<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Dokončení popisu komunikačních strategií poskytovaných knihovnou nanomsg</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Dokončení popisu komunikačních strategií poskytovaných knihovnou nanomsg</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešní části seriálu o message brokerech a k nim přidružených technologiích dokončíme popis základních komunikačních strategií poskytovaných knihovnou nanomsg. Všechny strategie budou pochopitelně implementovány i v demonstračních příkladech.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Komunikační strategie <strong>Publish-Subscribe</strong></a></p>
<p><a href="#k02">2. Zpracování většího množství zpráv při použití strategie <strong>Publish-Subscribe</strong></a></p>
<p><a href="#k03">3. Nastavení tématu (<i>topic</i>) pro strategii <strong>Publish-Subscribe</strong></a></p>
<p><a href="#k04">4. Implementace producenta zpráv</a></p>
<p><a href="#k05">5. Implementace různých konzumentů zpráv připojených k&nbsp;nastaveným tématům</a></p>
<p><a href="#k06">6. Komunikační strategie <strong>Request-Response</strong></a></p>
<p><a href="#k07">7. Implementace klienta používajícího strategii <strong>Request-Response</strong></a></p>
<p><a href="#k08">8. Implementace serveru zpracovávajícího požadavky</a></p>
<p><a href="#k09">9. Server zpracovávající dotazy v&nbsp;jediném vláknu</a></p>
<p><a href="#k10">10. Chování serveru při zpracování velkého množství dotazů</a></p>
<p><a href="#k11">11. Komunikační strategie <strong>Survey</strong></a></p>
<p><a href="#k12">12. Implementace klienta</a></p>
<p><a href="#k13">*** 13. Implementace serveru</a></p>
<p><a href="#k14">14. Ukázka poslání otázky a zpracování odpovědí</a></p>
<p><a href="#k15">*** 15. Komunikační strategie <strong>Bus</strong></a></p>
<p><a href="#k16">*** 16. Implementace prvního uzlu</a></p>
<p><a href="#k17">*** 17. Implementace druhého uzlu</a></p>
<p><a href="#k18">*** 18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Odkazy na předchozí části seriálu o message brokerech</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Komunikační strategie <strong>Publish-Subscribe</strong></h2>

<p><a
href="https://www.root.cz/clanky/implementace-ruznych-komunikacnich-strategii-s-vyuzitim-knihovny-nanomsg/">V&nbsp;předchozí
části</a> <a href="https://www.root.cz/serialy/message-brokery/">seriálu o
message brokerech</a> jsme se seznámili s&nbsp;některými možnostmi
poskytovanými nativní knihovnou (naprogramovanou v&nbsp;céčku) nazvanou
<i>nanomsg</i>. Jedná se o ideového nástupce knihovny <i>ØMQ</i>, kterou jsme
si již v&nbsp;tomto seriálu popsali [<a
href="https://www.root.cz/clanky/0mq-knihovna-pro-asynchronni-predavani-zprav/">1</a>]
[<a
href="https://www.root.cz/clanky/dalsi-moznosti-poskytovane-knihovnou-mq/">2</a>]
[<a
href="https://www.root.cz/clanky/vyuziti-zarizeni-v-knihovne-mq-pri-tvorbe-systemu-se-slozitejsi-architekturou/">3</a>]
[<a
href="https://www.root.cz/clanky/dalsi-moznosti-nabizene-knihovnou-mq-implementace-protokolu-mq-v-ciste-jave/">4</a>].
Oproti <i>ØMQ</i> došlo z&nbsp;pohledu vývojáře k&nbsp;několika podstatným
změnám a současně i ke zjednodušením, takže se například nemusíme starat o
takzvaný <i>kontext</i>. S&nbsp;využitím knihovny <i>nanomsg</i> je možné
vytvářet aplikace (resp.&nbsp;části aplikace), které mezi sebou komunikují
pomocí šesti typů strategií, které jsou vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Strategie/vzor</th><th>Stručný popis významu strategie</th></tr>
<tr><td>1</td><td>PAIR</td><td>jedna z&nbsp;nejjednodušších komunikačních strategií s&nbsp;dvojicí uzlů a vazbou 1:1; komunikace je obecně obousměrná (samozřejmě lze použít i komunikaci jednosměrnou)</td></tr>
<tr><td>2</td><td>BUS</td><td>složitější strategie, v&nbsp;níž se používá obecnější vazba M:N; tuto strategii si popíšeme <a href="#k15">v&nbsp;závěrečné části článku</a></td></tr>
<tr><td>3</td><td>PUBSUB</td><td>klasická komunikační strategie PUB-SUB neboli PUBLISH-SUBSCRIBE</td></tr>
<tr><td>4</td><td>REQREP</td><td>klasická komunikační strategie REQ-REP neboli REQUEST-RESPONSE, bude popsána <a href="#k06">v&nbsp;navazujících kapitolách</a></td></tr>
<tr><td>5</td><td>PIPELINE</td><td>jednosměrná komunikace buď s&nbsp;vazbami 1:1 (jeden vysílač a jeden přijímač), popř.&nbsp;mezi více vysílači a několika přijímači</td></tr>
<tr><td>6</td><td>SURVEY</td><td>speciální strategie umožňující získat stav více uzlů (procesů) jediným dotazem a mnoha odpovědmi; tato zcela nová strategie bude popsána <a href="#k11">v&nbsp;navazujících kapitolách</a></td></tr>
</table>

<p>Strategii pojmenovanou <strong>PIPELINE</strong> a zajišťující jednosměrný
přenos zpráv od vysílající aplikace (vlákna, procesu) k&nbsp;aplikaci
přijímající jsme si již popsali minule, konkrétně <a
href="https://www.root.cz/clanky/implementace-ruznych-komunikacnich-strategii-s-vyuzitim-knihovny-nanomsg/#k08">v&nbsp;osmé
kapitole</a>. Jedná se čistě o jednosměrnou komunikaci naznačenou na prvním
obrázku:</p>

<img src="https://i.iinfo.cz/images/248/zmq-2-5.png" class="image-35096" alt="&#160;" width="570" height="116" />
<p><i>Obrázek 1: Jednosměrná komunikace využívající strategii
<strong>PIPELINE</strong>.</i></p>

<p>Složitější komunikační schéma je zajištěno strategií <strong>PAIR</strong>
popsané minule <a
href="https://www.root.cz/clanky/implementace-ruznych-komunikacnich-strategii-s-vyuzitim-knihovny-nanomsg/#k12">ve
dvanácté kapitole</a>, která umožňuje buď jednosměrné posílání zpráv
z&nbsp;prvního uzlu do uzlu druhého:</p>

<img src="https://i.iinfo.cz/images/248/zmq-2-1.png" class="image-350896" alt="&#160;" width="570" height="100" />
<p><i>Obrázek 2: Jednosměrná komunikace využívající strategii
<strong>PAIR-PAIR</strong>.</i></p>

<p>nebo (a to častěji) obousměrné posílání zpráv:</p>

<img src="https://i.iinfo.cz/images/248/zmq-2-2.png" class="image-350897" alt="&#160;" width="570" height="100" />
<p><i>Obrázek 3: Obousměrná komunikace využívající strategii
<strong>PAIR-PAIR</strong>.</i></p>

<p>A konečně jsme si minule <a
href="https://www.root.cz/clanky/implementace-ruznych-komunikacnich-strategii-s-vyuzitim-knihovny-nanomsg/#k17">v&nbsp;sedmnácté
kapitole</a> ukázali (i když prozatím ve stručnosti) strategii typu
<strong>PUB-SUB</strong> či zkráceně pouze <strong>PUBSUB</strong>. Tato velmi
často používaná strategie umožňuje rozesílat zprávy libovolnému množství
příjemců (či v&nbsp;mezním případě žádnému příjemci):</p>

<img src="https://i.iinfo.cz/images/248/zmq-2-4.png" class="image-350899" alt="&#160;" width="570" height="200" />
<p><i>Obrázek 4: Jednosměrná komunikace využívající strategii
<strong>PUB-SUB</strong>.</i></p>

<p>V&nbsp;dnešním článku nejdříve dokončíme popis strategie
<strong>PUB-SUB</strong> a posléze se zaměříme na tři zbývající strategie
<strong>REQREP</strong>, <strong>SURVEY</strong> a <strong>BUS</strong>, které
jsou již nepatrně složitější, ovšem v&nbsp;některých případech i
užitečnější.</p>

<p>Všechny dále popsané demonstrační příklady budou vyvinuty
v&nbsp;programovacím jazyku C (většina jich je kompatibilních s&nbsp;ANSI C,
pouze u některých požadujeme funkce, které v&nbsp;tomto standardu neexistují),
protože rozhraními pro další programovací jazyky se budeme zabývat
v&nbsp;navazující části tohoto seriálu. Příklady jsou navíc napsány
s&nbsp;ohledem na co největší stručnost zápisu, takže u některých z&nbsp;nich
nejsou provedeny všechny kontroly chyb, jež by se ovšem v&nbsp;produkčním kódu
pochopitelně měly použít (na případné možnosti vylepšení se ovšem taktéž
zaměříme).</p>

<p>Pro překlad, slinkování a spuštění je u každého příkladu použit
<strong>Makefile</strong>, takže využijete příkaz/nástroj
<strong>make</strong>, který by měl být nainstalován.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Zpracování většího množství zpráv při použití strategie <strong>Publish-Subscribe</strong></h2>

<p><a
href="https://www.root.cz/clanky/implementace-ruznych-komunikacnich-strategii-s-vyuzitim-knihovny-nanomsg/">V&nbsp;úvodním
článku</a> o knihovně <i>nanomsg</i> jsme si mj.&nbsp;popsali i velmi často
používanou komunikační strategii nazvanou <strong>PUB-SUB</strong>, v&nbsp;níž
spolu komunikují dva typy uzlů: zdroje zpráv (<i>publishers</i>) a konzumenti
zpráv (<i>subscribers</i>). Konzumenti se mohou k&nbsp;odebírání zpráv kdykoli
přihlásit a kdykoli se také odpojit, což zdroj zpráv nijak neovlivní &ndash;
ten bude posílat zprávy nezávisle na tom, kdo je přijímá (v&nbsp;knihovně
<i>nanomsg</i> se i filtrace zpráv na základě témat/topiců provádí až na straně
konzumenta, nikoli na straně zdroje!).</p>

<p>Toto chování, v&nbsp;němž zcela cíleně chybí většina kontrolních a řídicích
mechanismů, má ovšem jeden důsledek, který je poměrně problematický a který
vyplývá z&nbsp;toho, že <i>nanomsg</i> ve skutečnosti není klasickým <i>message
brokerem</i>, ale jen &bdquo;pouhou&ldquo; knihovnou: pokud konzument zpráv
nebude mít k&nbsp;dispozici dostatečné množství prostředků ke zpracování zpráv,
může se stát, že nějakou zprávu nepřijme. Popsané chování si můžeme velmi
snadno odsimulovat, a to tak, že vytvoříme producenta, který odešle předem
nastavený počet zpráv, ovšem mezi posláním zpráv nebudou žádné pauzy &ndash;
producent tedy bude zprávy posílat maximální možnou rychlostí.</p>

<p><a
href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/07_publisher_subscriber_1000_messages/publisher.c">Úplný
zdrojový kód producenta</a> vypadá následovně:</p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include &lt;nanomsg/pubsub.h&gt;
&nbsp;
const int MAX_MESSAGES = 1000;
&nbsp;
const char *URL = "ipc:///tmp/example7";
&nbsp;
void <strong>report_error</strong>(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}
&nbsp;
void <strong>send_message</strong>(const int socket, const char *message)
{
    int bytes;
&nbsp;
    printf("Sending message '%s'\n", message);
    if ((bytes = nn_send(socket, message, strlen(message)+1, 0)) &lt; 0) {
        report_error("nn_send");
    }
    printf("Message with length %d bytes sent, flushing\n", bytes);
    sleep(1);
}
&nbsp;
void <strong>publisher</strong>(const char *url)
{
    int socket;
    int endpoint;
    int i;
&nbsp;
    if ((socket = nn_socket(AF_SP, NN_PUB)) &lt; 0) {
        report_error("nn_socket");
    }
    puts("Socket created");
&nbsp;
    if ((endpoint = nn_bind(socket, url)) &lt; 0) {
        report_error("nn_bind");
    }
    puts("Remote endpoint bound to the socket");
&nbsp;
    for (i=0; i &lt; MAX_MESSAGES; i++) {
        char buffer[45];
        int number = rand() % 10000;
        sprintf(buffer, "Hello, this is my top secret PIN: %04d", number);
        send_message(socket, buffer);
    }
&nbsp;
    if (nn_shutdown(socket, endpoint) &lt; 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}
&nbsp;
int <strong>main</strong>(const int argc, const char **argv)
{
    publisher(URL);
    return 0;
}
</pre>

<p>Samotný konzument, jehož <a
href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/07_publisher_subscriber_1000_messages/subscriber.c">úplný
zdrojový kód</a> je zobrazen pod tímto odstavcem, zůstal prakticky ve stejné
podobě, s&nbsp;jakou jsme se seznámili v&nbsp;předchozím článku:</p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include &lt;nanomsg/pubsub.h&gt;
&nbsp;
const char *URL = "ipc:///tmp/example7";
&nbsp;
void <strong>report_error</strong>(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}
&nbsp;
void <strong>receive_message</strong>(const int socket)
{
    char *message = NULL;
    int bytes;
&nbsp;
    if ((bytes = nn_recv(socket, &amp;message, NN_MSG, 0)) &lt; 0) {
        report_error("nn_recv");
    }
    printf("Received message '%s' with length %d bytes\n", message, bytes); 
    if (nn_freemsg(message) &lt; 0) {
        report_error("nn_freemsg");
    }
}
&nbsp;
void <strong>subscriber</strong>(const char *url)
{
    int socket;
    int endpoint;
    int messages;
&nbsp;
    if ((socket = nn_socket(AF_SP, NN_SUB)) &lt; 0) {
        report_error("nn_socket");
    }
    puts("Socket created");
&nbsp;
    if (nn_setsockopt(socket, NN_SUB, NN_SUB_SUBSCRIBE, "", 0) &lt; 0) {
        report_error("nn_setsockopt");
    }
&nbsp;
    if ((endpoint = nn_connect(socket, url)) &lt; 0) {
        report_error("nn_connect");
    }
    puts("Endpoint connected to socket");
&nbsp;
    puts("Waiting for messages...");
&nbsp;
    while (1) {
        receive_message(socket);
        messages++;
        printf("Processed %d messages so far\n", messages);
    }
&nbsp;
    if (nn_shutdown(socket, endpoint) &lt; 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}
&nbsp;
int <strong>main</strong>(int argc, char **argv)
{
    subscriber(URL);
    return 0;
}
</pre>

<p>Podívejme se ještě na soubor <a
href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/07_publisher_subscriber_1000_messages/Makefile">Makefile</a>
využitý jak pro překlad, tak i spuštění producenta i konzumenta:</p>

<pre>
CC=gcc
LINKER=gcc
&nbsp;
LIBS=nanomsg
&nbsp;
CFLAGS=-O0 -Wall -ansi -pedantic
LFLAGS=-l$(LIBS)
&nbsp;
LIBRARY_PATH=/usr/local/lib64/
&nbsp;
.PHONY: clean run_publisher run_subscriber
&nbsp;
all:    publisher subscriber
&nbsp;
%.o:    %.c
        $(CC) -c -o $@ $(CFLAGS) $&lt;
&nbsp;
publisher:      publisher.o
        $(CC) -o $@ $(LFLAGS) $&lt;
&nbsp;
subscriber:     subscriber.o
        $(CC) -o $@ $(LFLAGS) $&lt;
&nbsp;
clean:
        rm -f publisher.o \
        rm -f subscriber.o \
        rm -f publisher \
        rm -f subscriber
&nbsp;
run_publisher:
        LD_LIBRARY_PATH=$(LIBRARY_PATH) ./publisher
&nbsp;
run_subscriber:
        LD_LIBRARY_PATH=$(LIBRARY_PATH) ./subscriber
</pre>

<p>Podívejme se nyní na chování takto vytvořené architektury sestávající ze
dvou komunikujících uzlů &ndash; jednoho producenta a jednoho konzumenta zpráv.
Nejprve, například z&nbsp;nového terminálu, přeložíme a spustíme konzumenta
zpráv:</p>

<pre>
$ <strong>make consumer</strong>
&nbsp;
$ <strong>make run_consumer</strong>
&nbsp;
</pre>

<p>Dále pochopitelně budeme muset přeložit a spustit producenta:</p>

<pre>
$ <strong>make producer</strong>
&nbsp;
$ <strong>make run_producer</strong>
&nbsp;
</pre>

<p>Chování producenta je jednoduché a snadno pochopitelné &ndash; bude postupně
vytvářet a posílat (publikovat) zadaný počet zpráv.</p>

<p>Konzument se bude snažit tyto zprávy přijímat, ovšem (v&nbsp;závislosti na
mnoha faktorech) se mu to nemusí vždy podařit a může nějakou zprávu
vynechat:</p>

<pre>
...
...
...
Processed 564 messages so far
Received message 'Hello, this is my top secret PIN: 8382' with length 39 bytes
Processed 565 messages so far
Received message 'Hello, this is my top secret PIN: 5421' with length 39 bytes
Processed 566 messages so far
</pre>

<p><div class="rs-tip-major">Poznámka: můžeme zde vidět, že konzument zpracoval
pouze 566 zpráv z&nbsp;celkového počtu 1000.</div></p>

<p>Na toto chování můžeme v&nbsp;praxi narazit v&nbsp;mnoha případech. Zde se
konkrétně jedná o fakt, že je jak producent, tak i konzument spuštěn na jednom
počítači, takže záleží na tom, kdy dojde k&nbsp;přepnutí kontextu. U aplikací,
jejichž uzly jsou umístěny na různých počítačích a pro komunikaci se používá
síť, se může situace dále zkomplikovat. Jedno z&nbsp;možných řešení spočívá
v&nbsp;použití takzvaného <i>zařízení</i> (<i>device</i>) a v&nbsp;lepší správě
bufferů na straně producenta, ovšem my si vyzkoušíme, jak se chování změní ve
chvíli, kdy se mezi posláním jednotlivých zpráv vloží krátká pauza. Úprava bude
provedena následujícím způsobem:</p>

<pre>
void <strong>send_message</strong>(const int socket, const char *message)
{
    int bytes;
&nbsp;
    printf("Sending message '%s'\n", message);
    if ((bytes = nn_send(socket, message, strlen(message)+1, 0)) &lt; 0) {
        report_error("nn_send");
    }
    printf("Message with length %d bytes sent, flushing\n", bytes);
    <strong>usleep(100*1000);</strong>
}
</pre>

<p>S&nbsp;výsledkem, který je již mnohem lepší:</p>

<pre>
...
...
...
Processed 96 messages so far
Received message '8586 is my top secret PIN' with length 26 bytes
Processed 97 messages so far
Received message '8094 is my top secret PIN' with length 26 bytes
Processed 98 messages so far
Received message '7539 is my top secret PIN' with length 26 bytes
Processed 99 messages so far
</pre>

<p>Zbývá nám vyřešit ještě jeden problém, který spočívá v&nbsp;tom, že
konzument nepřijme první poslanou zprávu. Je to ostatně patrné i při pohledu na
jeho výstup zobrazený před tímto odstavcem.</p>

<p>Toto chování je ve skutečnosti možné napravit, a to zcela jednoduše.
Postačuje totiž, aby se vložila krátká pauza mezi voláním funkcí
<strong>nn_bind()</strong> a vlastním posíláním zpráv:</p>

<pre>
if ((endpoint = nn_bind(socket, url)) &lt; 0) {
    report_error("nn_bind");
}
puts("Remote endpoint bound to the socket");
&nbsp;
<strong>sleep(1);</strong>
&nbsp;
for (i=0; i &lt; MAX_MESSAGES; i++) {
    char buffer[45];
    int number = rand() % 10000;
    sprintf(buffer, "%04d is my top secret PIN", number);
    send_message(socket, buffer);
}
</pre>

<p>Výsledek je již mnohem lepší a bude odpovídat očekávanému chování:</p>

<pre>
...
...
...
Processed 97 messages so far
Received message '8586 is my top secret PIN' with length 26 bytes
Processed 98 messages so far
Received message '8094 is my top secret PIN' with length 26 bytes
Processed 99 messages so far
Received message '7539 is my top secret PIN' with length 26 bytes
Processed 100 messages so far
</pre>

<p><div class="rs-tip-major">Poznámka: zde jsme poprvé narazili na to, že
knihovna <i>nanomsg</i> je poměrně nízkoúrovňová, takže je nutné při tvorbě
aplikací myslet i na chování konkrétních operačních systémů. V&nbsp;knihovnách
napsaných nad <i>nanomsg</i> by měly být tyto stavy vyřešeny takovým způsobem,
aby se o ně již nemuseli programátoři sami starat.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Nastavení tématu (<i>topic</i>) pro strategii <strong>Publish-Subscribe</strong></h2>

<p>Při použití komunikační strategie <strong>PUB-SUB</strong> se velmi často
setkáme s&nbsp;požadavkem na to, aby se zprávy filtrovaly podle nastaveného
tématu (<i>topic</i>). V&nbsp;klasických implementacích message brokerů bývají
zprávy rozšířeny o hlavičku a téma bývá součástí této hlavičky. Ovšem knihovna
<i>nanomsg</i> je nízkoúrovňová, takže samotnou zprávu považuje za dále nijak
neinterpretovaná binární data. Tématem je poté <i>libovolný prefix</i>,
tj.&nbsp;několik prvních znaků zprávy, přičemž filtrace probíhá až u
konzumenta, nikoli u zdroje zpráv. Samotné nastavení filtrace zpráv lze provést
funkcí <strong>nn_setsockopt()</strong>, které se předá prefix a jeho
délka:</p>

<pre>
if (nn_setsockopt(socket, NN_SUB, NN_SUB_SUBSCRIBE, topic, strlen(topic)) &lt; 0) {
    report_error("nn_setsockopt");
}
else {
    printf("Topic set to '%s'\n", topic);
}
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Implementace producenta zpráv</h2>

<p>Zdroj (producent) zpráv, které budou filtrovány na základě nastaveného
tématu na straně konzumentů, se nebude nijak zásadně lišit od již popsaných
producentů, pouze si vystačíme jen se sto zprávami. Jeho <a
href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/11_pub_sub_topics/publisher.c">zdrojový
kód</a> je následující:</p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include &lt;nanomsg/pubsub.h&gt;
&nbsp;
const int MAX_MESSAGES = 100;
&nbsp;
const char *URL = "ipc:///tmp/example10";
&nbsp;
void <strong>report_error</strong>(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}
&nbsp;
void <strong>send_message</strong>(const int socket, const char *message)
{
    int bytes;

    printf("Sending message '%s'\n", message);
    if ((bytes = nn_send(socket, message, strlen(message)+1, 0)) &lt; 0) {
        report_error("nn_send");
    }
    printf("Message with length %d bytes sent, flushing\n", bytes);
    usleep(100*1000);
}
&nbsp;
void <strong>publisher</strong>(const char *url)
{
    int socket;
    int endpoint;
    int i;
&nbsp;
    if ((socket = nn_socket(AF_SP, NN_PUB)) &lt; 0) {
        report_error("nn_socket");
    }
    puts("Socket created");
&nbsp;
    if ((endpoint = nn_bind(socket, url)) &lt; 0) {
        report_error("nn_bind");
    }
    puts("Remote endpoint bound to the socket");
&nbsp;
    for (i=0; i &lt; MAX_MESSAGES; i++) {
        char buffer[45];
        int number = rand() % 10000;
        sprintf(buffer, "%04d is my top secret PIN", number);
        send_message(socket, buffer);
    }
&nbsp;
    if (nn_shutdown(socket, endpoint) &lt; 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}
&nbsp;
int <strong>main</strong>(const int argc, const char **argv)
{
    publisher(URL);
    return 0;
}
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že zprávy vždy začínají
celým čtyřciferným číslem od 0000 do 9999.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Implementace různých konzumentů zpráv připojených k&nbsp;nastaveným tématům</h2>

<p>Zatímco u producenta došlo jen k&nbsp;nepatrné změně, konkrétně
k&nbsp;přesunu čísla s&nbsp;PINem na začátek zprávy, budou konzumenti odlišní.
První z&nbsp;nich bude zpracovávat jen ty zprávy, které začínají znakem
&bdquo;0&ldquo;, které je zde považováno za téma:</p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include &lt;nanomsg/pubsub.h&gt;
&nbsp;
const char *URL = "ipc:///tmp/example10";
&nbsp;
void <strong>report_error</strong>(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}
&nbsp;
void <strong>receive_message</strong>(const int socket)
{
    char *message = NULL;
    int bytes;
&nbsp;
    if ((bytes = nn_recv(socket, &amp;message, NN_MSG, 0)) &lt; 0) {
        report_error("nn_recv");
    }
    printf("Received message '%s' with length %d bytes\n", message, bytes); 
    if (nn_freemsg(message) &lt; 0) {
        report_error("nn_freemsg");
    }
}
&nbsp;
void <strong>subscriber</strong>(const char *url)
{
    const char *topic = "0";
&nbsp;
    int socket;
    int endpoint;
    int messages;
&nbsp;
    if ((socket = nn_socket(AF_SP, NN_SUB)) &lt; 0) {
        report_error("nn_socket");
    }
    puts("Socket created");
&nbsp;
    if (nn_setsockopt(socket, NN_SUB, NN_SUB_SUBSCRIBE, topic, strlen(topic)) &lt; 0) {
        report_error("nn_setsockopt");
    }
    else {
        printf("Topic set to '%s'\n", topic);
    }
&nbsp;
    if ((endpoint = nn_connect(socket, url)) &lt; 0) {
        report_error("nn_connect");
    }
    puts("Endpoint connected to socket");
&nbsp;
    puts("Waiting for messages...");
&nbsp;
    while (1) {
        receive_message(socket);
        messages++;
        printf("Processed %d messages so far\n", messages);
    }
&nbsp;
    if (nn_shutdown(socket, endpoint) &lt; 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}
&nbsp;
int <strong>main</strong>(int argc, char **argv)
{
    subscriber(URL);
    return 0;
}
</pre>

<p>Druhý konzument se odlišuje pouze v&nbsp;jinak nastaveném tématu:</p>

<pre>
const char *topic = "1";
</pre>

<p>A konečně třetí konzument akceptuje všechny zprávy.</p>

<p>Chování jednotlivých konzumentů:</p>

<pre>
$ <strong>make run_subscriber_0</strong>
&nbsp;
LD_LIBRARY_PATH=/usr/local/lib64/ ./subscriber_0
Socket created
Topic set to '0'
Endpoint connected to socket
Waiting for messages...
Received message '0886 is my top secret PIN' with length 26 bytes
Processed 1 messages so far
Received message '0492 is my top secret PIN' with length 26 bytes
Processed 2 messages so far
Received message '0027 is my top secret PIN' with length 26 bytes
Processed 3 messages so far
Received message '0059 is my top secret PIN' with length 26 bytes
Processed 4 messages so far
Received message '0540 is my top secret PIN' with length 26 bytes
Processed 5 messages so far
Received message '0925 is my top secret PIN' with length 26 bytes
Processed 6 messages so far
Received message '0336 is my top secret PIN' with length 26 bytes
Processed 7 messages so far
Received message '0846 is my top secret PIN' with length 26 bytes
Processed 8 messages so far
Received message '0545 is my top secret PIN' with length 26 bytes
Processed 9 messages so far
Received message '0364 is my top secret PIN' with length 26 bytes
Processed 10 messages so far
Received message '0012 is my top secret PIN' with length 26 bytes
Processed 11 messages so far
</pre>

<pre>
$ <strong>make run_subscriber_1</strong>
&nbsp;
LD_LIBRARY_PATH=/usr/local/lib64/ ./subscriber_1
Socket created
Topic set to '1'
Endpoint connected to socket
Waiting for messages...
Received message '1421 is my top secret PIN' with length 26 bytes
Processed 1 messages so far
Received message '1530 is my top secret PIN' with length 26 bytes
Processed 2 messages so far
Received message '1393 is my top secret PIN' with length 26 bytes
Processed 3 messages so far
Received message '1873 is my top secret PIN' with length 26 bytes
Processed 4 messages so far
Received message '1729 is my top secret PIN' with length 26 bytes
Processed 5 messages so far
Received message '1313 is my top secret PIN' with length 26 bytes
Processed 6 messages so far
Received message '1087 is my top secret PIN' with length 26 bytes
Processed 7 messages so far
</pre>

<pre>
$ <strong>make run_subscriber_all</strong>
&nbsp;
LD_LIBRARY_PATH=/usr/local/lib64/ ./subscriber_all
Socket created
Endpoint connected to socket
Waiting for messages...
Received message '0886 is my top secret PIN' with length 26 bytes
Processed 1 messages so far
Received message '2777 is my top secret PIN' with length 26 bytes
Processed 2 messages so far
Received message '6915 is my top secret PIN' with length 26 bytes
Processed 3 messages so far
Received message '7793 is my top secret PIN' with length 26 bytes
Processed 4 messages so far
Received message '8335 is my top secret PIN' with length 26 bytes
Processed 5 messages so far
Received message '5386 is my top secret PIN' with length 26 bytes
Processed 6 messages so far
Received message '0492 is my top secret PIN' with length 26 bytes
Processed 7 messages so far
Received message '6649 is my top secret PIN' with length 26 bytes
Processed 8 messages so far
Received message '1421 is my top secret PIN' with length 26 bytes
Processed 9 messages so far
Received message '2362 is my top secret PIN' with length 26 bytes
Processed 10 messages so far
</pre>

<p><div class="rs-tip-major">Poznámka: můžeme vidět, že první konzument
skutečně akceptuje pouze zprávy začínající na řetězec &bdquo;0&ldquo;, druhý
konzument zprávy začínající řetězcem &bdquo;1&ldquo; a třetí konzument čte
všechny zprávy bez ohledu na jejich prefix.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Komunikační strategie <strong>Request-Response</strong></h2>

<p>Další velmi často používaná komunikační strategie se nazývá
<i>Request-Response</i> nebo zkráceně <i>REQ-REP</i> popř.&nbsp;pouze
<i>REQREP</i>. Při použití této strategie spolu komunikují dva typy uzlů
&ndash; <i>server</i> a teoreticky neomezené množství klientů. Server přijímá
požadavky (<i>request</i>) a odpovídá na ně (<i>response</i>), přičemž je
možné, aby požadavky posílalo několik klientů (a jeden klient naopak může
v&nbsp;případě potřeby posílat požadavky více serverům). Tato velmi asymetrická
komunikace se strategií REQ-REP je v&nbsp;praxi poměrně častá, ostatně je na ní
založen i známý protokol <a
href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">HTTP</a> a
jeho pozdější varianty (dokonce se někdy nad HTTP staví jiné komunikační
strategie, což je ovšem neoptimální řešení).</p>

<p>Nejjednodušší forma komunikace probíhá mezi pouhými dvěma uzly, jak je to
naznačeno na dalším obrázku:</p>

*** image ***
<p><i>Obrázek 5: Obousměrná komunikace využívající strategii
<strong>REQ-REP</strong> mezi jedním klientem a jedním serverem.</i></p>

<p>Samozřejmě nám však nic nebrání v&nbsp;použití většího množství klientů,
které se připojí k&nbsp;jednomu serveru:</p>

<img src="https://i.iinfo.cz/images/248/zmq-2-3.png" class="image-350898" alt="&#160;" width="570" height="200" />
<p><i>Obrázek 6: Obousměrná komunikace využívající strategii
<strong>REQ-REP</strong> mezi dvěma klienty a jedním serverem.</i></p>

<p><div class="rs-tip-major">Poznámka: nikdo pochopitelně nebrání ani tomu, aby
se jeden klient postupně připojoval na různé servery (ovšem s&nbsp;využitím
různých socketů).</div></p>

<p>Tato komunikační strategie vyžaduje, aby server používal sockety typu
<strong>NN_REP</strong> a klienti sockety typu <strong>NN_REQ</strong>. Server
typicky využívá funkci <strong>nn_bind()</strong>, klienti funkci
<strong>nn_connect()</strong>, protože port (či koncový bod) serveru je
z&nbsp;pohledu administrace systému &bdquo;stabilní&ldquo;, na rozdíl od
klientů.  Komunikaci vždy iniciuje klient posláním požadavku (<i>request</i>);
server na tento požadavek odpovídá (<i>response</i>). Jedná se o strategii
umožňující load balancing a taktéž znovuodeslání požadavku, pokud
v&nbsp;nastaveném čase nepřišla žádná odpověď.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Implementace klienta používajícího strategii <strong>Request-Response</strong></h2>

<p>Nejprve si ukažme, jak vypadá implementace klienta používajícího strategii
<i>REQ-REP</i>. Ta je ve skutečnosti velmi jednoduchá, protože postačuje
otevřít socket se specifikací strategie <strong>NN_REQ</strong>, poslat
požadavek s&nbsp;využitím funkce <strong>nn_send()</strong> a následně počkat a
přijmout výsledek (odpověď serveru) funkcí <strong>nn_recv()</strong>. Pro
lepší přehlednost příkladu je poslání požadavku implementováno
v&nbsp;uživatelské funkci nazvané <strong>send_request()</strong> a přijetí
odpovědi serveru ve funkci nazvané <strong>receive_response()</strong>.</p>

<p>Vytvoření socketu a připojení k&nbsp;serveru:</p>

<pre>
if ((socket = nn_socket(AF_SP, <strong>NN_REQ</strong>)) &lt; 0) {
    report_error("nn_socket");
}
&nbsp;
if ((endpoint = nn_connect(socket, url)) &lt; 0) {
    report_error("nn_connect");
}
</pre>

<p>Poslání zprávy (přesněji řečeno požadavku):</p>

<pre>
void <strong>send_request</strong>(const int socket, const char *message)
{
    int bytes;
&nbsp;
    printf("Sending message '%s'\n", message);
    if ((bytes = nn_send(socket, message, strlen(message)+1, 0)) &lt; 0) {
        report_error("nn_send");
    }
    printf("Message with length %d bytes sent, flushing\n", bytes);
    sleep(1);
}
</pre>

<p>Příjem zprávy (přesněji řečeno odpovědi serveru):</p>

<pre>
void <strong>receive_response</strong>(const int socket)
{
    char *response = NULL;
    int bytes;
&nbsp;
    if ((bytes = nn_recv(socket, &amp;response, NN_MSG, 0)) &lt; 0) {
        report_error("nn_recv");
    }
    printf("Received response '%s' with length %d bytes\n", response, bytes); 
    if (nn_freemsg(response) &lt; 0) {
        report_error("nn_freemsg");
    }
}
</pre>

<p><a
href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/12_req_res/client.c">Úplný
zdrojový kód klienta</a> vypadá následovně:</p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include &lt;nanomsg/reqrep.h&gt;
&nbsp;
const char *URL = "ipc:///tmp/example11";
&nbsp;
void <strong>report_error</strong>(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}
&nbsp;
void <strong>send_request</strong>(const int socket, const char *message)
{
    int bytes;
&nbsp;
    printf("Sending message '%s'\n", message);
    if ((bytes = nn_send(socket, message, strlen(message)+1, 0)) &lt; 0) {
        report_error("nn_send");
    }
    printf("Message with length %d bytes sent, flushing\n", bytes);
    sleep(1);
}
&nbsp;
void <strong>receive_response</strong>(const int socket)
{
    char *response = NULL;
    int bytes;
&nbsp;
    if ((bytes = nn_recv(socket, &amp;response, NN_MSG, 0)) &lt; 0) {
        report_error("nn_recv");
    }
    printf("Received response '%s' with length %d bytes\n", response, bytes); 
    if (nn_freemsg(response) &lt; 0) {
        report_error("nn_freemsg");
    }
}
&nbsp;
void <strong>client</strong>(const char *url)
{
    int socket;
    int endpoint;
&nbsp;
    if ((socket = nn_socket(AF_SP, NN_REQ)) &lt; 0) {
        report_error("nn_socket");
    }
    puts("Socket created");
&nbsp;
    if ((endpoint = nn_connect(socket, url)) &lt; 0) {
        report_error("nn_connect");
    }
    puts("Remote endpoint added to the socket");
&nbsp;
    send_request(socket, "Hello from 'first'!");
&nbsp;
    puts("Waiting for response...");
    receive_response(socket);
&nbsp;
    if (nn_shutdown(socket, endpoint) &lt; 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}
&nbsp;
int <strong>main</strong>(const int argc, const char **argv)
{
    client(URL);
    return 0;
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Implementace serveru zpracovávajícího požadavky</h2>

<p>Server založený na strategii <i>REQ-REP</i> bude používat socket typu
<strong>NN_REP</strong> a pro vytvoření koncového bodu pochopitelně použijeme
funkci <strong>nn_bind()</strong> a nikoli <strong>nn_connect()</strong>:</p>

<pre>
if ((socket = nn_socket(AF_SP, NN_REP)) &lt; 0) {
    report_error("nn_socket");
}
&nbsp;
if ((endpoint = nn_bind(socket, url)) &lt; 0) {
    report_error("nn_bind");
}
</pre>

<p>Zcela nejjednodušší varianta serveru přijme pouze jediný požadavek a pošle
na něj odpověď zpět klientovi. Žádné další požadavky již nebudou akceptovány,
protože se server odpojí:</p>

<pre>
receive_request(socket);
&nbsp;
send_response(socket, "ACK!");
&nbsp;
if (nn_shutdown(socket, endpoint) &lt; 0) {
    report_error("nn_shutdown");
}
</pre>

<p>Samozřejmě si opět ukážeme úplný zdrojový kód serveru, který <a
href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/12_req_res/server.c">vypadá
následovně</a>:</p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include &lt;nanomsg/reqrep.h&gt;
&nbsp;
const char *URL = "ipc:///tmp/example11";
&nbsp;
void <strong>report_error</strong>(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}
&nbsp;
void <strong>receive_request</strong>(const int socket)
{
    char *message = NULL;
    int bytes;
&nbsp;
    if ((bytes = nn_recv(socket, &amp;message, NN_MSG, 0)) &lt; 0) {
        report_error("nn_recv");
    }
    printf("Received message '%s' with length %d bytes\n", message, bytes); 
    if (nn_freemsg(message) &lt; 0) {
        report_error("nn_freemsg");
    }
}
&nbsp;
void <strong>send_response</strong>(const int socket, const char *response)
{
    int bytes;
&nbsp;
    printf("Sending response '%s'\n", response);
    if ((bytes = nn_send(socket, response, strlen(response)+1, 0)) &lt; 0) {
        report_error("nn_send");
    }
    printf("Response with length %d bytes sent, flushing\n", bytes);
    sleep(1);
}
&nbsp;
void <strong>server</strong>(const char *url)
{
    int socket;
    int endpoint;
&nbsp;
    if ((socket = nn_socket(AF_SP, NN_REP)) &lt; 0) {
        report_error("nn_socket");
    }
    puts("Socket created");
&nbsp;
    if ((endpoint = nn_bind(socket, url)) &lt; 0) {
        report_error("nn_bind");
    }
    puts("Endpoint bound to socket");
&nbsp;
    puts("Waiting for message...");
    receive_request(socket);
&nbsp;
    send_response(socket, "ACK!");
&nbsp;
    if (nn_shutdown(socket, endpoint) &lt; 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}
&nbsp;
int <strong>main</strong>(int argc, char **argv)
{
    server(URL);
    return 0;
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Server zpracovávající dotazy v&nbsp;jediném vláknu</h2>

<p>Pochopitelně nám nic nebrání ve vytvoření serveru, který bude jednotlivé
dotazy zpracovávat postupně a v&nbsp;takovém pořadí, v&nbsp;jakém je bude
přijímat. Prozatím nepoužijeme žádnou formu multitaskingu ani multithreadingu,
protože toto řešení není ideální &ndash; výhodnější je použít takzvaná
<i>zařízení</i> (<i>device</i>).</p>

<p>Zdrojový kód takto upraveného serveru naleznete na adrese <a
href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/13_req_res_single_thread/server.c">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/13_req_res_single_thread/server.c</a>:</p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include &lt;nanomsg/reqrep.h&gt;
&nbsp;
const char *URL = "ipc:///tmp/example12";
&nbsp;
void <strong>report_error</strong>(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}
&nbsp;
void <strong>receive_request</strong>(socket)
{
    char *message = NULL;
    int bytes;
&nbsp;
    if ((bytes = nn_recv(socket, &amp;message, NN_MSG, 0)) &lt; 0) {
        report_error("nn_recv");
    }
    printf("Received message '%s' with length %d bytes\n", message, bytes); 
    if (nn_freemsg(message) &lt; 0) {
        report_error("nn_freemsg");
    }
}
&nbsp;
void <strong>send_response</strong>(const int socket, const char *response)
{
    int bytes;
&nbsp;
    printf("Sending response '%s'\n", response);
    if ((bytes = nn_send(socket, response, strlen(response)+1, 0)) &lt; 0) {
        report_error("nn_send");
    }
    printf("Response with length %d bytes sent, flushing\n", bytes);
    sleep(1);
}
&nbsp;
void server(const char *url)
{
    int socket;
    int endpoint;
&nbsp;
    if ((socket = nn_socket(AF_SP, NN_REP)) &lt; 0) {
        report_error("nn_socket");
    }
    puts("Socket created");
&nbsp;
    if ((endpoint = nn_bind(socket, url)) &lt; 0) {
        report_error("nn_bind");
    }
    puts("Endpoint bound to socket");
&nbsp;
    puts("Waiting for messages...");
    while (1) {
        receive_request(socket);
        send_response(socket, "ACK!");
    }
&nbsp;
    if (nn_shutdown(socket, endpoint) &lt; 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}
&nbsp;
int main(int argc, char **argv)
{
    server(URL);
    return 0;
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Chování serveru při zpracování velkého množství dotazů</h2>

<p>Na rozdíl od strategie <i>PUB-SUB</i> by se při použití strategie
<i>REQ-REP</i> neměly žádné zprávy ztrácet. Můžeme se o tom snadno přesvědčit
úpravou klienta i serveru.</p>

<p>Klient, jehož zdrojový kód je možné nalézt na adrese <a
href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/13_req_res_single_thread/client.c">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/13_req_res_single_thread/client.c</a>,
je nakonfigurován tak, aby poslal celkem 100 zpráv:</p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include &lt;nanomsg/reqrep.h&gt;
&nbsp;
const int MESSAGES = 100;
&nbsp;
const char *URL = "ipc:///tmp/example13";
&nbsp;
void <strong>report_error</strong>(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}
&nbsp;
void <strong>send_request</strong>(const int socket, const char *message)
{
    int bytes;
&nbsp;
    printf("Sending message '%s'\n", message);
    if ((bytes = nn_send(socket, message, strlen(message)+1, 0)) &lt; 0) {
        report_error("nn_send");
    }
    printf("Message with length %d bytes sent, flushing\n", bytes);
}
&nbsp;
void <strong>receive_response</strong>(socket)
{
    char *response = NULL;
    int bytes;
&nbsp;
    if ((bytes = nn_recv(socket, &amp;response, NN_MSG, 0)) &lt; 0) {
        report_error("nn_recv");
    }
    printf("Received response '%s' with length %d bytes\n", response, bytes); 
    if (nn_freemsg(response) &lt; 0) {
        report_error("nn_freemsg");
    }
}
&nbsp;
void <strong>client</strong>(const char *url)
{
    int socket;
    int endpoint;
    int i;
&nbsp;
    if ((socket = nn_socket(AF_SP, NN_REQ)) &lt; 0) {
        report_error("nn_socket");
    }
    puts("Socket created");
&nbsp;
    if ((endpoint = nn_connect(socket, url)) &lt; 0) {
        report_error("nn_connect");
    }
    puts("Remote endpoint added to the socket");
&nbsp;
    for (i=0; i &lt; MESSAGES; i++) {
        send_request(socket, "Hello from 'first'!");
&nbsp;
        puts("Waiting for response...");
        receive_response(socket);
    }
&nbsp;
    if (nn_shutdown(socket, endpoint) &lt; 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}
&nbsp;
int <strong>main</strong>(const int argc, const char **argv)
{
    client(URL);
    return 0;
}
</pre>

<p><a
href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/14_req_resp_fast/server.c">Server</a>
tyto zprávy bude přijímat a současně vypíše, kolik zpráv již dokázal
zpracovat:</p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include &lt;nanomsg/reqrep.h&gt;
&nbsp;
const char *URL = "ipc:///tmp/example13";
&nbsp;
void <strong>report_error</strong>(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}
&nbsp;
void <strong>receive_request</strong>(socket)
{
    char *message = NULL;
    int bytes;
&nbsp;
    if ((bytes = nn_recv(socket, &amp;message, NN_MSG, 0)) &lt; 0) {
        report_error("nn_recv");
    }
    printf("Received message '%s' with length %d bytes\n", message, bytes); 
    if (nn_freemsg(message) &lt; 0) {
        report_error("nn_freemsg");
    }
}
&nbsp;
void <strong>send_response</strong>(const int socket, const char *response)
{
    int bytes;
&nbsp;
    printf("Sending response '%s'\n", response);
    if ((bytes = nn_send(socket, response, strlen(response)+1, 0)) &lt; 0) {
        report_error("nn_send");
    }
    printf("Response with length %d bytes sent, flushing\n", bytes);
}
&nbsp;
void <strong>server</strong>(const char *url)
{
    int socket;
    int endpoint;
    int messages;
&nbsp;
    if ((socket = nn_socket(AF_SP, NN_REP)) &lt; 0) {
        report_error("nn_socket");
    }
    puts("Socket created");
&nbsp;
    if ((endpoint = nn_bind(socket, url)) &lt; 0) {
        report_error("nn_bind");
    }
    puts("Endpoint bound to socket");
&nbsp;
    puts("Waiting for messages...");
    while (1) {
        receive_request(socket);
        send_response(socket, "ACK!");
        messages++;
        printf("Processed %d messages so far\n", messages);
    }
&nbsp;
    if (nn_shutdown(socket, endpoint) &lt; 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}
&nbsp;
int <strong>main</strong>(int argc, char **argv)
{
    server(URL);
    return 0;
}
</pre>

<p>Chování klienta:</p>

<pre>
</pre>

<p>Chování serveru:</p>

<pre>
$ <strong>make run_server</strong>
&nbsp;
LD_LIBRARY_PATH=/usr/local/lib64/ ./server
Socket created
Endpoint bound to socket
Waiting for messages...
Received message 'Hello from 'first'!' with length 20 bytes
Sending response 'ACK!'
Response with length 5 bytes sent, flushing
Processed 1 messages so far
Received message 'Hello from 'first'!' with length 20 bytes
Sending response 'ACK!'
...
...
...
Processed 97 messages so far
Received message 'Hello from 'first'!' with length 20 bytes
Sending response 'ACK!'
Response with length 5 bytes sent, flushing
Processed 98 messages so far
Received message 'Hello from 'first'!' with length 20 bytes
Sending response 'ACK!'
Response with length 5 bytes sent, flushing
Processed 99 messages so far
Received message 'Hello from 'first'!' with length 20 bytes
Sending response 'ACK!'
Response with length 5 bytes sent, flushing
Processed 100 messages so far
</pre>

<p>Chování klienta:</p>

<pre>
$ <strong>make run_client </strong>
&nbsp;
LD_LIBRARY_PATH=/usr/local/lib64/ ./client
Socket created
Remote endpoint added to the socket
Sending message 'Hello from 'first'!'
Message with length 20 bytes sent, flushing
Waiting for response...
Received response 'ACK!' with length 5 bytes
Sending message 'Hello from 'first'!'
Message with length 20 bytes sent, flushing
Waiting for response...
...
...
...
</pre>

<p><div class="rs-tip-major">Poznámka: při komunikaci tímto způsobem nedochází
ke ztrátám zpráv, klient ovšem v&nbsp;některých případech musí déle čekat na
akceptaci zprávy a poslání odpovědi.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Komunikační strategie <strong>Survey</strong></h2>

<p>V&nbsp;pořadí již pátou komunikační strategií, se kterou se dnes seznámíme,
je strategie nazvaná <strong>Survey</strong>. Jedná se o dosti příhodný název,
protože v&nbsp;této strategii vystupuje jeden uzel, který se dotáže ostatních
uzlů například na jejich stav a uzly následně mohou odpovídat. Dotazující se
uzel má nastavenu dobu čekání, takže může jednotlivé odpovědi zaznamenat a po
uplynutí zadaného časového okamžiku zjistit, které uzly vůbec neodpověděly
(nebo to nestihly, což je ovšem z&nbsp;pohledu dotazujícího to samé):</p>

*** image ***
<p><i>Obrázek 7: Komunikační strategie <strong>Survey</strong>.</i></p>

<p>Tato strategie je v&nbsp;praxi velmi užitečná, protože umožňuje například
sledování velkého množství čidel, počítačů v&nbsp;clusteru atd., aniž by tato
zařízení musela aktivně někam posílat svůj stav, typicky s&nbsp;využitím
strategie <strong>PUB-SUB</strong>. Nevýhodou může být nárazový způsob
využívání sítě, to ovšem již do určité míry záleží na její topologii.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Implementace klienta</h2>

<p>Implementace klienta odpovídajícího na otázky serveru je relativně
jednoduchá a nalezneme ji na adrese <a
href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/15_survey/client.c">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/15_survey/client.c</a>.
Povšimněte si, že klient v&nbsp;odpovědi pošle pseudonáhodné číslo:</p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include &lt;nanomsg/survey.h&gt;
&nbsp;
const char *URL = "ipc:///tmp/example14";
&nbsp;
void <strong>report_error</strong>(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}
&nbsp;
void <strong>receive_question</strong>(const int socket)
{
    char *message = NULL;
    int bytes;
&nbsp;
    if ((bytes = nn_recv(socket, &amp;message, NN_MSG, 0)) &lt; 0) {
        report_error("nn_recv");
    }
    printf("Received message '%s' with length %d bytes\n", message, bytes); 
    if (nn_freemsg(message) &lt; 0) {
        report_error("nn_freemsg");
    }
}
&nbsp;
void <strong>send_answer</strong>(const int socket, const char *answer)
{
    int bytes;
&nbsp;
    printf("Sending answer '%s'\n", answer);
    if ((bytes = nn_send(socket, answer, strlen(answer)+1, 0)) &lt; 0) {
        report_error("nn_send");
    }
    printf("Answer with length %d bytes sent, flushing\n", bytes);
}
&nbsp;
#define ANSWER_LENGTH 100
&nbsp;
void <strong>client</strong>(const char *url)
{
    int socket;
    int endpoint;
    char answer[ANSWER_LENGTH];
    int number;
&nbsp;
    if ((socket = nn_socket(AF_SP, NN_RESPONDENT)) &lt; 0) {
        report_error("nn_socket");
    }
    puts("Socket created");
&nbsp;
    if ((endpoint = nn_connect(socket, url)) &lt; 0) {
        report_error("nn_connect");
    }
    puts("Remote endpoint added to the socket");
&nbsp;
    while (1) {
        receive_question(socket);
        puts("Question received");
&nbsp;
        /* nemame vypocetni vykon Hlubiny mysleni... */
        srand((unsigned) getpid());
        number = rand() % 100;
&nbsp;
        snprintf(answer, ANSWER_LENGTH, "It must be %d", number);
        send_answer(socket, answer);
        puts("Answer sent");
    }
&nbsp;
    if (nn_shutdown(socket, endpoint) &lt; 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}
&nbsp;
int <strong>main</strong>(const int argc, const char **argv)
{
    client(URL);
    return 0;
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Implementace serveru</h2>

<p></p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include <nanomsg/survey.h>

const char *URL = "ipc:///tmp/example14";

void report_error(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}

void send_survey(const int socket, const char *message)
{
    int bytes;

    printf("Sending message '%s'\n", message);
    if ((bytes = nn_send(socket, message, strlen(message)+1, 0)) &lt; 0) {
        report_error("nn_send");
    }
    printf("Message with length %d bytes sent, flushing\n", bytes);
}

void receive_answer(const int socket)
{
    char *response = NULL;
    int bytes;

    if ((bytes = nn_recv(socket, &response, NN_MSG, 0)) &lt; 0) {
        report_error("nn_recv");
    }
    printf("Received answer '%s' with length %d bytes\n", response, bytes); 
    if (nn_freemsg(response) &lt; 0) {
        report_error("nn_freemsg");
    }
}

void wait_for_clients(int seconds)
{
    int i;
    puts("Waiting for clients to connect...");
    for (i=10; i>0; i--) {
        printf("%d  ", i);
        fflush(stdout);
        sleep(1);
    }
    puts("\nDone");
}

void server(const char *url)
{
    int socket;
    int endpoint;
    int answers;

    if ((socket = nn_socket(AF_SP, NN_SURVEYOR)) &lt; 0) {
        report_error("nn_socket");
    }
    puts("Socket created");

    if ((endpoint = nn_bind(socket, url)) &lt; 0) {
        report_error("nn_bind");
    }
    puts("Endpoint bound to socket");

    wait_for_clients(10);

    send_survey(socket, "What do you get when you multiply six by nine?");
    puts("Survey send, waiting for answers...");

    while (1) {
        receive_answer(socket);
        answers++;
        printf("Processed %d answers so far\n", answers);
    }

    if (nn_shutdown(socket, endpoint) &lt; 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}

int main(int argc, char **argv)
{
    server(URL);
    return 0;
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Ukázka poslání otázky a zpracování odpovědí</h2>

<p>Podívejme se nyní na to, jakým způsobem bude pracovat server. Nejprve se
spustí a počká deset sekund na připojení klientů (ty spustíme například
v&nbsp;paralelně běžících terminálech):</p>

<pre>
Socket created
Endpoint bound to socket
Waiting for clients to connect...
10  9  8  7  6  5  4  3  2  1  
Done
</pre>

<p>Následně server pošle dotaz, a to všem aktuálně připojeným klientům. Ihned
po poslání dotazu začne očekávat jednotlivé odpovědi:</p>

<pre>
Sending message 'What do you get when you multiply six by nine?'
Message with length 47 bytes sent, flushing
Survey send, waiting for answers...
</pre>

<p>Odpovědi skutečně dostane, a to v&nbsp;našem konkrétním případě tři (od
třech klientů):</p>

<pre>
Received answer 'It must be 99' with length 14 bytes
Processed 1 answers so far
Received answer 'It must be 88' with length 14 bytes
Processed 2 answers so far
Received answer 'It must be 73' with length 14 bytes
Processed 3 answers so far
</pre>

<p>Následně ovšem již další odpovědi nepřijdou a dojde k&nbsp;detekovatelné
chybě (timeout):</p>

<pre>
nn_recv: Connection timed out
make: *** [Makefile:34: run_server] Error 1
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;praxi by samozřejmě bylo možné,
aby se server z&nbsp;timeoutu nějakým způsobem &bdquo;vzpamatoval&ldquo; a
pokračoval v&nbsp;další činnosti.</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Komunikační strategie <strong>Bus</strong></h2>

<p></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Implementace prvního uzlu</h2>

<p></p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include <nanomsg/bus.h>
&nbsp;
const char *URL = "ipc:///tmp/example14";
&nbsp;
void report_error(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}
&nbsp;
void receive_message(const int socket)
{
    char *message = NULL;
    int bytes;
&nbsp;
    if ((bytes = nn_recv(socket, &message, NN_MSG, 0)) < 0) {
        report_error("nn_recv");
    }
    printf("Received message '%s' with length %d bytes\n", message, bytes); 
    if (nn_freemsg(message) < 0) {
        report_error("nn_freemsg");
    }
}
&nbsp;
void node1(const char *url)
{
    int socket;
    int endpoint;
    int messages = 0;
&nbsp;
    if ((socket = nn_socket(AF_SP, NN_BUS)) < 0) {
        report_error("nn_socket");
    }
    puts("Socket created");
&nbsp;
    if ((endpoint = nn_bind(socket, url)) < 0) {
        report_error("nn_bind");
    }
    printf("Remote endpoint %s bound to the socket\n", url);
&nbsp;
    puts("Waiting for messages...");
&nbsp;
    while (1) {
        receive_message(socket);
        messages++;
        printf("Processed %d messages so far\n", messages);
    }
&nbsp;
    if (nn_shutdown(socket, endpoint) < 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}
&nbsp;
int main(const int argc, const char **argv)
{
    node1(URL);
    return 0;
}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Implementace druhého uzlu</h2>

<p></p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;nanomsg/nn.h&gt;
#include <nanomsg/bus.h>
&nbsp;
const char *URL = "ipc:///tmp/example14";
&nbsp;
void report_error(const char *func)
{
    fprintf(stderr, "%s: %s\n", func, nn_strerror(nn_errno()));
    exit(1);
}
&nbsp;
void send_message(const int socket, const char *message)
{
    int bytes;
&nbsp;
    printf("Sending message '%s'\n", message);
    if ((bytes = nn_send(socket, message, strlen(message)+1, 0)) < 0) {
        report_error("nn_send");
    }
    printf("Message with length %d bytes sent, flushing\n", bytes);
    sleep(1);
}
&nbsp;
#define BUF_LEN 100
&nbsp;
void node2(const char *url)
{
    int socket;
    int endpoint;
    char buffer[BUF_LEN];
    int i;
&nbsp;
    if ((socket = nn_socket(AF_SP, NN_BUS)) < 0) {
        report_error("nn_socket");
    }
    puts("Socket created");
&nbsp;
    endpoint = nn_connect(socket, url);
    if (endpoint < 0) {
        report_error("nn_connect");
    }
    printf("Connected to the remote %s endpoint\n", url);
    sleep(1);
&nbsp;
    for (i=0; i<10; i++) {
        sprintf(buffer, "Message #%d from node2", i);
        send_message(socket, buffer);
    }
&nbsp;
    if (nn_shutdown(socket, endpoint) < 0) {
        report_error("nn_shutdown");
    }
    puts("Shutdown completed");
}
&nbsp;
int main(const int argc, const char **argv)
{
    node2(URL);
    return 0;
}
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů vyvinutých
v&nbsp;programovacím jazyku Go byly uloženy do Git repositáře, který je
dostupný na adrese <a
href="https://github.com/tisnik/message-queues-examples">https://github.com/tisnik/message-queues-examples</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
doslova několik kilobajtů), můžete namísto toho použít odkazy na jednotlivé
příklady, které naleznete v&nbsp;následující tabulce. Každý příklad se skládá
ze dvou samostatně překládaných a spouštěných souborů &ndash; producenta zpráv
a konzumenta zpráv:</p>

<table>
<tr><th>Příklad</th><th>Skript/kód</th><th>Popis</th><th>Cesta</th></tr>
<tr><td>1</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/07_publisher_subscriber_1000_messages/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/07_publisher_subscriber_1000_messages/</a></td></tr>
<tr><td>1</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/07_publisher_subscriber_1000_messages/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/07_publisher_subscriber_1000_messages/</a></td></tr>
<tr><td>1</td><td>Makefile</td><td>soubor pro překlad i spuštění jednotlivých částí aplikace</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/07_publisher_subscriber_1000_messages/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/07_publisher_subscriber_1000_messages/</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>2</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/08_publisher_subscriber_no_sleep/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/08_publisher_subscriber_no_sleep/</a></td></tr>
<tr><td>2</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/08_publisher_subscriber_no_sleep/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/08_publisher_subscriber_no_sleep/</a></td></tr>
<tr><td>2</td><td>Makefile</td><td>soubor pro překlad i spuštění jednotlivých částí aplikace</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/08_publisher_subscriber_no_sleep/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/08_publisher_subscriber_no_sleep/</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/09_pub_sub_tiny_sleep/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/09_pub_sub_tiny_sleep/</a></td></tr>
<tr><td>3</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/09_pub_sub_tiny_sleep/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/09_pub_sub_tiny_sleep/</a></td></tr>
<tr><td>3</td><td>Makefile</td><td>soubor pro překlad i spuštění jednotlivých částí aplikace</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/09_pub_sub_tiny_sleep/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/09_pub_sub_tiny_sleep/</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/09_pub_sub_tiny_sleep_proper_init/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/10_pub_sub_tiny_sleep_proper_init/</a></td></tr>
<tr><td>4</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/09_pub_sub_tiny_sleep_proper_init/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/10_pub_sub_tiny_sleep_proper_init/</a></td></tr>
<tr><td>4</td><td>Makefile</td><td>soubor pro překlad i spuštění jednotlivých částí aplikace</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/09_pub_sub_tiny_sleep_proper_init/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/10_pub_sub_tiny_sleep_proper_init/</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/10_pub_sub_topics/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/11_pub_sub_topics/</a></td></tr>
<tr><td>5</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/10_pub_sub_topics/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/11_pub_sub_topics/</a></td></tr>
<tr><td>5</td><td>Makefile</td><td>soubor pro překlad i spuštění jednotlivých částí aplikace</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/10_pub_sub_topics/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/11_pub_sub_topics/</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>6</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/11_req_res/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/12_req_res/</a></td></tr>
<tr><td>6</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/11_req_res/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/12_req_res/</a></td></tr>
<tr><td>6</td><td>Makefile</td><td>soubor pro překlad i spuštění jednotlivých částí aplikace</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/11_req_res/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/12_req_res/</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/12_req_res_single_thread/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/13_req_res_single_thread/</a></td></tr>
<tr><td>7</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/12_req_res_single_thread/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/13_req_res_single_thread/</a></td></tr>
<tr><td>7</td><td>Makefile</td><td>soubor pro překlad i spuštění jednotlivých částí aplikace</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/12_req_res_single_thread/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/13_req_res_single_thread/</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>8</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/13_req_resp_fast/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/14_req_resp_fast/</a></td></tr>
<tr><td>8</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/13_req_resp_fast/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/14_req_resp_fast/</a></td></tr>
<tr><td>8</td><td>Makefile</td><td>soubor pro překlad i spuštění jednotlivých částí aplikace</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/13_req_resp_fast/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/14_req_resp_fast/</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>9</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/14_survey/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/15_survey/</a></td></tr>
<tr><td>9</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/14_survey/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/15_survey/</a></td></tr>
<tr><td>9</td><td>Makefile</td><td>soubor pro překlad i spuštění jednotlivých částí aplikace</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/14_survey/">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/15_survey/</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>node1.c</td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/16_bus/node1.c">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/16_bus/node1.c</a></td></tr>
<tr><td>10</td><td>node2.c</td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/16_bus/node2.c">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/16_bus/node2.c</a></td></tr>
<tr><td>10</td><td>Makefile</td><td>soubor pro překlad i spuštění jednotlivých částí aplikace</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/16_bus/Makefile">https://github.com/tisnik/message-queues-examples/blob/master/nanomsg/16_bus/Makefile</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na předchozí části seriálu o message brokerech</h2>

<p>V&nbsp;této kapitole jsou uvedeny odkazy na všech šestnáct předchozích <a
href="https://www.root.cz/serialy/message-brokery/">částí seriálu</a>,
v&nbsp;němž se zabýváme různými způsoby implementace front zpráv a k&nbsp;nim
přidružených technologií message brokerů:</p>

<ol>

<li>Použití nástroje RQ (Redis Queue) pro správu úloh zpracovávaných na pozadí<br />
<a href="https://www.root.cz/clanky/pouziti-nastroje-rq-redis-queue-pro-spravu-uloh-zpracovavanych-na-pozadi/">https://www.root.cz/clanky/pouziti-nastroje-rq-redis-queue-pro-spravu-uloh-zpracovavanych-na-pozadi/</a>
</li>

<li>Celery: systém implementující asynchronní fronty úloh pro Python<br />
<a href="https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python/">https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python/</a>
</li>

<li>Celery: systém implementující asynchronní fronty úloh pro Python (dokončení)<br />
<a href="https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python-dokonceni/">https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python-dokonceni/</a>
</li>

<li>RabbitMQ: jedna z nejúspěšnějších implementací brokera<br />
<a href="https://www.root.cz/clanky/rabbitmq-jedna-z-nejuspesnejsich-implementaci-brokera/">https://www.root.cz/clanky/rabbitmq-jedna-z-nejuspesnejsich-implementaci-brokera/</a>
</li>

<li>Pokročilejší operace nabízené systémem RabbitMQ<br />
<a href="https://www.root.cz/clanky/pokrocilejsi-operace-nabizene-systemem-rabbitmq/">https://www.root.cz/clanky/pokrocilejsi-operace-nabizene-systemem-rabbitmq/</a>
</li>

<li>ØMQ: knihovna pro asynchronní předávání zpráv<br />
<a href="https://www.root.cz/clanky/0mq-knihovna-pro-asynchronni-predavani-zprav/">https://www.root.cz/clanky/0mq-knihovna-pro-asynchronni-predavani-zprav/</a>
</li>

<li>Další možnosti poskytované knihovnou ØMQ<br />
<a href="https://www.root.cz/clanky/dalsi-moznosti-poskytovane-knihovnou-mq/">https://www.root.cz/clanky/dalsi-moznosti-poskytovane-knihovnou-mq/</a>
</li>

<li>Využití zařízení v knihovně ØMQ při tvorbě systému se složitější architekturou<br />
<a href="https://www.root.cz/clanky/vyuziti-zarizeni-v-knihovne-mq-pri-tvorbe-systemu-se-slozitejsi-architekturou/">https://www.root.cz/clanky/vyuziti-zarizeni-v-knihovne-mq-pri-tvorbe-systemu-se-slozitejsi-architekturou/</a>
</li>

<li>Další možnosti nabízené knihovnou ØMQ, implementace protokolů ØMQ v čisté Javě<br />
<a href="https://www.root.cz/clanky/dalsi-moznosti-nabizene-knihovnou-mq-implementace-protokolu-mq-v-ciste-jave/">https://www.root.cz/clanky/dalsi-moznosti-nabizene-knihovnou-mq-implementace-protokolu-mq-v-ciste-jave/</a>
</li>

<li>Apache ActiveMQ – další systém implementující message brokera<br />
<a href="https://www.root.cz/clanky/apache-activemq-dalsi-system-implementujici-message-brokera/">https://www.root.cz/clanky/apache-activemq-dalsi-system-implementujici-message-brokera/</a>
</li>

<li>Použití Apache ActiveMQ s protokolem STOMP<br />
<a href="https://www.root.cz/clanky/pouziti-apache-activemq-s-protokolem-stomp/">https://www.root.cz/clanky/pouziti-apache-activemq-s-protokolem-stomp/</a>
</li>

<li>Použití Apache ActiveMQ s protokolem AMQP, jazyk Go a message brokeři<br />
<a href="https://www.root.cz/clanky/pouziti-apache-activemq-s-protokolem-amqp-jazyk-go-a-message-brokeri/">https://www.root.cz/clanky/pouziti-apache-activemq-s-protokolem-amqp-jazyk-go-a-message-brokeri/</a>
</li>

<li>Komunikace s&nbsp;message brokery z&nbsp;programovacího jazyka Go<br />
<a href="https://www.root.cz/clanky/komunikace-s-message-brokery-z-programovaciho-jazyka-go/">https://www.root.cz/clanky/komunikace-s-message-brokery-z-programovaciho-jazyka-go/</a>
</li>

<li>Použití message brokeru NATS<br />
<a href="https://www.root.cz/clanky/pouziti-message-brokeru-nats/">https://www.root.cz/clanky/pouziti-message-brokeru-nats/</a>
</li>

<li>NATS Streaming Server<br />
<a href="https://www.root.cz/clanky/nats-streaming-server/">https://www.root.cz/clanky/nats-streaming-server/</a>
</li>

<li>Implementace různých komunikačních strategií s&nbsp;využitím knihovny nanomsg<br />
<a href="https://www.root.cz/clanky/implementace-ruznych-komunikacnich-strategii-s-vyuzitim-knihovny-nanomsg/">https://www.root.cz/clanky/implementace-ruznych-komunikacnich-strategii-s-vyuzitim-knihovny-nanomsg/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>nanomsg na GitHubu<br />
<a href="https://github.com/nanomsg/nanomsg">https://github.com/nanomsg/nanomsg</a>
</li>

<li>Referenční příručka knihovny <strong>nanomsg</strong><br />
<a href="https://nanomsg.org/v1.1.5/nanomsg.html">https://nanomsg.org/v1.1.5/nanomsg.html</a>
</li>

<li>nng (nanomsg-next-generation)<br />
<a href="https://github.com/nanomsg/nng">https://github.com/nanomsg/nng</a>
</li>

<li>Differences between nanomsg and ZeroMQ<br />
<a href="https://nanomsg.org/documentation-zeromq.html">https://nanomsg.org/documentation-zeromq.html</a>
</li>

<li>NATS<br />
<a href="https://nats.io/about/">https://nats.io/about/</a>
</li>

<li>NATS Streaming Concepts<br />
<a href="https://nats.io/documentation/streaming/nats-streaming-intro/">https://nats.io/documentation/streaming/nats-streaming-intro/</a>
</li>

<li>NATS Streaming Server<br />
<a href="https://nats.io/download/nats-io/nats-streaming-server/">https://nats.io/download/nats-io/nats-streaming-server/</a>
</li>

<li>NATS Introduction<br />
<a href="https://nats.io/documentation/">https://nats.io/documentation/</a>
</li>

<li>NATS Client Protocol<br />
<a href="https://nats.io/documentation/internals/nats-protocol/">https://nats.io/documentation/internals/nats-protocol/</a>
</li>

<li>NATS Messaging (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/NATS_Messaging">https://en.wikipedia.org/wiki/NATS_Messaging</a>
</li>

<li>Stránka Apache Software Foundation<br />
<a href="http://www.apache.org/">http://www.apache.org/</a>
</li>

<li>Informace o portu 5672<br />
<a href="http://www.tcp-udp-ports.com/port-5672.htm">http://www.tcp-udp-ports.com/port-5672.htm</a>
</li>

<li>Třída MessagingHandler knihovny Qpid Proton<br />
<a href="https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._handlers.MessagingHandler-class.html">https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._handlers.MessagingHandler-class.html</a>
</li>

<li>Třída Event knihovny Qpid Proton<br />
<a href="https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._events.Event-class.html">https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._events.Event-class.html</a>
</li>

<li>package stomp (Go)<br />
<a href="https://godoc.org/github.com/go-stomp/stomp">https://godoc.org/github.com/go-stomp/stomp</a>
</li>

<li>Go language library for STOMP protocol<br />
<a href="https://github.com/go-stomp/stomp">https://github.com/go-stomp/stomp</a>
</li>

<li>python-qpid-proton 0.26.0 na PyPi<br />
<a href="https://pypi.org/project/python-qpid-proton/">https://pypi.org/project/python-qpid-proton/</a>
</li>

<li>Qpid Proton<br />
<a href="http://qpid.apache.org/proton/">http://qpid.apache.org/proton/</a>
</li>

<li>Using the AMQ Python Client<br />
<a href="https://access.redhat.com/documentation/en-us/red_hat_amq/7.1/html-single/using_the_amq_python_client/">https://access.redhat.com/documentation/en-us/red_hat_amq/7.1/html-single/using_the_amq_python_client/</a>
</li>

<li>Apache ActiveMQ<br />
<a href="http://activemq.apache.org/">http://activemq.apache.org/</a>
</li>

<li>Apache ActiveMQ Artemis<br />
<a href="https://activemq.apache.org/artemis/">https://activemq.apache.org/artemis/</a>
</li>

<li>Apache ActiveMQ Artemis User Manual<br />
<a href="https://activemq.apache.org/artemis/docs/latest/index.html">https://activemq.apache.org/artemis/docs/latest/index.html</a>
</li>

<li>KahaDB<br />
<a href="http://activemq.apache.org/kahadb.html">http://activemq.apache.org/kahadb.html</a>
</li>

<li>Understanding the KahaDB Message Store<br />
<a href="https://access.redhat.com/documentation/en-US/Fuse_MQ_Enterprise/7.1/html/Configuring_Broker_Persistence/files/KahaDBOverview.html">https://access.redhat.com/documentation/en-US/Fuse_MQ_Enterprise/7.1/html/Configuring_Broker_Persistence/files/KahaDBOverview.html</a>
</li>

<li>Command Line Tools (Apache ActiveMQ)<br />
<a href="https://activemq.apache.org/activemq-command-line-tools-reference.html">https://activemq.apache.org/activemq-command-line-tools-reference.html</a>
</li>

<li>stomp.py 4.1.21 na PyPi<br />
<a href="https://pypi.org/project/stomp.py/">https://pypi.org/project/stomp.py/</a>
</li>

<li>Stomp Tutorial<br />
<a href="https://access.redhat.com/documentation/en-US/Fuse_Message_Broker/5.5/html/Connectivity_Guide/files/FMBConnectivityStompTelnet.html">https://access.redhat.com/documentation/en-US/Fuse_Message_Broker/5.5/html/Connectivity_Guide/files/FMBConnectivityStompTelnet.html</a>
</li>

<li>Heartbeat (computing)<br />
<a href="https://en.wikipedia.org/wiki/Heartbeat_(computing)">https://en.wikipedia.org/wiki/Heartbeat_(computing)</a>
</li>

<li>Apache Camel<br />
<a href="https://camel.apache.org/">https://camel.apache.org/</a>
</li>

<li>Red Hat Fuse<br />
<a href="https://developers.redhat.com/products/fuse/overview/">https://developers.redhat.com/products/fuse/overview/</a>
</li>

<li>Confusion between ActiveMQ and ActiveMQ-Artemis?<br />
<a href="https://serverfault.com/questions/873533/confusion-between-activemq-and-activemq-artemis">https://serverfault.com/questions/873533/confusion-between-activemq-and-activemq-artemis</a>
</li>

<li>Staré stránky projektu HornetQ<br />
<a href="http://hornetq.jboss.org/">http://hornetq.jboss.org/</a>
</li>

<li>Snapshot JeroMQ verze 0.4.4<br />
<a href="https://oss.sonatype.org/content/repositories/snapshots/org/zeromq/jeromq/0.4.4-SNAPSHOT/">https://oss.sonatype.org/content/repositories/snapshots/org/zeromq/jeromq/0.4.4-SNAPSHOT/</a>
</li>

<li>Difference between ActiveMQ vs Apache ActiveMQ Artemis<br />
<a href="http://activemq.2283324.n4.nabble.com/Difference-between-ActiveMQ-vs-Apache-ActiveMQ-Artemis-td4703828.html">http://activemq.2283324.n4.nabble.com/Difference-between-ActiveMQ-vs-Apache-ActiveMQ-Artemis-td4703828.html</a>
</li>

<li>Microservices communications. Why you should switch to message queues<br />
<a href="https://dev.to/matteojoliveau/microservices-communications-why-you-should-switch-to-message-queues--48ia">https://dev.to/matteojoliveau/microservices-communications-why-you-should-switch-to-message-queues--48ia</a>
</li>

<li>Stomp.py 4.1.19 documentation<br />
<a href="https://stomppy.readthedocs.io/en/stable/">https://stomppy.readthedocs.io/en/stable/</a>
</li>

<li>Repositář knihovny JeroMQ<br />
<a href="https://github.com/zeromq/jeromq/">https://github.com/zeromq/jeromq/</a>
</li>

<li>ØMQ &ndash; Distributed Messaging <br />
<a href="http://zeromq.org/">http://zeromq.org/</a>
</li>

<li>ØMQ Community<br />
<a href="http://zeromq.org/community">http://zeromq.org/community</a>
</li>

<li>Get The Software<br />
<a href="http://zeromq.org/intro:get-the-software">http://zeromq.org/intro:get-the-software</a>
</li>

<li>PyZMQ Documentation<br />
<a href="https://pyzmq.readthedocs.io/en/latest/">https://pyzmq.readthedocs.io/en/latest/</a>
</li>

<li>Module: zmq.decorators<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.decorators.html">https://pyzmq.readthedocs.io/en/latest/api/zmq.decorators.html</a>
</li>

<li>ZeroMQ is the answer, by Ian Barber<br />
<a href="https://vimeo.com/20605470">https://vimeo.com/20605470</a>
</li>

<li>ZeroMQ RFC<br />
<a href="https://rfc.zeromq.org/">https://rfc.zeromq.org/</a>
</li>

<li>ZeroMQ and Clojure, a brief introduction<br />
<a href="https://antoniogarrote.wordpress.com/2010/09/08/zeromq-and-clojure-a-brief-introduction/">https://antoniogarrote.wordpress.com/2010/09/08/zeromq-and-clojure-a-brief-introduction/</a>
</li>

<li>zeromq/czmq<br />
<a href="https://github.com/zeromq/czmq">https://github.com/zeromq/czmq</a>
</li>

<li>golang wrapper for CZMQ<br />
<a href="https://github.com/zeromq/goczmq">https://github.com/zeromq/goczmq</a>
</li>

<li>ZeroMQ version reporting in Python<br />
<a href="http://zguide.zeromq.org/py:version">http://zguide.zeromq.org/py:version</a>
</li>

<li>A Go interface to ZeroMQ version 4<br />
<a href="https://github.com/pebbe/zmq4">https://github.com/pebbe/zmq4</a>
</li>

<li>Broker vs. Brokerless<br />
<a href="http://zeromq.org/whitepapers:brokerless">http://zeromq.org/whitepapers:brokerless</a>
</li>

<li>Learning ØMQ with pyzmq<br />
<a href="https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/">https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/</a>
</li>

<li>Céčková funkce <strong>zmq_ctx_new</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-ctx-new">http://api.zeromq.org/4-2:zmq-ctx-new</a>
</li>

<li>Céčková funkce <strong>zmq_ctx_destroy</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-ctx-destroy">http://api.zeromq.org/4-2:zmq-ctx-destroy</a>
</li>

<li>Céčková funkce <strong>zmq_bind</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-bind">http://api.zeromq.org/4-2:zmq-bind</a>
</li>

<li>Céčková funkce <strong>zmq_unbind</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-unbind">http://api.zeromq.org/4-2:zmq-unbind</a>
</li>

<li>Céčková C funkce <strong>zmq_connect</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-connect">http://api.zeromq.org/4-2:zmq-connect</a>
</li>

<li>Céčková C funkce <strong>zmq_disconnect</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-disconnect">http://api.zeromq.org/4-2:zmq-disconnect</a>
</li>

<li>Céčková C funkce <strong>zmq_send</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-send">http://api.zeromq.org/4-2:zmq-send</a>
</li>

<li>Céčková C funkce <strong>zmq_recv</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-recv">http://api.zeromq.org/4-2:zmq-recv</a>
</li>

<li>Třída <strong>Context</strong> (Python)<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.html#context">https://pyzmq.readthedocs.io/en/latest/api/zmq.html#context</a>
</li>

<li>Třída <strong>Socket</strong> (Python)<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.html#socket">https://pyzmq.readthedocs.io/en/latest/api/zmq.html#socket</a>
</li>

<li>Python binding<br />
<a href="http://zeromq.org/bindings:python">http://zeromq.org/bindings:python</a>
</li>

<li>Why should I have written ZeroMQ in C, not C++ (part I)<br />
<a href="http://250bpm.com/blog:4">http://250bpm.com/blog:4</a>
</li>

<li>Why should I have written ZeroMQ in C, not C++ (part II) <br />
<a href="http://250bpm.com/blog:8">http://250bpm.com/blog:8</a>
</li>

<li>About Nanomsg<br />
<a href="https://nanomsg.org/">https://nanomsg.org/</a>
</li>

<li>Advanced Message Queuing Protocol<br />
<a href="https://www.amqp.org/">https://www.amqp.org/</a>
</li>

<li>Advanced Message Queuing Protocol na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol">https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol</a>
</li>

<li>Dokumentace k&nbsp;příkazu <strong>rabbitmqctl</strong><br />
<a href="https://www.rabbitmq.com/rabbitmqctl.8.html">https://www.rabbitmq.com/rabbitmqctl.8.html</a>
</li>

<li>RabbitMQ<br />
<a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a>
</li>

<li>RabbitMQ Tutorials<br />
<a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a>
</li>

<li>RabbitMQ: Clients and Developer Tools<br />
<a href="https://www.rabbitmq.com/devtools.html">https://www.rabbitmq.com/devtools.html</a>
</li>

<li>RabbitMQ na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/RabbitMQ">https://en.wikipedia.org/wiki/RabbitMQ</a>
</li>

<li>Streaming Text Oriented Messaging Protocol<br />
<a href="https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol">https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol</a>
</li>

<li>Message Queuing Telemetry Transport<br />
<a href="https://en.wikipedia.org/wiki/MQTT">https://en.wikipedia.org/wiki/MQTT</a>
</li>

<li>Erlang<br />
<a href="http://www.erlang.org/">http://www.erlang.org/</a>
</li>

<li>pika 0.12.0 na PyPi<br />
<a href="https://pypi.org/project/pika/">https://pypi.org/project/pika/</a>
</li>

<li>Introduction to Pika<br />
<a href="https://pika.readthedocs.io/en/stable/">https://pika.readthedocs.io/en/stable/</a>
</li>

<li>Langohr: An idiomatic Clojure client for RabbitMQ that embraces the AMQP 0.9.1 model<br />
<a href="http://clojurerabbitmq.info/">http://clojurerabbitmq.info/</a>
</li>

<li>AMQP 0-9-1 Model Explained<br />
<a href="http://www.rabbitmq.com/tutorials/amqp-concepts.html">http://www.rabbitmq.com/tutorials/amqp-concepts.html</a>
</li>

<li>Part 1: RabbitMQ for beginners - What is RabbitMQ?<br />
<a href="https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html">https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html</a>
</li>

<li>Downloading and Installing RabbitMQ<br />
<a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a>
</li>

<li>celery na PyPi<br />
<a href="https://pypi.org/project/celery/">https://pypi.org/project/celery/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python <br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python (dokončení)<br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/</a>
</li>

<li>Redis Queue (RQ)<br />
<a href="https://www.fullstackpython.com/redis-queue-rq.html">https://www.fullstackpython.com/redis-queue-rq.html</a>
</li>

<li>Python Celery &amp; RabbitMQ Tutorial<br />
<a href="https://tests4geeks.com/python-celery-rabbitmq-tutorial/">https://tests4geeks.com/python-celery-rabbitmq-tutorial/</a>
</li>

<li>Flower: Real-time Celery web-monitor<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor">http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor</a>
</li>

<li>Asynchronous Tasks With Django and Celery<br />
<a href="https://realpython.com/asynchronous-tasks-with-django-and-celery/">https://realpython.com/asynchronous-tasks-with-django-and-celery/</a>
</li>

<li>First Steps with Celery<br />
<a href="http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html">http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html</a>
</li>

<li>node-celery<br />
<a href="https://github.com/mher/node-celery">https://github.com/mher/node-celery</a>
</li>

<li>Full Stack Python: web development<br />
<a href="https://www.fullstackpython.com/web-development.html">https://www.fullstackpython.com/web-development.html</a>
</li>

<li>Introducing RQ<br />
<a href="https://nvie.com/posts/introducing-rq/">https://nvie.com/posts/introducing-rq/</a>
</li>

<li>Asynchronous Tasks with Flask and Redis Queue<br />
<a href="https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue">https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Stránky projektu Redis<br />
<a href="https://redis.io/">https://redis.io/</a>
</li>

<li>Introduction to Redis<br />
<a href="https://redis.io/topics/introduction">https://redis.io/topics/introduction</a>
</li>

<li>Try Redis<br />
<a href="http://try.redis.io/">http://try.redis.io/</a>
</li>

<li>Redis tutorial, April 2010 (starší, ale pěkně udělaný)<br />
<a href="https://static.simonwillison.net/static/2010/redis-tutorial/">https://static.simonwillison.net/static/2010/redis-tutorial/</a>
</li>

<li>Python Redis<br />
<a href="https://redislabs.com/lp/python-redis/">https://redislabs.com/lp/python-redis/</a>
</li>

<li>Redis: key-value databáze v paměti i na disku<br />
<a href="https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/">https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/</a>
</li>

<li>Praktický úvod do Redis (1): vaše distribuovaná NoSQL cache<br />
<a href="http://www.cloudsvet.cz/?p=253">http://www.cloudsvet.cz/?p=253</a>
</li>

<li>Praktický úvod do Redis (2): transakce<br />
<a href="http://www.cloudsvet.cz/?p=256">http://www.cloudsvet.cz/?p=256</a>
</li>

<li>Praktický úvod do Redis (3): cluster<br />
<a href="http://www.cloudsvet.cz/?p=258">http://www.cloudsvet.cz/?p=258</a>
</li>

<li>Connection pool<br />
<a href="https://en.wikipedia.org/wiki/Connection_pool">https://en.wikipedia.org/wiki/Connection_pool</a>
</li>

<li>Instant Redis Sentinel Setup<br />
<a href="https://github.com/ServiceStack/redis-config">https://github.com/ServiceStack/redis-config</a>
</li>

<li>How to install REDIS in LInux<br />
<a href="https://linuxtechlab.com/how-install-redis-server-linux/">https://linuxtechlab.com/how-install-redis-server-linux/</a>
</li>

<li>Redis RDB Dump File Format<br />
<a href="https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format">https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format</a>
</li>

<li>Lempel–Ziv–Welch<br />
<a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch">https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch</a>
</li>

<li>Redis Persistence<br />
<a href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a>
</li>

<li>Redis persistence demystified<br />
<a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html">http://oldblog.antirez.com/post/redis-persistence-demystified.html</a>
</li>

<li>Redis reliable queues with Lua scripting<br />
<a href="http://oldblog.antirez.com/post/250">http://oldblog.antirez.com/post/250</a>
</li>

<li>Ost (knihovna)<br />
<a href="https://github.com/soveran/ost">https://github.com/soveran/ost</a>
</li>

<li>NoSQL<br />
<a href="https://en.wikipedia.org/wiki/NoSQL">https://en.wikipedia.org/wiki/NoSQL</a>
</li>

<li>Shard (database architecture)<br />
<a href="https://en.wikipedia.org/wiki/Shard_%28database_architecture%29">https://en.wikipedia.org/wiki/Shard_%28database_architecture%29</a>
</li>

<li>What is sharding and why is it important?<br />
<a href="https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important">https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important</a>
</li>

<li>What Is Sharding?<br />
<a href="https://btcmanager.com/what-sharding/">https://btcmanager.com/what-sharding/</a>
</li>

<li>Redis clients<br />
<a href="https://redis.io/clients">https://redis.io/clients</a>
</li>

<li>Category:Lua-scriptable software<br />
<a href="https://en.wikipedia.org/wiki/Category:Lua-scriptable_software">https://en.wikipedia.org/wiki/Category:Lua-scriptable_software</a>
</li>

<li>Seriál Programovací jazyk Lua<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-lua/">https://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>Redis memory usage<br />
<a href="http://nosql.mypopescu.com/post/1010844204/redis-memory-usage">http://nosql.mypopescu.com/post/1010844204/redis-memory-usage</a>
</li>

<li>Ukázka konfigurace Redisu pro lokální testování<br />
<a href="https://github.com/tisnik/presentations/blob/master/redis/redis.conf">https://github.com/tisnik/presentations/blob/master/redis/redis.conf</a>
</li>

<li>Resque<br />
<a href="https://github.com/resque/resque">https://github.com/resque/resque</a>
</li>

<li>Nested transaction<br />
<a href="https://en.wikipedia.org/wiki/Nested_transaction">https://en.wikipedia.org/wiki/Nested_transaction</a>
</li>

<li>Publish–subscribe pattern<br />
<a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern</a>
</li>

<li>Messaging pattern<br />
<a href="https://en.wikipedia.org/wiki/Messaging_pattern">https://en.wikipedia.org/wiki/Messaging_pattern</a>
</li>

<li>Using pipelining to speedup Redis queries<br />
<a href="https://redis.io/topics/pipelining">https://redis.io/topics/pipelining</a>
</li>

<li>Pub/Sub<br />
<a href="https://redis.io/topics/pubsub">https://redis.io/topics/pubsub</a>
</li>

<li>ZeroMQ distributed messaging<br />
<a href="http://zeromq.org/">http://zeromq.org/</a>
</li>

<li>ZeroMQ: Modern &amp; Fast Networking Stack<br />
<a href="https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/">https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/</a>
</li>

<li>Publish/Subscribe paradigm: Why must message classes not know about their subscribers?<br />
<a href="https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr">https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr</a>
</li>

<li>Python &amp; Redis PUB/SUB<br />
<a href="https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7">https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7</a>
</li>

<li>Message broker<br />
<a href="https://en.wikipedia.org/wiki/Message_broker">https://en.wikipedia.org/wiki/Message_broker</a>
</li>

<li>RESP Arrays<br />
<a href="https://redis.io/topics/protocol#array-reply">https://redis.io/topics/protocol#array-reply</a>
</li>

<li>Redis Protocol specification<br />
<a href="https://redis.io/topics/protocol">https://redis.io/topics/protocol</a>
</li>

<li>Redis Pub/Sub: Intro Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-intro/">https://www.redisgreen.net/blog/pubsub-intro/</a>
</li>

<li>Redis Pub/Sub: Howto Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-howto/">https://www.redisgreen.net/blog/pubsub-howto/</a>
</li>

<li>Comparing Publish-Subscribe Messaging and Message Queuing<br />
<a href="https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message">https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message</a>
</li>

<li>Apache Kafka<br />
<a href="https://kafka.apache.org/">https://kafka.apache.org/</a>
</li>

<li>Iron<br />
<a href="http://www.iron.io/mq">http://www.iron.io/mq</a>
</li>

<li>kue (založeno na Redisu, určeno pro node.js)<br />
<a href="https://github.com/Automattic/kue">https://github.com/Automattic/kue</a>
</li>

<li>Cloud Pub/Sub<br />
<a href="https://cloud.google.com/pubsub/">https://cloud.google.com/pubsub/</a>
</li>

<li>Introduction to Redis Streams<br />
<a href="https://redis.io/topics/streams-intro">https://redis.io/topics/streams-intro</a>
</li>

<li>glob (programming)<br />
<a href="https://en.wikipedia.org/wiki/Glob_(programming)">https://en.wikipedia.org/wiki/Glob_(programming)</a>
</li>

<li>Why and how Pricing Assistant migrated from Celery to RQ - Paris.py<br />
<a href="https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2">https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2</a>
</li>

<li>Enqueueing internals<br />
<a href="http://python-rq.org/contrib/">http://python-rq.org/contrib/</a>
</li>

<li>queue — A synchronized queue class<br />
<a href="https://docs.python.org/3/library/queue.html">https://docs.python.org/3/library/queue.html</a>
</li>

<li>Queue – A thread-safe FIFO implementation<br />
<a href="https://pymotw.com/2/Queue/">https://pymotw.com/2/Queue/</a>
</li>

<li>Queues<br />
<a href="http://queues.io/">http://queues.io/</a>
</li>

<li>Windows Subsystem for Linux Documentation<br />
<a href="https://docs.microsoft.com/en-us/windows/wsl/about">https://docs.microsoft.com/en-us/windows/wsl/about</a>
</li>

<li>RestMQ<br />
<a href="http://restmq.com/">http://restmq.com/</a>
</li>

<li>ActiveMQ<br />
<a href="http://activemq.apache.org/">http://activemq.apache.org/</a>
</li>

<li>Amazon MQ<br />
<a href="https://aws.amazon.com/amazon-mq/">https://aws.amazon.com/amazon-mq/</a>
</li>

<li>Amazon Simple Queue Service<br />
<a href="https://aws.amazon.com/sqs/">https://aws.amazon.com/sqs/</a>
</li>

<li>Celery: Distributed Task Queue<br />
<a href="http://www.celeryproject.org/">http://www.celeryproject.org/</a>
</li>

<li>Disque, an in-memory, distributed job queue<br />
<a href="https://github.com/antirez/disque">https://github.com/antirez/disque</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Projekt RQ na PyPi<br />
<a href="https://pypi.org/project/rq/">https://pypi.org/project/rq/</a>
</li>

<li>rq-dashboard 0.3.12<br />
<a href="https://pypi.org/project/rq-dashboard/">https://pypi.org/project/rq-dashboard/</a>
</li>

<li>Job queue<br />
<a href="https://en.wikipedia.org/wiki/Job_queue">https://en.wikipedia.org/wiki/Job_queue</a>
</li>

<li>Why we moved from Celery to RQ<br />
<a href="https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq">https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq</a>
</li>

<li>Running multiple workers using Celery<br />
<a href="https://serverfault.com/questions/655387/running-multiple-workers-using-celery">https://serverfault.com/questions/655387/running-multiple-workers-using-celery</a>
</li>

<li>celery — Distributed processing<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.html">http://docs.celeryproject.org/en/latest/reference/celery.html</a>
</li>

<li>Chains<br />
<a href="https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains">https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains</a>
</li>

<li>Routing<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing">http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing</a>
</li>

<li>Celery Distributed Task Queue in Go<br />
<a href="https://github.com/gocelery/gocelery/">https://github.com/gocelery/gocelery/</a>
</li>

<li>Python Decorators<br />
<a href="https://wiki.python.org/moin/PythonDecorators">https://wiki.python.org/moin/PythonDecorators</a>
</li>

<li>Periodic Tasks<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html">http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html</a>
</li>

<li>celery.schedules<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab">http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab</a>
</li>

<li>Pros and cons to use Celery vs. RQ<br />
<a href="https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq">https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq</a>
</li>

<li>Priority queue<br />
<a href="https://en.wikipedia.org/wiki/Priority_queue">https://en.wikipedia.org/wiki/Priority_queue</a>
</li>

<li>Jupyter<br />
<a href="https://jupyter.org/">https://jupyter.org/</a>
</li>

<li>How IPython and Jupyter Notebook work<br />
<a href="https://jupyter.readthedocs.io/en/latest/architecture/how_jupyter_ipython_work.html">https://jupyter.readthedocs.io/en/latest/architecture/how_jupyter_ipython_work.html</a>
</li>

<li>Context Managers<br />
<a href="http://book.pythontips.com/en/latest/context_managers.html">http://book.pythontips.com/en/latest/context_managers.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

