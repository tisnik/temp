<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Apache Kafka</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Apache Kafka</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Apache Kafka</a></p>
<p><a href="#k02">2. Některá úskalí klasických message brokerů</a></p>
<p><a href="#k03">3. Práce se zprávami (či událostmi) v&nbsp;systému Apache Kafka</a></p>
<p><a href="#k04">4. Témata a oddíly a replikace</a></p>
<p><a href="#k05">*** 5. Instalace Kafky</a></p>
<p><a href="#k06">*** 6. Spuštění nástroje Zookeper a jedné instance brokera</a></p>
<p><a href="#k07">*** 7. Konfigurace většího množství brokerů</a></p>
<p><a href="#k08">8. Užitečný nástroj <strong>kafkacat</strong></a></p>
<p><a href="#k09">*** 9. Instalace nástroje <strong>kafkacat</strong></a></p>
<p><a href="#k10">*** 10. Kafkacat v&nbsp;roli producenta i konzumenta zpráv</a></p>
<p><a href="#k11">11. Naprogramování klientů pro Kafku</a></p>
<p><a href="#k12">*** 12. Producent zpráv vytvořený v&nbsp;Pythonu</a></p>
<p><a href="#k13">*** 13. Konzument zpráv naprogramovaný v&nbsp;Pythonu</a></p>
<p><a href="#k14">*** 14. Přehrání (<i>replay</i>) zpráv</a></p>
<p><a href="#k15">*** 15. Producent zpráv naprogramovaný v&nbsp;jazyce Go</a></p>
<p><a href="#k16">*** 16. Konzument zpráv vytvořený v&nbsp;Go</a></p>
<p><a href="#k17">*** 17. Alternativa k&nbsp;systému Kafka: nástroj NATS</a></p>
<p><a href="#k18">18. Termíny používané v&nbsp;souvislosti s&nbsp;message brokery</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Apache Kafka</h2>

<p><a href="https://www.root.cz/serialy/message-brokery/">V&nbsp;seriálu o
message brokerech</a> jsme si již popsali prakticky všechny nejvýznamnější a
nejvíce nasazované implementace klasických <i>brokerů</i> založených na
frontách zpráv (<i>message queues</i>). Ovšem kromě front zpráv existují i
další typy brokerů, kteří podporují takzvaný <i>streaming</i> a s&nbsp;ním
spojenou komunikační strategii nazývanou <strong>pub-sub</strong>
popř.&nbsp;<strong>publish-subscribe</strong>. Kromě toho je většinou
podporováno i &bdquo;přehrání&ldquo; (<i>replay</i>) starších zpráv, což je
operace, kterou klasické message brokery založené na frontách, většinou
nepodporují (už jen z&nbsp;toho důvodu, že zpráva je po potvrzení producentem
z&nbsp;fronty odstraněna popř.&nbsp;přesunuta do fronty jiné). Jedním
z&nbsp;nejznámějších brokerů podporujících <i>streaming</i> je <a
href="https://kafka.apache.org/">Apache Kafka</a>. S&nbsp;tímto nástrojem jsme
se nepřímo setkali v&nbsp;seriálu o mikroslužbách, ovšem prozatím jsme si
neukázali, jakým způsobem je možné Kafku zprovoznit na vývojovém stroji a jak
lze naprogramovat jednoduché producenty a konzumenty zpráv.</p>

<p><div class="rs-tip-major">Poznámka: samotné jméno systému <i>Apache
Kafka</i> (dříve, dokud se projekt nestal součástí projektu <a
href="http://apache.org/">Apache</a> jen <i>Kafka</i>) je odvozeno od příjmení
slavného spisovatele <a href="https://en.wikipedia.org/wiki/Franz_Kafka">Franze
Kafky</a>. Ovšem v&nbsp;běžné řeči se docela často mluví o &bdquo;té
kafce&ldquo; (kavce), tj.&nbsp;používá se ženský rod. V&nbsp;tomto článku se
budu snažit používat neutrální spojení &bdquo;systém Kafka&ldquo;,
&bdquo;projekt Kafka&ldquo;.</div></p>

<a href="https://www.root.cz/obrazek/348762/"><img src="https://i.iinfo.cz/images/176/rabbitmq1-1-prev.png" class="image-348762" alt="&#160;" width="370" height="62" /></a>
<p><i>Obrázek 1: Komunikační strategie <strong>PUSH-PULL</strong> používaná
klasickými message brokery se hodí například pro implementaci takzvaných
workerů, kteří se dělí o zadávané úkoly a mohou být rozděleni podle toho, ke
které frontě se připojují popř.&nbsp;jaký &bdquo;topic&ldquo; zpracovávají.
Ovšem ve chvíli, kdy je nutné mít možnost si jednou zaznamenané zprávy
(resp.&nbsp;události) &bdquo;přehrát&ldquo;, je vhodnější použít jiný princip
zpracování podporovaný právě systémem Apache Kafka.</i></p>

<p>Díky konceptům, na nichž je projekt Kafka založen, je možné tento systém
použít v&nbsp;několika oblastech, například ve funkci distribuovaného logu,
databáze událostí (<i>events</i>), zobecněného message brokera, je ústředním
prvkem architektur <i>lambda</i> a <i>kappa</i>, příjemci zpráv se mohou
sdružovat do skupin atd. Ovšem i další vlastnosti, které projekt Kafka nabízí,
jsou velmi užitečné. Jedná se především o možnost nasazení celého clusteru
brokerů řízených z&nbsp;jednoho místa, možnost replikace záznamů (zpráv,
událostí), řízení, které zprávy mají být zachovány a které (ty starší) smazány
apod. Existují ale samozřejmě i alternativy k&nbsp;tomuto projektu, například
již popsaný <i>NATS Streaming Server</i> [<a
href="https://www.root.cz/clanky/pouziti-message-brokeru-nats/">1</a>] [<a
href="https://www.root.cz/clanky/nats-streaming-server/">2</a>]. Zavrhnout
nelze ani možnost použít Kafku jako klasického message brokera s&nbsp;frontami
zpráv, to ovšem vyžaduje použití většího množství topiců (jeden topic se
používá pro ukládání informací o zpracovaných zprávách) a navíc je nutné použít
i specializovaného klienta (konzumenta + producenta).</p>

<p><div class="rs-tip-major">Poznámka: Apache Kafka je z&nbsp;velké části
naprogramována ve <a href="https://www.scala-lang.org/">Scale</a> a <a
href="https://en.wikipedia.org/wiki/Java_(programming_language)">Javě</a>, běží
tedy nad JVM. Současně se jedná o velmi rychlý systém, což je ukazuje, že při
použití správných programátorských technik je JVM výkonnou a škálovatelnou
platformou.</div></p>

<img src="https://i.iinfo.cz/images/447/microservices2-3.png" class="image-361670" alt="&#160;" width="450" height="134" />
<p><i>Obrázek 2: Logo nástroje Apache Kafka, kterému se budeme dnes
věnovat.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Některá úskalí klasických message brokerů</h2>

<p>Klasické implementace message brokerů založených na komunikačních
strategiích <strong>PUSH-PULL</strong> a popř.&nbsp;i na původním konceptu
<strong>PUBLISH-SUBSCRIBE</strong> mají určitá omezení. Většina těchto úskalí
je do větší či menší míry řešena moderními <i>streaming brokery</i>, mezi něž
patří (na prvním místě) právě Apache Kafka:</p>

<ol>

<li>U strategie <strong>PUBLISH-SUBSCRIBE</strong> získají zprávu pouze ti
konzumenti, kteří jsou v&nbsp;daný okamžik přihlášeni k&nbsp;příjmu zpráv.
Pokud je nějaký konzument z&nbsp;nějakého důvodu odpojený, zprávu již nikdy
později nedostane (protože ji message broker nemá uloženou). V&nbsp;případě
streamingu si čtení zpráv od zadaného okamžiku řídí samotný konzument zpráv,
pochopitelně s&nbsp;tím omezením, že se starší (většinou mnohem starší) zprávy
mohou automaticky odstraňovat na základě kritérií nastavených administrátorem
(někdy to ovšem znamená, že si konzument musí pamatovat například offset
poslední zpracované zprávy &ndash; zde již konkrétní chování závisí na
možnostech brokera).</li>

<li>U strategie <strong>PUSH-PULL</strong> je jednou doručená zpráva
z&nbsp;message brokera (přesněji řečeno z&nbsp;fronty implementované
v&nbsp;message brokeru) odstraněna a nelze se k&nbsp;ní později vrátit. Tím
pádem pochopitelně není umožněna ani podpora pro přehrávání zpráv
(<i>replay</i>). I toto je do značné míry vyřešeno v&nbsp;případě nasazení
<i>streamingu</i>; vše je omezeno nastavením provedeném administrátorem (a
teoreticky existuje pouze jedno omezení na 2<sup>63</sup>-1 zpráv v&nbsp;jedné
oblasti, což je však hodnota, které v&nbsp;reálném nasazení prakticky nelze
dosáhnout).</li>

<li>Původní strategie <strong>PUSH-PULL</strong> navíc předpokládá, že se
zpráva doručí jen jedinému konzumentovi. Někteří message brokeři ovšem
podporují i rozšíření funkcionality a implementují tak kombinaci obou
strategií, jak <strong>PUBLISH-SUBSCRIBE</strong>, tak i
<strong>PUSH-PULL</strong> (dobrým příkladem může být populární message broker
<i>RabbitMQ</i>). Streaming servery používají zobecněnou strategii
<strong>PUBLISH-SUBSCRIBE</strong>, takže toto omezení nemají, pochopitelně při
správném nastavení témat a jejich replikací.</li>

<li>U strategie <strong>PUSH-PULL</strong> se v&nbsp;případě výchozího chování
nijak nespecifikuje maximální počet zpráv ve frontě popř.&nbsp;maximální
povolené obsazení místa na disku. V&nbsp;případě, že konzumenti budou delší
dobu odpojeni, se může jednat o potenciální problém (opět platí, že u některých
message brokerů se můžeme setkat s&nbsp;určitou podporu pro mazání starších
zpráv při dosažení administrátorem specifikovaných limitů). Řešení
v&nbsp;případě streaming serverů bylo zmíněno výše a ke konkrétním příkladům se
vrátíme v&nbsp;dalším textu.</li>

<li>Problematický může být i relativně nízký výkon přeposílání zpráv systémem
<strong>PUSH-PULL</strong> (přibližně do limitu 100 000 zpráv za sekundu při
použití <i>RabbitMQ</i> v&nbsp;clusteru, zatímco systémy založené na Kafce
mohou mít i řádově vyšší rychlost práce se zprávami).</li>

</ol>

<p><div class="rs-tip-major">Poznámka: u posledního bodu se možná na chvíli
zastavme. Klasičtí message brokeři jsou velmi často používání pro předávání i
relativně obsáhlých zpráv, kdežto u mnoha systémů s&nbsp;Apache Kafkou bývají
zprávy dosti krátké; většinou se jedná pouze o oznámení, že došlo k&nbsp;nějaké
události, jediný řádek logu, jedna změna ve stavu aplikace, update jednoho
řádku v&nbsp;databází atd. I to je jeden z&nbsp;důvodů, proč se poměrně snadno
dá (v&nbsp;clusteru) dosáhnout výkonu jednoho milionu zpráv za
sekundu.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Práce se zprávami (či událostmi) v&nbsp;systému Apache Kafka</h2>

<p>V&nbsp;systému Apache Kafka se se zprávami (které se zde ale typicky
nazývají spíše záznamy, <i>record</i>, popř.&nbsp;možná poněkud nepřesně
události neboli <i>events</i>) pracuje poněkud odlišným způsobem, který do
jisté míry kombinuje jak možnosti klasické fronty zpráv, tak i rozesílání zpráv
systémem <strong>PUBLISH-SUBSCRIBE</strong>. Zprávy se ovšem neukládají do
běžné fronty, ale (v&nbsp;tom zcela nejjednodušším případě) do neustále
rostoucí sekvence záznamů, přičemž každému záznamu je přiřazeno jednoznačné
číslo &ndash; <i>offset</i>. Z&nbsp;pohledu zdroje zpráv (<i>publisher</i>)
vlastně nedochází k&nbsp;žádné podstatnější změně. Rozdílné je ovšem další
zpracování záznamů. Tyto záznamy mohou číst příjemci zpráv
(<i>subscribeři</i>), kteří si sami zvolí, od jakého <i>offsetu</i> potřebují
zprávy přečíst. Offset lze kromě celočíselného údaje zadat i jinak: &bdquo;číst
od začátku&ldquo;, &bdquo;číst od poslední zpracované zprávy&ldquo; apod.</p>

<p><div class="rs-tip-major">Poznámka: jak zprávy, tak i záznamy jsou
v&nbsp;naprosté většině implementací brokerů neměnné &ndash;
<i>immutable</i>.</div></p>

<p>Přečtením ovšem zpráva nezanikne, na rozdíl od klasické fronty, kde operace
<strong>PULL</strong> zprávu z&nbsp;fronty navždy odstraní a message broker ji
ihned poté odstraní i ze své paměti a perzistentního úložiště. A je zde i
rozdíl oproti systému <strong>PUBLISH-SUBSCRIBE</strong>, protože
v&nbsp;systému Apache Kafka může <i>subscriber</i> zprávu získat kdykoli
později &ndash; nemusí být tedy připraven zprávu zpracovat v&nbsp;ten přesný
okamžik, kdy je zpráva message brokerem rozesílána.</p>

<p>To však není jediná změna či vylepšení. Vzhledem k&nbsp;tomu, že příjemci
zpráv (<i>subscribeři</i>) si sami volí offset, od kterého chtějí zprávy číst,
je možné provádět takzvanou operaci <i>replay</i>, což ve skutečnosti není nic
jiného, než nové zpracování zpráv od jejich začátku, od určitého (třeba i
relativně zadaného) časového okamžiku atd. Tato vlastnost má dosti závažné
důsledky pro mnohé oblasti, v&nbsp;nichž se systém Apache Kafka nasazuje.
Umožňuje totiž postupné přidávání nových příjemců zpráv, kteří ihned mohou
začít zpracovávat i historické záznamy. Ostatně to je i jeden z&nbsp;důvodů,
proč je Apache Kafka tak populární v&nbsp;oblasti strojového učení (<i>machine
learning</i> &ndash; <i>ML</i>), protože umožňuje prakticky dokonalé oddělení
systémů sloužících pro sběr dat od modulů, které tato data nějakým způsobem
dále zpracovávají.</p>

<pre>
      +---+---+---+---+---+---+---+---+---+
téma  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | ...
      +---+---+---+---+---+---+---+---+---+
                ^                            ^
                |                          zápis
              čtení
</pre>

<p>Aby bylo možné nějakým způsobem konfigurovat a řídit, které zprávy mají být
na message brokeru uloženy a které již smazány, specifikuje se takzvaný
<i>retention time</i> zajišťující, aby počet zpráv/záznamů nepřekročil časovou
mez. Streaming server dokáže omezit i celkový počet zpráv, počet zpráv
v&nbsp;tématu a/nebo počet zpráv na jednom serveru v&nbsp;clusteru. Totéž
omezení je možné aplikovat na celkovou velikost použitého paměťového či
diskového prostoru &ndash; vše podle požadavků, které jsou na celý systém
kladeny.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Témata a oddíly a replikace</h2>

<p>Systém Apache Kafka umožňuje ukládání zpráv (zde se ovšem, jak již víme,
používá termín záznam &ndash; <i>record</i>) do různých témat, přičemž každé
téma je rozděleno do oddílů neboli <i>partition</i> (samozřejmě je možné pro
téma vyhradit pouze jediný oddíl a tvářit se, že máme k&nbsp;dispozici
&bdquo;vylepšenou&ldquo; frontu &ndash; ostatně přesně takto lze s&nbsp;Kafkou
začít). Rozdělení do oddílů se provádí z&nbsp;několika důvodů. Jedním
z&nbsp;nich je rozdělení zátěže, protože jednotlivé oddíly mohou být
provozovány na různých počítačích v&nbsp;mnohdy i velmi rozsáhlém clusteru.</p>

<p>Dále se dělení provádí z&nbsp;toho důvodu, že každý oddíl obsahuje neměnnou
(<i>immutable</i>) sekvenci zpráv. Oddíly pro jednotlivá témata lze zpracovávat
v&nbsp;několika brokerech umístěných do clusteru a tak zajistit potřebný
<i>load balancing</i>, případnou replikaci zpráv atd. Každá zpráva uložená do
oddílu má přiřazen jednoznačný offset (reprezentovaný v&nbsp;Javě typem
<strong>long</strong>). Navíc je možné, aby se pro každé téma udržovalo několik
logů (<i>partition logs</i>), což umožňuje připojení většího množství
konzumentů zpráv k&nbsp;jednomu tématu s&nbsp;tím, že tito konzumenti budou
pracovat paralelně a nezávisle na sobě.</p>

<p><div class="rs-tip-major">Poznámka: s&nbsp;konfigurací logů se setkáme <a
href="#k05">v&nbsp;páté kapitole</a>.</div></p>

<img src="https://i.iinfo.cz/images/138/microservices4-2.png" class="image-362665" alt="&#160;" width="309" height="277" />
<p><i>Obrázek 3: Příklad rozdělení témat v&nbsp;clusteru.</i></p>

<p>U většiny nasazení Kafky se taktéž počítá s&nbsp;využitím většího množství
instancí brokerů, z&nbsp;nichž je vytvořen cluster. Zde se setkáme
s&nbsp;důležitým termínem <i>replikace</i> &ndash; každý oddíl je typicky
replikován na několika message brokerech v&nbsp;clusteru (ovšem nemusí se
jednat o všechny brokery, replikace se provádí například na tři brokery ve
větším clusteru).</p>

<p>To však není vše, jelikož je ve skutečnosti konfigurace poněkud složitější
&ndash; každý oddíl totiž může být replikován na více počítačích, přičemž jeden
z&nbsp;těchto oddílů je takzvaným &bdquo;leaderem&ldquo; a ostatní jsou
&bdquo;followeři&ldquo;. Zápis nových zpráv popř.&nbsp;čtení se provádí vždy
jen v&nbsp;rámci <i>leaderu</i>, ovšem změny jsou replikovány na všechny kopie
oddílu. Ve chvíli, kdy z&nbsp;nějakého (libovolného) důvodu dojde k&nbsp;pádu
&bdquo;leadera&ldquo;, převezme jeho roli jeden z&nbsp;dalších uzlů. Pokud tedy
existuje N uzlů s&nbsp;replikou oddílu, bude systém funkční i ve chvíli, kdy
zhavaruje N-1 uzlů!</p>

<p>Téma zpracovávané Kafkou může na clusteru vypadat například následovně:</p>

<pre>
          +---+---+---+---+---+---+
oddíl #0  | 0 | 1 | 2 | 3 | 4 | 5 | ...
          +---+---+---+---+---+---+
oddíl #1  | 0 | 1 | 2 | ...
          +---+---+---+
oddíl #2  | ...
          +---+---+---+---+---+---+---+---+---+
oddíl #3  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | ...
          +---+---+---+---+---+---+---+---+---+
</pre>

<p>Boxy s&nbsp;čísly odpovídají jednotlivým zprávám, kterým jsou tato pořadová
čísla v&nbsp;sekvenci postupně přiřazována. Zápis nových zpráv je prováděn do
oblastí označených třemi tečkami. Z&nbsp;tohoto diagramu můžeme odvodit, že
každý oddíl obsahuje vlastní sekvenci zpráv/záznamů, ke kterým se postupně
připojují záznamy další.</p>

<p><div class="rs-tip-major">Poznámka: někdy se setkáme i s&nbsp;opačným
nakreslením diagramu s&nbsp;oddíly a se zprávami v&nbsp;nich uloženými. Důvod
je vlastně dosti jednoduchý &ndash; z&nbsp;klasických message brokerů jsme
(minimálně národy píšící zleva doprava) zvyklí na to, že vstup do fronty je
nakreslen vlevo a výstup z&nbsp;fronty naopak napravo. Výše zobrazené oddíly
používají opačný způsob, protože zprávy jsou připojovány zprava a čteny zleva
doprava.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Instalace Kafky</h2>

<p></p>

<pre>
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Spuštění nástroje Zookeper a jedné instance brokera</h2>

<p></p>

<pre>
dataDir=/tmp/zookeeper
clientPort=2181
maxClientCnxns=0
admin.enableServer=false
</pre>

<pre>
$ <strong>bin/zookeeper-server-start.sh config/zookeeper.properties</strong>
[2020-01-20 17:00:07,823] INFO Reading configuration from: config/zookeeper.properties (org.apache.zookeeper.server.quorum.QuorumPeerConfig)
[2020-01-20 17:00:07,825] WARN config/zookeeper.properties is relative. Prepend ./ to indicate that you're sure! (org.apache.zookeeper.server.quorum.QuorumPeerConfig)
[2020-01-20 17:00:07,827] INFO clientPortAddress is 0.0.0.0/0.0.0.0:2181 (org.apache.zookeeper.server.quorum.QuorumPeerConfig)
...
...
...
[2020-01-20 17:00:07,947] INFO Using checkIntervalMs=60000 maxPerMinute=10000 (org.apache.zookeeper.server.ContainerManager)
[2020-01-20 17:00:26,978] INFO Creating new log file: log.1 (org.apache.zookeeper.server.persistence.FileTxnLog)
</pre>

<p></p>

<pre>
broker.id=0
listeners=PLAINTEXT://:9092
num.network.threads=3
num.io.threads=8
&nbsp;
socket.send.buffer.bytes=102400
socket.receive.buffer.bytes=102400
socket.request.max.bytes=104857600
&nbsp;
log.dirs=/tmp/kafka-logs
num.partitions=1
num.recovery.threads.per.data.dir=1
log.retention.hours=168
log.segment.bytes=1073741824
&nbsp;
zookeeper.connect=localhost:2181
zookeeper.connection.timeout.ms=6000
</pre>

<pre>
$ bin/kafka-server-start.sh config/server.properties
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Konfigurace většího množství brokerů</h2>

https://github.com/spotify/docker-kafka

<pre>
$ <strong>docker run -p 2181:2181 -p 9092:9092 --env ADVERTISED_HOST=`docker-machine ip \`docker-machine active\`` --env ADVERTISED_PORT=9092 spotify/kafka</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: předchozí nastavení předpokládá, že současně nepoběží žádná další instance Kafky ani Zookeepera. Pokud budete potřebovat spustit větší množství brokerů, je nutné minimálně změnit mapování portů (přepínače <strong>-p</strong>).</div></p>

export KAFKA=`docker-machine ip \`docker-machine active\``:9092
kafka-console-producer.sh --broker-list $KAFKA --topic test

export ZOOKEEPER=`docker-machine ip \`docker-machine active\``:2181
kafka-console-consumer.sh --zookeeper $ZOOKEEPER --topic test



<p><a name="k08"></a></p>
<h2 id="k08">8. Užitečný nástroj <strong>kafkacat</strong></h2>

<p>Součástí ekosystému vytvořeného okolo Apache Kafky je i užitečný nástroj
nazvaný <strong>kafkacat</strong> (autoři ho taktéž označují jako &bdquo;netcat
for Kafka&ldquo;, v&nbsp;kontextu REST API by se hodilo i &bdquo;curl for
Kafka&ldquo;). Tento nástroj, který naleznete na adrese <a
href="https://github.com/edenhill/kafkacat">https://github.com/edenhill/kafkacat</a>
slouží pro komunikaci s&nbsp;brokery přímo z&nbsp;příkazové řádky. Pochopitelně
se s&nbsp;velkou pravděpodobností nebude jednat o řešení používané
v&nbsp;produkčním kódu, ovšem možnost vytvořit producenta zpráv či jejich
konzumenta přímo z&nbsp;CLI je použitelná jak při vývoji, tak i při řešení
problémů, které mohou při běhu aplikace nastat. Tento nástroj budeme používat
později, při ukázkách nasazení Apache Kafky, takže se v&nbsp;této kapitole
krátce zmiňme o příkladech použití převzatých z&nbsp;oficiální dokumentace.
Všechny ukázky předpokládají, že broker běží na lokálním počítači na portu
9092.</p>

<p><div class="rs-tip-major">Poznámka: jedná se o nativní aplikaci, což je
velmi dobré řešení, protože se <strong>kafkacat</strong> spouští poměrně často.
To je v&nbsp;ostrém kontrastu se samotnou Kafkou, která sice startuje (jako
každá aplikace pod JVM) pomaleji, ovšem doba provozu se počítá spíše
v&nbsp;měsících a nikoli v&nbsp;sekundách.</div></p>

<p>Výpis informací o všech tématech a jejich konfigurace:</p>

<pre>
$ <strong>kafkacat -L -b localhost:9092</strong>
</pre>

<p>Spuštění nového producenta zpráv čtených ze souborů specifikovaných na
příkazové řádce:</p>

<pre>
$ <strong>kafkacat -P -b localhost:9092 -t filedrop -p 0 file1.bin file2.txt /etc/motd dalsi_soubor.tgz</strong>
</pre>

<p>Přečtení posledních 1000 zpráv z&nbsp;tématu &bdquo;téma1&ldquo;. Po této
operaci se konzument automaticky ukončí, tj.&nbsp;nebude čekat na další
zprávy:</p>

<pre>
$ <strong>kafkacat -C -b localhost:9092 -t tema1 -p 0 -o -1000 -e</strong>
</pre>

<p>Spuštění konzumentů, kteří jsou přihlášení k&nbsp;tématu
&bdquo;téma1&ldquo;:</p>

<pre>
$ <strong>kafkacat -b localhost:9092 -G skupina_konzumentů téma1</strong>
</pre>

<p>Přihlásit se lze i k&nbsp;odběru většího množství témat:</p>

<pre>
$ <strong>kafkacat -b localhost:9092 -G skupina_konzumentů téma1 téma2</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: možnosti nástroje
<strong>kafkacat</strong> jsou pochopitelně mnohem větší; některé z&nbsp;nich
si popíšeme v&nbsp;dalším textu.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Instalace nástroje <strong>kafkacat</strong></h2>

<p>Nástroj <strong>kafkacat</strong> se skládá z&nbsp;několika komponent, které
jsou většinou naprogramovány v&nbsp;jazyku C popř.&nbsp;v&nbsp;C++. Překlad a
slinkování lze provést takovým způsobem, že výsledkem bude jediný spustitelný
soubor nazvaný též &bdquo;kafkacat&ldquo;, který bude obsahovat i všechny
potřebné (tedy staticky slinkované) knihovny, což zjednodušuje nasazení této
utility. Na druhou stranu však nebude možné použít běžné prostředky operačního
systému při updatu knihoven, například při opravách CVE atd.</p>

<p>Napřed se provede naklonování repositáře:</p>

<pre>
$ <strong>git clone git@github.com:edenhill/kafkacat.git</strong>
</pre>

<p>po přesunu do naklonovaného repositáře:</p>

<pre>
$ <strong>cd kafkacat</strong>
</pre>

<p>se překlad provede běžnou trojkombinací configure+make+make install:</p>

<pre>
$ <strong>./configure</strong>
$ <strong>make</strong>
$ <strong>sudo make install</strong>
</pre>

<p>Alternativně je ovšem možné použít připravený skript
<strong>bootstrap.sh</strong>, který zajistí stažení všech potřebných knihoven
(crypto atd.) s&nbsp;jejich překladem:</p>

<pre>
$ <strong>./bootstrap.sh</strong>
</pre>

<p>Výsledkem je potom skutečně &bdquo;tlustý&ldquo; binární soubor:</p>

<pre>
$ <strong>ls -l ~/bin/kafkacat</strong>
-rwxrwxr-x. 1 ptisnovs ptisnovs <strong>20987784</strong> 17. led 14.34 /home/ptisnovs/bin/kafkacat
</pre>

<p>Některé linuxové distribuce obsahují přímo ve svých repositářích balíček
<strong>kafkacat</strong>, což samozřejmě celý proces instalace (a případných
updatů) značně zjednodušuje. Například na systémech založených na Debianu
postačuje použít:</p>

<pre>
$ <strong>apt-get install kafkacat</strong>
</pre>

<pre>

</pre>


<p><a name="k10"></a></p>
<h2 id="k10">10. Kafkacat v&nbsp;roli producenta i konzumenta zpráv</h2>

<p>Konzument zpráv posílaných do tématu &bdquo;upload&ldquo;:</p>

<pre>
$ <strong>kafkacat -C -b localhost:9092 -t "upload"</strong>
</pre>

<p>Producent zpráv zapisovaných na standardní vstup uživatelem (co zpráva, to
jeden řádek):</p>

<pre>
$ <strong>kafkacat -P -b localhost:9092 -t "upload"</strong>
</pre>

<p>Dtto, ale u každé zprávy lze specifikovat i klíč oddělený od těla zprávy
dvojtečkou:</p>

<pre>
$ <strong>kafkacat -P -b localhost:9092 -t "upload" -K:</strong>
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Naprogramování klientů pro Kafku</h2>

<p>Vzhledem k&nbsp;popularitě Kafky pravděpodobně nebude velkým překvapením, že
okolo ní vznikl celý rozsáhlý ekosystém. Jedná se především o následující
komponenty:</p>

<ol>

<li>Knihovnu Kafka Streams používanou při programování klientů pro Kafku
v&nbsp;Javě a dalších jazycích postavených nad JVM.</li>

<li>Knihovny umožňující připojení ke Kafce z&nbsp;mnoha programovacích
jazyků.</li>

<li>Konektory pro další služby, produkující proud dat.</li>

<li>Konektory pro další služby, které naopak proudy dat konzumují.</li>

<li>Konektory pro různé databáze sloužící pro vstup dat (relační databáze
s&nbsp;JDBC driverem, Cassandra, Couchbase atd. atd.)</li>

<li>Konektory pro databáze pro uložení dat (Amazon S3, Hadoop, ...)</li>

<li>Rozhraní pro systémy pro zpracování logů.</li>

<li>Již připravení konzumenti zpráv.</li>

<li>Již připravení producenti zpráv &ndash; systémy pro poskytování metrik atd.
(viz též další text).</li>

<li>Klient ovládaný z&nbsp;příkazové řádky (<strong>kafkacat</strong>), který
byl již zmíněn v&nbsp;předchozích kapitolách.</li>

</ol>

<a href="https://www.root.cz/obrazek/362664/"><img src="https://i.iinfo.cz/images/138/microservices4-1-prev.png" class="image-362664" alt="&#160;" width="370" height="237" /></a>
<p><i>Obrázek 6: Příklad použití ekosystému Kafky (Kafka Streams, konektory pro databáze atd.).</i></p>

<p>Samotný systém Apache Kafka je naprogramován v&nbsp;Javě, takže jeho
primární platformou je pochopitelně JVM (<i>Java Virtual Machine</i>). To však
pochopitelně neznamená, že se Kafka nedá použít i z&nbsp;dalších programovacích
jazyků. Ve skutečnosti existují rozhraní pro prakticky všechny používané a/nebo
populární (což není v&nbsp;IT vždy totéž) programovací jazyky. Tato rozhraní
jsou vypsána v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Jazyk/platforma</th></tr>
<tr><td> 1</td><td><a href="https://github.com/edenhill/librdkafka">C/C++</a></td></tr>
<tr><td> 2</td><td><a href="https://github.com/confluentinc/confluent-kafka-python">Python</a></td></tr>
<tr><td> 3</td><td><a href="https://github.com/Shopify/sarama">Go/Golang</a> <a href="https://github.com/confluentinc/confluent-kafka-go">Go/Golang</a></td></tr>
<tr><td> 4</td><td><a href="https://github.com/klarna/brod">Erlang</a></td></tr>
<tr><td> 5</td><td><a href="https://github.com/confluentinc/confluent-kafka-dotnet">.NET</a></td></tr>
<tr><td> 6</td><td><a href="https://github.com/zendesk/ruby-kafka">Ruby</a></td></tr>
<tr><td> 7</td><td><a href="https://github.com/Blizzard/node-rdkafka">Node.js</a></td></tr>
<tr><td> 8</td><td><a href="https://github.com/TrackingSoft/Kafka">Perl</a></td></tr>
<tr><td> 9</td><td><a href="https://github.com/EVODelavega/phpkafka">PHP</a></td></tr>
<tr><td>10</td><td><a href="https://github.com/spicavigo/kafka-rust">Rust</a></td></tr>
<tr><td>11</td><td><a href="https://github.com/wurstmeister/storm-kafka-0.8-plus">Storm</a></td></tr>
<tr><td>12</td><td><a href="https://github.com/elodina/scala-kafka">Scala (DSL jazyk)</a></td></tr>
<tr><td>13</td><td><a href="https://github.com/pingles/clj-kafka">Clojure</a></td></tr>
<tr><td>14</td><td><a href="https://github.com/gerritjvv/kafka-fast">Clojure</a></td></tr>
<tr><td>15</td><td><a href="https://github.com/kellanburket/franz">Swift</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td><a href="https://github.com/edenhill/kafkacat">CLI (stdin/stdout)</a></td></tr>
</table>

<p>V&nbsp;navazujících kapitolách si ukážeme, jakým způsobem lze vytvořit
producenta i konzumenta zpráv v&nbsp;programovacích jazycích <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">Go</a> a <a
href="https://www.root.cz/n/python/">Python</a> (typicky se Go používá na
straně producenta zpráv, zatímco Python doplněný například o ML a AI knihovny
na straně konzumenta).</p>

<a href="https://www.root.cz/obrazek/361674/"><img src="https://i.iinfo.cz/images/447/microservices2-7-prev.png" class="image-361674" alt="kappa" height="270" width="279"></a>
<p><i>Obrázek 7: Schéma aplikace založené na architektuře kappa, ke které se
ještě vrátíme v&nbsp;dalších částech tohoto seriálu.</i></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Producent zpráv vytvořený v&nbsp;Pythonu</h2>

<pre>
$ <strong>pip3 install --user kafka</strong>
&nbsp;
Collecting kafka
  Downloading https://files.pythonhosted.org/packages/21/71/73286e748ac5045b6a669c2fe44b03ac4c5d3d2af9291c4c6fc76438a9a9/kafka-1.3.5-py2.py3-none-any.whl (207kB)
    100% |████████████████████████████████| 215kB 1.8MB/s 
Installing collected packages: kafka
Successfully installed kafka-1.3.5
</pre>

<pre>
#!/usr/bin/env python3

from kafka import KafkaProducer
from time import sleep
from json import dumps

server = 'localhost:9092'
topic = 'upload'

print('Connecting to Kafka')
producer = KafkaProducer(bootstrap_servers=[server],
                         value_serializer=lambda x: dumps(x).encode('utf-8'))
print('Connected to Kafka')

for i in range(1000):
    data = {'counter': i}
    producer.send(topic, value=data)
    sleep(5)
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Konzument zpráv naprogramovaný v&nbsp;Pythonu</h2>

<pre>
#!/usr/bin/env python3
  
import sys
from kafka import KafkaConsumer

server = 'localhost:9092'
topic = 'upload'
group_id = 'group1'

print('Connecting to Kafka')
consumer = KafkaConsumer(topic,
                         group_id=group_id,
                         bootstrap_servers=[server],
                         auto_offset_reset='earliest')
print('Connected to Kafka')

try:
    for message in consumer:
        print("%s:%d:%d: key=%s value=%s" % (message.topic, message.partition, message.offset, message.key, message.value))
except KeyboardInterrupt:
    sys.exit()

</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Přehrání (<i>replay</i>) zpráv</h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. Producent zpráv naprogramovaný v&nbsp;jazyce Go</h2>

<pre>
$ <strong>export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/lib/pkgconfig/</strong>
</pre>

<pre>
$ <strong>go get -u gopkg.in/confluentinc/confluent-kafka-go.v1/kafka</strong>
</pre>

<pre>
package main
  
import (
        "fmt"
        "gopkg.in/confluentinc/confluent-kafka-go.v1/kafka"
)

const (
        server = "localhost"
)

func main() {
        topic := "upload"

        producer, err := kafka.NewProducer(&kafka.ConfigMap{
                "bootstrap.servers": server,
        })
        defer producer.Close()

        if err != nil {
                panic(err)
        }

        go func() {
                for event := range producer.Events() {
                        switch ev := event.(type) {
                        case *kafka.Message:
                                if ev.TopicPartition.Error != nil {
                                        fmt.Printf("Delivery failed: %v\n", ev.TopicPartition)
                                } else {
                                        fmt.Printf("Delivered message to %v\n", ev.TopicPartition)
                                }
                        }
                }
        }()

        for i := 0; i &lt; 100; i++ {
                text := fmt.Sprintf("Message #%d", i)
                producer.Produce(&kafka.Message{
                        TopicPartition: kafka.TopicPartition{Topic: &topic, Partition: kafka.PartitionAny},
                        Value:          []byte(text),
                }, nil)
        }
        producer.Flush(15 * 1000)
}
</pre>

<pre>
$ <strong>go build producer1.go</strong>
&nbsp;
$ <strong>ldd ./producer1</strong>
        linux-vdso.so.1 (0x00007ffc70b8e000)
        librdkafka.so.1 =&gt; not found
        libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007ffb2b6f8000)
        libc.so.6 =&gt; /lib64/libc.so.6 (0x00007ffb2b342000)
        /lib64/ld-linux-x86-64.so.2 (0x00007ffb2b916000)
</pre>

<pre>
$ <strong>go build -tags static producer1.go</strong>
&nbsp;
$ <strong>ldd ./producer1</strong>
        linux-vdso.so.1 (0x00007ffdd3156000)
        libm.so.6 =&gt; /lib64/libm.so.6 (0x00007f424359c000)
        libz.so.1 =&gt; /lib64/libz.so.1 (0x00007f4243385000)
        libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f4243181000)
        libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007f4242f63000)
        librt.so.1 =&gt; /lib64/librt.so.1 (0x00007f4242d5b000)
        libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f42429a5000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f42438e7000)
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Konzument zpráv vytvořený v&nbsp;Go</h2>

<pre>
package main
  
import (
        "fmt"
        "gopkg.in/confluentinc/confluent-kafka-go.v1/kafka"
)

const (
        server   = "localhost:9092"
        topic    = "upload"
        group_id = "group1"
)

func main() {
        consumer, err := kafka.NewConsumer(&kafka.ConfigMap{
                "bootstrap.servers": server,
                "group.id":          group_id,
                "auto.offset.reset": "earliest",
        })
        defer consumer.Close()

        if err != nil {
                panic(err)
        }

        consumer.SubscribeTopics([]string{topic}, nil)

        for {
                message, err := consumer.ReadMessage(-1)
                if err == nil {
                        fmt.Printf("Message on %s: %s %s\n", message.TopicPartition, string(message.Key), string(message.Value))
                } else {
                        fmt.Printf("Consumer error: %v (%v)\n", err, message)
                }
        }
}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Alternativa k&nbsp;systému Kafka: nástroj NATS</h2>

<p>V&nbsp;článku <a
href="https://www.root.cz/clanky/komunikace-s-message-brokery-z-programovaciho-jazyka-go/">Komunikace
s&nbsp;message brokery z&nbsp;programovacího jazyka Go</a>, který je taktéž
součástí <a href="https://www.root.cz/serialy/message-brokery/">seriálu o
message brokerech</a>, jsme se ve stručnosti seznámili s&nbsp;projektem <a
href="https://nats.io/">NATS</a>. Připomeňme si, že se jedná o poměrně úspěšný
a často nasazovaný projekt, jenž je vyvinut <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">v&nbsp;programovacím
jazyku Go</a>, což mu do jisté míry zajišťuje stabilitu i škálovatelnost. To
jsou vlastnosti, které u message brokerů většinou očekáváme.</p>

<p>Také jsme si řekli, že se systém NATS skládá z&nbsp;několika komponent:</p>

<ol>

<li>V&nbsp;první řadě se jedná o samotný <i>server</i>, jenž se spouští
příkazem <strong>gnatsd</strong>. Server je naprogramovaný v&nbsp;Go a při jeho
vývoji bylo dbáno na to, aby byla zaručena vysoká dostupnost celé služby a
přitom byla samotná služba s&nbsp;běžícím serverem málo náročná na systémové
zdroje, především na spotřebu operační paměti (to má v&nbsp;době Dockeru a
podobných nástrojů poměrně velký význam).</li>

<li>Dalším typem komponenty jsou programátorská rozhraní pro klienty, která
v&nbsp;současnosti existují pro několik ekosystémů (což je většinou kombinace
programovacího jazyka, knihoven a popř.&nbsp;jeho virtuálního stroje); viz též
tabulky s&nbsp;podporovanými ekosystémy, které jsou zobrazeny pod tímto
seznamem. Programátorské rozhraní určené pro jazyk Go bude popsáno <a
href="#k03">ve třetí kapitole</a> i v&nbsp;kapitolách navazujících.</li>

<li>Třetí komponentou je <i>NATS Streaming Server</i>, který je opět
naprogramován v&nbsp;jazyce Go. Způsobem využití Streaming Serveru a vůbec
teorií, na které streamování stojí, se budeme věnovat v&nbsp;dalším
článku.</li>

<li>Čtvrtým typem komponenty je takzvaný <i>NATS Connector Framework</i>
zajišťující propojení systému NATS s&nbsp;dalšími technologiemi (XMPP,
logování, notifikační služby aj.). Ten je naprogramovaný v&nbsp;Javě a
v&nbsp;současnosti je podporován například konektor pro Redis.</li>

</ol>



<p><a name="k18"></a></p>
<h2 id="k18">18. Termíny používané v&nbsp;souvislosti s&nbsp;message brokery</h2>

<p>V&nbsp;této kapitole jsou zmíněny významy některých termínů, s&nbsp;nimiž se
v&nbsp;souvislosti s&nbsp;message brokery a se streamingem často setkáme. České
překlady jsou ovšem pouze přibližné, protože oficiální terminologie
pravděpodobně ještě neexistuje:</p>

<table>
<tr><th>#</th><th>Původní termín</th><th>Přibližný český překlad</th><th>Stručný popis významu termínu</th></tr>
<tr><td>1</td><td>message</td><td>zpráva</td><td>ucelená informace či data posílaná mezi producentem a konzumentem přes message brokera popř.&nbsp;větší množství message brokerů</td></tr>
<tr><td>2</td><td>record</td><td>záznam</td><td>alternativní pojmenování pro zprávu, používané především v&nbsp;některých streamovacích message brokerech, například v&nbsp;Apache Kafka</td></tr>
<tr><td>3</td><td>producer</td><td>producent</td><td>aplikace/proces, která vytváří zprávy a posílá je do message brokera</td></tr>
<tr><td>4</td><td>consumer</td><td>konzument</td><td>aplikace/proces, která zprávy z&nbsp;message brokera přijímá</td></tr>
<tr><td>5</td><td>consumer group</td><td>skupina konzumentů</td><td>skupina konzumentů přijímajících zprávy z&nbsp;jednoho společného tématu; používáno například v&nbsp;dnes popisovaném systému Apache Kafka</td></tr>
<tr><td>6</td><td>topic</td><td>téma</td><td>kategorie či značka, pod kterou je zpráva v&nbsp;brokeru uložena a publikována; používá se pro směrování a/nebo pro ukládání zpráv</td></tr>
<tr><td>7</td><td>subject</td><td>téma</td><td>alternativní označení pro <i>topic</i>; použito pouze v&nbsp;některých message brokerech</td></tr>
<tr><td>8</td><td>topic partition</td><td></td><td>rozdělení tématu na oddíly, které mohou být rozmístěny na různé brokery v&nbsp;clusteru (opět najdeme i v&nbsp;Kafce)</td></tr>
<tr><td>9</td><td>replica</td><td>replika/duplikát</td><td>záložní kopie oddílu, typicky uložená na jiném brokeru</td></tr>
<tr><td>10</td><td>offset</td><td>ofset</td><td>unikátní identifikátor platný v&nbsp;rámci oddílu (popř.&nbsp;tématu), který umožňuje konzumentům specifikovat, kterou zprávu mají zpracovávat</td></tr>
</table>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů vyvinutých
v&nbsp;programovacím jazyku Python a Go byly uloženy do Git repositáře, který
je dostupný na adrese <a
href="https://github.com/tisnik/message-queues-examples">https://github.com/tisnik/message-queues-examples</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
stále ještě doslova několik kilobajtů), můžete namísto toho použít odkazy na
jednotlivé příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Zdrojový kód</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td>1</td><td>producer1.py</td><td>producent pro Kafku naprogramovaný v&nbsp;Pythonu</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/kafka/producer1.py">https://github.com/tisnik/message-queues-examples/blob/master/kafka/producer1.py</a></td></tr>
<tr><td>2</td><td>consumer1.py</td><td>konzument pro Kafku naprogramovaný v&nbsp;Pythonu</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/kafka/consumer1.py">https://github.com/tisnik/message-queues-examples/blob/master/kafka/consumer1.py</a></td></tr>
<tr><td>3</td><td>producer1.go</td><td>producent pro Kafku naprogramovaný v&nbsp;jazyce Go</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/kafka/producer1.go">https://github.com/tisnik/message-queues-examples/blob/master/kafka/producer1.go</a></td></tr>
<tr><td>4</td><td>consumer1.go</td><td>konzument pro Kafku naprogramovaný v&nbsp;jazyce Go</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/kafka/consumer1.go">https://github.com/tisnik/message-queues-examples/blob/master/kafka/consumer1.go</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Microservices: The Rise Of Kafka<br />
<a href="https://movio.co/blog/microservices-rise-kafka/">https://movio.co/blog/microservices-rise-kafka/</a>
</li>

<li>Building a Microservices Ecosystem with Kafka Streams and KSQL<br />
<a href="https://www.confluent.io/blog/building-a-microservices-ecosystem-with-kafka-streams-and-ksql/">https://www.confluent.io/blog/building-a-microservices-ecosystem-with-kafka-streams-and-ksql/</a>
</li>

<li>An introduction to Apache Kafka and microservices communication<br />
<a href="https://medium.com/@ulymarins/an-introduction-to-apache-kafka-and-microservices-communication-bf0a0966d63">https://medium.com/@ulymarins/an-introduction-to-apache-kafka-and-microservices-communication-bf0a0966d63</a>
</li>

<li>kappa-architecture.com<br />
<a href="http://milinda.pathirage.org/kappa-architecture.com/">http://milinda.pathirage.org/kappa-architecture.com/</a>
</li>

<li>Questioning the Lambda Architecture<br />
<a href="https://www.oreilly.com/ideas/questioning-the-lambda-architecture">https://www.oreilly.com/ideas/questioning-the-lambda-architecture</a>
</li>

<li>Lambda architecture<br />
<a href="https://en.wikipedia.org/wiki/Lambda_architecture">https://en.wikipedia.org/wiki/Lambda_architecture</a>
</li>

<li>Kafka &ndash; ecosystem (Wiki)<br />
<a href="https://cwiki.apache.org/confluence/display/KAFKA/Ecosystem">https://cwiki.apache.org/confluence/display/KAFKA/Ecosystem</a>
</li>

<li>The Kafka Ecosystem - Kafka Core, Kafka Streams, Kafka Connect, Kafka REST Proxy, and the Schema Registry<br />
<a href="http://cloudurable.com/blog/kafka-ecosystem/index.html">http://cloudurable.com/blog/kafka-ecosystem/index.html</a>
</li>

<li>A Kafka Operator for Kubernetes<br />
<a href="https://github.com/krallistic/kafka-operator">https://github.com/krallistic/kafka-operator</a>
</li>

<li>Kafka Streams<br />
<a href="https://cwiki.apache.org/confluence/display/KAFKA/Kafka+Streams">https://cwiki.apache.org/confluence/display/KAFKA/Kafka+Streams</a>
</li>

<li>Kafka Streams<br />
<a href="http://kafka.apache.org/documentation/streams/">http://kafka.apache.org/documentation/streams/</a>
</li>

<li>Kafka Streams (FAQ)<br />
<a href="https://cwiki.apache.org/confluence/display/KAFKA/FAQ#FAQ-Streams">https://cwiki.apache.org/confluence/display/KAFKA/FAQ#FAQ-Streams</a>
</li>

<li>Event stream processing<br />
<a href="https://en.wikipedia.org/wiki/Event_stream_processing">https://en.wikipedia.org/wiki/Event_stream_processing</a>
</li>

<li>Part 1: Apache Kafka for beginners - What is Apache Kafka?<br />
<a href="https://www.cloudkarafka.com/blog/2016-11-30-part1-kafka-for-beginners-what-is-apache-kafka.html">https://www.cloudkarafka.com/blog/2016-11-30-part1-kafka-for-beginners-what-is-apache-kafka.html</a>
</li>

<li>What are some alternatives to Apache Kafka?<br />
<a href="https://www.quora.com/What-are-some-alternatives-to-Apache-Kafka">https://www.quora.com/What-are-some-alternatives-to-Apache-Kafka</a>
</li>

<li>What is the best alternative to Kafka?<br />
<a href="https://www.slant.co/options/961/alternatives/~kafka-alternatives">https://www.slant.co/options/961/alternatives/~kafka-alternatives</a>
</li>

<li>A super quick comparison between Kafka and Message Queues<br />
<a href="https://hackernoon.com/a-super-quick-comparison-between-kafka-and-message-queues-e69742d855a8?gi=e965191e72d0">https://hackernoon.com/a-super-quick-comparison-between-kafka-and-message-queues-e69742d855a8?gi=e965191e72d0</a>
</li>

<li>Kafka Queuing: Kafka as a Messaging System<br />
<a href="https://dzone.com/articles/kafka-queuing-kafka-as-a-messaging-system">https://dzone.com/articles/kafka-queuing-kafka-as-a-messaging-system</a>
</li>

<li>POSIX message queues in Linux<br />
<a href="https://www.softprayog.in/programming/interprocess-communication-using-posix-message-queues-in-linux">https://www.softprayog.in/programming/interprocess-communication-using-posix-message-queues-in-linux</a>
</li>

<li>How is a message queue implemented in the Linux kernel?<br />
<a href="https://unix.stackexchange.com/questions/6930/how-is-a-message-queue-implemented-in-the-linux-kernel/6935">https://unix.stackexchange.com/questions/6930/how-is-a-message-queue-implemented-in-the-linux-kernel/6935</a>
</li>

<li>‘IPCS’ command in Linux with examples<br />
<a href="https://www.geeksforgeeks.org/ipcs-command-linux-examples/">https://www.geeksforgeeks.org/ipcs-command-linux-examples/</a>
</li>

<li>System V IPC: Message Queues<br />
<a href="https://nitish712.blogspot.com/2012/11/system-v-ipc-message-queues.html">https://nitish712.blogspot.com/2012/11/system-v-ipc-message-queues.html</a>
</li>

<li>How to create, check and delete IPC share memory, semaphare and message queue on linux <br />
<a href="https://fibrevillage.com/sysadmin/225-how-to-create-check-and-delete-ipc-share-memory-semaphare-and-message-queue-on-linux">https://fibrevillage.com/sysadmin/225-how-to-create-check-and-delete-ipc-share-memory-semaphare-and-message-queue-on-linux</a>
</li>

<li>MQ_OVERVIEW(7): Linux Programmer's Manual<br />
<a href="http://man7.org/linux/man-pages/man7/mq_overview.7.html">http://man7.org/linux/man-pages/man7/mq_overview.7.html</a>
</li>

<li>mq_overview (7) - Linux Man Pages<br />
<a href="https://www.systutorials.com/docs/linux/man/7-mq_overview/">https://www.systutorials.com/docs/linux/man/7-mq_overview/</a>
</li>

<li>POSIX.4 Message Queues (+ rozšíření QNX)<br />
<a href="https://users.pja.edu.pl/~jms/qnx/help/watcom/clibref/mq_overview.html">https://users.pja.edu.pl/~jms/qnx/help/watcom/clibref/mq_overview.html</a>
</li>

<li>System V message queues in Linux<br />
<a href="https://www.softprayog.in/programming/interprocess-communication-using-system-v-message-queues-in-linux">https://www.softprayog.in/programming/interprocess-communication-using-system-v-message-queues-in-linux</a>
</li>

<li>Linux System V and POSIX IPC Examples<br />
<a href="http://hildstrom.com/projects/ipc_sysv_posix/index.html">http://hildstrom.com/projects/ipc_sysv_posix/index.html</a>
</li>

<li>Programming Tutorial - Linux: Message Queues<br />
<a href="https://ccppcoding.blogspot.com/2013/03/linux-message-queues.html">https://ccppcoding.blogspot.com/2013/03/linux-message-queues.html</a>
</li>

<li>Go wrapper for POSIX Message Queues <br />
<a href="https://github.com/syucream/posix_mq">https://github.com/syucream/posix_mq</a>
</li>

<li>Stránka projektu NSQ<br />
<a href="https://nsq.io/">https://nsq.io/</a>
</li>

<li>Dokumentace k&nbsp;projektu NSQ<br />
<a href="https://nsq.io/overview/design.html">https://nsq.io/overview/design.html</a>
</li>

<li>Dokumentace ke klientovi pro Go<br />
<a href="https://godoc.org/github.com/nsqio/go-nsq">https://godoc.org/github.com/nsqio/go-nsq</a>
</li>

<li>Dokumentace ke klientovi pro Python<br />
<a href="https://pynsq.readthedocs.io/en/latest/">https://pynsq.readthedocs.io/en/latest/</a>
</li>

<li>Binární tarbally s&nbsp;NSQ<br />
<a href="https://nsq.io/deployment/installing.html">https://nsq.io/deployment/installing.html</a>
</li>

<li>GitHub repositář projektu NSQ<br />
<a href="https://github.com/nsqio/nsq">https://github.com/nsqio/nsq</a>
</li>

<li>Klienti pro NSQ<br />
<a href="https://nsq.io/clients/client_libraries.html">https://nsq.io/clients/client_libraries.html</a>
</li>

<li>Klient pro Go<br />
<a href="https://github.com/nsqio/go-nsq">https://github.com/nsqio/go-nsq</a>
</li>

<li>Klient pro Python<br />
<a href="https://github.com/nsqio/pynsq">https://github.com/nsqio/pynsq</a>
</li>

<li>An Example of Using NSQ From Go<br />
<a href="http://tleyden.github.io/blog/2014/11/12/an-example-of-using-nsq-from-go/">http://tleyden.github.io/blog/2014/11/12/an-example-of-using-nsq-from-go/</a>
</li>

<li>Go Go Gadget<br />
<a href="https://word.bitly.com/post/29550171827/go-go-gadget">https://word.bitly.com/post/29550171827/go-go-gadget</a>
</li>

<li>Simplehttp<br />
<a href="https://github.com/bitly/simplehttp">https://github.com/bitly/simplehttp</a>
</li>

<li>Dramatiq: simple task processing<br />
<a href="https://dramatiq.io/">https://dramatiq.io/</a>
</li>

<li>Cookbook (for Dramatiq)<br />
<a href="https://dramatiq.io/cookbook.html">https://dramatiq.io/cookbook.html</a>
</li>

<li>Balíček dramatiq na PyPi<br />
<a href="https://pypi.org/project/dramatiq/">https://pypi.org/project/dramatiq/</a>
</li>

<li>Dramatiq dashboard<br />
<a href="https://github.com/Bogdanp/dramatiq_dashboard">https://github.com/Bogdanp/dramatiq_dashboard</a>
</li>

<li>Dramatiq na Redditu<br />
<a href="https://www.reddit.com/r/dramatiq/">https://www.reddit.com/r/dramatiq/</a>
</li>

<li>A Dramatiq broker that can be used with Amazon SQS<br />
<a href="https://github.com/Bogdanp/dramatiq_sqs">https://github.com/Bogdanp/dramatiq_sqs</a>
</li>

<li>nanomsg na GitHubu<br />
<a href="https://github.com/nanomsg/nanomsg">https://github.com/nanomsg/nanomsg</a>
</li>

<li>Referenční příručka knihovny <strong>nanomsg</strong><br />
<a href="https://nanomsg.org/v1.1.5/nanomsg.html">https://nanomsg.org/v1.1.5/nanomsg.html</a>
</li>

<li>nng (nanomsg-next-generation)<br />
<a href="https://github.com/nanomsg/nng">https://github.com/nanomsg/nng</a>
</li>

<li>Differences between nanomsg and ZeroMQ<br />
<a href="https://nanomsg.org/documentation-zeromq.html">https://nanomsg.org/documentation-zeromq.html</a>
</li>

<li>NATS<br />
<a href="https://nats.io/about/">https://nats.io/about/</a>
</li>

<li>NATS Streaming Concepts<br />
<a href="https://nats.io/documentation/streaming/nats-streaming-intro/">https://nats.io/documentation/streaming/nats-streaming-intro/</a>
</li>

<li>NATS Streaming Server<br />
<a href="https://nats.io/download/nats-io/nats-streaming-server/">https://nats.io/download/nats-io/nats-streaming-server/</a>
</li>

<li>NATS Introduction<br />
<a href="https://nats.io/documentation/">https://nats.io/documentation/</a>
</li>

<li>NATS Client Protocol<br />
<a href="https://nats.io/documentation/internals/nats-protocol/">https://nats.io/documentation/internals/nats-protocol/</a>
</li>

<li>NATS Messaging (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/NATS_Messaging">https://en.wikipedia.org/wiki/NATS_Messaging</a>
</li>

<li>Stránka Apache Software Foundation<br />
<a href="http://www.apache.org/">http://www.apache.org/</a>
</li>

<li>Informace o portu 5672<br />
<a href="http://www.tcp-udp-ports.com/port-5672.htm">http://www.tcp-udp-ports.com/port-5672.htm</a>
</li>

<li>Třída MessagingHandler knihovny Qpid Proton<br />
<a href="https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._handlers.MessagingHandler-class.html">https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._handlers.MessagingHandler-class.html</a>
</li>

<li>Třída Event knihovny Qpid Proton<br />
<a href="https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._events.Event-class.html">https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._events.Event-class.html</a>
</li>

<li>package stomp (Go)<br />
<a href="https://godoc.org/github.com/go-stomp/stomp">https://godoc.org/github.com/go-stomp/stomp</a>
</li>

<li>Go language library for STOMP protocol<br />
<a href="https://github.com/go-stomp/stomp">https://github.com/go-stomp/stomp</a>
</li>

<li>python-qpid-proton 0.26.0 na PyPi<br />
<a href="https://pypi.org/project/python-qpid-proton/">https://pypi.org/project/python-qpid-proton/</a>
</li>

<li>Qpid Proton<br />
<a href="http://qpid.apache.org/proton/">http://qpid.apache.org/proton/</a>
</li>

<li>Using the AMQ Python Client<br />
<a href="https://access.redhat.com/documentation/en-us/red_hat_amq/7.1/html-single/using_the_amq_python_client/">https://access.redhat.com/documentation/en-us/red_hat_amq/7.1/html-single/using_the_amq_python_client/</a>
</li>

<li>Apache ActiveMQ<br />
<a href="http://activemq.apache.org/">http://activemq.apache.org/</a>
</li>

<li>Apache ActiveMQ Artemis<br />
<a href="https://activemq.apache.org/artemis/">https://activemq.apache.org/artemis/</a>
</li>

<li>Apache ActiveMQ Artemis User Manual<br />
<a href="https://activemq.apache.org/artemis/docs/latest/index.html">https://activemq.apache.org/artemis/docs/latest/index.html</a>
</li>

<li>KahaDB<br />
<a href="http://activemq.apache.org/kahadb.html">http://activemq.apache.org/kahadb.html</a>
</li>

<li>Understanding the KahaDB Message Store<br />
<a href="https://access.redhat.com/documentation/en-US/Fuse_MQ_Enterprise/7.1/html/Configuring_Broker_Persistence/files/KahaDBOverview.html">https://access.redhat.com/documentation/en-US/Fuse_MQ_Enterprise/7.1/html/Configuring_Broker_Persistence/files/KahaDBOverview.html</a>
</li>

<li>Command Line Tools (Apache ActiveMQ)<br />
<a href="https://activemq.apache.org/activemq-command-line-tools-reference.html">https://activemq.apache.org/activemq-command-line-tools-reference.html</a>
</li>

<li>stomp.py 4.1.21 na PyPi<br />
<a href="https://pypi.org/project/stomp.py/">https://pypi.org/project/stomp.py/</a>
</li>

<li>Stomp Tutorial<br />
<a href="https://access.redhat.com/documentation/en-US/Fuse_Message_Broker/5.5/html/Connectivity_Guide/files/FMBConnectivityStompTelnet.html">https://access.redhat.com/documentation/en-US/Fuse_Message_Broker/5.5/html/Connectivity_Guide/files/FMBConnectivityStompTelnet.html</a>
</li>

<li>Heartbeat (computing)<br />
<a href="https://en.wikipedia.org/wiki/Heartbeat_(computing)">https://en.wikipedia.org/wiki/Heartbeat_(computing)</a>
</li>

<li>Apache Camel<br />
<a href="https://camel.apache.org/">https://camel.apache.org/</a>
</li>

<li>Red Hat Fuse<br />
<a href="https://developers.redhat.com/products/fuse/overview/">https://developers.redhat.com/products/fuse/overview/</a>
</li>

<li>Confusion between ActiveMQ and ActiveMQ-Artemis?<br />
<a href="https://serverfault.com/questions/873533/confusion-between-activemq-and-activemq-artemis">https://serverfault.com/questions/873533/confusion-between-activemq-and-activemq-artemis</a>
</li>

<li>Staré stránky projektu HornetQ<br />
<a href="http://hornetq.jboss.org/">http://hornetq.jboss.org/</a>
</li>

<li>Snapshot JeroMQ verze 0.4.4<br />
<a href="https://oss.sonatype.org/content/repositories/snapshots/org/zeromq/jeromq/0.4.4-SNAPSHOT/">https://oss.sonatype.org/content/repositories/snapshots/org/zeromq/jeromq/0.4.4-SNAPSHOT/</a>
</li>

<li>Difference between ActiveMQ vs Apache ActiveMQ Artemis<br />
<a href="http://activemq.2283324.n4.nabble.com/Difference-between-ActiveMQ-vs-Apache-ActiveMQ-Artemis-td4703828.html">http://activemq.2283324.n4.nabble.com/Difference-between-ActiveMQ-vs-Apache-ActiveMQ-Artemis-td4703828.html</a>
</li>

<li>Microservices communications. Why you should switch to message queues<br />
<a href="https://dev.to/matteojoliveau/microservices-communications-why-you-should-switch-to-message-queues--48ia">https://dev.to/matteojoliveau/microservices-communications-why-you-should-switch-to-message-queues--48ia</a>
</li>

<li>Stomp.py 4.1.19 documentation<br />
<a href="https://stomppy.readthedocs.io/en/stable/">https://stomppy.readthedocs.io/en/stable/</a>
</li>

<li>Repositář knihovny JeroMQ<br />
<a href="https://github.com/zeromq/jeromq/">https://github.com/zeromq/jeromq/</a>
</li>

<li>ØMQ &ndash; Distributed Messaging <br />
<a href="http://zeromq.org/">http://zeromq.org/</a>
</li>

<li>ØMQ Community<br />
<a href="http://zeromq.org/community">http://zeromq.org/community</a>
</li>

<li>Get The Software<br />
<a href="http://zeromq.org/intro:get-the-software">http://zeromq.org/intro:get-the-software</a>
</li>

<li>PyZMQ Documentation<br />
<a href="https://pyzmq.readthedocs.io/en/latest/">https://pyzmq.readthedocs.io/en/latest/</a>
</li>

<li>Module: zmq.decorators<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.decorators.html">https://pyzmq.readthedocs.io/en/latest/api/zmq.decorators.html</a>
</li>

<li>ZeroMQ is the answer, by Ian Barber<br />
<a href="https://vimeo.com/20605470">https://vimeo.com/20605470</a>
</li>

<li>ZeroMQ RFC<br />
<a href="https://rfc.zeromq.org/">https://rfc.zeromq.org/</a>
</li>

<li>ZeroMQ and Clojure, a brief introduction<br />
<a href="https://antoniogarrote.wordpress.com/2010/09/08/zeromq-and-clojure-a-brief-introduction/">https://antoniogarrote.wordpress.com/2010/09/08/zeromq-and-clojure-a-brief-introduction/</a>
</li>

<li>zeromq/czmq<br />
<a href="https://github.com/zeromq/czmq">https://github.com/zeromq/czmq</a>
</li>

<li>golang wrapper for CZMQ<br />
<a href="https://github.com/zeromq/goczmq">https://github.com/zeromq/goczmq</a>
</li>

<li>ZeroMQ version reporting in Python<br />
<a href="http://zguide.zeromq.org/py:version">http://zguide.zeromq.org/py:version</a>
</li>

<li>A Go interface to ZeroMQ version 4<br />
<a href="https://github.com/pebbe/zmq4">https://github.com/pebbe/zmq4</a>
</li>

<li>Broker vs. Brokerless<br />
<a href="http://zeromq.org/whitepapers:brokerless">http://zeromq.org/whitepapers:brokerless</a>
</li>

<li>Learning ØMQ with pyzmq<br />
<a href="https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/">https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/</a>
</li>

<li>Céčková funkce <strong>zmq_ctx_new</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-ctx-new">http://api.zeromq.org/4-2:zmq-ctx-new</a>
</li>

<li>Céčková funkce <strong>zmq_ctx_destroy</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-ctx-destroy">http://api.zeromq.org/4-2:zmq-ctx-destroy</a>
</li>

<li>Céčková funkce <strong>zmq_bind</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-bind">http://api.zeromq.org/4-2:zmq-bind</a>
</li>

<li>Céčková funkce <strong>zmq_unbind</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-unbind">http://api.zeromq.org/4-2:zmq-unbind</a>
</li>

<li>Céčková C funkce <strong>zmq_connect</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-connect">http://api.zeromq.org/4-2:zmq-connect</a>
</li>

<li>Céčková C funkce <strong>zmq_disconnect</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-disconnect">http://api.zeromq.org/4-2:zmq-disconnect</a>
</li>

<li>Céčková C funkce <strong>zmq_send</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-send">http://api.zeromq.org/4-2:zmq-send</a>
</li>

<li>Céčková C funkce <strong>zmq_recv</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-recv">http://api.zeromq.org/4-2:zmq-recv</a>
</li>

<li>Třída <strong>Context</strong> (Python)<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.html#context">https://pyzmq.readthedocs.io/en/latest/api/zmq.html#context</a>
</li>

<li>Třída <strong>Socket</strong> (Python)<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.html#socket">https://pyzmq.readthedocs.io/en/latest/api/zmq.html#socket</a>
</li>

<li>Python binding<br />
<a href="http://zeromq.org/bindings:python">http://zeromq.org/bindings:python</a>
</li>

<li>Why should I have written ZeroMQ in C, not C++ (part I)<br />
<a href="http://250bpm.com/blog:4">http://250bpm.com/blog:4</a>
</li>

<li>Why should I have written ZeroMQ in C, not C++ (part II) <br />
<a href="http://250bpm.com/blog:8">http://250bpm.com/blog:8</a>
</li>

<li>About Nanomsg<br />
<a href="https://nanomsg.org/">https://nanomsg.org/</a>
</li>

<li>Advanced Message Queuing Protocol<br />
<a href="https://www.amqp.org/">https://www.amqp.org/</a>
</li>

<li>Advanced Message Queuing Protocol na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol">https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol</a>
</li>

<li>Dokumentace k&nbsp;příkazu <strong>rabbitmqctl</strong><br />
<a href="https://www.rabbitmq.com/rabbitmqctl.8.html">https://www.rabbitmq.com/rabbitmqctl.8.html</a>
</li>

<li>RabbitMQ<br />
<a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a>
</li>

<li>RabbitMQ Tutorials<br />
<a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a>
</li>

<li>RabbitMQ: Clients and Developer Tools<br />
<a href="https://www.rabbitmq.com/devtools.html">https://www.rabbitmq.com/devtools.html</a>
</li>

<li>RabbitMQ na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/RabbitMQ">https://en.wikipedia.org/wiki/RabbitMQ</a>
</li>

<li>Streaming Text Oriented Messaging Protocol<br />
<a href="https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol">https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol</a>
</li>

<li>Message Queuing Telemetry Transport<br />
<a href="https://en.wikipedia.org/wiki/MQTT">https://en.wikipedia.org/wiki/MQTT</a>
</li>

<li>Erlang<br />
<a href="http://www.erlang.org/">http://www.erlang.org/</a>
</li>

<li>pika 0.12.0 na PyPi<br />
<a href="https://pypi.org/project/pika/">https://pypi.org/project/pika/</a>
</li>

<li>Introduction to Pika<br />
<a href="https://pika.readthedocs.io/en/stable/">https://pika.readthedocs.io/en/stable/</a>
</li>

<li>Langohr: An idiomatic Clojure client for RabbitMQ that embraces the AMQP 0.9.1 model<br />
<a href="http://clojurerabbitmq.info/">http://clojurerabbitmq.info/</a>
</li>

<li>AMQP 0-9-1 Model Explained<br />
<a href="http://www.rabbitmq.com/tutorials/amqp-concepts.html">http://www.rabbitmq.com/tutorials/amqp-concepts.html</a>
</li>

<li>Part 1: RabbitMQ for beginners - What is RabbitMQ?<br />
<a href="https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html">https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html</a>
</li>

<li>Downloading and Installing RabbitMQ<br />
<a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a>
</li>

<li>celery na PyPi<br />
<a href="https://pypi.org/project/celery/">https://pypi.org/project/celery/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python <br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python (dokončení)<br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/</a>
</li>

<li>Redis Queue (RQ)<br />
<a href="https://www.fullstackpython.com/redis-queue-rq.html">https://www.fullstackpython.com/redis-queue-rq.html</a>
</li>

<li>Python Celery &amp; RabbitMQ Tutorial<br />
<a href="https://tests4geeks.com/python-celery-rabbitmq-tutorial/">https://tests4geeks.com/python-celery-rabbitmq-tutorial/</a>
</li>

<li>Flower: Real-time Celery web-monitor<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor">http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor</a>
</li>

<li>Asynchronous Tasks With Django and Celery<br />
<a href="https://realpython.com/asynchronous-tasks-with-django-and-celery/">https://realpython.com/asynchronous-tasks-with-django-and-celery/</a>
</li>

<li>First Steps with Celery<br />
<a href="http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html">http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html</a>
</li>

<li>node-celery<br />
<a href="https://github.com/mher/node-celery">https://github.com/mher/node-celery</a>
</li>

<li>Full Stack Python: web development<br />
<a href="https://www.fullstackpython.com/web-development.html">https://www.fullstackpython.com/web-development.html</a>
</li>

<li>Introducing RQ<br />
<a href="https://nvie.com/posts/introducing-rq/">https://nvie.com/posts/introducing-rq/</a>
</li>

<li>Asynchronous Tasks with Flask and Redis Queue<br />
<a href="https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue">https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Stránky projektu Redis<br />
<a href="https://redis.io/">https://redis.io/</a>
</li>

<li>Introduction to Redis<br />
<a href="https://redis.io/topics/introduction">https://redis.io/topics/introduction</a>
</li>

<li>Try Redis<br />
<a href="http://try.redis.io/">http://try.redis.io/</a>
</li>

<li>Redis tutorial, April 2010 (starší, ale pěkně udělaný)<br />
<a href="https://static.simonwillison.net/static/2010/redis-tutorial/">https://static.simonwillison.net/static/2010/redis-tutorial/</a>
</li>

<li>Python Redis<br />
<a href="https://redislabs.com/lp/python-redis/">https://redislabs.com/lp/python-redis/</a>
</li>

<li>Redis: key-value databáze v paměti i na disku<br />
<a href="https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/">https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/</a>
</li>

<li>Praktický úvod do Redis (1): vaše distribuovaná NoSQL cache<br />
<a href="http://www.cloudsvet.cz/?p=253">http://www.cloudsvet.cz/?p=253</a>
</li>

<li>Praktický úvod do Redis (2): transakce<br />
<a href="http://www.cloudsvet.cz/?p=256">http://www.cloudsvet.cz/?p=256</a>
</li>

<li>Praktický úvod do Redis (3): cluster<br />
<a href="http://www.cloudsvet.cz/?p=258">http://www.cloudsvet.cz/?p=258</a>
</li>

<li>Connection pool<br />
<a href="https://en.wikipedia.org/wiki/Connection_pool">https://en.wikipedia.org/wiki/Connection_pool</a>
</li>

<li>Instant Redis Sentinel Setup<br />
<a href="https://github.com/ServiceStack/redis-config">https://github.com/ServiceStack/redis-config</a>
</li>

<li>How to install REDIS in LInux<br />
<a href="https://linuxtechlab.com/how-install-redis-server-linux/">https://linuxtechlab.com/how-install-redis-server-linux/</a>
</li>

<li>Redis RDB Dump File Format<br />
<a href="https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format">https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format</a>
</li>

<li>Lempel–Ziv–Welch<br />
<a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch">https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch</a>
</li>

<li>Redis Persistence<br />
<a href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a>
</li>

<li>Redis persistence demystified<br />
<a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html">http://oldblog.antirez.com/post/redis-persistence-demystified.html</a>
</li>

<li>Redis reliable queues with Lua scripting<br />
<a href="http://oldblog.antirez.com/post/250">http://oldblog.antirez.com/post/250</a>
</li>

<li>Ost (knihovna)<br />
<a href="https://github.com/soveran/ost">https://github.com/soveran/ost</a>
</li>

<li>NoSQL<br />
<a href="https://en.wikipedia.org/wiki/NoSQL">https://en.wikipedia.org/wiki/NoSQL</a>
</li>

<li>Shard (database architecture)<br />
<a href="https://en.wikipedia.org/wiki/Shard_%28database_architecture%29">https://en.wikipedia.org/wiki/Shard_%28database_architecture%29</a>
</li>

<li>What is sharding and why is it important?<br />
<a href="https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important">https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important</a>
</li>

<li>What Is Sharding?<br />
<a href="https://btcmanager.com/what-sharding/">https://btcmanager.com/what-sharding/</a>
</li>

<li>Redis clients<br />
<a href="https://redis.io/clients">https://redis.io/clients</a>
</li>

<li>Category:Lua-scriptable software<br />
<a href="https://en.wikipedia.org/wiki/Category:Lua-scriptable_software">https://en.wikipedia.org/wiki/Category:Lua-scriptable_software</a>
</li>

<li>Seriál Programovací jazyk Lua<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-lua/">https://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>Redis memory usage<br />
<a href="http://nosql.mypopescu.com/post/1010844204/redis-memory-usage">http://nosql.mypopescu.com/post/1010844204/redis-memory-usage</a>
</li>

<li>Ukázka konfigurace Redisu pro lokální testování<br />
<a href="https://github.com/tisnik/presentations/blob/master/redis/redis.conf">https://github.com/tisnik/presentations/blob/master/redis/redis.conf</a>
</li>

<li>Resque<br />
<a href="https://github.com/resque/resque">https://github.com/resque/resque</a>
</li>

<li>Nested transaction<br />
<a href="https://en.wikipedia.org/wiki/Nested_transaction">https://en.wikipedia.org/wiki/Nested_transaction</a>
</li>

<li>Publish–subscribe pattern<br />
<a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern</a>
</li>

<li>Messaging pattern<br />
<a href="https://en.wikipedia.org/wiki/Messaging_pattern">https://en.wikipedia.org/wiki/Messaging_pattern</a>
</li>

<li>Using pipelining to speedup Redis queries<br />
<a href="https://redis.io/topics/pipelining">https://redis.io/topics/pipelining</a>
</li>

<li>Pub/Sub<br />
<a href="https://redis.io/topics/pubsub">https://redis.io/topics/pubsub</a>
</li>

<li>ZeroMQ distributed messaging<br />
<a href="http://zeromq.org/">http://zeromq.org/</a>
</li>

<li>ZeroMQ: Modern &amp; Fast Networking Stack<br />
<a href="https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/">https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/</a>
</li>

<li>Publish/Subscribe paradigm: Why must message classes not know about their subscribers?<br />
<a href="https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr">https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr</a>
</li>

<li>Python &amp; Redis PUB/SUB<br />
<a href="https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7">https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7</a>
</li>

<li>Message broker<br />
<a href="https://en.wikipedia.org/wiki/Message_broker">https://en.wikipedia.org/wiki/Message_broker</a>
</li>

<li>RESP Arrays<br />
<a href="https://redis.io/topics/protocol#array-reply">https://redis.io/topics/protocol#array-reply</a>
</li>

<li>Redis Protocol specification<br />
<a href="https://redis.io/topics/protocol">https://redis.io/topics/protocol</a>
</li>

<li>Redis Pub/Sub: Intro Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-intro/">https://www.redisgreen.net/blog/pubsub-intro/</a>
</li>

<li>Redis Pub/Sub: Howto Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-howto/">https://www.redisgreen.net/blog/pubsub-howto/</a>
</li>

<li>Comparing Publish-Subscribe Messaging and Message Queuing<br />
<a href="https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message">https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message</a>
</li>

<li>Apache Kafka<br />
<a href="https://kafka.apache.org/">https://kafka.apache.org/</a>
</li>

<li>Iron<br />
<a href="http://www.iron.io/mq">http://www.iron.io/mq</a>
</li>

<li>kue (založeno na Redisu, určeno pro node.js)<br />
<a href="https://github.com/Automattic/kue">https://github.com/Automattic/kue</a>
</li>

<li>Cloud Pub/Sub<br />
<a href="https://cloud.google.com/pubsub/">https://cloud.google.com/pubsub/</a>
</li>

<li>Introduction to Redis Streams<br />
<a href="https://redis.io/topics/streams-intro">https://redis.io/topics/streams-intro</a>
</li>

<li>glob (programming)<br />
<a href="https://en.wikipedia.org/wiki/Glob_(programming)">https://en.wikipedia.org/wiki/Glob_(programming)</a>
</li>

<li>Why and how Pricing Assistant migrated from Celery to RQ - Paris.py<br />
<a href="https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2">https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2</a>
</li>

<li>Enqueueing internals<br />
<a href="http://python-rq.org/contrib/">http://python-rq.org/contrib/</a>
</li>

<li>queue — A synchronized queue class<br />
<a href="https://docs.python.org/3/library/queue.html">https://docs.python.org/3/library/queue.html</a>
</li>

<li>Queue – A thread-safe FIFO implementation<br />
<a href="https://pymotw.com/2/Queue/">https://pymotw.com/2/Queue/</a>
</li>

<li>Queues<br />
<a href="http://queues.io/">http://queues.io/</a>
</li>

<li>Windows Subsystem for Linux Documentation<br />
<a href="https://docs.microsoft.com/en-us/windows/wsl/about">https://docs.microsoft.com/en-us/windows/wsl/about</a>
</li>

<li>RestMQ<br />
<a href="http://restmq.com/">http://restmq.com/</a>
</li>

<li>ActiveMQ<br />
<a href="http://activemq.apache.org/">http://activemq.apache.org/</a>
</li>

<li>Amazon MQ<br />
<a href="https://aws.amazon.com/amazon-mq/">https://aws.amazon.com/amazon-mq/</a>
</li>

<li>Amazon Simple Queue Service<br />
<a href="https://aws.amazon.com/sqs/">https://aws.amazon.com/sqs/</a>
</li>

<li>Celery: Distributed Task Queue<br />
<a href="http://www.celeryproject.org/">http://www.celeryproject.org/</a>
</li>

<li>Disque, an in-memory, distributed job queue<br />
<a href="https://github.com/antirez/disque">https://github.com/antirez/disque</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Projekt RQ na PyPi<br />
<a href="https://pypi.org/project/rq/">https://pypi.org/project/rq/</a>
</li>

<li>rq-dashboard 0.3.12<br />
<a href="https://pypi.org/project/rq-dashboard/">https://pypi.org/project/rq-dashboard/</a>
</li>

<li>Job queue<br />
<a href="https://en.wikipedia.org/wiki/Job_queue">https://en.wikipedia.org/wiki/Job_queue</a>
</li>

<li>Why we moved from Celery to RQ<br />
<a href="https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq">https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq</a>
</li>

<li>Running multiple workers using Celery<br />
<a href="https://serverfault.com/questions/655387/running-multiple-workers-using-celery">https://serverfault.com/questions/655387/running-multiple-workers-using-celery</a>
</li>

<li>celery — Distributed processing<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.html">http://docs.celeryproject.org/en/latest/reference/celery.html</a>
</li>

<li>Chains<br />
<a href="https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains">https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains</a>
</li>

<li>Routing<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing">http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing</a>
</li>

<li>Celery Distributed Task Queue in Go<br />
<a href="https://github.com/gocelery/gocelery/">https://github.com/gocelery/gocelery/</a>
</li>

<li>Python Decorators<br />
<a href="https://wiki.python.org/moin/PythonDecorators">https://wiki.python.org/moin/PythonDecorators</a>
</li>

<li>Periodic Tasks<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html">http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html</a>
</li>

<li>celery.schedules<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab">http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab</a>
</li>

<li>Pros and cons to use Celery vs. RQ<br />
<a href="https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq">https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq</a>
</li>

<li>Priority queue<br />
<a href="https://en.wikipedia.org/wiki/Priority_queue">https://en.wikipedia.org/wiki/Priority_queue</a>
</li>

<li>Jupyter<br />
<a href="https://jupyter.org/">https://jupyter.org/</a>
</li>

<li>How IPython and Jupyter Notebook work<br />
<a href="https://jupyter.readthedocs.io/en/latest/architecture/how_jupyter_ipython_work.html">https://jupyter.readthedocs.io/en/latest/architecture/how_jupyter_ipython_work.html</a>
</li>

<li>Context Managers<br />
<a href="http://book.pythontips.com/en/latest/context_managers.html">http://book.pythontips.com/en/latest/context_managers.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2020</small></p>
</body>
</html>

