<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>NATS Streaming Server</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>NATS Streaming Server</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V předchozí části seriálu o message brokerech jsme se seznámili s nástrojem nazvaným NATS, který lze použít ve funkci výkonného brokera zpráv. Nad tímto nástrojem je postavený takzvaný NATS Streaming Server, jehož popisem se budeme zabývat dnes.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. NATS Streaming Server</a></p>
<p><a href="#k02">2. Klasičtí message brokeři a jejich komunikační strategie</a></p>
<p><a href="#k03">*** 3. Alternativní přístup &ndash; streaming</a></p>
<p><a href="#k04">*** 4. Koncepty, na nichž je streaming založen</a></p>
<p><a href="#k05">*** 5. Nejznámější systémy podporující streaming</a></p>
<p><a href="#k06">6. Instalace systému NATS Streaming Server</a></p>
<p><a href="#k07">7. Spuštění NATS Streaming Serveru</a></p>
<p><a href="#k08">8. Instalace balíčku potřebného pro implementaci klientů</a></p>
<p><a href="#k09">9. Nejjednodušší varianta zdroje zpráv (producenta)</a></p>
<p><a href="#k10">10. Konzument zpráv</a></p>
<p><a href="#k11">*** 11. Vylepšení producenta i konzumenta zpráv &ndash; test všech chybových stavů, použití <strong>defer</strong> pro uzavírání prostředků</a></p>
<p><a href="#k12">*** 12. Přehrání všech zpráv poslaných do zvoleného tématu</a></p>
<p><a href="#k13">*** 13. Příjem zpráv od poslední přijaté zprávy</a></p>
<p><a href="#k14">*** 14. Specifikace pořadí zprávy v&nbsp;sekvenci</a></p>
<p><a href="#k15">*** 15. Specifikace časového okamžiku, od kterého se má zpráva či zprávy přijmout</a></p>
<p><a href="#k16">*** 16. Zajištění trvalého odběru zpráv zvoleným konzumentem (durable subscription)</a></p>
<p><a href="#k17">*** 17. Termíny používané v&nbsp;souvislosti s&nbsp;message brokery</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Odkazy na předchozí části seriálu o message brokerech</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. NATS Streaming Server</h2>

<p>V&nbsp;dnešním článku navážeme na téma, kterému jsme se <a
href="https://www.root.cz/clanky/pouziti-message-brokeru-nats/">věnovali
minule</a>. Připomeňme si, že jsme se zabývali popisem message brokera
nazvaného <a href="https://nats.io/">NATS</a>, který je vytvořen <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">v&nbsp;programovacím
jazyku Go</a>, takže výsledkem je server, jenž je poměrně nenáročný na
systémové zdroje (především na operační paměť a taktéž na diskový prostor),
ovšem i přesto podporuje rychlé přeposílání a popř.&nbsp;rozesílání zpráv. Ve
své základní konfiguraci se NATS používá především pro implementaci komunikační
strategie <i>publish-subscribe</i> neboli zkráceně <i>pub-sub</i>.</p>

<p>Dnes se seznámíme s&nbsp;projektem nazvaným <i>NATS Streaming Server</i>,
jehož zdrojové kódy i základní dokumentaci naleznete na adrese <a
href="https://github.com/nats-io/nats-streaming-server">https://github.com/nats-io/nats-streaming-server</a>.
Tento projekt je určen pro takzvaný <i>streaming</i> zpráv, podobně jako
známější a pravděpodobně i častěji nasazovaný projekt <i>Apache Kafka</i>, na
nějž jsme pochopitelně nezapomněli &ndash; popíšeme si ho v&nbsp;některém
dalším dílu <a href="https://www.root.cz/serialy/message-brokery/">seriálu o
message brokerech</a>.</p>

<p>NATS Streaming Server používá klasický systém (server) NATS, který navíc
doplňuje o takzvaný <i>storage</i>, tj.&nbsp;o technologii určenou pro ukládání
zpráv (někdy nazývaných i záznamy &ndash; <i>record</i>) do perzistentního
úložiště, kterým může být relační databáze či soubor (resp.&nbsp;skupina
souborů). Samotný NATS, jak již víme z&nbsp;předchozího článku, se skládá
z&nbsp;několika komponent:</p>

<ol>

<li>V&nbsp;první řadě se jedná o samotný <i>server</i>, jenž se spouští
příkazem <strong>gnatsd</strong>. Server je naprogramovaný v&nbsp;jazyce Go a
při jeho vývoji bylo dbáno na to, aby byla zaručena vysoká dostupnost celé
služby a přitom byla samotná služba s&nbsp;běžícím serverem málo náročná na
systémové zdroje, především na spotřebu operační paměti (viz úvodní
odstavec).</li>

<li>Dalším typem komponenty jsou programátorská rozhraní pro klienty, která
v&nbsp;současnosti existují pro několik ekosystémů (což je většinou kombinace
programovacího jazyka, knihoven a popř.&nbsp;jeho virtuálního stroje). Prozatím
jsme se seznámili s&nbsp;rozhraním určeným přímo pro jazyk Go.</li>

<li>Třetí komponentou je dnes popisovaný <i>NATS Streaming Server</i>, který je
opět naprogramován v&nbsp;jazyce Go. K&nbsp;tomuto serveru ještě musíme
připočítat příslušné rozhraní dodávané (v&nbsp;případě jazyka Go) ve formě
samostatného balíčku.</li>

<li>Čtvrtým typem komponenty je takzvaný <i>NATS Connector Framework</i>
zajišťující propojení systému NATS s&nbsp;dalšími technologiemi (XMPP,
logování, notifikační služby aj.). Ten je naprogramovaný v&nbsp;Javě a
v&nbsp;současnosti je podporován například konektor pro Redis (<a
href="https://github.com/nats-io/nats-connector-redis">https://github.com/nats-io/nats-connector-redis</a>).
I této zajímavé problematice bude později věnován samostatný článek.</li>

</ol>



<p><a name="k02"></a></p>
<h2 id="k02">2. Klasičtí message brokeři a jejich komunikační strategie</h2>

<p>V&nbsp;navazujících kapitolách se budeme věnovat takzvanému
<i>streamingu</i> zpráv (či záznamů), což je možné pokládat za rozšíření služeb
klasických message brokerů o možnost &bdquo;přehrání&ldquo; starších zpráv
kombinovanou s&nbsp;možností, aby tu samou zprávu zpracovávalo větší množství
konzumentů. Pro upřesnění, v&nbsp;čemž se vlastně <i>streaming</i> odlišuje od
běžných message brokerů si ještě jednou (v&nbsp;tomto seriálu naposledy :-)
zopakujme dvě komunikační strategie, které většinou nalezneme u běžných message
brokerů (<i>Redis Queue</i>, <i>RabbitMQ</i>, <i>ActiveMQ</i> atd.).</p>

<p>Většina message brokerů, s&nbsp;nimiž jsme se až doposud v&nbsp;tomto
seriálu seznámili, podporovala dvě základní komunikační strategie. První
z&nbsp;těchto strategií se nazývá <strong>publish-subscribe</strong> (neboli
zkráceně <strong>pub-sub</strong>) a spočívá v&nbsp;tom, že se zprávy
s&nbsp;nastaveným tématem (<i>topic</i>, <i>subject</i>) posílají do message
brokera, který tyto zprávy ihned přeposílá konzumentům přihlášeným
k&nbsp;danému tématu. V&nbsp;případě, že žádný takový konzument neexistuje, je
zpráva zahozena. Pokud konzumentů daného tématu naopak existuje větší množství,
je zpráva doručena všem takovým konzumentům. Samotný message broker
v&nbsp;tomto případě nepotřebuje zprávy ukládat, takže se většinou nesetkáme
ani s&nbsp;podporou pro persistenci zpráv. Příkladem takového systému je právě
NATS (bez dalších rozšíření).</p>

*** image ***
<p><i>Obrázek 1: Komunikační strategie
<strong>publish-subscribe</strong>.</i></p>

<p>Druhá komunikační strategie, která se někdy nazývá
<strong>push-pull</strong> či pouze <strong>queueing</strong>, je založena na
pojmenovaných frontách zpráv (<strong>message queue</strong>) implementovaných
v&nbsp;message brokerovi. Zpráva bývá v&nbsp;tomto případě doručena jen
jedinému konzumentovi a pokud žádný konzument není k&nbsp;frontě připojen,
zůstane zpráva ve frontě uložena (teoreticky) po libovolně dlouhou dobu.
Message broker v&nbsp;takovém případě typicky podporuje <i>perzistenci</i>
zpráv, které tak dokážou přečkat jeho případné restarty. Mnoho message brokerů
navíc umožňuje, aby konzumenti potvrzovali zpracování zprávy, popř.&nbsp;je
dokonce možné provádět transakce. K&nbsp;pojmenovaným frontám se potom
přidávají další specializované fronty na nezpracované zprávy (<i>DLQ &ndash;
Dead Letters Queue</i>.</p>

*** image ***
<p><i>Obrázek 2: Komunikační strategie <strong>push-pull</strong>.</i></p>

<p>V&nbsp;klasickým message brokerech orientovaných na komunikaci
s&nbsp;využitím zpráv je každá zpráva většinou spravována izolovaně od
ostatních zpráv. I když některé implementace message brokerů podporují
prioritní fronty, není obecně vyžadováno (a ani se to neočekává), aby se zprávy
doručovaly v&nbsp;takovém pořadí, v&nbsp;jakém je message broker přijímá (což
je u pojmenovaných front problematické). Toto chování pro mnohé účely plně
dostačuje a z&nbsp;hlediska klientů (tedy producentů zpráv i jejich konzumentů)
je použití takových message brokerů velmi jednoduché, protože si klienti
vlastně vůbec nemusí pamatovat stav zpráv (seznam zpracovaných zpráv, přijatých
ale nezpracovaných zpráv atd.).</p>

*** image ***
<p><i>Obrázek 3: Složitější komunikační strategie, které jsou některými message
brokery podporovány.</i></p>

<p>Ovšem existují problémy, které se s&nbsp;použitím klasickým message brokerů
implementují velmi složitě popř.&nbsp;je nelze (na rozumném HW) implementovat
vůbec. Příkladem může být systém pro zaznamenání událostí, ovšem v&nbsp;tom
pořadí, v&nbsp;jakém události vznikly a s&nbsp;možností zpětného přehrávání
(<i>replay</i>) zpráv/událostí. A právě pro řešení těchto problémů vznikl
<i>streaming</i> zpráv.</p>




<p><a name="k03"></a></p>
<h2 id="k03">3. Alternativní přístup &ndash; streaming</h2>

<p></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Koncepty, na nichž je streaming založen</h2>



<p><a name="k05"></a></p>
<h2 id="k05">5. Nejznámější systémy podporující streaming</h2>

<p>Mezi nejznámější a pravděpodobně nejčastěji nasazované systémy podporující streaming patří projekt <i>Apache Kafka</i> a taktéž dnes popisovaný <i>NATS Streaming Server</i>. Vzhledem k&nbsp;tomu, že <i>NATS Streaming Serverem</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Instalace systému NATS Streaming Server</h2>

<p>Nyní si ve stručnosti ukážeme, jak vlastně probíhá instalace systému NATS
Streaming Server. V&nbsp;této kapitole se předpokládá, že již máte nainstalován
NATS Server, který byl popsán v&nbsp;předchozím článku. Pokud tomu tak není,
postupujte následujícími dvěma kroky. Nejprve se přesuneme do adresáře, na
který odkazuje proměnná prostředí <strong>$GOPATH</strong>, což je typicky
adresář &bdquo;~/go&ldquo;:</p>

<pre>
$ <strong>cd $GOPATH</strong>
</pre>

<p>Dále spustíme příkaz pro nainstalování balíčku, který obsahuje server
NATSu:</p>

<pre>
$ <strong>go get github.com/nats-io/gnatsd</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti ovšem nebudeme, na rozdíl
od předchozího článku, takto nainstalovaný NATS server spouštět ručně. Tuto
činnost zajistí NATS Streaming server automaticky.</div></p>

<p>Nyní již konečně můžeme přistoupit k&nbsp;instalaci samotného  <i>NATS
Streaming Serveru</i>. Budeme postupovat podobně, jako při instalaci NATS
Serveru, tj.&nbsp;nejdříve se přesuneme do adresáře, na který odkazuje proměnná
prostředí <strong>$GOPATH</strong>:</p>

<pre>
$ <strong>cd $GOPATH</strong>
</pre>

<p>Instalace balíčku se streaming serverem:</p>

<pre>
$ <strong>go get github.com/nats-io/nats-streaming-server</strong>
</pre>

<p>Po instalaci zdrojových kódů musíme NATS Streaming Server přeložit, a to
tímto příkazem:</p>

<pre>
$ <strong>cd $GOPATH/src/github.com/nats-io/nats-streaming-server</strong>
$ <strong>go build</strong>
</pre>

<p>Po překladu by měl v&nbsp;aktuálním adresáři vzniknout soubor pojmenovaný
<strong>nats-streaming-server</strong>. Zkusíme si zobrazit jeho nápovědu:</p>

<pre>
$ <strong>./nats-streaming-server --help</strong>
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
Usage: nats-streaming-server [options]
&nbsp;
Streaming Server Options:
    -cid, --cluster_id  &lt;string&gt;         Cluster ID (default: test-cluster)
    -st,  --store &lt;string&gt;               Store type: MEMORY|FILE|SQL (default: MEMORY)
          --dir &lt;string&gt;                 For FILE store type, this is the root directory
    -mc,  --max_channels &lt;int&gt;           Max number of channels (0 for unlimited)
    -msu, --max_subs &lt;int&gt;               Max number of subscriptions per channel (0 for unlimited)
    -mm,  --max_msgs &lt;int&gt;               Max number of messages per channel (0 for unlimited)
    -mb,  --max_bytes &lt;size&gt;             Max messages total size per channel (0 for unlimited)
    -ma,  --max_age &lt;duration&gt;           Max duration a message can be stored ("0s" for unlimited)
    -mi,  --max_inactivity &lt;duration&gt;    Max inactivity (no new message, no subscription) after which a channel can be garbage collected (0 for unlimited)
    -ns,  --nats_server &lt;string&gt;         Connect to this external NATS Server URL (embedded otherwise)
    -sc,  --stan_config &lt;string&gt;         Streaming server configuration file
    -hbi, --hb_interval &lt;duration&gt;       Interval at which server sends heartbeat to a client
    -hbt, --hb_timeout &lt;duration&gt;        How long server waits for a heartbeat response
    -hbf, --hb_fail_count &lt;int&gt;          Number of failed heartbeats before server closes the client connection
          --ft_group &lt;string&gt;            Name of the FT Group. A group can be 2 or more servers with a single active server and all sharing the same datastore
    -sl,  --signal &lt;signal&gt;[=&lt;pid&gt;]      Send signal to nats-streaming-server process (stop, quit, reopen)
          --encrypt &lt;bool&gt;               Specify if server should use encryption at rest
          --encryption_cipher &lt;string&gt;   Cipher to use for encryption. Currently support AES and CHAHA (ChaChaPoly). Defaults to AES
          --encryption_key &lt;sting&gt;       Encryption Key. It is recommended to specify it through the NATS_STREAMING_ENCRYPTION_KEY environment variable instead
    
Streaming Server Clustering Options:
    --clustered &lt;bool&gt;                   Run the server in a clustered configuration (default: false)
    --cluster_node_id &lt;string&gt;           ID of the node within the cluster if there is no stored ID (default: random UUID)
    --cluster_bootstrap &lt;bool&gt;           Bootstrap the cluster if there is no existing state by electing self as leader (default: false)
    --cluster_peers &lt;string, ...&gt;        Comma separated list of cluster peer node IDs to bootstrap cluster state
    --cluster_log_path &lt;string&gt;          Directory to store log replication data
    --cluster_log_cache_size &lt;int&gt;       Number of log entries to cache in memory to reduce disk IO (default: 512)
    --cluster_log_snapshots &lt;int&gt;        Number of log snapshots to retain (default: 2)
    --cluster_trailing_logs &lt;int&gt;        Number of log entries to leave after a snapshot and compaction
    --cluster_sync &lt;bool&gt;                Do a file sync after every write to the replication log and message store
    --cluster_raft_logging &lt;bool&gt;        Enable logging from the Raft library (disabled by default)
&nbsp;
Streaming Server File Store Options:
    --file_compact_enabled &lt;bool&gt;        Enable file compaction
    --file_compact_frag &lt;int&gt;            File fragmentation threshold for compaction
    --file_compact_interval &lt;int&gt;        Minimum interval (in seconds) between file compactions
    --file_compact_min_size &lt;size&gt;       Minimum file size for compaction
    --file_buffer_size &lt;size&gt;            File buffer size (in bytes)
    --file_crc &lt;bool&gt;                    Enable file CRC-32 checksum
    --file_crc_poly &lt;int&gt;                Polynomial used to make the table used for CRC-32 checksum
    --file_sync &lt;bool&gt;                   Enable File.Sync on Flush
    --file_slice_max_msgs &lt;int&gt;          Maximum number of messages per file slice (subject to channel limits)
    --file_slice_max_bytes &lt;size&gt;        Maximum file slice size - including index file (subject to channel limits)
    --file_slice_max_age &lt;duration&gt;      Maximum file slice duration starting when the first message is stored (subject to channel limits)
    --file_slice_archive_script &lt;string&gt; Path to script to use if you want to archive a file slice being removed
    --file_fds_limit &lt;int&gt;               Store will try to use no more file descriptors than this given limit
    --file_parallel_recovery &lt;int&gt;       On startup, number of channels that can be recovered in parallel
    --file_truncate_bad_eof &lt;bool&gt;       Truncate files for which there is an unexpected EOF on recovery, dataloss may occur
&nbsp;
Streaming Server SQL Store Options:
    --sql_driver &lt;string&gt;            Name of the SQL Driver ("mysql" or "postgres")
    --sql_source &lt;string&gt;            Datasource used when opening an SQL connection to the database
    --sql_no_caching &lt;bool&gt;          Enable/Disable caching for improved performance
    --sql_max_open_conns &lt;int&gt;       Maximum number of opened connections to the database
&nbsp;
Streaming Server TLS Options:
    -secure &lt;bool&gt;                   Use a TLS connection to the NATS server without
                                     verification; weaker than specifying certificates.
    -tls_client_key &lt;string&gt;         Client key for the streaming server
    -tls_client_cert &lt;string&gt;        Client certificate for the streaming server
    -tls_client_cacert &lt;string&gt;      Client certificate CA for the streaming server
&nbsp;
Streaming Server Logging Options:
    -SD, --stan_debug=&lt;bool&gt;         Enable STAN debugging output
    -SV, --stan_trace=&lt;bool&gt;         Trace the raw STAN protocol
    -SDV                             Debug and trace STAN
         --syslog_name               On Windows, when running several servers as a service, use this name for the event source
    (See additional NATS logging options below)
&nbsp;
Embedded NATS Server Options:
    -a, --addr &lt;string&gt;              Bind to host address (default: 0.0.0.0)
    -p, --port &lt;int&gt;                 Use port for clients (default: 4222)
    -P, --pid &lt;string&gt;               File to store PID
    -m, --http_port &lt;int&gt;            Use port for http monitoring
    -ms,--https_port &lt;int&gt;           Use port for https monitoring
    -c, --config &lt;string&gt;            Configuration file
&nbsp;
Logging Options:
    -l, --log &lt;string&gt;               File to redirect log output
    -T, --logtime=&lt;bool&gt;             Timestamp log entries (default: true)
    -s, --syslog &lt;string&gt;            Enable syslog as log method
    -r, --remote_syslog &lt;string&gt;     Syslog server addr (udp://localhost:514)
    -D, --debug=&lt;bool&gt;               Enable debugging output
    -V, --trace=&lt;bool&gt;               Trace the raw protocol
    -DV                              Debug and trace
&nbsp;
Authorization Options:
        --user &lt;string&gt;              User required for connections
        --pass &lt;string&gt;              Password required for connections
        --auth &lt;string&gt;              Authorization token required for connections
&nbsp;
TLS Options:
        --tls=&lt;bool&gt;                 Enable TLS, do not verify clients (default: false)
        --tlscert &lt;string&gt;           Server certificate file
        --tlskey &lt;string&gt;            Private key for server certificate
        --tlsverify=&lt;bool&gt;           Enable TLS, verify client certificates
        --tlscacert &lt;string&gt;         Client certificate CA for verification
&nbsp;
NATS Clustering Options:
        --routes &lt;string, ...&gt;       Routes to solicit and connect
        --cluster &lt;string&gt;           Cluster URL for solicited routes
&nbsp;
Common Options:
    -h, --help                       Show this message
    -v, --version                    Show version
        --help_tls                   TLS help.
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Spuštění NATS Streaming Serveru</h2>

<p>V&nbsp;případě, že se nápověda skutečně zobrazila, můžeme se pokusit spustit
NATS Streaming Server s&nbsp;výchozí konfigurací. Každé (další) spuštění
serveru by mělo vypadat následovně:</p>

<pre>
$ <strong>cd $GOPATH/src/github.com/nats-io/nats-streaming-server</strong>
&nbsp;
$ <strong>./nats-streaming-server</strong>
</pre>

<p>Na terminálu by se měly zobrazit přibližně následující informace,
z&nbsp;nichž některé budou velmi důležité pro naše další pokusy:</p>

<pre>
[3568] 2019/04/05 17:50:18.681037 [INF] STREAM: Starting nats-streaming-server[<strong>test-cluster</strong>] version 0.12.2
[3568] 2019/04/05 17:50:18.681156 [INF] STREAM: ServerID: fxLHdxa4OjkdnXtNZaYHSC
[3568] 2019/04/05 17:50:18.681178 [INF] STREAM: Go version: go1.11.2
[3568] 2019/04/05 17:50:18.681621 [INF] STREAM: Git commit: [not set]
[3568] 2019/04/05 17:50:18.683122 [INF] Starting nats-server version 1.4.1
[3568] 2019/04/05 17:50:18.683172 [INF] Git commit [not set]
[3568] 2019/04/05 17:50:18.683422 [INF] Listening for client connections on <a href="">0.0.0.0:4222</a>
[3568] 2019/04/05 17:50:18.683447 [INF] Server is ready
[3568] 2019/04/05 17:50:18.712436 [INF] STREAM: Recovering the state...
[3568] 2019/04/05 17:50:18.712549 [INF] STREAM: No recovered state
[3568] 2019/04/05 17:50:18.963128 [INF] STREAM: Message store is <strong>MEMORY</strong>
[3568] 2019/04/05 17:50:18.963226 [INF] STREAM: ---------- Store Limits ----------
[3568] 2019/04/05 17:50:18.963255 [INF] STREAM: Channels:                  100 *
[3568] 2019/04/05 17:50:18.963271 [INF] STREAM: --------- Channels Limits --------
[3568] 2019/04/05 17:50:18.963291 [INF] STREAM:   Subscriptions:          1000 *
[3568] 2019/04/05 17:50:18.963307 [INF] STREAM:   Messages     :       1000000 *
[3568] 2019/04/05 17:50:18.963323 [INF] STREAM:   Bytes        :     976.56 MB *
[3568] 2019/04/05 17:50:18.963339 [INF] STREAM:   Age          :     <strong>unlimited</strong> *
[3568] 2019/04/05 17:50:18.963360 [INF] STREAM:   Inactivity   :     unlimited *
[3568] 2019/04/05 17:50:18.963375 [INF] STREAM: ----------------------------------
</pre>

<p>Za povšimnutí stojí především čtyři zvýrazněné informace:</p>

<ol>

<li>Důležité je především jméno clusteru, v&nbsp;rámci něhož server běží. Jedná
se o důležitou informaci z&nbsp;toho důvodu, že jméno clusteru budeme
potřebovat při připojování klientů.</li>

<li>Dále si povšimněte portu, na který se budou připojovat klienti. Pokud se
výchozí hodnota portu nezmění, nemusíme ji explicitně v&nbsp;klientech
specifikovat.</li>

<li>Pravděpodobně nejdůležitější je informace o tom, že zprávy jsou drženy
pouze v&nbsp;operační paměti a nejsou meziukládány na disk. Toto nastavení je
možné změnit a využít pro ukládání zpráv například relační databáze či přímo
souborový systém. Výchozí hodnota <strong>MEMORY</strong> znamená, že po
restartu serveru budou zprávy ztraceny.</li>

<li>Hodnota <strong>unlimited</strong> vlastnosti <strong>Age</strong> říká, že
předem neomezujeme maximální životnost zpráv, což v&nbsp;praxi znamená, že
pokud bude zpráv méně než jeden milion (informace o dva řádky výše) a
nepřesáhne se maximální kapacita kanálu, nebudou zprávy smazány.</li>

</ol>

<p>Server nechte spuštěný v&nbsp;samostatném terminálu, protože se ještě
vrátíme k&nbsp;dalším zprávám, které budou na tento terminál zapsány po
připojení prvního producenta zpráv.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Instalace balíčku potřebného pro implementaci klientů</h2>

<p>Kromě běžícího serveru pro streaming zpráv budeme při tvorbě demonstračních
příkladů potřebovat ještě jeden balíček, který se jmenuje
<strong>go-nats-streaming</strong>. Tento balíček zajišťuje rozhraní mezi
klienty a NATS Streaming Serverem. Nainstalujeme ho naprosto stejným způsobem,
jako jakýkoli jiný balíček určený pro programovací jazyk Go:</p>

<pre>
$ <strong>cd $GOPATH</strong>
&nbsp;
$ <strong>go get github.com/nats-io/go-nats-streaming</strong>
</pre>

<p>Import tohoto balíčku v&nbsp;demonstračních klientech bude vypadat
takto:</p>

<pre>
import streaming "github.com/nats-io/go-nats-streaming"
</pre>

<p><div class="rs-tip-major">Poznámka: z&nbsp;pohledu jazyka Go se tento
balíček jmenuje <strong>stan</strong> (nezáleží totiž na jménu adresáře, ale
identifikátoru za <strong>package</strong>), my ovšem použijeme jmenný alias
<strong>streaming</strong>.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Nejjednodušší varianta zdroje zpráv (producenta)</h2>

<p>Nejprve si ukážeme, jakým způsobem je možné vytvořit producenta zpráv. Ten
se svou činností vlastně vůbec neodlišuje od producentů zpráv posílaných do
běžných message brokerů &ndash; samotná zpráva musí mít pouze nastaveno téma
(<i>topic</i>) a na tělo zprávy nejsou kladena žádná omezení, protože se jedná
o sekvenci bajtů.</p>

<p>V&nbsp;tom nejjednodušším případě se pouze připojíme k&nbsp;zadanému
clusteru (viz též <a href="#k07">sedmou kapitolu</a>, kde jsme si ukázali, kde
jméno clusteru hledat) a specifikujeme jméno klienta, které by ideálně mělo být
jednoznačné:</p>

<pre>
stream, _ := streaming.Connect(clusterId, clientId)
</pre>

<p>Zpráva s&nbsp;libovolným obsahem (sekvencí bajtů) se publikuje metodou
<strong>Publish</strong>:</p>

<pre>
stream.Publish(topic, []byte("Hello World"))
</pre>

<p>Nakonec nesmíme zapomenout uzavřít připojení k&nbsp;serveru:</p>

<pre>
stream.Close()
</pre>

<p>Úplný zdrojový kód producenta zprávy naleznete na adrese <a
href="https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/01-simple-pub-sub/publisher.go">https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/01-simple-pub-sub/publisher.go</a>:</p>

<pre>
package main
&nbsp;
import streaming "github.com/nats-io/go-nats-streaming"
&nbsp;
const clusterId = "test-cluster"
const clientId = "publisher1"
const topic = "topic1"
&nbsp;
func <strong>main</strong>() {
        stream, _ := streaming.Connect(clusterId, clientId)
&nbsp;
        stream.Publish(topic, []byte("Hello World"))
&nbsp;
        stream.Close()
}
</pre>

<p>Pokud klienta přeložíte a spustíte, můžete si v&nbsp;terminálu, kde běží
NATS Streaming Server povšimnout nové zprávy:</p>

<pre>
[3568] 2019/04/05 17:50:42.121546 [INF] STREAM: Channel "<strong>topic1</strong>" has been created
</pre>

<p>Vidíme, že server správně poznal, že poslaná zpráva obsahuje prozatím
neexistující téma, pro které byl ihned vytvořen takzvaný <i>kanál</i>.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Konzument zpráv</h2>

<p>Jak je to u systémů, v&nbsp;nichž se posílají zprávy, běžné, je implementace
konzumenta zpráv nepatrně složitější, než u jejich producenta. Je tomu tak
proto, že konzument dopředu neví, kolik zpráv získá a musí na ně čekat &ndash;
buď v&nbsp;explicitně zapsané smyčce (což nebude náš případ), nebo
s&nbsp;využitím nějaké formy smyčky událostí.</p>

<p>Připojení k&nbsp;serveru se provádí stejným způsobem, jako u producenta.
V&nbsp;nejjednodušším případě nám postačuje znát jméno clusteru a zadat
libovolné jméno klienta:</p>

<pre>
stream, _ := streaming.Connect(clusterId, clientId)
</pre>

<p>K&nbsp;odběru zpráv je nutné se přihlásit metodou
<strong>Subscribe</strong>, které se předá téma, které konzumenta zajímá a
taktéž reference na callback funkci zavolanou ve chvíli, kdy bude zpráva
přijata:</p>

<pre>
sub, _ := stream.Subscribe(topic, onReceive)
</pre>

<p>Samotná callback funkce je po příjmu zprávy zavolána s&nbsp;jediným
parametrem, jímž je samotná zpráva:</p>

<pre>
func <strong>onReceive</strong>(m *streaming.Msg) {
        println("Received message: ", string(m.Data))
}
</pre>

<p>Na konci se odhlásíme od odběru zpráv a uzavřeme připojení
k&nbsp;serveru:</p>

<pre>
sub.Unsubscribe()
&nbsp;
stream.Close()
</pre>

<p>Problém ovšem spočívá v&nbsp;tom, že samotné čekání na zprávy je prováděno
asynchronně k&nbsp;běhu gorutiny s&nbsp;funkcí <strong>main</strong>. Proto
musíme zajistit, aby funkce <strong>main</strong> nebyla ihned ukončena.
K&nbsp;tomu může posloužit známý trik s&nbsp;kanálem, z&nbsp;něhož budeme číst
hodnotu, kterou ovšem ve skutečnosti nikdo nepošle:</p>

<pre>
c := make(chan bool)
&nbsp;
sub, _ := stream.Subscribe(topic, onReceive)
&nbsp;
&lt;-c
</pre>

<p>Opět se podívejme na úplný zdrojový kód konzumenta zpráv, který nalezneme na
adrese <a
href="https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/01-simple-pub-sub/consumer.go">https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/01-simple-pub-sub/consumer.go</a>:</p>

<pre>
package main
&nbsp;
import streaming "github.com/nats-io/go-nats-streaming"
&nbsp;
const clusterId = "test-cluster"
const clientId = "consumer1"
const topic = "topic1"
&nbsp;
func <strong>onReceive</strong>(m *streaming.Msg) {
        println("Received message: ", string(m.Data))
}
&nbsp;
func <strong>main</strong>() {
        stream, _ := streaming.Connect(clusterId, clientId)
&nbsp;
        c := make(chan bool)
&nbsp;
        sub, _ := stream.Subscribe(topic, onReceive)
&nbsp;
        &lt;-c
&nbsp;
        sub.Unsubscribe()
&nbsp;
        stream.Close()
}
</pre>

<pre>
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Vylepšení producenta i konzumenta zpráv &ndash; test všech chybových stavů, použití <strong>defer</strong> pro uzavírání prostředků</h2>

https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/02-pub-sub-error-handling/publisher.go

<pre>
package main
&nbsp;
import (
        streaming "github.com/nats-io/go-nats-streaming"
        "log"
)
&nbsp;
const clusterId = "test-cluster"
const clientId = "publisher1"
const topic = "topic1"
&nbsp;
func <strong>main</strong>() {
        stream, err := streaming.Connect(clusterId, clientId)
        if err != nil {
                log.Fatalf("Can not connect to cluster %s\n", clusterId)
        }
        defer stream.Close()
&nbsp;
        err = stream.Publish(topic, []byte("Hello World"))
        if err != nil {
                log.Fatalf("Error during publish: %v\n", err)
        } else {
                log.Println("Message published")
        }
}
</pre>

https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/02-pub-sub-error-handling/consumer.go

<pre>
package main
&nbsp;
import (
        streaming "github.com/nats-io/go-nats-streaming"
        "log"
)
&nbsp;
const clusterId = "test-cluster"
const clientId = "consumer1"
const topic = "topic1"
&nbsp;
func <strong>onReceive</strong>(m *streaming.Msg) {
        println("Received message: ", string(m.Data))
}
&nbsp;
func <strong>main</strong>() {
        stream, err := streaming.Connect(clusterId, clientId)
        if err != nil {
                log.Fatalf("Can not connect to cluster %s\n", clusterId)
        }
        defer stream.Close()
&nbsp;
        c := make(chan bool)
&nbsp;
        sub, err := stream.Subscribe(topic, onReceive)
        if err != nil {
                log.Fatalf("Can not subscribe to topic %s\n", topic)
        }
        defer sub.Unsubscribe()
&nbsp;
        &lt;-c
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Přehrání všech zpráv poslaných do zvoleného tématu</h2>

https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/03-replay-all/publisher.go

<pre>
package main
&nbsp;
import (
        "fmt"
        streaming "github.com/nats-io/go-nats-streaming"
        "log"
)
&nbsp;
const clusterId = "test-cluster"
const clientId = "publisher1"
const topic = "topic1"
&nbsp;
func <strong>main</strong>() {
        stream, err := streaming.Connect(clusterId, clientId)
        if err != nil {
                log.Fatalf("Can not connect to cluster %s\n", clusterId)
        }
        defer stream.Close()
&nbsp;
        for i := 1; i &lt;= 10; i++ {
                message := fmt.Sprintf("Hello World #%d", i)
                err = stream.Publish(topic, []byte(message))
                if err != nil {
                        log.Fatalf("Error during publish: %v\n", err)
                } else {
                        log.Println("Message published: %s", message)
                }
        }
}
</pre>

https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/03-replay-all/consumer.go

<pre>
package main
&nbsp;
import (
        streaming "github.com/nats-io/go-nats-streaming"
        "log"
)
&nbsp;
const clusterId = "test-cluster"
const clientId = "consumer1"
const topic = "topic1"
&nbsp;
func <strong>onReceive</strong>(m *streaming.Msg) {
        println("Received message: ", string(m.Data))
}
&nbsp;
func <strong>main</strong>() {
        stream, err := streaming.Connect(clusterId, clientId)
        if err != nil {
                log.Fatalf("Can not connect to cluster %s\n", clusterId)
        }
        defer stream.Close()
&nbsp;
        c := make(chan bool)
&nbsp;
        startOpt := streaming.DeliverAllAvailable()
        sub, err := stream.Subscribe(topic, onReceive, startOpt)
        if err != nil {
                log.Fatalf("Can not subscribe to topic %s\n", topic)
        }
        defer sub.Unsubscribe()
&nbsp;
        &lt;-c
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Příjem zpráv od poslední přijaté zprávy</h2>

https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/04-replay-from-last-received/publisher.go

https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/04-replay-from-last-received/consumer.go

<pre>
package main
&nbsp;
import (
        streaming "github.com/nats-io/go-nats-streaming"
        "log"
)
&nbsp;
const clusterId = "test-cluster"
const clientId = "consumer1"
const topic = "topic1"
&nbsp;
func <strong>onReceive</strong>(m *streaming.Msg) {
        println("Received message: ", string(m.Data))
}
&nbsp;
func <strong>main</strong>() {
        stream, err := streaming.Connect(clusterId, clientId)
        if err != nil {
                log.Fatalf("Can not connect to cluster %s\n", clusterId)
        }
        defer stream.Close()
&nbsp;
        c := make(chan bool)
&nbsp;
        // jeste jednou ziska posledni zpravu zpracovanou minule
        startOpt := streaming.StartWithLastReceived()
        sub, err := stream.Subscribe(topic, onReceive, startOpt)
        if err != nil {
                log.Fatalf("Can not subscribe to topic %s\n", topic)
        }
        defer sub.Unsubscribe()
&nbsp;
        &lt;-c
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Specifikace pořadí zprávy v&nbsp;sekvenci</h2>

https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/05-start-at-sequence/consumer.go

<pre>
package main
&nbsp;
import (
        streaming "github.com/nats-io/go-nats-streaming"
        "log"
)
&nbsp;
const clusterId = "test-cluster"
const clientId = "consumer1"
const topic = "topic1"
&nbsp;
func <strong>onReceive</strong>(m *streaming.Msg) {
        println("Received message: ", string(m.Data))
}
&nbsp;
func <strong>main</strong>() {
        stream, err := streaming.Connect(clusterId, clientId)
        if err != nil {
                log.Fatalf("Can not connect to cluster %s\n", clusterId)
        }
        defer stream.Close()
&nbsp;
        c := make(chan bool)
&nbsp;
        startOpt := streaming.StartAtSequence(40)
        sub, err := stream.Subscribe(topic, onReceive, startOpt)
        if err != nil {
                log.Fatalf("Can not subscribe to topic %s\n", topic)
        }
        defer sub.Unsubscribe()
&nbsp;
        &lt;-c
}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Specifikace časového okamžiku, od kterého se má zpráva či zprávy přijmout</h2>

https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/06-time-duration/consumer.go

<pre>
package main
&nbsp;
import (
        streaming "github.com/nats-io/go-nats-streaming"
        "log"
        "os"
        "time"
)
&nbsp;
const clusterId = "test-cluster"
const clientId = "consumer1"
const topic = "topic1"
&nbsp;
func <strong>onReceive</strong>(m *streaming.Msg) {
        println("Received message: ", string(m.Data))
}
&nbsp;
func <strong>main</strong>() {
        stream, err := streaming.Connect(clusterId, clientId)
        if err != nil {
                log.Fatalf("Can not connect to cluster %s\n", clusterId)
        }
        defer stream.Close()
&nbsp;
        c := make(chan bool)
&nbsp;
        ago := "5m"
        timeDelta, err := time.ParseDuration(ago)
        if err != nil {
                log.Fatalf("Unable to parse duration '%s'", ago)
                os.Exit(-1)
        }
        println("About to receive all messages newer than", timeDelta)
&nbsp;
        startOpt := streaming.StartAtTimeDelta(timeDelta)
        sub, err := stream.Subscribe(topic, onReceive, startOpt)
        if err != nil {
                log.Fatalf("Can not subscribe to topic %s\n", topic)
        }
        defer sub.Unsubscribe()
&nbsp;
        &lt;-c
}
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Zajištění trvalého odběru zpráv zvoleným konzumentem (durable subscription)</h2>

https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/07-durable-subscription/consumer.go

<pre>
package main
&nbsp;
import (
        streaming "github.com/nats-io/go-nats-streaming"
        "log"
)
&nbsp;
const clusterId = "test-cluster"
const clientId = "consumer1"
const topic = "topic1"
const durableName = "durableXYZZY"
&nbsp;
func <strong>onReceive</strong>(m *streaming.Msg) {
        println("Received message: ", string(m.Data))
}
&nbsp;
func <strong>main</strong>() {
        stream, err := streaming.Connect(clusterId, clientId)
        if err != nil {
                log.Fatalf("Can not connect to cluster %s\n", clusterId)
        }
        defer stream.Close()
&nbsp;
        c := make(chan bool)
&nbsp;
        startOpt := streaming.DurableName(durableName)
&nbsp;
        sub, err := stream.Subscribe(topic, onReceive, startOpt)
        if err != nil {
                log.Fatalf("Can not subscribe to topic %s\n", topic)
        }
        defer sub.Unsubscribe()
&nbsp;
        &lt;-c
}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Termíny používané v&nbsp;souvislosti s&nbsp;message brokery</h2>

<p>V&nbsp;této kapitole jsou zmíněny významy některých termínů, s&nbsp;nimiž se
v&nbsp;souvislosti s&nbsp;message brokery a se streamingem často setkáme. České
překlady jsou ovšem pouze přibližné, protože oficiální terminologie
pravděpodobně ještě neexistuje:</p>

<table>
<tr><th>#</th><th>Původní termín</th><th>Přibližný český překlad</th><th>Stručný popis významu termínu</th></tr>
<tr><td>1</td><td>message</td><td>zpráva</td><td>ucelená informace či data posílané mezi producentem a konzumentem přes message brokera popř.&nbsp;větší množství message brokerů</td></tr>
<tr><td>2</td><td>record</td><td>záznam</td><td>alternativní pojmenování pro zprávu, používané především v&nbsp;některých streamovacích message brokerech</td></tr>
<tr><td>3</td><td>producer</td><td>producent</td><td>aplikace/proces, která vytváří zprávy a posílá je do message brokera</td></tr>
<tr><td>4</td><td>consumer</td><td>konzument</td><td>aplikace/proces, která zprávy z&nbsp;message brokera přijímá</td></tr>
<tr><td>5</td><td></td><td></td><td></td></tr>
<tr><td>6</td><td></td><td></td><td></td></tr>
<tr><td>7</td><td></td><td></td><td></td></tr>
<tr><td>8</td><td></td><td></td><td></td></tr>
</table>
consumer group - skupina konzumentů přijímajících zprávy z jednoho společného tématu
téma topic/subject - kategorie či značka, pod kterou je zpráva v brokeru uložena a publikována
topic partition - rozdělení tématu na oddíly, které mohou být rozmístěny na různé brokery v clusteru
replica - záložní kopie oddílu, typicky uložená na jiném brokeru
offset - unikátní identifikátor platný v rámci oddílu, který umožňuje konzumentům specifikovat, kterou zprávu mají zpracovávat



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů naprogramovaných
v&nbsp;programovacím jazyku Go byly uloženy do Git repositáře, který je
dostupný na adrese <a
href="https://github.com/tisnik/message-queues-examples">https://github.com/tisnik/message-queues-examples</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
doslova několik kilobajtů), můžete namísto toho použít odkazy na jednotlivé
příklady, které naleznete v&nbsp;následující tabulce. Každý příklad se skládá
ze dvou samostatně překládaných a spouštěných souborů &ndash; producenta zpráv
a konzumenta zpráv:</p>

<table>
<tr><th>Příklad</th><th>Skript/kód</th><th>Popis</th><th>Cesta</th></tr>
<tr><td>1</td><td>publisher.go</td><td>základní varianta producenta zpráv bez kontroly chyb</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/01-simple-pub-sub/publisher.go">https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/01-simple-pub-sub/publisher.go</a></td></tr>
<tr><td>1</td><td>consumer.go</td><td>základní varianta konzumenta zpráv bez kontroly chyb</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/01-simple-pub-sub/consumer.go">https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/01-simple-pub-sub/consumer.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>2</td><td>publisher.go</td><td>vylepšená verze producenta zpráv s&nbsp;kontrolami a uzavíráním připojení</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/02-pub-sub-error-handling/publisher.go">https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/02-pub-sub-error-handling/publisher.go</a></td></tr>
<tr><td>2</td><td>consumer.go</td><td>vylepšená verze konzumenta zpráv s&nbsp;kontrolami a uzavíráním připojení</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/02-pub-sub-error-handling/consumer.go">https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/02-pub-sub-error-handling/consumer.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>publisher.go</td><td>producent deseti zpráv do zvoleného tématu</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/03-replay-all/publisher.go">https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/03-replay-all/publisher.go</a></td></tr>
<tr><td>3</td><td>consumer.go</td><td>konzument přijímající (a přehrávající) všechny zprávy ze zvoleného tématu</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/03-replay-all/consumer.go">https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/03-replay-all/consumer.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td>publisher.go</td><td>producent deseti zpráv do zvoleného tématu (shodný s&nbsp;předchozím příkladem)</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/04-replay-from-last-received/publisher.go">https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/04-replay-from-last-received/publisher.go</a></td></tr>
<tr><td>4</td><td>consumer.go</td><td>konzument přijímající zprávy od poslední přijaté zprávy</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/04-replay-from-last-received/consumer.go">https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/04-replay-from-last-received/consumer.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>publisher.go</td><td>producent deseti zpráv do zvoleného tématu (shodný s&nbsp;předchozím příkladem)</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/05-start-at-sequence/publisher.go">https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/05-start-at-sequence/publisher.go</a></td></tr>
<tr><td>5</td><td>consumer.go</td><td>konzument, v&nbsp;němž je možné specifikovat pořadí zprávy v&nbsp;sekvenci</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/05-start-at-sequence/consumer.go">https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/05-start-at-sequence/consumer.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>6</td><td>publisher.go</td><td>producent deseti zpráv do zvoleného tématu (shodný s&nbsp;předchozím příkladem)</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/06-time-duration/publisher.go">https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/06-time-duration/publisher.go</a></td></tr>
<tr><td>6</td><td>consumer.go</td><td>konzument, v&nbsp;němž se specifikuje časový okamžik, od kterého se má zpráva či zprávy přijmout</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/06-time-duration/consumer.go">https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/06-time-duration/consumer.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>publisher.go</td><td>producent deseti zpráv do zvoleného tématu (opět shodný s&nbsp;předchozím příkladem)</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/07-durable-subscription/publisher.go">https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/07-durable-subscription/publisher.go</a></td></tr>
<tr><td>7</td><td>consumer.go</td><td>konzument využívající tzv.&nbsp;durable subscription popsanou v&nbsp;šestnácté kapitole</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/07-durable-subscription/consumer.go">https://github.com/tisnik/message-queues-examples/blob/master/go-nats-streaming/07-durable-subscription/consumer.go</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na předchozí části seriálu o message brokerech</h2>

<p>V&nbsp;této kapitole jsou uvedeny odkazy na všech třináct předchozích <a
href="https://www.root.cz/serialy/message-brokery/">částí seriálu</a>,
v&nbsp;němž se zabýváme různými způsoby implementace front zpráv a k&nbsp;nim
přidružených technologií message brokerů:</p>

<ol>

<li>Použití nástroje RQ (Redis Queue) pro správu úloh zpracovávaných na pozadí<br />
<a href="https://www.root.cz/clanky/pouziti-nastroje-rq-redis-queue-pro-spravu-uloh-zpracovavanych-na-pozadi/">https://www.root.cz/clanky/pouziti-nastroje-rq-redis-queue-pro-spravu-uloh-zpracovavanych-na-pozadi/</a>
</li>

<li>Celery: systém implementující asynchronní fronty úloh pro Python<br />
<a href="https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python/">https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python/</a>
</li>

<li>Celery: systém implementující asynchronní fronty úloh pro Python (dokončení)<br />
<a href="https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python-dokonceni/">https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python-dokonceni/</a>
</li>

<li>RabbitMQ: jedna z nejúspěšnějších implementací brokera<br />
<a href="https://www.root.cz/clanky/rabbitmq-jedna-z-nejuspesnejsich-implementaci-brokera/">https://www.root.cz/clanky/rabbitmq-jedna-z-nejuspesnejsich-implementaci-brokera/</a>
</li>

<li>Pokročilejší operace nabízené systémem RabbitMQ<br />
<a href="https://www.root.cz/clanky/pokrocilejsi-operace-nabizene-systemem-rabbitmq/">https://www.root.cz/clanky/pokrocilejsi-operace-nabizene-systemem-rabbitmq/</a>
</li>

<li>ØMQ: knihovna pro asynchronní předávání zpráv<br />
<a href="https://www.root.cz/clanky/0mq-knihovna-pro-asynchronni-predavani-zprav/">https://www.root.cz/clanky/0mq-knihovna-pro-asynchronni-predavani-zprav/</a>
</li>

<li>Další možnosti poskytované knihovnou ØMQ<br />
<a href="https://www.root.cz/clanky/dalsi-moznosti-poskytovane-knihovnou-mq/">https://www.root.cz/clanky/dalsi-moznosti-poskytovane-knihovnou-mq/</a>
</li>

<li>Další možnosti nabízené knihovnou ØMQ, implementace protokolů ØMQ v čisté Javě<br />
<a href="https://www.root.cz/clanky/dalsi-moznosti-nabizene-knihovnou-mq-implementace-protokolu-mq-v-ciste-jave/">https://www.root.cz/clanky/dalsi-moznosti-nabizene-knihovnou-mq-implementace-protokolu-mq-v-ciste-jave/</a>
</li>

<li>Apache ActiveMQ – další systém implementující message brokera<br />
<a href="https://www.root.cz/clanky/apache-activemq-dalsi-system-implementujici-message-brokera/">https://www.root.cz/clanky/apache-activemq-dalsi-system-implementujici-message-brokera/</a>
</li>

<li>Použití Apache ActiveMQ s protokolem STOMP<br />
<a href="https://www.root.cz/clanky/pouziti-apache-activemq-s-protokolem-stomp/">https://www.root.cz/clanky/pouziti-apache-activemq-s-protokolem-stomp/</a>
</li>

<li>Použití Apache ActiveMQ s protokolem AMQP, jazyk Go a message brokeři<br />
<a href="https://www.root.cz/clanky/pouziti-apache-activemq-s-protokolem-amqp-jazyk-go-a-message-brokeri/">https://www.root.cz/clanky/pouziti-apache-activemq-s-protokolem-amqp-jazyk-go-a-message-brokeri/</a>
</li>

<li>Komunikace s&nbsp;message brokery z&nbsp;programovacího jazyka Go<br />
<a href="https://www.root.cz/clanky/komunikace-s-message-brokery-z-programovaciho-jazyka-go/">https://www.root.cz/clanky/komunikace-s-message-brokery-z-programovaciho-jazyka-go/</a>
</li>

<li>Použití message brokeru NATS<br />
<a href="https://www.root.cz/clanky/pouziti-message-brokeru-nats/">https://www.root.cz/clanky/pouziti-message-brokeru-nats/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>NATS<br />
<a href="https://nats.io/about/">https://nats.io/about/</a>
</li>

<li>NATS Streaming Concepts<br />
<a href="https://nats.io/documentation/streaming/nats-streaming-intro/">https://nats.io/documentation/streaming/nats-streaming-intro/</a>
</li>

<li>NATS Streaming Server<br />
<a href="https://nats.io/download/nats-io/nats-streaming-server/">https://nats.io/download/nats-io/nats-streaming-server/</a>
</li>

<li>NATS Introduction<br />
<a href="https://nats.io/documentation/">https://nats.io/documentation/</a>
</li>

<li>NATS Client Protocol<br />
<a href="https://nats.io/documentation/internals/nats-protocol/">https://nats.io/documentation/internals/nats-protocol/</a>
</li>

<li>NATS Messaging (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/NATS_Messaging">https://en.wikipedia.org/wiki/NATS_Messaging</a>
</li>

<li>Stránka Apache Software Foundation<br />
<a href="http://www.apache.org/">http://www.apache.org/</a>
</li>

<li>Informace o portu 5672<br />
<a href="http://www.tcp-udp-ports.com/port-5672.htm">http://www.tcp-udp-ports.com/port-5672.htm</a>
</li>

<li>Třída MessagingHandler knihovny Qpid Proton<br />
<a href="https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._handlers.MessagingHandler-class.html">https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._handlers.MessagingHandler-class.html</a>
</li>

<li>Třída Event knihovny Qpid Proton<br />
<a href="https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._events.Event-class.html">https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._events.Event-class.html</a>
</li>

<li>package stomp (Go)<br />
<a href="https://godoc.org/github.com/go-stomp/stomp">https://godoc.org/github.com/go-stomp/stomp</a>
</li>

<li>Go language library for STOMP protocol<br />
<a href="https://github.com/go-stomp/stomp">https://github.com/go-stomp/stomp</a>
</li>

<li>python-qpid-proton 0.26.0 na PyPi<br />
<a href="https://pypi.org/project/python-qpid-proton/">https://pypi.org/project/python-qpid-proton/</a>
</li>

<li>Qpid Proton<br />
<a href="http://qpid.apache.org/proton/">http://qpid.apache.org/proton/</a>
</li>

<li>Using the AMQ Python Client<br />
<a href="https://access.redhat.com/documentation/en-us/red_hat_amq/7.1/html-single/using_the_amq_python_client/">https://access.redhat.com/documentation/en-us/red_hat_amq/7.1/html-single/using_the_amq_python_client/</a>
</li>

<li>Apache ActiveMQ<br />
<a href="http://activemq.apache.org/">http://activemq.apache.org/</a>
</li>

<li>Apache ActiveMQ Artemis<br />
<a href="https://activemq.apache.org/artemis/">https://activemq.apache.org/artemis/</a>
</li>

<li>Apache ActiveMQ Artemis User Manual<br />
<a href="https://activemq.apache.org/artemis/docs/latest/index.html">https://activemq.apache.org/artemis/docs/latest/index.html</a>
</li>

<li>KahaDB<br />
<a href="http://activemq.apache.org/kahadb.html">http://activemq.apache.org/kahadb.html</a>
</li>

<li>Understanding the KahaDB Message Store<br />
<a href="https://access.redhat.com/documentation/en-US/Fuse_MQ_Enterprise/7.1/html/Configuring_Broker_Persistence/files/KahaDBOverview.html">https://access.redhat.com/documentation/en-US/Fuse_MQ_Enterprise/7.1/html/Configuring_Broker_Persistence/files/KahaDBOverview.html</a>
</li>

<li>Command Line Tools (Apache ActiveMQ)<br />
<a href="https://activemq.apache.org/activemq-command-line-tools-reference.html">https://activemq.apache.org/activemq-command-line-tools-reference.html</a>
</li>

<li>stomp.py 4.1.21 na PyPi<br />
<a href="https://pypi.org/project/stomp.py/">https://pypi.org/project/stomp.py/</a>
</li>

<li>Stomp Tutorial<br />
<a href="https://access.redhat.com/documentation/en-US/Fuse_Message_Broker/5.5/html/Connectivity_Guide/files/FMBConnectivityStompTelnet.html">https://access.redhat.com/documentation/en-US/Fuse_Message_Broker/5.5/html/Connectivity_Guide/files/FMBConnectivityStompTelnet.html</a>
</li>

<li>Heartbeat (computing)<br />
<a href="https://en.wikipedia.org/wiki/Heartbeat_(computing)">https://en.wikipedia.org/wiki/Heartbeat_(computing)</a>
</li>

<li>Apache Camel<br />
<a href="https://camel.apache.org/">https://camel.apache.org/</a>
</li>

<li>Red Hat Fuse<br />
<a href="https://developers.redhat.com/products/fuse/overview/">https://developers.redhat.com/products/fuse/overview/</a>
</li>

<li>Confusion between ActiveMQ and ActiveMQ-Artemis?<br />
<a href="https://serverfault.com/questions/873533/confusion-between-activemq-and-activemq-artemis">https://serverfault.com/questions/873533/confusion-between-activemq-and-activemq-artemis</a>
</li>

<li>Staré stránky projektu HornetQ<br />
<a href="http://hornetq.jboss.org/">http://hornetq.jboss.org/</a>
</li>

<li>Snapshot JeroMQ verze 0.4.4<br />
<a href="https://oss.sonatype.org/content/repositories/snapshots/org/zeromq/jeromq/0.4.4-SNAPSHOT/">https://oss.sonatype.org/content/repositories/snapshots/org/zeromq/jeromq/0.4.4-SNAPSHOT/</a>
</li>

<li>Difference between ActiveMQ vs Apache ActiveMQ Artemis<br />
<a href="http://activemq.2283324.n4.nabble.com/Difference-between-ActiveMQ-vs-Apache-ActiveMQ-Artemis-td4703828.html">http://activemq.2283324.n4.nabble.com/Difference-between-ActiveMQ-vs-Apache-ActiveMQ-Artemis-td4703828.html</a>
</li>

<li>Microservices communications. Why you should switch to message queues<br />
<a href="https://dev.to/matteojoliveau/microservices-communications-why-you-should-switch-to-message-queues--48ia">https://dev.to/matteojoliveau/microservices-communications-why-you-should-switch-to-message-queues--48ia</a>
</li>

<li>Stomp.py 4.1.19 documentation<br />
<a href="https://stomppy.readthedocs.io/en/stable/">https://stomppy.readthedocs.io/en/stable/</a>
</li>

<li>Repositář knihovny JeroMQ<br />
<a href="https://github.com/zeromq/jeromq/">https://github.com/zeromq/jeromq/</a>
</li>

<li>ØMQ &ndash; Distributed Messaging <br />
<a href="http://zeromq.org/">http://zeromq.org/</a>
</li>

<li>ØMQ Community<br />
<a href="http://zeromq.org/community">http://zeromq.org/community</a>
</li>

<li>Get The Software<br />
<a href="http://zeromq.org/intro:get-the-software">http://zeromq.org/intro:get-the-software</a>
</li>

<li>PyZMQ Documentation<br />
<a href="https://pyzmq.readthedocs.io/en/latest/">https://pyzmq.readthedocs.io/en/latest/</a>
</li>

<li>Module: zmq.decorators<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.decorators.html">https://pyzmq.readthedocs.io/en/latest/api/zmq.decorators.html</a>
</li>

<li>ZeroMQ is the answer, by Ian Barber<br />
<a href="https://vimeo.com/20605470">https://vimeo.com/20605470</a>
</li>

<li>ZeroMQ RFC<br />
<a href="https://rfc.zeromq.org/">https://rfc.zeromq.org/</a>
</li>

<li>ZeroMQ and Clojure, a brief introduction<br />
<a href="https://antoniogarrote.wordpress.com/2010/09/08/zeromq-and-clojure-a-brief-introduction/">https://antoniogarrote.wordpress.com/2010/09/08/zeromq-and-clojure-a-brief-introduction/</a>
</li>

<li>zeromq/czmq<br />
<a href="https://github.com/zeromq/czmq">https://github.com/zeromq/czmq</a>
</li>

<li>golang wrapper for CZMQ<br />
<a href="https://github.com/zeromq/goczmq">https://github.com/zeromq/goczmq</a>
</li>

<li>ZeroMQ version reporting in Python<br />
<a href="http://zguide.zeromq.org/py:version">http://zguide.zeromq.org/py:version</a>
</li>

<li>A Go interface to ZeroMQ version 4<br />
<a href="https://github.com/pebbe/zmq4">https://github.com/pebbe/zmq4</a>
</li>

<li>Broker vs. Brokerless<br />
<a href="http://zeromq.org/whitepapers:brokerless">http://zeromq.org/whitepapers:brokerless</a>
</li>

<li>Learning ØMQ with pyzmq<br />
<a href="https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/">https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/</a>
</li>

<li>Céčková funkce <strong>zmq_ctx_new</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-ctx-new">http://api.zeromq.org/4-2:zmq-ctx-new</a>
</li>

<li>Céčková funkce <strong>zmq_ctx_destroy</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-ctx-destroy">http://api.zeromq.org/4-2:zmq-ctx-destroy</a>
</li>

<li>Céčková funkce <strong>zmq_bind</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-bind">http://api.zeromq.org/4-2:zmq-bind</a>
</li>

<li>Céčková funkce <strong>zmq_unbind</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-unbind">http://api.zeromq.org/4-2:zmq-unbind</a>
</li>

<li>Céčková C funkce <strong>zmq_connect</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-connect">http://api.zeromq.org/4-2:zmq-connect</a>
</li>

<li>Céčková C funkce <strong>zmq_disconnect</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-disconnect">http://api.zeromq.org/4-2:zmq-disconnect</a>
</li>

<li>Céčková C funkce <strong>zmq_send</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-send">http://api.zeromq.org/4-2:zmq-send</a>
</li>

<li>Céčková C funkce <strong>zmq_recv</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-recv">http://api.zeromq.org/4-2:zmq-recv</a>
</li>

<li>Třída <strong>Context</strong> (Python)<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.html#context">https://pyzmq.readthedocs.io/en/latest/api/zmq.html#context</a>
</li>

<li>Třída <strong>Socket</strong> (Python)<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.html#socket">https://pyzmq.readthedocs.io/en/latest/api/zmq.html#socket</a>
</li>

<li>Python binding<br />
<a href="http://zeromq.org/bindings:python">http://zeromq.org/bindings:python</a>
</li>

<li>Why should I have written ZeroMQ in C, not C++ (part I)<br />
<a href="http://250bpm.com/blog:4">http://250bpm.com/blog:4</a>
</li>

<li>Why should I have written ZeroMQ in C, not C++ (part II) <br />
<a href="http://250bpm.com/blog:8">http://250bpm.com/blog:8</a>
</li>

<li>About Nanomsg<br />
<a href="https://nanomsg.org/">https://nanomsg.org/</a>
</li>

<li>Advanced Message Queuing Protocol<br />
<a href="https://www.amqp.org/">https://www.amqp.org/</a>
</li>

<li>Advanced Message Queuing Protocol na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol">https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol</a>
</li>

<li>Dokumentace k&nbsp;příkazu <strong>rabbitmqctl</strong><br />
<a href="https://www.rabbitmq.com/rabbitmqctl.8.html">https://www.rabbitmq.com/rabbitmqctl.8.html</a>
</li>

<li>RabbitMQ<br />
<a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a>
</li>

<li>RabbitMQ Tutorials<br />
<a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a>
</li>

<li>RabbitMQ: Clients and Developer Tools<br />
<a href="https://www.rabbitmq.com/devtools.html">https://www.rabbitmq.com/devtools.html</a>
</li>

<li>RabbitMQ na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/RabbitMQ">https://en.wikipedia.org/wiki/RabbitMQ</a>
</li>

<li>Streaming Text Oriented Messaging Protocol<br />
<a href="https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol">https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol</a>
</li>

<li>Message Queuing Telemetry Transport<br />
<a href="https://en.wikipedia.org/wiki/MQTT">https://en.wikipedia.org/wiki/MQTT</a>
</li>

<li>Erlang<br />
<a href="http://www.erlang.org/">http://www.erlang.org/</a>
</li>

<li>pika 0.12.0 na PyPi<br />
<a href="https://pypi.org/project/pika/">https://pypi.org/project/pika/</a>
</li>

<li>Introduction to Pika<br />
<a href="https://pika.readthedocs.io/en/stable/">https://pika.readthedocs.io/en/stable/</a>
</li>

<li>Langohr: An idiomatic Clojure client for RabbitMQ that embraces the AMQP 0.9.1 model<br />
<a href="http://clojurerabbitmq.info/">http://clojurerabbitmq.info/</a>
</li>

<li>AMQP 0-9-1 Model Explained<br />
<a href="http://www.rabbitmq.com/tutorials/amqp-concepts.html">http://www.rabbitmq.com/tutorials/amqp-concepts.html</a>
</li>

<li>Part 1: RabbitMQ for beginners - What is RabbitMQ?<br />
<a href="https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html">https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html</a>
</li>

<li>Downloading and Installing RabbitMQ<br />
<a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a>
</li>

<li>celery na PyPi<br />
<a href="https://pypi.org/project/celery/">https://pypi.org/project/celery/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python <br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python (dokončení)<br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/</a>
</li>

<li>Redis Queue (RQ)<br />
<a href="https://www.fullstackpython.com/redis-queue-rq.html">https://www.fullstackpython.com/redis-queue-rq.html</a>
</li>

<li>Python Celery &amp; RabbitMQ Tutorial<br />
<a href="https://tests4geeks.com/python-celery-rabbitmq-tutorial/">https://tests4geeks.com/python-celery-rabbitmq-tutorial/</a>
</li>

<li>Flower: Real-time Celery web-monitor<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor">http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor</a>
</li>

<li>Asynchronous Tasks With Django and Celery<br />
<a href="https://realpython.com/asynchronous-tasks-with-django-and-celery/">https://realpython.com/asynchronous-tasks-with-django-and-celery/</a>
</li>

<li>First Steps with Celery<br />
<a href="http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html">http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html</a>
</li>

<li>node-celery<br />
<a href="https://github.com/mher/node-celery">https://github.com/mher/node-celery</a>
</li>

<li>Full Stack Python: web development<br />
<a href="https://www.fullstackpython.com/web-development.html">https://www.fullstackpython.com/web-development.html</a>
</li>

<li>Introducing RQ<br />
<a href="https://nvie.com/posts/introducing-rq/">https://nvie.com/posts/introducing-rq/</a>
</li>

<li>Asynchronous Tasks with Flask and Redis Queue<br />
<a href="https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue">https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Stránky projektu Redis<br />
<a href="https://redis.io/">https://redis.io/</a>
</li>

<li>Introduction to Redis<br />
<a href="https://redis.io/topics/introduction">https://redis.io/topics/introduction</a>
</li>

<li>Try Redis<br />
<a href="http://try.redis.io/">http://try.redis.io/</a>
</li>

<li>Redis tutorial, April 2010 (starší, ale pěkně udělaný)<br />
<a href="https://static.simonwillison.net/static/2010/redis-tutorial/">https://static.simonwillison.net/static/2010/redis-tutorial/</a>
</li>

<li>Python Redis<br />
<a href="https://redislabs.com/lp/python-redis/">https://redislabs.com/lp/python-redis/</a>
</li>

<li>Redis: key-value databáze v paměti i na disku<br />
<a href="https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/">https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/</a>
</li>

<li>Praktický úvod do Redis (1): vaše distribuovaná NoSQL cache<br />
<a href="http://www.cloudsvet.cz/?p=253">http://www.cloudsvet.cz/?p=253</a>
</li>

<li>Praktický úvod do Redis (2): transakce<br />
<a href="http://www.cloudsvet.cz/?p=256">http://www.cloudsvet.cz/?p=256</a>
</li>

<li>Praktický úvod do Redis (3): cluster<br />
<a href="http://www.cloudsvet.cz/?p=258">http://www.cloudsvet.cz/?p=258</a>
</li>

<li>Connection pool<br />
<a href="https://en.wikipedia.org/wiki/Connection_pool">https://en.wikipedia.org/wiki/Connection_pool</a>
</li>

<li>Instant Redis Sentinel Setup<br />
<a href="https://github.com/ServiceStack/redis-config">https://github.com/ServiceStack/redis-config</a>
</li>

<li>How to install REDIS in LInux<br />
<a href="https://linuxtechlab.com/how-install-redis-server-linux/">https://linuxtechlab.com/how-install-redis-server-linux/</a>
</li>

<li>Redis RDB Dump File Format<br />
<a href="https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format">https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format</a>
</li>

<li>Lempel–Ziv–Welch<br />
<a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch">https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch</a>
</li>

<li>Redis Persistence<br />
<a href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a>
</li>

<li>Redis persistence demystified<br />
<a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html">http://oldblog.antirez.com/post/redis-persistence-demystified.html</a>
</li>

<li>Redis reliable queues with Lua scripting<br />
<a href="http://oldblog.antirez.com/post/250">http://oldblog.antirez.com/post/250</a>
</li>

<li>Ost (knihovna)<br />
<a href="https://github.com/soveran/ost">https://github.com/soveran/ost</a>
</li>

<li>NoSQL<br />
<a href="https://en.wikipedia.org/wiki/NoSQL">https://en.wikipedia.org/wiki/NoSQL</a>
</li>

<li>Shard (database architecture)<br />
<a href="https://en.wikipedia.org/wiki/Shard_%28database_architecture%29">https://en.wikipedia.org/wiki/Shard_%28database_architecture%29</a>
</li>

<li>What is sharding and why is it important?<br />
<a href="https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important">https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important</a>
</li>

<li>What Is Sharding?<br />
<a href="https://btcmanager.com/what-sharding/">https://btcmanager.com/what-sharding/</a>
</li>

<li>Redis clients<br />
<a href="https://redis.io/clients">https://redis.io/clients</a>
</li>

<li>Category:Lua-scriptable software<br />
<a href="https://en.wikipedia.org/wiki/Category:Lua-scriptable_software">https://en.wikipedia.org/wiki/Category:Lua-scriptable_software</a>
</li>

<li>Seriál Programovací jazyk Lua<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-lua/">https://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>Redis memory usage<br />
<a href="http://nosql.mypopescu.com/post/1010844204/redis-memory-usage">http://nosql.mypopescu.com/post/1010844204/redis-memory-usage</a>
</li>

<li>Ukázka konfigurace Redisu pro lokální testování<br />
<a href="https://github.com/tisnik/presentations/blob/master/redis/redis.conf">https://github.com/tisnik/presentations/blob/master/redis/redis.conf</a>
</li>

<li>Resque<br />
<a href="https://github.com/resque/resque">https://github.com/resque/resque</a>
</li>

<li>Nested transaction<br />
<a href="https://en.wikipedia.org/wiki/Nested_transaction">https://en.wikipedia.org/wiki/Nested_transaction</a>
</li>

<li>Publish–subscribe pattern<br />
<a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern</a>
</li>

<li>Messaging pattern<br />
<a href="https://en.wikipedia.org/wiki/Messaging_pattern">https://en.wikipedia.org/wiki/Messaging_pattern</a>
</li>

<li>Using pipelining to speedup Redis queries<br />
<a href="https://redis.io/topics/pipelining">https://redis.io/topics/pipelining</a>
</li>

<li>Pub/Sub<br />
<a href="https://redis.io/topics/pubsub">https://redis.io/topics/pubsub</a>
</li>

<li>ZeroMQ distributed messaging<br />
<a href="http://zeromq.org/">http://zeromq.org/</a>
</li>

<li>ZeroMQ: Modern &amp; Fast Networking Stack<br />
<a href="https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/">https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/</a>
</li>

<li>Publish/Subscribe paradigm: Why must message classes not know about their subscribers?<br />
<a href="https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr">https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr</a>
</li>

<li>Python &amp; Redis PUB/SUB<br />
<a href="https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7">https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7</a>
</li>

<li>Message broker<br />
<a href="https://en.wikipedia.org/wiki/Message_broker">https://en.wikipedia.org/wiki/Message_broker</a>
</li>

<li>RESP Arrays<br />
<a href="https://redis.io/topics/protocol#array-reply">https://redis.io/topics/protocol#array-reply</a>
</li>

<li>Redis Protocol specification<br />
<a href="https://redis.io/topics/protocol">https://redis.io/topics/protocol</a>
</li>

<li>Redis Pub/Sub: Intro Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-intro/">https://www.redisgreen.net/blog/pubsub-intro/</a>
</li>

<li>Redis Pub/Sub: Howto Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-howto/">https://www.redisgreen.net/blog/pubsub-howto/</a>
</li>

<li>Comparing Publish-Subscribe Messaging and Message Queuing<br />
<a href="https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message">https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message</a>
</li>

<li>Apache Kafka<br />
<a href="https://kafka.apache.org/">https://kafka.apache.org/</a>
</li>

<li>Iron<br />
<a href="http://www.iron.io/mq">http://www.iron.io/mq</a>
</li>

<li>kue (založeno na Redisu, určeno pro node.js)<br />
<a href="https://github.com/Automattic/kue">https://github.com/Automattic/kue</a>
</li>

<li>Cloud Pub/Sub<br />
<a href="https://cloud.google.com/pubsub/">https://cloud.google.com/pubsub/</a>
</li>

<li>Introduction to Redis Streams<br />
<a href="https://redis.io/topics/streams-intro">https://redis.io/topics/streams-intro</a>
</li>

<li>glob (programming)<br />
<a href="https://en.wikipedia.org/wiki/Glob_(programming)">https://en.wikipedia.org/wiki/Glob_(programming)</a>
</li>

<li>Why and how Pricing Assistant migrated from Celery to RQ - Paris.py<br />
<a href="https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2">https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2</a>
</li>

<li>Enqueueing internals<br />
<a href="http://python-rq.org/contrib/">http://python-rq.org/contrib/</a>
</li>

<li>queue — A synchronized queue class<br />
<a href="https://docs.python.org/3/library/queue.html">https://docs.python.org/3/library/queue.html</a>
</li>

<li>Queue – A thread-safe FIFO implementation<br />
<a href="https://pymotw.com/2/Queue/">https://pymotw.com/2/Queue/</a>
</li>

<li>Queues<br />
<a href="http://queues.io/">http://queues.io/</a>
</li>

<li>Windows Subsystem for Linux Documentation<br />
<a href="https://docs.microsoft.com/en-us/windows/wsl/about">https://docs.microsoft.com/en-us/windows/wsl/about</a>
</li>

<li>RestMQ<br />
<a href="http://restmq.com/">http://restmq.com/</a>
</li>

<li>ActiveMQ<br />
<a href="http://activemq.apache.org/">http://activemq.apache.org/</a>
</li>

<li>Amazon MQ<br />
<a href="https://aws.amazon.com/amazon-mq/">https://aws.amazon.com/amazon-mq/</a>
</li>

<li>Amazon Simple Queue Service<br />
<a href="https://aws.amazon.com/sqs/">https://aws.amazon.com/sqs/</a>
</li>

<li>Celery: Distributed Task Queue<br />
<a href="http://www.celeryproject.org/">http://www.celeryproject.org/</a>
</li>

<li>Disque, an in-memory, distributed job queue<br />
<a href="https://github.com/antirez/disque">https://github.com/antirez/disque</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Projekt RQ na PyPi<br />
<a href="https://pypi.org/project/rq/">https://pypi.org/project/rq/</a>
</li>

<li>rq-dashboard 0.3.12<br />
<a href="https://pypi.org/project/rq-dashboard/">https://pypi.org/project/rq-dashboard/</a>
</li>

<li>Job queue<br />
<a href="https://en.wikipedia.org/wiki/Job_queue">https://en.wikipedia.org/wiki/Job_queue</a>
</li>

<li>Why we moved from Celery to RQ<br />
<a href="https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq">https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq</a>
</li>

<li>Running multiple workers using Celery<br />
<a href="https://serverfault.com/questions/655387/running-multiple-workers-using-celery">https://serverfault.com/questions/655387/running-multiple-workers-using-celery</a>
</li>

<li>celery — Distributed processing<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.html">http://docs.celeryproject.org/en/latest/reference/celery.html</a>
</li>

<li>Chains<br />
<a href="https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains">https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains</a>
</li>

<li>Routing<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing">http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing</a>
</li>

<li>Celery Distributed Task Queue in Go<br />
<a href="https://github.com/gocelery/gocelery/">https://github.com/gocelery/gocelery/</a>
</li>

<li>Python Decorators<br />
<a href="https://wiki.python.org/moin/PythonDecorators">https://wiki.python.org/moin/PythonDecorators</a>
</li>

<li>Periodic Tasks<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html">http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html</a>
</li>

<li>celery.schedules<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab">http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab</a>
</li>

<li>Pros and cons to use Celery vs. RQ<br />
<a href="https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq">https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq</a>
</li>

<li>Priority queue<br />
<a href="https://en.wikipedia.org/wiki/Priority_queue">https://en.wikipedia.org/wiki/Priority_queue</a>
</li>

<li>Jupyter<br />
<a href="https://jupyter.org/">https://jupyter.org/</a>
</li>

<li>How IPython and Jupyter Notebook work<br />
<a href="https://jupyter.readthedocs.io/en/latest/architecture/how_jupyter_ipython_work.html">https://jupyter.readthedocs.io/en/latest/architecture/how_jupyter_ipython_work.html</a>
</li>

<li>Context Managers<br />
<a href="http://book.pythontips.com/en/latest/context_managers.html">http://book.pythontips.com/en/latest/context_managers.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

