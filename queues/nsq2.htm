<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>NSQ - systém pro doručování zpráv bez centrálního message brokera (dokončení)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>NSQ - systém pro doručování zpráv bez centrálního message brokera (dokončení)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhém článku o nástroji NSQ si ukážeme některé možné konfigurace používané v praxi. Zaměříme se mj. i na ty konfigurace, které do značné míry vylučují existenci SPOF, tedy jednoho uzlu (počítače, služby, procesu), jehož pád by způsobit nefunkčnost celého systému doručování zpráv.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. NSQ &ndash; systém pro doručování zpráv bez centrálního message brokera (dokončení)</a></p>
<p><a href="#k02">2. Zdrojové kódy producentů a konzumentů zpráv použitých v&nbsp;dnešním článku</a></p>
<p><a href="#k03">3. Nejjednodušší konfigurace s&nbsp;jediným <i>nsqd</i>, využití serializace zpráv na disk</a></p>
<p><a href="#k04">4. Připojení většího množství producentů zpráv</a></p>
<p><a href="#k05">5. Load-balancing konzumentů zpráv připojených ke stejnému kanálu</a></p>
<p><a href="#k06">6. Předání stejných zpráv několika konzumentům (distribuce)</a></p>
<p><a href="#k07">7. Archivace zpráv utilitou <strong>nsq_to_file</strong></a></p>
<p><a href="#k08">8. Špatné nastavení archivace</a></p>
<p><a href="#k09">9. Chování systému ve chvíli, kdy zpráva nemůže být doručena</a></p>
<p><a href="#k10">10. Důvody vedoucí k&nbsp;využití více služeb <i>nsqd</i></a></p>
<p><a href="#k11">11. Paralelně a nezávisle na sobě běžící služby <i>nsqd</i></a></p>
<p><a href="#k12">12. Chování dvou nezávislých služeb <i>nsqd</i></a></p>
<p><a href="#k13">13. Konzument zpráv připojený k&nbsp;více službám <i>nsqd</i></a></p>
<p><a href="#k14">14. Chování dvou nezávislých služeb <i>nsqd</i> s&nbsp;konzumentem připojeným k&nbsp;oběma službám</a></p>
<p><a href="#k15">15. Využití adresářové služby <i>nsqlookupd</i></a></p>
<p><a href="#k16">16. Úprava klienta (konzumenta) pro použití <i>nsqlookupd</i></a></p>
<p><a href="#k17">17. Otestování chování klienta</a></p>
<p><a href="#k18">18. Konzument současně přijímající zprávy z&nbsp;více služeb <i>nsqd</i></a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. NSQ &ndash; systém pro doručování zpráv bez centrálního message brokera (dokončení)</h2>

<p><a
href="https://www.root.cz/clanky/nsq-system-pro-dorucovani-zprav-bez-centralniho-message-brokera/">V&nbsp;prvním
článku</a> o nástroji <i>NSQ</i> jsme se seznámili se základními vlastnostmi
tohoto systému pro doručování zpráv vyvinutého <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">v&nbsp;programovacím
jazyce Go</a>. Připomeňme si, že tento systém je založen na myšlence
decentralizovaného doručování zpráv, což znamená, že se nejedná o klasického
message brokera, ale o distribuovaný systém s&nbsp;větším množstvím uzlů,
k&nbsp;nimž se mohou připojit jak producenti zpráv, tak i jejich konzumenti
(příjemci zpráv). Celý systém je přitom navržen takovým způsobem, aby se
(pochopitelně při správné konfiguraci a pokud je to vůbec vyžadováno) výpadek
nějakého uzlu neprojevil na pádu či nedostupnosti celého systému. Na druhou
stranu je však možné, že jedna zpráva bude nějakým příjemcem přijata vícekrát,
což je daň, kterou musíme zaplatit za decentralizovanou architekturu (jinými
slovy to znamená, že by příjemci měli být idempotentní, což si někdy vyžádá
nutnost použití databáze či jiného datového úložiště
s&nbsp;&bdquo;pamětí&ldquo; již zpracovaných zpráv).</p>

<p>Celý systém <i>NSQ</i> je složen z&nbsp;několika typů uzlů, přičemž
jednotlivé uzly mohou být provozovány na různých počítačích, geograficky
distribuovány atd. Jedná se o následující typy uzlů:</p>

<ol>

<li><i>nsqlookupd</i> &ndash; jedná se o takzvanou <i>directory service</i>,
tj.&nbsp;o službu, do které se registrují všechny ostatní uzly a která tak má
přehled o umístění (adresa+číslo portu) i o stavu jednotlivých uzlů. Konzumenti
se typicky nejprve připojují právě k&nbsp;<i>nsqlookupd</i>, aby zjistili,
které brokery jsou schopny jim dodávat zprávy požadovaných témat
(<i>topic</i>). Existuje ovšem možnost <i>nsqlookupd</i> vůbec nevyužívat a
připojovat se přímo ke službě <i>nsqd</i>.</li>

<li><i>nsqd</i> &ndash; tyto uzly, jichž může běžet libovolné množství,
zajišťují vlastní příjem zpráv, jejich ukládání do front a následné doručení
konzumentům. Zprávy jsou perzistentní, tj.&nbsp;ve chvíli, kdy je uzel
<i>nsqd</i> zastavován, jsou uloženy do souboru a po znovuspuštění jsou ze
souboru načteny do paměti a popř.&nbsp;zaslány konzumentům.</li>

<li><i>nsqadmin</i> &ndash; tato služba poskytuje (webové) uživatelské
rozhraní, ze kterého je možné sledovat činnost celého systému. Samotné
sledování je primárně založeno na komunikaci s&nbsp;prvním typem uzlu &ndash;
<i>nsqlookupd</i> a sekundárně s&nbsp;uzly <i>nsqd</i>.</li>

</ol>

<a href="https://www.root.cz/obrazek/348763/"><img src="https://i.iinfo.cz/images/176/rabbitmq1-2-prev.png" class="image-348763" alt="&#160;" width="370" height="60" /></a>
<p><i>Obrázek 1: Klasický message broker využívaný dalšími systémy.</i></p>

<p>Připomeňme si navíc, že zprávy se do <i>NSQ</i> posílají s&nbsp;nastaveným
tématem (<i>topic</i>). Výběr (či možná lépe řečeno odběr) zpráv je nepatrně
složitější, protože je nutné specifikovat jak téma odebíraných zpráv, tak i
takzvaný kanál (<i>channel</i>), ze kterého se zprávy vybírají. Pokud pro
nějaké schéma existuje větší množství kanálů, bude zpráva přeposlána
(distribuována) do všech kanálů s&nbsp;tímto tématem. V&nbsp;případě, že se
k&nbsp;jednomu kanálu připojí více příjemců, bude zpráva doručena jen jednomu
z&nbsp;nich (buď náhodně nebo prvnímu volnému příjemci). Případný
<i>load-balancing</i> se tedy provádí na úrovni kanálů, které můžeme považovat
za obdobu front zpráv (<i>message queue</i>), jež známe z&nbsp;popisu
klasických message brokerů (ve skutečnosti se ovšem fronta interně vytváří i na
úrovni samotného tématu, tj.&nbsp;na vstupu do <i>nsqd</i>). Některé možné
konfigurace systému <i>NSQ</i> si naznačíme na schématech v&nbsp;navazujících
kapitolách.</p>

<a href="https://www.root.cz/obrazek/348764/"><img src="https://i.iinfo.cz/images/176/rabbitmq1-3-prev.png" class="image-348764" alt="&#160;" width="370" height="125" /></a>
<p><i>Obrázek 2: Počet producentů ani konzumentů není v&nbsp;podstatě nijak
omezen.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Zdrojové kódy producentů a konzumentů zpráv použitých v&nbsp;dnešním článku</h2>

<p>Pro otestování základních funkcí různých konfigurací systému <i>NSQ</i>
použijeme producenta zpráv naprogramovaného v&nbsp;jazyce Go. Tento producent
bude s&nbsp;frekvencí přibližně jedné sekundy vytvářet zprávy, které budou
posílány do lokálně běžící služby <i>nsqd</i>. Zprávy budou směrovány do tématu
&bdquo;test&ldquo;. Zdrojový kód tohoto producenta naleznete na adrese <a
href="https://github.com/tisnik/message-queues-examples/blob/master/nsq/producer3.go">https://github.com/tisnik/message-queues-examples/blob/master/nsq/producer3.go</a>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/nsqio/go-nsq"
        "log"
        "time"
)
&nbsp;
const Address = "127.0.0.1:4150"
&nbsp;
const Topic = "test"
&nbsp;
func <strong>main</strong>() {
        config := nsq.NewConfig()
&nbsp;
        producer, err := nsq.NewProducer(Address, config)
        if err != nil {
                log.Panic("Producer can't be constructed")
        }
        defer producer.Stop()
&nbsp;
        i := 0
&nbsp;
        for {
                message := fmt.Sprintf("Zprava z Go #%d", i)
                log.Print("Sending message: ", message)
                err = producer.Publish(Topic, []byte(message))
                if err != nil {
                        log.Panic("Could not connect")
                }
                i++
                time.Sleep(1 * time.Second)
        }
}
</pre>

<p>Taktéž pochopitelně použijeme konzumenta, který bude opět vyvinut
v&nbsp;programovacím jazyce Go. První varianta konzumenta, kterou naleznete na
adrese <a
href="https://github.com/tisnik/message-queues-examples/blob/master/nsq/consumer4_chan_A.go">https://github.com/tisnik/message-queues-examples/blob/master/nsq/consumer4_chan_A.go</a>,
se bude připojovat na lokálně běžící službu <i>nsqd</i> (tedy na stejnou
službu, jako konzument) a bude odebírat zprávy s&nbsp;tématem
&bdquo;test&ldquo; z&nbsp;kanálu, jehož jméno je z&nbsp;důvodu co největší
jednoduchosti nastaveno na &bdquo;A&ldquo; (ovšem může se jednat o libovolný
řetězec):</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/nsqio/go-nsq"
        "log"
)
&nbsp;
const Address = "127.0.0.1:4150"
&nbsp;
const Topic = "test"
&nbsp;
const Channel = "A"
&nbsp;
func <strong>main</strong>() {
        config := nsq.NewConfig()
&nbsp;
        consumer, err := nsq.NewConsumer(Topic, Channel, config)
        if err != nil {
                log.Panic("Consumer can't be constructed")
        }
&nbsp;
        done := make(chan bool)
&nbsp;
        consumer.AddHandler(nsq.HandlerFunc(func(message *nsq.Message) error {
                log.Printf("Received a message: %s", string(message.Body))
                <i>// done &lt;- true</i>
                return nil
        }))
&nbsp;
        err = consumer.ConnectToNSQD(Address)
        if err != nil {
                log.Panic("Could not connect")
        }
&nbsp;
        log.Println("Waiting for message")
        &lt;-done
}
</pre>

<p>Druhý konzument se odlišuje jen v&nbsp;tom, že se připojuje na kanál B.
Zdrojový kód tohoto konzumenta je uložen na adrese <a
href="https://github.com/tisnik/message-queues-examples/blob/master/nsq/consumer4_chan_B.go">https://github.com/tisnik/message-queues-examples/blob/master/nsq/consumer4_chan_B.go</a>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/nsqio/go-nsq"
        "log"
)
&nbsp;
const Address = "127.0.0.1:4150"
&nbsp;
const Topic = "test"
&nbsp;
const Channel = "B"
&nbsp;
func <strong>main</strong>() {
        config := nsq.NewConfig()
&nbsp;
        consumer, err := nsq.NewConsumer(Topic, Channel, config)
        if err != nil {
                log.Panic("Consumer can't be constructed")
        }
&nbsp;
        done := make(chan bool)
&nbsp;
        consumer.AddHandler(nsq.HandlerFunc(func(message *nsq.Message) error {
                log.Printf("Received a message: %s", string(message.Body))
                <i>// done &lt;- true</i>
                return nil
        }))
&nbsp;
        err = consumer.ConnectToNSQD(Address)
        if err != nil {
                log.Panic("Could not connect")
        }
&nbsp;
        log.Println("Waiting for message")
        &lt;-done
}
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Nejjednodušší konfigurace s&nbsp;jediným <i>nsqd</i>, využití serializace zpráv na disk</h2>

<p>V&nbsp;závislosti na tom, jaké chování a vlastnosti od systému doručování
zpráv vyžadujeme, je možné <i>NSQ</i> nakonfigurovat několika možnými způsoby.
Nejprve si pro úplnost uvedeme tu nejjednodušší možnou konfiguraci, v&nbsp;níž
vystupuje pouze jediný uzel typu <i>nsqd</i>, k&nbsp;němuž se připojují jak ty
služby, které zprávy vytváří, tak i konzumenti zpráv. V&nbsp;případě, že bude
použito jen jediné téma (se jménem &bdquo;&ldquo;) a jediný kanál (se jménem
&bdquo;A&ldquo;), bude celá architektura připomínat jednoduchého message
brokera s&nbsp;jedinou frontou zpráv:</p>

<img src="https://i.iinfo.cz/images/262/nsq2-1-1.png" class="image-396168" alt="&#160;" width="305" height="820" />
<p><i>Obrázek 3: Nejjednodušší konfigurace systému NSQ s&nbsp;jediným nsqd.</i></p>

<p>Předchozí nastavení <i>NSQ</i> bylo skutečně triviální, ovšem v&nbsp;praxi
se setkáme s&nbsp;mnoha dalšími požadavky na službu pro doručování zpráv, které
je nutné nějakým způsobem implementovat. Poměrně častý a přitom jednoduše
řešitelný je požadavek na to, aby se zprávy nehromadily v&nbsp;operační paměti
alokované službou <i>nsqd</i>. Při startu <i>nsqd</i> je možné určit maximální
kapacitu paměti použitou pro zapamatování zpráv. Tato kapacita
(resp.&nbsp;přesněji řečeno mezní hodnota) se označuje termínem &bdquo;high
water mark&ldquo;. Ve chvíli, kdy by mělo dojít k&nbsp;překročení této
kapacity, budou zprávy uloženy na disk, takže se paměťové požadavky uzlu
<i>nsqd</i> mohou udržet ve stanovených mezích. Z&nbsp;pohledu producentů a
konzumentů zpráv ovšem nedojde k&nbsp;žádné podstatné změně:</p>

<img src="https://i.iinfo.cz/images/262/nsq2-1-2.png" class="image-396169" alt="&#160;" width="474" height="830" />
<p><i>Obrázek 4: Konfigurace systému NSQ s&nbsp;jediným nsqd a případnou
serializací zpráv na disk.</i></p>

<p><div class="rs-tip-major">Poznámka: na tomto místě si připomeňme, že pokud
dojde k&nbsp;ukončení běhu služby <i>nsqd</i>, budou zprávy taktéž
serializovány, a to do té chvíle, než se služba znovu nastartuje a dojde
k&nbsp;jejich opětovné deserializaci. Může se ovšem stát, že některá zpráva
bude konzumentům doručena vícekrát (<i>nsqd</i> se totiž může ukončit ve
chvíli, kdy ještě nedojde k&nbsp;potvrzení doručení posledních zpráv odeslaných
konzumentům, popř.&nbsp;potvrzení dojde, ale informace o něm se již nestačí
serializovat).</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Připojení většího množství producentů zpráv</h2>

<p>Samozřejmě nejsme omezeni pouze na jednoho producenta zpráv (pro zvolený
topic). Producentů může existovat libovolné množství a jedinou informaci,
kterou musí znát, je adresa služby <i>nsqd</i> a jméno tématu:</p>

<p><img src="https://i.iinfo.cz/images/497/nsq2-2-1.png" class="image-396170" alt="&#160;" width="341" height="810" /></p>
<p><i>Obrázek 5: Větší množství producentů zpráv připojených do jediného
nsqd.</i></p>

<p>Chování takto nastaveného systému si můžeme snadno odzkoušet. Po spuštění
služby <i>nsqd</i> (ta musí běžet) nastartujeme prvního producenta zpráv:</p>

<pre>
$ <strong>./producer3</strong>
&nbsp;
2019/11/11 23:32:12 Sending message: Zprava z Go #0
2019/11/11 23:32:12 INF    1 (127.0.0.1:4150) connecting to nsqd
2019/11/11 23:32:13 Sending message: Zprava z Go #1
2019/11/11 23:32:14 Sending message: Zprava z Go #2
2019/11/11 23:32:15 Sending message: Zprava z Go #3
2019/11/11 23:32:16 Sending message: Zprava z Go #4
2019/11/11 23:32:17 Sending message: Zprava z Go #5
2019/11/11 23:32:18 Sending message: Zprava z Go #6
2019/11/11 23:32:19 Sending message: Zprava z Go #7
2019/11/11 23:32:20 Sending message: Zprava z Go #8
2019/11/11 23:32:21 Sending message: Zprava z Go #9
2019/11/11 23:32:22 Sending message: Zprava z Go #10
</pre>

<p>Současně ve druhém terminálu spustíme druhého producenta zpráv (se stejným
tématem):</p>

<pre>
$ <strong>./producer3B</strong>
&nbsp;
2019/11/11 23:32:12 Sending message: Message from Go #0
2019/11/11 23:32:12 INF    1 (127.0.0.1:4150) connecting to nsqd
2019/11/11 23:32:13 Sending message: Message from Go #1
2019/11/11 23:32:14 Sending message: Message from Go #2
2019/11/11 23:32:15 Sending message: Message from Go #3
2019/11/11 23:32:16 Sending message: Message from Go #4
2019/11/11 23:32:17 Sending message: Message from Go #5
2019/11/11 23:32:18 Sending message: Message from Go #6
2019/11/11 23:32:19 Sending message: Message from Go #7
2019/11/11 23:32:20 Sending message: Message from Go #8
2019/11/11 23:32:21 Sending message: Message from Go #9
</pre>

<p>Ve třetím terminálu spustíme konzumenta zpráv připojeného k&nbsp;tématu
&bdquo;test&ldquo; a (jedinému) kanálu &bdquo;A&ldquo;. Vidíme, že konzument
zpracovává zprávy z&nbsp;obou producentů:</p>

<pre>
$ <strong>./consumer4_chan_A</strong>
&nbsp;
2019/11/11 23:32:02 INF    1 [test/A] (127.0.0.1:4150) connecting to nsqd
2019/11/11 23:32:02 Waiting for message
2019/11/11 23:32:12 Received a message: Zprava z Go #0
2019/11/11 23:32:12 Received a message: Message from Go #0
2019/11/11 23:32:13 Received a message: Zprava z Go #1
2019/11/11 23:32:13 Received a message: Message from Go #1
2019/11/11 23:32:14 Received a message: Zprava z Go #2
2019/11/11 23:32:14 Received a message: Message from Go #2
2019/11/11 23:32:15 Received a message: Zprava z Go #3
2019/11/11 23:32:15 Received a message: Message from Go #3
2019/11/11 23:32:16 Received a message: Zprava z Go #4
2019/11/11 23:32:16 Received a message: Message from Go #4
2019/11/11 23:32:17 Received a message: Zprava z Go #5
2019/11/11 23:32:17 Received a message: Message from Go #5
2019/11/11 23:32:18 Received a message: Zprava z Go #6
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Load-balancing konzumentů zpráv připojených ke stejnému kanálu</h2>

<p>Podobně je možné &ndash; a velmi často se s&nbsp;takovou situací setkáme
&ndash; že existuje několik konzumentů zpráv zaregistrovaných k&nbsp;odběru
stejného tématu na shodném kanálu. V&nbsp;takovém případě dojde k&nbsp;již výše
zmíněnému <i>load-balancingu</i> &ndash; zpráva je poslána jen jednomu
zvolenému klientovi:</p>

<p><img src="https://i.iinfo.cz/images/673/nsq2-3-1.png" class="image-396172" alt="&#160;" width="292" height="512" /></p>
<p><i>Obrázek 6: Větší množství konzumentů zpráv připojených do jediného
nsqd.</i></p>

<p>Toto chování si opět můžeme snadno otestovat.</p>

<p>Opět spustíme producenta zpráv:</p>

<pre>
$ <strong>./producer3</strong>
&nbsp;
2019/11/11 23:32:12 Sending message: Zprava z Go #0
2019/11/11 23:32:12 INF    1 (127.0.0.1:4150) connecting to nsqd
2019/11/11 23:32:13 Sending message: Zprava z Go #1
2019/11/11 23:32:14 Sending message: Zprava z Go #2
2019/11/11 23:32:15 Sending message: Zprava z Go #3
2019/11/11 23:32:16 Sending message: Zprava z Go #4
2019/11/11 23:32:17 Sending message: Zprava z Go #5
2019/11/11 23:32:18 Sending message: Zprava z Go #6
2019/11/11 23:32:19 Sending message: Zprava z Go #7
2019/11/11 23:32:20 Sending message: Zprava z Go #8
2019/11/11 23:32:21 Sending message: Zprava z Go #9
2019/11/11 23:32:22 Sending message: Zprava z Go #10
</pre>

<p>A následně spustíme dva konzumenty, kteří se připojí ke stejnému tématu i
shodnému kanálu:</p>

<pre>
$ <strong>./consumer4_chan_A </strong>
&nbsp;
2019/11/10 19:33:49 INF    1 [test/A] (127.0.0.1:4150) connecting to nsqd
2019/11/10 19:33:49 Waiting for message
2019/11/10 19:33:56 Received a message: Zprava z Go #0
2019/11/10 19:33:58 Received a message: Zprava z Go #2
2019/11/10 19:34:00 Received a message: Zprava z Go #4
2019/11/10 19:34:02 Received a message: Zprava z Go #6
2019/11/10 19:34:04 Received a message: Zprava z Go #8
2019/11/10 19:34:06 Received a message: Zprava z Go #10
2019/11/10 19:34:08 Received a message: Zprava z Go #12
2019/11/10 19:34:10 Received a message: Zprava z Go #14
</pre>

<pre>
$ <strong>./consumer4_chan_A</strong>
&nbsp;
2019/11/10 19:33:52 INF    1 [test/A] (127.0.0.1:4150) connecting to nsqd
2019/11/10 19:33:52 Waiting for message
2019/11/10 19:33:57 Received a message: Zprava z Go #1
2019/11/10 19:33:59 Received a message: Zprava z Go #3
2019/11/10 19:34:01 Received a message: Zprava z Go #5
2019/11/10 19:34:03 Received a message: Zprava z Go #7
2019/11/10 19:34:05 Received a message: Zprava z Go #9
2019/11/10 19:34:07 Received a message: Zprava z Go #11
2019/11/10 19:34:09 Received a message: Zprava z Go #13
2019/11/10 19:34:11 Received a message: Zprava z Go #15
</pre>

<p><div class="rs-tip-major">Poznámka: můžeme vidět, že se konzumenti skutečně
střídají v&nbsp;získávání a zpracovávání zpráv.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Předání stejných zpráv několika konzumentům (distribuce)</h2>

<p>Ovšem můžeme požadovat i odlišné chování &ndash; předání shodných zpráv
několika konzumentům. Řešení tohoto požadavku je ve skutečnosti velmi snadné,
protože postačuje zajistit, aby každý z&nbsp;konzumentů používal odlišný kanál
tak, jak je to naznačeno na dalším schématu:</p>

<p><img src="https://i.iinfo.cz/images/104/nsq2-4-1.png" class="image-396174" alt="&#160;" width="340" height="543" /></p>
<p><i>Obrázek 7: Příjem zpráv se stejným tématem, ale z&nbsp;odlišných
kanálů.</i></p>

<p>Otestování &ndash; spustíme producenta zpráv:</p>

<pre>
$ <strong>./producer3</strong>
&nbsp;
2019/11/11 23:32:12 Sending message: Zprava z Go #0
2019/11/11 23:32:12 INF    1 (127.0.0.1:4150) connecting to nsqd
2019/11/11 23:32:13 Sending message: Zprava z Go #1
2019/11/11 23:32:14 Sending message: Zprava z Go #2
2019/11/11 23:32:15 Sending message: Zprava z Go #3
2019/11/11 23:32:16 Sending message: Zprava z Go #4
2019/11/11 23:32:17 Sending message: Zprava z Go #5
2019/11/11 23:32:18 Sending message: Zprava z Go #6
2019/11/11 23:32:19 Sending message: Zprava z Go #7
2019/11/11 23:32:20 Sending message: Zprava z Go #8
2019/11/11 23:32:21 Sending message: Zprava z Go #9
2019/11/11 23:32:22 Sending message: Zprava z Go #10
</pre>

<p>První konzument bude přijímat zprávy z&nbsp;kanálu A:</p>

<pre>
$ <strong>./consumer4_chan_A </strong>
&nbsp;
2019/11/10 19:35:25 INF    1 [test/A] (127.0.0.1:4150) connecting to nsqd
2019/11/10 19:35:25 Waiting for message
2019/11/10 19:35:32 Received a message: Zprava z Go #0
2019/11/10 19:35:33 Received a message: Zprava z Go #1
2019/11/10 19:35:34 Received a message: Zprava z Go #2
2019/11/10 19:35:35 Received a message: Zprava z Go #3
2019/11/10 19:35:36 Received a message: Zprava z Go #4
2019/11/10 19:35:37 Received a message: Zprava z Go #5
2019/11/10 19:35:38 Received a message: Zprava z Go #6
2019/11/10 19:35:39 Received a message: Zprava z Go #7
2019/11/10 19:35:40 Received a message: Zprava z Go #8
2019/11/10 19:35:41 Received a message: Zprava z Go #9
2019/11/10 19:35:42 Received a message: Zprava z Go #10
</pre>

<p>Druhý konzument bude přijímat zprávy z&nbsp;kanálu B:</p>

<pre>
$ <strong>./consumer4_chan_B</strong>
&nbsp;
2019/11/10 19:35:29 INF    1 [test/B] (127.0.0.1:4150) connecting to nsqd
2019/11/10 19:35:29 Waiting for message
2019/11/10 19:35:32 Received a message: Zprava z Go #0
2019/11/10 19:35:33 Received a message: Zprava z Go #1
2019/11/10 19:35:34 Received a message: Zprava z Go #2
2019/11/10 19:35:35 Received a message: Zprava z Go #3
2019/11/10 19:35:36 Received a message: Zprava z Go #4
2019/11/10 19:35:37 Received a message: Zprava z Go #5
2019/11/10 19:35:38 Received a message: Zprava z Go #6
2019/11/10 19:35:39 Received a message: Zprava z Go #7
2019/11/10 19:35:40 Received a message: Zprava z Go #8
2019/11/10 19:35:41 Received a message: Zprava z Go #9
2019/11/10 19:35:42 Received a message: Zprava z Go #10
</pre>

<p>Mimochodem: v&nbsp;pracovním adresáři služby <i>nsqd</i> se vytvoří soubor
obsahující informace o tématech i o kanálech:</p>

<pre>
{
  "topics": [
    {
      "channels": [
        {
          "name": "A",
          "paused": false
        },
        {
          "name": "B",
          "paused": false
        }
      ],
      "name": "test",
      "paused": false
    }
  ],
  "version": "1.2.1-alpha"
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Archivace zpráv utilitou <strong>nsq_to_file</strong></h2>

<p>V&nbsp;mnoha situacích se setkáme s&nbsp;požadavkem archivace zpráv, které
byly do systému poslány. Buď se může jednat o všechny zprávy nebo o zprávy
s&nbsp;určitým tématem. Samozřejmě je možné naprogramovat konzumenta, který
bude archivaci nějakým způsobem provádět, ovšem přesně pro tento účel existuje
standardní utilita, která je součástí standardní instalace systému <i>NSQ</i>.
Tato utilita se jmenuje příznačně <strong>nsq_to_file</strong> a při jejím
volání musíme určit jak téma zpráv, které mají být archivovány, tak i jméno
kanálu (a pochopitelně i adresu <i>nsqd</i> použitou pro příjem zpráv):</p>

<pre>
$ <strong>nsq_to_file --nsqd-tcp-address=localhost:4150 --topic test --channel archive</strong>
</pre>

<p>Přitom je nutné zajistit, aby se k&nbsp;danému kanálu nepřipojovali žádní
běžní konzumenti zpráv, neboť již víme, že v&nbsp;takovém případě by se zpráva
poslala jen jednomu zvolenému konzumentovi (podle jejich aktuálního vytížení).
V&nbsp;případě, že utilita <strong>nsq_to_file</strong> bude naopak připojena
k&nbsp;unikátnímu kanálu, mohou být ostatní konzumenti připojeni ke kanálu
jinému a stále bude zaručeno, že se všechny zprávy s&nbsp;daným tématem budou
archivovat. Toto chování si můžeme velmi snadno otestovat, protože
postačuje:</p>

<ol>
<li>Spustit <i>nsqd</i></li>
<li>Spustit konzumenta zpráv</li>
<li>Spustit zde popisovanou utilitu <strong>nsq_to_file</strong></li>
<li>A nakonec spustit producenta zpráv</li>
</ol>

<p>Výsledky po odeslání jedenácti zpráv vypadají následovně.</p>

<p>Konzument:</p>

<pre>
$ <strong>./consumer4_chan_A </strong>
&nbsp;
2019/11/10 19:39:29 INF    1 [test/A] (127.0.0.1:4150) connecting to nsqd
2019/11/10 19:39:29 Waiting for message
2019/11/10 19:39:31 Received a message: Zprava z Go #0
2019/11/10 19:39:32 Received a message: Zprava z Go #1
2019/11/10 19:39:33 Received a message: Zprava z Go #2
2019/11/10 19:39:34 Received a message: Zprava z Go #3
2019/11/10 19:39:35 Received a message: Zprava z Go #4
2019/11/10 19:39:36 Received a message: Zprava z Go #5
2019/11/10 19:39:37 Received a message: Zprava z Go #6
2019/11/10 19:39:38 Received a message: Zprava z Go #7
2019/11/10 19:39:39 Received a message: Zprava z Go #8
2019/11/10 19:39:40 Received a message: Zprava z Go #9
2019/11/10 19:39:41 Received a message: Zprava z Go #10
</pre>

<p>Chování archivátoru zpráv:</p>

<pre>
$ <strong>./nsq_to_file --nsqd-tcp-address=localhost:4150 --topic test --channel archive</strong>
&nbsp;
2019/11/10 19:39:18 INF    1 [test/archive] (localhost:4150) connecting to nsqd
[nsq_to_file] 2019/11/10 19:39:31.461572 INFO: [test/archive] opening /tmp/test.tester-ThinkPad-T410.2019-11-10_19.log
[nsq_to_file] 2019/11/10 19:39:31.461687 INFO: [test/archive] syncing 1 records to disk
[nsq_to_file] 2019/11/10 19:39:48.314973 INFO: [test/archive] syncing 10 records to disk
^C2019/11/10 19:40:02 INF    1 [test/archive] stopping...
2019/11/10 19:40:02 INF    1 [test/archive] (localhost:4150) received CLOSE_WAIT from nsqd
2019/11/10 19:40:02 INF    1 [test/archive] (localhost:4150) beginning close
2019/11/10 19:40:02 INF    1 [test/archive] (localhost:4150) readLoop exiting
2019/11/10 19:40:02 INF    1 [test/archive] (localhost:4150) breaking out of writeLoop
2019/11/10 19:40:02 INF    1 [test/archive] (localhost:4150) writeLoop exiting
2019/11/10 19:40:03 INF    1 [test/archive] (localhost:4150) finished draining, cleanup exiting
2019/11/10 19:40:03 INF    1 [test/archive] (localhost:4150) clean close complete
2019/11/10 19:40:03 WRN    1 [test/archive] there are 0 connections left alive
2019/11/10 19:40:03 INF    1 [test/archive] stopping handlers
2019/11/10 19:40:03 INF    1 [test/archive] rdyLoop exiting
</pre>

<p>Obsah souboru, do kterého se archivují zprávy (implicitně je tento soubor
umístěn v&nbsp;adresáři <strong>/tmp</strong>, ovšem v&nbsp;případě potřeby lze
určit jeho odlišné umístění):</p>

<pre>
$ <strong>cat /tmp/test.tester-ThinkPad-T410.2019-11-10_19.log </strong>
&nbsp;
Zprava z Go #0
Zprava z Go #1
Zprava z Go #2
Zprava z Go #3
Zprava z Go #4
Zprava z Go #5
Zprava z Go #6
Zprava z Go #7
Zprava z Go #8
Zprava z Go #9
Zprava z Go #10
</pre>

<p><div class="rs-tip-major">Poznámka: můžeme zde vidět, že konzument skutečně
získal všechny zprávy a současně byly všechny zprávy uloženy na disk. To je
většinou přesně to chování, které od systému <i>NSQ</i> při archivaci zpráv
vyžadujeme.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Špatné nastavení archivace</h2>

<p>Pro zajímavost si můžeme otestovat jinou situaci &ndash; jak konzument
zpráv, tak i archivační utilita <strong>nsq_to_file</strong> budou zprávy
odebírat ze stejného kanálu. Systém <i>NSQ</i> by v&nbsp;takovém případě měl
zprávy mezi oba producenty rozdělit, protože z&nbsp;jeho pohledu je i
archivační utilita běžným příjemcem zpráv.</p>

<p>Výsledky po odeslání jedenácti zpráv vypadají následovně.</p>

<p>Konzument:</p>

<pre>
$ <strong>./consumer4_chan_A </strong>
&nbsp;
2019/11/10 19:42:02 INF    1 [test/A] (127.0.0.1:4150) connecting to nsqd
2019/11/10 19:42:02 Waiting for message
2019/11/10 19:42:04 Received a message: Zprava z Go #1
2019/11/10 19:42:06 Received a message: Zprava z Go #3
2019/11/10 19:42:08 Received a message: Zprava z Go #5
2019/11/10 19:42:10 Received a message: Zprava z Go #7
2019/11/10 19:42:12 Received a message: Zprava z Go #9
2019/11/10 19:42:14 Received a message: Zprava z Go #11
</pre>

<p>Utilita pro archivaci zpráv je nyní spuštěna s&nbsp;volbou kanálu A:</p>

<pre>
$ <strong>./nsq_to_file --nsqd-tcp-address=localhost:4150 --topic test --channel A</strong>
&nbsp;
2019/11/10 19:41:58 INF    1 [test/A] (localhost:4150) connecting to nsqd
[nsq_to_file] 2019/11/10 19:42:03.902131 INFO: [test/A] opening /tmp/test.tester-ThinkPad-T410.2019-11-10_19.log
[nsq_to_file] 2019/11/10 19:42:03.902605 INFO: [test/A] syncing 1 records to disk
[nsq_to_file] 2019/11/10 19:42:28.905202 INFO: [test/A] syncing 5 records to disk
</pre>

<p>Obsah souboru, do kterého se archivují zprávy:</p>

<pre>
$ <strong>cat /tmp/test.tester-ThinkPad-T410.2019-11-10_19.log </strong>
&nbsp;
Zprava z Go #0
Zprava z Go #1
Zprava z Go #2
Zprava z Go #3
Zprava z Go #4
Zprava z Go #5
Zprava z Go #6
Zprava z Go #7
Zprava z Go #8
Zprava z Go #9
    ↑
... ↑ původní obsah archivu z předchozího příklad
...
... ↓ nový obsah archivu
    ↓
Zprava z Go #10
Zprava z Go #0
Zprava z Go #2
Zprava z Go #4
Zprava z Go #6
Zprava z Go #8
Zprava z Go #10
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto případě je patrné, že se
zprávy skutečně rozdělily principem <i>round-robin</i> mezi běžného příjemce
zpráv a mezi utilitu <strong>nsq_to_file</strong>. V&nbsp;naprosté většině
případů se nejedná o to chování, které je v&nbsp;praxi vyžadováno. Jediným
důvodem, kdy by tato konfigurace mohla být použita, je situace, kdy nechceme
nezpracované zprávy ponechat v&nbsp;<i>nsqd</i>, ale současně je ani nechceme
ztratit, například tehdy, pokud jsou všichni příjemci zpráv vytížení.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Chování systému ve chvíli, kdy zpráva nemůže být doručena</h2>

<p>V&nbsp;této kapitole si popíšeme chování systému <i>NSQ</i> ve chvíli, kdy
zpráva nemůže být z&nbsp;nějakého důvodu doručena. Systém <i>NSQ</i>
v&nbsp;takové situaci používá dvě techniky nazvané <strong>retry</strong> a
<strong>exponential backoff</strong>. Ve skutečnosti se nejedná o nic
složitého:</p>

<ol>

<li><i>retry</i>: v&nbsp;případě, že dojde na straně konzumenta zpráv k&nbsp;nějaké chybě, informuje o ni (přes příslušnou knihovnu &ndash; rozhraní pro <i>NSQ</i>) službu <i>nsqd</i> příkazem <strong>REQ</strong> neboli <i>re-queue</i>. Podobně pokud služba <i>nsqd</i> nedostane v&nbsp;určeném čase informaci o zpracování zprávy, dojde k&nbsp;timeoutu následovaném opět operací typu <strong>REQ</strong>. Nutno říci, že tento systém trpí všemi nedostatky komunikační strategie <strong>příkaz-ack</strong>, protože konzument ve skutečnosti zprávu mohl korektně zpracovat, ovšem k&nbsp;chybě došlo až při posílání <strong>ack</strong>, tedy při potvrzování, že zpráva byla zpracována. To je jeden z&nbsp;důvodů, proč by měly být producenti zpráv <i>idempotentní</i>, protože jim taková zpráva bude poslána znovu.</li>

<li><i>exponential backoff</i>: pokud není zpráva korektně zpracována v&nbsp;konzumentovi zpráv, bude žádost o další zprávy pozdržena o dobu, která postupně (s&nbsp;dalšími případnými pády) exponenciálně roste. A naopak &ndash; ve chvíli, kdy je nějaká zpráva zpracována korektně, bude se doba mezi příjmem další zprávy postupně (nelineárně) snižovat až na nulu. Díky tomu se (z&nbsp;nějakého důvodu problémový) konzument zpráv v&nbsp;systému postupně zpomaluje a po jeho opravě zase postupně zrychluje. Dává se tím prostor pro další konzumenty, které jsou v&nbsp;korektním stavu &ndash; ty budou zprávy zpracovávat nejrychlejším možným způsobem, což ovšem neznamená, že by se opravený uzel nemohl znovu stát plnohodnotným uzlem v&nbsp;celém systému &ndash; akorát musí svoji funkci zpracovávat zprávy několikrát dokázat.</li>

</ol>

<img src="https://i.iinfo.cz/images/358/nsq2-6-1.png" class="image-396175" alt="&#160;" width="342" height="633" />
<p><i>Obrázek 8: Složitější konfigurace se dvěma kanály.</i></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Důvody vedoucí k&nbsp;využití více služeb <i>nsqd</i></h2>

<p>Všechny předchozí konfigurace systému <i>NSQ</i>, které jsme si popsali,
byly založeny na jediné službě <i>nsqd</i>, ke které se připojovali jak
producenti zpráv, tak i jejich konzumenti (popř.&nbsp;nástroj pro archivaci
zpráv). Konfigurace s&nbsp;jedinou službou <i>nsqd</i> je nejjednodušší a do
značné míry se podobá konfiguraci klasických message brokerů. V&nbsp;praxi je
pochopitelně možné <i>nsqd</i> využívat i tímto způsobem, ovšem musíme se
přitom smířit s&nbsp;tím, že se případný pád či dokonce jen restart služby
<i>nsqd</i> může negativně projevit na činnosti celého systému, a to
z&nbsp;toho důvodu, že message brokeři bývají ústřední částí celého messagingu.
Částečně lze tento problém (alespoň zdánlivě) vyřešit tím, že se v&nbsp;různých
částech systému budou používat odlišné instance message brokerů &ndash; jeden
pro rezervaci zboží, druhý pro vyskladňování atd. Pád/restart jednoho
z&nbsp;těchto message brokerů ovlivní jen určitou část systému (pochopitelně
jen v&nbsp;případě, že zbylé části systému nejsou vnitřně provázány a používají
pro vzájemnou komunikaci jen message broker).</p>

<p>Současně je nutné myslet na to, že může nastat situace, v&nbsp;níž se
<i>NSQ</i> stane úzkým hrdlem celého systému, ať již proto, že nebude mít
dostatečný výkon CPU (nepravděpodobné), nižší propustnost sítě (pravděpodobné)
či nedostatek RAM a diskového prostoru pro meziuložení všech zpracovávaných
zpráv (pravděpodobné). A právě v&nbsp;tomto okamžiku je možné využít
nejzajímavější funkci celého systému <i>NSQ</i> &ndash; schopnost provozovat
větší množství služeb <i>nsqd</i>, které budou buď centrálně spravovány jednou
službou <i>nsqlookupd</i> či v&nbsp;případě potřeby větším množstvím těchto
služeb. Jednotlivé <i>nsqd</i> mohou běžet na jednom počítači (přímo na holém
železe či v&nbsp;kontejneru), v&nbsp;rámci jednoho clusteru či naopak mohou být
navzájem vzdálené (a to i geograficky). A právě některé konfigurace systému
<i>NSQ</i> založené na dvou či více službách <i>nsqd</i> si popíšeme
v&nbsp;navazujících podkapitolách.</p>

<a href="https://www.root.cz/obrazek/396176/"><img src="https://i.iinfo.cz/images/358/nsq2-6-2-prev.png" class="image-396176" alt="&#160;" width="294" height="270" /></a>
<p><i>Obrázek 9: Nepatrně složitější architektura, v&nbsp;níž si klienti
vybírají službu nsqd.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Paralelně a nezávisle na sobě běžící služby <i>nsqd</i></h2>

<p>V&nbsp;navazujících kapitolách použijeme upravený kód producentů i
konzumentů zpráv. Úprava spočívá v&nbsp;tom, že se port pro připojení bude
získávat z&nbsp;parametru předaného na příkazovém řádku.</p>

<p>Upravený producent:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "github.com/nsqio/go-nsq"
        "log"
        "os"
        "time"
)
&nbsp;
const Topic = "test"
&nbsp;
func <strong>main</strong>() {
        if len(os.Args) &lt; 2 {
                log.Panic("nsqd address needs to be specified on CLI")
        }
&nbsp;
        address := os.Args[1]
&nbsp;
        config := nsq.NewConfig()
&nbsp;
        producer, err := nsq.NewProducer(address, config)
        if err != nil {
                log.Panic("Producer can't be constructed")
        }
        defer producer.Stop()
&nbsp;
        i := 0
&nbsp;
        for {
                message := fmt.Sprintf("Zprava z Go #%d", i)
                log.Print("Sending message: ", message)
                err = producer.Publish(Topic, []byte(message))
                if err != nil {
                        log.Panic("Could not connect")
                }
                i++
                time.Sleep(1 * time.Second)
        }
}
</pre>

<p>Upravený konzument:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/nsqio/go-nsq"
        "log"
        "os"
)
&nbsp;
const Topic = "test"
&nbsp;
const Channel = "A"
&nbsp;
func <strong>main</strong>() {
        if len(os.Args) &lt; 2 {
                log.Panic("nsqd address needs to be specified on CLI")
        }
&nbsp;
        address := os.Args[1]
        config := nsq.NewConfig()
&nbsp;
        consumer, err := nsq.NewConsumer(Topic, Channel, config)
        if err != nil {
                log.Panic("Consumer can't be constructed")
        }
&nbsp;
        done := make(chan bool)
&nbsp;
        consumer.AddHandler(nsq.HandlerFunc(func(message *nsq.Message) error {
                log.Printf("Received a message: %s", string(message.Body))
                <i>// done &lt;- true</i>
                return nil
        }))
&nbsp;
        err = consumer.ConnectToNSQD(address)
        if err != nil {
                log.Panic("Could not connect")
        }
&nbsp;
        log.Println("Waiting for message")
        &lt;-done
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Chování dvou nezávislých služeb <i>nsqd</i></h2>

<p>Nejprve se podívejme na situaci, kdy jsou v&nbsp;provozu dvě služby
<i>nsqd</i>, ovšem <i>nsqlookupd</i> není provozována. To tedy znamená, že se
jednotliví producenti zpráv sami rozhodují, ke kterému <i>nsqd</i> se budou
připojovat. Totéž platí i pro konzumenty zpráv. Toto řešení je sice plně
funkční, ovšem konzumenti i producenti zpráv musí znát &bdquo;své&ldquo; služby
<i>nsqd</i> a není zde zajištěn stav, kdy jedna ze služeb <i>nsqd</i> není
(z&nbsp;libovolného důvodu) dostupná:</p>

<p>Chování takto nakonfigurovaného systému si můžeme vyzkoušet, a to velmi
snadno (i na jediném počítači). Postačuje spustit dvě služby <i>nsqd</i>,
každou na jiném portu a ideálně v&nbsp;odlišném terminálu (ve Screenu/Tmuxu
atd.), aby byly vidět zprávy, které služby v&nbsp;průběhu své činnosti
generují:</p>

<pre>
$ <strong>nsqd -tcp-address localhost:4150 -http-address localhost:4151</strong>
$ <strong>nsqd -tcp-address localhost:5150 -http-address localhost:5151 --data-path=/tmp</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že u druhé služby musíme
specifikovat umístění souborů s&nbsp;konfigurací, stavem kanálů a
serializovaných zpráv. Jinak by došlo ke kolizi s&nbsp;již běžící první
službou.</div></p>

<p>Dále spustíme konzumenty zpráv, z&nbsp;nichž první se bude připojovat
k&nbsp;první službě a druhý naopak ke službě druhé:</p>

<pre>
$ <strong>nohup ./consumer5 localhost:4150 &gt; consumer1.log &amp;</strong>
$ <strong>nohup ./consumer5 localhost:5150 &gt; consumer2.log &amp;</strong>
</pre>

<p>Zbývá nám spustit producenty zpráv, jednoho pro první službu (a standardní
topic i kanál), druhého pro službu druhou:</p>

<pre>
$ <strong>nohup ./producer4 localhost:4150 &gt; producer1.log &amp;</strong>
$ <strong>nohup ./producer4 localhost:5150 &gt; producer2.log &amp;</strong>
</pre>

<p>Obě služby <i>nsqd</i> pracují nezávisle na sobě, takže se jedná o dva zcela
nezávislé systémy, které mezi sebou ani nesdílí žádná data. Je to ostatně
patrné i ze zpráv, které jednotlivé prvky systému vypisují do terminálu:</p>

<pre>
$ <strong>cat producer1.log</strong>
&nbsp;
2019/11/12 22:32:45 Sending message: Zprava z Go #0
2019/11/12 22:32:45 INF    1 (localhost:4150) connecting to nsqd
2019/11/12 22:32:46 Sending message: Zprava z Go #1
2019/11/12 22:32:47 Sending message: Zprava z Go #2
2019/11/12 22:32:48 Sending message: Zprava z Go #3
2019/11/12 22:32:49 Sending message: Zprava z Go #4
2019/11/12 22:32:50 Sending message: Zprava z Go #5
2019/11/12 22:32:51 Sending message: Zprava z Go #6
2019/11/12 22:32:52 Sending message: Zprava z Go #7
2019/11/12 22:32:53 Sending message: Zprava z Go #8
</pre>

<pre>
$ <strong>cat producer2.log</strong>
&nbsp;
2019/11/12 22:32:50 Sending message: Zprava z Go #0
2019/11/12 22:32:50 INF    1 (localhost:5150) connecting to nsqd
2019/11/12 22:32:51 Sending message: Zprava z Go #1
2019/11/12 22:32:52 Sending message: Zprava z Go #2
2019/11/12 22:32:53 Sending message: Zprava z Go #3
2019/11/12 22:32:54 Sending message: Zprava z Go #4
2019/11/12 22:32:55 Sending message: Zprava z Go #5
2019/11/12 22:32:56 Sending message: Zprava z Go #6
</pre>

<pre>
$ <strong>cat consumer1.log</strong>
&nbsp;
2019/11/12 22:32:19 INF    1 [test/A] (localhost:4150) connecting to nsqd
2019/11/12 22:32:19 Waiting for message
2019/11/12 22:32:45 Received a message: Zprava z Go #0
2019/11/12 22:32:47 Received a message: Zprava z Go #1
2019/11/12 22:32:50 Received a message: Zprava z Go #2
2019/11/12 22:32:50 Received a message: Zprava z Go #3
2019/11/12 22:32:50 Received a message: Zprava z Go #4
...
...
...
</pre>

<pre>
$ <strong>cat consumer2.log</strong>
&nbsp;
2019/11/12 22:32:19 INF    1 [test/A] (localhost:4150) connecting to nsqd
2019/11/12 22:32:19 Waiting for message
2019/11/12 22:32:45 Received a message: Zprava z Go #0
2019/11/12 22:32:47 Received a message: Zprava z Go #1
2019/11/12 22:32:50 Received a message: Zprava z Go #2
2019/11/12 22:32:50 Received a message: Zprava z Go #3
2019/11/12 22:32:50 Received a message: Zprava z Go #4
...
...
...
</pre>

<p>Na konec nezapomeňte producenty i konzumenty zpráv ukončit:</p>

<pre>
$ <strong>killall consumer5</strong>
$ <strong>killall producer4</strong>
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Konzument zpráv připojený k&nbsp;více službám <i>nsqd</i></h2>

<p>Nyní se můžeme pokusit vytvořit konzumenta, který se dokáže připojit
k&nbsp;více službám <i>nsqd</i> podle obrázku číslo 9. Je to snadné, protože
namísto volání:</p>

<pre>
consumer.ConnectToNSQD(jedna_adresa)
</pre>

<p>můžeme použít funkci:</p>

<pre>
consumer.ConnectToNSQDs([]string{adresa1, adresa2, adresa3...})
</pre>

<p>Zdrojový kód klienta se nepatrně změní, protože se budeme připojovat ke
dvojici služeb <i>nsqd</i>, jejichž adresy se zadávají na příkazovém řádku:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/nsqio/go-nsq"
        "log"
        "os"
)
&nbsp;
const Topic = "test"
&nbsp;
const Channel = "A"
&nbsp;
func <strong>main</strong>() {
        if len(os.Args) &lt; 3 {
                log.Panic("two nsqd addresses needs to be specified on CLI")
        }
&nbsp;
        address1 := os.Args[1]
        address2 := os.Args[2]
        config := nsq.NewConfig()
&nbsp;
        consumer, err := nsq.NewConsumer(Topic, Channel, config)
        if err != nil {
                log.Panic("Consumer can't be constructed")
        }
&nbsp;
        done := make(chan bool)

        consumer.AddHandler(nsq.HandlerFunc(func(message *nsq.Message) error {
                log.Printf("Received a message: %s", string(message.Body))
                <i>// done &lt;- true</i>
                return nil
        }))
&nbsp;
        err = consumer.ConnectToNSQDs([]string{address1, address2})
        if err != nil {
                log.Panic("Could not connect")
        }
&nbsp;
        log.Println("Waiting for message")
        &lt;-done
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Chování dvou nezávislých služeb <i>nsqd</i> s&nbsp;konzumentem připojeným k&nbsp;oběma službám</h2>

<p>Chování klienta (konzumenta zpráv) připojeného ke dvěma službám bude
záviset na tom, zda obě služby běží či nikoli. Na začátku si klient vybere
(například) první službu a bude zpracovávat zprávy, které z&nbsp;této služby
přichází:</p>

<pre>
$ <strong>./consumer6 localhost:4150 localhost:5150</strong>
&nbsp;
2019/11/12 22:57:45 INF    1 [test/A] (localhost:4150) connecting to nsqd
2019/11/12 22:57:45 INF    1 [test/A] (localhost:5150) connecting to nsqd
2019/11/12 22:57:45 Waiting for message
2019/11/12 22:58:03 Received a message: Zprava z Go #0
2019/11/12 22:58:04 Received a message: Zprava z Go #1
2019/11/12 22:58:05 Received a message: Zprava z Go #2
2019/11/12 22:58:06 Received a message: Zprava z Go #3
2019/11/12 22:58:07 Received a message: Zprava z Go #4
2019/11/12 22:58:08 Received a message: Zprava z Go #5
2019/11/12 22:58:09 Received a message: Zprava z Go #6
2019/11/12 22:58:10 Received a message: Zprava z Go #7
2019/11/12 22:58:11 Received a message: Zprava z Go #8
...
...
...
</pre>

<p>Pokud ovšem první službu restartujeme popř.&nbsp;ji ukončíme
(<strong>kill</strong> atd.), připojí se klient ke službě druhé a začne
zpracovávat zprávy, které do ní přichází:</p>

<pre>
2019/11/12 22:58:29 Received a message: Zprava z Go #26
2019/11/12 22:58:30 Received a message: Zprava z Go #27
2019/11/12 22:58:36 ERR    1 [test/A] (localhost:4150) IO error - EOF
2019/11/12 22:58:36 INF    1 [test/A] (localhost:4150) beginning close
2019/11/12 22:58:36 INF    1 [test/A] (localhost:4150) readLoop exiting
2019/11/12 22:58:36 INF    1 [test/A] (localhost:4150) breaking out of writeLoop
2019/11/12 22:58:36 INF    1 [test/A] (localhost:4150) writeLoop exiting
2019/11/12 22:58:36 INF    1 [test/A] (localhost:4150) finished draining, cleanup exiting
2019/11/12 22:58:36 INF    1 [test/A] (localhost:4150) clean close complete
2019/11/12 22:58:36 WRN    1 [test/A] there are 1 connections left alive
2019/11/12 22:58:36 INF    1 [test/A] (localhost:4150) re-connecting in 1m0s
2019/11/12 22:58:40 Received a message: Zprava z Go #0
2019/11/12 22:58:40 Received a message: Zprava z Go #1
2019/11/12 22:58:40 Received a message: Zprava z Go #2
2019/11/12 22:58:40 Received a message: Zprava z Go #3
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si zpráv typu
<strong>ERR</strong>or a <strong>INF</strong>o, které nám oznamují přepnutí na
službu druhou.</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Využití adresářové služby <i>nsqlookupd</i></h2>

<p>Předchozí konfiguraci můžeme ještě upravit, a to spuštěním služby
<i>nsqlookupd</i>, která dokáže sledovat jednotlivé služby <i>nsqd</i> a
poskytovat tyto informace klientům. Tuto službu (běžící na odlišném portu, než
jednotlivé <i>nsqd</i>) spustíme jako první a necháme <i>nsqd</i>, aby se
k&nbsp;ní přihlásily:</p>

<pre>
$ <strong>./nsqlookupd </strong>
&nbsp;
[nsqlookupd] 2019/11/13 20:25:10.392683 INFO: nsqlookupd v1.2.1-alpha (built w/go1.11.2)
[nsqlookupd] 2019/11/13 20:25:10.394993 INFO: TCP: listening on [::]:4160
[nsqlookupd] 2019/11/13 20:25:10.395000 INFO: HTTP: listening on [::]:4161
</pre>

<p>První služba:</p>

<pre>
$ <strong>./nsqd -tcp-address localhost:4150 -http-address localhost:4151 --lookupd-tcp-address=127.0.0.1:4160 -broadcast-address=127.0.0.1</strong>
</pre>

<p>Druhá služba:</p>

<pre>
$ <strong>./nsqd -tcp-address localhost:5150 -http-address localhost:5151 --lookupd-tcp-address=127.0.0.1:4160 -broadcast-address=127.0.0.1 --data-path=/tmp/</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: volbu
<strong>-broadcast-address</strong> je v&nbsp;tomto případě nutné použít, jinak
se klient (konzument) nedokáže k&nbsp;<i>nsqd</i> připojit.</div></p>

<p>Otestujeme, zda obě služby nahlašují svůj stav do adresářové služby:</p>

<pre>
$ <strong>alias pp='python -mjson.tool'</strong>
&nbsp;
$ <strong>curl -s localhost:4161/nodes |pp</strong>
{
    "producers": [
        {
            "broadcast_address": "tester-ThinkPad-T410",
            "hostname": "tester-ThinkPad-T410",
            "http_port": 5151,
            "remote_address": "127.0.0.1:43230",
            "tcp_port": 5150,
            "tombstones": [],
            "topics": [],
            "version": "1.2.1-alpha"
        },
        {
            "broadcast_address": "tester-ThinkPad-T410",
            "hostname": "tester-ThinkPad-T410",
            "http_port": 4151,
            "remote_address": "127.0.0.1:43231",
            "tcp_port": 4150,
            "tombstones": [],
            "topics": [],
            "version": "1.2.1-alpha"
        }
    ]
}
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Úprava klienta (konzumenta) pro použití <i>nsqlookupd</i></h2>

<p>Jak se tato změna dotkne klientů, kteří spolu potřebují komunikovat pomocí
zpráv? Klienty je možné upravit takovým způsobem, aby se zeptaly služby
<i>nsqlookupd</i>, na kterou konkrétní službu <i>nsqd</i> se mají připojit.
Pokud by došlo k&nbsp;restartu či dokonce k&nbsp;pádu (odpojení) některé
<i>nsqd</i>, mohou se klienti připojit k&nbsp;jiné službě (což ovšem neznamená,
že nemůže dojít k&nbsp;tomu, že některé zprávy dojdou až po opětovném spuštění
dané <i>nsqd</i>). Konzumenta upravíme snadno, ostatně podobný zdrojový kód
jsme již viděli v&nbsp;předchozí části tohoto seriálu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/nsqio/go-nsq"
        "log"
)
&nbsp;
const Topic = "test"
&nbsp;
const Channel = "A"
&nbsp;
func <strong>main</strong>() {
        config := nsq.NewConfig()
&nbsp;
        consumer, err := nsq.NewConsumer(Topic, Channel, config)
        if err != nil {
                log.Panic("Consumer can't be constructed")
        }
&nbsp;
        done := make(chan bool)
&nbsp;
        consumer.AddHandler(nsq.HandlerFunc(func(message *nsq.Message) error {
                log.Printf("Received a message: %s", string(message.Body))
                return nil
        }))
&nbsp;
        err = <strong>consumer.ConnectToNSQLookupd("127.0.0.1:4161")</strong>
        if err != nil {
                log.Panic("Could not connect")
        }
        defer <strong>consumer.DisconnectFromNSQLookupd("127.0.0.1:4160")</strong>
&nbsp;
        log.Println("Waiting for message")
        &lt;-done
}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Otestování chování klienta</h2>

<p>Nového klienta můžeme otestovat velmi snadno. V&nbsp;dalším výpisu je
ukázána situace, kdy se první služba odpoví (havaruje) a namísto ní se začnou
zpracovávat zprávy ze služby druhé:</p>

<pre>
2019/11/13 20:43:00 Received a message: Zprava z Go #17
2019/11/13 20:43:01 Received a message: Zprava z Go #18
2019/11/13 20:43:02 Received a message: Zprava z Go #19
2019/11/13 20:43:03 Received a message: Zprava z Go #20
2019/11/13 20:43:04 Received a message: Zprava z Go #21
2019/11/13 20:43:04 ERR    1 [test/A] (127.0.0.1:4150) IO error - EOF
2019/11/13 20:43:04 INF    1 [test/A] (127.0.0.1:4150) beginning close
2019/11/13 20:43:04 INF    1 [test/A] (127.0.0.1:4150) readLoop exiting
2019/11/13 20:43:04 INF    1 [test/A] (127.0.0.1:4150) breaking out of writeLoop
2019/11/13 20:43:04 INF    1 [test/A] (127.0.0.1:4150) writeLoop exiting
2019/11/13 20:43:04 INF    1 [test/A] (127.0.0.1:4150) finished draining, cleanup exiting
2019/11/13 20:43:04 INF    1 [test/A] (127.0.0.1:4150) clean close complete
2019/11/13 20:43:04 WRN    1 [test/A] there are 1 connections left alive
2019/11/13 20:43:04 INF    1 [test/A] querying nsqlookupd http://127.0.0.1:4161/lookup?topic=test
2019/11/13 20:43:05 Received a message: Zprava z Go #0
2019/11/13 20:43:05 Received a message: Zprava z Go #1
2019/11/13 20:43:05 Received a message: Zprava z Go #2
2019/11/13 20:43:05 Received a message: Zprava z Go #3
2019/11/13 20:43:05 Received a message: Zprava z Go #4
2019/11/13 20:43:05 Received a message: Zprava z Go #5
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Konzument současně přijímající zprávy z&nbsp;více služeb <i>nsqd</i></h2>

<p>V&nbsp;případě, že je nutné přijímat zprávy (a to současně) z&nbsp;více
služeb <i>nsqd</i>, musí se kód konzumenta nepatrně upravit takovým způsobem,
aby byl handler (pro příjem zpráv) skutečně zaregistrován pro všechny služby
<i>nsqd</i>. Jednoduché řešení (které ovšem nepočítá s&nbsp;pádem služby) může
vypadat následovně:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/nsqio/go-nsq"
        "log"
        "os"
)
&nbsp;
const Topic = "test"
&nbsp;
const Channel = "A"
&nbsp;
func <strong>main</strong>() {
        if len(os.Args) &lt; 3 {
                log.Panic("two nsqd addresses needs to be specified on CLI")
        }
&nbsp;
        config := nsq.NewConfig()
&nbsp;
        for i := 0; i &lt;= 1; i++ {
                consumer, err := nsq.NewConsumer(Topic, Channel, config)
                if err != nil {
                        log.Panic("Consumer can't be constructed")
                }
                consumer.AddHandler(nsq.HandlerFunc(func(message *nsq.Message) error {
                        log.Printf("Received a message from nsqd #%d: %s", i+1, string(message.Body))
                        return nil
                }))
                err = consumer.ConnectToNSQD(os.Args[i+1])
                if err != nil {
                        log.Panicf("Could not connect to nsqd #%d", i)
                }
        }
&nbsp;
        log.Println("Waiting for message")
        done := make(chan bool)
&nbsp;
        &lt;-done
}
</pre>

<p>Po spuštění konzumenta (a dvou producentů) lze snadno zjistit, že konzument
skutečně přijímá zprávy z&nbsp;obou služeb <i>nsqd</i>:</p>

<pre>
$ <strong>./consumer7 localhost:4150 localhost:5150</strong>
&nbsp;
2019/11/13 20:55:34 INF    1 [test/A] (localhost:4150) connecting to nsqd
2019/11/13 20:55:34 INF    2 [test/A] (localhost:5150) connecting to nsqd
2019/11/13 20:55:34 Waiting for message
2019/11/13 20:55:36 Received a message from nsqd #3: Zprava z Go #0
2019/11/13 20:55:37 Received a message from nsqd #3: Zprava z Go #1
2019/11/13 20:55:37 Received a message from nsqd #3: Zprava z Go #0
2019/11/13 20:55:38 Received a message from nsqd #3: Zprava z Go #2
2019/11/13 20:55:38 Received a message from nsqd #3: Zprava z Go #1
2019/11/13 20:55:39 Received a message from nsqd #3: Zprava z Go #3
2019/11/13 20:55:39 Received a message from nsqd #3: Zprava z Go #2
2019/11/13 20:55:40 Received a message from nsqd #3: Zprava z Go #4
2019/11/13 20:55:40 Received a message from nsqd #3: Zprava z Go #3
2019/11/13 20:55:41 Received a message from nsqd #3: Zprava z Go #5
2019/11/13 20:55:41 Received a message from nsqd #3: Zprava z Go #4
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů vyvinutých
v&nbsp;programovacím jazyku Go byly uloženy do Git repositáře, který je
dostupný na adrese <a
href="https://github.com/tisnik/message-queues-examples">https://github.com/tisnik/message-queues-examples</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
stále ještě doslova několik kilobajtů), můžete namísto toho použít odkazy na
jednotlivé příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th>Příklad</th><th>Skript</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td>1</td><td>producer3.go</td><td>producent sekvence zpráv naprogramovaný v&nbsp;jazyce Go s&nbsp;blokem <strong>defer</strong></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nsq/producer3.go">https://github.com/tisnik/message-queues-examples/blob/master/nsq/producer3.go</a></td></tr>
<tr><td>2</td><td>producer3B.go</td><td>producent sekvence zpráv s&nbsp;jiným obsahem naprogramovaný taktéž v&nbsp;jazyce Go s&nbsp;blokem <strong>defer</strong></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nsq/producer3B.go">https://github.com/tisnik/message-queues-examples/blob/master/nsq/producer3B.go</a></td></tr>
<tr><td>3</td><td>producer3C.go</td><td>rychlejší posílání zpráv</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nsq/producer3C.go">https://github.com/tisnik/message-queues-examples/blob/master/nsq/producer3C.go</a></td></tr>
<tr><td>4</td><td>producer4.go</td><td>producent se specifikací adresy <i>nsqd</i></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nsq/producer4.go">https://github.com/tisnik/message-queues-examples/blob/master/nsq/producer4.go</a></td></tr>
<tr><td>5</td><td>consumer4_chan_A.go</td><td>konzument naprogramovaný v&nbsp;Go, který zpracuje všechny jemu dostupné zprávy (kanál A)</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nsq/consumer4_chan_A.go">https://github.com/tisnik/message-queues-examples/blob/master/nsq/consumer4_chan_A.go</a></td></tr>
<tr><td>6</td><td>consumer4_chan_B.go</td><td>konzument naprogramovaný v&nbsp;Go, který zpracuje všechny jemu dostupné zprávy (kanál B)</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nsq/consumer4_chan_B.go">https://github.com/tisnik/message-queues-examples/blob/master/nsq/consumer4_chan_B.go</a></td></tr>
<tr><td>7</td><td>consumer5.go</td><td>konzument se specifikací adresy <i>nsqd</i></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nsq/consumer5.go">https://github.com/tisnik/message-queues-examples/blob/master/nsq/consumer5.go</a></td></tr>
<tr><td>8</td><td>consumer6.go</td><td>konzument připojený k&nbsp;více službám <i>nsqd</i>, vybírá vždy zprávy z&nbsp;jediné služby</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nsq/consumer6.go">https://github.com/tisnik/message-queues-examples/blob/master/nsq/consumer6.go</a></td></tr>
<tr><td>9</td><td>consumer7.go</td><td>konzument připojený k&nbsp;více službám <i>nsqd</i> a přijímající současně zprávy z&nbsp;obou služeb</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nsq/consumer7.go">https://github.com/tisnik/message-queues-examples/blob/master/nsq/consumer7.go</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Stránka projektu NSQ<br />
<a href="https://nsq.io/">https://nsq.io/</a>
</li>

<li>Dokumentace k&nbsp;projektu NSQ<br />
<a href="https://nsq.io/overview/design.html">https://nsq.io/overview/design.html</a>
</li>

<li>Dokumentace ke klientovi pro Go<br />
<a href="https://godoc.org/github.com/nsqio/go-nsq">https://godoc.org/github.com/nsqio/go-nsq</a>
</li>

<li>Dokumentace ke klientovi pro Python<br />
<a href="https://pynsq.readthedocs.io/en/latest/">https://pynsq.readthedocs.io/en/latest/</a>
</li>

<li>Binární tarbally s&nbsp;NSQ<br />
<a href="https://nsq.io/deployment/installing.html">https://nsq.io/deployment/installing.html</a>
</li>

<li>GitHub repositář projektu NSQ<br />
<a href="https://github.com/nsqio/nsq">https://github.com/nsqio/nsq</a>
</li>

<li>Klienti pro NSQ<br />
<a href="https://nsq.io/clients/client_libraries.html">https://nsq.io/clients/client_libraries.html</a>
</li>

<li>Klient pro Go<br />
<a href="https://github.com/nsqio/go-nsq">https://github.com/nsqio/go-nsq</a>
</li>

<li>Klient pro Python<br />
<a href="https://github.com/nsqio/pynsq">https://github.com/nsqio/pynsq</a>
</li>

<li>An Example of Using NSQ From Go<br />
<a href="http://tleyden.github.io/blog/2014/11/12/an-example-of-using-nsq-from-go/">http://tleyden.github.io/blog/2014/11/12/an-example-of-using-nsq-from-go/</a>
</li>

<li>Go Go Gadget<br />
<a href="https://word.bitly.com/post/29550171827/go-go-gadget">https://word.bitly.com/post/29550171827/go-go-gadget</a>
</li>

<li>Simplehttp<br />
<a href="https://github.com/bitly/simplehttp">https://github.com/bitly/simplehttp</a>
</li>

<li>Dramatiq: simple task processing<br />
<a href="https://dramatiq.io/">https://dramatiq.io/</a>
</li>

<li>Cookbook (for Dramatiq)<br />
<a href="https://dramatiq.io/cookbook.html">https://dramatiq.io/cookbook.html</a>
</li>

<li>Balíček dramatiq na PyPi<br />
<a href="https://pypi.org/project/dramatiq/">https://pypi.org/project/dramatiq/</a>
</li>

<li>Dramatiq dashboard<br />
<a href="https://github.com/Bogdanp/dramatiq_dashboard">https://github.com/Bogdanp/dramatiq_dashboard</a>
</li>

<li>Dramatiq na Redditu<br />
<a href="https://www.reddit.com/r/dramatiq/">https://www.reddit.com/r/dramatiq/</a>
</li>

<li>A Dramatiq broker that can be used with Amazon SQS<br />
<a href="https://github.com/Bogdanp/dramatiq_sqs">https://github.com/Bogdanp/dramatiq_sqs</a>
</li>

<li>nanomsg na GitHubu<br />
<a href="https://github.com/nanomsg/nanomsg">https://github.com/nanomsg/nanomsg</a>
</li>

<li>Referenční příručka knihovny <strong>nanomsg</strong><br />
<a href="https://nanomsg.org/v1.1.5/nanomsg.html">https://nanomsg.org/v1.1.5/nanomsg.html</a>
</li>

<li>nng (nanomsg-next-generation)<br />
<a href="https://github.com/nanomsg/nng">https://github.com/nanomsg/nng</a>
</li>

<li>Differences between nanomsg and ZeroMQ<br />
<a href="https://nanomsg.org/documentation-zeromq.html">https://nanomsg.org/documentation-zeromq.html</a>
</li>

<li>NATS<br />
<a href="https://nats.io/about/">https://nats.io/about/</a>
</li>

<li>NATS Streaming Concepts<br />
<a href="https://nats.io/documentation/streaming/nats-streaming-intro/">https://nats.io/documentation/streaming/nats-streaming-intro/</a>
</li>

<li>NATS Streaming Server<br />
<a href="https://nats.io/download/nats-io/nats-streaming-server/">https://nats.io/download/nats-io/nats-streaming-server/</a>
</li>

<li>NATS Introduction<br />
<a href="https://nats.io/documentation/">https://nats.io/documentation/</a>
</li>

<li>NATS Client Protocol<br />
<a href="https://nats.io/documentation/internals/nats-protocol/">https://nats.io/documentation/internals/nats-protocol/</a>
</li>

<li>NATS Messaging (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/NATS_Messaging">https://en.wikipedia.org/wiki/NATS_Messaging</a>
</li>

<li>Stránka Apache Software Foundation<br />
<a href="http://www.apache.org/">http://www.apache.org/</a>
</li>

<li>Informace o portu 5672<br />
<a href="http://www.tcp-udp-ports.com/port-5672.htm">http://www.tcp-udp-ports.com/port-5672.htm</a>
</li>

<li>Třída MessagingHandler knihovny Qpid Proton<br />
<a href="https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._handlers.MessagingHandler-class.html">https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._handlers.MessagingHandler-class.html</a>
</li>

<li>Třída Event knihovny Qpid Proton<br />
<a href="https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._events.Event-class.html">https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._events.Event-class.html</a>
</li>

<li>package stomp (Go)<br />
<a href="https://godoc.org/github.com/go-stomp/stomp">https://godoc.org/github.com/go-stomp/stomp</a>
</li>

<li>Go language library for STOMP protocol<br />
<a href="https://github.com/go-stomp/stomp">https://github.com/go-stomp/stomp</a>
</li>

<li>python-qpid-proton 0.26.0 na PyPi<br />
<a href="https://pypi.org/project/python-qpid-proton/">https://pypi.org/project/python-qpid-proton/</a>
</li>

<li>Qpid Proton<br />
<a href="http://qpid.apache.org/proton/">http://qpid.apache.org/proton/</a>
</li>

<li>Using the AMQ Python Client<br />
<a href="https://access.redhat.com/documentation/en-us/red_hat_amq/7.1/html-single/using_the_amq_python_client/">https://access.redhat.com/documentation/en-us/red_hat_amq/7.1/html-single/using_the_amq_python_client/</a>
</li>

<li>Apache ActiveMQ<br />
<a href="http://activemq.apache.org/">http://activemq.apache.org/</a>
</li>

<li>Apache ActiveMQ Artemis<br />
<a href="https://activemq.apache.org/artemis/">https://activemq.apache.org/artemis/</a>
</li>

<li>Apache ActiveMQ Artemis User Manual<br />
<a href="https://activemq.apache.org/artemis/docs/latest/index.html">https://activemq.apache.org/artemis/docs/latest/index.html</a>
</li>

<li>KahaDB<br />
<a href="http://activemq.apache.org/kahadb.html">http://activemq.apache.org/kahadb.html</a>
</li>

<li>Understanding the KahaDB Message Store<br />
<a href="https://access.redhat.com/documentation/en-US/Fuse_MQ_Enterprise/7.1/html/Configuring_Broker_Persistence/files/KahaDBOverview.html">https://access.redhat.com/documentation/en-US/Fuse_MQ_Enterprise/7.1/html/Configuring_Broker_Persistence/files/KahaDBOverview.html</a>
</li>

<li>Command Line Tools (Apache ActiveMQ)<br />
<a href="https://activemq.apache.org/activemq-command-line-tools-reference.html">https://activemq.apache.org/activemq-command-line-tools-reference.html</a>
</li>

<li>stomp.py 4.1.21 na PyPi<br />
<a href="https://pypi.org/project/stomp.py/">https://pypi.org/project/stomp.py/</a>
</li>

<li>Stomp Tutorial<br />
<a href="https://access.redhat.com/documentation/en-US/Fuse_Message_Broker/5.5/html/Connectivity_Guide/files/FMBConnectivityStompTelnet.html">https://access.redhat.com/documentation/en-US/Fuse_Message_Broker/5.5/html/Connectivity_Guide/files/FMBConnectivityStompTelnet.html</a>
</li>

<li>Heartbeat (computing)<br />
<a href="https://en.wikipedia.org/wiki/Heartbeat_(computing)">https://en.wikipedia.org/wiki/Heartbeat_(computing)</a>
</li>

<li>Apache Camel<br />
<a href="https://camel.apache.org/">https://camel.apache.org/</a>
</li>

<li>Red Hat Fuse<br />
<a href="https://developers.redhat.com/products/fuse/overview/">https://developers.redhat.com/products/fuse/overview/</a>
</li>

<li>Confusion between ActiveMQ and ActiveMQ-Artemis?<br />
<a href="https://serverfault.com/questions/873533/confusion-between-activemq-and-activemq-artemis">https://serverfault.com/questions/873533/confusion-between-activemq-and-activemq-artemis</a>
</li>

<li>Staré stránky projektu HornetQ<br />
<a href="http://hornetq.jboss.org/">http://hornetq.jboss.org/</a>
</li>

<li>Snapshot JeroMQ verze 0.4.4<br />
<a href="https://oss.sonatype.org/content/repositories/snapshots/org/zeromq/jeromq/0.4.4-SNAPSHOT/">https://oss.sonatype.org/content/repositories/snapshots/org/zeromq/jeromq/0.4.4-SNAPSHOT/</a>
</li>

<li>Difference between ActiveMQ vs Apache ActiveMQ Artemis<br />
<a href="http://activemq.2283324.n4.nabble.com/Difference-between-ActiveMQ-vs-Apache-ActiveMQ-Artemis-td4703828.html">http://activemq.2283324.n4.nabble.com/Difference-between-ActiveMQ-vs-Apache-ActiveMQ-Artemis-td4703828.html</a>
</li>

<li>Microservices communications. Why you should switch to message queues<br />
<a href="https://dev.to/matteojoliveau/microservices-communications-why-you-should-switch-to-message-queues--48ia">https://dev.to/matteojoliveau/microservices-communications-why-you-should-switch-to-message-queues--48ia</a>
</li>

<li>Stomp.py 4.1.19 documentation<br />
<a href="https://stomppy.readthedocs.io/en/stable/">https://stomppy.readthedocs.io/en/stable/</a>
</li>

<li>Repositář knihovny JeroMQ<br />
<a href="https://github.com/zeromq/jeromq/">https://github.com/zeromq/jeromq/</a>
</li>

<li>ØMQ &ndash; Distributed Messaging <br />
<a href="http://zeromq.org/">http://zeromq.org/</a>
</li>

<li>ØMQ Community<br />
<a href="http://zeromq.org/community">http://zeromq.org/community</a>
</li>

<li>Get The Software<br />
<a href="http://zeromq.org/intro:get-the-software">http://zeromq.org/intro:get-the-software</a>
</li>

<li>PyZMQ Documentation<br />
<a href="https://pyzmq.readthedocs.io/en/latest/">https://pyzmq.readthedocs.io/en/latest/</a>
</li>

<li>Module: zmq.decorators<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.decorators.html">https://pyzmq.readthedocs.io/en/latest/api/zmq.decorators.html</a>
</li>

<li>ZeroMQ is the answer, by Ian Barber<br />
<a href="https://vimeo.com/20605470">https://vimeo.com/20605470</a>
</li>

<li>ZeroMQ RFC<br />
<a href="https://rfc.zeromq.org/">https://rfc.zeromq.org/</a>
</li>

<li>ZeroMQ and Clojure, a brief introduction<br />
<a href="https://antoniogarrote.wordpress.com/2010/09/08/zeromq-and-clojure-a-brief-introduction/">https://antoniogarrote.wordpress.com/2010/09/08/zeromq-and-clojure-a-brief-introduction/</a>
</li>

<li>zeromq/czmq<br />
<a href="https://github.com/zeromq/czmq">https://github.com/zeromq/czmq</a>
</li>

<li>golang wrapper for CZMQ<br />
<a href="https://github.com/zeromq/goczmq">https://github.com/zeromq/goczmq</a>
</li>

<li>ZeroMQ version reporting in Python<br />
<a href="http://zguide.zeromq.org/py:version">http://zguide.zeromq.org/py:version</a>
</li>

<li>A Go interface to ZeroMQ version 4<br />
<a href="https://github.com/pebbe/zmq4">https://github.com/pebbe/zmq4</a>
</li>

<li>Broker vs. Brokerless<br />
<a href="http://zeromq.org/whitepapers:brokerless">http://zeromq.org/whitepapers:brokerless</a>
</li>

<li>Learning ØMQ with pyzmq<br />
<a href="https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/">https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/</a>
</li>

<li>Céčková funkce <strong>zmq_ctx_new</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-ctx-new">http://api.zeromq.org/4-2:zmq-ctx-new</a>
</li>

<li>Céčková funkce <strong>zmq_ctx_destroy</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-ctx-destroy">http://api.zeromq.org/4-2:zmq-ctx-destroy</a>
</li>

<li>Céčková funkce <strong>zmq_bind</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-bind">http://api.zeromq.org/4-2:zmq-bind</a>
</li>

<li>Céčková funkce <strong>zmq_unbind</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-unbind">http://api.zeromq.org/4-2:zmq-unbind</a>
</li>

<li>Céčková C funkce <strong>zmq_connect</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-connect">http://api.zeromq.org/4-2:zmq-connect</a>
</li>

<li>Céčková C funkce <strong>zmq_disconnect</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-disconnect">http://api.zeromq.org/4-2:zmq-disconnect</a>
</li>

<li>Céčková C funkce <strong>zmq_send</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-send">http://api.zeromq.org/4-2:zmq-send</a>
</li>

<li>Céčková C funkce <strong>zmq_recv</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-recv">http://api.zeromq.org/4-2:zmq-recv</a>
</li>

<li>Třída <strong>Context</strong> (Python)<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.html#context">https://pyzmq.readthedocs.io/en/latest/api/zmq.html#context</a>
</li>

<li>Třída <strong>Socket</strong> (Python)<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.html#socket">https://pyzmq.readthedocs.io/en/latest/api/zmq.html#socket</a>
</li>

<li>Python binding<br />
<a href="http://zeromq.org/bindings:python">http://zeromq.org/bindings:python</a>
</li>

<li>Why should I have written ZeroMQ in C, not C++ (part I)<br />
<a href="http://250bpm.com/blog:4">http://250bpm.com/blog:4</a>
</li>

<li>Why should I have written ZeroMQ in C, not C++ (part II) <br />
<a href="http://250bpm.com/blog:8">http://250bpm.com/blog:8</a>
</li>

<li>About Nanomsg<br />
<a href="https://nanomsg.org/">https://nanomsg.org/</a>
</li>

<li>Advanced Message Queuing Protocol<br />
<a href="https://www.amqp.org/">https://www.amqp.org/</a>
</li>

<li>Advanced Message Queuing Protocol na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol">https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol</a>
</li>

<li>Dokumentace k&nbsp;příkazu <strong>rabbitmqctl</strong><br />
<a href="https://www.rabbitmq.com/rabbitmqctl.8.html">https://www.rabbitmq.com/rabbitmqctl.8.html</a>
</li>

<li>RabbitMQ<br />
<a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a>
</li>

<li>RabbitMQ Tutorials<br />
<a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a>
</li>

<li>RabbitMQ: Clients and Developer Tools<br />
<a href="https://www.rabbitmq.com/devtools.html">https://www.rabbitmq.com/devtools.html</a>
</li>

<li>RabbitMQ na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/RabbitMQ">https://en.wikipedia.org/wiki/RabbitMQ</a>
</li>

<li>Streaming Text Oriented Messaging Protocol<br />
<a href="https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol">https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol</a>
</li>

<li>Message Queuing Telemetry Transport<br />
<a href="https://en.wikipedia.org/wiki/MQTT">https://en.wikipedia.org/wiki/MQTT</a>
</li>

<li>Erlang<br />
<a href="http://www.erlang.org/">http://www.erlang.org/</a>
</li>

<li>pika 0.12.0 na PyPi<br />
<a href="https://pypi.org/project/pika/">https://pypi.org/project/pika/</a>
</li>

<li>Introduction to Pika<br />
<a href="https://pika.readthedocs.io/en/stable/">https://pika.readthedocs.io/en/stable/</a>
</li>

<li>Langohr: An idiomatic Clojure client for RabbitMQ that embraces the AMQP 0.9.1 model<br />
<a href="http://clojurerabbitmq.info/">http://clojurerabbitmq.info/</a>
</li>

<li>AMQP 0-9-1 Model Explained<br />
<a href="http://www.rabbitmq.com/tutorials/amqp-concepts.html">http://www.rabbitmq.com/tutorials/amqp-concepts.html</a>
</li>

<li>Part 1: RabbitMQ for beginners - What is RabbitMQ?<br />
<a href="https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html">https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html</a>
</li>

<li>Downloading and Installing RabbitMQ<br />
<a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a>
</li>

<li>celery na PyPi<br />
<a href="https://pypi.org/project/celery/">https://pypi.org/project/celery/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python <br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python (dokončení)<br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/</a>
</li>

<li>Redis Queue (RQ)<br />
<a href="https://www.fullstackpython.com/redis-queue-rq.html">https://www.fullstackpython.com/redis-queue-rq.html</a>
</li>

<li>Python Celery &amp; RabbitMQ Tutorial<br />
<a href="https://tests4geeks.com/python-celery-rabbitmq-tutorial/">https://tests4geeks.com/python-celery-rabbitmq-tutorial/</a>
</li>

<li>Flower: Real-time Celery web-monitor<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor">http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor</a>
</li>

<li>Asynchronous Tasks With Django and Celery<br />
<a href="https://realpython.com/asynchronous-tasks-with-django-and-celery/">https://realpython.com/asynchronous-tasks-with-django-and-celery/</a>
</li>

<li>First Steps with Celery<br />
<a href="http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html">http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html</a>
</li>

<li>node-celery<br />
<a href="https://github.com/mher/node-celery">https://github.com/mher/node-celery</a>
</li>

<li>Full Stack Python: web development<br />
<a href="https://www.fullstackpython.com/web-development.html">https://www.fullstackpython.com/web-development.html</a>
</li>

<li>Introducing RQ<br />
<a href="https://nvie.com/posts/introducing-rq/">https://nvie.com/posts/introducing-rq/</a>
</li>

<li>Asynchronous Tasks with Flask and Redis Queue<br />
<a href="https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue">https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Stránky projektu Redis<br />
<a href="https://redis.io/">https://redis.io/</a>
</li>

<li>Introduction to Redis<br />
<a href="https://redis.io/topics/introduction">https://redis.io/topics/introduction</a>
</li>

<li>Try Redis<br />
<a href="http://try.redis.io/">http://try.redis.io/</a>
</li>

<li>Redis tutorial, April 2010 (starší, ale pěkně udělaný)<br />
<a href="https://static.simonwillison.net/static/2010/redis-tutorial/">https://static.simonwillison.net/static/2010/redis-tutorial/</a>
</li>

<li>Python Redis<br />
<a href="https://redislabs.com/lp/python-redis/">https://redislabs.com/lp/python-redis/</a>
</li>

<li>Redis: key-value databáze v paměti i na disku<br />
<a href="https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/">https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/</a>
</li>

<li>Praktický úvod do Redis (1): vaše distribuovaná NoSQL cache<br />
<a href="http://www.cloudsvet.cz/?p=253">http://www.cloudsvet.cz/?p=253</a>
</li>

<li>Praktický úvod do Redis (2): transakce<br />
<a href="http://www.cloudsvet.cz/?p=256">http://www.cloudsvet.cz/?p=256</a>
</li>

<li>Praktický úvod do Redis (3): cluster<br />
<a href="http://www.cloudsvet.cz/?p=258">http://www.cloudsvet.cz/?p=258</a>
</li>

<li>Connection pool<br />
<a href="https://en.wikipedia.org/wiki/Connection_pool">https://en.wikipedia.org/wiki/Connection_pool</a>
</li>

<li>Instant Redis Sentinel Setup<br />
<a href="https://github.com/ServiceStack/redis-config">https://github.com/ServiceStack/redis-config</a>
</li>

<li>How to install REDIS in LInux<br />
<a href="https://linuxtechlab.com/how-install-redis-server-linux/">https://linuxtechlab.com/how-install-redis-server-linux/</a>
</li>

<li>Redis RDB Dump File Format<br />
<a href="https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format">https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format</a>
</li>

<li>Lempel–Ziv–Welch<br />
<a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch">https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch</a>
</li>

<li>Redis Persistence<br />
<a href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a>
</li>

<li>Redis persistence demystified<br />
<a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html">http://oldblog.antirez.com/post/redis-persistence-demystified.html</a>
</li>

<li>Redis reliable queues with Lua scripting<br />
<a href="http://oldblog.antirez.com/post/250">http://oldblog.antirez.com/post/250</a>
</li>

<li>Ost (knihovna)<br />
<a href="https://github.com/soveran/ost">https://github.com/soveran/ost</a>
</li>

<li>NoSQL<br />
<a href="https://en.wikipedia.org/wiki/NoSQL">https://en.wikipedia.org/wiki/NoSQL</a>
</li>

<li>Shard (database architecture)<br />
<a href="https://en.wikipedia.org/wiki/Shard_%28database_architecture%29">https://en.wikipedia.org/wiki/Shard_%28database_architecture%29</a>
</li>

<li>What is sharding and why is it important?<br />
<a href="https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important">https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important</a>
</li>

<li>What Is Sharding?<br />
<a href="https://btcmanager.com/what-sharding/">https://btcmanager.com/what-sharding/</a>
</li>

<li>Redis clients<br />
<a href="https://redis.io/clients">https://redis.io/clients</a>
</li>

<li>Category:Lua-scriptable software<br />
<a href="https://en.wikipedia.org/wiki/Category:Lua-scriptable_software">https://en.wikipedia.org/wiki/Category:Lua-scriptable_software</a>
</li>

<li>Seriál Programovací jazyk Lua<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-lua/">https://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>Redis memory usage<br />
<a href="http://nosql.mypopescu.com/post/1010844204/redis-memory-usage">http://nosql.mypopescu.com/post/1010844204/redis-memory-usage</a>
</li>

<li>Ukázka konfigurace Redisu pro lokální testování<br />
<a href="https://github.com/tisnik/presentations/blob/master/redis/redis.conf">https://github.com/tisnik/presentations/blob/master/redis/redis.conf</a>
</li>

<li>Resque<br />
<a href="https://github.com/resque/resque">https://github.com/resque/resque</a>
</li>

<li>Nested transaction<br />
<a href="https://en.wikipedia.org/wiki/Nested_transaction">https://en.wikipedia.org/wiki/Nested_transaction</a>
</li>

<li>Publish–subscribe pattern<br />
<a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern</a>
</li>

<li>Messaging pattern<br />
<a href="https://en.wikipedia.org/wiki/Messaging_pattern">https://en.wikipedia.org/wiki/Messaging_pattern</a>
</li>

<li>Using pipelining to speedup Redis queries<br />
<a href="https://redis.io/topics/pipelining">https://redis.io/topics/pipelining</a>
</li>

<li>Pub/Sub<br />
<a href="https://redis.io/topics/pubsub">https://redis.io/topics/pubsub</a>
</li>

<li>ZeroMQ distributed messaging<br />
<a href="http://zeromq.org/">http://zeromq.org/</a>
</li>

<li>ZeroMQ: Modern &amp; Fast Networking Stack<br />
<a href="https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/">https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/</a>
</li>

<li>Publish/Subscribe paradigm: Why must message classes not know about their subscribers?<br />
<a href="https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr">https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr</a>
</li>

<li>Python &amp; Redis PUB/SUB<br />
<a href="https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7">https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7</a>
</li>

<li>Message broker<br />
<a href="https://en.wikipedia.org/wiki/Message_broker">https://en.wikipedia.org/wiki/Message_broker</a>
</li>

<li>RESP Arrays<br />
<a href="https://redis.io/topics/protocol#array-reply">https://redis.io/topics/protocol#array-reply</a>
</li>

<li>Redis Protocol specification<br />
<a href="https://redis.io/topics/protocol">https://redis.io/topics/protocol</a>
</li>

<li>Redis Pub/Sub: Intro Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-intro/">https://www.redisgreen.net/blog/pubsub-intro/</a>
</li>

<li>Redis Pub/Sub: Howto Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-howto/">https://www.redisgreen.net/blog/pubsub-howto/</a>
</li>

<li>Comparing Publish-Subscribe Messaging and Message Queuing<br />
<a href="https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message">https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message</a>
</li>

<li>Apache Kafka<br />
<a href="https://kafka.apache.org/">https://kafka.apache.org/</a>
</li>

<li>Iron<br />
<a href="http://www.iron.io/mq">http://www.iron.io/mq</a>
</li>

<li>kue (založeno na Redisu, určeno pro node.js)<br />
<a href="https://github.com/Automattic/kue">https://github.com/Automattic/kue</a>
</li>

<li>Cloud Pub/Sub<br />
<a href="https://cloud.google.com/pubsub/">https://cloud.google.com/pubsub/</a>
</li>

<li>Introduction to Redis Streams<br />
<a href="https://redis.io/topics/streams-intro">https://redis.io/topics/streams-intro</a>
</li>

<li>glob (programming)<br />
<a href="https://en.wikipedia.org/wiki/Glob_(programming)">https://en.wikipedia.org/wiki/Glob_(programming)</a>
</li>

<li>Why and how Pricing Assistant migrated from Celery to RQ - Paris.py<br />
<a href="https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2">https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2</a>
</li>

<li>Enqueueing internals<br />
<a href="http://python-rq.org/contrib/">http://python-rq.org/contrib/</a>
</li>

<li>queue — A synchronized queue class<br />
<a href="https://docs.python.org/3/library/queue.html">https://docs.python.org/3/library/queue.html</a>
</li>

<li>Queue – A thread-safe FIFO implementation<br />
<a href="https://pymotw.com/2/Queue/">https://pymotw.com/2/Queue/</a>
</li>

<li>Queues<br />
<a href="http://queues.io/">http://queues.io/</a>
</li>

<li>Windows Subsystem for Linux Documentation<br />
<a href="https://docs.microsoft.com/en-us/windows/wsl/about">https://docs.microsoft.com/en-us/windows/wsl/about</a>
</li>

<li>RestMQ<br />
<a href="http://restmq.com/">http://restmq.com/</a>
</li>

<li>ActiveMQ<br />
<a href="http://activemq.apache.org/">http://activemq.apache.org/</a>
</li>

<li>Amazon MQ<br />
<a href="https://aws.amazon.com/amazon-mq/">https://aws.amazon.com/amazon-mq/</a>
</li>

<li>Amazon Simple Queue Service<br />
<a href="https://aws.amazon.com/sqs/">https://aws.amazon.com/sqs/</a>
</li>

<li>Celery: Distributed Task Queue<br />
<a href="http://www.celeryproject.org/">http://www.celeryproject.org/</a>
</li>

<li>Disque, an in-memory, distributed job queue<br />
<a href="https://github.com/antirez/disque">https://github.com/antirez/disque</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Projekt RQ na PyPi<br />
<a href="https://pypi.org/project/rq/">https://pypi.org/project/rq/</a>
</li>

<li>rq-dashboard 0.3.12<br />
<a href="https://pypi.org/project/rq-dashboard/">https://pypi.org/project/rq-dashboard/</a>
</li>

<li>Job queue<br />
<a href="https://en.wikipedia.org/wiki/Job_queue">https://en.wikipedia.org/wiki/Job_queue</a>
</li>

<li>Why we moved from Celery to RQ<br />
<a href="https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq">https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq</a>
</li>

<li>Running multiple workers using Celery<br />
<a href="https://serverfault.com/questions/655387/running-multiple-workers-using-celery">https://serverfault.com/questions/655387/running-multiple-workers-using-celery</a>
</li>

<li>celery — Distributed processing<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.html">http://docs.celeryproject.org/en/latest/reference/celery.html</a>
</li>

<li>Chains<br />
<a href="https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains">https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains</a>
</li>

<li>Routing<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing">http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing</a>
</li>

<li>Celery Distributed Task Queue in Go<br />
<a href="https://github.com/gocelery/gocelery/">https://github.com/gocelery/gocelery/</a>
</li>

<li>Python Decorators<br />
<a href="https://wiki.python.org/moin/PythonDecorators">https://wiki.python.org/moin/PythonDecorators</a>
</li>

<li>Periodic Tasks<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html">http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html</a>
</li>

<li>celery.schedules<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab">http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab</a>
</li>

<li>Pros and cons to use Celery vs. RQ<br />
<a href="https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq">https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq</a>
</li>

<li>Priority queue<br />
<a href="https://en.wikipedia.org/wiki/Priority_queue">https://en.wikipedia.org/wiki/Priority_queue</a>
</li>

<li>Jupyter<br />
<a href="https://jupyter.org/">https://jupyter.org/</a>
</li>

<li>How IPython and Jupyter Notebook work<br />
<a href="https://jupyter.readthedocs.io/en/latest/architecture/how_jupyter_ipython_work.html">https://jupyter.readthedocs.io/en/latest/architecture/how_jupyter_ipython_work.html</a>
</li>

<li>Context Managers<br />
<a href="http://book.pythontips.com/en/latest/context_managers.html">http://book.pythontips.com/en/latest/context_managers.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

