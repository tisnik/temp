<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhém článku o nástroji NSQ si ukážeme některé možné konfigurace používané v praxi. Zaměříme se zejména na ty konfigurace, které do značné míry vylučují existenci SPOF, tedy jednoho uzlu (počítače, služby, procesu), jehož pád by způsobit nefunkčnost celého systému doručování zpráv.</p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">*** 2. Zdrojové kódy producentů a konzumentů zpráv použitých v&nbsp;dnešním článku</a></p>
<p><a href="#k03">*** 3. </a></p>
<p><a href="#k04">*** 4. </a></p>
<p><a href="#k05">*** 5. </a></p>
<p><a href="#k06">*** 6. </a></p>
<p><a href="#k07">*** 7. </a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. </a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>

<p><a href="">V&nbsp;prvním článku</a> o nástroji <i>NSQ</i> jsme se seznámili se základními vlastnostmi tohoto systému pro doručování zpráv vyvinutého <a href="">v&nbsp;programovacím jazyce Go</a>. Připomeňme si, že tento systém je založen na myšlence decentralizovaného doručování zpráv, což znamená, že se nejedná o klasického message brokera, ale o distribuovaný systém s&nbsp;větším množstvím uzlů, k&nbsp;nimž se mohou připojit jak producenti zpráv, tak i jejich konzumenti (příjemci zpráv). Celý systém je přitom navržen takovým způsobem, aby se (pochopitelně při správné konfiguraci) výpadek nějakého uzlu neprojevil na pádu či nedostupnosti celého systému. Na druhou stranu je však možné, že jedna zpráva bude nějakým příjemcem přijata vícekrát, což je daň, kterou musíme zaplatit za decentralizovanou architekturu (jinými slovy to znamená, že by příjemci měli být idempotentní, což si někdy vyžádá nutnost použití databáze či jiného datového úložiště s&nbsp;&bdquo;pamětí&ldquo; již zpracovaných zpráv).</p>

<p>Celý systém <i>NSQ</i> je složen z&nbsp;několika typů uzlů, přičemž jednotlivé uzly mohou být provozovány na různých počítačích, geograficky distribuovány atd. Jedná se o následující typy uzlů:</p>

<ol>

<li><i>nsqlookupd</i> &ndash; jedná se o takzvanou <i>direcory service</i>, tj.&nbsp;o službu, do které se registrují všechny ostatní uzly a která tak má přehled o umístění (adresa+číslo portu) i o stavu jednotlivých uzlů. Konzumenti se typicky nejprve připojují právě k&nbsp;<i>nsqlookupd</i>, aby zjistili, které brokery jsou schopny jim dodávat zprávy požadovaných témat (<i>topic</i>).</li>

<li><i>nsqd</i> &ndash; tyto uzly, jichž může běžet libovolné množství, zajišťují vlastní příjem zpráv, jejich ukládání do front a následné doručení konzumentům. Zprávy jsou perzistentní, tj.&nbsp;ve chvíli, kdy je uzel <i>nsqd</i> zastavován, jsou uloženy do souboru a po znovuspuštění jsou ze souboru načteny do paměti a popř.&nbsp;zaslány konzumentům.</li>

<li><i>nsqadmin</i> &ndash; tato služba poskytuje (webové) uživatelské rozhraní, ze kterého je možné sledovat činnost celého systému. Samotné sledování je primárně založeno na komunikaci s&nbsp;prvním typem uzlu &ndash; <i>nsqlookupd</i> a sekundárně s&nbsp;uzly <i>nsqd</i>.</li>

</ol>

<p>Připomeňme si navíc, že zprávy se do <i>NSQ</i> posílají s&nbsp;nastaveným tématem (<i>topic</i>). Výběr (či možná lépe řečeno odběr) zpráv je nepatrně složitější, protože je nutné specifikovat jak téma odebíraných zpráv, tak i takzvaný kanál (<i>channel</i>), ze kterého se zprávy vybírají. Pokud pro nějaké schéma existuje větší množství kanálů, bude zpráva přeposlána (distribuována) do všech kanálů s&nbsp;tímto tématem. V&nbsp;případě, že se k&nbsp;jednomu kanálu připojí více příjemců, bude zpráva doručena jen jednomu z&nbsp;nich (buď náhodně nebo prvnímu volnému příjemci). Případný <i>load-balancing</i> se tedy provádí na úrovni kanálů, které můžeme považovat za obdobu front zpráv (<i>message queue</i>), jež známe z&nbsp;popisu klasických message brokerů (ve skutečnosti se ovšem fronta interně vytváří i na úrovni samotného tématu, tj.&nbsp;na vstupu do <i>nsqd</i>). Některé možné konfigurace systému <i>NSQ</i> si naznačíme na schématech v&nbsp;navazujících kapitolách.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Zdrojové kódy producentů a konzumentů zpráv použitých v&nbsp;dnešním článku</h2>

<p>Pro otestování základních funkcí různých konfigurací systému <i>NSQ</i> použijeme producenta zpráv naprogramovaného v&nbsp;jazyce Go. Tento producent bude s&nbsp;frekvencí přibližně jedné sekundy vytvářet zprávy, které budou posílány do lokálně běžící služby <i>nsqd</i>. Zprávy budou směrovány do tématu &bdquo;test&ldquo;:</p>

<pre>
</pre>

<p>Taktéž pochopitelně použijeme konzumenta, který bude opět vyvinut v&nbsp;programovacím jazyce Go. První varianta konzumenta se bude připojovat na lokálně běžící službu <i>nsqd</i> (tedy na stejnou službu, jako konzument) a bude odebírat zprávy s&nbsp;tématem &bdquo;test&ldquo; z&nbsp;kanálu, jehož jméno je z&nbsp;důvodu co největší jednoduchosti nastaveno na &bdquo;A&ldquo;:</p>

<pre>
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. </h2>

<p>V&nbsp;závislosti na tom, jaké chování a vlastnosti od systému doručování zpráv vyžadujeme, je možné <i>NSQ</i> nakonfigurovat několika možnými způsoby. Nejprve si pro úplnost uvedeme tu nejjednodušší možnou konfiguraci, v&nbsp;niž vystupuje pouze jediný uzel typu <i>nsqd</i>, k&nbsp;němuž se připojují jak ty služby, které zprávy vytváří, tak i konzumenti zpráv. V&nbsp;případě, že bude použito jen jediné téma (se jménem &bdquo;&ldquo;) a jediný kanál (se jménem &bdquo;&ldquo;), bude celá architektura připomínat jednoduchého message brokera s&nbsp;jedinou frontou zpráv:</p>

<p>Předchozí nastavení <i>NSQ</i> bylo skutečně triviální, ovšem v&nbsp;praxi se setkáme s&nbsp;mnoha dalšími požadavky na službu pro doručování zpráv, které je nutné nějakým způsobem implementovat. Poměrně častý a přitom jednoduše řešitelný je požadavek na to, aby se zprávy nehromadily v&nbsp;operační paměti alokované službou <i>nsqd</i>. Při startu <i>nsqd</i> je možné určit maximální kapacitu paměti použitou pro zapamatování zpráv. Tato kapacita se označuje termínem &bdquo;high water mark&ldquo;. Ve chvíli, kdy by mělo dojít k&nbsp;překročení této kapacity, budou zprávy uloženy na disk, takže se paměťové požadavky uzlu <i>nsqd</i> mohou udržet ve stanovených mezích. Z&nbsp;pohledu producentů a konzumentů zpráv ovšem nedojde k&nbsp;žádné podstatné změně:</p>

<p><div class="rs-tip-major">Poznámka: na tomto místě si připomeňme, že pokud dojde k&nbsp;ukončení běhu služby <i>nsqd</i>, budou zprávy taktéž serializovány, a to do té chvíle, než se služba znovu nastartuje a dojde k&nbsp;jejich opětovné deserializaci. Může se ovšem stát, že některá zpráva bude konzumentům doručena vícekrát (<i>nsqd</i> se totiž může ukončit ve chvíli, kdy ještě nedojde k&nbsp;potvrzení doručení posledních zpráv odeslaných konzumentům, popř.&nbsp;potvrzení dojde, ale informace o něm se již nestačí serializovat).</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. </h2>

<p>Samozřejmě nejsme omezeni pouze na jednoho producenta zpráv (pro zvolený topic). Producentů může existovat libovolné množství a jedinou informaci, kterou musí znát, je adresa služby <i>nsqd</i> a jméno tématu:</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. </h2>

<p>Podobně je možné &ndash; a velmi často se s&nbsp;takovou situací setkáme &ndash; že existuje několik konzumentů zpráv zaregistrovaných k&nbsp;odběru stejného tématu na shodném kanálu. V&nbsp;takovém případě dojde k&nbsp;již výše zmíněnému <i>load-balancingu</i> &ndash; zpráva je poslána jen jednomu zvolenému klientovi:</p>

<pre>
$ ./consumer4_chan_A 

2019/11/10 19:33:49 INF    1 [test/A] (127.0.0.1:4150) connecting to nsqd
2019/11/10 19:33:49 Waiting for message
2019/11/10 19:33:56 Received a message: Zprava z Go #0
2019/11/10 19:33:58 Received a message: Zprava z Go #2
2019/11/10 19:34:00 Received a message: Zprava z Go #4
2019/11/10 19:34:02 Received a message: Zprava z Go #6
2019/11/10 19:34:04 Received a message: Zprava z Go #8
2019/11/10 19:34:06 Received a message: Zprava z Go #10
2019/11/10 19:34:08 Received a message: Zprava z Go #12
2019/11/10 19:34:10 Received a message: Zprava z Go #14
</pre>

<pre>
$ ./consumer4_chan_A

2019/11/10 19:33:52 INF    1 [test/A] (127.0.0.1:4150) connecting to nsqd
2019/11/10 19:33:52 Waiting for message
2019/11/10 19:33:57 Received a message: Zprava z Go #1
2019/11/10 19:33:59 Received a message: Zprava z Go #3
2019/11/10 19:34:01 Received a message: Zprava z Go #5
2019/11/10 19:34:03 Received a message: Zprava z Go #7
2019/11/10 19:34:05 Received a message: Zprava z Go #9
2019/11/10 19:34:07 Received a message: Zprava z Go #11
2019/11/10 19:34:09 Received a message: Zprava z Go #13
2019/11/10 19:34:11 Received a message: Zprava z Go #15
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. </h2>

<p>Ovšem můžeme požadovat i odlišné chování &ndash; předání shodných zpráv několika konzumentům. Řešeno tohoto požadavku je snadné, protože postačuje zajistit, aby každý z&nbsp;konzumentů používal odlišný kanál tak, jak je to naznačeno na dalším schématu:</p>

<pre>
$ ./consumer4_chan_A 

2019/11/10 19:35:25 INF    1 [test/A] (127.0.0.1:4150) connecting to nsqd
2019/11/10 19:35:25 Waiting for message
2019/11/10 19:35:32 Received a message: Zprava z Go #0
2019/11/10 19:35:33 Received a message: Zprava z Go #1
2019/11/10 19:35:34 Received a message: Zprava z Go #2
2019/11/10 19:35:35 Received a message: Zprava z Go #3
2019/11/10 19:35:36 Received a message: Zprava z Go #4
2019/11/10 19:35:37 Received a message: Zprava z Go #5
2019/11/10 19:35:38 Received a message: Zprava z Go #6
2019/11/10 19:35:39 Received a message: Zprava z Go #7
2019/11/10 19:35:40 Received a message: Zprava z Go #8
2019/11/10 19:35:41 Received a message: Zprava z Go #9
2019/11/10 19:35:42 Received a message: Zprava z Go #10
</pre>

<pre>
$ ./consumer4_chan_B
2019/11/10 19:35:29 INF    1 [test/B] (127.0.0.1:4150) connecting to nsqd
2019/11/10 19:35:29 Waiting for message
2019/11/10 19:35:32 Received a message: Zprava z Go #0
2019/11/10 19:35:33 Received a message: Zprava z Go #1
2019/11/10 19:35:34 Received a message: Zprava z Go #2
2019/11/10 19:35:35 Received a message: Zprava z Go #3
2019/11/10 19:35:36 Received a message: Zprava z Go #4
2019/11/10 19:35:37 Received a message: Zprava z Go #5
2019/11/10 19:35:38 Received a message: Zprava z Go #6
2019/11/10 19:35:39 Received a message: Zprava z Go #7
2019/11/10 19:35:40 Received a message: Zprava z Go #8
2019/11/10 19:35:41 Received a message: Zprava z Go #9
2019/11/10 19:35:42 Received a message: Zprava z Go #10
</pre>

<pre>
{
  "topics": [
    {
      "channels": [
        {
          "name": "A",
          "paused": false
        },
        {
          "name": "B",
          "paused": false
        }
      ],
      "name": "test",
      "paused": false
    }
  ],
  "version": "1.2.1-alpha"
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. </h2>

<p>V&nbsp;mnoha situacích se setkáme s&nbsp;požadavkem archivace zpráv, které byly do systému poslány. Buď se může jednat o všechny zprávy nebo o zprávy s&nbsp;určitým tématem. Samozřejmě je možné naprogramovat konzumenta, který bude archivaci nějakým způsobem provádět, ovšem přesně pro tento účel existuje standardní utilita, jež je součástí standardní instalace systému <i>NSQ</i>. Tato utilita se jmenuje příznačně <strong>nsq_to_file</strong> a při jejím volání musíme určit jak téma zpráv, které mají být archivovány, tak i jméno kanálu (a pochopitelně i adresu <i>nsqd</i> použitou pro příjem zpráv):</p>

<pre>
</pre>

<p>Přitom je nutné zajistit, se k&nbsp;danému kanálu nepřipojovali žádní běžní konzumenti zpráv, neboť již víme, že v&nbsp;takovém případě by se zpráva poslala jen jednomu zvolenému konzumentovi (podle jejich aktuálního vytížení). V&nbsp;případě, že utilita <strong>nsq_to_file</strong> bude naopak připojena k&nbsp;unikátnímu kanálu, mohou být ostatní konzumenti připojeni ke kanálu jinému a stále bude zaručeno, že se všechny zprávy s&nbsp;daným tématem budou archivovat. Toto chování si můžeme velmi snadno otestovat, protože postačuje:</p>

<ol>
<li>Spustit <i>nsqd</i></li>
<li>Spustit konzumenta zpráv</li>
<li>Spustit zde popisovanou utilitu <strong>nsq_to_file</strong></li>
<li>A nakonec spustit producenta zpráv</li>
</ol>

<p>Výsledky po odeslání jedenácti zpráv vypadají následovně.</p>

<p>Konzument:</p>

<pre>
$ ./consumer4_chan_A 
&nbsp;
2019/11/10 19:39:29 INF    1 [test/A] (127.0.0.1:4150) connecting to nsqd
2019/11/10 19:39:29 Waiting for message
2019/11/10 19:39:31 Received a message: Zprava z Go #0
2019/11/10 19:39:32 Received a message: Zprava z Go #1
2019/11/10 19:39:33 Received a message: Zprava z Go #2
2019/11/10 19:39:34 Received a message: Zprava z Go #3
2019/11/10 19:39:35 Received a message: Zprava z Go #4
2019/11/10 19:39:36 Received a message: Zprava z Go #5
2019/11/10 19:39:37 Received a message: Zprava z Go #6
2019/11/10 19:39:38 Received a message: Zprava z Go #7
2019/11/10 19:39:39 Received a message: Zprava z Go #8
2019/11/10 19:39:40 Received a message: Zprava z Go #9
2019/11/10 19:39:41 Received a message: Zprava z Go #10
</pre>

<p>Chování archivátoru zpráv:</p>

<pre>
$ ./nsq_to_file --nsqd-tcp-address=localhost:4150 --topic test --channel archive
&nbsp;
2019/11/10 19:39:18 INF    1 [test/archive] (localhost:4150) connecting to nsqd
[nsq_to_file] 2019/11/10 19:39:31.461572 INFO: [test/archive] opening /tmp/test.tester-ThinkPad-T410.2019-11-10_19.log
[nsq_to_file] 2019/11/10 19:39:31.461687 INFO: [test/archive] syncing 1 records to disk
[nsq_to_file] 2019/11/10 19:39:48.314973 INFO: [test/archive] syncing 10 records to disk
^C2019/11/10 19:40:02 INF    1 [test/archive] stopping...
2019/11/10 19:40:02 INF    1 [test/archive] (localhost:4150) received CLOSE_WAIT from nsqd
2019/11/10 19:40:02 INF    1 [test/archive] (localhost:4150) beginning close
2019/11/10 19:40:02 INF    1 [test/archive] (localhost:4150) readLoop exiting
2019/11/10 19:40:02 INF    1 [test/archive] (localhost:4150) breaking out of writeLoop
2019/11/10 19:40:02 INF    1 [test/archive] (localhost:4150) writeLoop exiting
2019/11/10 19:40:03 INF    1 [test/archive] (localhost:4150) finished draining, cleanup exiting
2019/11/10 19:40:03 INF    1 [test/archive] (localhost:4150) clean close complete
2019/11/10 19:40:03 WRN    1 [test/archive] there are 0 connections left alive
2019/11/10 19:40:03 INF    1 [test/archive] stopping handlers
2019/11/10 19:40:03 INF    1 [test/archive] rdyLoop exiting
</pre>

<p>Obsah souboru, do kterého se archivují zprávy:</p>

<pre>
$ cat /tmp/test.tester-ThinkPad-T410.2019-11-10_19.log 
&nbsp;
Zprava z Go #0
Zprava z Go #1
Zprava z Go #2
Zprava z Go #3
Zprava z Go #4
Zprava z Go #5
Zprava z Go #6
Zprava z Go #7
Zprava z Go #8
Zprava z Go #9
Zprava z Go #10
</pre>

<p><div class="rs-tip-major">Poznámka: můžeme zde vidět, že konzument skutečně získal všechny zprávy a současně byly všechny zprávy uloženy na disk. To je většinou přesně to chování, které od systému <i>NSQ</i> při archivaci zpráv vyžadujeme.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>

<p>Pro zajímavost si můžeme otestovat jinou situaci &ndash; jak konzument zpráv, tak i archivační utilita <strong>nsq_to_file</strong> budou zprávy odebírat ze stejného kanálu. Systém <i>NSQ</i> by v&nbsp;takovém případě měl zprávy mezi oba producenty rozdělit, protože z&nbsp;jeho pohledu je i archivační utilita běžným příjemcem zpráv.</p>

<p>Výsledky po odeslání jedenácti zpráv vypadají následovně.</p>

<p>Konzument:</p>

<pre>
</pre>

<p>Obsah souboru, do kterého se archivují zprávy:</p>

<pre>
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto případě je patrné, že se zprávy skutečně rozdělily principem <i>round-robin</i> mezi běžného příjemce zpráv a mezi utilitu <strong>nsq_to_file</strong>. V&nbsp;naprosté většině případů se nejedná o to chování, které je v&nbsp;praxi vyžadováno. Jediným důvodem, kdy by tato konfigurace mohla být použita, je situace, kdy nechceme nezpracované zprávy ponechat v&nbsp;<i>nsqd</i>, ale současně je ani nechceme ztratit, například tehdy, pokud jsou všichni příjemci zpráv vytížení.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>

<p>Chování ve chvíli, kdy zpráva nemůže být doručena.</p>

retry - pokud dojde na straně konzumenta zpráv k&nbsp;nějaké chybě, informuje o ni (přes příslušnou knihovnu) službu <i>nsqd</i> příkazem <strong>REQ</strong> neboli <i>re-queue</i>. Podobně pokud služba <i>nsqd</i> nedostane v&nbsp;určeném čase informaci o zpracování zprávy, dojde k&nbsp;timeoutu následovaném opět operací typu <strong>REQ</strong>

exponential backoff - pokud není zpráva korektně zpracována v&nbsp;konzumentovi zpráv, bude žádost o další zprávy pozdržena o dobu, která postupně (s&nbsp;dalšími případnými pády) exponenciálně roste. A naopak &ndash; ve chvíli, kdy je nějaká zpráva zpracována korektně, bude se doba mezi příjmem další zprávy postupně snižovat až na nulu. Díky tomu se (z&nbsp;nějakého důvodu problémový) konzument zpráv v&nbsp;systému postupně zpomaluje a po jeho opravě zase postupně zrychluje. Dává se tím prostor pro další konzumenty, které jsou v&nbsp;korektním stavu &ndash; ty budou zprávy zpracovávat nejrychlejším možným způsobem, což ovšem neznamená, že by se opravený uzel nemohl znovu stát plnohodnotným uzlem v&nbsp;celém systému.



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. </h2>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Stránka projektu NSQ<br />
<a href="https://nsq.io/">https://nsq.io/</a>
</li>

<li>Dokumentace k&nbsp;projektu NSQ<br />
<a href="https://nsq.io/overview/design.html">https://nsq.io/overview/design.html</a>
</li>

<li>Dokumentace ke klientovi pro Go<br />
<a href="https://godoc.org/github.com/nsqio/go-nsq">https://godoc.org/github.com/nsqio/go-nsq</a>
</li>

<li>Dokumentace ke klientovi pro Python<br />
<a href="https://pynsq.readthedocs.io/en/latest/">https://pynsq.readthedocs.io/en/latest/</a>
</li>

<li>Binární tarbally s&nbsp;NSQ<br />
<a href="https://nsq.io/deployment/installing.html">https://nsq.io/deployment/installing.html</a>
</li>

<li>GitHub repositář projektu NSQ<br />
<a href="https://github.com/nsqio/nsq">https://github.com/nsqio/nsq</a>
</li>

<li>Klienti pro NSQ<br />
<a href="https://nsq.io/clients/client_libraries.html">https://nsq.io/clients/client_libraries.html</a>
</li>

<li>Klient pro Go<br />
<a href="https://github.com/nsqio/go-nsq">https://github.com/nsqio/go-nsq</a>
</li>

<li>Klient pro Python<br />
<a href="https://github.com/nsqio/pynsq">https://github.com/nsqio/pynsq</a>
</li>

<li>An Example of Using NSQ From Go<br />
<a href="http://tleyden.github.io/blog/2014/11/12/an-example-of-using-nsq-from-go/">http://tleyden.github.io/blog/2014/11/12/an-example-of-using-nsq-from-go/</a>
</li>

<li>Go Go Gadget<br />
<a href="https://word.bitly.com/post/29550171827/go-go-gadget">https://word.bitly.com/post/29550171827/go-go-gadget</a>
</li>

<li>Simplehttp<br />
<a href="https://github.com/bitly/simplehttp">https://github.com/bitly/simplehttp</a>
</li>

<li>Dramatiq: simple task processing<br />
<a href="https://dramatiq.io/">https://dramatiq.io/</a>
</li>

<li>Cookbook (for Dramatiq)<br />
<a href="https://dramatiq.io/cookbook.html">https://dramatiq.io/cookbook.html</a>
</li>

<li>Balíček dramatiq na PyPi<br />
<a href="https://pypi.org/project/dramatiq/">https://pypi.org/project/dramatiq/</a>
</li>

<li>Dramatiq dashboard<br />
<a href="https://github.com/Bogdanp/dramatiq_dashboard">https://github.com/Bogdanp/dramatiq_dashboard</a>
</li>

<li>Dramatiq na Redditu<br />
<a href="https://www.reddit.com/r/dramatiq/">https://www.reddit.com/r/dramatiq/</a>
</li>

<li>A Dramatiq broker that can be used with Amazon SQS<br />
<a href="https://github.com/Bogdanp/dramatiq_sqs">https://github.com/Bogdanp/dramatiq_sqs</a>
</li>

<li>nanomsg na GitHubu<br />
<a href="https://github.com/nanomsg/nanomsg">https://github.com/nanomsg/nanomsg</a>
</li>

<li>Referenční příručka knihovny <strong>nanomsg</strong><br />
<a href="https://nanomsg.org/v1.1.5/nanomsg.html">https://nanomsg.org/v1.1.5/nanomsg.html</a>
</li>

<li>nng (nanomsg-next-generation)<br />
<a href="https://github.com/nanomsg/nng">https://github.com/nanomsg/nng</a>
</li>

<li>Differences between nanomsg and ZeroMQ<br />
<a href="https://nanomsg.org/documentation-zeromq.html">https://nanomsg.org/documentation-zeromq.html</a>
</li>

<li>NATS<br />
<a href="https://nats.io/about/">https://nats.io/about/</a>
</li>

<li>NATS Streaming Concepts<br />
<a href="https://nats.io/documentation/streaming/nats-streaming-intro/">https://nats.io/documentation/streaming/nats-streaming-intro/</a>
</li>

<li>NATS Streaming Server<br />
<a href="https://nats.io/download/nats-io/nats-streaming-server/">https://nats.io/download/nats-io/nats-streaming-server/</a>
</li>

<li>NATS Introduction<br />
<a href="https://nats.io/documentation/">https://nats.io/documentation/</a>
</li>

<li>NATS Client Protocol<br />
<a href="https://nats.io/documentation/internals/nats-protocol/">https://nats.io/documentation/internals/nats-protocol/</a>
</li>

<li>NATS Messaging (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/NATS_Messaging">https://en.wikipedia.org/wiki/NATS_Messaging</a>
</li>

<li>Stránka Apache Software Foundation<br />
<a href="http://www.apache.org/">http://www.apache.org/</a>
</li>

<li>Informace o portu 5672<br />
<a href="http://www.tcp-udp-ports.com/port-5672.htm">http://www.tcp-udp-ports.com/port-5672.htm</a>
</li>

<li>Třída MessagingHandler knihovny Qpid Proton<br />
<a href="https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._handlers.MessagingHandler-class.html">https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._handlers.MessagingHandler-class.html</a>
</li>

<li>Třída Event knihovny Qpid Proton<br />
<a href="https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._events.Event-class.html">https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._events.Event-class.html</a>
</li>

<li>package stomp (Go)<br />
<a href="https://godoc.org/github.com/go-stomp/stomp">https://godoc.org/github.com/go-stomp/stomp</a>
</li>

<li>Go language library for STOMP protocol<br />
<a href="https://github.com/go-stomp/stomp">https://github.com/go-stomp/stomp</a>
</li>

<li>python-qpid-proton 0.26.0 na PyPi<br />
<a href="https://pypi.org/project/python-qpid-proton/">https://pypi.org/project/python-qpid-proton/</a>
</li>

<li>Qpid Proton<br />
<a href="http://qpid.apache.org/proton/">http://qpid.apache.org/proton/</a>
</li>

<li>Using the AMQ Python Client<br />
<a href="https://access.redhat.com/documentation/en-us/red_hat_amq/7.1/html-single/using_the_amq_python_client/">https://access.redhat.com/documentation/en-us/red_hat_amq/7.1/html-single/using_the_amq_python_client/</a>
</li>

<li>Apache ActiveMQ<br />
<a href="http://activemq.apache.org/">http://activemq.apache.org/</a>
</li>

<li>Apache ActiveMQ Artemis<br />
<a href="https://activemq.apache.org/artemis/">https://activemq.apache.org/artemis/</a>
</li>

<li>Apache ActiveMQ Artemis User Manual<br />
<a href="https://activemq.apache.org/artemis/docs/latest/index.html">https://activemq.apache.org/artemis/docs/latest/index.html</a>
</li>

<li>KahaDB<br />
<a href="http://activemq.apache.org/kahadb.html">http://activemq.apache.org/kahadb.html</a>
</li>

<li>Understanding the KahaDB Message Store<br />
<a href="https://access.redhat.com/documentation/en-US/Fuse_MQ_Enterprise/7.1/html/Configuring_Broker_Persistence/files/KahaDBOverview.html">https://access.redhat.com/documentation/en-US/Fuse_MQ_Enterprise/7.1/html/Configuring_Broker_Persistence/files/KahaDBOverview.html</a>
</li>

<li>Command Line Tools (Apache ActiveMQ)<br />
<a href="https://activemq.apache.org/activemq-command-line-tools-reference.html">https://activemq.apache.org/activemq-command-line-tools-reference.html</a>
</li>

<li>stomp.py 4.1.21 na PyPi<br />
<a href="https://pypi.org/project/stomp.py/">https://pypi.org/project/stomp.py/</a>
</li>

<li>Stomp Tutorial<br />
<a href="https://access.redhat.com/documentation/en-US/Fuse_Message_Broker/5.5/html/Connectivity_Guide/files/FMBConnectivityStompTelnet.html">https://access.redhat.com/documentation/en-US/Fuse_Message_Broker/5.5/html/Connectivity_Guide/files/FMBConnectivityStompTelnet.html</a>
</li>

<li>Heartbeat (computing)<br />
<a href="https://en.wikipedia.org/wiki/Heartbeat_(computing)">https://en.wikipedia.org/wiki/Heartbeat_(computing)</a>
</li>

<li>Apache Camel<br />
<a href="https://camel.apache.org/">https://camel.apache.org/</a>
</li>

<li>Red Hat Fuse<br />
<a href="https://developers.redhat.com/products/fuse/overview/">https://developers.redhat.com/products/fuse/overview/</a>
</li>

<li>Confusion between ActiveMQ and ActiveMQ-Artemis?<br />
<a href="https://serverfault.com/questions/873533/confusion-between-activemq-and-activemq-artemis">https://serverfault.com/questions/873533/confusion-between-activemq-and-activemq-artemis</a>
</li>

<li>Staré stránky projektu HornetQ<br />
<a href="http://hornetq.jboss.org/">http://hornetq.jboss.org/</a>
</li>

<li>Snapshot JeroMQ verze 0.4.4<br />
<a href="https://oss.sonatype.org/content/repositories/snapshots/org/zeromq/jeromq/0.4.4-SNAPSHOT/">https://oss.sonatype.org/content/repositories/snapshots/org/zeromq/jeromq/0.4.4-SNAPSHOT/</a>
</li>

<li>Difference between ActiveMQ vs Apache ActiveMQ Artemis<br />
<a href="http://activemq.2283324.n4.nabble.com/Difference-between-ActiveMQ-vs-Apache-ActiveMQ-Artemis-td4703828.html">http://activemq.2283324.n4.nabble.com/Difference-between-ActiveMQ-vs-Apache-ActiveMQ-Artemis-td4703828.html</a>
</li>

<li>Microservices communications. Why you should switch to message queues<br />
<a href="https://dev.to/matteojoliveau/microservices-communications-why-you-should-switch-to-message-queues--48ia">https://dev.to/matteojoliveau/microservices-communications-why-you-should-switch-to-message-queues--48ia</a>
</li>

<li>Stomp.py 4.1.19 documentation<br />
<a href="https://stomppy.readthedocs.io/en/stable/">https://stomppy.readthedocs.io/en/stable/</a>
</li>

<li>Repositář knihovny JeroMQ<br />
<a href="https://github.com/zeromq/jeromq/">https://github.com/zeromq/jeromq/</a>
</li>

<li>ØMQ &ndash; Distributed Messaging <br />
<a href="http://zeromq.org/">http://zeromq.org/</a>
</li>

<li>ØMQ Community<br />
<a href="http://zeromq.org/community">http://zeromq.org/community</a>
</li>

<li>Get The Software<br />
<a href="http://zeromq.org/intro:get-the-software">http://zeromq.org/intro:get-the-software</a>
</li>

<li>PyZMQ Documentation<br />
<a href="https://pyzmq.readthedocs.io/en/latest/">https://pyzmq.readthedocs.io/en/latest/</a>
</li>

<li>Module: zmq.decorators<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.decorators.html">https://pyzmq.readthedocs.io/en/latest/api/zmq.decorators.html</a>
</li>

<li>ZeroMQ is the answer, by Ian Barber<br />
<a href="https://vimeo.com/20605470">https://vimeo.com/20605470</a>
</li>

<li>ZeroMQ RFC<br />
<a href="https://rfc.zeromq.org/">https://rfc.zeromq.org/</a>
</li>

<li>ZeroMQ and Clojure, a brief introduction<br />
<a href="https://antoniogarrote.wordpress.com/2010/09/08/zeromq-and-clojure-a-brief-introduction/">https://antoniogarrote.wordpress.com/2010/09/08/zeromq-and-clojure-a-brief-introduction/</a>
</li>

<li>zeromq/czmq<br />
<a href="https://github.com/zeromq/czmq">https://github.com/zeromq/czmq</a>
</li>

<li>golang wrapper for CZMQ<br />
<a href="https://github.com/zeromq/goczmq">https://github.com/zeromq/goczmq</a>
</li>

<li>ZeroMQ version reporting in Python<br />
<a href="http://zguide.zeromq.org/py:version">http://zguide.zeromq.org/py:version</a>
</li>

<li>A Go interface to ZeroMQ version 4<br />
<a href="https://github.com/pebbe/zmq4">https://github.com/pebbe/zmq4</a>
</li>

<li>Broker vs. Brokerless<br />
<a href="http://zeromq.org/whitepapers:brokerless">http://zeromq.org/whitepapers:brokerless</a>
</li>

<li>Learning ØMQ with pyzmq<br />
<a href="https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/">https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/</a>
</li>

<li>Céčková funkce <strong>zmq_ctx_new</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-ctx-new">http://api.zeromq.org/4-2:zmq-ctx-new</a>
</li>

<li>Céčková funkce <strong>zmq_ctx_destroy</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-ctx-destroy">http://api.zeromq.org/4-2:zmq-ctx-destroy</a>
</li>

<li>Céčková funkce <strong>zmq_bind</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-bind">http://api.zeromq.org/4-2:zmq-bind</a>
</li>

<li>Céčková funkce <strong>zmq_unbind</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-unbind">http://api.zeromq.org/4-2:zmq-unbind</a>
</li>

<li>Céčková C funkce <strong>zmq_connect</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-connect">http://api.zeromq.org/4-2:zmq-connect</a>
</li>

<li>Céčková C funkce <strong>zmq_disconnect</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-disconnect">http://api.zeromq.org/4-2:zmq-disconnect</a>
</li>

<li>Céčková C funkce <strong>zmq_send</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-send">http://api.zeromq.org/4-2:zmq-send</a>
</li>

<li>Céčková C funkce <strong>zmq_recv</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-recv">http://api.zeromq.org/4-2:zmq-recv</a>
</li>

<li>Třída <strong>Context</strong> (Python)<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.html#context">https://pyzmq.readthedocs.io/en/latest/api/zmq.html#context</a>
</li>

<li>Třída <strong>Socket</strong> (Python)<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.html#socket">https://pyzmq.readthedocs.io/en/latest/api/zmq.html#socket</a>
</li>

<li>Python binding<br />
<a href="http://zeromq.org/bindings:python">http://zeromq.org/bindings:python</a>
</li>

<li>Why should I have written ZeroMQ in C, not C++ (part I)<br />
<a href="http://250bpm.com/blog:4">http://250bpm.com/blog:4</a>
</li>

<li>Why should I have written ZeroMQ in C, not C++ (part II) <br />
<a href="http://250bpm.com/blog:8">http://250bpm.com/blog:8</a>
</li>

<li>About Nanomsg<br />
<a href="https://nanomsg.org/">https://nanomsg.org/</a>
</li>

<li>Advanced Message Queuing Protocol<br />
<a href="https://www.amqp.org/">https://www.amqp.org/</a>
</li>

<li>Advanced Message Queuing Protocol na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol">https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol</a>
</li>

<li>Dokumentace k&nbsp;příkazu <strong>rabbitmqctl</strong><br />
<a href="https://www.rabbitmq.com/rabbitmqctl.8.html">https://www.rabbitmq.com/rabbitmqctl.8.html</a>
</li>

<li>RabbitMQ<br />
<a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a>
</li>

<li>RabbitMQ Tutorials<br />
<a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a>
</li>

<li>RabbitMQ: Clients and Developer Tools<br />
<a href="https://www.rabbitmq.com/devtools.html">https://www.rabbitmq.com/devtools.html</a>
</li>

<li>RabbitMQ na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/RabbitMQ">https://en.wikipedia.org/wiki/RabbitMQ</a>
</li>

<li>Streaming Text Oriented Messaging Protocol<br />
<a href="https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol">https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol</a>
</li>

<li>Message Queuing Telemetry Transport<br />
<a href="https://en.wikipedia.org/wiki/MQTT">https://en.wikipedia.org/wiki/MQTT</a>
</li>

<li>Erlang<br />
<a href="http://www.erlang.org/">http://www.erlang.org/</a>
</li>

<li>pika 0.12.0 na PyPi<br />
<a href="https://pypi.org/project/pika/">https://pypi.org/project/pika/</a>
</li>

<li>Introduction to Pika<br />
<a href="https://pika.readthedocs.io/en/stable/">https://pika.readthedocs.io/en/stable/</a>
</li>

<li>Langohr: An idiomatic Clojure client for RabbitMQ that embraces the AMQP 0.9.1 model<br />
<a href="http://clojurerabbitmq.info/">http://clojurerabbitmq.info/</a>
</li>

<li>AMQP 0-9-1 Model Explained<br />
<a href="http://www.rabbitmq.com/tutorials/amqp-concepts.html">http://www.rabbitmq.com/tutorials/amqp-concepts.html</a>
</li>

<li>Part 1: RabbitMQ for beginners - What is RabbitMQ?<br />
<a href="https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html">https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html</a>
</li>

<li>Downloading and Installing RabbitMQ<br />
<a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a>
</li>

<li>celery na PyPi<br />
<a href="https://pypi.org/project/celery/">https://pypi.org/project/celery/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python <br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python (dokončení)<br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/</a>
</li>

<li>Redis Queue (RQ)<br />
<a href="https://www.fullstackpython.com/redis-queue-rq.html">https://www.fullstackpython.com/redis-queue-rq.html</a>
</li>

<li>Python Celery &amp; RabbitMQ Tutorial<br />
<a href="https://tests4geeks.com/python-celery-rabbitmq-tutorial/">https://tests4geeks.com/python-celery-rabbitmq-tutorial/</a>
</li>

<li>Flower: Real-time Celery web-monitor<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor">http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor</a>
</li>

<li>Asynchronous Tasks With Django and Celery<br />
<a href="https://realpython.com/asynchronous-tasks-with-django-and-celery/">https://realpython.com/asynchronous-tasks-with-django-and-celery/</a>
</li>

<li>First Steps with Celery<br />
<a href="http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html">http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html</a>
</li>

<li>node-celery<br />
<a href="https://github.com/mher/node-celery">https://github.com/mher/node-celery</a>
</li>

<li>Full Stack Python: web development<br />
<a href="https://www.fullstackpython.com/web-development.html">https://www.fullstackpython.com/web-development.html</a>
</li>

<li>Introducing RQ<br />
<a href="https://nvie.com/posts/introducing-rq/">https://nvie.com/posts/introducing-rq/</a>
</li>

<li>Asynchronous Tasks with Flask and Redis Queue<br />
<a href="https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue">https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Stránky projektu Redis<br />
<a href="https://redis.io/">https://redis.io/</a>
</li>

<li>Introduction to Redis<br />
<a href="https://redis.io/topics/introduction">https://redis.io/topics/introduction</a>
</li>

<li>Try Redis<br />
<a href="http://try.redis.io/">http://try.redis.io/</a>
</li>

<li>Redis tutorial, April 2010 (starší, ale pěkně udělaný)<br />
<a href="https://static.simonwillison.net/static/2010/redis-tutorial/">https://static.simonwillison.net/static/2010/redis-tutorial/</a>
</li>

<li>Python Redis<br />
<a href="https://redislabs.com/lp/python-redis/">https://redislabs.com/lp/python-redis/</a>
</li>

<li>Redis: key-value databáze v paměti i na disku<br />
<a href="https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/">https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/</a>
</li>

<li>Praktický úvod do Redis (1): vaše distribuovaná NoSQL cache<br />
<a href="http://www.cloudsvet.cz/?p=253">http://www.cloudsvet.cz/?p=253</a>
</li>

<li>Praktický úvod do Redis (2): transakce<br />
<a href="http://www.cloudsvet.cz/?p=256">http://www.cloudsvet.cz/?p=256</a>
</li>

<li>Praktický úvod do Redis (3): cluster<br />
<a href="http://www.cloudsvet.cz/?p=258">http://www.cloudsvet.cz/?p=258</a>
</li>

<li>Connection pool<br />
<a href="https://en.wikipedia.org/wiki/Connection_pool">https://en.wikipedia.org/wiki/Connection_pool</a>
</li>

<li>Instant Redis Sentinel Setup<br />
<a href="https://github.com/ServiceStack/redis-config">https://github.com/ServiceStack/redis-config</a>
</li>

<li>How to install REDIS in LInux<br />
<a href="https://linuxtechlab.com/how-install-redis-server-linux/">https://linuxtechlab.com/how-install-redis-server-linux/</a>
</li>

<li>Redis RDB Dump File Format<br />
<a href="https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format">https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format</a>
</li>

<li>Lempel–Ziv–Welch<br />
<a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch">https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch</a>
</li>

<li>Redis Persistence<br />
<a href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a>
</li>

<li>Redis persistence demystified<br />
<a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html">http://oldblog.antirez.com/post/redis-persistence-demystified.html</a>
</li>

<li>Redis reliable queues with Lua scripting<br />
<a href="http://oldblog.antirez.com/post/250">http://oldblog.antirez.com/post/250</a>
</li>

<li>Ost (knihovna)<br />
<a href="https://github.com/soveran/ost">https://github.com/soveran/ost</a>
</li>

<li>NoSQL<br />
<a href="https://en.wikipedia.org/wiki/NoSQL">https://en.wikipedia.org/wiki/NoSQL</a>
</li>

<li>Shard (database architecture)<br />
<a href="https://en.wikipedia.org/wiki/Shard_%28database_architecture%29">https://en.wikipedia.org/wiki/Shard_%28database_architecture%29</a>
</li>

<li>What is sharding and why is it important?<br />
<a href="https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important">https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important</a>
</li>

<li>What Is Sharding?<br />
<a href="https://btcmanager.com/what-sharding/">https://btcmanager.com/what-sharding/</a>
</li>

<li>Redis clients<br />
<a href="https://redis.io/clients">https://redis.io/clients</a>
</li>

<li>Category:Lua-scriptable software<br />
<a href="https://en.wikipedia.org/wiki/Category:Lua-scriptable_software">https://en.wikipedia.org/wiki/Category:Lua-scriptable_software</a>
</li>

<li>Seriál Programovací jazyk Lua<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-lua/">https://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>Redis memory usage<br />
<a href="http://nosql.mypopescu.com/post/1010844204/redis-memory-usage">http://nosql.mypopescu.com/post/1010844204/redis-memory-usage</a>
</li>

<li>Ukázka konfigurace Redisu pro lokální testování<br />
<a href="https://github.com/tisnik/presentations/blob/master/redis/redis.conf">https://github.com/tisnik/presentations/blob/master/redis/redis.conf</a>
</li>

<li>Resque<br />
<a href="https://github.com/resque/resque">https://github.com/resque/resque</a>
</li>

<li>Nested transaction<br />
<a href="https://en.wikipedia.org/wiki/Nested_transaction">https://en.wikipedia.org/wiki/Nested_transaction</a>
</li>

<li>Publish–subscribe pattern<br />
<a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern</a>
</li>

<li>Messaging pattern<br />
<a href="https://en.wikipedia.org/wiki/Messaging_pattern">https://en.wikipedia.org/wiki/Messaging_pattern</a>
</li>

<li>Using pipelining to speedup Redis queries<br />
<a href="https://redis.io/topics/pipelining">https://redis.io/topics/pipelining</a>
</li>

<li>Pub/Sub<br />
<a href="https://redis.io/topics/pubsub">https://redis.io/topics/pubsub</a>
</li>

<li>ZeroMQ distributed messaging<br />
<a href="http://zeromq.org/">http://zeromq.org/</a>
</li>

<li>ZeroMQ: Modern &amp; Fast Networking Stack<br />
<a href="https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/">https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/</a>
</li>

<li>Publish/Subscribe paradigm: Why must message classes not know about their subscribers?<br />
<a href="https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr">https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr</a>
</li>

<li>Python &amp; Redis PUB/SUB<br />
<a href="https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7">https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7</a>
</li>

<li>Message broker<br />
<a href="https://en.wikipedia.org/wiki/Message_broker">https://en.wikipedia.org/wiki/Message_broker</a>
</li>

<li>RESP Arrays<br />
<a href="https://redis.io/topics/protocol#array-reply">https://redis.io/topics/protocol#array-reply</a>
</li>

<li>Redis Protocol specification<br />
<a href="https://redis.io/topics/protocol">https://redis.io/topics/protocol</a>
</li>

<li>Redis Pub/Sub: Intro Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-intro/">https://www.redisgreen.net/blog/pubsub-intro/</a>
</li>

<li>Redis Pub/Sub: Howto Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-howto/">https://www.redisgreen.net/blog/pubsub-howto/</a>
</li>

<li>Comparing Publish-Subscribe Messaging and Message Queuing<br />
<a href="https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message">https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message</a>
</li>

<li>Apache Kafka<br />
<a href="https://kafka.apache.org/">https://kafka.apache.org/</a>
</li>

<li>Iron<br />
<a href="http://www.iron.io/mq">http://www.iron.io/mq</a>
</li>

<li>kue (založeno na Redisu, určeno pro node.js)<br />
<a href="https://github.com/Automattic/kue">https://github.com/Automattic/kue</a>
</li>

<li>Cloud Pub/Sub<br />
<a href="https://cloud.google.com/pubsub/">https://cloud.google.com/pubsub/</a>
</li>

<li>Introduction to Redis Streams<br />
<a href="https://redis.io/topics/streams-intro">https://redis.io/topics/streams-intro</a>
</li>

<li>glob (programming)<br />
<a href="https://en.wikipedia.org/wiki/Glob_(programming)">https://en.wikipedia.org/wiki/Glob_(programming)</a>
</li>

<li>Why and how Pricing Assistant migrated from Celery to RQ - Paris.py<br />
<a href="https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2">https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2</a>
</li>

<li>Enqueueing internals<br />
<a href="http://python-rq.org/contrib/">http://python-rq.org/contrib/</a>
</li>

<li>queue — A synchronized queue class<br />
<a href="https://docs.python.org/3/library/queue.html">https://docs.python.org/3/library/queue.html</a>
</li>

<li>Queue – A thread-safe FIFO implementation<br />
<a href="https://pymotw.com/2/Queue/">https://pymotw.com/2/Queue/</a>
</li>

<li>Queues<br />
<a href="http://queues.io/">http://queues.io/</a>
</li>

<li>Windows Subsystem for Linux Documentation<br />
<a href="https://docs.microsoft.com/en-us/windows/wsl/about">https://docs.microsoft.com/en-us/windows/wsl/about</a>
</li>

<li>RestMQ<br />
<a href="http://restmq.com/">http://restmq.com/</a>
</li>

<li>ActiveMQ<br />
<a href="http://activemq.apache.org/">http://activemq.apache.org/</a>
</li>

<li>Amazon MQ<br />
<a href="https://aws.amazon.com/amazon-mq/">https://aws.amazon.com/amazon-mq/</a>
</li>

<li>Amazon Simple Queue Service<br />
<a href="https://aws.amazon.com/sqs/">https://aws.amazon.com/sqs/</a>
</li>

<li>Celery: Distributed Task Queue<br />
<a href="http://www.celeryproject.org/">http://www.celeryproject.org/</a>
</li>

<li>Disque, an in-memory, distributed job queue<br />
<a href="https://github.com/antirez/disque">https://github.com/antirez/disque</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Projekt RQ na PyPi<br />
<a href="https://pypi.org/project/rq/">https://pypi.org/project/rq/</a>
</li>

<li>rq-dashboard 0.3.12<br />
<a href="https://pypi.org/project/rq-dashboard/">https://pypi.org/project/rq-dashboard/</a>
</li>

<li>Job queue<br />
<a href="https://en.wikipedia.org/wiki/Job_queue">https://en.wikipedia.org/wiki/Job_queue</a>
</li>

<li>Why we moved from Celery to RQ<br />
<a href="https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq">https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq</a>
</li>

<li>Running multiple workers using Celery<br />
<a href="https://serverfault.com/questions/655387/running-multiple-workers-using-celery">https://serverfault.com/questions/655387/running-multiple-workers-using-celery</a>
</li>

<li>celery — Distributed processing<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.html">http://docs.celeryproject.org/en/latest/reference/celery.html</a>
</li>

<li>Chains<br />
<a href="https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains">https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains</a>
</li>

<li>Routing<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing">http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing</a>
</li>

<li>Celery Distributed Task Queue in Go<br />
<a href="https://github.com/gocelery/gocelery/">https://github.com/gocelery/gocelery/</a>
</li>

<li>Python Decorators<br />
<a href="https://wiki.python.org/moin/PythonDecorators">https://wiki.python.org/moin/PythonDecorators</a>
</li>

<li>Periodic Tasks<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html">http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html</a>
</li>

<li>celery.schedules<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab">http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab</a>
</li>

<li>Pros and cons to use Celery vs. RQ<br />
<a href="https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq">https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq</a>
</li>

<li>Priority queue<br />
<a href="https://en.wikipedia.org/wiki/Priority_queue">https://en.wikipedia.org/wiki/Priority_queue</a>
</li>

<li>Jupyter<br />
<a href="https://jupyter.org/">https://jupyter.org/</a>
</li>

<li>How IPython and Jupyter Notebook work<br />
<a href="https://jupyter.readthedocs.io/en/latest/architecture/how_jupyter_ipython_work.html">https://jupyter.readthedocs.io/en/latest/architecture/how_jupyter_ipython_work.html</a>
</li>

<li>Context Managers<br />
<a href="http://book.pythontips.com/en/latest/context_managers.html">http://book.pythontips.com/en/latest/context_managers.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

