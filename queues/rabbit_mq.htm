<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>RabbitMQ - jedna z nejúspěšnějších implementací brokera</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>RabbitMQ - jedna z nejúspěšnějších implementací brokera</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Třetím nástrojem implementujícím fronty zpráv a popř. i asynchronní fronty úloh, s nímž se na stránkách Rootu seznámíme, je nástroj nazvaný RabbitMQ. Dnes se seznámíme se základními vlastnostmi tohoto systému i s jeho použitím z Pythonu a Clojure.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. RabbitMQ &ndash; jedna z&nbsp;nejúspěšnějších implementací brokera</a></p>
<p><a href="#k02">2. Rozhraní mezi nástrojem RabbitMQ a programovacími jazyky</a></p>
<p><a href="#k03">3. Protokoly podporované systémem RabbitMQ</a></p>
<p><a href="#k04">4. Ukázky základních způsobů použití nástroje RabbitMQ</a></p>
<p><a href="#k05">5. Směrování zpráv před jejich vložením do fronty</a></p>
<p><a href="#k06">6. Instalace RabbitMQ a konfigurace jeho síťového rozhraní</a></p>
<p><a href="#k07">7. Spuštění serveru ve funkci démona/služby</a></p>
<p><a href="#k08">8. Instalace knihovny Pika s&nbsp;rozhraním mezi RabbitMQ a Pythonem</a></p>
<p><a href="#k09">9. První příklad: nejjednodušší možná implementace systému producent+konzument</a></p>
<p><a href="#k10">10. Konzument zpráv</a></p>
<p><a href="#k11">11. Přenos společných prvků producenta a konzumenta do jednoho zdrojového kódu</a></p>
<p><a href="#k12">12. Pomalá práce konzumenta a způsob dělby práce mezi větší množství workerů</a></p>
<p><a href="#k13">13. Potvrzování zpracování zprávy, chování systému ve chvíli, kdy zpráva není zpracována</a></p>
<p><a href="#k14">14. Vylepšené chování RabbitMQ při &bdquo;dělbě práce&ldquo; mezi workery</a></p>
<p><a href="#k15">15. Konzument zpráv naprogramovaný v&nbsp;jazyku Clojure</a></p>
<p><a href="#k16">16. Konfigurace projektu využívajícího knihovnu Langohr</a></p>
<p><a href="#k17">17. Realizace konzumenta pro příjem zpráv</a></p>
<p><a href="#k18">18. Spuštění konzumenta a příjem zpráv</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. RabbitMQ &ndash; jedna z&nbsp;nejúspěšnějších implementací brokera</h2>

<p>Třetím nástrojem implementujícím fronty zpráv a popř.&nbsp;i asynchronní
fronty úloh, s&nbsp;nímž se na stránkách Rootu seznámíme, je nástroj nazvaný
<i>RabbitMQ</i>. Původně se jednalo o klasického message brokera (de facto o
implementaci fronty zpráv) a taktéž o jednu z&nbsp;implementací protokolu <a
href="https://www.amqp.org/">AMQP</a> (<i>Advanced Message Queuing
Protocol</i>), ovšem později byly možnosti nástroje RabbitMQ rozšířeny, takže
dnes jsou podporovány i protokoly MQTT (<i>Message Queuing Telemetry
Transport</i>, mimochodem se jedná o standard ISO) a STOMP neboli <i>Streaming
Text Oriented Messaging Protocol</i>. RabbitMQ je poměrně široce
konfigurovatelný a flexibilní, což administrátorům umožňuje zvolit si takové
vlastnosti, které nejlépe vyhovují potřebám implementované služby. Například je
možné RabbitMQ nastavit do režimu s&nbsp;velkou propustností, ovšem bez
zapnutých mechanismů pro persistenci zpráv, nebo naopak do režimu, v&nbsp;němž
zprávy přežijí restart jak workerů, tak i samotného serveru Rabbitu (dokonce
lze zaručit vysokou dostupnost samotných front).</p>

<p>Na systému RabbitMQ je zajímavý i fakt, že je vyvinut v&nbsp;programovacím
jazyce <a href="http://www.erlang.org/">Erlang</a> s&nbsp;využitím sady
knihoven a nástrojů Open Telecom Platform (OTP). Volba tohoto programovacího
jazyka pro systém zajišťující kooperaci mezi obecně velkým množstvím procesů a
služeb je velmi dobrá, protože tento jazyk byl navržen právě s&nbsp;ohledem na
tvorbu distribuovaných aplikací, které jsou do značné míry odolné vůči
selhání.</p>

<p><div class="rs-tip-major">Poznámka: nemusíte se ovšem bát, že by byl
RabbitMQ kvůli tomu, že je naprogramován v&nbsp;Erlangu, hodně náročný na
systémové zdroje (je tomu spíše naopak). Sice je pravda, že se společně se
serverem RabbitMQ nainstaluje i velká část ekosystému Erlangu, ale spotřeba
operační paměti při běhu serveru se pohybuje v&nbsp;rozumných mezích (navíc je
možné relativně snadno zajistit, aby měl virtuální stroj Erlangu
k&nbsp;dispozici pouze omezené množství paměti).</div></p>

<p>V&nbsp;dnešním článku si ukážeme, jakým způsobem je možné s&nbsp;využitím
systému RabbitMQ nastavit a naprogramovat jednoduchou architekturu
producent-konzument. Řekneme si, jak se řídí dělba práce mezi jednotlivými
workery (které implementují algoritmus konzumenta), jakým způsobem se dají
sledovat jednotlivé fronty použité pro posílání zpráv a konečně si ukážeme
způsob potvrzení dokončení práce workerem. To je ovšem jen velmi malá část
funkcionality nabízené tímto systémem; další podrobnosti si proto popíšeme
v&nbsp;navazujícím článku.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Rozhraní mezi nástrojem RabbitMQ a programovacími jazyky</h2>

<p>K&nbsp;nástroji RabbitMQ byla vytvořena rozhraní (různé knihovny) umožňující
práci s&nbsp;tímto systémem (posílání a příjem zpráv) z&nbsp;mnoha
programovacích jazyků:</p>

<table>
<tr><th>Jazyk/platforma</th></tr>
<tr><td>Java</td></tr>
<tr><td>JavaScript (Node.js)</td></tr>
<tr><td>Python</td></tr>
<tr><td>Ruby</td></tr>
<tr><td>PHP</td></tr>
<tr><td>C#</td></tr>
<tr><td>Go</td></tr>
<tr><td>Elixir</td></tr>
<tr><td>(Java) Spring AMQP</td></tr>
<tr><td>Swift</td></tr>
<tr><td>Objective-C</td></tr>
<tr><td>Clojure</td></tr>
</table>

<p>U některých výše zmíněných jazyků je k&nbsp;dispozici dokonce větší množství
knihoven. V&nbsp;dnešním článku se zaměříme především na programovací jazyk
Python, pro nějž existuje mj.&nbsp;i knihovna nazvaná <i>Pika</i>, která je
samozřejmě instalovatelná přes PyPi (<a
href="https://pypi.org/project/pika/">https://pypi.org/project/pika/</a>).
Abychom se ovšem nedrželi pouze čistého mainstreamu, ukážeme si v&nbsp;závěru
článku i volání funkcí systému RabbitMQ <a
href="https://www.clojure.org/">z&nbsp;programovacího jazyka Clojure</a>
s&nbsp;využitím knihovny <a
href="http://clojurerabbitmq.info/">Langohr</a>.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Protokoly podporované systémem RabbitMQ</h2>

<p>Se systémem RabbitMQ mohou další části aplikace komunikovat s&nbsp;využitím
několika protokolů, které se od sebe odlišují svými vlastnostmi (binární vs.
textový protokol), složitostí implementace, sémantikou příkazů atd.</p>

<p>Popis podporovaných protokolů musíme začít zmínkou o podpoře AMQP
(<i>Advanced Message Queuing Protocol</i>) verze 0-9-1, 0-9 a 0-8, protože
RabbitMQ původně vznikl právě z&nbsp;toho důvodu, aby podporoval tyto standardy
AMQP. Jedná se o binární protokol, v&nbsp;němž je velká váha kladena nejen na
precizní specifikaci formátu dat, ale i na popis sémantiky operací prováděných
službami, které AMQP implementují (či možná lépe řečeno akceptují). Jak uvidíme
dále, jsou termíny používané v&nbsp;dokumentaci RabbitMQ odvozeny právě od
terminologie převzaté ze specifikace AMQP. Specifikace pro verzi 0-9-1 je
dostupná na stránce <a
href="https://www.rabbitmq.com/resources/specs/amqp0-9-1.pdf">https://www.rabbitmq.com/resources/specs/amqp0-9-1.pdf</a>.</p>

<p><div class="rs-tip-major">Poznámka: verze uvádím schválně s&nbsp;pomlčkami
namísto dnes obvyklejších teček, protože právě takto se verze označují
v&nbsp;oficiální specifikaci a umožní vám přesnější hledání dalších
informací.</div></p>

<p>Kromě verzí 0-9-1, 0-9 a 0-8 existuje ještě protokol AMQP verze 1.0. Jedná
se o protokol, který je i přes shodné jméno značně odlišný od předchozích
verzí. RabbitMQ sice ve své základní konfiguraci tento protokol
<strong>ne</strong>podporuje, ovšem je možné si nainstalovat přídavný modul
(<i>plugin</i>), který podporu do Rabbitu přidává. Další informace o tomto
modulu naleznete v&nbsp;jeho repositáři na adrese <a
href="https://github.com/rabbitmq/rabbitmq-amqp1.0">https://github.com/rabbitmq/rabbitmq-amqp1.0</a>
(v&nbsp;článku ani v&nbsp;demonstračních příkladech ho nepoužijeme).</p>

<p>Třetím protokolem, který lze použít pro komunikaci s&nbsp;frontami Rabbita,
je protokol nazvaný <a href="http://stomp.github.io/">STOMP</a> neboli
<i>Streaming Text Oriented Messaging Protocol</i>. Jedná se o relativně
jednoduchý protokol založený &ndash; jak jeho název napovídá &ndash; na
příkazech posílaných v&nbsp;textovém formátu se syntaxí, která se podobá
protokolu HTTP. Předností je snadná implementace klientů a v&nbsp;případě
potřeby (ladění, simulace útoků atd.) je dokonce možné namísto dedikovaného
klienta použít běžný <a
href="https://linux.die.net/man/1/telnet">telnet</a>.</p>

<p>Posledním protokolem, o němž se zmíníme a který je podporován přes plugin
(stejně jako AMQP 1.0), je protokol nazvaný <a
href="http://mqtt.org/">MQTT</a>, který je mj.&nbsp;určený pro dnes populární
IoT, tj.&nbsp;obecně pro zařízení s&nbsp;relativně malým výkonem
popř.&nbsp;omezenými systémovými zdroji (a většinou i omezenou odolností proti
útokům :).</p>

<p><div class="rs-tip-major">Poznámka: díky tomu, že v&nbsp;demonstračních
příkladech použijeme již připravené knihovny zajišťující rozhraní
k&nbsp;RabbituMQ, se přímo s&nbsp;použitím těchto protokolů ve skutečnosti
nesetkáme. Později si ovšem pro úplnost ukážeme, jak lze naprogramovat
jednoduchého klienta používajícího protokol STOMP.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Ukázky základních způsobů použití nástroje RabbitMQ</h2>

<p>Samotný RabbitMQ je možné použít mnoha různými způsoby. Na nejnižší úrovni
se na tento systém můžeme dívat jako na klasickou a jednoduchou frontu zpráv
(<i>message queue</i>). Tuto frontu je přitom možné nakonfigurovat takovým
způsobem, aby byla zachována její robustnost, tj.&nbsp;aby zprávy ve frontě
přežily restart serveru RabbitMQ a aby bylo zaručeno doručení zprávy (příjemce
ovšem musí potvrdit, že zprávu převzal a nějakým způsobem zpracoval, což si
ukážeme na praktických příkladech). Tuto konfiguraci můžete použít kdykoli je
nutné propojit několik komponent do složitější architektury, přičemž jedna
z&nbsp;komponent bude produkovat zprávy (data, příkazy) a další
komponenta/komponenty zprávy přijímat a asynchronně je zpracovávat:</p>

<a href="https://www.root.cz/obrazek/348762/"><img src="https://i.iinfo.cz/images/176/rabbitmq1-1-prev.png" class="image-348762" alt="&#160;" width="370" height="62" /></a>
<p><i>Obrázek 1: RabbitMQ je možné použít jako jednoduchou frontu zpráv,
přičemž zpráva může vznikat na jiném počítači, než na kterém běží samotná
fronta. I příjemce může být provozován na samostatném počítači (počítačích).
Počet front, které jsou pojmenovány, není žádným drastickým způsobem omezen
&ndash; v&nbsp;praxi se může jednat o stovky front.</i></p>

<p>RabbitMQ se dále poměrně často používá v&nbsp;roli brokera i pro plánování a
asynchronní spouštění úloh. Ostatně přesně v&nbsp;této roli je RabbitMQ použit
i systémem <i>Celery</i>, s&nbsp;nímž jsme se seznámili v&nbsp;předchozích dvou
článcích [<a
href="https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python/">1</a>]
[<a
href="https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python-dokonceni/"></a>].</p>

<a href="https://www.root.cz/obrazek/348763/"><img src="https://i.iinfo.cz/images/176/rabbitmq1-2-prev.png" class="image-348763" alt="&#160;" width="370" height="60" /></a>
<p><i>Obrázek 2: RabbitMQ jako klasický broker využívaný dalšími
systémy.</i></p>

<p>V&nbsp;případě, že se RabbitMQ využívá v&nbsp;roli brokera, umožňuje
připojení různých konzumentů a nastavení strategií pro směrování zpráv mezi
producenty a konzumenty. Samozřejmě je implementováno i rozložení zátěže mezi
větší množství konzumentů v&nbsp;případě, že všichni tito konzumenti
implementují stejnou logiku (službu). S&nbsp;tímto systémem jsme se ostatně již
setkali při popisu Redis Queue i Celery, v&nbsp;nichž bylo relativně snadné
spustit větší množství workerů a celou aplikaci tak škálovat podle potřeby:</p>

<a href="https://www.root.cz/obrazek/348764/"><img src="https://i.iinfo.cz/images/176/rabbitmq1-3-prev.png" class="image-348764" alt="&#160;" width="370" height="125" /></a>
<p><i>Obrázek 3: Počet konzumentů není v&nbsp;podstatě nijak omezen.</i></p>

<p>Dále je možné nakonfigurovat rozvětvení (<i>fanout</i>) zpráv,
tj.&nbsp;každá zpráva může být doručena většímu množství příjemců. Příkladem
může být vzájemná distribuce textových zpráv mezi několika servery
implementující internetová &bdquo;kecátka&ldquo; (Slack, Mattermost,
Jabber/XMPP...). Každý server přitom může současně vystupovat v&nbsp;roli
příjemce zpráv i producenta zpráv.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Směrování zpráv před jejich vložením do fronty</h2>

<p>Interní struktura nástroje RabbitMQ je ve skutečnosti mnohem složitější, než
by se mohlo na první pohled zdát. Ústředním prvkem jsou samozřejmě fronty se
zprávami, ovšem před samotnými frontami je umístěn takzvaný <i>exchange</i>
sloužící pro směrování zpráv do jednotlivých front:</p>

<a href="https://www.root.cz/obrazek/348765/"><img src="https://i.iinfo.cz/images/176/rabbitmq1-4-prev.png" class="image-348765" alt="&#160;" width="370" height="158" /></a>
<p><i>Obrázek 4: Interní konfigurovatelná struktura systému RabbitMQ.</i></p>

<p><div class="rs-tip-major">Poznámka: termíny &bdquo;exchange&ldquo; a
&bdquo;binding&ldquo; vychází právě ze specifikace AMQP,.</div></p>

<p>Samotný broker, v&nbsp;tomto případě RabbitMQ, podporuje několik strategií
pro rozhodnutí, do jaké fronty či do jakých front se má přijatá zpráva vložit.
Každá z&nbsp;těchto strategií je samozřejmě plně konfigurovatelná a má své
jméno, které je dobré znát při hledání podrobnějších informací
v&nbsp;dokumentaci:</p>

<ul>

<li>Nejjednodušší strategie se jmenuje <i>direct</i>. Tato strategie je
založena na tom, že samotná zpráva obsahuje klíč (<i>key</i>), který slouží pro
výběr správné fronty. Pokud budeme mít k&nbsp;dispozici jedinou frontu a budeme
používat jeden klíč, celý broker se nám vlastně zúží na &bdquo;obyčejnou&ldquo;
frontu zpráv podporující různé protokoly a nabízejí řešení s&nbsp;vysokou
dostupností. Klíč je reprezentován jako běžný řetězec.</li>

<li>Další strategie se nazývá <i>topic</i>. Jedná se o složitější formu
navázání zprávy na frontu, v&nbsp;němž se opět používá klíč uložený ve zprávě.
Tento klíč se porovnává s&nbsp;regulárními výrazy specifikovanými
v&nbsp;konfiguraci směrovače. Ve chvíli, kdy klíč odpovídá nějakému regulárnímu
výrazu, je zpráva přesměrována do příslušné fronty. Můžeme tak například velmi
snadno směrovat zprávy do různých front (a tím pádem i do různých workerů) na
základě doménového jména serveru, kde zpráva vznikla apod.</li>

<li>Třetí strategie používá hlavičky (<i>headers</i>) připojené ke zprávě. To
umožňuje detailnější konfiguraci směrování; podrobnosti si popíšeme
v&nbsp;navazujícím článku.</li>

<li>A konečně čtvrtá strategie se nazývá <i>fanout</i>. Při použití této
strategie se přijatá zpráva přenese (zduplikuje) do několika nakonfigurovaných
front, což znamená, že bude přijata a zpracována několikrát. V&nbsp;praxi se
například může jednat o přeposlání zprávy napsané klientem na různé servery
implementující nějakou internetovou komunikační službu (Slack atd.).</li>

</ul>

<p>V&nbsp;dnešním článku se budeme převážně zabývat první strategií,
tj.&nbsp;přímým přeposláním přijaté zprávy do fronty určené klíčem ve zprávě.
Trošku předběhneme, ovšem asi je vhodné si ukázat, jak se vlastně zpráva
s&nbsp;klíčem pošle. Ve chvíli, kdy má klient nakonfigurovaný a otevřený
komunikační kanál na brokera, může zprávu s&nbsp;klíčem poslat takto:</p>

<pre>
channel.basic_publish(exchange='',
                      routing_key='test',
                      body='Hello World!')
</pre>

<p>Povšimněte si, že se u zprávy specifikuje jak její hodnota/tělo
(v&nbsp;našem případě se jedná o pouhopouhý řetězec), tak i klíč a popř.&nbsp;i
jméno tzv.&nbsp;exchange, která souvisí s&nbsp;vybranou strategií.
V&nbsp;případě, že strategie není specifikována, což je ostatně náš případ,
bude RabbitMQ server předpokládat výchozí volbu exchange (viz též podrobnější
popis na stránce <a
href="http://www.rabbitmq.com/amqp-0-9-1-reference.html#basic.publish">http://www.rabbitmq.com/amqp-0-9-1-reference.html#basic.publish</a>).</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Instalace RabbitMQ a konfigurace jeho síťového rozhraní</h2>

<p>Instalace systému RabbitMQ je na mainstreamových distribucích velmi snadná,
pokud se ovšem spokojíme s&nbsp;tím, že může být použita poněkud starší verze
Rabbitu. Balíček nazvaný <strong>rabbitmq-server</strong> je dostupný ve
standardních repositářích Debianu, Ubuntu, RHELu, CentOSu i Fedory. Vyzkoušejme
si instalaci na Fedoře, v&nbsp;níž byla v&nbsp;době instalace dostupná verze
3.6.16 (nejnovější verze Rabbitu je přitom 3.7.9). Instalaci provedeme ze
standardního repositáře přičemž se společně s&nbsp;Rabbitem nainstaluje i
běhové prostředí Erlangu:</p>

<pre>
# <strong>dnf install rabbitmq-server</strong>
&nbsp;
Last metadata expiration check: 0:22:16 ago on Fri 16 Nov 2018 10:14:57 AM EST.
Dependencies resolved.
=========================================================================================================================================================
 Package                                     Arch                          Version                                    Repository                    Size
=========================================================================================================================================================
Installing:
 rabbitmq-server                             noarch                        3.6.16-3.fc29                              beaker-Fedora-Everything     4.7 M
Installing dependencies:
 erlang-asn1                                 x86_64                        20.3.8.9-2.fc29                            beaker-Fedora-Everything     742 k
 erlang-compiler                             x86_64                        20.3.8.9-2.fc29                            beaker-Fedora-Everything     1.1 M
 erlang-crypto                               x86_64                        20.3.8.9-2.fc29                            beaker-Fedora-Everything     124 k
 erlang-eldap                                x86_64                        20.3.8.9-2.fc29                            beaker-Fedora-Everything     111 k
 erlang-erts                                 x86_64                        20.3.8.9-2.fc29                            beaker-Fedora-Everything     2.0 M
 erlang-hipe                                 x86_64                        20.3.8.9-2.fc29                            beaker-Fedora-Everything     2.8 M
 erlang-inets                                x86_64                        20.3.8.9-2.fc29                            beaker-Fedora-Everything     781 k
 erlang-kernel                               x86_64                        20.3.8.9-2.fc29                            beaker-Fedora-Everything     1.1 M
 erlang-mnesia                               x86_64                        20.3.8.9-2.fc29                            beaker-Fedora-Everything     767 k
 erlang-os_mon                               x86_64                        20.3.8.9-2.fc29                            beaker-Fedora-Everything     110 k
 erlang-otp_mibs                             x86_64                        20.3.8.9-2.fc29                            beaker-Fedora-Everything      27 k
 erlang-public_key                           x86_64                        20.3.8.9-2.fc29                            beaker-Fedora-Everything     604 k
 erlang-runtime_tools                        x86_64                        20.3.8.9-2.fc29                            beaker-Fedora-Everything     208 k
 erlang-sasl                                 x86_64                        20.3.8.9-2.fc29                            beaker-Fedora-Everything     290 k
 erlang-sd_notify                            x86_64                        1.0-8.fc29                                 beaker-Fedora-Everything      14 k
 erlang-snmp                                 x86_64                        20.3.8.9-2.fc29                            beaker-Fedora-Everything     1.7 M
 erlang-ssl                                  x86_64                        20.3.8.9-2.fc29                            beaker-Fedora-Everything     859 k
 erlang-stdlib                               x86_64                        20.3.8.9-2.fc29                            beaker-Fedora-Everything     2.9 M
 erlang-syntax_tools                         x86_64                        20.3.8.9-2.fc29                            beaker-Fedora-Everything     408 k
 erlang-tools                                x86_64                        20.3.8.9-2.fc29                            beaker-Fedora-Everything     638 k
 erlang-xmerl                                x86_64                        20.3.8.9-2.fc29                            beaker-Fedora-Everything     995 k
 lksctp-tools                                x86_64                        1.0.16-10.fc29                             beaker-Fedora-Everything      92 k
 logrotate                                   x86_64                        3.14.0-4.fc29                              beaker-Fedora-Everything      68 k
 xemacs-filesystem                           noarch                        21.5.34-30.20171230hg92757c2b8239.fc29     beaker-Fedora-Everything      10 k
&nbsp;
Transaction Summary
=========================================================================================================================================================
Install  25 Packages
&nbsp;
Total download size: 23 M
Installed size: 36 M
Is this ok [y/N]
&nbsp;
Downloading Packages:
(1/25): erlang-crypto-20.3.8.9-2.fc29.x86_64.rpm                                                                              1.4 MB/s | 124 kB     00:00
(2/25): erlang-asn1-20.3.8.9-2.fc29.x86_64.rpm                                                                                5.9 MB/s | 742 kB     00:00
(24/25): xemacs-filesystem-21.5.34-30.20171230hg92757c2b8239.fc29.noarch.rpm                                                  218 kB/s |  10 kB     00:00
(25/25): rabbitmq-server-3.6.16-3.fc29.noarch.rpm                                                                              21 MB/s | 4.7 MB     00:00
--------------------------------------------------------------------------------------------------------------------------------------------------------------
Total                                                                                                                          27 MB/s |  23 MB     00:00
Running transaction check
Transaction check succeeded.
Running transaction test
Transaction test succeeded.
&nbsp;
Installed:
  rabbitmq-server-3.6.16-3.fc29.noarch                                          erlang-asn1-20.3.8.9-2.fc29.x86_64                        erlang-compiler-20.3.8.9-2.fc29.x86_64
  erlang-crypto-20.3.8.9-2.fc29.x86_64                                          erlang-eldap-20.3.8.9-2.fc29.x86_64                       erlang-erts-20.3.8.9-2.fc29.x86_64
  erlang-hipe-20.3.8.9-2.fc29.x86_64                                            erlang-inets-20.3.8.9-2.fc29.x86_64                       erlang-kernel-20.3.8.9-2.fc29.x86_64
  erlang-mnesia-20.3.8.9-2.fc29.x86_64                                          erlang-os_mon-20.3.8.9-2.fc29.x86_64                      erlang-otp_mibs-20.3.8.9-2.fc29.x86_64
  erlang-public_key-20.3.8.9-2.fc29.x86_64                                      erlang-runtime_tools-20.3.8.9-2.fc29.x86_64               erlang-sasl-20.3.8.9-2.fc29.x86_64
  erlang-sd_notify-1.0-8.fc29.x86_64                                            erlang-snmp-20.3.8.9-2.fc29.x86_64                        erlang-ssl-20.3.8.9-2.fc29.x86_64
  erlang-stdlib-20.3.8.9-2.fc29.x86_64                                          erlang-syntax_tools-20.3.8.9-2.fc29.x86_64                erlang-tools-20.3.8.9-2.fc29.x86_64
  erlang-xmerl-20.3.8.9-2.fc29.x86_64                                           lksctp-tools-1.0.16-10.fc29.x86_64                        logrotate-3.14.0-4.fc29.x86_64
  xemacs-filesystem-21.5.34-30.20171230hg92757c2b8239.fc29.noarch
&nbsp;
Complete!
</pre>

<p>Po úspěšné instalaci si můžeme vyzkoušet server přímo spustit. V&nbsp;praxi
se sice přímé spouštění neprování (lepší je RabbitMQ spustit jako démona), ale
pro první odzkoušení, zda jsou dostupné všechny knihovny, je to pravděpodobně
nejjednodušší cesta:</p>

<pre>
$ <strong>su -</strong>
&nbsp;
# <strong>rabbitmq-server</strong>
&nbsp;
              RabbitMQ 3.6.16. Copyright (C) 2007-2018 Pivotal Software, Inc.
  ##  ##      Licensed under the MPL.  See http://www.rabbitmq.com/
  ##  ##
  ##########  Logs: /var/log/rabbitmq/rabbit@intel-sugarbay-dh-02.log
  ######  ##        /var/log/rabbitmq/rabbit@intel-sugarbay-dh-02-sasl.log
  ##########
              Starting broker...
 completed with 0 plugins.
</pre>

<p>Pokud se spuštění podařilo, server ukončíme stiskem klávesové zkratky
<strong>Ctrl+C</strong> a před dalšími pokusy omezíme možnosti síťového
připojení takovým způsobem, aby se k&nbsp;serveru mohly připojit pouze lokální
uživatelé a lokální služby. V&nbsp;souboru
<strong>/etc/rabbitmq/rabbitmq.config</strong> je nutné provést následující
změny, kterými se zajistí, že server bude přijímat pouze lokální požadavky:</p>

<pre>
[
 {rabbit,
  [
   {tcp_listeners, [{"127.0.0.1", 5672},
                    {"::1",       5672}]}
  ]
  ...
  ...
  ...
  }]
</pre>

<p><div class="rs-tip-major">Poznámka: na konci řádku končícího
&bdquo;5672}]}&ldquo; je nutné zapsat čárku v&nbsp;případě, že následují další
volby. Konfigurační soubor ve výchozím stavu však žádné další volby neobsahuje,
resp.&nbsp;přesněji řečeno jsou všechny další řádky zakomentovány.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Spuštění serveru ve funkci démona/služby</h2>

<p>Většinou se RabbitMQ spouští ve funkci démona resp.&nbsp;služby. Pro
operační systémy s&nbsp;klasickým Init systémem postačuje provést:</p>

<pre>
# <strong>chkconfig rabbitmq-server on</strong>
# <strong>service rabbitmq-server start</strong>
</pre>

<p>Pro systému používající Systemd lze použít buď předchozí příkazy (ty jsou
transformovány na příkazy nové), nebo:</p>

<pre>
# <strong>systemctl enable rabbitmq-server.service</strong>
# <strong>systemctl start rabbitmq-server.service</strong>
</pre>

<p>S&nbsp;kontrolou, zda se spuštění služby podařilo:</p>

<pre>
# <strong>systemctl status rabbitmq-server.service </strong>
&nbsp;
● rabbitmq-server.service - RabbitMQ broker
   Loaded: loaded (/usr/lib/systemd/system/rabbitmq-server.service; enabled; ven
   Active: active (running) since Wed 2018-12-19 14:39:45 CET; 33s ago
 Main PID: 20495 (beam.smp)
   Status: "Initialized"
    Tasks: 143 (limit: 4915)
   CGroup: /system.slice/rabbitmq-server.service
           ├─20495 /usr/lib64/erlang/erts-8.3.5.4/bin/beam.smp -W w -A 128 -P 10
           ├─20774 erl_child_setup 1024
           ├─20790 inet_gethost 4
           └─20791 inet_gethost 4
&nbsp;
pro 19 14:39:43 localhost.localdomain systemd[1]: Starting RabbitMQ broker...
pro 19 14:39:44 localhost.localdomain rabbitmq-server[20495]:               Rabb
pro 19 14:39:44 localhost.localdomain rabbitmq-server[20495]:   ##  ##      Lice
pro 19 14:39:44 localhost.localdomain rabbitmq-server[20495]:   ##  ##
pro 19 14:39:44 localhost.localdomain rabbitmq-server[20495]:   ##########  Logs
pro 19 14:39:44 localhost.localdomain rabbitmq-server[20495]:   ######  ##      
pro 19 14:39:44 localhost.localdomain rabbitmq-server[20495]:   ##########
pro 19 14:39:44 localhost.localdomain rabbitmq-server[20495]:               Star
pro 19 14:39:45 localhost.localdomain systemd[1]: Started RabbitMQ broker.
pro 19 14:39:45 localhost.localdomain rabbitmq-server[20495]:  completed with 0 
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Instalace knihovny Pika s&nbsp;rozhraním mezi RabbitMQ a Pythonem</h2>

<p>Posledním přípravným krokem je instalace knihovny Pika, která programátorům
nabízí rozhraní mezi systémem RabbitMQ na straně jedné a Pythonem
(resp.&nbsp;skripty napsanými v&nbsp;Pythonu) na straně druhé. Instalaci
provedeme přes nástroj <strong>pip3</strong>, přičemž budeme specifikovat, že
se má instalace provést pouze pro aktivního uživatele, aby se nezasahovalo do
systémových knihoven a modulů:</p>

<pre>
$ <strong>pip3 install --user pika</strong>
&nbsp;
Collecting pika
  Using cached https://files.pythonhosted.org/packages/bf/48/72de47f63ba353bacd74b76bb65bc63620b0706d8b0471798087cd5a4916/pika-0.12.0-py2.py3-none-any.whl
Installing collected packages: pika
Successfully installed pika-0.12.0
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. První příklad: nejjednodušší možná implementace systému producent+konzument</h2>

<p>V&nbsp;této chvíli je náš testovací počítač připraven na příjem zpráv od
producentů a na jejich následné zpracování konzumenty. Nejprve si ukažme, jak
může vypadat producent. Jedná se o velmi krátký skript naprogramovaný
v&nbsp;Pythonu, který se nejdříve připojí k&nbsp;serveru RabbitMQ, následně
požádá o vytvoření či o zpřístupnění fronty nazvané &bdquo;test&ldquo;, pošle
do fronty zprávu (nepřímo přes exchange) a následně zavře připojení
k&nbsp;serveru:</p>

<pre>
import pika
&nbsp;
<i># připojení k serveru RabbitMQ a vytvoření komunikačního kanálu</i>
connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()
&nbsp;
<i># žádost o vytvoření či o použití fronty &bdquo;test&ldquo;</i>
channel.queue_declare(queue='test')
&nbsp;
<i># poslání zprávy se strategií direct</i>
channel.basic_publish(exchange='',
                      routing_key='test',
                      body='Hello World!')
&nbsp;
print("Sent 'Hello World!'")
<i># uzavření komunikace</i>
connection.close()
</pre>

<p>Zajímavý je řádek:</p>

<pre>
channel.queue_declare(queue='test')
</pre>

<p>V&nbsp;případě, že fronta nazvaná &bdquo;test&ldquo; neexistuje, je
vytvořena. Pokud však fronta s&nbsp;tímto jménem existuje, nic se neděje
&ndash; nedojde k&nbsp;jejímu vymazání ani k&nbsp;vyprázdnění (operace je
idempotentní).</p>

<p>Dále si povšimněte, že používáme shodné jméno klíče a fronty. To je
v&nbsp;pořádku, protože ve výchozím nastavení se využívá strategie
<i>direct</i>, která přesměruje zprávu do fronty, jejíž název odpovídá
klíči.</p>

<p>Pokud nyní výše uvedený skript spustíme:</p>

<pre>
$ <strong>python3 enqueue_work.py</strong>
</pre>

<p>... měla by se do fronty &bdquo;test&ldquo; vložit jediná zpráva. O tom se
můžeme snadno přesvědčit s&nbsp;využitím nástroje
<strong>rabbitmqctl</strong>:</p>

<pre>
$ <strong>sudo rabbitmqctl list_queues</strong>
&nbsp;
Listing queues
test    1
</pre>

<p>Samozřejmě je možné do fronty poslat větší počet zpráv, a to mírně upraveným
producentem:</p>

<pre>
#!/usr/bin/env python
import pika
&nbsp;
connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()
&nbsp;
channel.queue_declare(queue='test')
&nbsp;
for i in range(1, 11):
    channel.basic_publish(exchange='',
                          routing_key='test',
                          body='Hello World! #{i}'.format(i=i))
&nbsp;
print("Sent 'Hello World!' ten times")
connection.close()
</pre>

<p>Nyní by se mělo ve frontě nacházet jedenáct zpráv &ndash; jedna původní a
deset nových:</p>

<pre>
$ <strong>sudo rabbitmqctl list_queues</strong>
&nbsp;
Listing queues
test    11
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Konzument zpráv</h2>

<p>Implementace konzumenta (příjemce) zpráv je nepatrně složitější, protože je
nutné deklarovat <i>callback</i> funkci automaticky zavolanou ve chvíli, kdy je
zpráva z&nbsp;fronty přijata. Pro tento účel se používá metoda:</p>

<pre>
channel.basic_consume(on_receive,
                      queue='test',
                      no_ack=True)
</pre>

<p>Této metodě se předá reference na již zmíněnou callback funkci, dále jméno
fronty, ze které se mají zprávy přijímat a konečně jako nepovinný parametr lze
specifikovat, zda bude konzument aktivně informovat systém RabbitMQ o tom, že
zpráva byla zpracována. Prozatím potvrzování o zpracování zpráv nebudeme
potřebovat, takže parametr <strong>no_ack</strong> nastavíme na
<strong>True</strong>.</p>

<p>Celá implementace konzumenta zpráv bude vypadat takto:</p>

<pre>
#!/usr/bin/env python
import pika
&nbsp;
<i># připojení k serveru RabbitMQ a vytvoření komunikačního kanálu</i>
connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()
&nbsp;
<i># pokus o nové vytvoření fronty ve skutečnosti neovlivní již existující frontu</i>
<i># pokud samozřejmě existuje</i>
channel.queue_declare(queue='test')
&nbsp;
&nbsp;
<i># callback funkce volaná při přijetí zprávy</i>
def on_receive(ch, method, properties, body):
    print("Received %r" % body)
&nbsp;
&nbsp;
<i># přihlášení se k odebírání zpráv z fronty "test"</i>
channel.basic_consume(on_receive,
                      queue='test',
                      no_ack=True)
&nbsp;
print('Waiting for messages. To exit press CTRL+C')
print("...")
&nbsp;
<i># smyčka s odebíráním zpráv</i>
channel.start_consuming()
</pre>

<p>V&nbsp;případě, že konzumenta spustíme, zpracuje všechny zbývající zprávy
z&nbsp;fronty &bdquo;test&ldquo;. Pokud jste v&nbsp;předchozí kapitole
postupovali podle návodu, mělo by se jednat o jedenáct zpráv:</p>

<pre>
$ <strong>python3 consumer.py</strong>
&nbsp;
Waiting for messages. To exit press CTRL+C
...
Received b'Hello World!'
Received b'Hello World! #1'
Received b'Hello World! #2'
Received b'Hello World! #3'
Received b'Hello World! #4'
Received b'Hello World! #5'
Received b'Hello World! #6'
Received b'Hello World! #7'
Received b'Hello World! #8'
Received b'Hello World! #9'
Received b'Hello World! #10'
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Přenos společných prvků producenta a konzumenta do jednoho zdrojového kódu</h2>

<p>Před dalšími pokusy nepatrně upravíme kód producenta i konzumenta
(spotřebitele), protože jsme mohli vidět, že samotné připojení k&nbsp;serveru
RabbitMQ je realizováno shodným kódem. Z&nbsp;tohoto kódu je tedy možné
vytvořit <a
href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example02/rabbitmq_connect.py">samostatný modul</a>, který může vypadat následovně:</p>

<pre>
import pika
&nbsp;
&nbsp;
def connect(where='localhost', queue_name='test'):
    <i># připojení k serveru RabbitMQ a vytvoření komunikačního kanálu</i>
    connection = pika.BlockingConnection(pika.ConnectionParameters(where))
    channel = connection.channel()
&nbsp;
    <i># pokus o nové vytvoření fronty ve skutečnosti neovlivní již existující frontu</i>
    <i># pokud samozřejmě existuje</i>
    channel.queue_declare(queue=queue_name)
    return connection, channel
</pre>

<p>Skript, který po svém spuštění vytvoří jednu zprávu a vloží ji do fronty
&bdquo;test&ldquo;, se <a
href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example02/enqueue_work.py">zjednoduší</a>:</p>

<pre>
#!/usr/bin/env python
import pika
&nbsp;
connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
connection, channel = connect()
&nbsp;
channel.basic_publish(exchange='',
                      routing_key='test',
                      body='Hello World!')
&nbsp;
print("Sent 'Hello World!'")
connection.close()
</pre>

<p>Podobným způsobem se zjednoduší i <a
href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example02/enqueue_more_work.py">skript
pro vytvoření deseti zpráv</a>:</p>

<pre>
#!/usr/bin/env python
from rabbitmq_connect import connect
&nbsp;
connection, channel = connect()
&nbsp;
for i in range(1, 11):
    channel.basic_publish(exchange='',
                          routing_key='test',
                          body='Hello World! #{i}'.format(i=i))
&nbsp;
print("Sent 'Hello World!' ten times")
connection.close()
</pre>

<p>Prakticky stejná úprava se samozřejmě dotkne <a
href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example02/consumer.py">i
konzumenta zpráv</a>:</p>

<pre>
#!/usr/bin/env python
from rabbitmq_connect import connect
&nbsp;
connection, channel = connect()
&nbsp;
def on_receive(ch, method, properties, body):
    print("Received %r" % body)
&nbsp;
&nbsp;
channel.basic_consume(on_receive,
                      queue='test',
                      no_ack=True)
&nbsp;
print('Waiting for messages. To exit press CTRL+C')
print("...")
channel.start_consuming()
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Pomalá práce příjemce zpráv a způsob dělby práce mezi větší množství workerů</h2>

<p>Pro další testování nepatrně upravíme kód konzumenta takovým způsobem, aby
simuloval (sic!) složitější a déletrvající práci. Pro naše účely bude
postačovat, když bude konzument v&nbsp;callback funkci zavolané při příjmu nové
zprávy čekat zhruba pět sekund:</p>

<pre>
def on_receive(ch, method, properties, body):
    print("Received %r" % body)
    sleep(5)
    print("Done processing %r" % body)
</pre>

<p>Pokud nyní spustíme dva konzumenty, každý v&nbsp;jiném terminálu, budeme
moci vidět, jak se dělí o práci.</p>

<p>První konzument:</p>

<pre>
$ <strong>python3 consumer.py </strong>
&nbsp;
Waiting for messages. To exit press CTRL+C
...
Received b'Hello World! #1'
Done processing b'Hello World! #1'
Received b'Hello World! #3'
Done processing b'Hello World! #3'
Received b'Hello World! #5'
Done processing b'Hello World! #5'
Received b'Hello World! #7'
Done processing b'Hello World! #7'
Received b'Hello World! #9'
Done processing b'Hello World! #9'
</pre>

<p>Druhý konzument:</p>

<pre>
$ <strong>python3 consumer.py </strong>
Waiting for messages. To exit press CTRL+C
...
Received b'Hello World! #2'
Done processing b'Hello World! #2'
Received b'Hello World! #4'
Done processing b'Hello World! #4'
Received b'Hello World! #6'
Done processing b'Hello World! #6'
Received b'Hello World! #8'
Done processing b'Hello World! #8'
Received b'Hello World! #10'
Done processing b'Hello World! #10'
</pre>

<p>Toto rozdělování práce ve skutečnosti provádí přímo RabbitMQ a nazývá se
&bdquo;round robin&ldquo;. V&nbsp;dalším textu poznáme, že výchozí chování není
ideální ve chvíli, kdy se konzumenti (workeři) připojují a odpojují
dynamicky.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Potvrzování zpracování zprávy, chování systému ve chvíli, kdy zpráva není zpracována</h2>

<p>V&nbsp;předchozích příkladech jste si mohli povšimnout, že se konzument
připojoval k&nbsp;RabbitMQ následovně:</p>

<pre>
channel.basic_consume(on_receive,
                      queue='test',
                      <strong>no_ack=True</strong>)
</pre>

<p>Posledním pojmenovaným parametrem jsme specifikovali, že jakmile konzument
zprávu z&nbsp;fronty odebere, je zpráva považována za doručenou a RabbitMQ ji
z&nbsp;fronty odstraní a úspěšně na ni zapomene. Ovšem v&nbsp;praxi se může
stát (a na produkci zcela jistě tato situace nastane!), že konzument
z&nbsp;nějakého důvodu zhavaruje nebo nebude připraven zpracování zprávy
dokončit. Pokud budeme chtít, aby se v&nbsp;takovém případě zpráva vrátila zpět
do fronty (a byla například zpracována jiným strojem), musíme připojení
nepatrně upravit:</p>

<pre>
channel.basic_consume(on_receive,
                      queue='test',
                      <strong>no_ack=False</strong>)
</pre>

<p>V&nbsp;tomto případě se konzument zavazuje k&nbsp;tomu, že (ideálně) až na
konci zpracování potvrdí zpracování zprávy:</p>

<pre>
ch.basic_ack(delivery_tag = method.delivery_tag)
</pre>

<p>V&nbsp;případě, že RabbitMQ nedostane informaci o zpracování zprávy, vloží
ji do k&nbsp;tomu určené fronty (podrobnosti, jak tyto fronty nakonfigurovat,
si řekneme příště).</p>

<p>Vylepšený kód konzumenta tedy může vypadat následovně:</p>

<pre>
#!/usr/bin/env python
&nbsp;
from time import sleep
from rabbitmq_connect import connect
&nbsp;
connection, channel = connect()
&nbsp;
def on_receive(ch, method, properties, body):
    print("Received %r" % body)
    sleep(5)
    print("Done processing %r" % body)
    <strong>ch.basic_ack(delivery_tag = method.delivery_tag)</strong>
&nbsp;
&nbsp;
channel.basic_consume(on_receive,
                      queue='test',
                      <strong>no_ack=False</strong>)
&nbsp;
print('Waiting for messages. To exit press CTRL+C')
print("...")
channel.start_consuming()
</pre>

<p><div class="rs-tip-major">Poznámka: samozřejmě můžeme zprávu potvrdit již
ihned při jejím přijetí, ovšem to se připravíte o významnou část funkcionality
systému RabbitMQ.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Vylepšené chování RabbitMQ při &bdquo;dělbě práce&ldquo; mezi workery</h2>

<p><a href="#k12">Ve dvanácté kapitole</a> jsme si ukázali, že v&nbsp;případě,
že jsou spuštěni dva konzumenti (nebo pochopitelně větší množství konzumentů),
budou se spravedlivě dělit o práci, tj.&nbsp;o zpracování zpráv přidaných do
zvolené fronty. Ovšem samotná dělba práce není ve výchozím nastavení založena
na tom, jak jsou konzumenti (resp.&nbsp;workeři, kteří konzumenty implementují)
vytíženi, protože o tom, jaký konzument zprávu zpracuje, je rozhodnuto už ve
chvíli jejího přijetí do RabbitMQ. Toto chování není příliš vhodné, protože
systém jako celek nedokáže zareagovat například na přidání nového konzumenta do
systému. Toto chování si ostatně sami můžete otestovat ve chvíli, kdy nějaký
konzument již zpracovává zprávy &ndash; přidání (spuštění) nového konzumenta
nemá vliv na to, že původní konzument má svoji práci naplánovanou.</p>

<p>Aby RabbitMQ dokázal práci rozdělovat spravedlivěji a dynamicky podle
aktuálního zatížení, musíte v&nbsp;konzumentovi provést jednoduchou změnu:</p>

<pre>
<strong>channel.basic_qos(prefetch_count=1)</strong>
channel.basic_consume(on_receive,
                      queue='test',
                      no_ack=False)
</pre>

<p>Nyní je možné konzumenty přidávat popř.&nbsp;vypínat a systém by měl stále
spravedlivě rozdělovat práci a reagovat i na to, že některá úloha trvá delší
dobu.</p>

<p>Opět si pro úplnost ještě jednou vypišme celý kód konzumenta:</p>

<pre>
#!/usr/bin/env python
&nbsp;
from time import sleep
from rabbitmq_connect import connect
&nbsp;
connection, channel = connect()
&nbsp;
def on_receive(ch, method, properties, body):
    print("Received %r" % body)
    sleep(5)
    print("Done processing %r" % body)
    ch.basic_ack(delivery_tag = method.delivery_tag)
&nbsp;
&nbsp;
channel.basic_qos(prefetch_count=1)
channel.basic_consume(on_receive,
                      queue='test',
                      no_ack=False)
&nbsp;
print('Waiting for messages. To exit press CTRL+C')
print("...")
channel.start_consuming()
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Konzument zpráv naprogramovaný v&nbsp;jazyku Clojure</h2>

<p>V&nbsp;závěrečné části článku si ukážeme, jakým způsobem lze se systémem
RabbitMQ komunikovat z&nbsp;programovacího jazyka Clojure. Pro tento jazyk
vzniklo hned několik knihoven, které rozhraní k&nbsp;RabbitMQ realizují.
Většina těchto knihoven je postavena na tzv.&nbsp;Java interop
(interoperabilita mezi Javou a Clojure). Rozdíly mezi knihovnami spočívají
v&nbsp;tom, zda se skutečně jedná o pouhou úzkou vrstvičku mezi Javou a Clojure
či zda knihovna realizuje vlastní složitější (a abstraktnější) framework.
Protože se zabýváme především RabbitMQ a nikoli nad ním postavenými systémy,
použijeme knihovnu Langohr, která nám nebude poskytovat příliš abstraktní
operace, což je dobře, protože jediné, co budeme potřebovat, je získávání zpráv
z&nbsp;fronty s&nbsp;jejich dalším zpracováním.</p>

<p><div class="rs-tip-major">Poznámka: v dalším textu se předpokládá, že máte
nainstalován správce projektu Leiningen. Pokud tomu tak není, bude nutné si <a
href="https://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">Leiningen
nainstalovat</a>, což ve skutečnosti není nic těžkého. Navíc se jedná o velmi
užitečný projekt s&nbsp;mnoha přídavnými moduly, které využijete nejenom při
testování, ale například i při přípravě dokumentace nebo ve chvíli, kdy se
aplikace připravuje na deployment. To, zda je Leiningen nainstalován a lze ho
spustit zjistíte například příkazem <strong>which lein</strong>.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Konfigurace projektu využívajícího knihovnu Langohr</h2>

<p>Na úplném začátku si připravíme kostru projektu, který bude představovat
konzumenta. Pro vytvoření této kostry použijeme <i>Leiningen</i>. Kostra
projektu se při použití Leiningenu vytvoří příkazem:</p>

<pre>
$ <strong>lein new app example-01</strong>
&nbsp;
Generating a project called example-01 based on the 'app' template.
</pre>

<p>Výsledkem tohoto příkazu by měla být následující adresářová struktura:</p>

<pre>
.
├── CHANGELOG.md
├── doc
│   └── intro.md
├── LICENSE
├── project.clj
├── README.md
├── src
│   └── example_01
│       └── core.clj
└── test
    └── example_01
        └── core_test.clj
</pre>

<p>V&nbsp;dalším kroku přistoupíme k&nbsp;úpravám projektového souboru
<strong>project.clj</strong>. Po vytvoření nového projektu by projektový soubor
měl vypadat přibližně takto (pouze si pro jistotu zkontrolujte verzi
interpretru jazyka Clojure; minimální požadovaná verze je 1.8.0):</p>

<pre>
(defproject example-01 "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.8.0"]]
  :main ^:skip-aot example-01.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all}})
</pre>

<p>Úprava projektového souboru spočívá v&nbsp;přidání informace o tom, že se
v&nbsp;projektu bude používat knihovna <strong>langohr</strong> verze
5.0.0:</p>

<pre>
(defproject example-01 "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.8.0"]
                 <strong>[com.novemberain/langohr "5.0.0"]</strong>]
  :main ^:skip-aot example-01.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all}})
</pre>

<p>Posledním krokem konfigurace projektu je spuštění příkazu:</p>

<pre>
$ <strong>lein deps</strong>
</pre>

<p>Tento příkaz zajistí, že se do adresáře <strong>~/.m2/</strong> stáhnou
všechny potřebné knihovny, tj.&nbsp;jak <strong>langohr</strong>, tak i její
závislosti.</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Realizace konzumenta pro příjem zpráv</h2>

<p>Samotná implementace konzumenta zpráv (vzniklá úpravou <a
href="http://clojurerabbitmq.info/articles/getting_started.html">getting
started příkladu</a>) je při použití programovacího jazyka Clojure nepatrně
delší, než je tomu v&nbsp;případě Pythonu. Je tomu tak především proto, že
knihovna Langohr je rozdělena na víc částí a budeme muset provést import čtyř
konkrétních jmenných prostorů:</p>

<pre>
(require '[langohr.core      :as rabbit-mq])
(require '[langohr.channel   :as l-channel])
(require '[langohr.queue     :as l-queue])
(require '[langohr.consumers :as l-consumers])
</pre>

<p>Dále je v&nbsp;konzumentovi deklarována callback funkce zavolaná při příjmu
každé zprávy. Povšimněte si, že tělo zprávy (poslední parametr) je typu
<i>bytes</i>, ovšem v&nbsp;těle callback funkce ze sekvence bajtů vytvoříme
řetězec. Zajímavý je i <i>destructuring</i> [<a
href="http://clojure-doc.org/articles/language/functions.html#map-destructuring">1</a>]
použitý u druhého parametru. Jedná se o specialitu nabízenou některými
Lispovskými jazyky ve chvíli, kdy se do funkcí předávají sekvence, vektory nebo
mapy (slovníky):</p>

<pre>
(defn message-handler
    [ch {:keys [content-type delivery-tag type] :as meta} ^bytes payload]
    (println (format "Received a message: %s" (String. payload "UTF-8"))))
</pre>

<p>Zbývá nám provést připojení k&nbsp;RabbitMQ a vytvoření komunikačního
kanálu:</p>

<pre>
(let [conn  (rabbit-mq/connect)
      ch    (l-channel/open conn)]
</pre>

<p>Další postup je prakticky totožný s&nbsp;kódem naprogramovaným
v&nbsp;Pythonu: deklarace fronty, s&nbsp;níž se pracuje, přihlášení
k&nbsp;příjmu zpráv s&nbsp;registrací callback funkce a na konci aplikace úklid
&ndash; uzavření komunikačního kanálu a uzavření připojení k&nbsp;RabbitMQ:</p>

<pre>
(l-queue/declare ch "test" {:exclusive false :auto-delete false})
(l-consumers/subscribe ch "test" message-handler {:auto-ack true})
(println (format "Connected to channel id: %d" (.getChannelNumber ch)))
(Thread/sleep 10000)
(println "Disconnecting...")
(rabbit-mq/close ch)
(rabbit-mq/close conn)))
</pre>

<p>Výsledný kód realizující celého konzumenta vypadá následovně:</p>

<pre>
(ns example-01.core
    (:gen-class))
&nbsp;
(require '[langohr.core      :as rabbit-mq])
(require '[langohr.channel   :as l-channel])
(require '[langohr.queue     :as l-queue])
(require '[langohr.consumers :as l-consumers])
&nbsp;
&nbsp;
(defn message-handler
    [ch {:keys [content-type delivery-tag type] :as meta} ^bytes payload]
    (println (format "Received a message: %s" (String. payload "UTF-8"))))
&nbsp;
&nbsp;
(defn -main
    [&amp; args]
    (let [conn  (rabbit-mq/connect)
          ch    (l-channel/open conn)]
      (l-queue/declare ch "test" {:exclusive false :auto-delete false})
      (l-consumers/subscribe ch "test" message-handler {:auto-ack true})
      (println (format "Connected to channel id: %d" (.getChannelNumber ch)))
      (Thread/sleep 10000)
      (println "Disconnecting...")
      (rabbit-mq/close ch)
      (rabbit-mq/close conn)))
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Spuštění konzumenta a příjem zpráv</h2>

<p>Před spuštěním konzumenta přidáme do fronty &bdquo;test&ldquo; několik
zpráv. Můžeme přitom použít <a
href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example01/enqueue_more_work.py">skript</a>,
s&nbsp;nímž jsme se seznámili v&nbsp;první polovině článku. Tento skript vloží
do fronty deset zpráv, každou s&nbsp;jiným tělem:</p>

<pre>
$ <strong>cd message-queues-examples/rabbit-mq/python/example01/</strong>
&nbsp;
$ <strong>python3 enqueue_more_work.py </strong>
Sent 'Hello World!' ten times
</pre>

<p>Přesvědčíme se, že fronta existuje a není prázdná:</p>

<pre>
$ <strong>sudo rabbitmqctl list_queues</strong>
&nbsp;
Listing queues
test    10
</pre>

<p>Následně se již můžeme přepnout do adresáře s&nbsp;projektem naprogramovaným
v&nbsp;Clojure a spustit konzumenta:</p>

<pre>
$ <strong>cd message-queues-examples/rabbit-mq/clojure/example01/</strong>
&nbsp;
$ <strong>lein run</strong>
&nbsp;
Connected to channel id: 1
Received a message: Hello World! #1
Received a message: Hello World! #2
Received a message: Hello World! #3
Received a message: Hello World! #4
Received a message: Hello World! #5
Received a message: Hello World! #6
Received a message: Hello World! #7
Received a message: Hello World! #8
Received a message: Hello World! #9
Received a message: Hello World! #10
Disconnecting...
</pre>

<p>Vidíme, že konzument bez problémů přečetl všechny zprávy a příslušným
způsobem je zpracoval.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů naprogramovaných
v&nbsp;Pythonu a jednoho příkladu v&nbsp;Clojure byly uloženy do Git
repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/message-queues-examples">https://github.com/tisnik/message-queues-examples</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
doslova několik kilobajtů), můžete namísto toho použít odkazy na jednotlivé
příklady, které naleznete v&nbsp;následující tabulce.</p>

<p>Příklady v&nbsp;Pythonu:</p>

<table>
<tr><th>Příklad</th><th>Skript</th><th>Popis</th><th>Cesta</th></tr>
<tr><td>1</td><td>enqueue_work.py</td><td>skript pro vložení zprávy do fronty</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example01/enqueue_work.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example01/enqueue_work.py</a></td></tr>
<tr><td>1</td><td>enqueue_more_work.py</td><td>skript pro vložení deseti zpráv do fronty</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example01/enqueue_more_work.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example01/enqueue_more_work.py</a></td></tr>
<tr><td>1</td><td>consumer.py</td><td>implementace konzumenta (workera)</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example01/consumer.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example01/consumer.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>2</td><td>rabbitmq_connect.py</td><td>společná část pro producenta i konzumenta</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example02/rabbitmq_connect.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example02/rabbitmq_connect.py</a></td></tr>
<tr><td>2</td><td>enqueue_work.py</td><td>skript pro vložení zprávy do fronty</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example02/enqueue_work.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example02/enqueue_work.py</a></td></tr>
<tr><td>2</td><td>enqueue_more_work.py</td><td>skript pro vložení deseti zpráv do fronty</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example02/enqueue_more_work.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example02/enqueue_more_work.py</a></td></tr>
<tr><td>2</td><td>consumer.py</td><td>implementace konzumenta (workera)</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example02/consumer.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example02/consumer.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>rabbitmq_connect.py</td><td>společná část pro producenta i konzumenta</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example03/rabbitmq_connect.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example03/rabbitmq_connect.py</a></td></tr>
<tr><td>3</td><td>enqueue_work.py</td><td>skript pro vložení zprávy do fronty</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example03/enqueue_work.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example03/enqueue_work.py</a></td></tr>
<tr><td>3</td><td>enqueue_more_work.py</td><td>skript pro vložení deseti zpráv do fronty</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example03/enqueue_more_work.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example03/enqueue_more_work.py</a></td></tr>
<tr><td>3</td><td>consumer.py</td><td>implementace konzumenta (workera) simulujícího delší práci</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example03/consumer.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example03/consumer.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td>rabbitmq_connect.py</td><td>společná část pro producenta i konzumenta</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example04/rabbitmq_connect.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example04/rabbitmq_connect.py</a></td></tr>
<tr><td>4</td><td>enqueue_work.py</td><td>skript pro vložení zprávy do fronty</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example04/enqueue_work.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example04/enqueue_work.py</a></td></tr>
<tr><td>4</td><td>enqueue_more_work.py</td><td>skript pro vložení deseti zpráv do fronty</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example04/enqueue_more_work.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example04/enqueue_more_work.py</a></td></tr>
<tr><td>4</td><td>consumer.py</td><td>implementace konzumenta (workera) s&nbsp;potvrzením dokončení práce</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example04/consumer.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example04/consumer.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>rabbitmq_connect.py</td><td>společná část pro producenta i konzumenta</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example05/rabbitmq_connect.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example05/rabbitmq_connect.py</a></td></tr>
<tr><td>5</td><td>enqueue_work.py</td><td>skript pro vložení zprávy do fronty</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example05/enqueue_work.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example05/enqueue_work.py</a></td></tr>
<tr><td>5</td><td>enqueue_more_work.py</td><td>skript pro vložení deseti zpráv do fronty</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example05/enqueue_more_work.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example05/enqueue_more_work.py</a></td></tr>
<tr><td>5</td><td>consumer.py</td><td>implementace konzumenta (workera) s&nbsp;vylepšením dělby práce</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example05/consumer.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example05/consumer.py</a></td></tr>
</table>

<p>Poslední příklad je naprogramován v&nbsp;jazyce Clojure. Proto se jedná o
ucelený projekt s&nbsp;běžnou strukturou vyžadovanou nástrojem Leiningen. Tento
projekt naleznete na adrese <a
href="https://github.com/tisnik/message-queues-examples/tree/master/rabbit-mq/clojure/example01">https://github.com/tisnik/message-queues-examples/tree/master/rabbit-mq/clojure/example01</a>.</p>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Advanced Message Queuing Protocol<br />
<a href="https://www.amqp.org/">https://www.amqp.org/</a>
</li>

<li>Advanced Message Queuing Protocol na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol">https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol</a>
</li>

<li>RabbitMQ<br />
<a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a>
</li>

<li>RabbitMQ Tutorials<br />
<a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a>
</li>

<li>RabbitMQ: Clients and Developer Tools<br />
<a href="https://www.rabbitmq.com/devtools.html">https://www.rabbitmq.com/devtools.html</a>
</li>

<li>RabbitMQ na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/RabbitMQ">https://en.wikipedia.org/wiki/RabbitMQ</a>
</li>

<li>Streaming Text Oriented Messaging Protocol<br />
<a href="https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol">https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol</a>
</li>

<li>Message Queuing Telemetry Transport<br />
<a href="https://en.wikipedia.org/wiki/MQTT">https://en.wikipedia.org/wiki/MQTT</a>
</li>

<li>Erlang<br />
<a href="http://www.erlang.org/">http://www.erlang.org/</a>
</li>

<li>pika 0.12.0 na PyPi<br />
<a href="https://pypi.org/project/pika/">https://pypi.org/project/pika/</a>
</li>

<li>Introduction to Pika<br />
<a href="https://pika.readthedocs.io/en/stable/">https://pika.readthedocs.io/en/stable/</a>
</li>

<li>Langohr: An idiomatic Clojure client for RabbitMQ that embraces the AMQP 0.9.1 model<br />
<a href="http://clojurerabbitmq.info/">http://clojurerabbitmq.info/</a>
</li>

<li>AMQP 0-9-1 Model Explained<br />
<a href="http://www.rabbitmq.com/tutorials/amqp-concepts.html">http://www.rabbitmq.com/tutorials/amqp-concepts.html</a>
</li>

<li>Part 1: RabbitMQ for beginners - What is RabbitMQ?<br />
<a href="https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html">https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html</a>
</li>

<li>Downloading and Installing RabbitMQ<br />
<a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a>
</li>

<li>celery na PyPi<br />
<a href="https://pypi.org/project/celery/">https://pypi.org/project/celery/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python <br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python (dokončení)<br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/</a>
</li>

<li>Použití nástroje RQ (Redis Queue) pro správu úloh zpracovávaných na pozadí<br />
<a href="https://www.root.cz/clanky/pouziti-nastroje-rq-redis-queue-pro-spravu-uloh-zpracovavanych-na-pozadi/">https://www.root.cz/clanky/pouziti-nastroje-rq-redis-queue-pro-spravu-uloh-zpracovavanych-na-pozadi/</a>
</li>

<li>Redis Queue (RQ)<br />
<a href="https://www.fullstackpython.com/redis-queue-rq.html">https://www.fullstackpython.com/redis-queue-rq.html</a>
</li>

<li>Python Celery &amp; RabbitMQ Tutorial<br />
<a href="https://tests4geeks.com/python-celery-rabbitmq-tutorial/">https://tests4geeks.com/python-celery-rabbitmq-tutorial/</a>
</li>

<li>Flower: Real-time Celery web-monitor<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor">http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor</a>
</li>

<li>Asynchronous Tasks With Django and Celery<br />
<a href="https://realpython.com/asynchronous-tasks-with-django-and-celery/">https://realpython.com/asynchronous-tasks-with-django-and-celery/</a>
</li>

<li>First Steps with Celery<br />
<a href="http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html">http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html</a>
</li>

<li>node-celery<br />
<a href="https://github.com/mher/node-celery">https://github.com/mher/node-celery</a>
</li>

<li>Full Stack Python: web development<br />
<a href="https://www.fullstackpython.com/web-development.html">https://www.fullstackpython.com/web-development.html</a>
</li>

<li>Introducing RQ<br />
<a href="https://nvie.com/posts/introducing-rq/">https://nvie.com/posts/introducing-rq/</a>
</li>

<li>Asynchronous Tasks with Flask and Redis Queue<br />
<a href="https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue">https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Stránky projektu Redis<br />
<a href="https://redis.io/">https://redis.io/</a>
</li>

<li>Introduction to Redis<br />
<a href="https://redis.io/topics/introduction">https://redis.io/topics/introduction</a>
</li>

<li>Try Redis<br />
<a href="http://try.redis.io/">http://try.redis.io/</a>
</li>

<li>Redis tutorial, April 2010 (starší, ale pěkně udělaný)<br />
<a href="https://static.simonwillison.net/static/2010/redis-tutorial/">https://static.simonwillison.net/static/2010/redis-tutorial/</a>
</li>

<li>Python Redis<br />
<a href="https://redislabs.com/lp/python-redis/">https://redislabs.com/lp/python-redis/</a>
</li>

<li>Redis: key-value databáze v paměti i na disku<br />
<a href="https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/">https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/</a>
</li>

<li>Praktický úvod do Redis (1): vaše distribuovaná NoSQL cache<br />
<a href="http://www.cloudsvet.cz/?p=253">http://www.cloudsvet.cz/?p=253</a>
</li>

<li>Praktický úvod do Redis (2): transakce<br />
<a href="http://www.cloudsvet.cz/?p=256">http://www.cloudsvet.cz/?p=256</a>
</li>

<li>Praktický úvod do Redis (3): cluster<br />
<a href="http://www.cloudsvet.cz/?p=258">http://www.cloudsvet.cz/?p=258</a>
</li>

<li>Connection pool<br />
<a href="https://en.wikipedia.org/wiki/Connection_pool">https://en.wikipedia.org/wiki/Connection_pool</a>
</li>

<li>Instant Redis Sentinel Setup<br />
<a href="https://github.com/ServiceStack/redis-config">https://github.com/ServiceStack/redis-config</a>
</li>

<li>How to install REDIS in LInux<br />
<a href="https://linuxtechlab.com/how-install-redis-server-linux/">https://linuxtechlab.com/how-install-redis-server-linux/</a>
</li>

<li>Redis RDB Dump File Format<br />
<a href="https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format">https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format</a>
</li>

<li>Lempel–Ziv–Welch<br />
<a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch">https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch</a>
</li>

<li>Redis Persistence<br />
<a href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a>
</li>

<li>Redis persistence demystified<br />
<a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html">http://oldblog.antirez.com/post/redis-persistence-demystified.html</a>
</li>

<li>Redis reliable queues with Lua scripting<br />
<a href="http://oldblog.antirez.com/post/250">http://oldblog.antirez.com/post/250</a>
</li>

<li>Ost (knihovna)<br />
<a href="https://github.com/soveran/ost">https://github.com/soveran/ost</a>
</li>

<li>NoSQL<br />
<a href="https://en.wikipedia.org/wiki/NoSQL">https://en.wikipedia.org/wiki/NoSQL</a>
</li>

<li>Shard (database architecture)<br />
<a href="https://en.wikipedia.org/wiki/Shard_%28database_architecture%29">https://en.wikipedia.org/wiki/Shard_%28database_architecture%29</a>
</li>

<li>What is sharding and why is it important?<br />
<a href="https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important">https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important</a>
</li>

<li>What Is Sharding?<br />
<a href="https://btcmanager.com/what-sharding/">https://btcmanager.com/what-sharding/</a>
</li>

<li>Redis clients<br />
<a href="https://redis.io/clients">https://redis.io/clients</a>
</li>

<li>Category:Lua-scriptable software<br />
<a href="https://en.wikipedia.org/wiki/Category:Lua-scriptable_software">https://en.wikipedia.org/wiki/Category:Lua-scriptable_software</a>
</li>

<li>Seriál Programovací jazyk Lua<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-lua/">https://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>Redis memory usage<br />
<a href="http://nosql.mypopescu.com/post/1010844204/redis-memory-usage">http://nosql.mypopescu.com/post/1010844204/redis-memory-usage</a>
</li>

<li>Ukázka konfigurace Redisu pro lokální testování<br />
<a href="https://github.com/tisnik/presentations/blob/master/redis/redis.conf">https://github.com/tisnik/presentations/blob/master/redis/redis.conf</a>
</li>

<li>Resque<br />
<a href="https://github.com/resque/resque">https://github.com/resque/resque</a>
</li>

<li>Nested transaction<br />
<a href="https://en.wikipedia.org/wiki/Nested_transaction">https://en.wikipedia.org/wiki/Nested_transaction</a>
</li>

<li>Publish–subscribe pattern<br />
<a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern</a>
</li>

<li>Messaging pattern<br />
<a href="https://en.wikipedia.org/wiki/Messaging_pattern">https://en.wikipedia.org/wiki/Messaging_pattern</a>
</li>

<li>Using pipelining to speedup Redis queries<br />
<a href="https://redis.io/topics/pipelining">https://redis.io/topics/pipelining</a>
</li>

<li>Pub/Sub<br />
<a href="https://redis.io/topics/pubsub">https://redis.io/topics/pubsub</a>
</li>

<li>ZeroMQ distributed messaging<br />
<a href="http://zeromq.org/">http://zeromq.org/</a>
</li>

<li>ZeroMQ: Modern &amp; Fast Networking Stack<br />
<a href="https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/">https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/</a>
</li>

<li>Publish/Subscribe paradigm: Why must message classes not know about their subscribers?<br />
<a href="https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr">https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr</a>
</li>

<li>Python &amp; Redis PUB/SUB<br />
<a href="https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7">https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7</a>
</li>

<li>Message broker<br />
<a href="https://en.wikipedia.org/wiki/Message_broker">https://en.wikipedia.org/wiki/Message_broker</a>
</li>

<li>RESP Arrays<br />
<a href="https://redis.io/topics/protocol#array-reply">https://redis.io/topics/protocol#array-reply</a>
</li>

<li>Redis Protocol specification<br />
<a href="https://redis.io/topics/protocol">https://redis.io/topics/protocol</a>
</li>

<li>Redis Pub/Sub: Intro Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-intro/">https://www.redisgreen.net/blog/pubsub-intro/</a>
</li>

<li>Redis Pub/Sub: Howto Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-howto/">https://www.redisgreen.net/blog/pubsub-howto/</a>
</li>

<li>Comparing Publish-Subscribe Messaging and Message Queuing<br />
<a href="https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message">https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message</a>
</li>

<li>Apache Kafka<br />
<a href="https://kafka.apache.org/">https://kafka.apache.org/</a>
</li>

<li>Iron<br />
<a href="http://www.iron.io/mq">http://www.iron.io/mq</a>
</li>

<li>kue (založeno na Redisu, určeno pro node.js)<br />
<a href="https://github.com/Automattic/kue">https://github.com/Automattic/kue</a>
</li>

<li>Cloud Pub/Sub<br />
<a href="https://cloud.google.com/pubsub/">https://cloud.google.com/pubsub/</a>
</li>

<li>Introduction to Redis Streams<br />
<a href="https://redis.io/topics/streams-intro">https://redis.io/topics/streams-intro</a>
</li>

<li>glob (programming)<br />
<a href="https://en.wikipedia.org/wiki/Glob_(programming)">https://en.wikipedia.org/wiki/Glob_(programming)</a>
</li>

<li>Why and how Pricing Assistant migrated from Celery to RQ - Paris.py<br />
<a href="https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2">https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2</a>
</li>

<li>Enqueueing internals<br />
<a href="http://python-rq.org/contrib/">http://python-rq.org/contrib/</a>
</li>

<li>queue — A synchronized queue class<br />
<a href="https://docs.python.org/3/library/queue.html">https://docs.python.org/3/library/queue.html</a>
</li>

<li>Queues<br />
<a href="http://queues.io/">http://queues.io/</a>
</li>

<li>Windows Subsystem for Linux Documentation<br />
<a href="https://docs.microsoft.com/en-us/windows/wsl/about">https://docs.microsoft.com/en-us/windows/wsl/about</a>
</li>

<li>RestMQ<br />
<a href="http://restmq.com/">http://restmq.com/</a>
</li>

<li>ActiveMQ<br />
<a href="http://activemq.apache.org/">http://activemq.apache.org/</a>
</li>

<li>Amazon MQ<br />
<a href="https://aws.amazon.com/amazon-mq/">https://aws.amazon.com/amazon-mq/</a>
</li>

<li>Amazon Simple Queue Service<br />
<a href="https://aws.amazon.com/sqs/">https://aws.amazon.com/sqs/</a>
</li>

<li>Celery: Distributed Task Queue<br />
<a href="http://www.celeryproject.org/">http://www.celeryproject.org/</a>
</li>

<li>Disque, an in-memory, distributed job queue<br />
<a href="https://github.com/antirez/disque">https://github.com/antirez/disque</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Projekt RQ na PyPi<br />
<a href="https://pypi.org/project/rq/">https://pypi.org/project/rq/</a>
</li>

<li>rq-dashboard 0.3.12<br />
<a href="https://pypi.org/project/rq-dashboard/">https://pypi.org/project/rq-dashboard/</a>
</li>

<li>Job queue<br />
<a href="https://en.wikipedia.org/wiki/Job_queue">https://en.wikipedia.org/wiki/Job_queue</a>
</li>

<li>Why we moved from Celery to RQ<br />
<a href="https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq">https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq</a>
</li>

<li>Running multiple workers using Celery<br />
<a href="https://serverfault.com/questions/655387/running-multiple-workers-using-celery">https://serverfault.com/questions/655387/running-multiple-workers-using-celery</a>
</li>

<li>celery — Distributed processing<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.html">http://docs.celeryproject.org/en/latest/reference/celery.html</a>
</li>

<li>Chains<br />
<a href="https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains">https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains</a>
</li>

<li>Routing<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing">http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing</a>
</li>

<li>Celery Distributed Task Queue in Go<br />
<a href="https://github.com/gocelery/gocelery/">https://github.com/gocelery/gocelery/</a>
</li>

<li>Python Decorators<br />
<a href="https://wiki.python.org/moin/PythonDecorators">https://wiki.python.org/moin/PythonDecorators</a>
</li>

<li>Periodic Tasks<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html">http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html</a>
</li>

<li>celery.schedules<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab">http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab</a>
</li>

<li>Pros and cons to use Celery vs. RQ<br />
<a href="https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq">https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

