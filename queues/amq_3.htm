<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Použití Apache ActiveMQ s protokolem AMQP, jazyk Go a message brokeři</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Použití Apache ActiveMQ s protokolem AMQP, jazyk Go a message brokeři</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V jedenácté části seriálu o message brokerech si nejdříve ukážeme, jakým způsobem je možné komunikovat se systémem Apache ActiveMQ při použití prokotolu AMQP. Durhá část článku je věnována popisu spolupráce mezi ActiveMQ a aplikacemi naprogramovanými v jazyku Go.</p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Použití Apache ActiveMQ s&nbsp;protokolem AMQP, jazyk Go a message brokeři</a></p>
<p><a href="#k02">*** 2. Instalace knihovny Qpid Proton</a></p>
<p><a href="#k03">*** 3. Producent zpráv publikovaných pod zvoleným tématem</a></p>
<p><a href="#k04">*** 4. Příjemce zpráv s&nbsp;nastaveným tématem</a></p>
<p><a href="#k05">*** 5. Producent zpráv posílaných do fronty</a></p>
<p><a href="#k06">*** 6. Konzument zpráv z&nbsp;vybrané fronty</a></p>
<p><a href="#k07">*** 7. Logika implementace producenta většího množství zpráv</a></p>
<p><a href="#k08">*** 8. Konzument zpráv ukončovaný explicitně poslanou zprávou <strong>EXIT</strong></a></p>
<p><a href="#k09">*** 9. Speciální témata vytvářená automaticky systémem AMQ</a></p>
<p><a href="#k10">*** 10. Příprava běžného producenta a konzumenta zpráv</a></p>
<p><a href="#k11">*** 11. Jednoduchý nástroj pro sledování speciálních témat</a></p>
<p><a href="#k12">*** 12. Analýza výsledků práce nástroje</a></p>
<p><a href="#k13">*** 13. Použití message brokerů z&nbsp;programovacího jazyka Go s&nbsp;využitím protokolu STOMP</a></p>
<p><a href="#k14">*** 14. Připojení k&nbsp;message brokerovi, práce se zprávami</a></p>
<p><a href="#k15">*** 15. Implementace producenta zpráv (publishera)</a></p>
<p><a href="#k16">*** 16. Implementace konzumenta zpráv</a></p>
<p><a href="#k17">*** 17. Úprava producenta a konzumenta tak, aby komunikace s&nbsp;message brokerem probíhala v&nbsp;gorutině</a></p>
<p><a href="#k18">*** 18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">*** 19. Odkazy na předchozí části seriálu</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Použití Apache ActiveMQ s&nbsp;protokolem AMQP, jazyk Go a message brokeři</h2>

<p>Dnešní část seriálu o systémech implementujících fronty zpráv bude rozdělena do dvou částí. V&nbsp;první části si na několika demonstračních příkladech ukážeme, jakým způsobem je možné komunikovat se systémem Apache ActiveMQ s&nbsp;využitím protokolu AMQP. Příklady budou naprogramovány v&nbsp;Pythonu, přičemž vlastní realizaci komunikačního protokolu bude zajišťovat knihovna <i>Qpid Proton</i>, kterou nalezneme na adrese <a href="https://qpid.apache.org/proton/">https://qpid.apache.org/proton/</a>. Zajímavé je, že programátorské rozhraní knihovny Qpid Proton je zcela odlišné od rozhraní protokolu STOMP, které bylo realizováno v&nbsp;knihovně <i>stomp.py</i>, viz též <a href="https://www.root.cz/clanky/pouziti-apache-activemq-s-protokolem-stomp/">předchozí část tohoto seriálu</a> s&nbsp;popisem možností poskytovaných touto knihovnou.</p>

<p><a href="#k13">Druhá část článku</a> je věnována nepatrně odlišnému tématu. Ukážeme si v&nbsp;ní způsob realizace klientů vyvinutých <a href="https://golang.org/">v&nbsp;programovacím jazyce Go</a>, kterému se podrobněji věnujeme <a href="https://www.root.cz/serialy/programovaci-jazyk-go/">v&nbsp;paralelně běžícím seriálu</a>. Uvidíme, že díky některým vlastnostem programovacího jazyka Go, zejména díky kanálům a gorutinám, je implementace klientů message brokera v&nbsp;mnoha ohledech velmi elegantní.</p>

<p></p>

conf/activemq.xml

<pre>
&lt;transportConnectors&gt;
    &lt;transportConnector name="openwire" uri="tcp://0.0.0.0:61616?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600"/&gt;
    &lt;transportConnector name="amqp" uri="amqp://0.0.0.0:5672?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600"/&gt;
    &lt;transportConnector name="stomp" uri="stomp://0.0.0.0:61613?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600"/&gt;
    &lt;transportConnector name="mqtt" uri="mqtt://0.0.0.0:1883?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600"/&gt;
    &lt;transportConnector name="ws" uri="ws://0.0.0.0:61614?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600"/&gt;
&lt;/transportConnectors&gt;
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Instalace knihovny Qpid Proton</h2>

<p>V&nbsp;demonstračních příkladech, které si ukážeme v&nbsp;navazujících kapitolách, použijeme pro komunikaci se systémem Apache ActiveMQ knihovnu nazvanou <i>Qpid Proton</i>, která je určena pro <a href="">programovací jazyk Python</a>. Tato knihovna je &ndash; jak je dnes již dobrým zvykem &ndash; dostupná na PyPi, ovšem před její instalací je nutné nainstalovat i Cython, a to v&nbsp;samostatném kroku. Cython, s&nbsp;nímž jsme se seznámili <a href="https://www.root.cz/clanky/rpython-vs-cython-aneb-dvoji-pristup-k-prekladu-pythonu-do-nativniho-kodu/">v&nbsp;jiném článku</a>, nainstalujeme pro právě přihlášeného uživatele následujícím příkazem:</p>

<pre>
$ <strong>pip3 install --user cython</strong>
&nbsp;
Collecting cython
  Downloading https://files.pythonhosted.org/packages/16/98/49aa24054e99e9c7734e49d6996662f547e4e2faae0051d35fbbc461afa4/Cython-0.29.5-cp36-cp36m-manylinux1_x86_64.whl (2.1MB)
    100% |████████████████████████████████| 2.1MB 603kB/s 
Installing collected packages: cython
Successfully installed cython-0.29.5
</pre>

<p>Po (doufejme že úspěšné) instalaci Cythonu již můžeme bez problémů nainstalovat i knihovnu <i>Qpid Proton</i>, a to takto:</p>

<pre>
$ <strong>pip3 install --user python-qpid-proton</strong>
&nbsp;
Collecting python-qpid-proton
  Downloading https://files.pythonhosted.org/packages/fe/e3/58379a2262a31788cfa037bde2c0c77273a74f34943f73abf20030c71f17/python-qpid-proton-0.26.0.zip (563kB)
    100% |████████████████████████████████| 573kB 1.1MB/s
Installing collected packages: python-qpid-proton
  Running setup.py install for python-qpid-proton ... done
Successfully installed python-qpid-proton-0.26.0
</pre>

<p>Základní kontrolu instalace můžeme provést přímo z&nbsp;interaktivní smyčky jazyka Python. Použijeme interpret Pythonu 3, protože i instalace byla provedena pro Python 3:</p>

<pre>
$ <strong>python3</strong>
&nbsp;
Python 3.6.3 (default, Oct  9 2017, 12:11:29) 
[GCC 7.2.1 20170915 (Red Hat 7.2.1-2)] on linux
Type "help", "copyright", "credits" or "license" for more information.
&nbsp;
&gt;&gt;&gt; <strong>import proton</strong>
&gt;&gt;&gt; <strong>help("proton")</strong>
</pre>

<p>Po potvrzení posledního příkazu by se měla zobrazit nápověda:</p>

<pre>
Help on package proton:
&nbsp;
NAME
    proton
&nbsp;
DESCRIPTION
    The proton module defines a suite of APIs that implement the AMQP 1.0
    protocol.
&nbsp;
    The proton APIs consist of the following classes:
&nbsp;
     - L{Message}   -- A class for creating and/or accessing AMQP message content.
     - L{Data}      -- A class for creating and/or accessing arbitrary AMQP encoded
                      data.
&nbsp;
PACKAGE CONTENTS
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Producent zpráv publikovaných pod zvoleným tématem</h2>

<p>Instalaci knihovny <i>Qpid Proton</i> jsme dokončili, takže si můžeme ukázat způsob implementace jednoduchého producenta zpráv, které budou posílány s&nbsp;využitím strategie <strong>PUB-SUB</strong> &ndash; zprávy tedy nebudou ukládány do fronty, ale budou přímo přeposlány všem posluchačům, kteří jsou v&nbsp;daný okamžik k&nbsp;message brokerovi připojeny.</p>

<p>Ve výchozím nastavení Apache ActiveMQ je pro komunikaci s&nbsp;využitím protokolu AMQP používán port 5672, který je dokonce <a href="http://www.tcp-udp-ports.com/port-5672.htm">k&nbsp;tomuto účelu rezervován</a>. Doménové jméno serveru tedy, společně s&nbsp;portem 5672, použijeme pro určení jeho adresy ve formátu, jak ho očekává knihovna Qpid:</p>

<pre>
ADDRESS = "localhost:5672"
</pre>

<p>Určit musíme i cíl zprávy. Ten typicky začíná prefixem &bdquo;topic://&ldquo; nebo &bdquo;queue://&ldquo;. V&nbsp;prvním příkladu použijeme téma (<i>topic</i>) nazvané &bdquo;event&ldquo;, takže se cíl zapíše následovně:</p>

<pre>
TARGET = "topic://event"
</pre>

<p>Samotný producent zprávy se inicializuje a následně spustí takto:</p>

<pre>
publisher = Publisher(ADDRESS, TARGET)
container = Container(publisher)
container.run()
</pre>

<p>Samozřejmě nám zbývá implementovat vlastní logiku producenta, tj.&nbsp;musíme naprogramovat třídu nazvanou <strong>Publisher</strong>, která byla použita v&nbsp;předchozích programových řádcích. Tato třída je odvozena od třídy <a href="https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._handlers.MessagingHandler-class.html">MessagingHandler</a>, v&nbsp;níž je předepsáno několik callback metod volaných samotnou knihovnou Qpid Proton na základě různých událostí (<a href="https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._events.Event-class.html">Event</a>). Prozatím nás budou zajímat čtyři typy událostí:</p>

<ol>
<li>on_start</li>
<li>on_accepted</li>
<li>on_disconnected</li>
<li>on_sendable</li>
</ol>

<p>V&nbsp;nejjednodušším případě &ndash; což je výchozí stav &ndash; budou handlery prázdné, ovšem povšimněte si, že se každému handleru skutečně předává objekt, který reprezentuje vzniklou událost:</p>

<pre>
class <strong>Publisher</strong>(MessagingHandler):
&nbsp;
    def <strong>__init__</strong>(self, url, target):
        pass
&nbsp;
    def <strong>on_start</strong>(self, event):
        pass
&nbsp;
    def <strong>on_sendable</strong>(self, event):
        pass
&nbsp;
    def <strong>on_accepted</strong>(self, event):
        pass
&nbsp;
    def <strong>on_disconnected</strong>(self, event):
        pass
</pre>

<p>Konkrétní implementace producenta zpráv samozřemě bude složitější, což je patrné i při pohledu na <a href="">jeho úplný zdrojový kód</a>:</p>

<pre>
from proton import Message
from proton.handlers import MessagingHandler
from proton.reactor import Container
&nbsp;
ADDRESS = "localhost:5672"
TARGET = "topic://event"
&nbsp;
&nbsp;
class <strong>Publisher</strong>(MessagingHandler):
&nbsp;
    def <strong>__init__</strong>(self, url, target):
        super(Publisher, self).__init__()
        self.url = url
        self.target = target
        self.message_sent = False
&nbsp;
    def <strong>on_start</strong>(self, event):
        print("on_start()")
        connection = event.container.connect(self.url)
        event.container.create_sender(connection, self.target)
&nbsp;
    def <strong>on_sendable</strong>(self, event):
        print("on_sendable()")
        if not self.message_sent:
            message = Message(id=1, body="Hello world1")
            event.sender.send(message)
            self.message_sent = True
            print("Message has been sent")
        else:
            print("Already sent... do nothing")
&nbsp;
    def <strong>on_accepted</strong>(self, event):
        print("on_accepted()")
        if self.message_sent:
            event.connection.close()
&nbsp;
    def <strong>on_disconnected</strong>(self, event):
        print("on_disconnected()")
&nbsp;
&nbsp;
publisher = Publisher(ADDRESS, TARGET)
container = Container(publisher)
container.run()
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Příjemce zpráv s&nbsp;nastaveným tématem</h2>

<pre>
class <strong>Subscriber</strong>(MessagingHandler):
&nbsp;
    def <strong>__init__</strong>(self, url, source):
        pass
&nbsp;
    def <strong>on_start</strong>(self, event):
        pass
&nbsp;
    def <strong>on_message</strong>(self, event):
        pass
</pre>

<pre>
connection = event.container.connect(self.url)
event.container.create_receiver(connection, self.source)
</pre>

<pre>
from proton.handlers import MessagingHandler
from proton.reactor import Container
&nbsp;
ADDRESS = "localhost:5672"
SOURCE = "topic://event"
&nbsp;
&nbsp;
class <strong>Subscriber</strong>(MessagingHandler):
&nbsp;
    def <strong>__init__</strong>(self, url, source):
        super(Subscriber, self).__init__()
        self.url = url
        self.source = source
&nbsp;
    def <strong>on_start</strong>(self, event):
        print("on_start()")
        connection = event.container.connect(self.url)
        event.container.create_receiver(connection, self.source)
&nbsp;
    def <strong>on_message</strong>(self, event):
        message = event.message
&nbsp;
        print("Received message '{m}'".format(m=message.body))
&nbsp;
        event.receiver.close()
        event.connection.close()
&nbsp;
&nbsp;
subscriber = Subscriber(ADDRESS, SOURCE)
container = Container(subscriber)
container.run()
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Producent zpráv posílaných do fronty</h2>

<pre>
ADDRESS = "localhost:5672"
TARGET = "queue://test"
</pre>

<pre>
from proton import Message
from proton.handlers import MessagingHandler
from proton.reactor import Container
&nbsp;
ADDRESS = "localhost:5672"
TARGET = "queue://test"
&nbsp;
&nbsp;
class <strong>Publisher</strong>(MessagingHandler):
&nbsp;
    def <strong>__init__</strong>(self, url, target):
        super(Publisher, self).__init__()
        self.url = url
        self.target = target
        self.message_sent = False
&nbsp;
    def <strong>on_start</strong>(self, event):
        print("on_start()")
        connection = event.container.connect(self.url)
        event.container.create_sender(connection, self.target)
&nbsp;
    def <strong>on_sendable</strong>(self, event):
        print("on_sendable()")
        if not self.message_sent:
            message = Message(id=1, body="Hello world1")
            event.sender.send(message)
            self.message_sent = True
            print("Message has been sent")
        else:
            print("Already sent... do nothing")
&nbsp;
    def <strong>on_accepted</strong>(self, event):
        print("on_accepted()")
        if self.message_sent:
            event.connection.close()
&nbsp;
    def <strong>on_disconnected</strong>(self, event):
        print("on_disconnected()")
&nbsp;
&nbsp;
publisher = Publisher(ADDRESS, TARGET)
container = Container(publisher)
container.run()
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Konzument zpráv z&nbsp;vybrané fronty</h2>

<pre>
from proton.handlers import MessagingHandler
from proton.reactor import Container
&nbsp;
ADDRESS = "localhost:5672"
SOURCE = "queue://test"
&nbsp;
&nbsp;
class <strong>Subscriber</strong>(MessagingHandler):
&nbsp;
    def <strong>__init__</strong>(self, url, source):
        super(Subscriber, self).__init__()
        self.url = url
        self.source = source
&nbsp;
    def <strong>on_start</strong>(self, event):
        print("on_start()")
        connection = event.container.connect(self.url)
        event.container.create_receiver(connection, self.source)
&nbsp;
    def <strong>on_message</strong>(self, event):
        message = event.message
&nbsp;
        print("Received message '{m}'".format(m=message.body))
&nbsp;
        event.receiver.close()
        event.connection.close()
&nbsp;
&nbsp;
subscriber = Subscriber(ADDRESS, SOURCE)
container = Container(subscriber)
container.run()
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Logika implementace producenta většího množství zpráv</h2>

<pre>
self.message_sent = 0
self.message_accepted = 0
</pre>

<pre>
from proton import Message
from proton.handlers import MessagingHandler
from proton.reactor import Container
&nbsp;
ADDRESS = "localhost:5672"
TARGET = "queue://test"
&nbsp;
MAX_MESSAGES = 10
&nbsp;
class <strong>Publisher</strong>(MessagingHandler):
&nbsp;
    def <strong>__init__</strong>(self, url, target):
        super(Publisher, self).__init__()
        self.url = url
        self.target = target
        self.message_sent = 0
        self.message_accepted = 0
&nbsp;
    def <strong>on_start</strong>(self, event):
        print("on_start()")
        connection = event.container.connect(self.url)
        event.container.create_sender(connection, self.target)
&nbsp;
    def <strong>on_sendable</strong>(self, event):
        print("on_sendable()")
        if self.message_sent &lt; MAX_MESSAGES:
            self.message_sent += 1
            message = Message(id=self.message_sent, body="Hello world #{n}".format(n=self.message_sent))
            event.sender.send(message)
            print("Message #{n} has been sent".format(n=self.message_sent))
        elif self.message_sent == MAX_MESSAGES:
            self.message_sent += 1
            message = Message(id=self.message_sent, body="exit")
            event.sender.send(message)
            print("Exit message")
&nbsp;
    def <strong>on_accepted</strong>(self, event):
        print("on_accepted()")
        self.message_accepted += 1
        if self.message_accepted == self.message_sent:
            print("All messages confirmed")
            event.connection.close()
        print("Number of accepted messages: {n}".format(n=self.message_accepted))
&nbsp;
    def <strong>on_disconnected</strong>(self, event):
        print("on_disconnected()")
&nbsp;
&nbsp;
publisher = Publisher(ADDRESS, TARGET)
container = Container(publisher)
container.run()
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Konzument zpráv ukončovaný explicitně poslanou zprávou <strong>EXIT</strong></h2>

<pre>
from proton.handlers import MessagingHandler
from proton.reactor import Container
&nbsp;
ADDRESS = "localhost:5672"
SOURCE = "queue://test"
&nbsp;
&nbsp;
class <strong>Subscriber</strong>(MessagingHandler):
&nbsp;
    def <strong>__init__</strong>(self, url, source):
        super(Subscriber, self).__init__()
        self.url = url
        self.source = source
&nbsp;
    def <strong>on_start</strong>(self, event):
        print("on_start()")
        connection = event.container.connect(self.url)
        event.container.create_receiver(connection, self.source)
&nbsp;
    def <strong>on_message</strong>(self, event):
        message = event.message
&nbsp;
        print("Received message '{m}'".format(m=message.body))
&nbsp;
        if message.body == "exit":
            print("Last message for me...good bye")
            event.receiver.close()
            event.connection.close()
&nbsp;
&nbsp;
subscriber = Subscriber(ADDRESS, SOURCE)
container = Container(subscriber)
container.run()
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Speciální témata vytvářená automaticky systémem AMQ</h2>

<p></p>

<table>
<tr><th></th><th></th></tr>
<tr><td></td><td></td></tr>
</table>

<table>
<tr><th></th><th></th></tr>
<tr><td></td><td></td></tr>
</table>

ActiveMQ.Advisory.Connection
ActiveMQ.Advisory.Queue
ActiveMQ.Advisory.Topic
ActiveMQ.Advisory.MasterBroker

ActiveMQ.Advisory.Consumer.Queue.test
ActiveMQ.Advisory.Producer.Queue.test


<p><a name="k10"></a></p>
<h2 id="k10">10. Příprava běžného producenta a konzumenta zpráv</h2>

<pre>
from proton import Message
from proton.handlers import MessagingHandler
from proton.reactor import Container
&nbsp;
ADDRESS = "localhost:5672"
TARGET = "queue://test"
&nbsp;
MAX_MESSAGES = 1
&nbsp;
&nbsp;
class <strong>Publisher</strong>(MessagingHandler):
&nbsp;
    def <strong>__init__</strong>(self, url, target):
        super(Publisher, self).__init__()
        self.url = url
        self.target = target
        self.message_sent = 0
        self.message_accepted = 0
&nbsp;
    def <strong>on_start</strong>(self, event):
        print("on_start()")
        connection = event.container.connect(self.url)
        event.container.create_sender(connection, self.target)
&nbsp;
    def <strong>on_sendable</strong>(self, event):
        print("on_sendable()")
        if self.message_sent &lt; MAX_MESSAGES:
            self.message_sent += 1
            message = Message(id=self.message_sent, body="Hello world #{n}".format(n=self.message_sent))
            event.sender.send(message)
            print("Message #{n} has been sent".format(n=self.message_sent))
        elif self.message_sent == MAX_MESSAGES:
            self.message_sent += 1
            message = Message(id=self.message_sent, body="exit")
            event.sender.send(message)
            print("Exit message")
&nbsp;
    def <strong>on_accepted</strong>(self, event):
        print("on_accepted()")
        self.message_accepted += 1
        if self.message_accepted == self.message_sent:
            print("All messages confirmed")
            event.connection.close()
        print("Number of accepted messages: {n}".format(n=self.message_accepted))
&nbsp;
    def <strong>on_disconnected</strong>(self, event):
        print("on_disconnected()")
&nbsp;
&nbsp;
publisher = Publisher(ADDRESS, TARGET)
container = Container(publisher)
container.run()
</pre>

<pre>
import time
&nbsp;
from proton.handlers import MessagingHandler
from proton.reactor import Container
&nbsp;
ADDRESS = "localhost:5672"
SOURCE = "queue://test"
&nbsp;
&nbsp;
class <strong>Subscriber</strong>(MessagingHandler):
&nbsp;
    def <strong>__init__</strong>(self, url, source):
        super(Subscriber, self).__init__()
        self.url = url
        self.source = source
&nbsp;
    def <strong>on_start</strong>(self, event):
        print("on_start()")
        connection = event.container.connect(self.url)
        event.container.create_receiver(connection, self.source)
&nbsp;
    def <strong>on_message</strong>(self, event):
        message = event.message
&nbsp;
        print("Received message '{m}'".format(m=message.body))
&nbsp;
        if message.body == "exit":
            print("Last message for me...good bye")
            event.receiver.close()
            event.connection.close()
        time.sleep(1)
&nbsp;
&nbsp;
subscriber = Subscriber(ADDRESS, SOURCE)
container = Container(subscriber)
container.run()
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Jednoduchý nástroj pro sledování speciálních témat</h2>

<pre>
from proton.handlers import MessagingHandler
from proton.reactor import Container
&nbsp;
ADDRESS = "localhost:5672"
&nbsp;
TOPICS = (
    "ActiveMQ.Advisory.Connection",
    "ActiveMQ.Advisory.Consumer.Queue.test",
    "ActiveMQ.Advisory.MasterBroker",
    "ActiveMQ.Advisory.Producer.Queue.test",
    "ActiveMQ.Advisory.Queue",
    "ActiveMQ.Advisory.Topic"
)
&nbsp;
&nbsp;
class <strong>Subscriber</strong>(MessagingHandler):
&nbsp;
    def <strong>__init__</strong>(self, url):
        super(Subscriber, self).__init__()
        self.url = url
&nbsp;
    def <strong>on_start</strong>(self, event):
        print("on_start()")
        connection = event.container.connect(self.url)
        for topic in TOPICS:
            event.container.create_receiver(connection, "topic://" + topic)
&nbsp;
    def <strong>on_message</strong>(self, event):
        message = event.message
        print(message)
&nbsp;
&nbsp;
subscriber = Subscriber(ADDRESS)
container = Container(subscriber)
container.run()
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Analýza výsledků práce nástroje</h2>

<pre>
Message{address="topic://ActiveMQ.Advisory.Connection", priority=0, id="ID:localhost.localdomain-37517-1550847645470-1:1:0:0:374", subject="Advisory", annotations={:"x-opt-jms-dest"=1}, properties={"originBrokerURL"="amqp://localhost.localdomain:5672", "originBrokerId"="ID:localhost.localdomain-37517-1550847645470-0:1", "originBrokerName"="localhost"}}
Message{address="topic://ActiveMQ.Advisory.Producer.Queue.test", priority=0, id="ID:localhost.localdomain-37517-1550847645470-1:1:0:0:375", subject="Advisory", annotations={:"x-opt-jms-dest"=1}, properties={"originBrokerURL"="amqp://localhost.localdomain:5672", "originBrokerId"="ID:localhost.localdomain-37517-1550847645470-0:1", "producerCount"=1, "originBrokerName"="localhost"}}
Message{address="topic://ActiveMQ.Advisory.Producer.Queue.test", priority=0, id="ID:localhost.localdomain-37517-1550847645470-1:1:0:0:376", subject="Advisory", annotations={:"x-opt-jms-dest"=1}, properties={"originBrokerURL"="amqp://localhost.localdomain:5672", "originBrokerId"="ID:localhost.localdomain-37517-1550847645470-0:1", "producerCount"=0, "originBrokerName"="localhost"}}
Message{address="topic://ActiveMQ.Advisory.Connection", priority=0, id="ID:localhost.localdomain-37517-1550847645470-1:1:0:0:377", subject="Advisory", annotations={:"x-opt-jms-dest"=1}, properties={"originBrokerURL"="amqp://localhost.localdomain:5672", "originBrokerId"="ID:localhost.localdomain-37517-1550847645470-0:1", "originBrokerName"="localhost"}}
Message{address="topic://ActiveMQ.Advisory.Connection", priority=0, id="ID:localhost.localdomain-37517-1550847645470-1:1:0:0:378", subject="Advisory", annotations={:"x-opt-jms-dest"=1}, properties={"originBrokerURL"="amqp://localhost.localdomain:5672", "originBrokerId"="ID:localhost.localdomain-37517-1550847645470-0:1", "originBrokerName"="localhost"}}
Message{address="topic://ActiveMQ.Advisory.Consumer.Queue.test", priority=0, id="ID:localhost.localdomain-37517-1550847645470-1:1:0:0:379", subject="Advisory", annotations={:"x-opt-jms-dest"=1}, properties={"originBrokerURL"="amqp://localhost.localdomain:5672", "consumerCount"=1, "originBrokerId"="ID:localhost.localdomain-37517-1550847645470-0:1", "originBrokerName"="localhost"}}
Message{address="topic://ActiveMQ.Advisory.Consumer.Queue.test", priority=0, id="ID:localhost.localdomain-37517-1550847645470-1:1:0:0:380", subject="Advisory", annotations={:"x-opt-jms-dest"=1}, properties={"originBrokerURL"="amqp://localhost.localdomain:5672", "consumerCount"=0, "originBrokerId"="ID:localhost.localdomain-37517-1550847645470-0:1", "originBrokerName"="localhost"}}
Message{address="topic://ActiveMQ.Advisory.Connection", priority=0, id="ID:localhost.localdomain-37517-1550847645470-1:1:0:0:381", subject="Advisory", annotations={:"x-opt-jms-dest"=1}, properties={"originBrokerURL"="amqp://localhost.localdomain:5672", "originBrokerId"="ID:localhost.localdomain-37517-1550847645470-0:1", "originBrokerName"="localhost"}}
</pre>

<table>
<tr><th></th><th></th><th></th><th></th><th></th><th></th></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td><td></td></tr>
</table>



<p><a name="k13"></a></p>
<h2 id="k13">13. Použití message brokerů z&nbsp;programovacího jazyka Go s&nbsp;využitím protokolu STOMP</h2>

<p>Ve druhé části dnešního článku se seznámíme s&nbsp;tím, jakým způsobem je možné použít message broker Apache ActiveMQ z&nbsp;programovacího jazyka Go. Pro jednoduchost použijeme protokol STOMP (<i>Streaming Text Oriented Messaging Protocol</i>), který, jak již víme, sice nedokáže využít všechny možnosti AMQ, ovšem základní architekturu systému založeného na kombinaci AMQ+STOMP celkem bez problémů dokážeme postavit (ostatně největší problémy nás většinou čekají při návrhu subsystému pro persistenci zpráv popř.&nbsp;pro clusterování a load balancing). Implementaci knihovny s&nbsp;implementací protokolu STOMP určenou pro jazyk Go nalezneme v&nbsp;GitHub repositáři <a href="https://github.com/go-stomp/stomp">https://github.com/go-stomp/stomp</a>, takže samotná instalace bude jednoduchá. Nejdříve přejdeme do adresáře, na nějž ukazuje proměnná prostředí GOPATH; typicky se jedná o adresář <strong>~/go</strong>. Zde zadáme následující příkaz:</p>

<pre>
$ <strong>go get github.com/go-stomp/stomp</strong>
</pre>

<p>V&nbsp;adresářové struktuře by se měl objevit podadresář <strong>src/github.com/go-stomp/stomp</strong> a taktéž <strong>pkg/linux_amd64/github.com/go-stomp/stomp</strong> s&nbsp;přibližně následujícím obsahem:</p>

<pre>
.
├── pkg
│   └── linux_amd64
│       └── github.com
│           └── go-stomp
│               └── stomp.a
├── src
│   ├── github.com
│   │   └── go-stomp
│   │       └── stomp
│   │           ├── ack.go
│   │           ├── breaking_changes.md
│   │           ├── conn.go
│   │           ├── conn_options.go
│   │           ├── conn_test.go
│   │           │   └── testutil.go
...
...
...
│   │           ├── transaction.go
│   │           ├── validator.go
│   │           ├── version.go
│   │           └── version_test.go
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Připojení k&nbsp;message brokerovi, práce se zprávami</h2>

<pre>
conn, err := stomp.Dial("tcp", serverAddr, nil)
if err != nil {
        println("cannot connect to server", err.Error())
        return
} else {
        println("connected to server", serverAddr)
}
defer conn.Disconnect()
</pre>

<pre>
err = conn.Send(queueName, "text/plain", []byte("EXIT"), nil)
</pre>

<pre>
sub, err := conn.Subscribe(queueName, stomp.AckAuto)
if err != nil {
        println("cannot subscribe to", queueName, err.Error())
        return
}
close(subscribed)
</pre>

<pre>
for {
        msg := &lt;-sub.C
        text := string(msg.Body)
        ...
        ...
        ...
}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Implementace producenta zpráv (publishera)</h2>

<pre>
package main
&nbsp;
import (
        "fmt"
&nbsp;
        "github.com/go-stomp/stomp"
)
&nbsp;
const serverAddr = "localhost:61613"
const queueName = "/queue/go_test"
&nbsp;
const messageCount = 10
&nbsp;
func <strong>sendMessages</strong>() {
        conn, err := stomp.Dial("tcp", serverAddr, nil)
        if err != nil {
                println("cannot connect to server", err.Error())
                return
        } else {
                println("connected to server", serverAddr)
        }
        defer conn.Disconnect()
&nbsp;
        for i := 1; i &lt;= messageCount; i++ {
                text := fmt.Sprintf("Message #%d", i)
                err = conn.Send(queueName, "text/plain", []byte(text), nil)
                if err != nil {
                        println("failed to send to server", err)
                        return
                } else {
                        println("message sent")
                }
        }
        println("sending EXIT message")
        err = conn.Send(queueName, "text/plain", []byte("EXIT"), nil)
        if err != nil {
                println("failed to send EXIT message to server", err)
                return
        } else {
                println("message sent")
        }
        println("sender finished")
}
&nbsp;
func <strong>main</strong>() {
        sendMessages()
}
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Implementace konzumenta zpráv</h2>

<pre>
package main
&nbsp;
import (
        "github.com/go-stomp/stomp"
)
&nbsp;
const serverAddr = "localhost:61613"
const queueName = "/queue/go_test"
&nbsp;
func <strong>receiveMessages</strong>() {
        conn, err := stomp.Dial("tcp", serverAddr, nil)
&nbsp;
        if err != nil {
                println("cannot connect to server", err.Error())
                return
        } else {
                println("connected to server", serverAddr)
        }
&nbsp;
        defer conn.Disconnect()
&nbsp;
        sub, err := conn.Subscribe(queueName, stomp.AckAuto)
        if err != nil {
                println("cannot subscribe to", queueName, err.Error())
                return
        }
        for {
                msg := &lt;-sub.C
                text := string(msg.Body)
                if text != "EXIT" {
                        println("Received message", text)
                } else {
                        println("Received EXIT command")
                        break
                }
        }
        println("receiver finished")
}
&nbsp;
func <strong>main</strong>() {
        receiveMessages()
}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Úprava producenta a konzumenta tak, aby komunikace s&nbsp;message brokerem probíhala v&nbsp;gorutině</h2>

<pre>
package main
&nbsp;
import (
        "fmt"
&nbsp;
        "github.com/go-stomp/stomp"
)
&nbsp;
const serverAddr = "localhost:61613"
const queueName = "/queue/go_test"
&nbsp;
const messageCount = 10
&nbsp;
var stop = make(chan bool)
&nbsp;
func <strong>sendMessages</strong>() {
        defer func() {
                stop &lt;- true
        }()
&nbsp;
        conn, err := stomp.Dial("tcp", serverAddr, nil)
        if err != nil {
                println("cannot connect to server", err.Error())
                return
        } else {
                println("connected to server", serverAddr)
        }
        defer conn.Disconnect()
&nbsp;
        for i := 1; i &lt;= messageCount; i++ {
                text := fmt.Sprintf("Message #%d", i)
                err = conn.Send(queueName, "text/plain", []byte(text), nil)
                if err != nil {
                        println("failed to send to server", err)
                        return
                } else {
                        println("message sent")
                }
        }
        println("sending EXIT message")
        err = conn.Send(queueName, "text/plain", []byte("EXIT"), nil)
        if err != nil {
                println("failed to send EXIT message to server", err)
                return
        } else {
                println("message sent")
        }
        println("sender finished")
}
&nbsp;
func <strong>main</strong>() {
        go sendMessages()
&nbsp;
        <-stop
}
</pre>

<pre>
package main
&nbsp;
import (
        "github.com/go-stomp/stomp"
)
&nbsp;
const serverAddr = "localhost:61613"
const queueName = "/queue/go_test"
&nbsp;
var stop = make(chan bool)
&nbsp;
func <strong>receiveMessages</strong>(subscribed chan bool) {
        defer func() {
                stop &lt;- true
        }()
&nbsp;
        conn, err := stomp.Dial("tcp", serverAddr, nil)
&nbsp;
        if err != nil {
                println("cannot connect to server", err.Error())
                return
        } else {
                println("connected to server", serverAddr)
        }
&nbsp;
        defer conn.Disconnect()
&nbsp;
        sub, err := conn.Subscribe(queueName, stomp.AckAuto)
        if err != nil {
                println("cannot subscribe to", queueName, err.Error())
                return
        }
        close(subscribed)
&nbsp;
        for {
                msg := &lt;-sub.C
                text := string(msg.Body)
                if text != "EXIT" {
                        println("Received message", text)
                } else {
                        println("Received EXIT command")
                        break
                }
        }
        println("receiver finished")
}
&nbsp;
func <strong>main</strong>() {
        subscribed := make(chan bool)
        go receiveMessages(subscribed)
&nbsp;
        &lt;-subscribed
&nbsp;
        &lt;-stop
}
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů naprogramovaných
v&nbsp;Pythonu a taktéž v&nbsp;jazyku Go byly uloženy do Git repositáře, který
je dostupný na adrese <a
href="https://github.com/tisnik/message-queues-examples">https://github.com/tisnik/message-queues-examples</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
doslova několik kilobajtů), můžete namísto toho použít odkazy na jednotlivé
příklady, které naleznete v&nbsp;následující tabulce.</p>

<table>
<tr><th>Příklad</th><th>Skript/kód</th><th>Popis</th><th>Cesta</th></tr>
<tr><td>1</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amqp/">https://github.com/tisnik/message-queues-examples/blob/master/amqp/</a></td></tr>
<tr><td>1</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amqp/">https://github.com/tisnik/message-queues-examples/blob/master/amqp/</a></td></tr>
<tr><td>2</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amqp/">https://github.com/tisnik/message-queues-examples/blob/master/amqp/</a></td></tr>
<tr><td>2</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amqp/">https://github.com/tisnik/message-queues-examples/blob/master/amqp/</a></td></tr>
<tr><td>3</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amqp/">https://github.com/tisnik/message-queues-examples/blob/master/amqp/</a></td></tr>
<tr><td>3</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amqp/">https://github.com/tisnik/message-queues-examples/blob/master/amqp/</a></td></tr>
<tr><td>4</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amqp/">https://github.com/tisnik/message-queues-examples/blob/master/amqp/</a></td></tr>
<tr><td>4</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amqp/">https://github.com/tisnik/message-queues-examples/blob/master/amqp/</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/">https://github.com/tisnik/message-queues-examples/blob/master/</a></td></tr>
<tr><td>5</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/">https://github.com/tisnik/message-queues-examples/blob/master/</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>6</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/">https://github.com/tisnik/message-queues-examples/blob/master/</a></td></tr>
<tr><td>6</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/">https://github.com/tisnik/message-queues-examples/blob/master/</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na předchozí části seriálu</h2>

<p>V&nbsp;této kapitole jsou uvedeny odkazy na všech deset předchozích částí
seriálu, v&nbsp;němž se zabýváme různými způsoby implementace front zpráv a
k&nbsp;nim přidružených technologií:</p>

<ol>

<li>Použití nástroje RQ (Redis Queue) pro správu úloh zpracovávaných na pozadí<br />
<a href="https://www.root.cz/clanky/pouziti-nastroje-rq-redis-queue-pro-spravu-uloh-zpracovavanych-na-pozadi/">https://www.root.cz/clanky/pouziti-nastroje-rq-redis-queue-pro-spravu-uloh-zpracovavanych-na-pozadi/</a>
</li>

<li>Celery: systém implementující asynchronní fronty úloh pro Python<br />
<a href="https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python/">https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python/</a>
</li>

<li>Celery: systém implementující asynchronní fronty úloh pro Python (dokončení)<br />
<a href="https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python-dokonceni/">https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python-dokonceni/</a>
</li>

<li>RabbitMQ: jedna z nejúspěšnějších implementací brokera<br />
<a href="https://www.root.cz/clanky/rabbitmq-jedna-z-nejuspesnejsich-implementaci-brokera/">https://www.root.cz/clanky/rabbitmq-jedna-z-nejuspesnejsich-implementaci-brokera/</a>
</li>

<li>Pokročilejší operace nabízené systémem RabbitMQ<br />
<a href="https://www.root.cz/clanky/pokrocilejsi-operace-nabizene-systemem-rabbitmq/">https://www.root.cz/clanky/pokrocilejsi-operace-nabizene-systemem-rabbitmq/</a>
</li>

<li>ØMQ: knihovna pro asynchronní předávání zpráv<br />
<a href="https://www.root.cz/clanky/0mq-knihovna-pro-asynchronni-predavani-zprav/">https://www.root.cz/clanky/0mq-knihovna-pro-asynchronni-predavani-zprav/</a>
</li>

<li>Další možnosti poskytované knihovnou ØMQ<br />
<a href="https://www.root.cz/clanky/dalsi-moznosti-poskytovane-knihovnou-mq/">https://www.root.cz/clanky/dalsi-moznosti-poskytovane-knihovnou-mq/</a>
</li>

<li>Další možnosti nabízené knihovnou ØMQ, implementace protokolů ØMQ v čisté Javě<br />
<a href="https://www.root.cz/clanky/dalsi-moznosti-nabizene-knihovnou-mq-implementace-protokolu-mq-v-ciste-jave/">https://www.root.cz/clanky/dalsi-moznosti-nabizene-knihovnou-mq-implementace-protokolu-mq-v-ciste-jave/</a>
</li>

<li>Apache ActiveMQ – další systém implementující message brokera<br />
<a href="https://www.root.cz/clanky/apache-activemq-dalsi-system-implementujici-message-brokera/">https://www.root.cz/clanky/apache-activemq-dalsi-system-implementujici-message-brokera/</a>
</li>

<li>Použití Apache ActiveMQ s protokolem STOMP<br />
<a href="https://www.root.cz/clanky/pouziti-apache-activemq-s-protokolem-stomp/">https://www.root.cz/clanky/pouziti-apache-activemq-s-protokolem-stomp/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Stránka Apache Software Foundation<br />
<a href="http://www.apache.org/">http://www.apache.org/</a>
</li>

<li>Informace o portu 5672<br />
<a href="http://www.tcp-udp-ports.com/port-5672.htm">http://www.tcp-udp-ports.com/port-5672.htm</a>
</li>

<li>Třída MessagingHandler knihovny Qpid Proton<br />
<a href="https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._handlers.MessagingHandler-class.html">https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._handlers.MessagingHandler-class.html</a>
</li>

<li>Třída Event knihovny Qpid Proton<br />
<a href="https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._events.Event-class.html">https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._events.Event-class.html</a>
</li>

<li>package stomp (Go)<br />
<a href="https://godoc.org/github.com/go-stomp/stomp">https://godoc.org/github.com/go-stomp/stomp</a>
</li>

<li>Go language library for STOMP protocol<br />
<a href="https://github.com/go-stomp/stomp">https://github.com/go-stomp/stomp</a>
</li>

<li>python-qpid-proton 0.26.0 na PyPi<br />
<a href="https://pypi.org/project/python-qpid-proton/">https://pypi.org/project/python-qpid-proton/</a>
</li>

<li>Qpid Proton<br />
<a href="http://qpid.apache.org/proton/">http://qpid.apache.org/proton/</a>
</li>

<li>Using the AMQ Python Client<br />
<a href="https://access.redhat.com/documentation/en-us/red_hat_amq/7.1/html-single/using_the_amq_python_client/">https://access.redhat.com/documentation/en-us/red_hat_amq/7.1/html-single/using_the_amq_python_client/</a>
</li>

<li>Apache ActiveMQ<br />
<a href="http://activemq.apache.org/">http://activemq.apache.org/</a>
</li>

<li>Apache ActiveMQ Artemis<br />
<a href="https://activemq.apache.org/artemis/">https://activemq.apache.org/artemis/</a>
</li>

<li>Apache ActiveMQ Artemis User Manual<br />
<a href="https://activemq.apache.org/artemis/docs/latest/index.html">https://activemq.apache.org/artemis/docs/latest/index.html</a>
</li>

<li>KahaDB<br />
<a href="http://activemq.apache.org/kahadb.html">http://activemq.apache.org/kahadb.html</a>
</li>

<li>Understanding the KahaDB Message Store<br />
<a href="https://access.redhat.com/documentation/en-US/Fuse_MQ_Enterprise/7.1/html/Configuring_Broker_Persistence/files/KahaDBOverview.html">https://access.redhat.com/documentation/en-US/Fuse_MQ_Enterprise/7.1/html/Configuring_Broker_Persistence/files/KahaDBOverview.html</a>
</li>

<li>Command Line Tools (Apache ActiveMQ)<br />
<a href="https://activemq.apache.org/activemq-command-line-tools-reference.html">https://activemq.apache.org/activemq-command-line-tools-reference.html</a>
</li>

<li>stomp.py 4.1.21 na PyPi<br />
<a href="https://pypi.org/project/stomp.py/">https://pypi.org/project/stomp.py/</a>
</li>

<li>Stomp Tutorial<br />
<a href="https://access.redhat.com/documentation/en-US/Fuse_Message_Broker/5.5/html/Connectivity_Guide/files/FMBConnectivityStompTelnet.html">https://access.redhat.com/documentation/en-US/Fuse_Message_Broker/5.5/html/Connectivity_Guide/files/FMBConnectivityStompTelnet.html</a>
</li>

<li>Heartbeat (computing)<br />
<a href="https://en.wikipedia.org/wiki/Heartbeat_(computing)">https://en.wikipedia.org/wiki/Heartbeat_(computing)</a>
</li>

<li>Apache Camel<br />
<a href="https://camel.apache.org/">https://camel.apache.org/</a>
</li>

<li>Red Hat Fuse<br />
<a href="https://developers.redhat.com/products/fuse/overview/">https://developers.redhat.com/products/fuse/overview/</a>
</li>

<li>Confusion between ActiveMQ and ActiveMQ-Artemis?<br />
<a href="https://serverfault.com/questions/873533/confusion-between-activemq-and-activemq-artemis">https://serverfault.com/questions/873533/confusion-between-activemq-and-activemq-artemis</a>
</li>

<li>Staré stránky projektu HornetQ<br />
<a href="http://hornetq.jboss.org/">http://hornetq.jboss.org/</a>
</li>

<li>Snapshot JeroMQ verze 0.4.4<br />
<a href="https://oss.sonatype.org/content/repositories/snapshots/org/zeromq/jeromq/0.4.4-SNAPSHOT/">https://oss.sonatype.org/content/repositories/snapshots/org/zeromq/jeromq/0.4.4-SNAPSHOT/</a>
</li>

<li>Difference between ActiveMQ vs Apache ActiveMQ Artemis<br />
<a href="http://activemq.2283324.n4.nabble.com/Difference-between-ActiveMQ-vs-Apache-ActiveMQ-Artemis-td4703828.html">http://activemq.2283324.n4.nabble.com/Difference-between-ActiveMQ-vs-Apache-ActiveMQ-Artemis-td4703828.html</a>
</li>

<li>Microservices communications. Why you should switch to message queues<br />
<a href="https://dev.to/matteojoliveau/microservices-communications-why-you-should-switch-to-message-queues--48ia">https://dev.to/matteojoliveau/microservices-communications-why-you-should-switch-to-message-queues--48ia</a>
</li>

<li>Stomp.py 4.1.19 documentation<br />
<a href="https://stomppy.readthedocs.io/en/stable/">https://stomppy.readthedocs.io/en/stable/</a>
</li>

<li>Repositář knihovny JeroMQ<br />
<a href="https://github.com/zeromq/jeromq/">https://github.com/zeromq/jeromq/</a>
</li>

<li>ØMQ &ndash; Distributed Messaging <br />
<a href="http://zeromq.org/">http://zeromq.org/</a>
</li>

<li>ØMQ Community<br />
<a href="http://zeromq.org/community">http://zeromq.org/community</a>
</li>

<li>Get The Software<br />
<a href="http://zeromq.org/intro:get-the-software">http://zeromq.org/intro:get-the-software</a>
</li>

<li>PyZMQ Documentation<br />
<a href="https://pyzmq.readthedocs.io/en/latest/">https://pyzmq.readthedocs.io/en/latest/</a>
</li>

<li>Module: zmq.decorators<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.decorators.html">https://pyzmq.readthedocs.io/en/latest/api/zmq.decorators.html</a>
</li>

<li>ZeroMQ is the answer, by Ian Barber<br />
<a href="https://vimeo.com/20605470">https://vimeo.com/20605470</a>
</li>

<li>ZeroMQ RFC<br />
<a href="https://rfc.zeromq.org/">https://rfc.zeromq.org/</a>
</li>

<li>ZeroMQ and Clojure, a brief introduction<br />
<a href="https://antoniogarrote.wordpress.com/2010/09/08/zeromq-and-clojure-a-brief-introduction/">https://antoniogarrote.wordpress.com/2010/09/08/zeromq-and-clojure-a-brief-introduction/</a>
</li>

<li>zeromq/czmq<br />
<a href="https://github.com/zeromq/czmq">https://github.com/zeromq/czmq</a>
</li>

<li>golang wrapper for CZMQ<br />
<a href="https://github.com/zeromq/goczmq">https://github.com/zeromq/goczmq</a>
</li>

<li>ZeroMQ version reporting in Python<br />
<a href="http://zguide.zeromq.org/py:version">http://zguide.zeromq.org/py:version</a>
</li>

<li>A Go interface to ZeroMQ version 4<br />
<a href="https://github.com/pebbe/zmq4">https://github.com/pebbe/zmq4</a>
</li>

<li>Broker vs. Brokerless<br />
<a href="http://zeromq.org/whitepapers:brokerless">http://zeromq.org/whitepapers:brokerless</a>
</li>

<li>Learning ØMQ with pyzmq<br />
<a href="https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/">https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/</a>
</li>

<li>Céčková funkce <strong>zmq_ctx_new</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-ctx-new">http://api.zeromq.org/4-2:zmq-ctx-new</a>
</li>

<li>Céčková funkce <strong>zmq_ctx_destroy</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-ctx-destroy">http://api.zeromq.org/4-2:zmq-ctx-destroy</a>
</li>

<li>Céčková funkce <strong>zmq_bind</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-bind">http://api.zeromq.org/4-2:zmq-bind</a>
</li>

<li>Céčková funkce <strong>zmq_unbind</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-unbind">http://api.zeromq.org/4-2:zmq-unbind</a>
</li>

<li>Céčková C funkce <strong>zmq_connect</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-connect">http://api.zeromq.org/4-2:zmq-connect</a>
</li>

<li>Céčková C funkce <strong>zmq_disconnect</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-disconnect">http://api.zeromq.org/4-2:zmq-disconnect</a>
</li>

<li>Céčková C funkce <strong>zmq_send</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-send">http://api.zeromq.org/4-2:zmq-send</a>
</li>

<li>Céčková C funkce <strong>zmq_recv</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-recv">http://api.zeromq.org/4-2:zmq-recv</a>
</li>

<li>Třída <strong>Context</strong> (Python)<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.html#context">https://pyzmq.readthedocs.io/en/latest/api/zmq.html#context</a>
</li>

<li>Třída <strong>Socket</strong> (Python)<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.html#socket">https://pyzmq.readthedocs.io/en/latest/api/zmq.html#socket</a>
</li>

<li>Python binding<br />
<a href="http://zeromq.org/bindings:python">http://zeromq.org/bindings:python</a>
</li>

<li>Why should I have written ZeroMQ in C, not C++ (part I)<br />
<a href="http://250bpm.com/blog:4">http://250bpm.com/blog:4</a>
</li>

<li>Why should I have written ZeroMQ in C, not C++ (part II) <br />
<a href="http://250bpm.com/blog:8">http://250bpm.com/blog:8</a>
</li>

<li>About Nanomsg<br />
<a href="https://nanomsg.org/">https://nanomsg.org/</a>
</li>

<li>Advanced Message Queuing Protocol<br />
<a href="https://www.amqp.org/">https://www.amqp.org/</a>
</li>

<li>Advanced Message Queuing Protocol na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol">https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol</a>
</li>

<li>Dokumentace k&nbsp;příkazu <strong>rabbitmqctl</strong><br />
<a href="https://www.rabbitmq.com/rabbitmqctl.8.html">https://www.rabbitmq.com/rabbitmqctl.8.html</a>
</li>

<li>RabbitMQ<br />
<a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a>
</li>

<li>RabbitMQ Tutorials<br />
<a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a>
</li>

<li>RabbitMQ: Clients and Developer Tools<br />
<a href="https://www.rabbitmq.com/devtools.html">https://www.rabbitmq.com/devtools.html</a>
</li>

<li>RabbitMQ na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/RabbitMQ">https://en.wikipedia.org/wiki/RabbitMQ</a>
</li>

<li>Streaming Text Oriented Messaging Protocol<br />
<a href="https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol">https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol</a>
</li>

<li>Message Queuing Telemetry Transport<br />
<a href="https://en.wikipedia.org/wiki/MQTT">https://en.wikipedia.org/wiki/MQTT</a>
</li>

<li>Erlang<br />
<a href="http://www.erlang.org/">http://www.erlang.org/</a>
</li>

<li>pika 0.12.0 na PyPi<br />
<a href="https://pypi.org/project/pika/">https://pypi.org/project/pika/</a>
</li>

<li>Introduction to Pika<br />
<a href="https://pika.readthedocs.io/en/stable/">https://pika.readthedocs.io/en/stable/</a>
</li>

<li>Langohr: An idiomatic Clojure client for RabbitMQ that embraces the AMQP 0.9.1 model<br />
<a href="http://clojurerabbitmq.info/">http://clojurerabbitmq.info/</a>
</li>

<li>AMQP 0-9-1 Model Explained<br />
<a href="http://www.rabbitmq.com/tutorials/amqp-concepts.html">http://www.rabbitmq.com/tutorials/amqp-concepts.html</a>
</li>

<li>Part 1: RabbitMQ for beginners - What is RabbitMQ?<br />
<a href="https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html">https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html</a>
</li>

<li>Downloading and Installing RabbitMQ<br />
<a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a>
</li>

<li>celery na PyPi<br />
<a href="https://pypi.org/project/celery/">https://pypi.org/project/celery/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python <br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python (dokončení)<br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/</a>
</li>

<li>Redis Queue (RQ)<br />
<a href="https://www.fullstackpython.com/redis-queue-rq.html">https://www.fullstackpython.com/redis-queue-rq.html</a>
</li>

<li>Python Celery &amp; RabbitMQ Tutorial<br />
<a href="https://tests4geeks.com/python-celery-rabbitmq-tutorial/">https://tests4geeks.com/python-celery-rabbitmq-tutorial/</a>
</li>

<li>Flower: Real-time Celery web-monitor<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor">http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor</a>
</li>

<li>Asynchronous Tasks With Django and Celery<br />
<a href="https://realpython.com/asynchronous-tasks-with-django-and-celery/">https://realpython.com/asynchronous-tasks-with-django-and-celery/</a>
</li>

<li>First Steps with Celery<br />
<a href="http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html">http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html</a>
</li>

<li>node-celery<br />
<a href="https://github.com/mher/node-celery">https://github.com/mher/node-celery</a>
</li>

<li>Full Stack Python: web development<br />
<a href="https://www.fullstackpython.com/web-development.html">https://www.fullstackpython.com/web-development.html</a>
</li>

<li>Introducing RQ<br />
<a href="https://nvie.com/posts/introducing-rq/">https://nvie.com/posts/introducing-rq/</a>
</li>

<li>Asynchronous Tasks with Flask and Redis Queue<br />
<a href="https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue">https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Stránky projektu Redis<br />
<a href="https://redis.io/">https://redis.io/</a>
</li>

<li>Introduction to Redis<br />
<a href="https://redis.io/topics/introduction">https://redis.io/topics/introduction</a>
</li>

<li>Try Redis<br />
<a href="http://try.redis.io/">http://try.redis.io/</a>
</li>

<li>Redis tutorial, April 2010 (starší, ale pěkně udělaný)<br />
<a href="https://static.simonwillison.net/static/2010/redis-tutorial/">https://static.simonwillison.net/static/2010/redis-tutorial/</a>
</li>

<li>Python Redis<br />
<a href="https://redislabs.com/lp/python-redis/">https://redislabs.com/lp/python-redis/</a>
</li>

<li>Redis: key-value databáze v paměti i na disku<br />
<a href="https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/">https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/</a>
</li>

<li>Praktický úvod do Redis (1): vaše distribuovaná NoSQL cache<br />
<a href="http://www.cloudsvet.cz/?p=253">http://www.cloudsvet.cz/?p=253</a>
</li>

<li>Praktický úvod do Redis (2): transakce<br />
<a href="http://www.cloudsvet.cz/?p=256">http://www.cloudsvet.cz/?p=256</a>
</li>

<li>Praktický úvod do Redis (3): cluster<br />
<a href="http://www.cloudsvet.cz/?p=258">http://www.cloudsvet.cz/?p=258</a>
</li>

<li>Connection pool<br />
<a href="https://en.wikipedia.org/wiki/Connection_pool">https://en.wikipedia.org/wiki/Connection_pool</a>
</li>

<li>Instant Redis Sentinel Setup<br />
<a href="https://github.com/ServiceStack/redis-config">https://github.com/ServiceStack/redis-config</a>
</li>

<li>How to install REDIS in LInux<br />
<a href="https://linuxtechlab.com/how-install-redis-server-linux/">https://linuxtechlab.com/how-install-redis-server-linux/</a>
</li>

<li>Redis RDB Dump File Format<br />
<a href="https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format">https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format</a>
</li>

<li>Lempel–Ziv–Welch<br />
<a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch">https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch</a>
</li>

<li>Redis Persistence<br />
<a href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a>
</li>

<li>Redis persistence demystified<br />
<a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html">http://oldblog.antirez.com/post/redis-persistence-demystified.html</a>
</li>

<li>Redis reliable queues with Lua scripting<br />
<a href="http://oldblog.antirez.com/post/250">http://oldblog.antirez.com/post/250</a>
</li>

<li>Ost (knihovna)<br />
<a href="https://github.com/soveran/ost">https://github.com/soveran/ost</a>
</li>

<li>NoSQL<br />
<a href="https://en.wikipedia.org/wiki/NoSQL">https://en.wikipedia.org/wiki/NoSQL</a>
</li>

<li>Shard (database architecture)<br />
<a href="https://en.wikipedia.org/wiki/Shard_%28database_architecture%29">https://en.wikipedia.org/wiki/Shard_%28database_architecture%29</a>
</li>

<li>What is sharding and why is it important?<br />
<a href="https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important">https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important</a>
</li>

<li>What Is Sharding?<br />
<a href="https://btcmanager.com/what-sharding/">https://btcmanager.com/what-sharding/</a>
</li>

<li>Redis clients<br />
<a href="https://redis.io/clients">https://redis.io/clients</a>
</li>

<li>Category:Lua-scriptable software<br />
<a href="https://en.wikipedia.org/wiki/Category:Lua-scriptable_software">https://en.wikipedia.org/wiki/Category:Lua-scriptable_software</a>
</li>

<li>Seriál Programovací jazyk Lua<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-lua/">https://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>Redis memory usage<br />
<a href="http://nosql.mypopescu.com/post/1010844204/redis-memory-usage">http://nosql.mypopescu.com/post/1010844204/redis-memory-usage</a>
</li>

<li>Ukázka konfigurace Redisu pro lokální testování<br />
<a href="https://github.com/tisnik/presentations/blob/master/redis/redis.conf">https://github.com/tisnik/presentations/blob/master/redis/redis.conf</a>
</li>

<li>Resque<br />
<a href="https://github.com/resque/resque">https://github.com/resque/resque</a>
</li>

<li>Nested transaction<br />
<a href="https://en.wikipedia.org/wiki/Nested_transaction">https://en.wikipedia.org/wiki/Nested_transaction</a>
</li>

<li>Publish–subscribe pattern<br />
<a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern</a>
</li>

<li>Messaging pattern<br />
<a href="https://en.wikipedia.org/wiki/Messaging_pattern">https://en.wikipedia.org/wiki/Messaging_pattern</a>
</li>

<li>Using pipelining to speedup Redis queries<br />
<a href="https://redis.io/topics/pipelining">https://redis.io/topics/pipelining</a>
</li>

<li>Pub/Sub<br />
<a href="https://redis.io/topics/pubsub">https://redis.io/topics/pubsub</a>
</li>

<li>ZeroMQ distributed messaging<br />
<a href="http://zeromq.org/">http://zeromq.org/</a>
</li>

<li>ZeroMQ: Modern &amp; Fast Networking Stack<br />
<a href="https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/">https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/</a>
</li>

<li>Publish/Subscribe paradigm: Why must message classes not know about their subscribers?<br />
<a href="https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr">https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr</a>
</li>

<li>Python &amp; Redis PUB/SUB<br />
<a href="https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7">https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7</a>
</li>

<li>Message broker<br />
<a href="https://en.wikipedia.org/wiki/Message_broker">https://en.wikipedia.org/wiki/Message_broker</a>
</li>

<li>RESP Arrays<br />
<a href="https://redis.io/topics/protocol#array-reply">https://redis.io/topics/protocol#array-reply</a>
</li>

<li>Redis Protocol specification<br />
<a href="https://redis.io/topics/protocol">https://redis.io/topics/protocol</a>
</li>

<li>Redis Pub/Sub: Intro Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-intro/">https://www.redisgreen.net/blog/pubsub-intro/</a>
</li>

<li>Redis Pub/Sub: Howto Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-howto/">https://www.redisgreen.net/blog/pubsub-howto/</a>
</li>

<li>Comparing Publish-Subscribe Messaging and Message Queuing<br />
<a href="https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message">https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message</a>
</li>

<li>Apache Kafka<br />
<a href="https://kafka.apache.org/">https://kafka.apache.org/</a>
</li>

<li>Iron<br />
<a href="http://www.iron.io/mq">http://www.iron.io/mq</a>
</li>

<li>kue (založeno na Redisu, určeno pro node.js)<br />
<a href="https://github.com/Automattic/kue">https://github.com/Automattic/kue</a>
</li>

<li>Cloud Pub/Sub<br />
<a href="https://cloud.google.com/pubsub/">https://cloud.google.com/pubsub/</a>
</li>

<li>Introduction to Redis Streams<br />
<a href="https://redis.io/topics/streams-intro">https://redis.io/topics/streams-intro</a>
</li>

<li>glob (programming)<br />
<a href="https://en.wikipedia.org/wiki/Glob_(programming)">https://en.wikipedia.org/wiki/Glob_(programming)</a>
</li>

<li>Why and how Pricing Assistant migrated from Celery to RQ - Paris.py<br />
<a href="https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2">https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2</a>
</li>

<li>Enqueueing internals<br />
<a href="http://python-rq.org/contrib/">http://python-rq.org/contrib/</a>
</li>

<li>queue — A synchronized queue class<br />
<a href="https://docs.python.org/3/library/queue.html">https://docs.python.org/3/library/queue.html</a>
</li>

<li>Queue – A thread-safe FIFO implementation<br />
<a href="https://pymotw.com/2/Queue/">https://pymotw.com/2/Queue/</a>
</li>

<li>Queues<br />
<a href="http://queues.io/">http://queues.io/</a>
</li>

<li>Windows Subsystem for Linux Documentation<br />
<a href="https://docs.microsoft.com/en-us/windows/wsl/about">https://docs.microsoft.com/en-us/windows/wsl/about</a>
</li>

<li>RestMQ<br />
<a href="http://restmq.com/">http://restmq.com/</a>
</li>

<li>ActiveMQ<br />
<a href="http://activemq.apache.org/">http://activemq.apache.org/</a>
</li>

<li>Amazon MQ<br />
<a href="https://aws.amazon.com/amazon-mq/">https://aws.amazon.com/amazon-mq/</a>
</li>

<li>Amazon Simple Queue Service<br />
<a href="https://aws.amazon.com/sqs/">https://aws.amazon.com/sqs/</a>
</li>

<li>Celery: Distributed Task Queue<br />
<a href="http://www.celeryproject.org/">http://www.celeryproject.org/</a>
</li>

<li>Disque, an in-memory, distributed job queue<br />
<a href="https://github.com/antirez/disque">https://github.com/antirez/disque</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Projekt RQ na PyPi<br />
<a href="https://pypi.org/project/rq/">https://pypi.org/project/rq/</a>
</li>

<li>rq-dashboard 0.3.12<br />
<a href="https://pypi.org/project/rq-dashboard/">https://pypi.org/project/rq-dashboard/</a>
</li>

<li>Job queue<br />
<a href="https://en.wikipedia.org/wiki/Job_queue">https://en.wikipedia.org/wiki/Job_queue</a>
</li>

<li>Why we moved from Celery to RQ<br />
<a href="https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq">https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq</a>
</li>

<li>Running multiple workers using Celery<br />
<a href="https://serverfault.com/questions/655387/running-multiple-workers-using-celery">https://serverfault.com/questions/655387/running-multiple-workers-using-celery</a>
</li>

<li>celery — Distributed processing<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.html">http://docs.celeryproject.org/en/latest/reference/celery.html</a>
</li>

<li>Chains<br />
<a href="https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains">https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains</a>
</li>

<li>Routing<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing">http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing</a>
</li>

<li>Celery Distributed Task Queue in Go<br />
<a href="https://github.com/gocelery/gocelery/">https://github.com/gocelery/gocelery/</a>
</li>

<li>Python Decorators<br />
<a href="https://wiki.python.org/moin/PythonDecorators">https://wiki.python.org/moin/PythonDecorators</a>
</li>

<li>Periodic Tasks<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html">http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html</a>
</li>

<li>celery.schedules<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab">http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab</a>
</li>

<li>Pros and cons to use Celery vs. RQ<br />
<a href="https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq">https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq</a>
</li>

<li>Priority queue<br />
<a href="https://en.wikipedia.org/wiki/Priority_queue">https://en.wikipedia.org/wiki/Priority_queue</a>
</li>

<li>Jupyter<br />
<a href="https://jupyter.org/">https://jupyter.org/</a>
</li>

<li>How IPython and Jupyter Notebook work<br />
<a href="https://jupyter.readthedocs.io/en/latest/architecture/how_jupyter_ipython_work.html">https://jupyter.readthedocs.io/en/latest/architecture/how_jupyter_ipython_work.html</a>
</li>

<li>Context Managers<br />
<a href="http://book.pythontips.com/en/latest/context_managers.html">http://book.pythontips.com/en/latest/context_managers.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

