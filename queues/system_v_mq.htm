<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Fronty zpráv podle Systemu V</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>


<body>

<h1>Fronty zpráv podle Systemu V</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V seriálu o message brokerech jsme se již seznámili s&nbsp;celou řadou více či méně komplikovaných a pokročilých technologií implementujících fronty zpráv. Ovšem již v&nbsp;samotné základní instalaci Linuxu nalezneme hned dvě implementace front zpráv. Jedna z implementací vznikla v Systemu V, druhá je definována v POSIXu.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Fronty zpráv podle Systemu V</a></p>
<p><a href="#k02">2. Tři příkazy a čtveřice knihovních funkcí použitých při práci s&nbsp;frontami zpráv</a></p>
<p><a href="#k03">3. Příkazy <strong>ipcs</strong> a <strong>ipcrm</strong></a></p>
<p><a href="#k04">4. Získání klíče použitého pro vytvoření nové fronty</a></p>
<p><a href="#k05">5. Vytvoření nové fronty funkcí <strong>msgget</strong></a></p>
<p><a href="#k06">6. Poslání zprávy do fronty funkcí <strong>msgsnd</strong></a></p>
<p><a href="#k07">7. Připojení k&nbsp;existující frontě a přečtení zprávy funkcí <strong>msgrcv</strong></a></p>
<p><a href="#k08">8. Spuštění producenta i konzumenta zprávy</a></p>
<p><a href="#k09">9. Připojení k&nbsp;existující frontě a přečtení zprávy</a></p>
<p><a href="#k10">10. Producent posílající více zpráv</a></p>
<p><a href="#k11">11. Konzument akceptující postupně všechny zprávy</a></p>
<p><a href="#k12">12. Chování producenta při zaplnění fronty</a></p>
<p><a href="#k13">13. Poslání zprávy do fronty bez čekání</a></p>
<p><a href="#k14">*** 14. Přečtení doplňujících informací o frontě funkcí <strong>msgctl</strong></a></p>
<p><a href="#k15">*** 15. Možné konfigurace: více producentů a jeden konzument, jeden konzument a více producentů atd.</a></p>
<p><a href="#k16">*** 16. Filtrace zpráv podle nastaveného typu</a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Fronty zpráv podle Systemu V</h2>

<p>Pokud se podíváme na <a
href="https://www.root.cz/serialy/message-brokery/">seznam předchozích
částí</a> seriálu o message brokerech, uvidíme, že jsme se prozatím zabývali
popisem mnoha více či méně komplikovaných a současně i pokročilých technologií,
od relativně jednoduchých knihoven typu <a
href="https://www.root.cz/clanky/0mq-knihovna-pro-asynchronni-predavani-zprav/">ØMQ</a>
a <a
href="https://www.root.cz/clanky/implementace-ruznych-komunikacnich-strategii-s-vyuzitim-knihovny-nanomsg/">Nanomsg</a>
přes klasické message brokery typu <a
href="https://www.root.cz/clanky/rabbitmq-jedna-z-nejuspesnejsich-implementaci-brokera/">RabbitMQ</a>
a <a
href="https://www.root.cz/clanky/apache-activemq-dalsi-system-implementujici-message-brokera/">Apache
ActiveMQ</a> až po sofistikované systémy, které se již z&nbsp;klasifikace
message brokerů vymykají (příkladem je <a
href="https://www.root.cz/clanky/nats-streaming-server/">NATS Streaming
Server</a> a <a
href="https://www.root.cz/clanky/nsq-system-pro-dorucovani-zprav-bez-centralniho-message-brokera/">Nsq</a>).
Všechny výše zmíněné nástroje je nutné explicitně nainstalovat a patřičným
způsobem nakonfigurovat.</p>

<p>Ovšem už v&nbsp;základní instalaci Linuxu (a vlastně i většiny dalších
unixových systémů &ndash; až na několik výjimek) mají vývojáři k&nbsp;dispozici
hned dvě implementace front zpráv určených pro meziprocesovou komunikaci
v&nbsp;rámci jednoho systému. První implementace vychází ze Systemu V, druhá je
pak definována v&nbsp;POSIXu. V&nbsp;dnešním článku se zaměříme na popis
prvního systému založeného na implementaci použité <a
href="https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Unix_history-simple.svg/1200px-Unix_history-simple.svg.png">v&nbsp;Systemu
V</a>, což je mj.&nbsp;i jeden z&nbsp;přímých předchůdců Solarisu, ovšem
vlastnosti Systemu V se postupně dostaly do dalších unixových systémů i do
Linuxu. Tyto fronty zpráv lze v&nbsp;současnosti použít prakticky kdekoli a
navíc se jedná o relativně jednoduše zvládnutelnou technologii, pro jejíž
využití postačuje znát pouze tři příkazy a čtyři knihovní funkce (volatelné
z&nbsp;céčka a tím pádem i z&nbsp;prakticky jakéhokoli programovacího jazyka
s&nbsp;FFI či obdobnou technologií). Ovšem pozor &ndash; ani jedna implementace
plně nenahrazuje klasické message brokery &ndash; jedná se o nástroje vhodné
skutečně především pro implementaci komunikace mezi několika procesy, které tak
nemusí být pevně svázány; navíc je veškerá komunikace asynchronní. Ovšem
například není zajištěna persistence zpráv, potvrzení zpracování zprávy
atd.</p>

<p><div class="rs-tip-major">Poznámka: tím, že se jedná o implementaci
komunikace mezi procesy na lokální úrovni, odpadá většina problémů spojená
s&nbsp;použitím síťových rozhraní a protokolů (tedy nutnost potvrzování
příkazů, reakce na rozpad spojení atd.). Na druhou stranu pochopitelně přijdeme
o možnost škálování systému přes více fyzických počítačů.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Tři příkazy a čtveřice knihovních funkcí použitých při práci s&nbsp;frontami zpráv</h2>

<p><a href="#k01">V&nbsp;úvodní kapitole</a> jsme si mj.&nbsp;řekli, že pro
práci se systémem front zpráv odvozených od Systemu V je zapotřebí znát pouze
trojici příkazů a čtveřici knihovních funkcí. Nejprve se podívejme na příkazy,
které se při práci s&nbsp;frontami používají:</p>

<table>
<tr><th>#</th><th>Příkaz</th><th>Stručný popis příkazu</th></tr>
<tr><td>1</td><td>ipcs</td><td>získání informací o vybraném prostředku používaném pro IPC</td></tr>
<tr><td>2</td><td>ipcmk</td><td>vytvoření prostředku používaného pro IPC (mk=make)</td></tr>
<tr><td>3</td><td>ipcrm</td><td>odstranění prostředku používaného pro IPC (rm=remove)</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: mezi prostředky pro IPC (tedy pro
komunikaci mezi procesy běžícími v&nbsp;rámci jednoho počítače/systému) patří
fronty, semafory a sdílená paměť. Navíc se může jednat i o anonymní a
pojmenované roury (<i>pipe</i>) a pochopitelně i o sockety (<i>sockets</i>),
které však nejsou výše uvedenými příkazy zpracovávány.</div></p>

<p>V&nbsp;aplikacích a nástrojích vytvářených v&nbsp;programovacím jazyku C
(což je ve světě Unixu standardní systémový jazyk) se pro práci s&nbsp;frontami
zpráv mohou použít následující čtyři funkce, jejichž konkrétní příklady použití
si ukážeme v&nbsp;navazujících kapitolách:</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Stručný popis funkce</th></tr>
<tr><td>1</td><td>msgget</td><td>vytvoření nové fronty či získání existující fronty s&nbsp;daným identifikátorem (celé číslo)</td></tr>
<tr><td>2</td><td>msgctl</td><td>provedení jedné ze tří funkcí: informace o frontě, změna nastavení fronty nebo smazání fronty</td></tr>
<tr><td>3</td><td>msgsnd</td><td>poslání zprávy do fronty (s&nbsp;čekáním či bez čekání při zaplnění fronty, podle nastavení příznaků)</td></tr>
<tr><td>4</td><td>msgrcv</td><td>přečtení zprávy z&nbsp;fronty (s&nbsp;čekáním či bez čekání v&nbsp;případě prázdné fronty, podle nastavení příznaků)</td></tr>
</table>

<p>Všechny čtyři výše zmíněné funkce budou použity v&nbsp;dnešních
demonstračních příkladech.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Příkazy <strong>ipcs</strong> a <strong>ipcrm</strong></h2>

<p>Nejprve se podívejme na základní operace poskytované příkazy
<strong>ipcs</strong> a <strong>ipcrm</strong>, které byly vypsány
v&nbsp;tabulce v&nbsp;předchozí kapitole. Tyto příkazy je možné použít pro
administraci front, zjišťování jejich aktuálního stavu, jejich mazání atd.
Pokud spustíme příkaz <strong>ipcs</strong> bez parametrů, zobrazí se seznam
všech existujících prostředků použitých pro IPC, tedy pro komunikaci mezi
několika procesy. Jak již víme, může se jednat o semafory, sdílenou paměť a
právě i o fronty zpráv:</p>

<pre>
$ <strong>ipcs</strong>
</pre>

<p>Na mém testovacím počítači se původně (před spuštěním dnešních
demonstračních příkazů) vypsaly informace pouze o několika regionech sdílené
paměti, ovšem žádné fronty ani semafory neexistovaly, resp.&nbsp;přesněji
řečeno je žádné aplikace nevytvořily a nepoužívaly:</p>

<pre>
------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages
&nbsp;
------ Shared Memory Segments --------
key        shmid      owner      perms      bytes      nattch     status
0x00000000 1146880    ptisnovs   600        524288     2          dest
0x00000000 2686977    ptisnovs   600        7925760    2          dest
0x00000000 2719746    ptisnovs   600        393216     2          dest
0x00000000 2588675    ptisnovs   600        7925760    2          dest
0x00000000 2818052    ptisnovs   600        524288     2          dest
0x00000000 2850821    ptisnovs   600        393216     2          dest
0x00000000 4423686    ptisnovs   600        155648     2          dest
0x00000000 3145735    ptisnovs   600        2867200    2          dest
0x00000000 3112968    ptisnovs   600        2867200    2          dest
0x00000000 3342345    ptisnovs   600        135168     2          dest
0x00000000 3309578    ptisnovs   600        135168     2          dest
0x00000000 4456459    ptisnovs   600        155648     2          dest
&nbsp;
------ Semaphore Arrays --------
key        semid      owner      perms      nsems
</pre>

<p>Zobrazit je možné i informace o vlastnících jednotlivých prostředků, a to
konkrétně přepínačem <strong>-c</strong>:</p>

<pre>
$ <strong>ipcs -c</strong>
&nbsp;
------ Message Queues Creators/Owners --------
msqid      perms      cuid       cgid       uid        gid       
0          660        ptisnovs   ptisnovs   ptisnovs   ptisnovs  
&nbsp;
------ Shared Memory Segment Creators/Owners --------
shmid      perms      cuid       cgid       uid        gid       
1146880    600        ptisnovs   ptisnovs   ptisnovs   ptisnovs  
&nbsp;
------ Semaphore Arrays Creators/Owners --------
semid      perms      cuid       cgid       uid        gid       
</pre>

<p>A dokonce si můžeme zobrazit i informace o procesech, které prostředky
naposledy využily:</p>

<pre>
$ <strong>ipcs -p</strong>
&nbsp;
------ Message Queues PIDs --------
msqid      owner      lspid      lrpid     
0        ptisnovs     5586      5560
&nbsp;
------ Shared Memory Creator/Last-op PIDs --------
shmid      owner      cpid       lpid      
1146880    ptisnovs   1901       1811      
</pre>

<p>Využití (utilizaci) prostředků získáme příkazem:</p>

<pre>
$ <strong>ipcs -u</strong>
&nbsp;
------ Shared Memory Status --------
segments allocated 3
pages allocated 320
pages resident  112
pages swapped   0
Swap performance: 0 attempts     0 successes
&nbsp;
------ Semaphore Status --------
used arrays = 0
allocated semaphores = 0
&nbsp;
------ Messages Status --------
allocated queues = 0
used headers = 0
used space = 0 bytes
</pre>

<p>Aktuálně nastavené limity (počet prostředků, maximální kapacita paměti,
počet front atd.) je možné vypsat po zadání přepínače <strong>-l</strong>:</p>

<pre>
$ <strong>ipcs -l</strong>
&nbsp;
------ Shared Memory Limits --------
max number of segments = 4096
max seg size (kbytes) = 32768
max total shared memory (kbytes) = 8388608
min seg size (bytes) = 1
&nbsp;
------ Semaphore Limits --------
max number of arrays = 128
max semaphores per array = 250
max semaphores system wide = 32000
max ops per semop call = 32
semaphore max value = 32767
&nbsp;
------ Messages Limits --------
max queues system wide = 1250
max size of message (bytes) = 8192
default max size of queue (bytes) = 16384
</pre>

<p>Nás však budou zajímat pouze informace o frontách, takže navíc přidáme i
přepínač <strong>-q</strong>:</p>

<pre>
$ <strong>ipcs -l -q</strong>
&nbsp;
------ Messages Limits --------
max queues system wide = 937
max size of message (bytes) = 8192
default max size of queue (bytes) = 16384
</pre>

<p><div class="rs-tip-major">Poznámka: poslední dvě hodnoty lze použít pro
výpočet maximálního počtu zpráv, které je možné umístit do fronty. Pokud budou
mít zprávy maximální možnou velikost, bude jejich počet (na mé konfiguraci)
pouze dvě zprávy, ovšem většinou budou zprávy menší. U zpráv o velikosti 16
bajtů (rozumné číslo pro předání několika parametrů) by se jednalo o 1024
zpráv.</div></p>

<p>Na dalším testovacím počítači zobrazíme počet front &ndash; bude zpočátku
nulový:</p>

<pre>
$ <strong>ipcs -q</strong>
&nbsp;
------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages
</pre>

<p>Pokud by nějaká fronta existovala, byl by výpis odlišný (zde konkrétně
ukazuje sedm zpráv o celkové délce 700 bajtů):</p>

<pre>
$ <strong>ipcs -q</strong>
&nbsp;
------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages    
0x2e010dbb 0          tester     660        700          7           
</pre>

<p>Fronta má ID=0 (msqid=message queue ID), takže ji můžeme smazat příkazem
<strong>icrm</strong>:</p>

<pre>
$ <strong>ipcrm -q 0</strong>
</pre>

<p>Nyní již při novém výpisu front frontu s&nbsp;ID=0 neuvidíme:</p>

<pre>
$ <strong>ipcs -q</strong>
&nbsp;
------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages    
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Získání klíče použitého pro vytvoření nové fronty</h2>

<p>Dva základní příkazy pro práci (nejenom) s&nbsp;frontami už známe, takže se
nyní podívejme na to, jak lze s&nbsp;frontami pracovat z&nbsp;programovacího
jazyka C či z&nbsp;libovolného programovacího jazyka, který má přístup ke
standardním céčkovským knihovnách (Python a LuaJIT přes FFI atd. atd.). Pro
vytvoření fronty či pro přístup k&nbsp;existující frontě se používá takzvaný
klíč (<i>key</i>), což je celé číslo typu <strong>key_t</strong>, které by
v&nbsp;ideálním případě mělo být na daném systému unikátní a jedinečné.
Z&nbsp;tohoto důvodu se klíč vytváří funkcí <strong>ftok</strong>, které se
předá jméno libovolného souboru a další celé číslo. Funkce
<strong>frok</strong> na základě <i>inode</i> předaného souboru a druhého čísla
(z&nbsp;něhož se v&nbsp;tradičních systémech přebírá spodních osm bitů) vytvoří
klíč, který lze použít ve všech procesech, které budou frontu používat. Pokud
tato funkce z&nbsp;nějakého důvodu zhavaruje (neexistující soubor atd.), vrátí
se chybová hodnota -1:</p>

<pre>
key_t key;
&nbsp;
key = <strong>ftok</strong>("/home/tester/.bashrc", 1234);
&nbsp;
if (key == -1) {
    perror("Unable to generate key");
    return 2;
}
&nbsp;
printf("Key: %x\n", key);
</pre>

<p><div class="rs-tip-major">Poznámka: ~ ani další znaky ve jméně souboru se
v&nbsp;tomto případě neexpandují.</div></p>

<p>Teoreticky by se pro zadanou dvojici jméno_souboru+celé číslo měl vytvořit
unikátní klíč, který se nebude rovnat klíči získanému s&nbsp;jakýmikoli jinými
parametry. Ovšem pokud je v&nbsp;systému připojeno (<i>mount</i>) více
souborových systémů, mohou být <i>inode</i> různých souborů (na různých
souborových systémech) shodné a tím pádem bude shodný i vygenerovaný klíč. Také
záleží na konkrétním algoritmu výpočtu &ndash; někdy se bere v&nbsp;úvahu jen
16 bitů z&nbsp;čísla inode, což může vést ke kolizi i v&nbsp;případě, že se
používá jen jediný připojený systém. Na druhou stranu se většinou příliš mnoho
front nepoužívá (což jsme ostatně viděli i v&nbsp;předchozí kapitole), takže
nebezpečí reálné kolize bude nízké.</p>

<p><div class="rs-tip-major">Poznámka: díky tomu, že se z&nbsp;druhé hodnoty
předané do funkce <strong>ftok</strong> získává jen spodních osm bitů, můžeme
zde uvést jen znak, například 'x' atd. To dobře koresponduje
s&nbsp;historickými systémy, kde byl druhý parametr typu
<strong>char</strong>:</div></p>

<pre>
key_t key;
&nbsp;
key = <strong>ftok</strong>("/home/tester/.bashrc", 'x');
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Vytvoření nové fronty funkcí <strong>msgget</strong></h2>

<p>Jakmile máme k&nbsp;dispozici klíč, který bude shodný pro všechny procesy
používající frontu, můžeme se pokusit o vytvoření nové fronty, a to konkrétně
funkcí <strong>msgget</strong>. Jméno této funkce může být poněkud matoucí,
ovšem jedná se o funkci pro získání obecné fronty &ndash; ať již existující,
tak nové. V&nbsp;případě, že tato funkce vrátí kladné číslo nebo nulu, jedná se
o identifikátor fronty, pokud vrátí hodnotu -1, značí to chybu:</p>

<pre>
int queue_id;
&nbsp;
queue_id = <strong>msgget</strong>(key, IPC_CREAT | 0660);
&nbsp;
if (queue_id == -1) {
    perror("Unable to get message queue identifier");
    return 2;
}
</pre>

<p>Povšimněte si druhého parametru funkce <strong>msgget</strong>. Zde se
předává několik bitových příznaků, přičemž příznak (bit)
<strong>IPC_CREAT</strong> udává, že se má vytvořit nová fronta a další
příznaky slouží k&nbsp;nastavení práv ke frontě (ta jsou podobná jako práva
k&nbsp;souborům, ovšem až na příznak <i>x</i>, který zde nemá význam &ndash;
frontu není možné &bdquo;spustit&ldquo;). V&nbsp;našem případě jsme nastavili
příznaky 0660 (osmičkově), tedy čtení i zápis pro vlastníka i skupinu. Ovšem
pochopitelně můžeme namísto čísla použít i kombinaci symbolických konstant
<strong>S_IRUSR</strong>, <strong>S_IWUSR</strong>, <strong>S_IRGRP</strong>,
<strong>S_IWGRP</strong>, <strong>S_IROTH</strong> a <strong>S_IWOTH</strong>,
osobně mi ovšem oktalový zápis přijde mnohem čitelnější.</p>

<p>Nastavené příznaky přístupu uvidíme i ve výstupu příkazu
<strong>ipcs</strong>:</p>

<pre>
$ <strong>ipcs -q</strong>
&nbsp;
------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages    
0x2e010dbb 0          tester     660        700          7           
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Poslání zprávy do fronty funkcí <strong>msgsnd</strong></h2>

<p>Nyní, když již máme frontu vytvořenou, se můžeme pokusit do ní poslat
nějakou zprávu. Zpráva má formát struktury, v&nbsp;níž je na začátku uložen typ
zprávy (nenulové číslo) následované libovolnou sekvencí bajtů. Pro jednoduchost
budeme používat zprávy s&nbsp;konstantní délkou 100 bajtů reprezentované touto
strukturou (typ ovšem není součástí délky zprávy):</p>

<pre>
typedef struct {
    long message_type;
    char message_text[100];
} t_message;
&nbsp;
t_message message;
&nbsp;
message.message_type = 1;
strcpy(message.message_text, "Hello world!");
</pre>

<p><div class="rs-tip-major">Poznámka: zcela korektní by bylo použít typ
<strong>__syscall_slong_t</strong> pro typ zprávy, v&nbsp;Linuxu se ovšem jedná
o typ odvozený právě od <strong>long</strong>.</div></p>

<p>Poslání zprávy do fronty s&nbsp;ID uloženým v&nbsp;proměnné
<strong>queue_id</strong> zajišťuje funkce <strong>msgsnd</strong>, které
musíme předat jak ID fronty (první parametr), tak i strukturu se zprávou (druhý
parametr), její délku (třetí parametr) a případné další příznaky (čtvrtý
parametr), které si vysvětlíme v&nbsp;navazujících kapitolách:</p>

<pre>
status = <strong>msgsnd</strong>(queue_id, (void*)&amp;message, sizeof(message.message_text), 0);
&nbsp;
if (status == -1) {
    perror("Can not send message");
    return 1;
}
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;předchozím volání jsme použili
<strong>sizeof(message.message_text)</strong> namísto
<strong>strlen(message.message_text)</strong>, protože posíláme zprávy
konstantní délky, bez ohledu na to, že budou obsahovat nulou ukončený řetězec a
případné náhodné bajty. Kvůli tomu, že typ zprávy se do délky nepřidává, nelze
použít <strong>sizeof(message)</strong>, resp.&nbsp;použít lze, ale musíme
odečíst <strong>sizeof(long)</strong>.</div></p>

<p>Podívejme se nyní na zdrojový kód jednoduchého producenta zpráv, který po
svém spuštění vytvoří frontu a pošle do ní jedinou zprávu s&nbsp;obsahem
&bdquo;Hello world!&ldquo;. V&nbsp;programu se kontroluje, zda se podařilo
frontu vytvořit a zda se poslání zprávy skutečně podařilo či nikoli:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
&nbsp;
#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/msg.h&gt;
&nbsp;
typedef struct {
    long message_type;
    char message_text[100];
} t_message;
&nbsp;
int main(void)
{
    t_message message;
    key_t key;
    int queue_id;
    int status;
&nbsp;
    message.message_type = 1;
    strcpy(message.message_text, "Hello world!");
&nbsp;
    key = <strong>ftok</strong>("/home/tester/.bashrc", 1234);
&nbsp;
    if (key == -1) {
        perror("Unable to generate key");
        return 2;
    }
&nbsp;
    printf("Key: %x\n", key);
&nbsp;
    queue_id = <strong>msgget</strong>(key, IPC_CREAT | 0660);
&nbsp;
    if (queue_id == -1) {
        perror("Unable to get message queue identifier");
        return 2;
    }
&nbsp;
    printf("Message queue identifier: %x\n", queue_id);
&nbsp;
    status = <strong>msgsnd</strong>(queue_id, (void*)&amp;message, sizeof(message.message_text), 0);
&nbsp;
    if (status == -1) {
        perror("Can not send message");
        return 1;
    }
    return 0;
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Připojení k&nbsp;existující frontě a přečtení zprávy funkcí <strong>msgrcv</strong></h2>

<p>Nyní si ukažme, jakým způsobem se můžeme připojit k&nbsp;existující frontě a
přečíst z&nbsp;ní zprávu, popř.&nbsp;počkat na poslání zprávy. Nejdříve je opět
nutné získat klíč (celočíselnou hodnotu), který musí být stejný, jako tomu bylo
v&nbsp;producentovi zpráv. Použijeme tedy shodný soubor i shodnou konstantu
předanou ve druhém parametru funkce <strong>ftok</strong>:</p>

<pre>
key_t key;
&nbsp;
key = <strong>ftok</strong>("/home/tester/.bashrc", 1234);
&nbsp;
if (key == -1) {
    perror("Unable to generate key");
    return 2;
}
&nbsp;
printf("Key: %x\n", key);
</pre>

<p>Dále se pokusíme o otevření fronty, a to opět s&nbsp;využitím funkce
<strong>msgget</strong>. Ovšem zatímco pro vytvoření fronty bylo nutné předat
příznak <strong>IPC_CREAT</strong> a režim přístupu:</p>

<pre>
queue_id = <strong>msgget</strong>(key, IPC_CREAT | 0660);
</pre>

<p>Pro otevření již existující fronty můžeme ve druhém parametry předat nulu
(počítá se tedy, že fronta existuje):</p>

<pre>
queue_id = <strong>msgget</strong>(key, 0);
&nbsp;
if (queue_id == -1) {
    perror("Unable to get message queue identifier");
    return 2;
}
</pre>

<p>Zpráva se přečte funkcí <strong>msgrcv</strong>:</p>

<pre>
status = <strong>msgrcv</strong>(queue_id, (void*)&amp;message, sizeof(message.message_text), 0, 0);
</pre>

<p>Této funkci se opět předává identifikátor fronty (první parametr), ukazatel
na strukturu pro uložení přečtené zprávy (druhý parametr), maximální očekávaná
délka zprávy (třetí parametr), typ zprávy (čtvrtý parametr) a případné další
příznaky ovlivňující příjem zprávy. Povšimněte si, že typ zprávy jsme nastavili
na nulu. Tato speciální hodnota říká, že se má přečíst první zpráva
z&nbsp;fronty, bez ohledu na její skutečný typ. V&nbsp;případě, že by byl typ
kladným číslem, přečetla by se první zpráva s&nbsp;tímto nastaveným typem
(pokud existuje). Pokud by se naopak jednalo o číslo záporné, přečetla by se
první zpráva s&nbsp;typem menším než absolutní hodnota tohoto čísla. Díky tomu
lze tento parametr použít pro filtraci zpráv, což si ukážeme v&nbsp;dalších
demonstračních příkladech. V&nbsp;posledním parametru lze příznakovými bity
určit, zda se má čekat na zprávu (výchozí chování odpovídající klasické
frontě), popř.&nbsp;jaká operace se má vykonat ve chvíli, kdy je přijatá zpráva
delší než nastavený limit.</p>

<p>Implementace konzumenta (příjemce) jediné zprávy může vypadat
následovně:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
&nbsp;
#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/msg.h&gt;
&nbsp;
typedef struct {
    long message_type;
    char message_text[100];
} t_message;
&nbsp;
int main(void)
{
    t_message message;
    key_t key;
    int queue_id;
    int status;
&nbsp;
    key = <strong>ftok</strong>("/home/tester/.bashrc", 1234);
&nbsp;
    if (key == -1) {
        perror("Unable to generate key");
        return 2;
    }
&nbsp;
    printf("Key: %x\n", key);
&nbsp;
    queue_id = <strong>msgget</strong>(key, 0);
&nbsp;
    if (queue_id == -1) {
        perror("Unable to get message queue identifier");
        return 2;
    }
&nbsp;
    printf("Message queue identifier: %x\n", queue_id);
&nbsp;
    status = <strong>msgrcv</strong>(queue_id, (void*)&amp;message, sizeof(message.message_text), 0, 0);
&nbsp;
    if (status == -1) {
        perror("Can not receive message");
        return 1;
    }
&nbsp;
    printf("Message type: %ld\n", message.message_type);
    printf("Message text: %s\n", message.message_text);
    return 0;
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Spuštění producenta i konzumenta zprávy</h2>

<p>Jak producenta zprávy, tak i jejího konzumenta přeložíme běžným způsobem.
Můžeme použít následující soubor <strong>Makefile</strong>, který je značně
zjednodušen, protože nepotřebujeme linkovat žádné další knihovny (příště už
bude situace nepatrně komplikovanější, protože budeme linkovat knihovnu
<strong>rt</strong>):</p>

<pre>
CC=gcc
LINKER=gcc
&nbsp;
CFLAGS=-O0 -Wall -pedantic
LFLAGS=
&nbsp;
.PHONY: clean
&nbsp;
all:    publisher subscriber
&nbsp;
%.o:    %.c
        $(CC) -c -o $@ $(CFLAGS) $&lt;
&nbsp;
publisher:      publisher.o
        $(CC) -o $@ $&lt; $(LFLAGS)
&nbsp;
subscriber:     subscriber.o
        $(CC) -o $@ $&lt; $(LFLAGS)
&nbsp;
clean:
        rm -f *.o \
        rm -f publisher \
        rm -f subscriber
</pre>

<p>Překlad a slinkování producenta i konzumenta:</p>

<pre>
$ <strong>make</strong>
&nbsp;
gcc -c -o publisher.o -O0 -Wall -pedantic publisher.c
gcc -o publisher publisher.o 
gcc -c -o subscriber.o -O0 -Wall -pedantic subscriber.c
gcc -o subscriber subscriber.o 
</pre>

<p>Nejprve spustíme producenta zprávy. Ten by měl vypsat klíč, který získal a
taktéž identifikátor nově vytvořené fronty:</p>

<pre>
$ <strong>./publisher </strong>
&nbsp;
Key: d2010dbb
Message queue identifier: 8000
</pre>

<p>A následně spustíme konzumenta. Ten opět vypíše klíč (musí být shodný
s&nbsp;klíčem předchozím), identifikátor fronty a konečně zprávu, kterou
z&nbsp;fronty přečetl:</p>

<pre>
$ <strong>./subscriber </strong>
&nbsp;
Key: d2010dbb
Message queue identifier: 8000
Message type: 1
Message text: Hello world!
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Prozkoumání stavu fronty příkazem <strong>ipcs</strong></h2>

<p>Můžeme si pochopitelně vyzkoušet, jakým způsobem ovlivnilo spuštění
producenta a konzumenta stav front, jenž dokážeme získat příkazem
<strong>ipcs</strong>.</p>

<p>Ještě před prvním spuštění producenta by žádná fronta neměla existovat, což
jsme si již ověřili v&nbsp;úvodních kapitolách:</p>

<pre>
$ <strong>ipcs -q</strong>
&nbsp;
------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages
</pre>

<p>Po spuštění producenta by se měla fronta vytvořit a současně by se do ní
měla zapsat zpráva o délce 100 bajtů:</p>

<pre>
$ <strong>ipcs -q</strong>
&nbsp;
------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages
0xd2010dbb 32768      tester     660        100          1
</pre>

<p><div class="rs-tip-major">Poznámka: nenechte se zmást tím, že ID fronty je
(nebo může být) nastaveno na hodnotu 32768, zatímco demonstrační příklady
s&nbsp;producentem i konzumentem ukazovaly hodnotu 8000. V&nbsp;prvním případě
se jedná o dekadické číslo, ve druhém o hexadecimální hodnotu.</div></p>

<p>Prozkoumat můžeme i konkrétní frontu, resp.&nbsp;přesněji řečeno frontu se
zadaným ID, v&nbsp;našem případě ID=32768:</p>

<pre>
$ <strong>ipcs -q -i 32768</strong>
&nbsp;
Message Queue msqid=32768
uid=1000        gid=1000        cuid=1000       cgid=1000       mode=0660
cbytes=100      qbytes=16384    qnum=1  lspid=15028     lrpid=15002
send_time=Sat Nov 16 21:58:51 2019  
rcv_time=Sat Nov 16 21:57:09 2019  
change_time=Sat Nov 16 21:56:02 2019  
</pre>

<p>Po spuštění konzumenta, který zprávu přečte, se pochopitelně změní i stav
fronty, což si můžeme velmi snadno ověřit:</p>

<pre>
$ <strong>ipcs -q </strong>
&nbsp;
------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages
0xd2010dbb 32768      tester     660        0            0
&nbsp;
&nbsp;
&nbsp;
$ <strong>ipcs -q -i 32768</strong>
&nbsp;
Message Queue msqid=32768
uid=1000        gid=1000        cuid=1000       cgid=1000       mode=0660
cbytes=0        qbytes=16384    qnum=0  lspid=15028     lrpid=15077
send_time=Sat Nov 16 21:58:51 2019  
rcv_time=Sat Nov 16 22:04:42 2019  
change_time=Sat Nov 16 21:56:02 2019  
</pre>

<p>Vidíme, že fronta sice stále existuje, ovšem neobsahuje žádné zprávy a její
zaplněná kapacita je tedy nula bajtů.</p>

<p><div class="rs-tip-major">Poznámka: na některých systémem má první vytvořená
fronta ID=0, takže příkazy budou nepatrně odlišné:</div></p>

<pre>
$ <strong>ipcs -q</strong>
&nbsp;
------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages
0xd200017f 0          ptisnovs   660        200          2
</pre>

<p>Informace o frontě číslo 0:</p>

<pre>
$ <strong>ipcs -q -i 0</strong>
&nbsp;
Message Queue msqid=0
uid=1000        gid=1000        cuid=1000       cgid=1000       mode=0660
cbytes=100      qbytes=16384    qnum=1  lspid=5043      lrpid=0
send_time=Fri Nov 15 16:01:24 2019
rcv_time=Not set
change_time=Fri Nov 15 15:44:27 2019
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Producent posílající více zpráv</h2>

<p>Nepatrnou úpravou producenta můžeme zajistit, aby se zprávy vytvářely
nepřetržitě s&nbsp;intervalem přibližně jedné sekundy. Každá zpráva bude
obsahovat odlišnou zprávu obsahující mj.&nbsp;i hodnotu počitadla:</p>

<pre>
while (1) {
    sprintf(message.message_text, "Message #%d", msg_number);
    msg_number++;
    status = <strong>msgsnd</strong>(queue_id, (void*)&amp;message, sizeof(message.message_text), 0);
&nbsp;
    if (status == -1) {
        perror("Can not send message");
        return 1;
    }
    sleep(1);
}
</pre>

<p><div class="rs-tip-major">Poznámka: nesmíme zapomenout na načtení
hlavičkového souboru <strong>unistd.h</strong> s&nbsp;deklarací funkce
<strong>sleep()</strong>.</div></p>

<p>Úplný zdrojový kód takto upraveného producenta zpráv může vypadat
následovně:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
&nbsp;
#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/msg.h&gt;
&nbsp;
typedef struct {
    long message_type;
    char message_text[100];
} t_message;
&nbsp;
int main(void)
{
    t_message message;
    key_t key;
    int queue_id;
    int status;
    int msg_number = 1;
&nbsp;
    message.message_type = 1;
&nbsp;
    key = <strong>ftok</strong>("/home/tester/.bashrc", 1234);
&nbsp;
    if (key == -1) {
        perror("Unable to generate key");
        return 2;
    }
&nbsp;
    printf("Key: %x\n", key);
&nbsp;
    queue_id = <strong>msgget</strong>(key, IPC_CREAT | 0660);
&nbsp;
    if (queue_id == -1) {
        perror("Unable to get message queue identifier");
        return 2;
    }
&nbsp;
    printf("Message queue identifier: %x\n", queue_id);
&nbsp;
    while (1) {
        sprintf(message.message_text, "Message #%d", msg_number);
        msg_number++;
        status = <strong>msgsnd</strong>(queue_id, (void*)&amp;message, sizeof(message.message_text), 0);
&nbsp;
        if (status == -1) {
            perror("Can not send message");
            return 1;
        }
        sleep(1);
    }
&nbsp;
    return 0;
}
</pre>

<p>Producenta spustíme po dobu přibližně jedné minuty a poté zkontrolujeme stav
fronty. Měla by obsahovat přibližně šedesát zpráv a zaplněná kapacita by měla
být přesně 100*počet_zpráv:</p>

<pre>
$ <strong>ipcs -q</strong>
&nbsp;
------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages
0xd2010dbb 32768      tester     660        6600         66
&nbsp;
&nbsp;
&nbsp;
$ <strong>ipcs -q -i 32768</strong>
&nbsp;
Message Queue msqid=32768
uid=1000        gid=1000        cuid=1000       cgid=1000       mode=0660
cbytes=6600     qbytes=16384    qnum=66 lspid=15115     lrpid=15077
send_time=Sat Nov 16 22:11:09 2019
rcv_time=Sat Nov 16 22:04:42 2019
change_time=Sat Nov 16 21:56:02 2019
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Konzument akceptující postupně všechny zprávy</h2>

<p>Podobným způsobem můžeme upravit i konzumenta zpráv, který ovšem bude
přijímat všechny zprávy bez zbytečné jednosekundové pauzy:</p>

<pre>
while (1) {
    status = <strong>msgrcv</strong>(queue_id, (void*)&amp;message, sizeof(message.message_text), 0, 0);
&nbsp;
    if (status == -1) {
        perror("Can not receive message");
        return 1;
    }
&nbsp;
    printf("Message type: %ld\n", message.message_type);
    printf("Message text: %s\n", message.message_text);
}
</pre>

<p>Úplný zdrojový kód upraveného konzumenta zpráv:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
&nbsp;
#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/msg.h&gt;
&nbsp;
typedef struct {
    long message_type;
    char message_text[100];
} t_message;
&nbsp;
int main(void)
{
    t_message message;
    key_t key;
    int queue_id;
    int status;
&nbsp;
    key = <strong>ftok</strong>("/home/tester/.bashrc", 1234);
&nbsp;
    if (key == -1) {
        perror("Unable to generate key");
        return 2;
    }
&nbsp;
    printf("Key: %x\n", key);
&nbsp;
    queue_id = <strong>msgget</strong>(key, 0);
&nbsp;
    if (queue_id == -1) {
        perror("Unable to get message queue identifier");
        return 2;
    }
&nbsp;
    printf("Message queue identifier: %x\n", queue_id);
&nbsp;
    while (1) {
        status = <strong>msgrcv</strong>(queue_id, (void*)&amp;message, sizeof(message.message_text), 0, 0);
&nbsp;
        if (status == -1) {
            perror("Can not receive message");
            return 1;
        }
&nbsp;
        printf("Message type: %ld\n", message.message_type);
        printf("Message text: %s\n", message.message_text);
    }
    return 0;
}
</pre>

<p>Po překladu a spuštění konzumenta zpráv by se měly prakticky okamžitě načíst
všechny zprávy, které byly uloženy do fronty:</p>

<pre>
$ <strong>./subscriber</strong>
&nbsp;
tester@tester-ThinkPad-T410 ~/temp/message-queues-examples/unix-messages/system-v/example2 $ ./subscriber
Key: d2010dbb
Message queue identifier: 0
Message type: 1
Message text: Message #1
Message type: 1
Message text: Message #2
Message type: 1
Message text: Message #3
Message type: 1
Message text: Message #4
...
...
...
Message type: 1
Message text: Message #66
...
...
...
konzument čeká na další zprávy
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Chování producenta při zaplnění fronty</h2>

<p>Nyní vyzkoušíme, co se stane ve chvíli, kdy producent zaplní celou kapacitu
fronty (konzument nebude spuštěn). Producenta z&nbsp;předchozích kapitol
nepatrně upravíme takovým způsobem, aby zprávy posílal co nejrychleji, bez
sekundových prodlev:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
&nbsp;
#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/msg.h&gt;
&nbsp;
typedef struct {
    long message_type;
    char message_text[100];
} t_message;
&nbsp;
int main(void)
{
    t_message message;
    key_t key;
    int queue_id;
    int status;
    int msg_number = 1;
&nbsp;
    message.message_type = 1;
&nbsp;
    key = <strong>ftok</strong>("/home/tester/.bashrc", 1234);
&nbsp;
    if (key == -1) {
        perror("Unable to generate key");
        return 2;
    }
&nbsp;
    printf("Key: %x\n", key);
&nbsp;
    queue_id = <strong>msgget</strong>(key, IPC_CREAT | 0660);
&nbsp;
    if (queue_id == -1) {
        perror("Unable to get message queue identifier");
        return 2;
    }
&nbsp;
    printf("Message queue identifier: %x\n", queue_id);
&nbsp;
    while (1) {
        sprintf(message.message_text, "Message #%d", msg_number);
        msg_number++;
        status = <strong>msgsnd</strong>(queue_id, (void*)&amp;message, sizeof(message.message_text), 0);
&nbsp;
        if (status == -1) {
            perror("Can not send message");
            return 1;
        }
    }
&nbsp;
    return 0;
}
</pre>

<p>Producenta přeložíme a následně běžným způsobem spustíme:</p>

<pre>
$ <strong>./publisher</strong>
&nbsp;
Key: d2010dbb
Message queue identifier: 0
</pre>

<p>V&nbsp;této chvíli se producent zastaví, protože došlo k&nbsp;naplnění
fronty. Můžeme se o tom velmi snadno přesvědčit:</p>

<pre>
$ <strong>ipcs -q</strong>
&nbsp;
------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages    
0xd2010dbb 0          tester     660        16300        163         
</pre>

<p>Fronta nyní obsahuje 163 zpráv, každou o délce 100 bajtů, což znamená, že
z&nbsp;kapacity 16384 je obsazeno 16300 bajtů a další zpráva se do zbylých 84
bajtů již nevleze:</p>

<pre>
$ <strong>ipcs -q -i 0</strong>
&nbsp;
Message Queue msqid=0
uid=1000        gid=1000        cuid=1000       cgid=1000       mode=0660
cbytes=16300    qbytes=16384    qnum=163        lspid=4139      lrpid=4118
send_time=Sun Nov 17 16:39:20 2019  
rcv_time=Sun Nov 17 16:38:28 2019  
change_time=Sun Nov 17 16:38:05 2019  
</pre>

<p><div class="rs-tip-major">Poznámka: frontu vyprázdníme snadno &ndash;
ukončením producenta zpráv a spuštěním konzumenta. Producenta vypněte, protože
jinak si začne producent a konzument předávat zprávy maximální možnou
rychlostí, což bude znamenat prakticky stoprocentní využití dvou procesorových
jader (budou často ve stavu Wait, protože se bude komunikovat
s&nbsp;jádrem).</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Poslání zprávy do fronty bez čekání</h2>

<p>Prozatím jsme zprávy do fronty posílali takto:</p>

<pre>
status = <strong>msgsnd</strong>(queue_id, (void*)&amp;message, sizeof(message.message_text), 0);
</pre>

<p>Vzhledem k&nbsp;tomu, že poslední parametr obsahoval nulu, bylo chování
funkce <strong>msgsnd</strong> blokující &ndash; ve chvíli, kdy byla fronta
zaplněna, čekala funkce <strong>msgsnd</strong> tak dlouho, dokud nedošlo
k&nbsp;ukončení procesu, ke smazání fronty či k&nbsp;uvolnění místa ve frontě.
Někdy však můžeme chtít, aby se v&nbsp;případě, že je fronta plná, o této
situaci producent dozvěděl, a to okamžitě. I to je možné &ndash; postačuje
v&nbsp;posledním parametru funkce <strong>msgsnd</strong> předat příznak
<strong>IPC_NOWAIT</strong>:</p>

<pre>
status = <strong>msgsnd</strong>(queue_id, (void*)&amp;message, sizeof(message.message_text), IPC_NOWAIT);
</pre>

<p>V&nbsp;případě, že je fronta plná, vrátí se chyba (-1) a proměnná
<strong>errno</strong> bude obsahovat konstantu <strong>EAGAIN</strong>
(z&nbsp;hlavičkového souboru <strong>errno.h</strong>), kterou můžeme
testovat.</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
&nbsp;
#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/msg.h&gt;
&nbsp;
typedef struct {
    long message_type;
    char message_text[100];
} t_message;
&nbsp;
int main(void)
{
    t_message message;
    key_t key;
    int queue_id;
    int status;
    int msg_number = 1;
&nbsp;
    message.message_type = 1;
&nbsp;
    key = <strong>ftok</strong>("/home/tester/.bashrc", 1234);
&nbsp;
    if (key == -1) {
        perror("Unable to generate key");
        return 2;
    }
&nbsp;
    printf("Key: %x\n", key);
&nbsp;
    queue_id = <strong>msgget</strong>(key, IPC_CREAT | 0660);
&nbsp;
    if (queue_id == -1) {
        perror("Unable to get message queue identifier");
        return 2;
    }
&nbsp;
    printf("Message queue identifier: %x\n", queue_id);
&nbsp;
    while (1) {
        sprintf(message.message_text, "Message #%d", msg_number);
        msg_number++;
        status = <strong>msgsnd</strong>(queue_id, (void*)&amp;message, sizeof(message.message_text), IPC_NOWAIT);
&nbsp;
        if (status == -1) {
            if (errno == EAGAIN) {
                puts("Message queue is full");
            }
            perror("Can not send message");
            return 1;
        }
    }
&nbsp;
    return 0;
}
</pre>

<p>Opět si otestujme chování producenta zpráv:</p>

<pre>
$ <strong>./publisher</strong>
&nbsp;
Key: d2010dbb
Message queue identifier: 0
Message queue is full
Can not send message: Resource temporarily unavailable
</pre>

<p>Vidíme, že v&nbsp;tomto případě byl producent ukončen a správně napsal,
z&nbsp;jakého důvodu.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Přečtení doplňujících informací o frontě funkcí <strong>msgctl</strong></h2>

<pre>
struct msqid_ds buf;
status = msgctl(queue_id, IPC_STAT, &buf);
if (status == -1) {
    perror("Can not read message queue info");
    return 1;
}
printf("Last sent: %s", ctime(&buf.msg_stime));
printf("Last recv: %s", ctime(&buf.msg_rtime));
printf("Last change: %s", ctime(&buf.msg_ctime));
printf("Messages in queue: %ld\n", buf.msg_qnum);
printf("PID of last sender: %d\n", buf.msg_lspid);
printf("PID of last receiver: %d\n", buf.msg_lrpid);
printf("PID of this process: %d\n\n", getpid());
</pre>

<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;time.h&gt;

#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/msg.h&gt;

typedef struct {
    long message_type;
    char message_text[100];
} t_message;

int main(void)
{
    t_message message;
    key_t key;
    int queue_id;
    int status;
    int msg_number = 1;

    message.message_type = 1;

    key = ftok("/home/tester/.bashrc", 1234);

    if (key == -1) {
        perror("Unable to generate key");
        return 2;
    }

    printf("Key: %x\n", key);

    queue_id = msgget(key, IPC_CREAT | 0660);

    if (queue_id == -1) {
        perror("Unable to get message queue identifier");
        return 2;
    }

    printf("Message queue identifier: %x\n", queue_id);

    while (1) {
        sprintf(message.message_text, "Message #%d", msg_number);
        msg_number++;
        status = msgsnd(queue_id, (void*)&message, sizeof(message.message_text), 0);

        if (status == -1) {
            perror("Can not send message");
            return 1;
        }

        {
            struct msqid_ds buf;
            status = msgctl(queue_id, IPC_STAT, &buf);
            if (status == -1) {
                perror("Can not read message queue info");
                return 1;
            }
            printf("Last sent: %s", ctime(&buf.msg_stime));
            printf("Last recv: %s", ctime(&buf.msg_rtime));
            printf("Last change: %s", ctime(&buf.msg_ctime));
            printf("Messages in queue: %ld\n", buf.msg_qnum);
            printf("PID of last sender: %d\n", buf.msg_lspid);
            printf("PID of last receiver: %d\n", buf.msg_lrpid);
            printf("PID of this process: %d\n\n", getpid());
        }
        sleep(1);
    }

    return 0;
}
</pre>




Key: d200017f
Message queue identifier: 0
Message type: 1
Message text: Hello world!

Last sent: Fri Nov 15 20:34:12 2019
Last recv: Fri Nov 15 20:22:14 2019
Last change: Fri Nov 15 19:57:25 2019
Messages in queue: 24
PID of last sender: 4590
PID of last receiver: 4168
PID of this process: 4590



<p><a name="k15"></a></p>
<h2 id="k15">15. Možné konfigurace: více producentů a jeden konzument, jeden konzument a více producentů atd.</h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. Filtrace zpráv podle nastaveného typu</h2>

<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;time.h&gt;

#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/msg.h&gt;

typedef struct {
    long message_type;
    char message_text[100];
} t_message;

int main(int argc, char **argv)
{
    t_message message;
    key_t key;
    int queue_id;
    int status;
    int msg_number = 1;

    if (argc &lt; 1) {
        puts("Usage: ./producer message_type");
        return 1;
    }

    message.message_type = atoi(argv[1]);

    key = ftok("/home/tester/.bashrc", 5678);

    if (key == -1) {
        perror("Unable to generate key");
        return 2;
    }

    printf("Key: %x\n", key);

    queue_id = msgget(key, IPC_CREAT | 0660);

    if (queue_id == -1) {
        perror("Unable to get message queue identifier");
        return 2;
    }

    printf("Message queue identifier: %x\n", queue_id);

    while (1) {
        sprintf(message.message_text, "Message #%d", msg_number);
        msg_number++;
        status = msgsnd(queue_id, (void*)&message, sizeof(message.message_text), 0);

        if (status == -1) {
            perror("Can not send message");
            return 1;
        }

        {
            struct msqid_ds buf;
            status = msgctl(queue_id, IPC_STAT, &buf);
            if (status == -1) {
                perror("Can not read message queue info");
                return 1;
            }
            printf("Last sent: %s", ctime(&buf.msg_stime));
            printf("Last recv: %s", ctime(&buf.msg_rtime));
            printf("Last change: %s", ctime(&buf.msg_ctime));
            printf("Messages in queue: %ld\n", buf.msg_qnum);
            printf("PID of last sender: %d\n", buf.msg_lspid);
            printf("PID of last receiver: %d\n", buf.msg_lrpid);
            printf("PID of this process: %d\n\n", getpid());
        }
        sleep(1);
    }

    return 0;
}
</pre>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/msg.h&gt;

typedef struct {
    long message_type;
    char message_text[100];
} t_message;

int main(int argc, char **argv)
{
    t_message message;
    key_t key;
    int queue_id;
    int status;
    long message_type;

    if (argc &lt; 1) {
        puts("Usage: ./subscriber message_type");
        return 1;
    }

    message_type = atoi(argv[1]);

    key = ftok("/home/tester/.bashrc", 5678);

    if (key == -1) {
        perror("Unable to generate key");
        return 2;
    }

    printf("Key: %x\n", key);

    queue_id = msgget(key, 0);

    if (queue_id == -1) {
        perror("Unable to get message queue identifier");
        return 2;
    }

    printf("Message queue identifier: %x\n", queue_id);

    while (1) {
        status = msgrcv(queue_id, (void*)&message, sizeof(message.message_text), message_type, 0);

        if (status == -1) {
            perror("Can not receive message");
            return 1;
        }

        printf("Message type: %ld\n", message.message_type);
        printf("Message text: %s\n", message.message_text);
    }
    return 0;
}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů vyvinutých
v&nbsp;programovacím jazyku Go byly uloženy do Git repositáře, který je
dostupný na adrese <a
href="https://github.com/tisnik/message-queues-examples">https://github.com/tisnik/message-queues-examples</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
stále ještě doslova několik kilobajtů), můžete namísto toho použít odkazy na
jednotlivé příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th>Příklad</th><th>Skript</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>publisher.c</td><td>vytvoření fronty a poslání jedné zprávy</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example1/publisher.c">https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example1/publisher.c</a></td></tr>
<tr><td> 2</td><td>subscriber.c</td><td>příjem jedné zprávy z&nbsp;fronty</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example1/subscriber.c">https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example1/subscriber.c</a></td></tr>
<tr><td> 3</td><td>Makefile</td><td>Makefile pro překlad obou příkladů</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example1/Makefile">https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example1/Makefile</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 4</td><td>publisher.c</td><td>vytvoření fronty a posílání zpráv s&nbsp;frekvencí 1 zpráva za sekundu</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example2/publisher.c">https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example2/publisher.c</a></td></tr>
<tr><td> 5</td><td>subscriber.c</td><td>kontinuální příjem zpráv získávaných z&nbsp;fronty</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example2/subscriber.c">https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example2/subscriber.c</a></td></tr>
<tr><td> 6</td><td>Makefile</td><td>Makefile pro překlad obou příkladů</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example2/Makefile">https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example2/Makefile</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>publisher.c</td><td>posílání zpráv kontinuálně (bez přestávky)</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example3/publisher.c">https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example3/publisher.c</a></td></tr>
<tr><td> 8</td><td>subscriber.c</td><td>stejná funkce, jako v&nbsp;předchozím příkladu</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example3/subscriber.c">https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example3/subscriber.c</a></td></tr>
<tr><td> 9</td><td>Makefile</td><td>Makefile pro překlad obou příkladů</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example3/Makefile">https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example3/Makefile</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>publisher.c</td><td>posílání zpráv s&nbsp;detekcí zaplnění fronty</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example4/publisher.c">https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example4/publisher.c</a></td></tr>
<tr><td>11</td><td>subscriber.c</td><td>stejná funkce, jako v&nbsp;předchozím příkladu</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example4/subscriber.c">https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example4/subscriber.c</a></td></tr>
<tr><td>12</td><td>Makefile</td><td>Makefile pro překlad obou příkladů</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example4/Makefile">https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example4/Makefile</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>publisher.c</td><td>posílání zpráv a průběžné informace o stavu fronty</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example5/publisher.c">https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example5/publisher.c</a></td></tr>
<tr><td>14</td><td>subscriber.c</td><td>stejná funkce, jako v&nbsp;předchozím příkladu</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example5/subscriber.c">https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example5/subscriber.c</a></td></tr>
<tr><td>15</td><td>Makefile</td><td>Makefile pro překlad obou příkladů</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example5/Makefile">https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example5/Makefile</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>publisher.c</td><td>posílání zpráv s&nbsp;možností změny jejich typu</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example6/publisher.c">https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example6/publisher.c</a></td></tr>
<tr><td>17</td><td>subscriber.c</td><td>kontinuální příjem zpráv získávaných z&nbsp;fronty s&nbsp;jejich filtrací podle typu</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example6/subscriber.c">https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example6/subscriber.c</a></td></tr>
<tr><td>18</td><td>Makefile</td><td>Makefile pro překlad obou příkladů</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example6/Makefile">https://github.com/tisnik/message-queues-examples/blob/master/unix-messages/system-v/example6/Makefile</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>POSIX message queues in Linux<br />
<a href="https://www.softprayog.in/programming/interprocess-communication-using-posix-message-queues-in-linux">https://www.softprayog.in/programming/interprocess-communication-using-posix-message-queues-in-linux</a>
</li>

<li>How is a message queue implemented in the Linux kernel?<br />
<a href="https://unix.stackexchange.com/questions/6930/how-is-a-message-queue-implemented-in-the-linux-kernel/6935">https://unix.stackexchange.com/questions/6930/how-is-a-message-queue-implemented-in-the-linux-kernel/6935</a>
</li>

<li>‘IPCS’ command in Linux with examples<br />
<a href="https://www.geeksforgeeks.org/ipcs-command-linux-examples/">https://www.geeksforgeeks.org/ipcs-command-linux-examples/</a>
</li>

<li>System V IPC: Message Queues<br />
<a href="https://nitish712.blogspot.com/2012/11/system-v-ipc-message-queues.html">https://nitish712.blogspot.com/2012/11/system-v-ipc-message-queues.html</a>
</li>

<li>How to create, check and delete IPC share memory, semaphare and message queue on linux <br />
<a href="https://fibrevillage.com/sysadmin/225-how-to-create-check-and-delete-ipc-share-memory-semaphare-and-message-queue-on-linux">https://fibrevillage.com/sysadmin/225-how-to-create-check-and-delete-ipc-share-memory-semaphare-and-message-queue-on-linux</a>
</li>

<li>MQ_OVERVIEW(7): Linux Programmer's Manual<br />
<a href="http://man7.org/linux/man-pages/man7/mq_overview.7.html">http://man7.org/linux/man-pages/man7/mq_overview.7.html</a>
</li>

<li>mq_overview (7) - Linux Man Pages<br />
<a href="https://www.systutorials.com/docs/linux/man/7-mq_overview/">https://www.systutorials.com/docs/linux/man/7-mq_overview/</a>
</li>

<li>POSIX.4 Message Queues (+ rozšíření QNX)<br />
<a href="https://users.pja.edu.pl/~jms/qnx/help/watcom/clibref/mq_overview.html">https://users.pja.edu.pl/~jms/qnx/help/watcom/clibref/mq_overview.html</a>
</li>

<li>System V message queues in Linux<br />
<a href="https://www.softprayog.in/programming/interprocess-communication-using-system-v-message-queues-in-linux">https://www.softprayog.in/programming/interprocess-communication-using-system-v-message-queues-in-linux</a>
</li>

<li>Linux System V and POSIX IPC Examples<br />
<a href="http://hildstrom.com/projects/ipc_sysv_posix/index.html">http://hildstrom.com/projects/ipc_sysv_posix/index.html</a>
</li>

<li>Programming Tutorial - Linux: Message Queues<br />
<a href="https://ccppcoding.blogspot.com/2013/03/linux-message-queues.html">https://ccppcoding.blogspot.com/2013/03/linux-message-queues.html</a>
</li>

<li>Go wrapper for POSIX Message Queues <br />
<a href="https://github.com/syucream/posix_mq">https://github.com/syucream/posix_mq</a>
</li>

<li>Stránka projektu NSQ<br />
<a href="https://nsq.io/">https://nsq.io/</a>
</li>

<li>Dokumentace k&nbsp;projektu NSQ<br />
<a href="https://nsq.io/overview/design.html">https://nsq.io/overview/design.html</a>
</li>

<li>Dokumentace ke klientovi pro Go<br />
<a href="https://godoc.org/github.com/nsqio/go-nsq">https://godoc.org/github.com/nsqio/go-nsq</a>
</li>

<li>Dokumentace ke klientovi pro Python<br />
<a href="https://pynsq.readthedocs.io/en/latest/">https://pynsq.readthedocs.io/en/latest/</a>
</li>

<li>Binární tarbally s&nbsp;NSQ<br />
<a href="https://nsq.io/deployment/installing.html">https://nsq.io/deployment/installing.html</a>
</li>

<li>GitHub repositář projektu NSQ<br />
<a href="https://github.com/nsqio/nsq">https://github.com/nsqio/nsq</a>
</li>

<li>Klienti pro NSQ<br />
<a href="https://nsq.io/clients/client_libraries.html">https://nsq.io/clients/client_libraries.html</a>
</li>

<li>Klient pro Go<br />
<a href="https://github.com/nsqio/go-nsq">https://github.com/nsqio/go-nsq</a>
</li>

<li>Klient pro Python<br />
<a href="https://github.com/nsqio/pynsq">https://github.com/nsqio/pynsq</a>
</li>

<li>An Example of Using NSQ From Go<br />
<a href="http://tleyden.github.io/blog/2014/11/12/an-example-of-using-nsq-from-go/">http://tleyden.github.io/blog/2014/11/12/an-example-of-using-nsq-from-go/</a>
</li>

<li>Go Go Gadget<br />
<a href="https://word.bitly.com/post/29550171827/go-go-gadget">https://word.bitly.com/post/29550171827/go-go-gadget</a>
</li>

<li>Simplehttp<br />
<a href="https://github.com/bitly/simplehttp">https://github.com/bitly/simplehttp</a>
</li>

<li>Dramatiq: simple task processing<br />
<a href="https://dramatiq.io/">https://dramatiq.io/</a>
</li>

<li>Cookbook (for Dramatiq)<br />
<a href="https://dramatiq.io/cookbook.html">https://dramatiq.io/cookbook.html</a>
</li>

<li>Balíček dramatiq na PyPi<br />
<a href="https://pypi.org/project/dramatiq/">https://pypi.org/project/dramatiq/</a>
</li>

<li>Dramatiq dashboard<br />
<a href="https://github.com/Bogdanp/dramatiq_dashboard">https://github.com/Bogdanp/dramatiq_dashboard</a>
</li>

<li>Dramatiq na Redditu<br />
<a href="https://www.reddit.com/r/dramatiq/">https://www.reddit.com/r/dramatiq/</a>
</li>

<li>A Dramatiq broker that can be used with Amazon SQS<br />
<a href="https://github.com/Bogdanp/dramatiq_sqs">https://github.com/Bogdanp/dramatiq_sqs</a>
</li>

<li>nanomsg na GitHubu<br />
<a href="https://github.com/nanomsg/nanomsg">https://github.com/nanomsg/nanomsg</a>
</li>

<li>Referenční příručka knihovny <strong>nanomsg</strong><br />
<a href="https://nanomsg.org/v1.1.5/nanomsg.html">https://nanomsg.org/v1.1.5/nanomsg.html</a>
</li>

<li>nng (nanomsg-next-generation)<br />
<a href="https://github.com/nanomsg/nng">https://github.com/nanomsg/nng</a>
</li>

<li>Differences between nanomsg and ZeroMQ<br />
<a href="https://nanomsg.org/documentation-zeromq.html">https://nanomsg.org/documentation-zeromq.html</a>
</li>

<li>NATS<br />
<a href="https://nats.io/about/">https://nats.io/about/</a>
</li>

<li>NATS Streaming Concepts<br />
<a href="https://nats.io/documentation/streaming/nats-streaming-intro/">https://nats.io/documentation/streaming/nats-streaming-intro/</a>
</li>

<li>NATS Streaming Server<br />
<a href="https://nats.io/download/nats-io/nats-streaming-server/">https://nats.io/download/nats-io/nats-streaming-server/</a>
</li>

<li>NATS Introduction<br />
<a href="https://nats.io/documentation/">https://nats.io/documentation/</a>
</li>

<li>NATS Client Protocol<br />
<a href="https://nats.io/documentation/internals/nats-protocol/">https://nats.io/documentation/internals/nats-protocol/</a>
</li>

<li>NATS Messaging (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/NATS_Messaging">https://en.wikipedia.org/wiki/NATS_Messaging</a>
</li>

<li>Stránka Apache Software Foundation<br />
<a href="http://www.apache.org/">http://www.apache.org/</a>
</li>

<li>Informace o portu 5672<br />
<a href="http://www.tcp-udp-ports.com/port-5672.htm">http://www.tcp-udp-ports.com/port-5672.htm</a>
</li>

<li>Třída MessagingHandler knihovny Qpid Proton<br />
<a href="https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._handlers.MessagingHandler-class.html">https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._handlers.MessagingHandler-class.html</a>
</li>

<li>Třída Event knihovny Qpid Proton<br />
<a href="https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._events.Event-class.html">https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._events.Event-class.html</a>
</li>

<li>package stomp (Go)<br />
<a href="https://godoc.org/github.com/go-stomp/stomp">https://godoc.org/github.com/go-stomp/stomp</a>
</li>

<li>Go language library for STOMP protocol<br />
<a href="https://github.com/go-stomp/stomp">https://github.com/go-stomp/stomp</a>
</li>

<li>python-qpid-proton 0.26.0 na PyPi<br />
<a href="https://pypi.org/project/python-qpid-proton/">https://pypi.org/project/python-qpid-proton/</a>
</li>

<li>Qpid Proton<br />
<a href="http://qpid.apache.org/proton/">http://qpid.apache.org/proton/</a>
</li>

<li>Using the AMQ Python Client<br />
<a href="https://access.redhat.com/documentation/en-us/red_hat_amq/7.1/html-single/using_the_amq_python_client/">https://access.redhat.com/documentation/en-us/red_hat_amq/7.1/html-single/using_the_amq_python_client/</a>
</li>

<li>Apache ActiveMQ<br />
<a href="http://activemq.apache.org/">http://activemq.apache.org/</a>
</li>

<li>Apache ActiveMQ Artemis<br />
<a href="https://activemq.apache.org/artemis/">https://activemq.apache.org/artemis/</a>
</li>

<li>Apache ActiveMQ Artemis User Manual<br />
<a href="https://activemq.apache.org/artemis/docs/latest/index.html">https://activemq.apache.org/artemis/docs/latest/index.html</a>
</li>

<li>KahaDB<br />
<a href="http://activemq.apache.org/kahadb.html">http://activemq.apache.org/kahadb.html</a>
</li>

<li>Understanding the KahaDB Message Store<br />
<a href="https://access.redhat.com/documentation/en-US/Fuse_MQ_Enterprise/7.1/html/Configuring_Broker_Persistence/files/KahaDBOverview.html">https://access.redhat.com/documentation/en-US/Fuse_MQ_Enterprise/7.1/html/Configuring_Broker_Persistence/files/KahaDBOverview.html</a>
</li>

<li>Command Line Tools (Apache ActiveMQ)<br />
<a href="https://activemq.apache.org/activemq-command-line-tools-reference.html">https://activemq.apache.org/activemq-command-line-tools-reference.html</a>
</li>

<li>stomp.py 4.1.21 na PyPi<br />
<a href="https://pypi.org/project/stomp.py/">https://pypi.org/project/stomp.py/</a>
</li>

<li>Stomp Tutorial<br />
<a href="https://access.redhat.com/documentation/en-US/Fuse_Message_Broker/5.5/html/Connectivity_Guide/files/FMBConnectivityStompTelnet.html">https://access.redhat.com/documentation/en-US/Fuse_Message_Broker/5.5/html/Connectivity_Guide/files/FMBConnectivityStompTelnet.html</a>
</li>

<li>Heartbeat (computing)<br />
<a href="https://en.wikipedia.org/wiki/Heartbeat_(computing)">https://en.wikipedia.org/wiki/Heartbeat_(computing)</a>
</li>

<li>Apache Camel<br />
<a href="https://camel.apache.org/">https://camel.apache.org/</a>
</li>

<li>Red Hat Fuse<br />
<a href="https://developers.redhat.com/products/fuse/overview/">https://developers.redhat.com/products/fuse/overview/</a>
</li>

<li>Confusion between ActiveMQ and ActiveMQ-Artemis?<br />
<a href="https://serverfault.com/questions/873533/confusion-between-activemq-and-activemq-artemis">https://serverfault.com/questions/873533/confusion-between-activemq-and-activemq-artemis</a>
</li>

<li>Staré stránky projektu HornetQ<br />
<a href="http://hornetq.jboss.org/">http://hornetq.jboss.org/</a>
</li>

<li>Snapshot JeroMQ verze 0.4.4<br />
<a href="https://oss.sonatype.org/content/repositories/snapshots/org/zeromq/jeromq/0.4.4-SNAPSHOT/">https://oss.sonatype.org/content/repositories/snapshots/org/zeromq/jeromq/0.4.4-SNAPSHOT/</a>
</li>

<li>Difference between ActiveMQ vs Apache ActiveMQ Artemis<br />
<a href="http://activemq.2283324.n4.nabble.com/Difference-between-ActiveMQ-vs-Apache-ActiveMQ-Artemis-td4703828.html">http://activemq.2283324.n4.nabble.com/Difference-between-ActiveMQ-vs-Apache-ActiveMQ-Artemis-td4703828.html</a>
</li>

<li>Microservices communications. Why you should switch to message queues<br />
<a href="https://dev.to/matteojoliveau/microservices-communications-why-you-should-switch-to-message-queues--48ia">https://dev.to/matteojoliveau/microservices-communications-why-you-should-switch-to-message-queues--48ia</a>
</li>

<li>Stomp.py 4.1.19 documentation<br />
<a href="https://stomppy.readthedocs.io/en/stable/">https://stomppy.readthedocs.io/en/stable/</a>
</li>

<li>Repositář knihovny JeroMQ<br />
<a href="https://github.com/zeromq/jeromq/">https://github.com/zeromq/jeromq/</a>
</li>

<li>ØMQ &ndash; Distributed Messaging <br />
<a href="http://zeromq.org/">http://zeromq.org/</a>
</li>

<li>ØMQ Community<br />
<a href="http://zeromq.org/community">http://zeromq.org/community</a>
</li>

<li>Get The Software<br />
<a href="http://zeromq.org/intro:get-the-software">http://zeromq.org/intro:get-the-software</a>
</li>

<li>PyZMQ Documentation<br />
<a href="https://pyzmq.readthedocs.io/en/latest/">https://pyzmq.readthedocs.io/en/latest/</a>
</li>

<li>Module: zmq.decorators<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.decorators.html">https://pyzmq.readthedocs.io/en/latest/api/zmq.decorators.html</a>
</li>

<li>ZeroMQ is the answer, by Ian Barber<br />
<a href="https://vimeo.com/20605470">https://vimeo.com/20605470</a>
</li>

<li>ZeroMQ RFC<br />
<a href="https://rfc.zeromq.org/">https://rfc.zeromq.org/</a>
</li>

<li>ZeroMQ and Clojure, a brief introduction<br />
<a href="https://antoniogarrote.wordpress.com/2010/09/08/zeromq-and-clojure-a-brief-introduction/">https://antoniogarrote.wordpress.com/2010/09/08/zeromq-and-clojure-a-brief-introduction/</a>
</li>

<li>zeromq/czmq<br />
<a href="https://github.com/zeromq/czmq">https://github.com/zeromq/czmq</a>
</li>

<li>golang wrapper for CZMQ<br />
<a href="https://github.com/zeromq/goczmq">https://github.com/zeromq/goczmq</a>
</li>

<li>ZeroMQ version reporting in Python<br />
<a href="http://zguide.zeromq.org/py:version">http://zguide.zeromq.org/py:version</a>
</li>

<li>A Go interface to ZeroMQ version 4<br />
<a href="https://github.com/pebbe/zmq4">https://github.com/pebbe/zmq4</a>
</li>

<li>Broker vs. Brokerless<br />
<a href="http://zeromq.org/whitepapers:brokerless">http://zeromq.org/whitepapers:brokerless</a>
</li>

<li>Learning ØMQ with pyzmq<br />
<a href="https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/">https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/</a>
</li>

<li>Céčková funkce <strong>zmq_ctx_new</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-ctx-new">http://api.zeromq.org/4-2:zmq-ctx-new</a>
</li>

<li>Céčková funkce <strong>zmq_ctx_destroy</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-ctx-destroy">http://api.zeromq.org/4-2:zmq-ctx-destroy</a>
</li>

<li>Céčková funkce <strong>zmq_bind</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-bind">http://api.zeromq.org/4-2:zmq-bind</a>
</li>

<li>Céčková funkce <strong>zmq_unbind</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-unbind">http://api.zeromq.org/4-2:zmq-unbind</a>
</li>

<li>Céčková C funkce <strong>zmq_connect</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-connect">http://api.zeromq.org/4-2:zmq-connect</a>
</li>

<li>Céčková C funkce <strong>zmq_disconnect</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-disconnect">http://api.zeromq.org/4-2:zmq-disconnect</a>
</li>

<li>Céčková C funkce <strong>zmq_send</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-send">http://api.zeromq.org/4-2:zmq-send</a>
</li>

<li>Céčková C funkce <strong>zmq_recv</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-recv">http://api.zeromq.org/4-2:zmq-recv</a>
</li>

<li>Třída <strong>Context</strong> (Python)<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.html#context">https://pyzmq.readthedocs.io/en/latest/api/zmq.html#context</a>
</li>

<li>Třída <strong>Socket</strong> (Python)<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.html#socket">https://pyzmq.readthedocs.io/en/latest/api/zmq.html#socket</a>
</li>

<li>Python binding<br />
<a href="http://zeromq.org/bindings:python">http://zeromq.org/bindings:python</a>
</li>

<li>Why should I have written ZeroMQ in C, not C++ (part I)<br />
<a href="http://250bpm.com/blog:4">http://250bpm.com/blog:4</a>
</li>

<li>Why should I have written ZeroMQ in C, not C++ (part II) <br />
<a href="http://250bpm.com/blog:8">http://250bpm.com/blog:8</a>
</li>

<li>About Nanomsg<br />
<a href="https://nanomsg.org/">https://nanomsg.org/</a>
</li>

<li>Advanced Message Queuing Protocol<br />
<a href="https://www.amqp.org/">https://www.amqp.org/</a>
</li>

<li>Advanced Message Queuing Protocol na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol">https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol</a>
</li>

<li>Dokumentace k&nbsp;příkazu <strong>rabbitmqctl</strong><br />
<a href="https://www.rabbitmq.com/rabbitmqctl.8.html">https://www.rabbitmq.com/rabbitmqctl.8.html</a>
</li>

<li>RabbitMQ<br />
<a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a>
</li>

<li>RabbitMQ Tutorials<br />
<a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a>
</li>

<li>RabbitMQ: Clients and Developer Tools<br />
<a href="https://www.rabbitmq.com/devtools.html">https://www.rabbitmq.com/devtools.html</a>
</li>

<li>RabbitMQ na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/RabbitMQ">https://en.wikipedia.org/wiki/RabbitMQ</a>
</li>

<li>Streaming Text Oriented Messaging Protocol<br />
<a href="https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol">https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol</a>
</li>

<li>Message Queuing Telemetry Transport<br />
<a href="https://en.wikipedia.org/wiki/MQTT">https://en.wikipedia.org/wiki/MQTT</a>
</li>

<li>Erlang<br />
<a href="http://www.erlang.org/">http://www.erlang.org/</a>
</li>

<li>pika 0.12.0 na PyPi<br />
<a href="https://pypi.org/project/pika/">https://pypi.org/project/pika/</a>
</li>

<li>Introduction to Pika<br />
<a href="https://pika.readthedocs.io/en/stable/">https://pika.readthedocs.io/en/stable/</a>
</li>

<li>Langohr: An idiomatic Clojure client for RabbitMQ that embraces the AMQP 0.9.1 model<br />
<a href="http://clojurerabbitmq.info/">http://clojurerabbitmq.info/</a>
</li>

<li>AMQP 0-9-1 Model Explained<br />
<a href="http://www.rabbitmq.com/tutorials/amqp-concepts.html">http://www.rabbitmq.com/tutorials/amqp-concepts.html</a>
</li>

<li>Part 1: RabbitMQ for beginners - What is RabbitMQ?<br />
<a href="https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html">https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html</a>
</li>

<li>Downloading and Installing RabbitMQ<br />
<a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a>
</li>

<li>celery na PyPi<br />
<a href="https://pypi.org/project/celery/">https://pypi.org/project/celery/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python <br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python (dokončení)<br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/</a>
</li>

<li>Redis Queue (RQ)<br />
<a href="https://www.fullstackpython.com/redis-queue-rq.html">https://www.fullstackpython.com/redis-queue-rq.html</a>
</li>

<li>Python Celery &amp; RabbitMQ Tutorial<br />
<a href="https://tests4geeks.com/python-celery-rabbitmq-tutorial/">https://tests4geeks.com/python-celery-rabbitmq-tutorial/</a>
</li>

<li>Flower: Real-time Celery web-monitor<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor">http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor</a>
</li>

<li>Asynchronous Tasks With Django and Celery<br />
<a href="https://realpython.com/asynchronous-tasks-with-django-and-celery/">https://realpython.com/asynchronous-tasks-with-django-and-celery/</a>
</li>

<li>First Steps with Celery<br />
<a href="http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html">http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html</a>
</li>

<li>node-celery<br />
<a href="https://github.com/mher/node-celery">https://github.com/mher/node-celery</a>
</li>

<li>Full Stack Python: web development<br />
<a href="https://www.fullstackpython.com/web-development.html">https://www.fullstackpython.com/web-development.html</a>
</li>

<li>Introducing RQ<br />
<a href="https://nvie.com/posts/introducing-rq/">https://nvie.com/posts/introducing-rq/</a>
</li>

<li>Asynchronous Tasks with Flask and Redis Queue<br />
<a href="https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue">https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Stránky projektu Redis<br />
<a href="https://redis.io/">https://redis.io/</a>
</li>

<li>Introduction to Redis<br />
<a href="https://redis.io/topics/introduction">https://redis.io/topics/introduction</a>
</li>

<li>Try Redis<br />
<a href="http://try.redis.io/">http://try.redis.io/</a>
</li>

<li>Redis tutorial, April 2010 (starší, ale pěkně udělaný)<br />
<a href="https://static.simonwillison.net/static/2010/redis-tutorial/">https://static.simonwillison.net/static/2010/redis-tutorial/</a>
</li>

<li>Python Redis<br />
<a href="https://redislabs.com/lp/python-redis/">https://redislabs.com/lp/python-redis/</a>
</li>

<li>Redis: key-value databáze v paměti i na disku<br />
<a href="https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/">https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/</a>
</li>

<li>Praktický úvod do Redis (1): vaše distribuovaná NoSQL cache<br />
<a href="http://www.cloudsvet.cz/?p=253">http://www.cloudsvet.cz/?p=253</a>
</li>

<li>Praktický úvod do Redis (2): transakce<br />
<a href="http://www.cloudsvet.cz/?p=256">http://www.cloudsvet.cz/?p=256</a>
</li>

<li>Praktický úvod do Redis (3): cluster<br />
<a href="http://www.cloudsvet.cz/?p=258">http://www.cloudsvet.cz/?p=258</a>
</li>

<li>Connection pool<br />
<a href="https://en.wikipedia.org/wiki/Connection_pool">https://en.wikipedia.org/wiki/Connection_pool</a>
</li>

<li>Instant Redis Sentinel Setup<br />
<a href="https://github.com/ServiceStack/redis-config">https://github.com/ServiceStack/redis-config</a>
</li>

<li>How to install REDIS in LInux<br />
<a href="https://linuxtechlab.com/how-install-redis-server-linux/">https://linuxtechlab.com/how-install-redis-server-linux/</a>
</li>

<li>Redis RDB Dump File Format<br />
<a href="https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format">https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format</a>
</li>

<li>Lempel–Ziv–Welch<br />
<a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch">https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch</a>
</li>

<li>Redis Persistence<br />
<a href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a>
</li>

<li>Redis persistence demystified<br />
<a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html">http://oldblog.antirez.com/post/redis-persistence-demystified.html</a>
</li>

<li>Redis reliable queues with Lua scripting<br />
<a href="http://oldblog.antirez.com/post/250">http://oldblog.antirez.com/post/250</a>
</li>

<li>Ost (knihovna)<br />
<a href="https://github.com/soveran/ost">https://github.com/soveran/ost</a>
</li>

<li>NoSQL<br />
<a href="https://en.wikipedia.org/wiki/NoSQL">https://en.wikipedia.org/wiki/NoSQL</a>
</li>

<li>Shard (database architecture)<br />
<a href="https://en.wikipedia.org/wiki/Shard_%28database_architecture%29">https://en.wikipedia.org/wiki/Shard_%28database_architecture%29</a>
</li>

<li>What is sharding and why is it important?<br />
<a href="https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important">https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important</a>
</li>

<li>What Is Sharding?<br />
<a href="https://btcmanager.com/what-sharding/">https://btcmanager.com/what-sharding/</a>
</li>

<li>Redis clients<br />
<a href="https://redis.io/clients">https://redis.io/clients</a>
</li>

<li>Category:Lua-scriptable software<br />
<a href="https://en.wikipedia.org/wiki/Category:Lua-scriptable_software">https://en.wikipedia.org/wiki/Category:Lua-scriptable_software</a>
</li>

<li>Seriál Programovací jazyk Lua<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-lua/">https://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>Redis memory usage<br />
<a href="http://nosql.mypopescu.com/post/1010844204/redis-memory-usage">http://nosql.mypopescu.com/post/1010844204/redis-memory-usage</a>
</li>

<li>Ukázka konfigurace Redisu pro lokální testování<br />
<a href="https://github.com/tisnik/presentations/blob/master/redis/redis.conf">https://github.com/tisnik/presentations/blob/master/redis/redis.conf</a>
</li>

<li>Resque<br />
<a href="https://github.com/resque/resque">https://github.com/resque/resque</a>
</li>

<li>Nested transaction<br />
<a href="https://en.wikipedia.org/wiki/Nested_transaction">https://en.wikipedia.org/wiki/Nested_transaction</a>
</li>

<li>Publish–subscribe pattern<br />
<a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern</a>
</li>

<li>Messaging pattern<br />
<a href="https://en.wikipedia.org/wiki/Messaging_pattern">https://en.wikipedia.org/wiki/Messaging_pattern</a>
</li>

<li>Using pipelining to speedup Redis queries<br />
<a href="https://redis.io/topics/pipelining">https://redis.io/topics/pipelining</a>
</li>

<li>Pub/Sub<br />
<a href="https://redis.io/topics/pubsub">https://redis.io/topics/pubsub</a>
</li>

<li>ZeroMQ distributed messaging<br />
<a href="http://zeromq.org/">http://zeromq.org/</a>
</li>

<li>ZeroMQ: Modern &amp; Fast Networking Stack<br />
<a href="https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/">https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/</a>
</li>

<li>Publish/Subscribe paradigm: Why must message classes not know about their subscribers?<br />
<a href="https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr">https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr</a>
</li>

<li>Python &amp; Redis PUB/SUB<br />
<a href="https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7">https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7</a>
</li>

<li>Message broker<br />
<a href="https://en.wikipedia.org/wiki/Message_broker">https://en.wikipedia.org/wiki/Message_broker</a>
</li>

<li>RESP Arrays<br />
<a href="https://redis.io/topics/protocol#array-reply">https://redis.io/topics/protocol#array-reply</a>
</li>

<li>Redis Protocol specification<br />
<a href="https://redis.io/topics/protocol">https://redis.io/topics/protocol</a>
</li>

<li>Redis Pub/Sub: Intro Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-intro/">https://www.redisgreen.net/blog/pubsub-intro/</a>
</li>

<li>Redis Pub/Sub: Howto Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-howto/">https://www.redisgreen.net/blog/pubsub-howto/</a>
</li>

<li>Comparing Publish-Subscribe Messaging and Message Queuing<br />
<a href="https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message">https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message</a>
</li>

<li>Apache Kafka<br />
<a href="https://kafka.apache.org/">https://kafka.apache.org/</a>
</li>

<li>Iron<br />
<a href="http://www.iron.io/mq">http://www.iron.io/mq</a>
</li>

<li>kue (založeno na Redisu, určeno pro node.js)<br />
<a href="https://github.com/Automattic/kue">https://github.com/Automattic/kue</a>
</li>

<li>Cloud Pub/Sub<br />
<a href="https://cloud.google.com/pubsub/">https://cloud.google.com/pubsub/</a>
</li>

<li>Introduction to Redis Streams<br />
<a href="https://redis.io/topics/streams-intro">https://redis.io/topics/streams-intro</a>
</li>

<li>glob (programming)<br />
<a href="https://en.wikipedia.org/wiki/Glob_(programming)">https://en.wikipedia.org/wiki/Glob_(programming)</a>
</li>

<li>Why and how Pricing Assistant migrated from Celery to RQ - Paris.py<br />
<a href="https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2">https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2</a>
</li>

<li>Enqueueing internals<br />
<a href="http://python-rq.org/contrib/">http://python-rq.org/contrib/</a>
</li>

<li>queue — A synchronized queue class<br />
<a href="https://docs.python.org/3/library/queue.html">https://docs.python.org/3/library/queue.html</a>
</li>

<li>Queue – A thread-safe FIFO implementation<br />
<a href="https://pymotw.com/2/Queue/">https://pymotw.com/2/Queue/</a>
</li>

<li>Queues<br />
<a href="http://queues.io/">http://queues.io/</a>
</li>

<li>Windows Subsystem for Linux Documentation<br />
<a href="https://docs.microsoft.com/en-us/windows/wsl/about">https://docs.microsoft.com/en-us/windows/wsl/about</a>
</li>

<li>RestMQ<br />
<a href="http://restmq.com/">http://restmq.com/</a>
</li>

<li>ActiveMQ<br />
<a href="http://activemq.apache.org/">http://activemq.apache.org/</a>
</li>

<li>Amazon MQ<br />
<a href="https://aws.amazon.com/amazon-mq/">https://aws.amazon.com/amazon-mq/</a>
</li>

<li>Amazon Simple Queue Service<br />
<a href="https://aws.amazon.com/sqs/">https://aws.amazon.com/sqs/</a>
</li>

<li>Celery: Distributed Task Queue<br />
<a href="http://www.celeryproject.org/">http://www.celeryproject.org/</a>
</li>

<li>Disque, an in-memory, distributed job queue<br />
<a href="https://github.com/antirez/disque">https://github.com/antirez/disque</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Projekt RQ na PyPi<br />
<a href="https://pypi.org/project/rq/">https://pypi.org/project/rq/</a>
</li>

<li>rq-dashboard 0.3.12<br />
<a href="https://pypi.org/project/rq-dashboard/">https://pypi.org/project/rq-dashboard/</a>
</li>

<li>Job queue<br />
<a href="https://en.wikipedia.org/wiki/Job_queue">https://en.wikipedia.org/wiki/Job_queue</a>
</li>

<li>Why we moved from Celery to RQ<br />
<a href="https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq">https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq</a>
</li>

<li>Running multiple workers using Celery<br />
<a href="https://serverfault.com/questions/655387/running-multiple-workers-using-celery">https://serverfault.com/questions/655387/running-multiple-workers-using-celery</a>
</li>

<li>celery — Distributed processing<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.html">http://docs.celeryproject.org/en/latest/reference/celery.html</a>
</li>

<li>Chains<br />
<a href="https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains">https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains</a>
</li>

<li>Routing<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing">http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing</a>
</li>

<li>Celery Distributed Task Queue in Go<br />
<a href="https://github.com/gocelery/gocelery/">https://github.com/gocelery/gocelery/</a>
</li>

<li>Python Decorators<br />
<a href="https://wiki.python.org/moin/PythonDecorators">https://wiki.python.org/moin/PythonDecorators</a>
</li>

<li>Periodic Tasks<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html">http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html</a>
</li>

<li>celery.schedules<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab">http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab</a>
</li>

<li>Pros and cons to use Celery vs. RQ<br />
<a href="https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq">https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq</a>
</li>

<li>Priority queue<br />
<a href="https://en.wikipedia.org/wiki/Priority_queue">https://en.wikipedia.org/wiki/Priority_queue</a>
</li>

<li>Jupyter<br />
<a href="https://jupyter.org/">https://jupyter.org/</a>
</li>

<li>How IPython and Jupyter Notebook work<br />
<a href="https://jupyter.readthedocs.io/en/latest/architecture/how_jupyter_ipython_work.html">https://jupyter.readthedocs.io/en/latest/architecture/how_jupyter_ipython_work.html</a>
</li>

<li>Context Managers<br />
<a href="http://book.pythontips.com/en/latest/context_managers.html">http://book.pythontips.com/en/latest/context_managers.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

