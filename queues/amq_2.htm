<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Použití Apache ActiveMQ s protokolem STOMP</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Použití Apache ActiveMQ s protokolem STOMP</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Použití Apache ActiveMQ s&nbsp;protokolem STOMP</a></p>
<p><a href="#k02">2. Zjednodušení producenta a konzumenta zpráv při použití strategie PUB-SUB</a></p>
<p><a href="#k03">3. Totéž zjednodušení při použití komunikační strategie PUSH-PULL</a></p>
<p><a href="#k04">*** 4. Explicitní potvrzování zpráv (<strong>ACK</strong>) vybíraných z&nbsp;fronty</a></p>
<p><a href="#k05">*** 5. Záporné potvrzení zprávy (<strong>NACK</strong>)</a></p>
<p><a href="#k06">*** 6. Chování AMQ při záporném potvrzení</a></p>
<p><a href="#k07">*** 7. Použití vlastní fronty na straně příjemce při využití komunikace PUSH-PULL</a></p>
<p><a href="#k08">8. Transakce</a></p>
<p><a href="#k09">*** 9. Komunikace typu PUB-SUB bez transakce</a></p>
<p><a href="#k10">*** 10. Komunikace typu PUB-SUB v&nbsp;transakci</a></p>
<p><a href="#k11">*** 11. Komunikace typu PUSH-PULL bez transakce</a></p>
<p><a href="#k12">*** 12. Komunikace typu PUSH-PULL v&nbsp;transakci</a></p>
<p><a href="#k13">*** 13. Zrušení celé transakce (rollback namísto commit)</a></p>
<p><a href="#k14">*** 14. Využití <i>heartbeat</i> pro ověření funkčnosti jednotlivých částí systému</a></p>
<p><a href="#k15">*** 15. Posílání binárních zpráv</a></p>
<p><a href="#k16">*** 16. Producent binární zprávy</a></p>
<p><a href="#k17">*** 17. Konzument binární zprávy</a></p>
<p><a href="#k18">*** 18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Odkazy na předchozí části seriálu</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Použití Apache ActiveMQ s&nbsp;protokolem STOMP</h2>

<p><a
href="https://www.root.cz/clanky/apache-activemq-dalsi-system-implementujici-message-brokera/">V&nbsp;předchozím
článku</a> <a href="#k19">seriálu o message brokerech</a> jsme se seznámili
s&nbsp;nástrojem Apache ActiveMQ (AMQ) a ukázali jsme si i dva krátké
demonstrační příklady, které AMQ používaly jak pro komunikační strategii
PUB-SUB, tak i pro strategii PUSH-PULL (tj.&nbsp;pro klasické fronty zpráv).
Dnes si ukážeme další možnosti nabízené nástrojem AMQ při použití protokolu
STOMP (<i>Streaming Text Oriented Messaging Protocol</i>), který sice nedokáže
využít všechny možnosti AMQ, ovšem základní architekturu systému založeného na
kombinaci AMQ+STOMP celkem bez problémů dokážeme postavit (ostatně největší
problémy nás většinou čekají při návrhu subsystému pro persistenci zpráv
popř.&nbsp;pro clusterování a load balancing).</p>

<p><div class="rs-tip-major">Poznámka: všechny možnosti AMQ je možné využít při
použití protokolu AMQP 1.0, který je však mnohem složitější než STOMP. Navíc,
pokud již postavíte systém na protokolu STOMP, je výměna message brokera
relativně jednoduchá &ndash; použít je možné například již popsaný nástroj <a
href="https://www.root.cz/clanky/rabbitmq-jedna-z-nejuspesnejsich-implementaci-brokera/">RabbitMQ</a>
popř.&nbsp;projekt Apollo (následovníka AMQ).</div></p>

<p>V&nbsp;tabulce zobrazené pod tímto odstavcem jsou vypsány všechny příkazy
podporované protokolem STOMP verze 1.2 (verze 1.1 se v&nbsp;tomto ohledu příliš
neliší):</p>

<table>
<tr><th>#</th><th>Příkaz</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>SEND</td><td>poslání zprávy</td></tr>
<tr><td>2</td><td>SUBSCRIBE</td><td>přihlášení k&nbsp;odběru zpráv</td></tr>
<tr><td>3</td><td>UNSUBSCRIBE</td><td>odhlášení od odběru zpráv</td></tr>
<tr><td>4</td><td>ACK</td><td>potvrzení zprávy</td></tr>
<tr><td>5</td><td>NACK</td><td>negativní potvrzení (vysvětlíme si příště)</td></tr>
<tr><td>6</td><td>BEGIN</td><td>začátek transakce (vysvětlíme si příště)</td></tr>
<tr><td>7</td><td>COMMIT</td><td>commit v&nbsp;transakci (provedení všech operací)</td></tr>
<tr><td>8</td><td>ABORT</td><td>rollback transakce</td></tr>
<tr><td>9</td><td>DISCONNECT</td><td>odpojení klienta</td></tr>
</table>

<p>Ještě před popisem demonstračních příkladů se krátce zmiňme o persistenci
zpráv. Ve výchozím nastavení jsou zprávy ukládány do databáze KahaDB, která
nabízí mj.&nbsp;i žurnálování. Soubory s&nbsp;databází naleznete
v&nbsp;podadresáři &bdquo;data/kahadb&ldquo;:</p>

<pre>
$ <strong>ls -1 data/kahadb/</strong>
&nbsp;
db-1.log
db.data
db.free
db.redo
lock
</pre>

<p>Konfiguraci ukládání zpráv nalezneme v&nbsp;souboru
<strong>activemq.xml</strong>:</p>

<pre>
&lt;broker brokerName="broker"&gt;
   &lt;persistenceAdapter&gt;
     &lt;kahaDB directory="activemq-data" journalMaxFileLength="32mb"/&gt;
   &lt;/persistenceAdapter&gt;
&lt;/broker&gt;
</pre>

<p>Bližší informace o konfiguraci i o principu činnosti KahaDB naleznete na
stránkách:</p>

<ol>

<li>KahaDB<br />
<a href="http://activemq.apache.org/kahadb.html">http://activemq.apache.org/kahadb.html</a>
</li>

<li>Understanding the KahaDB Message Store<br />
<a href="https://access.redhat.com/documentation/en-US/Fuse_MQ_Enterprise/7.1/html/Configuring_Broker_Persistence/files/KahaDBOverview.html">https://access.redhat.com/documentation/en-US/Fuse_MQ_Enterprise/7.1/html/Configuring_Broker_Persistence/files/KahaDBOverview.html</a>
</li>

</ol>

<p>Nastavení perzistence zpráv lze samozřejmě změnit, dokonce je možné i
vyměnit typ databáze. Podrobnosti budou popsány příště v&nbsp;rámci konfigurace
AMQ.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Zjednodušení producenta a konzumenta zpráv při použití strategie PUB-SUB</h2>

<p>Nejprve si zopakujeme dva základní způsoby použití message brokera. Většinou
jsou podporovány dvě rozdílně pracující komunikační strategie:</p>

<ol>

<li><strong>PUB-SUB</strong>: zprávy jsou posílány producentem do message
brokera, který má k&nbsp;dispozici dynamicky se měnící seznam příjemců
(konzumentů) zpráv. Pokud příjemce daného <i>tématu</i> zpráv existuje, je mu
zpráva přeposlána. Podobně se systém chová při existenci většího množství
příjemců. Zpráva je od producenta přečtena i ve chvíli, kdy neexistuje žádný
příjemce &ndash; v&nbsp;takovém případě je zahozena (pokud se interně používá
fronta, je jen dočasná).</li>

<li><strong>PUSH-PULL</strong>: tato strategie je založena na použití fronty.
Producent pošle zprávu message brokerovi, který ji uloží do fronty (každá
fronta je pojmenovaná), konzumenti se mohou k&nbsp;frontě (frontám) připojit a
zprávy přečíst. V&nbsp;tomto případě se zpráva doručí jen jedinému
konzumentovi. Pokud se k&nbsp;frontě připojí větší množství konzumentů, je
typicky použit algoritmus <i>round-robin</i> pro (polo)spravedlivé rozložení
zátěže.</li>

</ol>

<p>Ukažme si nejdříve implementaci producenta zpráv při použití strategie
<strong>PUB-SUB</strong>. Jak jsme si již naznačili v&nbsp;předchozím textu, je
každé zprávě přiřazeno téma (<i>topic</i>), které může být v&nbsp;případě
použití protokolu STOMP specifikováno následovně:</p>

<pre>
"/topic/event"
"/topic/téma2"
"/topic/jiné_téma"
</pre>

<p><div class="rs-tip-major">Poznámka: podobnost s&nbsp;cestou v&nbsp;rámci
souborového systému není náhodná.</div></p>

<p>Producent zpráv se nejprve musí připojit k&nbsp;běžícímu message brokerovi.
V&nbsp;demonstračním příkladu popsaném minule jsme pro připojení použili
volání:</p>

<pre>
conn = stomp.Connection(host_and_ports=[("localhost", 61613)])
conn.start()
conn.connect(login="admin", passcode="admin")
</pre>

<p>Ve skutečnosti je ovšem možné využít i zjednodušeného zápisu při volání konstruktoru <strong>Connection</strong>:</p>

<pre>
conn = stomp.Connection([("localhost", 61613)])
conn.start()
conn.connect(login="admin", passcode="admin")
</pre>

<p>Zprávy se posílají metodou <strong>send</strong>, přičemž je nutné specifikovat jak téma, tak i vlastní zprávu:</p>

<pre>
conn.send("/topic/event", "Hello world!")
</pre>

<p>Podporovány jsou i další nepovinné parametry, například:</p>

<pre>
conn.send("/topic/event", "Hello world!", persistent='true')
conn.send("/topic/event", "Hello world!", transaction='id-transakce')
conn.send("/topic/event", "Hello world!", content_type='text/plain')
</pre>

<p>Po poslání všech zpráv je vhodné, aby se producent od message brokera odpojil:</p>

<pre>
conn.disconnect()
</pre>

<p>Podívejme se nyní na <a href="https://github.com/tisnik/message-queues-examples/blob/master/amq/example03_simple_connection_call/publisher.py">úplný zdrojový kód jednoduchého producenta</a> zpráv, který použije dvě témata (topicy) se jmény &bdquo;event&ldquo; a &bdquo;event2&ldquo;:</p>

<pre>
#!/usr/bin/env python
&nbsp;
import time
import stomp
&nbsp;
&nbsp;
destination1 = "/topic/event"
destination2 = "/topic/event2"
&nbsp;
MESSAGES = 10
&nbsp;
conn = stomp.Connection([("localhost", 61613)])
conn.start()
conn.connect(login="admin", passcode="admin")
&nbsp;
&nbsp;
for i in range(0, MESSAGES):
    message = "Hello world #{i}!".format(i=i)
    conn.send(destination1, message, persistent='true')
    conn.send(destination2, message, persistent='true')
&nbsp;
&nbsp;
conn.disconnect()
</pre>

<p>Konzument (příjemce) zpráv je složitější, protože se samotný příjem zprávy (nebo vznik chyby) programuje s&nbsp;využitím callback metod. Samotný handler jednotlivých událostí může v&nbsp;nejjednodušším případě obsahovat pouze metody nazvané <strong>on_message</strong> (zavoláno při přijetí zprávy) a <strong>on_error</strong> (zavoláno v&nbsp;případě nějaké chyby). Existují ovšem i další callback metody, například <strong>on_disconnected</strong> a <strong>on_heartbeat</strong>, které si popíšeme později. Implementace handleru událostí:</p>

<pre>
class <strong>SimpleListener</strong>(object):
&nbsp;
    def <strong>__init__</strong>(self, conn):
        self.conn = conn
&nbsp;
    def <strong>on_message</strong>(self, headers, message):
        print("Received message: {m}".format(m=message))
&nbsp;
    def <strong>on_error</strong>(self, headers, message):
        print("Received an error {e}".format(e=message))
</pre>

<p>Samotné připojení příjemce zpráv je řešeno shodným kódem, jako u producenta, ovšem navíc musíme zaregistrovat výše zmíněný handler metodou <strong>set_listener</strong>:</p>

<pre>
conn = stomp.Connection([("localhost", 61613)])
conn.set_listener('', SimpleListener(conn))
conn.start()
&nbsp;
conn.connect(login="admin", passcode="admin")
</pre>

<p>K&nbsp;odebírání zpráv pro zvolené téma se přihlásíme metodou <strong>subscribe</strong>:</p>

<pre>
conn.subscribe(id='simple_listener', destination="/topic/zvolené_téma", ack='auto')
</pre>

<p><div class="rs-tip-major">Poznámka: nepovinný parametr <strong>ack</strong> určuje, jakým způsobem se potvrzuje zpracování zpráv. My jsme zvolili možnost &bdquo;auto&ldquo;. tj.&nbsp;zpráva je ihned po svém přijetí potvrzena, i když ve skutečnosti není zaručeno, že bude bez problémů i zpracována.</div></p>

<p>Opět si ukažme <a href="https://github.com/tisnik/message-queues-examples/blob/master/amq/example03_simple_connection_call/subscriber.py">úplný zdrojový kód jednoduchého konzumenta</a> zpráv:</p>

<pre>
#!/usr/bin/env python
&nbsp;
import time
import stomp
&nbsp;
&nbsp;
class <strong>SimpleListener</strong>(object):
&nbsp;
    def <strong>__init__</strong>(self, conn):
        self.conn = conn
&nbsp;
    def <strong>on_message</strong>(self, headers, message):
        print("Received message: {m}".format(m=message))
&nbsp;
    def <strong>on_error</strong>(self, headers, message):
        print("Received an error {e}".format(e=message))
&nbsp;
&nbsp;
destination = "/topic/event"
&nbsp;
conn = stomp.Connection([("localhost", 61613)])
conn.set_listener('', SimpleListener(conn))
conn.start()
&nbsp;
conn.connect(login="admin", passcode="admin")
conn.subscribe(id='simple_listener', destination=destination, ack='auto')
&nbsp;
print("Waiting for messages...")
&nbsp;
while True:
    time.sleep(10)
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Totéž zjednodušení při použití komunikační strategie PUSH-PULL</h2>

<p>Podobným způsobem můžeme implementovat producenta zpráv posílaných do front a tudíž používajících komunikační strategii <strong>PUSH-PULL</strong> a nikoli <strong>PUB-SUB</strong>. Na straně producenta se změní jen dva řádky, na nichž je specifikován cíl zpráv (z&nbsp;pohledu producenta je cílem nějaký bod message brokera). U strategie <strong>PUB-SUB</strong> byly cíle pojmenovány takto:</p>

<pre>
destination1 = "/topic/event"
destination2 = "/topic/event2"
</pre>

<p>kdežto v&nbsp;případě strategie <strong>PUSH-PULL</strong> použijeme:</p>

<pre>
destination1 = "/queue/test"
destination2 = "/queue/test2"
</pre>

<p><div class="rs-tip-major">Poznámka: záleží samozřejmě na nás, kolik cílů zpráv budeme používat. V&nbsp;případě většiny producentů zpráv se použije jen jediný cíl.</div></p>

<p><a href="">Nejjednodušší producent zpráv</a> posílaných do dvojice front může vypadat takto:</p>

<pre>
#!/usr/bin/env python
&nbsp;
import time
import stomp
&nbsp;
&nbsp;
destination1 = "/queue/test"
destination2 = "/queue/test2"
&nbsp;
MESSAGES = 10
&nbsp;
conn = stomp.Connection([("localhost", 61613)])
conn.start()
conn.connect(login="admin", passcode="admin")
&nbsp;
&nbsp;
for i in range(0, MESSAGES):
    message = "Hello world #{i}!".format(i=i)
    conn.send(destination1, message, persistent='true')
    conn.send(destination2, message, persistent='true')
&nbsp;
&nbsp;
conn.disconnect()
</pre>

<pre>
#!/usr/bin/env python
&nbsp;
import time
import stomp
&nbsp;
&nbsp;
class SimpleListener(object):
&nbsp;
    def <strong>__init__</strong>(self, conn):
        self.conn = conn
&nbsp;
    def <strong>on_message</strong>(self, headers, message):
        print("Received message: {m}".format(m=message))
&nbsp;
    def <strong>on_error</strong>(self, headers, message):
        print("Received an error {e}".format(e=message))
&nbsp;
&nbsp;
destination = "/queue/test"
&nbsp;
conn = stomp.Connection([("localhost", 61613)])
conn.set_listener('', SimpleListener(conn))
conn.start()
&nbsp;
conn.connect(login="admin", passcode="admin")
conn.subscribe(id='simple_listener', destination=destination, ack='auto')
&nbsp;
print("Waiting for messages...")
&nbsp;
while True:
    time.sleep(10)
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Explicitní potvrzování zpráv (<strong>ACK</strong>) vybíraných z&nbsp;fronty</h2>

<pre>
#!/usr/bin/env python

import time
import stomp


class SimpleListener(object):

    def <strong>__init__</strong>(self, conn):
        self.conn = conn

    def <strong>on_message</strong>(self, headers, message):
        print("Received message: {m}".format(m=message))
        print(headers)
        message_id = headers['message-id']
        subscription = headers['subscription']
        self.conn.ack(message_id, subscription)

    def <strong>on_error</strong>(self, headers, message):
        print("Received an error {e}".format(e=message))


destination = "/queue/test"

conn = stomp.Connection(host_and_ports=[("localhost", 61613)])
conn.set_listener('', SimpleListener(conn))
conn.start()

conn.connect(login="admin", passcode="admin")
conn.subscribe(id='simple_listener', destination=destination, ack='client')

print("Waiting for messages...")

while True:
    time.sleep(10)
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Záporné potvrzení zprávy (<strong>NACK</strong>)</h2>

<pre>
#!/usr/bin/env python

import time
import stomp


class SimpleListener(object):

    def <strong>__init__</strong>(self, conn):
        self.conn = conn

    def <strong>on_message</strong>(self, headers, message):
        print("Received message: {m}".format(m=message))
        print(headers)
        message_id = headers['message-id']
        subscription = headers['subscription']
        self.conn.nack(message_id, subscription)

    def <strong>on_error</strong>(self, headers, message):
        print("Received an error {e}".format(e=message))


destination = "/queue/test"

conn = stomp.Connection(host_and_ports=[("localhost", 61613)])
conn.set_listener('', SimpleListener(conn))
conn.start()

conn.connect(login="admin", passcode="admin")
conn.subscribe(id='simple_listener', destination=destination, ack='client')

print("Waiting for messages...")

while True:
    time.sleep(10)
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Použití vlastní fronty na straně příjemce při využití komunikace PUSH-PULL</h2>

<pre>
#!/usr/bin/env python

import time
import stomp

from queue import Queue


class SimpleListener(object):

    def <strong>__init__</strong>(self, queue):
        self.queue = queue

    def <strong>on_message</strong>(self, headers, message):
        print("Received message: {m}, putting it into local queue".format(m=message))
        self.queue.put(message)

    def <strong>on_error</strong>(self, headers, message):
        print("Received an error {e}".format(e=message))


q = Queue()

destination = "/queue/test"

conn = stomp.Connection([("localhost", 61613)])
conn.set_listener('', SimpleListener(q))
conn.start()

conn.connect(login="admin", passcode="admin")
conn.subscribe(id='simple_listener', destination=destination, ack='auto')

print("Waiting for messages...")

while True:
    item = q.get()
    print("Begin working on " + item)
    if item == "exit":
        break

    time.sleep(1)
    q.task_done()
    print("Finished working on " + item)

conn.disconnect()
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Transakce</h2>


<table>
<tr><th>Příkaz</th><th>Stručný popis</th></tr>
<tr><td>BEGIN</td><td>začátek transakce (vysvětlíme si příště)</td></tr>
<tr><td>COMMIT</td><td>commit v&nbsp;transakci (provedení všech operací)</td></tr>
<tr><td>ABORT</td><td>rollback transakce</td></tr>
</table>

<p>Použití těchto příkazů si můžeme vyzkoušet z&nbsp;klienta protokolu STOMP
ovládaného z&nbsp;příkazového řádku:</p>

<pre>
$ <strong>stomp -H 127.0.0.1 -P 61613 -U admin -W admin</strong>
</pre>

<p>Příkazy zadávané uživatelem jsou zvýrazněny tučně:</p>

<pre>
&gt; begin
Transaction id: 72c39904-080c-478f-a540-550b2deb9d99
&nbsp;
&gt; <strong>send /queue/test x</strong>
&gt; <strong>send /queue/test y</strong>
&gt; <strong>send /queue/test z</strong>
&gt; <strong>commit</strong>
Committing 72c39904-080c-478f-a540-550b2deb9d99
&nbsp;
&gt; <strong>begin</strong>
Transaction id: 37d70eb2-5e91-4988-932b-e2acfe1bc275
&nbsp;
&gt; <strong>send /queue/test u</strong>
&gt; <strong>send /queue/test v</strong>
&gt; <strong>send /queue/test w</strong>
&gt; 
&gt; rollback
</pre>

<p>Na straně příjemce zpráv se objeví pouze informace o přijetí prvních tří
zpráv &bdquo;x&ldquo;, &bdquo;y&ldquo; a &bdquo;z&ldquo;, zatímco zprávy
&bdquo;u&ldquo;, &bdquo;v&ldquo; a &bdquo;w&ldquo; nejsou do fronty vloženy a
tudíž je ani příjemce nemůže získat:</p>

<pre>
Waiting for messages...
Received message: x
Received message: y
Received message: z
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že po zadání příkazu
<strong>begin</strong> (začátek transakce) se vypíše řetězec
s&nbsp;jednoznačným identifikátorem transakce. Ten budeme potřebovat
v&nbsp;dalších demonstračních příkladech, protože se jedná o jeden
z&nbsp;atributů zprávy.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Komunikace typu PUB-SUB bez transakce</h2>

<p>Rozdíl mezi použitím a nepoužitím transakcí si ukážeme na dvou
příkladech:</p>

<ol>
<li>Producent-konzument používající PUB-SUB</li>
<li>Producent-konzument používající PUSH-PULL</li>
</ol>

<p></p>

<pre>
#!/usr/bin/env python

import time
import stomp


destination1 = "/topic/event"
destination2 = "/topic/event2"

MESSAGES = 10

conn = stomp.Connection([("localhost", 61613)])
conn.start()
conn.connect(login="admin", passcode="admin")


for i in range(0, MESSAGES):
    message = "Hello world #{i}!".format(i=i)
    print("Publishing message: " + message)
    conn.send(destination1, message, persistent='true')
    conn.send(destination2, message, persistent='true')
    time.sleep(1)
    print("Done")


conn.disconnect()
</pre>

<pre>
#!/usr/bin/env python

import time
import stomp


class SimpleListener:

    def <strong>__init__</strong>(self, conn):
        self.conn = conn

    def <strong>on_message</strong>(self, headers, message):
        print("Received message: {m}".format(m=message))

    def <strong>on_error</strong>(self, headers, message):
        print("Received an error {e}".format(e=message))


destination = "/topic/event"

conn = stomp.Connection([("localhost", 61613)])
conn.set_listener('', SimpleListener(conn))
conn.start()

conn.connect(login="admin", passcode="admin")
conn.subscribe(id='simple_listener', destination=destination, ack='auto')

print("Waiting for messages...")

while True:
    time.sleep(10)
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Komunikace typu PUB-SUB v&nbsp;transakci</h2>

<p></p>

<pre>
#!/usr/bin/env python

import time
import stomp


destination1 = "/topic/event"
destination2 = "/topic/event2"

MESSAGES = 10

conn = stomp.Connection([("localhost", 61613)])
conn.start()
conn.connect(login="admin", passcode="admin")


transaction=conn.begin()
print(transaction)

for i in range(0, MESSAGES):
    message = "Hello world #{i}!".format(i=i)
    print("Publishing message: " + message)
    conn.send(destination1, message, persistent='true', transaction=transaction)
    conn.send(destination2, message, persistent='true', transaction=transaction)
    time.sleep(1)
    print("Done")

conn.commit(transaction=transaction)


conn.disconnect()
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Komunikace typu PUSH-PULL bez transakce</h2>

<p></p>

<pre>
#!/usr/bin/env python

import time
import stomp


destination1 = "/queue/test"
destination2 = "/queue/test2"

MESSAGES = 10

conn = stomp.Connection([("localhost", 61613)])
conn.start()
conn.connect(login="admin", passcode="admin")


for i in range(0, MESSAGES):
    message = "Hello world #{i}!".format(i=i)
    print("Publishing message: " + message)
    conn.send(destination1, message, persistent='true')
    conn.send(destination2, message, persistent='true')
    time.sleep(2)
    print("Done")


conn.disconnect()
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Komunikace typu PUSH-PULL v&nbsp;transakci</h2>

<p></p>

<pre>
#!/usr/bin/env python

import time
import stomp


destination1 = "/queue/test"
destination2 = "/queue/test2"

MESSAGES = 10

conn = stomp.Connection([("localhost", 61613)])
conn.start()
conn.connect(login="admin", passcode="admin")


transaction=conn.begin()
print(transaction)

for i in range(0, MESSAGES):
    message = "Hello world #{i}!".format(i=i)
    print("Publishing message: " + message)
    conn.send(destination1, message, persistent='true', transaction=transaction)
    conn.send(destination2, message, persistent='true', transaction=transaction)
    time.sleep(1)
    print("Done")

conn.commit(transaction=transaction)


conn.disconnect()
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Zrušení celé transakce (rollback namísto commit)</h2>

<p></p>

<pre>
#!/usr/bin/env python

import time
import stomp


destination1 = "/queue/test"
destination2 = "/queue/test2"

MESSAGES = 10

conn = stomp.Connection([("localhost", 61613)])
conn.start()
conn.connect(login="admin", passcode="admin")


transaction=conn.begin()
print(transaction)

for i in range(0, MESSAGES):
    message = "Hello world #{i}!".format(i=i)
    print("Publishing message: " + message)
    conn.send(destination1, message, persistent='true', transaction=transaction)
    conn.send(destination2, message, persistent='true', transaction=transaction)
    time.sleep(1)
    print("Done")

conn.abort(transaction=transaction)


conn.disconnect()
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Využití <i>heartbeat</i> pro ověření funkčnosti jednotlivých částí systému</h2>

<pre>
#!/usr/bin/env python

import time
import stomp


destination1 = "/topic/event"
destination2 = "/topic/event2"

MESSAGES = 10

conn = stomp.Connection([("localhost", 61613)], heartbeats=(0, 0))
conn.start()
conn.connect(login="admin", passcode="admin")


for i in range(0, MESSAGES):
    message = "Hello world #{i}!".format(i=i)
    print("Publishing message: " + message)
    conn.send(destination1, message, persistent='true')
    conn.send(destination2, message, persistent='true')
    time.sleep(0.5)
    print("Done")


conn.disconnect()
</pre>

<pre>
#!/usr/bin/env python

import time
import stomp


class SimpleListener:

    def <strong>__init__</strong>(self, conn):
        self.conn = conn

    def <strong>on_message</strong>(self, headers, message):
        print("Received message: {m}".format(m=message))

    def <strong>on_error</strong>(self, headers, message):
        print("Received an error {e}".format(e=message))

    def <strong>on_disconnected</strong>(self):
        print("Disconnected")

    def <strong>on_heartbeat</strong>(self):
        print("Heartbeat")

    def <strong>on_heartbeat_timeout</strong>(self):
        print("Heartbeat timeout")


destination = "/topic/event"

conn = stomp.Connection([("localhost", 61613)], heartbeats=(0,1000))
conn.set_listener('', SimpleListener(conn))
conn.start()

conn.connect(login="admin", passcode="admin")
conn.subscribe(id='simple_listener', destination=destination, ack='auto')

print("Waiting for messages...")

while True:
    time.sleep(10)

print("Done...")
</pre>

<pre>
Received message: Hello world #7!
Heartbeat
Heartbeat
Heartbeat
Heartbeat
Heartbeat
Received message: Hello world #0!
Received message: Hello world #1!
</pre>

<pre>
Heartbeat timeout: diff_receive=1.5015023681335151, time=2968372.729240428, lastrec=2968371.22773806
Disconnected
Disconnected
Heartbeat timeout
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Posílání binárních zpráv</h2>

<p>V&nbsp;posledním příkladu si ukážeme jednu z&nbsp;možností posílání zpráv obsahujících binární data. Protokol STOMP sice přímo podporuje práci s&nbsp;binárními daty (zprávy nemusí být čistě textové), ovšem na problémy narazíme na straně producentů a konzumentů, zejména ve chvíli, kdy je producent realizován v&nbsp;jiném programovacím jazyce než konzument (popř.&nbsp;v&nbsp;odlišné verzi interpretru &ndash; typicky Python 2 vs. Python 3). Taktéž případné ladění popř.&nbsp;využití telnetu a podobných nástrojů při hledání problémů v&nbsp;systému je v&nbsp;případě přímého posílání binárních dat komplikovanější.</p>

<p>Z&nbsp;tohoto důvodu může být výhodnější binární data nejdříve nějakým způsobem zakódovat do sekvence binárních znaků, například s&nbsp;využitím <a href="https://cs.wikipedia.org/wiki/Base64">Base64</a>, který má tu výhodu, že algoritmus kódování/dekódování lze vytvořit velmi snadno (pokud již pro daný programovací jazyk neexistuje příslušná knihovna &ndash; většinou je již k&nbsp;dispozici). Nevýhodou jsou delší zprávy, které musí být v&nbsp;message brokerovi uloženy (ve frontách) a pomalejší posílání či příjem zpráv &ndash; pokud se ovšem zpracovávají relativně krátké zprávy s&nbsp;menší frekvencí (desítky za sekundu pro jednoho producenta), nemělo by být zpoždění vůbec patrné.</p>

<p>Pro otestování posílání a příjmu zpráv s&nbsp;binárními daty vytvoříme producenta, který do fronty pošle data s&nbsp;rastrovým obrázkem. Samotný obrázek získáme snadno (jedná se o ikonu Vimu, v&nbsp;němž tento článek vznikl):</p>

<pre>
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Producent binární zprávy</h2>

<pre>
#!/usr/bin/env python

import time
import stomp
import base64


destination = "/queue/test"

MESSAGES = 10

conn = stomp.Connection(host_and_ports=[("localhost", 61613)])
conn.start()
conn.connect(login="admin", passcode="admin")


with open("vim_editor.gif", mode="rb") as file:
    binaryData = file.read()
    print("Read {l} bytes from binary file".format(l=len(binaryData)))

    textData = base64.b64encode(binaryData)
    conn.send(destination, textData, persistent='true')
    print("Sent {l} characters".format(l=len(textData)))


conn.disconnect()
</pre>

<pre>
Read 1091 bytes from binary file
Sent 1456 characters
</pre>

<p>Pokud se nyní podíváme na fyzický tvar zprávy uložené do fronty přes webové rozhraní Active MQ, uvidíme, že zpráva byla skutečně převedena do BASE64:</p>

*** image ***
<p><i>Obrázek 1: Takto vypadá zpráva uložená do fronty nazvané &bdquo;test&ldquo;. Vlastní obsah zprávy je červeně orámován.</i></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Konzument binární zprávy</h2>

<pre>
#!/usr/bin/env python

import time
import stomp
import base64


class SimpleListener:

    def <strong>__init__</strong>(self, conn):
        self.conn = conn

    def <strong>on_message</strong>(self, headers, message):
        binaryData = base64.b64decode(message)
        print("Received {l} characters".format(l=len(message)))
        print("   converted into {l} bytes".format(l=len(binaryData)))

        with open("output.gif", "wb") as f:
            f.write(binaryData)

    def <strong>on_error</strong>(self, headers, message):
        print("Received an error {e}".format(e=message))


destination = "/queue/test"

conn = stomp.Connection(host_and_ports=[("localhost", 61613)])
conn.set_listener('', SimpleListener(conn))
conn.start()

conn.connect(login="admin", passcode="admin")
conn.subscribe(id='simple_listener', destination=destination, ack='auto')

print("Waiting for messages...")

while True:
    time.sleep(10)
</pre>

<pre>
Waiting for messages...
Received 1456 characters
   converted into 1091 bytes
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů naprogramovaných
v&nbsp;Pythonu byly uloženy do Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/message-queues-examples">https://github.com/tisnik/message-queues-examples</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
doslova několik kilobajtů), můžete namísto toho použít odkazy na jednotlivé
příklady, které naleznete v&nbsp;následující tabulce.</p>

<table>
<tr><th>Příklad</th><th>Skript/kód</th><th>Popis</th><th>Cesta</th></tr>
<tr><td>1</td><td>publisher.py</td><td>zdroj zpráv posílaných se strategií PUB-SUB</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amq/example01_publisher_listener/publisher.py">https://github.com/tisnik/message-queues-examples/blob/master/amq/example01_publisher_listener/publisher.py</a></td></tr>
<tr><td>1</td><td>subscriber.py</td><td>příjemce zpráv posílaných se strategií PUB-SUB</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amq/example01_publisher_listener/subscriber.py">https://github.com/tisnik/message-queues-examples/blob/master/amq/example01_publisher_listener/subscriber.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>2</td><td>publisher.py</td><td>zdroj zpráv posílaných se strategií PUSH-PULL</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amq/example02_publisher_listener_queue/publisher.py">https://github.com/tisnik/message-queues-examples/blob/master/amq/example02_publisher_listener_queue/publisher.py</a></td></tr>
<tr><td>2</td><td>subscriber.py</td><td>příjemce zpráv posílaných se strategií PUSH-PULL</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amq/example02_publisher_listener_queue/subscriber.py">https://github.com/tisnik/message-queues-examples/blob/master/amq/example02_publisher_listener_queue/subscriber.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>publisher.py</td><td>obdoba prvního příkladu, ovšem samotné připojení k&nbsp;message brokerovi se realizuje jednodušeji</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amq/example03_simple_connection_call/publisher.py">https://github.com/tisnik/message-queues-examples/blob/master/amq/example03_simple_connection_call/publisher.py</a></td></tr>
<tr><td>3</td><td>subscriber.py</td><td>obdoba prvního příkladu, ovšem samotné připojení k&nbsp;message brokerovi se realizuje jednodušeji</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amq/example03_simple_connection_call/subscriber.py">https://github.com/tisnik/message-queues-examples/blob/master/amq/example03_simple_connection_call/subscriber.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td>publisher.py</td><td>obdoba druhého příkladu, ovšem samotné připojení k&nbsp;message brokerovi se realizuje jednodušeji</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amq/example04_publisher_listener_queue_simple_connection_call/publisher.py">https://github.com/tisnik/message-queues-examples/blob/master/amq/example04_publisher_listener_queue_simple_connection_call/publisher.py</a></td></tr>
<tr><td>4</td><td>subscriber.py</td><td>obdoba druhého příkladu, ovšem samotné připojení k&nbsp;message brokerovi se realizuje jednodušeji</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amq/example04_publisher_listener_queue_simple_connection_call/subscriber.py">https://github.com/tisnik/message-queues-examples/blob/master/amq/example04_publisher_listener_queue_simple_connection_call/subscriber.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>publisher.py</td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amq/example05_ack/publisher.py">https://github.com/tisnik/message-queues-examples/blob/master/amq/example05_ack/publisher.py</a></td></tr>
<tr><td>5</td><td>subscriber.py</td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amq/example05_ack/subscriber.py">https://github.com/tisnik/message-queues-examples/blob/master/amq/example05_ack/subscriber.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>6</td><td>publisher.py</td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amq/example06_nack/publisher.py">https://github.com/tisnik/message-queues-examples/blob/master/amq/example06_nack/publisher.py</a></td></tr>
<tr><td>6</td><td>subscriber.py</td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amq/example06_nack/subscriber.py">https://github.com/tisnik/message-queues-examples/blob/master/amq/example06_nack/subscriber.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>publisher.py</td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amq/example07_queue/publisher.py">https://github.com/tisnik/message-queues-examples/blob/master/amq/example07_queue/publisher.py</a></td></tr>
<tr><td>7</td><td>subscriber.py</td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amq/example07_queue/subscriber.py">https://github.com/tisnik/message-queues-examples/blob/master/amq/example07_queue/subscriber.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>8</td><td>publisher.py</td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amq/example08_pub_sub_no_transactions/publisher.py">https://github.com/tisnik/message-queues-examples/blob/master/amq/example08_pub_sub_no_transactions/publisher.py</a></td></tr>
<tr><td>8</td><td>subscriber.py</td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amq/example08_pub_sub_no_transactions/subscriber.py">https://github.com/tisnik/message-queues-examples/blob/master/amq/example08_pub_sub_no_transactions/subscriber.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>9</td><td>publisher.py</td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amq/example09_pub_sub_transactions/publisher.py">https://github.com/tisnik/message-queues-examples/blob/master/amq/example09_pub_sub_transactions/publisher.py</a></td></tr>
<tr><td>9</td><td>subscriber.py</td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amq/example09_pub_sub_transactions/subscriber.py">https://github.com/tisnik/message-queues-examples/blob/master/amq/example09_pub_sub_transactions/subscriber.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amq/example04_publisher_listener_queue_simple_connection_call/publisher.py">https://github.com/tisnik/message-queues-examples/blob/master/amq/example04_publisher_listener_queue_simple_connection_call/publisher.py</a></td></tr>
<tr><td>4</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amq/example04_publisher_listener_queue_simple_connection_call/subscriber.py">https://github.com/tisnik/message-queues-examples/blob/master/amq/example04_publisher_listener_queue_simple_connection_call/subscriber.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amq/example05_">https://github.com/tisnik/message-queues-examples/blob/master/amq/example05_</a></td></tr>
<tr><td>5</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amq/example05_">https://github.com/tisnik/message-queues-examples/blob/master/amq/example05_</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>6</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amq/example06_">https://github.com/tisnik/message-queues-examples/blob/master/amq/example06_</a></td></tr>
<tr><td>6</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amq/example06_">https://github.com/tisnik/message-queues-examples/blob/master/amq/example06_</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amq/example07_">https://github.com/tisnik/message-queues-examples/blob/master/amq/example07_</a></td></tr>
<tr><td>7</td><td></td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amq/example07_">https://github.com/tisnik/message-queues-examples/blob/master/amq/example07_</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>14</td><td>publisher.py</td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amq/example14_binary_messages/publisher.py">https://github.com/tisnik/message-queues-examples/blob/master/amq/example14_binary_messages/publisher.py</a></td></tr>
<tr><td>14</td><td>subscriber.py</td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amq/example14_binary_messages/subscriber.py">https://github.com/tisnik/message-queues-examples/blob/master/amq/example14_binary_messages/subscriber.py</a></td></tr>
<tr><td>14</td><td>get_image</td><td></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/amq/example14_binary_messages/get_image">https://github.com/tisnik/message-queues-examples/blob/master/amq/example14_binary_messages/get_image</a></td></tr>
</table>



<p><div class="rs-tip-major">Poznámka: v&nbsp;tabulce jsou pro úplnost vypsány
i dva příklady, s&nbsp;nimiž jsme se seznámili v&nbsp;předchozí části tohoto
seriálu.</div></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na předchozí části seriálu</h2>

<p>V&nbsp;této kapitole jsou uvedeny odkazy na všech deset předchozích částí
seriálu, v&nbsp;němž se zabýváme různými způsoby implementace front zpráv a
k&nbsp;nim přidružených technologií:</p>

<ol>

<li>Použití nástroje RQ (Redis Queue) pro správu úloh zpracovávaných na pozadí<br />
<a href="https://www.root.cz/clanky/pouziti-nastroje-rq-redis-queue-pro-spravu-uloh-zpracovavanych-na-pozadi/">https://www.root.cz/clanky/pouziti-nastroje-rq-redis-queue-pro-spravu-uloh-zpracovavanych-na-pozadi/</a>
</li>

<li>Celery: systém implementující asynchronní fronty úloh pro Python<br />
<a href="https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python/">https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python/</a>
</li>

<li>Celery: systém implementující asynchronní fronty úloh pro Python (dokončení)<br />
<a href="https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python-dokonceni/">https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python-dokonceni/</a>
</li>

<li>RabbitMQ: jedna z nejúspěšnějších implementací brokera<br />
<a href="https://www.root.cz/clanky/rabbitmq-jedna-z-nejuspesnejsich-implementaci-brokera/">https://www.root.cz/clanky/rabbitmq-jedna-z-nejuspesnejsich-implementaci-brokera/</a>
</li>

<li>Pokročilejší operace nabízené systémem RabbitMQ<br />
<a href="https://www.root.cz/clanky/pokrocilejsi-operace-nabizene-systemem-rabbitmq/">https://www.root.cz/clanky/pokrocilejsi-operace-nabizene-systemem-rabbitmq/</a>
</li>

<li>ØMQ: knihovna pro asynchronní předávání zpráv<br />
<a href="https://www.root.cz/clanky/0mq-knihovna-pro-asynchronni-predavani-zprav/">https://www.root.cz/clanky/0mq-knihovna-pro-asynchronni-predavani-zprav/</a>
</li>

<li>Další možnosti poskytované knihovnou ØMQ<br />
<a href="https://www.root.cz/clanky/dalsi-moznosti-poskytovane-knihovnou-mq/">https://www.root.cz/clanky/dalsi-moznosti-poskytovane-knihovnou-mq/</a>
</li>

<li>Další možnosti nabízené knihovnou ØMQ, implementace protokolů ØMQ v čisté Javě<br />
<a href="https://www.root.cz/clanky/dalsi-moznosti-nabizene-knihovnou-mq-implementace-protokolu-mq-v-ciste-jave/">https://www.root.cz/clanky/dalsi-moznosti-nabizene-knihovnou-mq-implementace-protokolu-mq-v-ciste-jave/</a>
</li>

<li>Apache ActiveMQ – další systém implementující message brokera<br />
<a href="https://www.root.cz/clanky/apache-activemq-dalsi-system-implementujici-message-brokera/">https://www.root.cz/clanky/apache-activemq-dalsi-system-implementujici-message-brokera/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Apache ActiveMQ<br />
<a href="http://activemq.apache.org/">http://activemq.apache.org/</a>
</li>

<li>Apache ActiveMQ Artemis<br />
<a href="https://activemq.apache.org/artemis/">https://activemq.apache.org/artemis/</a>
</li>

<li>Apache ActiveMQ Artemis User Manual<br />
<a href="https://activemq.apache.org/artemis/docs/latest/index.html">https://activemq.apache.org/artemis/docs/latest/index.html</a>
</li>

<li>KahaDB<br />
<a href="http://activemq.apache.org/kahadb.html">http://activemq.apache.org/kahadb.html</a>
</li>

<li>Understanding the KahaDB Message Store<br />
<a href="https://access.redhat.com/documentation/en-US/Fuse_MQ_Enterprise/7.1/html/Configuring_Broker_Persistence/files/KahaDBOverview.html">https://access.redhat.com/documentation/en-US/Fuse_MQ_Enterprise/7.1/html/Configuring_Broker_Persistence/files/KahaDBOverview.html</a>
</li>

<li>Command Line Tools (Apache ActiveMQ)<br />
<a href="https://activemq.apache.org/activemq-command-line-tools-reference.html">https://activemq.apache.org/activemq-command-line-tools-reference.html</a>
</li>

<li>stomp.py 4.1.21 na PyPi<br />
<a href="https://pypi.org/project/stomp.py/">https://pypi.org/project/stomp.py/</a>
</li>

<li>Stomp Tutorial<br />
<a href="https://access.redhat.com/documentation/en-US/Fuse_Message_Broker/5.5/html/Connectivity_Guide/files/FMBConnectivityStompTelnet.html">https://access.redhat.com/documentation/en-US/Fuse_Message_Broker/5.5/html/Connectivity_Guide/files/FMBConnectivityStompTelnet.html</a>
</li>

<li>Heartbeat (computing)<br />
<a href="https://en.wikipedia.org/wiki/Heartbeat_(computing)">https://en.wikipedia.org/wiki/Heartbeat_(computing)</a>
</li>

<li>Apache Camel<br />
<a href="https://camel.apache.org/">https://camel.apache.org/</a>
</li>

<li>Red Hat Fuse<br />
<a href="https://developers.redhat.com/products/fuse/overview/">https://developers.redhat.com/products/fuse/overview/</a>
</li>

<li>Confusion between ActiveMQ and ActiveMQ-Artemis?<br />
<a href="https://serverfault.com/questions/873533/confusion-between-activemq-and-activemq-artemis">https://serverfault.com/questions/873533/confusion-between-activemq-and-activemq-artemis</a>
</li>

<li>Staré stránky projektu HornetQ<br />
<a href="http://hornetq.jboss.org/">http://hornetq.jboss.org/</a>
</li>

<li>Snapshot JeroMQ verze 0.4.4<br />
<a href="https://oss.sonatype.org/content/repositories/snapshots/org/zeromq/jeromq/0.4.4-SNAPSHOT/">https://oss.sonatype.org/content/repositories/snapshots/org/zeromq/jeromq/0.4.4-SNAPSHOT/</a>
</li>

<li>Difference between ActiveMQ vs Apache ActiveMQ Artemis<br />
<a href="http://activemq.2283324.n4.nabble.com/Difference-between-ActiveMQ-vs-Apache-ActiveMQ-Artemis-td4703828.html">http://activemq.2283324.n4.nabble.com/Difference-between-ActiveMQ-vs-Apache-ActiveMQ-Artemis-td4703828.html</a>
</li>

<li>Microservices communications. Why you should switch to message queues<br />
<a href="https://dev.to/matteojoliveau/microservices-communications-why-you-should-switch-to-message-queues--48ia">https://dev.to/matteojoliveau/microservices-communications-why-you-should-switch-to-message-queues--48ia</a>
</li>

<li>Stomp.py 4.1.19 documentation<br />
<a href="https://stomppy.readthedocs.io/en/stable/">https://stomppy.readthedocs.io/en/stable/</a>
</li>

<li>Repositář knihovny JeroMQ<br />
<a href="https://github.com/zeromq/jeromq/">https://github.com/zeromq/jeromq/</a>
</li>

<li>ØMQ &ndash; Distributed Messaging <br />
<a href="http://zeromq.org/">http://zeromq.org/</a>
</li>

<li>ØMQ Community<br />
<a href="http://zeromq.org/community">http://zeromq.org/community</a>
</li>

<li>Get The Software<br />
<a href="http://zeromq.org/intro:get-the-software">http://zeromq.org/intro:get-the-software</a>
</li>

<li>PyZMQ Documentation<br />
<a href="https://pyzmq.readthedocs.io/en/latest/">https://pyzmq.readthedocs.io/en/latest/</a>
</li>

<li>Module: zmq.decorators<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.decorators.html">https://pyzmq.readthedocs.io/en/latest/api/zmq.decorators.html</a>
</li>

<li>ZeroMQ is the answer, by Ian Barber<br />
<a href="https://vimeo.com/20605470">https://vimeo.com/20605470</a>
</li>

<li>ZeroMQ RFC<br />
<a href="https://rfc.zeromq.org/">https://rfc.zeromq.org/</a>
</li>

<li>ZeroMQ and Clojure, a brief introduction<br />
<a href="https://antoniogarrote.wordpress.com/2010/09/08/zeromq-and-clojure-a-brief-introduction/">https://antoniogarrote.wordpress.com/2010/09/08/zeromq-and-clojure-a-brief-introduction/</a>
</li>

<li>zeromq/czmq<br />
<a href="https://github.com/zeromq/czmq">https://github.com/zeromq/czmq</a>
</li>

<li>golang wrapper for CZMQ<br />
<a href="https://github.com/zeromq/goczmq">https://github.com/zeromq/goczmq</a>
</li>

<li>ZeroMQ version reporting in Python<br />
<a href="http://zguide.zeromq.org/py:version">http://zguide.zeromq.org/py:version</a>
</li>

<li>A Go interface to ZeroMQ version 4<br />
<a href="https://github.com/pebbe/zmq4">https://github.com/pebbe/zmq4</a>
</li>

<li>Broker vs. Brokerless<br />
<a href="http://zeromq.org/whitepapers:brokerless">http://zeromq.org/whitepapers:brokerless</a>
</li>

<li>Learning ØMQ with pyzmq<br />
<a href="https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/">https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/</a>
</li>

<li>Céčková funkce <strong>zmq_ctx_new</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-ctx-new">http://api.zeromq.org/4-2:zmq-ctx-new</a>
</li>

<li>Céčková funkce <strong>zmq_ctx_destroy</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-ctx-destroy">http://api.zeromq.org/4-2:zmq-ctx-destroy</a>
</li>

<li>Céčková funkce <strong>zmq_bind</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-bind">http://api.zeromq.org/4-2:zmq-bind</a>
</li>

<li>Céčková funkce <strong>zmq_unbind</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-unbind">http://api.zeromq.org/4-2:zmq-unbind</a>
</li>

<li>Céčková C funkce <strong>zmq_connect</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-connect">http://api.zeromq.org/4-2:zmq-connect</a>
</li>

<li>Céčková C funkce <strong>zmq_disconnect</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-disconnect">http://api.zeromq.org/4-2:zmq-disconnect</a>
</li>

<li>Céčková C funkce <strong>zmq_send</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-send">http://api.zeromq.org/4-2:zmq-send</a>
</li>

<li>Céčková C funkce <strong>zmq_recv</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-recv">http://api.zeromq.org/4-2:zmq-recv</a>
</li>

<li>Třída <strong>Context</strong> (Python)<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.html#context">https://pyzmq.readthedocs.io/en/latest/api/zmq.html#context</a>
</li>

<li>Třída <strong>Socket</strong> (Python)<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.html#socket">https://pyzmq.readthedocs.io/en/latest/api/zmq.html#socket</a>
</li>

<li>Python binding<br />
<a href="http://zeromq.org/bindings:python">http://zeromq.org/bindings:python</a>
</li>

<li>Why should I have written ZeroMQ in C, not C++ (part I)<br />
<a href="http://250bpm.com/blog:4">http://250bpm.com/blog:4</a>
</li>

<li>Why should I have written ZeroMQ in C, not C++ (part II) <br />
<a href="http://250bpm.com/blog:8">http://250bpm.com/blog:8</a>
</li>

<li>About Nanomsg<br />
<a href="https://nanomsg.org/">https://nanomsg.org/</a>
</li>

<li>Advanced Message Queuing Protocol<br />
<a href="https://www.amqp.org/">https://www.amqp.org/</a>
</li>

<li>Advanced Message Queuing Protocol na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol">https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol</a>
</li>

<li>Dokumentace k&nbsp;příkazu <strong>rabbitmqctl</strong><br />
<a href="https://www.rabbitmq.com/rabbitmqctl.8.html">https://www.rabbitmq.com/rabbitmqctl.8.html</a>
</li>

<li>RabbitMQ<br />
<a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a>
</li>

<li>RabbitMQ Tutorials<br />
<a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a>
</li>

<li>RabbitMQ: Clients and Developer Tools<br />
<a href="https://www.rabbitmq.com/devtools.html">https://www.rabbitmq.com/devtools.html</a>
</li>

<li>RabbitMQ na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/RabbitMQ">https://en.wikipedia.org/wiki/RabbitMQ</a>
</li>

<li>Streaming Text Oriented Messaging Protocol<br />
<a href="https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol">https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol</a>
</li>

<li>Message Queuing Telemetry Transport<br />
<a href="https://en.wikipedia.org/wiki/MQTT">https://en.wikipedia.org/wiki/MQTT</a>
</li>

<li>Erlang<br />
<a href="http://www.erlang.org/">http://www.erlang.org/</a>
</li>

<li>pika 0.12.0 na PyPi<br />
<a href="https://pypi.org/project/pika/">https://pypi.org/project/pika/</a>
</li>

<li>Introduction to Pika<br />
<a href="https://pika.readthedocs.io/en/stable/">https://pika.readthedocs.io/en/stable/</a>
</li>

<li>Langohr: An idiomatic Clojure client for RabbitMQ that embraces the AMQP 0.9.1 model<br />
<a href="http://clojurerabbitmq.info/">http://clojurerabbitmq.info/</a>
</li>

<li>AMQP 0-9-1 Model Explained<br />
<a href="http://www.rabbitmq.com/tutorials/amqp-concepts.html">http://www.rabbitmq.com/tutorials/amqp-concepts.html</a>
</li>

<li>Part 1: RabbitMQ for beginners - What is RabbitMQ?<br />
<a href="https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html">https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html</a>
</li>

<li>Downloading and Installing RabbitMQ<br />
<a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a>
</li>

<li>celery na PyPi<br />
<a href="https://pypi.org/project/celery/">https://pypi.org/project/celery/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python <br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python (dokončení)<br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/</a>
</li>

<li>Redis Queue (RQ)<br />
<a href="https://www.fullstackpython.com/redis-queue-rq.html">https://www.fullstackpython.com/redis-queue-rq.html</a>
</li>

<li>Python Celery &amp; RabbitMQ Tutorial<br />
<a href="https://tests4geeks.com/python-celery-rabbitmq-tutorial/">https://tests4geeks.com/python-celery-rabbitmq-tutorial/</a>
</li>

<li>Flower: Real-time Celery web-monitor<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor">http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor</a>
</li>

<li>Asynchronous Tasks With Django and Celery<br />
<a href="https://realpython.com/asynchronous-tasks-with-django-and-celery/">https://realpython.com/asynchronous-tasks-with-django-and-celery/</a>
</li>

<li>First Steps with Celery<br />
<a href="http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html">http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html</a>
</li>

<li>node-celery<br />
<a href="https://github.com/mher/node-celery">https://github.com/mher/node-celery</a>
</li>

<li>Full Stack Python: web development<br />
<a href="https://www.fullstackpython.com/web-development.html">https://www.fullstackpython.com/web-development.html</a>
</li>

<li>Introducing RQ<br />
<a href="https://nvie.com/posts/introducing-rq/">https://nvie.com/posts/introducing-rq/</a>
</li>

<li>Asynchronous Tasks with Flask and Redis Queue<br />
<a href="https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue">https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Stránky projektu Redis<br />
<a href="https://redis.io/">https://redis.io/</a>
</li>

<li>Introduction to Redis<br />
<a href="https://redis.io/topics/introduction">https://redis.io/topics/introduction</a>
</li>

<li>Try Redis<br />
<a href="http://try.redis.io/">http://try.redis.io/</a>
</li>

<li>Redis tutorial, April 2010 (starší, ale pěkně udělaný)<br />
<a href="https://static.simonwillison.net/static/2010/redis-tutorial/">https://static.simonwillison.net/static/2010/redis-tutorial/</a>
</li>

<li>Python Redis<br />
<a href="https://redislabs.com/lp/python-redis/">https://redislabs.com/lp/python-redis/</a>
</li>

<li>Redis: key-value databáze v paměti i na disku<br />
<a href="https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/">https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/</a>
</li>

<li>Praktický úvod do Redis (1): vaše distribuovaná NoSQL cache<br />
<a href="http://www.cloudsvet.cz/?p=253">http://www.cloudsvet.cz/?p=253</a>
</li>

<li>Praktický úvod do Redis (2): transakce<br />
<a href="http://www.cloudsvet.cz/?p=256">http://www.cloudsvet.cz/?p=256</a>
</li>

<li>Praktický úvod do Redis (3): cluster<br />
<a href="http://www.cloudsvet.cz/?p=258">http://www.cloudsvet.cz/?p=258</a>
</li>

<li>Connection pool<br />
<a href="https://en.wikipedia.org/wiki/Connection_pool">https://en.wikipedia.org/wiki/Connection_pool</a>
</li>

<li>Instant Redis Sentinel Setup<br />
<a href="https://github.com/ServiceStack/redis-config">https://github.com/ServiceStack/redis-config</a>
</li>

<li>How to install REDIS in LInux<br />
<a href="https://linuxtechlab.com/how-install-redis-server-linux/">https://linuxtechlab.com/how-install-redis-server-linux/</a>
</li>

<li>Redis RDB Dump File Format<br />
<a href="https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format">https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format</a>
</li>

<li>Lempel–Ziv–Welch<br />
<a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch">https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch</a>
</li>

<li>Redis Persistence<br />
<a href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a>
</li>

<li>Redis persistence demystified<br />
<a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html">http://oldblog.antirez.com/post/redis-persistence-demystified.html</a>
</li>

<li>Redis reliable queues with Lua scripting<br />
<a href="http://oldblog.antirez.com/post/250">http://oldblog.antirez.com/post/250</a>
</li>

<li>Ost (knihovna)<br />
<a href="https://github.com/soveran/ost">https://github.com/soveran/ost</a>
</li>

<li>NoSQL<br />
<a href="https://en.wikipedia.org/wiki/NoSQL">https://en.wikipedia.org/wiki/NoSQL</a>
</li>

<li>Shard (database architecture)<br />
<a href="https://en.wikipedia.org/wiki/Shard_%28database_architecture%29">https://en.wikipedia.org/wiki/Shard_%28database_architecture%29</a>
</li>

<li>What is sharding and why is it important?<br />
<a href="https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important">https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important</a>
</li>

<li>What Is Sharding?<br />
<a href="https://btcmanager.com/what-sharding/">https://btcmanager.com/what-sharding/</a>
</li>

<li>Redis clients<br />
<a href="https://redis.io/clients">https://redis.io/clients</a>
</li>

<li>Category:Lua-scriptable software<br />
<a href="https://en.wikipedia.org/wiki/Category:Lua-scriptable_software">https://en.wikipedia.org/wiki/Category:Lua-scriptable_software</a>
</li>

<li>Seriál Programovací jazyk Lua<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-lua/">https://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>Redis memory usage<br />
<a href="http://nosql.mypopescu.com/post/1010844204/redis-memory-usage">http://nosql.mypopescu.com/post/1010844204/redis-memory-usage</a>
</li>

<li>Ukázka konfigurace Redisu pro lokální testování<br />
<a href="https://github.com/tisnik/presentations/blob/master/redis/redis.conf">https://github.com/tisnik/presentations/blob/master/redis/redis.conf</a>
</li>

<li>Resque<br />
<a href="https://github.com/resque/resque">https://github.com/resque/resque</a>
</li>

<li>Nested transaction<br />
<a href="https://en.wikipedia.org/wiki/Nested_transaction">https://en.wikipedia.org/wiki/Nested_transaction</a>
</li>

<li>Publish–subscribe pattern<br />
<a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern</a>
</li>

<li>Messaging pattern<br />
<a href="https://en.wikipedia.org/wiki/Messaging_pattern">https://en.wikipedia.org/wiki/Messaging_pattern</a>
</li>

<li>Using pipelining to speedup Redis queries<br />
<a href="https://redis.io/topics/pipelining">https://redis.io/topics/pipelining</a>
</li>

<li>Pub/Sub<br />
<a href="https://redis.io/topics/pubsub">https://redis.io/topics/pubsub</a>
</li>

<li>ZeroMQ distributed messaging<br />
<a href="http://zeromq.org/">http://zeromq.org/</a>
</li>

<li>ZeroMQ: Modern &amp; Fast Networking Stack<br />
<a href="https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/">https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/</a>
</li>

<li>Publish/Subscribe paradigm: Why must message classes not know about their subscribers?<br />
<a href="https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr">https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr</a>
</li>

<li>Python &amp; Redis PUB/SUB<br />
<a href="https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7">https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7</a>
</li>

<li>Message broker<br />
<a href="https://en.wikipedia.org/wiki/Message_broker">https://en.wikipedia.org/wiki/Message_broker</a>
</li>

<li>RESP Arrays<br />
<a href="https://redis.io/topics/protocol#array-reply">https://redis.io/topics/protocol#array-reply</a>
</li>

<li>Redis Protocol specification<br />
<a href="https://redis.io/topics/protocol">https://redis.io/topics/protocol</a>
</li>

<li>Redis Pub/Sub: Intro Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-intro/">https://www.redisgreen.net/blog/pubsub-intro/</a>
</li>

<li>Redis Pub/Sub: Howto Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-howto/">https://www.redisgreen.net/blog/pubsub-howto/</a>
</li>

<li>Comparing Publish-Subscribe Messaging and Message Queuing<br />
<a href="https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message">https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message</a>
</li>

<li>Apache Kafka<br />
<a href="https://kafka.apache.org/">https://kafka.apache.org/</a>
</li>

<li>Iron<br />
<a href="http://www.iron.io/mq">http://www.iron.io/mq</a>
</li>

<li>kue (založeno na Redisu, určeno pro node.js)<br />
<a href="https://github.com/Automattic/kue">https://github.com/Automattic/kue</a>
</li>

<li>Cloud Pub/Sub<br />
<a href="https://cloud.google.com/pubsub/">https://cloud.google.com/pubsub/</a>
</li>

<li>Introduction to Redis Streams<br />
<a href="https://redis.io/topics/streams-intro">https://redis.io/topics/streams-intro</a>
</li>

<li>glob (programming)<br />
<a href="https://en.wikipedia.org/wiki/Glob_(programming)">https://en.wikipedia.org/wiki/Glob_(programming)</a>
</li>

<li>Why and how Pricing Assistant migrated from Celery to RQ - Paris.py<br />
<a href="https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2">https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2</a>
</li>

<li>Enqueueing internals<br />
<a href="http://python-rq.org/contrib/">http://python-rq.org/contrib/</a>
</li>

<li>queue — A synchronized queue class<br />
<a href="https://docs.python.org/3/library/queue.html">https://docs.python.org/3/library/queue.html</a>
</li>

<li>Queue – A thread-safe FIFO implementation<br />
<a href="https://pymotw.com/2/Queue/">https://pymotw.com/2/Queue/</a>
</li>

<li>Queues<br />
<a href="http://queues.io/">http://queues.io/</a>
</li>

<li>Windows Subsystem for Linux Documentation<br />
<a href="https://docs.microsoft.com/en-us/windows/wsl/about">https://docs.microsoft.com/en-us/windows/wsl/about</a>
</li>

<li>RestMQ<br />
<a href="http://restmq.com/">http://restmq.com/</a>
</li>

<li>ActiveMQ<br />
<a href="http://activemq.apache.org/">http://activemq.apache.org/</a>
</li>

<li>Amazon MQ<br />
<a href="https://aws.amazon.com/amazon-mq/">https://aws.amazon.com/amazon-mq/</a>
</li>

<li>Amazon Simple Queue Service<br />
<a href="https://aws.amazon.com/sqs/">https://aws.amazon.com/sqs/</a>
</li>

<li>Celery: Distributed Task Queue<br />
<a href="http://www.celeryproject.org/">http://www.celeryproject.org/</a>
</li>

<li>Disque, an in-memory, distributed job queue<br />
<a href="https://github.com/antirez/disque">https://github.com/antirez/disque</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Projekt RQ na PyPi<br />
<a href="https://pypi.org/project/rq/">https://pypi.org/project/rq/</a>
</li>

<li>rq-dashboard 0.3.12<br />
<a href="https://pypi.org/project/rq-dashboard/">https://pypi.org/project/rq-dashboard/</a>
</li>

<li>Job queue<br />
<a href="https://en.wikipedia.org/wiki/Job_queue">https://en.wikipedia.org/wiki/Job_queue</a>
</li>

<li>Why we moved from Celery to RQ<br />
<a href="https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq">https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq</a>
</li>

<li>Running multiple workers using Celery<br />
<a href="https://serverfault.com/questions/655387/running-multiple-workers-using-celery">https://serverfault.com/questions/655387/running-multiple-workers-using-celery</a>
</li>

<li>celery — Distributed processing<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.html">http://docs.celeryproject.org/en/latest/reference/celery.html</a>
</li>

<li>Chains<br />
<a href="https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains">https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains</a>
</li>

<li>Routing<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing">http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing</a>
</li>

<li>Celery Distributed Task Queue in Go<br />
<a href="https://github.com/gocelery/gocelery/">https://github.com/gocelery/gocelery/</a>
</li>

<li>Python Decorators<br />
<a href="https://wiki.python.org/moin/PythonDecorators">https://wiki.python.org/moin/PythonDecorators</a>
</li>

<li>Periodic Tasks<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html">http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html</a>
</li>

<li>celery.schedules<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab">http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab</a>
</li>

<li>Pros and cons to use Celery vs. RQ<br />
<a href="https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq">https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq</a>
</li>

<li>Priority queue<br />
<a href="https://en.wikipedia.org/wiki/Priority_queue">https://en.wikipedia.org/wiki/Priority_queue</a>
</li>

<li>Jupyter<br />
<a href="https://jupyter.org/">https://jupyter.org/</a>
</li>

<li>How IPython and Jupyter Notebook work<br />
<a href="https://jupyter.readthedocs.io/en/latest/architecture/how_jupyter_ipython_work.html">https://jupyter.readthedocs.io/en/latest/architecture/how_jupyter_ipython_work.html</a>
</li>

<li>Context Managers<br />
<a href="http://book.pythontips.com/en/latest/context_managers.html">http://book.pythontips.com/en/latest/context_managers.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

