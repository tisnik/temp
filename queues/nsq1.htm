<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Nsq - systém pro doručování zpráv bez centrálního message brokera</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V další části seriálu (nejenom) o message brokerech se seznámíme se systémem zpráv nazvaným NSQ. Tento nástroj, který je mimochodem vyvinut v jazyce Go, je založen na myšlence decentralizace a navíc takovým způsobem, aby neobsahoval takový uzel, jehož pádem by přestalo doručování zpráv fungovat.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Systém nsq se představuje</a></p>
<p><a href="#k02">2. Architektura systému nsq</a></p>
<p><a href="#k03">3. Doručení zprávy konzumentům</a></p>
<p><a href="#k04">4. Překlad  a instalace systému <i>nsq</i></a></p>
<p><a href="#k05">5. Instalace knihoven používaných klienty</a></p>
<p><a href="#k06">6. Spuštění jednotlivých uzlů systému <i>nsq</i></a></p>
<p><a href="#k07">7. Používané porty</a></p>
<p><a href="#k08">8. Poslání zprávy přes REST API</a></p>
<p><a href="#k09">9. Komunikace s&nbsp;uzlem <i>nsqlookupd</i> přes REST API</a></p>
<p><a href="#k10">10. Jednoduchý producent zpráv naprogramovaný v&nbsp;Pythonu</a></p>
<p><a href="#k11">11. Konzument zpráv naprogramovaný v&nbsp;Pythonu</a></p>
<p><a href="#k12">12. Použití systému <i>nsq</i> klienty naprogramovanými v&nbsp;Go</a></p>
<p><a href="#k13">13. Producent zpráv naprogramovaný v&nbsp;jazyce Go</a></p>
<p><a href="#k14">14. Využití bloku <strong>defer</strong> pro ukončení producenta zpráv</a></p>
<p><a href="#k15">15. Jednoduchý konzument zpráv používající synchronizaci pro ukončení gorutiny s&nbsp;příjemcem</a></p>
<p><a href="#k16">16. Použití kanálu ve funkci synchronizační struktury</a></p>
<p><a href="#k17">17. Připojení klienta ke službě <i>nsqlookupd</i></a></p>
<p><a href="#k18">18. Obsah následující části seriálu</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Systém nsq se představuje</h2>

<p><a href="https://www.root.cz/serialy/message-brokery/">V&nbsp;seriálu o
message brokerech</a> jsme se seznámili již s&nbsp;mnoha typy message brokerů,
implementací front zpráv, komunikačních strategií typu PUB-SUB atd. Již dříve
popsané systémy byly vytvořeny v&nbsp;různých programovacích jazycích,
například populární message broker <a
href="https://www.root.cz/clanky/rabbitmq-jedna-z-nejuspesnejsich-implementaci-brokera/">RabbitMQ</a>
v&nbsp;Erlangu, <a
href="https://www.root.cz/clanky/pouziti-nastroje-rq-redis-queue-pro-spravu-uloh-zpracovavanych-na-pozadi/">RQ</a>
(Redis Queue) v&nbsp;Pythonu (samotný Redis v&nbsp;jazyku C), <a
href="https://www.root.cz/clanky/0mq-knihovna-pro-asynchronni-predavani-zprav/">ZeroMQ</a>
v&nbsp;C++, <a
href="https://www.root.cz/clanky/implementace-ruznych-komunikacnich-strategii-s-vyuzitim-knihovny-nanomsg/">nanomsg</a>
v&nbsp;C, <a
href="https://www.root.cz/clanky/apache-activemq-dalsi-system-implementujici-message-brokera/">AMQ
a Artemis</a> v&nbsp;Javě a konečně systém <a
href="https://www.root.cz/clanky/pouziti-message-brokeru-nats/">NATS</a> <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">v&nbsp;programovacím
jazyce Go</a>. V&nbsp;Go je vytvořen i dnes popisovaný nástroj <i>nsq</i>,
který se skládá z&nbsp;několika samostatně spouštěných uzlů, které mezi sebou
vhodným způsobem komunikují. Výhodou a jednou ze základních vlastností
<i>nsq</i> je fakt, že způsob jeho návrhu počítá s&nbsp;tím, že jednotlivé uzly
mohou být po nějakou dobu nedostupné a přitom systém jako celek by měl být
stále použitelný. Jedná se tedy o architekturu vhodnou pro nasazení do dnešního
hybridní prostředí se systémy běžícími v&nbsp;cloudu, lokálně
v&nbsp;kontejneru, na dedikovaných serverech atd. Základní vlastnosti
<i>nsq</i> naleznete na stránce <a
href="https://nsq.io/overview/features_and_guarantees.html">https://nsq.io/overview/features_and_guarantees.html</a>,
my se s&nbsp;jednotlivými body seznámíme postupně.</p>

<img src="https://i.iinfo.cz/images/133/nsq1-1.png" class="image-395060" alt="&#160;" width="311" height="146" />
<p><i>Obrázek 1: Logo systému nsq.</i></p>

<p>Za vznikem a vývojem systému <i>nsq</i> stojí programátoři
z&nbsp;<i>bitly</i> (<a href="https://bitly.com/">https://bitly.com/</a>),
kteří mají s&nbsp;podobnými systémy dlouholeté zkušenosti. Za zmínku stojí
především jejich projekt <a
href="https://github.com/bitly/simplehttp">simplehttp</a>, v&nbsp;němž jsou
fronty zpráv i komunikační strategie PUB-SUB implementovány, konkrétně ve
zdrojových souborech <a
href="https://github.com/bitly/simplehttp/blob/master/simplequeue/simplequeue.c">simplequeue.c</a>
a <a
href="https://github.com/bitly/simplehttp/blob/master/pubsub/pubsub.c">pubsub.c</a>.
Zkušenosti s&nbsp;programováním v&nbsp;Go mají poměrně dlouhodobé, například
známý blog post o použití tohoto jazyka <a
href="https://word.bitly.com/post/29550171827/go-go-gadget">Go Go Gadget</a>
byl publikován již před pěti lety.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Architektura systému nsq</h2>

<p>Základním úkolem systému <i>nsq</i> je zajištění doručení zpráv od
producentů ke konzumentům, a to pochopitelně bez toho, aby spolu producenti a
konzumenti museli komunikovat přímo (popř.&nbsp;aniž by o sobě vůbec věděli
&ndash; takové pevné spojení částí systému bývá příliš rigidní a více náchylné
k&nbsp;poruchám). Systém má taktéž umožnit škálování, tj.&nbsp;typicky použití
většího množství konzumentů pro určité typy zpráv (rozlišených podle svého
tématu &ndash; <i>topic</i>). Navíc musí systém umožnit, aby byly zprávy
uchovány (ve frontách) ve chvíli, kdy není žádný konzument schopný zprávy
přečíst a zpracovat (ideálně se zajištěním perzistence zpráv). Tradičně jsou
tyto požadavky vyřešeny klasickým message brokerem, což bývá (jediný) proces
s&nbsp;několika frontami zpráv, přičemž každá fronta je určena pro přeposílání
zpráv patřících k&nbsp;jednomu tématu. Message broker navíc bývá doplněn i o
možnost posílat zprávy s&nbsp;využitím komunikační strategie PUB-SUB, tedy všem
konzumentům, kteří dané téma odebírají a současně jsou v&nbsp;daný okamžik
připojeni a schopni přijmu zpráv.</p>

<a href="https://www.root.cz/obrazek/348765/"><img src="https://i.iinfo.cz/images/176/rabbitmq1-4-prev.png" class="image-348765" alt="&#160;" width="370" height="158" /></a>
<p><i>Obrázek 2: Interní konfigurovatelná struktura systému RabbitMQ, který se v&nbsp;některých ohledech podobá dnes popisovanému systému nsq.</i></p>

<p>Systém <i>nsq</i> je oproti klasickým message brokerům navržen nepatrně
odlišným způsobem, protože obsahuje tři základní typy uzlů, přičemž každý uzel
je představován samostatným procesem (ten typicky běží na pozadí). Tyto procesy
mohou běžet na jediném počítači nebo mohou být distribuovány a škálovány na
větší množství strojů, a to pochopitelně i (v&nbsp;případě potřeby) geograficky
oddělených. Jedná se o tyto uzly:</p>

<ol>

<li><i>nsqlookupd</i> &ndash; jedná se o takzvanou <i>directory service</i>,
tj.&nbsp;o službu, do které se registrují všechny ostatní uzly a která tak má
přehled o umístění (adresa+číslo portu) i o stavu jednotlivých uzlů. Konzumenti
typicky nejprve kontaktují právě službu <i>nsqlookupd</i>, aby zjistili, které
brokery jim jsou schopny dodávat zprávy požadovaných témat (<i>topic</i>). Aby
byla zaručena funkcionalita celého systému, je možné, aby bylo současně
spuštěno více těchto služeb. Klienti (konzumenti) se pak mohou pokusit připojit
k&nbsp;více službám.</li>

<li><i>nsqd</i> &ndash; tyto uzly, jichž může běžet libovolné množství,
zajišťují vlastní příjem zpráv, jejich ukládání do front a následné doručení
konzumentům. Zprávy jsou perzistentní, tj.&nbsp;ve chvíli, kdy je uzel
<i>nsqd</i> z&nbsp;nějakého důvodu zastavován, jsou zprávy uloženy do souboru a
po znovuspuštění uzlu jsou ze souboru načteny do paměti a popř.&nbsp;zaslány
konzumentům. Je možné mít spuštěno větší množství <i>nsqd</i>, které mohou být
nastaveny takovým způsobem, že budou uchovávat a poskytovat stejné zprávy
(téma+kanál). V&nbsp;takovém případě se konzument může pokusit získat zprávy
z&nbsp;libovolného (právě dostupného) <i>nsqd</i>, popř.&nbsp;se připojit
k&nbsp;jinému <i>nsqd</i> v&nbsp;případě nějakého výpadku.</li>

<li><i>nsqadmin</i> &ndash; tato služba poskytuje (webové) uživatelské
rozhraní, ze kterého je možné sledovat činnost celého systému. Samotné
sledování je primárně založeno na komunikaci s&nbsp;prvním typem uzlu &ndash;
<i>nsqlookupd</i> a sekundárně s&nbsp;uzly <i>nsqd</i>.</li>

</ol>

<p><div class="rs-tip-major">Poznámka: celá architektura sice může na první
pohled vypadat zbytečně složitě, ovšem v&nbsp;té nejjednodušší možné (a
současně i prakticky využitelné) konfiguraci postačuje na stejném počítači
pustit jedinou instanci každé výše zmíněné služby; dokonce je možné použít
implicitní přednastavené porty, o nichž se zmíníme v&nbsp;navazujících
kapitolách. Pokud naopak budete vyžadovat vysokou dostupnost, je možné
jednotlivé služby spustit na různých počítačích/clusterech, což do značné míry
udělá systém odolný vůči výpadku jednotlivých uzlů (podrobnosti si řekneme
příště, protože existuje hned několik způsobů, jak architekturu navrhnout a
použít).</div></p>

<a href="https://www.root.cz/obrazek/395061/"><img src="https://i.iinfo.cz/images/133/nsq1-2-prev.png" class="image-395061" alt="&#160;" width="370" height="110" /></a>
<p><i>Obrázek 3: Webové uživatelské rozhraní vytvářené uzlem typu nsqadmin.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Doručení zprávy konzumentům</h2>

<p>Podívejme se nyní na způsob, jakým je zpráva doručena od producenta ke
konzumentovi (či při správném nastavení k&nbsp;více konzumentům). Zprávou je
v&nbsp;systému <i>nsq</i> myšlena prakticky libovolně dlouhá sekvence bajtů
označená časovým razítkem &ndash; může se tedy jednat jak o zprávu textovou,
tak i o obecná binární data, JSON, YAML, XML atd. Každá zpráva má navíc
přiřazeno téma (<i>topic</i>), což je libovolný řetězec. Samotná témata není
zapotřebí dopředu vytvářet, protože první poslaná zpráva s&nbsp;daným tématem
toto téma založí automaticky. Zpráva je poslána určitému <i>nsqd</i>,
popř.&nbsp;většímu množství <i>nsqd</i> &ndash; záleží, které <i>nsqd</i>
dokážou zpracovat správu se zvoleným tématem. Po přijetí zprávy systémem je
tato zpráva rozeslána do všech kanálů (<i>topic</i>), které pracují se zvoleným
tématem. Toto je důležité chování &ndash; díky rozeslání do více kanálů je
umožněn <i>multicast</i>, ovšem navíc to znamená, že jedna zpráva může být
zpracována vícekrát, s&nbsp;čímž musí konzumenti počítat (měli by být
<i>idempotentní</i> &ndash; <a
href="https://en.wikipedia.org/wiki/Idempotence">https://en.wikipedia.org/wiki/Idempotence</a>).</p>

<p>Konzumenti se připojují k&nbsp;určitým kanálům (a pochopitelně odebírají jen
zprávy ke zvoleným tématům), přičemž je možné, aby se k&nbsp;jednomu kanálu
připojilo větší množství konzumentů. V&nbsp;takovém případě jsou zprávy
distribuovány mezi připojené konzumenty na základě jejich dostupnosti a
rychlosti, s&nbsp;níž jsou schopni zpracování zpráv.</p>

<p><div class="rs-tip-major">Poznámka: na kanál (<i>channel</i>) se můžeme
dívat jako na samostatně pracujícího message brokera v&nbsp;klasickém slova
smyslu. Důležité je, že producenti zpráv s&nbsp;kanály vůbec nepracují a ani o
nich nemusí vědět. Producent pouze musí zjistit, které <i>nsqd</i> akceptují
zprávy s&nbsp;daným tématem, což zajišťuje <i>nsqlookupd</i>, který tyto
informace dostává od jednotlivých <i>nsqd</i> (ti mu je posílají přes
dlouhodobé TCP). Naproti tomu konzument si volí jak kanál, tak i téma
akceptovaných zpráv (což ostatně uvidíme ze zdrojových kódů demonstračních
příkladů). Navíc může být konzument připojen k&nbsp;většímu množství
<i>nsqd</i>, což vede k&nbsp;tomu, že může jednu zprávu dostat
vícekrát.</div></p>

<p>Toto schéma do značné míry odstraňuje problém <i>SPOF &ndash; Single Point
of Failure</i>. Sice může nastat situace, kdy je <i>nsqlookupd</i> jakožto
centrální prvek nedostupný, ovšem stávající klienty to neovlivní (ti jsou již
připojení ke konkrétním <i>nsqd</i>) a po znovuzprovoznění této služby se po
chvíli obnoví kýžený stav celého systému.</p>

<p>V&nbsp;dalších kapitolách si ukážeme, jak celé <i>nsq</i> funguje
prakticky.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Překlad  a instalace systému <i>nsq</i></h2>

<p>Před odzkoušením <i>nsq</i> pochopitelně musíme celý systém nainstalovat,
nakonfigurovat a spustit. Nejprve je nutné nainstalovat samotný systém
<i>nsq</i>. Máme přitom dvě možnosti &ndash; buď se přímo ze stránky <a
href="https://nsq.io/deployment/installing.html">https://nsq.io/deployment/installing.html</a>
stáhnou předpřipravené binární obrazy všech utilit, nebo je umožněno překlad
provést lokálně. První možnost &ndash; stažení tarballu se všemi potřebnými
utilitami &ndash; je (nebo alespoň v&nbsp;mém případě z&nbsp;nějakého důvodu
byla) velmi pomalá, takže si vyzkoušíme druhou možnost, tj.&nbsp;překlad
<i>nsq</i> ze zdrojových kódů. Potřebovat budeme standardní nástroje
programovacího jazyka Go, ideálně ve verzi podporující <a
href="https://www.root.cz/clanky/system-modulu-v-programovacim-jazyce-go/">práci
s&nbsp;moduly</a> (tj.&nbsp;mělo by se jednat o Go od verze 1.11, což by dnes
neměl být na všech majoritních distribucích problém). Druhým potřebným
nástrojem je <strong>make</strong>.</p>

<p>Nejprve naklonujeme repositář s&nbsp;<i>nsq</i> z&nbsp;GitHubu:</p>

<pre>
$ <strong>git clone https://github.com/nsqio/nsq</strong>
&nbsp;
Cloning into 'nsq'...
remote: Enumerating objects: 18, done.
remote: Counting objects: 100% (18/18), done.
remote: Compressing objects: 100% (17/17), done.
remote: Total 11117 (delta 2), reused 7 (delta 1), pack-reused 11099
Receiving objects: 100% (11117/11117), 12.18 MiB | 505.00 KiB/s, done.
Resolving deltas: 100% (6658/6658), done.
Checking connectivity... done.
</pre>

<p>Dále přejdeme do naklonovaného repositáře:</p>

<pre>
$ <strong>cd nsq</strong>
</pre>

<p>Samotný překlad spustíme jediným příkazem <strong>make</strong>:</p>

<pre>
$ <strong>make</strong>
&nbsp;
go build  -o build/nsqd ./apps/nsqd
go: finding github.com/nsqio/go-nsq v1.0.7
go: finding github.com/bitly/timer_metrics v0.0.0-20170606164300-b1c65ca7ae62
go: finding github.com/pmezard/go-difflib v1.0.0
go: finding github.com/stretchr/testify v1.2.2
go: finding github.com/julienschmidt/httprouter v1.2.0
go: finding github.com/BurntSushi/toml v0.3.1
go: finding github.com/bitly/go-hostpool v0.0.0-20171023180738-a3a6125de932
go: finding github.com/davecgh/go-spew v1.1.1
go: finding github.com/bmizerany/perks v0.0.0-20141205001514-d9a9656a3a4b
go: finding golang.org/x/sys v0.0.0-20181221143128-b4a75ba826a6
go: finding github.com/nsqio/go-diskqueue v0.0.0-20180306152900-74cfbc9de839
go: finding github.com/judwhite/go-svc v1.0.0
go: finding github.com/mreiferson/go-options v0.0.0-20190302015348-0c63f026bcd6
go: finding github.com/golang/snappy v0.0.0-20180518054509-2e65f85255db
go: finding github.com/blang/semver v3.5.1+incompatible
go: downloading github.com/BurntSushi/toml v0.3.1
go: downloading github.com/judwhite/go-svc v1.0.0
go: downloading github.com/nsqio/go-nsq v1.0.7
go: downloading github.com/golang/snappy v0.0.0-20180518054509-2e65f85255db
go: downloading github.com/julienschmidt/httprouter v1.2.0
go: downloading github.com/mreiferson/go-options v0.0.0-20190302015348-0c63f026bcd6
go: downloading github.com/bmizerany/perks v0.0.0-20141205001514-d9a9656a3a4b
go: downloading github.com/nsqio/go-diskqueue v0.0.0-20180306152900-74cfbc9de839
go: downloading github.com/blang/semver v3.5.1+incompatible
go build  -o build/nsqlookupd ./apps/nsqlookupd
go build  -o build/nsqadmin ./apps/nsqadmin
go build  -o build/nsq_to_nsq ./apps/nsq_to_nsq
go: downloading github.com/bitly/go-hostpool v0.0.0-20171023180738-a3a6125de932
go: downloading github.com/bitly/timer_metrics v0.0.0-20170606164300-b1c65ca7ae62
go build  -o build/nsq_to_file ./apps/nsq_to_file
go build  -o build/nsq_to_http ./apps/nsq_to_http
go build  -o build/nsq_tail ./apps/nsq_tail
go build  -o build/nsq_stat ./apps/nsq_stat
go build  -o build/to_nsq ./apps/to_nsq
</pre>

<p>Po relativně krátkém překladu by měl být výsledek tohoto procesu uložen do
podadresáře <strong>build/</strong>. Povšimněte si, že vzniklo hned několik
binárních spustitelných souborů, z&nbsp;nichž některé budou popsány a použity
v&nbsp;navazujících kapitolách:</p>

<pre>
-rwxr-xr-x 1 tester tester 10725519 říj 25 22:07 nsqadmin
-rwxr-xr-x 1 tester tester 11209429 říj 25 22:06 nsqd
-rwxr-xr-x 1 tester tester 10303290 říj 25 22:06 nsqlookupd
-rwxr-xr-x 1 tester tester  6922106 říj 25 22:07 nsq_stat
-rwxr-xr-x 1 tester tester  7297068 říj 25 22:07 nsq_tail
-rwxr-xr-x 1 tester tester  7506571 říj 25 22:07 nsq_to_file
-rwxr-xr-x 1 tester tester  7434625 říj 25 22:07 nsq_to_http
-rwxr-xr-x 1 tester tester  7409874 říj 25 22:07 nsq_to_nsq
-rwxr-xr-x 1 tester tester  7080549 říj 25 22:07 to_nsq
</pre>

<p>Zkontrolujeme, zda jsou soubory spustitelné:</p>

<pre>
$ <strong>cd build</strong>
&nbsp;
$ <strong>./nsqlookupd --version</strong>
nsqlookupd v1.2.1-alpha (built w/go1.11.2)
&nbsp;
$ <strong>./nsqd --version</strong>
nsqd v1.2.1-alpha (built w/go1.11.2)
</pre>

<p><div class="rs-tip-major">Poznámka: podadresář <strong>build</strong> je
vhodné přidat na <strong>PATH</strong>, protože právě zde umístěné soubory
budeme spouštět v&nbsp;rámci pokusů prováděných v&nbsp;dalších
kapitolách.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Instalace knihoven používaných klienty</h2>

<p>Ve druhém kroku nainstalujeme knihovny, které budou používány klienty
systému <i>nsq</i>, tj.&nbsp;jak producenty, tak i konzumenty. Seznam
oficiálních i neoficiálních knihoven určených pro různé programovací jazyky je
možné nalézt na adrese <a
href="https://nsq.io/clients/client_libraries.html">https://nsq.io/clients/client_libraries.html</a>.</p>

<p><div class="rs-tip-major">Poznámka: <i>nsqd</i> na prvním řádku tabulky je
uveden z&nbsp;toho důvodu, že umožňuje posílání zpráv přes REST API.</div></p>

<p>Pro účely dnešního článku nám budou postačovat knihovny určené pro jazyk Go
(<a href="https://github.com/nsqio/go-nsq">https://github.com/nsqio/go-nsq</a>)
a taktéž pro jazyk Python (<a
href="https://github.com/nsqio/pynsq">https://github.com/nsqio/pynsq</a>).</p>

<p>Instalace knihovny (či možná lépe řečeno balíčku) pro jazyk Go je ve
skutečnosti triviální, protože nám postačuje použít tento příkaz:</p>

<pre>
$ <strong>go get github.com/nsqio/go-nsq</strong>
</pre>

<p>Knihoven určených pro jazyk Python existuje několik (jedna je založena na <a
href="https://www.tornadoweb.org/en/stable/">Tornadu</a>, druhá na knihovně <a
href="http://www.gevent.org/">gevent</a>), my ovšem použijeme oficiálně
podporovanou knihovnu <i>pynsq</i> určenou právě pro Tornado. Tuto knihovnu je
možné nainstalovat nástrojem <strong>pip</strong>
popř.&nbsp;<strong>pip3</strong>, a to následujícím způsobem:</p>

<pre>
$ <strong>pip3 install --user pynsq</strong>
&nbsp;
Downloading/unpacking pynsq
  Downloading pynsq-0.8.3.tar.gz
  Running setup.py (path:/tmp/ramdisk/pip_build_tester/pynsq/setup.py) egg_info for package pynsq
&nbsp;
Downloading/unpacking tornado&lt;5.0 (from pynsq)
  Downloading tornado-4.5.3.tar.gz (484kB): 484kB downloaded
  Running setup.py (path:/tmp/ramdisk/pip_build_tester/tornado/setup.py) egg_info for package tornado
&nbsp;
    no previously-included directories found matching 'docs/build'
    warning: no files found matching 'tornado/test/README'
Downloading/unpacking backports-abc&gt;=0.4 (from tornado&lt;5.0-&gt;pynsq)
  Downloading backports_abc-0.5-py2.py3-none-any.whl
Installing collected packages: pynsq, tornado, backports-abc
  Running setup.py install for pynsq
&nbsp;
  Running setup.py install for tornado
    building 'tornado.speedups' extension
    x86_64-linux-gnu-gcc -pthread -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototy
    ...
    ...
    ...
Successfully installed pynsq tornado backports-abc
Cleaning up...
</pre>

<p><div class="rs-tip-major">Poznámka: pokud ještě nemáte nainstalován balíček
<i>Tornado</i>, dojde k&nbsp;pokusu o jeho překlad. Budete tedy potřebovat jak
GCC, tak i balíček <strong>python-dev</strong> či <strong>python-devel</strong>
z&nbsp;vaší Linuxové distribuce.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Spuštění jednotlivých uzlů systému <i>nsq</i></h2>

<p>Nyní, když již máme nainstalován jak samotný systém <i>nsq</i>, tak i
knihovny používané na straně klientů, si můžeme vyzkoušet jeho základní
chování. Nejdříve je nutné spustit jednotlivé uzly, z&nbsp;nichž se <i>nsq</i>
skládá (viz též <a href="#k02">druhou kapitolu</a> s&nbsp;popisem celkové
architektury systému).</p>

<p>Nejprve spustíme <i>nsqlookupd</i>, což je služba, které není (v&nbsp;našem
značně zjednodušeném případě) nutné předávat žádné další parametry. Tato služba
pochopitelně může běžet na pozadí, ovšem pro sledování její činnosti je lepší
ji spustit v&nbsp;samostatném terminálu:</p>

<pre>
$ <strong>./nsqlookupd</strong>
&nbsp;
[nsqlookupd] 2019/10/26 12:14:11.480329 INFO: nsqlookupd v1.2.1-alpha (built w/go1.11.2)
[nsqlookupd] 2019/10/26 12:14:11.481027 INFO: TCP: listening on [::]:4160
[nsqlookupd] 2019/10/26 12:14:11.481947 INFO: HTTP: listening on [::]:4161
</pre>

<p>Pro jistotu odzkoušíme, jestli služba skutečně běží:</p>

<pre>
$ <strong>curl -v localhost:4161/ping</strong>
&nbsp;
* Hostname was NOT found in DNS cache
*   Trying 127.0.0.1...
* Connected to localhost (127.0.0.1) port 4161 (#0)
&gt; GET /ping HTTP/1.1
&gt; User-Agent: curl/7.35.0
&gt; Host: localhost:4161
&gt; Accept: */*
&gt; 
&lt; HTTP/1.1 200 OK
&lt; Date: Sun, 27 Oct 2019 18:07:41 GMT
&lt; Content-Length: 2
&lt; Content-Type: text/plain; charset=utf-8
&lt; 
* Connection #0 to host localhost left intact
OK
</pre>

<p>V&nbsp;dalším kroku spustíme jednu instanci <i>nsqd</i>, které předáme
adresu a port již běžící služby <i>nsqlookupd</i>. Tyto informace je nutné
znát, protože <i>nsqd</i> bude službu <i>nsqlookupd</i> informovat o svém stavu
(kanály, témata, počty a stavy zpráv). Komunikace probíhá po TCP, jehož socket
je otevřen na portu 4160, tedy:</p>

<pre>
$ <strong>./nsqd --lookupd-tcp-address=127.0.0.1:4160</strong>
&nbsp;
[nsqd] 2019/10/26 12:15:09.617256 INFO: nsqd v1.2.1-alpha (built w/go1.11.2)
[nsqd] 2019/10/26 12:15:09.617365 INFO: ID: 961
[nsqd] 2019/10/26 12:15:09.617669 INFO: NSQ: persisting topic/channel metadata to nsqd.dat
[nsqd] 2019/10/26 12:15:09.623347 INFO: LOOKUP(127.0.0.1:4160): adding peer
[nsqd] 2019/10/26 12:15:09.623403 INFO: LOOKUP connecting to 127.0.0.1:4160
[nsqd] 2019/10/26 12:15:09.623756 INFO: HTTP: listening on [::]:4151
[nsqd] 2019/10/26 12:15:09.623410 INFO: TCP: listening on [::]:4150
[nsqd] 2019/10/26 12:15:09.625281 INFO: LOOKUPD(127.0.0.1:4160): peer info {TCPPort:4160 HTTPPort:4161 Version:1.2.1-alpha BroadcastAddress:tester-ThinkPad-T410}
</pre>

<p>I tuto službu lze otestovat přes její REST API:</p>

<pre>
$ <strong>curl -v localhost:4151/ping</strong>
&nbsp;
* Hostname was NOT found in DNS cache
*   Trying 127.0.0.1...
* Connected to localhost (127.0.0.1) port 4151 (#0)
&gt; GET /ping HTTP/1.1
&gt; User-Agent: curl/7.35.0
&gt; Host: localhost:4151
&gt; Accept: */*
&gt; 
&lt; HTTP/1.1 200 OK
&lt; Date: Sun, 27 Oct 2019 18:09:05 GMT
&lt; Content-Length: 2
&lt; Content-Type: text/plain; charset=utf-8
&lt; 
* Connection #0 to host localhost left intact
OK
</pre>

<p>Nakonec spustíme službu <i>nsqadmin</i>, která poskytuje uživatelské
rozhraní, k&nbsp;němuž je možné se připojit z&nbsp;webového prohlížeče:</p>

<pre>
$ <strong>./nsqadmin --lookupd-http-address=127.0.0.1:4161</strong>
&nbsp;
[nsqadmin] 2019/10/26 12:15:43.095179 INFO: nsqadmin v1.2.1-alpha (built w/go1.11.2)
[nsqadmin] 2019/10/26 12:15:43.096054 INFO: HTTP: listening on [::]:4171
</pre>

<p>Opět můžeme použít REST API (<i>ping</i>) pro otestování základní činnosti
serveru, a to na portu 4117:</p>

<pre>
$ <strong>curl -v localhost:4171/ping</strong>
&nbsp;
* Hostname was NOT found in DNS cache
*   Trying 127.0.0.1...
* Connected to localhost (127.0.0.1) port 4171 (#0)
&gt; GET /ping HTTP/1.1
&gt; User-Agent: curl/7.35.0
&gt; Host: localhost:4171
&gt; Accept: */*
&gt; 
&lt; HTTP/1.1 200 OK
&lt; Date: Sun, 27 Oct 2019 18:10:37 GMT
&lt; Content-Length: 2
&lt; Content-Type: text/plain; charset=utf-8
&lt; 
* Connection #0 to host localhost left intact
OK
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Používané porty</h2>

<p>Jen pro větší přehlednost si vypišme TCP porty, s&nbsp;nimiž budeme buď
přímo či nepřímo pracovat:</p>

<table>
<tr><th>Port</th><th>Uzel</th><th>Typ</th><th>Význam</th></tr>
<tr><td>4150</td><td>nsqd</td><td>TCP</td><td>použit producenty pro posílání zpráv</td></tr>
<tr><td>4151</td><td>nsqd</td><td>HTTP</td><td>použit producenty pro posílání zpráv</td></tr>
<tr><td>4160</td><td>nsqlookupd</td><td>TCP</td><td>použit nsqd, kteří informují o svém stavu</td></tr>
<tr><td>4161</td><td>nsqlookupd</td><td>HTTP</td><td>REST API rozhraní pro konzumenty a další nástroje</td></tr>
<tr><td>4171</td><td>nsqadmin</td><td>HTTP</td><td>webové UI administrátorské konzole</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: producenti mohou zprávy posílat jak na
port 4150, tak i 4151 v&nbsp;závislosti na jejich konfiguraci, použité knihovně
atd. Použití portu 4151 je jednodušší (klasické REST API), ovšem pomalejší, než
když si klient zajistí dlouhodobě otevřený socket na port 4150. Navíc, pokud se
nakonfiguruje i použití HTTPS, se používá port 4152. V&nbsp;případě, že je
nutné spustit více <i>nsqd</i> na stejném počítači, bude pochopitelně nutné
zvolit odlišná čísla portů &ndash; viz též příkaz:</div></p>

<pre>
<strong>./nsqd --help</strong>
&nbsp;
  ...
  ...
  ...
  -http-address string
        &lt;addr&gt;:&lt;port&gt; to listen on for HTTP clients (default "0.0.0.0:4151")
  ...
  ...
  ...
  -https-address string
        &lt;addr&gt;:&lt;port&gt; to listen on for HTTPS clients (default "0.0.0.0:4152")
  ...
  ...
  ...
  -tcp-address string
        &lt;addr&gt;:&lt;port&gt; to listen on for TCP clients (default "0.0.0.0:4150")
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Poslání zprávy přes REST API</h2>

<p>Pro poslání zprávy není ve skutečnosti nutné používat žádné komplikované
mechanismy, protože si vystačíme s&nbsp;běžným REST API běžícím (přesněji
řečeno naslouchajícím) na portu 4151 a tedy i s&nbsp;nástrojem typu
<strong>curl</strong>, <strong>httpie</strong> atd. Zpráva se konkrétně pošle
v&nbsp;těle požadavku a v&nbsp;URL je nutné specifikovat téma (<i>topic</i>)
zprávy:</p>

<pre>
$ <strong>curl -d 'zprava1' http://127.0.0.1:4151/pub?topic=test</strong>
&nbsp;
OK
</pre>

<p>Pokud se podíváte na terminál služby/uzlu <i>nsqd</i>, měly by se na něm
objevit tyto dvě zprávy oznamující, že bylo vytvořeno nové téma a že zprávy
budou meziuloženy v&nbsp;souboru <strong>nsqd.dat</strong> (způsob uložení
zpráv je pochopitelně taktéž konfigurovatelný):</p>

<pre>
[nsqd] 2019/10/26 12:05:26.826143 INFO: TOPIC(test): created
[nsqd] 2019/10/26 12:05:26.826954 INFO: NSQ: persisting topic/channel metadata to nsqd.dat
</pre>

<a href="https://www.root.cz/obrazek/395062/"><img src="https://i.iinfo.cz/images/133/nsq1-3-prev.png" class="image-395062" alt="&#160;" width="370" height="125" /></a>
<p><i>Obrázek 4: Stav systému po poslání první zprávy.</i></p>

<p>Pochopitelně je možné poslat zprávu s&nbsp;binárním obsahem, načtenou
z&nbsp;nějakého souboru:</p>

<pre>
$ <strong>curl -d 'zprava1' http://127.0.0.1:4151/pub?topic=test</strong>
&nbsp;
OK
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Komunikace s&nbsp;uzlem <i>nsqlookupd</i> přes REST API</h2>

<p>Uzel typu <i>nsqlookupd</i> nabízí všem klientům jednoduše použitelné REST
API. V&nbsp;této kapitole se podíváme na některé základní způsoby jeho použití.
Vzhledem k&nbsp;tomu, že většina odpovědí je ve formě <a
href="http://json.org/">JSONu</a>, který ovšem není naformátován (je vrácen na
jediném řádku), budeme v&nbsp;dále uvedených příkladech používat následující
alias, který JSON naformátuje a zobrazí na standardním výstupu:</p>

<pre>
$ <strong>alias pp='python -mjson.tool'</strong>
</pre>

<p>Dotaz, zda je služba funkční, jsme již viděli <a href="#k06">v&nbsp;šesté
kapitole</a>, takže jen krátce:</p>

<pre>
$ <strong>curl -s localhost:4161/ping </strong>
&nbsp;
OK
</pre>

<p>Základní informace o službě (v&nbsp;současnosti se zobrazí pouze verze):</p>

<pre>
$ <strong>curl -s localhost:4161/info | pp</strong>
&nbsp;
{
    "version": "1.2.1-alpha"
}
</pre>

<p>Získání seznamu všech založených témat (téma &bdquo;test&ldquo; jsme
vytvořili v&nbsp;rámci předchozí kapitoly):</p>

<pre>
$ <strong>curl -s localhost:4161/topics | pp</strong>
&nbsp;
{
    "topics": [
        "test"
    ]
}
</pre>

<p>Získání seznamu kanálů a producentů, kteří přispěli alespoň jednou zprávou
do zvoleného tématu:</p>

<pre>
$ <strong>curl -s localhost:4161/lookup?topic=test | pp</strong>
&nbsp;
{
    "channels": [
        "test"
        "nsq_to_file"
    ],
    "producers": [
        {
            "broadcast_address": "tester-ThinkPad-T410",
            "hostname": "tester-ThinkPad-T410",
            "http_port": 4151,
            "remote_address": "127.0.0.1:59503",
            "tcp_port": 4150,
            "version": "1.2.1-alpha"
        }
    ]
}
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti se vám zobrazí prázdný
seznam kanálů, a to až do chvíle, dokud není spuštěn nějaký
konzument.</div></p>

<p>Informace o kanálech, přes které se připojují klienti ke zvolenému
tématu:</p>

<pre>
$ <strong>curl -s localhost:4161/channels?topic=test | pp</strong>
&nbsp;
{
    "channels": [
        "test"
        "nsq_to_file"
    ]
}
</pre>

<p>Informace o všech producentech zpráv, včetně témat:</p>

<pre>
$ <strong>curl -s localhost:4161/nodes | pp</strong>
&nbsp;
{
    "producers": [
        {
            "broadcast_address": "tester-ThinkPad-T410",
            "hostname": "tester-ThinkPad-T410",
            "http_port": 4151,
            "remote_address": "127.0.0.1:59503",
            "tcp_port": 4150,
            "tombstones": [
                false
            ],
            "topics": [
                "test"
            ],
            "version": "1.2.1-alpha"
        }
    ]
}
</pre>

<p>Vytvoření nového tématu (musí se použít metoda POST):</p>

<pre>
$ <strong>curl -X POST -s localhost:4161/topic/create?topic=dalsi_tema</strong>
&nbsp;
$ <strong>curl -s localhost:4161/topics | pp</strong>
&nbsp;
{
    "topics": [
        "dalsi_tema",
        "test"
    ]
}
</pre>

<p>Smazání tématu:</p>

<pre>
$ <strong>curl -X POST -s localhost:4161/topic/delete?topic=dalsi_tema</strong>
&nbsp;
$ <strong>curl -s localhost:4161/topics | pp</strong>
&nbsp;
{
    "topics": [
        "test"
    ]
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Jednoduchý producent zpráv naprogramovaný v&nbsp;Pythonu</h2>

<p>V&nbsp;této kapitole si ukážeme jednoduchého producenta zpráv
naprogramovaného v&nbsp;Pythonu. Tento producent je (v&nbsp;poněkud jednodušší
podobě) popsán na stránce <a
href="https://pynsq.readthedocs.io/en/latest/writer.html">https://pynsq.readthedocs.io/en/latest/writer.html</a>.
Je založen na třídě <strong>Writer</strong> a taktéž na periodickém volání
callback funkce <strong>pub_message</strong>, která po poslání zprávy zavolá
další callback funkci <strong>finish_pub</strong>:</p>

<pre>
import nsq
import tornado.ioloop
import time
&nbsp;
cnt = 1
&nbsp;
def <strong>pub_message</strong>():
    global cnt
    writer.pub('test', 'zprava {}'.format(cnt).encode(), finish_pub)
    cnt += 1
&nbsp;
def <strong>finish_pub</strong>(conn, data):
    print("FINISHING")
    print(data.decode())
    print("---------")
&nbsp;
writer = nsq.Writer(['127.0.0.1:4150'])
&nbsp;
tornado.ioloop.PeriodicCallback(pub_message, 1000).start()
nsq.run()
</pre>

<p><div class="rs-tip-major">Poznámka: původní kód byl určen pro pomalu ale
jistě dosluhující <a href="https://pythonclock.org/">Python 2.x</a>. Úprava pro
Python 3 je snadná, pouze musíme zajistit převod řetězců na pole bajtů a naopak
(metody <strong>encode()</strong> a <strong>decode()</strong>).</div></p>

<a href="https://www.root.cz/obrazek/395063/"><img src="https://i.iinfo.cz/images/133/nsq1-4-prev.png" class="image-395063" alt="&#160;" width="370" height="107" /></a>
<p><i>Obrázek 5: Situace po zveřejnění několika zpráv producentem.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Konzument zpráv naprogramovaný v&nbsp;Pythonu</h2>

<p>Konzumenta zpráv je možné v&nbsp;Pythonu naprogramovat doslova na několika
programových řádcích. Postačuje vytvořit instanci objektu typu
<strong>Reader</strong> a předat jí odkaz na callback funkci zavolanou pro
každou přijatou zprávu, adresu běžící služby <i>nsqlookupd</i>, název tématu,
které se bude zpracovávat a taktéž název kanálu. Pokud kanál před připojením
konzumenta neexistoval, bude automaticky vytvořen a objeví se i
v&nbsp;administrátorské konzoli popř.&nbsp;na REST API:</p>

<pre>
import nsq
&nbsp;
def <strong>handler</strong>(message):
    print(message)
    return True
&nbsp;
r = nsq.Reader(message_handler=handler,
        lookupd_http_addresses=['http://127.0.0.1:4161'],
        topic='test', channel='test', lookupd_poll_interval=15)
&nbsp;
nsq.run()
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že adresa služby
<i>lookupd</i> je umístěna v&nbsp;seznamu. Nejedná se o chybu, protože je
skutečně možné specifikovat více adres a tím pádem se vyrovnat se situací, kdy
jedna ze služeb <i>lookupd</i> není z&nbsp;nějakého důvodu dostupná.</div></p>

<img src="https://i.iinfo.cz/images/133/nsq1-5.png" class="image-395064" alt="&#160;" width="427" height="255" />
<p><i>Obrázek 6: Informace o počtu zpracovaných zpráv.</i></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Použití systému <i>nsq</i> klienty naprogramovanými v&nbsp;Go</h2>

<p>Jak jsme si již řekli v&nbsp;předchozích kapitolách, je možné klienty
(typicky běžné producenty a konzumenty zpráv) vytvářet v&nbsp;různých
programovacích jazycích. Ukažme si tedy, jak se vytvoří jednoduchý producent a
konzument v&nbsp;programovacím jazyku Go. Budeme přitom potřebovat balíček
nazvaný <strong>github.com/nsqio/go-nsq</strong> nainstalovaný v&nbsp;rámci <a
href="#k05">páté kapitoly</a>. Pro jednoduchého producenta zpráv postačuje
zavolat konstruktor:</p>

<pre>
func <strong>NewProducer</strong>(addr string, config *Config) (*Producer, error)
</pre>

<p>Konstruktoru je nutné předat především adresu běžící (a dostupné) služby
<i>nsqd</i>, na kterou se zpráva pošle. Druhým parametrem je struktura
s&nbsp;konfigurací, která se vytvoří a inicializuje konstruktorem:</p>

<pre>
func <strong>NewConfig()</strong> *Config
</pre>

<p>Prozatím nám budou stačit výchozí parametry, takže obsah této struktury
nebudeme modifikovat.</p>

<p>Producent může posílat zprávy více způsoby &ndash; synchronně, asynchronně,
může poslat více zpráv atd.:</p>

<pre>
func (w *Producer) <strong>Publish</strong>(topic string, body []byte) error
func (w *Producer) <strong>PublishAsync</strong>(topic string, body []byte, doneChan chan *ProducerTransaction, args ...interface{}) error
func (w *Producer) <strong>MultiPublish</strong>(topic string, body [][]byte) error
func (w *Producer) <strong>MultiPublishAsync</strong>(topic string, body [][]byte, doneChan chan *ProducerTransaction, args ...interface{}) error
</pre>

<p>Pro vytvoření konzumenta zpráv se použije odlišný konstruktor:</p>

<pre>
func <strong>NewConsumer</strong>(topic string, channel string, config *Config) (*Consumer, error)
</pre>

<p>Povšimněte si, že musíme specifikovat téma (<i>topic</i>), jméno kanálu
(<i>channel</i>) a taktéž strukturu s&nbsp;konfigurací. Ve chvíli, kdy je
konzument inicializován, je nutné ho připojit buď přímo ke zvolenému
<i>nsqd</i>, a to metodou:</p>

<pre>
func (r *Consumer) <strong>ConnectToNSQD</strong>(addr string) error
</pre>

<p>Alternativně je možné se nejdříve připojit ke službě <i>nsqlookupd</i>,
která udržuje informace o aktuálně dostupných <i>nsqd</i>. Existují dvě
možnosti &ndash; dotaz na jedinou službu <i>nsqlookupd</i> nebo dotaz poslaný
na více služeb:</p>

<pre>
func (r *Consumer) <strong>ConnectToNSQLookupd</strong>(addr string) error
func (r *Consumer) <strong>ConnectToNSQLookupds</strong>(addresses []string) error
</pre>

<p>Pochopitelně je nutné zajistit i odpojení, ideálně v&nbsp;bloku
<strong>defer</strong>:</p>

<pre>
func (r *Consumer) <strong>DisconnectFromNSQD</strong>(addr string) error
func (r *Consumer) <strong>DisconnectFromNSQLookupd</strong>(addr string) error
</pre>

<p>Samotné posílané zprávy jsou reprezentovány strukturou s&nbsp;obsahem
zprávy, jejím ID, časovým razítkem a dalšími podrobnějšími informacemi:</p>

<pre>
type <strong>Message</strong> struct {
    ID        MessageID
    Body      []byte
    Timestamp int64
    Attempts  uint16
&nbsp;
    NSQDAddress string
&nbsp;
    Delegate MessageDelegate
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Producent zpráv naprogramovaný v&nbsp;jazyce Go</h2>

<p>Jednoduchý producent zpráv je naprogramován takovým způsobem, aby se
připojil přímo ke zvolenému <i>nsqd</i> (na port 4150), poslal jedinou zprávu
s&nbsp;tématem &bdquo;test&ldquo; a následně se ukončil. Povšimněte si, že tělo
zprávy je tvořeno sekvencí bajtů a na konci musíme producenta explicitně
zastavit:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/nsqio/go-nsq"
        "log"
)
&nbsp;
func <strong>main</strong>() {
        config := nsq.NewConfig()
&nbsp;
        producer, err := nsq.NewProducer("127.0.0.1:4150", config)
        if err != nil {
                log.Panic("Producer can't be constructed")
        }
&nbsp;
        err = producer.Publish("test", []byte("zprava z Go"))
        if err != nil {
                log.Panic("Could not connect")
        }
&nbsp;
        producer.Stop()
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Využití bloku <strong>defer</strong> pro ukončení producenta zpráv</h2>

<p>V&nbsp;praxi je lepší (a pro programovací jazyk Go i idiomatičtější)
zajistit odpojení a ukončení producenta zpráv s&nbsp;využitím bloku
<strong>defer</strong>, což je ukázáno v&nbsp;další verzi producenta (viz
zvýrazněný řádek kódu):</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "github.com/nsqio/go-nsq"
        "log"
)
&nbsp;
func <strong>main</strong>() {
        config := nsq.NewConfig()
&nbsp;
        producer, err := nsq.NewProducer("127.0.0.1:4150", config)
        if err != nil {
                log.Panic("Producer can't be constructed")
        }
        <strong>defer producer.Stop()</strong>
&nbsp;
        err = producer.Publish("test", []byte("zprava z Go"))
        if err != nil {
                log.Panic("Could not connect")
        }
}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Jednoduchý konzument zpráv používající synchronizaci pro ukončení gorutiny s&nbsp;příjemcem</h2>

<p>Nyní si můžeme ukázat konzumenta zpráv. Ten je založen na využití callback
funkce (<i>handleru</i>), jenž je zavolán ve chvíli, kdy byla přijata nová
zpráva. Tento koncept jsme ostatně viděli už v&nbsp;konzumentovi
naprogramovaném v&nbsp;Pythonu. Samotný handler lze vytvořit ve formě uzávěru,
protože musí mít přístup k&nbsp;synchronizační entitě <i>wait group</i> (i
s&nbsp;ní už jsme se seznámili, a to v&nbsp;paralelně běžícím seriálu o
programovacím jazyce Go):</p>

<pre>
consumer.AddHandler(nsq.HandlerFunc(func(message *nsq.Message) error {
        log.Printf("Received a message: %s", string(message.Body))
        waitgroup.Done()
        return nil
}))
</pre>

<p>Synchronizační entita slouží k&nbsp;tomu, aby se po zaregistrování handleru
aplikace neukončila. Ukončení zajistí až zavolání
<strong>waithroup.Done()</strong>:</p>

<pre>
package main
&nbsp;
import (
        "github.com/nsqio/go-nsq"
        "log"
        "sync"
)
&nbsp;
func main() {
        config := nsq.NewConfig()
&nbsp;
        consumer, err := nsq.NewConsumer("test", "test", config)
        if err != nil {
                log.Panic("Consumer can't be constructed")
        }
&nbsp;
        waitgroup := &amp;sync.WaitGroup{}
        waitgroup.Add(1)
&nbsp;
        consumer.AddHandler(nsq.HandlerFunc(func(message *nsq.Message) error {
                log.Printf("Received a message: %s", string(message.Body))
                waitgroup.Done()
                return nil
        }))
&nbsp;
        err = consumer.ConnectToNSQD("127.0.0.1:4150")
        if err != nil {
                log.Panic("Could not connect")
        }
&nbsp;
        log.Println("Waiting for message")
        waitgroup.Wait()
}
</pre>

<p><div class="rs-tip-major">Poznámka: do programu můžete přidat i explicitní
příkaz odpojení od <i>nsqd</i>. Není to sice striktně vyžadováno, protože
k&nbsp;odpojení dojde i po ukončení aplikace, ale programy psané v&nbsp;Go
bývají v&nbsp;tomto ohledu velmi explicitní:</div></p>

<pre>
defer consumer.DisconnectFromNSQD("127.0.0.1:4150")
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Použití kanálu ve funkci synchronizační struktury</h2>

<p>Pro čekání na příjem zprávy můžeme využít i kanály. Pro tento účel postačuje
vytvořit kanál, do něhož se zapíše (libovolná) informace po přijetí zprávy. Na
tuto informaci budeme čekat v&nbsp;hlavní gorutině. Výsledkem je (alespoň podle
mého názoru) přehlednější kód (změněné části jsou opět zvýrazněny):</p>

<pre>
package main
&nbsp;
import (
        "github.com/nsqio/go-nsq"
        "log"
)
&nbsp;
func main() {
        config := nsq.NewConfig()
&nbsp;
        consumer, err := nsq.NewConsumer("test", "test", config)
        if err != nil {
                log.Panic("Consumer can't be constructed")
        }
&nbsp;
        <strong>done := make(chan bool)</strong>
&nbsp;
        consumer.AddHandler(nsq.HandlerFunc(func(message *nsq.Message) error {
                log.Printf("Received a message: %s", string(message.Body))
                <strong>done &lt;- true</strong>
                return nil
        }))
&nbsp;
        err = consumer.ConnectToNSQD("127.0.0.1:4150")
        if err != nil {
                log.Panic("Could not connect")
        }
&nbsp;
        log.Println("Waiting for message")
        <strong>&lt;-done</strong>
}
</pre>

<p>Opět můžete přidat volání funkce pro explicitní odpojení klienta od
<i>nsqd</i>:</p>

<pre>
defer consumer.DisconnectFromNSQD("127.0.0.1:4150")
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Připojení klienta ke službě <i>nsqlookupd</i></h2>

<p>Klient, přesněji řečeno konzument zpráv, by se správně měl připojovat spíše
ke službě <i>nsqlookupd</i> a nikoli přímo k&nbsp;<i>nsqd</i>. Proto program
nepatrně upravíme a použijeme metodu <strong>ConnectToNSQLookupd</strong>
namísto <strong>ConnectToNSQD</strong>. Samozřejmě budeme muset použít odlišnou
adresu:</p>

<pre>
package main
&nbsp;
import (
        "github.com/nsqio/go-nsq"
        "log"
)
&nbsp;
func main() {
        config := nsq.NewConfig()
&nbsp;
        consumer, err := nsq.NewConsumer("test", "test", config)
        if err != nil {
                log.Panic("Consumer can't be constructed")
        }
&nbsp;
        done := make(chan bool)
&nbsp;
        consumer.AddHandler(nsq.HandlerFunc(func(message *nsq.Message) error {
                log.Printf("Received a message: %s", string(message.Body))
                return nil
        }))
&nbsp;
        err = <strong>consumer.ConnectToNSQLookupd("127.0.0.1:4161")</strong>
        if err != nil {
                log.Panic("Could not connect")
        }
&nbsp;
        log.Println("Waiting for message")
        <-done
}
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Obsah následující části seriálu</h2>

<p>V&nbsp;další části seriálu o message brokere popis systému <i>nsq</i>
dokončíme. Seznámíme se zejména se složitějšími architekturami, v&nbsp;nichž
běží více služeb <i>nsqlookupd</i> i <i>nsqd</i> a k&nbsp;nimž se mohou
připojovat klienti.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů vyvinutých
v&nbsp;programovacím jazyku Python a Go byly uloženy do Git repositáře, který
je dostupný na adrese <a
href="https://github.com/tisnik/message-queues-examples">https://github.com/tisnik/message-queues-examples</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, dnes má
stále ještě doslova několik kilobajtů), můžete namísto toho použít odkazy na
jednotlivé příklady, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th>Příklad</th><th>Skript</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td>1</td><td>producer.py</td><td>jednoduchý producent zpráv naprogramovaný v&nbsp;Pythonu</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nsq/producer.py">https://github.com/tisnik/message-queues-examples/blob/master/nsq/producer.py</a></td></tr>
<tr><td>2</td><td>consumer.py</td><td>konzument zpráv naprogramovaný v&nbsp;Pythonu</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nsq/consumer.py">https://github.com/tisnik/message-queues-examples/blob/master/nsq/consumer.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>producer.go</td><td>producent jedné zprávy naprogramované v&nbsp;jazyce Go</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nsq/producer.go">https://github.com/tisnik/message-queues-examples/blob/master/nsq/producer.go</a></td></tr>
<tr><td>4</td><td>producer2.go</td><td>producent jedné zprávy naprogramované v&nbsp;jazyce Go s&nbsp;blokem <strong>defer</strong></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nsq/producer.go">https://github.com/tisnik/message-queues-examples/blob/master/nsq/producer.go</a></td></tr>
<tr><td>5</td><td>consumer1.go</td><td>konzument naprogramovaný v&nbsp;Go, který využívá <i>wait groups</i> při čekání na doručení zprávy</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nsq/consumer1.go">https://github.com/tisnik/message-queues-examples/blob/master/nsq/consumer1.go</a></td></tr>
<tr><td>6</td><td>consumer2.go</td><td>konzument naprogramovaný v&nbsp;Go, který využívá kanál při čekání na doručení zprávy</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nsq/consumer2.go">https://github.com/tisnik/message-queues-examples/blob/master/nsq/consumer2.go</a></td></tr>
<tr><td>7</td><td>consumer3.go</td><td>ukázka použití metody <strong>ConnectToNSQLookupd</strong></td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/nsq/consumer3.go">https://github.com/tisnik/message-queues-examples/blob/master/nsq/consumer3.go</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Stránka projektu NSQ<br />
<a href="https://nsq.io/">https://nsq.io/</a>
</li>

<li>Dokumentace k&nbsp;projektu NSQ<br />
<a href="https://nsq.io/overview/design.html">https://nsq.io/overview/design.html</a>
</li>

<li>Dokumentace ke klientovi pro Go<br />
<a href="https://godoc.org/github.com/nsqio/go-nsq">https://godoc.org/github.com/nsqio/go-nsq</a>
</li>

<li>Dokumentace ke klientovi pro Python<br />
<a href="https://pynsq.readthedocs.io/en/latest/">https://pynsq.readthedocs.io/en/latest/</a>
</li>

<li>Binární tarbally s&nbsp;NSQ<br />
<a href="https://nsq.io/deployment/installing.html">https://nsq.io/deployment/installing.html</a>
</li>

<li>GitHub repositář projektu NSQ<br />
<a href="https://github.com/nsqio/nsq">https://github.com/nsqio/nsq</a>
</li>

<li>Klienti pro NSQ<br />
<a href="https://nsq.io/clients/client_libraries.html">https://nsq.io/clients/client_libraries.html</a>
</li>

<li>Klient pro Go<br />
<a href="https://github.com/nsqio/go-nsq">https://github.com/nsqio/go-nsq</a>
</li>

<li>Klient pro Python<br />
<a href="https://github.com/nsqio/pynsq">https://github.com/nsqio/pynsq</a>
</li>

<li>An Example of Using NSQ From Go<br />
<a href="http://tleyden.github.io/blog/2014/11/12/an-example-of-using-nsq-from-go/">http://tleyden.github.io/blog/2014/11/12/an-example-of-using-nsq-from-go/</a>
</li>

<li>Go Go Gadget<br />
<a href="https://word.bitly.com/post/29550171827/go-go-gadget">https://word.bitly.com/post/29550171827/go-go-gadget</a>
</li>

<li>Simplehttp<br />
<a href="https://github.com/bitly/simplehttp">https://github.com/bitly/simplehttp</a>
</li>

<li>Dramatiq: simple task processing<br />
<a href="https://dramatiq.io/">https://dramatiq.io/</a>
</li>

<li>Cookbook (for Dramatiq)<br />
<a href="https://dramatiq.io/cookbook.html">https://dramatiq.io/cookbook.html</a>
</li>

<li>Balíček dramatiq na PyPi<br />
<a href="https://pypi.org/project/dramatiq/">https://pypi.org/project/dramatiq/</a>
</li>

<li>Dramatiq dashboard<br />
<a href="https://github.com/Bogdanp/dramatiq_dashboard">https://github.com/Bogdanp/dramatiq_dashboard</a>
</li>

<li>Dramatiq na Redditu<br />
<a href="https://www.reddit.com/r/dramatiq/">https://www.reddit.com/r/dramatiq/</a>
</li>

<li>A Dramatiq broker that can be used with Amazon SQS<br />
<a href="https://github.com/Bogdanp/dramatiq_sqs">https://github.com/Bogdanp/dramatiq_sqs</a>
</li>

<li>nanomsg na GitHubu<br />
<a href="https://github.com/nanomsg/nanomsg">https://github.com/nanomsg/nanomsg</a>
</li>

<li>Referenční příručka knihovny <strong>nanomsg</strong><br />
<a href="https://nanomsg.org/v1.1.5/nanomsg.html">https://nanomsg.org/v1.1.5/nanomsg.html</a>
</li>

<li>nng (nanomsg-next-generation)<br />
<a href="https://github.com/nanomsg/nng">https://github.com/nanomsg/nng</a>
</li>

<li>Differences between nanomsg and ZeroMQ<br />
<a href="https://nanomsg.org/documentation-zeromq.html">https://nanomsg.org/documentation-zeromq.html</a>
</li>

<li>NATS<br />
<a href="https://nats.io/about/">https://nats.io/about/</a>
</li>

<li>NATS Streaming Concepts<br />
<a href="https://nats.io/documentation/streaming/nats-streaming-intro/">https://nats.io/documentation/streaming/nats-streaming-intro/</a>
</li>

<li>NATS Streaming Server<br />
<a href="https://nats.io/download/nats-io/nats-streaming-server/">https://nats.io/download/nats-io/nats-streaming-server/</a>
</li>

<li>NATS Introduction<br />
<a href="https://nats.io/documentation/">https://nats.io/documentation/</a>
</li>

<li>NATS Client Protocol<br />
<a href="https://nats.io/documentation/internals/nats-protocol/">https://nats.io/documentation/internals/nats-protocol/</a>
</li>

<li>NATS Messaging (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/NATS_Messaging">https://en.wikipedia.org/wiki/NATS_Messaging</a>
</li>

<li>Stránka Apache Software Foundation<br />
<a href="http://www.apache.org/">http://www.apache.org/</a>
</li>

<li>Informace o portu 5672<br />
<a href="http://www.tcp-udp-ports.com/port-5672.htm">http://www.tcp-udp-ports.com/port-5672.htm</a>
</li>

<li>Třída MessagingHandler knihovny Qpid Proton<br />
<a href="https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._handlers.MessagingHandler-class.html">https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._handlers.MessagingHandler-class.html</a>
</li>

<li>Třída Event knihovny Qpid Proton<br />
<a href="https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._events.Event-class.html">https://qpid.apache.org/releases/qpid-proton-0.27.0/proton/python/api/proton._events.Event-class.html</a>
</li>

<li>package stomp (Go)<br />
<a href="https://godoc.org/github.com/go-stomp/stomp">https://godoc.org/github.com/go-stomp/stomp</a>
</li>

<li>Go language library for STOMP protocol<br />
<a href="https://github.com/go-stomp/stomp">https://github.com/go-stomp/stomp</a>
</li>

<li>python-qpid-proton 0.26.0 na PyPi<br />
<a href="https://pypi.org/project/python-qpid-proton/">https://pypi.org/project/python-qpid-proton/</a>
</li>

<li>Qpid Proton<br />
<a href="http://qpid.apache.org/proton/">http://qpid.apache.org/proton/</a>
</li>

<li>Using the AMQ Python Client<br />
<a href="https://access.redhat.com/documentation/en-us/red_hat_amq/7.1/html-single/using_the_amq_python_client/">https://access.redhat.com/documentation/en-us/red_hat_amq/7.1/html-single/using_the_amq_python_client/</a>
</li>

<li>Apache ActiveMQ<br />
<a href="http://activemq.apache.org/">http://activemq.apache.org/</a>
</li>

<li>Apache ActiveMQ Artemis<br />
<a href="https://activemq.apache.org/artemis/">https://activemq.apache.org/artemis/</a>
</li>

<li>Apache ActiveMQ Artemis User Manual<br />
<a href="https://activemq.apache.org/artemis/docs/latest/index.html">https://activemq.apache.org/artemis/docs/latest/index.html</a>
</li>

<li>KahaDB<br />
<a href="http://activemq.apache.org/kahadb.html">http://activemq.apache.org/kahadb.html</a>
</li>

<li>Understanding the KahaDB Message Store<br />
<a href="https://access.redhat.com/documentation/en-US/Fuse_MQ_Enterprise/7.1/html/Configuring_Broker_Persistence/files/KahaDBOverview.html">https://access.redhat.com/documentation/en-US/Fuse_MQ_Enterprise/7.1/html/Configuring_Broker_Persistence/files/KahaDBOverview.html</a>
</li>

<li>Command Line Tools (Apache ActiveMQ)<br />
<a href="https://activemq.apache.org/activemq-command-line-tools-reference.html">https://activemq.apache.org/activemq-command-line-tools-reference.html</a>
</li>

<li>stomp.py 4.1.21 na PyPi<br />
<a href="https://pypi.org/project/stomp.py/">https://pypi.org/project/stomp.py/</a>
</li>

<li>Stomp Tutorial<br />
<a href="https://access.redhat.com/documentation/en-US/Fuse_Message_Broker/5.5/html/Connectivity_Guide/files/FMBConnectivityStompTelnet.html">https://access.redhat.com/documentation/en-US/Fuse_Message_Broker/5.5/html/Connectivity_Guide/files/FMBConnectivityStompTelnet.html</a>
</li>

<li>Heartbeat (computing)<br />
<a href="https://en.wikipedia.org/wiki/Heartbeat_(computing)">https://en.wikipedia.org/wiki/Heartbeat_(computing)</a>
</li>

<li>Apache Camel<br />
<a href="https://camel.apache.org/">https://camel.apache.org/</a>
</li>

<li>Red Hat Fuse<br />
<a href="https://developers.redhat.com/products/fuse/overview/">https://developers.redhat.com/products/fuse/overview/</a>
</li>

<li>Confusion between ActiveMQ and ActiveMQ-Artemis?<br />
<a href="https://serverfault.com/questions/873533/confusion-between-activemq-and-activemq-artemis">https://serverfault.com/questions/873533/confusion-between-activemq-and-activemq-artemis</a>
</li>

<li>Staré stránky projektu HornetQ<br />
<a href="http://hornetq.jboss.org/">http://hornetq.jboss.org/</a>
</li>

<li>Snapshot JeroMQ verze 0.4.4<br />
<a href="https://oss.sonatype.org/content/repositories/snapshots/org/zeromq/jeromq/0.4.4-SNAPSHOT/">https://oss.sonatype.org/content/repositories/snapshots/org/zeromq/jeromq/0.4.4-SNAPSHOT/</a>
</li>

<li>Difference between ActiveMQ vs Apache ActiveMQ Artemis<br />
<a href="http://activemq.2283324.n4.nabble.com/Difference-between-ActiveMQ-vs-Apache-ActiveMQ-Artemis-td4703828.html">http://activemq.2283324.n4.nabble.com/Difference-between-ActiveMQ-vs-Apache-ActiveMQ-Artemis-td4703828.html</a>
</li>

<li>Microservices communications. Why you should switch to message queues<br />
<a href="https://dev.to/matteojoliveau/microservices-communications-why-you-should-switch-to-message-queues--48ia">https://dev.to/matteojoliveau/microservices-communications-why-you-should-switch-to-message-queues--48ia</a>
</li>

<li>Stomp.py 4.1.19 documentation<br />
<a href="https://stomppy.readthedocs.io/en/stable/">https://stomppy.readthedocs.io/en/stable/</a>
</li>

<li>Repositář knihovny JeroMQ<br />
<a href="https://github.com/zeromq/jeromq/">https://github.com/zeromq/jeromq/</a>
</li>

<li>ØMQ &ndash; Distributed Messaging <br />
<a href="http://zeromq.org/">http://zeromq.org/</a>
</li>

<li>ØMQ Community<br />
<a href="http://zeromq.org/community">http://zeromq.org/community</a>
</li>

<li>Get The Software<br />
<a href="http://zeromq.org/intro:get-the-software">http://zeromq.org/intro:get-the-software</a>
</li>

<li>PyZMQ Documentation<br />
<a href="https://pyzmq.readthedocs.io/en/latest/">https://pyzmq.readthedocs.io/en/latest/</a>
</li>

<li>Module: zmq.decorators<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.decorators.html">https://pyzmq.readthedocs.io/en/latest/api/zmq.decorators.html</a>
</li>

<li>ZeroMQ is the answer, by Ian Barber<br />
<a href="https://vimeo.com/20605470">https://vimeo.com/20605470</a>
</li>

<li>ZeroMQ RFC<br />
<a href="https://rfc.zeromq.org/">https://rfc.zeromq.org/</a>
</li>

<li>ZeroMQ and Clojure, a brief introduction<br />
<a href="https://antoniogarrote.wordpress.com/2010/09/08/zeromq-and-clojure-a-brief-introduction/">https://antoniogarrote.wordpress.com/2010/09/08/zeromq-and-clojure-a-brief-introduction/</a>
</li>

<li>zeromq/czmq<br />
<a href="https://github.com/zeromq/czmq">https://github.com/zeromq/czmq</a>
</li>

<li>golang wrapper for CZMQ<br />
<a href="https://github.com/zeromq/goczmq">https://github.com/zeromq/goczmq</a>
</li>

<li>ZeroMQ version reporting in Python<br />
<a href="http://zguide.zeromq.org/py:version">http://zguide.zeromq.org/py:version</a>
</li>

<li>A Go interface to ZeroMQ version 4<br />
<a href="https://github.com/pebbe/zmq4">https://github.com/pebbe/zmq4</a>
</li>

<li>Broker vs. Brokerless<br />
<a href="http://zeromq.org/whitepapers:brokerless">http://zeromq.org/whitepapers:brokerless</a>
</li>

<li>Learning ØMQ with pyzmq<br />
<a href="https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/">https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/</a>
</li>

<li>Céčková funkce <strong>zmq_ctx_new</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-ctx-new">http://api.zeromq.org/4-2:zmq-ctx-new</a>
</li>

<li>Céčková funkce <strong>zmq_ctx_destroy</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-ctx-destroy">http://api.zeromq.org/4-2:zmq-ctx-destroy</a>
</li>

<li>Céčková funkce <strong>zmq_bind</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-bind">http://api.zeromq.org/4-2:zmq-bind</a>
</li>

<li>Céčková funkce <strong>zmq_unbind</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-unbind">http://api.zeromq.org/4-2:zmq-unbind</a>
</li>

<li>Céčková C funkce <strong>zmq_connect</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-connect">http://api.zeromq.org/4-2:zmq-connect</a>
</li>

<li>Céčková C funkce <strong>zmq_disconnect</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-disconnect">http://api.zeromq.org/4-2:zmq-disconnect</a>
</li>

<li>Céčková C funkce <strong>zmq_send</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-send">http://api.zeromq.org/4-2:zmq-send</a>
</li>

<li>Céčková C funkce <strong>zmq_recv</strong><br />
<a href="http://api.zeromq.org/4-2:zmq-recv">http://api.zeromq.org/4-2:zmq-recv</a>
</li>

<li>Třída <strong>Context</strong> (Python)<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.html#context">https://pyzmq.readthedocs.io/en/latest/api/zmq.html#context</a>
</li>

<li>Třída <strong>Socket</strong> (Python)<br />
<a href="https://pyzmq.readthedocs.io/en/latest/api/zmq.html#socket">https://pyzmq.readthedocs.io/en/latest/api/zmq.html#socket</a>
</li>

<li>Python binding<br />
<a href="http://zeromq.org/bindings:python">http://zeromq.org/bindings:python</a>
</li>

<li>Why should I have written ZeroMQ in C, not C++ (part I)<br />
<a href="http://250bpm.com/blog:4">http://250bpm.com/blog:4</a>
</li>

<li>Why should I have written ZeroMQ in C, not C++ (part II) <br />
<a href="http://250bpm.com/blog:8">http://250bpm.com/blog:8</a>
</li>

<li>About Nanomsg<br />
<a href="https://nanomsg.org/">https://nanomsg.org/</a>
</li>

<li>Advanced Message Queuing Protocol<br />
<a href="https://www.amqp.org/">https://www.amqp.org/</a>
</li>

<li>Advanced Message Queuing Protocol na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol">https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol</a>
</li>

<li>Dokumentace k&nbsp;příkazu <strong>rabbitmqctl</strong><br />
<a href="https://www.rabbitmq.com/rabbitmqctl.8.html">https://www.rabbitmq.com/rabbitmqctl.8.html</a>
</li>

<li>RabbitMQ<br />
<a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a>
</li>

<li>RabbitMQ Tutorials<br />
<a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a>
</li>

<li>RabbitMQ: Clients and Developer Tools<br />
<a href="https://www.rabbitmq.com/devtools.html">https://www.rabbitmq.com/devtools.html</a>
</li>

<li>RabbitMQ na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/RabbitMQ">https://en.wikipedia.org/wiki/RabbitMQ</a>
</li>

<li>Streaming Text Oriented Messaging Protocol<br />
<a href="https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol">https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol</a>
</li>

<li>Message Queuing Telemetry Transport<br />
<a href="https://en.wikipedia.org/wiki/MQTT">https://en.wikipedia.org/wiki/MQTT</a>
</li>

<li>Erlang<br />
<a href="http://www.erlang.org/">http://www.erlang.org/</a>
</li>

<li>pika 0.12.0 na PyPi<br />
<a href="https://pypi.org/project/pika/">https://pypi.org/project/pika/</a>
</li>

<li>Introduction to Pika<br />
<a href="https://pika.readthedocs.io/en/stable/">https://pika.readthedocs.io/en/stable/</a>
</li>

<li>Langohr: An idiomatic Clojure client for RabbitMQ that embraces the AMQP 0.9.1 model<br />
<a href="http://clojurerabbitmq.info/">http://clojurerabbitmq.info/</a>
</li>

<li>AMQP 0-9-1 Model Explained<br />
<a href="http://www.rabbitmq.com/tutorials/amqp-concepts.html">http://www.rabbitmq.com/tutorials/amqp-concepts.html</a>
</li>

<li>Part 1: RabbitMQ for beginners - What is RabbitMQ?<br />
<a href="https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html">https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html</a>
</li>

<li>Downloading and Installing RabbitMQ<br />
<a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a>
</li>

<li>celery na PyPi<br />
<a href="https://pypi.org/project/celery/">https://pypi.org/project/celery/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python <br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python (dokončení)<br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/</a>
</li>

<li>Redis Queue (RQ)<br />
<a href="https://www.fullstackpython.com/redis-queue-rq.html">https://www.fullstackpython.com/redis-queue-rq.html</a>
</li>

<li>Python Celery &amp; RabbitMQ Tutorial<br />
<a href="https://tests4geeks.com/python-celery-rabbitmq-tutorial/">https://tests4geeks.com/python-celery-rabbitmq-tutorial/</a>
</li>

<li>Flower: Real-time Celery web-monitor<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor">http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor</a>
</li>

<li>Asynchronous Tasks With Django and Celery<br />
<a href="https://realpython.com/asynchronous-tasks-with-django-and-celery/">https://realpython.com/asynchronous-tasks-with-django-and-celery/</a>
</li>

<li>First Steps with Celery<br />
<a href="http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html">http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html</a>
</li>

<li>node-celery<br />
<a href="https://github.com/mher/node-celery">https://github.com/mher/node-celery</a>
</li>

<li>Full Stack Python: web development<br />
<a href="https://www.fullstackpython.com/web-development.html">https://www.fullstackpython.com/web-development.html</a>
</li>

<li>Introducing RQ<br />
<a href="https://nvie.com/posts/introducing-rq/">https://nvie.com/posts/introducing-rq/</a>
</li>

<li>Asynchronous Tasks with Flask and Redis Queue<br />
<a href="https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue">https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Stránky projektu Redis<br />
<a href="https://redis.io/">https://redis.io/</a>
</li>

<li>Introduction to Redis<br />
<a href="https://redis.io/topics/introduction">https://redis.io/topics/introduction</a>
</li>

<li>Try Redis<br />
<a href="http://try.redis.io/">http://try.redis.io/</a>
</li>

<li>Redis tutorial, April 2010 (starší, ale pěkně udělaný)<br />
<a href="https://static.simonwillison.net/static/2010/redis-tutorial/">https://static.simonwillison.net/static/2010/redis-tutorial/</a>
</li>

<li>Python Redis<br />
<a href="https://redislabs.com/lp/python-redis/">https://redislabs.com/lp/python-redis/</a>
</li>

<li>Redis: key-value databáze v paměti i na disku<br />
<a href="https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/">https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/</a>
</li>

<li>Praktický úvod do Redis (1): vaše distribuovaná NoSQL cache<br />
<a href="http://www.cloudsvet.cz/?p=253">http://www.cloudsvet.cz/?p=253</a>
</li>

<li>Praktický úvod do Redis (2): transakce<br />
<a href="http://www.cloudsvet.cz/?p=256">http://www.cloudsvet.cz/?p=256</a>
</li>

<li>Praktický úvod do Redis (3): cluster<br />
<a href="http://www.cloudsvet.cz/?p=258">http://www.cloudsvet.cz/?p=258</a>
</li>

<li>Connection pool<br />
<a href="https://en.wikipedia.org/wiki/Connection_pool">https://en.wikipedia.org/wiki/Connection_pool</a>
</li>

<li>Instant Redis Sentinel Setup<br />
<a href="https://github.com/ServiceStack/redis-config">https://github.com/ServiceStack/redis-config</a>
</li>

<li>How to install REDIS in LInux<br />
<a href="https://linuxtechlab.com/how-install-redis-server-linux/">https://linuxtechlab.com/how-install-redis-server-linux/</a>
</li>

<li>Redis RDB Dump File Format<br />
<a href="https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format">https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format</a>
</li>

<li>Lempel–Ziv–Welch<br />
<a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch">https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch</a>
</li>

<li>Redis Persistence<br />
<a href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a>
</li>

<li>Redis persistence demystified<br />
<a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html">http://oldblog.antirez.com/post/redis-persistence-demystified.html</a>
</li>

<li>Redis reliable queues with Lua scripting<br />
<a href="http://oldblog.antirez.com/post/250">http://oldblog.antirez.com/post/250</a>
</li>

<li>Ost (knihovna)<br />
<a href="https://github.com/soveran/ost">https://github.com/soveran/ost</a>
</li>

<li>NoSQL<br />
<a href="https://en.wikipedia.org/wiki/NoSQL">https://en.wikipedia.org/wiki/NoSQL</a>
</li>

<li>Shard (database architecture)<br />
<a href="https://en.wikipedia.org/wiki/Shard_%28database_architecture%29">https://en.wikipedia.org/wiki/Shard_%28database_architecture%29</a>
</li>

<li>What is sharding and why is it important?<br />
<a href="https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important">https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important</a>
</li>

<li>What Is Sharding?<br />
<a href="https://btcmanager.com/what-sharding/">https://btcmanager.com/what-sharding/</a>
</li>

<li>Redis clients<br />
<a href="https://redis.io/clients">https://redis.io/clients</a>
</li>

<li>Category:Lua-scriptable software<br />
<a href="https://en.wikipedia.org/wiki/Category:Lua-scriptable_software">https://en.wikipedia.org/wiki/Category:Lua-scriptable_software</a>
</li>

<li>Seriál Programovací jazyk Lua<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-lua/">https://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>Redis memory usage<br />
<a href="http://nosql.mypopescu.com/post/1010844204/redis-memory-usage">http://nosql.mypopescu.com/post/1010844204/redis-memory-usage</a>
</li>

<li>Ukázka konfigurace Redisu pro lokální testování<br />
<a href="https://github.com/tisnik/presentations/blob/master/redis/redis.conf">https://github.com/tisnik/presentations/blob/master/redis/redis.conf</a>
</li>

<li>Resque<br />
<a href="https://github.com/resque/resque">https://github.com/resque/resque</a>
</li>

<li>Nested transaction<br />
<a href="https://en.wikipedia.org/wiki/Nested_transaction">https://en.wikipedia.org/wiki/Nested_transaction</a>
</li>

<li>Publish–subscribe pattern<br />
<a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern</a>
</li>

<li>Messaging pattern<br />
<a href="https://en.wikipedia.org/wiki/Messaging_pattern">https://en.wikipedia.org/wiki/Messaging_pattern</a>
</li>

<li>Using pipelining to speedup Redis queries<br />
<a href="https://redis.io/topics/pipelining">https://redis.io/topics/pipelining</a>
</li>

<li>Pub/Sub<br />
<a href="https://redis.io/topics/pubsub">https://redis.io/topics/pubsub</a>
</li>

<li>ZeroMQ distributed messaging<br />
<a href="http://zeromq.org/">http://zeromq.org/</a>
</li>

<li>ZeroMQ: Modern &amp; Fast Networking Stack<br />
<a href="https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/">https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/</a>
</li>

<li>Publish/Subscribe paradigm: Why must message classes not know about their subscribers?<br />
<a href="https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr">https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr</a>
</li>

<li>Python &amp; Redis PUB/SUB<br />
<a href="https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7">https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7</a>
</li>

<li>Message broker<br />
<a href="https://en.wikipedia.org/wiki/Message_broker">https://en.wikipedia.org/wiki/Message_broker</a>
</li>

<li>RESP Arrays<br />
<a href="https://redis.io/topics/protocol#array-reply">https://redis.io/topics/protocol#array-reply</a>
</li>

<li>Redis Protocol specification<br />
<a href="https://redis.io/topics/protocol">https://redis.io/topics/protocol</a>
</li>

<li>Redis Pub/Sub: Intro Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-intro/">https://www.redisgreen.net/blog/pubsub-intro/</a>
</li>

<li>Redis Pub/Sub: Howto Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-howto/">https://www.redisgreen.net/blog/pubsub-howto/</a>
</li>

<li>Comparing Publish-Subscribe Messaging and Message Queuing<br />
<a href="https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message">https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message</a>
</li>

<li>Apache Kafka<br />
<a href="https://kafka.apache.org/">https://kafka.apache.org/</a>
</li>

<li>Iron<br />
<a href="http://www.iron.io/mq">http://www.iron.io/mq</a>
</li>

<li>kue (založeno na Redisu, určeno pro node.js)<br />
<a href="https://github.com/Automattic/kue">https://github.com/Automattic/kue</a>
</li>

<li>Cloud Pub/Sub<br />
<a href="https://cloud.google.com/pubsub/">https://cloud.google.com/pubsub/</a>
</li>

<li>Introduction to Redis Streams<br />
<a href="https://redis.io/topics/streams-intro">https://redis.io/topics/streams-intro</a>
</li>

<li>glob (programming)<br />
<a href="https://en.wikipedia.org/wiki/Glob_(programming)">https://en.wikipedia.org/wiki/Glob_(programming)</a>
</li>

<li>Why and how Pricing Assistant migrated from Celery to RQ - Paris.py<br />
<a href="https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2">https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2</a>
</li>

<li>Enqueueing internals<br />
<a href="http://python-rq.org/contrib/">http://python-rq.org/contrib/</a>
</li>

<li>queue — A synchronized queue class<br />
<a href="https://docs.python.org/3/library/queue.html">https://docs.python.org/3/library/queue.html</a>
</li>

<li>Queue – A thread-safe FIFO implementation<br />
<a href="https://pymotw.com/2/Queue/">https://pymotw.com/2/Queue/</a>
</li>

<li>Queues<br />
<a href="http://queues.io/">http://queues.io/</a>
</li>

<li>Windows Subsystem for Linux Documentation<br />
<a href="https://docs.microsoft.com/en-us/windows/wsl/about">https://docs.microsoft.com/en-us/windows/wsl/about</a>
</li>

<li>RestMQ<br />
<a href="http://restmq.com/">http://restmq.com/</a>
</li>

<li>ActiveMQ<br />
<a href="http://activemq.apache.org/">http://activemq.apache.org/</a>
</li>

<li>Amazon MQ<br />
<a href="https://aws.amazon.com/amazon-mq/">https://aws.amazon.com/amazon-mq/</a>
</li>

<li>Amazon Simple Queue Service<br />
<a href="https://aws.amazon.com/sqs/">https://aws.amazon.com/sqs/</a>
</li>

<li>Celery: Distributed Task Queue<br />
<a href="http://www.celeryproject.org/">http://www.celeryproject.org/</a>
</li>

<li>Disque, an in-memory, distributed job queue<br />
<a href="https://github.com/antirez/disque">https://github.com/antirez/disque</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Projekt RQ na PyPi<br />
<a href="https://pypi.org/project/rq/">https://pypi.org/project/rq/</a>
</li>

<li>rq-dashboard 0.3.12<br />
<a href="https://pypi.org/project/rq-dashboard/">https://pypi.org/project/rq-dashboard/</a>
</li>

<li>Job queue<br />
<a href="https://en.wikipedia.org/wiki/Job_queue">https://en.wikipedia.org/wiki/Job_queue</a>
</li>

<li>Why we moved from Celery to RQ<br />
<a href="https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq">https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq</a>
</li>

<li>Running multiple workers using Celery<br />
<a href="https://serverfault.com/questions/655387/running-multiple-workers-using-celery">https://serverfault.com/questions/655387/running-multiple-workers-using-celery</a>
</li>

<li>celery — Distributed processing<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.html">http://docs.celeryproject.org/en/latest/reference/celery.html</a>
</li>

<li>Chains<br />
<a href="https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains">https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains</a>
</li>

<li>Routing<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing">http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing</a>
</li>

<li>Celery Distributed Task Queue in Go<br />
<a href="https://github.com/gocelery/gocelery/">https://github.com/gocelery/gocelery/</a>
</li>

<li>Python Decorators<br />
<a href="https://wiki.python.org/moin/PythonDecorators">https://wiki.python.org/moin/PythonDecorators</a>
</li>

<li>Periodic Tasks<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html">http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html</a>
</li>

<li>celery.schedules<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab">http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab</a>
</li>

<li>Pros and cons to use Celery vs. RQ<br />
<a href="https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq">https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq</a>
</li>

<li>Priority queue<br />
<a href="https://en.wikipedia.org/wiki/Priority_queue">https://en.wikipedia.org/wiki/Priority_queue</a>
</li>

<li>Jupyter<br />
<a href="https://jupyter.org/">https://jupyter.org/</a>
</li>

<li>How IPython and Jupyter Notebook work<br />
<a href="https://jupyter.readthedocs.io/en/latest/architecture/how_jupyter_ipython_work.html">https://jupyter.readthedocs.io/en/latest/architecture/how_jupyter_ipython_work.html</a>
</li>

<li>Context Managers<br />
<a href="http://book.pythontips.com/en/latest/context_managers.html">http://book.pythontips.com/en/latest/context_managers.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

