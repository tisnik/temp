<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - vyu¾ití nástroje Javassist pro generování bajtkódu</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - vyu¾ití nástroje Javassist pro generování bajtkódu</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o virtuálním stroji Javy si uká¾eme nìkteré základní mo¾nosti nástroje Javassist. Tento nástroj lze pou¾ít pro programové generování bajtkódu, popø. pro cílenou modifikaci bajtkódù ji¾ existujících tøíd. Dnes si uká¾eme zejména zpùsob vytváøení tøídních atributù.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Vyu¾ití nástroje <strong>Javassist</strong> pro programové generování bajtkódu</a></p>
<p><a href="#k02">2. Pøidání tøídních atributù do generovaného bajtkódu</a></p>
<p><a href="#k03">3. Modifikátory atributù</a></p>
<p><a href="#k04">4. Zdrojový kód demonstraèního pøíkladu <strong>ClassGenerationTest2</strong></a></p>
<p><a href="#k05">5. Výsledná podoba bajtkódu tøídy vygenerované pøíkladem <strong>ClassGenerationTest2</strong></a></p>
<p><a href="#k06">6. Vytvoøení atributu typu pole</a></p>
<p><a href="#k07">7. Zdrojový kód demonstraèního pøíkladu <strong>ClassGenerationTest3</strong></a></p>
<p><a href="#k08">8. Výsledná podoba bajtkódu tøídy vygenerované pøíkladem <strong>ClassGenerationTest3</strong></a></p>
<p><a href="#k09">9. Repositáø se zdrojovými kódy obou demonstraèních pøíkladù</a></p>
<p><a href="#k10">10. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Vyu¾ití nástroje <strong>Javassist</strong> pro programové generování bajtkódu</h2>

<p>V&nbsp;dne¹ní èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyku Java i o virtuálním stroji Javy</a> si uká¾eme, jakým
zpùsobem je mo¾né pou¾ít nástroj <i>Javassist</i> pro vytváøení bajtkódu,
konkrétnì pro pøidávání tøídních (tj.&nbsp;statických) atributù do vytváøeného
bajtkódu. Pøipomeòme si, ¾e <i>Javassist</i> je knihovna èásteènì podobná
knihovnì <i>BCEL</i>. Obì tyto knihovny nabízí vývojáøùm programové rozhraní
(API) urèené pro vytváøení èi pro modifikaci bajtkódu jednotlivých tøíd èi
rozhraní. V&nbsp;pøípadì knihovny <i>Javassist</i> mají programátoøi
k&nbsp;dispozici jak vysokoúrovòové konstrukce (napøíklad vytvoøení metody
z&nbsp;øetìzce), tak i konstrukce nízkoúrovòové (postupné doplòování
jednotlivých &bdquo;strojových&ldquo; instrukcí JVM do tìl metod).
Vysokoúrovòové i nízkoúrovòové konstrukce je samozøejmì mo¾né navzájem
kombinovat, èeho¾ je mo¾né vyu¾ít napøíklad pøi programování interpretrù èi
pøekladaèù. My se dnes budeme zabývat pøevá¾nì vysokoúrovòovými konstrukcemi,
které jsou pøi vytváøení bajtkódu jednodu¹eji pou¾itelné.</p>

<p>Zaènìme popisem toho, jak se vytvoøí bajtkód prázdné tøídy. To je
v&nbsp;pøípadì pou¾ití <i>Javassistu</i> velmi jednoduché:</p>

<pre>
import java.io.IOException;
import javassist.*;
&nbsp;
    private static void <strong>generateClass</strong>() throws CannotCompileException, NotFoundException, IOException {
<i>        // ziskat vychozi class pool</i>
        ClassPool pool = ClassPool.getDefault();
&nbsp;
<i>        // vytvoreni nove verejne tridy</i>
        CtClass generatedClass = pool.makeClass("TestClass");
&nbsp;
<i>        // ulozeni bajtkodu na disk</i>
        generatedClass.writeFile();
    }
</pre>

<p>V&nbsp;tomto kódu se objevuje pøedev¹ím tøída <strong>ClassPool</strong>.
Instance této tøídy slou¾í jako kontejnery pro objekty typu
<strong>CtClass</strong> pøedstavující jednotlivé generované èi modifikované
tøídy (resp.&nbsp;jejich bajtkódy). Sice je mo¾né vytvoøit instanci tøídy
<strong>ClassPool</strong> s&nbsp;vyu¾itím konstruktoru, ov¹em vzhledem
k&nbsp;tomu, ¾e ve vìt¹inì pøípadù si vystaèíme s&nbsp;jedinou instancí této
tøídy, lze namísto toho pou¾ít metodu <strong>ClassPool.getDefault()</strong>,
která vrátí (a popø.&nbsp;i pøi svém prvním zavolání vytvoøí) výchozí kontejner
pro objekty <strong>CtClass</strong>.</p>

<p>Dále mù¾eme v&nbsp;ukázaném zdrojovém kódu nalézt volání metody
<strong>ClassPool.makeClass(jméno_tøídy)</strong>. Tato pøetí¾ená metoda slou¾í
k&nbsp;vytvoøení nové tøídy se zadaným jménem. V&nbsp;nástroji <i>Javassist</i>
je ka¾dá tøída reprezentována objektem typu <strong>CtClass</strong>. Poslední
volanou metodou je <strong>CtClass.writeFile()</strong>, která se pokusí ulo¾it
bajtkód tøídy do souboru. Jméno souboru se samozøejmì nemusí zadávat, proto¾e
je odvozeno od jména tøídy podle zásad popsaných ve specifikaci programovacího
jazyka Java (samotný nástroj <i>Javassist</i> navíc provádí základní kontrolu,
zda je zadáno korektní jméno tøídy).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Pøidání tøídních atributù do generovaného bajtkódu</h2>

<p>Do vytváøeného bajtkódu lze snadno pøidat i tøídní (statické) atributy.
Zatímco ka¾dá tøída je v&nbsp;nástroji <i>Javassist</i> pøedstavována objektem
typu <strong>CtClass</strong>, je ka¾dý statický i nestatický atribut
pøedstavován objektem typu <strong>CtField</strong>. Vytvoøení nového atributu
se provede pøes konstruktor tøídy <strong>CtField()</strong>, který je
pøetí¾ený a lze ho volat ve dvou variantách:</p>

<pre>
public CtField(CtField src, CtClass declaring)
public CtField(CtClass type, String name, CtClass declaring)
</pre>

<p>My vyu¾ijeme druhou podobu tohoto konstruktoru, pøi jeho¾ volání se pøedává
typ vytváøeného atributu, jeho jméno a odkaz na tøídu, v&nbsp;ní¾ bude atribut
deklarován. Jméno nového atributu je reprezentováno øetìzcem, tøída, v&nbsp;ní¾
je atribut deklarován, je typu <strong>CtClass</strong> a typ atributu je
takté¾ pøedstavován instancí tøídy <strong>CtClass</strong>. <i>Javassist</i>
nám v&nbsp;pøípadì pou¾ití atributù primitivních datových typù mù¾e pomoci,
proto¾e ji¾ obsahuje instance pøíslu¹ných &bdquo;typových&ldquo; tøíd:</p>

<pre>
public abstract class CtClass {
...
...
...
    public static CtClass booleanType;
    public static CtClass charType;
    public static CtClass byteType;
    public static CtClass shortType;
    public static CtClass intType;
    public static CtClass longType;
    public static CtClass floatType;
    public static CtClass doubleType;
    public static CtClass voidType;
...
...
...
}
</pre>

<p>Jakmile je atribut vytvoøen, tj.&nbsp;jakmile jsme získali instanci tøídy
<strong>CtField</strong>, je mo¾né ho pøidat do vytváøeného bajtkódu
s&nbsp;vyu¾itím pøetí¾ené metody <strong>CtClass.addField()</strong>:</p>

<pre>
CtClass.addField(CtField f)
CtClass.addField(CtField f, String init)
CtClass.addField(CtField f, CtField.Initializer init)
</pre>

<p>My v&nbsp;na¹em pøíkladu vyu¾ijeme druhou variantu této metody, která nabízí
mo¾nost inicializovat atribut hodnotou pøedanou formou øetìzce (pøi vytváøení
atributu se tento øetìzec parsuje a kontroluje, zda skuteènì obsahuje korektní
data). Podívejme se nyní na zpùsob pøidání tøí atributù do vytváøené tøídy.
Prozatím se bude jednat o nestatické atributy. Ka¾dému atributu je pøi
pøidávání do vytváøeného bajtkódu pøiøazena hodnota pøedaná sice formou
øetìzce, ov¹em ve skuteènosti se provede pøevod tohoto øetìzce na zadaný typ a
dokonce se pøi parsování øetìzce provádí napøíklad náhrada "1/2f" za skuteènou
hodnotu 0.5f:</p>

<pre>
<i>    /**</i>
<i>     * Pridani novych atributu do vytvarene tridy.</i>
<i>     *</i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu ci generovanem kodu</i>
<i>     */</i>
    private static void <strong>addStaticVariables</strong>(CtClass generatedClass) throws CannotCompileException {
        CtField intAttribute = new CtField(CtClass.intType, "intAttribute", generatedClass);
        generatedClass.addField(intAttribute, "42");
&nbsp;
        CtField floatAttribute = new CtField(CtClass.floatType, "floatAttribute", generatedClass);
        generatedClass.addField(floatAttribute, "1/2f");
&nbsp;
        CtField booleanAttribute = new CtField(CtClass.booleanType, "booleanAttribute", generatedClass);
        generatedClass.addField(booleanAttribute, "true");
    }
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Modifikátory atributù</h2>

<p><a href="#k02">V&nbsp;pøedchozí kapitole</a> jsme si ukázali, jak se vytvoøí
nestatické atributy. My v¹ak potøebujeme vytvoøit atributy tøídní (statické) a
navíc je¹tì pro demonstraci mo¾ností knihovny <i>Javassist</i> budeme chtít
zmìnit pøístupová práva k&nbsp;tìmto atributùm. Ve skuteènosti je to velmi
jednoduché, proto¾e tøída <strong>CtField</strong> (pøedstavující atributy
v&nbsp;generovaném bajtkódu) nabízí metodu:</p>

<pre>
public void setModifiers(int mod)
</pre>

<p>urèenou pro nastavení takzvaných modifikátorù atributù. Èíslo pøedané této
metodì je slo¾eno z&nbsp;nìkolika bitových pøíznakù, které najdeme ve tøídì
<strong>Modifier</strong>:</p>

<pre>
    public static final int PUBLIC    = AccessFlag.PUBLIC;
    public static final int PRIVATE   = AccessFlag.PRIVATE;
    public static final int PROTECTED = AccessFlag.PROTECTED;
    public static final int STATIC    = AccessFlag.STATIC;
    public static final int FINAL     = AccessFlag.FINAL;
    public static final int SYNCHRONIZED = AccessFlag.SYNCHRONIZED;
    public static final int VOLATILE  = AccessFlag.VOLATILE;
    public static final int VARARGS = AccessFlag.VARARGS;
    public static final int TRANSIENT = AccessFlag.TRANSIENT;
    public static final int NATIVE    = AccessFlag.NATIVE;
    public static final int INTERFACE = AccessFlag.INTERFACE;
    public static final int ABSTRACT  = AccessFlag.ABSTRACT;
    public static final int STRICT    = AccessFlag.STRICT;
    public static final int ANNOTATION = AccessFlag.ANNOTATION;
    public static final int ENUM      = AccessFlag.ENUM;
</pre>

<p>Konkrétní hodnoty jsou uschovány v&nbsp;dal¹í tøídì
<strong>AccessFlag</strong>:</p>

<pre>
    public static final int PUBLIC    = 0x0001;
    public static final int PRIVATE   = 0x0002;
    public static final int PROTECTED = 0x0004;
    public static final int STATIC    = 0x0008;
    public static final int FINAL     = 0x0010;
    public static final int SYNCHRONIZED = 0x0020;
    public static final int VOLATILE  = 0x0040;
    public static final int BRIDGE    = 0x0040;     // for method_info
    public static final int TRANSIENT = 0x0080;
    public static final int VARARGS   = 0x0080;     // for method_info
    public static final int NATIVE    = 0x0100;
    public static final int INTERFACE = 0x0200;
    public static final int ABSTRACT  = 0x0400;
    public static final int STRICT    = 0x0800;
    public static final int SYNTHETIC = 0x1000;
    public static final int ANNOTATION = 0x2000;
    public static final int ENUM      = 0x4000;
</pre>

<p>Tyto hodnoty pøesnì odpovídají hodnotám ukládaným do bajtkódu a setkali jsme
se s&nbsp;nimi napøíklad ji¾ ve <a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-4-cast-dokonceni-popisu-struktury-souboru-class/#k03">21.
èásti tohoto seriálu ve tøetí kapitole</a>. Na základì pøedchozích informací
ji¾ mù¾eme upravit metodu pro vytváøení atributù takovým zpùsobem, aby se
vytváøely statické atributy se zvolenými právy pøístupu:</p>

<pre>
<i>    /**</i>
<i>     * Pridani novych tridnich atributu do vytvarene tridy.</i>
<i>     *</i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu ci generovanem kodu</i>
<i>     */</i>
    private static void <strong>addStaticVariables</strong>(CtClass generatedClass) throws CannotCompileException {
        CtField intAttribute = new CtField(CtClass.intType, "intAttribute", generatedClass);
        intAttribute.setModifiers(Modifier.STATIC | Modifier.PUBLIC);
        generatedClass.addField(intAttribute, "42");
&nbsp;
        CtField floatAttribute = new CtField(CtClass.floatType, "floatAttribute", generatedClass);
        floatAttribute.setModifiers(Modifier.STATIC | Modifier.PRIVATE);
        generatedClass.addField(floatAttribute, "1/2f");
&nbsp;
        CtField booleanAttribute = new CtField(CtClass.booleanType, "booleanAttribute", generatedClass);
        booleanAttribute.setModifiers(Modifier.STATIC | Modifier.FINAL | Modifier.PROTECTED);
        generatedClass.addField(booleanAttribute, "true");
    }
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Zdrojový kód demonstraèního pøíkladu <strong>ClassGenerationTest2</strong></h2>

<p>Koneènì se dostáváme k&nbsp;dne¹nímu prvnímu demonstraènímu pøíkladu
nazvanému <strong>ClassGenerationTest2</strong> (dvojka je zde proto, abychom
tento pøíklad odli¹ili od kódu uvedeného minule). V&nbsp;tomto pøíkladu se
nejdøíve vytvoøí kostra bajtkódu nové tøídy nazvané
<strong>GeneratedClass2</strong> a posléze se do této tøídy vlo¾í trojice
statických atributù pojmenovaných <strong>intAttribute</strong>,
<strong>floatAttribute</strong> a <strong>booleanAttribute</strong>. Následnì
je do bajtkódu tøídy vlo¾eno i pøelo¾ené tìlo metody <strong>main()</strong>,
která hodnotu v¹ech tøí tøídních atributù vypí¹e na standardní výstup:</p>

<pre>
import java.io.IOException;
&nbsp;
import javassist.CannotCompileException;
import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtField;
import javassist.CtMethod;
import javassist.Modifier;
import javassist.NotFoundException;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Test moznosti nastroje Javassist - vygenerovani jednoduche tridy</i>
<i> * s metodou main a nekolika tridnimi (statickymi) atributy.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>ClassGenerationTest2</strong> {
&nbsp;
<i>    /**</i>
<i>     * Jmeno vygenerovane tridy.</i>
<i>     */</i>
    private static final String <strong>GENERATED_CLASS_NAME</strong> = "GeneratedClass2";
&nbsp;
<i>    /**</i>
<i>     * Zdrojovy kod metody main(), ktery bude nasledne zkompilovan</i>
<i>     * do bajtkodu a zakomponovan do vytvorene tridy.</i>
<i>     */</i>
    private static final String <strong>MAIN_METHOD_SOURCE_TEXT</strong> =
        "public static void main(String[] args)" +
        "{" +
        "    System.out.println(intAttribute);" +
        "    System.out.println(floatAttribute);" +
        "    System.out.println(booleanAttribute);" +
        "}";
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni metody main() z jejiho zdrojoveho kodu.</i>
<i>     * </i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu</i>
<i>     */</i>
    private static void <strong>addMainMethod</strong>(CtClass generatedClass) throws CannotCompileException {
        CtMethod methodMain = CtMethod.make(MAIN_METHOD_SOURCE_TEXT, generatedClass);
        generatedClass.addMethod(methodMain);
    }
&nbsp;
<i>    /**</i>
<i>     * Pridani novych tridnich atributu do vytvarene tridy.</i>
<i>     *</i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu ci generovanem kodu</i>
<i>     */</i>
    private static void <strong>addStaticVariables</strong>(CtClass generatedClass) throws CannotCompileException {
        CtField intAttribute = new CtField(CtClass.intType, "intAttribute", generatedClass);
        intAttribute.setModifiers(Modifier.STATIC | Modifier.PUBLIC);
        generatedClass.addField(intAttribute, "42");
&nbsp;
        CtField floatAttribute = new CtField(CtClass.floatType, "floatAttribute", generatedClass);
        floatAttribute.setModifiers(Modifier.STATIC | Modifier.PRIVATE);
        generatedClass.addField(floatAttribute, "1/2f");
&nbsp;
        CtField booleanAttribute = new CtField(CtClass.booleanType, "booleanAttribute", generatedClass);
        booleanAttribute.setModifiers(Modifier.STATIC | Modifier.FINAL | Modifier.PROTECTED);
        generatedClass.addField(booleanAttribute, "true");
    }
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni tridy s metodou main().</i>
<i>     * </i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu metody main()</i>
<i>     * @throws IOException</i>
<i>     *             pokud dojde k chybe pri zapisu bajtkodu na disk</i>
<i>     * @throws NotFoundException</i>
<i>     *             pokud dojde k chybe pri zapisu bajtkodu na disk</i>
<i>     */</i>
    private static void <strong>generateClass</strong>() throws CannotCompileException, NotFoundException, IOException {
<i>        // ziskat vychozi class pool</i>
        ClassPool pool = ClassPool.getDefault();
&nbsp;
<i>        // vytvoreni nove verejne tridy</i>
        CtClass generatedClass = pool.makeClass(GENERATED_CLASS_NAME);
<i>        // pridani tridnich atributu</i>
        addStaticVariables(generatedClass);
<i>        // pridani metody do teto tridy</i>
        addMainMethod(generatedClass);
&nbsp;
<i>        // ulozeni bajtkodu na disk</i>
        generatedClass.writeFile();
    }
&nbsp;
<i>    /**</i>
<i>     * Spusteni generatoru tridy.</i>
<i>     *</i>
<i>     * @param args nevyuzito</i>
<i>     */</i>
    public static void <strong>main</strong>(String[] args) {
        System.out.println("class generation begin: " + GENERATED_CLASS_NAME);
        try {
            generateClass();
        }
        catch (CannotCompileException e) {
            e.printStackTrace();
        }
        catch (NotFoundException e) {
            e.printStackTrace();
        }
        catch (IOException e) {
            e.printStackTrace();
        }
        System.out.println("class generation end: " + GENERATED_CLASS_NAME);
    }
&nbsp;
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Výsledná podoba bajtkódu tøídy vygenerované pøíkladem <strong>ClassGenerationTest2</strong></h2>

<p>Demonstraèní pøíklad <strong>ClassGenerationTest2</strong> se pøelo¾í
následujícím skriptem, jen¾ pøedpokládá pøítomnost archivu
<i>javassist.jar</i>:</p>

<pre>
javac -cp javassist.jar ClassGenerationTest2.java
</pre>

<p>Spu¹tìní se provede pøíkazem:</p>

<pre>
java -cp .:javassist.jar ClassGenerationTest2
</pre>

<p>Po spu¹tìní by se v&nbsp;aktuálním adresáøi mìl vytvoøit soubor
<strong>GeneratedClass2.class</strong> obsahující novì vytvoøený bajtkód. Jeho
obsah je mo¾né si prohlédnout po zadání pøíkazu:</p>

<pre>
javap -c -private GeneratedClass2
</pre>

<pre>
Compiled from "GeneratedClass2.java"
public class GeneratedClass2 extends java.lang.Object{
&nbsp;
public static int intAttribute;
&nbsp;
private static float floatAttribute;
&nbsp;
protected static final boolean booleanAttribute;
&nbsp;
public static void main(java.lang.String[]);
  Code:
   0:	getstatic	#20; //Field java/lang/System.out:Ljava/io/PrintStream;
   3:	getstatic	#22; //Field intAttribute:I
   6:	invokevirtual	#28; //Method java/io/PrintStream.println:(I)V
   9:	getstatic	#20; //Field java/lang/System.out:Ljava/io/PrintStream;
   12:	getstatic	#30; //Field floatAttribute:F
   15:	invokevirtual	#33; //Method java/io/PrintStream.println:(F)V
   18:	getstatic	#20; //Field java/lang/System.out:Ljava/io/PrintStream;
   21:	getstatic	#35; //Field booleanAttribute:Z
   24:	invokevirtual	#38; //Method java/io/PrintStream.println:(Z)V
   27:	return
&nbsp;
public GeneratedClass2();
  Code:
   0:	aload_0
   1:	invokespecial	#43; //Method java/lang/Object."&lt;;init&gt;":()V
   4:	return
&nbsp;
static {};
  Code:
   0:	bipush	42
   2:	putstatic	#22; //Field intAttribute:I
   5:	ldc	#44; //float 0.5f
   7:	putstatic	#30; //Field floatAttribute:F
   10:	iconst_1
   11:	putstatic	#35; //Field booleanAttribute:Z
   14:	return
&nbsp;
}
&nbsp;
</pre>

<p>Pov¹imnìte si pøedev¹ím modifikátorù v¹ech tøí atributù i zpùsobu jejich
inicializace ve statickém bloku (blok oznaèený <strong>static{}</strong>).
Tímto zpùsobem se inicializují statické atributy i pøi pou¾ití bì¾ného
pøekladaèe Javy, tj.&nbsp;pøi pou¾ití nástroje <strong>javac</strong>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Vytvoøení atributu typu pole</h2>

<p>S&nbsp;tvorbou atributù primitivních datových typù jsme se seznámili
v&nbsp;pøedchozích kapitolách, z&nbsp;nich¾ je takté¾ patrné, ¾e se nejedná o
nijak slo¾itou problematiku &ndash; pøidání a popø.&nbsp;i inicializace
atributu je otázkou tøí èi ètyø volání metod ze tøíd, které jsou souèástí
nástroje <i>Javassist</i>. Ponìkud slo¾itìj¹í je v¹ak situace ve chvíli, kdy je
nutné vytvoøit atribut objektového typu, popø.&nbsp;atribut typu pole.
Podívejme se nejdøíve na zpùsob vytvoøení polí. Pole jsou zde chápána jako
dal¹í typ tøíd, tak¾e musíme být schopni získat obraz této tøídy pøedstavovaný
instancí <strong>CtClass</strong>. Pro tento úèel je mo¾né pou¾ít ji¾ vý¹e
zmínìný <strong>ClassPool</strong>, konkrétnì jeho metodu
<strong>get()</strong>, které se pøedá textová podoba pole:</p>

<pre>
        CtClass arrayClass = pool.get("int[]");
</pre>

<p>Ve chvíli, kdy máme k&nbsp;dispozici instanci <strong>CtClass</strong>
pøedstavující obraz pole (zde pole celých èísel), je ji¾ snadné do vytváøeného
bajtkódu pøidat nový atribut tohoto typu:</p>

<pre>
        CtField array = new CtField(arrayClass, "array", generatedClass);
        generatedClass.addField(array);
</pre>

<p>Celá metoda slou¾ící pro pøidání pole jako statického atributu vytváøené
tøídy má tvar:</p>

<pre>
    private static void <strong>addStaticArray</strong>(ClassPool pool, CtClass generatedClass) throws CannotCompileException, NotFoundException {
        CtClass arrayClass = pool.get("int[]");
        CtField array = new CtField(arrayClass, "array", generatedClass);
        array.setModifiers(Modifier.STATIC | Modifier.PUBLIC);
        generatedClass.addField(array);
    }
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Zdrojový kód demonstraèního pøíkladu <strong>ClassGenerationTest3</strong></h2>

<p>Dne¹ní druhý demonstraèní pøíklad, jeho¾ jméno je
<strong>ClassGenerationTest3</strong>, se od pøedchozího demonstraèního
pøíkladu odli¹uje pouze v&nbsp;tom ohledu, ¾e se namísto trojice atributù
primitivních datových typù vytváøí jediný atribut pøedstavující
neinicializované pole celých èísel. Namísto metody
<strong>addStaticVariables()</strong> je zde pou¾ita mírnì odli¹ná metoda
<strong>addStaticArray()</strong> popsaná v&nbsp;pøedchozí kapitole. Následuje
úplný výpis zdrojového kódu tohoto demonstraèního pøíkladu:</p>

<pre>
import java.io.IOException;
&nbsp;
import javassist.CannotCompileException;
import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtField;
import javassist.CtMethod;
import javassist.Modifier;
import javassist.NotFoundException;
&nbsp;
&nbsp;
&nbsp;
/<i>**</i>
<i> * Test moznosti nastroje Javassist - vygenerovani jednoduche tridy</i>
<i> * s metodou main a jednim tridnim atributem - polem.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>ClassGenerationTest3</strong> {
&nbsp;
<i>    /**</i>
<i>     * Jmeno vygenerovane tridy.</i>
<i>     */</i>
    private static final String <strong>GENERATED_CLASS_NAME</strong> = "GeneratedClass3";
&nbsp;
<i>    /**</i>
<i>     * Zdrojovy kod metody main(), ktery bude nasledne zkompilovan</i>
<i>     * do bajtkodu a zakomponovan do vytvorene tridy.</i>
<i>     */</i>
    private static final String <strong>MAIN_METHOD_SOURCE_TEXT</strong> =
        "public static void main(String[] args)" +
        "{" +
        "    System.out.println(array);" +
        "}";
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni metody main() z jejiho zdrojoveho kodu.</i>
<i>     * </i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu</i>
<i>     */</i>
    private static void <strong>addMainMethod</strong>(CtClass generatedClass) throws CannotCompileException {
        CtMethod methodMain = CtMethod.make(MAIN_METHOD_SOURCE_TEXT, generatedClass);
        generatedClass.addMethod(methodMain);
    }
&nbsp;
<i>    /**</i>
<i>     * Pridani noveho tridniho atributu do vytvarene tridy - pole.</i>
<i>     * @param pool </i>
<i>     *</i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu ci generovanem kodu</i>
<i>     * @throws NotFoundException</i>
<i>     *             vyhozena v pripade, ze se nenajde trida odpovidajici zapisu "int[]"</i>
<i>     */</i>
    private static void <strong>addStaticArray</strong>(ClassPool pool, CtClass generatedClass) throws CannotCompileException, NotFoundException {
        CtClass arrayClass = pool.get("int[]");
        CtField array = new CtField(arrayClass, "array", generatedClass);
        array.setModifiers(Modifier.STATIC | Modifier.PUBLIC);
        generatedClass.addField(array);
    }
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni tridy s metodou main().</i>
<i>     * </i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu metody main()</i>
<i>     * @throws IOException</i>
<i>     *             pokud dojde k chybe pri zapisu bajtkodu na disk</i>
<i>     * @throws NotFoundException</i>
<i>     *             pokud dojde k chybe pri zapisu bajtkodu na disk</i>
<i>     */</i>
    private static void <strong>generateClass</strong>() throws CannotCompileException, NotFoundException, IOException {
<i>        // ziskat vychozi class pool</i>
        ClassPool pool = ClassPool.getDefault();
&nbsp;
<i>        // vytvoreni nove verejne tridy</i>
        CtClass generatedClass = pool.makeClass(GENERATED_CLASS_NAME);
<i>        // pridani tridnich atributu</i>
        addStaticArray(pool, generatedClass);
<i>        // pridani metody do teto tridy</i>
        addMainMethod(generatedClass);
&nbsp;
<i>        // ulozeni bajtkodu na disk</i>
        generatedClass.writeFile();
    }
&nbsp;
<i>    /**</i>
<i>     * Spusteni generatoru tridy.</i>
<i>     *</i>
<i>     * @param args nevyuzito</i>
<i>     */</i>
    public static void <strong>main</strong>(String[] args) {
        System.out.println("class generation begin: " + GENERATED_CLASS_NAME);
        try {
            generateClass();
        }
        catch (CannotCompileException e) {
            e.printStackTrace();
        }
        catch (NotFoundException e) {
            e.printStackTrace();
        }
        catch (IOException e) {
            e.printStackTrace();
        }
        System.out.println("class generation end: " + GENERATED_CLASS_NAME);
    }
&nbsp;
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Výsledná podoba bajtkódu tøídy vygenerované pøíkladem <strong>ClassGenerationTest3</strong></h2>

<p>Pøeklad dne¹ního druhého demonstraèního pøíkladu se provede podobným
zpùsobem, s&nbsp;jakým jsme se ji¾ setkali u pøíkladu pøedchozího:</p>

<pre>
javac -cp javassist.jar ClassGenerationTest3.java
</pre>

<p>I jeho spu¹tìní je témìø shodné:</p>

<pre>
java -cp .:javassist.jar ClassGenerationTest2
</pre>

<p>Zajímavìj¹í je struktura vygenerovaného bajtkódu tøídy
<strong>GeneratedClass3</strong>. Tuto strukturu si opìt prohlédneme pomocí
standardního JDK nástroje <strong>javap</strong>:</p>

<pre>
javap -c -private GeneratedClass3
</pre>

<p>Z&nbsp;výpisu je patrné, ¾e je skuteènì vytvoøen statický atribut
pojmenovaný <strong>array</strong>, který je typu pole celých èísel (int[]),
ov¹em nedo¹lo k&nbsp;¾ádné inicializaci tohoto atributu:</p>

<pre>
Compiled from "GeneratedClass3.java"
public class GeneratedClass3 extends java.lang.Object{
&nbsp;
public static int[] array;
&nbsp;
public static void main(java.lang.String[]);
  Code:
   0:	getstatic	#16; //Field java/lang/System.out:Ljava/io/PrintStream;
   3:	getstatic	#18; //Field array:[I
   6:	invokevirtual	#24; //Method java/io/PrintStream.println:(Ljava/lang/Object;)V
   9:	return
&nbsp;
public GeneratedClass3();
  Code:
   0:	aload_0
   1:	invokespecial	#29; //Method java/lang/Object."<init>":()V
   4:	return
&nbsp;
}
</pre>

<p>Jakým zpùsobem lze tuto inicializaci provést, si &ndash; spoleènì
s&nbsp;dal¹ími informacemi &ndash; uká¾eme pøí¹tì.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Repositáø se zdrojovými kódy obou demonstraèních pøíkladù</h2>

<p>Zdrojové kódy obou dnes popsaných demonstraèních pøíkladù
<strong>ClassGenerationTest2</strong> a <strong>ClassGenerationTest3</strong>
jsou, spoleènì s&nbsp;pomocnými skripty, ulo¾eny do Mercurial repositáøe
dostupného na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
V&nbsp;následující tabulce najdete odkazy na prozatím nejnovìj¹í verze tìchto
zdrojových kódù:</p>

<table>
<tr><th>#</th><th>Zdrojový soubor/skript</th><th>Umístìní souboru v&nbsp;repositáøi</th></tr>
<tr><td>1</td><td>ClassGenerationTest2.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ac3bc585b54/javassist/ClassGenerationTest2/ClassGenerationTest2.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ac3bc585b54/javassist/ClassGenerationTest2/ClassGenerationTest2.java</a></td></tr>
<tr><td>2</td><td>buildClassGenerator2.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ac3bc585b54/javassist/ClassGenerationTest2/buildClassGenerator2.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ac3bc585b54/javassist/ClassGenerationTest2/buildClassGenerator2.sh</a></td></tr>
<tr><td>3</td><td>runClassGenerator2.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ac3bc585b54/javassist/ClassGenerationTest2/runClassGenerator2.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ac3bc585b54/javassist/ClassGenerationTest2/runClassGenerator2.sh</a></td></tr>
<tr><td>4</td><td>runGeneratedClass2.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ac3bc585b54/javassist/ClassGenerationTest2/runGeneratedClass2.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ac3bc585b54/javassist/ClassGenerationTest2/runGeneratedClass2.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>ClassGenerationTest3.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ac3bc585b54/javassist/ClassGenerationTest3/ClassGenerationTest3.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ac3bc585b54/javassist/ClassGenerationTest3/ClassGenerationTest3.java</a></td></tr>
<tr><td>6</td><td>buildClassGenerator3.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ac3bc585b54/javassist/ClassGenerationTest3/buildClassGenerator3.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ac3bc585b54/javassist/ClassGenerationTest3/buildClassGenerator3.sh</a></td></tr>
<tr><td>7</td><td>runClassGenerator3.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ac3bc585b54/javassist/ClassGenerationTest3/runClassGenerator3.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ac3bc585b54/javassist/ClassGenerationTest3/runClassGenerator3.sh</a></td></tr>
<tr><td>8</td><td>runGeneratedClass3.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ac3bc585b54/javassist/ClassGenerationTest3/runGeneratedClass3.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ac3bc585b54/javassist/ClassGenerationTest3/runGeneratedClass3.sh</a></td></tr>
</table>



<p><a name="k10"></a></p>
<h2 id="k10">10. Odkazy na Internetu</h2>

<ol>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (pøed verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

