<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - zpracování výjimek v JVM, Python VM a Lua VM</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - zpracování výjimek v JVM, Python VM a Lua VM</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Poslední porovnání virtuálního stroje Javy, VM jazyka Python a VM programovacího jazyka Lua se bude týkat zpùsobu zpracování výjimek. Jedná se o velmi dùle¾itou souèást prakticky v¹ech moderních virtuálních strojù a jak vyplyne z dal¹ího textu, mohou být výjimky zpracovány mnohdy i znaènì odli¹nými zpùsoby.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - zpracování výjimek v JVM, Python VM a Lua VM</a></p>
<p><a href="#k02">2. Porovnání zpùsobù práce s&nbsp;výjimkami v&nbsp;jazycích Java, Lua a Python</a></p>
<p><a href="#k03">3. Výjimky v&nbsp;programovacím jazyku Java</a></p>
<p><a href="#k04">4. Vyhození výjimky s&nbsp;vyu¾itím instrukce <strong>athrow</strong></a></p>
<p><a href="#k05">5. Demonstraèní pøíklad <strong>Test31.java</strong>: vyhození výjimky typu RuntimeException</a></p>
<p><a href="#k06">6. Pøeklad demonstraèního pøíkladu <strong>Test31.java</strong> do bajtkódu JVM</a></p>
<p><a href="#k07">7. Demonstraèní pøíklad <strong>Test32.java</strong>: vyhození výjimky typu Exception</a></p>
<p><a href="#k08">8. Pøeklad demonstraèního pøíkladu <strong>Test32.java</strong> do bajtkódu JVM</a></p>
<p><a href="#k09">9. Demonstraèní pøíklad <strong>Test33.java</strong>: implementace struktury try-catch</a></p>
<p><a href="#k10">10. Pøeklad demonstraèního pøíkladu <strong>Test33.java</strong> do bajtkódu JVM</a></p>
<p><a href="#k11">11. Demonstraèní pøíklad <strong>Test34.java</strong>: implementace struktury try-catch-finally</a></p>
<p><a href="#k12">12. Pøeklad demonstraèního pøíkladu <strong>Test34.java</strong> do bajtkódu JVM</a></p>
<p><a href="#k13">13. Repositáø se zdrojovými kódy v¹ech sedmi dne¹ních demonstraèních pøíkladù</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - zpracování výjimek v JVM, Python VM a Lua VM</h2>

<p>V&nbsp;pøedchozích èástech <a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-volani-funkci-a-pouziti-generatoru-i-uzaveru-v-python-vm-2/">tohoto
seriálu</a> jsme si popsali ji¾ prakticky v¹echny skupiny instrukcí, které je
mo¾né najít v&nbsp;bajtkódech urèených pro zpracování (bìh) ve virtuálních
strojích Javy (JVM), Pythonu (Python VM) i ve virtuálním stroji programovacího
jazyka Lua (Lua VM). Je¹tì si v¹ak musíme popsat jednu velmi dùle¾itou
vlastnost v¹ech tøí zmínìných bajtkódù &ndash; jedná se o instrukce a o
specializované datové struktury pou¾ité pøi zpracování výjimek i pøi
implementaci blokù
<strong>try</strong>-<strong>catch</strong>-<strong>finally</strong>
popø.&nbsp;jejich ekvivalentù (to se týká pøedev¹ím jazyka Lua, který tyto
bloky v&nbsp;souèasné verzi nepodporuje). Dnes se budeme zabývat pøevá¾nì
virtuálním strojem Javy, ov¹em v&nbsp;následující èásti tohoto seriálu si
osvìtlíme princip práce s&nbsp;výjimkami i ve virtuálním stroji Pythonu a
takté¾ Lua VM.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Porovnání zpùsobù práce s&nbsp;výjimkami v&nbsp;jazycích Java, Lua a Python</h2>

<p>Nejprve se na problematiku výjimek, vèetnì zpùsobu jejich vyhazování i
zachycování, podívejme z&nbsp;hlediska programátora vytváøejícího aplikace
v&nbsp;Javì, Pythonu èi v&nbsp;jazyku Lua. Teprve poté si vysvìtlíme zpùsob
práce s&nbsp;výjimkami pøímo v&nbsp;bajtkódu.</p>

<p>Zaènìme popisem práce s&nbsp;výjimkami v&nbsp;Javì. V&nbsp;tomto
programovacím jazyku má vývojáø k&nbsp;dispozici hned nìkolik klíèových slov
urèených jak pro oznaèení tìch výjimek, které mohou vzniknout v&nbsp;nìjaké
metodì (klíèové slovo <strong>throws</strong>), tak i pro samotné programové
vyhození výjimky zvoleného typu (klíèové slovo <strong>throw</strong>) i její
zachycení (struktura tvoøená dvojicí programových blokù
<strong>try-catch</strong> popø.&nbsp;roz¹íøená i o blok
<strong>finally</strong>). V&nbsp;prvním pøíkladu <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/673d8257fbd1/exceptions/ModuloByZero.java">ModuloByZero.java</a>
je ukázáno pou¾ití blokù <strong>try-catch-finally</strong> pøi výpoètu zbytku
po dìlení i pro korektní reakci na stav, kdy je dìlitel nulový. Pokud dojde
k&nbsp;dìlení nulou (a operace % takté¾ provádí dìlení), je vyhozena výjimka
typu <strong>ArithmeticException</strong>, která je následnì ve stejné metodì
zachycena a vhodným zpùsobem zpracována:</p>

<pre>
public class <strong>Test</strong> {
    public static void <strong>main</strong>(String[] args) {
        int x = 42;
        int y = 0;
        <strong>try</strong> {
            int z = x % y;
        }
        <strong>catch</strong> (ArithmeticException e) {
            System.out.println("div/mod by zero detected!");
            System.out.println(e);
        }
        <strong>finally</strong> {
            System.out.println("done");
        }
    }
}
</pre>

<p>Prakticky stejným zpùsobem jsou programové bloky
<strong>try-catch-finally</strong> implementovány i v&nbsp;programovacím jazyku
Python, a¾ na jeden nepatrný (syntaktický) rozdíl &ndash; namísto klíèového
slova <strong>catch</strong> se zde pou¾ívá slovo <strong>except</strong>.
Demonstraèní pøíklad <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/673d8257fbd1/exceptions/ModuloByZero.py">ModuloByZero.py</a>,
jeho¾ zdrojový kód je umístìn pod tímto odstavcem, se do znaèné míry podobá
vý¹e uvedenému pøíkladu <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/673d8257fbd1/exceptions/ModuloByZero.java">ModuloByZero.java</a>,
ov¹em samotný zápis je mnohem struènìj¹í (co¾ se ostatnì dá od Pythonu oèekávat
:-) a navíc i univerzálnìj¹í v&nbsp;pøípadì, ¾e bude operátor % pøetí¾en a
namísto èíselných promìnných <strong>x</strong> a <strong>y</strong> budou
pou¾ity objekty, které s&nbsp;operátorem % doká¾ou korektnì pracovat:</p>

<pre>
x = 42
y = 0
<strong>try</strong>:
    z = x % y
<strong>except</strong> ZeroDivisionError, e:
    print "div/mod by zero detected!"
    print e
<strong>finally</strong>:
    print "done"
</pre>

<p>Zcela odli¹ná je v¹ak implementace podobného pøíkladu v&nbsp;programovacím
jazyce Lua, a to z&nbsp;toho dùvodu, ¾e tento jazyk pøímo neobsahuje podporu
pro bloky <strong>try-catch-finally</strong>. Namísto toho je aplikován
&bdquo;funkcionální&ldquo; pøístup, kdy je ta èást programu, v&nbsp;ní¾ mù¾e
nastat nìjaká výjimka, umístìna do samostatné funkce, která se pak zavolá
v&nbsp;&bdquo;sandboxu&ldquo; s&nbsp;vyu¾itím funkce <strong>pcall()</strong>
(<i>protected call</i>). Výjimka se vyhazuje funkcí <strong>error()</strong> a
pokud výjimka skuteènì nastane, vrací funkce <strong>pcall()</strong> ve svém
prvním výsledku hodnotu <i>false</i> (dal¹í návratová hodnota èi návratové
hodnoty ji¾ souvisí s&nbsp;volanou funkcí). V&nbsp;demonstraèním pøíkladu <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/673d8257fbd1/exceptions/ModuloByZero.lua">ModuloByZero.lua</a>
je navíc pou¾it malý trik se zji¹tìním, zda pøi dìlení èi pøi operaci modulo
nedo¹lo k&nbsp;dìlení nulou, proto¾e Lua v&nbsp;tomto pøípadì automaticky
výjimku nevyhazuje (zmínìný trik je zalo¾en na normì IEEE 754 tvrdící, ¾e dvì
hodnoty NaN si nejsou nikdy rovny):</p>

<pre>
function <strong>mod</strong>(x, y)
    local result = x % y
    if result ~= result then
        <strong>error</strong>("ArithmeticException: / by zero")
    end
    return result
end
&nbsp;
local x = 42
local y = 0
&nbsp;
local status, result = <strong>pcall</strong>(mod , x, y)
print(status, result)
&nbsp;
x = 10
y = 3
&nbsp;
local status, result = <strong>pcall</strong>(mod , x, y)
print(status, result)
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Výjimky v&nbsp;programovacím jazyku Java</h2>

<p>V&nbsp;programovacím jazyku Java je zpracování výjimek nedílnou souèástí
syntaxe i sémantiky, a to ji¾ od první verze Javy. Toté¾ platí o bajtkódu JVM,
který obsahuje podporu pro instrukci <strong>athrow</strong> popsanou <a
href="#k04">ve ètvrté kapitole</a> a navíc se v&nbsp;bajtkódu pou¾ívají i
datové struktury popisující ty èásti bajtkódu, kde mù¾e vzniknout zachycovaná
výjimka èi výjimky. Díky této podpoøe a takté¾ s&nbsp;vyu¾itím podmínìných a
nepodmínìných skokù lze bloky <strong>try-catch-finally</strong>
v&nbsp;bajtkódu implementovat relativnì úsporným zpùsobem, co¾ bude ostatnì
ukázáno na demonstraèních pøíkladech <a href="#k05">Test31</a>, <a
href="#k07">Test32</a>, <a href="#k09">Test33</a> a koneènì <a
href="#k11">Test34</a>.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Vyhození výjimky s&nbsp;vyu¾itím instrukce <strong>athrow</strong></h2>

<p>Velmi dùle¾itou instrukcí, kterou mù¾eme v&nbsp;bajtkódu virtuálního stroje
Javy èasto nalézt, je instrukce nazvaná pøíznaènì <strong>athrow</strong>. Tato
instrukce slou¾í k&nbsp;vyhození výjimky, pøièem¾ pøi zavolání této instrukce
musí být reference na objekt reprezentující výjimku ulo¾ena na vrcholu
(<i>TOS</i>) zásobníku operandù (právì z&nbsp;tohoto dùvodu zaèíná jméno
instrukce znakem <strong>&bdquo;a&ldquo;</strong>, podobnì jako jména prakticky
v¹ech instrukcí zpracovávajících <i>reference</i> na objekty a nikoli
primitivní datové typy). Tato instrukce nemá ¾ádné dal¹í operandy (kromì
reference ulo¾ené na TOS), tak¾e její celková velikost je pøesnì jeden
bajt:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Provádìná operace</th></tr>
<tr><td>1</td><td>athrow</td><td>0xBF</td><td>&times;</td><td>vyhození výjimky</td></tr>
</table>

<p>Bajtkód ka¾dé metody navíc mù¾e obsahovat tabulku obsahující seznam výjimek,
které mohou nastat a adresy instrukcí, na nì¾ se provede skok ve chvíli, kdy
k&nbsp;dané výjimce skuteènì dojde. Pokud v¹ak tato tabulka není pøítomna,
popø.&nbsp;neobsahuje záznam s&nbsp;daným typem výjimky, je výjimka vyhozena
(<i>throw</i>) z&nbsp;metody a mù¾e být zachycena v&nbsp;nadøazených metodách,
opìt s&nbsp;vyu¾itím zmínìné tabulky. Podrobnosti si uká¾eme
v&nbsp;následujících ètyøech demonstraèních pøíkladech.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Demonstraèní pøíklad <strong>Test31.java</strong>: vyhození výjimky typu RuntimeException</h2>

<p>Zpùsob pøekladu Javovských programù, v&nbsp;nich¾ se pou¾ívají a
popø.&nbsp;i zpracovávají výjimky, si dnes uká¾eme na ètveøici velmi
jednoduchých demonstraèních pøíkladù. V&nbsp;prvním pøíkladu nazvaném
<strong>Test31</strong> se ve statické metodì pojmenované
<strong>throwRuntimeException()</strong> programovì vyhazuje výjimka typu
<strong>RuntimeException</strong>. Tento typ výjimky není zapotøebí zmiòovat
v&nbsp;hlavièce metody a dokonce ho není ani nutné v&nbsp;aplikaci explicitnì
zachytit (tyto kontroly provádí ji¾ pøekladaè <strong>javac</strong>, ov¹em
<strong>RuntimeException</strong> a od ní odvozené výjimky nepatøí mezi výjimky
kontrolované &ndash; <i>checked</i>). Pokud ov¹em k&nbsp;této výjimce pøi bìhu
programu skuteènì dojde a výjimka není nikde zachycena, bude bìh programu a tím
pádem i bìh virtuálního stroje Javy ukonèen a na terminál se vypí¹e klasický
<i>stack trace</i> (ponìkud odli¹né je ov¹em chování takové aplikace, kde
k&nbsp;výjimce dojde v&nbsp;jiném vláknu; zde k&nbsp;ukonèení celé JVM
nedojde). Podívejme se nyní na zdrojový kód tohoto velmi jednoduchého
demonstraèního pøíkladu:</p>

<pre>
<i>/**</i>
<i> * Demonstracni priklad cislo 31.</i>
<i> *</i>
<i> * Vyhozeni vyjimky typu RuntimeException z testovane metody.</i>
<i> */</i>
public class <strong>Test31</strong> {
&nbsp;
    <i>/**</i>
    <i> * Metoda, ktera vyhodi vyjimku typu RuntimeException()</i>
    <i> */</i>
    public static void <strong>throwRuntimeException</strong>() {
        throw new RuntimeException();
    }
&nbsp;
    <i>/**</i>
    <i> * Zavolani metody throwRuntimeException().</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        throwRuntimeException();
    }
&nbsp;
}
</pre>

<p>Po spu¹tìní tohoto demonstraèního pøíkladu se na terminálu objeví informace
o výjimce vyhozené z&nbsp;metody <strong>throwRuntimeException</strong> a
následnì i z&nbsp;metody <strong>main</strong>. Tato informace se vypí¹e je¹tì
pøedtím, ne¾ se ukonèí bìh virtuálního stroje Javy:</p>

<pre>
Exception in thread "main" java.lang.RuntimeException
    at Test31.throwRuntimeException(Test31.java:12)
    at Test31.main(Test31.java:19)
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Pøeklad demonstraèního pøíkladu <strong>Test31.java</strong> do bajtkódu JVM</h2>

<p>Pøeklad metody <strong>throwRuntimeException()</strong> do bajtkódu JVM je
velmi jednoduchý. V&nbsp;tìle této metody se nejdøíve vytvoøí a nále¾itì
inicializuje objekt tøídy <strong>RuntimeException</strong> a následnì je
pou¾ita instrukce <strong>athrow</strong> pro vyhození výjimky. Tato instrukce
po¾aduje, aby na TOS byla umístìna reference na objekt pøedstavující výjimku,
co¾ je i dùvod pou¾ití instrukce <strong>dup</strong>. Pov¹imnìte si, ¾e metoda
neobsahuje ¾ádné speciální oznaèení ani metadata øíkající, ¾e pøi jejím bìhu
mù¾e k&nbsp;výjimce skuteènì dojít:</p>

<pre>
  public static void <strong>throwRuntimeException</strong>();
    Code:
       0: new           #2;                 <i>// vytvoøení instance tøídy java.lang.RuntimeException</i>
       3: dup                               <i>// kopie reference na novì vytvoøený objekt</i>
                                            <i>// inicializace objektu</i>
       4: invokespecial #3;                 <i>// Method java/lang/RuntimeException."&lt;init&gt;":()V</i>
       7: athrow                            <i>// objekt byl inicializován, vyhození výjimky</i>
</pre>

<p>Ani pøi volání metody <strong>throwRuntimeException()</strong> není
zapotøebí ¾ádným zpùsobem specifikovat, ¾e mù¾e dojít k&nbsp;výjimce:</p>)

<pre>
  public static void <strong>main</strong>(java.lang.String[]);
    Code:
       0: invokestatic  #4;                 <i>// zavolání statické metody throwRuntimeException()</i>
       3: return                            <i>// ukonèení bìhu metody main()</i>
</pre>

<p>Pro úplnost je je¹tì vypsán obsah constant poolu, proto¾e vý¹e uvedené
bajtkódy pou¾ívaly záznamy ulo¾ené na indexech 2, 3 a 4 (a samozøejmì i záznamy
z&nbsp;tìchto záznamù referencované):</p>

<pre>
Constant pool:
   #1 = Methodref          #6.#16;        <i>//  java/lang/Object."&lt;init&gt;":()V</i>
   #2 = Class              #17;           <i>//  java/lang/RuntimeException</i>
   #3 = Methodref          #2.#16;        <i>//  java/lang/RuntimeException."&lt;init&gt;":()V</i>
   #4 = Methodref          #5.#18;        <i>//  Test31.throwRuntimeException:()V</i>
   #5 = Class              #19;           <i>//  Test31</i>
   #6 = Class              #20;           <i>//  java/lang/Object</i>
   #7 = Utf8               &lt;init&gt;;
   #8 = Utf8               ()V;
   #9 = Utf8               Code;
  #10 = Utf8               LineNumberTable;
  #11 = Utf8               throwRuntimeException;
  #12 = Utf8               main;
  #13 = Utf8               ([Ljava/lang/String;)V;
  #14 = Utf8               SourceFile;
  #15 = Utf8               Test31.java;
  #16 = NameAndType        #7:#8;         <i>//  "&lt;init&gt;":()V</i>
  #17 = Utf8               java/lang/RuntimeException;
  #18 = NameAndType        #11:#8;        <i>//  throwRuntimeException:()V</i>
  #19 = Utf8               Test31;
  #20 = Utf8               java/lang/Object;
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Demonstraèní pøíklad <strong>Test32.java</strong>: vyhození výjimky typu Exception</h2>

<p>Zdrojový kód demonstraèního pøíkladu <strong>Test32.java</strong> se do
znaèné míry podobá zdrojovému kódu <a href="#k05">vý¹e uvedeného</a> pøíkladu
<strong>Test31.java</strong>. Najdeme zde v¹ak tøi odli¹nosti. První odli¹nost
spoèívá v&nbsp;tom, ¾e se namísto výjimky typu
<strong>RuntimeException</strong> programovì vyhazuje výjimka typu
<strong>Exception</strong>. S&nbsp;tím souvisí i dal¹í dvì zmìny &ndash;
výjimky typu <strong>Exception</strong> (a samozøejmì i v¹echny odvozené
výjimky) je zapotøebí buï explicitnì zachytit nebo (opìt explicitnì) u metod,
kde mù¾e výjimka vzniknout, pou¾ít zápis <strong>throws Exception</strong>, aby
tak vývojáø dal pøekladaèi Javy najevo, ¾e se zpracováním výjimky tohoto typu
ve své aplikaci poèítá. Právì z&nbsp;tohoto dùvodu jsou v&nbsp;hlavièkách obou
statických funkcí deklarovaných ve tøídì <strong>Test32</strong> pou¾ity zápisy
<strong>throws Exception</strong>; v&nbsp;opaèném pøípadì by nebylo mo¾né
provést úspì¹ný pøeklad tohoto pøíkladu:</p>

<pre>
<i>/**</i>
<i> * Demonstracni priklad cislo 32.</i>
<i> *</i>
<i> * Vyhozeni vyjimky typu Exception z testovane metody.</i>
<i> */</i>
public class <strong>Test32</strong> {
&nbsp;
    <i>/**</i>
    <i> * Metoda, ktera vyhodi vyjimku typu Exception()</i>
    <i> */</i>
    public static void <strong>throwException</strong>() throws Exception {
        throw new Exception();
    }
&nbsp;
    <i>/**</i>
    <i> * Zavolani metody throwException().</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) throws Exception {
        throwException();
    }
&nbsp;
}
</pre>

<p>I po spu¹tìní tohoto demonstraèního pøíkladu dojde k&nbsp;ukonèení bìhu
virtuálního stroje Javy. Opìt se vypí¹e i historie volání metod ulo¾ených
v&nbsp;jednotlivých zásobníkových rámcích:</p>

<pre>
Exception in thread "main" java.lang.Exception
    at Test32.throwException(Test32.java:12)
    at Test32.main(Test32.java:19)
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Pøeklad demonstraèního pøíkladu <strong>Test32.java</strong> do bajtkódu JVM</h2>

<p>Velmi zajímavé bude zjistit, do jaké míry se budou odli¹ovat bajtkódy tøíd
<strong>Test31</strong> a <strong>Test32</strong>. Pøeklad metody
<strong>throwException()</strong>:</p>

<pre>
  public static void <strong>throwException</strong>() throws java.lang.Exception;
    Code:
       0: new           #2;                 <i>// vytvoøení instance tøídy java.lang.Exception</i>
       3: dup                               <i>// kopie reference na novì vytvoøený objekt</i>
                                            <i>// inicializace objektu</i>
       4: invokespecial #3;                 <i>// Method java/lang/Exception."&lt;init&gt;":()V</i>
       7: athrow                            <i>// objekt byl inicializován, vyhození výjimky</i>
</pre>

<p>Vidíme, ¾e jediný rozdíl spoèívá v&nbsp;pøidané deklaraci &bdquo;throws
java.lang.Exception;&ldquo;, co¾ lze pova¾ovat za metadata bajtkódu.</p>

<p>Pøeklad metody <strong>main()</strong>:</p>

<pre>
  public static void <strong>main</strong>(java.lang.String[]) throws java.lang.Exception;
    Code:
       0: invokestatic  #4;                 <i>// zavolání statické metody throwException:()V</i>
       3: return                            <i>// ukonèení bìhu metody main()</i>
</pre>

<p>I zde do¹lo pouze k&nbsp;pøidání deklarace &bdquo;throws
java.lang.Exception&ldquo;. ®ádné dal¹í zmìny v&nbsp;bajtkódu nenajdeme.</p>

<p>Na závìr bude opìt vypsán obsah constant poolu bajtkódu tøídy
<strong>Test32</strong>:</p>

<pre>
   #1 = Methodref          #6.#17;        <i>//  java/lang/Object."&lt;init&gt;":()V</i>
   #2 = Class              #18;           <i>//  java/lang/Exception</i>
   #3 = Methodref          #2.#17;        <i>//  java/lang/Exception."&lt;init&gt;":()V</i></i>
   #4 = Methodref          #5.#19;        <i>//  Test32.throwException:()V</i>
   #5 = Class              #20;           <i>//  Test32</i>
   #6 = Class              #21;           <i>//  java/lang/Object</i>
   #7 = Utf8               &lt;init&gt;;
   #8 = Utf8               ()V;
   #9 = Utf8               Code;
  #10 = Utf8               LineNumberTable;
  #11 = Utf8               throwException;
  #12 = Utf8               Exceptions;    <strong>*** pøidaný záznam ***</strong>
  #13 = Utf8               main;
  #14 = Utf8               ([Ljava/lang/String;)V;
  #15 = Utf8               SourceFile;
  #16 = Utf8               Test32.java;
  #17 = NameAndType        #7:#8;         <i>//  "&lt;init&gt;":()V</i>
  #18 = Utf8               java/lang/Exception;
  #19 = NameAndType        #11:#8;        <i>//  throwException:()V</i>
  #20 = Utf8               Test32;
  #21 = Utf8               java/lang/Object;
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Demonstraèní pøíklad <strong>Test33.java</strong>: implementace struktury try-catch</h2>

<p>Demonstraèní pøíklad nazvaný <strong>Test33.java</strong> se od obou
pøedchozích demonstraèních pøíkladù odli¹uje, proto¾e zde výjimku vyhazovanou
z&nbsp;metody pojmenované <strong>throwException()</strong> zachycujeme, a to
(samozøejmì) v&nbsp;bloku <strong>catch</strong>, kterému pøedchází blok
<strong>try</strong>. Vzhledem k&nbsp;tomu, ¾e výjimka je pøi volání statické
metody <strong>throwException()</strong> skuteènì vyhozena v¾dy, není pøíkaz
&bdquo;System.out.println("try block");&ldquo; umístìný v&nbsp;bloku
<strong>try</strong> nikdy proveden; namísto toho je naopak v¾dy proveden
pøíkaz &bdquo;System.out.println("catch block");&ldquo; umístìný v&nbsp;bloku
<strong>catch</strong>:</p>

<pre>
<i>/**</i>
<i> * Demonstracni priklad cislo 33.</i>
<i> *</i>
<i> * Implementace struktury try-catch.</i>
<i> */</i>
public class <strong>Test33</strong> {
&nbsp;
    <i>/**</i>
    <i> * Metoda, ktera vyhodi vyjimku typu Exception()</i>
    <i> */</i>
    public static void <strong>throwException</strong>() throws Exception {
        throw new Exception();
    }
&nbsp;
    <i>/**</i>
    <i> * Zavolani metody throwException().</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) throws Exception {
        try {
            throwException();
            System.out.println("try block");
        }
        catch (Exception e) {
            System.out.println("catch block");
        }
    }
&nbsp;
}
</pre>

<p>Pøi spu¹tìní tohoto pøíkladu se na standardním výstupu zobrazí (podle v¹ech
oèekávání) jediný øádek textu:</p>

<pre>
catch block
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Pøeklad demonstraèního pøíkladu <strong>Test33.java</strong> do bajtkódu JVM</h2>

<p>Bajtkód demonstraèního pøíkladu <strong>Test33.java</strong> ji¾ musí
obsahovat instrukce zaji¹»ující zachycení a zpracování výjimky, proto bude
velmi zajímavé ho prozkoumat. Metoda <strong>throwException()</strong> se
pøelo¾í naprosto stejným zpùsobem, jaký ji¾ známe z&nbsp;pøedchozího
pøíkladu:</p>

<pre>
  public static void <strong>throwException</strong>() throws java.lang.Exception;
    Code:
       0: new           #2;                 <i>// vytvoøení instance tøídy java.lang.Exception</i>
       3: dup                               <i>// kopie reference na novì vytvoøený objekt</i>
                                            <i>// inicializace objektu</i>
       4: invokespecial #3;                 <i>// Method java/lang/Exception."&lt;init&gt;":()V</i>
       7: athrow                            <i>// objekt byl inicializován, vyhození výjimky</i>
</pre>

<p>Ov¹em bajtkód metody <strong>main()</strong> je ji¾ komplikovanìj¹í:</p>

<pre>
  public static void <strong>main</strong>(java.lang.String[]) throws java.lang.Exception;
    Code:
      <strong>*** blok try ***</strong>
       0: invokestatic  #4;                 <i>// volání metody throwException:()V</i>
                                            <i>// pøíprava na volání metody System.out.println()</i>
       3: getstatic     #5;                 <i>// Field java/lang/System.out:Ljava/io/PrintStream;</i>
       6: ldc           #6;                 <i>// konstanta obsahující øetìzec "try block"</i>
       8: invokevirtual #7;                 <i>// volání metody java.io.PrintStream.println:(java.lang.String)</i>
      11: goto          23                  <i>// skok ZA konec bloku <strong>catch</strong></i>
&nbsp;
      <strong>*** blok catch ***</strong>
      14: astore_1                          <i>// zaèátek bloku <strong>catch</strong></i>
                                            <i>// pøíprava na volání metody System.out.println()</i>
      15: getstatic     #5;                 <i>// Field java/lang/System.out:Ljava/io/PrintStream;</i>
      18: ldc           #8;                 <i>// konstanta obsahujici retezec "catch block"</i>
      20: invokevirtual #7;                 <i>// volání metody java.io.PrintStream.println:(java.lang.String)</i>
&nbsp;
    <strong>*** konec konstrukce try-catch ***</strong>
      23: return                            <i>// ukonèení bìhu metody main()</i>
&nbsp;
    Exception table:                        <i>// tabulka obsahující seznam øádkù a pøípadných výjimek</i>
       from    to  target type
           0    11    14   Class java/lang/Exception
</pre>

<p>V&nbsp;tomto bajtkódu ji¾ mù¾eme vidìt dvì novinky. První novinka je vlastnì
oèekávaná &ndash; první sekvence instrukcí pøedstavuje tìlo bloku
<strong>try</strong>, druhá sekvence instrukcí pak tìlo bloku
<strong>catch</strong>. Na konci tìla prvního bloku je umístìna instrukce
<strong>goto</strong> provádìjící nepodmínìný skok za úèelem pøeskoku celého
bloku <strong>catch</strong>. Za jakých okolností je tìlo bloku
<strong>catch</strong> provedeno je specifikováno v&nbsp;datové struktuøe
<strong>Exception table</strong>. Zde jsou ulo¾eny záznamy obsahující rozsah
indexù instrukcí, kde mù¾e dojít k&nbsp;výjimce, index instrukce, na kterou se
skoèí v&nbsp;pøípadì skuteèného vzniku výjimky a samozøejmì i typ výjimky.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Demonstraèní pøíklad <strong>Test34.java</strong>: implementace struktury try-catch-finally</h2>

<p>Dne¹ní poslední demonstraèní pøíklad nazvaný <strong>Test34.java</strong> je
vlastnì obdobou <a href="#k09">pøedchozího pøíkladu</a>
<strong>Test33.java</strong>, ov¹em namísto neúplné struktury
<strong>try-catch</strong> je zde implementována úplná programová struktura
<strong>try-catch-finally</strong>, pøièem¾ pøíkazy umístìné v&nbsp;bloku
<strong>finally</strong> jsou vykonány v¾dy, nezávisle na tom, zda
k&nbsp;zachycované výjimce dojde èi nikoli:</p>

<pre>
<i>/**</i>
<i> * Demonstracni priklad cislo 34.</i>
<i> *</i>
<i> * Implementace struktury try-catch-finally.</i>
<i> */</i>
public class <strong>Test34</strong> {
&nbsp;
    <i>/**</i>
    <i> * Metoda, ktera vyhodi vyjimku typu Exception()</i>
    <i> */</i>
    public static void <strong>throwException</strong>() throws Exception {
        throw new Exception();
    }
&nbsp;
    <i>/**</i>
    <i> * Zavolani metody throwException().</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) throws Exception {
        try {
            throwException();
            System.out.println("try block");
        }
        catch (Exception e) {
            System.out.println("catch block");
        }
        finally {
            System.out.println("finally block");
        }
    }
&nbsp;
}
</pre>

<p>Podle oèekávání dojde pøi spu¹tìní tohoto pøíkladu k&nbsp;výpisu pouze dvou
øetìzcù na standardní výstup:</p>

<pre>
catch block
finally block
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Pøeklad demonstraèního pøíkladu <strong>Test34.java</strong> do bajtkódu JVM</h2>

<p>Opìt si uka¾me, jak se obì metody deklarované ve tøídì
<strong>Test34</strong> pøelo¾í do bajtkódu JVM. Zaèneme bajtkódem metody
<strong>throwException()</strong>, proto¾e v&nbsp;nìm nenalezneme ¾ádné
odli¹nosti od pøedchozího pøíkladu:</p>

<pre>
  public static void <strong>throwException</strong>() throws java.lang.Exception;
    Code:
       0: new           #2;                 <i>// vytvoøení instance tøídy java.lang.Exception</i>
       3: dup                               <i>// kopie reference na novì vytvoøený objekt</i>
                                            <i>// inicializace objektu</i>
       4: invokespecial #3;                 <i>// Method java/lang/Exception."&lt;init&gt;":()V</i>
       7: athrow                            <i>// objekt byl inicializován, vyhození výjimky</i>
</pre>

<p>Bajtkód metody <strong>main()</strong> je v¹ak ji¾ velmi rozsáhlý a najdeme
zde hned nìkolik nepodmínìných skokù realizovaných instrukcí
<strong>goto</strong>:</p>

<pre>
  public static void <strong>main</strong>(java.lang.String[]) throws java.lang.Exception;
    Code:
      <strong>*** blok try ***</strong>
       0: invokestatic  #4;                 <i>// volání metody throwException:()V</i>
                                            <i>// pøíprava na volání metody System.out.println()</i>
       3: getstatic     #5;                 <i>// Field java/lang/System.out:Ljava/io/PrintStream;</i>
       6: ldc           #6;                 <i>// konstanta obsahující øetìzec "try block"</i>
       8: invokevirtual #7;                 <i>// volání metody java.io.PrintStream.println:(java.lang.String)</i>
&nbsp;
      <strong>*** blok finally #1 ***</strong>
                                            <i>// pøíprava na volání metody System.out.println()</i>
      11: getstatic     #5;                 <i>// Field java/lang/System.out:Ljava/io/PrintStream;</i>
      14: ldc           #8;                 <i>// konstanta obsahující øetìzec "finally block"</i>
      16: invokevirtual #7;                 <i>// volání metody java.io.PrintStream.println:(java.lang.String)</i>
      19: goto          53                  <i>// skok ZA konec bloku <strong>finally</strong></i>
&nbsp;
      <strong>*** blok catch ***</strong>
      22: astore_1      
      23: getstatic     #5;                 <i>// Field java/lang/System.out:Ljava/io/PrintStream;</i>
      26: ldc           #9;                 <i>// konstanta obsahující øetìzec "catch block"</i>
      28: invokevirtual #7;                 <i>// volání metody java.io.PrintStream.println:(java.lang.String)</i>
&nbsp;
      <strong>*** blok finally #2 ***</strong>
      31: getstatic     #5;                 <i>// Field java/lang/System.out:Ljava/io/PrintStream;</i>
      34: ldc           #8;                 <i>// konstanta obsahující øetìzec "finally block"</i>
      36: invokevirtual #7;                 <i>// volání metody java.io.PrintStream.println:(java.lang.String)</i>
      39: goto          53                  <i>// skok ZA konec bloku <strong>finally</strong></i>
&nbsp;
      <strong>*** blok finally #3 - zachycení + rethrow jiné výjimky ***</strong>
      42: astore_2                          <i>// ulo¾it obsah TOS do lokální promìnné</i>
      43: getstatic     #5;                 <i>// Field java/lang/System.out:Ljava/io/PrintStream;</i>
      46: ldc           #8;                 <i>// konstanta obsahující øetìzec "finally block"</i>
      48: invokevirtual #7;                 <i>// volání metody java.io.PrintStream.println:(java.lang.String)</i>
      51: aload_2                           <i>// obnovit obsah TOS</i>
      52: athrow                            <i>// a ihned vyvolat výjimku, kterou jsme zachytili jen doèasnì</i>
&nbsp;
      53: return                            <i>// ukonèení bìhu metody main()</i>
&nbsp;
    Exception table:                        <i>// tabulka obsahující seznam øádkù a pøípadných výjimek</i>
       from    to  target type
           0    11    22   Class java/lang/Exception <i>// blok <strong>try</strong></i>
           0    11    42   any                       <i>// bloky <strong>try+finally #1</strong></i>
          22    31    42   any                       <i>// blok <strong>catch</strong></i>
          42    43    42   any                       <i>// instrukce zachycení jiné výjimky</i>
</pre>

<p>Tento bajtkód sice mù¾e vypadat ponìkud nepøehlednì, ale ukázaný zpùsob
pøekladu má své velmi dobré dùvody. &bdquo;Bì¾né&ldquo; chování metody je
implementováno v&nbsp;instrukcích umístìných na indexech 0 a¾ 11. Zde mù¾eme
vidìt jak implementaci v¹ech pøíkazù v&nbsp;bloku <strong>try</strong>, tak i
implementaci v¹ech pøíkazù v&nbsp;bloku <strong>finally</strong>. To je vlastnì
logické, proto¾e kdy¾ nedojde ke vzniku výjimky, vykonají se právì tyto dva
bloky v&nbsp;uvedeném poøadí (napøed blok <strong>try</strong>, poté blok
<strong>finally</strong>).</p>

<p>V&nbsp;tabulce výjimek mù¾eme vidìt, ¾e instrukce od indexu 0 do indexu 11
jsou zde zmínìny hned dvakrát &ndash; pokud zde dojde k&nbsp;výjimce
<strong>Exception</strong> (kterou zachytáváme), provedou se bloky
<strong>catch+finally #2</strong>, které zaèínají na indexu 22. To je také
oèekávané chování, které je explicitnì zapsáno ve zdrojovém kódu. Zajímavìj¹í
je pøedposlední blok <strong>finally</strong> vykonaný ve chvíli, kdy vznikne
jiný typ výjimky. I v&nbsp;tomto pøípadì je toti¾ nutné vypsat øetìzec
&bdquo;finally block&ldquo;, ale navíc musí neznámá výjimka
&bdquo;probublat&ldquo; do volající metody, a to ji¾ známým zpùsobem:
s&nbsp;vyu¾itím instrukce <strong>athrow</strong>.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Repositáø se zdrojovými kódy v¹ech sedmi dne¹ních demonstraèních pøíkladù</h2>

<p>V¹ech sedm (3+4) dnes popsaných a &bdquo;disasemblovaných&ldquo;
demonstraèních pøíkladù bylo ulo¾eno do Mercurial repositáøe umístìného na
adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>
(revize s&nbsp;kódy <a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/rev/320255fc8ed7">320255fc8ed7</a> a <a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/rev/673d8257fbd1">673d8257fbd1</a>).
Odkazy na prozatím poslední verze tìchto sedmi pøíkladù naleznete
v&nbsp;tabulce umístìné pod tímto odstavcem:</p>

<table>
<tr><th>#</th><th>Zdrojový kód</th><th>Umístìní</th></tr>
<tr><td>1</td><td>ModuloByZero.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/673d8257fbd1/exceptions/ModuloByZero.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/673d8257fbd1/exceptions/ModuloByZero.java</a></td></tr>
<tr><td>2</td><td>ModuloByZero.lua</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/673d8257fbd1/exceptions/ModuloByZero.lua">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/673d8257fbd1/exceptions/ModuloByZero.lua</a></td></tr>
<tr><td>3</td><td>ModuloByZero.py</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/673d8257fbd1/exceptions/ModuloByZero.py">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/673d8257fbd1/exceptions/ModuloByZero.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td>Test31.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/320255fc8ed7/bytecode/Java/Test31.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/320255fc8ed7/bytecode/Java/Test31.java</a></td></tr>
<tr><td>5</td><td>Test32.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/320255fc8ed7/bytecode/Java/Test32.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/320255fc8ed7/bytecode/Java/Test32.java</a></td></tr>
<tr><td>6</td><td>Test33.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/320255fc8ed7/bytecode/Java/Test33.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/320255fc8ed7/bytecode/Java/Test33.java</a></td></tr>
<tr><td>7</td><td>Test34.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/320255fc8ed7/bytecode/Java/Test34.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/320255fc8ed7/bytecode/Java/Test34.java</a></td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Python Byte Code Instructions<br />
<a href="https://docs.python.org/release/2.5.2/lib/bytecodes.html">https://docs.python.org/release/2.5.2/lib/bytecodes.html</a>
</li>

<li>Python 2.x: funkce range()<br />
<a href="https://docs.python.org/2/library/functions.html#range">https://docs.python.org/2/library/functions.html#range</a>
</li>

<li>Python 2.x: typ iterátor<br />
<a href="https://docs.python.org/2/library/stdtypes.html#iterator-types">https://docs.python.org/2/library/stdtypes.html#iterator-types</a>
</li>

<li>Python break, continue and pass Statements<br />
<a href="http://www.tutorialspoint.com/python/python_loop_control.htm">http://www.tutorialspoint.com/python/python_loop_control.htm</a>
</li>

<li>Python Bytecode: Fun With Dis<br />
<a href="http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/">http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/</a>
</li>

<li>Python's Innards: Hello, ceval.c!<br />
<a href="http://tech.blog.aknin.name/category/my-projects/pythons-innards/">http://tech.blog.aknin.name/category/my-projects/pythons-innards/</a>
</li>

<li>Byterun<br />
<a href="https://github.com/nedbat/byterun">https://github.com/nedbat/byterun</a>
</li>

<li>Python Byte Code Instructions<br />
<a href="http://document.ihg.uni-duisburg.de/Documentation/Python/lib/node56.html">http://document.ihg.uni-duisburg.de/Documentation/Python/lib/node56.html</a>
</li>

<li>Python Byte Code Instructions<br />
<a href="https://docs.python.org/3.2/library/dis.html#python-bytecode-instructions">https://docs.python.org/3.2/library/dis.html#python-bytecode-instructions</a>
</li>

<li>dis - Python module<br />
<a href="https://docs.python.org/2/library/dis.html">https://docs.python.org/2/library/dis.html</a>
</li>

<li>Comparison of Python virtual machines<br />
<a href="http://polishlinux.org/apps/cli/comparison-of-python-virtual-machines/">http://polishlinux.org/apps/cli/comparison-of-python-virtual-machines/</a>
</li>

<li>Lambda the Ultimate: Coroutines in Lua,<br />
<a href="http://lambda-the-ultimate.org/node/438">http://lambda-the-ultimate.org/node/438</a>
</li>

<li>Coroutines Tutorial,<br />
<a href="http://lua-users.org/wiki/CoroutinesTutorial">http://lua-users.org/wiki/CoroutinesTutorial</a>
</li>

<li>Lua Coroutines Versus Python Generators,<br />
<a href="http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators">http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators</a>
</li>

<li>Programming in Lua 9.1 &ndash; Coroutine Basics,<br />
<a href="http://www.lua.org/pil/9.1.html">http://www.lua.org/pil/9.1.html</a>
</li>

<li>Wikipedia CZ: Koprogram,<br />
<a href="http://cs.wikipedia.org/wiki/Koprogram">http://cs.wikipedia.org/wiki/Koprogram</a>
</li>

<li>Wikipedia EN: Coroutine,<br />
<a href="http://en.wikipedia.org/wiki/Coroutine">http://en.wikipedia.org/wiki/Coroutine</a>
</li>

<li>Programming in Lua (first edition)<br />
<a href="http://www.lua.org/pil/contents.html">http://www.lua.org/pil/contents.html</a>
</li>

<li>Programming in Lua: 6 - More about Functions<br />
<a href="http://www.lua.org/pil/6.html">http://www.lua.org/pil/6.html</a>
</li>

<li>Lua Lanes,<br />
<a href="http://kotisivu.dnainternet.net/askok/bin/lanes/">http://kotisivu.dnainternet.net/askok/bin/lanes/</a>
</li>

<li>Programming in Lua: 6.1 - Closures<br />
<a href="http://www.lua.org/pil/6.1.html">http://www.lua.org/pil/6.1.html</a>
</li>

<li>Programming in Lua: 9.1 - Coroutine Basics<br />
<a href="http://www.lua.org/pil/9.1.html">http://www.lua.org/pil/9.1.html</a>
</li>

<li>Programming in Lua: Numeric for<br />
<a href="http://www.lua.org/pil/4.3.4.html">http://www.lua.org/pil/4.3.4.html</a>
</li>

<li>Programming in Lua: break and return<br />
<a href="http://www.lua.org/pil/4.4.html">http://www.lua.org/pil/4.4.html</a>
</li>

<li>Programming in Lua: Tables<br />
<a href="http://www.lua.org/pil/2.5.html">http://www.lua.org/pil/2.5.html</a>
</li>

<li>Programming in Lua: Table Constructors<br />
<a href="http://www.lua.org/pil/3.6.html">http://www.lua.org/pil/3.6.html</a>
</li>

<li>Programovací jazyk Lua<br />
<a href="http://palmknihy.cz/web/kniha/programovaci-jazyk-lua-12651.htm">http://palmknihy.cz/web/kniha/programovaci-jazyk-lua-12651.htm</a>
</li>

<li>Lua: Tables Tutorial<br />
<a href="http://lua-users.org/wiki/TablesTutorial">http://lua-users.org/wiki/TablesTutorial</a>
</li>

<li>Lua: Control Structure Tutorial<br />
<a href="http://lua-users.org/wiki/ControlStructureTutorial">http://lua-users.org/wiki/ControlStructureTutorial</a>
</li>

<li>Lua Types Tutorial<br />
<a href="http://lua-users.org/wiki/LuaTypesTutorial">http://lua-users.org/wiki/LuaTypesTutorial</a>
</li>

<li>Goto Statement in Lua<br />
<a href="http://lua-users.org/wiki/GotoStatement">http://lua-users.org/wiki/GotoStatement</a>
</li>

<li>Lua 5.2 sources<br />
<a href="http://www.lua.org/source/5.2/">http://www.lua.org/source/5.2/</a>
</li>

<li>Lua 5.2 sources - lopcodes.h<br />
<a href="http://www.lua.org/source/5.2/lopcodes.h.html">http://www.lua.org/source/5.2/lopcodes.h.html</a>
</li>

<li>Lua 5.2 sources - lopcodes.c<br />
<a href="http://www.lua.org/source/5.2/lopcodes.c.html">http://www.lua.org/source/5.2/lopcodes.c.html</a>
</li>

<li>For-each Loop in Java<br />
<a href="http://www.leepoint.net/notes-java/flow/loops/foreach.html">http://www.leepoint.net/notes-java/flow/loops/foreach.html</a>
</li>

<li>For Loop (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/For_loop">http://en.wikipedia.org/wiki/For_loop</a>
</li>

<li>Heinz Rutishauser<br />
<a href="http://en.wikipedia.org/wiki/Heinz_Rutishauser">http://en.wikipedia.org/wiki/Heinz_Rutishauser</a>
</li>

<li>Parrot<br />
<a href="http://www.parrot.org/">http://www.parrot.org/</a>
</li>

<li>Parrot languages<br />
<a href="http://www.parrot.org/languages">http://www.parrot.org/languages</a>
</li>

<li>Parrot Primer<br />
<a href="http://docs.parrot.org/parrot/latest/html/docs/intro.pod.html">http://docs.parrot.org/parrot/latest/html/docs/intro.pod.html</a>
</li>

<li>Parrot Opcodes<br />
<a href="http://docs.parrot.org/parrot/latest/html/ops.html">http://docs.parrot.org/parrot/latest/html/ops.html</a>
</li>

<li>Parrot VM<br />
<a href="http://en.wikibooks.org/wiki/Parrot_Virtual_Machine">http://en.wikibooks.org/wiki/Parrot_Virtual_Machine</a>
</li>

<li>Parrot Assembly Language<br />
<a href="http://www.perl6.org/archive/pdd/pdd06_pasm.html">http://www.perl6.org/archive/pdd/pdd06_pasm.html</a>
</li>

<li>Parrot Reference: Chapter 11 - Perl 6 and Parrot Essentials<br />
<a href="http://oreilly.com/perl/excerpts/perl-6-and-parrot-essentials/parrot-reference.html">http://oreilly.com/perl/excerpts/perl-6-and-parrot-essentials/parrot-reference.html</a>
</li>

<li>O-code<br />
<a href="http://en.wikipedia.org/wiki/O-code_machine">http://en.wikipedia.org/wiki/O-code_machine</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>GC safe-point (or safepoint) and safe-region<br />
<a href="http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html">http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html</a>
</li>

<li>Safepoints in HotSpot JVM<br />
<a href="http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html">http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html</a>
</li>

<li>Java theory and practice: Synchronization optimizations in Mustang<br />
<a href="http://www.ibm.com/developerworks/java/library/j-jtp10185/">http://www.ibm.com/developerworks/java/library/j-jtp10185/</a>
</li>

<li>How to build hsdis<br />
<a href="http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README">http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README</a>
</li>

<li>Java SE 6 Performance White Paper<br />
<a href="http://www.oracle.com/technetwork/java/6-performance-137236.html">http://www.oracle.com/technetwork/java/6-performance-137236.html</a>
</li>

<li>Lukas Stadler's Blog<br />
<a href="http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html">http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html</a>
</li>

<li>How to build hsdis-amd64.dll and hsdis-i386.dll on Windows<br />
<a href="http://dropzone.nfshost.com/hsdis.htm">http://dropzone.nfshost.com/hsdis.htm</a>
</li>

<li>PrintAssembly<br />
<a href="https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly">https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly</a>
</li>

<li>The Java Virtual Machine Specification: 3.14. Synchronization<br />
<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14</a>
</li>

<li>The Java Virtual Machine Specification: 8.3.1.4. volatile Fields<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.4. Memory Model<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.7. Non-atomic Treatment of double and long<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7</a>
</li>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (pøed verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2014</small></p>
</body>
</html>

