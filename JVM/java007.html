<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Monitorování procesù a správa pamìti v JDK6 a JDK7 (1)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Monitorování procesù a správa pamìti v JDK6 a JDK7 (1)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;sedmé èásti seriálu o vlastnostech JDK (samozøejmì vèetnì OpenJDK) si øekneme základní informace o správì pamìti ve virtuálním stroji jazyka Java. Takté¾ se seznámíme se základními zpùsoby monitorování procesù bì¾ících v&nbsp;JVM &ndash; zamìøíme se pøitom (alespoò prozatím) pouze na nástroje, které jsou dostupné pøímo v&nbsp;JDK6 a JDK7.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Automatická správa pamìti ve virtuálním stroji jazyka Java</a></p>
<p><a href="#k02">2. Optimalizace související se správou pamìti</a></p>
<p><a href="#k03">3. Vyvolání správce pamìti z&nbsp;bì¾ící aplikace a metoda finalize()</a></p>
<p><a href="#k04">4. Demonstraèní pøíklady</a></p>
<p><a href="#k05">5. Základní zpùsoby monitorování operací provádìných správcem pamìti</a></p>
<p><a href="#k06">6. Alokace pamìti pro objekty v&nbsp;JVM</a></p>
<p><a href="#k07">7. Jak nákladné je vytváøení a ru¹ení objektù?</a></p>
<p><a href="#k08">8. &bdquo;Skryté&ldquo; vytváøení objektù</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2>1. Automatická správa pamìti ve virtuálním stroji jazyka Java</h2>

<p>Ka¾dý vývojáø, který zaèíná psát své první aplikace v&nbsp;programovacím
jazyku Java, se pomìrnì brzy dozví, ¾e tento jazyk (samozøejmì ve spolupráci
s&nbsp;jeho bìhovým prostøedím &ndash; <i>JRE</i>) podporuje automatickou
správu pamìti. To mj.&nbsp;znamená, ¾e se programátoøi ve vìt¹inì pøípadù
nemusí explicitnì starat o to, jakým zpùsobem se ji¾ nepotøebné objekty
z&nbsp;pamìti uvolní a jakým zpùsobem je vlastnì pamì» organizovaná,
popø.&nbsp;zda a jak se tato pamì» defragmentuje. Podpora pro automatickou
správu pamìti je zajisté velmi u¾iteèná vlastnost a vývojáøi mohou po urèité
dobì dokonce dojít k&nbsp;názoru, ¾e se o pøidìlovanou pamì» vùbec nemusí
starat. To v¹ak není v&nbsp;nìkterých pøípadech pravda, proto¾e vytváøení a
ru¹ení objektù (a s&nbsp;ním související alokace a dealokace blokù na takzvané
<i>haldì</i> &ndash; <i>heapu</i>) je operace pomìrnì nároèná na výpoèetní
výkon mikroprocesoru, tak¾e správné zacházení s&nbsp;pamìtí &ndash;
tj.&nbsp;pøedev¹ím hlídání toho, zda se napøíklad zbyteènì (a mnohdy ponìkud
skrytì) nevytváøí doèasné objekty &ndash; mù¾e nìkdy i velmi významnì ovlivnit
rychlost bìhu aplikace popø.&nbsp;eliminovat prodlevy zpùsobené automatickou
správou pamìti.</p>

<p>U desktopových aplikací se nìkdy celá problematika správy pamìti ignoruje
nebo zlehèuje se slovy &bdquo;to je prostì vlastnost pomalé Javy&ldquo;, ov¹em
u serverových aplikací, které napøíklad musejí souèasnì vyøizovat nìkolik
desítek nebo i stovek po¾adavkù za sekundu, je mo¾né <i>vhodnými</i> a cílenými
zásahy do programového kódu a nastavením nìkterých parametrù JVM zvý¹it
<i>propustnost</i> systému, a to v&nbsp;nìkterých pøípadech i nìkolikanásobnì
(je to ostatnì ponìkud podobné situaci, s&nbsp;ní¾ se èasto setkávají
programátoøi pí¹ící SQL pøíkazy &ndash; pro jednoduché a malé databáze
postaèuje pou¾ít jakýkoli SQL dotaz, který &bdquo;nìjak&ldquo; provede
po¾adovanou operaci, ov¹em u slo¾itých a rozsáhlých databází je zapotøebí
zji¹»ovat slo¾itosti dotazù a provádìt jejich optimalizace nebo dokonce zmìnit
celou strukturu databáze). Samozøejmì je¹tì vìt¹í dopad má optimalizovaný
program v&nbsp;pøípadì pou¾ití správcù pamìti orientovaných na systémy
bì¾ící v&nbsp;reálném èase (RT-systems). Ov¹em jaké optimalizace lze
v&nbsp;souvislosti se správou pamìti provádìt v&nbsp;Javì, kdy¾ jsme si o
odstavec vý¹e øekli, ¾e se pamì» spravuje automaticky?</p>



<p><a name="k02"></a></p>
<h2>2. Optimalizace související se správou pamìti</h2>

<p>Mezi vhodné zásahy ovlivòující funkci a èasové i pamì»ové nároky automatické
správy pamìti patøí pøedev¹ím zmìna èi optimalizace vlastního algoritmu (co¾
ov¹em není pøedmìtem tohoto èlánku, ale analýzy konkrétního problému).
S&nbsp;tím souvisí i pou¾ití vhodných datových struktur, napøíklad lineárnì
vázaných seznamù namísto seznamù implementovaných polem, kdy se i pøes snahu
automatického alokátoru pole systém mnohdy nevyhne jeho realokacím &ndash;
nebezpeènost èastých realokací stoupá napøíklad pøi nasazení aplikace do
ostrého provozu, v&nbsp;nìm¾ musí pracovat s&nbsp;jinými a pøedev¹ím
rozsáhlej¹ími daty, ne¾ v&nbsp;provozu testovacím (teoreticky by testovací
provoz mìl simulovat provoz reálný, ale jak v¹ichni víme, teorie se od praxe
mnohdy li¹í, napøíklad pøi èastých zmìnách ve specifikaci projektu, kdy se i
pomìrnì záva¾né úpravy implementují na poslední chvíli...). Dále pak je mo¾né
provést úpravu stávajícího algoritmu takovým zpùsobem, aby se eliminovalo
zbyteèné vytváøení doèasných objektù &ndash; typickým pøíkladem je náhrada
objektù typu <strong>String</strong> za objekty typu
<strong>StringBuffer</strong> nebo <strong>StringBuilder</strong>
v&nbsp;pøípadì, ¾e se èasto provádí spojování øetìzcù.</p>

<p>V&nbsp;pøípadì, kdy není mo¾né zmìnit pou¾itý algoritmus ani ho jiným
zpùsobem upravit, je je¹tì v&nbsp;záloze dal¹í strategie spoèívající
v&nbsp;nastavení vhodných parametrù pamìti spravované JVM (haldy) a koneènì
nastavení parametrù automatického správce pamìti (garbage collectoru),
popø.&nbsp;volba, který ze správcù pamìti má být pou¾it (v&nbsp;souèasných JVM
je jich dostupných více). Dùle¾ité je samozøejmì také zjistit, jak se
automatický správce pamìti chová pøi bìhu aplikace, popø.&nbsp;které èásti
aplikace je nutné upravit (to vùbec nemusí být pøi studiu statického
programového kódu zøejmé!). K&nbsp;tomuto úèelu slou¾í rùzné monitorovací a
logovací nástroje, které si popí¹eme v&nbsp;následujících kapitolách. Pøí¹tì na
tuto problematiku navá¾eme, proto¾e si popí¹eme konkrétní zpùsob práce
dostupných správcù pamìti (garbage collectorù) v&nbsp;JVM, vèetnì prozatím
nejnovìj¹ího typu správce pamìti, který se nazývá <strong>Garbage First Garbage
Collector</strong> nebo té¾ zkrácenì <strong>G1</strong>.</p>



<p><a name="k03"></a></p>
<h2>3. Vyvolání správce pamìti z&nbsp;bì¾ící aplikace a metoda finalize()</h2>

<p>Pøed popisem základních monitorovacích nástrojù, které jsou dostupné
v&nbsp;ka¾dé instalaci JDK 6 a JDK 7 si pøipomeòme, ¾e správce pamìti
(<i>garbage collector</i>) je spou¹tìn v&nbsp;samostatném vláknu èi více
vláknech, tak¾e pracuje paralelnì s&nbsp;bì¾ící aplikací. Operace provádìné
správcem pamìti samozøejmì nemohou probíhat zcela nezávisle na aplikaci,
proto¾e se napøíklad provádí defragmentace haldy (heapu), s&nbsp;èím¾ souvisí
potøeba nìkteré objekty uzamykat &ndash; právì v&nbsp;tìchto chvílích je bìh
aplikace pozastavován, a to i na systémech, které jsou vybaveny mikroprocesory
s&nbsp;více jádry. Správce pamìti si sám urèuje, v&nbsp;jakém okam¾iku provede
nìjakou operaci, ov¹em v&nbsp;nìkterých pøípadech je vhodné ho spustit
explicitnì &ndash; tím se napøíklad mù¾e uvolnit èást haldy pøed provedením
nìjaké nároèné operace. K&nbsp;tomuto úèelu slou¾í metoda
<strong>System.gc()</strong>. Nìkteré objekty navíc mohou implementovat metodu
<strong>protected void finalize()</strong> (její prázdnou deklaraci nalezneme
u¾ v&nbsp;koøenové tøídì <strong>Object</strong>) zavolanou tìsnì pøed tím, ne¾
je objekt skuteènì z&nbsp;pamìti odstranìn. Takzvanou <i>finalizaci</i> lze
vynutit zavoláním metody <strong>System.runFinalization()</strong>.</p>

<p>Obì zmínìné metody se mohou volat (a mnohdy se také volají) tìsnì po sobì.
Metoda <strong>System.gc()</strong> toti¾ vìt¹inou spustí první èást správce
pamìti (takzvanou fázi <i>mark</i> &ndash; oznaèování), bìhem ní¾ je zji¹tìno,
které objekty je mo¾né zru¹it a tyto objekty jsou vhodným zpùsobem oznaèeny,
popø.&nbsp;jsou objekty bez pøekryté metody <strong>finalize()</strong> pøímo
odstranìny v&nbsp;závislosti na tom, který správce pamìti je pou¾it. Metoda
<strong>System.runFinalization()</strong> zavolá (obecnì asynchronnì!) metody
<strong>finalize()</strong> u zbývajících objektù, které mají být zru¹eny a
následnì tyto objekty skuteènì z&nbsp;pamìti odstraní. Pøitom je nutné si
uvìdomit, ¾e správce pamìti stále bì¾í v&nbsp;samostatném vláknu/vláknech,
tj.&nbsp;paralelnì s&nbsp;vláknem/vlákny aplikace. Navíc není zaruèeno poøadí,
v&nbsp;jakém jsou objekty ru¹eny ani poøadí volání jejich metody
<strong>finalize()</strong> (pokud jsou samozøejmì tyto metody pøekryty).
Jediná zaruèená vlastnost je, ¾e se metoda <strong>finalize()</strong> pro
jeden objekt vyvolá pouze jedenkrát. Pou¾ití popsaných metod si uká¾eme na dvou
jednoduchých demonstraèních pøíkladech, jejich¾ zdrojové kódy jsou uvedeny
v&nbsp;následující kapitole.</p>



<p><a name="k04"></a></p>
<h2>4. Demonstraèní pøíklady</h2>

<p>V&nbsp;prvním demonstraèním pøíkladu je nejprve do seznamu ulo¾eno dvacet
instancí tøídy <strong>Item</strong> a následnì je celý seznam oznaèen za
neaktivní objekt (<i>list=null</i>) s&nbsp;následným zavoláním metod
<strong>System.gc()</strong> a <strong>System.runFinalization()</strong>.
Pov¹imnìte si, ¾e tøída <strong>Item</strong> má pøekrytou metodu
<strong>finalize</strong> a takté¾ toho, ¾e pro oznaèení objektu jako
neaktivního postaèuje, aby na nìj v&nbsp;bì¾ící aplikaci neexistovala ¾ádná
(aktivní) reference. Souèasní správci pamìti toti¾ pøi hledání ji¾ nepotøebných
objektù zji¹»ují právì to, zda na objekt existuje alespoò jedna pøímá èi
nepøímá reference:</p>

<pre>
import java.util.ArrayList;
import java.util.List;
&nbsp;
class Item
{
    private int i;
&nbsp;
    public Item(int i)
    {
        this.i = i;
    }
&nbsp;
    @Override
    protected void finalize()
    {
        System.out.println( "finalize object #" + this.i );
    }
}
&nbsp;
public class GcTest1
{
    public static void main(String[] args)
    {
        List&lt;Item&gt; list = new ArrayList&lt;Item&gt;();
        for ( int i = 0; i &lt; 20; i++ )
        {
            list.add( new Item( i ) );
        }
        System.out.println( "Press any key to run gc" );
        System.console().readLine();
        list = null;
        System.gc();
        System.runFinalization();
        System.out.println( "Press any key to quit" );
        System.console().readLine();
    }
}
</pre>

<p>Druhý demonstraèní pøíklad je podobný pøíkladu prvnímu, ov¹em namísto
oznaèení celého seznamu za neaktivní objekt jsou postupnì z&nbsp;tohoto seznamu
odstraòovány jednotlivé objekty, které do nìj byly pøedtím vlo¾eny. Podoba
tøídy <strong>Item</strong> se pøitom nezmìnila &ndash; stále obsahuje
pøekrytou metodu <strong>protected void finalize()</strong>, která pøi svém
zavolání vypí¹e (obecnì asynchronnì!) hlá¹ení na standardní výstup:</p>

<pre>
import java.util.ArrayList;
import java.util.List;
&nbsp;
class Item
{
    private int i;
&nbsp;
    public Item(int i)
    {
        this.i = i;
    }
&nbsp;
    @Override
    protected void finalize()
    {
        System.out.println("finalize object #" + this.i);
    }
}
&nbsp;
public class GcTest2
{
    public static void main(String[] args)
    {
        List&lt;Item&gt; list = new ArrayList&lt;Item&gt;();
        for ( int i = 0; i &lt; 20; i++ )
        {
            list.add( new Item( i ) );
        }
        System.out.println("Press any key to run gc");
        System.console().readLine();
        while (!list.isEmpty())
        {
            list.remove(0);
            System.gc();
            System.runFinalization();
        }
        System.out.println("Press any key to quit");
        System.console().readLine();
    }
}
</pre>



<p><a name="k05"></a></p>
<h2>5. Základní zpùsoby monitorování operací provádìných správcem pamìti</h2>

<p>Nejjednodu¹¹í zpùsob, jakým lze monitorovat práci správce pamìti (<i>garbage
collectoru</i>) spoèívá v&nbsp;pou¾ití volby <strong>-verbose:gc</strong> pøi
spou¹tìní libovolné javovské aplikace v&nbsp;<i>JVM</i>. Pokud je tato volba
pou¾ita, vypisuje správce pamìti prùbì¾nì základní informace o své práci.
Vzhledem k&nbsp;tomu, ¾e správce pamìti bì¾í v&nbsp;samostatných vláknech (viz
pøedchozí text), je jeho výstup promíchán s&nbsp;výstupem aplikace, která mù¾e
pou¾ívat metody <strong>System.out.print|println|format</strong> atd.
Standardní správce pamìti vypisuje na jednom øádku trojici údajù umístìných
mezi hranaté závorky: operaci, která byla provedena (GC/Full GC/...), stav
haldy (heapu) pøed a pro provedení operace a takté¾ èas trvání operace. Pøi
pou¾ití volby <strong>-verbose:gc</strong> je samozøejmì nutné dbát na to, aby
byla uvedena je¹tì pøed jménem tøídy s&nbsp;metodou <strong>main()</strong>,
která má být spu¹tìná (popø.&nbsp;kde má být spu¹tìn pouze blok <i>static</i>,
i kdy¾ toto jeho pou¾ití je ponìkud neobvyklé), popø.&nbsp;pøed specifikací
Java archivu. Je tomu tak z&nbsp;toho dùvodu, aby se tato volba nepøedala jako
parametr aplikace, ale zpracovala se pøímo v&nbsp;JVM.</p>

<p>To znamená, ¾e následující pøíkaz nebude pracovat korektnì:</p>

<pre>
java -jar freemind.jar -verbose:gc
</pre>

<p>Zatímco tento pøíkaz bude pracovat takovým zpùsobem, jak je oèekáváno:</p>

<pre>
java -verbose:gc -jar freemind.jar
</pre>

<p>Podívejme se nyní, jaké údaje jsou poslány na standardní výstup pøi spu¹tìní
prvního demonstraèního pøíkladu s&nbsp;vý¹e uvedenou volbou
<strong>-verbose:gc</strong>. Vidíme, ¾e po explicitním spu¹tìní správce pamìti
a finalizátoru jsou volány jednotlivé metody <strong>finalize()</strong>
objektù umístìných v&nbsp;seznamu. Konkrétní poøadí øádkù na standardním
výstupu mù¾e být odli¹né podle toho, jaký správce pamìti je pou¾itý a jak jsou
v&nbsp;daném okam¾iku synchronizována jednotlivá vlákna, v&nbsp;nich¾ bì¾í
aplikace a správce pamìti:</p>

<pre>
java -verbose:gc GcTest1
Press any key to run gc
&nbsp;
[Full GC 350K-&gt;166K(5056K), 0.0263670 secs]
finalize object #19
finalize object #18
finalize object #17
finalize object #16
finalize object #15
finalize object #14
finalize object #13
finalize object #12
finalize object #11
finalize object #10
finalize object #9
finalize object #8
finalize object #7
finalize object #6
finalize object #5
finalize object #4
finalize object #3
finalize object #2
finalize object #1
finalize object #0
Press any key to quit
</pre>

<p>V&nbsp;pøípadì druhého demonstraèního pøíkladu je standardní výstup odli¹ný,
co¾ je ostatnì logické, proto¾e jednotlivé objekty jsou ze seznamu odstraòovány
postupnì a ihned po jejich odstranìní je navíc vynuceno spu¹tìní správce
pamìti. Pov¹imnìte si takté¾ toho, ¾e i kdy¾ správce pamìti nemá (zdánlivì) co
na práci, proto¾e se odstranil (opìt zdánlivì) jen jeden zcela minimalistický
objekt s&nbsp;jediným atributem, trvá celá operace správci pamìti pomìrnì
dlouho. Pro pøedstavu &ndash; zhruba stejný èasový interval by trvalo
vyrendrování prùmìrnì slo¾ité trojrozmìrné scény na grafickém akcelerátoru:</p>

<pre>
java -verbose:gc GcTest2
Press any key to run gc
&nbsp;
[Full GC 350K-&gt;166K(5056K), 0.0223676 secs]
finalize object #0
[Full GC 202K-&gt;167K(5056K), 0.0180439 secs]
finalize object #1
[Full GC 203K-&gt;167K(5056K), 0.0207814 secs]
finalize object #2
[Full GC 203K-&gt;166K(5056K), 0.0221718 secs]
finalize object #3
[Full GC 202K-&gt;166K(5056K), 0.0218341 secs]
finalize object #4
[Full GC 202K-&gt;166K(5056K), 0.0222224 secs]
finalize object #5
[Full GC 202K-&gt;166K(5056K), 0.0215910 secs]
finalize object #6
[Full GC 202K-&gt;166K(5056K), 0.0216421 secs]
finalize object #7
[Full GC 202K-&gt;166K(5056K), 0.0215164 secs]
finalize object #8
[Full GC 202K-&gt;166K(5056K), 0.0216905 secs]
finalize object #9
[Full GC 202K-&gt;166K(5056K), 0.0209960 secs]
finalize object #10
[Full GC 202K-&gt;165K(5056K), 0.0180615 secs]
finalize object #11
[Full GC 201K-&gt;166K(5056K), 0.0179299 secs]
finalize object #12
[Full GC 202K-&gt;166K(5056K), 0.0179850 secs]
finalize object #13
[Full GC 202K-&gt;166K(5056K), 0.0179671 secs]
finalize object #14
[Full GC 202K-&gt;165K(5056K), 0.0179981 secs]
finalize object #15
[Full GC 201K-&gt;165K(5056K), 0.0179042 secs]
finalize object #16
[Full GC 201K-&gt;165K(5056K), 0.0178833 secs]
finalize object #17
[Full GC 202K-&gt;166K(5056K), 0.0178539 secs]
finalize object #18
[Full GC 202K-&gt;165K(5056K), 0.0180746 secs]
finalize object #19
Press any key to quit
</pre>

<p>V&nbsp;nìkterých pøípadech nemusí být vypisování informací o práci správce
pamìti na standardní výstup tou nejvhodnìj¹í metodou. Alternativnì lze pomocí
volby <strong>-Xloggc:jméno_souboru</strong> pøesmìrovat <i>pouze</i> informace
vypisované správcem pamìti do zvoleného souboru. Oproti informacím zapisovaným
na standardní výstup je je¹tì na zaèátku ka¾dého øádku doplnìna informace o
èasovém okam¾iku (mìøeném v&nbsp;sekundách od startu aplikace), kdy byla daná
operace zahájena. Logovací soubor obsahuje v&nbsp;pøípadì prvního
demonstraèního pøíkladu pouze jeden øádek:</p>

<pre>
1.654: [Full GC 349K-&gt;166K(5056K), 0.0267048 secs]
</pre>

<p>U druhého demonstraèního pøíkladu je do logovacího souboru vypsáno dvacet
øádkù:</p>

<pre>
1.077: [Full GC 349K-&gt;166K(5056K), 0.0232898 secs]
1.102: [Full GC 202K-&gt;166K(5056K), 0.0172860 secs]
1.121: [Full GC 202K-&gt;167K(5056K), 0.0172659 secs]
1.139: [Full GC 203K-&gt;165K(5056K), 0.0175709 secs]
1.158: [Full GC 201K-&gt;165K(5056K), 0.0171773 secs]
1.176: [Full GC 202K-&gt;166K(5056K), 0.0171315 secs]
1.194: [Full GC 202K-&gt;166K(5056K), 0.0171946 secs]
1.213: [Full GC 202K-&gt;165K(5056K), 0.0172673 secs]
1.231: [Full GC 201K-&gt;165K(5056K), 0.0171748 secs]
1.249: [Full GC 202K-&gt;166K(5056K), 0.0172159 secs]
1.268: [Full GC 202K-&gt;166K(5056K), 0.0171620 secs]
1.286: [Full GC 202K-&gt;165K(5056K), 0.0172600 secs]
1.305: [Full GC 201K-&gt;165K(5056K), 0.0171807 secs]
1.323: [Full GC 201K-&gt;165K(5056K), 0.0171617 secs]
1.341: [Full GC 201K-&gt;165K(5056K), 0.0172134 secs]
1.360: [Full GC 202K-&gt;165K(5056K), 0.0172419 secs]
1.378: [Full GC 201K-&gt;165K(5056K), 0.0171321 secs]
1.396: [Full GC 201K-&gt;165K(5056K), 0.0171343 secs]
1.415: [Full GC 201K-&gt;165K(5056K), 0.0175201 secs]
1.434: [Full GC 202K-&gt;165K(5056K), 0.0175939 secs]
</pre>



<p><a name="k06"></a></p>
<h2>6. Alokace pamìti pro objekty v&nbsp;JVM</h2>

<p>Pøi psaní aplikací v&nbsp;Javì se nevyhneme èastému vytváøení objektù. Mù¾e
se pøitom jednat jak o bì¾né objekty (obsahující vìt¹inou jako své atributy
reference na dal¹í objekty) nebo o pole a øetìzce, co¾ jsou takté¾ objekty,
které se od &bdquo;bì¾ných&ldquo; objektù odli¹ují pouze tím, ¾e pro nì
existuje podpora v&nbsp;syntaxi jazyka Java. Programovací jazyk Java se navíc
od nìkterých dal¹ích programovacích jazykù odli¹uje v&nbsp;tom, ¾e objekty jsou
v¾dy vytváøeny na haldì a nikoli na zásobníku (tam jsou ukládány pouze jejich
reference). To napøíklad znamená, ¾e pøekladaè pøi vytváøení nìjakého objektu
vùbec nemusí zkoumat, zda je objekt pou¾íván pouze v&nbsp;rámci nìkterého bloku
(metody, podmínky, smyèky) nebo zda je reference na nìj pøedána jako návratový
kód metody popø.&nbsp;je ulo¾ena napøíklad do atributu objektu. Tato vlastnost
&ndash; spolu s&nbsp;tím, ¾e se v¹echny objekty vytváøí dynamicky &ndash;
zabraòuje vznikùm chyb zpùsobených napøíklad tím, ¾e se z&nbsp;metody/funkce
vrátí ukazatel na objekt vytvoøený na zásobníku (který mù¾e být kdykoli pozdìji
pøepsán).</p>

<p>Mù¾eme se ostatnì podívat na to, jakým zpùsobem se odli¹uje bajtkód
následujících ètyø metod, které vytváøí instanci tøídy <strong>Integer</strong>
a následnì s&nbsp;ní pracují rùzným zpùsobem:</p>

<pre>
public class Test
{
    Integer attribute;
&nbsp;
    // reference na vytvoøený objekt se vrací
    // jako návratová hodnota metody
    Integer method1()
    {
        Integer i = new Integer(6502);
        return i;
    }
&nbsp;
    // objekt je pouze pou¾it v&nbsp;rámci metody
    void method2()
    {
        Integer i = new Integer(6502);
        System.out.println(i);
    }
&nbsp;
    // ulo¾ení reference na vytvoøený objekt
    // do atributu objektu (= instance tøídy Test)
    void method3()
    {
        Integer i = new Integer(6502);
        this.attribute = i;
    }
&nbsp;
    // vrácení instance tøídy Integer
    // bez vytváøení lokální reference
    Integer method4()
    {
        return new Integer(6502);
    }
}
</pre>

<p>Po pøekladu zdrojového kódu tøídy <strong>Test</strong> s&nbsp;volbou
<strong>-g</strong> (konkrétnì <i>javac -g Test.java</i>) si mù¾eme pøíkazem
<strong>javap -c Test</strong> nechat vypsat vygenerovaný bajtkód. Shodné øádky
v¹ech ètyø metod jsou oznaèeny hvìzdièkou, první tøi metody mají navíc
spoleènou instrukci, která ukládá referenci na nový objekt do lokální promìnné.
Tato instrukce je oznaèena vykøièníkem:</p>

<pre>
java.lang.Integer method1();
  Code:
*   0:  new     #2; //class java/lang/Integer
*   3:  dup
*   4:  sipush  6502
*   7:  invokespecial   #3; //Method java/lang/Integer."&lt;init&gt;":(I)V
!  10:  astore_1
   11:  aload_1
   12:  areturn
&nbsp;
void method2();
  Code:
*   0:  new     #2; //class java/lang/Integer
*   3:  dup
*   4:  sipush  6502
*   7:  invokespecial   #3; //Method java/lang/Integer."&lt;init&gt;":(I)V
!  10:  astore_1
   11:  getstatic       #4; //Field java/lang/System.out:Ljava/io/PrintStream;
   14:  aload_1
   15:  invokevirtual   #5; //Method java/io/PrintStream.println:(Ljava/lang/Object;)V
   18:  return
&nbsp;
void method3();
  Code:
*   0:  new     #2; //class java/lang/Integer
*   3:  dup
*   4:  sipush  6502
*   7:  invokespecial   #3; //Method java/lang/Integer."&lt;init&gt;":(I)V
!  10:  astore_1
   11:  aload_0
   12:  aload_1
   13:  putfield        #6; //Field attribute:Ljava/lang/Integer;
   16:  return
&nbsp;
java.lang.Integer method4();
  Code:
*   0:  new     #2; //class java/lang/Integer
*   3:  dup
*   4:  sipush  6502
*   7:  invokespecial   #3; //Method java/lang/Integer."&lt;init&gt;":(I)V
   10:  areturn
</pre>



<p><a name="k07"></a></p>
<h2>7. Jak nákladné je vytváøení a ru¹ení objektù?</h2>

<p>Vra»me se nyní k&nbsp;problematice vytváøení a ru¹ení objektù. Tyto dvì
operace, z&nbsp;nich¾ jedna je vìt¹inou provádìna explicitnì v&nbsp;aplikaci
(vìt¹inou, ale zdaleka ne v¾dy pøíkazem <strong>new</strong>) a druhá skrytì
správcem pamìti, samozøejmì nìjaký èas trvají, tj.&nbsp;je zapotøebí na nì
vyhradit urèitý a nikoli zanedbatelný výpoèetní výkon mikroprocesoru. I kdy¾ je
napøíklad vytvoøení, tj.&nbsp;konstrukce objektu zdánlivì jednoduchá (typicky
z&nbsp;toho dùvodu, ¾e je pou¾it bezparametrický konstruktor, v&nbsp;nìm¾ se
neprovádí ¾ádné slo¾ité inicializace), jsou s&nbsp;ní spojeny dal¹í skryté
operce, napøíklad alokace bloku/blokù na haldì, po¾adavek na pøidìlení dal¹ího
bloku pamìti poslaný operaènímu systému, v&nbsp;tom hor¹ím pøípadì dokonce
odlo¾ení èásti virtuální pamìti na disk (swapování) atd.</p>

<p>Odstraòování ji¾ nepotøebného objektu z&nbsp;haldy v¹ak mù¾e být je¹tì
slo¾itìj¹í, proto¾e se v&nbsp;rámci správy pamìti v&nbsp;urèitých intervalech
(a vìt¹inou po pomìrnì malých èástech) provádí defragmentace této pamìti. Jaký
vliv má relativnì malá zmìna v&nbsp;programovém kódu (která eliminuje vytváøení
doèasných objektù) na celkový bìh aplikace, a jak lze nároènost aplikace na
výpoèetní výkon mikroprocesoru zmìøit, si uká¾eme v&nbsp;navazujících
textech.</p>



<p><a name="k08"></a></p>
<h2>8. &bdquo;Skryté&ldquo; vytváøení objektù</h2>

<p>Pøed popisem rùzných zpùsobù monitorování aplikací bì¾ících v&nbsp;JVM si
uka¾me trojici demonstraèních pøíkladù, které provádí stejnou èinnost &ndash;
do øetìzce ulo¾í textové reprezentace èísel od nuly do zadané mezní hodnoty
(zde 10000), která jsou od sebe oddìlená mezerou. Jedná se sice o umìlý
pøíklad, ov¹em s&nbsp;podobným problémem se programátoøi mohou setkat pomìrnì
èasto &ndash; mù¾e se jednat o naèítání obsahu nìjakého logovacího souboru do
øetìzce, vytváøení podoby HTML tabulky v&nbsp;øetìzci pøed jejím posláním ke
klientovi, programová serializace objektù do formátu XML, formátování nìjaké
tiskové sestavy na základì údajù naèítaných z&nbsp;databáze atd. (vìt¹inou se
namísto pøidávání mezery do øetìzce pøidává znak pro konec øádku, ale to je
ji¾ detail).</p>

<p>První demonstraèní pøíklad pou¾ívá ten nejjednodu¹¹í a &ndash; jak uvidíme
dále &ndash; i z&nbsp;èasového hlediska nejhor¹í zpùsob: jednotlivá èísla jsou
pøevádìna na øetìzec, poté je tento øetìzec pøipojen k&nbsp;øetìzci
pøedstavujícím mezeru (právì díky této operaci dojde ke konverzi èísla na
øetìzec) a následnì se výsledek pøipojí k&nbsp;ji¾ vytvoøenému textu. Problém
skrytý v&nbsp;tomto pøístupu spoèívá v&nbsp;tom, ¾e øetìzce jsou nemìnitelné
objekty, co¾ znamená, ¾e operace <strong>str1 += str2</strong> vytvoøí zcela
nový objekt (typu <strong>String</strong>) a pøedchozí dva objekty
(tj.&nbsp;pùvodní <strong>str1</strong> a <strong>str2</strong>) musí být døíve
èi pozdìji zru¹eny správcem pamìti. Tato nároèná operace je v&nbsp;mezním
pøípadì (dlouhé øetìzce) provedena celkem <i>LOOP_COUNT</i>-krát, navíc je zde
je¹tì problém související s&nbsp;výrazem <strong>i + " "</strong> popsaným
dále:</p>

<pre>
public class ConcatTest1
{
    private static final int LOOP_COUNT = 10000;
&nbsp;
    private static String createString()
    {
        String str = "";
        for (int i = 0; i &lt; LOOP_COUNT; i++)
        {
            str += i + " ";
        }
        return str;
    }
&nbsp;
    public static void main(String[] args)
    {
        String str = createString();
        System.out.println("String length: " + str.length());
        System.out.println("*** Running full gc ***");
        System.gc();
        System.runFinalization();
        System.out.println("*** Quitting ***");
    }
}
</pre>

<a href="http://i.iinfo.cz/images/252/java07-1.png"><img src="http://i.iinfo.cz/images/252/java07-1-prev.png" width="370" height="258" alt=" " /></a>
<p><i>Obrázek 1: Sledování bìhu pøíkladu ConcatTest1 v&nbsp;nástroji jconsole.
Pov¹imnìte si vytí¾ení procesoru a takté¾ obsazení haldy (heapu).</i></p>

<p>Ve druhém demonstraèním pøíkladu je celá problematika øe¹ena ponìkud lépe
&ndash; namísto (nemìnných) objektù typu <strong>String</strong> je pou¾it
objekt typu <strong>StringBuffer</strong> nebo <strong>StringBuilder</strong>,
k&nbsp;nìmu¾ je mo¾né pomocí nìkolika pøetí¾ených metod
<strong>append()</strong> pøidávat dal¹í znaky. I zde v¹ak není situace zcela
dokonalá, i kdy¾ je mnohem lep¹í, ne¾ v&nbsp;pøedchozím pøíkladu. I pøesto, ¾e
se ve smyèce nenachází ¾ádné klíèové slovo <strong>new</strong>, dochází zde
ponìkud skrytì k&nbsp;neustálému vytváøení doèasných objektù, proto¾e zápis
<strong>i + " "</strong> se do bajtkódu pøelo¾í jako sekvence instrukcí pro
vytvoøení doèasného objektu <strong>StringBuilder</strong>, do nìho¾ se
postupnì ulo¾í pùvodní øetìzec, textová podoba promìnné <strong>i</strong> a mezera. Následnì je
tento doèasný objekt pøeveden na øetìzec, jen¾ je pøiøazen lokální promìnné
<i>str</i> (pøesnìji øeèeno je do promìnné pøiøazena reference na vytvoøený
øetìzec) a poté se doèasný <strong>StringBuilder</strong> ji¾ stane neaktivním
objektem. Jak uvidíme dále, není zde situace tak záva¾ná, jako v&nbsp;prvním
demonstraèním pøíkladu, proto¾e doèasný objekt <strong>StringBuilder</strong>
obsahuje pouze krátký text, tak¾e správce pamìti není vyvoláván s&nbsp;tak
velkou frekvencí:</p>

<pre>
public class ConcatTest2
{
    private static final int LOOP_COUNT = 10000;
&nbsp;
    private static String createString()
    {
        StringBuffer str = new StringBuffer();
        for (int i = 0; i &lt; LOOP_COUNT; i++)
        {
            str.append(i + " ");
        }
        return str.toString();
    }
&nbsp;
    public static void main(String[] args)
    {
        String str = createString();
        System.out.println("String length: " + str.length());
        System.out.println("*** Running full gc ***");
        System.gc();
        System.runFinalization();
        System.out.println("*** Quitting ***");
    }
}
</pre>

<a href="http://i.iinfo.cz/images/252/java07-2.png"><img src="http://i.iinfo.cz/images/252/java07-2-prev.png" width="370" height="259" alt=" " /></a>
<p><i>Obrázek 2: Sledování bìhu pøíkladu ConcatTest2 v&nbsp;nástroji jconsole.
Zde je ji¾ vytí¾ení procesoru minimální a takté¾ halda je obsazena z&nbsp;ménì
ne¾ 50%.</i></p>

<p>Tøetí demonstraèní pøíklad je pøepsán takovým zpùsobem, ¾e se ve smyèce
¾ádný dal¹í pomocný doèasný objekt nevytváøí, o èem¾ se mù¾eme snadno
pøesvìdèit napøíklad pohledem do vygenerovaného bajtkódu (ov¹em ke skrytému
vytvoøení nového objektu dojít ve skuteènosti mù¾e a skuteènì i nìkolikrát
dojde &ndash; pøijdete na to, kde a proè?). Jedná se sice o pøíklad
(pravdìpodobnì) nejménì pøehledný, ov¹em v&nbsp;pøípadì, ¾e by se podobná
konstrukce &ndash; postupné vytváøení dlouhého øetìzce z&nbsp;malých èástí
&ndash; mìla vyskytovat v&nbsp;kritické èásti programu, je vhodné a mnohdy i
nutné se pøiklonit k&nbsp;tomuto øe¹ení:</p>

<pre>
public class ConcatTest3
{
    private static final int LOOP_COUNT = 10000;
&nbsp;
    private static String createString()
    {
        StringBuffer str = new StringBuffer();
        for (int i = 0; i &lt; LOOP_COUNT; i++)
        {
            str.append(i);
            str.append(' ');
        }
        return str.toString();
    }
&nbsp;
    public static void main(String[] args)
    {
        String str = createString();
        System.out.println("String length: " + str.length());
        System.out.println("*** Running full gc ***");
        System.gc();
        System.runFinalization();
        System.out.println("*** Quitting ***");
    }
}
</pre>

<a href="http://i.iinfo.cz/images/252/java07-3.png"><img src="http://i.iinfo.cz/images/252/java07-3-prev.png" width="370" height="261" alt=" " /></a>
<p><i>Obrázek 3: Sledování bìhu pøíkladu ConcatTest3 v&nbsp;nástroji jconsole.
Výsledek je v&nbsp;tomto pøípadì podobný jako u pøíkladu pøedchozího.</i></p>

<p>Jak vypadá výpis práce správce pamìti v&nbsp;prvním pøíkladu, je ukázáno
ní¾e. Z&nbsp;tohoto výpisu je zøejmé, ¾e pøi bìhu programu do¹lo automaticky
k&nbsp;vyvolání správce pamìti cca 1100&times;(!) a program bì¾el na testovacím
poèítaèi celých 2,5 sekundy:</p>

<pre>
0.109: [GC 896K-&gt;118K(5056K), 0.0026554 secs]
0.115: [GC 1014K-&gt;123K(5056K), 0.0010161 secs]
0.119: [GC 1016K-&gt;120K(5056K), 0.0004892 secs]
...                    ...
... smazáno 1100 øádkù ...
...                    ...
2.491: [GC 2208K-&gt;1540K(5056K), 0.0003350 secs]
2.493: [GC 2399K-&gt;1635K(5056K), 0.0002609 secs]
2.495: [GC 2495K-&gt;1826K(5056K), 0.0003830 secs]
2.497: [GC 2686K-&gt;1921K(5056K), 0.0002724 secs]
2.499: [GC 2782K-&gt;2112K(5056K), 0.0003674 secs]
2.501: [GC 2973K-&gt;2208K(5056K), 0.0002763 secs]
2.502: [GC 3069K-&gt;2398K(5056K), 0.0003746 secs]
2.504: [GC 3260K-&gt;2494K(5056K), 0.0002911 secs]
2.506: [Full GC 2687K-&gt;211K(5056K), 0.0163401 secs]
</pre>

<p>Druhý demonstraèní pøíklad bì¾el znatelnì rychleji (0,135s) a navíc se
správce pamìti automaticky zavolal pouze dvakrát (tato hodnota se mù¾e mírnì
odli¹ovat, nicménì by nemìla pøesáhnout zhruba pìt zavolání GC):</p>

<pre>
0.122: [GC 896K-&gt;152K(5056K), 0.0025894 secs]
0.130: [GC 906K-&gt;188K(5056K), 0.0009370 secs]
0.135: [Full GC 825K-&gt;283K(5056K), 0.0199106 secs]
</pre>

<p>Ve tøetím pøíkladu nedocházelo k&nbsp;vytváøení ¾ádných doèasných objektù ve
smyèce, proto se správce pamìti zavolal a¾ po explicitním volání
<strong>System.gc</strong>():</p>

<pre>
0.114: [Full GC 615K-&gt;211K(5056K), 0.0240047 secs]
</pre>

<p>Podrobnìj¹í analýzu chování v¹ech tøí pøíkladù si uká¾eme pøí¹tì.</p>



<p><a name="k09"></a></p>
<h2>9. Odkazy na Internetu</h2>

<ol>

<li>Dr. Dobb's | G1: Java's Garbage First Garbage Collector<br />
<a href="http://www.drdobbs.com/article/printableArticle.jhtml?articleId=219401061&amp;dept_url=/java/">http://www.drdobbs.com/article/printableArticle.jhtml?articleId=219401061&amp;dept_url=/java/</a>
</li>

<li>Java's garbage-collected heap<br />
<a href="http://www.javaworld.com/javaworld/jw-08-1996/jw-08-gc.html">http://www.javaworld.com/javaworld/jw-08-1996/jw-08-gc.html</a>
</li>

<li>Compressed oops in the Hotspot JVM<br />
<a href="http://wikis.sun.com/display/HotSpotInternals/CompressedOops">http://wikis.sun.com/display/HotSpotInternals/CompressedOops</a>
</li>

<li>32-bit or 64-bit JVM? How about a Hybrid?<br />
<a href="http://blog.juma.me.uk/2008/10/14/32-bit-or-64-bit-jvm-how-about-a-hybrid/">http://blog.juma.me.uk/2008/10/14/32-bit-or-64-bit-jvm-how-about-a-hybrid/</a>
</li>

<li>Compressed object pointers in Hotspot VM<br />
<a href="http://blogs.sun.com/nike/entry/compressed_object_pointers_in_hotspot">http://blogs.sun.com/nike/entry/compressed_object_pointers_in_hotspot</a>
</li>

<li>Java HotSpot(tm) Virtual Machine Performance Enhancements<br />
<a href="http://download.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html">http://download.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html</a>
</li>

<li>Using jconsole<br />
<a href="http://download.oracle.com/javase/1.5.0/docs/guide/management/jconsole.html">http://download.oracle.com/javase/1.5.0/docs/guide/management/jconsole.html</a>
</li>

<li>jconsole &ndash; Java Monitoring and Management Console<br />
<a href="http://download.oracle.com/javase/1.5.0/docs/tooldocs/share/jconsole.html">http://download.oracle.com/javase/1.5.0/docs/tooldocs/share/jconsole.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>x86-64<br />
<a href="http://en.wikipedia.org/wiki/X86-64">http://en.wikipedia.org/wiki/X86-64</a>
</li>

<li>Physical Address Extension<br />
<a href="http://en.wikipedia.org/wiki/Physical_Address_Extension">http://en.wikipedia.org/wiki/Physical_Address_Extension</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>1.6.0_14 (6u14)<br />
<a href="http://www.oracle.com/technetwork/java/javase/6u14-137039.html?ssSourceSiteId=otncn">http://www.oracle.com/technetwork/java/javase/6u14-137039.html?ssSourceSiteId=otncn</a>
</li>

<li>Update Release Notes<br />
<a href="http://www.oracle.com/technetwork/java/javase/releasenotes-136954.html">http://www.oracle.com/technetwork/java/javase/releasenotes-136954.html</a>
</li>

<li>4.10 Limitations of the Java Virtual Machine<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#88659">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#88659</a>
</li>

<li>Java(TM) Platform, Standard Edition 7 Binary Snapshot Releases<br />
<a href="http://dlc.sun.com.edgesuite.net/jdk7/binaries/index.html">http://dlc.sun.com.edgesuite.net/jdk7/binaries/index.html</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>ClosableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>ArrayList (JDK 1.4)<br />
<a href="http://download.oracle.com/javase/1.4.2/docs/api/java/util/ArrayList.html">http://download.oracle.com/javase/1.4.2/docs/api/java/util/ArrayList.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2011</small></p>
</body>
</html>

