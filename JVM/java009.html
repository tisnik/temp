<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Monitorování procesù a správa pamìti v&nbsp;JDK 6 a JDK 7 (3)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Monitorování procesù a správa pamìti v&nbsp;JDK 6 a JDK 7 (2)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;deváté èásti seriálu o vlastnostech JDK 6 a JDK 7 (samozøejmì vèetnì OpenJDK) se budeme zabývat pøedev¹ím principem práce správcù pamìti. Øekneme si, jaké velièiny se pøi sledování chování aplikace v&nbsp;reálném provozu vlastnì mohou mìøit a jak jsou tyto velièiny ovlivnìny nastavením parametrù správcù pamìti pøi spu¹tìní bìhového prostøedí Javy (JRE).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Implementace správcù pamìti v&nbsp;JDK a OpenJDK</a></p>
<p><a href="#k02">2. Nejdùle¾itìj¹í velièiny sledované pøi nastavování parametrù JRE</a></p>
<p><a href="#k03">3. Trasovací algoritmy</a></p>
<p><a href="#k04">4. Zápory naivních trasovacích algoritmù</a></p>
<p><a href="#k05">5. V¹echny objekty jsou si rovné, ale nìkteré jsou si rovnìj¹í</a></p>
<p><a href="#k06">6. Metoda &bdquo;rozdìl a panuj&ldquo;</a></p>
<p><a href="#k07">7. Kopie (pøesuny) objektù v&nbsp;prùbìhu správy pamìti</a></p>
<p><a href="#k08">8. Parametry ovlivòující efektivitu správcù pamìti</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2>1. Implementace správcù pamìti v&nbsp;JDK a OpenJDK</h2>

<p>V&nbsp;pøedchozí èásti ponìkud nepravidelnì vycházejícího seriálu o
programovacím jazyce Java a vlastnostech <i>JDK 6</i> a <i>JDK 7</i> jsme se
mj.&nbsp;vìnovali i tématu implementace správcù pamìti (<i>gc &ndash; garbage
collectors</i>). I kdy¾ je programovací jazyk Java a samozøejmì i jeho bìhové
prostøedí (<i>JRE</i>) navr¾eno takovým zpùsobem, aby se programátoøi ve svých
aplikacích nemuseli (vìt¹inou!) zabývat problematikou alokace a dealokace
pamìti pro vytváøené objekty, s&nbsp;nimi¾ se v&nbsp;aplikaci pracuje, je
znalost fungování správcù pamìti dùle¾itá pøi nastavování parametrù bìhového
prostøedí Javy, pøedev¹ím v&nbsp;tìch pøípadech, pokud se jedná o aplikaci
bì¾ící na výkonných systémech s&nbsp;více mikroprocesory nebo s&nbsp;více jádry
umístìnými na jednom èipu (takový hardware je ji¾ zcela bì¾ný jak na serverech,
tak i na výkonnìj¹ích osobních poèítaèích). V&nbsp;souèasnosti je
v&nbsp;<i>JDK</i> a samozøejmì takté¾ v&nbsp;<i>OpenJDK</i> implementováno
vìt¹í mno¾ství typù správcù pamìti, pøièem¾ ka¾dý z&nbsp;nich je vhodný pro
jiné typy aplikací a odli¹né konfigurace poèítaèù.</p>

<img src="http://i.iinfo.cz/images/395/java09-1.png" width="400" height="300" alt=" " />
<p><i>Obrázek 1: Pøi pou¾ití správce pamìti vyu¾ívajícího poèítání referencí
(reference counting) je ke ka¾dému objektu pøiøazeno celé kladné èíslo
vyjadøující poèet existujících referencí na tento objekt. Pokud poèitadlo
klesne k&nbsp;hodnotì 0, je objekt z&nbsp;pamìti odstranìn. Jak jsme si v¹ak
ji¾ øekli minule, tento typ správy pamìti se v&nbsp;JDK nepou¾ívá, i kdy¾
v&nbsp;nìkterých oblastech (napøíklad pøi tvorbì systémù bì¾ících
v&nbsp;reálném èase) má své vyu¾ití.</i></p>

<p>V&nbsp;následujících kapitolách si vysvìtlíme pøedev¹ím princip fungování
správcù pamìti zalo¾ených na takzvaném <i>generaèním algoritmu</i>, pøi jeho¾
pou¾ití se objekty umístìné na <i>haldì</i> (heapu) heuristicky rozdìlují podle
jejich chování zji¹tìného pøímo za bìhu aplikace (nejedná se tedy o vlastnost
objektù, která by byla zji¹»ována ji¾ pøi pøekladu, i kdy¾ by to bylo
v&nbsp;nìkterých pøípadech mo¾né). Tito správci pamìti mohou bì¾et buï
v&nbsp;jednom vláknì, nebo je mo¾né jejich funkci rozdìlit do vìt¹ího mno¾ství
vláken, pøièem¾ strategie jejich práce se li¹í podle toho, jaké parametry jsou
nastaveny pøi startu <i>JRE</i> &ndash; ne v¹echny aplikace toti¾ mají shodné
po¾adavky na to, jakým zpùsobem mají správci pamìti pracovat (nìkdy se
preferuje spí¹e celková propustnost, u systémù reálného èasu se v¹ak dbá na
minimalizaci pauz zpùsobených správci pamìti pøi bìhu aplikace). Bli¾¹í
informace o tom, jaké velièiny se vìt¹inou pøi nastavování parametrù <i>JRE</i>
sledují, si øekneme v&nbsp;dal¹í kapitole.</p>



<p><a name="k02"></a></p>
<h2>2. Nejdùle¾itìj¹í velièiny sledované pøi nastavování parametrù JRE</h2>

<p>Pøi nastavování parametrù správcù pamìti èi pøi optimalizacích aplikace
(tj.&nbsp;úpravách vlastního algoritmu a/nebo pou¾ívaných datových typù) se
vìt¹inou sledují tøi velièiny. První z&nbsp;tìchto velièin pøedstavuje
maximální kapacitu operaèní pamìti, která mù¾e být alokována pøi vytváøení
objektù nebo pøi správì <i>haldy</i> (<i>heap</i>) správcem pamìti. Druhou
dùle¾itou velièinou je <i>propustnost</i> (<i>throughput</i>), která &ndash;
ponìkud zjednodu¹enì øeèeno &ndash; vyjadøuje, kolik procent strojového èasu
proces (tj.&nbsp;bì¾ící Javovská aplikace) stráví vlastními výpoèty. Pøitom se
pøedpokládá, ¾e zbylá procenta strojového èasu jsou vyu¾ita právì správcem
pamìti pøi zji¹»ování a následném uvolòování nepotøebných objektù. Propustnost
se vìt¹inou mìøí po velmi dlouhý èasový interval, kdy se ji¾ aplikace
&bdquo;ustálí&ldquo; a kdy mají správci pamìti zalo¾ení na heuristice mo¾nost
si objekty roztøídit podle jejich délky existence (viz té¾ dal¹í kapitoly).
Tøetí sledovanou velièinou je prùmìrná èi maximální doba, po kterou musí být
aplikace pozastavena (<i>pause time</i>), aby mohl správce pamìti uvolnit
nepotøebné objekty z&nbsp;haldy, popø.&nbsp;pøeorganizovat zde umístìné objekty
podle nastavené strategie organizace haldy. Na tomto místì je mo¾ná dobré
zdùraznit, ¾e naprostá vìt¹ina správcù pamìti musí aplikaci alespoò na krátké
okam¾iky pozastavit.</p>

<p>Podobnì jako je tomu i v&nbsp;mnoha dal¹ích oblastech IT (a nejenom tam :-),
zpùsobí vìt¹inou úprava nastavení <i>JRE</i> tak, aby se preferovala jedna
z&nbsp;tìchto velièin, zhor¹ení obou zbývajících velièin. Napøíklad po zvý¹ení
maximální kapacity pamìti pro <i>haldu</i> se mù¾e sní¾it frekvence volání
&bdquo;plného&ldquo; úklidu haldy (viz dal¹í text); sní¾ení prùmìrné èi
maximální doby, po kterou je aplikace kvùli správì pamìti pozastavena, mù¾e
sní¾it její celkovou propustnost apod. Pøi nastavování parametrù <i>JRE</i> je
tedy vhodné si ujasnit, o jaký typ aplikace se jedná a jaké chování je je¹tì
pro u¾ivatele/zákazníka pøijatelné a které ji¾ ne. Pokud by se kupøíkladu
jednalo o interaktivní aplikaci s&nbsp;grafickým u¾ivatelským rozhraním
(v&nbsp;extrémním pøípadì o hru nebo o multimediální pøehrávaè), je vìt¹inou
nutné minimalizovat pauzy zpùsobené správcem pamìti a naopak &ndash; u
dlouhotrvajících výpoètù se bude v&nbsp;naprosté vìt¹inì pøípadù klást vìt¹í
dùraz na celkovou propustnost, proto¾e u výpoètu trvajícího napøíklad tøi
hodiny bez interakce u¾ivatele asi nikoho nebude trápit, kdy¾ se celá aplikace
na nìkolik sekund zastaví, aby správce pamìti mohl vykonat v¹echny potøebné
èinnosti.</p>



<p><a name="k03"></a></p>
<h2>3. Trasovací algoritmy</h2>

<p>V&nbsp;moderních implementacích bìhového prostøedí jazyka Java (<i>JRE</i>)
se velmi èasto mù¾eme setkat se správci pamìti, které jsou zalo¾eny na
testování, které objekty ulo¾ené na haldì jsou skuteènì &bdquo;¾ivé&ldquo;,
tj.&nbsp;dostupné z&nbsp;alespoò jednoho vlákna aplikace. Tito správci pamìti
postupnì prochází stromem v¹ech objektù, pøièem¾ svoji èinnost zaèínají u
objektù, je¾ jsou v&nbsp;daném okam¾iku aktivní ve v¹ech vláknech. Mohou
zaèínat napøíklad u v¹ech objektù, jejich¾ reference jsou ulo¾eny
v&nbsp;zásobníkových rámcích vláken. Pøipomeòme si, ¾e virtuální stroj jazyka
<i>Java</i> vytváøí pro <strong>ka¾dé</strong> vlákno aplikace vlastní
virtuální zásobník (<i>virtual stack</i>), v&nbsp;nìm¾ jsou ulo¾eny
<i>zásobníkové rámce</i> (<i>stack frames</i>). Pro ka¾dou zavolanou metodu je
vytvoøen nový zásobníkový rámec, ve kterém jsou ulo¾ené jak lokální promìnné,
tak i mezivýsledky aritmetických a logických operací (tyto operace jsou
provádìny nad takzvaným <i>zásobníkem operandù</i> &ndash; <i>operand stack</i>
&ndash; jen¾ je souèástí zásobníkového rámce).</p>

<img src="http://i.iinfo.cz/images/395/java09-2.png" width="400" height="344" alt=" " />
<p><i>Obrázek 2: Stav haldy (heapu) pøed spu¹tìním správce pamìti vyu¾ívajícího
(naivní) trasovací algoritmus.</i></p>

<p>Zásobníkový rámec je takté¾ pou¾it pøi volání metod (statických, virtuálních
i konstruktorù) pro pøedávání parametrù volaným metodám (u nativních metod je
situace komplikovanìj¹í). Vzhledem k&nbsp;tomu, ¾e se s&nbsp;ukazateli na
zásobníkové rámce nedá v&nbsp;Javì pøímo manipulovat, je mo¾né, aby byly tyto
rámce postupnì vytváøeny pøímo na <i>haldì</i>, a to na libovolném místì (to je
v¹ak ji¾ implementaèní detail). V&nbsp;ka¾dém pøípadì mohou správci pamìti
nejprve oznaèit v¹echny objekty ulo¾ené v&nbsp;jednotlivých virtuálních
zásobnících jako objekty &bdquo;¾ivé&ldquo;, proto¾e jsou z&nbsp;daného vlákna
dostupné. Správci pamìti posléze postupnì prochází v¹emi atributy tìchto
objektù, které mnohdy obsahují reference na objekty dal¹í, a u v¹ech nalezených
objektù nastavují bitový pøíznak øíkající, ¾e je objekt skuteènì
&bdquo;¾ivý&ldquo;, tj.&nbsp;nìjakým zpùsobem dostupný. Po provedení celého
trasování mohou být ty objekty, které nemají bitový pøíznak &bdquo;je
¾ivý&ldquo; nastaveny na hodnotu <i>true</i>, odstranìny z&nbsp;haldy, proto¾e
neexistuje zpùsob, jakým by byly tyto objekty dosa¾itelné z&nbsp;libovolného
vlákna aplikace.</p>

<img src="http://i.iinfo.cz/images/395/java09-3.png" width="400" height="347" alt=" " />
<p><i>Obrázek 3: Objekt èíslo 1 (zde zvýraznìný ¾lutì) byl nalezen ve
virtuálním zásobníku jediného vlákna hypotetické aplikace a z&nbsp;tohoto
dùvodu byl oznaèený bitovým pøíznakem &bdquo;¾ivý&ldquo;. U modøe oznaèených
objektù je¹tì jejich stav neznáme.</i></p>



<p><a name="k04"></a></p>
<h2>4. Zápory naivních trasovacích algoritmù</h2>

<p>Vý¹e uvedený zpùsob práce správcù pamìti je ov¹em vhodný pouze pro
teoretické úvahy a v&nbsp;praxi se (tak jak je popsaný) pøíli¹ èasto nepou¾ívá,
proto¾e má nìkolik nepøíjemných vlastností. Jednou ze ¹patných vlastností je
to, ¾e projití celého stromu dosa¾itelných (¾ivých) objektù mù¾e být pomìrnì
nároèné jak na výpoèetní výkon daného poèítaèe, tak i na vyu¾ití jeho
vyrovnávacích pamìtí, proto¾e správce musí pøi své èinnosti projít i tìmi
objekty, které napøíklad nejsou v&nbsp;aplikaci nikdy pou¾ity, i kdy¾ jsou
stále dostupné (¾ivé). Pøedstavme si napøíklad serverovou aplikaci napsanou
v&nbsp;Javì, která nikdy nepou¾ije pole <strong>args</strong>, v&nbsp;nìm¾ jsou
aplikaci &ndash; pøesnìji øeèeno statické metodì <strong>public static void
main()</strong> &ndash; pøedány parametry zadané na pøíkazové øádce.
Popø.&nbsp;aplikace tyto parametry skuteènì zpracuje, ale pouze ihned po svém
spu¹tìní. Ov¹em pole <strong>args</strong> se ani v&nbsp;tomto pøípadì nemù¾e
odstranit, proto¾e reference na nìj je ulo¾ena prakticky na samotném zaèátku
virtuálního zásobníku hlavního vlákna aplikace.</p>

<img src="http://i.iinfo.cz/images/395/java09-4.png" width="400" height="344" alt=" " />
<p><i>Obrázek 4: Objekt èíslo 1 obsahoval dva atributy &ndash; reference na
objekt èíslo 2 a objekt èíslo 3. I tyto objekty jsou oznaèeny pøíznakem
&bdquo;¾ivý&ldquo;, podobnì jako objekt èíslo 7, jen¾ je dostupný nepøímo,
konkrétnì pøes dvì reference Objekt 1&rarr;Objekt 3&rarr;Objekt 7.</i></p>

<p>Tyto objekty &ndash; pole øetìzcù &ndash; jsou &bdquo;¾ivé&ldquo; po celou
dobu práce serverové aplikace, ov¹em ve skuteènosti se k&nbsp;nim nemusí i
nìkolik týdnù èi mìsícù pøistupovat (ano, i Javovské aplikace mnohdy musí
vydr¾et bì¾et tak dlouho ;-). Navíc, co¾ je v&nbsp;praxi mnohem dùle¾itìj¹í,
mù¾e projití celého stromu objektù trvat velmi dlouho. To by zpùsobovalo
nepøíjemné a v&nbsp;mnoha pøípadech i nepøípustné prodlevy &ndash; u
desktopových aplikací je to nepøíjemná vlastnost, u mnoha aplikací serverových
èi aplikací ovládajících nìjaké periferní zaøízení pak vlastnost zcela
nepøípustná. Z&nbsp;tohoto dùvodu se hledal vhodný zpùsob, jak by bylo mo¾né
chování &bdquo;naivních&ldquo; trasovacích algoritmù, které neustále otrocky
prochází v¹emi objekty na haldì, vylep¹it. Jedna z&nbsp;vhodných a
implementaènì relativnì nenároèných metod se skuteènì na¹la. Tato metoda je
zalo¾ena na poznatku získaném v&nbsp;praxi: ne v¹echny objekty, které jsou pøi
bìhu aplikace vytvoøeny, se chovají stejným zpùsobem. Existuje toti¾
(statistická) závislost mezi dobou existence objektu a pravdìpodobností, ¾e se
tento objekt stane nedostupný (neaktivní). Na tomto poznatku jsou zalo¾eny
takzvané <i>heuristické trasovací algoritmy</i>.</p>

<img src="http://i.iinfo.cz/images/395/java09-5.png" width="400" height="343" alt=" " />
<p><i>Obrázek 5: V¹echny ostatní objekty (na pøedchozím obrázku mìly stále
modré pozadí) nemìly pøíznak &bdquo;¾ivý&ldquo; nastaven na logickou jednièku a
proto je správce pamìti mohl odstranit z&nbsp;haldy. Pøed odstranìním
samozøejmì provedl finalizaci objektù, tj.&nbsp;zavolal jejich metody
<strong>finalize()</strong>.</i></p>



<p><a name="k05"></a></p>
<h2>5. V¹echny objekty jsou si rovné, ale nìkteré jsou si rovnìj¹í</h2>

<p>V&nbsp;souèasných verzích správcù pamìti, které jsou pou¾ívané v&nbsp;<i>JDK
6</i> i <i>JDK 7</i>, se sice stále pou¾ívají trasovací algoritmy, ov¹em tyto
algoritmy nepracují se v¹emi objekty ulo¾enými na haldì. Namísto toho jsou
objekty rozdìleny do nìkolika navzájem oddìlených èástí haldy. Nejhrub¹í dìlení
je na objekty &bdquo;mladé&ldquo; a objekty &bdquo;staré&ldquo;. Objekty jsou
tedy rozdìleny do nìkolika oblastí na haldì podle toho, jak dlouho ji¾ existují
&ndash; èas jejich existence se ov¹em nemìøí pomocí nìjakých èasovaèù, ale
podle toho, kolik spu¹tìní správce pamìti daný objekt &bdquo;pøe¾il&ldquo;,
tj.&nbsp;kolikrát se objekt nacházel v&nbsp;aktivním (dosa¾itelném) stavu.
Vyu¾ívá se zde pøitom faktu zji¹tìného pøi zkoumání chování reálných aplikací
v&nbsp;praxi: pomìrnì mnoho objektù se vyznaèuje velmi krátkou dobou existence
a naopak &ndash; èím déle je objekt aktivní (dosa¾itelný alespoò z&nbsp;jednoho
vlákna aplikace), tím men¹í je pravdìpodobnost, ¾e pøi dal¹ím bìhu správce
pamìti bude muset být odstranìn.</p>

<img src="http://i.iinfo.cz/images/395/java09-6.png" width="400" height="413" alt=" " />
<p><i>Obrázek 6: Vìt¹ina bì¾ných objektù je vytvoøena v&nbsp;men¹í oblasti
haldy nazvané <strong>young generation</strong>. Teprve poté, co objekt
nìkolikrát &bdquo;pøe¾ije&ldquo; spu¹tìní správce pamìti nad touto oblastí
haldy, mù¾e být pøesunut do (obecnì) vìt¹í oblasti haldy nazvané <strong>old
generation</strong> èi takté¾ <strong>tenured generation</strong>.</i></p>

<p>V&nbsp;praxi se tedy pøi rozdìlení haldy na nìkolik oblastí musí zmìnit
pøedev¹ím zpùsob alokace pamìti pøi vytváøení (konstrukci) objektù. Halda je
toti¾ rozdìlena na tøi oblasti: relativnì malou oblast nazvanou <i>young
generation</i>, vìt¹í oblast nazvanou <i>old generation</i> (té¾ <i>tenured
generation</i>) a tøetí oblast se jménem <i>permanent generation</i> (tato
oblast má ponìkud jiný význam a budeme se jí proto zabývat a¾ v&nbsp;nìkteré
následující èásti tohoto seriálu). Vìt¹ina nových objektù je vytváøena
v&nbsp;oblasti <i>young generation</i>, pouze nìkteré typy velkých objektù musí
být vytvoøeny pøímo v&nbsp;<i>old/tenured generation</i>. Nad oblastí <i>young
generation</i> se relativnì èasto spou¹tí správce pamìti optimalizovaný
s&nbsp;ohledem na to, ¾e velká èást objektù bude z&nbsp;této oblasti skuteènì
odstranìna. Objekty, které pøe¾ijí nìkolik spu¹tìní tohoto
&bdquo;rychlého&ldquo; správce pamìti, jsou pøesunuty do oblasti <i>old
generation</i>. I nad objekty ulo¾enými v&nbsp;oblasti <i>old generation</i> se
samozøejmì spou¹tí správce pamìti, ov¹em s&nbsp;mnohem men¹í frekvencí (pokud
se náhodou spou¹tí s&nbsp;velkou frekvencí, znaèí to buï problém
v&nbsp;aplikaci, nebo problém v&nbsp;parametrech <i>JRE</i>). Takté¾ algoritmus
tohoto správce pamìti je ponìkud upravený, proto¾e se poèítá s&nbsp;tím, ¾e
objekty ulo¾ené v&nbsp;<i>old generation</i> s&nbsp;vìt¹í pravdìpodobností
&bdquo;pøe¾ijí&ldquo;, na rozdíl od vìt¹iny objektù ulo¾ených v&nbsp;<i>young
generation</i>.</p>

<img src="http://i.iinfo.cz/images/395/java09-7.png" width="400" height="357" alt=" " />
<p><i>Obrázek 7: Oblast haldy nazvaná <strong>young generation</strong> je
vìt¹inou rozdìlena na tøi podoblasti: <strong>eden</strong>, <strong>survivor
space #1</strong> a <strong>survivor space #2</strong>. Na nìkterých
architekturách je v¹ak namísto toho pou¾ita vìt¹í kapacita haldy pro
<strong>eden</strong> a jedinou podoblast <strong>survivor
space</strong>.</i></p>



<p><a name="k06"></a></p>
<h2>6. Metoda &bdquo;rozdìl a panuj&ldquo;</h2>

<p>Popis rozdìlení haldy (heapu) na tøi oblasti, který byl uveden
v&nbsp;pøedchozí kapitole, není zcela pøesný. Týká se to zejména oblasti
<i>young generation</i>, které je ve skuteènosti je¹tì rozdìlena na nìkolik
dal¹ích podoblastí. První z&nbsp;tìchto podoblastí se nazývá <i>eden</i> a
právì v&nbsp;této podoblasti jsou vytváøeny nové objekty. V&nbsp;pøípadì, ¾e je
celá kapacita <i>edenu</i> ji¾ alokována, zavolá se správce pamìti, který celým
<i>edenem</i> projde a vyøadí ty objekty, které ji¾ nejsou aktivní (¾ivé).
Zbylé objekty, kterých je (alespoò podle statistických mìøení provedených nad
typickými aplikacemi) ménì, jsou zkopírovány do jedné z&nbsp;oblastí nazvaných
<i>survivor space</i>. V&nbsp;této oblasti jsou tedy umístìny pouze ty objekty,
které pøe¾ily masakr zpùsobený správcem pamìti v&nbsp;<i>edenu</i> :-). U
architektur, v&nbsp;ní¾ se pou¾ívají dvì podoblasti <i>survivor space</i>, je
v¾dy jedna z&nbsp;tìchto podoblastí prázdná a druhá podoblast obsahuje objekty
zkopírované z&nbsp;<i>edenu</i> popø.&nbsp;z&nbsp;podoblasti první (kopírováním
objektù se toti¾ <i>survivor space</i> kromì jiného té¾ defragmentuje).</p>

<img src="http://i.iinfo.cz/images/395/java09-8.png" width="401" height="398" alt=" " />
<p><i>Obrázek 8: Objekty bì¾né velikosti jsou v¾dy vytváøeny v&nbsp;edenu.
Pouze pøíli¹ velké objekty jsou alokovány ji¾ pøímo v&nbsp;oblasti old
generation, co¾ v¹ak mù¾e zpùsobovat problémy &ndash; fragmentaci této oblasti,
frekventované odstraòování objektù z&nbsp;old generation atd.</i></p>



<p><a name="k07"></a></p>
<h2>7. Kopie (pøesuny) objektù v&nbsp;prùbìhu správy pamìti</h2>

<p>Ka¾dý objekt mù¾e být po svém pøesunu z&nbsp;<i>edenu</i> do jedné
z&nbsp;podoblastí <i>survivor space</i>, mezi tìmito obìma podoblastmi
<i>survivor space</i> pøesunut nìkolikrát, ne¾ je uznáno jeho právo být
zkopírován do oblasti <i>old generation</i> (samozøejmì v&nbsp;závislosti na
nastavených parametrech správce pamìti). Ke kopiím objektu ze <i>survivor
space</i> do <i>edenu</i> v¹ak nedochází, proto¾e <i>eden</i> je vyhrazen pouze
pro novì vytváøené objekty. Po ka¾dém probìhnutí jedné iterace
&bdquo;rychlého&ldquo; správce pamìti tedy vypadá celá oblast <i>young
generation</i> na haldì následovnì: <i>eden</i> je vyprázdnìný, jedna
z&nbsp;podoblastí <i>survivor space</i> je takté¾ vyprázdnìná a druhá
z&nbsp;tìchto podoblastí obsahuje objekty, které jsou sice stále aktivní, ov¹em
je¹tì nedosáhly stavu dospìlosti (navíc je tato podoblast defragmentována). Pøi
spu¹tìní dal¹í iterace &bdquo;rychlého&ldquo; správce pamìti se význam obou
podoblastí <i>survivor space</i> otoèí, tj.&nbsp;objekty umístìné
v&nbsp;èásteènì zaplnìné podoblasti i pøe¾iv¹í objekty z&nbsp;<i>edenu</i> jsou
kopírovány do podoblasti, která byla pùvodnì prázdná.</p>

<img src="http://i.iinfo.cz/images/395/java09-9.png" width="400" height="354" alt=" " />
<p><i>Obrázek 9: Jakmile je eden zcela zaplnìn, nebo pokud v&nbsp;nìm ji¾ není
místo pro vytvoøení dal¹ího objektu, spustí se správce pamìti, který poctivì
projde v¹echny zde ulo¾ené objekty. Aktivní objekty jsou ulo¾eny do jedné
z&nbsp;oblastí survivor space, objekty neaktivní jsou odstranìny.</i></p>



<p><a name="k08"></a></p>
<h2>8. Parametry ovlivòující efektivitu správcù pamìti</h2>

<p>Efektivita správy pamìti implementované podle popisu uvedeného
v&nbsp;pøedchozích kapitolách je do znaèné míry závislá na nastavení velikostí
jednotlivých oblastí na haldì, tj.&nbsp;zejména pomìru mezi velikostí oblasti
<i>young generation</i> a <i>old (tenured) generation</i>. V&nbsp;neposlední
øadì efektivitu správcù pamìti ovlivòuje velikost <i>edenu</i>. Pokud by
napøíklad byla jeho kapacita pøíli¹ malá, docházelo by èasto k&nbsp;jeho
zaplòování, co¾ znamená, ¾e by se správce pamìti volal s&nbsp;velkou frekvencí.
Na tom by sice nemuselo být pøi prvním pohledu nic ¹patného, ov¹em v&nbsp;praxi
se ukazuje, ¾e je vhodné dát nìkterým objektùm urèitý èas na to, aby se staly
neaktivní. Pøíli¹ malá kapacita <i>edenu</i> by tedy mohla zpùsobit, ¾e by se i
objekty s&nbsp;krátkou dobou existence zkopírovaly do <i>survivor space</i> a
v&nbsp;extrémním pøípadì i do oblasti <i>old generation</i>. Dal¹í problém by
nastal u objektù, které se ji¾ pøi svém vytváøení do kapacity <i>edenu</i>
nedostanou. Takové objekty toti¾ jsou, jak jsme si ji¾ øekli o nìkolik odstavcù
vý¹e, pøímo vytváøeny v&nbsp;oblasti <i>old generation</i>.</p>

<img src="http://i.iinfo.cz/images/395/java09-10.png" width="400" height="418" alt=" " />
<p><i>Obrázek 10: Pøed èi po projití <strong>edenu</strong> se navíc projdou i
v¹echny objekty ulo¾ené v&nbsp;jedné ze <strong>survivor space</strong> a opìt
je na základì trasování objektù zhodnoceno, který objekt je aktivní, který
neaktivní a který dostateènì starý na to, aby byl pøesunut do oblasti
<strong>old generation</strong>.</i></p>

<p>To ov¹em opìt mù¾e zpùsobit men¹í efektivitu pøi údr¾bì pamìti, proto¾e
algoritmus správce pamìti pracujícího nad oblastí <i>old generation</i> není
optimalizován na to, ¾e se v&nbsp;této oblasti budou nacházet objekty
s&nbsp;krátkou dobou existence. Dal¹ím parametrem, který v&nbsp;nìkterých
pøípadech mù¾e i významnì ovlivnit chování aplikace, je volba, zda se má pou¾ít
správce pamìti bì¾ící v&nbsp;jediném vláknì nebo multivláknový (multithreadový)
správce pamìti. Zatímco jednovláknový (sériový) správce pamìti je vhodný pro
vìt¹inu desktopových aplikací bì¾ících na poèítaèích s&nbsp;malým poètem jader,
mù¾e být pou¾ití tohoto správce (který je napøíklad standardnì pou¾it
v&nbsp;JDK 1.4.2!) na výkonných serverech s&nbsp;osmi èi ¹estnácti
procesorovými jádry velmi problematické, proto¾e se zde zaène negativnì
uplatòovat <i>Amdahlùv zákon</i>. Podrobnosti si øekneme v&nbsp;navazující
èásti tohoto seriálu, spolu s&nbsp;vysvìtlením voleb, které ovlivòují zpùsob
práce správcù pamìti (a vlastnì i to, který správce pamìti se skuteènì
pou¾ije).</p>

<a href="http://i.iinfo.cz/images/679/java0603.png"><img src="http://i.iinfo.cz/images/679/java0603-prev.png" width="370" height="241" alt=" " /></a>
<p><i>Obrázek 11: Sledování stavu zaplnìní jednotlivých oblastí haldy lze
provádìt i z&nbsp;nástroje jconsole (viz pravý dolní roh okna).</i></p>



<p><a name="k09"></a></p>
<h2>9. Odkazy na Internetu</h2>

<ol>

<li>Amdahl's law<br />
<a href="http://en.wikipedia.org/wiki/Amdahl_law">http://en.wikipedia.org/wiki/Amdahl_law</a>
</li>

<li>Garbage collection (computer science)<br />
<a href="http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)</a>
</li>

<li>Dr. Dobb's | G1: Java's Garbage First Garbage Collector<br />
<a href="http://www.drdobbs.com/article/printableArticle.jhtml?articleId=219401061&amp;dept_url=/java/">http://www.drdobbs.com/article/printableArticle.jhtml?articleId=219401061&amp;dept_url=/java/</a>
</li>

<li>Java's garbage-collected heap<br />
<a href="http://www.javaworld.com/javaworld/jw-08-1996/jw-08-gc.html">http://www.javaworld.com/javaworld/jw-08-1996/jw-08-gc.html</a>
</li>

<li>Compressed oops in the Hotspot JVM<br />
<a href="http://wikis.sun.com/display/HotSpotInternals/CompressedOops">http://wikis.sun.com/display/HotSpotInternals/CompressedOops</a>
</li>

<li>32-bit or 64-bit JVM? How about a Hybrid?<br />
<a href="http://blog.juma.me.uk/2008/10/14/32-bit-or-64-bit-jvm-how-about-a-hybrid/">http://blog.juma.me.uk/2008/10/14/32-bit-or-64-bit-jvm-how-about-a-hybrid/</a>
</li>

<li>Compressed object pointers in Hotspot VM<br />
<a href="http://blogs.sun.com/nike/entry/compressed_object_pointers_in_hotspot">http://blogs.sun.com/nike/entry/compressed_object_pointers_in_hotspot</a>
</li>

<li>Java HotSpot(tm) Virtual Machine Performance Enhancements<br />
<a href="http://download.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html">http://download.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html</a>
</li>

<li>Using jconsole<br />
<a href="http://download.oracle.com/javase/1.5.0/docs/guide/management/jconsole.html">http://download.oracle.com/javase/1.5.0/docs/guide/management/jconsole.html</a>
</li>

<li>jconsole &ndash; Java Monitoring and Management Console<br />
<a href="http://download.oracle.com/javase/1.5.0/docs/tooldocs/share/jconsole.html">http://download.oracle.com/javase/1.5.0/docs/tooldocs/share/jconsole.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>x86-64<br />
<a href="http://en.wikipedia.org/wiki/X86-64">http://en.wikipedia.org/wiki/X86-64</a>
</li>

<li>Physical Address Extension<br />
<a href="http://en.wikipedia.org/wiki/Physical_Address_Extension">http://en.wikipedia.org/wiki/Physical_Address_Extension</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>1.6.0_14 (6u14)<br />
<a href="http://www.oracle.com/technetwork/java/javase/6u14-137039.html?ssSourceSiteId=otncn">http://www.oracle.com/technetwork/java/javase/6u14-137039.html?ssSourceSiteId=otncn</a>
</li>

<li>Update Release Notes<br />
<a href="http://www.oracle.com/technetwork/java/javase/releasenotes-136954.html">http://www.oracle.com/technetwork/java/javase/releasenotes-136954.html</a>
</li>

<li>4.10 Limitations of the Java Virtual Machine<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#88659">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#88659</a>
</li>

<li>Java(TM) Platform, Standard Edition 7 Binary Snapshot Releases<br />
<a href="http://dlc.sun.com.edgesuite.net/jdk7/binaries/index.html">http://dlc.sun.com.edgesuite.net/jdk7/binaries/index.html</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>ClosableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>ArrayList (JDK 1.4)<br />
<a href="http://download.oracle.com/javase/1.4.2/docs/api/java/util/ArrayList.html">http://download.oracle.com/javase/1.4.2/docs/api/java/util/ArrayList.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2011</small></p>
</body>
</html>

