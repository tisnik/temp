<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - pøedèasný výskok z metody s vyu¾itím rozhraní JVM TI</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - pøedèasný výskok z metody s vyu¾itím rozhraní JVM TI</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V ¹edesáté osmé èásti seriálu o programovacím jazyce Java i o vlastnostech JVM si øekneme, jakým zpùsobem je mo¾né pøes rozhraní JVM TI vynutit pøedèasné ukonèení libovolné metody. Vìt¹inou se jedná o metody, na kterých je nastavený breakpoint, ov¹em ve skuteènosti je mo¾né si vynutit ukonèení zcela libovolné metody.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - pøedèasný výskok z&nbsp;metody s&nbsp;vyu¾itím rozhraní JVM TI</a></p>
<p><a href="#k02">2. Pamì»ový prostor pøidìlený ka¾dému vláknu: zásobník a zásobníkové rámce (stack frames)</a></p>
<p><a href="#k03">3. Instrukce bajtkódu slou¾ící pro ukonèení metody s&nbsp;pøedáním návratové hodnoty této metody</a></p>
<p><a href="#k04">4. Podpora JVM TI pro výskok z&nbsp;metody mající návratovou hodnotu i z&nbsp;metody bez návratové hodnoty</a></p>
<p><a href="#k05">5. Testovací tøída pou¾itá tøicátým tøetím demonstraèním JVM TI agentem</a></p>
<p><a href="#k06">6. Nastavení breakpointù pro v¹echny testované metody</a></p>
<p><a href="#k07">7. Tvar callback funkce <strong>callback_on_breakpoint()</strong></a></p>
<p><a href="#k08">8. Tvar u¾ivatelské funkce <strong>force_early_return()</strong></a></p>
<p><a href="#k09">9. Spu¹tìní tøicátého tøetího demonstraèního JVM TI agenta</a></p>
<p><a href="#k10">10. Zdrojové kódy tøicátého tøetího demonstraèního agenta i k&nbsp;nìmu pøíslu¹ných testovacích pøíkladù a skriptù</a></p>
<p><a href="#k11">11. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - pøedèasný výskok z&nbsp;metody s&nbsp;vyu¾itím rozhraní JVM TI</h2>

<p>V&nbsp;závìru <a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-nastaveni-breakpointu-s-vyuzitim-rozhrani-jvm-ti-dokonceni/">pøedchozí èásti</a> <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyce Java i o vlastnostech virtuálního stroje Javy</a> jsme si
øekli, ¾e v&nbsp;tomto seriálu ji¾ byla popsána vìt¹ina funkcí nabízených
rozhraním <i>JVM TI</i>. Zbývá nám tak popsat a na demonstraèních pøíkladech
ukázat pouze dvì relativnì malé skupiny funkcí. Do první skupiny patøí ¹estice
funkcí zaèínajících prefixem <strong>ForceEarlyReturn*()</strong>. Tyto funkce
slou¾í k&nbsp;tomu, aby si <i>JVM TI</i> agent mohl v&nbsp;pøípadì potøeby
vynutit opu¹tìní nìjaké javovské metody a souèasnì vrátil z&nbsp;této metody
specifikovanou hodnotu (vynucením se zde myslí situace, kdy agent do kódu
jakoby vlo¾í pomyslný pøíkaz <strong>return</strong>). Mù¾e se jednat jak o
hodnotu primitivního datového typu (<strong>boolean</strong>,
<strong>char</strong>, <strong>byte</strong>, <strong>short</strong>,
<strong>int</strong>, <strong>long</strong>, <strong>float</strong>,
<strong>double</strong> s&nbsp;omezeními popsanými v&nbsp;dal¹ím textu), tak i
o referenci, tj.&nbsp;odkaz na instanci nìjaké tøídy.</p>

<p>Právì popisem zmínìné ¹estice funkcí <strong>ForceEarlyReturn*()</strong> se
budeme zabývat v&nbsp;následujících kapitolách. Øekneme si, jak tyto funkce
ovlivní chování virtuálního stroje Javy a posléze si na tøicátém tøetím
demonstraèním <i>JVM TI</i> agentovi uká¾eme, jak lze tyto funkce vyu¾ít
v&nbsp;praxi, konkrétnì v&nbsp;agentovi, který si vynutí pøedèasné opu¹tìní
v¹ech metod, pro nì¾ je nastavený breakpoint.</p>

<p>Poznámka: aby bylo mo¾né <i>JVM TI</i> funkce urèené pro vynucené opu¹tìní
metod v&nbsp;<i>JVM TI</i> agentech skuteènì pou¾ít, je nutné agenta nastavit
takovým zpùsobem, aby byla podporována schopnost
<strong>can_force_early_return</strong>. Jak se tato vlastnost v&nbsp;na¹em
demonstraèním <i>JVM TI</i> agentovi nastavuje, je vidìt z&nbsp;následující
ukázky:</p>

<pre>
<i>/*</i>
<i> * Nastaveni pozadovanych schopnosti agenta.</i>
<i> */</i>
jvmtiError <strong>set_capabilities</strong>(jvmtiEnv *jvmti)
{
    jvmtiCapabilities capabilities;
    jvmtiError error_code;
&nbsp;
    memset(&amp;capabilities, 0, sizeof(jvmtiCapabilities));
&nbsp;
<i>    /* vyuzivame pouze tri specialni schopnosti agenta */</i>
    capabilities.can_get_line_numbers = 1;
    capabilities.can_generate_breakpoint_events = 1;
    capabilities.can_force_early_return = 1;
&nbsp;
    error_code = (*jvmti)-&gt;AddCapabilities(jvmti, &amp;capabilities);
    check_jvmti_error(jvmti, error_code, "Unable to get necessary JVMTI capabilities.");
    return error_code;
}
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Pamì»ový prostor pøidìlený ka¾dému vláknu: zásobník a zásobníkové rámce (stack frames)</h2>

<p>Døíve ne¾ si popí¹eme funkce nabízené rozhraním <i>JVM TI</i>, které doká¾ou
vynutit pøedèasné ukonèení zvolené metody, si pøipomeòme, jakým zpùsobem je
vlastnì organizována pamì» vyu¾ívaná &bdquo;uvnitø&ldquo; metod.  Ji¾
v&nbsp;úvodních èástech tohoto seriálu jsme si øekli, ¾e instance tøíd,
tj.&nbsp;vlastnì hodnoty jednotlivých atributù, jsou alokovány na haldì
(<i>heapu</i>). Tato pamì»ová oblast je pro nás v&nbsp;tomto momentì relativnì
nezajímavá, proto¾e se jí pøedèasné ukonèení metod vlastnì nijak netýká. Mnohem
dùle¾itìj¹í pamì»ovou oblastí je pro nás zásobník (<i>stack</i>), který je
tvoøen sekvencí vzájemnì pouze nepøímo propojených zásobníkových rámcù
(<i>stack frame(s)</i>). Oznaèení &bdquo;zásobník&ldquo; sice mù¾e navozovat
pocit, ¾e se jedná o kontinuální oblast pamìti, ve skuteènosti v¹ak mezi
jednotlivými zásobníkovými rámci neexistují ¾ádné pøímé vazby a proto se ka¾dý
zásobníkový rámec mù¾e (ale nemusí) nacházet v&nbsp;pamìti kdekoli &ndash;
rámce napøíklad mohou být vytváøeny pøímo na haldì (hodnì zde zále¾í na
konkrétní implementaci JVM).</p>

<p>Dùle¾ité je, ¾e zásobník je virtuálním strojem Javy automaticky vytvoøen
<strong>pro ka¾dé vlákno</strong>, co¾ pøi bli¾¹ím zamy¹lení dává smysl,
proto¾e jedna metoda mù¾e být v&nbsp;jednom okam¾iku volána z&nbsp;vìt¹ího
mno¾ství vláken a je tedy nutné oddìlit parametry metody i její lokální
promìnné od dal¹ích volání té¾e metody. Ostatnì právì fakt, ¾e zásobník je
vytvoøen pro ka¾dé vlákno, vede k&nbsp;tomu, ¾e dále popsané <i>JVM TI</i>
funkce <strong>ForceEarlyReturn*()</strong> vy¾adují jako jeden ze svých
parametrù i identifikátor vlákna, jen¾ je typu <strong>jthread</strong>.
Zásobníkové rámce jsou tvoøeny lokálními promìnnými metod a parametry metod.
Jejich souèástí je v¹ak takté¾ zásobník operandù (<i>operand stack</i>)
vyu¾ívaný jak pøi v¹ech aritmetických a logických operacích, tak i pøi volání
jiné metody. Opìt platí, ¾e není mo¾né získat pøímou adresu lokálních
promìnných, parametrù metod ani dat ulo¾ených na zásobníku operandù, proto se
nemusí jednat o kontinuální oblast pamìti.</p>

<p>V&nbsp;pøedchozím textu bylo øeèeno, ¾e v&nbsp;zásobníkovém rámci jsou
ulo¾eny jak parametry metod, tak i její lokální promìnné. Nejdøíve jsou
v&nbsp;zásobníkovém rámci ulo¾eny parametry metod (vèetnì parametru
<strong>this</strong>, ov¹em logicky pouze u nestatických metod) a ihned za
nimi se nachází oblast vyhrazená pro lokální promìnné. Ke v¹em tìmto údajùm,
tj.&nbsp;jak k&nbsp;parametrùm, tak i k&nbsp;lokálním promìnným, se
v&nbsp;bajtkódu pøistupuje s&nbsp;vyu¾itím indexu: první údaj má index 0, dal¹í
1 atd. Uka¾me si to na jednoduchém pøíkladu tøídy s&nbsp;dvojicí metod &ndash;
jedné nestatické a druhé statické:</p>

<pre>
class <strong>Test</strong> {
    void <strong>add1</strong>(int x, int y) {
        int z = x + y;
    }
&nbsp;
    static void <strong>add2</strong>(int x, int y) {
        int z = x + y;
    }
}
</pre>

<p>Obì metody sice provádí tuté¾ èinnost &ndash; souèet dvou celých èísel
s&nbsp;ulo¾ením výsledku do lokální promìnné &ndash; ov¹em zpùsob indexování
parametrù je uvnitø JVM odli¹ný, proto¾e v&nbsp;nestatické metodì je
v&nbsp;první pozici zásobníkového rámce (tato pozice má index roven nule)
ulo¾en implicitní parametr <strong>this</strong>, kde¾to v&nbsp;metodì statické
se na stejné pozici zásobníkového rámce nachází ji¾ pøímo první parametr:</p>

<pre>
void <strong>add1</strong>(int, int);
  Code:
   Stack=2, Locals=4, Args_size=3
                        // v prvním parametru je ulo¾ena hodnota this, tu nepotøebujeme
   0:   iload_1         // naètení druhého parametru metody s jeho ulo¾ením na zásobník operandù
   1:   iload_2         // naètení tøetího parametru metody s jeho ulo¾ením na zásobník operandù
   2:   iadd            // provedení souètu
   3:   istore_3        // ulo¾ení výsledku na ètvrtou pozici v zásobníkovém rámci: první lokální promìnné
   4:   return          // návrat z metody
</pre>

<pre>
static void <strong>add2</strong>(int, int);
  Code:
   Stack=2, Locals=3, Args_size=2
   0:   iload_1         // naètení druhého parametru metody s jeho ulo¾ením na zásobník operandù
   1:   iload_2         // naètení tøetího parametru metody s jeho ulo¾ením na zásobník operandù
   2:   iadd            // provedení souètu
   3:   istore_2        // ulo¾ení výsledku na tøetí pozici v zásobníkovém rámci: první lokální promìnné
   4:   return          // návrat z metody
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Instrukce bajtkódu slou¾ící pro ukonèení metody s&nbsp;pøedáním návratové hodnoty této metody</h2>

<p>V&nbsp;bajtkódu virtuálního stroje Javy je mo¾né vyu¾ít nìkolik (konkrétnì
se jedná o ¹est) instrukcí slou¾ících pro ukonèení metody, tj.&nbsp;pro výskok
z&nbsp;tìla metody se souèasným úklidem zásobníku operandù i zásobníkového
rámce popsaného <a href="#k02">v&nbsp;pøedchozí kapitole</a>. Kromì úklidu
zásobníku operandù tyto instrukce takté¾ zaji¹»ují pøedání návratové hodnoty
(pokud ov¹em nìjaká existuje, tj.&nbsp;pokud návratový typ metody není
<strong>void</strong>) do volající metody (<i>caller method</i>). Zmínìné
instrukce jsou vìt¹inou generovány pøekladaèem Javy, a to jak na konci
zdrojového kódu metody, tak i v&nbsp;tìch místech, kde programátor do
zdrojového kódu vlo¾il pøíkaz <strong>return výraz</strong>. Pøipomeòme si, ¾e
volající metoda si mù¾e tuto návratovou hodnotu vyzvednout z&nbsp;vrcholu
<strong>svého</strong> zásobníku operandù (to je zaøízeno virtuálním strojem
Javy vìt¹inou bez nutnosti pøesunu tìchto hodnot).</p>

<p>Pou¾ití dále vypsaných instrukcí typu <strong>*return</strong> je ostatnì
jedinou mo¾ností, jak mù¾e volaná metoda modifikovat obsah zásobníku operandù
volající metody &ndash; v&nbsp;ostatních pøípadech jsou toti¾ zásobníky
operandù (takté¾ i datová oblast s&nbsp;parametry a lokálními promìnnými) obou
metod od sebe izolovány, co¾ pøispívá jak k&nbsp;vìt¹í bezpeènosti práce
virtuálního stroje (nelze vytvoøit metodu s&nbsp;postranním úèinkem), tak i
k&nbsp;oddìlení jednotlivých èástí kódu. Navíc tato vlastnost samozøejmì
zjednodu¹uje práci just-in-time pøekladaèe pøi provádìní optimalizací. Ukonèení
metody s&nbsp;ulo¾ením návratové hodnoty zabezpeèuje ¹estice instrukcí
<strong>*return</strong>, která je vypsaná v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Datový typ na TOS</th><th>Provádìná operace</th></tr>
<tr><td>1</td><td>ireturn</td><td>0xAC</td><td>int</td><td>získání návratové hodnoty typu int z&nbsp;TOS zásobníku operandù + návrat z&nbsp;metody</td></tr>
<tr><td>2</td><td>lreturn</td><td>0xAD</td><td>long</td><td>získání návratové hodnoty typu long z&nbsp;TOS zásobníku operandù + návrat z&nbsp;metody</td></tr>
<tr><td>3</td><td>freturn</td><td>0xAE</td><td>float</td><td>získání návratové hodnoty typu float z&nbsp;TOS zásobníku operandù + návrat z&nbsp;metody</td></tr>
<tr><td>4</td><td>dreturn</td><td>0xAF</td><td>double</td><td>získání návratové hodnoty typu double z&nbsp;TOS zásobníku operandù + návrat z&nbsp;metody</td></tr>
<tr><td>5</td><td>areturn</td><td>0xB0</td><td>reference</td><td>získání návratové hodnoty typu reference na objekt z&nbsp;TOS zásobníku operandù + návrat z&nbsp;metody</td></tr>
<tr><td>6</td><td>return</td><td>0xB1</td><td>&times;</td><td>pouze návrat z&nbsp;metody, ¾ádná hodnota se nevrací</td></tr>
</table>

<p>Zkratka <i>TOS</i> znamená <i>Top Of Stack</i>, v&nbsp;tomto pøípadì se
jedná o hodnotu ulo¾enou na vrcholu lokálního zásobníku operandù, která je
pøedána do volající metody. <i>Opkód</i> je zkrácenina sousloví &bdquo;operaèní
kód&ldquo;, tedy vlastního èíselného kódu instrukce v&nbsp;bajtkódu.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Podpora JVM TI pro výskok z&nbsp;metody mající návratovou hodnotu i z&nbsp;metody bez návratové hodnoty</h2>

<p>Asi nejdùle¾itìj¹í informací, která byla <a href="#k04">v&nbsp;pøedchozí
kapitole</a> uvedena, je fakt, ¾e i kdy¾ v&nbsp;Javì existuje celkem osm
primitivních datových typù (<i>boolean</i>, <i>char</i>, <i>byte</i>,
<i>short</i>, <i>int</i>, <i>long</i>, <i>float</i> a <i>double</i>), je ve
skuteènosti mo¾né z&nbsp;metody vrátit hodnoty jen ètyø primitivních datových
typù a to konkrétnì <i>int</i>, <i>long</i>, <i>float</i> a <i>double</i>
s&nbsp;vyu¾itím instrukcí <strong>ireturn</strong>, <strong>lreturn</strong>,
<strong>freturn</strong> a <strong>dreturn</strong>.</p>

<p>Je tomu tak z&nbsp;toho dùvodu, ¾e celoèíselné datové typy <i>byte</i> a
<i>short</i> jsou ve vìt¹inì instrukcí bajtkódu automaticky roz¹íøeny na typ
<i>int</i> (tomu ostatnì odpovídá i sémantika Javy, která pro tyto dva datové
typy nemá vyhrazenu napøíklad ani operaci souètu). Podobná konverze platí i pro
zbývající dva typy <i>boolean</i> a <i>char</i>. Dal¹í instrukce nazvaná pouze
<strong>return</strong> je pou¾ita pro výskok z&nbsp;metody bez návratové
hodnoty (<i>void</i>) a poslední, ¹estou instrukci <strong>areturn</strong> lze
vyu¾ít pro výskok z&nbsp;metody se souèasným vrácením reference na objekt
(popø.&nbsp;hodnoty <strong>null</strong>).</p>

<p>©esti zmínìným instrukcím <strong>return</strong>, <strong>ireturn</strong>,
<strong>lreturn</strong>, <strong>freturn</strong>, <strong>dreturn</strong> a
<strong>areturn</strong> odpovídá i ¹estice funkcí nabízených rozhraním <i>JVM
TI</i>, které vlastnì slou¾í pro &bdquo;vnucení&ldquo; tìchto instrukcí
virtuálnímu stroji i v&nbsp;místì, kde bajtkód ve skuteènosti obsahuje zcela
odli¹nou instrukci. Následuje výpis hlavièek v¹ech ¹esti <i>JVM TI</i>
funkcí.</p>

<p>Vynucení výskoku z&nbsp;metody bez návratové hodnoty
(<strong>void</strong>):</p>

<pre>
jvmtiError JNICALL <strong>ForceEarlyReturnVoid</strong>(
    jvmtiEnv* env,
    jthread   thread);
</pre>

<p>Vynucení výskoku z&nbsp;metody, její¾ návratová hodnota je typu
<strong>boolean</strong>, <strong>char</strong>, <strong>byte</strong>,
<strong>short</strong> nebo <strong>int</strong>:</p>

<pre>
jvmtiError JNICALL <strong>ForceEarlyReturnInt</strong>(
    jvmtiEnv* env,
    jthread   thread,
    jint      value);
</pre>

<p>Vynucení výskoku z&nbsp;metody, její¾ návratová hodnota je typu
<strong>long</strong>:</p>

<pre>
jvmtiError JNICALL <strong>ForceEarlyReturnLong</strong>(
    jvmtiEnv* env,
    jthread   thread,
    jlong     value);
</pre>

<p>Vynucení výskoku z&nbsp;metody, její¾ návratová hodnota je typu
<strong>float</strong>:</p>

<pre>
jvmtiError JNICALL <strong>ForceEarlyReturnFloat</strong>(
    jvmtiEnv* env,
    jthread   thread,
    jfloat    value);
</pre>

<p>Vynucení výskoku z&nbsp;metody, její¾ návratová hodnota je typu
<strong>double</strong>:</p>

<pre>
jvmtiError JNICALL <strong>ForceEarlyReturnDouble</strong>(
    jvmtiEnv* env,
    jthread   thread,
    jdouble   value);
</pre>

<p>Vynucení výskoku z&nbsp;metody, její¾ návratová hodnota je typu reference na
objekt (samotná instance tøídy=objekt je samozøejmì ulo¾ený na
haldì/<i>heapu</i>):</p>

<pre>
jvmtiError JNICALL <strong>ForceEarlyReturnObject</strong>(
    jvmtiEnv* env,
    jthread   thread,
    jobject   value);
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Testovací tøída pou¾itá tøicátým tøetím demonstraèním JVM TI agentem</h2>

<p>Pojïme si nyní ukázat, jakým zpùsobem je mo¾né <i>JVM TI</i> funkce popsané
<a href="#k04">v&nbsp;pøedchozí kapitole</a> vyu¾ít. Následující javovská tøída
nazvaná <strong>Test33</strong> obsahuje ¹est testovacích metod pojmenovaných
<strong>voidMethod()</strong>, <strong>booleanMethod()</strong>,
<strong>intMethod()</strong>, <strong>longMethod()</strong>,
<strong>floatMethod()</strong> a <strong>doubleMethod()</strong>. V¹echny tyto
metody pøi svém zavolání vypí¹ou na standardní výstup dvì zprávy a pìt
z&nbsp;tìchto metod navíc vrátí volající metodì konstantní návratovou
hodnotu:</p>

<pre>
<i>/**</i>
<i>  * Testovaci trida pouzita pro test tricateho</i>
<i>  * tretiho demonstracniho JVM TI agenta.</i>
<i>  * Agent se pokusi u kazde metody vynutit predcasny navrat.</i>
<i>  */</i>
public class <strong>Test33</strong> {
&nbsp;
    private void <strong>voidMethod</strong>() {
        System.out.println("voidMethod1");
        System.out.println("voidMethod2");
    }
&nbsp;
    private boolean <strong>booleanMethod</strong>() {
        System.out.println("booleanMethod1");
        System.out.println("booleanMethod2");
        <strong>return</strong> false;
    }
&nbsp;
    private int <strong>intMethod</strong>() {
        System.out.println("intMethod1");
        System.out.println("intMethod2");
        <strong>return</strong> 0;
    }
&nbsp;
    private long <strong>longMethod</strong>() {
        System.out.println("longMethod1");
        System.out.println("longMethod2");
        <strong>return</strong> 0;
    }
&nbsp;
    private float <strong>floatMethod</strong>() {
        System.out.println("floatMethod1");
        System.out.println("floatMethod2");
        <strong>return</strong> 0.0f;
    }
&nbsp;
    private double <strong>doubleMethod</strong>() {
        System.out.println("doubleMethod1");
        System.out.println("doubleMethod2");
        <strong>return</strong> 0.0;
    }
&nbsp;
    public void <strong>run</strong>() {
        voidMethod();
        System.out.println(booleanMethod());
        System.out.println(intMethod());
        System.out.println(longMethod());
        System.out.println(floatMethod());
        System.out.println(doubleMethod());
    }
&nbsp;
<i>    /**</i>
<i>      * Spusteni testu.</i>
<i>      */</i>
    public static void <strong>main</strong>(String[] args) {
        new Test33().run();
    }
}
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Nastavení breakpointù pro v¹echny testované metody</h2>

<p>Úkolem dne¹ního demonstraèního <i>JVM TI</i> agenta bude vynutit si
pøedèasné ukonèení v¹ech ¹esti testovacích metod <strong>voidMethod()</strong>,
<strong>booleanMethod()</strong>, <strong>intMethod()</strong>,
<strong>longMethod()</strong>, <strong>floatMethod()</strong> a
<strong>doubleMethod()</strong> s&nbsp;tím, ¾e se z&nbsp;tìchto metod vrátí
odli¹ná návratová hodnota, ne¾ jaká je zadána ve výrazu umístìného za pøíkazem
<strong>return</strong>. Pro implementaci dne¹ního agenta vyu¾ijeme zdrojový
kód agenta popsaného minule, dojde v¹ak k&nbsp;nìkolika úpravám. Nejprve musíme
nastavit breakpointy do v¹ech ¹esti zmínìných metod. Pøesné umístìní
jednotlivých breakpointù je ulo¾eno v&nbsp;poli <strong>breakpoints</strong>,
podobnì jako tomu bylo i minule:</p>

<pre>
<i>/*</i>
<i> * Breakpointy se budou nastavovat celkem pro sest metod.</i>
<i> */</i>
t_breakpoint <strong>breakpoints</strong>[] = {
    {"voidMethod",        10},
    {"booleanMethod",     15},
    {"intMethod",         21},
    {"longMethod",        27},
    {"floatMethod",       33},
    {"doubleMethod",      39},
    {NULL,  0}    <i>/* zarazka - je pouzita pri prochazeni timto polem! */</i>
};
</pre>

<p>Pokud si èísla øádkù zapsaná do pole <strong>breakpoints</strong> porovnáme
se zdrojovým kódem testovací tøídy <strong>Test33</strong>, uvidíme, ¾e
breakpointy jsou nastaveny v¾dy na druhý pøíkaz
<strong>System.out.println();</strong>. Tento pøíkaz se ji¾ ve skuteènosti
neprovede, proto¾e dojde k&nbsp;násilnému ukonèení metod.</p>

<p>O nastavení breakpointù se postará u¾ivatelská funkce nazvaná
<strong>set_breakpoint_for_selected_method()</strong>:</p>

<pre>
<i>/*</i>
<i> * Pokud se metoda nachazi v poli breakpoints, nastavi se pro ni breakpoint.</i>
<i> */</i>
void <strong>set_breakpoint_for_selected_method</strong>(jvmtiEnv *jvmti_env, jmethodID method)
{
    jvmtiError  error;
    char *method_name;
    char *method_signature;
&nbsp;
    error = (*jvmti_env)-&gt;<strong>GetMethodName</strong>(jvmti_env, method, &amp;method_name, &amp;method_signature, NULL);
&nbsp;
<i>    /* podarilo se ziskat jmeno metody, otestujme tedy, zda pro ni mame nastavit breakpoint */</i>
    if (error == JVMTI_ERROR_NONE)
    {
        int j;
        printf(AGENT_NAME " Found method(): %s with signature %s\n", method_name, method_signature);
        for (j=0; breakpoints[j].method_name != NULL; j++)
        {
            if (strcmp(method_name, breakpoints[j].method_name) == 0)
            {
                puts(AGENT_NAME " ...going to set breakpoint for this method");
                <strong>set_breakpoint</strong>(jvmti_env, method, breakpoints[j].line_number);
            }
        }
&nbsp;
        (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char*)method_name);
        (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char*)method_signature);
    }
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Tvar callback funkce <strong>callback_on_breakpoint()</strong></h2>

<p>Ve chvíli, kdy je v¹ech ¹est breakpointù zaregistrováno, je mo¾né spustit
statickou metodu <strong>main</strong> demonstraèní tøídy
<strong>Test33</strong>. Pøi ka¾dém pøístupu do jedné ze ¹esti testovacích
metod dojde k&nbsp;zavolání callback funkce nazvané
<strong>callback_on_breakpoint</strong>, v&nbsp;ní¾ se nejprve zjistí jméno a
signatura metody s&nbsp;breakpointem a posléze se ze signatury metody zjistí,
jaká je její návratová hodnota. Vyu¾íváme zde pøitom faktu, ¾e v¹ech ¹est
testovacích metod vrací buï hodnotu primitivního datového typu nebo se jedná o
metodu typu <strong>void</strong>. Ve v¹ech tìchto pøípadech lze typ návratové
hodnoty jednodu¹e zjistit z&nbsp;posledního znaku signatury. Ponìkud slo¾itìj¹í
je to v&nbsp;pøípadì, ¾e metoda bude vracet referenci (tj.&nbsp;odkaz na
instanci nìjaké tøídy), tuto situaci v¹ak prozatím nemusíme øe¹it:</p>

<pre>
<i>/*</i>
<i> * Callback funkce zavolana pri zapisu vybranych atributu</i>
<i> */</i>
static void JNICALL <strong>callback_on_breakpoint</strong>(
        jvmtiEnv *jvmti_env,
        JNIEnv   *jni_env,
        jthread   thread,
        jmethodID method,
        jlocation location)
{
    char      *method_name_ptr;
    char      *method_signature_ptr;
    char       return_type;
    jvmtiError error;
&nbsp;
<i>    /* veskere operace se budou provadet v kriticke sekci */</i>
    enter_critical_section(jvmti_env);
&nbsp;
<i>    /* ziskat jmeno metody */</i>
    (*jvmti_env)-&gt;<strong>GetMethodName</strong>(jvmti_env, method, &amp;method_name_ptr, &amp;method_signature_ptr, NULL);
&nbsp;
<i>    /* ze signatury lze ziskat jmeno navratoveho typu (nepouzivame prozatim objektove typy) */</i>
    return_type = method_signature_ptr[strlen(method_signature_ptr)-1];
&nbsp;
<i>    /* vypis vsech informaci o vyjimce */</i>
    printf(AGENT_NAME " *** visited breakpoint in method %s with signature %s and return type %c ***\n",
            method_name_ptr,
            method_signature_ptr,
            return_type);
&nbsp;
<i>    /* vynutime si predcasne ukonceni metod */</i>
    <strong>force_early_return</strong>(jvmti_env, thread, return_type);
&nbsp;
<i>    /* dealokace vsech ziskanych pametovych struktur */</i>
    error = (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char *)method_name_ptr);
    check_jvmti_error(jvmti_env, error, "deallocate method name");
&nbsp;
    error = (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char *)method_signature_ptr);
    check_jvmti_error(jvmti_env, error, "deallocate method signature");
&nbsp;
<i>    /* a vystup z kriticke sekce */</i>
    exit_critical_section(jvmti_env);
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Tvar u¾ivatelské funkce <strong>force_early_return()</strong></h2>

<p>V&nbsp;callback funkci <strong>callback_on_breakpoint()</strong> popsané <a
href="#k07">v&nbsp;pøedchozí kapitole</a> se volá u¾ivatelská funkce nazvaná
pøíznaènì <strong>force_early_return()</strong>. Této funkci se pøedává
reference na prostøedí <i>JVM TI</i> (to potøebujeme ve v¹ech pøípadech), dále
pak identifikátor vlákna, v&nbsp;nìm¾ do¹lo k&nbsp;prùchodu breakpointem a
koneènì se ve tøetím parametru pøedává znak urèující návratový typ metody.
Právì na základì tohoto znaku se provede rozeskok, který zajistí, ¾e se zavolá
korektní varianta <i>JVM TI</i> funkce <strong>ForceEarlyReturn*()</strong>.
Pokud by se toti¾ napøíklad pou¾ila funkce
<strong>ForceEarlyReturnVoid()</strong> u metody s&nbsp;návratovým typem
<strong>int</strong>, byla by tato akce zamítnuta jako chyba (kontrolu
samozøejmì provádí pøímo virtuální stroj Javy):</p>

<pre>
<i>/*</i>
<i> * Funkce, ktera zajisti predcasny vyskok z metody</i>
<i> */</i>
void <strong>force_early_return</strong>(jvmtiEnv *jvmti_env, jthread thread, char return_type)
{
    jvmtiError error;
    switch (return_type)
    {
        case 'V':
            error = (*jvmti_env)-&gt;<strong>ForceEarlyReturnVoid</strong>(jvmti_env, thread);
            check_jvmti_error(jvmti_env, error, "ForceEarlyReturnVoid");
            break;
        case 'Z':
            error = (*jvmti_env)-&gt;<strong>ForceEarlyReturnInt</strong>(jvmti_env, thread, 1);
            check_jvmti_error(jvmti_env, error, "ForceEarlyReturnInt");
            break;
        case 'I':
            error = (*jvmti_env)-&gt;<strong>ForceEarlyReturnInt</strong>(jvmti_env, thread, 42);
            check_jvmti_error(jvmti_env, error, "ForceEarlyReturnInt");
            break;
        case 'J':
            error = (*jvmti_env)-&gt;<strong>ForceEarlyReturnLong</strong>(jvmti_env, thread, 0x7fffffffffffffffLL);
            check_jvmti_error(jvmti_env, error, "ForceEarlyReturnLong");
            break;
        case 'F':
            error = (*jvmti_env)-&gt;<strong>ForceEarlyReturnFloat</strong>(jvmti_env, thread, 0.5f);
            check_jvmti_error(jvmti_env, error, "ForceEarlyReturnFloat");
            break;
        case 'D':
            error = (*jvmti_env)-&gt;<strong>ForceEarlyReturnDouble</strong>(jvmti_env, thread, 3.1415927);
            check_jvmti_error(jvmti_env, error, "ForceEarlyReturnDouble");
            break;
        default:
            break;
    }
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Spu¹tìní tøicátého tøetího demonstraèního JVM TI agenta</h2>

<p>Nyní si ji¾ mù¾eme tøicátého tøetího demonstraèního <i>JVM TI</i> agenta
otestovat. Pokud pouze spustíme testovací tøídu <strong>Test33</strong> bez
pou¾ití agenta, budou zprávy vypisované na standardní výstup vypadat
následovnì:</p>

<pre>
voidMethod1
voidMethod2
&nbsp;
booleanMethod1
booleanMethod2
false
&nbsp;
intMethod1
intMethod2
0
&nbsp;
longMethod1
longMethod2
0
&nbsp;
floatMethod1
floatMethod2
0.0
&nbsp;
doubleMethod1
doubleMethod2
0.0
</pre>

<p>Vidíme, ¾e se v&nbsp;ka¾dé metodì skuteènì zavolaly oba pøíkazy
<strong>System.out.println();</strong> a provedl se i pøíkaz <strong>return
(návratová hodnota)</strong>. Ov¹em v&nbsp;pøípadì, ¾e spustíme virtuální stroj
Javy i s&nbsp;agentem, bude výstup vypadat znaènì odli¹nì:</p>

<pre>
voidMethod1
&nbsp;
booleanMethod1
true
&nbsp;
intMethod1
42
&nbsp;
longMethod1
9223372036854775807
&nbsp;
floatMethod1
0.5
&nbsp;
doubleMethod1
3.1415927
</pre>

<p>V&nbsp;ka¾dé testovací metodì se v&nbsp;tomto pøípadì zavolal pouze první
pøíkaz <strong>System.out.println();</strong> a ihned poté do¹lo v&nbsp;<i>JVM
TI</i> agentovi k&nbsp;zavolání callback funkce
<strong>callback_on_breakpoint()</strong>, kde se provedl pøedèasný výskok
z&nbsp;metody.</p>

<p>Pro úplnost si je¹tì uveïme zprávy vypisované samotným agentem pøi bìhu
virtuálního stroje Javy:</p>

<pre>
Agent33: Agent_OnLoad
Agent33: JVM TI version is correct
Agent33: Got VM init event
Agent33: Class Test33; prepared, setting breakpoints for its methods
Agent33: Found method(): &lt;init&gt; with signature ()V
Agent33: Found method(): main with signature ([Ljava/lang/String;)V
Agent33: Found method(): run with signature ()V
Agent33: Found method(): voidMethod with signature ()V
Agent33: ...going to set breakpoint for this method
Agent33: Found method(): booleanMethod with signature ()Z
Agent33: ...going to set breakpoint for this method
Agent33: Found method(): intMethod with signature ()I
Agent33: ...going to set breakpoint for this method
Agent33: Found method(): longMethod with signature ()J
Agent33: ...going to set breakpoint for this method
Agent33: Found method(): floatMethod with signature ()F
Agent33: ...going to set breakpoint for this method
Agent33: Found method(): doubleMethod with signature ()D
Agent33: ...going to set breakpoint for this method
Agent33: *** visited breakpoint in method voidMethod with signature ()V and return type V ***
Agent33: *** visited breakpoint in method booleanMethod with signature ()Z and return type Z ***
Agent33: *** visited breakpoint in method intMethod with signature ()I and return type I ***
Agent33: *** visited breakpoint in method longMethod with signature ()J and return type J ***
Agent33: *** visited breakpoint in method floatMethod with signature ()F and return type F ***
Agent33: *** visited breakpoint in method doubleMethod with signature ()D and return type D ***
Agent33: ERROR: JVMTI: 34(JVMTI_ERROR_TYPE_MISMATCH): ForceEarlyReturnDouble
Agent33: Got VM Death event
Agent33: Agent_OnUnload
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Zdrojové kódy tøicátého tøetího demonstraèního agenta i k&nbsp;nìmu pøíslu¹ných testovacích pøíkladù a skriptù</h2>

<p>V&nbsp;tomto seriálu se ji¾ stalo zvykem ukládat v¹echny zdrojové soubory i
pomocné skripty do Mercurial repositáøe dostupného na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
Výjimku samozøejmì neudìláme ani dnes:</p>

<table>
<tr><td>Agent #33                     </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6f4c18dd1787/jvmti-agents/agent33/agent33.c">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6f4c18dd1787/jvmti-agents/agent33/agent33.c</a></td></tr>
<tr><td>Skript pro pøeklad agenta #33 </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6f4c18dd1787/jvmti-agents/agent33/compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6f4c18dd1787/jvmti-agents/agent33/compile.sh</a></td></tr>
<tr><td>Skript pro spu¹tìní agenta #33</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6f4c18dd1787/jvmti-agents/agent33/test.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6f4c18dd1787/jvmti-agents/agent33/test.sh</a></td></tr>
<tr><td>Testovací tøída Test33.java   </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6f4c18dd1787/jvmti-agents/agent33/Test33.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6f4c18dd1787/jvmti-agents/agent33/Test33.java</a></td></tr>
</table>



<p><a name="k11"></a></p>
<h2 id="k11">11. Odkazy na Internetu</h2>

<ol>

<li>Breakpoint (Wikipedia)<br />
<a href="http://cs.wikipedia.org/wiki/Breakpoint">http://cs.wikipedia.org/wiki/Breakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation<br />
<a href="http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html">http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; SetBreakpoint<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#SetBreakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#SetBreakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; ClearBreakpoint<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#ClearBreakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#ClearBreakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; Breakpoint (callback funkce)<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#Breakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#Breakpoint</a>
</li>

<li>The JVM Tool Interface (JVM TI): How VM Agents Work<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html">http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html</a>
</li>

<li>Creating a Debugging and Profiling Agent with JVMTI<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html">http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html</a>
</li>

<li>JVM TI (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/JVM_TI">http://en.wikipedia.org/wiki/JVM_TI</a>
</li>

<li>IBM JVMTI extensions<br />
<a href="http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html">http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

