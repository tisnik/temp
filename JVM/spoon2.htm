<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Analýza a transformace kódu psaného v Javě s využitím knihovny Spoon (2)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Analýza a transformace kódu psaného v Javě s využitím knihovny Spoon (2)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhé části článku o knihovně Spoon, kterou lze použít pro analýzu či dokonce transformace kódu psaného v Javě, dokončíme téma takzvaných &bdquo;procesorů&ldquo;, jež mohou sloužit k relativně jednoduchým analýzám kódu.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Analýza a transformace kódu psaného v&nbsp;Javě s&nbsp;využitím knihovny Spoon (2)</a></p>
<p><a href="#k02">2. Třídy použité pro otestování činnosti procesorů</a></p>
<p><a href="#k03">3. První procesor vypisující základní informace o nalezených konstruktorech</a></p>
<p><a href="#k04">4. Překlad a použití prvního procesoru</a></p>
<p><a href="#k05">5. Druhý procesor vypisující počet parametrů konstruktoru a počet příkazů v&nbsp;jeho těle</a></p>
<p><a href="#k06">6. Otestování druhého procesoru</a></p>
<p><a href="#k07">7. Výpis jednotlivých příkazů uvnitř těla konstruktorů a modifikátorů konstruktorů</a></p>
<p><a href="#k08">8. Otestování třetího procesoru</a></p>
<p><a href="#k09">9. Procesor pro detekci všech programových smyček</a></p>
<p><a href="#k10">10. Otestování čtvrtého procesoru</a></p>
<p><a href="#k11">11. Procesor pro zpracování informací o programových smyčkách typu <strong>while</strong></a></p>
<p><a href="#k12">12. Otestování pátého procesoru</a></p>
<p><a href="#k13">13. Použité třídy a rozhraní knihovny Spoon</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Analýza a transformace kódu psaného v&nbsp;Javě s&nbsp;využitím knihovny Spoon (2)</h2>

<p><a
href="https://www.root.cz/clanky/analyza-a-transformace-kodu-psaneho-v-jave-s-vyuzitim-knihovny-spoon/">V&nbsp;úvodním
článku</a> pojednávajícím o knihovně Spoon jsme se ve stručnosti seznámili
s&nbsp;tím, jakým způsobem se v&nbsp;této knihovně reprezentují zdrojové kódy
Javy s&nbsp;využitím abstraktního syntaktického stromu (AST). Taktéž jsme si
ukázali některé základní možnosti nabízené takzvanými &bdquo;procesory&ldquo;,
které je možné v&nbsp;případě potřeby použít pro relativně jednoduše zapsané
(implementované) analyzátory kódů. Dnes toto téma dokončíme, protože si ukážeme
několik dalších procesorů. Tvorba procesorů však samozřejmě nebude pouze
samoúčelná, protože se při jejich vyváření seznámíme s&nbsp;některými dalšími
vlastnostmi AST, tj.&nbsp;s&nbsp;typy objektů, které jsou do AST ukládány i se
samotným způsobem ukládání (konstruktory, metody, programové smyčky, jednotlivé
výrazy apod.)</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Třídy použité pro otestování činnosti procesorů</h2>

<p>Podobně jako tomu bylo minule, i v&nbsp;dnešním článku budou jednotlivé
procesory testovány s&nbsp;využitím několika velmi jednoduchých tříd, které
jsou ve stručnosti popsány v&nbsp;následujících podkapitolách:</p>



<h3>EmptyClass</h3>

<p>Zde je popis snadný &ndash; jedná se o prázdnou veřejnou třídu
s&nbsp;implicitně vytvořeným konstruktorem. Ten sice není ve zdrojovém kódu
viditelný, ale v&nbsp;AST ho najdeme (což odpovídá JLS):</p>

<pre>
public class EmptyClass {
}
</pre>



<h3>ManyConstructors</h3>

<p>Druhá třída obsahuje několik konstruktorů, které se od sebe odlišují počtem
a typem parametrů, existencí či neexistencí těla konstruktoru a taktéž
specifikovanou viditelností (<strong>private</strong>,
<strong>protected</strong>, <strong>public</strong>,
<strong>výchozí</strong>):</p>

<pre>
public class ManyConstructors {
&nbsp;
    ManyConstructors() {
    }
&nbsp;
    ManyConstructors(int x) {
    }
&nbsp;
    ManyConstructors(int x, int y) {
    }
&nbsp;
    ManyConstructors(String str) {
    }
&nbsp;
    ManyConstructors(String... strs) {
    }
&nbsp;
    ManyConstructors(float x) {
        System.out.println(x);
    }
&nbsp;
    ManyConstructors(float x, float y) {
        System.out.println(x);
        System.out.println(y);
    }
&nbsp;
    private ManyConstructors(double a) {
    }
&nbsp;
    protected ManyConstructors(double a, double b) {
    }
&nbsp;
    public ManyConstructors(double a, double b, double c) {
    }
}
</pre>



<h3>WhileLoop1</h3>

<p>Ve třetí testovací třídě nalezneme statickou metodu <strong>main()</strong>
obsahující programovou smyčku typu <strong>while</strong>:</p>

<pre>
class WhileLoop1 {
    public static void main(String[] args) throws Exception {
        int i = 1;
&nbsp;
        while (i &lt;= 10) {
            System.out.println(i);
            i++;
        }
    }
}
</pre>

<p>Poznámka: deklarace <strong>throws Exception</strong> si prozatím nemusíme
všímat, bude využita v&nbsp;dalších příkladech.</p>



<h3>Loops</h3>

<p>Poslední třída obsahuje trojici počítaných programových smyček. Nalezneme
zde smyčku typu <strong>while</strong>, <strong>do-while</strong> i počítanou
smyčku typu <strong>for</strong>:</p>

<pre>
class Loops {
    public static void main(String[] args) throws Exception {
        int i = 1;
&nbsp;
        do {
            System.out.println(i);
            i++;
        } while (i&lt;=10);
&nbsp;
        i=1;
        while (i &lt;= 10) {
            System.out.println(i);
            i++;
        }
&nbsp;
        for (i=0; i&lt;10; i++) {
            System.out.println(i);
        }
    }
}
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. První procesor vypisující základní informace o nalezených konstruktorech</h2>

<p>Minule jsme si ukázali, jak lze vytvořit jednoduchý procesor pro určené typy
elementů a jakým způsobem je možné pro některé elementy v&nbsp;AST zjistit
jejich pozici ve zdrojovém souboru. Zkusme si nyní vytvořit procesor, který
zpracuje všechny nalezené konstruktory. Základní princip již známe &ndash;
vytvoříme potomka třídy <strong>AbstractProcessor</strong> a s&nbsp;využitím
generického typu určíme, jaké typy elementů se budou tímto procesorem
zpracovávat. Vlastní zpracování zajišťuje metoda <strong>process()</strong>,
která je automaticky zavolána při průchodu AST. U konstruktorů, které jsou
v&nbsp;knihovně Spoon reprezentovány objekty implementujícími rozhraní
<strong>CtConstructor</strong>, lze zjistit jejich pozici ve zdrojovém kódu,
jejich jméno i takzvanou signaturu (o signaturách jsem se zmiňoval již
například <a
href="https://www.root.cz/clanky/pohled-pod-kapotu-jvm-2-cast-podrobnejsi-analyza-obsahu-constant-poolu/">v&nbsp;tomto
článku</a>). Celý procesor bude vypadat následovně a nebude se tedy příliš
lišit od již popsaných procesorů (až na zjištění signatury):</p>

<pre>
import spoon.processing.AbstractProcessor;
import spoon.reflect.declaration.CtConstructor;
import spoon.reflect.cu.SourcePosition;
&nbsp;
public class ConstructorsProcessor extends AbstractProcessor&lt;CtConstructor&gt; {
    public void process(CtConstructor element) {
        SourcePosition sp = element.getPosition();
        String position = sp == null ? "unknown" : sp.toString();
        String name = element.getSimpleName();
        String signature = element.getSignature();
        System.out.println("constructor '" + name + "' with signature '" + signature + "' declared at:" + sp);
    }
}
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Překlad a použití prvního procesoru</h2>

<p>Překlad prvního procesoru se provede stejným způsobem, který již známe
z&nbsp;úvodního článku:</p>

<pre>
javac -cp spoon-core-5.3.0-jar-with-dependencies.jar ConstructorsProcessor.java
</pre>

<p>Zkusme si nyní procesor spustit s&nbsp;třídou <strong>EmptyClass</strong>:</p>

<pre>
<strong>java -cp .:spoon-core-5.3.0-jar-with-dependencies.jar spoon.Launcher -p ConstructorsProcessor -i EmptyClass.java</strong>
&nbsp;
constructor '&lt;init&gt;' with signature 'EmptyClass()' declared at:(/home/tester/spoon/EmptyClass.java:1)
</pre>

<p>Z&nbsp;výpisu můžeme vidět, že se ve třídě nalezl implicitní konstruktor, i
když ve zdrojovém kódu se tento konstruktor nenachází. Spoon tento konstruktor
do vytvářeného AST přidal, protože to odpovídá JLS (Java Language
Specification).</p>

<p>Druhý test provedeme s&nbsp;třídou <strong>ManyConstructors</strong>:</p>

<pre>
<strong>java -cp .:spoon-core-5.3.0-jar-with-dependencies.jar spoon.Launcher -p ConstructorsProcessor -i ManyConstructors.java</strong>
&nbsp;
constructor '&lt;init&gt;' with signature 'ManyConstructors()' declared at:(/home/tester/spoon/ManyConstructors.java:2)
constructor '&lt;init&gt;' with signature 'ManyConstructors(double)' declared at:(/home/tester/spoon/ManyConstructors.java:19)
constructor '&lt;init&gt;' with signature 'ManyConstructors(double,double)' declared at:(/home/tester/spoon/ManyConstructors.java:21)
constructor '&lt;init&gt;' with signature 'ManyConstructors(double,double,double)' declared at:(/home/tester/spoon/ManyConstructors.java:23)
constructor '&lt;init&gt;' with signature 'ManyConstructors(float)' declared at:(/home/tester/spoon/ManyConstructors.java:12)
constructor '&lt;init&gt;' with signature 'ManyConstructors(float,float)' declared at:(/home/tester/spoon/ManyConstructors.java:15)
constructor '&lt;init&gt;' with signature 'ManyConstructors(int)' declared at:(/home/tester/spoon/ManyConstructors.java:4)
constructor '&lt;init&gt;' with signature 'ManyConstructors(int,int)' declared at:(/home/tester/spoon/ManyConstructors.java:6)
constructor '&lt;init&gt;' with signature 'ManyConstructors(java.lang.String)' declared at:(/home/tester/spoon/ManyConstructors.java:8)
constructor '&lt;init&gt;' with signature 'ManyConstructors(java.lang.String[])' declared at:(/home/tester/spoon/ManyConstructors.java:10)
</pre>

<p>Povšimněte si rozdílné signatury konstruktorů, zejména pak signatury
posledního konstruktoru, kde se ... (variabilní počet parametrů) převedl na
pole řetězců (opět podle JLS).</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Druhý procesor vypisující počet parametrů konstruktoru a počet příkazů v&nbsp;jeho těle</h2>

<p>Druhý procesor, který si dnes ukážeme, bude nepatrně složitější, protože
v&nbsp;něm budeme vypisovat jak počet parametrů konstruktoru (zatím jen počet,
ne jména nebo typy) i počet příkazů, které jsou uvedeny (ať již explicitně či
implicitně) v&nbsp;jeho těle. Příkazy se získají voláním
<strong>CtConstructor.getBody().getStatements()</strong> vracející seznam,
parametry se získají voláním
<strong>CtConstructor.getParameters()</strong>:</p>

<pre>
import spoon.processing.AbstractProcessor;
import spoon.reflect.declaration.CtConstructor;
import spoon.reflect.cu.SourcePosition;
&nbsp;
public class ConstructorsProcessor2 extends AbstractProcessor&lt;CtConstructor&gt; {
    public void process(CtConstructor element) {
        SourcePosition sp = element.getPosition();
        String position = sp == null ? "unknown" : sp.toString();
        String name = element.getSimpleName();
        String signature = element.getSignature();
&nbsp;
        int statements = element.getBody().getStatements().size();
        int parameters = element.getParameters().size();
&nbsp;
        System.out.println("constructor '" + name + "' with signature '" + signature + "' declared at:" + sp);
        System.out.println("    parameters: " + parameters);
        System.out.println("    statements: " + statements);
    }
}
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Otestování druhého procesoru</h2>

<p>Opět si tento procesor odzkoušíme na třídách <strong>EmptyClass</strong> a
<strong>ManyConstructors</strong>:</p>

<pre>
<strong>java -cp .:spoon-core-5.3.0-jar-with-dependencies.jar spoon.Launcher -p ConstructorsProcessor2 -i EmptyClass.java</strong>
&nbsp;
constructor '&lt;init&gt;' with signature 'EmptyClass()' declared at:(/home/tester/spoon/EmptyClass.java:1)
    parameters: 0
    statements: 1
</pre>

<p>Výsledek je v&nbsp;tomto případě zajímavý, i když očekávatelný &ndash;
v&nbsp;implicitně vytvořeném konstruktoru se nachází jeden příkaz! O který
příkaz se jedná nám opět může prozradit JLS &ndash; jde o volání konstruktoru
předka (tedy <strong>super()</strong>), o čemž se ostatně přesvědčíme
v&nbsp;následujícím příkladu.</p>

<p>Při této znalosti nás již další test s&nbsp;třídou
<strong>ManyConstructors</strong> nepřekvapí:</p>

<pre>
<strong>java -cp .:spoon-core-5.3.0-jar-with-dependencies.jar spoon.Launcher -p ConstructorsProcessor2 -i ManyConstructors.java</strong>
&nbsp;
constructor '&lt;init&gt;' with signature 'ManyConstructors()' declared at:(/home/tester/spoon/ManyConstructors.java:2)
    parameters: 0
    statements: 1
constructor '&lt;init&gt;' with signature 'ManyConstructors(double)' declared at:(/home/tester/spoon/ManyConstructors.java:19)
    parameters: 1
    statements: 1
constructor '&lt;init&gt;' with signature 'ManyConstructors(double,double)' declared at:(/home/tester/spoon/ManyConstructors.java:21)
    parameters: 2
    statements: 1
constructor '&lt;init&gt;' with signature 'ManyConstructors(double,double,double)' declared at:(/home/tester/spoon/ManyConstructors.java:23)
    parameters: 3
    statements: 1
constructor '&lt;init&gt;' with signature 'ManyConstructors(float)' declared at:(/home/tester/spoon/ManyConstructors.java:12)
    parameters: 1
    statements: 2
constructor '&lt;init&gt;' with signature 'ManyConstructors(float,float)' declared at:(/home/tester/spoon/ManyConstructors.java:15)
    parameters: 2
    statements: 3
constructor '&lt;init&gt;' with signature 'ManyConstructors(int)' declared at:(/home/tester/spoon/ManyConstructors.java:4)
    parameters: 1
    statements: 1
constructor '&lt;init&gt;' with signature 'ManyConstructors(int,int)' declared at:(/home/tester/spoon/ManyConstructors.java:6)
    parameters: 2
    statements: 1
constructor '&lt;init&gt;' with signature 'ManyConstructors(java.lang.String)' declared at:(/home/tester/spoon/ManyConstructors.java:8)
    parameters: 1
    statements: 1
constructor '&lt;init&gt;' with signature 'ManyConstructors(java.lang.String[])' declared at:(/home/tester/spoon/ManyConstructors.java:10)
    parameters: 1
    statements: 1
</pre>

<p>Poznámka: pokud si procesor předěláte takovým způsobem, aby detekoval metody
a ne konsturktory, zjistíte, že u nestatických metod je jeden parametr navíc
&ndash; jedná se o <strong>this</strong>.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Výpis jednotlivých příkazů uvnitř těla konstruktorů a modifikátorů konstruktorů</h2>

<p>Poslední procesor, který bude vypisovat informace o všech nalezených
konstruktorech, je opět složitější, protože zjistí a vypíše všechny příkazy
uvnitř těla konstruktoru a navíc ještě vypíše explicitně zapsané modifikátory
(<strong>public</strong>, <strong>private</strong>,
<strong>protected</strong>). Pokud by se namísto konstruktorů zjišťovaly
informace o metodách, bylo by možné zjistit i další modifikátory, například
<strong>static</strong>, <strong>strictfp</strong> apod. Povšimněte si, že
modifikátory se vrací ve formě množiny (<strong>Set</strong>), jejíž prvky jsou
typu <strong>ModifierKind</strong>. Příkazy se vrací ve formě seznamu, ovšem
pokud by se v&nbsp;konstruktoru nacházely další podbloky, každý by byl opět
reprezentován seznamem, který &bdquo;zastřešují&ldquo; objekty typu
<strong>CtBlock</strong> (ten nalezneme i v&nbsp;programových smyčkách,
podmínkových konstrukcích apod.). Podívejme se na zdrojový kód dnešního třetího
procesoru:</p>

<pre>
import java.util.Set;
&nbsp;
import spoon.processing.AbstractProcessor;
import spoon.reflect.declaration.CtConstructor;
import spoon.reflect.cu.SourcePosition;
import spoon.reflect.declaration.ModifierKind;
import spoon.reflect.code.CtStatement;
&nbsp;
public class ConstructorsProcessor3 extends AbstractProcessor&lt;CtConstructor&gt; {
    public void process(CtConstructor element) {
        SourcePosition sp = element.getPosition();
        String position = sp == null ? "unknown" : sp.toString();
        String name = element.getSimpleName();
        String signature = element.getSignature();
&nbsp;
        int statements = element.getBody().getStatements().size();
        int parameters = element.getParameters().size();
        Set&lt;ModifierKind&gt; modifiers = element.getModifiers();
&nbsp;
        System.out.println("constructor '" + name + "' with signature '" + signature + "' declared at:" + sp);
        System.out.println("    parameters: " + parameters);
        System.out.println("    statements: " + statements);
        for (ModifierKind modifier : modifiers) {
            System.out.println("    modifier " + modifier);
        }
        System.out.println("    body:");
        for (CtStatement statement: element.getBody().getStatements()) {
            System.out.println("        " +    statement);
        }
        System.out.println();
    }
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Otestování třetího procesoru</h2>

<p>U popisu předchozího procesoru jsem tvrdil, že u konstruktorů
s&nbsp;prázdným tělem (a tedy i u implicitně vytvořeného konstruktoru) se jako
první příkaz automaticky volá konstruktor předka, tedy
<strong>super()</strong>. Nyní se o platnosti tohoto tvrzení můžeme velmi
snadno přesvědčit:</p>

<pre>
<strong>java -cp .:spoon-core-5.3.0-jar-with-dependencies.jar spoon.Launcher -p ConstructorsProcessor3 -i EmptyClass.java</strong>
&nbsp;
constructor '&lt;init&gt;' with signature 'EmptyClass()' declared at:(/home/tester/spoon/EmptyClass.java:1)
    parameters: 0
    statements: 1
    modifier public
    body:
        super()
</pre>

<p>Vidíme, že se v&nbsp;případě implicitně vytvořeného konstruktoru skutečně do
jeho těla vloží volání <strong>super()</strong>. Navíc má tento konstruktor
modifikátor <strong>public</strong>.</p>

<p>V&nbsp;případě třídy <strong>ManyConstructors</strong> si povšimněte
modifikátorů jednotlivých konstruktorů a samozřejmě taktéž toho, že
<strong>super()</strong> se volá i v&nbsp;konstruktorech s&nbsp;dalšími
příkazy:</p>

<pre>
<strong>java -cp .:spoon-core-5.3.0-jar-with-dependencies.jar spoon.Launcher -p ConstructorsProcessor3 -i ManyConstructors.java</strong>
&nbsp;
constructor '&lt;init&gt;' with signature 'ManyConstructors()' declared at:(/home/tester/spoon/ManyConstructors.java:2)
    parameters: 0
    statements: 1
    body:
        super()
&nbsp;
constructor '&lt;init&gt;' with signature 'ManyConstructors(double)' declared at:(/home/tester/spoon/ManyConstructors.java:19)
    parameters: 1
    statements: 1
    modifier private
    body:
        super()
&nbsp;
constructor '&lt;init&gt;' with signature 'ManyConstructors(double,double)' declared at:(/home/tester/spoon/ManyConstructors.java:21)
    parameters: 2
    statements: 1
    modifier protected
    body:
        super()
&nbsp;
constructor '&lt;init&gt;' with signature 'ManyConstructors(double,double,double)' declared at:(/home/tester/spoon/ManyConstructors.java:23)
    parameters: 3
    statements: 1
    modifier public
    body:
        super()
&nbsp;
constructor '&lt;init&gt;' with signature 'ManyConstructors(float)' declared at:(/home/tester/spoon/ManyConstructors.java:12)
    parameters: 1
    statements: 2
    body:
        super()
        java.lang.System.out.println(x)
&nbsp;
constructor '&lt;init&gt;' with signature 'ManyConstructors(float,float)' declared at:(/home/tester/spoon/ManyConstructors.java:15)
    parameters: 2
    statements: 3
    body:
        super()
        java.lang.System.out.println(x)
        java.lang.System.out.println(y)
&nbsp;
constructor '&lt;init&gt;' with signature 'ManyConstructors(int)' declared at:(/home/tester/spoon/ManyConstructors.java:4)
    parameters: 1
    statements: 1
    body:
        super()
&nbsp;
constructor '&lt;init&gt;' with signature 'ManyConstructors(int,int)' declared at:(/home/tester/spoon/ManyConstructors.java:6)
    parameters: 2
    statements: 1
    body:
        super()
&nbsp;
constructor '&lt;init&gt;' with signature 'ManyConstructors(java.lang.String)' declared at:(/home/tester/spoon/ManyConstructors.java:8)
    parameters: 1
    statements: 1
    body:
        super()
&nbsp;
constructor '&lt;init&gt;' with signature 'ManyConstructors(java.lang.String[])' declared at:(/home/tester/spoon/ManyConstructors.java:10)
    parameters: 1
    statements: 1
    body:
        super()
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Procesor pro detekci všech programových smyček</h2>

<p>Zpracování metod se v&nbsp;mnoha ohledech podobá zpracování konstruktorů,
takže se raději podívejme na další typy programových konstrukcí v&nbsp;Javě,
které mají svůj obraz ve vytvořeném AST. Jednou z&nbsp;těchto konstrukcí je
obecná programová smyčka reprezentovaná objektem implementujícím rozhraní
<strong>CtLoop</strong>. V&nbsp;programech samozřejmě neexistují žádné obecné
smyčky, ale jen jejich konkrétní implementace, tj.&nbsp;<strong>CtDo</strong>,
<strong>CtWhile</strong>, <strong>CtFor</strong> (ta představuje počítanou
smyčku for) a konečně <strong>CtForEach</strong> (ta představuje for nad
iterátorem). Pokud však pracujeme s&nbsp;objekty typu <strong>CtLoop</strong>,
můžeme o smyčce zjistit jen základní informace &ndash; tělo smyčky (nikoli však
například podmínku):</p>

<pre>
import java.util.Set;
&nbsp;
import spoon.processing.AbstractProcessor;
import spoon.reflect.cu.SourcePosition;
import spoon.reflect.code.CtLoop;
import spoon.reflect.code.CtStatement;
&nbsp;
public class LoopDetector extends AbstractProcessor&lt;CtLoop&gt; {
    public void process(CtLoop element) {
        SourcePosition sp = element.getPosition();
        String position = sp == null ? "unknown" : sp.toString();
        CtStatement loopStatement = element.getBody();

        System.out.println("loop: " + loopStatement + " declared at:" + sp);
        System.out.println();
    }
}
</pre>


<p><a name="k10"></a></p>
<h2 id="k10">10. Otestování čtvrtého procesoru</h2>

<p>Tento procesor si otestujeme na třídách <strong>WhileLoop1</strong> a
<strong>Loops</strong>.</p>

<pre>
<strong>java -cp .:spoon-core-5.3.0-jar-with-dependencies.jar spoon.Launcher -p LoopDetector -i WhileLoop1</strong>
&nbsp;
loop: {
    java.lang.System.out.println(i);
    i++;
} declared at:(/home/tester/spoon/WhileLoop1.java:5)
</pre>

<pre>
<strong>java -cp .:spoon-core-5.3.0-jar-with-dependencies.jar spoon.Launcher -p LoopDetector -i Loops</strong>
&nbsp;
loop: {
    java.lang.System.out.println(i);
    i++;
} declared at:(/home/tester/temp/presentations/spoon/Loops.java:5)
&nbsp;
loop: {
    java.lang.System.out.println(i);
    i++;
} declared at:(/home/tester/temp/presentations/spoon/Loops.java:11)
&nbsp;
loop: {
    java.lang.System.out.println(i);
} declared at:(/home/tester/temp/presentations/spoon/Loops.java:16)
</pre>

<p>Povšimněte si, že se vždy vypíše celé tělo smyčky, protože objekty typu
<strong>CtStatement</strong> lze převést na (čitelnou) řetězcovou podobu.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Procesor pro zpracování informací o programových smyčkách typu <strong>while</strong></h2>

<p>Jakým způsobem je však možné získat další informace o nalezené programové
smyčce, například podmínku, která se testuje v&nbsp;každé iteraci
(resp.&nbsp;před či po každé iteraci)? U procesoru pro obecné smyčky
<strong>CtLoop</strong> to sice není snadné, protože by se musel testovat
konkrétní typ každého objektu a provádět přetypování (to v&nbsp;Javě není
příliš idiomatický kód), není však žádný problém si vytvořit specializovaný
procesor například jen pro smyčky typu <strong>while</strong>. U těchto smyček
se již dá podmínka získat metodou
<strong>CtWhile.getLoopingExpression</strong>:</p>

<pre>
import java.util.Set;
&nbsp;
import spoon.processing.AbstractProcessor;
import spoon.reflect.cu.SourcePosition;
import spoon.reflect.code.CtWhile;
import spoon.reflect.code.CtStatement;
import spoon.reflect.code.CtExpression;
&nbsp;
public class WhileLoopDetector extends AbstractProcessor&lt;CtWhile&gt; {
    public void process(CtWhile element) {
        SourcePosition sp = element.getPosition();
        String position = sp == null ? "unknown" : sp.toString();
        CtStatement loopStatement = element.getBody();
        CtExpression loopingExpression = element.getLoopingExpression();
&nbsp;
        System.out.println("loop: " + loopStatement + " declared at:" + sp);
        System.out.println("expression (test): " + loopingExpression);
        System.out.println();
    }
}
</pre>


<p><a name="k12"></a></p>
<h2 id="k12">12. Otestování pátého procesoru</h2>

<p>Procesor pro programové smyčky typu <strong>while</strong> si otestujeme na
třídě <strong>WhileLoop1</strong> i <strong>Loops</strong>:</p>

<pre>
<strong>java -cp .:spoon-core-5.3.0-jar-with-dependencies.jar spoon.Launcher -p WhileLoopDetector -i WhileLoop1.java</strong>
&nbsp;
loop: {
    java.lang.System.out.println(i);
    i++;
} declared at:(/home/tester/temp/presentations/spoon/WhileLoop1.java:5)
expression (test): i &lt;= 10
</pre>

<pre>
<strong>java -cp .:spoon-core-5.3.0-jar-with-dependencies.jar spoon.Launcher -p WhileLoopDetector -i Loops.java</strong>
&nbsp;
loop: {
    java.lang.System.out.println(i);
    i++;
} declared at:(/home/tester/temp/presentations/spoon/Loops.java:11)
expression (test): i &lt;= 10
</pre>

<p>V&nbsp;obou případech se tedy našla jedna programová smyčka typu
<strong>while</strong> se stejnou podmínkou.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Použité třídy a rozhraní knihovny Spoon</h2>

<ol>

<li>spoon.processing.AbstractProcessor<br />
<a href="http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/processing/AbstractProcessor.html">http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/processing/AbstractProcessor.html</a>
</li>

<li>spoon.reflect.declaration.CtElement<br />
<a href="http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/reflect/declaration/CtElement.html">http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/reflect/declaration/CtElement.html</a>
</li>

<li>spoon.reflect.declaration.CtClass<br />
<a href="http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/reflect/declaration/CtClass.html">http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/reflect/declaration/CtClass.html</a>
</li>

<li>spoon.reflect.declaration.CtConstructor<br />
<a href="http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/reflect/declaration/CtConstructor.html">http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/reflect/declaration/CtConstructor.html</a>
</li>

<li>spoon.reflect.declaration.ModifierKind<br />
<a href="http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/reflect/declaration/ModifierKind.html">http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/reflect/declaration/ModifierKind.html</a>
</li>

<li>spoon.reflect.code.CtLoop<br />
<a href="http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/reflect/code/CtLoop.html">http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/reflect/code/CtLoop.html</a>
</li>

<li>spoon.reflect.code.CtWhile<br />
<a href="http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/reflect/code/CtWhile.html">http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/reflect/code/CtWhile.html</a>
</li>

<li>spoon.reflect.code.CtStatement<br />
<a href="http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/reflect/code/CtStatement.html">http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/reflect/code/CtStatement.html</a>
</li>

<li>spoon.reflect.code.CtExpression<br />
<a href="http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/reflect/code/CtExpression.html">http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/reflect/code/CtExpression.html</a>
</li>

<li>spoon.reflect.cu.SourcePosition<br />
<a href="http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/reflect/cu/SourcePosition.html">http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/reflect/cu/SourcePosition.html</a>
</li>

<li>spoon.reflect.reference.CtVariableReference<br />
<a href="http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/reflect/reference/CtVariableReference.html">http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/reflect/reference/CtVariableReference.html</a>
</li>

</ol>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Spoon - Source Code Analysis and Transformation for Jav<br />
<a href="http://spoon.gforge.inria.fr/">http://spoon.gforge.inria.fr/</a>
</li>

<li>Project Filelist for Spoon<br />
<a href="https://gforge.inria.fr/frs/?group_id=73">https://gforge.inria.fr/frs/?group_id=73</a>
</li>

<li>Spoon na GitHubu<br />
<a href="https://github.com/INRIA/spoon">https://github.com/INRIA/spoon</a>
</li>

<li>Instance Jenkinsu, v níž se překládá Spoon<br />
<a href="https://ci.inria.fr/sos/">https://ci.inria.fr/sos/</a>
</li>

<li>JavaParser: Java Parser and Abstract Syntax Tree<br />
<a href="http://javaparser.org/">http://javaparser.org/</a>
</li>

<li>Javaparser na GitHubu<br />
<a href="https://github.com/javaparser/javaparser">https://github.com/javaparser/javaparser</a>
</li>

<li>FindBugs Fact Sheet<br />
<a href="http://findbugs.sourceforge.net/factSheet.html">http://findbugs.sourceforge.net/factSheet.html</a>
</li>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojů využívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (před verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

<li>Abstract syntax tree<br />
<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">https://en.wikipedia.org/wiki/Abstract_syntax_tree</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

