<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - vliv zmìn v syntaxi a sémantice Javy na strukturu bajtkódu</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - vliv zmìn v syntaxi a sémantice Javy na strukturu bajtkódu</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve tøicáté èásti seriálu o programovacím jazyce Java i o vlastnostech JVM navá¾eme na èásti pøedchozí, v nich¾ jsme si popsali instrukèní soubor virtuálního stroje Javy. Øekneme si, jak se mìnila struktura bajtkódu spoleènì s roz¹iøováním syntaxe a sémantiky Javy. Asi nejvìt¹í zmìnou je v¹ak pøidání instrukce invokedynamic do JDK 7, co¾ je o to zvlá¹tnìj¹í, ¾e se vlastnì nejedná o instrukci pou¾ívanou samotnou Javou.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - vliv zmìn v&nbsp;syntaxi a sémantice Javy na strukturu bajtkódu</a></p>
<p><a href="#k02">2. Zmìna syntaxe a sémantiky Javy od JDK 1.0 po Java SE 8</a></p>
<p><a href="#k03">3. Autoboxing a unboxing: øe¹eno pøekladaèem</a></p>
<p><a href="#k04">4. Operátor == pøi pou¾ívání autoboxingu a unboxingu</a></p>
<p><a href="#k05">5. Generické datové typy a bajtkód vytvoøený pøekladaèem</a></p>
<p><a href="#k06">6. Zpùsob pøekladu programové smyèky typu for-each</a></p>
<p><a href="#k07">7. Zpùsob pøekladu pøíkazu switch(String)</a></p>
<p><a href="#k08">8. Slavná nová instrukce invokedynamic</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - vliv zmìn v&nbsp;syntaxi a sémantice Javy na strukturu bajtkódu</h2>

<p>V&nbsp;pøedchozích èástech <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyce Java i o vlastnostech virtuálního stroje tohoto jazyka</a>
jsme si postupnì popsali prakticky v¹echny instrukce tvoøící instrukèní soubor
virtuálního stroje Javy (<i>JVM &ndash; Java Virtual Machine</i>). Tyto a¾
doposud popsané instrukce byly navr¾eny in¾enýry z&nbsp;firmy <i>Sun
Microsystems</i> ji¾ v&nbsp;první polovinì devadesátých let minulého století
pøi vlastním návrhu programovacího jazyka Java i jeho virtuálního stroje
(<i>Java</i> byla oficiálnì pøedstavena v&nbsp;roce 1995 a vydána na zaèátku
roku 1996, tj.&nbsp;je pøibli¾nì stejnì stará jako <i>Ruby</i> a dokonce o
ètyøi roky mlad¹í ne¾ <i>Python</i>).  Zajímavé je, ¾e i kdy¾ se programovací
jazyk Java od té doby vyvíjel a pøidávaly se do nìj nové vlastnosti i nové
programové konstrukce, nebylo nutné instrukèní soubor modifikovat; pouze se
z&nbsp;dùvodù lep¹í kontroly bajtkódu (pøesnìji øeèeno pro zmen¹ení stavového
prostoru pøi jeho bìhové kontrole) pøestaly vyu¾ívat instrukce
<strong>jsr</strong>, <strong>jsr_w</strong> a <strong>ret</strong>.</p>

<p>Kdy¾ se v¹ak zamyslíme na zmìnami, kterými programovací jazyk <i>Java</i> za
pøibli¾nì sedmnáct let své existence pro¹el, uvìdomíme si, ¾e vlastnì
k&nbsp;roz¹íøení instrukèního souboru ani nemuselo dojít, proto¾e se vùbec
nezmìnily základní vlastnosti tohoto jazyka &ndash; pøedev¹ím fakt, ¾e se stále
jedná o staticky typovaný jazyk vyu¾ívající jak primitivní datové typy, tak i
typy objektové. Napøíklad pøidání klíèového slova <strong>strictfp</strong>
v&nbsp;JDK 1.2 (mù¾e se to zdát jako nepodstatná malièkost, ale
v&nbsp;nìkterých oborech je to <strong>velmi</strong> dùle¾itá zmìna dovolující
pronikání Javy do hájemství Fortranu) ovlivnilo pøedev¹ím pøíznaky pøidávané ke
tøídám, metodám a atributùm, tj.&nbsp;do¹lo pouze k&nbsp;pøidání dal¹ího
pøíznakového bitu k&nbsp;bitovému poli ulo¾enému pro ka¾dou tøídu èi metodu
v&nbsp;bajtkódu. Dal¹í zmìny, které Javu potkaly, se na první pohled zdají být
pomìrnì podstatné, ale ve skuteènosti ani pøi jejich implementaci nemuselo
dojít k&nbsp;roz¹íøení instrukèního souboru. Proto¾e se jedná o zajímavé téma
související èásteènì se zpìtnou kompatibilitou bajtkódu (která je stále více na
poøadu dne, jak nám Java postupnì &bdquo;COBOLovatí&ldquo;), uká¾eme si
v&nbsp;navazujícím textu nìjaké ukázky zmìn v&nbsp;Javì a jejich vliv (pokud je
vùbec nìjaký) na výsledný bajtkód.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Zmìna syntaxe a sémantiky Javy od JDK 1.0 po Java SE 8</h2>

<p>V&nbsp;následující tabulce jsou vypsány nejdùle¾itìj¹í zmìny syntaxe a
sémantiky programovacího jazyka Java, které probìhly mezi roky 1996 a¾ 2011
(plus výhled do roku 2013).  V&nbsp;této chvíli nás zajímají skuteènì pouze
zmìny provedené ve vlastním jazyku a nikoli roz¹íøení standardních knihoven
Javy, proto¾e to nemá ¾ádný podstatný vliv na strukturu generovaného bajtkódu.
Pov¹imnìte si takté¾, jakým zpùsobem spoleènost <i>Sun</i> mìnila oznaèení
verzí Javy:</p>

<table>
<tr><th>Rok vydání</th><th>Oznaèení JDK/JRE</th><th>Nové prvky jazyka</th></tr>
<tr><td>1996  </td><td>JDK 1.0  </td><td>první zveøejnìná verze Javy</td></tr>
<tr><td>1997  </td><td>JDK 1.1  </td><td>vnitøní tøídy, podpora pro reflexi (nemá vliv na syntaxi)</td></tr>
<tr><td>1998  </td><td>J2SE 1.2 </td><td>nové klíèové slovo: <strong>strictfp</strong></td></tr>
<tr><td>2000  </td><td>J2SE 1.3 </td><td>syntetické proxy tøídy</td></tr>
<tr><td>2002  </td><td>J2SE 1.4 </td><td>nové klíèové slovo: <strong>assert</strong></td></tr>
<tr><td>2004  </td><td>J2SE 5.0 </td><td>autoboxing, unboxing, smyèka typu for-each, výètový typ, generika</td></tr>
<tr><td>2006  </td><td>Java SE 6</td><td>JSR 223 - podpora pro skriptovací jazyky (nemá vliv na syntaxi)</td></tr>
<tr><td>2011  </td><td>Java SE 7</td><td>nová instrukce: invokedynamic (v Javì nepou¾ito), <strong>switch (String)</strong> a dal¹í <a href="http://www.root.cz/clanky/novinky-v-nbsp-jdk-7-aneb-mirny-pokrok-v-nbsp-mezich-zakona-1/">roz¹íøení provedené v rámci projektu Coin</a></td></tr>
<tr><td>?2013?</td><td>Java SE 8</td><td>lambda výrazy, <a href="http://www.root.cz/clanky/novinky-v-nbsp-jdk-7-aneb-mirny-pokrok-v-nbsp-mezich-zakona-1/">zbylé èásti z projektu Coin</a></td></tr>
</table>

<p>Bli¾¹í informace o projektu <i>Coin</i> byly uvedeny v&nbsp;úvodních èástech
tohoto seriálu:</p>

<ol>

<li>Novinky v JDK 7 aneb mírný pokrok v mezích zákona (1)<br />
<a href="http://www.root.cz/clanky/novinky-v-nbsp-jdk-7-aneb-mirny-pokrok-v-nbsp-mezich-zakona-1/">http://www.root.cz/clanky/novinky-v-nbsp-jdk-7-aneb-mirny-pokrok-v-nbsp-mezich-zakona-1/</a>
</li>

<li>Novinky v JDK 7 aneb mírný pokrok v mezích zákona (2)<br />
<a href="http://www.root.cz/clanky/novinky-v-nbsp-jdk-7-aneb-mirny-pokrok-v-nbsp-mezich-zakona-2/">http://www.root.cz/clanky/novinky-v-nbsp-jdk-7-aneb-mirny-pokrok-v-nbsp-mezich-zakona-2/</a>
</li>

<li>Novinky v JDK 7 (3) + co v JDK 7 naopak nenajdeme<br />
<a href="http://www.root.cz/clanky/novinky-v-nbsp-jdk-7-3-co-v-nbsp-jdk-7-naopak-nenajdeme/">http://www.root.cz/clanky/novinky-v-nbsp-jdk-7-3-co-v-nbsp-jdk-7-naopak-nenajdeme/</a>
</li>

</ol>



<p><a name="k03"></a></p>
<h2 id="k03">3. Autoboxing a unboxing: øe¹eno pøekladaèem</h2>

<p>Jedním z&nbsp;pøíkladù, kdy sice do¹lo ke zmìnì sémantiky programovacího
jazyka Java, ale kdy tato zmìna nemìla ¾ádný dopad na strukturu bajtkódu, je
pøidání podpory pro takzvaný <i>autoboxing</i> a <i>unboxing</i>. O autoboxing
a unboxing, tj.&nbsp;o automatické oboustranné pøevody mezi primitivním datovým
typem a jeho obalovou tøídou (<i>wrapper class</i>), se toti¾ stará pøekladaè,
který pøi konverzích volá pøíslu¹né metody obalové tøídy, tak¾e se na
autoboxing a unboxing mù¾eme z&nbsp;tohoto hlediska dívat jako na vìt¹inou
pøíjemný syntaktický cukr, který v¹ak mù¾e zaèínajícím programátorùm
v&nbsp;nìkterých pøípadech zpùsobit nepøíjemnosti (napøíklad kvùli rozdílu mezi
funkcí operátoru ekvivalence ==, viz té¾ <a href="#k04">následující
kapitolu</a>). Podívejme se na jednoduchý pøíklad, kdy pøekladaè automaticky
provádí pøevody mezi primitivním datovým typem a obalovou tøídou, popø.&nbsp;i
pøevody opaèným smìrem:</p>

<pre>
public class Test {
&nbsp;
    public static int add(Integer a, Integer b)
    {
        // zde se provádí unboxing:
        // pøevod instance tøídy Integer na
        // primitivní datový typ int
        return a+b;
    }
&nbsp;
    public static void main(String[] args) 
    {
        // zde se provádí autoboxing:
        // pøevod int na Integer
        System.out.println(add(1,2));
    }
&nbsp;
}
</pre>

<p>Tento zdrojový text se pøelo¾í následujícím zpùsobem (komentáøe jsou
samozøejmì dopsány ruènì):</p>

<pre>
public static int add(java.lang.Integer, java.lang.Integer);
  Code:
   // unboxing prvního parametru metody s vyu¾itím Integer.intValue()
   0:   aload_0
   1:   invokevirtual   #2; //Method java/lang/Integer.intValue:()I
&nbsp;
   // unboxing druhého parametru metody s vyu¾itím Integer.intValue()
   4:   aload_1
   5:   invokevirtual   #2; //Method java/lang/Integer.intValue:()I
&nbsp;
   // teï ji¾ lze provést souèet dvou primitivních hodnot
   // pomocí jediné instrukce virtuálního stroje
   8:   iadd
   // a vrátit výsledek této operace
   9:   ireturn
&nbsp;
public static void main(java.lang.String[]);
  Code:
   0:   getstatic       #3; //Field java/lang/System.out:Ljava/io/PrintStream;
&nbsp;
   // autoboxing prvního parametru metody add() s vyu¾itím Integer.valueOf(int)
   3:   iconst_1
   4:   invokestatic    #4; //Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
&nbsp;
   // autoboxing druhého parametru metody add() s vyu¾itím Integer.valueOf(int)
   7:   iconst_2
   8:   invokestatic    #4; //Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
&nbsp;
   // nyní máme na zásobníku operandù ulo¾ené
   // dvì REFERENCE na instance tøídy Integer
   // lze tedy volat metodu add(Integer, Integer)
   11:  invokestatic    #5; //Method add:(Ljava/lang/Integer;Ljava/lang/Integer;)I
&nbsp;
   // metoda System.out.println() existuje i ve variantì akceptující "int"
   // tudí¾ ji zavoláme (konkrétní metodu samozøejmì urèil pøekladaè, nejedná se
   // tedy o údaj zji¹»ovaný v&nbsp;èase bìhu)
   14:  invokevirtual   #6; //Method java/io/PrintStream.println:(I)V
   17:  return
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Operátor == pøi pou¾ívání autoboxingu a unboxingu</h2>

<p>I kdy¾ to pøímo nesouvisí s&nbsp;tématem dne¹ního èlánku, je mo¾ná vhodné se
zmínit o tom, ¾e <i>autoboxing</i> a <i>unboxing</i> provádìný pøekladaèem mù¾e
na první pohled vypadat jako zcela transparentní postup, který zcela stírá
rozdíl mezi primitivními datovými typy a jejich obalovými tøídami
(<strong>int&lt;-&gt;Integer</strong>, <strong>float&lt;-&gt;Float</strong>,
<strong>boolean&lt;-&gt;Boolean</strong>,
<strong>char&lt;-&gt;Character</strong> atd.). To je sice ve vìt¹inì pøípadù
skuteènì pravda, ale jednou z&nbsp;výjimek je chování operátoru
<strong>==</strong>, proto¾e v&nbsp;pøípadì, ¾e je tento operátor aplikován
pouze na instance obalových tøíd nìjakého primitivního datového typu (napøíklad
<i>Integer</i>), tak se <i>unboxing</i> <strong>neprovede</strong> a prostì se
porovnají reference obou objektù, co¾ (vìt¹inou) není chování, které
programátor vy¾aduje (v&nbsp;dal¹ích tøech pøípadech je konverze a následnì
porovnání provedeno korektnì). Uka¾me se pøíklad, který navíc odhalí i urèitou
&bdquo;zradu&ldquo; spoèívající v&nbsp;tom, ¾e se chybné pou¾ití operátoru
<strong>==</strong> nemusí projevit ve v¹ech pøípadech kvùli optimalizacím,
které se pøi pou¾ití obalových tøíd provádí:</p>

<pre>
public class Test {
&nbsp;
    // porovnání dvou instancí tøídy Integer: porovnání dvou referencí
    public static boolean equalInteger(Integer a, Integer b)
    {
        return a == b;
    }
&nbsp;
    // porovnání dvou hodnot primitivního datového typu int
    public static boolean equalInt(int a, int b)
    {
        return a == b;
    }
&nbsp;
    public static void main(String[] args) 
    {
        // problém se zatím "skryl"
        System.out.println(equalInteger(42, 42));
        System.out.println(equalInt(42, 42));
&nbsp;
        // ale zde se ji¾ projeví
        System.out.println(equalInteger(-1000, -1000));
        System.out.println(equalInt(-1000,-1000));
    }
&nbsp;
}
</pre>

<p>Tento pøíklad se po svém spu¹tìní mù¾e chovat pomìrnì nekonzistentnì (zále¾í
ov¹em na pou¾itém virtuálním stroji), proto¾e vìt¹inou vypí¹e následující
ètveøici hodnot:</p>

<pre>
true
true
false
true
</pre>

<p>Zajímavé pøitom je, ¾e jak metoda <strong>equalInteger()</strong>, tak i
metoda <strong>equalInt()</strong> má prakticky zcela stejný bajtkód, který se
li¹í jen rozdílem mezi instrukcemi <strong>if_acmpe</strong> a
<strong>if_icmpe</strong>:</p>

<pre>
public static boolean equalInteger(java.lang.Integer, java.lang.Integer);
  Code:
   0:   aload_0            // ulo¾it první argument na zásobník
   1:   aload_1            // ulo¾it druhý argument na zásobník
   2:   if_acmpne       9  // porovnání dvou *referencí*
   5:   iconst_1           // pøevod výsledku na boolean (0/1)
   6:   goto    10
   9:   iconst_0
   10:  ireturn            // na zásobníku je nyní výsledek 0/1, konec
</pre>

<pre>
public static boolean equalInt(int, int);
  Code:
   0:   iload_0            // ulo¾it první argument na zásobník
   1:   iload_1            // ulo¾it druhý argument na zásobník
   2:   if_icmpne       9  // porovnání dvou *celých èísel*
   5:   iconst_1           // pøevod výsledku na boolean (0/1)
   6:   goto    10
   9:   iconst_0
   10:  ireturn            // na zásobníku je nyní výsledek 0/1, konec
</pre>

<p>Zmínìná &bdquo;zrada&ldquo; spoèívá v&nbsp;tom, ¾e pro malá celá èísla se ve
skuteènosti nevytváøí metodou <strong>Integer.valueOf()</strong> nová instance
tøídy <i>Integer</i>, ale namísto toho se vrátí konstantní objekt (konkrétnì se
jedná o hodnoty le¾ící v&nbsp;rozsahu -128 a¾ 127, co¾ se ov¹em mù¾e
v&nbsp;dal¹ích JVM zmìnit, proto¾e to je implementaèní detail, který by nemìl
<i>korektnì napsané</i> aplikace ovlivnit). To tedy znamená, ¾e i porovnání
referencí dvou shodných konstantních objektù samozøejmì vrátí hodnotu
<strong>true</strong>, i kdy¾ pro pøíli¹ velká èi naopak malá èísla (-1000) se
vytvoøí nové objekty, jejich¾ reference jsou samozøejmì rùzné:</p>

<pre>
public static void main(java.lang.String[]);
  Code:
&nbsp;
&nbsp;
&nbsp;
   0:   getstatic       #2; //Field java/lang/System.out:Ljava/io/PrintStream;
   // zde nedojde k vytvoøení nového objektu
   3:   bipush  42
   5:   invokestatic    #3; //Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
&nbsp;
   // zde takté¾ nedojde k vytvoøení nového objektu
   8:   bipush  42
   10:  invokestatic    #3; //Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
&nbsp;
   // porovnají se dvì reference ukazující na stejný objekt
   13:  invokestatic    #4; //Method equalInteger:(Ljava/lang/Integer;Ljava/lang/Integer;)Z
&nbsp;
   16:  invokevirtual   #5; //Method java/io/PrintStream.println:(Z)V
&nbsp;
&nbsp;
&nbsp;
   19:  getstatic       #2; //Field java/lang/System.out:Ljava/io/PrintStream;
   22:  bipush  42
   24:  bipush  42
   // zde je to jednoduché - porovnání dvou primitivních hodnot
   26:  invokestatic    #6; //Method equalInt:(II)Z
&nbsp;
   29:  invokevirtual   #5; //Method java/io/PrintStream.println:(Z)V
&nbsp;
&nbsp;
&nbsp;
   32:  getstatic       #2; //Field java/lang/System.out:Ljava/io/PrintStream;
   // vytvoøení nové instance tøídy Integer
   35:  sipush  -1000
   38:  invokestatic    #3; //Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
   // vytvoøení nové instance tøídy Integer
   41:  sipush  -1000
   44:  invokestatic    #3; //Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
   // porovnají se dvì reference ukazující na rùzné objekty (instance tøídy Integer)
   47:  invokestatic    #4; //Method equalInteger:(Ljava/lang/Integer;Ljava/lang/Integer;)Z
&nbsp;
   50:  invokevirtual   #5; //Method java/io/PrintStream.println:(Z)V
&nbsp;
&nbsp;
&nbsp;
   53:  getstatic       #2; //Field java/lang/System.out:Ljava/io/PrintStream;
   56:  sipush  -1000
   59:  sipush  -1000
   // zde je to jednoduché - porovnání dvou primitivních hodnot
   62:  invokestatic    #6; //Method equalInt:(II)Z
   65:  invokevirtual   #5; //Method java/io/PrintStream.println:(Z)V
   68:  return
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Generické datové typy a bajtkód vytvoøený pøekladaèem</h2>

<p>Dal¹í &ndash; z&nbsp;hlediska programátorù pomìrnì zásadní zmìnou èi
pøesnìji øeèeno roz¹íøením Javy &ndash; bylo pøidání podpory pro generické
datové typy (<i>generik</i>). Jedná se skuteènì o dosti významnou zmìnu, která
umo¾òuje tvorbu typovì lépe zabezpeèeného kódu a v&nbsp;mnoha pøípadech je
navíc výsledný kód i mnohem èitelnìj¹í, nebo» není zapotøebí explicitnì psát
pøetypování pøi získávání prvkù z&nbsp;kolekcí apod. Tato zmìna si ji¾ vy¾ádala
urèité zmìny v&nbsp;bajtkódu, ale kupodivu se to netýká vlastního instrukèního
souboru (nebyly pøidány ¾ádné nové instrukce) a dokonce se programový kód
vyu¾ívající generické datové typy mnohdy (ov¹em ne v¾dycky) pøelo¾í
s&nbsp;vyu¾itím zcela stejných instrukcí jako kód, který generika nevyu¾ívá.
V&nbsp;tomto pøípadì jsou ve¹keré informace o generických datových typech
&bdquo;pouze&ldquo; zapsány formou metadat do bajtkódu. Uveïme si nyní pøíklad
dvou tøíd, jejich¾ metody se pøelo¾í do identické sekvence instrukcí, nezávisle
na tom, zda jsou vyu¾ity generické datové typy èi nikoli:</p>

<pre>
import java.util.*;
&nbsp;
class A {
&nbsp;
    // zde je deklarován "typovaný" seznam
    List&lt;String&gt; list = new ArrayList&lt;String&gt;();
    public void AA() {
        list.add("foo");
        list.add("bar");
    }
&nbsp;
}
&nbsp;
class B {
&nbsp;
    // zde je deklarován "beztypový" seznam
    List list = new ArrayList();
    public void BB() {
        list.add("foo");
        list.add("bar");
    }
&nbsp;
}
</pre>

<p>Sekvence instrukcí pro metodu <strong>A.AA()</strong> i
<strong>B.BB()</strong> bude v&nbsp;tomto pøípadì identická, stejnì jako
inicializaèní kód zavolaný pøi konstrukci nové instance obou tøíd:</p>

<pre>
A();
  Code:
   0:   aload_0
   1:   invokespecial   #1; //Method java/lang/Object."&lt;init&gt;":()V
   4:   aload_0
   5:   new             #2; //class java/util/ArrayList
   8:   dup
   9:   invokespecial   #3; //Method java/util/ArrayList."&lt;init&gt;":()V
   12:  putfield        #4; //Field list:Ljava/util/List;
   15:  return
&nbsp;
public void AA();
  Code:
   0:   aload_0
   1:   getfield        #4; //Field list:Ljava/util/List;
   4:   ldc             #5; //String foo
   // zde se volá metoda List.add(Object)
   6:   invokeinterface #6,  2; //InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z
   11:  pop
   12:  aload_0
   13:  getfield        #4; //Field list:Ljava/util/List;
   16:  ldc             #7; //String bar
   // zde se volá metoda List.add(Object)
   18:  invokeinterface #6,  2; //InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z
   23:  pop
   24:  return
}
</pre>

<pre>
B();
  Code:
   0:   aload_0
   1:   invokespecial   #1; //Method java/lang/Object."&lt;init&gt;":()V
   4:   aload_0
   5:   new             #2; //class java/util/ArrayList
   8:   dup
   9:   invokespecial   #3; //Method java/util/ArrayList."&lt;init&gt;":()V
   12:  putfield        #4; //Field list:Ljava/util/List;
   15:  return
&nbsp;
public void BB();
  Code:
   0:   aload_0
   1:   getfield        #4; //Field list:Ljava/util/List;
   4:   ldc             #5; //String foo
   // zde se volá metoda List.add(Object)
   6:   invokeinterface #6,  2; //InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z
   11:  pop
   12:  aload_0
   13:  getfield        #4; //Field list:Ljava/util/List;
   16:  ldc             #7; //String bar
   // zde se volá metoda List.add(Object)
   18:  invokeinterface #6,  2; //InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z
   23:  pop
   24:  return
}
</pre>

<p>Mohlo by se tedy zdát, ¾e pou¾ití generických datových typù je opìt jen
zále¾itostí pøekladaèe, který tak mù¾e provádìt lep¹í kontroly v&nbsp;èase
pøekladu. To je skuteènì do znaèné míry pravda, ov¹em v&nbsp;nìkterých
pøípadech pøekladaè navíc do sekvence instrukcí mù¾e vlo¾it napøíklad instrukci
<strong>checkcast</strong> pro kontrolu, jaký typ objektu se skuteènì
v&nbsp;danou chvíli pou¾ívá (bli¾¹í informace o instrukci
<strong>checkcast</strong> jsme si øekli <a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-12-cast-volani-metod-rozhrani-synchronizovane-bloky-a-kontrola-typu-za-behu/#k08">v&nbsp;osmé
kapitole pøedchozí èásti tohoto seriálu</a>). Tato kontrola je samozøejmì
provádìna a¾ v&nbsp;èase bìhu programu, tj.&nbsp;v&nbsp;<i>runtime</i>. Opìt se
podívejme na jednoduchý pøíklad:</p>

<pre>
&nbsp;
import java.util.*;
&nbsp;
class A {
    List&lt;String&gt; list = new ArrayList&lt;String&gt;();
    public void AA() {
        list.add("foo");
        System.out.println(list.get(1));
    }
}
&nbsp;
class B {
    List list = new ArrayList();
    public void BB() {
        list.add("foo");
        System.out.println(list.get(1));
    }
}
</pre>

<p>V&nbsp;metodì <strong>B.BB()</strong> nedochází k&nbsp;¾ádné kontrole typu
objektu získaného ze seznamu:</p>

<pre>
public void BB();
  Code:
   0:   aload_0
   1:   getfield        #4; //Field list:Ljava/util/List;
   4:   ldc             #5; //String foo
   6:   invokeinterface #6,  2; //InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z
   11:  pop
   12:  getstatic       #7; //Field java/lang/System.out:Ljava/io/PrintStream;
   15:  aload_0
   16:  getfield        #4; //Field list:Ljava/util/List;
   19:  iconst_1
   20:  invokeinterface #8,  2; //InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;
   25:  invokevirtual   #9; //Method java/io/PrintStream.println:(Ljava/lang/Object;)V
   28:  return
</pre>

<p>Ov¹em v&nbsp;metodì <strong>A.AA()</strong> ke kontrole ji¾ dochází, a to
právì s&nbsp;vyu¾itím instrukce <strong>checkcast</strong> (tato instrukce
zaèíná na bajtu 25):</p>

<pre>
public void AA();
  Code:
   0:   aload_0
   1:   getfield        #4; //Field list:Ljava/util/List;
   4:   ldc             #5; //String foo
   6:   invokeinterface #6,  2; //InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z
   11:  pop
   12:  getstatic       #7; //Field java/lang/System.out:Ljava/io/PrintStream;
   15:  aload_0
   16:  getfield        #4; //Field list:Ljava/util/List;
   19:  iconst_1
   20:  invokeinterface #8,  2; //InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;
   // **********************************************
   25:  checkcast       #9; //class java/lang/String
   // **********************************************
   28:  invokevirtual   #10; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
   31:  return
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Zpùsob pøekladu programové smyèky typu for-each</h2>

<p>V&nbsp;<i>J2SE 5.0</i> vydané ji¾ pøed osmi lety byl kromì autoboxingu,
unboxingu, výètových typù a generických datových typù do programovacího jazyka
Java zaveden i nový typ programové smyèky nazývaný <strong>for-each</strong>
podle podobnosti této smyèky s&nbsp;programovými smyèkami, které mù¾eme nalézt
napøíklad i v&nbsp;mnoha skriptovacích jazycích. Smyèka
<strong>for-each</strong> je velmi u¾iteèná, nebo» umo¾òuje jednodu¹e procházet
v¹emi prvky pole (jakéhokoli typu), popø.&nbsp;v¹emi prvky prakticky libovolné
kolekce. Ve skuteènosti jsou v¹ak mo¾nosti tohoto typu programové smyèky mnohem
vìt¹í, proto¾e ji lze aplikovat na ka¾dou tøídu implementující rozhraní
<strong>Iterator</strong>, pøedepisující pøedev¹ím metody
<strong>Iterator.hasNext()</strong> a <strong>Iterator.next()</strong>. Zpùsob,
jakým se programová smyèka <strong>for-each</strong> pøelo¾í, závisí pøedev¹ím
na tom, zda se prochází (iteruje) pøes pole èi zda se prochází prvky kolekce
(nebo té¾ prvky dostupné pøes ji¾ zmínìné rozhraní
<strong>Iterator</strong>).</p>

<p>Nejdøíve se podívejme na to, jakým zpùsobem se smyèka
<strong>for-each</strong> pøelo¾í v&nbsp;pøípadì, ¾e je naprogramován prùchod
polem celých èísel:</p>

<pre>
import java.util.*;
&nbsp;
public class ForEachTest1 {
&nbsp;
    public static int sum(int[] pole) {
        // suma v¹ech hodnot ulo¾ených v poli
        int sum = 0;
        // smyèka typu for-each
        // provádìná nad polem
        for (int x : pole) {
            sum += x;
        }
        return sum;
    }
&nbsp;
    public static void main(String[] args) {
        int[] pole = {3, 4, 5, 6, 7, 8, 9};
        System.out.println(sum(pole));
    }
&nbsp;
}
</pre>

<p>Pøekladaè vý¹e uvedený prùchod v¹emi prvky pole celých èísel musí pøelo¾it
podobným zpùsobem, jakoby se polem procházelo s&nbsp;vyu¾itím poèítané smyèky
<strong>for</strong>. Nejprve se tedy vytvoøí nìkolik pomocných promìnných
(ulo¾ených v&nbsp;zásobníkovém rámci metody), z&nbsp;nich¾ jedna obsahuje
hodnotu poèitadla a dal¹í mezní hodnotu tohoto poèitadla, tj.&nbsp;délku pole
získanou instrukcí <strong>arraylength</strong> (prvky pole jsou samozøejmì
indexovány od 0 do pole.length-1). V&nbsp;pøelo¾eném bajtkódu je jasnì patrné,
jakým zpùsobem se celá smyèka zkonstruovala. Smyèka zaèíná od instrukce le¾ící
na bajtu 10 a konèí instrukcí le¾ící na bajtu 30:</p>

<pre>
public static int sum(int[]);
  Code:
   // první pomocná lokální promìnná bude obsahovat sumu
   0:   iconst_0
   1:   istore_1
&nbsp;
   // druhá pomocná lokální promìnná bude obsahovat referenci na pole
   2:   aload_0
   3:   astore_2
&nbsp;
   // tøetí pomocná lokální promìnná bude obsahovat délku pole
   4:   aload_2
   5:   arraylength
   6:   istore_3
&nbsp;
   // ètvrtá pomocná lokální promìnná bude obsahovat poèitadlo smyèky
   7:   iconst_0
   8:   istore  4
&nbsp;
   // zaèátek programové smyèky
   10:  iload   4
   12:  iload_3
   // kdy¾ poèitadlo &ge; délka pole, ukonèi smyèku
   13:  if_icmpge       33
&nbsp;
   16:  aload_2
   17:  iload   4
   19:  iaload
   // naètený prvek pole do páté pomocné lokální promìnné
   20:  istore  5
   22:  iload_1
   23:  iload   5
   // souèet s prùbì¾nou sumou
   25:  iadd
   26:  istore_1
   // zvý¹ení poèitadla smyèky o jednièku
   27:  iinc    4, 1
   // dal¹í iterace
   30:  goto    10
&nbsp;
   // sumu ulo¾it na zásobník operandù
   33:  iload_1
   // proto¾e se jedná o návratovou hodnotu metody
   // zpøístupnìnou volajícímu kódu pomocí instrukce ireturn
   34:  ireturn
</pre>

<p>Zcela odli¹ným zpùsobem je programová smyèka typu <strong>for-each</strong>
pøelo¾ena pøi prùchodu kolekcemi, napøíklad seznamem (libovolnou kolekcí
implementující rozhraní <strong>List</strong>). Podívejme se opìt na zdrojový
pøíklad, v&nbsp;nìm¾ je prùchod seznamem zapsán formou této smyèky. Jako
pomìrnì u¾iteèná zajímavost je navíc v&nbsp;metodì nazvané
<strong>arrayAsList()</strong> ukázáno, jak lze pracovat s&nbsp;polem podobnì
jako s&nbsp;nemìnným seznamem, tj.&nbsp;se seznamem, který má pevný poèet prvkù
a hodnoty tìchto prvkù je mo¾né jen èíst (relativnì snadno lze v¹ak
s&nbsp;vyu¾itím pole implementovat i modifikovatelný seznam, viz té¾
dokumentace k&nbsp;abstraktní tøídì <strong>AbstractList</strong>):</p>

<pre>
import java.util.*;
&nbsp;
public class ForEachTest2 {
&nbsp;
    public static int sum(List&lt;Integer&gt; seznam) {
        int sum = 0;
        for (int x : seznam) {
            sum += x;
        }
        return sum;
    }
&nbsp;
    // pravdìpodobnì nejjednodu¹¹í mo¾nost, jak je mo¾né
    // pracovat s polem jako s nemìnným seznamem
    public static List&lt;Integer&gt; arrayAsList(final int[] pole) {
        return new AbstractList&lt;Integer&gt;() {
            public Integer get(int i) {
                return pole[i];
            }
            public int size() {
                return pole.length;
            }
        };
    }
&nbsp;
    public static void main(String[] args) {
        int[] pole = {3, 4, 5, 6, 7, 8, 9};
        System.out.println(sum(arrayAsList(pole)));
    }
&nbsp;
}
</pre>

<p>V&nbsp;tomto pøípadì musí pøekladaè pøelo¾it programovou smyèku
<strong>for-each</strong> podobnì, jako by pøelo¾il tento zdrojový kód:</p>

<pre>
while (Iterator.hasNext()) {
    int x = (Integer)Iterator.next();
    sum += x;
}
</pre>

<p>Z&nbsp;bajtkódu vypsaného pod tímto odstavcem je patrné, ¾e se nejprve pro
seznam získá instance tøídy implementující rozhraní <strong>Iterator</strong>
(sice to z&nbsp;názvu není patrné, ale skuteènì se jedná o rozhraní). Posléze
se na zaèátku ka¾dé iterace testuje návratová hodnota metody
<strong>Iterator.hasNext()</strong> a pokud se je¹tì nedo¹lo za poslední prvek,
je získána hodnota prvku s&nbsp;vyu¾itím metody
<strong>Iterator.next()</strong>. Pøekladaè samozøejmì provede test na typ
hodnoty získané z&nbsp;kolekce a následnì pøevede tuto hodnotu (typu
<strong>Integer</strong>) na primitivní hodnotu <strong>int</strong>:</p>

<pre>
public static int sum(java.util.List);
  Code:
   // první pomocná lokální promìnná bude obsahovat sumu
   0:   iconst_0
   1:   istore_1
&nbsp;
   // druhá pomocná lokální promìnná bude instanci tøídy
   // implementující rozhraní Iterator
   2:   aload_0
   3:   invokeinterface #2,  1; //InterfaceMethod java/util/List.iterator:()Ljava/util/Iterator;
   8:   astore_2
&nbsp;
   // zaèátek programové smyèky
   9:   aload_2
   // test, zda kolekce obsahuje dal¹í prvek
   10:  invokeinterface #3,  1; //InterfaceMethod java/util/Iterator.hasNext:()Z
   // pokud ne, programová smyèka se ukonèí
   15:  ifeq    38
   18:  aload_2
   // získání dal¹ího prvku s vyu¾itím metody Iterator.next()
   19:  invokeinterface #4,  1; //InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object;
   // a pøevod prvku na int s nezbytnou kontrolou
   24:  checkcast       #5; //class java/lang/Integer
   27:  invokevirtual   #6; //Method java/lang/Integer.intValue:()I
   // naètený prvek pole do tøetí pomocné lokální promìnné
   30:  istore_3
   31:  iload_1
   32:  iload_3
   // souèet s prùbì¾nou sumou
   33:  iadd
   34:  istore_1
   // dal¹í iterace
   35:  goto    9
&nbsp;
   // sumu ulo¾it na zásobník operandù
   38:  iload_1
   // proto¾e se jedná o návratovou hodnotu metody
   39:  ireturn
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Zpùsob pøekladu pøíkazu switch(String)</h2>

<p>Jedním z&nbsp;roz¹íøení syntaxe a sémantiky programovacího jazyka Java, na
nìj¾ museli programátoøi èekat a¾ do roku 2011, konkrétnì a¾ do oficiálního
vydání <i>Java SE 7</i>, je podpora øetìzcù v&nbsp;programové konstrukci typu
<strong>switch-case</strong>. Pøipomeòme si, ¾e tato konstrukce je sice
v&nbsp;Javì pou¾ívána u¾ od jejího vzniku, ov¹em a¾ do <i>J2SE 1.4</i> bylo
mo¾né v&nbsp;pøíkazu <strong>switch-case</strong> pou¾ít pouze celoèíselný
výraz za <strong>switch</strong> a celoèíselné konstanty v&nbsp;ka¾dé vìtvi
<strong>case</strong>. To je na vy¹¹í programovací jazyk pomìrnì málo (kdy¾
pomineme fakt, ¾e by se Java vlastnì bez této &bdquo;neobjektové&ldquo;
konstrukce docela dobøe obe¹la :-), proto se v&nbsp;<i>J2SE 1.5</i> roz¹íøily
mo¾nosti <strong>switch-case</strong> o pou¾ití výètového typu a v&nbsp;<i>Java
SE 7</i> i o mo¾nost zápisu výrazu vyhodnoceného na øetìzec ve
<strong>switch</strong> a øetìzcových literálù (&bdquo;øetìzcových
konstant&ldquo;) v&nbsp;ka¾dé vìtvi <strong>case</strong>. Podívejme se na
pøíklad, s&nbsp;ním¾ jsme se vlastnì ji¾ seznámili v&nbsp;první èásti tohoto
seriálu. Tento pøíklad vypí¹e poèet dnù pro ka¾dý mìsíc roku 2012:</p>

<pre>
public class StringSwitchTest {
&nbsp;
    public static final int YEAR = 2012;
&nbsp;
    public static int getDaysOfMonth(String month) {
        switch (month) {
            case "April":
            case "June":
            case "September":
            case "November":
                return 30;
            case "January":
            case "March":
            case "May":
            case "July":
            case "August":
            case "October":
            case "December":
                return 31;
            case "February":
                return 29;   // nebudeme si to teï zbyteènì komplikovat výpoètem :-)
            default:
                throw new RuntimeException("Unknown month name: " + month);
        }
    }
&nbsp;
    public static void main(String[] args) {
        String[] months = {"January", "February", "March",
                           "April",   "May",      "June",
                           "July",    "August",   "September",
                           "October", "November", "December"};
&nbsp;
        for (String month : months) {
            int days = getDaysOfMonth(month);
            System.out.format("%-10s\t%d\n", month, days);
        }
    }
}
</pre>

<p>Naivní pøekladaè by konstrukci <strong>switch-case</strong> pou¾itou
v&nbsp;pøedchozím demonstraèním pøíkladu mohl pøelo¾it jako sekvenci
<strong>if-else if-else if-...else</strong>, kde by se v&nbsp;ka¾dé podmínce
provádìlo testování dvou øetìzcù na rovnost s&nbsp;vyu¾itím metody
<strong>String.equals()</strong> (ve skuteènosti by se zrovna v&nbsp;tomto
pøípadì mohly porovnávat pøímo reference z&nbsp;<i>constant poolu</i>, ale
nebudeme si situaci zbyteènì komplikovat a ani pøekladaè tuto mo¾nost nikdy
nevyu¾ije, proto¾e neví, v&nbsp;jakém kontextu se metoda
<strong>getDaysOfMonth()</strong> mù¾e volat). Pøekladaè <i>JDK 7</i> v¹ak
&bdquo;øetìzcovou variantu&ldquo; programové konstrukce
<strong>switch-case</strong> pøelo¾í pomìrnì efektivním zpùsobem, jeho¾ výhody
se projeví zejména tehdy, pokud by se tato konstrukce vyu¾ila napøíklad
v&nbsp;programové smyèce, nebo by bylo vìtví <strong>case</strong> velké
mno¾ství: mohlo by se napøíklad jednat o nìjaký jednoduchý lexikální
analyzátor, já jsem napøíklad podobnou konstrukci pou¾il pøi naèítání souborù
typu <strong>DXF</strong> obsahujících velké mno¾ství klíèových slov.</p>

<p>Pøekladaè nejdøíve vypoète otisk (<i>hash</i>) øetìzce
<strong>month</strong> (otiskem je 32bitové celé èíslo). Tento otisk je pou¾it
v&nbsp;instrukci <i>lookupswitch</i> pøi porovnávání s&nbsp;otisky øetìzcových
literálù. Zde je dùle¾itý pøedev¹ím fakt, ¾e tyto otisky jsou vypoèteny ji¾
v&nbsp;dobì pøekladu (<i>compile time</i>), co¾ znamená, ¾e v&nbsp;dobì bìhu
(<i>runtime</i>) se jimi ji¾ virtuální stroj nemusí zdr¾ovat. Pokud je otisk
øetìzce <strong>month</strong> shodný s&nbsp;otiskem nìjakého literálu, je
proveden skok do vìtve, v&nbsp;ní¾ se zavolá metoda
<strong>String.equals()</strong>, proto¾e shoda otiskù øetìzcù samozøejmì
nemusí nutnì znamenat to, ¾e jsou øetìzce skuteènì identické (jinými slovy
&ndash; pøi he¹ování nutnì obèas dochází ke kolizím). Dùle¾ité je, ¾e se metoda
<strong>String.equals()</strong> zavolá maximálnì jedenkrát (pøesnìji øeèeno
v&nbsp;na¹em pøípadì maximálnì jedenkrát, proto¾e u námi pou¾itých øetìzcových
literálù nedo¹lo ke kolizi), co¾ je podstatné pro výkonnost programu, jeliko¾
volání metody <strong>String.equals()</strong> je obecnì mnohem pomalej¹í, ne¾
pouhé porovnání dvou 32bitových otiskù.</p>

<p>V&nbsp;ka¾dé vìtvi je na zásobník ulo¾ena celoèíselná konstanta, která je
následnì pou¾ita v&nbsp;instrukci <i>tableswitch</i> pro vrácení správné
hodnoty z&nbsp;celé funkce. Výsledný bajtkód je sice ponìkud del¹í, ov¹em je na
druhou stranu proveden mnohem rychleji, a to zejména v&nbsp;pøípadech, kdy, jak
ji¾ bylo øeèeno, poèet vìtví pøíkazu <strong>switch</strong> roste:</p>

<pre>
public static int getDaysOfMonth(java.lang.String);
  Code:
   0:   aload_0
   1:   astore_1
   // ulo¾it -1 do pomocné promìnné pou¾ité v tableswitch
   2:   iconst_m1
   3:   istore_2
&nbsp;
   // ulo¾it na zásobník referenci na øetìzec month
   4:   aload_1
   // výpoèet he¹ovacího kódu tohoto øetìzce
   5:   invokevirtual   #2; //Method java/lang/String.hashCode:()I
&nbsp;
   // provést rozeskok na základì vypoèteného he¹ovacího kódu
   8:   lookupswitch{ //12
                -199248958: 275;  // otisky øetìzcù jednotlivých mìsícù + cílová adresa skoku
                -162006966: 172;
                -25881423: 144;
                77125: 200;
                2320440: 215;
                2320482: 130;
                43165376: 245;
                63478374: 116;
                74113571: 186;
                626483269: 260;
                1703773522: 158;
                1972131363: 230;
                default: 287 }
&nbsp;
   // zaèátek vìtve case
   116: aload_1
   117: ldc     #3; //String April
   119: invokevirtual   #4; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   122: ifeq    287
   // hodnota pou¾itá instrukcí tableswitch pro druhý rozeskok
   125: iconst_0
   126: istore_2
   // pøeskok dal¹ích vìtví
   127: goto    287
&nbsp;
   // zaèátek vìtve case
   130: aload_1
   131: ldc     #5; //String June
   133: invokevirtual   #4; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   136: ifeq    287
   // hodnota pou¾itá instrukcí tableswitch pro druhý rozeskok
   139: iconst_1
   140: istore_2
   // pøeskok dal¹ích vìtví
   141: goto    287
&nbsp;
   // zaèátek vìtve case
   144: aload_1
   145: ldc     #6; //String September
   147: invokevirtual   #4; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   150: ifeq    287
   // hodnota pou¾itá instrukcí tableswitch pro druhý rozeskok
   153: iconst_2
   154: istore_2
   // pøeskok dal¹ích vìtví
   155: goto    287
&nbsp;
   // zaèátek vìtve case
   158: aload_1
   159: ldc     #7; //String November
   161: invokevirtual   #4; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   164: ifeq    287
   // hodnota pou¾itá instrukcí tableswitch pro druhý rozeskok
   167: iconst_3
   168: istore_2
   // pøeskok dal¹ích vìtví
   169: goto    287
&nbsp;
   // zaèátek vìtve case
   172: aload_1
   173: ldc     #8; //String January
   175: invokevirtual   #4; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   178: ifeq    287
   // hodnota pou¾itá instrukcí tableswitch pro druhý rozeskok
   181: iconst_4
   182: istore_2
   // pøeskok dal¹ích vìtví
   183: goto    287
&nbsp;
   // zaèátek vìtve case
   186: aload_1
   187: ldc     #9; //String March
   189: invokevirtual   #4; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   192: ifeq    287
   // hodnota pou¾itá instrukcí tableswitch pro druhý rozeskok
   195: iconst_5
   196: istore_2
   // pøeskok dal¹ích vìtví
   197: goto    287
&nbsp;
   // zaèátek vìtve case
   200: aload_1
   201: ldc     #10; //String May
   203: invokevirtual   #4; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   206: ifeq    287
   // hodnota pou¾itá instrukcí tableswitch pro druhý rozeskok
   209: bipush  6
   211: istore_2
   // pøeskok dal¹ích vìtví
   212: goto    287
&nbsp;
   // zaèátek vìtve case
   215: aload_1
   216: ldc     #11; //String July
   218: invokevirtual   #4; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   221: ifeq    287
   // hodnota pou¾itá instrukcí tableswitch pro druhý rozeskok
   224: bipush  7
   226: istore_2
   // pøeskok dal¹ích vìtví
   227: goto    287
&nbsp;
   // zaèátek vìtve case
   230: aload_1
   231: ldc     #12; //String August
   233: invokevirtual   #4; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   236: ifeq    287
   // hodnota pou¾itá instrukcí tableswitch pro druhý rozeskok
   239: bipush  8
   241: istore_2
   // pøeskok dal¹ích vìtví
   242: goto    287
&nbsp;
   // zaèátek vìtve case
   245: aload_1
   246: ldc     #13; //String October
   248: invokevirtual   #4; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   251: ifeq    287
   // hodnota pou¾itá instrukcí tableswitch pro druhý rozeskok
   254: bipush  9
   256: istore_2
   // pøeskok dal¹ích vìtví
   257: goto    287
&nbsp;
   // zaèátek vìtve case
   260: aload_1
   261: ldc     #14; //String December
   263: invokevirtual   #4; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   266: ifeq    287
   // hodnota pou¾itá instrukcí tableswitch pro druhý rozeskok
   269: bipush  10
   271: istore_2
   // pøeskok dal¹ích vìtví
   272: goto    287
&nbsp;
   // zaèátek vìtve case
   275: aload_1
   276: ldc     #15; //String February
   278: invokevirtual   #4; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   281: ifeq    287
   // hodnota pou¾itá instrukcí tableswitch pro druhý rozeskok
   284: bipush  11
   286: istore_2
&nbsp;
   // v pomocné promìnné na pozici 2 je nyní ulo¾eno èíslo -1 a¾ 11
   // na základì této hodnoty se provede druhý rozeskok do tøí vìtví
   287: iload_2
   288: tableswitch{ //0 to 11
                0: 352;      // zde ji¾ máme v¹ech 13 cílù skoku: 12 mìsícù + vìtev default
                1: 352;
                2: 352;
                3: 352;
                4: 355;
                5: 355;
                6: 355;
                7: 355;
                8: 355;
                9: 355;
                10: 355;
                11: 358;
                default: 361 }
&nbsp;
   // vìtev pro mìsíce s&nbsp;30 dny
   352: bipush  30
   354: ireturn
&nbsp;
   // vìtev pro mìsíce s&nbsp;31 dny
   355: bipush  31
   357: ireturn
&nbsp;
   // vìtev pro Únor
   358: bipush  29
   360: ireturn
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Slavná nová instrukce invokedynamic</h2>

<p>V¹echny instrukce virtuálního stroje Javy, které jsme si popsali
v&nbsp;pøedchozích èástech tohoto seriálu, byly skuteènì navr¾eny
s&nbsp;ohledem na mo¾nosti a potøeby tohoto programovacího jazyka. Ov¹em
spoleènì s&nbsp;neustálým roz¹iøováním JVM do rùzných odvìtví informatiky se
objevila snaha o to, aby se nad virtuálním strojem Javy mohly ve skuteènosti
spou¹tìt i programy napsané v&nbsp;jiných programovacích jazycích. Vzhledem
k&nbsp;neustále rostoucímu výpoèetnímu výkonu mikroprocesorù, zvìt¹ující se
kapacitì operaèních pamìtí a souèasnì i neklesající cenì za hodinu èasu práce
programátorù je vlastnì logické, ¾e se stále více prosazují dynamicky typované
programovací jazyky, napøíklad <i>JavaScript</i>, <i>Python</i>, <i>Ruby</i> èi
rùzné varianty <i>Lispu</i>. Tvùrci Javy na tento trend (relativnì pozdì, ale
pøece) zareagovali, a to zpoèátku vytvoøením specifikace <i>JSR 223: Scripting
for the Java Platform</i> a posléze i mnohem zásadnìj¹í specifikací <i>JSR 292:
Supporting Dynamically Typed Languages on the Java<sup>TM</sup>
Platform</i>.</p>

<p>První zmínìná specifikace souvisí pøedev¹ím se zpùsobem unifikované
kooperace mezi skripty napsanými v&nbsp;nìkterém podporovaném skriptovacím
jazyku na jedné stranì a programem napsaným v&nbsp;Javì na stranì druhé.
Teoreticky by tedy tato specifikace mohla dostaèovat v¹em tvùrcùm nových
implementací programovacích jazykù bì¾ících nad JVM. Ve skuteènosti se v¹ak pøi
snaze o pøeklad skriptù (naprogramovaných dejme tomu
v&nbsp;<strong>Jythonu</strong>) do bajtkódu JVM objevují nìkteré problémy
související pøedev¹ím s&nbsp;tím, ¾e bajtkód i instrukèní soubor JVM byl
navr¾en pro potøeby staticky typovaného programovacího jazyka, kde je napøíklad
v¾dy zøejmé, jaká metoda se má zavolat &ndash; jakého typu jsou její parametry
a jakého typu je její návratová hodnota (<i>pozdní vazba</i> se aplikuje pouze
na tøídu, její¾ metoda se má volat). V&nbsp;dynamicky typovaných programovacích
jazycích je v¹ak situace ponìkud slo¾itìj¹í (a pro programátory pou¾ívajícími
tento jazyk zase jednodu¹¹í), proto¾e typy jsou pøiøazované nikoli
k&nbsp;promìnným/atributùm/parametrùm, ale pøímo k&nbsp;hodnotám.</p>

<p>Z&nbsp;tohoto dùvodu není pøi pøekladu do bajtkódu JVM mo¾né pro volání
metod pou¾ít &bdquo;klasické&ldquo; instrukce
<strong>invokespecial/invokevirtual/invokeinterface</strong>, ale musela by se
nejdøíve vhodná metoda najít. Aby se tato práce pøevedla pøímo na JVM, byla do
bajtkódu pøidána dal¹í instrukce nazvaná <strong>invokedynamic</strong>. Význam
této instrukce i zpùsob jejího pou¾ití si popí¹eme v&nbsp;navazující èásti
seriálu.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/">http://java.sun.com/developer/technicalArticles/DynTypeLang/</a>
</li>

<li>JSR 223: Scripting for the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=223">http://jcp.org/en/jsr/detail?id=223</a>
</li>

<li>JSR 292: Supporting Dynamically Typed Languages on the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=292">http://jcp.org/en/jsr/detail?id=292</a>
</li>

<li>Java 7: A complete invokedynamic example<br />
<a href="http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html">http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html</a>
</li>

<li>InvokeDynamic: Actually Useful?<br />
<a href="http://blog.headius.com/2007/01/invokedynamic-actually-useful.html">http://blog.headius.com/2007/01/invokedynamic-actually-useful.html</a>
</li>

<li>A First Taste of InvokeDynamic<br />
<a href="http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html">http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html</a>
</li>

<li>Java 6 try/finally compilation without jsr/ret<br />
<a href="http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html">http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Root.cz: Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM<br />
<a href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/</a></a>
</li>

<li>Root.cz: JamVM aneb alternativa k HotSpotu nejenom pro embedded zaøízení a chytré telefony<br />
<a href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>FindBugs<br />
<a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a>
</li>

<li>GNU Classpath<br />
<a href="www.gnu.org/s/classpath/">www.gnu.org/s/classpath/</a></li>

<li>Java VMs Compared<br />
<a href="http://bugblogger.com/java-vms-compared-160/">http://bugblogger.com/java-vms-compared-160/</a>
</li>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>CloseableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html">http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

