<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - výkonnost aplikací vytvoøených s vyu¾itím SDLJava v porovnání s nativními aplikacemi</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - výkonnost aplikací vytvoøených s vyu¾itím SDLJava v porovnání s nativními aplikacemi</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o JVM i o programovacím jazyku Java dokonèíme popis multimediální knihovny SDLJava. Øekneme si o nìkterých základních pravidlech pro tvorbu efektivních aplikací a následnì porovnáme výkonnost dvou prakticky toto¾ných programù, z nich¾ jeden je napsán v kombinaci C+SDL a druhý v kombinaci Java+SDLJava.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - výkonnost aplikací vytvoøených s vyu¾itím SDLJava v porovnání s nativními aplikacemi</a></p>
<p><a href="#k02">2. Problematika vytváøení nových objektù pøi bìhu aplikace</a></p>
<p><a href="#k03">3. Pøímý pøístup do pamìti vs. pou¾ití tøídy ByteBuffer</a></p>
<p><a href="#k04">4. Porovnání dvou metod pøístupu do obrazové pamìti</a></p>
<p><a href="#k05">5. Demonstraèní pøíklad <strong>SDLTest69</strong> &ndash; vyu¾ití knihovny SDL pøi renderingu</a></p>
<p><a href="#k06">6. Demonstraèní pøíklad <strong>SDLTest70</strong> &ndash; vyu¾ití knihovny SDLJava pøi renderingu</a></p>
<p><a href="#k07">7. Porovnání èasu bìhu obou demonstraèních pøíkladù</a></p>
<p><a href="#k08">8. Repositáø se zdrojovými kódy obou dne¹ních demonstraèních pøíkladù</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - výkonnost aplikací vytvoøených s vyu¾itím SDLJava v porovnání s nativními aplikacemi</h2>

<p>V&nbsp;dne¹ní èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyce Java i o virtuálním stroji tohoto jazyka</a> dokonèíme
popis multimediální knihovny <i>SDLJava</i>. Nejprve se zmíníme o nìkterých
základních pravidlech, jejich¾ dodr¾ování povede k&nbsp;tvorbì efektivnì
naprogramovaných aplikací, které napøíklad nebudou trpìt ¹patnými odezvami èi
vysokými pamì»ovými nároky. Ve druhé èásti èlánku bude porovnána výkonnost dvou
programù provádìjících výpoèet a vykreslení animace <a
href="http://www.root.cz/clanky/fraktaly-v-pocitacove-grafice-xxx/">systémù
iterovaných funkcí</a> (IFS). První z&nbsp;tìchto programù je napsán
v&nbsp;programovacím jazyku C s&nbsp;vyu¾itím knihovny SDL, zatímco druhý
(funkènì toto¾ný) program je napsán v&nbsp;Javì a pøi svém bìhu vyu¾ívá
mo¾nosti knihovny SDLJava (co¾ je, jak ji¾ víme, jen pomìrnì úzká mezivrstva
mezi Javou a nativní knihovnou SDL).</p>

<img src="http://i.iinfo.cz/images/301/java129-1.png" class="image-170621" width="320" height="240" alt="&#160;" />
<p><i>Obrázek 1: IFS vykreslený demonstraèními pøíklady.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Problematika vytváøení nových objektù pøi bìhu aplikace</h2>

<p>Pøi tvorbì multimediálních aplikací (samozøejmì vèetnì poèítaèových her)
v&nbsp;programovacím jazyku Java vìt¹inou vývojáøi narazí na nìkolik problémù,
které èásteènì souvisí s&nbsp;vlastnostmi Javy, s&nbsp;architekturou JVM
popø.&nbsp;s&nbsp;návrhem základních knihoven. Tvorba multimediálních programù
s&nbsp;vyu¾itím AWT èi Swingu je sice mo¾ná, mnohdy se v¹ak nejedná o tu
nejefektivnìj¹í mo¾nost &ndash; právì z&nbsp;tohoto dùvodu vznikla knihovna
<i>SDLJava</i>, která dává Javovským programátorùm mo¾nost pomìrnì snadno a
elegantnì pøistupovat k&nbsp;funkcím a datovým strukturám knihovny <i>SDL</i> i
dal¹ích podpùrných knihoven (<i>SDL_Image</i> atd.). S&nbsp;vyu¾itím
<i>SDLJava</i> a souèasným obejitím AWT a Swingu lze skuteènì vytvoøit
napøíklad hru, její¾ odezvy i celkový výkon mohou být srovnatelné
s&nbsp;podobnì navr¾enou aplikací naprogramovanou v&nbsp;C èi C++ (èi jiném
jazyku kompilovaném pøímo do nativního strojového kódu), ov¹em je zapotøebí
dodr¾et nìkolik jednoduchých pravidel.</p>

<img src="http://i.iinfo.cz/images/301/java129-2.png" class="image-170622" width="320" height="240" alt="&#160;" />
<p><i>Obrázek 2: Dal¹í IFS vykreslený demonstraèními pøíklady.</i></p>

<p>Pøedev¹ím je nutné se vyvarovat toho, aby neustále docházelo k&nbsp;tvorbì
nových objektù v&nbsp;hlavní programové smyèce, která je vìt¹inou základem
&bdquo;herního enginu&ldquo;. Vìt¹inou se nelze tvorbì nových objektù zcela
vyhnout, ov¹em díky návrhu <i>SDLJava</i> je poèet novì vytváøených objektù
skuteènì minimalizován, zejména v&nbsp;porovnání s&nbsp;knihovnou AWT/Swing,
v&nbsp;ní¾ vznikají nové objekty i skrytì, tj.&nbsp;zavoláním nìkterých metod
ji¾ existujících instancí tøíd. Základ &bdquo;herního enginu&ldquo;, pøesnìji
øeèeno jeho grafické èásti, je vìt¹inou postaven na sadì bitmap
reprezentovaných objekty typu <strong>SDLSurface</strong>, pøi jejich¾
vykreslování do framebufferu se pou¾ívá datová struktura
<strong>SDLRect</strong>. Bitmapy typicky existují po celou dobu bìhu aplikace,
tak¾e zde k&nbsp;tvorbì nových objektù nedochází a v&nbsp;pøípadì datové
struktury <strong>SDLRect</strong> mù¾e být vhodné znovu pou¾ít ji¾ jednou
vytvoøený objekt tohoto typu, ne¾ napøíklad vytváøet <strong>SDLRect</strong>
na úrovni lokální promìnné èi dokonce uvnitø programové smyèky.</p>

<img src="http://i.iinfo.cz/images/301/java129-3.png" class="image-170623" width="320" height="240" alt="&#160;" />
<p><i>Obrázek 3: Tøetí IFS vykreslený demonstraèními pøíklady.</i></p>

<p>Vytváøení nových objektù je problematické z&nbsp;toho dùvodu, ¾e se po
zaplnìní té èásti haldy (heapu), která se jmenuje <i>eden space</i> spustí
správce pamìti (GC), jen¾ sice bì¾í v&nbsp;samostatném vláknu èi
v&nbsp;nìkolika samostatných vláknech, ale minimálnì v&nbsp;dobì skenování
obsazení haldy je nutné pozastavit i vlákna samotné aplikace, co¾ je
v&nbsp;pøípadì her èi dal¹ích multimediálních programù samozøejmì nepøíjemné.
Tento problém není mo¾né obejít ani prostým zvìt¹ením velikosti haldy, proto¾e
by ve skuteènosti mohl být výsledek je¹tì hor¹í, proto¾e by se zvìt¹il i poèet
objektù, které správce pamìti bude muset pøi své èinnosti pøesunout
z&nbsp;jednoho regionu na haldì do druhého regionu (a následnì upravit
reference na tyto objekty).</p>

<a href="http://www.root.cz/obrazek/170624/"><img src="http://i.iinfo.cz/images/301/java129-4-prev.png" class="image-170624" width="330" height="270" alt="&#160;" /></a>
<p><i>Obrázek 4: Jedním ze základních nástrojù pou¾itelných i pøi tvorbì her,
je JConsole dodávaná pøímo s&nbsp;JDK.</i></p>

<p>Sledovat práci správce pamìti lze snadno i s&nbsp;vyu¾itím volby pøedané JVM
pøi jejím startu:</p>

<pre>
java -verbose:gc Game
</pre>

<p>Výstup mù¾e vypadat následovnì:</p>

<pre>
0.109: [GC 896K-&gt;118K(5056K), 0.0026554 secs]
0.115: [GC 1014K-&gt;123K(5056K), 0.0010161 secs]
0.119: [GC 1016K-&gt;120K(5056K), 0.0004892 secs]
...                    ...
...                    ...
...                    ...
2.491: [GC 2208K-&gt;1540K(5056K), 0.0003350 secs]
2.493: [GC 2399K-&gt;1635K(5056K), 0.0002609 secs]
2.495: [GC 2495K-&gt;1826K(5056K), 0.0003830 secs]
2.497: [GC 2686K-&gt;1921K(5056K), 0.0002724 secs]
2.499: [GC 2782K-&gt;2112K(5056K), 0.0003674 secs]
2.501: [GC 2973K-&gt;2208K(5056K), 0.0002763 secs]
2.502: [GC 3069K-&gt;2398K(5056K), 0.0003746 secs]
2.504: [GC 3260K-&gt;2494K(5056K), 0.0002911 secs]
2.506: [Full GC 2687K-&gt;211K(5056K), 0.0163401 secs]
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Pøímý pøístup do pamìti vs. pou¾ití tøídy ByteBuffer</h2>

<p>S&nbsp;bitmapami, pøesnìji øeèeno s&nbsp;objekty typu
<strong>SDLSurface</strong>, lze provádìt nìkolik operací. Základní operací je
operace typu BitBLT, tj.&nbsp;pøesun celé bitmapy èi její èásti na bitmapu
jinou, popø.&nbsp;souèasná aplikace maskování èi aplikace alfa blendingu, to
v¹e v&nbsp;závislosti na nastavených re¾imech. Ov¹em v&nbsp;bitmapì je mnohdy
nutné modifikovat barvy jednotlivých pixelù. Pro tuto èinnost nabízí nativní
knihovna <i>SDL</i> mo¾nost takzvaného uzamèení bitmapy a získání ukazatele do
oblasti pamìti, kde jsou ulo¾eny pixely bitmapy. V&nbsp;pøípadì knihovny
<i>SDLJava</i> tato funkcionalita &ndash; celkem pochopitelnì &ndash; nemohla
být implementována, tak¾e se pøi uzamèení bitmapy vrátí nikoli ukazatel na
pamì» s&nbsp;pixely, ale objekt typu <strong>ByteBuffer</strong>, který nabízí
nìkolik metod pro modifikaci hodnot pixelù. Tato operace se svou efektivitou
mù¾e pøiblí¾it pøímé manipulaci s&nbsp;ukazateli, co¾ je u mnoha
multimediálních aplikací velmi dùle¾ité.</p>

<a href="http://www.root.cz/obrazek/170625/"><img src="http://i.iinfo.cz/images/301/java129-5-prev.png" class="image-170625" width="330" height="270" alt="&#160;" /></a>
<p><i>Obrázek 5: Jedním ze základních nástrojù pou¾itelných i pøi tvorbì her,
je JConsole dodávaná pøímo s&nbsp;JDK.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Porovnání dvou metod pøístupu do obrazové pamìti</h2>

<p>Podívejme se nyní na zpùsob pøístupu k&nbsp;jednotlivým pixelùm bitmapy.
Nejprve je vypsána èást aplikace vytvoøená v&nbsp;programovacím jazyku C, která
získá ukazatel na první pixel bitmapy a ulo¾í ho do promìnné
<strong>pixel</strong>. Následnì je ji¾ mo¾né v&nbsp;programové smyèce
jednodu¹e zapisovat nové barvy pixelù a zvy¹ovat hodnotu ukazatele,
tj.&nbsp;pøesunovat se na dal¹í pixel (zde se pøedpokládá formát RGB, tj.&nbsp;situace,
kdy je ka¾dý pixel reprezentován trojicí bajtù a obrazové øádky nejsou
zarovnány):</p>

<pre>
<i>/* primy pristup k pixelum */</i>
Uint8 *pixel = (Uint8 *)pixmap-&gt;pixels;
&nbsp;
<i>/* rozmery bitmapy */</i>
const int width = pixmap-&gt;w;
const int height = pixmap-&gt;h;
&nbsp;
<i>/* vlastni rendering */</i>
int x, y;
&nbsp;
for (y = 0; y &lt; height; y++)
{
    for (x = 0; x &lt; width; x++)
    {
        int color = compute_color(x, y);
        *pixel++ = color;
        *pixel++ = color;
        *pixel++ = color;
    }
}
</pre>

<p>V&nbsp;pøípadì pou¾ití programovacího jazyka Java a knihovny <i>SDLJava</i>
se namísto pøístupu k&nbsp;datové struktuøe bitmapy musí pou¾ít metoda
<strong>SDLSurface.getPixelData()</strong> vracející instanci tøídy
<strong>java.nio.ByteBuffer</strong>. Namísto pøímého pøístupu do
pamìti/bufferu pøes ukazatel se zde volá metoda <strong>put()</strong>
existující v&nbsp;nìkolika variantách. V&nbsp;následujícím úryvku kódu je
ukázána varianta, v&nbsp;ní¾ se v¾dy specifikuje index zapisovaného bajtu, co¾
z&nbsp;implementaèního hlediska pøipomíná práci s&nbsp;jednorozmìrným
polem:</p>

<pre>
<i>/* primy pristup k pixelum */</i>
java.nio.ByteBuffer pixels = pixmap.getPixelData();
&nbsp;
<i>/* rozmery bitmapy */</i>
final int width = pixmap.getWidth();
final int height = pixmap.getHeight();
&nbsp;
<i>/* vlastni rendering */</i>
int index = 0;
for (int y = 0; y &lt; height; y++)
{
    for (int x = 0; x &lt; width; x++)
    {
        int color = compute_color(x, y);
        <i>// barvy pixelu se mohou vyplnit pres metody nabizene tridou ByteBuffer</i>
        pixels.put(index++, (byte)color);
        pixels.put(index++, (byte)color);
        pixels.put(index++, (byte)color);
    }
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Demonstraèní pøíklad <strong>SDLTest69</strong> &ndash; vyu¾ití knihovny SDL pøi renderingu</h2>

<p>Pro porovnání zpùsobu práce s&nbsp;nativní knihovnou <i>SDL</i> a její
mezivrstvou <i>SDLJava</i> byla vytvoøena dvojice aplikací s&nbsp;prakticky
shodným chováním. Obì aplikace nejprve otevøou okno (popø.&nbsp;nastaví vhodný
celoobrazovkový grafický re¾im) a posléze do nìj vykreslí animaci vypoètenou
s&nbsp;vyu¾itím systémù iterovaných funkcí (IFS) a interpolací mezi
jednotlivými IFS. Pøi výpoètu se navíc provádí normalizace obrazu (samotný
obraz je vlastnì histogramem, kde úroveò èerné odpovídá poètu
&bdquo;zásahù&ldquo; ka¾dého pixelu body tvoøícími IFS). Aplikace je zalo¾ena
na nìkolika operacích &ndash; aplikacích transformaèní matice (operace nad
èísly ulo¾enými ve formátu <i>float</i>), ètení a zápis do dvourozmìrného pole
s&nbsp;prvky typu <i>int</i>, zápis barev pixelù do bitmapy a koneènì pøesun
bitmapy do framebufferu. V&nbsp;této kapitole je uvedena varianta aplikace
naprogramovaná v&nbsp;jazyku C s&nbsp;vyu¾itím knihovny <i>SDL</i>:</p>

<pre>
<i>/*</i>
<i> * Vyuziti knihovny SDL pri renderingu.</i>
<i> *</i>
<i> * Pavel Tisnovsky 2014</i>
<i> *</i>
<i> * Preklad;</i>
<i> * gcc -ansi -Wall -pedantic -O9 -ffast-math sdl_test.c -lSDLmain -lSDL</i>
<i> */</i>
&nbsp;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;SDL/SDL.h&gt;
&nbsp;
#define <strong>WINDOW_WIDTH</strong>  640
#define <strong>WINDOW_HEIGHT</strong> 480
#define <strong>IMAGE_WIDTH</strong>   320
#define <strong>IMAGE_HEIGHT</strong>  240
&nbsp;
<i>/*</i>
<i> * Ukazatel na data predstavujici framebuffer.</i>
<i> */</i>
SDL_Surface *screen;
&nbsp;
<i>/*</i>
<i> * Ukazatel na bitmapu, do ktere se provadi rendering.</i>
<i> */</i>
SDL_Surface *pixmap;
&nbsp;
<i>/*</i>
<i> * Pouzito pri renderingu - celkovy pocet "zasahu" jednotlivych pixelu.</i>
<i> */</i>
int histogram[IMAGE_HEIGHT][IMAGE_WIDTH];
&nbsp;
<i>/*</i>
<i> * Celkovy pocet pixelu pri vypoctu.</i>
<i> */</i>
const int <strong>IFS_PIXELS</strong> = IMAGE_WIDTH*IMAGE_HEIGHT;
&nbsp;
<i>/*</i>
<i> * Transformacni matice (+koeficient pravdepodobnosti) jednotlivych IFS.</i>
<i> */</i>
static float <strong>data</strong>[][7]={
    { 0.500000, 0.000000, 0.000000, 0.500000,-2.563477,-0.000003, 0.333333},
    { 0.500000, 0.000000, 0.000000, 0.500000, 2.436544,-0.000003, 0.333333},
    { 0.000000,-0.500000, 0.500000, 0.000000, 4.873085, 7.563492, 0.333333},
    { 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000},
    { 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000},
&nbsp;
    { 0.307692,-0.531469,-0.461538,-0.293706, 5.401953, 8.655175, 0.400000},
    { 0.307692,-0.076923, 0.153846,-0.447552,-1.295248, 4.152990, 0.150000},
    { 0.000000, 0.545455, 0.692308,-0.195804,-4.893637, 7.269794, 0.450000},
    { 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000},
    { 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000},
&nbsp;
    { 0.696970,-0.481061,-0.393939,-0.662879, 2.147003,10.310288, 0.747826},
    { 0.090909,-0.443182, 0.515152,-0.094697, 4.286558, 2.925762, 0.252174},
    { 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000},
    { 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000},
    { 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000},
&nbsp;
    { 0.824074, 0.281482,-0.212346, 0.864198,-1.882290,-0.110607, 0.787473},
    { 0.088272, 0.520988,-0.463889,-0.377778, 0.785360, 8.095795, 0.212527},
    { 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000},
    { 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000},
    { 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000},
&nbsp;
    { 0.824074, 0.281481,-0.212346, 0.864197,-1.772710, 0.137795, 0.771268},
    {-0.138580, 0.283951,-0.670062,-0.279012, 2.930991, 7.338924, 0.228732},
    { 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000},
    { 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000},
    { 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000},
&nbsp;
    { 0.870370, 0.074074,-0.115741, 0.851852,-1.278016, 0.070331, 0.798030},
    {-0.162037,-0.407407, 0.495370, 0.074074, 6.835726, 5.799174, 0.201970},
    { 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000},
    { 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000},
    { 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000},
&nbsp;
    { 0.850000, 0.040000,-0.040000, 0.850000, 0.000000, 1.600000, 0.850000},
    { 0.200000,-0.260000, 0.230000, 0.220000, 0.000000, 1.600000, 0.070000},
    {-0.150000, 0.280000, 0.260000, 0.240000, 0.000000, 0.440000, 0.070000},
    { 0.000000, 0.000000, 0.000000, 0.160000, 0.000000, 0.000000, 0.010000},
    { 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000},
&nbsp;
    { 0.307692, 0.000000, 0.000000, 0.294118, 4.119164, 1.604278, 0.151515},
    { 0.192308,-0.205882, 0.653846, 0.088235,-0.688840, 5.978916, 0.253788},
    { 0.192308, 0.205882,-0.653846, 0.088235, 0.668580, 5.962514, 0.253788},
    { 0.307692, 0.000000, 0.000000, 0.294118,-4.136530, 1.604278, 0.151515},
    { 0.384615, 0.000000, 0.000000,-0.294118,-0.007718, 2.941176, 1.000000},
&nbsp;
    { 0.787879,-0.424242, 0.242424, 0.859848, 1.758647, 1.408065, 0.895652},
    {-0.121212, 0.257576, 0.151515, 0.053030,-6.721654, 1.377236, 0.052174},
    { 0.181818,-0.136364, 0.090909, 0.181818, 6.086107, 1.568035, 0.052174},
    { 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000},
    { 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000},
&nbsp;
    { 0.000000, 0.000000, 0.000000, 0.500000, 0.000000, 0.000000, 0.050000},
    { 0.420000,-0.420000, 0.420000, 0.420000, 0.000000, 0.200000, 0.400000},
    { 0.420000, 0.420000,-0.420000, 0.420000, 0.000000, 0.200000, 0.400000},
    { 0.100000, 0.000000, 0.000000, 0.100000, 0.000000, 0.200000, 0.150000},
    { 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000},
&nbsp;
    { 0.500000, 0.000000, 0.000000, 0.500000,-0.500000, 0.000000, 0.333333},
    { 0.500000, 0.000000, 0.000000, 0.500000, 0.500000, 0.000000, 0.333333},
    { 0.500000, 0.000000, 0.000000, 0.500000, 0.000000, 0.860000, 0.333334},
    { 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000},
    { 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000},
};
&nbsp;
<i>/*</i>
<i> * Inicializace knihovny SDL.</i>
<i> */</i>
static void <strong>init_sdl</strong>(void)
{
    if (SDL_Init(SDL_INIT_VIDEO) &lt; 0)
    {
        fprintf(stderr, "Error initializing SDL: %s\n", SDL_GetError());
        exit(1);
    }
#ifdef FULLSCREEN
    screen = SDL_SetVideoMode(WINDOW_WIDTH, WINDOW_HEIGHT, 32, SDL_HWSURFACE | SDL_DOUBLEBUF | SDL_FULLSCREEN | SDL_ANYFORMAT);
#else
    screen = SDL_SetVideoMode(WINDOW_WIDTH, WINDOW_HEIGHT, 32, SDL_HWSURFACE | SDL_DOUBLEBUF | SDL_ANYFORMAT);
#endif
    if (!screen)
    {
        fprintf(stderr, "Error setting video mode: %s\n", SDL_GetError());
        exit(1);
    }
}
&nbsp;
<i>/*</i>
<i> * Ukonceni prace programu.</i>
<i> */</i>
void <strong>finalize</strong>(void)
{
    SDL_FreeSurface(pixmap);
    SDL_FreeSurface(screen);
    SDL_Quit();
}
&nbsp;
<i>/*</i>
<i> * Provedeni operace typu BitBlt (Bit Block Transfer)</i>
<i> */</i>
void <strong>gfx_bitblt</strong>(SDL_Surface *surface, const int x, const int y)
{
    SDL_Rect dst_rect;
    dst_rect.x = x;
    dst_rect.y = y;
    SDL_BlitSurface(surface, NULL, screen, &amp;dst_rect);
}
&nbsp;
<i>/*</i>
<i> * Prohozeni predniho a zadniho bufferu.</i>
<i> */</i>
void <strong>gfx_flip</strong>(void)
{
    SDL_Flip(screen);
}
&nbsp;
<i>/*</i>
<i> * Prepocet obrazku s IFS fraktalem.</i>
<i> */</i>
void <strong>recalcIFS</strong>(int max_iter, int start_iter, float morph_ratio, int first_ifs, int second_ifs)
{
    const float scale_factor=12.0;
    const float scale_factor_x = pixmap-&gt;w / scale_factor;
    const float scale_factor_y = pixmap-&gt;h / scale_factor;
    const float xmin=-6.0;
    const float ymin=-1.0;
&nbsp;
    <i>/* operace deleni je pomala, dokonce i pro float */</i>
    const float rand_max_inv = 1.0 / RAND_MAX;
&nbsp;
    float x1=0, y1=0, x2, y2;
    int   i, j, k;
    float maxp=0;
    int  *ip;
    Uint8 *pixel = (Uint8 *)pixmap-&gt;pixels;
&nbsp;
    float a[5][7];
&nbsp;
    <i>/* vypocet vsech peti transformacnich matic na zaklade hodnoty morph_ratio */</i>
    for (j=0; j&lt;5; j++)
    {
        for (i=0; i&lt;7; i++)
        {
            a[j][i]=(1.0-morph_ratio)*data[j+first_ifs*5][i]
                       +(morph_ratio)*data[j+second_ifs*5][i];
        }
    }
&nbsp;
    <i>/* vlastni vypocet IFS */</i>
    for (i=0; i&lt;max_iter; i++)
    {
        float pp = rand()*rand_max_inv;
        float sum=0;
        for (k=0; sum&lt;=pp; k++)
            sum+=a[k][6];
        k--;
        x2 = x1*a[k][0] + y1*a[k][1] + a[k][4];
        y2 = x1*a[k][2] + y1*a[k][3] + a[k][5];
        x1 = x2;
        y1 = y2;
        if (i &gt; start_iter)
        {
            int x = (int) ((x1 - xmin) * scale_factor_x);
            int y = (int) ((y1 - ymin) * scale_factor_y);
            if (x &gt;= 0 &amp;&amp; y &gt;=0 &amp;&amp; x &lt; pixmap-&gt;w &amp;&amp; y &lt; pixmap-&gt;h)
            {
                histogram[y][x]++;
            }
        }
    }
&nbsp;
    <i>/* vypocet maxp pro normalizaci obrazu */</i>
    ip = &amp;histogram[0][0];
    for (i=0; i&lt;IFS_PIXELS; i++)
    {
        if (maxp&lt;*ip) maxp=*ip;
        ip++;
    }
    <i>/* prepocet konstanty pro normalizaci */</i>
    maxp = 255.0 / log(maxp);
&nbsp;
    <i>/* vlastni rendering */</i>
    ip = &amp;histogram[0][0];
    for (i=0; i&lt;IFS_PIXELS; i++)
    {
        int color = 0xff &amp; (int)(log(*ip)*maxp);
        color = ~color;
        ip++;
        *pixel++ = color;
        *pixel++ = color;
        *pixel++ = color;
    }
}
&nbsp;
<i>/*</i>
<i> * Reagovat na zavreni okna aplikace i na klavesy Esc a Q.</i>
<i> */</i>
int <strong>should_we_quit</strong>(void)
{
    SDL_Event event;
&nbsp;
    SDL_PollEvent(&amp;event);
    switch (event.type)
    {
        case SDL_QUIT:
            return 1;
            break;
        case SDL_KEYDOWN:
            switch (event.key.keysym.sym)
            {
                case SDLK_ESCAPE:
                case SDLK_q:
                    return 1;
                    break;
                default:
                    break;
            }
    }
    return 0;
}
&nbsp;
<i>/*</i>
<i> * Vlastni animace.</i>
<i> */</i>
void <strong>animation</strong>(SDL_Surface *pixmap)
{
    int max_iter=50000;
    int start_iter=100;
    int frames=100;
    int i,j;
&nbsp;
    <i>/* prvky tohoto pole predstavuji prechody mezi jednotlivymi IFS. */</i>
    int ifs_indexes[]={0, 3, 6, 7, 8};
&nbsp;
    for (j=0; j&lt;5; j++) {
        for (i=0; i&lt;frames; i++) {
            int zac = ifs_indexes[j];
            int kon = ifs_indexes[(j+1) % 5];
            memset(histogram, 0, IFS_PIXELS * sizeof(float));
            SDL_LockSurface(pixmap);
            recalcIFS(max_iter, start_iter, (float)i/(frames-1.0), zac, kon);
            SDL_UnlockSurface(pixmap);
            gfx_bitblt(pixmap, (WINDOW_WIDTH-IMAGE_WIDTH)/2, (WINDOW_HEIGHT-IMAGE_HEIGHT)/2);
            SDL_Delay(10);
            gfx_flip();
&nbsp;
            <i>/* reagovat na zavreni okna aplikace i na klavesy Esc a Q */</i>
            if (should_we_quit())
            {
                return;
            }
        }
        SDL_Delay(100);
    }
}
&nbsp;
<i>/*</i>
<i> * Zaciname...</i>
<i> */</i>
int <strong>main</strong>(int argc, char **argv)
{
    <i>/* inicializace */</i>
    pixmap = SDL_CreateRGBSurface(SDL_SWSURFACE, IMAGE_WIDTH, IMAGE_HEIGHT, 24, 0x000000ff, 0x0000ff00, 0x00ff0000, 0x00000000);
    init_sdl();
&nbsp;
    <i>/* zobrazit animaci */</i>
    animation(pixmap);
&nbsp;
    <i>/* ukonceni prace s SDL */</i>
    finalize();
    return 0;
}
&nbsp;
<i>/* finito */</i>
</pre>

<p>O pøeklad se postará nástroj &bdquo;make&ldquo; s&nbsp;vyu¾itím
následujícího souboru <strong>Makefile</strong>:</p>

<pre>
CC=gcc
CFLAGS=-Wall -pedantic -ansi -O9 -ffast-math
LFLAGS=-lSDLmain -lSDL
&nbsp;
EXENAME=sdl_test
&nbsp;
all:    $(EXENAME)
&nbsp;
$(EXENAME):     sdl_test.o
        gcc -o $(EXENAME) $? $(LFLAGS)
&nbsp;
sdl_test,o:     sdl_test.c
        $(CC) $(CFLAGS) -c -o $@ $&lt;
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Demonstraèní pøíklad <strong>SDLTest70</strong> &ndash; vyu¾ití knihovny SDLJava pøi renderingu</h2>

<p>Dne¹ní druhý demonstraèní pøíklad poèítá a zobrazuje stejnou animaci <a
href="#k05">jako pøíklad pøedchozí</a>, je ov¹em naprogramovaný v&nbsp;Javì
s&nbsp;vyu¾itím knihovny <i>SDLJava</i>. Jména metod i celková koncepce tohoto
pøíkladu je odvozena od céèkové varianty aplikace, ov¹em nìkteré èásti (pøístup
k&nbsp;pixelùm bitmapy) samozøejmì musely být modifikovány:</p>

<pre>
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.SDLTimer;
&nbsp;
import sdljava.event.SDLEvent;
import sdljava.event.SDLKeyboardEvent;
import sdljava.event.SDLKey;
import sdljava.event.SDLQuitEvent;
&nbsp;
import sdljava.video.SDLSurface;
import sdljava.video.SDLRect;
import sdljava.video.SDLVideo;
&nbsp;
import sdljava.x.swig.SDLPressedState;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Sedmdesaty demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> *</i>
<i> * Vyuziti knihovny SDLJava pri renderingu.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>SDLTest70</strong> {
&nbsp;
    <i>/**</i>
    <i> * Horizontalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>WINDOW_WIDTH</strong> = 640;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>WINDOW_HEIGHT</strong> = 480;
&nbsp;
    <i>/**</i>
    <i> * Horizontalni rozliseni renderovaneho obrazku.</i>
    <i> */</i>
    private static final int <strong>IMAGE_WIDTH</strong> = 320;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni rozliseni renderovaneho obrazku.</i>
    <i> */</i>
    private static final int <strong>IMAGE_HEIGHT</strong> = 240;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka vybraneho grafickeho rezimu.</i>
    <i> * (0 znamena automaticky vyber, ovsem lze samozrejme pouzit</i>
    <i> * i hodnoty 8, 16, 24 ci 32, podle vlastnosti graficke karty)</i>
    <i> */</i>
    private static final int <strong>GFX_BPP</strong> = 32;
&nbsp;
    <i>/**</i>
    <i> * Reference na data predstavujici framebuffer.</i>
    <i> */</i>
    static SDLSurface <strong>screen</strong> = null;
&nbsp;
    <i>/**</i>
    <i> * Reference na bitmapu, do ktere se provadi rendering.</i>
    <i> */</i>
    static SDLSurface <strong>pixmap</strong> = null;
&nbsp;
    <i>/**</i>
    <i> * Pouzito pri renderingu - celkovy pocet "zasahu" jednotlivych pixelu.</i>
    <i> */</i>
    static int[][] <strong>histogram</strong> = new int[IMAGE_HEIGHT][IMAGE_WIDTH];
&nbsp;
    <i>/**</i>
    <i> * Transformacni matice (+koeficient pravdepodobnosti) jednotlivych IFS.</i>
    <i> */</i>
    static float <strong>data</strong>[][] = new float[][] {
        { 0.500000f,  0.000000f,  0.000000f,  0.500000f, -2.563477f, -0.000003f,  0.333333f},
        { 0.500000f,  0.000000f,  0.000000f,  0.500000f,  2.436544f, -0.000003f,  0.333333f},
        { 0.000000f, -0.500000f,  0.500000f,  0.000000f,  4.873085f,  7.563492f,  0.333333f},
        { 1.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  1.000000f},
        { 1.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  1.000000f},
&nbsp;
        { 0.307692f, -0.531469f, -0.461538f, -0.293706f,  5.401953f,  8.655175f,  0.400000f},
        { 0.307692f, -0.076923f,  0.153846f, -0.447552f, -1.295248f,  4.152990f,  0.150000f},
        { 0.000000f,  0.545455f,  0.692308f, -0.195804f, -4.893637f,  7.269794f,  0.450000f},
        { 1.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  1.000000f},
        { 1.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  1.000000f},
&nbsp;
        { 0.696970f, -0.481061f, -0.393939f, -0.662879f,  2.147003f, 10.310288f,  0.747826f},
        { 0.090909f, -0.443182f,  0.515152f, -0.094697f,  4.286558f,  2.925762f,  0.252174f},
        { 1.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  1.000000f},
        { 1.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  1.000000f},
        { 1.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  1.000000f},
&nbsp;
        { 0.824074f,  0.281482f, -0.212346f,  0.864198f, -1.882290f, -0.110607f,  0.787473f},
        { 0.088272f,  0.520988f, -0.463889f, -0.377778f,  0.785360f,  8.095795f,  0.212527f},
        { 1.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  1.000000f},
        { 1.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  1.000000f},
        { 1.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  1.000000f},
&nbsp;
        { 0.824074f,  0.281481f, -0.212346f,  0.864197f, -1.772710f,  0.137795f,  0.771268f},
        {-0.138580f,  0.283951f, -0.670062f, -0.279012f,  2.930991f,  7.338924f,  0.228732f},
        { 1.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  1.000000f},
        { 1.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  1.000000f},
        { 1.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  1.000000f},
&nbsp;
        { 0.870370f,  0.074074f, -0.115741f,  0.851852f, -1.278016f,  0.070331f,  0.798030f},
        {-0.162037f, -0.407407f,  0.495370f,  0.074074f,  6.835726f,  5.799174f,  0.201970f},
        { 1.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  1.000000f},
        { 1.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  1.000000f},
        { 1.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  1.000000f},
&nbsp;
        { 0.850000f,  0.040000f, -0.040000f,  0.850000f,  0.000000f,  1.600000f,  0.850000f},
        { 0.200000f, -0.260000f,  0.230000f,  0.220000f,  0.000000f,  1.600000f,  0.070000f},
        {-0.150000f,  0.280000f,  0.260000f,  0.240000f,  0.000000f,  0.440000f,  0.070000f},
        { 0.000000f,  0.000000f,  0.000000f,  0.160000f,  0.000000f,  0.000000f,  0.010000f},
        { 1.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  1.000000f},
&nbsp;
        { 0.307692f,  0.000000f,  0.000000f,  0.294118f,  4.119164f,  1.604278f,  0.151515f},
        { 0.192308f, -0.205882f,  0.653846f,  0.088235f, -0.688840f,  5.978916f,  0.253788f},
        { 0.192308f,  0.205882f, -0.653846f,  0.088235f,  0.668580f,  5.962514f,  0.253788f},
        { 0.307692f,  0.000000f,  0.000000f,  0.294118f, -4.136530f,  1.604278f,  0.151515f},
        { 0.384615f,  0.000000f,  0.000000f, -0.294118f, -0.007718f,  2.941176f,  1.000000f},
&nbsp;
        { 0.787879f, -0.424242f,  0.242424f,  0.859848f,  1.758647f,  1.408065f,  0.895652f},
        {-0.121212f,  0.257576f,  0.151515f,  0.053030f, -6.721654f,  1.377236f,  0.052174f},
        { 0.181818f, -0.136364f,  0.090909f,  0.181818f,  6.086107f,  1.568035f,  0.052174f},
        { 1.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  1.000000f},
        { 1.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  1.000000f},
&nbsp;
        { 0.000000f,  0.000000f,  0.000000f,  0.500000f,  0.000000f,  0.000000f,  0.050000f},
        { 0.420000f, -0.420000f,  0.420000f,  0.420000f,  0.000000f,  0.200000f,  0.400000f},
        { 0.420000f,  0.420000f, -0.420000f,  0.420000f,  0.000000f,  0.200000f,  0.400000f},
        { 0.100000f,  0.000000f,  0.000000f,  0.100000f,  0.000000f,  0.200000f,  0.150000f},
        { 1.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  1.000000f},
&nbsp;
        { 0.500000f,  0.000000f,  0.000000f,  0.500000f, -0.500000f,  0.000000f,  0.333333f},
        { 0.500000f,  0.000000f,  0.000000f,  0.500000f,  0.500000f,  0.000000f,  0.333333f},
        { 0.500000f,  0.000000f,  0.000000f,  0.500000f,  0.000000f,  0.860000f,  0.333334f},
        { 1.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  1.000000f},
        { 1.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  1.000000f},
    };
&nbsp;
    <i>/**</i>
    <i> * Inicializace grafickeho rezimu ci otevreni okna pro vykreslovani.</i>
    <i> */</i>
    private static void <strong>init_sdl</strong>()
            throws SDLException {
        final long flags = SDLVideo.SDL_DOUBLEBUF;
        screen = SDLVideo.setVideoMode(WINDOW_WIDTH, WINDOW_HEIGHT, GFX_BPP, flags);
    }
&nbsp;
    <i>/**</i>
    <i> * Ukonceni prace aplikace (predevsim uvolneni framebufferu i bitmapy pro renderovani fraktalu).</i>
    <i> */</i>
    private static void <strong>finalize_app</strong>()
            throws SDLException {
        pixmap.freeSurface();
        screen.freeSurface();
    }
&nbsp;
    <i>/**</i>
    <i> * Provedeni operace typu BitBlt (Bit Block Transfer)</i>
    <i> */</i>
    private static void <strong>gfx_bitblt</strong>(SDLSurface surface, final int x, final int y)
            throws SDLException {
        SDLRect dst_rect = new SDLRect(x, y);
        surface.blitSurface(screen, dst_rect);
    }
&nbsp;
    <i>/**</i>
    <i> * Prohozeni predniho a zadniho bufferu.</i>
    <i> */</i>
    private static void <strong>gfx_flip</strong>()
            throws SDLException {
        screen.flip();
    }
&nbsp;
    <i>/**</i>
    <i> * Prepocet obrazku s IFS fraktalem.</i>
    <i> */</i>
    private static void <strong>recalcIFS</strong>(int max_iter, int start_iter, float morph_ratio, int first_ifs, int second_ifs)
            throws SDLException
    {
        final float scale_factor=12.0f;
        final float scale_factor_x = pixmap.getWidth() / scale_factor;
        final float scale_factor_y = pixmap.getHeight() / scale_factor;
        final float xmin=-6.0f;
        final float ymin=-1.0f;
&nbsp;
        float x1=0, y1=0, x2, y2;
        int   i, j, k;
        float maxp=0;
&nbsp;
        <i>/* primy pristup k pixelum */</i>
        java.nio.ByteBuffer pixels = pixmap.getPixelData();
&nbsp;
        float[][] a = new float[5][7];
&nbsp;
        <i>/* vypocet vsech peti transformacnich matic na zaklade hodnoty morph_ratio */</i>
        for (j=0; j&lt;5; j++)
        {
            <i>/* projit prvky transformacni matice i koeficientem pravdepodobnosti,</i>
            <i> * ktery je ulozen za posledni prvek transformacni matice */</i>
            for (i=0; i&lt;7; i++)
            {
                a[j][i]=(1.0f-morph_ratio)*data[j+first_ifs*5][i]
                             +(morph_ratio)*data[j+second_ifs*5][i];
            }
        }
&nbsp;
        <i>/* vlastni vypocet IFS fraktalu */</i>
        for (i=0; i&lt;max_iter; i++)
        {
            float pp = (float)Math.random();
            float sum=0;
            for (k=0; sum&lt;=pp; k++)
                sum+=a[k][6];
            k--;
            x2 = x1*a[k][0] + y1*a[k][1] + a[k][4];
            y2 = x1*a[k][2] + y1*a[k][3] + a[k][5];
            x1 = x2;
            y1 = y2;
            if (i &gt; start_iter)
            {
                int x = (int) ((x1 - xmin) * scale_factor_x);
                int y = (int) ((y1 - ymin) * scale_factor_y);
                if (x &gt;= 0 &amp;&amp; y &gt;=0 &amp;&amp; x &lt; pixmap.getWidth() &amp;&amp; y &lt; pixmap.getHeight())
                {
                    histogram[y][x]++;
                }
            }
        }
&nbsp;
        <i>/* vypocet maxp pro normalizaci obrazu */</i>
        for (int[] row : histogram)
        {
            for (int ip : row)
            {
                if (maxp&lt;ip) maxp=ip;
            }
        }
        <i>/* prepocet konstanty pro normalizaci */</i>
        maxp = (float)(255.0 / Math.log(maxp));
&nbsp;
        <i>/* vlastni rendering */</i>
        int index = 0;
        for (int[] row : histogram)
        {
            for (int ip : row)
            {
                int color = 0xff &amp; (int)(Math.log(ip)*maxp);
                color = ~color;
                <i>// barvy pixelu se mohou vyplnit pres metody nabizene tridou ByteBuffer</i>
                pixels.put(index++, (byte)color);
                pixels.put(index++, (byte)color);
                pixels.put(index++, (byte)color);
            }
        }
    }
&nbsp;
    <i>/**</i>
    <i> * Reagovat na zavreni okna aplikace i na klavesy Esc a Q.</i>
    <i> */</i>
    static private boolean <strong>should_we_quit</strong>()
            throws SDLException {
        <i>// precist udalost z fronty</i>
        SDLEvent event = SDLEvent.pollEvent();;
&nbsp;
        <i>// vyskok ze smycky pro zpracovani udalosti pri vyskytu</i>
        <i>// udalosti typu SDLQuitEvent</i>
        if (event instanceof SDLQuitEvent) {
            return true;
        }
&nbsp;
        <i>// stisk ci pusteni klavesy</i>
        if (event instanceof SDLKeyboardEvent) {
            <i>// pretypovani</i>
            final SDLKeyboardEvent keyEvent = (SDLKeyboardEvent)event;
&nbsp;
            <i>// symbol/kod klavesy</i>
            final int symbol = keyEvent.getSym();
&nbsp;
            if (keyEvent.getState() == SDLPressedState.PRESSED) {
                switch (symbol) {
                    case SDLKey.SDLK_ESCAPE: <i>// klavesa ESC ukonci program</i>
                    case SDLKey.SDLK_q:      <i>// klavesa Q taktez ukonci program</i>
                        return true;
                    default:
                        break;
                }
            }
        }
        return false;
    }
&nbsp;
    <i>/**</i>
    <i> * Vlastni animace.</i>
    <i> */</i>
    public static void <strong>animation</strong>() throws InterruptedException, SDLException
    {
        int max_iter = 50000;
        int start_iter = 100;
        int frames = 100;
        int i, j;
&nbsp;
        <i>/* prvky tohoto pole predstavuje prechody mezi jednotlivymi IFS. */</i>
        int ifs_indexes[] = {0, 3, 6, 7, 8};
&nbsp;
        for (j = 0; j &lt; 5; j++) {
            for (i = 0; i &lt; frames; i++) {
                int zac = ifs_indexes[j];
                int kon = ifs_indexes[(j+1) % 5];
                for (int[] row: histogram) {
                    java.util.Arrays.fill(row, 0);
                }
                pixmap.lockSurface();
                recalcIFS(max_iter, start_iter, (float)i/(frames-1.0f), zac, kon);
                pixmap.unlockSurface();
                gfx_bitblt(pixmap, (WINDOW_WIDTH-IMAGE_WIDTH)/2, (WINDOW_HEIGHT-IMAGE_HEIGHT)/2);
                SDLTimer.delay(10);
                gfx_flip();
&nbsp;
                /* reagovat na zavreni okna aplikace i na klavesy Esc a Q */
                if (should_we_quit())
                {
                    return;
                }
            }
            SDLTimer.delay(100);
        }
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni sedmdesateho demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace knihovny SDLJava</i>
            SDLMain.init(SDLMain.SDL_INIT_VIDEO);
&nbsp;
            <i>// inicializace bitmapy pro rendering</i>
            pixmap = SDLVideo.createRGBSurface(SDLVideo.SDL_SWSURFACE, IMAGE_WIDTH, IMAGE_HEIGHT, 24, 0x000000ff, 0x0000ff00, 0x00ff0000, 0x00000000);
&nbsp;
            <i>// inicializace celoobrazovkoveho grafickeho rezimu ci otevreni okna pro vykreslovani</i>
            init_sdl();
&nbsp;
            <i>// zobrazit animaci</i>
            animation();
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            try {
                finalize_app();
            }
            catch (SDLException e) {
                e.printStackTrace();
            }
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
    }
&nbsp;
}
</pre>

<p>Skript pro pøeklad tohoto demonstraèního pøíkladu na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest70.java
</pre>

<p>Dávkový soubor pro pøeklad tohoto demonstraèního pøíkladu na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest70.java
</pre>

<p>Skript pro spu¹tìní na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
java -cp .:$SDL_JAVA_LIBS/sdljava.jar -Djava.library.path=$SDL_JAVA_LIBS SDLTest70
</pre>

<p>Dávkový soubor pro spu¹tìní na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest70
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Porovnání èasu bìhu obou demonstraèních pøíkladù</h2>

<p>Zajímavé bude urèitì porovnání èasu bìhu obou demonstraèních pøíkladù.
V&nbsp;první tabulce jsou ukázány výstupy z&nbsp;utility &bdquo;time&ldquo; na
obstaro¾ním poèítaèi s&nbsp;mikroprocesorem AMD Duron:</p>

<table>
<tr><th>?</th><th>Nativní C+SDL</th><th>JVM re¾im client</th><th>JVM re¾im server</th></tr>
<tr><td>real</td><td>0m24.571s</td><td>0m40.098s</td><td>0m57.457s</td></tr>
<tr><td>user</td><td>0m13.777s</td><td>0m27.990s</td><td>0m44.903s</td></tr>
<tr><td>sys </td><td>0m0.292s </td><td>0m0.532s </td><td>0m0.708s </td></tr>
</table>

<p>JVM (konkrétnì 1.6.0) v&nbsp;tomto pøípadì v&nbsp;porovnání s&nbsp;nativní
aplikací nedopadlo nijak dobøe, ale zkusme se podívat, jak testování dopadne na
stroji vybaveném pøeci jen novìj¹ím procesorem Intel Core2 Duo:</p>
    
<table>
<tr><th>?</th><th>Nativní C+SDL</th><th>JVM re¾im client</th><th>JVM re¾im server</th></tr>
<tr><td>real</td><td>0m18.201s</td><td>0m20.906s</td><td>0m20.836s</td></tr>
<tr><td>user</td><td>0m12.052s</td><td>0m14.804s</td><td>0m14.796s</td></tr>
<tr><td>sys </td><td>0m0.026s </td><td>0m0.112s </td><td>0m0.089s </td></tr>
</table>

<p>Zde ji¾ jsou èasy srovnatelné a navíc se v&nbsp;nich ji¾ ve vìt¹í míøe
projeví naprogramované pauzy mezi jednotlivými snímky.</p>

<p>Pro úplnost se podívejme na výstup profileru, z&nbsp;nìho¾ je patrné, kterou
èást kódu by bylo ideální optimalizovat:</p>

<pre>
3225600 java.nio.Buffer.checkIndex(I)I java.nio.DirectByteBuffer.put(IB)Ljava/nio/ByteBuffer; 9062
3225600 java.nio.DirectByteBuffer.ix(I)J java.nio.DirectByteBuffer.put(IB)Ljava/nio/ByteBuffer; 9580
3225600 java.nio.DirectByteBuffer.put(IB)Ljava/nio/ByteBuffer; SDLTest70.recalcIFS(IIFII)V 54959
1400000 java.util.concurrent.atomic.AtomicLong.get()J java.util.Random.next(I)I 3757
1400000 java.util.concurrent.atomic.AtomicLong.compareAndSet(JJ)Z java.util.Random.next(I)I 4272
1400000 java.util.Random.next(I)I java.util.Random.nextDouble()D 24052
700000 java.util.Random.nextDouble()D java.lang.Math.random()D 31061
700000 java.lang.Math.random()D SDLTest70.recalcIFS(IIFII)V 36660
698614 sdljava.x.swig.SDL_Surface.getW()I sdljava.video.SDLSurface.getWidth()I 2010
698614 sdljava.x.swig.SDL_Surface.getH()I sdljava.video.SDLSurface.getHeight()I 1594
698600 sdljava.video.SDLSurface.getWidth()I SDLTest70.recalcIFS(IIFII)V 7195
698600 sdljava.video.SDLSurface.getHeight()I SDLTest70.recalcIFS(IIFII)V 6816
</pre>

<p>Zajímavé a mo¾ná i typické je, ¾e se jedná pøesnì o tu èást kódu, která je
v&nbsp;C variantì naprogramována s&nbsp;vyu¾itím ukazatelù a (nekontrolovaného)
pøímého pøístupu do pamìti :-)</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Repositáø se zdrojovými kódy obou dne¹ních demonstraèních pøíkladù</h2>

<p>Oba dva dnes popsané demonstraèní pøíklady byly spoleènì s&nbsp;podpùrnými
skripty urèenými pro jejich pøeklad a následné spu¹tìní ulo¾eny do Mercurial
repositáøe dostupného na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
Podobnì jako tomu bylo i v&nbsp;pøedchozích nìkolika dílech tohoto seriálu, i
ke dne¹ní dvojici pøíkladù jsou pøilo¾eny skripty vyu¾itelné pro jejich pøeklad
a spu¹tìní:</p>

<table>
<tr><th> #</th><th>Zdrojový soubor/skript</th><th>Umístìní souboru v&nbsp;repositáøi</th></tr>
<tr><td> 1</td><td>sdl_test.c</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/422be660e74f/sdljava/SDLTest69/sdl_test.c">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/422be660e74f/sdljava/SDLTest69/sdl_test.c</a></td></tr>
<tr><td> 2</td><td>Makefile</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/422be660e74f/sdljava/SDLTest69/Makefile">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/422be660e74f/sdljava/SDLTest69/Makefile</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>SDLTest70.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/422be660e74f/sdljava/SDLTest70/SDLTest70.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/422be660e74f/sdljava/SDLTest70/SDLTest70.java</a></td></tr>
<tr><td> 4</td><td>SDLTest70_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/422be660e74f/sdljava/SDLTest70/SDLTest70_compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/422be660e74f/sdljava/SDLTest70/SDLTest70_compile.sh</a></td></tr>
<tr><td> 5</td><td>SDLTest70_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/422be660e74f/sdljava/SDLTest70/SDLTest70_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/422be660e74f/sdljava/SDLTest70/SDLTest70_compile_sys.sh</a></td></tr>
<tr><td> 6</td><td>SDLTest70_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/422be660e74f/sdljava/SDLTest70/SDLTest70_run.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/422be660e74f/sdljava/SDLTest70/SDLTest70_run.sh</a></td></tr>
<tr><td> 7</td><td>SDLTest70_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/422be660e74f/sdljava/SDLTest70/SDLTest70_run_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/422be660e74f/sdljava/SDLTest70/SDLTest70_run_sys.sh</a></td></tr>
<tr><td> 8</td><td>SDLTest70_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/422be660e74f/sdljava/SDLTest70/SDLTest70_compile.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/422be660e74f/sdljava/SDLTest70/SDLTest70_compile.bat</a></td></tr>
<tr><td> 9</td><td>SDLTest70_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/422be660e74f/sdljava/SDLTest70/SDLTest70_run.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/422be660e74f/sdljava/SDLTest70/SDLTest70_run.bat</a></td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Audio File Formats.<br />
<a href="http://sox.sourceforge.net/AudioFormats-11.html">http://sox.sourceforge.net/AudioFormats-11.html</a>
</li>

<li>TestSounds.com: pure digital sounds to test your audio<br />
<a href="http://www.testsounds.com/">http://www.testsounds.com/</a>
</li>

<li>Test Tones (20hz - 20khz)<br />
<a href="http://mdf1.tripod.com/test-tones.html">http://mdf1.tripod.com/test-tones.html</a>
</li>

<li>WAV (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/WAV">http://en.wikipedia.org/wiki/WAV</a>
</li>

<li>WAVE PCM soundfile format<br />
<a href="https://ccrma.stanford.edu/courses/422/projects/WaveFormat/">https://ccrma.stanford.edu/courses/422/projects/WaveFormat/</a>
</li>

<li>Audio Interchange File Format<br />
<a href="http://en.wikipedia.org/wiki/Aiff">http://en.wikipedia.org/wiki/Aiff</a>
</li>

<li>Musical Instrument Digital Interface,<br />
<a href="http://en.wikipedia.org/wiki/Musical_Instrument_Digital_Interface">http://en.wikipedia.org/wiki/Musical_Instrument_Digital_Interface</a>
</li>

<li>A MIDI Pedalboard Encode,<br />
<a href="http://www.pykett.org.uk/a_midi_pedalboard_encoder.htm">http://www.pykett.org.uk/a_midi_pedalboard_encoder.htm</a>
</li>

<li>MIDI Note Number, Frequency Table,<br />
<a href="http://tonalsoft.com/pub/news/pitch-bend.aspx">http://tonalsoft.com/pub/news/pitch-bend.aspx</a>
</li>

<li>Note names, MIDI numbers and frequencies,<br />
<a href="http://www.phys.unsw.edu.au/jw/notes.html">http://www.phys.unsw.edu.au/jw/notes.html</a>
</li>

<li>The MIDI Specification,<br />
<a href="http://www.gweep.net/~prefect/eng/reference/protocol/midispec.html">http://www.gweep.net/~prefect/eng/reference/protocol/midispec.html</a>
</li>

<li>Essentials of the MIDI protocol,<br />
<a href="http://ccrma.stanford.edu/~craig/articles/linuxmidi/misc/essenmidi.html">http://ccrma.stanford.edu/~craig/articles/linuxmidi/misc/essenmidi.html</a>
</li>

<li>General MIDI,<br />
<a href="http://en.wikipedia.org/wiki/General_MIDI">http://en.wikipedia.org/wiki/General_MIDI</a>
</li>

<li>Obecné MIDI (General MIDI), <br />
<a href="http://www-kiv.zcu.cz/~herout/html_sbo/midi/5.html">http://www-kiv.zcu.cz/~herout/html_sbo/midi/5.html</a>
</li>

<li>Custom Chips: Paula<br />
<a href="http://www.amiga-hardware.com/showhardware.cgi?HARDID=1460">http://www.amiga-hardware.com/showhardware.cgi?HARDID=1460</a>
</li>

<li>Big Book of Amiga Hardware<br />
<a href="http://www.amiga-resistance.info/bboahfaq/">http://www.amiga-resistance.info/bboahfaq/</a>
</li>

<li>Amiga Hardware Database<br />
<a href="http://amiga.resource.cx/">http://amiga.resource.cx/</a>
</li>

<li>ExoticA<br />
<a href="http://www.exotica.org.uk/wiki/Main_Page">http://www.exotica.org.uk/wiki/Main_Page</a>
</li>

<li>The absolute basics of Amiga audio<br />
<a href="http://www.sufo.estates.co.uk/amiga/amimus.html">http://www.sufo.estates.co.uk/amiga/amimus.html</a>
</li>

<li>Wikipedia: Tracker<br />
<a href="http://en.wikipedia.org/wiki/Tracker">http://en.wikipedia.org/wiki/Tracker</a>
</li>

<li>Wikipedia: Trackers<br />
<a href="http://en.wikipedia.org/wiki/Trackers">http://en.wikipedia.org/wiki/Trackers</a>
</li>

<li>Ultimate Soundtracker<br />
<a href="http://en.wikipedia.org/wiki/Ultimate_Soundtracker">http://en.wikipedia.org/wiki/Ultimate_Soundtracker</a>
</li>

<li>Protracker<br />
<a href="http://en.wikipedia.org/wiki/ProTracker">http://en.wikipedia.org/wiki/ProTracker</a>
</li>

<li>Impulse Tracker<br />
<a href="http://en.wikipedia.org/wiki/Impulse_Tracker">http://en.wikipedia.org/wiki/Impulse_Tracker</a>
</li>

<li>Scream Tracker<br />
<a href="http://en.wikipedia.org/wiki/ScreamTracker">http://en.wikipedia.org/wiki/ScreamTracker</a>
</li>

<li>MikMod for Java<br />
<a href="http://jmikmod.berlios.de/">http://jmikmod.berlios.de/</a>
</li>

<li>List of audio trackers<br />
<a href="http://en.wikipedia.org/wiki/List_of_audio_trackers">http://en.wikipedia.org/wiki/List_of_audio_trackers</a>
</li>

<li>Wikipedia: Module File<br />
<a href="http://en.wikipedia.org/wiki/Module_file">http://en.wikipedia.org/wiki/Module_file</a>
</li>

<li>Wikipedia: Chiptune<br />
<a href="http://en.wikipedia.org/wiki/Chiptune">http://en.wikipedia.org/wiki/Chiptune</a>
</li>

<li>SDL_mixer 2.0<br />
<a href="http://www.libsdl.org/projects/SDL_mixer/">http://www.libsdl.org/projects/SDL_mixer/</a>
</li>

<li>SDLJava: package sdljava.ttf<br />
<a href="http://sdljava.sourceforge.net/docs/api/sdljava/ttf/package-summary.html#package_description">http://sdljava.sourceforge.net/docs/api/sdljava/ttf/package-summary.html#package_description</a>
</li>

<li>SDLJava: class sdljava.ttf.SDLTTF<br />
<a href="http://sdljava.sourceforge.net/docs/api/sdljava/ttf/SDLTTF.html">http://sdljava.sourceforge.net/docs/api/sdljava/ttf/SDLTTF.html</a>
</li>

<li>SDLJava: class sdljava.ttf.SDLTrueTypeFont<br />
<a href="http://sdljava.sourceforge.net/docs/api/sdljava/ttf/SDLTrueTypeFont.html">http://sdljava.sourceforge.net/docs/api/sdljava/ttf/SDLTrueTypeFont.html</a>
</li>

<li>SDL_ttf Documentation<br />
<a href="http://www.libsdl.org/projects/SDL_ttf/docs/">http://www.libsdl.org/projects/SDL_ttf/docs/</a>
</li>

<li>SDL_ttf 2.0 (není prozatím souèástí SDLJava)<br />
<a href="http://www.libsdl.org/projects/SDL_ttf/">http://www.libsdl.org/projects/SDL_ttf/</a>
</li>

<li>SDL_ttf doc<br />
<a href="http://www.libsdl.org/projects/SDL_ttf/docs/SDL_ttf_frame.html">http://www.libsdl.org/projects/SDL_ttf/docs/SDL_ttf_frame.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_Surface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_PixelFormat<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlpixelformat.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlpixelformat.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_LockSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdllocksurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdllocksurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_UnlockSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlunlocksurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlunlocksurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_LoadBMP<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlloadbmp.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlloadbmp.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_SaveBMP<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsavebmp.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsavebmp.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_BlitSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlblitsurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlblitsurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_VideoInfo<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlvideoinfo.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlvideoinfo.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_GetVideoInfo<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlgetvideoinfo.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlgetvideoinfo.html</a>
</li>

<li>glDrawArrays<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArrays.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArrays.xml</a>
</li>

<li>glDrawElements<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElements.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElements.xml</a>
</li>

<li>glDrawArraysInstanced<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArraysInstanced.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArraysInstanced.xml</a>
</li>

<li>glDrawElementsInstanced<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElementsInstanced.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElementsInstanced.xml</a>
</li>

<li>Root.cz: Seriál Grafická knihovna OpenGL<br />
<a href="http://www.root.cz/serialy/graficka-knihovna-opengl/">http://www.root.cz/serialy/graficka-knihovna-opengl/</a>
</li>

<li>Root.cz: Seriál Tvorba pøenositelných grafických aplikací vyu¾ívajících knihovnu GLUT<br />
<a href="http://www.root.cz/serialy/tvorba-prenositelnych-grafickych-aplikaci-vyuzivajicich-knihovnu-glut/">http://www.root.cz/serialy/tvorba-prenositelnych-grafickych-aplikaci-vyuzivajicich-knihovnu-glut/</a>
</li>

<li>Best Practices for Working with Vertex Data<br />
<a href="https://developer.apple.com/library/ios/documentation/3ddrawing/conceptual/opengles_programmingguide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html">https://developer.apple.com/library/ios/documentation/3ddrawing/conceptual/opengles_programmingguide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html</a>
</li>

<li>Class BufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferStrategy.html</a>
</li>

<li>Class Graphics<br />
<a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/Graphics.html">http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/Graphics.html</a>
</li>

<li>Double Buffering and Page Flipping<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html</a>
</li>

<li>BufferStrategy and BufferCapabilities<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/bufferstrategy.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/bufferstrategy.html</a>
</li>

<li>Java:Tutorials:Double Buffering<br />
<a href="http://content.gpwiki.org/index.php/Java:Tutorials:Double_Buffering">http://content.gpwiki.org/index.php/Java:Tutorials:Double_Buffering</a>
</li>

<li>Double buffer in standard Java AWT<br />
<a href="http://www.codeproject.com/Articles/2136/Double-buffer-in-standard-Java-AWT">http://www.codeproject.com/Articles/2136/Double-buffer-in-standard-Java-AWT</a>
</li>

<li>Java 2D: Hardware Accelerating - Part 1 - Volatile Images<br />
<a href="http://www.javalobby.org/forums/thread.jspa?threadID=16840&tstart=0">http://www.javalobby.org/forums/thread.jspa?threadID=16840&tstart=0</a>
</li>

<li>Java 2D: Hardware Accelerating - Part 2 - Buffer Strategies<br />
<a href="http://www.javalobby.org/java/forums/t16867.html">http://www.javalobby.org/java/forums/t16867.html</a>
</li>

<li>How does paintComponent work?<br />
<a href="http://stackoverflow.com/questions/15544549/how-does-paintcomponent-work">http://stackoverflow.com/questions/15544549/how-does-paintcomponent-work</a>
</li>

<li>A Swing Architecture Overview<br />
<a href="http://www.oracle.com/technetwork/java/architecture-142923.html">http://www.oracle.com/technetwork/java/architecture-142923.html</a>
</li>

<li>Class javax.swing.JComponent<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html</a>
</li>

<li>Class java.awt.Component<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html</a>
</li>

<li>Class java.awt.Component.BltBufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.BltBufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.BltBufferStrategy.html</a>
</li>

<li>Class java.awt.Component.FlipBufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.FlipBufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.FlipBufferStrategy.html</a>
</li>

<li>Metoda java.awt.Component.isDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html#isDoubleBuffered()">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html#isDoubleBuffered()</a>
</li>

<li>Metoda javax.swing.JComponent.isDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#isDoubleBuffered()">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#isDoubleBuffered()</a>
</li>

<li>Metoda javax.swing.JComponent.setDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#setDoubleBuffered(boolean)">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#setDoubleBuffered(boolean)</a>
</li>

<li>Javadoc - tøída GraphicsDevice<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html</a>
</li>

<li>Javadoc - tøída GraphicsEnvironment<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html</a>
</li>

<li>Javadoc - tøída GraphicsConfiguration<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html</a>
</li>

<li>Javadoc - tøída DisplayMode<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html">http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html</a>
</li>

<li>Lesson: Full-Screen Exclusive Mode API<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/">http://docs.oracle.com/javase/tutorial/extra/fullscreen/</a>
</li>

<li>Full-Screen Exclusive Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html</a>
</li>

<li>Display Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html</a>
</li>

<li>Using the Full-Screen Exclusive Mode API in Java<br />
<a href="http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm">http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>GC safe-point (or safepoint) and safe-region<br />
<a href="http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html">http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html</a>
</li>

<li>Safepoints in HotSpot JVM<br />
<a href="http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html">http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html</a>
</li>

<li>Java theory and practice: Synchronization optimizations in Mustang<br />
<a href="http://www.ibm.com/developerworks/java/library/j-jtp10185/">http://www.ibm.com/developerworks/java/library/j-jtp10185/</a>
</li>

<li>How to build hsdis<br />
<a href="http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README">http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README</a>
</li>

<li>Java SE 6 Performance White Paper<br />
<a href="http://www.oracle.com/technetwork/java/6-performance-137236.html">http://www.oracle.com/technetwork/java/6-performance-137236.html</a>
</li>

<li>Lukas Stadler's Blog<br />
<a href="http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html">http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html</a>
</li>

<li>How to build hsdis-amd64.dll and hsdis-i386.dll on Windows<br />
<a href="http://dropzone.nfshost.com/hsdis.htm">http://dropzone.nfshost.com/hsdis.htm</a>
</li>

<li>PrintAssembly<br />
<a href="https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly">https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly</a>
</li>

<li>The Java Virtual Machine Specification: 3.14. Synchronization<br />
<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14</a>
</li>

<li>The Java Virtual Machine Specification: 8.3.1.4. volatile Fields<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.4. Memory Model<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.7. Non-atomic Treatment of double and long<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7</a>
</li>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (pøed verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2014</small></p>
</body>
</html>

