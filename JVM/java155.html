<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (7 - dokonèení popisu mezijazyka LuaJITu)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (7 - dokonèení popisu mezijazyka LuaJITu)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V sedmé èásti èlánku o Just in Time pøekladaèi LuaJIT dokonèíme popis mezijazyka, který v LuaJITu plní funkci bajtkódu. Minule jsme se zmínili o zpùsobu pøekladu programových smyèek typu while, repeat-until i poèítané smyèky for, dnes na toto téma navá¾eme a popí¹eme si zpùsob pøekladu smyèky for-each a následnì pak práci s uzávìry (closures).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (7 - dokonèení popisu mezijazyka LuaJITu)</a></p>
<p><a href="#k02">2. ©ablony (templates) pou¾ité pøi pøekladu programových smyèek <strong>while</strong>, <strong>repeat-until</strong> a poèítané smyèky <strong>for</strong></a></p>
<p><a href="#k021">&nbsp;&nbsp;&nbsp;2.1 ©ablona pro programovou smyèku typu <strong>while</strong></a></p>
<p><a href="#k022">&nbsp;&nbsp;&nbsp;2.2 ©ablona pro programovou smyèku typu <strong>repeat-until</strong></a></p>
<p><a href="#k023">&nbsp;&nbsp;&nbsp;2.3 ©ablona pro poèítanou programovou smyèku typu <strong>for</strong></a></p>
<p><a href="#k03">3. ©ablony pou¾ité pøi pøekladu programové smyèky typu <strong>for-each</strong></a></p>
<p><a href="#k031">&nbsp;&nbsp;&nbsp;3.1 ©ablona pro programovou smyèku typu <strong>for-each</strong> pøi prùchodu polem</a></p>
<p><a href="#k032">&nbsp;&nbsp;&nbsp;3.2 ©ablona pro programovou smyèku typu <strong>for-each</strong> pøi prùchodu asociativním polem</a></p>
<p><a href="#k04">4. Programová smyèka typu <strong>for-each</strong> pøi prùchodu polem</a></p>
<p><a href="#k041">&nbsp;&nbsp;&nbsp;4.1 Zdrojový kód pøíkladu <strong>test35.lua</strong></a></p>
<p><a href="#k042">&nbsp;&nbsp;&nbsp;4.2 Pøeklad pøíkladu <strong>test35.lua</strong> do mezijazyka LuaJITu</a></p>
<p><a href="#k05">5. Programová smyèka typu <strong>for-each</strong> pøi prùchodu asociativním polem</a></p>
<p><a href="#k051">&nbsp;&nbsp;&nbsp;5.1 Zdrojový kód pøíkladu <strong>test36.lua</strong></a></p>
<p><a href="#k052">&nbsp;&nbsp;&nbsp;5.2 Pøeklad pøíkladu <strong>test36.lua</strong> do mezijazyka LuaJITu</a></p>
<p><a href="#k06">6. Vytvoøení a následné pou¾ití (zavolání) uzávìru (closure)</a></p>
<p><a href="#k061">&nbsp;&nbsp;&nbsp;6.1 Zdrojový kód pøíkladu <strong>test37.lua</strong></a></p>
<p><a href="#k062">&nbsp;&nbsp;&nbsp;6.2 Pøeklad pøíkladu <strong>test37.lua</strong> do mezijazyka LuaJITu</a></p>
<p><a href="#k07">7. Externí lokální promìnné vìt¹ího mno¾ství uzávìrù</a></p>
<p><a href="#k071">&nbsp;&nbsp;&nbsp;7.1 Zdrojový kód pøíkladu <strong>test38.lua</strong></a></p>
<p><a href="#k072">&nbsp;&nbsp;&nbsp;7.2 Pøeklad pøíkladu <strong>test38.lua</strong> do mezijazyka LuaJITu</a></p>
<p><a href="#k08">8. Pøedání parametrù volanému uzávìru</a></p>
<p><a href="#k081">&nbsp;&nbsp;&nbsp;8.1 Zdrojový kód pøíkladu <strong>test39.lua</strong></a></p>
<p><a href="#k082">&nbsp;&nbsp;&nbsp;8.2 Pøeklad pøíkladu <strong>test39.lua</strong> do mezijazyka LuaJITu</a></p>
<p><a href="#k09">9. Zdrojové kódy v¹ech pìti dne¹ních demonstraèních pøíkladù</a></p>
<p><a href="#k10">10. Obsah dal¹ích èástí tohoto seriálu</a></p>
<p><a href="#k11">11. Seznam v¹ech popsaných instrukcí mezijazyka LuaJITu</a></p>
<p><a href="#k111">&nbsp;&nbsp;&nbsp;11.1 První formát instrukcí</a></p>
<p><a href="#k112">&nbsp;&nbsp;&nbsp;11.2 Druhý formát instrukcí</a></p>
<p><a href="#k113">&nbsp;&nbsp;&nbsp;11.3 Seznam instrukcí</a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (7 - dokonèení popisu mezijazyka LuaJITu)</h2>

<p><a
href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-6-preklad-programovych-smycek-do-mezijazyka-luajitu/">V&nbsp;¹esté
èásti</a> èlánku o vlastnostech LuaJITu jsme se pøevá¾nì zabývali zpùsobem
pøekladu rùzných typù programových smyèek do mezijazyka (IR) vyu¾ívaného
LuaJITem. Pøipomeòme si, ¾e se jednalo o programové smyèky typu
<strong>while</strong> (test na ukonèení smyèky je provádìn pøed ka¾dou
iterací), <strong>repeat-until</strong> (test na ukonèení smyèky je provádìn po
ka¾dé iteraci) a takté¾ o poèítanou programovou smyèku typu
<strong>for</strong>. LuaJIT pøekládá v¹echny tyto smyèky podle jednotné
¹ablony zopakované <a href="#k02">ve druhé kapitole</a>. Na ukázce ¹ablon
uvedených v&nbsp;navazující kapitole si pov¹imnìte pøedev¹ím pou¾ití speciální
instrukce nazvané <strong>LOOP</strong>, která pouze oznaèuje rozsah instrukcí,
které smyèku tvoøí &ndash; tato informace je následnì pou¾ita just-in-time
pøekladaèem k&nbsp;detekci, která èást aplikace se má v&nbsp;èase jejího bìhu
pøelo¾it do nativního kódu. V&nbsp;pøípadì poèítané smyèky <strong>for</strong>
není zapotøebí <strong>LOOP</strong> vyu¾ívat, nebo» její funkci zastupují
dal¹í typy instrukcí: <strong>FORI</strong> na zaèátku smyèky (tato instrukce
zaji¹»uje vstup do smyèky) a <strong>FORL</strong> na konci smyèky (tato
instrukce zaji¹»uje øízení dal¹í iterace).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. ©ablony (templates) pou¾ité pøi pøekladu programových smyèek <strong>while</strong>, <strong>repeat-until</strong> a poèítané smyèky <strong>for</strong></h2>

<p>Ve struènosti si zopakujme tvar ¹ablon (posloupnost instrukcí IR) pou¾itou
pøi pøekladu typických programových smyèek do mezijazyka LuaJITu:</p>



<p><a name="k021"></a></p>
<h3 id="k021">2.1 ©ablona pro programovou smyèku typu <strong>while</strong></h3>

<p>Pøi pøekladu programové smyèky typu <strong>while</strong> do mezijazyka
LuaJITu se pou¾ívá ètveøice instrukcí &ndash; podmínìný skok na zaèátku smyèky
realizovaný dvojicí instrukcí <strong>IS??+JMP</strong>, nepodmínìný skok na
konci smyèky realizovaný instrukcí <strong>JMP</strong> a
&bdquo;pøebyteènou&ldquo; instrukcí <strong>LOOP</strong> oznaèující tìlo
smyèky (tedy zjednodu¹enì øeèeno rozsah instrukcí od-do):</p>

<pre>
+---&gt; <strong>IS??</strong>     <i>; podmínka odvozená z invertované podmínky zapsané ve zdrojovém kódu</i>
|     <strong>JMP</strong> --+  <i>; podmínìný skok ZA konec programové smyèky</i>
|     <strong>LOOP</strong>  |  <i>; oznaèení generické programové smyèky (pro detekci hot spotù)</i>
|     <strong>?</strong>     |
|     <strong>?</strong>     |  <i>; instrukce tvoøící tìlo smyèky</i>
|     <strong>?</strong>     |  <i>; instrukce tvoøící tìlo smyèky</i>
|     <strong>?</strong>     |  <i>; instrukce tvoøící tìlo smyèky</i>
|     <strong>?</strong>     |
|     <strong>?</strong>     |  <i>; end loop</i>
+---- <strong>JMP</strong>   |  <i>; nepodmínìný skok na zaèátek programové smyèky</i>
      &lt;-----+
</pre>



<p><a name="k022"></a></p>
<h3 id="k022">2.2 ©ablona pro programovou smyèku typu <strong>repeat-until</strong></h3>

<p>Pøeklad programové smyèky typu <strong>repeat-until</strong> do mezijazyka
LuaJITu je jednodu¹¹í, nebo» se podmínìný skok realizovaný dvojicí
<strong>IS??+JMP</strong> pøesouvá na konec smyèky. Na jejím zaèátku tak zbývá
místo jen pro instrukci <strong>LOOP</strong>:</p>

<pre>
+---&gt; <strong>LOOP</strong>     <i>; oznaèení generické programové smyèky (pro detekci hot spotù)</i>
|     <strong>?</strong>
|     <strong>?</strong>        <i>; instrukce tvoøící tìlo smyèky</i>
|     <strong>?</strong>        <i>; instrukce tvoøící tìlo smyèky</i>
|     <strong>?</strong>        <i>; instrukce tvoøící tìlo smyèky</i>
|     <strong>?</strong>
|     <strong>IS??</strong>     <i>; podmínka odvozená z podmínky zapsané ve zdrojovém kódu</i>
+---- <strong>JMP</strong>      <i>; podmínìný skok na zaèátek programové smyèky</i>
</pre>



<p><a name="k023"></a></p>
<h3 id="k023">2.3 ©ablona pro poèítanou programovou smyèku typu <strong>for</strong></h3>

<p>©ablona pou¾itá pro poèítanou programovou smyèku typu <strong>for</strong>
pøi pøekladu do mezijazyka LuaJITu je ponìkud odli¹ná, nebo» zde ji¾ nenajdeme
instrukci <strong>LOOP</strong>. Je tomu tak z&nbsp;toho dùvodu, ¾e
&bdquo;oznaèení&ldquo; zaèátku a konce tohoto typu smyèky nám zajistí instrukce
<strong>FORI</strong> (zaèátek smyèky) a <strong>FORL</strong> (konec
smyèky).</p>

<pre>
+---&gt;  <strong>FORI</strong> --+  <i>; vstup do poèítané programové smyèky typu for</i>
|      <strong>?</strong>      |
|      <strong>?</strong>      |  <i>; instrukce tvoøící tìlo smyèky</i>
|      <strong>?</strong>      |  <i>; instrukce tvoøící tìlo smyèky</i>
|      <strong>?</strong>      |  <i>; instrukce tvoøící tìlo smyèky</i>
|      <strong>?</strong>      |
+----- <strong>FORL</strong>   |  <i>; dal¹í iterace, skok na zaèátek programové smyèky</i>
      &lt;-------+
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. ©ablony pou¾ité pøi pøekladu programové smyèky typu <strong>for-each</strong></h2>

<p>Oproti trojici programových smyèek pøedstavených <a
href="#k02">v&nbsp;pøedchozí kapitole</a> se práce pøekladaèe <i>LuaJITu</i>
stává ponìkud slo¾itìj¹í ve chvíli, kdy se ve zdrojovém kódu vyskytne (velmi
èasto pou¾ívaná) programová smyèka typu <strong>for-each</strong> urèená pro
prùchod polem popø.&nbsp;pro prùchod asociativním polem. Tyto typy smyèek by se
teoreticky daly pøelo¾it stejným zpùsobem jako programová smyèka
<strong>while</strong>, pøièem¾ by se pøed ka¾dou iterací zavolala funkce
<strong>next()</strong>. Smyèka <strong>for-each</strong> by tedy byla do
znaèné míry ekvivalentní zápisu:

<pre>
<i>-- inicializace - získání prvního prvku a jeho indexu z tabulky</i>
<strong>local</strong> index,value = next(my_table, nil)
&nbsp;
<i>-- programová smyèka typu while</i>
<strong>while</strong> index <strong>do</strong>
    index,value = next(my_table, index)
<strong>end</strong>
</pre>

<p>Ve skuteènosti v¹ak pøekladaè LuaJITu generuje dosti odli¹ný IR, v&nbsp;nìm¾
nalezneme nové typy instrukcí, co¾ si uká¾eme v&nbsp;navazujících podkapitolách
a kapitolách.</p>



<p><a name="k031"></a></p>
<h3 id="k031">3.1 ©ablona pro programovou smyèku typu <strong>for-each</strong> pøi prùchodu polem</h3>

<p>Pøi prùchodu polem, tj.&nbsp;tabulkou, v&nbsp;ní¾ mají v¹echny prvky
pøiøazen celoèíselný index od 1 do n, se ve zdrojovém kódu vyu¾ívá iterátoru
<i>ipairs()</i> a v&nbsp;pøelo¾eném kódu nalezneme jak volání tohoto iterátoru,
tak i dvojici nových instrukcí nazvaných <strong>ITERC</strong> a
<strong>ITERL</strong>. Instrukce <strong>ITERC</strong> zavolá znovu iterátor,
pøièem¾ parametry tohoto iterátoru jsou vìt¹inou ji¾ pøipraveny
v&nbsp;rezervovaných slotech po celou dobu &bdquo;¾ivota&ldquo; programové
smyèky. Vlastní test, zda se má provést dal¹í iterace a tím pádem i skok, je
pøedstavován funkcí <strong>ITERL</strong>:</p>

<pre>
       <strong>GGET</strong>      <i>; získání reference na funkci se jménem "ipairs"</i>
       <strong>MOV</strong>       <i>; pøedání iterátoru jako parametru funkce</i>
       <strong>CALL</strong>      <i>; zavolání funkce ipairs()</i>
       <strong>JMP</strong>  --+  <i>; pøímý skok na instrukci ITERC</i>
+---&gt;  <strong>?</strong>      |
|      <strong>?</strong>      |  <i>; instrukce tvoøící tìlo smyèky</i>
|      <strong>?</strong>      |  <i>; instrukce tvoøící tìlo smyèky</i>
|      <strong>?</strong>      |  <i>; instrukce tvoøící tìlo smyèky</i>
|      <strong>?</strong>      |
|      <strong>ITERC</strong>&lt;-+
+----  <strong>ITERL</strong>    <i>; návrat na zaèátek smyèky (dal¹í iterace)</i>
</pre>



<p><a name="k032"></a></p>
<h3 id="k032">3.2 ©ablona pro programovou smyèku typu <strong>for-each</strong> pøi prùchodu asociativním polem</h3>

<p>Podobným zpùsobem je pøelo¾ena i programová smyèka typu
<strong>for-each</strong> ve chvíli, kdy se prochází v¹emi prvky asociativního
pole, tj.&nbsp;takové tabulky, v&nbsp;ní¾ je ka¾dý prvek indexován klíèem
(typicky øetìzcem, ale mù¾e se jednat i o klíè jiného typu, kromì hodnoty
<strong>nil</strong>). Pøi pøekladu do bajtkódu se pou¾ívají instrukce
<strong>ISNEXT</strong>, <strong>ITERN</strong> a <strong>ITERL</strong> (tato
instrukce je tedy stejná, jako tomu bylo i <a href="#k031">v&nbsp;pøedchozím
pøípadì</a>). Instrukce <strong>ITERN</strong> doká¾e spolupracovat (volat)
funkce <i>next()</i> èi <i>pairs()</i> a tím pádem implementovat jak naètení
dal¹ího prvku z&nbsp;asociativního pole, tak i pøípravu pro test, zda se má
provést dal¹í iterace:</p>

<pre>
       <strong>GGET</strong>      <i>; získání reference na funkci se jménem "pairs"</i>
       <strong>MOV</strong>       <i>; pøedání iterátoru jako parametru funkce</i>
       <strong>CALL</strong>      <i>; zavolání funkce pairs()</i>
       <strong>ISNEXT</strong>-+  <i>; pøímý skok na instrukci ITERN</i>
+---&gt;  <strong>?</strong>      |
|      <strong>?</strong>      |  <i>; instrukce tvoøící tìlo smyèky</i>
|      <strong>?</strong>      |  <i>; instrukce tvoøící tìlo smyèky</i>
|      <strong>?</strong>      |  <i>; instrukce tvoøící tìlo smyèky</i>
|      <strong>?</strong>      |
|      <strong>ITERN</strong>&lt;-+
+----  <strong>ITERL</strong>     <i>; návrat na zaèátek smyèky (dal¹í iterace)</i>
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Programová smyèka typu <strong>for-each</strong> pøi prùchodu polem</h2>

<p>V&nbsp;dne¹ním prvním demonstraèním pøíkladu nazvaném
<strong>test35.lua</strong> je nejprve vytvoøena a souèasnì i inicializována
desetiprvková tabulka. Následnì se v&nbsp;trojici programových smyèek postupnì
vypí¹ou indexy prvkù (první smyèka), hodnoty prvkù (druhá smyèka) a
indexy+hodnoty prvkù (tøetí smyèka) této tabulky.</p>



<p><a name="k041"></a></p>
<h3 id="k041">4.1 Zdrojový kód pøíkladu <strong>test35.lua</strong></h3>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 35.</i>
<i>--</i>
<i>-- Práce s tabulkami:</i>
<i>--    * vytvoøení a inicializace neprázdné tabulky</i>
<i>--    * programová smyèka typu for-each vyu¾ívající</i>
<i>--      funkci ipairs pou¾itá pro prùchod tabulkou.</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>-- vytvoøení desetiprvkové tabulky</i>
<strong>local</strong> tbl = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1}
&nbsp;
<i>-- programová smyèka typu for-each vyu¾ívající funkci ipairs</i>
<strong>for</strong> i,val <strong>in</strong> ipairs(tbl) <strong>do</strong>
    print(i)
<strong>end</strong>
&nbsp;
<i>-- odøádkování</i>
print()
&nbsp;
<i>-- programová smyèka typu for-each vyu¾ívající funkci ipairs</i>
<strong>for</strong> i,val <strong>in</strong> ipairs(tbl) <strong>do</strong>
    print(val)
<strong>end</strong>
&nbsp;
<i>-- odøádkování</i>
print()
&nbsp;
<i>-- programová smyèka typu for-each vyu¾ívající funkci ipairs</i>
<strong>for</strong> i,val <strong>in</strong> ipairs(tbl) <strong>do</strong>
    print(i, val)
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>-- finito</i>
</pre>



<p><a name="k042"></a></p>
<h3 id="k042">4.2 Pøeklad pøíkladu <strong>test35.lua</strong> do mezijazyka LuaJITu</h3>

<p>V&nbsp;IR pøelo¾eného pøíkladu <strong>test35.lua</strong> mù¾eme vidìt
pou¾ití instrukcí <strong>ITERC</strong> a <strong>ITERL</strong>:</p>

<pre>
<i>; Pøeklad demonstraèního pøíkladu test35.lua</i>
<i>; do IR vyu¾ívaného virtuálním strojem a JIT</i>
<i>; pøekladaèem LuaJIT.</i>
&nbsp;
&nbsp;
<i>; metadata se základními informacemi o zdrojovém kódu,</i>
<i>; který byl pou¾it pro vygenerování tohoto IR</i>
-- BYTECODE -- test35.lua:0-40
&nbsp;
&nbsp;
&nbsp;
<i>; vytvoøení a inicializace tabulky</i>
<i>; local tbl = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1}</i>
0001    <strong>TDUP</strong>     0   0        <i>; vytvoøení a inicializace tabulky</i>
&nbsp;
<i>; programová smyèka typu for-each</i>
<i>; for i,val in ipairs(tbl) do</i>
0002    <strong>GGET</strong>     1   1        <i>; získání reference na funkci se jménem "ipairs"</i>
0003    <strong>MOV</strong>      2   0        <i>; pøedání iterátoru</i>
0004    <strong>CALL</strong>     1   4   2    <i>; volání funkce ipairs()</i>
0005    <strong>JMP</strong>      4 =&gt; 0009    <i>; pøímý skok na instrukci ITERC</i>
&nbsp;
<i>; print(i)</i>
0006 =&gt; <strong>GGET</strong>     6   2        <i>; získání reference na funkci se jménem "print"</i>
0007    <strong>MOV</strong>      7   4        <i>; bude se tisknout index</i>
0008    <strong>CALL</strong>     6   1   2    <i>; volání funkce print()</i>
0009 =&gt; <strong>ITERC</strong>    4   3   3    <i>; volání iterátoru a zji¹tìní. zda existuje dal¹í prvek v tabulce</i>
&nbsp;
<i>; end loop</i>
0010    <strong>ITERL</strong>    4 =&gt; 0006    <i>; dal¹í iterace (pokud k ní dojde) zaène na instrukci 0006</i>
&nbsp;
<i>; print()</i>
0011    <strong>GGET</strong>     1   2        <i>; získání reference na funkci se jménem "print"</i>
0012    <strong>CALL</strong>     1   1   1    <i>; volání funkce print()</i>
&nbsp;
<i>; programová smyèka typu for-each</i>
<i>; for i,val in ipairs(tbl) do</i>
0013    <strong>GGET</strong>     1   1        <i>; získání reference na funkci se jménem "ipairs"</i>
0014    <strong>MOV</strong>      2   0        <i>; pøedání iterátoru</i>
0015    <strong>CALL</strong>     1   4   2    <i>; volání funkce ipairs()</i>
0016    <strong>JMP</strong>      4 =&gt; 0020    <i>; pøímý skok na instrukci ITERC</i>
&nbsp;
<i>; print(val)</i>
0017 =&gt; <strong>GGET</strong>     6   2        <i>; získání reference na funkci se jménem "print"</i>
0018    <strong>MOV</strong>      7   5        <i>; bude se tisknout hodnota</i>
0019    <strong>CALL</strong>     6   1   2    <i>; volání funkce print()</i>
0020 =&gt; <strong>ITERC</strong>    4   3   3    <i>; volání iterátoru a zji¹tìní. zda existuje dal¹í prvek v tabulce</i>
&nbsp;
<i>; end loop</i>
0021    <strong>ITERL</strong>    4 =&gt; 0017    <i>; dal¹í iterace (pokud k ní dojde) zaène na instrukci 0017</i>
&nbsp;
<i>; print()</i>
0022    <strong>GGET</strong>     1   2        <i>; získání reference na funkci se jménem "print"</i>
0023    <strong>CALL</strong>     1   1   1    <i>; volání funkce print()</i>
&nbsp;
<i>; programová smyèka typu for-each</i>
<i>; for i,val in ipairs(tbl) do</i>
0024    <strong>GGET</strong>     1   1        <i>; získání reference na funkci se jménem "ipairs"</i>
0025    <strong>MOV</strong>      2   0        <i>; pøedání iterátoru</i>
0026    <strong>CALL</strong>     1   4   2    <i>; volání funkce ipairs()</i>
0027    <strong>JMP</strong>      4 =&gt; 0032    <i>; pøímý skok na instrukci ITERC</i>
&nbsp;
<i>; print(i, val)</i>
0028 =&gt; <strong>GGET</strong>     6   2        <i>; získání reference na funkci se jménem "print"</i>
0029    <strong>MOV</strong>      7   4        <i>; bude se tisknout index</i>
0030    <strong>MOV</strong>      8   5        <i>; a souèasnì i hodnota</i>
0031    <strong>CALL</strong>     6   1   3    <i>; volání funkce print()</i>
0032 =&gt; <strong>ITERC</strong>    4   3   3    <i>; volání iterátoru a zji¹tìní. zda existuje dal¹í prvek v tabulce</i>
&nbsp;
<i>; end loop</i>
0033    <strong>ITERL</strong>    4 =&gt; 0028    <i>; dal¹í iterace (pokud k ní dojde) zaène na instrukci 0028</i>
&nbsp;
<i>; ka¾dý program je automaticky ukonèen následující instrukcí</i>
0034    <strong>RET0</strong>     0   1
&nbsp;
<i>; konec</i>
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Programová smyèka typu <strong>for-each</strong> pøi prùchodu asociativním polem</h2>

<p>V&nbsp;dne¹ním druhém demonstraèním pøíkladu s&nbsp;názvem
<strong>test36.lua</strong> si uká¾eme zpùsob prùchodu asociativním polem ve
smyèce typu <strong>for-each</strong> spojené s&nbsp;funkcí
<strong>pairs()</strong>. Podobnì jako v&nbsp;pøedchozím pøíkladu, i zde jsou
pou¾ity tøi programové smyèky, pøièem¾ v&nbsp;první smyèce se na standardní
výstup vytisknou pouze jednotlivé klíèe (v&nbsp;poøadí, které obvykle
neodpovídá poøadí vlo¾ení prvkù do tabulky), ve smyèce druhé se vytisknou jen
hodnoty prvkù tabulky a koneènì ve smyèce tøetí se vytisknou jak hodnoty klíèù,
tak i hodnoty prvkù pøiøazených k&nbsp;tìmto klíèùm.</p>



<p><a name="k051"></a></p>
<h3 id="k051">5.1 Zdrojový kód pøíkladu <strong>test36.lua</strong></h3>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 36.</i>
<i>--</i>
<i>-- Práce s tabulkami:</i>
<i>--    * vytvoøení a inicializace prázdné tabulky</i>
<i>--    * pøidání prvku do tabulky s pou¾itím klíèù</i>
<i>--    * programová smyèka typu for-each vyu¾ívající</i>
<i>--      funkci ipairs pou¾itá pro prùchod tabulkou</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>-- vytvoøení prázdné tabulky</i>
<strong>local</strong> tbl = {}
&nbsp;
<i>-- nastavit hodnotu prvku tabulky</i>
tbl["first"] = 777
&nbsp;
<i>-- nastavit hodnotu prvku tabulky</i>
tbl["second"] = 999
&nbsp;
<i>-- nastavit hodnotu prvku tabulky</i>
tbl["tenth"] = 1000
&nbsp;
<i>-- programová smyèka typu for-each vyu¾ívající funkci ipairs</i>
<strong>for</strong> key,val <strong>in</strong> pairs(tbl) <strong>do</strong>
    print(key)
<strong>end</strong>
&nbsp;
<i>-- odøádkování</i>
print()
&nbsp;
<i>-- programová smyèka typu for-each vyu¾ívající funkci ipairs</i>
<strong>for</strong> key,val <strong>in</strong> pairs(tbl) <strong>do</strong>
    print(val)
<strong>end</strong>
&nbsp;
<i>-- odøádkování</i>
print()
&nbsp;
<i>-- programová smyèka typu for-each vyu¾ívající funkci ipairs</i>
<strong>for</strong> key,val <strong>in</strong> pairs(tbl) <strong>do</strong>
    print(key, val)
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>-- finito</i>
</pre>



<p><a name="k052"></a></p>
<h3 id="k052">5.2 Pøeklad pøíkladu <strong>test36.lua</strong> do mezijazyka LuaJITu</h3>

<p>Pøi pøekladu tohoto demonstraèního pøíkladu do IR jsou pro implementaci
smyèky pou¾ity instrukce <strong>ISNEXT</strong> a <strong>ITERN</strong>:</p>

<pre>
<i>; Pøeklad demonstraèního pøíkladu test36.lua</i>
<i>; do IR vyu¾ívaného virtuálním strojem a JIT</i>
&nbsp;
&nbsp;
&nbsp;
<i>; pøekladaèem LuaJIT.</i>
<i>; metadata se základními informacemi o zdrojovém kódu,</i>
<i>; který byl pou¾it pro vygenerování tohoto IR</i>
-- BYTECODE -- test36.lua:0-50
&nbsp;
&nbsp;
&nbsp;
<i>; vytvoøení prázdné tabulky</i>
<i>; local tbl = {}</i>
0001    <strong>TNEW</strong>     0   0        <i>; vytvoøení prázdné tabulky</i>
&nbsp;
<i>; nastavit hodnotu prvku tabulky</i>
<i>; s vyu¾itím klíèe reprezentovaného øetìzcem</i>
<i>; tbl["first"] = 777</i>
0002    <strong>KSHORT</strong>   1 777        <i>; ukládaná konstanta</i>
0003    <strong>TSETS</strong>    1   0   0    <i>; ulo¾ení hodnoty do tabulky</i>
&nbsp;
<i>; nastavit hodnotu prvku tabulky</i>
<i>; s vyu¾itím klíèe reprezentovaného øetìzcem</i>
<i>; tbl["second"] = 999</i>
0004    <strong>KSHORT</strong>   1 999        <i>; ukládaná konstanta</i>
0005    <strong>TSETS</strong>    1   0   1    <i>; ulo¾ení hodnoty do tabulky</i>
&nbsp;
<i>; nastavit hodnotu prvku tabulky</i>
<i>; s vyu¾itím klíèe reprezentovaného øetìzcem</i>
<i>; tbl["tenth"] = 1000</i>
0006    <strong>KSHORT</strong>   1 1000       <i>; ukládaná konstanta</i>
0007    <strong>TSETS</strong>    1   0   2    <i>; ulo¾ení hodnoty do tabulky</i>
&nbsp;
<i>; programová smyèka typu for-each</i>
<i>; for key,val in pairs(tbl) do</i>
0008    <strong>GGET</strong>     1   3        <i>; získání reference na funkci se jménem "pairs"</i>
0009    <strong>MOV</strong>      2   0        <i>; pøedání iterátoru</i>
0010    <strong>CALL</strong>     1   4   2    <i>; volání funkce pairs()</i>
0011    <strong>ISNEXT</strong>   4 =&gt; 0015    <i>; pøímý skok na instrukci ITERN</i>
&nbsp;
<i>; print(key)</i>
0012 =&gt; <strong>GGET</strong>     6   4        <i>; získání reference na funkci se jménem "print"</i>
0013    <strong>MOV</strong>      7   4        <i>; bude se tisknout klíè</i>
0014    <strong>CALL</strong>     6   1   2    <i>; volání funkce print()</i>
0015 =&gt; <strong>ITERN</strong>    4   3   3    <i>; volání iterátoru a zji¹tìní. zda existuje dal¹í prvek v tabulce</i>
&nbsp;
<i>; end loop</i>
0016    <strong>ITERL</strong>    4 =&gt; 0012    <i>; dal¹í iterace (pokud k ní dojde) zaène na instrukci 0012</i>
&nbsp;
<i>; print()</i>
0017    <strong>GGET</strong>     1   4        <i>; získání reference na funkci se jménem "print"</i>
0018    <strong>CALL</strong>     1   1   1    <i>; volání funkce print()</i>
&nbsp;
<i>; programová smyèka typu for-each</i>
<i>; for key,val in pairs(tbl) do</i>
0019    <strong>GGET</strong>     1   3        <i>; získání reference na funkci se jménem "pairs"</i>
0020    <strong>MOV</strong>      2   0
0021    <strong>CALL</strong>     1   4   2
0022    <strong>ISNEXT</strong>   4 =&gt; 0026    <i>; volání iterátoru a zji¹tìní. zda existuje dal¹í prvek v tabulce</i>
&nbsp;
<i>; print(val)</i>
0023 =&gt; <strong>GGET</strong>     6   4        <i>; získání reference na funkci se jménem "print"</i>
0024    <strong>MOV</strong>      7   5        <i>; bude se tisknout hodnota</i>
0025    <strong>CALL</strong>     6   1   2    <i>; volání funkce print()</i>
0026 =&gt; <strong>ITERN</strong>    4   3   3    <i>; volání iterátoru a zji¹tìní. zda existuje dal¹í prvek v tabulce</i>
&nbsp;
<i>; end loop</i>
0027    <strong>ITERL</strong>    4 =&gt; 0023    <i>; dal¹í iterace (pokud k ní dojde) zaène na instrukci 0023</i>
&nbsp;
<i>; print()</i>
0028    <strong>GGET</strong>     1   4        <i>; získání reference na funkci se jménem "print"</i>
0029    <strong>CALL</strong>     1   1   1    <i>; volání funkce print()</i>
&nbsp;
<i>; programová smyèka typu for-each</i>
<i>; for key,val in pairs(tbl) do</i>
0030    <strong>GGET</strong>     1   3        <i>; získání reference na funkci se jménem "pairs"</i>
0031    <strong>MOV</strong>      2   0
0032    <strong>CALL</strong>     1   4   2
0033    <strong>ISNEXT</strong>   4 =&gt; 0038    <i>; volání iterátoru a zji¹tìní. zda existuje dal¹í prvek v tabulce</i>
&nbsp;
<i>; print(key, val)</i>
0034 =&gt; <strong>GGET</strong>     6   4        <i>; získání reference na funkci se jménem "print"</i>
0035    <strong>MOV</strong>      7   4        <i>; bude se tisknout klíè</i>
0036    <strong>MOV</strong>      8   5        <i>; a souèasnì se bude tisknout i hodnota</i>
0037    <strong>CALL</strong>     6   1   3    <i>; volání funkce print()</i>
0038 =&gt; <strong>ITERN</strong>    4   3   3    <i>; volání iterátoru a zji¹tìní. zda existuje dal¹í prvek v tabulce</i>
&nbsp;
<i>; end loop</i>
0039    <strong>ITERL</strong>    4 =&gt; 0034    <i>; dal¹í iterace (pokud k ní dojde) zaène na instrukci 0034</i>
&nbsp;
<i>; ka¾dý program je automaticky ukonèen následující instrukcí</i>
0040    <strong>RET0</strong>     0   1
&nbsp;
<i>; konec</i>
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Vytvoøení a následné pou¾ití (zavolání) uzávìru (closure)</h2>

<p>Poslední problematikou, kterou se v&nbsp;souvislosti s&nbsp;pøekladem
zdrojových kódù jazyka Lua do mezikódu <i>LuaJITu</i> budeme zabývat, je zpùsob
práce s&nbsp;takzvanými uzávìry (<i>closures</i>). Programovací jazyk Lua
pøevzal mnoho vlastností z&nbsp;klasických funkcionálních programovacích
jazykù, které práci s&nbsp;uzávìry podporují; jedná se souèasnì o velmi
dùle¾itou vlastnost umo¾òující efektivnìj¹í implementaci nìkterých typù
algoritmù. U vìt¹iny funkcionálních jazykù &ndash; a takté¾ u jazyka Lua
&ndash; si ka¾dý vytvoøený objekt (vèetnì funkce, zde speciálnì uzávìru)
uchovává odkazy na v¹echny promìnné, které jsou uvnitø objektu pou¾ity, nehledì
na jejich lexikální kontext (tyto promìnné se nazývají &bdquo;externí lokální
promìnné&ldquo; popø.&nbsp;&bdquo;upvalues&ldquo;).</p>

<p>To ov¹em znamená, ¾e pokud je uvnitø nìjaké funkce vytvoøena nová anonymní
funkce (uzávìr) pøistupující k&nbsp;lokálním promìnným své
&bdquo;obalující&ldquo; funkce a pokud je následnì tato anonymní funkce vrácena
pøíkazem <strong>return</strong>, jsou v¹echny odkazované lokální promìnné
zachovány minimálnì po tu dobu, po kterou existuje vrácený uzávìr (ten mù¾e být
ulo¾en jak do lokální, tak i do globální promìnné). Ka¾dé volání uzávìru mù¾e
s&nbsp;tìmito lokálními (a zdánlivì u¾ neexistujícími) promìnnými pracovat,
tj.&nbsp;èíst i zapisovat do nich hodnoty.</p> 

<p>Vzhledem k&nbsp;tomuto chování není ve funkcionálních jazycích podporujících
uzávìry obecnì mo¾né v¹echny lokální promìnné ukládat na zásobník (jeho rámec
je po opu¹tìní funkce zapomenut), ale je nutné vyu¾ít spí¹e pamì» alokovanou na
haldì (<i>heap</i>), pro její¾ uvolòování je pou¾ita nìjaká forma automatického
uvolòování nepou¾ívané pamìti (<i>garbage collectoru</i>).</p>

<p>V&nbsp;dne¹ním tøetím demonstraèním pøíkladu pojmenovaném
<strong>test37.lua</strong> je ve funkci <strong>createCounter()</strong>
vytvoøen uzávìr, tj.&nbsp;anonymní funkce, s&nbsp;ní¾ je svázána externí
lokální promìnná <strong>counter</strong>. Pøi ka¾dém zavolání tohoto uzávìru
se hodnota promìnné <strong>counter</strong> zvý¹í o jednièku a nová hodnota je
vrácena jako návratová hodnota uzávìru. Ve funkci <strong>main()</strong> je
uzávìr nejprve vytvoøen a následnì tøikrát zavolán.</p>



<p><a name="k061"></a></p>
<h3 id="k061">6.1 Zdrojový kód pøíkladu <strong>test37.lua</strong></h3>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 37</i>
<i>--</i>
<i>-- Vytvoøení a následné pou¾ití uzávìru (closure).</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>-- Vytvoøení a vrácení uzávìru, tj. funkce na ní¾ je navázána</i>
<i>-- externí lokální promìnná - upvalue.</i>
<strong>function</strong> createCounter()
    <i>-- lokální promìnná, její¾ "¾ivotnost" v èase bìhu aplikace pøesahuje</i>
    <i>-- pouhé zavolání a provedeni bloku funkce createCounter()</i>
    <strong>local</strong> counter = 0
    <i>-- návratovou hodnotou funkce createCounter() je anonymní</i>
    <i>-- funkce pracující s promìnnou cnt, která je na tuto</i>
    <i>-- anonymní funkci navázána</i>
    <strong>return</strong> <strong>function</strong>()
        <i>-- counter se oznaèuje jako "externí lokální promìnná"</i>
        <i>-- popø. v terminologii jazyka Lua "upvalue"</i>
        counter = counter + 1
        <strong>return</strong> counter
    <strong>end</strong>
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Spu¹tìní testu.</i>
<i>--</i>
<strong>function</strong> main()
    <i>-- získáme "instanci" anonymní funkce i na ni navázanou</i>
    <i>-- externí lokální promìnnou nazvanou "counter"</i>
    <i>-- -&amp; closure</i>
    <strong>local</strong> mycounter = createCounter()
    print(mycounter())
    print(mycounter())
    print(mycounter())
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
main()
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Finito.</i>
<i>--</i>
</pre>



<p><a name="k062"></a></p>
<h3 id="k062">6.2 Pøeklad pøíkladu <strong>test37.lua</strong> do mezijazyka LuaJITu</h3>

<p>Ve vygenerované sekvenci IR demonstraèního pøíkladu
<strong>test37.lua</strong> mù¾eme najít ètveøici nových instrukcí:
<strong>FNEW</strong>, <strong>UCLO</strong>, <strong>UGET</strong> a
<strong>USETV</strong>. Instrukce <strong>FNEW</strong> slou¾í pro vytvoøení
nového uzávìru z&nbsp;prototypu specifikovaného v&nbsp;operandu D, instrukce
<strong>UCLO</strong> k&nbsp;uzavøení hodnot a skoku na následující instrukci
(tou je ve vìt¹inì pøípadù <strong>JMP</strong> èi <strong>RET</strong>, skok
se zde vyu¾ije pøi dal¹ích optimalizacích).  V&nbsp;samotném uzávìru (tedy
funkci vyu¾ívající externí vázané promìnné) nalezneme instrukce
<strong>UGET</strong> a <strong>USETV</strong>, které slou¾í pro pøeètení èi
k&nbsp;zápisu do externí vázané promìnné (právì díky tìmto instrukcím doká¾e
uzávìr pøistupovat k&nbsp;vázaným promìnným):</p>

<pre>
<i>; Pøeklad demonstraèního pøíkladu test37.lua</i>
<i>; do IR vyu¾ívaného virtuálním strojem a JIT</i>
&nbsp;
&nbsp;
&nbsp;
<i>; metadata se základními informacemi o zdrojovém kódu,</i>
<i>; který byl pou¾it pro vygenerování tohoto IR</i>
-- BYTECODE -- test37.lua:18-23
&nbsp;
&nbsp;
&nbsp;
<i>; implementace uzávìru</i>
<i>; counter = counter + 1</i>
0001    <strong>UGET</strong>     0   0        <i>; pøeètení hodnoty externí vázané promìnné counter</i>
0002    <strong>ADDVN</strong>    0   0   0    <i>; pøiètení jednièky</i>
0003    <strong>USETV</strong>    0   0        <i>; zápis hodnoty externí vázané promìnné counter</i>
0004    <strong>UGET</strong>     0   0        <i>; pøeètení hodnoty externí vázané promìnné counter</i>
<i>; return counter</i>
0005    <strong>RET1</strong>     0   2        <i>; vrácení nové hodnoty</i>
&nbsp;
&nbsp;
&nbsp;
<i>; metadata se základními informacemi o zdrojovém kódu,</i>
<i>; který byl pou¾it pro vygenerování tohoto IR</i>
-- BYTECODE -- test37.lua:11-24
&nbsp;
&nbsp;
&nbsp;
<i>; implementace funkce createCounter()</i>
<i>; local counter = 0</i>
0001    <strong>KSHORT</strong>   0   0        <i>; nastavení hodnoty lokální promìnné counter</i>
<i>; return function()</i>
0002    <strong>FNEW</strong>     1   0        <i>; vytvoøení uzávìru</i>
0003    <strong>UCLO</strong>     0 =&gt; 0004
0004 =&gt; <strong>RET1</strong>     1   2        <i>; vrácení uzávìru</i>
&nbsp;
&nbsp;
&nbsp;
<i>; metadata se základními informacemi o zdrojovém kódu,</i>
<i>; který byl pou¾it pro vygenerování tohoto IR</i>
-- BYTECODE -- test37.lua:31-39
<i>; implementace funkce main()</i>
&nbsp;
&nbsp;
&nbsp;
<i>; local mycounter = createCounter()</i>
0001    <strong>GGET</strong>     0   0        <i>; získat referenci na funkci "createCounter"</i>
0002    <strong>CALL</strong>     0   2   1    <i>; volání funkce "createCounter"</i>
&nbsp;
<i>; print(mycounter())</i>
0003    <strong>GGET</strong>     1   1        <i>; získat referenci na funkci "print"</i>
0004    <strong>MOV</strong>      2   0
0005    <strong>CALL</strong>     2   0   1    <i>; volání funkce "mycounter"</i>
0006    <strong>CALLM</strong>    1   1   0    <i>; volání funkce "print"</i>
&nbsp;
<i>; print(mycounter())</i>
0007    <strong>GGET</strong>     1   1        <i>; získat referenci na funkci "print"</i>
0008    <strong>MOV</strong>      2   0
0009    <strong>CALL</strong>     2   0   1    <i>; volání funkce "mycounter"</i>
0010    <strong>CALLM</strong>    1   1   0    <i>; volání funkce "print"</i>
&nbsp;
<i>; print(mycounter())</i>
0011    <strong>GGET</strong>     1   1        <i>; získat referenci na funkci "print"</i>
0012    <strong>MOV</strong>      2   0
0013    <strong>CALL</strong>     2   0   1    <i>; volání funkce "mycounter"</i>
0014    <strong>CALLM</strong>    1   1   0    <i>; volání funkce "print"</i>
&nbsp;
0015    <strong>RET0</strong>     0   1        <i>; návrat z funkce "main"</i>
&nbsp;
&nbsp;
&nbsp;
<i>; metadata se základními informacemi o zdrojovém kódu,</i>
<i>; který byl pou¾it pro vygenerování tohoto IR</i>
-- BYTECODE -- test37.lua:0-51
&nbsp;
&nbsp;
&nbsp;
<i>; inicializace a volání funkce main</i>
0001    <strong>FNEW</strong>     0   0        <i>; test37.lua:11</i>
0002    <strong>GSET</strong>     0   1        <i>; "createCounter"</i>
0003    <strong>FNEW</strong>     0   2        <i>; test37.lua:31</i>
0004    <strong>GSET</strong>     0   3        <i>; "main"</i>
0005    <strong>GGET</strong>     0   3        <i>; "main"</i>
0006    <strong>CALL</strong>     0   1   1    <i>; volání funkce "main"</i>
&nbsp;
<i>; ka¾dý program je automaticky ukonèen následující instrukcí</i>
0007    <strong>RET0</strong>     0   1
&nbsp;
<i>; konec</i>
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Externí lokální promìnné vìt¹ího mno¾ství uzávìrù</h2>

<p>V&nbsp;pøípadì dal¹ího volání funkce <i>createCounter()</i> se vytvoøí i
nová lokální promìnná <strong>counter</strong> i nový uzávìr,
tj.&nbsp;jednotlivé uzávìry obsahují vazby na své vlastní kopie pùvodních
lokálních promìnných (lokální promìnné tedy nejsou statické ve smyslu
&bdquo;statiènosti&ldquo; známém napøíklad z&nbsp;céèka). Ka¾dé volání funkce
<i>createCounter()</i> tedy vede k&nbsp;alokaci pamìti na haldì; do této pamìti
je ulo¾ena poèáteèní hodnota lokální promìnné <i>counter</i> a vytvoøený uzávìr
obsahuje odkaz na tuto hodnotu. Tuto vlastnost si otestujeme na dne¹ním ètvrtém
demonstraèním pøíkladu nazvaném <strong>test38.lua</strong>, v&nbsp;nìm¾ se
vytvoøí dva uzávìry, které se následnì volají v&nbsp;poèítané programové smyèce
typu <strong>for</strong>.</p>



<p><a name="k071"></a></p>
<h3 id="k071">7.1 Zdrojový kód pøíkladu <strong>test38.lua</strong></h3>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 38.</i>
<i>--</i>
<i>-- Vytváøení a následné pou¾ití uzávìru (closure).</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>-- Vytvoøení a vraceni uzávìru</i>
<strong>function</strong> createCounter()
    <i>-- lokální promìnná, její¾ "¾ivotnost" v èase bìhu aplikace pøesahuje</i>
    <i>-- pouhé zavolání a provedeni bloku funkce createCounter()</i>
    <strong>local</strong> counter = 0
    <i>-- návratovou hodnotou funkce createCounter() je anonymní</i>
    <i>-- funkce pracující s promìnnou cnt, která je na tuto</i>
    <i>-- anonymní funkci navázána</i>
    <strong>return</strong> <strong>function</strong>()
        <i>-- counter se oznaèuje jako "externí lokální promìnná"</i>
        <i>-- popø. v terminologii jazyka Lua "upvalue"</i>
        counter = counter + 1
        <strong>return</strong> counter
    <strong>end</strong>
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Spu¹tìní testu.</i>
<i>--</i>
<strong>function</strong> main()
    <i>-- získáme dvojici uzávìru</i>
    <strong>local</strong> counter1 = createCounter()
    <strong>local</strong> counter2 = createCounter()
&nbsp;
    <i>-- volání uzávìru</i>
    for i = 1, 10 do
        print("iteration #" .. i)
        print("    counter1: " .. counter1())
        print("    counter2: " .. counter2())
        print("    counter1: " .. counter1())
        print()
    <strong>end</strong>
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
main()
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Finito.</i>
<i>--</i>
</pre>



<p><a name="k072"></a></p>
<h3 id="k072">7.2 Pøeklad pøíkladu <strong>test38.lua</strong> do mezijazyka LuaJITu</h3>

<pre>
<i>; Pøeklad demonstraèního pøíkladu test38.lua</i>
<i>; do IR vyu¾ívaného virtuálním strojem a JIT</i>
&nbsp;
&nbsp;
&nbsp;
<i>; metadata se základními informacemi o zdrojovém kódu,</i>
<i>; který byl pou¾it pro vygenerování tohoto IR</i>
-- BYTECODE -- test38.lua:17-22
&nbsp;
&nbsp;
&nbsp;
<i>; implementace uzávìru</i>
<i>; counter = counter + 1</i>
0001    <strong>UGET</strong>     0   0        <i>; pøeètení hodnoty externí vázané promìnné counter</i>
0002    <strong>ADDVN</strong>    0   0   0    <i>; pøiètení jednièky</i>
0003    <strong>USETV</strong>    0   0        <i>; zápis hodnoty externí vázané promìnné counter</i>
0004    <strong>UGET</strong>     0   0        <i>; pøeètení hodnoty externí vázané promìnné counter</i>
<i>; return counter</i>
0005    <strong>RET1</strong>     0   2        <i>; vrácení nové hodnoty</i>
&nbsp;
&nbsp;
&nbsp;
<i>; metadata se základními informacemi o zdrojovém kódu,</i>
<i>; který byl pou¾it pro vygenerování tohoto IR</i>
-- BYTECODE -- test38.lua:10-23
&nbsp;
&nbsp;
&nbsp;
<i>; implementace funkce createCounter()</i>
<i>; local counter = 0</i>
0001    <strong>KSHORT</strong>   0   0        <i>; nastavení hodnoty lokální promìnné counter</i>
<i>; return function()</i>
0002    <strong>FNEW</strong>     1   0        <i>; vytvoøení uzávìru</i>
0003    <strong>UCLO</strong>     0 =&gt; 0004
0004 =&gt; <strong>RET1</strong>     1   2        <i>; vrácení uzávìru</i>
&nbsp;
&nbsp;
&nbsp;
<i>; metadata se základními informacemi o zdrojovém kódu,</i>
<i>; který byl pou¾it pro vygenerování tohoto IR</i>
-- BYTECODE -- test38.lua:30-43
<i>; implementace funkce main()</i>
&nbsp;
&nbsp;
&nbsp;
<i>; local mycounter1 = createCounter()</i>
0001    <strong>GGET</strong>     0   0        <i>; získat referenci na funkci "createCounter"</i>
0002    <strong>CALL</strong>     0   2   1    <i>; volání funkce "createCounter"</i>
&nbsp;
<i>; local mycounter2 = createCounter()</i>
0003    <strong>GGET</strong>     1   0        <i>; získat referenci na funkci "createCounter"</i>
0004    <strong>CALL</strong>     1   2   1    <i>; volání funkce "createCounter"</i>
&nbsp;
<i>; pøíprava poèítané programové smyèky for</i>
0005    <strong>KSHORT</strong>   2   1
0006    <strong>KSHORT</strong>   3  10
0007    <strong>KSHORT</strong>   4   1
0008    <strong>FORI</strong>     2 =&gt; 0035
&nbsp;
<i>; tìlo poèítané programové smyèky for</i>
&nbsp;
<i>; print("iteration #" .. i)</i>
0009 =&gt; <strong>GGET</strong>     6   1        <i>; "print"</i>
0010    <strong>KSTR</strong>     7   2        <i>; "iteration #"</i>
0011    <strong>MOV</strong>      8   5
0012    <strong>CAT</strong>      7   7   8    <i>; spojení øetìzcù</i>
0013    <strong>CALL</strong>     6   1   2    <i>; volání funkce "print"</i>
&nbsp;
<i>; print("    counter1: " .. counter1())</i>
0014    <strong>GGET</strong>     6   1        <i>; "print"</i>
0015    <strong>KSTR</strong>     7   3        <i>; "    counter1: "</i>
0016    <strong>MOV</strong>      8   0
0017    <strong>CALL</strong>     8   2   1    <i>; volání uzávìru</i>
0018    <strong>CAT</strong>      7   7   8    <i>; spojení øetìzcù</i>
0019    <strong>CALL</strong>     6   1   2    <i>; volání funkce "print"</i>
&nbsp;
<i>; print("    counter2: " .. counter2())</i>
0020    <strong>GGET</strong>     6   1        <i>; "print"</i>
0021    <strong>KSTR</strong>     7   4        <i>; "    counter2: "</i>
0022    <strong>MOV</strong>      8   1
0023    <strong>CALL</strong>     8   2   1    <i>; volání uzávìru</i>
0024    <strong>CAT</strong>      7   7   8    <i>; spojení øetìzcù</i>
0025    <strong>CALL</strong>     6   1   2    <i>; volání funkce "print"</i>
&nbsp;
<i>; print("    counter1: " .. counter1())</i>
0026    <strong>GGET</strong>     6   1        <i>; "print"</i>
0027    <strong>KSTR</strong>     7   3        <i>; "    counter1: "</i>
0028    <strong>MOV</strong>      8   0
0029    <strong>CALL</strong>     8   2   1    <i>; volání uzávìru</i>
0030    <strong>CAT</strong>      7   7   8    <i>; spojení øetìzcù</i>
0031    <strong>CALL</strong>     6   1   2    <i>; volání funkce "print"</i>
&nbsp;
<i>; print()</i>
0032    <strong>GGET</strong>     6   1       <i>; "print"</i>
0033    <strong>CALL</strong>     6   1   1
&nbsp;
<i>; konec tìla programové smyèky for</i>
0034    <strong>FORL</strong>     2 =&gt; 0009
&nbsp;
<i>; návrat z funkce</i>
0035 =&gt; <strong>RET0</strong>     0   1
&nbsp;
&nbsp;
&nbsp;
<i>; metadata se základními informacemi o zdrojovém kódu,</i>
<i>; který byl pou¾it pro vygenerování tohoto IR</i>
-- BYTECODE -- test38.lua:0-55
&nbsp;
&nbsp;
&nbsp;
<i>; inicializace a volání funkce main</i>
0001    <strong>FNEW</strong>     0   0        <i>; test38.lua:10</i>
0002    <strong>GSET</strong>     0   1        <i>; "createCounter"</i>
0003    <strong>FNEW</strong>     0   2        <i>; test38.lua:30</i>
0004    <strong>GSET</strong>     0   3        <i>; "main"</i>
0005    <strong>GGET</strong>     0   3        <i>; "main"</i>
0006    <strong>CALL</strong>     0   1   1    <i>; volání funkce "main"</i>
&nbsp;
<i>; ka¾dý program je automaticky ukonèen následující instrukcí</i>
0007    <strong>RET0</strong>     0   1
&nbsp;
<i>; konec</i>
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Pøedání parametrù volanému uzávìru</h2>

<p>Dne¹ní pátý a souèasnì i poslední demonstraèní pøíklad, který je pojmenovaný
<strong>test39.lua</strong>, se v&nbsp;mnoha ohledech podobá tøetímu pøíkladu
nazvanému <strong>test37.lua</strong>. Je zde v¹ak jedna podstatná odli¹nost
&ndash; pøi volání uzávìru se mu pøedává parametr urèující, jakým zpùsobem se
má zmìnit hodnota externí lokální promìnné navázané na uzávìr. Tato zmìna ve
zdrojovém kódu samozøejmì povede i ke zmìnám ve vygenerovaném IR.</p>



<p><a name="k081"></a></p>
<h3 id="k081">8.1 Zdrojový kód pøíkladu <strong>test39.lua</strong></h3>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 39.</i>
<i>--</i>
<i>-- Vytváøení a následné pou¾ití uzávìru (closure).</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>-- Vytvoøení a vraceni uzávìru</i>
<strong>function</strong> createCounter()
    <i>-- lokální promìnná, její¾ "¾ivotnost" v èase bìhu aplikace pøesahuje</i>
    <i>-- pouhé zavolání a provedeni bloku funkce createCounter()</i>
    <strong>local</strong> counter = 0
    <i>-- návratovou hodnotou funkce createCounter() je anonymní</i>
    <i>-- funkce pracující s promìnnou cnt, která je na tuto</i>
    <i>-- anonymní funkci navázána</i>
    <strong>return</strong> <strong>function</strong>(delta)
        <i>-- counter se oznaèuje jako "externí lokální promìnná"</i>
        <i>-- popø. v terminologii jazyka Lua "upvalue"</i>
        counter = counter + delta
        <strong>return</strong> counter
    <strong>end</strong>
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Spu¹tìní testu.</i>
<i>--</i>
<strong>function</strong> main()
    <i>-- získáme "instanci" anonymní funkce i na ni navázanou</i>
    <i>-- externí lokální promìnnou "counter"</i>
    <i>-- -> closure</i>
    <strong>local</strong> mycounter = createCounter()

    <i>-- volání uzávìru</i>
    for i = 1, 10 do
        print("iteration #" .. i)
        print("    mycounter(1):  " .. mycounter(1))
        print("    mycounter(10): " .. mycounter(10))
        print("    mycounter(-2): " .. mycounter(-2))
        print()
    <strong>end</strong>
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
main()
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Finito.</i>
<i>--</i>
</pre>



<p><a name="k082"></a></p>
<h3 id="k082">8.2 Pøeklad pøíkladu <strong>test39.lua</strong> do mezijazyka LuaJITu</h3>

<pre>
<i>; Pøeklad demonstraèního pøíkladu test39.lua</i>
<i>; do IR vyu¾ívaného virtuálním strojem a JIT</i>
&nbsp;
&nbsp;
&nbsp;
<i>; metadata se základními informacemi o zdrojovém kódu,</i>
<i>; který byl pou¾it pro vygenerování tohoto IR</i>
-- BYTECODE -- test39.lua:17-22
&nbsp;
&nbsp;
&nbsp;
<i>; implementace uzávìru</i>
<i>; counter = counter + 1</i>
0001    <strong>UGET</strong>     1   0        <i>; pøeètení hodnoty externí vázané promìnné counter</i>
0002    <strong>ADDVV</strong>    1   1   0    <i>; pøiètení jednièky</i>
0003    <strong>USETV</strong>    0   1        <i>; zápis hodnoty externí vázané promìnné counter</i>
0004    <strong>UGET</strong>     1   0        <i>; pøeètení hodnoty externí vázané promìnné counter</i>
<i>; return counter</i>
0005    <strong>RET1</strong>     1   2        <i>; vrácení nové hodnoty</i>
&nbsp;
&nbsp;
&nbsp;
<i>; metadata se základními informacemi o zdrojovém kódu,</i>
<i>; který byl pou¾it pro vygenerování tohoto IR</i>
-- BYTECODE -- test39.lua:10-23
&nbsp;
&nbsp;
&nbsp;
<i>; implementace funkce createCounter()</i>
<i>; local counter = 0</i>
0001    <strong>KSHORT</strong>   0   0        <i>; nastavení hodnoty lokální promìnné counter</i>
<i>; return function()</i>
0002    <strong>FNEW</strong>     1   0        <i>; vytvoøení uzávìru</i>
0003    <strong>UCLO</strong>     0 =&gt; 0004
0004 =&gt; <strong>RET1</strong>     1   2        <i>; vrácení uzávìru</i>
&nbsp;
&nbsp;
&nbsp;
<i>; metadata se základními informacemi o zdrojovém kódu,</i>
<i>; který byl pou¾it pro vygenerování tohoto IR</i>
-- BYTECODE -- test39.lua:30-44
<i>; implementace funkce main()</i>
&nbsp;
&nbsp;
&nbsp;
<i>; local mycounter = createCounter()</i>
0001    <strong>GGET</strong>     0   0        <i>; získat referenci na funkci "createCounter"</i>
0002    <strong>CALL</strong>     0   2   1    <i>; volání funkce "createCounter"</i>
&nbsp;
&nbsp;
<i>; pøíprava poèítané programové smyèky for</i>
0003    <strong>KSHORT</strong>   1   1
0004    <strong>KSHORT</strong>   2  10
0005    <strong>KSHORT</strong>   3   1
0006    <strong>FORI</strong>     1 =&gt; 0036
&nbsp;
<i>; tìlo poèítané programové smyèky for</i>
&nbsp;
<i>; print("iteration #" .. i)</i>
0007 =&gt; <strong>GGET</strong>     5   1        <i>; "print"</i>
0008    <strong>KSTR</strong>     6   2        <i>; "iteration #"</i>
0009    <strong>MOV</strong>      7   4
0010    <strong>CAT</strong>      6   6   7    <i>; spojení øetìzcù</i>
0011    <strong>CALL</strong>     5   1   2
&nbsp;
<i>; print("    counter1: " .. counter1())</i>
0012    <strong>GGET</strong>     5   1        <i>; "print"</i>
0013    <strong>KSTR</strong>     6   3        <i>; "    mycounter(1):  "</i>
0014    <strong>MOV</strong>      7   0
0015    <strong>KSHORT</strong>   8   1
0016    <strong>CALL</strong>     7   2   2    <i>; volání uzávìru</i>
0017    <strong>CAT</strong>      6   6   7    <i>; spojení øetìzcù</i>
0018    <strong>CALL</strong>     5   1   2    <i>; volání funkce "print"</i>
&nbsp;
<i>; print("    counter2: " .. counter2())</i>
0019    <strong>GGET</strong>     5   1        <i>; "print"</i>
0020    <strong>KSTR</strong>     6   4        <i>; "    mycounter(10): "</i>
0021    <strong>MOV</strong>      7   0
0022    <strong>KSHORT</strong>   8  10
0023    <strong>CALL</strong>     7   2   2    <i>; volání uzávìru</i>
0024    <strong>CAT</strong>      6   6   7    <i>; spojení øetìzcù</i>
0025    <strong>CALL</strong>     5   1   2    <i>; volání funkce print</i>
&nbsp;
0026    <strong>GGET</strong>     5   1        <i>; "print"</i>
0027    <strong>KSTR</strong>     6   5        <i>; "    mycounter(-2): "</i>
0028    <strong>MOV</strong>      7   0
0029    <strong>KSHORT</strong>   8  -2
0030    <strong>CALL</strong>     7   2   2    <i>; volání funkce "print"</i>
&nbsp;
0031    <strong>CAT</strong>      6   6   7    <i>; spojení øetìzcù</i>
0032    <strong>CALL</strong>     5   1   2    <i>; volání funkce "print"</i>
&nbsp;
0033    <strong>GGET</strong>     5   1        <i>; "print"</i>
0034    <strong>CALL</strong>     5   1   1    <i>; volání funkce "print"</i>
&nbsp;
<i>; konec tìla programové smyèky for</i>
0035    <strong>FORL</strong>     1 =&gt; 0007
&nbsp;
<i>; návrat z funkce</i>
0036 =&gt; <strong>RET0</strong>     0   1        <i>; návrat z funkce "main"</i>
&nbsp;
&nbsp;
&nbsp;
<i>; metadata se základními informacemi o zdrojovém kódu,</i>
<i>; který byl pou¾it pro vygenerování tohoto IR</i>
-- BYTECODE -- test39.lua:0-56
&nbsp;
&nbsp;
&nbsp;
<i>; inicializace a volání funkce main</i>
0001    <strong>FNEW</strong>     0   0        <i>; vytvoøení funkce z definice na øádku test39.lua:10</i>
0002    <strong>GSET</strong>     0   1        <i>; zápis "createCounter" do globální tabulky</i>
0003    <strong>FNEW</strong>     0   2        <i>; vytvoøení funkce z definice na øádku test39.lua:30</i>
0004    <strong>GSET</strong>     0   3        <i>; zápis "main" do globální tabulky</i>
0005    <strong>GGET</strong>     0   3        <i>; "main"</i>
0006    <strong>CALL</strong>     0   1   1    <i>; volání funkce "main"</i>
&nbsp;
<i>; ka¾dý program je automaticky ukonèen následující instrukcí</i>
0007    <strong>RET0</strong>     0   1
&nbsp;
<i>; konec</i>
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Zdrojové kódy v¹ech pìti dne¹ních demonstraèních pøíkladù</h2>

<p>V&nbsp;dne¹ní èásti i v&nbsp;¹esti pøedchozích èástech èlánku o LuaJITu jsme
si øekli v¹echny podstatné informace o zpùsobu pøekladu zdrojových kódù
naprogramovaných v&nbsp;jazyku <i>Lua</i> do mezijazyka <i>LuaJITu</i>. Ve
skuteènosti v¹ak tento pøeklad není z&nbsp;programátorského hlediska pøíli¹
zajímavý, nebo» je zalo¾en na pøedpøipravených ¹ablonách. Mnohem zajímavìj¹í a
takté¾ slo¾itìj¹í je zpùsob just-in-time pøekladu z&nbsp;mezijazyka
<i>LuaJITu</i> do strojového kódu konkrétního typu mikroprocesoru. Tento
pøeklad ji¾ musí brát v&nbsp;úvahu jak rozdíly mezi jednotlivými typy
instrukèních sad (i386, x86_64, ARM, ...), tak i poèet pou¾itelných pracovních
registrù, adresovací re¾imy (a jejich efektivitu), zpùsob pøedávání parametrù
volaným subrutinám atd. Navíc se ji¾ od dob prvních JIT pøekladaèù ukazuje, ¾e
pomìrnì velkou èást kódu reálných aplikací ani nemá cenu slo¾itì pøekládat, ale
postaèuje interpretace. Pouze èasto volané funkce a samozøejmì té¾ programové
smyèky (speciálnì vnoøené smyèky) se &bdquo;JITují&ldquo;. Pøí¹tì si uká¾eme,
jak je tato problematika øe¹ená v&nbsp;<i>LuaJITu</i>.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Obsah dal¹ích èástí tohoto seriálu</h2>

<p>V¹echny dnes pou¾ité demonstraèní pøíklady byly, jak je tomu ostatnì
v&nbsp;tomto seriálu ji¾ dlouhodobìj¹ím zvykem, ulo¾eny do Git (pøesnìji øeèeno
do <a href="http://github.com/">GitHub</a>) repositáøe umístìného na adrese <a
href="https://github.com/tisnik/luajit-examples">https://github.com/tisnik/luajit-examples</a>:</p>

<table>
<tr><th> #</th><th>Zdrojový kód</th><th>Umístìní</th></tr>
<tr><td> 1</td><td>test35.lua</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/src/test35.lua">https://github.com/tisnik/luajit-examples/blob/master/src/test35.lua</a></td></tr>
<tr><td> 2</td><td>test36.lua</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/src/test36.lua">https://github.com/tisnik/luajit-examples/blob/master/src/test36.lua</a></td></tr>
<tr><td> 3</td><td>test37.lua</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/src/test37.lua">https://github.com/tisnik/luajit-examples/blob/master/src/test37.lua</a></td></tr>
<tr><td> 4</td><td>test38.lua</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/src/test38.lua">https://github.com/tisnik/luajit-examples/blob/master/src/test38.lua</a></td></tr>
<tr><td> 5</td><td>test39.lua</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/src/test39.lua">https://github.com/tisnik/luajit-examples/blob/master/src/test39.lua</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>test35.asm</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/asm/test35.asm">https://github.com/tisnik/luajit-examples/blob/master/asm/test35.asm</a></td></tr>
<tr><td> 7</td><td>test36.asm</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/asm/test36.asm">https://github.com/tisnik/luajit-examples/blob/master/asm/test36.asm</a></td></tr>
<tr><td> 8</td><td>test37.asm</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/asm/test37.asm">https://github.com/tisnik/luajit-examples/blob/master/asm/test37.asm</a></td></tr>
<tr><td> 9</td><td>test38.asm</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/asm/test38.asm">https://github.com/tisnik/luajit-examples/blob/master/asm/test38.asm</a></td></tr>
<tr><td>10</td><td>test39.asm</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/asm/test39.asm">https://github.com/tisnik/luajit-examples/blob/master/asm/test39.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>Makefile</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/Makefile">https://github.com/tisnik/luajit-examples/blob/master/Makefile</a></td></tr>
</table>



<p><a name="k11"></a></p>
<h2 id="k11">11. Seznam v¹ech popsaných instrukcí mezijazyka LuaJITu</h2>

<p>Na závìr si je¹tì uvedeme tabulku se v¹emi doposud popsanými instrukcemi
mezijazyka <i>LuaJITu</i>. Pøipomeòme si, ¾e IR pou¾ívá takzvaný tøíadresový
kód a instrukce o pevné ¹íøce tøiceti dvou bitù. Pøístup k&nbsp;instrukcím je
tedy obecnì mnohem rychlej¹í, ne¾ pøi pou¾ití instrukcí promìnné délky, tak
jako je tomu v&nbsp;JVM. Existují dva formáty instrukcí, pøesnìji øeèeno dva
zpùsoby rozdìlení 32bitového slova na jednotlivá bitová pole. V&nbsp;obou
formátech má operaèní kód instrukce ¹íøku osmi bitù, obsazení dal¹ích 24 bitù
je v¹ak odli¹né.</p>



<p><a name="k111"></a></p>
<h3 id="k111">11.1 První formát instrukcí</h3>

<p>První formát se pou¾ívá u instrukcí s&nbsp;trojicí operandù. Typické pou¾ití
tohoto formátu je u aritmetických instrukcí:</p>

<table>
<tr><th>Oznaèení</th><th>©íøka (bitù)</th><th>Popis</th></tr>
<tr><td>B</td><td>8</td><td>první vstupní operand (zdrojová promìnná)</td></tr>
<tr><td>C</td><td>8</td><td>druhý vstupní operand (zdrojová promìnná, numerická konstanta atd.)</td></tr>
<tr><td>A</td><td>8</td><td>výsledek operace (promìnná pro ulo¾ení výsledku)</td></tr>
<tr><td>OP</td><td>8</td><td>operaèní kód instrukce</td></tr>
<tr><td>Celkem</td><td>32</td><td>&nbsp;</td></tr>
</table>



<p><a name="k112"></a></p>
<h3 id="k112">11.2 Druhý formát instrukcí</h3>

<p>Druhý formát, resp.&nbsp;instrukce pou¾ívající druhý formát doká¾ou
adresovat pouze dva operandy, ov¹em operand oznaèený písmenem
<strong>D</strong> má ¹íøku ¹estnáct bitù a lze ho v&nbsp;nìkterých instrukcích
pou¾ít napøíklad k&nbsp;pøímému ulo¾ení ¹estnáctibitové celoèíselné konstanty
se znaménkem (srov.&nbsp;s&nbsp;pomìrnì velkým mno¾stvím instrukcí
v&nbsp;bajtkódu JVM, které se pokou¹í o toté¾, ale mnohem komplikovanìj¹ím
zpùsobem):</p>

<table>
<tr><th>Oznaèení</th><th>©íøka (bitù)</th><th>Popis</th></tr>
<tr><td>D</td><td>16</td><td>vstupní operand (zdrojová promìnná)</td></tr>
<tr><td>A</td><td>8</td><td>první operand nebo promìnná pro ulo¾ení výsledku</td></tr>
<tr><td>OP</td><td>8</td><td>operaèní kód instrukce</td></tr>
<tr><td>Celkem</td><td>32</td><td>&nbsp;</td></tr>
</table>



<p><a name="k113"></a></p>
<h3 id="k113">11.3 Seznam instrukcí</h3>

<p>Nyní ji¾ následuje slíbená tabulka se seznamem instrukcí IR LuaJITu:</p>

<table>
<tr><th> #</th><th>Instrukce </th><th>Operandy</th><th>Popis</th></tr>
<tr><td> 1</td><td>KNIL      </td><td>base, base </td><td>nastaví sloty èíslo A a¾ D na hodnotu <strong>nil</strong></td></tr>
<tr><td> 2</td><td>KPRI      </td><td>dest, pri  </td><td>nastaví <i>dest</i> na hodnotu specifikovanou v D</td></tr>
<tr><td> 3</td><td>KSHORT    </td><td>dest, lits </td><td>pøenese do <i>dest</i> ¹estnáctibitovou celoèíselnou konstantu</td></tr>
<tr><td> 4</td><td>KNUM      </td><td>dest, num  </td><td>pøenese do <i>dest</i> zvolenou numerickou konstantu</td></tr>
<tr><td> 5</td><td>KSTR      </td><td>dest, str  </td><td>pøenese do <i>dest</i> zvolený øetìzec</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>ADDVV     </td><td>slot, slot</td><td>aritmetická operace: souèet</td></tr>
<tr><td> 7</td><td>SUBVV     </td><td>slot, slot</td><td>aritmetická operace: rozdíl</td></tr>
<tr><td> 8</td><td>MULVV     </td><td>slot, slot</td><td>aritmetická operace: souèin</td></tr>
<tr><td> 9</td><td>DIVVV     </td><td>slot, slot</td><td>aritmetická operace: podíl</td></tr>
<tr><td>10</td><td>MODVV     </td><td>slot, slot</td><td>aritmetická operace: podíl modulo</td></tr>
<tr><td>11</td><td>ADDVN     </td><td>slot, num </td><td>aritmetická operace s&nbsp;numerickou konstantou: souèet</td></tr>
<tr><td>12</td><td>SUBVN     </td><td>slot, num </td><td>aritmetická operace s&nbsp;numerickou konstantou: rozdíl</td></tr>
<tr><td>13</td><td>MULVN     </td><td>slot, num </td><td>aritmetická operace s&nbsp;numerickou konstantou: souèin</td></tr>
<tr><td>14</td><td>DIVVN     </td><td>slot, num </td><td>aritmetická operace s&nbsp;numerickou konstantou: podíl</td></tr>
<tr><td>15</td><td>MODVN     </td><td>slot, num </td><td>aritmetická operace s&nbsp;numerickou konstantou: podíl modulo</td></tr>
<tr><td>16</td><td>ADDNV     </td><td>slot, num </td><td>aritmetická operace s&nbsp;numerickou konstantou: souèet (otoèené operandy)</td></tr>
<tr><td>17</td><td>SUBNV     </td><td>slot, num </td><td>aritmetická operace s&nbsp;numerickou konstantou: rozdíl</td></tr>
<tr><td>18</td><td>MULNV     </td><td>slot, num </td><td>aritmetická operace s&nbsp;numerickou konstantou: souèin</td></tr>
<tr><td>19</td><td>DIVNV     </td><td>slot, num </td><td>aritmetická operace s&nbsp;numerickou konstantou: podíl</td></tr>
<tr><td>20</td><td>MODNV     </td><td>slot, num </td><td>aritmetická operace s&nbsp;numerickou konstantou: podíl modulo</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>21</td><td>JMP       </td><td>adresa</td><td>nepodmínìný skok, popø.&nbsp;podmínìný skok, pokud mu pøedchází instrukce I*</td></tr>
<tr><td>22</td><td>IST       </td><td>slot</td><td>následuje skok provedený pøi splnìní podmínky A = true</td></tr>
<tr><td>23</td><td>ISF       </td><td>slot</td><td>následuje skok provedený pøi splnìní podmínky A = false</td></tr>
<tr><td>24</td><td>ISLT      </td><td>slot, slot</td><td>následuje skok provedený pøi splnìní podmínky A &lt; D</td></tr>
<tr><td>25</td><td>ISGE      </td><td>slot, slot</td><td>následuje skok provedený pøi splnìní podmínky A &ge; D</td></tr>
<tr><td>26</td><td>ISLE      </td><td>slot, slot</td><td>následuje skok provedený pøi splnìní podmínky A &le; D</td></tr>
<tr><td>27</td><td>ISGT      </td><td>slot, slot</td><td>následuje skok provedený pøi splnìní podmínky A &gt; D</td></tr>
<tr><td>28</td><td>ISEQV     </td><td>slot, slot</td><td>následuje skok provedený pøi splnìní podmínky A = D   </td></tr>
<tr><td>29</td><td>ISNEV     </td><td>slot, slot</td><td>následuje skok provedený pøi splnìní podmínky A &ne; D</td></tr>
<tr><td>30</td><td>ISEQN     </td><td>slot, konstanta</td><td>následuje skok provedený pøi splnìní podmínky A = konstanta</td></tr>
<tr><td>31</td><td>ISNEN     </td><td>slot, konstanta</td><td>následuje skok provedený pøi splnìní podmínky A &ne; konstanta</td></tr>
<tr><td>32</td><td>ISEQP     </td><td>slot, pri</td><td>následuje skok provedený pøi splnìní podmínky A = pri_type</td></tr>
<tr><td>33</td><td>ISNEP     </td><td>slot, pri</td><td>následuje skok provedený pøi splnìní podmínky A &ne; pri_type</td></tr>
<tr><td>34</td><td>ISEQS     </td><td>slot, string</td><td>následuje skok provedený pøi splnìní podmínky A = string</td></tr>
<tr><td>34</td><td>ISNES     </td><td>slot, string</td><td>následuje skok provedený pøi splnìní podmínky A &ne; string</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>35</td><td>MOV       </td><td>kopie dat z D do A</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>36</td><td>TNEW      </td><td>dst, lit</td><td>vytvoøení nové tabulky o velikosti specifikované v D (lit), reference na vytvoøenou tabulku se ulo¾í do A (dst)</td></tr>
<tr><td>37</td><td>TDUP      </td><td>dst, tab</td><td>vytvoøení nové tabulky na základì ¹ablony specifikované v D (tab), reference na vytvoøenou tabulku se ulo¾í do A (dst)</td></tr>
<tr><td>38</td><td>GGET      </td><td>dst, str</td><td>pøeètení prvku z globální tabulky _G, v D (str) je ulo¾en klíè (øetìzec)</td></tr>
<tr><td>39</td><td>GSET      </td><td>var, str</td><td>zápis prvku do globální tabulky _G, v D (str) je ulo¾en klíè (øetìzec)</td></tr>
<tr><td>40</td><td>TGETV     </td><td>dst, var, var</td><td>ètení prvku z tabulky specifikované v B, klíè je ulo¾en v promìnné</td></tr>
<tr><td>41</td><td>TGETS     </td><td>dst, var, str</td><td>ètení prvku z tabulky specifikované v B, klíèem je øetìzec</td></tr>
<tr><td>42</td><td>TGETB     </td><td>dst, var, lit</td><td>ètení prvku z tabulky specifikované v B, klíèem je literál (konstanta, typicky celé èíslo)</td></tr>
<tr><td>43</td><td>TSETV     </td><td>var, var, var</td><td>zápis prvku do tabulky specifikované v B, klíè je ulo¾en v promìnné</td></tr>
<tr><td>44</td><td>TSETS     </td><td>var, var, str</td><td>zápis prvku do tabulky specifikované v B, klíèem je øetìzec</td></tr>
<tr><td>45</td><td>TSETB     </td><td>var, var, lit</td><td>zápis prvku do tabulky specifikované v B, klíèem je literál (konstanta, typicky celé èíslo)</td></tr>
<tr><td>46</td><td>TSETM     </td><td>base, num*</td><td>nastavení vìt¹ího mno¾ství prvkù dle vztahu: (A-1)[D], (A-1)[D+1], ... = A, A+1, ...</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>47</td><td>FNEW      </td><td>dst, func     </td><td>vytvoøení uzávìru (closure) z prototypu funkce</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>48</td><td>CALL      </td><td>base, lit, lit</td><td>volání funkce s pøedáním parametrù (standardní forma volání)</td></tr>
<tr><td>49</td><td>CALLM     </td><td>base, lit, lit</td><td>volání funkce s pøedáním parametrù (speciální forma volání)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>50</td><td>RET0      </td><td>A, D          </td><td>návrat z funkce bez pøedání návratového hodnoty (A a D se ignorují)</td></tr>
<tr><td>51</td><td>RET1      </td><td>A, D          </td><td>návrat z funkce s pøedáním jedné návratové hodnoty A (D se ignoruje)</td></tr>
<tr><td>52</td><td>RET       </td><td>A, D          </td><td>návrat z funkce s pøedáním jedné návratových hodnot A, A+1, ... A+D-2</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>53</td><td>FORI      </td><td>A, D          </td><td>test i&le;max pro krok&ge;0 èi i&ge;min pro krok&lt;0<br />
            skok ZA tìlo smyèky pøi nesplnìní této podmínky</td></tr>
<tr><td>54</td><td>FORL      </td><td>A, D          </td><td>i=i+krok<br />
            test i&le;max pro krok&ge;0 èi i&ge;min pro krok&lt;0<br />
            skok na zaèátek smyèky pøi splnìní této podmínky</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>55</td><td>ITERC     </td><td>base, lit, lit</td><td>volání iterátoru A s&nbsp;parametry v A+1 a A+2</td></tr>
<tr><td>56</td><td>ITERN     </td><td>base, lit, lit</td><td>varianta instrukce ITERC pro funkci next() èi pairs()</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>57</td><td>LOOP      </td><td>rbase, jump</td><td>pou¾ití pøi JITování a detekci hot-spotù, neprovádí se skok!</td></tr>
<tr><td>58</td><td>ITERL     </td><td>base, jump</td><td>iterátor pro smyèku typu for-each, kontrola na hodnotu odli¹nou od nil a podmínìný skok</td></tr>
<tr><td>59</td><td>ISNEXT    </td><td>base, jump</td><td>pou¾ito se speciální instrukcí ITERN pro podmínìný skok</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>60</td><td>FNEW      </td><td></td><td>vytvoøení nového uzávìru</td></tr>
<tr><td>61</td><td>UCLO      </td><td></td><td>uzavøení (navázání) externích promìnných k funkci</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>62</td><td>UGET      </td><td></td><td>pøeètení hodnoty externí vázané promìnné</td></tr>
<tr><td>62</td><td>USETV     </td><td></td><td>zápis nové hodnoty externí vázané promìnné</td></tr>
<tr><td>63</td><td>USETS     </td><td></td><td>zápis øetìzce do externí vázané promìnné</td></tr>
<tr><td>64</td><td>USETN     </td><td></td><td>zápis èísla do externí vázané promìnné</td></tr>
<tr><td>65</td><td>USETP     </td><td></td><td>zápis vybrané primitivní hodnoty do externí vázané promìnné</td></tr>
</table>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>Wikipedia: Mezijazyk<br />
<a href="http://cs.wikipedia.org/wiki/Mezijazyk">http://cs.wikipedia.org/wiki/Mezijazyk</a>
</li>

<li>The LuaJIT Project<br />
<a href="http://luajit.org/index.html">http://luajit.org/index.html</a>
</li>

<li>LuaJIT FAQ<br />
<a href="http://luajit.org/faq.html">http://luajit.org/faq.html</a>
</li>

<li>LuaJIT Performance Comparison<br />
<a href="http://luajit.org/performance.html">http://luajit.org/performance.html</a>
</li>

<li>LuaJIT 2.0 intellectual property disclosure and research opportunities<br />
<a href="http://article.gmane.org/gmane.comp.lang.lua.general/58908">http://article.gmane.org/gmane.comp.lang.lua.general/58908</a>
</li>

<li>LuaJIT Wiki<br />
<a href="http://wiki.luajit.org/Home">http://wiki.luajit.org/Home</a>
</li>

<li>LuaJIT 2.0 Bytecode Instructions<br />
<a href="http://wiki.luajit.org/Bytecode-2.0">http://wiki.luajit.org/Bytecode-2.0</a>
</li>

<li>Programming in Lua 9.1 &ndash; Coroutine Basics,<br />
<a href="http://www.lua.org/pil/9.1.html">http://www.lua.org/pil/9.1.html</a>
</li>

<li>Programming in Lua (first edition)<br />
<a href="http://www.lua.org/pil/contents.html">http://www.lua.org/pil/contents.html</a>
</li>

<li>Programming in Lua: 6 - More about Functions<br />
<a href="http://www.lua.org/pil/6.html">http://www.lua.org/pil/6.html</a>
</li>

<li>Lua Lanes<br />
<a href="http://kotisivu.dnainternet.net/askok/bin/lanes/">http://kotisivu.dnainternet.net/askok/bin/lanes/</a>
</li>

<li>Programming in Lua: 6.1 - Closures<br />
<a href="http://www.lua.org/pil/6.1.html">http://www.lua.org/pil/6.1.html</a>
</li>

<li>Programming in Lua: 9.1 - Coroutine Basics<br />
<a href="http://www.lua.org/pil/9.1.html">http://www.lua.org/pil/9.1.html</a>
</li>

<li>Programming in Lua: Numeric for<br />
<a href="http://www.lua.org/pil/4.3.4.html">http://www.lua.org/pil/4.3.4.html</a>
</li>

<li>Programming in Lua: break and return<br />
<a href="http://www.lua.org/pil/4.4.html">http://www.lua.org/pil/4.4.html</a>
</li>

<li>Programming in Lua: Tables<br />
<a href="http://www.lua.org/pil/2.5.html">http://www.lua.org/pil/2.5.html</a>
</li>

<li>Programming in Lua: Table Constructors<br />
<a href="http://www.lua.org/pil/3.6.html">http://www.lua.org/pil/3.6.html</a>
</li>

<li>Programovací jazyk Lua<br />
<a href="http://palmknihy.cz/web/kniha/programovaci-jazyk-lua-12651.htm">http://palmknihy.cz/web/kniha/programovaci-jazyk-lua-12651.htm</a>
</li>

<li>Lua: Tables Tutorial<br />
<a href="http://lua-users.org/wiki/TablesTutorial">http://lua-users.org/wiki/TablesTutorial</a>
</li>

<li>Lua: Control Structure Tutorial<br />
<a href="http://lua-users.org/wiki/ControlStructureTutorial">http://lua-users.org/wiki/ControlStructureTutorial</a>
</li>

<li>Lua Types Tutorial<br />
<a href="http://lua-users.org/wiki/LuaTypesTutorial">http://lua-users.org/wiki/LuaTypesTutorial</a>
</li>

<li>Goto Statement in Lua<br />
<a href="http://lua-users.org/wiki/GotoStatement">http://lua-users.org/wiki/GotoStatement</a>
</li>

<li>Lua 5.2 sources<br />
<a href="http://www.lua.org/source/5.2/">http://www.lua.org/source/5.2/</a>
</li>

<li>Lua 5.2 sources - lopcodes.h<br />
<a href="http://www.lua.org/source/5.2/lopcodes.h.html">http://www.lua.org/source/5.2/lopcodes.h.html</a>
</li>

<li>Lua 5.2 sources - lopcodes.c<br />
<a href="http://www.lua.org/source/5.2/lopcodes.c.html">http://www.lua.org/source/5.2/lopcodes.c.html</a>
</li>

<li>Lambda the Ultimate: Coroutines in Lua,<br />
<a href="http://lambda-the-ultimate.org/node/438">http://lambda-the-ultimate.org/node/438</a>
</li>

<li>Coroutines Tutorial,<br />
<a href="http://lua-users.org/wiki/CoroutinesTutorial">http://lua-users.org/wiki/CoroutinesTutorial</a>
</li>

<li>Lua Coroutines Versus Python Generators,<br />
<a href="http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators">http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2014</small></p>
</body>
</html>

