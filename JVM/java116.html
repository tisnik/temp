<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - slo¾itìj¹í tìlesa, textury a sprity v knihovnì SDLJava</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - slo¾itìj¹í tìlesa, textury a sprity v knihovnì SDLJava</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o virtuálním stroji Javy si øekneme, jak lze v knihovnì SDLJava obejít funkce glBegin a glEnd z OpenGL (které ji¾ nejsou v OpenGL 3.1 a OpenGL ES oficiálnì podporovány) pomocí polí vrcholù (vertex arrays). Seznámíme se takté¾ s u¾iteènou tøídou Sprite vyu¾itelnou nejenom v poèítaèových hrách.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - slo¾itìj¹í tìlesa, textury a sprity v knihovnì SDLJava</a></p>
<p><a href="#k02">2. Pole vrcholù</a></p>
<p><a href="#k03">3. Vytvoøení pole vrcholù</a></p>
<p><a href="#k04">4. ByteBuffer versus pole v&nbsp;Javì</a></p>
<p><a href="#k05">5. Výbìr prvkù z&nbsp;pole/bufferu a pøenos jednotlivých vrcholù na grafický akcelerátor</a></p>
<p><a href="#k06">6. Demonstraèní pøíklad <strong>SDLTest17</strong> &ndash; pou¾ití metody <strong>glArrayElement()</strong></a></p>
<p><a href="#k07">7. Demonstraèní pøíklad <strong>SDLTest18</strong> &ndash; pou¾ití metody <strong>glDrawArrays()</strong></a></p>
<p><a href="#k08">8. Objekt typu <strong>Sprite</strong> v&nbsp;knihovnì SDLJava</a></p>
<p><a href="#k09">9. Demonstraèní pøíklad <strong>SDLTest19</strong> &ndash; texturování a objekt typu <strong>Sprite</strong></a></p>
<p><a href="#k10">10. Repositáø se zdrojovými kódy v¹ech tøí dne¹ních demonstraèních pøíkladù</a></p>
<p><a href="#k11">11. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - slo¾itìj¹í tìlesa, textury a sprity v knihovnì SDLJava</h2>

<p>V&nbsp;pøedchozí èásti tohoto seriálu jsme si øekli, ¾e pomocí grafické
knihovny OpenGL a SDLJava je mo¾né vykreslovat pouze nìkolik základních
grafických prvkù &ndash; <i>grafických primitiv</i>. Ve¹keré slo¾itìj¹í tvary
tìles se musí slo¾it z&nbsp;tìchto grafických primitiv, co¾ ve vìt¹inì pøípadù
pøi zobrazování trojrozmìrných scén znamená vyu¾ití trojúhelníkù a
ètyøúhelníkù. Kromì obecných vlastností tìchto prvkù je v&nbsp;nìkterých
pøípadech zapotøebí zadávat i vlastnosti jednotlivých vrcholù. Mezi tyto
vlastnosti, které se typicky nastavují uvnitø takzvaných &bdquo;programových
závorek&ldquo; <strong>glBegin()</strong> a <strong>glEnd()</strong>,
patøí:</p>

<ul>

<li>Pozice vrcholu (vertexu) v&nbsp;rovinì èi prostoru. Nastavuje se metodou
<strong>GL.glVertex*()</strong>, pøièem¾ lze zadat dvì souøadnice (rovina), tøi
souøadnice (prostor) nebo ètyøi souøadnice (prostor+&bdquo;váha&ldquo; vrcholu
reprezentovaná ètvrtou souøadicí).</li>

<li>Barva vrcholu, která se nastavuje metodou <strong>GL.glColor*()</strong>.
Barva plo¹ky mezi vrcholy (stejnì jako nìkteré dal¹í parametry) mù¾e být
dopoèítána pomocí interpolace.</li>

<li>Index barvy vrcholu v&nbsp;barvové paletì, který se nastavuje metodou
<strong>GL.glIndex*()</strong>. Barvové palety a indexované barvy byly do
knihovny OpenGL zaøazeny pro podporu vykreslování na star¹ích grafických
subsystémech, které nepodporovaly re¾im True-Color. V&nbsp;dne¹ní dobì v¹ak
ztratily smysl (kromì diskutabilní animace pomocí zmìny jednotlivých barev) a
pøestávají být také v&nbsp;nových grafických kartách podporovány, proto se jimi
dále nebudeme zabývat (od OpenGL 3.1 u¾ ani tato vlastnost oficiálnì není
v&nbsp;základním re¾imu povolena, tuto vlastnost nemá smysl hledat ani v OpenGL
ES 1.x/ES 2.x apod., co¾ je mo¾ná je¹tì dùle¾itìj¹í, pøedev¹ím pro vývojáøe
aplikací pro tablety apod.).</li>

<li>Normálový vektor ve vrcholu, který se nastavuje metodou
<strong>GL.glNormal*()</strong>. Normála (tj.&nbsp;vektor kolmý k&nbsp;povrchu)
vrcholu je sice z&nbsp;matematického hlediska nesmysl, ale v&nbsp;poèítaèové
grafice se normály rovin, které se ve vrcholech stýkají, seèítají a výsledek se
pou¾ívá napøíklad pøi výpoètech osvìtlení.</li>

<li>Souøadnice do textury, která se nastavuje metodou
<strong>GL.glTexCoord()</strong>. Tato souøadnice se pou¾ívá pøi texturování,
kterým se budeme podrobnìji zabývat v&nbsp;následujících kapitolách.</li>

<li>Mapovací souøadnice zadávaná metodou
<strong>GL.glEvalCoord*()</strong>.</li>

<li>Jednorozmìrný èi dvourozmìrný bod v&nbsp;síti (<i>mesh</i>), který se
zadává metodou <strong>GL.glEvalPoint*()</strong>.</li>

<li>Optické vlastnosti materiálu zadané metodou
<strong>GL.glMaterial()</strong>.</li>

<li>Vlastnosti hrany (tj.&nbsp;zda má být hrana viditelná èi nikoliv)
nastavované metodou <strong>GL.glEdgeFlag()</strong>.</li>

</ul>



<p><a name="k02"></a></p>
<h2 id="k02">2. Pole vrcholù</h2>

<p>Vlastnosti jednotlivých vrcholù se v&nbsp;nejjednodu¹¹ím pøípadì zadávají
pøímým voláním jednoduchých metod, napøíklad <strong>GL.glVertex*()</strong>,
<strong>GL.glColor*()</strong>, <strong>GL.glNormal*()</strong> a
<strong>glGL.Material*()</strong>. Toto øe¹ení je snadno pochopitelné i
pou¾itelné, jeho obrovskou nevýhodou v¹ak je, ¾e pro vykreslení slo¾itých
prostorových scén by se muselo tìchto funkcí volat nìkolik tisíc i desítek
tisíc (podle slo¾itosti tìchto scén, tj. poètu vrcholù).</p>

<p>Volání ka¾dé funkce s&nbsp;sebou nese pomìrnì znaèné mno¾ství práce pro
procesor, zejména pøesuny dat mezi registry procesoru, pamìtí a zásobníkem a
také skok do funkce a návrat z&nbsp;funkce (sní¾ení úèinnosti cache pamìti
z&nbsp;hlediska lokálnosti odkazù a pøepínání mezi ringy), nemluvì ji¾ o
nutnosti pou¾ívat <i>JNI</i> pøi volání tìchto nativních funkcí z&nbsp;Javy.
Proto by bylo vhodné co nejvíce sní¾it mno¾ství volání funkcí nutných pro
vykreslení dané scény. Existuje více mo¾ností vedoucích ke sní¾ení poètu
volaných funkcí, které se li¹í svou slo¾itostí, vyjadøovací schopností
(tj.&nbsp;které grafické efekty lze popø.&nbsp;naopak nelze vytvoøit) a
rychlostí vlastního vykreslení:</p>

<ol>

<li>První mo¾ností, která je pro pou¾ití nejjednodu¹¹í, je vyu¾ití faktu, ¾e se
OpenGL chová jako stavový automat, tj.&nbsp;pokud zadáme nìjakou vlastnost,
zùstane tato vlastnost nastavena a¾ do doby, ne¾ ji zmìníme.</li>

<li>Druhou mo¾ností je pou¾ití tìch grafických primitiv, u kterých se redukuje
poèet pøenesených vrcholù. Jedná se o ji¾ popsané <i>trsy</i> a <i>pruhy</i>
trojúhelníkù a o <i>pruh ètyøúhelníkù</i> (<i>triangle fan, triangle strip,
quad strip</i>). Redukce pøenesených vrcholù spoèívá v&nbsp;tom, ¾e vrcholy
spoleèné více hranám (a tím pádem i plo¹kám) jsou pøeneseny pouze jednou.</li>

<li>Tøetí mo¾ností je pou¾ití <i>display listù</i>, kdy se pøíkazy nutné pro
vytvoøení tìlesa ulo¾í do display listu a ten se poté zavolá pomocí jediné
funkce. Pøedností tohoto postupu je, ¾e data ulo¾ená v&nbsp;display listu jsou
v&nbsp;ideálním pøípadì zapsána pøímo do pamìti grafického akcelerátoru a pøi
ka¾dém vykreslení tedy není nutné tato data pøená¹et po sbìrnici, co¾ je
v&nbsp;dne¹ní dobì (se souèasnými sbìrnicemi a grafickými akcelerátory) nejvíce
zpomalující operace pøi vykreslování trojrozmìrných scén.</li>

<li>Ètvrtou mo¾ností, kterou se dnes budeme podrobnìji zabývat, je pou¾ití
takzvaného <i>pole vrcholù</i> (<i>vertex arrays</i>), kdy jsou data pro
jednotlivé vrcholy ulo¾ena ve vhodnì organizovaném poli a následnì je umo¾nìno
poslání dat vrcholù pomocí nìkolika málo funkèních volání. Nejvìt¹í pøedností
tohoto pøístupu je, ¾e se mezi jednotlivými snímky mohou mìnit data
jednotlivých vrcholù (barva, poloha apod.), co¾ v&nbsp;pøípadì display listù
nebylo mo¾né, proto¾e by se pøi jakékoliv zmìnì musel vytvoøit nový display
list.</li>

<li>Pøedchozí mo¾nost lze dále vylep¹it pou¾itím <i>Vertex Buffer Object
(VBO)</i> typu GL_STATIC_DRAW, co¾ jsou data ukládaná pøímo do pamìti
grafického akcelerátoru bez mo¾nosti je nìkdy mìnit (co¾ s&nbsp;sebou mù¾e
pøiná¹et jak výhody, tak i nevýhody).</li>

</ol>

<p>Pøi vývoji nových aplikací je takté¾ nutné mít na pamìti, ¾e v&nbsp;OpenGL
verze 3.0 u¾ je vykreslování s&nbsp;vyu¾itím &bdquo;pøíkazových závorek&ldquo;
<strong>glBegin</strong> a <strong>glEnd</strong> oznaèeno jako
<i>deprecated</i> a od OpenGL 3.1 u¾ nemusí být tyto vlastnosti v&nbsp;základní
variantì OpenGL vùbec podporovány. Jedná se samozøejmì o reakci na smìr vývoje
moderních grafických akcelerátorù a GPU, kde se namísto toho pou¾ívá funkcí
<strong>glDrawArrays</strong>, <strong>glDrawArraysInstanced</strong>,
<strong>glDrawElements</strong> atd.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Vytvoøení pole vrcholù</h2>

<p>Pøed prvním pou¾itím pole vrcholù v&nbsp;programu je zapotøebí pou¾ití pole
vrcholù povolit zavoláním metody
<strong>GL.glEnableClientState(array)</strong>, kde parametr <i>array</i> mù¾e
podle potøeby nabývat nìkolika hodnot:</p>

<ul>

<li><strong>GL.GL_COLOR_ARRAY</strong> &ndash; v&nbsp;poli je mo¾né mít ulo¾eny
RGB barvy vrcholù (pou¾ívá se v&nbsp;True-color RGB barevném re¾imu).</li>

<li><strong>GL.GL_INDEX_ARRAY</strong> &ndash; v&nbsp;poli je mo¾né mít ulo¾eny
indexové barvy vykreslování (pou¾ívá se paletovém barevném re¾imu, ji¾ vìt¹inou
nepodporováno).</li>

<li><strong>GL.GL_EDGE_FLAG_ARRAY</strong> &ndash; v&nbsp;poli je mo¾né mít
ulo¾eny pøíznaky hrany, tj. zda má být vykreslovaná hrana viditelná.</li>

<li><strong>GL.GL_NORMAL_ARRAY</strong> &ndash; v&nbsp;poli je mo¾né mít
ulo¾eny normálové vektory ve vrcholech.</li>

<li><strong>GL.GL_TEXTURE_COORD_ARRAY</strong> &ndash; v&nbsp;poli je mo¾né mít
ulo¾eny souøadnice do textury.</li>

<li><strong>GL.GL_VERTEX_ARRAY</strong> &ndash; v&nbsp;poli je mo¾né mít
ulo¾eny souøadnice vrcholù v&nbsp;rovinì èi prostoru.</li>

</ul>

<p>Pokud nìkteré z&nbsp;tìchto polí nebudeme chtít pou¾ít, je mo¾né zavolat
metodu <strong>GL.glDisableClientState(array)</strong>, kde parametr
<i>array</i> nabývá stejných hodnot jako u pøedchozí funkce. Stav povolení èi
zakázání nìkterého typu pole lze zjistit voláním metody
<strong>GL.glIsEnabled()</strong>.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. ByteBuffer versus pole v&nbsp;Javì</h2>

<p>Druhým krokem je vlastní vytvoøení pole vrcholù. Toto pole se musí naplnit
relevantními daty a poté pøedat knihovnì OpenGL ukazatel na toto pole. To se
v&nbsp;pøípadì nativního rozhraní OpenGL provede pøíkazem
<strong>gl*Pointer()</strong>, kde se za znak <strong>*</strong> doplní typ
pole. To znamená, ¾e podle typu ulo¾ených dat existují funkce:<br>
<strong>glVertexPointer()</strong>,<br>
<strong>glColorPointer()</strong>,<br>
<strong>glIndexPointer()</strong>,<br>
<strong>glNormalPointer()</strong>,<br>
<strong>glTexCoordPointer()</strong> a<br>
<strong>glEdgeFlagPointer()</strong>.</p>

<p>V&nbsp;pøípadì pou¾ití knihovny SDLJava v¹ak samozøejmì není mo¾né
specifikovat ukazatel na pole a dokonce pro ulo¾ení dat o jednotlivých
vrcholech <i>nelze pou¾ít Javovská pole</i>, a to z&nbsp;toho dùvodu, ¾e tato
pole mohou být kdykoli v&nbsp;pamìti pøemístìna pøi spu¹tìní správce pamìti.
Z&nbsp;tohoto dùvodu pou¾ívá knihovna SDLJava tøídu
<strong>java.nio.ByteBuffer</strong>, proto¾e zde je pøi alokaci zaruèeno, ¾e
se vytvoøený buffer (internì pole) nebude pøesouvat pøi zavolání GC. To
znamená, ¾e pøedchozí céèkové funkce <strong>gl*Pointer()</strong> se pøi
pou¾ití knihovny SDLJava sice stále jmenují <strong>GL.gl*Pointer</strong>, ale
posledním parametrem tìchto metod je ve skuteènosti reference na
ByteBuffer!</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Výbìr prvkù z&nbsp;pole/bufferu a zobrazení jednotlivých vrcholù</h2>

<p>Po povolení pou¾ití polí vrcholù a naplnìní tìchto polí je zapotøebí vhodným
zpùsobem vybrat prvky z&nbsp;pole a vykreslit jednotlivé vrcholy. Je nutné si
uvìdomit, ¾e pole zùstává ulo¾eno na stranì klienta (v&nbsp;pøípadì PC
v&nbsp;pamìti procesoru) do té doby, dokud poprvé nepøistoupíme k&nbsp;jeho
prvkùm. Poté jsou pole pøenesena na server (v&nbsp;pøípadì PC na grafický
akcelerátor, ale zde hodnì zále¾í na pou¾itém ovladaèi a velikosti volné pamìti
na grafickém akcelerátoru). Zmìníme-li pozdìji hodnoty v&nbsp;poli, musíme si
vynutit zaslání nového pole na server.</p>

<p>Prvky pole lze vybrat nìkolik rùznými zpùsoby:</p>

<ol>

<li>Po jednotlivých vrcholech metodou <strong>GL.glArrayElement(int
i)</strong>, která vybere data z&nbsp;<i>i</i>-tého prvku ze v¹ech zapnutých
polí. Zavolání této metody má stejný efekt jako volání metody
<strong>GL.glVertex()</strong>, <strong>GL.glColor()</strong> atd. Tento zpùsob
se jako jediný pou¾ívá mezi pøíkazovými závorkami <strong>glBegin()</strong> a
<strong>glEnd()</strong> a tudí¾ u¾ nemusí být v&nbsp;pøípadì OpenGL 3.1 a
vy¹¹í v¾dy podporovaný.</li>

<li>Zadáním seznamu nìkolika vrcholù pomocí metody
<strong>GL.glDrawElements(mode, count, type, buffer)</strong>. Tato metoda
vybere <i>count</i> vrcholù ze v¹ech zapnutých polí, pøièem¾ posloupnost indexù
vybíraných vrcholù je ulo¾ena v&nbsp;bufferu <i>indices</i>. Typ tohoto pole
pak urèuje parametr <i>type</i>, který mù¾e nabývat hodnot
<strong>GL_UNSIGNED_BYTE</strong>, <strong>GL_UNSIGNED_SHORT</strong> nebo
<strong>GL_UNSIGNED_INT</strong>. Parametr <i>mode</i> urèuje, jaká
geometrická primitiva mají být z&nbsp;vybíraných vrcholù konstruována
(<strong>GL_TRIANGLES</strong>, <strong>GL_POLYGON</strong> atd., tedy stejné
jako parametr funkce <strong>glBegin()</strong>).</li>

<li>V&nbsp;novìj¹ích verzích OpenGL lze vyu¾ít i podobnou funkci
<strong>glDrawElementsInstanced</strong> díky ní¾ lze jedno pole pou¾ít pro
nìkolik tìles.</li>

<li>Zadáním seznamu nìkolika po sobì jdoucích vrcholù pomocí metody
<strong>GL.glDrawArrays(mode, first, count)</strong>. Tato funkce vybere
<i>count</i> vrcholù, které jsou ulo¾eny v&nbsp;poli za sebou. Index prvního
vrcholu je urèen parametrem <i>first</i>.</li>

<li>I pro <strong>glDrawArrays</strong> existuje v&nbsp;novìj¹ích verzích
OpenGL alternativní funkce <strong>glDrawArraysInstanced</strong> pou¾itelná
pro vykreslení nìkolika tìles ulo¾ených v&nbsp;jednom poli.</li>

</ol>



<p><a name="k06"></a></p>
<h2 id="k06">6. Demonstraèní pøíklad <strong>SDLTest17</strong> &ndash; pou¾ití metody <strong>glArrayElement()</strong></h2>

<p>V&nbsp;dne¹ním prvním demonstraèním pøíkladu nazvaném
<strong>SDLTest17</strong> je ukázán zpùsob vytvoøení polí typu
<strong>GL_VERTEX_ARRAY</strong> a <strong>GL_COLOR_ARRAY</strong> a následné
vykreslení dvou úseèek s&nbsp;pou¾itím metody
<strong>glArrayElement()</strong>. Pov¹imnìte si pøedev¹ím zpùsobu alokace obou
bufferù i metod, pomocí nich¾ se do objektu typu <strong>ByteBuffer</strong>
mohou ukládat data jiného datového typu. Pro konstrukci bufferu je nutné pou¾ít
metodu <strong>ByteBuffer.allocateDirect(velikost)</strong> s&nbsp;následným
voláním metody <strong>ByteBuffer.order(ByteOrder.nativeOrder()</strong>, díky
ní¾ je zaji¹tìno ulo¾ení bajtù v&nbsp;bufferu takovým zpùsobem, který je na
pou¾ité platformì nativní (<i>little endian</i> èi <i>big endian</i>). Pokud by
se tato metoda nezavolala, ukládaly by se bajty hodnot typu
short/int/float/long/double v&nbsp;opaèném poøadí, ne¾ je na platformì x86
oèekáváno a vykreslení scény by nebylo korektní!</p>

<pre>
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
&nbsp;
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.video.SDLPixelFormat;
import sdljava.video.SDLSurface;
import sdljava.video.SDLVideo;
&nbsp;
import org.gljava.opengl.GL;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Sedmnacty demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> *</i>
<i> * Priklad vyuziti metody Gl.glArrayElement() pro vykreslovani</i>
<i> * komplikovanejsich objektu a teles.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>SDLTest17</strong> {
&nbsp;
    <i>/**</i>
    <i> * Horizontalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_WIDTH</strong> = 200;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_HEIGHT</strong> = 200;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka vybraneho grafickeho rezimu.</i>
    <i> * (0 znamena automaticky vyber, ovsem lze samozrejme pouzit</i>
    <i> * i hodnoty 8, 16, 24 ci 32, podle vlastnosti graficke karty)</i>
    <i> */</i>
    private static final int <strong>GFX_BPP</strong> = 0;
&nbsp;
    <i>/**</i>
    <i> * Buffer obsahujici vrcholy usecek.</i>
    <i> */</i>
    private static ByteBuffer verticesBuffer = null;
&nbsp;
    <i>/**</i>
    <i> * Buffer obsahujici barvy vrcholu usecek.</i>
    <i> */</i>
    private static ByteBuffer colorsBuffer = null;
&nbsp;
    <i>/* Inicializace bufferu */</i>
    static {
        <i>/* 8 souradnic * 4 bajtu/int = 32 bajtu */</i></i>
        <i>/* je nutne zachovat nativni usporadani bajtu ve slovech! */</i>
        verticesBuffer = ByteBuffer.allocateDirect(32).order(ByteOrder.nativeOrder());
        verticesBuffer.putInt(10);  verticesBuffer.putInt(10);
        verticesBuffer.putInt(190); verticesBuffer.putInt(190);
        verticesBuffer.putInt(10);  verticesBuffer.putInt(190);
        verticesBuffer.putInt(190); verticesBuffer.putInt(10);
        verticesBuffer.flip();
&nbsp;
        <i>/* 12 barvovych slozek<i> * 4 bajtu/float = 48 bajtu */</i></i>
        <i>/* je nutne zachovat nativni usporadani bajtu ve slovech! */</i>
        colorsBuffer = ByteBuffer.allocateDirect(48).order(ByteOrder.nativeOrder());
        colorsBuffer.putFloat(0.0f); colorsBuffer.putFloat(0.0f); colorsBuffer.putFloat(1.0f);
        colorsBuffer.putFloat(1.0f); colorsBuffer.putFloat(0.0f); colorsBuffer.putFloat(1.0f);
        colorsBuffer.putFloat(1.0f); colorsBuffer.putFloat(1.0f); colorsBuffer.putFloat(0.0f);
        colorsBuffer.putFloat(0.0f); colorsBuffer.putFloat(1.0f); colorsBuffer.putFloat(1.0f);
        colorsBuffer.flip();
    }
&nbsp;
    <i>/**</i>
    <i> * Inicializace grafickeho rezimu ci otevreni okna pro vykreslovani.</i>
    <i> */</i>
    private static SDLSurface <strong>initVideo</strong>() throws SDLException {
        final long flags = SDLVideo.SDL_OPENGL | SDLVideo.SDL_DOUBLEBUF;
        return SDLVideo.setVideoMode(GFX_WIDTH, GFX_HEIGHT, GFX_BPP, flags);
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni transformacnich matic a barvy pozadi framebufferu.</i>
    <i> */</i>
    private static void <strong>initScene</strong>(GL gl, int width, int height) {
        <i>// nastaveni projekcni matice</i>
        gl.glMatrixMode(gl.GL_PROJECTION);
&nbsp;
        <i>// jednotkova matice</i>
        gl.glLoadIdentity();
&nbsp;
        <i>// mapovani abstraktnich souradnic do souradnic okna ci cele obrazovky</i>
        gl.glOrtho(0, width, 0, height, -1, 1);
&nbsp;
        <i>// nastaveni modelview matice</i>
        gl.glMatrixMode(gl.GL_MODELVIEW);
        gl.glLoadIdentity();
&nbsp;
        <i>// viditelna oblast</i>
        gl.glViewport(0, 0, width, height);
&nbsp;
        <i>// vypnuti pameti hloubky pri vykreslovani</i>
        gl.glDisable(gl.GL_DEPTH_TEST);
&nbsp;
        <i>// barva pozadi framebufferu pro volani glClear()</i>
        gl.glClearColor (0.0f, 0.0f, 0.0f, 0.0f);
    }
&nbsp;
    <i>/**</i>
    <i> * Vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL.</i>
    <i> */</i>
    private static void <strong>drawScene</strong>(GL gl) {
&nbsp;
        <i>// vymazani framebufferu</i>
        gl.glClear(gl.GL_COLOR_BUFFER_BIT);
&nbsp;
        gl.glEnable(gl.GL_LINE_SMOOTH);                      <i>// povoleni antialiasingu usecek</i>
        gl.glEnableClientState(gl.GL_VERTEX_ARRAY);          <i>// povoleni pouziti pole vrcholu</i>
        gl.glEnableClientState(gl.GL_COLOR_ARRAY);           <i>// povoleni pouziti pole barev</i>
&nbsp;
        gl.glVertexPointer(2, gl.GL_INT, 0, verticesBuffer); <i>// naplneni pole vrcholu</i>
        gl.glColorPointer(3, gl.GL_FLOAT, 0, colorsBuffer);  <i>// naplneni pole barev</i>
&nbsp;
        gl.glBegin(gl.GL_LINES);
            for (int i=0; i&lt;4; i++) {                        <i>// vykreslit vsechny vrcholy</i>
                gl.glArrayElement(i);                        <i>// (vcetne zmeny barvy)</i>
            }
        gl.glEnd();
&nbsp;
        gl.glFlush();                                        <i>// provedeni a vykresleni vsech zmen</i>
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni osmeho demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace video subsystemu knihovny SDL</i>
            SDLMain.init(SDLMain.SDL_INIT_VIDEO);
&nbsp;
            <i>// inicializace grafickeho rezimu ci otevreni okna pro vykreslovani</i>
            SDLSurface screen = initVideo();
&nbsp;
            <i>// inicializace celoobrazovkoveho grafickeho rezimu</i>
            GL gl = screen.getGL();
&nbsp;
            <i>// nastaveni transformacnich matic a barvy pozadi framebufferu</i>
            initScene(gl, GFX_WIDTH, GFX_HEIGHT);
&nbsp;
            <i>// vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL</i>
            drawScene(gl);
&nbsp;
            <i>// prepnuti predniho a zadniho bufferu</i>
            screen.glSwapBuffers();
&nbsp;
            <i>// ukonceni cele aplikace po peti sekundach</i>
            Thread.sleep(5000);
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
        <i>// zobrazit ziskane informace</i>
    }
&nbsp;
}
</pre>

<p>Skript pro pøeklad na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest17.java
</pre>

<p>Dávkový soubor pro pøeklad na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest17.java
</pre>

<p>Skript pro spu¹tìní na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
java -cp .:$SDL_JAVA_LIBS/sdljava.jar -Djava.library.path=$SDL_JAVA_LIBS SDLTest17
</pre>

<p>Dávkový soubor pro spu¹tìní na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest17
</pre>

<img src="http://i.iinfo.cz/images/184/gl00001.png" class="image-161296" width="200" height="200" alt="&#160;" />
<p><i>Obrázek 1: Scéna vykreslená po spu¹tìní demonstraèního pøíkladu
<strong>SDLTest17</strong>.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Demonstraèní pøíklad <strong>SDLTest18</strong> &ndash; pou¾ití metody <strong>glDrawArrays()</strong></h2>

<p>Demonstraèní pøíklad <strong>SDLTest18</strong> se v&nbsp;mnoha ohledech
podobá pøedchozímu demonstraènímu pøíkladu, ov¹em namísto volání metody
<strong>GL.glArrayElement()</strong> se zde pou¾ívá mnohem efektivnìj¹ího
zpùsobu &ndash; metody <strong>GL.glDrawArrays()</strong>, která jediným
zavoláním doká¾e vykreslit i slo¾itou scénu. Této metodì se pøedávají tøi
parametry &ndash; typ vykreslovaných grafických primitiv (body, úseèky,
trojúhelníky ...), poèáteèní index v&nbsp;polích, od kterého se má zahájit
ètení (0=první prvky v&nbsp;polích) a koneènì poèet prvkù polí nutných pro
získání v¹ech dat pro vykreslované grafické primitivum (konstanta 4 znamená, ¾e
se pøeètou souøadnice a barvy ètyø vrcholù, z&nbsp;nich¾ se vytvoøí dvì
úseèky, stejnì, jako kdyby se ètyøikrát zavolala metoda
<strong>glVertex*</strong>):</p>

<pre>
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
&nbsp;
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.video.SDLPixelFormat;
import sdljava.video.SDLSurface;
import sdljava.video.SDLVideo;
&nbsp;
import org.gljava.opengl.GL;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Osmnacty demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> *</i>
<i> * Priklad vyuziti metody Gl.glDrawArrays() pro vykreslovani</i>
<i> * komplikovanejsich objektu a teles.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>SDLTest18</strong> {
&nbsp;
    <i>/**</i>
    <i> * Horizontalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_WIDTH</strong> = 200;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_HEIGHT</strong> = 200;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka vybraneho grafickeho rezimu.</i>
    <i> * (0 znamena automaticky vyber, ovsem lze samozrejme pouzit</i>
    <i> * i hodnoty 8, 16, 24 ci 32, podle vlastnosti graficke karty)</i>
    <i> */</i>
    private static final int <strong>GFX_BPP</strong> = 0;
&nbsp;
    <i>/**</i>
    <i> * Buffer obsahujici vrcholy usecek.</i>
    <i> */</i>
    private static ByteBuffer verticesBuffer = null;
&nbsp;
    <i>/**</i>
    <i> * Buffer obsahujici barvy vrcholu usecek.</i>
    <i> */</i>
    private static ByteBuffer colorsBuffer = null;
&nbsp;
    <i>/* Inicializace bufferu */</i>
    static {
        <i>/* 8 souradnic * 4 bajtu/int = 32 bajtu */</i></i>
        <i>/* je nutne zachovat nativni usporadani bajtu ve slovech! */</i>
        verticesBuffer = ByteBuffer.allocateDirect(32).order(ByteOrder.nativeOrder());
        verticesBuffer.putInt(10);  verticesBuffer.putInt(10);
        verticesBuffer.putInt(190); verticesBuffer.putInt(190);
        verticesBuffer.putInt(10);  verticesBuffer.putInt(190);
        verticesBuffer.putInt(190); verticesBuffer.putInt(10);
        verticesBuffer.flip();
&nbsp;
        <i>/* 12 barvovych slozek<i> * 4 bajtu/float = 48 bajtu */</i></i>
        <i>/* je nutne zachovat nativni usporadani bajtu ve slovech! */</i>
        colorsBuffer = ByteBuffer.allocateDirect(48).order(ByteOrder.nativeOrder());
        colorsBuffer.putFloat(0.0f); colorsBuffer.putFloat(0.0f); colorsBuffer.putFloat(1.0f);
        colorsBuffer.putFloat(1.0f); colorsBuffer.putFloat(0.0f); colorsBuffer.putFloat(1.0f);
        colorsBuffer.putFloat(1.0f); colorsBuffer.putFloat(1.0f); colorsBuffer.putFloat(0.0f);
        colorsBuffer.putFloat(0.0f); colorsBuffer.putFloat(1.0f); colorsBuffer.putFloat(1.0f);
        colorsBuffer.flip();
    }
&nbsp;
    <i>/**</i>
    <i> * Inicializace grafickeho rezimu ci otevreni okna pro vykreslovani.</i>
    <i> */</i>
    private static SDLSurface <strong>initVideo</strong>() throws SDLException {
        final long flags = SDLVideo.SDL_OPENGL | SDLVideo.SDL_DOUBLEBUF;
        return SDLVideo.setVideoMode(GFX_WIDTH, GFX_HEIGHT, GFX_BPP, flags);
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni transformacnich matic a barvy pozadi framebufferu.</i>
    <i> */</i>
    private static void <strong>initScene</strong>(GL gl, int width, int height) {
        <i>// nastaveni projekcni matice</i>
        gl.glMatrixMode(gl.GL_PROJECTION);
&nbsp;
        <i>// jednotkova matice</i>
        gl.glLoadIdentity();
&nbsp;
        <i>// mapovani abstraktnich souradnic do souradnic okna ci cele obrazovky</i>
        gl.glOrtho(0, width, 0, height, -1, 1);
&nbsp;
        <i>// nastaveni modelview matice</i>
        gl.glMatrixMode(gl.GL_MODELVIEW);
        gl.glLoadIdentity();
&nbsp;
        <i>// viditelna oblast</i>
        gl.glViewport(0, 0, width, height);
&nbsp;
        <i>// vypnuti pameti hloubky pri vykreslovani</i>
        gl.glDisable(gl.GL_DEPTH_TEST);
&nbsp;
        <i>// barva pozadi framebufferu pro volani glClear()</i>
        gl.glClearColor (0.0f, 0.0f, 0.0f, 0.0f);
    }
&nbsp;
    <i>/**</i>
    <i> * Vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL.</i>
    <i> */</i>
    private static void <strong>drawScene</strong>(GL gl) {
&nbsp;
        <i>// vymazani framebufferu</i>
        gl.glClear(gl.GL_COLOR_BUFFER_BIT);
&nbsp;
        gl.glEnable(gl.GL_LINE_SMOOTH);                      <i>// povoleni antialiasingu usecek</i>
        gl.glEnableClientState(gl.GL_VERTEX_ARRAY);          <i>// povoleni pouziti pole vrcholu</i>
        gl.glEnableClientState(gl.GL_COLOR_ARRAY);           <i>// povoleni pouziti pole barev</i>
&nbsp;
        gl.glVertexPointer(2, gl.GL_INT, 0, verticesBuffer); <i>// naplneni pole vrcholu</i>
        gl.glColorPointer(3, gl.GL_FLOAT, 0, colorsBuffer);  <i>// naplneni pole barev</i>
&nbsp;
        gl.glDrawArrays(gl.GL_LINES, 0, 4);                  <i>// vykreslit vsechny vrcholy</i>
                                                             <i>// (vcetne zmeny barvy)</i>
&nbsp;
        gl.glFlush();                                        <i>// provedeni a vykresleni vsech zmen</i>
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni osmeho demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace video subsystemu knihovny SDL</i>
            SDLMain.init(SDLMain.SDL_INIT_VIDEO);
&nbsp;
            <i>// inicializace grafickeho rezimu ci otevreni okna pro vykreslovani</i>
            SDLSurface screen = initVideo();
&nbsp;
            <i>// inicializace celoobrazovkoveho grafickeho rezimu</i>
            GL gl = screen.getGL();
&nbsp;
            <i>// nastaveni transformacnich matic a barvy pozadi framebufferu</i>
            initScene(gl, GFX_WIDTH, GFX_HEIGHT);
&nbsp;
            <i>// vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL</i>
            drawScene(gl);
&nbsp;
            <i>// prepnuti predniho a zadniho bufferu</i>
            screen.glSwapBuffers();
&nbsp;
            <i>// ukonceni cele aplikace po peti sekundach</i>
            Thread.sleep(5000);
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
        <i>// zobrazit ziskane informace</i>
    }
&nbsp;
}
</pre>

<p>Skript pro pøeklad na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest18.java
</pre>

<p>Dávkový soubor pro pøeklad na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest18.java
</pre>

<p>Skript pro spu¹tìní na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
java -cp .:$SDL_JAVA_LIBS/sdljava.jar -Djava.library.path=$SDL_JAVA_LIBS SDLTest18
</pre>

<p>Dávkový soubor pro spu¹tìní na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest18
</pre>

<img src="http://i.iinfo.cz/images/184/gl00001.png" class="image-161296" width="200" height="200" alt="&#160;" />
<p><i>Obrázek 1: Scéna vykreslená po spu¹tìní demonstraèního pøíkladu
<strong>SDLTest18</strong>.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Objekt typu <strong>Sprite</strong> v&nbsp;knihovnì SDLJava</h2>

<p>Knihovna OpenGL a tím pádem i SDLJava samozøejmì umo¾òuje naná¹et na
vykreslované plochy rastrové textury. Velkou výhodou rastrových textur je
jejich snadná implementace ve vykreslovacím øetìzci. Jednoduché grafické
akcelerátory pou¾ívané v&nbsp;minulosti øe¹ily texturování takovým zpùsobem, ¾e
se do jejich vykreslovacího øetìzce pøidala vyrovnávací pamì» pro textury a
nìkolik interpolátorù, pomocí kterých se zajistil pøístup do texturovací
pamìti. Dne¹ní moderní grafické akcelerátory a GPU jdou mnohem dál: textury je
mo¾né komprimovat, jsou podporovány mipmapy (textury ve více rozli¹eních),
antialiasing, multitextury apod. Texturovací jednotka v¹ak stále patøí
k&nbsp;tìm èástem vizuálního systému, která má velmi dobrý pomìr
slo¾itost/vizuální efekt.</p>

<p>Vzhledem k&nbsp;tomu, ¾e se knihovna <i>SDL</i> a tím pádem i <i>SDLJava</i>
èasto pou¾ívá pro tvorbu poèítaèových her (a» ji¾ s&nbsp;2D èi 3D scénami),
byla do balíèku <strong>org.gljava.opengl</strong> pøidána tøída nazvaná
<strong>Sprite</strong>, kterou lze vyu¾ít pro naètení bitmapy z&nbsp;externího
souboru a následné vykreslení této bitmapy jednoduchou operací
<strong>Sprite.draw(GL, x, y)</strong>, kde GL je kontext OpenGL a x a y jsou
pozice spritu ve scénì. Samotná knihovna <i>SDLJava</i> zajistí pøevod spritu
na formát textury a vykreslení objektu (ètverce èi obdélníku) pokrytého touto
texturou, co¾ je mnohem jednodu¹¹í, ne¾ bì¾ný postup pøi texturování
v&nbsp;OpenGL.</p>

<p>Mezi metody, které tøída <strong>Sprite</strong> programátorùm nabízí,
patøí:</p>

<table>
<tr><th>#</th><th>Metoda</th><th>Význam</th></tr>
<tr><td>1</td><td>Sprite(Texture t)</td><td>vytvoøení spritu z&nbsp;textury (bude popsáno pøí¹tì)</td></tr>
<tr><td>2</td><td>Sprite(GL gl, java.net.URL url)</td><td>naètení spritu z&nbsp;rastrového obrázku</td></tr>
<tr><td>3</td><td>Sprite(GL gl, java.lang.String texturePath)</td><td>naètení spritu z&nbsp;rastrového obrázku</td></tr>
<tr><td>4</td><td>draw(GL gl, float x, float y)</td><td>vykreslení spritu</td></tr>
<tr><td>5</td><td>getWidth()</td><td>získání ¹íøky spritu v&nbsp;pixelech</td></tr>
<tr><td>6</td><td>getHeight()</td><td>získání vý¹ky spritu v&nbsp;pixelech</td></tr>
</table>

<p>Pokud je zapotøebí sprite pøi vykreslování natoèit, lze tuto operaci provést
jen nepøímo a to natoèením celého souøadného systému. Posléze je vìt¹inou nutné
obnovit pùvodní transformaèní matici naprosto stejným zpùsobem, jaký se provádí
napøíklad pøi vykreslení natoèeného èi zvìt¹eného/zmen¹eného tìlesa.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Demonstraèní pøíklad <strong>SDLTest19</strong> &ndash; texturování a objekt typu <strong>Sprite</strong></h2>

<p>V&nbsp;dne¹ním posledním demonstraèním pøíkladu <strong>SDLTest19</strong>
je ukázán zpùsob naètení spritu z&nbsp;rastrového obrázku (opìt je pou¾ita ji¾
nìkolikrát zobrazená obrazovka hry <strong>Xscorch</strong>) s&nbsp;následným
vykreslením tohoto spritu. Nejprve je sprite vykreslen v&nbsp;takovém souøadném
systému, ¾e jsou jeho hrany rovnobì¾né s&nbsp;hranami okna, podruhé je sprite
otoèen o 45 stupòù, pøesnìji øeèeno <i>souøadný systém</i> je pøed vykreslením
spritu otoèen o tuto hodnotu (co¾ je ve výsledku to samé):</p>

<pre>
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
&nbsp;
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.video.SDLPixelFormat;
import sdljava.video.SDLSurface;
import sdljava.video.SDLVideo;
&nbsp;
import org.gljava.opengl.GL;
import org.gljava.opengl.Sprite;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Devatenacty demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> *</i>
<i> * Texturovani a objekt typu Sprite.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>SDLTest19</strong> {
&nbsp;
    <i>/**</i>
    <i> * Horizontalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_WIDTH</strong> = 200;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_HEIGHT</strong> = 200;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka vybraneho grafickeho rezimu.</i>
    <i> * (0 znamena automaticky vyber, ovsem lze samozrejme pouzit</i>
    <i> * i hodnoty 8, 16, 24 ci 32, podle vlastnosti graficke karty)</i>
    <i> */</i>
    private static final int <strong>GFX_BPP</strong> = 0;
&nbsp;
    <i>/**</i>
    <i> * Inicializace grafickeho rezimu ci otevreni okna pro vykreslovani.</i>
    <i> */</i>
    private static SDLSurface <strong>initVideo</strong>() throws SDLException {
        final long flags = SDLVideo.SDL_OPENGL | SDLVideo.SDL_DOUBLEBUF;
        return SDLVideo.setVideoMode(GFX_WIDTH, GFX_HEIGHT, GFX_BPP, flags);
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni transformacnich matic a barvy pozadi framebufferu.</i>
    <i> */</i>
    private static void <strong>initScene</strong>(GL gl, int width, int height) {
        <i>// nastaveni projekcni matice</i>
        gl.glMatrixMode(gl.GL_PROJECTION);
&nbsp;
        <i>// jednotkova matice</i>
        gl.glLoadIdentity();
&nbsp;
        <i>// mapovani abstraktnich souradnic do souradnic okna ci cele obrazovky</i>
        gl.glOrtho(0, width, height, 0, -1, 1);
&nbsp;
        <i>// nastaveni modelview matice</i>
        gl.glMatrixMode(gl.GL_MODELVIEW);
        gl.glLoadIdentity();
&nbsp;
        <i>// viditelna oblast</i>
        gl.glViewport(0, 0, width, height);
&nbsp;
        <i>// vypnuti pameti hloubky pri vykreslovani</i>
        gl.glDisable(gl.GL_DEPTH_TEST);
&nbsp;
        <i>// povoleni prace s texturami</i>
        gl.glEnable(gl.GL_TEXTURE_2D);
&nbsp;
        <i>// barva pozadi framebufferu pro volani glClear()</i>
        gl.glClearColor (0.0f, 0.0f, 0.0f, 0.0f);
    }
&nbsp;
    <i>/**</i>
    <i> * Vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL.</i>
    <i> */</i>
    private static void <strong>drawScene</strong>(GL gl, Sprite sprite) {
&nbsp;
        <i>// vymazani framebufferu</i>
        gl.glClear(gl.GL_COLOR_BUFFER_BIT);
&nbsp;
        <i>// vykresleni spritu</i>
        sprite.draw(gl, 200, 400);
&nbsp;
        <i>// otoceni souradneho systemu</i>
        gl.glMatrixMode(gl.GL_MODELVIEW);
        gl.glRotatef(45.0f, 0.0f, 0.0f, 1.0f);
&nbsp;
        <i>// vykresleni druheho spritu</i>
        sprite.draw(gl, 200, 0);
&nbsp;
        gl.glFlush();                                        <i>// provedeni a vykresleni vsech zmen</i>
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni osmeho demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace video subsystemu knihovny SDL</i>
            SDLMain.init(SDLMain.SDL_INIT_VIDEO);
&nbsp;
            <i>// inicializace grafickeho rezimu ci otevreni okna pro vykreslovani</i>
            SDLSurface screen = initVideo();
&nbsp;
            <i>// inicializace celoobrazovkoveho grafickeho rezimu</i>
            GL gl = screen.getGL();
&nbsp;
            <i>// nastaveni transformacnich matic a barvy pozadi framebufferu</i>
            initScene(gl, GFX_WIDTH, GFX_HEIGHT);
&nbsp;
            <i>// nacteni spritu z rastroveho obrazku</i>
            Sprite sprite = new Sprite(gl, "xscorch.bmp");
&nbsp;
            <i>// vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL</i>
            drawScene(gl, sprite);
&nbsp;
            <i>// prepnuti predniho a zadniho bufferu</i>
            screen.glSwapBuffers();
&nbsp;
            <i>// ukonceni cele aplikace po peti sekundach</i>
            Thread.sleep(5000);
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
        <i>// zobrazit ziskane informace</i>
    }
&nbsp;
}
</pre>

<p>Skript pro pøeklad na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest19.java
</pre>

<p>Dávkový soubor pro pøeklad na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest19.java
</pre>

<p>Skript pro spu¹tìní na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
java -cp .:$SDL_JAVA_LIBS/sdljava.jar -Djava.library.path=$SDL_JAVA_LIBS SDLTest19
</pre>

<p>Dávkový soubor pro spu¹tìní na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest19
</pre>

<img src="http://i.iinfo.cz/images/290/gl00002.png" class="image-161297" width="600" height="600" alt="&#160;" />
<p><i>Obrázek 1: Scéna vykreslená po spu¹tìní demonstraèního pøíkladu
<strong>SDLTest19</strong>.</i></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Repositáø se zdrojovými kódy v¹ech tøí dne¹ních demonstraèních pøíkladù</h2>

<p>V¹echny tøi dnes popsané demonstraèní pøíklady byly spoleènì
s&nbsp;podpùrnými skripty urèenými pro jejich pøeklad a následné spu¹tìní
ulo¾eno do Mercurial repositáøe dostupného na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
Podobnì jako tomu bylo i v&nbsp;pøedchozích ètyøech dílech tohoto seriálu, i ke
dne¹ním pøíkladùm jsou pøilo¾eny skripty vyu¾itelné pro jejich pøeklad a
spu¹tìní. Navíc byly pøidány i skripty vyu¾itelné ve Windows:</p>

<table>
<tr><th> #</th><th>Zdrojový soubor/skript</th><th>Umístìní souboru v&nbsp;repositáøi</th></tr>
<tr><td> 1</td><td>SDLTest17.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest17/SDLTest17.java ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest17/SDLTest17.java</a></td></tr>
<tr><td> 2</td><td>SDLTest17_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest17/SDLTest17_compile.sh ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest17/SDLTest17_compile.sh</a></td></tr>
<tr><td> 3</td><td>SDLTest17_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest17/SDLTest17_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest17/SDLTest17_compile_sys.sh</a></td></tr>
<tr><td> 4</td><td>SDLTest17_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest17/SDLTest17_run.sh ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest17/SDLTest17_run.sh</a></td></tr>
<tr><td> 5</td><td>SDLTest17_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest17/SDLTest17_run_sys.sh ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest17/SDLTest17_run_sys.sh</a></td></tr>
<tr><td> 6</td><td>SDLTest17_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest17/SDLTest17_compile.bat ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest17/SDLTest17_compile.bat</a></td></tr>
<tr><td> 7</td><td>SDLTest17_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest17/SDLTest17_run.bat ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest17/SDLTest17_run.bat</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr> 
<tr><td> 8</td><td>SDLTest18.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest18/SDLTest18.java ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest18/SDLTest18.java</a></td></tr>
<tr><td> 9</td><td>SDLTest18_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest18/SDLTest18_compile.sh ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest18/SDLTest18_compile.sh</a></td></tr>
<tr><td>10</td><td>SDLTest18_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest18/SDLTest18_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest18/SDLTest18_compile_sys.sh</a></td></tr>
<tr><td>11</td><td>SDLTest18_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest18/SDLTest18_run.sh ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest18/SDLTest18_run.sh</a></td></tr>
<tr><td>12</td><td>SDLTest18_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest18/SDLTest18_run_sys.sh ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest18/SDLTest18_run_sys.sh</a></td></tr>
<tr><td>13</td><td>SDLTest18_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest18/SDLTest18_compile.bat ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest18/SDLTest18_compile.bat</a></td></tr>
<tr><td>14</td><td>SDLTest18_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest18/SDLTest18_run.bat ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest18/SDLTest18_run.bat</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr> 
<tr><td>15</td><td>SDLTest19.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest19/SDLTest19.java ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest19/SDLTest19.java</a></td></tr>
<tr><td>16</td><td>SDLTest19_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest19/SDLTest19_compile.sh ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest19/SDLTest19_compile.sh</a></td></tr>
<tr><td>17</td><td>SDLTest19_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest19/SDLTest19_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest19/SDLTest19_compile_sys.sh</a></td></tr>
<tr><td>18</td><td>SDLTest19_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest19/SDLTest19_run.sh ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest19/SDLTest19_run.sh</a></td></tr>
<tr><td>19</td><td>SDLTest19_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest19/SDLTest19_run_sys.sh ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest19/SDLTest19_run_sys.sh</a></td></tr>
<tr><td>20</td><td>SDLTest19_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest19/SDLTest19_compile.bat ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest19/SDLTest19_compile.bat</a></td></tr>
<tr><td>21</td><td>SDLTest19_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest19/SDLTest19_run.bat ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest19/SDLTest19_run.bat</a></td></tr>
</table>



<p><a name="k11"></a></p>
<h2 id="k11">11. Odkazy na Internetu</h2>

<ol>

<li>glDrawArrays<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArrays.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArrays.xml</a>
</li>

<li>glDrawElements<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElements.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElements.xml</a>
</li>

<li>glDrawArraysInstanced<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArraysInstanced.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArraysInstanced.xml</a>
</li>

<li>glDrawElementsInstanced<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElementsInstanced.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElementsInstanced.xml</a>
</li>

<li>Root.cz: Seriál Grafická knihovna OpenGL<br />
<a href="http://www.root.cz/serialy/graficka-knihovna-opengl/">http://www.root.cz/serialy/graficka-knihovna-opengl/</a>
</li>

<li>Root.cz: Seriál Tvorba pøenositelných grafických aplikací vyu¾ívajících knihovnu GLUT<br />
<a href="http://www.root.cz/serialy/tvorba-prenositelnych-grafickych-aplikaci-vyuzivajicich-knihovnu-glut/">http://www.root.cz/serialy/tvorba-prenositelnych-grafickych-aplikaci-vyuzivajicich-knihovnu-glut/</a>
</li>

<li>Best Practices for Working with Vertex Data<br />
<a href="https://developer.apple.com/library/ios/documentation/3ddrawing/conceptual/opengles_programmingguide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html">https://developer.apple.com/library/ios/documentation/3ddrawing/conceptual/opengles_programmingguide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_Surface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_PixelFormat<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlpixelformat.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlpixelformat.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_LockSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdllocksurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdllocksurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_UnlockSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlunlocksurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlunlocksurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_LoadBMP<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlloadbmp.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlloadbmp.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_SaveBMP<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsavebmp.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsavebmp.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_BlitSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlblitsurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlblitsurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_VideoInfo<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlvideoinfo.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlvideoinfo.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_GetVideoInfo<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlgetvideoinfo.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlgetvideoinfo.html</a>
</li>

<li>Class BufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferStrategy.html</a>
</li>

<li>Class Graphics<br />
<a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/Graphics.html">http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/Graphics.html</a>
</li>

<li>Double Buffering and Page Flipping<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html</a>
</li>

<li>BufferStrategy and BufferCapabilities<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/bufferstrategy.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/bufferstrategy.html</a>
</li>

<li>Java:Tutorials:Double Buffering<br />
<a href="http://content.gpwiki.org/index.php/Java:Tutorials:Double_Buffering">http://content.gpwiki.org/index.php/Java:Tutorials:Double_Buffering</a>
</li>

<li>Double buffer in standard Java AWT<br />
<a href="http://www.codeproject.com/Articles/2136/Double-buffer-in-standard-Java-AWT">http://www.codeproject.com/Articles/2136/Double-buffer-in-standard-Java-AWT</a>
</li>

<li>Java 2D: Hardware Accelerating - Part 1 - Volatile Images<br />
<a href="http://www.javalobby.org/forums/thread.jspa?threadID=16840&tstart=0">http://www.javalobby.org/forums/thread.jspa?threadID=16840&tstart=0</a>
</li>

<li>Java 2D: Hardware Accelerating - Part 2 - Buffer Strategies<br />
<a href="http://www.javalobby.org/java/forums/t16867.html">http://www.javalobby.org/java/forums/t16867.html</a>
</li>

<li>How does paintComponent work?<br />
<a href="http://stackoverflow.com/questions/15544549/how-does-paintcomponent-work">http://stackoverflow.com/questions/15544549/how-does-paintcomponent-work</a>
</li>

<li>A Swing Architecture Overview<br />
<a href="http://www.oracle.com/technetwork/java/architecture-142923.html">http://www.oracle.com/technetwork/java/architecture-142923.html</a>
</li>

<li>Class javax.swing.JComponent<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html</a>
</li>

<li>Class java.awt.Component<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html</a>
</li>

<li>Class java.awt.Component.BltBufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.BltBufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.BltBufferStrategy.html</a>
</li>

<li>Class java.awt.Component.FlipBufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.FlipBufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.FlipBufferStrategy.html</a>
</li>

<li>Metoda java.awt.Component.isDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html#isDoubleBuffered()">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html#isDoubleBuffered()</a>
</li>

<li>Metoda javax.swing.JComponent.isDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#isDoubleBuffered()">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#isDoubleBuffered()</a>
</li>

<li>Metoda javax.swing.JComponent.setDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#setDoubleBuffered(boolean)">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#setDoubleBuffered(boolean)</a>
</li>

<li>Javadoc - tøída GraphicsDevice<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html</a>
</li>

<li>Javadoc - tøída GraphicsEnvironment<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html</a>
</li>

<li>Javadoc - tøída GraphicsConfiguration<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html</a>
</li>

<li>Javadoc - tøída DisplayMode<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html">http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html</a>
</li>

<li>Lesson: Full-Screen Exclusive Mode API<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/">http://docs.oracle.com/javase/tutorial/extra/fullscreen/</a>
</li>

<li>Full-Screen Exclusive Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html</a>
</li>

<li>Display Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html</a>
</li>

<li>Using the Full-Screen Exclusive Mode API in Java<br />
<a href="http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm">http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>GC safe-point (or safepoint) and safe-region<br />
<a href="http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html">http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html</a>
</li>

<li>Safepoints in HotSpot JVM<br />
<a href="http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html">http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html</a>
</li>

<li>Java theory and practice: Synchronization optimizations in Mustang<br />
<a href="http://www.ibm.com/developerworks/java/library/j-jtp10185/">http://www.ibm.com/developerworks/java/library/j-jtp10185/</a>
</li>

<li>How to build hsdis<br />
<a href="http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README">http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README</a>
</li>

<li>Java SE 6 Performance White Paper<br />
<a href="http://www.oracle.com/technetwork/java/6-performance-137236.html">http://www.oracle.com/technetwork/java/6-performance-137236.html</a>
</li>

<li>Lukas Stadler's Blog<br />
<a href="http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html">http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html</a>
</li>

<li>How to build hsdis-amd64.dll and hsdis-i386.dll on Windows<br />
<a href="http://dropzone.nfshost.com/hsdis.htm">http://dropzone.nfshost.com/hsdis.htm</a>
</li>

<li>PrintAssembly<br />
<a href="https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly">https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly</a>
</li>

<li>The Java Virtual Machine Specification: 3.14. Synchronization<br />
<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14</a>
</li>

<li>The Java Virtual Machine Specification: 8.3.1.4. volatile Fields<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.4. Memory Model<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.7. Non-atomic Treatment of double and long<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7</a>
</li>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (pøed verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2014</small></p>
</body>
</html>

