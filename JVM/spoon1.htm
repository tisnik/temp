<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Analýza a transformace kódu psaného v Javě s využitím knihovny Spoon</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Analýza a transformace kódu psaného v Javě s využitím knihovny Spoon</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V článku se seznámíme s knihovnou Spoon, kterou je možné použít v případě, že je zapotřebí analyzovat zdrojové kódy psané v Javě, hledat v nich typické příznaky chyb typu prázdného bloku catch či kódy dokonce programově modifikovat.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Analýza a transformace kódu psaného v&nbsp;Javě s&nbsp;využitím knihovny Spoon</a></p>
<p><a href="#k02">2. Lokální instalace a základní otestování  knihovny Spoon</a></p>
<p><a href="#k03">3. Grafické zobrazení abstraktního syntaktického stromu zdrojových kódů</a></p>
<p><a href="#k04">4. Vytvoření a překlad velmi jednoduchého procesoru zdrojového kódu</a></p>
<p><a href="#k05">5. Otestování procesoru zdrojového kódu</a></p>
<p><a href="#k06">6. Procesor zjišťující pozice elementů ve zdrojovém kódu</a></p>
<p><a href="#k07">7. Otestování druhého procesoru</a></p>
<p><a href="#k08">8. Procesor zjišťující všechny deklarované třídy</a></p>
<p><a href="#k09">9. Otestování třetího procesoru</a></p>
<p><a href="#k10">10. Procesor detekující zápisy do proměnných</a></p>
<p><a href="#k11">11. Otestování čtvrtého procesoru</a></p>
<p><a href="#k12">12. Zdrojové kódy všech procesorů i testovaných příkladů</a></p>
<p><a href="#k13">13. Použité třídy a rozhraní knihovny Spoon</a></p>
<p><a href="#k14">14. Obsah druhé části článku</a></p>
<p><a href="#k15">15. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Analýza a transformace kódu psaného v&nbsp;Javě s&nbsp;využitím knihovny Spoon</h2>

<p>V&nbsp;seriálu o programovacím jazyku Java i o virtuálním stroji Javy jsme
se již zabývali několika nástroji, které jsou používány pro analýzu programů a
aplikací naprogramovaných v&nbsp;Javě, popř.&nbsp;pro nějakou transformaci kódů
(například pro vložení volání loggeru na začátek vybraných metod atd.). Jednalo
se ovšem prozatím převážně o knihovny a nástroje, které jsou založeny na
zpracování a modifikaci bajtkódu. Zmínili jsme se například o knihovně
<i>ASM</i>, dále pak o knihovně <i>BCEL (Byte Code Engineering Library)</i> a
nesmíme zapomenout ani na knihovnu <i>Javassist</i> a utilitu <i>Byteman</i>.
Nad těmito knihovnami jsou postaveny složitější a možná i známější nástroje
typu <i>FindBugs</i>. Ovšem již při častějším používání <i>FindBugs</i> začne
být patrné, že tento nástroj nemá (a ani nemůže mít) k&nbsp;dispozici všechny
důležité informace o zpracovávaných kódech, protože jeho princip je založen na
analýze bajtkódu, ke kterému se pouze přidávají další metainformace typu číslo
řádku a jméno zdrojového souboru.</p>

<p>I některé další aplikace vyžadují poněkud odlišný přístup než
&bdquo;pouhou&ldquo; analýzu bajtkódu. Pro příklad samozřejmě nemusíme chodit
daleko, protože takovou aplikací jsou všechna moderní integrovaná vývojová
prostředí, která &bdquo;rozumí&ldquo; zapisovanému zdrojovému kódu &ndash;
nezpracovávají ho tedy jako pouhou sekvenci textových řádků, kde každý řádek
obsahuje proměnlivý počet znaků, ale udržují si určitý sofistikovanější model
zdrojového kódu, který umožňuje, aby IDE mohlo provádět kontextové doplňování
identifikátorů (metod, atributů, tříd, ...), refaktoring apod. Onen
sofistikovaný model je ve většině případů založen na <i>AST (Abstract Syntax
Tree)</i>. A právě na programovou manipulaci s&nbsp;AST reprezentujícím
zdrojové kódy Javy je zaměřena knihovna <i>Spoon</i>, jejíž základní vlastnosti
si dnes přiblížíme.  V&nbsp;nejjednodušším případě <i>Spoon</i> pracuje jako
&bdquo;kolona&ldquo; známá všem administrátorům unixových systémů:</p>

<pre>
zdrojový kód &rarr; AST &rarr; processor1 &rarr; processor2 &rarr; modifikovaný AST &rarr; výsledný zdrojový kód
</pre>

<p>Na vstupu i na výstupu tedy máme zdrojový kód, ovšem uprostřed
&bdquo;kolony&ldquo; se neprovádí nějaké textové substituce či aplikace
textových maker (jak to známe z&nbsp;preprocesoru céčka), ale přímo manipulace
s&nbsp;AST. V&nbsp;některých případech nás dokonce ani nezajímá výsledný
zdrojový kód, ale pouze průběh analýzy; to využijeme například při hledání
chyb, porovnávání dvou kódů (jeho sémantiky) atd. Ve skutečnosti ovšem může být
manipulace s&nbsp;AST poměrně sofistikovaná, od přidání nových metod až po
záměnu programových smyček, &bdquo;expanzi&ldquo; anotace na skutečný
programový kód (například při označení třídy jako jedináčka se může automaticky
skrýt konstruktor) apod.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Lokální instalace a základní otestování knihovny Spoon</h2>

<p>Knihovnu <i>Spoon</i> je možné nainstalovat a použít několika způsoby. Pokud
při správě projektů používáte Maven, stačí do konfiguračního souboru projektu
(.pom) přidat následující řádky odkazující se na Spoon verze 5.3.0:</p>

<pre>
&lt;dependency&gt;
    &lt;groupId&gt;fr.inria.gforge.spoon&lt;/groupId&gt;
    &lt;artifactId&gt;spoon-core&lt;/artifactId&gt;
    &lt;version&gt;5.3.0&lt;/version&gt;
&lt;/dependency&gt;
</pre>

<p>Ve skutečnosti je však samozřejmě možné knihovnu <i>Spoon</i> nainstalovat a
použít i bez Mavenu. Postačuje si pouze do pracovního adresáře stáhnout již
připravený Java archiv (JAR) obsahující již přeloženou knihovnu a současně i
všechny další potřebné balíčky. Takto vytvořený Java archiv vyžaduje ke své
činnosti pouze JVM (navíc ještě budeme potřebovat alespoň překladač pro překlad
tzv.&nbsp;procesorů). Pro naše účely se tedy celá instalace zmenší na jediný
příkaz pro stažení Java archivu s&nbsp;knihovnou verze 5.3.0:</p>

<pre>
<strong>wget https://gforge.inria.fr/frs/download.php/file/36179/spoon-core-5.3.0-jar-with-dependencies.jar</strong>
</pre>

<p>Právě stažený Java archiv pro jistotu otestujeme. Po zadání tohoto příkazu:</p>

<pre>
<strong>java -jar spoon-core-5.3.0-jar-with-dependencies.jar</strong>
</pre>

<p>by se na standardní výstup měla vypsat nápověda:</p>

<pre>
Spoon version 5.3.0
Usage: java &lt;launcher name&gt; [option(s)]
&nbsp;
Options : 
&nbsp;
  [-h|--help]
&nbsp;
...
...
...
</pre>

<p>Poznámka: všechny příklady byly otestovány na OpenJDK 1.7.0 a budou funkční
i pro 1.8.0. Pokud stále ještě používáte Javu 5 či 6, bude pravděpodobně nutné
si Spoon přeložit ze zdrojových kódů.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Grafické zobrazení abstraktního syntaktického stromu zdrojových kódů</h2>

<p>Ještě než si popíšeme základní způsoby zpracování AST, můžeme se podívat na
to, jak je vlastně takový AST v&nbsp;knihovně Spoon reprezentován. Vytvořme si
pro tento účel tu nejjednodušší možnou třídu:</p>

<pre>
public class EmptyClass {
}
</pre>

<p>Poznámka: třída je <i>public</i> z&nbsp;toho důvodu, aby bylo zřejmé, jak se
jmenuje její soubor.</p>

<p>Tuto třídu <strong>nemusíme překládat</strong>, protože Spoon skutečně
zpracovává zdrojový kód. Snadno se o tom můžeme přesvědčit po zadání
následujícího příkazu v&nbsp;pracovním adresáři:</p>

<pre>
java -jar spoon-core-5.3.0-jar-with-dependencies.jar -g -i EmptyClass.java
</pre>

<p>V&nbsp;tomto příkazu specifikujeme jméno zpracovávané třídy parametrem
<strong>-i</strong> a parametr <strong>-g</strong> zařídí, že Spoon zobrazí GUI
okno se strukturou AST zobrazenou klasickým Swingovým
&bdquo;stromečkem&ldquo;:</p>

<a href="http://www.root.cz/obrazek/264672/"><img src="https://i.iinfo.cz/images/83/spoon-1-prev.png" class="image-264672" alt="&#160;" height="270" width="360" /></a>
<p><i>Obrázek 1: AST třídy EmptyClass. Každý uzel stromu má svůj typ (CtClass, CtBlock).</i></p>

<p>Zkusme ještě něco složitějšího; třídu Operators (k&nbsp;té se ještě dnes
později vrátíme):</p>

<pre>
public class Operators {
    public static void main(String[] args) {
        int x, y, z;
        x = 10;
        y = 2 * x;
        z = y + x / 3 * (x + y);
    }
}
</pre>

<pre>
java -jar spoon-core-5.3.0-jar-with-dependencies.jar -g -i Operators.java
</pre>

<a href="http://www.root.cz/obrazek/264673/"><img src="https://i.iinfo.cz/images/83/spoon-2-prev.png" class="image-264673" alt="&#160;" height="270" width="254" /></a>
<p><i>Obrázek 2: AST třídy Operators.</i></p>

<p>Poznámka: uzly stromu jsou implicitně zabaleny, ovšem z&nbsp;kontextového
menu (pravé tlačítko myši) lze zvolit příkaz <i>Expand All</i> na zobrazení
celého stromu.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Vytvoření a překlad velmi jednoduchého procesoru zdrojového kódu</h2>

<p>Okno se zobrazeným AST je vhodné jen pro první seznámení s&nbsp;tím, jakým
způsobem je zdrojový kód v&nbsp;knihovně Spoon reprezentován, ovšem veškeré
případné manipulace musí být provedeny programově. Pro tento účel se používají
takzvané <i>procesory</i>, což jsou třídy rozšiřující abstraktní třídu
<strong>spoon.processing.AbstractProcessor</strong> či některého jejího
potomka. Konkrétní (neabstraktní) třídy odvozené od
<strong>AbstractProcessor</strong> obsahují metodu <strong>process()</strong>,
která je postupně volána pro každý element AST, jenž je zvoleného typu. Pro
začátek se nebudeme zabývat typy elementů a ukážeme si implementaci procesoru,
jehož metoda <strong>process()</strong> postupně získá a zpracuje všechny
elementy (každý element je reprezentován instancí třídy implementující rozhraní
<strong>CtElement</strong>, kde &bdquo;CT&ldquo; značí &bdquo;Compile
Time&ldquo;). Náš úplně první procesor je velmi jednoduchý:</p>

<pre>
import spoon.processing.AbstractProcessor;
import spoon.reflect.declaration.CtElement;
&nbsp;
public class FirstProcessor extends AbstractProcessor {
    public void process(CtElement element) {
        System.out.println(element);
    }
}
</pre>

<p>Pro překlad je pochopitelně nutné specifikovat, kde se nachází importovaná
třída <strong>AbstractProcessor</strong> a rozhraní <strong>CtElement</strong>.
Překlad se tedy provede následovně:</p>

<pre>
javac -cp spoon-core-5.3.0-jar-with-dependencies.jar FirstProcessor.java
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Otestování procesoru zdrojového kódu</h2>

<p>Otestujme si nyní právě přeložený procesor. Pro spuštění knihovny Spoon
s&nbsp;procesorem se spouští metoda <strong>main</strong> třídy
<strong>spoon.Launcher</strong>, samotný procesor se specifikuje přepínačem
<strong>-p</strong>:</p>

<pre>
java -cp .:spoon-core-5.3.0-jar-with-dependencies.jar spoon.Launcher -p FirstProcessor -i zdrojový_kód
</pre>

<p>Zkusme si procesor otestovat na již představené třídě
<strong>EmptyClass</strong>:</p>

<pre>
public class EmptyClass {
}
</pre>

<pre>
<strong>java -cp .:spoon-core-5.3.0-jar-with-dependencies.jar spoon.Launcher -p FirstProcessor -i EmptyClass.java</strong>
&nbsp;
java.lang
java.lang.Object
java.lang
java.lang.Object
java.lang.Object#Object()
super()
{
}
public EmptyClass() {
}
public class EmptyClass {}
</pre>

<p>Metoda <strong>process()</strong> byla postupně volána pro všechny elementy
AST a vypsala jejich textovou podobu <strong>CtElement.toString()</strong> na
standardní výstup (ve skutečnosti není výsledek příliš čitelný, protože
implementace metody <strong>CtElement.toString()</strong> jsou pojaty dosti
minimalisticky).</p>

<p>Můžeme si ještě vyzkoušet nepatrně složitější příklad &ndash; třídu
<strong>HelloWorld</strong>:</p>

<pre>
public class HelloWorld {
    private static String HELLO = "Hello world!";
&nbsp;
    public static void main(String[] args) {
        System.out.println(HELLO);
    }
}
</pre>

<pre>
<strong>java -cp .:spoon-core-5.3.0-jar-with-dependencies.jar spoon.Launcher -p FirstProcessor -i HelloWorld.java</strong>
&nbsp;
java.lang
java.lang.String
java.lang
java.lang.String
"Hello world!"
private static java.lang.String HELLO = "Hello world!";
java.lang
java.lang.Object
java.lang
java.lang.Object
java.lang.Object#Object()
super()
{
}
public HelloWorld() {
}
void
java.lang
java.lang.String
java.lang.String[]
java.lang.String[] args
java.lang
java.lang.System
java.lang.System
java.lang
java.lang.System
java.io
java.io.PrintStream
java.lang.System.out
java.lang.System.out
java.io
java.io.PrintStream
void
java.lang
java.lang.String
java.io.PrintStream#println(java.lang.String)

HelloWorld
HelloWorld

HelloWorld
java.lang
java.lang.String
HelloWorld.HELLO
HelloWorld.HELLO
java.lang.System.out.println(HelloWorld.HELLO)
{
    java.lang.System.out.println(HelloWorld.HELLO);
}
public static void main(java.lang.String[] args) {
    java.lang.System.out.println(HelloWorld.HELLO);
}
public class HelloWorld {
    private static java.lang.String HELLO = "Hello world!";

    public static void main(java.lang.String[] args) {
        java.lang.System.out.println(HelloWorld.HELLO);
    }
}
0 packages
</pre>

<p>Poznámka: povšimněte si, že při spuštění procesoru vznikl adresář
<strong>spooned</strong>, do kterého jsou uloženy transformované třídy. Ve
skutečnosti se vlastně žádná skutečná transformace (modifikace) neprováděla,
takže třídy jsou vlastně sémanticky totožné.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Procesor zjišťující pozice elementů ve zdrojovém kódu</h2>

<p>První implementace procesoru byla velmi primitivní (jediný programový řádek
v&nbsp;metodě <strong>process</strong>), takže se ani není čemu divit, že
generovaný výstup je prakticky nečitelný. Zkusme si nyní vytvořit nepatrně
složitější procesor, který u každého elementu vypíše, na kterém místě ve
zdrojovém kódu se tento element nachází, dále pak typ elementu
(resp.&nbsp;přesněji řečeno jméno třídy implementující rozhraní
<strong>CtElement</strong>) a nakonec lepší textovou reprezentaci elementu
zjišťovanou metodou <strong>CtElement.getShortRepresentation</strong>.
Vylepšený procesor vypadá následovně:</p>

<pre>
import spoon.processing.AbstractProcessor;
import spoon.reflect.declaration.CtElement;
import spoon.reflect.cu.SourcePosition;
&nbsp;
public class ListSourcePositionProcessor extends AbstractProcessor {
    public void process(CtElement element) {
        SourcePosition sp = element.getPosition();
        String position = sp == null ? "unknown" : sp.toString();
        System.out.println(position + "\t" + element.getClass().getName() + "\t" + element.getShortRepresentation());
    }
}
</pre>

<p>Povšimněte si, že nejprve zjišťujeme pozici elementu ve zpracovávaném
zdrojovém kódu, která však nemusí být u všech elementů známá. Pokud nelze
pozici elementu určit, vrátí se <strong>null</strong>, který je nutné korektně
zpracovat.</p>

<p>Překlad vylepšeného procesoru:</p>

<pre>
javac -cp spoon-core-5.3.0-jar-with-dependencies.jar ListSourcePositionProcessor.java
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Otestování druhého procesoru</h2>

<p>Druhý procesor zjišťující pozice elementů a jejich typ, si otestujeme jak na
třídě <strong>EmptyClass</strong>, tak i na třídě
<strong>HelloWorld</strong>:</p>

<pre>
<strong>java -cp .:spoon-core-5.3.0-jar-with-dependencies.jar spoon.Launcher -p ListSourcePositionProcessor -i EmptyClass.java</strong>
&nbsp;
unknown spoon.support.reflect.reference.CtPackageReferenceImpl  java.lang
unknown spoon.support.reflect.reference.CtTypeReferenceImpl     java.lang.Object
unknown spoon.support.reflect.reference.CtPackageReferenceImpl  java.lang
unknown spoon.support.reflect.reference.CtTypeReferenceImpl     java.lang.Object
unknown spoon.support.reflect.reference.CtExecutableReferenceImpl       java.lang.Object#Object()
(/home/tester/spoon/EmptyClass.java:1)       spoon.support.reflect.code.CtInvocationImpl     (java.lang.Object#Object()())
(/home/tester/spoon/EmptyClass.java:1)       spoon.support.reflect.code.CtBlockImpl  {
(java.lang.Object#Object()());
}
(/home/tester/spoon/EmptyClass.java:1)       spoon.support.reflect.declaration.CtConstructorImpl     EmptyClass()
(/home/tester/spoon/EmptyClass.java:1)       spoon.support.reflect.declaration.CtClassImpl   class EmptyClass
unknown spoon.reflect.CtModelImpl$CtRootPackage
</pre>

<p>Z&nbsp;výpisu, který je vhodné porovnat s&nbsp;prvním obrázkem <a
href="#k03">ve třetí kapitole</a>, je patrné, proč se u některých elementů nedá
určit jejich vazba na konkrétní místo ve zdrojovém kódu. Taktéž si při
porovnání s&nbsp;obrázkem můžeme uvědomit, že se metoda
<strong>process</strong> volá pro všechny uzly AST, ovšem prohledávání je
prováděno do hloubky, takže se kořenový uzel zpracuje jako poslední, což má
svůj význam například při manipulaci s&nbsp;bloky či s&nbsp;výrazy.</p>

<pre>
<strong>java -cp .:spoon-core-5.3.0-jar-with-dependencies.jar spoon.Launcher -p ListSourcePositionProcessor -i HelloWorld.java</strong>
&nbsp;
unknown	spoon.support.reflect.reference.CtPackageReferenceImpl	java.lang
(/home/tester/spoon/HelloWorld.java:2)	spoon.support.reflect.reference.CtTypeReferenceImpl	java.lang.String
unknown	spoon.support.reflect.reference.CtPackageReferenceImpl	java.lang
unknown	spoon.support.reflect.reference.CtTypeReferenceImpl	java.lang.String
(/home/tester/spoon/HelloWorld.java:2)	spoon.support.reflect.code.CtLiteralImpl	"Hello world!"
(/home/tester/spoon/HelloWorld.java:2)	spoon.support.reflect.declaration.CtFieldImpl	java.lang.String HELLO
unknown	spoon.support.reflect.reference.CtPackageReferenceImpl	java.lang
unknown	spoon.support.reflect.reference.CtTypeReferenceImpl	java.lang.Object
unknown	spoon.support.reflect.reference.CtPackageReferenceImpl	java.lang
unknown	spoon.support.reflect.reference.CtTypeReferenceImpl	java.lang.Object
unknown	spoon.support.reflect.reference.CtExecutableReferenceImpl	java.lang.Object#Object()
(/home/tester/spoon/HelloWorld.java:1)	spoon.support.reflect.code.CtInvocationImpl	(java.lang.Object#Object()())
(/home/tester/spoon/HelloWorld.java:1)	spoon.support.reflect.code.CtBlockImpl	{
(java.lang.Object#Object()());
}
(/home/tester/spoon/HelloWorld.java:1)	spoon.support.reflect.declaration.CtConstructorImpl	HelloWorld()
(/home/tester/spoon/HelloWorld.java:4)	spoon.support.reflect.reference.CtTypeReferenceImpl	void
unknown	spoon.support.reflect.reference.CtPackageReferenceImpl	java.lang
unknown	spoon.support.reflect.reference.CtTypeReferenceImpl	java.lang.String
(/home/tester/spoon/HelloWorld.java:4)	spoon.support.reflect.reference.CtArrayTypeReferenceImpl	java.lang.String[]
(/home/tester/spoon/HelloWorld.java:4)	spoon.support.reflect.declaration.CtParameterImpl	args
unknown	spoon.support.reflect.reference.CtPackageReferenceImpl	java.lang
unknown	spoon.support.reflect.reference.CtTypeReferenceImpl	java.lang.System
(/home/tester/spoon/HelloWorld.java:5)	spoon.support.reflect.code.CtTypeAccessImpl	java.lang.System
unknown	spoon.support.reflect.reference.CtPackageReferenceImpl	java.lang
unknown	spoon.support.reflect.reference.CtTypeReferenceImpl	java.lang.System
unknown	spoon.support.reflect.reference.CtPackageReferenceImpl	java.io
unknown	spoon.support.reflect.reference.CtTypeReferenceImpl	java.io.PrintStream
(/home/tester/spoon/HelloWorld.java:5)	spoon.support.reflect.reference.CtFieldReferenceImpl	java.io.PrintStream java.lang.System#out
(/home/tester/spoon/HelloWorld.java:5)	spoon.support.reflect.code.CtFieldReadImpl	java.io.PrintStream java.lang.System#out
unknown	spoon.support.reflect.reference.CtPackageReferenceImpl	java.io
unknown	spoon.support.reflect.reference.CtTypeReferenceImpl	java.io.PrintStream
unknown	spoon.support.reflect.reference.CtTypeReferenceImpl	void
unknown	spoon.support.reflect.reference.CtPackageReferenceImpl	java.lang
unknown	spoon.support.reflect.reference.CtTypeReferenceImpl	java.lang.String
unknown	spoon.support.reflect.reference.CtExecutableReferenceImpl	java.io.PrintStream#println(java.lang.String)
unknown	spoon.support.reflect.reference.CtPackageReferenceImpl	
unknown	spoon.support.reflect.reference.CtTypeReferenceImpl	HelloWorld
unknown	spoon.support.reflect.code.CtTypeAccessImpl	HelloWorld
unknown	spoon.support.reflect.reference.CtPackageReferenceImpl	
unknown	spoon.support.reflect.reference.CtTypeReferenceImpl	HelloWorld
unknown	spoon.support.reflect.reference.CtPackageReferenceImpl	java.lang
unknown	spoon.support.reflect.reference.CtTypeReferenceImpl	java.lang.String
unknown	spoon.support.reflect.reference.CtFieldReferenceImpl	java.lang.String HelloWorld#HELLO
(/home/tester/spoon/HelloWorld.java:5)	spoon.support.reflect.code.CtFieldReadImpl	java.lang.String HelloWorld#HELLO
(/home/tester/spoon/HelloWorld.java:5)	spoon.support.reflect.code.CtInvocationImpl	(java.io.PrintStream#println(java.lang.String)(java.lang.String HelloWorld#HELLO))
(/home/tester/spoon/HelloWorld.java:4)	spoon.support.reflect.code.CtBlockImpl	{
(java.io.PrintStream#println(java.lang.String)(java.lang.String HelloWorld#HELLO));
}
(/home/tester/spoon/HelloWorld.java:4)	spoon.support.reflect.declaration.CtMethodImpl	void main(java.lang.String[])
(/home/tester/spoon/HelloWorld.java:1)	spoon.support.reflect.declaration.CtClassImpl	class HelloWorld
unknown	spoon.reflect.CtModelImpl$CtRootPackage	
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Procesor zjišťující všechny deklarované třídy</h2>

<p>Procesory ve skutečnosti nemusí zpracovávat všechny typy elementů, ale je
možné provádět různé formy filtrace. Nejjednodušší filtrace je zajištěna
explicitním určením typů elementů &ndash; namísto obecného rozhraní
<strong>CtElement</strong> lze zvolit konkrétní typ elementu či množinu
elementů z&nbsp;následujícího seznamu rozhraní: CtAbstractInvocation,
CtAnnotation, CtAnnotationFieldAccess, CtAnnotationMethod, CtAnnotationType,
CtAnonymousExecutable, CtArrayAccess, CtArrayRead, CtArrayTypeReference,
CtArrayWrite, CtAssert, CtAssignment, CtBinaryOperator, CtBlock, CtBreak,
CtCase, CtCatch, CtCatchVariable, CtCatchVariableReference, CtCFlowBreak,
CtClass, CtCodeElement, CtCodeSnippetExpression, CtCodeSnippetStatement,
CtComment, CtConditional, CtConstructor, CtConstructorCall, CtContinue, CtDo,
CtEnum, CtEnumValue, CtExecutable, CtExecutableReference,
CtExecutableReferenceExpression, CtExpression, CtField, CtFieldAccess,
CtFieldRead, CtFieldReference, CtFieldWrite, CtFor, CtForEach,
CtFormalTypeDeclarer, CtIf, CtInterface, CtIntersectionTypeReference,
CtInvocation, CtLambda, CtLiteral, CtLocalVariable, CtLocalVariableReference,
CtLoop, CtMethod, CtModifiable, CtMultiTypedElement, CtNamedElement,
CtNewArray, CtNewClass, CtOperatorAssignment, CtPackage, CtPackageReference,
CtParameter, CtParameterReference, CtReference, CtReturn, CtStatement,
CtStatementList, CtSuperAccess, CtSwitch, CtSynchronized, CtTargetedExpression,
CtThisAccess, CtThrow, CtTry, CtTryWithResource, CtType, CtTypeAccess,
CtTypedElement, CtTypeMember, CtTypeParameter, CtTypeParameterReference,
CtTypeReference, CtUnaryOperator, CtUnboundVariableReference, CtVariable,
CtVariableAccess, CtVariableRead, CtVariableReference, CtVariableWrite,
CtWhile, CtWildcardReference.</p>

<p>Rozhraní tvoří hierarchii, například CtElement &rarr; CtLoop &rarr; CtDo,
CtFor, CtForEach, CtWhile atd.</p>

<p>Podívejme se nyní na praktický příklad. Bude se jednat o procesor, který
vypíše všechny deklarované třídy nalezené ve zpracovávaném zdrojovém kódu.
V&nbsp;procesoru jsou provedeny dvě změny. Nejprve uvedeme typ zpracovávaných
elementů v&nbsp;deklaraci třídy (namísto <strong>extends
AbstractProcessor</strong> zapíšeme konkrétně <strong>extends
AbstractProcessor&lt;CtClass&gt;</strong> a metoda <strong>process</strong> je
upravena takovým způsobem, že zpracovává elementy typu <strong>CtClass</strong>
a nikoli <strong>CtElement</strong>, takže se vyhneme zbytečnému
přetypování:</p>

<pre>
import spoon.processing.AbstractProcessor;
import spoon.reflect.declaration.CtClass;
import spoon.reflect.cu.SourcePosition;
&nbsp;
public class ListClassesProcessor extends AbstractProcessor&lt;CtClass&gt; {
    public void process(CtClass element) {
        SourcePosition sp = element.getPosition();
        String position = sp == null ? "unknown" : sp.toString();
        System.out.println(position + "\t" + element.getSimpleName());
    }
}
</pre>

<p>Překlad procesoru provedeme nám již známým příkazem:</p>

<pre>
javac -cp spoon-core-5.3.0-jar-with-dependencies.jar ListClassesProcessor.java
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Otestování třetího procesoru</h2>

<p>Nejprve nový procesor otestujeme na naší známé třídě
<strong>EmptyClass</strong>:</p>

<pre>
<strong>java -cp .:spoon-core-5.3.0-jar-with-dependencies.jar spoon.Launcher -p ListClassesProcessor -i EmptyClass.java</strong>
&nbsp;
(/home/tester/spoon/HelloWorld.java:1)       HelloWorld
</pre>

<p>Nic překvapivého se nevypsalo, ale můžeme zde vidět, že správnou filtrací
lze dosáhnout mnohem uspokojivějších výsledků.</p>

<p>Zkusme tedy něco složitějšího, a to konkrétně následující zdrojový kód
s&nbsp;několika top-level třídami a vnořenými třídami:</p>

<pre>
public class ManyClasses {
    class InnerClass {
    }
    class OtherInnerClass {
        class NestedClass {
        }
    }
}
&nbsp;
class OtherClass {
}
&nbsp;
class YetAnotherClass {
}
</pre>

<p>Spusťme náš nový procesor:</p>

<pre>
<strong>java -cp .:spoon-core-5.3.0-jar-with-dependencies.jar spoon.Launcher -p ListClassesProcessor -i ManyClasses.java</strong>
&nbsp;
(/home/tester/spoon/ManyClasses.java:2)      InnerClass
(/home/tester/spoon/ManyClasses.java:5)      NestedClass
(/home/tester/spoon/ManyClasses.java:4)      OtherInnerClass
(/home/tester/spoon/ManyClasses.java:1)      ManyClasses
(/home/tester/spoon/ManyClasses.java:10)     OtherClass
(/home/tester/spoon/ManyClasses.java:13)     YetAnotherClass
</pre>

<p>Povšimněte si způsobu výpisu &ndash; první třída obsahující dvě vnitřní
třídy je vypsána až na čtvrtém místě, tj.&nbsp;ve chvíli, kdy má procesor šanci
správně zpracovat všechny vnitřní třídy.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Procesor detekující zápisy do proměnných</h2>

<p>Všechny tři předchozí procesory vlastně ukazovaly pouze nepatrnou část
možností knihovny Spoon. Podívejme se na složitější a možná již praktičtější
příklad. Budeme v&nbsp;něm hledat všechna místa v&nbsp;programovém kódu,
v&nbsp;nichž se zapisuje do proměnných. Pro každou operaci zápisu, kterou
nalezneme, vypíšeme jak pozici ve zdrojovém kódu, tak i jméno proměnné. Náš
procesor nyní bude filtrovat jen elementy typu <strong>CtVariableWrite</strong>
a nikoli všechny elementy <strong>CtElement</strong>. Dále pro každý nalezený
element v&nbsp;AST přečteme, o jakou se jedná proměnnou. Objekt představující
referenci na proměnnou v&nbsp;AST má typ <strong>CtVariableReference</strong>,
nás ovšem v&nbsp;tuto chvíli zajímá pouze jeho metoda
<strong>getSimpleName()</strong>. Výsledná implementace procesoru může vypadat
takto:</p>

<pre>
import spoon.processing.AbstractProcessor;
import spoon.reflect.code.CtVariableWrite;
import spoon.reflect.reference.CtVariableReference;
import spoon.reflect.cu.SourcePosition;
&nbsp;
public class VariableWriteProcessor extends AbstractProcessor&lt;CtVariableWrite&gt; {
    public void process(CtVariableWrite element) {
        SourcePosition sp = element.getPosition();
        CtVariableReference variable = element.getVariable();
        String variableName = variable.getSimpleName();
        String position = sp == null ? "unknown" : sp.toString();
        System.out.println("write into variable '" + variableName + "' at " + position);
    }
}
</pre>

<p>Příkaz pro překlad procesoru již známe:</p>

<pre>
javac -cp spoon-core-5.3.0-jar-with-dependencies.jar VariableWriteProcessor.java
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Otestování čtvrtého procesoru</h2>

<p>Pro otestování čtvrtého procesoru použijeme třídu
<strong>Operators</strong>, s&nbsp;níž jsme se již seznámili <a href="#k03">ve
třetí kapitole</a> (v&nbsp;ní je zobrazena část AST této třídy):</p>

<pre>
public class Operators {
    public static void main(String[] args) {
        int x, y, z;
        x = 10;
        y = 2 * x;
        z = y + x / 3 * (x + y);
    }
}
</pre>

<p>Zkusme nyní nalézt všechny zápisy do proměnných ve třídě
<strong>Operators</strong>:</p>

<pre>
java -cp .:spoon-core-5.3.0-jar-with-dependencies.jar spoon.Launcher -p VariableWriteProcessor -i Operators.java
</pre>

<p>Zde je výsledek, který je již na první pohled korektní:</p>

<pre>
write into variable 'x' at (/home/tester/spoon/Operators.java:4)
write into variable 'y' at (/home/tester/spoon/Operators.java:5)
write into variable 'z' at (/home/tester/spoon/Operators.java:6)
</pre>

<p>Poznámka: tento procesor nedokáže (a ani nemá dokázat) zobrazit deklaraci
proměnné s&nbsp;přiřazením.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Zdrojové kódy všech procesorů i testovaných příkladů</h2>

<table>
<tr><th>Zdrojový kód</th><th>Adresa</th></tr>
<tr><td>FirstProcessor.java</td><td><a href="https://github.com/tisnik/presentations/blob/master/spoon/FirstProcessor.java">https://github.com/tisnik/presentations/blob/master/spoon/FirstProcessor.java</a></td></tr>
<tr><td>compile_FirstProcessor.sh</td><td><a href="https://github.com/tisnik/presentations/blob/master/spoon/compile_FirstProcessor.sh">https://github.com/tisnik/presentations/blob/master/spoon/compile_FirstProcessor.sh</a></td></tr>
<tr><td>run_FirstProcessor.sh</td><td><a href="https://github.com/tisnik/presentations/blob/master/spoon/run_FirstProcessor.sh">https://github.com/tisnik/presentations/blob/master/spoon/run_FirstProcessor.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>ListSourcePositionProcessor.java</td><td><a href="https://github.com/tisnik/presentations/blob/master/spoon/ListSourcePositionProcessor.java">https://github.com/tisnik/presentations/blob/master/spoon/ListSourcePositionProcessor.java</a></td></tr>
<tr><td>compile_ListSourcePositionProcessor.sh</td><td><a href="https://github.com/tisnik/presentations/blob/master/spoon/compile_ListSourcePositionProcessor.sh">https://github.com/tisnik/presentations/blob/master/spoon/compile_ListSourcePositionProcessor.sh</a></td></tr>
<tr><td>run_ListSourcePositionProcessor.sh</td><td><a href="https://github.com/tisnik/presentations/blob/master/spoon/run_ListSourcePositionProcessor.sh">https://github.com/tisnik/presentations/blob/master/spoon/run_ListSourcePositionProcessor.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>ListClassesProcessor.java</td><td><a href="https://github.com/tisnik/presentations/blob/master/spoon/ListClassesProcessor.java">https://github.com/tisnik/presentations/blob/master/spoon/ListClassesProcessor.java</a></td></tr>
<tr><td>compile_ListClassesProcessor.sh</td><td><a href="https://github.com/tisnik/presentations/blob/master/spoon/compile_ListClassesProcessor.sh">https://github.com/tisnik/presentations/blob/master/spoon/compile_ListClassesProcessor.sh</a></td></tr>
<tr><td>run_ListClassesProcessor.sh</td><td><a href="https://github.com/tisnik/presentations/blob/master/spoon/run_ListClassesProcessor.sh">https://github.com/tisnik/presentations/blob/master/spoon/run_ListClassesProcessor.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>VariableWriteProcessor.java</td><td><a href="https://github.com/tisnik/presentations/blob/master/spoon/VariableWriteProcessor.java">https://github.com/tisnik/presentations/blob/master/spoon/VariableWriteProcessor.java</a></td></tr>
<tr><td>compile_VariableWriteProcessor.sh</td><td><a href="https://github.com/tisnik/presentations/blob/master/spoon/compile_VariableWriteProcessor.sh">https://github.com/tisnik/presentations/blob/master/spoon/compile_VariableWriteProcessor.sh</a></td></tr>
<tr><td>run_VariableWriteProcessor.sh</td><td><a href="https://github.com/tisnik/presentations/blob/master/spoon/run_VariableWriteProcessor.sh">https://github.com/tisnik/presentations/blob/master/spoon/run_VariableWriteProcessor.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>EmptyClass.java</td><td><a href="https://github.com/tisnik/presentations/blob/master/spoon/EmptyClass.java">https://github.com/tisnik/presentations/blob/master/spoon/EmptyClass.java</a></td></tr>
<tr><td>HelloWorld.java</td><td><a href="https://github.com/tisnik/presentations/blob/master/spoon/HelloWorld.java">https://github.com/tisnik/presentations/blob/master/spoon/HelloWorld.java</a></td></tr>
<tr><td>ManyClasses.java</td><td><a href="https://github.com/tisnik/presentations/blob/master/spoon/ManyClasses.java">https://github.com/tisnik/presentations/blob/master/spoon/ManyClasses.java</a></td></tr>
<tr><td>Operators.java</td><td><a href="https://github.com/tisnik/presentations/blob/master/spoon/Operators.java">https://github.com/tisnik/presentations/blob/master/spoon/Operators.java</a></td></tr>
</table>



<p><a name="k13"></a></p>
<h2 id="k13">13. Použité třídy a rozhraní knihovny Spoon</h2>

<ol>

<li>spoon.processing.AbstractProcessor<br />
<a href="http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/processing/AbstractProcessor.html">http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/processing/AbstractProcessor.html</a>
</li>

<li>spoon.reflect.declaration.CtElement<br />
<a href="http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/reflect/declaration/CtElement.html">http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/reflect/declaration/CtElement.html</a>
</li>

<li>spoon.reflect.declaration.CtClass<br />
<a href="http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/reflect/declaration/CtClass.html">http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/reflect/declaration/CtClass.html</a>
</li>

<li>spoon.reflect.code.CtVariableWrite<br />
<a href="http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/reflect/code/CtVariableWrite.html">http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/reflect/code/CtVariableWrite.html</a>
</li>

<li>spoon.reflect.cu.SourcePosition<br />
<a href="http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/reflect/cu/SourcePosition.html">http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/reflect/cu/SourcePosition.html</a>
</li>

<li>spoon.reflect.reference.CtVariableReference<br />
<a href="http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/reflect/reference/CtVariableReference.html">http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/spoon/reflect/reference/CtVariableReference.html</a>
</li>

</ol>



<p><a name="k14"></a></p>
<h2 id="k14">14. Obsah druhé části článku</h2>

<p>Dnes jsme si ukázali pouze naprosté základy nabízené knihovnou Spoon. Příště
se seznámíme se složitějšími procesory a taktéž s&nbsp;takzvanými šablonami,
které lze využít pro automatizaci různých transformací zdrojového kódu.</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Odkazy na Internetu</h2>

<ol>

<li>Spoon - Source Code Analysis and Transformation for Jav<br />
<a href="http://spoon.gforge.inria.fr/">http://spoon.gforge.inria.fr/</a>
</li>

<li>Project Filelist for Spoon<br />
<a href="https://gforge.inria.fr/frs/?group_id=73">https://gforge.inria.fr/frs/?group_id=73</a>
</li>

<li>Spoon na GitHubu<br />
<a href="https://github.com/INRIA/spoon">https://github.com/INRIA/spoon</a>
</li>

<li>Instance Jenkinsu, v níž se překládá Spoon<br />
<a href="https://ci.inria.fr/sos/">https://ci.inria.fr/sos/</a>
</li>

<li>JavaParser: Java Parser and Abstract Syntax Tree<br />
<a href="http://javaparser.org/">http://javaparser.org/</a>
</li>

<li>Javaparser na GitHubu<br />
<a href="https://github.com/javaparser/javaparser">https://github.com/javaparser/javaparser</a>
</li>

<li>FindBugs Fact Sheet<br />
<a href="http://findbugs.sourceforge.net/factSheet.html">http://findbugs.sourceforge.net/factSheet.html</a>
</li>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojů využívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (před verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

<li>Abstract syntax tree<br />
<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">https://en.wikipedia.org/wiki/Abstract_syntax_tree</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

