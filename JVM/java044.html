<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Clojure 13: pøeklad programù z Clojure do bajtkódu JVM (pokraèování)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Clojure 13: pøeklad programù z Clojure do bajtkódu JVM (pokraèování)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o virtuálním stroji Javy se budeme zabývat stejným tématem jako v èásti pøedchozí &ndash; øekneme si dal¹í informace o tom, jakým zpùsobem se pøekládají aplikace naprogramované v Clojure do bajtkódu JVM. Jeden z problémù, které je nutné øe¹it, spoèívá v tom, jak do Clojure vnést informaci o datových typech.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyk Clojure 13: pøeklad programù z Clojure do bajtkódu JVM (pokraèování)</a></p>
<p><a href="#k02">2. Tvorba tøíd v&nbsp;Clojure a jejich pøeklad do bajtkódu (makro gen-class)</a></p>
<p><a href="#k03">3. Vyu¾ití prefixù u názvù funkcí</a></p>
<p><a href="#k04">4. Staticky definované datové typy v&nbsp;dynamicky typovaném programovacím jazyce?</a></p>
<p><a href="#k05">5. Tvorba metod z&nbsp;funkcí</a></p>
<p><a href="#k06">6. Informace o typech pøedávaných parametrù i o návratovém typu metody</a></p>
<p><a href="#k07">7. Rozhraní clojure.lang.IFn a dal¹í magie skrytá pod povrchem</a></p>
<p><a href="#k08">8. Statické metody</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk Clojure 13: pøeklad programù z Clojure do bajtkódu JVM (pokraèování)</h2>

<p>V&nbsp;pøedchozí èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o Javì
i o virtuálním stroji Javy</a> jsme si øekli základní informace o zpùsobu
pøekladu aplikací naprogramovaných v&nbsp;<i>Clojure</i> do bajtkódu JVM.
Pøipomeòme si, ¾e pøeklad lze provést nìkolika zpùsoby. V&nbsp;prùbìhu vývoje
je nejèastìji provádìn pøeklad s&nbsp;generováním bajtkódu pøímo ve virtuálním
stroji Javy, co¾ znamená, ¾e se nevytváøí ¾ádné externí soubory
s&nbsp;bajtkódem, které by bylo mo¾né prozkoumat èi pøenést na poèítaèe
u¾ivatelù. Z&nbsp;tohoto dùvodu je pro úèely distribuce aplikace a/nebo
nasazení aplikace vìt¹inou vhodnìj¹í vedle zdrojových kódù dodávat i explicitnì
pøelo¾enou aplikaci, a to buï ve formì souborù <strong>.class</strong>
s&nbsp;bajtkódem, nebo alternativnì ve formì Java archivu
(<strong>.jar</strong>) èi webového archivu (<strong>.war</strong>) &ndash;
tyto archivy toti¾ kromì dal¹ích souborù obsahují právì pøelo¾ený bajtkód.
Existuje je¹tì tøetí zpùsob pøekladu &ndash; vytváøení tøíd a k&nbsp;nim
pøíslu¹ných souborù <strong>.class</strong> pøímo za bìhu aplikace pøes proxy
tøídy, co¾ je varianta, kterou lze v&nbsp;samotné Javì napodobit jen velmi
neohrabanì s&nbsp;vyu¾itím classloaderù a tøídy
<strong>java.lang.Compiler</strong>.</p>

<p>Minule jsme si takté¾ ukazovali, jak se &bdquo;explicitní&ldquo; pøeklad
funkcí (prozatím skuteènì pouze funkcí) provádí prakticky. V&nbsp;souèasné
verzi programovacího jazyka <i>Clojure</i> je mo¾né pøelo¾it pouze kód ulo¾ený
ve zdrojovém souboru, nelze tedy napøíklad pøímo v&nbsp;interpretru pøelo¾it
jednu zvolenou funkci atd. (výjimkou je pøeklad vyu¾ívající ji¾ zmínìnou proxy
tøídu; tento zpùsob bude popsaný pøí¹tì). V&nbsp;nejjednodu¹¹ím pøípadì, pokud
tedy prozatím nebudeme vytváøet tøídy umístìné v&nbsp;balíècích, je mo¾né mít
soubory se zdrojovými texty ulo¾ené v&nbsp;podadresáøi nazvaném
<strong>classes</strong>. Tyto soubory by mìly mít koncovku
<strong>.clj</strong> a na zaèátku ka¾dého souboru by mìla být uvedena
specifikace jmenného prostoru s&nbsp;názvem odpovídajícím jménu souboru se
zdrojovým textem. Následující zdrojový text by tedy mìl být ulo¾ený
v&nbsp;souboru se jménem <strong>classes/AddTest1.clj</strong>:</p>

<pre>
(ns AddTest1)
&nbsp;
(defn add
    [x y]
    (+ x y))
</pre>

<p>Pøeklad tohoto zdrojového textu do bajtkódu JVM se provede z&nbsp;adresáøe,
v&nbsp;nìm¾ je umístìn vý¹e zmínìný podadresáø <strong>classes</strong>.
V&nbsp;tomto adresáøi je pro co nejvìt¹í jednoduchost (snadné nastavení
CLASSPATH) ulo¾en i archiv <strong>clojure-1.4.0.jar</strong>,
popø.&nbsp;symbolický link na tento archiv. Struktura celého pracovního
adresáøe by mohla vypadat následovnì:</p>

<pre>
|   clojure-1.4.0.jar
|
\---classes
        AddTest1.clj
</pre>

<p>Pøeklad programu <strong>AddTest1</strong> do bajtkódu se provede tak, ¾e se
nejdøíve spustí interpret programovacího jazyka <i>Clojure</i> s&nbsp;tím, ¾e
se na CLASSPATH pøidá i podadresáø <strong>classes</strong>:</p>

<pre>
java -cp .;classes;clojure-1.4.0.jar clojure.main
</pre>

<p>Jakmile se interpret spustí, postaèí zadat jediný pøíkaz spou¹tìjící
pøeklad:</p>

<pre>
user=&gt; <strong>(compile 'AddTest1)</strong>
AddTest1
user=&gt;
</pre>

<p>V&nbsp;podadresáøi <strong>classes</strong> by se mìly vytvoøit tøi nové
soubory, tak¾e se celá struktura pracovního adresáøe zmìní takto:</p>

<pre>
|   clojure-1.4.0.jar
|
\---classes
        AddTest1$add.class
        AddTest1$loading__4784__auto__.class
        AddTest1.clj
        AddTest1__init.class
</pre>

<p>Struèný význam jednotlivých souborù ulo¾ených v&nbsp;podadresáøi
<strong>classes</strong>:</p>

<table>
<tr><th>#</th><th>Soubor</th><th>Velikost</th><th>Popis</th></tr>
<tr><td>1</td><td>AddTEst1.clj</td><td>  55</td><td>zdrojový kód pøíkladu v&nbsp;Clojure</td></tr>
<tr><td>2</td><td>AddTest1__init.class</td><td>2369</td><td>pomocné metody vyu¾ívané &bdquo;interpretrem&ldquo;</td></tr>
<tr><td>3</td><td>AddTest1$loading__4784__auto__.class</td><td>1492 </td><td>pomocné metody vyu¾ívané &bdquo;interpretrem&ldquo;</td></tr>
<tr><td>4</td><td>AddTest1$add.class</td><td> 884</td><td>metoda add a tøída, která tuto metodu obaluje</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Tvorba tøíd v&nbsp;Clojure a jejich pøeklad do bajtkódu (makro gen-class)</h2>

<p>Pøeklad demonstraèního pøíkladu <strong>AddTest1</strong>, s&nbsp;ním¾ jsme
se seznámili <a href="#k01">v&nbsp;pøedchozí kapitole</a>, sice skuteènì vedl
k&nbsp;vytvoøení nìkolika souborù <strong>.class</strong> a tedy i
k&nbsp;vytvoøení nìkolika javovských tøíd, ov¹em ve skuteènosti v&nbsp;tomto
pøípadì pøekladaè pouze vygeneroval pro ka¾dou definovanou funkci samostatnou
tøídu obalující pøíslu¹nou metodu. K&nbsp;funkci nazvané <strong>add</strong>,
která byla definována ve jmenném prostoru <strong>AddTest1</strong> tedy byla
vytvoøena tøída nazvaná <strong>AddTest1$add</strong>, co¾ pøesnì odpovídá
jmenným konvencím Javy. Pro zajímavost se mù¾eme podívat na vnitøní strukturu
této tøídy. Vzhledem k&nbsp;tomu, ¾e vygenerovaný bajtkód je plnohodnotným
bajtkódem JVM, lze pro zji¹tìní jeho vnitøní struktury pou¾ít libovolný
(vhodný) nástroj, napøíklad nástroj <strong>javap</strong>, s&nbsp;ním¾ jsme se
ji¾ v&nbsp;tomto seriálu nìkolikrát setkali. Pøipomeòme si, ¾e tento nástroj je
standardní souèástí ka¾dé instalace JDK:</p>

<pre>
% javap AddTest1$add
&nbsp;
Compiled from "AddTest1.clj"
public final class AddTest1$add extends clojure.lang.AFunction{
    public static final clojure.lang.Var const__0;
    public static {};
    public AddTest1$add();
    <strong>public java.lang.Object invoke(java.lang.Object, java.lang.Object);</strong>
}
</pre>

<p>Na¹e funkce pùvodnì nazvaná <strong>add</strong> se ve skuteènosti bude
volat nepøímo pøes metodu <strong>Object invoke(Object, Object)</strong>. Toto
chování pøekladaèe <i>Clojure</i> sice docela dobøe odpovídá filozofii
funkcionálního programovacího jazyka (obecné &bdquo;beztypové&ldquo;
parametry), ale v&nbsp;praxi budeme vìt¹inou potøebovat generovat
&bdquo;skuteèné&ldquo; Javovské tøídy a budeme tedy muset vyøe¹it minimálnì dva
problémy &ndash; jak slouèit nìkolik funkcí do jediné tøídy (a udìlat
z&nbsp;tìchto funkcí statické èi nestatické metody) a jak nahradit obecné
metody typu <strong>Object invoke(Object, Object)</strong> za metody
s&nbsp;pøesnìji specifikovanými datovými typy. Obì tyto problematiky lze
v&nbsp;programovacím jazyce <i>Clojure</i> samozøejmì øe¹it, i kdy¾ se popravdì
øeèeno nejedná o øe¹ení elegantní: je zde patrné, ¾e vzájemná kooperace mezi
objektovì orientovaným staticky typovaným jazykem a dynamicky typovaným
funkcionálním jazykem je sice mo¾ná, ale nikoli zcela automatická. Nejprve si
uka¾me, jak se vytváøí &bdquo;skuteèné&ldquo; tøídy. Pro tyto úèely se pou¾ívá
témìø v¹emocné makro nazvané <strong>gen-class</strong>.</p>

<p>V&nbsp;následujícím demonstraèním pøíkladu je makro
<strong>gen-class</strong> voláno v&nbsp;rámci zpracování makra
<strong>ns</strong>, co¾ je obvyklé doporuèované øe¹ení. Makro
<strong>gen-class</strong> mù¾e mít velké mno¾ství volitelných parametrù,
z&nbsp;nich¾ my pou¾ijeme prozatím pouze parametry dva &ndash; urèení jména
tøídy (<strong>:name "AddTest2"</strong>) a zaji¹tìní vygenerování metody
<strong>main</strong> (<strong>:main true</strong>). Ve zdrojovém kódu je navíc
definována i funkce <strong>-main</strong> pøekládaná do metody
<strong>main</strong>. Znak pomlèky na zaèátku názvu této metody nebyl zapsán
omylem, jeho význam si vysvìtlíme v&nbsp;navazující kapitole:</p>

<pre>
(ns AddTest2 (
    :gen-class
    :name "AddTest2"
    :main true))
&nbsp;
(defn -main
    []
    (println "Hello world!"))
</pre>

<p>Pøeklad se provede stejným postupem, jako tomu bylo i u pøedchozího
demonstraèního pøíkladu:</p>

<pre>
% java -cp .;classes;clojure-1.4.0.jar clojure.main
&nbsp;
user=&gt; <strong>(compile 'AddTest2)</strong>
AddTest2
user=&gt;
</pre>

<p>V&nbsp;adresáøi <strong>classes</strong> by nyní mìlo být ulo¾eno i tìchto
pìt souborù:</p>

<table>
<tr><th>#</th><th>Soubor</th><th>Velikost</th></tr>
<tr><td>1</td><td>AddTest2.clj</td><td> 128</td></tr>
<tr><td>2</td><td>AddTest2__init.class</td><td>2325</td></tr>
<tr><td>3</td><td>AddTest2$loading__4784__auto__.class</td><td>1494</td></tr>
<tr><td>4</td><td>AddTest2$_main.class</td><td> 848</td></tr>
<tr><td>5</td><td>AddTest2.class</td><td>1744</td></tr>
</table>
 
<p>Vzhledem k&nbsp;tomu, ¾e ve tøídì <strong>AddTest2.class</strong> je
definována i metoda <strong>public static void main(String[])</strong>, mù¾eme
tuto metodu ihned po inicializaci virtuálního stroje spustit, a to prakticky
stejnì, jako jakoukoli jinou aplikaci napsanou v&nbsp;Javì (pouze stále
potøebujeme mít archiv <strong>clojure*.jar</strong> ulo¾en na CLASSPATH):</p>

<pre>
% java -cp .;classes;clojure-1.4.0.jar AddTest2
Hello world!
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Vyu¾ití prefixù u názvù funkcí</h2>

<p>V&nbsp;demonstraèním pøíkladu <a href="#k02">z&nbsp;pøedchozí kapitoly</a>
byl pøed názvem funkce <strong>main</strong> uveden znak pomlèky, který byl
nedílnou souèástí tohoto názvu. Jedná se o takzvaný prefix pou¾ívaný pro
poloautomatické zaèleòování funkcí do vytváøených tøíd, kde se z&nbsp;funkcí
stanou plnohodnotné statické èi nestatické metody. Pokud vám nevyhovuje
implicitní prefix <strong>-</strong> (tj.&nbsp;ona pomlèka), je samozøejmì
mo¾né ho zmìnit a to s&nbsp;vyu¾itím nepovinného parametru
<strong>:prefix</strong> pøedaného makru <strong>gen-class</strong>.
V&nbsp;dne¹ním tøetím demonstraèním pøíkladu je tento parametr pou¾it
s&nbsp;hodnotou (øetìzcem) &bdquo;implementation-&ldquo;, co¾ samozøejmì
znamená, ¾e se musel zmìnit i název funkce <strong>main</strong>
z&nbsp;<strong>-main</strong> (prefixem je jen pomlèka) na
<strong>implementation-main</strong> (prefixem je slovo
&bdquo;implementation&ldquo; následované pomlèkou):</p>

<pre>
(ns AddTest3 (
    :gen-class
    :name "AddTest3"
    :main true
    :prefix "implementation-"))
&nbsp;
(defn implementation-main
    []
    (println "Hello world!"))
</pre>

<p>Pøeklad tohoto demonstraèního pøíkladu se provede naprosto stejným zpùsobem,
jako tomu bylo v&nbsp;pøedchozím demonstraèním pøíkladu (v&nbsp;dal¹ích
kapitolách u¾ si tuto informaci nebudeme uvádìt, ale pro jednoduchost
pøedpokládejme, ¾e v¹echny zdrojové kódy budou v¾dy umístìny v&nbsp;podadresáøi
<strong>classes</strong>):</p>

<pre>
% java -cp .;classes;clojure-1.4.0.jar clojure.main
&nbsp;
user=&gt; <strong>(compile 'AddTest3)</strong>
AddTest3
user=&gt;
</pre>

<p>Výsledkem pøekladu je ètveøice nových souborù obsahujících bajtkód a
v&nbsp;následující tabulce jsou pro porovnání uvedena jména a velikosti souborù
s&nbsp;bajtkódem vygenerovaným pro demonstraèní pøíklad
<strong>AddTest2</strong> i pro pøíklad <strong>AddTest3</strong>. Pov¹imnìte
si, ¾e zmìny postihly název bajtkódu s&nbsp;implementací funkce
<strong>main</strong>, zatímco dal¹ích pomocných tøíd se zmìny prakticky
nedotkly:</p>

<table>
<tr><th>#</th><th>Soubor (AddTest2)</th><th>Velikost (AddTest2)</th><th>Soubor (AddTest3)</th><th>Velikost (AddTest3)</th></tr>
<tr><td>1</td><td>AddTest2.clj</td><td> 128</td><td>AddTest3.clj</td><td> 173</td></tr>
<tr><td>2</td><td>AddTest2__init.class</td><td>2325</td><td>AddTest3__init.class</td><td>2353</td></tr>
<tr><td>3</td><td>AddTest2$loading__4784__auto__.class</td><td>1494</td><td>AddTest3$loading__4784__auto__.class</td><td>1494</td></tr>
<tr><td>4</td><td>AddTest2$_main.class</td><td> 848</td><td>AddTest3$_main.class</td><td> 862</td></tr>
<tr><td>5</td><td>AddTest2.class</td><td>1744</td><td>AddTest3.class</td><td>1828</td></tr>
</table>

<p>Zajímavìj¹í ne¾ porovnání bajtkódù vzniklých pøekladem obou demonstraèních
pøíkladù v¹ak bude interní struktura tøídy <strong>AddTest3.class</strong>:</p>

<pre>
% javap AddTest3
&nbsp;
public class AddTest3 extends java.lang.Object{
    public static {};
    public AddTest3();
    public java.lang.String toString();
    public boolean equals(java.lang.Object);
    public java.lang.Object clone();
    public int hashCode();
    <strong>public static void main(java.lang.String[]);</strong>
}
</pre>

<p>Z&nbsp;pøedchozího výpisu je patrné, ¾e se v&nbsp;této tøídì skuteènì
nachází metoda <strong>public static void main(String[])</strong> &ndash; tudí¾
je mo¾né tuto metodu spustit po startu JVM &ndash; a navíc jsou v&nbsp;této
tøídì &bdquo;poctivì&ldquo; implementovány i metody
<strong>toString()</strong>, <strong>equals()</strong>,
<strong>hashCode()</strong> a <strong>clone()</strong> získané pøekrytím metod
se stejnou signaturou, které jsou deklarovány ve tøídì <strong>Object</strong>,
tedy ve tøídì pøedstavující koøen stromu tøídní hierarchie Javy. Pokud se v¹ak
podíváme na obsah tìchto pøekrytých metod, zjistíme, ¾e se v&nbsp;nich ve
skuteènosti volá nìkterá z&nbsp;forem metody <strong>Object
invoke(Object...)</strong> definované v&nbsp;rozhraní
<strong>clojure.lang.IFn</strong>, co¾ znamená nutnost pøetypování výsledku
atd. To je daò, kterou platíme za to, ¾e se sna¾íme pou¾ívat bajtkód navr¾ený
pro staticky typovaný jazyk. Dal¹í informace o této problematice si øekneme
v&nbsp;navazujících kapitolách.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Staticky definované datové typy v&nbsp;dynamicky typovaném programovacím jazyce?</h2>

<div class="rs-box"><p>Dále uvedené informace není v&nbsp;¾ádném pøípadì nutné
znát pro to, abyste byli schopni vytváøet v&nbsp;Clojure skuteèné tøídy. Jedná
se jen o problematiku, s&nbsp;ní¾ musí bojovat a nìjak ji vyøe¹it v¹ichni
tvùrci dynamicky typovaných programovacích jazykù urèených pro bìh nad
virtuálním strojem Javy.</p></div>

<p>Nyní se ji¾ dostáváme k&nbsp;pomìrnì záva¾nému tématu &ndash; jakým zpùsobem
je vlastnì v&nbsp;bajtkódu zaøízeno volání funkcí (èi mo¾ná pøesnìji øeèeno
metod) naprogramovaných pùvodnì v&nbsp;<i>Clojure</i>? Nejvìt¹í problém spoèívá
v&nbsp;tom, jak se pracuje s&nbsp;typy parametrù a souèasnì i s&nbsp;typem
návratové hodnoty, proto¾e programovací jazyk Java i jeho bajtkód je navr¾en
s&nbsp;ohledem na to, ¾e se pøi pøedávání parametrù metodám i pøi výpoètu
aritmetických a logických výrazù pou¾ívají primitivní datové typy
(<strong>boolean</strong>, <strong>char</strong>, <strong>byte</strong>,
<strong>short</strong>, <strong>int</strong>, <strong>long</strong>,
<strong>float</strong>, <strong>double</strong>), popø.&nbsp;se pøi volání
metod pøedávají hodnoty referenèního typu, neboli reference na objekty.
Dùle¾itìj¹í v¹ak je, ¾e informace o typech a o poètu parametrù i informace o
typu návratové hodnoty je nedílnou souèástí <i>signatury</i> ka¾dé metody a
tato signatura je ulo¾ena v&nbsp;bajtkódu JVM (je dokonce pøímo èitelná
z&nbsp;<i>constant poolu</i>).</p>

<p>Pøi pøekladu funkcí z&nbsp;<i>Clojure</i> do bajtkódu JVM tedy musí
pøekladaè nìjakým postupem vygenerovat metody se správnou signaturou a to
takovým zpùsobem, aby se stále jednalo o plnohodnotné metody, které je mo¾né
zavolat s&nbsp;libovolným typem parametrù, tj.&nbsp;stejným zpùsobem, jakým
mù¾eme volat funkce v&nbsp;<i>Clojure</i> (poèet parametrù je na druhou stranu
pøesnì zadaný ji¾ ve chvíli, kdy je metoda vytvoøena). My ve skuteènosti
vlastnì ji¾ víme, jak je tento úkol vyøe¹en, proto¾e ji¾ v&nbsp;první kapitole
jsme si ukázali, ¾e následující funkce:</p>

<pre>
(defn add
    [x y]
    (+ x y))
</pre>

<p>se do bajtkódu pøelo¾í jako metoda se signaturou <strong>public
java.lang.Object invoke(java.lang.Object, java.lang.Object);</strong>, která je
umístìna do &bdquo;obalové&ldquo; tøídy, v&nbsp;na¹em pøípadì mající název
<strong>AddTest1$add</strong>:</p>

<pre>
% javap AddTest1$add
&nbsp;
Compiled from "AddTest1.clj"
public final class AddTest1$add extends clojure.lang.AFunction{
    public static final clojure.lang.Var const__0;
    public static {};
    public AddTest1$add();
    <strong>public java.lang.Object invoke(java.lang.Object, java.lang.Object);</strong>
}
</pre>

<p>Metoda <strong>invoke</strong> tedy jako své parametry akceptuje libovolné
dva objekty, co¾ je pøesnì to, co jsme vlastnì zpoèátku po¾adovali, proto¾e
v&nbsp;<i>Clojure</i> je jakákoli numerická hodnota pøedstavována instancí
nìjaké tøídy implementující rozhraní <strong>java.lang.Number</strong>. A
skuteènì &ndash; pokud se podíváme na bajtkód metody <strong>invoke</strong>,
zjistíme, ¾e se jedná o velmi jednoduchou metodu, která ve skuteènosti volá
metodu <strong>clojure.lang.Numbers.add(Object, Object)</strong> (a¾ do této
chvíle je tedy mo¾né pøedat metodì <strong>invoke</strong> jakoukoli dvojici
objektù &ndash; opìt stejnì jako v&nbsp;samotném <i>Clojure</i>!):</p>

<pre>
public java.lang.Object invoke(java.lang.Object, java.lang.Object);
  Code:
   0:   aload_1         ; první parametr na zásobník
   1:   aconst_null     ; pravdìpodobnì jen zaji¹tìní, ¾e se první parametr ji¾ nikde nepou¾ije
   2:   astore_1
   3:   aload_2         ; druhý parametr na zásobník
   4:   aconst_null     ; pravdìpodobnì jen zaji¹tìní, ¾e se první parametr ji¾ nikde nepou¾ije
   5:   astore_2
   6:   invokestatic    #34; //Method clojure/lang/Numbers.add:(Ljava/lang/Objec
t;Ljava/lang/Object;)Ljava/lang/Number;
   9:   areturn
}
</pre>

<p>Jednodu¹e lze zjistit, ¾e tøída <strong>clojure.lang.Numbers</strong>
skuteènì obsahuje metodu <strong>add</strong> s&nbsp;touto signaturou:</p>

<pre>
Compiled from "Numbers.java"
public class clojure.lang.Numbers extends java.lang.Object{
    ...
    <strong>public static java.lang.Number add(java.lang.Object, java.lang.Object);</strong>
    ...
}
</pre>

<p>A¾ v&nbsp;této metodì je v&nbsp;runtime proveden test na skuteèný typ
pøedávaných objektù:</p>

<pre>
public static java.lang.Number add(java.lang.Object, java.lang.Object);
  Code:
   0:   aload_0
   1:   invokestatic    #2; //Method ops:(Ljava/lang/Object;)Lclojure/lang/Numbers$Ops;
   4:   aload_1
   5:   invokestatic    #2; //Method ops:(Ljava/lang/Object;)Lclojure/lang/Numbers$Ops;
   8:   invokeinterface #13,  2; //InterfaceMethod clojure/lang/Numbers$Ops.combine:(Lclojure/lang/Numbers$Ops;)Lclojure/lang/Numbers$Ops;
   13:  aload_0
   <strong>14:  checkcast       #3; //class java/lang/Number</strong>
   17:  aload_1
   <strong>18:  checkcast       #3; //class java/lang/Number</strong>
   21:  invokeinterface #14,  3; //InterfaceMethod clojure/lang/Numbers$Ops.add:(Ljava/lang/Number;Ljava/lang/Number;)Ljava/lang/Number;
   26:  areturn
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Tvorba metod z&nbsp;funkcí</h2>

<p>V&nbsp;této kapitole si uká¾eme, jakým zpùsobem lze do generovaných tøíd
pøidat nové metody, a to dokonce metody, u nich¾ je mo¾né pøesnì specifikovat
typ pøedávaných parametrù i typ návratové hodnoty. Pro pøidání metod do
vytváøené tøídy (resp.&nbsp;pøesnìji øeèeno do bajtkódu odpovídajícího této
tøídì) je nutné pou¾ít dal¹í parametr pøedávaný makru
<strong>gen-class</strong>. Prozatím jsme se v&nbsp;pøedchozích kapitolách
seznámili se tøemi parametry tohoto makra: <strong>:name jméno_tøídy</strong>,
<strong>:main true/false</strong> a <strong>:prefix prefix_funkcí</strong>.
Ètvrtým dùle¾itým parametrem je parametr s&nbsp;názvem
<strong>:methods</strong>, jemu¾ se pøedá <i>vektor</i> obsahující informace o
v¹ech metodách, které se mají do vytváøeného bajtkódu pøidat. Informace o ka¾dé
metodì je takté¾ pøedstavována <i>vektorem</i>, jeho¾ prvním prvkem je název
vygenerované metody (bez prefixu), ve druhém prvku je uvedena specifikace typù
parametrù metody (tøetí vnoøený <i>vektor</i>!) a prvkem tøetím je pak typ
návratové hodnoty metody. Zní to slo¾itì, ¾e? Uka¾me si tedy, jak celý zápis
<strong>:methods</strong> mù¾e vypadat:</p>

<pre>
:methods
[                          ; zaèátek vektoru obsahujícího informace o metodách
&nbsp;
    [                      ; zaèátek vektoru popisujícího metodu se signaturou "long add(long, long)"
        add                ; jméno metody
        [long long]        ; TYP parametrù metody (nikoli názvy tìchto parametrù)
        long               ; návratový typ metody
    ]                      ; konec vektoru popisujícího metodu se signaturou "long add(long, long)"
&nbsp;
    [                      ; zaèátek vektoru popisujícího metodu se signaturou "String add(String, String)"
        add                ; jméno metody
        [String String]    ; TYP parametrù metody (nikoli názvy tìchto parametrù)
        String             ; návratový typ metody
    ]                      ; konec vektoru popisujícího metodu se signaturou "String add(String, String)"
&nbsp;
]                          ; konec vektoru obsahujícího informace o metodách
</pre>

<p>V&nbsp;praxi mù¾e pou¾ití <strong>:methods</strong> vypadat následovnì
&ndash; vytvoøíme novou tøídu nazvanou <strong>AddTest4</strong>, která bude
obsahovat nestatickou metodu <strong>add</strong> akceptující dvojici parametrù
typu <strong>long</strong> a její¾ návratová hodnota bude takté¾
<strong>long</strong>. Tato metoda je pøedepsána funkcí
<strong>implementation-add</strong>, kde nejsou prozatím uvedeny ¾ádné
informace o datových typech, jedná se tedy o obyèejnou funkci
<i>Clojure</i>:</p>

<pre>
(ns AddTest4 (
    :gen-class
    :name "AddTest4"
    :prefix "implementation-"
<strong>    :methods [</strong>
<strong>        [add [long long] long] ]))</strong>
&nbsp;
(defn implementation-add
    [x y]
    (+ x y))
&nbsp;
(defn implementation-main
    []
    (println "Hello world!" (implementation-add 10 20)))
</pre>

<p>Jak tedy bude vypadat struktura vygenerovaného bajtkódu tøídy
<strong>AddTest4</strong>? S&nbsp;vyu¾itím nástroje <strong>javap</strong>
mù¾eme snadno zjistit, ¾e metoda <strong>add</strong> skuteènì byla vytvoøena a
¾e její signatura pøesnì odpovídá na¹emu pøedpisu &ndash; <strong>public long
add(long, long)</strong>:</p>

<pre>
% javap AddTest4
&nbsp;
public class AddTest4 extends java.lang.Object{
    public static {};
    public AddTest4();
    public java.lang.String toString();
    public boolean equals(java.lang.Object);
    public java.lang.Object clone();
    public int hashCode();
    <strong>public long add(long, long);</strong>
    <strong>public static void main(java.lang.String[]);</strong>
}
</pre>

<p>Ztratili jsme v¹ak nìco z&nbsp;obecnosti funkce
<strong>implementation-main</strong>, kterou lze z&nbsp;<i>Clojure</i> volat
s&nbsp;jakoukoli dvojicí èíselných hodnot? Ve skuteènosti tomu tak není,
proto¾e ve tøídì <strong>AddTest4</strong> je sice ulo¾ena metoda
<strong>public long add(long, long);</strong> (viz výpis uvedený pøed tímto
odstavcem), ale kromì toho byl vygenerován i bajtkód tøídy pojmenované
<strong>AddTest4$implementation_add</strong>, v&nbsp;ní¾ je stále ulo¾en obecný
tvar této funkce volané pøes metodu <strong>Object invoke(Object,
Object)</strong>:</p>

<pre>
% javap AddTest4$implementation_add
&nbsp;
Compiled from "AddTest4.clj"
public final class AddTest4$implementation_add extends clojure.lang.AFunction{
    public static final clojure.lang.Var const__0;
    public static {};
    public AddTest4$implementation_add();
    <strong>public java.lang.Object invoke(java.lang.Object, java.lang.Object);</strong>
}
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Informace o typech pøedávaných parametrù i o návratovém typu metody</h2>

<p>V¹echny funkce, které jsme prozatím v&nbsp;<i>Clojure</i> vytváøeli,
obsahovaly pouze informaci o poètu a názvu parametrù tìchto funkcí (tyto údaje
se zapisují do vektoru umístìného ihned za název funkce), nikoli v¹ak ji¾ údaje
o typu parametrù, co¾ dobøe odpovídá zpùsobu zápisu funkcí a/nebo metod
v&nbsp;dynamicky typovaných jazycích. Ve skuteènosti je v¹ak mo¾né i
v&nbsp;dynamicky typovaném jazyku <i>Clojure</i> pøidat k&nbsp;funkcím i
&bdquo;statickou&ldquo; informaci o pøedpokládaných typech parametrù i o typu
návratové hodnoty. Pro tento úèel se pøed jméno parametru popø.&nbsp;za jméno
funkce mù¾e pøidat zápis ve tvaru <strong>^typ</strong>. Demonstraèní pøíklad
uvedený v&nbsp;pøedchozí kapitole tedy mù¾eme je¹tì vylep¹it tím, ¾e u funkce
<strong>implementation_add</strong> urèíme, ¾e oba pøedávané parametry by mìly
být typu <strong>long</strong> a i návratová hodnota by mìla být typu
<strong>long</strong>, co¾ ostatnì pøesnì koresponduje s&nbsp;údaji uvedenými
v&nbsp;parametru <strong>:methods</strong> makra
<strong>gen-class</strong>:</p>

<pre>
(ns AddTest5 (
    :gen-class
    :name "AddTest5"
    :prefix "implementation-"
    :methods [[add [long long] long]]))
&nbsp;
(defn implementation-add <strong>^long</strong>
    [<strong>^long</strong> x <strong>^long</strong> y]
    (+ x y))
&nbsp;
(defn implementation-main
    []
    (println "Hello world!" (implementation-add 10 20)))
</pre>

<p>V&nbsp;bajtkódu vytvoøené a pøelo¾ené tøídy <strong>AddTest5</strong>
nenajdeme ¾ádné &bdquo;novinky&ldquo;, které by nás mohly pøekvapit:</p>

<pre>
% javap AddTest5
&nbsp;
public class AddTest5 extends java.lang.Object{
    public static {};
    public AddTest5();
    public java.lang.String toString();
    public boolean equals(java.lang.Object);
    public java.lang.Object clone();
    public int hashCode();
    <strong>public long add(long, long);</strong>
    <strong>public static void main(java.lang.String[]);</strong>
}
</pre>

<p>Mnohem zajímavìj¹í je v¹ak tøída
<strong>AddTest5$implementation_add</strong>, proto¾e zde oproti pøedchozímu
demonstraènímu pøíkladu do¹lo ke dvìma významným zmìnám. První zmìnou je to, ¾e
tøída novì implementuje rozhraní s&nbsp;ponìkud neobvyklým názvem
<strong>clojure.lang.IF$LLL</strong> a druhou zmìnou je pøidání nové nestatické
metody <strong>long invokePrim(long, long)</strong>:</p>

<pre>
% javap AddTest5$implementation_add
&nbsp;
Compiled from "AddTest5.clj"
public final class AddTest5$implementation_add extends clojure.lang.AFunction
    <i>; novì implementované rozhraní</i>
    <strong>implements clojure.lang.IFn$LLL{</strong>
    public static final clojure.lang.Var const__0;
    public static {};
    public AddTest5$implementation_add();
    <i>; nová metoda vy¾adovaná rozhraním IFn$LLL</i>
    <strong>public final long invokePrim(long, long);</strong>
    <strong>public java.lang.Object invoke(java.lang.Object, java.lang.Object);</strong>
}
</pre>

<p>Podrobnosti o tom, proè vlastnì byla tøída
<strong>AddTest5$implementation_add</strong> vytvoøena pøesnì takovýmto
zpùsobem, si øekneme v&nbsp;navazující kapitole.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Rozhraní clojure.lang.IFn a dal¹í magie skrytá pod povrchem</h2>

<div class="rs-box"><p>V&nbsp;této kapitole jsou opìt uvedeny informace, které
sice není zapotøebí znát pro pou¾ití jazyka <i>Clojure</i> v&nbsp;praxi, ov¹em
souèasnì tyto informace osvìtlují nìkteré aspekty interní struktury
<i>Clojure</i> i dùvod, proè je konstrukce pøekladaèe pro dynamicky typované
jazyky pracující nad JVM relativnì slo¾itá a nìkdy málo elegantní (èásteèné
øe¹ení spoèívá ve vyu¾ití instrukce <strong>invokedynamic</strong>).</p></div>

<p>Podívejme se je¹tì jednou na vygenerovanou tøídu <strong>AddTest5</strong>.
Tato tøída je odvozena od tøídy <strong>clojure.lang.AFunction</strong> a navíc
implementuje rozhraní <strong>IFn$LLL</strong>. V&nbsp;samotné tøídì
<strong>clojure.lang.AFunction</strong> pro nás v&nbsp;tuto chvíli není nic
zajímavého a¾ na informaci, ¾e se jedná o specializaci tøídy
<strong>clojure.lang.AFn</strong>. A¾ tato tøída je zajímavá a to pøedev¹ím
z&nbsp;toho dùvodu, ¾e implementuje rozhraní <strong>clojure.lang.IFn</strong>,
v&nbsp;nìm¾ je pøedepsána celá øada variant metody <strong>invoke</strong>.
Ostatnì se o tom sami pøesvìdète:</p>

<pre>
Compiled from "IFn.java"
public interface clojure.lang.IFn extends java.util.concurrent.Callable,java.lang.Runnable{
    public abstract java.lang.Object invoke();
    public abstract java.lang.Object invoke(java.lang.Object);
    public abstract java.lang.Object invoke(java.lang.Object, java.lang.Object);
    public abstract java.lang.Object invoke(java.lang.Object, java.lang.Object, java.lang.Object);
    public abstract java.lang.Object invoke(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object);
    public abstract java.lang.Object invoke(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object);
    public abstract java.lang.Object invoke(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object);
    public abstract java.lang.Object invoke(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object);
    public abstract java.lang.Object invoke(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object);
    public abstract java.lang.Object invoke(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object);
    public abstract java.lang.Object invoke(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object);
    public abstract java.lang.Object invoke(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object);
    public abstract java.lang.Object invoke(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object);
    public abstract java.lang.Object invoke(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object);
    public abstract java.lang.Object invoke(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object);
    public abstract java.lang.Object invoke(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object);
    public abstract java.lang.Object invoke(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object);
    public abstract java.lang.Object invoke(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object);
    public abstract java.lang.Object invoke(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object);
    public abstract java.lang.Object invoke(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object);
    public abstract java.lang.Object invoke(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object);
    public abstract java.lang.Object invoke(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object[]);
    public abstract java.lang.Object applyTo(clojure.lang.ISeq);
}
</pre>

<p>Uff! Co to v¹echno vlastnì pro nás znamená? Tøída
<strong>clojure.lang.AFn</strong> implementuje v¹echny vý¹e vypsané metody
rozhraní <strong>clojure.lang.IFn</strong>, ov¹em nejedná se o finální metody,
co¾ znamená, ¾e jakákoli tøída odvozená od <strong>clojure.lang.AFn</strong>
mù¾e libovolnou z&nbsp;tìchto metod pøekrýt a implementovat ji po svém. Tímto
ponìkud &bdquo;ukecaným&ldquo; zpùsobem je zaji¹tìno to, ¾e jakoukoli funkci
lze v&nbsp;<i>Clojure</i> volat s&nbsp;libovolným mno¾stvím parametrù
(resp.&nbsp;s&nbsp;maximálnì 21 parametry, pokud poèítám dobøe), jejich¾ typy
se zji¹»ují a¾ v&nbsp;runtime a souèasnì implicitní implementace tìchto metod
zaji¹»uje správné chování funkcí pøi pøedání ¹patného poètu parametrù &ndash;
nesmíme toti¾ zapomenout na to, ¾e funkce jsou <strong>v¾dy</strong> pøekládány
do bajtkódu, a to i pøi pou¾ívání interpretru, tedy REPL.</p>

<p>Druhá informace o implementovaném rozhraní <strong>IFn$LLL</strong> tøídou
<strong>AddTest5</strong> je takté¾ dùle¾itá. V&nbsp;tomto rozhraní je toti¾
pøedepsána jediná metoda se dvìma parametry typu <strong>long</strong>
vracející hodnotu typu <strong>long</strong> &ndash; to jsou ostatnì ony tøi
"L" v&nbsp;názvu rozhraní:</p>

<pre>
javap IFn$LLL
&nbsp;
Compiled from "IFn.java"
public interface clojure.lang.IFn$LLL{
    public abstract long invokePrim(long, long);
}
</pre>

<p>V&nbsp;<i>Clojure</i> existuje celá øada podobných rozhraní, která umo¾òují
definovat signaturu metody <strong>invokePrim</strong> s&nbsp;rùznými typy
parametrù a s&nbsp;rùznými typy návratové hodnot. Tyto informace lze v¾dy
vyèíst z&nbsp;názvu rozhraní. Napøíklad rozhraní <strong>IFn$DLDOL</strong>
pøedepisuje metodu <strong>invokePrim</strong> takto:</p>

<pre>
public interface clojure.lang.IFn$DLDOL{
    public abstract long invokePrim(double, long, double, java.lang.Object);
}
</pre>

<p>Prozatím existují tato rozhraní kombinující rùzné parametry a rùzné
návratové hodnoty metody <strong>invokePrim</strong>:</p>

<pre>
clojure/lang/IFn$D         clojure/lang/IFn$DD        clojure/lang/IFn$DDD
clojure/lang/IFn$DDDD      clojure/lang/IFn$DDDDD     clojure/lang/IFn$DDDDL
clojure/lang/IFn$DDDDO     clojure/lang/IFn$DDDL      clojure/lang/IFn$DDDLD
clojure/lang/IFn$DDDLL     clojure/lang/IFn$DDDLO     clojure/lang/IFn$DDDO
clojure/lang/IFn$DDDOD     clojure/lang/IFn$DDDOL     clojure/lang/IFn$DDDOO
clojure/lang/IFn$DDL       clojure/lang/IFn$DDLD      clojure/lang/IFn$DDLDD
clojure/lang/IFn$DDLDL     clojure/lang/IFn$DDLDO     clojure/lang/IFn$DDLL
clojure/lang/IFn$DDLLD     clojure/lang/IFn$DDLLL     clojure/lang/IFn$DDLLO
clojure/lang/IFn$DDLO      clojure/lang/IFn$DDLOD     clojure/lang/IFn$DDLOL
clojure/lang/IFn$DDLOO     clojure/lang/IFn$DDO       clojure/lang/IFn$DDOD
clojure/lang/IFn$DDODD     clojure/lang/IFn$DDODL     clojure/lang/IFn$DDODO
clojure/lang/IFn$DDOL      clojure/lang/IFn$DDOLD     clojure/lang/IFn$DDOLL
clojure/lang/IFn$DDOLO     clojure/lang/IFn$DDOO      clojure/lang/IFn$DDOOD
clojure/lang/IFn$DDOOL     clojure/lang/IFn$DDOOO     clojure/lang/IFn$DL
clojure/lang/IFn$DLD       clojure/lang/IFn$DLDD      clojure/lang/IFn$DLDDD
clojure/lang/IFn$DLDDL     clojure/lang/IFn$DLDDO     clojure/lang/IFn$DLDL
clojure/lang/IFn$DLDLD     clojure/lang/IFn$DLDLL     clojure/lang/IFn$DLDLO
clojure/lang/IFn$DLDO      clojure/lang/IFn$DLDOD     clojure/lang/IFn$DLDOL
clojure/lang/IFn$DLDOO     clojure/lang/IFn$DLL       clojure/lang/IFn$DLLD
clojure/lang/IFn$DLLDD     clojure/lang/IFn$DLLDL     clojure/lang/IFn$DLLDO
clojure/lang/IFn$DLLL      clojure/lang/IFn$DLLLD     clojure/lang/IFn$DLLLL
clojure/lang/IFn$DLLLO     clojure/lang/IFn$DLLO      clojure/lang/IFn$DLLOD
clojure/lang/IFn$DLLOL     clojure/lang/IFn$DLLOO     clojure/lang/IFn$DLO
clojure/lang/IFn$DLOD      clojure/lang/IFn$DLODD     clojure/lang/IFn$DLODL
clojure/lang/IFn$DLODO     clojure/lang/IFn$DLOL      clojure/lang/IFn$DLOLD
clojure/lang/IFn$DLOLL     clojure/lang/IFn$DLOLO     clojure/lang/IFn$DLOO
clojure/lang/IFn$DLOOD     clojure/lang/IFn$DLOOL     clojure/lang/IFn$DLOOO
clojure/lang/IFn$DO        clojure/lang/IFn$DOD       clojure/lang/IFn$DODD
clojure/lang/IFn$DODDD     clojure/lang/IFn$DODDL     clojure/lang/IFn$DODDO
clojure/lang/IFn$DODL      clojure/lang/IFn$DODLD     clojure/lang/IFn$DODLL
clojure/lang/IFn$DODLO     clojure/lang/IFn$DODO      clojure/lang/IFn$DODOD
clojure/lang/IFn$DODOL     clojure/lang/IFn$DODOO     clojure/lang/IFn$DOL
clojure/lang/IFn$DOLD      clojure/lang/IFn$DOLDD     clojure/lang/IFn$DOLDL
clojure/lang/IFn$DOLDO     clojure/lang/IFn$DOLL      clojure/lang/IFn$DOLLD
clojure/lang/IFn$DOLLL     clojure/lang/IFn$DOLLO     clojure/lang/IFn$DOLO
clojure/lang/IFn$DOLOD     clojure/lang/IFn$DOLOL     clojure/lang/IFn$DOLOO
clojure/lang/IFn$DOO       clojure/lang/IFn$DOOD      clojure/lang/IFn$DOODD
clojure/lang/IFn$DOODL     clojure/lang/IFn$DOODO     clojure/lang/IFn$DOOL
clojure/lang/IFn$DOOLD     clojure/lang/IFn$DOOLL     clojure/lang/IFn$DOOLO
clojure/lang/IFn$DOOO      clojure/lang/IFn$DOOOD     clojure/lang/IFn$DOOOL
clojure/lang/IFn$DOOOO     clojure/lang/IFn$L         clojure/lang/IFn$LD
clojure/lang/IFn$LDD       clojure/lang/IFn$LDDD      clojure/lang/IFn$LDDDD
clojure/lang/IFn$LDDDL     clojure/lang/IFn$LDDDO     clojure/lang/IFn$LDDL
clojure/lang/IFn$LDDLD     clojure/lang/IFn$LDDLL     clojure/lang/IFn$LDDLO
clojure/lang/IFn$LDDO      clojure/lang/IFn$LDDOD     clojure/lang/IFn$LDDOL
clojure/lang/IFn$LDDOO     clojure/lang/IFn$LDL       clojure/lang/IFn$LDLD
clojure/lang/IFn$LDLDD     clojure/lang/IFn$LDLDL     clojure/lang/IFn$LDLDO
clojure/lang/IFn$LDLL      clojure/lang/IFn$LDLLD     clojure/lang/IFn$LDLLL
clojure/lang/IFn$LDLLO     clojure/lang/IFn$LDLO      clojure/lang/IFn$LDLOD
clojure/lang/IFn$LDLOL     clojure/lang/IFn$LDLOO     clojure/lang/IFn$LDO
clojure/lang/IFn$LDOD      clojure/lang/IFn$LDODD     clojure/lang/IFn$LDODL
clojure/lang/IFn$LDODO     clojure/lang/IFn$LDOL      clojure/lang/IFn$LDOLD
clojure/lang/IFn$LDOLL     clojure/lang/IFn$LDOLO     clojure/lang/IFn$LDOO
clojure/lang/IFn$LDOOD     clojure/lang/IFn$LDOOL     clojure/lang/IFn$LDOOO
clojure/lang/IFn$LL        clojure/lang/IFn$LLD       clojure/lang/IFn$LLDD
clojure/lang/IFn$LLDDD     clojure/lang/IFn$LLDDL     clojure/lang/IFn$LLDDO
clojure/lang/IFn$LLDL      clojure/lang/IFn$LLDLD     clojure/lang/IFn$LLDLL
clojure/lang/IFn$LLDLO     clojure/lang/IFn$LLDO      clojure/lang/IFn$LLDOD
clojure/lang/IFn$LLDOL     clojure/lang/IFn$LLDOO     clojure/lang/IFn$LLL
clojure/lang/IFn$LLLD      clojure/lang/IFn$LLLDD     clojure/lang/IFn$LLLDL
clojure/lang/IFn$LLLDO     clojure/lang/IFn$LLLL      clojure/lang/IFn$LLLLD
clojure/lang/IFn$LLLLL     clojure/lang/IFn$LLLLO     clojure/lang/IFn$LLLO
clojure/lang/IFn$LLLOD     clojure/lang/IFn$LLLOL     clojure/lang/IFn$LLLOO
clojure/lang/IFn$LLO       clojure/lang/IFn$LLOD      clojure/lang/IFn$LLODD
clojure/lang/IFn$LLODL     clojure/lang/IFn$LLODO     clojure/lang/IFn$LLOL
clojure/lang/IFn$LLOLD     clojure/lang/IFn$LLOLL     clojure/lang/IFn$LLOLO
clojure/lang/IFn$LLOO      clojure/lang/IFn$LLOOD     clojure/lang/IFn$LLOOL
clojure/lang/IFn$LLOOO     clojure/lang/IFn$LO        clojure/lang/IFn$LOD
clojure/lang/IFn$LODD      clojure/lang/IFn$LODDD     clojure/lang/IFn$LODDL
clojure/lang/IFn$LODDO     clojure/lang/IFn$LODL      clojure/lang/IFn$LODLD
clojure/lang/IFn$LODLL     clojure/lang/IFn$LODLO     clojure/lang/IFn$LODO
clojure/lang/IFn$LODOD     clojure/lang/IFn$LODOL     clojure/lang/IFn$LODOO
clojure/lang/IFn$LOL       clojure/lang/IFn$LOLD      clojure/lang/IFn$LOLDD
clojure/lang/IFn$LOLDL     clojure/lang/IFn$LOLDO     clojure/lang/IFn$LOLL
clojure/lang/IFn$LOLLD     clojure/lang/IFn$LOLLL     clojure/lang/IFn$LOLLO
clojure/lang/IFn$LOLO      clojure/lang/IFn$LOLOD     clojure/lang/IFn$LOLOL
clojure/lang/IFn$LOLOO     clojure/lang/IFn$LOO       clojure/lang/IFn$LOOD
clojure/lang/IFn$LOODD     clojure/lang/IFn$LOODL     clojure/lang/IFn$LOODO
clojure/lang/IFn$LOOL      clojure/lang/IFn$LOOLD     clojure/lang/IFn$LOOLL
clojure/lang/IFn$LOOLO     clojure/lang/IFn$LOOO      clojure/lang/IFn$LOOOD
clojure/lang/IFn$LOOOL     clojure/lang/IFn$LOOOO     clojure/lang/IFn$OD
clojure/lang/IFn$ODD       clojure/lang/IFn$ODDD      clojure/lang/IFn$ODDDD
clojure/lang/IFn$ODDDL     clojure/lang/IFn$ODDDO     clojure/lang/IFn$ODDL
clojure/lang/IFn$ODDLD     clojure/lang/IFn$ODDLL     clojure/lang/IFn$ODDLO
clojure/lang/IFn$ODDO      clojure/lang/IFn$ODDOD     clojure/lang/IFn$ODDOL
clojure/lang/IFn$ODDOO     clojure/lang/IFn$ODL       clojure/lang/IFn$ODLD
clojure/lang/IFn$ODLDD     clojure/lang/IFn$ODLDL     clojure/lang/IFn$ODLDO
clojure/lang/IFn$ODLL      clojure/lang/IFn$ODLLD     clojure/lang/IFn$ODLLL
clojure/lang/IFn$ODLLO     clojure/lang/IFn$ODLO      clojure/lang/IFn$ODLOD
clojure/lang/IFn$ODLOL     clojure/lang/IFn$ODLOO     clojure/lang/IFn$ODO
clojure/lang/IFn$ODOD      clojure/lang/IFn$ODODD     clojure/lang/IFn$ODODL
clojure/lang/IFn$ODODO     clojure/lang/IFn$ODOL      clojure/lang/IFn$ODOLD
clojure/lang/IFn$ODOLL     clojure/lang/IFn$ODOLO     clojure/lang/IFn$ODOO
clojure/lang/IFn$ODOOD     clojure/lang/IFn$ODOOL     clojure/lang/IFn$ODOOO
clojure/lang/IFn$OL        clojure/lang/IFn$OLD       clojure/lang/IFn$OLDD
clojure/lang/IFn$OLDDD     clojure/lang/IFn$OLDDL     clojure/lang/IFn$OLDDO
clojure/lang/IFn$OLDL      clojure/lang/IFn$OLDLD     clojure/lang/IFn$OLDLL
clojure/lang/IFn$OLDLO     clojure/lang/IFn$OLDO      clojure/lang/IFn$OLDOD
clojure/lang/IFn$OLDOL     clojure/lang/IFn$OLDOO     clojure/lang/IFn$OLL
clojure/lang/IFn$OLLD      clojure/lang/IFn$OLLDD     clojure/lang/IFn$OLLDL
clojure/lang/IFn$OLLDO     clojure/lang/IFn$OLLL      clojure/lang/IFn$OLLLD
clojure/lang/IFn$OLLLL     clojure/lang/IFn$OLLLO     clojure/lang/IFn$OLLO
clojure/lang/IFn$OLLOD     clojure/lang/IFn$OLLOL     clojure/lang/IFn$OLLOO
clojure/lang/IFn$OLO       clojure/lang/IFn$OLOD      clojure/lang/IFn$OLODD
clojure/lang/IFn$OLODL     clojure/lang/IFn$OLODO     clojure/lang/IFn$OLOL
clojure/lang/IFn$OLOLD     clojure/lang/IFn$OLOLL     clojure/lang/IFn$OLOLO
clojure/lang/IFn$OLOO      clojure/lang/IFn$OLOOD     clojure/lang/IFn$OLOOL
clojure/lang/IFn$OLOOO     clojure/lang/IFn$OOD       clojure/lang/IFn$OODD
clojure/lang/IFn$OODDD     clojure/lang/IFn$OODDL     clojure/lang/IFn$OODDO
clojure/lang/IFn$OODL      clojure/lang/IFn$OODLD     clojure/lang/IFn$OODLL
clojure/lang/IFn$OODLO     clojure/lang/IFn$OODO      clojure/lang/IFn$OODOD
clojure/lang/IFn$OODOL     clojure/lang/IFn$OODOO     clojure/lang/IFn$OOL
clojure/lang/IFn$OOLD      clojure/lang/IFn$OOLDD     clojure/lang/IFn$OOLDL
clojure/lang/IFn$OOLDO     clojure/lang/IFn$OOLL      clojure/lang/IFn$OOLLD
clojure/lang/IFn$OOLLL     clojure/lang/IFn$OOLLO     clojure/lang/IFn$OOLO
clojure/lang/IFn$OOLOD     clojure/lang/IFn$OOLOL     clojure/lang/IFn$OOLOO
clojure/lang/IFn$OOOD      clojure/lang/IFn$OOODD     clojure/lang/IFn$OOODL
clojure/lang/IFn$OOODO     clojure/lang/IFn$OOOL      clojure/lang/IFn$OOOLD
clojure/lang/IFn$OOOLL     clojure/lang/IFn$OOOLO     clojure/lang/IFn$OOOOD
clojure/lang/IFn$OOOOL
</pre>

<p>V&nbsp;pøedchozí èásti tohoto seriálu jsme si øekli, ¾e <i>Clojure</i>
vyu¾ívá pouze malé mno¾ství primitivních typù jazyka Java a toto je jeden
z&nbsp;dùvodù, proè jich není podporováno více. Pokud by se napøíklad kromì
typu <i>double</i> podporoval je¹tì typ <i>float</i>, musel by poèet rozhraní
<strong>IFn$***</strong> být je¹tì mnohem vìt¹í!</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Statické metody</h2>

<p>Ve výètu metod zapisovaného do parametru <strong>:methods</strong> makra
<strong>gen-class</strong> lze urèit, které metody jsou statické a které
nikoli. Pøipomeòme si, ¾e nestatické metody se od metod statických li¹í
pøedev¹ím tím, ¾e se jim pøi volání automaticky pøedává i reference na objekt,
pro nìj¾ je nestatická metoda volána. Naproti tomu statické metody nemají
pøístup k&nbsp;atributùm tohoto objektu (mají v¹ak samozøejmì pøístup
k&nbsp;atributùm tøídy). Pro vytvoøení statické metody postaèuje pøed
<i>vektor</i> obsahující informace o metodì pøidat metainformaci
<strong>^{:static true}</strong>. To je v¹e &ndash; pouze na základì této
informace se vytvoøí metoda, která má v&nbsp;bajtkódu nastaven pøíznak
ACC_STATIC a bude se jí pøedávat o jeden parametr ménì &ndash; bude tedy chybìt
neviditelný parametr <strong>this</strong>:</p>

<pre>
(ns AddTest6 (
    :gen-class
    :name "AddTest6"
    :prefix "implementation-"
    :methods [<strong>^{:static true}</strong> [add [long long] long]]))
&nbsp;
(defn implementation-add
    [^long x ^long y]
    (^long + x y))
&nbsp;
(defn implementation-main
    []
    (println "Hello world!" (implementation-add 10 20)))
</pre>

<p>O tom, ¾e je skuteènì vygenerována statická metoda, se mù¾eme jednodu¹e
pøesvìdèit prozkoumáním interní struktury vytvoøeného souboru
<strong>AddTest6.class</strong> s&nbsp;bajkódem:</p>

<pre>
% javap AddTest6
&nbsp;
public class AddTest6 extends java.lang.Object{
    public static {};
    public AddTest6();
    public java.lang.String toString();
    public boolean equals(java.lang.Object);
    public java.lang.Object clone();
    public int hashCode();
    <strong>public static long add(long, long);</strong>
    <strong>public static void main(java.lang.String[]);</strong>
}
</pre>

<p>Na závìr si musíme je¹tì øíci, ¾e pøidání typù k&nbsp;funkcím (jedná se o
metainformaci) v&nbsp;<i>Clojure</i> ve skuteènosti neznamená, ¾e by bylo mo¾né
jen takto jednodu¹e vytvoøit pøetí¾ené metody, tj.&nbsp;metody se stejným
názvem, které se od sebe li¹í typem a/nebo poètem parametrù. Podívejme se na
následující pøíklad, v&nbsp;nìm¾ je skrytá urèitá zrada, kterou v¹ak pøekladaè
dopøedu neohlásí, a to z&nbsp;toho prostého dùvodu, ¾e tuto zradu vlastnì
nemù¾e u dynamicky typovaného jazyka v¾dy na 100% pøedvídat:</p>

<pre>
(ns AddTest7 (
    :gen-class
    :name "AddTest7"
    :prefix "implementation-"
    :methods [
        ^{:static true} [add [long long] long]
        ^{:static true} [add [double double] double]
        ^{:static true} [add [String String] String]
        ]))
&nbsp;
(defn implementation-add
    [^long x ^long y]
    (^long + x y))
&nbsp;
(defn implementation-add
    [^double x ^double y]
    (^double + x y))
&nbsp;
(defn implementation-add
    [^String x ^String y]
    (^String str x y))
&nbsp;
(defn implementation-main
    []
    (println "Hello world!"))
</pre>

<p>Mohlo by se zdát, ¾e je v¹e v&nbsp;poøádku a ¾e jsme takto jednodu¹e
nadefinovali trojici funkcí <strong>implementation-add</strong>, které se
pøelo¾í do odpovídajících metod <strong>add</strong>. I prùzkum bajtkódu
vytvoøené tøídy neodhalí ¾ádný problém, spí¹e naopak:</p>

<pre>
% javap AddTest7
&nbsp;
public class AddTest7 extends java.lang.Object{
    public static {};
    public AddTest7();
    public java.lang.String toString();
    public boolean equals(java.lang.Object);
    public java.lang.Object clone();
    public int hashCode();
    <strong>public static long add(long, long);</strong>
    <strong>public static double add(double, double);</strong>
    <strong>public static java.lang.String add(java.lang.String, java.lang.String);</strong>
    <strong>public static void main(java.lang.String[]);</strong>
}
</pre>

<p>Ve skuteènosti v¹ak do¹lo k&nbsp;tomu, ¾e poslední funkce
<strong>implementation-add</strong> pøemazala definici pøedchozích funkcí, a to
úplnì stejným zpùsobem, jako by se to stalo v&nbsp;interpretru jazyka
<i>Clojure</i>. To znamená, ¾e i kdy¾ je ve vygenerovaném bajtkódu tøídy
<strong>AddTest7.class</strong> uvedena trojice metod <strong>add</strong>
s&nbsp;rùznými parametry, bude se z&nbsp;tìchto metod ve skuteènosti v¾dy volat
pøelo¾ená funkce <strong>implementation-add</strong>, v&nbsp;jejím¾ tìle se
budou spojovat dva øetìzce pomocí <strong>str</strong>. Pokud se této funkci
pøedají parametry jiného typu ne¾ dvojice øetìzcù
(<strong>AddTest7.add(1,2)</strong>), dojde k&nbsp;bìhové chybì!</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Eulerovo èíslo<br />
<a href="http://cs.wikipedia.org/wiki/Eulerovo_èíslo">http://cs.wikipedia.org/wiki/Eulerovo_èíslo</a>
</li>

<li>List comprehension<br />
<a href="http://en.wikipedia.org/wiki/List_comprehension">http://en.wikipedia.org/wiki/List_comprehension</a>
</li>

<li>List Comprehensions in Clojure<br />
<a href="http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html">http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html</a>
</li>

<li>Clojure Programming Concepts: List Comprehension<br />
<a href="http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension">http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension</a>
</li>

<li>Clojure core API: for macro<br />
<a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for">http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for</a>
</li>

<li>cirrus machina - The Clojure for macro<br />
<a href="http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/">http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/</a>
</li>

<li>Clojure.org: Clojure home page<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>A Couple of Clojure Agent Examples<br />
<a href="http://lethain.com/a-couple-of-clojure-agent-examples/">http://lethain.com/a-couple-of-clojure-agent-examples/</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/">http://java.sun.com/developer/technicalArticles/DynTypeLang/</a>
</li>

<li>JSR 223: Scripting for the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=223">http://jcp.org/en/jsr/detail?id=223</a>
</li>

<li>JSR 292: Supporting Dynamically Typed Languages on the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=292">http://jcp.org/en/jsr/detail?id=292</a>
</li>

<li>Java 7: A complete invokedynamic example<br />
<a href="http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html">http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html</a>
</li>

<li>InvokeDynamic: Actually Useful?<br />
<a href="http://blog.headius.com/2007/01/invokedynamic-actually-useful.html">http://blog.headius.com/2007/01/invokedynamic-actually-useful.html</a>
</li>

<li>A First Taste of InvokeDynamic<br />
<a href="http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html">http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html</a>
</li>

<li>Java 6 try/finally compilation without jsr/ret<br />
<a href="http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html">http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Root.cz: Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM<br />
<a href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/</a></a>
</li>

<li>Root.cz: JamVM aneb alternativa k HotSpotu nejenom pro embedded zaøízení a chytré telefony<br />
<a href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>FindBugs<br />
<a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a>
</li>

<li>GNU Classpath<br />
<a href="www.gnu.org/s/classpath/">www.gnu.org/s/classpath/</a></li>

<li>Java VMs Compared<br />
<a href="http://bugblogger.com/java-vms-compared-160/">http://bugblogger.com/java-vms-compared-160/</a>
</li>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Scala Programming Language<br />
<a href="http://www.scala-lang.org/">http://www.scala-lang.org/</a>
</li>

<li>Run Scala in Apache Tomcat in 10 minutes<br />
<a href="http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes">http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes</a>
</li>

<li>Fast Web Development With Scala<br />
<a href="http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html">http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html</a>
</li>

<li>Top five scripting languages on the JVM<br />
<a href="http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855">http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>CloseableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html">http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

