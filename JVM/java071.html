<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - architektura JPDA a rozhraní JDI</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - architektura JPDA a rozhraní JDI</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyku Java i o virtuálním stroji Javy si øekneme základní informace o architektuøe JPDA (Java Platform Debugger Architecture). Uká¾eme si, jaký je vztah ji¾ popsaného rozhraní JVM TI k JPDA a takté¾ si popí¹eme základní vlastnosti javovského rozhraní JDI (Java Debugger Interface).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Vlastnosti, pøednosti a zápory rozhraní JVM TI (shrnutí)</a></p>
<p><a href="#k02">2. Architektura JPDA (Java Platform Debugger Architecture)</a></p>
<p><a href="#k03">3. JDWP &ndash; Java Debug Wire Protocol</a></p>
<p><a href="#k04">4. JDI &ndash; Java Debugger Interface</a></p>
<p><a href="#k05">5. Vytvoøení pøipojení pøes rozhraní JDI k&nbsp;cílovému virtuálnímu stroji Javy</a></p>
<p><a href="#k06">6. Demonstraèní pøíklad &ndash; výpis v¹ech konektorù, které jsou pøes rozhraní JDI k&nbsp;dispozici</a></p>
<p><a href="#k07">7. Spu¹tìní demonstraèního pøíkladu na Linuxu i na MS Windows</a></p>
<p><a href="#k08">8. Obsah následující èásti seriálu</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Vlastnosti, pøednosti a zápory rozhraní JVM TI (shrnutí)</h2>

<p>V&nbsp;pøedchozích osmnácti èástech <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyku Java i o virtuálním stroji Javy</a> jsme si popsali
vìt¹inu funkcí nabízených rozhraním <i>JVM TI (Java Virtual Machine Tool
Interface )</i>. Pøipomeòme si, ¾e <i>JVM TI</i> umo¾òuje pøipojení nativní
binární knihovny (naprogramované typicky v&nbsp;céèku èi C++)
k&nbsp;virtuálnímu stroji Javy. Tato nativní knihovna, která se nazývá
<i>agent</i>, mù¾e pøes funkce nabízené <i>JVM TI</i> sledovat stav JVM &ndash;
mù¾e napøíklad získat informace o v¹ech naètených tøídách, pøeèíst a
prostudovat obsah haldy (heapu), zastavit libovolné vlákno na nastaveném
breakpointu a samozøejmì takté¾ prozkoumat obsah zásobníkových rámcù vybraného
vlákna (napøíklad pøi vzniku výjimky). Nespornou pøedností rozhraní <i>JVM
TI</i> je fakt, ¾e JVM TI agent mù¾e zaèít sledovat èi ovlivòovat èinnost
virtuálního stroje Javy je¹tì pøedtím, ne¾ JVM zaène inicializovat classloadery
a ne¾ zaène naèítat a inicializovat bajtkódy jednotlivých tøíd, které jsou
vyu¾ívány spou¹tìnou javovskou aplikací.</p>

<p>Dokonce platí, ¾e funkce dostupné pøes rozhraní <i>JVM TI</i> bude mo¾né
vyu¾ít i tehdy, pokud nepùjde inicializovat javovskou aplikaci, napøíklad
z&nbsp;toho dùvodu, ¾e se pou¾ívá ¹patný <strong>rt.jar</strong> (zde jsou
ulo¾eny tøídy a rozhraní definované v&nbsp;Java SE API), pokud tento soubor
nebyl nalezen apod. Ov¹em pøi pohledu na zdrojové kódy testovacích JVM TI
agentù (<a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>)
zaènou být zøejmé i nìkteré nevýhody tohoto rozhraní. Ty spoèívají v&nbsp;tom,
¾e pøi volání funkcí JVM TI je nutné provádìt ruèní alokaci a dealokaci
jednotlivých datových struktur (typicky øetìzcù èi polí), pøi vstupu do
kritických sekcí musí programátor explicitnì zamykat a odmykat zámky atd.
Funkce a datové struktury JVM TI jsou navíc odli¹né od tøíd a metod nabízených
samotným standardním Java (SE) API, co¾ znamená, ¾e se vývojáø musí detailnì
seznámit s&nbsp;obìma &bdquo;svìty&ldquo; &ndash; jak s&nbsp;tím javovským, tak
i céèkovým.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Architektura JPDA (Java Platform Debugger Architecture)</h2>

<p>Tvùrci specifikace technologie virtuálního stroje Javy si byli této
vlastnosti rozhraní <i>JVM TI</i> vìdomi a proto ve skuteènosti JVM TI tvoøí
pouze nejni¾¹í vrstvu speciálního API virtuálního stroje Javy slou¾ícího
k&nbsp;monitorování i k&nbsp;øízení JVM. Nad rozhraním JVM TI je vytvoøen
komunikaèní kanál tvoøený protokolem <i>JDWP (Java Debug Wire Protocol)</i> [<a
href="#k03">kapitola 3</a>] a nad tímto protokolem bylo vytvoøeno plnohodnotné
javovské rozhraní nazvané <i>JDI (Java Debug Interface)</i> [<a
href="#k04">kapitola 4</a>]. <i>JVM TI</i>, <i>JDWP</i> (spoleènì
s&nbsp;pomìrnì jednoduchým rozhraním k&nbsp;tomuto protokolu <i>JDWPI</i>) a
<i>JDI</i> tvoøí ucelenou tøívrstvou architekturu nazvanou <i>Java Platform
Debugger Architecture</i> neboli zkrácenì <i>JPDA</i>. Jak ji¾ název této
architektury naznaèuje, lze ji pou¾ít napøíklad pro implementaci rùzných
ladicích nástrojù (debuggerù), ale i nástrojù monitorovacích, nástrojù
umo¾òujících &bdquo;hotswap&ldquo; tøíd èi jejich metod do bì¾ícího virtuálního
stroje Javy apod.</p>

<p>Z&nbsp;tohoto dùvodu jsou funkce nabízené jednou ze tøí zmínìných
technologií velmi èasto vyu¾ívány i integrovanými vývojovými prostøedími (IDE).
Na provádìní nízkoúrovòových operací je pøitom pou¾íváno rozhraní <i>JVM TI</i>
a pro implementaci vysokoúrovòových funkcí pak <i>JDI</i>, popø.&nbsp;se
s&nbsp;virtuálním strojem Javy, v&nbsp;nìm¾ byla spu¹tìna vyvíjená aplikace,
komunikuje pøímo s&nbsp;vyu¾itím protokolu <i>JDWP</i> (to je v¹ak vìt¹inou
zbyteènì komplikované). Vzájemný vztah mezi rozhraním <i>JVM TI</i>, protokolem
<i>JDWP</i> a rozhraním <i>JDI</i> je zobrazen na následujícím schématu:</p>

<img src="http://i.iinfo.cz/images/426/jpda.png" class="image-124848" width="596" height="398" alt="&#160;" />
<p><i>Obrázek 1: Vzájemný vztah mezi (céèkovým) rozhraním JVM TI, protokolem
JDWP a javovským rozhraním JDI.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. JDWP &ndash; Java Debug Wire Protocol</h2>

<p>Jedním z&nbsp;dùle¾itých prvkù architektury <i>JPDA</i> je protokol nazvaný
<i>JDWP</i>, neboli <i>Java Debug Wire Protocol</i>. Ze schématu vyobrazeného
<a href="#k02">v&nbsp;pøedchozí kapitole</a> je patrné, ¾e protokol <i>JDWP</i>
je v&nbsp;typické konfiguraci pou¾it pro komunikaci mezi nativním agentem
vyu¾ívajícím rozhraní <i>JVM TI</i> na jedné stranì a debuggerem vyu¾ívajícím
javovské rozhraní <i>JDI</i> na stranì druhé. V&nbsp;terminologii <i>JPDA</i>
se nativní agent nazývá <i>back-end</i> a jeho standardní implementaci
nabízející céèkové rozhraní nazvané <strong>jdwpTransport</strong> vìt¹inou
nalezneme v&nbsp;instalaèním adresáøi JRE pod jménem
<strong>libjdwp.so</strong> popø.&nbsp;<strong>jdwp.dll</strong> (to, ¾e je
tato knihovna souèástí JRE znamená, ¾e lze <i>JDWP</i> vyu¾ít napøíklad i na
klientských poèítaèích èi serverech, kde nelze pøedpokládat existenci instalace
plné JDK). Zatímco se nativní agent nazývá <i>back-end</i>, <i>front-endem</i>
je nazývána javovská knihovna, která s&nbsp;debuggerem èi jiným vyvíjeným
ladicím/monitorovacím nástrojem komunikuje pøes javovské rozhraní
<i>JDI</i>.</p>

<p>Dùle¾ité je, ¾e zatímco <i>back-end</i> je pøímo navázán s&nbsp;virtuálním
strojem Javy, na nìm¾ bì¾í ladìná èi sledovaná javovská aplikace (takzvaná
&bdquo;cílová JVM&ldquo;), je <i>front-end</i> vet¹inou spu¹tìn v&nbsp;jiném
virtuálním stroji Javy, který navíc mù¾e bì¾et i na odli¹ném poèítaèi &ndash;
protokol <i>JDWP</i> umo¾òuje jak lokální komunikaci pøes sdílenou pamì», tak i
komunikaci se vzdáleným poèítaèem pøes sockety, sériovou linku atd. Díky
existenci <i>JDWP</i> je dokonce mo¾né, aby byl <i>front-end</i> implementován
v&nbsp;jiném programovacím jazyce, ne¾ je Java (viz té¾ schéma zobrazené pod
odstavcem). Po implementaci front-endu se pouze oèekává dodr¾ení specifikace
tohoto protokolu, která mj.&nbsp;vy¾aduje i asynchronní obousmìrnou komunikaci
zalo¾enou na (obousmìrném) posílání paketù typu pøíkaz&ndash;odpovìï.
<i>JDWP</i> je bezstavovým protokolem a posílané pakety obsahují binární data,
v&nbsp;nich¾ jsou hodnoty reprezentované dvoubajtovými èi ètyøbajtovými
hodnotami ulo¾eny ve formátu <i>big-endian</i>, jak je tomu ostatnì
v&nbsp;JDK/JRE zvykem. Základní pøíkazy protokolu <i>JDWP</i> si popí¹eme
v&nbsp;nìkterém z&nbsp;dal¹ích pokraèování tohoto seriálu.</p>

<img src="http://i.iinfo.cz/images/472/jdwp.png" class="image-124849" width="596" height="398" alt="&#160;" />
<p><i>Obrázek 2: S&nbsp;vyu¾itím protokolu JDWP mù¾e s&nbsp;bì¾ící (cílovou)
JVM komunikovat prakticky libovolný proces; nemusí se tedy jednat o aplikaci
naprogramovanou v&nbsp;Javì.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. JDI &ndash; Java Debugger Interface</h2>

<p><i>JDI</i>, neboli <i>Java Debug Interface</i>, je rozhraní implementované
v&nbsp;Javì, které je mo¾né pou¾ít pro monitorování a ladìní aplikací
spu¹tìných v&nbsp;samostatném (&bdquo;cílovém&ldquo;) virtuálním stroji Javy.
<i>JDI</i> lze pou¾ít napøíklad pro implementaci debuggeru naprogramovaného
v&nbsp;Javì. Tento debugger se mù¾e s&nbsp;vyu¾itím tøíd a metod poskytovaných
rozhraním <i>JDI</i> pøipojit k&nbsp;virtuálnímu stroji s&nbsp;testovanou
aplikací, popø.&nbsp;dokonce mù¾e tento stroj pøímo spustit, co¾ je téma,
kterému se budeme podrobnìji vìnovat v&nbsp;následující èásti tohoto seriálu.
Ve chvíli, kdy debugger volá nìjakou metodu nabízenou <i>JDI</i>, vy¹le se
pøíkazový paket pøes protokol <i>JDWP</i> do pøíslu¹ného <i>JVM TI</i> agenta,
který je ji¾ pøipojen k&nbsp;testovanému virtuálnímu stroji Javy. Odpovìdí na
pøíkazový paket je paket s&nbsp;vy¾ádanými daty (napøíklad hodnotami lokálních
promìnných sledovaného vlákna), který je pøenesen pøes protokol <i>JDWP</i>
zpìt do debuggeru, který tato data získá pøes <i>JDI</i> jako návratovou
hodnotu nìjaké metody.</p>

<p>Tento postup sice mù¾e na první pohled vypadat ponìkud komplikovanì, ve
skuteènosti je v¹ak velmi flexibilní. Programátor vyvíjející debugger èi
specializovaný monitorovací nástroj se toti¾ mù¾e sám rozhodnout, zda radìji
vyu¾ije nízkoúrovòové rozhraní <i>JVM TI</i> (co¾ jsme si ukázali
v&nbsp;pøedchozích osmnácti èástech <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">tohoto
seriálu</a>), zda bude radìji implementovat svùj program tak, aby pou¾íval
komunikaèní protokol <i>JDWP</i> èi zda naopak vyu¾ije tøídy a metody nabízené
vysokoúrovòovým rozhraním <i>JDI</i>, co¾ je ve vìt¹inì pøípadù nejrychlej¹í a
z&nbsp;implementaèního hlediska i nejjednodu¹¹í øe¹ení. Ostatnì ètenáøi tohoto
seriálu se o relativní jednoduchosti rozhraní <i>JDI</i> v&nbsp;porovnání
s&nbsp;nízkoúrovòovým <i>JVM TI</i> budou moci pøesvìdèit v&nbsp;dal¹ích
èástech, v&nbsp;nich¾ si uká¾eme pomìrnì velké mno¾ství demonstraèních pøíkladù
vyu¾ívajících rozhraní <i>JDI</i> pro monitorování i øízení JVM.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Vytvoøení pøipojení pøes rozhraní JDI k&nbsp;cílovému virtuálnímu stroji</h2>

<p>Pøed pou¾itím tøíd a metod nabízených rozhraním <i>JDI</i> je nejprve nutné
navázat spojení mezi debuggerem (tak budeme pro zjednodu¹ení oznaèovat v¹echny
nástroje volající <i>JDI</i>) a takzvanou cílovou JVM, tj.&nbsp;virtuálním
strojem, v&nbsp;nìm¾ bì¾í monitorovaná èi ladìná aplikace. Zpùsob komunikace
mezi debuggerem a cílovou JVM se v&nbsp;terminologii <i>JPDA</i> nazývá
<i>transport</i>; s&nbsp;tímto slovem se ostatnì mù¾eme setkat i pøi startu
cílové JVM (<strong>java -agentlib:jdwp=transport=???</strong>). Implementace
transportu mù¾e být rùzná, nìkdy i systémovì závislá. Mezi dvì hlavní metody
v¹ak patøí transport implementovaný s&nbsp;vyu¾itím socketù a druhou metodou je
transport implementovaný sdílenou pamìtí. Jak v¹ak uvidíme dále, není transport
pou¾ívající sdílenou pamì» podporován na v¹ech operaèních systémech.
V&nbsp;pøípadì, ¾e se komunikace navazuje pøes rozhraní <i>JDI</i>, se pou¾ívá
abstrakce transportu nazvaná jednodu¹e <i>connector</i>, která je definována
v&nbsp;rozhraní <strong>com.sun.jdi.connect.Connector</strong> (pozor &ndash;
nejde o souèást standardního API Javy).</p>

<p>Vìt¹ina virtuálních strojù Javy nabízí pro propojení mezi debuggerem a
cílovou JVM hned nìkolik typù konektorù, z&nbsp;nich¾ ty nejpou¾ívanìj¹í jsou
vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Konektor</th><th>Plné jméno (identifikace)</th><th>Popis</th></tr>
<tr><td>1</td><td>CommandLineLaunch   </td><td>"com.sun.jdi.CommandLineLaunch"</td><td>cílová JVM je spu¹tìna pøímo pøes JDI a ihned poté se navá¾e spojení pøes socket èi sdílenou pamì»</td></tr>
<tr><td>2</td><td>RawCommandLineLaunch</td><td>"com.sun.jdi.RawCommandLineLaunch"</td><td>podobné pøedchozímu konektoru, ov¹em pøíkaz pro spu¹tìní JVM se pøedává pøes jediný øetìzec (li¹í se jen zpùsob spu¹tìní)</td></tr>
<tr><td>3</td><td>SocketAttach        </td><td>"com.sun.jdi.SocketAttach"</td><td>pøipojení k&nbsp;ji¾ bì¾ící cílové JVM pøes socket</td></tr>
<tr><td>4</td><td>SharedMemoryAttach  </td><td>"com.sun.jdi.SharedMemoryAttach"</td><td>pøipojení k&nbsp;ji¾ bì¾ící cílové JVM pøes sdílenou pamì»</td></tr>
<tr><td>5</td><td>SocketListen        </td><td>"com.sun.jdi.SocketListen"</td><td>pøipojení k&nbsp;bì¾ící cílové JVM na základì po¾adavku pøijatého od této JVM</td></tr>
<tr><td>6</td><td>SharedMemoryListen  </td><td>"com.sun.jdi.SharedMemoryListen"</td><td>dtto ale vyu¾ije se sdílená pamì»</td></tr>
<tr><td>7</td><td>ProcessAttach       </td><td>"com.sun.jdi.ProcessAttach"</td><td>pøipojení k&nbsp;ji¾ bì¾ící cílové JVM, která je spu¹tìna s&nbsp;parametrem agentlib:jdwp=server=y</td></tr>
</table>



<p><a name="k06"></a></p>
<h2 id="k06">6. Demonstraèní pøíklad &ndash; výpis v¹ech konektorù, které jsou pøes rozhraní JDI k&nbsp;dispozici</h2>

<p>V&nbsp;pøedchozí kapitole jsme si øekli, ¾e nabídka konektorù dostupných
v&nbsp;konkrétní verzi JVM a na konkrétní architektuøe, se mù¾e li¹it. Pøi
pou¾ití rozhraní <i>JDI</i> v¹ak máme mo¾nost zjistit dostupné (nabízené)
konektory v&nbsp;èase bìhu debuggeru, a to s&nbsp;vyu¾itím javovského rozhraní
<strong>com.sun.jdi.VirtualMachineManager</strong>. Instanci jedináèka
implementujícího toto rozhraní získáme pøes statickou metodu
<strong>com.sun.jdi.Bootstrap.virtualMachineManager()</strong> a následnì
mù¾eme v¹echny dostupné konektory pøeèíst metodou
<strong>com.sun.jdi.VirtualMachineManager.allConnectors()</strong>, která vrátí
seznam (list) objektù typu <strong>com.sun.jdi.connect.Connector</strong>.
Následnì je ji¾ mo¾né jeden z&nbsp;konektorù pou¾ít, popø.&nbsp;jen získaný
seznam konektorù vypsat na standardní výstup. Pøesnì tento algoritmus je
implementován v&nbsp;prvním demonstraèním pøíkladu vyu¾ívajícím tøídy a
rozhraní nabízené <i>JDI</i>:</p>

<pre>
import com.sun.jdi.Bootstrap;
import com.sun.jdi.VirtualMachineManager;
import com.sun.jdi.connect.Connector;
&nbsp;
<i>/**</i>
<i> * Trida, ktera vypise vsechny dostupne JDI konektory.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
 */
public class JDIListAllConnectors {
&nbsp;
    public static void main(String[] args) {
<i>        // ziskat (jedinou) instanci tridy VirtualMachineManager</i>
        VirtualMachineManager virtualMachineManager = <strong>Bootstrap.virtualMachineManager()</strong>;
&nbsp;
<i>        // vypsat vsechny dostupne konektory</i>
        for (Connector connector : <strong>virtualMachineManager.allConnectors()</strong>) {
            System.out.println(connector.toString());
        }
    }
&nbsp;
}
</pre>

<p>Vzhledem k&nbsp;tomu, ¾e tøídy a rozhraní
<strong>com.sun.jdi.Bootstrap</strong>,
<strong>com.sun.jdi.VirtualMachineManager</strong> a
<strong>com.sun.jdi.connect.Connector</strong> nejsou souèástí standardního API
Java SE, je nutné pøi pøekladu specifikovat, v&nbsp;jakém adresáøi èi
v&nbsp;jakém Java archivu (JAR) se nachází bajtkódy tìchto tøíd. Standardnì se
jedná o Java archiv nazvaný <strong>tools.jar</strong>, který nalezneme
v&nbsp;adresáøi <strong>/usr/lib/jvm/{verze-JDK}/lib/</strong>. Pøeklad tedy
mù¾e vypadat napøíklad následovnì:</p>

<pre>
javac -classpath /usr/lib/jvm/java-6-openjdk/lib/tools.jar:. JDIListAllConnectors.java
</pre>

<a href="http://www.root.cz/obrazek/124850/"><img src="http://i.iinfo.cz/images/361/eclipse-prev.png" class="image-124850" width="327" height="270" alt="&#160;" /></a>
<p><i>Obrázek 3: Ukázka nastavení konfigurace projektu v&nbsp;Eclipse takovým
zpùsobem, aby se pøi pøekladu i spu¹tìní správnì nalezly v¹echny potøebné tøídy
JDI.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Spu¹tìní demonstraèního pøíkladu na Linuxu i na MS Windows</h2>

<p>Po kompilaci demonstraèního pøíkladu se ji¾ mù¾eme pokusit o jeho spu¹tìní.
Podobnì jako pøi samotném pøekladu je nutné i pøi spou¹tìní specifikovat cestu
k&nbsp;Java archivu, v&nbsp;nìm¾ jsou ulo¾eny tøídy <i>JDI</i>. Pokud je
napøíklad nainstalováno dnes ji¾ ponìkud historické OpenJDK6, provede se
pøeklad následujícím zpùsobem:</p>

<pre>
java -cp /usr/lib/jvm/java-6-openjdk/lib/tools.jar:. JDIListAllConnectors
</pre>

<p>Po spu¹tìní na Linuxu vìt¹inou získáme seznam pìti konektorù (pov¹imnìte si
pøedvyplnìných parametrù konektorù; podrobnìji se s&nbsp;nimi seznámíme
pøí¹tì):</p>

<pre>
com.sun.jdi.CommandLineLaunch (defaults: home=/usr/lib/jvm/java-6-openjdk/jre, options=, main=, suspend=true, quote=", vmexec=java)
com.sun.jdi.RawCommandLineLaunch (defaults: command=, quote=", address=)
com.sun.jdi.SocketAttach (defaults: timeout=, hostname=bender, port=)
com.sun.jdi.SocketListen (defaults: timeout=, port=, localAddress=)
com.sun.jdi.ProcessAttach (defaults: pid=, timeout=)
</pre>

<p>Na operaèním systému Microsoft Windows bývá nabídka dostupných konektorù
vìt¹í, proto¾e jsou nabízeny i dva konektory vyu¾ívající pro komunikaci
sdílenou pamì» namísto socketù:</p>

<pre>
com.sun.jdi.CommandLineLaunch (defaults: home=C:\Program Files\Java\jdk1.6.0_01\jre, options=, main=, suspend=true, quote=", vmexec=java)
com.sun.jdi.RawCommandLineLaunch (defaults: command=, quote=", address=)
com.sun.jdi.SocketAttach (defaults: timeout=, hostname=bender, port=)
com.sun.jdi.SocketListen (defaults: timeout=, port=, localAddress=)
com.sun.jdi.SharedMemoryAttach (defaults: timeout=, name=)
com.sun.jdi.SharedMemoryListen (defaults: timeout=, name=)
com.sun.jdi.ProcessAttach (defaults: pid=, timeout=)
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Obsah následující èásti seriálu</h2>

<p>V&nbsp;následující èásti seriálu o programovacím jazyku Java i o virtuálním
stroji Javy si na nìkolika demonstraèních pøíkladech uká¾eme, jakým zpùsobem
lze vyu¾ít konektor typu <strong>CommandLineLaunch</strong>, tj.&nbsp;konektor,
který nejprve spustí cílovou JVM a ihned poté s&nbsp;ní navá¾e spojení. Dále si
uká¾eme pou¾ití konektoru typu <strong>SocketAttach</strong>, proto¾e se jedná
o velmi èasto pou¾ívaný zpùsob pøipojení debuggeru èi jiného monitorovacího
nástroje k&nbsp;ji¾ bì¾ícímu virtuálnímu stroji Javy.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Breakpoint (Wikipedia)<br />
<a href="http://cs.wikipedia.org/wiki/Breakpoint">http://cs.wikipedia.org/wiki/Breakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation<br />
<a href="http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html">http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; SetBreakpoint<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#SetBreakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#SetBreakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; ClearBreakpoint<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#ClearBreakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#ClearBreakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; Breakpoint (callback funkce)<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#Breakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#Breakpoint</a>
</li>

<li>The JVM Tool Interface (JVM TI): How VM Agents Work<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html">http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html</a>
</li>

<li>Creating a Debugging and Profiling Agent with JVMTI<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html">http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html</a>
</li>

<li>JVM TI (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/JVM_TI">http://en.wikipedia.org/wiki/JVM_TI</a>
</li>

<li>IBM JVMTI extensions<br />
<a href="http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html">http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

