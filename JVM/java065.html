<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - nastavení breakpointù s vyu¾itím rozhraní JVM TI</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - nastavení breakpointù s vyu¾itím rozhraní JVM TI</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o vlastnostech JVM se zaèneme zabývat dal¹í velmi dùle¾itou funkcí nabízenou rozhraním JVM TI. Jedná se o funkci urèenou pro nastavení breakpointù (bodù pøeru¹ení). Breakpoint je mo¾né nastavit v libovolné metodì na zvolenou instrukci, tak¾e v JVM TI je práce s breakpointy pøesnìj¹í, ne¾ ve vìt¹inì debuggerù èi IDE.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Podpora práce s&nbsp;breakpointy v&nbsp;rozhraní JVM TI</a></p>
<p><a href="#k02">2. JVM TI funkce <strong>SetBreakpoint()</strong> a <strong>ClearBreakpoint()</strong></a></p>
<p><a href="#k03">3. Callback funkce zavolaná ve chvíli dosa¾ení breakpointu</a></p>
<p><a href="#k04">4. Postup pøi nastavení breakpointù</a></p>
<p><a href="#k05">5. Získání identifikátorù v¹ech metod pro zvolenou tøídu</a></p>
<p><a href="#k06">6. Demonstraèní agent èíslo 30 &ndash; výpis v¹ech metod pro zvolenou tøídu</a></p>
<p><a href="#k07">7. Spu¹tìní tøicátého demonstraèního agenta</a></p>
<p><a href="#k08">8. Zdrojové kódy demonstraèního agenta i k&nbsp;nìmu pøíslu¹ných testovacích pøíkladù a skriptù</a></p>
<p><a href="#k09">9. Obsah následující èásti seriálu</a></p>
<p><a href="#k10">10. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Podpora práce s&nbsp;breakpointy v&nbsp;rozhraní JVM TI</h2>

<p>V&nbsp;dne¹ní èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyce Java i o vlastnostech virtuálního stroje Javy</a> se
budeme zabývat popisem jedné z&nbsp;neju¾iteènìj¹ích funkcí nabízených
rozhraním <i>JVM TI</i>. Jedná se o funkci nazvanou
<strong>SetBreakpoint()</strong> a v&nbsp;men¹í míøe i o funkci
<strong>ClearBreakpoint()</strong>. Jak ji¾ názvy tìchto funkcí naznaèují, lze
je vyu¾ít pro nastavení èi naopak zru¹ení breakpointù vkládaných na urèitá
místa v&nbsp;bajtkódu. Breakpointù mù¾e být zaregistrováno libovolné mno¾ství a
ve chvíli, kdy nìjaké vlákno k&nbsp;zaregistrovanému breakpointu dojde, zavolá
rozhraní <i>JVM TI</i> callback funkci spoleènou pro v¹echny nastavené
breakpointy.</p>

<p>V&nbsp;této callback funkci je ji¾ mo¾né získat v¹echny potøebné informace o
místì, kde vlákno do¹lo k&nbsp;breakpointu, lze samozøejmì získat hodnoty
atributù sledovaného objektu, výpis zásobníkových rámcù platných pro aktuální
vlákno atd. atd. Mo¾nosti nabízené rozhraním <i>JVM TI</i> jsou v&nbsp;tomto
ohledu dosti velké, i kdy¾ je nutné øíci, ¾e pro implementaci plnohodnotného
debuggeru mù¾e být jednodu¹¹í vyu¾ít rozhraní <i>JDWP</i> (k&nbsp;popisu tohoto
velmi zajímavého a u¾iteèného rozhraní se v&nbsp;tomto seriálu dostaneme
pozdìji).</p>

<p>Na tomto místì je¹tì stojí za zmínku si pøipomenout, ¾e v&nbsp;pøedchozích
èástech tohoto seriálu jsme si popsali funkce, které lze vyu¾ít pro trasování
vstupu do metod a výstupu z&nbsp;metod:</p>

<pre>
void JNICALL <strong>MethodEntry</strong>(
            jvmtiEnv *jvmti_env,
            JNIEnv   *jni_env,
            jthread   thread,
            jmethodID method)
</pre>

<pre>
void JNICALL <strong>MethodExit</strong>(
            jvmtiEnv *jvmti_env,
            JNIEnv   *jni_env,
            jthread   thread,
            jmethodID method,
            jboolean  was_popped_by_exception,
            jvalue    return_value)
</pre>

<p>Tyto funkce mohou v&nbsp;nìkterých pøípadech nahradit breakpointy, ov¹em
mají jednu dosti zásadní nevýhodu &ndash; tyto callback funkce jsou toti¾
zaregistrovány globálnì pro <strong>v¹echny</strong> metody, co¾
mj.&nbsp;znamená, ¾e se pøi jejich pou¾ití výraznì zpomalí bìh virtuálního
stroje Javy. U breakpointù toto nebezpeèí nehrozí, samozøejmì v&nbsp;pøípadì,
¾e jich nebudeme mít zaregistrováno nìkolik tisíc :-) Zajímavé takté¾ je, ¾e
nastavené breakpointy zùstanou zachovány i tehdy, pokud je daná metoda
pøelo¾ena JIT pøekladaèem do nativního strojového kódu (ostatnì algoritmus,
který breakpointy zachovává i v&nbsp;tomto pøípadì je dosti slo¾itý a
v&nbsp;minulosti nebyl zcela bez chyb).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. JVM TI funkce <strong>SetBreakpoint()</strong> a <strong>ClearBreakpoint()</strong></h2>

<p>Popi¹me si nyní obì funkce urèené pro nastavování a ru¹ení breakpointù. Pro
nastavení breakpointu se pou¾ívá funkce
<strong>jvmti-&gt;SetBreakpoint()</strong>. Této funkci je nutné pøedat dva
dùle¾ité údaje. Jedná se v&nbsp;první øadì o identifikátor metody, tj.&nbsp;o
hodnotu typu <strong>jmethodID</strong>, kterou je nutné nìjakým zpùsobem
získat (jak, to se dozvíme v&nbsp;navazujících kapitolách). Druhým dùle¾itým
parametrem je parametr typu <strong>jlocation</strong>, který urèuje pøesné
místo v&nbsp;rámci metody, kam má být breakpoint umístìn. Ve vìt¹inì
existujících virtuálních strojù Javy platí, ¾e <strong>jlocation</strong>
odpovídá indexùm instrukcí bajtkódu v&nbsp;metodì, co¾ znamená, ¾e breakpoint
lze nastavit s&nbsp;pøesností na instrukci, zatímco vìt¹ina (?) debuggerù a
integrovaných vývojových prostøedí pracuje s&nbsp;øádky zdrojového kódu.
V&nbsp;praxi to znamená, ¾e pøes rozhraní <i>JVM TI</i> lze umístit breakpoint
napøíklad doprostøed výrazu, co¾ mù¾e být v&nbsp;nìkterých pøípadech
u¾iteèné.</p>

<p>Hlavièka funkce <strong>jvmti-&gt;SetBreakpoint()</strong> vypadá
následovnì:</p>

<pre>
jvmtiError <strong>SetBreakpoint</strong>(
            jvmtiEnv* env,
            jmethodID method,
            jlocation location)
</pre>

<p>Zajímavé je, ¾e funkce urèená pro ru¹ení existujícího breakpointu
(<strong>jvmti-&gt;ClearBreakpoint()</strong>) má stejné parametry jako funkce
<strong>jvmti-&gt;SetBreakpoint()</strong>. Je to vlastnì pochopitelné, nebo» i
pøi ru¹ení breakpointu je nutné specifikovat metodu a index instrukce
v&nbsp;rámci této metody:</p>

<pre>
jvmtiError <strong>ClearBreakpoint</strong>(
            jvmtiEnv* env,
            jmethodID method,
            jlocation location)
</pre>

<p>Jak jsme si ji¾ øekli <a href="#k01">v&nbsp;pøedchozí kapitole</a>, zùstává
breakpoint nastaven i v&nbsp;pøípadì, ¾e je metoda pøelo¾ena JIT pøekladaèem do
nativního strojového kódu. U vìt¹iny virtuálních strojù Javy se v¹ak musí
internì zakázat nìkteré optimalizace, které by vedly napøíklad k&nbsp;eliminaci
kódu, na nìm¾ je breakpoint nastaven. Teoreticky to tedy znamená, ¾e nastavením
breakpointu se bìh programu zpomalí, ve skuteènosti se v¹ak vìt¹inou jedná o
minimální rozdíly. Výjimkou by byly pøípady, kdy by byl breakpoint nastaven ve
vnitøní smyèce nìjakého výpoètu, který by jinak mohl být eliminován
optimalizujícím JIT pøekladaèem. Druhý problém mù¾e nastat u nìkterých
&bdquo;alternativních&ldquo; JVM (napøíklad Zero+Shark pro ARM) ve chvíli, kdy
se breakpoint nastavuje do metody s&nbsp;prázdným tìlem &ndash; Shark toti¾
volání prázdných metod eliminuje i v&nbsp;pøípadì, ¾e je zde breakpoint
nastaven (co¾ by v&nbsp;ideálním pøípadì mìlo být o¹etøeno).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Callback funkce zavolaná ve chvíli dosa¾ení breakpointu</h2>

<p>Nastavení breakpointu s&nbsp;vyu¾itím funkce
<strong>jvmti-&gt;SetBreakpoint()</strong> v¹ak je¹tì nestaèí k&nbsp;tomu, aby
<i>JVM TI</i> agent dostával zprávy o tom, ¾e nìjaké vlákno breakpointu
skuteènì dosáhlo. Musíme toti¾ je¹tì implementovat u¾ivatelskou callback funkci
zavolanou ve chvíli dosa¾ení breakpointu. Hlavièka této callback funkce vypadá
následovnì:</p>

<pre>
void JNICALL <strong>Breakpoint</strong>(
            jvmtiEnv *jvmti_env,
            JNIEnv   *jni_env,
            jthread   thread,
            jmethodID method,
            jlocation location)
</pre>

<p>V&nbsp;následující tabulce je vypsán význam v¹ech pìti parametrù této
funkce. Tyto parametry jsou samozøejmì naplòovány virtuálním strojem Javy ve
chvíli pøed zavoláním callback funkce:</p>

<table>
<tr><th>#</th><th>Typ parametru</th><th>Jméno parametru</th><th>Význam</th></tr>
<tr><td>1</td><td>jvmtiEnv *</td><td>jvmti_env</td><td>JVM TI prostøedí agenta (je pøedáváno do vìt¹iny callback funkcí)</td></tr>
<tr><td>2</td><td>JNIEnv   *</td><td>jni_env  </td><td>JNI prostøedí platné pro dané vlákno (je pøedáváno do nìkterých callback funkcí)</td></tr>
<tr><td>3</td><td>jthread   </td><td>thread   </td><td>vlákno, v&nbsp;nìm¾ do¹lo k&nbsp;dosa¾ení instrukce oznaèené breakpointem</td></tr>
<tr><td>4</td><td>jmethodID </td><td>method   </td><td>metoda s&nbsp;registrovaným breakpointem</td></tr>
<tr><td>5</td><td>jlocation </td><td>location </td><td>identifikace instrukce, na ní¾ je nastavený registrovaný breakpoint</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Postup pøi nastavení breakpointù</h2>

<p>V&nbsp;dal¹ím kroku je nutné povolit generování událostí ve chvíli dosa¾ení
breakpointu. Podobnì jako u dal¹ích typù událostí, i zde se &bdquo;povolovací
sekvence&ldquo; rozdìluje na dva kroky. Nejprve musíme pøes <i>JVM TI</i>
rozhraní oznámit, ¾e danou funkcionalitu vy¾adujeme, a to s&nbsp;vyu¾itím
struktury <strong>jvmtiCapabilities</strong> a <i>JVM TI</i> funkce
<strong>jvmti-&gt;AddCapabilities()</strong>:</p>

<pre>
jvmtiCapabilities capabilities;
&nbsp;
memset(&amp;capabilities, 0, sizeof(jvmtiCapabilities));
&nbsp;
capabilities.can_generate_breakpoint_events = 1;
(*jvmti)-&gt;<strong>AddCapabilities</strong>(jvmti, &amp;capabilities);
</pre>

<p>Následnì je nutné nastavit re¾im notifikace s&nbsp;vyu¾itím funkce
<strong>jvmti-&gt;SetEventNotificationMode()</strong>, které se pøedá hodnota
<strong>JVMTI_EVENT_BREAKPOINT</strong>:</p>

<pre>
(*jvmti)-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL)
</pre>

<p>Následnì musíme provést tyto kroky:</p>

<ol>

<li>Získat identifikátor metody, pro ní¾ se breakpoint nastavuje.</li>

<li>Získat lokaci (umístìní) breakpointu v&nbsp;rámci metody (vìt¹inou na
základì èísla øádku).</li>

<li>Provést registraci breakpointu s&nbsp;vyu¾itím funkce
<strong>SetBreakpoint()</strong>.</li>

<li>Definovat u¾ivatelskou callback funkci popsanou <a
href="#k03">v&nbsp;pøedchozí kapitole</a>.</li>

</ol>



<p><a name="k05"></a></p>
<h2 id="k05">5. Získání identifikátorù v¹ech metod pro zvolenou tøídu</h2>

<p>V&nbsp;pøedchozích kapitolách jsme si øekli, ¾e pro zdárné zaregistrování
nového breakpointu je nutné funkci <strong>SetBreakpoint()</strong> pøedat
identifikátor metody a umístìní breakpointu v&nbsp;rámci této metody. Nejprve
se podívejme na to, jakým zpùsobem se zjistí v¹echny metody zvolené tøídy. Ve
skuteènosti je to velmi jednoduché, proto¾e mù¾eme vyu¾ít postup, s&nbsp;ním¾
jsme se seznámili v&nbsp;pøedchozích dvou dílech tohoto seriálu &ndash;
vyu¾ijeme u¾ivatelskou callback funkci
<strong>callback_on_class_prepare()</strong> volanou v&nbsp;dobì, kdy jsou do
virtuálního stroje Javy naèítány jednotlivé tøídy. Pro ka¾dou tøídu zjistíme
pomocí funkce <strong>GetClassSignature()</strong> její jméno a pokud se jedná
o testovací tøídu (resp.&nbsp;tøídu, pro její¾ metodu má být nastaven
breakpoint), zavolá se u¾ivatelská funkce <strong>list_all_methods()</strong>,
která vypí¹e jména v¹ech metod deklarovaných v&nbsp;rámci nalezené tøídy:</p>

<pre>
<i>/*</i>
<i> * Callback funkce zavolana ve chvili, kdy je trida ve virtualnim stroji ve stavu,</i>
<i> * kdy ji lze normalne pouzivat.</i>
<i> */</i>
static void JNICALL <strong>callback_on_class_prepare</strong>(
        jvmtiEnv *jvmti_env,
        JNIEnv   *jni_env,
        jthread   thread,
        jclass    class)
{
    jvmtiError error;
    char *class_name_ptr;
    char *updated_class_name_ptr;
&nbsp;
    enter_critical_section(jvmti_env);
&nbsp;
<i>    /* ziskat jmeno tridy */</i>
    error = (*jvmti_env)-&gt;<strong>GetClassSignature</strong>(jvmti_env, class, &amp;class_name_ptr, NULL);
    check_jvmti_error(jvmti_env, error, "get class signature");
    if (class_name_ptr == NULL)
    {
        puts("Error: class has no signature");
    }
&nbsp;
<i>    /* upravit jmeno tridy */</i>
    updated_class_name_ptr = update_class_name(class_name_ptr, ';');
&nbsp;
<i>    /* pokud jsme nasli to pravou tridu */</i>
    if (strcmp(updated_class_name_ptr, TEST_CLASS_NAME) == 0)
    {
        puts("Class "TEST_CLASS_NAME" prepared, listing all its methods");
        list_all_methods(jvmti_env, class);
    }
&nbsp;
<i>    /* dealokace pameti po GetClassSignature() */</i>
    error = (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char *)class_name_ptr);
    check_jvmti_error(jvmti_env, error, "deallocate class name");
    exit_critical_section(jvmti_env);
}
</pre>

<p>U¾ivatelské funkci <strong>list_all_methods()</strong> je pøedán
identifikátor tøídy pøedstavovaný hodnotou typu <strong>jclass</strong>. Pro
získání seznamu v¹ech metod této tøídy se pou¾ije funkce
<strong>GetClassMethods()</strong>, která vrátí pole obsahující prvky typu
<strong>jmethodID</strong> a takté¾ vrátí délku tohoto pole. Pro ka¾dý prvek
typu <strong>jmethodID</strong> lze ji¾ snadno získat jméno i signaturu metody,
a to s&nbsp;vyu¾itím <i>JVM TI</i> funkce <strong>GetMethodName()</strong>. Po
vyu¾ití jména i signatury samozøejmì nesmíme zapomenout na dealokaci obou
øetìzcù, co¾ zajistí nám ji¾ dobøe známá funkce
<strong>Deallocate()</strong>:</p>

<pre>
<i>/*</i>
<i> * Vypis vsech metod zvolene tridy.</i>
<i> */</i>
void <strong>list_all_methods</strong>(jvmtiEnv *jvmti_env, jclass class)
{
    jvmtiError  error;
    int         method_count;
    jmethodID  *methods_array;
&nbsp;
<i>    /* precist vsechny metody tridy */</i>
    error = (*jvmti_env)-&gt;<strong>GetClassMethods</strong>(jvmti_env, class, &amp;method_count, &amp;methods_array);
    check_jvmti_error(jvmti_env, error, "get class methods");
&nbsp;
<i>    /* pole metod bylo inicializovano */</i>
    if (error == JVMTI_ERROR_NONE)
    {
        int i;
<i>        /* projit vsemi metodami */</i>
        for (i = 0; i &lt; method_count; i++)
        {
            char *method_name;
            char *method_signature;
            jmethodID method = methods_array[i];
            error = (*jvmti_env)-&gt;<strong>GetMethodName</strong>(jvmti_env, method, &amp;method_name, &amp;method_signature, NULL);
            if (error == JVMTI_ERROR_NONE)
            {
                printf("Found method(): %s with signature %s\n", method_name, method_signature);
                (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char*)method_name);
                (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char*)method_signature);
            }
        }
    }
&nbsp;
<i>    /* dealokace pole ziskaneho pres GetClassFields() */</i>
    error = (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char*)methods_array);
    check_jvmti_error(jvmti_env, error, "deallocate class fields array");
}
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Demonstraèní agent èíslo 30 &ndash; výpis v¹ech metod pro zvolenou tøídu</h2>

<p>Vý¹e popsané u¾ivatelské funkce <strong>callback_on_class_prepare()</strong>
a <strong>list_all_methods()</strong> tvoøí ústøední prvek ji¾ tøicátého
demonstraèního <i>JVM TI</i> agenta, který po svém spu¹tìní v&nbsp;rámci JVM
vypí¹e seznam v¹ech metod testovací tøídy <strong>Test30</strong>. U ka¾dé
metody je vypsáno jak její jméno (které nemusí být jednoznaèné), tak i
signatura metody, z&nbsp;ní¾ lze nám ji¾ známým postupem vyèíst poèet a typ
parametrù metody i typ návratové hodnoty této metody. Testovací tøída
<strong>Test30</strong> mj.&nbsp;obsahuje i nìkolik metod se shodným názvem
<strong>x</strong>, které se v¹ak li¹í (=musí se li¹it) svými signaturami:</p>

<pre>
<i>/**</i>
<i>  * Testovaci trida pouzite pro test tricateho</i>
<i>  * demonstracniho JVM TI agenta.</i>
<i>  */</i>
public class <strong>Test30</strong> {
&nbsp;
    public void <strong>foo</strong>() {
        System.out.println("Test30.foo()");
        bar();
    }
&nbsp;
    public void <strong>bar</strong>() {
        System.out.println("Test30.bar() line 12");
        System.out.println("Test30.bar() line 13");
        System.out.println("Test30.bar() line 14");
        System.out.println("Test30.bar() line 15");
    }
&nbsp;
    public void <strong>run</strong>() {
        System.out.println("Test30.run()");
        foo();
    }
&nbsp;
    public int <strong>x</strong>() {return 0;}
    public int <strong>x</strong>(int y) {return 0;}
    public int <strong>x</strong>(int y, boolean z) {return 0;}
    public int[] <strong>x</strong>(int[] y, double[][] z) {return null;}
&nbsp;
<i>    /**</i>
<i>      * Spusteni testu.</i>
<i>      */</i>
    public static void <strong>main</strong>(String[] args) {
        new Test30().run();
    }
&nbsp;
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Spu¹tìní tøicátého demonstraèního agenta</h2>

<p>Demonstraèní <i>JVM TI</i> agent i k&nbsp;nìmu pøíslu¹ná testovací tøída
<strong>Test30</strong> se pøelo¾í stejným zpùsobem, jaký jsme pou¾ili i u
v¹ech pøedchozích pøíkladù:</p>

<pre>
gcc -Wall -ansi -I/usr/lib/jvm/java-1.6.0-openjdk/include/ -shared -o libagent30.so agent30.c
javac -g Test30.java
</pre>

<p>O spu¹tìní virtuálního stroje Javy spoleènì s&nbsp;<i>JVM TI</i> agentem se
postará pøíkaz:</p>

<pre>
java -agentpath:./libagent30.so Test30 2&gt; /dev/null
</pre>

<p>Po spu¹tìní by se mìl na standardním výstupu objevit mj.&nbsp;i seznam v¹ech
metod testovací tøídy <strong>Test30</strong>, a to vèetnì signatur tìchto
metod:</p>

<pre>
Test30.run()
Test30.foo()
Test30.bar() line 12
Test30.bar() line 13
Test30.bar() line 14
Test30.bar() line 15
Agent30: Agent_OnLoad
Agent30: JVM TI version is correct
Agent30: Got VM init event
Class Test30; prepared, listing all its methods
Found method(): &lt;init&gt; with signature ()V
Found method(): main with signature ([Ljava/lang/String;)V
Found method(): run with signature ()V
Found method(): x with signature ()I
Found method(): x with signature (I)I
Found method(): x with signature (IZ)I
Found method(): x with signature ([I[[D)[I
Found method(): foo with signature ()V
Found method(): bar with signature ()V
Agent30: Got VM Death event
Agent30: Agent_OnUnload
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Zdrojové kódy demonstraèního agenta i k&nbsp;nìmu pøíslu¹ných testovacích pøíkladù a skriptù</h2>

<p>Podobnì jako v&nbsp;mnoha pøedcházejících èástech <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">tohoto
seriálu</a> byl i dne¹ní demonstraèní <i>JVM TI</i> agent kvùli snaz¹ímu
udr¾ování v¹ech zdrojových kódù ulo¾en do Mercurial repositáøe, který je
dostupný na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
Prozatím nejnovìj¹í verze dnes popisovaného <i>JVM TI</i> agenta i dal¹ích
potøebných skriptù a testovacích javovských tøíd jsou dostupné na následujících
adresách:</p>

<table>
<tr><th>Demonstraèní pøíklad/podpùrný soubor</th><th>Umístìní</th></tr>
<tr><td>Agent #30                     </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2a7ebf111840/jvmti-agents/agent30/agent30.c">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2a7ebf111840/jvmti-agents/agent30/agent30.c</a></td></tr>
<tr><td>Skript pro pøeklad agenta #30 </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2a7ebf111840/jvmti-agents/agent30/compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2a7ebf111840/jvmti-agents/agent30/compile.sh</a></td></tr>
<tr><td>Skript pro spu¹tìní agenta #30</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2a7ebf111840/jvmti-agents/agent30/test.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2a7ebf111840/jvmti-agents/agent30/test.sh</a></td></tr>
<tr><td>Testovací tøída Test30.java   </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2a7ebf111840/jvmti-agents/agent30/Test30.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2a7ebf111840/jvmti-agents/agent30/Test30.java</a></td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Obsah následující èásti seriálu</h2>

<p>První èást na¹eho problému ji¾ vlastnì máme vyøe¹enou &ndash; na základì
jména tøídy a jména metody toti¾ doká¾eme získat hodnotu typu
<strong>jmethodID</strong>, která vybranou metodu jednoznaènì reprezentuje
v&nbsp;rámci spu¹tìného virtuálního stroje Javy. Mù¾eme se tedy pustit do
pøípravy 31 demonstraèního <i>JVM TI</i> agenta, v&nbsp;nìm¾ bude nutné provést
tyto operace:</p>

<ol>

<li>Zjistit hodnotu typu <strong>jmethodID</strong> pro metodu, v&nbsp;ní¾
budeme chtít zaregistrovat breakpoint.</li>

<li>Pøevést èíslo øádku na hodnotu typu <strong>jlocation</strong>. Èíslo øádku
pøitom odpovídá poøadí øádku v&nbsp;textovém souboru se zdrojovým kódem
tøídy.</li>

<li>Nastavit po¾adované schopnosti agenta, zejména povolit generování callback
funkcí pøi prùchodu breakpointem.</li>

<li>Nastavit breakpoint funkcí <strong>SetBreakpoint()</strong> na základì
hodnot <strong>jmethodID</strong> a <strong>jlocation</strong> zji¹tìných
v&nbsp;bodech 1 a 2.</li>

<li>Zaregistrovat callback funkci zavolanou pøi prùchodu breakpointem (viz té¾
<a href="#k03">tøetí kapitolu</a>).</li>

</ol>

<p>V¹echny tyto kroky si podrobnì popí¹eme v&nbsp;navazující èásti tohoto
seriálu. Zde si jen jako malou ukázku uvedeme zprávy, které agent po svém
spu¹tìní vypí¹e na standardní výstup:</p>

<pre>
Test31.run()
Test31.foo()
Test31.bar() line 1
Test31.bar() line 2
Test31.bar() line 3
Test31.bar() line 4
Agent31: Agent_OnLoad
Agent31: JVM TI version is correct
Agent31: Got VM init event
Class Test31; prepared, setting breakpoint for method bar
Found method(): &lt;init&gt; with signature ()V
Found method(): main with signature ([Ljava/lang/String;)V
Found method(): run with signature ()V
Found method(): x with signature ()I
Found method(): x with signature (I)I
Found method(): x with signature (IZ)I
Found method(): x with signature ([I[[D)[I
Found method(): foo with signature ()V
Found method(): bar with signature ()V
...going to set breakpoint for this method
<strong>*** breakpoint visited!!! ***</strong>
Agent31: Got VM Death event
Agent31: Agent_OnUnload
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Odkazy na Internetu</h2>

<ol>

<li>Breakpoint (Wikipedia)<br />
<a href="http://cs.wikipedia.org/wiki/Breakpoint">http://cs.wikipedia.org/wiki/Breakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation<br />
<a href="http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html">http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; SetBreakpoint<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#SetBreakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#SetBreakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; ClearBreakpoint<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#ClearBreakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#ClearBreakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; Breakpoint (callback funkce)<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#Breakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#Breakpoint</a>
</li>

<li>The JVM Tool Interface (JVM TI): How VM Agents Work<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html">http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html</a>
</li>

<li>Creating a Debugging and Profiling Agent with JVMTI<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html">http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html</a>
</li>

<li>JVM TI (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/JVM_TI">http://en.wikipedia.org/wiki/JVM_TI</a>
</li>

<li>IBM JVMTI extensions<br />
<a href="http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html">http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

