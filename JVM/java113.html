<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - základní koncepty, na nich¾ je postavena knihovna SDLJava</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>


<body>

<h1>Pohled pod kapotu JVM - základní koncepty, na nich¾ je postavena knihovna SDLJava</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o virtuálním stroji Javy si popí¹eme základní koncepty pou¾ívané pøi vykreslování s vyu¾itím knihovny SDLJava. Popí¹eme si pøedev¹ím mo¾nosti tøídy sdljava.video.SDLSurface, vèetnì metod vyu¾ívaných pøi operacích typu BitBLT.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - základní koncepty, na nich¾ je postavena knihovna SDLJava</a></p>
<p><a href="#k02">2. Tøída <strong>sdljava.video.SDLRect</strong></a></p>
<p><a href="#k03">3. Tøída <strong>sdljava.video.SDLSurface</strong></a></p>
<p><a href="#k04">4. Naètení bitmapy s&nbsp;vyu¾itím metody <strong>sdljava.video.SDLVideo.loadBMP()</strong></a></p>
<p><a href="#k05">5. Podpora dal¹ích grafických formátù</a></p>
<p><a href="#k06">6. Operace typu <i>BitBLT</i> realizovaná mezi dvìma objekty typu <strong>sdljava.video.SDLSurface</strong></a></p>
<p><a href="#k07">7. Demonstraèní pøíklad <strong>SDLTest4</strong> &ndash; naètení bitmapy typu BMP a provedení operace <i>BitBLT</i></a></p>
<p><a href="#k08">8. Demonstraèní pøíklad <strong>SDLTest5</strong> &ndash; urèení pozice, kde se má bitmapa vykreslit</a></p>
<p><a href="#k09">9. Demonstraèní pøíklad <strong>SDLTest6</strong> &ndash; oøez bitmapy pøi provádìní operace typu <i>BitBLT</i></a></p>
<p><a href="#k10">10. Demonstraèní pøíklad <strong>SDLTest7</strong> &ndash; naètení bitmapy ulo¾ené ve formátu PNG</a></p>
<p><a href="#k11">11. Repositáø se zdrojovými kódy v¹ech ètyø dne¹ních demonstraèních pøíkladù</a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - základní koncepty, na nich¾ je postavena knihovna SDLJava</h2>

<p>V&nbsp;dne¹ní èásti seriálu o programovacím jazyce Java i o virtuálním
stroji tohoto jazyka budeme pokraèovat v&nbsp;popisu mo¾ností knihovny
<i>SDLJava</i>. V&nbsp;pøedchozím díle jsme si øekli základní informace o této
knihovnì; víme tedy, ¾e se jedná o &bdquo;objektové&ldquo; rozhraní ke známé
nativní knihovnì <i>SDL</i>. Takté¾ jsme si na trojici demonstraèních pøíkladù
ukázali, jak lze knihovnu <i>SDLJava</i> vyu¾ít ve vlastních aplikacích. Dnes
se podrobnìji seznámíme se základy vykreslování grafických scén s&nbsp;vyu¾itím
<i>SDLJava</i> a tím pádem i <i>SDL</i>. Demonstraèní pøíklady, s&nbsp;nimi¾ se
seznámíme, budou vyu¾ívat ¹estici tøíd vypsaných v&nbsp;následující tabulce,
ov¹em popis bude zamìøen pøedev¹ím na tøídy
<strong>sdljava.video.SDLRect</strong>, <strong>sdljava.video.SDLVideo</strong>
a <strong>sdljava.video.SDLSurface</strong>, které tvoøí základ grafického
subsystému knihovny <i>SDL</i> a v&nbsp;posledním demonstraèním pøíkladu bude
vyu¾ita i tøída <strong>sdljava.image.SDLImage</strong>:</p>

<table>
<tr><th>#</th><th>Tøída</th><th>Struèný popis</th></tr>
<tr><td>1</td><td>sdljava.SDLMain         </td><td>tato tøída obsahuje pøedev¹ím metody pro inicializaci knihovny <i>SDL</i> a pro korektní ukonèení èinnosti aplikace</td></tr>
<tr><td>2</td><td>sdljava.SDLException    </td><td>výjimka vyhazovaná pøi provedení nìkteré neplatné operace v&nbsp;knihovnì SDLJava èi SDL</td></tr>
<tr><td>3</td><td>sdljava.video.SDLRect   </td><td>jednoduchá tøída obalující strukturu SDL_rect z&nbsp;knihovny <i>SDL</i></td></tr>
<tr><td>4</td><td>sdljava.video.SDLVideo  </td><td>tøída se statickými metodami pou¾ívanými pøi práci s&nbsp;grafikou</td></tr>
<tr><td>5</td><td>sdljava.video.SDLSurface</td><td>reprezentuje bitmapu èi framebuffer, do nìho¾ je mo¾né provádìt vykreslování</td></tr>
<tr><td>6</td><td>sdljava.image.SDLImage  </td><td>tøída obsahující jedinou pøetí¾enou metodu <strong>load</strong> urèenou pro naètení bitmap z&nbsp;rùzných zdrojù (souborù, bufferu, URL atd.)</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Tøída <strong>sdljava.video.SDLRect</strong></h2>

<p>První tøída z&nbsp;knihovny <i>SDLJava</i>, s&nbsp;ní¾ se dnes podrobnìji
seznámíme, má plný název <strong>sdljava.video.SDLRect </strong>. Instance této
tøídy reprezentují obdélník se specifikovanými souøadnicemi jeho levého horního
rohu i se zadanými rozmìry (¹íøka, vý¹ka). Obdélníky jsou v&nbsp;knihovnì
<i>SDLJava</i> vyu¾ity na nìkolika místech; my se s&nbsp;nimi konkrétnì setkáme
v&nbsp;souvislosti s&nbsp;operací typu <i>BitBLT</i>, v&nbsp;ní¾ mohou být
obdélníky pou¾ity jak pro specifikaci umístìní kopírované bitmapy, tak i pro
nastavení oøezávání pøi kopiích bitmap. Jak jednotlivé souøadnice, tak i ¹íøka
a vý¹ka ka¾dého obdélníku jsou reprezentovány celými èísly typu <i>int</i>,
zatímco v&nbsp;nativní knihovnì <i>SDL</i> vypadá datový typ
<strong>SDL_Rect</strong> následovnì:</p>

<pre>
typedef struct SDL_Rect {
        Sint16 x, y;
        Uint16 w, h;
} SDL_Rect;
</pre>

<p>Ve tøídì <strong>sdljava.video.SDLRect</strong> mohou programátoøi pøímo
pøistupovat k&nbsp;atributùm <strong>x</strong>, <strong>y</strong>,
<strong>width</strong> a <strong>height</strong>, popø.&nbsp;mohou alternativnì
pou¾ít pøíslu¹né gettery a settery, které jsou navíc roz¹íøeny o metody
<strong>setLocation()</strong> a <strong>setSize()</strong>:</p>

<table>
<tr><th> #</th><th>Metoda</th><th>Popis</th></tr>
<tr><td> 1</td><td>int getX()                </td><td>getter pro atribut <strong>x</strong></td></tr>
<tr><td> 2</td><td>int getY()                </td><td>getter pro atribut <strong>y</strong></td></tr>
<tr><td> 3</td><td>int getWidth()            </td><td>getter pro atribut <strong>width</strong></td></tr>
<tr><td> 4</td><td>int getHeight()           </td><td>getter pro atribut <strong>height</strong></td></tr>
<tr><td> 5</td><td>void setX(int x)          </td><td>setter pro atribut <strong>x</strong></td></tr>
<tr><td> 6</td><td>void setY(int y)          </td><td>setter pro atribut <strong>y</strong></td></tr>
<tr><td> 7</td><td>void setWidth(int width)  </td><td>setter pro atribut <strong>width</strong></td></tr>
<tr><td> 8</td><td>void setHeight(int height)</td><td>setter pro atribut <strong>height</strong></td></tr>
<tr><td> 9</td><td>void setLocation(int x, int y)</td><td>nastavuje atributy <strong>x</strong> i <strong>y</strong></td></tr>
<tr><td>10</td><td>void setSize(int width, int height)</td><td>nastavuje atributy <strong>width</strong> i <strong>height</strong></td></tr>
</table>

<p>Velmi èasto se takté¾ pou¾ívá konstruktor <strong>public SDLRect(int x, int
y, int width, int height)</strong>.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Tøída <strong>sdljava.video.SDLSurface</strong></h2>

<p>Zatímco tøída <strong>sdljava.video.SDLRect</strong> popsaná <a
href="#k02">v&nbsp;pøedchozí kapitole</a> je velmi jednoduchá a jedná se
vlastnì jen o pøímoèaøe navr¾enou obalovou tøídu nad céèkovou datovou
strukturou, je tøída <strong>sdljava.video.SDLSurface</strong> ji¾ mnohem
slo¾itìj¹í, a to jak svojí vnitøní strukturou, tak i metodami, které tato tøída
nabízí. Objekty typu <strong>SDLSurface</strong> pøedstavují v&nbsp;knihovnì
<i>SDLJava</i> bitmapu, do ní¾ je mo¾né provádìt vykreslování,
popø.&nbsp;kterou lze s&nbsp;vyu¾itím operace typu <i>BitBLT</i> pøenést do
jiné bitmapy. <strong>SDLSurface</strong> v¹ak v&nbsp;<i>SDL</i> takté¾
pøedstavuje i vlastní framebuffer, co¾ znamená, ¾e vìt¹inu operací, kterou lze
provádìt s&nbsp;bitmapami ulo¾enými v&nbsp;operaèní pamìti, je mo¾né provádìt i
s&nbsp;framebufferem. Tøída <strong>SDLSurface</strong> obaluje nativní datovou
strukturu <strong>SDL_Surface</strong>, její¾ deklarace vypadá následovnì:</p>

<pre>
typedef struct <strong>SDL_Surface</strong> {
        Uint32 flags;                           /** Read-only */
        SDL_PixelFormat *format;                /** Read-only */
        int w, h;                               /** Read-only */
        Uint16 pitch;                           /** Read-only */
        void *pixels;                           /** Read-write */
        int offset;                             /** Private */
&nbsp;
        /** Hardware-specific surface info */
        struct private_hwdata *hwdata;
&nbsp;
        /** clipping information */
        SDL_Rect clip_rect;                     /** Read-only */
        Uint32 unused1;                         /** for binary compatibility */
&nbsp;
        /** Allow recursive locks */
        Uint32 locked;                          /** Private */
&nbsp;
        /** info for fast blit mapping to other surfaces */
        struct SDL_BlitMap *map;                /** Private */
&nbsp;
        /** format version, bumped at every change to invalidate blit maps */
        unsigned int format_version;            /** Private */
&nbsp;
        /** Reference count -- used when freeing surface */
        int refcount;                           /** Read-mostly */
} SDL_Surface;
</pre>

<p>Programátory vyu¾ívající knihovnu <i>SDLJava</i> v¹ak budou velmi
pravdìpodobnì zajímat pøedev¹ím metody, které jim tøída
<strong>SDLSurface</strong> nabízí. Struènì je mo¾né øíci, ¾e se nabízené
metody rozdìlují do nìkolika kategorií: vytvoøení èi naètení bitmapy/plochy,
vyplnìní plochy èi její èásti barvou, pøístup k&nbsp;jednotlivým pixelùm a
koneènì pøenos celé plochy èi její èásti na jinou plochu èi obrazovku.
Dùle¾itou metodou je <strong>SDLSurface.loadBMP()</strong> popsaná <a
href="#k04">v&nbsp;navazující kapitole</a>. Dále zde mù¾eme nalézt metodu
<strong>SDLSurface.fillRect()</strong> slou¾ící buï pro vyplnìní celé
plochy/bitmapy jednou barvou, nebo pro vyplnìní obdélníka specifikovaného
pomocí <strong>SDLRect</strong>. Ukázku pou¾ití tìchto metod jsme mohli vidìt
v&nbsp;pøedchozí èásti tohoto seriálu. Samostatnou kategorií je pøetí¾ená
metoda <strong>SDLSurface.blitSurface()</strong> slou¾ící pro vykonání operace
typu <i>BitBLT</i>.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Naètení bitmapy s&nbsp;vyu¾itím metody <strong>sdljava.video.SDLVideo.loadBMP()</strong></h2>

<p>Vìt¹ina her, v&nbsp;nich¾ je pou¾ita knihovna <i>SDL</i>
(resp.&nbsp;pøenesenì i <i>SDLJava</i>) pro práci s&nbsp;2D grafikou, musí
nìjakým zpùsobem naèítat rastrové obrázky z&nbsp;externích souborù. Samotná
základní varianta knihovny <i>SDL</i> se nesna¾í pokrýt v¹echny dostupné
grafické formáty ani suplovat dal¹í knihovny (giflib, libpng, libjpeg...) a
z&nbsp;tohoto dùvodu podporuje pouze naèítání rastrových obrázkù ulo¾ených
v&nbsp;souborech typu <i>BMP</i> neboli <i>(Windows) Bitmap</i>. Tento formát
byl navr¾en firmami IBM a Microsoft (ka¾dá firma navrhla jinou variantu) jako
základní rastrový obrazový formát pro jejich operaèní systémy OS/2 a Microsoft
Windows. Tím pádem je naèítání i ukládání obrázkù v&nbsp;tomto formátu
podporováno pøímo v&nbsp;aplikaèním rozhraní daného operaèního systému a tvùrci
programù mohou toto rozhraní vyu¾ít bez toho, aby daný formát detailnì
znali.</p></p>

<p>Zajímavý je také zpùsob ukládání obrazových øádkù do souborù. Ty se toti¾
v&nbsp;pùvodních verzích neukládaly smìrem shora dolù, jak je to pøirozené pro
programátory, mikroprocesory, operaèní pamìti i pro pou¾ité zobrazovací
prostøedky (grafické karty, tiskárny), ale pøesnì naopak &ndash; zespoda
nahoru. Vzhledem k&nbsp;tomu, ¾e i vykreslování obrázkù pomocí WinAPI se
provádí od spodního okraje, se v¹e výraznì komplikuje. Dùvod, proè je smìr
vykreslování a ukládání u bitmap (pøesnìji øeèeno obrázkù typu BMP) opaèný,
spoèívá v&nbsp;tom, ¾e tuto orientaci pùvodnì pou¾íval operaèní systém OS/2,
který je v¹ak v&nbsp;tomto ohledu alespoò konzistentní &ndash; souøadnice
rostou smìrem od levého spodního rohu smìrem doprava a nahoru. Ve WinAPI se
v¹ak pou¾ívá &bdquo;klasické&ldquo; a pøirozenìj¹í orientace souøadnic, které
rostou od levého horního rohu smìrem doprava a dolù, a tak se opaèný smysl
vykreslování bitmap do tohoto systému vùbec nehodí a u nìkolika API funkcí
zpùsobuje zmatky v&nbsp;chápání smìru.</p>

<p>Nicménì tyto implementaèní detaily nemusí programátory vyu¾ívající
<i>SDL/SDLJava</i> pøíli¹ zajímat. Praktiètìj¹í je informace, ¾e pro naètení
bitmapy se pou¾ívá statická metoda <strong>static SDLSurface.
loadBMP(java.lang.String path)</strong>, které se pøedá cesta k&nbsp;bitmapì a
výsledkem je pøímo objekt typu <strong>SDLSurface</strong>, jen¾ lze buï
zkonvertovat nebo pøímo vykreslit na obrazovku. Pov¹imnìte si, ¾e se této
metodì pøedává øetìzec s&nbsp;cestou a nikoli objekt typu
<strong>File</strong>, tak¾e zále¾í jen na programátorovi, zda správnì o¹etøí
jména souborù s&nbsp;bitmapami takovým zpùsobem, aby byl program pøenositelný
(týká se to zejména oddìlovaèù adresáøù). Pøíklad pou¾ití této metody si
uká¾eme v&nbsp;demonstraèním pøíkladu <strong>SDLTest4</strong>, který je
popsán <a href="#k07">v&nbsp;sedmé kapitole</a>, nicménì základní idiom
je jednoduchý:</p>

<pre>
<i>// nacteni bitmapy z externiho souboru</i>
SDLSurface bitmap = SDLVideo.loadBMP("test.bmp");
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Podpora dal¹ích grafických formátù</h2>

<p>Podpora grafického formátu <i>BMP</i> v&nbsp;jádru knihovny <i>SDL</i>
nemusí být pro mnoho aplikací dostaèující, zejména ve chvíli, kdy je napøíklad
vyvíjena hra s&nbsp;velkým mno¾stvím obrázkù. V&nbsp;takovém pøípadì by byly
nároky na potøebnou kapacitu disku zbyteènì velké; navíc má formát <i>BMP</i>
jen omezené mo¾nosti definice prùhlednosti pixelù. Alternativním øe¹ením je
vyu¾ití jednoho z&nbsp;pøídavných modulù knihovny <i>SDL</i>, který se jmenuje
<i>SDL_image</i>. I tento modul je v&nbsp;knihovnì <i>SDLJava</i> dostupný a to
konkrétnì pøes tøídu <strong>sdljava.image.SDLImage</strong>. Tato tøída
obsahuje jen jedinou pøetí¾enou statickou metodu <strong>load()</strong>, která
vrací, podobnì jako vý¹e popsaná metoda <strong>SDLSurface.loadBMP()</strong>,
objekt typu <strong>SDLSurface</strong>. Pøes
<strong>sdljava.image.SDLImage.load()</strong> je mo¾né naèíst bitmapy ulo¾ené
do rùzných formátù, ov¹em pro vìt¹inu programátorù budou pravdìpodobnì
nejdùle¾itìj¹í formáty <i>PNG</i> a <i>JPEG</i>:</p>

<table>
<tr><th> #</th><th>Metoda</th><th>Popis</th></tr>
<tr><td> 1</td><td>static SDLSurface load(java.nio.Buffer buf)   </td><td>naètení bitmapy, která je ulo¾ena v&nbsp;bufferu</td></tr>
<tr><td> 2</td><td>static SDLSurface load(byte[] data)           </td><td>naètení bitmapy ulo¾ené v&nbsp;poli</td></tr>
<tr><td> 3</td><td>static SDLSurface load(java.io.InputStream in)</td><td>naètení bitmapy ze vstupního proudu</td></tr>
<tr><td> 4</td><td>static SDLSurface load(java.lang.String file) </td><td>naètení bitmapy ze souboru specifikovaného jménem</td></tr>
<tr><td> 5</td><td>static SDLSurface load(java.net.URL url)      </td><td>naètení bitmapy z&nbsp;místa specifikovaného pomocí URL</td></tr>
</table>

<p>V&nbsp;mnoha aplikacích se programátoøi pravdìpodobnì spokojí
s&nbsp;naètením ka¾dé bitmapy ze samostatného souboru, ov¹em nìkdy mù¾e být
výhodnìj¹í v¹echny bitmapy ulo¾it do souboru jediného a pro jejich naètení
následnì vyu¾ít vstupní proud popø.&nbsp;buffer. Knihovna <i>SDLJava</i> sama
rozpozná hlavièku grafického formátu i ukonèení obrázku.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Operace typu <i>BitBLT</i> realizovaná mezi dvìma objekty typu <strong>sdljava.video.SDLSurface</strong></h2>

<p>Jakmile jsou bitmapy naèteny z&nbsp;externích souborù, je nutné je nìjakým
zpùsobem vykreslit. V&nbsp;knihovnì <i>SDLJava</i> se tato operace provádí
pomocí pøetí¾ené metody <strong>SDLSurface.blitSurface()</strong>. Tato metoda
existuje ve tøech variantách, které se od sebe li¹í poètem a významem
parametrù. Základní operace v¹ak zùstává stejná &ndash; zdrojová bitmapa
(tj.&nbsp;objekt typu <strong>SDLSurface</strong>) je pøenesena do bitmapy
cílové, která je v¾dy pøedána v&nbsp;prvním parametru metody
<strong>SDLSurface.blitSurface()</strong>. V&nbsp;pøípadì, ¾e je zdrojová
bitmapa men¹í ne¾ bitmapa cílová, je zdrojová bitmapa pøenesena do levého
horního rohu cílové bitmapy. Pokud je naopak zdrojová bitmapa vìt¹í, je pøi
jejím pøenosu provedeno její oøezání.</p>

<p>Pokud je nutné explicitnì specifikovat pozici zdrojové bitmapy
v&nbsp;bitmapì cílové, pou¾ívá se druhá varianta metody
<strong>SDLSurface.blitSurface()</strong>, kde se ký¾ená pozice specifikuje
pomocí objektu typu <strong>SDLRect</strong> (význam má jen pozice jeho levého
horního rohu). Ov¹em pøi pøenosu bitmapy je mo¾né provést i její oøezání na
základì informací ulo¾ených ve druhém objektu typu <strong>SDLRect</strong>.
Souøadnice pøedstavované tímto objektem se vztahují v¾dy ke zdrojové bitmapì
(k&nbsp;jejímu lokálnímu souøadnému systému):</p>

<table>
<tr><th> #</th><th>Metoda</th><th>Popis</th></tr>
<tr><td> 1</td><td>int blitSurface(SDLSurface dstSurface)</td><td>pøenos bitmapy do levého horního rohu cílové bitmapy</td></tr>
<tr><td> 2</td><td>int blitSurface(SDLSurface dstSurface, SDLRect dst)</td><td>pøedchozí operace + mo¾nost specifikace místa, na nìj¾ bude bitmapa pøenesena</td></tr>
<tr><td> 3</td><td>int blitSurface(SDLRect src, SDLSurface dstSurface, SDLRect dst)</td><td>pøedchozí operace + mo¾nost specifikace oøezového obdélníka</td></tr>
</table>

<p>V¹echny tøi varianty budou pou¾ity v&nbsp;demonstraèních pøíkladech.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Demonstraèní pøíklad <strong>SDLTest4</strong> &ndash; naètení bitmapy typu BMP a provedení operace <i>BitBLT</i></h2>

<p>V&nbsp;prvním demonstraèním pøíkladu si uká¾eme zpùsob naètení bitmapy
s&nbsp;jejím následným vykreslením na obrazovku. Nejprve je provedena
inicializace knihovny <i>SDL</i> s&nbsp;vyu¾itím statické metody
<strong>SDLMain.init()</strong>, které se pomocí konstanty
<strong>SDLMain.SDL_INIT_VIDEO</strong> pøedá informace o tom, ¾e se bude
vyu¾ívat pouze grafický subsystém <i>SDL</i>. Následnì je s&nbsp;vyu¾itím
takté¾ statické metody <strong>SDLVideo.setVideoMode()</strong> provedeno
pøepnutí do celoobrazovkového grafického re¾imu s&nbsp;rozli¹ením 800&times;600
pixelù a s&nbsp;bitovou hloubkou 16 bitù na pixel. V¹echny tyto operace jsme si
ji¾ popsali v&nbsp;pøedchozí èásti tohoto seriálu. Následnì se s&nbsp;vyu¾itím
metody <strong>SDLVideo.loadBMP()</strong> naète bitmapa ulo¾ená ve formátu
Microsoft Bitmap. Návratovou hodnotou této metody je instance tøídy
<strong>SDLSurface</strong>, v&nbsp;ní¾ jsou ulo¾eny jak hodnoty (barvy)
jednotlivých pixelù, tak i rozmìry bitmapy, její formát apod. Bitmapa je na
obrazovku vykreslena pomocí metody
<strong>SDLSurface.blitSurface(SDLSurface)</strong>, pøièem¾ plochou/bitmapou,
do ní¾ má být vykreslení provedeno, je samotný framebuffer.</p>

<p>Pøíklad má poøadové èíslo 4, proto¾e navazuje na demonstraèní pøíklady
vysvìtlené minule:</p>

<pre>
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.video.SDLVideo;
import sdljava.video.SDLSurface;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Ctvrty demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> * Po spusteni se provede prepnuti do grafickeho rezimu 800x600x16</i>
<i> * Po inicializaci grafickeho rezimu se nacte bitmapa "xscorch.bmp",</i>
<i> * ktera se nasledne vykresli na obrazovku operaci typu BitBLT.</i>
<i> */</i>
public class <strong>SDLTest4</strong> {
&nbsp;
    <i>/**</i>
    <i> * Horizontalni rozliseni vybraneho grafickeho rezimu.</i>
    <i> */</i>
    private static final int <strong>GFX_WIDTH</strong> = 800;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni rozliseni vybraneho grafickeho rezimu.</i>
    <i> */</i>
    private static final int <strong>GFX_HEIGHT</strong> = 600;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka vybraneho grafickeho rezimu.</i>
    <i> */</i>
    private static final int <strong>GFX_BPP</strong> = 16;
&nbsp;
    <i>/**</i>
    <i> * Nazev bitmapy, ktera se ma nacist a nasledne zobrazit.</i>
    <i> */</i>
    private static final String <strong>IMAGE_NAME</strong> = "xscorch.bmp";
&nbsp;
    <i>/**</i>
    <i> * Vykresleni bitmapy na obrazovku.</i>
    <i> * </i>
    <i> * @param screen</i>
    <i> *            framebuffer</i>
    <i> * @param bitmap</i>
    <i> *            bitmapa, ktery se ma na obrazovku vykreslit</i>
    <i> */</i>
    private static void <strong>drawOnScreen</strong>(SDLSurface screen, SDLSurface bitmap) throws SDLException {
        <i>// provest operaci typu BitBLT</i>
        bitmap.blitSurface(screen);
        <i>// nutno volat i v pripade, ze neni pouzit double buffering</i>
        screen.updateRect();
        screen.flip();
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace video subsystemu knihovny SDL.</i>
            SDLMain.init(SDLMain.SDL_INIT_VIDEO);
            <i>// inicializace celoobrazovkoveho grafickeho rezimu</i>
            final SDLSurface screen = SDLVideo.setVideoMode(GFX_WIDTH, GFX_HEIGHT, GFX_BPP, SDLVideo.SDL_FULLSCREEN);
            <i>// nacteni bitmapy z externiho souboru</i>
            final SDLSurface bitmap = SDLVideo.loadBMP(IMAGE_NAME);
            <i>// vykresleni bitmapy na obrazovku</i>
            drawOnScreen(screen, bitmap);
            Thread.sleep(5000);
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
    }
}
</pre>

<p>Skript pro pøeklad (Linux):</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest4.java
</pre>

<p>Skript pro pøeklad (Windows):</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest4.java
</pre>

<p>Skript pro spu¹tìní (Linux):</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest4.java
</pre>

<p>Skript pro spu¹tìní (Windows):</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest4
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Demonstraèní pøíklad <strong>SDLTest5</strong> &ndash; urèení pozice, kde se má bitmapa vykreslit</h2>

<p>V&nbsp;dne¹ním druhém demonstraèním pøíkladu pojmenovaném
<strong>SDLTest5</strong> si uká¾eme dal¹í mo¾nosti nabízené metodou
<strong>SDLSurface.blitSurface</strong>. V&nbsp;pøedchozím pøíkladu se bitmapa
naètená z&nbsp;externího souboru zobrazila v&nbsp;levém horním rohu obrazovky
nastavené na grafický re¾im 800&times;600&times;16 bpp. V&nbsp;naprosté vìt¹inì
pøípadù (snad a¾ na vykreslení pozadí celé scény) v¹ak budeme potøebovat
vykreslit bitmapu na jinou pozici na obrazovce. K&nbsp;tomuto úèelu se musí
namísto metody <strong>SDLSurface.blitSurface(SDLSurface dstSurface)</strong>
pou¾ít její roz¹íøená varianta <strong>blitSurface(SDLSurface dstSurface,
SDLRect dst)</strong>. Této metodì se navíc pøedává obdélník, jeho¾ poèáteèní
souøadnice (x,y) urèují, ve kterém místì na obrazovce (èi na jiné bitmapì) se
má zdrojová bitmapa zaèít vykreslovat, tj.&nbsp;kde bude le¾et její horní levý
roh. ©íøka a vý¹ka obdélníku zde nemá prakticky ¾ádný význam,
v&nbsp;demonstraèním pøíkladu se v¹ak pro úplnost nastaví i tyto dva atributy,
a to konkrétnì v&nbsp;metodì <strong>computePositionOnScreen</strong>.</p>

<p>Následuje výpis zdrojového kódu dne¹ního druhého demonstraèního
pøíkladu:</p>

<pre>
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.video.SDLRect;
import sdljava.video.SDLVideo;
import sdljava.video.SDLSurface;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Paty demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> * Po spusteni se provede prepnuti do grafickeho rezimu 800x600x16</i>
<i> * Po inicializaci grafickeho rezimu se nacte bitmapa "xscorch.bmp",</i>
<i> * ktera se nasledne vykresli na obrazovku operaci typu BitBLT, ovsem</i>
<i> * se specifikaci presneho umisteni bitmapy na obrazovce.</i>
<i> */</i>
public class <strong>SDLTest5</strong> {
&nbsp;
    <i>/**</i>
    <i> * Horizontalni rozliseni vybraneho grafickeho rezimu.</i>
    <i> */</i>
    private static final int <strong>GFX_WIDTH</strong> = 800;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni rozliseni vybraneho grafickeho rezimu.</i>
    <i> */</i>
    private static final int <strong>GFX_HEIGHT</strong> = 600;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka vybraneho grafickeho rezimu.</i>
    <i> */</i>
    private static final int <strong>GFX_BPP</strong> = 16;
&nbsp;
    <i>/**</i>
    <i> * Nazev bitmapy, ktera se ma nacist a nasledne zobrazit.</i>
    <i> */</i>
    private static final String <strong>IMAGE_NAME</strong> = "xscorch.bmp";
&nbsp;
    <i>/**</i>
    <i> * Vykresleni bitmapy na obrazovku.</i>
    <i> * </i>
    <i> * @param screen</i>
    <i> *            framebuffer</i>
    <i> * @param bitmap</i>
    <i> *            bitmapa, ktery se ma na obrazovku vykreslit</i>
    <i> */</i>
    private static void <strong>drawOnScreen</strong>(SDLSurface screen, SDLSurface bitmap) throws SDLException {
        <i>// vypocitat umisteni bitmapy na obrazovce.</i>
        final SDLRect rect = computePositionOnScreen(screen, bitmap);
        <i>// provest operaci typu BitBLT</i>
        bitmap.blitSurface(screen, rect);
        <i>// nutno volat i v pripade, ze neni pouzit double buffering</i>
        screen.updateRect();
        screen.flip();
    }
&nbsp;
    <i>/**</i>
    <i> * Vypocitat umisteni bitmapy na obrazovce.</i>
    <i> * </i>
    <i> * @param screen</i>
    <i> *            framebuffer</i>
    <i> * @param bitmap</i>
    <i> *            bitmapa, ktery se ma na obrazovku vykreslit</i>
    <i> * @return obdelnik predstavujici pozici bitmapy na obrazovce</i>
    <i> */</i>
    private static SDLRect <strong>computePositionOnScreen</strong>(SDLSurface screen, SDLSurface bitmap) {
        <i>// ziskat rozmery obrazovky i bitmapy</i>
        final int screenWidth = screen.getWidth();
        final int screenHeight = screen.getHeight();
        final int bitmapWidth = bitmap.getWidth();
        final int bitmapHeight = bitmap.getHeight();
&nbsp;
        <i>// vypocitat umisteni bitmapy na obrazovce</i>
        final int x = (screenWidth - bitmapWidth)&gt;&gt;1;
        final int y = (screenHeight - bitmapHeight)&gt;&gt;1;
        return new SDLRect(x, y, bitmapWidth, bitmapHeight);
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace video subsystemu knihovny SDL.</i>
            SDLMain.init(SDLMain.SDL_INIT_VIDEO);
            <i>// inicializace celoobrazovkoveho grafickeho rezimu</i>
            final SDLSurface screen = SDLVideo.setVideoMode(GFX_WIDTH, GFX_HEIGHT, GFX_BPP, SDLVideo.SDL_FULLSCREEN);
            <i>// nacteni bitmapy z externiho souboru</i>
            final SDLSurface bitmap = SDLVideo.loadBMP(IMAGE_NAME);
            <i>// vykresleni bitmapy na obrazovku</i>
            drawOnScreen(screen, bitmap);
            Thread.sleep(5000);
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
    }
}
</pre>

<p>Skript pro pøeklad (Linux):</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest5.java
</pre>

<p>Skript pro pøeklad (Windows):</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest5.java
</pre>

<p>Skript pro spu¹tìní (Linux):</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest5.java
</pre>

<p>Skript pro spu¹tìní (Windows):</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest5
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Demonstraèní pøíklad <strong>SDLTest6</strong> &ndash; oøez bitmapy pøi provádìní operace typu <i>BitBLT</i></h2>

<p>V&nbsp;dal¹ím demonstraèním pøíkladu nazvaném <strong>SDLTest6</strong> se
takté¾ vykresluje bitmapa naètená z&nbsp;externího souboru typu BMP (Windows
Bitmap), ov¹em soubì¾nì s&nbsp;vykreslováním této bitmapy s&nbsp;vyu¾itím
operace <i>BitBLT</i> se aplikuje i oøezávání rastrového obrázku na základì
údajù pøedaných <a href="#k02">ve vý¹e popsané</a> datové struktuøe typu
<strong>SDLRect</strong>. Aby byl efekt oøezávání lépe viditelný, není bitmapa
do framebufferu vykreslena pouze jedenkrát; namísto toho je na displeji
zobrazena jednoduchá animace spoèívající v&nbsp;plynulém posunování oøezového
obdélníku pøes vykreslovanou (&bdquo;blitovanou&ldquo;) bitmapu. Celkem je
zobrazeno tisíc snímkù animace, pøièem¾ minimální doba jednoho snímku je
nastavena na deset milisekund. Zpùsobem pøesnìj¹ího èasování se budeme zabývat
pozdìji, v&nbsp;dne¹ním jednoduchém pøíkladu nám v¹ak bude dostaèovat pou¾ití
<strong>Thread.sleep(10)</strong>. Zdrojový kód demonstraèního pøíkladu vypadá
následovnì:</p>

<pre>
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.video.SDLRect;
import sdljava.video.SDLVideo;
import sdljava.video.SDLSurface;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Sesty demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> * Po spusteni se provede prepnuti do grafickeho rezimu 800x600x16</i>
<i> * Po inicializaci grafickeho rezimu se nacte bitmapa "xscorch.bmp".</i>
<i> * Nasledne se provede demonstrace moznosti metody</i>
<i> * blitSurface(SDLRect src, SDLSurface dstSurface, SDLRect dst)</i>
<i> */</i>
public class <strong>SDLTest6</strong> {
&nbsp;
    <i>/**</i>
    <i> * Horizontalni rozliseni vybraneho grafickeho rezimu.</i>
    <i> */</i>
    private static final int <strong>GFX_WIDTH</strong> = 800;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni rozliseni vybraneho grafickeho rezimu.</i>
    <i> */</i>
    private static final int <strong>GFX_HEIGHT</strong> = 600;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka vybraneho grafickeho rezimu.</i>
    <i> */</i>
    private static final int <strong>GFX_BPP</strong> = 16;
&nbsp;
    <i>/**</i>
    <i> * Nazev bitmapy, ktera se ma nacist a nasledne zobrazit.</i>
    <i> */</i>
    private static final String <strong>IMAGE_NAME</strong> = "xscorch.bmp";
&nbsp;
    <i>/**</i>
    <i> * Rozmery obdelniku pouziteho pri animaci.</i>
    <i> */</i>
    private static final int SOURCE_RECTANGLE_SIZE = 100;
&nbsp;
    <i>/**</i>
    <i> * Vykresleni jednoduche animace na obrazovku.</i>
    <i> * </i>
    <i> * @param screen</i>
    <i> *            framebuffer</i>
    <i> * @param bitmap</i>
    <i> *            bitmapa, ktery se ma na obrazovku vykreslit</i>
    <i> * @throws InterruptedException</i>
    <i> */</i>
    private static void <strong>drawOnScreen</strong>(SDLSurface screen, SDLSurface bitmap) throws SDLException, InterruptedException {
        <i>// vypocitat umisteni bitmapy na obrazovce.</i>
        final SDLRect dstrect = computePositionOnScreen(screen, bitmap);
        <i>// obdelnik urcujici orezani obrazku</i>
        SDLRect srcrect = new SDLRect(0, 0, SOURCE_RECTANGLE_SIZE, SOURCE_RECTANGLE_SIZE);
        int x = 0, y = 0;
        int dx = 1, dy = 1;
        <i>// jednoducha animace spocivajici v plynule zmene</i>
        <i>// pocatecniho bodu zdrojoveho obdelniku</i>
        for (int i = 0; i &lt; 1000; i++) {
            x += dx;
            y += dy;
            if (x &gt;= bitmap.getWidth() - SOURCE_RECTANGLE_SIZE) {
                dx = -dx;
            }
            if (y &gt;= bitmap.getHeight() - SOURCE_RECTANGLE_SIZE) {
                dy = -dy;
            }
            if (x &lt;= 0) {
                dx = -dx;
            }
            if (y &lt;= 0) {
                dy = -dy;
            }
            <i>// vypocitat pocatecni bod zdrojoveho obdelniku</i>
            srcrect.x = x;
            srcrect.y = y;
            <i>// provest operaci typu BitBLT</i>
            bitmap.blitSurface(srcrect, screen, dstrect);
            <i>// nutno volat i v pripade, ze neni pouzit double buffering</i>
            screen.updateRect();
            screen.flip();
            Thread.sleep(10);
        }
    }
&nbsp;
    <i>/**</i>
    <i> * Vypocitat umisteni bitmapy na obrazovce.</i>
    <i> * </i>
    <i> * @param screen</i>
    <i> *            framebuffer</i>
    <i> * @param bitmap</i>
    <i> *            bitmapa, ktery se ma na obrazovku vykreslit</i>
    <i> * @return obdelnik predstavujici pozici bitmapy na obrazovce</i>
    <i> */</i>
    private static SDLRect <strong>computePositionOnScreen</strong>(SDLSurface screen, SDLSurface bitmap) {
        <i>// ziskat rozmery obrazovky i bitmapy</i>
        final int screenWidth = screen.getWidth();
        final int screenHeight = screen.getHeight();
        final int bitmapWidth = bitmap.getWidth();
        final int bitmapHeight = bitmap.getHeight();
&nbsp;
        <i>// vypocitat umisteni bitmapy na obrazovce</i>
        final int x = (screenWidth - bitmapWidth)&gt;&gt;1;
        final int y = (screenHeight - bitmapHeight)&gt;&gt;1;
        return new SDLRect(x, y, bitmapWidth, bitmapHeight);
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace video subsystemu knihovny SDL.</i>
            SDLMain.init(SDLMain.SDL_INIT_VIDEO);
            <i>// inicializace celoobrazovkoveho grafickeho rezimu</i>
            final SDLSurface screen = SDLVideo.setVideoMode(GFX_WIDTH, GFX_HEIGHT, GFX_BPP, SDLVideo.SDL_FULLSCREEN);
            <i>// nacteni bitmapy z externiho souboru</i>
            final SDLSurface bitmap = SDLVideo.loadBMP(IMAGE_NAME);
            <i>// vykresleni bitmapy na obrazovku</i>
            drawOnScreen(screen, bitmap);
            Thread.sleep(1000);
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
    }
}
</pre>

<p>Skript pro pøeklad (Linux):</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest6.java
</pre>

<p>Skript pro pøeklad (Windows):</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest6.java
</pre>

<p>Skript pro spu¹tìní (Linux):</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest6.java
</pre>

<p>Skript pro spu¹tìní (Windows):</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest6
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Demonstraèní pøíklad <strong>SDLTest7</strong> &ndash; naètení bitmapy ulo¾ené ve formátu PNG</h2>

<p>V&nbsp;dne¹ním posledním demonstraèním pøíkladu pojmenovaném
<strong>SDLTest7</strong> si uká¾eme jeden z&nbsp;mo¾ných zpùsobù naètení
bitmapy ulo¾ené ve formátu odli¹ném od pomìrnì primitivního a neúsporného
formátu Microsoft Bitmap. Zde ji¾ není mo¾né vyu¾ít metodu
<strong>sdljava.video.SDLVideo.loadBMP()</strong>, ale je nutné zavolat mnohem
obecnìj¹í metodu <strong>sdljava.image.SDLImage.load()</strong>, která volá
nativní funkce z&nbsp;<strong>libSDLJava_image.so</strong>
popø.&nbsp;<strong>SDLJava_image.dll</strong> (ve skuteènosti jsou tyto nativní
metody jen mezivrstvou ke knihovnì
<strong>libSDL_image.so/SDL_image.so</strong>). Dùle¾ité je, ¾e je podporován
napøíklad formát <i>PNG</i>, co¾ je velmi u¾iteèné, proto¾e kromì (pomìrnì
dobré) bezztrátové komprimace podporuje tento formát i rùzné metody ulo¾ení
prùhlednosti pixelù, tak¾e do <i>PNG</i> je mo¾né ukládat napøíklad
<i>sprity</i>. S&nbsp;touto v&nbsp;oblasti 2D grafiky známou a ji¾ velmi dlouho
vyu¾ívanou technikou se seznámíme v&nbsp;následující èásti tohoto seriálu. Nyní
se ji¾ podívejme na zdrojový kód demonstraèního pøíkladu:</p>

<pre>
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.video.SDLVideo;
import sdljava.video.SDLSurface;
import sdljava.image.SDLImage;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Sedmy demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> * Po spusteni se provede prepnuti do grafickeho rezimu 800x600x16</i>
<i> * Po inicializaci grafickeho rezimu se nacte bitmapa "xscorch.png",</i>
<i> * ktera se nasledne vykresli na obrazovku operaci typu BitBLT.</i>
<i>*/</i>
public class <strong>SDLTest7</strong> {
&nbsp;
    <i>/**</i>
    <i> * Horizontalni rozliseni vybraneho grafickeho rezimu.</i>
    <i> */</i>
    private static final int <strong>GFX_WIDTH</strong> = 800;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni rozliseni vybraneho grafickeho rezimu.</i>
    <i> */</i>
    private static final int <strong>GFX_HEIGHT</strong> = 600;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka vybraneho grafickeho rezimu.</i>
    <i> */</i>
    private static final int <strong>GFX_BPP</strong> = 16;
&nbsp;
    <i>/**</i>
    <i> * Nazev bitmapy, ktera se ma nacist a nasledne zobrazit.</i>
    <i> */</i>
    private static final String <strong>IMAGE_NAME</strong> = "xscorch.png";
&nbsp;
    <i>/**</i>
    <i> * Vykresleni bitmapy na obrazovku.</i>
    <i> * </i>
    <i> * @param screen</i>
    <i> *            framebuffer</i>
    <i> * @param bitmap</i>
    <i> *            bitmapa, ktery se ma na obrazovku vykreslit</i>
    <i> */</i>
    private static void <strong>drawOnScreen</strong>(SDLSurface screen, SDLSurface bitmap) throws SDLException {
        <i>// provest operaci typu BitBLT</i>
        bitmap.blitSurface(screen);
        <i>// nutno volat i v pripade, ze neni pouzit double buffering</i>
        screen.updateRect();
        screen.flip();
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace video subsystemu knihovny SDL.</i>
            SDLMain.init(SDLMain.SDL_INIT_VIDEO);
            <i>// inicializace celoobrazovkoveho grafickeho rezimu</i>
            final SDLSurface screen = SDLVideo.setVideoMode(GFX_WIDTH, GFX_HEIGHT, GFX_BPP, SDLVideo.SDL_FULLSCREEN);
            <i>// nacteni bitmapy z externiho souboru</i>
            final SDLSurface bitmap = SDLImage.load(IMAGE_NAME);
            <i>// vykresleni bitmapy na obrazovku</i>
            drawOnScreen(screen, bitmap);
            Thread.sleep(5000);
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
    }
}
</pre>

<p>Skript pro pøeklad (Linux):</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest7.java
</pre>

<p>Skript pro pøeklad (Windows):</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest7.java
</pre>

<p>Skript pro spu¹tìní (Linux):</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest7.java
</pre>

<p>Skript pro spu¹tìní (Windows):</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest7
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Repositáø se zdrojovými kódy v¹ech ètyø dne¹ních demonstraèních pøíkladù</h2>

<p>V¹echny ètyøi dne¹ní demonstraèní pøíklady byly spoleènì s&nbsp;podpùrnými
skripty urèenými pro jejich pøeklad a následné spu¹tìní ulo¾eny do Mercurial
repositáøe dostupného na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
Podobnì jako tomu bylo i v&nbsp;pøedchozím dílu, i ke dne¹ním pøíkladùm jsou
pøilo¾eny skripty vyu¾itelné pro jejich pøeklad a spu¹tìní. Navíc byly pøidány
i skripty vyu¾itelné ve Windows:</p>

<table>
<tr><th> #</th><th>Zdrojový soubor/skript</th><th>Umístìní souboru v&nbsp;repositáøi</th></tr>
<tr><td> 1</td><td>SDLTest4.java </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest4/SDLTest4.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest4/SDLTest4.java </a></td></tr>
<tr><td> 2</td><td>SDLTest4_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest4/SDLTest4_compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest4/SDLTest4_compile.sh </a></td></tr>
<tr><td> 3</td><td>SDLTest4_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest4/SDLTest4_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest4/SDLTest4_compile_sys.sh</a></td></tr>
<tr><td> 4</td><td>SDLTest4_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest4/SDLTest4_run.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest4/SDLTest4_run.sh </a></td></tr>
<tr><td> 5</td><td>SDLTest4_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest4/SDLTest4_run_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest4/SDLTest4_run_sys.sh </a></td></tr>
<tr><td> 6</td><td>SDLTest4_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest4/SDLTest4_compile.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest4/SDLTest4_compile.bat </a></td></tr>
<tr><td> 7</td><td>SDLTest4_run.bat </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest4/SDLTest4_run.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest4/SDLTest4_run.bat </a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>SDLTest5.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest5/SDLTest5.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest5/SDLTest5.java </a></td></tr>
<tr><td> 9</td><td>SDLTest5_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest5/SDLTest5_compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest5/SDLTest5_compile.sh </a></td></tr>
<tr><td>10</td><td>SDLTest5_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest5/SDLTest5_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest5/SDLTest5_compile_sys.sh</a></td></tr>
<tr><td>11</td><td>SDLTest5_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest5/SDLTest5_run.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest5/SDLTest5_run.sh </a></td></tr>
<tr><td>12</td><td>SDLTest5_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest5/SDLTest5_run_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest5/SDLTest5_run_sys.sh </a></td></tr>
<tr><td>13</td><td>SDLTest5_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest5/SDLTest5_compile.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest5/SDLTest5_compile.bat </a></td></tr>
<tr><td>14</td><td>SDLTest5_run.bat </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest5/SDLTest5_run.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest5/SDLTest5_run.bat </a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>SDLTest6.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest6/SDLTest6.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest6/SDLTest6.java </a></td></tr>
<tr><td>16</td><td>SDLTest6_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest6/SDLTest6_compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest6/SDLTest6_compile.sh </a></td></tr>
<tr><td>17</td><td>SDLTest6_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest6/SDLTest6_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest6/SDLTest6_compile_sys.sh</a></td></tr>
<tr><td>18</td><td>SDLTest6_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest6/SDLTest6_run.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest6/SDLTest6_run.sh </a></td></tr>
<tr><td>19</td><td>SDLTest6_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest6/SDLTest6_run_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest6/SDLTest6_run_sys.sh </a></td></tr>
<tr><td>20</td><td>SDLTest6_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest6/SDLTest6_compile.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest6/SDLTest6_compile.bat </a></td></tr>
<tr><td>21</td><td>SDLTest6_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest6/SDLTest6_run.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest6/SDLTest6_run.bat </a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>SDLTest7.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest7/SDLTest7.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest7/SDLTest7.java </a></td></tr>
<tr><td>23</td><td>SDLTest7_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest7/SDLTest7_compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest7/SDLTest7_compile.sh </a></td></tr>
<tr><td>24</td><td>SDLTest7_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest7/SDLTest7_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest7/SDLTest7_compile_sys.sh</a></td></tr>
<tr><td>25</td><td>SDLTest7_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest7/SDLTest7_run.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest7/SDLTest7_run.sh </a></td></tr>
<tr><td>26</td><td>SDLTest7_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest7/SDLTest7_run_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest7/SDLTest7_run_sys.sh </a></td></tr>
<tr><td>27</td><td>SDLTest7_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest7/SDLTest7_compile.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest7/SDLTest7_compile.bat </a></td></tr>
<tr><td>28</td><td>SDLTest7_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest7/SDLTest7_run.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6fe0d3a6edeb/sdljava/SDLTest7/SDLTest7_run.bat </a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
</table>

<p>Pro správnou èinnost demonstraèních pøíkladù je nutné mít v&nbsp;pracovním
adresáøi ulo¾enu i dvojici obrázkù <strong>xscorch.bmp</strong> a
<strong>xscorch.png</strong>:</p>

<table>
<tr><th> #</th><th>Bitmapa</th><th>Umístìní souboru v&nbsp;repositáøi</th></tr>
<tr><td> 1</td><td>xscorch.bmp</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/raw-file/6fe0d3a6edeb/sdljava/img/xscorch.bmp">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/raw-file/6fe0d3a6edeb/sdljava/img/xscorch.bmp</a></td></tr>
<tr><td> 2</td><td>xscorch.png</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/raw-file/6fe0d3a6edeb/sdljava/img/xscorch.png">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/raw-file/6fe0d3a6edeb/sdljava/img/xscorch.png</a></td></tr>
</table>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>Class BufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferStrategy.html</a>
</li>

<li>Class Graphics<br />
<a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/Graphics.html">http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/Graphics.html</a>
</li>

<li>Double Buffering and Page Flipping<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html</a>
</li>

<li>BufferStrategy and BufferCapabilities<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/bufferstrategy.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/bufferstrategy.html</a>
</li>

<li>Java:Tutorials:Double Buffering<br />
<a href="http://content.gpwiki.org/index.php/Java:Tutorials:Double_Buffering">http://content.gpwiki.org/index.php/Java:Tutorials:Double_Buffering</a>
</li>

<li>Double buffer in standard Java AWT<br />
<a href="http://www.codeproject.com/Articles/2136/Double-buffer-in-standard-Java-AWT">http://www.codeproject.com/Articles/2136/Double-buffer-in-standard-Java-AWT</a>
</li>

<li>Java 2D: Hardware Accelerating - Part 1 - Volatile Images<br />
<a href="http://www.javalobby.org/forums/thread.jspa?threadID=16840&tstart=0">http://www.javalobby.org/forums/thread.jspa?threadID=16840&tstart=0</a>
</li>

<li>Java 2D: Hardware Accelerating - Part 2 - Buffer Strategies<br />
<a href="http://www.javalobby.org/java/forums/t16867.html">http://www.javalobby.org/java/forums/t16867.html</a>
</li>

<li>How does paintComponent work?<br />
<a href="http://stackoverflow.com/questions/15544549/how-does-paintcomponent-work">http://stackoverflow.com/questions/15544549/how-does-paintcomponent-work</a>
</li>

<li>A Swing Architecture Overview<br />
<a href="http://www.oracle.com/technetwork/java/architecture-142923.html">http://www.oracle.com/technetwork/java/architecture-142923.html</a>
</li>

<li>Class javax.swing.JComponent<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html</a>
</li>

<li>Class java.awt.Component<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html</a>
</li>

<li>Class java.awt.Component.BltBufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.BltBufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.BltBufferStrategy.html</a>
</li>

<li>Class java.awt.Component.FlipBufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.FlipBufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.FlipBufferStrategy.html</a>
</li>

<li>Metoda java.awt.Component.isDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html#isDoubleBuffered()">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html#isDoubleBuffered()</a>
</li>

<li>Metoda javax.swing.JComponent.isDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#isDoubleBuffered()">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#isDoubleBuffered()</a>
</li>

<li>Metoda javax.swing.JComponent.setDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#setDoubleBuffered(boolean)">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#setDoubleBuffered(boolean)</a>
</li>

<li>Javadoc - tøída GraphicsDevice<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html</a>
</li>

<li>Javadoc - tøída GraphicsEnvironment<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html</a>
</li>

<li>Javadoc - tøída GraphicsConfiguration<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html</a>
</li>

<li>Javadoc - tøída DisplayMode<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html">http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html</a>
</li>

<li>Lesson: Full-Screen Exclusive Mode API<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/">http://docs.oracle.com/javase/tutorial/extra/fullscreen/</a>
</li>

<li>Full-Screen Exclusive Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html</a>
</li>

<li>Display Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html</a>
</li>

<li>Using the Full-Screen Exclusive Mode API in Java<br />
<a href="http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm">http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>GC safe-point (or safepoint) and safe-region<br />
<a href="http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html">http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html</a>
</li>

<li>Safepoints in HotSpot JVM<br />
<a href="http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html">http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html</a>
</li>

<li>Java theory and practice: Synchronization optimizations in Mustang<br />
<a href="http://www.ibm.com/developerworks/java/library/j-jtp10185/">http://www.ibm.com/developerworks/java/library/j-jtp10185/</a>
</li>

<li>How to build hsdis<br />
<a href="http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README">http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README</a>
</li>

<li>Java SE 6 Performance White Paper<br />
<a href="http://www.oracle.com/technetwork/java/6-performance-137236.html">http://www.oracle.com/technetwork/java/6-performance-137236.html</a>
</li>

<li>Lukas Stadler's Blog<br />
<a href="http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html">http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html</a>
</li>

<li>How to build hsdis-amd64.dll and hsdis-i386.dll on Windows<br />
<a href="http://dropzone.nfshost.com/hsdis.htm">http://dropzone.nfshost.com/hsdis.htm</a>
</li>

<li>PrintAssembly<br />
<a href="https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly">https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly</a>
</li>

<li>The Java Virtual Machine Specification: 3.14. Synchronization<br />
<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14</a>
</li>

<li>The Java Virtual Machine Specification: 8.3.1.4. volatile Fields<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.4. Memory Model<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.7. Non-atomic Treatment of double and long<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7</a>
</li>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (pøed verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2014</small></p>
</body>
</html>

