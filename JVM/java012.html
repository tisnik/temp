<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Monitorování procesù a správa pamìti v&nbsp;JDK 6 a JDK 7 &ndash; vyu¾ití large pages</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Monitorování procesù a správa pamìti v&nbsp;JDK 6 a JDK 7 &ndash; vyu¾ití large pages</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve dvanácté èásti seriálu o vlastnostech JDK 6 a JDK 7 (samozøejmì vèetnì OpenJDK) si øekneme, z&nbsp;jakého dùvodu mù¾e být v&nbsp;nìkterých pøípadech vhodné pou¾ívat takzvané large pages, známé té¾ pod názvem huge pages. Jedná se o technologii nabízenou nìkterými novìj¹ími procesory, která je podporována i Linuxem (konkrétnì jádry 2.6.x) a samozøejmì i bìhovým prostøedím Javy.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Kdy¾ v¹echny dal¹í pokusy o zvý¹ení výkonnosti sel¾ou...</a></p>
<p><a href="#k02">2. Virtuální adresa vs. fyzická adresa, stránkování</a></p>
<p><a href="#k03">3. Význam TLB</a></p>
<p><a href="#k04">4. Vliv velikosti stránek na výkonnost systému</a></p>
<p><a href="#k05">5. Øe¹ení problému: large (huge) pages</a></p>
<p><a href="#k06">6. Podpora large (huge) pages v&nbsp;JVM</a></p>
<p><a href="#k07">7. Povolení large pages v&nbsp;operaèním systému (1.èást)</a></p>
<p><a href="#k08">8. Obsah následující èásti seriálu</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2>1. Kdy¾ v¹echny dal¹í pokusy o zvý¹ení výkonnosti sel¾ou...</h2>

<p>V&nbsp;pøedchozích èástech seriálu o monitorování a správì pamìti, které je
mo¾né pou¾ít v&nbsp;<i>(Open)JDK 6</i> a samozøejmì i v&nbsp;<i>(Open)JDK
7</i>, jsme si øekli základní informace o funkci správcù pamìti (<i>GC &ndash;
Garbage Collectors</i>) i o tom, jakým zpùsobem je alokována halda
(<i>heap</i>) i jednotlivé oblasti a podoblasti, na nì¾ je halda z&nbsp;dùvodù
efektivnìj¹í správy pamìti rozdìlena. Ov¹em na problémy s&nbsp;výkonností
aplikací psaných v&nbsp;Javì mù¾eme narazit i v&nbsp;tìch pøípadech, pokud je
aplikace naprogramována optimálnì, je zvolen ten nejlep¹í dostupný typ správce
pamìti (samozøejmì volaný s&nbsp;ovìøenými parametry) a i halda je rozdìlena na
základì údajù zji¹tìných pøi testovacích bìzích aplikace. Ponìkud paradoxnì se
mohou výkonnostní problémy objevit na tìch nejlep¹ích poèítaèových systémech
vybavených nìkolika procesory a mnoha gigabajty èi desítkami gigabajtù operaèní
pamìti. Celkem logicky si mù¾eme polo¾it otázku, zda je za tìchto okolností
vùbec mo¾né je¹tì nìco vylep¹it?</p>

<p>Samozøejmì, ¾e v¾dy je mo¾né je¹tì nìco vylep¹it èi poupravit :-), zejména
tehdy, kdy¾ si uvìdomíme, ¾e výkonnostní problém mù¾e v&nbsp;mnoha pøípadech
souviset opìt se správou pamìti, tentokrát ov¹em se správou, kterou do znaèné
míry automaticky provádí samotný mikroprocesor (èi mikroprocesory u
multiprocesorových systémù) v&nbsp;souèinnosti s&nbsp;operaèním systémem.
Prakticky v¹echny moderní procesorové architektury i operaèní systémy toti¾
podporují <i>virtualizaci pamìti</i>, s&nbsp;èím¾ ov¹em souvisí i to, ¾e se
pøístup do pamìti stal ponìkud slo¾itìj¹í a obecnì takté¾ pomalej¹í ne¾ na
architekturách, kde platí rovnost
<strong>virtuální_adresa=fyzická_adresa</strong>. Dùvod, proè tomu tak je, si
struènì vysvìtlíme v&nbsp;navazující kapitole. Upozornìní: v&nbsp;dal¹ím textu
se nebudu zabývat triviálnì zjistitelným problémem souvisejícím
s&nbsp;virtualizací pamìti, konkrétnì se stavem, kdy je systém pomalý
z&nbsp;toho dùvodu, ¾e neustále odkládá a naèítá stránky ze swapovacího
souboru. Zde by bylo øe¹ení následující: úprava velikosti haldy a takté¾
velikosti oblastí na haldì, peèlivý výbìr správce pamìti, pou¾ití
komprimovaných ukazatelù a samozøejmì té¾ pokus o nalezení slabých míst
v&nbsp;aplikaci.</p>



<p><a name="k02"></a></p>
<h2>2. Virtuální adresa vs. fyzická adresa, stránkování</h2>

<p>Pro zaèátek si struènì (a v&nbsp;rámci struènosti i ponìkud nepøesnì)
popi¹me, jakým zpùsobem je vlastnì pamì» spravována na moderních
mikropoèítaèových architekturách. Pøedpokládejme, ¾e si nìjaká aplikace
vy¾ádala od operaèního systému pomocí funkce <strong>malloc()</strong>
napøíklad oblast o velikosti 100kB. Operaèní systém skuteènì tuto oblast
zarezervuje (zde musí spolupracovat s&nbsp;jednotkou <i>MMU</i> mikroprocesoru)
a vrátí aplikaci ukazatel na první volný bajt v&nbsp;novì alokované pamì»ové
oblasti. Aplikaci se sice celá stokilobajtová oblast jeví jako kontinuální,
ov¹em ve skuteènosti je tato oblast na fyzické úrovni rozdìlena do takzvaných
<i>stránek</i>, které mohou být ve fyzické pamìti rozmístìny prakticky
libovolnì (èím déle systém bì¾í, tím k&nbsp;vìt¹í fragmentaci pamì»ového
prostoru dochází) &ndash; dokonce je mo¾né, ¾e nìkteré z&nbsp;ménì èasto
pou¾ívaných stránek budou ulo¾eny do swapovacího oddílu nebo do swapovacího
souboru, tj.&nbsp;nebudou vùbec ulo¾eny ve fyzickém pamì»ovém modulu.</p>

<p>V&nbsp;praxi to tedy znamená, ¾e virtuální adresy jsou obecnì odli¹né od
fyzických adres, tj.&nbsp;od adres, které jsou mikroprocesorem posílány po
adresové sbìrnici ve chvíli ètení èi zápisu slova z/do pamì»ového modulu.
Dokonce se mohou (a na mnoha systémech i budou) li¹it i logické adresy
pou¾ívané v&nbsp;aplikacích od adres virtuálních, ov¹em to nesouvisí pøímo se
stránkováním, ale se segmentací pamìti (pøesnìji øeèeno spodních <i>n</i> bitù
virtuální a fyzické adresy bude toto¾ných, pøièem¾ <i>n</i> souvisí
s&nbsp;velikostí stránek). Navíc musí mít mikroprocesor a souèasnì i operaèní
systém ve vhodné datové struktuøe ulo¾eny v¹echny potøebné informace o
stránkách &ndash; na jakou adresu je ka¾dá stránka mapována ve fyzické pamìti,
zda je stránka ulo¾ena ve swapovacím souboru/oddílu atd. Postupem èasu se tyto
údaje zaèaly ukládat do datových struktur slo¾ených z&nbsp;nìkolika
hierarchicky uspoøádaných tabulek &ndash; u architektury <i>x86</i> se jedná o
dvouúrovòovou hierarchii a v&nbsp;pøípadì pou¾ití <i>PAE</i> o hierarchii
tøíúrovòovou (na 64bitových systémech je to pro jistotu je¹tì o nìco slo¾itìj¹í
:-).</p>



<p><a name="k03"></a></p>
<h2>3. Význam TLB</h2>

<p>Pøepoèet, èi mo¾ná pøesnìji øeèeno <i>mapování</i> mezi virtuální a fyzickou
adresou musí být provádìno pøi ètení èi zápisu ka¾dého bajtu, samozøejmì i pøi
naèítání operaèních kódù instrukcí tvoøících bì¾ící program, ukládání dat na
zásobník atd. Z&nbsp;toho nutnì vyplývá, ¾e mapování adres musí být velmi
rychlé, proto¾e i zdr¾ení o jeden èi dva takty by se negativnì projevilo na
výkonnosti celého systému. Vzhledem k&nbsp;tomu, ¾e procházení hierarchie
tabulek (i kdy¾ je vykonáváno mikroprocesorem resp.&nbsp;jeho modulem
<i>MMU</i>) není tak rychlé, jsou v¹echny moderní procesory vybaveny takzvaným
<i>TLB</i> neboli <i>Translation Lookaside Buffer</i>. Jedná se vlastnì o velmi
rychlou cache pamì» implementovanou pøímo na mikroprocesoru, v&nbsp;ní¾ jsou
ulo¾eny nejèastìji pou¾ívané informace z&nbsp;tabulek stránek. Pokud je pøi
ètení èi zápisu bajtu na virtuální adresu nalezeno v&nbsp;<i>TLB</i> pøíslu¹né
mapování, je v¹e v&nbsp;poøádku &ndash; virtuální adresa se pøevede na adresu
fyzickou.</p>

<p>Problém nastane, pokud se daný vzorek (konkrétnì nejvy¹¹ích <i>n</i> bitù)
virtuální adresy v&nbsp;<i>TLB</i> nenachází. Zde ji¾ musí mikroprocesor
skuteènì projít celou hierarchií tabulek stránek, co¾ je z&nbsp;èasového
hlediska ponìkud nároèné, zejména v&nbsp;pøípadì, ¾e je stránek nìkolik desítek
tisíc, co¾ se pomìrnì snadno stane, jak si ostatnì uká¾eme v&nbsp;následující
kapitole. Pokud se záznam najde, je ihned ulo¾en do <i>TLB</i>, z&nbsp;nìho¾
ov¹em musí být nìkterý ménì èasto pou¾ívaný záznam vymazán (konkrétní strategie
ovládání této pamìti cache je pøed námi ov¹em skryta v&nbsp;mikroprocesoru).
V&nbsp;pøípadì, ¾e ani po projití celé hierarchie není potøebný mapovací záznam
nalezen, je mikroprocesorem vyvolána výjimka, kterou mù¾e operaèní systém
obslou¾it napøíklad tak, ¾e pøíslu¹nou stránku (její¾ virtuální adresu má
samozøejmì k&nbsp;dispozici) pøenese ze swapovacího souboru do fyzické pamìti a
opìt vlo¾í pøíslu¹ný záznam do <i>TLB</i>.</p>



<p><a name="k04"></a></p>
<h2>4. Vliv velikosti stránek na výkonnost systému</h2>

<p>Vra»me se nyní do druhé poloviny osmdesátých let minulého století, kdy firma
<i>Intel</i> uvedla na trh mikroprocesory <i>Intel 80386</i>. Jedná se o první
mikroprocesory øady <i>x86</i>, které mìly implementovanou stránkovací jednotku
a v&nbsp;instrukèní sadì i systému výjimek plnì podporovaly stránkování.
V&nbsp;té dobì byly v&nbsp;bì¾ných poèítaèích instalovány pamìti o kapacitách
v&nbsp;øádu megabajtù, od klasického jednoho megabajtu bì¾ného i u star¹ích
poèítaèù s&nbsp;procesorem <i>Intel 80286</i> pøes pomìrnì obvyklé 4MB (minimum
pro spu¹tìní <i>Doomu</i> :-) a¾ do osmi megabajtù, co¾ byla maximální
dosa¾itelná kapacita na poèítaèích s&nbsp;osmi jednomegabajtovými 30pinovými
moduly <i>SIMM</i> (tyto moduly byly osmibitové, proto se musely u poèítaèù
s&nbsp;32bitovými procesory <i>80386DX</i> instalovat v¾dy po ètveøicích).
Teoretická maximální kapacita 30pinového modulu <i>SIMM</i> je sice 16 MB,
ov¹em moduly s&nbsp;takto velkou kapacitou nebyly zpoèátku k&nbsp;dispozici
&ndash; typické kapacity byly 256 kB a 1 MB.</p>

<p>Vzhledem k&nbsp;tomu, ¾e velikosti stránek mìly být dostateènì malé kvùli
redukci èasu nutného pro ulo¾ení èi naètení stránek ze swapovacího souboru a
takté¾ kvùli tomu, aby se zbyteènì nealokovala stránka zaplnìná jen
z&nbsp;nìkolika procent, zvolila firma <i>Intel</i> za výchozí velikost stránky
hodnotu 4kB, tj.&nbsp;4096 bajtù. Celkový poèet stránek se tedy v&nbsp;pøípadì
tehdy pou¾ívaných kapacit operaèních pamìtí pohyboval v&nbsp;celkem rozumných
mezích. Napøíklad u poèítaèe s&nbsp;4MB pamìti se jednalo o 4MB/4kB=1024
stránek (zde se dopou¹tíme drobné nepøesnosti), co¾ znamenalo, ¾e i <i>TLB</i>
s&nbsp;relativnì malou kapacitou pamìti cache mìl pomìrnì velkou úspì¹nost
(<i>hit rate</i>) pøi vyhledávání stránek, do kterých se èetly èi zapisovaly
bajty. Navíc je dobré si uvìdomit, ¾e pøi tehdej¹ích rychlostech procesorù,
kapacitách RAM a v&nbsp;neposlední øadì i &bdquo;kvalitì&ldquo; operaèních
systémù se prakticky nespou¹tìlo velké mno¾ství paralelnì bì¾ících úloh
souèasnì, co¾ pøi pomìrnì dobré lokalitì dat u jedné úlohy znamenalo, ¾e se
úspì¹nost <i>TLB</i> opìt pomìrnì významnì zvý¹ila.</p>

<p>Celá situace je znázornìna <a
href="http://upload.wikimedia.org/wikipedia/commons/2/2d/080810-protected-386-paging.PNG">na
tomto schématu</a> umístìného na Wikipedii.</p>



<p><a name="k05"></a></p>
<h2>5. Øe¹ení problému: large (huge) pages</h2>

<p>Po uvedení mikroprocesoru <i>Intel 80386</i> na trh se podpora pro
stránkování stala prakticky nedílnou souèástí v¹ech novìj¹ích operaèních
systémù, které pro tuto platformu vznikly. Ov¹em od uvedení procesoru
<i>80386</i> u¾ ubìhlo 25 let a za tu dobu vzrostly bì¾nì pou¾ívané kapacity
operaèních pamìtí na tisícinásobek (!) a souèasnì se i zvý¹il prùmìrný poèet
úloh, které jsou v&nbsp;systému paralelnì provozovány. To mìlo znaèný negativní
dopad na úèinnost <i>TLB</i>, který se sice takté¾ neustále vylep¹oval a
zvy¹oval svoji kapacitu pamìti cache (která musí být typu <i>CAM</i>,
tj.&nbsp;jde o asociativní pamì»), ov¹em i pøes toto vylep¹ování byl ka¾dý
výpadek <i>TLB</i> se zvy¹ující se kapacitou pamìti mnohem hor¹í &ndash;
procesor toti¾ musel v&nbsp;této chvíli prohledávat tabulky stránek, které ji¾
dnes neobsahují jen 1024 stránek jako tomu bylo u 4MB RAM, ale mnohdy i nìkolik
milionù stránek. Výrobci procesorù a ve druhém kole i vývojáøi operaèních
systémù tedy hledali nìjakou cestu, jak tento problém uspokojivì vyøe¹it.</p>

<p>Pou¾ité øe¹ení je vlastnì celkem jednoduché &ndash; kromì dnes ji¾
klasických stránek o velikosti 4 kB podporují novìj¹í procesory i stránky
mnohem vìt¹í, které mají napøíklad velikost 2MB nebo 4MB. Oba dva typy
pamì»ových stránek mohou být pou¾ity spoleènì (my¹leno na jednom systému),
proto¾e v¹echny datové struktury (hierarchické tabulky stránek) zùstávají
zachovány &ndash; jedinou novou informaci pøedstavuje pøíznakový bit ulo¾ený
v&nbsp;tabulkách stránek, který urèuje, zda se jedná o pùvodní ètyøkilobajtovou
stránku nebo o stránku &bdquo;velkou&ldquo; (<i>huge</i>, <i>large</i>). Pøes
slu¾by operaèního systému je mo¾né za¾ádat o alokaci libovolného poètu velkých
stránek, dùle¾ité je ov¹em to, ¾e ne v¾dy se alokace povede, a to i
v&nbsp;pøípadì, ¾e je k&nbsp;dispozici dostatek operaèní pamìti. Dùvod, proè se
nìkdy alokace nepovede, je pochopitelný &ndash; alokovaná stránka musí být ve
fyzické pamìti umístìna na kontinuálních adresách (tj.&nbsp;jedná se o jeden
blok o délce 2MB nebo 4MB), tento blok se v¹ak v&nbsp;pøípadì fragmentované
pamìti systému nepodaøí nalézt. Z&nbsp;tohoto dùvodu je nejlep¹í za¾ádat o
alokaci velkých stránek ihned po startu systému nebo dokonce i v&nbsp;prùbìhu
startování inicializaèních skriptù.</p>



<p><a name="k06"></a></p>
<h2>6. Podpora large (huge) pages v&nbsp;JVM</h2>

<p>Nyní se dostáváme k&nbsp;podpoøe velkých stránek v&nbsp;JVM. Tato
technologie je podporována ji¾ od JDK 5.0 a dá se zapnout pøepínaèem
<strong>-XX:+UseLargePages</strong>, napøíklad následovnì pøi spou¹tìní testu,
jeho¾ zdrojový kód byl uveden minule:</p>

<pre>
java -XX:+UseLargePages ConcurrentConcatenationTest
</pre>

<p>V&nbsp;pøípadì, ¾e se pamì» pro haldu (a nejenom pro ni) nepodaøila
naalokovat pøes velké stránky, nejedná se o zásadní chybu a aplikace bude
pokraèovat v&nbsp;bìhu (i kdy¾ s&nbsp;cca o 10 a¾ 15 procent men¹ím výkonem).
Ov¹em na standardní výstup (ne na výstup chybový!) se vypí¹e podobné
varování:</p>

<pre>
OpenJDK Server VM warning: Failed to reserve shared memory (errno = 5).
</pre>

<p>popø.:</p>

<pre>
OpenJDK Server VM warning: Failed to reserve shared memory (errno = 22).
</pre>

<p>Pokud se toto hlá¹ení objeví, je mo¾né, ¾e velkých stránek není dostateèné
mno¾ství (JVM buï pou¾ije malé stránky nebo stránky velké, nikdy ne jejich
mix), ¾e jsou ji¾ zaalokované jiným procesem, nebo (co¾ je na
nenakonfigurovaných systémech pravdìpodobné) není podpora pro velké stránky
zapnuta.</p>



<p><a name="k07"></a></p>
<h2>7. Povolení large pages v&nbsp;operaèním systému (1.èást)</h2>

<p>Nejprve se musíme pøesvìdèit, jestli daná platforma, tj.&nbsp;jak
mikroprocesor, tak souèasnì i jádro operaèního systému, podporuje práci
s&nbsp;velkými stránkami. To mù¾eme zjistit více zpùsoby, pravdìpodobnì
nejjednodu¹eji následovnì:</p>

<pre>
grep Huge /proc/meminfo
</pre>

<p>Pokud platforma velké stránky podporuje (i kdy¾ není ani jedna naalokována),
vypí¹ou se ètyøi øádky (u nich¾ se èíselné údaje samozøejmì mohou li¹it):</p>

<pre>
HugePages_Total:     0
HugePages_Free:      0
HugePages_Rsvd:      0
Hugepagesize:     2048 kB
</pre>

<p>Dále je ji¾ mo¾né velké stránky naalokovat. Pokud napøíklad potøebujeme na
systému, jeho¾ velké stránky mají velikost 2MB, pou¾ít aplikaci
s&nbsp;velikostí haldy 20MB, postaèuje naalokovat 10 velkých stránek (jedná se
pouze o pøíklad, ve skuteènosti bude halda spí¹e stokrát vìt¹í a bude tedy
potøebovat stokrát více velkých stránek). Následující pøíkaz se musí spou¹tìt
pod rootem:</p>

<pre>
echo 10 &gt; /proc/sys/vm/nr_hugepages
</pre>

<p>O tom, zda alokace skuteènì probìhla, se mù¾eme pøesvìdèit zpìtným
výpisem pseudosouboru:</p>

<pre>
cat /proc/sys/vm/nr_hugepages
10
</pre>

<p>a samozøejmì té¾ vý¹e uvedeným pøíkazem:</p>

<pre>
grep Huge /proc/meminfo
HugePages_Total:    10
HugePages_Free:     10
HugePages_Rsvd:      0
HugePages_Surp:      0
Hugepagesize:     2048 kB
</pre>

<p>Poznámka: vý¹e uvedený postup je vhodný spí¹e pro testování. Pokud se mají
velké stránky alokovat automaticky pøi startu systému, lze provést zmìnu
v&nbsp;souboru <i>/etc/sysctl.conf</i>, napøíklad pøidáním následujícího
øádku:</p>

<pre>
vm.nr_hugepages = 10
</pre>

<p>Nezávisle na zpùsobu specifikace celkového poètu velkých stránek je dobré si
uvìdomit, ¾e JVM buï bude alokovat haldu pouze s&nbsp;vyu¾itím velkých stránek
nebo ji naopak bude alokovat s&nbsp;vyu¾itím bì¾ných malých ètyøkilobajtových
stránek. To znamená, ¾e by celková kapacita rezervovaných velkých stránek
(tj.&nbsp;jejich poèet&times;kapacita) mìla pøesahovat velikost haldy
specifikovanou pomocí pøepínaèe <strong>-Xmx</strong>, jinak bude výsledek
celého sna¾ení spí¹e kontraproduktivní.</p>



<p><a name="k08"></a></p>
<h2>8. Obsah následující èásti seriálu</h2>

<p>Dal¹í postup pøi nastavování velkých stránek je ji¾ do urèité míry závislý
na typu operaèního systému a takté¾ na tom, jaká JDK se pou¾ívá (Oracle JDK,
OpenJDK, IBM JDK atd.). Ka¾dý typ JDK toti¾ mù¾e k&nbsp;velkým stránkám
pøistupovat odli¹ným zpùsobem &ndash; buï pøes sdílenou pamì» nebo pøes
virtuální souborový systém. Z&nbsp;dùvodu velké rozsáhlosti se problematikou
dal¹ího nastavení a pøedev¹ím mìøení výkonnosti Javovských aplikací
vyu¾ívajících velké stránky, budeme vìnovat je¹tì v&nbsp;následující èásti
tohoto seriálu.</p>



<p><a name="k09"></a></p>
<h2>9. Odkazy na Internetu</h2>

<ol>

<li>HugePages<br />
<a href="http://linux-mm.org/HugePages">http://linux-mm.org/HugePages</a>
</li>

<li>Tuning big java heap and linux huge pages<br />
<a href="http://www.tikalk.com/alm/forums/tuning-big-java-heap-and-linux-huge-pages">http://www.tikalk.com/alm/forums/tuning-big-java-heap-and-linux-huge-pages</a>
</li>

<li>How do I set up hugepages in Red Hat Enterprise Linux 4<br />
<a href="http://magazine.redhat.com/2007/05/29/how-do-i-set-up-hugepages-in-red-hat-enterprise-linux-4/">http://magazine.redhat.com/2007/05/29/how-do-i-set-up-hugepages-in-red-hat-enterprise-linux-4/</a>
</li>

<li>Java SE Tuning Tip: Large Pages on Windows and Linux<br />
<a href="http://blogs.sun.com/dagastine/entry/java_se_tuning_tip_large">http://blogs.sun.com/dagastine/entry/java_se_tuning_tip_large</a>
</li>

<li>Translation lookaside buffer<br />
<a href="http://en.wikipedia.org/wiki/Translation_lookaside_buffer">http://en.wikipedia.org/wiki/Translation_lookaside_buffer</a>
</li>

<li>Physical Address Extension<br />
<a href="http://en.wikipedia.org/wiki/Physical_Address_Extension">http://en.wikipedia.org/wiki/Physical_Address_Extension</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a>
</li>

<li>Amdahl's law<br />
<a href="http://en.wikipedia.org/wiki/Amdahl_law">http://en.wikipedia.org/wiki/Amdahl_law</a>
</li>

<li>Garbage collection (computer science)<br />
<a href="http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)</a>
</li>

<li>Dr. Dobb's | G1: Java's Garbage First Garbage Collector<br />
<a href="http://www.drdobbs.com/article/printableArticle.jhtml?articleId=219401061&amp;dept_url=/java/">http://www.drdobbs.com/article/printableArticle.jhtml?articleId=219401061&amp;dept_url=/java/</a>
</li>

<li>Java's garbage-collected heap<br />
<a href="http://www.javaworld.com/javaworld/jw-08-1996/jw-08-gc.html">http://www.javaworld.com/javaworld/jw-08-1996/jw-08-gc.html</a>
</li>

<li>Compressed oops in the Hotspot JVM<br />
<a href="http://wikis.sun.com/display/HotSpotInternals/CompressedOops">http://wikis.sun.com/display/HotSpotInternals/CompressedOops</a>
</li>

<li>32-bit or 64-bit JVM? How about a Hybrid?<br />
<a href="http://blog.juma.me.uk/2008/10/14/32-bit-or-64-bit-jvm-how-about-a-hybrid/">http://blog.juma.me.uk/2008/10/14/32-bit-or-64-bit-jvm-how-about-a-hybrid/</a>
</li>

<li>Compressed object pointers in Hotspot VM<br />
<a href="http://blogs.sun.com/nike/entry/compressed_object_pointers_in_hotspot">http://blogs.sun.com/nike/entry/compressed_object_pointers_in_hotspot</a>
</li>

<li>Java HotSpot(tm) Virtual Machine Performance Enhancements<br />
<a href="http://download.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html">http://download.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html</a>
</li>

<li>Using jconsole<br />
<a href="http://download.oracle.com/javase/1.5.0/docs/guide/management/jconsole.html">http://download.oracle.com/javase/1.5.0/docs/guide/management/jconsole.html</a>
</li>

<li>jconsole &ndash; Java Monitoring and Management Console<br />
<a href="http://download.oracle.com/javase/1.5.0/docs/tooldocs/share/jconsole.html">http://download.oracle.com/javase/1.5.0/docs/tooldocs/share/jconsole.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>x86-64<br />
<a href="http://en.wikipedia.org/wiki/X86-64">http://en.wikipedia.org/wiki/X86-64</a>
</li>

<li>Physical Address Extension<br />
<a href="http://en.wikipedia.org/wiki/Physical_Address_Extension">http://en.wikipedia.org/wiki/Physical_Address_Extension</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>1.6.0_14 (6u14)<br />
<a href="http://www.oracle.com/technetwork/java/javase/6u14-137039.html?ssSourceSiteId=otncn">http://www.oracle.com/technetwork/java/javase/6u14-137039.html?ssSourceSiteId=otncn</a>
</li>

<li>Update Release Notes<br />
<a href="http://www.oracle.com/technetwork/java/javase/releasenotes-136954.html">http://www.oracle.com/technetwork/java/javase/releasenotes-136954.html</a>
</li>

<li>Java virtual machine: 4.10 Limitations of the Java Virtual Machine<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#88659">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#88659</a>
</li>

<li>Java(TM) Platform, Standard Edition 7 Binary Snapshot Releases<br />
<a href="http://dlc.sun.com.edgesuite.net/jdk7/binaries/index.html">http://dlc.sun.com.edgesuite.net/jdk7/binaries/index.html</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>ClosableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>ArrayList (JDK 1.4)<br />
<a href="http://download.oracle.com/javase/1.4.2/docs/api/java/util/ArrayList.html">http://download.oracle.com/javase/1.4.2/docs/api/java/util/ArrayList.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2011</small></p>
</body>
</html>

