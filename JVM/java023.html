<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM (6.èást - instrukèní soubor virtuálního stroje Javy)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM (6.èást - instrukèní soubor virtuálního stroje Javy)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o vlastnostech JVM si popí¹eme první èást instrukcí tvoøících instrukèní soubor virtuálního stroje Javy. Jedná se o instrukce slou¾ící pro ulo¾ení konstant na zásobník operandù, instrukce pro pøesuny dat mezi lokálními promìnnými a zásobníkem operandù a takté¾ o konverzní instrukce.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM (6.èást - instrukèní soubor virtuálního stroje Javy)</a></p>
<p><a href="#k02">2. Instrukce slou¾ící pro ulo¾ení konstanty zvoleného typu na zásobník operandù</a></p>
<p><a href="#k03">3. Demonstraèní pøíklad: vyu¾ití instrukcí pro ulo¾ení konstanty na zásobník</a></p>
<p><a href="#k04">4. Instrukce slou¾ící pro pøesuny dat mezi lokálními promìnnými a zásobníkem operandù</a></p>
<p><a href="#k05">5. Demonstraèní pøíklad: pøesun dat mezi parametry metody a zásobníkem</a></p>
<p><a href="#k06">6. Instrukce pro pøímou manipulaci s&nbsp;prvky ulo¾enými na zásobníku operandù</a></p>
<p><a href="#k07">7. Instrukce pro konverzi mezi rùznými datovými typy</a></p>
<p><a href="#k08">8. Demonstraèní pøíklad: konverze mezi rùznými datovými typy</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM (6.èást - instrukèní soubor virtuálního stroje Javy)</h2>

<p>V&nbsp;dne¹ní èásti seriálu o programovacím jazyku Java i o vlastnostech JVM
(<i>Java Virtual Machine</i>) budeme pokraèovat v&nbsp;popisu instrukèního
souboru zpracovávaného buï pøímo virtuálním strojem Javy (interpretace
bajtkódu), nebo pøekládaného s&nbsp;vyu¾itím <i>JIT</i> (<i>Just In Time</i>)
pøekladaèe do nativního strojového kódu konkrétního mikroprocesoru, na nìm¾
virtuální stroj Javy bì¾í. Pøipomeòme si, ¾e instrukce pou¾ité
v&nbsp;instrukèní sadì JVM pracují s&nbsp;operandy ulo¾enými na takzvaném
<i>zásobníku operandù</i>, který souèasnì slou¾í i pro pøedávání parametrù
volaným metodám a následnì pro získání návratové hodnoty tìchto metod. Nìkteré
instrukce takté¾ pracují s&nbsp;operandy ulo¾enými v&nbsp;zásobníkovém rámci
(<i>stack frame</i>), v&nbsp;nìm¾ se nachází jak parametry pøedané volané
metodì, tak i oblast vyhrazená pro lokální promìnné této metody. Velikost této
pamì»ové oblasti, na ní¾ se mù¾eme dívat jako na pole s&nbsp;mo¾ností indexace
jednotlivých prvkù, je zji¹tìna ji¾ pøi pøekladu zdrojových kódù a virtuální
stroj Javy automaticky provádí kontrolu, zda nedochází k&nbsp;pøekroèení
indexu, tj.&nbsp;ke ètení èi zápisu mimo vyhrazenou oblast (jedná se ov¹em o
pole nehomogenní, proto¾e jeho prvky mohou mít rùzný typ).</p>

<p>Logická struktura pamìti spravované virtuálním strojem Javy, která nás nyní
bude zajímat, je zobrazena pod tímto odstavcem:</p>

<pre>
+============================================+
|              Zásobník (stack)              |
+============================================+
|                                            |
|   +------------------------------------+   |
|   | Zásobníkový rámec #1 (stack frame) |   |
|   +------------------------------------+   |
|   |                                    |   |
|   |      +---------------------+       |   |
|   |      |  Zásobník operandù  |       |   |
|   |      +---------------------+       |   |
|   |                                    |   |
|   |      +---------------------+       |   |
|   |      |  Parametry metody   |       |   |
|   |      |.....................|       |   |
|   |      |  Lokální promìnné   |       |   |
|   |      +---------------------+       |   |
|   |                                    |   |
|   +------------------------------------+   |
|                                            |
|   +------------------------------------+   |
|   | Zásobníkový rámec #2 (stack frame) |   |
|   +------------------------------------+   |
|   |                                    |   |
|   |      +---------------------+       |   |
|   |      |  Zásobník operandù  |       |   |
|   |      +---------------------+       |   |
|   |                                    |   |
|   |      +---------------------+       |   |
|   |      |  Parametry metody   |       |   |
|   |      |.....................|       |   |
|   |      |  Lokální promìnné   |       |   |
|   |      +---------------------+       |   |
|   |                                    |   |
|   +------------------------------------+   |
|                                            |
|   +------------------------------------+   |
|   | Zásobníkový rámec #3 (stack frame) |   |
|   +------------------------------------+   |
|   |                                    |   |
|   |      +---------------------+       |   |
|   |      |  Zásobník operandù  |       |   |
|   |      +---------------------+       |   |
|   |                                    |   |
|   |      +---------------------+       |   |
|   |      |  Parametry metody   |       |   |
|   |      |.....................|       |   |
|   |      |  Lokální promìnné   |       |   |
|   |      +---------------------+       |   |
|   |                                    |   |
|   +------------------------------------+   |
|                                            |
|  ::::::::::::::::::::::::::::::::::::::::  |
|  :: Dal¹í zásobníkové rámce vytváøené  ::  |
|  :: v èase bìhu aplikace pøi volání    ::  |
|  :: metod.                             ::  |
|  ::::::::::::::::::::::::::::::::::::::::  |
+============================================+
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Instrukce slou¾ící pro ulo¾ení konstanty zvoleného typu na zásobník operandù</h2>

<p>První skupinou instrukcí, o nich¾ se dnes zmíníme, jsou instrukce slou¾ící
pro ulo¾ení konstanty na <i>zásobník operandù</i>. Ov¹em je¹tì pøed uvedením
seznamu jednotlivých instrukcí si musíme øíci dva dùle¾ité fakty o celém
instrukèním souboru JVM. Prvním faktem je, ¾e v¹echny dále popsané instrukce
mají operaèní kód o délce pouhého jednoho bajtu, pøièem¾ se za operaèním kódem
u nìkterých instrukcí nachází jeden èi více dal¹ích bajtù pøedstavujících buï
pøímo celoèíselnou konstantu nebo index do <i>constant poolu</i>. Druhým
faktem, který mo¾ná &bdquo;assemblerovským puristùm&ldquo; (mezi které jsem
také je¹tì nedávno patøil :-) mù¾e vadit, je to, ¾e instrukèní sada JVM není
v&nbsp;¾ádném pøípadì ortogonální, tj.&nbsp;mnohé instrukce pracují pouze
s&nbsp;omezeným poètem datových typù a pro ostatní datové typy neexistuje
ekvivalentní instrukce. To napøíklad znamená, ¾e existuje jen velmi málo
instrukcí pro operace nad datovými typy <strong>byte</strong>,
<strong>short</strong> a <strong>char</strong> a prakticky ¾ádná instrukce pro
datový typ <strong>boolean</strong>.</p>

<p>Naproti tomu v¹ak nìkteré dal¹í instrukce obsahují pøímo ve svém operaèním
kódu (tj.&nbsp;v&nbsp;onom jednom bajtu) krátkou celoèíselnou konstantu, která
se vyu¾ívá buï jako index do oblasti lokálních promìnných nebo jako skuteèná
èíselná konstanta. Tato technika je pou¾ita z&nbsp;toho dùvodu, aby byl bajtkód
co mo¾ná nejkrat¹í, proto se také nejvíce místa v&nbsp;instrukèní sadì
&bdquo;obìtovalo&ldquo; na instrukce slou¾ící pro ulo¾ení konstanty typu
<strong>int</strong>. V&nbsp;následující tabulce jsou vypsány v¹echny instrukce
slou¾ící pro ulo¾ení èíselné konstanty na zásobník. Ve sloupci
&bdquo;Instrukce&ldquo; se nachází symbolické jméno instrukce, sloupec
&bdquo;Opkód&ldquo; obsahuje bajtovou hodnotu ulo¾enou pøímo v&nbsp;bajtkódu
(tedy operaèní kód instrukce), ve sloupcích &bdquo;Data 1&ldquo; a &bdquo;Data
2&ldquo; jsou vypsány bajty, které jsou pøípadnì ulo¾eny ihned za operaèním
kódem a ve sloupci &bdquo;Typ&ldquo; je uveden datový typ skuteènì ulo¾ený na
<i>zásobník operandù</i>:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Data 1</th><th>Data 2</th><th>Typ na zásobníku</th><th>Popis</th></tr>
<tr><td>01</td><td>aconst_null</td><td>0x01</td><td>&nbsp;</td><td>&nbsp;</td><td>ref.</td><td>ulo¾ení reference "null" na zásobník</td></tr>
<tr><td>02</td><td>iconst_m1</td><td>0x02</td><td>&nbsp;</td><td>&nbsp;</td><td>int</td><td>ulo¾ení konstanty -1 na zásobník</td></tr>
<tr><td>03</td><td>iconst_0</td><td>0x03</td><td>&nbsp;</td><td>&nbsp;</td><td>int</td><td>ulo¾ení konstanty 0 na zásobník</td></tr>
<tr><td>04</td><td>iconst_1</td><td>0x04</td><td>&nbsp;</td><td>&nbsp;</td><td>int</td><td>ulo¾ení konstanty 1 na zásobník</td></tr>
<tr><td>05</td><td>iconst_2</td><td>0x05</td><td>&nbsp;</td><td>&nbsp;</td><td>int</td><td>ulo¾ení konstanty 2 na zásobník</td></tr>
<tr><td>06</td><td>iconst_3</td><td>0x06</td><td>&nbsp;</td><td>&nbsp;</td><td>int</td><td>ulo¾ení konstanty 3 na zásobník</td></tr>
<tr><td>07</td><td>iconst_4</td><td>0x07</td><td>&nbsp;</td><td>&nbsp;</td><td>int</td><td>ulo¾ení konstanty 4 na zásobník</td></tr>
<tr><td>08</td><td>iconst_5</td><td>0x08</td><td>&nbsp;</td><td>&nbsp;</td><td>int</td><td>ulo¾ení konstanty 5 na zásobník</td></tr>
<tr><td>09</td><td>lconst_0</td><td>0x09</td><td>&nbsp;</td><td>&nbsp;</td><td>long</td><td>ulo¾ení konstanty 0L na zásobník</td></tr>
<tr><td>10</td><td>lconst_1</td><td>0x0a</td><td>&nbsp;</td><td>&nbsp;</td><td>long</td><td>ulo¾ení konstanty 1L na zásobník</td></tr>
<tr><td>11</td><td>fconst_0</td><td>0x0b</td><td>&nbsp;</td><td>&nbsp;</td><td>float</td><td>ulo¾ení konstanty 0.0f na zásobník</td></tr>
<tr><td>12</td><td>fconst_1</td><td>0x0c</td><td>&nbsp;</td><td>&nbsp;</td><td>float</td><td>ulo¾ení konstanty 1.0f na zásobník</td></tr>
<tr><td>13</td><td>fconst_2</td><td>0x0d</td><td>&nbsp;</td><td>&nbsp;</td><td>float</td><td>ulo¾ení konstanty 2.0f na zásobník</td></tr>
<tr><td>14</td><td>dconst_0</td><td>0x0e</td><td>&nbsp;</td><td>&nbsp;</td><td>double</td><td>ulo¾ení konstanty 0.0 na zásobník</td></tr>
<tr><td>15</td><td>dconst_1</td><td>0x0f</td><td>&nbsp;</td><td>&nbsp;</td><td>double</td><td>ulo¾ení konstanty 1.0 na zásobník</td></tr>
<tr><td>16</td><td>bipush</td><td>0x10</td><td>byteconst</td><td>&nbsp;</td><td>int</td><td>ulo¾ení "byteconst" na zásobník s konverzí na int</td></tr>
<tr><td>17</td><td>sipush</td><td>0x11</td><td>hi-byte</td><td>lowbyte</td><td>int</td><td>ulo¾ení slova hibyte-lowbyte na zásobník s konverzí na int</td></tr>
<tr><td>18</td><td>ldc</td><td>0x12</td><td>index  </td><td>&nbsp; </td><td>string/ref/int/float</td><td>naète konstantu z&nbsp;constant poolu (mù¾e se jednat i o referenci)</td></tr>
<tr><td>19</td><td>ldc_w</td><td>0x13</td><td>hi-byte</td><td>lowbyte</td><td>string/ref/int/float</td><td>naète konstantu z&nbsp;constant poolu (index je ¹estnáctibitový)</td></tr>
<tr><td>20</td><td>ldc2_w</td><td>0x14</td><td>hi-byte</td><td>lowbyte</td><td>long/double</td><td>toté¾ co pøedchozí instrukce, ale pro typy long a double (ty mají v&nbsp;constant poolu vyhrazeny dvì polo¾ky)</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Demonstraèní pøíklad: vyu¾ití instrukcí pro ulo¾ení konstanty na zásobník</h2>

<p>Pøi pohledu na tabulku uvedenou <a href="#k02">v&nbsp;pøedchozí kapitole</a>
se mù¾e zdát, ¾e nìkteré instrukce jsou zdánlivì shodné. Napøíklad se jedná o
pár instrukcí <strong>iconst_1</strong> a <strong>lconst_1</strong>. Ve
skuteènosti v¹ak tyto instrukce pracují s&nbsp;rozdílnými datovými typy, co¾ je
kontrolováno za bìhu JVM. Toté¾ platí i u trojice instrukcí
<strong>ldc*</strong> u nich¾ je typ zji¹tìn pøímo z&nbsp;typu konstanty
ulo¾ené na <i>constant poolu</i> (typicky se jedná o reference na objekty èi o
reálné konstanty). V¹imnìte si také, ¾e práce s&nbsp;typy <strong>long</strong>
a <strong>double</strong> témìø v¾dy vede k&nbsp;vygenerování del¹ího bajtkódu,
proto¾e konstanty tohoto typu ulo¾ené na <i>constant poolu</i> lze adresovat
jen s&nbsp;vyu¾itím ¹estnáctibitového indexu (popravdì øeèeno je v&nbsp;tomto
pøípadì jak struktura <i>constant poolu</i>, tak i struktura bajtkódu navr¾ena
dosti ne¹»astnì a nelogicky; jen tì¾ko lze odhadnout, kolik kilobajtù
pamì»ového prostoru je kvùli této nelogiènosti zbyteènì alokováno pro ka¾dou
bì¾ící JVM).</p>

<p>Pojïme se podívat je¹tì na dal¹í vlastnosti instrukcí vypsaných
v&nbsp;pøedchozí tabulce. Zajímavé napøíklad je, ¾e nìkteré pøíkazy lze provést
více zpùsoby, proto¾e napøíklad instrukce <strong>iconst_1</strong>,
<strong>bipush 1</strong> a <strong>sipush 1</strong> jsou funkènì ekvivalentní
&ndash; v¹echny toti¾ slou¾í pro ulo¾ení konstanty 1 typu <i>int</i> na
zásobník operandù. Ve skuteènosti ale pøekladaè v&nbsp;tomto pøípadì v¾dy
vybere nejkrat¹í instrukci, tj.&nbsp;<strong>iconst_1</strong> (ta má délku jen
jeden bajt, zatímco <strong>bipush 1</strong> má dva bajty a <strong>sipush
1</strong> dokonce bajty tøi). Toté¾ platí napøíklad pro instrukce
<strong>bipush 100</strong>, <strong>sipush 100</strong> a <strong>ldc (index
na konstantu 100 ulo¾enou na constant poolu)</strong>. I v&nbsp;tomto pøípadì
pøekladaè vybere první instrukci, proto¾e ne nejkrat¹í (u¾ jen z&nbsp;toho
dùvodu, ¾e se u¹etøí jeden záznam na <i>constant poolu</i>). V¹e si uká¾eme na
následujícím demonstraèním pøíkladu, jeho¾ zdrojový kód má tvar:</p>

<pre>
class Test1 {
&nbsp;
    static void method1() {
        nop(0, 1, 2);
    }
&nbsp;
    static void method2() {
        nop(3, 4, 5);
    }
&nbsp;
    static void method3() {
        nop(6, 7, 8);
    }
&nbsp;
    static void method4() {
        nop(32, 127, -128);
    }
&nbsp;
    static void method5() {
        nop(128, 32767, -32768);
    }
&nbsp;
    static void method6() {
        nop(0x12345678, 0x00aabbcc, 789789);
    }
&nbsp;
    static void method7() {
        nop(0.0f, 1.0f);
    }
&nbsp;
    static void method8() {
        nop(2.0f, 3.0f);
    }
&nbsp;
    static void method9() {
        nop(0.0, 1.0);
    }
&nbsp;
    static void method10() {
        nop(2.0, 3.0);
    }
&nbsp;
    static void method11() {
        nop(null);
    }
&nbsp;
    static void method12() {
        nop("pokus");
    }
&nbsp;
    static void nop(int a, int b, int c) {
        // nic ;-)
    }
&nbsp;
    static void nop(float a, float b) {
        // opìt nic ;-)
    }
&nbsp;
    static void nop(double a, double b) {
        // opìt nic ;-)
    }
&nbsp;
    static void nop(Object o) {
        // opìt nic ;-)
    }
&nbsp;
}
</pre>

<p>Jak je ze zdrojového kódu tøídy <strong>Test1</strong> patrné, je v&nbsp;nìm
z&nbsp;nìkolika testovacích metod volána pøetí¾ená statická metoda
<strong>nop(int, int, int)</strong>, <strong>nop(float, float)</strong>,
<strong>nop(double, double)</strong> èi <strong>nop(Object)</strong>, která ve
skuteènosti nic neprovádí a takté¾ nic nevrací (její návratový typ je ve v¹ech
pøípadech <strong>void</strong>). My budeme sledovat, jakým zpùsobem se pøelo¾í
zbylé metody <strong>method*</strong>, které musí pøed zavoláním
<strong>nop()</strong> umístit v¹echny parametry na zásobník, tj.&nbsp;pou¾ít
instrukce z&nbsp;tabulky uvedené <a href="#k02">ve druhé kapitole</a>.
Následuje výpis disassemlovaného bajtkódu s&nbsp;ruènì dopsanými
poznámkami:</p>

<pre>
static void method1();
  Code:
   Stack=3, Locals=0, Args_size=0
   0:   iconst_0            // konstanta 1 je pøímo souèástí operaèního kódu instrukce
   1:   iconst_1            // konstanta 2 je pøímo souèástí operaèního kódu instrukce
   2:   iconst_2            // konstanta 3 je pøímo souèástí operaèního kódu instrukce
   3:   invokestatic    #2; // volání metody void nop(int, int, int)
   6:   return              // návrat do volající metody
</pre>

<pre>
static void method2();
  Code:
   Stack=3, Locals=0, Args_size=0
   0:   iconst_3            // konstanta 4 je pøímo souèástí operaèního kódu instrukce
   1:   iconst_4            // konstanta 5 je pøímo souèástí operaèního kódu instrukce
   2:   iconst_5            // konstanta 6 je pøímo souèástí operaèního kódu instrukce
   3:   invokestatic    #2; // volání metody void nop(int, int, int)
   6:   return              // návrat do volající metody
</pre>

<pre>
static void method3();
  Code:
   Stack=3, Locals=0, Args_size=0
   0:   bipush  6           // konstanta o rozsahu (signed) byte ulo¾ená ihned za operaèním kódem
   2:   bipush  7           // konstanta o rozsahu (signed) byte ulo¾ená ihned za operaèním kódem
   4:   bipush  8           // konstanta o rozsahu (signed) byte ulo¾ená ihned za operaèním kódem
   6:   invokestatic    #2; // volání metody void nop(int, int, int)
   9:   return              // návrat do volající metody
</pre>

<pre>
static void method4();
  Code:
   Stack=3, Locals=0, Args_size=0
   0:   bipush  32          // konstanta o rozsahu (signed) byte ulo¾ená ihned za operaèním kódem
   2:   bipush  127         // konstanta o rozsahu (signed) byte ulo¾ená ihned za operaèním kódem
   4:   bipush  -128        // konstanta o rozsahu (signed) byte ulo¾ená ihned za operaèním kódem
   6:   invokestatic    #2; // volání metody void nop(int, int, int)
   9:   return              // návrat do volající metody
</pre>

<pre>
static void method5();
  Code:
   Stack=3, Locals=0, Args_size=0
   0:   sipush  128         // konstanta o rozsahu (signed) short ulo¾ená ihned za operaèním kódem
   3:   sipush  32767       // konstanta o rozsahu (signed) short ulo¾ená ihned za operaèním kódem
   6:   sipush  -32768      // konstanta o rozsahu (signed) short ulo¾ená ihned za operaèním kódem
   9:   invokestatic    #2; // volání metody void nop(int, int, int)
   12:  return              // návrat do volající metody
</pre>

<pre>
static void method6();
  Code:
   Stack=3, Locals=0, Args_size=0
   0:   ldc #3;             // celoèíselná konstanta typu int 305419896 naètená z constant poolu
   2:   ldc #4;             // celoèíselná konstanta typu int 11189196 naètená z constant poolu
   4:   ldc #5;             // celoèíselná konstanta typu int 789789 naètená z constant poolu
   6:   invokestatic    #2; // volání metody void nop(int, int, int)
   9:   return              // návrat do volající metody
</pre>

<pre>
static void method7();
  Code:
   Stack=2, Locals=0, Args_size=0
   0:   fconst_0            // konstanta 0.0f je pøímo souèástí operaèního kódu instrukce
   1:   fconst_1            // konstanta 1.0f je pøímo souèástí operaèního kódu instrukce
   2:   invokestatic    #6; // volání metody void nop(float, float)
   5:   return              // návrat do volající metody
</pre>

<pre>
static void method8();
  Code:
   Stack=2, Locals=0, Args_size=0
   0:   fconst_2            // konstanta 2.0f je pøímo souèástí operaèního kódu instrukce
   1:   ldc #7;             // konstanta typu float 3.0f naètená z constant poolu
   3:   invokestatic    #6; // volání metody void nop(float, float)
   6:   return              // návrat do volající metody
</pre>

<pre>
static void method9();
  Code:
   Stack=4, Locals=0, Args_size=0
   0:   dconst_0            // konstanta 0.0 je pøímo souèástí operaèního kódu instrukce
   1:   dconst_1            // konstanta 1.0 je pøímo souèástí operaèního kódu instrukce
   2:   invokestatic    #8; // volání metody void nop(double, double)
   5:   return
</pre>

<pre>
static void method10();
  Code:
   Stack=4, Locals=0, Args_size=0
   0:   ldc2_w  #9;         // konstanta typu double 2.0d naètená z constant poolu
   3:   ldc2_w  #11;        // konstanta typu double 3.0d naètená z constant poolu
   6:   invokestatic    #8; // volání metody void nop(double, double)
   9:   return
</pre>

<pre>
static void method11();
  Code:
   Stack=1, Locals=0, Args_size=0
   0:   aconst_null         // konstanta null je souèástí operaèního kódu instrukce
   1:   invokestatic   #13; // volání metody void nop(Object)
   4:   return
</pre>

<pre>
static void method12();
  Code:
   Stack=1, Locals=0, Args_size=0
   0:   ldc #14;            // String "pokus" je ulo¾en v constant poolu
   2:   invokestatic   #13; // volání metody void nop(Object)
   5:   return
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Instrukce slou¾ící pro pøesuny dat mezi lokálními promìnnými a zásobníkem operandù</h2>

<p>Dal¹í pomìrnì velkou skupinu instrukcí tvoøí instrukce slou¾ící pro pøesuny
dat mezi lokálními promìnnými a pøípadnými parametry metody na jedné stranì a
<i>zásobníkem operandù</i> na stranì druhé. Je pravdìpodobnì zøejmé, ¾e zpùsob
adresace dat bude odli¹ný na stranì lokálních promìnných i na stranì zásobníku
operandù. V&nbsp;pøípadì lokálních promìnných+parametrù je toti¾ ka¾dý prvek
urèen svým indexem, který je nedílnou souèástí instrukce (jak jsme si ji¾ øekli
minule a ostatnì i <a href="#k01">v&nbsp;první kapitole</a>, lze na tuto oblast
zásobníkového rámce pohlí¾et jako na pole, jeho¾ prvky lze snadno indexovat). U
zásobníku operandù se v¾dy pracuje s&nbsp;prvkem umístìným na vrcholu zásobníku
(<i>TOS=Top Of Stack</i>); ostatní prvky umístìné pod <i>TOS</i> jsou
nedostupné.</p>

<p>V¹echny instrukce tohoto typu se jmenují <strong>*load#</strong> popø.
<strong>*store#</strong>, pøièem¾ za hvìzdièku se doplòuje první písmeno
datového typu a za køí¾ek se v&nbsp;nìkterých pøípadech udává index do oblasti
lokálních promìnných &ndash; to ov¹em jen v&nbsp;pøípadì tìch instrukcí,
u&nbsp;nich¾ je index souèástí instrukèního slova. V&nbsp;opaèném pøípadì je
index ulo¾en ve formì jednoho bajtu ihned za instrukèním kódem. Pokud je nutné
adresovat prvek s&nbsp;indexem vìt¹ím ne¾ 255 (typicky u zaèáteènických
programù v&nbsp;velkým mno¾stvím lokálních promìnných v&nbsp;jediné metodì
:-)), lze pøed instrukci typu <strong>load/store</strong> vlo¾it prefix
<strong>wide</strong> &ndash; poté lze pou¾ít ¹estnáctibitový index namísto
indexu osmibitového. Tuto zajímavou instrukci (èi spí¹e instrukèní prefix) si
podrobnìji popí¹eme pøí¹tì:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Data1</th><th>Typ dat</th><th>Popis</th></tr>
<tr><td>01</td><td>iload</td><td>15</td><td>index</td><td>int</td><td>naètení lokální promìnné typu int z pozice "index" a její ulo¾ení na TOS</td></tr>
<tr><td>02</td><td>lload</td><td>16</td><td>index</td><td>long</td><td>naètení lokální promìnné typu long z pozice "index" a její ulo¾ení na TOS</td></tr>
<tr><td>03</td><td>fload</td><td>17</td><td>index</td><td>float</td><td>naètení lokální promìnné typu float z pozice "index" a její ulo¾ení na TOS</td></tr>
<tr><td>04</td><td>dload</td><td>18</td><td>index</td><td>double</td><td>naètení lokální promìnné typu double z pozice "index" a její ulo¾ení na TOS</td></tr>
<tr><td>05</td><td>aload</td><td>19</td><td>index</td><td>reference</td><td>naètení lokální promìnné typu reference na objekt z pozice "index" a její ulo¾ení na TOS</td></tr>
<tr><td>06</td><td>iload_0</td><td>1A</td><td>&nbsp;</td><td>int</td><td>naètení lokální promìnné typu int z pozice èíslo 0 a její ulo¾ení na TOS</td></tr>
<tr><td>07</td><td>iload_1</td><td>1B</td><td>&nbsp;</td><td>int</td><td>naètení lokální promìnné typu int z pozice èíslo 1 a její ulo¾ení na TOS</td></tr>
<tr><td>08</td><td>iload_2</td><td>1C</td><td>&nbsp;</td><td>int</td><td>naètení lokální promìnné typu int z pozice èíslo 2 a její ulo¾ení na TOS</td></tr>
<tr><td>09</td><td>iload_3</td><td>1D</td><td>&nbsp;</td><td>int</td><td>naètení lokální promìnné typu int z pozice èíslo 3 a její ulo¾ení na TOS</td></tr>
<tr><td>10</td><td>lload_0</td><td>1E</td><td>&nbsp;</td><td>long</td><td>naètení lokální promìnné typu long z pozice èíslo 0 a její ulo¾ení na TOS</td></tr>
<tr><td>11</td><td>lload_1</td><td>1F</td><td>&nbsp;</td><td>long</td><td>naètení lokální promìnné typu long z pozice èíslo 1 a její ulo¾ení na TOS</td></tr>
<tr><td>12</td><td>lload_2</td><td>20</td><td>&nbsp;</td><td>long</td><td>naètení lokální promìnné typu long z pozice èíslo 2 a její ulo¾ení na TOS</td></tr>
<tr><td>13</td><td>lload_3</td><td>21</td><td>&nbsp;</td><td>long</td><td>naètení lokální promìnné typu long z pozice èíslo 3 a její ulo¾ení na TOS</td></tr>
<tr><td>14</td><td>fload_0</td><td>22</td><td>&nbsp;</td><td>float</td><td>naètení lokální promìnné typu float z pozice èíslo 0 a její ulo¾ení na TOS</td></tr>
<tr><td>15</td><td>fload_1</td><td>23</td><td>&nbsp;</td><td>float</td><td>naètení lokální promìnné typu float z pozice èíslo 1 a její ulo¾ení na TOS</td></tr>
<tr><td>16</td><td>fload_2</td><td>24</td><td>&nbsp;</td><td>float</td><td>naètení lokální promìnné typu float z pozice èíslo 2 a její ulo¾ení na TOS</td></tr>
<tr><td>17</td><td>fload_3</td><td>25</td><td>&nbsp;</td><td>float</td><td>naètení lokální promìnné typu float z pozice èíslo 3 a její ulo¾ení na TOS</td></tr>
<tr><td>18</td><td>dload_0</td><td>26</td><td>&nbsp;</td><td>double</td><td>naètení lokální promìnné typu double z pozice èíslo 0 a její ulo¾ení na TOS</td></tr>
<tr><td>19</td><td>dload_1</td><td>27</td><td>&nbsp;</td><td>double</td><td>naètení lokální promìnné typu double z pozice èíslo 1 a její ulo¾ení na TOS</td></tr>
<tr><td>20</td><td>dload_2</td><td>28</td><td>&nbsp;</td><td>double</td><td>naètení lokální promìnné typu double z pozice èíslo 2 a její ulo¾ení na TOS</td></tr>
<tr><td>21</td><td>dload_3</td><td>29</td><td>&nbsp;</td><td>double</td><td>naètení lokální promìnné typu double z pozice èíslo 3 a její ulo¾ení na TOS</td></tr>
<tr><td>22</td><td>aload_0</td><td>2A</td><td>&nbsp;</td><td>reference</td><td>naètení lokální promìnné typu reference na objekt z pozice èíslo 0 a její ulo¾ení na TOS</td></tr>
<tr><td>23</td><td>aload_1</td><td>2B</td><td>&nbsp;</td><td>reference</td><td>naètení lokální promìnné typu reference na objekt z pozice èíslo 1 a její ulo¾ení na TOS</td></tr>
<tr><td>24</td><td>aload_2</td><td>2C</td><td>&nbsp;</td><td>reference</td><td>naètení lokální promìnné typu reference na objekt z pozice èíslo 2 a její ulo¾ení na TOS</td></tr>
<tr><td>25</td><td>aload_3</td><td>2D</td><td>&nbsp;</td><td>reference</td><td>naètení lokální promìnné typu reference na objekt z pozice èíslo 3 a její ulo¾ení na TOS</td></tr>
<tr><td>26</td><td>istore</td><td>36</td><td>index</td><td>int</td><td>pøesun hodnoty z TOS do lokální promìnné umístìné na pozici "index" (kontrola na typ int)</td></tr>
<tr><td>27</td><td>lstore</td><td>37</td><td>index</td><td>long</td><td>pøesun hodnoty z TOS do lokální promìnné umístìné na pozici "index" (kontrola na typ long)</td></tr>
<tr><td>28</td><td>fstore</td><td>38</td><td>index</td><td>float</td><td>pøesun hodnoty z TOS do lokální promìnné umístìné na pozici "index" (kontrola na typ float)</td></tr>
<tr><td>29</td><td>dstore</td><td>39</td><td>index</td><td>double</td><td>pøesun hodnoty z TOS do lokální promìnné umístìné na pozici "index" (kontrola na typ double)</td></tr>
<tr><td>30</td><td>astore</td><td>3A</td><td>index</td><td>reference</td><td>pøesun hodnoty z TOS do lokální promìnné umístìné na pozici "index" (kontrola, zda jde o objekt)</td></tr>
<tr><td>31</td><td>istore_0</td><td>3B</td><td>&nbsp;</td><td>int</td><td>pøesun hodnoty z TOS do lokální promìnné umístìné na pozici èíslo 0 (kontrola na typ int)</td></tr>
<tr><td>32</td><td>istore_1</td><td>3C</td><td>&nbsp;</td><td>int</td><td>pøesun hodnoty z TOS do lokální promìnné umístìné na pozici èíslo 1 (kontrola na typ int)</td></tr>
<tr><td>33</td><td>istore_2</td><td>3D</td><td>&nbsp;</td><td>int</td><td>pøesun hodnoty z TOS do lokální promìnné umístìné na pozici èíslo 2 (kontrola na typ int)</td></tr>
<tr><td>34</td><td>istore_3</td><td>3E</td><td>&nbsp;</td><td>int</td><td>pøesun hodnoty z TOS do lokální promìnné umístìné na pozici èíslo 3 (kontrola na typ int)</td></tr>
<tr><td>35</td><td>lstore_0</td><td>3F</td><td>&nbsp;</td><td>long</td><td>pøesun hodnoty z TOS do lokální promìnné umístìné na pozici èíslo 0 (kontrola na typ long)</td></tr>
<tr><td>36</td><td>lstore_1</td><td>40</td><td>&nbsp;</td><td>long</td><td>pøesun hodnoty z TOS do lokální promìnné umístìné na pozici èíslo 1 (kontrola na typ long)</td></tr>
<tr><td>37</td><td>lstore_2</td><td>41</td><td>&nbsp;</td><td>long</td><td>pøesun hodnoty z TOS do lokální promìnné umístìné na pozici èíslo 2 (kontrola na typ long)</td></tr>
<tr><td>38</td><td>lstore_3</td><td>42</td><td>&nbsp;</td><td>long</td><td>pøesun hodnoty z TOS do lokální promìnné umístìné na pozici èíslo 3 (kontrola na typ long)</td></tr>
<tr><td>39</td><td>fstore_0</td><td>43</td><td>&nbsp;</td><td>float</td><td>pøesun hodnoty z TOS do lokální promìnné umístìné na pozici èíslo 0 (kontrola na typ float)</td></tr>
<tr><td>40</td><td>fstore_1</td><td>44</td><td>&nbsp;</td><td>float</td><td>pøesun hodnoty z TOS do lokální promìnné umístìné na pozici èíslo 1 (kontrola na typ float)</td></tr>
<tr><td>41</td><td>fstore_2</td><td>45</td><td>&nbsp;</td><td>float</td><td>pøesun hodnoty z TOS do lokální promìnné umístìné na pozici èíslo 2 (kontrola na typ float)</td></tr>
<tr><td>42</td><td>fstore_3</td><td>46</td><td>&nbsp;</td><td>float</td><td>pøesun hodnoty z TOS do lokální promìnné umístìné na pozici èíslo 3 (kontrola na typ float)</td></tr>
<tr><td>43</td><td>dstore_0</td><td>47</td><td>&nbsp;</td><td>double</td><td>pøesun hodnoty z TOS do lokální promìnné umístìné na pozici èíslo 0 (kontrola na typ double)</td></tr>
<tr><td>44</td><td>dstore_1</td><td>48</td><td>&nbsp;</td><td>double</td><td>pøesun hodnoty z TOS do lokální promìnné umístìné na pozici èíslo 1 (kontrola na typ double)</td></tr>
<tr><td>45</td><td>dstore_2</td><td>49</td><td>&nbsp;</td><td>double</td><td>pøesun hodnoty z TOS do lokální promìnné umístìné na pozici èíslo 2 (kontrola na typ double)</td></tr>
<tr><td>46</td><td>dstore_3</td><td>4A</td><td>&nbsp;</td><td>double</td><td>pøesun hodnoty z TOS do lokální promìnné umístìné na pozici èíslo 3 (kontrola na typ double)</td></tr>
<tr><td>47</td><td>astore_0</td><td>4B</td><td>&nbsp;</td><td>reference</td><td>pøesun hodnoty z TOS do lokální promìnné umístìné na pozici èíslo 0 (kontrola na typ reference na objekt)</td></tr>
<tr><td>48</td><td>astore_1</td><td>4C</td><td>&nbsp;</td><td>reference</td><td>pøesun hodnoty z TOS do lokální promìnné umístìné na pozici èíslo 1 (kontrola na typ reference na objekt)</td></tr>
<tr><td>49</td><td>astore_2</td><td>4D</td><td>&nbsp;</td><td>reference</td><td>pøesun hodnoty z TOS do lokální promìnné umístìné na pozici èíslo 2 (kontrola na typ reference na objekt)</td></tr>
<tr><td>50</td><td>astore_3</td><td>4E</td><td>&nbsp;</td><td>reference</td><td>pøesun hodnoty z TOS do lokální promìnné umístìné na pozici èíslo 3 (kontrola na typ reference na objekt)</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. Demonstraèní pøíklad: pøesun dat mezi parametry metody a zásobníkem</h2>

<p>Podobnì jako u pøedchozí skupiny instrukcí, i u instrukcí typu
<strong>load</strong> a <strong>store</strong> je mo¾né vidìt snahu tvùrcù
specifikace JVM o optimalizaci bajtkódu na jeho celkovou velikost &ndash; týká
se to pøedev¹ím pøístupu k&nbsp;prvním parametrùm metody a/nebo lokálním
promìnným s&nbsp;vyu¾itím konstantního indexu ulo¾eného pøímo v&nbsp;operaèním
kódu instrukce. I z&nbsp;tohoto dùvodu je vhodné u v¹ech metod nepracujících
s&nbsp;atributy objektu pou¾ívat modifikátor <strong>static</strong>, èím¾ se
u¹etøí jedna pozice v&nbsp;oblasti lokálních promìnných, která by jinak byla
rezervována pro pøedání hodnoty <strong>this</strong>. Podívejme se v¹ak opìt
na demonstraèní pøíklad, který nám uká¾e, jakým zpùsobem pøekladaè generuje
instrukce typu <strong>load</strong> a <strong>store</strong> v&nbsp;reálném
bajtkódu. Zdrojový kód demonstraèního pøíkladu je opìt pomìrnì jednoduchý
&ndash; jedná se o tøídu obsahující metody, které pracují pouze se svými
parametry (to abychom se vyhnuli práci s&nbsp;konstantami, proto¾e to ji¾ známe
z&nbsp;pøedchozích kapitol). Aby byl vidìt rozdíl mezi pøístupem k&nbsp;prvním
ètyøem parametrùm a zbylými parametry, má ka¾dá metoda navíc i dvojici
&bdquo;výplòových&ldquo; parametrù:</p>

<pre>
class Test2 {
&nbsp;
    static void method1(int a, int b, boolean vypln1, boolean vypln2, int c) {
        a = b;
        b = c;
        c = a;
    }
&nbsp;
    static void method2(long a, long b, boolean vypln1, boolean vypln2, long c) {
        a = b;
        b = c;
        c = a;
    }
&nbsp;
    static void method3(float a, float b, boolean vypln1, boolean vypln2, float c) {
        a = b;
        b = c;
        c = a;
    }
&nbsp;
    static void method4(double a, double b, boolean vypln1, boolean vypln2, double c) {
        a = b;
        b = c;
        c = a;
    }
&nbsp;
    static void method5(String a, String b, boolean vypln1, boolean vypln2, String c) {
        a = b;
        b = c;
        c = a;
    }
&nbsp;
}
</pre>

<p>Disassemlovaný bajtkód v¹ech pìti testovacích metod s&nbsp;ruènì dopsanými
komentáøi vypadá následovnì:</p>

<pre>
static void method1(int, int, boolean, boolean, int);
  Code:
   Stack=1, Locals=5, Args_size=5
   0:	iload_1           // index je souèástí operaèního kódu instrukce
   1:	istore_0          // index je souèástí operaèního kódu instrukce
   2:	iload	4         // index je uveden v bajtu za operaèním kódem
   4:	istore_1          // index je souèástí operaèního kódu instrukce
   5:	iload_0           // index je souèástí operaèního kódu instrukce
   6:	istore	4         // index je uveden v bajtu za operaèním kódem
   8:	return            // návrat do volající metody
</pre>

<pre>
static void method2(long, long, boolean, boolean, long);
  Code:
   Stack=2, Locals=8, Args_size=5
   0:	lload_2           // index je souèástí operaèního kódu instrukce
   1:	lstore_0          // index je souèástí operaèního kódu instrukce
   2:	lload	6         // index je uveden v bajtu za operaèním kódem
   4:	lstore_2          // index je souèástí operaèního kódu instrukce
   5:	lload_0           // index je souèástí operaèního kódu instrukce
   6:	lstore	6         // index je uveden v bajtu za operaèním kódem
   8:	return            // návrat do volající metody
</pre>

<pre>
static void method3(float, float, boolean, boolean, float);
  Code:
   Stack=1, Locals=5, Args_size=5
   0:	fload_1           // index je souèástí operaèního kódu instrukce
   1:	fstore_0          // index je souèástí operaèního kódu instrukce
   2:	fload	4         // index je uveden v bajtu za operaèním kódem
   4:	fstore_1          // index je souèástí operaèního kódu instrukce
   5:	fload_0           // index je souèástí operaèního kódu instrukce
   6:	fstore	4         // index je uveden v bajtu za operaèním kódem
   8:	return            // návrat do volající metody
</pre>

<pre>
static void method4(double, double, boolean, boolean, double);
  Code:
   Stack=2, Locals=8, Args_size=5
   0:	dload_2           // index je souèástí operaèního kódu instrukce
   1:	dstore_0          // index je souèástí operaèního kódu instrukce
   2:	dload	6         // index je uveden v bajtu za operaèním kódem
   4:	dstore_2          // index je souèástí operaèního kódu instrukce
   5:	dload_0           // index je souèástí operaèního kódu instrukce
   6:	dstore	6         // index je uveden v bajtu za operaèním kódem
   8:	return            // návrat do volající metody
</pre>

<pre>
static void method5(java.lang.String, java.lang.String, boolean, boolean, java.lang.String);
  Code:
   Stack=1, Locals=5, Args_size=5
   0:	aload_1           // index je souèástí operaèního kódu instrukce
   1:	astore_0          // index je souèástí operaèního kódu instrukce
   2:	aload	4         // index je uveden v bajtu za operaèním kódem
   4:	astore_1          // index je souèástí operaèního kódu instrukce
   5:	aload_0           // index je souèástí operaèního kódu instrukce
   6:	astore	4         // index je uveden v bajtu za operaèním kódem
   8:	return            // návrat do volající metody
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Instrukce pro pøímou manipulaci s&nbsp;prvky ulo¾enými na zásobníku operandù</h2>

<p>Mohlo by se zdát, ¾e pokud zásobník operandù slou¾í pouze k&nbsp;pøípravì
parametrù pro volanou metodu, popø.&nbsp;k&nbsp;jednoduchým výpoètùm, nejsou
potøeba ¾ádné dal¹í instrukce, které by slou¾ily pro manipulaci s&nbsp;daty
ulo¾enými na zásobníku operandù. Ve skuteènosti to v¹ak není zcela pravda,
proto¾e se velmi èasto stane, ¾e je zapotøebí odstranit nìjaký prvek ze
zásobníku a nikam ho pøitom neukládat, popø.&nbsp;zduplikovat prvek, který se
na zásobníku nachází. Pro tyto pøípady obsahuje instrukèní sada virtuálního
stroje Javy nìkolik instrukcí, které se nápadnì podobají <i>slovùm</i>
pou¾ívaným v&nbsp;programovacím jazyku <i>Forth</i> (ono se ostatnì není èemu
divit, proto¾e se jedná skuteènì o základní instrukce). Dùle¾ité je, ¾e tyto
instrukce ji¾ nepotøebují být rozdìleny podle toho s&nbsp;jakými daty pracují,
proto¾e ka¾dému prvku ulo¾eném na <i>zásobníku operandù</i> je stejnì pøiøazen
datový <i>tag</i>, který je tìmito instrukcemi vyu¾íván. Zajímavé je, ¾e
podobný princip nebyl pou¾it napøíklad u aritmetických instrukcí (bavil jsem se
o tom s&nbsp;jedním vývojáøem VM, kterému se to také pøíli¹ nelíbilo, ale u¾ si
nepamatoval, kdo vlastnì s&nbsp;návrhem instrukèní sady pøed více ne¾ patnácti
lety u spoleènosti Sun pøi¹el):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Popis</th></tr>
<tr><td>1</td><td>pop</td><td>57</td><td>odstraní jednu polo¾ku z <i>TOS</i> (platí pro int, float, referenci na objekt)</td></tr>
<tr><td>2</td><td>pop2</td><td>58</td><td>odstraní jednu (long, double) polo¾ku èi dvì (int, float, reference) polo¾ky ze zásobníku</td></tr>
<tr><td>3</td><td>dup</td><td>59</td><td>zduplikuje (zkopíruje) polo¾ku z <i>TOS</i> (platí pro int, float, referenci na objekt)</td></tr>
<tr><td>4</td><td>dup_x1</td><td>5A</td><td>zduplikuje (zkopíruje) polo¾ku z <i>TOS</i>, ale vlo¾í i o dvì pozice ní¾ do zásobníku</td></tr>
<tr><td>5</td><td>dup_x2</td><td>5B</td><td>zduplikuje (zkopíruje) polo¾ku z <i>TOS</i> a vlo¾í i o dvì èi tøi pozice ní¾ (v závislosti na bitové ¹íøce)</td></tr>
<tr><td>6</td><td>dup2</td><td>5C</td><td>duplikace jedné (long, double) èi dvou (int, float, reference) polo¾ek</td></tr>
<tr><td>7</td><td>dup2_x1</td><td>5D</td><td>kombinace vlastností instrukcí dup2 a dup_x1 (vlo¾ení prvku o dvì místa ní¾e)</td></tr>
<tr><td>8</td><td>dup2_x2</td><td>5E</td><td>kombinace vlastností instrukcí dup2 a dup_x2</td></tr>
<tr><td>9</td><td>swap</td><td>5F</td><td>prohodí dva prvky le¾ící na vrcholu zásobníku (platí pro int, float, referenci na objekt)</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Instrukce pro konverzi mezi rùznými datovými typy</h2>

<p>Ètvrtou skupinou instrukcí virtuálního stroje jazyka Java, s&nbsp;ní¾ se
dnes seznámíme, jsou instrukce slou¾ící pro konverzi dat. Programovací jazyk
Java sice patøí mezi jazyky silnì typované, ale konverze mezi nìkterými
datovými typy jsou provádìny automaticky (byte-&rarr;int) a jiné lze explicitnì
zapsat. Navíc se konverzní instrukce objevují v&nbsp;bajtkódu napøíklad pøi
vytváøení návratové hodnoty metody v&nbsp;pøípadì, ¾e tato hodnota nemá typ
<strong>int</strong>, <strong>long</strong>, <strong>float</strong> èi
<strong>double</strong>. Ov¹em ne v¹echny kombinace konverzí datových typù jsou
v&nbsp;instrukèní sadì pøítomny, tak¾e nìkteré konverze je ve skuteènosti nutné
provádìt pomocí dvojice instrukcí (napøíklad se mù¾e jednat o konverzi
z&nbsp;<strong>float</strong> na <strong>short</strong> a podobnì). Podívejme
se ostatnì na tabulku obsahující v¹echny konverzní instrukce. V&nbsp;prvním
sloupci je uveden datový typ, z&nbsp;nìho¾ je konverze provádìna a
v&nbsp;prvním øádku naopak výsledný datový typ:</p>

<table>
<tr><th>z/na-&gt;</th><th>char</th><th>byte</th><th>short</th><th>int</th><th>long</th><th>float</th><th>double</th></tr>
<tr><td>char  </td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>byte  </td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>short </td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>int</td><td>i2c</td><td>i2b</td><td>i2s</td><td>&nbsp;</td><td>i2l</td><td>i2f</td><td>i2d</td></tr>
<tr><td>long  </td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>l2i</td><td>&nbsp;</td><td>l2f</td><td>l2d</td></tr>
<tr><td>float </td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>f2i</td><td>f2l</td><td>&nbsp;</td><td>f2d</td></tr>
<tr><td>double</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>d2i</td><td>d2l</td><td>d2f</td><td>&nbsp;</td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Demonstraèní pøíklad: konverze mezi rùznými datovými typy</h2>

<p>Opìt se podívejme na jednoduchý demonstraèní pøíklad, v&nbsp;nìm¾ budou
pou¾ity nìkteré vý¹e uvedené konverzní funkce. Pøíklad se skládá
z&nbsp;nìkolika metod &ndash; první ètyøi metody provádí konverzi svého
parametru na výstupní hodnotu a pátá metoda obsahuje nìkolik lokálních
promìnných inicializovaných promìnnými jiného typu. V&nbsp;nìkterých pøípadech
je mo¾né vyu¾ít implicitní konverze, ov¹em v&nbsp;mnoha dal¹ích pøípadech se
nevyhneme explicitnímu pøetypování:</p>

<pre>
class Test3 {
&nbsp;
    static byte toByte(int i) {
        return (byte)i;
    }
&nbsp;
    static short toShort(int i) {
        return (short)i;
    }
&nbsp;
    static short toShort(float f) {
        return (short)f;
    }
&nbsp;
    static short toShort(double d) {
        return (short)d;
    }
&nbsp;
    static void vypocet(int x, int y) {
        long   a = x;
        float  f = y;
        float  g = a;
        int    i = (int)f;
        double d = i;
        byte   b = (byte)d;
    }
&nbsp;
}
</pre>

<p>Disassemlovaný bajtkód vypadá následovnì:</p>

<pre>
static byte toByte(int);
  Code:
   Stack=1, Locals=1, Args_size=1
   0:	iload_0           // naètení prvního parametru metody
   1:	i2b               // pøevod na byte
   2:	ireturn           // návrat do volající metody s návratovou hodnotou na zásobníku
</pre>

<pre>
static short toShort(int);
  Code:
   Stack=1, Locals=1, Args_size=1
   0:	iload_0           // naètení prvního parametru metody
   1:	i2s               // pøevod na short
   2:	ireturn           // návrat do volající metody s návratovou hodnotou na zásobníku
</pre>

<pre>
static short toShort(float);
  Code:
   Stack=1, Locals=1, Args_size=1
   0:	fload_0           // naètení prvního parametru metody
   1:	f2i               // postupný pøevod z float
   2:	i2s               // ... na short pøes typ int
   3:	ireturn           // návrat do volající metody s návratovou hodnotou na zásobníku
</pre>

<pre>
static short toShort(double);
  Code:
   Stack=2, Locals=2, Args_size=1
   0:	dload_0           // naètení prvního parametru metody
   1:	d2i               // postupný pøevod z double
   2:	i2s               // ... na short pøes typ int
   3:	ireturn           // návrat do volající metody s návratovou hodnotou na zásobníku
</pre>

<pre>
static void vypocet(int, int);
  Code:
   Stack=2, Locals=10, Args_size=2
   0:	iload_0           //
   1:	i2l               // long a = x;
   2:	lstore_2          //
&nbsp;
   3:	iload_1           //
   4:	i2f               // float f = y
   5:	fstore	4         //
&nbsp;
   7:	lload_2           //
   8:	l2f               // float g = a
   9:	fstore	5         //
&nbsp;
   11:	fload	4         //
   13:	f2i               // int i = (int)f;
   14:	istore	6         //
&nbsp;
   16:	iload	6         //
   18:	i2d               // double d = i;
   19:	dstore	7         //
&nbsp;
   21:	dload	7         //
   23:	d2i               // byte b = (byte)d;
   24:	i2b               // zde jde o postupný pøevod pøes int
   25:	istore	9         //
&nbsp;
   27:	return            // návrat do volající metody
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Java quick guide: JVM Instruction Set<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Root.cz: Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM<br />
<a href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/</a></a>
</li>

<li>Root.cz: JamVM aneb alternativa k HotSpotu nejenom pro embedded zaøízení a chytré telefony<br />
<a href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>FindBugs<br />
<a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a>
</li>

<li>GNU Classpath<br />
<a href="www.gnu.org/s/classpath/">www.gnu.org/s/classpath/</a></li>

<li>Java VMs Compared<br />
<a href="http://bugblogger.com/java-vms-compared-160/">http://bugblogger.com/java-vms-compared-160/</a>
</li>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a></li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>CloseableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html">http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

