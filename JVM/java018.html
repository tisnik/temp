<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM (1.èást - prohlí¾ení a modifikace bajtkódu)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM (1.èást - prohlí¾ení a modifikace bajtkódu)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V osmnácté èásti ponìkud nepravidelnì vycházejícího seriálu o programovacím jazyce Java i o vlastnostech JVM se budeme zabývat problematikou prohlí¾ení a modifikace bajtkódu, do nìho¾ jsou pøekládány zdrojové texty psané (nejenom) v Javì. Modifikace bajtkódu je èasto pou¾ívána nástroji typu Cobertura, EMMA èi AspectJ.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM (1.èást - prohlí¾ení a modifikace bajtkódu)</a></p>
<p><a href="#k02">2. Nástroj <strong>javap</strong> &ndash; základ pro hrátky s&nbsp;bajtkódem</a></p>
<p><a href="#k03">3. Nástroj <strong>BCEL</strong> (Byte Code Engineering Library)</a></p>
<p><a href="#k04">4. Nástroj <strong>ASM</strong> aneb alternativa k&nbsp;<strong>BCEL</strong></a></p>
<p><a href="#k05">5. Soubory .class</a></p>
<p><a href="#k06">6. Struktura souborù .class</a></p>
<p><a href="#k07">7. Hlavièka souborù .class</a></p>
<p><a href="#k08">8. Constant pool &ndash; nedílná souèást souborù .class</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM (1.èást - prohlí¾ení a modifikace bajtkódu)</h2>

<p>V&nbsp;pøedchozích sedmnácti èástech seriálu o programovacím jazyce Java i o
vlastnostech virtuálního stroje Javy jsme se ji¾ nìkolikrát zmínili o bajtkódu,
tj.&nbsp;(ponìkud zjednodu¹enì øeèeno) o souborech s&nbsp;koncovkou
<strong>.class</strong>. Tyto soubory vìt¹inou vznikají pøekladem zdrojových
textù napsaných v&nbsp;Javì, ov¹em není to pravidlem, proto¾e bajtkód mù¾e být
generován i pøekladaèi jiných programovacích jazykù, popø.&nbsp;se mù¾e jednat
o bajtkód pøelo¾ený assemblerem typu <i>Jasmin</i> èi nìkterým generátorem
kódu. My se v&nbsp;dal¹ím textu zamìøíme pøedev¹ím na popis struktury bajtkódu
a na to, jak lze tuto strukturu zobrazit. Teprve poté si uká¾eme nìkteré
mo¾nosti, které nám nabízí modifikace bajtkódu. Prohlí¾ení èi dokonce
modifikace bajtkódu generovaného pøekladaèem <strong>javac</strong>
(popø.&nbsp;dal¹í nízkoúrovòové operace) sice nepatøí mezi ka¾dodenní èinnosti
programátorù pou¾ívajících Javu, ov¹em v&nbsp;nìkterých situacích se
s&nbsp;bajtkódem skuteènì manipuluje, a» ji¾ pøímo, èi (mnohem èastìji) nepøímo
s&nbsp;vyu¾itím rùzných specializovaných nástrojù.</p>

<p>Pøíkladem mohou být napøíklad nástroje typu <i>Cobertura</i> a <i>EMMA</i>,
které slou¾í pro zji¹tìní, které èásti zdrojového kódu aplikací jsou pokryty
(jednotkovými) testy. Tyto nástroje musí umìt dobøe kooperovat
s&nbsp;virtuálním strojem Javy, proto nejprve modifikují bajtkódy testovaných
tøíd, aby bylo mo¾né pøi bìhu testù dynamicky zjistit, které øádky kódu jsou
skuteènì z&nbsp;testù volány. Podobným zpùsobem je bajtkód modifikován nástroji
podporujícími aspektovì orientované programování (<i>aspect oriented
programming</i>), které takté¾ mohou zasahovat do bajtkódu vygenerovaného
pøekladaèem. Teoreticky je sice mo¾né pøi pou¾ití aspektovì orientovaného
programování transformovat pøímo zdrojové kódy programù (co¾ je pou¾ito
pøedev¹ím v&nbsp;jiných programovacích jazycích), ale transformace bajtkódu je
v&nbsp;pøípadì Javy mnohem snaz¹í. Ze stejného dùvodu (analýza bajtkódu je
jednodu¹¹í ne¾ analýza zdrojového textu) je bajtkód pou¾it pro statickou
analýzu a hledání potenciálních chyb nástrojem <i>FindBugs</i>.</p>

<p>U¾iteèné odkazy:</p>

<ol>

<li>aspectj (podpora AOP pro Eclipse IDE)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>FindBugs (home page)<br />
<a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a>
</li>

<li>FindBugs (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/FindBugs">http://en.wikipedia.org/wiki/FindBugs</a>
</li>

</ol>



<p><a name="k02"></a></p>
<h2 id="k02">2. Nástroj <strong>javap</strong> &ndash; základ pro hrátky s&nbsp;bajtkódem</h2>

<p>Jeden z&nbsp;nejjednodu¹¹ích nástrojù urèených pro prohlí¾ení obsahu
bajtkódu je souèástí ka¾dé instalace <i>JDK (Java Development Kit)</i>. Tento
nástroj, jen¾ je sice na první pohled velmi jednoduchý, ov¹em na druhou stranu
v&nbsp;mnoha pøípadech u¾iteèný, se jmenuje <strong>javap</strong> a slou¾í pro
výpis základní struktury pøelo¾ených tøíd, popø.&nbsp;takté¾ k&nbsp;zobrazení
sekvence instrukcí tvoøících tìla metod (jedná se tedy o jednoduchý
disassembler). S&nbsp;vyu¾itím tohoto nástroje je takté¾ mo¾né zobrazit hodnoty
konstant ulo¾ených v&nbsp;bajtkódu v&nbsp;takzvaném <i>constant poolu</i>. <a
href="#k08">V&nbsp;osmé kapitole</a> si strukturu constant poolu vysvìtlíme
podrobnìji. Pøi spu¹tìní nástroje <strong>javap</strong> je nutné na pøíkazové
øádce zadat minimálnì jméno tøídy (nikoli pøímo jméno souboru
s&nbsp;bajtkódem!), popø.&nbsp;lze vyu¾ít i nìkolik voleb, které urèují, jaké
informace se získají a následnì zobrazí:</p>

<table>
<tr><th>#</th><th>Volba (pøepínaè)</th><th>Význam volby</th></tr>
<tr><td>1</td><td>-public</td><td>ve výpise budou uvedeny jen veøejné tøídy, metody a atributy</td></tr>
<tr><td>2</td><td>-protected</td><td>ve výpise budou uvedeny i tøídy, metody a atributy s&nbsp;pøíznakem &bdquo;protected&ldquo;</td></tr>
<tr><td>3</td><td>-package</td><td>podobné pøedchozímu pøepínaèi, ale navíc se vypí¹ou i tøídy, metody a atributy s&nbsp;pøíznakem &bdquo;package-protected&ldquo;</td></tr>
<tr><td>4</td><td>-private</td><td>vypí¹ou se tøídy, metody a atributy se v¹emi pøíznaky (takto lze získat informaci o celé struktuøe tøídy)</td></tr>
<tr><td>5</td><td>-c</td><td>provede se navíc zpìtný pøeklad tìl metod (disassembler)</td></tr>
<tr><td>6</td><td>-l</td><td>pro ka¾dou metodu vypí¹e tabulku s&nbsp;korespondujícími øádky ve zdrojovém textu (ne v¾dy jsou tyto informace dostupné, zále¾í na pou¾ití volby <strong>-g:xxx</strong> pøi pøekladu tøídy).</td></tr>
<tr><td>7</td><td>-verbose</td><td>nejpodrobnìj¹í re¾im výpisu, dojde zde i na výpis informací z&times;constant poolu</td></tr>
</table>

<p>K&nbsp;nástroji <strong>javap</strong> se je¹tì nìkolikrát vrátíme
v&nbsp;dal¹ím textu.</p>

<p>U¾iteèné odkazy:</p>

<ol>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

</ol>



<p><a name="k03"></a></p>
<h2 id="k03">3. Nástroj <strong>BCEL</strong> (Byte Code Engineering Library)</h2>

<p>I pøes svoji nespornou u¾iteènost nemusí v&nbsp;mnoha pøípadech vý¹e popsaný
nástroj <strong>javap</strong> pro v¹echny potøeby vývojáøù dostaèovat. Jedná
se pøedev¹ím o situace, v&nbsp;nich¾ je zapotøebí do bajtkódu nìjakým zpùsobem
aktivnì zasahovat. V&nbsp;tìchto pøípadech lze vyu¾ít programy <i>BCEL</i> èi
<i>ASM</i>, které umo¾òují s&nbsp;bajtkódem provádìt mnoho i pomìrnì slo¾itých
operací, vèetnì zmìny tìl metod. Historicky star¹í je program (èi spí¹e
knihovna) nazvaná <i>BCEL (Byte Code Engineering Library)</i> umo¾òující
nejprve naèíst celý bajtkód a posléze s&nbsp;tímto bajtkódem rùzným zpùsobem
manipulovat. Vzhledem k&nbsp;tomu, ¾e se bajtkód pøi naèítání pøevádí na
vnitøní reprezentaci (rùzné typy tøíd), je manipulace s&nbsp;bajtkódem pomocí
knihovny <i>BCEL</i> pomìrnì pomalá, co¾ se v¹ak vìt¹inou negativnì projeví a¾
pøi práci s&nbsp;rozsáhlými projekty. Vìt¹í problém pro vývojáøe pøedstavuje
ponìkud nepøehledné aplikaèní programové rozhraní knihovny <i>BCEL</i> a
s&nbsp;tím související hor¹í dokumentace.</p>

<p>U¾iteèné odkazy:</p>

<ol>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

</ol>



<p><a name="k04"></a></p>
<h2 id="k04">4. Nástroj <strong>ASM</strong> aneb alternativa k&nbsp;<strong>BCEL</strong></h2>

<p>Kromì knihovny <i>BCEL</i> lze v&nbsp;mnoha pøípadech vyu¾ít i knihovnu
nazvanou <i>ASM</i>, která takté¾ umo¾òuje manipulaci s&nbsp;bajtkódem (navíc
má <i>ASM</i> snad nejlep¹í 3D logo, které jsem zatím vidìl :-). Zatímco
se v&nbsp;pøípadì <i>BCEL</i> celý bajtkód nejprve naèetl do pamìti, knihovna
<i>ASM</i> ve své základní konfiguraci pracuje odli¹nì &ndash; bajtkód je
postupnì naèítán a pro ka¾dou informaci mù¾e být zaregistrován programový kód,
který tuto informaci zpracovává. Samozøejmì je té¾ mo¾né pou¾ít opaèný postup,
pøi nìm¾ je bajtkód postupnì generován. Transformace bajtkódu je tedy typicky
provedena naèítáním vstupního bajtkódu s&nbsp;postupným generováním bajtkódu
výstupního (pøi pøenosu informací ze vstupního bajtkódu do bajtkódu výstupního
se aplikuje zvolená transformace èi modifikace). Rozdíl mezi knihovnou
<i>BCEL</i> a knihovnou <i>ASM</i> (opìt pøipomínám, ¾e v&nbsp;základní
konfiguraci) se podobá rozdílu mezi zpùsobem zpracování XML souborù &ndash; buï
lze pou¾ít <i>DOM (Document Object Model)</i> (analogie k&nbsp;<i>BCEL</i>)
nebo <i>SAX (Simple API for XML)</i> (analogie k&nbsp;<i>ASM</i>). Knihovnu
<i>ASM</i> je v¹ak takté¾ mo¾né vyu¾ívat v&nbsp;&bdquo;re¾imu DOM&ldquo;,
podobnì jako <i>BCEL</i>, i kdy¾ se API obou knihoven od sebe dosti li¹í.</p>

<p>U¾iteèné odkazy:</p>

<ol>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

</ol>



<p><a name="k05"></a></p>
<h2 id="k05">5. Soubory .class</h2>

<p>Nyní se ji¾ (koneènì :-) dostáváme k&nbsp;vlastnímu popisu souborù typu
<strong>.class</strong>. Nejprve si øeknìme, z&nbsp;èeho vlastnì soubory
<strong>.class</strong> vznikají. V&nbsp;nìkterých uèebnicích Javy se sice
pí¹e, ¾e z&nbsp;ka¾dého zdrojového souboru <strong>.java</strong> vznikne
pøekladem soubor <strong>.class</strong> pojmenovaný stejnì, jako onen zdrojový
soubor (li¹í se samozøejmì koncovka). Jak v¹ak ji¾ pravdìpodobnì vývojáøi vìdí,
je situace ponìkud slo¾itìj¹í. V&nbsp;ka¾dém souboru <strong>.class</strong> se
toti¾ mù¾e nacházet pouze bajtkód <i>jediné</i> tøídy, co¾ znamená, ¾e se ve
skuteènosti pøi pøekladu jednoho zdrojového textu mù¾e vygenerovat hned nìkolik
souborù <strong>.class</strong>, jejich¾ pojmenování se øídí striktními
pravidly, které jsou dodr¾ovány jak samotným pøekladaèem, tak i JVM, který pøi
inicializaci a spou¹tìní programu musí najít a jednoznaènì spárovat jména tøíd
se jmény souborù <strong>.class</strong>. Buïme konkrétnìj¹í &ndash; samostatný
soubor <strong>.class</strong> se vygeneruje pro:</p>

<ul>

<li>ka¾dou bì¾nou tøídu ve zdrojovém textu (v&nbsp;jednom zdrojovém souboru
jich mù¾e být samozøejmì vìt¹í mno¾ství, ov¹em pouze jedna tøída mù¾e být
veøejná a musí být pojmenována stejnì, jako zdrojový soubor)</li>

<li>ka¾dou vnitøní tøídu. Název souboru <strong>.class</strong> je v&nbsp;tomto
pøípadì slo¾en ze jména obalové tøídy, znaku dolar a jména vnitøní tøídy. Toté¾
pravidlo platí i pro statické vnitøní tøídy.</li>

<li>ka¾dou lokální tøídu. V&nbsp;názvu souboru <strong>.class</strong> je
pou¾ito jméno obalové tøídy, znak dolar, generovaný index a jméno lokální
tøídy.</li>

<li>ka¾dou anonymní tøídu. Název souboru <strong>.class</strong> obsahuje pouze
jméno obalové tøídy, znak dolar a generovaný index.</li>

<li>ka¾dý výèet (co¾ je jen forma bì¾né tøídy se stejnými pravidly pro
pojmenování).</li>

<li>ka¾dé rozhraní. Soubor se jmenuje stejnì, jako jméno rozhraní.</li>

</ul>

<p>Uka¾me si zpùsob pojmenování souborù <strong>.class</strong> na jediném
zdrojovém textu s&nbsp;rùznými typy tøíd, rozhraní a výètù, který má tvar:</p>

<pre>
// vycet
enum E {}
&nbsp;
// vycet
enum F {}
&nbsp;
// rozhrani
interface I { }
&nbsp;
// rozhrani
interface J { }
&nbsp;
// bezna trida (je verejna, tudiz pojmenovana stejne, jako zdrojovy soubor)
public class A {
    // vnitrni trida
    class InnerClassA1 {
    }
    // vnitrni trida
    class InnerClassA2 {
        // vnitrni trida uvnitr vnitrni tridy :-)
        class InnerClassInA2 {
        }
    }
    // staticka vnitrni trida
    static class StaticInnerClassA {
    }
    // ctverice anonymnich trid
    I i1 = new I(){};
    I i2 = new I(){};
    J j1 = new J(){};
    J j2 = new J(){};
    void x() {
        // lokalni tridy
        class LocalClassX {};
        class LocalClassY {};
        class LocalClassZ {};
    }
    void y() {
        // lokalni tridy
        class LocalClassX {};
        class LocalClassY {};
        class LocalClassZ {};
    }
}
&nbsp;
// bezna (neverejna) trida
class B {
    // vnitrni trida
    class InnerClassA2 {
    }
}
</pre>

<p>Po pøekladu vý¹e vypsaného zdrojového textu získáme následující soubory.
Mù¾ete si sami zkusit spárovat jména tìchto souborù s&nbsp;definicemi tøíd,
rozhraní a výètù:</p>

<pre>
A.class
A$InnerClassA1.class
A$InnerClassA2.class
A$InnerClassA2$InnerClassInA2.class
A$StaticInnerClassA.class
A$1.class
A$1LocalClassX.class
A$1LocalClassY.class
A$1LocalClassZ.class
A$2.class
A$2LocalClassX.class
A$2LocalClassY.class
A$2LocalClassZ.class
A$3.class
A$4.class
B.class
B$InnerClassA2.class
E.class
F.class
I.class
J.class
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Struktura souborù .class</h2>

<p>Na jednu stranu jsou sice vý¹e vypsaná pravidla urèující zpùsob pojmenování
souborù typu <strong>.class</strong> ponìkud komplikovaná, na stranu druhou to
v¹ak vede k&nbsp;tomu, ¾e interní struktura tìchto souborù mù¾e být pomìrnì
jednoduchá, proto¾e ka¾dý soubor <strong>.class</strong> mù¾e obsahovat, jak
jsme si ji¾ øekli, pouze informace o jediné tøídì, rozhraní èi výètovém typu.
V&nbsp;souborech <strong>.class</strong> se nachází pøedev¹ím velmi jednoduchá
osmibajtová hlavièka. Za ní je ulo¾en takzvaný <i>constant pool</i>, který
mnohdy tvoøí více ne¾ 2/3 celkové velikosti souboru. Poté je v&nbsp;souboru
v&nbsp;binární formì ulo¾ena informace o pøístupových právech, jméno tøídy i
nadtøídy, seznam implementovaných rozhraní, seznam atributù tøídy a koneènì
vlastní pøíkazy tvoøící tìla jednotlivých metod (JVM je zalo¾ena na relativnì
jednoduchém zásobníkovém procesoru). Na konci souboru <strong>.class</strong>
se mohou nacházet dal¹í informace, jejich¾ význam si popí¹eme
v&nbsp;následujících èástech tohoto seriálu.</p>

<pre>
+------------------------------+
|  Hlavièka                    |
+------------------------------+
|  Constant pool               |
|  .....                       |
|  .....                       |
|  .....                       |
+------------------------------+
|  Definice pøístupových práv  |
+------------------------------+
|  Jméno tøídy a nadtøídy      |
+------------------------------+
|  Implementovaná rozhraní     |
|  .....                       |
+------------------------------+
|  Atributy tøídy              |
|  .....                       |
+------------------------------+
|  Kódy jednotlivých metod     |
|  .....                       |
|  .....                       |
|  .....                       |
+------------------------------+
|  Dal¹í metadata tøídy        |
+------------------------------+
</pre>

<p>U¾iteèné odkazy:</p>

<ol>

<li>The JavaTM Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

</ol>



<p><a name="k07"></a></p>
<h2 id="k07">7. Hlavièka souborù .class</h2>

<p>Hlavièka souborù <strong>.class</strong> je velmi jednoduchá, obsahuje toti¾
pouze trojici hodnot. Soubory tohoto typu zaèínají, podobnì jako mnoho dal¹ích
typù binárních souborù, takzvanou magickou konstantou slou¾ící pro snadné (i
kdy¾ ne v¾dy zcela pøesné) rozpoznání typu souboru. V&nbsp;pøípadì souborù
<strong>.class</strong> je tato konstanta ètyøbajtová a obsahuje hodnotu, která
má v&nbsp;hexadecimálním vyjádøení tvar <strong>0x CAFE BABE</strong>
(v&nbsp;minulosti se navíc pou¾ívala podobná magická konstanta <strong>0x CAFE
DEAD</strong> pro oznaèení souborù s&nbsp;perzistentními objekty). Tato
konstanta je, podobnì jako v¹echny dal¹í vícebajtové konstanty v&nbsp;souborech
<strong>.class</strong>, ulo¾ena v&nbsp;poøadí <i>big endian</i>, tedy pøesnì
naopak, ne¾ je zvykem u architektury <i>i386</i> (Java ostatnì pùvodnì vznikla
na procesorech <i>SPARC</i>, nikoli na platformì <i>i386</i>). Za ètyøbajtovou
magickou konstantou se nachází dvì dvoubajtové hodnoty, v&nbsp;nich¾ je ulo¾eno
minoritní a majoritní èíslo verze bajtkódu. Tyto hodnoty jsou pou¾ity pøi
naèítání bajtkódu do virtuálního stroje pro základní kontrolu kompatibility.
Následuje výpis struktury hlavièky bajtkódu:</p>

<pre>
+-------------------------+---------+
| Magická konstanta       | 4 bajty |
+-------------------------+---------+
| Minoritní verze formátu | 2 bajty |
+-------------------------+---------+
| Majoritní verze formátu | 2 bajty |
+-------------------------+---------+
</pre>

<p>Vra»me se na chvíli k&nbsp;èíslu verze bajtkódu. V&nbsp;souèasnosti se
mù¾ete nejèastìji setkat s&nbsp;následujícími verzemi:</p>

<table>
<tr><th>Verze JVM/JRE</th><th>Èíslo verze bajtkódu</th></tr>
<tr><td>1.1</td><td>45</td></tr>
<tr><td>1.2</td><td>45</td></tr>
<tr><td>1.3</td><td>47</td></tr>
<tr><td>1.4</td><td>48</td></tr>
<tr><td>5.0</td><td>49</td></tr>
<tr><td>6.0</td><td>50</td></tr>
<tr><td>7</td><td>51</td></tr>
</table>

<p>V&nbsp;nìkterých pøípadech se mù¾e stát, ¾e je zapotøebí vyu¾ít bajtkód
pøelo¾ený pro vy¹¹í verzi JVM/JRE a souèasnì není k&nbsp;dispozici zdrojový kód
tøíd. V&nbsp;tomto pøípadì je mo¾né (ov¹em¾e na vlastní riziko) ruènì upravit
majoritní èíslo verze bajtkódu, proto¾e samotná struktura bajtkódu nepro¹la
vìt¹ími zmìnami &ndash; pouze byly doplnìny metainformace o tøídì a takté¾
do¹lo k&nbsp;doplnìní nových instrukcí (asi nejznámìj¹í novinkou v&nbsp;této
oblasti je instrukce <strong>invokedynamic</strong>, k&nbsp;ní¾ se nìkdy je¹tì
vrátíme). Zmìny v&nbsp;API základních knihoven jsou navíc testovány a¾ za bìhu
JRE.</p>

<p><ins>Poznámka: takté¾ se lze setkat s&nbsp;opaèným problémem, kdy je
zapotøebí vygenerovat soubory <strong>.class</strong>, které budou vyu¾ívané
star¹í JVM/JRE (mnoho komerèních aplikací napøíklad stále pou¾ívá Javu 1.4.2).
Zde je øe¹ení vìt¹inou jednoduché &ndash; postaèuje pou¾ít pøi pøekladu
pøepínaèe <strong>-source 1.x</strong> a <strong>-target
1.x</strong>:</ins></p>

<pre>
javac -source 1.4 -target 1.4 Hello.java
</pre>

<p>Verze Javy odpovídající zdrojovým kódùm musí být men¹í nebo rovna verzi
cílového JVM/JRE.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Constant pool &ndash; nedílná souèást souborù .class</h2>

<p>Za hlavièkou následuje obvykle objemovì nejrozsáhlej¹í èást souborù
<strong>.class</strong>. Jedná se o takzvaný <i>constant pool</i>, v&nbsp;nìm¾
jsou ulo¾eny nìkteré èíselné konstanty a takté¾ v¹echny øetìzcové konstanty (to
je ostatnì jeden z&nbsp;dùvodù, proè lze s&nbsp;<i>konstantními</i> øetìzci
definovanými v&nbsp;rámci jedné tøídy provádìt operaci porovnání pomocí
operátoru ==). Dále se zde nachází pøesné typové informace o v¹ech pou¾itých
tøídách i o volaných metodách tìchto tøíd. Prvním údajem v&nbsp;<i>constant
poolu</i> je informace o jeho délce, co¾ je dvoubajtové èíslo obsahující
hodnotu o jednièku vìt¹í, ne¾ je skuteèný poèet záznamù v&nbsp;constant poolu.
Ka¾dý prvek zaèíná jednobajtovým <i>tagem</i>, který urèuje jeho typ a posléze
ji¾ následují ulo¾ené údaje. Celkem se rozeznává jedenáct typù záznamù.</p>

<p>Nejjednodu¹¹í jsou záznamy o èíselných konstantách typu <i>int</i> a
<i>float</i>, proto¾e hodnoty tìchto konstant jsou ulo¾eny pøímo za tagem
záznamu. Ponìkud slo¾itìj¹í je zpùsob ulo¾ení konstant typu <i>long</i> a
<i>double</i>. Tyto konstanty jsou takté¾ ulo¾eny ihned za tagem, ale tvùrci
bajtkódu se dosti ne¹»astnì rozhodli, ¾e za tìmito konstantami bude následovat
jeden nepou¾itý záznam (ten samozøejmì není ulo¾ený v&nbsp;bajtkódu, ale pøi
dekódování informací z&nbsp;constant poolu se musí korektnì zvý¹it hodnota
indexu &ndash; ov¹em to je ji¾ problém dekódovacích nástrojù a prozatím se jim
nemusíme zaobírat).</p>

<table>
<tr><th>Tag</th><th>Název tagu</th><th>Parametr 1</th><th>Parametr 2</th></tr>
<tr><td> 3</td><td>Integer </td><td>ètyøbajtová konstanta</td><td>&times;</td></tr>
<tr><td> 4</td><td>Float   </td><td>ètyøbajtová konstanta</td><td>&times;</td></tr>
<tr><td> 5</td><td>Long    </td><td>osmibajtová konstanta</td><td>&times;</td></tr>
<tr><td> 6</td><td>Double  </td><td>osmibajtová konstanta</td><td>&times;</td></tr>
</table>

<p>Dùle¾itý je takté¾ záznam obsahující øetìzec (kódovaný s&nbsp;vyu¾itím
<i>UTF-8</i>, navíc se zadanou délkou bez ukonèující nuly), proto¾e na tento
typ záznamu se odkazují mnohé dal¹í záznamy. Týká se to i záznamu typu
<strong>String</strong>, který se odkazuje právì na záznam typu
<strong>Utf8</strong> (odkaz není nic jiného, ne¾ index záznamu
v&nbsp;constant poolu):</p>

<table>
<tr><th>Tag</th><th>Název tagu</th><th>Parametr 1</th><th>Parametr 2</th></tr>
<tr><td> 1</td><td>Utf8     </td><td>délka øetìzce v&nbsp;bajtech</td><td>sekvence bajtù (poèet znakù je obecnì men¹í ne¾ poèet bajtù)</td></tr>
<tr><td> 8</td><td>String   </td><td>2 bajty: odkaz na vlastní øetìzec (záznam typu <strong>Utf8</strong>)</td><td>&times;</td></tr>
</table>

<p>Zaèíná pøituhovat :-) V¹echny dal¹í typy záznamù obsahují pouze reference
(indexy) na dal¹í záznam èi dokonce na dvojici záznamù. Týká se to napøíklad
záznamu nesoucího informaci o referencované metodì (<i>Methodref</i>), který
odkazuje na záznam s&nbsp;informací o tøídì (<i>Class</i>) a dále na záznam
s&nbsp;informací o jménu a typu metody. Jak záznam s&nbsp;informací o tøídì,
tak i záznam s&nbsp;informací o jménu a typu takté¾ obsahují odkazy/reference
na dal¹í záznamy; konkrétnì odkazy na øetìzce se jménem tøídy, jménem metody,
její návratové hodnoty a takté¾ jejich parametrech (zní to pomìrnì slo¾itì, ve
skuteènosti je tento zpùsob nìkdy i velmi úsporný). V¹echny odkazy/reference
jsou ulo¾eny ve formì dvoubajtových indexù záznamù, pøièem¾ indexování zaèíná
od jednièky. V&nbsp;následující tabulce jsou vypsány typy záznamù obsahující
reference na jiné záznamy:</p>

<table>
<tr><th>Tag</th><th>Název tagu</th><th>Parametr 1</th><th>Parametr 2</th></tr>
<tr><td> 7</td><td>Class             </td><td>2 bajty: odkaz na jméno tøídy (záznam typu <strong>Utf8</strong>)</td><td>&times;</td></tr>
<tr><td> 9</td><td>Fieldref          </td><td>2 bajty: odkaz na jméno tøídy (záznam typu <strong>Utf8</strong>)</td><td>2 bajty: odkaz na záznam typu <strong>NameAndType</strong></td></tr>
<tr><td>10</td><td>Methodref         </td><td>2 bajty: odkaz na jméno tøídy (záznam typu <strong>Utf8</strong>)</td><td>2 bajty: odkaz na záznam typu <strong>NameAndType</strong></td></tr>
<tr><td>11</td><td>InterfaceMethodref</td><td>2 bajty: odkaz na jméno tøídy (záznam typu <strong>Utf8</strong>)</td><td>2 bajty: odkaz na záznam typu <strong>NameAndType</strong></td></tr>
<tr><td>12</td><td>NameAndType       </td><td>2 bajty: odkaz na záznam typu <strong>Utf8</strong></td><td>2 bajty: odkaz na záznam typu <strong>Utf8</strong></td></tr>
</table>

<p>Indexy tìchto záznamù jsou intenzivnì pou¾ívány v&nbsp;instrukcích tvoøících
tìla metod. Díky tomu jsou napøíklad instrukce pro volání metod velmi krátké,
proto¾e obsahují pouze krátký index do <i>constant poolu</i>, nikoli napøíklad
32 èi 64bitovou adresu skoku. V¹e si podrobnì vysvìtlíme v&nbsp;dal¹ím
pokraèování tohoto seriálu, kde si takté¾ uká¾eme jednoduchý nástroj
(naprogramovaný v&nbsp;céèku), který doká¾e rychle zobrazit obsah celého
<i>constant poolu</i> zpùsobem, který je podobný zpùsobu pou¾ívanému mj.&nbsp;i
nástrojem <strong>javap</strong>. Pøí¹tì si takté¾ popí¹eme dal¹í souèásti
bajtkódu.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>The JavaTM Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>FindBugs<br />
<a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a>
</li>

<li>GNU Classpath<br />
<a href="www.gnu.org/s/classpath/">www.gnu.org/s/classpath/</a></li>

<li>Java VMs Compared<br />
<a href="http://bugblogger.com/java-vms-compared-160/">http://bugblogger.com/java-vms-compared-160/</a>
</li>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a></li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>ClosableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2011</small></p>
</body>
</html>

