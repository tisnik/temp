<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Novinky v&nbsp;JDK 7 aneb mírný pokrok v&nbsp;mezích zákona (2)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Novinky v&nbsp;JDK 7 aneb mírný pokrok v&nbsp;mezích zákona (2)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhé èásti seriálu o nových vlastnostech programovacího jazyka Java i jeho virtuálního stroje, které jsou zaøazeny do JDK 7, si popí¹eme dal¹í roz¹íøení syntaxe a sémantiky Javy. Jedná se pøedev¹ím o nový operátor nazvaný &bdquo;diamant&ldquo; a takté¾ o roz¹íøené mo¾nosti bloku try-catch-delete, které byly do Javy zavedeny spolu s&nbsp;novým rozhraním AutoCloseable.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Novinky v&nbsp;JDK 7 aneb mírný pokrok v&nbsp;mezích zákona (2)</a></p>
<p><a href="#k02">2. JDK 5 a generické datové typy</a></p>
<p><a href="#k03">3. Generiky ve vygenerovaném bajtkódu</a></p>
<p><a href="#k04">4. Nová syntaxe v&nbsp;JDK 7 &ndash; operátor &lt;&gt;</a></p>
<p><a href="#k05">5. Je operátor &lt;&gt; skuteènì nezbytný a/nebo dostateènì obecný?</a></p>
<p><a href="#k06">6. Rozhraní <strong>Closeable</strong> a mo¾né problémy pøi jeho pou¾ití</a></p>
<p><a href="#k07">7. Automatická správa prostøedkù: rozhraní <strong>AutoCloseable</strong> a roz¹íøení mo¾ností bloku <strong>try</strong></a></p>
<p><a href="#k08">8. Vliv existence automatické správy prostøedkù na stávající aplikace</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2>1. Novinky v&nbsp;JDK 7 aneb mírný pokrok v&nbsp;mezích zákona (2)</h2>

<p>V&nbsp;úvodní èásti miniseriálu o nových vlastnostech, které byly zaøazeny
do <i>JDK 7</i>, jsme se alespoò struènì seznámili s&nbsp;tím, jaká vylep¹ení
byla do <i>JDK 7</i> plánována v&nbsp;minulosti (je¹tì firmou <i>Sun
Microsystems</i>) a která z&nbsp;tìchto vylep¹ení skuteènì mù¾eme v&nbsp;<i>JDK
7</i> najít. Nìkteré pùvodnì navrhované zmìny byly v&nbsp;rámci plánu
&bdquo;B&ldquo; pøesunuty do <i>JDK 8</i> nebo <i>JDK 9</i>, ov¹em i tak nabízí
<i>JDK 7</i> popø.&nbsp;<i>OpenJDK 7</i> (zalo¾ené na prakticky shodných
zdrojových kódech a knihovnách) nìkolik novinek v&nbsp;syntaxi i sémantice
jazyka <i>Java</i>, s&nbsp;nimi¾ se prùbì¾nì seznámíme. Dvì implementaènì
nejjednodu¹¹í vlastnosti &bdquo;nové&ldquo; <i>Javy</i> jsme si ji¾ popsali
&ndash; jednalo se o mo¾nost vkládaní podtr¾ítek do numerických konstant (co¾
je opravdu pouze syntaktický cukr) a takté¾ o mo¾nost pou¾ívat øetìzce
v&nbsp;rozhodovací struktuøe typu <strong>switch-case</strong> (tato vlastnost
je ji¾ zajímavìj¹í, a to i z&nbsp;hlediska principu pøekladu zdrojových textù
do bajtkódu).</p>

<p>Obì zmiòované novinky v&nbsp;syntaxi a sémantice <i>Javy</i> byly zavedeny
v&nbsp;rámci projektu <i>Coin</i>, v&nbsp;nìm¾ v¹ak mù¾eme nalézt i mnohá dal¹í
vylep¹ení. Jedno z&nbsp;tìchto vylep¹ení se týká zjednodu¹ení práce
s&nbsp;generickými datovými typy &ndash; pro tyto úèely byl novì vytvoøen
operátor nazvaný podle svého (vizuálního) tvaru <i>diamant</i>. Nemusíte se
v¹ak bát &ndash; tvùrci <i>Javy</i> jsou dostateènì soudní, tak¾e do jazyka
<strong>NE</strong>zavedli nìjaký cizokrajný znak z&nbsp;Unicode; v¹e se
alespoò prozatím zapisuje ve staré dobré ASCII :-). Nejdøíve se tedy budeme
vìnovat generickým datovým typùm z&nbsp;<i>JDK 5</i> a jejich souvislosti
s&nbsp;novým operátorem <i>diamant</i>.</p>



<p><a name="k02"></a></p>
<h2>2. JDK 5 a generické datové typy</h2>

<p>Jednou z&nbsp;novinek zavedených ji¾ v&nbsp;<i>JDK</i> verze 5 (<i>J2SE
5.0</i>) byla podpora generických datových typù (generik). Dokonce je mo¾né
øíci, ¾e se &ndash; spoleènì s&nbsp;anotacemi &ndash; s&nbsp;velkou
pravdìpodobností jednalo o nejvìt¹í zmìny, kterými prozatím programovací jazyk
<i>Java</i> pøi svém více ne¾ patnáctiletém vývoji pro¹el. Díky pou¾ití
generických datových typù se zjednodu¹ila jak práce programátorù, tak se
souèasnì i zvý¹ila bezpeènost jimi vytváøených aplikací, napøíklad pøi práci
s&nbsp;kolekcemi, tj.&nbsp;s&nbsp;mno¾inami, seznamy a asociativními poli
(mapami).</p>

<p>Kolekce toti¾ byly je¹tì v&nbsp;<i>JDK 1.4.x</i> implementovány takovým
zpùsobem, ¾e jako své prvky mohly obsahovat pouze obecný typ
<strong>Object</strong> (stojící, jak je známo, na vrcholu hierarchie tøíd) a
pøi ka¾dém ètení prvku ulo¾eného v&nbsp;kolekci se tedy muselo pøímo
v&nbsp;programu provádìt explicitní pøetypování objektù získávaných
z&nbsp;kolekcí. Toto pøetypování bylo jak nepøehledné, tak i potenciálnì
nebezpeèné (popø.&nbsp;samozøejmì bylo mo¾né pomocí operátoru
<strong>instanceof</strong> otestovat, zda objekt implementuje nìjaké rozhraní
èi zda je instancí dané tøídy nebo jejího potomka). Typovì zabezpeèené kolekce,
které nebylo mo¾né deklarovat pøímo s&nbsp;vyu¾itím výrazových prostøedkù
programovacího jazyka, se tedy musely tvoøit ruènì, co¾ bylo pracné a
v&nbsp;mnoha ohledech také nepøehledné, zejména v&nbsp;tìch pøípadech, kdy¾ si
vývojáø vytvoøil vlastní API s&nbsp;jinými názvy èi významy metod, ne¾ byly
pou¾ité v&nbsp;<i>JCF &ndash; Java Collections Framework</i>.</p>

<p>Pro pøipomenutí si uka¾me, jak mohl vypadat (umìlý) pøíklad pøelo¾itelný
v&nbsp;<i>JDK 1.4.x</i> (v&nbsp;novìj¹ích <i>JDK</i> pou¾ijte pro pøíklad
pøepínaè <strong>-source 1.4</strong>):</p>

<pre>
import java.util.List;
import java.util.ArrayList;

public class TT
{
    public static void main(String[] args)
    {
        List l = new ArrayList();
        l.add("String");
        l.add(Integer.valueOf(1));
        l.add(new Object());
        for (int i = 0; i &lt; l.size(); i++)
        {
            Object o = l.get(i);
            System.out.println(o.getClass().getName() + "\t" + o.toString());
            if (o instanceof Integer)
            {
                Integer integer = (Integer)o;
                System.out.println("Nasli jsme cislo :-) " + 100*integer.intValue());
            }
        }
    }
}
</pre>

<p>Výstup zobrazený po spu¹tìní pøíkladu:</p>

<pre>
java.lang.String	String
java.lang.Integer	1
Nasli jsme cislo :-) 100
java.lang.Object	java.lang.Object@42e816
</pre>



<p><a name="k03"></a></p>
<h2>3. Generiky ve vygenerovaném bajtkódu</h2>

<p>Zajímavé a pro celou platformu <i>Javy</i> vlastnì i typické je to, ¾e se po
pøidání podpory pro generické datové typy v&nbsp;<i>JDK 5</i> tato nová
vlastnost nijak zásadním zpùsobem neprojevila na vygenerovaném bajtkódu.
Pøekladaè toti¾ &ndash; ponìkud zjednodu¹enì øeèeno &ndash; vygeneroval bajtkód
obsahující konstrukci beztypové kolekce a pøi ètení objektù z&nbsp;kolekce
automaticky doplnil instrukce pro kontrolu pøetypování následovanou vlastním
pøetypováním (tj.&nbsp;v&nbsp;podstatì øe¹il stejný problém, jako my
v&nbsp;pøedchozím pøíkladu). Strukturu bajtkódu si ostatnì mù¾eme ukázat na
jednoduchém pøíkladu. Po pøekladu následujícího zdrojového kódu pou¾ívajícího
kolekci (konkrétnì seznam implementovaný polem) s&nbsp;generikami...:</p>

<pre>
import java.util.List;
import java.util.ArrayList;

public class T
{
    public static void main(String[] args)
    {
        List&lt;String&gt; l = new ArrayList&lt;String&gt;();
        l.add("www.root.cz");
        String s = l.get(0);
        System.out.println(s);
    }
}
</pre>

<p>...se vytvoøí bajtkód, v&nbsp;nìm¾ se volá konstruktor obecného
<strong>ArrayListu</strong> s&nbsp;metodami <strong>boolean add(Object
o)</strong> a <strong>Object get(int index)</strong>; viz té¾ <a
href="http://download.oracle.com/javase/1.4.2/docs/api/java/util/ArrayList.html">http://download.oracle.com/javase/1.4.2/docs/api/java/util/ArrayList.html</a>:</p>

<pre>
Compiled from "T.java"
public class T extends java.lang.Object{
public T();
  Code:
   0:	aload_0
   1:	invokespecial	#1; //Method java/lang/Object."&lt;init&gt;":()V
   4:	return

public static void main(java.lang.String[]);
  Code:
   0:	new	#2; //class java/util/ArrayList
   3:	dup
   4:	invokespecial	#3; //Method java/util/ArrayList."&lt;init&gt;":()V
   7:	astore_1
   8:	aload_1
   9:	ldc	#4; //String Hello

   // -----------------------------------------------------------
   // volání metody boolean List.add(Object o)
   // -----------------------------------------------------------
   11:	invokeinterface	#5,  2; //InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z
   16:	pop
   17:	aload_1
   18:	iconst_0

   // -----------------------------------------------------------
   // volání metody Object List.get(int index)
   // -----------------------------------------------------------
   19:	invokeinterface	#6,  2; //InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;

   // -----------------------------------------------------------
   // kontrola typu získaného objektu za bìhu programu (runtime)
   // - vìt¹inou ji HotSpot v dal¹ím bìhu eliminuje
   //   Dùle¾ité je, ¾e se tato kontrola skuteènì provádí,
   //   ale pouze do chvíle, kdy je ji¾ jasné, ¾e nedojde
   //   k pøedání objektu jiného typu.
   // -----------------------------------------------------------
   24:	checkcast	#7; //class java/lang/String
   27:	astore_2
   28:	getstatic	#8; //Field java/lang/System.out:Ljava/io/PrintStream;
   31:	aload_2
   32:	invokevirtual	#9; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
   35:	return
}
</pre>

<p>Poznámky ve vý¹e uvedeném bajtkódu jsou samozøejmì dopsány ruènì, program
<strong>javap</strong> prozatím tak sofistikovaný není :-)</p>



<p><a name="k04"></a></p>
<h2>4. Nová syntaxe v&nbsp;JDK 7 &ndash; operátor &lt;&gt;</h2>

<p>V&nbsp;demonstraèním pøíkladu uvedeném v&nbsp;pøedchozí kapitole byl seznam,
jen¾ mù¾e obsahovat pouze instance tøídy <strong>String</strong>, vytvoøen
pomocí tohoto pøíkazu:</p>

<pre>
List&lt;String&gt; list = new ArrayList&lt;String&gt;();
</pre>

<p>Podobnou konstrukci pou¾ívají vývojáøi pøi práci v&nbsp;Javì dennì a pro
její jednodu¹¹í tvorbu existuje i podpora v&nbsp;mnoha vývojových prostøedích
&ndash; v&nbsp;nich postaèuje zapsat pouze èást výrazu a napøíklad typ prvkù
ukládaných do kolekce se ji¾ na pravé stranì doplní automaticky, tak¾e by se
mohlo zdát, ¾e zde k&nbsp;¾ádnému problému nedochází. V&nbsp;nìkterých
pøípadech je v¹ak deklarace datového typu prvkù na levé i pravé stranì
pøiøazovacího pøíkazu slo¾itìj¹í, co¾ vede ke zbyteènému duplikování stejných
èástí zdrojového textu. Podívejme se napøíklad na následující (samozøejmì umìle
vytvoøené!) pøíklady:</p>

<pre>
List&lt;String&gt; list = new ArrayList&lt;String&gt;();
List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;List&lt;String&gt;&gt;();
List&lt;List&lt;List&lt;String&gt;&gt;&gt; list = new ArrayList&lt;List&lt;List&lt;String&gt;&gt;&gt;();
Map&lt;String, Collection&lt;Integer&gt;&gt; map = new LinkedHashMap&lt;String, Collection&lt;Integer&gt;&gt;();
</pre>

<p>Aby se na pravou stranu pøiøazovacího pøíkazu nemusel kopírovat ten samý
zdrojový text, který je na jeho levé stranì, byl do <i>JDK 7</i> pøidán nový
operátor nazvaný <i>diamant</i>, proto¾e se skuteènì diamantu podobá &ndash;
zapisuje se toti¾ znakem &bdquo;men¹í ne¾&ldquo;, za ním¾ je ihned zapsán znak
&bdquo;vìt¹í ne¾&ldquo;. Pokud pøekladaè tento operátor ve zdrojovém textu
uvidí, pokusí se <i>odvodit</i> správný datový typ z&nbsp;deklarace na levé
stranì výrazu. Uva¾uje se je¹tì o slo¾itìj¹ím algoritmu odvození typu podle
parametrù pøedaných konstruktoru, ov¹em souèasné demoverze <i>JDK 7</i> a
<i>OpenJDK 7</i> v&nbsp;tomto ohledu nepracují zcela korektnì (operátor
<i>diamant</i> takté¾ pracuje pouze pøi konstrukci objektu pomocí
<strong>new</strong>, nikoli napøíklad pøi pøetypování). Pøíklady uvedené pøed
tímto odstavcem je tedy mo¾né s&nbsp;vyu¾itím operátoru <i>diamant</i> pøepsat
následujícím zpùsobem:</p>

<pre>
List&lt;String&gt; list = new ArrayList&lt;&gt;();
List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;();
List&lt;List&lt;List&lt;String&gt;&gt;&gt; list = new ArrayList&lt;&gt;();
Map&lt;String, Collection&lt;Integer&gt;&gt; map = new LinkedHashMap&lt;&gt;();
</pre>

<p>Uka¾me si celý demonstraèní pøíklad:</p>

<pre>
import java.util.List;
import java.util.ArrayList;

public class DiamondTest1
{
    public static void main(String[] args)
    {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("Hello");
        list.add(null);
        list.add("World!");
        for (String str : list)
        {
            System.out.println(str);
        }
    }
}
</pre>

<p>Popø.&nbsp;ponìkud slo¾itìj¹í pøíklad, v&nbsp;nìm¾ je <i>diamant</i> pou¾it
na více místech oznaèených poznámkami:</p>

<pre>
import java.util.*;

public class DiamondTest3
{
    public static void main(String[] args)
    {
        //                            vvvv
        Set&lt;Integer&gt; set1 = new TreeSet&lt;&gt;();
        //                            ^^^^

        set1.add(1);
        set1.add(2);
        set1.add(3);

        //                            vvvv
        Set&lt;Integer&gt; set2 = new TreeSet&lt;&gt;();
        //                            ^^^^

        set2.add(100);
        set2.add(99);
        set2.add(88);

        //                                    vvvv
        List&lt;Set&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();
        //                                    ^^^^

        list.add(set1);
        list.add(set2);

        // zde _nelze_ pou¾ít operátor diamant, tj. nejde napsat
        // napøíklad Set&lt;&gt; numbers : list
        for (Set&lt;Integer&gt; numbers : list)
        {
            for (Integer number : numbers)
            {
                System.out.print(number + "\t");
            }
            System.out.println();
        }

    }
}
</pre>



<p><a name="k05"></a></p>
<h2>5. Je operátor &lt;&gt; skuteènì nezbytný a/nebo dostateènì obecný?</h2>

<p>Návrh na pøidání operátoru <i>diamant</i>, který do <i>Javy</i> (dokonce ji¾
podruhé) pøinesl algoritmy pro automatické odvozování typù objektù, se setkal
s&nbsp;pomìrnì velkým ohlasem, a to jak ze strany vývojáøù, kteøí by tento
prvek nejradìji úplnì zru¹ili, tak na druhé stranì od vývojáøù (majících
evidentnì zku¹enosti z&nbsp;jiných programovacích jazykù), kteøí naopak
tvrdili, ¾e je tento operátor nìkde na pùli cesty k&nbsp;plné typové inferenci.
Po prostudování demonstraèních pøíkladù uvedených v&nbsp;pøedchozí kapitole se
mo¾ná také ptáte, proè je vlastnì nutné vùbec nový operátor do programovacího
jazyka <i>Java</i> zavádìt, kdy¾ by postaèovalo napsat nìco podobného:</p>

<pre>
List&lt;String&gt; list = new ArrayList();
List&lt;List&lt;String&gt;&gt; list = new ArrayList();
List&lt;List&lt;List&lt;String&gt;&gt;&gt; list = new ArrayList();
Map&lt;String, Collection&lt;Integer&gt;&gt; map = new LinkedHashMap();
</pre>

<p>Podle autorù projektu <i>Coin</i> by v¹ak povolení tohoto je¹tì jednodu¹¹ího
zápisu bylo v&nbsp;rozporu se zpìtnou kompatibilitou s&nbsp;pøedchozími verzemi
<i>Javy</i>, kde zápis <strong>new ArrayList()</strong> znamená vytvoøení
&bdquo;beztypového&ldquo; seznamu s&nbsp;prvky typu <strong>Object</strong>.
Zde se ukazuje, jak se závislost na pùvodní syntaxi <i>Javy</i> negativnì
projevuje i v&nbsp;jejích moderních verzích (popravdì øeèeno je v¹ak tì¾ké
pøijít na to, kde by zmìna nikoli syntaxe ale pouze sémantiky v&nbsp;tomto
pøípadì mohla vadit).</p>

<p>Dal¹í èasto kladenou otázkou v&nbsp;souvislosti s&nbsp;novým operátorem
<i>diamant</i> je, proè vlastnì jeho tvùrci ne¹li v&nbsp;roz¹íøení syntaxe a
sémantiky je¹tì dále a proè <i>Java</i> nepodporuje napøíklad následující
zpùsoby vytváøení objektù, v&nbsp;nich¾ je celá deklarace typu uvedena pouze na
<strong>pravé</strong> stranì pøiøazovacího pøíkazu:</p>

<pre>
var list = new ArrayList&lt;String&gt;();
</pre>

<p>nebo s&nbsp;jiným klíèovým slovem:</p>

<pre>
auto map = new LinkedHashMap&lt;String, Collection&lt;Integer&gt;&gt;();
</pre>

<p>Jedním z&nbsp;dùvodù, proè (prozatím) tento zpùsob zápisu není
v&nbsp;<i>Javì</i> mo¾ný, spoèívá v&nbsp;tom, ¾e by se jednalo o pomìrnì
citelný zásah do jazyka, který by neodpovídal filozofii projektu <i>Coin</i> a
vlastnì ani mottu tohoto èlánku: &bdquo;mírný pokrok v&nbsp;mezích
zákona&ldquo; :-) Operátor &lt;&gt; toti¾ pomáhá programátorùm pouze v&nbsp;tom
ohledu, ¾e nemusí opisovat kód uvedený na levé stranì pøiøazovacího pøíkazu pøi
vytváøení objektù (a nikde jinde!), ale nesna¾í se ji¾ napøíklad odvodit obecný
typ vytvoøeného objektu, tj.&nbsp;zda se jedná o obecný objekt implementující
rozhraní <strong>Collection</strong>, obecný seznam <strong>List</strong> èi o
zcela konkrétní <strong>ArrayList</strong>. Nicménì v&nbsp;ostatních
srovnatelných programovacích jazycích ji¾ podobné konstrukce existují a fungují
ke spokojenosti programátorù, tak¾e je mo¾ná pouze otázkou èasu, kdy se nová
sémantika i syntaxe objeví v&nbsp;nìkteré z&nbsp;dal¹ích verzí <i>JDK</i>
(ostatnì i dnes existují projekty, které podobnou funkcionalitu do <i>Javy</i>
pøidávají, nìkdy pøí¹tì se k&nbsp;tìmto projektùm je¹tì vrátíme).</p>



<p><a name="k06"></a></p>
<h2>6. Rozhraní <strong>Closeable</strong> a mo¾né problémy pøi jeho pou¾ití</h2>

<p>Dal¹í vylep¹ení, které se objevilo v&nbsp;<i>JDK 7</i>, se týká práce
s&nbsp;objekty implementujícími nové rozhraní <strong>AutoCloseable</strong>,
tj.&nbsp;metodu <strong>void close()</strong>. Aby se s&nbsp;tìmito objekty
pracovalo jednodu¹¹ím zpùsobem, byla roz¹íøena syntaxe a sémantika bloku
<strong>try</strong>. Nová funkcionalita se nazývá <i>Automatic Resource
Management</i> neboli <i>ARM</i>. Pøipomeòme si jen, ¾e tvùrci návrhù
implementovaných v&nbsp;<i>JDK 7</i> zavedli v¹echny zmìny v&nbsp;syntaxi bez
pøidání nových klíèových slov a tyto zmìny navíc nevedou k&nbsp;tomu, aby bylo
nutné pøepisovat stávající aplikace. To je pro mainstreamový jazyk velmi
dùle¾itá podmínka, která sice umo¾òuje zachovat témìø 100% zpìtnou
kompatibilitu (vìt¹inou a¾ k&nbsp;<i>JDK 1.0</i>), na druhou stranu to v¹ak
ponìkud omezuje mo¾né inovace jazyka. Zmìny zavedené pøedev¹ím v&nbsp;<i>JDK
5</i> a <i>JDK 7</i> jsou ostatnì pìknou ukázkou &bdquo;balancování na
hranì&ldquo; mezi novými vlastnostmi a vazbou na minulost.</p>

<p>Nejprve si pøipomeòme, ¾e ji¾ v&nbsp;<i>JDK 5 (1.5)</i> bylo do API pøidáno
rozhraní <strong>Closeable</strong> s&nbsp;pøedpisem metody
<strong>close()</strong> a ¾e toto rozhraní implementuje pomìrnì velké mno¾ství
tøíd ze standardního API (typicky tøídy pro práci se soubory èi jinými
prostøedky). Toto rozhraní samozøejmì mohou implementovat i u¾ivatelské
objekty. Teoreticky je práce s&nbsp;tímto rozhraním velmi jednoduchá, zejména
v&nbsp;pøípadì, ¾e pøi práci programu nedojde ke vzniku ¹patnì o¹etøených
výjimek. Následuje jednoduchý pøíklad:</p>

<pre>
class T implements java.io.Closeable
{
    private String name;

    public T(String name)
    {
        this.name = name;
        System.out.println(name + " -&gt; constructor()");
    }

    public void doSomething()
    {
        System.out.println(name + " -&gt; doSomething()");
    }

    public void close()
    {
        System.out.println(name + " -&gt; close()");
    }
}

public class CloseTest1
{
    public static void main(String[] args)
    {
        T t1 = new T("T1");
        T t2 = new T("T2");
        T t3 = new T("T3");
        try
        {
            System.out.println("zacatek bloku try");
            t1.doSomething();
            t2.doSomething();
            t3.doSomething();
            t1.close();
            t2.close();
            t3.close();
            System.out.println("konec bloku try");
        }
        catch (RuntimeException e)
        {
            e.printStackTrace();
        }
        finally
        {
            System.out.println("blok finally");
        }
    }
}
</pre>

<p>Vzhledem k&nbsp;tomu, ¾e pøi bìhu velmi pravdìpodobnì nenastane ¾ádná
výjimka, pracuje program tak, jak bylo zamý¹leno, co¾ mj.&nbsp;znamená, ¾e se
korektnì zavolají v¹echny metody <strong>close()</strong>:</p>

<pre>
T1 -&gt; constructor()
T2 -&gt; constructor()
T3 -&gt; constructor()
zacatek bloku try
T1 -&gt; doSomething()
T2 -&gt; doSomething()
T3 -&gt; doSomething()
T1 -&gt; close()
T2 -&gt; close()
T3 -&gt; close()
konec bloku try
blok finally
</pre>

<p>Hor¹í je ov¹em situace ve chvíli, kdy k&nbsp;výjimce dojde a kdy napøíklad
metoda <strong>close()</strong> skuteènì zavírá nìjaký prostøedek, tøeba
pøipojení do databáze (které bývá pro jednu aplikaci nebo pro jednoho klienta
omezené):</p>

<pre>
class T implements java.io.Closeable
{
    private String name;

    public T(String name)
    {
        this.name = name;
        System.out.println(name + " -&gt; constructor()");
    }

    public void doSomething()
    {
        System.out.println(name + " -&gt; doSomething()");
    }

    public void close()
    {
        System.out.println(name + " -&gt; close()");
    }
}

public class CloseTest2
{
    public static void main(String[] args)
    {
        T t1 = new T("T1");
        T t2 = new T("T2");
        T t3 = new T("T3");
        try
        {
            System.out.println("zacatek bloku try");
            int i = Integer.parseInt(args[0]);
            t1.doSomething();
            t2.doSomething();
            t3.doSomething();
            t1.close();
            t2.close();
            t3.close();
            System.out.println("konec bloku try");
        }
        catch (RuntimeException e)
        {
            e.printStackTrace();
        }
        finally
        {
            System.out.println("blok finally");
        }
    }
}
</pre>

<p>Pokud není na jako první parametr programu zadáno korektnì zapsané celé
èíslo, dojde k&nbsp;výjimce a metody <strong>close()</strong> se nezavolají
&ndash; prostøedek zùstal aplikaci ji¾ natrvalo pøidìlen:</p>

<pre>
T1 -&gt; constructor()
T2 -&gt; constructor()
T3 -&gt; constructor()
zacatek bloku try
java.lang.ArrayIndexOutOfBoundsException: 0
	at CloseTest2.main(CloseTest2.java:32)
blok finally
</pre>

<p>Mohlo by se zdát, ¾e postaèuje pøesunout volání metod
<strong>close()</strong> do bloku <strong>finally</strong>:</p>

<pre>
class T implements java.io.Closeable
{
    private String name;

    public T(String name)
    {
        this.name = name;
        System.out.println(name + " -&gt; constructor()");
    }

    public void doSomething()
    {
        System.out.println(name + " -&gt; doSomething()");
    }

    public void close()
    {
        System.out.println(name + " -&gt; close()");
    }
}

public class CloseTest3
{
    public static void main(String[] args)
    {
        T t1 = new T("T1");
        T t2 = new T("T2");
        T t3 = new T("T3");
        try
        {
            System.out.println("zacatek bloku try");
            int i = Integer.parseInt(args[0]);
            t1.doSomething();
            t2.doSomething();
            t3.doSomething();
            System.out.println("konec bloku try");
        }
        catch (RuntimeException e)
        {
            e.printStackTrace();
        }
        finally
        {
            System.out.println("blok finally");
            t1.close();
            t2.close();
            t3.close();
        }
    }
}
</pre>

<p>Co¾ skuteènì bude pracovat (alespoò zdánlivì) korektnì:</p>

<pre>
T1 -&gt; constructor()
T2 -&gt; constructor()
T3 -&gt; constructor()
zacatek bloku try
java.lang.ArrayIndexOutOfBoundsException: 0
	at CloseTest2.main(CloseTest2.java:32)
blok finally
T1 -&gt; close()
T2 -&gt; close()
T3 -&gt; close()
</pre>

<p>Jen¾e tak jednoduché to není v&nbsp;pøípadì, ¾e metoda
<strong>close()</strong> vyvolává výjimky, co¾ samozøejmì dle její deklarace
mù¾e. Zde se pokusíme výjimku nasimulovat pro objekt se jménem
<strong>T2</strong>:</p>

<pre>
class T implements java.io.Closeable
{
    private String name;

    public T(String name)
    {
        this.name = name;
        System.out.println(name + " -&gt; constructor()");
    }

    public void doSomething()
    {
        System.out.println(name + " -&gt; doSomething()");
    }

    public void close()
    {
        if ("T2".equals(this.name))
        {
            throw new RuntimeException("T2 object throws exception!");
        }
        System.out.println(name + " -&gt; close()");
    }
}

public class CloseTest4
{
    public static void main(String[] args)
    {
        T t1 = new T("T1");
        T t2 = new T("T2");
        T t3 = new T("T3");
        try
        {
            System.out.println("zacatek bloku try");
            int i = Integer.parseInt(args[0]);
            t1.doSomething();
            t2.doSomething();
            t3.doSomething();
            System.out.println("konec bloku try");
        }
        catch (RuntimeException e)
        {
            e.printStackTrace();
        }
        finally
        {
            System.out.println("blok finally");
            t1.close();
            t2.close();
            t3.close();
        }
    }
}
</pre>

<p>Zase ¹patnì :-( proto¾e se nezavolají v¹echny metody <strong>close()</strong>, co¾ by v&nbsp;praxi znamenalo, ¾e aplikace po sobì neuklidí v¹echny prostøedky:</p>

<pre>
T1 -&gt; constructor()
T2 -&gt; constructor()
T3 -&gt; constructor()
zacatek bloku try
java.lang.ArrayIndexOutOfBoundsException: 0
	at CloseTest4.main(CloseTest4.java:36)
blok finally
T1 -&gt; close()
Exception in thread "main" java.lang.RuntimeException: T2 object throws exception!
	at T.close(CloseTest5.java:20)
	at CloseTest4.main(CloseTest4.java:50)
</pre>

<p>V&nbsp;<i>JDK 6</i> nám tedy nezbude nic jiného, ne¾ vytvoøit
&bdquo;¹pagetový&ldquo; kód s&nbsp;explicitním uzavíráním metod
<strong>close()</strong> do blokù <strong>try-catch-finally</strong>:</p>

<pre>
class T implements java.io.Closeable
{
    private String name;

    public T(String name)
    {
        this.name = name;
        System.out.println(name + " -&gt; constructor()");
    }

    public void doSomething()
    {
        System.out.println(name + " -&gt; doSomething()");
    }

    public void close()
    {
        if ("T2".equals(this.name))
        {
            throw new RuntimeException("T2 object throws exception!");
        }
        System.out.println(name + " -&gt; close()");
    }
}

public class CloseTest5
{
    public static void main(String[] args)
    {
        T t1 = new T("T1");
        T t2 = new T("T2");
        T t3 = new T("T3");
        try
        {
            System.out.println("zacatek bloku try");
            int i = Integer.parseInt(args[0]);
            t1.doSomething();
            t2.doSomething();
            t3.doSomething();
            System.out.println("konec bloku try");
        }
        catch (RuntimeException e)
        {
            e.printStackTrace();
        }
        finally
        {
            System.out.println("blok finally");
            try
            {
                t1.close();
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
            try
            {
                t2.close();
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
            try
            {
                t3.close();
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
        }
    }
}
</pre>

<p>Nyní se koneènì v¹echny metody <strong>close()</strong> zavolají, a to i
v&nbsp;pøípadì, ¾e nìkterá z&nbsp;nich vyvolala výjimku:</p>

<pre>
T1 -&gt; constructor()
T2 -&gt; constructor()
T3 -&gt; constructor()
zacatek bloku try
java.lang.ArrayIndexOutOfBoundsException: 0
	at CloseTest5.main(CloseTest5.java:36)
blok finally
T1 -&gt; close()
java.lang.RuntimeException: T2 object throws exception!
	at T.close(CloseTest5.java:20)
	at CloseTest5.main(CloseTest5.java:59)
T3 -&gt; close()
</pre>



<p><a name="k07"></a></p>
<h2>7. Automatická správa prostøedkù: rozhraní <strong>AutoCloseable</strong> a roz¹íøení mo¾ností bloku <strong>try</strong></h2>

<p>Ve v¹ech pøedchozích pøíkladech jsme si situaci je¹tì zjednodu¹ili
v&nbsp;tom, ¾e objekty <strong>t1</strong> a¾ <strong>t3</strong> jsou v¾dy
vytvoøeny, tj.&nbsp;lze pro nì zavolat metodu <strong>close()</strong>.
V&nbsp;praxi v¹ak mù¾e výjimka nastat ji¾ pøi konstrukci objektù, tak¾e by
pøíslu¹né reference na nì mìly hodnotu <strong>null</strong>, která by se
musela explicitnì testovat. Nicménì i pøi pou¾ití zjednodu¹ujících pøedpokladù
je poslední kód velmi dlouhý a jeho vlastní výkonná èást vlastnì smì¹nì krátká
&ndash; jedná se o trojici øádkù <strong>t?.doSomething();</strong>, okolo
nich¾ se nachází obrovité programové konstrukce øe¹ící <strong>pouze</strong>
mezní stavy programu. Vývojáøi, kteøí nejsou placeni za poèet vytvoøených
programových øádkù :-), tedy hledali a hledají cesty, jak se tomuto kódu
vyhnout. Kromì projektù tøetích stran  (opìt se k&nbsp;nim je¹tì vrátíme) bylo
jedno øe¹ení implementováno i v&nbsp;<i>JDK 7</i>.</p>

<p>Jedná se o pøidání nového rozhraní <strong>java.lang.AutoCloseable</strong>
do API a takté¾ o pøidání &bdquo;deklaraèní&ldquo; èásti do bloku
<strong>try</strong>. Objekty, které jsou v&nbsp;této deklaraèní èásti
vytvoøeny a souèasnì implementují rozhraní <strong>AutoCloseable</strong>, jsou
automaticky pøi opu¹tìní bloku &bdquo;uzavøeny&ldquo;, pøesnìji øeèeno se pro
nì zavolá metoda <strong>close()</strong>, a to nezávisle na tom, kdy a jaké
výjimky pøi bìhu nastanou. Metody <strong>close()</strong> se volají
v&nbsp;opaèném poøadí, ne¾ v&nbsp;jakém jsou objekty v&nbsp;bloku
<strong>try</strong> deklarovány, co¾ je praktické &ndash; napøíklad lze
otevøít pøipojení do databáze (<strong>Connection</strong>), vytvoøit
v&nbsp;nìm pøíkaz (<strong>Statement</strong>) a získat data z&nbsp;databáze
(<strong>ResultSet</strong>). Vcelku oprávnìnì tedy oèekáváme, ¾e se nejdøíve
uzavøe <strong>ResultSet</strong>, poté <strong>Statement</strong> a teprve pak
<strong>Connection</strong>. Následuje ukázka mo¾né úpravy pøedchozích pøíkladù
tak, aby se vyu¾ilo <i>ARM</i>:</p>

<pre>
// zde se implementuje nové rozhraní
class T implements java.lang.AutoCloseable
{
    private String name;

    public T(String name)
    {
        this.name = name;
        System.out.println(name + " -&gt; constructor()");
    }

    public void doSomething()
    {
        System.out.println(name + " -&gt; doSomething()");
    }

    public void close()
    {
        System.out.println(name + " -&gt; close()");
    }
}

public class CloseTest6
{
    public static void main(String[] args)
    {
        // nová deklaraèní èást v kulatých závorkách
        // (za poslední deklarací NENÍ støedník!)
        try (
            T t1 = new T("T1");
            T t2 = new T("T2");
            T t3 = new T("T3")
        )
        {
            System.out.println("zacatek bloku try");
            int i = Integer.parseInt(args[0]);
            t1.doSomething();
            t2.doSomething();
            t3.doSomething();
            System.out.println("konec bloku try");
        }
        catch (RuntimeException e)
        {
            e.printStackTrace();
        }
        finally
        {
            System.out.println("blok finally");
        }
    }
}
</pre>

<p>A výstup:</p>

<pre>
T1 -&gt; constructor()
T2 -&gt; constructor()
T3 -&gt; constructor()
zacatek bloku try
T3 -&gt; close()
T2 -&gt; close()
T1 -&gt; close()
java.lang.ArrayIndexOutOfBoundsException: 0
	at CloseTest6.main(CloseTest6.java:33)
blok finally
</pre>

<p>Je¹tì zkusíme pøidat umìlé vyhození výjimky pøi volání metody
<strong>close()</strong>:</p>

<pre>
class T implements java.lang.AutoCloseable
{
    private String name;

    public T(String name)
    {
        this.name = name;
        System.out.println(name + " -&gt; constructor()");
    }

    public void doSomething()
    {
        System.out.println(name + " -&gt; doSomething()");
    }

    public void close()
    {
        if ("T2".equals(this.name))
        {
            throw new RuntimeException("T2 object throws exception!");
        }
        System.out.println(name + " -&gt; close()");
    }
}

public class CloseTest7
{
    public static void main(String[] args)
    {
        try (
            T t1 = new T("T1");
            T t2 = new T("T2");
            T t3 = new T("T3")
        )
        {
            System.out.println("zacatek bloku try");
            int i = Integer.parseInt(args[0]);
            t1.doSomething();
            t2.doSomething();
            t3.doSomething();
            System.out.println("konec bloku try");
        }
        catch (RuntimeException e)
        {
            e.printStackTrace();
        }
        finally
        {
            System.out.println("blok finally");
        }
    }
}
</pre>

<p>Co¾ po spu¹tìní vede k&nbsp;následujícímu výstupu:</p>

<pre>
T1 -&gt; constructor()
T2 -&gt; constructor()
T3 -&gt; constructor()
zacatek bloku try
T3 -&gt; close()
T1 -&gt; close()
java.lang.ArrayIndexOutOfBoundsException: 0
	at CloseTest7.main(CloseTest7.java:37)
	Suppressed: java.lang.RuntimeException: T2 object throws exception!
		at T.close(CloseTest7.java:20)
		at CloseTest7.main(CloseTest7.java:42)
blok finally
</pre>

<p>Metody <strong>close()</strong> se tedy zavolají a teprve
<strong>poté</strong> je vyvolána pùvodní výjimka (a navíc té¾ výjimka vyhozená
jednou z&nbsp;metod <strong>close</strong>). Toto chování nás v¹ak vyjde
pomìrnì &bdquo;draho&ldquo;, alespoò co se týká objemu vygenerovaného bajtkódu,
kde jsou explicitnì zpracovány v¹echny mo¾né eventuality. Postaèuje se podívat,
kolikrát a za jakých podmínek jsou volány jednotlivé metody
<strong>close()</strong>:</p>

<pre>
Compiled from "CloseTest6.java"
public class CloseTest6 extends java.lang.Object {
  public CloseTest6();
    Code:
       0: aload_0       
       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V
       4: return        

  public static void main(java.lang.String[]);
    Code:
       0: new           #2                  // class T
       3: dup           
       4: ldc           #3                  // String T1
       6: invokespecial #4                  // Method T."&lt;init&gt;":(Ljava/lang/String;)V
       9: astore_1      
      10: aconst_null   
      11: astore_2      
      12: new           #2                  // class T
      15: dup           
      16: ldc           #5                  // String T2
      18: invokespecial #4                  // Method T."&lt;init&gt;":(Ljava/lang/String;)V
      21: astore_3      
      22: aconst_null   
      23: astore        4
      25: new           #2                  // class T
      28: dup           
      29: ldc           #6                  // String T3
      31: invokespecial #4                  // Method T."&lt;init&gt;":(Ljava/lang/String;)V
      34: astore        5
      36: aconst_null   
      37: astore        6
      39: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;
      42: ldc           #8                  // String zacatek bloku try
      44: invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      47: aload_0       
      48: iconst_0      
      49: aaload        
      50: invokestatic  #10                 // Method java/lang/Integer.parseInt:(Ljava/lang/String;)I
      53: istore        7
      55: aload_1       
      56: invokevirtual #11                 // Method T.doSomething:()V
      59: aload_3       
      60: invokevirtual #11                 // Method T.doSomething:()V
      63: aload         5
      65: invokevirtual #11                 // Method T.doSomething:()V
      68: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;
      71: ldc           #12                 // String konec bloku try
      73: invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      76: aload         6
      78: ifnull        101
      81: aload         5
      83: invokevirtual #13                 // Method T.close:()V
      86: goto          153
      89: astore        7
      91: aload         6
      93: aload         7
      95: invokevirtual #15                 // Method java/lang/Throwable.addSuppressedException:(Ljava/lang/Throwable;)V
      98: goto          153
     101: aload         5
     103: invokevirtual #13                 // Method T.close:()V
     106: goto          153
     109: astore        7
     111: aload         7
     113: astore        6
     115: aload         7
     117: athrow        
     118: astore        8
     120: aload         6
     122: ifnull        145
     125: aload         5
     127: invokevirtual #13                 // Method T.close:()V
     130: goto          150
     133: astore        9
     135: aload         6
     137: aload         9
     139: invokevirtual #15                 // Method java/lang/Throwable.addSuppressedException:(Ljava/lang/Throwable;)V
     142: goto          150
     145: aload         5
     147: invokevirtual #13                 // Method T.close:()V
     150: aload         8
     152: athrow        
     153: aload         4
     155: ifnull        177
     158: aload_3       
     159: invokevirtual #13                 // Method T.close:()V
     162: goto          226
     165: astore        5
     167: aload         4
     169: aload         5
     171: invokevirtual #15                 // Method java/lang/Throwable.addSuppressedException:(Ljava/lang/Throwable;)V
     174: goto          226
     177: aload_3       
     178: invokevirtual #13                 // Method T.close:()V
     181: goto          226
     184: astore        5
     186: aload         5
     188: astore        4
     190: aload         5
     192: athrow        
     193: astore        10
     195: aload         4
     197: ifnull        219
     200: aload_3       
     201: invokevirtual #13                 // Method T.close:()V
     204: goto          223
     207: astore        11
     209: aload         4
     211: aload         11
     213: invokevirtual #15                 // Method java/lang/Throwable.addSuppressedException:(Ljava/lang/Throwable;)V
     216: goto          223
     219: aload_3       
     220: invokevirtual #13                 // Method T.close:()V
     223: aload         10
     225: athrow        
     226: aload_2       
     227: ifnull        246
     230: aload_1       
     231: invokevirtual #13                 // Method T.close:()V
     234: goto          289
     237: astore_3      
     238: aload_2       
     239: aload_3       
     240: invokevirtual #15                 // Method java/lang/Throwable.addSuppressedException:(Ljava/lang/Throwable;)V
     243: goto          289
     246: aload_1       
     247: invokevirtual #13                 // Method T.close:()V
     250: goto          289
     253: astore_3      
     254: aload_3       
     255: astore_2      
     256: aload_3       
     257: athrow        
     258: astore        12
     260: aload_2       
     261: ifnull        282
     264: aload_1       
     265: invokevirtual #13                 // Method T.close:()V
     268: goto          286
     271: astore        13
     273: aload_2       
     274: aload         13
     276: invokevirtual #15                 // Method java/lang/Throwable.addSuppressedException:(Ljava/lang/Throwable;)V
     279: goto          286
     282: aload_1       
     283: invokevirtual #13                 // Method T.close:()V
     286: aload         12
     288: athrow        
     289: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;
     292: ldc           #16                 // String blok finally
     294: invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
     297: goto          329
     300: astore_1      
     301: aload_1       
     302: invokevirtual #18                 // Method java/lang/RuntimeException.printStackTrace:()V
     305: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;
     308: ldc           #16                 // String blok finally
     310: invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
     313: goto          329
     316: astore        14
     318: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;
     321: ldc           #16                 // String blok finally
     323: invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
     326: aload         14
     328: athrow        
     329: return        
    Exception table:
       from    to  target type
          81    86    89   Class java/lang/Throwable
          39    76   109   Class java/lang/Throwable
          39    76   118   any
         125   130   133   Class java/lang/Throwable
         109   120   118   any
         158   162   165   Class java/lang/Throwable
          25   153   184   Class java/lang/Throwable
          25   153   193   any
         200   204   207   Class java/lang/Throwable
         184   195   193   any
         230   234   237   Class java/lang/Throwable
          12   226   253   Class java/lang/Throwable
          12   226   258   any
         264   268   271   Class java/lang/Throwable
         253   260   258   any
           0   289   300   Class java/lang/RuntimeException
           0   289   316   any
         300   305   316   any
         316   318   316   any
}
</pre>

<p>Na nové syntaxi a sémantice bloku <strong>try-catch-finally</strong> je
zajímavá dal¹í vìc, která pravdìpodobnì usnadní (èi by alespoò mìla usnadnit)
tvorbu korektních programù v&nbsp;Javì pøedev¹ím zaèáteèníkùm a takté¾
programátorùm, kteøí døíve pou¾ívali rùzné skriptovací jazyky. Blok
<strong>try</strong> s&nbsp;deklaraèní a výkonnou èástí je toti¾ pouze
&bdquo;vsunut&ldquo; mezi pùvodní programový kód, co¾ mj.&nbsp;znamená, ¾e
v&nbsp;bì¾ných podmínkách není nutné pøidávat ¾ádné dal¹í pøíkazy ani mìnit
poøadí pøíkazù. Programátor se tedy mù¾e soustøedit pøedev¹ím na vytvoøení
aplikaèní logiky, která nebude &ndash; pokud to samozøejmì nebude nutné &ndash;
zamoøena explicitnì rozepsaným voláním metod <strong>close()</strong> a
zachytáváním výjimek, které mohou pøi volání tìchto metod nastat. Tuto situaci
si mù¾eme ukázat na velmi jednoduchém pøíkladu, v&nbsp;nìm¾ je do aplikaèní
logiky (v&nbsp;tomto pøípadì kopie dat) pouze &bdquo;vsunut&ldquo; blok
<strong>try</strong> s&nbsp;deklaraèní i výkonnou èástí. Nejprve si vypí¹eme
vlastní logiku tak, jak ji programátor zamý¹lel implementovat:</p>

<pre>
InputStream  input = new FileInputStream(source);
OutputStream output = new FileOutputStream(destination);
byte[] buffer = new byte[8192];
int n;
while ((n = input.read(buffer)) &gt;= 0)
{
    output.write(buffer, 0, n);
}
</pre>

<p>Pou¾itím bloku <strong>try(){}</strong> se zajistí uzavøení jak vstupního,
tak i výstupního proudu, a to nezávisle na tom, jestli dojde pøi operaci
<strong>input.read()</strong> nebo <strong>output.write()</strong>
k&nbsp;nìjaké chybì, která je samozøejmì pøi práci se soubory pomìrnì èastá,
zejména v&nbsp;pøípadech, kdy je vstupní soubor zadáván u¾ivatelem nebo se
jedná o soubor kopírovaný ze sítì:</p>

<pre>
try(
    InputStream  input = new FileInputStream(source);
    OutputStream output = new FileOutputStream(destination)
)
{
    byte[] buffer = new byte[8192];
    int n;
    while ((n = input.read(buffer)) &gt;= 0)
    {
        output.write(buffer, 0, n);
    }
}
</pre>



<p><a name="k08"></a></p>
<h2>8. Vliv existence automatické správy prostøedkù na stávající aplikace</h2>

<p>V&nbsp;souvislosti s&nbsp;roz¹íøením mo¾ností bloku
<strong>try-catch-finally</strong> o (polo)automatickou správu objektù
implementujících rozhraní <strong>AutoCloseable</strong> v&nbsp;<i>JDK 7</i>
samozøejmì programátory vìt¹ích aplikací napadne, jakým zpùsobem toto nové
chování ovlivní jejich stávající a mnoha roky provozu otestované aplikace.
V&nbsp;tomto pøípadì je odpovìï pomìrnì jednoduchá &ndash; pokud není nový
objekt vytvoøen v&nbsp;deklaraèní èásti bloku <strong>try</strong>,
tj.&nbsp;v&nbsp;kulatých závorkách, chová se stejnì jako v&nbsp;pøedchozích
verzích <i>JDK 5</i> a <i>JDK 6</i>, tak¾e stávající zdrojové kódy není
zapotøebí mìnit (ostatnì pøekvapivé mno¾ství zdrojových kódù dodnes ani
nevyu¾ívá mo¾ností zavedených v&nbsp;<i>JDK 5</i>). Naopak pøidání této podpory
pro vlastní tøídy je velmi jednoduché &ndash; ke tøídì implementující rozhraní
<strong>Closeable</strong> (a tím pádem i metodu <strong>close</strong>)
postaèuje pøidat dal¹í rozhraní <strong>AutoCloseable</strong>. Nic dal¹ího
není vìt¹inou zapotøebí.</p>

<p>Pro zji¹tìní, které tøídy jsou vhodnými &bdquo;kandidáty&ldquo; pro
implementaci rozhraní <strong>AutoCloseable</strong>, je mo¾né vyu¾ít napøíklad
jednoduchou utilitku <i>Joea Darcyho</i> z&nbsp;firmy <i>Oracle</i>, která je
dostupná na adrese <a
href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>.
V&nbsp;souvislosti se zavedením rozhraní <strong>AutoCloseable</strong>
v&nbsp;<i>JDK 7</i> do¹lo i k&nbsp;úpravì velkého mno¾ství tøíd ze standardních
knihoven takovým zpùsobem, aby kromì rozhraní <strong>Closeable</strong>
implementovaly i rozhraní <strong>AutoCloseable</strong>. Jedná se o tøídy
pracující se soubory, sockety, obsahem archivù, databázemi atd. Pro ilustraci
jsou v&nbsp;následujícím seznamu uvedeny v¹echny tøídy, které v&nbsp;<i>JDK
7</i> nové rozhraní <strong>AutoCloseable</strong> implementují,
tj.&nbsp;tøídy, s&nbsp;jejich¾ instancemi je mo¾né pracovat zjednodu¹eným
zpùsobem &ndash; bez explicitního volání metod <strong>close()</strong>:</p>

<pre>
AbstractInterruptibleChannel, AbstractSelectableChannel,
AbstractSelector, AsynchronousFileChannel,
AsynchronousServerSocketChannel, AsynchronousSocketChannel,
AudioInputStream, BufferedInputStream, BufferedOutputStream,
BufferedReader, BufferedWriter, ByteArrayInputStream,
ByteArrayOutputStream, CharArrayReader, CharArrayWriter,
CheckedInputStream, CheckedOutputStream, CipherInputStream,
CipherOutputStream, DatagramChannel, DatagramSocket, DataInputStream,
DataOutputStream, DeflaterInputStream, DeflaterOutputStream,
DigestInputStream, DigestOutputStream, FileCacheImageInputStream,
FileCacheImageOutputStream, FileChannel, FileImageInputStream,
FileImageOutputStream, FileInputStream, FileLock, FileOutputStream,
FileReader, FileSystem, FileWriter, FilterInputStream,
FilterOutputStream, FilterReader, FilterWriter, Formatter,
ForwardingJavaFileManager, GZIPInputStream, GZIPOutputStream,
ImageInputStreamImpl, ImageOutputStreamImpl, InflaterInputStream,
InflaterOutputStream, InputStream, InputStream, InputStream,
InputStreamReader, JarFile, JarInputStream, JarOutputStream,
LineNumberInputStream, LineNumberReader, LogStream,
MemoryCacheImageInputStream, MemoryCacheImageOutputStream, MLet,
MulticastSocket, ObjectInputStream, ObjectOutputStream, OutputStream,
OutputStream, OutputStream, OutputStreamWriter, Pipe.SinkChannel,
Pipe.SourceChannel, PipedInputStream, PipedOutputStream, PipedReader,
PipedWriter, PrintStream, PrintWriter, PrivateMLet,
ProgressMonitorInputStream, PushbackInputStream, PushbackReader,
RandomAccessFile, Reader, RMIConnectionImpl, RMIConnectionImpl_Stub,
RMIConnector, RMIIIOPServerImpl, RMIJRMPServerImpl, RMIServerImpl,
Scanner, SecureDirectoryStream, SelectableChannel, Selector,
SequenceInputStream, ServerSocket, ServerSocketChannel, Socket,
SocketChannel, SSLServerSocket, SSLSocket, StringBufferInputStream,
StringReader, StringWriter, URLClassLoader, WatchService, Writer,
XMLDecoder, XMLEncoder, ZipFile, ZipInputStream, ZipOutputStream
</pre>



<p><a name="k09"></a></p>
<h2>9. Odkazy na Internetu</h2>

<ol>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>ClosableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>ArrayList (JDK 1.4)<br />
<a href="http://download.oracle.com/javase/1.4.2/docs/api/java/util/ArrayList.html">http://download.oracle.com/javase/1.4.2/docs/api/java/util/ArrayList.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2010</small></p>
</body>
</html>

