<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - závìreèné porovnání JVM, Lua VM a Python VM (1/2)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - závìreèné porovnání JVM, Lua VM a Python VM (1/2)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu (nejenom) o programovacím jazyku Java a JVM bude provedeno závìreèné porovnání trojice virtuálních strojù: JVM, Lua VM a Python VM. Zamìøíme se pøedev¹ím na porovnání struktury bajtkódu, pøesnìji øeèeno instrukèní sady v¹ech tøí porovnávaných virtuálních strojù.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - závìreèné porovnání JVM, Lua VM a Python VM (1/2)</a></p>
<p><a href="#k011">&nbsp;&nbsp;1.1 JVM</a></p>
<p><a href="#k012">&nbsp;&nbsp;1.2 Lua VM</a></p>
<p><a href="#k013">&nbsp;&nbsp;1.3 Python VM</a></p>
<p><a href="#k02">2. Základní porovnání bajtkódù v¹ech tøí virtuálních strojù</a></p>
<p><a href="#k03">3. Aritmetické operace</a></p>
<p><a href="#k031">&nbsp;&nbsp;3.1 JVM</a></p>
<p><a href="#k032">&nbsp;&nbsp;3.2 Lua VM</a></p>
<p><a href="#k033">&nbsp;&nbsp;3.3 Python VM</a></p>
<p><a href="#k04">4. Logické operace</a></p>
<p><a href="#k041">&nbsp;&nbsp;4.1 JVM</a></p>
<p><a href="#k042">&nbsp;&nbsp;4.2 Lua VM</a></p>
<p><a href="#k043">&nbsp;&nbsp;4.3 Python VM</a></p>
<p><a href="#k05">5. Aritmetické a bitové posuny</a></p>
<p><a href="#k051">&nbsp;&nbsp;5.1 JVM</a></p>
<p><a href="#k052">&nbsp;&nbsp;5.2 Lua VM</a></p>
<p><a href="#k053">&nbsp;&nbsp;5.3 Python VM</a></p>
<p><a href="#k06">6. Konverze mezi základními datovými typy</a></p>
<p><a href="#k07">7. Instrukce pro operace s&nbsp;registry popø.&nbsp;zásobníkem operandù</a></p>
<p><a href="#k071">&nbsp;&nbsp;7.1 JVM</a></p>
<p><a href="#k072">&nbsp;&nbsp;7.2 Lua VM</a></p>
<p><a href="#k073">&nbsp;&nbsp;7.3 Python VM</a></p>
<p><a href="#k08">8. Podmínìné a nepodmínìné skoky, vìtvení kódu</a></p>
<p><a href="#k081">&nbsp;&nbsp;8.1 JVM</a></p>
<p><a href="#k082">&nbsp;&nbsp;8.2 Lua VM</a></p>
<p><a href="#k083">&nbsp;&nbsp;8.3 Python VM</a></p>
<p><a href="#k09">9. Obsah následující èásti seriálu</a></p>
<p><a href="#k10">10. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - závìreèné porovnání JVM, Lua VM a Python VM (1/2)</h2>

<p>V&nbsp;dne¹ní a takté¾ i navazující èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o JVM
i o dal¹ích dvou virtuálních strojích</a> bude provedeno závìreèné porovnání
vlastností a mo¾ností trojice virtuálních strojù, tj.&nbsp;JVM, Lua VM i Python
VM. Kromì obecného porovnání tìchto tøí virtuálních strojù se zamìøíme i na
vzájemné srovnání struktury bajtkódu, pøesnìji øeèeno instrukèní sady v¹ech tøí
porovnávaných VM. Následuje shrnutí základních vlastností virtuálního stroje
Javy, virtuálního stroje jazyka Lua a koneènì i virtuálního stroje Pythonu
(CPythonu):</p>



<p><a name="k011"></a></p>
<h3>1.1 JVM</h3>

<p>První typ bajtkódu je bajtkód vyu¾ívaný JVM. Virtuální stroj jazyka Java
samozøejmì vyu¾ívá jiný soubor &bdquo;strojových&ldquo; instrukcí ne¾ fyzický
mikroprocesor, na nìm¾ jsou Javovské programy spou¹tìny. Dokonce ani
mikroprocesory urèené pro pøímé spou¹tìní bajtkódu &ndash; dnes ji¾ zpola
zapomenuté projekty <i>MicroJava</i> a <i>PicoJava</i>, dokonce i ARM procesory
s&nbsp;technologií <i>Jazelle</i> &ndash; nedokázaly nativnì vykonávat v¹echny
instrukce bajtkódu. V&nbsp;prvních nìkolika letech existence Javy byly
instrukce bajtkódu (tvoøící tìla jednotlivých metod) v&nbsp;naprosté vìt¹inì
pøípadù pouze interpretovány, a to mnohdy velmi jednoduchým zpùsobem:
v&nbsp;programové smyèce se postupnì naèítaly kódy jednotlivých instrukcí a
následnì se pro ka¾dou instrukci zavolala nativní funkce, která danou instrukci
vykonala, vìt¹inou s&nbsp;parametry ulo¾enými v&nbsp;zásobníkovém rámci nebo
v&nbsp;zásobníku operandù.</p>

<p>Virtuální stroj jazyka Java obsahuje instrukce, které pracují
s&nbsp;operandy nìkolika datových typù. Na rozdíl od mnoha fyzických procesorù
se v&nbsp;pøípadì JVM provádí kontroly, zda jsou operace skuteènì aplikovány na
správné operandy. Není napøíklad mo¾né, aby se operace souètu provádìla
s&nbsp;jedním operandem typu <strong>int</strong> a druhým operandem typu
<strong>long</strong> &ndash; takový bajtkód by byl pøi svém naèítání odmítnut
a vùbec by nebyl spu¹tìn (to v¹ak jinými slovy znamená, ¾e bajtkód je zbyteènì
redundantní, zejména v&nbsp;porovnání s&nbsp;bajtkódy jazykù Lua a Python).
Zajímavé je, ¾e jen velmi málo instrukcí JVM podporuje práci s&nbsp;datovými
typy <strong>boolean</strong>, <strong>byte</strong>, <strong>short</strong> a
<strong>char</strong>. Promìnné a parametry metod tìchto typù musí být
napøíklad pøed provedením nìkteré aritmetické operace nejprve pøevedeny na typ
<strong>int</strong> pomocí konverzních instrukcí (tìch existuje celkem
patnáct).</p>

<p>Vìt¹ina instrukcí virtuálního stroje Javy pracuje s&nbsp;operandy ulo¾enými
na takzvaném <i>zásobníku operandù (operand stack)</i>. Zásobník operandù
(v&nbsp;tomto pøípadì se ji¾ jedná o skuteèný zásobník typu <i>LIFO &ndash;
Last In, First Out</i>) je vytváøen v&nbsp;èase bìhu aplikace pro ka¾dou
zavolanou metodu, co¾ mj.&nbsp;znamená, ¾e je pøi spu¹tìní metody v¾dy prázdný
(zásobník operandù je podle specifikace souèástí zásobníkového rámce, jeho
konkrétní umístìní v¹ak je libovolné). Ji¾ v&nbsp;èase pøekladu zdrojového kódu
je pro ka¾dou metodu zji¹tìno, jak velká oblast pamìti má být pro zásobník
operandù vyhrazena a samozøejmì je provádìna kontrola, zda se v&nbsp;dobì bìhu
aplikace tato velikost nepøekroèí (to by se nemìlo u validního bajtkódu
stát).</p>

<p>Virtuální stroj Javy kontroluje typy operandù ulo¾ených na zásobník operandù
a zaji¹»uje, ¾e se nad tìmito operandy budou provádìt pouze typovì bezpeèné
operace. V&nbsp;praxi to napøíklad znamená, ¾e není mo¾né na zásobník ulo¾it
dvì hodnoty typu <strong>float</strong> a následnì provést instrukci
<strong>iadd</strong>, proto¾e tato instrukce vy¾aduje, aby na zásobníku byly
ulo¾eny dvì hodnoty typu <strong>int</strong> (i kdy¾ <strong>float</strong> i
<strong>int</strong> mají shodnou bitovou ¹íøku).</p>



<p><a name="k012"></a></p>
<h3>1.2 Lua VM</h3>

<p>Bajtkód programovacího jazyka Lua se v&nbsp;mnoha ohledech odli¹uje od
bajtkódu JVM. Pravdìpodobnì nejnápadnìj¹ím rozdílem mezi bajtkódem JVM a
bajtkódem jazyka Lua je fakt, ¾e se v&nbsp;Lua VM nepou¾ívá zásobník operandù,
proto¾e indexy operandù jsou pøímo souèástí instrukèního slova. I formát
instrukèních kódù je od JVM velmi odli¹ný, proto¾e zatímco v&nbsp;pøípadì
bajtkódu JVM je kód instrukce ulo¾en v&nbsp;celém bajtu (s&nbsp;nìkolika málo
výjimkami), je u Lua VM kód instrukce ulo¾en v&nbsp;pouhých ¹esti bitech,
zatímco zbylých 26 bitù instrukèního slova je rezervováno pro ulo¾ení indexù
operandù èi konstant. Bajtkód Lua VM takté¾ obsahuje spí¹e vysokoúrovòové
instrukce, které dobøe reflektují vlastnosti tohoto programovacího jazyka.
Existují napøíklad instrukce pro implementaci programové smyèky
<strong>for</strong>, instrukce pro práci s&nbsp;(asociativními) poli tvoøícími
nejdùle¾itìj¹í strukturovaný datový typ jazyka Lua a dokonce se v&nbsp;bajtkódu
nachází instrukce pro vytvoøení uzávìru (<i>closure</i>) a pro tail call.</p>

<p>Instrukce mohou mít jeden z&nbsp;následujících formátù:</p>

<h3>iABC</h3>

<table>
<tr><th>#</th><th>Oznaèení</th><th>Délka bitového pole</th><th>Význam</th></tr>
<tr><td>1</td><td>i</td><td>6</td><td>kód instrukce</td></tr>
<tr><td>2</td><td>A</td><td>8</td><td>index èi hodnota prvního operandu</td></tr>
<tr><td>3</td><td>B</td><td>9</td><td>index èi hodnota druhého operandu</td></tr>
<tr><td>4</td><td>C</td><td>9</td><td>index èi hodnota tøetího operandu</td></tr>
</table>

<h3>iABx</h3>

<table>
<tr><th>#</th><th>Oznaèení</th><th>Délka bitového pole</th><th>Význam</th></tr>
<tr><td>1</td><td>i</td><td>6</td><td>kód instrukce</td></tr>
<tr><td>2</td><td>A</td><td>8</td><td>index èi hodnota prvního operandu</td></tr>
<tr><td>3</td><td>Bx</td><td>18</td><td>index èi hodnota druhého operandu</td></tr>
</table>

<h3>iAsBx</h3>

<table>
<tr><th>#</th><th>Oznaèení</th><th>Délka bitového pole</th><th>Význam</th></tr>
<tr><td>1</td><td>i</td><td>6</td><td>kód instrukce</td></tr>
<tr><td>2</td><td>A</td><td>8</td><td>index èi hodnota prvního operandu</td></tr>
<tr><td>3</td><td>sBx</td><td>18</td><td>index èi hodnota druhého operandu (zde se znaménkem)</td></tr>
</table>

<h3>iAx</h3>

<table>
<tr><th>#</th><th>Oznaèení</th><th>Délka bitového pole</th><th>Význam</th></tr>
<tr><td>1</td><td>i</td><td>6</td><td>kód instrukce</td></tr>
<tr><td>2</td><td>Ax</td><td>26</td><td>index èi hodnota prvního (jediného) operandu</td></tr>
</table>



<p><a name="k013"></a></p>
<h3>1.3 Python VM</h3>

<p>Posledním v&nbsp;souèasnosti pou¾ívaným bajtkódem, o nìm¾ se v&nbsp;dne¹ním
èlánku zmíníme, je bajtkód vyu¾ívaný programovacím jazykem Python, konkrétnì
jeho pùvodní verzí CPython (kromì tohoto bajtkódu lze najít i dal¹í bajtkódy
Pythonu urèené pro jiné VM, napøíklad Mamba atd.). Ji¾ <a
href="#k011">v&nbsp;pøedchozí podkapitole</a> jsme si øekli, ¾e bajtkód JVM je
pomìrnì nízkoúrovòový, zejména v&nbsp;porovnání s&nbsp;bajtkódem pou¾ívaným
v&nbsp;programovacím jazyku Lua (resp.&nbsp;pøesnìji øeèeno virtuálním strojem
tohoto jazyka). Toté¾ platí, a to dokonce je¹tì ve vìt¹í míøe, i pro bajtkód
jazyka Python. Ten je opìt zalo¾en na zásobníku operandù, ov¹em mnohé instrukce
pracující s&nbsp;jedním èi dvìma operandy (samozøejmì ulo¾enými na zásobníku)
ve skuteènosti mohou volat metody objektù a nikoli pouze provádìt operace nad
primitivními datovými typy. Platí to pøedev¹ím pro v¹echny
&bdquo;aritmetické&ldquo; operace, napøíklad i pro operátor +, který se
pøekládá do instrukce <strong>BINARY_ADD</strong>.</p>

<p>To napøíklad znamená, ¾e se jednoduchá funkce <strong>add()</strong> se
dvìma operandy:</p>

<pre>
def <strong>add</strong>(x, y):
    return x+y
</pre>

<p>pøelo¾í do následující ètveøice instrukcí bajtkódu:</p>

<pre>
<strong>add</strong>:
 28           0 LOAD_FAST                0 (x)
              3 LOAD_FAST                1 (y)
              6 BINARY_ADD          
              7 RETURN_VALUE        
</pre>

<p>Tuto funkci lze ov¹em volat jak s&nbsp;èíselnými parametry, tak i
s&nbsp;øetìzci, n-ticemi, seznamy èi objekty s&nbsp;implementovanou metodou
<strong>__add__</strong>, tak¾e instrukce <strong>BINARY_ADD</strong> není
zcela porovnatelná napøíklad s&nbsp;JVM instrukcemi <strong>iadd</strong>,
<strong>ladd</strong> atd. operujícími pouze nad konkrétním primitivním datovým
typem.:</p>

<pre>
    print(add(1, 2))
    print(add(1., 2))
    print(add("Hello ", "world!"))
    print(add([1,2,3], [4,5,6]))
    print(add((1,2,3), (4,5,6)))
</pre>

<p>Kromì toho mù¾e bajtkód Pythonu obsahovat i instrukce pro snaz¹í tvorbu
smyèek (<strong>BREAK_LOOP</strong>, <strong>CONTINUE_LOOP</strong>) i pro
práci s&nbsp;kolekcemi (<strong>LIST_APPEND</strong>, <strong>MAP_ADD</strong>,
<strong>BUILD_SLICE</strong> apod).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Základní porovnání bajtkódù v¹ech tøí virtuálních strojù</h2>

<p>Tøi nejdùle¾itìj¹í spoleèné vlastnosti ale i rozdíly mezi trojicí
popisovaných virtuálních strojù jsou vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Vlastnost</th><th>JVM</th><th>Lua VM</th><th>Python VM</th></tr>
<tr><td>1</td><td>Typ VM</td><td>zásobníkový</td><td>registrový</td><td>zásobníkový</td></tr>
<tr><td>2</td><td>Typový systém VM</td><td>striktní</td><td>dynamický</td><td>dynamický</td></tr>
<tr><td>3</td><td>Výjimky v bajtkódu</td><td>ano</td><td>ne</td><td>ano</td></tr>
</table>

<p>Typ VM má velký vliv jak na zpùsob implementace v¹ech aritmetických a
logických operací, tak i na zpùsob pøedávání parametrù volaným funkcím èi
metodám. Typový systém takté¾ do znaèné míry ovlivòuje vlastnost VM i bajtkódu
&ndash; existenci konverzních instrukcí, mo¾nost pou¾ití jedné instrukce pro
vìt¹í mno¾ství datových typù atd. Podpora výjimek v&nbsp;bajtkódu do znaèné
míry ovlivòuje i syntaxi programovacího jazyka postaveného nad danou VM. Ve
druhé tabulce jsou vypsány dal¹í dùle¾ité vlastnosti popisovaných VM:</p>

<table>
<tr><th> #</th><th>Vlastnost</th><th>JVM</th><th>Lua VM</th><th>Python VM</th></tr>
<tr><td> 1</td><td>Skoky</td><td>v rámci metody</td><td>v rámci funkce</td><td>v rámci funkce</td></tr>
<tr><td> 2</td><td>Aritmetické instrukce</td><td>ano</td><td>ano</td><td>ano</td></tr>
<tr><td> 3</td><td>Logické instrukce</td><td>ano</td><td>èásteènì</td><td>ano</td></tr>
<tr><td> 4</td><td>Bitové instrukce</td><td>ano</td><td>èásteènì</td><td>ano</td></tr>
<tr><td> 5</td><td>Bitové posuny a rotace</td><td>ano</td><td>ne</td><td>ano</td></tr>
<tr><td> 6</td><td>Pøetí¾ení operátorù ve VM</td><td>ne</td><td>ne</td><td>ano</td></tr>
<tr><td> 7</td><td>Konverzní instrukce</td><td>ano</td><td>ne</td><td>ne</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>Programové smyèky</td><td>øe¹eno skoky</td><td>speciální instrukce</td><td>speciální instrukce</td></tr>
<tr><td> 9</td><td>Synchronizaèní instrukce</td><td>ano</td><td>ne</td><td>ne</td></tr>
<tr><td>10</td><td>Strukturované datové typy</td><td>pole</td><td>tabulky</td><td>seznamy+n-tice</td></tr>
<tr><td>11</td><td>Výjimky v bajtkódu</td><td>ano</td><td>ne</td><td>ano</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>12</td><td>Podpora pro volání funkcí v bajtkódu</td><td>ne</td><td>ano</td><td>ano</td></tr>
<tr><td>13</td><td>Podpora pro volání metod v bajtkódu</td><td>ano</td><td>ano</td><td>ano</td></tr>
<tr><td>14</td><td>Volání statických metod v bajtkódu</td><td>ano</td><td>ano</td><td>èásteènì</td></tr>
<tr><td>15</td><td>Kontrola poètu parametrù pøi pøekladu</td><td>ano</td><td>ne</td><td>v závislosti na deklaraci</td></tr>
<tr><td>16</td><td>Kontrola poètu parametrù pøi naèítání/bìhu</td><td>ano</td><td>ne</td><td>ano</td></tr>
<tr><td>17</td><td>Pøedávání dat do funkcí</td><td>pøes zásobník</td><td>pøes registry</td><td>pøes zásobník</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>Podpora deklarace typu parametrù pøi pøekladu</td><td>ano</td><td>ne</td><td>ne</td></tr>
<tr><td>19</td><td>Podpora kontroly typu parametrù pøi pøekladu</td><td>ano</td><td>ne</td><td>ne</td></tr>
<tr><td>20</td><td>Podpora promìnného poètu parametrù</td><td>ano</td><td>ano</td><td>ano</td></tr>
<tr><td>21</td><td>Podpora pojmenovaných parametrù</td><td>ne</td><td>ne</td><td>ano</td></tr>
<tr><td>22</td><td>Podpora promìnného poètu návratových hodnot</td><td>ne</td><td>ano</td><td>nepøímo</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>23</td><td>Funkce je plnohodnotný datový typ</td><td>Ne pro Javu&lt;=7</td><td>ano</td><td>ano</td></tr>
<tr><td>24</td><td>Podpora uzávìrù (closures)</td><td>Ne pro Javu&lt;=7</td><td>ano</td><td>ano</td></tr>
</table>

<p>V&nbsp;následujících sedmi kapitolách si popí¹eme zpùsob implementace
rùzných operací v&nbsp;bajtkódech JVM, Lua VM i Python VM. Uvidíme, ¾e nìkteré
operace jsou provádìny podobným zpùsobem, ov¹em mnohé dal¹í operace &ndash;
napøíklad zpùsob implementace programových smyèek &ndash; se mnohdy zásadním
zpùsobem odli¹uje.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Aritmetické operace</h2>

<p>Zaènìme popisem aritmetických instrukcí, které jsou velmi jednoduché a
snadno pochopitelné.</p>

<p><a name="k031"></a></p>
<h3>3.1 JVM</h3>

<p>V&nbsp;pøípadì JVM se vìt¹inou jedná o instrukce pracující
s&nbsp;dvojicí operandù ulo¾ených na zásobníku operandù, Tyto instrukce slou¾í
pro implementaci pìti základních (binárních) aritmetických operací &ndash;
souètu, rozdílu, souèinu, podílu a výpoètu zbytku po dìlení. Vzhledem
k&nbsp;tomu, ¾e ka¾dá tato operace existuje ve ètyøech variantách pro datové
typy <strong>int</strong>, <strong>long</strong>, <strong>float</strong> a
<strong>double</strong>, jsou binární aritmetické operace implementovány
dvaceti instrukcemi. Dal¹í ètyøi instrukce &ndash; zmìna znaménka &ndash; v¹ak
pracují pouze s&nbsp;jedním operandem. Virtuální stroj Javy v&nbsp;èase bìhu
aplikace nebo v&nbsp;èase verifikace bajtkódu testuje, zda se v¹echny
aritmetické operace provádí se správným typem operandù. Pov¹imnìte si, ¾e
instrukèní soubor JVM neobsahuje ¾ádné aritmetické operace pro operandy typu
<strong>byte</strong>, <strong>short</strong> èi <strong>char</strong> &ndash;
operandy tìchto typù jsou v¾dy pøevedeny na <strong>int</strong>. Navíc se u
celoèíselných operací netestuje pøeteèení, co¾ je mo¾ná u vysokoúrovòového
jazyka ponìkud pøekvapující (ono je ostatnì pøi ponìkud jednostranném pohledu
pøekvapující i to, ¾e Java vùbec obsahuje primitivní datové typy :-):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operand 1</th><th>Operand 2</th><th>Operace</th><th>Poznámka</th></tr>
<tr><td> 1</td><td>iadd</td><td>0x60</td><td>int   </td><td>int   </td><td>souèet</td><td>oba pùvodní operandy jsou ze zásobníku operandù odstranìny</td></tr>
<tr><td> 2</td><td>ladd</td><td>0x61</td><td>long  </td><td>long  </td><td>souèet</td><td>-//-</td></tr>
<tr><td> 3</td><td>fadd</td><td>0x62</td><td>float </td><td>float </td><td>souèet</td><td>-//-</td></tr>
<tr><td> 4</td><td>dadd</td><td>0x63</td><td>double</td><td>double</td><td>souèet</td><td>-//-</td></tr>
<tr><td> 5</td><td>isub</td><td>0x64</td><td>int   </td><td>int   </td><td>rozdíl</td><td>-//-</td></tr>
<tr><td> 6</td><td>lsub</td><td>0x65</td><td>long  </td><td>long  </td><td>rozdíl</td><td>-//-</td></tr>
<tr><td> 7</td><td>fsub</td><td>0x66</td><td>float </td><td>float </td><td>rozdíl</td><td>-//-</td></tr>
<tr><td> 8</td><td>dsub</td><td>0x67</td><td>double</td><td>double</td><td>rozdíl</td><td>-//-</td></tr>
<tr><td> 9</td><td>imul</td><td>0x68</td><td>int   </td><td>int   </td><td>souèin</td><td>-//-</td></tr>
<tr><td>10</td><td>lmul</td><td>0x69</td><td>long  </td><td>long  </td><td>souèin</td><td>-//-</td></tr>
<tr><td>11</td><td>fmul</td><td>0x6A</td><td>float </td><td>float </td><td>souèin</td><td>-//-</td></tr>
<tr><td>12</td><td>dmul</td><td>0x6B</td><td>double</td><td>double</td><td>souèin</td><td>-//-</td></tr>
<tr><td>13</td><td>idiv</td><td>0x6C</td><td>int   </td><td>int   </td><td>podíl</td><td>-//-</td></tr>
<tr><td>14</td><td>ldiv</td><td>0x6D</td><td>long  </td><td>long  </td><td>podíl</td><td>-//-</td></tr>
<tr><td>15</td><td>fdiv</td><td>0x6E</td><td>float </td><td>float </td><td>podíl</td><td>-//-</td></tr>
<tr><td>16</td><td>ddiv</td><td>0x6F</td><td>double</td><td>double</td><td>podíl</td><td>-//-</td></tr>
<tr><td>17</td><td>irem</td><td>0x70</td><td>int   </td><td>int   </td><td>zbytek po dìlení</td><td>-//-</td></tr>
<tr><td>18</td><td>lrem</td><td>0x71</td><td>long  </td><td>long  </td><td>zbytek po dìlení</td><td>-//-</td></tr>
<tr><td>19</td><td>frem</td><td>0x72</td><td>float </td><td>float </td><td>zbytek po dìlení</td><td>-//-</td></tr>
<tr><td>20</td><td>drem</td><td>0x73</td><td>double</td><td>double</td><td>zbytek po dìlení</td><td>-//-</td></tr>
<tr><td>21</td><td>ineg</td><td>0x74</td><td>int   </td><td>&nbsp;</td><td>zmìna znaménka</td><td>pùvodní operand je ze zásobníku operandù odstranìn</td></tr>
<tr><td>22</td><td>lneg</td><td>0x75</td><td>long  </td><td>&nbsp;</td><td>zmìna znaménka</td><td>pùvodní operand je ze zásobníku operandù odstranìn</td></tr>
<tr><td>23</td><td>fneg</td><td>0x76</td><td>float </td><td>&nbsp;</td><td>zmìna znaménka</td><td>pùvodní operand je ze zásobníku operandù odstranìn</td></tr>
<tr><td>24</td><td>dneg</td><td>0x77</td><td>double</td><td>&nbsp;</td><td>zmìna znaménka</td><td>pùvodní operand je ze zásobníku operandù odstranìn</td></tr>
</table>

<p><a name="k032"></a></p>
<h3>3.2 Lua VM</h3>

<p>V&nbsp;bajtkódu Lua VM je situace mnohem jednodu¹¹í, nebo» zde najdeme jen
sedm aritmetických instrukcí. Tyto instrukce pracují s&nbsp;obsahem vybraných
dvou èi tøí registrù. Vìt¹ina aritmetických instrukci pracuje se dvìma
zdrojovými registry a jedním registrem cílovým; výjimkou je jen poslední
instrukce, která má pouze jeden zdrojový a jeden cílový registr:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operand 1</th><th>Operand 2</th><th>Operace</th></tr>
<tr><td>1</td><td>ADD</td><td>13</td><td>int/float</td><td>int/float</td><td>souèet</td></tr>
<tr><td>2</td><td>SUB</td><td>14</td><td>int/float</td><td>int/float</td><td>rozdíl</td></tr>
<tr><td>3</td><td>MUL</td><td>15</td><td>int/float</td><td>int/float</td><td>souèin</td></tr>
<tr><td>4</td><td>DIV</td><td>16</td><td>int/float</td><td>int/float</td><td>podíl</td></tr>
<tr><td>5</td><td>MOD</td><td>17</td><td>int/float</td><td>int/float</td><td>podíl modulo</td></tr>
<tr><td>6</td><td>POW</td><td>18</td><td>int/float</td><td>int/float</td><td>umocnìní</td></tr>
<tr><td>7</td><td>UNM</td><td>19</td><td>int/float</td><td>&times;</td><td>zmìna znaménka</td></tr>
</table>

<p>Zajímavá je existence instrukce <strong>POW</strong>, proto¾e tato
aritmetická operace se pou¾ívá pouze minimálnì.</p>

<p><a name="k033"></a></p>
<h3>3.3 Python VM</h3>

<p>Podobnì jednoduchá je i situace ve virtuálním stroji Python VM, a¾ na ten
rozdíl, ¾e zde aritmetické instrukce pracují s&nbsp;hodnotami umístìnými na
zásobníku operandù, podobnì jako je tomu i v&nbsp;JVM. V¹echny instrukce navíc
mohou pracovat i pro rùzné typy objektù (to odpovídá pøetí¾ení pøíslu¹ných
operandù):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Operand 1</th><th>Operand 2</th><th>Operace</th></tr>
<tr><td>1</td><td>BINARY_ADD</td><td>èíslo/objekt</td><td>èíslo/objekt</td><td>souèet</td></tr>
<tr><td>2</td><td>BINARY_SUBTRACT</td><td>èíslo/objekt</td><td>èíslo/objekt</td><td>rozdíl</td></tr>
<tr><td>3</td><td>BINARY_MULTIPLY</td><td>èíslo/objekt</td><td>èíslo/objekt</td><td>souèin</td></tr>
<tr><td>4</td><td>BINARY_DIVIDE</td><td>èíslo/objekt</td><td>èíslo/objekt</td><td>podíl</td></tr>
<tr><td>5</td><td>BINARY_MODULO</td><td>èíslo/objekt</td><td>èíslo/objekt</td><td>podíl modulo</td></tr>
<tr><td>6</td><td>BINARY_POWER</td><td>èíslo/objekt</td><td>èíslo/objekt</td><td>umocnìní</td></tr>
<tr><td>7</td><td>UNARY_NEGATIVE</td><td>èíslo/objekt</td><td>&times;</td><td>zmìna znaménka</td></tr>
</table>

<p>I zde nalezneme instrukci <strong>BINARY_POWER</strong> podobnou instrukci
<strong>POW</strong> z&nbsp;Lua VM.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Logické operace</h2>

<p>Druhou skupinou instrukcí jsou instrukce, pomocí nich¾ se implementují témìø
v¹echny základní bitové a logické operace.</p>

<p><a name="k041"></a></p>
<h3>4.1 JVM</h3>

<p>Nejprve se zmíníme o bitových
operacích v&nbsp;JVM. Programovací jazyk Java obsahuje nìkolik bitových
operací, které lze provádìt nad datovými typy <strong>int</strong> èi
<strong>long</strong>. Jedná se o bitový souèin (operace AND provádìná bit po
bitu), bitový souèet, nonekvivalenci a negaci (opìt provádìnou bit po bitu).
V&nbsp;instrukèním souboru v¹ak nalezneme pouze první tøi bitové instrukce:
bitový souèin, bitový souèet a nonekvivalenci, proto¾e negace se provádí pomocí
dvou instrukcí, konkrétnì s&nbsp;vyu¾itím nonekvivalence proti masce 0xffffffff
(popø.&nbsp;obdobné konstanty typu <strong>long</strong>). Tyto instrukce jsou
pou¾ity i pro provádìní logických operací: logického souètu, souèinu,
nonekvivalence a negace, tak¾e do instrukèního souboru JVM nebylo nutné pro
datový typ <strong>boolean</strong> pøidávat ¾ádné dal¹í specializované
instrukce.</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operand 1</th><th>Operand 2</th><th>Operace</th><th>Poznámka</th></tr>
<tr><td>1</td><td>iand</td><td>0x7E</td><td>int </td><td>int </td><td>bitový souèin</td><td>-//-</td></tr>
<tr><td>2</td><td>land</td><td>0x7F</td><td>long</td><td>long</td><td>bitový souèin</td><td>-//-</td></tr>
<tr><td>3</td><td>ior </td><td>0x80</td><td>int </td><td>int </td><td>bitový souèet</td><td>-//-</td></tr>
<tr><td>4</td><td>lor </td><td>0x81</td><td>long</td><td>long</td><td>bitový souèet</td><td>-//-</td></tr>
<tr><td>5</td><td>ixor</td><td>0x82</td><td>int </td><td>int </td><td>nonekvivalence</td><td>-//-</td></tr>
<tr><td>6</td><td>lxor</td><td>0x83</td><td>long</td><td>long</td><td>nonekvivalence</td><td>-//-</td></tr>
</table>

<p><a name="k042"></a></p>
<h3>4.2 Lua VM</h3>

<p>Velmi zajímavé je, ¾e v&nbsp;Lua VM najdeme pouze dvì instrukce slou¾ící pro
implementaci logických funkcí. První instrukce slou¾í k&nbsp;negaci hodnoty
ulo¾ené ve vybraném registru, druhá instrukce pro porovnání, zda se hodnota
ulo¾ená v&nbsp;registru rovná zapsané konstantì. Tato druhá instrukce se
typicky kombinuje s&nbsp;pøeskokem následující instrukce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operand 1</th><th>Operand 2</th><th>Operace</th></tr>
<tr><td>1</td><td>NOT</td><td>20</td><td>int/float</td><td>&times;</td><td>negace</td></tr>
<tr><td>2</td><td>TESTSET</td><td>28</td><td>int/float</td><td>porovnávaná hodnota</td><td>test hodnoty ulo¾ené v registru</td></tr>
</table>

<p><a name="k043"></a></p>
<h3>4.3 Python VM</h3>

<p>V&nbsp;Python VM opìt najdeme celou sadu (oèekávaných) instrukcí pro
provádìní logických operací, vèetnì operace XOR:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Operand 1</th><th>Operand 2</th><th>Operace</th></tr>
<tr><td>1</td><td>BINARY_AND</td><td>èíslo/objekt</td><td>èíslo/objekt</td><td>bitový/logický souèin</td></tr>
<tr><td>2</td><td>BINARY_OR </td><td>èíslo/objekt</td><td>èíslo/objekt</td><td>bitový/logický souèet</td></tr>
<tr><td>3</td><td>BINARY_XOR</td><td>èíslo/objekt</td><td>èíslo/objekt</td><td>bitová/logická nonekvivalence</td></tr>
<tr><td>7</td><td>UNARY_NOT</td><td>èíslo/objekt</td><td>&times;</td><td>negace</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. Aritmetické a bitové posuny</h2>

<p><a name="k051"></a></p>
<h3>5.1 JVM</h3>

<p>Navíc programovací jazyk Java obsahuje i operace aritmetického a bitového
posunu doleva a doprava, které mají svùj obraz v&nbsp;instrukèní sadì. Posun
doleva odpovídá operátoru &lt;&lt; (nezávisle na znaménku prvního operandu),
posun doprava pak dvojici operátorù &gt;&gt; a &gt;&gt;&gt; (v&nbsp;céèku se
rozli¹ují typy <strong>signed</strong> a <strong>unsigned</strong>, proto druhý
z&nbsp;tìchto operátorù nemusí být v&nbsp;tomto jazyku pou¾it). Mimochodem: ze
specifikace JVM vyplývá, ¾e druhý operand v&nbsp;instrukcích posunu je nejprve
maskován konstantou 0x1f v&nbsp;pøípadì typu <strong>int</strong> èi 0x3f u
datového typu <strong>long</strong>. Jinými slovy to znamená, ¾e pro posun je
pou¾ito pouze dolních 5 èi 6 bitù. Takté¾ si pov¹imnìte, ¾e u instrukcí pro
bitový èi aritmetický posun je druhým operandem v¾dy hodnota typu
<strong>int</strong>, a to i v&nbsp;pøípadì, ¾e se posouvá hodnota typu
<strong>long</strong>:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operand 1</th><th>Operand 2</th><th>Operace</th><th>Poznámka</th></tr>
<tr><td>1</td><td>ishl </td><td>0x78</td><td>int </td><td>int </td><td>aritmetický/bitový posun doleva</td><td>oba pùvodní operandy ze zásobníku operandù jsou odstranìny</td></tr>
<tr><td>2</td><td>lshl </td><td>0x79</td><td>long</td><td>int </td><td>aritmetický/bitový posun doleva</td><td>-//-</td></tr>
<tr><td>3</td><td>ishr </td><td>0x7A</td><td>int </td><td>int </td><td>aritmetický posun doprava</td><td>-//-</td></tr>
<tr><td>4</td><td>lshr </td><td>0x7B</td><td>long</td><td>int </td><td>aritmetický posun doprava</td><td>-//-</td></tr>
<tr><td>5</td><td>iushr</td><td>0x7C</td><td>int </td><td>int </td><td>bitový posun doprava</td><td>-//-</td></tr>
<tr><td>6</td><td>lushr</td><td>0x7D</td><td>long</td><td>int </td><td>bitový posun doprava</td><td>-//-</td></tr>
</table>

<p><a name="k052"></a></p>
<h3>5.2 Lua VM</h3>

<p>Jak je tomu v&nbsp;Lua VM? Zde je situace ponìkud zvlá¹tní, proto¾e
instrukce pro bitové èi aritmetické posuny zde (Lua 5.1 a Lua 5.2) vùbec
nenajdeme, i kdy¾ existují minimálnì dva patche, které tyto operace pøidávají
jak do jazyka, tak i do bajtkódu (v&nbsp;Lua 5.3 je ji¾ podpora pro posuvy
zahrnuta, ov¹em stále se nejedná o finální vydání).</p>

<p><a name="k053"></a></p>
<h3>5.3 Python VM</h3>

<p>V&nbsp;Python VM nalezneme následující instrukce pro posuny:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Operand 1</th><th>Operand 2</th><th>Operace</th></tr>
<tr><td>1</td><td>BINARY_LSHIFT</td><td>èíslo/objekt</td><td>èíslo/objekt</td><td>posun doleva</td></tr>
<tr><td>2</td><td>BINARY_RSHIFT</td><td>èíslo/objekt</td><td>èíslo/objekt</td><td>posun doprava</td></tr>
</table>



<p><a name="k06"></a></p>
<h2 id="k06">6. Konverze mezi základními datovými typy</h2>

<p>Dal¹í skupinou instrukcí, kterou lze v&nbsp;nìkterých typech virtuálních
strojù nalézt, jsou instrukce slou¾ící pro konverzi dat, pøesnìji øeèeno pro
konverzi mezi hodnotami primitivních datových typù. Konverzní instrukce
nalezneme prakticky jen v&nbsp;JVM, tak¾e tato kapitola mù¾e být relativnì
krátká. Programovací jazyk Java sice patøí mezi jazyky silnì typované, ale
konverze mezi nìkterými datovými typy jsou provádìny automaticky (pøíkladem
mù¾e být konverze byte-&rarr;int) a jiné lze explicitnì zapsat. Navíc se
konverzní instrukce objevují v&nbsp;bajtkódu JVM napøíklad pøi vytváøení
návratové hodnoty metody v&nbsp;pøípadì, ¾e tato hodnota nemá typ
<strong>int</strong>, <strong>long</strong>, <strong>float</strong> èi
<strong>double</strong>. Ov¹em ne v¹echny kombinace konverzí datových typù jsou
v&nbsp;instrukèní sadì pøítomny, tak¾e nìkteré konverze je ve skuteènosti nutné
provádìt pomocí dvojice instrukcí (napøíklad se mù¾e jednat o konverzi
z&nbsp;<strong>float</strong> na <strong>short</strong> a podobnì). Podívejme
se ostatnì na tabulku obsahující v¹echny konverzní instrukce. V&nbsp;prvním
sloupci je uveden datový typ, z&nbsp;nìho¾ je konverze provádìna a
v&nbsp;prvním øádku naopak výsledný datový typ:</p>

<table>
<tr><th>z/na-&gt;</th><th>char</th><th>byte</th><th>short</th><th>int</th><th>long</th><th>float</th><th>double</th></tr>
<tr><td>char  </td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>byte  </td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>short </td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>int</td><td>i2c</td><td>i2b</td><td>i2s</td><td>&nbsp;</td><td>i2l</td><td>i2f</td><td>i2d</td></tr>
<tr><td>long  </td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>l2i</td><td>&nbsp;</td><td>l2f</td><td>l2d</td></tr>
<tr><td>float </td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>f2i</td><td>f2l</td><td>&nbsp;</td><td>f2d</td></tr>
<tr><td>double</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>d2i</td><td>d2l</td><td>d2f</td><td>&nbsp;</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Instrukce pro operace s&nbsp;registry popø.&nbsp;zásobníkem operandù</h2>

<p>Pøed provedením aritmetických, logických i bitových instrukcí jako¾ i pøed
zavoláním jiné funkce popø.&nbsp;metody je mnohdy nutné data vlo¾it do vhodných
registrù a/nebo na správné místo v&nbsp;zásobníku operandù. K&nbsp;tomu slou¾í
instrukce popsané v&nbsp;této kapitole.</p>

<p><a name="k071"></a></p>
<h3>7.1 JVM</h3>

<p>JVM je zásobníkový virtuální stroj, proto jeho instrukèní sada obsahuje
nìkolik instrukcí, které se nápadnì podobají <i>slovùm</i> pou¾ívaným
v&nbsp;programovacím jazyku <i>Forth</i> (ono se ostatnì není èemu divit,
proto¾e se jedná skuteènì o základní &bdquo;zásobníkové&ldquo; instrukce).
Dùle¾ité je, ¾e tyto instrukce ji¾ nepotøebují být rozdìleny podle toho
s&nbsp;jakými daty pracují, proto¾e ka¾dému prvku ulo¾eném na <i>zásobníku
operandù</i> je stejnì pøiøazen datový <i>tag</i>, který je tìmito instrukcemi
vyu¾íván. Zajímavé je, ¾e podobný princip nebyl pou¾it napøíklad u
aritmetických instrukcí (bavil jsem se o tom s&nbsp;jedním vývojáøem VM,
kterému se to také pøíli¹ nelíbilo, ale u¾ si nepamatoval, kdo vlastnì
s&nbsp;návrhem instrukèní sady pøed více ne¾ patnácti lety u spoleènosti Sun
pøi¹el):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Popis</th></tr>
<tr><td>1</td><td>pop</td><td>57</td><td>odstraní jednu polo¾ku z <i>TOS</i> (platí pro int, float, referenci na objekt)</td></tr>
<tr><td>2</td><td>pop2</td><td>58</td><td>odstraní jednu (long, double) polo¾ku èi dvì (int, float, reference) polo¾ky ze zásobníku</td></tr>
<tr><td>3</td><td>dup</td><td>59</td><td>zduplikuje (zkopíruje) polo¾ku z <i>TOS</i> (platí pro int, float, referenci na objekt)</td></tr>
<tr><td>4</td><td>dup_x1</td><td>5A</td><td>zduplikuje (zkopíruje) polo¾ku z <i>TOS</i>, ale vlo¾í i o dvì pozice ní¾ do zásobníku</td></tr>
<tr><td>5</td><td>dup_x2</td><td>5B</td><td>zduplikuje (zkopíruje) polo¾ku z <i>TOS</i> a vlo¾í i o dvì èi tøi pozice ní¾ (v závislosti na bitové ¹íøce)</td></tr>
<tr><td>6</td><td>dup2</td><td>5C</td><td>duplikace jedné (long, double) èi dvou (int, float, reference) polo¾ek</td></tr>
<tr><td>7</td><td>dup2_x1</td><td>5D</td><td>kombinace vlastností instrukcí dup2 a dup_x1 (vlo¾ení prvku o dvì místa ní¾e)</td></tr>
<tr><td>8</td><td>dup2_x2</td><td>5E</td><td>kombinace vlastností instrukcí dup2 a dup_x2</td></tr>
<tr><td>9</td><td>swap</td><td>5F</td><td>prohodí dva prvky le¾ící na vrcholu zásobníku (platí pro int, float, referenci na objekt)</td></tr>
</table>

<p><a name="k072"></a></p>
<h3>7.2 Lua VM</h3>

<p>U¾ z&nbsp;tabulek uvedených v&nbsp;pøedchozích kapitolách bylo patrné, ¾e
bajtkód Lua VM je velmi elegantní a navíc pojatý minimalisticky. To platí i pro
instrukce pro pøenosy dat, proto¾e v¹e zaøizuje jediná instrukce pojmenovaná
<strong>MOVE</strong>, která slou¾í k&nbsp;pøenosu dat mezi libovolnými dvìma
pracovními registry. U registrového virtuálního stroje není ¾ádná dal¹í
instrukce zapotøebí, i kdy¾ by v&nbsp;nìkterých pøípadech bylo vhodné mít
instrukci typu <strong>SWAP</strong>:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operand 1</th><th>Operand 2</th><th>Operace</th></tr>
<tr><td>1</td><td>MOVE</td><td>0</td><td>cílový registr</td><td>zdrojový registr</td><td>pøesun dat ze zdrojového do cílového registru</td></tr>
</table>

<p><a name="k073"></a></p>
<h3>7.3 Python VM</h3>

<p>Python VM je, podobnì jako JVM, virtuální stroj postavený na zásobníku
operandù, z&nbsp;èeho¾ také vyplývá, ¾e pro manipulaci s&nbsp;operandy zde
nalezneme podobné instrukce, jako v&nbsp;JVM:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Operand 1</th><th>Operand 2</th><th>Operace</th></tr>
<tr><td>1</td><td>POP_TOP  </td><td>implicitní</td><td>implicitní</td><td>odstraní polo¾ku ze zásobníku operandù</td></tr>
<tr><td>2</td><td>ROT_TWO  </td><td>implicitní</td><td>implicitní</td><td>rotace (swap) dvou polo¾ek</td></tr>
<tr><td>3</td><td>ROT_THREE</td><td>implicitní</td><td>implicitní</td><td>rotace (roll) tøí polo¾ek</td></tr>
<tr><td>4</td><td>ROT_FOUR </td><td>implicitní</td><td>implicitní</td><td>rotace ètyø polo¾ek</td></tr>
<tr><td>5</td><td>DUP_TOP  </td><td>implicitní</td><td>implicitní</td><td>duplikace polo¾ky na zásobníku operandù</td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Podmínìné a nepodmínìné skoky, vìtvení kódu</h2>

<p>V¹echny popisované virtuální stroje obsahují instrukce pro provádìní
podmínìných a nepodmínìných skokù. Tyto velmi dùle¾ité instrukce si popí¹eme
v&nbsp;této kapitole.</p>

<p><a name="k081"></a></p>
<h3>8.1 JVM</h3>

<p>V&nbsp;JVM nalezneme velké mno¾ství instrukcí pro provádìní podmínìných i
nepodmínìných skokù. Základní instrukce spadající do této kategorie jsou
popsány v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Podmínka</th><th>Operace</th></tr>
<tr><td>1</td><td>goto</td><td>0xA7</td><td>highbyte, lowbyte</td><td>&nbsp;</td><td>pøímý skok na adresu ulo¾enou v&nbsp;dvojici operandù: highbyte*256+lowbyte</td></tr>
<tr><td>2</td><td>goto_w</td><td>0xC8</td><td>byte1,byte2,byte3 byte4</td><td>&nbsp;</td><td>pøímý skok na adresu ulo¾enou ve ètveøici operandù: byte1*2<sup>24</sup>+byte2*2<sup>16</sup>+byte3*2<sup>8</sup>+byte4</td></tr>
<tr><td>3</td><td>ifeq</td><td>0x99</td><td>highbyte, lowbyte</td><td>TOS=0</td><td>skok na lokální adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>4</td><td>ifne</td><td>0x9A</td><td>highbyte, lowbyte</td><td>TOS&ne;0</td><td>skok na lokální adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>5</td><td>iflt</td><td>0x9B</td><td>highbyte, lowbyte</td><td>TOS&lt;0</td><td>skok na lokální adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>6</td><td>ifge</td><td>0x9C</td><td>highbyte, lowbyte</td><td>TOS&ge;0</td><td>skok na lokální adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>7</td><td>ifgt</td><td>0x9D</td><td>highbyte, lowbyte</td><td>TOS&gt;0</td><td>skok na lokální adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>8</td><td>ifle</td><td>0x9E</td><td>highbyte, lowbyte</td><td>TOS&le;0</td><td>skok na lokální adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>9</td><td>ifnull   </td><td>0xC6</td><td>highbyte, lowbyte</td><td>TOS=null</td><td>skok na adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>10</td><td>ifnonnull</td><td>0xC7</td><td>highbyte, lowbyte</td><td>TOS&ne;null</td><td>skok na adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
</table>

<p>V&nbsp;pøípadì potøeby testu hodnoty promìnných typu <i>long</i>,
<i>float</i> nebo <i>double</i> nezbývá nic jiného ne¾ vyu¾ít instrukce, které
porovnají dvì hodnoty daného typu (typicky se jedná o promìnnou a konstantu) a
ulo¾í na <i>TOS</i> hodnotu 0, 1 nebo -1 na základì výsledku tohoto porovnání.
Jedná se o následující pìtici instrukcí:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operand 1</th><th>Operand 2</th><th>Výsledek</th></tr>
<tr><td>1</td><td>lcmp </td><td>0x94</td><td>long  </td><td>long  </td><td>1 kdy¾ operand 1 &gt; operand 2<br />0 kdy¾ operand 1 == operand 2<br />-1 kdy¾ operand 1 &lt; operand 2</td></tr>
<tr><td>2</td><td>fcmpl</td><td>0x95</td><td>float </td><td>float </td><td>1 kdy¾ operand 1 &gt; operand 2<br />0 kdy¾ operand 1 == operand 2<br />-1 kdy¾ operand 1 &lt; operand 2<br />-1 kdy¾ operand 1 je NaN<br />-1 kdy¾ operand 2 je NaN</td></tr>
<tr><td>3</td><td>fcmpg</td><td>0x96</td><td>float </td><td>float </td><td>1 kdy¾ operand 1 &gt; operand 2<br />0 kdy¾ operand 1 == operand 2<br />-1 kdy¾ operand 1 &lt; operand 2<br />1 kdy¾ operand 1 je NaN<br />1 kdy¾ operand 2 je NaN</td></tr>
<tr><td>4</td><td>dcmpl</td><td>0x97</td><td>double</td><td>double</td><td>1 kdy¾ operand 1 &gt; operand 2<br />0 kdy¾ operand 1 == operand 2<br />-1 kdy¾ operand 1 &lt; operand 2<br />-1 kdy¾ operand 1 je NaN<br />-1 kdy¾ operand 2 je NaN</td></tr>
<tr><td>5</td><td>dcmpg</td><td>0x98</td><td>double</td><td>double</td><td>1 kdy¾ operand 1 &gt; operand 2<br />0 kdy¾ operand 1 == operand 2<br />-1 kdy¾ operand 1 &lt; operand 2<br />1 kdy¾ operand 1 je NaN<br />1 kdy¾ operand 2 je NaN</td></tr>
</table>

<p>Z&nbsp;teoretického hlediska by podmínìné skoky popsané v&nbsp;pøedchozích
dvou odstavcích mìly ve v¹ech pøípadech postaèovat. V&nbsp;praxi &ndash;
napøíklad pøi implementaci poèítaných programových smyèek &ndash; je v¹ak
vhodné umìt efektivnì provést podmínìný skok na základì porovnání
<strong>dvou</strong> operandù, nikoli na základì porovnání jednoho operandu
vùèi nule. Samozøejmì je mo¾né nejdøíve oba operandy od sebe odeèíst a poté
provést skok na základì výsledku tohoto rozdílu (co¾ se podobá systému
pou¾ívanému u mnohých typù mikroprocesorù), to v¹ak vy¾aduje zbyteènì dlouhou
sekvenci instrukcí.  Z&nbsp;tohoto dùvodu se v&nbsp;instrukèním souboru JVM
nachází i instrukce, které porovnají dvojici operandù typu <i>int</i> ulo¾enou
na nejvrchnìj¹ích dvou pozicích zásobníku operandù a skok vykonají na základì
toho, zda je první operand vìt¹í, men¹í èi roven operandu druhému (oba operandy
jsou navíc ze zásobníku odstranìny):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Podmínka</th><th>Operace</th></tr>
<tr><td>1</td><td>if_icmpeq</td><td>0x9F</td><td>highbyte, lowbyte</td><td>value1=value2</td><td>skok na adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>2</td><td>if_icmpne</td><td>0xA0</td><td>highbyte, lowbyte</td><td>value1&ne;value2</td><td>skok na adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>3</td><td>if_icmplt</td><td>0xA1</td><td>highbyte, lowbyte</td><td>value1&lt;value2</td><td>skok na adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>4</td><td>if_icmpge</td><td>0xA2</td><td>highbyte, lowbyte</td><td>value1&ge;value2</td><td>skok na adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>5</td><td>if_icmpgt</td><td>0xA3</td><td>highbyte, lowbyte</td><td>value1&gt;value2</td><td>skok na adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>6</td><td>if_icmple</td><td>0xA4</td><td>highbyte, lowbyte</td><td>value1&le;value2</td><td>skok na adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
</table>

<p>Kromì porovnání dvou operandù typu <i>int</i> je takté¾ mo¾né porovnat dvì
reference. Ov¹em vzhledem k&nbsp;neexistenci skuteèné ukazatelové aritmetiky
(viz vý¹e) lze dvì reference porovnat pouze na rovnost nebo nerovnost, nikoli
ji¾ na to, zda je jedna reference (resp.&nbsp;hodnota ukazatele)
&bdquo;vìt¹í&ldquo; nebo &bdquo;men¹í&ldquo; ne¾ druhá. Z&nbsp;tohoto dùvodu
pro porovnávání dvou referencí existují pouze dvì instrukce vypsané
v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Podmínka</th><th>Operace</th></tr>
<tr><td>1</td><td>if_acmpeq</td><td>0xA5</td><td>highbyte, lowbyte</td><td>value1=value2</td><td>skok na adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>2</td><td>if_acmpne</td><td>0xA6</td><td>highbyte, lowbyte</td><td>value1&ne;value2</td><td>skok na adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
</table>

<p><a name="k082"></a></p>
<h3>8.2 Lua VM</h3>

<p>Instrukcí pro skoky nalezneme v&nbsp;Lua VM naprosté minimum. Jedná se ve
skuteènosti o jedinou instrukci <strong>JMP</strong> pro provedení relativního
skoku v&nbsp;rámci jedné funkce. Kromì toho v¹ak v&nbsp;instrukèní sadì
nalezneme ètveøici instrukcí, které sice neprovedou <i>podmínìný skok</i>, ale
<i>podmínìný pøeskok</i> dal¹í instrukce. To je velmi snadné, proto¾e
v&nbsp;Lua VM &ndash; na rozdíl od JVM &ndash; mají v¹echny instrukce pevnou
(konstantní) délku. Tyto instrukce s&nbsp;podmínkami jsou navíc velmi
univerzální:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operace</th></tr>
<tr><td>1</td><td>EQ  </td><td>24</td><td>pøeskok dal¹í instrukce za podmínky ((RK[B] == RK[C]) ~= A)</td></tr>
<tr><td>2</td><td>LT  </td><td>25</td><td>pøeskok dal¹í instrukce za podmínky ((RK[B] &lt; RK[C]) ~= A) </td></tr>
<tr><td>3</td><td>LE  </td><td>26</td><td>pøeskok dal¹í instrukce za podmínky ((RK[B] &lt;= RK[C]) ~= A)</td></tr>
<tr><td>4</td><td>TEST</td><td>27</td><td>pøeskok dal¹í instrukce za podmínky not (R[A] &lt;=&gt; C)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>JMP </td><td>23</td><td>relativní skok</td></tr>
</table>

<p><a name="k083"></a></p>
<h3>8.3 Python VM</h3>

<p>Ve virtuálním stroji programovacího jazyka Python nalezneme ¹est instrukcí
skoku &ndash; dvì instrukce pro provedení nepodmínìných skokù a tøi instrukce
pro provedení skokù podmínìných:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Provádìná operace</th></tr>
<tr><td>1</td><td>JUMP_ABSOLUTE</td><td>skok na zadaný index (lokální adresu)</td></tr>
<tr><td>2</td><td>JUMP_FORWARD</td><td>skok na relativní index (je zadána delta oproti souèasné adrese)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>POP_JUMP_IF_TRUE(</td><td>podmínìný skok na základì obsahu TOS; obsah TOS je odstranìn</td></tr>
<tr><td>4</td><td>POP_JUMP_IF_FALSE(</td><td>podmínìný skok na základì obsahu TOS (opaèná podmínka); obsah TOS je odstranìn</td></tr>
<tr><td>5</td><td>JUMP_IF_TRUE_OR_POP</td><td>pokud TOS==true, provede se skok, v opaèném pøípadì se TOS odstraní</td></tr>
<tr><td>6</td><td>JUMP_IF_FALSE_OR_POP</td><td>opaèné chování, ne¾ je tomu v&nbsp;pøedchozí instrukci</td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Obsah následující èásti seriálu</h2>

<p>V&nbsp;následující èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">tohoto
seriálu</a> bude vzájemné porovnání vlastností bajtkódu virtuálního stroje
Javy, Pythonu i programovacího jazyka Lua dokonèeno. Zabývat se budeme
pøedev¹ím problematikou volání funkcí popø.&nbsp;volání metod, deklarace tøíd a
objektù a takté¾ rozliènými zpùsoby pøístupu k&nbsp;tøídním atributùm
(statickým atributùm) i k&nbsp;atributùm objektù. Nezapomeneme ani na krátké
porovnání zpùsobu práce s&nbsp;výjimkami.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Odkazy na Internetu</h2>

<ol>

<li>Python Byte Code Instructions<br />
<a href="https://docs.python.org/release/2.5.2/lib/bytecodes.html">https://docs.python.org/release/2.5.2/lib/bytecodes.html</a>
</li>

<li>Python 2.x: funkce range()<br />
<a href="https://docs.python.org/2/library/functions.html#range">https://docs.python.org/2/library/functions.html#range</a>
</li>

<li>Python 2.x: typ iterátor<br />
<a href="https://docs.python.org/2/library/stdtypes.html#iterator-types">https://docs.python.org/2/library/stdtypes.html#iterator-types</a>
</li>

<li>Python break, continue and pass Statements<br />
<a href="http://www.tutorialspoint.com/python/python_loop_control.htm">http://www.tutorialspoint.com/python/python_loop_control.htm</a>
</li>

<li>Python Bytecode: Fun With Dis<br />
<a href="http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/">http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/</a>
</li>

<li>Python's Innards: Hello, ceval.c!<br />
<a href="http://tech.blog.aknin.name/category/my-projects/pythons-innards/">http://tech.blog.aknin.name/category/my-projects/pythons-innards/</a>
</li>

<li>Byterun<br />
<a href="https://github.com/nedbat/byterun">https://github.com/nedbat/byterun</a>
</li>

<li>Python Byte Code Instructions<br />
<a href="http://document.ihg.uni-duisburg.de/Documentation/Python/lib/node56.html">http://document.ihg.uni-duisburg.de/Documentation/Python/lib/node56.html</a>
</li>

<li>Python Byte Code Instructions<br />
<a href="https://docs.python.org/3.2/library/dis.html#python-bytecode-instructions">https://docs.python.org/3.2/library/dis.html#python-bytecode-instructions</a>
</li>

<li>dis - Python module<br />
<a href="https://docs.python.org/2/library/dis.html">https://docs.python.org/2/library/dis.html</a>
</li>

<li>Comparison of Python virtual machines<br />
<a href="http://polishlinux.org/apps/cli/comparison-of-python-virtual-machines/">http://polishlinux.org/apps/cli/comparison-of-python-virtual-machines/</a>
</li>

<li>Lambda the Ultimate: Coroutines in Lua,<br />
<a href="http://lambda-the-ultimate.org/node/438">http://lambda-the-ultimate.org/node/438</a>
</li>

<li>Coroutines Tutorial,<br />
<a href="http://lua-users.org/wiki/CoroutinesTutorial">http://lua-users.org/wiki/CoroutinesTutorial</a>
</li>

<li>Lua Coroutines Versus Python Generators,<br />
<a href="http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators">http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators</a>
</li>

<li>Programming in Lua 9.1 &ndash; Coroutine Basics,<br />
<a href="http://www.lua.org/pil/9.1.html">http://www.lua.org/pil/9.1.html</a>
</li>

<li>Wikipedia CZ: Koprogram,<br />
<a href="http://cs.wikipedia.org/wiki/Koprogram">http://cs.wikipedia.org/wiki/Koprogram</a>
</li>

<li>Wikipedia EN: Coroutine,<br />
<a href="http://en.wikipedia.org/wiki/Coroutine">http://en.wikipedia.org/wiki/Coroutine</a>
</li>

<li>Programming in Lua (first edition)<br />
<a href="http://www.lua.org/pil/contents.html">http://www.lua.org/pil/contents.html</a>
</li>

<li>Programming in Lua: 6 - More about Functions<br />
<a href="http://www.lua.org/pil/6.html">http://www.lua.org/pil/6.html</a>
</li>

<li>Lua Lanes,<br />
<a href="http://kotisivu.dnainternet.net/askok/bin/lanes/">http://kotisivu.dnainternet.net/askok/bin/lanes/</a>
</li>

<li>Programming in Lua: 6.1 - Closures<br />
<a href="http://www.lua.org/pil/6.1.html">http://www.lua.org/pil/6.1.html</a>
</li>

<li>Programming in Lua: 9.1 - Coroutine Basics<br />
<a href="http://www.lua.org/pil/9.1.html">http://www.lua.org/pil/9.1.html</a>
</li>

<li>Programming in Lua: Numeric for<br />
<a href="http://www.lua.org/pil/4.3.4.html">http://www.lua.org/pil/4.3.4.html</a>
</li>

<li>Programming in Lua: break and return<br />
<a href="http://www.lua.org/pil/4.4.html">http://www.lua.org/pil/4.4.html</a>
</li>

<li>Programming in Lua: Tables<br />
<a href="http://www.lua.org/pil/2.5.html">http://www.lua.org/pil/2.5.html</a>
</li>

<li>Programming in Lua: Table Constructors<br />
<a href="http://www.lua.org/pil/3.6.html">http://www.lua.org/pil/3.6.html</a>
</li>

<li>Programovací jazyk Lua<br />
<a href="http://palmknihy.cz/web/kniha/programovaci-jazyk-lua-12651.htm">http://palmknihy.cz/web/kniha/programovaci-jazyk-lua-12651.htm</a>
</li>

<li>Lua: Tables Tutorial<br />
<a href="http://lua-users.org/wiki/TablesTutorial">http://lua-users.org/wiki/TablesTutorial</a>
</li>

<li>Lua: Control Structure Tutorial<br />
<a href="http://lua-users.org/wiki/ControlStructureTutorial">http://lua-users.org/wiki/ControlStructureTutorial</a>
</li>

<li>Lua Types Tutorial<br />
<a href="http://lua-users.org/wiki/LuaTypesTutorial">http://lua-users.org/wiki/LuaTypesTutorial</a>
</li>

<li>Goto Statement in Lua<br />
<a href="http://lua-users.org/wiki/GotoStatement">http://lua-users.org/wiki/GotoStatement</a>
</li>

<li>Lua 5.2 sources<br />
<a href="http://www.lua.org/source/5.2/">http://www.lua.org/source/5.2/</a>
</li>

<li>Lua 5.2 sources - lopcodes.h<br />
<a href="http://www.lua.org/source/5.2/lopcodes.h.html">http://www.lua.org/source/5.2/lopcodes.h.html</a>
</li>

<li>Lua 5.2 sources - lopcodes.c<br />
<a href="http://www.lua.org/source/5.2/lopcodes.c.html">http://www.lua.org/source/5.2/lopcodes.c.html</a>
</li>

<li>For-each Loop in Java<br />
<a href="http://www.leepoint.net/notes-java/flow/loops/foreach.html">http://www.leepoint.net/notes-java/flow/loops/foreach.html</a>
</li>

<li>For Loop (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/For_loop">http://en.wikipedia.org/wiki/For_loop</a>
</li>

<li>Heinz Rutishauser<br />
<a href="http://en.wikipedia.org/wiki/Heinz_Rutishauser">http://en.wikipedia.org/wiki/Heinz_Rutishauser</a>
</li>

<li>Parrot<br />
<a href="http://www.parrot.org/">http://www.parrot.org/</a>
</li>

<li>Parrot languages<br />
<a href="http://www.parrot.org/languages">http://www.parrot.org/languages</a>
</li>

<li>Parrot Primer<br />
<a href="http://docs.parrot.org/parrot/latest/html/docs/intro.pod.html">http://docs.parrot.org/parrot/latest/html/docs/intro.pod.html</a>
</li>

<li>Parrot Opcodes<br />
<a href="http://docs.parrot.org/parrot/latest/html/ops.html">http://docs.parrot.org/parrot/latest/html/ops.html</a>
</li>

<li>Parrot VM<br />
<a href="http://en.wikibooks.org/wiki/Parrot_Virtual_Machine">http://en.wikibooks.org/wiki/Parrot_Virtual_Machine</a>
</li>

<li>Parrot Assembly Language<br />
<a href="http://www.perl6.org/archive/pdd/pdd06_pasm.html">http://www.perl6.org/archive/pdd/pdd06_pasm.html</a>
</li>

<li>Parrot Reference: Chapter 11 - Perl 6 and Parrot Essentials<br />
<a href="http://oreilly.com/perl/excerpts/perl-6-and-parrot-essentials/parrot-reference.html">http://oreilly.com/perl/excerpts/perl-6-and-parrot-essentials/parrot-reference.html</a>
</li>

<li>O-code<br />
<a href="http://en.wikipedia.org/wiki/O-code_machine">http://en.wikipedia.org/wiki/O-code_machine</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>GC safe-point (or safepoint) and safe-region<br />
<a href="http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html">http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html</a>
</li>

<li>Safepoints in HotSpot JVM<br />
<a href="http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html">http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html</a>
</li>

<li>Java theory and practice: Synchronization optimizations in Mustang<br />
<a href="http://www.ibm.com/developerworks/java/library/j-jtp10185/">http://www.ibm.com/developerworks/java/library/j-jtp10185/</a>
</li>

<li>How to build hsdis<br />
<a href="http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README">http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README</a>
</li>

<li>Java SE 6 Performance White Paper<br />
<a href="http://www.oracle.com/technetwork/java/6-performance-137236.html">http://www.oracle.com/technetwork/java/6-performance-137236.html</a>
</li>

<li>Lukas Stadler's Blog<br />
<a href="http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html">http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html</a>
</li>

<li>How to build hsdis-amd64.dll and hsdis-i386.dll on Windows<br />
<a href="http://dropzone.nfshost.com/hsdis.htm">http://dropzone.nfshost.com/hsdis.htm</a>
</li>

<li>PrintAssembly<br />
<a href="https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly">https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly</a>
</li>

<li>The Java Virtual Machine Specification: 3.14. Synchronization<br />
<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14</a>
</li>

<li>The Java Virtual Machine Specification: 8.3.1.4. volatile Fields<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.4. Memory Model<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.7. Non-atomic Treatment of double and long<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7</a>
</li>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (pøed verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2014</small></p>
</body>
</html>

