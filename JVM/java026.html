<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM (9.èást - tajemství instrukcí lookupswitch a tableswitch)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM (9.èást - tajemství instrukcí lookupswitch a tableswitch)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o vlastnostech JVM se ji¾ poètvrté budeme zabývat popisem instrukèního souboru virtuálního stroje Javy. Zamìøíme se pøedev¹ím na dvojici pomìrnì komplikovaných instrukcí nazvaných tableswitch a lookupswitch, pomocí nich¾ se implementují vìtvení programù realizované pøíkazy switch.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Rozvìtvení programù realizované sadou pøíkazù <strong>if</strong></a></p>
<p><a href="#k02">2. Rozvìtvení programù vytvoøené pøíkazy <strong>if-elseif</strong></a></p>
<p><a href="#k03">3. Programová konstrukce <strong>switch</strong> v&nbsp;Javì</a></p>
<p><a href="#k04">4. Struktura instrukce <strong>tableswitch</strong></a></p>
<p><a href="#k05">5. Pøíklad vyu¾ití instrukce <strong>tableswitch</strong></a></p>
<p><a href="#k06">6. Bajtkód instrukce <strong>tableswitch</strong> pod lupou hexa editoru</a></p>
<p><a href="#k07">7. Struktura instrukce <strong>lookupswitch</strong></a></p>
<p><a href="#k08">8. Pøíklad vyu¾ití instrukce <strong>lookupswitch</strong></a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Rozvìtvení programù realizované sadou pøíkazù <strong>if</strong></h2>

<p><a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-8-cast-instrukce-urcene-pro-rizeni-behu-programu/">V&nbsp;pøedchozí
èásti</a> seriálu o <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">programovacím
jazyku Java i o vlastnostech JVM</a> jsme si popsali v¹echny základní instrukce
pou¾ívané pro øízení bìhu programu. Jednalo se pøedev¹ím o nepodmínìné a
podmínìné skoky, pomocí nich¾ je mo¾né realizovat jak podmínìné pøíkazy typu
<strong>if-then-else</strong> èi výrazy <strong>?:</strong>, tak i poèítané a
nepoèítané programové smyèky. Teoreticky je sice mo¾né <a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-8-cast-instrukce-urcene-pro-rizeni-behu-programu/">minule
uvedené instrukce</a> pou¾ít i pro implementaci pøíkazu <strong>switch</strong>,
ve skuteènosti je v¹ak virtuální stroj Javy vybaven dvojicí pomìrnì slo¾itých
instrukcí nazvaných <strong>tableswitch</strong> a
<strong>lookupswitch</strong> urèených právì pro co nejefektivnìj¹í
implementaci tohoto pøíkazu (jeho¾ u¾iteènost je popravdì øeèeno
v&nbsp;objektovì orientovaném jazyce ponìkud diskutabilní :-), nicménì se
ponìkud vylep¹ila v&nbsp;Javì 7).</p>

<p>Zaènìme jednoduchým demonstraèním pøíkladem &ndash; implementací rozvìtvení
s&nbsp;vyu¾itím pøíkazu <strong>if</strong>. Následující demonstraèní program
obsahuje jen jedinou statickou metodu, která na základì hodnoty svého prvního a
jediného parametru vrátí celoèíselnou hodnotu zji¹tìnou v&nbsp;sekvenci pøíkazù
<strong>if</strong> (prozatím ignorujme fakt, ¾e se celá vìc dá snadno vyøe¹it
s&nbsp;vyu¾itím pole):</p>

<pre>
class Test1 {
&nbsp;
    static char ifChain(int x) {
        if (x == 0) return 'a';
        if (x == 1) return 'b';
        if (x == 2) return 'c';
        if (x == 3) return 'd';
        return ' ';
    }
&nbsp;
}
</pre>

<p>Pøelo¾ený bajtkód je celkem snadno pochopitelný a vyskytují se v&nbsp;nìm
pouze ty instrukce, které jsme si ji¾ popsali døíve (poznámky a ¹ipky
podmínìných skokù jsou samozøejmì dopsány ruènì):</p>

<pre>
static char ifChain(int);
  Code:
   0:   iload_0
   1:   ifne          7   -------+
   4:   bipush  97   // 'a'      |
   6:   ireturn                  |
                                 |
   7:   iload_0     &lt;------------+
   8:   iconst_1
   9:   if_icmpne     15  -------+
   12:  bipush  98   // 'b'      |
   14:  ireturn                  |
                                 |
   15:  iload_0     &lt;------------+
   16:  iconst_2
   17:  if_icmpne     23  -------+
   20:  bipush  99   // 'c'      |
   22:  ireturn                  |
                                 |
   23:  iload_0     &lt;------------+
   24:  iconst_3
   25:  if_icmpne     31  -------+
   28:  bipush  100  // 'd'      |
   30:  ireturn                  |
                                 |
   31:  bipush  32  &lt;------------+
   33:  ireturn
}
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Rozvìtvení programù vytvoøené pøíkazy <strong>if-elseif</strong></h2>

<p>Zajímavé je, ¾e prakticky stejný bajtkód je vygenerován i v&nbsp;pøípadì, ¾e
se namísto sekvence izolovaných pøíkazù <strong>if</strong> pou¾ije schéma
<strong>if-elseif-elseif-...</strong>. Je to vlastnì vcelku pochopitelné,
proto¾e se v&nbsp;na¹em demonstraèním pøíkazu nachází za ka¾dou podmínkou pouze
pøíkaz <strong>return</strong>, který v&nbsp;pøípadì splnìní podmínky ukonèí
bìh testovací metody:</p>

<pre>
class Test2 {
&nbsp;
    static char ifElseChain(int x) {
        if (x == 0) return 'a';
        else if (x == 1) return 'b';
        else if (x == 2) return 'c';
        else if (x == 3) return 'd';
        return ' ';
    }
&nbsp;
}
</pre>

<p>Vygenerovaný bajtkód je zcela stejný, jako u pøíkladu <a
href="#k01">z&nbsp;první kapitoly</a>:</p>

<pre>
static char ifElseChain(int);
  Code:
   0:   iload_0
   1:   ifne          7   -------+
   4:   bipush  97   // 'a'      |
   6:   ireturn                  |
                                 |
   7:   iload_0     &lt;------------+
   8:   iconst_1
   9:   if_icmpne     15  -------+
   12:  bipush  98   // 'b'      |
   14:  ireturn                  |
                                 |
   15:  iload_0     &lt;------------+
   16:  iconst_2
   17:  if_icmpne     23  -------+
   20:  bipush  99   // 'c'      |
   22:  ireturn                  |
                                 |
   23:  iload_0     &lt;------------+
   24:  iconst_3
   25:  if_icmpne     31  -------+
   28:  bipush  100  // 'd'      |
   30:  ireturn                  |
                                 |
   31:  bipush  32  &lt;------------+
   33:  ireturn
}
</pre>

<p>Z&nbsp;obou vý¹e vypsaných disassemblovaných bajtkódù je patrné, ¾e se
v&nbsp;obou pøípadech neustále provádí porovnání hodnoty jediného parametru
metody s&nbsp;konstantami 1, 2 a 3 (porovnání s&nbsp;nulou je
&bdquo;optimalizováno&ldquo;, proto¾e je proveden pouze test na nulovost
operandu, nikoli porovnání) a na základì výsledku tohoto porovnání se buï
podmínìným skokem <strong>ifne/if_icmpne</strong> pøejde k&nbsp;testu dal¹í
vìtve, nebo se naopak øízení pøenese dovnitø aktuální vìtve, co¾ vede a¾
k&nbsp;pøíkazu <strong>ireturn</strong>. Pøedností tohoto pøístupu je naprostá
univerzálnost, proto¾e je v&nbsp;pøíkazu <strong>if ()</strong> mo¾né zapsat
libovolný typ podmínky; na druhou stranu je v¹ak tìlo metody pomìrnì dlouhé
&ndash; celých 34 bajtù &ndash; a navíc je kvùli jednotlivým testùm bìh metody
docela pomalý, a to i pøi pøekladu do bajtkódu JIT pøekladaèem. Je tedy zøejmé,
¾e by bylo vhodnìj¹í pou¾ít ponìkud odli¹ný pøístup k&nbsp;celé
problematice.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Programová konstrukce <strong>switch</strong> v&nbsp;Javì</h2>

<p>Ka¾dého Javistu samozøejmì hned napadne, jakým zpùsobem lze pøedchozí dva
demonstraèní programy vylep¹it: buï by se jednalo o pou¾ití tabulky èi
asociativního pole, nebo o zápis rozvìtvení s&nbsp;vyu¾itím programové
konstrukce <strong>switch</strong>. Tato øídicí struktura je
v&nbsp;programovacím jazyku Java dostupná ji¾ od samého poèátku, tj.&nbsp;od
<i>JDK 1.0</i>, co¾ je ale vlastnì samozøejmé, nebo» byla po mírných úpravách
pøevzata z&nbsp;jazykù <i>C</i> a <i>C++</i>, které jsou ideovými pøedchùdci
Javy. Ov¹em pùvodnì se jednalo o øídicí strukturu, v&nbsp;ní¾ bylo mo¾né za
klíèovým slovem <strong>switch</strong> pou¾ít pouze celoèíselný výraz
vyhodnocovaný na <i>int</i> a jednotlivé vìtve specifikované klíèovým slovem
<strong>case</strong> mohly obsahovat pouze celoèíselnou konstantu typu
<i>byte</i>, <i>short</i> èi <i>int</i>, nikoli v¹ak <i>long</i>, co¾ je
omezení dané strukturou bajtkódu! (viz dal¹í text). Kromì tìchto tøí datových
typù bylo mo¾né pou¾ít i znakový literál, který je v&nbsp;Javì takté¾ pova¾ován
za jinak zapsanou celoèíselnou ¹estnáctibitovou konstantu typu <i>char</i>
&ndash; i tento typ je v&nbsp;bajtkódu zpracováván jako celé èíslo typu
<i>int</i>.</p>

<p>Jen pro zajímavost si pøipomeòme, ¾e i kdy¾ je datový typ <i>boolean</i>
takté¾ internì zpracováván podobnì, jako promìnné typu <i>int</i>, není výraz
typu <i>boolean</i> v&nbsp;pøíkazu <strong>switch</strong> mo¾né pou¾ít, co¾ je
ostatnì jen dobøe, proto¾e by tato konstrukce byla naprosto monstrózní, o èem¾
se mù¾ete sami pøesvìdèit:</p>

<pre>
class JavaMonstrosity {
&nbsp;
    static char badSwitch(boolean b) {
        switch (b) {
            case true:  /* neco */ break;
            case false: /* neco */break;
        }
    }
&nbsp;
}
</pre>

<p>Pøi pøekladu zdrojového kódu je programová konstrukce vytvoøená
s&nbsp;vyu¾itím klíèových slov <strong>switch</strong>, <strong>case</strong>,
<strong>break</strong> a <strong>default</strong> pøelo¾ena do bajtkódu,
v&nbsp;nìm¾ jsou pou¾ity instrukce <i>tableswitch</i>,
popø.&nbsp;<i>lookupswitch</i>, s&nbsp;nimi¾ se setkáme i v&nbsp;následujících
kapitolách.</p></p>

<p>Konkrétní výbìr jedné z&nbsp;tìchto instrukcí, je¾ se ve vygenerovaném
bajtkódu skuteènì pou¾ije, je proveden v&nbsp;závislosti na tom, která
instrukce je pro daný pøíkaz <strong>switch</strong> vykonána efektivnìji nebo
která je reprezentována krat¹ím bajtkódem (to zále¾í pøedev¹ím na tom, jaké
konstanty jsou uvedeny u jednotlivých vìtví <strong>case</strong>, jak si to
ostatnì uká¾eme na demonstraèních pøíkladech). V&nbsp;<i>J2SE 5.0</i> byly
mo¾nosti øídicí konstrukce <strong>switch</strong> ve dvou smìrech roz¹íøeny.
Kromì primitivních datových typù <i>byte</i>, <i>short</i>, <i>int</i> a
<i>char</i> byla pøidána i podpora pro instance obalových tøíd tìchto typù,
tj.&nbsp;pro instance tøíd <i>Character</i>, <i>Byte</i>, <i>Short</i> a
<i>Integer </i>. Tato podpora samozøejmì souvisí s&nbsp;autoboxingem a
unboxingem, co¾ jsou takté¾ nové vlastnosti <i>J2SE 5.0</i>. Ov¹em mnohem
u¾iteènìj¹í bylo roz¹íøení pøíkazu <strong>switch</strong> o výètový typ
(<i>enumeration &ndash; enum</i>), díky èemu¾ bylo mo¾né mnoho algoritmù zapsat
èitelnìj¹ím a takté¾ bezpeènìj¹ím zpùsobem, proto¾e se z&nbsp;programù mohly
odstranit typovì nezabezpeèené &bdquo;magické konstanty&ldquo;.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Struktura instrukce <strong>tableswitch</strong></h2>

<p>První instrukcí, která slou¾í k&nbsp;implementaci pøíkazu
<strong>switch</strong>, je instrukce nazvaná <strong>tableswitch</strong>. Na
rozdíl od v¹ech instrukcí, které jsme si v&nbsp;tomto seriálu a¾ doposud
popsali, je instrukce <strong>tableswitch</strong> pomìrnì slo¾itá a
variabilní, u¾ jen z&nbsp;toho dùvodu, ¾e je její délka promìnná. Operaèní kód
instrukce <strong>tableswitch</strong> má hodnotu <strong>0xAA</strong>. Za
operaèním kódem mohou následovat a¾ tøi &bdquo;výplòové bajty mající nulovou
hodnotu (teoreticky je sice jejich hodnota libovolná, ale JVM provádí kontrolu,
zda se skuteènì jedná o nuly). Tyto bajty slou¾í k&nbsp;tomu, aby byly dal¹í
údaje zarovnané na adresách dìlitelných ètyømi (tj.&nbsp;provádí se zarovnání
na 32 bitù, a to v¾dy v&nbsp;rámci tìla metody, nikoli v&nbsp;rámci celého
bajtkódu!). Jde o první ukázku výjimeènosti instrukcí
<strong>tableswitch</strong> a <strong>lookupswitch</strong>, proto¾e ¾ádné
dal¹í instrukce virtuálního stroje Javy zarovnání nevyu¾ívají ani
nepo¾adují.</p>

<p>Za nula a¾ tøemi výplòovými bajty se nachází 32bitová hodnota pøedstavující
<i>offset</i> skoku pro vìtev <strong>default</strong>, popø.&nbsp;offset první
instrukce umístìné ZA pøíkazem <strong>switch</strong> v&nbsp;pøípadì, ¾e vìtev
<strong>default</strong> není uvedena. Pozor: jedná se skuteènì o offset,
tj.&nbsp;o relativní adresu poèítanou od pozice operaèního kódu instrukce
<strong>tableswitch</strong>. Offset musí být v¾dy vìt¹í ne¾ nula a navíc je
z&nbsp;praktických dùvodù délka metod omezena na 65536 bajtù, co¾ znamená i
omezení velikosti offsetu v&nbsp;reálných bajtkódech na ¹estnáctibitové kladné
hodnoty. Dal¹ími údaji uvedenými u instrukce <strong>tableswitch</strong> jsou
32bitové hodnoty <i>low</i> a <i>high</i> pøedstavující nejmen¹í a nejvìt¹í
hodnoty pou¾ité ve vìtvích <strong>case</strong>. Následuje sekvence 32bitových
offsetù adres pro jednotlivé vìtve <strong>case</strong>; tìchto offsetù je
celkem <i>high-low+1</i>. Pokud se napøíklad v&nbsp;pøíkazu
<strong>switch</strong> pou¾ijí vìtve s&nbsp;konstantami 10, 11 a 12, je
hodnota <i>low</i> nastavena na 10, hodnota <i>high</i> nastavena na 12 a
offsety jsou v&nbsp;tabulce ulo¾eny celkem tøi, proto¾e 12-10+1=3:</p>

<pre>
1. operaèní kód
2. výplòové bajty
3. offset pro vìtev default
4. hodnota low (nejmen¹í pou¾itá konstanta ve vìtvích case)
5. hodnota high (nejvìt¹í pou¾itá konstanta ve vìtvích case)
6. offset pro vìtev #1
7. offset pro vìtev #2
8. offset pro vìtev #3
...
...
...
</pre>

<p>Instrukce <strong>tableswitch</strong> je pou¾itelná pouze v&nbsp;tìch
pøípadech, kdy se ve vìtvích <strong>case</strong> pou¾ívají celoèíselné
konstanty tvoøící nepøeru¹enou sekvenci. V&nbsp;tomto pøípadì virtuální stroj
Javy nejprve získá ze zásobníku operandù èíselný operand, odeète od nìj hodnotu
<i>low</i> a získá tak <i>index</i>, který následnì pou¾ije pøi pøístupu do
tabulky offsetù ulo¾enou za operaèním kódem instrukce
<strong>tableswitch</strong>. Pokud je hodnota získaná ze zásobníku operandù
men¹í ne¾ <i>low</i> nebo naopak vìt¹í ne¾ <i>high</i>, provede se skok na
vìtev <strong>default</strong>. Dùle¾itá je efektivita výpoètu adresy skoku,
která je v&nbsp;tomto pøípadì obecnì vìt¹í, ne¾ pøi pou¾ití podmínìných skokù
pou¾itých v&nbsp;pøedchozích dvou pøíkladech a dokonce i vìt¹í, ne¾ je tomu u
instrukce <strong>lookupswitch</strong>. Programátoøi mohou tuto znalost vyu¾ít
ve svùj prospìch pro dosa¾ení vy¹¹ího výkonu aplikací, proto¾e v&nbsp;nìkterých
pøípadech je výhodné doplnit do zdrojového textu &bdquo;prázdné&ldquo; vìtve a
docílit tak toho, ¾e se vyu¾ije instrukce <strong>tableswitch</strong> namísto
del¹í a pomalej¹í instrukce <strong>lookupswitch</strong>.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Pøíklad vyu¾ití instrukce <strong>tableswitch</strong></h2>

<p>Jak je <a href="#k04">z&nbsp;pøedchozího popisu</a> zøejmé, je formát
instrukce <strong>tableswitch</strong> skuteènì pomìrnì slo¾itý. Proto si teï
uká¾eme nejenom to, jakým zpùsobem je tato instrukce vygenerována
v&nbsp;bajtkódu, ale takté¾ její obsah získaný z&nbsp;hexa editoru, popøípadì
nástrojem typu <i>xxd</i>:</p>

<pre>
class Test3 {
&nbsp;
    static char simpleSwitch(int x) {
        switch (x) {
            case 10: return 'a';
            case 11: return 'b';
            case 12: return 'c';
            case 13: return 'd';
            case 14: return 'e';
            default: return ' ';
        }
    }
&nbsp;
}
</pre>

<p>Bajtkód vygenerovaný pøekladaèem <strong>javac</strong> obsahuje na zaèátku
instrukci <strong>iload_0</strong> zaji¹»ující ulo¾ení hodnoty parametru metody
na zásobník operandù. Druhou instrukcí je ji¾ popisovaná instrukce
<strong>tableswitch</strong> se ¹esti skoky &ndash; pìti vìtvemi
<strong>case</strong> a jednou vìtví <strong>default</strong>:</p>

<pre>
static char simpleSwitch(int);
  Code:
   0:   iload_0
   1:   tableswitch{ //10 to 14
                10: 36;
                11: 39;
                12: 42;
                13: 45;
                14: 48;
                default: 51 }
&nbsp;
   36:  bipush  97
   38:  ireturn
&nbsp;
   39:  bipush  98
   41:  ireturn
&nbsp;
   42:  bipush  99
   44:  ireturn
&nbsp;
   45:  bipush  100
   47:  ireturn
&nbsp;
   48:  bipush  101
   50:  ireturn
&nbsp;
   51:  bipush  32
   53:  ireturn
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Bajtkód instrukce <strong>tableswitch</strong> pod lupou hexa editoru</h2>

<p>Nyní se podívejme na zpùsob zakódování binární podoby instrukce
<strong>tableswitch</strong> v&nbsp;bajtkódu. Pøi prùzkumu bajtkódu v&nbsp;hexa
editoru lze snadno zjistit, ¾e bajty tvoøící tìlo metody
<strong>simpleSwitch</strong> zaèínají následující sekvencí hodnot:</p>

<pre>
1a aa 00 00 00 00 00 32 00 00 00 0a 00 00 00 0e
00 00 00 23 00 00 00 26 00 00 00 29 00 00 00 2c
00 00 00 2f .. .. .. .. .. .. .. .. .. .. .. ..
</pre>

<p><ins>Poznámka: hexadecimální výpis obsahu bajtkódu zajistí pøíkaz
<strong>xxd -g 1 test.class</strong> s&nbsp;pøípadným pøesmìrováním výstupu do
souboru. Popøípadì je mo¾né soubor test.class otevøít v&nbsp;interním
prohlí¾eèi Midnight Commanderu a stlaèit klávesu F4.</ins></p>

<p>Na základì informací uvedených v&nbsp;pøedchozí kapitole je mo¾né tuto
sekvenci hodnot s&nbsp;trochou úsilí dekódovat. První bajt je operaèním kódem
instrukce <strong>iload_0</strong>, tak¾e je pro nás v&nbsp;tuto chvíli
nezajímavý. Ihned po nìm následuje operaèní kód instrukce
<strong>tableswitch</strong>, tj.&nbsp;hodnota 0xaa, za ní¾ jsou ulo¾eny dva
výplòové bajty, které zarovnávají dal¹í hodnoty na 32 bitù. Poté mù¾eme
v&nbsp;bajtkódu nalézt offset pro vìtev <strong>default</strong>, hodnoty
<i>low</i> a <i>high</i> a koneènì tabulku pìti hodnot, v&nbsp;nich¾ jsou
ulo¾eny offsety adres jednotlivých vìtví pøíkazu <strong>switch</strong>:</p>

<pre>
1a             // operaèní kód instrukce iload_0 - není souèástí tableswitche!
&nbsp;         
aa             // operaèní kód instrukce tableswitch
00 00          // dvojice výplòových bajtù
00 00 00 32    // offset pro vìtev default je 0x32=50, reálná adresa je 51
00 00 00 0a    // hodnota low je nastavena na 0x0a = 10 desítkovì
00 00 00 0e    // hodnota high je nastavena na 0x0e = 14 desítkovì
00 00 00 23    // offset první vìtve je 0x23 = 35, reálná adresa je 36
00 00 00 26    // offset druhé vìtve je 0x26 = 38, reálná adresa je 39
00 00 00 29    // offset tøetí vìtve je 0x29 = 41, reálná adresa je 42
00 00 00 2c    // offset ètvrté vìtve je 0x2c = 44, reálná adresa je 45
00 00 00 2f    // offset páté vìtve je 0x2f = 47, reálná adresa je 48
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Struktura instrukce <strong>lookupswitch</strong></h2>

<p>Druhá instrukce pou¾ívaná v&nbsp;bajtkódu pro implementaci pøíkazu
<strong>switch</strong> je instrukce nazvaná <strong>lookupswitch</strong>.
Struktura této instrukce se èásteènì podobá ji¾ popsané instrukci
<strong>tableswitch</strong>, ov¹em s&nbsp;tím rozdílem, ¾e se namísto pole
jednotlivých offsetù pou¾ívá vyhledávací tabulka obsahující dvojici
<i>hodnota_vìtve_case:offset</i>, tak¾e je délka instrukce obecnì vìt¹í, ov¹em
zato obecnìj¹í. Pojïme si tedy strukturu instrukce
<strong>lookupswitch</strong> popsat podrobnìji. Operaèní kód této instrukce je
roven hodnotì 0xAB. Za operaèním kódem mù¾e následovat nula a¾ tøi výplòové
bajty (co¾ ji¾ známe z&nbsp;pøedchozích kapitol). Po pøípadných výplòových
bajtech je ulo¾en 32bitový offset pro vìtev <strong>default</strong>. A¾
doposud se tedy struktura instrukce <strong>lookupswitch</strong> podobala
struktuøe instrukce <strong>tableswitch</strong> (samozøejmì a¾ na rozdílný
operaèní kód).</p>

<p>Ov¹em nyní ji¾ nastává zmìna, proto¾e dal¹ím údajem je 32bitová hodnota
<i>npairs</i>, která obsahuje poèet vìtví <strong>case</strong> (tento údaj
nemusel být u instrukce <strong>tableswitch</strong> uveden, nebo» ho bylo
mo¾né vypoèítat z&nbsp;hodnot <i>low</i> a <i>high</i>, které v¹ak
v&nbsp;<strong>lookupswitch</strong> nejsou pou¾ity). Dostáváme se ji¾ ke konci
&ndash; za celoèíselným údajem o poètu vìtví následuje <i>npairs</i> párù
<i>hodnota_vìtve_case:offset</i>, pøièem¾ oba prvky tohoto páru jsou
reprezentovány 32bitovými hodnotami. Vzhledem k&nbsp;tomu, ¾e údaj
<i>hodnota_vìtve_case</i> mù¾e být libovolná konstanta typu <i>int</i>, znamená
to, ¾e se pomocí instrukce <strong>lookupswitch</strong> mohou realizovat
prakticky libovolnì konstruované pøíkazy <strong>switch</strong>:</p>

<pre>
1. operaèní kód
2. výplòové bajty
3. offset pro vìtev default
4. hodnota npairs
5. hodnota case + offset pro vìtev #1
6. hodnota case + offset pro vìtev #2
7. hodnota case + offset pro vìtev #3
8. hodnota case + offset pro vìtev #4
...
...
x. hodnota case + offset pro vìtev #npairs
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Pøíklad vyu¾ití instrukce <strong>lookupswitch</strong></h2>

<p>Pøi tvorbì demonstraèního pøíkladu pro instrukci
<strong>lookupswitch</strong> je nutné zajistit, aby konstanty pou¾ité ve
vìtvích <strong>case</strong> netvoøily souvislou øadu celých èísel, proto¾e by
pøekladaè v&nbsp;tomto pøípadì pou¾il &bdquo;optimalizovanou&ldquo; instrukci
<strong>tableswitch</strong>:</p>

<pre>
class Test5 {
&nbsp;
    static char simpleSwitch(int x) {
        switch (x) {
            case 0:    return 'a';
            case 10:   return 'b';
            case 64:   return 'c';
            case 99:   return 'd';
            case 6502: return 'e';
            default:   return ' ';
        }
    }
&nbsp;
}
</pre>

<p>Bajtkód vygenerovaný pøekladaèem <strong>javac</strong> obsahuje na zaèátku
opìt instrukci <strong>iload_0</strong> zaji¹»ující ulo¾ení hodnoty parametru
metody na zásobník operandù. Druhou instrukcí je <strong>lookupswitch</strong>
se ¹esti skoky &ndash; pìti vìtvemi <strong>case</strong> a jednou vìtví
<strong>default</strong>:</p>

<pre>
static char simpleSwitch(int);
  Code:
   0:   iload_0
   1:   lookupswitch{ //5
        0:    52;
        10:   55;
        64:   58;
        99:   61;
        6502: 64;
        default: 67 }
   52:  bipush  97
   54:  ireturn
   55:  bipush  98
   57:  ireturn
   58:  bipush  99
   60:  ireturn
   61:  bipush  100
   63:  ireturn
   64:  bipush  101
   66:  ireturn
   67:  bipush  32
   69:  ireturn
</pre>

<p>Asi ji¾ tu¹íte, co bude následovat: podíváme se na zpùsob ulo¾ení binárního
tvaru instrukce <strong>lookupswitch</strong> v&nbsp;bajtkódu. Ten vypadá
následovnì:</p>

<pre>
ab 00 00 00 00 00 42 00 00 00 05 00 00 00 00 00
00 00 33 00 00 00 0a 00 00 00 36 00 00 00 40 00
00 00 39 00 00 00 63 00 00 00 3c 00 00 19 66 00
00 00 3f
</pre>

<p>Tuto sekvenci bajtù lze ji¾ relativnì snadno analyzovat:</p>

<pre>
aa                         // operaèní kód instrukce tableswitch
00 00                      // dvojice výplòových bajtù
00 00 00 42                // offset pro vìtvi default je 0x42 = 66, reálná adresa = 67
00 00 00 05                // hodnota npairs: poèet párù hodnota_case:offset
00 00 00 00   00 00 00 33  // case 0:    - offset 0x33=51, reálná adresa = 52
00 00 00 0a   00 00 00 36  // case 10:   - offset 0x36=54, reálná adresa = 55
00 00 00 40   00 00 00 39  // case 64:   - offset 0x39=57, reálná adresa = 58
00 00 00 63   00 00 00 3c  // case 99:   - offset 0x3c=60, reálná adresa = 61
00 00 19 66   00 00 00 3f  // case 6502: - offset 0x3f=63, reálná adresa = 64
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Root.cz: Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM<br />
<a href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/</a></a>
</li>

<li>Root.cz: JamVM aneb alternativa k HotSpotu nejenom pro embedded zaøízení a chytré telefony<br />
<a href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>FindBugs<br />
<a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a>
</li>

<li>GNU Classpath<br />
<a href="www.gnu.org/s/classpath/">www.gnu.org/s/classpath/</a></li>

<li>Java VMs Compared<br />
<a href="http://bugblogger.com/java-vms-compared-160/">http://bugblogger.com/java-vms-compared-160/</a>
</li>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>CloseableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html">http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

