<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Clojure aneb jazyk umo¾òující tvorbu bezpeèných vícevláknových aplikací pro JVM (2.èást)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Clojure aneb jazyk umo¾òující tvorbu bezpeèných vícevláknových aplikací pro JVM (2.èást)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;dne¹ní èásti seriálu o programovacím jazyku Java i o virtuálním stroji Javy budeme pokraèovat v&nbsp;popisu programovacího jazyka Clojure. Seznámíme se pøedev¹ím s&nbsp;tím, jakým zpùsobem se v&nbsp;<i>Clojure</i> pracuje se slo¾enými formami a takté¾ s&nbsp;formami speciálními, proto¾e právì to pøedstavuje ústøední souèást tohoto programovacího jazyka.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Clojure aneb jazyk umo¾òující tvorbu bezpeèných vícevláknových aplikací pro JVM (2.èást)</a></p>
<p><a href="#k02">2. Symboly a &bdquo;keywords&ldquo;</a></p>
<p><a href="#k03">3. Slo¾ené formy aneb sémantika zápisu kolekcí</a></p>
<p><a href="#k04">4. Pøíklad konstrukce kolekcí v&nbsp;jazyku Clojure</a></p>
<p><a href="#k05">5. Vlastnosti spoleèné v¹em typùm kolekcí</a></p>
<p><a href="#k06">6. Seznam jako forma zápisu programù aneb kód==data</a></p>
<p><a href="#k07">7. Demonstraèní pøíklady: aritmetické funkce (prefixový zápis operátorù)</a></p>
<p><a href="#k08">8. Speciální formy</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Clojure aneb jazyk umo¾òující tvorbu bezpeèných vícevláknových aplikací pro JVM (2.èást)</h2>

<p>V&nbsp;pøedchozí èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">tohoto
seriálu</a> jsme si øekli základní informace o programovacím jazyku
<i>Clojure</i> i o zpùsobu jeho pou¾ití v&nbsp;rámci aplikací bì¾ících nad
virtuálním strojem Javy &ndash; JVM (<i>Clojure</i> ov¹em ji¾ dnes existuje i
ve variantì urèené pro <i>CLI</i> a dokonce i ve variantì pøekládané do
<i>JavaScriptu</i>, který je nìkterými autory pova¾ovaný za &bdquo;assembler
pro web&ldquo;). Pøipomeòme si, ¾e se v&nbsp;pøípadì <i>Clojure</i> jedná o
programovací jazyk, jeho¾ koøeny mù¾eme hledat v&nbsp;<i>LISPu</i> a obecnì ve
funkcionálních programovacích jazycích. Programy napsané v&nbsp;<i>Clojure</i>
jsou automaticky pøekládány do bajtkódu JVM a posléze jsou vykonávány naprosto
stejným zpùsobem, jako bajtkód získaný pøekladem programu napsaného
v&nbsp;<i>Javì</i>, <i>Scale</i> atd. Díky tomu nemusí být
v&nbsp;<i>Clojure</i> implementován ani optimalizující pøekladaè (pøeklad do
nativního kódu je zále¾itostí JITu) ani vyhrazený správce pamìti, proto¾e
v¹echna data, s&nbsp;nimi¾ <i>Clojure</i> manipuluje, jsou ukládána na haldu
(<i>heap</i>) spravovanou nìkterým ze správcù pamìti (GC), které jsou dostupné
v&nbsp;JVM.</p>

<p>Díky tomu, ¾e v¹echny objekty jsou ulo¾eny na haldì, je takté¾ mo¾né
relativnì snadno oboustrannì komunikovat mezi kódem napsaným v&nbsp;<i>Javì</i>
(a pou¾ívajícím tedy napøíklad tøídy implementující rozhraní <i>Collection</i>
èi <i>Map</i>) a kódem napsaným v&nbsp;<i>Clojure</i>, kde se dosti intenzivnì
vyu¾ívají seznamy, vektory, mapy a mno¾iny. Minule jsme si takté¾ øekli, jakým
zpùsobem je mo¾né spustit smyèku <i>REPL</i> programovacího jazyka
<i>Clojure</i>. <i>REPL</i> budeme pou¾ívat i ve v¹ech dnes uvedených
demonstraèních pøíkladech. Smyèka <i>REPL</i> oèekává, ¾e u¾ivatel bude na
standardní vstup zapisovat takzvané <i>formy (form)</i> (v&nbsp;jiných jazycích
se vìt¹inou pou¾ívá termín &bdquo;výraz&ldquo;), pøièem¾ ka¾dá forma je
nejdøíve zkontrolována na korektní zápis, potom je vyhodnocena a následnì je na
standardní výstup zapsána hodnota, na kterou se forma vyhodnotila. Tato hodnota
získaná vyhodnocením formy mù¾e být jakéhokoli podporovaného typu, mù¾e se tedy
jednat jak o èíslo, tak i o seznam èi klidnì i o funkci (co¾ není
v&nbsp;<i>Clojure</i> tak neobvyklé, jak by se mo¾ná mohlo zdát).</p>

<p>V&nbsp;programovacím jazyku <i>Clojure</i> existují ètyøi základní typy
forem:</p>


<ol>
<li>literály (numerické hodnoty, pravdivostní hodnoty, znaky, øetìzce; vyhodnocují se samy na sebe)</li>
<li>symboly a takzvaná &bdquo;klíèová hesla&ldquo; (<i>keywords</i>)</li>
<li>slo¾ené formy (seznamy, vektory, mno¾iny a mapy, seznamy mají navíc zvlá¹tní postavení kvùli zpùsobu svého vyhodnocení)</li>
<li>speciální formy (podobají se slo¾eným formám &ndash; seznamùm, ale internì se vyhodnocují odli¹ným zpùsobem)</li>
</ol>



<p><a name="k02"></a></p>
<h2 id="k02">2. Symboly a &bdquo;keywords&ldquo;</h2>

<p>Nejjednodu¹¹í typ formy &ndash; <i>literály</i> &ndash; jsme si ji¾ popsali
minule, tak¾e se pojïme vìnovat dal¹ím tøem typùm forem. Druhým typem formy
podporovaným programovacím jazykem <i>Clojure</i> jsou takzvané <i>symboly</i>
známé u¾ z&nbsp;<i>LISPu</i>, ke kterým se v&nbsp;<i>Clojure</i> je¹tì
pøidávají <i>keywords</i>. Zaènìme s&nbsp;popisem &bdquo;keywords&ldquo;.
Pøeklad tohoto slova je ponìkud problematický kvùli jeho dvojímu významu
(alespoò v&nbsp;programování), tak¾e se pokusím pou¾ívat sousloví
&bdquo;klíèová hesla&ldquo;, proto¾e termín &bdquo;keywords&ldquo;
v&nbsp;<i>Clojure</i> <strong>ne</strong>znamená, ¾e by se jednalo o
rezervovaná klíèová slova jazyka. Klíèová hesla jsou na pou¾ití jednodu¹¹í ne¾
symboly, proto¾e se ve smyèce <i>REPL</i> vyhodnocují samy na sebe a nemù¾e jim
být pøiøazena ¾ádná hodnota. Na co se tedy vlastnì v&nbsp;praxi tento typ formy
hodí? Jedním z&nbsp;dùvodù zavedení tohoto typu formy do programovacího jazyka
<i>Clojure</i> byla podpora pro datového typu (kolekce) <i>mapa</i>,
v&nbsp;nìm¾ je mo¾né uchovávat dvojice klíè:hodnota. A jako klíè jsou
s&nbsp;výhodou pou¾ívána právì klíèová hesla, proto¾e jejich hodnotu nelze
mìnit a navíc se jejich he¹ovací hodnota mù¾e vypoèítat pouze jedenkrát.
Smyèka <i>REPL</i> pozná, ¾e u¾ivatel pou¾ívá klíèové heslo z&nbsp;toho, ¾e je
tìsnì pøed ním napsána dvojteèka. Jak ji¾ bylo øeèeno vý¹e, vyhodnotí se heslo
na sebe samu:</p>

<pre>
user=&gt; :x
:x
</pre>

<pre>
user=&gt; :jine_heslo
:jine_heslo
</pre>

<pre>
user=&gt; :dalsi-heslo
:dalsi-heslo
</pre>

<pre>
user=&gt; :jeste.jine.heslo
:jeste.jine.heslo
</pre>

<p>Ve skuteènosti je dvojteèka uvádìná pøed klíèovým heslem jen syntaktickým
cukrem, proto¾e &bdquo;plný&ldquo; zápis (v&nbsp;tomto pøípadì speciální) formy
pøedstavující klíèové heslo vypadá takto:</p>

<pre>
user=&gt; (keyword "jine_heslo")
:jine_heslo
</pre>

<p>Podobným typem formy jsou <i>symboly</i>, pøed jejich¾ jménem se pou¾ívá
ampersand. Symbolùm mù¾e být pøiøazena hodnota a z&nbsp;tohoto dùvodu se
pou¾ívají pro pojmenování funkcí, promìnných èi jmenných prostorù. Se symboly
se je¹tì v&nbsp;tomto èlánku nìkolikrát setkáme, nyní si tedy jen uka¾me, jak
se symboly zapisují a jak je smyèka <i>REPL</i> vyhodnotí:</p>

<pre>
user=&gt; 'toto-je-symbol
toto-je-symbol
</pre>

<p>(pov¹imnìte si, ¾e po vyhodnocení v&nbsp;<i>REPL</i> &bdquo;zmizí&ldquo;
apostrof pùvodnì uvedený pøed jménem symbolu)</p>

<p>Podobnì jako dvojteèka byla pouze syntaktickým cukrem pro speciální formu
(keyword "xxx"), je i ampersand zkrácenou podobou speciální formy (quote
symbol). Pøedchozí pøíklad by tedy ¹el zapsat i následujícím zpùsobem:</p>

<pre>
user=&gt; (quote toto-je-symbol)
toto-je-symbol
</pre>

<p>To, ¾e se v&nbsp;obou pøípadech jedná skuteènì o stejný symbol, lze zjistit
s&nbsp;vyu¾itím funkce ekvivalence (zde ji¾ tro¹ku pøedbíháme, tak¾e se prosím
k&nbsp;pøíkladu vra»te po doètení celého èlánku):</p>

<pre>
user=&gt;(= 'toto-je-symbol (quote toto-je-symbol))
true
</pre>

<p>Zatím je to pomìrnì nuda, ¾e? Ale u¾ se pomalu dostáváme k&nbsp;dal¹í
dvojici forem &ndash; slo¾eným formám a speciálním formám &ndash; jejich¾
vyhodnocování pøedstavuje srdce programovacího jazyka <i>Clojure</i>.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Slo¾ené formy aneb sémantika zápisu kolekcí</h2>

<p>V&nbsp;této kapitole si popí¹eme takzvané <i>slo¾ené formy</i>, proto¾e
právì tyto formy pøedstavují, spoleènì s&nbsp;formami speciálními, jeden
z&nbsp;nejdùle¾itìj¹ích prvkù jazyka <i>Clojure</i> (a podobnì i pùvodního
<i>LISPu</i>). V&nbsp;tradièním <i>LISPu</i> je slo¾enou formou pøedev¹ím
seznam (<i>list</i>), co¾ je ov¹em jen zjednodu¹enì zapsaný øetìzec takzvaných
teèka-dvojic. Koncept teèka-dvojic byl v&nbsp;<i>Clojure</i> opu¹tìn (samotný
znak teèky zde dostal jiný význam &ndash; volání metod Javy), ov¹em
k&nbsp;seznamùm navíc pøibyly i dal¹í zpùsoby zápisu slo¾ených forem, které se
pou¾ívají (opìt v&nbsp;podstatì jako syntaktický cukr) pro zápis následujících
datových struktur: vektoru (<i>vector</i>), mno¾iny (<i>set</i>) a mapy
(<i>map</i>). V¹echny ètyøi typy slo¾ených forem (budeme je dále nazývat
<i>kolekce</i>), a» ji¾ se jedná o seznam, vektor, mno¾inu èi mapu, jsou
z&nbsp;obou stran uvozeny závorkami, pøièem¾ musí být zachována párovost
závorek (ke ka¾dé otevírací závorce pøíslu¹í jedna závorka uzavírací), která je
kontrolována pøed vyhodnocením slo¾ené formy ve smyèce <i>REPL</i>.</p>

<p>V&nbsp;pøedchozím textu bylo napsáno, ¾e základním typem slo¾ené formy je
seznam (<i>list</i>), jeho¾ prvky se ji¾ tradiènì (více ne¾ padesát let!)
zapisují do kulatých závorek. Pro zápis vektorù (<i>vector</i>) se pou¾ívají
hranaté závorky, mapy (<i>map</i>) vyu¾ívají závorky slo¾ené a mno¾iny
(<i>set</i>) takté¾ závorky slo¾ené, ov¹em pøed otevírací závorkou se musí
napsat køí¾ek (hash, #). V&nbsp;následující tabulce jsou vypsány v¹echny ètyøi
typy slo¾ených forem. Kromì seznamù lze ostatní tøi slo¾ené formy (vektory,
mapy, mno¾iny) vytvoøit i pomocí vhodného konstruktoru (tøetí sloupec), ov¹em
pøesný význam tohoto zápisu si uvedeme a¾ v&nbsp;následujících kapitolách:</p>

<table>
<tr><th>Typ kolekce</th><th>Zápis (syntaktický cukr)</th><th>Konstruktor</th></tr>
<tr><td>Seznam </td><td>(prvky)</td><td>(prvky)</td></tr>
<tr><td>Vektor </td><td>[prvky]</td><td>(vector prvky)</td></tr>
<tr><td>Mapa   </td><td>{dvojice klíè-hodnota}</td><td>(hash-map dvojice klíè-hodnota)</td></tr>
<tr><td>Mno¾ina</td><td>#{unikátní prvky}</td><td>(hash-set unikátní prvky)</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Pøíklad konstrukce kolekcí v&nbsp;jazyku Clojure</h2>

<p>V&nbsp;tabulce zobrazené <a href="#k03">v&nbsp;pøedchozí kapitole</a> byl
obsah v¹ech ètyø typù kolekcí popsán jen velmi vágnì slovem
&bdquo;prvky&ldquo;, proto asi ètenáøe bude zajímat, jaké prvky v&nbsp;nich
mohou být ulo¾eny. Mù¾e se jednat jak o literály (popsané v&nbsp;pøedchozí
èásti tohoto seriálu), symboly, klíèová hesla, tak i &ndash; co¾ je
nejzajímavìj¹í &ndash; o jiné kolekce. Není tedy vùbec neobvyklé pracovat
napøíklad se seznamy ulo¾enými v&nbsp;jiných seznamech, s&nbsp;mapami
(v&nbsp;podstatì se strukturami èi záznamy), v&nbsp;nich¾ jsou ulo¾eny vektory
atd. Vzhledem k&nbsp;tomu, ¾e <i>Clojure</i> je dynamicky typovaným
programovacím jazykem, lze v&nbsp;jakémkoli okam¾iku získat typ ka¾dého prvku
ulo¾eného v&nbsp;kolekci. Jak se to ve skuteènosti provádí si vysvìtlíme
v&nbsp;èásti vìnované predikátùm. Podívejme se nyní na nìkolik demonstraèních
pøíkladù, kde u ka¾dého pøíkladu bude vysvìtleno, co se vlastnì provádí a
z&nbsp;jakého dùvodu <i>Clojure</i> nìkterý typ formy nedoká¾e zpracovat:</p>

<p>Seznamy musí být uvozeny ampersandem, tj.&nbsp;syntaktickým cukrem pro
speciální formu <strong>quote</strong>. Dùvod si vysvìtlíme a¾ za chvíli:</p>

<pre>
user=&gt; '(1 2 3 4)
(1 2 3 4)
</pre>

<p>Prázdný seznam:</p>

<pre>
user=&gt; '()
()
</pre>

<p>Seznam obsahující dal¹í seznamy (zde jde vlastnì o nevyvá¾ený binární
strom):</p>

<pre>
user=&gt; '(1 (2 (3 (4 5))))
(1 (2 (3 (4 5))))
</pre>

<p>Vektor mù¾eme pova¾ovat za pole konstantních prvkù:</p>

<pre>
user=&gt; [1 2 3 4]
[1 2 3 4]
</pre>

<p>Vektor vektorù:</p>

<pre>
user=&gt; [ [1 2 3] [4 5 6] [7 8 9]]
[[1 2 3] [4 5 6] [7 8 9]]
</pre>

<p>Vektor seznamù:</p>

<pre>
user=&gt; [ '(:jedna :dva) '(:tri :ctyri) '(:pet :sest) ]
[(:jedna :dva) (:tri :ctyri) (:pet :sest)]
</pre>

<p>Typická mapa:</p>

<pre>
user=&gt; {:prvni 1, :druhy 2}
{:druhy 2, :prvni 1}
</pre>

<p>Ve skuteènosti se èárky za dvojicemi klíè-hodnota nemusí zapisovat:</p>

<pre>
user=&gt; {:prvni 1 :druhy 2}
{:druhy 2, :prvni 1}
</pre>

<p>Zápis mapy mù¾e být nìkdy i pomìrnì &bdquo;divoký&ldquo;:</p>

<pre>
user=&gt; {:seznam '(:toto :je :seznam), :vektor [:toto :je :vektor] }
{:seznam (:toto :je :seznam), :vektor [:toto :je :vektor]}
</pre>

<p>Zbývají nám ji¾ jen mno¾iny:</p>

<pre>
user=&gt; #{"toto" "je" "mnozina"}                   
#{"mnozina" "toto" "je"}
</pre>

<p>(pov¹imnìte si toho, ¾e prvky v&nbsp;mno¾inì <strong>nejsou</strong> vypsány
ve stejném poøadí, jak do ní byly vlo¾eny, internì se toti¾ pou¾ívá he¹ovací
tabulka).</p>

<p>Prvky v&nbsp;mno¾inì nesmí být duplikátní!</p>

<p>Kontrolují se samozøejmì shodné hodnoty literálù:</p>

<pre>
user=&gt; #{1 1 3}
IllegalArgumentException Duplicate key: 1  clojure.lang.PersistentHashSet.create
WithCheck (PersistentHashSet.java:68)
</pre>

<p>Øetìzce jsou, jak ji¾ víme, takté¾ literály (zde je duplikován øetìzec
&bdquo;nesmi&ldquo;):</p>

<pre>
user=&gt; #{"nesmi" "mit" "dva" "stejne" "prvky" "skutecne" "nesmi"}
IllegalArgumentException Duplicate key: nesmi  clojure.lang.PersistentHashSet.createWithCheck (PersistentHashSet.java:68)
</pre>

<p><i>Clojure</i> poctivì zkontroluje i ekvivalenci seznamù atd.:</p>

<pre>
user=&gt; #{ '(:stejny :seznam) '(:stejny :seznam) }
IllegalArgumentException Duplicate key: (quote (:stejny :seznam))  clojure.lang.
PersistentHashSet.createWithCheck (PersistentHashSet.java:68)
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Vlastnosti spoleèné v¹em typùm kolekcí</h2>

<p>V¹echny ètyøi typy kolekcí popsaných v&nbsp;pøedchozích dvou kapitolách,
mají nìkolik spoleèných vlastností, které &ndash; spoleènì s&nbsp;technikami
popsanými v&nbsp;následujícím textu &ndash; umo¾òují, aby se
v&nbsp;programovacím jazyku <i>Clojure</i> mohly pomìrnì snadno vytváøet
vícevláknové programy. Základní vlastností spoleènou v¹em ètyøem typùm kolekcí
je jejich <i>nemìnitelnost (immutability)</i>. To znamená, ¾e ji¾ ve chvíli,
kdy je kolekce vytvoøena, je po celou dal¹í dobu její existence v&nbsp;bì¾ícím
programu urèen její obsah, tj.&nbsp;hodnoty v¹ech prvkù kolekce. Na první
pohled to sice mo¾ná mù¾e vypadat zvlá¹tnì, ale i s&nbsp;takto se chovajícími
kolekcemi je mo¾né v&nbsp;reálným programech pracovat a to dokonce velmi
efektivním zpùsobem. Ostatnì i ve standardní knihovnì programovacího jazyka
Java existují nìkteré tøídy, jejich¾ instance jsou nemìnné. Typickým a
v¹eobecnì známým pøíkladem jsou øetìzce pøedstavované tøídou
<strong>String</strong>, barvy pøedstavované tøídou <strong>Color</strong> èi
instance tøíd <strong>BigInteger</strong> (celé celé èíslo se znaménkem o
libovolném rozsahu) a <strong>BigDecimal</strong> (racionální èíslo o libovolné
pøesnosti).</p>

<p>Kromì nemìnitelnosti (<i>immutability</i>) je dal¹í spoleènou vlastností
v¹ech ètyø typù kolekcí jejich <i>persistence</i>. Vìt¹ina standardních funkcí
poskytovaná programovacím jazykem <i>Clojure</i> se toti¾ sna¾í o to, aby
jednou vytvoøené sekvence (dejme tomu seznam) byly znovupou¾ity i
v&nbsp;pøípadì, ¾e je vytvoøen nový seznam, který v&nbsp;sobì obsahuje i seznam
star¹í (ten stále existuje a mohou na nìj existovat reference pou¾ívané
napøíklad i v&nbsp;jiných paralelnì bì¾ících vláknech). Vzhledem k&nbsp;tomu,
¾e se obsah starého seznamu nemù¾e zmìnit (seznam je nemìnitelný), mù¾e
napøíklad funkce <strong>cons</strong> známá ji¾ z&nbsp;<i>LISPu</i> jednodu¹e
k&nbsp;seznamu pøidat nový první prvek (<i>head</i>) s&nbsp;tím, ¾e tento prvek
ukazuje na pùvodní seznam &ndash; jinými slovy není nutné, alespoò v&nbsp;tomto
pøípadì, vytváøet kopii (a» ji¾ plytkou èi hlubokou) pùvodního seznamu, co¾
pøispívá k&nbsp;tomu, ¾e mnohé operace nad kolekcemi jsou ve skuteènosti velmi
rychlé, i kdy¾ by se podle jejich popisu mohlo zdát, ¾e jejich implementace
vy¾aduje provedení èasovì slo¾itých operací.</p>

<p>Podobnì funkce <strong>pop</strong>, kterou skalní LISPaøi pravdìpodobnì
znají pod názvem <strong>cdr</strong>, vrátí &bdquo;nový&ldquo; seznam
vytvoøený z&nbsp;pùvodního seznamu takovým zpùsobem, ¾e se z&nbsp;nìj
&bdquo;odstraní&ldquo; první prvek &ndash; ve skuteènosti se v¹ak ¾ádný nový
seznam nevytváøí a ji¾ vùbec se nikde ¾ádný prvek neodstraòuje, pouze se
jednodu¹e vrátí reference na druhý prvek pùvodního seznamu, popø. prázdný
seznam <strong>()</strong>, pokud ¾ádný druhý prvek v&nbsp;seznamu ulo¾en
není:</p>

<pre>
user=&gt; (pop '("prvni" "druhy" "treti"))
("druhy" "treti")
</pre>

<pre>
user=&gt;(pop '("prvni"))
()
</pre>

<pre>
user=&gt;(pop '("prvni" '("dalsi" "seznam")))
((quote ("dalsi" "seznam")))
</pre>

<p>Tøetí spoleènou vlastností v¹ech ètyø typù kolekcí je to, ¾e se
v&nbsp;ka¾dém pøípadì v¾dy správnì vyhodnotí jejich ekvivalence èi
neekvivalence, nezávisle na tom, jakým zpùsobem kolekce vznikla &ndash;
<i>Clojure</i> v&nbsp;tomto pøípadì nemù¾e pouze jednodu¹e porovnat rovnost
referencí ukazujících na porovnávané kolekce (napøíklad dva seznamy), ale
mnohdy musí rekurzivnì procházet jak samotnými porovnávanými kolekcemi, tak i
jejich prvky, je¾ takté¾ mohou být kolekcemi. Naproti tomu v&nbsp;Javì to není
v¾dy tak jednoduché, jak by se mo¾ná mohlo na první pohled zdát, proto¾e
porovnání dvou objektù vy¾aduje pøekrytí metody
<strong>Object.equals()</strong> a tím pádem i detailní znalost interních
struktur porovnávaných objektù.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Seznam jako forma zápisu programù aneb kód==data</h2>

<p>Seznamy, tj.&nbsp;jeden ze ètyø podporovaných typù kolekcí, mají
v&nbsp;programovacím jazyku <i>Clojure</i> je¹tì jeden dosti zásadní význam.
Samotný program zapsaný v&nbsp;<i>Clojure</i> není toti¾ nic jiného ne¾ seznam
(èi seznamy), pøièem¾ prvním prvkem seznamu je jméno funkce a zbylé prvky
seznamu jsou chápány jako parametry této funkce. Pøíkladem mù¾e být napøíklad
funkce <strong>println</strong>, která vypí¹e obsah svých parametrù na
standardní výstup a posléze je provedeno odøádkování. Klasický program typu
&bdquo;Hello world&ldquo; by tedy mohl v&nbsp;<i>Clojure</i> vypadat
následovnì:</p>

<pre>
user=&gt; (println "Hello" "world")
Hello world
</pre>

<p>Funkce samozøejmì mohou vracet i nìjaké výsledky, co¾ nám umo¾òuje zapisovat
program funkcionálním stylem &ndash; tedy jako funkci, její¾ parametry jsou
vyhodnoceny na základì nìjakých jiných funkcí vyhodnocovaných rekurzivnì. Mìjme
napøíklad funkci pojmenovanou + (co¾ je v&nbsp;<i>Clojure</i> korektní jméno
funkce), která provede souèet v¹ech svých parametrù, a dále funkci pojmenovanou
*, která naopak vynásobí v¹echny své parametry. Mù¾eme tedy psát:</p>

<pre>
user=&gt; (+ 1 2 3)
6
</pre>

<p>nebo té¾:</p>

<pre>
user=&gt; (* 6 7)
42
</pre>

<p>Ov¹em takté¾ je mo¾né pou¾ít následující zápis, kdy se nejdøíve vyhodnotí
vnitøní funkce a teprve poté se jejich výsledky pou¾ijí pro násobení:</p>

<pre>
user=&gt; (* (+ 1 2 3) (+ 3 4))
42
</pre>

<p>Pravidla pro vyhodnocení forem jsou v&nbsp;programovacím jazyku
<i>Clojure</i> velmi jednoduchá a pøímoèará, na rozdíl od mnoha jiných
programovacích jazykù. Tato pravidla lze ve zjednodu¹ené podobì sepsat do
nìkolika bodù:</p>

<ol>

<li>èísla, øetìzce, pravdivostní hodnoty a dal¹í literály jsou vyhodnoceny samy
na sebe (co¾ je logické &ndash; jedná se o dále nedìlitelné objekty)</li>

<li>klíèová hesla (<i>keywords</i>) jsou takté¾ vyhodnocována sama na sebe:
výsledkem <strong>:foo</strong> je opìt <strong>:foo</strong>.</li>

<li>hodnotou symbolu je objekt, který je na tento symbol navázán (analogie
z&nbsp;jiných programovacích jazykù &ndash; hodnotou promìnné zapsané svým
jménem je hodnota ulo¾ená do promìnné)</li>

<li>seznamy jsou vyhodnocovány tak, ¾e se první prvek seznamu chápe jako jméno
funkce (èi speciální formy), které je pøedán zbytek seznamu jako parametry této
funkce (formy)</li>

<li>pokud seznam obsahuje podseznamy, jsou tyto podseznamy vyhodnoceny
nejdøíve, pøièem¾ úroveò rekurzivního zanoøování pøi vyhodnocování podseznamù
není teoreticky omezena (tj.&nbsp;podseznamy lze vnoøovat do témìø libovolné
úrovnì)</li>

<li>dal¹í tøi typy kolekcí jsou vyhodnoceny na stejnou kolekci, ov¹em
s&nbsp;tím, ¾e pøípadné seznamy zde ulo¾ené (jako prvky) jsou nejprve
vyhodnoceny podle pøedchozích dvou bodù.</li>

</ol>

<p>Poslední pravidlo mù¾e být mo¾ná tro¹ku nejasné, pojïme si tedy ukázat
jednoduchý pøíklad:</p>

<pre>
user=&gt; [ (+ 1 2) (+ 3 4) (+ 5 6) (+ 7 8)]
[3 7 11 15]
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Demonstraèní pøíklady: aritmetické funkce (prefixový zápis operátorù)</h2>

<p>Vzhledem k&nbsp;tomu, ¾e vyhodnocování seznamù &ndash; volání funkcí &ndash;
pøedstavuje dùle¾itou souèást programovacího jazyka <i>Clojure</i>, uká¾eme si
zpùsob tohoto vyhodnocování na nìkolika demonstraèních pøíkladech.  První øádek
uvedený pod poznámkou (uvozenou znakem <strong>;</strong>) pøedstavuje text
zapsaný u¾ivatelem na klávesnici, øádek druhý vypisuje samotná smyèka
<i>REPL</i> (vynecháváme zde tedy prompt &ndash; výzvu):</p>

<p>Vyhodnocení seznamu obsahujícího jako první prvek funkci:</p>

<pre>
(max 10 20)
20
</pre>

<p>Vyhodnocení seznamu obsahujícího dal¹í seznamy (ka¾dý podseznam samozøejmì znamená volání funkce):</p>

<pre>
(max (min 10 20) (min 30 40))
30
</pre>

<p>Zatímco v&nbsp;naprosté vìt¹inì &bdquo;mainstreamových&ldquo; programovacích
jazykù, jakými jsou napøíklad <i>Céèko</i>, <i>Java</i>, <i>JavaScript</i> èi
<i>Python</i>, se aritmetické a logické výrazy zapisují v&nbsp;takzvané
<i>infixové notaci</i>, pøi ní¾ jsou binární operátory zapisovány mezi dvojici
operandù, tvùrci jazyka <i>Clojure</i> (resp.&nbsp;pøesnìji øeèeno ji¾ tvùrci
<i>LISPu</i>) se od tohoto zpùsobu zápisu distancovali &ndash; namísto toho
jsou v&nbsp;<i>Clojure</i> v¹echny základní aritmetické i logické (a samozøejmì
té¾ relaèní) operace zapisovány jako volání funkcí èi speciálních forem,
tj.&nbsp;v¾dy v&nbsp;<i>prefixové podobì</i>. Dùvodù, proè byla zvolena tato
forma zápisu výrazù, je více. Prvním dùvodem je fakt, ¾e syntaxe <i>LISPu</i>
byla pùvodnì navrhována s&nbsp;tím, ¾e pozdìji dojde k&nbsp;její zmìnì,
tj.&nbsp;samotná syntaxe nebyla pro tvùrce tohoto programovacího jazyka tak
prioritní jako jeho sémantika (paradoxní pøitom je, ¾e se nakonec syntaxe
<i>LISPu</i> nezmìnila, takzvané <strong>M-výrazy</strong> se nedoèkaly vìt¹ího
roz¹íøení, podobnì jako dal¹í snahy o úpravu syntaxe <i>LISPu</i> tak, aby se
eliminovalo mno¾ství závorek èi právì prefixový zápis aritmetických
výrazù).</p>

<p>Druhý dùvod spoèíval v&nbsp;tom, ¾e zavedení infixových operátorù by do
jazyka zavádìlo zbyteèné dal¹í komplikace: musely by se napøíklad øe¹it a
pøesnì specifikovat priority operací (a u nìkterých operací i jejich
asociativita), se zapsanými výrazy by se slo¾itìji provádìly rùzné symbolické
manipulace (integrace, derivace, zjednodu¹ování výrazù), infixové operátory by
nebylo mo¾né pøedávat jako parametry do jiných funkcí atd. Vzhledem
k&nbsp;tomu, ¾e aritmetické operátory jsou zapisovány jako volání funkcí, musí
se znak èi jméno pøíslu¹ného operátoru uvádìt ve vyhodnocovaném seznamu na
prvním místì, podobnì jako jméno jakékoli jiné funkce. V¹echny dílèí podvýrazy
se samozøejmì vyhodnocují døíve ne¾ celý výraz, co¾ plnì koresponduje
s&nbsp;pravidly, která jsme si uvedli v&nbsp;pøedchozí kapitole (podvýraz je
zapsán formou volání nìjaké funkce). Vìt¹ina aritmetických funkcí není omezena
pouze na dva parametry, co¾ znamená, ¾e je napøíklad mo¾né zavoláním jedné
funkce nazvané <strong>+</strong> seèíst i více ne¾ dvì numerické hodnoty:</p>

<pre>
; zaèneme pozvolna jako na základní ¹kole :-)
(+ 1 1)
2
</pre>

<pre>
; operace rozdílu - druhý argument funkce je odeèten od prvního
(- 1 2)
-1
</pre>

<pre>
; souèet øady èísel
(+ 1 2 3 4 5 6 7 8 9 10)
55
</pre>

<pre>
; ní¾e uvedený výraz v infixové notaci odpovídá: 1-2-3-4-5....-10:
(- 1 2 3 4 5 6 7 8 9 10)
-53
</pre>

<pre>
; POZOR - závorky v LISPu nemají mnoho spoleèného
; s vyjádøením priority aritmetických operací
; (nelze je pou¾ít tak volnì jako napøíklad v céèku)
(* (+ 1 2) (+ 3 4))
21
</pre>

<pre>
(+ (* 1 2) (* 3 4))
14
</pre>

<pre>
; Clojure umí, podobnì jako nìkteré implementace LISPu,
; pracovat se zlomky, tj. sna¾í se racionální
; èísla vyjádøit formou zlomku (ideální jazyk do ¹kol :-)
(/ 1 2)
1/2
</pre>

<pre>
(/ 1 2 3)
1/6
</pre>

<pre>
; dal¹í forma, která se vyhodnotí na zlomek
(/ 3 2)
3/2
</pre>

<pre>
; zkusíme výpoèet slo¾itìj¹ího zlomku
(/ (+ 1 2) (+ 3 4))
3/7
</pre>

<pre>
; neracionální (reálná) èísla se vypisují tak, jak to
; známe z ostatních programovacích jazykù (samozøejmì
; v pøípadì speciálních po¾adavkù programátora lze pou¾ít
; rùzné formátovací funkce na úpravu výstupu)
(* 0.3 (/ (+ 1 2) (+ 3 4)))
0.1285714285714286
</pre>

<p>Programovací jazyk <i>Clojure</i> obsahuje i úplnou sadu relaèních
operátorù, které v&nbsp;závislosti na hodnotách pøedaných parametrù (operandù)
vrací hodnotu <strong>true</strong> (pravda) èi <strong>false</strong>
(nepravda). Zde se <i>Clojure</i> spí¹e podobá <i>Scheme</i> ne¾ klasickému
<i>LISPu</i> (s&nbsp;jeho <strong>T</strong> a <strong>nil</strong>), co¾ je
ostatnì jen dobøe:</p>

<pre>
; porovnání dvou èíselných hodnot
; relace "men¹í ne¾"
(&lt; 1 2)
true
</pre>

<pre>
; relace "vìt¹í ne¾"
(&gt; 1 2)
false
</pre>

<pre>
; relace "men¹í nebo rovno"
(&lt;= 1 2)
true
</pre>

<pre>
; relace "vìt¹í nebo rovno"
(&gt;= 1 2)
false
</pre>

<pre>
; porovnání dvou výrazù na ekvivalenci
(= 1 2)
false
</pre>

<pre>
(= 1 1)
true
</pre>

<pre>
; podvýrazy se nejprve vyhodnotí a posléze se porovnají
; vyhodnocené výsledky (v tomto pøípadì dva atomy)
(= (+ 1 1) (/ 4 2))
true
</pre>

<pre>
; na ekvivalenci lze porovnávat i seznamy (mapy, vektory...), nikoli pouze literály
(= '(1 2) '(1 2))
true
</pre>

<pre>
(= '(1 2) '(2 1))
false
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Speciální formy</h2>

<p>Poslední dùle¾itou vlastností programovacího jazyka <i>Clojure</i>,
s&nbsp;ní¾ se v&nbsp;dne¹ním èlánku alespoò ve struènosti seznámíme, je pou¾ití
takzvaných <i>speciálních forem</i>, tj.&nbsp;ètvrtého typu forem
zpracovávaných smyèkou <i>REPL</i>. Ze syntaktického hlediska jsou speciální
formy zapisovány naprosto stejným zpùsobem jako bì¾né funkce
(tj.&nbsp;v&nbsp;kulatých závorkách je nejprve zapsáno jméno funkce a posléze
její parametry), ov¹em existuje zde jeden významný rozdíl &ndash; zatímco u
funkcí jsou v¹echny jejich parametry nejdøíve rekurzivnì vyhodnoceny a teprve
posléze je funkce zavolána, u speciálních forem k&nbsp;tomuto vyhodnocení
obecnì nedochází, resp.&nbsp;jsou vyhodnoceny pouze nìkteré parametry (které
konkrétnì, to závisí na tom, o jakou speciální formu se jedná). K&nbsp;èemu
jsou speciální formy dobré? Typickým a pro praxi naprosto nezbytným pøíkladem
je zápis podmínìných blokù kódu. V&nbsp;tomto pøípadì potøebujeme, aby se
nìjaká èást programu vykonala pouze v&nbsp;pøípadì, ¾e je splnìna
(popø.&nbsp;nesplnìna) nìjaká podmínka, v&nbsp;opaèném pøípadì nemá být tato
èást programu vùbec vykonána.</p>

<p>Pomocí bì¾ných funkcí by nebylo mo¾né tuto funkcionalitu splnit, proto¾e by
se kód (pøedaný jako parametr &ndash; jinou mo¾nost v&nbsp;<i>Clojure</i>
ostatnì prakticky nemáme) vykonal je¹tì pøed zavoláním &bdquo;podmínkové&ldquo;
funkce. Z&nbsp;toho vyplývá, ¾e samotná podmínka, i kdy¾ se syntakticky podobá
volání funkce, je <i>speciální formou</i>. V&nbsp;jazyku <i>Clojure</i>
existuje pro zápis podmínìného pøíkazu mj.&nbsp;i speciální forma
<strong>if</strong>, která oèekává tøi parametry:</p>

<ol>
<li>podmínku (výraz=formu, která se vyhodnotí na <strong>true</strong> èi <strong>false</strong></li>
<li>formu vyhodnocenou v&nbsp;pøípadì, ¾e je podmínka splnìna</li>
<li>formu vyhodnocenou v&nbsp;pøípadì, ¾e podmínka není splnìna</li>
</ol>

<p>Pøíklady pou¾ití speciální formy <strong>if</strong>:</p>

<pre>
; na základì podmínky se vyhodnotí (a vrátí jako výsledek)
; buï øetìzec "mensi" nebo "vetsi"
(if (&lt; 1 2) "mensi" "vetsi")
"mensi"
</pre>

<pre>
; opaèná podmínka - je vyhodnocen pouze druhý øetìzec
(if (&gt; 1 2) "mensi" "vetsi")
"vetsi"
</pre>

<pre>
; test na ekvivalenci
(if (= 1 2) "rovno" "nerovno")
"nerovno"
</pre>

<pre>
; dal¹í test na ekvivalenci
(if (= 1 1) "rovno" "nerovno")
"rovno"
</pre>

<pre>
; pou¾ití slo¾itìj¹ích funkcí ve vìtvi "then" a "else"
(if (= 1 1) (+ 10 20) (/ 10 20))
30
</pre>

<pre>
; zde je výsledkem zlomek
(if (= 1 2) (+ 10 20) (/ 10 20))
1/2
</pre>

<pre>
; samotná speciální forma if mù¾e být volána uvnitø slo¾itìj¹ího výrazu
(* 84 (if (= 1 2) (+ 10 20) (/ 10 20)))
42N
</pre>

<pre>
; je¹tì jste se neztratili v závorkách? Zkusíme tedy vnoøenou
; speciální formu if:
(* 112 (if (&lt; (/ 2 3) (* 2 3)) (if (= 1 2) (+ 10 20) (- 1 5/8)) (/ 10 20)))
42N
; (¾e by Velká otázka byla zapsána právì takto?)
</pre>

<p>Teoreticky by bylo mo¾né pomocí speciální formy implementovat i programové
smyèky, ov¹em pro tento úèel se ve funkcionálních jazycích pou¾ívá spí¹e mnohem
obecnìj¹í mechanismus &ndash; rekurze a speciálnì té¾ tail rekurze, která se
musí v&nbsp;<i>Clojure</i> uvést explicitnì. Podrobnosti si øekneme
v&nbsp;dal¹í èásti tohoto seriálu.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Clojure home page<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/">http://java.sun.com/developer/technicalArticles/DynTypeLang/</a>
</li>

<li>JSR 223: Scripting for the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=223">http://jcp.org/en/jsr/detail?id=223</a>
</li>

<li>JSR 292: Supporting Dynamically Typed Languages on the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=292">http://jcp.org/en/jsr/detail?id=292</a>
</li>

<li>Java 7: A complete invokedynamic example<br />
<a href="http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html">http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html</a>
</li>

<li>InvokeDynamic: Actually Useful?<br />
<a href="http://blog.headius.com/2007/01/invokedynamic-actually-useful.html">http://blog.headius.com/2007/01/invokedynamic-actually-useful.html</a>
</li>

<li>A First Taste of InvokeDynamic<br />
<a href="http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html">http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html</a>
</li>

<li>Java 6 try/finally compilation without jsr/ret<br />
<a href="http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html">http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Root.cz: Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM<br />
<a href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/</a></a>
</li>

<li>Root.cz: JamVM aneb alternativa k HotSpotu nejenom pro embedded zaøízení a chytré telefony<br />
<a href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>FindBugs<br />
<a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a>
</li>

<li>GNU Classpath<br />
<a href="www.gnu.org/s/classpath/">www.gnu.org/s/classpath/</a></li>

<li>Java VMs Compared<br />
<a href="http://bugblogger.com/java-vms-compared-160/">http://bugblogger.com/java-vms-compared-160/</a>
</li>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Scala Programming Language<br />
<a href="http://www.scala-lang.org/">http://www.scala-lang.org/</a>
</li>

<li>Run Scala in Apache Tomcat in 10 minutes<br />
<a href="http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes">http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes</a>
</li>

<li>Fast Web Development With Scala<br />
<a href="http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html">http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html</a>
</li>

<li>Top five scripting languages on the JVM<br />
<a href="http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855">http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>CloseableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html">http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

