<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - prùchod objekty ulo¾enými na haldì (heapu)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - prùchod objekty ulo¾enými na haldì (heapu)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o vlastnostech JVM se seznámíme se zpùsobem práce s objekty ulo¾enými na haldì s vyu¾itím rozhraní JVM TI. Agenti pøipojení k virtuálnímu stroji Javy pøes JVM TI toti¾ pomìrnì èasto potøebují nìjaké údaje (instance urèitých tøíd) z haldy pøeèíst a následnì zpracovat.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - prùchod objekty ulo¾enými na haldì (heapu)</a></p>
<p><a href="#k02">2. Callback funkce volané pøi prùchodu haldou</a></p>
<p><a href="#k03">3. Osmnáctý demonstraèní pøíklad &ndash; prùchod v¹emi objekty ulo¾enými na haldì</a></p>
<p><a href="#k04">4. U¾ivatelská data pøená¹ená do callback funkce pøi prùchodu objekty ulo¾enými na hladì</a></p>
<p><a href="#k05">5. Devatenáctý demonstraèní pøíklad &ndash; výpis souhrnných informací o obsazení haldy (poèet objektù a jejich velikost)</a></p>
<p><a href="#k06">6. Pøidání tagù ke tøídám</a></p>
<p><a href="#k07">7. Pou¾ití tagù pøi pøiøazování objektù k&nbsp;jejich tøídám</a></p>
<p><a href="#k08">8. Dvacátý demonstraèní pøíklad &ndash; výpis v¹ech objektù na haldì vèetnì jména pøíslu¹né tøídy</a></p>
<p><a href="#k09">9. Zdrojové kódy v¹ech tøí demonstraèních pøíkladù</a></p>
<p><a href="#k10">10. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - prùchod objekty ulo¾enými na haldì (heapu)</h2>

<p>V&nbsp;dne¹ní &ndash; ji¾ 59.èásti &ndash; <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyce Java i o vlastnostech virtuálního stroje Javy</a> si na
tøech demonstraèních pøíkladech uká¾eme, jakým zpùsobem je mo¾né
s&nbsp;vyu¾itím agentù komunikujících s&nbsp;JVM pøes rozhraní <i>JVM TI</i>
procházet v¹emi objekty ulo¾enými na haldì (<i>heap</i>) a získat i dal¹í
informace o tìchto objektech, pøedev¹ím pak tøídu, z&nbsp;ní¾ je objekt ulo¾ený
na haldì vytvoøen. V&nbsp;rozhraní <i>JVM TI</i> je mo¾né pro zahájení prùchodu
v¹emi objekty na haldì vyu¾ít funkci nazvanou
<strong>IterateThroughHeap()</strong>. Pøi volání této funkce se jí
mj.&nbsp;pøedá i datová struktura obsahující ukazatele na callback funkce
volané pro jednotlivé objekty nalezené na haldì; v&nbsp;souèasné verzi rozhraní
<i>JVM TI</i> se jedná o pìtici callback funkcí, zbytek datové struktury není
vyu¾it.</p>

<p>Dùle¾ité je, ¾e haldou (<i>heapem</i>) je mo¾né procházet nepøímo právì
s&nbsp;vyu¾itím <strong>IterateThroughHeap()</strong> a na ni navázaných
callback funkcí, proto¾e ji¾ minule jsme si øekli, ¾e v&nbsp;rozhraní <i>JVM
TI</i> nejsou k&nbsp;dispozici ¾ádné funkce, které by dokázaly pøímo vrátit
seznam objektù vyfiltrovaný na základì nìjaké podmínky. Pokud tedy programátor
potøebuje zjistit informace o urèitých typech objektù na haldì, musí si sám
implementovat a následnì zaregistrovat pøíslu¹né callback funkce, kterým se
budou tyto informace pøedávat. Hlavièka funkce
<strong>IterateThroughHeap()</strong> vypadá následovnì:</p>

<pre>
jvmtiError <strong>IterateThroughHeap</strong>(
            jvmtiEnv* env,
            jint      heap_filter,
            jclass    klass,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data)
</pre>

<p>Význam prvního parametru této funkce je zøejmý, proto¾e je v&nbsp;nìm
pøenesena (pøesnìji øeèeno pouze odkázána) struktura obsahující aktuální
prostøedí <i>JVM TI</i>. Zajímavìj¹í je druhý parametr, pøes který je mo¾né
specifikovat základní filtr, který urèuje, pro které typy objektù se budou
callback funkce volat. Vyu¾ít je mo¾né následující hodnoty, popø.&nbsp;jejich
bitové kombinace spojené pøes operátor + nebo |:</p>

<table>
<tr><th>Konstanta</th><th>Hodnota</th><th>Význam</th></tr>
<tr><td>JVMTI_HEAP_FILTER_TAGGED        </td><td>0x04</td><td>objekty s&nbsp;pøiøazeným tagem jsou odfiltrovány</td></tr>
<tr><td>JVMTI_HEAP_FILTER_UNTAGGED      </td><td>0x08</td><td>objekty bez tagu jsou odfiltrovány</td></tr>
<tr><td>JVMTI_HEAP_FILTER_CLASS_TAGGED  </td><td>0x10</td><td>objekty, jejich¾ tøídy mají pøiøazeny tag jsou odfiltrovány</td></tr>
<tr><td>JVMTI_HEAP_FILTER_CLASS_UNTAGGED</td><td>0x20</td><td>pøesný opak pøedchozí konstanty</td></tr>
</table>

<p>Oznaèením <i>tag</i> je zde my¹len celoèíselný údaj rozdílný od nuly, kterým
mohou být objekty &bdquo;oznaèkovány&ldquo;, a to opìt pomocí rozhraní <i>JVM
TI</i>. Tagy mají pøi procházení haldou pomìrnì velký význam a seznámíme se
s&nbsp;nimi <a href="#k06">v&nbsp;¹esté kapitole</a>.</p>

<p>Ve tøetím parametru lze pøedat buï hodnotu <strong>NULL</strong>
popø.&nbsp;identifikátor tøídy, který je opìt pou¾it pro filtraci. To napøíklad
znamená, ¾e pokud nás zajímají informace pouze o instancích tøídy
<strong>org.foo.bar.Baz</strong>, lze toho velmi jednodu¹e docílit, ani¾ by se
musela procházet celá halda, resp.&nbsp; ani¾ by byla pøíslu¹ná callback funkce
volána pro v¹echny instance ostatních tøíd.</p>

<p>Ètvrtým parametrem je ukazatel na datovou strukturu nazvanou
<strong>jvmtiHeapCallbacks</strong>. Právì do této struktury mù¾e programátor
ulo¾it odkazy na callback funkce. Struktura sice teoreticky pojme ¹estnáct
ukazatelù na callback funkce, ov¹em vyu¾ito je v&nbsp;souèasnosti jen pìt
prvních ukazatelù a i libovolný z&nbsp;tìchto ukazatelù mù¾e mít hodnotu
<strong>NULL</strong>:</p>

<pre>
<strong>typedef struct</strong> {
    jvmtiHeapIterationCallback        heap_iteration_callback;
    jvmtiHeapReferenceCallback        heap_reference_callback;
    jvmtiPrimitiveFieldCallback       primitive_field_callback;
    jvmtiArrayPrimitiveValueCallback  array_primitive_value_callback;
    jvmtiStringPrimitiveValueCallback string_primitive_value_callback;
    jvmtiReservedCallback             reserved5;
    jvmtiReservedCallback             reserved6;
    jvmtiReservedCallback             reserved7;
    jvmtiReservedCallback             reserved8;
    jvmtiReservedCallback             reserved9;
    jvmtiReservedCallback             reserved10;
    jvmtiReservedCallback             reserved11;
    jvmtiReservedCallback             reserved12;
    jvmtiReservedCallback             reserved13;
    jvmtiReservedCallback             reserved14;
    jvmtiReservedCallback             reserved15;
} <strong>jvmtiHeapCallbacks</strong>;
</pre>

<p>Význam pìti ukazatelù na callback funkce je následující:</p>

<table>
<tr><th>#</th><th>Typ</th><th>Název</th><th>Význam</th></tr>
<tr><td>1</td><td>jvmtiHeapIterationCallback       </td><td>heap_iteration_callback        </td><td>voláno pro bì¾né objekty</td></tr>
<tr><td>2</td><td>jvmtiHeapReferenceCallback       </td><td>heap_reference_callback        </td><td>voláni pro reference na objekty</td></tr>
<tr><td>3</td><td>jvmtiPrimitiveFieldCallback      </td><td>primitive_field_callback       </td><td>voláno pro atributy primitivního datového typu</td></tr>
<tr><td>4</td><td>jvmtiArrayPrimitiveValueCallback </td><td>array_primitive_value_callback </td><td>voláno pro pole primitivních datových typù</td></tr>
<tr><td>5</td><td>jvmtiStringPrimitiveValueCallback</td><td>string_primitive_value_callback</td><td>voláno pro øetìzce</td></tr>
</table>

<p>V&nbsp;pátém parametru se pøedává buï hodnota NULL nebo ukazatel na
u¾ivatelská data, napøíklad na pole èi na nìjakou datovou strukturu. Tato
u¾ivatelská data jsou pøi volání zaregistrovaných callback funkcí tìmto funkcím
jednodu¹e pøedána. Pøíklad pou¾ití u¾ivatelských dat si uká¾eme <a
href="#k04">ve ètvrté</a> a <a href="#k05">v&nbsp;páté kapitole</a>.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Callback funkce volané pøi prùchodu haldou</h2>

<p>V&nbsp;datové struktuøe <strong>jvmtiHeapIterationCallback</strong> popsané
<a href="#k01">v&nbsp;pøedchozí kapitole</a> je první polo¾ka urèena pro
ulo¾ení ukazatele na callback funkci oznaèenou
<strong>heap_iteration_callback</strong>. S&nbsp;velkou pravdìpodobností se
jedná o nejèastìji pou¾ívanou callback funkci, která mù¾e být zavolána pro
v¹echny &bdquo;bì¾né&ldquo; objekty ulo¾ené na haldì, tj.&nbsp;jak pro instance
tøíd, tak i pro pole objektù o libovolné dimenzi, proto¾e tato pole jsou
v&nbsp;Javì pova¾ována takté¾ za bì¾né objekty. Hlavièka callback funkce, její¾
ukazatel mù¾e být ulo¾en do polo¾ky
<strong>jvmtiHeapIterationCallback.heap_iteration_callback</strong>, musí
vypadat následovnì:</p>

<pre>
jint <strong>jvmtiHeapIterationCallback</strong> (
        jlong  class_tag, 
        jlong  size, 
        jlong* tag_ptr, 
        jint   length, 
        void*  user_data);
</pre>

<p>V&nbsp;tabulce ní¾e je vypsán význam v¹ech pìti parametrù této callback
funkce, které jsou správnì naplnìny pøi jejím zavolání:</p>

<table>
<tr><th>#</th><th>Jméno</th><th>Typ</th><th>Popis</th></tr>
<tr><td>1</td><td>class_tag</td><td>jlong </td><td>tag pøiøazený ke tøídì, popø.&nbsp;nula, pokud ke tøídì není ¾ádný tag pøiøazen</td></tr>
<tr><td>2</td><td>size     </td><td>jlong </td><td>velikost objektu uvedená v&nbsp;bajtech</td></tr>
<tr><td>3</td><td>tag_ptr  </td><td>jlong*</td><td>tag pøiøazený k&nbsp;objektu, popø.&nbsp;nula, pokud objektu ¾ádný tak nebyl pøiøazen</td></tr>
<tr><td>4</td><td>length   </td><td>jint  </td><td>délka pole (pokud je objektem pole), jinak by zde mìla být pøedána hodnota -1</td></tr>
<tr><td>5</td><td>user_data</td><td>void* </td><td>u¾ivatelská data pøedávaná této callback funkci</td></tr>
</table>

<p>Dùle¾itá je i návratová hodnota této callback funkce, a to z&nbsp;toho
dùvodu, ¾e s&nbsp;vyu¾itím návratové hodnoty je mo¾né do urèité míry ovlivòovat
prùchod haldou. Pokud se vrací hodnota <strong>JVMTI_VISIT_OBJECTS</strong>,
znamená to, ¾e se má pokraèovat v&nbsp;dal¹ím procházení haldou, pokud se v¹ak
vrátí hodnota <strong>JVMTI_VISIT_ABORT</strong>, je procházení zastaveno. Ve
skuteènosti jsou sice mo¾né i dal¹í kombinace návratových hodnot callback
funkcí, ty se v¹ak vyu¾ijí zejména v&nbsp;pøípadech, kdy se prochází pouze
referencemi (to si uká¾eme pøí¹tì):</p>

<table>
<tr><th>#</th><th>Konstanta</th><th>Hodnota konstanty</th><th>Význam</th></tr>
<tr><td>1</td><td>JVMTI_VISIT_OBJECTS</td><td>0x0100</td><td>pokraèovat v prùchodu haldou</td></tr>
<tr><td>2</td><td>JVMTI_VISIT_ABORT  </td><td>0x8000</td><td>ukonèení prùchodu haldou</td></tr>
</table>

<p>První verze callback funkce, kterou vyu¾ijeme v&nbsp;osmnáctém demonstraèním
pøíkladu, bude velmi jednoduchá, proto¾e bude pouze vypisovat <i>tag</i>
pøiøazený ke tøídì a takté¾ velikost haldy alokovanou pro daný objekt.
<i>Tag</i> bude mít v¾dy hodnotu nula, proto¾e jsme (alespoò prozatím)
neprovedli jeho explicitní pøenastavení:</p>

<pre>
<i>/*</i>
<i> * Callback funkce volana pro kazdy objekt "navstiveny" na halde.</i>
<i> */</i>
static jint JNICALL <strong>callback_for_heap_object</strong>(
        jlong  class_tag,
        jlong  size,
        jlong* tag_ptr,
        jint   length,
        void*  user_data)
{
    printf("instance of class with tag #%ld of size %ld\n", (long int)class_tag, (long int)size);
    return JVMTI_VISIT_OBJECTS;
}
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Osmnáctý demonstraèní pøíklad &ndash; prùchod v¹emi objekty ulo¾enými na haldì</h2>

<p>Zdrojový kód osmnáctého demonstraèního pøíkladu vychází z&nbsp;pøíkladù
popsaných v&nbsp;pøedchozích èástech tohoto seriálu, proto si zde uvedeme pouze
úpravy provedené v&nbsp;nìkterých funkcích (úplné zdrojové kódy najdete <a
href="#k09">v&nbsp;deváté kapitole</a>). V&nbsp;pomocné funkci
<strong>set_capabilities()</strong> nastavíme po¾adavek na mo¾nost nastavovat
<i>tagy</i> pro tøídy a objekty (ve skuteènosti tuto mo¾nost vyu¾ijeme a¾
v&nbsp;dal¹ích pøíkladech). Musíme mít na pamìti, ¾e mo¾nost nastavovat
<i>tagy</i> nemusí být implementována v¹emi virtuálními stroji Javy, ov¹em
v&nbsp;pøípadì OpenJDK a Oracle JDK je tuto technologii mo¾né vyu¾ít. ®ádné
dal¹í po¾adavky nastavovány nebudou, proto¾e na rozdíl od nìkterých pøedchozích
pøíkladù nepotøebujeme detekovat výjimky ani zji¹»ovat èísla øádkù:</p>

<pre>
<i>/*</i>
<i> * Nastaveni pozadovanych schopnosti agenta.</i>
<i> */</i>
jvmtiError <strong>set_capabilities</strong>(jvmtiEnv *jvmti)
{
    jvmtiCapabilities capabilities;
    jvmtiError error_code;
&nbsp;
    memset(&amp;capabilities, 0, sizeof(jvmtiCapabilities));
&nbsp;
<i>    /* vyuzivame pouze jednu specialni schopnost agenta */</i>
    capabilities.can_tag_objects = 1;
&nbsp;
    error_code = (*jvmti)-&gt;AddCapabilities(jvmti, &amp;capabilities);
    check_jvmti_error(jvmti, error_code, "Unable to get necessary JVMTI capabilities.");
    return error_code;
}
</pre>

<p>Dále v&nbsp;<i>JVM TI</i> agentovi zaregistrujeme tøi callback funkce volané
samotným virtuálním strojem Javy (tyto callback funkce samozøejmì nemají nic
spoleèného s&nbsp;callback funkcí volanou pøi procházení haldou). První dvì
callback funkce ji¾ dokonale známe &ndash; jsou volány pøi spu¹tìní a naopak
pøi ukonèování èinnosti JVM. Poslední callback funkce je nová a je zavolána ve
chvíli, kdy pøijde systémový po¾adavek na pøeètení dat &ndash; typicky se jedná
o reakci na ukonèení javovského procesu z&nbsp;klávesnice atd. (tímto zpùsobem
si tedy mù¾eme vynutit výpis haldy kdykoli za bìhu JVM):</p>

<pre>
<i>/*</i>
<i> * Registrace tri callback funkci zavolanych virtualnim strojem Javy.</i>
<i> */</i>
jvmtiError <strong>register_all_callback_functions</strong>(jvmtiEnv *jvmti)
{
    jvmtiEventCallbacks callbacks;
    jvmtiError error_code;
&nbsp;
    memset(&amp;callbacks, 0, sizeof(callbacks));
&nbsp;
<i>    /* JVMTI_EVENT_VM_INIT */</i>
    callbacks.VMInit = &amp;callback_on_vm_init;
&nbsp;
<i>    /* JVMTI_EVENT_VM_DEATH */</i>
    callbacks.VMDeath = &amp;callback_on_vm_death;
&nbsp;
<i>    /* JVMTI_EVENT_DATA_DUMP_REQUEST */</i>
    callbacks.DataDumpRequest = &amp;callback_on_data_dump_request;
&nbsp;
    error_code = (*jvmti)-&gt;SetEventCallbacks(jvmti, &amp;callbacks, (jint)sizeof(callbacks));
    check_jvmti_error(jvmti, error_code, "Cannot set JVM TI callbacks");
    return error_code;
}
</pre>

<p>Obsah haldy bude na¹ím demonstraèním <i>JVM TI</i> agentem (pro vìt¹í
jednoduchost implementace) vypsán automaticky ve chvíli, kdy má dojít
k&nbsp;ukonèení èinnosti virtuálního stroje Javy. To znamená, ¾e musíme
v&nbsp;callback funkci <strong>callback_on_vm_death()</strong> nejprve zakázat
reakci na pøíkaz o ukonèení JVM z&nbsp;klávesnice a poté provést vlastní výpis
haldy. Dùvod, proè je reakce na pøíkaz o ukonèení JVM zakázána je prostý
&ndash; nechceme, aby se halda vypsala nìkolikrát. Takté¾ si pov¹imnìte, ¾e
celý výpis haldy je umístìn do kritické sekce, co¾ je ostatnì vy¾adováno i
rozhraním <i>JVM TI</i>:</p>

<pre>
<i>/*</i>
<i> * Callback funkce zavolana pri ukonceni cinnosti virtualniho stroje.</i>
<i> */</i>
static void JNICALL <strong>callback_on_vm_death</strong>(jvmtiEnv *jvmti_env, JNIEnv* env)
{
    MSG("Got VM Death event");
&nbsp;
<i>    /* veskere operace se budou provadet v kriticke sekci */</i>
    enter_critical_section(jvmti_env);
&nbsp;
<i>    /* jen pro jistotu zakazeme notifikaci */</i>
    (*jvmti_env)-&gt;SetEventNotificationMode(jvmti_env, JVMTI_DISABLE, JVMTI_EVENT_DATA_DUMP_REQUEST, NULL);
&nbsp;
<i>    /* data request */</i>
    callback_on_data_dump_request(jvmti_env);
&nbsp;
<i>    /* a vystup z kriticke sekce */</i>
    exit_critical_section(jvmti_env);
}
</pre>

<p>Pøípravné práce jsou dokonèeny, nyní nám ji¾ zbývá si ukázat, jak vypadá
callback funkce <strong>callback_on_data_dump_request()</strong>. Ta je ve
skuteènosti velmi jednoduchá:</p>

<pre>
<i>/*</i>
<i> * Callback funkce zavolana pri cteni informaci z haldy.</i>
<i> */</i>
static void JNICALL <strong>callback_on_data_dump_request</strong>(jvmtiEnv *jvmti_env)
{
    MSG("Got data dump request");
    register_heap_callback_and_run_dump(jvmti_env);
}
</pre>

<p>Vidíme, ¾e se z&nbsp;této callback funkce pouze volá dal¹í pomocná funkce,
která zahájí vlastní proces výpisu haldy &ndash; konkrétnì zaregistruje
pøíslu¹nou callback funkci pøes datovou strukturu <strong>jvmtiHeapCallbacks
</strong>a nakonec zavolá <strong>IterateThroughHeap()</strong>:</p>

<pre>
<i>/*</i>
<i> * Registrace callback funkce pro prochazeni heapem a zacatek prochazeni.</i>
<i> */</i>
static void <strong>register_heap_callback_and_run_dump</strong>(jvmtiEnv *jvmti_env)
{
    jvmtiError error;
    jvmtiHeapCallbacks heap_callbacks;
&nbsp;
<i>    /* naplnit strukturu heap_callbacks jednou callback funkci */</i>
    (void)memset(&amp;heap_callbacks, 0, sizeof(heap_callbacks));
    heap_callbacks.heap_iteration_callback = &amp;callback_for_heap_object;
&nbsp;
<i>    /* zahajit prochazeni haldou */</i>
    error = (*jvmti_env)-&gt;IterateThroughHeap(jvmti_env, 0, NULL,
            &amp;heap_callbacks, NULL);
    check_jvmti_error(jvmti_env, error, "read heap content");
}
</pre>

<p>Vzhledem k&nbsp;tomu, ¾e prozatím nemáme mo¾nost si vypsat jména tøíd pro
v¹echny objekty ulo¾ené na haldì, je vcelku jedno, jak bude vypadat
demonstraèní javovská tøída. Pou¾ijeme tedy kód vyu¾itý i dal¹ími agenty:</p>

<pre>
<i>/**</i>
<i>  * Testovaci trida pouzita pro test osmnacteho</i>
<i>  * demonstracniho JVM TI agenta.</i>
<i>  */</i>
public class Test18 {
<i>    /**</i>
<i>      * Spusteni testu.</i>
<i>      */</i>
    public static void main(String[] args) {
        int[]     intArray = new int[1000];
        float[][] floatMatrix = new float[100][100];
        String    hello = "Hello" + ' ' + "world" + '!';
        Object    x = new Test18();
    }
}
</pre>

<p>Výstup bude pomìrnì zajímavý, proto¾e se ukazuje, ¾e i JVM spu¹tìná pro tak
jednoduchý pøíklad bude mít na haldì ulo¾eno pøes pìt tisíc objektù! Samozøejmì
se jedná pøedev¹ím o objekty vyu¾ívané internì virtuálním strojem:</p>

<pre>
Agent18: Agent_OnLoad
Agent18: JVM TI version is correct
Agent18: Got VM init event
Agent18: Got VM Death event
Agent18: Got data dump request
instance of class with tag #0 of size 16
instance of class with tag #0 of size 24
instance of class with tag #0 of size 48
instance of class with tag #0 of size 24
...
...
... cca 5000(!) øádkù
...
...
instance of class with tag #0 of size 32
instance of class with tag #0 of size 640
instance of class with tag #0 of size 32
instance of class with tag #0 of size 96
instance of class with tag #0 of size 32
instance of class with tag #0 of size 464
instance of class with tag #0 of size 40
Agent18: Agent_OnUnload
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. U¾ivatelská data pøená¹ená do callback funkce pøi prùchodu objekty ulo¾enými na hladì</h2>

<p>V&nbsp;pøedchozích kapitolách jsme si øekli, ¾e pøi volání <i>JVM TI</i>
funkce <strong>IterateThroughHeap()</strong> je mo¾né v&nbsp;pátém parametru
této funkce pøedat ukazatel na &bdquo;nìjaká&ldquo; u¾ivatelská data
s&nbsp;tím, ¾e tento ukazatel bude pøedáván do callback funkce volané pro ka¾dý
objekt umístìný na heapu. Pokud se do tohoto parametru pøedá pouze hodnota
<strong>NULL</strong> (co¾ je ostatnì zcela legální), bude prostì tato hodnota
jednodu¹e pøedávána i do callback funkce:</p>

<pre>
jvmtiError <strong>IterateThroughHeap</strong>(
            jvmtiEnv* env,
            jint      heap_filter,
            jclass    klass,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data)
</pre>

<p>Pøi pohledu na na¹i implementaci funkce
<strong>callback_for_heap_object()</strong> je patrné, ¾e se tento ukazatel
prozatím nijak nevyu¾ívá:</p>

<pre>
<i>/*</i>
<i> * Callback funkce volana pro kazdy objekt "navstiveny" na halde.</i>
<i> */</i>
static jint JNICALL <strong>callback_for_heap_object</strong>(
        jlong  class_tag,
        jlong  size,
        jlong* tag_ptr,
        jint   length,
        void*  user_data)
{
    printf("instance of class with tag #%ld of size %ld\n", (long int)class_tag, (long int)size);
    return JVMTI_VISIT_OBJECTS;
}
</pre>

<p>Ov¹em hned <a href="#k05">v&nbsp;navazující kapitole</a> si uká¾eme, jak
tento ukazatel vyu¾ít &ndash; bude se jednat o pøíklad, který takté¾ vypí¹e
zjednodu¹ený obsah haldy, ale navíc je¹tì spoèítá celkový poèet tìchto objektù
a poèet alokovaných bajtù pro tyto objekty.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Devatenáctý demonstraèní pøíklad &ndash; výpis souhrnných informací o obsazení haldy (poèet objektù a jejich velikost)</h2>

<p>Devatenáctý demonstraèní <i>JVM TI</i> agent se od pøedchozího
demonstraèního agenta li¹í pouze minimálnì, tak¾e si opìt uvedeme pouze nové èi
pozmìnìné èásti s&nbsp;tím, ¾e úplné zdrojové texty jsou uvedeny <a
href="#k09">v&nbsp;deváté kapitole</a>. Nejprve je pøidána definice velmi
jednoduché datové struktury, do ní¾ se budou zaznamenávat poèty objektù a
jejich celková velikost na haldì. Tato struktura je umístìna na zaèátku celého
programu (jak je ostatnì v&nbsp;céèkových programech zvykem):</p>

<pre>
<i>/* Definice struktura se zakladnimi informacemi o objektech na halde */</i>
typedef struct
{
    int  object_count;
    long total_size;
} t_heap_stat;
</pre>

<p>Dále do¹lo ke zmìnì callback funkce volané pro ka¾dý objekt umístìný na
haldì. Pov¹imnìte si, ¾e nyní pøedpokládáme, ¾e se v&nbsp;parametru
<strong>user_data</strong> bude pøedávat ukazatel na vý¹e popsanou datovou
strukturu <strong>t_heap_stat</strong>, tak¾e je nejprve provedeno pøetypování
pùvodního ukazatele <strong>void*</strong> na <strong>t_heap_stat*</strong> a
posléze se pozmìní hodnota obou prvkù ulo¾ených v&nbsp;této struktuøe &ndash;
poèet objektù a poèet alokovaných bajtù:</p>

<pre>
<i>/*</i>
<i> * Callback funkce volana pro kazdy objekt "navstiveny" na halde.</i>
<i> */</i>
static jint JNICALL <strong>callback_for_heap_object</strong>(jlong class_tag, jlong size, jlong* tag_ptr,
        jint length, void* user_data)
{
    t_heap_stat *heap_stat = (t_heap_stat*)user_data;
&nbsp;
    heap_stat-&gt;object_count++;
    heap_stat-&gt;total_size += size;
    printf("instance of class with tag #%ld of size %ld\n", (long int)class_tag, (long int)size);
    return JVMTI_VISIT_OBJECTS;
}
</pre>

<p>Poslední zmìna byla provedena ve funkci
<strong>register_heap_callback_and_run_dump()</strong>, kde je nejprve na
zásobníku vytvoøena lokální datová struktura <strong>t_heap_stat</strong> a
posléze je ukazatel na tuto strukturu pøedán do funkce
<strong>IterateThroughHeap()</strong>. A¾ tato funkce skonèí, tj.&nbsp;a¾ se
zavolají v¹echny callback funkce pøi prùchodu haldou, vypí¹e se na standardní
výstup poèet v¹ech objektù na haldì i poèet bajtù alokovaných na haldì:</p>

<pre>
<i>/*</i>
<i> * Registrace callback funkce pro prochazeni heapem a zacatek prochazeni.</i>
<i> */</i>
static void <strong>register_heap_callback_and_run_dump</strong>(jvmtiEnv *jvmti_env)
{
    jvmtiError error;
    jvmtiHeapCallbacks heap_callbacks;
    t_heap_stat heap_stat = {0,0};
&nbsp;
<i>    /* naplnit strukturu heap_callbacks jednou callback funkci */</i>
    (void)memset(&amp;heap_callbacks, 0, sizeof(heap_callbacks));
    heap_callbacks.heap_iteration_callback = &amp;callback_for_heap_object;
&nbsp;
<i>    /* zahajit prochazeni haldou */</i>
    error = (*jvmti_env)-&gt;IterateThroughHeap(jvmti_env, 0, NULL,
            &amp;heap_callbacks, (const void *)&amp;heap_stat);
    check_jvmti_error(jvmti_env, error, "read heap content");
&nbsp;
<i>    /* vypis statistiky */</i>
    printf("Object count: %d\n", heap_stat.object_count);
    printf("Total size:   %ld bytes\n", heap_stat.total_size);
}
</pre>

<p>A jak bude vypadat výstup tohoto demonstraèního pøíkladu? Opìt se nejprve
vypí¹ou základní informace o v¹ech objektech umístìných na haldì (jejich tagy
by mìly být nulové) a navíc se na konci vypí¹e krátká statistika o vyu¾ití
haldy:</p>

<pre>
Agent19: Agent_OnLoad
Agent19: JVM TI version is correct
Agent19: Got VM init event
Agent19: Got VM Death event
Agent19: Got data dump request
instance of class with tag #0 of size 16
instance of class with tag #0 of size 24
instance of class with tag #0 of size 48
instance of class with tag #0 of size 24
instance of class with tag #0 of size 40
instance of class with tag #0 of size 24
instance of class with tag #0 of size 88
...
...
... cca 5000(!) øádkù
...
...
instance of class with tag #0 of size 32
instance of class with tag #0 of size 640
instance of class with tag #0 of size 32
instance of class with tag #0 of size 96
instance of class with tag #0 of size 32
instance of class with tag #0 of size 464
instance of class with tag #0 of size 40
Object count: 5233
Total size:   607264 bytes
Agent19: Agent_OnUnload
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Pøidání tagù ke tøídám</h2>

<p>Pøedchozí dva demonstraèní pøíklady postrádaly jednu velice dùle¾itou
vlastnost &ndash; nedokázaly vypsat jména tøíd pro jednotlivé objekty ulo¾ené
na haldì. Je tomu tak z&nbsp;toho dùvodu, ¾e do callback funkce
<strong>callback_for_heap_object()</strong> se potøebné informace nepøedávají.
Ov¹em mù¾eme zde vyu¾ít faktu, ¾e se do této funkce pøedává <i>tag</i>
pøiøazený ke tøídì. <i>Tagem</i> je zde my¹leno celé èíslo rozdílné od nuly,
proto¾e nula má speciální význam oznamující, ¾e ¾ádný <i>tag</i> nebyl
pøiøazen. Teoreticky je tedy mo¾né provést následující sekvenci operací:</p>

<ol>
<li>Získat seznam v¹ech tøíd ve virtuálním stroji Javy.</li>
<li>Jména tøíd ulo¾it do globálního pole øetìzcù.</li>
<li>Pøiøadit tøídám tagy takovým zpùsobem, aby n-té jméno v&nbsp;poli odpovídalo tagu <i>n</i> (nebo spí¹e n+1).</li>
<li>V callback funkci <strong>callback_for_heap_object()</strong> vyu¾ít pøedané èíslo tagu i globální pole názvù.</li>
</ol>

<p>První bod lze splnit velmi snadno s&nbsp;vyu¾itím <i>JVM TI</i> funkce
<strong>GetLoadedClasses()</strong>, která vrátí jak poèet tøíd naètených do
virtuálního stroje Javy, tak i pole s&nbsp;vyplnìnými polo¾kami typu
<strong>jclass</strong>, s&nbsp;nimi¾ ji¾ umíme pracovat:</p>

<pre>
jvmtiError <strong>GetLoadedClasses</strong>(
            jvmtiEnv* env,
            jint* class_count_ptr,
            jclass** classes_ptr)
</pre>

<p>V&nbsp;následujícím úryvku kódu je ukázáno, jak lze tyto informace vyu¾ít
pøi naplnìní globálního pole <strong>class_names</strong>. Pov¹imnìte si, ¾e
v&nbsp;celém kódu jsou pou¾ity pouze tøi <i>JVM TI</i> funkce
<strong>GetLoadedClasses()</strong>, <strong>GetClassSignature()</strong> a
<strong>Deallocate()</strong>, proto¾e samozøejmì nesmíme zapomenout na
uvolnìní pamìti alokované funkcí <strong>GetClassSignature()</strong> (jako
malé cvièení si navíc do kódu pøidejte dealokaci pamìti po
<strong>GetLoadedClasses()</strong>):</p>

<pre>
<i>/* Globální pole, do nìj¾ se ulo¾í jména v¹ech pou¾itých tøíd. */</i>
char **class_names;
&nbsp;
<i>/* Lokální promìnné pou¾ité pouze pro pøeètení jmen tøíd, posléze nebudou zapotøebí. */</i>
jvmtiError error;
jint       class_count;
jclass    *class_array;
int        i;
&nbsp;
<i>/* Pøeèíst jména v¹ech naètených tøíd. */</i>
error = (*jvmti_env)-&gt;<strong>GetLoadedClasses</strong>(jvmti_env, &amp;class_count, &amp;class_array);
check_jvmti_error(jvmti_env, error, "get loaded classes");
&nbsp;
<i>/* Alokovat globální pole, které bude jména obsahovat. */</i>
class_names = (char**)malloc(class_count * sizeof(char*));
&nbsp;
<i>/* Projít získaným seznamem. */</i>
for (i=0; i &lt; class_count; i++)
{
    char *class_name_ptr;
    char *updated_class_name_ptr;
&nbsp;
<i>    /* Získat jméno (signaturu) jedné tøídy */</i>
    error = (*jvmti_env)-&gt;<strong>GetClassSignature</strong>(jvmti_env, class_array[i], &amp;class_name_ptr, NULL);
    check_jvmti_error(jvmti_env, error, "get class signature");
    if (class_name_ptr == NULL)
    {
        puts("Error: class has no signature");
    }
&nbsp;
<i>    /* Upravit jméno tøídy do èitelnìj¹í podoby. */</i>
    updated_class_name_ptr = update_class_name(class_name_ptr, ' ');
&nbsp;
<i>    /* Kopie jména tøídy do globálního pole class_names. */</i>
    class_names[i] = (char*)malloc(1 + strlen(updated_class_name_ptr));
    strcpy(class_names[i], updated_class_name_ptr);
&nbsp;
<i>    /* Dealokace pamìti vrácené funkcí GetClassSignature() */</i>
    error = (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char *)class_name_ptr);
    check_jvmti_error(jvmti_env, error, "deallocate class name");
}
</pre>

<p>Funkci <strong>update_class_name()</strong> jsme si ji¾ uvedli
v&nbsp;nìkolika pøedchozích demonstraèních <i>JVM TI</i> agentech &ndash; jejím
úkolem je ponìkud &bdquo;zlid¹tit&ldquo; názvy tøíd.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Pou¾ití tagù pøi pøiøazování objektù k&nbsp;jejich tøídám</h2>

<p>První a druhý bod na¹eho teoretického postupu tedy ji¾ máme splnìn, musíme
v¹ak je¹tì implementovat dva dal¹í body &ndash; pøiøadit <i>tag</i> ke ka¾dé
tøídì a následnì tento <i>tag</i> vhodnì pou¾ít v&nbsp;callback funkci. O
pøiøazení tagu ke tøídì èi objektu se stará funkce <strong>SetTag()</strong>
s&nbsp;následující hlavièkou:</p>

<pre>
jvmtiError <strong>SetTag</strong>(
            jvmtiEnv* env,
            jobject object,
            jlong tag)
</pre>

<p>Relativnì snadno lze tuto funkci vlo¾it do kódu z&nbsp;pøedchozí kapitoly a
následnì tento kód zaøadit do funkce
<strong>callback_on_data_dump_request()</strong>. Nesmíme zapomenout na jednu
malièkost &ndash; èíslo tagu zaèíná jednièkou a ne nulou, tak¾e pro tag èíslo
<i>n</i> bude pøíslu¹né jméno tøídy ulo¾ené v&nbsp;globálním poli
<strong>class_names</strong> pod indexem <i>n-1</i>. Celý zdrojový kód této
funkce je sice pomìrnì dlouhý, ale to jenom z&nbsp;toho dùvodu, ¾e je zapotøebí
ruènì alokovat pamì», pracovat s&nbsp;øetìzci s&nbsp;vyu¾itím céèkových funkcí
a takté¾ kontrolovat návratové hodnoty <i>JVM TI</i> funkcí:</p>

<pre>
<i>/*</i>
<i> * Callback funkce zavolana pri cteni informaci z haldy.</i>
<i> */</i>
static void JNICALL <strong>callback_on_data_dump_request</strong>(jvmtiEnv *jvmti_env)
{
    jvmtiError error;
    jint       class_count;
    jclass    *class_array;
    int        i;
&nbsp;
    MSG("Got data dump request");
&nbsp;
    <i>/* Pøeèíst jména v¹ech naètených tøíd. */</i>
    error = (*jvmti_env)-&gt;<strong>GetLoadedClasses</strong>(jvmti_env, &amp;class_count, &amp;class_array);
    check_jvmti_error(jvmti_env, error, "get loaded classes");
&nbsp;
    <i>/* Alokovat globální pole, které bude jména obsahovat. */</i>
    class_names = (char**)malloc(class_count * sizeof(char*));
&nbsp;
    <i>/* Projít získaným seznamem. */</i>
    for (i=0; i &lt; class_count; i++)
    {
        char *class_name_ptr;
        char *updated_class_name_ptr;
&nbsp;
    <i>    /* Získat jméno (signaturu) jedné tøídy */</i>
        error = (*jvmti_env)-&gt;<strong>GetClassSignature</strong>(jvmti_env, class_array[i], &amp;class_name_ptr, NULL);
        check_jvmti_error(jvmti_env, error, "get class signature");
        if (class_name_ptr == NULL)
        {
            puts("Error: class has no signature");
        }
&nbsp;
    <i>    /* Upravit jméno tøídy do èitelnìj¹í podoby. */</i>
        updated_class_name_ptr = update_class_name(class_name_ptr, ' ');
&nbsp;
    <i>    /* Kopie jména tøídy do globálního pole class_names. */</i>
        class_names[i] = (char*)malloc(1 + strlen(updated_class_name_ptr));
        strcpy(class_names[i], updated_class_name_ptr);
&nbsp;
        printf("class %s has tag %d\n", class_names[i], i + 1);
&nbsp;
    <i>    /* Dealokace pamìti vrácené funkcí GetClassSignature() */</i>
        error = (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char *)class_name_ptr);
        check_jvmti_error(jvmti_env, error, "deallocate class name");
&nbsp;
<i>        /* Nastavení tagu pro tøídu. */</i>
        error = (*jvmti_env)-&gt;<strong>SetTag</strong>(jvmti_env, class_array[i], i + 1);
        check_jvmti_error(jvmti_env, error, "deallocate class name");
    }
    register_heap_callback_and_run_dump(jvmti_env);
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Dvacátý demonstraèní pøíklad &ndash; výpis v¹ech objektù na haldì vèetnì jména pøíslu¹né tøídy</h2>

<p>Poslední variantu funkce <strong>callback_on_data_dump_request()</strong>
uvedenou <a href="#k07">v&nbsp;pøedchozí kapitole</a> pou¾ijeme ve dvacátém
demonstraèním <i>JVM TI</i> agentovi. Tato funkce pøipraví globální seznam jmen
tøíd a pøiøadí ka¾dé tøídì nìjaký <i>tag</i>, tj.&nbsp;celé èíslo odli¹né od
nuly. Následnì je zavolána funkce
<strong>register_heap_callback_and_run_dump()</strong>, která zaregistruje
callback funkci pøes datovou strukturu <strong>jvmtiHeapCallbacks</strong>,
zavolá funkci <strong>IterateThroughHeap()</strong> a následnì na standardní
výstup vypí¹e poèet objektù ulo¾ených na haldì i celkovou obsazenost haldy
v&nbsp;bajtech:</p>

<pre>
<i>/*</i>
<i> * Registrace callback funkce pro prochazeni heapem a zacatek prochazeni.</i>
<i> */</i>
static void <strong>register_heap_callback_and_run_dump</strong>(jvmtiEnv *jvmti_env)
{
    jvmtiError error;
    jvmtiHeapCallbacks heap_callbacks;
    t_heap_stat heap_stat = {0,0};
&nbsp;
<i>    /* naplnit strukturu heap_callbacks jednou callback funkci */</i>
    (void)memset(&amp;heap_callbacks, 0, sizeof(heap_callbacks));
    heap_callbacks.heap_iteration_callback = &amp;callback_for_heap_object;
&nbsp;
<i>    /* zahajit prochazeni haldou */</i>
    error = (*jvmti_env)-&gt;IterateThroughHeap(jvmti_env, 0, NULL,
            &amp;heap_callbacks, (const void *)&amp;heap_stat);
    check_jvmti_error(jvmti_env, error, "read heap content");
&nbsp;
<i>    /* vypis statistiky */</i>
    printf("Object count: %d\n", heap_stat.object_count);
    printf("Total size:   %ld bytes\n", heap_stat.total_size);
}
</pre>

<p>Jak zajisté oèekáváte, do¹lo i ke zmìnì samotné callback funkce
<strong>callback_for_heap_object()</strong> volané pro ka¾dý objekt na haldì.
Vylep¹ená varianta této funkce pou¾ije globální seznam jmen tøíd
<strong>class_names</strong> spoleènì s&nbsp;hodnotou parametru
<strong>class_tag</strong> k&nbsp;získání jména tøídy, z&nbsp;ní¾ byl daný
objekt získán. V&nbsp;produkèním kódu by zde bylo nutné pøidat kontrolu, zda se
náhodou nepøekraèuje kapacita pole <strong>class_names</strong>, zde se to
pro jednoduchost neprovádí:</p>

<pre>
<i>/*</i>
<i> * Callback funkce volana pro kazdy objekt "navstiveny" na halde.</i>
<i> */</i>
static jint JNICALL <strong>callback_for_heap_object</strong>(jlong class_tag, jlong size, jlong* tag_ptr,
        jint length, void* user_data)
{
    int index = class_tag - 1;
    t_heap_stat *heap_stat = (t_heap_stat*)user_data;
&nbsp;
    heap_stat-&gt;object_count++;
    heap_stat-&gt;total_size += size;
    printf("instance of class %s with tag #%ld of size %ld\n",
            class_names[index], (long int)class_tag, (long int)size);
    return JVMTI_VISIT_OBJECTS;
}
</pre>

<p>Z&nbsp;výpisu práce tohoto demonstraèního agenta je patrné, ¾e jsme se
koneènì dostali k&nbsp;po¾adovaným jménùm tøíd. Ty jsou vypsány hned na
zaèátku:</p>

<pre>
Agent20: Agent_OnLoad
Agent20: JVM TI version is correct
Agent20: Got VM init event
Agent20: Got VM Death event
Agent20: Got data dump request
class java.io.BufferedOutputStream  has tag 1
class java.util.Enumeration  has tag 3
class sun.misc.Version  has tag 4
class sun.misc.ExtensionDependency  has tag 5
class java.nio.HeapByteBuffer  has tag 6
class java.util.Arrays  has tag 7
class sun.misc.JavaIOAccess  has tag 8
class java.util.IdentityHashMap  has tag 9
class java.net.URLStreamHandlerFactory  has tag 10
class java.util.AbstractCollection  has tag 11
class java.util.AbstractMap  has tag 12
class java.util.concurrent.locks.AbstractOwnableSynchronizer  has tag 13
class java.lang.ClassCastException  has tag 14
class java.lang.Class  has tag 169
...
...
...
</pre>

<p>Mnoho tøíd obsahuje ve svém jménu znak &bdquo;$&ldquo;. V&nbsp;tomto pøípadì
se v&nbsp;nìkterých pøípadech jedná o vnitøní tøídy:</p>

<pre>
class java.lang.Thread$UncaughtExceptionHandler  has tag 15
class java.util.HashMap$KeySet  has tag 49
class java.util.IdentityHashMap$KeyIterator  has tag 73
class java.util.concurrent.locks.ReentrantLock$Sync  has tag 179
</pre>

<p>A v&nbsp;dal¹ích pøípadech pak o tøídy anonymní:</p>

<pre>
class java.lang.Class$3  has tag 2
class java.io.File$1  has tag 68
class java.lang.Class$1  has tag 154
class java.io.File$2  has tag 178
class java.nio.charset.CoderResult$2  has tag 180
</pre>

<p>U nìkterých jmen naleznete na zaèátku jeden èi více znakù &bdquo;[&ldquo;,
jejich¾ význam v¹ak ji¾ známe &ndash; oznaèují pole, popø.&nbsp;vícerozmìrné
pole o tolika dimenzích, kolik znakù je zde umístìno. Typy prvkù pole jsou
zapsány ihned za tìmito závorkami:</p>

<pre>
class [Ljava.lang.Comparable  has tag 88
class [Ljava.io.ObjectStreamField  has tag 93
class [Ljava.util.Map$Entry  has tag 221
class [Ljava.lang.String  has tag 230
</pre>

<p>Poslední speciální skupinou tøíd jsou pole obsahující jako své polo¾ky
primitivní datové typy. Tato pole opìt zaèínají jedním èi více znaky
&bdquo;[&ldquo;, ov¹em namísto jmen tøíd se pou¾ívají jednopísmenné zkratky
odpovídající základním datovým typùm Javy:</p>

<pre>
class [Z has tag 372
class [B has tag 373
class [C has tag 374
class [I has tag 375
class [S has tag 376
class [J has tag 377
class [F has tag 378
class [[F has tag 379
class [D has tag 380
</pre>

<p>Pøevodní tabulku pro tyto kódy jsme si ji¾ v&nbsp;tomto seriálu nìkolikrát
uvedli, ale mo¾ná nebude na ¹kodu si ji zopakovat:</p>

<table>
<tr><th>#</th><th>Znak</th><th>Datový typ</th><th>Význam</th></tr>
<tr><td>1</td><td>B</td><td>byte</td><td>osmibitové celé èíslo se znaménkem</td></tr>
<tr><td>2</td><td>C</td><td>char</td><td>znak reprezentovaný v&nbsp;Unikódu</td></tr>
<tr><td>3</td><td>D</td><td>double</td><td>èíslo s&nbsp;plovoucí øádovou èárkou s&nbsp;dvojitou pøesností</td></tr>
<tr><td>4</td><td>F</td><td>float</td><td>èíslo s&nbsp;plovoucí øádovou èárkou s&nbsp;jednoduchou pøesností</td></tr>
<tr><td>5</td><td>I</td><td>int</td><td>32bitové celé èíslo se znaménkem</td></tr>
<tr><td>6</td><td>J</td><td>long</td><td>64bitové celé èíslo se znaménkem</td></tr>
<tr><td>7</td><td>S</td><td>short</td><td>16bitové celé èíslo se znaménkem</td></tr>
<tr><td>8</td><td>Z</td><td>boolean</td><td>pravdivostní hodnota true/false</td></tr>
<tr><td>9</td><td>V</td><td>void</td><td>void &ndash; pouze u návratového typu (nebude pou¾ito ve výpisu haldy)</td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Zdrojové kódy v¹ech tøí demonstraèních pøíkladù</h2>

<p>Podobnì jako v&nbsp;minulé a pøedminulé èásti tohoto seriálu, i dne¹ní tøi
demonstraèní pøíklady byly kvùli snaz¹ímu udr¾ování v¹ech zdrojových kódù
ulo¾eny do Mercurial repositáøe, který je dostupný na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
Prozatím poslední verze dnes popisovaných <i>JVM TI</i> agentù i dal¹í potøebné
skripty a testovací javovské tøídy jsou dostupné na následujících adresách:</p>

<table>
<tr><th>Demonstraèní pøíklad</th><th>Umístìní</th></tr>
<tr><td>Agent #18</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2cce3440ed10/jvmti-agents/agent18/agent18.c">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2cce3440ed10/jvmti-agents/agent18/agent18.c</a></td></tr>
<tr><td>skript pro pøeklad</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2cce3440ed10/jvmti-agents/agent18/compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2cce3440ed10/jvmti-agents/agent18/compile.sh</a></td></tr>
<tr><td>skript pro spu¹tìní</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2cce3440ed10/jvmti-agents/agent18/test.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2cce3440ed10/jvmti-agents/agent18/test.sh</a></td></tr>
<tr><td>Agent #19</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2cce3440ed10/jvmti-agents/agent19/agent19.c">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2cce3440ed10/jvmti-agents/agent19/agent19.c</a></td></tr>
<tr><td>skript pro pøeklad</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2cce3440ed10/jvmti-agents/agent19/compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2cce3440ed10/jvmti-agents/agent19/compile.sh</a></td></tr>
<tr><td>skript pro spu¹tìní</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2cce3440ed10/jvmti-agents/agent19/test.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2cce3440ed10/jvmti-agents/agent19/test.sh</a></td></tr>
<tr><td>Agent #20</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2cce3440ed10/jvmti-agents/agent20/agent20.c">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2cce3440ed10/jvmti-agents/agent20/agent20.c</a></td></tr>
<tr><td>skript pro pøeklad</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2cce3440ed10/jvmti-agents/agent20/compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2cce3440ed10/jvmti-agents/agent20/compile.sh</a></td></tr>
<tr><td>skript pro spu¹tìní</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2cce3440ed10/jvmti-agents/agent20/test.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2cce3440ed10/jvmti-agents/agent20/test.sh</a></td></tr>
</table>



<p><a name="k10"></a></p>
<h2 id="k10">10. Odkazy na Internetu</h2>

<ol>

<li>The JVM Tool Interface (JVM TI): How VM Agents Work<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html">http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html</a>
</li>

<li>JVM Tool Interface Version 1.2<br />
<a href="http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html">http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html</a>
</li>

<li>Creating a Debugging and Profiling Agent with JVMTI<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html">http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html</a>
</li>

<li>JVM TI (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/JVM_TI">http://en.wikipedia.org/wiki/JVM_TI</a>
</li>

<li>IBM JVMTI extensions<br />
<a href="http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html">http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

