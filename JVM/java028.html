<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM (11.èást - instrukce pro tvorbu polí a pøístup k prvkùm polí)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM (11.èást - instrukce pro tvorbu polí a pøístup k prvkùm polí)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Poèet ji¾ popsaných instrukcí virtuálního stroje Javy se nám utì¹enì zvìt¹uje. V dne¹ní èásti seriálu o programovacím jazyce Java i o JVM se zamìøíme na popis dal¹ích dvaceti instrukcí. Bude se jednat o instrukce pou¾ívané pro vytváøení polí rùzných typù a pro pøístup k prvkùm tìchto polí.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Instrukce <strong>newarray</strong></a></p>
<p><a href="#k02">2. První demonstraèní pøíklad &ndash; vytvoøení jednorozmìrných polí s&nbsp;vyu¾itím instrukce <strong>newarray</strong></a></p>
<p><a href="#k03">3. Vytvoøení pole objektù pomocí instrukce <strong>anewarray</strong></a></p>
<p><a href="#k04">4. První demonstraèní pøíklad &ndash; vytvoøení jednorozmìrných polí s&nbsp;vyu¾itím instrukce <strong>anewarray</strong></a></p>
<p><a href="#k05">5. Pole s&nbsp;více dimenzemi a instrukce <strong>multianewarray</strong></a></p>
<p><a href="#k06">6. Tøetí demonstraèní pøíklad &ndash; vytvoøení polí o více dimenzích</a></p>
<p><a href="#k07">7. Pøístup k&nbsp;prvkùm pole</a></p>
<p><a href="#k08">8. Ètvrtý demonstraèní pøíklad &ndash; pøístup k&nbsp;prvkùm jednorozmìrných polí</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Instrukce <strong>newarray</strong></h2>

<p><a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-10-cast-instrukce-pro-praci-s-tridami-a-objekty/">V&nbsp;pøedchozí èásti</a> <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyce Java</a> i o vlastnostech virtuálního stroje Javy jsme se
zabývali instrukcemi vyu¾ívanými pro vytváøení objektù, pøístup ke statickým i
nestatickým atributùm a takté¾ k&nbsp;instrukcím, pomocí nich¾ se volají
statické metody, virtuální metody i metody speciální (zejména konstruktory).
Je¹tì nám v¹ak zbývá popis instrukcí pou¾ívaných pøi práci se druhým
v&nbsp;Javì existujícím referenèním datovým typem &ndash; jedná se o pole.
Pøipomeòme si, ¾e <i>objekty</i> jsou spoleènì s&nbsp;<i>poli</i> pova¾ovány za
takzvané <i>referenèní datové typy</i>, z&nbsp;toho dùvodu, ¾e se v&nbsp;Javì
pøedávají ve formì referencí a nikoli pøímo hodnoty. Zatímco objekty se vytváøí
pomocí instrukce <strong>new</strong> a pro pøístup k&nbsp;jejich atributùm se
pou¾ívají instrukce <strong>getfield</strong> a <strong>putfield</strong>, je
situace v&nbsp;pøípadì polí odli¹ná, proto¾e se pro pole pou¾ívá dvacet
specializovaných instrukcí slou¾ících jak pro vytvoøení pole, tak i pro pøístup
k&nbsp;jeho prvkùm, popø.&nbsp;pro zji¹tìní délky pole.</p>

<p>První instrukcí, se kterou se dnes seznámíme, je instrukce nazvaná
<strong>newarray</strong>. Pravdìpodobnì uhodnete, k&nbsp;èemu tato instrukce
slou¾í &ndash; lze ji pou¾ít pro vytvoøení pole dané délky, ov¹em pouze
v&nbsp;tom pøípadì, pokud má pole obsahovat prvky nìkterého z&nbsp;primitivních
datových typù, tj.&nbsp;pravdivostní hodnoty, znaky, celá èísla èi èísla
s&nbsp;plovoucí øádovou èárkou. Jinými slovy to znamená, ¾e tuto instrukci
nelze pou¾ít napøíklad pro vytvoøení pole objektù. Formát instrukce
<strong>newarray</strong> je vypsán v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Provádìná operace</th></tr>
<tr><td>1</td><td>newarray</td><td>0xBC</td><td>arraytype</td><td>Vytvoøí nové pole s prvky primitivního datového typu</td></tr>
</table>

<p>Instrukce <strong>newarray</strong> oèekává, ¾e na vrcholu zásobníku
operandù (<i>TOS</i>) bude ulo¾ena hodnota typu <strong>int</strong> udávající
velikost pole. Tato hodnota je ze zásobníku v&nbsp;prùbìhu vytváøení pole
odstranìna a namísto ní se na vrchol zásobníku operandù ulo¾í reference na
právì vytvoøené pole. Je¹tì nám zbývá popsat operand instrukce
<strong>newarray</strong> nazvaný <i>arraytype</i>. Jde o jednobajtový operand,
jeho¾ hodnota urèuje typ prvkù vytváøeného pole. Jak jsme si ji¾ øekli
v&nbsp;pøedchozím odstavci, mù¾e se pomocí instrukce <strong>newarray</strong>
vytvoøit pole slo¾ené z&nbsp;pravdivostních hodnot, znakù, celých èísel èi
èísel s&nbsp;plovoucí øádovou èárkou (ve v¹ech pøípadech se jedná o primitivní
datové typy):</p>

<table>
<tr><th>Arraytype</th><th>Typ prvkù pole</th></tr>
<tr><td> 4</td><td>boolean</td></tr>
<tr><td> 5</td><td>char</td></tr>
<tr><td> 6</td><td>float</td></tr>
<tr><td> 7</td><td>double</td></tr>
<tr><td> 8</td><td>byte</td></tr>
<tr><td> 9</td><td>short</td></tr>
<tr><td>10</td><td>int</td></tr>
<tr><td>11</td><td>long</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. První demonstraèní pøíklad &ndash; vytvoøení jednorozmìrných polí s&nbsp;vyu¾itím instrukce <strong>newarray</strong></h2>

<p>Zpùsob pou¾ití instrukce <strong>newarray</strong> si uká¾eme na jednoduchém
demonstraèním pøíkladu, v&nbsp;jeho¾ tøídì je deklarována jediná (statická)
metoda, po jejím¾ zavolání se vytvoøí osm lokálních promìnných, pøièem¾ ka¾dá
promìnná je referencí na pole zadané délky. Zdrojový kód tohoto demonstraèního
pøíkladu je velmi jednoduchý:</p>

<pre>
class CreateArrayTest {
&nbsp;
    static void createArrays(int size) {
        boolean[] booleanArray    = new boolean[size];
        char[]    charArray       = new char[size];
        byte[]    byteArray       = new byte[size];
        short[]   shortArray      = new short[size];
        int[]     intArray        = new int[size];
        long[]    longArray       = new long[size];
        float[]   floatArray      = new float[size];
        double[]  doubleegerArray = new double[size];
    }
&nbsp;
}
</pre>

<p>Pøekladaè <strong>javac</strong> vygeneruje bajtkód, v&nbsp;nìm¾ jsou
pou¾ity instrukce pro vytvoøení v¹ech osmi lokálních promìnných, i kdy¾ ve
skuteènosti nejsou tyto promìnné nikde pou¾ity. Z&nbsp;výpisu je patrné, ¾e
ka¾dé pole je vytvoøeno s&nbsp;vyu¾itím pouze tøech instrukcí &ndash; ulo¾ení
poètu prvkù vytváøeného pole na zásobník, vlastní vytvoøení (konstrukce) pole a
nakonec ulo¾ení reference do lokální promìnné:</p>

<pre>
static void createArrays(int);
  Code:
   0:     iload_0            // na TOS zásobníku operandù se ulo¾í délka vytváøeného pole
   1:     newarray boolean   // vytvoøení pole s prvky typu boolean
   3:     astore_1           // reference na pole se ulo¾í do lokální promìnné
&nbsp;
   4:     iload_0            // na TOS zásobníku operandù se ulo¾í délka vytváøeného pole
   5:     newarray char      // vytvoøení pole s prvky typu char
   7:     astore_2           // reference na pole se ulo¾í do lokální promìnné
&nbsp;
   8:     iload_0            // na TOS zásobníku operandù se ulo¾í délka vytváøeného pole
   9:     newarray byte      // vytvoøení pole s prvky typu byte
   11:    astore_3           // reference na pole se ulo¾í do lokální promìnné
&nbsp;
   12:    iload_0            // na TOS zásobníku operandù se ulo¾í délka vytváøeného pole
   13:    newarray short     // vytvoøení pole s prvky typu short
   15:    astore    4        // reference na pole se ulo¾í do lokální promìnné
&nbsp;
   17:    iload_0            // na TOS zásobníku operandù se ulo¾í délka vytváøeného pole
   18:    newarray int       // vytvoøení pole s prvky typu int
   20:    astore    5        // reference na pole se ulo¾í do lokální promìnné
&nbsp;
   22:    iload_0            // na TOS zásobníku operandù se ulo¾í délka vytváøeného pole
   23:    newarray long      // vytvoøení pole s prvky typu long
   25:    astore    6        // reference na pole se ulo¾í do lokální promìnné
&nbsp;
   27:    iload_0            // na TOS zásobníku operandù se ulo¾í délka vytváøeného pole
   28:    newarray float     // vytvoøení pole s prvky typu float
   30:    astore    7        // reference na pole se ulo¾í do lokální promìnné
&nbsp;
   32:    iload_0            // na TOS zásobníku operandù se ulo¾í délka vytváøeného pole
   33:    newarray double    // vytvoøení pole s prvky typu double
   35:    astore    8        // reference na pole se ulo¾í do lokální promìnné
&nbsp;
   37:    return             // návrat z metody
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Vytvoøení pole objektù pomocí instrukce <strong>anewarray</strong></h2>

<p>Dal¹í instrukcí pou¾ívanou pøi vytváøení polí je instrukce nazvaná
<strong>anewarray</strong> (na zaèátku jména této instrukce se nachází znak
&bdquo;a&ldquo;). Tato instrukce se pou¾ívá pro vytvoøení pole, jeho¾ prvky
jsou objekty, a to objekty libovolného (specifikovaného) typu. Zatímco se u
instrukce <strong>newarray</strong> popsané <a href="#k01">v&nbsp;první
kapitole</a> specifikoval typ prvkù pole pomocí hodnoty bajtu ulo¾eného ihned
za operaèním kódem instrukce, je nutné u instrukce <strong>anewarray</strong>
pou¾ít celé jméno tøídy, rozhraní èi výètového typu (udávající typ prvkù pole).
Toto jméno tøídy je, jak pravdìpodobnì ji¾ tu¹íte, ulo¾ené v&nbsp;<i>constant
poolu</i>, tak¾e se za operaèním kódem instrukce <strong>anewarray</strong>
nachází dvojice bajtù pøedstavujících index záznamu v&nbsp;<i>constant
poolu</i>. Chování obou zmínìných instrukcí v¹ak zùstává stejné &ndash;
z&nbsp;vrcholu zásobníku operandù se vyzvedne hodnota typu <i>int</i>
pøedstavující velikost pole, pole daného typu se vytvoøí a následnì se na
zásobník operandù ulo¾í reference na vytvoøený objekt (v&nbsp;pøípadì polí
objektù samozøejmì nejsou tyto objekty vytvoøeny a pole obsahuje hodnoty
<strong>null</strong>):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Provádìná operace</th></tr>
<tr><td>1</td><td>anewarray</td><td>0xBD</td><td>highbyte, lowbyte</td><td>Vytvoøí nové pole objektù</td></tr>
</table>

<p>Operandy <i>highbyte</i> a <i>lowbyte</i> tvoøí dohromady ¹estnáctibitový
index do <i>constant poolu</i>. Záznam ulo¾ený na tomto indexu musí být typu
<i>ClassName</i> a mù¾e se jednat buï o název bì¾né tøídy nebo o název rozhraní
èi dokonce o název výètového typu.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. První demonstraèní pøíklad &ndash; vytvoøení jednorozmìrných polí s&nbsp;vyu¾itím instrukce <strong>anewarray</strong></h2>

<p>Zpùsob vyu¾ití instrukce <strong>anewarray</strong> si opìt uká¾eme na
jednoduchém demonstraèním pøíkladu. V&nbsp;tomto pøíkladu je v&nbsp;metodì
<strong>createObjectArrays</strong> vytvoøeno celkem pìt polí. První tøi pole
mohou obsahovat prvky typu <strong>Object</strong>, <strong>String</strong> a
<strong>Color</strong>, popø.&nbsp;potomky tìchto tøíd. Zajímavé je ètvrté
pole, které mù¾e obsahovat jakýkoli typ objektu, jeho¾ tøída implementuje
rozhraní <strong>Comparable</strong>, tj.&nbsp;mù¾e se napøíklad jednat o
øetìzce, obalové objekty primitivních datových typù (<strong>Integer,
Double...</strong>), data (<strong>Data</strong>), objekty typu
<strong>BigInteger</strong> a <strong>BigDecimal</strong> atd. Páté pole mù¾e
obsahovat prvky výètového typu <strong>WeekDay</strong>:</p>

<pre>
import java.awt.Color;
&nbsp;
enum WeekDay {
    MON, TUE, WED, THU, FRI, SAT, SUN
}
&nbsp;
class CreateObjectArrayTest {
&nbsp;
    static void createObjectArrays(int size) {
        Object[]     objects  = new Object[size];
        String[]     strings  = new String[size];
        Color[]      colors   = new Color[size];
        Comparable[] xyzzy    = new Comparable[size];
        WeekDay[]    weekDays = new WeekDay[size];
    }
&nbsp;
}
</pre>

<p>Podívejme se nejdøíve na obsah <i>constant poolu</i>. Polo¾ky, které nás
budou zajímat, jsou oznaèeny hvìzdièkami:</p>

<pre>
const #1 = Method       #2.#16; //  java/lang/Object."&lt;init&gt;":()V
***************************************************************
const #2 = class        #17;    //  java/lang/Object
const #3 = class        #18;    //  java/lang/String
const #4 = class        #19;    //  java/awt/Color
const #5 = class        #20;    //  java/lang/Comparable
const #6 = class        #21;    //  WeekDay
***************************************************************
const #7 = class        #22;    //  CreateObjectArrayTest
const #8 = Asciz        &lt;init&gt;;
const #9 = Asciz        ()V;
const #10 = Asciz       Code;
const #11 = Asciz       LineNumberTable;
const #12 = Asciz       createObjectArrays;
const #13 = Asciz       (I)V;
const #14 = Asciz       SourceFile;
const #15 = Asciz       Test1.java;
const #16 = NameAndType #8:#9;//  "&lt;init&gt;":()V
const #17 = Asciz       java/lang/Object;
const #18 = Asciz       java/lang/String;
const #19 = Asciz       java/awt/Color;
const #20 = Asciz       java/lang/Comparable;
const #21 = Asciz       WeekDay;
const #22 = Asciz       CreateObjectArrayTest;
</pre>

<p>Nyní se ji¾ mù¾eme podívat na bajtkód metody
<strong>createObjectArrays</strong> vygenerovaný pøekladaèem
<strong>javac</strong>:</p>

<pre>
static void createObjectArrays(int);
  Code:
   0:     iload_0            // na TOS zásobníku operandù se ulo¾í délka vytváøeného pole
   1:     anewarray #2;      // vytvoøení pole s prvky typu java/lang/Object
   4:     astore_1           // reference na pole se ulo¾í do lokální promìnné
&nbsp;
   5:     iload_0            // na TOS zásobníku operandù se ulo¾í délka vytváøeného pole
   6:     anewarray #3;      // vytvoøení pole s prvky typu java/lang/String
   9:     astore_2           // reference na pole se ulo¾í do lokální promìnné
&nbsp;
   10:    iload_0            // na TOS zásobníku operandù se ulo¾í délka vytváøeného pole
   11:    anewarray #4;      // vytvoøení pole s prvky typu java/awt/Color
   14:    astore_3           // reference na pole se ulo¾í do lokální promìnné
&nbsp;
   15:    iload_0            // na TOS zásobníku operandù se ulo¾í délka vytváøeného pole
   16:    anewarray #5;      // vytvoøení pole s prvky typu java/lang/Comparable
   19:    astore    4        // reference na pole se ulo¾í do lokální promìnné
&nbsp;
   21:    iload_0            // na TOS zásobníku operandù se ulo¾í délka vytváøeného pole
   22:    anewarray #6;      // vytvoøení pole s prvky typu WeekDay
   25:    astore    5        // reference na pole se ulo¾í do lokální promìnné
&nbsp;
   27:    return             // návrat z metody
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Pole s&nbsp;více dimenzemi a instrukce <strong>multianewarray</strong></h2>

<p>Obì dnes popsané instrukce <strong>newarray</strong> a
<strong>anewarray</strong> mají jedno pomìrnì zásadní omezení &ndash; jsou
toti¾ vyu¾itelné pouze pro vytvoøení jednorozmìrných polí. Pokud se v¹ak ve
zdrojovém kódu vyskytuje programová konstrukce pro vytvoøení polí o více
dimenzích, vygeneruje pøekladaè jinou instrukci nazvanou
<strong>multianewarray</strong>. Jedná se, spoleènì s&nbsp;ji¾ popsanými
instrukcemi <strong>tableswitch</strong> a <strong>lookupswich</strong> o jednu
z&nbsp;nejslo¾itìj¹ích instrukcí, kterou mù¾eme v&nbsp;bajtkódu najít, proto¾e
se za jejím operaèním kódem nachází hned tøi doplòkové bajty. První dva bajty
tvoøí spoleènì index do <i>constant poolu</i>, v&nbsp;nìm¾ se nachází záznam o
typu prvkù ulo¾ených v&nbsp;poli (vìt¹inou se jedná o typ odpovídající poli,
jeho¾ poèet dimenzí odpovídá poètu dimenzí pole vytváøeného). Tøetí bajt
ulo¾ený za operaèním kódem instrukce <strong>multianewarray</strong> obsahuje
poèet dimenzí vytváøeného pole, z&nbsp;èeho¾ mimochodem vyplývá, ¾e pole mù¾e
mít &bdquo;pouze&ldquo; 256 dimenzí ;-). Pøed zavoláním této instrukce se musí
na zásobník operandù ulo¾it rozmìry vytváøeného pole, pøièem¾ poèet rozmìrù
ulo¾ených na zásobníku musí odpovídat (vcelku logicky) poètu dimenzí,
tj.&nbsp;hodnotì ulo¾ené ve tøetím bajtu za operaèním kódem instrukce
<strong>multianewarray</strong>.</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Provádìná operace</th></tr>
<tr><td>1</td><td>multianewarray</td><td>0xC5</td><td>highbyte, lowbyte, dimensions</td><td>Vytvoøí vícedimenzionální pole o <i>dimensions</i> dimenzích</td></tr>
</table>

<p>Operandy <i>highbyte</i> a <i>lowbyte</i> opìt spoleènì tvoøí
¹estnáctibitový index do <i>constant poolu</i>. Pokud se napøíklad vytváøí
dvourozmìrné pole s&nbsp;prvky typu <strong>String</strong>, bude
v&nbsp;<i>constant poolu</i> ulo¾en záznam typu <i>ClassName</i> obsahující
hodnotu &bdquo;[[Ljava/lang/String;&ldquo;. Podobné to bude i v&nbsp;pøípadì
vícerozmìrného pole s&nbsp;prvky typu celé èíslo èi pravdivostní hodnota.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Tøetí demonstraèní pøíklad &ndash; vytvoøení polí o více dimenzích</h2>

<p>Dne¹ní tøetí demonstraèní pøíklad je ponìkud slo¾itìj¹í ne¾ pøedchozí dva
pøíklady. V&nbsp;pøíkladu jsou deklarovány dvì statické metody, pøièem¾
v&nbsp;první metodì se vytvoøí lokální promìnná obsahující dvourozmìrné pole
s&nbsp;prvky typu <strong>int</strong>, zatímco druhá metoda vytvoøí a vrátí
trojrozmìrné pole, do nìho¾ se mohou ukládat instance tøídy
<strong>Color</strong> (toto trojrozmìrné pole je mo¾né napøíklad pou¾ít pøi
<i>volume renderingu</i>). Následuje výpis zdrojového kódu tøetího
demonstraèního pøíkladu:</p>

<pre>
import java.awt.Color;
&nbsp;
class MultidimensionalArraysTest {
&nbsp;
    static void createMatrix(int dim1, int dim2) {
        int[][] matrix = new int[dim1][dim2];
    }
&nbsp;
    static Color[][][] createVolume(int dim1, int dim2, int dim3) {
        return new Color[dim1][dim2][dim3];
    }
&nbsp;
}
</pre>

<p>Podobnì jako u pøedchozího demonstraèního pøíkladu, kde jsme si vysvìtlovali
zpùsob pou¾ití instrukce <strong>anewarray</strong>, i nyní bude vhodné se
nejdøíve podívat na obsah <i>constant poolu</i> ulo¾eného v&nbsp;bajtkódu.
Záznamy, které nás zajímají, jsou zvýraznìny pomocí hvìzdièek:</p>

<pre>
const #1 = Method       #5.#16; //  java/lang/Object."&lt;init&gt;":()V
***************************************************************
const #2 = class        #17;    //  "[[I"
const #3 = class        #18;    //  "[[[Ljava/awt/Color;"
***************************************************************
const #4 = class        #19;    //  MultidimensionalArraysTest
const #5 = class        #20;    //  java/lang/Object
const #6 = Asciz        &lt;init&gt;;
const #7 = Asciz        ()V;
const #8 = Asciz        Code;
const #9 = Asciz        LineNumberTable;
const #10 = Asciz       createMatrix;
const #11 = Asciz       (II)V;
const #12 = Asciz       createVolume;
const #13 = Asciz       (III)[[[Ljava/awt/Color;;
const #14 = Asciz       SourceFile;
const #15 = Asciz       Test1.java;
const #16 = NameAndType #6:#7;//  "&lt;init&gt;":()V
const #17 = Asciz       [[I;
const #18 = Asciz       [[[Ljava/awt/Color;;
const #19 = Asciz       MultidimensionalArraysTest;
const #20 = Asciz       java/lang/Object;
</pre>

<p>Následuje dissasemblovaný kód metody <strong>createMatrix</strong>.
Pov¹imnìte si, ¾e nejdøíve jsou na zásobník operandù ulo¾eny dvì hodnoty typu
<i>int</i> pøedstavující rozmìry pole a následnì je zavolána instrukce
<strong>multianewarray</strong> s&nbsp;dvojicí parametrù: první parametr
(dvoubajtový) odkazuje na záznam v&nbsp;<i>constant poolu</i> s&nbsp;indexem 2
a druhý parametr obsahuje poèet dimenzí vytváøeného pole. Typ pole ulo¾ený na
<i>constant poolu</i> pøitom odpovídá zadanému poètu dimenzí, co¾ lze
v&nbsp;tomto pøípadì jednodu¹e zjistit z&nbsp;poètu levých hranatých závorek [,
jejich¾ význam jsme si ji¾ v&nbsp;minulosti vysvìtlili:</p>

<pre>
static void createMatrix(int, int);
  Code:
   0:   iload_0                 // na zásobník operandù ulo¾it první dimenzi pole
   1:   iload_1                 // na zásobník operandù ulo¾it druhou dimenzi pole
   2:   multianewarray  #2,  2; // class "[[I" - pole polí prvkù typu int
                                // první dvojka je index do constant poolu
                                // druhá dvojka je poèet dimenzí vytváøeného pole
   6:   astore_2                // ulo¾it referenci na vytvoøené pole do lokální promìnné
   7:   return                  // návrat z metody
</pre>

<p>Metoda <strong>createVolume</strong> pou¾ívá takté¾ instrukci
<strong>multianewarray</strong>, ov¹em nyní je tato instrukce pou¾ita pro
vytvoøení pole, v&nbsp;nìm¾ mají být ulo¾eny reference na objekty typu
<strong>Color</strong>. Výsledné pole je pou¾ito jako návratová hodnota
metody:</p>

<pre>
static java.awt.Color[][][] createVolume(int, int, int);
  Code:
   0:   iload_0                 // na zásobník operandù ulo¾it první dimenzi pole
   1:   iload_1                 // na zásobník operandù ulo¾it druhou dimenzi pole
   2:   iload_2                 // na zásobník operandù ulo¾it tøetí dimenzi pole
   3:   multianewarray  #3,  3; // class "[[[Ljava/awt/Color;"
                                // první trojka je index do constant poolu
                                // druhá trojka je poèet dimenzí vytváøeného pole
   7:   areturn                 // reference vytvoøeného pole je návratovou hodnotou metody
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Pøístup k&nbsp;prvkùm pole</h2>

<p>Nyní ji¾ umíme vytvoøit jednorozmìrná i vícerozmìrná pole, která mohou
obsahovat prvky rùzných datových typù. Mezi dal¹í operace týkající se polí
patøí ètení obsahu jednotlivých prvkù, popø.&nbsp;zmìna hodnoty jednotlivých
prvkù pole. Pro tyto úèely je v&nbsp;instrukèní sadì JVM vyhrazeno ¹estnáct
instrukcí rozdìlených do dvou sad. V&nbsp;první sadì je osm instrukcí urèených
pro pøeètení prvku pole a ulo¾ení pøeètené hodnoty na vrchol zásobníku
operandù. Pøed zavoláním tìchto instrukcí musí být na zásobníku operandù
ulo¾ena reference na pole (tj.&nbsp;výsledek instrukce
<strong>newarray</strong>, <strong>anewarray</strong>) a takté¾ index prvku,
který se má pøeèíst. Pov¹imnìte si, ¾e pole s&nbsp;prvky typu
<strong>boolean</strong> je ve skuteènosti obsluhováno takovým zpùsobem, jako
by obsahovalo prvky typu <strong>byte</strong>:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Provádìná operace</th></tr>
<tr><td>1</td><td>iaload</td><td>0x2E</td><td>&times;</td><td>pøeètení prvku z pole typu int[]</td></tr>
<tr><td>2</td><td>laload</td><td>0x2F</td><td>&times;</td><td>pøeètení prvku z pole typu long[]</td></tr>
<tr><td>3</td><td>faload</td><td>0x30</td><td>&times;</td><td>pøeètení prvku z pole typu float[]</td></tr>
<tr><td>4</td><td>daload</td><td>0x31</td><td>&times;</td><td>pøeètení prvku z pole typu double[]</td></tr>
<tr><td>5</td><td>aaload</td><td>0x32</td><td>&times;</td><td>pøeètení prvku z pole typu reference[]</td></tr>
<tr><td>6</td><td>baload</td><td>0x33</td><td>&times;</td><td>pøeètení prvku z pole typu byte[] nebo boolean[]</td></tr>
<tr><td>7</td><td>caload</td><td>0x34</td><td>&times;</td><td>pøeètení prvku z pole typu char[]</td></tr>
<tr><td>8</td><td>saload</td><td>0x35</td><td>&times;</td><td>pøeètení prvku z pole typu short[]</td></tr>
</table>

<p>Ve druhé skupinì se nachází takté¾ osm instrukcí. Tyto instrukce slou¾í pro
zmìnu hodnoty vybraného prvku pole. Pøed spu¹tìním tìchto instrukcí musí být na
zásobníku operandù ulo¾ena jak reference na pole, tak i index mìnìného prvku a
samozøejmì i jeho nová hodnota:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Provádìná operace</th></tr>
<tr><td>1</td><td>iastore</td><td>0x4F</td><td>&times;</td><td>zápis nové hodnoty prvku do pole typu int[]</td></tr>
<tr><td>2</td><td>lastore</td><td>0x50</td><td>&times;</td><td>zápis nové hodnoty prvku do pole typu long[]</td></tr>
<tr><td>3</td><td>fastore</td><td>0x51</td><td>&times;</td><td>zápis nové hodnoty prvku do pole typu float[]</td></tr>
<tr><td>4</td><td>dastore</td><td>0x52</td><td>&times;</td><td>zápis nové hodnoty prvku do pole typu double[]</td></tr>
<tr><td>5</td><td>aastore</td><td>0x53</td><td>&times;</td><td>zápis nové hodnoty prvku do pole typu reference[]</td></tr>
<tr><td>6</td><td>bastore</td><td>0x54</td><td>&times;</td><td>zápis nové hodnoty prvku do pole typu byte[] nebo boolean[]</td></tr>
<tr><td>7</td><td>castore</td><td>0x55</td><td>&times;</td><td>zápis nové hodnoty prvku do pole typu char[]</td></tr>
<tr><td>8</td><td>sastore</td><td>0x56</td><td>&times;</td><td>zápis nové hodnoty prvku do pole typu short[]</td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Ètvrtý demonstraèní pøíklad &ndash; pøístup k&nbsp;prvkùm jednorozmìrných polí</h2>

<p>Je¹tì se musíme zmínit o poslední instrukci pou¾ívané pøi práci s&nbsp;poli.
Tato instrukce se jmenuje <strong>arraylength</strong> (operaèní kód
<strong>0xBE</strong>) a slou¾í pro zji¹tìní délky pole, jeho¾ reference je
ulo¾ena na zásobníku operandù. Se znalostí této instrukce si ji¾ mù¾eme ukázat
slo¾itìj¹í pøíklad, v&nbsp;jeho¾ metodì se do pole celých èísel ulo¾í prvních
tøicet prvkù Fibonacciho posloupnosti:</p>

<pre>
class FibSeq {
&nbsp;
    static void calcFibSeq() {
        int[] sequence = new int[30];
        sequence[0] = 1;
        sequence[1] = 1;
&nbsp;
        for (int i = 2; i &lt; sequence.length; i++) {
            sequence[i] = sequence[i-2] + sequence[i-1];
        }
    }
&nbsp;
}
</pre>

<p>Vzhledem k&nbsp;tomu, ¾e se ji¾ jedná o netriviální pøíklad, tak nás asi
nepøekvapí, ¾e i vygenerovaný bajtkód je pomìrnì slo¾itý a má délku celých 42
bajtù:</p>

<pre>
static void calcFibSeq();
  Code:
   0:   bipush  30              // poèet prvkù vytváøeného pole
   2:   newarray int            // vytvoøení pole o tøiceti prvcích typu int
   4:   astore_0                // ulo¾ení reference pole do první lokální promìnné
&nbsp;
   5:   aload_0                 // \
   6:   iconst_0                //  \ sequence[0] = 1;
   7:   iconst_1                //  /
   8:   iastore                 // /
&nbsp;
   9:   aload_0                 // \
   10:  iconst_1                //  \ sequence[1] = 1;
   11:  iconst_1                //  /
   12:  iastore                 // /
&nbsp;
   13:  iconst_2                // \ int i = 2;
   14:  istore_1                // /
&nbsp;
   15:  iload_1                 // hodnota èítaèe i na zásobník
   16:  aload_0                 // \ sequence.length;
   17:  arraylength             // /
   18:  if_icmpge   41          // if (i &gt; sequence.length) konec smyèky
&nbsp;
   21:  aload_0                 // \ pøíprava pro pøíkaz sequence[i] = nìco
   22:  iload_1                 // /
&nbsp;
   23:  aload_0                 // \
   24:  iload_1                 //  \
   25:  iconst_2                //   &gt; prvek sequence[i-2] ulo¾it na zásobník
   26:  isub                    //  /
   27:  iaload                  // /
&nbsp;
   28:  aload_0                 // \
   29:  iload_1                 //  \
   30:  iconst_1                //   &gt; prvek sequence[i-1] ulo¾it na zásobník
   31:  isub                    //  /
   32:  iaload                  // /
&nbsp;
   33:  iadd                    // seèíst oba prvky
   34:  iastore                 // dokonèení pøíkazu zaèínajícího na adrese 21
&nbsp;
   35:  iinc    1, 1            // i++
   38:  goto    15              // opakování smyèky
&nbsp;
   41:  return                  // návrat z metody
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Root.cz: Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM<br />
<a href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/</a></a>
</li>

<li>Root.cz: JamVM aneb alternativa k HotSpotu nejenom pro embedded zaøízení a chytré telefony<br />
<a href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>FindBugs<br />
<a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a>
</li>

<li>GNU Classpath<br />
<a href="www.gnu.org/s/classpath/">www.gnu.org/s/classpath/</a></li>

<li>Java VMs Compared<br />
<a href="http://bugblogger.com/java-vms-compared-160/">http://bugblogger.com/java-vms-compared-160/</a>
</li>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>CloseableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html">http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

