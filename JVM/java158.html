<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (10 - JIT pøeklad do nativního kódu)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (10 - JIT pøeklad do nativního kódu)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Zatímco jsme se v pøedchozích dvou èástech seriálu o just in time pøekladaèi nazvaném LuaJIT zabývali pøedev¹ím zpùsobem detekce stop (traces) v bajtkódu aplikací naprogramovaných v jazyku Lua, dnes se budeme zabývat druhým a èásteènì i tøetím krokem, který musí trasovací JIT pøekladaè provést. Jedná se o generování pseudoinstrukcí a následnì i vytváøení nativního kódu.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (10 - JIT pøeklad do nativního kódu)</a></p>
<p><a href="#k02">2. Zdrojový text &rarr; bajtkód &rarr; sekvence pseudoinstrukcí &rarr; nativní kód</a></p>
<p><a href="#k03">3. Reprezentace nalezené trasy mezikódem (pseudoinstrukcemi)</a></p>
<p><a href="#k031">&nbsp;&nbsp;&nbsp;3.1 Typy operandù</a></p>
<p><a href="#k032">&nbsp;&nbsp;&nbsp;3.2 Vybrané pseudoinstrukce</a></p>
<p><a href="#k033">&nbsp;&nbsp;&nbsp;3.3 Formát výpisu sekvence pseudoinstrukcí</a></p>
<p><a href="#k04">4. Demonstraèní pøíklady &ndash; jednoduché programové smyèku pøelo¾ené do sekvence pseudoinstrukcí</a></p>
<p><a href="#k041">&nbsp;&nbsp;&nbsp;4.1 Just-in-time pøeklad poèítané programové smyèky typu <strong>for</strong></a></p>
<p><a href="#k042">&nbsp;&nbsp;&nbsp;4.2 Just-in-time pøeklad programové smyèky typu <strong>while</strong></a></p>
<p><a href="#k05">5. Demonstraèní pøíklady &ndash; pøeklad smyèek s&nbsp;podmínkami do sekvence pseudoinstrukcí</a></p>
<p><a href="#k051">&nbsp;&nbsp;&nbsp;5.1 Just-in-time pøeklad programové smyèky s&nbsp;jedním rozvìtvením</a></p>
<p><a href="#k052">&nbsp;&nbsp;&nbsp;5.2 Just-in-time pøeklad programové smyèky se slo¾itìj¹ím rozvìtvením</a></p>
<p><a href="#k06">6. Demonstraèní pøíklad &ndash; pøeklad volání funkce do sekvence pseudoinstrukcí</a></p>
<p><a href="#k07">7. Pøeklad ze sekvence pseudoinstrukcí do nativního kódu</a></p>
<p><a href="#k08">8. Zdrojové kódy dnes pou¾itých demonstraèních pøíkladù i vygenerované sekvence pseudoinstrukcí</a></p>
<p><a href="#k09">9. Literatura</a></p>
<p><a href="#k10">10. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (10 - JIT pøeklad do nativního kódu)</h2>

<p><a
href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-9-dalsi-vlastnosti-trasovaciho-jitu/">V&nbsp;minulé</a>
a takté¾ i <a
href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-8-zakladni-vlastnosti-trasovaciho-jitu/">pøedminulé</a>
èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">tohoto
seriálu</a> jsme si vysvìtlili princip èinnosti trasovacího JITu, na nìm¾ je
celý <i>LuaJIT</i> postaven. Ov¹em samotné trasování slou¾í zejména pro
zji¹tìní, které èásti programového kódu, konkrétnì které instrukce bajtkódu je
zapotøebí pøelo¾it, tj.&nbsp;jakou èást bajtkódu lze pova¾ovat za <i>hot
loop</i> èi <i>hot call</i>. Jakmile jsou vhodné trasy detekovány, je nutné
provést vlastní just-in-time pøeklad. Právì toto je téma, jemu¾ se budeme
vìnovat dnes. Na nìkolika demonstraèních pøíkladech, s&nbsp;nimi¾ jsme se ji¾
seznámili v&nbsp;pøedchozích èástech tohoto seriálu, si uká¾eme a takté¾
zjednodu¹enì popí¹eme zpùsob, jakým je proveden ký¾ený pøeklad a popø.&nbsp;i
optimalizace nativního strojového kódu.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Zdrojový text &rarr; bajtkód &rarr; sekvence pseudoinstrukcí &rarr; nativní kód</h2>

<p>Pøed podrobnìj¹ím popisem funkce pøekladaèe implementovaného
v&nbsp;<i>LuaJITu</i> si zkusme struènì popsat, jaká cesta vede od zdrojového
textu napsaného v&nbsp;jazyku Lua a¾ k&nbsp;nativnímu (strojovému) kódu:</p>

<ol>

<li>Na zaèátku celého øetìzce se nachází zdrojový text, který typicky napí¹e
vývojáø v&nbsp;textovém editoru. V&nbsp;nìkterých pøípadech se jedná o
generovaný zdrojový text, co¾ se v¹ak nijak nedotýká problematiky JITu.</li>

<li>Pøi spu¹tìní <i>LuaJITu</i> pøíkazem <strong>luajit jméno_projektu</strong>
je zdrojový text postupnì pøekládán do bajtkódu, kterému jsme se podrobnì
vìnovali v&nbsp;¹esti dílech tohoto seriálu: <a
href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-2/">[2]</a>,
<a
href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-3/">[3]</a>,
<a
href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-4/">[4]</a>,
<a
href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-5-tabulky-a-pole/">[5]</a>,
<a
href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-6-preklad-programovych-smycek-do-mezijazyka-luajitu/">[6]</a>
a <a
href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-7-dokonceni-popisu-mezijazyka-luajitu/">[7]</a>.</li>

<li>Bajtkód je ihned interpretován a souèasnì se v&nbsp;nìm vyhledávají <i>hot
calls</i> a <i>hot loops</i>, tedy takové sekvence instrukcí bajtkódu, které by
bylo vhodné JITovat.</li>

<li>Jakmile je nalezena vhodná stopa, je sekvence instrukcí bajtkódu tvoøící
tuto stopu pøelo¾ena do sekvence pseudoinstrukcí. V&nbsp;tomto mezistupni se
ji¾ pracuje s&nbsp;konkrétními datovými typy a samotný formát pseudoinstrukcí
je zvolen takovým zpùsobem, aby se dobøe provádìly optimalizace i poslední
krok.</li>

<p>Posledním krokem je transformace z&nbsp;pseudoinstrukcí do nativního
strojového kódu. Zde se pou¾ívají ¹ablony pøipravené pro konkrétní typy
mikroprocesorù a hlavním úkolem JITu je alokace registrù. Strojový kód v¹ak
stále obsahuje vlo¾ené kontroly, zda jsou dodr¾eny výchozí podmínky provádìní
stopy. Pokud se napøíklad dojde k&nbsp;tomu, ¾e se má vykonat jiná vìtev, je
bìh nativní èásti pøeru¹en.</p>

</ol>



<p><a name="k03"></a></p>
<h2 id="k03">3. Reprezentace nalezené trasy mezikódem (pseudoinstrukcemi)</h2>

<p>Trasovací pøekladaè pøi nalezení stopy vhodné pro JITování provede nejdøíve
pøeklad této stopy do sekvence pseudoinstrukcí. Pøitom se vyu¾ívá takzvaná
<i>SSA</i> forma, její¾ základní vlastnosti jsou popsány napøíklad na stránce
<a
href="http://en.wikipedia.org/wiki/Static_single_assignment_form">http://en.wikipedia.org/wiki/Static_single_assignment_form</a>.
Vìt¹ina pseudoinstrukcí pou¾ívaných <i>LuaJITem</i> obsahuje dva operandy, a¾
na nìkolik výjimek (jednou z&nbsp;výjimek je pseudoinstrukce rezervovaná pro
volání funkce). Navíc je u ka¾dé pseudoinstrukce specifikován i typ výsledku,
co¾ je mo¾ná ponìkud pøekvapivé, proto¾e jak programovací jazyk Lua, tak i
bajtkód <i>LuaJITu</i> vyu¾ívá dynamické typování. Nicménì na úrovni
pseudoinstrukcí se ji¾ nacházíme na tak nízké úrovni, ¾e je nutné zaèít
pracovat s&nbsp;konkrétními datovými typy, proto¾e i samotné instrukce
mikroprocesoru pracují s&nbsp;konkrétními datovými typy (bajt, short, int,
float atd. atd.). Pro nás je v&nbsp;tuto chvíli dùle¾itý zejména fakt, ¾e se na
sekvenci pseudoinstrukcí mù¾eme snadno podívat, a to s&nbsp;vyu¾itím volby
<strong>-jdump</strong> (s&nbsp;pøípadnými parametry).</p>



<p><a name="k031"></a></p>
<h3 id="k031">3.1 Typy operandù</h3>

<p>V&nbsp;pøedchozím odstavci jsme se dozvìdìli, ¾e u ka¾dé pseudoinstrukce je
kromì vlastního operaèního kódu a popø.&nbsp;i operandù navíc specifikován i
typ výsledku. To napøíklad znamená, ¾e dále zmínìná pseudoinstrukce nazvaná
<strong>SLOAD</strong> mù¾e naèítat (a vracet) celá èísla (<i>int</i>), hodnoty
s&nbsp;plovoucí øádovou èárkou (<i>flt</i>/<i>num</i>) atd. JIT pøekladaè
následnì na základì páru datový_typ+pseudoinstrukce zaène generovat nativní
kód, samozøejmì s&nbsp;ohledem na vlastnosti instrukèní sady cílového
mikroprocesoru. V&nbsp;následující tabulce jsou vypsány typy výsledkù, které se
mohou objevit u v¹ech pseudoinstrukcí:</p>

<table>
<tr><th> #</th><th>Typ</th><th>Význam</th></tr>
<tr><td> 1</td><td>nil</td><td>odpovídá hodnotì <strong>nil</strong> v&nbsp;bajtkódu i v&nbsp;jazyku Lua</td></tr>
<tr><td> 2</td><td>fal</td><td>odpovídá hodnotì <strong>false</strong> v&nbsp;bajtkódu i v&nbsp;jazyku Lua</td></tr>
<tr><td> 3</td><td>tru</td><td>odpovídá hodnotì <strong>true</strong> v&nbsp;bajtkódu i v&nbsp;jazyku Lua</td></tr>
<tr><td> 4</td><td>lud</td><td>light user data</td></tr>
<tr><td> 5</td><td>str</td><td>øetìzec</td></tr>
<tr><td> 6</td><td>p32</td><td>32bitový ukazatel</td></tr>
<tr><td> 7</td><td>thr</td><td>objekt reprezentující vlákno</td></tr>
<tr><td> 8</td><td>pro</td><td>prototyp funkce</td></tr>
<tr><td> 9</td><td>fun</td><td>uzávìr</td></tr>
<tr><td>10</td><td>p64</td><td>64bitový ukazatel</td></tr>
<tr><td>11</td><td>cdt</td><td>cdata (z&nbsp;nich se napøíklad mù¾e vytvoøit øetìzec atd.)</td></tr>
<tr><td>12</td><td>tab</td><td>tabulka</td></tr>
<tr><td>13</td><td>udt</td><td>user data</td></tr>
<tr><td>14</td><td>flt</td><td>32bitová hodnota typu float (èíslo s&nbsp;plovoucí øádovou èárkou)</td></tr>
<tr><td>15</td><td>num</td><td>64bitová hodnota typu double (èíslo s&nbsp;plovoucí øádovou èárkou)</td></tr>
<tr><td>16</td><td>i8 </td><td>8bitová hodnota typu signed integer (celé èíslo se znaménkem)</td></tr>
<tr><td>17</td><td>u8 </td><td>8bitová hodnota typu unsigned integer (kladné celé èíslo)</td></tr>
<tr><td>18</td><td>i16</td><td>16bitová hodnota typu signed integer (celé èíslo se znaménkem)</td></tr>
<tr><td>19</td><td>u16</td><td>16bitová hodnota typu unsigned integer (kladné celé èíslo)</td></tr>
<tr><td>20</td><td>int</td><td>32bitová hodnota typu signed integer (celé èíslo se znaménkem)</td></tr>
<tr><td>21</td><td>u32</td><td>32bitová hodnota typu unsigned integer (kladné celé èíslo)</td></tr>
<tr><td>22</td><td>i64</td><td>64bitová hodnota typu signed integer (celé èíslo se znaménkem)</td></tr>
<tr><td>23</td><td>u64</td><td>64bitová hodnota typu unsigned integer (kladné celé èíslo)</td></tr>
</table>

<p>Zajímavé je, ¾e se v&nbsp;dal¹ích ètyøech pøíkladech setkáme jen a pouze
s&nbsp;typem <i>int</i>, tj.&nbsp;s&nbsp;pseudoinstrukcemi pracujícími
s&nbsp;32bitovými hodnotami se znaménkem a navíc je¹tì s&nbsp;typem <i>num</i>,
který odpovídá bì¾ným numerickým hodnotám pou¾ívaným v&nbsp;jazyku <i>Lua</i>.
Pouze u pátého pøíkladu se pracuje s&nbsp;typem <i>fun</i> (reference na
funkci).</p>



<p><a name="k032"></a></p>
<h3 id="k032">3.2 Vybrané pseudoinstrukce</h3>

<p>V&nbsp;následujících demonstraèních pøíkladech, resp.&nbsp;pøesnìji øeèeno
v&nbsp;sekvenci vygenerovaných pseudoinstrukcí, se setkáme s&nbsp;výpisem
nalezených stop reprezentovaných jak bajtkódem, tak i posloupností
pseudoinstrukcí. Kupodivu si v&nbsp;prvních ètyøech demonstraèních pøíkladech
vystaèíme jen se ¹esti pseudoinstrukcemi, které jsou vypsány v&nbsp;tabulce
umístìné pod tímto odstavcem:</p>

<table>
<tr><th>#</th><th>Pseudoinstrukce</th><th>Operandy</th><th>Význam</th></tr>
<tr><td>1</td><td><strong>SLOAD</strong></td><td>#slot,#flags</td><td>stack slot load, #slot obsahuje 1 pro první lokální promìnnou atd. (v bytecode je to 0)</td></tr>
<tr><td>2</td><td><strong>ADD</strong>  </td><td>left, right</td><td>aritmetická operace: left+right (zále¾í na typu operandù)</td></tr>
<tr><td>3</td><td><strong>ADDOV</strong></td><td>left, right</td><td>souèet s kontrolou pøeteèení</td></tr>
<tr><td>4</td><td><strong>LE</strong>   </td><td>left, right</td><td>pøedpoklad left&le;right, nesplnìní podmínky vede k ukonèení stopy</td></tr>
<tr><td>5</td><td><strong>LT</strong>   </td><td>left, right</td><td>pøedpoklad left&lt;right, nesplnìní podmínky vede k ukonèení stopy</td></tr>
<tr><td>6</td><td><strong>PHI</strong>  </td><td>left, right</td><td>typicky umístìno na konci smyèky, left obsahuje referenci na poèáteèní hodnotu, right na hodnotu po provedení smyèky</td></tr>
</table>

<p>Instrukce nazvaná <strong>SLOAD</strong> bude v&nbsp;demonstraèních
pøíkladech pou¾ívána pravidelnì. Slou¾í pro naètení hodnoty ze slotu, výsledkem
instrukce je pak naètená hodnota (daného typu). Zajímavé je adresování slotù,
proto¾e index první lokální promìnné má hodnotu 1 a ne 0. Pøi porovnání
bajtkódu s&nbsp;pseudoinstrukcemi to mù¾e být ponìkud matoucí. Pseudoinstrukce
<strong>ADD</strong> a <strong>ADDOV</strong> provádí souèet obou operandù,
druhá z&nbsp;tìchto pseudoinstrukcí navíc provádí kontrolu, zda nedo¹lo
k&nbsp;pøeteèení výsledku. Tato pseudoinstrukce se èasto pou¾ívá právì pøi
implementaci programových smyèek.</p>

<p>Zvlá¹tní postavení mají pseudoinstrukce <strong>LE</strong>,
<strong>LT</strong> a je¹tì dal¹ích deset podobných pseudoinstrukcí, o nich¾ se
zmíníme pøí¹tì. Tyto pseudoinstrukce se podobají podmínìným skokùm, ov¹em
s&nbsp;tím rozdílem, ¾e neobsahují explicitnì zadanou adresu cíle. Pokud je
podmínka reprezentovaná tìmito pseudoinstrukcemi splnìna, neprovede se ¾ádná
èinnost, pokud v¹ak podmínka splnìna není, dojde k&nbsp;ukonèení bìhu stopy a
navíc k&nbsp;obnovì pøedchozího stavu procesu. Díky tomuto mechanismu je mo¾né
v&nbsp;runtime reagovat na stav, kdy dojde k&nbsp;poru¹ení nìjaké podmínky,
která platila pøi nalezení stopy &ndash; typickým pøíkladem je programová
smyèka s&nbsp;vìtvením uvnitø této smyèky.</p>

<p>V&nbsp;pátém pøíkladu, kde je zpracováno volání funkce, se objevují i dal¹í
pseudoinstrukce:</p>

<table>
<tr><th>#</th><th>Pseudoinstrukce</th><th>Operandy</th><th>Význam</th></tr>
<tr><td>1</td><td><strong>UREFO</strong></td><td>func, #uv</td><td>získání reference na aktuálnì provádìnou funkci</td></tr>
<tr><td>2</td><td><strong>ULOAD</strong></td><td>uref</td><td>naètení vázané promìnné, pou¾ito pro pøeklad instrukce UGET (tato instrukce je pou¾ita v&nbsp;bajtkódu)</td></tr>
<tr><td>3</td><td><strong>USTORE</strong></td><td>uref, val</td><td>ulo¾ení nové hodnoty do vázané promìnné, pou¾ito pro pøeklad instrukcí USETV, USETS, USETN a USETP</td></tr>
</table>



<p><a name="k033"></a></p>
<h3 id="k033">3.3 Formát výpisu sekvence pseudoinstrukcí</h3>

<p>Sekvenci pseudoinstrukcí lze snadno vypsat s&nbsp;vyu¾itím pøepínaèe
<strong>-jdump</strong>. Pøi pou¾ití tohoto pøepínaèe lze specifikovat pomìrnì
velké mno¾ství voleb:</p>

<table>
<tr><th>#</th><th>Výchozí?</th><th>Volba</th><th>Význam</th></tr>
<tr><td>1</td><td>ano</td><td>t</td><td>výpis informace o ka¾dé nalezené èi ukonèené stopì</td></tr>
<tr><td>2</td><td>ano</td><td>b</td><td>výpis bajtkódu stopy</td></tr>
<tr><td>3</td><td>ano</td><td>i</td><td>výpis sekvence pseudoinstrukcí stopy</td></tr>
<tr><td>4</td><td>ne </td><td>s</td><td>vytvoøí se snapshot</td></tr>
<tr><td>5</td><td>ano</td><td>m</td><td>výpis sekvence nativních instrukcí stopy (závislé na architektuøe)</td></tr>
<tr><td>6</td><td>ano</td><td>T</td><td>výstup v plaintextu</td></tr>
<tr><td>7</td><td>ne </td><td>A</td><td>výstup v plaintextu+øídicí symboly pro terminál pro zmìnu barvy</td></tr>
<tr><td>8</td><td>ne </td><td>H</td><td>výstup v HTML+CSS</td></tr>
</table>

<p>Podívejme se nyní na to, jak vypadá výchozí výstupní formát do plaintextu.
Jedná se o stopu jednoduché programové smyèky, v&nbsp;ní¾ se neprovádí
vìtvení:</p>

<pre>
---- TRACE 1 IR
0001    int SLOAD  #3    I
0002 &gt;  int SLOAD  #2    T
0003 &gt;+ int ADDOV  0002  +1  
0004  + int ADD    0001  +1  
0005 &gt;  int LE     0004  +60 
0006 ------ LOOP ------------
0007 &gt;+ int ADDOV  0003  +1  
0008  + int ADD    0004  +1  
0009 &gt;  int LE     0008  +60 
0010    int PHI    0004  0008
0011    int PHI    0003  0007
---- TRACE 1 stop -&gt; loop
</pre>

<p>Význam údajù umístìných v&nbsp;jednotlivých sloupcích:</p>

<table>
<tr><th>Sloupec</th><th>Význam</th></tr>
<tr><td>1</td><td>èíslo (index) pseudoinstrukce</td></tr>
<tr><td>2</td><td>pøíznaky: &gt; zde mù¾e dojít k&nbsp;ukonèení stopy, + existuje reference pseudoinstrukcí PHI</td></tr>
<tr><td>3</td><td>typ výsledku pseudoinstrukce</td></tr>
<tr><td>4</td><td>operaèní kód pseudoinstrukce</td></tr>
<tr><td>5</td><td>operandy pseudoinstrukce (reference nebo konstanty)</td></tr>
</table>

<p>Typ operandù lze jednodu¹e rozpoznat podle jejich prvního znaku:</p>

<table>
<tr><th>První znak operandu</th><th>Význam</th><th>Pøíklad</th></tr>
<tr><td>#</td><td>èíslo slotu</td><td>#3</td></tr>
<tr><td>+</td><td>kladná numerická hodnota</td><td>+1</td></tr>
<tr><td>-</td><td>záporná numerická hodnota</td><td>-60 (málokdy ji skuteènì uvidíme)</td></tr>
<tr><td>(nic)</td><td>adresa</td><td>0007</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Demonstraèní pøíklady &ndash; jednoduché programové smyèku pøelo¾ené do sekvence pseudoinstrukcí</h2>

<p>Zpùsob èinnosti just-in-time pøekladaèe implementovaného
v&nbsp;<i>LuaJITu</i> si uká¾eme na pìtici demonstraèních pøíkladù,
s&nbsp;nimi¾ jsme se ji¾ setkali v&nbsp;minulé a pøedminulé èásti tohoto
seriálu. U ka¾dého pøíkladu bude (znovu) uveden jeho zdrojový text, sekvence
instrukcí bajtkódu detekovaná pro ka¾dou stopu a samozøejmì té¾ sekvence
pseudoinstrukcí vygenerovaných z&nbsp;bajtkódu.</p>



<p><a name="k041"></a></p>
<h3 id="k041">4.1 Just-in-time pøeklad poèítané programové smyèky typu <strong>for</strong></h3>

<p>Podívejme se na dne¹ní první demonstraèní pøíklad nazvaný
<strong>test41.lua</strong> (s&nbsp;tímto pøíkladem jsme se ji¾ setkali
pøedminule). Tento demonstraèní pøíklad je velmi jednoduchý, proto¾e se
v&nbsp;nìm nachází pouze jediná poèítaná programová smyèka typu
<strong>for</strong>, která je provádìna celkem 60&times;. Toto èíslo ji¾
zajistí detekci <i>hot loop</i> a tedy i JIT pøeklad:</p>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 41.</i>
<i>--</i>
<i>-- Test JITu.</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<strong>local</strong> i
<strong>local</strong> sum = 0
&nbsp;
<strong>for</strong> i = 1,60 <strong>do</strong>
    sum = sum + 1
<strong>end</strong>
&nbsp;
print(sum)
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Finito.</i>
<i>--</i>
</pre>

<p>Pøi bìhu tohoto programu se nalezne pouze jediná stopa (trace) tvoøená
samozøejmì tìlem programové smyèky. <i>LuaJIT</i> vypí¹e informace o této stopì
následujícím zpùsobem (vèetnì instrukcí bajtkódu, které stopu tvoøí):</p>

<pre>
---- TRACE 1 start test41.lua:12
0007  ADDVN    1   1   0  ; 1
0008  FORL     2 =&gt; 0007
</pre>

<p>Po transformaci do pseudoinstrukcí vypadá programová smyèka a její
inicializaèní èást následovnì:</p>

<pre>
---- TRACE 1 IR
0001    int SLOAD  #3    I
0002 &gt;  int SLOAD  #2    T
0003 &gt;+ int ADDOV  0002  +1  
0004  + int ADD    0001  +1  
0005 &gt;  int LE     0004  +60 
0006 ------ LOOP ------------
0007 &gt;+ int ADDOV  0003  +1  
0008  + int ADD    0004  +1  
0009 &gt;  int LE     0008  +60 
0010    int PHI    0004  0008
0011    int PHI    0003  0007
---- TRACE 1 stop -&gt; loop
</pre>

<p>Za pov¹imnutí stojí nìkolik zajímavostí. První z&nbsp;nich je, ¾e øídicí
promìnná (poèitadlo) smyèky je typu <i>int</i> a nikoli <i>num</i>, co¾
znamená, ¾e <i>LuaJIT</i> korektnì odhadl strukturu aplikace a datové typy
pou¾ité v&nbsp;runtime. Dále zde mù¾eme vidìt asserce (pøedpoklady) tvoøené
pseudoinstrukcemi <strong>LE</strong> pou¾itými jak pøed vlastním tìlem smyèky,
tak i na zaèátku jejího tìla. Instrukce <strong>ADD</strong> slou¾í ke zvý¹ení
poèitadla smyèky, zatímco instrukce <strong>ADDOV</strong> ke zvý¹ení hodnoty
promìnné <i>sum</i>.</p>

<p>Pokud by se hodnota promìnné <i>sum</i> sni¾ovala o jednièku, vypadal by
bajtkód odli¹nì:</p>

<pre>
---- TRACE 1 start test41.lua:12
0007  SUBVN    1   1   0  ; 1
0008  FORL     2 =&gt; 0007
</pre>

<p>A samozøejmì by se zmìnila i sekvence pseudoinstrukcí (vèetnì zmìny typu dat):</p>

<pre>
---- TRACE 1 IR
0001    int SLOAD  #3    CI
0002 &gt;  int SLOAD  #2    T
0003  + num SUB    0002  +1  
0004  + int ADD    0001  +1  
0005 &gt;  int LE     0004  +60 
0006 ------ LOOP ------------
0007  + num SUB    0003  +1  
0008  + int ADD    0004  +1  
0009 &gt;  int LE     0008  +60 
0010    int PHI    0004  0008
0011    int PHI    0003  0007
---- TRACE 1 stop -&gt; loop
</pre>



<p><a name="k042"></a></p>
<h3 id="k042">4.2 Just-in-time pøeklad programové smyèky typu <strong>while</strong></h3>

<p>V&nbsp;dne¹ním druhém demonstraèním pøíkladu je namísto poèítané programové
smyèky typu <strong>for</strong> pou¾ita univerzální smyèka
<strong>while</strong> s&nbsp;podmínkou vyhodnocovanou na zaèátku.
V&nbsp;bajtkódu <i>LuaJITu</i> se namísto speciální instrukce
<strong>FORI</strong> v&nbsp;tomto pøípadì pou¾ívá instrukce
<strong>LOOP</strong> a podmínìný skok realizovaný instrukcí
<strong>ISGE</strong>:</p>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 43.</i>
<i>--</i>
<i>-- Test JITu.</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<strong>local</strong> i = 0
<strong>local</strong> sum = 0
&nbsp;
<strong>while</strong> i &lt; 100 <strong>do</strong>
    sum = sum + 1
    i = i + 1
<strong>end</strong>
&nbsp;
print(sum)
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Finito.</i>
<i>--</i>
</pre>

<p>Programová smyèka je opìt &ndash; podle oèekávání &ndash; detekována jako
stopa vhodná pro JITování, ov¹em na rozdíl od pøedchozího demonstraèního
pøíkladu je struktura bajtkódu zcela odli¹ná, proto¾e se namísto speciální
instrukce <strong>FORL</strong> pou¾ívá instrukce <strong>LOOP</strong>
doplnìná o <strong>ISGE</strong>:</p>

<pre>
---- TRACE 1 start test43.lua:12
0007  ADDVN    1   1   0  ; 1
0008  ADDVN    0   0   0  ; 1
0009  JMP      2 =&gt; 0003
0003  KSHORT   2 100
0004  ISGE     0   2
0005  JMP      2 =&gt; 0010
0006  LOOP     2 =&gt; 0010
</pre>

<p>Odli¹ný bajtkód se samozøejmì projeví i na sekvenci pseudoinstrukcí:</p>

<pre>
---- TRACE 1 IR
0001 &gt;  int SLOAD  #2    T
0002 &gt;+ int ADDOV  0001  +1  
0003 &gt;  int SLOAD  #1    T
0004 &gt;+ int ADDOV  0003  +1  
0005 &gt;  int LT     0004  +100
0006 ------ LOOP ------------
0007 &gt;+ int ADDOV  0002  +1  
0008 &gt;+ int ADDOV  0004  +1  
0009 &gt;  int LT     0008  +100
0010    int PHI    0002  0007
0011    int PHI    0004  0008
---- TRACE 1 stop -&gt; loop
</pre>

<p>Opìt si pov¹imnìte pou¾ití datového typu <i>int</i> a takté¾ vyu¾ití
pseudoinstrukcí <strong>ADDOV</strong>. Pøí¹tì uvidíme, ¾e se tyto
pseudoinstrukce pøekládají pomìrnì slo¾itým zpùsobem, a to kvùli tomu, aby se
detekovalo pøeteèení výsledku a pøechod na pou¾ití jiného datového typu.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Demonstraèní pøíklady &ndash; pøeklad smyèek s&nbsp;podmínkami do sekvence pseudoinstrukcí</h2>

<p>Ji¾ minule jsme se zabývali problematikou programových smyèek obsahujících
ve svém tìle podmínku èi vìt¹í mno¾ství podmínek (vìtvení). Víme ji¾, ¾e se
vìtvení &ndash; pokud se samozøejmì provádí dostateènì èasto &ndash; pøelo¾í do
samostatné stopy, tak¾e si pojïme toto tvrzení ovìøit na dvojici demonstraèních
pøíkladù.</p>



<p><a name="k051"></a></p>
<h3 id="k051">5.1 Just-in-time pøeklad programové smyèky s&nbsp;jedním rozvìtvením</h3>

<p>Donutit <i>LuaJIT</i> k&nbsp;tomu, aby provedl i pøeklad podmínky umístìné
uvnitø poèítané programové smyèky, je ve skuteènosti velmi snadné, jak jsme si
ostatnì vysvìtlili minule &ndash; postaèuje toti¾ zvý¹it poèet iterací smyèky a
souèasnì i poèet vstupù do podmínìného bloku. Dne¹ní tøetí demonstraèní pøíklad
pojmenovaný <strong>test49.lua</strong> pou¾ívá pro smyèku tisíc iterací a
uvnitø smyèky se po 500 iteracích provádí vnitøní vìtev:</p>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 49.</i>
<i>--</i>
<i>-- Test JITu - programová smyèka s rozvìtvením, zvý¹ení poètu iteraci.</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>-- deklarace a inicializace lokálních promìnných</i>
<strong>local</strong> i
<strong>local</strong> x = 0
<strong>local</strong> y = 0
&nbsp;
&nbsp;
&nbsp;
<i>-- programová smyèka s rozvìtvením</i>
<strong>for</strong> i = 1,1000 <strong>do</strong>
    x = x + 1
    <strong>if</strong> i &gt; 500 <strong>then</strong>
        y = y + 1
    <strong>end</strong>
<strong>end</strong>
&nbsp;
print(x, y)
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Finito.</i>
<i>--</i>
</pre>

<p>Nyní si musíme ovìøit, ¾e se vìtvení skuteènì pøelo¾ilo do samostatné stopy.
Nejprve trasovací JIT odhalil celou programovou smyèku, a to vèetnì podmínìného
skoku:</p>

<pre>
---- TRACE 1 start test49.lua:17
0008  ADDVN    1   1   0  ; 1
0009  KSHORT   7 500
0010  ISGE     7   6
0011  JMP      7 =&gt; 0013
0013  FORL     3 =&gt; 0008
</pre>

<p>A následnì na¹el a JIToval i její vìtev (pouze tuto vìtev):</p>

<pre>
---- TRACE 2 start 1/1 test49.lua:20
0012  ADDVN    2   2   0  ; 1
0013  JFORL    3   1
</pre>

<p>Jak vypadá transformace bajtkódu do pseudokódu mù¾eme vidìt ní¾e:</p>

<pre>
---- TRACE 1 IR
0001    int SLOAD  #4    I
0002 &gt;  int SLOAD  #2    T
0003 &gt;+ int ADDOV  0002  +1  
0004 &gt;  int LE     0001  +500
0005  + int ADD    0001  +1  
0006 &gt;  int LE     0005  +1000
0007 ------ LOOP ------------
0008 &gt;+ int ADDOV  0003  +1  
0009 &gt;  int LE     0005  +500
0010  + int ADD    0005  +1  
0011 &gt;  int LE     0010  +1000
0012    int PHI    0005  0010
0013    int PHI    0003  0008
---- TRACE 1 stop -&gt; loop
</pre>

<p>Stopa nalezená pro vìtvení ve smyèce je oproti kódu celé smyèky dosti
krátká, a to z&nbsp;toho dùvodu, ¾e tato stopa má pøímou návaznost na stopu
vlastní smyèky:</p>

<pre>
---- TRACE 2 IR
0001    int SLOAD  #2    PI
0002    int SLOAD  #4    PI
0003 &gt;  int SLOAD  #3    T
0004 &gt;  int ADDOV  0003  +1  
0005    int ADD    0002  +1  
0006 &gt;  int LE     0005  +1000
---- TRACE 2 stop -&gt; 1
</pre>

<p>Poprvé zde vidíme, ¾e pseudoinstrukce jsou v&nbsp;ka¾dé stopì indexovány od
jednièky.</p>



<p><a name="k052"></a></p>
<h3 id="k052">5.2 Just-in-time pøeklad programové smyèky se slo¾itìj¹ím rozvìtvením</h3>

<p>V&nbsp;demonstraèním pøíkladu se jménem <strong>test50.lua</strong> se ve
vnìj¹í programové smyèce nachází hned tøi vìtve. Vzhledem k&nbsp;tomu, ¾e je
poèet iterací nastaven na hodnotu 1000 a podmínky ve vìtvích umo¾ní vstup do
podmínìných blokù v&nbsp;1000-100=900, 1000-200=800 a 1000-300=700 iteracích,
budou detekovány a následnì pøelo¾eny celkem ètyøi stopy &ndash; vlastní
programová smyèka a tøi stopy obsahující jednotlivé vìtve:</p>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 50.</i>
<i>--</i>
<i>-- Test JITu - programová smyèka se slo¾itìj¹ím rozvìtvením</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>-- deklarace a inicializace lokálních promìnných</i>
<strong>local</strong> i
<strong>local</strong> x = 0
<strong>local</strong> y = 0
<strong>local</strong> z = 0
&nbsp;
&nbsp;
&nbsp;
<i>-- programová smyèka s rozvìtvením</i>
<strong>for</strong> i = 1,1000 <strong>do</strong>
    <strong>if</strong> i &gt; 100 <strong>then</strong>
        x = x + 1
    <strong>end</strong>
    <strong>if</strong> i &gt; 200 <strong>then</strong>
        y = y + 1
    <strong>end</strong>
    <strong>if</strong> i &gt; 300 <strong>then</strong>
        z = z + 1
    <strong>end</strong>
<strong>end</strong>
&nbsp;
print(x, y, z)
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Finito.</i>
<i>--</i>
</pre>

<p>Nyní bude velmi zajímavé sledovat pøedev¹ím strukturu bajtkódu. Podle
oèekávání dostaneme celkem ètyøi stopy, pøièem¾ tøi stopy budou navázány na
nadøazenou stopu programové smyèky.</p>

<p>Stopa celé smyèky, vèetnì pøeskokù vìtvení (jednotlivé vìtve se toti¾
neprovádí od zaèátku!):</p>

<pre>
---- TRACE 1 start test50.lua:18
0009  KSHORT   8 100
0010  ISGE     8   7
0011  JMP      8 =&gt; 0013
0013  KSHORT   8 200
0014  ISGE     8   7
0015  JMP      8 =&gt; 0017
0017  KSHORT   8 300
0018  ISGE     8   7
0019  JMP      8 =&gt; 0021
0021  FORL     4 =&gt; 0009
</pre>

<p>Stopa prvního vìtvení, vèetnì pøeskoku dal¹ích dvou vìtvení (dùvod je stejný
jako dùvod uvedený vý¹e):</p>

<pre>
---- TRACE 2 start 1/1 test50.lua:20
0012  ADDVN    1   1   0  ; 1
0013  KSHORT   8 200
0014  ISGE     8   7
0015  JMP      8 =&gt; 0017
0017  KSHORT   8 300
0018  ISGE     8   7
0019  JMP      8 =&gt; 0021
0021  JFORL    4   1
</pre>

<p>Stopa druhého vìtvení, vèetnì pøeskoku tøetí podmínky:</p>

<pre>
---- TRACE 3 start 2/1 test50.lua:23
0016  ADDVN    2   2   0  ; 1
0017  KSHORT   8 300
0018  ISGE     8   7
0019  JMP      8 =&gt; 0021
0021  JFORL    4   1
</pre>

<p>Koneènì zbývá tøetí podmínka, která je splnìna a tudí¾ i detekována
naposledy:</p>

<pre>
---- TRACE 4 start 3/1 test50.lua:26
0020  ADDVN    3   3   0  ; 1
0021  JFORL    4   1
</pre>

<p>Sekvence pseudoinstrukcí vygenerovaných z&nbsp;vý¹e vypsaných bajtkódù jsou
ji¾ pomìrnì slo¾ité (a je¹tì slo¾itìj¹í bude transformace do nativního
strojového kódu :-):</p>

<pre>
---- TRACE 1 IR
0001    int SLOAD  #5    I
0002 &gt;  int LE     0001  +100
0003 &gt;  int LE     0001  +200
0004 &gt;  int LE     0001  +300
0005  + int ADD    0001  +1  
0006 &gt;  int LE     0005  +1000
0007 ------ LOOP ------------
0008 &gt;  int LE     0005  +100
0009 &gt;  int LE     0005  +200
0010 &gt;  int LE     0005  +300
0011  + int ADD    0005  +1  
0012 &gt;  int LE     0011  +1000
0013    int PHI    0005  0011
---- TRACE 1 stop -&gt; loop
&nbsp;
---- TRACE 2 IR
0001    int SLOAD  #5    PI
0002 &gt;  int SLOAD  #2    T
0003 &gt;  int ADDOV  0002  +1  
0004 &gt;  int LE     0001  +200
0005 &gt;  int LE     0001  +300
0006    int ADD    0001  +1  
0007 &gt;  int LE     0006  +1000
---- TRACE 2 stop -&gt; 1
&nbsp;
---- TRACE 3 IR
0001    int SLOAD  #2    PI
0002    int SLOAD  #5    PI
0003 &gt;  int SLOAD  #3    T
0004 &gt;  int ADDOV  0003  +1  
0005 &gt;  int LE     0002  +300
0006    int ADD    0002  +1  
0007 &gt;  int LE     0006  +1000
---- TRACE 3 stop -&gt; 1
&nbsp;
---- TRACE 4 IR
0001    int SLOAD  #2    PI
0002    int SLOAD  #3    PI
0003    int SLOAD  #5    PI
0004 &gt;  int SLOAD  #4    T
0005 &gt;  int ADDOV  0004  +1  
0006    int ADD    0003  +1  
0007 &gt;  int LE     0006  +1000
---- TRACE 4 stop -&gt; 1
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Demonstraèní pøíklad &ndash; pøeklad volání funkce do sekvence pseudoinstrukcí</h2>

<p>Dne¹ní pátý a souèasnì i poslední demonstraèní pøíklad je zalo¾en na
deklaraci funkce <strong>adder</strong>. Tato funkce je volána v&nbsp;trojici
programových smyèek. V&nbsp;první smyèce se provede prvních padesát volání,
v&nbsp;dal¹í smyèce dal¹ích padesát volání a koneènì ve smyèce tøetí se funkce
zavolá po 101 a¾ 150. Proè je pøíklad organizován takovým zpùsobem? Jde nám o
to zabránit <i>LuaJITu</i> v&nbsp;detekci smyèek s&nbsp;velkým poètem iterací,
pøièem¾ hodnota 50 le¾í pod hranièní hodnotou <strong>hotcall=56</strong>,
tak¾e smyèky samotné JITovány nebudou, ale funkce <strong>adder</strong>
nakonec ano (samozøejmì a¾ v&nbsp;poslední smyèce):</p>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 53.</i>
<i>--</i>
<i>-- Test JITu - volání funkce</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>-- deklarace a inicializace lokálních promìnných</i>
<strong>local</strong> i
<strong>local</strong> x = 0
<strong>local</strong> y = 0
&nbsp;
&nbsp;
&nbsp;
<i>-- funkce, která se bude JITovat</i>
<strong>function</strong> adder()
    x = x + 1
    y = y + 1
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>-- programová smyèka, která se neJITuje</i>
<strong>for</strong> i = 1,50 <strong>do</strong>
    adder()
<strong>end</strong>
print("1")
&nbsp;
<i>-- programová smyèka, která se neJITuje</i>
<strong>for</strong> i = 1,50 <strong>do</strong>
    adder()
<strong>end</strong>
print("2")
&nbsp;
<i>-- programová smyèka, která se neJITuje</i>
<strong>for</strong> i = 1,50 <strong>do</strong>
    adder()
<strong>end</strong>
print("3")
&nbsp;
print(x,y)
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Finito.</i>
<i>--</i>
</pre>

<p>Instrukce bajtkódu v&nbsp;detekované stopì nám prozradí, ¾e je stopa
skuteènì nalezena ve funkci <strong>adder</strong>, proto¾e zde mù¾eme vidìt
pøístup k&nbsp;vázaným promìnným x a y. Instrukcí <strong>UGET</strong> se
pøeète aktuální hodnota vázané promìnné a instrukcí <strong>USETV</strong> se
do této promìnné ulo¾í nová hodnota z&nbsp;registru (zde konkrétnì
z&nbsp;registru èíslo 1):</p>

<pre>
---- TRACE 1 start test53.lua:17
0001  UGET     0   0      ; x
0002  ADDVN    0   0   0  ; 1
0003  USETV    0   0      ; x
0004  UGET     0   1      ; y
0005  ADDVN    0   0   0  ; 1
0006  USETV    1   0      ; y
0007  RET0     0   1
</pre>

<p>Po transformaci do sekvence pseudoinstrukcí mù¾eme vidìt náhradu
<strong>UGET</strong> za <strong>ULOAD</strong> a <strong>USETV</strong> za
<strong>USTORE</strong>. Navíc se zde &ndash; zcela poprvé &ndash; objevuje i
pseudoinstrukce <strong>UREFO</strong> vracející referenci na funkci:</p>

<pre>
---- TRACE 1 IR
0001    fun SLOAD  #0    R
0002 &gt;  p32 UREFO  0001  #0  
0003 &gt;  int ULOAD  0002
0004 &gt;  int ADDOV  0003  +1  
0005    int USTORE 0002  0004
0006 &gt;  p32 UREFO  0001  #1  
0007 &gt;  int ULOAD  0006
0008 &gt;  int ADDOV  0007  +1  
0009    int USTORE 0006  0008
---- TRACE 1 stop -&gt; return
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Pøeklad ze sekvence pseudoinstrukcí do nativního kódu</h2>

<p>Posledním krokem JIT pøekladu je transformace pseudoinstrukcí do nativního
kódu. Uka¾me si transformaci stopy z&nbsp;dne¹ního druhého demonstraèního
pøíkladu:</p>

<pre>
---- TRACE 1 IR
0001 &gt;  int SLOAD  #2    T
0002 &gt;+ int ADDOV  0001  +1  
0003 &gt;  int SLOAD  #1    T
0004 &gt;+ int ADDOV  0003  +1  
0005 &gt;  int LT     0004  +100
0006 ------ LOOP ------------
0007 &gt;+ int ADDOV  0002  +1  
0008 &gt;+ int ADDOV  0004  +1  
0009 &gt;  int LT     0008  +100
0010    int PHI    0002  0007
0011    int PHI    0004  0008
---- TRACE 1 stop -&gt; loop
</pre>

<p>Pøeklad do nativního strojového kódu pro 32bitové mikroprocesory ARM vypadá
následovnì:</p>

<pre>
---- TRACE 1 start test43.lua:12
---- TRACE 1 mcode 84
00397fac  ldrd  r4, [r9, #8]
00397fb0  cmn   r5, #14
00397fb4  blne  0x00390018      -&gt;0
00397fb8  adds  r4, r4, #1
00397fbc  blvs  0x00390018      -&gt;0
00397fc0  ldrd  r6, [r9]
00397fc4  cmn   r7, #14
00397fc8  blne  0x00390018      -&gt;0
00397fcc  adds  r6, r6, #1
00397fd0  blvs  0x00390018      -&gt;0
00397fd4  cmp   r6, #100
00397fd8  blge  0x0039001c      -&gt;1
-&gt;LOOP:
00397fdc  mov   r11, r6
00397fe0  mov   r10, r4
00397fe4  adds  r4, r10, #1
00397fe8  blvs  0x00390020      -&gt;2
00397fec  adds  r6, r11, #1
00397ff0  blvs  0x00390020      -&gt;2
00397ff4  cmp   r6, #100
00397ff8  blt   0x00397fdc      -&gt;LOOP
00397ffc  bl    0x00390024      -&gt;3
---- TRACE 1 stop -&gt; loop
</pre>

<p>Pov¹imnìte si pøedev¹ím mno¾ství podmínìných skokù (<strong>blne</strong>,
<strong>blvs</strong>), kterými jsou realizovány asserce zmínìné
v&nbsp;pøedchozím textu.</p>

<p>Pro platformu x86_64 dostaneme &ndash; podle oèekávání &ndash; sice
identický, ale v&nbsp;detailech pøece jen odli¹ný &bdquo;stroják&ldquo;:</p>

<pre>
---- TRACE 1 mcode 104
0bceff8e  mov dword [0x409604a0], 0x1
0bceff99  movsd xmm1, [0x404b0d38]
0bceffa2  movsd xmm0, [0x404b0d40]
0bceffab  cmp dword [rdx+0xc], 0xfffeffff
0bceffb2  jnb 0x0bce0010        -&gt;0
0bceffb8  movsd xmm6, [rdx+0x8]
0bceffbd  addsd xmm6, xmm1
0bceffc1  cmp dword [rdx+0x4], 0xfffeffff
0bceffc8  jnb 0x0bce0010        -&gt;0
0bceffce  movsd xmm7, [rdx]
0bceffd2  addsd xmm7, xmm1
0bceffd6  ucomisd xmm0, xmm7
0bceffda  jbe 0x0bce0014        -&gt;1
-&gt;LOOP:
0bceffe0  addsd xmm6, xmm1
0bceffe4  movaps xmm5, xmm7
0bceffe7  addsd xmm7, xmm1
0bceffeb  ucomisd xmm0, xmm7
0bceffef  ja 0x0bceffe0 -&gt;LOOP
0bcefff1  jmp 0x0bce001c        -&gt;3
---- TRACE 1 stop -&gt; loop
</pre>

<p>I zde mù¾eme vidìt nìkolik podmínìných skokù (<strong>jnb</strong>,
<strong>jbe</strong>) s&nbsp;podobným významem jako v&nbsp;pøedchozím nativním
kódu. Podrobnosti si v&nbsp;pøípadì zájmu vysvìtlíme pøí¹tì.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Zdrojové kódy dnes pou¾itých demonstraèních pøíkladù i vygenerované sekvence pseudoinstrukcí</h2>

<p>V¹echny dnes pou¾ité demonstraèní pøíklady byly, jak je tomu ostatnì
v&nbsp;tomto seriálu ji¾ dlouhodobìj¹ím zvykem, ulo¾eny do Git (pøesnìji øeèeno
do <a href="http://github.com/">GitHub</a>) repositáøe umístìného na adrese <a
href="https://github.com/tisnik/luajit-examples">https://github.com/tisnik/luajit-examples</a>.</p>

<p>Následuje tabulka obsahující odkazy na poslední verze dne¹ních pøíkladù i
výstupních souborù: trasovací informace, mezikód i novì upravený
<i>Makefile</i>:</p>

<table>
<tr><th> #</th><th>Zdrojový kód</th><th>Umístìní</th></tr>
<tr><td> 1</td><td>test41.lua</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/src/test41.lua">https://github.com/tisnik/luajit-examples/blob/master/src/test41.lua</a></td></tr>
<tr><td> 2</td><td>test43.lua</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/src/test43.lua">https://github.com/tisnik/luajit-examples/blob/master/src/test43.lua</a></td></tr>
<tr><td> 3</td><td>test49.lua</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/src/test49.lua">https://github.com/tisnik/luajit-examples/blob/master/src/test49.lua</a></td></tr>
<tr><td> 4</td><td>test50.lua</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/src/test50.lua">https://github.com/tisnik/luajit-examples/blob/master/src/test50.lua</a></td></tr>
<tr><td> 5</td><td>test53.lua</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/src/test53.lua">https://github.com/tisnik/luajit-examples/blob/master/src/test53.lua</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>test41.out</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/out/test41.out">https://github.com/tisnik/luajit-examples/blob/master/out/test41.out</a></td></tr>
<tr><td> 7</td><td>test43.out</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/out/test43.out">https://github.com/tisnik/luajit-examples/blob/master/out/test43.out</a></td></tr>
<tr><td> 8</td><td>test49.out</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/out/test49.out">https://github.com/tisnik/luajit-examples/blob/master/out/test49.out</a></td></tr>
<tr><td> 9</td><td>test50.out</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/out/test50.out">https://github.com/tisnik/luajit-examples/blob/master/out/test50.out</a></td></tr>
<tr><td>10</td><td>test53.out</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/out/test53.out">https://github.com/tisnik/luajit-examples/blob/master/out/test53.out</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>test41.ir</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/ir/test41.ir">https://github.com/tisnik/luajit-examples/blob/master/ir/test41.ir</a></td></tr>
<tr><td>12</td><td>test43.ir</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/ir/test43.ir">https://github.com/tisnik/luajit-examples/blob/master/ir/test43.ir</a></td></tr>
<tr><td>13</td><td>test49.ir</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/ir/test49.ir">https://github.com/tisnik/luajit-examples/blob/master/ir/test49.ir</a></td></tr>
<tr><td>14</td><td>test50.ir</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/ir/test50.ir">https://github.com/tisnik/luajit-examples/blob/master/ir/test50.ir</a></td></tr>
<tr><td>15</td><td>test53.ir</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/ir/test53.ir">https://github.com/tisnik/luajit-examples/blob/master/ir/test53.ir</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>Makefile</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/Makefile">https://github.com/tisnik/luajit-examples/blob/master/Makefile</a></td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Literatura</h2>

<ol>

<li>Bolz, Cuni, Fijalkowski, Rigo:<br />
&bdquo;Tracing the Meta-Level: PyPy's Tracing JIT Compiler&ldquo;
</li>

<li>Vasanth Bala, Evelyn Duesterwald, Sanjeev Banerjia:<br />
&bdquo;Dynamo: A Transparent Dynamic Optimization System&ldquo;
</li>

<li>Bolz, Cuni, Fijalkowski, Leuschel, Pedroni, Rigo:
&bdquo;Allocation removal by partial evaluation in a tracing JIT&ldquo;
</li>

<li>Bolz:<br />
&bdquo;Automatic JIT Compiler Generation with Runtime Partial Evaluation&ldquo;
</li>

<li>Bolz, Kuhn, Lienhard, Matsakis, Nierstrasz, Renggli, Rigo and T. Verwaest:<br />
&bdquo;Back to the Future in One Week - Implementing a Smalltalk VM in PyPy&ldquo;<br />
pages 123-139. 2008.
</li>

<li>Bolz  and Rigo:<br />
&bdquo;How to not write a virtual machine&ldquo;<br />
In Proceedings of the 3rd Workshop on Dynamic Languages and Applications (DYLA), 2007
</li>

<li>Bruni, Verwaest:<br />
&bdquo;PyGirl: generating Whole-System VMs from High-Level prototypes using PyPy&ldquo;<br />
In Tools, accepted for publication, 2009.
</li>

<li>Sullivan, Bruening, Baron, Garnett and Amarasinghe:<br />
&bdquo;Dynamic native optimization of interpreters&ldquo;<br />
In Proceedings of the 2003 Workshop on Interpreters,<br />
Virtual Machines and Emulators pages 50-57, San Diego, California, 2003. ACM.
</li>

</ol>



<p><a name="k10"></a></p>
<h2 id="k10">10. Odkazy na Internetu</h2>

<ol>

<li>Static single assignment form (SSA)<br />
<a href="http://en.wikipedia.org/wiki/Static_single_assignment_form">http://en.wikipedia.org/wiki/Static_single_assignment_form</a>
</li>

<li>LuaJIT 2.0 SSA IR</li>
<a href="http://wiki.luajit.org/SSA-IR-2.0">http://wiki.luajit.org/SSA-IR-2.0</a>
</li>

<li>Dynamic Assembler<br />
<a href="http://luajit.org/dynasm.html">http://luajit.org/dynasm.html</a>
</li>

<li>The Unofficial DynASM Documentation: Introduction<br />
<a href="http://corsix.github.io/dynasm-doc/index.html">http://corsix.github.io/dynasm-doc/index.html</a>
</li>

<li>Have tracing JIT compilers won?<br />
<a href="http://lambda-the-ultimate.org/node/3851">http://lambda-the-ultimate.org/node/3851</a>
</li>

<li>Tracing just-in-time compilation<br />
<a href="http://en.wikipedia.org/wiki/Tracing_just-in-time_compilation">http://en.wikipedia.org/wiki/Tracing_just-in-time_compilation</a>
</li>

<li>How does LuaJIT's trace compiler work?<br />
<a href="http://www.freelists.org/post/luajit/How-does-LuaJITs-trace-compiler-work,1">http://www.freelists.org/post/luajit/How-does-LuaJITs-trace-compiler-work,1</a>
</li>

<li>How does LuaJIT's trace compiler work?<br />
<a href="http://stackoverflow.com/questions/20266523/how-does-luajits-trace-compiler-work">http://stackoverflow.com/questions/20266523/how-does-luajits-trace-compiler-work</a>
</li>

<li>TraceMonkey<br />
<a href="https://wiki.mozilla.org/JavaScript:TraceMonkey">https://wiki.mozilla.org/JavaScript:TraceMonkey</a>
</li>

<li>TraceMonkey<br />
<a href="http://brendaneich.com/2008/08/tracemonkey-javascript-lightspeed/">http://brendaneich.com/2008/08/tracemonkey-javascript-lightspeed/</a>
</li>

<li>improving JavaScript performance with JägerMonkey<br />
<a href="http://hacks.mozilla.org/2010/03/improving-javascript-performance-with-jagermonkey/">http://hacks.mozilla.org/2010/03/improving-javascript-performance-with-jagermonkey/</a>
</li>

<li>Wikipedia: Mezijazyk<br />
<a href="http://cs.wikipedia.org/wiki/Mezijazyk">http://cs.wikipedia.org/wiki/Mezijazyk</a>
</li>

<li>The LuaJIT Project<br />
<a href="http://luajit.org/index.html">http://luajit.org/index.html</a>
</li>

<li>LuaJIT FAQ<br />
<a href="http://luajit.org/faq.html">http://luajit.org/faq.html</a>
</li>

<li>LuaJIT Performance Comparison<br />
<a href="http://luajit.org/performance.html">http://luajit.org/performance.html</a>
</li>

<li>LuaJIT 2.0 intellectual property disclosure and research opportunities<br />
<a href="http://article.gmane.org/gmane.comp.lang.lua.general/58908">http://article.gmane.org/gmane.comp.lang.lua.general/58908</a>
</li>

<li>LuaJIT Wiki<br />
<a href="http://wiki.luajit.org/Home">http://wiki.luajit.org/Home</a>
</li>

<li>LuaJIT 2.0 Bytecode Instructions<br />
<a href="http://wiki.luajit.org/Bytecode-2.0">http://wiki.luajit.org/Bytecode-2.0</a>
</li>

<li>Programming in Lua 9.1 &ndash; Coroutine Basics,<br />
<a href="http://www.lua.org/pil/9.1.html">http://www.lua.org/pil/9.1.html</a>
</li>

<li>Programming in Lua (first edition)<br />
<a href="http://www.lua.org/pil/contents.html">http://www.lua.org/pil/contents.html</a>
</li>

<li>Programming in Lua: 6 - More about Functions<br />
<a href="http://www.lua.org/pil/6.html">http://www.lua.org/pil/6.html</a>
</li>

<li>Lua Lanes<br />
<a href="http://kotisivu.dnainternet.net/askok/bin/lanes/">http://kotisivu.dnainternet.net/askok/bin/lanes/</a>
</li>

<li>Programming in Lua: 6.1 - Closures<br />
<a href="http://www.lua.org/pil/6.1.html">http://www.lua.org/pil/6.1.html</a>
</li>

<li>Programming in Lua: 9.1 - Coroutine Basics<br />
<a href="http://www.lua.org/pil/9.1.html">http://www.lua.org/pil/9.1.html</a>
</li>

<li>Programming in Lua: Numeric for<br />
<a href="http://www.lua.org/pil/4.3.4.html">http://www.lua.org/pil/4.3.4.html</a>
</li>

<li>Programming in Lua: break and return<br />
<a href="http://www.lua.org/pil/4.4.html">http://www.lua.org/pil/4.4.html</a>
</li>

<li>Programming in Lua: Tables<br />
<a href="http://www.lua.org/pil/2.5.html">http://www.lua.org/pil/2.5.html</a>
</li>

<li>Programming in Lua: Table Constructors<br />
<a href="http://www.lua.org/pil/3.6.html">http://www.lua.org/pil/3.6.html</a>
</li>

<li>Programovací jazyk Lua<br />
<a href="http://palmknihy.cz/web/kniha/programovaci-jazyk-lua-12651.htm">http://palmknihy.cz/web/kniha/programovaci-jazyk-lua-12651.htm</a>
</li>

<li>Lua: Tables Tutorial<br />
<a href="http://lua-users.org/wiki/TablesTutorial">http://lua-users.org/wiki/TablesTutorial</a>
</li>

<li>Lua: Control Structure Tutorial<br />
<a href="http://lua-users.org/wiki/ControlStructureTutorial">http://lua-users.org/wiki/ControlStructureTutorial</a>
</li>

<li>Lua Types Tutorial<br />
<a href="http://lua-users.org/wiki/LuaTypesTutorial">http://lua-users.org/wiki/LuaTypesTutorial</a>
</li>

<li>Goto Statement in Lua<br />
<a href="http://lua-users.org/wiki/GotoStatement">http://lua-users.org/wiki/GotoStatement</a>
</li>

<li>Lua 5.2 sources<br />
<a href="http://www.lua.org/source/5.2/">http://www.lua.org/source/5.2/</a>
</li>

<li>Lua 5.2 sources - lopcodes.h<br />
<a href="http://www.lua.org/source/5.2/lopcodes.h.html">http://www.lua.org/source/5.2/lopcodes.h.html</a>
</li>

<li>Lua 5.2 sources - lopcodes.c<br />
<a href="http://www.lua.org/source/5.2/lopcodes.c.html">http://www.lua.org/source/5.2/lopcodes.c.html</a>
</li>

<li>Lambda the Ultimate: Coroutines in Lua,<br />
<a href="http://lambda-the-ultimate.org/node/438">http://lambda-the-ultimate.org/node/438</a>
</li>

<li>Coroutines Tutorial,<br />
<a href="http://lua-users.org/wiki/CoroutinesTutorial">http://lua-users.org/wiki/CoroutinesTutorial</a>
</li>

<li>Lua Coroutines Versus Python Generators,<br />
<a href="http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators">http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2014</small></p>
</body>
</html>

