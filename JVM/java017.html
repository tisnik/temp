<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>JamVM aneb alternativa k HotSpotu (nejenom) pro embedded zaøízení, tablety a chytré telefony</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>JamVM aneb alternativa k HotSpotu (nejenom) pro embedded zaøízení a chytré telefony</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V sedmnácté èásti ponìkud nepravidelnì vycházejícího seriálu o programovacím jazyce Java a o vlastnostech JVM si øekneme základní informace o projektu JamVM. Pod tímto názvem se skrývá virtuální stroj Javy pøedstavující alternativu ke známému HotSpotu pocházejícímu z dílny firmy Sun a pozdìji Oracle. Díky své systémové nenároènosti je JamVM vhodný pøedev¹ím pro embedded zaøízení, tablety i chytré telefony.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. JamVM aneb alternativa k HotSpotu (nejenom) pro embedded zaøízení, tablety a chytré telefony</a></p>
<p><a href="#k02">2. Základní vlastnosti JamVM</a></p>
<p><a href="#k03">3. Jak pøelo¾it IcedTea s&nbsp;podporou JamVM?</a></p>
<p><a href="#k04">4. Výsledné obrazy JDK a JRE</a></p>
<p><a href="#k05">5. První porovnání JamVM a HotSpotu &ndash; velikost JRE</a></p>
<p><a href="#k06">6. Druhé porovnání JamVM a HotSpotu &ndash; pamì»ová nároènost JRE pøi spu¹tìní virtuálního stroje</a></p>
<p><a href="#k07">7. Tøetí porovnání JamVM a HotSpotu &ndash; výpoèetní výkon pøi bìhu benchmarku ConcatTest</a></p>
<p><a href="#k08">8. Ètvrté porovnání JamVM a HotSpotu  &ndash; výpoèetní výkon dosahovaný pøi slo¾itìj¹ích výpoètech</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2>1. JamVM aneb alternativa k HotSpotu (nejenom) pro embedded zaøízení a chytré telefony</h2>

<p>V&nbsp;pøedchozích ¹estnácti èástech seriálu o programovacím jazyce Java i o
vlastnostech virtuálního stroje Javy jsme se zabývali pøevá¾nì dvìma variantami
JDK &ndash; <i>OpenJDK6</i> a <i>OpenJDK7</i>. Tyto verze JDK a JRE jsou
vybaveny virtuálním strojem Javy nazvaným <i>HotSpot</i>. Jedná se o virtuální
stroj vyu¾ívající pomìrnì velké mno¾ství sofistikovaných a po dlouhý èas
peèlivì ovìøovaných technologií, a» ji¾ se jedná o rùzné typy správcù pamìti
(<i>garbage collectors</i>), tak i o just in time (JIT) pøekladaè bajtkódu do
nativního kódu platformy, na ní¾ je virtuální stroj spu¹tìn. <i>HotSpot</i>
dnes skuteènì patøí mezi technologickou ¹pièku na poli virtuálních strojù,
ov¹em má i nìkolik nevýhod, které mohou v&nbsp;nìkterých pøípadech omezovat
mo¾nosti jeho pou¾ití. Jednou z&nbsp;nevýhod je to, ¾e <i>HotSpot</i> je
k&nbsp;dispozici pro relativnì omezené mno¾ství procesorových architektur:
konkrétnì ho lze pou¾ít na procesorových architekturách <i>x86</i>, <i>x86_64
(AMD64)</i>, <i>Itanium</i> (konèící podpora pro <i>JDK7</i>) a samozøejmì té¾
na architekturách <i>Sparc</i> a <i>UltraSparc</i>.</p>

<img src="http://i.iinfo.cz/images/49/pc151-3.jpg" width="402" height="407" alt=" " />
<p><i>Obrázek 1: Jeden z&nbsp;typù mikroprocesorù SuperSPARC, jen¾ byl vyrábìný
spoleèností Sun Microsystems.</i></p>

<p>Originální zdrojové kódy <i>HotSpotu</i> obsahují pøibli¾nì deset tisíc
øádkù nízkoúrovòového a platformnì závislého kódu napsaného v&nbsp;C++ a zhruba
1000 øádkù kódu v&nbsp;assembleru. I z&nbsp;tohoto dùvodu by bylo velmi slo¾ité
pøidat podporu pro dal¹í procesorovou architekturu. Aby bylo mo¾né
<i>OpenJDK</i> spou¹tìt i na dal¹ích platformách, vzniklo nìkolik projektù,
jejich¾ cílem bylo doplnit èi dokonce zcela nahradit pùvodní <i>HotSpot</i>
jiným øe¹ením. Jedním z&nbsp;tìchto projektù je <i>Zero-assembler port</i>, co¾
je (zjednodu¹enì øeèeno) interpret bajtkódu psaný v&nbsp;programovacím jazyku
C++, který je podporován relativnì úzkou mezivrstvou mezi interpretrem bajtkódu
a voláním nativního kódu (to zaji¹»uje knihovna <i>libffi</i>). Pøedností
tohoto øe¹ení je zaji¹tìná pøenositelnost (vèetnì platformy <i>IBM S/390</i>),
nevýhodou pak pomalý bìh programù zpùsobený interpretací bajtkódu. Druhou
mo¾ností (èi spí¹e doplòkem) je projekt <i>Shark</i>, který umo¾òuje vyu¾ití
just in time (<i>JIT</i>) pøekladaèe z&nbsp;<i>LLVM</i>. Tímto projektem se
pravdìpodobnì budeme zabývat v&nbsp;nìkterém z&nbsp;dal¹ích dílù tohoto
seriálu. Dal¹í alternativu k&nbsp;<i>HotSpotu</i> pøedstavuje projekt <i>CACAO
VM</i> (ke kterému se opìt je¹tì vrátíme) a takté¾ <i>JamVM</i> popsaný
v&nbsp;následujících kapitolách.</p>

<img src="http://i.iinfo.cz/images/49/pc151-5.jpg" width="450" height="471" alt=" " />
<p><i>Obrázek 2: Architektura mikroprocesorù UltraSPARC T1.</i></p>



<p><a name="k02"></a></p>
<h2>2. Základní vlastnosti JamVM</h2>

<p><i>JamVM</i> je v&nbsp;mnoha ohledech pomìrnì zajímavý projekt, proto¾e se
jedná o samostatný a souèasnì i plnohodnotný virtuální stroj Javy, který je
z&nbsp;velké èásti vyvíjený jedním autorem, jím¾ je <i>Robert Lougher</i>.
Pøedností <i>JamVM</i> v&nbsp;porovnání s&nbsp;<i>HotSpotem</i> je men¹í
velikost samotného virtuálního stroje a takté¾ prakticky neomezená
pøenositelnost na rùzné platformy (ov¹em s&nbsp;urèitým mno¾stvím práce pøi
pøidávání dal¹í nové platformy), co¾ se ukazuje být velmi dùle¾itá vlastnost
pøedev¹ím v&nbsp;souèasnosti, kdy je mnoho vestavných (embedded) zaøízení i
smartphonù a tabletù (dokonce i nìkolik typù netbookù) postaveno na
mikroprocesorech <i>ARM</i> nebo <i>MIPS</i>, tak¾e poptávka po výkonných ale
pamì»ovì nenároèných virtuálních strojích Javy je dosti velká (ostatnì ani
<i>Dalvik</i> není s&nbsp;<i>JamVM</i> &ndash; politicky korektnì øeèeno :-)
&ndash; úplnì nepodobný). <i>JamVM</i> je naprogramován pøevá¾nì v&nbsp;èistém
céèku, ov¹em nìkolik èasovì kritických èástí je napsáno v&nbsp;assembleru, co¾
znamená, ¾e pro ka¾dou procesorovou platformu je nutné relativnì malou èást
kódu naprogramovat znovu. Pro ilustraci: jedná se prùmìrnì o zhruba tøi a¾ osm
kilobajtù zdrojového kódu, co¾ není mnoho.</p>

<img src="http://i.iinfo.cz/images/151/java17-03.png" width="537" height="307" alt=" " />
<p><i>Obrázek 3: Podíl jednotlivých programovacích jazykù ve zdrojových kódech
JamVM.<br />
Zdroj: analýza provedena slu¾bou Ohloh.</i></p>

<p>V&nbsp;souèasnosti je <i>JamVM</i> podporován na následujících architekturách:</p>

<ul>
<li>PowerPC</li>
<li>i486 a vy¹¹í (my¹lena je zde 32bitová architektura x86)</li>
<li>AMD64</li>
<li>ARM (samozøejmì vèetnì populárního Beagle Boardu)</li>
<li>MIPS</li>
</ul>

<p>I kdy¾ <i>JamVM</i> neobsahuje plnohodnotný just in time pøekladaè, je jeho
interpret bajtkódu v&nbsp;porovnání s&nbsp;konkurencí velmi rychlý, tak¾e se
jeho výkonnost zdola pøibli¾uje k&nbsp;JIT pøekladaèùm. To je velmi dùle¾ité
pøedev¹ím na mikroprocesorech <i>ARM</i> a <i>MIPS</i>, pro nì¾ není
k&nbsp;dispozici originální <i>HotSpot</i> a <i>Zero-assembler port</i> je
dosti pomalý. Souèástí ka¾dého virtuálního stroje Javy v¹ak není pouze
interpret bajtkódu èi jeho JIT pøekladaè, ale také správce èi správci pamìti.
V&nbsp;pøípadì <i>JamVM</i> je k&nbsp;dispozici modifikovaný správce pamìti
typu <i>Mark and Sweep</i>, který mù¾e bì¾et synchronnì èi asynchronnì ve svém
vlastním vláknu. Obrazy Javovských objektù na haldì se odli¹ují od obrazù
pou¾ívaných v&nbsp;<i>HotSpotu</i>, napøíklad tím, ¾e se pou¾ívají pøímé
ukazatele na objekty a hlavièka obrazù objektù je pojata minimalisticky
(obsahuje pouze dvì slova, z&nbsp;nich¾ jedno je ukazatel na tøídu, které je
objekt instancí).</p>

<img src="http://i.iinfo.cz/images/113/java17-04.png" width="538" height="311" alt=" " />
<p><i>Obrázek 4: Graf postupného rùstu poètu øádkù (vèetnì prázdných øádkù a
komentáøù) ve zdrojových kódech virtuálního stroje JamVM.<br />
Zdroj: analýza provedena slu¾bou Ohloh.</i></p>



<p><a name="k03"></a></p>
<h2>3. Jak pøelo¾it IcedTea s&nbsp;podporou JamVM?</h2>

<p>Virtuální stroj <i>JamVM</i> lze pøelo¾it a vyu¾ívat buï spoleènì
s&nbsp;projektem <i>GNU Classpath</i> (jako pøekladaè se v&nbsp;tomto pøípadì
vìt¹inou pou¾ívá <strong>gcj</strong> nebo <strong>ecj</strong>), popø.&nbsp;je
mo¾né vyu¾ít jednodu¹¹í variantu &ndash; pøelo¾it <i>IcedTea</i>
(tj.&nbsp;<i>OpenJDK</i> s&nbsp;pøidanými knihovnami, nìkolika desítkami patchù
a podporou pøekladu pouze pomocí GNU nástrojù), ov¹em s&nbsp;náhradou pùvodního
<i>HotSpotu</i> právì za <i>JamVM</i>. Tento postup sice na první pohled mù¾e
vypadat slo¾itì, ov¹em ve skuteènosti je ji¾ potøebná funkcionalita zabudována
pøímo do <i>IcedTea</i>. Nejprve si uka¾me, jakým zpùsobem se pøekládá
<i>IcedTea6</i> zalo¾ené na <i>OpenJDK6</i>, co¾ je postup vyu¾ívaný pro
pøípravu balíèkù s&nbsp;OS Javou (SDK+JRE) na vìt¹inì Linuxových distribucí.
Celý postup je velmi jednoduchý, samozøejmì za pøedpokladu, ¾e jsou
nainstalovány <a
href="http://icedtea.classpath.org/wiki/BuildRequirements">v¹echny potøebné
nástroje a knihovny</a>:</p>

<pre>
hg clone http://icedtea.classpath.org/hg/icedtea6
./autogen.sh
./configure --disable-bootstrap
make
</pre>

<p>Pøi pøekladu <i>IcedTea6</i> s&nbsp;podporou <i>JamVM</i> namísto pùvodního
<i>HotSpotu</i> pøibude pouze jedna nová volba <strong>--enable-jamvm</strong>
v&nbsp;pøíkazu <strong>configure</strong>:</p>

<pre>
hg clone http://icedtea.classpath.org/hg/icedtea6
./autogen.sh
./configure --disable-bootstrap --enable-jamvm
make
</pre>

<p>Poznámka: v&nbsp;pøípadì, ¾e se pøeklad provádí na poèítaèi vybaveném vìt¹ím
mno¾stvím mikroprocesorù, popø.&nbsp;vícejádrovými procesory, lze pøeklad
urychlit pomocí volby <strong>--with-parallel-jobs=n</strong>, kde se za
<i>n</i> dosadí poèet procesù spu¹tìných bìhem pøekladu:</p>

<pre>
hg clone http://icedtea.classpath.org/hg/icedtea6
./autogen.sh
./configure --disable-bootstrap --enable-jamvm --with-parallel-jobs=4
make
</pre>



<p><a name="k04"></a></p>
<h2>4. Výsledné obrazy JDK a JRE</h2>

<p>V&nbsp;pøípadì, ¾e pøeklad celého projektu <i>IcedTea</i> probìhne bez
chyby, je obraz plnohodnotného <i>JDK</i> (pou¾ívaného pro vývoj v&nbsp;Javì)
ulo¾en v&nbsp;podadresáøi <strong>openjdk.build/j2sdk-image</strong> a obraz
samotného <i>JRE</i> (pouze bìhové prostøedí urèené napøíklad pro instalaci na
aplikaèní servery) je v&nbsp;podadresáøi
<strong>openjdk.build/j2re-image</strong>:</p>

<pre>
ls -l openjdk.build

total 124
drwxr-xr-x  2 tisnik tisnik  4096 Aug  5 22:18 bin
drwxr-xr-x  5 tisnik tisnik  4096 Aug  5 22:15 btclasses
drwxr-xr-x  2 tisnik tisnik  4096 Aug  5 22:11 btjars
drwxr-xr-x  2 tisnik tisnik  4096 Aug  5 22:05 bundles
drwxr-xr-x  9 tisnik tisnik  4096 Aug  5 22:16 classes
drwxr-xr-x  9 tisnik tisnik  4096 Aug  5 22:07 corba
drwxr-xr-x  9 tisnik tisnik  4096 Aug  5 22:17 demo
drwxr-xr-x  3 tisnik tisnik  4096 Aug  5 22:17 democlasses
drwxr-xr-x  6 tisnik tisnik  4096 Aug  5 22:20 docs
drwxr-xr-x  3 tisnik tisnik  4096 Aug  5 22:16 gennativesrc
drwxr-xr-x  6 tisnik tisnik  4096 Aug  5 22:16 gensrc
drwxr-xr-x  4 tisnik tisnik  4096 Aug  5 22:05 hotspot
drwxr-xr-x  7 tisnik tisnik  4096 Aug  5 22:11 impsrc
drwxr-xr-x  3 tisnik tisnik  4096 Aug  5 22:16 include
drwxr-xr-x  5 tisnik tisnik  4096 Aug  5 22:20 j2re-image   &lt;--------
drwxr-xr-x  9 tisnik tisnik  4096 Aug  5 22:21 j2sdk-image  &lt;--------
drwxr-xr-x  2 tisnik tisnik  4096 Aug  5 22:05 java.net
drwxr-xr-x  5 tisnik tisnik  4096 Aug  5 22:07 jaxp
drwxr-xr-x  5 tisnik tisnik  4096 Aug  5 22:07 jaxws
drwxr-xr-x  4 tisnik tisnik  4096 Aug  5 22:05 langtools
drwxr-xr-x 10 tisnik tisnik  4096 Aug  5 22:21 lib
drwxr-xr-x  6 tisnik tisnik  4096 Aug  5 22:17 sample
-rw-r--r--  1 tisnik tisnik 12469 Aug  5 22:11 sanityCheckMessages.txt
-rw-r--r--  1 tisnik tisnik  4338 Aug  5 22:11 sanityCheckWarnings.txt
drwxr-xr-x  2 tisnik tisnik  4096 Aug  5 22:05 source-bundles
drwxr-xr-x  3 tisnik tisnik  4096 Aug  5 22:20 symbols
drwxr-xr-x 24 tisnik tisnik  4096 Aug  5 22:21 tmp
</pre>

<p>Jak <i>JDK</i>, tak i <i>JRE</i> lze zkopírovat nebo nalinkovat do adresáøe
<strong>/usr/lib/jvm</strong> a nakonfigurovat cesty ke v¹em zde pøítomným
souborùm pomocí <strong>alternatives</strong>, popø.&nbsp;podobného
nástroje (nebo lze provést stejnou operaci ruènì :-).</p>



<p><a name="k05"></a></p>
<h2>5. První porovnání JamVM a HotSpotu &ndash; velikost JRE</h2>

<p>Po pøekladu obou variant <i>IcedTea</i>, tj.&nbsp;první varianty zalo¾ené na
klasickém <i>HotSpotu</i> a druhé varianty, která se spoléhá na alternativní
<i>JamVM</i> v&nbsp;roli virtuálního stroje Javy, se mù¾eme podívat na to,
v&nbsp;èem se ve skuteènosti odli¹uje <i>JRE</i> s&nbsp;<i>HotSpotem</i> a
<i>JRE</i> s&nbsp;<i>JamVM</i>. První rozdíl mezi obìma virtuálními stroji je
patrný ji¾ pøi zcela zbì¾ném pohledu na celkovou velikost adresáøù s&nbsp;obìma
variantami <i>JRE</i>. Následující hodnoty byly získány na 64bitové
architektuøe <i>x86_64 (AMD64)</i>, co¾ mj.&nbsp;znamená, ¾e na 32bitových
systémech budou zji¹tìné hodnoty o nìkolik procent men¹í (pomìr mezi jejich
velikostmi v¹ak zùstane pøibli¾nì stejný).</p>

<p>HotSpot JRE:</p>

<pre>
du -s -b -h openjdk.build/j2re-image
95M       j2re-image
</pre>

<p>JamVM JRE:</p>

<pre>
du -s -b -h openjdk.build/j2re-image
86M        j2re-image
</pre>

<p>Pøi podrobnìj¹ím prùzkumu obou adresáøù obsahujících <i>JRE</i> lze zjistit,
¾e naprostá vìt¹ina souborù má shodnou délku i obsah a dal¹ích nìkolik souborù
(vìt¹inou nativních knihoven) se ve velikosti li¹í pouze o nìkolik desítek
bajtù. Ov¹em nejmarkantnìj¹í rozdíl je ve velikosti souborù
<strong>libjvm.so</strong>, co¾ je nativní knihovna obsahující vlastní
virtuální stroj Javy. Tato knihovna má v&nbsp;pøípadì <i>HotSpotu</i>
pøelo¾eného na platformì <i>x86_64</i> velikost:</p>

<pre>
ls -lhR j2re-image | grep libjvm.so
-rwxr-xr-x 1 tisnik tisnik 11M 2011-08-05 23:06 libjvm.so
</pre>

<p>tj.&nbsp;<strong>11 megabajtù</strong>, zatímco pro <i>JamVM</i> dostaneme
zcela odli¹nou hodnotu:</p>

<pre>
ls -lhR j2re-image | grep libjvm.so
-rwxr-xr-x 1 tisnik tisnik 371K 2011-08-05 22:49 libjvm.so
</pre>

<p>tj.&nbsp;velikost mnohem ni¾¹í. Aby bylo porovnání férové, byly porovnávány
velikosti stripovaných souborù, v&nbsp;opaèném pøípadì by toti¾ byl rozdíl ve
velikosti v&nbsp;rozsahu dvou øádù (!), samozøejmì v&nbsp;neprospìch
<i>HotSpotu</i>, který obsahuje mnohem víc funkcí, metod a promìnných
s&nbsp;pøidru¾enými ladicími informacemi.</p>

<p>Poznámka: vyhledávání nativní knihovny <strong>libjvm.so</strong> ve výpisu
pomocí pøíkazu <strong>grep</strong> jsem zvolil z&nbsp;toho dùvodu, ¾e se
umístìní této knihovny v&nbsp;adresáøích <i>JRE</i> li¹í podle toho, zda je
pøeklad proveden na 32bitovém systému (zde jsou v&nbsp;pøípadì <i>HotSpotu</i>
dostupné varianty klient i server) èi na systému 64bitovém (zde je
k&nbsp;dispozici pouze varianta server) a takté¾ v&nbsp;závislosti na zvolené
platformì. V&nbsp;na¹em konkrétním pøípadì, kdy byl pøeklad <i>IcedTea</i>
proveden na platformì <i>x86_64</i>, byla nalezena knihovna
<strong>libjvm.so</strong> le¾ící v&nbsp;adresáøi:</p>

<pre>
j2re-image/lib/amd64/server
</pre>



<p><a name="k06"></a></p>
<h2>6. Druhé porovnání JamVM a HotSpotu &ndash; pamì»ová nároènost JRE pøi spu¹tìní virtuálního stroje</h2>

<p>V&nbsp;pøedchozí kapitole jsme si ukázali, ¾e velikosti nativních knihoven
s&nbsp;virtuálním strojem Javy se sice vzájemnì dosti významnì odli¹ují, to
ov¹em je¹tì nemusí znamenat, ¾e se budou ve stejném pomìru li¹it i obrazy
virtuálních strojù v&nbsp;operaèní pamìti poèítaèe po jejich spu¹tìní. Ov¹em i
pro tento pøípad je mo¾né pou¾ít sice ponìkud nepøesné, ale stále velmi
jednoduché mìøení. Jedná se o výpis spotøeby pamìti JVM v&nbsp;pøípadì, ¾e je
v&nbsp;tomto stroji spu¹tìn nìjaký velmi jednoduchý Javovský program, který jen
vypí¹e èíslo svého procesu (pro mo¾nost podrobnìj¹ího prùzkumu) a posléze ji¾
pouze èeká na stisk klávesy Enter. Následuje výpis zdrojového kódu tohoto velmi
jednoduchého testu:</p>

<pre>
import java.io.*;

public class SimpleMemTest {
    static {
        // Nejprve vypiseme PID - cislo procesu.
        // Nasledujici trik je odzkousen pouze na Linuxu:
        try {
            System.out.println("PID=" +
                    new File("/proc/self").getCanonicalFile().getName());
        }
        catch (IOException e) {
            System.out.println("windows???");
        }
        // potom jiz jen cekame na stisk Enteru
        System.console().readLine("Press Enter to exit this test");
        // hotovo
        System.exit(0);
    }
}
</pre>

<p>Ihned poté, co program vypí¹e èíslo svého procesu, mù¾eme se z&nbsp;druhého
terminálu (konzole) podívat, jakým zpùsobem je pamì» pro daný virtuální stroj
Javy alokována.</p>

<p>HotSpot JRE:</p>

<pre>
cat /proc/***PID***/status

Name:   java
State:  S (sleeping)
SleepAVG:       68%
Tgid:   10488
Pid:    10488
PPid:   10098
TracerPid:      0
Uid:    14282   14282   14282   14282
Gid:    14282   14282   14282   14282
FDSize: 256
Groups: 5283 14282 
VmPeak:  2393280 kB
VmSize:  2393280 kB
VmLck:         0 kB
VmHWM:     13444 kB
VmRSS:     13444 kB
VmData:  2293224 kB
VmStk:        88 kB
VmExe:        36 kB
VmLib:     13528 kB
VmPTE:       228 kB
StaBrk: 01ed9000 kB
Brk:    01fae000 kB
StaStk: 7fff6e18dee0 kB
Threads:        14
SigQ:   0/71680
SigPnd: 0000000000000000
ShdPnd: 0000000000000000
SigBlk: 0000000000000000
SigIgn: 0000000000000000
SigCgt: 0000000181005ccf
CapInh: 0000000000000000
CapPrm: 0000000000000000
CapEff: 0000000000000000
Cpus_allowed:   00000000,00000000,00000000,00000000,00000000,00000000,00000000,0000000f
Mems_allowed:   00000000,00000001
</pre>

<p>JamVM JRE:</p>

<pre>
cat /proc/***PID***/status

Name:   java
State:  S (sleeping)
SleepAVG:       68%
Tgid:   10455
Pid:    10455
PPid:   10098
TracerPid:      0
Uid:    14282   14282   14282   14282
Gid:    14282   14282   14282   14282
FDSize: 256
Groups: 5283 14282 
VmPeak:  1351768 kB
VmSize:  1319960 kB
VmLck:         0 kB
VmHWM:      9340 kB
VmRSS:      9340 kB
VmData:  1173200 kB
VmStk:        88 kB
VmExe:        36 kB
VmLib:      2872 kB
VmPTE:       200 kB
StaBrk: 197d1000 kB
Brk:    1991e000 kB
StaStk: 7fff57c7b690 kB
Threads:        6
SigQ:   0/71680
SigPnd: 0000000000000000
ShdPnd: 0000000000000000
SigBlk: 0000000000000000
SigIgn: 0000000000000000
SigCgt: 0000000180004207
CapInh: 0000000000000000
CapPrm: 0000000000000000
CapEff: 0000000000000000
Cpus_allowed:   00000000,00000000,00000000,00000000,00000000,00000000,00000000,0000000f
Mems_allowed:   00000000,00000001
</pre>

<p>Ilustrativnìj¹í v¹ak bude zobrazení rozdílù mezi obìma virtuálními
stroji:</p>

<pre>
diff --side-by-side status-hotspot status-jamvm

         Hotspot VM             JamVM
VmPeak:  2393280 kB           | VmPeak:  1351768 kB
VmSize:  2393280 kB           | VmSize:  1319960 kB
VmLck:         0 kB             VmLck:         0 kB
VmHWM:     13444 kB           | VmHWM:      9340 kB
VmRSS:     13444 kB           | VmRSS:      9340 kB
VmData:  2293224 kB           | VmData:  1173200 kB
VmStk:        88 kB             VmStk:        88 kB
VmExe:        36 kB             VmExe:        36 kB
VmLib:     13528 kB           | VmLib:      2872 kB
VmPTE:       228 kB           | VmPTE:       200 kB
</pre>

<p>(nerelevantní øádky byly odstranìny). Pøedchozí mìøení je samozøejmì pouze
pøibli¾né, proto¾e pøi spou¹tìní virtuálního stroje Javy lze pomocí mnoha
parametrù velmi pøesnì nastavit velikost jednotlivých pamì»ových regionù
(zásobníku, haldy...), ov¹em i samotná velikost <i>HotSpotu</i> èi <i>JamVM</i>
v&nbsp;tomto pøípadì hraje svoji roli.</p>



<p><a name="k07"></a></p>
<h2>7. Tøetí porovnání JamVM a HotSpotu &ndash; výpoèetní výkon pøi bìhu benchmarku ConcatTest</h2>

<p>V&nbsp;tomto seriálu jsme se ji¾ nìkolikrát setkali s&nbsp;jednoduchým
benchmarkem nazvaným <i>ConcatTest</i>. V&nbsp;tomto benchmarku je
v&nbsp;programové smyèce vytváøen øetìzec skládaný postupnì z&nbsp;men¹ích
øetìzcù. Vzhledem k&nbsp;tomu, ¾e pro spojování øetìzcù je pou¾it operátor +,
provìøuje tento test jak funkci správcù pamìti (v&nbsp;jedné iteraci toti¾
dochází ke vzniku nìkolika objektù s&nbsp;krátkou dobou ¾ivota), tak i
implementaci subrutin pou¾ívaných pro kopii znakù mezi øetìzci. Zdrojový kód
benchmarku je následující:</p>

<pre>
public class ConcatTest
{
    private static final int LOOP_COUNT = 10000;

    public static String createString(int loopCount)
    {
        String str = "";
        for (int i = 0; i &lt; loopCount; i++)
        {
            str += i + " ";
        }
        return str;
    }

    public static void main(String[] args)
    {
        long t1 = System.currentTimeMillis();
        // vypocitat pocet iteraci
        int loopCount = args.length == 0 ? LOOP_COUNT : (1 &lt;&lt; Integer.parseInt(args[0]));
        String str = "";
        for (int i = 0; i &lt; 10; i++)
        {
            str = createString(loopCount);
        }
        long t2 = System.currentTimeMillis();
        System.out.format("Loop count: %8d   time: %6d   string length: %8d\n", loopCount, (t2-t1), str.length());
    }
}
</pre>

<a href="http://i.iinfo.cz/images/567/java17-05.png"><img src="http://i.iinfo.cz/images/567/java17-05-prev.png" width="370" height="256" alt=" " /></a>
<p><i>Obrázek 5: Zdrojový kód prvního benchmarku se zvýraznìním
syntaxe.</i></p>

<p>Tento benchmark je spou¹tìn ve skriptu, v&nbsp;nìm¾ se mìní poèet iterací
programové smyèky pou¾ité pro konstrukci výsledného øetìzce:</p>

<pre>
#!/bin/bash

HOTSPOT_JRE=~/icedtea6-hotspot/openjdk.build/j2sdk-image/bin/
JAMVM_JRE=~/icedtea6-jamvm/openjdk.build/j2sdk-image/bin/

${HOTSPOT_JRE}java -version 2&gt; hotpspot.txt
for i in `seq 5 16`;
do
    ${HOTSPOT_JRE}java ConcatTest $i &gt;&gt; hotpspot.txt
done

${JAMVM_JRE}java -version 2&gt; hotpspot.txt
for i in `seq 5 16`;
do
    ${JAMVM_JRE}java ConcatTest $i &gt;&gt; jamvm.txt
done
</pre>

<a href="http://i.iinfo.cz/images/354/java17-06.png"><img src="http://i.iinfo.cz/images/354/java17-06-prev.png" width="370" height="204" alt=" " /></a>
<p><i>Obrázek 6: Zdrojový kód spou¹tìcího skriptu prvního benchmarku se
zvýraznìním syntaxe.</i></p>

<p>Pøi spu¹tìní benchmarku se kupodivu ukazuje, ¾e <i>HotSpot</i>
s&nbsp;povoleným JITem a <i>JamVM</i> s&nbsp;pouhým interpretrem bajtkódu jsou
prakticky stejnì rychlá øe¹ení, a to pøevá¾nì z&nbsp;toho dùvodu, ¾e kopie polí
znakù a spou¹tìní správcù pamìti jsou na obou virtuálních strojích realizovány
shodným èi velmi podobným zpùsobem:</p>

<pre>
java version "1.6.0_23"                                                         
OpenJDK Runtime Environment (IcedTea6 1.11pre+r013f83c2fa16) (linux-gnu build 1.
OpenJDK 64-Bit Server VM (build 20.0-b11, mixed mode)

Loop count:       32   time:      1   string length:       86
Loop count:       64   time:      3   string length:      182
Loop count:      128   time:      6   string length:      402
Loop count:      256   time:     17   string length:      914
Loop count:      512   time:     52   string length:     1938
Loop count:     1024   time:    133   string length:     4010
Loop count:     2048   time:    443   string length:     9130
Loop count:     4096   time:   1399   string length:    19370
Loop count:     8192   time:   5471   string length:    39850
Loop count:    16384   time:  29295   string length:    87194
Loop count:    32768   time: 129135   string length:   185498
</pre>

<pre>
java version "1.6.0_23"                                                         
IcedTea6 Runtime Environment (1.11pre+r013f83c2fa16) (linux-gnu build 1.6.0_23-b
JamVM (build 1.6.0-devel, inline-threaded interpreter)

Loop count:       32   time:      1   string length:       86
Loop count:       64   time:      3   string length:      182
Loop count:      128   time:      5   string length:      402
Loop count:      256   time:     13   string length:      914
Loop count:      512   time:     42   string length:     1938
Loop count:     1024   time:    153   string length:     4010
Loop count:     2048   time:    457   string length:     9130
Loop count:     4096   time:   1732   string length:    19370
Loop count:     8192   time:   6899   string length:    39850
Loop count:    16384   time:  28577   string length:    87194
Loop count:    32768   time: 122037   string length:   185498
</pre>



<p><a name="k08"></a></p>
<h2>8. Ètvrté porovnání JamVM a HotSpotu &ndash; výpoèetní výkon pøi slo¾itìj¹ích výpoètech</h2>

<p>Benchmark uvedený v&nbsp;pøedchozí kapitole neukazoval prakticky ¾ádné
významnìj¹í rozdíly mezi <i>HotSpotem</i> a <i>JamVM</i>, a to pøedev¹ím
z&nbsp;toho dùvodu, ¾e se v&nbsp;nìm nemohl výraznìji projevit JIT pøekladaè,
který je v&nbsp;<i>HotSpotu</i> implementován. Z&nbsp;tohoto dùvodu si je¹tì
uká¾eme, jak se výpoèetní výkon (pøesnìji øeèeno rychlost provádìní Javovských
programù) zmìní ve chvíli, kdy se bude spou¹tìt benchmark s&nbsp;mnoha do sebe
vlo¾enými programovými smyèkami, v&nbsp;nich¾ se provádí slo¾itìj¹í výpoèty,
pøi nich¾ se nemusí volat ¾ádné knihovní funkce. Právì zde by se mìla projevit
kvalita JIT pøekladaèe oproti pouhému interpretru bajtkódu. Jako druhý
benchmark jsem zvolil program pro výpoèet <i>Mandelbrotovy mno¾iny</i>, jeho¾
zdrojový kód je následující::</p>

<pre>
public class Mandelbrot
{
    public static final int MAXITER = 1000;

    public static void mandelbrot(int resolution, int maxiter)
    {
        double cy = -2.0;
        for (int y = 0; y &lt; resolution; y++)
        {
            double cx = -2.0;
            for (int x = 0; x &lt; resolution; x++)
            {
                double zx = 0.0, zy = 0.0, zx2, zy2;
                int iter = 0;
                while (++iter &lt; maxiter)
                {
                    zx2 = zx * zx;
                    zy2 = zy * zy;
                    if (zx2 + zy2 &gt; 4.0) break;
                    zy = 2.0 * zx * zy + cy;
                    zx = zx2 - zy2 + cx;
                }
                //System.out.print(iter==maxiter ? ' ' : '.');
                cx += 4.0/resolution;
            }
            //System.out.println();
            cy += 4.0/resolution;
        }
    }

    public static void main(String[] args)
    {
        long t1 = System.currentTimeMillis();
        mandelbrot(1 &lt;&lt; Integer.parseInt(args[0]), MAXITER);
        long t2 = System.currentTimeMillis();
        System.out.format("time: %6d\n", t2-t1);
    }
}
</pre>

<a href="http://i.iinfo.cz/images/100/java17-07.png"><img src="http://i.iinfo.cz/images/100/java17-07-prev.png" width="213" height="270" alt=" " /></a>
<p><i>Obrázek 7: Zdrojový kód druhého benchmarku se zvýraznìním
syntaxe.</i></p>

<p>Na rozdíl od pøedchozího benchmarku nyní budeme testovat výkonnost tøí
virtuálních strojù. Prvním virtuálním strojem je <i>HotSpot</i>
s&nbsp;interpretrem bajtkódu (pou¾ívá se volba <strong>
-Djava.compiler=NONE</strong>), druhým virtuálním strojem je takté¾
<i>HotSpot</i>, tentokrát v¹ak vyu¾ívající svùj JIT pøekladaè a koneènì tøetí
virtuální stroj je pøedstavován <i>JamVM</i>. O spou¹tìní v¹ech tøí benchmarkù
se stará následující skript:</p>

<pre>
#!/bin/bash

HOTSPOT_JRE=~/icedtea6-hotspot/openjdk.build/j2sdk-image/bin/
JAMVM_JRE=~/icedtea6-jamvm/openjdk.build/j2sdk-image/bin/

for i in `seq 4 12`;
do
    ${HOTSPOT_JRE}java -Djava.compiler=NONE Mandelbrot $i &gt;&gt; hotpspot_int.txt
done

for i in `seq 4 12`;
do
    ${HOTSPOT_JRE}java Mandelbrot $i &gt;&gt; hotpspot_jit.txt
done

for i in `seq 4 12`;
do
    ${JAMVM_JRE}java Mandelbrot $i &gt;&gt; jamvm.txt
done
</pre>

<a href="http://i.iinfo.cz/images/407/java17-08.png"><img src="http://i.iinfo.cz/images/407/java17-08-prev.png" width="370" height="194" alt=" " /></a>
<p><i>Obrázek 8: Zdrojový kód spou¹tìcího skriptu druhého benchmarku se
zvýraznìním syntaxe.</i></p>

<p>V&nbsp;tomto pøípadì se ji¾ naplno projevuje kvalita JIT pøekladaèe, který
je zhruba desetkrát rychlej¹í, ne¾ interpret bajtkódu zabudovaný
v&nbsp;<i>HotSpotu</i>. Zajímavé v¹ak je, ¾e interpret z&nbsp;<i>JamVM</i> je
rychlej¹í ne¾ interpret z&nbsp;<i>HotSpotu</i>, co¾ jen svìdèí o kvalitì návrhu
<i>JamVM</i>, který i pøesto, ¾e se jedná v&nbsp;podstatì o one man show,
doká¾e konkurovat interpretru vyvíjenému ji¾ nìkolik let vìt¹í vývojovou
skupinou:</p>

<table>
<tr><th>Rozli¹ení</th><th>HotSpot interpret</th><th>HotSpot JIT</th><th>JamVM</th></tr>
<tr><td>  2&times;2  </td><td>     2</td><td>    2</td><td>    1</td></tr>
<tr><td>  4&times;4  </td><td>     7</td><td>    9</td><td>    6</td></tr>
<tr><td>  8&times;8  </td><td>    26</td><td>   15</td><td>   21</td></tr>
<tr><td> 16&times;16 </td><td>   100</td><td>   22</td><td>   83</td></tr>
<tr><td> 32&times;32 </td><td>   399</td><td>   53</td><td>  328</td></tr>
<tr><td> 64&times;64 </td><td>  1595</td><td>  191</td><td> 1310</td></tr>
<tr><td>128&times;128</td><td>  6362</td><td>  698</td><td> 5230</td></tr>
<tr><td>256&times;256</td><td> 25456</td><td> 2773</td><td>20928</td></tr>
<tr><td>512&times;512</td><td>101863</td><td>11015</td><td>83703</td></tr>
</table>



<p><a name="k09"></a></p>
<h2>9. Odkazy na Internetu</h2>

<ol>

<li>JamVM home page<br />
<a href="http://jamvm.sourceforge.net/">http://jamvm.sourceforge.net/</a>
</li>

<li>GNU Classpath<br />
<a href="www.gnu.org/s/classpath/">www.gnu.org/s/classpath/</a></li>

<li>JamVM na stránkách SourceForge<br />
<a href="http://sourceforge.net/projects/jamvm/">http://sourceforge.net/projects/jamvm/</a>
</li>

<li>Java VMs Compared<br />
<a href="http://bugblogger.com/java-vms-compared-160/">http://bugblogger.com/java-vms-compared-160/</a>
</li>

<li>JamVM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/JamVM">http://en.wikipedia.org/wiki/JamVM</a>
</li>

<li>Statistika projektu JamVM na slu¾bì Ohloh<br />
<a href="https://www.ohloh.net/p/jamvm">https://www.ohloh.net/p/jamvm</a>
</li>

<li>IcedTea Build Requirements<br />
<a href="http://icedtea.classpath.org/wiki/BuildRequirements">http://icedtea.classpath.org/wiki/BuildRequirements</a>
</li>

<li>IcedTea Fedora Build Instructions<br />
<a href="http://icedtea.classpath.org/wiki/FedoraBuildInstructions">http://icedtea.classpath.org/wiki/FedoraBuildInstructions</a>
</li>

<li>IcedTea Debian Building Instructions<br />
<a href="http://icedtea.classpath.org/wiki/DebianBuildingInstructions">http://icedtea.classpath.org/wiki/DebianBuildingInstructions</a>
</li>

<li>IcedTea Gentoo Build Instructions<br />
<a href="http://icedtea.classpath.org/wiki/GentooBuildInstructions">http://icedtea.classpath.org/wiki/GentooBuildInstructions</a>
</li>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Package javax.script (JavaDoc)<br />
<a href="http://download.oracle.com/javase/6/docs/api/javax/script/package-summary.html">http://download.oracle.com/javase/6/docs/api/javax/script/package-summary.html</a>
</li>

<li>javax.script.Bindings<br />
<a href="http://download.oracle.com/javase/6/docs/api/javax/script/Bindings.html">http://download.oracle.com/javase/6/docs/api/javax/script/Bindings.html</a>
</li>

<li>javax.script.Compilable<br />
<a href="http://download.oracle.com/javase/6/docs/api/javax/script/Compilable.html">http://download.oracle.com/javase/6/docs/api/javax/script/Compilable.html</a>
</li>

<li>javax.script.Invocable<br />
<a href="http://download.oracle.com/javase/6/docs/api/javax/script/Invocable.html">http://download.oracle.com/javase/6/docs/api/javax/script/Invocable.html</a>
</li>

<li>javax.script.ScriptContext<br />
<a href="http://download.oracle.com/javase/6/docs/api/javax/script/ScriptContext.html">http://download.oracle.com/javase/6/docs/api/javax/script/ScriptContext.html</a>
</li>

<li>javax.script.ScriptEngine<br />
<a href="http://download.oracle.com/javase/6/docs/api/javax/script/ScriptEngine.html">http://download.oracle.com/javase/6/docs/api/javax/script/ScriptEngine.html</a>
</li>

<li>javax.script.ScriptEngineFactory<br />
<a href="http://download.oracle.com/javase/6/docs/api/javax/script/ScriptEngineFactory.html">http://download.oracle.com/javase/6/docs/api/javax/script/ScriptEngineFactory.html</a>
</li>

<li>javax.script.AbstractScriptEngine<br />
<a href="http://download.oracle.com/javase/6/docs/api/javax/script/AbstractScriptEngine.html">http://download.oracle.com/javase/6/docs/api/javax/script/AbstractScriptEngine.html</a>
</li>

<li>javax.script.CompiledScript<br />
<a href="http://download.oracle.com/javase/6/docs/api/javax/script/CompiledScript.html">http://download.oracle.com/javase/6/docs/api/javax/script/CompiledScript.html</a></td>
</li>

<li>javax.script.ScriptEngineManager<br />
<a href="http://download.oracle.com/javase/6/docs/api/javax/script/ScriptEngineManager.html">http://download.oracle.com/javase/6/docs/api/javax/script/ScriptEngineManager.html</a>
</li>

<li>javax.script.SimpleBindings<br />
<a href="http://download.oracle.com/javase/6/docs/api/javax/script/SimpleBindings.html">http://download.oracle.com/javase/6/docs/api/javax/script/SimpleBindings.html</a>
</li>

<li>javax.script.SimpleScriptContext<br />
<a href="http://download.oracle.com/javase/6/docs/api/javax/script/SimpleScriptContext.html">http://download.oracle.com/javase/6/docs/api/javax/script/SimpleScriptContext.html</a>
</li>

<li>javax.script.ScriptException<br />
<a href="http://download.oracle.com/javase/6/docs/api/javax/script/ScriptException.html">http://download.oracle.com/javase/6/docs/api/javax/script/ScriptException.html</a>
</li>

<li>The Java Compatibility Test Tools: JavaTest Harness<br />
<a href="http://java.sun.com/developer/technicalArticles/JCPtools2/">http://java.sun.com/developer/technicalArticles/JCPtools2/</a>
</li>

<li>JavaScript engine (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/JavaScript_engine">http://en.wikipedia.org/wiki/JavaScript_engine</a>
</li>

<li>Rhino (JavaScript engine)<br />
<a href="http://en.wikipedia.org/wiki/Rhino_(JavaScript_engine)">http://en.wikipedia.org/wiki/Rhino_(JavaScript_engine)</a>
</li>

<li>Rhino: JavaScript for Java<br />
<a href="http://www.mozilla.org/rhino/">http://www.mozilla.org/rhino/</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a></li>

<li>HugePages<br />
<a href="http://linux-mm.org/HugePages">http://linux-mm.org/HugePages</a>
</li>

<li>Tuning big java heap and linux huge pages<br />
<a href="http://www.tikalk.com/alm/forums/tuning-big-java-heap-and-linux-huge-pages">http://www.tikalk.com/alm/forums/tuning-big-java-heap-and-linux-huge-pages</a>
</li>

<li>How do I set up hugepages in Red Hat Enterprise Linux 4<br />
<a href="http://magazine.redhat.com/2007/05/29/how-do-i-set-up-hugepages-in-red-hat-enterprise-linux-4/">http://magazine.redhat.com/2007/05/29/how-do-i-set-up-hugepages-in-red-hat-enterprise-linux-4/</a>
</li>

<li>Java SE Tuning Tip: Large Pages on Windows and Linux<br />
<a href="http://blogs.sun.com/dagastine/entry/java_se_tuning_tip_large">http://blogs.sun.com/dagastine/entry/java_se_tuning_tip_large</a>
</li>

<li>Translation lookaside buffer<br />
<a href="http://en.wikipedia.org/wiki/Translation_lookaside_buffer">http://en.wikipedia.org/wiki/Translation_lookaside_buffer</a>
</li>

<li>Physical Address Extension<br />
<a href="http://en.wikipedia.org/wiki/Physical_Address_Extension">http://en.wikipedia.org/wiki/Physical_Address_Extension</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a>
</li>

<li>Amdahl's law<br />
<a href="http://en.wikipedia.org/wiki/Amdahl_law">http://en.wikipedia.org/wiki/Amdahl_law</a>
</li>

<li>Garbage collection (computer science)<br />
<a href="http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)</a>
</li>

<li>Dr. Dobb's | G1: Java's Garbage First Garbage Collector<br />
<a href="http://www.drdobbs.com/article/printableArticle.jhtml?articleId=219401061&amp;dept_url=/java/">http://www.drdobbs.com/article/printableArticle.jhtml?articleId=219401061&amp;dept_url=/java/</a>
</li>

<li>Java's garbage-collected heap<br />
<a href="http://www.javaworld.com/javaworld/jw-08-1996/jw-08-gc.html">http://www.javaworld.com/javaworld/jw-08-1996/jw-08-gc.html</a>
</li>

<li>Compressed oops in the Hotspot JVM<br />
<a href="http://wikis.sun.com/display/HotSpotInternals/CompressedOops">http://wikis.sun.com/display/HotSpotInternals/CompressedOops</a>
</li>

<li>32-bit or 64-bit JVM? How about a Hybrid?<br />
<a href="http://blog.juma.me.uk/2008/10/14/32-bit-or-64-bit-jvm-how-about-a-hybrid/">http://blog.juma.me.uk/2008/10/14/32-bit-or-64-bit-jvm-how-about-a-hybrid/</a>
</li>

<li>Compressed object pointers in Hotspot VM<br />
<a href="http://blogs.sun.com/nike/entry/compressed_object_pointers_in_hotspot">http://blogs.sun.com/nike/entry/compressed_object_pointers_in_hotspot</a>
</li>

<li>Java HotSpot(tm) Virtual Machine Performance Enhancements<br />
<a href="http://download.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html">http://download.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html</a>
</li>

<li>Using jconsole<br />
<a href="http://download.oracle.com/javase/1.5.0/docs/guide/management/jconsole.html">http://download.oracle.com/javase/1.5.0/docs/guide/management/jconsole.html</a>
</li>

<li>jconsole &ndash; Java Monitoring and Management Console<br />
<a href="http://download.oracle.com/javase/1.5.0/docs/tooldocs/share/jconsole.html">http://download.oracle.com/javase/1.5.0/docs/tooldocs/share/jconsole.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>x86-64<br />
<a href="http://en.wikipedia.org/wiki/X86-64">http://en.wikipedia.org/wiki/X86-64</a>
</li>

<li>Physical Address Extension<br />
<a href="http://en.wikipedia.org/wiki/Physical_Address_Extension">http://en.wikipedia.org/wiki/Physical_Address_Extension</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>1.6.0_14 (6u14)<br />
<a href="http://www.oracle.com/technetwork/java/javase/6u14-137039.html?ssSourceSiteId=otncn">http://www.oracle.com/technetwork/java/javase/6u14-137039.html?ssSourceSiteId=otncn</a>
</li>

<li>Update Release Notes<br />
<a href="http://www.oracle.com/technetwork/java/javase/releasenotes-136954.html">http://www.oracle.com/technetwork/java/javase/releasenotes-136954.html</a>
</li>

<li>Java virtual machine: 4.10 Limitations of the Java Virtual Machine<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#88659">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#88659</a>
</li>

<li>Java(TM) Platform, Standard Edition 7 Binary Snapshot Releases<br />
<a href="http://dlc.sun.com.edgesuite.net/jdk7/binaries/index.html">http://dlc.sun.com.edgesuite.net/jdk7/binaries/index.html</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>ClosableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>ArrayList (JDK 1.4)<br />
<a href="http://download.oracle.com/javase/1.4.2/docs/api/java/util/ArrayList.html">http://download.oracle.com/javase/1.4.2/docs/api/java/util/ArrayList.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2011</small></p>
</body>
</html>

