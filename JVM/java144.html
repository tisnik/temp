<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - volání funkcí a pou¾ití generátorù i uzávìrù v Python VM (2)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - volání funkcí a pou¾ití generátorù i uzávìrù v Python VM (2)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Na pøedchozí èást seriálu o JVM (i o dal¹ích typech virtuálních strojù), v ní¾ jsme si popsali volání funkcí a metod v Python VM dnes navá¾eme, proto¾e si vysvìtlíme princip implementace generátorù a uzávìrù v Python VM. Díky podpoøe uzávìrù a generátorù je mo¾né v Pythonu psát nìkteré algoritmy velmi elegantním zpùsobem.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Generátory v&nbsp;Pythonu a v&nbsp;Python VM</a></p>
<p><a href="#k02">2. Demonstraèní pøíklad <strong>Test32.py</strong>: jednoduchý generátor</a></p>
<p><a href="#k03">3. Pøeklad demonstraèního pøíkladu <strong>Test32.py</strong> do bajtkódu Python VM</a></p>
<p><a href="#k04">4. Demonstraèní pøíklad <strong>Test33.py</strong>: generátor koneèné sekvence hodnot</a></p>
<p><a href="#k05">5. Pøeklad demonstraèního pøíkladu <strong>Test33.py</strong> do bajtkódu Python VM</a></p>
<p><a href="#k06">6. Uzávìry v&nbsp;Pythonu a v&nbsp;Python VM</a></p>
<p><a href="#k07">7. Demonstraèní pøíklad <strong>Test34.py</strong>: jednoduchý uzávìr vytvoøený v&nbsp;Pythonu</a></p>
<p><a href="#k08">8. Pøeklad demonstraèního pøíkladu <strong>Test34.py</strong> do bajtkódu Python VM</a></p>
<p><a href="#k09">9. Demonstraèní pøíklad <strong>Test35.py</strong>: nefunkèní implementace èítaèe realizovaného uzávìrem</a></p>
<p><a href="#k10">10. Demonstraèní pøíklad <strong>Test36.py</strong>: funkèní implementace èítaèe realizovaného uzávìrem</a></p>
<p><a href="#k11">11. Pøeklad demonstraèního pøíkladu <strong>Test36.py</strong> do bajtkódu Python VM</a></p>
<p><a href="#k12">12. Repositáø se zdrojovými kódy v¹ech pìti dne¹ních demonstraèních pøíkladù</a></p>
<p><a href="#k13">13. Generátory a uzávìry &ndash; rozdíly mezi jazyky Lua a Python</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Generátory v&nbsp;Pythonu a v&nbsp;Python VM</h2>

<p>V&nbsp;pøedchozí èásti tohoto seriálu jsme si popsali princip volání funkcí
v&nbsp;bajtkódu Python VM. Víme ji¾, jak se volají &bdquo;bì¾né&ldquo; funkce
s&nbsp;pozièními parametry, funkce, jejich¾ (nìkteré) parametry mají pøiøazenou
implicitní hodnotu i funkce, pøi jejich¾ volání jsou explicitnì pøiøazeny
hodnoty k&nbsp;pojmenovaným parametrùm. Ov¹em v&nbsp;souvislosti
s&nbsp;funkcemi si musíme popsat dvojici konceptù &ndash; <i>uzávìrù
(closures)</i> a <i>generátorù (generators)</i>. Zejména koncept
<i>generátorù</i> a obecnì <i>koprogramù (coroutines)</i> umo¾òuje tvoøit
v&nbsp;Pythonu nìkteré algoritmy velmi elegantním zpùsobem bez nutnosti
zavádìní lazy sekvencí známých z&nbsp;nìkterých funkcionálních programovacích
jazykù. Generátory jsou v&nbsp;programech pou¾ity pøedev¹ím v&nbsp;programových
smyèkách typu <strong>for</strong>, ve skuteènosti je v¹ak mo¾né volat
koprogram (kterým je generátor vìt¹inou implementován) i z&nbsp;jiné èásti
kódu. Nicménì právì pou¾ití v&nbsp;programové smyèce typu <strong>for</strong>
je tak idiomatické, ¾e tuto smyèku pou¾ijeme i v&nbsp;nìkterých dne¹ních
demonstraèních pøíkladech (proto se také budeme bavit speciálnì o generátorech
a ne o obecných koprogramech).</p>

<p><i>Generátorem</i> se v&nbsp;Pythonu oznaèuje specifický typ funkce urèené
pro postupné generování nìjaké sekvence hodnot, pøièem¾ tato sekvence mù¾e být
nekoneèná. Pøi ka¾dém volání této funkce je v¹ak vrácena v¾dy jen jedna hodnota
&ndash; to je právì dùvod, proè mohou generátory generovat teoreticky
nekoneènou sekvenci, ani¾ by do¹lo k&nbsp;zaplnìní ve¹keré operaèní pamìti. Aby
bylo mo¾né generátor vùbec vytvoøit, musel být koncept <i>funkcí</i> roz¹íøen a
zobecnìn &ndash; funkce ji¾ nemá jeden vstupní bod a její provádìní neskonèí
pøi výskoku z&nbsp;funkce, ale v&nbsp;pøípadì generátorù má funkce urèitou
formu vnitøní pamìti (tím se pøibli¾uje uzávìrùm, i kdy¾ samotná implementace
je odli¹ná).</p>

<p>Aby bylo mo¾né pøi ka¾dém zavolání generátoru vrátit dal¹í hodnotu
generované posloupnosti a souèasnì i zachovat vnitøní stav funkce, nepou¾ívá se
pro vrácení a ukonèení funkce klíèové slovo <strong>return</strong> ale odli¹né
klíèové slovo <strong>yield</strong>. Jakmile program pøi svém bìhu
(v&nbsp;prùbìhu vykonávání tìla generátoru) narazí na toto klíèové slovo,
<i>pøeru¹í</i> bìh generátoru a vrátí hodnotu výrazu uvedeného za tímto
klíèovým slovem. Dal¹í volání generátoru nezaèíná od zaèátku jeho tìla, ale
tìsnì za pøíkazem <strong>yield</strong>. Pokud se v¹ak pøi provádìní
generátoru dojde na konec jeho tìla, ukonèí se jeho bìh, stejnì jako je tomu u
bì¾né funkce. Generátor se nevolá pøímo, ale pøes funkci/metodu
<strong>next()</strong>, co¾ vlastnì znamená, ¾e se souèasnì jedná i o
<i>iterátor</i>.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Demonstraèní pøíklad <strong>Test32.py</strong>: jednoduchý generátor</h2>

<p>Pochopení principu práce generátorù mù¾e být mo¾ná zpoèátku ponìkud slo¾ité,
proto se podívejme na &bdquo;¹kolní&ldquo; pøíklad, jeho¾ obdobu lze najít
v&nbsp;mnoha uèebnicích programovacího jazyka Python. V&nbsp;tomto pøíkladu je
vytvoøen generátor, který po ka¾dém svém zavolání vrátí dal¹í èlen posloupnosti
faktoriálù, tj.&nbsp;postupnì se vrací hodnoty 1!=1, 2!=2, 3!=6, 4!=24 atd.
Tìlo generátoru pojmenovaného <strong>factorialGenerator()</strong> je tvoøeno
nekoneènou smyèkou (generuje se tedy alespoò teoreticky nekoneèná posloupnost
&ndash; otestujte sami!), v&nbsp;jejím¾ tìle je pou¾it pøíkaz <strong>yield
n</strong>, který <i>pøeru¹í</i> bìh generátoru a souèasnì i vrátí hodnotu
dal¹ího vypoèteného faktoriálu v&nbsp;posloupnosti. &bdquo;Pamì»
generátoru&ldquo; je zde tvoøena dvojicí interních promìnných nazvaných
<strong>n</strong> a <strong>i</strong>. Pov¹imnìte si, ¾e generátor se volá
pøímo pøes metodu <strong>next()</strong>, co¾ je v&nbsp;praxi ponìkud
neobvyklé (v&nbsp;dal¹ím pøíkladu je ukázán jiný postup):</p>

<pre>
<i>#</i>
<i># Demonstracni priklad cislo 32.</i>
<i>#</i>
<i># Generatory v Pythonu.</i>
<i>#</i>
&nbsp;
&nbsp;
&nbsp;
<i>#</i>
<i># Jednoduchy generator.</i>
<i>#</i>
def <strong>factorialGenerator()</strong>:
    n = 1
    i = 1
    while True:
        <strong>yield</strong> n
        i = i + 1
        n = n * i
&nbsp;
&nbsp;
&nbsp;
<i>#</i>
<i># Spusteni testu.</i>
<i>#</i>
def <strong>main()</strong>:
    fact = factorialGenerator()
    for i in range(10):
        print(fact.next())
&nbsp;
&nbsp;
&nbsp;
<i>#</i>
<i># Ukazka disasembleru.</i>
<i># (prekladu funkci do bajtkodu Python VM).</i>
<i>#</i>
def <strong>disassemble()</strong>:
    from dis import dis
&nbsp;
    print("\nfactorialGenerator():")
    dis(factorialGenerator)
&nbsp;
&nbsp;
&nbsp;
main()
&nbsp;
<i>#disassemble()</i>
&nbsp;
<i>#</i>
<i># Finito.</i>
<i>#</i>
</pre>

<p>Tento demonstraèní pøíklad po svém spu¹tìní vypí¹e na standardní výstup
následující sekvenci hodnot:</p>

<pre>
1
2
6
24
120
720
5040
40320
362880
3628800
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Pøeklad demonstraèního pøíkladu <strong>Test32.py</strong> do bajtkódu Python VM</h2>

<p>Podívejme se na zpùsob pøekladu demonstraèního pøíkladu
<strong>Test32.py</strong> popsaného <a href="#k03">v&nbsp;pøedchozí
kapitole</a> do bajtkódu virtuálního stroje jazyka Python. Pøeklad funkce
<strong>factorialGenerator()</strong> je zvlá¹tní pou¾itím instrukce
<strong>YIELD_VALUE</strong>, která implementuje funkcionalitu zabezpeèenou
pøímo v&nbsp;Pythonu klíèovým slovem <strong>yield</strong>. Pøi volání
instrukce <strong>YIELD_VALUE</strong> se na vrcholu zásobníku operandù (TOS)
oèekává hodnota, která je pøedána volajícímu kódu:</p>

<pre>
<strong>factorialGenerator</strong>():
 13           0 LOAD_CONST               1 (1)         <i>// umístit na TOS celoèíselnou konstantu 1</i>
              3 STORE_FAST               0 (n)         <i>// a ulo¾it ji do lokální promìnné <strong>n</strong></i>
&nbsp;
 14           6 LOAD_CONST               1 (1)         <i>// opìt umístit na TOS celoèíselnou konstantu 1</i>
              9 STORE_FAST               1 (i)         <i>// a ulo¾it ji do lokální promìnné <strong>i</strong></i>
&nbsp;
 15          12 SETUP_LOOP              37 (to 52)     <i>// pøíprava na provedení programové smyèky</i>
             15 LOAD_GLOBAL              0 (True)      <i>// pøíprava pro test na tuto hodnotu (<strong>True</strong>)</i>
             18 JUMP_IF_FALSE           29 (to 50)     <i>// tento podmínìný skok nikdy nenastane</i>
             21 POP_TOP                                <i>// odstranit prvek (<strong>True</strong>) z TOS</i>
&nbsp;
 16          22 LOAD_FAST                0 (n)         <i>// naètení hodnoty lokální promìnné <strong>n</strong></i>
             25 YIELD_VALUE                            <i>// pøeru¹ení bìhu generátoru a vrácení hodnoty <strong>n</strong></i>
             26 POP_TOP                                <i>// odstranit prvek (hodnotu <strong>n</strong>) z TOS</i>
&nbsp;
 17          27 LOAD_FAST                1 (i)         <i>// |</i>
             30 LOAD_CONST               1 (1)         <i>// | implementace operace i = i + 1</i>
             33 BINARY_ADD                             <i>// |</i>
             34 STORE_FAST               1 (i)         <i>// |</i>
&nbsp;
 18          37 LOAD_FAST                0 (n)         <i>// |</i>
             40 LOAD_FAST                1 (i)         <i>// | implementace operace n = n * i</i>
             43 BINARY_MULTIPLY                        <i>// |</i>
             44 STORE_FAST               0 (n)         <i>// |</i>
&nbsp;
             47 JUMP_ABSOLUTE           15             <i>// skok na zaèátek programové smyèky while</i>
&nbsp;
             50 POP_TOP                                <i>// odstranit prvek z TOS</i>
             51 POP_BLOCK                              <i>// (úklid po programové smyèce)</i>
                                                       <i>// standardní výskok z funkce</i>
             52 LOAD_CONST               0 (None)      <i>// ulo¾it konstantu None na zásobník operandù</i>
             55 RETURN_VALUE                           <i>// vrátit tuto konstantu (ulo¾enou na TOS)</i>
</pre>

<p>Samotné pou¾ití generátoru je velice snadné, proto¾e explicitnì voláme
metodu <strong>fact.next()</strong>, kde <strong>fact</strong> je jméno lokální
promìnné, do ní¾ byla reference na generátor ulo¾ena. Ve¹kerá dal¹í èinnost je
ji¾ zaji¹tìna programovou smyèkou <strong>for</strong> a funkcí
<strong>range()</strong> vracející svùj vlastní iterátor (který nemá
s&nbsp;na¹ím generátorem nic spoleèného):</p>

<pre>
<strong>main</strong>():
 26           0 LOAD_GLOBAL              0             <i>// naètení globální reference na funkci <strong>factorialGenerator</strong></i>
              3 CALL_FUNCTION            0             <i>// volání funkce <strong>factorialGenerator()</strong> bez parametrù</i>
              6 STORE_FAST               0 (fact)      <i>// ulo¾it vrácenou referenci do lokální promìnné</i>
&nbsp;
 27           9 SETUP_LOOP              31 (to 43)     <i>// pøíprava na provedení programové smyèky</i>
             12 LOAD_GLOBAL              1 (range)     <i>// naètení globální reference na funkci <strong>range()</strong></i>
             15 LOAD_CONST               1 (10)        <i>// konstanta pøedávaná do funkce <strong>range()</strong></i>
             18 CALL_FUNCTION            1             <i>// zavolání funkce <strong>range(10)</strong></i>
             21 GET_ITER                               <i>// získání iterátoru vráceného funkcí <strong>range()</strong></i>
&nbsp;
             22 FOR_ITER                17 (to 42)     <i>// zaèátek programové smyèky (vstup do dal¹í iterace)</i>
             25 STORE_FAST               1 (i)         <i>// tato lokální promìnná je poèitadlem smyèky</i>
&nbsp;
 28          28 LOAD_FAST                0 (fact)      <i>// pøíprava na volání metody <strong>fact.next()</strong></i>
             31 LOAD_ATTR                2 (next)      <i>// pøíprava na volání metody <strong>fact.next()</strong></i>
             34 CALL_FUNCTION            0             <i>// zavolání metody <strong>fact.next()</strong>, tj.&nbsp;provedení výpoètu</i>
             37 PRINT_ITEM                             <i>// výpis hodnoty vrácené generátorem</i>
             38 PRINT_NEWLINE                          <i>// odøádkování na standardním výstupu</i>
&nbsp;
             39 JUMP_ABSOLUTE           22             <i>// skok na zaèátek programové smyèky for</i>
             42 POP_BLOCK                              <i>// (úklid po smyèce)</i>
                                                       <i>// standardní výskok z funkce</i>
             43 LOAD_CONST               0 (None)      <i>// ulo¾it konstantu None na zásobník operandù</i>
             46 RETURN_VALUE                           <i>// vrátit tuto konstantu (ulo¾enou na TOS)</i>
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Demonstraèní pøíklad <strong>Test33.py</strong>: generátor koneèné sekvence hodnot</h2>

<p>Ve druhém demonstraèním pøíkladu je pùvodní generátor
<strong>factorialGenerator</strong> upraven takovým zpùsobem, ¾e generuje
hodnoty faktoriálu pouze do chvíle, kdy je pøekroèen nastavený limit pøedaný
pøi vytváøení generátoru v&nbsp;parametru <strong>maxn</strong>. Jakmile je
limit pøekroèen, bìh generátoru je ukonèen a souèasnì se vyhodí výjimka typu
<strong>StopIteration</strong>. To nás v¹ak nemusí pøíli¹ trápit
v&nbsp;pøípadì, ¾e je generátor pou¾it v&nbsp;programové smyèce typu
<strong>for</strong>, nebo» v&nbsp;ní se výskyt této výjimky pøedpokládá
&ndash; ukonèuje její bìh. Naproti tomu pøi explicitním volání funkce
<strong>next()</strong> by se výjimka mìla zachytit (co¾ v¹ak v&nbsp;na¹em
demonstraèním pøíkladu nemusíme dìlat a také to nedìláme):</p>

<pre>
<i>#</i>
<i># Demonstracni priklad cislo 33.</i>
<i>#</i>
<i># Generatory v Pythonu.</i>
<i>#</i>
&nbsp;
&nbsp;
&nbsp;
<i>#</i>
<i># Jednoduchy generator s limitem.</i>
<i>#</i>
def <strong>factorialGenerator(maxn)</strong>:
    n = 1
    i = 1
    while n &lt; maxn:
        <strong>yield</strong> n
        i = i + 1
        n = n * i
&nbsp;
&nbsp;
&nbsp;
<i>#</i>
<i># Spusteni testu.</i>
<i>#</i>
def <strong>main()</strong>:
    for fact in factorialGenerator(1e10):
        print(fact)
&nbsp;
&nbsp;
&nbsp;
<i>#</i>
<i># Ukazka disasembleru.</i>
<i># (prekladu funkci do bajtkodu Python VM).</i>
<i>#</i>
def <strong>disassemble()</strong>:
    from dis import dis
&nbsp;
    print("\nfactorialGenerator():")
    dis(factorialGenerator)
&nbsp;
&nbsp;
&nbsp;
main()
&nbsp;
<i>#disassemble()</i>
&nbsp;
<i>#</i>
<i># Finito.</i>
<i>#</i>
</pre>

<p>Výstup tohoto demonstraèního pøíkladu vypadá následovnì:</p>

<pre>
1
2
6
24
120
720
5040
40320
362880
3628800
39916800
479001600
6227020800
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Pøeklad demonstraèního pøíkladu <strong>Test33.py</strong> do bajtkódu Python VM</h2>

<p>Funkce <strong>factorialGenerator()</strong> se opìt pøelo¾í s&nbsp;vyu¾itím
instrukce <strong>YIELD_VALUE</strong>. Od pøedchozí verze stejnojmenné funkce
se nová varianta li¹í pøedev¹ím ve zpùsobu testu ukonèení vnitøní programové
smyèky, která ji¾ není nekoneèná. Pov¹imnìte si, ¾e nikde není vidìt generování
výjimky <strong>StopIteration</strong> o ní¾ jsme se <a href="#k04">zmínili
vý¹e</a>. To je (díky OO návrhu) zaji¹tìno internì pøekladaèem:</p>

<pre>
<strong>factorialGenerator</strong>():
 13           0 LOAD_CONST               1 (1)         <i>// umístit na TOS celoèíselnou konstantu 1</i>
              3 STORE_FAST               1 (n)         <i>// a ulo¾it ji do lokální promìnné <strong>n</strong></i>
&nbsp;
 14           6 LOAD_CONST               1 (1)         <i>// opìt umístit na TOS celoèíselnou konstantu 1</i>
              9 STORE_FAST               2 (i)         <i>// a ulo¾it ji do lokální promìnné <strong>i</strong></i>
&nbsp;
 15          12 SETUP_LOOP              43 (to 58)     <i>// pøíprava na provedení programové smyèky</i>
             15 LOAD_FAST                1 (n)         <i>// hodnota lokální promìnné <strong>n</strong></i>
             18 LOAD_FAST                0 (maxn)      <i>// se bude porovnávat s&nbsp;hodnotou parametru <strong>maxn</strong></i>
             21 COMPARE_OP               0 (&lt;)
             24 JUMP_IF_FALSE           29 (to 56)     <i>// podmínìný skok ZA konec smyèky</i>
             27 POP_TOP                                <i>// odstranit prvek (výsledek porovnání) z TOS</i>
&nbsp;
 16          28 LOAD_FAST                1 (n)         <i>// naètení hodnoty lokální promìnné <strong>n</strong></i>
             31 YIELD_VALUE                            <i>// pøeru¹ení bìhu generátoru a vrácení hodnoty <strong>n</strong></i>
             32 POP_TOP                                <i>// odstranit prvek (hodnotu <strong>n</strong>) z TOS</i>
&nbsp;
 17          33 LOAD_FAST                2 (i)         <i>// |</i>
             36 LOAD_CONST               1 (1)         <i>// | implementace operace i = i + 1</i>
             39 BINARY_ADD                             <i>// |</i>
             40 STORE_FAST               2 (i)         <i>// |</i>
&nbsp;
 18          43 LOAD_FAST                1 (n)         <i>// |</i>
             46 LOAD_FAST                2 (i)         <i>// | implementace operace n = n * i</i>
             49 BINARY_MULTIPLY                        <i>// |</i>
             50 STORE_FAST               1 (n)         <i>// |</i>
&nbsp;
             53 JUMP_ABSOLUTE           15             <i>// skok na zaèátek programové smyèky while</i>
&nbsp;
             56 POP_TOP                                <i>// odstranit prvek z TOS</i>
             57 POP_BLOCK                              <i>// (úklid po programové smyèce)</i>
                                                       <i>// standardní výskok z funkce</i>
             58 LOAD_CONST               0 (None)      <i>// ulo¾it konstantu None na zásobník operandù</i>
             61 RETURN_VALUE                           <i>// vrátit tuto konstantu (ulo¾enou na TOS)</i>
</pre>

<p>Pou¾ití nové verze generátoru v&nbsp;programové smyèce typu
<strong>for</strong> je nyní velice snadné, proto¾e tuto funkci vyu¾ijeme pro
získání iterátoru, pro nìj¾ smyèka <strong>for</strong> automaticky bude volat
metodu <strong>next()</strong> a¾ do té chvíle, ne¾ dojde k&nbsp;výjimce:</p>

<pre>
<strong>main</strong>():
 26           0 SETUP_LOOP              25 (to 28)
              3 LOAD_GLOBAL              0             <i>// naètení globální reference na funkci <strong>factorialGenerator</strong></i>
              6 LOAD_CONST               1             <i>// jediný parametr funkce <strong>factorialGenerator</strong> &ndash; hodnota (10000000000.0</i>
              9 CALL_FUNCTION            1             <i>// volání funkce <strong>factorialGenerator()</strong> s jedním parametrem</i>
             12 GET_ITER                               <i>// získání iterátoru vráceného funkcí <strong>factorialGenerator()</strong></i>
&nbsp;
             13 FOR_ITER                11 (to 27)     <i>// zaèátek programové smyèky (vstup do dal¹í iterace)</i>
             16 STORE_FAST               0 (fact)      <i>// tato promìnná je postupnì naplòována hodnotami vytváøenými generátorem</i>
&nbsp;
 27          19 LOAD_FAST                0 (fact)      <i>// naèíst hodnotu vrácenou generátorem</i>
             22 PRINT_ITEM                             <i>// výpis hodnoty vrácené generátorem</i>
             23 PRINT_NEWLINE                          <i>// odøádkování na standardním výstupu</i>
&nbsp;
             24 JUMP_ABSOLUTE           13             <i>// skok na zaèátek programové smyèky for</i>
             27 POP_BLOCK                              <i>// (úklid po smyèce)</i>
                                                       <i>// standardní výskok z funkce</i>
             28 LOAD_CONST               0 (None)      <i>// ulo¾it konstantu None na zásobník operandù</i>
             31 RETURN_VALUE                           <i>// vrátit tuto konstantu (ulo¾enou na TOS)</i>
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Uzávìry v&nbsp;Pythonu a v&nbsp;Python VM</h2>

<p>V&nbsp;programovacím jazyku Python je kromì &bdquo;obyèejných&ldquo; funkcí
a generátorù mo¾né vytváøe i uzávìry (<i>closures</i>). Samotné pou¾ití uzávìrù
je sice v&nbsp;Pythonu 2.x ponìkud problematické (co¾ ostatnì uvidíme
v&nbsp;navazujících kapitolách), ov¹em v&nbsp;Pythonu 3.x je ji¾ tento
nedostatek související se sémantikou rozpoznání lokálních a nelokálních
promìnných odstranìn a tak mají uzávìry v&nbsp;Pythonu prakticky stejnou
vyjadøovací sílu, jako napøíklad v&nbsp;programovacích jazycích Lua èi
JavaScript; nehledì ji¾ na vìt¹inu funkcionálních jazykù, které samozøejmì
práci s&nbsp;uzávìry ve vìt¹inì pøípadù takté¾ podporují. Uzávìry jsou navíc
tak dùle¾itou souèástí Pythonu, ¾e pro jejich implementaci jsou v&nbsp;bajtkódu
Python VM rezervovány dvì instrukce nazvané <strong>LOAD_CLOSURE</strong> a
<strong>MAKE_CLOSURE</strong> s&nbsp;nimi¾ se setkáme v&nbsp;navazujících
kapitolách, konkrétnì ve výpisech bajtkódù demonstraèních pøíkladù.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Demonstraèní pøíklad <strong>Test34.py</strong>: jednoduchý uzávìr vytvoøený v&nbsp;Pythonu</h2>

<p>První demonstraèní pøíklad s&nbsp;uzávìrem je velmi prostý, proto¾e je zde
funkce (která tvoøí základ uzávìru) navázána na hodnotu parametru pøedaného do
funkce, v&nbsp;ní¾ se uzávìr vytváøí. Pro lep¹í èitelnost je funkce tvoøící
základ uzávìru pojmenována, ve skuteènosti by v¹ak bylo mo¾né
v&nbsp;jednodu¹¹ích pøípadech pou¾ít i anonymní funkce vytvoøené
s&nbsp;vyu¾itím klíèového slova <strong>lambda</strong> (zde v¹ak programovací
jazyk Python omezuje tìla takových funkcí na jediný výraz, co¾ mù¾e být nìkdy
pøíli¹ striktní, ostatnì právì proto si ukazujeme pou¾ití vnitøní neanonymní
funkce):</p>

<pre>
<i>#</i>
<i># Demonstracni priklad cislo 34.</i>
<i>#</i>
<i># Jednoduchy uzaver v Pythonu.</i>
<i>#</i>
&nbsp;
&nbsp;
&nbsp;
<i>#</i>
<i># Jednoduchy uzaver v Pythonu.</i>
<i>#</i>
def <strong>dummyAdder</strong>(delta):
    def <strong>add</strong>(n):
        return delta + n
    return add
&nbsp;
&nbsp;
&nbsp;
<i>#</i>
<i># Spusteni testu.</i>
<i>#</i>
def <strong>main</strong>():
    adder1 = dummyAdder(0)
    adder2 = dummyAdder(42)
    for i in range(1,11):
        result1 = adder1(i)
        result2 = adder2(i)
        print("Iteration #%d" % i)
        print("    Adder1: %d" % result1)
        print("    Adder2: %d" % result2)
&nbsp;
&nbsp;
&nbsp;
<i>#</i>
<i># Ukazka disasembleru.</i>
<i># (prekladu funkci do bajtkodu Python VM).</i>
<i>#</i>
def <strong>disassemble</strong>():
    from dis import dis
&nbsp;
    print("\ndummyAdder():")
    dis(dummyAdder)
&nbsp;
    print("\nmain():")
    dis(main)
&nbsp;
&nbsp;
&nbsp;
main()
&nbsp;
disassemble()
&nbsp;
<i>#</i>
<i># Finito.</i>
<i>#</i>
</pre>

<p>Po spu¹tìní tohoto demonstraèního pøíkladu je patrné, ¾e se skuteènì ka¾dý
uzávìr navázal na jinou hodnotu parametru pøedaného do funkce vytváøející
uzávìr:</p>

<pre>
Iteration #1
    Adder1: 1
    Adder2: 43
Iteration #2
    Adder1: 2
    Adder2: 44
Iteration #3
    Adder1: 3
    Adder2: 45
Iteration #4
    Adder1: 4
    Adder2: 46
Iteration #5
    Adder1: 5
    Adder2: 47
Iteration #6
    Adder1: 6
    Adder2: 48
Iteration #7
    Adder1: 7
    Adder2: 49
Iteration #8
    Adder1: 8
    Adder2: 50
Iteration #9
    Adder1: 9
    Adder2: 51
Iteration #10
    Adder1: 10
    Adder2: 52
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Pøeklad demonstraèního pøíkladu <strong>Test34.py</strong> do bajtkódu Python VM</h2>

<p>Opìt nás bude zajímat, jakým zpùsobem se demonstraèní pøíklad
<strong>Test34.py</strong> pøelo¾il do bajtkódu virtuálního stroje Pythonu.
Nejdøíve se podívejme na pøeklad funkce <strong>dummyAdder()</strong>,
v&nbsp;jejím¾ bajtkódu mù¾eme vidìt nové instrukce nazvané
<strong>LOAD_CLOSURE</strong> a <strong>MAKE_CLOSURE</strong>, které se
postarají &ndash; ji¾ na takto nízké úrovni &ndash; o vytvoøení uzávìru,
podobnì jako tomu bylo s&nbsp;instrukcí <strong>CLOSURE</strong>
v&nbsp;bajtkódu Lua VM:</p>

<pre>
<strong>dummyAdder</strong>():
 13           0 LOAD_CLOSURE             0 (delta)     <i>// pøíprava na navázání promìnné k uzávìru</i>
              3 BUILD_TUPLE              1
                                                       <i>// nyní se naète bajktód ji¾ pøelo¾ené vnitøní funkce</i>
              6 LOAD_CONST               1 (code object add at 0xb77125c0, file "Test34.py", line 13)
              9 MAKE_CLOSURE             0             <i>// vytvoøit uzávìr a ulo¾it referenci na nìj na TOS</i>
             12 STORE_FAST               1 (add)       <i>// referenci takté¾ do promìnné <strong>add</strong></i>
&nbsp;
 15          15 LOAD_FAST                1 (add)       <i>// na TOS ulo¾it referenci na uzávìr z&nbsp;promìnné <strong>add</strong></i>
             18 RETURN_VALUE                           <i>// vrátit tuto referenci</i> 
</pre>

<p>Samotné volání vytvoøeného uzávìru ji¾ není vùbec slo¾ité, uzávìry se toti¾
v&nbsp;tomto ohledu chovají jako bì¾né funkce:</p>

<pre>
<strong>main</strong>():
 23           0 LOAD_GLOBAL              0 (dummyAdder)<i>// pøíprava na volání funkce <strong>dummyAdder</strong></i>
              3 LOAD_CONST               1 (0)         <i>// na TOS ulo¾it konstantu 0</i>
              6 CALL_FUNCTION            1             <i>// zavolat funkci <strong>dummyAdder()</strong> s jedním parametrem</i>
              9 STORE_FAST               0 (adder1)    <i>// ulo¾it vrácený uzávìr do lokální promìnné</i>
&nbsp;
 24          12 LOAD_GLOBAL              0 (dummyAdder)<i>// pøíprava na volání funkce <strong>dummyAdder</strong></i>
             15 LOAD_CONST               2 (42)        <i>// na TOS ulo¾it konstantu 42</i>
             18 CALL_FUNCTION            1             <i>// zavolat funkci <strong>dummyAdder()</strong> s jedním parametrem</i>
             21 STORE_FAST               1 (adder2)    <i>// ulo¾it vrácený uzávìr do lokální promìnné</i>
&nbsp;
 25          24 SETUP_LOOP              74 (to 101)    <i>// pøíprava na provedení programové smyèky</i>
             27 LOAD_GLOBAL              1 (range)     <i>// naètení globální reference na funkci <strong>range()</strong></i>
             30 LOAD_CONST               3 (1)         <i>// první konstanta pøedávaná do funkce <strong>range()</strong></i>
             33 LOAD_CONST               4 (11)        <i>// druhá konstanta pøedávaná do funkce <strong>range()</strong></i>
             36 CALL_FUNCTION            2             <i>// zavolání funkce <strong>range(1, 11)</strong></i>
             39 GET_ITER                               <i>// získání iterátoru vráceného funkcí <strong>range()</strong></i>
&nbsp;
             40 FOR_ITER                57 (to 100)    <i>// zaèátek programové smyèky (vstup do dal¹í iterace)</i>
             43 STORE_FAST               2 (i)         <i>// tato lokální promìnná je poèitadlem smyèky</i>
&nbsp;
 26          46 LOAD_FAST                0 (adder1)    <i>// pøíprava na volání prvního uzávìru</i>
             49 LOAD_FAST                2 (i)         <i>// lokální promìnná i (poèitadlo) bude parametrem uzávìru</i>
             52 CALL_FUNCTION            1             <i>// zavolat uzávìr s jedním parametrem</i>
             55 STORE_FAST               3 (result1)   <i>// ulo¾it výsledek volání do lokální promìnné</i>
&nbsp;
 27          58 LOAD_FAST                1 (adder2)    <i>// pøíprava na volání druhého uzávìru</i>
             61 LOAD_FAST                2 (i)         <i>// lokální promìnná i (poèitadlo) bude parametrem uzávìru</i>
             64 CALL_FUNCTION            1             <i>// zavolat uzávìr s jedním parametrem</i>
             67 STORE_FAST               4 (result2)   <i>// ulo¾it výsledek volání do lokální promìnné</i>
&nbsp;
 28          70 LOAD_CONST               5 ('Iteration #%d')
             73 LOAD_FAST                2 (i)
             76 BINARY_MODULO                          <i>// operátor modulo je zde pou¾it pro formátování výstupu</i>
             77 PRINT_ITEM                             <i>// výpis èísla iterace</i>
             78 PRINT_NEWLINE                          <i>// odøádkování</i>
&nbsp;
 29          79 LOAD_CONST               6 ('    Adder1: %d')
             82 LOAD_FAST                3 (result1)
             85 BINARY_MODULO                          <i>// operátor modulo je zde pou¾it pro formátování výstupu</i>
             86 PRINT_ITEM                             <i>// výpis hodnoty vrácené prvním uzávìrem</i>
             87 PRINT_NEWLINE                          <i>// odøádkování</i>
&nbsp;
 30          88 LOAD_CONST               7 ('    Adder2: %d')
             91 LOAD_FAST                4 (result2)
             94 BINARY_MODULO                          <i>// operátor modulo je zde pou¾it pro formátování výstupu</i>
             95 PRINT_ITEM                             <i>// výpis hodnoty vrácené druhým uzávìrem</i>
             96 PRINT_NEWLINE                          <i>// odøádkování</i>
&nbsp;
             97 JUMP_ABSOLUTE           40             <i>// skok na zaèátek programové smyèky (dal¹í iterace)</i>
&nbsp;
            100 POP_BLOCK                              <i>// úklid zásobníku po provedení smyèky</i>
            101 LOAD_CONST               0 (None)      <i>// ulo¾it konstantu None na zásobník operandù</i>
            104 RETURN_VALUE                           <i>// vrátit tuto konstantu (ulo¾enou na TOS)</i>
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Demonstraèní pøíklad <strong>Test35.py</strong>: nefunkèní implementace èítaèe realizovaného uzávìrem</h2>

<p>Pøipomeòme si, ¾e pøi popisu implementace uzávìrù v&nbsp;programovacím
jazyce Lua jsme se mj.&nbsp;zabývali i následujícím demonstraèním pøíkladem,
v&nbsp;nìm¾ se ve funkci <strong>createCounter()</strong> vytvoøil uzávìr
navázaný na lokální promìnnou této funkce nazvanou <strong>counter</strong>.
Uzávìr mohl jak èíst hodnotu této promìnné, tak ji dokonce mohl bez problémù
modifikovat:</p>

<pre>
<i>--</i>
<i>-- Demonstracni priklad cislo 30.</i>
<i>--</i>
<i>-- Vytvareni a nasledne pouziti uzaveru (closure).</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>-- Vytvoreni a vraceni uzaveru, tj. funkce na niz je navazana</i>
<i>-- externi lokalni promenna - upvalue.</i>
function <strong>createCounter</strong>()
    <i>-- lokalni promenna, jejiz "zivotnost" presahuje</i>
    <i>-- pouhe zavolani a provedeni bloku funkce createCounter()</i>
    local counter = 0
    <i>-- navratovou hodnotou funkce createCounter() je anonymni</i>
    <i>-- funkce pracujici s promennou cnt, ktera je na tuto</i>
    <i>-- anonymni funkci navazana</i>
    return function()
        <i>-- counter se oznacuje jako "externi lokalni promenna"</i>
        <i>-- popr. v terminologii jazyka Lua "upvalue"</i>
        counter = counter + 1
        return counter
    end
end
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Spusteni testu.</i>
<i>--</i>
function <strong>main</strong>()
    <i>-- ziskame "instanci" anonymni funkce i na ni navazanou</i>
    <i>-- externi lokalni promennou "counter"</i>
    <i>-- -&gt; closure</i>
    local mycounter = createCounter()
    print(mycounter())
    print(mycounter())
    print(mycounter())
end
&nbsp;
&nbsp;
&nbsp;
main()
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Finito.</i>
<i>--</i>
</pre>

<p>Pøímý pøepis vý¹e uvedeného demonstraèního pøíkladu do Pythonu by mohl
vypadat následovnì:</p>

<pre>
<i>#</i>
<i># Demonstracni priklad cislo 35.</i>
<i>#</i>
<i># Nefunkcni implementace citace realizovaneho uzaverem.</i>
<i>#</i>
&nbsp;
&nbsp;
&nbsp;
<i>#</i>
<i># Jednoduchy uzaver v Pythonu.</i>
<i>#</i>
def <strong>createCounter</strong>():
    counter = 0
    def <strong>next</strong>():
        counter += 1
        return counter
    return next
&nbsp;
&nbsp;
&nbsp;
<i>#</i>
<i># Spusteni testu.</i>
<i>#</i>
def <strong>main</strong>():
    counter1 = createCounter()
    counter2 = createCounter()
    for i in range(1,11):
        result1 = counter1()
        result2 = counter2()
        print("Iteration #%d" % i)
        print("    Counter1: %d" % result1)
        print("    Counter2: %d" % result2)
&nbsp;
&nbsp;
&nbsp;
<i>#</i>
<i># Ukazka disasembleru.</i>
<i># (prekladu funkci do bajtkodu Python VM).</i>
<i>#</i>
def <strong>disassemble</strong>():
    from dis import dis
&nbsp;
    print("\ncreateCounter():")
    dis(createCounter)
&nbsp;
    print("\nmain():")
    dis(main)
&nbsp;
&nbsp;
&nbsp;
main()
&nbsp;
disassemble()
&nbsp;
<i>#</i>
<i># Finito.</i>
<i>#</i>
</pre>

<p>Ve skuteènosti v¹ak takto naprogramovaný uzávìr nebude funkèní, proto¾e
k&nbsp;vázané promìnné <strong>counter</strong> sice mù¾e uzávìr pøistupovat
pøi ètení, ale nikoli u¾ pøi zápisu (modifikaci). Proè dojde k&nbsp;chybì lze
zjednodu¹enì øeèeno vysvìtlit tak, ¾e interpret Pythonu musí mít informaci o
tom, ¾e promìnná <strong>counter</strong> není interní promìnnou uzávìru, ale
vázanou (tedy nelokální) promìnnou. Z&nbsp;tohoto dùvodu pøi spu¹tìní tohoto
pøíkladu dojde k&nbsp;bìhové výjimce. Proto je zapotøebí dávat pozor na to, ¾e
ne v¹echny uzávìry implementované v&nbsp;programovacích jazycích jakými jsou
Lua èi JavaScript lze bez problémù pøímo pøepsat do Pythonu:</p>

<pre>
Traceback (most recent call last):
  File "Test35.py", line 51, in &lt;module&lt;
    main()
  File "Test35.py", line 28, in main
    result1 = counter1()
  File "Test35.py", line 15, in next
    counter += 1
UnboundLocalError: local variable 'counter' referenced before assignment
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Demonstraèní pøíklad <strong>Test36.py</strong>: funkèní implementace èítaèe realizovaného uzávìrem</h2>

<p>Aby bylo mo¾né vytváøet plnohodnotné uzávìry i v&nbsp;Pythonu, bylo do verze
3.x pøidáno nové klíèové slovo <strong>nonlocal</strong>. Tímto klíèovým slovem
je mo¾né ve vnitøní funkci &ndash; tedy ve vlastním uzávìru &ndash; oznaèit
promìnnou, která nemá být chápána jako promìnná lokální. Ov¹em ve skuteènosti
mù¾eme uzávìr implementující èítaè vytvoøit i v&nbsp;Pythonu 2, a to pomocí
malého triku: namísto skalární (celoèíselné) promìnné se pou¾ije jednorozmìrný
seznam. Zde ji¾ interpret nebude mít problém s&nbsp;rozeznáním lokální promìnné
od promìnné vázané, nebo» význam øádkù <strong>counter += 1</strong> a
<strong>counter[0] += 1</strong> je sémanticky odli¹ný (interpret si je ve
druhém pøípadì jistý, ¾e se nejedná o deklaraci nové lokální promìnné):</p>

<pre>
<i>#</i>
<i># Demonstracni priklad cislo 36.</i>
<i>#</i>
<i># Funkcni implementace citace realizovaneho uzaverem.</i>
<i>#</i>
&nbsp;
&nbsp;
&nbsp;
<i>#</i>
<i># Jednoduchy uzaver v Pythonu.</i>
<i>#</i>
def <strong>createCounter</strong>():
    counter = [0]
    def <strong>next</strong>():
        counter[0] += 1
        return counter[0]
    return next
&nbsp;
&nbsp;
&nbsp;
<i>#</i>
<i># Spusteni testu.</i>
<i>#</i>
def <strong>main</strong>():
    counter1 = createCounter()
    counter2 = createCounter()
    for i in range(1,11):
        result1 = counter1()
        result2 = counter2()
        print("Iteration #%d" % i)
        print("    Counter1: %d" % result1)
        print("    Counter2: %d" % result2)
&nbsp;
&nbsp;
&nbsp;
<i>#</i>
<i># Ukazka disasembleru.</i>
<i># (prekladu funkci do bajtkodu Python VM).</i>
<i>#</i>
def <strong>disassemble</strong>():
    from dis import dis
&nbsp;
    print("\ncreateCounter():")
    dis(createCounter)
&nbsp;
    print("\nmain():")
    dis(main)
&nbsp;
&nbsp;
&nbsp;
main()
&nbsp;
disassemble()
&nbsp;
<i>#</i>
<i># Finito.</i>
<i>#</i>
</pre>

<p>Z&nbsp;následujícího výpisu je patrné, ¾e tento demonstraèní pøíklad
skuteènì funguje, a to i v&nbsp;Pythonu 2:</p>

<pre>
Iteration #1
    Counter1: 1
    Counter2: 1
Iteration #2
    Counter1: 2
    Counter2: 2
Iteration #3
    Counter1: 3
    Counter2: 3
Iteration #4
    Counter1: 4
    Counter2: 4
Iteration #5
    Counter1: 5
    Counter2: 5
Iteration #6
    Counter1: 6
    Counter2: 6
Iteration #7
    Counter1: 7
    Counter2: 7
Iteration #8
    Counter1: 8
    Counter2: 8
Iteration #9
    Counter1: 9
    Counter2: 9
Iteration #10
    Counter1: 10
    Counter2: 10
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Pøeklad demonstraèního pøíkladu <strong>Test36.py</strong> do bajtkódu Python VM</h2>

<p>Funkce <strong>createCounter()</strong>, která vytvoøí nyní ji¾ funkèní
èítaè tvoøený uzávìrem s&nbsp;jednou vázanou promìnnou, se pøelo¾í do bajtkódu
virtuálního stroje programovacího jazyka Python následujícím zpùsobem:</p>

<pre>
<strong>createCounter</strong>():
 13           0 LOAD_CONST               1 (0)         <i>// první (a jediný) prvek seznamu má hodnotu 0</i>
              3 BUILD_LIST               1             <i>// vytvoøit seznam o velikosti jednoho prvku</i>
              6 STORE_DEREF              0 (counter)   <i>// ulo¾it seznam</i>
&nbsp;
 14           9 LOAD_CLOSURE             0 (counter)   <i>// pøíprava na navázání promìnné k uzávìru</i>
             12 BUILD_TUPLE              1
                                                       <i>// nyní se naète bajktód ji¾ pøelo¾ené vnitøní funkce</i>
             15 LOAD_CONST               2 (code object next at 0xb77175c0, file "Test36.py", line 14)
             18 MAKE_CLOSURE             0             <i>// vytvoøit uzávìr a ulo¾it referenci na nìj na TOS</i>
             21 STORE_FAST               0 (next)      <i>// na TOS ulo¾it referenci na uzávìr z&nbsp;promìnné <strong>add</strong></i>
&nbsp;
 17          24 LOAD_FAST                0 (next)      <i>// na TOS ulo¾it referenci na uzávìr z&nbsp;promìnné <strong>next</strong></i>
             27 RETURN_VALUE                           <i>// vrátit tuto referenci</i> 
</pre>

<p>Samotné volání vytvoøeného uzávìru se podobá volání, s&nbsp;ním¾ jsme se
setkali ji¾ v&nbsp;pøedchozích kapitolách:</p>

<pre>
<strong>main</strong>():
 25           0 LOAD_GLOBAL              0 (createCounter)<i>// pøíprava na volání funkce <strong>createCounter</strong></i>
              3 CALL_FUNCTION            0             <i>// zavolat funkci <strong>createCounter()</strong> bez parametrù</i>
              6 STORE_FAST               0 (counter1)  <i>// ulo¾it vrácený uzávìr do lokální promìnné</i>
&nbsp;
 26           9 LOAD_GLOBAL              0 (createCounter)<i>// pøíprava na volání funkce <strong>createCounter</strong></i>
             12 CALL_FUNCTION            0             <i>// zavolat funkci <strong>createCounter()</strong> bez parametrù</i>
             15 STORE_FAST               1 (counter2)  <i>// ulo¾it vrácený uzávìr do lokální promìnné</i>
&nbsp;
 27          18 SETUP_LOOP              68 (to 89)     <i>// pøíprava na provedení programové smyèky</i>
             21 LOAD_GLOBAL              1 (range)     <i>// naètení globální reference na funkci <strong>range()</strong></i>
             24 LOAD_CONST               1 (1)         <i>// první konstanta pøedávaná do funkce <strong>range()</strong></i>
             27 LOAD_CONST               2 (11)        <i>// druhá konstanta pøedávaná do funkce <strong>range()</strong></i>
             30 CALL_FUNCTION            2             <i>// zavolání funkce <strong>range(1, 11)</strong></i>
             33 GET_ITER                               <i>// získání iterátoru vráceného funkcí <strong>range()</strong></i>
&nbsp;
             34 FOR_ITER                51 (to 88)     <i>// zaèátek programové smyèky (vstup do dal¹í iterace)</i>
             37 STORE_FAST               2 (i)         <i>// tato lokální promìnná je poèitadlem smyèky</i>
&nbsp;
 28          40 LOAD_FAST                0 (counter1)  <i>// pøíprava na volání prvního uzávìru</i>
             43 CALL_FUNCTION            0             <i>// zavolat uzávìr bez pøedání parametrù</i>
             46 STORE_FAST               3 (result1)   <i>// ulo¾it výsledek volání do lokální promìnné</i>
&nbsp;
 29          49 LOAD_FAST                1 (counter2)  <i>// pøíprava na volání prvního uzávìru</i>
             52 CALL_FUNCTION            0             <i>// zavolat uzávìr bez pøedání parametrù</i>
             55 STORE_FAST               4 (result2)   <i>// ulo¾it výsledek volání do lokální promìnné</i>
&nbsp;
 30          58 LOAD_CONST               3 ('Iteration #%d')
             61 LOAD_FAST                2 (i)
             64 BINARY_MODULO                          <i>// operátor modulo je zde pou¾it pro formátování výstupu</i>
             65 PRINT_ITEM                             <i>// výpis èísla iterace</i>
             66 PRINT_NEWLINE                          <i>// odøádkování</i>
&nbsp;
 31          67 LOAD_CONST               4 ('    Counter1: %d')
             70 LOAD_FAST                3 (result1)
             73 BINARY_MODULO                          <i>// operátor modulo je zde pou¾it pro formátování výstupu</i>
             74 PRINT_ITEM                             <i>// výpis hodnoty vrácené prvním uzávìrem</i>
             75 PRINT_NEWLINE                          <i>// odøádkování</i>
&nbsp;
 32          76 LOAD_CONST               5 ('    Counter2: %d')
             79 LOAD_FAST                4 (result2)
             82 BINARY_MODULO                          <i>// operátor modulo je zde pou¾it pro formátování výstupu</i>
             83 PRINT_ITEM                             <i>// výpis hodnoty vrácené druhým uzávìrem</i>
             84 PRINT_NEWLINE                          <i>// odøádkování</i>
&nbsp;
             85 JUMP_ABSOLUTE           34             <i>// skok na zaèátek programové smyèky (dal¹í iterace)</i>
&nbsp;
             88 POP_BLOCK                              <i>// úklid zásobníku po provedení smyèky</i>
             89 LOAD_CONST               0 (None)      <i>// ulo¾it konstantu None na zásobník operandù</i>
             92 RETURN_VALUE                           <i>// vrátit tuto konstantu (ulo¾enou na TOS)</i>
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Repositáø se zdrojovými kódy v¹ech pìti dne¹ních demonstraèních pøíkladù</h2>

<p>V¹ech pìt dnes popsaných a &bdquo;disasemblovaných&ldquo; demonstraèních
pøíkladù bylo ulo¾eno do Mercurial repositáøe umístìného na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
Odkazy na prozatím poslední verze tìchto pìti pøíkladù naleznete v&nbsp;tabulce
umístìné pod tímto odstavcem:</p>

<table>
<tr><th>#</th><th>Zdrojový kód</th><th>Umístìní</th></tr>
<tr><td>1</td><td>Test32.py</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/83b435bb6c0f/bytecode/Python/Test32.py">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/83b435bb6c0f/bytecode/Python/Test32.py</a></td></tr>
<tr><td>2</td><td>Test33.py</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/83b435bb6c0f/bytecode/Python/Test33.py">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/83b435bb6c0f/bytecode/Python/Test33.py</a></td></tr>
<tr><td>3</td><td>Test34.py</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/280bfaac435f/bytecode/Python/Test34.py">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/280bfaac435f/bytecode/Python/Test34.py</a></td></tr>
<tr><td>4</td><td>Test35.py</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/280bfaac435f/bytecode/Python/Test35.py">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/280bfaac435f/bytecode/Python/Test35.py</a></td></tr>
<tr><td>5</td><td>Test36.py</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/280bfaac435f/bytecode/Python/Test36.py">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/280bfaac435f/bytecode/Python/Test36.py</a></td></tr>
</table>



<p><a name="k13"></a></p>
<h2 id="k13">13. Generátory a uzávìry &ndash; rozdíly mezi jazyky Lua a Python</h2>

<p>V&nbsp;programovacím jazyce <i>Lua</i> není podpora pro práci
s&nbsp;<i>koprogramy</i> implementována formou speciální syntaktické konstrukce
jazyka tak, jako je tomu v&nbsp;nìkterých dal¹ích programovacích jazycích
implementujících koprogramy (neexistuje zde napøíklad klíèové slovo pro
pøeru¹ení práce koprogramu, zatímco tøeba Python pro podobnou èinnost rezervuje
slovo <strong>yield</strong>, viz pøedchozí kapitoly), ale &ndash; jak se ji¾
v&nbsp;<i>Lua</i> stalo dobrým zvykem &ndash; je v¹e øe¹eno pomocí funkcí a
asociativních polí. Samotný koprogram je ve své podstatì pojmenovaná èi
anonymní funkce s&nbsp;vlastním zásobníkem, který je oddìlený od zásobníku
volajícího programu. Pro vytváøení, øízení a zji¹»ování stavù koprogramù lze
vyu¾ít ¹est funkcí le¾ících v&nbsp;prostoru jmen nazvaném
<strong>coroutine</strong> (prostor jmen není nic jiného ne¾ takto pojmenované
globální asociativní pole se ¹esti &bdquo;veøejnými&ldquo; funkcemi a nìkolika
pomocnými atributy), jejich¾ význam je uveden v&nbsp;následující tabulce.:</p>

<table>
<tr><th>Název funkce</th><th>Význam</th></tr>
<tr><td>coroutine.create() </td><td>vytvoøení koprogramu</td></tr>
<tr><td>coroutine.resume() </td><td>spu¹tìní èi znovuspu¹tìní koprogramu</td></tr>
<tr><td>coroutine.running()</td><td>funkce vrátí právì bì¾ící koprogram (pro hlavní vlákno se vrací <strong>nil</strong>)</td></tr>
<tr><td>coroutine.status() </td><td>funkce vrátí aktuální stav koprogramu &ndash; zda bì¾í, je pozastaven èi zda je bìh koprogramu ji¾ ukonèen</td></tr>
<tr><td>coroutine.wrap()   </td><td>vytvoøení koprogramu, vrací se funkce, která koprogram spustí</td></tr>
<tr><td>coroutine.yield()  </td><td>pozastavení koprogramu a pøípadný pøenos parametrù volajícímu programu</td></tr>
</table>

<p>Na závìr se je¹tì pokusme popsat spoleèné vlastnosti a rozdíly mezi
programovacími jazyky Lua a Python v&nbsp;oblasti generátorù a uzávìrù:</p>

<table>
<tr><th> #</th><th>Vlastnost</th><th>Lua</th><th>Python</th></tr>
<tr><td> 1</td><td>podpora uzávìrù v jazyku</td><td>ano</td><td>ano</td></tr>
<tr><td> 2</td><td>podpora anonymních funkcí</td><td>ano</td><td>s omezeními</td></tr>
<tr><td> 3</td><td>funkce je plnohodnotný datový typ</td><td>ano</td><td>ano</td></tr>
<tr><td> 4</td><td>podpora uzávìrù v bajtkódu</td><td>ano</td><td>ano</td></tr>
<tr><td> 5</td><td>vázané &bdquo;lokální externí promìnné&ldquo;</td><td>ano</td><td>Python 2: omezení, Python 3: ano</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>podpora koprogramù/generátorù v jazyku</td><td>ano (pøes funkce)</td><td>ano</td></tr>
<tr><td> 7</td><td>pozastavení koprogramu s návratovou hodnotou</td><td>coroutine.yield(value)</td><td>yield value</td></tr>
<tr><td> 8</td><td>podpora koprogramù/generátorù v bajtkódu</td><td>ne</td><td>ano</td></tr>
</table>

<p>(je¹tì &bdquo;politicky slo¾itìj¹í&ldquo; situace nastane pøi porovnání
s&nbsp;programovacím jazykem Java a pøedev¹ím s&nbsp;bajtkódem JVM).</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Python Byte Code Instructions<br />
<a href="https://docs.python.org/release/2.5.2/lib/bytecodes.html">https://docs.python.org/release/2.5.2/lib/bytecodes.html</a>
</li>

<li>Python 2.x: funkce range()<br />
<a href="https://docs.python.org/2/library/functions.html#range">https://docs.python.org/2/library/functions.html#range</a>
</li>

<li>Python 2.x: typ iterátor<br />
<a href="https://docs.python.org/2/library/stdtypes.html#iterator-types">https://docs.python.org/2/library/stdtypes.html#iterator-types</a>
</li>

<li>Python break, continue and pass Statements<br />
<a href="http://www.tutorialspoint.com/python/python_loop_control.htm">http://www.tutorialspoint.com/python/python_loop_control.htm</a>
</li>

<li>Python Bytecode: Fun With Dis<br />
<a href="http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/">http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/</a>
</li>

<li>Python's Innards: Hello, ceval.c!<br />
<a href="http://tech.blog.aknin.name/category/my-projects/pythons-innards/">http://tech.blog.aknin.name/category/my-projects/pythons-innards/</a>
</li>

<li>Byterun<br />
<a href="https://github.com/nedbat/byterun">https://github.com/nedbat/byterun</a>
</li>

<li>Python Byte Code Instructions<br />
<a href="http://document.ihg.uni-duisburg.de/Documentation/Python/lib/node56.html">http://document.ihg.uni-duisburg.de/Documentation/Python/lib/node56.html</a>
</li>

<li>Python Byte Code Instructions<br />
<a href="https://docs.python.org/3.2/library/dis.html#python-bytecode-instructions">https://docs.python.org/3.2/library/dis.html#python-bytecode-instructions</a>
</li>

<li>dis - Python module<br />
<a href="https://docs.python.org/2/library/dis.html">https://docs.python.org/2/library/dis.html</a>
</li>

<li>Comparison of Python virtual machines<br />
<a href="http://polishlinux.org/apps/cli/comparison-of-python-virtual-machines/">http://polishlinux.org/apps/cli/comparison-of-python-virtual-machines/</a>
</li>

<li>Lambda the Ultimate: Coroutines in Lua,<br />
<a href="http://lambda-the-ultimate.org/node/438">http://lambda-the-ultimate.org/node/438</a>
</li>

<li>Coroutines Tutorial,<br />
<a href="http://lua-users.org/wiki/CoroutinesTutorial">http://lua-users.org/wiki/CoroutinesTutorial</a>
</li>

<li>Lua Coroutines Versus Python Generators,<br />
<a href="http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators">http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators</a>
</li>

<li>Programming in Lua 9.1 &ndash; Coroutine Basics,<br />
<a href="http://www.lua.org/pil/9.1.html">http://www.lua.org/pil/9.1.html</a>
</li>

<li>Wikipedia CZ: Koprogram,<br />
<a href="http://cs.wikipedia.org/wiki/Koprogram">http://cs.wikipedia.org/wiki/Koprogram</a>
</li>

<li>Wikipedia EN: Coroutine,<br />
<a href="http://en.wikipedia.org/wiki/Coroutine">http://en.wikipedia.org/wiki/Coroutine</a>
</li>

<li>Programming in Lua (first edition)<br />
<a href="http://www.lua.org/pil/contents.html">http://www.lua.org/pil/contents.html</a>
</li>

<li>Programming in Lua: 6 - More about Functions<br />
<a href="http://www.lua.org/pil/6.html">http://www.lua.org/pil/6.html</a>
</li>

<li>Lua Lanes,<br />
<a href="http://kotisivu.dnainternet.net/askok/bin/lanes/">http://kotisivu.dnainternet.net/askok/bin/lanes/</a>
</li>

<li>Programming in Lua: 6.1 - Closures<br />
<a href="http://www.lua.org/pil/6.1.html">http://www.lua.org/pil/6.1.html</a>
</li>

<li>Programming in Lua: 9.1 - Coroutine Basics<br />
<a href="http://www.lua.org/pil/9.1.html">http://www.lua.org/pil/9.1.html</a>
</li>

<li>Programming in Lua: Numeric for<br />
<a href="http://www.lua.org/pil/4.3.4.html">http://www.lua.org/pil/4.3.4.html</a>
</li>

<li>Programming in Lua: break and return<br />
<a href="http://www.lua.org/pil/4.4.html">http://www.lua.org/pil/4.4.html</a>
</li>

<li>Programming in Lua: Tables<br />
<a href="http://www.lua.org/pil/2.5.html">http://www.lua.org/pil/2.5.html</a>
</li>

<li>Programming in Lua: Table Constructors<br />
<a href="http://www.lua.org/pil/3.6.html">http://www.lua.org/pil/3.6.html</a>
</li>

<li>Programovací jazyk Lua<br />
<a href="http://palmknihy.cz/web/kniha/programovaci-jazyk-lua-12651.htm">http://palmknihy.cz/web/kniha/programovaci-jazyk-lua-12651.htm</a>
</li>

<li>Lua: Tables Tutorial<br />
<a href="http://lua-users.org/wiki/TablesTutorial">http://lua-users.org/wiki/TablesTutorial</a>
</li>

<li>Lua: Control Structure Tutorial<br />
<a href="http://lua-users.org/wiki/ControlStructureTutorial">http://lua-users.org/wiki/ControlStructureTutorial</a>
</li>

<li>Lua Types Tutorial<br />
<a href="http://lua-users.org/wiki/LuaTypesTutorial">http://lua-users.org/wiki/LuaTypesTutorial</a>
</li>

<li>Goto Statement in Lua<br />
<a href="http://lua-users.org/wiki/GotoStatement">http://lua-users.org/wiki/GotoStatement</a>
</li>

<li>Lua 5.2 sources<br />
<a href="http://www.lua.org/source/5.2/">http://www.lua.org/source/5.2/</a>
</li>

<li>Lua 5.2 sources - lopcodes.h<br />
<a href="http://www.lua.org/source/5.2/lopcodes.h.html">http://www.lua.org/source/5.2/lopcodes.h.html</a>
</li>

<li>Lua 5.2 sources - lopcodes.c<br />
<a href="http://www.lua.org/source/5.2/lopcodes.c.html">http://www.lua.org/source/5.2/lopcodes.c.html</a>
</li>

<li>For-each Loop in Java<br />
<a href="http://www.leepoint.net/notes-java/flow/loops/foreach.html">http://www.leepoint.net/notes-java/flow/loops/foreach.html</a>
</li>

<li>For Loop (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/For_loop">http://en.wikipedia.org/wiki/For_loop</a>
</li>

<li>Heinz Rutishauser<br />
<a href="http://en.wikipedia.org/wiki/Heinz_Rutishauser">http://en.wikipedia.org/wiki/Heinz_Rutishauser</a>
</li>

<li>Parrot<br />
<a href="http://www.parrot.org/">http://www.parrot.org/</a>
</li>

<li>Parrot languages<br />
<a href="http://www.parrot.org/languages">http://www.parrot.org/languages</a>
</li>

<li>Parrot Primer<br />
<a href="http://docs.parrot.org/parrot/latest/html/docs/intro.pod.html">http://docs.parrot.org/parrot/latest/html/docs/intro.pod.html</a>
</li>

<li>Parrot Opcodes<br />
<a href="http://docs.parrot.org/parrot/latest/html/ops.html">http://docs.parrot.org/parrot/latest/html/ops.html</a>
</li>

<li>Parrot VM<br />
<a href="http://en.wikibooks.org/wiki/Parrot_Virtual_Machine">http://en.wikibooks.org/wiki/Parrot_Virtual_Machine</a>
</li>

<li>Parrot Assembly Language<br />
<a href="http://www.perl6.org/archive/pdd/pdd06_pasm.html">http://www.perl6.org/archive/pdd/pdd06_pasm.html</a>
</li>

<li>Parrot Reference: Chapter 11 - Perl 6 and Parrot Essentials<br />
<a href="http://oreilly.com/perl/excerpts/perl-6-and-parrot-essentials/parrot-reference.html">http://oreilly.com/perl/excerpts/perl-6-and-parrot-essentials/parrot-reference.html</a>
</li>

<li>O-code<br />
<a href="http://en.wikipedia.org/wiki/O-code_machine">http://en.wikipedia.org/wiki/O-code_machine</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>GC safe-point (or safepoint) and safe-region<br />
<a href="http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html">http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html</a>
</li>

<li>Safepoints in HotSpot JVM<br />
<a href="http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html">http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html</a>
</li>

<li>Java theory and practice: Synchronization optimizations in Mustang<br />
<a href="http://www.ibm.com/developerworks/java/library/j-jtp10185/">http://www.ibm.com/developerworks/java/library/j-jtp10185/</a>
</li>

<li>How to build hsdis<br />
<a href="http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README">http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README</a>
</li>

<li>Java SE 6 Performance White Paper<br />
<a href="http://www.oracle.com/technetwork/java/6-performance-137236.html">http://www.oracle.com/technetwork/java/6-performance-137236.html</a>
</li>

<li>Lukas Stadler's Blog<br />
<a href="http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html">http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html</a>
</li>

<li>How to build hsdis-amd64.dll and hsdis-i386.dll on Windows<br />
<a href="http://dropzone.nfshost.com/hsdis.htm">http://dropzone.nfshost.com/hsdis.htm</a>
</li>

<li>PrintAssembly<br />
<a href="https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly">https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly</a>
</li>

<li>The Java Virtual Machine Specification: 3.14. Synchronization<br />
<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14</a>
</li>

<li>The Java Virtual Machine Specification: 8.3.1.4. volatile Fields<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.4. Memory Model<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.7. Non-atomic Treatment of double and long<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7</a>
</li>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (pøed verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2014</small></p>
</body>
</html>

