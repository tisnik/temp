<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Novinky v&nbsp;JDK 7 aneb mírný pokrok v&nbsp;mezích zákona (1)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Novinky v&nbsp;JDK 7 aneb mírný pokrok v&nbsp;mezích zákona (1)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V tomto èlánku si popí¹eme nìkteré z&nbsp;nových vlastností programovacího jazyka Java i jeho virtuálního stroje, které jsou zaøazeny do chystané verze JDK 7. Nebude se jednat pouze o struèný popis vlastností, proto¾e se kromì zmínky o nových knihovnách, tøídách a rozhraních budeme vìnovat i roz¹íøení syntaxe a sémantiky Javy, a to s&nbsp;ohledem na to, jak se nová syntaxe/sémantika projevuje v&nbsp;generovaném bajtkódu.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Novinky v&nbsp;JDK 7 aneb mírný pokrok v&nbsp;mezích zákona</a></p>
<p><a href="#k02">2. Plán &bdquo;A&ldquo; a plán &bdquo;B&ldquo;</a></p>
<p><a href="#k03">3. Projekt Coin &ndash; roz¹íøení syntaxe a sémantiky Javy</a></p>
<p><a href="#k04">4. Nové mo¾nosti pøi deklaraci numerických konstant</a></p>
<p><a href="#k05">5. Pøíkaz <strong>switch</strong> v&nbsp;JDK 1.0 a¾ JDK 5</a></p>
<p><a href="#k06">6. Rychlý pohled &bdquo;pod kapotu&ldquo; JDK</a></p>
<p><a href="#k07">7. Pou¾ití øetìzcù v&nbsp;pøíkazu <strong>switch</strong></a></p>
<p><a href="#k08">8. Struktura generovaného bajtkódu pøi pou¾ití øetìzcù v&nbsp;pøíkazu <strong>switch</strong></a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2>1. Novinky v&nbsp;JDK 7 aneb mírný pokrok v&nbsp;mezích zákona</h2>

<p>Specifikace programovacího jazyka <i>Java</i> i jeho virtuálního stroje se
postupnì vyvíjí spoleènì s&nbsp;tím, jak se roz¹iøují jak mo¾nosti poèítaèù a
dal¹ích programovacích jazykù, tak i zpùsoby nasazení <i>Javy</i> v&nbsp;praxi.
V&nbsp;roce 1996 firma <i>Sun Microsystems</i> zveøejnila první verzi <i>JDK
1.0</i> a ve verzích následujících docházelo k&nbsp;postupnému roz¹iøování a
vylep¹ování syntaxe a sémantiky tohoto programovacího jazyka, co¾ se
v&nbsp;nìkterých pøípadech projevilo i na nutnosti zmìny generovaného bajtkódu.
Z&nbsp;vlastností jazyka, které byly postupnì do <i>Javy</i> pøidány, mù¾eme
jmenovat napøíklad vnitøní tøídy a reflexi (<i>JDK 1.0</i>), kolekce (<i>J2SE
1.2</i>), klíèové slovo <strong>assert</strong> (<i>J2SE 1.4</i>), generické
typy, anotace, autoboxing, výètový typ, smyèku typu for-each a variabilní poèet
parametrù metod (<i>J2SE 5.0</i>). Zatímco v&nbsp;následující verzi <i>Java SE
6</i> se mnoho zmìn neobjevilo, jinak je tomu u specifikace <i>Java SE 7</i>
implementované v&nbsp;<i>JDK 7</i> a <i>OpenJDK7</i>. Pøi rozhodování o tom,
jaké nové vlastnosti by se mìly v&nbsp;<i>JDK 7</i> projevit, byly do úvahy
brány mj.&nbsp;i kritéria popsaná v&nbsp;následujícím textu.</p>

<p>Hlavní prioritou pøi posuzování vhodnosti èi nevhodnosti jednotlivých zmìn
byla jasnost a srozumitelnost zdrojových kódù vytváøených v&nbsp;Javì. To je na
první pohled rozumné kritérium, ov¹em nìkteré u¾iteèné, ale na první pohled ne
zcela jasné nebo jen pro javisty neobvyklé konstrukce, nakonec nebyly do Javy zaøazeny.
Napøíklad i pøes existenci autoboxingu (<i>JDK 5</i>) stále nelze zapsat
<strong>1.toString()</strong>, ale jen
<strong>((Integer)1).toString()</strong>, <strong>new
Integer(1).toString()</strong> nebo lépe
<strong>Integer.valueOf(1).toString()</strong>. Druhým kritériem braným
v&nbsp;úvahu bylo, ¾e ètení pøehledného kódu je dùle¾itìj¹í ne¾ jeho snadný a
úsporný zápis, co¾ mj.&nbsp;znamená, ¾e <i>Java</i> je pomìrnì
&bdquo;ukecaný&ldquo; jazyk: napøíklad settery a gettery je &ndash; alespoò
prozatím &ndash; nutné psát explicitnì namísto pou¾ití dekorátorù èi anotací;
podmínku, zda je nìjaká reference rovna <strong>null</strong>, je nutné takté¾
psát explicitnì atd. Jiné programovací jazyky mají i odli¹né priority a jsou
smìrovány k&nbsp;jiným typùm aplikací. Dobrým pøíkladem mù¾e být <i>Perl</i>
s&nbsp;mnoha &bdquo;magickými&ldquo; promìnnými a úsporným zápisem.</p>



<p><a name="k02"></a></p>
<h2>2. Plán &bdquo;A&ldquo; a plán &bdquo;B&ldquo;</h2>

<p>Pùvodní návrhy pro nové vlastnosti <i>JDK 7</i> byly vytvoøeny je¹tì ve
firmì <i>Sun Microsystems</i>. Mìlo se jednat o doslova revoluèní verzi
<i>JDK</i>, v&nbsp;ní¾ se mìly do programovacího jazyka <i>Java</i> dostat
konstrukce známé spí¹e z&nbsp;funkcionálních programovacích jazykù (napøíklad
lambda výrazy, ov¹em typované!); z&nbsp;<i>JVM</i> se mìla stát universální
platforma pro mnoho dal¹ích, vìt¹inou dynamicky typovaných programovacích
jazykù atd. Ov¹em celý vývoj <i>JDK 7</i> se dostal do èasového skluzu, co¾ je
ostatnì u¾ u mnoha velkých projektù spí¹e pravidlem ne¾ výjimkou ;-). Navíc
mezitím firma <i>Sun</i> otevøela cca 95% svého <i>JDK</i> pod názvem
<i>OpenJDK</i> a o nìjaký èas pozdìji do¹lo k&nbsp;pøevzetí firmy <i>Sun
Microsystems</i> firmou <i>Oracle</i>, tak¾e se ponìkud zmìnily priority vývoje
(nejenom) <i>JDK 7</i>. Výsledkem v¹ech tìchto skuteèností bylo sestavení dvou
plánù: plánu &bdquo;A&ldquo; a plánu &bdquo;B&ldquo;, s&nbsp;tím, ¾e se po
zralé úvaze rozhodne, který z&nbsp;plánù bude uskuteènìn.</p>

<p>V&nbsp;plánu &bdquo;A&ldquo; se poèítalo s&nbsp;tím, ¾e se vydá
&bdquo;revoluèní&ldquo; <i>JDK 7</i> s&nbsp;velkým mno¾stvím zmìn, ov¹em a¾
v&nbsp;roce 2012, co¾ je velký èasový skluz. Pøednosti tohoto plánu spoèívají
v&nbsp;tom, ¾e se poèet dostupných verzí podporovaných <i>JDK</i> nebude pøíli¹
zvy¹ovat, ov¹em velkou nevýhodou je ji¾ zmínìný èasový skluz. Naproti tomu se
v&nbsp;plánu &bdquo;B&ldquo; vývoj <i>JDK 7</i> rozdìlil na <i>JDK 7</i>, které
má být dokonèené ji¾ v&nbsp;polovinì pøí¹tího roku a na <i>JDK 8</i>, které by
snad mohlo být k&nbsp;dispozici na konci roku 2012. Pøedností tohoto plánu je
to, ¾e vývojáøi budou moci ji¾ pøí¹tí rok vyu¾ít nìkteré z&nbsp;nových (ji¾
implementovaných a otestovaných) vlastností <i>JDK 7</i>, ov¹em nevýhoda
spoèívá ve vìt¹í fragmentaci <i>JDK</i> a jejich podpory: zatímco dnes se stále
je¹tì pomìrnì èasto pou¾ívá verze 1.4.2 a samozøejmì té¾ 5.0 a 6.0, bylo by to
v&nbsp;roce 2012 hned pìt rùzných verzí <i>JDK</i> (podpora pro 1.4.2 a 5.0
sice teoreticky vypr¹í, ale mnoho firem nemù¾e z&nbsp;rùzných dùvodù na novou
verzi ihned pøejít). Dá se tedy poèítat s&nbsp;tím, ¾e <i>JDK 7</i> nebude
pøijato v¹emi vývojáøi, proto¾e si mnozí radìji poèkají a¾ na <i>JDK 8</i>.</p>



<p><a name="k03"></a></p>
<h2>3. Projekt Coin &ndash; roz¹íøení syntaxe a sémantiky Javy</h2>

<p>Na leto¹ní konferenci <i>JavaOne</i> bylo prezentováno rozhodnutí o dal¹ím
vývoji <i>JDK 7</i> &ndash; nakonec zvítìzil plán &bdquo;B&ldquo;. Nové
vlastnosti <i>JDK</i> tedy byly rozdìleny do dvou mno¾in, z&nbsp;nich¾ první
bude (v&nbsp;podstatì ji¾ je) implementována v&nbsp;<i>JDK 7</i> a druhá a¾
v&nbsp;<i>JDK 8</i> o dva roky pozdìji. V&nbsp;novinkách, které budou
v&nbsp;<i>JDK 7</i>, je zahrnuta napøíklad podpora pro dynamicky typované
jazyky bì¾ící v&nbsp;JVM (nová instrukce v&nbsp;bajtkódu), èást projektu
<i>Coin</i> (zmìna syntaxe a sémantiky jazyka), roz¹íøení NIO.2, podpora
XRender Graphics Pipeline operacemi implementovanými v&nbsp;Java 2D
(s&nbsp;èím¾ souvisí i nárùst výkonu nìkterých grafických operací, co¾ si
øekneme pøí¹tì), projekt <i>Nimbus</i> pro Swingové aplikace (takté¾ bude
popsáno pøí¹tì), zahrnutí nových verzí TLS 1.2 a JDBC 4.1, podpora pro Unicode
6.0 atd. Pro bì¾né programátory budou asi nejviditelnìj¹í zmìny, které jsou
implementovány v&nbsp;rámci vý¹e zmínìného projektu <i>Coin</i>.</p>

<p>Jedná se o projekt, který do programovacího jazyka Java vná¹í malé, ale o to
pøíjemnìj¹í zmìny v&nbsp;syntaxi a sémantice. V&nbsp;nìkterých pøípadech se
jedná o pouhý &bdquo;syntaktický cukr&ldquo;, ale na dal¹í vlastnosti èekali
programátoøi mnohdy i nìkolik let. Zajímavé je, ¾e i pøes roz¹íøení syntaxe
jazyka Java nebylo nutné v&nbsp;rámci projektu <i>Coin</i> pøidat do tohoto
programovacího jazyka ¾ádné nové klíèové slovo a takté¾ se nemusel roz¹iøovat
bajtkód o dal¹í instrukce. Mezi nové prvky Javy, které projekt <i>Coin</i>
pøiná¹í ji¾ do <i>JDK 7</i> (v&nbsp;<i>JDK 8</i> je tìchto prvkù mnohem více),
patøí pøedev¹ím:</p>

<ul>
<li>Deklarace celoèíselných binárních konstant</li>
<li>Pou¾ití podtr¾ítka pro lep¹í èitelnost numerických konstant</li>
<li>Pøíkaz switch a øetìzce</li>
<li>&bdquo;Diamant&ldquo; &ndash; zjednodu¹ený zápis deklarací pøi pou¾ití generik</li>
<li>Automatic Resource Management (ARM) &ndash; automatické volání metody <strong>close</strong> v&nbsp;rámci roz¹íøeného bloku <strong>try</strong></li>
<li>Vylep¹ené zpracování výjimek</li>
</ul>

<p>První tøi roz¹íøení budou popsána v&nbsp;dal¹ích kapitolách, zbylé tøi
roz¹íøení a¾ v&nbsp;navazujícím èlánku.</p>



<p><a name="k04"></a></p>
<h2>4. Nové mo¾nosti pøi deklaraci numerických konstant</h2>

<p>Mezi jedno z&nbsp;nejjednodu¹¹ích roz¹íøení, které ji¾ byly v&nbsp;rámci
projektu <i>Coin</i> implementovány, patøí podpora pro zápis binárních
numerických konstant, tj.&nbsp;èísel ve dvojkové soustavì. <i>Java</i> toti¾
pøevzala z&nbsp;programovacího jazyka <i>C</i> a <i>C++</i> zpùsob zápisu
konstant v&nbsp;osmièkové a ¹estnáctkové soustavì, ale doposud neexistovala
mo¾nost pou¾ití soustavy dvojkové (to se hodí napøíklad pøi nízkoúrovòové práci
s&nbsp;bitovými pøíznaky a novì také napøíklad pøi zápisu masek v&nbsp;IPv6).
Syntaxe je velmi jednoduchá &ndash; èísla v&nbsp;osmièkové soustavì zaèínají na
<strong>0</strong>, v&nbsp;soustavì ¹estnáctkové na <strong>0x</strong> a
v&nbsp;soustavì binární, jak ji¾ asi ètenáø uhodl, na <strong>0b</strong>. Novì
je takté¾ mo¾né, aby se pøi zápisu celých i reálných èísel, bez ohledu na
pou¾itý základ èíselné soustavy, mohly jednotlivé øády oddìlovat podtr¾ítkem.
To, kde a zda vùbec bude podtr¾ítko pou¾ito, zále¾í pouze na vývojáøi (typicky
se asi budou oddìlovat miliony a tisíce). Obì popsaná roz¹íøení <i>Javy</i>,
které se mimochodem nijak neprojeví na generovaném bajtkódu, si mù¾ete
s&nbsp;<i>(Open)JDK7</i> snadno vyzkou¹et:</p>

<pre>
public class NumericConstants
{
    public static void main(String[] args)
    {
        int  decimal1 = 1234567890;
        int  decimal2 = 1_234_567_890; // oddìlení tisícù, milionù a miliard
        long decimal3 = -99_88_77_66_55_44_33_22_11L;

        // nová mo¾nost - binární èísla
        int  binary1 = 0b01000010;
        long binary2 = 0b0000_0001_0010_0011_0100_0101;

        // ponìkud neobvyklé ale mo¾né - záporné binární hodnoty
        long binary3 = -0b0000_0001_0010_0011_0100_0101;

        int  octal1 = 01234567;
        int  octal2 = 012_34_56_77;
        long octal3 = 0666_555_444_333_222_111L;

        int  hexadecimal1 = 0x12345678;
        int  hexadecimal2 = 0x12_34_56_78;
        long hexadecimal3 = 0x88_77_66_55_44_33_22_11L;

        // podtr¾ítka lze pou¾ít i pøi zápisu reálných konstant
        float f1 = -1_2.3_4f;
        double f2 = -1_2.3_4e10;
        double f3 = -1_2.3_4e1_2_3;

        System.out.println(decimal1);
        System.out.println(decimal2);
        System.out.println(decimal3);
        System.out.println();

        System.out.format("%x\n", binary1);
        System.out.format("%x\n", binary2);
        System.out.format("%x\n", binary3);
        System.out.println();

        System.out.format("%o\n", octal1);
        System.out.format("%o\n", octal2);
        System.out.format("%o\n", octal3);
        System.out.println();

        System.out.format("%x\n", hexadecimal1);
        System.out.format("%x\n", hexadecimal2);
        System.out.format("%x\n", hexadecimal3);
        System.out.println();

        System.out.println(f1);
        System.out.println(f2);
        System.out.println(f3);
    }
}
</pre>



<p><a name="k05"></a></p>
<h2>5. Pøíkaz <strong>switch</strong> v&nbsp;JDK 1.0 a¾ JDK 5</h2>

<p>Mezi mno¾inu nìkolika roz¹íøení syntaxe i sémantiky Javy, které lze
v&nbsp;nové verzi <i>JDK 7</i> pou¾ít, patøí i mo¾nost pou¾ití øetìzcù
v&nbsp;øídicím pøíkazu <strong>switch</strong>. Tato øídicí struktura je
v&nbsp;Javì dostupná od samého poèátku, tj.&nbsp;od <i>JDK 1.0</i> (co¾ je
vlastnì samozøejmé, nebo» byla po mírných úpravách pøevzata z&nbsp;jazykù
<i>C</i> a <i>C++</i>). Ov¹em pùvodnì se jednalo o øídicí strukturu, v&nbsp;ní¾
bylo mo¾né za klíèovým slovem <strong>switch</strong> pou¾ít pouze celoèíselný
výraz a jednotlivé vìtve specifikované klíèovým slovem <strong>case</strong>
mohly obsahovat pouze celoèíselnou konstantu typu <i>byte</i>, <i>short</i> èi
<i>int</i> (nikoli v¹ak <i>long</i>, co¾ je omezení dané strukturou bajtkódu!).
Kromì tìchto tøí datových typù bylo mo¾né pou¾ít i znakový literál, který je
v&nbsp;Javì takté¾ pova¾ován za jinak zapsanou celoèíselnou ¹estnáctibitovou
konstantu typu <i>char</i>. Pøi pøekladu zdrojového kódu je programová
konstrukce vytvoøená s&nbsp;vyu¾itím klíèových slov <strong>switch</strong>,
<strong>case</strong>, <strong>break</strong> a <strong>default</strong>
pøelo¾ena do bajtkódu, v&nbsp;nìm¾ jsou pou¾ity instrukce <i>tableswitch</i>,
popø.&nbsp;<i>lookupswitch</i>, s&nbsp;nimi¾ se setkáme i v&nbsp;dal¹ím
textu.</p>

<p>Konkrétní výbìr jedné z&nbsp;tìchto instrukcí, je¾ se ve vygenerovaném
bajtkódu skuteènì pou¾ije, je proveden v&nbsp;závislosti na tom, která
instrukce je pro daný pøíkaz <strong>switch</strong> vykonána efektivnìji nebo
která je reprezentována krat¹ím bajtkódem (to zále¾í pøedev¹ím na tom, jaké
konstanty jsou uvedeny u jednotlivých vìtví <strong>case</strong>).
V&nbsp;<i>J2SE 5.0</i> byly mo¾nosti øídicí konstrukce <strong>switch</strong>
ve dvou smìrech roz¹íøeny. Kromì primitivních datových typù <i>byte</i>,
<i>short</i>, <i>int</i> a <i>char</i> byla pøidána i podpora pro instance
obalových tøíd tìchto typù, tj.&nbsp;pro instance tøíd <i>Character</i>,
<i>Byte</i>, <i>Short</i> a <i>Integer </i>. Tato podpora samozøejmì souvisí
s&nbsp;autoboxingem a unboxingem, co¾ jsou takté¾ nové vlastnosti <i>J2SE
5.0</i>. Ov¹em mnohem u¾iteènìj¹í bylo roz¹íøení pøíkazu
<strong>switch</strong> o výètový typ (<i>enumeration &ndash; enum</i>), díky
èemu¾ bylo mo¾né mnoho algoritmù zapsat èitelnìj¹ím a takté¾ bezpeènìj¹ím
zpùsobem, proto¾e se z&nbsp;programù mohly odstranit typovì nebezpeèné
&bdquo;magické konstanty&ldquo;.</p>



<p><a name="k06"></a></p>
<h2>6. Rychlý pohled &bdquo;pod kapotu&ldquo; JDK</h2>

<p>Zajímavé je, ¾e syntaktické a sémantické roz¹íøení øídicí konstrukce
<strong>switch</strong> o mo¾nost pou¾ití výètového typu vùbec nevedlo
k&nbsp;nutnosti zmìn v&nbsp;bajtkódu, tj.&nbsp;do bajtkódu nebylo nutné
pøidávat ¾ádné dal¹í typy instrukcí. Pøed provedením rozeskoku s&nbsp;vyu¾itím
instrukce <i>tableswitch</i> nebo <i>lookupswitch</i> se toti¾ internì pro
objekt výètového typu zavolá metoda <i>Enum.ordinal()</i>, která vrátí
ordinální (poøadové) èíslo daného prvku výètového typu. Získání tohoto celého
èísla je velmi snadné, proto¾e instance tøídy odvozené od <strong>Enum</strong>
jsou v&nbsp;celém virtuálním stroji unikátní &ndash; jedná se o jedináèky
neboli <i>singletony</i>. Tento pøístup návrháøù Javy ke v¹em roz¹íøením
jazyka, který je jasnì patrný i ze zmìn provedených v&nbsp;<i>JDK 7</i>, si
mù¾eme ukázat na jednoduchém pøíkladu. Bude nás zajímat, jakým zpùsobem se
pøelo¾í programová konstrukce <strong>switch</strong> pou¾itá
v&nbsp;následujícím zdrojovém kódu:</p>

<pre>
enum T {JEDNA, DVA, TRI}

public class EnumSwitchTest
{
    public static void main(String args[])
    {
        T x=T.DVA;
        int y;
        switch (x)
        {
            case JEDNA:
                y=1;
                break;
            case DVA:
                y=2;
                break;
            case TRI:
                y=3;
                break;
            default:
                y=0;
                break; 
        }
        System.out.println(y);
    }
}
</pre>

<p>Pomocným programem <strong>javap</strong> zavolaným s&nbsp;parametrem
<strong>-c</strong> lze získat bajtkód odpovídající pøedchozí konstrukci (èeské
poznámky jsem samozøejmì dopsal ruènì, podobnì jako jsem pøidal
odøádkování):</p>

<pre>
public static void main(java.lang.String[]);
  Code:

   0:   getstatic       #2; //Field T.DVA:LT;
   3:   astore_1
   4:   getstatic       #3; //Field Test$1.$SwitchMap$T:[I
   7:   aload_1
   8:   invokevirtual   #4; // zde se volá metoda T.ordinal() vracející èíslo 1-3
   11:  iaload
   12:  tableswitch{        // rozhodovací tabulka pro hodnoty 1 a¾ 3
                1: 40;      // skok na instrukci s adresou 40
                2: 45;      // skok na instrukci s adresou 45
                3: 50;      // skok na instrukci s adresou 50
                default: 55 } // skok na instrukci s adresou 55

   40:  iconst_1            // cíl prvního skoku
   41:  istore_2            // ulo¾ení celoèíselné konstanty 1 do lokální promìnné y
   42:  goto    57          // odpovídá break, tj. ukonèení switch

   45:  iconst_2            // cíl druhého skoku
   46:  istore_2            // ulo¾ení celoèíselné konstanty 2 do lokální promìnné y
   47:  goto    57          // odpovídá break, tj. ukonèení switch

   50:  iconst_3            // cíl tøetího skoku
   51:  istore_2            // ulo¾ení celoèíselné konstanty 3 do lokální promìnné y
   52:  goto    57          // odpovídá break, tj. ukonèení switch

   55:  iconst_0            // cíl posledního skoku (default)
   56:  istore_2            // ulo¾ení celoèíselné konstanty 0 do lokální promìnné y
                            // (skok ji¾ není zapotøebí, jsme ji¾ na adrese 57)

   57:  getstatic       #5; //Field java/lang/System.out:Ljava/io/PrintStream;
   60:  iload_2             // naètení hodnoty lokální promìnné y do zásobníku
   61:  invokevirtual   #6; //Method java/io/PrintStream.println:(I)V
   64:  return
}
</pre>



<p><a name="k07"></a></p>
<h2>7. Pou¾ití øetìzcù v&nbsp;pøíkazu <strong>switch</strong></h2>

<p>Nyní se opìt vra»me k&nbsp;ji¾ zmínìné zmìnì sémantiky pøíkazu
<strong>switch</strong> v&nbsp;<i>JDK 7</i>, tj.&nbsp;k&nbsp;zaøazení mo¾nosti
pou¾ít výraz typu øetìzec (pøesnìji øeèeno výraz, který se vyhodnotí na
øetìzec) v&nbsp;rozhodovací èásti tohoto pøíkazu a øetìzcové literály
v&nbsp;jeho jednotlivých vìtvích. Na toto roz¹íøení mnoho vývojáøù èekalo
vlastnì ji¾ od první verze <i>Javy</i>, proto¾e øetìzce jsou v&nbsp;tomto
programovacím jazyku pou¾ity ponìkud chaoticky &ndash; na jednu stranu se
chovají jako dal¹í primitivní datový typ (existence øetìzcového literálu a
operátoru +, který je jinak vyhrazený pro primitivní datové typy), na stranu
druhou jsou øetìzce chápány jako bì¾né objekty, co¾ tøeba znamená, ¾e operátor
== nemusí v¾dy pracovat tak, jak si pøedev¹ím zaèínající programátoøi
v&nbsp;Javì myslí, proto¾e se porovnávají reference objektù nebo øetìzcù ze
<i>string poolu</i>, nikoli samotný obsah øetìzcù. Ostatnì si postaèí vyzkou¹et
následující pøíklad, v&nbsp;nìm¾ se porovnává hodnota naètená z&nbsp;jeho
prvního argumentu (zadaného na pøíkazové øádce) s&nbsp;øetìzcovým literálem
ulo¾eným ve <i>string poolu</i>:</p>

<pre>
public class T
{
    public static void main(String[] args)
    {
        String s = (args.length &lt; 0) ? args[0] : "";
        System.out.println(s);
        System.out.println(s == "ahoj");
        System.out.println("ahoj".equals(s));
        System.out.println("ahoj".compareTo(s));
    }

}
</pre>

<p>Poznámka: øetìzec "ahoj" z&nbsp;pøedchozího pøíkladu je ve <i>string
poolu</i> (jen¾ je mj.&nbsp;souèástí souboru .class) ulo¾en pouze jedenkrát,
proto pro nìj &ndash; a jen pro nìj &ndash; bude operátor == pracovat podobným
zpùsobem, jako pøi porovnávání hodnot primitivních datových typù. Nemo¾nost
pou¾ití øetìzcù v&nbsp;pøíkazu <strong>switch</strong> komplikovala nìkteré
úlohy, napøíklad zpracování parametrù, parsing nìkterých typù souborù
(pøíkladem mohou být soubory typu <i>DXF</i>) atd. Napøíklad pøi psaní funkce,
která pro zadané jméno mìsíce vypoèítá poèet dní v&nbsp;mìsíci, se bì¾nì
pou¾ívá sekvence zøetìzených pøíkazù <strong>if-then</strong> (nejedná se o
jedinou mo¾nost, je samozøejmì mo¾né øetìzec pøevést na hodnotu výètového typu
pomocí metody <i>valueOf</i>, ov¹em pøi pohledu do zdrojových kódù se zdá, ¾e
tuto mo¾nost programátoøi z&nbsp;nìjakého dùvodu pøíli¹ èasto nepou¾ívají):</p>

<pre>
public class StringIfEqualsTest
{
    public static final int YEAR = 2010;

    public static int getDaysOfMonth(String month)
    {
        if (month.equals("April") ||
            month.equals("June") ||
            month.equals("September") ||
            month.equals("November"))
        {
            return 30;
        }
        if (month.equals("January") ||
            month.equals("March") ||
            month.equals("May") ||
            month.equals("July") ||
            month.equals("August") ||
            month.equals("October") ||
            month.equals("December"))
        {
            return 31;
        }
        if (month.equals("February"))
        {
            return YEAR % 4 == 0 &amp;&amp; YEAR % 100 != 0 &amp;&amp; YEAR % 400 == 0 ? 29 : 28;
        }
        else
        {
            throw new RuntimeException("Unknown month name: " + month);
        }
    }

    public static void main(String[] args)
    {
        String[] months = {"January", "February", "March",
                           "April",   "May",      "June",
                           "July",    "August",   "September",
                           "October", "November", "December"};

        for (String month : months)
        {
            int days = getDaysOfMonth(month);
            System.out.format("%-10s\t%d\n", month, days);
        }
    }
}
</pre>

<p>Pøedchozí programový kód, pøesnìji øeèeno funkce <i>getDaysOfMonth()</i>,
v¹ak s&nbsp;sebou pøiná¹í nìkolik problémù. Pøedev¹ím je vlastní logika této
funkce schována za pøemírou volání metod <i>String.equals()</i>, co¾ zajisté
nevede k&nbsp;lep¹í èitelnosti kódu. Co je v¹ak v&nbsp;nìkterých pøípadech
témìø stejnì záva¾né, je zpùsob, jakým je tato funkce provedena. Pøi pohledu do
bajtkódu mù¾eme vidìt, ¾e se ka¾dý èlen výrazu za <strong>if</strong> skuteènì
pøelo¾í do volání metody <strong>String.equals()</strong>, co¾ je pomìrnì
neefektivní. Napøíklad pro mìsíc Únor (February) je metoda
<strong>String.equals()</strong> zavolána dvanáctkrát, co¾ v&nbsp;tomto pøípadì
sice nebude mít ¾ádný velký vliv na výkonnost, ov¹em kdyby byly v¹echny øetìzce
stejnì dlouhé, skuteènì by se provádìlo porovnání znak po znaku (pokud nemají
øetìzce shodnou délku, nemusí se porovnání samozøejmì provádìt &ndash; viz té¾
zdrojové kódy tøídy <strong>String</strong>).</p>

<p>S&nbsp;vyu¾itím nové sémantiky pøíkazu <strong>switch</strong> je v¹ak mo¾né
stejný program napsat mnohem èitelnìji:</p>

<pre>
public class StringSwitchTest
{
    public static final int YEAR = 2010;

    public static int getDaysOfMonth(String month)
    {
        switch (month)
        {
            case "April":
            case "June":
            case "September":
            case "November":
                return 30;
            case "January":
            case "March":
            case "May":
            case "July":
            case "August":
            case "October":
            case "December":
                return 31;
            case "February":
                return YEAR % 4 == 0 &amp;&amp; YEAR % 100 != 0 &amp;&amp; YEAR % 400 == 0 ? 29 : 28;
            default:
                throw new RuntimeException("Unknown month name: " + month);
        }
    }

    public static void main(String[] args)
    {
        String[] months = {"January", "February", "March",
                           "April",   "May",      "June",
                           "July",    "August",   "September",
                           "October", "November", "December"};

        for (String month : months)
        {
            int days = getDaysOfMonth(month);
            System.out.format("%-10s\t%d\n", month, days);
        }
    }
}
</pre>



<p><a name="k08"></a></p>
<h2>8. Struktura generovaného bajtkódu pøi pou¾ití øetìzcù v&nbsp;pøíkazu <strong>switch</strong></h2>

<p>Vra»me se nyní k&nbsp;obìma demonstraèním pøíkladùm. Funkce
<i>getDaysOfMonth()</i> z&nbsp;prvního pøíkladu (pøelo¾itelného i na <i>JDK
1.0</i>) je pøelo¾ena do bajtkódu, z&nbsp;nìho¾ je patrné, ¾e se pøíkazy
<strong>if</strong> s&nbsp;pomìrnì slo¾itými podmínkami pøelo¾ily do sekvence
instrukcí tvoøících &bdquo;¹pagetový kód&ldquo; tvoøený mnoha podmínìnými skoky
<strong>ifeq</strong> (branch if equal) a <strong>ifne</strong> (branch if not
equal):</p>

<pre>
public static int getDaysOfMonth(java.lang.String);
  Code:
   0:   aload_0
   1:   ldc     #2;         //String April
   3:   invokevirtual   #3; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   6:   ifne    36          // vìtvení na základì výsledku metody String.equals()
   9:   aload_0
   10:  ldc     #4;         //String June
   12:  invokevirtual   #3; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   15:  ifne    36          // vìtvení na základì výsledku metody String.equals()
   18:  aload_0
   19:  ldc     #5;         //String September
   21:  invokevirtual   #3; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   24:  ifne    36          // vìtvení na základì výsledku metody String.equals()
   27:  aload_0
   28:  ldc     #6;         //String November
   30:  invokevirtual   #3; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   33:  ifeq    39
   36:  bipush  30          // cíl pøedchozích vìtvení - vrácení hodnoty 30
   38:  ireturn
   39:  aload_0
   40:  ldc     #7; //String January
   42:  invokevirtual   #3; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   45:  ifne    102
   48:  aload_0
   49:  ldc     #8; //String March
   51:  invokevirtual   #3; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   54:  ifne    102
   57:  aload_0
   58:  ldc     #9; //String May
   60:  invokevirtual   #3; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   63:  ifne    102
   66:  aload_0
   67:  ldc     #10; //String July
   69:  invokevirtual   #3; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   72:  ifne    102
   75:  aload_0
   76:  ldc     #11; //String August
   78:  invokevirtual   #3; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   81:  ifne    102
   84:  aload_0
   85:  ldc     #12; //String October
   87:  invokevirtual   #3; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   90:  ifne    102
   93:  aload_0
   94:  ldc     #13; //String December
   96:  invokevirtual   #3; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   99:  ifeq    105
   102: bipush  31
   104: ireturn
   105: aload_0
   106: ldc     #14; //String February
   108: invokevirtual   #3; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   111: ifeq    117
   114: bipush  28
   116: ireturn
</pre>

<p>Naproti tomu pøi ètení bajtkódu druhé funkce pøelo¾ené pomocí <i>JDK 7</i>,
narazíme na pomìrnì velké odli¹nosti. Pøedev¹ím se nejdøíve vypoète otisk
(<i>hash</i>) øetìzce <strong>month</strong> (otiskem je 32bitové celé èíslo).
Tento otisk je pou¾it v&nbsp;instrukci <i>lookupswitch</i> pøi porovnávání
s&nbsp;otisky øetìzcových literálù. Zde je dùle¾ité pøedev¹ím to, ¾e tyto
otisky jsou vypoèteny ji¾ v&nbsp;dobì pøekladu, tj.&nbsp;v&nbsp;dobì bìhu se
jimi ji¾ JVM nemusí zdr¾ovat. Pokud je otisk øetìzce <strong>month</strong>
shodný s&nbsp;otiskem nìjakého literálu, je proveden skok do vìtve, v&nbsp;ní¾
se zavolá metoda <strong>String.equals()</strong>, proto¾e shoda otiskù øetìzcù
samozøejmì nemusí znamenat to, ¾e jsou øetìzce skuteènì identické (jinými slovy
&ndash; pøi he¹ování nutnì dochází ke kolizím). Dùle¾ité je, ¾e se metoda
<strong>String.equals()</strong> zavolá maximálnì jedenkrát (pøesnìji øeèeno
v&nbsp;na¹em pøípadì maximálnì jedenkrát, proto¾e u námi pou¾itých øetìzcových
literálù nedo¹lo ke kolizi), co¾ je dùle¾ité, proto¾e volání metody
<strong>String.equals()</strong> je obecnì mnohem pomalej¹í, ne¾ pouhé
porovnání dvou 32bitových otiskù.</p>

<p>V&nbsp;ka¾dé vìtvi je na zásobník ulo¾ena celoèíselná konstanta, která je
následnì pou¾ita v&nbsp;instrukci <i>tableswitch</i> pro vrácení správné
hodnoty z&nbsp;celé funkce. Výsledný bajtkód je sice ponìkud del¹í, ov¹em je na
druhou stranu proveden mnohem rychleji, a to zejména v&nbsp;pøípadech, kdy
poèet vìtví pøíkazu <strong>switch</strong> roste:</p>

<pre>
public static int getDaysOfMonth(java.lang.String);
  Code:
   0:   aload_0
   1:   astore_1
   2:   iconst_m1
   3:   istore_2
   4:   aload_1
   5:   invokevirtual   #2; //Method java/lang/String.hashCode:()I
   8:   lookupswitch{ //12
                -199248958: 275;  // otisky øetìzcù jednotlivých mìsícù + cílová adresa skoku
                -162006966: 172;
                -25881423: 144;
                77125: 200;
                2320440: 215;
                2320482: 130;
                43165376: 245;
                63478374: 116;
                74113571: 186;
                626483269: 260;
                1703773522: 158;
                1972131363: 230;
                default: 287 }
   116: aload_1
   117: ldc     #3; //String April
   119: invokevirtual   #4; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   122: ifeq    287
   125: iconst_0
   126: istore_2
   127: goto    287
   130: aload_1
   131: ldc     #5; //String June
   133: invokevirtual   #4; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   136: ifeq    287
   139: iconst_1
   140: istore_2
   141: goto    287
   144: aload_1
   145: ldc     #6; //String September
   147: invokevirtual   #4; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   150: ifeq    287
   153: iconst_2
   154: istore_2
   155: goto    287
   158: aload_1
   159: ldc     #7; //String November
   161: invokevirtual   #4; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   164: ifeq    287
   167: iconst_3
   168: istore_2
   169: goto    287
   172: aload_1
   173: ldc     #8; //String January
   175: invokevirtual   #4; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   178: ifeq    287
   181: iconst_4
   182: istore_2
   183: goto    287
   186: aload_1
   187: ldc     #9; //String March
   189: invokevirtual   #4; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   192: ifeq    287
   195: iconst_5
   196: istore_2
   197: goto    287
   200: aload_1
   201: ldc     #10; //String May
   203: invokevirtual   #4; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   206: ifeq    287
   209: bipush  6
   211: istore_2
   212: goto    287
   215: aload_1
   216: ldc     #11; //String July
   218: invokevirtual   #4; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   221: ifeq    287
   224: bipush  7
   226: istore_2
   227: goto    287
   230: aload_1
   231: ldc     #12; //String August
   233: invokevirtual   #4; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   236: ifeq    287
   239: bipush  8
   241: istore_2
   242: goto    287
   245: aload_1
   246: ldc     #13; //String October
   248: invokevirtual   #4; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   251: ifeq    287
   254: bipush  9
   256: istore_2
   257: goto    287
   260: aload_1
   261: ldc     #14; //String December
   263: invokevirtual   #4; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   266: ifeq    287
   269: bipush  10
   271: istore_2
   272: goto    287
   275: aload_1
   276: ldc     #15; //String February
   278: invokevirtual   #4; //Method java/lang/String.equals:(Ljava/lang/Object;)Z
   281: ifeq    287
   284: bipush  11
   286: istore_2
   287: iload_2
   288: tableswitch{ //0 to 11
                0: 352;      // zde ji¾ máme v¹ech 13 cílù skoku: 12 mìsícù + vìtev default
                1: 352;
                2: 352;
                3: 352;
                4: 355;
                5: 355;
                6: 355;
                7: 355;
                8: 355;
                9: 355;
                10: 355;
                11: 358;
                default: 361 }
   352: bipush  30
   354: ireturn
   355: bipush  31
   357: ireturn
   358: bipush  28
   360: ireturn
</pre>



<p><a name="k09"></a></p>
<h2>9. Odkazy na Internetu</h2>

<ol>

<li>OpenJDK Source Releases<br />
<a href="http://download.java.net/openjdk/jdk7/">http://download.java.net/openjdk/jdk7/</a>
</li>

<li>Java Platform, Standard Edition 7 Source Snapshot Releases<br />
<a href="http://download.java.net/jdk7/">http://download.java.net/jdk7/</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2010</small></p>
</body>
</html>

