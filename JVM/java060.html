<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - prùchod hodnotami atributù objektù ulo¾ených na haldì (heapu)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - prùchod hodnotami atributù objektù ulo¾ených na haldì (heapu)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o vlastnostech JVM si øekneme, jak je mo¾né s vyu¾itím JVM TI agenta vypsat hodnoty v¹ech statických a nestatických atributù ulo¾ených na haldì. Zamìøíme se zejména na prùchod atributy základních (primitivních) datových typù, proto¾e ty se zpracovávají odli¹nì od objektových (referenèních) typù.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - prùchod hodnotami atributù objektù ulo¾ených na haldì (heapu)</a></p>
<p><a href="#k02">2. Callback funkce volaná pøi prùchodu hodnotami primitivních datových typù ulo¾ených na haldì</a></p>
<p><a href="#k03">3. Rozli¹ení mezi atributem tøídy (statickým atributem) a atributem objektu (nestatickým atributem)</a></p>
<p><a href="#k04">4. Zji¹tìní typu hodnoty ulo¾ené na haldì</a></p>
<p><a href="#k05">5. Zji¹tìní tøídy, k&nbsp;ní¾ atribut ulo¾ený na haldì pøíslu¹í</a></p>
<p><a href="#k06">6. Demonstraèní agent èíslo 21: výpis atributù pro v¹echny instance tøíd "Foo" a "Bar"</a></p>
<p><a href="#k07">7. Výpoèet obsazení haldy hodnotami primitivních datových typù</a></p>
<p><a href="#k08">8. Tisk v¹ech hodnot nalezených agentem</a></p>
<p><a href="#k09">9. Demonstraèní agent èíslo 22: podrobnìj¹í výpis atributù pro instance tøíd "Foo" a "Bar"</a></p>
<p><a href="#k10">10. Zdrojové kódy obou agentù a k&nbsp;nim pøíslu¹ných testovacích pøíkladù</a></p>
<p><a href="#k11">11. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - prùchod hodnotami atributù objektù ulo¾ených na haldì (heapu)</h2>

<p>V&nbsp;dne¹ní (ji¾ ¹edesáté :-) èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyce Java i o vlastnostech virtuálního stroje Javy</a> si
popí¹eme a následnì na dvojici demonstraèních agentù i prakticky uká¾eme, jakým
zpùsobem je mo¾né pøes rozhraní <i>JVM TI</i> procházet v¹emi (neobjektovými)
atributy tøíd i atributy objektù ulo¾ených na haldì (heapu). Pøipomeòme si, ¾e
atributy tøíd (=statické atributy) i atributy objektù (=nestatické atributy)
mohou být, podobnì jako lokální promìnné èi parametry metod, buï objektového
typu (instancí nìjaké tøídy, která opìt rekurzivnì mù¾e obsahovat dal¹í objekty
nebo primitivní hodnoty) nebo mohou být pøedstavovány takzvaným <i>primitivním
datovým typem</i>, co¾ je v&nbsp;pøípadì programovacího jazyka Java jeden
z&nbsp;následujících osmi typù:</p>

<table>
<tr><th>#</th><th>Primitivní datový typ</th><th>Skupina</th><th></th><th>Rozsah hodnot</th></tr>
<tr><td>1</td><td>boolean</td><td>pravdivostní typ</td><td>true,false</td></tr>
<tr><td>2</td><td>byte   </td><td>celoèíselný typ</td><td>-128..127</td></tr>
<tr><td>3</td><td>short  </td><td>celoèíselný typ</td><td>-32768..32767</td></tr>
<tr><td>4</td><td>int    </td><td>celoèíselný typ</td><td>-2<sup>31</sup>..2<sup>31</sup>-1</td></tr>
<tr><td>5</td><td>long   </td><td>celoèíselný typ</td><td>-2<sup>63</sup>..2<sup>63</sup>-1</td></tr>
<tr><td>6</td><td>char   </td><td>znakový typ    </td><td>0..2<sup>32</sup>-1</td></tr>
<tr><td>7</td><td>float  </td><td>èíselný typ s plovoucí øádovou èárkou</td><td>&plusmn;3.40282347&times;10<sup>38</sup></td></tr>
<tr><td>8</td><td>double </td><td>èíselný typ s plovoucí øádovou èárkou</td><td>&plusmn;1.79769313486231570&times;10<sup>308</sup></td></tr>
</table>

<p>Atributy v¹ech ¾ivých objektù jsou samozøejmì pøi bìhu virtuálního stroje
Javy ulo¾eny na haldì, podobnì jako vlastní instance tøíd (objekty). Rozhraní
<i>JVM TI</i> obsahuje potøebnou funkcionalitu i pro procházení atributy;
v&nbsp;podstatì se jedná o stejný princip, s&nbsp;ním¾ jsme se ji¾ seznámili <a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-pruchod-objekty-ulozenymi-na-halde-heapu/">minule</a>,
ov¹em s&nbsp;tím rozdílem, ¾e se pøi procházení atributy ulo¾enými na haldì
pou¾ije jiný typ callback funkce, její¾ parametry jsou odli¹né od callback
funkce pou¾ívané pro ka¾dý bì¾ný objekt. Inicializaci prùchodu haldou
(<i>heapem</i>) budeme, podobnì jako v&nbsp;pøedchozí èásti tohoto seriálu,
iniciovat pomocí JVM TI funkce nazvané <strong>IterateThroughHeap()</strong> a
na ni navázaných callback funkcí. Hlavièka funkce
<strong>IterateThroughHeap()</strong> vypadá následovnì:</p>

<pre>
jvmtiError <strong>IterateThroughHeap</strong>(
            jvmtiEnv* env,
            jint      heap_filter,
            jclass    klass,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data)
</pre>

<p>Význam v¹ech parametrù této funkce jsme si ji¾ popsali <a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-prace-se-zasobnikem-a-haldou-pres-rozhrani-jvm-ti/">pøedminule</a>
a <a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-pruchod-objekty-ulozenymi-na-halde-heapu/">minule</a>,
v&nbsp;dne¹ních dvou demonstraèních pøíkladech popsaných v&nbsp;následujících
kapitolách v¹ak dojde ke zmìnì obsahu struktury typu
<strong>jvmtiHeapCallbacks</strong>, která se pøedává jako ètvrtý parametr
<i>JVM TI</i> funkci <strong>IterateThroughHeap()</strong>. Struktura
<strong>jvmtiHeapCallbacks</strong> je navr¾ena takovým zpùsobem, aby mohla
pojmout celkem ¹estnáct ukazatelù na rùzné typy callback funkcí. Ve skuteènosti
je v¹ak v&nbsp;souèasné verzi rozhraní JVM TI pou¾ito pouze pìt typù callback
funkcí, tak¾e by dal¹ích jedenáct ukazatelù mìlo mít hodnotu
<strong>NULL</strong> (není to sice striktnì vy¾adováno, ale je to bezpeènìj¹í
v&nbsp;pøípadì, kdyby se agent pou¾il na novìj¹í verzi JVM):</p>

<pre>
<strong>typedef struct</strong> {
    jvmtiHeapIterationCallback        heap_iteration_callback;
    jvmtiHeapReferenceCallback        heap_reference_callback;
    jvmtiPrimitiveFieldCallback       primitive_field_callback;
    jvmtiArrayPrimitiveValueCallback  array_primitive_value_callback;
    jvmtiStringPrimitiveValueCallback string_primitive_value_callback;
    jvmtiReservedCallback             reserved5;
    jvmtiReservedCallback             reserved6;
    jvmtiReservedCallback             reserved7;
    jvmtiReservedCallback             reserved8;
    jvmtiReservedCallback             reserved9;
    jvmtiReservedCallback             reserved10;
    jvmtiReservedCallback             reserved11;
    jvmtiReservedCallback             reserved12;
    jvmtiReservedCallback             reserved13;
    jvmtiReservedCallback             reserved14;
    jvmtiReservedCallback             reserved15;
} <strong>jvmtiHeapCallbacks</strong>;
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Callback funkce volaná pøi prùchodu hodnotami primitivních datových typù ulo¾ených na haldì</h2>

<p>Význam pìti v&nbsp;souèasnosti pøesnì definovaných ukazatelù na callback
funkce ulo¾ený v&nbsp;datové struktuøe <strong>jvmtiHeapCallbacks</strong> je
následující:</p>

<table>
<tr><th>#</th><th>Typ</th><th>Název</th><th>Význam</th></tr>
<tr><td>1</td><td>jvmtiHeapIterationCallback       </td><td>heap_iteration_callback        </td><td>voláno pro bì¾né objekty</td></tr>
<tr><td>2</td><td>jvmtiHeapReferenceCallback       </td><td>heap_reference_callback        </td><td>voláno pro reference na objekty</td></tr>
<tr><td>3</td><td>jvmtiPrimitiveFieldCallback      </td><td>primitive_field_callback       </td><td>voláno pro atributy primitivního datového typu</td></tr>
<tr><td>4</td><td>jvmtiArrayPrimitiveValueCallback </td><td>array_primitive_value_callback </td><td>voláno pro pole primitivních datových typù</td></tr>
<tr><td>5</td><td>jvmtiStringPrimitiveValueCallback</td><td>string_primitive_value_callback</td><td>voláno pro øetìzce</td></tr>
</table>

<p>Callback funkce <strong>jvmtiHeapIterationCallback()</strong> byla ji¾
pomìrnì dopodrobna popsána v&nbsp;pøedchozí èásti tohoto seriálu, kde jsme ji
pou¾ili ve tøech demonstraèních JVM TI agentech. Tato callback funkce mù¾e být
zavolána pro ka¾dý objekt nalezený na haldì, pøièem¾ se jí poka¾dé pøedají
nejdùle¾itìj¹í informace o nalezeném objektu &ndash; jeho tøída, velikost
objektu v&nbsp;bajtech, tag pøiøazený k&nbsp;objektu (nebo NULL, pokud tag
pøiøazen není), délka pole v&nbsp;pøípadì, ¾e je objektem pole a koneènì
ukazatel na u¾ivatelská data, který byl pøedán funkci
<strong>IterateThroughHeap()</strong> pøi inicializaci prùchodu haldou:</p>

<pre>
jint <strong>jvmtiHeapIterationCallback</strong> (
        jlong  class_tag, 
        jlong  size, 
        jlong* tag_ptr, 
        jint   length, 
        void*  user_data);
</pre>

<p>V&nbsp;pøípadì, ¾e potøebujeme procházet atributy objektù (pøesnìji øeèeno
atributy primitivního typu), je nutné namísto callback funkce
<strong>jvmtiHeapIterationCallback()</strong> zaregistrovat a následnì pou¾ít
funkci <strong>jvmtiPrimitiveFieldCallback()</strong>, její¾ hlavièka je
v&nbsp;mnoha ohledech od <strong>jvmtiHeapIterationCallback()</strong> odli¹ná,
co¾ je ostatnì pochopitelné, proto¾e o atributech (a pøedev¹ím o primitivních
hodnotách) potøebujeme znát odli¹né informace, ne¾ o instancích tøíd:</p>

<pre>
jint <strong>jvmtiPrimitiveFieldCallback</strong> (
        jvmtiHeapReferenceKind        kind,
        const jvmtiHeapReferenceInfo* info,
        jlong                         object_class_tag,
        jlong*                        object_tag_ptr,
        jvalue                        value,
        jvmtiPrimitiveType            value_type,
        void*                         user_data);
</pre>

<p>Tento typ callback funkce je mo¾né v&nbsp;agentovi zaregistrovat velmi
snadno &ndash; následující úryvek kódu je prakticky shodný s&nbsp;kódem
pou¾itým v&nbsp;demonstraèních pøíkladech minule, li¹í se pouze øádek,
v&nbsp;nìm¾ je naplòována datová struktura <strong>jvmtiHeapCallbacks
heap_callbacks</strong>:</p>

<pre>
<i>/*</i>
<i> * Registrace callback funkce pro prochazeni heapem a zacatek prochazeni.</i>
<i> */</i>
static void <strong>register_heap_callback_and_run_dump</strong>(jvmtiEnv *jvmti_env)
{
    jvmtiError error;
    jvmtiHeapCallbacks heap_callbacks;
    t_heap_stat heap_stat = {0};
&nbsp;
<i>    /* naplnit strukturu heap_callbacks jednou callback funkci */</i>
    (void)memset(&amp;heap_callbacks, 0, sizeof(heap_callbacks));
    <strong>heap_callbacks.primitive_field_callback = &amp;callback_for_primitive_values;</strong>
&nbsp;
<i>    /* zahajit prochazeni haldou */</i>
    error = (*jvmti_env)-&gt;IterateThroughHeap(jvmti_env, 0, NULL,
            &amp;heap_callbacks, (const void *)&amp;heap_stat);
    check_jvmti_error(jvmti_env, error, "read heap content");
&nbsp;
<i>    /* vypis statistiky */</i>
    printf("Primitive values count: %d (fields only)\n", heap_stat.primitive_count);
}
</pre>

<p>Vlastní volaná callback funkce pak mù¾e ve zcela minimalistické variantì
vypadat následovnì:</p>

<pre>
<i>/*</i>
<i> * Callback funkce volana pro kazdou hodnotu primitivniho datoveho typu</i>
<i> * ulozenou na halde.</i>
<i> */</i>
static jint JNICALL <strong>callback_for_primitive_values</strong>(
        jvmtiHeapReferenceKind        kind,
        const jvmtiHeapReferenceInfo* info,
        jlong                         object_class_tag,
        jlong*                        object_tag_ptr,
        jvalue                        value,
        jvmtiPrimitiveType            value_type,
        void*                         user_data)
{
<i>    /* pokracovat dal v prochazeni haldy */</i>
    return JVMTI_VISIT_OBJECTS;
}
</pre>

<p>Tato callback funkce bude zavolána pro ka¾dý atribut primitivního datového
typu, který bude na haldì nalezen. O to, aby se pro¹la skuteènì celá halda, se
stará návratová hodnota <strong>JVMTI_VISIT_OBJECTS </strong>, pøesnìji øeèeno
jakákoli hodnota, která neobsahuje nastavený bit
<strong>JVMTI_VISIT_ABORT</strong>. Je¹tì v¹ak neznáme, jaké hodnoty se vlastnì
této callback funkci pro ka¾dý atribut pøedávají. Popis jednotlivých parametrù
této callback funkce je uveden v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Typ parametru</th><th>Jméno parametru</th><th>Význam</th></tr>
<tr><td>1</td><td>jvmtiHeapReferenceKind</td><td>kind</td><td>rozli¹ení, zda se jedná o atribut tøídy nebo atribut objektu</td></tr>
<tr><td>2</td><td>jvmtiHeapReferenceInfo*</td><td>info</td><td>ukazatel na unii struktur, kde je ulo¾en index (poøadí) atributu (viz dal¹í text)</td></tr>
<tr><td>3</td><td>jlong</td><td>object_class_tag</td><td>tag pøiøazený ke tøídì, které je objekt instancí</td></tr>
<tr><td>4</td><td>jlong*</td><td>object_tag_ptr</td><td>ukazatel na tag pøiøazený k&nbsp;objektu</td></tr>
<tr><td>5</td><td>jvalue</td><td>value</td><td>hodnota atributu (jde o unii, viz dal¹í text)</td></tr>
<tr><td>6</td><td>jvmtiPrimitiveType</td><td>value_type</td><td>typ hodnoty (byte, int, float...)</td></tr>
<tr><td>7</td><td>void*</td><td>user_data</td><td>ukazatel na u¾ivatelská data (má stejný význam, jaký ji¾ známe z minula)</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Rozli¹ení mezi atributem tøídy (statickým atributem) a atributem objektu (nestatickým atributem)</h2>

<p>Podívejme se nyní na význam prvního parametru callback funkce
<strong>callback_for_primitive_values()</strong>. Tento parametr je typu
<strong>jvmtiHeapReferenceKind</strong> a pøi pohledu na obsah hlavièkového
souboru <strong>jvmti.h</strong> mù¾eme jednodu¹e zjistit, ¾e se jedná o
výètový typ, tj.&nbsp;callback funkci je ve skuteènosti pøedáno celé èíslo typu
<strong>int</strong>:</p>

<pre>
typedef enum {
        JVMTI_HEAP_REFERENCE_CLASS = 1,
        JVMTI_HEAP_REFERENCE_FIELD = 2,
        JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT = 3,
        JVMTI_HEAP_REFERENCE_CLASS_LOADER = 4,
        JVMTI_HEAP_REFERENCE_SIGNERS = 5,
        JVMTI_HEAP_REFERENCE_PROTECTION_DOMAIN = 6,
        JVMTI_HEAP_REFERENCE_INTERFACE = 7,
        JVMTI_HEAP_REFERENCE_STATIC_FIELD = 8,
        JVMTI_HEAP_REFERENCE_CONSTANT_POOL = 9,
        JVMTI_HEAP_REFERENCE_SUPERCLASS = 10,
        JVMTI_HEAP_REFERENCE_JNI_GLOBAL = 21,
        JVMTI_HEAP_REFERENCE_SYSTEM_CLASS = 22,
        JVMTI_HEAP_REFERENCE_MONITOR = 23,
        JVMTI_HEAP_REFERENCE_STACK_LOCAL = 24,
        JVMTI_HEAP_REFERENCE_JNI_LOCAL = 25,
        JVMTI_HEAP_REFERENCE_THREAD = 26,
        JVMTI_HEAP_REFERENCE_OTHER = 27
} jvmtiHeapReferenceKind;
</pre>

<p>Ve skuteènosti se v¹ak nemusíme rozhodovat mezi sedmnácti hodnotami, které
jsou v&nbsp;tomto výètovém typu definovány, proto¾e je zaruèeno, ¾e
v&nbsp;prvním parametru callback funkce
<strong>callback_for_primitive_values()</strong> mù¾e být ulo¾ena pouze hodnota
<strong>JVMTI_HEAP_REFERENCE_STATIC_FIELD</strong> pro atributy tøíd,
popø.&nbsp;hodnota <strong>JVMTI_HEAP_REFERENCE_FIELD</strong> pro atributy
objektù.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Zji¹tìní typu hodnoty ulo¾ené na haldì</h2>

<p>Dal¹ím parametrem callback funkce
<strong>callback_for_primitive_values()</strong>, kterým se budeme zabývat, je
pøedposlední parametr nazvaný <strong>value_type</strong>, jeho¾ datovým typem
je <strong>jvmtiPrimitiveType</strong>. Patrnì jste ji¾ správnì uhodli, ¾e se
v&nbsp;tomto parametru pøedává typ atributu. Jak jsme si ji¾ øekli <a
href="#k03">v&nbsp;první kapitole</a>, rozeznáváme v&nbsp;programovacím jazyku
Java celkem osm primitivních datových typù:</p>

<pre>
typedef enum {
        JVMTI_PRIMITIVE_TYPE_BOOLEAN = 90,
        JVMTI_PRIMITIVE_TYPE_BYTE = 66,
        JVMTI_PRIMITIVE_TYPE_CHAR = 67,
        JVMTI_PRIMITIVE_TYPE_SHORT = 83,
        JVMTI_PRIMITIVE_TYPE_INT = 73,
        JVMTI_PRIMITIVE_TYPE_LONG = 74,
        JVMTI_PRIMITIVE_TYPE_FLOAT = 70,
        JVMTI_PRIMITIVE_TYPE_DOUBLE = 68
} jvmtiPrimitiveType;
</pre>

<p>V&nbsp;prvním demonstraèním pøíkladu popsaném dále budeme mj.&nbsp;vypisovat
i typy atributù. O pøevod mezi èíselnì vyjádøeným datovým typem a popisným
øetìzcem se postará funkce <strong>get_primitive_type_str()</strong>,
v&nbsp;ní¾ bylo jednodu¹¹í pou¾ít rozvìtvení typu switch z&nbsp;toho dùvodu, ¾e
èíselné kódy datových typù (kupodivu) netvoøí celoèíselnou posloupnost:</p>

<pre>
<i>/**</i>
<i> * Prevod ciselneho identifikatoru datoveho typu na retezec.</i>
<i> */</i>
char *<strong>get_primitive_type_str</strong>(jvmtiPrimitiveType value_type)
{
    switch (value_type)
    {
        case <strong>JVMTI_PRIMITIVE_TYPE_BOOLEAN:</strong>
            return "boolean";
            break;
        case <strong>JVMTI_PRIMITIVE_TYPE_BYTE:</strong>
            return "byte";
            break;
        case <strong>JVMTI_PRIMITIVE_TYPE_CHAR:</strong>
            return "char";
            break;
        case <strong>JVMTI_PRIMITIVE_TYPE_SHORT:</strong>
            return "short";
            break;
        case <strong>JVMTI_PRIMITIVE_TYPE_INT:</strong>
            return "int";
            break;
        case <strong>JVMTI_PRIMITIVE_TYPE_LONG:</strong>
            return "long";
            break;
        case <strong>JVMTI_PRIMITIVE_TYPE_FLOAT:</strong>
            return "float";
            break;
        case <strong>JVMTI_PRIMITIVE_TYPE_DOUBLE:</strong>
            return "double";
            break;
        default: <i>/* nemelo by nikdy nastat */</i>
            return "unknown!";
            break;
    }
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Zji¹tìní tøídy, k&nbsp;ní¾ atribut ulo¾ený na haldì pøíslu¹í</h2>

<p>Dal¹ím dùle¾itým parametrem callback funkce
<strong>callback_for_primitive_values()</strong> je tøetí parametr pojmenovaný
<strong>object_class_tag</strong>. S&nbsp;tímto parametrem jsme se vlastnì ji¾
setkali, i kdy¾ v&nbsp;ponìkud odli¹né podobì, i v&nbsp;pøedchozí èásti tohoto
seriálu &ndash; v&nbsp;tomto parametru je toti¾ pøedán <i>tag</i> pøiøazený ke
tøídì, k&nbsp;ní¾ pøíslu¹í právì nalezený statický/tøídní atribut,
popø.&nbsp;ke tøídì, její¾ instance je právì procházena. My ji¾ víme, jakým
zpùsobem je mo¾né <i>tag</i> vyu¾ít; doká¾eme toti¾ ji¾ pøi naèítání tøíd,
popø.&nbsp;po zavolání funkce <strong>GetLoadedClasses()</strong> ka¾dé tøídì
nastavit nenulový <i>tag</i> a souèasnì si ulo¾it jméno tøídy do globálního
pole øetìzcù. Následnì je mo¾né s&nbsp;vyu¾itím pøedaného <i>tagu</i> pøevést
tuto èíselnou hodnotu na jméno tøídy. Globální pole
<strong>class_names</strong> lze naplnit napøíklad následujícím kódem:</p>

<pre>
<i>/* Globální pole, do nìho¾ se ulo¾í jména v¹ech pou¾itých tøíd. */</i>
char **class_names;
&nbsp;
<i>/* Lokální promìnné pou¾ité pouze pro pøeètení jmen tøíd, posléze nebudou zapotøebí. */</i>
jvmtiError error;
jint       class_count;
jclass    *class_array;
int        i;
&nbsp;
<i>/* Pøeèíst jména v¹ech naètených tøíd. */</i>
error = (*jvmti_env)-&gt;<strong>GetLoadedClasses</strong>(jvmti_env, &amp;class_count, &amp;class_array);
check_jvmti_error(jvmti_env, error, "get loaded classes");
&nbsp;
<i>/* Alokovat globální pole, které bude jména obsahovat. */</i>
class_names = (char**)malloc(class_count * sizeof(char*));
&nbsp;
<i>/* Projít získaným seznamem. */</i>
for (i=0; i &lt; class_count; i++)
{
    char *class_name_ptr;
    char *updated_class_name_ptr;
&nbsp;
<i>    /* Získat jméno (signaturu) jedné tøídy */</i>
    error = (*jvmti_env)-&gt;<strong>GetClassSignature</strong>(jvmti_env, class_array[i], &amp;class_name_ptr, NULL);
    check_jvmti_error(jvmti_env, error, "get class signature");
    if (class_name_ptr == NULL)
    {
        puts("Error: class has no signature");
    }
&nbsp;
<i>    /* Upravit jméno tøídy do èitelnìj¹í podoby. */</i>
    updated_class_name_ptr = update_class_name(class_name_ptr, ' ');
&nbsp;
<i>    /* Kopie jména tøídy do globálního pole class_names. */</i>
    class_names[i] = (char*)malloc(1 + strlen(updated_class_name_ptr));
    strcpy(class_names[i], updated_class_name_ptr);
&nbsp;
<i>    /* Dealokace pamìti vrácené funkcí GetClassSignature() */</i>
    error = (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char *)class_name_ptr);
    check_jvmti_error(jvmti_env, error, "deallocate class name");
}
</pre>

<p>Nyní ji¾ mù¾eme callback funkci
<strong>callback_for_primitive_values()</strong> upravit takovým zpùsobem, ¾e
pro ka¾dý nalezený (statický i nestatický) atribut vypí¹e jak jeho typ, tak i
jméno pøíslu¹né tøídy:</p>

<pre>
<i>/*</i>
<i> * Callback funkce volana pro kazdou hodnotu primitivniho datoveho typu</i>
<i> * ulozenou na halde.</i>
<i> */</i>
static jint JNICALL <strong>callback_for_primitive_values</strong>(
        jvmtiHeapReferenceKind        kind,
        const jvmtiHeapReferenceInfo* info,
        jlong                         object_class_tag,
        jlong*                        object_tag_ptr,
        jvalue                        value,
        jvmtiPrimitiveType            value_type,
        void*                         user_data)
{
    int index;
    char *primitive_type_str;
    char *class_name;
&nbsp;
<i>    /* na zaklade predaneho typu ziskat jmeno typu jako retezec */</i>
    primitive_type_str = get_primitive_type_str(value_type);
&nbsp;
<i>    /* jmeno tridy lze ziskat na zaklade tagu z globalniho pole */</i>
    index = object_class_tag - 1;
    class_name = class_names[index];
&nbsp;
<i>    /* vypiseme informace */</i>
    printf("Found field of type %-7s in instance of class %s\n",
        primitive_type_str, class_name);
&nbsp;
<i>    /* spocitani statistickych informaci o obsazeni haldy */</i>
    t_heap_stat *heap_stat = (t_heap_stat*)user_data;
    heap_stat-&gt;primitive_count++;
&nbsp;
<i>    /* pokracovat dal v prochazeni haldy */</i>
    return <strong>JVMTI_VISIT_OBJECTS</strong>;
}
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Demonstraèní agent èíslo 21: výpis atributù pro v¹echny instance tøíd "Foo" a "Bar"</h2>

<p>Koneènì se dostáváme k&nbsp;dne¹nímu prvnímu demonstraènímu pøíkladu &ndash;
<i>JVM TI</i> agentu. V&nbsp;tomto pøíkladu se vypí¹ou typy v¹ech nestatických
atributù instancí tøíd <strong>Foo</strong> a <strong>Bar</strong>. Instance
tìchto dvou tøíd jsou vytvoøeny v&nbsp;metodì
<strong>Test21.main()</strong>:</p>

<pre>
<i>/**</i>
<i>  * Testovaci trida pouzita pro test dvacateho</i>
<i>  * prvniho demonstracniho JVM TI agenta.</i>
<i>  */</i>
public class <strong>Test21</strong> {
&nbsp;
<i>    /**</i>
<i>      * Spusteni testu.</i>
<i>      */</i>
    public static void main(String[] args) {
        Foo foo1 = new Foo(42, 3.1415f, false);
        Foo foo2 = new Foo(6502, 2.7172f, true);
        Bar bar1 = new Bar();
        Bar bar2 = new Bar();
    }
}
&nbsp;
class <strong>Foo</strong> {
&nbsp;
    boolean booleanValue;
    int     intValue;
    float   floatValue;
&nbsp;
    public Foo(int intValue, float floatValue, boolean booleanValue) {
        this.intValue = intValue;
        this.floatValue = floatValue;
        this.booleanValue = booleanValue;
    }
&nbsp;
}
&nbsp;
class <strong>Bar</strong> {
&nbsp;
    byte  b;
    short s;
    int  i;
    long l;
&nbsp;
    public Bar() {
        this.b = (byte)1;
        this.s = (short)2;
        this.i = 3;
        this.l = 4L;
    }
&nbsp;
}
</pre>

<p>Vzhledem k&nbsp;tomu, ¾e potøebujeme vypsat jen nestatické atributy, budeme
muset do callback funkce <strong>callback_for_primitive_values()</strong>
pøidat kontrolu na to, zda je v&nbsp;parametru <strong>kind</strong> pøedána
hodnota <strong>JVMTI_HEAP_REFERENCE_FIELD</strong>. Druhou filtraci provedeme
na základì jména tøídy, proto¾e potøebujeme vypsat pouze atributy instancí tøíd
<strong>Foo</strong> a <strong>Bar</strong>. Rychlej¹í by sice bylo si
zapamatovat <i>tagy</i> tìchto tøíd a potom provádìt pouze porovnání dvou
celých èísel a nikoli porovnávání øetìzcù, celý program by to v¹ak zbyteènì
zkomplikovalo. Výsledná podoba callback funkce je vypsána pod tímto
odstavcem:</p>

<pre>
<i>/*</i>
<i> * Callback funkce volana pro kazdou hodnotu primitivniho datoveho typu</i>
<i> * ulozenou na halde.</i>
<i> */</i>
static jint JNICALL <strong>callback_for_primitive_values</strong>(
        jvmtiHeapReferenceKind        kind,
        const jvmtiHeapReferenceInfo* info,
        jlong                         object_class_tag,
        jlong*                        object_tag_ptr,
        jvalue                        value,
        jvmtiPrimitiveType            value_type,
        void*                         user_data)
{
    int index;
    char *primitive_type_str;
    char *class_name;
&nbsp;
<i>    /* zajimaji nas pouze nestaticke atributy objektu */</i>
    if (kind != <strong>JVMTI_HEAP_REFERENCE_FIELD</strong>) return <strong>JVMTI_VISIT_OBJECTS;</strong>
&nbsp;
<i>    /* na zaklade predaneho typu ziskat jmeno typu jako retezec */</i>
    primitive_type_str = get_primitive_type_str(value_type);
&nbsp;
<i>    /* jmeno tridy lze ziskat na zaklade tagu z globalniho pole */</i>
    index = object_class_tag - 1;
    class_name = class_names[index];
&nbsp;
<i>    /* vypiseme informace pouze pro dve testovaci tridy "Foo" a "Bar" */</i>
    if (strcmp("Foo ", class_name)==0 || strcmp("Bar ", class_name)==0)
    {
        printf("Found field of type %-7s in instance of class %s\n",
                primitive_type_str, class_name);
    }
&nbsp;
<i>    /* spocitani statistickych informaci o obsazeni haldy */</i>
    t_heap_stat *heap_stat = (t_heap_stat*)user_data;
    heap_stat-&gt;primitive_count++;
&nbsp;
<i>    /* pokracovat dal v prochazeni haldy */</i>
    return <strong>JVMTI_VISIT_OBJECTS</strong>;
}
</pre>

<p>Kompletní zdrojový kód 21.demonstraèního agenta i v¹echny potøebné soubory
pou¾ité pro jeho pøeklad a spu¹tìní mù¾ete nalézt <a href="#k10">v&nbsp;desáté
kapitole</a>. Zde si jen uká¾eme zprávy vypisované agentem na standardní
výstup:</p>

<pre>
Agent21: Agent_OnLoad
Agent21: JVM TI version is correct
Agent21: Got VM init event
Agent21: Got VM Death event
Agent21: Got data dump request
class java.io.BufferedOutputStream  has tag 1
class java.lang.Class$3  has tag 2
class java.util.Enumeration  has tag 3
class sun.misc.Version  has tag 4
...
...
...
class [Z has tag 373
class [B has tag 374
class [C has tag 375
class [I has tag 376
class [S has tag 377
class [J has tag 378
class [F has tag 379
class [D has tag 380
Found field of type float   in instance of class Foo 
Found field of type int     in instance of class Foo 
Found field of type boolean in instance of class Foo 
Found field of type float   in instance of class Foo 
Found field of type int     in instance of class Foo 
Found field of type boolean in instance of class Foo 
Found field of type long    in instance of class Bar 
Found field of type int     in instance of class Bar 
Found field of type short   in instance of class Bar 
Found field of type byte    in instance of class Bar 
Found field of type long    in instance of class Bar 
Found field of type int     in instance of class Bar 
Found field of type short   in instance of class Bar 
Found field of type byte    in instance of class Bar 
Primitive values count: 5522 (fields only)
Agent21: Agent_OnUnload
</pre>

<p>Z&nbsp;výpisu je patrné, ¾e se nejdøíve ka¾dé naètené tøídì pøiøadí
celoèíselný <i>tag</i> rozdílný od nuly a následnì se pøi prùchodu haldou
vypí¹ou datové typy atributù instancí tøíd <strong>Foo</strong> a
<strong>Bar</strong>. Nakonec je vypsán celkový poèet atributù (základního
datového typu), které byly na haldì nalezeny.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Výpoèet obsazení haldy hodnotami primitivních datových typù</h2>

<p>Dal¹í úpravy demonstraèního agenta ji¾ budou pomìrnì jednoduché. Do
statistiky obsazení haldy nejprve pøidáme i informaci o tom, kolik místa je zde
vyhrazeno pro atributy základních datových typù. Dopøedu je nutné øíci, ¾e se
bude jednat pouze o odhad (a to je¹tì o dolní hranici tohoto odhadu), proto¾e
ka¾dá implementace virtuálního stroje Javy si mù¾e sama rozhodnout, zda se bude
pøi ukládání pou¾ívat nìjaká forma zarovnání dat, napøíklad na celoèíselné
násobky 32bitových èi dnes spí¹e 64bitových adres. I tak se v¹ak jedná o
zajímavé informace, zvlá¹tì kdy¾ si uvìdomíme, ¾e primitivní datové typy a pole
tìchto typù jsou vlastnì jedinými &bdquo;skuteènými&ldquo; daty ulo¾enými na
haldì, proto¾e objekty jsou zde ulo¾eny ve formì referencí, které
v&nbsp;dùsledku zase ukazují pouze na hodnoty primitivních datových typù. Pro
výpoèet minimálního místa na haldì obsazené urèitou hodnotou je pou¾ita pomocná
funkce <strong>get_primitive_type_size()</strong>. Její chování je jednoduché,
snad a¾ na výpoèet velikosti u typu <strong>boolean</strong>, kde teoreticky
postaèuje pro ulo¾ení hodnoty <strong>true/false</strong> pouze jeden bit,
nicménì JVM vìt¹inou pracuje s&nbsp;celým bajtem (a v&nbsp;bajtkódu je navíc
<strong>boolean</strong> zpracováván jako <strong>int</strong>, podobnì jako je
tomu u typù <strong>byte</strong> a <strong>short</strong>). Z&nbsp;tohoto dùvodu
se budeme dr¾et rozhraní <i>JNI</i>, kde je jasnì øeèeno, ¾e se hodnoty typu
<strong>boolean</strong> pøedávají v&nbsp;jako osmibitové hodnoty:</p>

<pre>
<i>/**</i>
<i> * Ziskani velikosti (bajty) hodnoty daneho primitivniho datoveho typu.</i>
<i> */</i>
int get_primitive_type_size(jvmtiPrimitiveType value_type)
{
    switch (value_type)
    {
        case <strong>JVMTI_PRIMITIVE_TYPE_BOOLEAN</strong>:
        case <strong>JVMTI_PRIMITIVE_TYPE_BYTE</strong>:
            return 1;
            break;
        case <strong>JVMTI_PRIMITIVE_TYPE_CHAR</strong>:
        case <strong>JVMTI_PRIMITIVE_TYPE_SHORT</strong>:
            return 2;
            break;
        case <strong>JVMTI_PRIMITIVE_TYPE_INT</strong>:
        case <strong>JVMTI_PRIMITIVE_TYPE_FLOAT</strong>:
            return 4;
            break;
        case <strong>JVMTI_PRIMITIVE_TYPE_LONG</strong>:
        case <strong>JVMTI_PRIMITIVE_TYPE_DOUBLE</strong>:
            return 8;
            break;
        default: <i>/* nemelo by nastat */</i>
            return 0;
            break;
    }
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Tisk v¹ech hodnot nalezených agentem</h2>

<p>Dal¹ím úkolem agenta bude tisk hodnot primitivních datových typù. Jak jsme
se ji¾ dozvìdìli ve <a href="#k02">druhé kapitole</a>, je hodnota jakéhokoli
primitivního datového typu pøedána v&nbsp;pátém parametru funkce
<strong>callback_for_primitive_values()</strong>. Tento parametr je typu
<strong>jvalue</strong> a pohledem do hlavièkového souboru
<strong>jni.h</strong> (nikoli <strong>jvmti.h</strong>!) snadno zjistíme, ¾e
se jedná o unii (v&nbsp;céèku <i>union</i>), v&nbsp;ní¾ mù¾e být ulo¾ena jak
hodnota jakéhokoli základního datového typu, tak i reference na objekt. Nás
v¹ak budou v&nbsp;tuto chvíli zajímat pouze hodnoty základních datových typù a
nikoli reference, tak¾e z&nbsp;unie <strong>jvalue</strong> budeme pou¾ívat
pouze prvních osm (v&nbsp;pamìti se pøekrývajících) prvkù:</p>

<pre>
typedef union jvalue {
        jboolean z;
        jbyte    b;
        jchar    c;
        jshort   s;
        jint     i;
        jlong    j;
        jfloat   f;
        jdouble  d;
        jobject  l;
} jvalue;
</pre>

<p>Funkce, která provede tisk jakékoli hodnoty základního datového typu na
standardní výstup, mù¾e vypadat napøíklad následovnì (úprava pro GCC
v&nbsp;pøípadì céèkového datového typu <strong>long long</strong>):</p>

<pre>
<i>/**</i>
<i> * Tisk hodnoty primitivniho datoveho typu na standardni vystup.</i>
<i> */</i>
void <strong>print_value</strong>(jvmtiPrimitiveType value_type, jvalue value)
{
    switch (value_type)
    {
        case <strong>JVMTI_PRIMITIVE_TYPE_BOOLEAN:</strong>
            puts(value.z ? "true" : "false");
            break;
        case <strong>JVMTI_PRIMITIVE_TYPE_CHAR:</strong>
            printf("%d\n", (int)value.c);
            break;
        case <strong>JVMTI_PRIMITIVE_TYPE_BYTE:</strong>
            printf("%d\n", (int)value.b);
            break;
        case <strong>JVMTI_PRIMITIVE_TYPE_SHORT:</strong>
            printf("%d\n", (int)value.s);
            break;
        case <strong>JVMTI_PRIMITIVE_TYPE_INT:</strong>
            printf("%d\n", (int)value.i);
            break;
        case <strong>JVMTI_PRIMITIVE_TYPE_LONG:</strong>
            printf("%Ld\n", (long long)value.j);
            break;
        case <strong>JVMTI_PRIMITIVE_TYPE_FLOAT:</strong>
            printf("%f\n", value.f);
            break;
        case <strong>JVMTI_PRIMITIVE_TYPE_DOUBLE:</strong>
            printf("%lf\n", value.d);
            break;
        default:
            puts("unknown!");
            break;
    }
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Demonstraèní agent èíslo 22: podrobnìj¹í výpis atributù pro instance tøíd "Foo" a "Bar"</h2>

<p>Pomocné funkce popsané v&nbsp;pøedchozích dvou kapitolách nyní mù¾eme vyu¾ít
v&nbsp;dal¹ím (22.) demonstraèním <i>JVM TI</i> agentovi, který pro ka¾dý
atribut nalezený na haldì vypí¹e pøíslu¹nou tøídu, typ atributu (boolean,
float, int...) a takté¾ jeho hodnotu. Pøitom se provádí filtrace na atributy
tøíd <strong>Foo</strong> a <strong>Bar</strong>; tento filtr lze samozøejmì
velmi snadno odstranit, pokud budete potøebovat vypsat v¹ech pøibli¾nì 5500
atributù :-) Kromì obou nových pomocných funkcí
<strong>get_primitive_type_size()</strong> a
<strong>get_primitive_type_str()</strong> do¹lo ke zmìnì v&nbsp;callback funkci
<strong>callback_for_primitive_values()</strong>:</p>

<pre>
<i>/*</i>
<i> * Callback funkce volana pro kazdou hodnotu primitivniho datoveho typu</i>
<i> * ulozenou na halde.</i>
<i> */</i>
static jint JNICALL <strong>callback_for_primitive_values</strong>(
        jvmtiHeapReferenceKind        kind,
        const jvmtiHeapReferenceInfo* info,
        jlong                         object_class_tag,
        jlong*                        object_tag_ptr,
        jvalue                        value,
        jvmtiPrimitiveType            value_type,
        void* user_data)
{
    int index;
    int size;
    char *primitive_type_str;
    char *class_name;
&nbsp;
<i>    /* zajimaji nas pouze nestaticke atributy objektu */</i>
    if (kind != JVMTI_HEAP_REFERENCE_FIELD) return JVMTI_VISIT_OBJECTS;
&nbsp;
<i>    /* na zaklade predaneho typu ziskat jmeno typu jako retezec */</i>
    primitive_type_str = get_primitive_type_str(value_type);
&nbsp;
<i>    /* na zaklade predaneho typu ziskat velikost v bajtech */</i>
    size = get_primitive_type_size(value_type);
&nbsp;
<i>    /* jmeno tridy lze ziskat na zaklade tagu z globalniho pole */</i>
    index = object_class_tag - 1;
    class_name = class_names[index];
&nbsp;
<i>    /* vypiseme informace pouze pro dve testovaci tridy "Foo" a "Bar" */</i>
    if (strcmp("Foo ", class_name)==0 || strcmp("Bar ", class_name)==0)
    {
        printf("Field of type %-7s in instance of class %shas size %1d byte%c and value ",
                primitive_type_str, class_name, size, size &gt; 1 ? 's' : ' ');
        print_value(value_type, value);
    }
&nbsp;
<i>    /* spocitani statistickych informaci o obsazeni haldy */</i>
    t_heap_stat *heap_stat = (t_heap_stat*)user_data;
    heap_stat-&gt;primitive_count++;
    heap_stat-&gt;total_size += size;
&nbsp;
<i>    /* pokracovat dal v prochazeni haldy */</i>
    return JVMTI_VISIT_OBJECTS;
}
</pre>

<p>Takto upravený agent vypí¹e po svém pøipojení k&nbsp;bì¾ícímu virtuálnímu
stroji Javy následující zprávy:</p>

<pre>
Agent22: Agent_OnLoad
Agent22: JVM TI version is correct
Agent22: Got VM init event
Agent22: Got VM Death event
Agent22: Got data dump request
class java.io.BufferedOutputStream  has tag 1
class java.lang.Class$3  has tag 2
class java.util.Enumeration  has tag 3
class sun.misc.Version  has tag 4
...
...
...
class [Z has tag 373
class [B has tag 374
class [C has tag 375
class [I has tag 376
class [S has tag 377
class [J has tag 378
class [F has tag 379
class [D has tag 380
Field of type float   in instance of class Foo has size 4 bytes and value 3.141500
Field of type int     in instance of class Foo has size 4 bytes and value 42
Field of type boolean in instance of class Foo has size 1 byte  and value false
Field of type float   in instance of class Foo has size 4 bytes and value 2.717200
Field of type int     in instance of class Foo has size 4 bytes and value 6502
Field of type boolean in instance of class Foo has size 1 byte  and value true
Field of type long    in instance of class Bar has size 8 bytes and value 4
Field of type int     in instance of class Bar has size 4 bytes and value 3
Field of type short   in instance of class Bar has size 2 bytes and value 2
Field of type byte    in instance of class Bar has size 1 byte  and value 1
Field of type long    in instance of class Bar has size 8 bytes and value 4
Field of type int     in instance of class Bar has size 4 bytes and value 3
Field of type short   in instance of class Bar has size 2 bytes and value 2
Field of type byte    in instance of class Bar has size 1 byte  and value 1
Primitive values count: 5522 (fields only)
Total size:   21422 bytes
Agent22: Agent_OnUnload
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Zdrojové kódy obou agentù a k&nbsp;nim pøíslu¹ných testovacích pøíkladù</h2>

<p>Podobnì jako ve tøech pøedcházejících èástech tohoto seriálu [<a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-sledovani-cinnosti-virtualniho-stroje-javy-pres-rozhrani-jvm-ti-5-cast-detekce-vzniku-vsech-vyjimek/">57</a>][<a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-prace-se-zasobnikem-a-haldou-pres-rozhrani-jvm-ti/">58</a>][<a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-pruchod-objekty-ulozenymi-na-halde-heapu/">59</a>],
byly i dne¹ní dva demonstraèní pøíklady kvùli snaz¹ímu udr¾ování v¹ech
zdrojových kódù ulo¾eny do Mercurial repositáøe, který je dostupný na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
Prozatím nejnovìj¹í verze dnes popisovaných <i>JVM TI</i> agentù i dal¹ích
potøebných skriptù a testovacích javovských tøíd jsou dostupné na následujících
adresách:</p>

<table>
<tr><th>Demonstraèní pøíklad/podpùrný soubor</th><th>Umístìní</th></tr>
<tr><td>Agent #21          </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/5d9c9b6db35f/jvmti-agents/agent21/agent21.c">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/5d9c9b6db35f/jvmti-agents/agent21/agent21.c</a></td></tr>
<tr><td>Skript pro pøeklad </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/5d9c9b6db35f/jvmti-agents/agent21/compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/5d9c9b6db35f/jvmti-agents/agent21/compile.sh</a></td></tr>
<tr><td>Skript pro spu¹tìní</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/5d9c9b6db35f/jvmti-agents/agent21/test.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/5d9c9b6db35f/jvmti-agents/agent21/test.sh</a></td></tr>
<tr><td>Testovací tøída    </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/5d9c9b6db35f/jvmti-agents/agent21/Test21.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/5d9c9b6db35f/jvmti-agents/agent21/Test21.java</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Agent #22          </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/5d9c9b6db35f/jvmti-agents/agent22/agent22.c">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/5d9c9b6db35f/jvmti-agents/agent22/agent22.c</a></td></tr>
<tr><td>Skript pro pøeklad </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/5d9c9b6db35f/jvmti-agents/agent22/compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/5d9c9b6db35f/jvmti-agents/agent22/compile.sh</a></td></tr>
<tr><td>Skript pro spu¹tìní</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/5d9c9b6db35f/jvmti-agents/agent22/test.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/5d9c9b6db35f/jvmti-agents/agent22/test.sh</a></td></tr>
<tr><td>Testovací tøída    </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/5d9c9b6db35f/jvmti-agents/agent22/Test22.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/5d9c9b6db35f/jvmti-agents/agent22/Test22.java</a></td></tr>
</table>



<p><a name="k11"></a></p>
<h2 id="k11">11. Odkazy na Internetu</h2>

<ol>

<li>The JVM Tool Interface (JVM TI): How VM Agents Work<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html">http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html</a>
</li>

<li>JVM Tool Interface Version 1.2<br />
<a href="http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html">http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html</a>
</li>

<li>Creating a Debugging and Profiling Agent with JVMTI<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html">http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html</a>
</li>

<li>JVM TI (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/JVM_TI">http://en.wikipedia.org/wiki/JVM_TI</a>
</li>

<li>IBM JVMTI extensions<br />
<a href="http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html">http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

