<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - nízkoúrovòový pøístup k framebufferu i bitmapám s vyu¾itím knihovny SDLJava</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - nízkoúrovòový pøístup k framebufferu i bitmapám s vyu¾itím knihovny SDLJava</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;dne¹ní èásti seriálu o programovacím jazyce Java i o virtuálním stroji Javy si øekneme, jakým zpùsobem je mo¾né s&nbsp;vyu¾itím knihovny SDLJava pøistupovat k&nbsp;obsahu framebufferu i bitmap (typ SDLSurface) na úrovni jednotlivých pixelù. Sice se jedná o pomìrnì pomalé operace, ov¹em v&nbsp;nìkterých typech aplikací se jim nemù¾eme zcela vyhnout.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - nízkoúrovòový pøístup k&nbsp;framebufferu i bitmapám s&nbsp;vyu¾itím knihovny SDLJava</a></p>
<p><a href="#k02">2. Formát ukládání pixelù ve framebufferu a v&nbsp;bitmapách</a></p>
<p><a href="#k03">3. Tøída <strong>sdljava.video.SDLPixelFormat</strong></a></p>
<p><a href="#k04">4. Demonstraèní pøíklad <strong>SDLTest8</strong> &ndash; zobrazení základních informací o framebufferu</a></p>
<p><a href="#k05">5. Spu¹tìní demonstraèního pøíkladu <strong>SDLTest8</strong> a ukázka výstupu</a></p>
<p><a href="#k06">6. Demonstraèní pøíklad <strong>SDLTest9</strong> &ndash; zobrazení základních informací o naètené bitmapì</a></p>
<p><a href="#k07">7. Spu¹tìní demonstraèního pøíkladu <strong>SDLTest9</strong> a ukázka výstupu</a></p>
<p><a href="#k08">8. Vlastnosti pou¾itého video systému</a></p>
<p><a href="#k09">9. Demonstraèní pøíklad <strong>SDLTest10</strong> &ndash; zobrazení informací o video systému</a></p>
<p><a href="#k10">10. Spu¹tìní demonstraèního pøíkladu <strong>SDLTest10</strong> a ukázka výstupu</a></p>
<p><a href="#k11">11. Nízkoúrovòový pøístup k&nbsp;obsahu framebufferu a bitmap</a></p>
<p><a href="#k12">12. Demonstraèní pøíklad <strong>SDLTest11</strong> &ndash; negace v¹ech pixelù ulo¾ených v&nbsp;bitmapì</a></p>
<p><a href="#k13">13. Repositáø se zdrojovými kódy v¹ech ètyø dne¹ních demonstraèních pøíkladù</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - nízkoúrovòový pøístup k&nbsp;framebufferu a bitmapám s&nbsp;vyu¾itím knihovny SDLJava</h2>

<p>V&nbsp;dne¹ní èásti seriálu o programovacím jazyku Java i o virtuálním
stroji tohoto jazyka navá¾eme na pøedchozí díl, v&nbsp;nìm¾ byl
mj.&nbsp;vysvìtlen zpùsob naètení bitmap z&nbsp;externích souborù
s&nbsp;následným zobrazením (resp.&nbsp;pøenosem) tìchto bitmap do
framebufferu. Pro úplné pochopení vlastností knihovny <i>SDL</i> (verze 1.x) si
v¹ak je¹tì musíme ukázat zpùsoby manipulace s&nbsp;obsahem bitmap a
popø.&nbsp;i s&nbsp;obsahem framebufferu. Jedná se o dosti nízkoúrovòové
operace, které neoplývají velkou rychlostí, ov¹em v&nbsp;nìkterých pøípadech se
jim nemù¾eme vyhnout. Pøíkladem mù¾e být napøíklad grafický editor, v&nbsp;nìm¾
je nutné pøistupovat k&nbsp;jednotlivým pixelùm popø.&nbsp;k&nbsp;jejich
barvovým slo¾kám. Knihovna <i>SDLJava</i> zaji¹»ující rozhraní mezi Javovskou
aplikací a knihovnou <i>SDL</i> samozøejmì tyto operace podporuje, ov¹em
s&nbsp;nìkolika omezeními, která vyplývají z&nbsp;toho, ¾e v&nbsp;Javì nelze
pøímo manipulovat s&nbsp;ukazateli pou¾itými v&nbsp;nativních datových
strukturách knihovny <i>SDL</i>.</p>

<p>Nejdøíve si popí¹eme zpùsoby získání základních informací o libovolné
bitmapì èi framebufferu, tedy o objektech, které jsou pøi vyu¾ití knihovny
<i>SDLJava</i> reprezentovány instancemi tøídy
<strong>sdljava.video.SDLSurface</strong>. Následnì se seznámíme s&nbsp;tøídou
<strong>sdljava.video.SDLPixelFormat</strong>, co¾ je obalující tøída céèkové
datové struktury nazvané <strong>SDL_PixelFormat</strong>, z&nbsp;ní¾ lze
získat v¹echny informace nutné pro zakódování èi dekódování barev na hodnoty
ukládané do bitmapy a/nebo do framebufferu. Nesmíme zapomenout ani na tøídu
<strong>sdljava.video.SDLVideoInfo</strong> (obalující céèkovou datovou
strukturu <strong>SDL_VideoInfo</strong>) s&nbsp;informacemi o mo¾nostech video
systému. V&nbsp;závìreèné èásti tohoto èlánku si uká¾eme jeden
z&nbsp;jednoduchých (ale souèasnì i pomalých) zpùsobù pøístupu
k&nbsp;jednotlivým pixelùm ulo¾eným v&nbsp;bitmapì. V¹echny informace, které se
dnes dozvíme, budou opìt ukázány na nìkolika demonstraèních pøíkladech.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Formát ukládání pixelù ve framebufferu a v&nbsp;bitmapách</h2>

<p>V&nbsp;pøedchozích dvou èástech tohoto seriálu jsme se ji¾ seznámili se
tøídou <strong>sdljava.video.SDLSurface</strong>, její¾ instance reprezentují
buï bitmapy nebo framebuffer. Bitmapy je mo¾né naèíst z&nbsp;externích souborù
s&nbsp;vyu¾itím metody <strong>sdljava.video.SDLVideo.loadBMP()</strong>
popø.&nbsp;<strong>sdljava.image.SDLImage.load()</strong>, nebo lze (pokud je
to nutné) bitmapy tvoøit programovì, tj.&nbsp;konstrukcí prázdné bitmapy
s&nbsp;následným nakreslením nìjakého obrazce do bitmapy. Pokud je nutno do
bitmapy zapisovat èi z&nbsp;ní èíst jednotlivé pixely, musíme znát následující
údaje: rozmìry bitmapy, skuteènou délku obrazového øádku a pøesný formát
ulo¾ení pixelù. Pro zji¹tìní tìchto údajù lze vyu¾ít následující ètveøici metod
tøídy <strong>sdljava.video.SDLSurface</strong>:</p>

<table>
<tr><th>#</th><th>Metoda</th><th>Popis</th></tr>
<tr><td>1</td><td>int getWidth()</td><td>vrátí ¹íøku bitmapy, tj.&nbsp;poèet viditelných pixelù na obrazovém øádku</td></tr>
<tr><td>2</td><td>int getHeight()</td><td>vrátí vý¹ku bitmapy, tj.&nbsp;poèet viditelných obrazových øádkù</td></tr>
<tr><td>3</td><td>int getPitch()</td><td>vrátí skuteènou délku obrazového øádku (viz poznámka ní¾e)</td></tr>
<tr><td>4</td><td>SDLPixelFormat getFormat()</td><td>vrátí instanci tøídy <strong>SDLPixelFormat</strong> obsahující v¹echny informace o zpùsobu ulo¾ení pixelù v&nbsp;bitmapì</td></tr>
</table>

<p>Údaje o ¹íøce a vý¹ce bitmapy jsou uvádìny v&nbsp;pixelech, zatímco údaj
<i>pitch</i> je pou¾íván pro adresaci a tudí¾ je vrácen jako celková délka
obrazového øádku uvádìná v&nbsp;bajtech. Tento údaj je nutné znát ze dvou
dùvodù: u nìkterých typù bitmap i u framebufferù je délka obrazového øádku
zarovnána napøíklad na násobky ètyø, osmi atd. bajtù, a to proto, aby se
jednodu¹eji provádìly blokové pøenosy dat. U nìkterých typù framebufferù je
jeho &bdquo;neviditelná&ldquo; èást vyu¾ita pro ulo¾ení spritù atd., co¾ mù¾e
znamenat, ¾e hodnota <i>pitch</i> nebude v&nbsp;¾ádném pøípadì odpovídat ¹íøce
bitmapy vynásobené poètem bajtù nutných pro ulo¾ení jednoho pixelu. Mù¾eme si
uvést pøíklad bitmapy/framebufferu s&nbsp;¹íøkou 800 pixelù a bitovou hloubkou
32bpp (tj.&nbsp;ètyøi bajty na pixel). V&nbsp;tomto pøípadì mù¾e hodnota
<i>pitch</i> být 800&times;4=3200 bajtù, ov¹em mù¾e také být rovna 4096 bajtùm
atd.  Druhý dùvod pou¾ití hodnoty <i>pitch</i> v&nbsp;praxi spoèívá v&nbsp;tom,
¾e se pøi adresaci pixelù nemusí násobit ¹íøka bitmapy hodnotou bpp (dìlitelnou
osmi).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Tøída <strong>sdljava.video.SDLPixelFormat</strong></h2>

<p>Dal¹ím dùle¾itým údajem o bitmapì a/nebo framebufferu je informace o pøesném
formátu ulo¾ení pixelù. Pro reprezentaci tìchto informací se v&nbsp;nativní
knihovnì <i>SDL</i> pou¾ívá céèková struktura nazvaná
<strong>SDL_PixelFormat</strong>, která vypadá následovnì:</p>

<pre>
typedef struct SDL_PixelFormat {
    SDL_Palette *palette;
    Uint8  BitsPerPixel;
    Uint8  BytesPerPixel;
    Uint8  Rloss, Gloss, Bloss, Aloss;
    Uint8  Rshift, Gshift, Bshift, Ashift;
    Uint32 Rmask, Gmask, Bmask, Amask;
    Uint32 colorkey;
    Uint8  alpha;
} SDL_PixelFormat;
</pre>

<p>V&nbsp;knihovnì <i>SDLJava</i> je tato datová struktura obalena tøídou
<strong>SDLPixelFormat</strong> a najdeme v&nbsp;ní v¹echny potøebné gettery,
které jsou vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Metoda</th><th>Popis</th></tr>
<tr><td> 1</td><td>short getRloss() </td><td>poèet bitù, které se ztratí pøi konverzi hodnoty èervené barvové slo¾ky v rozsahu 0..255</td></tr>
<tr><td> 2</td><td>long  getRmask() </td><td>maska, která z&nbsp;hodnoty pixelu odstraní v¹echny informace kromì èervené slo¾ky</td></tr>
<tr><td> 3</td><td>short getRshift()</td><td>hodnota bitového posunu proto, aby bylo mo¾né získat hodnotu èervené slo¾ky</td></tr>
<tr><td> 4</td><td>short getGloss() </td><td>poèet bitù, které se ztratí pøi konverzi hodnoty zelené barvové slo¾ky v rozsahu 0..255</td></tr>
<tr><td> 5</td><td>long  getGmask() </td><td>maska, která z&nbsp;hodnoty pixelu odstraní v¹echny informace kromì zelené slo¾ky</td></tr>
<tr><td> 6</td><td>short getGshift()</td><td>hodnota bitového posunu proto, aby bylo mo¾né získat hodnotu zelené slo¾ky</td></tr>
<tr><td> 7</td><td>short getBloss() </td><td>poèet bitù, které se ztratí pøi konverzi hodnoty modré barvové slo¾ky v rozsahu 0..255</td></tr>
<tr><td> 8</td><td>long  getBmask() </td><td>maska, která z&nbsp;hodnoty pixelu odstraní v¹echny informace kromì modré slo¾ky</td></tr>
<tr><td> 9</td><td>short getBshift()</td><td>hodnota bitového posunu proto, aby bylo mo¾né získat hodnotu modré slo¾ky</td></tr>
<tr><td>10</td><td>short getAloss() </td><td>poèet bitù, které se ztratí pøi konverzi hodnoty alfa slo¾ky v rozsahu 0..255</td></tr>
<tr><td>11</td><td>long  getAmask() </td><td>maska, která z&nbsp;hodnoty pixelu odstraní v¹echny informace kromì alfa slo¾ky</td></tr>
<tr><td>12</td><td>short getAshift()</td><td>hodnota bitového posunu proto, aby bylo mo¾né získat hodnotu alfa slo¾ky</td></tr>
<tr><td>13</td><td>short getBitsPerPixel()</td><td>poèet bitù, kterými je reprezentovaný pixel</td></tr>
<tr><td>14</td><td>short getBytesPerPixel()</td><td>poèet bajtù, kterými je reprezentovaný pixel</td></tr>
<tr><td>15</td><td>long  getColorkey()</td><td>klíèová barva (resp.&nbsp;hodnota pixelu), prùhledná pøi operaci typu <i>BitBLT</i></td></tr>
</table>

<p>Význam tìchto getterù si zaslou¾í zvlá¹tní vysvìtlení. <i>SDL</i> rozli¹uje
bitmapy s&nbsp;barvovou paletou a bitmapy bez palety. U bitmap s&nbsp;barvovou
paletou má význam pouze zji¹tìní bitové hloubky, tj.&nbsp;jedná se o gettery
<strong>getBitsPerPixel()</strong>, <strong>getBytesPerPixel()</strong> a
<strong>getColorkey()</strong>. Zajímavìj¹í je to u bitmap bez palety, které
mají vìt¹inou bitovou hloubku 16bpp, 24bpp a 32bpp. U tìchto bitmap je ka¾dá
barvová slo¾ka (<i>red</i>, <i>green</i>, <i>blue</i>) a popø.&nbsp;i
prùhlednost pixelu (<i>alf</i>a kanál) ulo¾ena ve dvou, tøech èi ètyøech
bajtech a vý¹e popsané gettery #1 a¾ #12 slou¾í k&nbsp;tomu, aby byl
programátor schopen tyto barvové slo¾ky získat, popø.&nbsp;naopak ze tøí
barvových slo¾ek (popø.&nbsp;prùhlednosti) vypoèítat hodnotu pro zápis do
bitmapu.</p>

<p>Pøíkladem mù¾e být bitmapa s&nbsp;bitovou hloubkou 24bpp, v&nbsp;ní¾ je
ka¾dá barvová slo¾ka (<i>red</i>, <i>green</i>, <i>blue</i>) reprezentována
osmi bity. V&nbsp;tomto pøípadì budou masky jednotlivých barvových slo¾ek
nastaveny na hodnoty 0xff000, 0x00ff00 a 0x0000ff a bitové posuny na hodnoty
16, 8 a 0. První barvovou slo¾ku (vìt¹inou <i>red</i>) získáme maskováním
hodnoty pixelu maskou 0xff0000 a posunem o 16 bitù doprava, druhou barvovou
slo¾ku (typicky <i>green</i>) maskováním hodnoty pixelu maskou 0x00ff00 a
posunem o 8 bitù atd. Hodnota <i>loss</i> je pou¾ita v&nbsp;pøípadì, kdy má
bitmapa hloubku 16bpp, aby se napøíklad pìtibitová hodnota získaná maskováním a
posunem zkonvertovala na osmibitovou hodnotu.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Demonstraèní pøíklad <strong>SDLTest8</strong> &ndash; zobrazení základních informací o framebufferu</h2>

<p>Informace, s&nbsp;nimi¾ jsme se seznámili v&nbsp;pøedchozích tøech
kapitolách, si mù¾eme ovìøit na demonstraèním pøíkladu nazvaném
<strong>SDLTest8</strong>. Po spu¹tìní tohoto demonstraèního pøíkladu se
nastaví zvolený video re¾im (implicitnì je pou¾ito rozli¹ení 800&times;600
pixelù) a následnì se zjistí v¹echny dùle¾ité informace jak o rozli¹ení
framebufferu, tak i o hodnotì <i>pitch</i> zmínìné <a href="#k02">ve druhé
kapitole</a> a o formátu ulo¾ení pixelù, co¾ bylo téma, kterému jsme se
vìnovali <a href="#k03">v&nbsp;kapitole tøetí</a>. V¹echny zji¹tìné informace o
framebufferu jsou následnì vypsány na standardní výstup. Sami si mù¾ete
vyzkou¹et pou¾ití dal¹ích grafických re¾imù, rùzných bitových hloubek atd.:</p>

<pre>
import sdljava.SDLMain;
import sdljava.video.SDLPixelFormat;
import sdljava.video.SDLSurface;
import sdljava.video.SDLVideo;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Osmy demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> *</i>
<i> * Zobrazeni zakladnich informaci o vybranem grafickem rezimu</i>
<i> * a o formatu pixelu pouzitych v tomto rezimu.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>SDLTest8</strong> {
&nbsp;
    <i>/**</i>
    <i> * Horizontalni rozliseni vybraneho grafickeho rezimu.</i>
    <i> */</i>
    private static final int <strong>GFX_WIDTH</strong> = 800;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni rozliseni vybraneho grafickeho rezimu.</i>
    <i> */</i>
    private static final int <strong>GFX_HEIGHT</strong> = 600;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka vybraneho grafickeho rezimu.</i>
    <i> * (0 znamena automaticky vyber, ovsem lze samozrejme pouzit</i>
    <i> * i hodnoty 8, 16, 24 ci 32, podle vlastnosti graficke karty)</i>
    <i> */</i>
    private static final int <strong>GFX_BPP</strong> = 0;
&nbsp;
    <i>/**</i>
    <i> * Zobrazeni ziskanych informaci o vybranem grafickem rezimu.</i>
    <i> * </i>
    <i> * @param pixelFormat</i>
    <i> *            format pixelu</i>
    <i> * @param pitch</i>
    <i> *            skutecna delka obrazoveho radku v bajtech</i>
    <i> * @param width</i>
    <i> *            pocet viditelnych pixelu na obrazovem radku</i>
    <i> * @param height</i>
    <i> *            pocet viditelnych obrazovych radku</i>
    <i> */</i>
    private static void <strong>printInfo</strong>(SDLPixelFormat pixelFormat, int pitch, int width, int height) {
        print("Width:  " + width);
        print("Height: " + height);
        print("Pitch:  " + pitch);
        print("Bpp:    " + pixelFormat.getBitsPerPixel());
        <i>// informace o cervene barvove slozce</i>
        print("Red:");
        print("    shift: " + pixelFormat.getRShift());
        print("    mask:  0x" + Long.toHexString(pixelFormat.getRMask()));
        print("    loss:  " + pixelFormat.getRLoss());
        <i>// informace o zelene barvove slozce</i>
        print("Green:");
        print("    shift: " + pixelFormat.getGShift());
        print("    mask:  0x" + Long.toHexString(pixelFormat.getGMask()));
        print("    loss:  " + pixelFormat.getGLoss());
        <i>// informace o modre barvove slozce</i>
        print("Blue:");
        print("    shift: " + pixelFormat.getBShift());
        print("    mask:  0x" + Long.toHexString(pixelFormat.getBMask()));
        print("    loss:  " + pixelFormat.getBLoss());
        <i>// informace o alfa kanalu</i>
        print("Alpha:");
        print("    shift: " + pixelFormat.getAShift());
        print("    mask:  0x" + Long.toHexString(pixelFormat.getAMask()));
        print("    loss:  " + pixelFormat.getALoss());
    }
&nbsp;
    <i>/**</i>
    <i> * Vypis retezce na standardni vystup.</i>
    <i> * </i>
    <i> * @param string</i>
    <i> *            vypisovany retezec</i>
    <i> */</i>
    private static void <strong>print</strong>(String string) {
        System.out.println(string);
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni osmeho demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        <i>// informace o formatu pixelu</i>
        SDLPixelFormat pixelFormat = null;
        <i>// skutecna delka obrazoveho radku</i>
        int pitch = 0;
        <i>// realne rozliseni (viditelna bitmapa)</i>
        int width = 0;
        int height = 0;
&nbsp;
        try {
            <i>// inicializace video subsystemu knihovny SDL.</i>
            SDLMain.init(SDLMain.SDL_INIT_VIDEO);
            <i>// inicializace celoobrazovkoveho grafickeho rezimu</i>
            final SDLSurface screen = SDLVideo.setVideoMode(GFX_WIDTH, GFX_HEIGHT, GFX_BPP, 0);
            Thread.sleep(500);
            <i>// precteni zakladnich informaci o grafickem rezimu</i>
            pixelFormat = screen.getFormat();
            pitch = screen.getPitch();
            width = screen.getWidth();
            height = screen.getHeight();
            Thread.sleep(500);
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
        <i>// zobrazit ziskane informace</i>
        printInfo(pixelFormat, pitch, width, height);
    }
&nbsp;
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Spu¹tìní demonstraèního pøíkladu <strong>SDLTest8</strong> a ukázka výstupu</h2>

<p>Pøipomeòme si, jakým zpùsobem je nutné demonstraèní pøíklady vyu¾ívající
knihovnu <i>SDLJava</i> pøelo¾it a následnì spustit. Nesmíme zapomenout uvést
cestu k&nbsp;javovské èásti této knihovny (<strong>sdljava.jar</strong>) a pøi
spu¹tìní ani k&nbsp;nativní èásti knihovny
(<strong>libsdljava.so/sdljava.dll</strong>):</p>

<p>Skript pro pøeklad (Linux):</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest8.java
</pre>

<p>Skript pro pøeklad (Microsoft Windows):</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest8.java
</pre>

<p>Skript pro spu¹tìní (Linux):</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest8.java
</pre>

<p>Skript pro spu¹tìní (Microsoft Windows):</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest8
</pre>

<p>Zajímavé jsou výsledky spu¹tìní demonstraèního pøíkladu na rùzných
systémech, popø.&nbsp;s&nbsp;rùznì nastavenými konstantami
<strong>GFX_WIDTH</strong>, <strong>GFX_HEIGHT</strong> a
<strong>GFX_BPP</strong>.</p>

<p>Spu¹tìní pøi specifikaci osmibitové hloubky, pøi ní¾ se pou¾ívá barvová
paleta tudí¾ masky ani bitové posuny nemají význam:</p>

<pre>
Width:  800
Height: 600
Pitch:  800
Bpp:    8
Red:
    shift: 0
    mask:  0x0
    loss:  8
Green:
    shift: 0
    mask:  0x0
    loss:  8
Blue:
    shift: 0
    mask:  0x0
    loss:  8
Alpha:
    shift: 0
    mask:  0x0
    loss:  8
</pre>

<p>Pøi volbì 16bitové hloubky je zajímavé sledovat hodnotu masky i poèty bitù,
které se u jednotlivých barvových slo¾ek ztratí (3 bity pro èervenou slo¾ku, 2
bity pro slo¾ku zelenou a 3 bity pro slo¾ku modrou):</p>

<pre>
Width:  800
Height: 600
Pitch:  1600
Bpp:    16
Red:
    shift: 11
    mask:  0xf800
    loss:  3
Green:
    shift: 5
    mask:  0x7e0
    loss:  2
Blue:
    shift: 0
    mask:  0x1f
    loss:  3
Alpha:
    shift: 0
    mask:  0x0
    loss:  8
</pre>

<p>Spu¹tìní pøi specifikaci 24 bitové hloubky ve skuteènosti na testovaném
stroji pou¾ilo framebuffer s&nbsp;formátem 32bpp, ov¹em alfa kanál je nevyu¾it
(maskován):</p>

<pre>
Width:  800
Height: 600
Pitch:  2400
Bpp:    24
Red:
    shift: 16
    mask:  0xff0000
    loss:  0
Green:
    shift: 8
    mask:  0xff00
    loss:  0
Blue:
    shift: 0
    mask:  0xff
    loss:  0
Alpha:
    shift: 0
    mask:  0x0
    loss:  8
</pre>

<p>Skuteèná 32bitová hloubka framebufferu:</p>

<pre>
Width:  800
Height: 600
Pitch:  3200
Bpp:    32
Red:
    shift: 16
    mask:  0xff0000
    loss:  0
Green:
    shift: 8
    mask:  0xff00
    loss:  0
Blue:
    shift: 0
    mask:  0xff
    loss:  0
Alpha:
    shift: 0
    mask:  0x0
    loss:  8
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Demonstraèní pøíklad <strong>SDLTest9</strong> &ndash; zobrazení základních informací o naètené bitmapì</h2>

<p>Demonstraèní pøíklad <strong>SDLTest9</strong> se v&nbsp;mnoha ohledech
podobá pøedchozímu demonstraènímu pøíkladu <strong>SDLTest8</strong>, a¾ na ten
rozdíl, ¾e se zjistí a následnì i zobrazí informace o bitmapì ulo¾ené do
souboru <strong>xscorch.bmp</strong> (<a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/raw-file/6fe0d3a6edeb/sdljava/img/xscorch.bmp">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/raw-file/6fe0d3a6edeb/sdljava/img/xscorch.bmp</a>)
a nikoli informace o framebufferu.  Pov¹imnìte si, ¾e v&nbsp;tomto pøíkladu
vùbec není nutné nastavovat grafický re¾im, proto¾e jedinými operacemi, které
je nutné provést, je naètení bitmapy pomocí metody
<strong>sdljava.video.SDLVideo.loadBMP()</strong>, pøeètení informací o ulo¾ení
pixelù v&nbsp;bitmapì pøes metodu
<strong>sdljava.video.SDLSurface.getFormat()</strong> a následné volání
getterù, jen¾ jsou v&nbsp;této tøídì deklarovány (viz <a href="#k03">tøetí
kapitolu</a> s&nbsp;podrobnìj¹ím popisem):</p>

<pre>
import sdljava.SDLMain;
import sdljava.video.SDLPixelFormat;
import sdljava.video.SDLSurface;
import sdljava.video.SDLVideo;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Devaty demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> *</i>
<i> * Zobrazeni zakladnich informaci o bitmape nactene ze souboru</i>
<i> * typu BMP (Windows Bitmap).</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>SDLTest9</strong> {
&nbsp;
    <i>/**</i>
    <i> * Nazev bitmapy, ktera se ma nacist a nasledne zobrazit.</i>
    <i> */</i>
    private static final String <strong>IMAGE_NAME</strong> = "xscorch.bmp";
&nbsp;
    <i>/**</i>
    <i> * Zobrazeni ziskanych informaci o bitmape (surface).</i>
    <i> * </i>
    <i> * @param pixelFormat</i>
    <i> *            format pixelu</i>
    <i> * @param pitch</i>
    <i> *            skutecna delka obrazoveho radku v bajtech</i>
    <i> * @param width</i>
    <i> *            pocet viditelnych pixelu na jednom radku bitmapy</i>
    <i> * @param height</i>
    <i> *            pocet viditelnych obrazovych radku bitmapy</i>
    <i> */</i>
    private static void <strong>printInfo</strong>(SDLPixelFormat pixelFormat, int pitch, int width, int height) {
        print("Width:  " + width);
        print("Height: " + height);
        print("Pitch:  " + pitch);
        print("Bpp:    " + pixelFormat.getBitsPerPixel());
        <i>// informace o cervene barvove slozce</i>
        print("Red:");
        print("    shift: " + pixelFormat.getRShift());
        print("    mask:  0x" + Long.toHexString(pixelFormat.getRMask()));
        print("    loss:  " + pixelFormat.getRLoss());
        <i>// informace o zelene barvove slozce</i>
        print("Green:");
        print("    shift: " + pixelFormat.getGShift());
        print("    mask:  0x" + Long.toHexString(pixelFormat.getGMask()));
        print("    loss:  " + pixelFormat.getGLoss());
        <i>// informace o modre barvove slozce</i>
        print("Blue:");
        print("    shift: " + pixelFormat.getBShift());
        print("    mask:  0x" + Long.toHexString(pixelFormat.getBMask()));
        print("    loss:  " + pixelFormat.getBLoss());
        <i>// informace o alfa kanalu</i>
        print("Alpha:");
        print("    shift: " + pixelFormat.getAShift());
        print("    mask:  0x" + Long.toHexString(pixelFormat.getAMask()));
        print("    loss:  " + pixelFormat.getALoss());
    }
&nbsp;
    <i>/**</i>
    <i> * Vypis retezce na standardni vystup.</i>
    <i> * </i>
    <i> * @param string</i>
    <i> *            vypisovany retezec</i>
    <i> */</i>
    private static void <strong>print</strong>(String string) {
        System.out.println(string);
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni devateho demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        <i>// informace o formatu pixelu</i>
        SDLPixelFormat pixelFormat = null;
        <i>// skutecna delka obrazoveho radku</i>
        int pitch = 0;
        <i>// realne rozliseni nactene bitmapy</i>
        int width = 0;
        int height = 0;
&nbsp;
        try {
            <i>// inicializace video subsystemu knihovny SDL.</i>
            SDLMain.init(SDLMain.SDL_INIT_VIDEO);
            <i>// nacteni bitmapy z externiho souboru</i>
            final SDLSurface bitmap = SDLVideo.loadBMP(IMAGE_NAME);
            <i>// ziskani informaci o nactene bitmape</i>
            pixelFormat = bitmap.getFormat();
            pitch = bitmap.getPitch();
            width = bitmap.getWidth();
            height = bitmap.getHeight();
            Thread.sleep(100);
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
        <i>// zobrazit ziskane informace</i>
        printInfo(pixelFormat, pitch, width, height);
    }
&nbsp;
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Spu¹tìní demonstraèního pøíkladu <strong>SDLTest9</strong> a ukázka výstupu</h2>

<p>Pøeklad i spu¹tìní pøíkladu <strong>SDLTest9</strong> se provádí naprosto
stejným zpùsobem, jako tomu bylo u pøedchozího pøíklad:</p>

<p>Skript pro pøeklad (Linux):</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest9.java
</pre>

<p>Skript pro pøeklad (Microsoft Windows):</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest9.java
</pre>

<p>Skript pro spu¹tìní (Linux):</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest9.java
</pre>

<p>Skript pro spu¹tìní (Microsoft Windows):</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest9
</pre>

<p>Po spu¹tìní tohoto pøíkladu by se na standardním výstupu mìla objevit
následující zpráva pøesnì v&nbsp;tom formátu, v&nbsp;jakém je zde uvedena.
Pov¹imnìte si zejména absence alfa kanálu, který znaèí ¾e v&nbsp;této bitmapì
(pokud by nebyla provedena její konverze) nelze ukládat poloprùhledné pixely.
Hodnota <i>pitch</i> pøesnì odpovídá ¹íøce bitmapy vynásobené poètem bajtù na
pixel:</p>

<pre>
Width:  300
Height: 195
Pitch:  900
Bpp:    24
Red:
    shift: 16
    mask:  0xff0000
    loss:  0
Green:
    shift: 8
    mask:  0xff00
    loss:  0
Blue:
    shift: 0
    mask:  0xff
    loss:  0
Alpha:
    shift: 0
    mask:  0x0
    loss:  8
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Vlastnosti pou¾itého video systému</h2>

<p>Knihovna <i>SDL</i> doká¾e pøeèíst i vlastnosti pou¾itého video systému.
Tyto informace jsou pøedány v&nbsp;nativní struktuøe (bitovém poli) pojmenované
<strong>SDL_VideoInfo</strong>:</p>

<pre>
typedef struct{
    Uint32 hw_available:1;
    Uint32 wm_available:1;
    Uint32 blit_hw:1;
    Uint32 blit_hw_CC:1;
    Uint32 blit_hw_A:1;
    Uint32 blit_sw:1;
    Uint32 blit_sw_CC:1;
    Uint32 blit_sw_A:1;
    Uint32 blit_fill;
    Uint32 video_mem;
    SDL_PixelFormat *vfmt;
} SDL_VideoInfo;
</pre>

<p>Tato struktura je v&nbsp;knihovnì <i>SDLJava</i> obalena tøídou
<strong>sdljava.video.SDLVideoInfo</strong>, v&nbsp;ní¾ jsou deklarovány
následující gettery:</p>

<table>
<tr><th> #</th><th>Metoda</th><th>Popis</th></tr>
<tr><td> 1</td><td>getHwAvailable()</td><td>vrací true pokud se bitmapy vytváøí ve video pamìti</td></tr>
<tr><td> 2</td><td>getWmAvailable()</td><td>vrací true pokud je pøítomen správce oken (neplatí napøíklad pro FB re¾imy)<td></td></tr>
<tr><td> 3</td><td>getVideoMemory()</td><td>kapacita VRAM (ne v¾dy dostupný údaj)</td></tr>
<tr><td> 4</td><td>getBlit_fill() </td><td>mo¾nosti akcelerace operace typu <i>rectangle fill</i></td></tr>
<tr><td> 5</td><td>getBlit_hw_A() </td><td>mo¾nosti akcelerace operace typu <i>BitBLT</i> s&nbsp;prùhledností pixelù (pøenos z&nbsp;VRAM)</td></tr>
<tr><td> 6</td><td>getBlit_hw_CC()</td><td>mo¾nosti akcelerace operace typu <i>BitBLT</i> s&nbsp;klíèovou (zcela prùhlednou) barvou (pøenos z&nbsp;VRAM)</td></tr>
<tr><td> 7</td><td>getBlit_hw()   </td><td>mo¾nosti akcelerace operace typu <i>BitBLT</i> (pøenos z&nbsp;VRAM)</td></tr>
<tr><td> 8</td><td>getBlit_sw_A() </td><td>mo¾nosti akcelerace operace typu <i>BitBLT</i> s&nbsp;prùhledností pixelù (pøenos z&nbsp;operaèní pamìti do VRAM)</td></tr>
<tr><td> 9</td><td>getBlit_sw_CC()</td><td>mo¾nosti akcelerace operace typu <i>BitBLT</i> s&nbsp;klíèovou (zcela prùhlednou) barvou (pøenos z&nbsp;operaèní pamìti do VRAM)</td></tr>
<tr><td>10</td><td>getBlit_sw()   </td><td>mo¾nosti akcelerace operace typu <i>BitBLT</i> (pøenos z&nbsp;operaèní pamìti do VRAM)</td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Demonstraèní pøíklad <strong>SDLTest10</strong> &ndash; zobrazení informací o video systému</h2>

<p>V&nbsp;demonstraèním pøíkladu <strong>SDLTest10</strong> je ukázáno, jakým
zpùsobem lze pøeèíst informace o video systému nainstalovaném na poèítaèi, na
nìm¾ je tento pøíklad spu¹tìn. Pov¹imnìte si, ¾e instanci tøídy
<strong>sdljava.video.SDLVideoInfo</strong> popsané <a
href="#k08">v&nbsp;pøedchozí kapitole</a> lze získat zavoláním statické metody
<strong>sdljava.video.SDLVideo.getVideoInfo()</strong>:</p>

<pre>
import sdljava.SDLMain;
import sdljava.video.SDLVideo;
import sdljava.video.SDLVideoInfo;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Desaty demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> *</i>
<i> * Zobrazeni zakladnich informaci o video subsystemu.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>SDLTest10</strong> {
&nbsp;
    <i>/**</i>
    <i> * Zobrazeni ziskanych informaci o video subsystemu.</i>
    <i> * </i>
    <i> * @param videoInfo</i>
    <i> *            informace o video subsystemu</i>
    <i> */</i>
    private static void <strong>printInfo</strong>(SDLVideoInfo videoInfo) {
        print("Window manager available:          " + trueFalse(videoInfo.getWmAvailable()));
        print("Hardware surfaces available:       " + trueFalse(videoInfo.getHwAvailable()));
        print("Total video RAM (kB):              " + videoInfo.getVideoMemory());
        print("Accelerated BitBLT (HW):           " + trueFalse(videoInfo.getBlit_hw()));
        print("Accelerated Color key BitBLT (HW): " + trueFalse(videoInfo.getBlit_hw_CC()));
        print("Accelerated Alpha BitBLT (HW):     " + trueFalse(videoInfo.getBlit_hw_A()));
        print("Accelerated BitBLT (SW):           " + trueFalse(videoInfo.getBlit_sw()));
        print("Accelerated Color key BitBLT (SW): " + trueFalse(videoInfo.getBlit_sw_CC()));
        print("Accelerated Alpha BitBLT (SW):     " + trueFalse(videoInfo.getBlit_sw_A()));
        print("Accelerated BitBLT fill:           " + trueFalse(videoInfo.getBlit_fill()));
    }
&nbsp;
    <i>/**</i>
    <i> * Prevod priznaku na retezec "true" ci "false".</i>
    <i> * </i>
    <i> * @param flag</i>
    <i> *            priznak</i>
    <i> * @return retezec "true" ci "false"</i>
    <i> */</i>
    private static String <strong>trueFalse</strong>(long flag) {
        return flag == 0 ? "no" : "yes";
    }
&nbsp;
    <i>/**</i>
    <i> * Vypis retezce na standardni vystup.</i>
    <i> * </i>
    <i> * @param string</i>
    <i> *            vypisovany retezec</i>
    <i> */</i>
    private static void <strong>print</strong>(String string) {
        System.out.println(string);
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni desateho demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace video subsystemu knihovny SDL.</i>
            SDLMain.init(SDLMain.SDL_INIT_VIDEO);
            <i>// ziskat informace o video subsystemu</i>
            final SDLVideoInfo videoInfo = SDLVideo.getVideoInfo();
            <i>// zobrazit ziskane informace</i>
            printInfo(videoInfo);
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
    }
&nbsp;
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Spu¹tìní demonstraèního pøíkladu <strong>SDLTest10</strong> a ukázka výstupu</h2>

<p>Pøíklad <strong>SDLTest10</strong> se pøekládá a spou¹tí naprosto stejným
zpùsobem jako oba dva pøedchozí pøíklady <strong>SDLTest8</strong> a
<strong>SDLTest9</strong>, proto zde ji¾ nejsou pøíslu¹né skripty uvedeny.
Zajímavìj¹í jsou zprávy, které získáme na standardním výstupu. Pro testovaný
systém (Linux, X Window + uzavøené ovladaèe nVidia) se získaly následující
výsledky naznaèující, ¾e vìt¹ina klíèových operací provádìných knihovnou
<i>SDL</i> není akcelerována:</p>

<pre>
Window manager available:          yes
Hardware surfaces available:       no
Total video RAM (kB):              0
Accelerated BitBLT (HW):           no
Accelerated Color key BitBLT (HW): no
Accelerated Alpha BitBLT (HW):     no
Accelerated BitBLT (SW):           no
Accelerated Color key BitBLT (SW): no
Accelerated Alpha BitBLT (SW):     no
Accelerated BitBLT fill:           no
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Nízkoúrovòový pøístup k&nbsp;obsahu framebufferu a bitmap</h2>

<p>Pro nízkoúrovòový pøístup k&nbsp;obsahu framebufferu a/nebo bitmap lze
v&nbsp;pøípadì pou¾ití knihovny <i>SDL</i> získat pøímo ukazatel (pointer),
pøes nìj¾ je mo¾né pøistupovat k&nbsp;jednotlivým pixelùm. V&nbsp;Javì a
knihovnì <i>SDLJava</i> sice tuto mo¾nost nemáme, namísto toho je ov¹em obsah
bitmapy pøístupný ve formì objektu typu <strong>java.nio.ByteBuffer</strong>.
Ov¹em je¹tì pøedtím, ne¾ je mo¾né èíst èi zapisovat obsah bitmapy, je nutné
bitmapu takzvanì uzamknout s&nbsp;vyu¾itím metody
<strong>lockSurface()</strong> a následnì opìt odemnknout metodou
<strong>unlockSurface()</strong>. Tyto metody sice nemusí být volány pro
v¹echny typy bitmap, ov¹em pøi pøímém pøístupu do framebufferu se jim
nevyhneme:</p>

<table>
<tr><th>#</th><th>Metoda</th><th>Popis</th></tr>
<tr><td>1</td><td>boolean lockSurface()</td><td></td></tr>
<tr><td>2</td><td>void unlockSurface()</td><td></td></tr>
<tr><td>3</td><td>java.nio.ByteBuffer getPixelData()</td><td></td></tr>
</table>

<p>Postup pøi pøímém pøístupu k&nbsp;obsahu bitmapy/framebufferu je
následující:</p>

<pre>
    private static void <strong>updateBitmap</strong>(SDLSurface bitmap) throws SDLException {
        bitmap.lockSurface();
        ByteBuffer pixelBuffer = bitmap.getPixelData();
        ... zde je mo¾né pracovat s pixely
        bitmap.unlockSurface();
    }
</pre>

<p>Pixely se ètou a zapisují v&nbsp;interní podobì, tj.&nbsp;pro jejich pøevod
na hodnoty RGB èi RGBA je nutné pou¾ít informace získané metodami vysvìtlenými
v&nbsp;pøedchozích kapitolách, popø.&nbsp;vyu¾ít dvojici konverzních funkcí,
které v¹ak nejsou nijak závratnì rychlé.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Demonstraèní pøíklad <strong>SDLTest11</strong> &ndash; negace v¹ech pixelù ulo¾ených v&nbsp;bitmapì</h2>

<p>Dne¹ní poslední demonstraèní pøíklad se jmenuje <strong>SDLTest11</strong>.
Po jeho spu¹tìní se naète bitmapa ze souboru <strong>xscorch.bmp</strong> a
následnì se vykreslí na obrazovku (do framebufferu). Po pøibli¾nì dvou
sekundách se získá buffer obsahující hodnoty v¹ech pixelù v&nbsp;bitmapì a
následnì jsou tyto hodnoty invertovány (to si mù¾eme dovolit udìlat velmi
jednodu¹e, proto¾e bitmapa neobsahuje alfa kanál). Po inverzi v¹ech pixelù se
bitmapa opìt zobrazí a posléze se ulo¾í do nového souboru s&nbsp;názvem
<strong>xscorch2.bmp</strong>:</p>

<img src="http://i.iinfo.cz/images/654/javasdl3-1.png" class="image-160279" width="300" height="195" alt="&#160;" />
<p><i>Obrázek 1: Originální bitmapa.</i></p>

<img src="http://i.iinfo.cz/images/654/javasdl3-2.png" class="image-160280" width="300" height="195" alt="&#160;" />
<p><i>Obrázek 2: Bitmapa vytvoøená demonstraèním pøíkladem.</i></p>

<pre>
import java.nio.ByteBuffer;
&nbsp;
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.video.SDLRect;
import sdljava.video.SDLVideo;
import sdljava.video.SDLSurface;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Jedenacty demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> *</i>
<i> * Po spusteni se provede prepnuti do grafickeho rezimu 800x600x16</i>
<i> * Po inicializaci grafickeho rezimu se nacte bitmapa "xscorch.bmp",</i>
<i> * ktera je upravena (pixel po pixelu).</i>
<i> * Bitmapa nasledne vykresli na obrazovku operaci typu BitBLT a navic</i>
<i> * se ulozi do souboru s nazvem "xscorch2.bmp".</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>SDLTest11</strong> {
&nbsp;
    <i>/**</i>
    <i> * Horizontalni rozliseni vybraneho grafickeho rezimu.</i>
    <i> */</i>
    private static final int <strong>GFX_WIDTH</strong> = 800;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni rozliseni vybraneho grafickeho rezimu.</i>
    <i> */</i>
    private static final int <strong>GFX_HEIGHT</strong> = 600;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka vybraneho grafickeho rezimu.</i>
    <i> */</i>
    private static final int <strong>GFX_BPP</strong> = 16;
&nbsp;
    <i>/**</i>
    <i> * Nazev bitmapy, ktera se ma nacist a nasledne zobrazit.</i>
    <i> */</i>
    private static final String <strong>INPUT_IMAGE_NAME</strong> = "xscorch.bmp";
&nbsp;
    <i>/**</i>
    <i> * Nazev vysledne bitmapy.</i>
    <i> */</i>
    private static final String <strong>OUTPUT_IMAGE_NAME</strong> = "xscorch2.bmp";
&nbsp;
    <i>/**</i>
    <i> * Vykresleni bitmapy na obrazovku.</i>
    <i> * </i>
    <i> * @param screen</i>
    <i> *            framebuffer</i>
    <i> * @param bitmap</i>
    <i> *            bitmapa, ktery se ma na obrazovku vykreslit</i>
    <i> */</i>
    private static void <strong>drawOnScreen</strong>(SDLSurface screen, SDLSurface bitmap) throws SDLException {
        <i>// vypocitat umisteni bitmapy na obrazovce.</i>
        final SDLRect rect = computePositionOnScreen(screen, bitmap);
        <i>// provest operaci typu BitBLT</i>
        bitmap.blitSurface(screen, rect);
        <i>// nutno volat i v pripade, ze neni pouzit double buffering</i>
        screen.updateRect();
        screen.flip();
    }
&nbsp;
    <i>/**</i>
    <i> * Vypocitat umisteni bitmapy na obrazovce.</i>
    <i> * </i>
    <i> * @param screen</i>
    <i> *            framebuffer</i>
    <i> * @param bitmap</i>
    <i> *            bitmapa, ktery se ma na obrazovku vykreslit</i>
    <i> * @return obdelnik predstavujici pozici bitmapy na obrazovce</i>
    <i> */</i>
    private static SDLRect <strong>computePositionOnScreen</strong>(SDLSurface screen, SDLSurface bitmap) {
        <i>// ziskat rozmery obrazovky i bitmapy</i>
        final int screenWidth = screen.getWidth();
        final int screenHeight = screen.getHeight();
        final int bitmapWidth = bitmap.getWidth();
        final int bitmapHeight = bitmap.getHeight();
&nbsp;
        <i>// vypocitat umisteni bitmapy na obrazovce</i>
        final int x = (screenWidth - bitmapWidth) &gt;&gt; 1;
        final int y = (screenHeight - bitmapHeight) &gt;&gt; 1;
        return new SDLRect(x, y, bitmapWidth, bitmapHeight);
    }
&nbsp;
    <i>/**</i>
    <i> * Uprava bitmapy na urovni jednotlivych pixelu.</i>
    <i> *</i>
    <i> * @param bitmap</i>
    <i> * @throws SDLException </i>
    <i> */</i>
    private static void <strong>updateBitmap</strong>(SDLSurface bitmap) throws SDLException {
        bitmap.lockSurface();
        ByteBuffer pixelBuffer = bitmap.getPixelData();
        <i>// negace barvovych slozek vsech pixelu</i>
        for (int i = 0; i &lt; pixelBuffer.capacity(); i++) {
            pixelBuffer.put(i, (byte) ~pixelBuffer.get(i));
        }
        bitmap.unlockSurface();
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni jedenacteho demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace video subsystemu knihovny SDL.</i>
            SDLMain.init(SDLMain.SDL_INIT_VIDEO);
            <i>// inicializace celoobrazovkoveho grafickeho rezimu</i>
            final SDLSurface screen = SDLVideo.setVideoMode(GFX_WIDTH, GFX_HEIGHT, GFX_BPP, SDLVideo.SDL_FULLSCREEN);
            <i>// nacteni bitmapy z externiho souboru</i>
            final SDLSurface bitmap = SDLVideo.loadBMP(INPUT_IMAGE_NAME);
            <i>// vykresleni bitmapy na obrazovku</i>
            drawOnScreen(screen, bitmap);
            Thread.sleep(2000);
            <i>// uprava pixelu v bitmape</i>
            updateBitmap(bitmap);
            <i>// vykresleni bitmapy na obrazovku</i>
            drawOnScreen(screen, bitmap);
            Thread.sleep(2000);
            bitmap.saveBMP(OUTPUT_IMAGE_NAME);
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
    }
&nbsp;
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Repositáø se zdrojovými kódy v¹ech ètyø dne¹ních demonstraèních pøíkladù</h2>

<p>V¹echny ètyøi dne¹ní demonstraèní pøíklady byly spoleènì s&nbsp;podpùrnými
skripty urèenými pro jejich pøeklad a následné spu¹tìní ulo¾eny do Mercurial
repositáøe dostupného na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
Podobnì jako tomu bylo i v&nbsp;pøedchozích dvou dílech, i ke dne¹ním pøíkladùm
jsou pøilo¾eny skripty vyu¾itelné pro jejich pøeklad a spu¹tìní. Navíc byly
pøidány i skripty vyu¾itelné ve Windows:</p>

<table>
<tr><th> #</th><th>Zdrojový soubor/skript</th><th>Umístìní souboru v&nbsp;repositáøi</th></tr>
<tr><td> 1</td><td>SDLTest8.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest8/SDLTest8.java ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest8/SDLTest8.java</a></td></tr>
<tr><td> 2</td><td>SDLTest8_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest8/SDLTest8_compile.sh ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest8/SDLTest8_compile.sh</a></td></tr>
<tr><td> 3</td><td>SDLTest8_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest8/SDLTest8_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest8/SDLTest8_compile_sys.sh</a></td></tr>
<tr><td> 4</td><td>SDLTest8_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest8/SDLTest8_run.sh ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest8/SDLTest8_run.sh</a></td></tr>
<tr><td> 5</td><td>SDLTest8_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest8/SDLTest8_run_sys.sh ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest8/SDLTest8_run_sys.sh</a></td></tr>
<tr><td> 6</td><td>SDLTest8_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest8/SDLTest8_compile.bat ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest8/SDLTest8_compile.bat</a></td></tr>
<tr><td> 7</td><td>SDLTest8_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest8/SDLTest8_run.bat ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest8/SDLTest8_run.bat</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>SDLTest9.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest9/SDLTest9.java ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest9/SDLTest9.java</a></td></tr>
<tr><td> 9</td><td>SDLTest9_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest9/SDLTest9_compile.sh ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest9/SDLTest9_compile.sh</a></td></tr>
<tr><td>10</td><td>SDLTest9_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest9/SDLTest9_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest9/SDLTest9_compile_sys.sh</a></td></tr>
<tr><td>11</td><td>SDLTest9_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest9/SDLTest9_run.sh ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest9/SDLTest9_run.sh</a></td></tr>
<tr><td>12</td><td>SDLTest9_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest9/SDLTest9_run_sys.sh ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest9/SDLTest9_run_sys.sh</a></td></tr>
<tr><td>13</td><td>SDLTest9_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest9/SDLTest9_compile.bat ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest9/SDLTest9_compile.bat</a></td></tr>
<tr><td>14</td><td>SDLTest9_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest9/SDLTest9_run.bat ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest9/SDLTest9_run.bat</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>SDLTest10.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest10/SDLTest10.java ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest10/SDLTest10.java</a></td></tr>
<tr><td>16</td><td>SDLTest10_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest10/SDLTest10_compile.sh ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest10/SDLTest10_compile.sh</a></td></tr>
<tr><td>17</td><td>SDLTest10_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest10/SDLTest10_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest10/SDLTest10_compile_sys.sh</a></td></tr>
<tr><td>18</td><td>SDLTest10_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest10/SDLTest10_run.sh ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest10/SDLTest10_run.sh</a></td></tr>
<tr><td>19</td><td>SDLTest10_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest10/SDLTest10_run_sys.sh ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest10/SDLTest10_run_sys.sh</a></td></tr>
<tr><td>20</td><td>SDLTest10_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest10/SDLTest10_compile.bat ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest10/SDLTest10_compile.bat</a></td></tr>
<tr><td>21</td><td>SDLTest10_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest10/SDLTest10_run.bat ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest10/SDLTest10_run.bat</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>SDLTest11.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest11/SDLTest11.java ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest11/SDLTest11.java</a></td></tr>
<tr><td>23</td><td>SDLTest11_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest11/SDLTest11_compile.sh ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest11/SDLTest11_compile.sh</a></td></tr>
<tr><td>24</td><td>SDLTest11_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest11/SDLTest11_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest11/SDLTest11_compile_sys.sh</a></td></tr>
<tr><td>25</td><td>SDLTest11_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest11/SDLTest11_run.sh ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest11/SDLTest11_run.sh</a></td></tr>
<tr><td>26</td><td>SDLTest11_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest11/SDLTest11_run_sys.sh ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest11/SDLTest11_run_sys.sh</a></td></tr>
<tr><td>27</td><td>SDLTest11_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest11/SDLTest11_compile.bat ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest11/SDLTest11_compile.bat</a></td></tr>
<tr><td>28</td><td>SDLTest11_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest11/SDLTest11_run.bat ">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/20fe0e5daa24/sdljava/SDLTest11/SDLTest11_run.bat</a></td></tr>
</table>

<p>Pro správnou èinnost demonstraèních pøíkladù <strong>SDLTest9</strong> a
<strong>SDLTest11</strong> je nutné mít v&nbsp;pracovním adresáøi ulo¾en i
obrázek <strong>xscorch.bmp</strong>:</p>

<table>
<tr><th> #</th><th>Bitmapa</th><th>Umístìní souboru v&nbsp;repositáøi</th></tr>
<tr><td> 1</td><td>xscorch.bmp</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/raw-file/6fe0d3a6edeb/sdljava/img/xscorch.bmp">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/raw-file/6fe0d3a6edeb/sdljava/img/xscorch.bmp</a></td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>SDL 1.2 Documentation: SDL_Surface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_PixelFormat<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlpixelformat.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlpixelformat.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_LockSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdllocksurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdllocksurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_UnlockSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlunlocksurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlunlocksurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_LoadBMP<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlloadbmp.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlloadbmp.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_SaveBMP<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsavebmp.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsavebmp.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_BlitSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlblitsurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlblitsurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_VideoInfo<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlvideoinfo.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlvideoinfo.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_GetVideoInfo<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlgetvideoinfo.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlgetvideoinfo.html</a>
</li>

<li>Class BufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferStrategy.html</a>
</li>

<li>Class Graphics<br />
<a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/Graphics.html">http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/Graphics.html</a>
</li>

<li>Double Buffering and Page Flipping<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html</a>
</li>

<li>BufferStrategy and BufferCapabilities<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/bufferstrategy.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/bufferstrategy.html</a>
</li>

<li>Java:Tutorials:Double Buffering<br />
<a href="http://content.gpwiki.org/index.php/Java:Tutorials:Double_Buffering">http://content.gpwiki.org/index.php/Java:Tutorials:Double_Buffering</a>
</li>

<li>Double buffer in standard Java AWT<br />
<a href="http://www.codeproject.com/Articles/2136/Double-buffer-in-standard-Java-AWT">http://www.codeproject.com/Articles/2136/Double-buffer-in-standard-Java-AWT</a>
</li>

<li>Java 2D: Hardware Accelerating - Part 1 - Volatile Images<br />
<a href="http://www.javalobby.org/forums/thread.jspa?threadID=16840&tstart=0">http://www.javalobby.org/forums/thread.jspa?threadID=16840&tstart=0</a>
</li>

<li>Java 2D: Hardware Accelerating - Part 2 - Buffer Strategies<br />
<a href="http://www.javalobby.org/java/forums/t16867.html">http://www.javalobby.org/java/forums/t16867.html</a>
</li>

<li>How does paintComponent work?<br />
<a href="http://stackoverflow.com/questions/15544549/how-does-paintcomponent-work">http://stackoverflow.com/questions/15544549/how-does-paintcomponent-work</a>
</li>

<li>A Swing Architecture Overview<br />
<a href="http://www.oracle.com/technetwork/java/architecture-142923.html">http://www.oracle.com/technetwork/java/architecture-142923.html</a>
</li>

<li>Class javax.swing.JComponent<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html</a>
</li>

<li>Class java.awt.Component<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html</a>
</li>

<li>Class java.awt.Component.BltBufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.BltBufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.BltBufferStrategy.html</a>
</li>

<li>Class java.awt.Component.FlipBufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.FlipBufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.FlipBufferStrategy.html</a>
</li>

<li>Metoda java.awt.Component.isDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html#isDoubleBuffered()">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html#isDoubleBuffered()</a>
</li>

<li>Metoda javax.swing.JComponent.isDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#isDoubleBuffered()">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#isDoubleBuffered()</a>
</li>

<li>Metoda javax.swing.JComponent.setDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#setDoubleBuffered(boolean)">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#setDoubleBuffered(boolean)</a>
</li>

<li>Javadoc - tøída GraphicsDevice<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html</a>
</li>

<li>Javadoc - tøída GraphicsEnvironment<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html</a>
</li>

<li>Javadoc - tøída GraphicsConfiguration<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html</a>
</li>

<li>Javadoc - tøída DisplayMode<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html">http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html</a>
</li>

<li>Lesson: Full-Screen Exclusive Mode API<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/">http://docs.oracle.com/javase/tutorial/extra/fullscreen/</a>
</li>

<li>Full-Screen Exclusive Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html</a>
</li>

<li>Display Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html</a>
</li>

<li>Using the Full-Screen Exclusive Mode API in Java<br />
<a href="http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm">http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>GC safe-point (or safepoint) and safe-region<br />
<a href="http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html">http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html</a>
</li>

<li>Safepoints in HotSpot JVM<br />
<a href="http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html">http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html</a>
</li>

<li>Java theory and practice: Synchronization optimizations in Mustang<br />
<a href="http://www.ibm.com/developerworks/java/library/j-jtp10185/">http://www.ibm.com/developerworks/java/library/j-jtp10185/</a>
</li>

<li>How to build hsdis<br />
<a href="http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README">http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README</a>
</li>

<li>Java SE 6 Performance White Paper<br />
<a href="http://www.oracle.com/technetwork/java/6-performance-137236.html">http://www.oracle.com/technetwork/java/6-performance-137236.html</a>
</li>

<li>Lukas Stadler's Blog<br />
<a href="http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html">http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html</a>
</li>

<li>How to build hsdis-amd64.dll and hsdis-i386.dll on Windows<br />
<a href="http://dropzone.nfshost.com/hsdis.htm">http://dropzone.nfshost.com/hsdis.htm</a>
</li>

<li>PrintAssembly<br />
<a href="https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly">https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly</a>
</li>

<li>The Java Virtual Machine Specification: 3.14. Synchronization<br />
<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14</a>
</li>

<li>The Java Virtual Machine Specification: 8.3.1.4. volatile Fields<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.4. Memory Model<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.7. Non-atomic Treatment of double and long<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7</a>
</li>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (pøed verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2014</small></p>
</body>
</html>

