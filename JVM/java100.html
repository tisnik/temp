<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - základy optimalizace aplikací naprogramovaných v Javì (5)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - základy optimalizace aplikací naprogramovaných v Javì (5)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o virtuálním stroji Javy si popí¹eme nìkteré dal¹í typy optimalizací provádìných automaticky JIT pøekladaèi. Zamìøíme se jak na známé optimalizaèní metody typu rozbalení smyèek èi eliminaci volání metod, tak i na vyu¾ití ji¾ pøipravených sekvencí instrukcí (intrinsic funkce)</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - základy optimalizace aplikací naprogramovaných v Javì (5)</a></p>
<p><a href="#k02">2. Alokace pracovních registrù</a></p>
<p><a href="#k03">3. Rozbalení programových smyèek: loop unrolling</a></p>
<p><a href="#k04">4. První demonstraèní pøíklad &ndash; rozbalení smyèek</a></p>
<p><a href="#k05">5. Method inlining</a></p>
<p><a href="#k06">6. Druhý demonstraèní pøíklad &ndash; eliminace volání metod</a></p>
<p><a href="#k07">7. Pou¾ití intrinsic &bdquo;funkcí&ldquo;</a></p>
<p><a href="#k08">8. Seznam v¹ech &bdquo;intrinsic&ldquo;</a></p>
<p><a href="#k09">9. Metoda <strong>System.arraycopy()</strong></a></p>
<p><a href="#k10">10. Repositáø se zdrojovými kódy v¹ech demonstraèních i testovacích pøíkladù</a></p>
<p><a href="#k11">11. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - základy optimalizace aplikací naprogramovaných v Javì (5)</h2>

<p>V&nbsp;dne¹ní èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyce Java i o virtuálním stroji Javy</a> si struènì popí¹eme
nìkolik optimalizaèních metod provádìných JIT pøekladaèi typu client a
pøedev¹ím pak JIT pøekladaèi typu server. Úèinek dále popsaných optimalizaèních
metod si uká¾eme na nìkolika demonstraèních pøíkladech. Pøed popisem
jednotlivých optimalizaèních metod si v¹ak nejprve øeknìme, na jaké oblasti se
vlastnì JIT pøekladaèe zamìøují:</p>

<ol>

<li>Nejvìt¹ím problémem, který se JIT pøekladaèe sna¾í (nìkdy více, nìkdy ale
ji¾ ménì úspì¹nì :-) eliminovat, jsou pøístupy do operaèní pamìti. Ka¾dý
pøístup do operaèní pamìti mù¾e znamenat nutnost synchronizace vyrovnávacích
pamìtí (cache), co¾ mù¾e zpùsobit vá¾né sní¾ení výkonnosti aplikací zejména na
systémech s&nbsp;mnoha jádry. Právì zde se uplatòuje Amdahlùv zákon
(vztah).</li>

<li>Dal¹ím problémem je volání metod, které je takté¾ vhodné eliminovat.
Pøekladaèe se sna¾í zjistit, které metody jsou natolik jednoduché a pøitom
èasto volané, aby se namísto jejich skuteèného volání mohlo nakopírovat tìlo
metody pøímo do volajícího kódu. Tato optimalizace &ndash; zde zalo¾ená na
reálných datech získaných pøi bìhu aplikace! &ndash; se nazývá <i>method
inlining</i>.</li>

<li>Tøetí problém zpùsobuje pou¾ívání zámkù. I zde se pøekladaèe sna¾í rùzným
zpùsobem buï zcela pou¾ití zámkù eliminovat (nìkdy to skuteènì mo¾né je),
popø.&nbsp;pou¾ít jeden a tý¾ zámek pro del¹í úsek kódu.</li>

<li>Na mnoha architekturách je takté¾ vhodné eliminovat podmínìné a nepodmínìné
skoky, popø.&nbsp;pøerovnat kód takovým zpùsobem, aby prediktory skokù dokázaly
správnì odhadnout, zda se podmínìný skok provede èi nikoli. Základní
optimalizaèní metodou je zde rozbalování smyèek (<i>loop unrolling</i>).</li>

<li>Nìkteré metody jsou tak èasto pou¾ívané a souèasnì tak obecné, ¾e se
vyplatí dopøedu si pøipravit optimalizovanou sekvenci strojových instrukcí
implementujících tyto metody na cílové platformì. Klasickým pøíkladem je metoda
<strong>System.arraycopy()</strong>, její¾ kód je ji¾ pøipraven a to hned
v&nbsp;nìkolika variantách optimalizovaných pro rùzné pøípady, které mohou
v&nbsp;praxi nastat (pøekryv polí, zarovnání èi naopak nezarovnání polí
atd.).</li>

</ol>



<p><a name="k02"></a></p>
<h2 id="k02">2. Alokace pracovních registrù</h2>

<p>JIT pøekladaèe typu client i server jsou v&nbsp;souèasnosti implementovány
na mikroprocesorových architekturách zalo¾ených na pracovních registrech a
nikoli napøíklad na zásobníku operandù (tyto alternativní architektury jsou
dnes spí¹e minoritní). To mj.&nbsp;znamená, ¾e JIT pøekladaè musí vhodným
zpùsobem transformovat pùvodní bajtkód zalo¾ený na pou¾ití zásobníku operandù
na strojový kód, v&nbsp;nìm¾ se pou¾ívají pracovní registry cílové
mikroprocesorové architektury (i686, x86_64, SPARC, ARM, AArch64...). Poèet
dostupných pracovních registrù i zpùsob jejich vyu¾ití je na ka¾dé
mikroprocesorové architektuøe odli¹ný, co¾ je jeden z&nbsp;dùvodù, proè se JIT
pøekladaèe musí pro ka¾dou novou architekturu v¾dy z&nbsp;urèité èásti pøepsat;
co¾ je mimochodem pomìrnì zajímavé téma, kterému se je¹tì v&nbsp;tomto seriálu
budeme podrobnìji vìnovat, zejména s&nbsp;ohledem na právì vznikající C1 a C2
JIT pøekladaèe urèené pro mikroprocesory AArch64.</p>

<p>Pro alokaci registrù se vyu¾ívají dva odli¹né zpùsoby. JIT pøekladaè typu
client je &ndash; jak ji¾ víme z&nbsp;pøedchozích èástí tohoto seriálu &ndash;
zamìøen pøedev¹ím na rychlost pøekladu a nikoli na kvalitu výsledného kódu, a
proto pou¾ívá jednoduchou lineární alokaci registrù soubì¾nì s&nbsp;takzvanými
¹ablonami kódu (<i>code templates</i>), v&nbsp;nich¾ se pro implementaci
rùzných operací pou¾ívají v¾dy stejné registry. Naproti tomu JIT pøekladaè typu
server ji¾ pøi alokaci registrù vytváøí graf dostupnosti a sna¾í se registry
vyu¾ít optimálním zpùsobem, zejména s&nbsp;ohledem na to, aby se mezivýsledky
rùzných operací nemusely ukládat do pamìti a aby pøesuny dat mezi registry byly
minimalizovány. Na vìt¹inì souèasných architektur je navíc alokace rozdìlena
minimálnì na dvì èásti &ndash; registry pro ALU operace a adresování a registry
pro provádìní operací s&nbsp;èísly s&nbsp;plovoucí øádovou èárkou (<i>floating
point</i>). K&nbsp;této problematice se takté¾ je¹tì vrátíme.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Rozbalení programových smyèek: loop unrolling</h2>

<p>Jednou ze základních optimalizací, o ní¾ jsme se zmiòovali <a
href="#k01">v&nbsp;první kapitole</a>, je rozbalení programových smyèek neboli
<i>loop unrolling</i>. Pøekladaèe se k&nbsp;této optimalizaci uchylují
pøedev¹ím z&nbsp;toho dùvodu, ¾e moderní mikroprocesory obsahují dlouhé
pipeline. Pøi výskytu skoku se musí vyøe¹it problém, co se má udìlat
s&nbsp;instrukcemi, které se nachází v&nbsp;rozpracovaném stavu uvnitø
pipeline. Vìt¹inou nastává nejhor¹í pøípad, kdy se tyto instrukce musí zahodit
a po provedení skoku se musí pipeline znovu naplnit, tentokrát jinými
instrukcemi (zde tro¹ku celý problém zjednodu¹uji). To má samozøejmì za
následek sní¾ení výpoèetního výkonu, které mù¾e být nìkdy velmi radikální
(napøíklad Pentium 4 má pipeline rozdìlenou na více ne¾ 30 øezù, tj.&nbsp;mù¾e
se v&nbsp;ní nacházet tøicet rozpracovaných instrukcí). Je tedy vhodné nìjakým
zpùsobem skoky co nejvíce omezit èi sní¾it jejich negativní dopad na rychlost
bìhu programu. První metody, tj.&nbsp;omezení skokù, jsou vesmìs zále¾itostí
pøekladaèe èi ruèní optimalizace kódu. A právì sem spadá i zmínìné rozbalení
smyèek.</p>

<p>Vìt¹inou se v¹ak neprovádí jen jednoduché rozbalení smyèky ve stylu, ¾e by
se napøíklad sekvence instrukcí pro tøi po sobì jdoucí iterace jednodu¹e
nakopírovaly za sebe, ale JIT pøekladaè se souèasnì sna¾í i o eliminaci
zbyteèných pøesunù dat mezi operaèní pamìtí a pracovními registry. To je jeden
z&nbsp;dùvodù, proè je pøi pohledu na disassemblovaný kód nìkdy velmi tì¾ké
urèit, jak pøesnì se rozbalení smyèky provedlo. Navíc se ukazuje, ¾e
v&nbsp;nìkterých pøípadech by schopný programátor dokázal výsledný strojový kód
optimalizovat je¹tì lépe ne¾ JIT pøekladaè (ten je toti¾ omezen mj.&nbsp;i
safepointy, které vìt¹inou pøi optimalizacích nepøekraèuje), ov¹em to je fakt,
který lze aplikovat i napøíklad na klasické pøekladaèe programovacích jazykù
typu C, C++ èi Fortran.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. První demonstraèní pøíklad &ndash; rozbalení smyèek</h2>

<p>Uka¾me si nyní zpùsob rozbalení smyèky u demonstraèního programu pro výpoèet
faktoriálu. Faktoriál je vypoèten v&nbsp;metodì <strong>factorial</strong>,
v&nbsp;ní¾ je výpoèet realizován jednoduchou poèítanou programovou smyèkou. Pro
jednoduchost jsou výpoèty provádìny s&nbsp;výsledkem typu <strong>int</strong>,
proto¾e se budeme dívat na disassemblovaný kód pro platformu <i>x86</i>, kde by
výpoèty s&nbsp;64bitovými èísly byly pomìrnì kryptické (kombinace instrukcí
<strong>mul</strong> a <strong>imul</strong> atd.). Zdrojový kód demonstraèního
pøíkladu vypadá následovnì:</p>

<pre>
public class <strong>Factorial</strong> {
&nbsp;
    public static int <strong>factorial</strong>(int n) {
        if (n &lt;= 1) return 1;
        int result = 1;
        for (int i = 1; i &lt;= n; i++) {
            result *= i;
        }
        return result;
    }
&nbsp;
    public static void <strong>testFactorial</strong>() {
        for (int i = 0; i &lt; 16; i++) {
            System.out.println(i + "! = " + factorial(i));
        }
    }
&nbsp;
    public static void <strong>main</strong>(String[] args) {
        for (int i = 0; i &lt; 100; i++) {
            testFactorial();
        }
    }
}
</pre>

<p>Metoda <strong>factorial</strong> se pøelo¾í do následující sekvence
instrukcí bajtkódu. Vlastní programová smyèka je od ostatního kódu pro vìt¹í
pøehlednost oddìlena:</p>

<pre>
  public static int <strong>factorial</strong>(int);
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=3, args_size=1
         0: iload_0
         1: iconst_1
         2: if_icmpgt     7
         5: iconst_1
         6: ireturn
         7: iconst_1
         8: istore_1
         9: iconst_1
        10: istore_2
        =================================
        11: iload_2
        12: iload_0
        13: if_icmpgt     26
        16: iload_1
        17: iload_2
        18: imul
        19: istore_1
        20: iinc          2, 1
        23: goto          11
        =================================
        26: iload_1
        27: ireturn
      LineNumberTable:
        line 4: 0
        line 5: 7
        line 6: 9
        line 7: 16
        line 6: 20
        line 9: 26
      StackMapTable: number_of_entries = 3
           frame_type = 7 /* same */
           frame_type = 253 /* append */
             offset_delta = 3
        locals = [ int, int ]
           frame_type = 250 /* chop */
          offset_delta = 14
</pre>

<p>A zde se ji¾ mù¾eme podívat na výsledný (disassemblovaný) strojový kód, kde
ji¾ do¹lo k&nbsp;rozbalení poèítané programové smyèky. Pov¹imnìte si, jakým
zpùsobem nám disassembler oznamuje mapování strojových instrukcí na instrukce
bajtkódu (poznámky obsahující jméno metody s&nbsp;indexem za zavináèem):</p>

<pre>
Decoding compiled method 0x009bab88:
Code:
[Entry Point]
[Verified Entry Point]
[Constants]
[Exception Handler]
[Stub Code]
  0x009bad40: jmp    0x009b7240         ;   {no_reloc}
[Deopt Handler Code]
  0x009bad45: push   $0x9bad45          ;   {section_word}
  0x009bad4a: jmp    0x0099e280         ;   {runtime_call}
  0x009bad4f: hlt    
  # {method} <strong>'factorial' '(I)I' in 'Factorial'</strong>
  # parm0:    ecx       = int
  #           [sp+0x10]  (sp of caller)
  0x009bac80: mov    %eax,0xffffc000(%esp)
  0x009bac87: push   %ebp
  0x009bac88: sub    $0x8,%esp          ;*synchronization entry
                                        ; - Factorial::factorial@-1 (line 4)
  0x009bac8b: mov    $0x1,%eax
  0x009bac90: cmp    $0x1,%ecx
  0x009bac93: jle    0x009bad0a         ;*if_icmpgt
                                        ; - Factorial::factorial@2 (line 4)
  0x009bac95: cmp    $0x1,%ecx
  0x009bac98: jl     0x009bad0a         ;*if_icmpgt
                                        ; - Factorial::factorial@13 (line 6)
  0x009bac9a: cmp    $0x7ffffffe,%ecx
  0x009baca0: jg     0x009bad15         ;*iload_1
                                        ; - Factorial::factorial@16 (line 7)
  0x009baca2: mov    %ecx,%edi
  0x009baca4: inc    %edi
  0x009baca5: add    $0xfffffffe,%ecx
  0x009baca8: mov    $0x80000000,%ebx
  0x009bacad: cmp    %ecx,%edi
  0x009bacaf: cmovl  %ebx,%ecx
  0x009bacb2: mov    $0x2,%edx
  0x009bacb7: cmp    $0x2,%ecx
  0x009bacba: jle    0x009bad25
  0x009bacbc: mov    $0x2,%eax
  0x009bacc1: jmp    0x009bace2
  0x009bacc3: mov    %esi,%ecx
  0x009bacc5: imul   %eax,%ecx
  0x009bacc8: mov    %ecx,%eax          ;*imul
                                        ; - Factorial::factorial@18 (line 7)
  0x009bacca: inc    %esi               ;*iinc
                                        ; - Factorial::factorial@20 (line 6)
  0x009baccb: cmp    %edi,%esi
  0x009baccd: jl     0x009bacc3         ;*if_icmpgt
                                        ; - Factorial::factorial@13 (line 6)
  0x009baccf: jmp    0x009bad0a
  0x009bacd1: nopw   0x0(%eax,%eax,1)
  0x009bacdc: xchg   %ax,%ax
  0x009bace0: mov    %esi,%edx          ;*imul
                                        ; - Factorial::factorial@18 (line 7)
  0x009bace2: mov    %edx,%ebx
  0x009bace4: add    $0x3,%ebx
  0x009bace7: mov    %edx,%esi
  0x009bace9: add    $0x4,%esi          ;*iinc
                                        ; - Factorial::factorial@20 (line 6)
  0x009bacec: mov    %edx,%ebp
  0x009bacee: add    $0x2,%ebp
  0x009bacf1: inc    %edx
  0x009bacf2: imul   %eax,%edx
  0x009bacf5: imul   %ebp,%edx
  0x009bacf8: imul   %edx,%ebx
  0x009bacfb: mov    %esi,%eax
  0x009bacfd: imul   %ebx,%eax          ;*imul
                                        ; - Factorial::factorial@18 (line 7)
  0x009bad00: cmp    %ecx,%esi
  0x009bad02: jl     0x009bace0         ;*if_icmpgt
                                        ; - Factorial::factorial@13 (line 6)
  0x009bad04: cmp    %edi,%esi
  0x009bad06: jl     0x009bacca
  0x009bad08: mov    %ebx,%eax
  0x009bad0a: add    $0x8,%esp
  0x009bad0d: pop    %ebp
  0x009bad0e: test   %eax,0x940000      ;   {poll_return}
  0x009bad14: ret    
  0x009bad15: mov    %ecx,%ebp
  0x009bad17: mov    $0xffffff7e,%ecx
  0x009bad1c: xchg   %ax,%ax
  0x009bad1f: call   0x0099dd00         ; OopMap{off=164}
                                        ;*iload_1
                                        ; - Factorial::factorial@16 (line 7)
                                        ;   {runtime_call}
  0x009bad24: int3                      ;*iload_1
                                        ; - Factorial::factorial@16 (line 7)
  0x009bad25: mov    $0x2,%esi
  0x009bad2a: mov    $0x2,%eax
  0x009bad2f: mov    $0x1,%ebx
  0x009bad34: jmp    0x009bad04         ;*if_icmpgt
                                        ; - Factorial::factorial@13 (line 6)
  0x009bad36: hlt
  0x009bad37: hlt
  0x009bad38: hlt
  0x009bad39: hlt
  0x009bad3a: hlt
  0x009bad3b: hlt
  0x009bad3c: hlt
  0x009bad3d: hlt
  0x009bad3e: hlt
  0x009bad3f: hlt
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Method inlining</h2>

<p>Dal¹í optimalizaèní metodou, o ní¾ jsme se zmínili <a
href="#k01">v&nbsp;první kapitole</a>, je eliminace volání metod neboli
<i>method inlining</i>. Tato optimalizaèní metoda je zalo¾ena na známém faktu,
¾e volání metod/funkcí s&nbsp;krátkým (pøesnìji øeèeno jednoduchým) tìlem je
neekonomické, a to z&nbsp;dùvodu nutnosti pøípravy parametrù pro volanou funkci
i kvùli vlastní re¾ii volání (strojové instrukce typu <strong>call</strong> a
<strong>return</strong>, popø.&nbsp;na nìkterých architekturách instrukce typu
<strong>BL=branch+link</strong>). JIT pøekladaè tedy doká¾e detekovat metody,
jejich¾ volání by bylo vhodné nahradit vlo¾ením tìla metody pøímo do volající
metody. Jedním z&nbsp;parametrù virtuálního stroje, který ovlivòuje rozhodování
o pou¾ití této optimalizaèní metody, je parametr nazvaný
<strong>InlineSmallCode</strong>, který je v&nbsp;pøípadì architektury x86
nastaven na hodnotu 1000 (velikost kódu) a parametr
<strong>MinInliningThreshold</strong> urèující, kolikrát musí být metoda volána
v&nbsp;èase bìhu aplikace.</p>

<p>Základní informaci o tom, které metody jsou touto optimalizaèní technikou
nahrazeny svým tìlem, je mo¾né získat následujícím zpùsobem:</p>

<pre>
java -server -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining FooBar
</pre>

<p>Podívejme se na pøíklad pou¾ití tìchto dvou pøepínaèù ve chvíli, kdy jsou
pou¾ity pøi spou¹tìní virtuálního stroje s&nbsp;demonstraèním benchmarkem <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/05d05b5fd08d/jit/MandelbrotRenderer.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/05d05b5fd08d/jit/MandelbrotRenderer.java</a>,
který jsme si popsali ji¾ v&nbsp;devadesáté sedmé èásti tohoto seriálu:</p>

<a href="http://i.iinfo.cz/images/12/mandel.png"><img src="http://i.iinfo.cz/images/12/mandel-prev.png" class="image-145955" width="270" height="270" alt="&#160;" /></a>

<p>Informace o method inliningu:</p>

<pre>
java -server -XX:CompileThreshold=10000 -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining MandelbrotRenderer
</pre>

<pre>
                            @ 17   sun.java2d.StateTrackableDelegate::markDirty (6 bytes)   inline (hot)
                            @ 59   MandelbrotRenderer::iteration (93 bytes)   inline (hot)
                            @ 70   java.awt.image.DataBufferByte::setElem (21 bytes)   inline (hot)
                              @ 17   sun.java2d.StateTrackableDelegate::markDirty (6 bytes)   inline (hot)
                            @ 963   com.sun.imageio.plugins.png.RowFilter::filterRow (426 bytes)   too big
                            @ 971   com.sun.imageio.plugins.png.IDATOutputStream::write (17 bytes)   executed &lt; MinInliningThreshold times
                            @ 990   com.sun.imageio.plugins.png.IDATOutputStream::write (43 bytes)   too big
                            @ 1041   javax.imageio.ImageWriter::processImageProgress (56 bytes)   too big
              s             @ 1045   javax.imageio.ImageWriter::abortRequested (5 bytes)   inline (hot)
                            @ 317   java.awt.Rectangle::&lt;init&gt; (26 bytes)   inline (hot)
                              @ 1   java.awt.geom.Rectangle2D::&lt;init&gt; (5 bytes)   inline (hot)
                                @ 1   java.awt.geom.RectangularShape::&lt;init&gt; (5 bytes)   inline (hot)
                                  @ 1   java.lang.Object::&lt;init&gt; (1 bytes)   inline (hot)
                            @ 325   java.awt.image.BufferedImage::getData (113 bytes)   too big
                            @ 372   sun.awt.image.ByteInterleavedRaster::getPixels (865 bytes)   too big
                            @ 377   java.awt.image.BufferedImage::getColorModel (5 bytes)   inline (hot)
                            @ 382   java.awt.image.ColorModel::isAlphaPremultiplied (5 bytes)   inline (hot)
                            @ 390   sun.awt.image.ByteInterleavedRaster::createCompatibleWritableRaster (13 bytes)   never executed
                            @ 399   java.awt.image.Raster::getMinX (5 bytes)   inline (hot)
                            @ 404   java.awt.image.Raster::getMinY (5 bytes)   inline (hot)
                            @ 409   java.awt.image.Raster::getWidth (5 bytes)   inline (hot)
                            @ 414   java.awt.image.Raster::getHeight (5 bytes)   inline (hot)
                            @ 423   java.awt.image.BufferedImage::getColorModel (5 bytes)   inline (hot)
                            @ 439   java.awt.image.Raster::getMinX (5 bytes)   inline (hot)
                            @ 444   java.awt.image.Raster::getMinY (5 bytes)   inline (hot)
                            @ 449   java.awt.image.Raster::getWidth (5 bytes)   inline (hot)
                            @ 454   java.awt.image.Raster::getHeight (5 bytes)   inline (hot)
                            @ 963   com.sun.imageio.plugins.png.RowFilter::filterRow (426 bytes)   too big
                            @ 971   com.sun.imageio.plugins.png.IDATOutputStream::write (17 bytes)   executed &lt; MinInliningThreshold times
                            @ 990   com.sun.imageio.plugins.png.IDATOutputStream::write (43 bytes)   too big
                            @ 1041   javax.imageio.ImageWriter::processImageProgress (56 bytes)   too big
              s             @ 1045   javax.imageio.ImageWriter::abortRequested (5 bytes)   inline (hot)
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Druhý demonstraèní pøíklad &ndash; eliminace volání metod</h2>

<p>Zkusme si nyní upravit pøíklad pro výpoèet faktoriálu takovým zpùsobem, aby
byl JIT pøekladaè typu server donucen provést eliminaci volání metod,
tj.&nbsp;<i>method inlining</i>. Je to ve skuteènosti velmi jednoduché,
postaèuje toti¾ vlastní výpoèet provádìný pùvodnì v&nbsp;poèítané programové
smyèce v&nbsp;metodì <strong>factorial()</strong> &bdquo;refaktorovat&ldquo; do
zvlá¹tní metody <strong>calcResult()</strong>, která pouze vrátí výsledek
souèinu svých dvou operandù. Nový demonstraèní pøíklad vypadá následovnì:</p>

<pre>
public class <strong>Factorial2</strong> {
&nbsp;
    public static int <strong>factorial</strong>(int n) {
        if (n &lt;= 1) return 1;
        int result = 1;
        for (int i = 1; i &lt;= n; i++) {
            result = calcResult(result, i);
        }
        return result;
    }
&nbsp;
    public static int <strong>calcResult</strong>(int result, int i) {
        return result * i;
    }
&nbsp;
    public static void <strong>testFactorial</strong>() {
        for (int i = 0; i &lt; 16; i++) {
            System.out.println(i + "! = " + factorial(i));
        }
    }
&nbsp;
    public static void <strong>main</strong>(String[] args) {
        for (int i = 0; i &lt; 100; i++) {
            testFactorial();
        }
    }
}
</pre>

<p>Snadno se mù¾eme pøesvìdèit o tom, ¾e v&nbsp;bajtkódu je skuteènì statická
metoda <strong>calcResult()</strong> volána, proto¾e vlastní pøekladaè
<strong>javac</strong> ¾ádné významné optimalizace neprovádí:</p>

<pre>
  public static int <strong>factorial</strong>(int);
    Code:
       0: iload_0       
       1: iconst_1      
       2: if_icmpgt     7
       5: iconst_1      
       6: ireturn       
       7: iconst_1      
       8: istore_1      
       9: iconst_1      
      10: istore_2      
      11: iload_2       
      12: iload_0       
      13: if_icmpgt     28
      16: iload_1       
      17: iload_2       
      18: <strong>invokestatic  #2                  // Method calcResult:(II)I</strong>
      21: istore_1      
      22: iinc          2, 1
      25: goto          11
      28: iload_1       
      29: ireturn       
</pre>

<p>Bajtkód metody <strong>calcResult()</strong> je skuteènì velmi jednoduchý
&ndash; typický adept na method inlining:</p>

<pre>
  public static int <strong>calcResult</strong>(int, int);
    Code:
       0: iload_0       
       1: iload_1       
       2: imul          
       3: ireturn       
</pre>

<p>Nyní se podívejme na to, jak byla metoda <strong>factorial()</strong>
pøelo¾ena JIT pøekladaèem typu server:</p>

<pre>
Decoding compiled method 0x009bab88:
Code:
[Entry Point]
[Verified Entry Point]
[Constants]
  # {method} <strong>'factorial' '(I)I' in 'Factorial2'</strong>
  # parm0:    ecx       = int
  #           [sp+0x10]  (sp of caller)
  0x009bac80: mov    %eax,0xffffc000(%esp)
  0x009bac87: push   %ebp
  0x009bac88: sub    $0x8,%esp          ;*synchronization entry
                                        ; - Factorial2::factorial@-1 (line 4)
  0x009bac8b: mov    $0x1,%eax
  0x009bac90: cmp    $0x1,%ecx
  0x009bac93: jle    0x009bad0a         ;*if_icmpgt
                                        ; - Factorial2::factorial@2 (line 4)
  0x009bac95: cmp    $0x1,%ecx
  0x009bac98: jl     0x009bad0a         ;*if_icmpgt
                                        ; - Factorial2::factorial@13 (line 6)
  0x009bac9a: cmp    $0x7ffffffe,%ecx
  0x009baca0: jg     0x009bad15         ;*iload_1
                                        ; - Factorial2::factorial@16 (line 7)
  0x009baca2: mov    %ecx,%edi
  0x009baca4: inc    %edi
  0x009baca5: add    $0xfffffffe,%ecx
  0x009baca8: mov    $0x80000000,%ebx
  0x009bacad: cmp    %ecx,%edi
  0x009bacaf: cmovl  %ebx,%ecx
  0x009bacb2: mov    $0x2,%edx
  0x009bacb7: cmp    $0x2,%ecx
  0x009bacba: jle    0x009bad25
  0x009bacbc: mov    $0x2,%eax
  0x009bacc1: jmp    0x009bace2
  ======================================
  0x009bacc3: mov    %esi,%ecx
  0x009bacc5: imul   %eax,%ecx
  0x009bacc8: mov    %ecx,%eax          ;*imul
                                        ; - Factorial2::calcResult@2 (line 13)
                                        ; - Factorial2::factorial@18 (line 7)
  ======================================
  0x009bacca: inc    %esi               ;*iinc
                                        ; - Factorial2::factorial@22 (line 6)
  0x009baccb: cmp    %edi,%esi
  0x009baccd: jl     0x009bacc3         ;*if_icmpgt
                                        ; - Factorial2::factorial@13 (line 6)
  0x009baccf: jmp    0x009bad0a
  0x009bacd1: nopw   0x0(%eax,%eax,1)
  0x009bacdc: xchg   %ax,%ax
  0x009bace0: mov    %esi,%edx          ;*imul
                                        ; - Factorial2::calcResult@2 (line 13)
                                        ; - Factorial2::factorial@18 (line 7)
  0x009bace2: mov    %edx,%ebx
  0x009bace4: add    $0x3,%ebx
  0x009bace7: mov    %edx,%esi
  0x009bace9: add    $0x4,%esi          ;*iinc
                                        ; - Factorial2::factorial@22 (line 6)
  0x009bacec: mov    %edx,%ebp
  0x009bacee: add    $0x2,%ebp
  ======================================
  0x009bacf1: inc    %edx
  0x009bacf2: imul   %eax,%edx
  0x009bacf5: imul   %ebp,%edx
  0x009bacf8: imul   %edx,%ebx
  0x009bacfb: mov    %esi,%eax
  0x009bacfd: imul   %ebx,%eax          ;*imul
                                        ; - Factorial2::calcResult@2 (line 13)
                                        ; - Factorial2::factorial@18 (line 7)
  ======================================
  0x009bad00: cmp    %ecx,%esi
  0x009bad02: jl     0x009bace0         ;*if_icmpgt
                                        ; - Factorial2::factorial@13 (line 6)
  0x009bad04: cmp    %edi,%esi
  0x009bad06: jl     0x009bacca
  0x009bad08: mov    %ebx,%eax
  0x009bad0a: add    $0x8,%esp
  0x009bad0d: pop    %ebp
  0x009bad0e: test   %eax,0x940000      ;   {poll_return}
  0x009bad14: ret    
  0x009bad15: mov    %ecx,%ebp
  0x009bad17: mov    $0xffffff7e,%ecx
  0x009bad1c: xchg   %ax,%ax
  0x009bad1f: call   0x0099dd00         ; OopMap{off=164}
                                        ;*iload_1
                                        ; - Factorial2::factorial@16 (line 7)
                                        ;   {runtime_call}
  0x009bad24: int3                      ;*iload_1
                                        ; - Factorial2::factorial@16 (line 7)
  0x009bad25: mov    $0x2,%esi
  0x009bad2a: mov    $0x2,%eax
  0x009bad2f: mov    $0x1,%ebx
  0x009bad34: jmp    0x009bad04         ;*if_icmpgt
                                        ; - Factorial2::factorial@13 (line 6)
  0x009bad36: hlt    
  0x009bad37: hlt    
  0x009bad38: hlt    
  0x009bad39: hlt    
  0x009bad3a: hlt    
  0x009bad3b: hlt    
  0x009bad3c: hlt    
  0x009bad3d: hlt    
  0x009bad3e: hlt    
  0x009bad3f: hlt    
[Exception Handler]
[Stub Code]
  0x009bad40: jmp    0x009b7240         ;   {no_reloc}
[Deopt Handler Code]
  0x009bad45: push   $0x9bad45          ;   {section_word}
  0x009bad4a: jmp    0x0099e280         ;   {runtime_call}
  0x009bad4f: hlt    
</pre>

<p>Z&nbsp;výpisu je patrné, ¾e se skuteènì provedl method inlining (¾ádné
<strong>call</strong>) a takté¾ rozbalení programové smyèky.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Pou¾ití intrinsic &bdquo;funkcí&ldquo;</h2>

<p>Poslední optimalizaèní technika, kterou se v&nbsp;dne¹ním èlánku budeme
zabývat, je zalo¾ena na my¹lence, ¾e nìkteré standardní metody jsou pou¾ívané
velmi èasto a souèasnì i provádí èasovì nároèné èinnosti, tak¾e by bylo vhodné,
aby byly tyto metody ji¾ dopøedu implementovány a optimalizovány. Jedná se
napøíklad o nìkteré metody (èi pøesnìji øeèeno funkce), které lze nalézt ve
tøídì <strong>java.lang.Math</strong>. Tyto metody/funkce (napøíklad
goniometrické funkce) jsou implementovány takovým zpùsobem, ¾e v&nbsp;nìkterých
pøípadech vùbec nedojde k&nbsp;volání pøíslu¹ných bìhových nativních funkcí,
ale namísto toho jsou pøímo vygenerovány instrukce pro matematický koprocesor.
Pøíkladem mù¾e být interní funkce JIT pøekladaèe generující dvojici bajtù,
které ve strojovém kódu znamenají výpoèet hodnoty sinus:</p>

<pre>
void Assembler::fsin() {
  emit_byte(0xD9);
  emit_byte(0xFE);
}
</pre>

<p>Dal¹ím pøíkladem mù¾e být implementace metody
<strong>String.indexOf()</strong>, kterou je takté¾ mo¾né nahradit
optimalizovanou sekvencí instrukcí (hledání tak je mo¾né provádìt po osmici
bajtù apod.).</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Seznam v¹ech &bdquo;intrinsic&ldquo;</h2>

<p>Seznam v¹ech tzv.&nbsp;<i>intrinsic</i> lze nalézt v&nbsp;hlavièkovém
souboru <strong>vmSymbols.hpp</strong> (jedná se o souèást OpenJDK):</p>

<pre>
Jméno generující funkce        Tøída
_hashCode,                     java_lang_Object
_getClass,                     java_lang_Object
_clone,                        java_lang_Object
_dabs,                         java_lang_Math
_dsin,                         java_lang_Math
_dcos,                         java_lang_Math
_dtan,                         java_lang_Math
_datan2,                       java_lang_Math
_dsqrt,                        java_lang_Math
_dlog,                         java_lang_Math
_dlog10,                       java_lang_Math
_dpow,                         java_lang_Math
_dexp,                         java_lang_Math
_min,                          java_lang_Math
_max,                          java_lang_Math
_floatToRawIntBits,            java_lang_Float
_floatToIntBits,               java_lang_Float
_intBitsToFloat,               java_lang_Float
_doubleToRawLongBits,          java_lang_Double
_doubleToLongBits,             java_lang_Double
_longBitsToDouble,             java_lang_Double
_numberOfLeadingZeros_i,       java_lang_Integer
_numberOfLeadingZeros_l,       java_lang_Long
_numberOfTrailingZeros_i,      java_lang_Integer
_numberOfTrailingZeros_l,      java_lang_Long
_bitCount_i,                   java_lang_Integer
_bitCount_l,                   java_lang_Long
_reverseBytes_i,               java_lang_Integer
_reverseBytes_l,               java_lang_Long
_reverseBytes_c,               java_lang_Character
_reverseBytes_s,               java_lang_Short
_identityHashCode,             java_lang_System
_currentTimeMillis,            java_lang_System
_nanoTime,                     java_lang_System
_arraycopy,                    java_lang_System
_isInterrupted,                java_lang_Thread
_currentThread,                java_lang_Thread
_isAssignableFrom,             java_lang_Class
_isInstance,                   java_lang_Class
_getModifiers,                 java_lang_Class
_isInterface,                  java_lang_Class
_isArray,                      java_lang_Class
_isPrimitive,                  java_lang_Class
_getSuperclass,                java_lang_Class
_getComponentType,             java_lang_Class
_getClassAccessFlags,          sun_reflect_Reflection
_getLength,                    java_lang_reflect_Array
_getCallerClass,               sun_reflect_Reflection
_newArray,                     java_lang_reflect_Array
_copyOf,                       java_util_Arrays
_copyOfRange,                  java_util_Arrays
_equalsC,                      java_util_Arrays
_compareTo,                    java_lang_String
_indexOf,                      java_lang_String
_equals,                       java_lang_String
_checkIndex,                   java_nio_Buffer
_Reference_get,                java_lang_ref_Reference
_get_AtomicLong,               sun_misc_AtomicLongCSImpl
_attemptUpdate,                sun_misc_AtomicLongCSImpl
_allocateInstance,             sun_misc_Unsafe
_copyMemory,                   sun_misc_Unsafe
_park,                         sun_misc_Unsafe
_unpark,                       sun_misc_Unsafe
_getObject,                    sun_misc_Unsafe
_getBoolean,                   sun_misc_Unsafe
_getByte,                      sun_misc_Unsafe
_getShort,                     sun_misc_Unsafe
_getChar,                      sun_misc_Unsafe
_getInt,                       sun_misc_Unsafe
_getLong,                      sun_misc_Unsafe
_getFloat,                     sun_misc_Unsafe
_getDouble,                    sun_misc_Unsafe
_putObject,                    sun_misc_Unsafe
_putBoolean,                   sun_misc_Unsafe
_putByte,                      sun_misc_Unsafe
_putShort,                     sun_misc_Unsafe
_putChar,                      sun_misc_Unsafe
_putInt,                       sun_misc_Unsafe
_putLong,                      sun_misc_Unsafe
_putFloat,                     sun_misc_Unsafe
_putDouble,                    sun_misc_Unsafe
_getObjectVolatile,            sun_misc_Unsafe
_getBooleanVolatile,           sun_misc_Unsafe
_getByteVolatile,              sun_misc_Unsafe
_getShortVolatile,             sun_misc_Unsafe
_getCharVolatile,              sun_misc_Unsafe
_getIntVolatile,               sun_misc_Unsafe
_getLongVolatile,              sun_misc_Unsafe
_getFloatVolatile,             sun_misc_Unsafe
_getDoubleVolatile,            sun_misc_Unsafe
_putObjectVolatile,            sun_misc_Unsafe
_putBooleanVolatile,           sun_misc_Unsafe
_putByteVolatile,              sun_misc_Unsafe
_putShortVolatile,             sun_misc_Unsafe
_putCharVolatile,              sun_misc_Unsafe
_putIntVolatile,               sun_misc_Unsafe
_putLongVolatile,              sun_misc_Unsafe
_putFloatVolatile,             sun_misc_Unsafe
_putDoubleVolatile,            sun_misc_Unsafe
_getByte_raw,                  sun_misc_Unsafe
_getShort_raw,                 sun_misc_Unsafe
_getChar_raw,                  sun_misc_Unsafe
_getInt_raw,                   sun_misc_Unsafe
_getLong_raw,                  sun_misc_Unsafe
_getFloat_raw,                 sun_misc_Unsafe
_getDouble_raw,                sun_misc_Unsafe
_getAddress_raw,               sun_misc_Unsafe
_putByte_raw,                  sun_misc_Unsafe
_putShort_raw,                 sun_misc_Unsafe
_putChar_raw,                  sun_misc_Unsafe
_putInt_raw,                   sun_misc_Unsafe
_putLong_raw,                  sun_misc_Unsafe
_putFloat_raw,                 sun_misc_Unsafe
_putDouble_raw,                sun_misc_Unsafe
_putAddress_raw,               sun_misc_Unsafe
_compareAndSwapObject,         sun_misc_Unsafe
_compareAndSwapInt,            sun_misc_Unsafe
_putOrderedObject,             sun_misc_Unsafe
_putOrderedLong,               sun_misc_Unsafe
_putOrderedInt,                sun_misc_Unsafe
_prefetchRead,                 sun_misc_Unsafe
_prefetchWrite,                sun_misc_Unsafe
_prefetchReadStatic,           sun_misc_Unsafe
_prefetchWriteStatic,          sun_misc_Unsafe
_fillInStackTrace,             java_lang_Throwable
_StringBuilder_void,           java_lang_StringBuilder
_StringBuilder_int,            java_lang_StringBuilder
_StringBuilder_String,         java_lang_StringBuilder
_StringBuilder_append_char,    java_lang_StringBuilder
_StringBuilder_append_int,     java_lang_StringBuilder
_StringBuilder_append_String , java_lang_StringBuilder
_StringBuilder_toString,       java_lang_StringBuilder
_StringBuffer_void,            java_lang_StringBuffer
_StringBuffer_int,             java_lang_StringBuffer
_StringBuffer_String,          java_lang_StringBuffer
_StringBuffer_append_char,     java_lang_StringBuffer
_StringBuffer_append_int,      java_lang_StringBuffer
_StringBuffer_append_String,   java_lang_StringBuffer
_StringBuffer_toString,        java_lang_StringBuffer
_Integer_toString,             java_lang_Integer
_String_String,                java_lang_String
_Object_init,                  java_lang_Object
_invoke,                       java_lang_reflect_Method
_checkSpreadArgument,          java_lang_invoke_MethodHandleNatives
_invokeExact,                  java_lang_invoke_MethodHandle
_invokeGeneric,                java_lang_invoke_MethodHandle
_invokeVarargs,                java_lang_invoke_MethodHandle
_invokeDynamic,                java_lang_invoke_InvokeDynamic
_booleanValue,                 java_lang_Boolean
_byteValue,                    java_lang_Byte
_charValue,                    java_lang_Character
_shortValue,                   java_lang_Short
_intValue,                     java_lang_Integer
_longValue,                    java_lang_Long
_floatValue,                   java_lang_Float
_doubleValue,                  java_lang_Double
_Boolean_valueOf,              java_lang_Boolean
_Byte_valueOf,                 java_lang_Byte
_Character_valueOf,            java_lang_Character
_Short_valueOf,                java_lang_Short
_Integer_valueOf,              java_lang_Integer
_Long_valueOf,                 java_lang_Long
_Float_valueOf,                java_lang_Float
_Double_valueOf,               java_lang_Double
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Metoda <strong>System.arraycopy()</strong></h2>

<p>Ji¾ v&nbsp;úvodní kapitole jsme si øekli, ¾e jednou z&nbsp;tìchto tzv.
<i>intrinsic</i> je i metoda <strong>System.arraycopy()</strong>, její¾ kód je
ji¾ dopøedu pøipraven a to hned v&nbsp;nìkolika variantách optimalizovaných pro
rùzné pøípady, které mohou v&nbsp;praxi nastat (pøekryv polí, zarovnání èi
naopak nezarovnání polí atd.). Metoda <strong>System.arraycopy()</strong> má
následující hlavièku:</p>

<pre>
public static void arraycopy(Object src,
                             int srcPos,
                             Object dest,
                             int destPos,
                             int length)
</pre>

<p>Tato metoda slou¾í ke kopii prvkù z&nbsp;jednoho pole do pole jiného,
pøièem¾ je mo¾né zvolit jak offsety prvkù (nemusí se zaèínat prvkem
s&nbsp;indexem 0), tak i celkový poèet kopírovaných prvkù. Podívejme se nyní na
jednoduchý demonstraèní pøíklad, kde se metoda
<strong>System.arraycopy()</strong> volá s&nbsp;rùznými parametry:</p>

<pre>
public class <strong>ArrayCopyTest</strong> {
    static int[] src = new int[30000];
    static int[] dest = new int[30000];
&nbsp;
    public static void <strong>testArrayCopy1</strong>(int offset, int length) {
        System.arraycopy(src, 0, dest, 0, length);
    }
&nbsp;
    public static void <strong>testArrayCopy2</strong>(int offset, int length) {
        System.arraycopy(src, offset, dest, 0, length);
    }
&nbsp;
    public static void <strong>testArrayCopy3</strong>(int offset, int length) {
        System.arraycopy(src, 0, dest, offset, length);
    }
&nbsp;
    public static void <strong>testArrayCopy4</strong>(int offset, int length) {
        System.arraycopy(src, 0, src, 0, length);
    }
&nbsp;
    public static void <strong>testArrayCopy5</strong>(int offset, int length) {
        System.arraycopy(src, offset, src, 0, length);
    }
&nbsp;
    public static void <strong>testArrayCopy6</strong>(int offset, int length) {
        System.arraycopy(src, 0, src, offset, length);
    }
&nbsp;
    public static void <strong>main</strong>(String[] args) {
        for (int i = 0; i &lt; 10000; i++) {
            testArrayCopy1(i, i);
            testArrayCopy2(i, i);
            testArrayCopy3(i, i);
            testArrayCopy4(i, i);
            testArrayCopy5(i, i);
            testArrayCopy6(i, i);
        }
    }
}
</pre>

<p>Pøi pøekladu dojde k&nbsp;nahrazení volání
<strong>System.arraycopy()</strong> nìkolika rùznými nativními a
optimalizovanými variantami smyèky pro kopii prvkù rozdílných typù
s&nbsp;rùzným zarovnáním, pøekryvem polí atd. Konkrétní výsledky si uká¾eme
v&nbsp;následující èásti tohoto seriálu.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Repositáø se zdrojovými kódy v¹ech demonstraèních i testovacích pøíkladù</h2>

<p>Následuje &ndash; v&nbsp;tomto seriálu ji¾ tradièní &ndash; kapitola
s&nbsp;odkazy na zdrojové kódy ulo¾ené do Mercurial repositáøe.
V&nbsp;následující tabulce najdete odkazy na prozatím nejnovìj¹í verzi dnes
pou¾itých demonstraèních pøíkladù:</p>

<table>
<tr><th>#</th><th>Zdrojový soubor/skript</th><th>Umístìní souboru v&nbsp;repositáøi</th></tr>
<tr><td>1</td><td>Factorial.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d6e81b348112/jit/Factorial.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d6e81b348112/jit/Factorial.java</a></td></tr>
<tr><td>2</td><td>Factorial2.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d6e81b348112/jit/Factorial2.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d6e81b348112/jit/Factorial2.java</a></td></tr>
<tr><td>3</td><td>ArrayCopyTest.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d6e81b348112/jit/ArrayCopyTest.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d6e81b348112/jit/ArrayCopyTest.java</a></td></tr>
</table>



<p><a name="k11"></a></p>
<h2 id="k11">11. Odkazy na Internetu</h2>

<ol>

<li>GC safe-point (or safepoint) and safe-region<br />
<a href="http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html">http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html</a>
</li>

<li>Safepoints in HotSpot JVM<br />
<a href="http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html">http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html</a>
</li>

<li>Java theory and practice: Synchronization optimizations in Mustang<br />
<a href="http://www.ibm.com/developerworks/java/library/j-jtp10185/">http://www.ibm.com/developerworks/java/library/j-jtp10185/</a>
</li>

<li>How to build hsdis<br />
<a href="http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README">http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README</a>
</li>

<li>Java SE 6 Performance White Paper<br />
<a href="http://www.oracle.com/technetwork/java/6-performance-137236.html">http://www.oracle.com/technetwork/java/6-performance-137236.html</a>
</li>

<li>Lukas Stadler's Blog<br />
<a href="http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html">http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html</a>
</li>

<li>How to build hsdis-amd64.dll and hsdis-i386.dll on Windows<br />
<a href="http://dropzone.nfshost.com/hsdis.htm">http://dropzone.nfshost.com/hsdis.htm</a>
</li>

<li>PrintAssembly<br />
<a href="https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly">https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly</a>
</li>

<li>The Java Virtual Machine Specification: 3.14. Synchronization<br />
<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14</a>
</li>

<li>The Java Virtual Machine Specification: 8.3.1.4. volatile Fields<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.4. Memory Model<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.7. Non-atomic Treatment of double and long<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7</a>
</li>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (pøed verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

