<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - jak efektivnì jsou ulo¾ena pole a øetìzce na haldì?</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - jak efektivnì jsou ulo¾ena pole a øetìzce na haldì?</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o jazyce Java i o vlastnostech JVM si øekneme, jak lze získat informace o polích (primitivních typù) ulo¾ených na haldì a následnì se budeme zabývat zpùsobem ulo¾ení øetìzcù. Jedná se o pomìrnì dùle¾ité téma, jeliko¾ zpùsob práce JVM s øetìzci mù¾e mnohdy významným zpùsobem ovlivnit jak výkonnost javovských aplikací, tak i jejich pamì»ovou nároènost.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Dokonèení pøedchozí èásti seriálu &ndash; zji¹tìní poøadí atributu v&nbsp;rámci tøídy</a></p>
<p><a href="#k02">2. Pøeètení poøadí atributu ve tøídì z&nbsp;unie <strong>jvmtiHeapReferenceInfo</strong></a></p>
<p><a href="#k03">3. Demonstraèní agent èíslo 23 &ndash; výpis poøadí v¹ech atributù nalezených na haldì</a></p>
<p><a href="#k04">4. Pøeètení informací o polích primitivních datových typù ulo¾ených na haldì</a></p>
<p><a href="#k05">5. Demonstraèní agent èíslo 24 &ndash; výpis informací o polích primitivních datových typù</a></p>
<p><a href="#k06">6. Proè velikost pamìti obsazené polem neodpovídá objemu pamìti vyhrazené pro prvky pole?</a></p>
<p><a href="#k07">7. Øetìzce na haldì &ndash; aneb specifický typ objektù</a></p>
<p><a href="#k08">8. Struktura objektu pøedstavujícího øetìzec</a></p>
<p><a href="#k09">9. Efektivita ulo¾ení øetìzcù na haldì</a></p>
<p><a href="#k10">10. Výpoèet efektivity ulo¾ení øetìzcù na haldì</a></p>
<p><a href="#k11">11. Zdrojové kódy v¹ech tøí agentù a k&nbsp;nim pøíslu¹ných testovacích pøíkladù</a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Dokonèení pøedchozí èásti seriálu &ndash; zji¹tìní poøadí atributu v&nbsp;rámci tøídy</h2>

<p>V&nbsp;dne¹ní èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyce Java i o vlastnostech virtuálního stroje Javy</a> nejprve
dokonèíme téma, kterému jsme se ji¾ zaèali vìnovat minule. Jedná se o výpis
typù a hodnot atributù ulo¾ených na haldì. Posléze si øekneme, jakým zpùsobem
je mo¾né získat informace o polích (primitivních typù) ulo¾ených na haldì a
následnì se budeme zabývat zpùsobem ulo¾ení øetìzcù, proto¾e se jedná o pomìrnì
dùle¾ité téma, jeliko¾ zpùsob práce s&nbsp;øetìzci mù¾e mnohdy velmi významným
zpùsobem ovlivnit jak výkonnost javovských aplikací, tak i jejich pamì»ovou
nároènost. Vra»me se nejdøíve ke dvìma demonstraèním <i>JVM TI</i> agentùm
popsaným minule. V&nbsp;tìchto agentech se pou¾ívala callback funkce nazvaná
<strong>callback_for_primitive_values()</strong>, která se volala pro v¹echny
atributy objektù ulo¾ených na haldì. Pøitom se jednalo o atributy, jejich¾ typ
patøil mezi primitivní typy Javy &ndash; <strong>boolean</strong>,
<strong>byte</strong>, <strong>short</strong>, <strong>int</strong>,
<strong>long</strong>, <strong>char</strong>, <strong>float</strong> èi
<strong>double</strong>. Hlavièka zmínìné callback funkce vypadá
následovnì:</p>

<pre>
<i>/*</i>
<i> * Callback funkce volana pro kazdou hodnotu primitivniho datoveho typu</i>
<i> * ulozenou na halde.</i>
<i> */</i>
static jint JNICALL <strong>callback_for_primitive_values</strong>(
        jvmtiHeapReferenceKind        kind,
        const jvmtiHeapReferenceInfo* info,
        jlong                         object_class_tag,
        jlong *                       object_tag_ptr,
        jvalue                        value,
        jvmtiPrimitiveType            value_type,
        void *                        user_data)
</pre>

<p>Ji¾ víme, jak je mo¾né z&nbsp;údajù pøedaných této callback funkci získat
jméno pøíslu¹né tøídy (její¾ instance jsou zkoumány), typ atributu i hodnotu,
která je v&nbsp;tomto atributu ulo¾ena. Prozatím v¹ak je¹tì nevíme, jakým
zpùsobem je mo¾né zjistit poøadí atributu v&nbsp;rámci tøídy (èi její
instance). To je dal¹í a v&nbsp;podstatì ji¾ poslední informace, kterou mù¾eme
relativnì snadno získat, tentokrát s&nbsp;vyu¾itím prvního parametru
<strong>kind</strong> a pøedev¹ím pak parametru druhého <strong>info</strong>.
Podrobnosti si øekneme <a href="#k02">v&nbsp;navazující kapitole</a>.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Pøeètení poøadí atributu ve tøídì z&nbsp;unie <strong>jvmtiHeapReferenceInfo</strong></h2>

<p>Pøi volání callback funkce <strong>callback_for_primitive_values()</strong>
je v&nbsp;prvním parametru nazvaném <strong>kind</strong> pøedána informace o
tom, jaký prvek ulo¾ený na haldì je právì prozkoumáván. Datový typ parametru
<strong>kind</strong> je <strong>jvmtiHeapReferenceKind</strong> a pohledem do
hlavièkového souboru <strong>jvmti.h</strong> (èi do dokumentace, ale zdrojový
kód bývá èasto tou nejlep¹í dokumentací :-) lze velmi snadno zjistit, ¾e se
jedná o výèet s&nbsp;celkem sedmnácti deklarovanými hodnotami:</p>

<pre>
typedef enum {
    JVMTI_HEAP_REFERENCE_CLASS = 1,
    JVMTI_HEAP_REFERENCE_FIELD = 2,
    JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT = 3,
    JVMTI_HEAP_REFERENCE_CLASS_LOADER = 4,
    JVMTI_HEAP_REFERENCE_SIGNERS = 5,
    JVMTI_HEAP_REFERENCE_PROTECTION_DOMAIN = 6,
    JVMTI_HEAP_REFERENCE_INTERFACE = 7,
    JVMTI_HEAP_REFERENCE_STATIC_FIELD = 8,
    JVMTI_HEAP_REFERENCE_CONSTANT_POOL = 9,
    JVMTI_HEAP_REFERENCE_SUPERCLASS = 10,
    JVMTI_HEAP_REFERENCE_JNI_GLOBAL = 21,
    JVMTI_HEAP_REFERENCE_SYSTEM_CLASS = 22,
    JVMTI_HEAP_REFERENCE_MONITOR = 23,
    JVMTI_HEAP_REFERENCE_STACK_LOCAL = 24,
    JVMTI_HEAP_REFERENCE_JNI_LOCAL = 25,
    JVMTI_HEAP_REFERENCE_THREAD = 26,
    JVMTI_HEAP_REFERENCE_OTHER = 27
} jvmtiHeapReferenceKind;
</pre>

<p>Nás v¹ak v&nbsp;tento okam¾ik zajímají pouze hodnoty primitivních datových
typù ulo¾ených na haldì, pro nì¾ se pøi volání callback funkce v&nbsp;parametru
<strong>kind</strong> v¾dy pøedává hodnota
<strong>JVMTI_HEAP_REFERENCE_FIELD</strong>, èemu¾ ostatnì odpovídá i podmínka
zapsaná uvnitø tìla callback funkce:</p>

<pre>
<i>    /* zajimaji nas pouze nestaticke atributy objektu */</i>
    if (kind != <strong>JVMTI_HEAP_REFERENCE_FIELD</strong>) return <strong>JVMTI_VISIT_OBJECTS</strong>;
&nbsp;
</pre>

<p>Dùle¾itìj¹í, zajímavìj¹í a souèasnì i ponìkud komplikovanìj¹í je v¹ak druhý
parametr na¹í callback funkce nazvaný <strong>info</strong>, jeho¾ typ je
<strong>jvmtiHeapReferenceInfo</strong>. Pro zji¹tìní, o jaký datový typ se ve
skuteènosti jedná, budeme muset opìt prozkoumat hlavièkový soubor
<strong>jvmti.h</strong>, z&nbsp;nìho¾ lze vyèíst, ¾e jde o unii, která mù¾e
v&nbsp;daný okam¾ik obsahovat jednu ze ¹esti (ve skuteènosti v¹ak jen pìti)
datových struktur:</p>

<pre>
union <strong>jvmtiHeapReferenceInfo</strong> {
    jvmtiHeapReferenceInfoField field;
    jvmtiHeapReferenceInfoArray array;
    jvmtiHeapReferenceInfoConstantPool constant_pool;
    jvmtiHeapReferenceInfoStackLocal stack_local;
    jvmtiHeapReferenceInfoJniLocal jni_local;
    jvmtiHeapReferenceInfoReserved other;
};
</pre>

<p>Pro úplnost si uveïme deklarace v¹ech ¹esti datových struktur ukládaných do
unie, i kdy¾ nás ve skuteènosti bude zajímat pouze struktura jediná &ndash;
<strong>jvmtiHeapReferenceInfoField</strong>:</p>

<pre>
struct <strong>jvmtiHeapReferenceInfoField</strong> {
    jint index;  <i>/* zde je ulo¾eno poøadí atributu v rámci tøídy/objektu */</i>
};
</pre>

<pre>
struct <strong>jvmtiHeapReferenceInfoArray</strong> {
    jint index;
};
</pre>

<pre>
struct <strong>jvmtiHeapReferenceInfoConstantPool</strong> {
    jint index;
};
</pre>

<pre>
struct <strong>jvmtiHeapReferenceInfoStackLocal</strong> {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
    jlocation location;
    jint slot;
};
</pre>

<pre>
struct <strong>jvmtiHeapReferenceInfoJniLocal</strong> {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
};
</pre>

<pre>
struct <strong>jvmtiHeapReferenceInfoReserved</strong> {
    jlong reserved1;
    jlong reserved2;
    jlong reserved3;
    jlong reserved4;
    jlong reserved5;
    jlong reserved6;
    jlong reserved7;
    jlong reserved8;
};
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Demonstraèní agent èíslo 23 &ndash; výpis poøadí v¹ech atributù nalezených na haldì</h2>

<p>Dal¹í postup pøi vylep¹ování demonstraèního <i>JVM TI</i> agenta je ji¾
pomìrnì snadný; staèí jen vìdìt, ¾e v&nbsp;pøípadì, ¾e je v&nbsp;prvním
parametru callback funkce <strong>callback_for_primitive_values()</strong>
pøedána hodnota <strong>JVMTI_HEAP_REFERENCE_FIELD</strong>, pak je v&nbsp;unii
<strong>info</strong> v¾dy ulo¾ena datová struktura
<strong>jvmtiHeapReferenceInfoField</strong>, v&nbsp;ní¾ je umístìn jediný
prvek &ndash; ký¾ený index atributu v&nbsp;rámci tøídy èi objektu (instance
tøídy). Odkaz na celý zdrojový kód nové verze demonstraèního <i>JVM TI</i>
agenta je uveden <a href="#k11">v&nbsp;jedenácté kapitole</a>, zde si pouze
uká¾eme upravenou formu callback funkce volané pro v¹echny hodnoty primitivních
datových typù ulo¾ených na haldì:</p>

<pre>
<i>/*</i>
<i> * Callback funkce volana pro kazdou hodnotu primitivniho datoveho typu</i>
<i> * ulozenou na halde.</i>
<i> */</i>
static jint JNICALL <strong>callback_for_primitive_values</strong>(
        jvmtiHeapReferenceKind kind,
        const                  jvmtiHeapReferenceInfo* info,
        jlong                  object_class_tag,
        jlong *                object_tag_ptr,
        jvalue                 value,
        jvmtiPrimitiveType     value_type,
        void *                 user_data)
{
    int index;
    int size;
    int field_no;
    char *primitive_type_str;
    char *class_name;
&nbsp;
<i>    /* struktura obsahujici podrobnejsi informace o atributu */</i>
    jvmtiHeapReferenceInfoField *reference_info_field;
&nbsp;
<i>    /* zajimaji nas pouze nestaticke atributy objektu */</i>
    if (kind != <strong>JVMTI_HEAP_REFERENCE_FIELD</strong>) return <strong>JVMTI_VISIT_OBJECTS</strong>;
&nbsp;
<i>    /* na zaklade predaneho typu ziskat jmeno typu jako retezec */</i>
    primitive_type_str = get_primitive_type_str(value_type);
&nbsp;
<i>    /* na zaklade predaneho typu ziskat velikost v bajtech */</i>
    size = get_primitive_type_size(value_type);
&nbsp;
<i>    /* ziskat poradi atributu v tride */</i>
<i>    /* nutno pretypovat, protoze jvmtiHeapReferenceInfo je ve skutecnosti unie */</i>
    reference_info_field = (jvmtiHeapReferenceInfoField*)info;
    field_no = reference_info_field-&gt;index;
&nbsp;
<i>    /* jmeno tridy lze ziskat na zaklade tagu z globalniho pole */</i>
    index = object_class_tag - 1;
    class_name = class_names[index];
&nbsp;
<i>    /* vypiseme informace pouze pro dve testovaci tridy "Foo" a "Bar" */</i>
    if (strcmp("Foo ", class_name)==0 || strcmp("Bar ", class_name)==0)
    {
        printf("Field #%2d of type %-7s in instance of class %shas size %1d byte%c and value ",
                field_no, primitive_type_str, class_name, size, size &gt; 1 ? 's' : ' ');
        print_value(value_type, value);
    }
&nbsp;
<i>    /* spocitani statistickych informaci o obsazeni haldy */</i>
    t_heap_stat *heap_stat = (t_heap_stat*)user_data;
    heap_stat-&gt;primitive_count++;
    heap_stat-&gt;total_size += size;
&nbsp;
<i>    /* pokracovat dal v prochazeni haldy */</i>
    return <strong>JVMTI_VISIT_OBJECTS</strong>;
}
</pre>

<p>Po pøekladu a spu¹tìní tohoto demonstraèního pøíkladu skripty uvedenými opìt
<a href="#k11">v&nbsp;jedenácté kapitole</a> získáme následující výstup:</p>

<pre>
Agent23: Agent_OnLoad
Agent23: JVM TI version is correct
Agent23: Got VM init event
Agent23: Got VM Death event
Agent23: Got data dump request
class java.io.BufferedOutputStream  has tag 1
class java.lang.Class$3  has tag 2
class java.util.Enumeration  has tag 3
class sun.misc.Version  has tag 4
class java.util.Collections$EmptyList  has tag 5
class sun.misc.ExtensionDependency  has tag 6
class java.nio.HeapByteBuffer  has tag 7
...
...
...
class [Z has tag 373
class [B has tag 374
class [C has tag 375
class [I has tag 376
class [S has tag 377
class [J has tag 378
class [F has tag 379
class [D has tag 380
Field # 2 of type float   in instance of class Foo has size 4 bytes and value 3.141500
Field # 1 of type int     in instance of class Foo has size 4 bytes and value 42
Field # 0 of type boolean in instance of class Foo has size 1 byte  and value false
Field # 2 of type float   in instance of class Foo has size 4 bytes and value 2.717200
Field # 1 of type int     in instance of class Foo has size 4 bytes and value 6502
Field # 0 of type boolean in instance of class Foo has size 1 byte  and value true
Field # 3 of type long    in instance of class Bar has size 8 bytes and value 4
Field # 2 of type int     in instance of class Bar has size 4 bytes and value 3
Field # 1 of type short   in instance of class Bar has size 2 bytes and value 2
Field # 0 of type byte    in instance of class Bar has size 1 byte  and value 1
Field # 3 of type long    in instance of class Bar has size 8 bytes and value 4
Field # 2 of type int     in instance of class Bar has size 4 bytes and value 3
Field # 1 of type short   in instance of class Bar has size 2 bytes and value 2
Field # 0 of type byte    in instance of class Bar has size 1 byte  and value 1
Primitive values count: 5522 (fields only)
Total size:   21422 bytes
Agent23: Agent_OnUnload
</pre>

<p>Nyní si mù¾ete porovnat zdrojový kód testovacích tøíd <strong>Foo</strong> a
<strong>Bar</strong> s&nbsp;informacemi vypsanými vý¹e...</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Pøeètení informací o polích primitivních datových typù ulo¾ených na haldì</h2>

<p>Nyní ji¾ víme, jakým zpùsobem je mo¾né vypsat v¹echny objekty ulo¾ené na
haldì i v¹echny &bdquo;jednoduché&ldquo; atributy objektù &ndash; a» ji¾ se
jedná o atributy objektového typu (=reference) èi o atributy primitivního
datového typu. Ov¹em je¹tì nám zbývá si øíci, jak lze získat informace o polích
ulo¾ených na haldì a to vèetnì polí znakù, proto¾e právì s&nbsp;vyu¾itím polí
znakù (pevné délky) jsou implementovány øetìzce, které hrají v&nbsp;mnoha
typech javovských aplikací témìø klíèovou roli. Nejdøíve si popí¹eme zpùsob
ètení informací o polích, jejich¾ prvky jsou primitivního datového typu,
tj.&nbsp;polí vytvoøených napøíklad takto:</p>

<pre>
byte[]    b = new byte[length];
short[]   s = new short[length];
int[]     i = new int[length];
long[]    l = new long[length];
char[]    c = new char[length];
float[]   f = new float[length];
double[]  d = new double[length];
boolean[] z = new boolean[length];
</pre>

<p>Poznámka: vícerozmìrná pole se v&nbsp;Javì zpracovávají jako pole polí,
podobnì jako je tomu napøíklad v&nbsp;céèku a mnoha dal¹ích programovacích
jazycích.</p>

<p>Pøi prùchodu poli ulo¾enými na haldì se pou¾ívá speciální forma callback
funkce, která je ve struktuøe <strong>jvmtiHeapCallbacks</strong> pøedstavována
ukazatelem <strong>array_primitive_value_callback</strong>:</p>

<pre>
<strong>typedef struct</strong> {
    jvmtiHeapIterationCallback        heap_iteration_callback;
    jvmtiHeapReferenceCallback        heap_reference_callback;
    jvmtiPrimitiveFieldCallback       primitive_field_callback;
    jvmtiArrayPrimitiveValueCallback  array_primitive_value_callback;
    jvmtiStringPrimitiveValueCallback string_primitive_value_callback;
    jvmtiReservedCallback             reserved5;
    jvmtiReservedCallback             reserved6;
    jvmtiReservedCallback             reserved7;
    jvmtiReservedCallback             reserved8;
    jvmtiReservedCallback             reserved9;
    jvmtiReservedCallback             reserved10;
    jvmtiReservedCallback             reserved11;
    jvmtiReservedCallback             reserved12;
    jvmtiReservedCallback             reserved13;
    jvmtiReservedCallback             reserved14;
    jvmtiReservedCallback             reserved15;
} <strong>jvmtiHeapCallbacks</strong>;
</pre>

<p>Registrace této callback funkce se provádí naprosto stejným zpùsobem, jako
registrace callback funkcí volaných pro objekty i pro atributy primitivních
datových typù; bude se v¹ak li¹it poèet i typ parametrù pøedávaných této
callback funkci (tu si uká¾eme <a href="#k05">v&nbsp;navazující kapitole</a>).
V&nbsp;kódu ní¾e je ukázán zpùsob registrace této callback funkce
s&nbsp;následným zahájením prùchodu haldou:</p>

<pre>
<i>/*</i>
<i> * Registrace callback funkce pro prochazeni heapem a zacatek prochazeni.</i>
<i> */</i>
static void <strong>register_heap_callback_and_run_dump</strong>(jvmtiEnv *jvmti_env)
{
    jvmtiError error;
    jvmtiHeapCallbacks heap_callbacks;
    t_heap_stat heap_stat = {0, 0, 0};
&nbsp;
<i>    /* naplnit strukturu heap_callbacks jednou callback funkci */</i>
    (void)memset(&amp;heap_callbacks, 0, sizeof(heap_callbacks));
    <strong>heap_callbacks.array_primitive_value_callback = &amp;callback_for_array_values</strong>;
&nbsp;
<i>    /* zahajit prochazeni haldou */</i>
    error = (*jvmti_env)-&gt;IterateThroughHeap(jvmti_env, 0, NULL,
            &amp;heap_callbacks, (const void *)&amp;heap_stat);
    check_jvmti_error(jvmti_env, error, "read heap content");
&nbsp;
<i>    /* vypis statistiky */</i>
    printf("Arrays count: %d\n", heap_stat.arrays_count);
    printf("Data size:    %ld bytes\n", heap_stat.data_size);
    printf("Total size:   %ld bytes\n", heap_stat.total_size);
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Demonstraèní agent èíslo 24 &ndash; výpis informací o polích primitivních datových typù</h2>

<p>Callback funkci zavolané pøi nalezení pole s&nbsp;prvky primitivního
datového typu se pøedává celkem sedm parametrù, z&nbsp;nich¾ nìkteré ji¾ známe
z&nbsp;jiných typù callback funkcí, ov¹em dal¹í parametry budou zcela nové:
</p>

<table>
<tr><th>#</th><th>Typ parametru</th><th>Jméno parametru</th><th>Význam</th></tr>
<tr><td>1</td><td>jlong </td><td>class_tag</td><td>tag pøiøazený ke tøídì, které je objekt instancí</td></tr>
<tr><td>2</td><td>jlong </td><td>size</td><td>celková velikost alokovaná pro pole na haldì</td></tr>
<tr><td>3</td><td>jlong*</td><td>tag_ptr</td><td>ukazatel na tag pøiøazený k&nbsp;objektu</td></tr>
<tr><td>4</td><td>jint  </td><td>element_count</td><td>poèet prvkù pole</td></tr>
<tr><td>5</td><td>jvmtiPrimitiveType</td><td>element_type</td><td>typ hodnoty (byte, int, float...) prvkù pole</td></tr>
<tr><td>6</td><td>void*</td><td>element</td><td>obsah pole (hodnoty prvkù pole)</td></tr>
<tr><td>7</td><td>void*</td><td>user_data</td><td>ukazatel na u¾ivatelská data (má stejný význam, jaký ji¾ známe z minula)</td></tr>
</table>

<p>Pøi prùchodu haldou nás bude zajímat pøedev¹ím poèet prvkù pole, typ prvkù
pole a velikost pamìti alokované pro pole (proè je tato pamì» vìt¹í, ne¾ by
odpovídalo poètu prvkù pole si øekneme v&nbsp;dal¹ím textu):</p>

<pre>
<i>/*</i>
<i> * Callback funkce volana pro kazde pole primitivnich</i>
<i> * datovych typu ulozene na halde.</i>
<i> */</i>
static jint JNICALL <strong>callback_for_array_values</strong>(
        jlong              class_tag, 
        jlong              size, 
        jlong*             tag_ptr, 
        jint               element_count, 
        jvmtiPrimitiveType element_type, 
        const void*        elements, 
        void*              user_data)
{
    char *primitive_type_str;
    char *class_name;
    int   index;
    long  data_size;
&nbsp;
<i>    /* na zaklade predaneho typu ziskat jmeno typu jako retezec */</i>
    primitive_type_str = get_primitive_type_str(element_type);
&nbsp;
<i>    /* jmeno tridy lze ziskat na zaklade tagu z globalniho pole */</i>
    index = class_tag - 1;
    class_name = class_names[index];
&nbsp;
<i>    /* ziskat objem zabrany jen daty, nikoli vyplni */</i>
    data_size = element_count * get_primitive_type_size(element_type);
&nbsp;
<i>    /* "magicke" delky pouzite v testovaci tride */</i>
    if (element_count == 1 || element_count == 1234 || element_count == 10000) {
        printf("%s  %s[%d] with size %ld(%ld) bytes\n",
            class_name, primitive_type_str, element_count, data_size, (long int)size);
    }
&nbsp;
<i>    /* spocitani statistickych informaci o obsazeni haldy */</i>
    t_heap_stat *heap_stat = (t_heap_stat*)user_data;
    heap_stat-&gt;arrays_count++;
    heap_stat-&gt;total_size += size;
    heap_stat-&gt;data_size += data_size;
&nbsp;
<i>    /* pokracovat dal v prochazeni haldy */</i>
    return JVMTI_VISIT_OBJECTS;
}
</pre>

<p>Kompletní zdrojový kód demonstraèního <i>JVM TI</i> agenta je opìt uveden <a
href="#k11">v&nbsp;kapitole èíslo 11</a>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Proè velikost pamìti obsazené polem neodpovídá objemu pamìti vyhrazené pro prvky pole?</h2>

<p>Po spu¹tìní demonstraèního agenta èíslo 24 získáme následující (ponìkud
zkrácený) výpis:</p>

<pre>
Agent24: Agent_OnLoad
Agent24: JVM TI version is correct
Agent24: Got VM init event
Agent24: Got VM Death event
Agent24: Got data dump request
class java.io.BufferedOutputStream  has tag 1
class java.lang.Class$3  has tag 2
class java.util.Enumeration  has tag 3
class sun.misc.Version  has tag 4
class java.util.Collections$EmptyMap  has tag 5
class sun.misc.ExtensionDependency  has tag 6
class java.nio.HeapByteBuffer  has tag 7
class java.util.Arrays  has tag 8
class sun.misc.JavaIOAccess  has tag 9
class java.util.IdentityHashMap  has tag 10
class java.net.URLStreamHandlerFactory  has tag 11
class Foo  has tag 12
...
...
...
class [Z has tag 372
class [B has tag 373
class [C has tag 374
class [I has tag 375
class [S has tag 376
class [J has tag 377
class [F has tag 378
class [D has tag 379
[C  char[1] with size 2(16) bytes
[C  char[1] with size 2(16) bytes
[C  char[1] with size 2(16) bytes
[B  byte[1] with size 1(16) bytes
[C  char[1] with size 2(16) bytes
[B  byte[1] with size 1(16) bytes
[B  byte[1] with size 1(16) bytes
[C  char[1] with size 2(16) bytes
[C  char[1] with size 2(16) bytes
[B  byte[1] with size 1(16) bytes
[C  char[1] with size 2(16) bytes
[C  char[1] with size 2(16) bytes
[C  char[1] with size 2(16) bytes
[B  byte[1] with size 1(16) bytes
[S  short[1] with size 2(16) bytes
[I  int[1] with size 4(16) bytes
[J  long[1] with size 8(24) bytes
[C  char[1] with size 2(16) bytes
[F  float[1] with size 4(16) bytes
[D  double[1] with size 8(24) bytes
[Z  boolean[1] with size 1(16) bytes
[B  byte[1234] with size 1234(1248) bytes
[S  short[1234] with size 2468(2480) bytes
[I  int[1234] with size 4936(4952) bytes
[J  long[1234] with size 9872(9888) bytes
[C  char[1234] with size 2468(2480) bytes
[F  float[1234] with size 4936(4952) bytes
[Z  boolean[1234] with size 1234(1248) bytes
[D  double[1234] with size 9872(9888) bytes
[B  byte[10000] with size 10000(10016) bytes
[S  short[10000] with size 20000(20016) bytes
[I  int[10000] with size 40000(40016) bytes
[J  long[10000] with size 80000(80016) bytes
[C  char[10000] with size 20000(20016) bytes
[F  float[10000] with size 40000(40016) bytes
[D  double[10000] with size 80000(80016) bytes
[Z  boolean[10000] with size 10000(10016) bytes
[C  char[1] with size 2(16) bytes
[C  char[1] with size 2(16) bytes
[C  char[1] with size 2(16) bytes
[C  char[1] with size 2(16) bytes
[C  char[1] with size 2(16) bytes
[C  char[1] with size 2(16) bytes
[C  char[1] with size 2(16) bytes
[C  char[1] with size 2(16) bytes
[C  char[1] with size 2(16) bytes
Arrays count: 2494
Data size:    610459 bytes
Total size:   648752 bytes
Agent24: Agent_OnUnload
</pre>

<p>Zajímavé je, ¾e pamì» alokovaná pro pole je v¾dy vìt¹í, ne¾ délka zji¹tìná
prostým vynásobením poètu prvkù pole s&nbsp;poètem bajtù pro jeden prvek.
V&nbsp;céèku toti¾ skuteènì platí:</p>

<pre>
alokovaná_pamì» = délka_pole * sizeof(typ)
</pre>

<p>V&nbsp;Javì je v¹ak situace ponìkud komplikovanìj¹í, proto¾e pole jsou
chápána jako objekty a tudí¾ se pøi jejich ukládání na haldu kromì vlastních
prvkù ukládají i dal¹í informace. Pøedev¹ím se jedná o hlavièku, její¾ délka je
vìt¹inou rovna osmi bajtùm. Hlavièka je pou¾ívána pro identifikaci objektu,
vyu¾ívá ji správce pamìti atd. atd. U 64bitových virtuálních strojù a velkých
kapacit haldy mù¾e být hlavièka i vìt¹í, setkat se lze i s&nbsp;délkou 16
bajtù! Takté¾ je nutné ulo¾it délku pole, co¾ je (prozatím) ètyøbajtová hodnota
(délka pole je jeho nedílnou souèástí, na rozdíl od céèka). Navíc se podle
architektury, na ní¾ JVM bì¾í, na konci pole nachází výplò (<i>padding</i>) tak
velká, aby celková velikost objektu byla dìlitelná 8 èi 16 bajty. To je i
dùvod, proè napøíklad jednoprvkové pole <strong>boolean[1]</strong> ve
skuteènosti na haldì obsadí ¹estnáct bajtù.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Øetìzce na haldì &ndash; aneb specifický typ objektù</h2>

<p>Dnes se je¹tì budeme zabývat popisem zpùsobu ulo¾ení øetìzcù na haldì,
získáním tìchto øetìzcù a jejich (i kdy¾ ponìkud omezeným) výpisem. Pøipomeòme
si, co se vlastnì v&nbsp;Javì pod pojmem &bdquo;øetìzec&ldquo; (string) skrývá.
Na jednu stranu se jedná o pouhou tøídu, její¾ instance lze vytváøet
s&nbsp;vyu¾itím operátoru <strong>new</strong>, na stranu druhou v¹ak pro práci
s&nbsp;øetìzci existuje podpora v&nbsp;samotné syntaxi a sémantice tohoto
programovacího jazyka, proto¾e do programù je mo¾né zapisovat øetìzcové
literály (konstantní øetìzce) a navíc pro øetìzce existují pøetí¾ené verze
operátorù + a += (nikoli v¹ak ji¾ operátoru ==, co¾ stále vede ke vzniku mnohdy
tì¾ko objevitelných sémantických chyb). To v¹ak není v¹e, proto¾e øetìzcové
literály jsou ukládány v&nbsp;<i>constant poolu</i> (<a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-2-cast-podrobnejsi-analyza-obsahu-constant-poolu">http://www.root.cz/clanky/pohled-pod-kapotu-jvm-2-cast-podrobnejsi-analyza-obsahu-constant-poolu</a>),
tak¾e øetìzce jsou skuteènì na platformì Java zpracovávány jiným zpùsobem, ne¾
dal¹í tøídy a jejich instance (navíc s&nbsp;JDK7 existuje pro øetìzce speciální
forma rozeskoku <strong>switch</strong> &ndash; viz té¾ úvodní èlánek tohoto
seriálu <a
href="http://www.root.cz/clanky/novinky-v-nbsp-jdk-7-aneb-mirny-pokrok-v-nbsp-mezich-zakona-1/">http://www.root.cz/clanky/novinky-v-nbsp-jdk-7-aneb-mirny-pokrok-v-nbsp-mezich-zakona-1/</a>).</p>

<p>Z&nbsp;hlediska vývojáøe je dùle¾itý takté¾ fakt, ¾e øetìzce jsou
nemìnitelné (<i>immutable</i>), co¾ s&nbsp;sebou pøiná¹í jak nìkteré výhody,
tak i komplikace, pøedev¹ím ve chvíli, kdy se mají s&nbsp;øetìzci provádìt
slo¾itìj¹í operace. Internì øetìzce vypadají pomìrnì jednodu¹e, alespoò pøi
prvním pohledu, proto¾e jsou tvoøeny polem <strong>char[]</strong>, co¾
znamená, ¾e ka¾dý prvek tohoto pole má velikost ¹estnáct bitù. Pro vìt¹inu
abeced platí, ¾e ka¾dý znak ulo¾ený v&nbsp;tomto poli skuteènì odpovídá jednomu
znaku dané abecedy (latinky, azbuky, alfabety ...), ov¹em ve skuteènosti není
mo¾né v&nbsp;rozsahu 0..2<sup>16</sup> reprezentovat libovolný znak definovaný
v&nbsp;normì Unicode. To platí pouze pro znaky s&nbsp;kódem 0x0000 a¾ 0xFFFF,
které se nìkdy oznaèují názvem <i>Basic Multilingual Plane (BMP)</i>, které
jsou v&nbsp;øetìzci ulo¾eny stylem jeden_znak_abecedy == 1 char. Pro znaky
s&nbsp;vy¹¹ím kódem (a¾ 0x10FFFF) je nutné v&nbsp;øetìzci vyhradit pár hodnot
typu <strong>char</strong>, tento pár se jmenuje <i>surrogate pair</i>.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Struktura objektu pøedstavujícího øetìzec</h2>

<p>V&nbsp;pøedchozích kapitolách jsme si øekli, ¾e pole jsou na haldì ulo¾eny
takovým zpùsobem, ¾e je pro nì nutné alokovat vìt¹í objem pamìti, ne¾ by to
odpovídalo poètu prvkù pole vynásobeného velikostí jednoho prvku.
V&nbsp;pøípadì øetìzcù je ponìkud paradoxnì situace je¹tì hor¹í, proto¾e
øetìzec je na haldì pøedstavován dvìma objekty &ndash; instancí tøídy
<strong>String</strong> a instancí pole <strong>char[]</strong> &ndash; toto
pole je sice atributem tøídy <strong>String</strong>, ov¹em pole jsou, jak ji¾
víme, chápána jako objekty, tudí¾ se namísto pole ukládá pouze jeho reference.
To s&nbsp;sebou nese urèitou (osobnì bych øekl, ¾e velmi velkou) re¾ii, která
vede k&nbsp;tomu, ¾e øetìzce pou¾ívané v&nbsp;typických Javovských aplikacích
spotøebují daleko vìt¹í mno¾ství operaèní pamìti, ne¾ je na první pohled
patrné.</p>

<p>Nejprve se podívejme na to, jak je ulo¾ena ka¾dá instance tøídy
<strong>String</strong>:</p>

<table>
<tr><th>#</th><th>Velikost (B)</th><th>Struktura</th><th>Popis</th></tr>
<tr><td>1</td><td>8</td><td>HEADER</td><td>hlavièka objektu (pøiøazena ka¾dému objektu na haldì)</td></tr>
<tr><td>2</td><td>4</td><td>int offset</td><td>atribut <strong>offset</strong> instance tøídy String</td></tr>
<tr><td>3</td><td>4</td><td>int count </td><td>atribut <strong>count</strong> instance tøídy String</td></tr>
<tr><td>4</td><td>4</td><td>int hash  </td><td>atribut <strong>hash</strong> instance tøídy String</td></tr>
<tr><td>5</td><td>4</td><td>char[]    </td><td>reference na pole znakù</td></tr>
</table>

<p>Celková velikost pamìti pro ulo¾ení instance tøídy <strong>String</strong>
je tedy minimálnì 24 bajtù, a to pouze v&nbsp;pøípadì, ¾e reference na objekty
má ¹íøku 32 bitù a nikoli 64 bitù (i to je mo¾né v&nbsp;pøípadì vìt¹ích kapacit
hald). Onìch 24 bajtù se oznaèuje <i>shallow size</i> (&bdquo;mìlká
velikost&ldquo; znaèící, ¾e nebereme v&nbsp;úvahu velikosti objektových
atributù) a je stejná pro v¹echny instance tøídy String.</p>

<p>To v¹ak samozøejmì není v¹e, proto¾e instance tøídy <strong>String</strong>
se pouze odkazuje na pole <strong>char[]</strong>, které je na haldì ulo¾eno
následovnì:</p>

<table>
<tr><th>#</th><th>Velikost (B)</th><th>Struktura</th><th>Popis</th></tr>
<tr><td>1</td><td>8</td><td>HEADER</td><td>hlavièka objektu (pøiøazena ka¾dému objektu na haldì)</td></tr>
<tr><td>2</td><td>4</td><td>int length</td><td>délka pole = délka øetìzce ve znacích</td></tr>
<tr><td>3</td><td>x</td><td>length*2  </td><td>vlastní obsah øetìzce</td></tr>
<tr><td>4</td><td>0 nebo 2</td><td>PADDING</td><td>výplò, aby celková délka objektu byla dìlitelná ètyømi (nìkdy osmi)</td></tr>
</table>

<p>I pro pole <strong>char[]</strong>, které bude obsahovat pouze jeden znak,
tedy bude na haldì alokována pamì» o velikosti ¹estnácti bajtù!</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Efektivita ulo¾ení øetìzcù na haldì</h2>

<p>Z&nbsp;textu uvedeného <a href="#k08">v&nbsp;pøedchozí kapitole</a> plyne,
¾e ulo¾ení pøedev¹ím krat¹ích øetìzcù nemusí být vùbec efektivní
z&nbsp;hlediska vyu¾ití operaèní pamìti. Pro úplnost si øeknìme, ¾e celková
kapacita pamìti alokovaná na haldì pro urèitý objekt se nazývá <i>retained
size</i> a v&nbsp;pøípadì øetìzcù se jedná o souèet <i>shallow size</i>
s&nbsp;velikostí pamìti alokované pro pole <strong>char[]</strong>, tedy:</p>

<pre>
Retained size = Shallow size + char[].HEADER + char[].length + (chars * 2 + padding)
</pre>

<p>Kdy¾ si uvìdomíme, ¾e pomìr mezi pamìtí vyhrazenou POUZE pro vlastní obsah
øetìzce (znaky zde ulo¾ené) a hodnotou <i>retained size</i> nelineárnì roste se
zvìt¹ující se délkou øetìzce, vyjde nám, ¾e zejména pøi práci s&nbsp;krátkými
øetìzci je halda vyu¾ívána dosti neefektivním zpùsobem (jak neefektivním, si
uká¾eme <a href="#10">ní¾e</a>). Krátké øetìzce se v¹ak v&nbsp;Javovských
aplikacích vyskytují velmi èasto; pou¾ívají se jako klíèe do he¹ovacích map,
jména souborù bývají krátká, jména a pøíjmení lidí takté¾, nehledì na jména
tøíd a balíèkù (øetìzce vyu¾ívané internì samotnou JVM)... Navíc se k&nbsp;tomu
pøidává fakt, ¾e napøíklad pøi pou¾ívání aplikací v&nbsp;anglicky mluvících
prostøedích (ale i v&nbsp;dal¹ích zemích se základní èi roz¹íøenou latinkou) se
prakticky v¾dy vyu¾ije pouze 8 bitù z&nbsp;16 bitù alokovaných na ka¾dou
hodnotu typu <strong>char</strong>, tak¾e je vyu¾ití ve skuteènosti je¹tì
polovièní oproti prostému pomìru <i>chars*2/retained_size</i>.</p>

<p>Mimochodem &ndash; i pøi spu¹tìní toho nejjednodu¹¹ího javovského programu
typu Hello world se na haldì vytvoøí pøes 900 pøevá¾nì krátkých øetìzcù.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Výpoèet efektivity ulo¾ení øetìzcù na haldì</h2>

<p>Abychom si ukázali, ¾e ulo¾ení krátkých øetìzcù na haldì je skuteènì
v&nbsp;mnoha pøípadech dosti neefektivní, mù¾eme si vyzkou¹et vygenerovat
tabulku a z&nbsp;ní odvozený graf, na nìm¾ bude vykreslen pomìr
<i>chars*2/retained_size</i>, tj.&nbsp;pomìr mezi poètem znakù ulo¾ených
v&nbsp;øetìzci (dvojka je zde z&nbsp;toho dùvodu, ¾e ¹íøka datového typu
<strong>char</strong> je v&nbsp;Javì 16 bitù). Tabulka bude vygenerována pro
v¹echny délky øetìzce, pro nì¾ je efektivita ulo¾ení men¹í ne¾ 90% (znovu je
dùle¾ité zopakovat, ¾e v&nbsp;pøípadì programù pracujících pouze s&nbsp;ASCII
sadou je toto èíslo ve skuteènosti vlastnì polovièní). Program pro výpoèet této
tabulky je jednoduchý (zdrojový kód si mù¾ete stáhnout z&nbsp;adresy
<a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f61c1eead131/tools/string_storage.c">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f61c1eead131/tools/string_storage.c</a>):</p>

<pre>
<i>/* Vypocet efektivity ulozeni retezcu na halde. */</i>
<i>/* Autor: Pavel Tisnovsky */</i>
&nbsp;
#include &lt;stdio.h&gt;
&nbsp;
<i>/* Hlavicka objektu ulozenych na halde */</i>
const int <strong>HEADER_SIZE</strong> = 8;
&nbsp;
<i>/* Atributy kazde instance tridy String */</i>
const int <strong>STRING_CLASS_OFFSET_FIELD</strong> = 4;
const int <strong>STRING_CLASS_COUNT_FIELD</strong>  = 4;
const int <strong>STRING_CLASS_HASH_FIELD</strong>   = 4;
const int <strong>STRING_CLASS_ARRAY_REF</strong>    = 4;
&nbsp;
<i>/* Atribut ulozeny spolecne s kazdym polem. */</i>
const int <strong>ARRAY_LENGTH</strong> = 4;
&nbsp;
int <strong>main</strong>(int argc, char **argv)
{
    int str_length = 0;
    float effectivity;
&nbsp;
<i>    /* Hlavicka tabulky */</i>
    printf("j_chars\tBytes\tPadding\tBytes+Padding\tShallow size\tRetained size\tEffectivity\n");
&nbsp;
<i>    /* Vypocet a zobrazeni efektivity ulozeni retezcu pro ruzne delky */</i>
    <strong>do</strong> {
<i>        /* char v Jave ma delku 2 bajty */</i>
        int bytes = str_length &lt;&lt; 1;
&nbsp;
<i>        /* dorovnani delky na velikost delitelnou ctyrmi */</i>
        int padding = (str_length % 2) &lt;&lt; 1;
&nbsp;
<i>        /* na zacatku je vetsinou 24 bajtu "rozsirene hlavicky" */</i>
        int shallow_size = HEADER_SIZE
                         + STRING_CLASS_OFFSET_FIELD
                         + STRING_CLASS_COUNT_FIELD
                         + STRING_CLASS_HASH_FIELD
                         + STRING_CLASS_ARRAY_REF;
        int retained_size = shallow_size + HEADER_SIZE + ARRAY_LENGTH + bytes + padding;
<i>        /* 0..100 % */</i>
        effectivity = 100.0 * bytes / retained_size;
&nbsp;
<i>        /* tisk jednoho radku tabulky */</i>
        printf("%d\t%d\t%d\t%d\t%d\t%d\t%5.1f%%\n",
                str_length, bytes, padding, bytes + padding, shallow_size, retained_size,
                effectivity);
        str_length++;
    } <strong>while</strong> (effectivity &lt; 90.0);
&nbsp;
    <strong>return</strong> 0;
}
</pre>

<p>Nejprve bude ukázán numerický výpis:</p>

<table>
<tr><th>j_chars</th><th>Bytes</th><th>Padding</th><th>Bytes+Padding</th><th>Shallow size</th><th>Retained size</th><th>Effectivity</th></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>24</td><td>36</td><td> 0.0%</td></tr>
<tr><td>1</td><td>2</td><td>2</td><td>4</td><td>24</td><td>40</td><td> 5.0%</td></tr>
<tr><td>2</td><td>4</td><td>0</td><td>4</td><td>24</td><td>40</td><td>10.0%</td></tr>
<tr><td>3</td><td>6</td><td>2</td><td>8</td><td>24</td><td>44</td><td>13.6%</td></tr>
<tr><td>4</td><td>8</td><td>0</td><td>8</td><td>24</td><td>44</td><td>18.2%</td></tr>
<tr><td>5</td><td>10</td><td>2</td><td>12</td><td>24</td><td>48</td><td>20.8%</td></tr>
<tr><td>6</td><td>12</td><td>0</td><td>12</td><td>24</td><td>48</td><td>25.0%</td></tr>
<tr><td>7</td><td>14</td><td>2</td><td>16</td><td>24</td><td>52</td><td>26.9%</td></tr>
<tr><td>8</td><td>16</td><td>0</td><td>16</td><td>24</td><td>52</td><td>30.8%</td></tr>
<tr><td>9</td><td>18</td><td>2</td><td>20</td><td>24</td><td>56</td><td>32.1%</td></tr>
<tr><td>10</td><td>20</td><td>0</td><td>20</td><td>24</td><td>56</td><td>35.7%</td></tr>
<tr><td>11</td><td>22</td><td>2</td><td>24</td><td>24</td><td>60</td><td>36.7%</td></tr>
<tr><td>12</td><td>24</td><td>0</td><td>24</td><td>24</td><td>60</td><td>40.0%</td></tr>
<tr><td>13</td><td>26</td><td>2</td><td>28</td><td>24</td><td>64</td><td>40.6%</td></tr>
<tr><td>14</td><td>28</td><td>0</td><td>28</td><td>24</td><td>64</td><td>43.8%</td></tr>
<tr><td>15</td><td>30</td><td>2</td><td>32</td><td>24</td><td>68</td><td>44.1%</td></tr>
<tr><td>16</td><td>32</td><td>0</td><td>32</td><td>24</td><td>68</td><td>47.1%</td></tr>
<tr><td>17</td><td>34</td><td>2</td><td>36</td><td>24</td><td>72</td><td>47.2%</td></tr>
<tr><td>18</td><td>36</td><td>0</td><td>36</td><td>24</td><td>72</td><td>50.0%</td></tr>
<tr><td>19</td><td>38</td><td>2</td><td>40</td><td>24</td><td>76</td><td>50.0%</td></tr>
<tr><td>20</td><td>40</td><td>0</td><td>40</td><td>24</td><td>76</td><td>52.6%</td></tr>
<tr><td>21</td><td>42</td><td>2</td><td>44</td><td>24</td><td>80</td><td>52.5%</td></tr>
<tr><td>22</td><td>44</td><td>0</td><td>44</td><td>24</td><td>80</td><td>55.0%</td></tr>
<tr><td>23</td><td>46</td><td>2</td><td>48</td><td>24</td><td>84</td><td>54.8%</td></tr>
<tr><td>24</td><td>48</td><td>0</td><td>48</td><td>24</td><td>84</td><td>57.1%</td></tr>
<tr><td>25</td><td>50</td><td>2</td><td>52</td><td>24</td><td>88</td><td>56.8%</td></tr>
<tr><td>26</td><td>52</td><td>0</td><td>52</td><td>24</td><td>88</td><td>59.1%</td></tr>
<tr><td>27</td><td>54</td><td>2</td><td>56</td><td>24</td><td>92</td><td>58.7%</td></tr>
<tr><td>28</td><td>56</td><td>0</td><td>56</td><td>24</td><td>92</td><td>60.9%</td></tr>
<tr><td>29</td><td>58</td><td>2</td><td>60</td><td>24</td><td>96</td><td>60.4%</td></tr>
<tr><td>30</td><td>60</td><td>0</td><td>60</td><td>24</td><td>96</td><td>62.5%</td></tr>
<tr><td>31</td><td>62</td><td>2</td><td>64</td><td>24</td><td>100</td><td>62.0%</td></tr>
<tr><td>32</td><td>64</td><td>0</td><td>64</td><td>24</td><td>100</td><td>64.0%</td></tr>
<tr><td>33</td><td>66</td><td>2</td><td>68</td><td>24</td><td>104</td><td>63.5%</td></tr>
<tr><td>34</td><td>68</td><td>0</td><td>68</td><td>24</td><td>104</td><td>65.4%</td></tr>
<tr><td>35</td><td>70</td><td>2</td><td>72</td><td>24</td><td>108</td><td>64.8%</td></tr>
<tr><td>36</td><td>72</td><td>0</td><td>72</td><td>24</td><td>108</td><td>66.7%</td></tr>
<tr><td>37</td><td>74</td><td>2</td><td>76</td><td>24</td><td>112</td><td>66.1%</td></tr>
<tr><td>38</td><td>76</td><td>0</td><td>76</td><td>24</td><td>112</td><td>67.9%</td></tr>
<tr><td>39</td><td>78</td><td>2</td><td>80</td><td>24</td><td>116</td><td>67.2%</td></tr>
<tr><td>40</td><td>80</td><td>0</td><td>80</td><td>24</td><td>116</td><td>69.0%</td></tr>
<tr><td>41</td><td>82</td><td>2</td><td>84</td><td>24</td><td>120</td><td>68.3%</td></tr>
<tr><td>42</td><td>84</td><td>0</td><td>84</td><td>24</td><td>120</td><td>70.0%</td></tr>
<tr><td>43</td><td>86</td><td>2</td><td>88</td><td>24</td><td>124</td><td>69.4%</td></tr>
<tr><td>44</td><td>88</td><td>0</td><td>88</td><td>24</td><td>124</td><td>71.0%</td></tr>
<tr><td>45</td><td>90</td><td>2</td><td>92</td><td>24</td><td>128</td><td>70.3%</td></tr>
<tr><td>46</td><td>92</td><td>0</td><td>92</td><td>24</td><td>128</td><td>71.9%</td></tr>
<tr><td>47</td><td>94</td><td>2</td><td>96</td><td>24</td><td>132</td><td>71.2%</td></tr>
<tr><td>48</td><td>96</td><td>0</td><td>96</td><td>24</td><td>132</td><td>72.7%</td></tr>
<tr><td>49</td><td>98</td><td>2</td><td>100</td><td>24</td><td>136</td><td>72.1%</td></tr>
<tr><td>50</td><td>100</td><td>0</td><td>100</td><td>24</td><td>136</td><td>73.5%</td></tr>
<tr><td>51</td><td>102</td><td>2</td><td>104</td><td>24</td><td>140</td><td>72.9%</td></tr>
<tr><td>52</td><td>104</td><td>0</td><td>104</td><td>24</td><td>140</td><td>74.3%</td></tr>
<tr><td>53</td><td>106</td><td>2</td><td>108</td><td>24</td><td>144</td><td>73.6%</td></tr>
<tr><td>54</td><td>108</td><td>0</td><td>108</td><td>24</td><td>144</td><td>75.0%</td></tr>
<tr><td>55</td><td>110</td><td>2</td><td>112</td><td>24</td><td>148</td><td>74.3%</td></tr>
<tr><td>56</td><td>112</td><td>0</td><td>112</td><td>24</td><td>148</td><td>75.7%</td></tr>
<tr><td>57</td><td>114</td><td>2</td><td>116</td><td>24</td><td>152</td><td>75.0%</td></tr>
<tr><td>58</td><td>116</td><td>0</td><td>116</td><td>24</td><td>152</td><td>76.3%</td></tr>
<tr><td>59</td><td>118</td><td>2</td><td>120</td><td>24</td><td>156</td><td>75.6%</td></tr>
<tr><td>60</td><td>120</td><td>0</td><td>120</td><td>24</td><td>156</td><td>76.9%</td></tr>
<tr><td>61</td><td>122</td><td>2</td><td>124</td><td>24</td><td>160</td><td>76.3%</td></tr>
<tr><td>62</td><td>124</td><td>0</td><td>124</td><td>24</td><td>160</td><td>77.5%</td></tr>
<tr><td>63</td><td>126</td><td>2</td><td>128</td><td>24</td><td>164</td><td>76.8%</td></tr>
<tr><td>64</td><td>128</td><td>0</td><td>128</td><td>24</td><td>164</td><td>78.0%</td></tr>
<tr><td>65</td><td>130</td><td>2</td><td>132</td><td>24</td><td>168</td><td>77.4%</td></tr>
<tr><td>66</td><td>132</td><td>0</td><td>132</td><td>24</td><td>168</td><td>78.6%</td></tr>
<tr><td>67</td><td>134</td><td>2</td><td>136</td><td>24</td><td>172</td><td>77.9%</td></tr>
<tr><td>68</td><td>136</td><td>0</td><td>136</td><td>24</td><td>172</td><td>79.1%</td></tr>
<tr><td>69</td><td>138</td><td>2</td><td>140</td><td>24</td><td>176</td><td>78.4%</td></tr>
<tr><td>70</td><td>140</td><td>0</td><td>140</td><td>24</td><td>176</td><td>79.5%</td></tr>
<tr><td>71</td><td>142</td><td>2</td><td>144</td><td>24</td><td>180</td><td>78.9%</td></tr>
<tr><td>72</td><td>144</td><td>0</td><td>144</td><td>24</td><td>180</td><td>80.0%</td></tr>
<tr><td>73</td><td>146</td><td>2</td><td>148</td><td>24</td><td>184</td><td>79.3%</td></tr>
<tr><td>74</td><td>148</td><td>0</td><td>148</td><td>24</td><td>184</td><td>80.4%</td></tr>
<tr><td>75</td><td>150</td><td>2</td><td>152</td><td>24</td><td>188</td><td>79.8%</td></tr>
<tr><td>76</td><td>152</td><td>0</td><td>152</td><td>24</td><td>188</td><td>80.9%</td></tr>
<tr><td>77</td><td>154</td><td>2</td><td>156</td><td>24</td><td>192</td><td>80.2%</td></tr>
<tr><td>78</td><td>156</td><td>0</td><td>156</td><td>24</td><td>192</td><td>81.3%</td></tr>
<tr><td>79</td><td>158</td><td>2</td><td>160</td><td>24</td><td>196</td><td>80.6%</td></tr>
<tr><td>80</td><td>160</td><td>0</td><td>160</td><td>24</td><td>196</td><td>81.6%</td></tr>
<tr><td>81</td><td>162</td><td>2</td><td>164</td><td>24</td><td>200</td><td>81.0%</td></tr>
<tr><td>82</td><td>164</td><td>0</td><td>164</td><td>24</td><td>200</td><td>82.0%</td></tr>
<tr><td>83</td><td>166</td><td>2</td><td>168</td><td>24</td><td>204</td><td>81.4%</td></tr>
<tr><td>84</td><td>168</td><td>0</td><td>168</td><td>24</td><td>204</td><td>82.4%</td></tr>
<tr><td>85</td><td>170</td><td>2</td><td>172</td><td>24</td><td>208</td><td>81.7%</td></tr>
<tr><td>86</td><td>172</td><td>0</td><td>172</td><td>24</td><td>208</td><td>82.7%</td></tr>
<tr><td>87</td><td>174</td><td>2</td><td>176</td><td>24</td><td>212</td><td>82.1%</td></tr>
<tr><td>88</td><td>176</td><td>0</td><td>176</td><td>24</td><td>212</td><td>83.0%</td></tr>
<tr><td>89</td><td>178</td><td>2</td><td>180</td><td>24</td><td>216</td><td>82.4%</td></tr>
<tr><td>90</td><td>180</td><td>0</td><td>180</td><td>24</td><td>216</td><td>83.3%</td></tr>
<tr><td>91</td><td>182</td><td>2</td><td>184</td><td>24</td><td>220</td><td>82.7%</td></tr>
<tr><td>92</td><td>184</td><td>0</td><td>184</td><td>24</td><td>220</td><td>83.6%</td></tr>
<tr><td>93</td><td>186</td><td>2</td><td>188</td><td>24</td><td>224</td><td>83.0%</td></tr>
<tr><td>94</td><td>188</td><td>0</td><td>188</td><td>24</td><td>224</td><td>83.9%</td></tr>
<tr><td>95</td><td>190</td><td>2</td><td>192</td><td>24</td><td>228</td><td>83.3%</td></tr>
<tr><td>96</td><td>192</td><td>0</td><td>192</td><td>24</td><td>228</td><td>84.2%</td></tr>
<tr><td>97</td><td>194</td><td>2</td><td>196</td><td>24</td><td>232</td><td>83.6%</td></tr>
<tr><td>98</td><td>196</td><td>0</td><td>196</td><td>24</td><td>232</td><td>84.5%</td></tr>
<tr><td>99</td><td>198</td><td>2</td><td>200</td><td>24</td><td>236</td><td>83.9%</td></tr>
<tr><td>100</td><td>200</td><td>0</td><td>200</td><td>24</td><td>236</td><td>84.7%</td></tr>
<tr><td>101</td><td>202</td><td>2</td><td>204</td><td>24</td><td>240</td><td>84.2%</td></tr>
<tr><td>102</td><td>204</td><td>0</td><td>204</td><td>24</td><td>240</td><td>85.0%</td></tr>
<tr><td>103</td><td>206</td><td>2</td><td>208</td><td>24</td><td>244</td><td>84.4%</td></tr>
<tr><td>104</td><td>208</td><td>0</td><td>208</td><td>24</td><td>244</td><td>85.2%</td></tr>
<tr><td>105</td><td>210</td><td>2</td><td>212</td><td>24</td><td>248</td><td>84.7%</td></tr>
<tr><td>106</td><td>212</td><td>0</td><td>212</td><td>24</td><td>248</td><td>85.5%</td></tr>
<tr><td>107</td><td>214</td><td>2</td><td>216</td><td>24</td><td>252</td><td>84.9%</td></tr>
<tr><td>108</td><td>216</td><td>0</td><td>216</td><td>24</td><td>252</td><td>85.7%</td></tr>
<tr><td>109</td><td>218</td><td>2</td><td>220</td><td>24</td><td>256</td><td>85.2%</td></tr>
<tr><td>110</td><td>220</td><td>0</td><td>220</td><td>24</td><td>256</td><td>85.9%</td></tr>
<tr><td>111</td><td>222</td><td>2</td><td>224</td><td>24</td><td>260</td><td>85.4%</td></tr>
<tr><td>112</td><td>224</td><td>0</td><td>224</td><td>24</td><td>260</td><td>86.2%</td></tr>
<tr><td>113</td><td>226</td><td>2</td><td>228</td><td>24</td><td>264</td><td>85.6%</td></tr>
<tr><td>114</td><td>228</td><td>0</td><td>228</td><td>24</td><td>264</td><td>86.4%</td></tr>
<tr><td>115</td><td>230</td><td>2</td><td>232</td><td>24</td><td>268</td><td>85.8%</td></tr>
<tr><td>116</td><td>232</td><td>0</td><td>232</td><td>24</td><td>268</td><td>86.6%</td></tr>
<tr><td>117</td><td>234</td><td>2</td><td>236</td><td>24</td><td>272</td><td>86.0%</td></tr>
<tr><td>118</td><td>236</td><td>0</td><td>236</td><td>24</td><td>272</td><td>86.8%</td></tr>
<tr><td>119</td><td>238</td><td>2</td><td>240</td><td>24</td><td>276</td><td>86.2%</td></tr>
<tr><td>120</td><td>240</td><td>0</td><td>240</td><td>24</td><td>276</td><td>87.0%</td></tr>
<tr><td>121</td><td>242</td><td>2</td><td>244</td><td>24</td><td>280</td><td>86.4%</td></tr>
<tr><td>122</td><td>244</td><td>0</td><td>244</td><td>24</td><td>280</td><td>87.1%</td></tr>
<tr><td>123</td><td>246</td><td>2</td><td>248</td><td>24</td><td>284</td><td>86.6%</td></tr>
<tr><td>124</td><td>248</td><td>0</td><td>248</td><td>24</td><td>284</td><td>87.3%</td></tr>
<tr><td>125</td><td>250</td><td>2</td><td>252</td><td>24</td><td>288</td><td>86.8%</td></tr>
<tr><td>126</td><td>252</td><td>0</td><td>252</td><td>24</td><td>288</td><td>87.5%</td></tr>
<tr><td>127</td><td>254</td><td>2</td><td>256</td><td>24</td><td>292</td><td>87.0%</td></tr>
<tr><td>128</td><td>256</td><td>0</td><td>256</td><td>24</td><td>292</td><td>87.7%</td></tr>
<tr><td>129</td><td>258</td><td>2</td><td>260</td><td>24</td><td>296</td><td>87.2%</td></tr>
<tr><td>130</td><td>260</td><td>0</td><td>260</td><td>24</td><td>296</td><td>87.8%</td></tr>
<tr><td>131</td><td>262</td><td>2</td><td>264</td><td>24</td><td>300</td><td>87.3%</td></tr>
<tr><td>132</td><td>264</td><td>0</td><td>264</td><td>24</td><td>300</td><td>88.0%</td></tr>
<tr><td>133</td><td>266</td><td>2</td><td>268</td><td>24</td><td>304</td><td>87.5%</td></tr>
<tr><td>134</td><td>268</td><td>0</td><td>268</td><td>24</td><td>304</td><td>88.2%</td></tr>
<tr><td>135</td><td>270</td><td>2</td><td>272</td><td>24</td><td>308</td><td>87.7%</td></tr>
<tr><td>136</td><td>272</td><td>0</td><td>272</td><td>24</td><td>308</td><td>88.3%</td></tr>
<tr><td>137</td><td>274</td><td>2</td><td>276</td><td>24</td><td>312</td><td>87.8%</td></tr>
<tr><td>138</td><td>276</td><td>0</td><td>276</td><td>24</td><td>312</td><td>88.5%</td></tr>
<tr><td>139</td><td>278</td><td>2</td><td>280</td><td>24</td><td>316</td><td>88.0%</td></tr>
<tr><td>140</td><td>280</td><td>0</td><td>280</td><td>24</td><td>316</td><td>88.6%</td></tr>
<tr><td>141</td><td>282</td><td>2</td><td>284</td><td>24</td><td>320</td><td>88.1%</td></tr>
<tr><td>142</td><td>284</td><td>0</td><td>284</td><td>24</td><td>320</td><td>88.8%</td></tr>
<tr><td>143</td><td>286</td><td>2</td><td>288</td><td>24</td><td>324</td><td>88.3%</td></tr>
<tr><td>144</td><td>288</td><td>0</td><td>288</td><td>24</td><td>324</td><td>88.9%</td></tr>
<tr><td>145</td><td>290</td><td>2</td><td>292</td><td>24</td><td>328</td><td>88.4%</td></tr>
<tr><td>146</td><td>292</td><td>0</td><td>292</td><td>24</td><td>328</td><td>89.0%</td></tr>
<tr><td>147</td><td>294</td><td>2</td><td>296</td><td>24</td><td>332</td><td>88.6%</td></tr>
<tr><td>148</td><td>296</td><td>0</td><td>296</td><td>24</td><td>332</td><td>89.2%</td></tr>
<tr><td>149</td><td>298</td><td>2</td><td>300</td><td>24</td><td>336</td><td>88.7%</td></tr>
<tr><td>150</td><td>300</td><td>0</td><td>300</td><td>24</td><td>336</td><td>89.3%</td></tr>
<tr><td>151</td><td>302</td><td>2</td><td>304</td><td>24</td><td>340</td><td>88.8%</td></tr>
<tr><td>152</td><td>304</td><td>0</td><td>304</td><td>24</td><td>340</td><td>89.4%</td></tr>
<tr><td>153</td><td>306</td><td>2</td><td>308</td><td>24</td><td>344</td><td>89.0%</td></tr>
<tr><td>154</td><td>308</td><td>0</td><td>308</td><td>24</td><td>344</td><td>89.5%</td></tr>
<tr><td>155</td><td>310</td><td>2</td><td>312</td><td>24</td><td>348</td><td>89.1%</td></tr>
<tr><td>156</td><td>312</td><td>0</td><td>312</td><td>24</td><td>348</td><td>89.7%</td></tr>
<tr><td>157</td><td>314</td><td>2</td><td>316</td><td>24</td><td>352</td><td>89.2%</td></tr>
<tr><td>158</td><td>316</td><td>0</td><td>316</td><td>24</td><td>352</td><td>89.8%</td></tr>
<tr><td>159</td><td>318</td><td>2</td><td>320</td><td>24</td><td>356</td><td>89.3%</td></tr>
<tr><td>160</td><td>320</td><td>0</td><td>320</td><td>24</td><td>356</td><td>89.9%</td></tr>
<tr><td>161</td><td>322</td><td>2</td><td>324</td><td>24</td><td>360</td><td>89.4%</td></tr>
<tr><td>162</td><td>324</td><td>0</td><td>324</td><td>24</td><td>360</td><td>90.0%</td></tr>
</table>

<p>Zajímavìj¹í je v¹ak graf, který ukazuje (pravá Y-ová osa a prùbìh vykreslený
hnìdou barvou), jak efektivita ulo¾ení nelineárnì roste a teprve pro øetìzce o
délce 161 znakù pøekraèuje 90% (z&nbsp;360 alokovaných bajtù se 324 bajtù
pou¾ije pro ulo¾ení znakù, zbytek je vlastnì re¾ie).</p>

<img src="http://i.iinfo.cz/images/376/java-string-storage-efficiency.png" alt="string_storage_graph" />



<p><a name="k11"></a></p>
<h2 id="k11">11. Zdrojové kódy v¹ech tøí agentù a k&nbsp;nim pøíslu¹ných testovacích pøíkladù</h2>

<p>Podobnì jako ve ètyøech pøedcházejících èástech tohoto seriálu byly i dne¹ní
tøi demonstraèní pøíklady kvùli snaz¹ímu udr¾ování v¹ech zdrojových kódù
ulo¾eny do Mercurial repositáøe, který je dostupný na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
Prozatím nejnovìj¹í verze dnes popisovaných <i>JVM TI</i> agentù i dal¹ích
potøebných skriptù a testovacích javovských tøíd jsou dostupné na následujících
adresách:</p>

<table>
<tr><th>Demonstraèní pøíklad/podpùrný soubor</th><th>Umístìní</th></tr>
<tr><td>Agent #23          </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f61c1eead131/jvmti-agents/agent23/agent23.c">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f61c1eead131/jvmti-agents/agent23/agent23.c</a></td></tr>
<tr><td>Skript pro pøeklad </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f61c1eead131/jvmti-agents/agent23/compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f61c1eead131/jvmti-agents/agent23/compile.sh</a></td></tr>
<tr><td>Skript pro spu¹tìní</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f61c1eead131/jvmti-agents/agent23/test.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f61c1eead131/jvmti-agents/agent23/test.sh</a></td></tr>
<tr><td>Testovací tøída    </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f61c1eead131/jvmti-agents/agent23/Test23.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f61c1eead131/jvmti-agents/agent23/Test23.java</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Agent #24          </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f61c1eead131/jvmti-agents/agent24/agent24.c">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f61c1eead131/jvmti-agents/agent24/agent24.c</a></td></tr>
<tr><td>Skript pro pøeklad </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f61c1eead131/jvmti-agents/agent24/compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f61c1eead131/jvmti-agents/agent24/compile.sh</a></td></tr>
<tr><td>Skript pro spu¹tìní</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f61c1eead131/jvmti-agents/agent24/test.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f61c1eead131/jvmti-agents/agent24/test.sh</a></td></tr>
<tr><td>Testovací tøída    </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f61c1eead131/jvmti-agents/agent24/Test24.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f61c1eead131/jvmti-agents/agent24/Test24.java</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Výpoèet efektivity ulo¾ení øetìzcù</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f61c1eead131/tools/string_storage.c">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f61c1eead131/tools/string_storage.c</a></td></tr>
</table>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>The JVM Tool Interface (JVM TI): How VM Agents Work<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html">http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html</a>
</li>

<li>JVM Tool Interface Version 1.2<br />
<a href="http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html">http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html</a>
</li>

<li>Creating a Debugging and Profiling Agent with JVMTI<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html">http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html</a>
</li>

<li>JVM TI (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/JVM_TI">http://en.wikipedia.org/wiki/JVM_TI</a>
</li>

<li>IBM JVMTI extensions<br />
<a href="http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html">http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

