<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - nastavení breakpointù s vyu¾itím rozhraní JVM TI (pokraèování)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - nastavení breakpointù s vyu¾itím rozhraní JVM TI (pokraèování)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o vlastnostech JVM budeme pokraèovat v popisu zpùsobu nastavování breakpointù s vyu¾itím rozhraní JVM TI. Na pøíkladu demonstraèního JVM TI agenta si uká¾eme, jak lze zaregistrovat breakpoint pro zvolenou metodu a èíslo øádku i to, jakým zpùsobem je agent informován a vstupu na breakpoint.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Demonstraèní agent èíslo 31 &ndash; nastavení breakpointu a výpis zprávy pøi pøístupu na breakpoint</a></p>
<p><a href="#k02">2. Pøíprava pro nastavení breakpointu</a></p>
<p><a href="#k03">3. Nastavení breakpointu pro zvolenou metodu a èíslo øádku</a></p>
<p><a href="#k04">4. Pøevod èísla øádku na index instrukce</a></p>
<p><a href="#k05">5. Registrace callback funkce zavolané pøi vstupu na breakpoint</a></p>
<p><a href="#k06">6. Testovací tøída pou¾itá spoleènì s&nbsp;demonstraèním agentem èíslo 31</a></p>
<p><a href="#k07">7. Spu¹tìní tøicátého prvního demonstraèního JVM TI agenta</a></p>
<p><a href="#k08">8. Zdrojové kódy demonstraèního agenta i k&nbsp;nìmu pøíslu¹ných testovacích pøíkladù a skriptù</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Demonstraèní agent èíslo 31 &ndash; nastavení breakpointu a výpis zprávy pøi pøístupu na breakpoint</h2>

<p>V&nbsp;pøedchozí èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyce Java i o vlastnostech virtuálního stroje Javy</a> jsme si
øekli základní informace o tom, jakým zpùsobem je mo¾né s&nbsp;vyu¾itím
rozhraní <i>JVM TI</i> nastavit breakpoint a následnì zaregistrovat callback
funkci zavolanou ve chvíli, kdy libovolné vlákno v&nbsp;aplikaci pøistoupí na
nìkterý z&nbsp;nastavených breakpointù (tìch mù¾e být samozøejmì zaregistrováno
libovolné mno¾ství). Pøipomeòme si, ¾e pro nastavení breakpointu se vyu¾ívá
funkce nazvaná <strong>jvmti-&gt;SetBreakpoint()</strong> a v&nbsp;pøípadì, ¾e
potøebujeme nìkterý døíve nastavený breakpoint zru¹it, zavolá se funkce
<strong>jvmti-&gt;ClearBreakpoint()</strong>. Breakpointù mù¾e být
zaregistrováno libovolné mno¾ství a ve chvíli, kdy nìjaké vlákno
k&nbsp;zaregistrovanému breakpointu dojde, zavolá rozhraní <i>JVM TI</i>
callback funkci spoleènou pro v¹echny nastavené breakpointy. V&nbsp;zavolané
callback funkci je ji¾ mo¾né získat v¹echny potøebné informace o místì, kde
vlákno do¹lo k&nbsp;breakpointu, lze samozøejmì získat hodnoty atributù
sledovaného objektu, výpis zásobníkových rámcù platných pro aktuální vlákno
atd.</p>

<p>Obìma zmínìným funkcím <strong>jvmti-&gt;SetBreakpoint()</strong> a
<strong>jvmti-&gt;ClearBreakpoint()</strong> je nutné pøedat dva dùle¾ité
údaje, které rozhraní <i>JVM TI</i> vyu¾ije pro nastavení popø.&nbsp;naopak pro
zru¹ení breakpointu (hlavièky obou funkcí jsou shodné). Jedná se v&nbsp;první
øadì o jednoznaèný identifikátor metody, tj.&nbsp;o hodnotu typu
<strong>jmethodID</strong>, kterou je nutné nìjakým zpùsobem získat (jeden ze
zpùsobù jsme si ukázali minule a vrátíme se k&nbsp;nìmu i v&nbsp;dne¹ním
demonstraèním pøíkladu). Druhým dùle¾itým parametrem pøedávaným do funkce
<strong>jvmti-&gt;SetBreakpoint()</strong> i do
<strong>jvmti-&gt;ClearBreakpoint()</strong> je parametr typu
<strong>jlocation</strong>, který urèuje pøesné místo v&nbsp;rámci metody, kam
má být breakpoint umístìn. Ve vìt¹inì existujících virtuálních strojù Javy
platí, ¾e <strong>jlocation</strong> odpovídá indexùm instrukcí bajtkódu
v&nbsp;metodì, co¾ znamená, ¾e breakpoint lze nastavit s&nbsp;pøesností na
&bdquo;strojovou&ldquo; instrukci, zatímco vìt¹ina (?) debuggerù a
integrovaných vývojových prostøedí pracuje s&nbsp;øádky zdrojového kódu.</p>

<p>Posledním dùle¾itým údajem zmínìným minule je informace o hlavièce callback
funkce zaregistrované a zavolané ve chvíli, kdy nìjaké vlákno aplikace dosáhne
breakpointu. Této callback funkci se mj.&nbsp;pøedá i informace o vláknu, které
breakpointu dosáhlo, identifikátor metody s&nbsp;breakpointem a pøesná lokace
breakpointu v&nbsp;rámci této metody. Díky tìmto informacím je zaji¹tìno, ¾e
v&nbsp;<i>JVM TI</i> agentovi mù¾e být zaregistrována pouze tato jediná
callback funkce (jak se registruje, si øekneme za chvíli), která bude
vyu¾itelná pro v¹echny breakpointy. Hlavièka této callback funkce vypadá
následovnì:</p>

<pre>
void JNICALL <strong>Breakpoint</strong>(
            jvmtiEnv *jvmti_env,
            JNIEnv   *jni_env,
            jthread   thread,
            jmethodID method,
            jlocation location)
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Pøíprava pro nastavení breakpointu</h2>

<p>Nyní si pojïme øíci, jakou pøípravu je nutné udìlat pøi nastavení
breakpointu pro zvolenou metodu. První èást na¹eho problému jsme ji¾ vlastnì
vyøe¹ili minule &ndash; na základì jména tøídy a jména metody doká¾eme
relativnì jednodu¹e získat hodnotu typu <strong>jmethodID</strong>, která
vybranou metodu jednoznaènì reprezentuje v&nbsp;rámci spu¹tìného virtuálního
stroje Javy. Mù¾eme se tedy pustit do pøípravy dne¹ního (celkovì ji¾ tøicátého
prvního!) demonstraèního <i>JVM TI</i> agenta, v&nbsp;nìm¾ se nejprve
zaregistruje breakpoint a po pøístupu k&nbsp;tomuto breakpointu se zavolá
u¾ivatelská callback funkce, která vypí¹e informaci o náv¹tìvì breakpointu.</p>

<p>Nejprve je nutné nastavit po¾adované schopnosti agenta, kde si vy¾ádáme
mo¾nost generovat události pøi prùchodu breakpointem:</p>

<pre>
<i>/*</i>
<i> * Nastaveni pozadovanych schopnosti agenta.</i>
<i> */</i>
jvmtiError <strong>set_capabilities</strong>(jvmtiEnv *jvmti)
{
    jvmtiCapabilities capabilities;
    jvmtiError error_code;
&nbsp;
    memset(&amp;capabilities, 0, sizeof(jvmtiCapabilities));
&nbsp;
<i>    /* vyuzivame tri specialni schopnosti agenta */</i>
    capabilities.can_get_line_numbers = 1;
    capabilities.can_get_source_file_name = 1;
    <strong>capabilities.can_generate_breakpoint_events = 1;</strong>
&nbsp;
    error_code = (*jvmti)-&gt;AddCapabilities(jvmti, &amp;capabilities);
    check_jvmti_error(jvmti, error_code, "Unable to get necessary JVMTI capabilities.");
    return error_code;
}
</pre>

<p>Dále pou¾ijeme upravenou variantu funkce
<strong>callback_on_class_prepare()</strong>, kde ji¾ nebude docházet pouze
k&nbsp;výpisu v¹ech metod testovací tøídy, ale v&nbsp;pøípadì, ¾e se nalezne
tøída, pro její¾ metodu se má nastavit breakpoint, dojde k&nbsp;zavolání dal¹í
u¾ivatelské funkce <strong>prepare_breakpoint()</strong>:</p>

<pre>
<i>/*</i>
<i> * Callback funkce zavolana ve chvili, kdy je trida ve virtualnim stroji ve stavu,</i>
<i> * kdy ji lze normalne pouzivat.</i>
<i> */</i>
static void JNICALL <strong>callback_on_class_prepare</strong>(
        jvmtiEnv *jvmti_env,
        JNIEnv   *jni_env,
        jthread   thread,
        jclass    class)
{
    jvmtiError error;
    char *class_name_ptr;
    char *updated_class_name_ptr;
&nbsp;
    enter_critical_section(jvmti_env);
&nbsp;
<i>    /* ziskat jmeno tridy */</i>
    error = (*jvmti_env)-&gt;GetClassSignature(jvmti_env, class, &amp;class_name_ptr, NULL);
    check_jvmti_error(jvmti_env, error, "get class signature");
    if (class_name_ptr == NULL)
    {
        puts("Error: class has no signature");
    }
&nbsp;
<i>    /* upravit jmeno tridy */</i>
    updated_class_name_ptr = update_class_name(class_name_ptr, ';');
&nbsp;
<i>    /* pokud jsme nasli to pravou tridu */</i>
    if (strcmp(updated_class_name_ptr, TEST_CLASS_NAME) == 0)
    {
        puts("Class "TEST_CLASS_NAME" prepared, setting breakpoint for method "BREAKPOINT_FOR_METHOD);
        <strong>prepare_breakpoint(jvmti_env, class);</strong>
    }
&nbsp;
<i>    /* dealokace pameti po GetClassSignature() */</i>
    error = (*jvmti_env)-&gt;Deallocate(jvmti_env, (unsigned char *)class_name_ptr);
    check_jvmti_error(jvmti_env, error, "deallocate class name");
    exit_critical_section(jvmti_env);
}
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Nastavení breakpointu pro zvolenou metodu a èíslo øádku</h2>

<p>V&nbsp;u¾ivatelské funkci <strong>prepare_breakpoint()</strong> nejprve ji¾
popsaným postupem získáme seznam (resp.&nbsp;pøesnìji øeèeno se jedná o céèkové
pole) v¹ech metod vybrané tøídy a v&nbsp;pøípadì, ¾e nalezneme metodu, pro ní¾
se má breakpoint nastavit, dojde k&nbsp;zavolání tøetí (ji¾ témìø poslední)
u¾ivatelské funkce nazvané <strong>set_breakpoint()</strong>, které se pøedá
identifikátor metody typu <strong>jmethodID</strong>. Test, zda jsme skuteènì
na¹li metodu, pro ní¾ se má breakpoint nastavit, je v&nbsp;na¹em demonstraèním
pøíkladu velmi jednoduchý, proto¾e pouze porovnáváme <i>jméno</i> metody
s&nbsp;názvem ulo¾eným v&nbsp;konstantì <strong>BREAKPOINT_FOR_METHOD</strong>.
V&nbsp;praxi by byla situace ponìkud slo¾itìj¹í, proto¾e v&nbsp;jedné tøídì se
samozøejmì mù¾e nacházet vìt¹í mno¾ství metod se stejným jménem, ale odli¹nou
signaturou. Korektnìj¹í by tedy bylo porovnávat i signatury metod:</p>

<pre>
<i>/*</i>
<i> * Registrace breakpointu pro zvolenou metodu.</i>
<i> */</i>
void <strong>prepare_breakpoint</strong>(jvmtiEnv *jvmti_env, jclass class)
{
    jvmtiError  error;
    int         method_count;
    jmethodID  *methods_array;
&nbsp;
<i>    /* precist vsechny metody tridy */</i>
    error = (*jvmti_env)-&gt;<strong>GetClassMethods</strong>(jvmti_env, class, &amp;method_count, &amp;methods_array);
    check_jvmti_error(jvmti_env, error, "get class methods");
&nbsp;
<i>    /* pole metod bylo inicializovano */</i>
    if (error == JVMTI_ERROR_NONE)
    {
        int i;
<i>        /* projit vsemi metodami a nastavit breakpoint pro zvolenou metodu */</i>
        for (i = 0; i &lt; method_count; i++)
        {
            char *method_name;
            char *method_signature;
            jmethodID method = methods_array[i];
            error = (*jvmti_env)-&gt;<strong>GetMethodName</strong>(jvmti_env, method, &amp;method_name, &amp;method_signature, NULL);
            if (error == JVMTI_ERROR_NONE)
            {
                printf("Found method(): %s with signature %s\n", method_name, method_signature);
                if (strcmp(method_name, BREAKPOINT_FOR_METHOD) == 0)
                {
                    puts("...going to set breakpoint for this method");
                    <strong>set_breakpoint(jvmti_env, method, BREAKPOINT_LINE_NUMBER);</strong>
                }
                (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char*)method_name);
                (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char*)method_signature);
            }
        }
    }
&nbsp;
<i>    /* dealokace pole ziskaneho pres GetClassFields() */</i>
    error = (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char*)methods_array);
    check_jvmti_error(jvmti_env, error, "deallocate class fields array");
}
</pre>

<p>Funkce <strong>set_breakpoint()</strong> zavolaná z&nbsp;vý¹e popsané funkce
<strong>prepare_breakpoint()</strong>, je ve skuteènosti velmi jednoduchá
&ndash; nejprve zjistí hodnotu <strong>jlocation</strong> a posléze pouze
zavolá <i>JVM TI</i> funkci <strong>SetBreakpoint()</strong> se v¹emi
vy¾adovanými parametry:</p>

<pre>
<i>/*</i>
<i> * Nastaveni breakpointu pro zvolenou metodu na danem radku.</i>
<i> */</i>
void <strong>set_breakpoint</strong>(jvmtiEnv *jvmti_env, jmethodID method, int line)
{
    jvmtiError  error;
    jlocation   location = <strong>get_location_for_line</strong>(jvmti_env, method, line);
&nbsp;
    error = (*jvmti_env)-&gt;SetBreakpoint(jvmti_env, method, location);
    check_jvmti_error(jvmti_env, error, "set breakpoint");
}
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Pøevod èísla øádku na index instrukce</h2>

<p>Jak jste si zajisté <a href="#k03">v&nbsp;pøedchozí kapitole</a> v¹imli,
volali jsme z&nbsp;u¾ivatelské funkce <strong>set_breakpoint()</strong> dal¹í
&ndash; prozatím neznámou &ndash; u¾ivatelskou funkci nazvanou
<strong>get_location_for_line()</strong>. Tato funkce pøevádí èíslo øádku
(kladné celé èíslo) na hodnotu typu <strong>jlocation</strong> s&nbsp;vyu¾itím
<i>JVM TI</i> funkce <strong>jvmti-&gt;GetLineNumberTable()</strong>. Tento
pøevod se provádí pøesnì opaèným zpùsobem, ne¾ tomu bylo ve funkci
<strong>get_line_number()</strong>, jí¾ jsme pou¾ili napøíklad ve <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/810c61d5d549/jvmti-agents/agent29/agent29.c">dvacátém
devátém demonstraèním JVM TI agentovi</a> popsaném v&nbsp;pøedminulé èásti
tohoto seriálu.</p>

<p>Rozdíl mezi obìma zmínìnými funkcemi spoèívá v&nbsp;tom, jakým zpùsobem se
pracuje s&nbsp;tabulkou obsahující záznamy typu
<strong>jvmtiLineNumberEntry</strong> &ndash; zde toti¾ pro zadané èíslo øádku
vyhledáme index první instrukce bajtkódu odpovídajícímu zdrojovému øádku (pro
jednoduchost pøedpokládejme, ¾e zdrojový øádek skuteènì obsahuje pøelo¾itelný
kód).</p>

<p>Kód u¾ivatelské funkce <strong>get_location_for_line()</strong> mù¾e
v&nbsp;nejjednodu¹¹ím pøípadì vypadat následovnì:</p>

<pre>
<i>/*</i>
<i> * Ziskani indexu instrukce pro dane cislo radku.</i>
<i> */</i>
jlocation <strong>get_location_for_line</strong>(jvmtiEnv *jvmti_env, jmethodID method, int line)
{
    int count;
    int i;
    jvmtiLineNumberEntry *location_table;
    jvmtiError error_code;
<i>    /* pokud se èíslo øádku nenalezne nebo zde není ¾ádný kód, vrátí se chybová hodnota -1 */</i>
    jlocation  location = -1;
&nbsp;
<i>    /* pokud nebyla pøedána ¾ádná metoda */</i>
    if (method == NULL)
    {
        return -1;
    }
&nbsp;
<i>    /* test na korektnì zadané èíslo øádku */</i>
    if (line &lt;= 0)
    {
        return -1;
    }
&nbsp;
<i>    /* nacteni tabulky s cisly radku a indexy instrukci */</i>
    error_code = (*jvmti_env)-&gt;GetLineNumberTable(jvmti_env, method, &amp;count, &amp;location_table);
<i>    /* v nekterych pripadech se nacist tabulku nemusi podarit */</i>
    if (error_code != JVMTI_ERROR_NONE)
    {
        return -1;
    }
&nbsp;
<i>    /* projit celou tabulkou */</i>
    for (i = 0; i &lt; count; i++)
    {
        jvmtiLineNumberEntry entry = location_table[i];
        if (entry.line_number == line)
        {
            location = entry.start_location;
            break;
        }
    }
&nbsp;
<i>    /* nesmíme zapomenout na dealokaci tabulky (pole) s dvojicemi èíslo øádku:location */</i>
    (*jvmti_env)-&gt;Deallocate(jvmti_env, (unsigned char *)location_table);
    return location;
}
</pre>

<p>Nesmíme zapomenout pouze na jednu drobnost &ndash; èíslo øádku se neuvádí
relativnì vùèi zaèátku metody, ale jedná se o èíslo platné v&nbsp;rámci
zdrojového kódu tøídy, tedy o stejné èíslo, které se zobrazí v&nbsp;textovém
editoru. Takté¾ je nutné zajistit, aby <i>JVM TI</i> agent mìl nastavenou
vlastnosti <strong>can_get_line_numbers</strong> (co¾ je ji¾ zaøízeno ve funkci
<strong>set_capabilities()</strong>).</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Registrace callback funkce zavolané pøi vstupu na breakpoint</h2>

<p>Aby se skuteènì zavolala callback funkce pøi prùchodu nìjakého vlákna
zaregistrovaným breakpointem, je nutné nastavit notifikaèní re¾im
<strong>JVMTI_EVENT_BREAKPOINT</strong>, co¾ se ji¾ tradiènì provádí
v&nbsp;u¾ivatelské funkci nazvané
<strong>set_event_notification_modes()</strong>:</p>

<pre>
<i>/*</i>
<i> * Nastaveni udalosti, pro nez se maji zavolat callback funkce.</i>
<i> */</i>
jvmtiError <strong>set_event_notification_modes</strong>(jvmtiEnv *jvmti)
{
    jvmtiError error_code;
&nbsp;
<i>    /* Potrebujeme zachytavat udalost inicializace virtualniho stroje. */</i>
    if ((error_code = set_event_notification_mode(jvmti, JVMTI_EVENT_VM_INIT)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
<i>    /* Potrebujeme zachytavat udalost ukonceni prace virtualniho stroje. */</i>
    if ((error_code = set_event_notification_mode(jvmti, JVMTI_EVENT_VM_DEATH)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
<i>    /* Udalost pri priprave tridy ve virtualnim stroji. */</i>
    if ((error_code = set_event_notification_mode(jvmti, JVMTI_EVENT_CLASS_PREPARE)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
<i>    /* Udalost pri vstupu na radek s breakpointem. */</i>
    if ((error_code = <strong>set_event_notification_mode(jvmti, JVMTI_EVENT_BREAKPOINT))</strong> != JNI_OK)
    {
        return error_code;
    }
&nbsp;
    return error_code;
}
</pre>

<p>Registrace nové callback funkce nazvané pøíznaènì
<strong>callback_on_breakpoint()</strong> se provede v&nbsp;u¾ivatelské funkci
<strong>register_all_callback_functions()</strong>, kterou ji¾ známe
z&nbsp;naprosté vìt¹iny a¾ doposud popsaných demonstraèních <i>JVM TI</i>
agentù. Pov¹imnìte si toho, ¾e ukazatel na tuto callback funkci se ukládá do
struktury <strong>jvmtiEventCallbacks.Breakpoint</strong>:</p>

<pre>
<i>/*</i>
<i> * Registrace ctyr callback funkci zavolanych virtualnim strojem javy.</i>
<i> */</i>
jvmtiError <strong>register_all_callback_functions</strong>(jvmtiEnv *jvmti)
{
    jvmtiEventCallbacks callbacks;
    jvmtiError error_code;
&nbsp;
    memset(&amp;callbacks, 0, sizeof(callbacks));
&nbsp;
<i>    /* JVMTI_EVENT_VM_INIT */</i>
    callbacks.VMInit = &amp;callback_on_vm_init;
&nbsp;
<i>    /* JVMTI_EVENT_VM_DEATH */</i>
    callbacks.VMDeath = &amp;callback_on_vm_death;
&nbsp;
<i>    /* JVMTI_EVENT_CLASS_PREPARE */</i>
    callbacks.ClassPrepare = &amp;callback_on_class_prepare;
&nbsp;
<i>    /* JVMTI_EVENT_BREAKPOINT */</i>
    <strong>callbacks.Breakpoint = &amp;callback_on_breakpoint;</strong>
&nbsp;
    error_code = (*jvmti)-&gt;SetEventCallbacks(jvmti, &amp;callbacks, (jint)sizeof(callbacks));
    check_jvmti_error(jvmti, error_code, "Cannot set JVM TI callbacks");
    return error_code;
}
</pre>

<p>Callback funkce zavolaná pøi vstupu na øádek s&nbsp;nastaveným breakpointem,
je velmi jednoduchá, proto¾e pouze na standardní výstup vypí¹e zprávu o
náv¹tìvì breakpointu. Ov¹em vzhledem k&nbsp;tomu, ¾e se této callback funkci
pøedá identifikátor vlákna, identifikátor metody s&nbsp;breakpointem i pøesná
lokace breakpointu v&nbsp;rámci této metody, mohly by se v&nbsp;této callback
funkci ve skuteènosti provádìt i mnohem slo¾itìj¹í operace, proto¾e pøes
parametr typu <strong>jthread</strong> lze získat celý stav vlákna, vèetnì
obsahu zásobníkových rámcù atd.:</p>

<pre>
<i>/*</i>
<i> * Callback funkce zavolana pri zapisu vybranych atributu</i>
<i> */</i>
static void JNICALL <strong>callback_on_breakpoint</strong>(
        jvmtiEnv *jvmti_env,
        JNIEnv*   jni_env,
        jthread   thread,
        jmethodID method,
        jlocation location)
{
    printf("*** visited breakpoint!!! ***\n");
}
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Testovací tøída pou¾itá spoleènì s&nbsp;demonstraèním agentem èíslo 31</h2>

<p>Pro otestování korektní èinnosti tøicátého prvního <i>JVM TI</i> agenta byla
vytvoøena testovací tøída nazvaná, jak ji¾ zajisté oèekáváte,
<strong>Test31</strong>. V&nbsp;této tøídì je definováno nìkolik metod, pro nás
je v¹ak nejdùle¾itìj¹í metoda <strong>bar()</strong>, proto¾e právì pro tuto
metodu se nastavuje breakpoint. Ze zdrojového kódu <i>JVM TI</i> agenta lze
získat informaci o tom, ¾e breakpoint se nastavuje pro øádek èíslo 14 &ndash;
jedná se o hodnotu pøiøazenou konstantì
<strong>BREAKPOINT_LINE_NUMBER</strong>. V&nbsp;pøípadì, ¾e si v&nbsp;textovém
editoru otevøete zdrojový kód tøídy <strong>Test31</strong> (soubor <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2a7ebf111840/jvmti-agents/agent31/Test31.java">Test31.java</a>),
zjistíte, ¾e tìlo metody <strong>bar()</strong> se skuteènì nachází na øádcích
12, 13, 14 a 15, tak¾e k&nbsp;nastavení breakpointu na øádek
<strong>Test31:14</strong> skuteènì mù¾e bez problému dojít:</p>

<pre>
<i>/**</i>
<i>  * Testovaci trida pouzite pro test tricateho</i>
<i>  * prvniho demonstracniho JVM TI agenta.</i>
<i>  */</i>
public class <strong>Test31</strong> {
    public void <strong>foo</strong>() {
        System.out.println("Test31.foo()");
        bar();
    }
&nbsp;
    public void <strong>bar</strong>() {
        System.out.println("Test31.bar() line 12");
        System.out.println("Test31.bar() line 13");
        System.out.println("Test31.bar() line 14");
        System.out.println("Test31.bar() line 15");
    }
&nbsp;
    public void <strong>run</strong>() {
        System.out.println("Test31.run()");
        foo();
    }
&nbsp;
    public int <strong>x</strong>() {return 0;}
    public int <strong>x</strong>(int y) {return 0;}
    public int <strong>x</strong>(int y, boolean z) {return 0;}
    public int[] <strong>x</strong>(int[] y, double[][] z) {return null;}
&nbsp;
<i>    /**</i>
<i>      * Spusteni testu.</i>
<i>      */</i>
    public static void <strong>main</strong>(String[] args) {
        new Test31().run();
    }
&nbsp;
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Spu¹tìní tøicátého prvního demonstraèního JVM TI agenta</h2>

<p>Po pøekladu tøicátého prvního demonstraèního <i>JVM TI</i> agenta, jeho¾
úplný zdrojový kód najdete <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2a7ebf111840/jvmti-agents/agent31/agent31.c">pod
tímto odkazem</a> si mù¾eme vyzkou¹et jeho spu¹tìní spoleènì s&nbsp;testovací
tøídou <strong>Test31</strong>. Spu¹tìní se provede pøíkazem:</p>

<pre>
java -agentpath:./libagent31.so Test31 2&gt; /dev/null
</pre>

<p><i>JVM TI</i> agent by mìl nejprve vypsat informaci o v¹ech nalezených
metodách testovací tøídy <strong>Test31</strong> a posléze by mìl vypsat
øetìzec <strong>*** visited breakpoint!!! ***</strong> ve chvíli dosa¾ení
breakpointu. Vzhledem k&nbsp;tomu, ¾e se na standardním výstupu kombinují
zprávy vypisované agentem se zprávami vypisovanými testovací tøídou, lze
jednodu¹e zjistit, ¾e byl breakpoint skuteènì zaregistrován na správném místì
ve zdrojovém kódu tøídy <strong>Test31</strong>:</p>

<pre>
Test31.run()
Test31.foo()
Test31.bar() line 1
Test31.bar() line 2
Test31.bar() line 3
Test31.bar() line 4
Agent31: Agent_OnLoad
Agent31: JVM TI version is correct
Agent31: Got VM init event
Class Test31; prepared, setting breakpoint for method bar
Found method(): &lt;init&gt; with signature ()V
Found method(): main with signature ([Ljava/lang/String;)V
Found method(): run with signature ()V
Found method(): x with signature ()I
Found method(): x with signature (I)I
Found method(): x with signature (IZ)I
Found method(): x with signature ([I[[D)[I
Found method(): foo with signature ()V
Found method(): bar with signature ()V
...going to set breakpoint for this method
<strong>*** visited breakpoint!!! ***</strong>
Agent31: Got VM Death event
Agent31: Agent_OnUnload
</pre>

<p>Sami si mù¾ete pro zajímavost vyzkou¹et, co se stane v&nbsp;pøípadì, pokud
je breakpoint umístìn do programové smyèky.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Zdrojové kódy demonstraèního agenta i k&nbsp;nìmu pøíslu¹ných testovacích pøíkladù a skriptù</h2>

<p>Zdrojový kód tøicátého prvního demonstraèního <i>JVM TI</i> agenta je,
spoleènì s&nbsp;testovací tøídou <strong>Test31</strong> i skripty pou¾itými
pro pøeklad a spu¹tìní agenta, ulo¾en do Mercurial repositáøe dostupného na
adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
Prozatím nejnovìj¹í verze v¹ech zmínìných zdrojových souborù jsou dostupné na
adresách:</p>

<table>
<tr><td>Agent #31                     </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2a7ebf111840/jvmti-agents/agent31/agent31.c">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2a7ebf111840/jvmti-agents/agent31/agent31.c</a></td></tr>
<tr><td>Skript pro pøeklad agenta #31 </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2a7ebf111840/jvmti-agents/agent31/compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2a7ebf111840/jvmti-agents/agent31/compile.sh</a></td></tr>
<tr><td>Skript pro spu¹tìní agenta #31</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2a7ebf111840/jvmti-agents/agent31/test.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2a7ebf111840/jvmti-agents/agent31/test.sh</a></td></tr>
<tr><td>Testovací tøída Test31.java   </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2a7ebf111840/jvmti-agents/agent31/Test31.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2a7ebf111840/jvmti-agents/agent31/Test31.java</a></td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Breakpoint (Wikipedia)<br />
<a href="http://cs.wikipedia.org/wiki/Breakpoint">http://cs.wikipedia.org/wiki/Breakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation<br />
<a href="http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html">http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; SetBreakpoint<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#SetBreakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#SetBreakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; ClearBreakpoint<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#ClearBreakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#ClearBreakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; Breakpoint (callback funkce)<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#Breakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#Breakpoint</a>
</li>

<li>The JVM Tool Interface (JVM TI): How VM Agents Work<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html">http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html</a>
</li>

<li>Creating a Debugging and Profiling Agent with JVMTI<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html">http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html</a>
</li>

<li>JVM TI (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/JVM_TI">http://en.wikipedia.org/wiki/JVM_TI</a>
</li>

<li>IBM JVMTI extensions<br />
<a href="http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html">http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

