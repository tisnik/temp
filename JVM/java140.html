<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - volání funkcí a metod v JVM, Lua VM a Python VM</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - volání funkcí a metod v JVM, Lua VM a Python VM</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Dal¹ími velmi dùle¾itými instrukcemi, které jsou souèástí bajtkódù prakticky v¹ech virtuálních strojù, jsou instrukce urèené pro volání funkcí, popø. metod. Právì touto pomìrnì rozsáhlou problematikou se budeme zabývat v dne¹ní èásti seriálu o programovacím jazyku Java a JVM. Nejdøíve opìt zaèneme s popisem JVM, pozdìji navá¾eme popisem Lua VM a Python VM.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - volání funkcí a metod v JVM, Lua VM a Python VM</a></p>
<p><a href="#k02">2. Volání metod v&nbsp;bajtkódu programovacího jazyka Java (JVM)</a></p>
<p><a href="#k03">3. Instrukce <strong>invokestatic</strong></a></p>
<p><a href="#k04">4. Demonstraèní pøíklad <strong>Test27.java</strong>: pou¾ití instrukce <strong>invokestatic</strong></a></p>
<p><a href="#k05">5. Instrukce <strong>invokevirtual</strong></a></p>
<p><a href="#k06">6. Demonstraèní pøíklad <strong>Test28.java</strong>: pou¾ití instrukce <strong>invokevirtual</strong></a></p>
<p><a href="#k07">7. Instrukce <strong>invokespecial</strong></a></p>
<p><a href="#k08">8. Demonstraèní pøíklad <strong>Test29.java</strong>: pou¾ití instrukce <strong>invokespecial</strong></a></p>
<p><a href="#k09">9. Instrukce <strong>invokeinterface</strong></a></p>
<p><a href="#k10">10. Demonstraèní pøíklad <strong>Test30.java</strong>: pou¾ití instrukce <strong>invokeinterface</strong></a></p>
<p><a href="#k11">11. Repositáø se zdrojovými kódy v¹ech ètyø dne¹ních demonstraèních pøíkladù</a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - volání funkcí a metod v JVM, Lua VM a Python VM</h2>

<p>Jednou z&nbsp;posledních a prozatím nepopsaných oblastí souvisejících
s&nbsp;bìhem programù ve virtuálních strojích jazykù Java, Lua i Python, je
volání funkcí popø.&nbsp;metod. Jedná se samozøejmì o velmi èasto provádìnou
èinnost, pøi ní¾ je kromì vlastního zavolání vybrané funkce nebo metody nutné
zajistit pøedání hodnot parametrù a takté¾ zpracování návratové hodnoty (Java)
èi vìt¹ího mno¾ství návratových hodnot (Lua). V&nbsp;dne¹ním èlánku se zamìøíme
pøedev¹ím na popis volání metod v&nbsp;bajtkódu programovacího jazyka Java,
nebo» zde je situace asi nejslo¾itìj¹í, a to mj.&nbsp;i kvùli silnému typovému
systému Javy a s&nbsp;ním související nutnosti znát u ka¾dé metody pøesný poèet
a takté¾ typ v¹ech jejích parametrù. V&nbsp;navazující èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">tohoto
seriálu</a> si pak mo¾nosti Javy a pøedev¹ím JVM porovnáme s&nbsp;mo¾nostmi
programovacích jazykù Lua a Python i jejich virtuálních strojù (Lua VM a Python
VM).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Volání metod v&nbsp;bajtkódu programovacího jazyka Java (JVM)</h2>

<p>Virtuální stroj programovacího jazyka Java obsahuje ètyøi (resp.&nbsp;dnes
ji¾ pìt) instrukcí bajtkódu urèených pro volání metod rùzných typù. Tyto
instrukce se jmenují <strong>invokestatic</strong>,
<strong>invokevirtual</strong>, <strong>invokespecial</strong> a
<strong>invokeinterface</strong>. Novì byla do bajtkódu JVM pøidána i instrukce
<strong>invokedynamic</strong>, která má význam pøedev¹ím pøi implementaci
dynamicky typovaných programovacích jazykù nad JVM. V&nbsp;dal¹ím textu se
budeme zabývat pøedev¹ím prvními ètyømi zmínìnými instrukcemi. Na rozdíl od
instrukcí JVM popsaných v&nbsp;pøedchozích èláncích jsou v¹echny ètyøi
instrukce <strong>invoke*</strong> zvlá¹tní tím, ¾e pracují se
<i>signaturami</i> metod ulo¾enými v&nbsp;<i>constant poolu</i>. Díky tomu
mohou být u instrukcí uvedeny jen ¹estnáctibitové indexy do <i>constant
poolu</i> a nikoli plná jména metod a jejich typù, co¾ mj.&nbsp;znamená výrazné
zkrácení celého bajtkódu (a takté¾ snaz¹í a rychlej¹í práci JIT
pøekladaèe):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Provádìná operace</th></tr>
<tr><td>1</td><td>invokestatic </td><td>0xB8</td><td>highbyte, lowbyte</td><td>zavolání statické metody s&nbsp;pøedáním parametrù této metodì</td></tr>
<tr><td>2</td><td>invokevirtual</td><td>0xB6</td><td>highbyte, lowbyte</td><td>zavolání nestatické metody s&nbsp;pøedáním hodnoty <strong>this</strong> a v¹ech dal¹ích parametrù</td></tr>
<tr><td>3</td><td>invokespecial</td><td>0xB7</td><td>highbyte, lowbyte</td><td>zavolání privátní metody popø.&nbsp;konstruktoru</td></tr>
<tr><td>4</td><td>invokeinterface</td><td>0xB9</td><td>highbyte, lowbyte, count</td><td>zavolání metody deklarované v&nbsp;rozhraní, samozøejmì s&nbsp;pøedáním parametrù</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Instrukce <strong>invokestatic</strong></h2>

<p>Instrukce bajtkódu JVM nazvaná <strong>invokestatic</strong> slou¾í, jak ji¾
ostatnì název této instrukce napovídá, k&nbsp;zavolání statické metody,
tj.&nbsp;takové metody, kterou je mo¾né zavolat i v&nbsp;pøípadì, ¾e neexistuje
¾ádná instance tøídy, v&nbsp;ní¾ je tato metoda deklarována (samozøejmì za
pøedpokladu, ¾e jsou vhodnì nastavena pøístupová práva k&nbsp;metodì, to je
kontrolováno jak v&nbsp;dobì pøekladu, tak i v&nbsp;dobì bìhu aplikace). Tato
instrukce pracuje se signaturami metod ulo¾ených v&nbsp;<i>constant poolu</i>.
Pøed zavoláním statické metody je nutné na zásobník operandù ulo¾it v¹echny
parametry volané metody a po zavolání metody a návratu z&nbsp;ní se na tomté¾
zásobníku bude nacházet návratová hodnota (samozøejmì za pøedpokladu, ¾e se
nejedná o metodu s&nbsp;návratovou hodnotou <strong>void</strong>). ®ádné dal¹í
hodnoty se volané metodì nepøedávají. Formát instrukce
<strong>invokestatic</strong> je následující:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Provádìná operace</th></tr>
<tr><td>1</td><td>invokestatic </td><td>0xB8</td><td>highbyte, lowbyte</td><td>zavolání statické metody s&nbsp;pøedáním parametrù této metodì</td></tr>
</table>

<p>Operandy <i>highbyte</i> a <i>lowbyte</i> tvoøí ¹estnáctibitový index do
<i>constant poolu</i>. Záznam ulo¾ený na daném indexu musí být typu
<i>MethodReference</i>, co¾ je pro pøipomenutí záznam obsahující odkaz na
záznam typu <i>Class</i> (jméno tøídy) a takté¾ na záznam typu <i>Name and
Type</i> (signatura metody èi atributu). JVM tedy ví, kterou metodu má zavolat
(nemusí tedy pracnì párovat datové typy parametrù s&nbsp;typy argumentù atd.),
ov¹em pøesnou adresu metody vyhodnocuje a¾ v&nbsp;dobì bìhu aplikace.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Demonstraèní pøíklad <strong>Test27.java</strong>: pou¾ití instrukce <strong>invokestatic</strong></h2>

<p>Podívejme se nyní na velmi jednoduchý demonstraèní pøíklad nazvaný
<strong>Test27.java</strong>. V&nbsp;tomto pøíkladu jsou deklarovány ètyøi
statické metody pojmenované <strong>staticMethod1()</strong> a¾
<strong>staticMethod4()</strong>, které jsou následnì volány z (nestatických)
metod <strong>callStaticMethod1()</strong> a¾
<strong>callStaticMethod4()</strong>. Navíc se v&nbsp;metodì
<strong>callStaticMethod5()</strong> volá <strong>Math.abs()</strong>,
tj.&nbsp;metoda nále¾ející jiné tøídì:</p>

<pre>
<i>/**</i>
<i> * Demonstracni priklad cislo 27.</i>
<i> *</i>
<i> * Vyuziti instrukce invokestatic.</i>
<i> */</i>
public class <strong>Test27</strong> {
&nbsp;
    <i>/**</i>
    <i> * Staticka bezparametricka metoda.</i>
    <i> */</i>
    static void <strong>staticMethod1</strong>() {
        <i>// nic = prazdne telo metody</i>
    }
&nbsp;
    <i>/**</i>
    <i> * Staticka bezparametricka metoda vracejici cele cislo.</i>
    <i> */</i>
    static int <strong>staticMethod2</strong>() {
        return 42;
    }
&nbsp;
    <i>/**</i>
    <i> * Staticka metoda se dvema parametry.</i>
    <i> */</i>
    static void <strong>staticMethod3</strong>(int x, int y) {
        <i>// nic = prazdne telo metody</i>
    }
&nbsp;
    <i>/**</i>
    <i> * Staticka metoda se dvema parametry vracejici cele cislo.</i>
    <i> */</i>
    static int <strong>staticMethod4</strong>(int x, int y) {
        return x + y;
    }
&nbsp;
    <i>/**</i>
    <i> * Volani staticke metody ze stejne tridy.</i>
    <i> */</i>
    void <strong>callStaticMethod1</strong>() {
        staticMethod1();
    }
&nbsp;
    <i>/**</i>
    <i> * Volani staticke metody ze stejne tridy.</i>
    <i> */</i>
    void <strong>callStaticMethod2</strong>() {
        staticMethod2();
    }
&nbsp;
    <i>/**</i>
    <i> * Volani staticke metody ze stejne tridy.</i>
    <i> */</i>
    void <strong>callStaticMethod3</strong>() {
        staticMethod3(1, 2);
    }
&nbsp;
    <i>/**</i>
    <i> * Volani staticke metody ze stejne tridy.</i>
    <i> */</i>
    void <strong>callStaticMethod4</strong>() {
        staticMethod4(3, 4);
    }
&nbsp;
    <i>/**</i>
    <i> * Volani staticke metody ze tridy Math.</i>
    <i> */</i>
    void <strong>callStaticMethod5</strong>() {
        Math.abs(42);
    }
&nbsp;
}
</pre>

<p>Ètyøi volané statické metody <strong>staticMethod1()</strong> a¾
<strong>staticMethod4()</strong> jsou do bajtkódu pøelo¾eny následujícím
zpùsobem:</p>

<pre>
  static void <strong>staticMethod1</strong>();
    Code:
       0: return               <i>// vyskok z metody bez pouziti navratove hodnoty</i>
&nbsp;
  static int <strong>staticMethod2</strong>();
    Code:
       0: bipush        42     <i>// ulozit na vrchol zasobniku operandu konstantu 42</i>
       2: ireturn              <i>// vyskok z metody s navratovou hodnotou ziskanou z TOS</i>
&nbsp;
  static void <strong>staticMethod3</strong>(int, int);
    Code:
       0: return               <i>// vyskok z metody bez pouziti navratove hodnoty</i>
&nbsp;
  static int <strong>staticMethod4</strong>(int, int);
    Code:
       0: iload_0              <i>// ulozit na vrchol zasobniku operandu hodnotu prvniho parametru metody</i>
       1: iload_1              <i>// ulozit na vrchol zasobniku operandu hodnotu druheho parametru metody</i>
       2: iadd                 <i>// secist hodnotu obou parametru a vratit vysledek zpet na TOS</i>
       3: ireturn              <i>// vyskok z metody s navratovou hodnotou ziskanou z TOS</i>
</pre>

<p>Volání tìchto metod je v&nbsp;bajtkódu provedeno instrukcí
<strong>invokestatic</strong>:</p>

<pre>
  void <strong>callStaticMethod1</strong>();
    Code:
       0: invokestatic  #2;    <i>// volani staticke metody: Method staticMethod1:()V</i>
       3: return               <i>// vyskok z metody bez pouziti navratove hodnoty</i>
&nbsp;
  void <strong>callStaticMethod2</strong>();
    Code:
       0: invokestatic  #3;    <i>// volani staticke metody: Method staticMethod2:()I</i>
       3: pop                  <i>// odstranit navratovou hodnotu ze zasobniku operandu</i>
       4: return               <i>// vyskok z metody bez pouziti navratove hodnoty</i>
&nbsp;
  void <strong>callStaticMethod3</strong>();
    Code:
       0: iconst_1             <i>// ulozit na zasobnik operandu hodnotu prvniho argumentu volane metody</i>
       1: iconst_2             <i>// ulozit na zasobnik operandu hodnotu druheho argumentu volane metody</i>
       2: invokestatic  #4;    <i>// volani staticke metody: Method staticMethod3:(II)V</i>
       5: return               <i>// vyskok z metody bez pouziti navratove hodnoty</i>
&nbsp;
  void <strong>callStaticMethod4</strong>();
    Code:
       0: iconst_3             <i>// ulozit na zasobnik operandu hodnotu prvniho argumentu volane metody</i>
       1: iconst_4             <i>// ulozit na zasobnik operandu hodnotu druheho argumentu volane metody</i>
       2: invokestatic  #5;    <i>// volani staticke metody: Method staticMethod4:(II)I</i>
       5: pop                  <i>// odstranit navratovou hodnotu ze zasobniku operandu</i>
       6: return               <i>// vyskok z metody bez pouziti navratove hodnoty</i>
<pre>

<p>Stejnou instrukcí je zaji¹tìno i volání metody
<strong>Math.abs()</strong>:</p>

</pre>
  void <strong>callStaticMethod5</strong>();
    Code:
       0: bipush        42     <i>// ulozit na zasobnik operandu hodnotu jedineho argumentu volane metody</i>
       2: invokestatic  #6;    <i>// volani staticke metody: Method java/lang/Math.abs:(I)I</i>
       5: pop                  <i>// odstranit navratovou hodnotu ze zasobniku operandu</i>
       6: return               <i>// vyskok z metody bez pouziti navratove hodnoty</i>
</pre>

<p>U instrukcí <strong>invokestatic</strong> byly jako parametry pou¾ity indexy
#2 a¾ #6 ukazující na záznamy typu <strong>MethodRef</strong>
v&nbsp;<i>constant poolu</i>:</p>

<pre>
Constant pool:
   #1 = Methodref          #8.#27;        <i>//  java/lang/Object."init":()V</i>
   #2 = Methodref          #7.#28;        <i>//  Test27.staticMethod1:()V</i>
   #3 = Methodref          #7.#29;        <i>//  Test27.staticMethod2:()I</i>
   #4 = Methodref          #7.#30;        <i>//  Test27.staticMethod3:(II)V</i>
   #5 = Methodref          #7.#31;        <i>//  Test27.staticMethod4:(II)I</i>
   #6 = Methodref          #32.#33;       <i>//  java/lang/Math.abs:(I)I</i>
   #7 = Class              #34;           <i>//  Test27</i>
   #8 = Class              #35;           <i>//  java/lang/Object</i>
   #9 = Utf8               init;
  #10 = Utf8               ()V;
  #11 = Utf8               Code;
  #12 = Utf8               LineNumberTable;
  #13 = Utf8               staticMethod1;
  #14 = Utf8               staticMethod2;
  #15 = Utf8               ()I;
  #16 = Utf8               staticMethod3;
  #17 = Utf8               (II)V;
  #18 = Utf8               staticMethod4;
  #19 = Utf8               (II)I;
  #20 = Utf8               callStaticMethod1;
  #21 = Utf8               callStaticMethod2;
  #22 = Utf8               callStaticMethod3;
  #23 = Utf8               callStaticMethod4;
  #24 = Utf8               callStaticMethod5;
  #25 = Utf8               SourceFile;
  #26 = Utf8               Test27.java;
  #27 = NameAndType        #9:#10;        <i>//  "init":()V</i>
  #28 = NameAndType        #13:#10;       <i>//  staticMethod1:()V</i>
  #29 = NameAndType        #14:#15;       <i>//  staticMethod2:()I</i>
  #30 = NameAndType        #16:#17;       <i>//  staticMethod3:(II)V</i>
  #31 = NameAndType        #18:#19;       <i>//  staticMethod4:(II)I</i>
  #32 = Class              #36;           <i>//  java/lang/Math</i>
  #33 = NameAndType        #37:#38;       <i>//  abs:(I)I</i>
  #34 = Utf8               Test27;
  #35 = Utf8               java/lang/Object;
  #36 = Utf8               java/lang/Math;
  #37 = Utf8               abs;
  #38 = Utf8               (I)I;
</pre>

<p>Podívejme se nyní na to, jakým konkrétním zpùsobem je v&nbsp;<i>constant
poolu</i> ulo¾ena signatura metody <strong>Test27.staticMethod3()</strong>.
Tato signatura se nachází na indexu #4, kde je v¹ak ulo¾ena pouze dvojice
indexù #7 a #30. První index odkazuje na jméno tøídy, druhý index na záznam
typu <i>NameAndType</i>, kde je (opìt nepøímo) ulo¾eno jméno metody i typy
jejích parametrù a typ návratové hodnoty:</p>

<pre>
+-+--- #4  = Methodref          #7.#30;        <i>//  Test27.staticMethod3:(II)V</i>
| | 
| +--&gt;  #7 = Class              #34;-----+     <i>//  Test27</i>
|                                        |
+----&gt; #30 = NameAndType        #16:#17; |     <i>//  staticMethod3:(II)V</i>
                                 |   |   |
       #16 = Utf8 &lt;--------------+   |   |    "staticMethod3;"
       #17 = Utf8 &lt;------------------+   |    "(II)V;"
                                         |
       #34 = Utf8 &lt;----------------------+    "Test27;"
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Instrukce <strong>invokevirtual</strong></h2>

<p>V&nbsp;pøípadì instrukce <strong>invokevirtual</strong> je situace ponìkud
slo¾itìj¹í, ne¾ u vý¹e popsané instrukce <strong>invokestatic</strong>, proto¾e
virtuální stroj Javy musí zjistit, metoda které tøídy má být ve skuteènosti
zavolána &ndash; mù¾e se toti¾ jednat o metodu pøedka, a to v&nbsp;libovolné
úrovni (klidnì se mù¾e jednat i o metodu prapøedka v¹ech tøíd &ndash; tøídy
<strong>Object</strong>). Proto virtuální stroj Javy rekurzivnì prochází pøedky
tøídy, její¾ instance je ulo¾ena na zásobníku operandù a hledá metodu se
signaturou stejnou, jako je signatura ulo¾ená v&nbsp;<i>constant poolu</i>.
Jakmile je taková metoda nalezena, je rekurzivní vyhledávání ihned ukonèeno a
nalezená metoda je zavolána se v¹emi parametry, vèetnì skrytého parametru
pøedstavujícího <strong>this</strong> (referenci na objekt, pro nìj¾ je metoda
zavolána). Z&nbsp;tohoto dùvodu v&nbsp;demonstraèním pøíkladu popsaném
v&nbsp;navazující kapitole budou mít v¹echny testovací metody jeden skrytý
parametr, který musí být pøed voláním nestatické metody naplnìn (pøedávání
parametrù se opìt provádí pøes zásobník operandù).</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Demonstraèní pøíklad <strong>Test28.java</strong>: pou¾ití instrukce <strong>invokevirtual</strong></h2>

<p>V&nbsp;dne¹ním druhém demonstraèním pøíkladu <strong>Test28.java</strong>
jsou deklarovány ètyøi nestatické metody <strong>nonStaticMethod1()</strong> a¾
<strong>nonStaticMethod4()</strong>, které jsou následnì volány
z&nbsp;testovacích metod <strong>callnonStaticMethod1()</strong> a¾
<strong>callNonStaticMethod4()</strong>. V&nbsp;páté testovací metodì
<strong>callNonStaticMethod5()</strong> je volána dal¹í nestatická metoda
<strong>getClass()</strong>, jen¾ je ov¹em deklarována v&nbsp;pøedkovi tøídy
<strong>Test28</strong>:</p>

<pre>
<i>/**</i>
<i> * Demonstracni priklad cislo 28.</i>
<i> *</i>
<i> * Vyuziti instrukce invokevirtual.</i>
<i> */</i>
public class <strong>Test28</strong> {
&nbsp;
    <i>/**</i>
    <i> * Nestaticka bezparametricka metoda.</i>
    <i> */</i>
    void <strong>nonStaticMethod1</strong>() {
        <i>// nic = prazdne telo metody</i>
    }
&nbsp;
    <i>/**</i>
    <i> * Nestaticka bezparametricka metoda vracejici cele cislo.</i>
    <i> */</i>
    int <strong>nonStaticMethod2</strong>() {
        return 42;
    }
&nbsp;
    <i>/**</i>
    <i> * Nestaticka metoda se dvema parametry.</i>
    <i> */</i>
    void <strong>nonStaticMethod3</strong>(int x, int y) {
        <i>// nic = prazdne telo metody</i>
    }
&nbsp;
    <i>/**</i>
    <i> * Nestaticka metoda se dvema parametry vracejici cele cislo.</i>
    <i> */</i>
    int <strong>nonStaticMethod4</strong>(int x, int y) {
        return x + y;
    }
&nbsp;
    <i>/**</i>
    <i> * Volani nestaticke metody ze stejne tridy.</i>
    <i> */</i>
    void <strong>callnonStaticMethod1</strong>() {
        nonStaticMethod1();
    }
&nbsp;
    <i>/**</i>
    <i> * Volani nestaticke metody ze stejne tridy.</i>
    <i> */</i>
    void <strong>callnonStaticMethod2</strong>() {
        nonStaticMethod2();
    }
&nbsp;
    <i>/**</i>
    <i> * Volani nestaticke metody ze stejne tridy.</i>
    <i> */</i>
    void <strong>callnonStaticMethod3</strong>() {
        nonStaticMethod3(1, 2);
    }
&nbsp;
    <i>/**</i>
    <i> * Volani nestaticke metody ze stejne tridy.</i>
    <i> */</i>
    void <strong>callnonStaticMethod4</strong>() {
        nonStaticMethod4(3, 4);
    }
&nbsp;
    <i>/**</i>
    <i> * Volani nestaticke metody ze stejne tridy.</i>
    <i> */</i>
    void <strong>callnonStaticMethod5</strong>() {
        getClass();
    }
&nbsp;
}
</pre>

<p>Bajtkódy pøelo¾ených metod <strong>nonStaticMethod1()</strong> a¾
<strong>nonStaticMethod4()</strong> vypadají následovnì. Zajímavý je pøedev¹ím
bajtkód poslední zmínìné metody, proto¾e je zde patrné &bdquo;posunutí&ldquo;
indexù parametrù kvùli tomu, ¾e se na pozici prvního parametru nachází
<strong>this</strong>:</p>

<pre>
  void <strong>nonStaticMethod1</strong>();
    Code:
       0: return               <i>// vyskok z metody bez pouziti navratove hodnoty</i>
&nbsp;
  int <strong>nonStaticMethod2</strong>();
    Code:
       0: bipush        42     <i>// ulozit na vrchol zasobniku operandu konstantu 42</i>
       2: ireturn              <i>// vyskok z metody s navratovou hodnotou ziskanou z TOS</i>
&nbsp;
  void <strong>nonStaticMethod3</strong>(int, int);
    Code:
       0: return               <i>// vyskok z metody bez pouziti navratove hodnoty</i>
&nbsp;
  int <strong>nonStaticMethod4</strong>(int, int);
    Code:
       0: iload_1              <i>// ulozit na vrchol zasobniku operandu hodnotu prvniho parametru metody</i>
       1: iload_2              <i>// ulozit na vrchol zasobniku operandu hodnotu druheho parametru metody</i>
       2: iadd                 <i>// secist hodnotu obou parametru a vratit vysledek zpet na TOS</i>
       3: ireturn              <i>// vyskok z metody s navratovou hodnotou ziskanou z TOS</i>
</pre>

<p>Pøi volání v¹ech metod je pou¾ita instrukce <strong>invokevirtual</strong>,
pøièem¾ se v¾dy pøed voláním ulo¾í na zásobník operandù i hodnota
<strong>this</strong> a to konkrétnì s&nbsp;pou¾itím instrukce
<strong>aload_0</strong>:</p>

<pre>
  void <strong>callnonStaticMethod1</strong>();
    Code:
       0: aload_0              <i>// ulozit na vrchol zasobniku operandu hodnotu <strong>this</strong></i>
       1: invokevirtual #2;    <i>// volani virtualni metody: Method nonStaticMethod1:()V</i>
       4: return               <i>// vyskok z metody bez pouziti navratove hodnoty</i>
&nbsp;
  void <strong>callnonStaticMethod2</strong>();
    Code:
       0: aload_0              <i>// ulozit na vrchol zasobniku operandu hodnotu <strong>this</strong></i>
       1: invokevirtual #3;    <i>// volani virtualni metody: Method nonStaticMethod2:()I</i>
       4: pop                  <i>// odstranit navratovou hodnotu ze zasobniku operandu</i>
       5: return               <i>// vyskok z metody bez pouziti navratove hodnoty</i>
&nbsp;
  void <strong>callnonStaticMethod3</strong>();
    Code:
       0: aload_0              <i>// ulozit na vrchol zasobniku operandu hodnotu <strong>this</strong></i>
       1: iconst_1             <i>// ulozit na zasobnik operandu hodnotu prvniho argumentu volane metody</i>
       2: iconst_2             <i>// ulozit na zasobnik operandu hodnotu druheho argumentu volane metody</i>
       3: invokevirtual #4;    <i>// volani virtualni metody: Method nonStaticMethod3:(II)V</i>
       6: return               <i>// vyskok z metody bez pouziti navratove hodnoty</i>
&nbsp;
  void <strong>callnonStaticMethod4</strong>();
    Code:
       0: aload_0              <i>// ulozit na vrchol zasobniku operandu hodnotu <strong>this</strong></i>
       1: iconst_3             <i>// ulozit na zasobnik operandu hodnotu prvniho argumentu volane metody</i>
       2: iconst_4             <i>// ulozit na zasobnik operandu hodnotu druheho argumentu volane metody</i>
       3: invokevirtual #5;    <i>// volani virtualni metody: Method nonStaticMethod4:(II)I</i>
       6: pop                  <i>// odstranit navratovou hodnotu ze zasobniku operandu</i>
       7: return               <i>// vyskok z metody bez pouziti navratove hodnoty</i>
<pre>

<p>Zcela stejným zpùsobem, tj.&nbsp;pøes instrukci
<strong>invokevirtual</strong>, je zavolána i metoda pøedka:</p>

</pre>
  void <strong>callnonStaticMethod5</strong>();
    Code:
       0: aload_0              <i>// ulozit na vrchol zasobniku operandu hodnotu <strong>this</strong></i>
       1: invokevirtual #6;    <i>// volani virtualni metody: Method java/lang/Object.getClass:()Ljava/lang/Class;</i>
       4: pop                  <i>// odstranit navratovou hodnotu ze zasobniku operandu</i>
       5: return               <i>// vyskok z metody bez pouziti navratove hodnoty</i>
</pre>

<p>Pro úplnost doplòme strukturu <i>constant poolu</i>, zejména záznamù na
indexech #2 a¾ #6, kde jsou ulo¾eny signatury volaných metod:</p>

<pre>
   #1 = Methodref          #8.#27;        //  java/lang/Object."init":()V
   #2 = Methodref          #7.#28;        //  Test28.nonStaticMethod1:()V
   #3 = Methodref          #7.#29;        //  Test28.nonStaticMethod2:()I
   #4 = Methodref          #7.#30;        //  Test28.nonStaticMethod3:(II)V
   #5 = Methodref          #7.#31;        //  Test28.nonStaticMethod4:(II)I
   #6 = Methodref          #8.#32;        //  java/lang/Object.getClass:()Ljava/lang/Class;
   #7 = Class              #33;           //  Test28
   #8 = Class              #34;           //  java/lang/Object
   #9 = Utf8               init;
  #10 = Utf8               ()V;
  #11 = Utf8               Code;
  #12 = Utf8               LineNumberTable;
  #13 = Utf8               nonStaticMethod1;
  #14 = Utf8               nonStaticMethod2;
  #15 = Utf8               ()I;
  #16 = Utf8               nonStaticMethod3;
  #17 = Utf8               (II)V;
  #18 = Utf8               nonStaticMethod4;
  #19 = Utf8               (II)I;
  #20 = Utf8               callnonStaticMethod1;
  #21 = Utf8               callnonStaticMethod2;
  #22 = Utf8               callnonStaticMethod3;
  #23 = Utf8               callnonStaticMethod4;
  #24 = Utf8               callnonStaticMethod5;
  #25 = Utf8               SourceFile;
  #26 = Utf8               Test28.java;
  #27 = NameAndType        #9:#10;        //  "init":()V
  #28 = NameAndType        #13:#10;       //  nonStaticMethod1:()V
  #29 = NameAndType        #14:#15;       //  nonStaticMethod2:()I
  #30 = NameAndType        #16:#17;       //  nonStaticMethod3:(II)V
  #31 = NameAndType        #18:#19;       //  nonStaticMethod4:(II)I
  #32 = NameAndType        #35:#36;       //  getClass:()Ljava/lang/Class;
  #33 = Utf8               Test28;
  #34 = Utf8               java/lang/Object;
  #35 = Utf8               getClass;
  #36 = Utf8               ()Ljava/lang/Class;;
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Instrukce <strong>invokespecial</strong></h2>

<p>Dal¹í instrukcí urèenou v&nbsp;bajtkódu JVM pro volání metod, je instrukce
nazvaná <strong>invokespecial</strong>. Tato instrukce se pou¾ívá zejména pøi
inicializaci objektu, konkrétnì pøi volání konstruktoru pøedka poté, co je
objekt vytvoøen, ale takté¾ pøi volání privátních metod, popø.&nbsp;pøekrytých
metod. Struktura instrukce <strong>invokespecial</strong> je vypsána
v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Provádìná operace</th></tr>
<tr><td>1</td><td>invokespecial</td><td>0xB7</td><td>highbyte, lowbyte</td><td>zavolání privátní metody popø.&nbsp;konstruktoru</td></tr>
</table>

<p>Formát této instrukce je tedy toto¾ný s&nbsp;formátem instrukcí
<strong>invokestatic</strong> i <strong>invokevirtual</strong>.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Demonstraèní pøíklad <strong>Test29.java</strong>: pou¾ití instrukce <strong>invokespecial</strong></h2>

<p>Jak jsme si ji¾ øekli <a href="#k07">v&nbsp;pøedchozí kapitole</a>, má
instrukce <strong>invokespecial</strong> hned nìkolik mo¾ností vyu¾ití. První
z&nbsp;nich je volání privátní metody. Instrukce <strong>invokespecial</strong>
se vyu¾ívá takté¾ pøi inicializaci objektù. Oba zpùsoby pou¾ití této instrukce
budou ilustrovány na demonstraèním pøíkladu <strong>Test29</strong>:</p>

<pre>
<i>/**</i>
<i> * Demonstracni priklad cislo 29.</i>
<i> *</i>
<i> * Vyuziti instrukce invokespecial.</i>
<i> */</i>
public class <strong>Test29</strong> {
&nbsp;
    <i>/**</i>
    <i> * Privatni staticka bezparametricka metoda.</i>
    <i> */</i>
    private void <strong>nonStaticPrivateMethod1</strong>() {
        <i>// nic = prazdne telo metody</i>
    }
&nbsp;
    <i>/**</i>
    <i> * Privatni staticka bezparametricka metoda vracejici cele cislo.</i>
    <i> */</i>
    private int <strong>nonStaticPrivateMethod2</strong>() {
        return 42;
    }
&nbsp;
    <i>/**</i>
    <i> * Privatni staticka metoda se dvema parametry.</i>
    <i> */</i>
    private void <strong>nonStaticPrivateMethod3</strong>(int x, int y) {
        <i>// nic = prazdne telo metody</i>
    }
&nbsp;
    <i>/**</i>
    <i> * Privatni staticka metoda se dvema parametry vracejici cele cislo.</i>
    <i> */</i>
    private int <strong>nonStaticPrivateMethod4</strong>(int x, int y) {
        return x + y;
    }
&nbsp;
    <i>/**</i>
    <i> * Volani privatni staticke metody ze stejne tridy.</i>
    <i> */</i>
    void <strong>callNonStaticPrivateMethod1</strong>() {
        nonStaticPrivateMethod1();
    }
&nbsp;
    <i>/**</i>
    <i> * Volani privatni staticke metody ze stejne tridy.</i>
    <i> */</i>
    void <strong>callNonStaticPrivateMethod2</strong>() {
        nonStaticPrivateMethod2();
    }
&nbsp;
    <i>/**</i>
    <i> * Volani privatni staticke metody ze stejne tridy.</i>
    <i> */</i>
    void <strong>callNonStaticPrivateMethod3</strong>() {
        nonStaticPrivateMethod3(1, 2);
    }
&nbsp;
    <i>/**</i>
    <i> * Volani privatni staticke metody ze stejne tridy.</i>
    <i> */</i>
    void <strong>callNonStaticPrivateMethod4</strong>() {
        nonStaticPrivateMethod4(3, 4);
    }
&nbsp;
    <i>/**</i>
    <i> * Volani konstruktoru.</i>
    <i> */</i>
    void <strong>callConstructor</strong>() {
        new Test29();
    }
&nbsp;
}
</pre>

<p>Pøeklad metod <strong>nonStaticPrivateMethod1</strong> a¾
<strong>nonStaticPrivateMethod4</strong> do bajtkódu JVM je vlastnì stejný
s&nbsp;pøekladem, který jsme ji¾ vidìli u pøedchozího demonstraèního
pøíkladu:</p>

<pre>
  private void <strong>nonStaticPrivateMethod1</strong>();
    Code:
       0: return               <i>// vyskok z metody bez pouziti navratove hodnoty</i>
&nbsp;
  private int <strong>nonStaticPrivateMethod2</strong>();
    Code:
       0: bipush        42     <i>// ulozit na vrchol zasobniku operandu konstantu 42</i>
       2: ireturn              <i>// vyskok z metody s navratovou hodnotou ziskanou z TOS</i>
&nbsp;
  private void <strong>nonStaticPrivateMethod3</strong>(int, int);
    Code:
       0: return               <i>// vyskok z metody bez pouziti navratove hodnoty</i>
&nbsp;
  private int <strong>nonStaticPrivateMethod4</strong>(int, int);
    Code:
       0: iload_1              <i>// ulozit na vrchol zasobniku operandu hodnotu prvniho parametru metody</i>
       1: iload_2              <i>// ulozit na vrchol zasobniku operandu hodnotu druheho parametru metody</i>
       2: iadd                 <i>// secist hodnotu obou parametru a vratit vysledek zpet na TOS</i>
       3: ireturn              <i>// vyskok z metody s navratovou hodnotou ziskanou z TOS</i>
</pre>

<p>Zajímavìj¹í je a¾ volání tìchto metod s&nbsp;vyu¾itím instrukce
<strong>invokespecial</strong>:</p>

<pre>
  void <strong>callNonStaticPrivateMethod1</strong>();
    Code:
       0: aload_0              <i>// ulozit na vrchol zasobniku operandu hodnotu <strong>this</strong></i>
       1: invokespecial #2;    <i>// volani nestaticke privatni metody: Method nonStaticPrivateMethod1:()V</i>
       4: return               <i>// vyskok z metody bez pouziti navratove hodnoty</i>
&nbsp;
  void <strong>callNonStaticPrivateMethod2</strong>();
    Code:
       0: aload_0              <i>// ulozit na vrchol zasobniku operandu hodnotu <strong>this</strong></i>
       1: invokespecial #3;    <i>// volani nestaticke privatni metody: Method nonStaticPrivateMethod2:()I</i>
       4: pop                  <i>// odstranit navratovou hodnotu ze zasobniku operandu</i>
       5: return               <i>// vyskok z metody bez pouziti navratove hodnoty</i>
&nbsp;
  void <strong>callNonStaticPrivateMethod3</strong>();
    Code:
       0: aload_0              <i>// ulozit na vrchol zasobniku operandu hodnotu <strong>this</strong></i>
       1: iconst_1             <i>// ulozit na zasobnik operandu hodnotu prvniho argumentu volane metody</i>
       2: iconst_2             <i>// ulozit na zasobnik operandu hodnotu druheho argumentu volane metody</i>
       3: invokespecial #4;    <i>// volani nestaticke privatni metody: Method nonStaticPrivateMethod3:(II)V</i>
       6: return               <i>// vyskok z metody bez pouziti navratove hodnoty</i>
&nbsp;
  void <strong>callNonStaticPrivateMethod4</strong>();
    Code:
       0: aload_0              <i>// ulozit na vrchol zasobniku operandu hodnotu <strong>this</strong></i>
       1: iconst_3             <i>// ulozit na zasobnik operandu hodnotu prvniho argumentu volane metody</i>
       2: iconst_4             <i>// ulozit na zasobnik operandu hodnotu druheho argumentu volane metody</i>
       3: invokespecial #5;    <i>// volani nestaticke privatni metody: Method nonStaticPrivateMethod4:(II)I</i>
       6: pop                  <i>// odstranit navratovou hodnotu ze zasobniku operandu</i>
       7: return               <i>// vyskok z metody bez pouziti navratove hodnoty</i>
</pre>

<p>V&nbsp;bajtkódu metody <strong>callConstructor()</strong> se nejdøíve pomocí
instrukce <strong>new</strong> vytvoøí instance tøídy <strong>Test29</strong> a
posléze se zavolá speciální metoda nazvaná <strong>&lt;init&gt;</strong>, která
(ponìkud zjednodu¹enì øeèeno) odpovídá konstruktoru této tøídy. Pov¹imnìte si
také dvojice instrukcí <strong>dup</strong> a <strong>pop</strong> na adresách
3 a 7. Tyto instrukce slou¾í pro úschovu a následné odstranìní reference na
objekt vytvoøený pomocí <strong>new</strong>, i kdy¾ ve skuteènosti není tato
reference nikde pou¾ita (instrukce <strong>invokespecial</strong> takté¾
vyu¾ívá referenci na vytvoøený objekt, ov¹em tato reference je pøi zpracování
této instrukce z&nbsp;TOS odstranìna):</p>

<pre>
  void <strong>callConstructor</strong>();
    Code:
       0: new           #6;    <i>// vytvoreni nove instance tridy Test29</i>
       3: dup                  <i>// duplikace reference na nove vytvoreny objekt</i>
       4: invokespecial #7;    <i>// volani tela konstruktoru</i>
       7: pop                  <i>// odstranit navratovou hodnotu ze zasobniku operandu</i>
       8: return               <i>// vyskok z metody bez pouziti navratove hodnoty</i>
</pre>

<p>Opìt se podívejme je¹tì na strukturu <i>constant poolu</i> tøídy
<strong>Test29</strong>:</p>

<pre>
   #1 = Methodref          #8.#27;        //  java/lang/Object."init":()V
   #2 = Methodref          #6.#28;        //  Test29.nonStaticPrivateMethod1:()V
   #3 = Methodref          #6.#29;        //  Test29.nonStaticPrivateMethod2:()I
   #4 = Methodref          #6.#30;        //  Test29.nonStaticPrivateMethod3:(II)V
   #5 = Methodref          #6.#31;        //  Test29.nonStaticPrivateMethod4:(II)I
   #6 = Class              #32;           //  Test29
   #7 = Methodref          #6.#27;        //  Test29."init":()V
   #8 = Class              #33;           //  java/lang/Object
   #9 = Utf8               <init>;
  #10 = Utf8               ()V;
  #11 = Utf8               Code;
  #12 = Utf8               LineNumberTable;
  #13 = Utf8               nonStaticPrivateMethod1;
  #14 = Utf8               nonStaticPrivateMethod2;
  #15 = Utf8               ()I;
  #16 = Utf8               nonStaticPrivateMethod3;
  #17 = Utf8               (II)V;
  #18 = Utf8               nonStaticPrivateMethod4;
  #19 = Utf8               (II)I;
  #20 = Utf8               callNonStaticPrivateMethod1;
  #21 = Utf8               callNonStaticPrivateMethod2;
  #22 = Utf8               callNonStaticPrivateMethod3;
  #23 = Utf8               callNonStaticPrivateMethod4;
  #24 = Utf8               callConstructor;
  #25 = Utf8               SourceFile;
  #26 = Utf8               Test29.java;
  #27 = NameAndType        #9:#10;        //  "init":()V
  #28 = NameAndType        #13:#10;       //  nonStaticPrivateMethod1:()V
  #29 = NameAndType        #14:#15;       //  nonStaticPrivateMethod2:()I
  #30 = NameAndType        #16:#17;       //  nonStaticPrivateMethod3:(II)V
  #31 = NameAndType        #18:#19;       //  nonStaticPrivateMethod4:(II)I
  #32 = Utf8               Test29;
  #33 = Utf8               java/lang/Object;
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Instrukce <strong>invokeinterface</strong></h2>

<p>Dal¹í (dnes ji¾ poslední) prozatím nepopsanou instrukcí je instrukce nazvaná
<strong>invokeinterface</strong>. Tato instrukce slou¾í k&nbsp;zavolání metody
rozhraní, co¾ sice mù¾e vypadat ponìkud nesmyslnì (v&nbsp;rozhraní mohou být
pouze hlavièky metod, ale ne jejich implementace), ov¹em v&nbsp;øeèi tvùrcù
bajtkódu se tím myslí stav, kdy se volá metoda, její¾ konkrétní implementaci je
mo¾né rozeznat a¾ v&nbsp;èase bìhu programu (<i>runtime</i>). Instrukce
<strong>invokeinterface</strong> se èásteènì podobá ji¾ popsaným instrukcím
<strong>invokestatic</strong>, <strong>invokevirtual</strong> a
<strong>invokespecial</strong>, ov¹em s&nbsp;tím rozdílem, ¾e se za operaèním
kódem nachází jak dvojice bajtù obsahujících index do <i>constant poolu</i>,
tak i poèet argumentù volané metody. Ve skuteènosti se v¹ak jedná o údaj, který
se zde nachází z&nbsp;historických dùvodù a èistì teoreticky by nemusel být
uvádìn, proto¾e poèet argumentù metody lze získat i z&nbsp;její signatury
ulo¾ené na <i>constant poolu</i>:</p>

<table>
<tr><td>1</td><td>invokeinterface</td><td>0xB9</td><td>highbyte, lowbyte, count</td><td>zavolání metody deklarované v&nbsp;rozhraní, samozøejmì s&nbsp;pøedáním parametrù</td></tr>
</table>

<p>Operandy <i>highbyte</i> a <i>lowbyte</i> opìt tvoøí ¹estnáctibitový index
do <i>constant poolu</i>. Záznam na daném indexu musí být typu
<i>InterfaceMethodref</i> (nikoli <i>MethodRef</i>), co¾ je pro pøipomenutí
záznam obsahující odkaz na dal¹í záznam typu <i>Class</i> (jméno tøídy èi
rozhraní) a takté¾ na záznam typu <i>Name and Type</i> (signatura metody èi
atributu).</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Demonstraèní pøíklad <strong>Test30.java</strong>: pou¾ití instrukce <strong>invokeinterface</strong></h2>

<p>Podívejme se nyní na demonstraèní pøípad, v&nbsp;nìm¾ pøekladaè musí pou¾ít
pøi pøekladu do bajtkódu instrukce <strong>invokeinterface</strong>, proto¾e
v&nbsp;èase pøekladu nemù¾e rozhodnout o tom, metoda jaké tøídy se bude ve
skuteènosti volat &ndash; mù¾e se (v&nbsp;prvním pøípadì) jednat o metodu
<strong>compareTo()</strong> jakékoli tøídy implementující rozhraní
<strong>Comparable</strong>, to stejné platí i o dal¹í metody
<strong>iterator()</strong> a <strong>append()</strong>:</p>

<pre>
<i>/**</i>
<i> * Demonstracni priklad cislo 30.</i>
<i> *</i>
<i> * Vyuziti instrukce invokeinterface pro volani metod, jejichz</i>
<i> * hlavicky jsou predepsany v nejakem (standardnim) rozhrani.</i>
<i> */</i>
public class <strong>Test30</strong> {
&nbsp;
    <i>/**</i>
    <i> * Zavolani metody Iterable.iterator().</i>
    <i> */</i>
    public java.util.Iterator <strong>getIterator</strong>(Iterable i) {
        return i.iterator();
    }
&nbsp;
    <i>/**</i>
    <i> * Zavolani metody Comparable.compareTo().</i>
    <i> */</i>
    public int <strong>compare</strong>(Comparable a, Comparable b) {
        return a.compareTo(b);
    }
&nbsp;
    <i>/**</i>
    <i> * Zavolani metody Appendable.append(char).</i>
    <i> */</i>
    public void <strong>append</strong>(Appendable a, char c) throws java.io.IOException {
        a.append(c);
    }
&nbsp;
}
</pre>

<p>Vygenerovaný bajtkód metod <strong>getIterator()</strong>,
<strong>compare()</strong> a <strong>append()</strong> vypadá následovnì:</p>

<pre>
  public java.util.Iterator <strong>getIterator</strong>(java.lang.Iterable);
    Code:
       0: aload_1                   <i>// ulozit na zasobnik operandu prvni (viditelny) parametr metody</i>
                                    <i>// zavolani metody rozhrani</i>
       1: invokeinterface #2,  1;   <i>// InterfaceMethod java/lang/Iterable.iterator:()Ljava/util/Iterator;</i>
       6: areturn                   <i>// vyskok z metody, reference na iterator je vracena volajicimu kodu</i>
&nbsp;
  public int <strong>compare</strong>(java.lang.Comparable, java.lang.Comparable);
    Code:
       0: aload_1                   <i>// ulozit na zasobnik operandu referenci na prvni objekt typu Comparable</i>
       1: aload_2                   <i>// ulozit na zasobnik operandu referenci na druhy objekt typu Comparable</i>
                                    <i>// zavolani metody rozhrani</i>
       2: invokeinterface #3,  2;   <i>// InterfaceMethod java/lang/Comparable.compareTo:(Ljava/lang/Object;)I</i>
       7: ireturn                   <i>// vratit vysledek volani Comparable.compareTo()</i> 
&nbsp;
  public void <strong>append</strong>(java.lang.Appendable, char) throws java.io.IOException;
    Code:
       0: aload_1                   <i>// ulozit na zasobnik operandu referenci na objekt typu Appendable</i>
       1: iload_2                   <i>// ulozit na zasobnik operandu znak</i>
                                    <i>// zavolani metody rozhrani</i>
       2: invokeinterface #4,  2;   <i>// InterfaceMethod java/lang/Appendable.append:(C)Ljava/lang/Appendable;</i>
       7: pop                       <i>// odstranit navratovou hodnotu metody Appendable.append()</i>
                                    <i>// (coz je opet objekt implementujici rozhrani Appendable)</i>
       8: return                    <i>// vyskok z metody bez pouziti navratove hodnoty</i>
</pre>

<p>Pro úplnost si doplòme výpis <i>constant poolu</i> tøídy
<strong>Test30</strong>. Nejdùle¾itìj¹í jsou zde záznamy ulo¾ené na indexech
#2, #3 a #4, které jsou typu <i>InterfaceMethodref</i>:</p>

<pre>
   #1 = Methodref          #6.#21;        //  java/lang/Object."init":()V
   #2 = InterfaceMethodref #22.#23;       //  java/lang/Iterable.iterator:()Ljava/util/Iterator;
   #3 = InterfaceMethodref #24.#25;       //  java/lang/Comparable.compareTo:(Ljava/lang/Object;)I
   #4 = InterfaceMethodref #26.#27;       //  java/lang/Appendable.append:(C)Ljava/lang/Appendable;
   #5 = Class              #28;           //  Test30
   #6 = Class              #29;           //  java/lang/Object
   #7 = Utf8               init;
   #8 = Utf8               ()V;
   #9 = Utf8               Code;
  #10 = Utf8               LineNumberTable;
  #11 = Utf8               getIterator;
  #12 = Utf8               (Ljava/lang/Iterable;)Ljava/util/Iterator;;
  #13 = Utf8               compare;
  #14 = Utf8               (Ljava/lang/Comparable;Ljava/lang/Comparable;)I;
  #15 = Utf8               append;
  #16 = Utf8               (Ljava/lang/Appendable;C)V;
  #17 = Utf8               Exceptions;
  #18 = Class              #30;           //  java/io/IOException
  #19 = Utf8               SourceFile;
  #20 = Utf8               Test30.java;
  #21 = NameAndType        #7:#8;         //  "init":()V
  #22 = Class              #31;           //  java/lang/Iterable
  #23 = NameAndType        #32:#33;       //  iterator:()Ljava/util/Iterator;
  #24 = Class              #34;           //  java/lang/Comparable
  #25 = NameAndType        #35:#36;       //  compareTo:(Ljava/lang/Object;)I
  #26 = Class              #37;           //  java/lang/Appendable
  #27 = NameAndType        #15:#38;       //  append:(C)Ljava/lang/Appendable;
  #28 = Utf8               Test30;
  #29 = Utf8               java/lang/Object;
  #30 = Utf8               java/io/IOException;
  #31 = Utf8               java/lang/Iterable;
  #32 = Utf8               iterator;
  #33 = Utf8               ()Ljava/util/Iterator;;
  #34 = Utf8               java/lang/Comparable;
  #35 = Utf8               compareTo;
  #36 = Utf8               (Ljava/lang/Object;)I;
  #37 = Utf8               java/lang/Appendable;
  #38 = Utf8               (C)Ljava/lang/Appendable;;
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Repositáø se zdrojovými kódy v¹ech ètyø dne¹ních demonstraèních pøíkladù</h2>

<p>V¹echny ètyøi dnes popsané a pou¾ité demonstraèní pøíklady byly ulo¾eny do
Mercurial repositáøe umístìného na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
Odkazy na prozatím poslední verze tìchto ètyø pøíkladù naleznete v&nbsp;tabulce
pod tímto odstavcem:</p>

<table>
<tr><th>#</th><th>Zdrojový kód</th><th>Umístìní</th></tr>
<tr><td>1</td><td>Test27.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d007ee625fa6/bytecode/Java/Test27.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d007ee625fa6/bytecode/Java/Test27.java</a></td></tr>
<tr><td>2</td><td>Test28.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d007ee625fa6/bytecode/Java/Test28.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d007ee625fa6/bytecode/Java/Test28.java</a></td></tr>
<tr><td>3</td><td>Test29.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d007ee625fa6/bytecode/Java/Test29.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d007ee625fa6/bytecode/Java/Test29.java</a></td></tr>
<tr><td>4</td><td>Test30.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d007ee625fa6/bytecode/Java/Test30.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d007ee625fa6/bytecode/Java/Test30.java</a></td></tr>
</table>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>Python Byte Code Instructions<br />
<a href="https://docs.python.org/release/2.5.2/lib/bytecodes.html">https://docs.python.org/release/2.5.2/lib/bytecodes.html</a>
</li>

<li>For-each Loop in Java<br />
<a href="http://www.leepoint.net/notes-java/flow/loops/foreach.html">http://www.leepoint.net/notes-java/flow/loops/foreach.html</a>
</li>

<li>Programming in Lua (first edition)<br />
<a href="http://www.lua.org/pil/contents.html">http://www.lua.org/pil/contents.html</a>
</li>

<li>Programming in Lua: Numeric for<br />
<a href="http://www.lua.org/pil/4.3.4.html">http://www.lua.org/pil/4.3.4.html</a>
</li>

<li>Programming in Lua: break and return<br />
<a href="http://www.lua.org/pil/4.4.html">http://www.lua.org/pil/4.4.html</a>
</li>

<li>Programming in Lua: Tables<br />
<a href="http://www.lua.org/pil/2.5.html">http://www.lua.org/pil/2.5.html</a>
</li>

<li>Programming in Lua: Table Constructors<br />
<a href="http://www.lua.org/pil/3.6.html">http://www.lua.org/pil/3.6.html</a>
</li>

<li>Programovací jazyk Lua<br />
<a href="http://palmknihy.cz/web/kniha/programovaci-jazyk-lua-12651.htm">http://palmknihy.cz/web/kniha/programovaci-jazyk-lua-12651.htm</a>
</li>

<li>Lua: Tables Tutorial<br />
<a href="http://lua-users.org/wiki/TablesTutorial">http://lua-users.org/wiki/TablesTutorial</a>
</li>

<li>Python 2.x: funkce range()<br />
<a href="https://docs.python.org/2/library/functions.html#range">https://docs.python.org/2/library/functions.html#range</a>
</li>

<li>Python 2.x: typ iterátor<br />
<a href="https://docs.python.org/2/library/stdtypes.html#iterator-types">https://docs.python.org/2/library/stdtypes.html#iterator-types</a>
</li>

<li>Lua: Control Structure Tutorial<br />
<a href="http://lua-users.org/wiki/ControlStructureTutorial">http://lua-users.org/wiki/ControlStructureTutorial</a>
</li>

<li>Lua Types Tutorial<br />
<a href="http://lua-users.org/wiki/LuaTypesTutorial">http://lua-users.org/wiki/LuaTypesTutorial</a>
</li>

<li>Goto Statement in Lua<br />
<a href="http://lua-users.org/wiki/GotoStatement">http://lua-users.org/wiki/GotoStatement</a>
</li>

<li>Python break, continue and pass Statements<br />
<a href="http://www.tutorialspoint.com/python/python_loop_control.htm">http://www.tutorialspoint.com/python/python_loop_control.htm</a>
</li>

<li>For Loop (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/For_loop">http://en.wikipedia.org/wiki/For_loop</a>
</li>

<li>Heinz Rutishauser<br />
<a href="http://en.wikipedia.org/wiki/Heinz_Rutishauser">http://en.wikipedia.org/wiki/Heinz_Rutishauser</a>
</li>

<li>Parrot<br />
<a href="http://www.parrot.org/">http://www.parrot.org/</a>
</li>

<li>Parrot languages<br />
<a href="http://www.parrot.org/languages">http://www.parrot.org/languages</a>
</li>

<li>Parrot Primer<br />
<a href="http://docs.parrot.org/parrot/latest/html/docs/intro.pod.html">http://docs.parrot.org/parrot/latest/html/docs/intro.pod.html</a>
</li>

<li>Parrot Opcodes<br />
<a href="http://docs.parrot.org/parrot/latest/html/ops.html">http://docs.parrot.org/parrot/latest/html/ops.html</a>
</li>

<li>Parrot VM<br />
<a href="http://en.wikibooks.org/wiki/Parrot_Virtual_Machine">http://en.wikibooks.org/wiki/Parrot_Virtual_Machine</a>
</li>

<li>Parrot Assembly Language<br />
<a href="http://www.perl6.org/archive/pdd/pdd06_pasm.html">http://www.perl6.org/archive/pdd/pdd06_pasm.html</a>
</li>

<li>Parrot Reference: Chapter 11 - Perl 6 and Parrot Essentials<br />
<a href="http://oreilly.com/perl/excerpts/perl-6-and-parrot-essentials/parrot-reference.html">http://oreilly.com/perl/excerpts/perl-6-and-parrot-essentials/parrot-reference.html</a>
</li>

<li>Python Bytecode: Fun With Dis<br />
<a href="http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/">http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/</a>
</li>

<li>Python's Innards: Hello, ceval.c!<br />
<a href="http://tech.blog.aknin.name/category/my-projects/pythons-innards/">http://tech.blog.aknin.name/category/my-projects/pythons-innards/</a>
</li>

<li>Byterun<br />
<a href="https://github.com/nedbat/byterun">https://github.com/nedbat/byterun</a>
</li>

<li>Python Byte Code Instructions<br />
<a href="http://document.ihg.uni-duisburg.de/Documentation/Python/lib/node56.html">http://document.ihg.uni-duisburg.de/Documentation/Python/lib/node56.html</a>
</li>

<li>Python Byte Code Instructions<br />
<a href="https://docs.python.org/3.2/library/dis.html#python-bytecode-instructions">https://docs.python.org/3.2/library/dis.html#python-bytecode-instructions</a>
</li>

<li>Lua 5.2 sources<br />
<a href="http://www.lua.org/source/5.2/">http://www.lua.org/source/5.2/</a>
</li>

<li>Lua 5.2 sources - lopcodes.h<br />
<a href="http://www.lua.org/source/5.2/lopcodes.h.html">http://www.lua.org/source/5.2/lopcodes.h.html</a>
</li>

<li>Lua 5.2 sources - lopcodes.c<br />
<a href="http://www.lua.org/source/5.2/lopcodes.c.html">http://www.lua.org/source/5.2/lopcodes.c.html</a>
</li>

<li>dis - Python module<br />
<a href="https://docs.python.org/2/library/dis.html">https://docs.python.org/2/library/dis.html</a>
</li>

<li>Comparison of Python virtual machines<br />
<a href="http://polishlinux.org/apps/cli/comparison-of-python-virtual-machines/">http://polishlinux.org/apps/cli/comparison-of-python-virtual-machines/</a>
</li>

<li>O-code<br />
<a href="http://en.wikipedia.org/wiki/O-code_machine">http://en.wikipedia.org/wiki/O-code_machine</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>GC safe-point (or safepoint) and safe-region<br />
<a href="http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html">http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html</a>
</li>

<li>Safepoints in HotSpot JVM<br />
<a href="http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html">http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html</a>
</li>

<li>Java theory and practice: Synchronization optimizations in Mustang<br />
<a href="http://www.ibm.com/developerworks/java/library/j-jtp10185/">http://www.ibm.com/developerworks/java/library/j-jtp10185/</a>
</li>

<li>How to build hsdis<br />
<a href="http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README">http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README</a>
</li>

<li>Java SE 6 Performance White Paper<br />
<a href="http://www.oracle.com/technetwork/java/6-performance-137236.html">http://www.oracle.com/technetwork/java/6-performance-137236.html</a>
</li>

<li>Lukas Stadler's Blog<br />
<a href="http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html">http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html</a>
</li>

<li>How to build hsdis-amd64.dll and hsdis-i386.dll on Windows<br />
<a href="http://dropzone.nfshost.com/hsdis.htm">http://dropzone.nfshost.com/hsdis.htm</a>
</li>

<li>PrintAssembly<br />
<a href="https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly">https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly</a>
</li>

<li>The Java Virtual Machine Specification: 3.14. Synchronization<br />
<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14</a>
</li>

<li>The Java Virtual Machine Specification: 8.3.1.4. volatile Fields<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.4. Memory Model<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.7. Non-atomic Treatment of double and long<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7</a>
</li>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (pøed verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2014</small></p>
</body>
</html>

