<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - vytváøení i dekompilace metod s vyu¾itím nástroje Javassist</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - vytváøení i dekompilace metod s vyu¾itím nástroje Javassist</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o virtuálním stroji Javy budeme pokraèovat v popisu mo¾ností nástroje Javassist, s ním¾ jsme se seznámili v pøedchozích dvou dílech. Dnes si uká¾eme zpùsob vytváøení nových metod a pøidání tìchto metod do libovolné tøídy. Nezapomeneme ani na nízkoúrovòovou operaci - dekompilaci metod.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - vytváøení i dekompilace metod s vyu¾itím nástroje Javassist</a></p>
<p><a href="#k02">2. Vytvoøení bajtkódu metody pøímo ze zdrojového kódu</a></p>
<p><a href="#k03">3. Konstrukce bajtkódu metody se specifikací návratové hodnoty, parametrù a tìla metody</a></p>
<p><a href="#k04">4. Konstrukce bajtkódu metody pøímým zápisem instrukcí JVM</a></p>
<p><a href="#k05">5. Zdrojový kód demonstraèního pøíkladu <strong>ClassGenerationTest4</strong></a></p>
<p><a href="#k06">6. Výsledná podoba bajtkódu tøídy vygenerované pøíkladem <strong>ClassGenerationTest4</strong></a></p>
<p><a href="#k07">7. Zpìtné získání informací o libovolné metodì vybrané tøídy</a></p>
<p><a href="#k08">8. Pøeètení instrukcí tvoøících tìlo vybrané metody a dekódování instrukcí do èitelné podoby</a></p>
<p><a href="#k09">9. Zdrojový kód demonstraèního pøíkladu <strong>ClassGenerationTest5</strong></a></p>
<p><a href="#k10">10. Ukázka výpisu bajtkódu metod vytvoøených demonstraèním pøíkladem <strong>ClassGenerationTest5</strong></a></p>
<p><a href="#k11">11. Repositáø se zdrojovými kódy obou demonstraèních pøíkladù</a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - vytváøení i dekompilace metod s vyu¾itím nástroje Javassist</h2>

<p>V&nbsp;dne¹ní èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyku Java i o virtuálním stroji Javy</a> navá¾eme na èást
pøedchozí, v&nbsp;ní¾ jsme si ukázali zpùsob vytváøení nových atributù a
pøidávání tìchto atributù k&nbsp;vytváøené (generované) tøídì, pøesnìji øeèeno
k&nbsp;jejímu bajtkódu. Práce s&nbsp;atributy je v&nbsp;podstatì velmi
jednoduchá, proto¾e u ka¾dého atributu musíme zadat jen jeho jméno, datový typ,
modifikátory (STATIC, PUBLIC, VOLATILE atd.) a popø.&nbsp;i poèáteèní hodnotu,
kterou je atribut naplnìn v&nbsp;rámci inicializace tøídy ve statickém bloku
(platí pro statické atributy) èi pøi konstrukci instance tøídy (nestatické
atributy). Dnes se budeme zabývat slo¾itìj¹í problematikou, konkrétnì pøidáním
nových metod do generovaných tøíd. U ka¾dé metody je nutné znát a tím pádem i
zadat mnohem vìt¹í mno¾ství údajù, ne¾ tomu bylo v&nbsp;pøípadì atributù. Kromì
jména metody a modifikátorù je nutné zadat i její návratový typ, typy parametrù
metody a samozøejmì i její tìlo.</p>

<p>Kromì tøí základních zpùsobù vytváøení nových metod se seznámíme i
s&nbsp;opaènou problematikou. Jedná se o získání v¹ech dùle¾itých informací o
ji¾ existující metodì vybrané tøídy, a to nezávisle na tom, zda byla tato
metoda pøelo¾ena klasickým pøekladaèem Javy, tj.&nbsp;pøíkazem
<strong>javac</strong>, nebo zda byla vygenerována nìkterým dal¹ím nástrojem,
samozøejmì vèetnì <i>Javassist</i>. Vzhledem k&nbsp;tomu, ¾e se pøi pøekladu
ztratí pùvodní zdrojový kód (resp.&nbsp;mohou na nìj být pouze uvedeny odkazy
ve formì jména souboru a èísla øádku), je pøi <i>dekompilaci</i> metody získána
sekvence instrukcí tvoøících její tìlo. Tyto instrukce lze vypsat rùzným
zpùsobem, buï jen jako seznam operaèních kódù tìchto instrukcí nebo ve formì
jmen instrukcí. I pro tento pøípad existují v&nbsp;nástroji <i>Javassist</i>
pøíslu¹né tøídy a metody, co¾ znamená, ¾e vytvoøení prohlí¾eèe bajtkódu je
skuteènì pomìrnì jednoduché.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Vytvoøení bajtkódu metody pøímo ze zdrojového kódu</h2>

<p>Jak jsme si ji¾ øekli v&nbsp;pøedchozích èástech tohoto seriálu, je nástroj
<i>Javassist</i> navr¾en takovým zpùsobem, ¾e obsahuje API slou¾ící pro tvorbu
tøíd/metod/atributù na vy¹¹í úrovni i na úrovni ni¾¹í. Pojmem &bdquo;vy¹¹í
úroveò&ldquo; je zde my¹lena práce se zdrojovým kódem pøedstavujícím napøíklad
tìlo metody, zatímco na ni¾¹í úrovni je mo¾né manipulovat pøímo
s&nbsp;jednotlivými instrukcemi bajtkódu, èi dokonce s&nbsp;jednotlivými bajty
(co¾ je nìkdy takté¾ zapotøebí). S&nbsp;generováním metody s&nbsp;vyu¾itím
vysokoúrovòového API nástroje <i>Javassist</i> jsme se ji¾ seznámili, proto¾e
jsme v&nbsp;pøedchozích tøech demonstraèních pøíkladech vytváøeli metodu
<strong>main()</strong> takovým zpùsobem, ¾e se ve formì øetìzce zadala jak
hlavièka metody, tak i její tìlo, a to ve stejném formátu, jakoby se jednalo o
standardní zdrojový kód odpovídající specifikaci jazyka Java:</p>

<pre>
<i>    /**</i>
<i>     * Zdrojovy kod metody main(), ktery bude nasledne zkompilovan</i>
<i>     * do bajtkodu a zakomponovan do vytvorene tridy.</i>
<i>     */</i>
    private static final String MAIN_METHOD_SOURCE_TEXT =
        "public static void main(String[] args)" +
        "{" +
        "    System.out.println(add(1,2));" +
        "    System.out.println(foo());" +
        "    System.out.println(bar());" +
        "}";
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni metody main() z jejiho zdrojoveho kodu.</i>
<i>     * </i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu</i>
<i>     */</i>
    private static void <strong>addMethodMain</strong>(CtClass generatedClass) throws CannotCompileException {
        CtMethod methodMain = CtMethod.make(MAIN_METHOD_SOURCE_TEXT, generatedClass);
        generatedClass.addMethod(methodMain);
    }
</pre>

<p>Stejným zpùsobem lze samozøejmì vytvoøit i metodu s&nbsp;jinými parametry èi
s&nbsp;jiným návratovým typem ne¾ <strong>void</strong>. Uveïme si jednoduchý
pøíklad metody, která seète hodnoty svých dvou celoèíselných parametrù a
následnì vrátí výsledek tohoto souètu:</p>

<pre>
<i>    /**</i>
<i>     * Vytvoreni metody public static int add(int x, int y).</i>
<i>     *</i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu</i>
<i>     */</i>
    private static void <strong>addMethodAdd</strong>(CtClass generatedClass) throws CannotCompileException {
        CtMethod addMethod = CtMethod.make(
                "public static int add(int x, int y)" +
                "{" +
                "    return x+y;" +
                "}", generatedClass);
        generatedClass.addMethod(addMethod);
    }
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Konstrukce bajtkódu metody se specifikací návratové hodnoty, parametrù a tìla metody</h2>

<p>Mohlo by se zdát, ¾e nástroj <i>Javassist</i> je vlastnì pouze rozhraním ke
standardnímu pøekladaèi Javy (<strong>javac</strong>), ve skuteènosti v¹ak tomu
tak není, proto¾e nové metody je mo¾né vytváøet i dal¹ími zpùsoby, které ji¾
programátorùm umo¾òují s&nbsp;bajtkódy výsledných metod lépe manipulovat. Kromì
<strong>CtMethod.make()</strong> je mo¾né kostru bajtkódu nové metody vytvoøit
i pøímým zavoláním konstruktoru <strong>new CtMethod()</strong>. Tomuto
konstruktoru je nutné pøedat ètyøi základní parametry popisující metodu &ndash;
její návratový typ, jméno metody, typy (ne jména!) v¹ech parametrù metody a
koneènì tøídu, v&nbsp;ní¾ má být metoda deklarována. Následnì je mo¾né zmìnit
modifikátory metody s&nbsp;vyu¾itím <strong>CtMethod.setModifiers()</strong>,
co¾ je obdoba minule popsaného pøíkazu <strong>CtField.setModifiers()</strong>.
Tìlo metody se v&nbsp;tomto pøípadì zadává pøes
<strong>CtMethod.setBody()</strong>. Uka¾me si jednoduchý pøíklad, v&nbsp;nìm¾
je tìlo metody pøedstavováno jediným pøíkazem. V&nbsp;tomto pøípadì se nemusí
okolo pøíkazu zapisovat slo¾ené závorky:</p>

<pre>
<i>    /**</i>
<i>     * Vytvoreni bezparametricke staticke metody foo() vracejici int.</i>
<i>     *</i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu</i>
<i>     */</i>
    private static void <strong>constructMethodFoo</strong>(CtClass generatedClass) throws CannotCompileException {
        CtClass returnType = CtClass.intType;
        CtClass[] parameterTypes = {};
&nbsp;
<i>        // u metody je nutne znat jeji jmeno, navratovou hodnotu i typy parametru</i>
        CtMethod fooMethod = new CtMethod(returnType, "foo", parameterTypes, generatedClass);
&nbsp;
<i>        // zmena modifikatoru</i>
        fooMethod.setModifiers(Modifier.STATIC | Modifier.PUBLIC);
&nbsp;
<i>        // telo metody muze byt slozeno z jednoho vyrazu</i>
        fooMethod.setBody("return 42;");
        generatedClass.addMethod(fooMethod);
    }
</pre>

<p>Pokud je tìlo metody slo¾eno z&nbsp;více pøíkazù, je vhodné okolo tìchto
pøíkazù zapsat slo¾ené závorky a vytvoøit tak pøíkazový blok. To je ukázáno na
dal¹í metodì (nyní neveøejné) nazvané <strong>bar</strong>. Tato metoda
obsahuje dvì lokální promìnné a vrací výsledek výpoètu s&nbsp;vyu¾itím tìchto
promìnných. Zde je nutné upozornit na to, ¾e se pøi generování bajtkódu metody
nebudou provádìt ¾ádné optimalizace, co¾ znamená, ¾e uvedené výpoèty budou
pøevedeny do instrukcí bajtkódu, i kdy¾ by to ve skuteènosti nemuselo být
nutné:</p>

<pre>
<i>    /**</i>
<i>     * Vytvoreni bezparametricke staticke metody bar() vracejici float.</i>
<i>     *</i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu</i>
<i>     */</i>
    private static void <strong>constructMethodBar</strong>(CtClass generatedClass) throws CannotCompileException {
        CtClass returnType = CtClass.floatType;
        CtClass[] parameterTypes = {};
&nbsp;
<i>        // u metody je nutne znat jeji jmeno, navratovou hodnotu i typy parametru</i>
        CtMethod fooMethod = new CtMethod(returnType, "bar", parameterTypes, generatedClass);
&nbsp;
<i>        // zmena modifikatoru</i>
        fooMethod.setModifiers(Modifier.STATIC | Modifier.PRIVATE);
&nbsp;
<i>        // telo metody muze byt slozeno z celeho bloku</i>
        fooMethod.setBody(
                "{" +
                "    float x = 1/8f;" +
                "    float y = 336;" +
                "    return x * y;" +
                "}"
        );
        generatedClass.addMethod(fooMethod);
    }
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Konstrukce bajtkódu metody pøímým zápisem instrukcí JVM</h2>

<p>Tøetí zpùsob konstrukce metody ji¾ pou¾ívá nízkoúrovòové API nástroje
<i>Javassist</i>. Vyu¾ívá se zde faktu, ¾e instrukce tvoøící tìlo metody jsou
ulo¾eny v&nbsp;jednom z&nbsp;jejích atributù. Mù¾e se to sice zdát podivné, ale
je tomu skuteènì tak, ostatnì nìkteré metody nemají (a nemohou) mít ¾ádné tìlo.
Instrukce tvoøící tìlo pøelo¾ené metody jsou ulo¾eny v&nbsp;atributu nazvaném
<strong>Code</strong> a v&nbsp;nástroji <i>Javassist</i> je mo¾né hodnotu
tohoto atributu nastavit s&nbsp;vyu¾itím pøíkazu
<strong>MethodInfo.setCodeAttribute()</strong>, kterému se pøedá instance tøídy
<strong>CodeAttribute</strong>. Bli¾¹í informace o tøídì
<strong>MethodInfo</strong> budou uvedeny v&nbsp;dal¹ích kapitolách, zpùsob
vytváøení bajtkódu metod bude podrobnìji vysvìtlen v&nbsp;navazující èásti
tohoto seriálu. Zde si jen uka¾me krátký úryvek kódu, který vytvoøí tìlo
metody, které by se v&nbsp;Javì mohlo zapsat takto: <strong>return
42;</strong>:</p>

<pre>
        MethodInfo minfo = method.getMethodInfo();
&nbsp;
        ConstPool constPool = minfo.getConstPool();
        Bytecode b = new Bytecode(constPool, 2, 0); <i>// stacksize == 2</i>
&nbsp;
        <i>// pridani instrukce pro ulozeni celociselne konstanty na zasobnik</i>
        b.addIconst(42);
        <i>// pridani instrukce pro ukonceni metody a vraceni hodnoty ulozene na zasobniku</i>
        b.addReturn(CtClass.intType);
&nbsp;
        <i>// ziskani atributu metody s nazvem "code" z vytvoreneho bajtkodu</i>
        CodeAttribute codeAttribute = b.toCodeAttribute();
&nbsp;
        <i>// prirazeni atributu k metode</i>
        minfo.setCodeAttribute(codeAttribute);
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Zdrojový kód demonstraèního pøíkladu <strong>ClassGenerationTest4</strong></h2>

<p>První dva zpùsoby konstrukce nových metod popsané v&nbsp;pøedchozích
kapitolách jsou implementovány v&nbsp;dne¹ním prvním demonstraèním pøíkladu
nazvaném <strong>ClassGenerationTest4</strong> (pøíklady jsou èíslovány
prùbì¾nì od pøedminulé èásti tohoto seriálu). Tento pøíklad po svém spu¹tìní
vytvoøí kostru tøídy nazvané &bdquo;GeneratedClass4&ldquo; a následnì se
v&nbsp;této tøídì vytvoøí ètveøice statických metod. Samozøejmì se jedná o
metodu <strong>main()</strong>, dále pak o metodu <strong>add()</strong>
následovanou dvojicí bezparametrických metod nazvaných <strong>foo()</strong> a
<strong>bar()</strong>. Následnì je vygenerovaná tøída
&bdquo;GeneratedClass4&ldquo; ulo¾ena do souboru
&bdquo;GeneratedClass4.class&ldquo; a je pøipravena pro svou inicializaci a
spu¹tìní v&nbsp;rámci virtuálního stroje Javy. Následuje výpis celého kódu vý¹e
popsaného demonstraèního pøíkladu:</p>

<pre>
import java.io.IOException;
&nbsp;
import javassist.CannotCompileException;
import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtMethod;
import javassist.Modifier;
import javassist.NotFoundException;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Test moznosti nastroje Javassist - vygenerovani jednoduche tridy</i>
<i> * s metodou main a nekolika dalsimi metodami.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>ClassGenerationTest4</strong> {
&nbsp;
<i>    /**</i>
<i>     * Jmeno vygenerovane tridy.</i>
<i>     */</i>
    private static final String GENERATED_CLASS_NAME = "GeneratedClass4";
&nbsp;
<i>    /**</i>
<i>     * Zdrojovy kod metody main(), ktery bude nasledne zkompilovan</i>
<i>     * do bajtkodu a zakomponovan do vytvorene tridy.</i>
<i>     */</i>
    private static final String MAIN_METHOD_SOURCE_TEXT =
        "public static void main(String[] args)" +
        "{" +
        "    System.out.println(add(1,2));" +
        "    System.out.println(foo());" +
        "    System.out.println(bar());" +
        "}";
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni metody main() z jejiho zdrojoveho kodu.</i>
<i>     * </i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu</i>
<i>     */</i>
    private static void <strong>addMethodMain</strong>(CtClass generatedClass) throws CannotCompileException {
        CtMethod methodMain = CtMethod.make(MAIN_METHOD_SOURCE_TEXT, generatedClass);
        generatedClass.addMethod(methodMain);
    }
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni metody public static int add(int x, int y).</i>
<i>     *</i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu</i>
<i>     */</i>
    private static void <strong>addMethodAdd</strong>(CtClass generatedClass) throws CannotCompileException {
        CtMethod addMethod = CtMethod.make(
                "public static int add(int x, int y)" +
                "{" +
                "    return x+y;" +
                "}", generatedClass);
        generatedClass.addMethod(addMethod);
    }
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni bezparametricke staticke metody foo() vracejici int.</i>
<i>     *</i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu</i>
<i>     */</i>
    private static void <strong>constructMethodFoo</strong>(CtClass generatedClass) throws CannotCompileException {
        CtClass returnType = CtClass.intType;
        CtClass[] parameterTypes = {};
&nbsp;
<i>        // u metody je nutne znat jeji jmeno, navratovou hodnotu i typy parametru</i>
        CtMethod fooMethod = new CtMethod(returnType, "foo", parameterTypes, generatedClass);
&nbsp;
<i>        // zmena modifikatoru</i>
        fooMethod.setModifiers(Modifier.STATIC | Modifier.PUBLIC);
&nbsp;
<i>        // telo metody muze byt slozeno z jednoho vyrazu</i>
        fooMethod.setBody("return 42;");
        generatedClass.addMethod(fooMethod);
    }
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni bezparametricke staticke metody bar() vracejici float.</i>
<i>     *</i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu</i>
<i>     */</i>
    private static void <strong>constructMethodBar</strong>(CtClass generatedClass) throws CannotCompileException {
        CtClass returnType = CtClass.floatType;
        CtClass[] parameterTypes = {};
&nbsp;
<i>        // u metody je nutne znat jeji jmeno, navratovou hodnotu i typy parametru</i>
        CtMethod fooMethod = new CtMethod(returnType, "bar", parameterTypes, generatedClass);
&nbsp;
<i>        // zmena modifikatoru</i>
        fooMethod.setModifiers(Modifier.STATIC | Modifier.PRIVATE);
&nbsp;
<i>        // telo metody muze byt slozeno z celeho bloku</i>
        fooMethod.setBody(
                "{" +
                "    float x = 1/8f;" +
                "    float y = 336;" +
                "    return x * y;" +
                "}"
        );
        generatedClass.addMethod(fooMethod);
    }
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni tridy s metodou main().</i>
<i>     * </i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu metody main()</i>
<i>     * @throws IOException</i>
<i>     *             pokud dojde k chybe pri zapisu bajtkodu na disk</i>
<i>     * @throws NotFoundException</i>
<i>     *             pokud dojde k chybe pri zapisu bajtkodu na disk</i>
<i>     */</i>
    private static void <strong>generateClass</strong>() throws CannotCompileException, NotFoundException, IOException {
<i>        // ziskat vychozi class pool</i>
        ClassPool pool = ClassPool.getDefault();
&nbsp;
<i>        // vytvoreni nove verejne tridy</i>
        CtClass generatedClass = pool.makeClass(GENERATED_CLASS_NAME);
&nbsp;
<i>        // pridani metody add do teto tridy</i>
        addMethodAdd(generatedClass);
&nbsp;
<i>        // konstrukce nove metody foo()</i>
        constructMethodFoo(generatedClass);
&nbsp;
<i>        // konstrukce nove metody bar()</i>
        constructMethodBar(generatedClass);
&nbsp;
<i>        // pridani metody do teto tridy</i>
        addMethodMain(generatedClass);
&nbsp;
<i>        // ulozeni bajtkodu na disk</i>
        generatedClass.writeFile();
    }
&nbsp;
<i>    /**</i>
<i>     * Spusteni generatoru tridy.</i>
<i>     *</i>
<i>     * @param args nevyuzito</i>
<i>     */</i>
    public static void <strong>main</strong>(String[] args) {
        System.out.println("class generation begin: " + GENERATED_CLASS_NAME);
        try {
            generateClass();
        }
        catch (CannotCompileException e) {
            e.printStackTrace();
        }
        catch (NotFoundException e) {
            e.printStackTrace();
        }
        catch (IOException e) {
            e.printStackTrace();
        }
        System.out.println("class generation end: " + GENERATED_CLASS_NAME);
    }
&nbsp;
}
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Výsledná podoba bajtkódu tøídy vygenerované pøíkladem <strong>ClassGenerationTest4</strong></h2>

<p>Demonstraèní pøíklad <strong>ClassGenerationTest4</strong>, jeho¾ zdrojový
text byl vypsán <a href="#k05">v&nbsp;pøedchozí kapitole</a>, se pøelo¾í
následujícím skriptem, jen¾ pøedpokládá pøítomnost archivu <i>javassist.jar</i>
v&nbsp;aktuálním adresáøi:</p>

<pre>
javac -cp javassist.jar ClassGenerationTest4.java
</pre>

<p>Spu¹tìní pøelo¾eného pøíkladu se provede pøíkazem:</p>

<pre>
java -cp .:javassist.jar ClassGenerationTest4
</pre>

<p>Po spu¹tìní <strong>ClassGenerationTest4</strong> by se v&nbsp;aktuálním
adresáøi mìl vytvoøit soubor nazvaný <strong>GeneratedClass4.class</strong>
obsahující novì vytvoøený bajtkód. Jeho obsah je mo¾né si prohlédnout po zadání
pøíkazu:</p>

<pre>
javap -c -private GeneratedClass4
</pre>

<p>Ve výpisu obsahu bajtkódu mù¾eme vidìt tìla v¹ech ètyø explicitnì
vytvoøených metod a souèasnì i tìlo automaticky vygenerovaného konstruktoru.
Pov¹imnìte si, ¾e u metody <strong>private static float bar()</strong> skuteènì
nedo¹lo k&nbsp;¾ádné optimalizaci bajtkódu, proto¾e ten zde obsahuje jak obì
lokální promìnné, tak i výpoèet nad nimi. Ve skuteènosti by bylo mo¾né celé
tìlo této metody nahradit pouze dvìma instrukcemi: <strong>fstore
(42)+freturn</strong>:</p>

<pre>
Compiled from "GeneratedClass4.java"
public class <strong>GeneratedClass4</strong> extends java.lang.Object{
<strong>public static int add(int, int)</strong>;
  Code:
   0:   iload_0
   1:   iload_1
   2:   iadd
   3:   ireturn
&nbsp;
<strong>public static int foo()</strong>;
  Code:
   0:   bipush  42
   2:   ireturn
&nbsp;
<strong>private static float bar()</strong>;
  Code:
   0:   ldc     #12; <i>//float 0.125f</i>
   2:   fstore_0
   3:   sipush  336
   6:   i2f
   7:   fstore_1
   8:   fload_0
   9:   fload_1
   10:  fmul
   11:  freturn
&nbsp;
<strong>public static void main(java.lang.String[])</strong>;
  Code:
   0:   getstatic       #20; <i>//Field java/lang/System.out:Ljava/io/PrintStream;</i>
   3:   iconst_1
   4:   iconst_2
   5:   invokestatic    #22; <i>//Method add:(II)I</i>
   8:   invokevirtual   #28; <i>//Method java/io/PrintStream.println:(I)V</i>
   11:  getstatic       #20; <i>//Field java/lang/System.out:Ljava/io/PrintStream;</i>
   14:  invokestatic    #30; <i>//Method foo:()I</i>
   17:  invokevirtual   #28; <i>//Method java/io/PrintStream.println:(I)V</i>
   20:  getstatic       #20; <i>//Field java/lang/System.out:Ljava/io/PrintStream;</i>
   23:  invokestatic    #32; <i>//Method bar:()F</i>
   26:  invokevirtual   #35; <i>//Method java/io/PrintStream.println:(F)V</i>
   29:  return
&nbsp;
<strong>public GeneratedClass4();</strong>
  Code:
   0:   aload_0
   1:   invokespecial   #39; <i>//Method java/lang/Object."&lt;init&gt;":()V</i>
   4:   return
&nbsp;
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Zpìtné získání informací o libovolné metodì vybrané tøídy</h2>

<p>Nyní se budeme zabývat opaènou problematikou, ne¾ je vytváøení nových metod.
Mnohdy je toti¾ nástroj <i>Javassist</i> pou¾íván v&nbsp;pøípadech, kdy je
nutné získat bajtkód nìjaké metody a popø.&nbsp;tento bajtkód i modifikovat
(typickým pøíkladem je ji¾ zmínìné volání logovací funkce). My si dnes uká¾eme,
jak lze vypsat informace o libovolné metodì. Pro jednoduchost a souèasnì i pro
vìt¹í názornost se budou získávat informace o ètyøech metodách, které ji¾ dobøe
známe &ndash; <strong>main</strong>, <strong>add</strong>, <strong>foo</strong>
a <strong>bar</strong>. První vìcí, kterou je nutné udìlat, je takzvanì
&bdquo;rozmrazit&ldquo; vygenerovanou tøídu, aby bylo mo¾né pøistupovat
k&nbsp;jejím slo¾kám. Pokud by se rozmrazení neprovedlo pøíkazem
<strong>CtClass.defrost()</strong>, do¹lo by pøi bìhu demonstraèního pøíkladu
k&nbsp;bìhové výjimce. Jakmile je tøída rozmrazena, lze zavolat u¾ivatelskou
metodu <strong>printMethodStructures()</strong>:</p>

<pre>
<i>    /**</i>
<i>     * Spusteni generatoru tridy.</i>
<i>     *</i>
<i>     * @param args nevyuzito</i>
<i>     */</i>
    public static void <strong>main</strong>(String[] args) {
        System.out.println("class generation begin: " + GENERATED_CLASS_NAME);
        try {
            CtClass generatedClass = generateClass();
<i>            // dulezite - generovana trida nesmi byt "zmrazena"</i>
            <strong>generatedClass.defrost();</strong>
            printMethodStructures(generatedClass);
        }
        catch (CannotCompileException e) {
            e.printStackTrace();
        }
        catch (NotFoundException e) {
            e.printStackTrace();
        }
        catch (IOException e) {
            e.printStackTrace();
        }
        catch (BadBytecode e) {
            e.printStackTrace();
        }
        System.out.println("class generation end: " + GENERATED_CLASS_NAME);
    }
&nbsp;
}
</pre>

<p>U¾ivatelská metoda <strong>printMethodStructures()</strong> je ve
skuteènosti velmi jednoduchá, proto¾e pro v¹echny ètyøi zkoumané metody zavolá
<strong>printMethodStructure()</strong>:</p>

<pre>
<i>    /**</i>
<i>     * Vypis struktury vybranych metod z generovane tridy.</i>
<i>     * </i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws NotFoundException</i>
<i>     *             vyhozena, pokud metoda nebyla nalezena</i>
<i>     * @throws BadBytecode </i>
<i>     */</i>
    private static void <strong>printMethodStructures</strong>(CtClass generatedClass) throws NotFoundException, BadBytecode {
        printMethodStructure(generatedClass, "main");
        printMethodStructure(generatedClass, "add");
        printMethodStructure(generatedClass, "foo");
        printMethodStructure(generatedClass, "bar");
    }
</pre>

<p>V&nbsp;<strong>printMethodStructure()</strong> se nejprve získá instance
tøídy <strong>CtMethod</strong> pøedstavující obraz zkoumané metody. Následnì
se pøes <strong>CtMethod.getMethodInfo()</strong> získá instance tøídy
<strong>MethodInfo</strong> obsahující, jak ji¾ název této tøídy napovídá,
informace o zkoumané metodì. My vyu¾ijeme následující ètveøici getterù, které
jsou ve tøídì <strong>MethodInfo</strong> deklarovány:</p>

<table>
<tr><th>#</th><th>Metoda</th><th>Popis</th></tr>
<tr><td>1</td><td>javassist.bytecode.MethodInfo.getName()</td><td>vrátí jméno metody</td></tr>
<tr><td>2</td><td>javassist.bytecode.MethodInfo.getDescriptor()</td><td>vrátí deskriptor metody (èást její signatury)</td></tr>
<tr><td>3</td><td>javassist.bytecode.MethodInfo.getAccessFlags()</td><td>vrátí pøístupová práva a dal¹í modifikátory metody (STATIC...)</td></tr>
<tr><td>4</td><td>javassist.bytecode.MethodInfo.getCodeAttribute()</td><td>vrátí atribut metody reprezentující její tìlo</td></tr>
</table>

<p>V&nbsp;následujícím úryvku zdrojového kódu si pov¹imnìte, jak lze velmi
snadno pøevést modifikátory metody na øetìzec s&nbsp;vyu¾itím
<strong>Modifier.toString()</strong>:</p>

<pre>
<i>    /**</i>
<i>     * Vypis struktury vybrane metody.</i>
<i>     * </i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @param methodName</i>
<i>     *            jmeno metody, jejiz struktura se ma vypsat</i>
<i>     * @throws NotFoundException</i>
<i>     *             vyhozena, pokud metoda nebyla nalezena</i>
<i>     * @throws BadBytecode</i>
<i>     *             vyhozena, pokud se nalezne neplatna instrukce v bytekodu</i>
<i>     */</i>
    private static void <strong>printMethodStructure</strong>(CtClass generatedClass, String methodName) throws NotFoundException, BadBytecode {
        System.out.println("Method '" + methodName + "' structure:");
        CtMethod method = generatedClass.getDeclaredMethod(methodName);
        if (method == null) {
            System.out.println("   not found!");
            return;
        }
        MethodInfo methodInfo = method.getMethodInfo();
        System.out.println("    real name:    " + methodInfo.getName());
        System.out.println("    descriptor:   " + methodInfo.getDescriptor());
        System.out.println("    access flags: " + Modifier.toString(methodInfo.getAccessFlags()));
        System.out.println("    method body:");
        printMethodBody(methodInfo);
        System.out.println();
    }
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Pøeètení instrukcí tvoøících tìlo vybrané metody a dekódování instrukcí do èitelné podoby</h2>

<p>Nyní se dostáváme k&nbsp;snad nejzajímavìj¹í èásti dne¹ního èlánku &ndash;
ke zkoumání sekvence instrukcí tvoøících tìlo zkoumané metody. Jak jsme si ji¾
øekli <a href="#k04">ve ètvrté kapitole</a>, je tato sekvence instrukcí ulo¾ená
v&nbsp;atributu nazvaném <strong>Code</strong>. Hodnotu tohoto atributu získáme
pomocí <strong>CodeAttribute ca = methodInfo.getCodeAttribute();</strong>.
Jednotlivé bajty tvoøící hodnotu atributu <strong>Code</strong> by v¹ak bylo
velmi namáhavé zkoumat ruènì, proto vyu¾ijeme dal¹í tøídy z&nbsp;nástroje
<i>Javassist</i>. Tato tøída se jmenuje <strong>CodeIterator</strong> a její
instanci získáme jednodu¹e: <strong>CodeAttribute.iterator()</strong>.
Z&nbsp;mnoha metod, které tato tøída nabízí, nás bude prozatím zajímat tato
osmice:</p>

<table>
<tr><th>#</th><th>Metoda</th><th>Popis</th></tr>
<tr><td>1</td><td>javassist.bytecode.CodeIterator.begin()</td><td>pøesun na zaèátek bajtkódu</td></tr>
<tr><td>2</td><td>javassist.bytecode.CodeIterator.next()</td><td>pøesun na dal¹í <strong>instrukci</strong></td></tr>
<tr><td>3</td><td>javassist.bytecode.CodeIterator.hasNext()</td><td>oznamuje, zda existuje dal¹í instrukce</td></tr>
<tr><td>4</td><td>javassist.bytecode.CodeIterator.getCodeLength()</td><td>vrací celkovou délku kódu</td></tr>
<tr><td>5</td><td>javassist.bytecode.CodeIterator.byteAt()</td><td>vrací hodnotu bajtu na aktuální pozici</td></tr>
<tr><td>6</td><td>javassist.bytecode.CodeIterator.u16bitAt()</td><td>vrací hodnotu (bezznaménkového) 16bitového slova na aktuální pozici</td></tr>
<tr><td>7</td><td>javassist.bytecode.CodeIterator.s16bitAt()</td><td>vrací hodnotu 16bitového slova se znaménkem na aktuální pozici</td></tr>
<tr><td>8</td><td>javassist.bytecode.CodeIterator.s32bitAt()</td><td>vrací hodnotu 32bitového slova se znaménkem na aktuální pozici</td></tr>
</table>

<p>Asi nejzajímavìj¹í je fakt, ¾e metoda
<strong>javassist.bytecode.CodeIterator.next()</strong> posune iterátor na
dal¹í instrukci a nikoli na dal¹í bajt. To je dùle¾ité, proto¾e jednotlivé
instrukce mohou mít rùznou délku, kterou by bylo nutné zkoumat a nìjakým
zpùsobem reflektovat. Ov¹em vzhledem k&nbsp;tomu, ¾e ka¾dá instrukce bajtkódu
má operaèní znak dlouhý pøesnì jeden bajt (li¹í se poèet parametrù), je mo¾né
celý prùchod bajtkódem implementovat velmi jednodu¹e následující smyèkou, která
vypí¹e pouze hodnotu bajtù tvoøících operaèní kódy instrukcí (a nikoli
parametry &ndash; tyto bajty jsou ignorovány):</p>

<pre>
        CodeIterator iterator = ca.iterator();
        while (iterator.hasNext()) {
            int index = iterator.next();
            int opcode = iterator.byteAt(index);
            System.out.println(opcode);
        }
</pre>

<p>Ov¹em èíselné hodnoty kódù jednotlivých instrukcí jsou pro èlovìka
neèitelné; bylo by lep¹í je pøevést na mnemotechnické zkratky instrukcí. I na
to je v&nbsp;nástroji <i>Javassist</i> my¹leno, proto¾e ve tøídì
<strong>javassist.bytecode.Mnemonic</strong> se nachází pole øetìzcù
s&nbsp;mnemotechnickými zkratkami v¹ech instrukcí. Opìt je zde vyu¾ito faktu,
¾e ka¾dá instrukce má délku operaèního kódu pøesnì jeden bajt, tak¾e staèí
vytvoøit pole s&nbsp;256 øetìzci, i kdy¾ ve skuteènosti jsou nìkteré operaèní
kódy prozatím neobsazeny:</p>

<pre>
package javassist.bytecode;
&nbsp;
public interface <strong>Mnemonic</strong> {
    String[] OPCODE = {
        "nop",  <i>/* 0*/</i>
        "aconst_null",  <i>/* 1*/</i>
        "iconst_m1",    <i>/* 2*/</i>
        "iconst_0",     <i>/* 3*/</i>
        ...
        ...
        ...
        "ifnonnull",    <i>/* 199*/</i>
        "goto_w",       <i>/* 200*/</i>
        "jsr_w"         <i>/* 201*/</i>
    };
}
</pre>

<p>Podívejme se nyní na u¾ivatelskou metodu <strong>printMethodBody()</strong>,
která vlastnì pøedstavuje ústøední èást na¹eho jednoduchého
&bdquo;disassembleru&ldquo;. V&nbsp;této metodì se prochází pøes jednotlivé
instrukce bajtkódu (metoda <strong>CodeIterator.next()</strong> mù¾e pøeskoèit
o více ne¾ jeden bajt) a následnì jsou vypsány mnemotechnické zkratky v¹ech
pøeètených instrukcí:</p>

<pre>
<i>    /**</i>
<i>     * Vypis instrukci tvoricich telo vybrane metody.</i>
<i>     *</i>
<i>     * @throws NotFoundException</i>
<i>     *             vyhozena, pokud metoda nebyla nalezena</i>
<i>     * @throws BadBytecode</i>
<i>     *             vyhozena, pokud se nalezne neplatna instrukce v bytekodu</i>
<i>     */</i>
    private static void <strong>printMethodBody</strong>(MethodInfo methodInfo) throws BadBytecode {
        CodeAttribute ca = methodInfo.getCodeAttribute();
        CodeIterator iterator = ca.iterator();
        while (iterator.hasNext()) {
            int index = iterator.next();
            int opcode = iterator.byteAt(index);
            System.out.println("        " + Mnemonic.OPCODE[opcode]);
        }
    }
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Zdrojový kód demonstraèního pøíkladu <strong>ClassGenerationTest5</strong></h2>

<p>U¾ivatelské metody popsané <a href="#k07">v&nbsp;sedmé</a> i <a
href="#k08">v&nbsp;osmé</a> kapitole, jsou souèástí dne¹ního druhého
demonstraèního pøíkladu pojmenovaného <strong>ClassGenerationTest5</strong>.
V&nbsp;tomto pøíkladu se nejdøíve vytvoøí ètveøice metod zcela shodným
zpùsobem, jako tomu bylo i v&nbsp;pøedchozím demonstraèním pøíkladu
<strong>ClassGenerationTest4</strong> a následnì jsou vypsány informace o v¹ech
tìchto ètyøech metodách. Následuje výpis zdrojového kódu dne¹ního druhého
demonstraèního pøíkladu:</p>

<pre>
import java.io.IOException;
&nbsp;
import javassist.CannotCompileException;
import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtMethod;
import javassist.Modifier;
import javassist.NotFoundException;
import javassist.bytecode.BadBytecode;
import javassist.bytecode.CodeAttribute;
import javassist.bytecode.CodeIterator;
import javassist.bytecode.MethodInfo;
import javassist.bytecode.Mnemonic;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Test moznosti nastroje Javassist - vygenerovani jednoduche tridy</i>
<i> * s metodou main a nekolika dalsimi metodami.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>ClassGenerationTest5</strong> {
&nbsp;
<i>    /**</i>
<i>     * Jmeno vygenerovane tridy.</i>
<i>     */</i>
    private static final String GENERATED_CLASS_NAME = "GeneratedClass5";
&nbsp;
<i>    /**</i>
<i>     * Zdrojovy kod metody main(), ktery bude nasledne zkompilovan</i>
<i>     * do bajtkodu a zakomponovan do vytvorene tridy.</i>
<i>     */</i>
    private static final String MAIN_METHOD_SOURCE_TEXT =
        "public static void main(String[] args)" +
        "{" +
        "    System.out.println(add(1,2));" +
        "    System.out.println(foo());" +
        "    System.out.println(bar());" +
        "}";
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni metody main() z jejiho zdrojoveho kodu.</i>
<i>     * </i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu</i>
<i>     */</i>
    private static void <strong>addMethodMain</strong>(CtClass generatedClass) throws CannotCompileException {
        CtMethod methodMain = CtMethod.make(MAIN_METHOD_SOURCE_TEXT, generatedClass);
        generatedClass.addMethod(methodMain);
    }
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni metody public static int add(int x, int y).</i>
<i>     *</i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu</i>
<i>     */</i>
    private static void <strong>addMethodAdd</strong>(CtClass generatedClass) throws CannotCompileException {
        CtMethod addMethod = CtMethod.make(
                "public static int add(int x, int y)" +
                "{" +
                "    return x+y;" +
                "}", generatedClass);
        generatedClass.addMethod(addMethod);
    }
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni bezparametricke staticke metody foo() vracejici int.</i>
<i>     *</i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu</i>
<i>     */</i>
    private static void <strong>constructMethodFoo</strong>(CtClass generatedClass) throws CannotCompileException {
        CtClass returnType = CtClass.intType;
        CtClass[] parameterTypes = {};
&nbsp;
<i>        // u metody je nutne znat jeji jmeno, navratovou hodnotu i typy parametru</i>
        CtMethod fooMethod = new CtMethod(returnType, "foo", parameterTypes, generatedClass);
&nbsp;
<i>        // zmena modifikatoru</i>
        fooMethod.setModifiers(Modifier.STATIC | Modifier.PUBLIC);
&nbsp;
<i>        // telo metody muze byt slozeno z jednoho vyrazu</i>
        fooMethod.setBody("return 42;");
        generatedClass.addMethod(fooMethod);
    }
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni bezparametricke staticke metody bar() vracejici float.</i>
<i>     *</i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu</i>
<i>     */</i>
    private static void <strong>constructMethodBar</strong>(CtClass generatedClass) throws CannotCompileException {
        CtClass returnType = CtClass.floatType;
        CtClass[] parameterTypes = {};
&nbsp;
<i>        // u metody je nutne znat jeji jmeno, navratovou hodnotu i typy parametru</i>
        CtMethod fooMethod = new CtMethod(returnType, "bar", parameterTypes, generatedClass);
&nbsp;
<i>        // zmena modifikatoru</i>
        fooMethod.setModifiers(Modifier.STATIC | Modifier.PRIVATE);
&nbsp;
<i>        // telo metody muze byt slozeno z celeho bloku</i>
        fooMethod.setBody(
                "{" +
                "    float x = 1/8f;" +
                "    float y = 336;" +
                "    return x * y;" +
                "}"
        );
        generatedClass.addMethod(fooMethod);
    }
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni tridy s metodou main().</i>
<i>     * </i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu metody main()</i>
<i>     * @throws IOException</i>
<i>     *             pokud dojde k chybe pri zapisu bajtkodu na disk</i>
<i>     * @throws NotFoundException</i>
<i>     *             pokud dojde k chybe pri zapisu bajtkodu na disk</i>
<i>     */</i>
    private static CtClass <strong>generateClass</strong>() throws CannotCompileException, NotFoundException, IOException {
<i>        // ziskat vychozi class pool</i>
        ClassPool pool = ClassPool.getDefault();
&nbsp;
<i>        // vytvoreni nove verejne tridy</i>
        CtClass generatedClass = pool.makeClass(GENERATED_CLASS_NAME);
&nbsp;
<i>        // pridani metody add do teto tridy</i>
        addMethodAdd(generatedClass);
&nbsp;
<i>        // konstrukce nove metody foo()</i>
        constructMethodFoo(generatedClass);
&nbsp;
<i>        // konstrukce nove metody bar()</i>
        constructMethodBar(generatedClass);
&nbsp;
<i>        // pridani metody do teto tridy</i>
        addMethodMain(generatedClass);
&nbsp;
<i>        // ulozeni bajtkodu na disk</i>
        generatedClass.writeFile();
&nbsp;
        return generatedClass;
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis struktury vybrane metody.</i>
<i>     * </i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @param methodName</i>
<i>     *            jmeno metody, jejiz struktura se ma vypsat</i>
<i>     * @throws NotFoundException</i>
<i>     *             vyhozena, pokud metoda nebyla nalezena</i>
<i>     * @throws BadBytecode</i>
<i>     *             vyhozena, pokud se nalezne neplatna instrukce v bytekodu</i>
<i>     */</i>
    private static void <strong>printMethodStructure</strong>(CtClass generatedClass, String methodName) throws NotFoundException, BadBytecode {
        System.out.println("Method '" + methodName + "' structure:");
        CtMethod method = generatedClass.getDeclaredMethod(methodName);
        if (method == null) {
            System.out.println("   not found!");
            return;
        }
        MethodInfo methodInfo = method.getMethodInfo();
        System.out.println("    real name:    " + methodInfo.getName());
        System.out.println("    descriptor:   " + methodInfo.getDescriptor());
        System.out.println("    access flags: " + Modifier.toString(methodInfo.getAccessFlags()));
        System.out.println("    method body:");
        printMethodBody(methodInfo);
        System.out.println();
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis instrukci tvoricich telo vybrane metody.</i>
<i>     *</i>
<i>     * @throws NotFoundException</i>
<i>     *             vyhozena, pokud metoda nebyla nalezena</i>
<i>     * @throws BadBytecode</i>
<i>     *             vyhozena, pokud se nalezne neplatna instrukce v bytekodu</i>
<i>     */</i>
    private static void <strong>printMethodBody</strong>(MethodInfo methodInfo) throws BadBytecode {
        CodeAttribute ca = methodInfo.getCodeAttribute();
        CodeIterator iterator = ca.iterator();
        while (iterator.hasNext()) {
            int index = iterator.next();
            int opcode = iterator.byteAt(index);
            System.out.println("        " + Mnemonic.OPCODE[opcode]);
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis struktury vybranych metod z generovane tridy.</i>
<i>     * </i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws NotFoundException</i>
<i>     *             vyhozena, pokud metoda nebyla nalezena</i>
<i>     * @throws BadBytecode </i>
<i>     */</i>
    private static void <strong>printMethodStructures</strong>(CtClass generatedClass) throws NotFoundException, BadBytecode {
        printMethodStructure(generatedClass, "main");
        printMethodStructure(generatedClass, "add");
        printMethodStructure(generatedClass, "foo");
        printMethodStructure(generatedClass, "bar");
    }
&nbsp;
<i>    /**</i>
<i>     * Spusteni generatoru tridy.</i>
<i>     *</i>
<i>     * @param args nevyuzito</i>
<i>     */</i>
    public static void <strong>main</strong>(String[] args) {
        System.out.println("class generation begin: " + GENERATED_CLASS_NAME);
        try {
            CtClass generatedClass = generateClass();
<i>            // dulezite - generovana trida nesmi byt "zmrazena"</i>
            generatedClass.defrost();
            printMethodStructures(generatedClass);
        }
        catch (CannotCompileException e) {
            e.printStackTrace();
        }
        catch (NotFoundException e) {
            e.printStackTrace();
        }
        catch (IOException e) {
            e.printStackTrace();
        }
        catch (BadBytecode e) {
            e.printStackTrace();
        }
        System.out.println("class generation end: " + GENERATED_CLASS_NAME);
    }
&nbsp;
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Ukázka výpisu bajtkódu metod vytvoøených demonstraèním pøíkladem <strong>ClassGenerationTest5</strong></h2>

<p>Pøeklad dne¹ního druhého demonstraèního pøíkladu
<strong>ClassGenerationTest5</strong> se provede podobným zpùsobem,
s&nbsp;jakým jsme se ji¾ setkali u pøíkladu pøedchozího:</p>

<pre>
javac -cp javassist.jar ClassGenerationTest5.java
</pre>

<p>I jeho spu¹tìní je témìø shodné:</p>

<pre>
java -cp .:javassist.jar ClassGenerationTest5
</pre>

<p>Po spu¹tìní tøídy <strong>ClassGenerationTest5</strong> se na standardní
výstup vypí¹ou informace o v¹ech ètyøech zkoumaných metodách. Mù¾ete si pro
vìt¹í zajímavost tento výpis zkusit porovnat s&nbsp;(prozatím) podrobnìj¹ím
výpisem uvedeným <a href="#k06">v&nbsp;¹esté kapitole</a>:</p>

<pre>
class generation begin: <strong>GeneratedClass5</strong>
Method '<strong>main</strong>' structure:
    real name:    main
    descriptor:   ([Ljava/lang/String;)V
    access flags: public static
    method body:
        getstatic
        iconst_1
        iconst_2
        invokestatic
        invokevirtual
        getstatic
        invokestatic
        invokevirtual
        getstatic
        invokestatic
        invokevirtual
        return
&nbsp;
Method '<strong>add</strong>' structure:
    real name:    add
    descriptor:   (II)I
    access flags: public static
    method body:
        iload_0
        iload_1
        iadd
        ireturn
&nbsp;
Method '<strong>foo</strong>' structure:
    real name:    foo
    descriptor:   ()I
    access flags: public static
    method body:
        bipush
        ireturn
&nbsp;
Method '<strong>bar</strong>' structure:
    real name:    bar
    descriptor:   ()F
    access flags: private static
    method body:
        ldc
        fstore_0
        sipush
        i2f
        fstore_1
        fload_0
        fload_1
        fmul
        freturn
&nbsp;
class generation end: <strong>GeneratedClass5</strong>
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Repositáø se zdrojovými kódy obou demonstraèních pøíkladù</h2>

<p>Následuje &ndash; v&nbsp;tomto seriálu ji¾ tradièní &ndash; kapitola
s&nbsp;odkazy na zdrojové kódy :-) Oba dnes popsané demonstraèní pøíklady jsou
spoleènì s&nbsp;dal¹ími pomocnými skripty ulo¾eny do Mercurial repositáøe
dostupného na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
V&nbsp;následující tabulce najdete odkazy na prozatím nejnovìj¹í verze tìchto
zdrojových kódù:</p>

<table>
<tr><th>#</th><th>Zdrojový soubor/skript</th><th>Umístìní souboru v&nbsp;repositáøi</th></tr>
<tr><td>1</td><td>ClassGenerationTest4.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/33c81496ce0a/javassist/ClassGenerationTest4/ClassGenerationTest4.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/33c81496ce0a/javassist/ClassGenerationTest4/ClassGenerationTest4.java</a></td></tr>
<tr><td>2</td><td>buildClassGenerator4.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/33c81496ce0a/javassist/ClassGenerationTest4/buildClassGenerator4.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/33c81496ce0a/javassist/ClassGenerationTest4/buildClassGenerator4.sh</a></td></tr>
<tr><td>3</td><td>runClassGenerator4.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/33c81496ce0a/javassist/ClassGenerationTest4/runClassGenerator4.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/33c81496ce0a/javassist/ClassGenerationTest4/runClassGenerator4.sh</a></td></tr>
<tr><td>4</td><td>runGeneratedClass4.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/33c81496ce0a/javassist/ClassGenerationTest4/runGeneratedClass4.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/33c81496ce0a/javassist/ClassGenerationTest4/runGeneratedClass4.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>ClassGenerationTest5.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/33c81496ce0a/javassist/ClassGenerationTest5/ClassGenerationTest5.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/33c81496ce0a/javassist/ClassGenerationTest5/ClassGenerationTest5.java</a></td></tr>
<tr><td>6</td><td>buildClassGenerator5.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/33c81496ce0a/javassist/ClassGenerationTest5/buildClassGenerator5.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/33c81496ce0a/javassist/ClassGenerationTest5/buildClassGenerator5.sh</a></td></tr>
<tr><td>7</td><td>runClassGenerator5.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/33c81496ce0a/javassist/ClassGenerationTest5/runClassGenerator5.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/33c81496ce0a/javassist/ClassGenerationTest5/runClassGenerator5.sh</a></td></tr>
<tr><td>8</td><td>runGeneratedClass5.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/33c81496ce0a/javassist/ClassGenerationTest5/runGeneratedClass5.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/33c81496ce0a/javassist/ClassGenerationTest5/runGeneratedClass5.sh</a></td></tr>
</table>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (pøed verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

