<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - detekce ètení i zápisu do vybraného atributu s vyu¾itím rozhraní JDI</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - detekce ètení i zápisu do vybraného atributu s vyu¾itím rozhraní JDI</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyku Java i o virtuálním stroji Javy dokonèíme téma, kterým jsme se zaèali zabývat ji¾ minule. Uká¾eme si zpùsob vyu¾ití rozhraní JDI (Java Debugger Interface) pro detekci ètení a souèasnì i zápisu nové hodnoty do sledovaného atributu vybrané tøídy.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - detekce ètení i zápisu do vybraného atributu s vyu¾itím rozhraní JDI</a></p>
<p><a href="#k02">2. Dvì skupiny událostí, které lze vyu¾ít v&nbsp;rozhraní JDI</a></p>
<p><a href="#k03">3. Metody pøedepsané v&nbsp;rozhraní <strong>AccessWatchpointEvent</strong></a></p>
<p><a href="#k04">4. Metody pøedepsané v&nbsp;rozhraní <strong>ModificationWatchpointEvent</strong></a></p>
<p><a href="#k05">5. Registrace události typu <strong>AccessWatchpointEvent</strong></a></p>
<p><a href="#k06">6. Registrace události typu <strong>ModificationWatchpointEvent</strong></a></p>
<p><a href="#k07">7. Smyèka událostí se zpracováním jednotlivých typù událostí</a></p>
<p><a href="#k08">8. Výpis zprávy v&nbsp;pøípadì detekce události ètení sledovaného atributu</a></p>
<p><a href="#k09">9. Výpis zprávy v&nbsp;pøípadì detekce události zápisu do sledovaného atributu</a></p>
<p><a href="#k10">10. Informace o lokaci ve zdrojovém kódu, kde do¹lo ke ètení èi k&nbsp;zápisu do sledovaného atributu</a></p>
<p><a href="#k11">11. Zdrojový kód demonstraèního pøíkladu <strong>JDIWatchPointDemo3</strong></a></p>
<p><a href="#k12">12. Výstup generovaný demonstraèním pøíkladem <strong>JDIWatchPointDemo3</strong></a></p>
<p><a href="#k13">13. Testovací tøída <strong>Test7</strong> &ndash; zápis shodné hodnoty, operátor ++ apod.</a></p>
<p><a href="#k14">14. Výstup generovaný demonstraèním pøíkladem <strong>JDIWatchPointDemo3</strong> pro tøídu <strong>Test7</strong></a></p>
<p><a href="#k15">15. Repositáø se zdrojovými kódy demonstraèního pøíkladu</a></p>
<p><a href="#k16">16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - detekce ètení i zápisu do vybraného atributu s vyu¾itím rozhraní JDI</h2>

<p>V&nbsp;dne¹ní èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyku Java i o virtuálním stroji Javy</a> dokonèíme téma,
kterému jsme se podrobnìji zaèali vìnovat ji¾ minule. Jedná se o detekci ètení
èi zápisu do vybraného atributu urèité tøídy s&nbsp;vyu¾itím rozhraní <i>JDI
(Java Debugger Interface)</i>, co¾ je funkcionalita implementovaná ve vìt¹inì
debuggerù a dal¹ích ladicích nástrojù. Minule jsme si na dvojici demonstraèních
pøíkladù <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/64baaf2ff0df/jdi/JDIWatchpointDemo1.java">JDIWatchPointDemo1.java</a>
a <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/64baaf2ff0df/jdi/JDIWatchpointDemo2.java">JDIWatchPointDemo2.java</a>
ukázali zpùsob naprogramování reakce na událost typu
<strong>AccessWatchpointEvent</strong>, která nastane ve chvíli, kdy dojde
k&nbsp;pøístupu ke sledovanému atributu (a to samozøejmì z&nbsp;libovolného
vlákna). Slovem &bdquo;pøístup&ldquo; zde máme na mysli ètení atributu.</p>

<p>Dnes si pro doplnìní popisu této problematiky uká¾eme, jakým zpùsobem lze
s&nbsp;vyu¾itím rozhraní <i>JDI</i> zjistit, ¾e se zmìnila hodnota sledovaného
atributu, tj.&nbsp;¾e do¹lo k&nbsp;operaci zápisu. Jak uvidíme dále, vyu¾ívá se
v&nbsp;tomto pøípadì událost typu <strong>ModificationWatchpointEvent</strong>,
která nám mj.&nbsp;zprostøedkuje jak starou, tak i novou hodnotu sledovaného
atributu. Díky této vlastnosti události
<strong>ModificationWatchpointEvent</strong> není nutné, aby si debugger èi
podobná aplikace musela sama slo¾itì udr¾ovat hodnoty v¹ech sledovaných
atributù.</p>

<p>Poznámka: zmìnou atributu je v&nbsp;pøípadì pou¾ití <i>JDI</i> my¹len i
zápis takové hodnoty, která se shoduje s&nbsp;hodnotou pùvodní.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Dvì skupiny událostí, které lze vyu¾ít v&nbsp;rozhraní JDI</h2>

<p>Pøipomeòme si, ¾e typy událostí podporovaných v&nbsp;<i>JDI</i> lze rozdìlit
do dvou skupin. V&nbsp;první skupinì najdeme události reprezentující zmìnu
stavu cílové JVM jako celku a ve druhé skupinì najdeme události, které jsou
vzta¾eny ke konkrétnímu vláknu a ke konkrétnímu místu kódu, kde k&nbsp;události
do¹lo. Do první skupiny nále¾í tyto typy událostí:</p>

<table>
<tr><th>#</th><th>Rozhraní</th><th>Popis</th></tr>
<tr><td>1</td><td>com.sun.jdi.event.VMStartEvent</td><td>Tato událost vznikne tìsnì pøed okam¾ikem, kdy je spu¹tìno hlavní vlákno aplikace, tj.&nbsp;vìt¹inou metoda main().</td></tr>
<tr><td>2</td><td>com.sun.jdi.event.VMDeathEvent</td><td>Tato událost informuje debugger o tom, ¾e cílová JVM bude ukonèena. V&nbsp;závislosti na nastavení debuggeru mohou vzniknout dvì události tohoto typu.</td></tr>
<tr><td>3</td><td>com.sun.jdi.event.VMDisconnectEvent</td><td>Tato událost informuje debugger o odpojení sledované JVM pøi jejím ukonèování.</td></tr>
<tr><td>4</td><td>com.sun.jdi.event.ClassPrepareEvent</td><td>Událost vygenerovaná ve chvíli, kdy se v&nbsp;cílové JVM naèítá a pøipravuje tøída.</td></tr>
<tr><td>5</td><td>com.sun.jdi.event.ClassUnloadEvent</td><td>Událost vygenerovaná pøi odstraòování tøídy ze sledované JVM (pokud JVM podporuje odstraòování tøíd z&nbsp;pamìti)</td></tr>
<tr><td>6</td><td>com.sun.jdi.event.ThreadStartEvent</td><td>Událost informující debugger o tom, ¾e vzniklo vlákno, které se bude spou¹tìt (událost je vygenerována je¹tì pøed vlastním spu¹tìním vlákna)</td></tr>
<tr><td>7</td><td>com.sun.jdi.event.ThreadDeathEvent</td><td>Událost informující debugger o ukonèení nìjakého vlákna</td></tr>
</table>

<p>Ve druhé skupinì typù událostí najdeme v¹echny události vzta¾ené ke
konkrétnímu vláknu a k&nbsp;urèitému místu kódu. Tyto typy událostí jsou
odvozeny od rozhraní <strong>com.sun.jdi.event.LocatableEvent</strong>:</p>

<table>
<tr><th>#</th><th>Rozhraní</th><th>Popis</th></tr>
<tr><td> 1</td><td>com.sun.jdi.event.BreakpointEvent</td><td>Vstup na breakpoint.</td></tr>
<tr><td> 2</td><td>com.sun.jdi.event.ExceptionEvent</td><td>Vznik výjimky (generováno v&nbsp;javovském kódu; pokud výjimka vznikne v&nbsp;nativním kódu, dojde ke vzniku události a¾ pozdìji)</td></tr>
<tr><td> 3</td><td>com.sun.jdi.event.MethodEntryEvent</td><td>Vstup do metody</td></tr>
<tr><td> 4</td><td>com.sun.jdi.event.MethodExitEvent</td><td>Výskok z&nbsp;metody (libovolný <strong>return</strong>, ne ov¹em pøi vzniku výjimky &ndash; tehdy se generuje jiná událost)</td></tr>
<tr><td> 5</td><td>com.sun.jdi.event.WatchpointEvent</td><td>Pøedek následující dvojice rozhraní:</td></tr>
<tr><td> 6</td><td>com.sun.jdi.event.AccessWatchpointEvent</td><td>Ètení hodnoty sledovaného atributu</td></tr>
<tr><td> 7</td><td>com.sun.jdi.event.ModificationWatchpointEvent</td>Zápis nové hodnoty do sledovaného atributu<td></td></tr>
<tr><td> 8</td><td>com.sun.jdi.event.MonitorContendedEnteredEvent</td><td>Vstup do re¾imu èekání s&nbsp;právì uvolnìným zámkem</td></tr>
<tr><td> 9</td><td>com.sun.jdi.event.MonitorContendedEnterEvent</td><td>Vstup do re¾imu èekání se zámkem, který ji¾ vlastní jiné vlákno</td></tr>
<tr><td>10</td><td>com.sun.jdi.event.MonitorWaitedEvent</td><td>Vlákno ukonèilo èekání na synchronizaci (i timeout èekání)</td></tr>
<tr><td>11</td><td>com.sun.jdi.event.MonitorWaitEvent</td><td>Vlákno vstoupí do re¾imu èekání na synchronizaci (<i>monitor</i>)</td></tr>
<tr><td>12</td><td>com.sun.jdi.event.StepEvent</td><td>Jeden krok pøi krokování aplikace</td></tr>
</table>

<p>V&nbsp;dal¹ím textu nás bude z&nbsp;pøedchozí tabulky zajímat pouze øádek 5,
6 a 7.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Metody pøedepsané v&nbsp;rozhraní <strong>AccessWatchpointEvent</strong></h2>

<p>V&nbsp;rozhraní <strong>com.sun.jdi.event.AccessWatchpointEvent</strong>
nalezneme metody shodné s&nbsp;metodami, které jsou pøedepsány v&nbsp;rozhraní
<strong>com.sun.jdi.event.WatchpointEvent</strong> (co¾ je pøedek):</p>

<table>
<tr><th>#</th><th>Návratový typ</th><th>Jméno metody</th><th>Parametry</th><th>Význam</th></tr>
<tr><td>1</td><td>com.sun.jdi.Field</td><td>field</td><td>()</td><td>vrací objekt pøedstavující sledovaný atribut</td></tr>
<tr><td>2</td><td>com.sun.jdi.ObjectReference</td><td>object</td><td>()</td><td>vrací objekt obsahující právì ètený èi mìnìný atribut</td></tr>
<tr><td>3</td><td>com.sun.jdi.Value</td><td>valueCurrent</td><td>()</td><td>vrací aktuální hodnotu sledovaného atributu</td></tr>
<tr><td>4</td><td>com.sun.jdi.ThreadReference</td><td>thread</td><td>()</td><td>informace o threadu v&nbsp;monitorované JVM, v&nbsp;nìm¾ do¹lo ke ètení èi zápisu do sledovaného atributu</td></tr>
<tr><td>5</td><td>com.sun.jdi.reqeuest.EventRequest</td><td>request</td><td>()</td><td>objekt s&nbsp;jeho¾ pomocí bylo nastaveno sledování tohoto typu události</td></tr>
<tr><td>6</td><td>com.sun.jdi.Location</td><td>location</td><td>()</td><td>lokalizace kódu, který ète sledovaný atribut popø.&nbsp;do tohoto atributu zapisuje</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Metody pøedepsané v&nbsp;rozhraní <strong>ModificationWatchpointEvent</strong></h2>

<p>V&nbsp;rozhraní
<strong>com.sun.jdi.event.ModificationWatchpointEvent</strong> je oproti
rozhraním <strong>com.sun.jdi.event.WatchpointEvent</strong> i
<strong>com.sun.jdi.event.AccessWatchpointEvent</strong> pøedepsána jedna
zvlá¹tní metoda slou¾ící k&nbsp;pøeètení nové hodnoty zapsané do sledovaného
atributu:</p>

<table>
<tr><th>#</th><th>Návratový typ</th><th>Jméno metody</th><th>Parametry</th><th>Význam</th></tr>
<tr><td>1</td><td>com.sun.jdi.Field</td><td>field</td><td>()</td><td>vrací objekt pøedstavující sledovaný atribut</td></tr>
<tr><td>2</td><td>com.sun.jdi.ObjectReference</td><td>object</td><td>()</td><td>vrací objekt obsahující právì ètený èi mìnìný atribut</td></tr>
<tr><td>3</td><td>com.sun.jdi.Value</td><td>valueCurrent</td><td>()</td><td>vrací aktuální hodnotu sledovaného atributu</td></tr>
<tr><td>4</td><td>com.sun.jdi.ThreadReference</td><td>thread</td><td>()</td><td>informace o threadu v&nbsp;monitorované JVM, v&nbsp;nìm¾ do¹lo ke ètení èi zápisu do sledovaného atributu</td></tr>
<tr><td>5</td><td>com.sun.jdi.reqeuest.EventRequest</td><td>request</td><td>()</td><td>objekt s&nbsp;jeho¾ pomocí bylo nastaveno sledování tohoto typu události</td></tr>
<tr><td>6</td><td>com.sun.jdi.Location</td><td>location</td><td>()</td><td>lokalizace kódu, který ète sledovaný atribut popø.&nbsp;do tohoto atributu zapisuje</td></tr>
<tr><td>7</td><td>com.sun.jdi.Value</td><td>valueToBe</td><td>()</td><td>nová hodnota zapisovaná do sledovaného atributu</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. Registrace události typu <strong>AccessWatchpointEvent</strong></h2>

<p>V&nbsp;následujícím textu budou postupnì popsány ty nejdùle¾itìj¹í metody
pou¾ité v&nbsp;dne¹ním demonstraèním pøíkladu
<strong>JDIWatchPointDemo3</strong>. Stejnì jako v&nbsp;ostatních
demonstraèních pøíkladech, i zde se nejprve provede pøipojení k&nbsp;ji¾
bì¾ícímu virtuálnímu stroji pøes socket na portu 6502 a následnì se zavolá
u¾ivatelská metoda <strong>acquireAndUseEventRequestManager</strong>, která
provede registraci v¹ech potøebných typù událostí a následný vstup do smyèky
událostí (<i>event loop</i>):</p>

<pre>
<i>    /**</i>
<i>     * Ukazka pouziti EventRequestManageru.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>acquireAndUseEventRequestManager</strong>(VirtualMachine virtualMachine) {
        EventRequestManager eventRequestManager = virtualMachine.eventRequestManager();
&nbsp;
<i>        // tuto udalost potrebujeme zpracovavat pro korektni ukonceni debuggeru</i>
        VMDeathRequest vmDeathRequest = registerVMDeathEvent(eventRequestManager);
&nbsp;
<i>        // udalost volana pri pristupu k vybranemu atributu</i>
        registerAccessWatchpointRequest(virtualMachine, eventRequestManager);
&nbsp;
<i>        // udalost volana pri zapisu do vybranemu atributu</i>
        registerModificationWatchpointRequest(virtualMachine, eventRequestManager);
&nbsp;
<i>        // klasicka smycka pro zpracovani udalosti</i>
        eventLoop(virtualMachine, vmDeathRequest);
    }
</pre>

<p>V&nbsp;metodì <strong>registerAccessWatchpointRequest()</strong>, kterou
jsme si ji¾ ukázali i v&nbsp;pøedchozí èásti tohoto seriálu, se nejprve vy¾ádá
generování událostí typu <strong>AccessWatchpointEvent</strong> a posléze se
vytváøení tìchto typù událostí je¹tì musí explicitnì povolit:</p>

<pre>
<i>    /**</i>
<i>     * Registrace udalosti typu AccessWatchpointEvent</i>
<i>     * @param virtualMachine </i>
<i>     *            sledovany virtualni stroj, k nemuz je debugger vzdalene</i>
<i>     *            pripojen</i>
<i>     */</i>
    private static void <strong>registerAccessWatchpointRequest</strong>(VirtualMachine virtualMachine, EventRequestManager eventRequestManager) {
<i>        // ziskani objektu predstavujiciho vybrany atribut</i>
        Field field = findField(virtualMachine);
&nbsp;
<i>        // registrace udalosti</i>
        AccessWatchpointRequest accessWatchpointRequest = eventRequestManager.createAccessWatchpointRequest(field);
&nbsp;
<i>        // po registraci udalosti je jeste nutne tento typ udalosti povolit</i>
        accessWatchpointRequest.enable();
    }
</pre>

<p>V&nbsp;této chvíli zaènou být do fronty událostí (<i>event queue</i>)
zapisovány i události typu <strong>AccessWatchpointEvent</strong> vyvolané ve
chvíli, kdy se ète hodnota sledovaného atributu.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Registrace události typu <strong>ModificationWatchpointEvent</strong></h2>

<p>Dal¹ím typem události, kterou musíme v&nbsp;demonstraèním pøíkladu
zpracovávat, jsou události typu <strong>ModificationWatchpointEvent</strong>,
které jsou do fronty událostí vlo¾eny ve chvíli, kdy se v&nbsp;monitorovaném
virtuálním stroji provede zápis do sledovaného atributu. O registraci tohoto
typu události se stará u¾ivatelská metoda
<strong>registerModificationWatchpointRequest()</strong>:</p>

<pre>
<i>    /**</i>
<i>     * Registrace udalosti typu ModificationWatchpointEvent</i>
<i>     * @param virtualMachine </i>
<i>     *            sledovany virtualni stroj, k nemuz je debugger vzdalene</i>
<i>     *            pripojen</i>
<i>     */</i>
    private static void <strong>registerModificationWatchpointRequest</strong>(VirtualMachine virtualMachine, EventRequestManager eventRequestManager) {
<i>        // ziskani objektu predstavujiciho vybrany atribut</i>
        Field field = findField(virtualMachine);
&nbsp;
<i>        // registrace udalosti</i>
        ModificationWatchpointRequest modificationWatchpointRequest = eventRequestManager.createModificationWatchpointRequest(field);
&nbsp;
<i>        // po registraci udalosti je jeste nutne tento typ udalosti povolit</i>
        modificationWatchpointRequest.enable();
    }
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Smyèka událostí se zpracováním jednotlivých typù událostí</h2>

<p>Implementace smyèky událostí je zcela stejná, jako smyèka pou¾itá
v&nbsp;demonstraèních pøíkladech <strong>JDIWatchpointDemo1</strong> a
<strong>JDIWatchpointDemo2</strong> popsaných minule:</p>

<pre>
<i>    /**</i>
<i>     * Klasicka smycka pro postupne zpracovani udalosti.</i>
<i>     * </i>
<i>     * @param virtualMachine</i>
<i>     *            sledovany virtualni stroj, k nemuz je debugger vzdalene</i>
<i>     *            pripojen</i>
<i>     * @param vmDeathRequest</i>
<i>     *            objekt pro rizeni udalosti typu VMDeathEvent</i>
<i>     */</i>
    private static void <strong>eventLoop</strong>(VirtualMachine virtualMachine, VMDeathRequest vmDeathRequest) {
        EventQueue eventQueue = virtualMachine.eventQueue();
&nbsp;
<i>        // precist a zpracovat udalosti</i>
        while (processEvents(eventQueue, vmDeathRequest)) {
<i>            // jojo tady skutecne nic neni :)</i>
        }
    }
</pre>

<p>Vlastní ètení událostí z&nbsp;fronty øe¹í u¾ivatelská metoda
<strong>processEvent()</strong>, v&nbsp;ní¾ se zpracovávají ètyøi typy událostí
&ndash; <strong>AccessWatchpointEvent</strong>,
<strong>ModificationWatchpointEvent</strong>, <strong>VMStartEvent</strong> a
<strong>VMDeathEvent</strong>. V&nbsp;této metodì je nutné jednotlivé události
rozpoznávat s&nbsp;vyu¾itím operátoru <i>instanceof</i> (druhou mo¾ností by
bylo porovnání názvù tøíd, to v¹ak není pøíli¹ efektivní):</p>

<pre>
<i>    /**</i>
<i>     * Precteni a zpracovani udalosti</i>
<i>     * </i>
<i>     * @param eventQueue</i>
<i>     *            fronta udalosti</i>
<i>     * @param vmDeathRequest</i>
<i>     *            objekt pro rizeni udalosti typu VMDeathEvent</i>
<i>     * </i>
<i>     * @return true pokud se ma pokracovat ve zpracovavani udalosti false pokud</i>
<i>     *         se ma sledovana VM ukoncit</i>
<i>     */</i>
    private static boolean <strong>processEvents</strong>(EventQueue eventQueue, VMDeathRequest vmDeathRequest) {
        EventSet eventSet;
        try {
<i>            // precist udalosti z fronty</i>
            eventSet = eventQueue.remove();
            int events = eventSet.size();
            System.out.println("Got " + events + " request" + (events &gt; 1 ? "s:" : ":"));
&nbsp;
<i>            // projit vsemi udalostmi</i>
            for (Event event : eventSet) {
                if (event instanceof VMStartEvent) {
                    System.out.println("    VMStartEvent");
                }
                else if (event instanceof VMDeathEvent) {
                    System.out.println("    VMDeathEvent");
<i>                    // zakazat dalsi generovani udalosti</i>
<i>                    // (u VMDeathEvent je ve skutecnosti vzdy posledni udalost poslana) </i>
                    vmDeathRequest.disable();
<i>                    // posleze se zavola shutdownVirtualMachine()</i>
                    return false;
                }
                else if (event instanceof AccessWatchpointEvent) {
<i>                    // podrobnejsi vypis o pristupu k atributu</i>
                    printAccessWatchpointInfo((AccessWatchpointEvent)event);
                }
                else if (event instanceof ModificationWatchpointEvent) {
<i>                    // podrobnejsi vypis o zapisu do atributu</i>
                    printModificationWatchpointInfo((ModificationWatchpointEvent)event);
                }
                else {
                    System.out.println("    other event");
                }
            }
<i>            // znovu postit vsechna vlakna</i>
            eventSet.resume();
        }
        catch (InterruptedException e) {
            e.printStackTrace();
        }
        return true;
    }
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Výpis zprávy v&nbsp;pøípadì detekce události ètení sledovaného atributu</h2>

<p>Koneènì se dostáváme k&nbsp;metodám na¹eho demonstraèního pøíkladu, které
jsou zavolány ve chvíli ètení popø.&nbsp;zápisu do sledovaného atributu. První
metodou je <strong>printAccessWatchpointInfo()</strong>, která vytiskne hodnotu
atributu ve chvíli jeho ètení nìjakým vláknem ve sledovaném virtuálním stroji
Javy. Oproti podobné metodì popsané minule se v¹ak zde hodnota atributu získává
ponìkud odli¹ným zpùsobem. Pøipomeòme si, ¾e minule jsme pro pøeètení hodnoty
celoèíselného atributu pou¾ívali zvlá¹tní metodu nazvanou
<strong>getFieldValue()</strong>, která vypadala následovnì:</p>

<pre>
<i>    /**</i>
<i>     * Ziskani hodnoty vybraneho atributu.</i>
<i>     *</i>
<i>     * @param event</i>
<i>     *            udalost typu AccessWatchpointEvent</i>
<i>     */</i>
    private static int <strong>getFieldValue</strong>(AccessWatchpointEvent event) {
        ObjectReference objectReference = event.object();
<i>        // dopredu zname typ atributu, tudiz lze provest pretypovani</i>
        IntegerValue value = (IntegerValue)objectReference.getValue(event.field());
        return value.intValue();
    }
</pre>

<p>Dnes naproti tomu pro ilustraci pomìrnì velké variability rozhraní
<i>JDI</i> pou¾ijeme jinou formu této metody, v&nbsp;ní¾ se vyu¾ije metoda
<strong>WatchPointEvent.valueCurrent()</strong>:</p>

<pre>
<i>    /**</i>
<i>     * Ziskani hodnoty vybraneho (sledovaneho) atributu.</i>
<i>     *</i>
<i>     * @param event</i>
<i>     *            udalost typu WatchpointEvent</i>
<i>     * @return hodnota, ktera je ulozena prirazena ve sledovanem atributu</i>
<i>     *         prevedena na retezec</i>
<i>     */</i>
    private static String <strong>getFieldValue</strong>(WatchpointEvent event) {
        return event.valueCurrent().toString();
    }
</pre>

<p>Pøi vzniku události typu <strong>AccessWatchpointEvent</strong> se získá
jméno a aktuální hodnota sledovaného atributu a posléze se tyto hodnoty vypí¹ou
na standardní výstup. Za tìmito hodnotami se navíc je¹tì vypí¹ou dal¹í
informace s&nbsp;vyu¾itím u¾ivatelské metody
<strong>printOtherWatchPointInfo()</strong> popsané <a
href="#k10">v&nbsp;dal¹ím textu</a>:</p>

<pre>
<i>    /**</i>
<i>     * Zprava vypsana ve chvili, kdy se cte hodnota sledovaneho atributu.</i>
<i>     *</i>
<i>     * @param event</i>
<i>     *            udalost typu AccessWatchpointEvent</i>
<i>     */</i>
    private static void <strong>printAccessWatchpointInfo</strong>(AccessWatchpointEvent event) {
<i>        // ziskat aktualni hodnotu atributu</i>
        String fieldValue = getFieldValue(event);
        String fieldName = event.field().name();
        System.out.format("    read value %s from attribute %s ", fieldValue, fieldName);
        printOtherWatchPointInfo(event);
    }
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Výpis zprávy v&nbsp;pøípadì detekce události zápisu do sledovaného atributu</h2>

<p>Dal¹í u¾ivatelská metoda <strong>printModificationWatchpointInfo()</strong>
je zavolána tehdy, pokud ve sledovaném virtuálním stroji Javy dojde
k&nbsp;zápisu do sledovaného atributu:</p>

<pre>
<i>    /**</i>
<i>     * Zprava vypsana ve chvili, kdy se zapisuje nova hodnota do sledovaneho atributu.</i>
<i>     *</i>
<i>     * @param event</i>
<i>     *            udalost typu ModificationWatchpointEvent</i>
<i>     */</i>
    private static void <strong>printModificationWatchpointInfo</strong>(ModificationWatchpointEvent event) {
<i>        // ziskat aktualni hodnotu atributu</i>
        String fieldValue = getFieldValue(event);
        String fieldName = event.field().name();
        String newValue = getNewValue(event);
        System.out.format("    overwrite value %s in attribute %s by new value %s", fieldValue, fieldName, newValue);
        printOtherWatchPointInfo(event);
    }
</pre>

<p>Od u¾ivatelské metody <strong>printAccessWatchpointInfo()</strong> se metoda
<strong>printModificationWatchpointInfo()</strong> li¹í pouze tím, ¾e pøibyla
informace o nové hodnotì atributu, co¾ je informace získaná z&nbsp;dal¹í
pomocné u¾ivatelské metody nazvané <strong>getNewValue()</strong>:</p>

<pre>
<i>    /**</i>
<i>     * Precteni nove hodnoty, ktera ma byt prirazena do sledovaneho atributu.</i>
<i>     *</i>
<i>     * @param event</i>
<i>     *            udalost typu ModificationWatchpointEvent</i>
<i>     * @return nova hodnota, ktera ma byt prirazena do sledovaneho atributu</i>
<i>     *         prevedena na retezec</i>
<i>     */</i>
    private static String <strong>getNewValue</strong>(ModificationWatchpointEvent event) {
        return event.valueToBe().toString();
    }
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Informace o lokaci ve zdrojovém kódu, kde do¹lo ke ètení èi k&nbsp;zápisu do sledovaného atributu</h2>

<p>V&nbsp;u¾ivatelských metodách <strong>printAccessWatchpointInfo()</strong> i
<strong>printModificationWatchpointInfo()</strong> je nutné mj.&nbsp;vypsat i
informaci o lokaci ve zdrojovém kódu, v&nbsp;nìm¾ do¹lo ke ètení èi
k&nbsp;zápisu do sledovaného atributu. O tuto spoleènou funkci se stará metoda
<strong>printOtherWatchPointInfo()</strong>, která nejprve z&nbsp;objektu typu
<strong>WatchpointEvent</strong> získá instanci tøídy <strong>Location</strong>
a posléze z&nbsp;této instance pøeète jméno tøídy i metody, název zdrojového
kódu, v&nbsp;nìm¾ byla tøída deklarována a koneènì i èíslo øádku, na nìm¾ do¹lo
ke ètení èi zápisu do sledovaného atributu (poslední zmiòovaná informace se
v¹ak vypí¹e pouze tehdy, pokud je testovací tøída pøelo¾ena s&nbsp;pøepínaèem
<strong>-g</strong>):</p>

<pre>
<i>    /**</i>
<i>     * Vypis lokace v kodu, kde dochazi ke cteni ci k zapisu nove hodnoty</i>
<i>     * do sledovaneho atributu.</i>
<i>     *</i>
<i>     * @param event</i>
<i>     *            udalost typu WatchpointEvent</i>
<i>     */</i>
    private static void <strong>printOtherWatchPointInfo</strong>(WatchpointEvent event) {
<i>        // ziskat objekt typu Location, ktery obsahuje informaci o tom,</i>
<i>        // ve kterem miste kodu se k atributu pristupovalo</i>
        Location location = event.location();
&nbsp;
<i>        // ziskat vsechny informace o pozici v pozastavenem vlaknu</i>
        String className = getClassName(location);
        String methodName = getMethodName(location);
        String sourceName = getSourceName(location);
        String lineNumber = getLineNumber(location);
&nbsp;
<i>        // nyni jiz mame vsechny dulezite informace,</i>
<i>        // lze je tedy vypsat</i>
        System.out.format("  at: %s.%s ", className, methodName);
<i>        // po vypisu zakladnich informaci se jeste vypise jmeno zdrojoveho</i>
<i>        // souboru a cislo radku metody, v niz se k atributu pristupuje</i>
        System.out.format("(%s:%s)\n", sourceName, lineNumber);
    }
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Zdrojový kód demonstraèního pøíkladu <strong>JDIWatchPointDemo3</strong></h2>

<p>Celý dne¹ní demonstraèní pøíklad <strong>JDIWatchPointDemo3</strong> pracuje
tak, ¾e se nejdøíve zaregistrují v¹echny typy zpracovávaných událostí a posléze
se spustí smyèka událostí. Vytváøení v¹ech sledovaných typù událostí nastane ve
chvíli, kdy aplikace bì¾ící v&nbsp;monitorovaném (cílovém) virtuálním stroji
Javy pøeète (v&nbsp;libovolném vláknu) atribut s&nbsp;plným jménem
<strong>Test6.testedField</strong>, popø.&nbsp;modifikuje hodnotu tohoto
atributu. Ve chvíli, kdy k&nbsp;pøeètení tohoto atributu dojde, mù¾e
demonstraèní pøíklad ze své fronty událostí získat objekt typu
<strong>AccessWatchpointEvent</strong> a vypsat prozatím základní informaci o
této události na standardní výstup. Podobnì je tomu i pøi zápisu do atributu,
tj.&nbsp;pøi zpracování události typu
<strong>ModificationWatchpointEvent</strong>. Následuje výpis celého zdrojového
kódu dne¹ního prvního demonstraèního pøíkladu:</p>

<pre>
import java.io.IOException;
import java.util.List;
import java.util.Map;
&nbsp;
import com.sun.jdi.AbsentInformationException;
import com.sun.jdi.Bootstrap;
import com.sun.jdi.Field;
import com.sun.jdi.Location;
import com.sun.jdi.ReferenceType;
import com.sun.jdi.VirtualMachine;
import com.sun.jdi.VirtualMachineManager;
import com.sun.jdi.connect.AttachingConnector;
import com.sun.jdi.connect.Connector;
import com.sun.jdi.connect.IllegalConnectorArgumentsException;
import com.sun.jdi.event.AccessWatchpointEvent;
import com.sun.jdi.event.Event;
import com.sun.jdi.event.EventQueue;
import com.sun.jdi.event.EventSet;
import com.sun.jdi.event.ModificationWatchpointEvent;
import com.sun.jdi.event.VMDeathEvent;
import com.sun.jdi.event.VMStartEvent;
import com.sun.jdi.event.WatchpointEvent;
import com.sun.jdi.request.AccessWatchpointRequest;
import com.sun.jdi.request.EventRequestManager;
import com.sun.jdi.request.ModificationWatchpointRequest;
import com.sun.jdi.request.VMDeathRequest;
&nbsp;
&nbsp;
&nbsp;
/**
<i> * Demonstracni priklad JDIWatchPointDemo3, v nemz je ukazan zpusob</i>
<i> * vypisu zprav pri cteni i pri zapisu do sledovaneho atributu vybrane tridy.</i>
<i> *</i>
<i> * Pripojeni k bezicimu virtualnimu stroji Javy,</i>
<i> * ktery byl spusten s parametry:</i>
<i> * java -agentlib:jdwp=transport=dt_socket,server=y,address=6502,suspend=y Trida</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>JDIWatchPointDemo3</strong> {
&nbsp;
<i>    /**</i>
<i>     * Navratovy kod pouzity pri ukoncovani sledovane JVM.</i>
<i>     */</i>
    private static final int <strong>EXIT_VALUE</strong> = 0;
&nbsp;
<i>    /**</i>
<i>     * Jmeno konektoru, ktery pro pripojeni pouziva sockety.</i>
<i>     */</i>
    private static final String <strong>SOCKET_ATTACH_CONNECTOR_NAME</strong> = "com.sun.jdi.SocketAttach";
&nbsp;
<i>    /**</i>
<i>     * Jmeno testovane tridy.</i>
<i>     */</i>
    private static final String <strong>TEST_CLASS_NAME</strong> = "Test6";
&nbsp;
<i>    /**</i>
<i>     * Jmeno sledovaneho atributu v testovane tride.</i>
<i>     */</i>
    private static final String <strong>TESTED_FIELD_NAME</strong> = "testedField";
&nbsp;
<i>    /**</i>
<i>     * Vstupni metoda debuggeru.</i>
<i>     */</i>
    public static void <strong>main</strong>(String[] args) {
<i>        // ziskat (jedinou) instanci tridy VirtualMachineManager</i>
        VirtualMachineManager virtualMachineManager = Bootstrap.virtualMachineManager();
&nbsp;
<i>        // ziskat vsechny konektory pouzite pro pripojeni k bezici JVM</i>
        List&lt;AttachingConnector&gt; connectors = virtualMachineManager.attachingConnectors();
&nbsp;
<i>        // potrebujeme ziskat konektor pouzivajici pro pripojeni sockety</i>
        AttachingConnector connector = getSocketAttachConnector(connectors);
&nbsp;
        if (connector == null) {
            System.out.println("Socket connector is not available");
            return;
        }
&nbsp;
<i>        // jsme pripojeni ke sledovane JVM, takze lze provadet ladeni</i>
        debugVirtualMachineUsingSocket(connector);
    }
&nbsp;
<i>    /**</i>
<i>     * Ziskat konektor pouzivajici pro pripojeni sockety</i>
<i>     */</i>
    private static AttachingConnector <strong>getSocketAttachConnector</strong>(List&lt;AttachingConnector&gt; connectors) {
        for (AttachingConnector connector : connectors) {
            if (SOCKET_ATTACH_CONNECTOR_NAME.equals(connector.name())) {
                return connector;
            }
        }
<i>        // nenasli jsme zadny vhodny konektor</i>
        return null;
    }
&nbsp;
<i>    /**</i>
<i>     * Pripojeni k bezicimu virtualnimu stroji pres socket.</i>
<i>     * @throws InterruptedException </i>
<i>     */</i>
    private static void <strong>debugVirtualMachineUsingSocket</strong>(AttachingConnector connector) {
<i>        // nastaveni argumentu pouzivanych konektorem</i>
        Map&lt;String, Connector.Argument&gt; arguments = prepareConnectorArguments(connector);
&nbsp;
        try {
<i>            // pripojeni ke vzdalenemu bezicimu virtualnimu stroji Javy</i>
            VirtualMachine virtualMachine = connectToVirtualMachine(connector, arguments);
&nbsp;
<i>            // spustit sledovany virtualni stroj Javy</i>
            runVirtualMachine(virtualMachine);
&nbsp;
<i>            // ukazka pouziti EventRequestManageru</i>
            acquireAndUseEventRequestManager(virtualMachine);
&nbsp;
<i>            // ukonceni behu vzdaleneho virtualniho stroje</i>
            shutdownVirtualMachine(virtualMachine);
        }
        catch (IOException e) {
            e.printStackTrace();
        }
        catch (IllegalConnectorArgumentsException e) {
            e.printStackTrace();
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Nastaveni portu na cilove JVM, jenz debugger pouzije pro navazani spojeni.</i>
<i>     *</i>
<i>     * @param connector konektor pouzity pro pripojeni</i>
<i>     * @return mapa obsahujici parametry konektoru</i>
<i>     */</i>
    private static Map&lt;String, Connector.Argument&gt; <strong>prepareConnectorArguments</strong>(AttachingConnector connector) {
        Map&lt;String, Connector.Argument&gt; arguments = connector.defaultArguments();
        arguments.get("port").setValue("6502");
        return arguments;
    }
&nbsp;
<i>    /**</i>
<i>     * Pripojeni debuggeru ke sledovanemu virtualnimu stroji.</i>
<i>     *</i>
<i>     * @param connector konektor vyuzivajici pro spojeni sockety</i>
<i>     * @param arguments mapa obsahujici parametry pripojeni</i>
<i>     * @return sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     *</i>
<i>     * @throws IOException vyvolane v pripade, ze se pripojeni k JVM nepodari</i>
<i>     * @throws IllegalConnectorArgumentsException vyvolane v pripade spatne zadanych parametru</i>
<i>     */</i>
    private static VirtualMachine <strong>connectToVirtualMachine</strong>(AttachingConnector connector, Map&lt;String, Connector.Argument&gt; arguments)
        throws IOException, IllegalConnectorArgumentsException {
        System.out.println("Connecting to virtual machine");
        VirtualMachine virtualMachine = connector.attach(arguments);
        System.out.println("Connected");
        return virtualMachine;
    }
&nbsp;
<i>    /**</i>
<i>     * Spustit sledovany virtualni stroj</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>runVirtualMachine</strong>(VirtualMachine virtualMachine) {
        virtualMachine.resume();
    }
&nbsp;
<i>    /**</i>
<i>     * Ukonceni prace beziciho sledovaneho virtualniho stroje.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>shutdownVirtualMachine</strong>(VirtualMachine virtualMachine) {
        System.out.println("Calling exit");
        virtualMachine.exit(EXIT_VALUE);
    }
&nbsp;
<i>    /**</i>
<i>     * Ukazka pouziti EventRequestManageru.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>acquireAndUseEventRequestManager</strong>(VirtualMachine virtualMachine) {
        EventRequestManager eventRequestManager = virtualMachine.eventRequestManager();
&nbsp;
<i>        // tuto udalost potrebujeme zpracovavat pro korektni ukonceni debuggeru</i>
        VMDeathRequest vmDeathRequest = registerVMDeathEvent(eventRequestManager);
&nbsp;
<i>        // udalost volana pri pristupu k vybranemu atributu</i>
        registerAccessWatchpointRequest(virtualMachine, eventRequestManager);
&nbsp;
<i>        // udalost volana pri zapisu do vybranemu atributu</i>
        registerModificationWatchpointRequest(virtualMachine, eventRequestManager);
&nbsp;
<i>        // klasicka smycka pro zpracovani udalosti</i>
        eventLoop(virtualMachine, vmDeathRequest);
    }
&nbsp;
<i>    /**</i>
<i>     * Registrace udalosti typu VMDeathEvent</i>
<i>     */</i>
    private static VMDeathRequest <strong>registerVMDeathEvent</strong>(EventRequestManager eventRequestManager) {
        VMDeathRequest vmDeathRequest = eventRequestManager.createVMDeathRequest();
<i>        // po registraci udalosti je jeste nutne tento typ udalosti povolit</i>
        vmDeathRequest.enable();
        return vmDeathRequest;
    }
&nbsp;
<i>    /**</i>
<i>     * Registrace udalosti typu AccessWatchpointEvent</i>
<i>     * @param virtualMachine </i>
<i>     *            sledovany virtualni stroj, k nemuz je debugger vzdalene</i>
<i>     *            pripojen</i>
<i>     */</i>
    private static void <strong>registerAccessWatchpointRequest</strong>(VirtualMachine virtualMachine, EventRequestManager eventRequestManager) {
<i>        // ziskani objektu predstavujiciho vybrany atribut</i>
        Field field = findField(virtualMachine);
&nbsp;
<i>        // registrace udalosti</i>
        AccessWatchpointRequest accessWatchpointRequest = eventRequestManager.createAccessWatchpointRequest(field);
&nbsp;
<i>        // po registraci udalosti je jeste nutne tento typ udalosti povolit</i>
        accessWatchpointRequest.enable();
    }
&nbsp;
<i>    /**</i>
<i>     * Registrace udalosti typu ModificationWatchpointEvent</i>
<i>     * @param virtualMachine </i>
<i>     *            sledovany virtualni stroj, k nemuz je debugger vzdalene</i>
<i>     *            pripojen</i>
<i>     */</i>
    private static void <strong>registerModificationWatchpointRequest</strong>(VirtualMachine virtualMachine, EventRequestManager eventRequestManager) {
<i>        // ziskani objektu predstavujiciho vybrany atribut</i>
        Field field = findField(virtualMachine);
&nbsp;
<i>        // registrace udalosti</i>
        ModificationWatchpointRequest modificationWatchpointRequest = eventRequestManager.createModificationWatchpointRequest(field);
&nbsp;
<i>        // po registraci udalosti je jeste nutne tento typ udalosti povolit</i>
        modificationWatchpointRequest.enable();
    }
&nbsp;
<i>    /**</i>
<i>     * Ziskani objektu predstavujiciho vybrany atribut ve sledovane VM.</i>
<i>     *</i>
<i>     * @param virtualMachine</i>
<i>     *            sledovany virtualni stroj, k nemuz je debugger vzdalene</i>
<i>     *            pripojen</i>
<i>     * @return nalezeny atribut</i>
<i>     */</i>
    private static Field <strong>findField</strong>(VirtualMachine virtualMachine) {
<i>        // mela by se vratit jedina trida</i>
        List&lt;ReferenceType&gt; allClasses = virtualMachine.classesByName(TEST_CLASS_NAME);
        System.out.println("Number of classes with name '" + TEST_CLASS_NAME + "': " + allClasses.size());
&nbsp;
<i>        // vratila se jedina trida, takze ji precteme</i>
        ReferenceType class1 = allClasses.get(0);
&nbsp;
<i>        // ziskani atributu z teto tridy</i>
        return class1.fieldByName(TESTED_FIELD_NAME);
    }
&nbsp;
<i>    /**</i>
<i>     * Klasicka smycka pro postupne zpracovani udalosti.</i>
<i>     * </i>
<i>     * @param virtualMachine</i>
<i>     *            sledovany virtualni stroj, k nemuz je debugger vzdalene</i>
<i>     *            pripojen</i>
<i>     * @param vmDeathRequest</i>
<i>     *            objekt pro rizeni udalosti typu VMDeathEvent</i>
<i>     */</i>
    private static void <strong>eventLoop</strong>(VirtualMachine virtualMachine, VMDeathRequest vmDeathRequest) {
        EventQueue eventQueue = virtualMachine.eventQueue();
&nbsp;
<i>        // precist a zpracovat udalosti</i>
        while (processEvents(eventQueue, vmDeathRequest)) {
<i>            // jojo tady skutecne nic neni :)</i>
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Precteni a zpracovani udalosti</i>
<i>     * </i>
<i>     * @param eventQueue</i>
<i>     *            fronta udalosti</i>
<i>     * @param vmDeathRequest</i>
<i>     *            objekt pro rizeni udalosti typu VMDeathEvent</i>
<i>     * </i>
<i>     * @return true pokud se ma pokracovat ve zpracovavani udalosti false pokud</i>
<i>     *         se ma sledovana VM ukoncit</i>
<i>     */</i>
    private static boolean <strong>processEvents</strong>(EventQueue eventQueue, VMDeathRequest vmDeathRequest) {
        EventSet eventSet;
        try {
<i>            // precist udalosti z fronty</i>
            eventSet = eventQueue.remove();
            int events = eventSet.size();
            System.out.println("Got " + events + " request" + (events &gt; 1 ? "s:" : ":"));
&nbsp;
<i>            // projit vsemi udalostmi</i>
            for (Event event : eventSet) {
                if (event instanceof VMStartEvent) {
                    System.out.println("    VMStartEvent");
                }
                else if (event instanceof VMDeathEvent) {
                    System.out.println("    VMDeathEvent");
<i>                    // zakazat dalsi generovani udalosti</i>
<i>                    // (u VMDeathEvent je ve skutecnosti vzdy posledni udalost poslana) </i>
                    vmDeathRequest.disable();
<i>                    // posleze se zavola shutdownVirtualMachine()</i>
                    return false;
                }
                else if (event instanceof AccessWatchpointEvent) {
<i>                    // podrobnejsi vypis o pristupu k atributu</i>
                    printAccessWatchpointInfo((AccessWatchpointEvent)event);
                }
                else if (event instanceof ModificationWatchpointEvent) {
<i>                    // podrobnejsi vypis o zapisu do atributu</i>
                    printModificationWatchpointInfo((ModificationWatchpointEvent)event);
                }
                else {
                    System.out.println("    other event");
                }
            }
<i>            // znovu postit vsechna vlakna</i>
            eventSet.resume();
        }
        catch (InterruptedException e) {
            e.printStackTrace();
        }
        return true;
    }
&nbsp;
<i>    /**</i>
<i>     * Zprava vypsana ve chvili, kdy se cte hodnota sledovaneho atributu.</i>
<i>     *</i>
<i>     * @param event</i>
<i>     *            udalost typu AccessWatchpointEvent</i>
<i>     */</i>
    private static void <strong>printAccessWatchpointInfo</strong>(AccessWatchpointEvent event) {
<i>        // ziskat aktualni hodnotu atributu</i>
        String fieldValue = getFieldValue(event);
        String fieldName = event.field().name();
        System.out.format("    read value %s from attribute %s ", fieldValue, fieldName);
        printOtherWatchPointInfo(event);
    }
&nbsp;
<i>    /**</i>
<i>     * Zprava vypsana ve chvili, kdy se zapisuje nova hodnota do sledovaneho atributu.</i>
<i>     *</i>
<i>     * @param event</i>
<i>     *            udalost typu ModificationWatchpointEvent</i>
<i>     */</i>
    private static void <strong>printModificationWatchpointInfo</strong>(ModificationWatchpointEvent event) {
<i>        // ziskat aktualni hodnotu atributu</i>
        String fieldValue = getFieldValue(event);
        String fieldName = event.field().name();
        String newValue = getNewValue(event);
        System.out.format("    overwrite value %s in attribute %s by new value %s", fieldValue, fieldName, newValue);
        printOtherWatchPointInfo(event);
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis lokace v kodu, kde dochazi ke cteni ci k zapisu nove hodnoty</i>
<i>     * do sledovaneho atributu.</i>
<i>     *</i>
<i>     * @param event</i>
<i>     *            udalost typu WatchpointEvent</i>
<i>     */</i>
    private static void <strong>printOtherWatchPointInfo</strong>(WatchpointEvent event) {
<i>        // ziskat objekt typu Location, ktery obsahuje informaci o tom,</i>
<i>        // ve kterem miste kodu se k atributu pristupovalo</i>
        Location location = event.location();
&nbsp;
<i>        // ziskat vsechny informace o pozici v pozastavenem vlaknu</i>
        String className = getClassName(location);
        String methodName = getMethodName(location);
        String sourceName = getSourceName(location);
        String lineNumber = getLineNumber(location);
&nbsp;
<i>        // nyni jiz mame vsechny dulezite informace,</i>
<i>        // lze je tedy vypsat</i>
        System.out.format("  at: %s.%s ", className, methodName);
<i>        // po vypisu zakladnich informaci se jeste vypise jmeno zdrojoveho</i>
<i>        // souboru a cislo radku metody, v niz se k atributu pristupuje</i>
        System.out.format("(%s:%s)\n", sourceName, lineNumber);
    }
&nbsp;
<i>    /**</i>
<i>     * Ziskani hodnoty vybraneho (sledovaneho) atributu.</i>
<i>     *</i>
<i>     * @param event</i>
<i>     *            udalost typu WatchpointEvent</i>
<i>     * @return hodnota, ktera je ulozena prirazena ve sledovanem atributu</i>
<i>     *         prevedena na retezec</i>
<i>     */</i>
    private static String <strong>getFieldValue</strong>(WatchpointEvent event) {
        return event.valueCurrent().toString();
    }
&nbsp;
<i>    /**</i>
<i>     * Precteni nove hodnoty, ktera ma byt prirazena do sledovaneho atributu.</i>
<i>     *</i>
<i>     * @param event</i>
<i>     *            udalost typu ModificationWatchpointEvent</i>
<i>     * @return nova hodnota, ktera ma byt prirazena do sledovaneho atributu</i>
<i>     *         prevedena na retezec</i>
<i>     */</i>
    private static String <strong>getNewValue</strong>(ModificationWatchpointEvent event) {
        return event.valueToBe().toString();
    }
&nbsp;
<i>    /**</i>
<i>     * Jmeno tridy, jejiz metoda byla zavolana.</i>
<i>     */</i>
    private static String <strong>getClassName</strong>(Location location) {
        return location.method().declaringType().name();
    }
&nbsp;
<i>    /**</i>
<i>     * Jmeno volane metody.</i>
<i>     */</i>
    private static String <strong>getMethodName</strong>(Location location) {
        return location.method().name();
    }
&nbsp;
<i>    /**</i>
<i>     * Ziskani informaci o jmene zdrojoveho souboru pro danou lokaci.</i>
<i>     */</i>
    private static String <strong>getSourceName</strong>(Location location) {
        try {
            return location.sourceName();
        }
        catch (AbsentInformationException e) {
            return "unknown";
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Prevod cisla radku na retezec, pokud je to mozne.</i>
<i>     */</i>
    private static String <strong>getLineNumber</strong>(Location location) {
        int lineNumber = location.lineNumber();
<i>        // u nativnich metod nelze zjistit cisla radku</i>
        return lineNumber &gt;= 0 ? "" + lineNumber : "&lt;native method&gt;";
    }
&nbsp;
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Výstup generovaný demonstraèním pøíkladem <strong>JDIWatchPointDemo3</strong></h2>

<p>Podívejme se nyní na zpùsob pøelo¾ení a následného pou¾ití demonstraèního
pøíkladu <strong>JDIWatchPointDemo3</strong>. Pøeklad se provede následujícím
skriptem (který pøedpokládá instalaci OpenJDK 6 do nastaveného adresáøe):</p>

<pre>
javac -classpath /usr/lib/jvm/java-6-openjdk/lib/tools.jar:. JDIWatchpointDemo3.java
</pre>

<p>Pøed spu¹tìním tohoto pøíkladu je nutné z&nbsp;jiného terminálu spustit i
testovací aplikaci <strong>Test6</strong> (její <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/64baaf2ff0df/jdi/Test6.java">zdrojový
kód</a> jsme si ukazovali minule):</p>

<pre>
java -agentlib:jdwp=transport=dt_socket,server=y,address=6502,suspend=y Test6
</pre>

<p>Spu¹tìní dne¹ního demonstraèního pøíkladu zajistí následující pøíkaz:</p>

<pre>
java -cp /usr/lib/jvm/java-6-openjdk/lib/tools.jar:. JDIWatchpointDemo3
</pre>

<p>Jakmile se testovací aplikace <strong>Test6</strong> spustí, otevøe její
virtuální stroj Javy port èíslo 6502, na nìm¾ se oèekává pøipojení debuggeru.
Následnì tato aplikace poèká na stisk libovolné klávesy. Po pøipojení debuggeru
(resp.&nbsp;na¹eho demonstraèního pøíkladu <strong>JDIWatchpointDemo3</strong>)
by se na standardní výstup mìly vypsat následující zprávy:</p>

<pre>
Connecting to virtual machine
Connected
Number of classes with name 'Test6': 1
Number of classes with name 'Test6': 1
Got 1 request:
    overwrite value 0 in attribute testedField by new value 1  at: Test6.<init> (Test6.java:3)
Got 1 request:
    read value 1 from attribute testedField   at: Test6.run (Test6.java:6)
Got 1 request:
    overwrite value 1 in attribute testedField by new value 42  at: Test6.run (Test6.java:6)
Got 1 request:
    overwrite value 42 in attribute testedField by new value 1  at: Test6.foo (Test6.java:12)
Got 1 request:
    read value 1 from attribute testedField   at: Test6.bar (Test6.java:18)
Got 1 request:
    overwrite value 1 in attribute testedField by new value 2  at: Test6.foo (Test6.java:12)
Got 1 request:
    read value 2 from attribute testedField   at: Test6.bar (Test6.java:18)
Got 1 request:
    overwrite value 2 in attribute testedField by new value 4  at: Test6.foo (Test6.java:12)
Got 1 request:
    read value 4 from attribute testedField   at: Test6.bar (Test6.java:18)
Got 1 request:
    overwrite value 4 in attribute testedField by new value 8  at: Test6.foo (Test6.java:12)
Got 1 request:
    read value 8 from attribute testedField   at: Test6.bar (Test6.java:18)
Got 1 request:
    overwrite value 8 in attribute testedField by new value 16  at: Test6.foo (Test6.java:12)
Got 1 request:
    read value 16 from attribute testedField   at: Test6.bar (Test6.java:18)
Got 1 request:
    overwrite value 16 in attribute testedField by new value 32  at: Test6.foo (Test6.java:12)
Got 1 request:
    read value 32 from attribute testedField   at: Test6.bar (Test6.java:18)
Got 1 request:
    overwrite value 32 in attribute testedField by new value 64  at: Test6.foo (Test6.java:12)
Got 1 request:
    read value 64 from attribute testedField   at: Test6.bar (Test6.java:18)
Got 1 request:
    overwrite value 64 in attribute testedField by new value 128  at: Test6.foo (Test6.java:12)
Got 1 request:
    read value 128 from attribute testedField   at: Test6.bar (Test6.java:18)
Got 1 request:
    overwrite value 128 in attribute testedField by new value 256  at: Test6.foo (Test6.java:12)
Got 1 request:
    read value 256 from attribute testedField   at: Test6.bar (Test6.java:18)
Got 1 request:
    overwrite value 256 in attribute testedField by new value 512  at: Test6.foo (Test6.java:12)
Got 1 request:
    read value 512 from attribute testedField   at: Test6.bar (Test6.java:18)
Got 2 requests:
    VMDeathEvent
Calling exit
</pre>

<p>Pov¹imnìte si zejména zpùsobu výpisu zpráv v&nbsp;pøípadì, ¾e se na jednom
programovém øádku ète aktuální hodnota atributu a souèasnì se zapisuje hodnota
nová. Jedná se pøedev¹ím o øádek <strong>Test6.java:6</strong>, který vypadá
následovnì:</p>

<pre>
this.testedField *= value;
</pre>

<p>Podobný význam (souèasné ètení i zápis nové hodnoty do sledovaného atributu)
by mìl napøíklad i podobný øádek:</p>

<pre>
this.testedField ++;
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Testovací tøída <strong>Test7</strong> &ndash; zápis shodné hodnoty, operátor ++ apod.</h2>

<p>Zkusme si nyní dne¹ní demonstraèní pøíklad
<strong>JDIWatchpointDemo3</strong> vyzkou¹et spustit proti nové testovací
tøídì <strong>Test7.java</strong>, kde se atribut ète èi zapisuje
v&nbsp;trojici metod. Pov¹imnìte si, ¾e v&nbsp;první metodì
<strong>foo()</strong> se stále zapisuje stejná konstanta, ve druhé metodì
<strong>bar()</strong> se pøièítá nula (tudí¾ se hodnota atributu nemìní, ov¹em
zápis se provádí) a ve tøetí metodì <strong>baz()</strong> se pou¾ívá operátor
++ pro ètení i zápis:</p>

<pre>
public class <strong>Test7</strong> {
&nbsp;
    int testedField = 1;
&nbsp;
    public void <strong>run</strong>() {
        foo();
        bar();
        baz();
    }
&nbsp;
    public void <strong>foo</strong>() {
        for (int i = 1; i &lt; 10; i++) {
            this.testedField = 0;
        }
    }
&nbsp;
    public void <strong>bar</strong>() {
        for (int i = 1; i &lt; 10; i++) {
            this.testedField += 0;
        }
    }
&nbsp;
    public void <strong>baz</strong>() {
        for (int i = 1; i &lt; 10; i++) {
            this.testedField++;
        }
    }
&nbsp;
    public static void <strong>main</strong>(String[] args) {
        System.out.println("Press any key");
        try {
            System.in.read();
        }
        catch (java.io.IOException e) {
            <i>// . //</i>
        }
        new Test7().run();
    }
&nbsp;
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Výstup generovaný demonstraèním pøíkladem <strong>JDIWatchPointDemo3</strong> pro tøídu <strong>Test7</strong></h2>

<p>Podívejme se nyní na výstup pøíkladu <strong>JDIWatchPointDemo3</strong> ve
chvíli, kdy je spu¹tìn oproti tøídì <strong>Test7</strong> v&nbsp;monitorovaném
virtuálním stroji Javy:</p>

<pre>
Connecting to virtual machine
Connected
Number of classes with name 'Test7': 1
Test7.testedField
Number of classes with name 'Test7': 1
Test7.testedField
Got 1 request:
    overwrite value 0 in attribute testedField by new value 1  at: Test7.<init> (Test7.java:3)
Got 1 request:
    overwrite value 1 in attribute testedField by new value 0  at: Test7.foo (Test7.java:13)
Got 1 request:
    overwrite value 0 in attribute testedField by new value 0  at: Test7.foo (Test7.java:13)
Got 1 request:
    overwrite value 0 in attribute testedField by new value 0  at: Test7.foo (Test7.java:13)
Got 1 request:
    overwrite value 0 in attribute testedField by new value 0  at: Test7.foo (Test7.java:13)
Got 1 request:
    overwrite value 0 in attribute testedField by new value 0  at: Test7.foo (Test7.java:13)
Got 1 request:
    overwrite value 0 in attribute testedField by new value 0  at: Test7.foo (Test7.java:13)
Got 1 request:
    overwrite value 0 in attribute testedField by new value 0  at: Test7.foo (Test7.java:13)
Got 1 request:
    overwrite value 0 in attribute testedField by new value 0  at: Test7.foo (Test7.java:13)
Got 1 request:
    overwrite value 0 in attribute testedField by new value 0  at: Test7.foo (Test7.java:13)
Got 1 request:
    read value 0 from attribute testedField   at: Test7.bar (Test7.java:19)
Got 1 request:
    overwrite value 0 in attribute testedField by new value 0  at: Test7.bar (Test7.java:19)
Got 1 request:
    read value 0 from attribute testedField   at: Test7.bar (Test7.java:19)
Got 1 request:
    overwrite value 0 in attribute testedField by new value 0  at: Test7.bar (Test7.java:19)
Got 1 request:
    read value 0 from attribute testedField   at: Test7.bar (Test7.java:19)
Got 1 request:
    overwrite value 0 in attribute testedField by new value 0  at: Test7.bar (Test7.java:19)
Got 1 request:
    read value 0 from attribute testedField   at: Test7.bar (Test7.java:19)
Got 1 request:
    overwrite value 0 in attribute testedField by new value 0  at: Test7.bar (Test7.java:19)
Got 1 request:
    read value 0 from attribute testedField   at: Test7.bar (Test7.java:19)
Got 1 request:
    overwrite value 0 in attribute testedField by new value 0  at: Test7.bar (Test7.java:19)
Got 1 request:
    read value 0 from attribute testedField   at: Test7.bar (Test7.java:19)
Got 1 request:
    overwrite value 0 in attribute testedField by new value 0  at: Test7.bar (Test7.java:19)
Got 1 request:
    read value 0 from attribute testedField   at: Test7.bar (Test7.java:19)
Got 1 request:
    overwrite value 0 in attribute testedField by new value 0  at: Test7.bar (Test7.java:19)
Got 1 request:
    read value 0 from attribute testedField   at: Test7.bar (Test7.java:19)
Got 1 request:
    overwrite value 0 in attribute testedField by new value 0  at: Test7.bar (Test7.java:19)
Got 1 request:
    read value 0 from attribute testedField   at: Test7.bar (Test7.java:19)
Got 1 request:
    overwrite value 0 in attribute testedField by new value 0  at: Test7.bar (Test7.java:19)
Got 1 request:
    read value 0 from attribute testedField   at: Test7.baz (Test7.java:25)
Got 1 request:
    overwrite value 0 in attribute testedField by new value 1  at: Test7.baz (Test7.java:25)
Got 1 request:
    read value 1 from attribute testedField   at: Test7.baz (Test7.java:25)
Got 1 request:
    overwrite value 1 in attribute testedField by new value 2  at: Test7.baz (Test7.java:25)
Got 1 request:
    read value 2 from attribute testedField   at: Test7.baz (Test7.java:25)
Got 1 request:
    overwrite value 2 in attribute testedField by new value 3  at: Test7.baz (Test7.java:25)
Got 1 request:
    read value 3 from attribute testedField   at: Test7.baz (Test7.java:25)
Got 1 request:
    overwrite value 3 in attribute testedField by new value 4  at: Test7.baz (Test7.java:25)
Got 1 request:
    read value 4 from attribute testedField   at: Test7.baz (Test7.java:25)
Got 1 request:
    overwrite value 4 in attribute testedField by new value 5  at: Test7.baz (Test7.java:25)
Got 1 request:
    read value 5 from attribute testedField   at: Test7.baz (Test7.java:25)
Got 1 request:
    overwrite value 5 in attribute testedField by new value 6  at: Test7.baz (Test7.java:25)
Got 1 request:
    read value 6 from attribute testedField   at: Test7.baz (Test7.java:25)
Got 1 request:
    overwrite value 6 in attribute testedField by new value 7  at: Test7.baz (Test7.java:25)
Got 1 request:
    read value 7 from attribute testedField   at: Test7.baz (Test7.java:25)
Got 1 request:
    overwrite value 7 in attribute testedField by new value 8  at: Test7.baz (Test7.java:25)
Got 1 request:
    read value 8 from attribute testedField   at: Test7.baz (Test7.java:25)
Got 1 request:
    overwrite value 8 in attribute testedField by new value 9  at: Test7.baz (Test7.java:25)
Got 2 requests:
    VMDeathEvent
Calling exit
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Repositáø se zdrojovými kódy demonstraèního pøíkladu</h2>

<p>Zdrojové kódy demonstraèního pøíkladu
<strong>JDIWatchPointDemo3.java</strong> jsou spoleènì s&nbsp;dal¹ími pomocnými
soubory ulo¾eny do Mercurial repositáøe dostupného na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
V&nbsp;následující tabulce najdete odkazy na prozatím nejnovìj¹í verze tìchto
zdrojových kódù:</p>

<table>
<tr><th>#</th><th>Zdrojový soubor/skript</th><th>Umístìní souboru v&nbsp;repositáøi</th></tr>
<tr><td>1</td><td>JDIWatchPointDemo3.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e48b9b41a61c/jdi/JDIWatchPointDemo3.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e48b9b41a61c/jdi/JDIWatchPointDemo3.java</a></td></tr>
<tr><td>2</td><td>compile_JDIWatchpointDemo3.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e48b9b41a61c/jdi/compile_JDIWatchpointDemo3.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e48b9b41a61c/jdi/compile_JDIWatchpointDemo3.sh</a></td></tr>
<tr><td>3</td><td>Test6.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/64baaf2ff0df/jdi/Test6.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/64baaf2ff0df/jdi/Test6.java</a></td></tr>
<tr><td>4</td><td>Test6.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/64baaf2ff0df/jdi/Test6.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/64baaf2ff0df/jdi/Test6.sh</a></td></tr>
<tr><td>5</td><td>Test7.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e48b9b41a61c/jdi/Test7.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e48b9b41a61c/jdi/Test7.java</a></td></tr>
<tr><td>6</td><td>Test7.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e48b9b41a61c/jdi/Test7.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e48b9b41a61c/jdi/Test7.sh/a></td></tr>
</table>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>Class com.sun.jdi.Bootstrap<br />
<a href="http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/package-tree.html">http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/package-tree.html</a>
</li>

<li>Interface com.sun.jdi.VirtualMachine<br />
<a href="http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/VirtualMachine.html">http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/VirtualMachine.html</a>
</li>

<li>Interface com.sun.jdi.Field<br />
<a href="http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/Field.html">http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/Field.html</a>
</li>

<li>Interface com.sun.jdi.ReferenceType<br />
<a href="http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/ReferenceType.html">http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/ReferenceType.html</a>
</li>

<li>Interface com.sun.jdi.TypeComponent<br />
<a href="http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/TypeComponent.html">http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/TypeComponent.html</a>
</li>

<li>Interface com.sun.jdi.Accessible<br />
<a href="http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/Accessible.html">http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/Accessible.html</a>
</li>

<li>Breakpoint (Wikipedia)<br />
<a href="http://cs.wikipedia.org/wiki/Breakpoint">http://cs.wikipedia.org/wiki/Breakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation<br />
<a href="http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html">http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; SetBreakpoint<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#SetBreakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#SetBreakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; ClearBreakpoint<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#ClearBreakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#ClearBreakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; Breakpoint (callback funkce)<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#Breakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#Breakpoint</a>
</li>

<li>The JVM Tool Interface (JVM TI): How VM Agents Work<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html">http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html</a>
</li>

<li>Creating a Debugging and Profiling Agent with JVMTI<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html">http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html</a>
</li>

<li>JVM TI (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/JVM_TI">http://en.wikipedia.org/wiki/JVM_TI</a>
</li>

<li>IBM JVMTI extensions<br />
<a href="http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html">http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

