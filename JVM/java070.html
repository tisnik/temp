<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - vyu¾ití rozhraní JNI spoleènì s rozhraním JVM TI</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - vyu¾ití rozhraní JNI spoleènì s rozhraním JVM TI</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyku Java i o virtuálním stroji Javy si uká¾eme zpùsob vyu¾ití rozhraní JNI (Java Native Interface) z JVM TI agentù. JVM TI agenti, co¾ jsou programy napsané vìt¹inou v C èi C++, toti¾ v nìkterých pøípadech potøebují s vyu¾itím JNI vytváøet javovské objekty, popø. volat metody ji¾ vytvoøených javovských objektù.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - vyu¾ití rozhraní JNI spoleènì s rozhraním JVM TI</a></p>
<p><a href="#k02">2. Tøicátý pátý demonstraèní JVM TI agent &ndash; jeden ze zpùsobù øe¹ení JAR Hellu :-)</a></p>
<p><a href="#k03">3. Callback funkce <strong>callback_on_class_prepare()</strong></a></p>
<p><a href="#k04">4. U¾ivatelská funkce <strong>print_class_info()</strong></a></p>
<p><a href="#k05">5. U¾ivatelská funkce <strong>print_class_loader()</strong></a></p>
<p><a href="#k06">6. U¾ivatelská funkce <strong>print_path_to_class()</strong></a></p>
<p><a href="#k07">7. Zdrojový soubor Test35.java obsahující tøídy a rozhraní nazvaná Test35, A, B a C</a></p>
<p><a href="#k08">8. Spu¹tìní 35.demonstraèního agenta spoleènì s&nbsp;tøídou Test35</a></p>
<p><a href="#k09">9. Spu¹tìní tøídy Test35 z&nbsp;Java archivu (JAR)</a></p>
<p><a href="#k10">10. Zdrojové kódy 35.demonstraèního agenta i k&nbsp;nìmu pøíslu¹ných testovacích pøíkladù a skriptù</a></p>
<p><a href="#k11">11. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - vyu¾ití rozhraní JNI spoleènì s rozhraním JVM TI</h2>

<p>V&nbsp;pøedchozích èástech <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyku Java i o virtuálním stroji Javy</a> jsme se pøi popisu
callback funkcí volaných <i>JVM TI</i> rozhraním setkali s&nbsp;tím, ¾e se do
tìchto funkcí pøedávají minimálnì dva ukazatele. První z&nbsp;tìchto ukazatelù
je typu <strong>jvmtiEnv*</strong> a jde o vstupní bod ke v¹em funkcím rozhraní
<i>JVM TI</i>, zatímco druhý ukazatel je typu <strong>JNIEnv*</strong> a
s&nbsp;jeho vyu¾itím lze volat funkce nabízené rozhraním <i>JNI (Java Native
Interface)</i>. Toto rozhraní se v&nbsp;<i>JVM TI</i> agentech mù¾e vyu¾ívat
rùzným zpùsobem, zejména v¹ak pro vytváøení javovských objektù a volání metod
tìchto objektù. V&nbsp;tomto seriálu jsme si toti¾ ji¾ popsali prakticky
ve¹kerou funkcionalitu rozhraní <i>JVM TI</i>, ov¹em pøímou manipulací
s&nbsp;javovskými objekty jsme se nezabývali &ndash; a ani nemohli, proto¾e
<i>JVM TI</i> neduplikuje funkce, které jsou nabízené právì <i>JNI</i>.</p>

<p>Vìt¹ina vývojáøù, kteøí se z&nbsp;rozhraním <i>JNI</i> setkali, vyu¾ívala
toto rozhraní k&nbsp;volání nativních funkcí/metod z&nbsp;Javy, co¾ napøíklad
umo¾òuje naèíst a posléze pøímo z&nbsp;Javy vyu¾ívat prakticky jakoukoli
nainstalovanou nativní knihovnu. My ov¹em budeme <i>JNI</i> pou¾ívat pøesnì
opaèným zpùsobem &ndash; budeme volat funkce tohoto rozhraní z&nbsp;céèka tak,
abychom napodobili manipulaci s&nbsp;objekty v&nbsp;Javì. V&nbsp;dal¹ích
kapitolách se setkáme s&nbsp;následujícími funkcemi rozhraní <i>JNI</i>:</p>

<table>
<tr><th>#</th><th>Funkce <i>JNI</i></th><th>Význam</th></tr>
<tr><td>1</td><td>FindClass()            </td><td>nalezení tøídy na základì její plné signatury</td></tr>
<tr><td>2</td><td>GetMethodID()          </td><td>získání nestatické metody na základì jejího jména, signatury a tøídy</td></tr>
<tr><td>3</td><td>CallObjectMethod()     </td><td>zavolání metody s pøedáním parametrù a získáním výsledku</td></tr>
<tr><td>4</td><td>NewStringUTF           </td><td>vytvoøení instance tøídy java.lang.String s inicializací céèkovým øetìzcem</td></tr>
<tr><td>5</td><td>GetStringUTFChars()    </td><td>pøevod mezi java.lang.String a céèkovým øetìzcem</td></tr>
<tr><td>6</td><td>ReleaseStringUTFChars()</td><td>uvolnìní instance tøídy java.lang.String</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Tøicátý pátý demonstraèní JVM TI agent &ndash; jeden ze zpùsobù øe¹ení JAR Hellu :-)</h2>

<p>Zpùsob vyu¾ití funkcí nabízených rozhraním <i>JNI</i> si uká¾eme
v&nbsp;tøicátém pátém demonstraèním <i>JVM TI</i> agentovi na výpisu souborù
(streamù), z&nbsp;nich¾ jsou získávány bajtkódy tøíd naèítaných do virtuálního
stroje Javy. Pøipomeòme si, ¾e v&nbsp;JVM se naèítání tøíd (pøesnìji øeèeno
jejich bajtkódù) provádí pøes takzvané <i>classloadery</i>, pøièem¾ pøímo
v&nbsp;JVM je implementován takzvaný <i>bootstrap classloader</i> pou¾itý pro
naèítání &bdquo;systémových&ldquo; tøíd a dal¹í classloadery se ji¾ mohou
inicializovat právì s&nbsp;vyu¾itím bootstrap classloaderu. Bajtkódy tøíd jsou
vìt¹inou naèítány pøímo ze souborù <strong>.class</strong>, které jsou hledány
v&nbsp;adresáøích specifikovaných v&nbsp;promìnné prostøedí
<strong>CLASSPATH</strong>, popø.&nbsp;definovaných pøi startu virtuálního
stroje (pøepínaè <strong>-cp</strong>). Ve skuteènosti se v¹ak mohou bajtkódy
naèítat i z&nbsp;dal¹ích míst, napøíklad z&nbsp;Java archivù (soubory
s&nbsp;koncovkou .jar), bajtkód lze pøenést i pøes sí»ové rozhraní atd.</p>

<p>V&nbsp;nìkterých pøípadech &ndash; a mo¾ná èastìji, ne¾ je zdrávo :-)
&ndash; mù¾e dojít k&nbsp;situaci, kdy je do virtuálního stroje Javy naèítána
stejná tøída, která mù¾e být napøíklad ulo¾ena v&nbsp;rùzných Java archivech
&ndash; programátor èi administrátor napøíklad nasazuje aplikaci na aplikaèní
server, v&nbsp;nìm¾ je ji¾ nainstalována jiná verze stejné knihovny atd.
V&nbsp;tìchto situacích zále¾í chování aplikace na mnoha okolnostech a
v&nbsp;pøípadì, ¾e se aplikace chová jinak, ne¾ pøi vývoji, je vhodné získat
informace o tom, jaké tøídy a s&nbsp;vyu¾itím jakých classloaderù se naèítají.
Nìkteré z&nbsp;tìchto informací lze získat s&nbsp;vyu¾itím pøepínaèe
<strong>-verbose:class</strong>, ov¹em zde se ji¾ nevypí¹e, s&nbsp;vyu¾itím
jakého classloaderu se daná tøída naèítá. A právì zde se mù¾e &ndash;
samozøejmì kromì dal¹ích sofistikovanìj¹ích nástrojù &ndash; pou¾ít i ná¹
demonstraèní <i>JVM TI</i> agent popsaný v&nbsp;následujících kapitolách.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Callback funkce <strong>callback_on_class_prepare()</strong></h2>

<p>I&nbsp;v&nbsp;tøicátém pátém demonstraèním <i>JVM TI</i> agentovi je,
podobnì jako i v&nbsp;nìkolika agentech popsaných v&nbsp;pøedchozích dílech
tohoto seriálu, zaregistrována callback funkce nazvaná
<strong>callback_on_class_prepare()</strong>, která je zavolána ve chvíli, kdy
je do virtuálního stroje Javy naèítána nìjaká tøída a kdy je zpracován její
bajtkód (dùle¾ité pro nás je, ¾e tøída je ji¾ ve chvíli volání funkce
<strong>callback_on_class_prepare()</strong> skuteènì naètena, proto¾e nad ní
budeme provádìt dal¹í operace). V&nbsp;této callback funkci se nejprve pøes
rozhraní <i>JVM TI</i> získá signatura tøídy, která je následnì upravena do
èitelné podoby. Posléze je zavolána u¾ivatelská funkce nazvaná
<strong>print_class_info()</strong>, která bude podrobnìji popsána <a
href="#k04">v&nbsp;následující kapitole</a>:</p>

<pre>
<i>/*</i>
<i> * Callback funkce zavolana ve chvili, kdy je trida ve virtualnim stroji ve stavu,</i>
<i> * kdy ji lze normalne pouzivat.</i>
<i> */</i>
static void JNICALL <strong>callback_on_class_prepare</strong>(
        jvmtiEnv *jvmti_env,
        JNIEnv   *jni_env,
        jthread   thread,
        jclass    class)
{
    jvmtiError error;
    char *class_name_ptr;
    char *updated_class_name_ptr;
&nbsp;
    enter_critical_section(jvmti_env);
&nbsp;
<i>    /* ziskat jmeno tridy */</i>
    error = (*jvmti_env)-&gt;<strong>GetClassSignature</strong>(jvmti_env, class, &amp;class_name_ptr, NULL);
    check_jvmti_error(jvmti_env, error, "get class signature");
    if (class_name_ptr == NULL)
    {
        puts("Error: class has no signature");
    }
&nbsp;
<i>    /* upravit jmeno tridy */</i>
    updated_class_name_ptr = update_class_name(class_name_ptr);
&nbsp;
<i>    /* vypsat informace o classloaderu a streamu, z nehoz je nacten bajtkod tridy */</i>
    <strong>print_class_info</strong>(jvmti_env, jni_env, class, updated_class_name_ptr);
&nbsp;
<i>    /* dealokace pameti po GetClassSignature() */</i>
    error = (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char *)class_name_ptr);
    check_jvmti_error(jvmti_env, error, "deallocate class name");
    exit_critical_section(jvmti_env);
}
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. U¾ivatelská funkce <strong>print_class_info()</strong></h2>

<p>U¾ivatelská funkce <strong>print_class_info()</strong> je volána
z&nbsp;callback funkce <strong>callback_on_class_prepare()</strong> popsané <a
href="#k03">ve tøetí kapitole</a>. V&nbsp;této funkci nejdøíve získáme
classloader pro tøídu specifikovanou hodnotou typu <strong>jclass</strong>. Pro
získání classloaderu slou¾í <i>JVM TI</i> funkce
<strong>GetClassLoader()</strong>, které se musí ve druhém parametru pøedat
ukazatel na promìnnou typu <strong>jobject</strong>. Pøes tento ukazatel je buï
vrácen pøíslu¹ný classloader, nebo se vrátí hodnota <strong>NULL</strong>, a to
tehdy, pokud je tøída naèítána bootstrap classloaderem (jedná se tedy vìt¹inou
o &bdquo;systémovou&ldquo; tøídu). Ve chvíli, kdy je skuteènì získán
classloader, jsou zavolány dal¹í dvì u¾ivatelské funkce
<strong>print_class_loader()</strong> (<a href="#k05">kapitola 5</a>) a
<strong>print_path_to_class()</strong> (<a href="#k06">kapitola 6</a>). Získaný
classloader by mìl být explicitnì uvolnìn pomocí JNI funkce
<strong>DeleteLocalRef()</strong>, proto¾e se jedná o takzvanou lokální
referenci. Ve skuteènosti to ov¹em nemusí být nutné, jeliko¾ se JVM postará o
automatické uvolnìní a¾ ¹estnácti lokálních referencí v&nbsp;jednom vláknu:</p>

<pre>
<i>/*</i>
<i> * Tisk informaci o nactene tride: classloaderu a ceste ke streamu</i>
<i> * z nehoz se nacita bajtkod</i>
<i> */</i>
static void <strong>print_class_info</strong>(
            jvmtiEnv *jvmti_env,
            JNIEnv   *jni_env,
            jclass    class,
            char     *class_name)
{
    jobject class_loader = NULL;
<i>    /* ziskani classloaderu tridy */</i>
    (*jvmti_env)-&gt;<strong>GetClassLoader</strong>(jvmti_env, class, &amp;class_loader);
&nbsp;
<i>    /* bootstrap classloader slouzi vetsinou k nacteni trid ulozenych v rt.jar */</i>
    if (class_loader == NULL)
    {
        printf("%-50s bootstrap classloader\n", class_name);
    }
    else
    {
        <strong>print_class_loader</strong>(jvmti_env, jni_env, class_loader, class_name);
        <strong>print_path_to_class</strong>(jvmti_env, jni_env, class_loader, class_name);
    }
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. U¾ivatelská funkce <strong>print_class_loader()</strong></h2>

<p>Ve funkci <strong>print_class_loader()</strong> se ji¾ setkáme s&nbsp;pøímým
vyu¾itím rozhraní <i>JNI</i>. Jedná se pøedev¹ím o funkci
<strong>GetMethodID()</strong> slou¾ící pro získání metody se zadaným jménem,
signaturou a tøídou, dále pak o funkci <strong>FindClass()</strong> slou¾ící
pro nalezení tøídy specifikované svým jménem, funkci
<strong>CallObjectMethod()</strong>, která doká¾e zavolat nalezenou metodu a
pøedat jí parametry a nakonec o dvojici funkcí
<strong>GetStringUTFChars()</strong> a <strong>ReleaseStringUTFChars()</strong>
slou¾ících pro manipulaci s&nbsp;øetìzci (je toti¾ rozdíl pracovat
s&nbsp;øetìzci virtuálního stroje Javy a øetìzci céèkovými). V¹e, co
u¾ivatelská funkce <strong>print_class_loader()</strong> dìlá, by se
v&nbsp;Javì dalo shrnout do jediného øádku:</p>

<pre>
System.out.println(java.lang.ClassLoader.toString());
</pre>

<p>V&nbsp;<i>JVM TI</i> agentovi ov¹em musíme tento kód pøepsat do volání
funkcí rozhraní <i>JNI</i>, co¾ je ji¾ docela zdlouhavé:</p>

<pre>
<i>/*</i>
<i> * Vypis classloaderu spjateho s konkretni Javovskou tridou.</i>
<i> */</i>
static void <strong>print_class_loader</strong>(
            jvmtiEnv *jvmti_env,
            JNIEnv   *jni_env,
            jclass    class_loader,
            char     *class_name)
{
<i>    /* nalezeni metody java.lang.ClassLoader.toString() */</i>
    jmethodID to_string = (*jni_env)-&gt;<strong>GetMethodID</strong>(jni_env, (*jni_env)-&gt;<strong>FindClass</strong>(jni_env, "java/lang/ClassLoader"), "toString", "()Ljava/lang/String;" );
    if (to_string ==  NULL)
    {
        MSG("can not find method ClassLoader.toString()");
        return;
    }
&nbsp;
<i>    /* zavolani metody java.lang.ClassLoader.toString() */</i>
    jstring jstr = (jstring)(*jni_env)-&gt;<strong>CallObjectMethod</strong>(jni_env, class_loader, to_string);
    if (jstr ==  NULL)
    {
        MSG("can not call method ClassLoader.toString()");
        return;
    }
&nbsp;
<i>    /* prevod objektu typu jstring na ceckovy retezec */</i>
    char *str = (char*)(*jni_env)-&gt;<strong>GetStringUTFChars</strong>(jni_env, jstr, NULL);
    printf("%-50s other classloader %s\n", class_name, str);
&nbsp;
<i>    /* uvolneni alokovane pameti */</i>
    (*jni_env)-&gt;<strong>ReleaseStringUTFChars</strong>(jni_env, jstr, str);
}
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. U¾ivatelská funkce <strong>print_path_to_class()</strong></h2>

<p>Dal¹í u¾ivatelská funkce nazvaná <strong>print_path_to_class()</strong> má
za úkol vypsat na standardní výstup cestu k&nbsp;souboru (èi korektnìji øeèeno
ke streamu), z&nbsp;nìho¾ byl získán bajtkód pøedstavující naèítanou tøídu.
Ekvivalentem kódu implementovaného v&nbsp;této funkci je následující øádek
v&nbsp;Javì:</p>

<pre>
System.out.println(java.lang.ClassLoader.getResource(className+".class").toExternalForm());
</pre>

<p>Zajisté ji¾ tu¹íte, ¾e céèkový ekvivalent vyu¾ívající rozhraní <i>JNI</i>
tak struèný nebude :-) Skuteènì je tomu tak, nebo» je nejprve nutné vytvoøit
øetìzec obsahující <strong>className+".class</strong>, následnì získat metodu
<strong>ClassLoader.getResource()</strong>, zavolat tuto metodu a pøedat jí
vytvoøený øetìzec (ov¹em pøevedený na jinou formu) a následnì zpracovat
výsledek této metody, co¾ je objekt typu java.net.URL. Nad tímto objektem je
toti¾ nutné zavolat metodu <strong>toExternalForm()</strong> a vypsat její
návratovou hodnotu (øetìzec) na standardní výstup, samozøejmì opìt
s&nbsp;konverzí mezi øetìzci JVM a céèkovými øetìzci:</p>

<pre>
<i>/*</i>
<i> * Vypis cesty k souboru (streamu), z nehoz je nacitan bajtkod tridy.</i>
<i> */</i>
static void <strong>print_path_to_class</strong>(
            jvmtiEnv *jvmti_env,
            JNIEnv   *jni_env,
            jclass    class_loader,
            char     *class_name)
{
<i>    /* ze jmena tridy "Trida" potrebujeme vytvorit retezec "Trida.class" */</i>
    char *upd_class_name = (char*)malloc(strlen(class_name)+7);
    strcpy(upd_class_name, class_name);
    strcat(upd_class_name, ".class");
&nbsp;
<i>    /* nalezeni metody java.lang.ClassLoader.getResource() */</i>
    jmethodID get_resource = (*jni_env)-&gt;<strong>GetMethodID</strong>(jni_env, (*jni_env)-&gt;<strong>FindClass</strong>(jni_env, "java/lang/ClassLoader"), "getResource", "(Ljava/lang/String;)Ljava/net/URL;" );
    if (get_resource ==  NULL)
    {
        MSG("can not find method ClassLoader.getResource()");
        return;
    }
&nbsp;
<i>    /* zavolani metody java.lang.ClassLoader.getResource() */</i>
    jobject url = (*jni_env)-&gt;<strong>CallObjectMethod</strong>(jni_env, class_loader, get_resource, (*jni_env)-&gt;<strong>NewStringUTF</strong>(jni_env, upd_class_name));
    if (url ==  NULL)
    {
        MSG("can not call method ClassLoader.getResource()");
        return;
    }
&nbsp;
<i>    /* nalezeni metody java.net.URL.toExternalForm() */</i>
    jmethodID to_external_form = (*jni_env)-&gt;<strong>GetMethodID</strong>(jni_env, (*jni_env)-&gt;<strong>FindClass</strong>(jni_env, "java/net/URL"), "toExternalForm", "()Ljava/lang/String;" );
    if (to_external_form ==  NULL)
    {
        MSG("can not find method URL.toExternalForm()");
        return;
    }
&nbsp;
<i>    /* zavolani metody java.net.URL.toExternalForm() */</i>
    jstring jstr = (jstring)(*jni_env)-&gt;<strong>CallObjectMethod</strong>(jni_env, url, to_external_form);
    if (jstr ==  NULL)
    {
        MSG("can not call method URL.toExternalForm()");
        return;
    }
&nbsp;
<i>    /* prevod objektu typu jstring na ceckovy retezec */</i>
    char *str = (char*)(*jni_env)-&gt;<strong>GetStringUTFChars</strong>(jni_env, jstr, NULL);
    printf("Class %s is loaded from: %s\n", upd_class_name, str);
&nbsp;
<i>    /* uvolneni alokovane pameti */</i>
    (*jni_env)-&gt;<strong>ReleaseStringUTFChars</strong>(jni_env, jstr, str);
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Zdrojový soubor Test35.java obsahující tøídy a rozhraní nazvané Test35, A, B a C</h2>

<p>Pro otestování správné funkce tøicátého pátého demonstraèního <i>JVM TI</i>
agenta byl vytvoøen javovský zdrojový soubor nazvaný
<strong>Test35.java</strong>. Internì je tento zdrojový soubor pomìrnì
komplikovaný proto¾e je v&nbsp;nìm definována veøejná tøída
<strong>Test35</strong>, neveøejná tøída <strong>A</strong>, statická vnitøní
tøída <strong>B</strong> a takté¾ neveøejné rozhraní <strong>C</strong>.
V&nbsp;tomto rozhraní je pøedepsána metoda <strong>void foo()</strong> a
rozhraní je implementováno v&nbsp;<i>anonymní tøídì</i> vytvoøené pøímo
v&nbsp;metodì <strong>main()</strong>.</p>

<p>Po pøekladu tohoto zdrojového kódu získáme následující soubory
s&nbsp;bajtkódem:</p>

<table>
<tr><th>#</th><th>Tøída/rozhraní</th><th>Bajtkód ulo¾en v souboru</th></tr>
<tr><td>1</td><td>Tøída <strong>Test35</strong></td><td>Test35.class</td></tr>
<tr><td>2</td><td>Tøída <strong>A</strong></td><td>A.class</td></tr>
<tr><td>3</td><td>Vnitøní tøída <strong>B</strong></td><td>Test35$B.class</td></tr>
<tr><td>4</td><td>Rozhraní <strong>C</strong></td><td>C.class</td></tr>
<tr><td>5</td><td>Anonymní tøída implementující <strong>C</strong></td><td>Test35$1.class</td></tr>
</table>

<p>Pod tímto odstavcem je vypsán obsah zdrojového textu
<strong>Test35.java</strong>:</p>

<pre>
import java.awt.Color;
import java.util.*;
&nbsp;
<strong>interface C</strong> {
    void foo();
}
&nbsp;
<strong>class A</strong> {
}
&nbsp;
<i>/**</i>
<i>  * Testovaci trida pouzita pro test tricateho</i>
<i>  * pateho demonstracniho JVM TI agenta.</i>
<i>  *</i>
<i>  * Trida obsahuje nekolik metod s ruznym poctem</i>
<i>  * a typy lokalnich promennych.</i>
<i>  */</i>
<strong>public class Test35</strong> {
&nbsp;
    <strong>static class B</strong> {
    }
&nbsp;
    private void method1() {
    }
&nbsp;
    private void method2() {
        int x = 0;
    }
&nbsp;
    private void method3() {
        int x = 1;
        int y = 2;
    }
&nbsp;
    private void method4() {
        byte    byte_variable = 1;
        short   short_variable = 2;
        int     int_variable = 3;
        long    long_variable = 4;
    }
&nbsp;
    private void method5() {
        char    char_variable = 'a';
        float   float_variable = 1/2f;
        double  double_variable = 1/2.0;
        boolean boolean_variable = true;
    }
&nbsp;
    private void method6() {
        int[]   int_array = null;
        float[] float_array = null;
        int[][] int_matrix = null;
    }
&nbsp;
    private void method7() {
        String  str = null;
        Color   color = null;
        Color[] colors = null;
    }
&nbsp;
    private void method8() {
        List&lt;String&gt;       list = null;
        Set&lt;Integer&gt;       set = null;
        Map&lt;Float, String&gt; map = null;
        Queue&lt;Color&gt;       queue = null;
        Deque&lt;String&gt;      double_ended_queue = null;
    }
&nbsp;
    private void method9(int x, float y, boolean z) {
        List&lt;String&gt;       list = null;
        Set&lt;Integer&gt;       set = null;
        Map&lt;Float, String&gt; map = null;
        Queue&lt;Color&gt;       queue = null;
        Deque&lt;String&gt;      double_ended_queue = null;
    }
&nbsp;
    private static void static_method1() {
    }
&nbsp;
    private static void static_method2() {
        int x = 0;
    }
&nbsp;
    private static void static_method3() {
        int x = 1;
        int y = 2;
    }
&nbsp;
    private static void static_method4() {
        byte    byte_variable = 1;
        short   short_variable = 2;
        int     int_variable = 3;
        long    long_variable = 4;
    }
&nbsp;
    private static void static_method5() {
        char    char_variable = 'a';
        float   float_variable = 1/2f;
        double  double_variable = 1/2.0;
        boolean boolean_variable = true;
    }
&nbsp;
    private static void static_method6() {
        int[]   int_array = null;
        float[] float_array = null;
        int[][] int_matrix = null;
    }
&nbsp;
    private static void static_method7() {
        String  str = null;
        Color   color = null;
        Color[] colors = null;
    }
&nbsp;
    private static void static_method8() {
        List&lt;String&gt;       list = null;
        Set&lt;Integer&gt;       set = null;
        Map&lt;Float, String&gt; map = null;
        Queue&lt;Color&gt;       queue = null;
        Deque&lt;String&gt;      double_ended_queue = null;
    }
&nbsp;
    private static void static_method9(int x, float y, boolean z) {
        List&lt;String&gt;       list = null;
        Set&lt;Integer&gt;       set = null;
        Map&lt;Float, String&gt; map = null;
        Queue&lt;Color&gt;       queue = null;
        Deque&lt;String&gt;      double_ended_queue = null;
    }
&nbsp;
<i>    /**</i>
<i>      * Spusteni testu.</i>
<i>      */</i>
    public static void main(String[] args) {
        new A();
        new B();
        <strong>C c = new C()</strong> {
            public void foo() {
                System.out.println("foo");
            }
        };
    }
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Spu¹tìní 35.demonstraèního agenta spoleènì s&nbsp;tøídou Test35</h2>

<p>Pøeklad tøicátého pátého demonstraèního <i>JVM TI</i> agenta se provede
pøíkazem:</p>

<pre>
gcc -Wall -ansi -I/usr/lib/jvm/java-1.6.0-openjdk/include/ -shared -o libagent35.so agent35.c
</pre>

<p>Pøeklad testovacího zdrojového souboru <strong>Test35</strong> zajistí
jednodu¹e pøíkaz (volba <strong>-g</strong> zde není ve skuteènosti nutná):</p>

<pre>
javac -g Test35.java
</pre>

<p>Po pøekladu se vytvoøí nìkolik souborù <strong>.class</strong>
s&nbsp;bajtkódem, jejich¾ obsah byl vysvìtlen <a href="#k07">v&nbsp;pøedchozí
kapitole</a>. Nyní ji¾ mù¾eme demonstraèního agenta spustit, a to konkrétnì
pøíkazem:</p>

<pre>
java -agentpath:./libagent35.so Test35 2&gt; /dev/null
</pre>

<p>Po spu¹tìní agenta by se na standardní výstup mìly vypsat následující øádky
(vysvìtlení jednotlivých zpráv hledejte na konci kapitoly):</p>

<pre>
Agent35: Agent_OnLoad
Agent35: JVM TI version is correct
Agent35: Got VM init event
java.lang.ClassNotFoundException                   bootstrap classloader
java.net.URLClassLoader$1                          bootstrap classloader
sun.misc.URLClassPath$3                            bootstrap classloader
sun.misc.URLClassPath$Loader                       bootstrap classloader
sun.misc.URLClassPath$JarLoader                    bootstrap classloader
java.lang.StringBuffer                             bootstrap classloader
java.lang.Short                                    bootstrap classloader
sun.misc.URLClassPath$JarLoader$1                  bootstrap classloader
sun.misc.FileURLMapper                             bootstrap classloader
java.util.zip.ZipConstants                         bootstrap classloader
java.util.zip.ZipFile                              bootstrap classloader
java.util.jar.JarFile                              bootstrap classloader
...
...
...
<strong>Test35                                             other classloader sun.misc.Launcher$AppClassLoader@17182c1</strong>
sun.misc.Launcher$1                                bootstrap classloader
java.io.IOException                                bootstrap classloader
java.io.FileNotFoundException                      bootstrap classloader
java.net.URLClassLoader$2                          bootstrap classloader
<strong>Class Test35.class is loaded from: file:/home/pavel/temp/jvmti/Agent35/Test35.class</strong>
<strong>A                                                  other classloader sun.misc.Launcher$AppClassLoader@17182c1</strong>
<strong>Class A.class is loaded from: file:/home/pavel/temp/jvmti/Agent35/A.class</strong>
<strong>Test35$B                                           other classloader sun.misc.Launcher$AppClassLoader@17182c1</strong>
<strong>Class Test35$B.class is loaded from: file:/home/pavel/temp/jvmti/Agent35/Test35$B.class</strong>
<strong>C                                                  other classloader sun.misc.Launcher$AppClassLoader@17182c1</strong>
<strong>Class C.class is loaded from: file:/home/pavel/temp/jvmti/Agent35/C.class</strong>
<strong>Test35$1                                           other classloader sun.misc.Launcher$AppClassLoader@17182c1</strong>
<strong>Class Test35$1.class is loaded from: file:/home/pavel/temp/jvmti/Agent35/Test35$1.class</strong>
...
...
...
java.util.ArrayList$Itr                            bootstrap classloader
java.util.IdentityHashMap$KeySet                   bootstrap classloader
java.util.IdentityHashMap$IdentityHashMapIterator  bootstrap classloader
java.util.IdentityHashMap$KeyIterator              bootstrap classloader
java.io.DeleteOnExitHook                           bootstrap classloader
java.util.LinkedHashSet                            bootstrap classloader
java.util.HashMap$KeySet                           bootstrap classloader
java.util.LinkedHashMap$LinkedHashIterator         bootstrap classloader
java.util.LinkedHashMap$KeyIterator                bootstrap classloader
java.util.Collections                              bootstrap classloader
java.util.Collections$EmptySet                     bootstrap classloader
java.util.Collections$EmptyList                    bootstrap classloader
java.util.Collections$EmptyMap                     bootstrap classloader
Agent35: Got VM Death event
Agent35: Agent_OnUnload
</pre>

<p>V&nbsp;pøedchozím výpisu se objevily hned tøi zajímavé informace. První
z&nbsp;nich je, ¾e základní &bdquo;systémové&ldquo; tøídy jsou naèítané
bootstrap classloaderem, co¾ je oèekávaná vlastnost JVM (ne v¹echny virtuální
stroje Javy se ov¹em pøesnì takto chovají). Druhou informací je to, ¾e agent
skuteènì dokázal vypsat cesty k&nbsp;bajtkódùm, a to jak u tøíd, tak i u
rozhraní <strong>C</strong> (které se musí naèíst spoleènì s&nbsp;anonymní
tøídou <strong>Test35$1</strong>:</p>

<pre>
Class Test35.class is loaded from: file:/home/pavel/temp/jvmti/Agent35/Test35.class
Class A.class is loaded from: file:/home/pavel/temp/jvmti/Agent35/A.class
Class Test35$B.class is loaded from: file:/home/pavel/temp/jvmti/Agent35/Test35$B.class
Class C.class is loaded from: file:/home/pavel/temp/jvmti/Agent35/C.class
Class Test35$1.class is loaded from: file:/home/pavel/temp/jvmti/Agent35/Test35$1.class
</pre>

<p>Mo¾ná nejzajímavìj¹í informace je v¹ak skryta v&nbsp;øádcích:</p>

<pre>
<strong>Test35                                             other classloader sun.misc.Launcher$AppClassLoader@17182c1</strong>
sun.misc.Launcher$1                                bootstrap classloader
java.io.IOException                                bootstrap classloader
java.io.FileNotFoundException                      bootstrap classloader
java.net.URLClassLoader$2                          bootstrap classloader
<strong>Class Test35.class is loaded from: file:/home/pavel/temp/jvmti/Agent35/Test35.class</strong>
</pre>

<p>Mù¾eme zde vidìt, ¾e mezi výpisem zprávy o classloaderu tøídy
<strong>Test35</strong> a výpisem informace o tom, odkud byl naèten její
bajtkód, se &bdquo;magicky&ldquo; do virtuálního stroje Javy naèetly ètyøi
dal¹í tøídy. O toto naètení jsme se vlastnì postarali sami v&nbsp;<i>JVM TI</i>
agentovi, proto¾e se tyto tøídy pou¾ily pro získání streamu
s&nbsp;bajtkódem.</p>

<p>Poznámka: podobný výstup dostaneme i v&nbsp;pøípadì, ¾e se pøi startu
virtuálního stroje Javy pou¾ije pøepínaè <strong>-verbose:class</strong>:</p>

<pre>
[Loaded java.lang.Object from shared objects file]
[Loaded java.io.Serializable from shared objects file]
[Loaded java.lang.Comparable from shared objects file]
[Loaded java.lang.CharSequence from shared objects file]
[Loaded java.lang.String from shared objects file]
...
...
...
<strong>[Loaded Test35 from file:/home/pavel/temp/jvmti/Agent35/]</strong>
<strong>[Loaded A from file:/home/pavel/temp/jvmti/Agent35/]</strong>
<strong>[Loaded Test35$B from file:/home/pavel/temp/jvmti/Agent35/]</strong>
<strong>[Loaded C from file:/home/pavel/temp/jvmti/Agent35/]</strong>
<strong>[Loaded Test35$1 from file:/home/pavel/temp/jvmti/Agent35/]</strong>
...
...
...
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Spu¹tìní tøídy Test35 z&nbsp;Java archivu (JAR)</h2>

<p><a href="#k08">V&nbsp;pøedchozí kapitole</a> jsme mohli vidìt, jak se <i>JVM
TI</i> agent chová v&nbsp;pøípadì, ¾e jsou tøídy naèítány pøímo ze souborù
<strong>.class</strong>. Co se v¹ak stane v&nbsp;pøípadì, ¾e tøídy zabalíme do
Java archivu (JAR) pøíkazem:</p>

<pre>
jar cfe test.jar Test35 *.class
</pre>

<p>?</p>

<p>Je jisté, ¾e virtuální stroj Javy je nutné spou¹tìt ponìkud odli¹ným
zpùsobem, konkrétnì takto:</p>

<pre>
java -agentpath:./libagent35.so -jar test.jar Test35 2&gt; /dev/null
</pre>

<p>Virtuální stroj Javy bude v&nbsp;tomto pøípadì naèítat v¹ech pìt souborù
s&nbsp;bajtkódem z&nbsp;Java archivu nazvaného <strong>test.jar</strong> a
výpis provedený agentem se tedy bude oproti pøedchozímu výpisu odli¹ovat:</p>

<pre>
Agent35: Agent_OnLoad
Agent35: JVM TI version is correct
Agent35: Got VM init event
java.util.zip.ZipConstants                         bootstrap classloader
java.util.zip.ZipFile                              bootstrap classloader
java.util.jar.JarFile                              bootstrap classloader
sun.misc.JavaUtilJarAccess                         bootstrap classloader
java.util.jar.JavaUtilJarAccessImpl                bootstrap classloader
java.util.zip.ZipEntry                             bootstrap classloader
java.util.jar.JarEntry                             bootstrap classloader
java.util.jar.JarFile$JarFileEntry                 bootstrap classloader
java.io.DataInput                                  bootstrap classloader
java.io.DataInputStream                            bootstrap classloader
...
...
...
<strong>Test35                                             other classloader sun.misc.Launcher$AppClassLoader@13f5d07</strong>
sun.misc.Launcher$1                                bootstrap classloader
java.io.IOException                                bootstrap classloader
java.io.FileNotFoundException                      bootstrap classloader
java.net.URLClassLoader$2                          bootstrap classloader
<strong>Class Test35.class is loaded from: jar:file:/home/pavel/temp/jvmti/Agent35/test.jar!/Test35.class</strong>
<strong>A                                                  other classloader sun.misc.Launcher$AppClassLoader@13f5d07</strong>
<strong>Class A.class is loaded from: jar:file:/home/pavel/temp/jvmti/Agent35/test.jar!/A.class</strong>
<strong>Test35$B                                           other classloader sun.misc.Launcher$AppClassLoader@13f5d07</strong>
<strong>Class Test35$B.class is loaded from: jar:file:/home/pavel/temp/jvmti/Agent35/test.jar!/Test35$B.class</strong>
<strong>C                                                  other classloader sun.misc.Launcher$AppClassLoader@13f5d07</strong>
<strong>Class C.class is loaded from: jar:file:/home/pavel/temp/jvmti/Agent35/test.jar!/C.class</strong>
<strong>Test35$1                                           other classloader sun.misc.Launcher$AppClassLoader@13f5d07</strong>
<strong>Class Test35$1.class is loaded from: jar:file:/home/pavel/temp/jvmti/Agent35/test.jar!/Test35$1.class</strong>
java.util.ArrayList$Itr                            bootstrap classloader
java.util.IdentityHashMap$KeySet                   bootstrap classloader
java.util.IdentityHashMap$IdentityHashMapIterator  bootstrap classloader
java.util.IdentityHashMap$KeyIterator              bootstrap classloader
java.io.DeleteOnExitHook                           bootstrap classloader
java.util.LinkedHashSet                            bootstrap classloader
java.util.HashMap$KeySet                           bootstrap classloader
java.util.LinkedHashMap$LinkedHashIterator         bootstrap classloader
java.util.LinkedHashMap$KeyIterator                bootstrap classloader
java.util.Collections                              bootstrap classloader
java.util.Collections$EmptySet                     bootstrap classloader
java.util.Collections$EmptyList                    bootstrap classloader
java.util.Collections$EmptyMap                     bootstrap classloader
Agent35: Got VM Death event
Agent35: Agent_OnUnload
</pre>

<p>Podobný výstup získáme i pøi pou¾ití volby <strong>-verbose:class</strong>:</p>

<pre>
[Loaded java.lang.Object from shared objects file]
[Loaded java.io.Serializable from shared objects file]
[Loaded java.lang.Comparable from shared objects file]
[Loaded java.lang.CharSequence from shared objects file]
[Loaded java.lang.String from shared objects file]
...
...
...
<strong>[Loaded Test34 from file:/home/pavel/temp/jvmti/Agent35/test.jar]</strong>
<strong>[Loaded A from file:/home/pavel/temp/jvmti/Agent35/test.jar]</strong>
<strong>[Loaded Test34$B from file:/home/pavel/temp/jvmti/Agent35/test.jar]</strong>
<strong>[Loaded C from file:/home/pavel/temp/jvmti/Agent35/test.jar]</strong>
<strong>[Loaded Test34$1 from file:/home/pavel/temp/jvmti/Agent35/test.jar]</strong>
...
...
...
</pre>

<p>Porovnejme si nyní zprávy vypsané pøi spu¹tìní tøídy Test35 pøímo:</p>

<pre>
Class Test35.class is loaded from: file:/home/pavel/temp/jvmti/Agent35/Test35.class
Class A.class is loaded from: file:/home/pavel/temp/jvmti/Agent35/A.class
Class Test35$B.class is loaded from: file:/home/pavel/temp/jvmti/Agent35/Test35$B.class
Class C.class is loaded from: file:/home/pavel/temp/jvmti/Agent35/C.class
Class Test35$1.class is loaded from: file:/home/pavel/temp/jvmti/Agent35/Test35$1.class
</pre>

<p>...se zprávami vypsanými pøi spu¹tìní té¾e tøídy, ov¹em ulo¾ené v&nbsp;Java
archivu:</p>

<pre>
Class Test35.class is loaded from: jar:file:/home/pavel/temp/jvmti/Agent35/test.jar!/Test35.class
Class A.class is loaded from: jar:file:/home/pavel/temp/jvmti/Agent35/test.jar!/A.class
Class Test35$B.class is loaded from: jar:file:/home/pavel/temp/jvmti/Agent35/test.jar!/Test35$B.class
Class C.class is loaded from: jar:file:/home/pavel/temp/jvmti/Agent35/test.jar!/C.class
Class Test35$1.class is loaded from: jar:file:/home/pavel/temp/jvmti/Agent35/test.jar!/Test35$1.class
</pre>

<p>Agent tedy správnì rozpoznal, ¾e se soubory s&nbsp;bajtkódem nyní naèítají
z&nbsp;Java archivu.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Zdrojové kódy 35.demonstraèního agenta i k&nbsp;nìmu pøíslu¹ných testovacích pøíkladù a skriptù</h2>

<p>Zdrojový kód tøicátého pátého demonstraèního <i>JVM TI</i> agenta je,
spoleènì s&nbsp;testovací tøídou nazvanou <strong>Test35</strong> i se skripty
pou¾itými pro pøeklad a spu¹tìní agenta (dvìma zpùsoby), ulo¾en do Mercurial
repositáøe dostupného na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
Prozatím nejnovìj¹í verze v¹ech zmínìných zdrojových souborù mù¾ete najít na
tìchto adresách:</p>

<table>
<tr><td>JVM TI agent #35                         </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1d908b81dc34/jvmti-agents/agent35/agent35.c">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1d908b81dc34/jvmti-agents/agent35/agent35.c</a></td></tr>
<tr><td>Testovací tøída Test35                   </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1d908b81dc34/jvmti-agents/agent35/Test35.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1d908b81dc34/jvmti-agents/agent35/Test35.java</a></td></tr>
<tr><td>Skript pro vytvoøení Java archivu        </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1d908b81dc34/jvmti-agents/agent35/makejar.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1d908b81dc34/jvmti-agents/agent35/makejar.sh</a></td></tr>
<tr><td>Skript pro pøeklad agenta #35            </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1d908b81dc34/jvmti-agents/agent35/compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1d908b81dc34/jvmti-agents/agent35/compile.sh</a></td></tr>
<tr><td>Skript pro spu¹tìní agenta #35           </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1d908b81dc34/jvmti-agents/agent35/test.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1d908b81dc34/jvmti-agents/agent35/test.sh</a></td></tr>
<tr><td>Skript pro spu¹tìní agenta #35 proti JARu</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1d908b81dc34/jvmti-agents/agent35/test2.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1d908b81dc34/jvmti-agents/agent35/test2.sh</a></td></tr>
</table>



<p><a name="k11"></a></p>
<h2 id="k11">11. Odkazy na Internetu</h2>

<ol>

<li>Breakpoint (Wikipedia)<br />
<a href="http://cs.wikipedia.org/wiki/Breakpoint">http://cs.wikipedia.org/wiki/Breakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation<br />
<a href="http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html">http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; SetBreakpoint<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#SetBreakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#SetBreakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; ClearBreakpoint<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#ClearBreakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#ClearBreakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; Breakpoint (callback funkce)<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#Breakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#Breakpoint</a>
</li>

<li>The JVM Tool Interface (JVM TI): How VM Agents Work<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html">http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html</a>
</li>

<li>Creating a Debugging and Profiling Agent with JVMTI<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html">http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html</a>
</li>

<li>JVM TI (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/JVM_TI">http://en.wikipedia.org/wiki/JVM_TI</a>
</li>

<li>IBM JVMTI extensions<br />
<a href="http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html">http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

