<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM (7.èást - dal¹í instrukce zpracovávané virtuálním strojem Javy)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM (7.èást - dal¹í instrukce zpracovávané virtuálním strojem Javy)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o vlastnostech JVM budeme pokraèovat v popisu instrukèního souboru zpracovávaného virtuálním strojem Javy. Popí¹eme si pøedev¹ím instrukce pou¾ívané pro provádìní aritmetických a bitových operací a takté¾ instrukce slou¾ící pro porovnání dvou hodnot. Na tìchto instrukcích je mj. zalo¾eno i øízení bìhu programù.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Instrukce urèené pro provádìní aritmetických operací</a></p>
<p><a href="#k02">2. První demonstraèní pøíklad: pou¾ití aritmetických operací v&nbsp;bajtkódu</a></p>
<p><a href="#k03">3. Speciální aritmetická operace <strong>iinc</strong> a s&nbsp;ní související druhý demonstraèní pøíklad</a></p>
<p><a href="#k04">4. Instrukce urèené pro provádìní bitových operací</a></p>
<p><a href="#k05">5. Tøetí demonstraèní pøíklad: bitové operace</a></p>
<p><a href="#k06">6. Ètvrtý demonstraèní pøíklad: bitové posuny a booleovské operace</a></p>
<p><a href="#k07">7. Instrukce urèené pro porovnání dvou hodnot</a></p>
<p><a href="#k08">8. Pátý demonstraèní pøíklad: porovnávací (komparaèní) operace</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Instrukce urèené pro provádìní aritmetických operací</h2>

<p>V&nbsp;pøedchozí èásti seriálu o programovacím jazyce Java i o vlastnostech
virtuálního stroje tohoto jazyka jsme si øekli základní informace o instrukèním
souboru JVM. Víme ji¾, ¾e tento instrukèní soubor byl navr¾en s&nbsp;ohledem na
to, aby byl výsledný bajtkód ulo¾ený v&nbsp;souborech <strong>.class</strong>
co nejmen¹í, tak¾e instrukèní sada JVM není pøíli¹ ortogonální a navíc nìkteré
instrukce obsahují pøímo ve svém operaèním kódu i svùj operand: konstantu èi
index. Operaèní kód ka¾dé instrukce je ulo¾en v&nbsp;jednom bajtu, za ním¾
&ndash; podle typu instrukce &ndash; mohou následovat dal¹í bajty
s&nbsp;konstantou, popø.&nbsp;s&nbsp;indexem ukazujícím do <i>constant
poolu</i>. Z&nbsp;256 mo¾ných operaèních kódù je jich v&nbsp;souèasných verzích
virtuálního stroje Javy obsazeno zhruba 250 (zále¾í toti¾ na konkrétní verzi
JVM), pøièem¾ minule jsme si popsali zhruba jednu ètvrtinu v¹ech instrukcí.
Dnes si popí¹eme dal¹í mno¾inu instrukcí: bude se z&nbsp;velké èásti jednat o
instrukce pracující s&nbsp;daty ulo¾enými na <i>zásobníku operandù</i>,
s&nbsp;jeho¾ funkcí jsme se podrobnì seznámili v&nbsp;pøedminulé a minulé èásti
tohoto seriálu.</p>

<p>Zaènìme popisem aritmetických instrukcí, které jsou velmi jednoduché. Jedná
se vìt¹inou o instrukce pracující s&nbsp;dvojicí operandù ulo¾ených na
zásobníku operandù, Tyto instrukce slou¾í pro implementaci pìti základních
(binárních) aritmetických operací &ndash; souètu, rozdílu, souèinu, podílu a
výpoètu zbytku po dìlení. Vzhledem k&nbsp;tomu, ¾e ka¾dá tato operace existuje
ve ètyøech variantách pro datové typy <strong>int</strong>,
<strong>long</strong>, <strong>float</strong> a <strong>double</strong>, jsou
binární aritmetické operace implementovány dvaceti instrukcemi. Dal¹í ètyøi
instrukce &ndash; zmìna znaménka &ndash; v¹ak pracují pouze s&nbsp;jedním
operandem. Virtuální stroj Javy v&nbsp;èase bìhu aplikace nebo v&nbsp;èase
verifikace bajtkódu testuje, zda se v¹echny aritmetické operace provádí se
správným typem operandù. Pov¹imnìte si, ¾e instrukèní soubor JVM neobsahuje
¾ádné aritmetické operace pro operandy typu <strong>byte</strong>,
<strong>short</strong> èi <strong>char</strong> &ndash; operandy tìchto typù
jsou v¾dy pøevedeny na <strong>int</strong>. Navíc se u celoèíselných operací
netestuje pøeteèení, co¾ je mo¾ná u vysokoúrovòového jazyka ponìkud
pøekvapující (ono je ostatnì pøi ponìkud jednostranném pohledu pøekvapující i
to, ¾e Java má primitivní datové typy :-):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operand 1</th><th>Operand 2</th><th>Operace</th><th>Poznámka</th></tr>
<tr><td> 1</td><td>iadd</td><td>0x60</td><td>int   </td><td>int   </td><td>souèet</td><td>oba pùvodní operandy jsou ze zásobníku operandù odstranìny</td></tr>
<tr><td> 2</td><td>ladd</td><td>0x61</td><td>long  </td><td>long  </td><td>souèet</td><td>-//-</td></tr>
<tr><td> 3</td><td>fadd</td><td>0x62</td><td>float </td><td>float </td><td>souèet</td><td>-//-</td></tr>
<tr><td> 4</td><td>dadd</td><td>0x63</td><td>double</td><td>double</td><td>souèet</td><td>-//-</td></tr>
<tr><td> 5</td><td>isub</td><td>0x64</td><td>int   </td><td>int   </td><td>rozdíl</td><td>-//-</td></tr>
<tr><td> 6</td><td>lsub</td><td>0x65</td><td>long  </td><td>long  </td><td>rozdíl</td><td>-//-</td></tr>
<tr><td> 7</td><td>fsub</td><td>0x66</td><td>float </td><td>float </td><td>rozdíl</td><td>-//-</td></tr>
<tr><td> 8</td><td>dsub</td><td>0x67</td><td>double</td><td>double</td><td>rozdíl</td><td>-//-</td></tr>
<tr><td> 9</td><td>imul</td><td>0x68</td><td>int   </td><td>int   </td><td>souèin</td><td>-//-</td></tr>
<tr><td>10</td><td>lmul</td><td>0x69</td><td>long  </td><td>long  </td><td>souèin</td><td>-//-</td></tr>
<tr><td>11</td><td>fmul</td><td>0x6A</td><td>float </td><td>float </td><td>souèin</td><td>-//-</td></tr>
<tr><td>12</td><td>dmul</td><td>0x6B</td><td>double</td><td>double</td><td>souèin</td><td>-//-</td></tr>
<tr><td>13</td><td>idiv</td><td>0x6C</td><td>int   </td><td>int   </td><td>podíl</td><td>-//-</td></tr>
<tr><td>14</td><td>ldiv</td><td>0x6D</td><td>long  </td><td>long  </td><td>podíl</td><td>-//-</td></tr>
<tr><td>15</td><td>fdiv</td><td>0x6E</td><td>float </td><td>float </td><td>podíl</td><td>-//-</td></tr>
<tr><td>16</td><td>ddiv</td><td>0x6F</td><td>double</td><td>double</td><td>podíl</td><td>-//-</td></tr>
<tr><td>17</td><td>irem</td><td>0x70</td><td>int   </td><td>int   </td><td>zbytek po dìlení</td><td>-//-</td></tr>
<tr><td>18</td><td>lrem</td><td>0x71</td><td>long  </td><td>long  </td><td>zbytek po dìlení</td><td>-//-</td></tr>
<tr><td>19</td><td>frem</td><td>0x72</td><td>float </td><td>float </td><td>zbytek po dìlení</td><td>-//-</td></tr>
<tr><td>20</td><td>drem</td><td>0x73</td><td>double</td><td>double</td><td>zbytek po dìlení</td><td>-//-</td></tr>
<tr><td>21</td><td>ineg</td><td>0x74</td><td>int   </td><td>&nbsp;</td><td>zmìna znaménka</td><td>pùvodní operand je ze zásobníku operandù odstranìn</td></tr>
<tr><td>22</td><td>lneg</td><td>0x75</td><td>long  </td><td>&nbsp;</td><td>zmìna znaménka</td><td>pùvodní operand je ze zásobníku operandù odstranìn</td></tr>
<tr><td>23</td><td>fneg</td><td>0x76</td><td>float </td><td>&nbsp;</td><td>zmìna znaménka</td><td>pùvodní operand je ze zásobníku operandù odstranìn</td></tr>
<tr><td>24</td><td>dneg</td><td>0x77</td><td>double</td><td>&nbsp;</td><td>zmìna znaménka</td><td>pùvodní operand je ze zásobníku operandù odstranìn</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. První demonstraèní pøíklad: pou¾ití aritmetických operací v&nbsp;bajtkódu</h2>

<p>Pojïme si nyní ukázat, jakým zpùsobem pøekladaè Javy generuje aritmetické
instrukce popsané <a href="#k01">v&nbsp;pøedchozí kapitole</a>. Zdrojový kód
testovacího pøíkladu bude velmi jednoduchý &ndash; bude se jednat o nìkolik
statických metod s&nbsp;jedinou lokální promìnnou, do ní¾ se ulo¾í výsledek
aritmetické operace. Jedinou ponìkud slo¾itìj¹í metodou bude výpoèet
determinantu matice o velikosti 2&times;2 prvky:</p>

<pre>
class test1 {
&nbsp;
    static void add(int a, int b) {
        int d = a + b;
    }
&nbsp;
    static void subtract1(long a, long b) {
        long c = a - b;
    }
&nbsp;
    static void subtract2(long a, long b) {
        long c = a + -b;
    }
&nbsp;
    static void multiply(float a, float b) {
        float c = a * b;
    }
&nbsp;
    static void divide(double a, double b) {
        double c = a / b;
    }
&nbsp;
    static void rem(double a, double b) {
        double c = a % b;
    }
&nbsp;
    /**
     * Determinant matice 2x2 prvky
     */
    static double det(double a11, double a12, double a21, double a22) {
        return a11*a22 - a12*a21;
    }
&nbsp;
}
</pre>

<p>První metoda pojmenovaná <strong>add()</strong> je v&nbsp;bajtkódu
implementována pøímoèaøe:</p>

<pre>
static void add(int, int);
  Code:
   0:   iload_0      // ulo¾it první parametr metody na zásobník operandù
   1:   iload_1      // ulo¾it druhý parametr metody na zásobník operandù
   2:   iadd         // provést operaci souètu s odstranìním obou operandù
   3:   istore_2     // výsledek operace se ulo¾í do první lokální promìnné
   4:   return       // návrat do volající metody
</pre>

<p>Ve druhé metodì <strong>subtract1()</strong> stojí za pov¹imnutí pøedev¹ím
zpùsob indexování parametrù, které jsou typu <strong>long</strong>. Ka¾dý
takový parametr (èi lokální promìnná) zabere na zásobníkovém rámci dvì pozice,
proto má první parametr index 0, ale druhý parametr ji¾ index 2 a první lokální
promìnná (ulo¾ená ihned za druhým parametrem) index 4:</p>

<pre>
static void subtract1(long, long);
  Code:
   0:   lload_0      // ulo¾it první parametr metody na zásobník operandù
   1:   lload_2      // ulo¾it druhý parametr metody na zásobník operandù
   2:   lsub         // provést operaci rozdílu s odstranìním obou operandù
   3:   lstore  4    // výsledek operace se ulo¾í do první lokální promìnné
   5:   return       // návrat do volající metody
</pre>

<p>Na pøíkladu metody <strong>subtract2()</strong> je patrné, ¾e pøekladaè
vlastnì neprovedl ¾ádnou optimalizaci, tak¾e jsou pro nìj výrazy
<strong>a-b</strong> a <strong>a+ -b</strong> rozdílné:</p>

<pre>
static void subtract2(long, long);
  Code:
   0:   lload_0      // ulo¾it první parametr metody na zásobník operandù
   1:   lload_2      // ulo¾it druhý parametr metody na zásobník operandù
   2:   lneg         // zmìna znaménka prvku na TOS
   3:   ladd         // provést operaci souètu s odstranìním obou operandù
   4:   lstore  4    // výsledek operace se ulo¾í do první lokální promìnné
   6:   return       // návrat do volající metody
</pre>

<p>V&nbsp;pøípadì metody <strong>multiply()</strong> by nás nemìl její bajtkód
nièím pøekvapit:</p>

<pre>
static void multiply(float, float);
  Code:
   0:   fload_0      // ulo¾it první parametr metody na zásobník operandù
   1:   fload_1      // ulo¾it druhý parametr metody na zásobník operandù
   2:   fmul         // provést operaci souèinu s odstranìním obou operandù
   3:   fstore_2     // výsledek operace se ulo¾í do první lokální promìnné
   4:   return       // návrat do volající metody
</pre>

<p>Ani v&nbsp;pøípadì metody <strong>divide()</strong> by nás nic nemìlo
pøekvapit, tedy a¾ na fakt, ¾e se parametry typu <strong>double</strong>
zpracovávají podobnì, jako parametry typu <strong>long</strong>:</p>

<pre>
static void divide(double, double);
  Code:
   0:   dload_0      // ulo¾it první parametr metody na zásobník operandù
   1:   dload_2      // ulo¾it druhý parametr metody na zásobník operandù
   2:   ddiv         // provést operaci podílu s odstranìním obou operandù
   3:   dstore  4    // výsledek operace se ulo¾í do první lokální promìnné
   5:   return       // návrat do volající metody
</pre>

<p>Výpoèet zbytku po dìlení je prakticky stejný jako samotné dìlení, a¾ na
jednu rozdílnou instrukci:</p>

<pre>
static void rem(double, double);
  Code:
   0:   dload_0      // ulo¾it první parametr metody na zásobník operandù
   1:   dload_2      // ulo¾it druhý parametr metody na zásobník operandù
   2:   drem         // provést operaci výpoètu zbytku s odstranìním obou operandù
   3:   dstore  4    // výsledek operace se ulo¾í do první lokální promìnné
   5:   return       // návrat do volající metody
</pre>

<p>Z&nbsp;posledního výpisu je patrné, jakým zpùsobem pøekladaè Javy doká¾e
vyu¾ít zásobník v&nbsp;pøípadì, ¾e se má provést slo¾itìj¹í výpoèet
s&nbsp;operátory majícími rùznou prioritu. Pov¹imnìte si, ¾e se mezivýsledek
prvního souèinu prostì nechá ulo¾ený na zásobníku operandù, vypoète se druhý
souèin a posléze se (bez vyu¾ití mezipamìti) oba výsledky od sebe odeètou:</p>

<pre>
static double det(double, double, double, double);
  Code:
   0:   dload_0      // ulo¾it první parametr metody na zásobník operandù
   1:   dload   6    // ulo¾it tøetí parametr metody na zásobník operandù
   3:   dmul         // vypoèítat souèin (oba operandy se odstraní)
&nbsp;
   // zásobník operandù nyní obsahuje pouze TOS s výsledkem souèinu
&nbsp;
   4:   dload_2      // ulo¾it druhý parametr metody na zásobník operandù
   5:   dload   4    // ulo¾it ètvrtý parametr metody na zásobník operandù
   7:   dmul         // vypoèítat souèin (oba operandy se odstraní)
&nbsp;
   // zásobník operandù nyní obsahuje dva prvky: výsledky obou souèinù
&nbsp;
   8:   dsub         // vypoèítat rozdíl obou prvkù
&nbsp;
   // zásobník operandù nyní obsahuje pouze TOS s rozdílem
&nbsp;
   9:   dreturn      // návrat do volající metody s výsledkem double
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Speciální aritmetická operace <strong>iinc</strong> a s&nbsp;ní související druhý demonstraèní pøíklad</h2>

<p>Ve skuteènosti není seznam aritmetických instrukcí vypsaný <a
href="#k01">v&nbsp;první kapitole</a> zcela úplný, proto¾e v&nbsp;instrukèním
souboru JVM mù¾eme najít je¹tì jednu ponìkud specializovanou aritmetickou
instrukci nazvanou <strong>iinc</strong>. Tato instrukce slou¾í pro zvý¹ení
hodnoty lokální promìnné (èi parametru metody) typu <i>int</i> o hodnotu
konstanty ulo¾ené za operaèním kódem (typicky se jedná o jednièku, napøíklad
pøi implementaci nìkterých poèítaných smyèek). Vzhledem k&nbsp;tomu, ¾e se tato
hodnota mìní pøímo v&nbsp;oblasti lokálních promìnných, je instrukce
<strong>iinc</strong> jedinou aritmetickou instrukcí, která nepracuje
s&nbsp;daty ulo¾enými na zásobníku operandù. Instrukce <strong>iinc</strong>
existuje ve dvou variantách: základní a &bdquo;¹iroké&ldquo;. V&nbsp;základní
variantì je za operaèním kódem ulo¾en jeden bajt pøedstavující index do oblasti
lokálních promìnných (kde jsou i parametry metody). Za tímto bajtem je ulo¾ena
osmibitová konstanta (se znaménkem), o ní¾ se má hodnota lokální promìnné
zvý¹it.</p>

<p>V&nbsp;&bdquo;¹iroké&ldquo; variantì je index do oblasti lokálních
promìnných ¹estnáctibitový a i konstanta pro pøiètení je ¹estnáctibitová,
tj.&nbsp;pøedstavuje hodnotu le¾ící v&nbsp;rozsahu -32786 a¾ 32767. Operaèní
kódy jsou v¾dy stejné, li¹í se jen tím, zda se pøed instrukcí
<strong>iinc</strong> nachází prefix <strong>wide</strong>:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Data 1</th><th>Data 2</th><th>Operace</th></tr>
<tr><td>1</td><td>iinc  </td><td>0x84</td><td>8bit index</td><td>8bit konstanta</td><td>pøiètení osmibitové konstanty k&nbsp;promìnné</td></tr>
<tr><td>2</td><td>iinc_w</td><td>0xc4+0x84</td><td>16bit index</td><td>16bit konstanta</td><td>pøiètení ¹estnáctibitové konstanty k&nbsp;promìnné</td></tr>
</table>

<p>Podívejme se na jednoduchý demonstraèní pøíklad, v&nbsp;nìm¾ jsou navíc
ukázány nìkteré limity instrukce <strong>iinc</strong>, zejména její omezení na
pou¾ití 16bitových konstant:</p>

<pre>
class test2 {
&nbsp;
    static void inc(int a) {
        a++;
        a+=10;
        a--;
        a+=1000;
        a-=1000;
        a+=100000;
        a-=100000;
    }
&nbsp;
}
</pre>

<p>Statická metoda <strong>inc()</strong> se pøelo¾í následovnì (poznámky jsou
samozøejmì dopsány ruènì):</p>

<pre>
static void inc(int);
  Code:
   // pøíkaz a++:
   0:   iinc    0, 1       // 0=index promìnné, 1=konstanta pro pøiètení
&nbsp;
   // pøíkaz a+=10;
   3:   iinc    0, 10
&nbsp;
   // pøíkaz a--:
   6:   iinc    0, -1
&nbsp;
   // pøíkaz a+=1000; (konstanta je vìt¹í ne¾ 127)
   9:   iinc_w 0, 1000
&nbsp;
   // pøíkaz a-=1000; (konstanta je men¹í ne¾ -128)
   15:  iinc_w 0, -1000
&nbsp;
   // pøíkaz a+=100000; (konstanta je vìt¹í ne¾ 32767, nelze pou¾ít iinc)
   21:  iload_0
   22:  ldc     #2; //int 100000 ulo¾ený na constant poolu
   24:  iadd
   25:  istore_0
&nbsp;
   // pøíkaz a-=100000; (konstanta je vìt¹í ne¾ 32767, nelze pou¾ít iinc)
   26:  iload_0
   27:  ldc     #2; //int 100000 ulo¾ený na constant poolu
   29:  isub
   30:  istore_0
&nbsp;
   31:  return      // návrat z metody
}
</pre>

<p>I pøes omezení na pou¾ití osmibitových a ¹estnáctibitových konstant je
instrukce <strong>iinc</strong> velmi u¾iteèná, proto¾e má ve své standardní
variantì délku pouze tøi bajty a v&nbsp;¹iroké variantì délku ¹esti bajtù (i
s&nbsp;prefixem), co¾ je obecnì (ov¹em ne v¾dy!) ménì, ne¾ sekvence operací
<strong>iload+ldc+iadd/isub+istore</strong>.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Instrukce urèené pro provádìní bitových operací</h2>

<p>Druhou skupinou instrukcí virtuálního stroje Javy, s&nbsp;ní¾ se
v&nbsp;dne¹ním èlánku seznámíme, jsou instrukce, pomocí nich¾ se implementují
témìø v¹echny základní bitové a logické operace. Nejprve se zmíníme o bitových
operacích. Programovací jazyk Java obsahuje nìkolik bitových operací, které lze
provádìt nad datovými typy <strong>int</strong> èi <strong>long</strong>. Jedná
se o bitový souèin (operace AND provádìná bit po bitu), bitový souèet,
nonekvivalenci a negaci (opìt provádìnou bit po bitu). V&nbsp;instrukèním
souboru v¹ak nalezneme pouze první tøi bitové instrukce: bitový souèin, bitový
souèet a nonekvivalenci, proto¾e negace se provádí pomocí dvou instrukcí,
konkrétnì s&nbsp;vyu¾itím nonekvivalence proti masce 0xffffffff
(popø.&nbsp;obdobné konstanty typu <strong>long</strong>). Jak uvidíme dále,
jsou tyto instrukce pou¾ity i pro provádìní logických operací: logického
souètu, souèinu, nonekvivalence a negace, tak¾e do instrukèního souboru JVM
nebylo nutné pro datový typ <strong>boolean</strong> pøidávat ¾ádné dal¹í
specializované instrukce.</p>

<p>Navíc programovací jazyk Java obsahuje i operace aritmetického a bitového
posunu doleva a doprava, které mají svùj obraz v&nbsp;instrukèní sadì. Posun
doleva odpovídá operátoru &lt;&lt; (nezávisle na znaménku prvního operandu),
posun doprava pak dvojici operátorù &gt;&gt; a &gt;&gt;&gt; (v&nbsp;céèku se
rozli¹ují typy <strong>signed</strong> a <strong>unsigned</strong>, proto druhý
z&nbsp;tìchto operátorù nemusí být v&nbsp;tomto jazyku pou¾it). Mimochodem: ze
specifikace JVM vyplývá, ¾e druhý operand v&nbsp;instrukcích posunu je nejprve
maskován konstantou 0x1f v&nbsp;pøípadì typu <strong>int</strong> èi 0x3f u
datového typu <strong>long</strong>. Jinými slovy to znamená, ¾e pro posun je
pou¾ito pouze dolních 5 èi 6 bitù. Takté¾ si pov¹imnìte, ¾e u instrukcí pro
bitový èi aritmetický posun je druhým operandem v¾dy hodnota typu
<strong>int</strong>, a to i v&nbsp;pøípadì, ¾e se posouvá hodnota typu
<strong>long</strong>:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operand 1</th><th>Operand 2</th><th>Operace</th><th>Poznámka</th></tr>
<tr><td> 1</td><td>ishl </td><td>0x78</td><td>int </td><td>int </td><td>aritmetický/bitový posun doleva</td><td>oba pùvodní operandy ze zásobníku operandù jsou odstranìny</td></tr>
<tr><td> 2</td><td>lshl </td><td>0x79</td><td>long</td><td>int </td><td>aritmetický/bitový posun doleva</td><td>-//-</td></tr>
<tr><td> 3</td><td>ishr </td><td>0x7A</td><td>int </td><td>int </td><td>aritmetický posun doprava</td><td>-//-</td></tr>
<tr><td> 4</td><td>lshr </td><td>0x7B</td><td>long</td><td>int </td><td>aritmetický posun doprava</td><td>-//-</td></tr>
<tr><td> 5</td><td>iushr</td><td>0x7C</td><td>int </td><td>int </td><td>bitový posun doprava</td><td>-//-</td></tr>
<tr><td> 6</td><td>lushr</td><td>0x7D</td><td>long</td><td>int </td><td>bitový posun doprava</td><td>-//-</td></tr>
<tr><td> 7</td><td>iand </td><td>0x7E</td><td>int </td><td>int </td><td>bitový souèin</td><td>-//-</td></tr>
<tr><td> 8</td><td>land </td><td>0x7F</td><td>long</td><td>long</td><td>bitový souèin</td><td>-//-</td></tr>
<tr><td> 9</td><td>ior  </td><td>0x80</td><td>int </td><td>int </td><td>bitový souèet</td><td>-//-</td></tr>
<tr><td>10</td><td>lor  </td><td>0x81</td><td>long</td><td>long</td><td>bitový souèet</td><td>-//-</td></tr>
<tr><td>11</td><td>ixor </td><td>0x82</td><td>int </td><td>int </td><td>nonekvivalence</td><td>-//-</td></tr>
<tr><td>12</td><td>lxor </td><td>0x83</td><td>long</td><td>long</td><td>nonekvivalence</td><td>-//-</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. Tøetí demonstraèní pøíklad: bitové operace</h2>

<p>Na následujícím testovacím pøíkladu si uká¾eme, jakým zpùsobem pøekladaè
Javy doká¾e pøelo¾it základní bitové operace provádìné nad promìnnými typu
<strong>int</strong> a <strong>long</strong>. Pøíklad je velmi jednoduchý,
proto¾e obsahuje pouze osmici statických metod, z&nbsp;nich¾ ka¾dá obsahuje
pouze jednu bitovou operaci. Pov¹imnìte si pøedev¹ím toho, jakým zpùsobem je
pøelo¾ena unární operace bitové negace: v&nbsp;pøípadì promìnné typu
<strong>int</strong> je pro ulo¾ení hodnoty 0xffffffff na <i>zásobník
operandù</i> pou¾ita jednobajtová instrukce <strong>iconst_m1</strong> (ulo¾ení
konstanty -1 na zásobník), ov¹em u promìnné typu <strong>long</strong> se ji¾
musela pou¾ít konstanta ulo¾ená na <i>constant poolu</i>:</p>

<pre>
class test3 {
&nbsp;
    static void bitOpAnd(int a, int b) {
        int c = a &amp; b;
    }
&nbsp;
    static void bitOpOr(int a, int b) {
        int c = a | b;
    }
&nbsp;
    static void bitOpXor(int a, int b) {
        int c = a ^ b;
    }
&nbsp;
    static void bitOpNegate(int a) {
        int b = ~a;
    }
&nbsp;
    static void bitOpAnd(long a, long b) {
        long c = a &amp; b;
    }
&nbsp;
    static void bitOpOr(long a, long b) {
        long c = a | b;
    }
&nbsp;
    static void bitOpXor(long a, long b) {
        long c = a ^ b;
    }
&nbsp;
    static void bitOpNegate(long a) {
        long b = ~a;
    }
&nbsp;
}
</pre>

<p>Dissasemblovaný bajtkód tøetího demonstraèního pøíkladu vypadá
následovnì:</p>

<pre>
static void bitOpAnd(int, int);
  Code:
   0:   iload_0       // naètení prvního parametru metody
   1:   iload_1       // naètení druhého parametru metody
   2:   iand          // provedení operace bitového souèinu
   3:   istore_2      // ulo¾ení výsledku do lokální promìnné
   4:   return        // návrat z metody
</pre>

<pre>
static void bitOpOr(int, int);
  Code:
   0:   iload_0       // naètení prvního parametru metody
   1:   iload_1       // naètení druhého parametru metody
   2:   ior           // provedení operace bitového souètu
   3:   istore_2      // ulo¾ení výsledku do lokální promìnné
   4:   return        // návrat z metody
</pre>

<pre>
static void bitOpXor(int, int);
  Code:
   0:   iload_0       // naètení prvního parametru metody
   1:   iload_1       // naètení druhého parametru metody
   2:   ixor          // provedení operace nonekvivalence
   3:   istore_2      // ulo¾ení výsledku do lokální promìnné
   4:   return        // návrat z metody
</pre>

<pre>
static void bitOpNegate(int);
  Code:
   0:   iload_0       // naètení prvního parametru metody
   1:   iconst_m1     // naètení konstanty 0xffffffff
   2:   ixor          // a^0xffffffff == ~a
   3:   istore_1      // ulo¾ení výsledku do lokální promìnné
   4:   return        // návrat z metody
</pre>

<p>U promìnných typu <strong>long</strong> je opìt jejich indexace
rozdílná:</p>

<pre>
static void bitOpAnd(long, long);
  Code:
   0:   lload_0       // naètení prvního parametru metody
   1:   lload_2       // naètení druhého parametru metody
   2:   land          // provedení operace bitového souèinu
   3:   lstore  4     // ulo¾ení výsledku do lokální promìnné
   5:   return        // návrat z metody
</pre>

<pre>
static void bitOpOr(long, long);
  Code:
   0:   lload_0       // naètení prvního parametru metody
   1:   lload_2       // naètení druhého parametru metody
   2:   lor           // provedení operace bitového souètu
   3:   lstore  4     // ulo¾ení výsledku do lokální promìnné
   5:   return        // návrat z metody
</pre>

<pre>
static void bitOpXor(long, long);
  Code:
   0:   lload_0       // naètení prvního parametru metody
   1:   lload_2       // naètení druhého parametru metody
   2:   lxor          // provedení operace nonekvivalence
   3:   lstore  4     // ulo¾ení výsledku do lokální promìnné
   5:   return        // návrat z metody
</pre>

<pre>
static void bitOpNegate(long);
  Code:
   0:   lload_0       // naètení prvního parametru metody
   1:   ldc2_w  #2;   // 0xffffffffffffffff
   4:   lxor          // a^0xffffffffffffffff == ~a
   5:   lstore_2      // ulo¾ení výsledku do lokální promìnné
   6:   return        // návrat z metody
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Ètvrtý demonstraèní pøíklad: bitové posuny a booleovské operace</h2>

<p>Ve ètvrtém demonstraèním pøíkladu si uká¾eme pou¾ití bitových instrukcí pro
implementaci booleovských operací. Takté¾ si uká¾eme, jak se pøelo¾í výpoèty,
v&nbsp;nich¾ se vyskytují operandy pro provádìní aritmetického èi bitového
posunu doleva a doprava. Zdrojový kód demonstraèního pøíkladu je
následující:</p>

<pre>
class test4 {
&nbsp;
    static void boolOpAnd(boolean a, boolean b) {
        boolean c = a &amp; b;
    }
&nbsp;
    static void boolOpOr(boolean a, boolean b) {
        boolean c = a | b;
    }
&nbsp;
    static void boolOpXor(boolean a, boolean b) {
        boolean c = a ^ b;
    }
&nbsp;
    static void boolOpNot(boolean a) {
        boolean c = !a;
    }
&nbsp;
    static void asl(int x, int shift) {
        int y = x &lt;&lt; shift;
    }
&nbsp;
    static void asr(int x, int shift) {
        int y = x &gt;&gt; shift;
    }
&nbsp;
    static void lsr(int x, int shift) {
        int y = x &gt;&gt;&gt; shift;
    }
&nbsp;
    static void asl(long x, long shift) {
        long y = x &lt;&lt; shift;
    }
&nbsp;
    static void asr(long x, long shift) {
        long y = x &gt;&gt; shift;
    }
&nbsp;
    static void lsr(long x, long shift) {
        long y = x &gt;&gt;&gt; shift;
    }
&nbsp;
}
</pre>

<p>První tøi metody s&nbsp;booleovskými operacemi jsou pøelo¾eny takovým
zpùsobem, ¾e se namísto hodnot typu <strong>boolean</strong> pou¾ívají hodnoty
typu <strong>int</strong>, pøièem¾ platí identity <strong>false=0,
true=1</strong> (co¾ mimochodem není pøímo v&nbsp;Javì povoleno):</p>

<pre>
static void boolOpAnd(boolean, boolean);
  Code:
   0:   iload_0       // naètení prvního parametru metody
   1:   iload_1       // naètení druhého parametru metody
   2:   iand          // provedení operace bitového souèinu (a tím pádem i booleovského souèinu)
   3:   istore_2      // ulo¾ení výsledku do lokální promìnné
   4:   return        // návrat z metody
</pre>

<pre>
static void boolOpOr(boolean, boolean);
  Code:
   0:   iload_0       // naètení prvního parametru metody
   1:   iload_1       // naètení druhého parametru metody
   2:   ior           // provedení operace bitového souètu
   3:   istore_2      // ulo¾ení výsledku do lokální promìnné
   4:   return        // návrat z metody
</pre>

<pre>
static void boolOpXor(boolean, boolean);
  Code:
   0:   iload_0       // naètení prvního parametru metody
   1:   iload_1       // naètení druhého parametru metody
   2:   ixor          // provedení operace nonekvivalence
   3:   istore_2      // ulo¾ení výsledku do lokální promìnné
   4:   return        // návrat z metody
</pre>

<p>Zdánlivì velmi jednoduchá operace logické negace je v¹ak pøelo¾ena pomocí
podmínìného skoku(!), proto¾e výsledkem musí být hodnota 0 nebo 1 a nikoli 0
nebo -1, jak by tomu bylo pøi pou¾ití negace bit po bitu (zkuste se zamyslet
nad tím, proè není pou¾ita operace <strong>xor 0x01</strong>):</p>

<pre>
static void boolOpNot(boolean);
  Code:
   0:   iload_0       // naètení prvního parametru metody
   1:   ifne    8     // podmínìný skok (probereme v dal¹í èásti)
   4:   iconst_1      // jeden z výsledkù - konstanta 1
   5:   goto    9     // nepodmínìný skok
   8:   iconst_0      // jeden z výsledkù - konstanta 1
   9:   istore_1      // ulo¾ení výsledku do lokální promìnné
   10:  return        // návrat z metody
</pre>

<p>Bitové a aritmetické posuny jsou pøelo¾eny pøímoèaøe (alespoò v&nbsp;pøípadì
pou¾ití promìnných typu <strong>int</strong>):</p>

<pre>
static void asl(int, int);
  Code:
   0:   iload_0       // naètení prvního parametru metody
   1:   iload_1       // naètení druhého parametru metody
   2:   ishl          // aritmetická/bitová operace posunu doleva
   3:   istore_2      // ulo¾ení výsledku do lokální promìnné
   4:   return        // návrat z metody
</pre>

<pre>
static void asr(int, int);
  Code:
   0:   iload_0       // naètení prvního parametru metody
   1:   iload_1       // naètení druhého parametru metody
   2:   ishr          // aritmetická operace posunu doprava
   3:   istore_2      // ulo¾ení výsledku do lokální promìnné
   4:   return        // návrat z metody
</pre>

<pre>
static void lsr(int, int);
  Code:
   0:   iload_0       // naètení prvního parametru metody
   1:   iload_1       // naètení druhého parametru metody
   2:   iushr         // bitová operace posunu doprava
   3:   istore_2      // ulo¾ení výsledku do lokální promìnné
   4:   return        // návrat z metody
</pre>

<p>V&nbsp;pøípadì, ¾e je druhý operand posunu typu <strong>long</strong>, je
tento operand automaticky (a bez varování) nejdøíve pøeveden na typ
<strong>int</strong> pomocí instrukce <strong>l2i</strong>, kterou jsme si ji¾
popsali v&nbsp;pøedchozí èásti tohoto seriálu:</p>

<pre>
static void asl(long, long);
  Code:
   0:   lload_0       // naètení prvního parametru metody
   1:   lload_2       // naètení druhého parametru metody
   2:   l2i           // pøevod druhého parametru na typ int
   3:   lshl          // aritmetická/bitová operace posunu doleva
   4:   lstore  4     // ulo¾ení výsledku do lokální promìnné
   6:   return        // návrat z metody
</pre>

<pre>
static void asr(long, long);
  Code:
   0:   lload_0       // naètení prvního parametru metody
   1:   lload_2       // naètení druhého parametru metody
   2:   l2i           // pøevod druhého parametru na typ int
   3:   lshr          // aritmetická operace posunu doprava
   4:   lstore  4     // ulo¾ení výsledku do lokální promìnné
   6:   return        // návrat z metody
</pre>

<pre>
static void lsr(long, long);
  Code:
   0:   lload_0       // naètení prvního parametru metody
   1:   lload_2       // naètení druhého parametru metody
   2:   l2i           // pøevod druhého parametru na typ int
   3:   lushr         // bitová operace posunu doprava
   4:   lstore  4     // ulo¾ení výsledku do lokální promìnné
   6:   return        // návrat z metody
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Instrukce urèené pro porovnání dvou hodnot</h2>

<p>Do tøetí skupiny instrukcí, s&nbsp;nimi¾ se dnes seznámíme, patøí pouze pìt
instrukcí, které slou¾í k&nbsp;porovnání dvojice numerických hodnot a jejich¾
výsledkem je hodnota typu <strong>int</strong> 0, 1, popø.&nbsp; -1.
Porovnávané numerické hodnoty mohou být typu <strong>long</strong>,
<strong>float</strong> èi <strong>double</strong>, nikoli v¹ak (mo¾ná ponìkud
pøekvapivì) typu <strong>int</strong>. To ve skuteènosti ani není zapotøebí,
proto¾e porovnávací instrukce ve vìt¹inì pøípadù slou¾í pouze k&nbsp;pøípravì
na podmínìný skok. Instrukcemi podmínìných skokù se budeme zabývat v&nbsp;dal¹í
èásti tohoto seriálu, zde si jen øeknìme, ¾e existuje ¹estice podmínìných skokù
zalo¾ených na porovnání hodnoty typu <strong>int</strong> s&nbsp;nulou
(tj.&nbsp;test na nulovost, nenulovost, kladnost, zápornost, popø.&nbsp;test na
rozumnou kombinaci tìchto vlastností). V&nbsp;následující tabulce je vypsáno
v¹ech pìt porovnávacích instrukcí. Pov¹imnìte si, ¾e instrukce konèící na
&bdquo;l&ldquo; se od instrukcí konèících na &bdquo;g&ldquo; li¹í ve zpùsobu
zpracování speciální hodnoty <strong>NaN</strong> (<i>not-a-number</i>):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operand 1</th><th>Operand 2</th><th>Výsledek</th><th>Poznámka</th></tr>
<tr><td>1</td><td>lcmp </td><td>0x94</td><td>long  </td><td>long  </td><td>1 kdy¾ operand 1 &gt; operand 2<br />0 kdy¾ operand 1 == operand 2<br />-1 kdy¾ operand 1 &lt; operand 2</td></tr>
<tr><td>2</td><td>fcmpl</td><td>0x95</td><td>float </td><td>float </td><td>1 kdy¾ operand 1 &gt; operand 2<br />0 kdy¾ operand 1 == operand 2<br />-1 kdy¾ operand 1 &lt; operand 2<br />-1 kdy¾ operand 1 je NaN<br />-1 kdy¾ operand 2 je NaN</td></tr>
<tr><td>3</td><td>fcmpg</td><td>0x96</td><td>float </td><td>float </td><td>1 kdy¾ operand 1 &gt; operand 2<br />0 kdy¾ operand 1 == operand 2<br />-1 kdy¾ operand 1 &lt; operand 2<br />1 kdy¾ operand 1 je NaN<br />1 kdy¾ operand 2 je NaN</td></tr>
<tr><td>4</td><td>dcmpl</td><td>0x97</td><td>double</td><td>double</td><td>1 kdy¾ operand 1 &gt; operand 2<br />0 kdy¾ operand 1 == operand 2<br />-1 kdy¾ operand 1 &lt; operand 2<br />-1 kdy¾ operand 1 je NaN<br />-1 kdy¾ operand 2 je NaN</td></tr>
<tr><td>5</td><td>dcmpg</td><td>0x98</td><td>double</td><td>double</td><td>1 kdy¾ operand 1 &gt; operand 2<br />0 kdy¾ operand 1 == operand 2<br />-1 kdy¾ operand 1 &lt; operand 2<br />1 kdy¾ operand 1 je NaN<br />1 kdy¾ operand 2 je NaN</td></tr>
</table>

<p>Jen na okraj si pøipomeòme, ¾e v&nbsp;Javì pøi porovnávání speciální hodnoty
<strong>NaN</strong> s&nbsp;jakoukoli jinou hodnotou v¾dy dostaneme výsledek
<strong>false</strong> (a to i v&nbsp;pøípadì, ¾e je druhou hodnotou takté¾
<strong>NaN</strong>):</p>

<pre>
float a = Float.NaN;
float b = Float.NaN;
&nbsp;
System.out.println(a&lt;b);
System.out.println(a&gt;b);
System.out.println(a==b);
System.out.println(a&lt;0);
System.out.println(a&gt;0);
System.out.println(a==0);
</pre>

<p>Výsledkem je ve v¹ech tøech pøípadech stejný text:</p>

<pre>
false
false
false
false
false
false
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Pátý demonstraèní pøíklad: porovnávací (komparaèní) operace</h2>

<p>V&nbsp;posledním demonstraèním pøíkladu si uká¾eme pou¾ití porovnávacích
operací. Tento pøíklad se bude ponìkud li¹it od v¹ech pøedchozích
demonstraèních pøíkladù v&nbsp;tom ohledu, ¾e v&nbsp;nìm budou pou¾ity
instrukce, jejich¾ význam si podrobnìji popí¹eme a¾ v&nbsp;následující èásti
tohoto seriálu. Zdrojový kód je jednoduchý &ndash; na základì porovnání dvou
èísel typu <strong>long</strong> je nastavena hodnota ¹esti lokálních
promìnných typu <strong>boolean</strong>. I takto jednoduché výpoèty se v¹ak
kupodivu pøelo¾í pomocí podmínìných skokù:</p>

<pre>
class test4 {
&nbsp;
    static void compare(long a, long b) {
        boolean eq = a == b;
        boolean ne = a != b;
        boolean lt = a &lt; b;
        boolean le = a &lt;= b;
        boolean gt = a &gt; b;
        boolean ge = a &gt;= b;
    }
&nbsp;
}
</pre>

<p>Následuje okomentovaný bajtkód metody <strong>compare()</strong>:</p>

<p>Instrukce provádìjící pøíkaz: <strong>boolean eq = a == b;</strong></p>

<pre>
   0:   lload_0       // naètení prvního parametru metody
   1:   lload_2       // naètení druhého parametru metody
   2:   lcmp          // porovnání obou hodnot s výsledkem 0, 1 nebo -1
   3:   ifne    10    // pøi opaèné podmínce skok s výsledkem 0
   6:   iconst_1      // podmínìný skok nebyl proveden: výsledek = 1
   7:   goto    11    // nepodmínìný skok
   10:  iconst_0      // sem je proveden podmínìný skok z instrukce #3
   11:  istore  4     // ulo¾ení výsledku do lokální promìnné
</pre>

<p>Instrukce provádìjící pøíkaz: <strong>boolean ne = a != b;</strong></p>

<pre>
   13:  lload_0       // naètení prvního parametru metody
   14:  lload_2       // naètení druhého parametru metody
   15:  lcmp          // porovnání obou hodnot s výsledkem 0, 1 nebo -1
   16:  ifeq    23    // pøi opaèné podmínce skok s výsledkem 0
   19:  iconst_1      // podmínìný skok nebyl proveden: výsledek = 1
   20:  goto    24    // nepodmínìný skok
   23:  iconst_0      // sem je proveden podmínìný skok z instrukce #16
   24:  istore  5     // ulo¾ení výsledku do lokální promìnné
</pre>

<p>Instrukce provádìjící pøíkaz: <strong>boolean lt = a &lt; b;</strong></p>

<pre>
   26:  lload_0       // naètení prvního parametru metody
   27:  lload_2       // naètení druhého parametru metody
   28:  lcmp          // porovnání obou hodnot s výsledkem 0, 1 nebo -1
   29:  ifge    36    // pøi opaèné podmínce skok s výsledkem 0
   32:  iconst_1      // podmínìný skok nebyl proveden: výsledek = 1
   33:  goto    37    // nepodmínìný skok
   36:  iconst_0      // sem je proveden podmínìný skok z instrukce #29
   37:  istore  6     // ulo¾ení výsledku do lokální promìnné
</pre>

<p>Instrukce provádìjící pøíkaz: <strong>boolean le = a &lt;= b;</strong></p>

<pre>
   39:  lload_0       // naètení prvního parametru metody
   40:  lload_2       // naètení druhého parametru metody
   41:  lcmp          // porovnání obou hodnot s výsledkem 0, 1 nebo -1
   42:  ifgt    49    // pøi opaèné podmínce skok s výsledkem 0
   45:  iconst_1      // podmínìný skok nebyl proveden: výsledek = 1
   46:  goto    50    // nepodmínìný skok
   49:  iconst_0      // sem je proveden podmínìný skok z instrukce #42
   50:  istore  7     // ulo¾ení výsledku do lokální promìnné
</pre>

<p>Instrukce provádìjící pøíkaz: <strong>boolean gt = a &gt; b;</strong></p>

<pre>
   52:  lload_0       // naètení prvního parametru metody
   53:  lload_2       // naètení druhého parametru metody
   54:  lcmp          // porovnání obou hodnot s výsledkem 0, 1 nebo -1
   55:  ifle    62    // pøi opaèné podmínce skok s výsledkem 0
   58:  iconst_1      // podmínìný skok nebyl proveden: výsledek = 1
   59:  goto    63    // nepodmínìný skok
   62:  iconst_0      // sem je proveden podmínìný skok z instrukce #55
   63:  istore  8     // ulo¾ení výsledku do lokální promìnné
</pre>

<p>Instrukce provádìjící pøíkaz: <strong>boolean ge = a &gt;= b;</strong></p>

<pre>
   65:  lload_0       // naètení prvního parametru metody
   66:  lload_2       // naètení druhého parametru metody
   67:  lcmp          // porovnání obou hodnot s výsledkem 0, 1 nebo -1
   68:  iflt    75    // pøi opaèné podmínce skok s výsledkem 0
   71:  iconst_1      // podmínìný skok nebyl proveden: výsledek = 1
   72:  goto    76    // nepodmínìný skok
   75:  iconst_0      // sem je proveden podmínìný skok z instrukce #68
   76:  istore  9     // ulo¾ení výsledku do lokální promìnné
</pre>

<p>Návrat z&nbsp;metody:</p>

<pre>
   78:  return
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Root.cz: Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM<br />
<a href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/</a></a>
</li>

<li>Root.cz: JamVM aneb alternativa k HotSpotu nejenom pro embedded zaøízení a chytré telefony<br />
<a href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>FindBugs<br />
<a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a>
</li>

<li>GNU Classpath<br />
<a href="www.gnu.org/s/classpath/">www.gnu.org/s/classpath/</a></li>

<li>Java VMs Compared<br />
<a href="http://bugblogger.com/java-vms-compared-160/">http://bugblogger.com/java-vms-compared-160/</a>
</li>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a></li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>CloseableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html">http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

