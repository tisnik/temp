<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - zpracování událostí v knihovnì SDLJava (dokonèení)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - zpracování událostí v knihovnì SDLJava (dokonèení)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyku Java i o virtuálním stroji tohoto jazyka dokonèíme problematiku práce s událostmi implementovanými v knihovnì SDLJava. Na ètveøici demonstraèních pøíkladù si uká¾eme, jakým zpùsobem lze naprogramovat aplikaci s oknem s mìnitelnými rozmìry i to, jak lze napøíklad registrovat ztrátu fokusu tohoto okna.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - zpracování událostí v knihovnì SDLJava (dokonèení)</a></p>
<p><a href="#k02">2. Událost typu <strong>sdljava.event.SDLResizeEvent</strong></a></p>
<p><a href="#k03">3. Demonstraèní pøíklad <strong>SDLTest36</strong>: detekce zmìny velikosti okna aplikace</a></p>
<p><a href="#k04">4. Vykreslovací plocha pøi zmìnì velikosti okna aplikace</a></p>
<p><a href="#k05">5. Demonstraèní pøíklad <strong>SDLTest37</strong>: vykreslování do okna s&nbsp;mìnitelnými rozmìry</a></p>
<p><a href="#k06">6. Korektní zpùsob reakce na zmìnu velikosti okna aplikace</a></p>
<p><a href="#k07">7. Demonstraèní pøíklad <strong>SDLTest38</strong>: korektní zpùsob reakce na zmìnu velikosti okna aplikace</a></p>
<p><a href="#k08">8. Událost typu <strong>sdljava.event.SDLActiveEvent</strong></a></p>
<p><a href="#k09">9. Demonstraèní pøíklad <strong>SDLTest39</strong>: detekce získání a ztracení fokusu a detekce pøesunu kurzoru my¹i do plochy okna aplikace</a></p>
<p><a href="#k10">10. Repositáø se zdrojovými kódy v¹ech ètyø dne¹ních demonstraèních pøíkladù</a></p>
<p><a href="#k11">11. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - zpracování událostí v knihovnì SDLJava (dokonèení)</h2>

<p>V&nbsp;pøedchozích èástech <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyku Java i o virtuálním stroji tohoto jazyka</a> jsme si
vysvìtlili zpùsob práce s&nbsp;událostmi implementovanými v&nbsp;knihovnì
<i>SDLJava</i>. Pøipomeòme si, ¾e události, tj.&nbsp;instance tøídy
<strong>sdljava.event.SDLEvent</strong> popø.&nbsp;tøíd od
<strong>sdljava.event.SDLEvent</strong> odvozených, vznikají napøíklad pøi
stisku klávesy, posunu kurzoru my¹i v&nbsp;oknì aplikace, uzavøení okna
aplikace atd. Typicky se události postupnì naèítají v&nbsp;nekoneèné smyèce
(<i>event loop</i>) z&nbsp;takzvané fronty událostí (<i>event queue</i>) a
aplikace na nì odpovídajícím zpùsobem reaguje zmìnou stavu svých objektù
&ndash; posunem spritu hráèe na obrazovce apod. Typická smyèka událostí
v&nbsp;sobì zahrnuje i test na událost typu
<strong>sdljava.event.SDLQuitEvent</strong>, tak¾e je mo¾né korektnì reagovat
na ¾ádost o ukonèení aplikace. Podívejme se na jednoduchý pøíklad, který jsme
ji¾ v&nbsp;mnoha obdobách mohli vidìt v&nbsp;pøedchozích èástech seriálu:</p>

<pre>
    <i>/**</i>
    <i> * Smycka pro zpracovani udalosti.</i>
    <i> */</i>
    private static void <strong>eventLoop</strong>() throws SDLException {
        while (true) {
            <i>// precist udalost z fronty</i>
            SDLEvent event = SDLEvent.waitEvent();
&nbsp;
            <i>// vyskok ze smycky pro zpracovani udalosti pri vyskytu</i>
            <i>// udalosti typu SDLQuitEvent</i>
            if (event instanceof SDLQuitEvent) {
                return;
            }
&nbsp;
            <i>// stisk ci pusteni klavesy</i>
            if (event instanceof SDLKeyboardEvent) {
                <i>// pretypovani</i>
                final SDLKeyboardEvent keyEvent = (SDLKeyboardEvent)event;
&nbsp;
                <i>// symbol/kod klavesy</i>
                final int symbol = keyEvent.getSym();
&nbsp;
                <i>// ESC ukonci program</i>
                if (symbol == SDLKey.SDLK_ESCAPE &amp;&amp; keyEvent.getState() == SDLPressedState.PRESSED) {
                    return;
                }
            }
&nbsp;
            if (event instanceof SDLActiveEvent) {
                <i>// adekvátní reakce na tento typ události</i>
            }
&nbsp;
            if (event instanceof SDLMouseButtonEvent) {
                <i>// adekvátní reakce na tento typ události</i>
            }
&nbsp;
            if (event instanceof SDLMouseMotionEvent) {
                <i>// adekvátní reakce na tento typ události</i>
            }
&nbsp;
        }
    }
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Událost typu <strong>sdljava.event.SDLResizeEvent</strong></h2>

<p>Knihovna <i>SDL</i> a zprostøedkovanì i knihovna <i>SDLJava</i> se pomìrnì
èasto pou¾ívá pro implementaci her. Vìt¹inou hry vyu¾ívají vybraný exkluzivní
celoobrazovkový grafický re¾im, co¾ hráèùm umo¾òuje se plnì soustøedit na
vlastní hru a nenechat se rozptylovat stále komplikovanìj¹ím desktopovým
prostøedím :-) Ov¹em v&nbsp;nìkterých pøípadech mù¾e být preferováno spu¹tìní
aplikace vyu¾ívající <i>SDL/SDLJava</i> v&nbsp;samostatném oknì. Na tomto místì
se musí programátor rozhodnout, zda bude mít toto okno pevnou velikost èi zda
u¾ivatelùm umo¾ní velikost (libovolnì) mìnit. Pokud má být velikost primárního
okna aplikace nemìnitelná, pou¾ije se následující typický zpùsob inicializace
grafického subsystému <i>SDLJava</i>:</p>

<pre>
    <i>/**</i>
    <i> * Inicializace grafickeho rezimu ci otevreni okna pro vykreslovani.</i>
    <i> */</i>
    private static void <strong>initVideo</strong>() throws SDLException {
        final long flags = SDLVideo.SDL_DOUBLEBUF;
        SDLVideo.setVideoMode(GFX_WIDTH, GFX_HEIGHT, GFX_BPP, flags);
    }
</pre>

<p>Sami si mù¾ete vyzkou¹et, ¾e velikost okna by nemìlo být mo¾né mìnit.
V&nbsp;pøípadì, ¾e má být velikost okna mìnitelná, je nutné pøi inicializaci
grafického subsystému knihovny <i>SDL/SDLJava</i> pøidat pøíznak
<strong>SDLVideo.SDL_RESIZABLE</strong>, a to napøíklad následujícím
zpùsobem:</p>

<pre>
    <i>/**</i>
    <i> * Inicializace grafickeho rezimu ci otevreni okna pro vykreslovani.</i>
    <i> */</i>
    private static void <strong>initVideo</strong>(int width, int height) throws SDLException {
        <i>// potrebujeme vytvorit okno, u ktereho je mozne menit jeho velikost.</i>
        final long flags = SDLVideo.SDL_DOUBLEBUF | SDLVideo.SDL_RESIZABLE;
        SDLVideo.setVideoMode(width, height, GFX_BPP, flags);
    }
</pre>

<p>Po této inicializaci je v¹ak nutné, aby aplikace zaèala korektnì reagovat na
zmìnu velikosti okna, co¾ konkrétnì znamená, ¾e musí zpracovávat události typu
<strong>sdljava.event.SDLResizeEvent</strong>, které jsou do fronty událostí
vlo¾eny po ka¾dé zmìnì velikosti okna (závisí na mnoha faktorech, zda je tato
událost zapsána pouze pøi ukonèení zmìny velikosti okna èi v&nbsp;jeho prùbìhu
&ndash; typicky je chování závislé na nastavení správce oken).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Demonstraèní pøíklad <strong>SDLTest36</strong>: detekce zmìny velikosti okna aplikace</h2>

<p>V&nbsp;dne¹ním prvním demonstraèním pøíkladu pojmenovaném
<strong>SDLTest36</strong> je ukázáno základní zpracování události typu
<strong>sdljava.event.SDLResizeEvent</strong>. Nejprve je provedena
inicializace grafického subsystému s&nbsp;vyu¾itím pøíznaku
<strong>SDLVideo.SDL_RESIZABLE</strong> a posléze se ve smyèce událostí
detekuje událost typu <strong>sdljava.event.SDLResizeEvent</strong>. Pokud je
tato událost ze smyèky událostí pøeètena, jsou na standardní výstup vypsány
nové rozmìry okna zji¹tìné metodami <strong>SDLResizeEvent.getWidth()</strong>
a <strong>SDLResizeEvent.getHeight()</strong> &ndash; tyto hodnoty pøitom
reprezentují rozmìry vnitøní plochy okna, co¾ je hodnota, která je pro
programátora mnohem dùle¾itìj¹í, ne¾ vnìj¹í rozmìry okna (dekorace oken je
toti¾ zále¾itostí správce oken a nikoli vlastní aplikace). Smyèka událostí
implementovaná v&nbsp;tomto demonstraèním pøíkladu vypadá následovnì:</p>

<pre>
    <i>/**</i>
    <i> * Smycka pro zpracovani udalosti.</i>
    <i> */</i>
    private static void <strong>eventLoop</strong>() throws SDLException {
        while (true) {
            <i>// precist udalost z fronty</i>
            SDLEvent event = SDLEvent.waitEvent();
&nbsp;
            <i>// vyskok ze smycky pro zpracovani udalosti pri vyskytu</i>
            <i>// udalosti typu SDLQuitEvent</i>
            if (event instanceof SDLQuitEvent) {
                return;
            }
&nbsp;
            <i>// stisk ci pusteni klavesy</i>
            if (event instanceof SDLKeyboardEvent) {
                <i>// pretypovani</i>
                final SDLKeyboardEvent keyEvent = (SDLKeyboardEvent)event;
&nbsp;
                <i>// symbol/kod klavesy</i>
                final int symbol = keyEvent.getSym();
&nbsp;
                <i>// ESC ukonci program</i>
                if (symbol == SDLKey.SDLK_ESCAPE &amp;&amp; keyEvent.getState() == SDLPressedState.PRESSED) {
                    return;
                }
            }
&nbsp;
            <i>// zmena velikosti okna</i>
            if (event instanceof SDLResizeEvent) {
                <i>// pretypovani</i>
                final SDLResizeEvent resizeEvent = (SDLResizeEvent)event;
&nbsp;
                <i>// precist novou velikost okna</i>
                final int width = resizeEvent.getWidth();
                final int height = resizeEvent.getHeight();
&nbsp;
                <i>// vypsat informaci o zmene velikosti okna</i>
                System.out.format("Window resized to: %dx%d pixels.\n", width, height);
            }
&nbsp;
        }
    }
</pre>

<p>Podívejme se nyní na úplný zdrojový kód demonstraèního pøíkladu
<strong>SDLTest36</strong>:</p>

<pre>
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.event.SDLEvent;
import sdljava.event.SDLKeyboardEvent;
import sdljava.event.SDLResizeEvent;
import sdljava.event.SDLKey;
import sdljava.event.SDLQuitEvent;
import sdljava.video.SDLVideo;
&nbsp;
import sdljava.x.swig.SDLPressedState;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Tricaty sesty demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> *</i>
<i> * Prace s udalosti typu SDLResizeEvent.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>SDLTest36</strong> {
&nbsp;
    <i>/**</i>
    <i> * Horizontalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_WIDTH</strong> = 320;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_HEIGHT</strong> = 240;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka vybraneho grafickeho rezimu.</i>
    <i> * (0 znamena automaticky vyber, ovsem lze samozrejme pouzit</i>
    <i> * i hodnoty 8, 16, 24 ci 32, podle vlastnosti graficke karty)</i>
    <i> */</i>
    private static final int <strong>GFX_BPP</strong> = 0;
&nbsp;
    <i>/**</i>
    <i> * Inicializace grafickeho rezimu ci otevreni okna pro vykreslovani.</i>
    <i> */</i>
    private static void <strong>initVideo</strong>() throws SDLException {
        <i>// potrebujeme vytvorit okno, u ktereho je mozne menit jeho velikost.</i>
        final long flags = SDLVideo.SDL_DOUBLEBUF | SDLVideo.SDL_RESIZABLE;
        SDLVideo.setVideoMode(GFX_WIDTH, GFX_HEIGHT, GFX_BPP, flags);
    }
&nbsp;
    <i>/**</i>
    <i> * Smycka pro zpracovani udalosti.</i>
    <i> */</i>
    private static void <strong>eventLoop</strong>() throws SDLException {
        while (true) {
            <i>// precist udalost z fronty</i>
            SDLEvent event = SDLEvent.waitEvent();
&nbsp;
            <i>// vyskok ze smycky pro zpracovani udalosti pri vyskytu</i>
            <i>// udalosti typu SDLQuitEvent</i>
            if (event instanceof SDLQuitEvent) {
                return;
            }
&nbsp;
            <i>// stisk ci pusteni klavesy</i>
            if (event instanceof SDLKeyboardEvent) {
                <i>// pretypovani</i>
                final SDLKeyboardEvent keyEvent = (SDLKeyboardEvent)event;
&nbsp;
                <i>// symbol/kod klavesy</i>
                final int symbol = keyEvent.getSym();
&nbsp;
                <i>// ESC ukonci program</i>
                if (symbol == SDLKey.SDLK_ESCAPE &amp;&amp; keyEvent.getState() == SDLPressedState.PRESSED) {
                    return;
                }
            }
&nbsp;
            <i>// zmena velikosti okna</i>
            if (event instanceof SDLResizeEvent) {
                <i>// pretypovani</i>
                final SDLResizeEvent resizeEvent = (SDLResizeEvent)event;
&nbsp;
                <i>// precist novou velikost okna</i>
                final int width = resizeEvent.getWidth();
                final int height = resizeEvent.getHeight();
&nbsp;
                <i>// vypsat informaci o zmene velikosti okna</i>
                System.out.format("Window resized to: %dx%d pixels.\n", width, height);
            }
&nbsp;
        }
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni osmeho demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace knihovny SDLJava</i>
            SDLMain.init(SDLMain.SDL_INIT_EVERYTHING);
&nbsp;
            <i>// inicializace grafickeho rezimu ci otevreni okna pro vykreslovani</i>
            initVideo();
&nbsp;
            <i>// smycka pro zpracovani udalosti</i>
            eventLoop();
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
    }
&nbsp;
}
</pre>

<p>Skript pro pøeklad na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest36.java
</pre>

<p>Dávkový soubor pro pøeklad na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest36.java
</pre>

<p>Skript pro spu¹tìní na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
java -cp .:$SDL_JAVA_LIBS/sdljava.jar -Djava.library.path=$SDL_JAVA_LIBS SDLTest36
</pre>

<p>Dávkový soubor pro spu¹tìní na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest36
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Vykreslovací plocha pøi zmìnì velikosti okna aplikace</h2>

<p>Pøi zmìnì velikosti okna aplikace je sice korektnì vytvoøena událost typu
<strong>sdljava.event.SDLResizeEvent</strong>, která je následnì vlo¾ena do
fronty událostí, ov¹em dal¹í operace za programátora knihovna <i>SDL</i> ani
knihovna <i>SDLJava</i> automaticky neudìlá. Na toto chování je zapotøebí si
dávat pozor, proto¾e dokonce ani nedojde k&nbsp;modifikaci primární
vykreslovací plochy (<strong>SDLSurface</strong>) vytvoøené døíve voláním
<strong>SDLVideo.setVideoMode(width, height, bpp, flags);</strong>. To
mj.&nbsp;znamená, ¾e rozmìry primární vykreslovací plochy zùstanou stále
stejné, co¾ ve výsledku povede k&nbsp;tomu, ¾e se pøi zmìnì velikosti okna buï
nevykreslí celá scéna (èást jí bude zakryta), èi se naopak v&nbsp;èásti okna
zobrazí jen nemìnné pozadí. Takové &ndash; vìt¹inou neoèekávané &ndash; chování
aplikace je ukázáno na následující trojici obrázkù, v&nbsp;nich¾ je pùvodní
velikost okna i pùvodní velikost primární vykreslovací plochy rovna
320&times;240 pixelùm:</p>

<img src="http://i.iinfo.cz/images/547/java001.png" class="image-164360" width="320" height="240" alt="&#160;" />
<p><i>Obrázek 1: Originální scéna vykreslená do okna o vnitøních rozmìrech
320&times;200 pixelù.</i></p>

<img src="http://i.iinfo.cz/images/649/java002.png" class="image-164361" width="442" height="248" alt="&#160;" />
<p><i>Obrázek 2: Tatá¾ scéna, ov¹em pøi zmìnì vnitøních rozmìrù okna na
442&times;248 pixelù.</i></p>

<img src="http://i.iinfo.cz/images/259/java003.png" class="image-164362" width="204" height="303" alt="&#160;" />
<p><i>Obrázek 3: Stále tatá¾ scéna, ov¹em pøi zmìnì vnitøních rozmìrù okna na
204&times;303 pixelù.</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Demonstraèní pøíklad <strong>SDLTest37</strong>: vykreslování do okna s&nbsp;mìnitelnými rozmìry</h2>

<p>Chování popsané v&nbsp;pøedchozí kapitole je názornì ukázáno na dne¹ním
druhém demonstraèním pøíkladu nazvaném <strong>SDLTest37</strong>. Po spu¹tìní
tohoto pøíkladu se provede inicializace grafického re¾imu v&nbsp;metodì
<strong>initVideo()</strong>. Vykreslení scény je provedeno v&nbsp;dal¹í metodì
<strong>drawOnScreen()</strong>, která sice korektnì vypoète velikosti
vykreslovaných obdélníkù z&nbsp;rozmìrù primární kreslicí plochy, ov¹em jak ji¾
z&nbsp;pøedchozí kapitoly víme, nejsou tyto rozmìry automaticky aktualizovány.
To mj.&nbsp;znamená, ¾e se v&nbsp;metodì <strong>drawOnScreen()</strong> scéna
stále vykresluje do plochy o rozmìrech 320&times;240 pixelù:</p>

<pre>
    <i>/**</i>
    <i> * Vykresleni obdelniku na obrazovku.</i>
    <i> */</i>
    private static void <strong>drawOnScreen</strong>() throws SDLException {
        <i>// ziskat rozmery obrazovky</i>
        final int width = screen.getWidth();
        final int height = screen.getHeight();
&nbsp;
        <i>// barva vykreslovani</i>
        long color;
&nbsp;
        <i>// vymazat pozadi</i>
        color = screen.mapRGB(0, 100, 0);
        rect.x = BORDER;
        rect.y = BORDER;
        rect.width = width - BORDER * 2;
        rect.height = height - BORDER * 2;
        screen.fillRect(rect, color);
&nbsp;
        <i>// vykreslit obdelnik na obrazovku</i>
        color = screen.mapRGB(255, 255, 64);
        rect.x = width &gt;&gt; 2;
        rect.y = height &gt;&gt; 2;
        rect.width = width &gt;&gt; 1;
        rect.height = height &gt;&gt; 1;
        screen.fillRect(rect, color);
&nbsp;
        <i>// nutno volat i v pripade, ze neni pouzit double buffering</i>
        screen.flip();
    }
</pre>

<p>Za zmínku zde stojí upozornìní na to, ¾e objekt typu
<strong>SDLRect</strong> je v&nbsp;celé aplikaci vytvoøen jen jedenkrát pøi
inicializaci tøídy, co¾ znamená, ¾e se pøi pøekreslení scény nebude zbyteènì
vytváøet dal¹í objekt, který by bylo následnì nutné dealokovat správcem pamìti
(GC). Podobným zpùsobem, který ov¹em ponìkud odporuje principùm tvorby programù
se zaji¹tìním lokality promìnných, lze zajistit bezproblémový bìh aplikace ve
virtuálním stroji Javy, který nebude nucen èasto spou¹tìt správce pamìti (ani
knihovna <i>SDLJava</i> zbyteènì nevytváøí nové objekty, a to dokonce ani pøi
vzniku události).</p>

<p>Následuje úplný výpis zdrojového kódu demonstraèního pøíkladu
<strong>SDLTest37</strong>:</p>


<pre>
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.event.SDLEvent;
import sdljava.event.SDLKeyboardEvent;
import sdljava.event.SDLResizeEvent;
import sdljava.event.SDLKey;
import sdljava.event.SDLQuitEvent;
import sdljava.video.SDLSurface;
import sdljava.video.SDLRect;
import sdljava.video.SDLVideo;
&nbsp;
import sdljava.x.swig.SDLPressedState;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Tricaty sedmy demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> *</i>
<i> * Prace s udalosti typu SDLResizeEvent - vykreslovani do okna s menitelnymi rozmery.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>SDLTest37</strong> {
&nbsp;
    <i>/**</i>
    <i> * Horizontalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_WIDTH</strong> = 320;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_HEIGHT</strong> = 240;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka vybraneho grafickeho rezimu.</i>
    <i> * (0 znamena automaticky vyber, ovsem lze samozrejme pouzit</i>
    <i> * i hodnoty 8, 16, 24 ci 32, podle vlastnosti graficke karty)</i>
    <i> */</i>
    private static final int <strong>GFX_BPP</strong> = 0;
&nbsp;
    <i>/**</i>
    <i> * Okraje uvnitr okna, ktere zustanou cerne.</i>
    <i> */</i>
    private static final int <strong>BORDER</strong> = 10;
&nbsp;
    <i>/**</i>
    <i> * Objekt predsavujici kreslici plochu.</i>
    <i> */</i>
    private static SDLSurface screen = null;
&nbsp;
    <i>/**</i>
    <i> * Promenna vyuzivana pri prekreslovani - nema smysl zbytecne trapit GC.</i>
    <i> */</i>
    private static SDLRect rect = new SDLRect();
&nbsp;
    <i>/**</i>
    <i> * Inicializace grafickeho rezimu ci otevreni okna pro vykreslovani.</i>
    <i> */</i>
    private static void <strong>initVideo</strong>() throws SDLException {
        <i>// potrebujeme vytvorit okno, u ktereho je mozne menit jeho velikost.</i>
        final long flags = SDLVideo.SDL_DOUBLEBUF | SDLVideo.SDL_RESIZABLE;
        screen = SDLVideo.setVideoMode(GFX_WIDTH, GFX_HEIGHT, GFX_BPP, flags);
    }
&nbsp;
    <i>/**</i>
    <i> * Vykresleni obdelniku na obrazovku.</i>
    <i> */</i>
    private static void <strong>drawOnScreen</strong>() throws SDLException {
        <i>// ziskat rozmery obrazovky</i>
        final int width = screen.getWidth();
        final int height = screen.getHeight();
&nbsp;
        <i>// barva vykreslovani</i>
        long color;
&nbsp;
        <i>// vymazat pozadi</i>
        color = screen.mapRGB(0, 100, 0);
        rect.x = BORDER;
        rect.y = BORDER;
        rect.width = width - BORDER * 2;
        rect.height = height - BORDER * 2;
        screen.fillRect(rect, color);
&nbsp;
        <i>// vykreslit obdelnik na obrazovku</i>
        color = screen.mapRGB(255, 255, 64);
        rect.x = width &gt;&gt; 2;
        rect.y = height &gt;&gt; 2;
        rect.width = width &gt;&gt; 1;
        rect.height = height &gt;&gt; 1;
        screen.fillRect(rect, color);
&nbsp;
        <i>// nutno volat i v pripade, ze neni pouzit double buffering</i>
        screen.flip();
    }
&nbsp;
    <i>/**</i>
    <i> * Smycka pro zpracovani udalosti.</i>
    <i> */</i>
    private static void <strong>eventLoop</strong>() throws SDLException {
        while (true) {
            <i>// precist udalost z fronty</i>
            SDLEvent event = SDLEvent.waitEvent();
&nbsp;
            <i>// vyskok ze smycky pro zpracovani udalosti pri vyskytu</i>
            <i>// udalosti typu SDLQuitEvent</i>
            if (event instanceof SDLQuitEvent) {
                return;
            }
&nbsp;
            <i>// stisk ci pusteni klavesy</i>
            if (event instanceof SDLKeyboardEvent) {
                <i>// pretypovani</i>
                final SDLKeyboardEvent keyEvent = (SDLKeyboardEvent)event;
&nbsp;
                <i>// symbol/kod klavesy</i>
                final int symbol = keyEvent.getSym();
&nbsp;
                <i>// ESC ukonci program</i>
                if (symbol == SDLKey.SDLK_ESCAPE &amp;&amp; keyEvent.getState() == SDLPressedState.PRESSED) {
                    return;
                }
            }
&nbsp;
            <i>// zmena velikosti okna</i>
            if (event instanceof SDLResizeEvent) {
                <i>// pretypovani</i>
                final SDLResizeEvent resizeEvent = (SDLResizeEvent)event;
&nbsp;
                <i>// precist novou velikost okna</i>
                final int width = resizeEvent.getWidth();
                final int height = resizeEvent.getHeight();
&nbsp;
                <i>// vypsat informaci o zmene velikosti okna</i>
                System.out.format("Window resized to: %dx%d pixels.\n", width, height);
            }
&nbsp;
        }
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni osmeho demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace knihovny SDLJava</i>
            SDLMain.init(SDLMain.SDL_INIT_EVERYTHING);
&nbsp;
            <i>// inicializace grafickeho rezimu ci otevreni okna pro vykreslovani</i>
            initVideo();
&nbsp;
            <i>// vykresleni sceny</i>
            drawOnScreen();
&nbsp;
            <i>// smycka pro zpracovani udalosti</i>
            eventLoop();
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
    }
&nbsp;
}
</pre>

<p>Skript pro pøeklad na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest37.java
</pre>

<p>Dávkový soubor pro pøeklad na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest37.java
</pre>

<p>Skript pro spu¹tìní na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
java -cp .:$SDL_JAVA_LIBS/sdljava.jar -Djava.library.path=$SDL_JAVA_LIBS SDLTest37
</pre>

<p>Dávkový soubor pro spu¹tìní na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest37
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Korektní zpùsob reakce na zmìnu velikosti okna aplikace</h2>

<p>Aby aplikace dokázala korektnì reagovat na zmìnu velikosti okna, je nutné,
aby se po ka¾dém pøijetí události typu
<strong>sdljava.event.SDLResizeEvent</strong> znovu inicializoval grafický
re¾im a aby se tím pádem vytvoøila nová primární kreslicí plocha. Metodu
<strong>initVideo()</strong> je tedy nutné upravit tak, aby jako své parametry
akceptovala po¾adované rozmìry kreslicí plochy:</p>

<pre>
    <i>/**</i>
    <i> * Inicializace grafickeho rezimu ci otevreni okna pro vykreslovani.</i>
    <i> */</i>
    private static void <strong>initVideo</strong>(int width, int height) throws SDLException {
        <i>// potrebujeme vytvorit okno, u ktereho je mozne menit jeho velikost.</i>
        final long flags = SDLVideo.SDL_DOUBLEBUF | SDLVideo.SDL_RESIZABLE;
        screen = SDLVideo.setVideoMode(width, height, GFX_BPP, flags);
    }
</pre>

<p>Následnì se musí ve smyèce událostí po zmìnì velikosti okna vytvoøit nová
primární kreslicí plocha, pøièem¾ je korektní pùvodní plochu dealokovat metodou
<strong>SDLScreen.freeSurface()</strong>. Ihned poté se obsah okna musí
pøekreslit voláním metody <strong>drawOnScreen()</strong>:</p>

<pre>
    <i>/**</i>
    <i> * Smycka pro zpracovani udalosti.</i>
    <i> */</i>
    private static void <strong>eventLoop</strong>() throws SDLException {
        while (true) {
            <i>// precist udalost z fronty</i>
            SDLEvent event = SDLEvent.waitEvent();
&nbsp;
            <i>// vyskok ze smycky pro zpracovani udalosti pri vyskytu</i>
            <i>// udalosti typu SDLQuitEvent</i>
            if (event instanceof SDLQuitEvent) {
                return;
            }
&nbsp;
            <i>// stisk ci pusteni klavesy</i>
            if (event instanceof SDLKeyboardEvent) {
                <i>// pretypovani</i>
                final SDLKeyboardEvent keyEvent = (SDLKeyboardEvent)event;
&nbsp;
                <i>// symbol/kod klavesy</i>
                final int symbol = keyEvent.getSym();
&nbsp;
                <i>// ESC ukonci program</i>
                if (symbol == SDLKey.SDLK_ESCAPE &amp;&amp; keyEvent.getState() == SDLPressedState.PRESSED) {
                    return;
                }
            }
&nbsp;
            <i>// zmena velikosti okna</i>
            if (event instanceof SDLResizeEvent) {
                <i>// pretypovani</i>
                final SDLResizeEvent resizeEvent = (SDLResizeEvent)event;
&nbsp;
                <i>// precist novou velikost okna</i>
                final int width = resizeEvent.getWidth();
                final int height = resizeEvent.getHeight();
&nbsp;
                <i>// vypsat informaci o zmene velikosti okna</i>
                System.out.format("Window resized to: %dx%d pixels.\n", width, height);
&nbsp;
                <i>// vytvoreni nove kreslici plochy a prekresleni cele sceny</i>
                screen.freeSurface();
                initVideo(width, height);
                drawOnScreen();
            }
&nbsp;
        }
    }
</pre>

<img src="http://i.iinfo.cz/images/649/java004.png" class="image-164363" width="320" height="240" alt="&#160;" />
<p><i>Obrázek 4: Originální scéna vykreslená do okna o vnitøních rozmìrech
320&times;200 pixelù.</i></p>

<img src="http://i.iinfo.cz/images/498/java005.png" class="image-164364" width="468" height="214" alt="&#160;" />
<p><i>Obrázek 5: Tatá¾ scéna, ov¹em pøi zmìnì vnitøních rozmìrù okna na
468&times;214 pixelù.</i></p>

<img src="http://i.iinfo.cz/images/44/java006.png" class="image-164365" width="204" height="380" alt="&#160;" />
<p><i>Obrázek 6: Stále tatá¾ scéna, ov¹em pøi zmìnì vnitøních rozmìrù okna na
204&times;380 pixelù.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Demonstraèní pøíklad <strong>SDLTest38</strong>: korektní zpùsob reakce na zmìnu velikosti okna aplikace</h2>

<p>Po úpravì zdrojového kódu demonstraèního pøíkladu <strong>SDLTest37</strong>
podle popisu <a href="#k06">z&nbsp;pøedchozí kapitoly</a> získáme novou
aplikaci s&nbsp;odli¹ným chováním, která je zde pojmenována
<strong>SDLTest38</strong>. Pov¹imnìte si, ¾e zmìny ve zdrojovém kódu aplikace
jsou v&nbsp;tomto pøípadì minimální, ov¹em v&nbsp;reálných programech by bylo
nutné provést mnohem vìt¹í zásahy, a to zejména v&nbsp;metodì, v&nbsp;ní¾ se má
pøekreslit obsah okna (tj.&nbsp;napøíklad kde se má vykreslit celý herní svìt).
Z&nbsp;tohoto dùvodu je nutné peèlivì zvá¾it, zda se má vùbec povolit zmìna
velikosti okna s&nbsp;vykreslovanou scénou èi zda bude mít okno nemìnné
rozmìry:</p>

<pre>
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.event.SDLEvent;
import sdljava.event.SDLKeyboardEvent;
import sdljava.event.SDLResizeEvent;
import sdljava.event.SDLKey;
import sdljava.event.SDLQuitEvent;
import sdljava.video.SDLSurface;
import sdljava.video.SDLRect;
import sdljava.video.SDLVideo;
&nbsp;
import sdljava.x.swig.SDLPressedState;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Tricaty osmy demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> *</i>
<i> * Prace s udalosti typu SDLResizeEvent - vykreslovani do okna s menitelnymi rozmery.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>SDLTest38</strong> {
&nbsp;
    <i>/**</i>
    <i> * Horizontalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_WIDTH</strong> = 320;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_HEIGHT</strong> = 240;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka vybraneho grafickeho rezimu.</i>
    <i> * (0 znamena automaticky vyber, ovsem lze samozrejme pouzit</i>
    <i> * i hodnoty 8, 16, 24 ci 32, podle vlastnosti graficke karty)</i>
    <i> */</i>
    private static final int <strong>GFX_BPP</strong> = 0;
&nbsp;
    <i>/**</i>
    <i> * Okraje uvnitr okna, ktere zustanou cerne.</i>
    <i> */</i>
    private static final int <strong>BORDER</strong> = 10;
&nbsp;
    <i>/**</i>
    <i> * Objekt predsavujici kreslici plochu.</i>
    <i> */</i>
    private static SDLSurface screen = null;
&nbsp;
    <i>/**</i>
    <i> * Promenna vyuzivana pri prekreslovani - nema smysl zbytecne trapit GC.</i>
    <i> */</i>
    private static SDLRect rect = new SDLRect();
&nbsp;
    <i>/**</i>
    <i> * Inicializace grafickeho rezimu ci otevreni okna pro vykreslovani.</i>
    <i> */</i>
    private static void <strong>initVideo</strong>(int width, int height) throws SDLException {
        <i>// potrebujeme vytvorit okno, u ktereho je mozne menit jeho velikost.</i>
        final long flags = SDLVideo.SDL_DOUBLEBUF | SDLVideo.SDL_RESIZABLE;
        screen = SDLVideo.setVideoMode(width, height, GFX_BPP, flags);
    }
&nbsp;
    <i>/**</i>
    <i> * Vykresleni obdelniku na obrazovku.</i>
    <i> */</i>
    private static void <strong>drawOnScreen</strong>() throws SDLException {
        <i>// ziskat rozmery obrazovky</i>
        final int width = screen.getWidth();
        final int height = screen.getHeight();
&nbsp;
        <i>// barva vykreslovani</i>
        long color;
&nbsp;
        <i>// vymazat pozadi</i>
        color = screen.mapRGB(0, 100, 0);
        rect.x = BORDER;
        rect.y = BORDER;
        rect.width = width - BORDER * 2;
        rect.height = height - BORDER * 2;
        screen.fillRect(rect, color);
&nbsp;
        <i>// vykreslit obdelnik na obrazovku</i>
        color = screen.mapRGB(255, 255, 64);
        rect.x = width &gt;&gt; 2;
        rect.y = height &gt;&gt; 2;
        rect.width = width &gt;&gt; 1;
        rect.height = height &gt;&gt; 1;
        screen.fillRect(rect, color);
&nbsp;
        <i>// nutno volat i v pripade, ze neni pouzit double buffering</i>
        screen.flip();
    }
&nbsp;
    <i>/**</i>
    <i> * Smycka pro zpracovani udalosti.</i>
    <i> */</i>
    private static void <strong>eventLoop</strong>() throws SDLException {
        while (true) {
            <i>// precist udalost z fronty</i>
            SDLEvent event = SDLEvent.waitEvent();
&nbsp;
            <i>// vyskok ze smycky pro zpracovani udalosti pri vyskytu</i>
            <i>// udalosti typu SDLQuitEvent</i>
            if (event instanceof SDLQuitEvent) {
                return;
            }
&nbsp;
            <i>// stisk ci pusteni klavesy</i>
            if (event instanceof SDLKeyboardEvent) {
                <i>// pretypovani</i>
                final SDLKeyboardEvent keyEvent = (SDLKeyboardEvent)event;
&nbsp;
                <i>// symbol/kod klavesy</i>
                final int symbol = keyEvent.getSym();
&nbsp;
                <i>// ESC ukonci program</i>
                if (symbol == SDLKey.SDLK_ESCAPE &amp;&amp; keyEvent.getState() == SDLPressedState.PRESSED) {
                    return;
                }
            }
&nbsp;
            <i>// zmena velikosti okna</i>
            if (event instanceof SDLResizeEvent) {
                <i>// pretypovani</i>
                final SDLResizeEvent resizeEvent = (SDLResizeEvent)event;
&nbsp;
                <i>// precist novou velikost okna</i>
                final int width = resizeEvent.getWidth();
                final int height = resizeEvent.getHeight();
&nbsp;
                <i>// vypsat informaci o zmene velikosti okna</i>
                System.out.format("Window resized to: %dx%d pixels.\n", width, height);
&nbsp;
                <i>// vytvoreni nove kreslici plochy a prekresleni cele sceny</i>
                screen.freeSurface();
                initVideo(width, height);
                drawOnScreen();
            }
&nbsp;
        }
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni osmeho demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace knihovny SDLJava</i>
            SDLMain.init(SDLMain.SDL_INIT_EVERYTHING);
&nbsp;
            <i>// inicializace grafickeho rezimu ci otevreni okna pro vykreslovani</i>
            initVideo(GFX_WIDTH, GFX_HEIGHT);
&nbsp;
            <i>// vykresleni sceny</i>
            drawOnScreen();
&nbsp;
            <i>// smycka pro zpracovani udalosti</i>
            eventLoop();
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
    }
&nbsp;
}
</pre>

<p>Skript pro pøeklad na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest38.java
</pre>

<p>Dávkový soubor pro pøeklad na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest38.java
</pre>

<p>Skript pro spu¹tìní na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
java -cp .:$SDL_JAVA_LIBS/sdljava.jar -Djava.library.path=$SDL_JAVA_LIBS SDLTest38
</pre>

<p>Dávkový soubor pro spu¹tìní na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest38
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Událost typu <strong>sdljava.event.SDLActiveEvent</strong></h2>

<p>Posledním typem události, s&nbsp;ním¾ se v&nbsp;dne¹ním èlánku seznámíme, je
událost reprezentovaná instancí tøídy
<strong>sdljava.event.SDLActiveEvent</strong>. Tato událost mù¾e vzniknout
v&nbsp;nìkolika pøípadech, zejména pøi získání èi naopak ztrátì fokusu
klávesnice (tj.&nbsp;pøi zmìnì okna, do nìho¾ budou pøená¹eny stisky kláves) a
takté¾ ve chvíli, kdy kurzor my¹i opustí plochu okna aplikace popø.&nbsp;se do
této plochy vrátí. Zpùsob reakce na tento typ událostí závisí èistì na logice
aplikace &ndash; mù¾e být pomìrnì rozumné pozastavit hru ve chvíli, kdy je
ztracen fokus klávesnice, napøíklad vlivem zobrazení nìjakého modálního dialogu
nebo pøi ruèním pøepnutí aktivního okna atd. Aby aplikace správnì rozeznala,
jaký typ události pøesnì vznikl, je nutné pou¾ít následující dvojici pøíkazù
pro získání pøesného typu události:</p>

<pre>
final int type = activeEvent.getSwigActiveEvent().getState();
final boolean gain = activeEvent.getSwigActiveEvent().getGain() == 1;
</pre>

<p>Promìnná type mù¾e nabývat tøí hodnot:</p>

<table>
<tr><th>Type</th><th>Význam</th></tr>
<tr><td>SDLActiveEvent.SDL_APPACTIVE</td><td>aktivace èi deaktivace celé aplikace (systémovì závislé)</td></tr>
<tr><td>SDLActiveEvent.SDL_APPINPUTFOCUS</td><td>získání èi ztráta fokusu klávesnice</td></tr>
<tr><td>SDLActiveEvent.SDL_APPMOUSEFOCUS</td><td>kurzor opustil plochu okna èi se do okna naopak vrátil</td></tr>
</table>

<p>Rozli¹ení mezi získáním èi ztrátou fokusu atd. je samozøejmì provedeno
v&nbsp;závislosti na hodnotì promìnné <strong>gain</strong>.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Demonstraèní pøíklad <strong>SDLTest39</strong>: detekce získání a ztracení fokusu a detekce pøesunu kurzoru my¹i do plochy okna aplikace</h2>

<p><a href="#k08">V&nbsp;pøedchozí kapitole</a> popsaný zpùsob pøeètení
informací o ztrátì nebo naopak o získání fokusu klávesnice/my¹i je
implementován v&nbsp;dne¹ním posledním demonstraèním pøíkladu nazvaném
<strong>SDLTest39</strong>, jeho¾ zdrojový kód je zobrazen pod tímto odstavcem.
Pro jednoduchost je výpis pøesného typu událostí implementován
v&nbsp;rozhodovací konstrukci <strong>switch-case</strong>, která je
v&nbsp;bajtkódu ulo¾ena efektivním zpùsobem a JIT pøekladaè tuto konstrukci
takté¾ doká¾ou efektivnì pøelo¾it (vìt¹inou lépe ne¾ sekvenci pøíkazù
<strong>if-then-else</strong>):</p>

<pre>
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.event.SDLActiveEvent;
import sdljava.event.SDLEvent;
import sdljava.event.SDLKeyboardEvent;
import sdljava.event.SDLKey;
import sdljava.event.SDLQuitEvent;
import sdljava.video.SDLVideo;
&nbsp;
import sdljava.x.swig.SDL_ActiveEvent;
import sdljava.x.swig.SDLPressedState;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Tricaty devaty demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> *</i>
<i> * Zaklad prace s udalosti typu SDLActiveEvent.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>SDLTest39</strong> {
&nbsp;
    <i>/**</i>
    <i> * Horizontalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_WIDTH</strong> = 320;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_HEIGHT</strong> = 240;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka vybraneho grafickeho rezimu.</i>
    <i> * (0 znamena automaticky vyber, ovsem lze samozrejme pouzit</i>
    <i> * i hodnoty 8, 16, 24 ci 32, podle vlastnosti graficke karty)</i>
    <i> */</i>
    private static final int <strong>GFX_BPP</strong> = 0;
&nbsp;
    <i>/**</i>
    <i> * Inicializace grafickeho rezimu ci otevreni okna pro vykreslovani.</i>
    <i> */</i>
    private static void <strong>initVideo</strong>() throws SDLException {
        final long flags = SDLVideo.SDL_DOUBLEBUF;
        SDLVideo.setVideoMode(GFX_WIDTH, GFX_HEIGHT, GFX_BPP, flags);
    }
&nbsp;
    <i>/**</i>
    <i> * Smycka pro zpracovani udalosti.</i>
    <i> */</i>
    private static void <strong>eventLoop</strong>() throws SDLException {
        while (true) {
            <i>// precist udalost z fronty</i>
            SDLEvent event = SDLEvent.waitEvent();
&nbsp;
            <i>// vyskok ze smycky pro zpracovani udalosti pri vyskytu</i>
            <i>// udalosti typu SDLQuitEvent</i>
            if (event instanceof SDLQuitEvent) {
                return;
            }
&nbsp;
            <i>// stisk ci pusteni klavesy</i>
            if (event instanceof SDLKeyboardEvent) {
                <i>// pretypovani</i>
                final SDLKeyboardEvent keyEvent = (SDLKeyboardEvent)event;
&nbsp;
                <i>// symbol/kod klavesy</i>
                final int symbol = keyEvent.getSym();
&nbsp;
                <i>// ESC ukonci program</i>
                if (symbol == SDLKey.SDLK_ESCAPE &amp;&amp; keyEvent.getState() == SDLPressedState.PRESSED) {
                    return;
                }
            }
&nbsp;
            if (event instanceof SDLActiveEvent) {
                <i>// pretypovani</i>
                final SDLActiveEvent activeEvent = (SDLActiveEvent)event;
&nbsp;
                <i>// precist typ udalosti</i>
                final int type = activeEvent.getSwigActiveEvent().getState();
&nbsp;
                <i>// ziskala aplikace fokus/kurzor mysi ci ji ztratila?</i>
                final boolean gain = activeEvent.getSwigActiveEvent().getGain() == 1;
&nbsp;
                switch (type) {
                    case SDLActiveEvent.SDL_APPACTIVE:
                        System.out.println("The application is " + (gain ? "" : "in") + "active");
                        break;
                    case SDLActiveEvent.SDL_APPINPUTFOCUS:
                        System.out.println("The application has " + (gain ? "gain" : "lost") + " input focus");
                        break;
                    case SDLActiveEvent.SDL_APPMOUSEFOCUS:
                        System.out.println("The application has " + (gain ? "gain" : "lost") + " mouse coverage");
                        break;
                    default:
                        System.out.println("Unknown SDLActiveEvent type!");
                        break;
                }
            }
        }
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni osmeho demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace knihovny SDLJava</i>
            SDLMain.init(SDLMain.SDL_INIT_VIDEO);
&nbsp;
            <i>// inicializace grafickeho rezimu ci otevreni okna pro vykreslovani</i>
            initVideo();
&nbsp;
            <i>// smycka pro zpracovani udalosti</i>
            eventLoop();
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
    }
&nbsp;
}
</pre>

<p>Skript pro pøeklad na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest39.java
</pre>

<p>Dávkový soubor pro pøeklad na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest39.java
</pre>

<p>Skript pro spu¹tìní na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
java -cp .:$SDL_JAVA_LIBS/sdljava.jar -Djava.library.path=$SDL_JAVA_LIBS SDLTest39
</pre>

<p>Dávkový soubor pro spu¹tìní na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest39
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Repositáø se zdrojovými kódy v¹ech ètyø dne¹ních demonstraèních pøíkladù</h2>

<p>V¹echny ètyøi dnes popsané demonstraèní pøíklady byly spoleènì
s&nbsp;podpùrnými skripty urèenými pro jejich pøeklad a následné spu¹tìní
ulo¾eny do Mercurial repositáøe dostupného na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
Podobnì jako tomu bylo i v&nbsp;pøedchozích osmi dílech tohoto seriálu, i ke
dne¹ním pøíkladùm jsou pøilo¾eny skripty vyu¾itelné pro jejich pøeklad a
spu¹tìní. Navíc byly pøidány i skripty vyu¾itelné ve Windows:</p>

<table>
<tr><th> #</th><th>Zdrojový soubor/skript</th><th>Umístìní souboru v&nbsp;repositáøi</th></tr>
<tr><td> 1</td><td>SDLTest36.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest36/SDLTest36.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest36/SDLTest36.java</a></td></tr>
<tr><td> 2</td><td>SDLTest36_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest36/SDLTest36_compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest36/SDLTest36_compile.sh</a></td></tr>
<tr><td> 3</td><td>SDLTest36_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest36/SDLTest36_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest36/SDLTest36_compile_sys.sh</a></td></tr>
<tr><td> 4</td><td>SDLTest36_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest36/SDLTest36_run.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest36/SDLTest36_run.sh</a></td></tr>
<tr><td> 5</td><td>SDLTest36_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest36/SDLTest36_run_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest36/SDLTest36_run_sys.sh</a></td></tr>
<tr><td> 6</td><td>SDLTest36_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest36/SDLTest36_compile.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest36/SDLTest36_compile.bat</a></td></tr>
<tr><td> 7</td><td>SDLTest36_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest36/SDLTest36_run.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest36/SDLTest36_run.bat</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>SDLTest37.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest37/SDLTest37.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest37/SDLTest37.java</a></td></tr>
<tr><td> 9</td><td>SDLTest37_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest37/SDLTest37_compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest37/SDLTest37_compile.sh</a></td></tr>
<tr><td>10</td><td>SDLTest37_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest37/SDLTest37_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest37/SDLTest37_compile_sys.sh</a></td></tr>
<tr><td>11</td><td>SDLTest37_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest37/SDLTest37_run.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest37/SDLTest37_run.sh</a></td></tr>
<tr><td>12</td><td>SDLTest37_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest37/SDLTest37_run_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest37/SDLTest37_run_sys.sh</a></td></tr>
<tr><td>13</td><td>SDLTest37_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest37/SDLTest37_compile.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest37/SDLTest37_compile.bat</a></td></tr>
<tr><td>14</td><td>SDLTest37_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest37/SDLTest37_run.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest37/SDLTest37_run.bat</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>SDLTest38.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest38/SDLTest38.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest38/SDLTest38.java</a></td></tr>
<tr><td>16</td><td>SDLTest38_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest38/SDLTest38_compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest38/SDLTest38_compile.sh</a></td></tr>
<tr><td>17</td><td>SDLTest38_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest38/SDLTest38_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest38/SDLTest38_compile_sys.sh</a></td></tr>
<tr><td>18</td><td>SDLTest38_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest38/SDLTest38_run.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest38/SDLTest38_run.sh</a></td></tr>
<tr><td>19</td><td>SDLTest38_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest38/SDLTest38_run_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest38/SDLTest38_run_sys.sh</a></td></tr>
<tr><td>20</td><td>SDLTest38_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest38/SDLTest38_compile.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest38/SDLTest38_compile.bat</a></td></tr>
<tr><td>21</td><td>SDLTest38_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest38/SDLTest38_run.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest38/SDLTest38_run.bat</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>SDLTest39.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest39/SDLTest39.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest39/SDLTest39.java</a></td></tr>
<tr><td>23</td><td>SDLTest39_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest39/SDLTest39_compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest39/SDLTest39_compile.sh</a></td></tr>
<tr><td>24</td><td>SDLTest39_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest39/SDLTest39_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest39/SDLTest39_compile_sys.sh</a></td></tr>
<tr><td>25</td><td>SDLTest39_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest39/SDLTest39_run.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest39/SDLTest39_run.sh</a></td></tr>
<tr><td>26</td><td>SDLTest39_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest39/SDLTest39_run_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest39/SDLTest39_run_sys.sh</a></td></tr>
<tr><td>27</td><td>SDLTest39_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest39/SDLTest39_compile.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest39/SDLTest39_compile.bat</a></td></tr>
<tr><td>28</td><td>SDLTest39_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest39/SDLTest39_run.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/78d3c6eb13b2/sdljava/SDLTest39/SDLTest39_run.bat</a></td></tr>
</table>



<p><a name="k11"></a></p>
<h2 id="k11">11. Odkazy na Internetu</h2>

<ol>

<li>glDrawArrays<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArrays.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArrays.xml</a>
</li>

<li>glDrawElements<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElements.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElements.xml</a>
</li>

<li>glDrawArraysInstanced<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArraysInstanced.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArraysInstanced.xml</a>
</li>

<li>glDrawElementsInstanced<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElementsInstanced.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElementsInstanced.xml</a>
</li>

<li>Root.cz: Seriál Grafická knihovna OpenGL<br />
<a href="http://www.root.cz/serialy/graficka-knihovna-opengl/">http://www.root.cz/serialy/graficka-knihovna-opengl/</a>
</li>

<li>Root.cz: Seriál Tvorba pøenositelných grafických aplikací vyu¾ívajících knihovnu GLUT<br />
<a href="http://www.root.cz/serialy/tvorba-prenositelnych-grafickych-aplikaci-vyuzivajicich-knihovnu-glut/">http://www.root.cz/serialy/tvorba-prenositelnych-grafickych-aplikaci-vyuzivajicich-knihovnu-glut/</a>
</li>

<li>Best Practices for Working with Vertex Data<br />
<a href="https://developer.apple.com/library/ios/documentation/3ddrawing/conceptual/opengles_programmingguide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html">https://developer.apple.com/library/ios/documentation/3ddrawing/conceptual/opengles_programmingguide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_Surface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_PixelFormat<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlpixelformat.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlpixelformat.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_LockSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdllocksurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdllocksurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_UnlockSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlunlocksurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlunlocksurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_LoadBMP<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlloadbmp.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlloadbmp.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_SaveBMP<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsavebmp.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsavebmp.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_BlitSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlblitsurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlblitsurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_VideoInfo<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlvideoinfo.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlvideoinfo.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_GetVideoInfo<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlgetvideoinfo.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlgetvideoinfo.html</a>
</li>

<li>Class BufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferStrategy.html</a>
</li>

<li>Class Graphics<br />
<a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/Graphics.html">http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/Graphics.html</a>
</li>

<li>Double Buffering and Page Flipping<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html</a>
</li>

<li>BufferStrategy and BufferCapabilities<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/bufferstrategy.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/bufferstrategy.html</a>
</li>

<li>Java:Tutorials:Double Buffering<br />
<a href="http://content.gpwiki.org/index.php/Java:Tutorials:Double_Buffering">http://content.gpwiki.org/index.php/Java:Tutorials:Double_Buffering</a>
</li>

<li>Double buffer in standard Java AWT<br />
<a href="http://www.codeproject.com/Articles/2136/Double-buffer-in-standard-Java-AWT">http://www.codeproject.com/Articles/2136/Double-buffer-in-standard-Java-AWT</a>
</li>

<li>Java 2D: Hardware Accelerating - Part 1 - Volatile Images<br />
<a href="http://www.javalobby.org/forums/thread.jspa?threadID=16840&tstart=0">http://www.javalobby.org/forums/thread.jspa?threadID=16840&tstart=0</a>
</li>

<li>Java 2D: Hardware Accelerating - Part 2 - Buffer Strategies<br />
<a href="http://www.javalobby.org/java/forums/t16867.html">http://www.javalobby.org/java/forums/t16867.html</a>
</li>

<li>How does paintComponent work?<br />
<a href="http://stackoverflow.com/questions/15544549/how-does-paintcomponent-work">http://stackoverflow.com/questions/15544549/how-does-paintcomponent-work</a>
</li>

<li>A Swing Architecture Overview<br />
<a href="http://www.oracle.com/technetwork/java/architecture-142923.html">http://www.oracle.com/technetwork/java/architecture-142923.html</a>
</li>

<li>Class javax.swing.JComponent<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html</a>
</li>

<li>Class java.awt.Component<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html</a>
</li>

<li>Class java.awt.Component.BltBufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.BltBufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.BltBufferStrategy.html</a>
</li>

<li>Class java.awt.Component.FlipBufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.FlipBufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.FlipBufferStrategy.html</a>
</li>

<li>Metoda java.awt.Component.isDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html#isDoubleBuffered()">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html#isDoubleBuffered()</a>
</li>

<li>Metoda javax.swing.JComponent.isDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#isDoubleBuffered()">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#isDoubleBuffered()</a>
</li>

<li>Metoda javax.swing.JComponent.setDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#setDoubleBuffered(boolean)">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#setDoubleBuffered(boolean)</a>
</li>

<li>Javadoc - tøída GraphicsDevice<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html</a>
</li>

<li>Javadoc - tøída GraphicsEnvironment<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html</a>
</li>

<li>Javadoc - tøída GraphicsConfiguration<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html</a>
</li>

<li>Javadoc - tøída DisplayMode<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html">http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html</a>
</li>

<li>Lesson: Full-Screen Exclusive Mode API<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/">http://docs.oracle.com/javase/tutorial/extra/fullscreen/</a>
</li>

<li>Full-Screen Exclusive Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html</a>
</li>

<li>Display Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html</a>
</li>

<li>Using the Full-Screen Exclusive Mode API in Java<br />
<a href="http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm">http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>GC safe-point (or safepoint) and safe-region<br />
<a href="http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html">http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html</a>
</li>

<li>Safepoints in HotSpot JVM<br />
<a href="http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html">http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html</a>
</li>

<li>Java theory and practice: Synchronization optimizations in Mustang<br />
<a href="http://www.ibm.com/developerworks/java/library/j-jtp10185/">http://www.ibm.com/developerworks/java/library/j-jtp10185/</a>
</li>

<li>How to build hsdis<br />
<a href="http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README">http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README</a>
</li>

<li>Java SE 6 Performance White Paper<br />
<a href="http://www.oracle.com/technetwork/java/6-performance-137236.html">http://www.oracle.com/technetwork/java/6-performance-137236.html</a>
</li>

<li>Lukas Stadler's Blog<br />
<a href="http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html">http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html</a>
</li>

<li>How to build hsdis-amd64.dll and hsdis-i386.dll on Windows<br />
<a href="http://dropzone.nfshost.com/hsdis.htm">http://dropzone.nfshost.com/hsdis.htm</a>
</li>

<li>PrintAssembly<br />
<a href="https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly">https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly</a>
</li>

<li>The Java Virtual Machine Specification: 3.14. Synchronization<br />
<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14</a>
</li>

<li>The Java Virtual Machine Specification: 8.3.1.4. volatile Fields<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.4. Memory Model<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.7. Non-atomic Treatment of double and long<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7</a>
</li>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (pøed verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2014</small></p>
</body>
</html>

