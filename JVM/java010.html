<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Monitorování procesù a správa pamìti v&nbsp;JDK 6 a JDK 7 (4)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Monitorování procesù a správa pamìti v&nbsp;JDK 6 a JDK 7 (4)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;desáté èásti seriálu o vlastnostech JDK 6 a JDK 7 si uká¾eme zpùsob ovlivnìní chování správcù pamìti pomocí parametrù, které je mo¾né specifikovat pøi spou¹tìní bìhového prostøedí Javy (JRE). Zamìøíme se pøedev¹ím na zpùsob nastavování velikostí pamì»ových oblastí, ze kterých se skládá halda (heap).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Princip funkce správce pamìti typu Mark and Sweep</a></p>
<p><a href="#k02">2. Základní zpùsoby monitorování správce pamìti</a></p>
<p><a href="#k03">3. Podrobnìj¹í monitorování èinnosti správce pamìti</a></p>
<p><a href="#k04">4. Statistika vypsaná pøi pou¾ití volby -XX:PrintGCDetails</a></p>
<p><a href="#k05">5. Parametry ovlivòující funkci správce pamìti</a></p>
<p><a href="#k06">6. Chování správce pamìti pøi explicitním nastavení velikosti haldy</a></p>
<p><a href="#k07">7. Zmìna pomìru mezi velikostí jednotlivých oblastí na haldì</a></p>
<p><a href="#k08">8. Výsledky mìøení</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2>1. Princip funkce správce pamìti typu Mark and Sweep</h2>

<p>V&nbsp;pøedchozí èásti ponìkud nepravidelnì vycházejícího seriálu o
programovacím jazyce Java i o vlastnostech <i>JDK 6</i> a <i>JDK 7</i> jsme se
zabývali popisem algoritmù, které jsou pou¾ity pøi implementaci správcù pamìti
(<i>GC &ndash; Garbage Collectors</i>) a souèasnì i popisem struktury haldy
(<i>heap</i>). Pøipomeòme si, ¾e se v&nbsp;moderních implementacích správcù
pamìti sice pou¾ívají trasovací algoritmy, tj.&nbsp;algoritmy prohledávající
strom objektù a oznaèujících ¾ivé objekty, ov¹em kvùli vìt¹í výkonnosti tyto
trasovací algoritmy nepracují stejným zpùsobem se v¹emi objekty ulo¾enými na
haldì. Namísto toho jsou objekty podle svých vlastností rozdìleny do nìkolika
navzájem oddìlených èástí haldy. Nejhrub¹í dìlení je na objekty
&bdquo;mladé&ldquo; a objekty &bdquo;staré&ldquo;, pøièem¾ &bdquo;mladé
objekty&ldquo; (u nich¾ je vìt¹í pravdìpodobnost, ¾e jejich ¾ivotnost bude
krátká &ndash; mù¾e se jednat o jednu iteraci smyèky èi jedinou metodu) jsou
umístìny v&nbsp;oblasti haldy nazvané pøíznaènì <i>young generation</i> a
objekty star¹í (tj.&nbsp;takové objekty, které ji¾ nìkolikrát pøe¾ily bìh
správce pamìti) jsou ulo¾eny v&nbsp;oblasti nazvané <i>tenured generation</i>
nebo té¾ <i>old generation</i>.</p>

<img src="http://i.iinfo.cz/images/395/java09-6.png" width="400" height="413" alt=" " />
<p><i>Obrázek 1: Vìt¹ina bì¾ných objektù je vytvoøena v&nbsp;obecnì men¹í
oblasti haldy nazvané <strong>young generation</strong>. Teprve poté, co objekt
nìkolikrát &bdquo;pøe¾ije&ldquo; spu¹tìní správce pamìti nad touto oblastí
haldy, mù¾e být pøesunut do (opìt obecnì) vìt¹í oblasti haldy nazvané
<strong>old generation</strong> èi takté¾ <strong>tenured generation</strong>.
Objekty, pro jejich¾ alokaci je zapotøebí velké mno¾ství pamìti, v¹ak mohou být
pøímo vytvoøeny v&nbsp;oblasti <strong>tenured generation</strong>.</i></p>

<p>Nad oblastí <i>young generation</i> se relativnì èasto spou¹tí správce
pamìti optimalizovaný s&nbsp;ohledem na to, ¾e velká èást objektù bude
z&nbsp;této oblasti skuteènì prakticky ihned odstranìna (jedná se o fakt
zji¹tìný mìøením chování objektù v&nbsp;mnoha reálných i modelových
aplikacích). Objekty, které pøe¾ijí nìkolik spu¹tìní tohoto
&bdquo;rychlého&ldquo; správce pamìti, jsou pøesunuty do oblasti <i>old/tenured
generation</i>. I nad objekty ulo¾enými v&nbsp;oblasti <i>old/tenured
generation</i> se samozøejmì spou¹tí správce pamìti, ov¹em s&nbsp;mnohem men¹í
frekvencí. I samotný algoritmus správce pamìti pou¾ívaný pro tuto pamì»ovou
oblast je ponìkud odli¹ný, proto¾e musí mj.&nbsp;správnì vyhodnocovat reference
&bdquo;starých&ldquo; objektù na objekty &bdquo;mladé&ldquo; a naopak. Ov¹em i
samotná oblast <i>young generation</i> je rozdìlena na nìkolik podoblastí.
První z&nbsp;tìchto podoblastí se nazývá <i>eden</i> a právì v&nbsp;této
podoblasti jsou vytváøeny nové objekty.</p>

<img src="http://i.iinfo.cz/images/395/java09-7.png" width="400" height="357" alt=" " />
<p><i>Obrázek 2: Oblast haldy nazvaná <strong>young generation</strong> je
vìt¹inou rozdìlena na tøi podoblasti: <strong>eden</strong>, <strong>survivor
space #1</strong> a <strong>survivor space #2</strong>. Na nìkterých
architekturách je v¹ak namísto toho pou¾ita vìt¹í kapacita haldy pro
<strong>eden</strong> a jedinou podoblast <strong>survivor
space</strong> (jak v¹ak uvidíme dále, není to pøípad architektury
i386).</i></p>

<p>V&nbsp;pøípadì, ¾e je celá kapacita <i>edenu</i> ji¾ alokována, zavolá se
správce pamìti, který celým <i>edenem</i> projde a vyøadí ty objekty, které ji¾
nejsou aktivní (¾ivé). Zbylé objekty, kterých je (alespoò podle statistických
mìøení provedených nad typickými aplikacemi) mnohem ménì, jsou zkopírovány do
jedné z&nbsp;oblastí nazvaných <i>survivor space</i>. U architektur,
v&nbsp;nich¾ se pou¾ívají dvì podoblasti <i>survivor space</i>, je v¾dy jedna
z&nbsp;tìchto podoblastí prázdná a druhá podoblast obsahuje objekty zkopírované
z&nbsp;<i>edenu</i> popø.&nbsp;z&nbsp;podoblasti první (kopírováním objektù se
toti¾ <i>survivor space</i> kromì jiného té¾ defragmentuje). Teprve poté, co je
objekt nìkolikrát zkopírován mezi obìma podoblastmi <i>survivor space</i>, mù¾e
být pøesunut z&nbsp;<i>young generation</i> do vìt¹í a ménì èasto modifikované
oblasti <i>tenured generation</i>.</p>



<p><a name="k02"></a></p>
<h2>2. Základní zpùsoby monitorování správce pamìti</h2>

<p>O nejzákladnìj¹ím a souèasnì i nejjednodu¹¹ím zpùsobu monitorování práce
správce pamìti jsme si ji¾ øekli v&nbsp;pøedchozích èástech tohoto seriálu.
Pokud pøi startu Javovské aplikace pou¾ijeme volbu
<strong>-verbose:gc</strong>, bude se na standardní výstup postupnì vypisovat
ka¾dé zavolání správce pamìti &ndash; jedná se jak o správce pamìti bì¾ícího
nad <i>young generation</i>, tak i o správce pracujícího s&nbsp;<i>tenured
generation</i>. Pro pøipomenutí si znovu uveïme ná¹ demonstraèní pøíklad
pou¾ívající konkatenaci øetìzce v&nbsp;programové smyèce, co¾ ve svém dùsledku
vede k&nbsp;opakovanému volání správce pamìti nad novì vytvoøenými objekty typu
<strong>String</strong> a <strong>StringBuilder</strong> s&nbsp;velmi krátkou
dobou ¾ivota, proto¾e tyto objekty pøestávají být platné ji¾ po probìhnutí
jediné iterace (jednoho cyklu) programové smyèky. Zdrojový kód tohoto
testovacího pøíkladu je následující:</p>

<pre>
public class ConcatTest1
{
    private static final int LOOP_COUNT = 10000;

    public static String createString()
    {
        String str = "";
        for (int i = 0; i &lt; LOOP_COUNT; i++)
        {
            str += i + " ";
        }
        return str;
    }

    public static void main(String[] args)
    {
        String str = createString();
        System.gc(); // lze zakomentovat
        System.out.println("String length: " + str.length());
    }
}
</pre>

<img src="http://i.iinfo.cz/images/395/java09-8.png" width="401" height="398" alt=" " />
<p><i>Obrázek 3: Objekty bì¾né velikosti jsou v¾dy vytváøeny v&nbsp;edenu.
Pouze pøíli¹ velké objekty jsou alokovány ji¾ pøímo v&nbsp;oblasti old/tenured
generation, co¾ v¹ak mù¾e zpùsobovat problémy &ndash; fragmentaci této oblasti,
frekventované odstraòování objektù z&nbsp;old/tenured generation atd.</i></p>

<p>Po pøelo¾ení vý¹e uvedeného programu a jeho spu¹tìní pomocí volby...</p>

<pre>
java -verbose:gc ConcatTest1
</pre>

<p>... se na standardní výstup vypí¹e mno¾ství údajù o spu¹tìní správce pamìti
nad <i>young generation</i>. Ka¾dý výpis vypadá následovnì:</p>

<pre>
[GC 2257K-&gt;153K(7744K), 0.0009370 secs]
</pre>

<p>Co v¹ak jednotlivé údaje znamenají? Písmena <strong>GC</strong> znaèí, ¾e se
spustil správce pamìti nad <i>young generation</i>; pokud by se v¹ak spustil
správce pamìti i nad <i>tenured generation</i>, vypsal by se namísto øetìzce
<strong>GC</strong> øetìzec <strong>Full GC</strong>. Hodnota
<strong>2257K</strong> znaèí celkovou velikost v¹ech ¾ivých objektù pøed
spu¹tìním správce pamìti a hodnota <strong>153K</strong> naproti tomu celkovou
velikost objektù, které zùstaly ¾ivé i po probìhnutí celého cyklu správy pamìti
(zde mù¾eme vidìt, ¾e správce pamìti byl pøi èi¹tìní <i>edenu</i> skuteènì
velmi úspì¹ný, proto¾e v&nbsp;tomto &ndash; ponìkud umìlém &ndash; pøíkladu
dokázal uvolnit více ne¾ 93% pamì»ové kapacity <i>edenu</i>). Ve skuteènosti se
nemusí jednat o skuteènì ¾ivé objekty, ale takté¾ o objekty, na nì¾ existuje
alespoò jedna reference od objektu ulo¾eného v&nbsp;oblasti <i>tenured
generation</i>. Takový objekt sice ji¾ nemusí být ¾ivý, co¾ v¹ak správce pamìti
zatím nemù¾e vìdìt, proto¾e prozatím prochází pouze oblast <i>young
generation</i>.</p>

<p>Èíslo umístìné v&nbsp;závorkách (<strong>7744K</strong>) je celková velikost
pamìti vyu¾itelná pro alokaci objektù. Jedná se o maximální kapacitu haldy, od
ní¾ je odeètena velikost jedné podoblasti <i>survivor space</i> (to je ostatnì
logické, proto¾e pouze v¾dy jedna z&nbsp;tìchto dvou oblastí je pou¾ívána pro
defragmentaci <i>young generation</i>). Význam posledního èísla je zøejmý
&ndash; jedná se o dobu bìhu správce pamìti. Na tomto místì je vhodné
poznamenat, ¾e správce pamìti vìt¹inou bì¾í v&nbsp;samostatném vláknu a
<strong>NE</strong>musí zamykat v¹echny objekty, s&nbsp;nimi¾ pracuje, co¾
znamená, ¾e vlákno/vlákna aplikace ve skuteènosti nemusí být pozastavena na
takovou dobu, jaká je uvedena ve výpisu.</p>

<img src="http://i.iinfo.cz/images/395/java09-9.png" width="400" height="354" alt=" " />
<p><i>Obrázek 4: Jakmile je eden zcela zaplnìn, nebo pokud v&nbsp;nìm ji¾ není
místo pro vytvoøení dal¹ího objektu, spustí se správce pamìti, který poctivì
projde v¹echny zde ulo¾ené objekty. Aktivní objekty jsou ulo¾eny do jedné
z&nbsp;oblastí survivor space, objekty neaktivní jsou odstranìny.</i></p>



<p><a name="k03"></a></p>
<h2>3. Podrobnìj¹í monitorování èinnosti správce pamìti</h2>

<p>Pøi nutnosti podrobnìj¹ího sledování èinnosti správce pamìti je v¹ak vý¹e zmínìná volba <strong>-verbose:gc</strong> nedostateèná, proto¾e nám nedává pøesnou pøedstavu o tom, jakým zpùsobem se jednotlivé oblasti, na nì¾ je halda rozdìlena, skuteènì vyu¾ívají (a vlastnì ani nemusíme vìdìt, jak jsou jednotlivé oblasti velké). V&nbsp;takovém pøípadì mù¾e být zajímavìj¹í a u¾iteènìj¹í pou¾ít volbu <strong>-XX:PrintGCDetails</strong>, napøíklad následujícím zpùsobem:</p>

<pre>
java -XX:+PrintGCDetails ConcatTest1
</pre>

<p>Zpùsob výpisu informací pøi pou¾ití této volby sice není doposud plnì
standardizován a mù¾e se dokonce li¹it podle verze JVM, nicménì
v&nbsp;<i>OpenJDK 6</i> se pøi ka¾dém zavolání správce pamìti nad oblastí
<i>young generation</i> vypí¹e následující øádek:</p>

<pre>
[GC [DefNew: 2159K-&gt;102K(2368K), 0.0014200 secs] 2268K-&gt;211K(7744K), 0.0015800 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
</pre>

<p>První tøi èíslice ve výpisu <strong>2159K-&gt;102K (2368K)</strong> mají
stejný význam, jaký jsme si ji¾ øekli v&nbsp;pøedchozí kapitole, ov¹em vztahují
se pouze k&nbsp;oblasti <i>young generation</i>. Teprve trojice èíslic
<strong>2268K-&gt;211K(7744K)</strong> se vztahuje k&nbsp;celé haldì (tudí¾ by
rozdíl 2159K-102K mìl být stejný jako 2268K-211K, samozøejmì za pøedpokladu, ¾e
není vytvoøen ¾ádný obøí objekt, který by byl pøímo alokován v&nbsp;<i>tenured
generation</i>).</p>

<img src="http://i.iinfo.cz/images/395/java09-10.png" width="400" height="418" alt=" " />
<p><i>Obrázek 5: Pøed èi po projití <strong>edenu</strong> se navíc projdou i
v¹echny objekty ulo¾ené v&nbsp;jedné z&nbsp;podoblastí <strong>survivor
space</strong> a opìt je na základì trasování objektù zhodnoceno, který objekt
je aktivní, který neaktivní a který dostateènì starý na to, aby byl pøesunut do
oblasti <strong>old generation</strong>.</i></p>

<p>Pokud dojde ke spu¹tìní správce pamìti i nad oblastí <i>tenured
generation</i>, tj.&nbsp;oblastí, kde se nachází dostateènì staré a/nebo velké
objekty, je výpis ponìkud pozmìnìn:</p>

<pre>
[Full GC (System) [Tenured: 125K-&gt;110K(5376K), 0.0792740 secs] 170K-&gt;110K(7872K), [Perm : 24K-&gt;24K(12288K)], 0.0794570 secs] [Times: user=0.07 sys=0.00, real=0.08 secs] 
</pre>

<p>Zde si kromì na první pohled viditelných rozdílù (odli¹ná slova na zaèátku
zprávy) pov¹imnìte takté¾ toho, ¾e celý bìh správce pamìti je nad oblastí
<i>tenured generation</i> pomalej¹í (zde více ne¾ 50&times;) a takté¾ toho, ¾e
vlastnì v&nbsp;této oblasti nedo¹lo k&nbsp;významné redukci objektù alokovaných
na haldì. To je ov¹em v&nbsp;poøádku, proto¾e to jen ukazuje na to, ¾e metoda
&bdquo;rozdìl a panuj&ldquo; byla vhodnì pou¾itá &ndash; vìt¹inu doèasných
objektù se podaøilo &bdquo;zlikvidovat&ldquo; ji¾ v&nbsp;oblasti <i>young
generation</i>.</p>



<p><a name="k04"></a></p>
<h2>4. Statistika vypsaná pøi pou¾ití volby -XX:PrintGCDetails</h2>

<p>Pøi pou¾ití volby <strong>-XX:PrintGCDetails</strong> se pøed ukonèením
aplikace vypí¹e zajímavá statistika (následující formát opìt platí pro pøípad,
¾e je tato volba pou¾ita na <i>OpenJDK 6</i>):</p>

<pre>
Heap
 def new generation   total 2496K, used 1288K [0x7feb0000, 0x80160000, 0x85200000)
  eden space 2240K,  57% used [0x7feb0000, 0x7fff20c0, 0x800e0000)
  from space 256K,   0% used [0x800e0000, 0x800e0000, 0x80120000)
  to   space 256K,   0% used [0x80120000, 0x80120000, 0x80160000)
 tenured generation   total 5376K, used 394K [0x85200000, 0x85740000, 0x8f8b0000)
   the space 5376K,   7% used [0x85200000, 0x85262b60, 0x85262c00, 0x85740000)
 compacting perm gen  total 12288K, used 28K [0x8f8b0000, 0x904b0000, 0x938b0000)
   the space 12288K,   0% used [0x8f8b0000, 0x8f8b72d8, 0x8f8b7400, 0x904b0000)
    ro space 10240K,  73% used [0x938b0000, 0x94006e40, 0x94007000, 0x942b0000)
    rw space 12288K,  60% used [0x942b0000, 0x949ef9f8, 0x949efa00, 0x94eb0000)
</pre>

<p>Na pøedchozím výpisu je nám virtuálním strojem jazyka Java prozrazeno, jak
jsou vlastnì jednotlivé oblasti <i>young generation</i> (zde je pøejmenovaná na
<i>def new generation</i>) a <i>tenured generation</i> velké a souèasnì jsou
vypsány i kapacity v¹ech tøí podoblastí v&nbsp;<i>young generation</i> &ndash;
<i>edenu</i> a obou podoblastí <i>survivor space</i> (tyto oblasti jsou na
výpisu nazvané podle své funkce <i>from</i> a <i>to</i>). Pov¹imnìte si, ¾e
kapacita <i>young generation</i> je rovna 2496K, co¾ je souèet kapacity
<i>edenu</i> (2240K) a kapacity <strong>jedné</strong> z&nbsp;podoblastí
<i>survivor space</i> (256K) &ndash; dùvod pro tento výpoèet jsme si ji¾
vysvìtlili o nìkolik odstavcù vý¹e.</p>

<p>Poznámka: volbu <strong>-XX:PrintGCDetails</strong> je mo¾né kombinovat
s&nbsp;volbou <strong>-XX:PrintGCTimeStamps</strong>, èím¾ dosáhneme i výpisu
èasových znaèek odpovídajících volání správce pamìti. Samotná volba
<strong>-XX:PrintGCTimeStamps</strong> v¹ak nemá ¾ádný efekt; musí být pou¾ita
spolu s&nbsp;nìkterou volbou povolující výpis informací o bìhu správce
pamìti:</p>

<pre>
java -XX:+PrintGCDetails -XX:+PrintGCTimeStamps ConcatTest1
</pre>

<p>Výpis je nepatrnì pozmìnìn, ov¹em èasová znaèka mù¾e být v&nbsp;nìkterých
pøípadech dùle¾itá, napøíklad pøi sledování, v&nbsp;jakém okam¾iku je bì¾ící
program pozastaven na del¹í dobu, kdy je halda nejvíce pou¾ívána atd.:</p>

<pre>
27.296: [GC 27.296: [DefNew: 2289K-&gt;190K(2368K), 0.0036770 secs] 7552K-&gt;5548K(7744K), 0.0038540 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]
23.893: [Full GC (System) 23.894: [Tenured: 394K-&gt;203K(5376K), 0.1400310 secs] 1638K-&gt;203K(7872K), [Perm : 26K-&gt;26K(12288K)], 0.1402740 secs] [Times: user=0.07 sys=0.00, real=0.14 secs]
</pre>



<p><a name="k05"></a></p>
<h2>5. Parametry ovlivòující funkci správce pamìti</h2>

<p>V&nbsp;pøedchozích kapitolách jsme si øekli základní informace o tom, jakým
zpùsobem lze i za pomocí jednoduchých prostøedkù (tj.&nbsp;pouze vlastního
<i>JRE</i> a nástrojù, které se v&nbsp;<i>JRE</i> nachází) monitorovat funkci
správcù pamìti. Ov¹em monitorování samo o sobì by nemìlo velký význam tehdy,
pokud by nebylo mo¾né parametry správy pamìti vhodným zpùsobem modifikovat. Pøi
spou¹tìní <i>JRE</i> je skuteènì mo¾né chování správce pamìti ovlivnit, a to
hned nìkolika volbami. Nejprve se znovu podívejme na to, jak je rozdìlena
pamì»ová oblast haldy (pro jednoduchost nyní budeme ignorovat oblast
<i>PermGen</i> pou¾ívanou pro ponìkud odli¹né úèely). Obì hlavní oblasti haldy
&ndash; <i>young generation</i> a <i>tenured generation</i> &ndash; i v¹echny
dùle¾ité podoblasti jsou zobrazeny na ¹estém a sedmém obrázku. Dva základní
parametry, kterými se virtuální stroj jazyka Java pøi svém spou¹tìní øídí, je
parametr urèující maximální velikost haldy (rezervovanou pøi startu virtuálního
stroje) a parametr urèující, jak velká pamì» je skuteènì virtuálnímu stroji po
rezervaci pøiøazena.</p>

<a href="http://i.iinfo.cz/images/592/java10-1.png"><img src="http://i.iinfo.cz/images/592/java10-1-prev.png" width="193" height="270" alt=" " /></a>
<p><i>Obrázek 6: Dvì hlavní oblasti haldy a podrobnìj¹í pohled na podoblast
young generation.</i></p>

<p>Tyto dva parametry je mo¾né pøi startu virtuálního stroje Javy specifikovat
pomocí známých voleb <strong>-Xmx</strong> (rezervovaná velikost pamìti pro
haldu) a <strong>-Xms</strong> (pamì» skuteènì alokovaná pro haldu pøi startu
virtuálního stroje). Je zapotøebí si dát pozor na to, ¾e se pùvodní hodnoty
obou parametrù li¹í v&nbsp;závislosti na typu operaèního systému i na pou¾ité
platformì. Hodnoty obou parametrù mohou být samozøejmì shodné, co¾ je také
v&nbsp;mnoha pøípadech nejlep¹í varianta, zejména ve chvíli, kdy je virtuální
stroj jazyka Java spu¹tìn na systémech s&nbsp;malými pamì»ovými stránkami, co¾
mù¾e být i pøípad Linuxu, zejména tehdy, kdy¾ není povolena podpora pro
<i>Large/Huge pages</i>.</p>

<a href="http://i.iinfo.cz/images/592/java10-2.png"><img src="http://i.iinfo.cz/images/592/java10-2-prev.png" width="194" height="270" alt=" " /></a>
<p><i>Obrázek 7: Dvì hlavní oblasti haldy a podrobnìj¹í pohled na podoblast
tenured generation.</i></p>

<p>Mimochodem, velikost pamì»ových stránek lze zjistit pøíkazem <strong>getconf
PAGESIZE</strong> vracejícího údaje v&nbsp;bajtech. Hodnoty parametrù
<strong>-Xmx</strong> a <strong>-Xms</strong> ovlivòují jak velikost oblasti
<i>young generation</i>, tak i oblasti <i>tenured generation</i>, co¾
mj.&nbsp;znamená, ¾e se v&nbsp;pøípadì malé kapacity haldy bude správce pamìti
spou¹tìt s&nbsp;vìt¹í frekvencí, proto¾e se bude èastìji zaplòovat <i>eden</i>
a objekty se budou kvùli men¹í velikosti <i>survivor space(s)</i> èastìji
kopírovat do <i>tenured generation</i> i v&nbsp;pøípadì, ¾e je¹tì nedosáhly
potøebného &bdquo;stáøí&ldquo;.</p>



<p><a name="k06"></a></p>
<h2>6. Chování správce pamìti pøi explicitním nastavení velikosti haldy</h2>

<p>Chování správce pamìti pøi explicitním nastavení velikosti haldy si mù¾eme
vyzkou¹et na na¹em demonstraèním pøíkladu:</p>

<pre>
java -Xmx10M -Xms10M -XX:+PrintGCDetails ConcatTest1
</pre>

<p>Na dal¹ím výpisu je zobrazeno posledních nìkolik øádkù zpráv vypisovaných
správcem pamìti. Pov¹imnìte si velikostí jednotlivých oblastí a podoblastí
vypoètených samotným virtuálním strojem Javy pouze na základì celkové velikosti
haldy:</p>

<pre>
[GC [DefNew: 2865K-&gt;191K(3072K), 0.0022210 secs] 2974K-&gt;299K(9920K), 0.0023930 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
[Full GC (System) [Tenured: 108K-&gt;203K(6848K), 0.1063970 secs] 587K-&gt;203K(9920K), [Perm : 26K-&gt;26K(12288K)], 0.1066690 secs] [Times: user=0.07 sys=0.01, real=0.11 secs] 
String length: 48890
Heap
 def new generation   total 3072K, used 57K [0x8eeb0000, 0x8f200000, 0x8f200000)
  eden space 2752K,   2% used [0x8eeb0000, 0x8eebe4a0, 0x8f160000)
  from space 320K,   0% used [0x8f160000, 0x8f160000, 0x8f1b0000)
  to   space 320K,   0% used [0x8f1b0000, 0x8f1b0000, 0x8f200000)
 tenured generation   total 6848K, used 203K [0x8f200000, 0x8f8b0000, 0x8f8b0000)
   the space 6848K,   2% used [0x8f200000, 0x8f232fc8, 0x8f233000, 0x8f8b0000)
 compacting perm gen  total 12288K, used 28K [0x8f8b0000, 0x904b0000, 0x938b0000)
   the space 12288K,   0% used [0x8f8b0000, 0x8f8b72f8, 0x8f8b7400, 0x904b0000)
    ro space 10240K,  73% used [0x938b0000, 0x94006e40, 0x94007000, 0x942b0000)
    rw space 12288K,  60% used [0x942b0000, 0x949ef9f8, 0x949efa00, 0x94eb0000)
</pre>

<p>Zajímavé je také zjistit, kolikrát byl v&nbsp;tomto pøípadì zavolaný správce
pamìti nad oblastí <i>young generation</i>:</p>

<pre>
java -Xmx10M -Xms10M -XX:+PrintGCDetails ConcatTest1 | grep DefNew | wc -l
694
</pre>

<p>A takté¾ celkový èas bìhu aplikace:</p>

<pre>
time java -Xmx10M -Xms10M ConcatTest1

real    0m14.300s
user    0m11.477s
sys     0m0.544s
</pre>

<p>Jak jsem se ji¾ zmínil v&nbsp;pøedchozí kapitole, má velikost pamìti
rezervované (popø.&nbsp;alokované) pro haldu velký vliv na výkonnost celého
virtuálního stroje a tím i aplikace, která je ve virtuálním stroji spu¹tìna.
Vyzkou¹ejme nejprve extrémní pøíklad, kdy je kapacita haldy sní¾ena na velmi
malé hodnoty, napøíklad na 2MB. Zde je nutné poznamenat, ¾e u vìt¹ích aplikací
napøíklad pøi spou¹tìní aplikaèního serveru, je za &bdquo;malou kapacitu
haldy&ldquo; pova¾ováno i nìkolik (desítek) megabajtù, tak¾e se v&nbsp;pøípadì
výkonnostních problémù mohou programátoøi a/nebo administrátoøi zamìøit takté¾
na volby <strong>-Xmx</strong> a <strong>-Xms</strong>. Jak se zmìní doba bìhu
aplikace i dal¹í vlastnosti JRE pøi sní¾ení maximální rezervované kapacity
haldy na 2MB? Nejprve se podívejme, jakým zpùsobem virtuální stroj rozdìlí
pøidìlenou 2MB oblast mezi rùzné oblasti a podoblasti haldy:</p>

<pre>
Heap
 def new generation   total 960K, used 20K [0x8f2b0000, 0x8f3b0000, 0x8f4b0000)
  eden space 896K,   2% used [0x8f2b0000, 0x8f2b5028, 0x8f390000)
  from space 64K,   0% used [0x8f3a0000, 0x8f3a0000, 0x8f3b0000)
  to   space 64K,   0% used [0x8f390000, 0x8f390000, 0x8f3a0000)
 tenured generation   total 1024K, used 201K [0x8f4b0000, 0x8f5b0000, 0x8f8b0000)
   the space 1024K,  19% used [0x8f4b0000, 0x8f4e2428, 0x8f4e2600, 0x8f5b0000)
 compacting perm gen  total 12288K, used 27K [0x8f8b0000, 0x904b0000, 0x938b0000)
   the space 12288K,   0% used [0x8f8b0000, 0x8f8b6e08, 0x8f8b7000, 0x904b0000)
    ro space 10240K,  73% used [0x938b0000, 0x94006e40, 0x94007000, 0x942b0000)
    rw space 12288K,  60% used [0x942b0000, 0x949ef9f8, 0x949efa00, 0x94eb0000)
</pre>

<p>Celková doba bìhu aplikace v&nbsp;tomto pøípadì pravdìpodobnì u¾ivatele
pøíli¹ nepotì¹í:</p>

<pre>
time java -Xmx2M -Xms2M ConcatTest1

real   0m45.910s
user   0m39.334s
sys    0m1.696s

(trojnásobné zpomalení)
</pre>

<p>...stejnì jako celkový poèet spu¹tìní správce pamìti (poèet jeho spu¹tìní
koresponduje s&nbsp;celkovým nárùstem doby bìhu programu, co¾ u takto
jednoduchého algoritmu pravdìpodobnì nepøekvapí)...</p>

<pre>
java -Xmx2M -Xms2M -XX:+PrintGCDetails ConcatTest1 | grep DefNew | wc -l
2241

(cca trojnásobný poèet spu¹tìní správce pamìti)
</pre>

<p>Vyzkou¹ejme nyní druhý extrém &ndash; nastavení rezervované velikosti pro
haldu na 100MB:</p>

<pre>
Heap
 def new generation   total 30720K, used 548K [0x894b0000, 0x8b600000, 0x8b600000)
  eden space 27328K,   2% used [0x894b0000, 0x895392b8, 0x8af60000)
  from space 3392K,   0% used [0x8af60000, 0x8af60000, 0x8b2b0000)
  to   space 3392K,   0% used [0x8b2b0000, 0x8b2b0000, 0x8b600000)
 tenured generation   total 68288K, used 203K [0x8b600000, 0x8f8b0000, 0x8f8b0000)
   the space 68288K,   0% used [0x8b600000, 0x8b632fc8, 0x8b633000, 0x8f8b0000)
 compacting perm gen  total 12288K, used 28K [0x8f8b0000, 0x904b0000, 0x938b0000)
   the space 12288K,   0% used [0x8f8b0000, 0x8f8b72f8, 0x8f8b7400, 0x904b0000)
    ro space 10240K,  73% used [0x938b0000, 0x94006e40, 0x94007000, 0x942b0000)
    rw space 12288K,  60% used [0x942b0000, 0x949ef9f8, 0x949efa00, 0x94eb0000)
</pre>

<p>Celkový èas bìhu programu:</p>

<pre>
time java -Xmx100M -Xms100M ConcatTest1

real    0m11.673s
user    0m10.081s
sys     0m0.408s
</pre>

<p>Poèet volání správce pamìti:</p>

<pre>
java -Xmx100M -Xms100M -XX:+PrintGCDetails ConcatTest1 | grep DefNew | wc -l
68

(10&times; men¹í ne¾ pøi nastavení 10MB a 33&times; men¹í ne¾ u 2MB)
</pre>



<p><a name="k07"></a></p>
<h2>7. Zmìna pomìru mezi velikostí jednotlivých oblastí na haldì</h2>

<p>Po volbách <strong>-Xmx</strong> a <strong>-Xms</strong> má nejvìt¹í vliv na
výkonnost správcù pamìti podíl velikostí oblastí <i>young generation</i> a
<i>tenured generation</i>. Tento pomìr lze nastavit pomocí volby
<strong>-XX:NewRatio=x</strong>, kde <strong>x</strong> je celoèíselný (!)
pomìr mezi velikostí <i>tenured generation</i> a <i>young generation</i>. Na
tomto místì je vhodné si uvìdomit, ¾e do celkové velikosti oblasti <i>young
generation</i> se pøi výpoètu pomìru zapoèítávají v¹echny tøi podoblasti,
tj.&nbsp;jak <i>eden</i>, tak i obì podoblasti <i>survivor space(s)</i>.
Celková maximální kapacita pamìti vyhrazené pro haldu se sice nemìní, i tak
v¹ak má tento parametr v&nbsp;mnoha pøípadech velký vliv na výkonnost èi
propustnost Javovských aplikací &ndash; právì proto je vhodné pøi výkonnostních
problémech provést mìøení pøi zmìnách tohoto parametru, proto¾e se u nìkterých
aplikací mù¾e podaøit výkon aplikací zvý¹it ani¾ by bylo nutné obìtovat dal¹í
operaèní pamì» pro haldu.</p>

<p>Ostatnì se o významu tohoto parametru mù¾eme pøesvìdèit sami, napøíklad
pomocí jednoduchého skriptu, který do souboru <i>gc_count.txt</i> ulo¾í poèet
volání správce pamìti nad <i>young generation</i>, pøièem¾ celková velikost
haldy zùstává stále nastavena na 10MB:</p>

<pre>
#!/bin/bash

for i in `seq 1 10`;
do
    java -Xmx10M -Xms10M -XX:NewRatio=${i} \
        -XX:+PrintGCDetails ConcatTest1 | grep DefNew | wc -l &gt;&gt; gc_count.txt
done
</pre>

<p>Namìøené výsledky jsem pro vìt¹í pøehlednost uspoøádal do tabulky, do ní¾ je
navíc pøidán i sloupec s&nbsp;dobou bìhu aplikace. Z&nbsp;tabulky je patrné, ¾e
i pøi omezené velikosti haldy (tu mù¾e limitovat jak kapacita operaèní pamìti,
tak i napøíklad kapacita alokovaná pro virtuální stroj, co¾ zaèíná být
v&nbsp;dobì cloudù èím dál tím více dùle¾itìj¹í velièina), je mo¾né
s&nbsp;vhodnými spou¹tìcími parametry dosáhnout zajímavých zlep¹ení:</p>

<table>
<tr><th>Velikost haldy</th><th>Pomìr tenured:young</th><th>Volání GC pro young</th><th>Èas bìhu</th></tr>
<tr><td>10&nbsp;M</td><td> 1:1</td><td> 463</td><td>10.86&nbsp;s</td></tr>
<tr><td>10&nbsp;M</td><td> 2:1</td><td> 694</td><td>11.37&nbsp;s</td></tr>
<tr><td>10&nbsp;M</td><td> 3:1</td><td> 939</td><td>12.01&nbsp;s</td></tr>
<tr><td>10&nbsp;M</td><td> 4:1</td><td>1163</td><td>12.41&nbsp;s</td></tr>
<tr><td>10&nbsp;M</td><td> 5:1</td><td>1378</td><td>13.38&nbsp;s</td></tr>
<tr><td>10&nbsp;M</td><td> 6:1</td><td>1700</td><td>14.33&nbsp;s</td></tr>
<tr><td>10&nbsp;M</td><td> 7:1</td><td>1926</td><td>14.91&nbsp;s</td></tr>
<tr><td>10&nbsp;M</td><td> 8:1</td><td>2052</td><td>16.29&nbsp;s</td></tr>
<tr><td>10&nbsp;M</td><td> 9:1</td><td>2239</td><td>16.87&nbsp;s</td></tr>
<tr><td>10&nbsp;M</td><td>10:1</td><td>2238</td><td>16.80&nbsp;s</td></tr>
</table>

<p>V&nbsp;mnoha pøípadech nám v¹ak nebude nastavení <i>celoèíselného</i> pomìru
mezi <i>young generation</i> a <i>tenured generation</i> dostaèovat. Namísto
této hodnoty lze takté¾ pou¾ít pøepínaèe <strong>-XX:NewSize=kapacita</strong>
a <strong>-XX:MaxNewSize=kapacita</strong>, pomocí nich¾ je mo¾né nastavit
minimální a maximální velikost oblasti <i>young generation</i> v&nbsp;bajtech,
kilobajtech, megabajtech atd. Velikost <i>tenured generation</i> se
v&nbsp;tomto pøípadì dopoèítá automaticky na základì maximální povolené
velikosti haldy. Podívejme se na konkrétní pøíklad, kde je velikost <i>young
generation</i> nastavena na hodnotu 8192+1024+1024=10240 kB a velikost
<i>tenured generation</i> na 11M-10M=1 MB (1024 kB):</p>

<pre>
java -Xmx11M -XX:NewSize=10M -XX:+PrintGCDetails

... informace o mo¾ných pøepínaèích ...

Heap
 def new generation   total 9216K, used 491K [0x8eab0000, 0x8f4b0000, 0x8f4b0000)
  eden space 8192K,   6% used [0x8eab0000, 0x8eb2af00, 0x8f2b0000)
  from space 1024K,   0% used [0x8f2b0000, 0x8f2b0000, 0x8f3b0000)
  to   space 1024K,   0% used [0x8f3b0000, 0x8f3b0000, 0x8f4b0000)
 tenured generation   total 1024K, used 0K [0x8f4b0000, 0x8f5b0000, 0x8f8b0000)
   the space 1024K,   0% used [0x8f4b0000, 0x8f4b0000, 0x8f4b0200, 0x8f5b0000)
 compacting perm gen  total 12288K, used 43K [0x8f8b0000, 0x904b0000, 0x938b0000)
   the space 12288K,   0% used [0x8f8b0000, 0x8f8baf88, 0x8f8bb000, 0x904b0000)
    ro space 10240K,  73% used [0x938b0000, 0x94006e40, 0x94007000, 0x942b0000)
    rw space 12288K,  60% used [0x942b0000, 0x949ef9f8, 0x949efa00, 0x94eb0000)
</pre>

<p>Nyní se opìt na chvíli vrátíme k&nbsp;na¹emu testovacímu pøíkladu. Nejprve
ho spustíme s&nbsp;velikostí haldy nastavenou na 5 MB, ov¹em s&nbsp;tím, ¾e
zpùsob rozdìlení této kapacity mezi <i>young generation</i> a <i>tenured
generation</i> ponecháme plnì na virtuálním stroji Javy:</p>

<pre>
time java -Xmx5M -Xms5M -XX:+PrintGCDetails ConcatTest1 | grep DefNew | wc -l
1311    - poèet volání GC

real	0m15.715s
user	0m14.529s
sys	0m0.984s
</pre>

<p>Ov¹em vzhledem k&nbsp;tomu, ¾e víme, ¾e ná¹ pøíklad vytváøí velké mno¾ství
objektù s&nbsp;malou ¾ivotností, které tudí¾ nemusí (a nemají!) skonèit
v&nbsp;oblasti <i>tenured generation</i>, mù¾eme velikost této oblasti sní¾it
na pouhý jeden megabajt, èím¾ se jak drasticky sní¾í poèet volání správce
pamìti, tak se i zmen¹í celková doba bìhu aplikace:</p>

<pre>
time java -Xmx5M -Xms5M -XX:NewSize=4M -XX:+PrintGCDetails ConcatTest1 | grep DefNew | wc -l
571     - poèet volání GC

real	0m11.994s
user	0m11.221s
sys	0m0.612s
</pre>

<p>Poznámka: opìt pro jistotu poznamenávám, ¾e pro reálné aplikace budou
namìøené hodnoty i vhodné nastavované parametry s&nbsp;velkou pravdìpodobností
zcela odli¹né, proto¾e ná¹ demonstraèní pøíklad je v&nbsp;urèitém ohledu
extrémem.</p>



<p><a name="k08"></a></p>
<h2>8. Výsledky mìøení</h2>

<p>Nikdy neza¹kodí takté¾ uvést nìjakou (samozøejmì vhodnì zfal¹ovanou :-)
statistiku, ideálnì podepøenou grafy. S&nbsp;generováním dat tvoøících základ
pro grafy nám mù¾e pomoci jednoduchý skript, pomocí nìho¾ zjistíme jak dobu
bìhu testovací aplikace pøi pou¾ití rùzné velikosti haldy, tak i celkový poèet
volání správce pamìti:</p>

<pre>
#!/bin/bash

# vysledek: dvojice textovych souboru
# obsahujicich pocet spusteni GC a celkovou
# dobu behu testovaciho programu

for i in `seq 2 100`;
do
    echo "Spoustim JVM s nastavenou velikosti heapu na ${i}MB"
    # POZOR! nechceme volat interni prikaz time z BASHe
    /usr/bin/time -o times.txt -a -f "%U" \
        java -Xmx${i}M -Xms${i}M -XX:+PrintGCDetails \
        ConcatTest1 | grep DefNew | wc -l &gt;&gt; gc_count.txt
done
</pre>

<p>Z&nbsp;vygenerovaných dat lze jednodu¹e vytvoøit grafy, na kterých je patrná
nelineární závislost mezi celkovou velikostí haldy a èasem bìhu aplikace.
Z&nbsp;grafù je patrné také to, ¾e pøíli¹ malá velikost haldy vede
k&nbsp;mnohem del¹í dobì trvání bìhu aplikace (popø.&nbsp;i ke vzniku výjimek
typu <strong>java.lang.OutOfMemoryError</strong>), ov¹em na druhou stranu nemá
moc smyslu nastavovat ani pøíli¹ velkou kapacitu haldy, proto¾e od urèitého
okam¾iku (zcela závislého na povaze bì¾ící aplikace i zpracovávaných dat!) se
ji¾ dal¹í zvy¹ování velikosti haldy projeví na celkovém èasu bìhu aplikace
(popø.&nbsp;na prùchodnosti aplikace) jen zcela nepatrnì.</p>

<a href="http://i.iinfo.cz/images/592/java10-3.png"><img src="http://i.iinfo.cz/images/592/java10-3-prev.png" width="223" height="270" alt=" " /></a>
<p><i>Obrázek 8: Celková doba bìhu testovací aplikace (vyjádøená
v&nbsp;sekundách) v&nbsp;závislosti na maximální velikosti haldy (vyjádøené
v&nbsp;MB)</i></p>

<a href="http://i.iinfo.cz/images/592/java10-4.png"><img src="http://i.iinfo.cz/images/592/java10-4-prev.png" width="217" height="270" alt=" " /></a>
<p><i>Obrázek 9: Poèet spu¹tìní správce pamìti v&nbsp;závislosti na maximální
velikosti haldy (vyjádøené v&nbsp;MB).</i></p>



<p><a name="k09"></a></p>
<h2>9. Odkazy na Internetu</h2>

<ol>

<li>Amdahl's law<br />
<a href="http://en.wikipedia.org/wiki/Amdahl_law">http://en.wikipedia.org/wiki/Amdahl_law</a>
</li>

<li>Garbage collection (computer science)<br />
<a href="http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)</a>
</li>

<li>Dr. Dobb's | G1: Java's Garbage First Garbage Collector<br />
<a href="http://www.drdobbs.com/article/printableArticle.jhtml?articleId=219401061&amp;dept_url=/java/">http://www.drdobbs.com/article/printableArticle.jhtml?articleId=219401061&amp;dept_url=/java/</a>
</li>

<li>Java's garbage-collected heap<br />
<a href="http://www.javaworld.com/javaworld/jw-08-1996/jw-08-gc.html">http://www.javaworld.com/javaworld/jw-08-1996/jw-08-gc.html</a>
</li>

<li>Compressed oops in the Hotspot JVM<br />
<a href="http://wikis.sun.com/display/HotSpotInternals/CompressedOops">http://wikis.sun.com/display/HotSpotInternals/CompressedOops</a>
</li>

<li>32-bit or 64-bit JVM? How about a Hybrid?<br />
<a href="http://blog.juma.me.uk/2008/10/14/32-bit-or-64-bit-jvm-how-about-a-hybrid/">http://blog.juma.me.uk/2008/10/14/32-bit-or-64-bit-jvm-how-about-a-hybrid/</a>
</li>

<li>Compressed object pointers in Hotspot VM<br />
<a href="http://blogs.sun.com/nike/entry/compressed_object_pointers_in_hotspot">http://blogs.sun.com/nike/entry/compressed_object_pointers_in_hotspot</a>
</li>

<li>Java HotSpot(tm) Virtual Machine Performance Enhancements<br />
<a href="http://download.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html">http://download.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html</a>
</li>

<li>Using jconsole<br />
<a href="http://download.oracle.com/javase/1.5.0/docs/guide/management/jconsole.html">http://download.oracle.com/javase/1.5.0/docs/guide/management/jconsole.html</a>
</li>

<li>jconsole &ndash; Java Monitoring and Management Console<br />
<a href="http://download.oracle.com/javase/1.5.0/docs/tooldocs/share/jconsole.html">http://download.oracle.com/javase/1.5.0/docs/tooldocs/share/jconsole.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>x86-64<br />
<a href="http://en.wikipedia.org/wiki/X86-64">http://en.wikipedia.org/wiki/X86-64</a>
</li>

<li>Physical Address Extension<br />
<a href="http://en.wikipedia.org/wiki/Physical_Address_Extension">http://en.wikipedia.org/wiki/Physical_Address_Extension</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>1.6.0_14 (6u14)<br />
<a href="http://www.oracle.com/technetwork/java/javase/6u14-137039.html?ssSourceSiteId=otncn">http://www.oracle.com/technetwork/java/javase/6u14-137039.html?ssSourceSiteId=otncn</a>
</li>

<li>Update Release Notes<br />
<a href="http://www.oracle.com/technetwork/java/javase/releasenotes-136954.html">http://www.oracle.com/technetwork/java/javase/releasenotes-136954.html</a>
</li>

<li>4.10 Limitations of the Java Virtual Machine<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#88659">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#88659</a>
</li>

<li>Java(TM) Platform, Standard Edition 7 Binary Snapshot Releases<br />
<a href="http://dlc.sun.com.edgesuite.net/jdk7/binaries/index.html">http://dlc.sun.com.edgesuite.net/jdk7/binaries/index.html</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>ClosableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>ArrayList (JDK 1.4)<br />
<a href="http://download.oracle.com/javase/1.4.2/docs/api/java/util/ArrayList.html">http://download.oracle.com/javase/1.4.2/docs/api/java/util/ArrayList.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2011</small></p>
</body>
</html>

