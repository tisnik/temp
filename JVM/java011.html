<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Monitorování procesù a správa pamìti v&nbsp;JDK 6 a JDK 7 (5)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Monitorování procesù a správa pamìti v&nbsp;JDK 6 a JDK 7 (5)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;jedenácté èásti seriálu o vlastnostech JDK 6 a JDK 7 (samozøejmì vèetnì OpenJDK) se opìt budeme zabývat principem èinnosti správcù pamìti a zpùsobù, jakými lze ovlivnit výkonnost virtuálního stroje Javy. Popí¹eme si pøedev¹ím rozdíl mezi rùznými typy správcù pamìti a zamìøíme se na bìh JVM na víceprocesorových poèítaèích.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Základní funkce správce pamìti &ndash; shrnutí</a></p>
<p><a href="#k02">2. Propustnost versus èas pozastavení bìhu aplikací</a></p>
<p><a href="#k03">3. Co lze napravit pøi výkonnostních problémech?</a></p>
<p><a href="#k04">4. Sériový správce pamìti</a></p>
<p><a href="#k05">5. Správce pamìti jako úzké hrdlo víceprocesorového systému?</a></p>
<p><a href="#k06">6. Paralelní správci pamìti</a></p>
<p><a href="#k07">7. Testovací pøíklad</a></p>
<p><a href="#k08">8. Výsledky bìhu testovacího pøíkladu</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2>1. Základní funkce správce pamìti &ndash; shrnutí</h2>

<p>V&nbsp;pøedchozích èástech seriálu o vlastnostech programovacího jazyka Java
i jeho virtuálního stroje (<i>JVM</i>) jsme se seznámili s&nbsp;tím, jakým
zpùsobem je implementován správce pamìti (<i>GC &ndash; Garbage Collector</i>).
Pøipomeòme si, ¾e správce pamìti slou¾í k&nbsp;vyhledávání tìch objektù
umístìných na haldì, které ji¾ nejsou dosa¾itelné ze ¾ádného vlákna bì¾ící
aplikace. Tyto objekty jsou následnì odstranìny a ostatní objekty na haldì jsou
v&nbsp;pøípadì potøeby pøeuspoøádány takovým zpùsobem, aby halda nebyla pøíli¹
fragmentovaná, co¾ by znemo¾nilo alokaci pamìti pro vìt¹í objekty. Vzhledem
k&nbsp;tomu, ¾e vyhledávání potenciálnì ne¾ivých objektù je z&nbsp;èasového i
výkonnostního hlediska pomìrnì nároèná èinnost, jsou pøi implementaci správcù
pamìti pou¾ity nìkteré heuristické metody. Základní my¹lenkou, na které jsou
tyto metody zalo¾eny, je zji¹tìní, ¾e objekty, které jsou ji¾ ¾ivé po del¹í
èasový úsek, budou s&nbsp;velkou pravdìpodobností ¾ivé i po provedení dal¹ího
bìhu správce pamìti. Vìt¹inou platí i opak &ndash; novì vytvoøené objekty budou
mít s&nbsp;velkou pravdìpodobností jen krátkou dobu ¾ivota.</p>

<a href="http://i.iinfo.cz/images/592/java10-1.png"><img src="http://i.iinfo.cz/images/592/java10-1-prev.png" width="193" height="270" alt=" " /></a>
<p><i>Obrázek 1: Dvì hlavní oblasti haldy (young generation a tenured
generation) a podrobnìj¹í pohled na podoblast young generation.</i></p>

<p>Pøi pou¾ití vý¹e zmínìné heuristiky je celá halda (<i>heap</i>) rozdìlena na
dvì oblasti &ndash; <i>young generation</i> a <i>tenured generation</i>
s&nbsp;tím, ¾e novì vytváøené objekty jsou nejprve umístìny do oblasti <i>young
generation</i>. Virtuální stroj jazyka Java se sna¾í jemu dostupnou
(pøidìlenou) operaèní pamì» pro haldu rozdìlit na oblasti <i>young
generation</i> a <i>tenured generation</i> na základì vzorcù odvozených opìt od
chování bì¾ných aplikací (navíc se pro haldu mù¾e rezervovat vìt¹í pamì»ový
úsek, ne¾ je skuteènì v&nbsp;daný okam¾ik alokován). V&nbsp;nìkterých
pøípadech, pøedev¹ím u netypických aplikací èi u aplikací, kde zále¾í na co
nejvy¹¹ím výkonu èi rychlé odezvì aplikace, je v¹ak mo¾né pøi spu¹tìní
virtuálního stroje definovat jak alokovanou i maximální velikost haldy, tak i
zpùsob rozdìlení haldy na dvì vý¹e zmínìné oblasti. K&nbsp;tomuto úèelu slou¾í
nìkolik pøepínaèù, pøedev¹ím volby <strong>-Xmx</strong>,
<strong>-Xms</strong>, <strong>-XX:NewRatio=</strong>,
<strong>-XX:NewSize=</strong> a <strong>-XX:MaxNewSize=</strong>, jejich¾
význam byl vysvìtlen <a
href="http://www.root.cz/clanky/monitorovani-procesu-a-sprava-pameti-v-jdk-6-a-jdk-7-4/">v&nbsp;pøedchozí
èásti tohoto seriálu</a>.</p>

<a href="http://i.iinfo.cz/images/592/java10-2.png"><img src="http://i.iinfo.cz/images/592/java10-2-prev.png" width="194" height="270" alt=" " /></a>
<p><i>Obrázek 2: Dvì hlavní oblasti haldy (young generation a tenured
generation) a podrobnìj¹í pohled na podoblast tenured generation.</i></p>



<p><a name="k02"></a></p>
<h2>2. Propustnost versus èas pozastavení bìhu aplikací</h2>

<p>V&nbsp;pøedchozí èásti seriálu jsme si takté¾ popsali základní metody
(nabízené pøímo bìhovým prostøedím Javy &ndash; <i>JRE</i>) pro monitorování
èinnosti správce pamìti. Pro tento úèel je mo¾né pøi spou¹tìní virtuálního
stroje Javy pou¾ít volby <strong>-verbose:gc</strong>,
<strong>-Xloggc:jméno_souboru</strong> a <strong>-XX:PrintGCDetails</strong>,
které se èasto kombinují s&nbsp;volbou <strong>>-XX:PrintGCTimeStamps</strong>
(pøidání informací o èase, v&nbsp;ní¾ byl správce pamìti spu¹tìn). Pomocí
tìchto voleb lze zjistit, jak èasto se správce pamìti spou¹tí, o kterého
správce pamìti se jedná (<i>young generation</i> èi <i>tenured generation</i>)
a takté¾ obsazení jednotlivých oblastí na haldì. Pokud dochází
k&nbsp;výkonnostním problémùm, lze vý¹e uvedené volby kombinovat takté¾
s&nbsp;profilerem (<strong>-Xprof</strong>) s&nbsp;jeho¾ pomocí je mo¾né
zjistit, kterou èást kódu je vhodné upravit. Ov¹em v&nbsp;nìkterých pøípadech
nám údaje poskytované s&nbsp;vyu¾itím tìchto voleb nemusí plnì dostaèovat.</p>

<a href="http://i.iinfo.cz/images/592/java10-3.png"><img src="http://i.iinfo.cz/images/592/java10-3-prev.png" width="223" height="270" alt=" " /></a>
<p><i>Obrázek 3: Celková doba bìhu testovací aplikace
<strong>ConcatTest1</strong> (vyjádøená v&nbsp;sekundách) v&nbsp;závislosti na
maximální velikosti haldy (vyjádøené v&nbsp;megabajtech).</i></p>

<p>Jedná se napøíklad o situace, kdy dochází k&nbsp;takovým problémùm se
správou pamìti, ¾e aplikace musí být pozastavovaná na dlouhou dobu, co¾ sice
nemusí pøi èíselném vyjádøení prùmìrné doby èinnosti správce pamìti být
alarmující, ov¹em dlouhé intervaly jsou velmi nepøíjemné, a to jak u
desktopových aplikací s&nbsp;grafickým u¾ivatelským rozhraním, tak i napøíklad
u aplikací serverových (vùbec ji¾ nemluvì o aplikacích bì¾ících v&nbsp;reálném
èase). V&nbsp;praxi se tedy rozli¹uje mezi <i>propustností systému</i> (zhruba
øeèeno jde o zprùmìrovaný výkon sni¾ovaný mj.&nbsp;i èinností správce pamìti) a
<i>maximální dobou</i> pozastavení aplikace z&nbsp;dùvodu èinnosti správce
pamìti.</p>

<a href="http://i.iinfo.cz/images/592/java10-4.png"><img src="http://i.iinfo.cz/images/592/java10-4-prev.png" width="217" height="270" alt=" " /></a>
<p><i>Obrázek 4: Poèet spu¹tìní správce pamìti v&nbsp;závislosti na maximální
velikosti haldy (vyjádøené v&nbsp;megabajtech).</i></p>

<p>Pro detekci takových kritických okam¾ikù v&nbsp;¾ivotì aplikace je mo¾né
pou¾ít volby <strong>-XX:+PrintGCApplicationConcurrentTime</strong> a
<strong>-XX:+PrintGCApplicationStoppedTime</strong>. Ka¾dou z&nbsp;tìchto voleb
je samozøejmì mo¾né vyu¾ít samostatnì, spoleènì, nebo je lze kombinovat
s&nbsp;ostatními volbami &ndash; v¹e zále¾í na na¹ich schopnostech pøi
zpracování standardního výstupu generovaného <i>JRE</i> :-). První
z&nbsp;tìchto voleb slou¾í pro zapnutí výpisu èasových intervalù, v&nbsp;nich¾
aplikace bì¾í bez pøeru¹ení, pøesnìji øeèeno bez pøeru¹ení správcem pamìti
(aplikace samozøejmì mù¾e pasivnì èekat na jiné události). Pokud tuto volbu
pou¾ijeme, budou se na standardní výstup vypisovat následující údaje (formát je
platný pro poslední oficiální verzi <i>JDK 6</i> i pro <i>OpenJDK 6</i>):</p>

<pre>
Application time: 0.0194960 seconds
Application time: 0.0035360 seconds
Application time: 0.0030870 seconds
Application time: 0.0026110 seconds
...
</pre>

<a href="http://i.iinfo.cz/images/50/java11-1.png"><img src="http://i.iinfo.cz/images/50/java11-1-prev.png" width="370" height="252" alt=" " /></a>
<p><i>Obrázek 5: Graficky zpracované hodnoty vypisované pomocí volby
<strong>-XX:PrintGCApplicationConcurrentTime</strong> (intervaly kdy aplikace
bì¾í) v&nbsp;pøípadì, ¾e je testovací aplikace <strong>ConcatTest1</strong>
spu¹tìna s&nbsp;maximální povolenou velikostí haldy na 20MB.</i></p>

<p>Význam tìchto údajù je zøejmý: nejprve aplikace pracovala po dobu 19,4 ms,
poté byla na urèitou dobu pøeru¹ena kvùli správì pamìti, následnì opìt mohla
bì¾et bez pøeru¹ení cca 3,5 ms atd. Informaci o tom, na jak dlouho byla
aplikace pøeru¹ena èinností správce pamìti, lze získat po zapnutí volby
<strong>-XX:+PrintGCApplicationStoppedTime</strong>:</p>

<pre>
Total time for which application threads were stopped: 0.0035280 seconds
Total time for which application threads were stopped: 0.0017170 seconds
Total time for which application threads were stopped: 0.0009440 seconds
</pre>

<a href="http://i.iinfo.cz/images/50/java11-2.png"><img src="http://i.iinfo.cz/images/50/java11-2-prev.png" width="370" height="252" alt=" " /></a>
<p><i>Obrázek 6: Graficky zpracované hodnoty vypisované pomocí volby
<strong>-XX:PrintGCApplicationStoppedTime</strong> (intervaly, kdy je aplikace
pøeru¹ena kvùli GC) v&nbsp;pøípadì, ¾e je testovací aplikace
<strong>ConcatTest1</strong> spu¹tìna s&nbsp;maximální povolenou velikostí
haldy na 20MB.</i></p>

<p>Pøi kombinaci obou vý¹e zmínìných voleb získáme výpis, v&nbsp;nìm¾ se oba údaje støídají:</p>

<pre>
Application time: 0.0196750 seconds
Total time for which application threads were stopped: 0.0034630 seconds
Application time: 0.0035820 seconds
Total time for which application threads were stopped: 0.0017060 seconds
Application time: 0.0030790 seconds
Total time for which application threads were stopped: 0.0008940 seconds
Application time: 0.0026010 seconds
Total time for which application threads were stopped: 0.0005410 seconds
</pre>

<a href="http://i.iinfo.cz/images/50/java11-3.png"><img src="http://i.iinfo.cz/images/50/java11-3-prev.png" width="370" height="250" alt=" " /></a>
<p><i>Obrázek 7: Graficky zpracované hodnoty vypisované pomocí volby
<strong>-XX:PrintGCApplicationConcurrentTime</strong>, ov¹em tentokrát
setøídìné sestupnì.</i></p>



<p><a name="k03"></a></p>
<h2>3. Co lze napravit pøi výkonnostních problémech?</h2>

<p>Pokud se pøi mìøení výkonnosti aplikace stane, ¾e jsou zji¹tìny velké
prodlevy zpùsobené èinností správce pamìti, nebo ¾e správce pamìti výrazným
zpùsobem sni¾uje celkovou propustnost systému, lze provést (nebo alespoò
vyzkou¹et) nìkterou z&nbsp;následujících úprav:</p>

<ol>

<li>Upravit algoritmus aplikace a/nebo datové struktury, které aplikace pou¾ívá
(to se ov¹em lehko øekne, ¾e...).</li>

<li>Na 64bitových platformách je mo¾né pou¾ít ji¾ popsané <a
href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">komprimované
ukazatele na objekty</a>, které v&nbsp;nìkterých pøípadech mohou pomìrnì
výraznì sní¾it obsazení haldy. Do jaké míry je tato volba v&nbsp;konkrétní
aplikaci u¾iteèná, zále¾í pøedev¹ím na tom, s&nbsp;jakými datovými strukturami
se pracuje (resp.&nbsp;v&nbsp;jaké míøe se pou¾ívají reference &ndash; typické
u grafových struktur, speciálnì binárních stromù èi vázaných seznamù).</li>

<li>Velký vliv na výkonnost správce pamìti a tím pádem i celé aplikace, má
výchozí i maximální velikost haldy nastavovaná pomocí vý¹e uvedených voleb
<strong>-Xmx</strong> a <strong>-Xms</strong> (v&nbsp;mnoha pøípadech je
výhodné, aby obì volby obsahovaly shodné hodnoty). Ov¹em maximální velikost
haldy by nemìla pøesáhnout volnou kapacitu fyzické operaèní pamìti, proto¾e by
jinak docházelo k&nbsp;odkládání stránek na disk, co¾ naopak výkonnost citelnì
sni¾uje (to je ji¾ výhodnìj¹í obìtovat nìkolik procent strojového èasu na bìh
správce pamìti).</li>

<li>Kromì specifikace celkové velikosti haldy má velký vliv na výkonnost i
zpùsob rozdìlení haldy na <i>young generation</i> a <i>tenured generation</i>
pomocí voleb popsaných <a
href="http://www.root.cz/clanky/monitorovani-procesu-a-sprava-pameti-v-jdk-6-a-
jdk-7-4/">minule</a>. Na rozdíl od pøedchozích voleb <strong>-Xmx</strong> a
<strong>-Xms</strong>, jejich¾ hodnoty se nastavují celkem snadno, je
v&nbsp;tomto pøípadì ji¾ vìt¹inou nutné provádìt profilování a monitorování
aplikací bì¾ících ve stejném prostøedí, kde mají být aplikace nasazeny a takté¾
se <i>shodnými (nebo velmi podobnými) daty</i> (mìøení výkonnosti aplikace nad
testovací databází s&nbsp;10000 záznamy nám prakticky nic neøekne o tom, jak se
aplikace bude chovat nad reálnými daty s&nbsp;10 miliony záznamy a nìkolika
desítkami soubì¾nì zpracovávaných po¾adavkù).</li>

<li>V&nbsp;pøípadì, ¾e správce pamìti zvolený virtuálním strojem jazyka Java
z&nbsp;nìjakého dùvodu potøebám aplikace nevyhovuje (co¾ se stává pomìrnì
èasto!), lze zvolit jiný typ správce pamìti. Jde se o dosti dùle¾itou
problematiku popsanou v&nbsp;navazujících kapitolách.</li>

<li>V&nbsp;neposlední øadì je takté¾ mo¾né správci pamìti ponìkud pomoci
vyu¾itím velkých stránek (<i>huge pages</i>, <i>large pages</i>). Tuto mo¾nost
sice není mo¾né vyu¾ít na v¹ech systémech, ale na mnohých serverech je mo¾né
velké stránky pøi startu systému povolit a následnì je i vyu¾ívat
v&nbsp;<i>JRE</i> pøi mapování pamìti pro haldu. Tato problematika, která se
kvùli neustále se zvy¹ujícím kapacitám operaèních pamìtí dostává stále èastìji
do povìdomí programátorù i administrátorù, bude popsána v&nbsp;navazující èásti
tohoto seriálu.</li>

</ol>

<a href="http://i.iinfo.cz/images/50/java11-4.png"><img src="http://i.iinfo.cz/images/50/java11-4-prev.png" width="339" height="270" alt=" " /></a>
<p><i>Obrázek 8: Pøi sní¾ení maximální kapacity haldy na pouhé 2MB se zmen¹ují
i intervaly, v&nbsp;nich¾ testovací aplikace bì¾í bez toho, aby byl její bìh
pøeru¹ován správcem pamìti.</i></p>



<p><a name="k04"></a></p>
<h2>4. Sériový správce pamìti</h2>

<p>Na nìkterých platformách a zejména pøi spu¹tìní bìhového prostøedí Javy
v&nbsp;re¾imu <i>client</i>, se pou¾ívá takzvaný <i>sériový správce pamìti</i>.
Jak ji¾ název napovídá, pracuje tento správce pamìti v&nbsp;jednom vláknu,
pøièem¾ jeho èinnost odpovídá èinnosti popsané v&nbsp;minulé a pøedminulé èásti
tohoto seriálu (rozdìlení haldy na dvì èásti, dva rùzné typy algoritmù
v&nbsp;závislosti na tom, nad kterou èástí haldy správce pamìti pracuje...). Na
poèítaèích vybavených jedním procesorem s&nbsp;jedním nebo dvìma jádry
(popø.&nbsp;s&nbsp;jedním jádrem podporujícím <i>hyperthreading</i>) se ve
velké vìt¹inì pøípadù jedná o nejvhodnìj¹í typ správce pamìti, který se navíc
chová velmi deterministicky (pøedvídatelnì). Souèasnì je sériový správce pamìti
tím nejjednodu¹¹ím správcem pamìti, který je v&nbsp;souèasných verzích
<i>JDK</i> a <i>OpenJDK</i> implementován; navíc jde i o historicky nejstar¹í
implementaci stále podporovanou i v&nbsp;moderních <i>JDK</i> (tyto dvì
vlastnosti pøispívají k&nbsp;jeho velké stabilitì). V&nbsp;nìkterých pøípadech
se v¹ak mù¾e ukázat, ¾e tento správce pamìti nemusí být pro daný typ aplikace
tou nejvhodnìj¹í volbou.</p>

<a href="http://i.iinfo.cz/images/50/java11-5.png"><img src="http://i.iinfo.cz/images/50/java11-5-prev.png" width="370" height="200" alt=" " /></a>
<p><i>Obrázek 9: Hodnoty vypisované pomocí volby
<strong>-XX:PrintGCApplicationStoppedTime</strong> (intervaly, kdy je aplikace
pøeru¹ena kvùli GC) v&nbsp;pøípadì, ¾e je testovací aplikace
<strong>ConcatTest1</strong> spu¹tìna s&nbsp;maximální povolenou velikostí
haldy sní¾enou na pouhé 2MB (lze porovnat s&nbsp;obrázkem èíslo 6).
Pov¹imnìte si, jak se postupnì mìní pomìr krátkých a dlouhých intervalù.</i></p>

<p>Sériový správce pamìti mù¾e zpùsobovat problémy u tìch aplikací, u nich¾
jsou vy¾adovány co nejkrat¹í (popø.&nbsp;navíc predikovatelné) intervaly
pøeru¹ení bìhu aplikace kvùli správì pamìti. V&nbsp;tomto pøípadì je namísto
sériového správce pamìti vhodnìj¹í pou¾ít buï nìkterý z&nbsp;ostatních
standardních správcù pamìti, nebo pou¾ít prozatím sice je¹tì experimentální,
ale velmi dobrý a po teoretické stránce promy¹lený správce pamìti <i>G1</i>,
který se v&nbsp;souèasných verzích <i>JDK</i> a <i>OpenJDK</i> zapíná dvojicí
voleb <strong>-XX:+UnlockExperimentalVMOptions -XX:+UseG1GC</strong>. Ov¹em
sériový správce pamìti mù¾e být nevhodný takté¾ i ve chvíli, kdy je aplikace
provozována na výkonných serverech s&nbsp;vìt¹ím mno¾stvím procesorových jader
&ndash; v&nbsp;souèasnosti se ostatnì stroje s&nbsp;osmi èi dokonce ¹estnácti
jádry stávají ji¾ vcelku bì¾nou výbavou serveroven. Na tìchto výkonných
poèítaèích se toti¾ sériový správce pamìti mù¾e stát úzkým hrdlem celé
aplikace, co¾ si budeme ilustrovat v&nbsp;následující kapitole.</p>

<a href="http://i.iinfo.cz/images/50/java11-6.png"><img src="http://i.iinfo.cz/images/50/java11-6-prev.png" width="370" height="205" alt=" " /></a>
<p><i>Obrázek 10: Hodnoty vypisované pomocí volby
<strong>-XX:PrintGCApplicationConcurrentTime</strong>, ov¹em tentokrát
setøídìné sestupnì. Tento graf je platný pro testovací aplikaci
<strong>ConcatTest1</strong> spu¹tìnou s&nbsp;maximální povolenou velikostí
haldy 2 MB (lze porovnat s&nbsp;obrázek 7).</i></p>



<p><a name="k05"></a></p>
<h2>5. Správce pamìti jako úzké hrdlo víceprocesorového systému?</h2>

<p>V&nbsp;pøedchozí kapitole jsme si øekli, ¾e sériový správce pamìti
(<i>serial garbage collector</i>) nemusí být v¾dy vhodný pøi provozování
aplikace na poèítaèích, které jsou osazeny vìt¹ím mno¾stvím procesorových
jader. Dùvod je jednoduchý: sériový správce pamìti je spu¹tìn v&nbsp;jediném, i
kdy¾ samostatném vláknì, tak¾e vlastnì pøedstavuje tu èást aplikace, která není
dobøe ¹kálovatelná se zvy¹ujícím se poètem procesorových jader &ndash; zejména
v&nbsp;tìch pøípadech, kdy jsou pou¾ity ètyøi procesorová jádra nebo i vìt¹í
mno¾ství jader (pro jednoduchost nyní uva¾ujme o procesorech podporujících
hyperthreading jako o vícejádrových procesorech, co¾ sice není zcela pøesné,
ale pro první pøiblí¾ení dostaèující).</p>

<a href="http://i.iinfo.cz/images/50/java11-7.png"><img src="http://i.iinfo.cz/images/50/java11-7-prev.png" width="370" height="222" alt=" " /></a>
<p><i>Obrázek 11: Jednovláknová aplikace (<strong>ConcatTest1</strong>)
spu¹tìná na poèítaèi s&nbsp;osmi jádry nedoká¾e dobøe vyu¾ít v¹echny mo¾nosti
nabízené tímto relativnì výkonným strojem.</i></p>

<p>Pøedstavme si, ¾e aplikace provozovaná na virtuálním stroji jazyka Java je
optimalizovaná takovým zpùsobem, aby se dosáhlo co nejvìt¹í propustnosti
(<i>throughput</i>) na poèítaèi, v&nbsp;nìm¾ je nainstalováno vìt¹í mno¾ství
procesorových jader, napøíklad dva procesory s&nbsp;podporou hyperthreadingu.
To znamená, ¾e je v&nbsp;takové aplikaci vytvoøeno vìt¹í mno¾ství soubì¾nì
pracujících vláken. Ve zcela ideálním pøípadì (ka¾dý ideál je ov¹em
nedosa¾itelný ;-)) pracují v¹echna vlákna skuteènì samostatnì, tj.&nbsp;není
zapotøebí je synchronizovat kvùli pøístupu k&nbsp;nìjakému sdílenému
prostøedku. Pomìrnì velké mno¾ství algoritmizovatelných problémù je skuteènì
mo¾né paralelizovat, tak¾e by se mohlo zdát, ¾e zvý¹ení propustnosti celého
systému lze mj.&nbsp;dosáhnout i prostým spu¹tìním aplikace na poèítaèi
s&nbsp;vìt¹ím mno¾stvím procesorù a ¾e výkon aplikace poroste zhruba lineárnì
s&nbsp;poètem procesorù (nebo jejich jader) &ndash; viz té¾ následující
obrázek.</p>

<a href="http://i.iinfo.cz/images/50/java11-8.png"><img src="http://i.iinfo.cz/images/50/java11-8-prev.png" width="360" height="270" alt=" " /></a>
<p><i>Obrázek 12: Dokonale ¹kálovatelná aplikace, kde sériový správce pamìti
nevy¾aduje ¾ádný výkon CPU. Na horizontální osu je vynesen poèet procesorových
jader, na vertikální osu míra urychlení (propustnost).</i></p>

<p>Ov¹em pokud je aplikace provozována na virtuálním stroji jazyka Java
(<i>JVM</i>) s&nbsp;bì¾ícím sériovým správcem pamìti, stává se tento správce
úzkým hrdlem celého systému, proto¾e pøi jeho bìhu, pøesnìji ve druhé èásti
algoritmu <i>Mark and Sweep</i>, musí správce pamìti na urèitý okam¾ik
pozastavit v¹echna ostatní vlákna aplikace. I v&nbsp;pøípadì, ¾e celý cyklus
správy pamìti vy¾aduje pouze 5% nebo 10% výkonu poèítaèe, má i tato relativnì
malá èást aplikace velký dopad na její ¹kálovatelnost &ndash; v&nbsp;této
situaci se tedy uplatòuje <i>Amdahlùv zákon</i> (i kdy¾ je pravda, ¾e jsme si
celou problematiku ponìkud zjednodu¹ili).</p>

<a href="http://i.iinfo.cz/images/50/java11-9.png"><img src="http://i.iinfo.cz/images/50/java11-9-prev.png" width="360" height="270" alt=" " /></a>
<p><i>Obrázek 13: Ji¾ ve chvíli, kdy sériový správce pamìti vy¾aduje pouhých 5%
výkonu, klesá dosti výraznì propustnost celé aplikace. Napøíklad pro poèítaè
s&nbsp;20 jádry není urychlení dvacetinásobné, ale pouze desetinásobné.</i></p>



<p><a name="k06"></a></p>
<h2>6. Paralelní správci pamìti</h2>

<p>Na¹tìstí v¹ak nejsme v&nbsp;souèasných verzích <i>JDK</i> a <i>OpenJDK</i>
omezeni pouze na pou¾ití sériového správce pamìti. Namísto nìho mù¾eme
v&nbsp;pøípadì potøeby pou¾ít dal¹í tøi typy správcù &ndash; paralelního
správce pamìti (<i>ParallelGC</i>), takzvaného soubì¾nì pracujícího správce
typu Mark and Sweep (<i>Concurrent Mark and Sweep &ndash; CMS</i>) a takté¾
správce pamìti <i>G1</i>, který se v&nbsp;souèasnosti nachází v&nbsp;testovací
fázi vývoje. U paralelního správce pamìti lze zvolit, zda má jeho paralelní
èást bì¾et pouze nad oblastí <i>young generation</i> nebo i nad oblastí
<i>tenured generation</i> a u v¹ech správcù se navíc mù¾e zvolit (a je to i
v&nbsp;mnoha pøípadech vhodné), v&nbsp;kolika vláknech tito správci pobì¾í.
Podrobnìj¹ím popisem algoritmù tìchto správcù pamìti se budeme zabývat pøí¹tì,
dnes si v¹ak ji¾ øekneme, jaké volby lze pro jejich spu¹tìní pou¾ít. Pro
úplnost zaènìme sériovým správcem pamìti. Ten se vybírá následujícím
zpùsobem:</p>

<pre>
java -XX:+UseSerialGC ConcatTest1
</pre>

<p>Paralelní správce pamìti bì¾ící nad oblastí <i>young generation</i> se
zapíná takto:</p>

<pre>
java -XX:+UseParallelGC ConcatTest1
</pre>

<p>Pokud má paralelní èást správce pamìti pracovat i nad oblastí <i>tenured
generation</i>, lze vyu¾ít volbu:</p>

<pre>
java -XX:+UseParallelOldGC ConcatTest1
</pre>

<a href="http://i.iinfo.cz/images/50/java11-10.png"><img src="http://i.iinfo.cz/images/50/java11-10-prev.png" width="360" height="270" alt=" " /></a>
<p><i>Obrázek 14: Stav, kdy sériový správce pamìti vy¾aduje ji¾ 10% výkonu, by
byl ji¾ pro vìt¹í poèet procesorových jader neakceptovatelný.</i></p>

<p>Správce pamìti <i>CMS</i> není mo¾né pou¾ít souèasnì s&nbsp;pøedchozími typy
správcù pamìti, star¹í verze JDK v¹ak na tuto chybu u¾ivatele neupozoròovaly.
V&nbsp;ka¾dém pøípadì, pokud je vhodné pou¾ít <i>CMS</i> (napøíklad pøi
po¾adavcích na rychlé odezvy aplikace), pou¾ívá se tato volba:</p>

<pre>
java -XX:+UseConcMarkSweepGC ConcatTest1
</pre>

<p>Jak jsme si ji¾ øekli v&nbsp;pøedchozím textu, nìkdy je vhodné pøímo urèit
poèet vláken, které jsou jednotlivými paralelními správci pamìti vyu¾ity:</p>

<pre>
java -XX:+UseParallelGC -XX:ParallelGCThreads=4 ConcatTest1
java -XX:+UseParallelOldGC -XX:ParallelGCThreads=4 ConcatTest1
java -XX:+UseConcMarkSweepGC -XX:ParallelGCThreads=4 ConcatTest1
</pre>

<a href="http://i.iinfo.cz/images/50/java11-11.png"><img src="http://i.iinfo.cz/images/50/java11-11-prev.png" width="360" height="270" alt=" " /></a>
<p><i>Obrázek 15: Vliv sériového správce pamìti si mù¾eme zobrazit i jinak. Na
tomto grafu jsou na horizontální osu vyneseny po¾adavky správce pamìti na
výpoèetní výkon (od 0% do 100%) a na vertikální ose skuteèné urychlení jinak
dokonale ¹kálovatelné aplikace bì¾ící na poèítaèi se ¹estnácti
procesory.</i></p>



<p><a name="k07"></a></p>
<h2>7. Testovací pøíklad</h2>

<p>Pro otestování funkce správcù pamìti na poèítaèi s&nbsp;vìt¹ím mno¾stvím
procesorù jsem vytvoøil velmi jednoduchou modifikaci na¹eho pùvodního pøíkladu
<strong>ConcatTest1</strong>. Modifikovaná verze nazvaná
<strong>ConcurrentConcatenationTest</strong> po svém spu¹tìní vytvoøí <i>n</i>
vláken (<i>n</i> lze zadat jako parametr, jinak je zvolena hodnota 8), kde
ka¾dé vlákno samostatnì provádí pamì»ovì nároènou konkatenaci øetìzce. Pøi
startu vlákna, pøi dokonèení výpoètu (konkatenace øetìzce) i pøed ukonèením
vlákna se na standardní výstup vypí¹e èíslo (ID) daného vlákna a informace o
tom, v&nbsp;jakém stavu se vlákno nachází:</p>

<pre>
class ConcatenationThread extends Thread {
    private static final int DEFAULT_LOOP_COUNT = 10000;
    private int threadId;

    public ConcatenationThread(int threadId) {
        this.threadId = threadId;
    }

    public String createString() {
        String str = "";
        for (int i = 0; i &lt; DEFAULT_LOOP_COUNT; i++) {
            str += i + " ";
        }
        return str;
    }

    @Override
    public void run() {
        System.out.format("Thread #%d started\n", this.threadId);
        System.out.format("Thread #%d: string length %d\n", this.threadId, createString().length());
        System.out.format("Thread #%d finished\n", this.threadId);
    }
}

public class ConcurrentConcatenationTest {
    private static final int DEFAULT_THREAD_COUNT = 8;

    public static void main(String[] args) {
        int threadCount = args.length == 0 ? DEFAULT_THREAD_COUNT : Integer.parseInt(args[0]);
        for (int i = 0; i &lt; threadCount; i++) {
            new ConcatenationThread(i).start();
        }
        System.out.println("Main thread finished");
    }

}
</pre>

<a href="http://i.iinfo.cz/images/50/java11-12.png"><img src="http://i.iinfo.cz/images/50/java11-12-prev.png" width="370" height="221" alt=" " /></a>
<p><i>Obrázek 16: Testovací pøíklad <strong>ConcurrentConcatenationTest</strong>
spu¹tìný na poèítaèi s&nbsp;osmi procesorovými jádry ji¾ vyu¾ívá mo¾nosti
poèítaèe lépe ne¾ program <strong>ConcatTest1</strong>.</i></p>



<p><a name="k08"></a></p>
<h2>8. Výsledky bìhu testovacího pøíkladu</h2>

<p>Základní vlastnost paralelních správcù pamìti &ndash; tj.&nbsp;propustnost
aplikace &ndash; si mù¾eme jednodu¹e otestovat tak, ¾e budeme spou¹tìt vý¹e
uvedený demonstraèní pøíklad s&nbsp;rùznými správci pamìti a s&nbsp;rùzným
poètem vláken vyhrazených pro tyto správce. Skript, který zajistí vytvoøení
souborù se statistickými daty, je pomìrnì jednoduchý (pov¹imnìte si, ¾e lze
specifikovat i maximální velikost pamìti vyhrazené pro haldu):</p>

<pre>
#!/bin/bash

# kolik vlaken ma byt vyhrazeno GC
MIN_GC_THREADS=1
MAX_GC_THREADS=16

# velikost haldy v megabajtech
HEAP_SIZE=5

function run_java () {
    # nechceme volat interni prikaz time z BASHe!
    echo "JVM parameters: $1"
    /usr/bin/time -o $2 -a -f "%U" java -Xmx${HEAP_SIZE}M $1 ConcurrentConcatenationTest
}

# seriovy spravce pameti
run_java "-XX:+UseSerialGC" _time_serial.txt

# paralelni spravce pameti bezici nad young generation
for par in `seq $MIN_GC_THREADS $MAX_GC_THREADS`;
do
    run_java "-XX:+UseParallelGC -XX:ParallelGCThreads=${par}" _time_parallel_young.txt
done

# paralelni spravce pameti bezici nad young i tenured generation
for par in `seq $MIN_GC_THREADS $MAX_GC_THREADS`;
do
    run_java "-XX:+UseParallelOldGC -XX:ParallelGCThreads=${par}" _time_parallel_old_gc.txt
done

# spravce pameti typu Concurrent Mark and Sweep
for par in `seq $MIN_GC_THREADS $MAX_GC_THREADS`;
do
    run_java "-XX:+UseConcMarkSweepGC -XX:ParallelGCThreads=${par}" _time_concurrent.txt
done
</pre>

<p>Výsledky bude pravdìpodobnì nejlep¹í si zobrazit graficky. V&nbsp;prvním
grafu jsou ukázány èasy bìhu testovací aplikace v&nbsp;pøípadì, ¾e je maximální
velikost haldy nastavena na 20MB a poèet vláken pro správce pamìti se pohybuje
od 1 do 16 (v¹e na osmijádrovém systému!). Pov¹imnìte si, ¾e s&nbsp;rostoucím
poètem vláken vytvoøených pro správce pamìti (nikoli pro výkonnou èást
aplikace) ve skuteènosti od urèité pomìrnì nízké hranice <i>klesá</i>
propustnost, tj.&nbsp;prodlu¾uje se celkový èas bìhu aplikace:</p>

<a href="http://i.iinfo.cz/images/50/java11-13.png"><img src="http://i.iinfo.cz/images/50/java11-13-prev.png" width="370" height="267" alt=" " /></a>

<p>Pøi pohledu na pøedchozí graf by se mohlo zdát, ¾e v¾dy jasnì vyhrává
paralelní správce pamìti. Ve skuteènosti tomu v¹ak tak nemusí být v¾dycky.
Podívejme se, co se stane, kdy¾ se velikost haldy sní¾í na pouhých 5MB. Zde se
dostáváme do situace (zde umìle vytvoøené, ov¹em v&nbsp;praxi takté¾
nastávající), ¾e se zmen¹ují oblasti, nad kterými správci pamìti pracují a
jednotlivá vlákna si tak spí¹e pøeká¾ejí (toto je ostatnì jeden z&nbsp;pøípadù,
kdy starý dobrý sériový správce pamìti mù¾e být výkonnìj¹í ne¾ mnohem
slo¾itìj¹í správci paralelní):</p>

<a href="http://i.iinfo.cz/images/50/java11-14.png"><img src="http://i.iinfo.cz/images/50/java11-14-prev.png" width="368" height="270" alt=" " /></a>

<p>To, jakým zpùsobem lze tyto (a mnohé dal¹í) problémy øe¹it, se budeme
zabývat pøí¹tì.</p>



<p><a name="k09"></a></p>
<h2>9. Odkazy na Internetu</h2>

<ol>

<li>První graf z&nbsp;osmé kapitoly v&nbsp;plném rozli¹ení<br />
<a class="rs-file file-png" href="http://i.iinfo.cz/files/root/254/java-11-graf1.png">java-11-graf1</a>
</li>

<li>Druhý graf z&nbsp;osmé kapitoly v&nbsp;plném rozli¹ení<br />
<a class="rs-file file-png" href="http://i.iinfo.cz/files/root/561/java-11-graf2.png">java-11-graf2</a>
</li>

<li>V¹echny zdrojové soubory a skripty pou¾ité v&nbsp;dne¹ním èlánku<br />
<a class="rs-file file-x-bzip2" href="http://i.iinfo.cz/files/root/54/java11-src.bz2">java11-src</a>
</li>

<li>Výsledky pou¾ívané pøi tvorbì grafù v&nbsp;dne¹ním èlánku<br />
<a class="rs-file file-x-bzip2" href="http://i.iinfo.cz/files/root/60/java11-results.bz2">java11-results</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a>
</li>

<li>Amdahl's law<br />
<a href="http://en.wikipedia.org/wiki/Amdahl_law">http://en.wikipedia.org/wiki/Amdahl_law</a>
</li>

<li>Garbage collection (computer science)<br />
<a href="http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)</a>
</li>

<li>Dr. Dobb's | G1: Java's Garbage First Garbage Collector<br />
<a href="http://www.drdobbs.com/article/printableArticle.jhtml?articleId=219401061&amp;dept_url=/java/">http://www.drdobbs.com/article/printableArticle.jhtml?articleId=219401061&amp;dept_url=/java/</a>
</li>

<li>Java's garbage-collected heap<br />
<a href="http://www.javaworld.com/javaworld/jw-08-1996/jw-08-gc.html">http://www.javaworld.com/javaworld/jw-08-1996/jw-08-gc.html</a>
</li>

<li>Compressed oops in the Hotspot JVM<br />
<a href="http://wikis.sun.com/display/HotSpotInternals/CompressedOops">http://wikis.sun.com/display/HotSpotInternals/CompressedOops</a>
</li>

<li>32-bit or 64-bit JVM? How about a Hybrid?<br />
<a href="http://blog.juma.me.uk/2008/10/14/32-bit-or-64-bit-jvm-how-about-a-hybrid/">http://blog.juma.me.uk/2008/10/14/32-bit-or-64-bit-jvm-how-about-a-hybrid/</a>
</li>

<li>Compressed object pointers in Hotspot VM<br />
<a href="http://blogs.sun.com/nike/entry/compressed_object_pointers_in_hotspot">http://blogs.sun.com/nike/entry/compressed_object_pointers_in_hotspot</a>
</li>

<li>Java HotSpot(tm) Virtual Machine Performance Enhancements<br />
<a href="http://download.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html">http://download.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html</a>
</li>

<li>Using jconsole<br />
<a href="http://download.oracle.com/javase/1.5.0/docs/guide/management/jconsole.html">http://download.oracle.com/javase/1.5.0/docs/guide/management/jconsole.html</a>
</li>

<li>jconsole &ndash; Java Monitoring and Management Console<br />
<a href="http://download.oracle.com/javase/1.5.0/docs/tooldocs/share/jconsole.html">http://download.oracle.com/javase/1.5.0/docs/tooldocs/share/jconsole.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>x86-64<br />
<a href="http://en.wikipedia.org/wiki/X86-64">http://en.wikipedia.org/wiki/X86-64</a>
</li>

<li>Physical Address Extension<br />
<a href="http://en.wikipedia.org/wiki/Physical_Address_Extension">http://en.wikipedia.org/wiki/Physical_Address_Extension</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>1.6.0_14 (6u14)<br />
<a href="http://www.oracle.com/technetwork/java/javase/6u14-137039.html?ssSourceSiteId=otncn">http://www.oracle.com/technetwork/java/javase/6u14-137039.html?ssSourceSiteId=otncn</a>
</li>

<li>Update Release Notes<br />
<a href="http://www.oracle.com/technetwork/java/javase/releasenotes-136954.html">http://www.oracle.com/technetwork/java/javase/releasenotes-136954.html</a>
</li>

<li>Java virtual machine: 4.10 Limitations of the Java Virtual Machine<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#88659">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#88659</a>
</li>

<li>Java(TM) Platform, Standard Edition 7 Binary Snapshot Releases<br />
<a href="http://dlc.sun.com.edgesuite.net/jdk7/binaries/index.html">http://dlc.sun.com.edgesuite.net/jdk7/binaries/index.html</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>ClosableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>ArrayList (JDK 1.4)<br />
<a href="http://download.oracle.com/javase/1.4.2/docs/api/java/util/ArrayList.html">http://download.oracle.com/javase/1.4.2/docs/api/java/util/ArrayList.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2011</small></p>
</body>
</html>

