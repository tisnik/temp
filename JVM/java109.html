<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - bitmapy typu BufferedImage a VolatileImage v celoobrazovkových re¾imech</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - bitmapy typu BufferedImage a VolatileImage v celoobrazovkových re¾imech</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o virtuálním stroji Javy si na ètveøici demonstraèních pøíkladù uká¾eme, jakým zpùsobem je mo¾né vyu¾ít bitmapy (rastrové obrázky) typu BufferedImage a VolatileImage v celoobrazovkových (exkluzivních) grafických re¾imech, a to vèetnì podpory prùhlednosti.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - bitmapy typu <strong>BufferedImage</strong> a <strong>VolatileImage</strong> v&nbsp;celoobrazovkových re¾imech</a></p>
<p><a href="#k02">2. První demonstraèní pøíklad: vykreslení pozadí a spritu v&nbsp;celoobrazovkovém re¾imu</a></p>
<p><a href="#k03">3. Zamezení poblikávání s&nbsp;vyu¾itím bitmapy typu <strong>BufferedImage</strong> ve funkci offscreen bufferu</a></p>
<p><a href="#k04">4. Druhý demonstraèní pøíklad: vykreslení pozadí a spritu do bufferu tvoøeného bitmapou typu BufferedImage</a></p>
<p><a href="#k05">5. Vyu¾ití bitmap typu <strong>VolatileImage</strong></a></p>
<p><a href="#k06">6. Detekce zmìny stavu grafické konfigurace a zneplatnìní obsahu volatilních bitmap</a></p>
<p><a href="#k07">7. Tøetí demonstraèní pøíklad: vykreslení pozadí a spritu do bufferu tvoøeného bitmapou typu <strong>VolatileImage</strong></a></p>
<p><a href="#k08">8. Problematika prùhledných obrázkù</a></p>
<p><a href="#k09">9. Ètvrtý demonstraèní pøíklad: vykreslení pozadí a poloprùhledného spritu do bufferu tvoøeného bitmapou typu <strong>VolatileImage</strong></a></p>
<p><a href="#k10">10. Repositáø se zdrojovými soubory dne¹ních demonstraèních pøíkladù</a></p>
<p><a href="#k11">11. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - bitmapy typu <strong>BufferedImage</strong> a <strong>VolatileImage</strong> v&nbsp;celoobrazovkových re¾imech</h2>

<p>V&nbsp;pøedchozí èásti tohoto seriálu jsme si vysvìtlili a na demonstraèním
pøíkladu (benchmarku) ukázali, jakým zpùsobem souèasné virtuální stroje jazyka
Java vykreslují rastrové obrázky (bitmapy) typu <strong>BufferedImage</strong>
popø.&nbsp;<strong>VolatileImage</strong>. Takté¾ jsme si øekli základní
rozdíly mezi tìmito dvìma typy bitmap. Dnes se budeme zabývat ponìkud
praktiètìj¹í problematikou; konkrétnì mo¾nostmi pou¾ití bitmap
<strong>BufferedImage</strong> i <strong>VolatileImage</strong> pøi práci ve
vybraném celoobrazovkovém exkluzivním grafickém re¾imu (<i>fullscreen exclusive
graphics mode</i>). Pøipomeòme si, ¾e JVM umo¾òuje na vìt¹inì systémù nastavení
celoobrazovkového grafického re¾imu se zvoleným rozli¹ením (napøíklad
800&times;600 pixelù èi 1600&times;1200 pixelù), zvolenou bitovou hloubkou
(vìt¹inou 8bpp, 16bpp, 24bpp a 32bpp) a takté¾ vybranou obnovovací frekvencí
obrazu. Následnì je mo¾né provádìt &bdquo;exkluzivní&ldquo; vykreslování pøes
pøedem nastavené a maximalizované okno (popø.&nbsp;rámec, dialog èi applet),
které má k&nbsp;dispozici celou plochu obrazovky.</p>

<p>Slovem &bdquo;exkluzivní&ldquo; je v&nbsp;pøedchozím odstavci my¹len fakt,
¾e okna a dialogy ostatních aplikací nebudou viditelná; pøi zapnutí
celoobrazovkového re¾imu se tak vlastnì vracíme do doby pøed roz¹íøením správcù
oken (co¾ ostatnì není pøi pohledu na smìr, kterým se vyvíjí moderní desktop a¾
tak ¹patná my¹lenka :-). Nabídka grafických re¾imù je závislá jak na
vlastnostech grafické karty èi grafického akcelerátoru, tak i na konfiguraci
monitorù. My dnes budeme pro jednoduchost pøedpokládat, ¾e je ke grafické
kartì/akcelerátoru pøipojen pouze jediný monitor, popø.&nbsp;¾e v¹echny
monitory budou zobrazovat stejný snímek. JVM sice umo¾òuje práci i na systémech
s&nbsp;více monitory (a dokonce i vìt¹ím mno¾stvím grafických karet), to je
v¹ak mnohdy pomìrnì komplikovaná problematika, kterou se budeme zabývat
v&nbsp;samostatném èlánku (navíc mnoho aplikací nepracuje pøi pou¾ití více
monitorù korektnì, napøíklad nerespektuje nastavení primárního displeje,
zobrazuje dialogy centrované uprostøed mezi monitory atd. atd.).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. První demonstraèní pøíklad: vykreslení pozadí a spritu v&nbsp;celoobrazovkovém re¾imu</h2>

<p>V&nbsp;dne¹ním prvním demonstraèním pøíkladu je ukázáno vykreslování bitmap
v&nbsp;celoobrazovkovém re¾imu. Tento pøíklad po svém spu¹tìní nejprve
inicializuje rámec (JFrame), u nìj¾ jsou vypnuty okraje a titulkový pruh.
Následnì je pro tento rámec povolen celoobrazovkový re¾im:</p>

<pre>
    <i>/**</i>
    <i> * Nastaveni parametru okna a zobrazeni.</i>
    <i> * @param gd </i>
     <i>*/</i>
    private void <strong>showJFrame</strong>(GraphicsDevice gd) {
        <i>// vypneme okraje a dalsi zbytecnosti :)</i>
        this.setUndecorated(true);
        this.setLocation(0, 0);
        this.setSize(FRAME_WIDTH, FRAME_HEIGHT);
        this.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
        this.createBufferStrategy(1);
        this.setVisible(true);
        gd.setFullScreenWindow(this);
    }
</pre>

<p>Posléze je nastaven celoobrazovkový grafický re¾im s&nbsp;rozli¹ením
1024&times;768 pixelù a bitovou hloubkou 16bpp. Tuto èást programu si mù¾ete
sami upravit na základì vlastností konkrétního poèítaèe, ostatní èásti programu
se novému rozli¹ení doká¾ou pøizpùsobit (pozor: na nìkterých systémech není
mo¾né specifikovat barvovou hloubku; mù¾ete zde v¹ak zadat hodnotu -1 a JVM
samo vybere vhodný grafický re¾im):</p>

<pre>
    <i>/**</i>
    <i> * Nastaveni grafickeho rezimu.</i>
     <i>*/</i>
    private void <strong>setDisplayMode</strong>(GraphicsDevice gd) {
        DisplayMode dm = new DisplayMode(FRAME_WIDTH, FRAME_HEIGHT, BPP, DisplayMode.REFRESH_RATE_UNKNOWN);
        gd.setDisplayMode(dm);
    }
</pre>

<p>Pøi vykreslování se pou¾ívá dvojice bitmap nazvaná pozadí
(<i>background</i>) a <i>sprite</i>. Pozadí je nemìnné a rozmìry této bitmapy
jsou stejné jako rozli¹ení nastaveného grafického re¾imu. <i>Sprite</i> se
naproti tomu neustále pohybuje nad pozadím. Vlastní vykreslovací rutina vyu¾ívá
metodu <strong>Graphics.drawImage()</strong>, která je na vìt¹inì souèasných
poèítaèù akcelerovaná (pokud tedy nedojde k&nbsp;problémùm s&nbsp;nezarovnanými
øádky, co¾ jsme si vysvìtlili minule):</p>

<pre>
    <i>@Override</i>
    public void <strong>paint</strong>(Graphics g) {
        final BufferedImage sprite = getSpriteImage();
        final BufferedImage background = getBackgroundImage();
        if (sprite == null || background == null) return;
        final int spriteX = getImageX() - sprite.getWidth() / 2;
        final int spriteY = getImageY() - sprite.getHeight() / 2;
        <i>// vykreslime pozadi</i>
        g.drawImage(background, 0, 0, null);
        <i>// nad nej vykreslime pohybujici se sprite</i>
        g.drawImage(sprite, spriteX, spriteY, null);
        <i>// neni zcela nutne</i>
        g.dispose();
        this.repaintCount++;
    }
</pre>

<p>Následuje výpis celého zdrojového kódu demonstraèního pøíkladu
<strong>BlitTest2</strong>:</p>

<pre>
import java.awt.Color;
import java.awt.DisplayMode;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.image.BufferedImage;
&nbsp;
import javax.swing.JFrame;
import javax.swing.WindowConstants;
&nbsp;
<i>/**</i>
<i> * Jednoduchy test metody Graphics.drawImage().</i>
<i> * Pri vykreslovani se nebude pouzivat double buffering.</i>
 <i>*/</i>
public class <strong>BlitTest2</strong> extends JFrame {
&nbsp;
    <i>/**</i>
    <i> * Generated serial version UID.</i>
     <i>*/</i>
    private static final long <strong>serialVersionUID</strong> = -6455857608125974217L;
&nbsp;
    <i>/**</i>
    <i> * Sirka testovaciho obrazku.</i>
     <i>*/</i>
    private static final int <strong>IMAGE_WIDTH</strong> = 256;
&nbsp;
    <i>/**</i>
    <i> * Vyska testovaciho obrazku.</i>
     <i>*/</i>
    private static final int <strong>IMAGE_HEIGHT</strong> = 256;
&nbsp;
    <i>/**</i>
    <i> * Sirka okna ve fullscreen rezimu.</i>
     <i>*/</i>
    private static final int <strong>FRAME_WIDTH</strong> = 1024;
&nbsp;
    <i>/**</i>
    <i> * Vyska okna ve fullscreen rezimu.</i>
     <i>*/</i>
    private static final int <strong>FRAME_HEIGHT</strong> = 768;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka nastavovaneho grafickeho rezimu.</i>
     <i>*/</i>
    private static final int <strong>BPP</strong> = 16;
&nbsp;
    <i>/**</i>
    <i> * Horizontalni souradnice obrazku.</i>
     <i>*/</i>
    private int imageX;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni souradnice obrazku.</i>
     <i>*/</i>
    private int imageY;
&nbsp;
    <i>/**</i>
    <i> * Pocet skutecnych volani metody paint()</i>
     <i>*/</i>
    private int repaintCount = 0;
&nbsp;
    <i>/**</i>
    <i> * Obrazek, ktery se bude prenaset do okna.</i>
     <i>*/</i>
    private BufferedImage spriteImage = null;
&nbsp;
    <i>/**</i>
    <i> * Obrazek zobrazeny na pozadi okna.</i>
     <i>*/</i>
    private BufferedImage backgroundImage = null;
&nbsp;
    <i>/**</i>
    <i> * Spusteni testu.</i>
     <i>*/</i>
    private void <strong>run</strong>() {
        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
        GraphicsDevice gd = ge.getDefaultScreenDevice();
&nbsp;
        showJFrame(gd);
        setDisplayMode(gd);
        createSpriteImage();
        createBackgroundImage();
        runBenchmark();
&nbsp;
        gd.setFullScreenWindow(null);
        this.dispose();
        System.out.println("Repaint count: " + this.repaintCount);
        System.exit(0);
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni grafickeho rezimu.</i>
     <i>*/</i>
    private void <strong>setDisplayMode</strong>(GraphicsDevice gd) {
        DisplayMode dm = new DisplayMode(FRAME_WIDTH, FRAME_HEIGHT, BPP, DisplayMode.REFRESH_RATE_UNKNOWN);
        gd.setDisplayMode(dm);
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni vlastniho benchmarku.</i>
     <i>*/</i>
    private void <strong>runBenchmark</strong>() {
        for (int y = 0; y &lt; FRAME_HEIGHT; y += 10) {
            for (int x = 0; x &lt; FRAME_WIDTH; x += 10) {
                setImageX(x);
                setImageY(y);
                <i>// vynutime si prekresleni okna</i>
                repaint();
                try {
                    Thread.sleep(10);
                }
                catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
&nbsp;
    <i>/**</i>
    <i> * Vytvoreni testovaciho obrazku.</i>
     <i>*/</i>
    private void <strong>createSpriteImage</strong>() {
        this.spriteImage = getGraphicsConfiguration().createCompatibleImage(IMAGE_WIDTH, IMAGE_HEIGHT);
        drawIntoSpriteImage(this.spriteImage);
    }
&nbsp;
    <i>/**</i>
    <i> * Vytvoreni obrazku pozadi.</i>
     <i>*/</i>
    private void <strong>createBackgroundImage</strong>() {
        this.backgroundImage = getGraphicsConfiguration().createCompatibleImage(FRAME_WIDTH, FRAME_HEIGHT);
        drawIntoBackgroundImage(this.backgroundImage);
    }
&nbsp;
    <i>/**</i>
    <i> * Vykresleni vzorku do obrazku.</i>
     <i>*/</i>
    private void <strong>drawIntoSpriteImage</strong>(BufferedImage image) {
        final int width = image.getWidth();
        final int height = image.getHeight();
        Graphics2D g = image.createGraphics();
&nbsp;
        <i>// smazeme pozadi obrazku</i>
        g.setColor(Color.white);
        g.fillRect(0, 0, width-1, height-1);
&nbsp;
        <i>// vykresleni cerveneho ctverce</i>
        g.setColor(Color.red);
        g.drawRect(0, 0, width-1, height-1);
&nbsp;
        <i>// vykresleni krize</i>
        g.setColor(Color.blue);
        g.drawLine(width &gt;&gt; 1, height/3, width &gt;&gt; 1, 2*height/3);
        g.drawLine(width/3, height &gt;&gt; 1, 2*width/3, height &gt;&gt; 1);
        g.dispose();
    }
&nbsp;
    <i>/**</i>
    <i> * Vykresleni vzorku do obrazku na pozadi.</i>
     <i>*/</i>
    private void <strong>drawIntoBackgroundImage</strong>(BufferedImage image) {
        final int width = image.getWidth();
        final int height = image.getHeight();
        Graphics2D g = image.createGraphics();
&nbsp;
        <i>// smazeme pozadi obrazku</i>
        g.setColor(Color.white);
        g.fillRect(0, 0, width-1, height-1);
&nbsp;
        <i>// vykresleni zelene sachovnice</i>
        g.setColor(Color.green);
        for (int y = 0; y &lt; height; y += 20) {
            g.drawLine(0, y, width - 1, y);
        }
        g.setColor(Color.green);
        for (int x = 0; x &lt; width; x += 20) {
            g.drawLine(x, 0, x, height - 1);
        }
&nbsp;
        g.dispose();
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni parametru okna a zobrazeni.</i>
    <i> * @param gd </i>
     <i>*/</i>
    private void <strong>showJFrame</strong>(GraphicsDevice gd) {
        <i>// vypneme okraje a dalsi zbytecnosti :)</i>
        this.setUndecorated(true);
        this.setLocation(0, 0);
        this.setSize(FRAME_WIDTH, FRAME_HEIGHT);
        this.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
        this.createBufferStrategy(1);
        this.setVisible(true);
        gd.setFullScreenWindow(this);
    }
&nbsp;
    @Override
    public void <strong>paint</strong>(Graphics g) {
        final BufferedImage sprite = getSpriteImage();
        final BufferedImage background = getBackgroundImage();
        if (sprite == null || background == null) return;
        final int spriteX = getImageX() - sprite.getWidth() / 2;
        final int spriteY = getImageY() - sprite.getHeight() / 2;
        <i>// vykreslime pozadi</i>
        g.drawImage(background, 0, 0, null);
        <i>// nad nej vykreslime pohybujici se sprite</i>
        g.drawImage(sprite, spriteX, spriteY, null);
        <i>// neni zcela nutne</i>
        g.dispose();
        this.repaintCount++;
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni horizontalni souradnice obrazku.</i>
    <i> *</i>
    <i> * @param x</i>
     <i>*/</i>
    void <strong>setImageX</strong>(int x) {
        this.imageX = x;
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni vertikalni souradnice obrazku.</i>
    <i> *</i>
    <i> * @param y</i>
     <i>*/</i>
    void <strong>setImageY</strong>(int y) {
        this.imageY = y;
    }
&nbsp;
    <i>/**</i>
    <i> * Getter pro atribut imageX.</i>
     <i>*/</i>
    int <strong>getImageX</strong>() {
        return this.imageX;
    }
&nbsp;
    <i>/**</i>
    <i> * Getter pro atribut imageY.</i>
     <i>*/</i>
    int <strong>getImageY</strong>() {
        return this.imageY;
    }
&nbsp;
    <i>/**</i>
    <i> * Getter pro atribut spriteImage.</i>
     <i>*/</i>
    BufferedImage <strong>getSpriteImage</strong>() {
        return this.spriteImage;
    }
&nbsp;
    <i>/**</i>
    <i> * Getter pro atribut backgroundImage.</i>
     <i>*/</i>
    BufferedImage <strong>getBackgroundImage</strong>() {
        return this.backgroundImage;
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni testu.</i>
    <i> * @param args</i>
     <i>*/</i>
    public static void <strong>main</strong>(String[] args) {
        new BlitTest2().run();
    }
&nbsp;
}
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zamezení poblikávání s&nbsp;vyu¾itím bitmapy typu <strong>BufferedImage</strong> ve funkci offscreen bufferu</h2>

<p>Pokud jste si dne¹ní první demonstraèní pøíklad spustili, pravdìpodobnì jste
zaznamenali nepøíjemné blikání celé vykreslované scény. To je zpùsobeno tím, ¾e
se bitmapa pozadí a bitmapa spritu vykresluje pøímo na obrazovku, tak¾e
u¾ivatel vidí nejdøíve vykreslení pozadí (a tím pádem i pøemazání spritu
z&nbsp;pøedchozího snímku) s&nbsp;následným vykreslením spritu na novou pozici.
Toto chování je samozøejmì pro vìt¹inu aplikací neakceptovatelné, tak¾e je
nutné zvolit jiné øe¹ení. V&nbsp;prùbìhu pøibli¾nì ètyøiceti let vývoje
grafických subsystémù se ukázalo, ¾e vhodné a souèasnì i dostateènì obecné
øe¹ení tohoto problému spoèívá v&nbsp;pou¾ití takzvaného <i>offscreen
bufferu</i>, tj.&nbsp;bitmapy (rastrového obrázku), do ní¾ se postupnì
vykreslují jednotlivé grafické objekty a na závìr &ndash; kdy¾ je ji¾ v¹e øádnì
vykresleno, je <i>offscreen buffer</i> buï pøenesen na obrazovku, nebo je
jednodu¹e prohozen (operace typu <i>flip</i>) s&nbsp;bufferem, který je
v&nbsp;daném okam¾iku viditelný na obrazovce (<i>double buffering</i>).</p>

<p>My si dnes pøedstavíme první mo¾nost &ndash; vykreslování do <i>offscreen
bufferu</i> s&nbsp;následným blokovým vykreslením ji¾ pøipraveného bufferu na
obrazovku (double buffering bude popsán pøí¹tì). Kromì obou ji¾ pøipravených
bitmap (pozadí a spritu) vytvoøíme je¹tì dal¹í bitmapu, její¾ rozmìry budou
stejné jako rozli¹ení nastaveného grafického re¾imu. Bitmapa bude typu
<strong>BufferedImage</strong> a vytvoøíme ji voláním metody
<strong>GraphicsConfiguration.createCompatibleImage()</strong>.  Vytvoøení této
bitmapy mù¾e probíhat a¾ v&nbsp;metodì <strong>paint()</strong>, a to
z&nbsp;toho dùvodu, ¾e zde máme zaruèeno, ¾e se vytvoøí bitmapa skuteènì
kompatibilní (se stejným formátem pixelù) s&nbsp;nastaveným grafickým
re¾imem:</p>

<pre>
    <i>@Override</i>
    public void <strong>paint</strong>(Graphics g) {
        final BufferedImage sprite = getSpriteImage();
        final BufferedImage background = getBackgroundImage();
        if (sprite == null || background == null) return;
        final int spriteX = getImageX() - sprite.getWidth() / 2;
        final int spriteY = getImageY() - sprite.getHeight() / 2;
&nbsp;
        <i>// konstrukce offscreen bufferu, pokud jeste nebyl vytvoren</i>
        if (this.offscreen == null) {
            GraphicsConfiguration gc = ((Graphics2D)g).getDeviceConfiguration();
            this.offscreen = gc.createCompatibleImage(FRAME_WIDTH, FRAME_HEIGHT);
        }
&nbsp;
        <i>// vykreslime pozadi</i>
        this.offscreen.getGraphics().drawImage(background, 0, 0, null);
        <i>// nad nej vykreslime pohybujici se sprite</i>
        this.offscreen.getGraphics().drawImage(sprite, spriteX, spriteY, null);
        <i>// ted jiz konecne vykreslujeme na obrazovku</i>
        g.drawImage(this.offscreen, 0, 0, null);
        g.dispose();
        this.repaintCount++;
    }
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Druhý demonstraèní pøíklad: vykreslení pozadí a spritu do bufferu tvoøeného bitmapou typu BufferedImage</h2>

<p>Zpùsob vyu¾ití bitmapy typu <strong>BufferedImage</strong> ve funkci
<i>offscreen bufferu</i> je ukázán v&nbsp;dne¹ním druhém demonstraèním pøíkladu
nazvaném <strong>BlitTest3</strong>, jeho¾ zdrojový kód je zobrazen pod tímto
odstavcem:</p>

<pre>
import java.awt.Color;
import java.awt.DisplayMode;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsConfiguration;
import java.awt.Image;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.image.BufferedImage;
&nbsp;
import javax.swing.JFrame;
import javax.swing.WindowConstants;
&nbsp;
<i>/**</i>
<i> * Jednoduchy test metody Graphics.drawImage().</i>
<i> * Pri vykreslovani se nebude pouzivat double buffering.</i>
<i> * Predbezne vykreslovani se bude provadet do nevolatilniho obrazku.</i>
 <i>*/</i>
public class <strong>BlitTest3</strong> extends JFrame {
&nbsp;
    <i>/**</i>
    <i> * Generated serial version UID.</i>
     <i>*/</i>
    private static final long <strong>serialVersionUID</strong> = -6455857608125974217L;
&nbsp;
    <i>/**</i>
    <i> * Sirka testovaciho obrazku.</i>
     <i>*/</i>
    private static final int <strong>IMAGE_WIDTH</strong> = 256;
&nbsp;
    <i>/**</i>
    <i> * Vyska testovaciho obrazku.</i>
     <i>*/</i>
    private static final int <strong>IMAGE_HEIGHT</strong> = 256;
&nbsp;
    <i>/**</i>
    <i> * Sirka okna ve fullscreen rezimu.</i>
     <i>*/</i>
    private static final int <strong>FRAME_WIDTH</strong> = 1024;
&nbsp;
    <i>/**</i>
    <i> * Vyska okna ve fullscreen rezimu.</i>
     <i>*/</i>
    private static final int <strong>FRAME_HEIGHT</strong> = 768;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka nastavovaneho grafickeho rezimu.</i>
     <i>*/</i>
    private static final int <strong>BPP</strong> = 16;
&nbsp;
    <i>/**</i>
    <i> * Horizontalni souradnice obrazku.</i>
     <i>*/</i>
    private int imageX;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni souradnice obrazku.</i>
     <i>*/</i>
    private int imageY;
&nbsp;
    <i>/**</i>
    <i> * Pocet skutecnych volani metody paint()</i>
     <i>*/</i>
    private int repaintCount = 0;
&nbsp;
    <i>/**</i>
    <i> * Obrazek, ktery se bude prenaset do okna.</i>
     <i>*/</i>
    private BufferedImage spriteImage = null;
&nbsp;
    <i>/**</i>
    <i> * Obrazek zobrazeny na pozadi okna.</i>
     <i>*/</i>
    private BufferedImage backgroundImage = null;
&nbsp;
    <i>/**</i>
    <i> * Obrazek pouzity pro kresleni mimo obrazovku.</i>
     <i>*/</i>
    private Image offscreen;
&nbsp;
    <i>/**</i>
    <i> * Spusteni testu.</i>
     <i>*/</i>
    private void <strong>run</strong>() {
        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
        GraphicsDevice gd = ge.getDefaultScreenDevice();
&nbsp;
        showJFrame(gd);
        setDisplayMode(gd);
        createSpriteImage();
        createBackgroundImage();
        runBenchmark();
&nbsp;
        gd.setFullScreenWindow(null);
        this.dispose();
        System.out.println("Repaint count: " + this.repaintCount);
        System.exit(0);
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni grafickeho rezimu.</i>
     <i>*/</i>
    private void <strong>setDisplayMode</strong>(GraphicsDevice gd) {
        DisplayMode dm = new DisplayMode(FRAME_WIDTH, FRAME_HEIGHT, BPP, DisplayMode.REFRESH_RATE_UNKNOWN);
        gd.setDisplayMode(dm);
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni vlastniho benchmarku.</i>
     <i>*/</i>
    private void <strong>runBenchmark</strong>() {
        for (int y = 0; y &lt; FRAME_HEIGHT; y += 10) {
            for (int x = 0; x &lt; FRAME_WIDTH; x += 10) {
                setImageX(x);
                setImageY(y);
                <i>// vynutime si prekresleni okna</i>
                repaint();
                try {
                    Thread.sleep(10);
                }
                catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
&nbsp;
    <i>/**</i>
    <i> * Vytvoreni testovaciho obrazku.</i>
     <i>*/</i>
    private void <strong>createSpriteImage</strong>() {
        this.spriteImage = getGraphicsConfiguration().createCompatibleImage(IMAGE_WIDTH, IMAGE_HEIGHT);
        drawIntoSpriteImage(this.spriteImage);
    }
&nbsp;
    <i>/**</i>
    <i> * Vytvoreni obrazku pozadi.</i>
     <i>*/</i>
    private void <strong>createBackgroundImage</strong>() {
        this.backgroundImage = getGraphicsConfiguration().createCompatibleImage(FRAME_WIDTH, FRAME_HEIGHT);
        drawIntoBackgroundImage(this.backgroundImage);
    }
&nbsp;
    <i>/**</i>
    <i> * Vykresleni vzorku do obrazku.</i>
     <i>*/</i>
    private void <strong>drawIntoSpriteImage</strong>(BufferedImage image) {
        final int width = image.getWidth();
        final int height = image.getHeight();
        Graphics2D g = image.createGraphics();
&nbsp;
        <i>// smazeme pozadi obrazku</i>
        g.setColor(Color.white);
        g.fillRect(0, 0, width-1, height-1);
&nbsp;
        <i>// vykresleni cerveneho ctverce</i>
        g.setColor(Color.red);
        g.drawRect(0, 0, width-1, height-1);
&nbsp;
        <i>// vykresleni krize</i>
        g.setColor(Color.blue);
        g.drawLine(width &gt;&gt; 1, height/3, width &gt;&gt; 1, 2*height/3);
        g.drawLine(width/3, height &gt;&gt; 1, 2*width/3, height &gt;&gt; 1);
        g.dispose();
    }
&nbsp;
    <i>/**</i>
    <i> * Vykresleni vzorku do obrazku na pozadi.</i>
     <i>*/</i>
    private void <strong>drawIntoBackgroundImage</strong>(BufferedImage image) {
        final int width = image.getWidth();
        final int height = image.getHeight();
        Graphics2D g = image.createGraphics();
&nbsp;
        <i>// smazeme pozadi obrazku</i>
        g.setColor(Color.white);
        g.fillRect(0, 0, width-1, height-1);
&nbsp;
        <i>// vykresleni zelene sachovnice</i>
        g.setColor(Color.green);
        for (int y = 0; y &lt; height; y += 20) {
            g.drawLine(0, y, width - 1, y);
        }
        g.setColor(Color.green);
        for (int x = 0; x &lt; width; x += 20) {
            g.drawLine(x, 0, x, height - 1);
        }
&nbsp;
        g.dispose();
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni parametru okna a zobrazeni.</i>
    <i> * @param gd </i>
     <i>*/</i>
    private void <strong>showJFrame</strong>(GraphicsDevice gd) {
        <i>// vypneme okraje a dalsi zbytecnosti :)</i>
        this.setUndecorated(true);
        this.setLocation(0, 0);
        this.setSize(FRAME_WIDTH, FRAME_HEIGHT);
        this.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
        this.createBufferStrategy(1);
        this.setVisible(true);
        gd.setFullScreenWindow(this);
    }
&nbsp;
    @Override
    public void <strong>paint</strong>(Graphics g) {
        final BufferedImage sprite = getSpriteImage();
        final BufferedImage background = getBackgroundImage();
        if (sprite == null || background == null) return;
        final int spriteX = getImageX() - sprite.getWidth() / 2;
        final int spriteY = getImageY() - sprite.getHeight() / 2;
&nbsp;
        if (this.offscreen == null) {
            GraphicsConfiguration gc = ((Graphics2D)g).getDeviceConfiguration();
            this.offscreen = gc.createCompatibleImage(FRAME_WIDTH, FRAME_HEIGHT);
        }
&nbsp;
        <i>// vykreslime pozadi</i>
        this.offscreen.getGraphics().drawImage(background, 0, 0, null);
        <i>// nad nej vykreslime pohybujici se sprite</i>
        this.offscreen.getGraphics().drawImage(sprite, spriteX, spriteY, null);
        g.drawImage(this.offscreen, 0, 0, null);
        g.dispose();
        this.repaintCount++;
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni horizontalni souradnice obrazku.</i>
    <i> *</i>
    <i> * @param x</i>
     <i>*/</i>
    void <strong>setImageX</strong>(int x) {
        this.imageX = x;
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni vertikalni souradnice obrazku.</i>
    <i> *</i>
    <i> * @param y</i>
     <i>*/</i>
    void <strong>setImageY</strong>(int y) {
        this.imageY = y;
    }
&nbsp;
    <i>/**</i>
    <i> * Getter pro atribut imageX.</i>
     <i>*/</i>
    int <strong>getImageX</strong>() {
        return this.imageX;
    }
&nbsp;
    <i>/**</i>
    <i> * Getter pro atribut imageY.</i>
     <i>*/</i>
    int <strong>getImageY</strong>() {
        return this.imageY;
    }
&nbsp;
    <i>/**</i>
    <i> * Getter pro atribut spriteImage.</i>
     <i>*/</i>
    BufferedImage <strong>getSpriteImage</strong>() {
        return this.spriteImage;
    }
&nbsp;
    <i>/**</i>
    <i> * Getter pro atribut backgroundImage.</i>
     <i>*/</i>
    BufferedImage <strong>getBackgroundImage</strong>() {
        return this.backgroundImage;
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni testu.</i>
    <i> * @param args</i>
     <i>*/</i>
    public static void <strong>main</strong>(String[] args) {
        new BlitTest3().run();
    }
&nbsp;
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Vyu¾ití bitmap typu <strong>VolatileImage</strong></h2>

<p>V&nbsp;pøedchozím demonstraèním pøíkladu byla pro implementaci <i>offscreen
bufferu</i> pou¾ita bitmapa typu <strong>BufferedImage</strong>. Ov¹em kdy¾ si
uvìdomíme, jakým zpùsobem je tento buffer pou¾it, mù¾eme dojít k&nbsp;závìru,
¾e výhodnìj¹í by bylo pou¾ití bitmapy typu <strong>VolatileImage</strong>, a to
pøedev¹ím z&nbsp;toho dùvodu, ¾e buffer pou¾íváme pouze v&nbsp;jediné metodì
<strong>paint()</strong> a navíc nám nebude vadit, pokud se v&nbsp;intervalu
mezi voláním této metody obsah volatilní bitmapy ztratí (co¾ se mù¾e stát,
ostatnì právì z&nbsp;této vlastnosti se odvozuje název tohoto typu rastrových
obrázkù). Úprava demonstraèního pøíkladu tak, aby pro implementaci <i>offscreen
bufferu</i> pou¾íval volatilní rastrové obrazy, je v¹ak ponìkud
komplikovanìj¹í, nebo» je nutné správnì reagovat na zmìnu stavu grafické
konfigurace i na zneplatnìní obsahu volatilní bitmapy (zneplatnìním je zde
my¹len pøepis hodnot pixelù jinými údaji).</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Detekce zmìny stavu grafické konfigurace a zneplatnìní obsahu volatilních bitmap</h2>

<p>Ji¾ v&nbsp;pøedchozí èásti tohoto seriálu jsme si øekli, ¾e nezávisle na
pou¾ití èi nepou¾ití exkluzivního celoobrazovkového re¾imu mohou nastat
situace, kdy dojde k&nbsp;po¹kození obrazových dat (a v&nbsp;dùsledku toho i
volatilních bitmap). Mù¾e se napøíklad jednat o zobrazení zprávy z&nbsp;task
manageru (ten má vysokou prioritu), spu¹tìní screensaveru, pøechodu systému
z/do re¾imu spánku èi re¾imu uspání, spu¹tìní èi pøepnutí do dal¹í aplikace
vy¾adující celoobrazovkový re¾im atd. Z&nbsp;tohoto dùvodu JVM sleduje stav
volatilních bitmap a ukládá tento stav do atributu dostupného pøes metodu
<strong>validate()</strong> (ta má je¹tì dal¹í význam). Volatilní bitmapa se
mù¾e nacházet v&nbsp;jednom ze tøí stavù:</p>

<ol>
<li><strong>IMAGE_OK</strong>: validní bitmapa, obsah se neztratil.</li>
<li><strong>IMAGE_INCOMPATIBLE</strong>: pravdìpodobnì se zmìnil grafický re¾im (i ukonèení celoobrazovkového re¾imu).</li>
<li><strong>IMAGE_RESTORED</strong>: bitmapu je nutno pøekreslit.</li>
</ol>

<p>Kromì volání metody <strong>validate()</strong> je je¹tì nutné volat metodu
<strong>contentsLost()</strong>, která vrací pravdivostní hodnotu
<i>true/false</i> podle toho, zda do¹lo z&nbsp;nìjakého dùvodu k&nbsp;po¹kození
obrazových dat (pixelù) ulo¾ených do volatilního obrázku.</p>

<p>Uka¾me si nyní, jak by mohla vypadat kostra metody <strong>paint()</strong>
naprogramované takovým zpùsobem, aby se volatilní bitmapa správnì pou¾ila
a/nebo obnovila jak ve chvíli, kdy se zmìní grafický re¾im (resp.&nbsp;formát
ukládaných pixelù), tak i ve chvíli, kdy se obsah bitmapy pøema¾e jinými
daty:</p>

<pre>
    @Override
    public void <strong>paint</strong>(Graphics g) {
        GraphicsEnvironment graphicsEnvironment = GraphicsEnvironment.getLocalGraphicsEnvironment();
        GraphicsConfiguration graphicsConfiguration = graphicsEnvironment.getDefaultScreenDevice().getDefaultConfiguration();
        do {
            int valid = offscreen.validate(graphicsConfiguration);
&nbsp;
            if (valid == VolatileImage.IMAGE_INCOMPATIBLE) {
                // zmena grafickeho rezimu?
                offscreen = graphicsConfiguration.createCompatibleVolatileImage(FRAME_WIDTH, FRAME_HEIGHT);
            }
&nbsp;
            <i>// vykresleni cehokoli do volatilni bitmapy "offscreen"</i>
            ...
            ...
            ...
            <i>// prenos volatilni bitmapy na obrazovku</i>
            g.drawImage(offscreen, 0, 0, null);
            g.dispose();
        } while (offscreen.contentsLost());    
    }
</pre>

<p>Vý¹e uvedený kód skuteènì øe¹í obì situace (a to navíc s&nbsp;pou¾itím málo
vyu¾ívané programové smyèky typu <strong>do-while</strong>): pokud se zmìní
grafický re¾im, dojde k&nbsp;vytvoøení nové &bdquo;kompatibilní&ldquo; bitmapy,
pokud se v&nbsp;prùbìhu vykreslování obsah volatilní bitmapy pøepí¹e jinými
daty, bude se celá smyèka znovu opakovat. Zde ve skuteènosti mù¾e dojít
k&nbsp;vizuálním chybám, reagovat na pøepis hodnoty pixelù lze pro jistotu
je¹tì pøed zavoláním metody <strong>g.drawImage()</strong> (pøidáním nové
podmínky, schválnì ponechávám úpravu na vá¾eném ètenáøi).</p>

<p>Podívejme se nyní, jak lze upravit metodu <strong>paint()</strong>
z&nbsp;pøedchozího demonstraèního pøíkladu tak, aby se pro <i>offscreen
buffer</i> pou¾ívala bitmapa typu <strong>VolatileImage</strong> namísto
<strong>BufferedImage</strong>:</p>

<pre>
    @Override
    public void <strong>paint</strong>(Graphics g) {
        final BufferedImage sprite = getSpriteImage();
        final BufferedImage background = getBackgroundImage();
        if (sprite == null || background == null) return;
        final int spriteX = getImageX() - sprite.getWidth() / 2;
        final int spriteY = getImageY() - sprite.getHeight() / 2;
&nbsp;
        GraphicsEnvironment graphicsEnvironment = GraphicsEnvironment.getLocalGraphicsEnvironment();
        GraphicsConfiguration graphicsConfiguration = graphicsEnvironment.getDefaultScreenDevice().getDefaultConfiguration();
&nbsp;
        do {
            if (this.offscreen == null) {
                this.offscreen = graphicsConfiguration.createCompatibleVolatileImage(FRAME_WIDTH, FRAME_HEIGHT);
            }
            int valid = this.offscreen.validate(graphicsConfiguration);
&nbsp;
            if (valid == VolatileImage.IMAGE_INCOMPATIBLE) {
                // zmena grafickeho rezimu?
                this.offscreen = graphicsConfiguration.createCompatibleVolatileImage(FRAME_WIDTH, FRAME_HEIGHT);
            }
&nbsp;
            <i>// vykresleni pozadi</i>
            this.offscreen.getGraphics().drawImage(background, 0, 0, null);
            <i>// vykresleni spritu</i>
            this.offscreen.getGraphics().drawImage(sprite, spriteX, spriteY, null);
            <i>// prenos na obrazovku</i>
            g.drawImage(this.offscreen, 0, 0, null);
            g.dispose();
        } while (this.offscreen.contentsLost());    
        this.repaintCount ++;
    }
</pre>


<p><a name="k07"></a></p>
<h2 id="k07">7. Tøetí demonstraèní pøíklad: vykreslení pozadí a spritu do bufferu tvoøeného bitmapou typu <strong>VolatileImage</strong></h2>

<p>Následuje výpis zdrojového kódu dne¹ního tøetího demonstraèního pøíkladu,
v&nbsp;nìm¾ se ji¾ pou¾ívají volatilní bitmapy. Zda skuteènì dojde ke sní¾ení
zátì¾e mikroprocesoru a/nebo grafického akcelerátoru, lze opìt zjistit
s&nbsp;vyu¾itím profileru:</p>

<pre>
import java.awt.Color;
import java.awt.DisplayMode;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.image.BufferedImage;
import java.awt.image.VolatileImage;
&nbsp;
import javax.swing.JFrame;
import javax.swing.WindowConstants;
&nbsp;
<i>/**</i>
<i> * Jednoduchy test metody Graphics.drawImage().</i>
<i> * Pri vykreslovani se nebude pouzivat double buffering.</i>
<i> * Predbezne vykreslovani se bude provadet do volatilniho obrazku.</i>
 <i>*/</i>
public class <strong>BlitTest4</strong> extends JFrame {
&nbsp;
    <i>/**</i>
    <i> * Generated serial version UID.</i>
     <i>*/</i>
    private static final long <strong>serialVersionUID</strong> = -6455857608125974217L;
&nbsp;
    <i>/**</i>
    <i> * Sirka testovaciho obrazku.</i>
     <i>*/</i>
    private static final int <strong>IMAGE_WIDTH</strong> = 256;
&nbsp;
    <i>/**</i>
    <i> * Vyska testovaciho obrazku.</i>
     <i>*/</i>
    private static final int <strong>IMAGE_HEIGHT</strong> = 256;
&nbsp;
    <i>/**</i>
    <i> * Sirka okna ve fullscreen rezimu.</i>
     <i>*/</i>
    private static final int <strong>FRAME_WIDTH</strong> = 1024;
&nbsp;
    <i>/**</i>
    <i> * Vyska okna ve fullscreen rezimu.</i>
     <i>*/</i>
    private static final int <strong>FRAME_HEIGHT</strong> = 768;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka nastavovaneho grafickeho rezimu.</i>
     <i>*/</i>
    private static final int <strong>BPP</strong> = 16;
&nbsp;
    <i>/**</i>
    <i> * Horizontalni souradnice obrazku.</i>
     <i>*/</i>
    private int imageX;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni souradnice obrazku.</i>
     <i>*/</i>
    private int imageY;
&nbsp;
    <i>/**</i>
    <i> * Pocet skutecnych volani metody paint()</i>
     <i>*/</i>
    private int repaintCount = 0;
&nbsp;
    <i>/**</i>
    <i> * Obrazek, ktery se bude prenaset do okna.</i>
     <i>*/</i>
    private BufferedImage spriteImage = null;
&nbsp;
    <i>/**</i>
    <i> * Obrazek zobrazeny na pozadi okna.</i>
     <i>*/</i>
    private BufferedImage backgroundImage = null;
&nbsp;
    <i>/**</i>
    <i> * Volatilni obrazek pouzity pro kresleni mimo obrazovku.</i>
     <i>*/</i>
    private VolatileImage offscreen = null;
&nbsp;
    <i>/**</i>
    <i> * Spusteni testu.</i>
     <i>*/</i>
    private void <strong>run</strong>() {
        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
        GraphicsDevice gd = ge.getDefaultScreenDevice();
&nbsp;
        showJFrame(gd);
        setDisplayMode(gd);
        createSpriteImage();
        createBackgroundImage();
        runBenchmark();
&nbsp;
        gd.setFullScreenWindow(null);
        this.dispose();
        System.out.println("Repaint count: " + this.repaintCount);
        System.exit(0);
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni grafickeho rezimu.</i>
     <i>*/</i>
    private void <strong>setDisplayMode</strong>(GraphicsDevice gd) {
        DisplayMode dm = new DisplayMode(FRAME_WIDTH, FRAME_HEIGHT, BPP, DisplayMode.REFRESH_RATE_UNKNOWN);
        gd.setDisplayMode(dm);
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni vlastniho benchmarku.</i>
     <i>*/</i>
    private void <strong>runBenchmark</strong>() {
        for (int y = 0; y &lt; FRAME_HEIGHT; y += 10) {
            for (int x = 0; x &lt; FRAME_WIDTH; x += 10) {
                setImageX(x);
                setImageY(y);
                <i>// vynutime si prekresleni okna</i>
                repaint();
                try {
                    Thread.sleep(10);
                }
                catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
&nbsp;
    <i>/**</i>
    <i> * Vytvoreni testovaciho obrazku.</i>
     <i>*/</i>
    private void <strong>createSpriteImage</strong>() {
        this.spriteImage = getGraphicsConfiguration().createCompatibleImage(IMAGE_WIDTH, IMAGE_HEIGHT);
        drawIntoSpriteImage(this.spriteImage);
    }
&nbsp;
    <i>/**</i>
    <i> * Vytvoreni obrazku pozadi.</i>
     <i>*/</i>
    private void <strong>createBackgroundImage</strong>() {
        this.backgroundImage = getGraphicsConfiguration().createCompatibleImage(FRAME_WIDTH, FRAME_HEIGHT);
        drawIntoBackgroundImage(this.backgroundImage);
    }
&nbsp;
    <i>/**</i>
    <i> * Vykresleni vzorku do obrazku.</i>
     <i>*/</i>
    private void <strong>drawIntoSpriteImage</strong>(BufferedImage image) {
        final int width = image.getWidth();
        final int height = image.getHeight();
        Graphics2D g = image.createGraphics();
&nbsp;
        <i>// smazeme pozadi obrazku</i>
        g.setColor(Color.white);
        g.fillRect(0, 0, width-1, height-1);
&nbsp;
        <i>// vykresleni cerveneho ctverce</i>
        g.setColor(Color.red);
        g.drawRect(0, 0, width-1, height-1);
&nbsp;
        <i>// vykresleni krize</i>
        g.setColor(Color.blue);
        g.drawLine(width &gt;&gt; 1, height/3, width &gt;&gt; 1, 2*height/3);
        g.drawLine(width/3, height &gt;&gt; 1, 2*width/3, height &gt;&gt; 1);
        g.dispose();
    }
&nbsp;
    <i>/**</i>
    <i> * Vykresleni vzorku do obrazku na pozadi.</i>
     <i>*/</i>
    private void <strong>drawIntoBackgroundImage</strong>(BufferedImage image) {
        final int width = image.getWidth();
        final int height = image.getHeight();
        Graphics2D g = image.createGraphics();
&nbsp;
        <i>// smazeme pozadi obrazku</i>
        g.setColor(Color.white);
        g.fillRect(0, 0, width-1, height-1);
&nbsp;
        <i>// vykresleni zelene sachovnice</i>
        g.setColor(Color.green);
        for (int y = 0; y &lt; height; y += 20) {
            g.drawLine(0, y, width - 1, y);
        }
        g.setColor(Color.green);
        for (int x = 0; x &lt; width; x += 20) {
            g.drawLine(x, 0, x, height - 1);
        }
&nbsp;
        g.dispose();
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni parametru okna a zobrazeni.</i>
    <i> * @param gd </i>
     <i>*/</i>
    private void <strong>showJFrame</strong>(GraphicsDevice gd) {
        <i>// vypneme okraje a dalsi zbytecnosti :)</i>
        this.setUndecorated(true);
        this.setLocation(0, 0);
        this.setSize(FRAME_WIDTH, FRAME_HEIGHT);
        this.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
        this.createBufferStrategy(1);
        this.setVisible(true);
        gd.setFullScreenWindow(this);
    }
&nbsp;
    @Override
    public void <strong>paint</strong>(Graphics g) {
        final BufferedImage sprite = getSpriteImage();
        final BufferedImage background = getBackgroundImage();
        if (sprite == null || background == null) return;
        final int spriteX = getImageX() - sprite.getWidth() / 2;
        final int spriteY = getImageY() - sprite.getHeight() / 2;
&nbsp;
        GraphicsEnvironment graphicsEnvironment = GraphicsEnvironment.getLocalGraphicsEnvironment();
        GraphicsConfiguration graphicsConfiguration = graphicsEnvironment.getDefaultScreenDevice().getDefaultConfiguration();
&nbsp;
        do {
            if (this.offscreen == null) {
                this.offscreen = graphicsConfiguration.createCompatibleVolatileImage(FRAME_WIDTH, FRAME_HEIGHT);
            }
            int valid = this.offscreen.validate(graphicsConfiguration);
&nbsp;
            if (valid == VolatileImage.IMAGE_INCOMPATIBLE) {
                // zmena grafickeho rezimu?
                this.offscreen = graphicsConfiguration.createCompatibleVolatileImage(FRAME_WIDTH, FRAME_HEIGHT);
            }
&nbsp;
            <i>// vykresleni pozadi</i>
            this.offscreen.getGraphics().drawImage(background, 0, 0, null);
            <i>// vykresleni spritu</i>
            this.offscreen.getGraphics().drawImage(sprite, spriteX, spriteY, null);
            <i>// prenos na obrazovku</i>
            g.drawImage(this.offscreen, 0, 0, null);
            g.dispose();
        } while (this.offscreen.contentsLost());    
        this.repaintCount ++;
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni horizontalni souradnice obrazku.</i>
    <i> *</i>
    <i> * @param x</i>
     <i>*/</i>
    void <strong>setImageX</strong>(int x) {
        this.imageX = x;
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni vertikalni souradnice obrazku.</i>
    <i> *</i>
    <i> * @param y</i>
     <i>*/</i>
    void <strong>setImageY</strong>(int y) {
        this.imageY = y;
    }
&nbsp;
    <i>/**</i>
    <i> * Getter pro atribut imageX.</i>
     <i>*/</i>
    int <strong>getImageX</strong>() {
        return this.imageX;
    }
&nbsp;
    <i>/**</i>
    <i> * Getter pro atribut imageY.</i>
     <i>*/</i>
    int <strong>getImageY</strong>() {
        return this.imageY;
    }
&nbsp;
    <i>/**</i>
    <i> * Getter pro atribut spriteImage.</i>
     <i>*/</i>
    BufferedImage <strong>getSpriteImage</strong>() {
        return this.spriteImage;
    }
&nbsp;
    <i>/**</i>
    <i> * Getter pro atribut backgroundImage.</i>
     <i>*/</i>
    BufferedImage <strong>getBackgroundImage</strong>() {
        return this.backgroundImage;
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni testu.</i>
    <i> * @param args</i>
     <i>*/</i>
    public static void <strong>main</strong>(String[] args) {
        new BlitTest4().run();
    }
&nbsp;
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Problematika prùhledných obrázkù</h2>

<p>Pro zajímavost se je¹tì podívejme na problematiku vykreslení prùhledných
(resp.&nbsp;pøesnìji øeèeno poloprùhledných) obrázkù. Pøedchozí testovací
pøíklad upravíme takovým zpùsobem, aby byl sprite vykreslen poloprùhlednì,
tj.&nbsp;aby pod ním èásteènì prosvítalo pozadí. Vykreslování poloprùhledných
obrázkù je ji¾ v&nbsp;souèasnosti realizováno funkcemi nabízenými grafickými
akcelerátory, tak¾e by vlastní práce s&nbsp;tìmito obrázky nemìla pøíli¹
zatì¾ovat mikroprocesor. Nejdøíve se podívejme, jak se vytvoøí bitmapa typu
<strong>BufferedImage</strong> s&nbsp;podporou (polo)prùhlednosti. Je to
snadné, musíme pouze pøidat dal¹í parametr do metody
<strong>GraphicsConfiguration.createCompatibleImage()</strong>:</p>

<pre>
    <i>/**</i>
    <i> * Vytvoreni testovaciho obrazku.</i>
     <i>*/</i>
    private void <strong>createSpriteImage</strong>() {
        this.spriteImage = getGraphicsConfiguration().createCompatibleImage(IMAGE_WIDTH, IMAGE_HEIGHT, Transparency.TRANSLUCENT);
        drawIntoSpriteImage(this.spriteImage);
    }
</pre>

<p>Zajímavìj¹í je zpùsob vykreslení poloprùhledné bitmapy. Zde vyu¾ijeme metodu
<strong>Graphics2D.setComposite()</strong> pro nastavení operace provádìné pøi
vykreslování, které se pøedá instance tøídy <strong>AlphaComposite</strong>.
Dùle¾ité je, ¾e operace typu <strong>SRC_OVER</strong> je (na rozdíl od
nìkterých dal¹ích rastrových operací) skuteènì akcelerovaná. Druhým parametrem
metody <strong>AlphaComposite.getInstance()</strong> je hodnota prùhlednosti,
co¾ je reálné èíslo v&nbsp;rozsahu 0..1 odpovídající 0 a¾ 100%:</p>

<pre>
    <i>// vykresleni polopruhledneho spritu</i>
    float transparency = 0.8f;
    Graphics2D g2 = (Graphics2D)this.offscreen.getGraphics();
    g2.setComposite(java.awt.AlphaComposite.getInstance(java.awt.AlphaComposite.SRC_OVER, transparency));
    g2.drawImage(sprite, spriteX, spriteY, null);
</pre>

<p>Nová varianta pøekreslovací rutiny nyní vypadá následovnì:</p>

<pre>
    @Override
    public void <strong>paint</strong>(Graphics g) {
        final BufferedImage sprite = getSpriteImage();
        final BufferedImage background = getBackgroundImage();
        if (sprite == null || background == null) return;
        final int spriteX = getImageX() - sprite.getWidth() / 2;
        final int spriteY = getImageY() - sprite.getHeight() / 2;
&nbsp;
        GraphicsEnvironment graphicsEnvironment = GraphicsEnvironment.getLocalGraphicsEnvironment();
        GraphicsConfiguration graphicsConfiguration = graphicsEnvironment.getDefaultScreenDevice().getDefaultConfiguration();
&nbsp;
        do {
            if (this.offscreen == null) {
                this.offscreen = graphicsConfiguration.createCompatibleVolatileImage(FRAME_WIDTH, FRAME_HEIGHT);
            }
            int valid = this.offscreen.validate(graphicsConfiguration);
&nbsp;
            if (valid == VolatileImage.IMAGE_INCOMPATIBLE) {
                // zmena grafickeho rezimu?
                this.offscreen = graphicsConfiguration.createCompatibleVolatileImage(FRAME_WIDTH, FRAME_HEIGHT);
            }
&nbsp;
            <i>// vykresleni pozadi</i>
            this.offscreen.getGraphics().drawImage(background, 0, 0, null);
            <i>// vykresleni polopruhledneho spritu</i>
            float transparency = 0.8f;
            Graphics2D g2 = (Graphics2D)this.offscreen.getGraphics();
            g2.setComposite(java.awt.AlphaComposite.getInstance(java.awt.AlphaComposite.SRC_OVER, transparency));
            g2.drawImage(sprite, spriteX, spriteY, null);
            <i>// prenos na obrazovku</i>
            g.drawImage(this.offscreen, 0, 0, null);
            g.dispose();
        } while (this.offscreen.contentsLost());    
        this.repaintCount ++;
    }
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Ètvrtý demonstraèní pøíklad: vykreslení pozadí a poloprùhledného spritu do bufferu tvoøeného bitmapou typu <strong>VolatileImage</strong></h2>

<p>Vykreslení prùhledného spritu na neprùhledném pozadí je realizováno
v&nbsp;dne¹ním ètvrtém a souèasnì i posledním demonstraèním pøíkladu, jeho¾
úplný zdrojový kód je vypsán pod tímto odstavcem:</p>

<pre>
import java.awt.Color;
import java.awt.DisplayMode;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.Transparency;
import java.awt.image.BufferedImage;
import java.awt.image.VolatileImage;
&nbsp;
import javax.swing.JFrame;
import javax.swing.WindowConstants;
&nbsp;
<i>/**</i>
<i> * Jednoduchy test metody Graphics.drawImage().</i>
<i> * Pri vykreslovani se nebude pouzivat double buffering.</i>
<i> * Predbezne vykreslovani se bude provadet do volatilniho obrazku.</i>
<i> * Sprite bude vykreslen polopruhledne.</i>
 <i>*/</i>
public class <strong>BlitTest5</strong> extends JFrame {
&nbsp;
    <i>/**</i>
    <i> * Generated serial version UID.</i>
     <i>*/</i>
    private static final long <strong>serialVersionUID</strong> = -6455857608125974217L;
&nbsp;
    <i>/**</i>
    <i> * Sirka testovaciho obrazku.</i>
     <i>*/</i>
    private static final int <strong>IMAGE_WIDTH</strong> = 256;
&nbsp;
    <i>/**</i>
    <i> * Vyska testovaciho obrazku.</i>
     <i>*/</i>
    private static final int <strong>IMAGE_HEIGHT</strong> = 256;
&nbsp;
    <i>/**</i>
    <i> * Sirka okna ve fullscreen rezimu.</i>
     <i>*/</i>
    private static final int <strong>FRAME_WIDTH</strong> = 1024;
&nbsp;
    <i>/**</i>
    <i> * Vyska okna ve fullscreen rezimu.</i>
     <i>*/</i>
    private static final int <strong>FRAME_HEIGHT</strong> = 768;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka nastavovaneho grafickeho rezimu.</i>
     <i>*/</i>
    private static final int <strong>BPP</strong> = 16;
&nbsp;
    <i>/**</i>
    <i> * Horizontalni souradnice obrazku.</i>
     <i>*/</i>
    private int imageX;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni souradnice obrazku.</i>
     <i>*/</i>
    private int imageY;
&nbsp;
    <i>/**</i>
    <i> * Pocet skutecnych volani metody paint()</i>
     <i>*/</i>
    private int repaintCount = 0;
&nbsp;
    <i>/**</i>
    <i> * Obrazek, ktery se bude prenaset do okna.</i>
     <i>*/</i>
    private BufferedImage spriteImage = null;
&nbsp;
    <i>/**</i>
    <i> * Obrazek zobrazeny na pozadi okna.</i>
     <i>*/</i>
    private BufferedImage backgroundImage = null;
&nbsp;
    <i>/**</i>
    <i> * Volatilni obrazek pouzity pro kresleni mimo obrazovku.</i>
     <i>*/</i>
    private VolatileImage offscreen = null;
&nbsp;
    <i>/**</i>
    <i> * Spusteni testu.</i>
     <i>*/</i>
    private void <strong>run</strong>() {
        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
        GraphicsDevice gd = ge.getDefaultScreenDevice();
&nbsp;
        showJFrame(gd);
        setDisplayMode(gd);
        createSpriteImage();
        createBackgroundImage();
        runBenchmark();
&nbsp;
        gd.setFullScreenWindow(null);
        this.dispose();
        System.out.println("Repaint count: " + this.repaintCount);
        System.exit(0);
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni grafickeho rezimu.</i>
     <i>*/</i>
    private void <strong>setDisplayMode</strong>(GraphicsDevice gd) {
        DisplayMode dm = new DisplayMode(FRAME_WIDTH, FRAME_HEIGHT, BPP, DisplayMode.REFRESH_RATE_UNKNOWN);
        gd.setDisplayMode(dm);
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni vlastniho benchmarku.</i>
     <i>*/</i>
    private void <strong>runBenchmark</strong>() {
        for (int y = 0; y &lt; FRAME_HEIGHT; y += 10) {
            for (int x = 0; x &lt; FRAME_WIDTH; x += 10) {
                setImageX(x);
                setImageY(y);
                <i>// vynutime si prekresleni okna</i>
                repaint();
                try {
                    Thread.sleep(10);
                }
                catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
&nbsp;
    <i>/**</i>
    <i> * Vytvoreni testovaciho obrazku.</i>
     <i>*/</i>
    private void <strong>createSpriteImage</strong>() {
        this.spriteImage = getGraphicsConfiguration().createCompatibleImage(IMAGE_WIDTH, IMAGE_HEIGHT, Transparency.TRANSLUCENT);
        drawIntoSpriteImage(this.spriteImage);
    }
&nbsp;
    <i>/**</i>
    <i> * Vytvoreni obrazku pozadi.</i>
     <i>*/</i>
    private void <strong>createBackgroundImage</strong>() {
        this.backgroundImage = getGraphicsConfiguration().createCompatibleImage(FRAME_WIDTH, FRAME_HEIGHT);
        drawIntoBackgroundImage(this.backgroundImage);
    }
&nbsp;
    <i>/**</i>
    <i> * Vykresleni vzorku do obrazku.</i>
     <i>*/</i>
    private void <strong>drawIntoSpriteImage</strong>(BufferedImage image) {
        final int width = image.getWidth();
        final int height = image.getHeight();
        Graphics2D g = image.createGraphics();
&nbsp;
        <i>// smazeme pozadi obrazku</i>
        g.setColor(Color.white);
        g.fillRect(0, 0, width-1, height-1);
&nbsp;
        <i>// vykresleni cerveneho ctverce</i>
        g.setColor(Color.red);
        g.drawRect(0, 0, width-1, height-1);
&nbsp;
        <i>// vykresleni krize</i>
        g.setColor(Color.blue);
        g.drawLine(width &gt;&gt; 1, height/3, width &gt;&gt; 1, 2*height/3);
        g.drawLine(width/3, height &gt;&gt; 1, 2*width/3, height &gt;&gt; 1);
        g.dispose();
    }
&nbsp;
    <i>/**</i>
    <i> * Vykresleni vzorku do obrazku na pozadi.</i>
     <i>*/</i>
    private void <strong>drawIntoBackgroundImage</strong>(BufferedImage image) {
        final int width = image.getWidth();
        final int height = image.getHeight();
        Graphics2D g = image.createGraphics();
&nbsp;
        <i>// smazeme pozadi obrazku</i>
        g.setColor(Color.white);
        g.fillRect(0, 0, width-1, height-1);
&nbsp;
        <i>// vykresleni zelene sachovnice</i>
        g.setColor(Color.green);
        for (int y = 0; y &lt; height; y += 20) {
            g.drawLine(0, y, width - 1, y);
        }
        g.setColor(Color.green);
        for (int x = 0; x &lt; width; x += 20) {
            g.drawLine(x, 0, x, height - 1);
        }
&nbsp;
        g.dispose();
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni parametru okna a zobrazeni.</i>
    <i> * @param gd </i>
     <i>*/</i>
    private void <strong>showJFrame</strong>(GraphicsDevice gd) {
        <i>// vypneme okraje a dalsi zbytecnosti :)</i>
        this.setUndecorated(true);
        this.setLocation(0, 0);
        this.setSize(FRAME_WIDTH, FRAME_HEIGHT);
        this.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
        this.createBufferStrategy(1);
        this.setVisible(true);
        gd.setFullScreenWindow(this);
    }
&nbsp;
    @Override
    public void <strong>paint</strong>(Graphics g) {
        final BufferedImage sprite = getSpriteImage();
        final BufferedImage background = getBackgroundImage();
        if (sprite == null || background == null) return;
        final int spriteX = getImageX() - sprite.getWidth() / 2;
        final int spriteY = getImageY() - sprite.getHeight() / 2;
&nbsp;
        GraphicsEnvironment graphicsEnvironment = GraphicsEnvironment.getLocalGraphicsEnvironment();
        GraphicsConfiguration graphicsConfiguration = graphicsEnvironment.getDefaultScreenDevice().getDefaultConfiguration();
&nbsp;
        do {
            if (this.offscreen == null) {
                this.offscreen = graphicsConfiguration.createCompatibleVolatileImage(FRAME_WIDTH, FRAME_HEIGHT);
            }
            int valid = this.offscreen.validate(graphicsConfiguration);
&nbsp;
            if (valid == VolatileImage.IMAGE_INCOMPATIBLE) {
                // zmena grafickeho rezimu?
                this.offscreen = graphicsConfiguration.createCompatibleVolatileImage(FRAME_WIDTH, FRAME_HEIGHT);
            }
&nbsp;
            <i>// vykresleni pozadi</i>
            this.offscreen.getGraphics().drawImage(background, 0, 0, null);
            <i>// vykresleni polopruhledneho spritu</i>
            float transparency = 0.8f;
            Graphics2D g2 = (Graphics2D)this.offscreen.getGraphics();
            g2.setComposite(java.awt.AlphaComposite.getInstance(java.awt.AlphaComposite.SRC_OVER, transparency));
            g2.drawImage(sprite, spriteX, spriteY, null);
            <i>// prenos na obrazovku</i>
            g.drawImage(this.offscreen, 0, 0, null);
            g.dispose();
        } while (this.offscreen.contentsLost());    
        this.repaintCount ++;
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni horizontalni souradnice obrazku.</i>
    <i> *</i>
    <i> * @param x</i>
     <i>*/</i>
    void <strong>setImageX</strong>(int x) {
        this.imageX = x;
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni vertikalni souradnice obrazku.</i>
    <i> *</i>
    <i> * @param y</i>
     <i>*/</i>
    void <strong>setImageY</strong>(int y) {
        this.imageY = y;
    }
&nbsp;
    <i>/**</i>
    <i> * Getter pro atribut imageX.</i>
     <i>*/</i>
    int <strong>getImageX</strong>() {
        return this.imageX;
    }
&nbsp;
    <i>/**</i>
    <i> * Getter pro atribut imageY.</i>
     <i>*/</i>
    int <strong>getImageY</strong>() {
        return this.imageY;
    }
&nbsp;
    <i>/**</i>
    <i> * Getter pro atribut spriteImage.</i>
     <i>*/</i>
    BufferedImage <strong>getSpriteImage</strong>() {
        return this.spriteImage;
    }
&nbsp;
    <i>/**</i>
    <i> * Getter pro atribut backgroundImage.</i>
     <i>*/</i>
    BufferedImage <strong>getBackgroundImage</strong>() {
        return this.backgroundImage;
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni testu.</i>
    <i> * @param args</i>
     <i>*/</i>
    public static void <strong>main</strong>(String[] args) {
        new BlitTest5().run();
    }
&nbsp;
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Repositáø se zdrojovými soubory dne¹ních demonstraèních pøíkladù</h2>

<p>Následují ji¾ tradièní odkazy na zdrojové kódy ulo¾ené do Mercurial
repositáøe. V&nbsp;následující tabulce najdete linky na prozatím nejnovìj¹í
verze v¹ech ètyø dnes popsaných demonstraèních pøíkladù vykreslujícího bitmapy
typu <strong>BufferedImage</strong> a <strong>VolatileImage</strong>
v&nbsp;celoobrazovkovém grafickém re¾imu:</p>

<table>
<tr><th>#</th><th>Zdrojový soubor/skript</th><th>Umístìní souboru v&nbsp;repositáøi</th></tr>
<tr><td>1</td><td>BlitTest2.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/083421bb26ff/jvm/gfx/BlitTest2.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/083421bb26ff/jvm/gfx/BlitTest2.java</a></td></tr>
<tr><td>2</td><td>BlitTest3.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/083421bb26ff/jvm/gfx/BlitTest3.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/083421bb26ff/jvm/gfx/BlitTest3.java</a></td></tr>
<tr><td>3</td><td>BlitTest4.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/083421bb26ff/jvm/gfx/BlitTest4.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/083421bb26ff/jvm/gfx/BlitTest4.java</a></td></tr>
<tr><td>4</td><td>BlitTest5.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/083421bb26ff/jvm/gfx/BlitTest5.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/083421bb26ff/jvm/gfx/BlitTest5.java</a></td></tr>
</table>



<p><a name="k11"></a></p>
<h2 id="k11">11. Odkazy na Internetu</h2>

<ol>

<li>Javadoc - tøída GraphicsDevice<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html</a>
</li>

<li>Javadoc - tøída GraphicsEnvironment<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html</a>
</li>

<li>Javadoc - tøída GraphicsConfiguration<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html</a>
</li>

<li>Javadoc - tøída DisplayMode<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html">http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html</a>
</li>

<li>Lesson: Full-Screen Exclusive Mode API<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/">http://docs.oracle.com/javase/tutorial/extra/fullscreen/</a>
</li>

<li>Full-Screen Exclusive Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html</a>
</li>

<li>Display Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html</a>
</li>

<li>Using the Full-Screen Exclusive Mode API in Java<br />
<a href="http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm">http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>GC safe-point (or safepoint) and safe-region<br />
<a href="http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html">http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html</a>
</li>

<li>Safepoints in HotSpot JVM<br />
<a href="http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html">http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html</a>
</li>

<li>Java theory and practice: Synchronization optimizations in Mustang<br />
<a href="http://www.ibm.com/developerworks/java/library/j-jtp10185/">http://www.ibm.com/developerworks/java/library/j-jtp10185/</a>
</li>

<li>How to build hsdis<br />
<a href="http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README">http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README</a>
</li>

<li>Java SE 6 Performance White Paper<br />
<a href="http://www.oracle.com/technetwork/java/6-performance-137236.html">http://www.oracle.com/technetwork/java/6-performance-137236.html</a>
</li>

<li>Lukas Stadler's Blog<br />
<a href="http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html">http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html</a>
</li>

<li>How to build hsdis-amd64.dll and hsdis-i386.dll on Windows<br />
<a href="http://dropzone.nfshost.com/hsdis.htm">http://dropzone.nfshost.com/hsdis.htm</a>
</li>

<li>PrintAssembly<br />
<a href="https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly">https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly</a>
</li>

<li>The Java Virtual Machine Specification: 3.14. Synchronization<br />
<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14</a>
</li>

<li>The Java Virtual Machine Specification: 8.3.1.4. volatile Fields<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.4. Memory Model<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.7. Non-atomic Treatment of double and long<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7</a>
</li>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (pøed verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

