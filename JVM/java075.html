<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - pøístup k zásobníkovým rámcùm vláken sledované JVM pøes rozhraní JDI</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - pøístup k zásobníkovým rámcùm vláken sledované JVM pøes rozhraní JDI</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyku Java i o virtuálním stroji Javy si uká¾eme, jakým zpùsobem je mo¾né s&nbsp;vyu¾itím rozhraní JDI (Java Debugger Interface) získat a následnì i vypsat obsah zásobníkových rámcù v¹ech vláken aplikace bì¾ící v&nbsp;cílové (sledované) JVM.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - pøístup k zásobníkovým rámcùm vláken sledované JVM pøes rozhraní JDI</a></p>
<p><a href="#k02">2. Získání a následný výpis obsahu zásobníkových rámcù s&nbsp;vyu¾itím rozhraní JDI</a></p>
<p><a href="#k03">3. Výpis informací o vybraném zásobníkovém rámci</a></p>
<p><a href="#k04">4. Pøeètení jména volané metody i jména tøídy, v&nbsp;ní¾ je tato metoda deklarována</a></p>
<p><a href="#k05">5. Získání øádku, v&nbsp;ní¾ do¹lo k&nbsp;volání metody a pøeètení jména zdrojového souboru tøídy</a></p>
<p><a href="#k06">6. Kompletní zdrojový kód demonstraèního pøíkladu <strong>JDIStackTraceList</strong></a></p>
<p><a href="#k07">7. Spu¹tìní demonstraèního pøíkladu</a></p>
<p><a href="#k08">8. Zdrojové kódy demonstraèního pøíkladu i podpùrných skriptù</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - pøístup k zásobníkovým rámcùm vláken sledované JVM pøes rozhraní JDI</h2>

<p>V&nbsp;dne¹ní èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyku Java i o virtuálním stroji Javy</a> se ji¾ popáté budeme
zabývat mo¾nostmi nabízenými rozhraním <i>JDI (Java Debugger Interface)</i>.
Uká¾eme si, jakým zpùsobem je mo¾né toto rozhraní pou¾ít k&nbsp;získání obsahu
zásobníkových rámcù v¹ech vláken aplikace bì¾ící v&nbsp;cílové (sledované) JVM.
Dne¹ní demonstraèní pøíklad <strong>JDIStackTraceList</strong> slou¾ící
k&nbsp;výpisu obsahu zásobníkových rámcù jednotlivých vláken je zalo¾en na
pøíkladu <strong>JDIVirtualMachineInfo</strong>, jeho¾ <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/cadf0d815a2b/jdi/JDIVirtualMachineInfo.java">zdrojový
kód</a> jsme si do v¹ech podrobností popsali minule. Pøed popisem dne¹ního
demonstraèního pøíkladu i dal¹ích mo¾ností rozhraní <i>JDI</i> si v¹ak nejprve
pøipomeòme, jakým zpùsobem internì pracuje virtuální stroj Javy pøi spu¹tìní a
následném bìhu javovské aplikace.</p>

<p>Pøi spu¹tìní JVM i v&nbsp;prùbìhu inicializace javovské aplikace je pro
ka¾dé vlákno vytvoøen samostatný <i>zásobník (stack)</i> a pokud se
v&nbsp;nìjakém vláknu volá metoda, je pro toto volání na zásobníku vytvoøen
takzvaný <i>zásobníkový rámec (stack frame)</i>, v&nbsp;nìm¾ je ulo¾ena jak
informace o bodu návratu z&nbsp;metody (tedy místo, kam povede instrukce typu
<strong>return</strong> v&nbsp;bajtkódu), tak i hodnoty v¹ech parametrù
pøedaných metodì i oblast s&nbsp;lokálními promìnnými metody. Oznaèení
&bdquo;zásobník&ldquo; sice mù¾e navozovat pocit, ¾e se jedná o kontinuální
oblast pamìti, ve skuteènosti v¹ak mezi jednotlivými zásobníkovými rámci
neexistují ¾ádné pøímé vazby a proto se ka¾dý zásobníkový rámec mù¾e (ale
nemusí) nacházet v&nbsp;pamìti kdekoli &ndash; rámce napøíklad mohou být
vytváøeny pøímo na haldì (hodnì zde zále¾í na konkrétní implementaci JVM).
Podle specifikace JVM je toti¾ ka¾dý zásobník (<i>stack</i>) tvoøen sekvencí
vzájemnì pouze nepøímo propojených zásobníkových rámcù (<i>stack frame(s)</i>),
co¾ má i své dopady na vìt¹í bezpeènost javovských aplikací.<p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Získání a následný výpis obsahu zásobníkových rámcù s&nbsp;vyu¾itím rozhraní JDI</h2>

<p>Pøi pou¾ití rozhraní <i>JVM TI</i> bylo mo¾né k&nbsp;zásobníkovým rámcùm
pøistupovat napøíklad v&nbsp;callback funkcích zavolaných ve chvíli vzniku
výjimky, popø.&nbsp;v&nbsp;callback funkcích zavolaných ve chvíli, kdy do¹lo ve
sledované javovské aplikaci k&nbsp;zavolání nìjaké metody. Tento pøístup mìl
nìkolik pøedností, ale i záporù. Pravdìpodobnì nejvìt¹í pøedností byl fakt, ¾e
pøi automatickém zavolání callback funkce zaregistrované v&nbsp;<i>JVM TI</i>
agentovi do¹lo k&nbsp;pozastavení daného vlákna, co¾ znamenalo, ¾e bylo mo¾né
relativnì bez problémù zjistit v¹echny zásobníkové rámce tohoto vlákna a
provádìt s&nbsp;nimi rùzné operace ani¾ by to ovlivnilo dal¹í vlákna aplikace.
Nevýhodou bylo to, ¾e pøístup k&nbsp;zásobníkovým rámcùm <strong>v¹ech</strong>
vláken ji¾ byl o poznání slo¾itìj¹í (nehledì na slo¾itost celého
nízkoúrovòového <i>JVM TI</i>). Pøi pou¾ití rozhraní <i>JDI</i> se
k&nbsp;problému pøistupuje vlastnì z&nbsp;opaèné strany &ndash; máme toti¾
pøístup ke v¹em vláknùm aplikace a mù¾eme zjistit a zpracovat zásobníkové rámce
libovolného vlákna, ov¹em pouze v&nbsp;pøípadì, ¾e je toto vlákno pozastaveno
(co¾ je vìt¹inou nutné zaøídit programovì pøímo z&nbsp;<i>JDI</i>).</p>

<p>Pøipomeòme si, ¾e sledovaný (cílový) virtuální stroj Javy se spou¹tí
s&nbsp;následujícími parametry:</p>

<pre>
java -agentlib:jdwp=transport=dt_socket,server=y,address=6502,suspend=y Test2
</pre>

<p>Tyto parametry mj.&nbsp;zajistí i to, ¾e ihned po spu¹tìní virtuálního
stroje a po inicializaci aplikace dojde k&nbsp;pozastavení v¹ech vláken uvnitø
JVM. Znamená to takté¾, ¾e vlastnì ani nedojde ke spu¹tìní metody
<strong>main</strong> v&nbsp;aplikaci, která má být v&nbsp;JVM spu¹tìna, tak¾e
výsledky, které z&nbsp;takto pozastaveného virtuálního stroje Javy získáme,
budou pomìrnì nezajímavé. Ov¹em díky rozhraní <i>JDI</i> není velkým problémem
cílovou JVM na chvíli spustit, èím¾ ji¾ dojde ke spu¹tìní metody
<strong>main</strong>. Po pøibli¾nì jedné sekundì dojde k&nbsp;opìtovnému
pozastavení JVM. V&nbsp;na¹em demonstraèním pøíkladu je spu¹tìní a opìtovné
pozastavení cílové JVM zaji¹tìno v&nbsp;u¾ivatelské metodì nazvané
<strong>runVirtualMachineForOneSecond</strong>, která vypadá následovnì:</p>

<pre>
<i>    /**</i>
<i>     * Spustit sledovany virtualni stroj po dobu jedne sekundy</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>runVirtualMachineForOneSecond</strong>(VirtualMachine virtualMachine) {
        virtualMachine.resume();
        try {
            Thread.sleep(1000);
        }
        catch (InterruptedException e) {
            e.printStackTrace();
        }
        virtualMachine.suspend();
    }
</pre>

<p>Jakmile je cílová JVM opìt pozastavena, je mo¾né získat informace o v¹ech
vláknech a takté¾ pøeèíst informace o v¹ech zásobníkových rámcích jednotlivých
vláken. V&nbsp;demonstraèním pøíkladu je tato funkcionalita implementována
v&nbsp;metodì <strong>printThreadInfo</strong>, kterou ji¾ èásteènì známe
z&nbsp;pøedchozí èásti tohoto seriálu (zde pouze pøibyl øádek s&nbsp;voláním
metody <strong>printStackFrames</strong>):</p>

<pre>
<i>    /**</i>
<i>     * Vypis informaci o vlaknech existujicich ve sledovanem virtualnim stroji.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>printThreadInfo</strong>(VirtualMachine virtualMachine) {
        System.out.println("Thread info:");
        System.out.println("    UniqueID    Thread name            Status       Suspended");
        List&lt;ThreadReference&gt; threads = virtualMachine.allThreads();
        for (ThreadReference thread : threads) {
            String threadName = thread.name();
            String threadStatus = getThreadStatus(thread);
            String threadSuspended = getThreadSuspended(thread);
            long uniqueID = thread.uniqueID();
            System.out.format("    %8d    %-20s   %-12s    %-5s\n", uniqueID, threadName, threadStatus, threadSuspended);
            printStackFrames(thread);
        }
        System.out.println();
    }
</pre>

<p>Pou¾ité metody rozhraní <i>JDI</i>:</p>

<table>
<tr><th>#</th><th>Tøída/rozhraní</th><th>Návratový typ</th><th>Metoda</th></tr>
<tr><td>1</td><td>com.sun.jdi.VirtualMachine</td><td>void</td><td>resume()</td></tr>
<tr><td>2</td><td>com.sun.jdi.VirtualMachine</td><td>void</td><td>suspend()</td></tr>
<tr><td>3</td><td>com.sun.jdi.ThreadReference</td><td>String</td><td>name()</td></tr>
<tr><td>4</td><td>com.sun.jdi.ObjectReference</td><td>long</td><td>uniqueID()</td></tr>
<tr><td>5</td><td>com.sun.jdi.ThreadReference</td><td>int</td><td>status()</td></tr>
<tr><td>6</td><td>com.sun.jdi.ThreadReference</td><td>boolean</td><td>isSuspended()</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Výpis informací o vybraném zásobníkovém rámci</h2>

<p>U¾ivatelské metodì nazvané <strong>printStackFrames</strong> se pøedává
objekt typu <strong>ThreadReference</strong>, který pøedstavuje vlákno
v&nbsp;cílové JVM. Nejprve je voláním
<strong>com.sun.jdi.ThreadReference.frameCount()</strong> získán poèet
zásobníkových rámcù vytvoøených pro vybrané vlákno a následnì se projde v¹emi
zásobníkovými rámci tohoto vlákna. Pro získání v¹ech zásobníkových rámcù se
vyu¾ívá metoda <strong>com.sun.jdi.ThreadReference.frames()</strong> vracející
seznam objektù typu <strong>com.sun.jdi.StackFrame</strong>:</p>

<pre>
<i>    /**</i>
<i>     * Vypis zasobnikovych ramcu</i>
<i>     *</i>
<i>     * @param thread JDI objekt predstavujici vlakno</i>
<i>     */</i>
    private static void <strong>printStackFrames</strong>(ThreadReference thread) {
        try {
            System.out.format("%16s-------------------------------------------------\n", "");
            System.out.format("%16sStack frame count: %d\n", "", thread.frameCount());
<i>            // vypsat informace o vsech zasobnikovych ramcich</i>
            for (StackFrame frame : thread.frames()) {
                printStackFrameInfo(frame);
            }
            System.out.format("%16s-------------------------------------------------\n", "");
        }
        catch (IncompatibleThreadStateException e) {
            e.printStackTrace();
        }
    }
</pre>

<p>V&nbsp;u¾ivatelské metodì <strong>printStackFrameInfo</strong> se ji¾
zji¹»ují a následnì i vypisují informace o jednotlivých zásobníkových
rámcích (o významu tøídy <strong>Location</strong> si øekneme více informací
v&nbsp;dal¹ím textu):</p>

<pre>
<i>    /**</i>
<i>     * Vypis informaci o vybranem zasobnikovem ramci</i>
<i>     *</i>
<i>     * @param frame zasobnikovy ramec</i>
<i>     */</i>
    private static void <strong>printStackFrameInfo</strong>(StackFrame frame) {
        Location location = frame.location();
<i>        // ziskat vsechny informace o pozici v pozastavenem vlaknu</i>
        String className = getClassName(location);
        String methodName = getMethodName(location);
        String sourceName = getSourceName(location);
        String lineNumber = getLineNumber(location);
&nbsp;
<i>        // nyni mame vsechny informace, lze je tedy vypsat</i>
        System.out.format("%16s%s.%s (%s:%s)\n", "", className, methodName, sourceName, lineNumber);
    }
</pre>

<p>Význam metod <strong>getClassName</strong>, <strong>getMethodName</strong>,
<strong>getSourceName</strong> a <strong>getLineNumber</strong> bude podrobnìji
vysvìtlen <a href="#k04">ve ètvrté</a> a <a href="#k05">v&nbsp;páté
kapitole</a>.</p>

<p>Pou¾ité metody rozhraní <i>JDI</i>:</p>

<table>
<tr><th>#</th><th>Tøída/rozhraní</th><th>Návratový typ</th><th>Metoda</th></tr>
<tr><td>1</td><td>com.sun.jdi.ThreadReference</td><td>int</td><td>frameCount()</td></tr>
<tr><td>2</td><td>com.sun.jdi.ThreadReference</td><td>List&lt;StackFrame&gt;</td><td>frames()</td></tr>
<tr><td>3</td><td>com.sun.jdi.StackFrame</td><td>com.sun.jdi.Location</td><td>location()</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Pøeètení jména volané metody i jména tøídy, v&nbsp;ní¾ je tato metoda deklarována</h2>

<p>Ka¾dý vývojáø pou¾ívající programovací jazyk Java se ji¾ s&nbsp;velkou
pravdìpodobností setkal s&nbsp;takzvaným <i>stack trace</i>, co¾ vlastnì není
nic jiného, ne¾ vhodným zpùsobem naformátovaný seznam volaných metod.
V&nbsp;tomto seznamu se mj.&nbsp;vypisuje i jméno metody a takté¾ jméno tøídy,
v&nbsp;ní¾ byla tato metoda deklarována. Tyto dvì informace je mo¾né
s&nbsp;vyu¾itím rozhraní <i>JDI</i> získat velmi snadno. Nejdøíve je nutné
z&nbsp;objektu typu <strong>com.sun.jdi.StackFrame</strong> získat objekt typu
<strong>com.sun.jdi.Location</strong> obsahující ve¹keré dostupné informace o
volané metodì. Jakmile máme tento objekt k&nbsp;dispozici, lze snadno získat
referenci volané metody a následnì i jméno této metody, co¾ je
v&nbsp;demonstraèním pøíkladu implementováno
v&nbsp;<strong>getMethodName</strong>:</p>

<pre>
<i>    /**</i>
<i>     * Jmeno volane metody.</i>
<i>     */</i>
    private static String <strong>getMethodName</strong>(Location location) {
        return location.method().name();
    }
</pre>

<p>Mù¾eme takté¾ získat tøídu, ve které je volaná metoda deklarována. Pou¾ívá
se zde volání <strong>com.sun.jdi.Method.declaringType()</strong> (pøesnìji
øeèeno <strong>com.sun.jdi.TypeComponent.declarintType()</strong>) vracející
objekt typu <strong>ReferenceType</strong>:</p>

<pre>
<i>    /**</i>
<i>     * Jmeno tridy, jejiz metoda byla zavolana.</i>
<i>     */</i>
    private static String <strong>getClassName</strong>(Location location) {
        return location.method().declaringType().name();
    }
</pre>

<p>Pou¾ité metody rozhraní <i>JDI</i>:</p>

<table>
<tr><th>#</th><th>Tøída/rozhraní</th><th>Návratový typ</th><th>Metoda</th></tr>
<tr><td>1</td><td>com.sun.jdi.Location</td><td>com.sun.jdi.Method</td><td>method()</td></tr>
<tr><td>2</td><td>com.sun.jdi.Method</td><td>String</td><td>name()</td></tr>
<tr><td>3</td><td>com.sun.jdi.Method</td><td>com.sun.jdi.ReferenceType</td><td>declaringType()</td></tr>
<tr><td>4</td><td>com.sun.jdi.ReferenceType</td><td>String</td><td>name()</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. Získání øádku, v&nbsp;ní¾ do¹lo k&nbsp;volání metody a pøeètení jména zdrojového souboru tøídy</h2>

<p>V&nbsp;ka¾dém <i>stack trace</i> se kromì jména tøídy a jména volané metody
objevují i dal¹í dvì informace. Jedná se o èíslo øádku s&nbsp;voláním metody a
takté¾ o jméno zdrojového souboru obsahujícího deklaraci pøíslu¹né tøídy èi
rozhraní &ndash; tato informace ov¹em nemusí být dostupná v¾dy. Nejprve se
podívejme, jak lze zjistit èíslo øádku, v&nbsp;nìm¾ do¹lo k&nbsp;volání metody.
Tuto informaci získáme pomocí
<strong>com.sun.jdi.Location.lineNumber()</strong>, která vrátí kladné èíslo
v&nbsp;pøípadì, ¾e je èíslo øádku známé a zápornou èi nulovou hodnotu ve
chvíli, kdy èíslo øádku není mo¾né z&nbsp;nìjakého dùvodu zjistit (typicky se
jedná o nativní metody). Na tomto místì je je¹tì vhodné upozornit na to, ¾e
rozhraní <i>JDI</i> operuje s&nbsp;pojmem &bdquo;strata&ldquo; (vrstvy), kde
ka¾dé vrstvì (&bdquo;stratum&ldquo;) mù¾e odpovídat jiný programovací jazyk
v&nbsp;pøípadì, ¾e je zdrojový kód transformován z&nbsp;jednoho programovacího
jazyka do jazyka jiného. Pokud je v¹ak testovací aplikace napsána pøímo
v&nbsp;Javì, nemusí nás problematika vrstev pøíli¹ trápit:</p>

<pre>
<i>    /**</i>
<i>     * Prevod cisla radku na retezec, pokud je to mozne.</i>
<i>     */</i>
    private static String <strong>getLineNumber</strong>(Location location) {
        int lineNumber = location.lineNumber();
<i>        // u nativnich metod nelze zjistit cisla radku</i>
        return lineNumber &gt;= 0 ? "" + lineNumber : "&lt;native method&gt;";
    }
</pre>

<p>Zji¹tìní jména zdrojového kódu, v&nbsp;nìm¾ je volaná metoda a samozøejmì i
pøíslu¹ná tøída deklarována, je velmi jednoduché, proto¾e pro tento úèel lze
pou¾ít volání <strong>com.sun.jdi.Location.sourceName()</strong>.
V&nbsp;pøípadì potøeby je mo¾né zjistit i cestu k&nbsp;tomuto souboru
s&nbsp;vyu¾itím <strong>com.sun.jdi.Location.sourcePath()</strong> (tuto
informaci jsme v&nbsp;rozhraní <i>JVM TI</i> zji¹»ovali jen velmi slo¾itým
zpùsobem):</p>

<pre>
<i>    /**</i>
<i>     * Ziskani informaci o jmene zdrojoveho souboru pro danou lokaci.</i>
<i>     */</i>
    private static String <strong>getSourceName</strong>(Location location) {
        try {
            return location.sourceName();
        }
        catch (AbsentInformationException e) {
            return "unknown";
        }
    }
</pre>

<p>Pou¾ité metody rozhraní <i>JDI</i>:</p>

<table>
<tr><th>#</th><th>Tøída/rozhraní</th><th>Návratový typ</th><th>Metoda</th></tr>
<tr><td>1</td><td>com.sun.jdi.Location</td><td>int</td><td>lineNumber()</td></tr>
<tr><td>2</td><td>com.sun.jdi.Location</td><td>String</td><td>sourceName()</td></tr>
</table>



<p><a name="k06"></a></p>
<h2 id="k06">6. Kompletní zdrojový kód demonstraèního pøíkladu <strong>JDIStackTraceList</strong></h2>

<p>V&nbsp;pøedchozích kapitolách byly popsány ty nejdùle¾itìj¹í metody, které
jsou souèástí dne¹ního demonstraèního pøíkladu nazvaného
<strong>JDIStackTraceList</strong>. Pod tímto odstavcem je vypsán celý zdrojový
kód tohoto stále je¹tì velmi jednoduchého debuggeru:</p>

<pre>
import java.io.IOException;
import java.util.List;
import java.util.Map;
&nbsp;
import com.sun.jdi.AbsentInformationException;
import com.sun.jdi.Bootstrap;
import com.sun.jdi.IncompatibleThreadStateException;
import com.sun.jdi.Location;
import com.sun.jdi.StackFrame;
import com.sun.jdi.ThreadReference;
import com.sun.jdi.VirtualMachine;
import com.sun.jdi.VirtualMachineManager;
import com.sun.jdi.connect.AttachingConnector;
import com.sun.jdi.connect.Connector;
import com.sun.jdi.connect.IllegalConnectorArgumentsException;
&nbsp;
<i>/**</i>
<i> * Pripojeni k bezicimu virtualnimu stroji Javy,</i>
<i> * ktery byl spusten s parametry:</i>
<i> * java -agentlib:jdwp=transport=dt_socket,server=y,address=6502,suspend=y Trida</i>
<i> *</i>
<i> * Po pripojeni se vypisou obsahy zasobnikovych ramcu vsech vlaken.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>JDIStackTraceList</strong> {
&nbsp;
<i>    /**</i>
<i>     * Navratovy kod pouzity pri ukoncovani sledovane JVM.</i>
<i>     */</i>
    private static final int EXIT_VALUE = 0;
&nbsp;
<i>    /**</i>
<i>     * Jmeno konektoru, ktery pro pripojeni pouziva sockety.</i>
<i>     */</i>
    private static final String SOCKET_ATTACH_CONNECTOR_NAME = "com.sun.jdi.SocketAttach";
&nbsp;
    public static void <strong>main</strong>(String[] args) {
<i>        // ziskat (jedinou) instanci tridy VirtualMachineManager</i>
        VirtualMachineManager virtualMachineManager = Bootstrap.virtualMachineManager();
&nbsp;
<i>        // ziskat vsechny konektory pouzite pro pripojeni k bezici JVM</i>
        List&lt;AttachingConnector&gt; connectors = virtualMachineManager.attachingConnectors();
&nbsp;
<i>        // potrebujeme ziskat konektor pouzivajici pro pripojeni sockety</i>
        AttachingConnector connector = getSocketAttachConnector(connectors);
&nbsp;
        if (connector == null) {
            System.out.println("Socket connector is not available");
            return;
        }
&nbsp;
        debugVirtualMachineUsingSocket(connector);
    }
&nbsp;
<i>    /**</i>
<i>     * Ziskat konektor pouzivajici pro pripojeni sockety</i>
<i>     */</i>
    private static AttachingConnector <strong>getSocketAttachConnector</strong>(List&lt;AttachingConnector&gt; connectors) {
        for (AttachingConnector connector : connectors) {
            if (SOCKET_ATTACH_CONNECTOR_NAME.equals(connector.name())) {
                return connector;
            }
        }
        return null;
    }
&nbsp;
<i>    /**</i>
<i>     * Pripojeni k bezicimu virtualnimu stroji pres socket.</i>
<i>     * @throws InterruptedException </i>
<i>     */</i>
    private static void <strong>debugVirtualMachineUsingSocket</strong>(AttachingConnector connector) {
        // nastaveni argumentu pouzivanych konektorem
        Map&lt;String, Connector.Argument&gt; arguments = prepareConnectorArguments(connector);
&nbsp;
        try {
<i>            // pripojeni ke vzdalenemu bezicimu virtualnimu stroji Javy</i>
            VirtualMachine virtualMachine = connectToVirtualMachine(connector, arguments);
&nbsp;
<i>            // spustit sledovany virtualni stroj po dobu jedne sekundy</i>
            runVirtualMachineForOneSecond(virtualMachine);
&nbsp;
<i>            // vypis zakladnich informaci o pripojenem VM</i>
            printVirtualMachineInfo(virtualMachine);
&nbsp;
<i>            // ukonceni behu vzdaleneho virtualniho stroje</i>
            shutdownVirtualMachine(virtualMachine);
        }
        catch (IOException e) {
            e.printStackTrace();
        }
        catch (IllegalConnectorArgumentsException e) {
            e.printStackTrace();
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Nastaveni portu na cilove JVM, jenz debugger pouzije pro navazani spojeni.</i>
<i>     *</i>
<i>     * @param connector konektor pouzity pro pripojeni</i>
<i>     * @return mapa obsahujici parametry konektoru</i>
<i>     */</i>
    private static Map&lt;String, Connector.Argument&gt; <strong>prepareConnectorArguments</strong>(AttachingConnector connector) {
        Map&lt;String, Connector.Argument&gt; arguments = connector.defaultArguments();
        arguments.get("port").setValue("6502");
        return arguments;
    }
&nbsp;
<i>    /**</i>
<i>     * Pripojeni debuggeru ke sledovanemu virtualnimu stroji.</i>
<i>     *</i>
<i>     * @param connector konektor vyuzivajici pro spojeni sockety</i>
<i>     * @param arguments mapa obsahujici parametry pripojeni</i>
<i>     * @return sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     *</i>
<i>     * @throws IOException vyvolane v pripade, ze se pripojeni k JVM nepodari</i>
<i>     * @throws IllegalConnectorArgumentsException vyvolane v pripade spatne zadanych parametru</i>
<i>     */</i>
    private static VirtualMachine <strong>connectToVirtualMachine</strong>(AttachingConnector connector, Map&lt;String, Connector.Argument&gt; arguments)
        throws IOException, IllegalConnectorArgumentsException {
        System.out.println("Connecting to virtual machine");
        VirtualMachine virtualMachine = connector.attach(arguments);
        System.out.println("Connected");
        return virtualMachine;
    }
&nbsp;
<i>    /**</i>
<i>     * Spustit sledovany virtualni stroj po dobu jedne sekundy</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>runVirtualMachineForOneSecond</strong>(VirtualMachine virtualMachine) {
        virtualMachine.resume();
        try {
            Thread.sleep(1000);
        }
        catch (InterruptedException e) {
            e.printStackTrace();
        }
        virtualMachine.suspend();
    }
&nbsp;
<i>    /**</i>
<i>     * Ukonceni prace beziciho sledovaneho virtualniho stroje.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>shutdownVirtualMachine</strong>(VirtualMachine virtualMachine) {
        System.out.println("Calling exit");
        virtualMachine.exit(EXIT_VALUE);
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis informaci ziskanych ze sledovaneho virtualniho stroje.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>printVirtualMachineInfo</strong>(VirtualMachine virtualMachine) {
        System.out.println("Basic virtual machine info:");
        printThreadInfo(virtualMachine);
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis informaci o vlaknech existujicich ve sledovanem virtualnim stroji.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>printThreadInfo</strong>(VirtualMachine virtualMachine) {
        System.out.println("Thread info:");
        System.out.println("    UniqueID    Thread name            Status       Suspended");
        List&lt;ThreadReference&gt; threads = virtualMachine.allThreads();
        for (ThreadReference thread : threads) {
            String threadName = thread.name();
            String threadStatus = getThreadStatus(thread);
            String threadSuspended = getThreadSuspended(thread);
            long uniqueID = thread.uniqueID();
            System.out.format("    %8d    %-20s   %-12s    %-5s\n", uniqueID, threadName, threadStatus, threadSuspended);
            printStackFrames(thread);
        }
        System.out.println();
    }
&nbsp;
<i>    /**</i>
<i>     * Prevod stavu vlakna na retezec.</i>
<i>     *</i>
<i>     * @param thread JDI objekt predstavujici vlakno</i>
<i>     * @return stav vlakna v retezcove podobe</i>
<i>     */</i>
    private static String <strong>getThreadStatus</strong>(ThreadReference thread) {
        switch (thread.status()) {
        case ThreadReference.THREAD_STATUS_NOT_STARTED:
            return "not started";
        case ThreadReference.THREAD_STATUS_RUNNING:
            return "running";
        case ThreadReference.THREAD_STATUS_SLEEPING:
            return "sleeping";
        case ThreadReference.THREAD_STATUS_MONITOR:
            return "wait/monitor";
        case ThreadReference.THREAD_STATUS_WAIT:
            return "Object.wait";
        case ThreadReference.THREAD_STATUS_ZOMBIE:
            return "zombie";
        case ThreadReference.THREAD_STATUS_UNKNOWN:
            return "*unkwnown*";
        default:
            return "should not happen!";
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Informace (ve tvaru retezce) o tom, zda je vlakno pozastaveno ci nikoli.</i>
<i>     *</i>
<i>     * @param thread JDI objekt predstavujici vlakno</i>
<i>     * @return stav pozastaveni vlakna v retezcove podobe</i>
<i>     */</i>
    private static String <strong>getThreadSuspended</strong>(ThreadReference thread) {
        return thread.isSuspended() ? "yes" : "no";
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis zasobnikovych ramcu</i>
<i>     *</i>
<i>     * @param thread JDI objekt predstavujici vlakno</i>
<i>     */</i>
    private static void <strong>printStackFrames</strong>(ThreadReference thread) {
        try {
            System.out.format("%16s-------------------------------------------------\n", "");
            System.out.format("%16sStack frame count: %d\n", "", thread.frameCount());
<i>            // vypsat informace o vsech zasobnikovych ramcich</i>
            for (StackFrame frame : thread.frames()) {
                printStackFrameInfo(frame);
            }
            System.out.format("%16s-------------------------------------------------\n", "");
        }
        catch (IncompatibleThreadStateException e) {
            e.printStackTrace();
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis informaci o vybranem zasobnikovem ramci</i>
<i>     *</i>
<i>     * @param frame zasobnikovy ramec</i>
<i>     */</i>
    private static void <strong>printStackFrameInfo</strong>(StackFrame frame) {
        Location location = frame.location();
<i>        // ziskat vsechny informace o pozici v pozastavenem vlaknu</i>
        String className = getClassName(location);
        String methodName = getMethodName(location);
        String sourceName = getSourceName(location);
        String lineNumber = getLineNumber(location);
&nbsp;
<i>        // nyni mame vsechny informace, lze je tedy vypsat</i>
        System.out.format("%16s%s.%s (%s:%s)\n", "", className, methodName, sourceName, lineNumber);
    }
&nbsp;
<i>    /**</i>
<i>     * Jmeno tridy, jejiz metoda byla zavolana.</i>
<i>     */</i>
    private static String <strong>getClassName</strong>(Location location) {
        return location.method().declaringType().name();
    }
&nbsp;
<i>    /**</i>
<i>     * Jmeno volane metody.</i>
<i>     */</i>
    private static String <strong>getMethodName</strong>(Location location) {
        return location.method().name();
    }
&nbsp;
<i>    /**</i>
<i>     * Ziskani informaci o jmene zdrojoveho souboru pro danou lokaci.</i>
<i>     */</i>
    private static String <strong>getSourceName</strong>(Location location) {
        try {
            return location.sourceName();
        }
        catch (AbsentInformationException e) {
            return "unknown";
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Prevod cisla radku na retezec, pokud je to mozne.</i>
<i>     */</i>
    private static String <strong>getLineNumber</strong>(Location location) {
        int lineNumber = location.lineNumber();
        // u nativnich metod nelze zjistit cisla radku
        return lineNumber &gt;= 0 ? "" + lineNumber : "&lt;native method&gt;";
    }
&nbsp;
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Spu¹tìní demonstraèního pøíkladu</h2>

<p>Pøed vlastním spu¹tìním demonstraèního pøíkladu
<strong>JDIStackTraceList</strong> je nejprve nutné spustit samostatnou cílovou
JVM i s&nbsp;testovanou aplikací. Tato aplikace je velmi jednoduchá, proto¾e se
po své inicializaci dostane do nekoneèné smyèky, co¾ nám samozøejmì vyhovuje,
nebo» bude jisté, ¾e po cca jednosekundovém bìhu cílové JVM (viz té¾ <a
href="#k02">druhou kapitolu</a>) se bude hlavní vlákno aplikace skuteènì
nacházet uvnitø této smyèky. Pov¹imnìte si, ¾e nekoneèné smyèky je dosa¾eno a¾
po postupném volání
<strong>main()</strong>&rarr;<strong>run()</strong>&rarr;<strong>foo()</strong>&rarr;<strong>bar()</strong>:</p>

<pre>
public class <strong>Test2</strong> {
&nbsp;
    public void <strong>run</strong>() {
        foo();
    }
&nbsp;
    public void <strong>foo</strong>() {
        bar();
    }
&nbsp;
    public void <strong>bar</strong>() {
        while (true) {
            System.out.println("Hello world!");
        }
    }
&nbsp;
    public static void <strong>main</strong>(String[] args) {
        new Test2().run();
    }
&nbsp;
}
</pre>

<p>Pøeklad a spu¹tìní této aplikace v&nbsp;cílovém virtuálním stroji Javy se
provede následujícím zpùsobem:</p>

<pre>
javac Test2.java
java -agentlib:jdwp=transport=dt_socket,server=y,address=6502,suspend=y Test2
</pre>

<p>Nyní ji¾ zbývá provést pøeklad a spu¹tìní na¹eho demonstraèního
pøíkladu:</p>

<pre>
javac -classpath /usr/lib/jvm/java-6-openjdk/lib/tools.jar:. JDIStackTraceList.java
java -cp /usr/lib/jvm/java-6-openjdk/lib/tools.jar:. JDIStackTraceList
</pre>

<p>Po spu¹tìní by se mìl na standardním výstupu objevit pøibli¾nì tento
text:</p>

<pre>
Connecting to virtual machine
Connected
Basic virtual machine info:
Thread info:
    UniqueID    Thread name            Status       Suspended
          56    Attach Listener        running         yes  
                -------------------------------------------------
                Stack frame count: 0
                -------------------------------------------------
          57    Signal Dispatcher      running         yes  
                -------------------------------------------------
                Stack frame count: 0
                -------------------------------------------------
          58    Finalizer              Object.wait     yes  
                -------------------------------------------------
                Stack frame count: 4
                java.lang.Object.wait (Object.java:&lt;native method&gt;)
                java.lang.ref.ReferenceQueue.remove (ReferenceQueue.java:116)
                java.lang.ref.ReferenceQueue.remove (ReferenceQueue.java:132)
                java.lang.ref.Finalizer$FinalizerThread.run (Finalizer.java:159)
                -------------------------------------------------
          59    Reference Handler      Object.wait     yes  
                -------------------------------------------------
                Stack frame count: 3
                java.lang.Object.wait (Object.java:&lt;native method&gt;)
                java.lang.Object.wait (Object.java:485)
                java.lang.ref.Reference$ReferenceHandler.run (Reference.java:116)
                -------------------------------------------------
           1    main                   running         yes  
                -------------------------------------------------
                Stack frame count: 15
                java.io.FileOutputStream.writeBytes (FileOutputStream.java:&lt;native method&gt;)
                java.io.FileOutputStream.write (FileOutputStream.java:260)
                java.io.BufferedOutputStream.flushBuffer (BufferedOutputStream.java:65)
                java.io.BufferedOutputStream.flush (BufferedOutputStream.java:123)
                java.io.PrintStream.write (PrintStream.java:432)
                sun.nio.cs.StreamEncoder.writeBytes (StreamEncoder.java:202)
                sun.nio.cs.StreamEncoder.implFlushBuffer (StreamEncoder.java:272)
                sun.nio.cs.StreamEncoder.flushBuffer (StreamEncoder.java:85)
                java.io.OutputStreamWriter.flushBuffer (OutputStreamWriter.java:168)
                java.io.PrintStream.newLine (PrintStream.java:496)
                java.io.PrintStream.println (PrintStream.java:757)
                Test2.bar (Test2.java:13)
                Test2.foo (Test2.java:8)
                Test2.run (Test2.java:4)
                Test2.main (Test2.java:18)
                -------------------------------------------------

Calling exit
</pre>

<p>Obsah jednotlivých zásobníkových rámcù se mù¾e nepatrnì li¹it, ov¹em
minimálnì v&nbsp;pøípadì vlákna pojmenovaného <strong>main</strong> by se mìla
na jeho zaèátku objevit sekvence volání:</p>

<pre>
Test2.bar (Test2.java:13)
Test2.foo (Test2.java:8)
Test2.run (Test2.java:4)
Test2.main (Test2.java:18)
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Zdrojové kódy demonstraèního pøíkladu i podpùrných skriptù</h2>

<p>Zdrojové kódy demonstraèního pøíkladu <strong>JDIStackTraceList</strong>,
testovací tøídy i skriptù pou¾itých pro pøeklad a spu¹tìní tohoto
demonstraèního pøíkladu, byly ulo¾eny (podobnì jako tomu bylo i
v&nbsp;pøedchozích èástech tohoto seriálu) do Mercurial repositáøe dostupného
na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
Prozatím nejnovìj¹í verze v¹ech zmínìných zdrojových souborù a skriptù mù¾ete
najít na adresách:</p>

<table>
<tr><th>#</th><th>Zdrojový soubor/skript</th><th>Umístìní v&nbsp;repositáøi</th></tr>
<tr><td>1</td><td>JDIStackTraceList           </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/8fad31d36206/jdi/JDIStackTraceList.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/8fad31d36206/jdi/JDIStackTraceList.java</a></td></tr>
<tr><td>2</td><td>compile_JDIStackTraceList.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/8fad31d36206/jdi/compile_JDIStackTraceList.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/8fad31d36206/jdi/compile_JDIStackTraceList.sh</a></td></tr>
<tr><td>3</td><td>Test2.java                  </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/8fad31d36206/jdi/Test2.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/8fad31d36206/jdi/Test2.java</a></td></tr>
<tr><td>4</td><td>Test2.sh                    </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/8fad31d36206/jdi/Test2.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/8fad31d36206/jdi/Test2.sh</a></td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Breakpoint (Wikipedia)<br />
<a href="http://cs.wikipedia.org/wiki/Breakpoint">http://cs.wikipedia.org/wiki/Breakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation<br />
<a href="http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html">http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; SetBreakpoint<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#SetBreakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#SetBreakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; ClearBreakpoint<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#ClearBreakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#ClearBreakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; Breakpoint (callback funkce)<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#Breakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#Breakpoint</a>
</li>

<li>The JVM Tool Interface (JVM TI): How VM Agents Work<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html">http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html</a>
</li>

<li>Creating a Debugging and Profiling Agent with JVMTI<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html">http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html</a>
</li>

<li>JVM TI (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/JVM_TI">http://en.wikipedia.org/wiki/JVM_TI</a>
</li>

<li>IBM JVMTI extensions<br />
<a href="http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html">http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

