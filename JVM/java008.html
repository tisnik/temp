<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Monitorování procesù a správa pamìti v JDK6 a JDK7 (2)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Monitorování procesù a správa pamìti v JDK6 a JDK7 (1)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;osmé èásti seriálu o vlastnostech JDK (vèetnì OpenJDK) si uká¾eme pou¾ití profileru, jen¾ je pøímo souèástí standardní instalace JRE. Takté¾ si øekneme dal¹í dùvody, proè není vhodné, aby se v&nbsp;èasto volaném programovém kódu spojovaly øetìzce pomocí operátorù + a +=. V&nbsp;závìru se navíc seznámíme se základními zpùsoby implementace správcù pamìti.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Spojování øetìzcù a dal¹í problémy, které je provázejí</a></p>
<p><a href="#k02">2. Zpùsob pøekladu operátorù + a += pøi práci s&nbsp;øetìzci</a></p>
<p><a href="#k03">3. Opakované skryté provádìní interních kopií polí znakù &ndash; AbstractStringBuilder.append(String)</a></p>
<p><a href="#k04">4. Dal¹í skryté kopie pole znakù v&nbsp;metodách String.getChars() a StringBuilder.toString()</a></p>
<p><a href="#k05">5. Malá rekapitulace</a></p>
<p><a href="#k06">6. Základní analýza bìhu programu &ndash; profiler JDK</a></p>
<p><a href="#k07">7. Implementace správcù pamìti: klasický pøípad &ndash; poèítání referencí</a></p>
<p><a href="#k08">8. Pøednosti a zápory správce pamìti zalo¾eného na poèítání referencí</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2>1. Spojování øetìzcù a dal¹í problémy, které je provázejí</h2>

<p>V&nbsp;pøedchozí èásti seriálu o bìhovém prostøedí JDK 6 a JDK 7 jsme si
øekli základní informace o problematice vytváøení a ru¹ení objektù.
V&nbsp;samotném závìru pøedchozí èásti byly ukázány tøi demonstraèní programy,
které &ndash; ka¾dý pøíklad ov¹em pomocí jiného postupu &ndash; ve své metodì
nazvané <strong>createString()</strong> vytvoøily øetìzec, v&nbsp;nìm¾ byly
ulo¾eny textové reprezentace èísel od nuly do zadané mezní hodnoty (konkrétnì
se jednalo o hodnotu 10000), pøièem¾ jednotlivá èísla byla od sebe oddìlena
jednou mezerou. První pøíklad pro vytvoøení øetìzce pou¾íval
&bdquo;øetìzcové&ldquo; operátory <strong>+</strong> a <strong>+=</strong>, ve
druhém pøíkladu se pou¾ila optimalizace s&nbsp;vyu¾itím
<strong>StringBufferu</strong> a jeho pøetí¾ené metody
<strong>append()</strong>, do nìho¾ se ov¹em ukládal lokálnì vytváøený øetìzec,
a koneènì v&nbsp;pøíkladu tøetím se ji¾ ¾ádný lokální øetìzec uvnitø programové
smyèky nevytváøel, proto¾e se jak èíselná hodnota, tak i mezera vkládaly pøímo
do <strong>StringBufferu</strong> (èíselná hodnota se samozøejmì internì musela
pøevést do øetìzcové podoby).</p>

<p>Zdrojové kódy demonstraèních pøíkladù u¾ zde nebudu znovu uvádìt, aby se
èlánek zbyteènì neprodlu¾oval. Pokud si v¹ak chcete v¹echny tøi demonstraèní
programy prohlédnout i se zvýraznìním syntaxe, je mo¾né je nalézt pod
následujícími odkazy:
<a href="">[1]</a>,
<a href="">[2]</a> a
<a href="">[3]</a>.
Èasy bìhù v¹ech tøí programù i celkové zatí¾ení procesoru se ov¹em pøi mìøení
velmi li¹ily, a to i pøesto, ¾e výsledkem práce v¹ech programù byl shodný
textový øetìzec. Ji¾ v&nbsp;pøedchozí èásti jsme si øekli, ¾e jednou
z&nbsp;pøíèin je neustálé vytváøení objektù uvnitø programové smyèky. Ov¹em to
není pøíèina jediná, i kdy¾ pomìrnì podstatná, proto¾e si v&nbsp;pøípadì
prvního pøíkladu vy¾ádala hned nìkolikeré volání správce pamìti. Druhou
pøíèinou, proè je první program o mnoho pomalej¹í, ne¾ dal¹í dva programy a
takté¾ proè je tøetí program (nepatrnì) rychlej¹í ne¾ program druhý, je to, ¾e
se pøi práci s&nbsp;øetìzci i pøi pøevodu <strong>StringBufferu</strong> èi
<strong>StringBuilderu</strong> na øetìzec provádí kopie v¹ech znakù, které
øetìzec tvoøí (na tuto pøíèinu správnì upozornili nìkteøí ètenáøi v&nbsp;
<a href="">diskusi pod pøedchozím èlánkem</a>).
Pojïme se tedy podívat, jakým zpùsobem se vlastnì internì s&nbsp;øetìzci i
s&nbsp;ostatními dvìma tøídami slou¾ícími primárnì pro úschovu øetìzcù
pracuje.</p>



<p><a name="k02"></a></p>
<h2>2. Zpùsob pøekladu operátorù + a += pøi práci s&nbsp;øetìzci</h2>

<p>Pøed popisem zpùsobu profilování programù s&nbsp;vyu¾itím nástrojù
dostupných pøímo v&nbsp;<i>JRE</i> si nejdøíve uká¾eme, v&nbsp;èem konkrétnì
spoèívají dal¹í problémy skryté zejména v&nbsp;prvním, ale èásteènì ve i druhém
demonstraèním pøíkladu. Nejprve se podíváme na to, jakým zpùsobem se pøelo¾í
metoda <strong>createString()</strong> z&nbsp;prvního demonstraèního pøíkladu.
Pro pøipomenutí &ndash; zdrojový kód této metody má následující tvar:</p>

<pre>
public static String createString()
{
    String str = "";
    for (int i = 0; i &lt; LOOP_COUNT; i++)
    {
        str += i + " ";
    }
    return str;
}
</pre>

<p>Po pøekladu demonstraèního pøíkladu do bajtkódu (ideálnì provedeném i
s&nbsp;pou¾itím modifikátoru <strong>-g</strong>) mù¾eme z&nbsp;bajtkódu
pomìrnì snadno zjistit, jak vùbec pøekladaè Javy dokázal pøelo¾it pøíkaz
<strong>str += i + " "</strong>. Bajtkód v¹ech veøejných metod získáme pomocí
pøíkazu <strong>javap -c ConcatTest1</strong>. Pod tímto odstavcem jsou vypsány
pouze ty instrukce virtuálního stroje Javy (JVM), které reprezentují metodu
<strong>createString()</strong>. Zpùsob vlastní implementace poèítané smyèky
nás v&nbsp;tento okam¾ik pøíli¹ nezajímá, proto¾e mnohem dùle¾itìj¹í je to, jak
je pøelo¾en vý¹e uvedený pøíkaz <strong>str += i + " "</strong>. Instrukce,
kterými je tento zdánlivì jednoduchý pøíkaz implementován, jsou oznaèeny na
zaèátku ka¾dého øádku hvìzdièkou:</p>

<pre>
public static java.lang.String createString();
  Code:
   0:   ldc             #2; //String 
   2:   astore_0
   3:   iconst_0
   4:   istore_1
   5:   iload_1
   6:   sipush  10000
   9:   if_icmpge 42        // na bajtu s indexem 42 je konec smyèky
*  12:  new             #3; //class java/lang/StringBuilder
*  15:  dup
*  16:  invokespecial   #4; //Method java/lang/StringBuilder."(init)":()V
*  19:  aload_0
*  20:  invokevirtual   #5; //Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
*  23:  iload_1
*  24:  invokevirtual   #6; //Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;
*  27:  ldc             #7; //String  
*  29:  invokevirtual   #5; //Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
*  32:  invokevirtual   #8; //Method java/lang/StringBuilder.toString:()Ljava/lang/String;
*  35:  astore_0
   36:  iinc    1, 1
   39:  goto    5           // skok zpìt na zaèátek smyèky
   42:  aload_0
   43:  areturn
</pre>

<p>Vzhledem k&nbsp;tomu, ¾e vý¹e uvedený bajtkód je pro velkou èást
programátorù v&nbsp;Javì pomìrnì nepøehledný a ¹patnì èitelný, je ní¾e pro
ilustraci vypsán programový kód, který je do co nejvìt¹í míry ekvivalentní
s&nbsp;instrukcemi, je¾ se vyskytují ve vygenerovaném bajtkódu. Pov¹imnìte si,
¾e se v&nbsp;tomto zdrojovém kódu instance tøídy <strong>StringBuilder</strong>
ihned po svém vytvoøení (konstrukci) naplní pùvodním øetìzcem, ke kterému se
mají pøipisovat dal¹í znaky. Posléze se do tohoto objektu pøidá textová
reprezentace celého èísla následovaná øetìzcem obsahujícím mezeru. Pou¾ití
øetìzce bylo v&nbsp;tomto pøípadì zpùsobeno tím, ¾e by zápis <strong>i + '
'</strong> ve skuteènosti znamenal pøiètení konstanty 32 k&nbsp;hodnotì
promìnné <strong>i</strong>, co¾ vùbec není chování, které oèekáváme (zmínìná
konstanta 32 samozøejmì odpovídá ASCII hodnotì mezery &ndash; space). Poslední
operací, která se s&nbsp;instancí tøídy <strong>StringBuffer</strong> provádí,
je pøevod jejího atributu na øetìzec:</p>

<pre>
public static String createString()
{
    String str = "";
    for (int i = 0; i &lt; LOOP_COUNT; i++)
    {
        StringBuilder tmp = new StringBuilder();
        tmp.append(str);
        tmp.append(i);
        tmp.append(" ");
        str = tmp.toString();
    }
    return str;
}
</pre>



<p><a name="k03"></a></p>
<h2>3. Opakované skryté provádìní interních kopií polí znakù &ndash; AbstractStringBuilder.append(String)</h2>

<p>I pøi letmém pohledu na fragment zdrojového kódu vypsaného v&nbsp;závìru
pøedchozí kapitoly mù¾eme objevit jeden problém &ndash; uvnitø programové
smyèky se vytváøí pomocná instance tøídy <strong>StringBuilder</strong>,
z&nbsp;ní¾ je na konci ka¾dé iterace získána nová podoba øetìzce
<strong>str</strong> (navíc je je¹tì, jak uvidíme dále, vytvoøena i nová
instance tøídy <strong>String</strong>). O tomto problému &ndash; konkrétnì o
èastém vytváøení objektù s&nbsp;velmi krátkou dobou ¾ivota &ndash; jsme se
dozvìdìli základní informace ji¾ v&nbsp;pøedchozí èásti tohoto seriálu. Ov¹em
v&nbsp;onìch pìti øádcích uvnitø programové smyèky jsou skryta i dal¹í úskalí,
spoèívající v&nbsp;tom, ¾e se (i kdy¾ skrytì) v&nbsp;operaèní pamìti neustále
provádí nìkolik kopií polí znakù. S&nbsp;tìmito úskalími &ndash; které ov¹em
zdaleka neplatí pouze pro tøídu <strong>String</strong>, ale i pro nìkteré
dal¹í èasto pou¾ívané programové konstrukce &ndash; se podrobnìji seznámíme
v&nbsp;následujících odstavcích, kde se takté¾ podíváme na zpùsob, jakým jsou
jednotlivé metody implementovány v&nbsp;knihovnách JDK. Zamìøíme se pøitom na
implementaci pou¾itou v&nbsp;(Open)JDK 7, ov¹em podobnì je tomu i
v&nbsp;(Open)JDK 6.</p>

<p>První z&nbsp;tohoto pohledu zajímavou metodou je metoda
<strong>StringBuilder.append(String)</strong>, která je je v&nbsp;OpenJDK 7
implementována následujícím zpùsobem:</p>

<pre>
public AbstractStringBuilder append(String str)
{
    if (str == null) str = "null";
    int len = str.length();
    ensureCapacityInternal(count + len);
    str.getChars(0, len, value, count);
    count += len;
    return this;
}
</pre>

<p>V&nbsp;této metodì jsou potenciálnì výpoèetnì nároèné dva pøíkazy &ndash;
volání metody <strong>ensureCapacityInternal()</strong>, tj.&nbsp;zaji¹tìní,
aby se do <strong>StringBuilderu</strong> mohl skuteènì pøipojit celý øetìzec a
takté¾ volání metody <strong>String.getChars()</strong>, v&nbsp;ní¾ se provádí
defenzivní kopie pole znakù z&nbsp;øetìzce do atributu <strong>value</strong>.
První ze zmínìných metod &ndash; privátní metoda
<strong>ensureCapacityInternal()</strong> &ndash; není sama o sobì pøíli¹
zajímavá; ostatnì posuïte sami:</p>

<pre>
private void ensureCapacityInternal(int minimumCapacity)
{
    // overflow-conscious code
    if (minimumCapacity - value.length &gt; 0)
        expandCapacity(minimumCapacity);
}
</pre>

<p>Zajímavìj¹í je ji¾ metoda <strong>expandCapacity()</strong>, která je
zavolaná v&nbsp;pøípadì, kdy je zapotøebí zvìt¹it kapacitu
<strong>StringBufferu</strong> nebo <strong>StringBuilderu</strong>.
V&nbsp;na¹em demonstraèním pøípadu ke zvìt¹ení kapacity urèitì dojde ji¾ po
nìkolika málo iteracích (kdy se prùbì¾nì roz¹iøovaný øetìzec zvìt¹í), proto¾e
standardní velikost pole znakù je v&nbsp;pøípadì
<strong>StringBufferu()</strong> a <strong>StringBuilderu()</strong> rovna
pouze 16 znakùm. Pøi roz¹íøení kapacity bufferu samozøejmì musí dojít ke kopii
pole znakù na zaèátek vìt¹ího pole. Zda je tomu skuteènì tak, se dozvíme pøi
pohledu na zdrojový kód metody <strong>expandCapacity()</strong>:</p>

<pre>
void expandCapacity(int minimumCapacity)
{
    int newCapacity = value.length * 2 + 2;
    if (newCapacity - minimumCapacity &lt; 0)
        newCapacity = minimumCapacity;
    if (newCapacity &lt; 0) {
        if (minimumCapacity &lt; 0) // overflow
            throw new OutOfMemoryError();
        newCapacity = Integer.MAX_VALUE;
    }
    value = Arrays.copyOf(value, newCapacity);
}
</pre>

<p>Z&nbsp;vý¹e uvedeného výpisu je patrné, ¾e se kopie pole znakù pøi zvìt¹ení
kapacity <strong>StringBufferu</strong> nebo <strong>StringBuilderu</strong>
skuteènì provádí a pùvodní pole ulo¾ené v&nbsp;atributu <strong>value</strong>
musí být následnì uvolnìno správcem pamìti.</p>



<p><a name="k04"></a></p>
<h2>4. Dal¹í skryté kopie pole znakù v&nbsp;metodách String.getChars() a StringBuilder.toString()</h2>

<p>To ov¹em zdaleka není jediná kopie pole, která se pøi provádìní onoho tak
nenápadného, ale o to více problematického pøíkazu <strong>str += i + "&nbsp;"
</strong> musí provést. Dal¹í kopie je skryta ve vý¹e popsané metodì
<strong>StringBuilder.append(String)</strong>, konkrétnì na programovém øádku
<strong>str.getChars(0, len, value, count);</strong>, proto¾e metoda
<strong>String.getChars()</strong> provádí defenzivní kopii celého pole znakù
(toto pole pøedstavuje interní podobu øetìzce v&nbsp;operaèní pamìti). O tom,
¾e se tato kopie skuteènì provádí, se mù¾eme snadno pøesvìdèit ve zdrojových
kódech <i>OpenJDK</i>:</p>

<pre>
public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin)
{
    if (srcBegin &lt; 0)
    {
        throw new StringIndexOutOfBoundsException(srcBegin);
    }
    if (srcEnd &gt; count)
    {
        throw new StringIndexOutOfBoundsException(srcEnd);
    }
    if (srcBegin &gt; srcEnd)
    {
        throw new StringIndexOutOfBoundsException(srcEnd - srcBegin);
    }
    System.arraycopy(value, offset + srcBegin, dst, dstBegin, srcEnd - srcBegin);
}
</pre>

<p>Poslední (koneènì :-) problematickou èást kódu mù¾eme najít v&nbsp;pátém
pøíkazu v&nbsp;programové smyèce, tj.&nbsp;ve volání metody
<strong>StringBuilder.toString()</strong>. V&nbsp;této metodì se toti¾ vytvoøí
nová instance tøídy <strong>String</strong>, která se bude inicializovat je¹tì
jednou zkopírovaným polem znakù, proto¾e metoda
<strong>StringBuilder.toString()</strong> má následující tvar:</p>

<pre>
public String toString()
{
    // Create a copy, don't share the array
    return new String(value, 0, count);
}
</pre>

<p>Pøièem¾ se v&nbsp;konstruktoru <strong>String(char value[], int offset, int
count)</strong> volá metoda:</p>

<pre>
Arrays.copyOfRange(value, offset, offset+count);
</pre>



<p><a name="k05"></a></p>
<h2>5. Malá rekapitulace</h2>

<p>Proveïme si malé shrnutí poznatkù získaných z&nbsp;pøedchozích kapitol.
Pùvodní pøíkaz:</p>

<pre>
str += i + " ";
</pre>

<p>kde promìnná <strong>str</strong> je typu <strong>String</strong> a promìnná
<strong>i</strong> je typu <strong>int</strong>, se pøelo¾í do následující
sekvence pøíkazù:</p>

<pre>
StringBuilder tmp = new StringBuilder();
tmp.append(str);
tmp.append(i);
tmp.append(" ");
str = tmp.toString();
</pre>

<p>V&nbsp;nich¾ se kromì jiného provádí i následující kopie polí znakù:</p>

<pre>
tmp.append(str):
    Arrays.copyOf (pouze v&nbsp;pøípadì, ¾e se zvìt¹uje kapacita bufferu)
    System.arraycopy
&nbsp;
tmp.toString():
    Arrays.copyOfRange
</pre>

<p>Kromì vý¹e zmínìného neustálého kopírování v&nbsp;podstatì stále tìch samých
znakù mezi nìkolika regiony operaèní pamìti se navíc pøi ka¾dé iteraci vytvoøí
tyto objekty:</p>

<pre>
StringBuilder
String
</pre>

<p>Pøièem¾ se pùvodní instance tøídy <strong>String</strong> stane neaktivní,
stejnì jako lokálnì (v&nbsp;programové smyèce) vytvoøený objekt
<strong>StringBuilder</strong>.</p>

<p>Je¹tì do této kapitoly doplním malou statistiku &ndash; délka vytvoøeného
øetìzce je pro 10000 iterací rovna pouhým 48890 znakùm a &ndash; pokud
zanedbáme kopie polí provádìné v&nbsp;pøípadì zvìt¹ování kapacity bufferu
&ndash; vyjde nám, ¾e se pro získání takto krátkého øetìzce musí v&nbsp;pamìti
pøesunout celkem 478858990 znakù, tj.&nbsp;cca 912 MB! Poèet kopírovaných znakù
toti¾ roste se zvìt¹ujícím se poètem iterací pomìrnì rychle:</p>

<table>
<tr><th>Poèet iterací</th><th>Zkopírovaných bajtù</th></tr>
<tr><td>1 </td><td>4  </td></tr>
<tr><td>2 </td><td>12 </td></tr>
<tr><td>3 </td><td>24 </td></tr>
<tr><td>4 </td><td>40 </td></tr>
<tr><td>5 </td><td>60 </td></tr>
<tr><td>6 </td><td>84 </td></tr>
<tr><td>7 </td><td>112</td></tr>
<tr><td>8 </td><td>144</td></tr>
<tr><td>9 </td><td>180</td></tr>
<tr><td>10</td><td>220</td></tr>
<tr><td>11</td><td>266</td></tr>
<tr><td>12</td><td>318</td></tr>
<tr><td>13</td><td>376</td></tr>
<tr><td>14</td><td>440</td></tr>
<tr><td>15</td><td>510</td></tr>
<tr><td>16</td><td>586</td></tr>
<tr><td>17</td><td>668</td></tr>
<tr><td>18</td><td>756</td></tr>
<tr><td>19</td><td>850</td></tr>
<tr><td>20</td><td>950</td></tr>
</table>

<p>Mimochodem &ndash; ani druhý demonstraèní pøíklad není zcela bez chybièky,
proto¾e se jeho programová smyèka ve tvaru:</p>

<pre>
StringBuffer str = new StringBuffer();
for (int i = 0; i &lt; LOOP_COUNT; i++)
{
    str.append(i + " ");
}
return str.toString();
</pre>

<p>Pøelo¾í takto:</p>

<pre>
StringBuffer str = new StringBuffer();
for (int i = 0; i &lt; LOOP_COUNT; i++)
{
    StringBuilder tmp = new StringBuilder();
    tmp.append(i);
    tmp.append(" ");
    String s = tmp.toString();
    str.append(s);
}
return str.toString();
</pre>

<p>Co¾ znamená, ¾e se opìt vytváøí pøi ka¾dé iteraci nìkolik doèasných objektù
a takté¾ se provádí kopie polí znakù. Ov¹em v&nbsp;tomto pøípadì se jedná pouze
o velmi malá pole, navíc je zde èasová slo¾itost prakticky lineární, na rozdíl
od problematického pøíkladu prvního.</p>



<p><a name="k06"></a></p>
<h2>6. Základní analýza bìhu programu &ndash; profiler JDK</h2>

<p>&bdquo;Statické&ldquo; analýzy programového kódu, které jsme si ukázali
v&nbsp;pøedchozích kapitolách, sice mohou vést k&nbsp;základnímu pøehledu o
tom, co se v&nbsp;bì¾ícím procesu dìje a kde mohou být jeho slabá místa, ov¹em
v&nbsp;mnoha pøípadech nám nedají pøesnou informaci o skuteènì kritických
èástech kódu, tj.&nbsp;o èástech, které se volají velmi èasto a které mnohdy
tvoøí nejdùle¾itìj¹í místo v&nbsp;programu, na nì¾ by se mìli programátoøi
zamìøit pøi optimalizacích. Pro tento úèel se &ndash; kromì dal¹ích nástrojù
&ndash; pou¾ívají i takzvané <i>profilery</i>. V&nbsp;pøípadì pou¾ití <i>Oracle
JDK</i> nebo <i>OpenJDK</i> mají vývojáøi výhodu v&nbsp;tom, ¾e mohou pou¾ít
profiler zabudovaný pøímo do JRE, tj.&nbsp;do bìhového prostøedí Javy. Je to
ostatnì to nejlep¹í místo, kam profiler umístit, proto¾e právì JRE má v¹echny
informace jak o naètených knihovnách, tak i o nativních metodách, které jsou
internì volány z&nbsp;Javovského kódu.</p>

<p>Pou¾ití interního profileru JRE je jednoduché &ndash; pøi startu Javovské
aplikace postaèí pou¾ít parametr <i>-Xprof</i> s&nbsp;pøesmìrováním
profilovacích informací ze standardního výstupu do souboru:</p>

<pre>
java -Xprof ConcatTest1 &gt; ConcatTest1.prof
</pre>

<p>Výsledky bìhu profileru mohou být v&nbsp;nìkterých pøípadech zajímavé, jak
se ostatnì ukazuje pøi spu¹tìní profileru pro první demonstraèní pøíklad,
tj.&nbsp;pro pøíklad, ve kterém se provádí konkatenace øetìzcù v&nbsp;pøíkazu
<i>str += i + " ";</i>. Z&nbsp;výstupu profileru je patrné, ¾e nejvíce èasu
proces ztratí pøi volání metod
<strong>AbstractStringBuilder.expandCapacity()</strong> (tato metoda obsahuje
volání <strong>Arrays.copyOf()</strong>, jak jsme si ji¾ ostatnì øekli ve tøetí
kapitole), dále pak v&nbsp;metodì
<strong>AbstractStringBuilder.append()</strong> (s&nbsp;parametrem String, co¾
zde není patrné) a takté¾ pøi inicializaci øetìzcù:</p>

<pre>
Flat profile of 5.53 secs (297 total ticks): main
&nbsp;
  Interpreted + native   Method
  1.0%     3  +     0    java.lang.AbstractStringBuilder.append
  0.7%     2  +     0    java.util.Arrays.copyOf
  0.3%     1  +     0    java.util.zip.ZipEntry.&lt;init&gt;
  0.3%     1  +     0    java.util.Arrays.copyOfRange
  0.3%     1  +     0    sun.misc.URLClassPath$3.run
  2.7%     8  +     0    Total interpreted
&nbsp;
     Compiled + native   Method
 29.6%     0  +    88    java.lang.AbstractStringBuilder.expandCapacity
 19.9%    59  +     0    java.lang.AbstractStringBuilder.append
 18.9%    56  +     0    java.lang.String.&lt;init&gt;
 17.2%    51  +     0    java.lang.AbstractStringBuilder.append
 11.4%     0  +    34    java.util.Arrays.copyOfRange
 97.0%   166  +   122    Total compiled
&nbsp;
         Stub + native   Method
  0.3%     0  +     1    java.lang.System.arraycopy
  0.3%     0  +     1    Total stub
&nbsp;
&nbsp;
Flat profile of 6.51 secs (1 total ticks): DestroyJavaVM
&nbsp;
  Thread-local ticks:
100.0%     1             Unknown: thread_state
&nbsp;
&nbsp;
Global summary of 12.04 seconds:
100.0%   399             Received ticks
 23.1%    92             Received GC ticks
  2.0%     8             Other VM operations
  0.3%     1             Unknown code
</pre>

<p>Pøi profilování druhého demonstraèního pøíkladu se ukazuje, ¾e se náhrada
spojování øetìzcù za pøipojování øetìzce na konec
<strong>StringBuilderu</strong> èi <strong>StringBufferu</strong>,
v&nbsp;ka¾dém pøípadì vyplácí, nebo» program je mnohem rychlej¹í (první øádek).
Souèasnì se zcela zmìnilo poøadí metod, v&nbsp;nich¾ bì¾ící proces tráví
nejvíce strojového èasu &ndash; ze 40% se jedná o nativní metodu
<strong>System.arraycopy</strong> volanou (internì) v&nbsp;programové
smyèce:</p>

<pre>
Flat profile of 0.00 secs (1 total ticks): Secondary finalizer
&nbsp;
  Thread-local ticks:
100.0%     1             Unknown: no last frame
&nbsp;
Flat profile of 0.09 secs (6 total ticks): main
&nbsp;
  Interpreted + native   Method
 20.0%     1  +     0    java.util.Arrays.copyOfRange
 20.0%     1  +     0    java.lang.String.indexOf
 20.0%     1  +     0    java.lang.AbstractStringBuilder.stringSizeOfInt
 60.0%     3  +     0    Total interpreted
&nbsp;
         Stub + native   Method
 40.0%     0  +     2    java.lang.System.arraycopy
 40.0%     0  +     2    Total stub
&nbsp;
  Thread-local ticks:
 16.7%     1             Blocked (of total)
&nbsp;
&nbsp;
Flat profile of 6.51 secs (1 total ticks): DestroyJavaVM
&nbsp;
  Thread-local ticks:
100.0%     1             Unknown: thread_state
&nbsp;
&nbsp;
Global summary of 6.61 seconds:
100.0%     7             Received ticks
 28.6%     2             Unknown code
</pre>

<p>Ve tøetím demonstraèním pøíkladu program strávil vìt¹inu svého pøidìleného
strojového èasu <i>mimo</i> vlastní metodu <strong>createString()</strong>,
proto¾e jediná metoda, která ov¹em zabrala zhruba pouze ètvrtinu èasu, byla
metoda <strong>AbstractStringBuilder.append()</strong>. Zde je ov¹em nutné
poznamenat, ¾e pokud by se poèet iterací napøíklad øádovì zvý¹il, byly by
výsledky jiné (na druhou stranu by v¹ak první demonstraèní pøíklad bì¾el i
nìkolik minut, proto¾e u nìj je èasová slo¾itost zhruba exponenciální):</p>

<pre>
Flat profile of 0.06 secs (4 total ticks): main
&nbsp;
  Interpreted + native   Method
 25.0%     0  +     1    java.util.zip.ZipFile.open
 25.0%     1  +     0    java.util.LinkedHashMap.createEntry
 25.0%     1  +     0    java.lang.AbstractStringBuilder.append
 25.0%     0  +     1    java.lang.Runtime.gc
100.0%     2  +     2    Total interpreted
&nbsp;
&nbsp;
Flat profile of 6.52 secs (1 total ticks): DestroyJavaVM
&nbsp;
  Thread-local ticks:
100.0%     1             Unknown: thread_state
&nbsp;
&nbsp;
Global summary of 6.57 seconds:
100.0%     5             Received ticks
 20.0%     1             Unknown code
</pre>



<p><a name="k07"></a></p>
<h2>7. Implementace správcù pamìti: klasický pøípad &ndash; poèítání referencí</h2>

<p>Po malé, ale pomìrnì dùle¾ité odboèce, v&nbsp;ní¾ jsme se zabývali problémy
s&nbsp;výpoèetním výkonem a systémovou nároèností nìkterých operací
s&nbsp;øetìzci v&nbsp;Javì, se ji¾ koneènì zaèneme vìnovat popisu funkcí
správcù pamìti, které jsou v&nbsp;posledních verzích JVM k&nbsp;dispozici.
Správci pamìti (<i>garbage collectors &ndash; GC</i>) tvoøí nezbytnou a
integrální souèást virtuálního stroje jazyka Java, proto¾e tento programovací
jazyk je pøímo navr¾en takovým zpùsobem, aby se vývojáøi nemuseli ve vìt¹inì
pøípadù starat o to, v&nbsp;jakém okam¾iku a jakým zpùsobem mají odstraòovat
objekty z&nbsp;operaèní pamìti. Jak jsme si ji¾ øekli v&nbsp;pøedchozích
èástech tohoto seriálu, jsou v¹echny objekty, vèetnì objektù lokálních
v&nbsp;dané funkci nebo programovém bloku (napøíklad v&nbsp;tìle programové
smyèky), vytváøeny dynamicky na haldì (<i>heapu</i>), nikoli na zásobníku. To
je pomìrnì velký rozdíl pøi porovnání Javy a nìkterých dal¹ích programovacích
jazykù, které doká¾ou lokální objekty alokovat v&nbsp;takzvaném zásobníkovém
rámci (<i>stack frame</i>).</p>

<p>Programátoøi navíc v&nbsp;Javì nemají pøístup pøímo k&nbsp;fyzické podobì
objektù, tak jak jsou ulo¾eny v&nbsp;operaèní pamìti, ale získají pouze
<i>referenci</i> na objekt, pøes kterou pøistupují k&nbsp;atributùm a metodám
objektù (to mimo jiné znamená, ¾e objekty jako své atributy obsahují pouze
hodnoty primitivních datových typù nebo reference na jiné objekty). Jedním
z&nbsp;nejjednodu¹¹ích a velmi pravdìpodobnì i jedním z&nbsp;prvních typù
správcù pamìti, které byly vytvoøeny, je správce pamìti zalo¾ený na <i>poèítání
referencí</i> (<i>reference counting</i>). Tento správce pamìti sice není
v&nbsp;JVM bì¾nì pou¾íván, nicménì je dobré se s&nbsp;jeho funkcí seznámit a
zjistit jeho pøednosti a zápory. Správce pamìti zalo¾ený na poèítání referencí
pøiøazuje ka¾dému objektu poèitadlo (celoèíselnou hodnotu), v&nbsp;nìm¾ je
ulo¾ené, kolikrát je daný objekt <i>referencován</i>, jinými slovy, kolik
k&nbsp;tomuto objektu v&nbsp;bì¾ícím procesu existuje platných referencí èi
ukazatelù.</p>

<p>Správce pamìti v&nbsp;tomto pøípadì mù¾e odstranit pouze ty objekty, jejich¾
poèitadlo dosáhlo nuly. Dùle¾ité pøitom je, aby se pøi ka¾dém vzniku reference
poèitadlo zvý¹ilo o jednièku a navíc pøi ka¾dém zániku reference opìt o
jednièku sní¾ilo. To napøíklad znamená, ¾e pøíkaz (zde nikoli výraz!):</p>

<pre>
new Color(0x000000);
</pre>

<p>sice vytvoøí objekt, ov¹em poèitadlo referencí bude rovno nule, zatímco
pøíkazy:</p>

<pre>
Color c = new Color(0x000000);
</pre>

<p>popø:</p>

<pre>
callMethod(new Color(0x000000));
</pre>

nebo:

<pre>
private Color color = new Color(0x000000);
</pre>

<p>vytvoøí objekt, jeho¾ poèitadlo referencí je nastaveno na jednièku.</p>



<p><a name="k08"></a></p>
<h2>8. Pøednosti a zápory správce pamìti zalo¾eného na poèítání referencí</h2>

<p>Tento typ správce pamìti je sice implementaènì pomìrnì jednoduchý a souèasnì
i rychlý, proto¾e není zapotøebí slo¾itì zji¹»ovat, které objekty je mo¾né
odstranit, ov¹em má jednu pomìrnì záva¾nou nevýhodu &ndash; nedoká¾e
z&nbsp;pamìti odstranit ty objekty, které tvoøí cyklus, tj.&nbsp;napøíklad
objekt <strong>A</strong> obsahující referenci na objekt <strong>B</strong>,
který naopak obsahuje referenci na objekt <strong>A</strong>. Cyklus samozøejmì
mù¾e být i del¹í, mù¾e se napøíklad jednat i o slo¾itou grafovou strukturu
s&nbsp;alespoò jedním cyklem. Druhou nevýhodou &ndash; i kdy¾ ménì záva¾nou
&ndash; je to, ¾e v&nbsp;mnoha pøípadech mù¾e být neustálá zmìna hodnoty
poèitadla referencí výpoèetnì nároèná, zejména kvùli nutnosti jeho
synchronizace mezi v¹emi vlákny, které úloha pou¾ívá (a navíc s&nbsp;vláknem èi
více vlákny samotného správce pamìti), proto¾e zvý¹ení poèitadla o jednièku,
sní¾ení poèitadla o jednièku a souèasný test na jeho nulovou hodnotu nebývají
na souèasných procesorech atomické operace. Ov¹em ji¾ první uvedený dùvod
(neodstranìní objektù tvoøících cyklus) vedl k&nbsp;tomu, ¾e se s&nbsp;tímto
správcem pamìti v&nbsp;JDK prakticky nesetkáme, i kdy¾ by se tento správce
pamìti hodil pøedev¹ím na realtimeové úlohy.</p>

<p>V&nbsp;moderních implementacích JDK se namísto toho setkáme se správci
pamìti, které jsou zalo¾ené na zji¹»ování, které objekty jsou v&nbsp;daném
okam¾iku dostupné z&nbsp;ka¾dého vlákna aplikace. Vzhledem k&nbsp;tomu, ¾e test
na &bdquo;¾ivost&ldquo; objektù je pomìrnì nároèný, jsou objekty podle svého
chování za bìhu aplikace rozdìlovány do nìkolika skupin, pøièem¾ se
s&nbsp;ka¾dou skupinou objektù zachází ponìkud odli¹ným zpùsobem. Bli¾¹í
informace o principu práce tìchto správcù pamìti, zpùsobù jejich monitorování
(to je samozøejmì mo¾né a nìkdy i nutné) i optimalizací jejich parametrù, budou
uvedeny v&nbsp;následující èásti tohoto seriálu.</p>



<p><a name="k09"></a></p>
<h2>9. Odkazy na Internetu</h2>

<ol>

<li>Dr. Dobb's | G1: Java's Garbage First Garbage Collector<br />
<a href="http://www.drdobbs.com/article/printableArticle.jhtml?articleId=219401061&amp;dept_url=/java/">http://www.drdobbs.com/article/printableArticle.jhtml?articleId=219401061&amp;dept_url=/java/</a>
</li>

<li>Java's garbage-collected heap<br />
<a href="http://www.javaworld.com/javaworld/jw-08-1996/jw-08-gc.html">http://www.javaworld.com/javaworld/jw-08-1996/jw-08-gc.html</a>
</li>

<li>Compressed oops in the Hotspot JVM<br />
<a href="http://wikis.sun.com/display/HotSpotInternals/CompressedOops">http://wikis.sun.com/display/HotSpotInternals/CompressedOops</a>
</li>

<li>32-bit or 64-bit JVM? How about a Hybrid?<br />
<a href="http://blog.juma.me.uk/2008/10/14/32-bit-or-64-bit-jvm-how-about-a-hybrid/">http://blog.juma.me.uk/2008/10/14/32-bit-or-64-bit-jvm-how-about-a-hybrid/</a>
</li>

<li>Compressed object pointers in Hotspot VM<br />
<a href="http://blogs.sun.com/nike/entry/compressed_object_pointers_in_hotspot">http://blogs.sun.com/nike/entry/compressed_object_pointers_in_hotspot</a>
</li>

<li>Java HotSpot(tm) Virtual Machine Performance Enhancements<br />
<a href="http://download.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html">http://download.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html</a>
</li>

<li>Using jconsole<br />
<a href="http://download.oracle.com/javase/1.5.0/docs/guide/management/jconsole.html">http://download.oracle.com/javase/1.5.0/docs/guide/management/jconsole.html</a>
</li>

<li>jconsole &ndash; Java Monitoring and Management Console<br />
<a href="http://download.oracle.com/javase/1.5.0/docs/tooldocs/share/jconsole.html">http://download.oracle.com/javase/1.5.0/docs/tooldocs/share/jconsole.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>x86-64<br />
<a href="http://en.wikipedia.org/wiki/X86-64">http://en.wikipedia.org/wiki/X86-64</a>
</li>

<li>Physical Address Extension<br />
<a href="http://en.wikipedia.org/wiki/Physical_Address_Extension">http://en.wikipedia.org/wiki/Physical_Address_Extension</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>1.6.0_14 (6u14)<br />
<a href="http://www.oracle.com/technetwork/java/javase/6u14-137039.html?ssSourceSiteId=otncn">http://www.oracle.com/technetwork/java/javase/6u14-137039.html?ssSourceSiteId=otncn</a>
</li>

<li>Update Release Notes<br />
<a href="http://www.oracle.com/technetwork/java/javase/releasenotes-136954.html">http://www.oracle.com/technetwork/java/javase/releasenotes-136954.html</a>
</li>

<li>4.10 Limitations of the Java Virtual Machine<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#88659">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#88659</a>
</li>

<li>Java(TM) Platform, Standard Edition 7 Binary Snapshot Releases<br />
<a href="http://dlc.sun.com.edgesuite.net/jdk7/binaries/index.html">http://dlc.sun.com.edgesuite.net/jdk7/binaries/index.html</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>ClosableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>ArrayList (JDK 1.4)<br />
<a href="http://download.oracle.com/javase/1.4.2/docs/api/java/util/ArrayList.html">http://download.oracle.com/javase/1.4.2/docs/api/java/util/ArrayList.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2011</small></p>
</body>
</html>

