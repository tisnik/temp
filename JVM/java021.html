<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM (4.èást - dokonèení popisu struktury souborù .class)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM (4.èást - dokonèení popisu struktury souborù .class)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o vlastnostech JVM dokonèíme popis struktury bajtkódu, tj. souborù s koncovkou .class generovaných (vìt¹inou) pøekladaèem Javy. Øekneme si, jakým zpùsobem jsou ulo¾eny informace o datových polo¾kách tøíd, rozhraní èi výètových typù, jak jsou ulo¾eny jednotlivé metody a zmíníme se takté¾ o atributech pøiøazených k vlastním tøídám.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM (4.èást - dokonèení popisu struktury souborù .class)</a></p>
<p><a href="#k02">2. Struktura obsahující seznam datových polo¾ek deklarovaných ve tøídì èi rozhraní</a></p>
<p><a href="#k03">3. Bitové pøíznaky urèující vlastnosti datové polo¾ky</a></p>
<p><a href="#k04">4. Atributy pøiøazené k&nbsp;datové polo¾ce</a></p>
<p><a href="#k05">5. Demonstraèní pøíklad &ndash; výpis pøíznakù, deskriptorù a atributù rùzných typù datových polo¾ek</a></p>
<p><a href="#k06">6. Struktura obsahující seznam v¹ech deklarovaných metod</a></p>
<p><a href="#k07">7. Roz¹íøení demonstraèního dekompileru o výpis seznamu datových polo¾ek a metod</a></p>
<p><a href="#k08">8. Atributy pøiøazené ke tøídì nebo k&nbsp;rozhraní</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM (4.èást - dokonèení popisu struktury souborù .class)</h2>

<p>V&nbsp;dne¹ní &ndash; ji¾ dvacáté první &ndash; èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyce Java</a> i o vlastnostech virtuálního stroje tohoto jazyka
dokonèíme popis interní struktury bajtkódu. V&nbsp;pøedchozích tøech èláncích
[<a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-1-cast-prohlizeni-a-modifikace-bajtkodu/">1</a>][<a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-2-cast-podrobnejsi-analyza-obsahu-constant-poolu/">2</a>][<a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-3-cast-pokracovani-popisu-struktury-souboru-class/">3</a>]
jsme postupnì zpøesòovali pùvodní velmi hrubì naèrtnuté schéma interní
struktury bajtkódu a¾ na úroveò, která je zobrazená na konci této kapitoly.
V&nbsp;dne¹ním èlánku si popí¹eme poslední tøi èásti bajtkódu &ndash; seznam
datových polo¾ek (<i>fields</i>) deklarovaných pøímo ve tøídì èi
v&nbsp;rozhraní, jednotlivé metody (<i>methods</i>, opìt deklarované pøímo ve
tøídì) a koneènì dodateèné informace, které mohou být ke tøídì pøiøazeny. Jedná
se o takzvané atributy tøídy èi metadata, jejich¾ poèet se postupnì zvy¹uje
spoleènì s&nbsp;roz¹iøováním sémantiky programovacího jazyka Java.</p>

<p>Uvidíme, ¾e prakticky v¹echny dal¹í èásti bajtkódu jsou do znaèné míry
svázány s&nbsp;<i>constant poolem</i>, co¾ je ostatnì jeden z&nbsp;dùvodù, proè
byla popisu <i>constant poolu</i> vìnována celá <a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-2-cast-podrobnejsi-analyza-obsahu-constant-poolu/">devatenáctá
èást tohoto seriálu</a>. Ve¹keré nové informace, které si v&nbsp;následujících
kapitolách sdìlíme, budou samozøejmì zabudovány do demonstraèního dekompileru
bajtkódu:</p>

<pre>
+-----------------------------------------+
|   Hlavièka bajtkódu                     |
|                                         |
|  +-------------------------+---------+  |
|  | Magická konstanta       | 4 bajty |  |
|  +-------------------------+---------+  |
|  | Minoritní verze formátu | 2 bajty |  |
|  +-------------------------+---------+  |
|  | Majoritní verze formátu | 2 bajty |  |
|  +-------------------------+---------+  |
|                                         |
+-----------------------------------------+
|   Constant pool                         |
|                                         |
|  +-------------------------+---------+  |
|  | Poèet záznamù v poolu   | 2 bajty |  |
|  +-------------------------+---------+  |
|  | záznam #1               | x bajtù |  |
|  | záznam #2               | x bajtù |  |
|  | ...                     |         |  |
|  | záznam #n               | x bajtù |  |
|  +-------------------------+---------+  |
|                                         |
+-----------------------------------------+
|   Definice pøíznakù tøídy/rozhraní      |
|                                         |
|  +-------------------------+---------+  |
|  | Bitové pole s pøíznaky  | 2 bajty |  |
|  +-------------------------+---------+  |
|                                         |
+-----------------------------------------+
|   Jméno tøídy a nadtøídy                |
|                                         |
|  +-------------------------+---------+  |
|  | Index do constant poolu | 2 bajty |  |
|  +-------------------------+---------+  |
|  | Index do constant poolu | 2 bajty |  |
|  +-------------------------+---------+  |
|                                         |
+-----------------------------------------+
|   Implementovaná rozhraní               |
|                                         |
|  +-------------------------+---------+  |
|  | Poèet jmen rozhraní     | 2 bajty |  |
|  +-------------------------+---------+  |
|  | Index do const. poolu #1| 2 bajty |  |
|  | Index do const. poolu #2| 2 bajty |  |
|  | ...                     |         |  |
|  | Index do const. poolu #n| 2 bajty |  |
|  +-------------------------+---------+  |
|                                         |
+-----------------------------------------+
|   Datové polo¾ky deklarované ve tøídì   |
|   .....                                 |
|   .....                                 |
|   .....                                 |
+-----------------------------------------+
|   Kódy jednotlivých metod               |
|   .....                                 |
|   .....                                 |
|   .....                                 |
+-----------------------------------------+
|   Dal¹í metadata tøídy                  |
|   (atributy tøídy)                      |
|   .....                                 |
|   .....                                 |
|   .....                                 |
+-----------------------------------------+
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Struktura obsahující seznam datových polo¾ek deklarovaných ve tøídì èi rozhraní</h2>

<p>S&nbsp;vyu¾itím znalosti v¹ech struktur bajtkódu uvedených
v&nbsp;pøedchozích tøech èástech tohoto seriálu lze snadno získat základní
informace o tøídì (<i>class</i>), rozhraní (<i>interface</i>) èi o výètovém
typu (<i>enumeration</i>), který je v&nbsp;bajtkódu ulo¾en. Pøeèíst lze jméno
tøídy (popø.&nbsp;i jméno balíèku, do nìho¾ tøída nále¾í), jméno nadtøídy,
pøístupová práva zadaná programátorem (<i>public</i> atd.) i seznam v¹ech
rozhraní, která jsou tøídou implementována. Ov¹em ve skuteènosti nám
k&nbsp;úplné znalosti celé struktury tøídy chybí to hlavní &ndash; informace o
datových polo¾kách (<i>fields</i>) a takté¾ o metodách (<i>methods</i>).
Nejdøíve si øekneme, jakým zpùsobem jsou v&nbsp;bajtkódu ulo¾eny datové
polo¾ky, proto¾e informace o nich se nachází v&nbsp;sekci umístìné ihned za
sekcí se seznamem implementovaných rozhraní. Zaèátek sekce s&nbsp;datovými
polo¾kami je snadno pochopitelný &ndash; ve dvou bajtech je zde ulo¾en celkový
poèet datových polo¾ek deklarovaných <i>pøímo v&nbsp;dané tøídì</i>. Jinými
slovy to znamená, ¾e implicitnì zdìdìné datové polo¾ky v&nbsp;této sekci
bajtkódu nenalezneme.</p>

<p>Uka¾me si tuto vlastnost na jednoduchém pøíkladu trojice tøíd
<strong>A</strong>, <strong>B</strong> a <strong>C</strong>, mezi nimi¾
existuje vztah prapøedek&rarr;pøedek&rarr;potomek:</p>

<pre>
class A {
    int x;
}
</pre>

<pre>
class B extends A {
    int y;
}
</pre>

<pre>
class C extends B {
    int z;
}
</pre>

<p>Po pøekladu vznikne trojice souborù <strong>.class</strong>, pøièem¾ bajtkód
ulo¾ený v&nbsp;souboru <strong>A.class</strong> bude obsahovat informaci pouze
o datové polo¾ce <strong>x</strong>, soubor <strong>B.class</strong> informaci
pouze o datové polo¾ce <strong>y</strong> a koneènì soubor
<strong>C.class</strong> bude obsahovat &ndash; jak ji¾ urèitì víte &ndash;
informaci o datové polo¾ce <strong>z</strong>, i kdy¾ ve skuteènosti jsou
v&nbsp;této tøídì dostupné i zbylé dvì datové polo¾ky.</p>

<p>Vra»me se v¹ak zpìt k&nbsp;popisu struktury informací o datových polo¾kách
ulo¾ených v&nbsp;bajtkódu. Po ji¾ zmínìném poètu v¹ech deklarovaných datových
polo¾ek je v&nbsp;bajtkódu ulo¾en jejich seznam. Ka¾dá datová polo¾ka je
reprezentována záznamem s&nbsp;promìnnou délkou. Na zaèátku ka¾dého záznamu je
ve dvou bajtech ulo¾eno bitové pole s&nbsp;pøíznaky, které urèují vlastnosti
datové polo¾ky. Jednotlivé pøíznaky budou popsány <a
href="#k03">v&nbsp;následující kapitole</a>. Ihned za bitovým polem je
v&nbsp;bajtkódu ulo¾ena opìt dvoubajtová hodnota, v&nbsp;ní¾ je umístìn odkaz
na záznam typu <i>CONSTANT_Utf8</i> z&nbsp;<i>constant poolu</i>. Tento øetìzec
obsahuje jméno datové polo¾ky. Dal¹ím údajem je opìt dvoubajtová hodnota
pøedstavující (opìt) odkaz na záznam typu <i>CONSTANT_Utf8</i> &ndash;
tentokrát se jedná o øetìzec obsahující deskriptor, tj.&nbsp;øetìzec,
v&nbsp;nìm¾ je zakódován datový typ polo¾ky (formát øetìzce s&nbsp;datovým
typem jsme si ji¾ popsali <a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-2-cast-podrobnejsi-analyza-obsahu-constant-poolu/">v&nbsp;devatenácté
èásti</a> tohoto seriálu). Dal¹í èástí záznamu o datové polo¾ce je poèet
takzvaných <i>atributù</i>. Za tímto záznamem následuje seznam v¹ech atributù
popsaný podrobnìji <a href="#k04">ve ètvrté kapitole</a>.</p>

<p>Struktura se záznamem o jedné datové polo¾ce tedy vypadá následovnì:</p>

<table>
<tr><th>#</th><th>Název slo¾ky</th><th>Datový typ</th><th>Význam</th></tr>
<tr><td>1</td><td>access_flags</td><td>uint16</td><td>bitové pøíznaky urèující vlastnosti datové polo¾ky</td></tr>
<tr><td>2</td><td>name_index</td><td>uint16</td><td>jméno, odkaz do <i>constant_poolu</i> na záznam typu <i>CONSTANT_Utf8</i></td></tr>
<tr><td>3</td><td>descriptor_index</td><td>uint16</td><td>deskriptor, odkaz do <i>constant poolu</i> na záznam typu <i>CONSTANT_Utf8</i></td></tr>
<tr><td>4</td><td>attributes_count</td><td>uint16</td><td>celkový poèet atributù pøiøazených k datové polo¾ce</td></tr>
<tr><td>5</td><td>attributes</td><td>attribute_info[]</td><td>pole, jeho¾ prvky jsou struktury typu attribute_info</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Bitové pøíznaky urèující vlastnosti datové polo¾ky</h2>

<p><a href="#k02">V&nbsp;pøedchozí kapitole</a> jsme si øekli, ¾e na zaèátku
ka¾dého záznamu s&nbsp;informacemi o datové polo¾ce se nachází bitové pole o
velikosti 16 bitù, tj.&nbsp;dva bajty (ty jsou samozøejmì ulo¾eny v&nbsp;poøadí
<i>big endian</i>, podobnì jako v¹echny dal¹í vícebajtové hodnoty
v&nbsp;bajtkódu). V&nbsp;tomto bitovém poli jsou ulo¾ena pøístupová práva
k&nbsp;datové polo¾ce (<i>public</i>, <i>private</i>, <i>protected</i>, kdy¾
není nastavena ¾ádná z&nbsp;tìchto masek, tak se jedná o <i>package
protected</i>), dále pak pøíznak toho, zda je datová polo¾ka statická
(tj.&nbsp;zda nále¾í ke tøídì, nikoli k&nbsp;její instanci), finální
(konstanta), volatilní (pøístup k&nbsp;ní je obecnì asynchronní, mù¾e k&nbsp;ní
napøíklad pøistupovat více vláken), zda se jedná o prvek výètového typu atd.
V¹echny bitové masky, které mohou být u datové polo¾ky nastaveny, jsou uvedeny
v&nbsp;následující tabulce. Dùle¾ité je, ¾e se poèet bitových masek
s&nbsp;postupným vývojem syntaxe a sémantiky Javy roz¹iøoval, co¾ se týká
pøedev¹ím posledních dvou masek <strong>ACC_SYNTHETIC</strong> a
<strong>ACC_ENUM</strong>:</p>

<table>
<tr><th>#</th><th>Název masky  </th><th>Hodnota</th><th>Význam, pokud je maska nastavena</th></tr>
<tr><td>1</td><td>ACC_PUBLIC   </td><td>0x0001 </td><td>veøejná datová polo¾ka dostupná vnì tøídy i vnì balíèku</td></tr>
<tr><td>2</td><td>ACC_PRIVATE  </td><td>0x0002 </td><td>privátní datová polo¾ka dostupná pouze uvnitø tøídy</td></tr>
<tr><td>3</td><td>ACC_PROTECTED</td><td>0x0004 </td><td>chránìná datová polo¾ka dostupná uvnitø tøídy, z pøípadných odvozených tøíd i v rámci celého balíèku</td></tr>
<tr><td>4</td><td>ACC_STATIC   </td><td>0x0008 </td><td>statická datová polo¾ka, mù¾e se kombinovat s pøedchozí trojicí pøíznakù</td></tr>
<tr><td>5</td><td>ACC_FINAL    </td><td>0x0010 </td><td>finální datová polo¾ka</td></tr>
<tr><td>6</td><td>ACC_VOLATILE </td><td>0x0040 </td><td>pøíznak volatile - hodnota se v¾dy pøeète èi zapí¹e do pamìti (nezùstane ulo¾ena pouze v registrech)</td></tr>
<tr><td>7</td><td>ACC_TRANSIENT</td><td>0x0080 </td><td>pøíznak transient - nebude se zpracovávat pøi (de)serializaci objektu</td></tr>
<tr><td>8</td><td>ACC_SYNTHETIC</td><td>0x1000 </td><td>syntetická datová polo¾ka, která nemá svùj protìj¹ek ve zdrojovém kódu (je generována pøekladaèem)</td></tr>
<tr><td>9</td><td>ACC_ENUM     </td><td>0x4000 </td><td>jedná se o prvek výètového typu</td></tr>
</table>

<p>Ji¾ ze samotné specifikace programovacího jazyka Java vyplývá, ¾e ne v¹echny
kombinace bitových pøíznakù je mo¾né pou¾ít souèasnì. Nìkterá omezení jsou
vypsána v&nbsp;dal¹í tabulce. Jedno z&nbsp;omezení se týká tìch bitových
pøíznakù, které není mo¾né pou¾ít v&nbsp;pøípadì datových polo¾ek rozhraní
(<i>interface</i>), dále pak nelze libovolnì kombinovat první tøi pøíznaky (co¾
je pochopitelné) a takté¾ není mo¾né souèasnì pou¾ít pøíznaky
<strong>ACC_FINAL</strong> a <strong>ACC_VOLATILE</strong> (co¾ je opìt
pochopitelné, nebo» u konstant nehrozí mo¾nost, ¾e by se mohly asynchronnì
zmìnit v&nbsp;jiném vláknu):</p>

<table>
<tr><th>#</th><th>Název masky  </th><th>Class</th><th>Interface</th><th>Nelze kombinovat s...</th><th>Poznámka</th></tr>
<tr><td>1</td><td>ACC_PUBLIC   </td><td>ano</td><td>ano</td><td>ACC_PRIVATE, ACC_PROTECTED</td><td>musí být pou¾it pro atributy rozhraní</td></tr>
<tr><td>2</td><td>ACC_PRIVATE  </td><td>ano</td><td>ne </td><td>ACC_PUBLIC, ACC_PROTECTED</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>ACC_PROTECTED</td><td>ano</td><td>ne </td><td>ACC_PUBLIC, ACC_PRIVATE</td><td>&nbsp;</td></tr>
<tr><td>4</td><td>ACC_STATIC   </td><td>ano</td><td>ano</td><td>&times;</td><td>musí být pou¾it pro atributy rozhraní</td></tr>
<tr><td>5</td><td>ACC_FINAL    </td><td>ano</td><td>ano</td><td>ACC_VOLATILE</td><td>musí být pou¾it pro atributy rozhraní</td></tr>
<tr><td>6</td><td>ACC_VOLATILE </td><td>ano</td><td>ne </td><td>ACC_FINAL</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>ACC_TRANSIENT</td><td>ano</td><td>ne </td><td>&times;</td><td>&nbsp;</td></tr>
<tr><td>8</td><td>ACC_SYNTHETIC</td><td>ano</td><td>ano</td><td>&times;</td><td>&nbsp;</td></tr>
<tr><td>9</td><td>ACC_ENUM     </td><td>ano</td><td>ne </td><td>&times;</td><td>pou¾it pouze u výètu</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Atributy pøiøazené k&nbsp;datové polo¾ce</h2>

<p>Ke ka¾dé datové polo¾ce mù¾e být pøiøazen libovolný poèet atributù, které
umo¾òují ulo¾ení dal¹ích informací o této datové polo¾ce, resp.&nbsp;o jejích
vlastnostech. Poèet atributù je libovolný, samozøejmì mù¾e být i nulový (to se
ostatnì týká vìt¹iny nefinálních datových polo¾ek, kterým ¾ádný atribut nebývá
pøiøazen). Ka¾dý atribut se obecnì skládá z&nbsp;dvojice obsahující jméno
atributu a jeho hodnotu. Jméno atributu je zadáno nepøímo jako odkaz do
<i>constant poolu</i>, proto¾e se v&nbsp;mnoha pøípadech mù¾eme setkat
s&nbsp;tím, ¾e shodný atribut je pou¾it u vìt¹ího mno¾ství datových polo¾ek
(jedná se napøíklad o atribut se jménem <strong>ConstantValue</strong>)
odkazující na konstantu v&nbsp;poolu. Následující tabulka obsahuje jména a
struèný popis atributù popsaných pøímo ve specifikaci virtuálního stroje
Javy:</p>

<table>
<tr><th> #</th><th>Jméno atributu</th><th>Význam</th></tr>
<tr><td> 1</td><td>ConstantValue</td><td>odkaz na konstantu u finální datové polo¾ky</td></tr>
<tr><td> 2</td><td>Code</td><td>instrukce tvoøící tìlo metody</td></tr>
<tr><td> 3</td><td>Exceptions</td><td>informace o výjimkách, které mù¾e metoda vyhazovat</td></tr>
<tr><td> 4</td><td>InnerClasses</td><td>informace o vnitøních tøídách (jedná se o atribut tøídy)</td></tr>
<tr><td> 5</td><td>EnclosingMethod</td><td>informace uvádìná u vnitøních a anonymních tøíd</td></tr>
<tr><td> 6</td><td>Synthetic</td><td>atribut bez hodnoty (délka=0) uvádìný u syntetických tøíd, metod èi datových polo¾ek</td></tr>
<tr><td> 7</td><td>Signature</td><td>atribut obsahující odkaz na signaturu tøídy, metody èi datové polo¾ky</td></tr>
<tr><td> 8</td><td>SourceFile</td><td>atribut obsahující odkaz na jméno zdrojového souboru (ulo¾ené v&nbsp;constant poolu)</td></tr>
<tr><td> 9</td><td>LineNumberTable</td><td>atribut obsahující pole s&nbsp;mapováním mezi instrukcemi metody a odpovídajícím zdrojovým øádkem</td></tr>
<tr><td>10</td><td>LocalVariableTable</td><td>atribut obsahující ladicí informace o lokálních promìnných</td></tr>
<tr><td>11</td><td>LocalVariableTypeTable</td><td>atribut obsahující ladicí informace o typech lokálních promìnných</td></tr>
<tr><td>11</td><td>Deprecated</td><td>atribut bez hodnoty (délka=0) uvádìný u tøíd, metod a datových polo¾ek s&nbsp;anotací @Deprecated</td></tr>
</table>

<p>Zdaleka ne v¹echny tyto atributy v¹ak mohou být pøiøazeny k&nbsp;datovým
polo¾kám, proto¾e mnohé z&nbsp;tìchto atributù jsou pou¾ity zejména u metod a
nìkteré dal¹í i u tøíd.</p>

<p>Hodnota atributu je v&nbsp;bajtkódu obecnì zapsána formou øetìzce
v&nbsp;UTF-8. Pøed øetìzcem je ve ètveøici bajtù zapsána jeho délka a øetìzec
NEní ukonèený nulou (jak by tomu bylo u bì¾ných céèkovských øetìzcù). Vzhledem
k&nbsp;tomu, ¾e délka udává délku øetìzce v&nbsp;bajtech a ne ve znacích, je
mo¾né, aby virtuální stroj jazyka Java jednodu¹e celý øetìzec pøeskoèil
v&nbsp;pøípadì, ¾e daný atribut nedoká¾e zpracovat (i toto chování je ve
specifikaci povoleno). V&nbsp;následující tabulce je pro pøehled uveden formát
ulo¾ení jednoho atributu. Pokud je k&nbsp;datové polo¾ce pøidáno vìt¹í mno¾ství
atributù, jsou jednodu¹e ulo¾eny za sebou bez jakýchkoli oddìlovaèù. Hodnoty
nìkterých typù atributù, napøíklad ji¾ zmínìného atributu
<strong>ConstantValue</strong>, mají speciální význam a nezpracovávají se jako
øetìzec, ale napøíklad jako dvoubajtový index do <i>constant poolu</i>
(v&nbsp;nìm¾ jsou ulo¾eny, jak ji¾ víme z&nbsp;pøedchozích dílù tohoto seriálu,
takté¾ celoèíselné i reálné konstanty):</p>

<table>
<tr><th>#</th><th>Název slo¾ky</th><th>Datový typ</th><th>Význam</th></tr>
<tr><td>1</td><td>attribute_name_index</td><td>uint16</td><td>odkaz do <i>constant_poolu</i> na záznam typu <i>CONSTANT_Utf8</i></td></tr>
<tr><td>2</td><td>attribute_length</td><td>uint32</td><td>délka øetìzce uvedená v bajtech (ne ve znacích!)</td></tr>
<tr><td>3</td><td>info</td><td>char[]</td><td>øetìzec (NEukonèený nulou) obsahující text atributu</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. Demonstraèní pøíklad &ndash; výpis pøíznakù, deskriptorù a atributù rùzných typù datových polo¾ek</h2>

<p>Podívejme se nyní na jednoduchý demonstraèní pøíklad s&nbsp;tøídou
obsahující dvanáct datových polo¾ek typu <i>int</i>. Polo¾ky mají nastavenou
rùznou oblast viditelnosti (<i>public</i>, <i>protected</i>, <i>private</i>,
implicitní oblast viditelnosti) i dal¹í modifikátory (<i>static</i>,
<i>final</i>...). Navíc je u dvou polo¾ek pou¾ita anotace: u polo¾ky
<strong>i11</strong> se jedná o anotaci <strong>@Deprecated</strong>, která
zùstane zachována i v&nbsp;bajtkódu (mimo jiné i proto, ¾e má deklarováno
<strong>@Retention(value=RUNTIME)</strong>), zatímco polo¾ka
<strong>i12</strong> má pøiøazenu anotaci <strong>@SuppressWarning</strong>,
která je vyu¾ita pouze pøekladaèem a v&nbsp;bajtkódu se neobjeví (deklarace
<strong>@Retention(value=SOURCE)</strong>):</p>

<pre>
public class FieldTest {
    public int           i1;
    protected int        i2;
    private int          i3;
    int                  i4;
    final int            i5 = 6502;
    static int           i6;
    static final int     i7 = 42;
    transient int        i8;
    volatile int         i9;
    public transient int i10 = 0;
    @Deprecated
    int                  i11;
    @SuppressWarnings("foo")
    int                  i12;
}
</pre>

<p>Seznam v¹ech deklarovaných datových polo¾ek získaných pøímo z&nbsp;bajtkódu
vypadá následovnì:</p>

<pre>
Number of declared fields: 12
  Field name:  'i1'
  Descriptor:  I
    Field flags: 0x0001
    ACC_PUBLIC
  Attributes:  0
&nbsp;
  Field name:  'i2'
  Descriptor:  I
    Field flags: 0x0004
    ACC_PROTECTED
  Attributes:  0
&nbsp;
  Field name:  'i3'
  Descriptor:  I
    Field flags: 0x0002
    ACC_PRIVATE
  Attributes:  0
&nbsp;
  Field name:  'i4'
  Descriptor:  I
    Field flags: 0x0000
  Attributes:  0
&nbsp;
  Field name:  'i5'
  Descriptor:  I
    Field flags: 0x0010
    ACC_FINAL
  Attributes:  1
    Name:  'ConstantValue'
    Value: binarni hodnota (ne retezec)
&nbsp;
  Field name:  'i6'
  Descriptor:  I
    Field flags: 0x0008
    ACC_STATIC
  Attributes:  0
&nbsp;
  Field name:  'i7'
  Descriptor:  I
    Field flags: 0x0018
    ACC_STATIC
    ACC_FINAL
  Attributes:  1
    Name:  'ConstantValue'
    Value: binarni hodnota (ne retezec)
&nbsp;
  Field name:  'i8'
  Descriptor:  I
    Field flags: 0x0080
    ACC_TRANSIENT
  Attributes:  0
&nbsp;
  Field name:  'i9'
  Descriptor:  I
    Field flags: 0x0040
    ACC_VOLATILE
  Attributes:  0
&nbsp;
  Field name:  'i10'
  Descriptor:  I
    Field flags: 0x0081
    ACC_PUBLIC
    ACC_TRANSIENT
  Attributes:  0
&nbsp;
  Field name:  'i11'
  Descriptor:  I
    Field flags: 0x0000
  Attributes:  2
    Name:  'Deprecated'
    Value: '' (nulova delka)
    Name:  'RuntimeVisibleAnnotations'
    Value: binarni hodnota (ne retezec)
&nbsp;
  Field name:  'i12'
  Descriptor:  I
    Field flags: 0x0000
  Attributes:  0
</pre>

<p>Zajímavý je takté¾ bajtkód, který vznikne pøekladem výètového typu:</p>

<pre>
public enum EnumTest {
    PRVNI,
    DRUHA,
    TRETI
}
</pre>

<p>Ve výsledném bajtkódu najdeme jak v¹echny tøi explicitnì zapsané datové
polo¾ky (které jsou samozøejmì statické a finální), tak i jednu polo¾ku
syntetickou, tj.&nbsp;polo¾ku vygenerovanou samotným pøekladaèem (význam
této polo¾ky je asi zøejmý pøi pohledu na dokumentaci k&nbsp;výètovému
typu):</p>

<pre>
Number of declared fields: 4
  Field name:  'PRVNI'
  Descriptor:  LEnumTest;
    Field flags: 0x4019
    ACC_PUBLIC
    ACC_STATIC
    ACC_FINAL
    ACC_ENUM
  Attributes:  0
&nbsp;
  Field name:  'DRUHA'
  Descriptor:  LEnumTest;
    Field flags: 0x4019
    ACC_PUBLIC
    ACC_STATIC
    ACC_FINAL
    ACC_ENUM
  Attributes:  0
&nbsp;
  Field name:  'TRETI'
  Descriptor:  LEnumTest;
    Field flags: 0x4019
    ACC_PUBLIC
    ACC_STATIC
    ACC_FINAL
    ACC_ENUM
  Attributes:  0
&nbsp;
  Field name:  '$VALUES'
  Descriptor:  [LEnumTest;
    Field flags: 0x101a
    ACC_PRIVATE
    ACC_STATIC
    ACC_FINAL
    ACC_SYNTHETIC
  Attributes:  0
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Struktura obsahující seznam v¹ech deklarovaných metod</h2>

<p>Po informacích o jednotlivých datových polo¾kách deklarovaných
v&nbsp;rozhraní èi ve tøídì se v&nbsp;bajtkódu nachází informace o jednotlivých
metodách. U ka¾dé metody mù¾eme zjistit její jméno, typ návratové hodnoty, typy
parametrù metody a takté¾ vlastní tìlo metody, které je slo¾eno
z&nbsp;instrukcí virtuálního stroje Javy. Nejprve je v&nbsp;bajtkódu ulo¾ena
dvoubajtová hodnota s&nbsp;poètem metod. Za touto hodnotou pak následují
záznamy s&nbsp;informacemi o jednotlivých metodách, které se v&nbsp;mnoha
ohledech podobají struktuøe záznamù s&nbsp;informacemi o datových polo¾kách.
Nejprve je pro ka¾dou metodu ulo¾ena dvoubajtová hodnota s&nbsp;bitovými
pøíznaky, následuje dvoubajtový index do <i>constant poolu</i>, který musí
ukazovat na jméno metody (záznam typu <i>CONSTANT_Utf8</i>). Tøetím údajem je
opìt dvoubajtový index do <i>constant poolu</i>, který obsahuje odkaz na
deskriptor metody. Z&nbsp;nìj se dá vyèíst návratový typ metody i datové typy
v¹ech jejích parametrù. Nakonec mù¾e záznam metody obsahovat libovolný poèet
atributù, z&nbsp;nich¾ nejdùle¾itìj¹í je atribut s&nbsp;názvem
<strong>Code</strong>, jeho¾ hodnotou jsou instrukce tvoøící tìlo metody
(instrukèním souborem se budeme podrobnìji zabývat pøí¹tì).</p>

<p>V&nbsp;následující tabulce je pro pøehlednost vypsána struktura záznamu
s&nbsp;informacemi o jedné metodì:</p>

<table>
<tr><th>#</th><th>Název slo¾ky</th><th>Datový typ</th><th>Význam</th></tr>
<tr><td>1 access_flags    </td><td>uint16</td><td>bitové pøíznaky urèující vlastnosti metody</td></tr>
<tr><td>2 name_index      </td><td>uint16</td><td>jméno, odkaz do <i>constant_poolu</i> na záznam typu <i>CONSTANT_Utf8</i></td></tr>
<tr><td>3 descriptor_index</td><td>uint16</td><td>deskriptor, odkaz do <i>constant poolu</i> na záznam typu <i>CONSTANT_Utf8</i></td></tr>
<tr><td>4 attributes_count</td><td>uint16</td><td>poèet atributù pøiøazených k metodì</td></tr>
<tr><td>5 attributes      </td><td>attribute_info[]</td><td>pole struktur attribute_info</td></tr>
</table>

<p>V&nbsp;pøedchozím odstavci jsme si øekli, ¾e záznam s&nbsp;informacemi o
metodì obsahuje, podobnì jako záznam s&nbsp;informacemi o datové polo¾ce,
dvoubajtovou hodnotu s&nbsp;bitovým polem, jeho¾ jednotlivé pøíznaky blí¾e
urèují napøíklad viditelnost metody, zda se jedná o statickou èi finální
metodu, zda byl pøi deklaraci metody pou¾it modifikátor
<strong>strictfp</strong> (aritmetika dle IEEE 754) atd. Nìkteré
z&nbsp;bitových pøíznakù mají stejná jména i hodnotu, jako pøíznaky pou¾ité u
tøíd a datových polo¾ek, dal¹í pøíznaky jsou odli¹né, co¾ je ostatnì patrné i
z&nbsp;následující tabulky:</p>

<table>
<tr><th> #</th><th>Název masky</th><th>Hodnota</th><th>Význam, pokud je maska nastavena</th></tr>
<tr><td> 1</td><td>ACC_PUBLIC</td><td>0x0001</td><td>veøejná metoda dostupná vnì tøídy i vnì balíèku</td></tr>
<tr><td> 2</td><td>ACC_PRIVATE</td><td>0x0002</td><td>privátní metoda dostupná pouze uvnitø tøídy</td></tr>
<tr><td> 3</td><td>ACC_PROTECTED</td><td>0x0004</td><td>chránìná metoda dostupná uvnitø tøídy a z pøípadných odvozených tøíd</td></tr>
<tr><td> 4</td><td>ACC_STATIC</td><td>0x0008</td><td>statická metoda</td></tr>
<tr><td> 5</td><td>ACC_FINAL</td><td>0x0010</td><td>finální metoda (nemù¾e být pøekryta v odvozené tøídì)</td></tr>
<tr><td> 6</td><td>ACC_SYNCHRONIZED</td><td>0x0020</td><td>volání metody je synchronizováno (pou¾ije se zámek)</td></tr>
<tr><td> 7</td><td>ACC_BRIDGE</td><td>0x0040</td><td>metoda generovaná pøekladaèem</td></tr>
<tr><td> 8</td><td>ACC_VARARGS</td><td>0x0080</td><td>metoda s variabilním poètem argumentù</td></tr>
<tr><td> 9</td><td>ACC_NATIVE</td><td>0x0100</td><td>nativní metoda, nemá bajtkód, proto¾e volá nativní binární kód</td></tr>
<tr><td>10</td><td>ACC_ABSTRACT</td><td>0x0400</td><td>abstraktní metoda, takté¾ nemá bajtkód</td></tr>
<tr><td>11</td><td>ACC_STRICT</td><td>0x0800</td><td>pou¾ito v pøípadì, ¾e se má pou¾ívat aritmetika dle IEEE 754</td></tr>
<tr><td>12</td><td>ACC_SYNTHETIC</td><td>0x1000</td><td>syntetická metoda, nemá svùj protìj¹ek ve zdrojovém kódu</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Roz¹íøení demonstraèního dekompileru o výpis seznamu datových polo¾ek a metod</h2>

<p>S&nbsp;informacemi uvedenými v&nbsp;pøedchozích kapitolách je ji¾ mo¾né
roz¹íøit demonstraèní dekompiler javovského bajtkódu. Roz¹íøit je nutné zejména
výèet obsahující v¹echny bitové konstanty (masky) pou¾ité v&nbsp;bajtkódu.
Pov¹imnìte si, ¾e nìkteré bitové masky mají stejnou hodnotu, co¾ v¹ak nevadí,
proto¾e nìkteré masky jsou pou¾ity jen u tøíd, jiné u datových polo¾ek a
zbývající u metod:</p>

<pre>
/*
 * Priznaky tridy, rozhrani ci datove polozky
 */
enum
{
    ACC_PUBLIC       = 0x0001,   /* verejna trida/rozhrani/datova polozka */
    ACC_PRIVATE      = 0x0002,   /* privatni datova polozka dostupna pouze uvnitr tridy */
    ACC_PROTECTED    = 0x0004,   /* chranena datova polozka dostupna uvnitr tridy a z pripadne odvozene tridy */
    ACC_STATIC       = 0x0008,   /* staticka datova polozka */
    ACC_FINAL        = 0x0010,   /* finalni trida ci datova polozka */
    ACC_SUPER        = 0x0020,   /* semantika instrukce invokespecial */
    ACC_VOLATILE     = 0x0040,   /* priznak volatile - hodnota se vzdy precte ci zapise do pameti */
    ACC_TRANSIENT    = 0x0080,   /* priznak transient - nebude se zpracovavat pri (de)serializaci */
    ACC_INTERFACE    = 0x0200,   /* rozliseni trida/rozhrani */
    ACC_ABSTRACT     = 0x0400,   /* abstraktni trida */
    ACC_SYNTHETIC    = 0x1000,   /* synteticka trida ci datova polozka, nema svuj protejsek ve zdrojovem kodu */
    ACC_ANNOTATION   = 0x2000,   /* anotace */
    ACC_ENUM         = 0x4000,   /* vycet */
&nbsp;
    /* cast platna pro metody, nikoli vsak pro datove polozky */
    ACC_SYNCHRONIZED = 0x0020,   /* volani metody je synchronizovano */
    ACC_BRIDGE       = 0x0040,   /* metoda generovana prekladacem */
    ACC_VARARGS      = 0x0080,   /* metoda s variabilnim poctem parametru */
    ACC_NATIVE       = 0x0100,   /* nativni metoda */
    ACC_STRICT       = 0x0800    /* pouzito v pripade, ze se ma pouzivat aritmetika dle IEEE 754 */
};
</pre>

<p>Stejným zpùsobem bylo nutné roz¹íøit i funkci pro výpis v¹ech pøíznakù. Ve
funkci se nyní pomocí tøetího parametru rozli¹uje, zda se mají vypisovat
pøíznaky pro metodu èi pøíznaky pro datovou polo¾ku nebo tøídu:</p>

<pre>
/*
 * Nacteni a vypis atributu tridy, rozhrani, datove polozky ci metody.
 */
void process_flags(const char *message, uint16_t flags, int ismethod)
{
    printf("\n%s: 0x%04x\n", message, flags);
&nbsp;
    if (flags &amp; ACC_PUBLIC)     puts("    ACC_PUBLIC");
    if (flags &amp; ACC_PRIVATE)    puts("    ACC_PRIVATE");
    if (flags &amp; ACC_PROTECTED)  puts("    ACC_PROTECTED");
    if (flags &amp; ACC_STATIC)     puts("    ACC_STATIC");
    if (flags &amp; ACC_FINAL)      puts("    ACC_FINAL");
    if (flags &amp; ACC_ABSTRACT)   puts("    ACC_ABSTRACT");
    if (flags &amp; ACC_SYNTHETIC)  puts("    ACC_SYNTHETIC");
    if (ismethod) /* cast platna jen pro metody */
    {
        if (flags &amp; ACC_SYNCHRONIZED) puts("    ACC_SYNCHRONIZED");
        if (flags &amp; ACC_BRIDGE)       puts("    ACC_BRIDGE");
        if (flags &amp; ACC_VARARGS)      puts("    ACC_VARARGS");
        if (flags &amp; ACC_NATIVE)       puts("    ACC_NATIVE");
        if (flags &amp; ACC_STRICT)       puts("    ACC_STRICT");
    }
    else /* cast platna jen pro tridy a/nebo datove polozky */
    {
        if (flags &amp; ACC_TRANSIENT)  puts("    ACC_TRANSIENT");
        if (flags &amp; ACC_INTERFACE)  puts("    ACC_INTERFACE");
        if (flags &amp; ACC_ANNOTATION) puts("    ACC_ANNOTATION");
        if (flags &amp; ACC_ENUM)       puts("    ACC_ENUM");
        if (flags &amp; ACC_SUPER)      puts("    ACC_SUPER");
        if (flags &amp; ACC_VOLATILE)   puts("    ACC_VOLATILE");
    }
}
</pre>

<p>Následuje nová funkce urèená pro výpis v¹ech deklarovaných datových
polo¾ek:</p>

<pre>
/*
 * Nacteni a vypis vsech deklarovanych datovych polozek
 */
void process_all_defined_fields(FILE *fin)
{
    int i;
    /* nacist pocet deklarovanych datovych polozek */
    uint16_t fields = read_two_bytes(fin);
&nbsp;
    printf("\nNumber of declared fields: %d\n", (int)fields);
&nbsp;
    /* vypis vsech datovych polozek */
    for (i = 0; i &lt; fields; i++)
    {
        /* nacist priznaky */
        uint16_t flags = read_two_bytes(fin);
        /* nacist index do constant poolu */
        uint16_t name_index = read_two_bytes(fin);
        /* nacist index do constant poolu */
        uint16_t descriptor_index = read_two_bytes(fin);
        /* nacist pocet atributu */
        uint16_t attributes_count = read_two_bytes(fin);
&nbsp;
        /* v cecku se indexuje od 0, v constant poolu od 1 */
        name_index--;
        descriptor_index--;
        printf("  Field name:  '%s'\n", pool_entries[name_index].string);
        printf("  Descriptor:  %s", pool_entries[descriptor_index].string);
        process_class_or_field_flags("    Field flags", flags);
        printf("  Attributes:  %d\n", attributes_count);
        if (attributes_count)
        {
            print_all_attributes(fin, attributes_count);
        }
        putchar('\n');
    }
}
</pre>

<p>Prakticky stejný tvar má i funkce pro výpis v¹ech deklarovaných metod:</p>

<pre>
/*
 * Nacteni a vypis vsech deklarovanych metod
 */
void process_all_defined_methods(FILE *fin)
{
    int i;
    /* nacist pocet deklarovanych metod */
    uint16_t methods = read_two_bytes(fin);
&nbsp;
    printf("\nNumber of declared methods: %d\n", (int)methods);
&nbsp;
    /* vypis vsech metod */
    for (i = 0; i &lt; methods; i++)
    {
        /* nacist priznaky */
        uint16_t flags = read_two_bytes(fin);
        /* nacist index do constant poolu */
        uint16_t name_index = read_two_bytes(fin);
        /* nacist index do constant poolu */
        uint16_t descriptor_index = read_two_bytes(fin);
        /* nacist pocet atributu */
        uint16_t attributes_count = read_two_bytes(fin);
&nbsp;
        /* v cecku se indexuje od 0, v constant poolu od 1 */
        name_index--;
        descriptor_index--;
        printf("  Method name:'%s'\n", pool_entries[name_index].string);
        printf("  Descriptor:  %s", pool_entries[descriptor_index].string);
        process_flags("    Field flags", flags, 1);
        printf("  Attributes:  %d\n", attributes_count);
        if (attributes_count)
        {
            print_all_attributes(fin, attributes_count);
        }
        putchar('\n');
    }
}
</pre>

<p>Poslední novou funkcí je funkce urèená pro výpis v¹ech atributù. Vzhledem
k&nbsp;tomu, ¾e nìkteré atributy obsahují jako svoji hodnotu binární data, je
hodnota ka¾dého atributu vypsána jako seznam hexadecimálních hodnot a nikoli ve
formì øetìzce:</p>

<pre>
/*
 * Vypis vsech atributu prirazenych k nejakemu objektu v bajtkodu
 */
void print_all_attributes(FILE *fin, int attributes_count)
{
    int i, j;
    for (i = 0; i &lt; attributes_count; i++)
    {
        /* nacist index do constant poolu */
        uint16_t name_index = read_two_bytes(fin);
        /* nacist delku retezce obsahujiciho hodnotu atributu */
        uint32_t length = read_four_bytes(fin);
&nbsp;
        /* v cecku se indexuje od 0, v constant poolu od 1 */
        name_index--;
        printf("    Name:  '%s'\n", pool_entries[name_index].string);
        printf("    Value: '");
        for (j = 0; j &lt; length; j++)
        {
            unsigned char c = read_byte(fin);
            printf(" %02x", c);
        }
        putchar('\'');
        putchar('\n');
    }
}
</pre>

<p>Zdrojový text tímto zpùsobem upraveného dekompileru souborù
<strong>.class</strong> mù¾ete nalézt <a href="">zde</a>, popø.&nbsp;si mù¾ete
prohlédnout i <a href="">zdrojový kód se zvýraznìnou syntaxí</a>.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Atributy pøiøazené ke tøídì nebo k&nbsp;rozhraní</h2>

<p>Poslední informací, kterou mù¾eme v&nbsp;bajtkódu nalézt, jsou atributy
pøiøazené pøímo ke tøídì. Ihned za seznamem metod (viz pøedchozí kapitoly)
následuje obligátní dvoubajtová hodnota urèující poèet atributù, které jsou ke
tøídì pøiøazeny a posléze ji¾ následuje seznam jednotlivých atributù &ndash;
odkaz na jméno atributu v&nbsp;<i>constant poolu</i>, délka hodnoty atributu a
koneènì vlastní hodnota atributu. V&nbsp;souèasnosti lze ke tøídám pøiøazovat
pouze nìkteré atributy, zejména atribut <strong>InnerClasses</strong>,
<strong>EnclosingMethod</strong> (pokud se jedná o vnitøní èi anonymní tøídu),
<strong>Synthetic</strong>, <strong>SourceFile</strong> (pro úèely ladìní),
<strong>Signature</strong> (zde lze napøíklad zakódovat informace o generikách)
a takté¾ atribut <strong>Deprecated</strong>, jeho¾ úèel je zøejmý (je získán
ze shodnì pojmenované anotace).</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>The JavaTM Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>FindBugs<br />
<a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a>
</li>

<li>GNU Classpath<br />
<a href="www.gnu.org/s/classpath/">www.gnu.org/s/classpath/</a></li>

<li>Java VMs Compared<br />
<a href="http://bugblogger.com/java-vms-compared-160/">http://bugblogger.com/java-vms-compared-160/</a>
</li>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a></li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>CloseableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

