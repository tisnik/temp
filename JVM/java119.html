<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - zpracování událostí v knihovnì SDLJava</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - zpracování událostí v knihovnì SDLJava</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Knihovna SDLJava obsahuje i mechanismus umo¾òující zpracování rùzných typù událostí, které mohou vzniknout napøíklad pøi stisku nìjaké klávesy èi pøi pohybu my¹i popø. joysticku. Celý mechanismus práce s událostmi je navr¾en takovým zpùsobem. aby byl pamì»ovì nenároèný, tj. aby zbyteènì nevznikaly nové objekty.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Dokonèení tématu z&nbsp;pøedchozí èásti seriálu: obrázky typu BufferedImage a texturování</a></p>
<p><a href="#k02">2. Parametry metody <strong>TextureFactory.loadTexture()</strong></a></p>
<p><a href="#k03">3. Demonstraèní pøíklad <strong>SDLTest26</strong> &ndash; pou¾ití obrázku typu BufferedImage pøi texturování</a></p>
<p><a href="#k04">4. Demonstraèní pøíklad <strong>SDLTest27</strong> &ndash; BufferedImage, texturování a alfa blending</a></p>
<p><a href="#k05">5. Zpracování událostí v&nbsp;knihovnì SDLJava</a></p>
<p><a href="#k06">6. Demonstraèní pøíklad <strong>SDLTest28</strong> &ndash; ètení událostí ve smyèce</a></p>
<p><a href="#k07">7. Demonstraèní pøíklad <strong>SDLTest29</strong> &ndash; reakce na událost typu <strong>SDLQuitEvent</strong></a></p>
<p><a href="#k08">8. Demonstraèní pøíklad <strong>SDLTest30</strong> &ndash; ètení informací o stisknutých a pu¹tìných klávesách</a></p>
<p><a href="#k09">9. Repositáø se zdrojovými kódy v¹ech pìti dne¹ních demonstraèních pøíkladù</a></p>
<p><a href="#k10">10. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Dokonèení tématu z&nbsp;pøedchozí èásti seriálu: obrázky typu BufferedImage a texturování</h2>

<p>V&nbsp;dne¹ní èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyce Java i o virtuálním stroji tohoto jazyka</a> se budeme
zabývat pøedev¹ím popisem zpracování událostí v&nbsp;knihovnì <i>SDLJava</i>.
Je¹tì pøedtím v¹ak musíme dokonèit téma, kterému jsme se vìnovali <a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-blending-a-textury-s-alfa-kanalem-v-knihovne-sdljava/">v&nbsp;poslední</a>
i <a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-prace-s-texturami-v-knihovne-sdljava/">pøedposlední
èásti</a> tohoto seriálu &ndash; texturování. Na nìkolika demonstraèních
pøíkladech jsme si ji¾ ukázali, jakým zpùsobem je mo¾né naèíst texturu
z&nbsp;externího souboru a jak se následnì tato textura navá¾e na kontext
<i>OpenGL</i>. Ov¹em v&nbsp;knihovnì <i>SDLJava</i> je mo¾né texturu, pøesnìji
øeèeno instanci tøídy <strong>Texture</strong> vytvoøit i z&nbsp;rastrového
obrázku typu <strong>BufferedImage</strong>. Tato funkcionalita se mù¾e hodit
zejména ve chvílích, kdy je obrázek nìjakým zpùsobem programovì generován,
tj.&nbsp;kdy¾ je napøíklad vytváøena procedurální textura. Základem pro
vytváøení èi naèítání textur je tøída
<strong>org.gljava.opengl.TextureFactory</strong>, která mj.&nbsp;nabízí i
následující metody urèené pro získání instance této tøídy a následnì pro
naètení textury:</p>

<table>
<tr><th>#</th><th>Návratový typ</th><th>Metoda</th><th>Popis</th></tr>
<tr><td>1</td><td>TextureFactory</td><td>getFactory()</td><td>získání instance tøídy TextureFactory</td></tr>
<tr><td>2</td><td>Texture</td><td>loadTexture(GL gl, java.lang.String path)</td><td>naètení textury ze souboru specifikovaného jménem</td></tr>
<tr><td>3</td><td>Texture</td><td>loadTexture(GL gl, java.net.URL url)</td><td>naètení textury ze souboru/zdroje specifikovaného URL</td></tr>
<tr><td>4</td><td>Texture</td><td>loadTexture(GL gl, java.awt.image.BufferedImage bufferedImage, int target, int dstPixelFormat, int minFilter, int magFilter)</td><td>naètení textury z&nbsp;obrázku typu BufferedImage</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Parametry metody <strong>TextureFactory.loadTexture()</strong></h2>

<p>Nás nyní bude zajímat pøedev¹ím poslední zmínìná metoda
<strong>TextureFactory.loadTexture(GL gl, java.awt.image.BufferedImage
bufferedImage, int target, int dstPixelFormat, int minFilter, int
magFilter)</strong>, které je mo¾né pøedat obrázek typu
<strong>BufferedImage</strong> a na základì dal¹ích informací se z&nbsp;tohoto
obrázku vytvoøí bì¾ná textura, tj.&nbsp;objekt typu <strong>Texture</strong>.
Význam parametrù této metody je následující:</p>

<table>
<tr><th>#</th><th>Parametr</th><th>Význam</th></tr>
<tr><td>1</td><td>GL gl                      </td><td>aktuální kontext OpenGL</td></tr>
<tr><td>2</td><td>BufferedImage bufferedImage</td><td>obrázek, který má být konvertován na texturu</td></tr>
<tr><td>3</td><td>int target                 </td><td>buï <strong>GL.GL_TEXTURE_1D</strong> nebo <strong>GL.GL_TEXTURE_2D</strong></td></tr>
<tr><td>4</td><td>int dstPixelFormat         </td><td>formát textury, typicky <strong>GL.GL_RGBA</strong> (viz té¾ pøedchozí èásti tohoto seriálu)</td></tr>
<tr><td>5</td><td>int minFilter              </td><td>filtr pou¾itý pøi zmen¹ování obrázku, typicky <strong>GL.GL_LINEAR</strong></td></tr>
<tr><td>6</td><td>int magFilter              </td><td>filtr pou¾itý pøi zvìt¹ování obrázku, typicky <strong>GL.GL_LINEAR</strong></td></tr>
</table>

<p>Parametr <strong>target</strong> mù¾e podle typu textury nabývat hodnot:</p>

<table>
<tr><th>#</th><th>Hodnota</th><th>Význam</th></tr>
<tr><td>1</td><td><strong>GL.GL_TEXTURE_1D</strong></td><td>jednorozmìrná textura</td></tr>
<tr><td>2</td><td><strong>GL.GL_TEXTURE_2D</strong></td><td>dvourozmìrná textura (mnohem èastìj¹í)</td></tr>
</table>

<p>Parametr <strong>dstPixelFormat</strong> urèuje interní formát výsledné
textury:</p>

<table>
<tr><th> #</th><th>Roz¹íøený formát</th><th>Základní formát</th></tr>
<tr><td> 1</td><td>GL_ALPHA4             </td><td>GL_ALPHA          </td></tr>
<tr><td> 2</td><td>GL_ALPHA8             </td><td>GL_ALPHA          </td></tr>
<tr><td> 3</td><td>GL_ALPHA12            </td><td>GL_ALPHA          </td></tr>
<tr><td> 4</td><td>GL_ALPHA16            </td><td>GL_ALPHA          </td></tr>
<tr><td> 5</td><td>GL_LUMINANCE4         </td><td>GL_LUMINANCE      </td></tr>
<tr><td> 6</td><td>GL_LUMINANCE8         </td><td>GL_LUMINANCE      </td></tr>
<tr><td> 7</td><td>GL_LUMINANCE12        </td><td>GL_LUMINANCE      </td></tr>
<tr><td> 8</td><td>GL_LUMINANCE16        </td><td>GL_LUMINANCE      </td></tr>
<tr><td> 9</td><td>GL_LUMINANCE4_ALPHA4  </td><td>GL_LUMINANCE_ALPHA</td></tr>
<tr><td>10</td><td>GL_LUMINANCE6_ALPHA2  </td><td>GL_LUMINANCE_ALPHA</td></tr>
<tr><td>11</td><td>GL_LUMINANCE8_ALPHA8  </td><td>GL_LUMINANCE_ALPHA</td></tr>
<tr><td>12</td><td>GL_LUMINANCE12_ALPHA4 </td><td>GL_LUMINANCE_ALPHA</td></tr>
<tr><td>13</td><td>GL_LUMINANCE12_ALPHA12</td><td>GL_LUMINANCE_ALPHA</td></tr>
<tr><td>14</td><td>GL_LUMINANCE16_ALPHA16</td><td>GL_LUMINANCE_ALPHA</td></tr>
<tr><td>15</td><td>GL_INTENSITY4         </td><td>GL_INTENSITY      </td></tr>
<tr><td>16</td><td>GL_INTENSITY8         </td><td>GL_INTENSITY      </td></tr>
<tr><td>17</td><td>GL_INTENSITY12        </td><td>GL_INTENSITY      </td></tr>
<tr><td>18</td><td>GL_INTENSITY16        </td><td>GL_INTENSITY      </td></tr>
<tr><td>19</td><td>GL_R3_G3_B2           </td><td>GL_RGB            </td></tr>
<tr><td>20</td><td>GL_RGB4               </td><td>GL_RGB            </td></tr>
<tr><td>21</td><td>GL_RGB5               </td><td>GL_RGB            </td></tr>
<tr><td>22</td><td>GL_RGB8               </td><td>GL_RGB            </td></tr>
<tr><td>23</td><td>GL_RGB10              </td><td>GL_RGB            </td></tr>
<tr><td>24</td><td>GL_RGB12              </td><td>GL_RGB            </td></tr>
<tr><td>25</td><td>GL_RGB16              </td><td>GL_RGB            </td></tr>
<tr><td>26</td><td>GL_RGBA2              </td><td>GL_RGBA           </td></tr>
<tr><td>27</td><td>GL_RGBA4              </td><td>GL_RGBA           </td></tr>
<tr><td>28</td><td>GL_RGB5_A1            </td><td>GL_RGBA           </td></tr>
<tr><td>29</td><td>GL_RGBA8              </td><td>GL_RGBA           </td></tr>
<tr><td>30</td><td>GL_RGB10_A2           </td><td>GL_RGBA           </td></tr>
<tr><td>31</td><td>GL_RGBA12             </td><td>GL_RGBA           </td></tr>
<tr><td>32</td><td>GL_RGBA16             </td><td>GL_RGBA           </td></tr>
</table>

<p>Hodnoty pøedávané v&nbsp;posledních dvou parametrech
<strong>minFilter</strong> a <strong>magFilter</strong> jsou specifikovány
tìmito konstantami:</p>

<table>
<tr><th>#</th><th>Hodnota</th><th>Význam</th></tr>
<tr><td>1</td><td><strong>GL.GL_NEAREST</strong></td><td>pøi zmìnì velikosti se pou¾ije nejbli¾¹í texel</td></tr>
<tr><td>2</td><td><strong>GL.GL_LINEAR </strong></td><td>pøi zmìnì velikosti se pou¾ije (bi)lineární interpolace</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Demonstraèní pøíklad <strong>SDLTest26</strong> &ndash; pou¾ití obrázku typu BufferedImage pøi texturování</h2>

<p>V&nbsp;dne¹ním prvním demonstraèním pøíkladu, který se jmenuje
<strong>SDLTest26</strong>, je ukázáno, jak je mo¾né vytvoøit texturu,
tj.&nbsp;instanci tøídy <strong>org.gljava.opengl.Texture</strong>
z&nbsp;rastrového obrázku (bitmapy) reprezentovaného objektem typu
<strong>java.awt.image.BufferedImage</strong>. Vlastní bitmapa je vytvoøena
v&nbsp;metodì <strong>createTexture()</strong>, pøièem¾ si v¹imnìte, ¾e formát
ulo¾ení pixelù v&nbsp;bitmapì mù¾e, ale nemusí pøesnì korespondovat
s&nbsp;formátem ulo¾ení pixelù ve výsledné textuøe. Následnì je bitmapa
v&nbsp;metodì <strong>renderImage()</strong> vyplnìna jednoduchým vzorkem a
poté je provedeno její pøevedení na texturu. Rozmìry textury samozøejmì nemusí
korespondovat s&nbsp;rozmìry reálného objektu, který je touto texturou
pokryt:</p>

<pre>
<i>/**</i>
<i> * Vytvoreni textury z obrazku typu BufferedImage.</i>
<i> */</i>
private static Texture <strong>createTexture</strong>(GL gl) throws IOException {
    <i>// rozmery textury</i>
    final int width = 256;
    final int height = 256;
&nbsp;
    <i>// vytvoreni rastroveho obrazku</i>
    BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_4BYTE_ABGR);
    renderImage(image);
&nbsp;
    <i>// ziskani instance typu TextureFactory</i>
    TextureFactory textureFactory = TextureFactory.getFactory();
&nbsp;
    <i>// vytvoreni textury z obrazku typu BufferedImage</i>
    return textureFactory.loadTexture(gl, image, GL.GL_TEXTURE_2D, GL.GL_RGBA, GL.GL_LINEAR, GL.GL_LINEAR);
}
</pre>

<p>Následuje výpis zdrojového kódu demonstraèního pøíkladu
<strong>SDLTest26</strong>:</p>

<pre>
import java.awt.image.BufferedImage;
import java.awt.image.WritableRaster;
import java.awt.image.DataBuffer;
import java.io.IOException;
&nbsp;
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.video.SDLPixelFormat;
import sdljava.video.SDLSurface;
import sdljava.video.SDLVideo;
&nbsp;
import org.gljava.opengl.GL;
import org.gljava.opengl.Texture;
import org.gljava.opengl.TextureFactory;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Dvacaty sesty demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> *</i>
<i> * Vytvoreni textury z obrazku typu BufferedImage.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>SDLTest26</strong> {
&nbsp;
    <i>/**</i>
    <i> * Horizontalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_WIDTH</strong> = 600;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_HEIGHT</strong> = 600;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka vybraneho grafickeho rezimu.</i>
    <i> * (0 znamena automaticky vyber, ovsem lze samozrejme pouzit</i>
    <i> * i hodnoty 8, 16, 24 ci 32, podle vlastnosti graficke karty)</i>
    <i> */</i>
    private static final int <strong>GFX_BPP</strong> = 0;
&nbsp;
    <i>/**</i>
    <i> * Inicializace grafickeho rezimu ci otevreni okna pro vykreslovani.</i>
    <i> */</i>
    private static SDLSurface <strong>initVideo</strong>() throws SDLException {
        final long flags = SDLVideo.SDL_OPENGL | SDLVideo.SDL_DOUBLEBUF;
        return SDLVideo.setVideoMode(GFX_WIDTH, GFX_HEIGHT, GFX_BPP, flags);
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni transformacnich matic a barvy pozadi framebufferu.</i>
    <i> */</i>
    private static void <strong>initScene</strong>(GL gl, int width, int height) {
        <i>// nastaveni projekcni matice</i>
        gl.glMatrixMode(gl.GL_PROJECTION);
&nbsp;
        <i>// jednotkova matice</i>
        gl.glLoadIdentity();
&nbsp;
        <i>// mapovani abstraktnich souradnic do souradnic okna ci cele obrazovky</i>
        gl.glOrtho(0, width, height, 0, -1, 1);
&nbsp;
        <i>// nastaveni modelview matice</i>
        gl.glMatrixMode(gl.GL_MODELVIEW);
        gl.glLoadIdentity();
&nbsp;
        <i>// viditelna oblast</i>
        gl.glViewport(0, 0, width, height);
&nbsp;
        <i>// vypnuti pameti hloubky pri vykreslovani</i>
        gl.glDisable(gl.GL_DEPTH_TEST);
&nbsp;
        <i>// zakaz opakovani textury</i>
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_WRAP_S, gl.GL_CLAMP);
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_WRAP_T, gl.GL_CLAMP);
&nbsp;
        <i>// volba filtru</i>
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MAG_FILTER, gl.GL_NEAREST);
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MIN_FILTER, gl.GL_NEAREST);
&nbsp;
        <i>// vylepseni zobrazovani v pripade pouziti perspektivni projekce</i>
        gl.glHint(gl.GL_PERSPECTIVE_CORRECTION_HINT, gl.GL_NICEST);
&nbsp;
        <i>// barva pozadi framebufferu pro volani glClear()</i>
        gl.glClearColor (0.0f, 0.0f, 0.0f, 0.0f);
    }
&nbsp;
    <i>/**</i>
    <i> * Vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL.</i>
    <i> */</i>
    private static void <strong>drawScene</strong>(GL gl, Texture texture) {
&nbsp;
        <i>// vymazani framebufferu</i>
        gl.glClear(GL.GL_COLOR_BUFFER_BIT);
&nbsp;
        <i>// zakaz prace s texturami</i>
        gl.glDisable(gl.GL_TEXTURE_2D);
&nbsp;
        gl.glBegin(GL.GL_LINES);
            gl.glColor3f(1.0f, 0.0f, 0.0f);
            gl.glVertex2i(0, 0);
            gl.glColor3f(1.0f, 0.0f, 1.0f);
            gl.glVertex2i(600, 600);
            gl.glColor3f(0.0f, 1.0f, 0.0f);
            gl.glVertex2i(600, 0);
            gl.glColor3f(1.0f, 1.0f, 0.0f);
            gl.glVertex2i(0, 600);
        gl.glEnd();
&nbsp;
        <i>// povoleni prace s texturami</i>
        gl.glEnable(GL.GL_TEXTURE_2D);
&nbsp;
        <i>// navazani textury na kontext OpenGL</i>
        texture.bind(gl);
&nbsp;
        <i>// vykresleni ctyruhelniku pokryteho texturou</i>
        gl.glBegin(GL.GL_QUADS);
            gl.glTexCoord2f(0.0f, 0.0f);
            gl.glVertex2i(100, 100);
            gl.glTexCoord2f(1.0f, 0.0f);
            gl.glVertex2i(500, 100);
            gl.glTexCoord2f(1.0f, 1.0f);
            gl.glVertex2i(500, 500);
            gl.glTexCoord2f(0.0f, 1.0f);
            gl.glVertex2i(100, 500);
        gl.glEnd();
&nbsp;
        gl.glFlush();                                        <i>// provedeni a vykresleni vsech zmen</i>
    }
&nbsp;
    <i>/**</i>
    <i> * Vytvoreni textury z obrazku typu BufferedImage.</i>
    <i> */</i>
    private static Texture <strong>createTexture</strong>(GL gl) throws IOException {
        <i>// rozmery textury</i>
        final int width = 256;
        final int height = 256;
&nbsp;
        <i>// vytvoreni rastroveho obrazku</i>
        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_4BYTE_ABGR);
        renderImage(image);
&nbsp;
        <i>// ziskani instance typu TextureFactory</i>
        TextureFactory textureFactory = TextureFactory.getFactory();
&nbsp;
        <i>// vytvoreni textury z obrazku typu BufferedImage</i>
        return textureFactory.loadTexture(gl, image, GL.GL_TEXTURE_2D, GL.GL_RGBA, GL.GL_LINEAR, GL.GL_LINEAR);
    }
&nbsp;
    <i>/**</i>
    <i> * Vytvoreni vzorku.</i>
    <i> */</i>
    private static void <strong>renderImage</strong>(BufferedImage image) {
        <i>// rozmery bitmapy</i>
        final int width = image.getWidth();
        final int height = image.getHeight();
&nbsp;
        <i>// ziskani objektu obsahujiciho hodnoty vsech pixelu bitmapy</i>
        DataBuffer dataBuffer = image.getRaster().getDataBuffer();
&nbsp;
        <i>// provest vypocet barev pixelu a jejich vykresleni</i>
        int i = 0;
        for (int y = 0; y &lt; height; y++) {
            for (int x = 0; x &lt; width; x++) {
                dataBuffer.setElem(i++, 0xff);
                dataBuffer.setElem(i++, 0xff);
                dataBuffer.setElem(i++, y);
                dataBuffer.setElem(i++, x);
            }
        }
        System.out.println("Written " + i + " bytes into DataBuffer"); 
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni osmeho demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace video subsystemu knihovny SDL</i>
            SDLMain.init(SDLMain.SDL_INIT_VIDEO);
&nbsp;
            <i>// inicializace grafickeho rezimu ci otevreni okna pro vykreslovani</i>
            SDLSurface screen = initVideo();
&nbsp;
            <i>// inicializace celoobrazovkoveho grafickeho rezimu</i>
            GL gl = screen.getGL();
&nbsp;
            <i>// nastaveni transformacnich matic a barvy pozadi framebufferu</i>
            initScene(gl, GFX_WIDTH, GFX_HEIGHT);
&nbsp;
            <i>// vytvoreni textury z obrazku typu BufferedImage</i>
            Texture texture = createTexture(gl);
&nbsp;
            <i>// vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL</i>
            drawScene(gl, texture);
&nbsp;
            <i>// prepnuti predniho a zadniho bufferu</i>
            screen.glSwapBuffers();
&nbsp;
            <i>// ukonceni cele aplikace po peti sekundach</i>
            Thread.sleep(5000);
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
        <i>// zobrazit ziskane informace</i>
    }
&nbsp;
}
</pre>

<p>Skript pro pøeklad na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest26.java
</pre>

<p>Dávkový soubor pro pøeklad na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest26.java
</pre>

<p>Skript pro spu¹tìní na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
java -cp .:$SDL_JAVA_LIBS/sdljava.jar -Djava.library.path=$SDL_JAVA_LIBS SDLTest26
</pre>

<p>Dávkový soubor pro spu¹tìní na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest26
</pre>

<a href="http://i.iinfo.cz/images/362/119-1.png"><img src="http://i.iinfo.cz/images/362/119-1-prev.png" class="image-163225" width="270" height="270" alt="&#160;" /></a>
<p><i>Obrázek 1: Scéna vykreslená po spu¹tìní demonstraèního pøíkladu
<strong>SDLTest26</strong>.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Demonstraèní pøíklad <strong>SDLTest27</strong> &ndash; BufferedImage, texturování a alfa blending</h2>

<p>V&nbsp;pøedchozí èásti tohoto seriálu jsme si ukázali, ¾e v&nbsp;pøípadì
pou¾ití rastrového obrázku ulo¾eného v&nbsp;souboru typu <strong>PNG</strong>
je mo¾né pro vytvoøení textury v&nbsp;plné míøe vyu¾ít informace o prùhlednosti
jednotlivých pixelù ulo¾ených v&nbsp;alfa kanále (jedná se o volitelný kanál).
Stejným zpùsobem je v¹ak mo¾né pracovat s&nbsp;prùhledností ve chvíli, kdy se
textura vytváøí z&nbsp;bitmapy typu <strong>BufferedImage</strong>, co¾ je
ukázáno v&nbsp;dne¹ním druhém demonstraèním pøíkladu. Nejzajímavìj¹í je zde
metoda <strong>drawScene()</strong>, z&nbsp;ní¾ je patrné, ¾e se nejdøíve
vykreslí pozadí slo¾ené z&nbsp;møí¾ky (alfa blending je vypnutý) a posléze se
pøes toho pozadí vykreslí poloprùhledná textura (nyní ji¾ se zapnutým alfa
blendingem):</p>

<pre>
<i>/**</i>
<i> * Vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL.</i>
<i> */</i>
private static void <strong>drawScene</strong>(GL gl, Texture texture) {
    <i>// vymazani framebufferu (bile pozadi)</i>
    gl.glClear(GL.GL_COLOR_BUFFER_BIT);
&nbsp;
    <i>// zakaz prace s texturami</i>
    gl.glDisable(gl.GL_TEXTURE_2D);
&nbsp;
    <i>// zakaz blendingu</i>
    gl.glDisable(GL.GL_BLEND);
&nbsp;
    <i>// vykresleni mrizky</i>
    gl.glColor3f(0.0f, 0.0f, 0.0f);
    gl.glBegin(GL.GL_LINES);
    for (int i=0; i &lt; GFX_WIDTH; i+=20) {
        gl.glVertex2i(i, 0);
        gl.glVertex2i(i, GFX_HEIGHT);
    }
    for (int i=0; i &lt; GFX_HEIGHT; i+=20) {
        gl.glVertex2i(0, i);
        gl.glVertex2i(GFX_WIDTH, i);
    }
    gl.glEnd();
&nbsp;
    <i>// povoleni prace s texturami</i>
    gl.glEnable(GL.GL_TEXTURE_2D);
&nbsp;
    <i>// povoleni a nastaveni blendingu</i>
    gl.glEnable(GL.GL_BLEND);
    gl.glBlendFunc(GL.GL_SRC_ALPHA, GL.GL_ONE_MINUS_SRC_ALPHA);
&nbsp;
    <i>// navazani textury na kontext OpenGL</i>
    texture.bind(gl);
&nbsp;
    <i>// vykresleni ctyruhelniku pokryteho texturou</i>
    gl.glBegin(GL.GL_QUADS);
        gl.glTexCoord2f(0.0f, 0.0f);
        gl.glVertex2i(100, 100);
        gl.glTexCoord2f(1.0f, 0.0f);
        gl.glVertex2i(500, 100);
        gl.glTexCoord2f(1.0f, 1.0f);
        gl.glVertex2i(500, 500);
        gl.glTexCoord2f(0.0f, 1.0f);
        gl.glVertex2i(100, 500);
    gl.glEnd();
&nbsp;
    gl.glFlush();                                        <i>// provedeni a vykresleni vsech zmen</i>
}
</pre>

<p>Opìt následuje výpis úplného zdrojového kódu tohoto demonstraèního
pøíkladu:</p>

<pre>
import java.awt.image.BufferedImage;
import java.awt.image.WritableRaster;
import java.awt.image.DataBuffer;
import java.io.IOException;
&nbsp;
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.video.SDLPixelFormat;
import sdljava.video.SDLSurface;
import sdljava.video.SDLVideo;
&nbsp;
import org.gljava.opengl.GL;
import org.gljava.opengl.Texture;
import org.gljava.opengl.TextureFactory;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Dvacaty sedmy demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> *</i>
<i> * Vytvoreni textury z obrazku typu BufferedImage.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>SDLTest27</strong> {
&nbsp;
    <i>/**</i>
    <i> * Horizontalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_WIDTH</strong> = 600;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_HEIGHT</strong> = 600;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka vybraneho grafickeho rezimu.</i>
    <i> * (0 znamena automaticky vyber, ovsem lze samozrejme pouzit</i>
    <i> * i hodnoty 8, 16, 24 ci 32, podle vlastnosti graficke karty)</i>
    <i> */</i>
    private static final int <strong>GFX_BPP</strong> = 0;
&nbsp;
    <i>/**</i>
    <i> * Inicializace grafickeho rezimu ci otevreni okna pro vykreslovani.</i>
    <i> */</i>
    private static SDLSurface <strong>initVideo</strong>() throws SDLException {
        final long flags = SDLVideo.SDL_OPENGL | SDLVideo.SDL_DOUBLEBUF;
        return SDLVideo.setVideoMode(GFX_WIDTH, GFX_HEIGHT, GFX_BPP, flags);
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni transformacnich matic a barvy pozadi framebufferu.</i>
    <i> */</i>
    private static void <strong>initScene</strong>(GL gl, int width, int height) {
        <i>// nastaveni projekcni matice</i>
        gl.glMatrixMode(gl.GL_PROJECTION);
&nbsp;
        <i>// jednotkova matice</i>
        gl.glLoadIdentity();
&nbsp;
        <i>// mapovani abstraktnich souradnic do souradnic okna ci cele obrazovky</i>
        gl.glOrtho(0, width, height, 0, -1, 1);
&nbsp;
        <i>// nastaveni modelview matice</i>
        gl.glMatrixMode(gl.GL_MODELVIEW);
        gl.glLoadIdentity();
&nbsp;
        <i>// viditelna oblast</i>
        gl.glViewport(0, 0, width, height);
&nbsp;
        <i>// vypnuti pameti hloubky pri vykreslovani</i>
        gl.glDisable(gl.GL_DEPTH_TEST);
&nbsp;
        <i>// zakaz opakovani textury</i>
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_WRAP_S, gl.GL_CLAMP);
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_WRAP_T, gl.GL_CLAMP);
&nbsp;
        <i>// volba filtru</i>
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MAG_FILTER, gl.GL_NEAREST);
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MIN_FILTER, gl.GL_NEAREST);
&nbsp;
        <i>// vylepseni zobrazovani v pripade pouziti perspektivni projekce</i>
        gl.glHint(gl.GL_PERSPECTIVE_CORRECTION_HINT, gl.GL_NICEST);
&nbsp;
        <i>// barva pozadi framebufferu pro volani glClear()</i>
        gl.glClearColor (1.0f, 1.0f, 1.0f, 0.0f);
    }
&nbsp;
    <i>/**</i>
    <i> * Vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL.</i>
    <i> */</i>
    private static void <strong>drawScene</strong>(GL gl, Texture texture) {
        <i>// vymazani framebufferu (bile pozadi)</i>
        gl.glClear(GL.GL_COLOR_BUFFER_BIT);
&nbsp;
        <i>// zakaz prace s texturami</i>
        gl.glDisable(gl.GL_TEXTURE_2D);
&nbsp;
        <i>// zakaz blendingu</i>
        gl.glDisable(GL.GL_BLEND);
&nbsp;
        <i>// vykresleni mrizky</i>
        gl.glColor3f(0.0f, 0.0f, 0.0f);
        gl.glBegin(GL.GL_LINES);
        for (int i=0; i &lt; GFX_WIDTH; i+=20) {
            gl.glVertex2i(i, 0);
            gl.glVertex2i(i, GFX_HEIGHT);
        }
        for (int i=0; i &lt; GFX_HEIGHT; i+=20) {
            gl.glVertex2i(0, i);
            gl.glVertex2i(GFX_WIDTH, i);
        }
        gl.glEnd();
&nbsp;
        <i>// povoleni prace s texturami</i>
        gl.glEnable(GL.GL_TEXTURE_2D);
&nbsp;
        <i>// povoleni a nastaveni blendingu</i>
        gl.glEnable(GL.GL_BLEND);
        gl.glBlendFunc(GL.GL_SRC_ALPHA, GL.GL_ONE_MINUS_SRC_ALPHA);
&nbsp;
        <i>// navazani textury na kontext OpenGL</i>
        texture.bind(gl);
&nbsp;
        <i>// vykresleni ctyruhelniku pokryteho texturou</i>
        gl.glBegin(GL.GL_QUADS);
            gl.glTexCoord2f(0.0f, 0.0f);
            gl.glVertex2i(100, 100);
            gl.glTexCoord2f(1.0f, 0.0f);
            gl.glVertex2i(500, 100);
            gl.glTexCoord2f(1.0f, 1.0f);
            gl.glVertex2i(500, 500);
            gl.glTexCoord2f(0.0f, 1.0f);
            gl.glVertex2i(100, 500);
        gl.glEnd();
&nbsp;
        gl.glFlush();                                        <i>// provedeni a vykresleni vsech zmen</i>
    }
&nbsp;
    <i>/**</i>
    <i> * Vytvoreni textury z obrazku typu BufferedImage.</i>
    <i> */</i>
    private static Texture <strong>createTexture</strong>(GL gl) throws IOException {
        <i>// rozmery textury</i>
        final int width = 256;
        final int height = 256;
&nbsp;
        <i>// vytvoreni rastroveho obrazku</i>
        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_4BYTE_ABGR);
        renderImage(image);
&nbsp;
        <i>// ziskani instance typu TextureFactory</i>
        TextureFactory textureFactory = TextureFactory.getFactory();
&nbsp;
        <i>// vytvoreni textury z obrazku typu BufferedImage</i>
        return textureFactory.loadTexture(gl, image, GL.GL_TEXTURE_2D, GL.GL_RGBA, GL.GL_LINEAR, GL.GL_LINEAR);
    }
&nbsp;
    <i>/**</i>
    <i> * Vytvoreni vzorku.</i>
    <i> */</i>
    private static void <strong>renderImage</strong>(BufferedImage image) {
        <i>// rozmery bitmapy</i>
        final int width = image.getWidth();
        final int height = image.getHeight();
&nbsp;
        <i>// ziskani objektu obsahujiciho hodnoty vsech pixelu bitmapy</i>
        DataBuffer dataBuffer = image.getRaster().getDataBuffer();
&nbsp;
        <i>// provest vypocet barev pixelu a jejich vykresleni</i>
        int i = 0;
        for (int y = 0; y &lt; height; y++) {
            for (int x = 0; x &lt; width; x++) {
                dataBuffer.setElem(i++, x+y);
                dataBuffer.setElem(i++, x-y);
                dataBuffer.setElem(i++, y);
                dataBuffer.setElem(i++, y);
            }
        }
        System.out.println("Written " + i + " bytes into DataBuffer"); 
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni osmeho demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace video subsystemu knihovny SDL</i>
            SDLMain.init(SDLMain.SDL_INIT_VIDEO);
&nbsp;
            <i>// inicializace grafickeho rezimu ci otevreni okna pro vykreslovani</i>
            SDLSurface screen = initVideo();
&nbsp;
            <i>// inicializace celoobrazovkoveho grafickeho rezimu</i>
            GL gl = screen.getGL();
&nbsp;
            <i>// nastaveni transformacnich matic a barvy pozadi framebufferu</i>
            initScene(gl, GFX_WIDTH, GFX_HEIGHT);
&nbsp;
            <i>// vytvoreni textury z obrazku typu BufferedImage</i>
            Texture texture = createTexture(gl);
&nbsp;
            <i>// vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL</i>
            drawScene(gl, texture);
&nbsp;
            <i>// prepnuti predniho a zadniho bufferu</i>
            screen.glSwapBuffers();
&nbsp;
            <i>// ukonceni cele aplikace po peti sekundach</i>
            Thread.sleep(5000);
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
        <i>// zobrazit ziskane informace</i>
    }
&nbsp;
}
</pre>

<p>Skript pro pøeklad na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest27.java
</pre>

<p>Dávkový soubor pro pøeklad na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest27.java
</pre>

<p>Skript pro spu¹tìní na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
java -cp .:$SDL_JAVA_LIBS/sdljava.jar -Djava.library.path=$SDL_JAVA_LIBS SDLTest27
</pre>

<p>Dávkový soubor pro spu¹tìní na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest27
</pre>

<a href="http://i.iinfo.cz/images/362/119-2.png"><img src="http://i.iinfo.cz/images/362/119-2-prev.png" class="image-163226" width="270" height="270" alt="&#160;" /></a>
<p><i>Obrázek 2: Scéna vykreslená po spu¹tìní demonstraèního pøíkladu
<strong>SDLTest27</strong>.</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Zpracování událostí v&nbsp;knihovnì SDLJava</h2>

<p>Knihovna <i>SDLJava</i> obsahuje i vlastní systém pro práci
s&nbsp;událostmi, který je mo¾né vyu¾ít napøíklad pøi práci s&nbsp;klávesnicí,
my¹í èi joystickem. Systém událostí implementovaný v&nbsp;<i>SDLJava</i> se
v&nbsp;nìkolika ohledech odli¹uje napøíklad od zpùsobu reakce na události,
který známe z&nbsp;knihovny <i>AWT</i> a pøenesenì i z&nbsp;knihovny
<i>Swing</i>. Zatímco v&nbsp;pøípadì <i>AWT/Swing</i> bylo mo¾né naprogramovat
reakci na nìjaký typ události pro ka¾dou komponentu (okno, widget) zvlá¹», a to
formou anonymních tøíd s&nbsp;&bdquo;callback metodami&ldquo;, je
v&nbsp;<i>SDLJava</i> implementována jediná fronta událostí, z&nbsp;ní¾ je
mo¾né jednotlivé události vybírat a/nebo èíst s&nbsp;vyu¾itím následujících
ètyø statických metod implementovaných ve tøídì <strong>SDLEvent</strong>:</p>

<table>
<tr><th>#</th><th>Metoda</th><th>Význam</th></tr>
<tr><td>1</td><td>SDLEvent pollEvent()                   </td><td>pøeètení události z&nbsp;fronty</td></tr>
<tr><td>2</td><td>SDLEvent pollEvent(boolean returnEvent)</td><td>pøeètení události z&nbsp;fronty</td></tr>
<tr><td>3</td><td>SDLEvent waitEvent()                   </td><td>èekání na dal¹í událost a pøeètení této události</td></tr>
<tr><td>4</td><td>SDLEvent waitEvent(boolean returnEvent)</td><td>èekání na dal¹í událost a pøípadné pøeètení této události</td></tr>
</table>

<p>To, zda se pou¾ije metoda <strong>pollEvent()</strong> èi metoda
<strong>waitEvent()</strong> závisí na povaze aplikace. Napøíklad ve chvíli,
kdy aplikace zobrazuje nìjaké menu èi dialog, mù¾e být vhodné èekat na dal¹í
událost v&nbsp;metodì <strong>waitEvent()</strong>, zatímco ve høe, v&nbsp;ní¾
se pohybují protivníci nezávisle na akcích u¾ivatele, se typicky pou¾ívá metoda
<strong>pollEvent()</strong>, která mù¾e vrátit <strong>null</strong>
v&nbsp;pøípadì, ¾e ¾ádná událost nebyla do fronty ulo¾ena.</p>

<p>V&nbsp;knihovnì <i>SDLJava</i> je fronta událostí øe¹ena takovým zpùsobem,
aby se nemusely vytváøet nové objekty pøi vzniku události &ndash; ty by jen
zbyteènì zaplòovaly haldu (heap) a její plnìní by vedlo i k&nbsp;pozastavování
aplikace ve chvílích, kdy by se spou¹tìl správce pamìti (garbage collector).
Proto bývá obvykle hra naprogramovaná s&nbsp;vyu¾itím <i>SDLJava</i>
plynulej¹í, ne¾ podobná aplikace naprogramovaná s&nbsp;vyu¾itím AWT èi Swingu
(nemluvì ji¾ o obecnì vy¹¹ím výkonu <i>SDLJava</i> pøi provádìní grafických
operací).</p>

<p>Souèasná verze knihovny <i>SDLJava</i> pracuje s&nbsp;následujícími typy
událostí:</p>

<table>
<tr><th> #</th><th>Událost</th></tr>
<tr><td> 1</td><td>sdljava.event.SDLActiveEvent     </td></tr>
<tr><td> 2</td><td>sdljava.event.SDLExposeEvent     </td></tr>
<tr><td> 3</td><td>sdljava.event.SDLJoyAxisEvent    </td></tr>
<tr><td> 4</td><td>sdljava.event.SDLJoyBallEvent    </td></tr>
<tr><td> 5</td><td>sdljava.event.SDLJoyButtonEvent  </td></tr>
<tr><td> 6</td><td>sdljava.event.SDLJoyHatEvent     </td></tr>
<tr><td> 7</td><td>sdljava.event.SDLKeyboardEvent   </td></tr>
<tr><td> 8</td><td>sdljava.event.SDLMouseButtonEvent</td></tr>
<tr><td> 9</td><td>sdljava.event.SDLMouseMotionEvent</td></tr>
<tr><td>10</td><td>sdljava.event.SDLQuitEvent       </td></tr>
<tr><td>11</td><td>sdljava.event.SDLResizeEvent     </td></tr>
<tr><td>12</td><td>sdljava.event.SDLSysWMEvent      </td></tr>
</table>

<p>Princip zpracování jednotlivých typù událostí si postupnì uká¾eme na
nìkolika demonstraèních pøíkladech.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Demonstraèní pøíklad <strong>SDLTest28</strong> &ndash; ètení událostí ve smyèce</h2>

<p>V&nbsp;demonstraèním pøíkladu pojmenovaném <strong>SDLTest28</strong> je
ukázán nejjednodu¹¹í typ smyèky pro zpracování událostí. Tato (nekoneèná)
smyèka je implementována v&nbsp;metodì <strong>eventLoop()</strong> a provádí
pouze tøi èinnosti &ndash; èekání na pøíchod nové události, pøeètení této
události a následnì výpis jména tøídy, její¾ objekt reprezentuje právì
zachycenou událost. Pov¹imnìte si, ¾e demonstraèní pøíklad <i>nelze</i>
jednodu¹e ukonèit uzavøením jeho okna, proto¾e v&nbsp;tomto pøípadì se
&bdquo;pouze&ldquo; vytvoøí událost typu <strong>SDLQuitEvent</strong>, na ní¾
se v¹ak nijak nereaguje. Pøíklad tedy ukonèíte napøíklad pøes CTRL+C, zasláním
signálu atd. Samotná smyèka pro zpracování událostí vypadá následovnì:</p>

<pre>
<i>/**</i>
<i> * Smycka pro zpracovani udalosti.</i>
<i> */</i>
private static void <strong>eventLoop</strong>() throws SDLException {
    while (true) {
        <i>// precist udalost z fronty</i>
        SDLEvent event = SDLEvent.waitEvent();
        System.out.println(event.getClass().getName());
    }
}
</pre>

<a href="http://i.iinfo.cz/images/362/119-3.png"><img src="http://i.iinfo.cz/images/362/119-3-prev.png" class="image-163227" width="370" height="232" alt="&#160;" /></a>
<p><i>Obrázek 3: Ukázka výstupu demonstraèního pøíkladu <strong>SDLTest28</strong>.</i></p>

<p>Úplný zdrojový kód demonstraèního pøíkladu <strong>SDLTest28</strong>:</p>

<pre>
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.event.SDLEvent;
import sdljava.video.SDLVideo;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Dvacaty osmy demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> *</i>
<i> * Cteni udalosti.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>SDLTest28</strong> {
&nbsp;
    <i>/**</i>
    <i> * Horizontalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_WIDTH</strong> = 320;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_HEIGHT</strong> = 240;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka vybraneho grafickeho rezimu.</i>
    <i> * (0 znamena automaticky vyber, ovsem lze samozrejme pouzit</i>
    <i> * i hodnoty 8, 16, 24 ci 32, podle vlastnosti graficke karty)</i>
    <i> */</i>
    private static final int <strong>GFX_BPP</strong> = 0;
&nbsp;
    <i>/**</i>
    <i> * Inicializace grafickeho rezimu ci otevreni okna pro vykreslovani.</i>
    <i> */</i>
    private static void <strong>initVideo</strong>() throws SDLException {
        final long flags = SDLVideo.SDL_DOUBLEBUF;
        SDLVideo.setVideoMode(GFX_WIDTH, GFX_HEIGHT, GFX_BPP, flags);
    }
&nbsp;
    <i>/**</i>
    <i> * Smycka pro zpracovani udalosti.</i>
    <i> */</i>
    private static void <strong>eventLoop</strong>() throws SDLException {
        while (true) {
            <i>// precist udalost z fronty</i>
            SDLEvent event = SDLEvent.waitEvent();
            System.out.println(event.getClass().getName());
        }
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni osmeho demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace knihovny SDLJava</i>
            SDLMain.init(SDLMain.SDL_INIT_VIDEO);
&nbsp;
            <i>// inicializace grafickeho rezimu ci otevreni okna pro vykreslovani</i>
            initVideo();
&nbsp;
            <i>// smycka pro zpracovani udalosti</i>
            eventLoop();
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
        <i>// zobrazit ziskane informace</i>
    }
&nbsp;
}
</pre>

<p>Skript pro pøeklad na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest28.java
</pre>

<p>Dávkový soubor pro pøeklad na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest28.java
</pre>

<p>Skript pro spu¹tìní na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
java -cp .:$SDL_JAVA_LIBS/sdljava.jar -Djava.library.path=$SDL_JAVA_LIBS SDLTest28
</pre>

<p>Dávkový soubor pro spu¹tìní na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest28
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Demonstraèní pøíklad <strong>SDLTest29</strong> &ndash; reakce na událost typu <strong>SDLQuitEvent</strong></h2>

<p>Chování pøedchozího demonstraèního pøíkladu <strong>SDLTest28</strong> bylo
&ndash; politicky korektnì øeèeno &ndash; ponìkud &bdquo;nestandardní&ldquo;
;-), proto¾e u¾ivatelé oèekávají, ¾e se po zavøení okna pøíslu¹ná aplikace
skuteènì ukonèí. Toho lze velmi snadno dosáhnout i pøi pou¾ití knihovny
<i>SDLJava</i>, a to konkrétnì takovým zpùsobem, ¾e se správnì zareaguje na
událost typu <strong>SDLQuitEvent</strong>. Tato událost typicky vzniká právì
pøi pokusu o uzavøení okna aplikace, a to nezávisle na tom, na jakém operaèním
systému je aplikace spu¹tìna. Jeden z&nbsp;nejjednodu¹¹ích zpùsobù reakce na
událost typu <strong>SDLQuitEvent</strong> je ukonèení bìhu smyèky
událostí:</p>

<pre>
<i>/**</i>
<i> * Smycka pro zpracovani udalosti.</i>
<i> */</i>
private static void <strong>eventLoop</strong>() throws SDLException {
    while (true) {
        <i>// precist udalost z fronty</i>
        SDLEvent event = SDLEvent.waitEvent();
        System.out.println(event.getClass().getName());
&nbsp;
        <i>// vyskok ze smycky pro zpracovani udalosti pri vyskytu</i>
        <i>// udalosti typu SDLQuitEvent</i>
        if (event instanceof SDLQuitEvent) {
            return;
        }
    }
}
</pre>

<p>Opìt následuje výpis celého zdrojového kódu demonstraèního pøíkladu
<strong>SDLTest29</strong>:</p>

<pre>
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.event.SDLEvent;
import sdljava.event.SDLQuitEvent;
import sdljava.video.SDLVideo;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Dvacaty devaty demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> *</i>
<i> * Cteni udalosti a reakce na udalost typu SDLQuitEvent.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>SDLTest29</strong> {
&nbsp;
    <i>/**</i>
    <i> * Horizontalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_WIDTH</strong> = 320;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_HEIGHT</strong> = 240;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka vybraneho grafickeho rezimu.</i>
    <i> * (0 znamena automaticky vyber, ovsem lze samozrejme pouzit</i>
    <i> * i hodnoty 8, 16, 24 ci 32, podle vlastnosti graficke karty)</i>
    <i> */</i>
    private static final int <strong>GFX_BPP</strong> = 0;
&nbsp;
    <i>/**</i>
    <i> * Inicializace grafickeho rezimu ci otevreni okna pro vykreslovani.</i>
    <i> */</i>
    private static void <strong>initVideo</strong>() throws SDLException {
        final long flags = SDLVideo.SDL_DOUBLEBUF;
        SDLVideo.setVideoMode(GFX_WIDTH, GFX_HEIGHT, GFX_BPP, flags);
    }
&nbsp;
    <i>/**</i>
    <i> * Smycka pro zpracovani udalosti.</i>
    <i> */</i>
    private static void <strong>eventLoop</strong>() throws SDLException {
        while (true) {
            <i>// precist udalost z fronty</i>
            SDLEvent event = SDLEvent.waitEvent();
            System.out.println(event.getClass().getName());
&nbsp;
            <i>// vyskok ze smycky pro zpracovani udalosti pri vyskytu</i>
            <i>// udalosti typu SDLQuitEvent</i>
            if (event instanceof SDLQuitEvent) {
                return;
            }
        }
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni osmeho demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace knihovny SDLJava</i>
            SDLMain.init(SDLMain.SDL_INIT_VIDEO);
&nbsp;
            <i>// inicializace grafickeho rezimu ci otevreni okna pro vykreslovani</i>
            initVideo();
&nbsp;
            <i>// smycka pro zpracovani udalosti</i>
            eventLoop();
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
        <i>// zobrazit ziskane informace</i>
    }
&nbsp;
}
</pre>

<p>Skript pro pøeklad na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest29.java
</pre>

<p>Dávkový soubor pro pøeklad na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest29.java
</pre>

<p>Skript pro spu¹tìní na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
java -cp .:$SDL_JAVA_LIBS/sdljava.jar -Djava.library.path=$SDL_JAVA_LIBS SDLTest29
</pre>

<p>Dávkový soubor pro spu¹tìní na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest29
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Demonstraèní pøíklad <strong>SDLTest30</strong> &ndash; ètení informací o stisknutých a pu¹tìných klávesách</h2>

<p>Kromì události typu <strong>SDLQuitEvent</strong> lze samozøejmì reagovat i
na dal¹í typy událostí. V&nbsp;dne¹ním posledním demonstraèním pøíkladu
nazvaném <strong>SDLTest30</strong> je ukázán základní zpùsob zpracování
události typu <strong>SDLKeyboardEvent</strong>. Tato událost vznikne ve chvíli
stlaèení èi naopak pu¹tìní nìjaké klávesy &ndash; dùle¾itý je zde právì fakt,
¾e doká¾eme snadno detekovat i okam¾ik pu¹tìní nìjaké klávesy, co¾ se hodí pøi
programování her. Objekt typu <strong>SDLKeyboardEvent</strong> nese nìkolik
dùle¾itých informací, pøedev¹ím pak kód stisknuté/pu¹tìné klávesy a stav této
klávesy. Kódy kláves lze porovnávat s&nbsp;konstantami ulo¾enými ve tøídì
<strong>SDLKey</strong>. V&nbsp;demonstraèním pøíkladu je tímto zpùsobem
reagováno na stisk klávesy <i>ESC</i>, která bìh demonstraèního pøíkladu
ukonèí:</p>

<pre>
<i>/**</i>
<i> * Smycka pro zpracovani udalosti.</i>
<i> */</i>
private static void <strong>eventLoop</strong>() throws SDLException {
    while (true) {
        <i>// precist udalost z fronty</i>
        SDLEvent event = SDLEvent.waitEvent();
&nbsp;
        <i>// vyskok ze smycky pro zpracovani udalosti pri vyskytu</i>
        <i>// udalosti typu SDLQuitEvent</i>
        if (event instanceof SDLQuitEvent) {
            return;
        }
&nbsp;
        <i>// stisk ci pusteni klavesy</i>
        if (event instanceof SDLKeyboardEvent) {
            final SDLKeyboardEvent keyEvent = (SDLKeyboardEvent)event;
            final int symbol = keyEvent.getSym();
            final String state = keyEvent.getState() == SDLPressedState.PRESSED ? "pressed" : "release";
            System.out.println("Keyboard event: symbol=" + symbol +" state=" + state);
&nbsp;
            <i>// ESC ukonci program</i>
            if (symbol == SDLKey.SDLK_ESCAPE) {
                return;
            }
        }
    }
}
</pre>

<p>Úplný zdrojový kód demonstraèního pøíkladu <strong>SDLTest30</strong> vypadá
následovnì:</p>

<pre>
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.event.SDLEvent;
import sdljava.event.SDLKeyboardEvent;
import sdljava.event.SDLKey;
import sdljava.event.SDLQuitEvent;
import sdljava.video.SDLVideo;
&nbsp;
import sdljava.x.swig.SDLPressedState;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Dvacaty devaty demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> *</i>
<i> * Cteni udalosti a reakce na stisk klaves.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>SDLTest30</strong> {
&nbsp;
    <i>/**</i>
    <i> * Horizontalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_WIDTH</strong> = 320;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_HEIGHT</strong> = 240;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka vybraneho grafickeho rezimu.</i>
    <i> * (0 znamena automaticky vyber, ovsem lze samozrejme pouzit</i>
    <i> * i hodnoty 8, 16, 24 ci 32, podle vlastnosti graficke karty)</i>
    <i> */</i>
    private static final int <strong>GFX_BPP</strong> = 0;
&nbsp;
    <i>/**</i>
    <i> * Inicializace grafickeho rezimu ci otevreni okna pro vykreslovani.</i>
    <i> */</i>
    private static void <strong>initVideo</strong>() throws SDLException {
        final long flags = SDLVideo.SDL_DOUBLEBUF;
        SDLVideo.setVideoMode(GFX_WIDTH, GFX_HEIGHT, GFX_BPP, flags);
    }
&nbsp;
    <i>/**</i>
    <i> * Smycka pro zpracovani udalosti.</i>
    <i> */</i>
    private static void <strong>eventLoop</strong>() throws SDLException {
        while (true) {
            <i>// precist udalost z fronty</i>
            SDLEvent event = SDLEvent.waitEvent();
&nbsp;
            <i>// vyskok ze smycky pro zpracovani udalosti pri vyskytu</i>
            <i>// udalosti typu SDLQuitEvent</i>
            if (event instanceof SDLQuitEvent) {
                return;
            }
&nbsp;
            <i>// stisk ci pusteni klavesy</i>
            if (event instanceof SDLKeyboardEvent) {
                final SDLKeyboardEvent keyEvent = (SDLKeyboardEvent)event;
                final int symbol = keyEvent.getSym();
                final String state = keyEvent.getState() == SDLPressedState.PRESSED ? "pressed" : "release";
                System.out.println("Keyboard event: symbol=" + symbol +" state=" + state);
&nbsp;
                <i>// ESC ukonci program</i>
                if (symbol == SDLKey.SDLK_ESCAPE) {
                    return;
                }
            }
        }
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni osmeho demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace knihovny SDLJava</i>
            SDLMain.init(SDLMain.SDL_INIT_VIDEO);
&nbsp;
            <i>// inicializace grafickeho rezimu ci otevreni okna pro vykreslovani</i>
            initVideo();
&nbsp;
            <i>// smycka pro zpracovani udalosti</i>
            eventLoop();
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
        <i>// zobrazit ziskane informace</i>
    }
&nbsp;
}
</pre>

<p>Skript pro pøeklad na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest30.java
</pre>

<p>Dávkový soubor pro pøeklad na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest30.java
</pre>

<p>Skript pro spu¹tìní na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
java -cp .:$SDL_JAVA_LIBS/sdljava.jar -Djava.library.path=$SDL_JAVA_LIBS SDLTest30
</pre>

<p>Dávkový soubor pro spu¹tìní na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest30
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Repositáø se zdrojovými kódy v¹ech pìti dne¹ních demonstraèních pøíkladù</h2>

<p>V¹ech pìt dnes popsaných demonstraèních pøíkladù bylo spoleènì
s&nbsp;podpùrnými skripty urèenými pro jejich pøeklad a následné spu¹tìní
ulo¾eno do Mercurial repositáøe dostupného na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
Podobnì jako tomu bylo i v&nbsp;pøedchozích sedmi dílech tohoto seriálu, i ke
dne¹ním pøíkladùm jsou pøilo¾eny skripty vyu¾itelné pro jejich pøeklad a
spu¹tìní. Navíc byly pøidány i skripty vyu¾itelné ve Windows:</p>

<table>
<tr><th> #</th><th>Zdrojový soubor/skript</th><th>Umístìní souboru v&nbsp;repositáøi</th></tr>
<tr><td> 1</td><td>SDLTest26.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest26/SDLTest26.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest26/SDLTest26.java</a></td></tr>
<tr><td> 2</td><td>SDLTest26_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest26/SDLTest26_compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest26/SDLTest26_compile.sh</a></td></tr>
<tr><td> 3</td><td>SDLTest26_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest26/SDLTest26_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest26/SDLTest26_compile_sys.sh</a></td></tr>
<tr><td> 4</td><td>SDLTest26_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest26/SDLTest26_run.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest26/SDLTest26_run.sh</a></td></tr>
<tr><td> 5</td><td>SDLTest26_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest26/SDLTest26_run_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest26/SDLTest26_run_sys.sh</a></td></tr>
<tr><td> 6</td><td>SDLTest26_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest26/SDLTest26_compile.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest26/SDLTest26_compile.bat</a></td></tr>
<tr><td> 7</td><td>SDLTest26_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest26/SDLTest26_run.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest26/SDLTest26_run.bat</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>SDLTest27.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest27/SDLTest27.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest27/SDLTest27.java</a></td></tr>
<tr><td> 9</td><td>SDLTest27_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest27/SDLTest27_compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest27/SDLTest27_compile.sh</a></td></tr>
<tr><td>10</td><td>SDLTest27_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest27/SDLTest27_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest27/SDLTest27_compile_sys.sh</a></td></tr>
<tr><td>11</td><td>SDLTest27_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest27/SDLTest27_run.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest27/SDLTest27_run.sh</a></td></tr>
<tr><td>12</td><td>SDLTest27_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest27/SDLTest27_run_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest27/SDLTest27_run_sys.sh</a></td></tr>
<tr><td>13</td><td>SDLTest27_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest27/SDLTest27_compile.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest27/SDLTest27_compile.bat</a></td></tr>
<tr><td>14</td><td>SDLTest27_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest27/SDLTest27_run.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest27/SDLTest27_run.bat</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>SDLTest28.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest28/SDLTest28.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest28/SDLTest28.java</a></td></tr>
<tr><td>16</td><td>SDLTest28_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest28/SDLTest28_compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest28/SDLTest28_compile.sh</a></td></tr>
<tr><td>17</td><td>SDLTest28_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest28/SDLTest28_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest28/SDLTest28_compile_sys.sh</a></td></tr>
<tr><td>18</td><td>SDLTest28_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest28/SDLTest28_run.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest28/SDLTest28_run.sh</a></td></tr>
<tr><td>19</td><td>SDLTest28_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest28/SDLTest28_run_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest28/SDLTest28_run_sys.sh</a></td></tr>
<tr><td>20</td><td>SDLTest28_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest28/SDLTest28_compile.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest28/SDLTest28_compile.bat</a></td></tr>
<tr><td>21</td><td>SDLTest28_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest28/SDLTest28_run.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest28/SDLTest28_run.bat</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>SDLTest29.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest29/SDLTest29.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest29/SDLTest29.java</a></td></tr>
<tr><td>23</td><td>SDLTest29_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest29/SDLTest29_compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest29/SDLTest29_compile.sh</a></td></tr>
<tr><td>24</td><td>SDLTest29_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest29/SDLTest29_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest29/SDLTest29_compile_sys.sh</a></td></tr>
<tr><td>25</td><td>SDLTest29_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest29/SDLTest29_run.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest29/SDLTest29_run.sh</a></td></tr>
<tr><td>26</td><td>SDLTest29_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest29/SDLTest29_run_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest29/SDLTest29_run_sys.sh</a></td></tr>
<tr><td>27</td><td>SDLTest29_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest29/SDLTest29_compile.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest29/SDLTest29_compile.bat</a></td></tr>
<tr><td>28</td><td>SDLTest29_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest29/SDLTest29_run.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest29/SDLTest29_run.bat</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>29</td><td>SDLTest30.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest30/SDLTest30.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest30/SDLTest30.java</a></td></tr>
<tr><td>30</td><td>SDLTest30_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest30/SDLTest30_compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest30/SDLTest30_compile.sh</a></td></tr>
<tr><td>31</td><td>SDLTest30_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest30/SDLTest30_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest30/SDLTest30_compile_sys.sh</a></td></tr>
<tr><td>32</td><td>SDLTest30_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest30/SDLTest30_run.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest30/SDLTest30_run.sh</a></td></tr>
<tr><td>33</td><td>SDLTest30_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest30/SDLTest30_run_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest30/SDLTest30_run_sys.sh</a></td></tr>
<tr><td>34</td><td>SDLTest30_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest30/SDLTest30_compile.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest30/SDLTest30_compile.bat</a></td></tr>
<tr><td>35</td><td>SDLTest30_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest30/SDLTest30_run.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/ff8f5102c62a/sdljava/SDLTest30/SDLTest30_run.bat</a></td></tr>
</table>



<p><a name="k10"></a></p>
<h2 id="k10">10. Odkazy na Internetu</h2>

<ol>

<li>glDrawArrays<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArrays.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArrays.xml</a>
</li>

<li>glDrawElements<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElements.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElements.xml</a>
</li>

<li>glDrawArraysInstanced<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArraysInstanced.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArraysInstanced.xml</a>
</li>

<li>glDrawElementsInstanced<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElementsInstanced.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElementsInstanced.xml</a>
</li>

<li>Root.cz: Seriál Grafická knihovna OpenGL<br />
<a href="http://www.root.cz/serialy/graficka-knihovna-opengl/">http://www.root.cz/serialy/graficka-knihovna-opengl/</a>
</li>

<li>Root.cz: Seriál Tvorba pøenositelných grafických aplikací vyu¾ívajících knihovnu GLUT<br />
<a href="http://www.root.cz/serialy/tvorba-prenositelnych-grafickych-aplikaci-vyuzivajicich-knihovnu-glut/">http://www.root.cz/serialy/tvorba-prenositelnych-grafickych-aplikaci-vyuzivajicich-knihovnu-glut/</a>
</li>

<li>Best Practices for Working with Vertex Data<br />
<a href="https://developer.apple.com/library/ios/documentation/3ddrawing/conceptual/opengles_programmingguide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html">https://developer.apple.com/library/ios/documentation/3ddrawing/conceptual/opengles_programmingguide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_Surface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_PixelFormat<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlpixelformat.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlpixelformat.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_LockSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdllocksurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdllocksurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_UnlockSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlunlocksurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlunlocksurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_LoadBMP<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlloadbmp.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlloadbmp.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_SaveBMP<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsavebmp.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsavebmp.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_BlitSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlblitsurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlblitsurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_VideoInfo<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlvideoinfo.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlvideoinfo.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_GetVideoInfo<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlgetvideoinfo.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlgetvideoinfo.html</a>
</li>

<li>Class BufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferStrategy.html</a>
</li>

<li>Class Graphics<br />
<a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/Graphics.html">http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/Graphics.html</a>
</li>

<li>Double Buffering and Page Flipping<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html</a>
</li>

<li>BufferStrategy and BufferCapabilities<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/bufferstrategy.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/bufferstrategy.html</a>
</li>

<li>Java:Tutorials:Double Buffering<br />
<a href="http://content.gpwiki.org/index.php/Java:Tutorials:Double_Buffering">http://content.gpwiki.org/index.php/Java:Tutorials:Double_Buffering</a>
</li>

<li>Double buffer in standard Java AWT<br />
<a href="http://www.codeproject.com/Articles/2136/Double-buffer-in-standard-Java-AWT">http://www.codeproject.com/Articles/2136/Double-buffer-in-standard-Java-AWT</a>
</li>

<li>Java 2D: Hardware Accelerating - Part 1 - Volatile Images<br />
<a href="http://www.javalobby.org/forums/thread.jspa?threadID=16840&tstart=0">http://www.javalobby.org/forums/thread.jspa?threadID=16840&tstart=0</a>
</li>

<li>Java 2D: Hardware Accelerating - Part 2 - Buffer Strategies<br />
<a href="http://www.javalobby.org/java/forums/t16867.html">http://www.javalobby.org/java/forums/t16867.html</a>
</li>

<li>How does paintComponent work?<br />
<a href="http://stackoverflow.com/questions/15544549/how-does-paintcomponent-work">http://stackoverflow.com/questions/15544549/how-does-paintcomponent-work</a>
</li>

<li>A Swing Architecture Overview<br />
<a href="http://www.oracle.com/technetwork/java/architecture-142923.html">http://www.oracle.com/technetwork/java/architecture-142923.html</a>
</li>

<li>Class javax.swing.JComponent<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html</a>
</li>

<li>Class java.awt.Component<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html</a>
</li>

<li>Class java.awt.Component.BltBufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.BltBufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.BltBufferStrategy.html</a>
</li>

<li>Class java.awt.Component.FlipBufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.FlipBufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.FlipBufferStrategy.html</a>
</li>

<li>Metoda java.awt.Component.isDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html#isDoubleBuffered()">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html#isDoubleBuffered()</a>
</li>

<li>Metoda javax.swing.JComponent.isDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#isDoubleBuffered()">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#isDoubleBuffered()</a>
</li>

<li>Metoda javax.swing.JComponent.setDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#setDoubleBuffered(boolean)">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#setDoubleBuffered(boolean)</a>
</li>

<li>Javadoc - tøída GraphicsDevice<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html</a>
</li>

<li>Javadoc - tøída GraphicsEnvironment<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html</a>
</li>

<li>Javadoc - tøída GraphicsConfiguration<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html</a>
</li>

<li>Javadoc - tøída DisplayMode<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html">http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html</a>
</li>

<li>Lesson: Full-Screen Exclusive Mode API<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/">http://docs.oracle.com/javase/tutorial/extra/fullscreen/</a>
</li>

<li>Full-Screen Exclusive Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html</a>
</li>

<li>Display Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html</a>
</li>

<li>Using the Full-Screen Exclusive Mode API in Java<br />
<a href="http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm">http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>GC safe-point (or safepoint) and safe-region<br />
<a href="http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html">http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html</a>
</li>

<li>Safepoints in HotSpot JVM<br />
<a href="http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html">http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html</a>
</li>

<li>Java theory and practice: Synchronization optimizations in Mustang<br />
<a href="http://www.ibm.com/developerworks/java/library/j-jtp10185/">http://www.ibm.com/developerworks/java/library/j-jtp10185/</a>
</li>

<li>How to build hsdis<br />
<a href="http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README">http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README</a>
</li>

<li>Java SE 6 Performance White Paper<br />
<a href="http://www.oracle.com/technetwork/java/6-performance-137236.html">http://www.oracle.com/technetwork/java/6-performance-137236.html</a>
</li>

<li>Lukas Stadler's Blog<br />
<a href="http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html">http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html</a>
</li>

<li>How to build hsdis-amd64.dll and hsdis-i386.dll on Windows<br />
<a href="http://dropzone.nfshost.com/hsdis.htm">http://dropzone.nfshost.com/hsdis.htm</a>
</li>

<li>PrintAssembly<br />
<a href="https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly">https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly</a>
</li>

<li>The Java Virtual Machine Specification: 3.14. Synchronization<br />
<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14</a>
</li>

<li>The Java Virtual Machine Specification: 8.3.1.4. volatile Fields<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.4. Memory Model<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.7. Non-atomic Treatment of double and long<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7</a>
</li>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (pøed verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2014</small></p>
</body>
</html>

