<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM (5.èást - popis virtuálního stroje Javy)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM (5.èást - popis virtuálního stroje Javy)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;dne¹ní èásti seriálu o programovacím jazyce Java i o vlastnostech JVM se budeme zabývat popisem vlastního virtuálního stroje Javy, v&nbsp;nìm¾ jsou zpracovávány instrukce bajtkódu tvoøící tìla jednotlivých metod. Popí¹eme si pøedev¹ím strukturu virtuálního stroje Javy v&nbsp;dobì bìhu aplikace a nezapomeneme ani na základní informace o instrukèním souboru.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Virtuální stroj Javy &ndash; JVM</a></p>
<p><a href="#k02">2. Interprety bajtkódu versus just-in-time pøekladaèe</a></p>
<p><a href="#k03">3. Programátorský pohled na virtuální stroj Javy</a></p>
<p><a href="#k04">4. Sdílené pamì»ové prostory: halda (heap), method area a runtime constant pool</a></p>
<p><a href="#k05">5. Pamì»ový prostor pøidìlený ka¾dému vláknu: zásobník, zásobníkové rámce (stack frames)</a></p>
<p><a href="#k06">6. Datové typy zpracovávané virtuálním strojem Javy</a></p>
<p><a href="#k07">7. Zásobník operandù</a></p>
<p><a href="#k08">8. Vyu¾ití zásobníku operandù pøi pøedávání parametrù volaným metodám</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Virtuální stroj Javy &ndash; JVM</h2>

<p>V&nbsp;dne¹ní èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyce Java i o vlastnostech JVM</a> se zamìøíme na popis
virtuálního stroje Javy, který &ndash; jak ji¾ jeho název ostatnì napovídá
&ndash; vytváøí abstraktní (èi virtuální) procesor zcela nezávislý na konkrétní
architektuøe poèítaèe, v&nbsp;nìm¾ jsou spou¹tìny instrukce ulo¾ené
v&nbsp;bajtkódu jednotlivých tøíd. Struktura i vlastnosti virtuálního stroje
Javy jsou pøesnì popsány ve specifikaci JVM, vèetnì pøesného formátu v¹ech
datových typù (znakù, celých èísel, èísel s&nbsp;plovoucí øádovou teèkou). Díky
dodr¾ování této specifikace rùznými výrobci virtuálního stroje Javy je
zaruèeno, ¾e programy napsané v&nbsp;Javì jsou pøenositelné na poèítaèe
s&nbsp;mnohdy velmi rozdílnou architekturou: od smartphonù
s&nbsp;jednojádrovými mikroprocesory a¾ po superpoèítaèe s&nbsp;velkým
mno¾stvím výpoèetních uzlù a mnohdy s&nbsp;nìkolika desítkami tisíc
procesorových jader. Rùzné nekompatibility, s&nbsp;nimi¾ programátoøi bojovali
pøedev¹ím v&nbsp;minulosti (ale samozøejmì i dnes, i kdy¾ v&nbsp;mnohem men¹í
míøe), bývají zpùsobeny buï chybami v&nbsp;implementaci nìkterého virtuálního
stroje (a nedodr¾ení specifikace lze pova¾ovat za chybu) èi nekompatibilitami
ve standardních knihovnách, popø.&nbsp;chybami v&nbsp;nativních knihovnách,
které lze z&nbsp;JVM volat.</p>

<p>Specifikace virtuálního stroje Javy popisuje nìkteré jeho èásti velmi
preciznì (napøíklad se jedná o ji¾ zmínìné datové typy èi o formát instrukcí
nebo o strukturu zásobníkového rámce), ov¹em u nìkterých dal¹ích èástí jsou
popsány jen základní vlastnosti a zùstává pouze na tvùrci konkrétní JVM, jakým
zpùsobem se bude daná èást virtuálního stroje ve skuteènosti implementovat. Asi
nejtypiètìj¹ím pøíkladem je specifikace haldy (<i>heap</i>), u ní¾ se sice
pøedpokládá vyu¾ití automatické správy pamìti, ale nikde ji¾ není øeèeno, jaký
konkrétní algoritmus správy pamìti se má pou¾ít (v&nbsp;souèasnosti se vyu¾ívá
hned nìkolik algoritmù) ani jaký formát má být pou¾it pro ukládání referencí na
objekty. Díky tomu bylo mo¾né Javu jednodu¹e pøenést z&nbsp;pùvodní 32bitové
architektury jak na 16bitové procesory, tak i na procesory pracující
s&nbsp;64bitovými ukazateli (u nich¾ lze navíc v&nbsp;pøípadì potøeby vyu¾ít i
<a
href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">komprimované
ukazatele na objekty</a>) &ndash; to v¹e bez nutnosti zásahu do zdrojových kódù
Javovských programù i bez nutnosti jejich rekompilace.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Interprety bajtkódu versus just-in-time pøekladaèe</h2>

<p>Virtuální stroj jazyka Java samozøejmì vyu¾ívá jiný soubor
&bdquo;strojových&ldquo; instrukcí, ne¾ fyzický mikroprocesor, na nìm¾ jsou
Javovské programy spou¹tìny. Dokonce ani mikroprocesory urèené pro pøímé
spou¹tìní bajtkódu &ndash; dnes ji¾ zpola zapomenuté projekty <i>MicroJava</i>
a <i>PicoJava</i> &ndash; nedokázaly nativnì spou¹tìt v¹echny instrukce
bajtkódu. V&nbsp;prvních nìkolika letech existence Javy byly instrukce bajtkódu
(tvoøící tìla jednotlivých metod) v&nbsp;naprosté vìt¹inì pøípadù pouze
interpretovány, a to mnohdy velmi jednoduchým zpùsobem: v&nbsp;programové
smyèce se postupnì naèítaly kódy jednotlivých instrukcí a následnì se pro
ka¾dou instrukci zavolala nativní funkce, která danou instrukci vykonala,
vìt¹inou s&nbsp;parametry ulo¾enými v&nbsp;zásobníkovém rámci nebo
v&nbsp;zásobníku operandù (bli¾¹í popis bude uveden v&nbsp;následujících
kapitolách). Naprogramování naivního interpretru pro JVM není pøíli¹ slo¾ité,
proto¾e samotná instrukèní sada je pomìrnì jednoduchá. Moderní interpretry,
napøíklad v&nbsp;tomto seriálu popsaný <a
href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">JamVM</a>,
jsou navíc naprogramovány takovým zpùsobem, aby byl jejich pøenos na dal¹í
procesorové architektury snadný a pøitom se bajtkód interpretoval co
nejefektivnìj¹ím zpùsobem, ideálnì s&nbsp;ruènì optimalizovanou vnitøní
smyèkou (psanou v&nbsp;assembleru).</p>

<p>Ov¹em i pøes ve¹kerou snahu programátorù interpretrù nemù¾e bìh programù
napsaných v&nbsp;Javì a spou¹tìných v&nbsp;JVM s&nbsp;interpretovaným bajtkódem
v&nbsp;rychlosti soutì¾it s&nbsp;nativními aplikacemi. Právì z&nbsp;tohoto
dùvodu vznikly takzvané <i>just-in-time (JIT)</i> pøekladaèe, které doká¾ou
pøelo¾it buï jen urèitou sekvenci instrukcí JVM nebo i celý bajtkód do
nativního strojového kódu, který je následnì spu¹tìn. Nìkteré JIT pøekladaèe,
napøíklad stále populární <i>HotSpot</i> pùvodnì vyvinutý spoleèností Sun
Microsystems, pou¾ívají <i>adaptivní pøeklad</i>, v&nbsp;nìm¾ je bajtkód
analyzován v&nbsp;dobì bìhu, tak¾e má JIT pøekladaè k&nbsp;dispozici mnohem
více informací, ne¾ pøi statickém pøekladu. <i>HotSpot</i> navíc umo¾òuje
pomocí takzvaný sond (<i>probes</i> sledovat, který kód je pøekládán a jaký typ
pøekladu je pøitom pou¾it, to je v¹ak ji¾ pomìrnì pokroèilá a nepøíli¹ èasto
pou¾ívaná technologie. Ov¹em nezávisle na tom, zda jsou instrukce JVM
&bdquo;pouze&ldquo; interpretovány, nebo je nejdøíve pou¾it <i>JIT</i>, musí
být v¾dy dodr¾eny v¹echny vlastnosti jazyka Java i JVM. <i>JIT</i> napøíklad
mù¾e odstranit kontrolu mezí pøi indexování polí, ale jen tehdy, kdy¾ je
zøejmé, ¾e nedojde k&nbsp;pøekroèení tìchto mezí.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Programátorský pohled na virtuální stroj Javy</h2>

<p>Na virtuální stroj Javy se mù¾eme dívat zpùsobem, který se pøíli¹ nebude
li¹it od pohledu na programátorský model jakéhokoli reálného mikroprocesoru.
Pøi inicializaci JVM toti¾ automaticky dojde k&nbsp;vytvoøení pamì»ových
oblastí, které jsou následnì vyu¾ívány Javovským programem. Do tvorby tìchto
oblastí nemù¾e samotný Javovský program pøíli¹ zasahovat, nebo» se jedná o
pamì» spravovanou mimo vlastní virtuální stroj (to napøíklad znamená, ¾e
programátor èi administrátor systému mù¾e zvolit maximální kapacitu pamìti pro
JVM, velikost zásobníku atd.). Instrukce ulo¾ené v&nbsp;bajtkódu nedìlají
(ponìkud nadnesenì øeèeno) nic jiného, ne¾ manipulaci s&nbsp;daty ulo¾enými
v&nbsp;jedné nebo více pamì»ových oblastech, popø.&nbsp;navíc mohou volat dal¹í
metody, a» ji¾ se jedná o metody ze stejné tøídy (popø.&nbsp;její instance) èi
o metody ze tøídy jiné. V&nbsp;následující tabulce jsou uvedeny v¹echny
významné pamì»ové oblasti i dal¹í datové struktury, s&nbsp;nimi¾ se podrobnìji
setkáme v&nbsp;navazujících kapitolách:</p>

<table>
<tr><th>#</th><th>Název oblasti/struktury</th><th>Struèný popis oblasti èi struktury</th></tr>
<tr><td>1</td><td>halda (heap)</td><td>spoleèný pamì»ový prostor pro v¹echna vlákna, obsahuje pøedev¹ím data objektù, spravováno pomocí GC</td></tr>
<tr><td>2</td><td>method area</td><td>obsahuje <i>runtime constant pool</i>, kód metod, atributy tøíd atd.</td></tr>
<tr><td>3</td><td>zásobník (stack)</td><td>vytváøený pro ka¾dé vlákno, skládá se ze zásobníkových rámcù (<i>stack frames</i>)</td></tr>
<tr><td>4</td><td>registr PC</td><td>vytváøený pro ka¾dé vlákno, ukazuje na právì zpracovávanou instrukci JVM</td></tr>
<tr><td>5</td><td>native method stack</td><td>vytváøený pro ka¾dé vlákno a pou¾ívaný pøi volání nativních metod (pøedávání parametrù atd.)</td></tr>
</table>

<p>Vý¹e uvedené pamì»ové oblasti mù¾eme rozdìlit do dvou skupin. V&nbsp;první
skupinì se nachází ty oblasti, které jsou dostupné celému procesu, ve druhé
skupinì pak pamì»ové oblasti vytváøené samostatnì pro ka¾dé vlákno
(<i>thread</i>).</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Sdílené pamì»ové prostory: halda (heap), method area a runtime constant pool</h2>

<p>Nejprve se budeme zabývat datovými oblastmi spoleènými pro v¹echna vlákna
bì¾ící v&nbsp;rámci jednoho procesu. Jedná se pøedev¹ím o haldu (<i>heap</i>),
na ní¾ jsou ukládána zejména data patøící k&nbsp;instancím jednotlivých tøíd.
Data ulo¾ená na haldì bývají spravována nìkterým typem automatického správce
pamìti (<i>garbage collector &ndash; GC</i>), ov¹em vzhledem k&nbsp;tomu, ¾e
nelze získat pøímý ukazatel na objekt le¾ící na haldì, nás detaily v&nbsp;tomto
pøípadì nemusí zajímat. Jak uvidíme dále, pøistupuje se k&nbsp;datùm na haldì
nepøímo, vìt¹inou s&nbsp;vyu¾itím jména atributu, pøièem¾ jméno atributu je
ulo¾eno v&nbsp;<i>constant poolu</i>, tak¾e se pøímo v&nbsp;instrukèní sadì
pou¾ívají indexy smìøující do constant poolu, nikoli pøímé adresy objektù na
haldì. Souèástí haldy mù¾e být i takzvaná <i>method area</i> obsahující
atributy tøíd, kódy jednotlivých metod (instrukce JVM) i obraz <i>constant
poolu</i> naètený z&nbsp;bajtkódu. Obraz <i>constant poolu</i> je vytváøen pro
ka¾dou tøídu.</p>

<p>Prozatím se, bez podrobnìj¹ího popisu jednotlivých instrukcí podívejme,
jakým zpùsobem se nepøímo &ndash; s&nbsp;vyu¾itím jména, nikoli adresy &ndash;
mù¾e volat statická metoda z&nbsp;jiné tøídy (volání nestatické metody je
nepatrnì slo¾itìj¹í). Mìjme následující dvojici tøíd, z&nbsp;nich¾ ka¾dá
obsahuje jen jednu metodu:</p>

<pre>
class OtherClass {
    public static void testMethod() {
    }
}
</pre>

<pre>
class Test {
    void callTestMethod() {
        OtherClass.testMethod();
    }
}
</pre>

<p>Metoda <strong>callTestMethod()</strong>, která volá statickou metodu
<strong>OtherClass.testMethod()</strong> se pøelo¾í následujícím zpùsobem:</p>

<pre>
   0:   invokestatic #2
   3:   return
</pre>

<p>Instrukce <strong>invokestatic</strong> (kterou si podrobnìji popí¹eme
pøí¹tì, prozatím ji pova¾ujme za jakousi vylep¹enou instrukci typu
<strong>call</strong>) obsahuje jeden operand &ndash; index do <i>constant
poolu</i>. Podívejme se tedy, jak vypadá <i>constant pool</i> a zvýraznìme si,
jaké informace jsou pøedány JVM pøi zavolání instrukce <strong>invokestatic
#2</strong>:</p>

<pre>
Velikost const. poolu: 18 prvku
  1   10  MethodRef         4     12             java/lang/Object.<init>()V
* 2 * 10  MethodRef        13--.  14----.        OtherClass.testMethod()V
  3    7  Class            15  |        |        Test
  4    7  Class            16  |        |        java/lang/Object
  5    1  String               |        |        "&lt;init&gt;"
  6    1  String         ,-&gt;   |        |        "()V"
  7    1  String         |     |        |        "Code"
  8    1  String         |     |        |        "LineNumberTable"
  9    1  String         |     |        |        "callTestMethod"
 10    1  String         |     |        |        "SourceFile"
 11    1  String         |     |        |        "Test.java"
 12   12  Name and type  |  6  |   5    |        ()V  &lt;init&gt;
 13    7  Class          | 17  `---------------&gt; OtherClass
 14   12  Name and type  `--6     18--. `------&gt; ()V  testMethod
 15    1  String                      |          "Test"
 16    1  String                      |          "java/lang/Object"
 17    1  String                      |          "OtherClass"
 18    1  String                      `--------&gt; "testMethod"
</pre>

<p>Instrukci <strong>invokestatic</strong> pøitom musí být pøedán index na
záznam typu <i>MethodRef</i>, co¾ je kontrolováno ji¾ pøi naèítání bajtkódu do
virtuálního stroje.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Pamì»ový prostor pøidìlený ka¾dému vláknu: zásobník, zásobníkové rámce (stack frames)</h2>

<p>Druhou skupinu pamì»ových oblastí tvoøí ty oblasti, které jsou pøidìlované
jednotlivým vláknùm. Jedná se pøedev¹ím o zásobník (<i>stack</i>), který je
tvoøen sekvencí zásobníkových rámcù (<i>stack frame(s)</i>). Oznaèení
&bdquo;zásobník&ldquo; sice mù¾e navozovat pocit, ¾e se jedná o kontinuální
oblast pamìti, ve skuteènosti v¹ak mezi jednotlivými zásobníkovými rámci
neexistují ¾ádné pøímé vazby a proto se ka¾dý zásobníkový rámec mù¾e nacházet
v&nbsp;pamìti kdekoli &ndash; rámce napøíklad mohou být vytváøeny pøímo na
haldì (zále¾í na konkrétní implementaci JVM). Rámce jsou tvoøeny lokálními
promìnnými a parametry metod.  Jejich souèástí je v¹ak takté¾ zásobník operandù
(<i>operand stack</i>) popsaný <a href="#k07">v&nbsp;sedmé kapitole</a>. Opìt
platí, ¾e není mo¾né získat pøímou adresu lokálních promìnných, parametrù metod
ani dat ulo¾ených na zásobníku operandù, proto se nemusí jednat o kontinuální
oblast pamìti.</p>

<p>Dále zde mù¾eme najít takzvaný <i>native method stack</i> pou¾itý pøi volání
nativních metod. Poslední datovou strukturou pøiøazenou k&nbsp;vláknu, je èítaè
instrukcí <i>PC</i>, který ukazuje na právì provádìnou instrukci JVM. Pøi
volání nativní metody není tento èítaè instrukcí pou¾it (jméno <i>PC</i> je
sice shodné s&nbsp;registrem <i>PC</i>, i funkce je podobná, ale konkrétní
podoba adresy instrukce JVM je obecnì odli¹ná). V&nbsp;pøedchozím odstavci bylo
øeèeno, ¾e v&nbsp;zásobníkovém rámci jsou ulo¾eny jak parametry metod, tak i
její lokální promìnné. Nejdøíve jsou v&nbsp;zásobníkovém rámci ulo¾eny
parametry metod (vèetnì parametru <strong>this</strong> u nestatických metod) a
ihned za nimi je oblast vyhrazená pro lokální promìnné. Ke v¹em tìmto údajùm,
tj.&nbsp;jak k&nbsp;parametrùm, tak i k&nbsp;lokálním promìnným, se pøistupuje
pomocí indexu: první údaj má index 0, dal¹í 1 atd. Uka¾me si to na jednoduchém
pøíkladu tøídy s&nbsp;dvojicí metod &ndash; jedné nestatické a druhé
statické:</p>

<pre>
class Test {
    void add1(int x, int y) {
        int z = x + y;
    }
&nbsp;
    static void add2(int x, int y) {
        int z = x + y;
    }
}
</pre>

<p>Obì metody sice provádí tuté¾ èinnost &ndash; souèet dvou celých èísel
s&nbsp;ulo¾ením výsledku do lokální promìnné &ndash; ov¹em zpùsob indexování
parametrù je uvnitø JVM odli¹ný, proto¾e v&nbsp;nestatické metodì je
v&nbsp;první pozici zásobníkového rámce (tato pozice má index roven nule)
ulo¾en implicitní parametr <strong>this</strong>, kde¾to v&nbsp;metodì statické
se na stejné pozici zásobníkového rámce nachází ji¾ první parametr:</p>

<pre>
void add1(int, int);
  Code:
   Stack=2, Locals=4, Args_size=3
                        // v prvním parametru je ulo¾ena hodnota this, tu nepotøebujeme
   0:   iload_1         // naètení druhého parametru metody s jeho ulo¾ením na zásobník operandù
   1:   iload_2         // naètení tøetího parametru metody s jeho ulo¾ením na zásobník operandù
   2:   iadd            // provedení souètu
   3:   istore_3        // ulo¾ení výsledku na ètvrtou pozici v zásobníkovém rámci: první lokální promìnné
   4:   return          // návrat z metody
</pre>

<pre>
static void add2(int, int);
  Code:
   Stack=2, Locals=3, Args_size=2
   0:   iload_1         // naètení druhého parametru metody s jeho ulo¾ením na zásobník operandù
   1:   iload_2         // naètení tøetího parametru metody s jeho ulo¾ením na zásobník operandù
   2:   iadd            // provedení souètu
   3:   istore_2        // ulo¾ení výsledku na tøetí pozici v zásobníkovém rámci: první lokální promìnné
   4:   return          // návrat z metody
</pre>

<p>Pøesný význam v¹ech instrukcí pou¾itých ve výpisu si uvedeme pøí¹tì.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Datové typy zpracovávané virtuálním strojem Javy</h2>

<p>Virtuální stroj jazyka Java obsahuje instrukce, které pracují
s&nbsp;operandy nìkolika datových typù. Na rozdíl od mnoha fyzických procesorù
se v&nbsp;pøípadì JVM provádí kontroly, zda jsou operace skuteènì aplikovány na
správné operandy. Není napøíklad mo¾né, aby se operace souètu provádìla
s&nbsp;jedním operandem typu <strong>int</strong> a druhým operandem typu
<strong>long</strong> &ndash; takový bajtkód by byl pøi svém naèítání odmítnut
a vùbec by nebyl spu¹tìn. Zajímavé je, ¾e jen velmi málo instrukcí JVM
podporuje práci s&nbsp;datovými typy <strong>boolean</strong>,
<strong>byte</strong>, <strong>short</strong> a <strong>char</strong>. Promìnné
a parametry metod tìchto typù musí být napøíklad pøed provedením nìkteré
aritmetické operace nejprve pøevedeny na typ <strong>int</strong> pomocí
konverzních instrukcí (tìch existuje celkem patnáct). Mimochodem &ndash; tato
vlastnost bajtkódu a virtuálního stroje se projevuje i v&nbsp;sémantice
vlastního programovacího jazyka Java. Pøíkladem mù¾e být následující
metoda:</p>

<pre>
    byte byteAdd(byte a, byte b) {
        byte c=a+b;
        return c;
    }
</pre>

<p>Pøi pokusu o pøeklad této metody (resp.&nbsp;tøídy s&nbsp;touto metodou)
získáme pouze chybové hlá¹ení:</p>

<pre>
% javac Test.java
Test.java:3: possible loss of precision
found   : int
required: byte
        byte c=(a+b);
                 ^
1 error
</pre>

<p>Z&nbsp;toho je patrné, ¾e datový typ <strong>byte</strong> (popø.&nbsp;i
<strong>short</strong> a <strong>char</strong>) není &bdquo;uzavøený&ldquo;
vùèi aritmetickým operacím (operandy jsou automaticky zkonvertovány na
<strong>int</strong>) a je nutné provést explicitní pøetypování:</p>

<pre>
    static byte byteAdd(byte a, byte b) {
        byte c=(byte)(a+b);
        return c;
    }
</pre>

<p>Vra»me se v¹ak k&nbsp;virtuálnímu stroji Javy. Ten doká¾e pracovat
s&nbsp;celkem deseti datovými typy, které jsou v¹echny vypsány
v&nbsp;následující tabulce. Prvních osm datových typù odpovídá primitivním
datovým typùm známým v¹em programátorùm v&nbsp;Javì, devátý typ odpovídá
objektovému datovému typu (reference na libovolnou instanci), ov¹em desátý typ
není pøímo z&nbsp;Javy pøístupný. Operand s&nbsp;tímto typem obsahuje ukazatel
na instrukèní kód, tj.&nbsp;mù¾e se napøíklad jednat o skuteènou adresu
v&nbsp;adresovém prostoru procesoru s&nbsp;JVM, offset platný v&nbsp;rámci
prostoru haldy atd. (to stejné ostatnì platí i pro registr <strong>PC</strong>
zmínìný <a href="#k05">v&nbsp;páté kapitole</a>).</p>

<table>
<tr><th> #</th><th>Typ v&nbsp;Javì</th><th>Pou¾itý typ v JVM</th></tr>
<tr><td> 1</td><td>boolean      </td><td>int          </td></tr>
<tr><td> 2</td><td>byte         </td><td>int          </td></tr>
<tr><td> 3</td><td>char         </td><td>int          </td></tr>
<tr><td> 4</td><td>short        </td><td>int          </td></tr>
<tr><td> 5</td><td>int          </td><td>int          </td></tr>
<tr><td> 6</td><td>long         </td><td>long         </td></tr>
<tr><td> 7</td><td>float        </td><td>float        </td></tr>
<tr><td> 8</td><td>double       </td><td>double       </td></tr>
<tr><td> 9</td><td>reference    </td><td>reference    </td></tr>
<tr><td>10</td><td>není dostupný</td><td>returnAddress</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Zásobník operandù</h2>

<p>Vìt¹ina instrukcí virtuálního stroje Javy pracuje s&nbsp;operandy ulo¾enými
na takzvaném <i>zásobníku operandù (operand stack)</i>. Zásobník operandù
(v&nbsp;tomto pøípadì se ji¾ jedná o skuteèný zásobník typu <i>LIFO &ndash;
Last In, First Out</i>) je vytváøen v&nbsp;èase bìhu aplikace pro ka¾dou
zavolanou metodu, co¾ mj.&nbsp;znamená, ¾e je pøi spu¹tìní metody v¾dy prázdný
(zásobník operandù je podle specifikace souèástí zásobníkového rámce, jeho
konkrétní umístìní v¹ak je libovolné). Ji¾ v&nbsp;èase pøekladu zdrojového kódu
je pro ka¾dou metodu zji¹tìno, jak velká oblast pamìti má být pro zásobník
operandù vyhrazena a samozøejmì je provádìna kontrola, zda se v&nbsp;dobì bìhu
aplikace tato velikost nepøekroèí (to by se nemìlo u validního bajtkódu stát).
Virtuální stroj Javy kontroluje typy operandù ulo¾ených na zásobník operandù a
zaji¹»uje, ¾e se nad tìmito operandy budou provádìt pouze typovì bezpeèné
operace. V&nbsp;praxi to napøíklad znamená, ¾e není mo¾né na zásobník ulo¾it
dvì hodnoty typu <strong>float</strong> a následnì provést instrukci
<strong>iadd</strong>, proto¾e tato instrukce vy¾aduje, aby na zásobníku byly
ulo¾eny dvì hodnoty typu <strong>int</strong> (i kdy¾ <strong>float</strong> i
<strong>int</strong> mají shodnou bitovou ¹íøku).</p>

<p>Podívejme se na jednoduchou ukázku vyu¾ití zásobníku operandù pøi
vyhodnocování slo¾itìj¹ího aritmetického výrazu:</p>

<pre>
class Test {
    void test() {
        int a=10;
        int b=20;
        int c=30;
        int d=30;
        int z=a+b*(c-d);
    }
}
</pre>

<p>Pøelo¾ený bajtkód metody <strong>Test.test()</strong> je následující:</p>

<pre>
void test();
  Code:
   0:   bipush  10
   2:   istore_1           // naplnìní promìnné a hodnotou 10
   3:   bipush  20
   5:   istore_2           // naplnìní promìnné b hodnotou 20
   6:   bipush  30
   8:   istore_3           // naplnìní promìnné c hodnotou 30
   9:   bipush  30
   11:  istore  4          // naplnìní promìnné d hodnotou 40
&nbsp;
   13:  iload_1            // vlo¾ení a na zásobník      [a]
   14:  iload_2            // vlo¾ení b na zásobník      [a b]
   15:  iload_3            // vlo¾ení c na zásobník      [a b c]
   16:  iload   4          // vlo¾ení d na zásobník      [a b c d]
   18:  isub               // provedení operace x=c-d    [a b c-d]
   19:  imul               // provedení operace y=b*x    [a b*(c-d)]
   20:  iadd               // provedení operace a+y      [a+b*(c-d)]
   21:  istore  5          // ulo¾ení výsledku do z      []
&nbsp;
   23:  return
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Vyu¾ití zásobníku operandù pøi pøedávání parametrù volaným metodám</h2>

<p>Zásobník operandù je takté¾ pou¾it pøi volání metod pro pøedání parametrù
tìmto metodám a pro vyzvednutí jejich návratových hodnot. Zále¾í jen na
konkrétní implementaci virtuálního stroje Javy, jakým zpùsobem dojde pøi volání
metody ke konverzi mezi zásobníkem operandù volající metody a lokálními
parametry metody volané. Uka¾me si zpùsob pou¾ití zásobníku operandù jak pro
provádìní aritmetické operace souètu, tak i pro pøedání parametrù volající
metodì a získání výsledku z&nbsp;volané metody. Mìjme jednoduchou tøídu
s&nbsp;dvojicí metod:</p>

<pre>
class Test {
    // provedení souètu dvou celých èísel
    static int add(int a, int b) {
        int c=a+b;
        return c;
    }
&nbsp;
    // zavolá metodu pro provedení souètu dvou èísel
    // a ulo¾í návratovou hodnotu do své lokální promìnné
    static void callAdd() {
        int result = add(1234,5678);
    }
}
</pre>

<p>Pøelo¾ený bajtkód obou metod je následující. V¹echny poznámky jsou
samozøejmì dopsány ruènì:</p>

<pre>
// v metodì add je zásobník operandù pou¾it pouze pro provedení operace souètu
static int add(int, int);
  Code:
   0:   iload_0         // ulo¾ení prvního parametru metody na zásobník operandù
   1:   iload_1         // ulo¾ení druhého parametru metody na zásobník operandù
   2:   iadd            // provedení operace souètu s odstranìním obou operandù
   3:   istore_2        // vyzvednutí výsledku souètu a ulo¾ení do lokální promìnné
   4:   iload_2         // opìtovné ulo¾ení obsahu lokální promìnné na zásobník
   5:   ireturn         // pøi operaci ireturn se vyu¾ije hodnota z vrcholu zásobníku
</pre>

<pre>
// v této metodì se zásobník operandù pou¾ívá i pro komunikaci s metodou Test.add(int, int)
static void callAdd();
  Code:
   0:   sipush  1234    // ulo¾ení konstanty 1234 na zásobník operandù
   3:   sipush  5678    // ulo¾ení konstanty 5678 na zásobník operandù
   6:   invokestatic #2 // zavolání statické metody Test.add(int, int)
   9:   istore_0        // výsledná hodnota je umístìna na vrchol zásobníku operandù,
                        // tak ji odtud vyzvedneme a ulo¾íme do lokální promìnné
   10:  return          // návrat z metody
</pre>

<p>Pov¹imnìte si, ¾e pøekladaè <strong>javac</strong> neprovedl ¾ádné
optimalizace, i kdy¾ se nám napøíklad mù¾e zdát dvojice po sobì jdoucích
instrukcí <strong>istore_2</strong> a <strong>iload_2</strong> nadbyteèná (ve
skuteènosti je to nutné pro správnou funkci debuggeru).</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Root.cz: Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM<br />
<a href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/</a></a>
</li>

<li>Root.cz: JamVM aneb alternativa k HotSpotu nejenom pro embedded zaøízení a chytré telefony<br />
<a href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>FindBugs<br />
<a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a>
</li>

<li>GNU Classpath<br />
<a href="www.gnu.org/s/classpath/">www.gnu.org/s/classpath/</a></li>

<li>Java VMs Compared<br />
<a href="http://bugblogger.com/java-vms-compared-160/">http://bugblogger.com/java-vms-compared-160/</a>
</li>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a></li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>CloseableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html">http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

