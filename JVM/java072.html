<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - spu¹tìní a monitorování virtuálního stroje Javy s vyu¾itím rozhraní JDI</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - spu¹tìní a monitorování virtuálního stroje Javy s vyu¾itím rozhraní JDI</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyku Java i o virtuálním stroji Javy se ji¾ podruhé budeme zabývat rozhraním JDI (Java Debugger Interface). Uká¾eme si, jak lze pøes JDI spustit a následnì i sledovat JVM a pøedev¹ím aplikace spu¹tìné v tomto virtuálním stroji &ndash; jedná se o stejnou èinnost, jakou musí pøi inicializaci vykonat i debuggery.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Krátké shrnutí pøedchozí èásti seriálu: konektory v&nbsp;rozhraní JDI</a></p>
<p><a href="#k02">2. Tøi typy konektorù nabízených rozhraním JDI</a></p>
<p><a href="#k03">3. Základ JDI: tøída <strong>com.sun.jdi.Bootstrap</strong> a rozhraní <strong>com.sun.jdi.VirtualMachineManager</strong></a></p>
<p><a href="#k04">4. Metody pøedepsané rozhraním <strong>com.sun.jdi.connect.LaunchingConnector</strong></a></p>
<p><a href="#k05">5. První demonstraèní pøíklad &ndash; výpis v¹ech argumentù výchozího konektoru typu LaunchingConnector</a></p>
<p><a href="#k06">6. Spu¹tìní nového virtuálního stroje Javy s&nbsp;vyu¾itím výchozího konektoru typu LaunchingConnector</a></p>
<p><a href="#k07">7. Specifikace tøídy, její¾ metoda main() se má v&nbsp;novì vytvoøeném virtuálním stroji spustit</a></p>
<p><a href="#k08">8. Pøeètení standardního výstupu spu¹tìného virtuálního stroje Javy</a></p>
<p><a href="#k09">9. Druhý demonstraèní pøíklad &ndash; spu¹tìní nové JVM s&nbsp;pøeètením výstupu testovací aplikace</a></p>
<p><a href="#k10">10. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Krátké shrnutí pøedchozí èásti seriálu: konektory v&nbsp;rozhraní JDI</h2>

<p>V&nbsp;dne¹ní èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyku Java i o virtuálním stroji Javy</a> bude pokraèovat
v&nbsp;popisu javovského rozhraní <i>JDI (Java Debugger Interface)</i>, které
slou¾í, jak ji¾ název tohoto rozhraní napovídá, k&nbsp;implementaci rùzných
ladicích nástrojù spolupracujících s&nbsp;virtuálním strojem Javy i
s&nbsp;aplikacemi, které jsou v&nbsp;rámci tohoto virtuálního stroje spu¹tìny.
Minule jsme si øekli základní informace o tomto rozhraní i o zaèlenìní
<i>JDI</i> do architektury nazvané <i>JPDA (Java Platform Debugger
Architecture)</i>. Pøipomeòme si, ¾e <i>JDI</i> vývojáøùm debuggerù nabízí hned
nìkolik mo¾ností propojení mezi debuggerem a cílovým JVM, na nìm¾ je spu¹tìna
ladìná aplikace. O propojení mezi <i>JDI</i> a cílovou JVM se z&nbsp;hlediska
programátora starají takzvané &bdquo;konektory&ldquo;, kterých existuje hned
nìkolik typù v&nbsp;závislosti na tom, jakým zpùsobem je debugger pøes
<i>JNI</i> k&nbsp;cílové JVM pøipojován:</p>

<table>
<tr><th>#</th><th>Konektor</th><th>Plné jméno (identifikace)</th><th>Popis</th></tr>
<tr><td>1</td><td>CommandLineLaunch   </td><td>"com.sun.jdi.CommandLineLaunch"</td><td>cílová JVM je spu¹tìna pøímo pøes JDI a ihned poté se navá¾e spojení pøes socket èi sdílenou pamì»</td></tr>
<tr><td>2</td><td>RawCommandLineLaunch</td><td>"com.sun.jdi.RawCommandLineLaunch"</td><td>podobné pøedchozímu konektoru, ov¹em pøíkaz pro spu¹tìní JVM se pøedává pøes jediný øetìzec (li¹í se jen zpùsob spu¹tìní)</td></tr>
<tr><td>3</td><td>SocketAttach        </td><td>"com.sun.jdi.SocketAttach"</td><td>pøipojení k&nbsp;ji¾ bì¾ící cílové JVM pøes socket</td></tr>
<tr><td>4</td><td>SharedMemoryAttach  </td><td>"com.sun.jdi.SharedMemoryAttach"</td><td>pøipojení k&nbsp;ji¾ bì¾ící cílové JVM pøes sdílenou pamì»</td></tr>
<tr><td>5</td><td>SocketListen        </td><td>"com.sun.jdi.SocketListen"</td><td>pøipojení k&nbsp;bì¾ící cílové JVM na základì po¾adavku pøijatého od této JVM</td></tr>
<tr><td>6</td><td>SharedMemoryListen  </td><td>"com.sun.jdi.SharedMemoryListen"</td><td>dtto ale vyu¾ije se sdílená pamì»</td></tr>
<tr><td>7</td><td>ProcessAttach       </td><td>"com.sun.jdi.ProcessAttach"</td><td>pøipojení k&nbsp;ji¾ bì¾ící cílové JVM, která je spu¹tìna s&nbsp;parametrem agentlib:jdwp=server=y</td></tr>
</table>

<img src="http://i.iinfo.cz/images/426/jpda.png" class="image-124848" width="596" height="398" alt="&#160;" />
<p><i>Obrázek 1: Vzájemný vztah mezi ji¾ popsaným (céèkovým) rozhraním JVM TI,
protokolem JDWP a javovským rozhraním JDI. JVM TI, JDWP i JDI jsou souèástí
architektury JPDA &ndash; Java Platform Debugger Architecture.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Tøi typy konektorù nabízených rozhraním JDI</h2>

<p>Ve skuteènosti mù¾e na nìkterých poèítaèových architekturách existovat i
vìt¹í mno¾ství konektorù, tak¾e tabulka uvedená <a href="#k01">v&nbsp;pøedchozí
kapitole</a> není úplná. Ov¹em dùle¾ité je, ¾e nezávisle na tom, kolik
konektorù na dané poèítaèové architektuøe existuje, je v¾dy mù¾eme rozdìlit do
tøí skupin. První skupina konektorù implementuje rozhraní
<strong>LaunchingConnector</strong> a je typická tím, ¾e konektor sám spustí
cílovou JVM i s&nbsp;ladìnou aplikací. Typicky se jedná o konektor velmi èasto
pou¾ívaný rùznými integrovanými vývojovými prostøedími pro spu¹tìní a následné
ladìní aplikace. Druhá skupina konektorù implementuje rozhraní
<strong>AttachingConnector</strong>. Jedná se o konektory, které se doká¾ou
pøipojit k&nbsp;ji¾ bì¾ící JVM. Tato JVM musí být spu¹tìna s&nbsp;volbou:</p>

<pre>
agentlib:jdwp=transport=typ_konektoru,server=y
</pre>

<p>Tøetí typ konektorù implementuje rozhraní
<strong>ListeningConnector</strong>. Tyto konektory slou¾í k&nbsp;tomu, aby se
cílová JVM sama pøipojila k&nbsp;debuggeru, který ji¾ musí být spu¹tìn. Cílový
virtuální stroj Javy bývá v&nbsp;tomto pøípadì spu¹tìn s&nbsp;volbou:</p>

<pre>
agentlib:jdwp=transport=typ_konektoru,address=zvolena_adresa
</pre>

<p>Kde se namísto øetìzce <strong>zvolena adresa</strong> zadá skuteèná adresa,
na které &bdquo;poslouchá&ldquo; debugger.</p>

<p>V¹echny tøi skupiny konektorù jsou pro vìt¹í pøehled vypsány v&nbsp;dal¹í
tabulce i s&nbsp;pøíslu¹nými implementacemi:</p>

<table>
<tr><th>#</th><th>Typ konektoru</th><th>Metoda propojení debuggeru a JVM</th><th>Implementace</th></tr>
<tr><td>1</td><td>LaunchingConnector</td><td>debugger spou¹tí JVM</td><td>com.sun.jdi.CommandLineLaunch, com.sun.jdi.RawCommandLineLaunch</td></tr>
<tr><td>2</td><td>AttachingConnector</td><td>debugger se pøipojuje k&nbsp;bì¾ící JVM</td><td>com.sun.jdi.SocketAttach, com.sun.jdi.SharedMemoryAttach, com.sun.jdi.ProcessAttach</td></tr>
<tr><td>3</td><td>ListeningConnector</td><td>debugger akceptuje ¾ádost JVM o pøipojení</td><td>com.sun.jdi.SocketListen, com.sun.jdi.SharedMemoryListen</td></tr>
</table>

<img src="http://i.iinfo.cz/images/472/jdwp.png" class="image-124849" width="596" height="398" alt="&#160;" />
<p><i>Obrázek 2: (zopakování z&nbsp;minula) s&nbsp;vyu¾itím protokolu JDWP mù¾e
s&nbsp;bì¾ící (cílovou) JVM komunikovat prakticky libovolný proces; nemusí se
tedy ve v¹ech pøípadech jednat o aplikaci naprogramovanou v&nbsp;Javì.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Základ JDI: tøída com.sun.jdi.Bootstrap a rozhraní com.sun.jdi.VirtualMachineManager</h2>

<p>Pøi pou¾ití rozhraní <i>JDI</i> se hned v&nbsp;poèáteèních fázích vývoje
jednoduchého debuggeru setkáme s&nbsp;tøídou nazvanou
<strong>com.sun.jdi.Bootstrap</strong> a s&nbsp;rozhraním
<strong>com.sun.jdi.Interface VirtualMachineManager</strong> (v&nbsp;názvech
pou¾ívám i jména balíèkù, proto¾e se NEjedná o tøídy a rozhraní ze standardního
Java SE API). Tøída <strong>com.sun.jdi.Bootstrap</strong> je ve skuteènosti
velmi jednoduchá, proto¾e obsahuje pouze jednu metodu nazvanou
<strong>virtualMachineManager</strong>. Tato metoda vrací jedinou instanci
(singleton) tøídy implementující rozhraní <strong>com.sun.jdi.Interface
VirtualMachineManager</strong> (pozor, existuje vìt¹í mno¾ství tøíd se stejným
jménem, ov¹em le¾ící v&nbsp;jiném balíèku):</p>
 
<pre>
com.sun.jdi.Bootstrap
public static VirtualMachineManager virtualMachineManager()
</pre>

<p>Rozhraní <strong>com.sun.jdi.Interface VirtualMachineManager</strong> je ji¾
pro vývojáøe zajímavìj¹í, proto¾e tøídy, které toto rozhraní implementují, musí
obsahovat mj.&nbsp;i následujících deset metod:</p>

<table>
<tr><th>#</th><th>Metoda</th><th>Popis</th></tr>
<tr><td> 1</td><td>int majorInterfaceVersion()</td><td>vrací majoritní èíslo verze rozhraní JDI</td></tr>
<tr><td> 2</td><td>int minorInterfaceVersion()</td><td>vrací minoritní èíslo verze rozhraní JDI</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>LaunchingConnector defaultConnector()</td><td>vrací výchozí konektor typu LaunchingConnector</td></tr>
<tr><td> 4</td><td>List&lt;LaunchingConnector&gt; launchingConnectors()</td><td>vrací v¹echny dostupné (implementované) konektory typu LaunchingConnector</td></tr>
<tr><td> 5</td><td>List&lt;ListeningConnector&gt; listeningConnectors()</td><td>vrací v¹echny dostupné (implementované) konektory typu ListeningConnector</td></tr>
<tr><td> 6</td><td>List&lt;AttachingConnector&gt; attachingConnectors()</td><td>vrací v¹echny dostupné (implementované) konektory typu AttachingConnector</td></tr>
<tr><td> 7</td><td>List&lt;Connector&gt; allConnectors()</td><td>vrací v¹echny dostupné (implementované) konektory &ndash; kombinace pøedchozích metod</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>VirtualMachine createVirtualMachine(Connection connection)</td><td>vytvoøení nové instance virtuálního stroje</td></tr>
<tr><td> 9</td><td>VirtualMachine createVirtualMachine(Connection connection, Process process)</td><td>vytvoøení nové instance virtuálního stroje</td></tr>
<tr><td>10</td><td>List&lt;VirtualMachine&gt;connectedVirtualMachines()</td><td>vrací seznam v¹ech JVM pøipojených k&nbsp;debuggeru</td></tr>
</table>

<p>Tyto metody lze rozdìlit do tøí skupin. Metody z&nbsp;první skupiny jsou
velmi jednoduché, proto¾e pouze slou¾í k&nbsp;vrácení majoritního a minoritního
èísla verze rozhraní <i>JDI</i>. Ve druhé skupinì se nachází metody vracející
instanci jednoho konektoru, popø.&nbsp;seznam v¹ech konektorù daného typu;
ostatnì s&nbsp;metodou <strong>allConnectors()</strong> jsme se ji¾ setkali
minule. Ve tøetí skupinì metod najdeme metody slou¾ící ke spu¹tìní nového
virtuálního stroje Javy, popø.&nbsp;pro zji¹tìní v¹ech takto spu¹tìných JVM.
Tyto metody se vìt¹inou nepou¾ívají pøímo, proto¾e pro spu¹tìní virtuálního
stroje se pou¾ívá spí¹e metoda <strong>Connector.launch()</strong>, kterou si
popí¹eme v&nbsp;dal¹ím textu.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Metody pøedepsané rozhraním <strong>com.sun.jdi.connect.LaunchingConnector</strong></h2>

<p>Nyní si uka¾me, jakým zpùsobem mù¾eme vyu¾ít metodu
<strong>com.sun.jdi.VirtualMachineManager.defaultConnector()</strong>.
Z&nbsp;tabulky uvedené <a href="#k03">v&nbsp;pøedchozí kapitole</a> ji¾ víme,
¾e tato metoda vrátí konektor typu <strong>LaunchingConnector</strong>, co¾
znamená konektor, který je schopen vytvoøit nový virtuální stroj Javy a urèit,
která tøída v&nbsp;novì vytvoøeném JVM bude spu¹tìna (tato tøída musí obsahovat
statickou metodu <strong>main</strong>). <strong>LaunchingConnector</strong> je
ve skuteènosti rozhraní roz¹iøující jiné rozhraní nazvané jednodu¹e
<strong>Connector</strong>:</p>

<pre>
com.sun.jdi.connect 
public interface LaunchingConnector extends Connector
</pre>

<p>V&nbsp;rozhraní <strong>LaunchingConnector</strong> nalezneme pøedpis pro
nìkolik zajímavých metod, které jsou vypsány v&nbsp;tabulce ní¾e:</p>

<table>
<tr><th>#</th><th>Metoda</th><th>Popis</th></tr>
<tr><td>1</td><td>String name()</td><td>vrátí øetìzcový identifikátor konektoru</td></tr>
<tr><td>2</td><td>String description()</td><td>vrátí øetìzec s&nbsp;popisem konektoru v&nbsp;èitelné podobì</td></tr>
<tr><td>3</td><td>Transport transport()</td><td>urèeno pro zji¹tìní transportního mechanismu pou¾itého pro napojení na cílovou (ladìnou) JVM</td></tr>
<tr><td>4</td><td>VirtualMachine launch(Map&lt;String, ? extends Connector.Argument&gt; arguments)</td><td>spu¹tìní cílové JVM s ladìnou aplikací</td></tr>
<tr><td>5</td><td>Map&lt;String,Connector.Argument&gt; defaultArguments()</td><td>vrátí argumenty pou¾ité konektorem spoleènì s&nbsp;výchozími hodnotami tìchto argumentù</td></tr>
</table>

<p>Jak tento konektor spou¹tí nový cílový virtuální stroj Javy se dozvíme a¾
v&nbsp;následujících kapitolách, nyní nás bude zajímat pøedev¹ím poslední
metoda nazvaná <strong>defaultArguments()</strong>. Tato metoda vrátí mapu
(asociativní pole), v&nbsp;ní¾ jsou jako klíèe pou¾ita jména argumentù a
hodnoty jsou typu <strong>Connector.Argument</strong>. Dùle¾ité je, ¾e tuto
mapu není mo¾né roz¹iøovat, pøesnìji øeèeno není mo¾né roz¹íøenou mapu pou¾ít
v&nbsp;metodì <strong>launch()</strong>. Mù¾eme ov¹em mìnit hodnoty
jednotlivých argumentù, co¾ je velmi dùle¾ité, proto¾e v&nbsp;jednom argumentu
je ulo¾en i název tøídy, která se má v&nbsp;novì vytvoøeném virtuálním stroji
Javy spustit.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. První demonstraèní pøíklad &ndash; výpis v¹ech argumentù výchozího konektoru typu LaunchingConnector</h2>

<p>V&nbsp;dne¹ním prvním demonstraèním pøíkladu je ukázáno, jak lze vyu¾ít
metodu <strong>Bootstrap.virtualMachineManager()</strong> pro získání instance
tøídy implementující rozhraní <strong>VirtualMachineManager</strong>. Následnì
je zavolána metoda <strong>VirtualMachineManager.defaultConnector()</strong>
vracející výchozí konektor dostupný v&nbsp;prakticky ka¾dé implementaci JRE.
Tato metoda vrací instanci tøídy implementující rozhraní
<strong>LaunchingConnector</strong>. Jakmile jsme získali tento objekt, mù¾eme
pøes metodu <strong>Connector.defaultArguments()</strong> získat mapu
obsahující jména i hodnoty v¹ech argumentù výchozího konektoru. Tyto informace
jsou následnì vypsány na standardní výstup:</p>

<pre>
import java.util.Map;
&nbsp;
import com.sun.jdi.Bootstrap;
import com.sun.jdi.VirtualMachineManager;
import com.sun.jdi.connect.LaunchingConnector;
import com.sun.jdi.connect.Connector;
import com.sun.jdi.connect.Connector.Argument;
&nbsp;
<i>/**</i>
<i> * Trida, ktera vypise vsechny argumenty</i>
<i> * vychoziho launching connectoru</i>
<i> * (presneji receno konektoru typu LaunchingConnector).</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>JDIListLaunchingConnectorArguments</strong> {
&nbsp;
    public static void main(String[] args) {
<i>        // ziskat (jedinou) instanci tridy implementujici rozhrani VirtualMachineManager</i>
        VirtualMachineManager virtualMachineManager = <strong>Bootstrap.virtualMachineManager()</strong>;
&nbsp;
<i>        // ziskat vychozi launching connector</i>
        LaunchingConnector connector = <strong>virtualMachineManager.defaultConnector()</strong>;
&nbsp;
<i>        // ziskat a vypsat vsechny parametry launching connectoru</i>
<i>        // (kazdy argument je typu com.sun.jdi.connect.Connector.Argument)</i>
        Map&lt;String, Argument&gt; arguments = connector.defaultArguments();
        for (Map.Entry&lt;String, Connector.Argument&gt; argument : arguments.entrySet()) {
            System.out.println(argument.getKey() + "\t" + argument.getValue());
        }
    }
&nbsp;
}
</pre>

<p>Pøeklad prvního demonstraèního pøíkladu se provede následovnì:</p>

<pre>
javac -classpath /usr/lib/jvm/java-6-openjdk/lib/tools.jar:. JDIListLaunchingConnectorArguments.java
</pre>

<p>Spu¹tìní zajistí pøíkaz:</p>

<pre>
java -cp /usr/lib/jvm/java-6-openjdk/lib/tools.jar:. JDIListLaunchingConnectorArguments
</pre>

<p>(v&nbsp;obou pøípadech je nutné udat cestu k&nbsp;javovskému archivu <strong>tools.jar</strong>)</p>

<p>Pøíklad výpisu výchozích parametrù po spu¹tìní na Linuxu:</p>

<pre>
home	home=/usr/lib/jvm/java-6-openjdk/jre
options	options=
main	main=
suspend	suspend=true
quote	quote="
vmexec	vmexec=java
</pre>

<p>Pøíklad výpisu výchozích parametrù po spu¹tìní na MS Windows:</p>

<pre>
home	home=C:\Program Files\Java\jdk1.6.0_01\jre
options	options=
main	main=
suspend	suspend=true
quote	quote="
vmexec	vmexec=java
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Spu¹tìní nového virtuálního stroje Javy s&nbsp;vyu¾itím výchozího konektoru typu LaunchingConnector</h2>

<p>V&nbsp;následujících ètyøech kapitolách si vysvìtlíme, jakým zpùsobem lze
argumenty výchozího konektoru typu <strong>LaunchingConnector</strong>
modifikovat takovým zpùsobem, abychom konektor &bdquo;donutili&ldquo; ke
spu¹tìní virtuálního stroje Javy i se specifikovanou tøídou obsahující metodu
<strong>main</strong>. Zaèneme jednodu¹e &ndash; získáním instance tøídy
implementující rozhraní <strong>LaunchingConnector</strong>. To pro nás není
nic nového, proto¾e stejný kód byl vyu¾it i v&nbsp;prvním demonstraèním
pøíkladu. Jakmile ký¾ený objekt získáme, zavolá se u¾ivatelská metoda nazvaná
<strong>launchVirtualMachine()</strong>, které se pøedá jak získaný objekt
s&nbsp;konektorem, tak i jméno tøídy, která se má spustit v&nbsp;novì vytváøené
JVM:</p>

<pre>
<i>        // ziskat (jedinou) instanci tridy implementujici rozhrani VirtualMachineManager</i>
        VirtualMachineManager virtualMachineManager = Bootstrap.virtualMachineManager();
&nbsp;
<i>        // ziskat vychozi launching connector</i>
        LaunchingConnector connector = virtualMachineManager.defaultConnector();
&nbsp;
<i>        // spustit virtualni stroj Javy</i>
        launchVirtualMachine(connector, "Test");
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Specifikace tøídy, její¾ metoda main() se má v&nbsp;novì vytvoøeném virtuálním stroji spustit</h2>

<p>V&nbsp;u¾ivatelské metodì <strong>launchVirtualMachine()</strong> je nejprve
nutné zmìnit výchozí argumenty konektoru takovým zpùsobem, aby se v&nbsp;novì
vytváøeném virtuálním stroji Javy spou¹tìla vybraná tøída. Tuto funkci zajistí
následující kód:</p>

<pre>
        Map&lt;String, Connector.Argument&gt; arguments = connector.defaultArguments();
        arguments.get("main").setValue(main);
</pre>

<p>Z&nbsp;pøedchozího textu víme, ¾e do mapy vrácené metodou
<strong>Connector.defaultArguments()</strong> sice není mo¾né pøidávat dal¹í
prvky ani není mo¾né prvky odebírat, mù¾eme v¹ak mìnit hodnoty jednotlivých
argumentù. Nás zajímá argument ulo¾ený pod klíèem "main", jemu¾ s&nbsp;vyu¾itím
metody <strong>com.sun.jdi.connect.Connector.Argument.setValue()</strong>
zmìníme výchozí hodnotu "" na jméno konkrétní tøídy, která se má skuteènì
spustit.</p>

<p>Dále se cílový virtuální stroj Javy skuteènì spustí, i kdy¾ výchozím stavem
JVM bude pozastavení &ndash; suspend). Spu¹tìní mù¾e vypadat takto:</p>

<pre>
        try {
            System.out.println("Starting virtual machine");
            VirtualMachine virtualMachine = connector.launch(arguments);
        catch (IOException e) {
            e.printStackTrace();
        }
        catch (IllegalConnectorArgumentsException e) {
            e.printStackTrace();
        }
        catch (VMStartException e) {
            e.printStackTrace();
        }
    }
</pre>

<p>Kompletní tìlo u¾ivatelské metody <strong>launchVirtualMachine()</strong> je
vypsáno pod tímto odstavcem:</p>

<pre>
<i>    /**</i>
<i>     * Spusteni noveho virtualniho stroje Javy.</i>
<i>     *</i>
<i>     * @param connector instance launching connectoru</i>
<i>     * @param main jmeno tridy, ktera se ma v nove JVM spustit</i>
<i>     */</i>
    private static void launchVirtualMachine(LaunchingConnector connector, String main) {
<i>        // zmena hodnoty argumentu se jmenem "main"</i>
        Map&lt;String, Connector.Argument&gt; arguments = connector.defaultArguments();
        arguments.get("main").setValue(main);
&nbsp;
<i>        // spusteni virtualniho stroje Javy</i>
        try {
            System.out.println("Starting virtual machine");
            VirtualMachine virtualMachine = connector.launch(arguments);
<i>            // precteni standardniho vystupu spustene JVM</i>
            processVMStandardOutput(virtualMachine);
            System.out.println("Virtual machine stopped");
        }
        catch (IOException e) {
            e.printStackTrace();
        }
        catch (IllegalConnectorArgumentsException e) {
            e.printStackTrace();
        }
        catch (VMStartException e) {
            e.printStackTrace();
        }
    }
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Pøeètení standardního výstupu spu¹tìného virtuálního stroje Javy</h2>

<p>Zbývají nám vyøe¹it dva problémy, které spolu úzce souvisí. První problém
spoèívá v&nbsp;tom, ¾e je vìt¹inou nutné, aby debugger pøeèetl standardní a
vìt¹inou i chybový výstup aplikace bì¾ící v&nbsp;cílovém JVM. Pokud by
k&nbsp;prùbì¾nému ètení nedocházelo, byla by ladìná aplikace bì¾ící
v&nbsp;cílovém JVM pozastavena ve chvíli, kdy by se naplnily vyrovnávací
buffery standardního a chybového výstupu. Tento problém vyøe¹íme tak, ¾e
získáme objekt typu <strong>Process</strong>, který reprezentuje proces cílové
JVM. Následnì lze získat standardní/chybový výstup tohoto procesu
s&nbsp;vyu¾itím metod <strong>Process.getInputStream()</strong> a
<strong>Process.getErrorStrem()</strong>. Pojmenování tìchto metod je ponìkud
matoucí, ale pøi bli¾¹ím pohledu pochopitelné, proto¾e standardní/chybový
výstup <i>jiného</i> procesu je pro <i>souèasný</i> proces vstupním proudem,
nikoli proudem výstupním. Standardní výstup získáme takto:</p>

<pre>
        Process process = virtualMachine.process();
        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
</pre>

<p>Jakmile je standardní výstup pøesmìrován, lze cílovou JVM znovu
&bdquo;rozjet&ldquo; metodou <strong>VirtualMachine.resume</strong>:</p>

<pre>
<i>        // zmena stavu suspend-&gt;resume</i>
        virtualMachine.resume();
</pre>

<p>Následnì je nutné peèlivì pøeèíst celý standardní výstup cílové JVM. Celý
kód zaji¹»ující spu¹tìní cílové JVM s&nbsp;pøeètením jejího standardního
výstupu vypadá následovnì:</p>

<pre>
<i>    /**</i>
<i>     * Precteni standardniho vystupu spustene JVM</i>
<i>     *</i>
<i>     * @param virtualMachine nove spustena JVM</i>
<i>     * @throws IOException</i>
<i>     */</i>
    private static void processVMStandardOutput(VirtualMachine virtualMachine) throws IOException {
        Process process = virtualMachine.process();
<i>        // nenechte se zmast - standardni vystup jineho procesu</i>
<i>        // je z naseho pohledu vstupem!</i>
        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
&nbsp;
<i>        // zmena stavu suspend-&gt;resume</i>
        virtualMachine.resume();
&nbsp;
<i>        // precist standardni vystup nove JVM</i>
        String line;
        while ((line = reader.readLine()) != null) {
            System.out.println("Child VM output: " + line);
        }
        reader.close();
    }
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Druhý demonstraèní pøíklad &ndash; spu¹tìní nové JVM s&nbsp;pøeètením výstupu testovací aplikace</h2>

<p>Nyní si ji¾ mù¾eme ukázat kompletní zdrojový kód druhého demonstraèního
pøíkladu, který vytvoøí novou instanci virtuálního stroje Javy a v&nbsp;tomto
JVM spustí tøídu nazvanou jednodu¹e "Main". Ve¹kerý text zapisovaný na
standardní výstup cílové JVM je zachycen:</p>

<pre>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Map;
&nbsp;
import com.sun.jdi.Bootstrap;
import com.sun.jdi.VirtualMachine;
import com.sun.jdi.VirtualMachineManager;
import com.sun.jdi.connect.Connector;
import com.sun.jdi.connect.IllegalConnectorArgumentsException;
import com.sun.jdi.connect.LaunchingConnector;
import com.sun.jdi.connect.VMStartException;
&nbsp;
<i>/**</i>
<i> * Spusteni noveho virtualniho stroje Javy</i>
<i> * a precteni jeho standardniho vystupu.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>JDILaunchingConnectorTest</strong> {
&nbsp;
    public static void main(String[] args) {
<i>        // ziskat (jedinou) instanci tridy implementujici rozhrani VirtualMachineManager</i>
        VirtualMachineManager virtualMachineManager = <strong>Bootstrap.virtualMachineManager()</strong>;
&nbsp;
<i>        // ziskat vychozi launching connector</i>
        LaunchingConnector connector = <strong>virtualMachineManager.defaultConnector()</strong>;
&nbsp;
<i>        // spustit virtualni stroj Javy</i>
        launchVirtualMachine(connector, "Test");
    }
&nbsp;
<i>    /**</i>
<i>     * Spusteni noveho virtualniho stroje Javy.</i>
<i>     *</i>
<i>     * @param connector instance launching connectoru</i>
<i>     * @param main jmeno tridy, ktera se ma v nove JVM spustit</i>
<i>     */</i>
    private static void launchVirtualMachine(LaunchingConnector connector, String main) {
<i>        // zmena hodnoty argumentu se jmenem "main"</i>
        Map&lt;String, Connector.Argument&gt; arguments = connector.defaultArguments();
        arguments.get("main").setValue(main);
&nbsp;
<i>        // spusteni virtualniho stroje Javy</i>
        try {
            System.out.println("Starting virtual machine");
            VirtualMachine virtualMachine = connector.launch(arguments);
<i>            // precteni standardniho vystupu spustene JVM</i>
            processVMStandardOutput(virtualMachine);
            System.out.println("Virtual machine stopped");
        }
        catch (IOException e) {
            e.printStackTrace();
        }
        catch (IllegalConnectorArgumentsException e) {
            e.printStackTrace();
        }
        catch (VMStartException e) {
            e.printStackTrace();
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Precteni standardniho vystupu spustene JVM</i>
<i>     *</i>
<i>     * @param virtualMachine nove spustena JVM</i>
<i>     * @throws IOException</i>
<i>     */</i>
    private static void processVMStandardOutput(VirtualMachine virtualMachine) throws IOException {
        Process process = virtualMachine.process();
<i>        // nenechte se zmast - standardni vystup jineho procesu</i>
<i>        // je z naseho pohledu vstupem!</i>
        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
&nbsp;
<i>        // zmena stavu suspend-&gt;resume</i>
        virtualMachine.resume();
&nbsp;
<i>        // precist standardni vystup nove JVM</i>
        String line;
        while ((line = reader.readLine()) != null) {
            System.out.println("Child VM output: " + line);
        }
        reader.close();
    }
&nbsp;
}
</pre>

<p>Samotná tøída <strong>Test</strong> je velmi jednoduchá:</p>

<pre>
public class Test {
&nbsp;
    public static void main(String[] args) {
        for (int i = 0; i &lt; 10; i++) {
            System.out.println("Hello world!");
        }
    }
&nbsp;
}
</pre>

<p>Pøeklad druhého demonstraèního pøíkladu zajistí pøíkaz:</p>

<pre>
javac -classpath /usr/lib/jvm/java-6-openjdk/lib/tools.jar:. JDILaunchingConnectorTest.java
</pre>

<p>Spu¹tìní se provede pøíkazem:</p>

<pre>
java -cp /usr/lib/jvm/java-6-openjdk/lib/tools.jar:. JDILaunchingConnectorTest
</pre>

<p>Po spu¹tìní by se mìl na standardní výstup vypsat následující text:</p>

<pre>
Starting virtual machine
Child VM output: Hello world!
Child VM output: Hello world!
Child VM output: Hello world!
Child VM output: Hello world!
Child VM output: Hello world!
Child VM output: Hello world!
Child VM output: Hello world!
Child VM output: Hello world!
Child VM output: Hello world!
Child VM output: Hello world!
Virtual machine stopped
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Odkazy na Internetu</h2>

<ol>

<li>Breakpoint (Wikipedia)<br />
<a href="http://cs.wikipedia.org/wiki/Breakpoint">http://cs.wikipedia.org/wiki/Breakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation<br />
<a href="http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html">http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; SetBreakpoint<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#SetBreakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#SetBreakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; ClearBreakpoint<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#ClearBreakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#ClearBreakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; Breakpoint (callback funkce)<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#Breakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#Breakpoint</a>
</li>

<li>The JVM Tool Interface (JVM TI): How VM Agents Work<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html">http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html</a>
</li>

<li>Creating a Debugging and Profiling Agent with JVMTI<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html">http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html</a>
</li>

<li>JVM TI (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/JVM_TI">http://en.wikipedia.org/wiki/JVM_TI</a>
</li>

<li>IBM JVMTI extensions<br />
<a href="http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html">http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

