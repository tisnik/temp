<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - základy optimalizace aplikací naprogramovaných v Javì</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - základy optimalizace aplikací naprogramovaných v Javì</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o virtuálním stroji Javy se seznámíme se základními technikami optimalizace aplikací naprogramovaných v Javì. Postupnì se seznámíme jak s vysokoúrovòovými optimalizacemi, tak i s nastavováním a ladìním samotného virtuálního stroje Javy (co¾ se týká pøedev¹ím GC a JITu).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - základy optimalizace aplikací naprogramovaných v Javì</a></p>
<p><a href="#k02">2. Optimalizace na úrovni implementovaných algoritmù</a></p>
<p><a href="#k03">3. Vliv JRE a JVM na chování aplikací naprogramovaných v Javì</a></p>
<p><a href="#k04">4. JIT pøekladaè typu client a server</a></p>
<p><a href="#k05">5. Pou¾ití vhodných typù kolekcí</a></p>
<p><a href="#k06">6. Pole a dal¹í mo¾nosti náhrady kolekcí</a></p>
<p><a href="#k07">7. Nízkoúrovòové optimalizace &ndash; mají vùbec v&nbsp;Javì smysl?</a></p>
<p><a href="#k08">8. Ladìní parametrù JVM (aneb JIT ani GC nejsou samospasitelné)</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - základy optimalizace aplikací naprogramovaných v Javì</h2>

<p><a href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">Seriál o
programovacím jazyku Java i o virtuálním stroji Javy</a> ji¾ dosáhl své
devadesáté páté èásti, pøièem¾ jsme si v&nbsp;pøedchozích dílech
mj.&nbsp;vysvìtlili i problematiku monitorování JVM, základy fungování správcù
pamìti i vlastnosti bajtkódu JVM. Prozatím jsme se v¹ak hloubìji a
systematiètìji nezabývali zpùsoby optimalizace aplikací naprogramovaných
v&nbsp;Javì, i kdy¾ právì optimalizace na základì rùzných hledisek by mìla být
(alespoò v&nbsp;ideálním svìtì :-) souèástí vývoje a testování. Pomìrnì velké
mno¾ství vývojáøù se testováním výkonnosti a optimalizací svých aplikací pøíli¹
nezabývá, a to z&nbsp;mnoha dùvodù &ndash; a» ji¾ se jedná o nedostatek èasu èi
o pocit, ¾e vy¹¹ího výkonu lze snadno dosáhnout výkonnìj¹ím hardwarem (co¾ si
uká¾eme, ¾e nemusí být v¾dy pravda) èi ¾e se o &bdquo;vyladìní&ldquo; aplikace
nìjak postará pøekladaè a/nebo samotný virtuální stroj Javy (to je také mnohdy
dosti vzdáleno od skuteènosti).</p>

<p>Pøi pohledu do rùzných diskuzních fór je patrné, ¾e pohled na JVM a Javovské
aplikace bì¾nì osciluje mezi dvìma názorovými extrémy. Na jedné stranì stojí
názor (bohu¾el nìkdy potvrzený ¹patnì naprogramovanou aplikací èi mizernou
JVM), ¾e Javovské aplikace vy¾adují neúmìrné mno¾ství operaèní pamìti a ¾e
jejich rychlost daleko zaostává za aplikacemi napsanými v&nbsp;C/C++/D èi
v&nbsp;dal¹ích kompilovaných programovacích jazycích. Na druhé stranì
názorového spektra se tvrdí, ¾e díky existenci JIT (Just-In-Time) pøekladaèe
Javovské aplikace dosahují stejného výkonu, jako aplikace nativní. Pravda ve
skuteènosti le¾í nìkde uprostøed; my si pøedev¹ím v&nbsp;dal¹ích dílech tohoto
seriálu øekneme podrobnosti o práci JIT pøekladaèe, proto¾e teprve
s&nbsp;pochopením jeho funkcionality je mo¾né si uvìdomit, za jakých okolností
vlastnì JIT zaèíná provádìt pøeklad a jaké programové konstrukce mu mohou
pomoci èi naopak znesnadnit jeho práci.</p>

<p>Upozornìní: dne¹ní èlánek sice nebude obsahovat mnoho konkrétních informací
o JIT pøekladaèích ani o GC, to se v¹ak v&nbsp;dal¹ích èástech napraví.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Optimalizace na úrovni implementovaných algoritmù</h2>

<p>Zpùsoby optimalizace (nejenom) Javovských aplikací lze rozdìlit na nìkolik
úrovní. Na úrovni nejvy¹¹í a vìt¹inou také nejdùle¾itìj¹í stojí dobrá
implementace algoritmu, který má øe¹it daný problém. Typickým ¹kolním :-)
pøíkladem bývá pøedvedení algoritmù pro setøídìní prvkù nìjaké kolekce èi pole.
Naivní algoritmy typu <i>Bubble Sort</i> mají slo¾itost O(n<sup>2</sup>), ov¹em
lze pou¾ít také algoritmy typu <i>Merge Sort</i> se slo¾itostí O(n*log(n))
&ndash; tento algoritmus mimochodem není nutné implementovat, proto¾e ho
najdeme (dokonce v&nbsp;nìkolika rùzných modifikacích)
v&nbsp;<strong>java.util.Arrays.sort()</strong> a
<strong>java.util.Collections.sort()</strong>. Dal¹ím pøíkladem, tentokrát
odpozorovaným z&nbsp;reálných aplikací, byla nevhodnì navr¾ená struktura
programù takovým zpùsobem, ¾e se nìkolikrát naèítal a zbyteènì zpracovával
stejný soubor &ndash; konkrétnì se jednalo o XML soubor obsahující konfiguraci
programu, jen¾ byl v&nbsp;jedné aplikaci naèítán a zpracováván hned nìkolikrát,
poka¾dé se pøitom získávala odli¹ná informace (ulo¾ená v&nbsp;jiném uzlu).</p>

<p>Do této úrovnì optimalizace je takté¾ mo¾né zaøadit implementaci daného
algoritmu takovým zpùsobem, aby se dobøe vyu¾ily mo¾nosti mikroprocesorù
s&nbsp;více jádry. Samotný pøekladaè ani virtuální stroj Javy toti¾ nejsou
v&nbsp;souèasnosti na takové úrovni, aby dokázaly výpoèty dobøe a automaticky
paralelizovat &ndash; pøitom právì zde by mohl vysokoúrovòový jazyk
s&nbsp;vlastní VM excelovat a pøekonat tak tradièní kompilované jazyky, jak je
to ostatnì dobøe patrné na pøíkladu <a
href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">Clojure</a>.
Paralelizace výpoètù je tak vìt¹inou nutné øe¹it pøímo pøi tvorbì zdrojového
kódu programu, co¾ je v&nbsp;Javì slo¾ité a mù¾e vést k&nbsp;mnoha tì¾ko
odhalitelným chybám (typické deadlocky èi naopak nesynchronizovaný pøístup
k&nbsp;nìjakému objektu). Urèité vylep¹ení v&nbsp;této oblasti pøinesla a¾ Java
8, co¾ je v¹ak problematika, které se budeme podrobnìji vìnovat v&nbsp;dal¹í
èásti tohoto seriálu.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Vliv JRE a JVM na chování aplikací naprogramovaných v Javì</h2>

<p>Na bìh aplikací naprogramovaných v&nbsp;Javì má výrazný vliv i vybrané JRE a
JVM (samotný virtuální stroj). Pøipomeòme si, ¾e virtuální stroj Javy se skládá
ze tøí hlavních subsystémù. Jedná se o <strong>JIT pøekladaè</strong>,
<strong>správce pamìti</strong> a <strong>bìhové prostøedí</strong> (runtime
&ndash; interpret, standardní class loader, synchronizaèní mechanismy, správce
vláken). Nejprve se budeme zabývat JIT pøekladaèi, kvùli jejich velkému vlivu
na výkon aplikací. V&nbsp;souèasnosti se mù¾eme setkat s&nbsp;dvìma typy JIT
pøekladaèù &ndash; <i>client</i> a <i>server</i>, které se v&nbsp;nových JVM
kombinují do takzvaného vícevrstvého pøekladaèe <i>tiered compiler</i>
(principem jeho práce se opìt budeme zabývat pozdìji).</p>

<p>Velký vliv na výkon javovských aplikací má i pou¾itý správce pamìti. Podobnì
jako existují dva typy JIT pøekladaèù, máme dnes k&nbsp;dispozici i vìt¹í
mno¾ství správcù pamìti, z&nbsp;nich¾ ka¾dý je vhodný pouze pro urèitý úèel a
pro urèitou velikost haldy, na ní¾ jsou ukládány v¹echny objekty. Správce
pamìti (<i>garbage collector</i>) je spou¹tìn v&nbsp;samostatném vláknu èi více
vláknech, tak¾e pracuje paralelnì s&nbsp;bì¾ící aplikací. Operace provádìné
správcem pamìti samozøejmì nemohou probíhat zcela nezávisle na aplikaci,
proto¾e se napøíklad provádí defragmentace haldy (heapu), s&nbsp;èím¾ souvisí
potøeba nìkteré objekty uzamykat &ndash; právì v&nbsp;tìchto chvílích mù¾e být
bìh aplikace pozastavován, a to i na systémech, které jsou vybaveny
mikroprocesory s&nbsp;více jádry (u nìkterých správcù pamìti se proto setkáme
s&nbsp;termínem <i>stop-the-world</i>).</p>

<p>Nesmíme zapomínat ani na bìhové prostøedí (<i>runtime</i>). Vliv interpretru
si èásteènì osvìtlíme <a href="#k04">v&nbsp;navazující kapitole</a>, dùle¾itý
je v¹ak i systém synchronizace. V&nbsp;souèasnosti je v&nbsp;JVM implementován
takzvaný optimistický mechanismus zámkù, který pøedpokládá, ¾e je velmi
pravdìpodobné, ¾e o zámek bude ¾ádat v¾dy stále to stejné vlákno, které tento
zámek ihned získá. Pokud tomu tak není (objekt je zamèen jiným vláknem, ...),
je synchronizace obecnì èasovì nároènìj¹í, s&nbsp;èím¾ je zapotøebí poèítat i
pøi návrhu èi optimalizacích aplikace.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. JIT pøekladaè typu client a server</h2>

<p>V&nbsp;pøedchozí kapitole jsme si øekli, ¾e v&nbsp;souèasných JVM se setkáme
s&nbsp;dvojicí JIT pøekladaèù &ndash; client a server.</p>

<p>Oba typy pøekladaèù se spou¹tí <i>a¾ na základì po¾adavku interpretru</i>
&ndash; bajtkód ka¾dé metody je tedy nejdøíve relativnì pomalu interpretován a
teprve poté, pokud se daná metoda volá èasto nebo pokud se nìkterá smyèka
v&nbsp;metodì opakuje po zadanou mez, se metoda èi jen její èasto opakovaná
smyèka pøelo¾í. Pøitom platí, ¾e pøekladaè typu <i>client</i> je navr¾en
takovým zpùsobem, ¾e velmi jednodu¹e a tudí¾ i rychle danou sekvenci instrukcí
bajtkódu pøelo¾í na základì &bdquo;¹ablony&ldquo; obsahující (velmi
zjednodu¹enì øeèeno) sekvenci strojových instrukcí pro ka¾dou instrukci
bajtkódu. Provádí se pøitom je minimální mno¾ství optimalizací, tak¾e od tohoto
typu pøekladaèe nelze èekat ¾ádné zázraky.</p>

<p>Naproti tomu pøekladaè typu <i>server</i> ji¾ doká¾e provádìt rùzné lokální
i globální optimalizace a takté¾ stráví vìt¹í mno¾ství èasu s&nbsp;alokací
registrù mikroprocesoru pro potøeby ulo¾ení lokálních promìnných, mezivýsledkù
výpoètù atd. atd. Ov¹em aby tento typ pøekladaèe pracoval skuteènì efektivnì,
musí mít k&nbsp;dispozici vìt¹í mno¾ství informací o dynamických vlastnostech
metody/smyèky &ndash; a tyto informace získá opìt z&nbsp;interpretru.
Zjednodu¹enì øeèeno to znamená, ¾e èím vícekrát je metoda/smyèka zpracována
pomalým interpretrem, tím lep¹í informace má k&nbsp;dispozici optimalizující
JIT pøekladaè, tak¾e se dostáváme do ponìkud paradoxní situace, ¾e pro
dlouhotrvající aplikace je výhodnìj¹í, kdy¾ jsou nìjaký èas provozovány jen
v&nbsp;re¾imu interpretru (jak to pøesnì funguje a jak je mo¾né nastavit
pøíslu¹né parametry JVM si øekneme pøí¹tì).</p>

<p>Z&nbsp;vý¹e uvedeného takté¾ vyplývá, ¾e JIT pøekladaèe typu <i>server</i>
nemusí být v¾dy výhodnìj¹í a pro aplikace bì¾ící jen krátkou dobu mù¾e být JIT
pøekladaè typu <i>client</i> lep¹í volbou. Výkon JIT pøekladaèù se takté¾
postupnì vylep¹uje, co¾ je patrné i z&nbsp;následující tabulky porovnávající
dobu bìhu jednoho benchmarku (zmínìného pøí¹tì) na dvou rùzných JVM
v&nbsp;re¾imu interpretru, JIT pøekladaèe typu <i>client</i> i JIT pøekladaèe
typu <i>server</i>:</p>

<table>
<tr><th>Pøekladaè/interpret</th><th>Java 1.6.0</th><th>Java 1.7.0_25</th></tr>
<tr><td>-Xint  </td><td>5018676954 ns</td><td>5016002314 ns</td></tr>
<tr><td>-client</td><td>&nbsp;407990681 ns</td><td>&nbsp;409226033 ns</td></tr>
<tr><td>-server</td><td>&nbsp;512994248 ns</td><td>&nbsp;334564030 ns</td></tr>
</table>

<p>Pov¹imnìte si toho, ¾e interpret je více ne¾ 10&times; pomalej¹í
v&nbsp;porovnání s&nbsp;JIT i toho, jak se vylep¹ily vlastnosti JIT typu
<i>server</i>.</p>

<p>Poznámka: pokud se spoléháte na to, ¾e na poèítaèích klientù bude v¾dy
pou¾it JIT pøekladaè typu <i>server</i>, je nutné zde upozornit na fakt, ¾e pro
32bitové systémy se ji¾ Oracle JRE 7 dodává jen a pouze ve verzi <i>client</i>.
Kdo potøebuje i JIT <i>server</i>, musí si nainstalovat celé JVM (nebo pou¾ít
OpenJDK, co¾ je vìt¹inou lep¹í volba).</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Pou¾ití vhodných typù kolekcí</h2>

<p>Jen pro úplnost je nutné v&nbsp;tomto èlánku zmínit i nutnost pou¾ití
vhodného typu kolekcí, popø.&nbsp;zvá¾it, zda pou¾ití klasických polí nepovede
k&nbsp;nárùstu výkonu aplikace. Následující tabulka se ètyømi typy kolekcí a
jejich základními implementacemi je velmi pravdìpodobnì ètenáøùm tohoto èlánku
dobøe známá:</p>

<table>
<tr><th>Rozhraní</th><th>Implementace<br />polem</th><th>Implementace<br />stromem</th><th>Implementace<br />seznamem</th><th>Implementace<br />hash mapou</th></tr>
<tr><td>Set  </td><td>&nbsp;    </td><td>TreeSet</td><td>&nbsp;    </td><td>HashSet, LinkedHashSet</td></tr>
<tr><td>Map  </td><td>&nbsp;    </td><td>TreeMap</td><td>&nbsp;    </td><td>HashMap, LinkedHashMap</td></tr>
<tr><td>List </td><td>ArrayList </td><td>&nbsp; </td><td>LinkedList</td><td>&nbsp;</td></tr>
<tr><td>Deque</td><td>ArrayDeque</td><td>&nbsp; </td><td>LinkedList</td><td>&nbsp;</td></tr>
</table>

<p>Z&nbsp;této tabulky je patrné, ¾e ka¾dé rozhraní je implementováno minimálnì
dvakrát, nìkdy i tøikrát. To má samozøejmì svùj význam, proto¾e ka¾dá
implementace má odli¹né chování. Nás bude nejvíce zajímat èasová slo¾itost,
kterou lze pomìrnì snadno zjistit pohledem do zdrojových kódù (ty jsou
v&nbsp;JDK k&nbsp;dispozici). Pro ilustraci si uveïme èasovou slo¾itost
nìkterých operací provádìných nad kolekcí typu <i>List</i>:</p>

<table>
<tr><th>Operace</th><th>ArrayList</th><th>LinkedList</th></tr>
<tr><td>set(index,E) </td><td>O(1)  </td><td>O(n)</td></tr>
<tr><td>get(index)   </td><td>O(1)  </td><td>O(n)</td></tr>
<tr><td>add(index,E) </td><td>O(n)  </td><td>O(n)</td></tr>
<tr><td>remove(index)</td><td>O(n)  </td><td>O(n)</td></tr>
<tr><td>toArray()    </td><td>O(n) *</td><td>O(n) **</td></tr>
</table>

<p>* - provádí se kopie celého pole, ** - provádí se postupné kopírování prvkù do pole</p>

<p>Podobnì lze zjistit èasovou slo¾itost kolekce typu <i>Deque</i> (co¾ je
kolekce sdru¾ující vlastnosti obousmìrné fronty a seznamu):</p>

<table>
<tr><th>Operace</th><th>ArrayDeque</th><th>LinkedList</th></tr>
<tr><td>addFirst()   </td><td>O(1) nebo O(n)</td><td>O(1)</td></tr>
<tr><td>addLast()    </td><td>O(1) nebo O(n)</td><td>O(1)</td></tr>
<tr><td>removeFirst()</td><td>O(1)          </td><td>O(1)</td></tr>
<tr><td>removeLast() </td><td>O(1)          </td><td>O(1)</td></tr>
<tr><td>getFirst()   </td><td>O(1)          </td><td>O(1)</td></tr>
<tr><td>getLast()    </td><td>O(1)          </td><td>O(1)</td></tr>
<tr><td>toArray()    </td><td>O(n) *        </td><td>O(n) **</td></tr>
</table>

<p>* - provádí se kopie celého pole, ** - provádí se postupné kopírování prvkù do pole</p>

<p>Podobnì je mo¾né snadno zjistit vlastnosti a rozdíly mezi dvojicí
<i>HashSet/TreeSet</i> a <i>HashMap/TreeMap</i>. Dal¹í alternativou je pou¾ití
<i>ConcurrentHashMap</i>, která v&nbsp;nìkterých pøípadech nabízí vy¹¹í výkonnost
(tu je ov¹em nutné otestovat pomocí profileru).</p>

<p>Ov¹em implementace kolekcí, která je dodávaná pøímo s&nbsp;JRE, není
v&nbsp;¾ádném pøípadì jediná existující implementace. K&nbsp;dispozici jsou
toti¾ i mnohé dal¹í implementace, které se li¹í jak pou¾itými algoritmy, tak i
zpùsobem ulo¾ení kolekce na haldì.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Pole a dal¹í mo¾nosti náhrady kolekcí</h2>

<p>Kolekce se v&nbsp;Javì pou¾ívají velmi jednodu¹e, co¾ v¹ak mù¾e znamenat, ¾e
je programátor nìkdy bezmy¹lenkovitì vyu¾ije i tam, kde to není vhodné.
Existuje toti¾ pomìrnì velké mno¾ství situací, v&nbsp;nich¾ jsou bì¾ná pole
mnohem efektivnìj¹í, a to jak z&nbsp;hlediska obsazené pamìti, tak i
z&nbsp;hlediska rychlosti pøístupu k&nbsp;prvkùm. Typickým pøíkladem je nutnost
ukládat prvky primitivních datových typù, co¾ není u kolekcí mo¾né &ndash; zde
je nutné aplikovat autoboxing, který je èasovì nároèný a navíc i objekt
obalující hodnotu primitivního datového typu obsadí velké mno¾ství pamìti na
haldì (tu navíc prochází správce pamìti, èím¾ výkonnostní problémy je¹tì
narùstají). Navíc jsou v¹echny operace s&nbsp;polem pøekládány do k&nbsp;tomu
urèených instrukcí bajtkódu, zatímco pøi práci s&nbsp;kolekcemi libovolného
typu je nutné stále volat pøíslu¹né metody (add, remove, get, set, ...).</p>

<p>Sice by se mohlo zdát, ¾e JIT pøekladaèe si s&nbsp;tímto problémem poradí,
ale jak ji¾ bylo naznaèeno <a href="#k04">ve ètvrté kapitole</a>, není vhodné
se slepì spoléhat na magické schopnosti JITu, u¾ jen z&nbsp;toho dùvodu, ¾e se
v&nbsp;mnoha pøípadech ve skuteènosti bude kód pouze interpretovat. Ostatnì
uka¾me si jednoduchý odstra¹ující pøíklad:</p>

<pre>
import java.util.*;
&nbsp;
public class Test {
&nbsp;
    private static final int LIST_SIZE = 5000;
&nbsp;
    public static void main(String[] args) {
        List&lt;Integer&gt; x = new ArrayList&lt;Integer&gt;(LIST_SIZE);
        for (int i = 0; i &lt; LIST_SIZE; i++) {
            x.add(i);
        }
    }
&nbsp;
}
</pre>

<p>V&nbsp;tomto pøíkladu je seznam celých èísel ulo¾en velmi neefektivnì (kvùli
autoboxingu), samotné vlo¾ení jednoho prvku znamená volání nìkolika metod a
navíc je velikost seznamu (5000 prvkù) tak malá, ¾e se ani nespustí JIT
pøekladaè typu <i>server</i>! Mù¾eme se o tom sami pøesvìdèit:</p>

<pre>
javac Test.java
java -server -XX:+UnlockDiagnosticVMOptions -XX:+PrintCompilation Test
</pre>

<p>(tyto pøepínaèe budou podrobnì vysvìtleny pøí¹tì).</p>

<p>Naproti tomu je práce s&nbsp;poli podporována pøímo v&nbsp;bajtkódu, a to
konkrétnì následujícími instrukcemi:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Provádìná operace</th></tr>
<tr><td>1</td><td>newarray</td><td>0xBC</td><td>arraytype</td><td>Vytvoøí nové pole s prvky primitivního datového typu</td></tr>
<tr><td>2</td><td>anewarray</td><td>0xBD</td><td>highbyte, lowbyte</td><td>Vytvoøí nové pole objektù</td></tr>
<tr><td>3</td><td>multianewarray</td><td>0xC5</td><td>highbyte, lowbyte, dimensions</td><td>Vytvoøí vícedimenzionální pole o <i>dimensions</i> dimenzích</td></tr>
<tr><td>4</td><td>iaload</td><td>0x2E</td><td>&times;</td><td>pøeètení prvku z pole typu int[]</td></tr>
<tr><td>5</td><td>laload</td><td>0x2F</td><td>&times;</td><td>pøeètení prvku z pole typu long[]</td></tr>
<tr><td>6</td><td>faload</td><td>0x30</td><td>&times;</td><td>pøeètení prvku z pole typu float[]</td></tr>
<tr><td>7</td><td>daload</td><td>0x31</td><td>&times;</td><td>pøeètení prvku z pole typu double[]</td></tr>
<tr><td>8</td><td>aaload</td><td>0x32</td><td>&times;</td><td>pøeètení prvku z pole typu reference[]</td></tr>
<tr><td>9</td><td>baload</td><td>0x33</td><td>&times;</td><td>pøeètení prvku z pole typu byte[] nebo boolean[]</td></tr>
<tr><td>10</td><td>caload</td><td>0x34</td><td>&times;</td><td>pøeètení prvku z pole typu char[]</td></tr>
<tr><td>11</td><td>saload</td><td>0x35</td><td>&times;</td><td>pøeètení prvku z pole typu short[]</td></tr>
<tr><td>12</td><td>iastore</td><td>0x4F</td><td>&times;</td><td>zápis nové hodnoty prvku do pole typu int[]</td></tr>
<tr><td>13</td><td>lastore</td><td>0x50</td><td>&times;</td><td>zápis nové hodnoty prvku do pole typu long[]</td></tr>
<tr><td>14</td><td>fastore</td><td>0x51</td><td>&times;</td><td>zápis nové hodnoty prvku do pole typu float[]</td></tr>
<tr><td>15</td><td>dastore</td><td>0x52</td><td>&times;</td><td>zápis nové hodnoty prvku do pole typu double[]</td></tr>
<tr><td>16</td><td>aastore</td><td>0x53</td><td>&times;</td><td>zápis nové hodnoty prvku do pole typu reference[]</td></tr>
<tr><td>17</td><td>bastore</td><td>0x54</td><td>&times;</td><td>zápis nové hodnoty prvku do pole typu byte[] nebo boolean[]</td></tr>
<tr><td>18</td><td>castore</td><td>0x55</td><td>&times;</td><td>zápis nové hodnoty prvku do pole typu char[]</td></tr>
<tr><td>19</td><td>sastore</td><td>0x56</td><td>&times;</td><td>zápis nové hodnoty prvku do pole typu short[]</td></tr>
<tr><td>20</td><td>arraylength</td><td>0xBE</td><td>&times;</td><td>zji¹tìní délky pole</td></tr>
</table>

<p>Pøístup k&nbsp;prvkùm pole se vìt¹inou pøekládá do tøí krokù (viz té¾
napøíklad zdrojový soubor
<i>hotspot/src/cpu/x86/vm/templateTable_x86_32.cpp</i> ve zdrojových kódech
OpenJDK):</p>

<ol>
<li>Kontrola, zda objekt pøedstavující pole není <strong>null</strong></li>
<li>Kontrola, zda index je men¹í ne¾ mez pole</li>
<li>Vlastní ètení/zápis (1-2 instrukce)</li>
</ol>

<p>Optimalizaèní pøekladaè mù¾e první dva kroky zcela eliminovat a dosáhnout
tak rychlosti srovnatelné s&nbsp;pøelo¾eným céèkem.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Nízkoúrovòové optimalizace &ndash; mají vùbec v&nbsp;Javì smysl?</h2>

<p>Ponìkud pøekvapující mù¾e být fakt, ¾e i nìkteré &bdquo;nízkoúrovòové&ldquo;
zásahy do zdrojového kódu mohou vylep¹it èas bìhu aplikace. Podívejme se na
velmi jednoduchý (i kdy¾ tro¹ku umìlý) pøíklad aplikace, v&nbsp;ní¾ se vyplòuje
pole sekvencí celých èísel. Jsou pou¾ity dva typy smyèek, pøièem¾ v&nbsp;první
smyèce se neustále (v&nbsp;ka¾dé iteraci) ète atribut
<strong>array.length</strong>, zatímco ve druhé smyèce je tato hodnota ulo¾ena
do pomocné lokální konstanty. Ka¾dá smyèka probìhne dvakrát, první kolo je
zahøívací:</p>

<pre>
public class ArrayTest1 {
    public static final int ARRAY_SIZE = 20000;
&nbsp;
    public static void main(String[] args) throws InterruptedException {
        System.out.println(System.getProperty("java.version"));
&nbsp;
        for (int i=0; i&lt;2; i++) {
            long t1, t2;
&nbsp;
            System.gc();
            Thread.sleep(1000);
            t1 = System.nanoTime();
            test1();
            t2 = System.nanoTime();
            System.out.println("Method #1: " + (t2 - t1) + " ns");
&nbsp;
            System.gc();
            Thread.sleep(1000);
            t1 = System.nanoTime();
            test2();
            t2 = System.nanoTime();
            System.out.println("Method #2: " + (t2 - t1) + " ns");
        }

    }
&nbsp;
    private static void test1() {
        int[] array = new int[ARRAY_SIZE];
        for (int i = 0; i &lt; ARRAY_SIZE; i++) {
            for (int j = 0; j &lt; array.length; j++) {
                array[j] = j;
            }
        }
    }
&nbsp;
    private static void test2() {
        int[] array = new int[ARRAY_SIZE];
        final int length = array.length;
        for (int i = 0; i &lt; ARRAY_SIZE; i++) {
            for (int j = 0; j &lt; length; j++) {
                array[j] = j;
            }
        }
    }
</pre>

<p>Jak dopadnou èasy bìhu obou typù smyèek lze snadno zjistit:</p>

<pre>
java -Xint ArrayTest1
1.7.0_25
Method #1: 21546434533 ns
Method #2: 20551668997 ns
Method #1: 21568800224 ns
Method #2: 20092864038 ns
&nbsp;
java -client ArrayTest1
1.7.0_25
Method #1: 2066722727 ns
Method #2: 1711408014 ns
Method #1: 2065038433 ns
Method #2: 1719504295 ns
&nbsp;
java -server ArrayTest1
1.7.0_25
Method #1: 1401953601 ns
Method #2: 1361821964 ns
Method #1: 1393230703 ns
Method #2: 1360679360 ns
</pre>

<p>Nejzajímavìj¹í jsou rozdíly v&nbsp;èasech bìhu obou smyèek pøi pou¾ití JIT
pøekladaèe typu <i>client</i>, kdy se èasy li¹í o zhruba 16%, tak¾e uvedená
&bdquo;optimalizace&ldquo; má kupodivu smysl. K&nbsp;tomu je nutno brát
v&nbsp;úvahu ji¾ zmínìný fakt, ¾e novìj¹í JRE 7 jsou spoleèností Oracle na
32bitové systémy dodávány jen s&nbsp;JIT pøekladaèem typu <i>client</i>, tak¾e
se spoléhat na to, ¾e <i>JIT server</i> v¹e pøelo¾í stejnì (viz té¾ tøetí bìh)
nemusí být v¾dy na místì.</p>

<p>Proè je v¹ak JIT typu <i>client</i> pomalej¹í v&nbsp;prvním pøípadì? Je tomu
tak z&nbsp;toho dùvodu, ¾e &bdquo;¹ablona&ldquo; instrukce
<strong>arraylength</strong> (volaná pøed ka¾dou iterací!) obsahuje i kontrolu
na to, zda není pøedaný objekt roven <strong>null</strong>. JIT typu
<i>server</i> ji¾ dopøedu ví (dozví se to z&nbsp;interpretru), ¾e objekt není
roven <strong>null</strong> a mù¾e tuto kontrolu zcela vynechat, rozbalit
smyèku, rozdìlit ji na tøi èásti (viz té¾ dal¹í díl) atd.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Ladìní parametrù JVM (aneb JIT ani GC nejsou samospasitelné)</h2>

<p>Pøi snaze o optimalizaci javovských aplikací je vhodné mít neustále na
pamìti, ¾e i kdy¾ JIT pøekladaèe a správci pamìti (GC), které najdeme
v&nbsp;dostupných virtuálních strojích Javy, patøí mezi ty nejlep¹í
technologie, které jsou v&nbsp;souèasnosti dostupné, nejsou a ani nemohou být
samospasitelné. To je sice pochopitelné, ponìkud hùøe se v¹ak akceptuje fakt,
¾e souèasné JIT a GC nedoká¾ou dobøe automaticky mìnit své chování
v&nbsp;závislosti na vlastnostech bì¾ící aplikace. Asi nejvíce je tento problém
palèivý pøi nastavování haldy a správcù pamìti, kdy je mnohdy nutné nejenom
zvolit konkrétního správce pamìti, ale i nastavit, kolik vláken má tento
správce pamìti vyu¾ít (to se navíc odli¹uje pøi takzvaném FullGC a rychlém
bìhu), v&nbsp;jakém pomìru má být halda rozdìlena na èásti <i>young</i> a
<i>tenured</i>, jak má být èást <i>young</i> rozdìlena na dal¹í bloky (eden,
survivor space1, survivor space2) atd. Podobné nastavování nás èeká pøi
optimalizacích bìhu JIT pøekladaèe.</p>

<p>Aby si vá¾ený ètenáø sám udìlal pøehled, kolika volbami lze vlastnì JVM
ovlivnit, staèí napsat pøíkaz:</p>

<pre>
java -XX:+PrintFlagsFinal -version
</pre>

<p>V&nbsp;pøípadì JDK 1.7.0_25 se vypí¹e více ne¾ 600 parametrù!</p>

<pre>
[Global flags]
    uintx AdaptivePermSizeWeight                    = 20              {product}           
    uintx AdaptiveSizeDecrementScaleFactor          = 4               {product}           
    uintx AdaptiveSizeMajorGCDecayTimeScale         = 10              {product}           
    uintx AdaptiveSizePausePolicy                   = 0               {product}           
    uintx AdaptiveSizePolicyCollectionCostMargin    = 50              {product}           
    uintx AdaptiveSizePolicyInitializingSteps       = 20              {product}           
    uintx AdaptiveSizePolicyOutputInterval          = 0               {product}           
    uintx AdaptiveSizePolicyWeight                  = 10              {product}           
    uintx AdaptiveSizeThroughPutPolicy              = 0               {product}           
    uintx AdaptiveTimeWeight                        = 25              {product}           
     bool AdjustConcurrency                         = false           {product}           
     bool AggressiveOpts                            = false           {product}           
...
...
...
    uintx YoungGenerationSizeIncrement              = 20              {product}           
    uintx YoungGenerationSizeSupplement             = 80              {product}           
    uintx YoungGenerationSizeSupplementDecay        = 8               {product}           
    uintx YoungPLABSize                             = 4096            {product}           
     bool ZeroTLAB                                  = false           {product}           
     intx hashCode                                  = 0               {product
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (pøed verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

