<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - øetìzce na haldì (dokonèení) a vyu¾ití JVM TI pro ladìní</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - øetìzce na haldì (dokonèení) a vyu¾ití JVM TI pro ladìní</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o jazyce Java i o vlastnostech JVM nejprve dokonèíme téma, kterým jsme se zaèali zabývat v pøedchozím díle &ndash; uká¾eme si, jakým zpùsobem jsou vyu¾ívány (krátké) øetìzce ve vybrané reálné Javovské aplikaci. Ve druhé polovinì èlánku si øekneme, jak lze vyu¾ít rozhraní JVM TI pro ladìní (debugging).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Prùchod haldou a výpis v¹ech øetìzcù ulo¾ených na haldì</a></p>
<p><a href="#k02">2. Callback funkce <strong>jvmtiStringPrimitiveValueCallback()</strong></a></p>
<p><a href="#k03">3. Demonstraèní agent èíslo 25 &ndash; výpis øetìzcù ulo¾ených na haldì</a></p>
<p><a href="#k04">4. Statistika vyu¾ití øetìzcù v&nbsp;jednoduchém testovacím pøíkladu (Test25)</a></p>
<p><a href="#k05">5. Statistika vyu¾ití øetìzcù v&nbsp;reálné aplikaci (Freemind)</a></p>
<p><a href="#k06">6. Vyu¾ití rozhraní JVM TI pro ladìní (debugging) javovských aplikací</a></p>
<p><a href="#k07">7. Zji¹tìní v¹ech atributù vybrané tøídy</a></p>
<p><a href="#k08">8. Demonstraèní agent èíslo 26 &ndash; výpis informací o v¹ech atributech vybrané tøídy</a></p>
<p><a href="#k09">9. Zdrojové kódy obou demonstraèních agentù a k&nbsp;nim pøíslu¹ných testovacích pøíkladù</a></p>
<p><a href="#k10">10. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Prùchod haldou a výpis v¹ech øetìzcù ulo¾ených na haldì</h2>

<p>V&nbsp;pøedchozí èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyce Java i o vlastnostech virtuálního stroje Javy</a> jsme se
seznámili s&nbsp;tím, jakým zpùsobem jsou ulo¾eny øetìzce na haldì
(<i>heapu</i>) virtuálního stroje (JVM). Dnes popis této pomìrnì dùle¾ité
problematiky dokonèíme, proto¾e si uká¾eme demonstraèního <i>JVM TI</i> agenta,
který doká¾e vypsat v¹echny øetìzce ulo¾ené na haldì &ndash; z&nbsp;tìchto
informací posléze budeme moci získat alespoò rámcovou pøedstavu o tom, jak
pamì»ovì nároèná je práce s&nbsp;øetìzci v&nbsp;jednoduchém demonstraèním
pøíkladu (<a href="#k04">kapitola 4</a>) i v&nbsp;reálné desktopové aplikaci
<i>Freemind</i> (<a href="#k05">kapitola 5</a>). Toto mìøení v¹ak samozøejmì
lze provést i pro ostatní javovské aplikace, napøíklad i pro aplikaèní servery
a na nich nasazené (<i>deploy</i>) aplikace. Pøipomeòme si v¹ak nejdøíve, jakým
zpùsobem jsou øetìzce na haldì ulo¾eny. Øetìzec je pøedstavován dvojicí objektù
&ndash; instancí tøídy <strong>String</strong> a instancí pole
<strong>char[]</strong>, které je atributem tøídy <strong>String</strong>.</p>

<p>Pole <strong>char[]</strong> mohou být ve skuteènosti sdílená mezi vìt¹ím
mno¾stvím øetìzcù, proto¾e ka¾dá instance tøídy <strong>String</strong>
obsahuje dal¹í dva dùle¾ité atributy &ndash; <i>délku</i> øetìzce (ve znacích)
a <i>offset</i> od zaèátku pole <strong>char[]</strong>. Díky tomu je napøíklad
mo¾né implementovat metodu <strong>String.substring()</strong> takovým
zpùsobem, ¾e se neprovádí èasovì i pamì»ovì nároèné vytváøení nového pole se
znaky, ale prostì se vrátí nová instance tøídy <strong>String</strong> se
stejným atributem <strong>char[]</strong>, ov¹em s&nbsp;rozdílnými hodnotami
atributù <strong>count</strong> a <strong>offset</strong> a samozøejmì té¾
posledního atributu <strong>hash</strong> (proè je mo¾né
<strong>String.substring()</strong> takto implementovat je zøejmé &ndash;
øetìzce jsou v&nbsp;Javì nemìnné neboli <i>immutable</i>). Ka¾dá instance tøídy
<strong>String</strong> zabere na haldì vìt¹inou 24 bajtù (platí pro 32bitové
JVM i 64bitové JVM s&nbsp;relativnì malou velikostí haldy), jak je to ostatnì
patrné i pøi pohledu na následující tabulku:</p>

<table>
<tr><th>#</th><th>Velikost (B)</th><th>Struktura</th><th>Popis</th></tr>
<tr><td>1</td><td>8</td><td>HEADER    </td><td>hlavièka objektu (pøiøazena ka¾dému objektu na haldì)</td></tr>
<tr><td>2</td><td>4</td><td>int offset</td><td>atribut <strong>offset</strong> instance tøídy String</td></tr>
<tr><td>3</td><td>4</td><td>int count </td><td>atribut <strong>count</strong> instance tøídy String</td></tr>
<tr><td>4</td><td>4</td><td>int hash  </td><td>atribut <strong>hash</strong> instance tøídy String</td></tr>
<tr><td>5</td><td>4</td><td>char[]    </td><td>reference na pole znakù</td></tr>
</table>

<p>(Potenciálnì) sdílené pole <strong>char[]</strong> má na haldì samozøejmì
promìnnou délku v&nbsp;závislosti na tom, kolik znakù øetìzec skuteènì
obsahuje:</p>

<table>
<tr><th>#</th><th>Velikost (B)</th><th>Struktura</th><th>Popis</th></tr>
<tr><td>1</td><td>8</td><td>HEADER</td><td>hlavièka objektu (pøiøazena ka¾dému objektu na haldì)</td></tr>
<tr><td>2</td><td>4</td><td>int length</td><td>délka pole = délka øetìzce ve znacích</td></tr>
<tr><td>3</td><td>length*2</td><td>char[] </td><td>vlastní obsah øetìzce (char má dva bajty)</td></tr>
<tr><td>4</td><td>0 nebo 2</td><td>PADDING</td><td>výplò, aby celková délka objektu byla dìlitelná ètyømi (nìkdy osmi)</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Callback funkce <strong>jvmtiStringPrimitiveValueCallback()</strong></h2>

<p>Nyní tedy ji¾ víme, jak jsou øetìzce na haldì ulo¾eny. Teoreticky ji¾
dokonce umíme v¹echny øetìzce na haldì pøeèíst, proto¾e by postaèovalo projít
instancemi v¹ech tøíd s&nbsp;vyu¾itím callback funkce
<strong>jvmtiHeapReferenceCallback()</strong>, vybrat z&nbsp;nich v¹echny
instance tøídy <strong>String</strong> (co¾ není tì¾ké) a potom s&nbsp;vyu¾itím
callback funkce <strong>jvmtiArrayPrimitiveValueCallback()</strong> projít
v¹emi poli znakù (char[]) a z&nbsp;nich nìjakým zpùsobem vyfiltrovat pouze ta
pole, která jsou atributy instancí tøíd <strong>String</strong>. Ov¹em vzhledem
k&nbsp;tomu, ¾e se s&nbsp;øetìzci pracuje skuteènì velmi èasto a navíc i proto,
¾e øetìzce mají (jako objekty) v&nbsp;Javì ponìkud zvlá¹tní postavení, existuje
v&nbsp;rozhraní <i>JVM TI</i> pro prùchod øetìzci speciální typ callback funkce
<strong>jvmtiStringPrimitiveValueCallback()</strong>. Ukazatel na tuto callback
funkci lze ulo¾it do struktury <strong>jvmtiHeapCallbacks</strong>, kterou si
v&nbsp;tomto seriálu ji¾ uká¾eme skuteènì naposledy:</p>

<pre>
<strong>typedef struct</strong> {
    jvmtiHeapIterationCallback        heap_iteration_callback;
    jvmtiHeapReferenceCallback        heap_reference_callback;
    jvmtiPrimitiveFieldCallback       primitive_field_callback;
    jvmtiArrayPrimitiveValueCallback  array_primitive_value_callback;
    <strong>jvmtiStringPrimitiveValueCallback string_primitive_value_callback;</strong>
    jvmtiReservedCallback             reserved5;
    jvmtiReservedCallback             reserved6;
    jvmtiReservedCallback             reserved7;
    jvmtiReservedCallback             reserved8;
    jvmtiReservedCallback             reserved9;
    jvmtiReservedCallback             reserved10;
    jvmtiReservedCallback             reserved11;
    jvmtiReservedCallback             reserved12;
    jvmtiReservedCallback             reserved13;
    jvmtiReservedCallback             reserved14;
    jvmtiReservedCallback             reserved15;
} <strong>jvmtiHeapCallbacks</strong>;
</pre>

<p>Ukazatel zapsaný do polo¾ky datové struktury
<strong>jvmtiHeapCallbacks.jvmtiStringPrimitiveValueCallback</strong> musí
obsahovat adresu callback funkce, její¾ hlavièka má následující tvar:</p>

<pre>
jint JNICALL <strong>jvmtiStringPrimitiveValueCallback</strong>(
     jlong        class_tag, 
     jlong        size, 
     jlong*       tag_ptr, 
     const jchar* value, 
     jint         value_length, 
     void*        user_data);
</pre>

<p>Vidíme, ¾e této callback funkci, která mù¾e být zavolána pro ka¾dý øetìzec
ulo¾ený na haldì, se pøi jejím zavolání pøedá ¹estice parametrù, z&nbsp;nich¾
nìkteré ji¾ známe z&nbsp;dal¹ích callback funkcí, ale nìkteré parametry jsou
zde zcela nové:</p>

<table>
<tr><th>#</th><th>Typ parametru</th><th>Jméno parametru</th><th>Význam</th></tr>
<tr><td>1</td><td>jlong </td><td>class_tag</td><td>tag pøiøazený ke tøídì, které je objekt instancí (bude to v¾dy tøída String)</td></tr>
<tr><td>2</td><td>jlong </td><td>size</td><td>celková velikost alokovaná pro <strong>objekt</strong> na haldì (typicky 24 bajtù)</td></tr>
<tr><td>3</td><td>jlong*</td><td>tag_ptr</td><td>ukazatel na tag pøiøazený k&nbsp;objektu</td></tr>
<tr><td>4</td><td>char* </td><td>value</td><td>obsah øetìzce v&nbsp;Unicode (modifikovaný UTF-8)</td></tr>
<tr><td>5</td><td>jint  </td><td>value_length</td><td>délka øetìzce (odpovídá poètu 16bitových znakù)</td></tr>
<tr><td>6</td><td>void* </td><td>user_data</td><td>ukazatel na u¾ivatelská data (má stejný význam, jaký ji¾ známe z minula)</td></tr>
</table>

<p>V&nbsp;prvním parametru se pøedává tag pøiøazený ke tøídì, její¾ instancí se
právì na haldì prochází. V&nbsp;této callback funkci by se v¾dy mìlo jednat o
tag pøiøazený ke tøídì <strong>String</strong>, co¾ si ostatnì mù¾eme otestovat
na demonstraèním <i>JVM TI</i> agentovi. Ve druhém parametru je pøedávána
velikost instance této tøídy, co¾ je (mo¾ná ponìkud pøekvapivì) konstantní
hodnota &ndash; vìt¹inou 24 bajtù. Proè tomu tak je bylo vysvìtleno <a
href="#k01">v&nbsp;pøedchozí kapitole</a>. U¾iteènìj¹í je pátý parametr
obsahující skuteènou délku øetìzce a samozøejmé té¾ ètvrtý parametr
s&nbsp;vlastním obsahem øetìzce. Z&nbsp;toho vyplývá, ¾e <i>JVM TI</i> doká¾e
automaticky zpárovat instanci tøídy <strong>String</strong> s&nbsp;pøíslu¹nou
instancí pole <strong>char[]</strong>, tak¾e tuto relativnì slo¾itou èinnost
nemusíme dìlat ruènì.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Demonstraèní agent èíslo 25 &ndash; výpis øetìzcù ulo¾ených na haldì</h2>

<p>Informace získané <a href="#k02">v&nbsp;pøedchozí kapitole</a> vyu¾ijeme ve
dvacátém pátém demonstraèním <i>JVM TI</i> agentovi, v&nbsp;nìm¾ je
implementována speciální callback funkce pojmenovaná
<strong>callback_for_each_string()</strong>, která musí být zaregistrována pøes
<strong>heap_callbacks.string_primitive_value_callback</strong>. Zpùsob
registrace této callback funkce je ukázán na následujícím úryvku kódu, kde
nejprve dojde k&nbsp;vlastní registraci callback funkce a následnì se zahájí
procházení haldou:</p>

<pre>
<i>/*</i>
<i> * Registrace callback funkce pro prochazeni haldou a zacatek prochazeni.</i>
<i> */</i>
static void <strong>register_heap_callback_and_run_dump</strong>(jvmtiEnv *jvmti_env)
{
    jvmtiError error;
    jvmtiHeapCallbacks heap_callbacks;
    t_heap_stat heap_stat = {0,0};
&nbsp;
<i>    /* naplnit strukturu heap_callbacks jednou callback funkci */</i>
    (void)memset(&amp;heap_callbacks, 0, sizeof(heap_callbacks));
    heap_callbacks.string_primitive_value_callback = &amp;callback_for_each_string;
&nbsp;
<i>    /* zahajit prochazeni haldou */</i>
    error = (*jvmti_env)-&gt;IterateThroughHeap(jvmti_env, 0, NULL,
            &amp;heap_callbacks, (const void *)&amp;heap_stat);
    check_jvmti_error(jvmti_env, error, "read heap content");
&nbsp;
<i>    /* vypis statistiky o obsazeni haldy */</i>
    printf("String count: %d\n", heap_stat.arrays_count);
    printf("Total size:   %ld bytes\n", heap_stat.total_size);
}
</pre>

<p>Pro ka¾dý øetìzec nalezený na haldì se vypí¹e délka tohoto øetìzce (uvedená
ve znacích), velikost objektu pøedstavujícího øetìzec (jak jsme se ji¾ zmínili,
bude zde vìt¹inou konstantní hodnota 24) a následnì se øetìzec vypí¹e, ale pro
jistotu se budou vypisovat jen znaky s&nbsp;kódy 32 a¾ 127, proto¾e øetìzec
(resp. pøesnìji øeèeno jednotlivé znaky v&nbsp;nìm ulo¾ené) jsou reprezentovány
v&nbsp;modifikovaném kódu <i>UTF-8</i>, s&nbsp;ním¾ se v&nbsp;èistém céèku
pracuje dosti obtí¾nì. V&nbsp;modifikovaném <i>UTF-8</i> je znak ulo¾en
v&nbsp;jednom a¾ tøech bajtech, tj.&nbsp;délka je promìnná a oproti normálnímu
kódování <i>UTF-8</i> zde existuje omezení na maximálnì tøíbajtové sekvence.
Navíc je zaruèeno, ¾e ASCII znaky 0x00 a¾ 0x7f jsou reprezentovány jedním
bajtem s&nbsp;ASCII kódem, zatímco v¹echny znaky s&nbsp;kódem 0x80 a¾ 0x7ff
jsou ulo¾eny ve dvou bajtech a znaky s&nbsp;kódem 0x800 a¾ 0xffff ve tøech
bajtech &ndash; v&nbsp;tomto pøípadì v¹ak mají v¹echny bajty nastaven nejvy¹¹í
bit na jednièku, tj.&nbsp;jejich hodnota je vìt¹í ne¾ 127.</p>

<p>Pokud tedy budeme v&nbsp;øetìzci vyhledávat a následnì tisknout pouze bajty
s&nbsp;hodnotou men¹í ne¾ 128, je zaruèeno, ¾e se provede tisk pouze ASCII
znakù a nikoli napøíklad &bdquo;rozsypaného èaje&ldquo;:</p>

<pre>
<i>/*</i>
<i> * Callback funkce volana pro kazdy retezec.</i>
<i> */</i>
static jint JNICALL <strong>callback_for_each_string</strong>(
        jlong  class_tag, 
        jlong  size, 
        jlong* tag_ptr, 
        const  jchar* value,
        jint   value_length,
        void*  user_data)
{
    int i;
    printf("length: %4d chars,  size: %ld bytes    ",
        value_length, (long int)size);
&nbsp;
<i>    /* velmi zjednoduseny tisk *podmnoziny* Unicode znaku */</i>
    putchar('"');
    for (i=0; i&lt;value[i]; i++)
    {
        if (value[i] &gt;= 32 &amp;&amp; value[i] &lt;= 127)
        {
            putchar(value[i]);
        }
    }
    putchar('"');
    putchar('\n');
&nbsp;
<i>    /* spocitani statistickych informaci o obsazeni haldy */</i>
    t_heap_stat *heap_stat = (t_heap_stat*)user_data;
    heap_stat-&gt;arrays_count++;
    heap_stat-&gt;total_size += size;
&nbsp;
<i>    /* pokracovat dale v prochazeni haldy */</i>
    return JVMTI_VISIT_OBJECTS;
}
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Statistika vyu¾ití øetìzcù v&nbsp;jednoduchém testovacím pøíkladu (Test25)</h2>

<p>Celý zdrojový kód demonstraèního <i>JVM TI</i> agenta èíslo 25 je, podobnì
jako i pøedchozí demonstraèní agenti, dostupný <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">v&nbsp;Mercurial
repositáøi</a>. Zajímavé bude zjistit, kolik øetìzcù je ulo¾eno na haldì
virtuálního stroje Javy v&nbsp;pøípadì, ¾e je v&nbsp;JVM spu¹tìn pouze velmi
jednoduchý a krátký pøíklad, jeho¾ zdrojový kód je vypsán pod tímto
odstavcem:</p>

<pre>
<i>/**</i>
<i>  * Testovaci trida pouzita pro test dvacateho</i>
<i>  * pateho demonstracniho JVM TI agenta.</i>
<i>  */</i>
public class <strong>Test25</strong> {
<i>    /**</i>
<i>      * Spusteni testu.</i>
<i>      */</i>
    public static void <strong>main</strong>(String[] args) {
        String s1 = "Hello world!";
        String s2 = "http://www.root.cz";
        String s3 = "abcdefghijklmnopqrstuvwxyz";
        String s4 = "Pøíli¹ ¾lu»ouèký kùò úpìl ïábelské ódy";
    }
}
</pre>

<p>Vidíme, ¾e v&nbsp;této testovací tøídì jsou pou¾ity pouze ètyøi øetìzce,
ov¹em ve skuteènosti bude na haldì bì¾ící JVM ulo¾eno øetìzcù mnohem více. Po
pøekladu <i>JVM TI</i> agenta i testovací tøídy <i>Test25</i> se virtuální
stroj Javy spustí následujícím pøíkazem:</p>

<pre>
gcc -Wall -ansi -I/usr/lib/jvm/java-1.6.0-openjdk/include/ -shared -o libagent25.so agent25.c
javac -g Test25.java
</pre>

<p>I kdy¾ v¹ichni oèekáváme, ¾e na haldì bude ulo¾eno vìt¹í mno¾ství øetìzcù,
mù¾e být výsledek i tak pomìrnì pøekvapivý:</p>

<pre>
Agent25: Agent_OnLoad
Agent25: JVM TI version is correct
Agent25: Got VM init event
Agent25: Got VM Death event
Agent25: Got data dump request
class java.io.BufferedOutputStream  has tag 1
class java.lang.Class$3  has tag 2
class java.util.Enumeration  has tag 3
...
...
...
class [Z has tag 371
class [B has tag 372
class [C has tag 373
class [I has tag 374
class [S has tag 375
class [J has tag 376
class [F has tag 377
class [D has tag 378
length:   15 chars,  size: 24 bytes    "Java heap space"
length:   13 chars,  size: 24 bytes    "PermGen space"
length:   37 chars,  size: 24 bytes    "Requested array size exceeds VM limit"
length:   26 chars,  size: 24 bytes    "GC overhead limit exceeded"
length:    9 chars,  size: 24 bytes    "/ by zero"
length:    4 chars,  size: 24 bytes    "main"
length:    4 chars,  size: 24 bytes    "main"
length:   90 chars,  size: 24 bytes    "Method sun.misc.Unsafe.prefetchRead(Ljava/lang/Object;J"
length:  108 chars,  size: 24 bytes    "Method sun.misc.Unsafe.copyMemory(Ljava/lang/Object;JLjava"
...
...
...
length:    5 chars,  size: 24 bytes    "java."
length:    4 chars,  size: 24 bytes    "main"
length:   12 chars,  size: 24 bytes    "Hello world!"
length:   18 chars,  size: 24 bytes    "http://www.root.cz"
length:   26 chars,  size: 24 bytes    "abcdefghijklmnopqrstuvwxyz"
length:   38 chars,  size: 24 bytes    "Pli luouk k pl belsk"
Strings count: 927
Total size:   22248 bytes
Agent25: Agent_OnUnload
</pre>

<p>Na haldì je tedy ulo¾eno celkem 927 øetìzcù (toto èíslo se mù¾e na va¹í JVM
o nìkolik procent mìnit) a velikost pamìti obsazené <i>pouze</i> instancemi
tøídy <strong>String</strong>, nikoli tedy vlastními øetìzci
<strong>char[]</strong>, dosahuje pøibli¾né hodnoty dvacet jedna kilobajtù.
V&nbsp;následující tabulce jsou vypsány dal¹í zajímavé statistické
informace:</p>

<table>
<tr><td>Poèet øetìzcù</td><td>927</td></tr>
<tr><td>Minimální délka øetìzce</td><td>0 znakù</td></tr>
<tr><td>Maximální délka øetìzce</td><td>517 znakù</td></tr>
<tr><td>Prùmìrná délka øetìzce</td><td>15,6 znakù</td></tr>
<tr><td>Medián</td><td>10 znakù</td></tr>
<tr><td>Prùmìrná efektivita ulo¾ení</td><td>44%</td></tr>
</table>

<p>Prùmìrná délka øetìzce ani medián nám ov¹em nedají zcela pøesnou informaci o
tom, jak dlouhé øetìzce ve skuteènosti na haldì najdeme. Proto si navíc je¹tì
uká¾eme histogram, na jeho¾ horizontální osu je nanesena délka øetìzce (ve
znacích) a na osu vertikální pak poèet øetìzcù majících tuto délku. Histogram
je zobrazen pro dva rùzné rozsahy horizontální osy: první zobrazuje frekvenci
výskytu øetìzcù s&nbsp;délkou 0-600 znakù a druhý pouze øetìzce s&nbsp;délkou
0-100 znakù:</p>

<a href="http://www.root.cz/obrazek/117192/"><img src="http://i.iinfo.cz/images/430/jvm-62-2-prev.png" class="image-117192" width="370" height="258" alt="&#160;" /></a>
<p><i>Obrázek 1: Histogram s&nbsp;frekvencí výskytu øetìzcù s&nbsp;délkou 0-600 znakù.</i></p>

<a href="http://www.root.cz/obrazek/117193/"><img src="http://i.iinfo.cz/images/430/jvm-62-3-prev.png" class="image-117193" width="370" height="236" alt="&#160;" /></a>
<p><i>Obrázek 2: Histogram s&nbsp;frekvencí výskytu øetìzcù s&nbsp;délkou 0-100 znakù.</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Statistika vyu¾ití øetìzcù v&nbsp;reálné aplikaci (Freemind)</h2>

<p>Pro malé javovské programy lze pøedpokládat, ¾e se na haldì budou nacházet
pøedev¹ím objekty vytvoøené a vyu¾ívané pøímo virtuálním strojem Javy, co¾ bude
platit i o øetìzcích. O tom jsme se ostatnì mohli pøesvìdèit v&nbsp;pøedchozím
pøípadì, kdy javovský program obsahoval pouze ètyøi explicitnì zadané øetìzce,
zatímco na haldì jich bylo ulo¾eno celkem 927. Pøitom se vìt¹inou jednalo o
velmi krátké øetìzce s&nbsp;prùmìrnou délkou 15,6 znakù a s&nbsp;mediánem
dokonce pouhých 10 znakù. Zkusme tedy vyu¾ít na¹eho <i>JVM TI</i> agenta pro
získání statistiky o øetìzcích pro reálnou aplikaci. Bude se jednat o pomìrnì
známý desktopový program <i>Freemind</i> slou¾ící pro tvorbu takzvaných
my¹lenkových map. Jedná se o støednì velkou aplikaci, tak¾e získané informace
by mohly být pomìrnì zajímavé.</p>

<a href="http://www.root.cz/obrazek/117191/"><img src="http://i.iinfo.cz/images/430/jvm-62-1-prev.png" class="image-117191" width="370" height="270" alt="&#160;" /></a>
<p><i>Obrázek 3: Screenshot programu Freemind ve chvíli, kdy je virtuální stroj
monitorován JVM TI agentem èíslo 25.</i></p>

<p><i>Freemind</i> se spou¹tí pomocí skriptu, v&nbsp;nìm¾ se nastavují cesty
k&nbsp;rùzným Java archivùm. Tento skript bylo pro potøeby mìøení <i>JVM TI</i>
agentem nutné upravit do následující podoby (která je ov¹em závislá na
konkrétních adresáøích, kde jsou ulo¾eny Java archivy):</p>

<pre>
CLASSPATH=\
/usr/share/java/SimplyHTML.jar:\
/usr/share/java/gnu-regexp.jar:\
/usr/share/java/jibx-run.jar:\
/usr/share/java/xpp3.jar:\
/usr/share/freemind/lib/bindings.jar:\
/usr/share/freemind/lib/freemind.jar:\
/usr/share/java/commons-lang.jar:\
/usr/share/java/forms.jar
&nbsp;
java -agentpath:./libagent25.so -Xmx256M -Dfreemind.base.dir="/usr/share/freemind" -cp "${CLASSPATH}" freemind.main.FreeMindStarter
</pre>

<p>Po spu¹tìní tohoto skriptu dojde k&nbsp;zobrazení grafického u¾ivatelského
rozhraní <i>Freemindu</i> a je mo¾né s&nbsp;ním normálnì pracovat. A¾ teprve
pøi ukonèování èinnosti virtuálního stroje se zavolá callback funkce
v&nbsp;<i>JVM TI</i> agentovi, která nastartuje procházení v¹emi øetìzci na
haldì:</p>

<pre>
Checking Java Version...
Agent25: Agent_OnLoad
Agent25: JVM TI version is correct
Agent25: Got VM init event
Agent25: Got VM Death event
Agent25: Got data dump request
class freemind.modes.common.GotoLinkNodeAction  has tag 1
class sun.awt.image.IntegerComponentRaster  has tag 2
class javax.swing.plaf.PanelUI  has tag 3
class sun.awt.MostRecentKeyValue  has tag 4
class javax.swing.plaf.basic.BasicHTML$BasicHTMLViewFactory  has tag 5
class java.util.TaskQueue  has tag 6
class java.util.Currency  has tag 7
class sun.awt.X11.XNETProtocol  has tag 8
class sun.awt.X11.XProtocolConstants  has tag 9
...
...
...
class [[S has tag 3405
class [[[S has tag 3406
class [J has tag 3407
class [[J has tag 3408
class [F has tag 3409
class [[F has tag 3410
class [D has tag 3411
class [[D has tag 3412
length:   31 chars,  size: 24 bytes    "End paint in 213. Mean time:247"
length:    0 chars,  size: 24 bytes    " "
length:    9 chars,  size: 24 bytes    "18.1.2013"
length:    8 chars,  size: 24 bytes    "23:38:41"
length:    0 chars,  size: 24 bytes    " "
length:    4 chars,  size: 24 bytes    "cs__"
length:   97 chars,  size: 24 bytes    "18.1.2013 23:38:41 freemind.view.mindmapview.MapView"
length:   38 chars,  size: 24 bytes    "Java_java_awt_AWTEvent_nativeSetSource"
length:   58 chars,  size: 24 bytes    "Java_sun_awt_X11_XWindow_haveCurrentX11InputMethodInstance"
length:   51 chars,  size: 24 bytes    "Java_sun_awt_X11_XWindow_x11inputMethodLookupString"
length:   20 chars,  size: 24 bytes    "The X.Org Foundation"
length:   40 chars,  size: 24 bytes    "Java_sun_awt_X11_XlibWrapper_IsKeypadKey"
length:   17 chars,  size: 24 bytes    "type = FocusOut, "
length:   31 chars,  size: 24 bytes    "type = FocusOut, serial = 695, "
...
...
...
length:   10 chars,  size: 24 bytes    "US/Central"
length:   10 chars,  size: 24 bytes    "US/Eastern"
length:    9 chars,  size: 24 bytes    "US/Hawaii"
length:   17 chars,  size: 24 bytes    "US/Indiana-Starke"
length:   15 chars,  size: 24 bytes    "US/East-Indiana"
length:   11 chars,  size: 24 bytes    "US/Michigan"
length:   11 chars,  size: 24 bytes    "US/Mountain"
length:   10 chars,  size: 24 bytes    "US/Pacific"
length:   14 chars,  size: 24 bytes    "US/Pacific-New"
length:    8 chars,  size: 24 bytes    "US/Samoa"
length:    3 chars,  size: 24 bytes    "VST"
length:    4 chars,  size: 24 bytes    "W-SU"
length:    4 chars,  size: 24 bytes    "Zulu"
length:   17 chars,  size: 24 bytes    "filter_conditions"
Strings count: 29737
Total size:   713688 bytes
Agent25: Agent_OnUnload
</pre>

<p>Pro tuto prùmìrnou desktopovou aplikaci se tedy na haldì vytvoøilo necelých
tøicet tisíc(!) øetìzcù a pouze instance tøídy <strong>String</strong> zabraly
témìø 700 kilobajtù (do této velikosti nejsou poèítána pole
<strong>char[]</strong>). V&nbsp;následující tabulce jsou zobrazeny dal¹í
zajímavé statistické informace:</p>

<table>
<tr><td>Poèet øetìzcù</td><td>29737</td></tr>
<tr><td>Minimální délka øetìzce</td><td>0 znakù</td></tr>
<tr><td>Maximální délka øetìzce</td><td>10387 znakù</td></tr>
<tr><td>Prùmìrná délka øetìzce</td><td>23,7 znakù</td></tr>
<tr><td>Medián</td><td>16 znakù</td></tr>
<tr><td>Prùmìrná efektivita ulo¾ení</td><td>55 %</td></tr>
</table>

<p>Prùmìrná délka øetìzce i medián se oproti první testovací aplikaci zvý¹ily,
co¾ znamená, ¾e se zlep¹ila i efektivita ulo¾ení øetìzcù (pomìr mezi obsazením
haldy znaky dìlený celkovým obsazením instancemi tøíd <strong>String</strong> a
jejími atributy <strong>char[]</strong>). Podívejme se takté¾ na histogramy.
První histogram opìt ukazuje frekvenci øetìzcù s&nbsp;délkami 0 a¾ 600 znakù a
druhý pouze frekvence øetìzcù s&nbsp;délkou 0 a¾ 100 znakù.</p>

<a href="http://www.root.cz/obrazek/117194/"><img src="http://i.iinfo.cz/images/430/jvm-62-4-prev.png" class="image-117194" width="370" height="241" alt="&#160;" /></a>
<p><i>Obrázek 4: Histogram s&nbsp;frekvencí výskytu øetìzcù s&nbsp;délkou 0-600 znakù.</i></p>

<a href="http://www.root.cz/obrazek/117195/"><img src="http://i.iinfo.cz/images/430/jvm-62-5-prev.png" class="image-117195" width="370" height="244" alt="&#160;" /></a>
<p><i>Obrázek 5: Histogram s&nbsp;frekvencí výskytu øetìzcù s&nbsp;délkou 0-100 znakù.</i></p>

<p>Jen pro doplnìní je je¹tì vhodné k&nbsp;obìma histogramùm pøidat minule
vysvìtlený graf, na jeho¾ horizontální osu je vynesena délka øetìzce a na osu
vertikální (pravá osa) pak efektivita ulo¾ení takto dlouhého øetìzce
v&nbsp;pamìti:</p>

<img src="http://i.iinfo.cz/images/376/java-string-storage-efficiency.png" alt="string_storage_graph" />
<p><i>Obrázek 6: Efektivita ulo¾ení øetìzcù s&nbsp;rùznou délkou.</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Vyu¾ití rozhraní JVM TI pro ladìní (debugging) javovských aplikací</h2>

<p>Rozhraní <i>JVM TI</i> je mo¾né vyu¾ít i pro ladìní javovských aplikací
&ndash; jinými slovy je mo¾né s&nbsp;vyu¾itím <i>JVM TI</i> naprogramovat i
pomìrnì slo¾itý <i>debugger</i>, i kdy¾ je na tomto místì nutné øíci, ¾e
výhodnìj¹í a pøedev¹ím jednodu¹¹í bývá v&nbsp;tomto pøípadì pou¾ití rozhraní
<i>JDWP</i>, které je pøímo urèené právì pro implementaci debuggerù. Pokud se
smíøíme s&nbsp;tím, ¾e <i>JVM TI</i> je nízkoúrovòové rozhraní, nabízí nám
v&nbsp;oblasti ladìní ve skuteènosti pomìrnì ¹irokou funkcionalitu,
napøíklad:</p>

<ol>
<li>Zji¹tìní vzniku zachycované èi nezachycované výjimky (to ji¾ umíme).</li>
<li>Zji¹tìní zachycení výjimky (takté¾ ji¾ umíme).</li>
<li>Získání seznamu v¹ech naètených tøíd (-//-).</li>
<li>Pøeètení v¹ech objektù, polí i primitivních hodnot na haldì (-//-).</li>
<li>Zji¹tìní zápisu do atributu.</li>
<li>Zji¹tìní pouhého ètení hodnoty atributu.</li>
<li>Zachycení vstupu do metody.</li>
<li>Zachycení výstupu z&nbsp;metody.</li>
<li>Nastavení breakpointu.</li>
<li>Vynucení výskoku z&nbsp;funkce s&nbsp;vybranou návratovou hodnotou.</li>
<li>Krokování po jednotlivých instrukcích.</li>
</ol>



<p><a name="k07"></a></p>
<h2 id="k07">7. Zji¹tìní v¹ech atributù vybrané tøídy</h2>

<p>V&nbsp;následujícím textu se budeme zabývat pøedev¹ím body èíslo 5 a 6,
tj.&nbsp;zpùsobem detekce zápisu do atributu vybrané tøídy/objektu a zpùsobem
detekce ètení tohoto atributu. Tuto u¾iteènou funkci nám nabízí prakticky
v¹echny moderní debuggery (pøíkaz <strong>watch...</strong>). S&nbsp;vyu¾itím
funkcionality nabízené rozhraním <i>JVM TI</i> je mo¾né k&nbsp;libovolnému
atributu tøídy èi objektu zaregistrovat callback funkci zavolanou ve chvíli,
kdy je hodnota tohoto atributu zmìnìna (je proveden zápis) èi kdy je naopak jen
pøeètena aktuální hodnota tohoto atributu. Nicménì pøi registraci tìchto
callback funkcí je zapotøebí znát identifikátor tohoto atributu reprezentovaný
hodnotou typu <strong>jfieldID</strong>, kterou musíme nìjakým zpùsobem získat.
Nejprve si uká¾eme, jak je mo¾né získat informace o v¹ech atributech vybrané
javovské tøídy, proto¾e pøesnì tato èinnost se provádí v&nbsp;debuggeru &ndash;
tam je takté¾ nutné vybrat tøídu/objekt a její/jeho atribut, který se má
sledovat.</p>

<p>Demonstraèní agent èíslo 26 získá a vypí¹e jména, signatury a modifikátory
v¹ech atributù tøídy <strong>Test26</strong> (a samozøejmì i v¹ech pøípadných
instancí této tøídy). Základem funkcionality tohoto agenta je funkce
<strong>callback_on_info_request()</strong> zavolaná ve chvíli ukonèování práce
JVM. Ve skuteènosti je v¹ak mo¾né tuto funkci zavolat naopak pøi inicializaci
JVM, v&nbsp;této chvíli je to jedno. V&nbsp;callback funkci
<strong>callback_on_info_request()</strong> se získá seznam v¹ech naètených
tøíd a ve smyèce se tímto seznamem prochází. Ve chvíli, kdy jméno tøídy
odpovídá zadanému jménu "Test26" je zavolána funkce
<strong>print_attributes_info()</strong>, které se pøedá identifikátor
pøíslu¹né tøídy:</p>

<pre>
<i>/*</i>
<i> * Callback funkce zavolana pri cteni informaci o atributech vybrane tridy.</i>
<i> */</i>
static void JNICALL <strong>callback_on_info_request</strong>(jvmtiEnv *jvmti_env)
{
    jvmtiError error;
    jint       class_count;
    jclass    *class_array;
    int        i;
&nbsp;
    MSG("Got data dump request");
&nbsp;
    error = (*jvmti_env)-&gt;<strong>GetLoadedClasses</strong>(jvmti_env, &amp;class_count, &amp;class_array);
    check_jvmti_error(jvmti_env, error, "get loaded classes");
&nbsp;
    for (i=0; i &lt; class_count; i++)
    {
        char *class_name_ptr;
        char *updated_class_name_ptr;
&nbsp;
        <i>/* ziskat jmeno tridy */</i>
        error = (*jvmti_env)-&gt;<strong>GetClassSignature</strong>(jvmti_env, class_array[i], &amp;class_name_ptr, NULL);
        check_jvmti_error(jvmti_env, error, "get class signature");
        if (class_name_ptr == NULL)
        {
            puts("Error: class has no signature");
        }
        <i>/* upravit jmeno tridy */</i>
        updated_class_name_ptr = update_class_name(class_name_ptr, ';');
&nbsp;
        <i>/* nasli jsme nasi testovaci tridu? */</i>
        if (strcmp(TEST_CLASS_NAME, updated_class_name_ptr) == 0)
        {
            printf("Field\t%-20s\t%-25s\tModifiers\n", "Name", "Signature");
            print_attributes_info(jvmti_env, class_array[i]);
        }
&nbsp;
        <i>/* dealokace pameti po GetClassSignature() */</i>
        error = (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char *)class_name_ptr);
        check_jvmti_error(jvmti_env, error, "deallocate class name");
    }
}
</pre>

<p>Ve funkci <strong>print_attributes_info()</strong> se s&nbsp;vyu¾itím <i>JVM
TI</i> funkce <strong>GetClassFields()</strong> získá pole obsahující
identifikátory v¹ech atributù, které jsou v&nbsp;dané tøídì deklarovány. Toto
pole obsahuje prvky typu <strong>jfieldID</strong> a <i>JVM TI</i> funkce
<strong>GetClassFields()</strong> kromì tohoto pole vrátí i jeho délku, èeho¾
se vyu¾ije v&nbsp;programové smyèce, která v¹emi hodnotami
<strong>jfieldID</strong> prochází a pro ka¾dou získanou hodnotu zavolá funkci
<strong>print_info_for_attribute()</strong>:</p>

<pre>
<i>/*</i>
<i> * Zjisteni a nasledny tisk informaci o atributech tridy.</i>
<i> */</i>
static void JNICALL <strong>print_attributes_info</strong>(jvmtiEnv *jvmti_env, jclass class)
{
    jvmtiError error;
    int        field_count;
    jfieldID  *fields_array;
&nbsp;
    <i>/* precist vsechny atributy tridy */</i>
    error = (*jvmti_env)-&gt;<strong>GetClassFields</strong>(jvmti_env, class, &amp;field_count, &amp;fields_array);
    check_jvmti_error(jvmti_env, error, "get class fields");
&nbsp;
    <i>/* pole atributu bylo inicializovano */</i>
    if (error == JVMTI_ERROR_NONE)
    {
        int i;
        <i>/* projit vsemi atributy a vypsat o nich informace */</i>
        for (i = 0; i &lt; field_count; i++)
        {
            print_info_for_attribute(jvmti_env, class, fields_array[i], i);
        }
    }
&nbsp;
    <i>/* dealokace pole ziskaneho pres GetClassFields() */</i>
    error = (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char*)fields_array);
    check_jvmti_error(jvmti_env, error, "deallocate class fields array");
}
</pre>

<p>Do funkce <strong>print_info_for_attribute()</strong> jsou pøedány dvì
dùle¾ité informace &ndash; hodnoty <strong>jclass</strong> a
<strong>jfieldID</strong>, které jednoznaènì urèují pøíslu¹ný atribut tøídy.
Pro získání jména a signatury atributu se pou¾ije <i>JVM TI</i> funkce nazvaná
<strong>GetFieldName()</strong> a pro pøeètení modifikátorù (viz dal¹í text)
pak funkce nazvaná <strong>GetFieldModifiers()</strong>. Pou¾ití obou zmínìných
<i>JVM TI</i> funkcí je jednoduché, pouze nesmíme zapomenout na dealokaci
øetìzcù vrácených z&nbsp;<strong>GetFieldName()</strong>:</p>

<pre>
<i>/*</i>
<i> * Tisk informaci o vybranem atributu tridy.</i>
<i> */</i>
static void <strong>print_info_for_attribute</strong>(jvmtiEnv *jvmti_env, jclass class, jfieldID field, int i)
{
    jvmtiError error;
    char *name;
    char *signature;
    int  modifiers;
&nbsp;
    error = (*jvmti_env)-&gt;<strong>GetFieldName</strong>(jvmti_env, class, field, &amp;name, &amp;signature, NULL);
    check_jvmti_error(jvmti_env, error, "get field name");
    error = (*jvmti_env)-&gt;<strong>GetFieldModifiers</strong>(jvmti_env, class, field, &amp;modifiers);
    check_jvmti_error(jvmti_env, error, "get field modifiers");
&nbsp;
    <i>/* zakladni informace */</i>
    printf("%d\t%-20s\t%-25s\t", i, name, signature);
    <i>/* tisk pripadnych modifikatoru */</i>
    print_modifiers(modifiers);
    putchar('\n');
&nbsp;
    <i>/* dealokace pameti */</i>
    error = (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char*)name);
    check_jvmti_error(jvmti_env, error, "deallocate field name");
    error = (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char*)signature);
    check_jvmti_error(jvmti_env, error, "deallocate field signature");
}
</pre>

<p>Nyní nám ji¾ zbývá pouze vytisknout v¹echny pøípadné modifikátory atributu.
Tyto modifikátory jsou ulo¾eny v&nbsp;jediné celoèíselné hodnotì jako bitové
pøíznaky. My ji¾ vlastnì hodnoty tìchto pøíznakù známe, proto¾e jsou stejné,
jako pøíznaky pou¾ívané v&nbsp;bajtkódu JVM (èásti 18 a¾ 31 tohoto
seriálu):</p>

<pre>
<i>/*</i>
<i> * Priznaky tridy, rozhrani ci datove polozky</i>
<i> */</i>
enum
{
    ACC_PUBLIC       = 0x0001,   <i>/* verejna trida/rozhrani/datova polozka */</i>
    ACC_PRIVATE      = 0x0002,   <i>/* privatni datova polozka dostupna pouze uvnitr tridy */</i>
    ACC_PROTECTED    = 0x0004,   <i>/* chranena datova polozka dostupna uvnitr tridy a z pripadne odvozene tridy */</i>
    ACC_STATIC       = 0x0008,   <i>/* staticka datova polozka */</i>
    ACC_FINAL        = 0x0010,   <i>/* finalni trida ci datova polozka */</i>
    ACC_VOLATILE     = 0x0040,   <i>/* priznak volatile - hodnota se vzdy precte ci zapise do pameti */</i>
    ACC_TRANSIENT    = 0x0080,   <i>/* priznak transient - nebude se zpracovavat pri (de)serializaci */</i>
    ACC_INTERFACE    = 0x0200,   <i>/* rozliseni trida/rozhrani */</i>
    ACC_ABSTRACT     = 0x0400,   <i>/* abstraktni trida */</i>
    ACC_SYNTHETIC    = 0x1000,   <i>/* synteticka trida ci datova polozka, nema svuj protejsek ve zdrojovem kodu */</i>
    ACC_ANNOTATION   = 0x2000,   <i>/* anotace */</i>
    ACC_ENUM         = 0x4000,   <i>/* vycet */</i>
};
</pre>

<p>Se znalostí èíselného kódu vráceného <i>JVM TI</i> funkcí
<strong>GetFieldModifiers()</strong> a vý¹e vypsaného výètu s&nbsp;bitovými
maskami je mo¾né vypsat v¹echny modifikátory pøíslu¹ného atributu èi jejich
rùzné kombinace napøíklad následujícím zpùsobem:</p>

<pre>
<i>/*</i>
<i> * Tisk informaci o modifikatorech atributu.</i>
<i> */</i>
static void <strong>print_modifiers</strong>(int modifiers)
{
    if (modifiers &amp; ACC_PUBLIC)     fputs(" public", stdout);
    if (modifiers &amp; ACC_PRIVATE)    fputs(" private", stdout);
    if (modifiers &amp; ACC_PROTECTED)  fputs(" protected", stdout);
    if (modifiers &amp; ACC_STATIC)     fputs(" static", stdout);
    if (modifiers &amp; ACC_FINAL)      fputs(" final", stdout);
    if (modifiers &amp; ACC_ABSTRACT)   fputs(" abstract", stdout);
    if (modifiers &amp; ACC_SYNTHETIC)  fputs(" synthetic", stdout);
    if (modifiers &amp; ACC_TRANSIENT)  fputs(" transient", stdout);
    if (modifiers &amp; ACC_INTERFACE)  fputs(" interface", stdout);
    if (modifiers &amp; ACC_ANNOTATION) fputs(" annotation", stdout);
    if (modifiers &amp; ACC_ENUM)       fputs(" enum", stdout);
    if (modifiers &amp; ACC_VOLATILE)   fputs(" volatile", stdout);
}
</pre>

<p>Poznámka: funkce <strong>fputs()</strong> je zde pou¾ita pouze z&nbsp;toho
dùvodu, ¾e nevkládá do standardního výstupu znak pro konec øádku, jiný dùvod
pro provádìní této &bdquo;magie&ldquo; neexistuje :-)</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Demonstraèní agent èíslo 26 &ndash; výpis informací o v¹ech atributech vybrané tøídy</h2>

<p>Pro vyzkou¹ení èinnosti dvacátého ¹estého demonstraèního <i>JVM TI</i>
agenta, jeho¾ zdrojový kód je opìt ulo¾en v&nbsp;Mercurial repositáøi (viz té¾
<a href="#k09">kapitola èíslo 9</a>) bude tento agent spu¹tìn s&nbsp;testovací
tøídou <strong>Test26</strong>, v&nbsp;ní¾ je deklarováno pomìrnì velké
mno¾ství rùzných atributù. Jedná se o atributy primitivního datového typu, pole
primitivních datových typù, reference na objekty i pole referencí na objekty.
Navíc jsou u nìkterých atributù pou¾ity rùzné modifikátory, a» ji¾ se jedná o
modifikátory pøístupu (<strong>public/protected/private</strong>), tak i
modifikátory <strong>static</strong> (tøídní atribut),
<strong>transient</strong> (atribut nebude serializován),
<strong>volatile</strong> (nebude se provádìt ¾ádná optimalizace pøi ètení a
zápisu hodnoty atributu) a <strong>final</strong> (jedná se o konstantní
hodnotu). Tyto atributy lze samozøejmì rùznì kombinovat, co¾ je takté¾
v&nbsp;testovací tøídì pou¾ito:</p>

<pre>
<i>/**</i>
<i>  * Testovaci trida pouzita pro test dvacateho</i>
<i>  * sesteho demonstracniho JVM TI agenta.</i>
<i>  */</i>
public class <strong>Test26</strong> {
<i>    /* Zakladni datove typy a obalove tridy */</i>
    int         i;
    Integer     I;
    float       f;
    Float       F;
&nbsp;
<i>    /* Pole, tridy a rozhrani */</i>
    int[]       pole;
    boolean[][] matice;
    String      retezec;
    String[]    moc_retezcu;
    Test26      instance;
    Comparable  comparable;
&nbsp;
<i>    /* Ruzne modifikatory */</i>
    public int    public_int;
    private int   private_int;
    protected int protected_int;
    int           proste_jen_int;
    transient int transient_int;
    volatile int  volatile_int;
    final int     final_int = 0;
    static int    static_int;
&nbsp;
<i>    /* Kombinace modifikatoru */</i>
    public static final int public_static_final_int = 42;
    private transient java.awt.Color color;
    protected volatile static java.util.Date date;
&nbsp;
<i>    /**</i>
<i>      * Spusteni testu.</i>
<i>      */</i>
    public static void main(String[] args) {
    }
}
</pre>

<p>Po spu¹tìní virtuálního stroje Javy spoleènì s&nbsp;<i>JVM TI</i>
agentem:</p>

<pre>
java -agentpath:./libagent26.so Test26 2&gt; /dev/null
</pre>

<p>Získáme následující výpis, který pøesnì odpovídá deklaraci atributù
v&nbsp;testovací tøídì <strong>Test26</strong>:</p>

<pre>
Agent26: Agent_OnLoad
Agent26: JVM TI version is correct
Agent26: Got VM init event
Agent26: Got VM Death event
Agent26: Got data dump request
Field   Name                    Signature                       Modifiers
0       i                       I                               
1       I                       Ljava/lang/Integer;             
2       f                       F                               
3       F                       Ljava/lang/Float;               
4       pole                    [I                              
5       matice                  [[Z                             
6       retezec                 Ljava/lang/String;              
7       moc_retezcu             [Ljava/lang/String;             
8       instance                LTest26;                        
9       comparable              Ljava/lang/Comparable;          
10      public_int              I                                public
11      private_int             I                                private
12      protected_int           I                                protected
13      proste_jen_int          I                               
14      transient_int           I                                transient
15      volatile_int            I                                volatile
16      final_int               I                                final
17      static_int              I                                static
18      public_static_final_int I                                public static final
19      color                   Ljava/awt/Color;                 private transient
20      date                    Ljava/util/Date;                 protected static volatile
Agent26: Agent_OnUnload
</pre>

<p>V&nbsp;následující èásti tohoto seriálu si uká¾eme, jak lze takto získané
informace dále vyu¾ít pøi tvorbì jednoduchého &bdquo;debuggeru&ldquo;.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Zdrojové kódy obou demonstraèních agentù a k&nbsp;nim pøíslu¹ných testovacích pøíkladù</h2>

<p>Podobnì jako v&nbsp;pìti pøedcházejících èástech <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">tohoto
seriálu</a> byly i dne¹ní dva demonstraèní <i>JVM TI</i> agenti kvùli snaz¹ímu
udr¾ování v¹ech zdrojových kódù ulo¾eni do Mercurial repositáøe, který je
dostupný na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
Prozatím nejnovìj¹í verze dnes popisovaných <i>JVM TI</i> agentù i dal¹ích
potøebných skriptù a testovacích javovských tøíd jsou dostupné na následujících
adresách:</p>

<table>
<tr><th>Demonstraèní pøíklad/podpùrný soubor</th><th>Umístìní</th></tr>
<tr><td>Agent #25                     </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f258f0f485b5/jvmti-agents/agent25/agent25.c">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f258f0f485b5/jvmti-agents/agent25/agent25.c</a></td></tr>
<tr><td>Skript pro pøeklad            </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f258f0f485b5/jvmti-agents/agent25/compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f258f0f485b5/jvmti-agents/agent25/compile.sh</a></td></tr>
<tr><td>Skript pro spu¹tìní           </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f258f0f485b5/jvmti-agents/agent25/test.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f258f0f485b5/jvmti-agents/agent25/test.sh</a></td></tr>
<tr><td>Skript pro spu¹tìní Freemindu </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f258f0f485b5/jvmti-agents/agent25/freemind.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f258f0f485b5/jvmti-agents/agent25/freemind.sh</a></td></tr>
<tr><td>Testovací tøída Test25.java   </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f258f0f485b5/jvmti-agents/agent25/Test25.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f258f0f485b5/jvmti-agents/agent25/Test25.java</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Výsledek pro tøídu Test26     </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f258f0f485b5/jvmti-agents/agent25/Test25.out">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f258f0f485b5/jvmti-agents/agent25/Test25.out</a></td></tr>
<tr><td>Výsledek pro aplikaci Freemind</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f258f0f485b5/jvmti-agents/agent25/freemind.out">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f258f0f485b5/jvmti-agents/agent25/freemind.out</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Agent #26                     </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f258f0f485b5/jvmti-agents/agent26/agent26.c">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f258f0f485b5/jvmti-agents/agent26/agent26.c</a></td></tr>
<tr><td>Skript pro pøeklad            </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f258f0f485b5/jvmti-agents/agent26/compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f258f0f485b5/jvmti-agents/agent26/compile.sh</a></td></tr>
<tr><td>Skript pro spu¹tìní           </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f258f0f485b5/jvmti-agents/agent26/test.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f258f0f485b5/jvmti-agents/agent26/test.sh</a></td></tr>
<tr><td>Testovací tøída Test26.java   </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f258f0f485b5/jvmti-agents/agent26/Test26.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f258f0f485b5/jvmti-agents/agent26/Test26.java</a></td></tr>
</table>



<p><a name="k10"></a></p>
<h2 id="k10">10. Odkazy na Internetu</h2>

<ol>

<li>The JVM Tool Interface (JVM TI): How VM Agents Work<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html">http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html</a>
</li>

<li>JVM Tool Interface Version 1.2<br />
<a href="http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html">http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html</a>
</li>

<li>Creating a Debugging and Profiling Agent with JVMTI<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html">http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html</a>
</li>

<li>JVM TI (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/JVM_TI">http://en.wikipedia.org/wiki/JVM_TI</a>
</li>

<li>IBM JVMTI extensions<br />
<a href="http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html">http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

