<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Clojure 16: slo¾itìj¹í u¾ivatelská makra</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Clojure 16: slo¾itìj¹í u¾ivatelská makra</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o vlastnostech programovacího jazyka Java i JVM budeme pokraèovat v popisu makrosystému, který tvoøí nedílnou souèást jazyka Clojure. Nejprve vylep¹íme trasovací makro navr¾ené minule a posléze si uká¾eme tvorbu slo¾itìj¹ího makra, díky nìmu¾ do jazyka Clojure pøidáme nový typ øídicí struktury &ndash; programové smyèky.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyk Clojure 16: slo¾itìj¹í u¾ivatelská makra</a></p>
<p><a href="#k02">2. Zápis kódu generovaného makrem s&nbsp;vyu¾itím &bdquo;¹ablony&ldquo;</a></p>
<p><a href="#k03">3. Pøíprava na vylep¹ení makra <strong>trace</strong></a></p>
<p><a href="#k04">4. Funkce s&nbsp;promìnným poètem parametrù</a></p>
<p><a href="#k05">5. Pøíklad funkce s&nbsp;promìnným poètem parametrù</a></p>
<p><a href="#k06">6. Vylep¹ené makro <strong>trace</strong></a></p>
<p><a href="#k07">7. Vytvoøení nového typu programové smyèky <strong>forloop</strong> s&nbsp;vyu¾itím maker</a></p>
<p><a href="#k08">8. Úprava programové smyèky <strong>forloop</strong></a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk Clojure 16: slo¾itìj¹í u¾ivatelská makra</h2>

<p>V&nbsp;dne¹ní èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyce Java i o virtuálním stroji Javy (JVM)</a> se budeme
podrobnìji zabývat popisem makrosystému jazyka <i>Clojure</i> postaveného nad
JVM. Minule jsme si øekli, ¾e makra v&nbsp;<i>Clojure</i> jsou aplikována na
zadávané èi naèítané formy ve chvíli naèítání tìchto forem a nikoli a¾
v&nbsp;èase bìhu programu &ndash; makra zde tedy slou¾í ke stejnému úèelu, jako
napøíklad zcela odli¹ným zpùsobem koncipovaná makra pou¾itá
v&nbsp;programovacích jazycích C a C++. V&nbsp;pøedchozím èlánku jsme si takté¾
ukázali dva zpùsoby tvorby u¾ivatelských maker. První zpùsob spoèíval
v&nbsp;ponìkud namáhavé konstrukci výsledného kódu s&nbsp;vyu¾itím funkcí a
speciálních forem <strong>list</strong>, <strong>quote</strong> a
<strong>concat</strong>. Vá¾nou nevýhodou tohoto zpùsobu tvorby maker je
pøedev¹ím dlouhý i nepøehledný zápis makra a takté¾ to, ¾e se u¾ivatel pøi
tvorbì slo¾itìj¹ího makra obvykle nevyhne nutnosti toto makro nìkolikrát
pøepsat, proto¾e nìkde zapomene uvést <strong>quote</strong>, nebo naopak
<strong>quote</strong> pøidá i tam, kde ve skuteènosti nemá být.</p>

<p>Pøipomeòme si nejdøíve, jak jsme vytvoøili první u¾ivatelské makro. Toto
makro se jmenovalo <strong>trace</strong> a kdy¾ bylo zavoláno s&nbsp;urèitým
výrazem, mìlo dojít k&nbsp;vygenerování kódu, který nejdøíve vypsal tento výraz
(pøesnìji øeèeno jeho tisknutelnou podobu) a následnì vypsal i hodnotu vzniklou
vyhodnocením tohoto výrazu. Souèasnì mìla být tato hodnota i návratovou
hodnotou vygenerovaného kódu, aby se vlo¾ením makra do slo¾itìj¹ího programu
neovlivnila správná funkce tohoto programu. Kód, který mìl být makrem
<strong>trace</strong> vygenerován, vypadá zhruba takto:</p>

<pre>
(let [x vyraz]
    (println (quote vyraz) " = " x)
    x)
</pre>

<p>Mù¾eme zde vidìt pou¾ití lokální promìnné <strong>x</strong>, díky ní¾ se
pøedaný výraz vyhodnotí pouze jednou, co¾ je nutné zajistit zejména tehdy,
pokud by nìjaká funkce volaná z&nbsp;výrazu mìla vedlej¹í efekt. Abychom
vytvoøili tento výraz ve formì rekurzivnì zanoøeného seznamu, definovali jsme
makro <strong>trace</strong> s&nbsp;následující podobou:</p>

<pre>
(defmacro <strong>trace</strong>
    [vyraz]
    (list
        'let ['x vyraz]
        (list 'println (list 'quote vyraz) "=" 'x)
        'x))
</pre>

<p>O tom, ¾e makro pracuje (alespoò zdánlivì) korektnì, jsme se mohli
pøesvìdèit pou¾itím funkce <strong>macroexpand-1</strong>, která zobrazí
expandované makro:</p>

<pre>
<i>; nejprve zadáme interpretru tvar makra</i>
<strong>(defmacro trace</strong>
<strong>    [vyraz]</strong>
<strong>    (list</strong>
<strong>        'let ['x vyraz]</strong>
<strong>        (list 'println (list 'quote vyraz) "=" 'x)</strong>
<strong>        'x))</strong>
&nbsp;
&nbsp;
<i>; otestování makra na volání jednoduché funkce</i>
user=&gt; <strong>(trace (* 6 7))</strong>
(* 6 7) = 42
42
&nbsp;
&nbsp;
<i>; zobrazíme si expandované makro</i>
user=&gt; <strong>(macroexpand-1 '(trace (* 6 7)))</strong>
(let [x (* 6 7)] (println (quote (* 6 7)) "=" x) x)
&nbsp;
&nbsp;
user=&gt;
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Zápis kódu generovaného makrem s&nbsp;vyu¾itím &bdquo;¹ablony&ldquo;</h2>

<p>Zápis makra uvedený <a href="#k01">v&nbsp;pøedchozí kapitole</a> ve
skuteènosti není ani pøíli¹ pìkný, ani èitelný, proto¾e jsme byli nuceni
v¹echny funkce (které se mìly objevit ve výsledném kódu) quotovat,
tj.&nbsp;zapsat pøed nì znak apostrofu, co¾ je zkrácený zpùsob zápisu
<strong>(quote ...)</strong>. Dále se výsledný seznam musel explicitnì vytváøet
s&nbsp;vyu¾itím funkce <strong>list</strong> atd. Mnohem èitelnìj¹í a
elegantnìj¹í je pou¾ít zápis makra vyu¾ívající takzvaná <i>reader makra</i>
nazvaná &bdquo;syntax-quote&ldquo; (zapisováno formou znaku zpìtného apostrofu,
back-tick) a &bdquo;unquote&ldquo; (zapisováno jako znak tilda).
S&nbsp;vyu¾itím zpìtného apostrofu bylo mo¾né tìlo makra, tj.&nbsp;generovaný
výraz, quotovat, ov¹em s&nbsp;tou výjimkou, ¾e symboly, pøed nimi¾ byl zapsán
znak tildy (&bdquo;unquote&ldquo;) byly naopak nahrazeny hodnotou pøiøazenou
k&nbsp;tomuto symbolu. S&nbsp;vyu¾itím znakù ` a ~ je tedy mo¾né zapsat makro
ve formì jakési ¹ablony (<i>template</i>), do které se pouze doplòují hodnoty
vybraných symbolù. Druhá verze makra <strong>trace</strong> je nepochybnì
jednodu¹¹í a èitelnìj¹í ne¾ verze první. Pov¹imnìte si pøedev¹ím toho, ¾e
v&nbsp;makru mù¾eme pou¾ít napøíklad i <strong>'~vyraz</strong>, proto¾e znak '
(&bdquo;quote&ldquo;) je uvnitø ` pouze opisován do kódu generovaného makrem a
nemá zde tedy svùj obvyklý význam:</p>

<pre>
(defmacro <strong>trace2</strong>
    [vyraz]
    `(let [x ~vyraz] (println '~vyraz "=" x) x))
</pre>

<p>Pou¾ití znaku ` v¹ak pøineslo je¹tì jeden efekt &ndash; ke v¹em symbolùm
pou¾itým v&nbsp;makru se pøidal i jejich jmenný prostor (<i>namespace/ns</i>),
co¾ je sice zcela správnì (makro bude mo¾né pou¾ít i v&nbsp;jiném jmenném
prostoru), ov¹em jmenný prostor se doplnil i u symbolu <strong>x</strong>,
který by mìl být ve skuteènosti symbolem lokálním. Aby makro fungovalo zcela
správnì, musíme umìt vytvoøit lokální symbol s&nbsp;unikátním jménem. Pro tento
úèel se pou¾ívá (tak jako v&nbsp;mnoha dal¹ích situacích) znak køí¾ku
zapisovaný <strong>ZA</strong> nìjakým symbolem. <i>Clojure</i> zápis
<strong>symbol#</strong> expanduje na <strong>symbol_generované_èíslo</strong>,
které bude unikátní, co¾ je pøesnì to, co potøebujeme. Ve tøetí verzi na¹eho
makra tedy nahradíme <strong>x</strong> za <strong>x#</strong>:</p>

<pre>
(defmacro <strong>trace3</strong>
    [vyraz]
    `(let [x# ~vyraz] (println '~vyraz "=" x#) x#))
</pre>

<p>Nyní tedy ji¾ známe témìø v¹echny nástroje pou¾ívané pøi tvorbì maker:</p>

<table>
<tr><th>Znak</th><th>Význam pøi tvorbì maker</th></tr>
<tr><td>`</td><td>vìt¹inou uzavírá celé tìlo makra, tj. ¹ablonu vytváøeného výrazu</td></tr>
<tr><td>~</td><td>ru¹í význam znaku `, ov¹em pouze pro jediný symbol uvedený ihned za tímto znakem</td></tr>
<tr><td>#</td><td>symbol zapsaný pøed tímto znakem bude doplnìn takovým zpùsobem, aby se jednalo o unikátní jméno</td></tr>
</table>

<p>Je¹tì jsme si nevysvìtlili význam dvouznaku ~@ (<i>reader makro</i>
&bdquo;unqote-splicing&ldquo;), který bude vyu¾it v&nbsp;následujících
kapitolách.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Pøíprava na vylep¹ení makra <strong>trace</strong></h2>

<p>Prozatím poslední varianta makra <strong>trace</strong>, která byla ukázána
<a href="#k02">v&nbsp;pøedchozí kapitole</a>, sice pracuje korektnì, ale mo¾ná
jste si v¹imli, ¾e pøi pou¾ití tohoto makra je nutné pøi jeho vkládání do
zdrojových kódù nejenom uvést název tohoto makra, ale navíc se musí okolo
pøedávané funkce/výrazu/formy napsat i kulaté závorky:</p>

<pre>
<i>; otestování makra na volání funkce</i>
user=&gt; <strong>(trace (* 6 7))</strong>
(* 6 7) = 42
42
&nbsp;
&nbsp;
<i>; volání funkce apply</i>
user=&gt; <strong>(trace4 (apply * (range 1 6)))</strong>
(apply * (range 1 6)) = 120
120
&nbsp;
&nbsp;
<i>; otestování makra na volání slo¾itìj¹í funkce</i>
user=&gt; <strong>(trace (list (range 1 10) (range 20 30)))</strong>
(list (range 1 10) (range 20 30)) = ((1 2 3 4 5 6 7 8 9) (20 21 22 23 24 25 26 27 28 29))
((1 2 3 4 5 6 7 8 9) (20 21 22 23 24 25 26 27 28 29))
&nbsp;
&nbsp;
user=&gt;
</pre>

<p>Toto chování samozøejmì není zcela ¹patné (pou¾ití makra se ze syntaktického
hlediska neli¹í od volání bì¾né funkce èi speciální formy), ov¹em pou¾ití makra
<strong>trace</strong> se stává ponìkud slo¾itìj¹í, ne¾ by mohlo být, proto¾e
ve chvíli, kdy potøebujeme do zdrojového kódu toto makro vlo¾it (a vytváøet tak
trasovací informace pøi bìhu aplikace), je nutné nejenom pøed nìjaký výraz
zapsat <strong>(trace</strong>, ale dále je nutné najít je¹tì odpovídající
pravou kulatou závorku a celé volání uzavøít pomocí <strong>)</strong>. To je
ji¾ komplikovaný zásah do zdrojových kódù, zejména v&nbsp;pøípadì, ¾e
programátor rád tvoøí slo¾ité výrazy s&nbsp;mnoha závorkami, kvùli nim¾ se
význam názvu programovacího jazyka <i>LISP</i> (z&nbsp;nìho¾ je <i>Clojure</i>
pøímo odvozen) vysvìtluje jako <strong>L</strong>ost <strong>I</strong>n
<strong>S</strong>tupid <strong>P</strong>arentheses. Jedním z&nbsp;dùvodù
existence maker je zjednodu¹it zápis programù, ne ho je¹tì udìlat více
slo¾itìj¹ím. Na¹ím cílem tedy bude upravit makro <strong>trace</strong> takovým
zpùsobem, aby jsme mohli psát prostì:</p>

<pre>
<i>; otestování makra na volání funkce</i>
user=&gt; <strong>(trace * 6 7)</strong>
(* 6 7) = 42
42
&nbsp;
&nbsp;
<i>; volání funkce range</i>
user=&gt; <strong>(trace range 1 10)</strong>
(range 1 10) = (1 2 3 4 5 6 7 8 9)
(1 2 3 4 5 6 7 8 9)
&nbsp;
&nbsp;
<i>; volání funkce apply</i>
user=&gt; <strong>(trace4 apply * (range 1 6))</strong>
(apply * (range 1 6)) = 120
120
&nbsp;
&nbsp;
<i>; otestování makra na volání slo¾itìj¹í funkce</i>
user=&gt; <strong>(trace list (range 1 10) (range 20 30))</strong>
(list (range 1 10) (range 20 30)) = ((1 2 3 4 5 6 7 8 9) (20 21 22 23 24 25 26 27 28 29))
((1 2 3 4 5 6 7 8 9) (20 21 22 23 24 25 26 27 28 29))
&nbsp;
&nbsp;
user=&gt;
</pre>

<p>Asi nebudete pøíli¹ pøekvapeni zji¹tìním, ¾e makro pùjde pøesnì takovým
zpùsobem upravit, a to relativnì jednoduchým zpùsobem. Je¹tì pøed popisem
potøebné úpravy si v¹ak musíme vysvìtlit dal¹í vlastnost programovacího jazyka
<i>Clojure</i>: zpùsob tvorby funkcí s&nbsp;promìnným poètem parametrù.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Funkce s&nbsp;promìnným poètem parametrù</h2>

<p>V&nbsp;mnoha programovacích jazycích se jejich tvùrci sna¾ili více èi ménì
elegantnì vyøe¹it problém tvorby funkcí èi metod s&nbsp;promìnným poètem
parametrù. Nejedná se sice o vlastnost, která by musela být
v&nbsp;programovacím jazyku nutnì implementována, ov¹em její zahrnutí do
syntaxe a sémantiky jazyka znamená pro programátory mo¾nost tvorby
univerzálnìji pou¾itelných funkcí. Zejména se tak dá efektivnì obejít vytváøení
pøetí¾ených funkcí èi metod, které jsou mnohdy pøetì¾ovány jen z&nbsp;toho
dùvodu, ¾e v&nbsp;nìkterých pøípadech jim potøebujeme pøedat doplòující
parametry. Zajímavé je, ¾e dokonce i v&nbsp;tìch programovacích jazycích, které
(tøeba jen zpoèátku) mo¾nost tvorby funkcí s&nbsp;promìnným poètem parametrù
nepovolovaly, se tato vlastnost objevila, napøíklad ve formì &bdquo;speciálních
pøíkazù&ldquo;, které sice programátoøi nemohli sami vytváøet, ale mohli
alespoò tyto ji¾ pøipravené speciální pøíkazy pou¾ívat (co¾ na druhou stranu
ukazuje na nekoncepènost pøi návrhu tìchto jazykù).</p>

<p>Pro pøíklady nemusíme chodit daleko &ndash; ji¾ programovací jazyk
<i>Pascal</i> obsahoval &bdquo;speciální pøíkazy&ldquo; <strong>write</strong>
a <strong>writeln</strong> s&nbsp;promìnným poètem parametrù, stejnì jako
programovací jazyk <i>Basic</i> s&nbsp;jeho pøíkazy <strong>PRINT</strong> a
<strong>INPUT</strong>.</p>

<p>Tvùrci nìkterých dal¹ích programovacích jazykù byli vùèi
programátorùm-u¾ivatelùm férovìj¹í a zahrnuli tuto mo¾nost pøímo do syntaxe a
sémantiky. Týká se to napøíklad programovacích jazykù <i>C</i>, <i>C++</i>,
<i>TCL</i>, <i>Python</i> a podpory pro promìnný poèet parametrù metod jsme se
nakonec doèkali i v&nbsp;<i>Javì</i> (i kdy¾ zde je mo¾ná typické, ¾e nejprve
musel pøijít konkurent jménem <i>C#</i>, aby se tvùrci Javy koneènì
&bdquo;rozhoupali&ldquo; pro implementaci nové vlastnosti do jazyka). Podporu
pro promìnný poèet parametrù obsahuje i programovací jazyk <i>Clojure</i>,
v&nbsp;nìm¾ je mo¾né s&nbsp;vyu¾itím znaku &amp; oddìlit lokální jména
povinných parametrù od jména sekvence, do ní¾ se ulo¾í v¹echny zbylé parametry.
Povinné parametry se oznaèují termínem &bdquo;pozièní parametry&ldquo;, zbylé
parametry pak termínem &bdquo;dal¹í (next) parametry&ldquo;. Podívejme se
nejprve na zpùsob zápisu funkce obsahující pouze dva pozièní parametry (nejedná
se o nic nového &ndash; podobný zápis byl v&nbsp;tomto seriálu pou¾it ji¾
mockrát):</p>

<pre>
(defn <strong>fce1</strong>
    [x y]
    (println "x = " x)
    (println "y = " y))
</pre>

<p>Pou¾ití této funkce je snadné:</p>

<pre>
user=&gt; <strong>(fce1 1 2)</strong>
x =  1
y =  2
nil
&nbsp;
&nbsp;
user=&gt; <strong>(fce1 "Hello" "world")</strong>
x =  Hello
y =  world
nil
&nbsp;
&nbsp;
user=&gt;
</pre>

<p>Musíme ov¹em pøesnì dodr¾et poèet pøedávaných parametrù, jinak dojde pøi
zavolání funkce k&nbsp;chybì:</p>

<pre>
user=&gt; <strong>(fce1 1)</strong>
ArityException Wrong number of args (1) passed to: user$fce1  clojure.lang.AFn.throwArity (AFn.java:437)
&nbsp;
&nbsp;
user=&gt; <strong>(fce1 1 2 3)</strong>
ArityException Wrong number of args (3) passed to: user$fce1  clojure.lang.AFn.throwArity (AFn.java:437)
user=&gt;
&nbsp;
&nbsp;
user=&gt;
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Pøíklad funkce s&nbsp;promìnným poètem parametrù</h2>

<p>Pokusme se funkci <strong>fce1</strong> <a href="#k04">z&nbsp;pøedchozí
kapitoly</a> upravit takovým zpùsobem, aby akceptovala jeden povinný (pozièní)
parametr a poté libovolné mno¾ství dal¹ích parametrù. Úprava je v&nbsp;tomto
pøípadì velmi snadná, proto¾e postaèuje vlo¾it znak ampersandu (&amp;) mezi
jména obou formálních parametrù. Poèet jmen formálních parametrù pøed
ampersandem toti¾ odpovídá poètu povinných parametrù, s&nbsp;nimi¾ se funkce
mù¾e volat, za ampersandem je pak jméno symbolu s&nbsp;lokální platností, do
nìho¾ se ukládají zbylé parametry. Jeliko¾ jejich poèet není dopøedu znám, je
k&nbsp;tomuto symbolu buï pøiøazena hodnota <strong>nil</strong> (¾ádný
volitelný parametr nebyl pøedán), nebo je mu pøiøazen seznam (byl pøedán
alespoò jeden a nebo více volitelných parametrù):</p>

<pre>
(defn <strong>fce2</strong>
    [x &amp; y]
    (println "x = " x)
    (println "y = " y))
</pre>

<p>Pou¾ití této funkce je ji¾ mnohem zajímavìj¹í, proto¾e se v¹echny nepovinné
parametry vkládají do seznamu navázaného na lokální symbol
<strong>y</strong>:</p>

<pre>
<i>; dva parametry - první je ulo¾en do x, druhý</i>
<i>; do prvního prvku seznamu y</i>
user=&gt; <strong>(fce2 1 2)</strong>
x =  1
y =  (2)
nil
&nbsp;
&nbsp;
<i>; dva parametry - první je ulo¾en do x, druhý</i>
<i>; do prvního prvku seznamu y</i>
user=&gt; <strong>(fce2 "Hello" "world")</strong>
x =  Hello
y =  (world)
nil
&nbsp;
&nbsp;
<i>; tøi parametry - první je ulo¾en do x, druhý</i>
<i>; a tøetí do seznamu y</i>
user=&gt; <strong>(fce2 "Don't" "panic" '!)</strong>
x =  Don't
y =  (panic !)
nil
&nbsp;
&nbsp;
<i>; pouze jeden parametr ulo¾ený do x</i>
<i>; lokální symbol y je pøiøazen k hodnotì nil!!!</i>
user=&gt; <strong>(fce2 1)</strong>
x =  1
y =  nil
nil
&nbsp;
&nbsp;
<i>; tøi parametry - první je ulo¾en do x, druhý</i>
<i>; a tøetí do seznamu y</i>
user=&gt; <strong>(fce2 1 2 3)</strong>
x =  1
y =  (2 3)
nil
&nbsp;
&nbsp;
<i>; slo¾itìj¹í pøíklad, kdy se do y vlo¾í seznam</i>
<i>; obsahující jako své prvky dal¹í podseznamy</i>
user=&gt; <strong>(fce2 1 '(2 3) '(4 5) '(6 7))</strong>
x =  1
y =  ((2 3) (4 5) (6 7))
nil
&nbsp;
&nbsp;
user=&gt;
</pre>

<p>Ve skuteènosti ov¹em mù¾eme zajít je¹tì dále a vytvoøit funkci akceptující
skuteènì úplnì libovolný poèet parametrù, vèetnì ¾ádného parametru:</p>

<pre>
(defn <strong>fce3</strong>
    [&amp; x]
    (println "x = " x))
</pre>

<p>Opìt si uveïme nìkolik demonstraèních pøíkladù:</p>

<pre>
<i>; dva parametry - budou ulo¾eny do seznamu</i>
<i>; na nìj¾ bude navázán symbol x</i>
user=&gt; <strong>(fce3 1 2)</strong>
x =  (1 2)
nil
&nbsp;
&nbsp;
<i>; dva parametry - budou ulo¾eny do seznamu</i>
<i>; na nìj¾ bude navázán symbol x</i>
user=&gt; <strong>(fce3 "Hello" "world")</strong>
x =  (Hello world)
nil
&nbsp;
&nbsp;
<i>; tøi parametry - budou ulo¾eny do seznamu</i>
<i>; na nìj¾ bude navázán symbol x</i>
user=&gt; <strong>(fce3 "Don't" "panic" '!)</strong>
x =  (Don't panic !)
nil
&nbsp;
&nbsp;
<i>; pouze jediný parametr - seznam se v¹ak pøesto vytvoøí</i>
user=&gt; <strong>(fce3 1)</strong>
x =  (1)
nil
&nbsp;
&nbsp;
<i>; pokud funkci nepøedáme ¾ádný parametr,</i>
<i>; bude x navázán na hodnotu nil!!!</i>
user=&gt; <strong>(fce3)</strong>
x =  nil
nil
&nbsp;
&nbsp;
user=&gt;
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Vylep¹ené makro <strong>trace</strong></h2>

<p>Zmìna makra <strong>trace</strong> takovým zpùsobem, aby toto makro
akceptovalo libovolný poèet parametrù, pøièem¾ první parametr bude jméno
funkce, je pomìrnì snadné. Zatímco pøedchozí tvar makra byl tento:</p>

<pre>
(defmacro <strong>trace3</strong>
    [vyraz]
    `(let [x# ~vyraz] (println '~vyraz "=" x#) x#))
</pre>

<p>...nyní upravíme makro tak, aby se v¹echny pøedávané parametry ulo¾ily do
seznamu. Pøi vyhodnocení pøedaného &bdquo;výrazu&ldquo; (nejedná se o skuteèný
výraz, pøesnìji øeèeno nejde o korektní formu) pøitom vyu¾ijeme známého faktu,
¾e seznam mù¾e být pova¾ován za volání funkce &ndash; jméno funkce je ulo¾eno
v&nbsp;prvním prvku seznamu, zbylé prvky pak pøedstavují parametry pøedané této
funkci. Znak &amp; má stejný význam pøi definici funkcí pomocí
<strong>defn</strong> i pøi definici maker s&nbsp;vyu¾itím
<strong>defmacro</strong>, tudí¾ je následující zápis korektní:</p>

<pre>
(defmacro <strong>trace4</strong>
    [&amp; params]
    `(let [x# ~params] (println '~params "=" x#) x#))
</pre>

<p>Vyzkou¹ejme si &bdquo;vylep¹enou&ldquo; funkci tohoto makra. Pov¹imnìte si,
¾e pokud je zapotøebí nìkam do kódu pøidat generování trasovacích informací,
postaèuje na toto místo kódu vlo¾it pouze symbol <strong>trace4</strong>. To
znamená, ¾e ¾ádné závorky ani dal¹í znaky se ji¾ (a¾ na jednu výjimku) nemusí
pou¾ívat:</p>

<pre>
<i>; zde mù¾e dojít k pøekvapení</i>
user=&gt; <strong>(trace4)</strong>
nil = nil
nil
&nbsp;
&nbsp;
user=&gt; <strong>(trace4 + 1 2)</strong>
(+ 1 2) = 3
3
&nbsp;
&nbsp;
user=&gt; <strong>(trace4 Math/random)</strong>
(Math/random) = 0.5518909120897316
0.5518909120897316
&nbsp;
&nbsp;
user=&gt; <strong>(trace4 apply * (range 1 6))</strong>
(apply * (range 1 6)) = 120
120
&nbsp;
&nbsp;
user=&gt;
</pre>

<p>Zajímavá takté¾ mù¾e být expanze tohoto makra, zejména v&nbsp;prvním
pøípadì, proto¾e zde se namísto seznamu pøiøadí symbolu <strong>params</strong>
hodnota <strong>nil</strong>:</p>

<pre>
user=&gt; <strong>(macroexpand-1 '(trace4))</strong>
(clojure.core/let [x__1__auto__ nil] (clojure.core/println (quote nil) "=" x__1_
_auto__) x__1__auto__)
&nbsp;
&nbsp;
user=&gt; <strong>(macroexpand-1 '(trace4 Math/random))</strong>
(clojure.core/let [x__1__auto__ (Math/random)] (clojure.core/println (quote (Mat
h/random)) "=" x__1__auto__) x__1__auto__)
&nbsp;
&nbsp;
user=&gt; <strong>(macroexpand-1 '(trace4 apply * (range 1 6)))</strong>
(clojure.core/let [x__1__auto__ (apply * (range 1 6))] (clojure.core/println (qu
ote (apply * (range 1 6))) "=" x__1__auto__) x__1__auto__)
&nbsp;
&nbsp;
user=&gt;
</pre>

<p>Malý úkol pro ètenáøe: makro <strong>trace4</strong> ve skuteènosti nebude
správnì fungovat ve chvíli, kdy se mu pøedá napøíklad atom &ndash; celé èíslo,
pravdivostní hodnota atd. Zkuste analyzovat následující dvojici pøíkazù (volání
makra a jeho expanzi) a navrhnout takovou úpravu makra, která tuto chybu
eliminuje:</p>

<pre>
user=&gt; <strong>(trace4 42)</strong>
ClassCastException java.lang.Long cannot be cast to clojure.lang.IFn  user/eval1
35 (NO_SOURCE_FILE:72)
&nbsp;
&nbsp;
user=&gt; <strong>(macroexpand-1 '(trace4 42))</strong>
(clojure.core/let [x__1__auto__ (42)] (clojure.core/println (quote (42)) "=" x__
1__auto__) x__1__auto__)
&nbsp;
&nbsp;
user=&gt;
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vytvoøení nového typu programové smyèky <strong>forloop</strong> s&nbsp;vyu¾itím maker</h2>

<p>Nyní se pustíme do tvorby slo¾itìj¹ího makra, konkrétnì do makra
pøedstavujícího programovou smyèku, která tak vlastnì roz¹íøí syntaxi a
sémantiku programovacího jazyka <i>Clojure</i> o novou konstrukci. Postup pøi
tvorbì tohoto makra je velmi detailnì popsán v&nbsp;trojici èlánkù
&bdquo;Clojure Macro Tutorial&ldquo; &ndash; odkaz na tyto èlánky najdete <a
href="#k09">na zaèátku deváté kapitoly</a> (pøi prvním ètení je mo¾ná nejlep¹í
èlánky prostudovat v&nbsp;poøadí I.díl, III.díl a teprve nakonec II.díl).
Nicménì se vra»me k&nbsp;na¹í programové smyèce. Potøebovali bychom vytvoøit
poèítanou smyèku typu <strong>for</strong>, které by se pøedala trojice
parametrù &ndash; název øídicí promìnné smyèky (poèitadla), poèáteèní hodnota
poèitadla a koncová hodnota poèitadla. Za parametry by mìlo následovat tìlo
smyèky, v&nbsp;nìm¾ je mo¾né vyu¾ít øídicí promìnnou, popø.&nbsp;globální
promìnné atd. Pro jednoduchost pøedpokládejme, ¾e krok smyèky bude v¾dy roven
jedné, i kdy¾ ve skuteènosti nebude vìt¹ím problémem na¹e makro roz¹íøit i o
mo¾nost zadání libovolného jiného kroku. Zpùsob volání tohoto makra by mìl
vypadat zhruba následovnì:</p>

<pre>
(forloop [counter start end]
    code)
</pre>

<p>Makro by mìlo na základì zadaných údajù vygenerovat tento kód, v&nbsp;nìm¾
je pou¾ita tail rekurze:</p>

<pre>
(loop [counter start]
    (when (&lt;= counter end)
        code
        (recur (inc counter))))
</pre>

<p>Konkrétní pøíklad:</p>

<pre>
(forloop [i 1 100]
    (println i))
</pre>

<p>Kód vygenerovaný makrem <strong>forloop</strong>:</p>

<pre>
(loop [i 1]
    (when (&lt;= i 100)
        (println i)
        (recur (inc i))))
</pre>

<p>Pøi tvorbì a ladìní maker mù¾eme postupovat dvìma zpùsoby. První zpùsob
spoèívá v&nbsp;tom, ¾e se nevytváøí pøímo makro pomocí
<strong>defmacro</strong>, ale namísto toho se vytváøí funkce slou¾ící jako
generátor kódu. Vygenerovaný kód se buï pouze zobrazí, nebo je ho mo¾né kdykoli
vyhodnotit pomocí <strong>eval</strong>. Druhý zpùsob spoèívá v&nbsp;pøímém
vytvoøení makra a následnì v&nbsp;pou¾ití funkce <strong>macroexpand-1</strong>
pro prohlédnutí expandovaného makra. Podle mì je první zpùsob výhodnìj¹í, proto
ho také pou¾ijeme zde. Následující funkci, která je pojmenovaná
<strong>forloop-generator</strong>, se musí pøedat vektor s&nbsp;trojicí hodnot
[jméno-øídicí-promìnné poèáteèní-hodnota-promìnné koncová-hodnota-promìnné] a
za tímto vektorem mù¾e následovat kód, který odpovídá tìlu generované smyèky.
®ádné nové techniky jsme v&nbsp;této funkci nepou¾ili, dokonce ani prozatím
nepou¾íváme <i>reader makra</i> &bdquo;syntax-quote&ldquo; èi
&bdquo;unquote&ldquo;:</p>

<pre>
(defn <strong>forloop-generator</strong>
    [[variable start end] &amp; code]
    (list 'loop [variable start]
        (concat (list 'when)
            (list (list '&lt;= variable end))
            code
            (list (list 'recur (list 'inc variable))))))
</pre>

<p>Nyní se mù¾eme podívat na kód generovaný touto funkcí, nesmíme v¹ak
zapomenout na to, ¾e jak jméno øídicí promìnné, tak i tìlo smyèky je zapotøebí
quotovat, proto¾e (prozatím) nevoláme plnohodnotné makro, ale obyèejnou
funkci:</p>

<pre>
user=&gt; <strong>(forloop-generator '[i 1 10] '(println i))</strong>
(loop [i 1] (when (&lt;= i 10) (println i) (recur (inc i))))
&nbsp;
&nbsp;
user=&gt; <strong>(forloop-generator ['i 1 10] '(println i))</strong>
(loop [i 1] (when (&lt;= i 10) (println i) (recur (inc i))))
&nbsp;
&nbsp;
user=&gt;
</pre>

<p>S&nbsp;vyu¾itím <strong>eval</strong> nakonec mù¾eme vyzkou¹et, zda lze
generovaný kód vùbec spustit (vyhodnotit) a zda dostaneme oèekávaný
výsledek:</p>

<pre>
user=&gt; <strong>(eval (forloop-generator ['i 1 10] '(println i)))</strong>
1
2
3
4
5
6
7
8
9
10
nil
&nbsp;
&nbsp;
user=&gt;
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Úprava programové smyèky <strong>forloop</strong></h2>

<p>Pokusme se nyní nahradit neèitelné generování kódu s&nbsp;vyu¾itím
<strong>quote</strong>, <strong>list</strong> a <strong>concat</strong> za
generování s&nbsp;pou¾itím ¹ablony, tj.&nbsp;za pomoci <i>reader maker</i>
&bdquo;syntax-quote&ldquo; a &bdquo;unquote&ldquo;. Postup je velmi jednoduchý
a u¾ jsme si ho ukazovali v&nbsp;pøedchozích kapitolách &ndash; celý generovaný
kód bude uvozen znakem zpìtného apostrofu (&bdquo;syntax-quote&ldquo;) a pouze
tam, kde budeme potøebovat pou¾ít hodnotu nìjakého symbolu pou¾ijeme znak tildy
pøed jménem tohoto symbolu (&bdquo;unquote&ldquo;). Druhá verze na¹eho
generátoru kódu tedy bude vypadat následovnì:</p>

<pre>
(defn <strong>forloop-generator2</strong>
    [[variable start end] &amp; code]
    `(loop [~variable ~start]
        (when (&lt;= ~variable ~end)
            ~code
            (recur (inc ~variable)))))
</pre>

<p>Na první pohled prozatím není v&nbsp;tomto zápisu patrná ¾ádná chyba, proto
si generátor kódu vyzkou¹íme:</p>

<pre>
user=&gt; <strong>(forloop-generator2 '[i 1 10] '(println i))</strong>
(clojure.core/loop [i 1] (clojure.core/when (clojure.core/&lt;= i 10) ((println i))
 (recur (clojure.core/inc i))))
&nbsp;
&nbsp;
user=&gt;
</pre>

<p>Vidíme, ¾e jména symbolù byla roz¹íøena o jmenný prostor, co¾ je dobøe. Dále
se v&nbsp;kódu správnì nahradily èásti ~variable, ~start a ~end za
<strong>i</strong>, <strong>1</strong> a <strong>10</strong>, co¾ je takté¾
správnì. Jediný problém v¹ak spoèívá v&nbsp;tom, ¾e tìlo smyèky má okolo sebe
je¹tì jedny kulaté závorky, co¾ ji¾ korektní není. O tom, ¾e se skuteènì jedná
o chybu, se mù¾eme snadno pøesvìdèit ve chvíli, kdy se pokusíme smyèku zavolat,
tj.&nbsp;vyhodnotit:</p>

<pre>
user=&lt; <strong>(eval (forloop-generator2 '[i 1 10] '(println i)))</strong>
1
NullPointerException   user/eval36 (NO_SOURCE_FILE:26)
&nbsp;
&nbsp;
user=&gt;
</pre>

<p>Jak lze této chybì zabránit? Quotování pou¾ité pøi pøedávání tìla smyèky do
generátoru kódu nemù¾eme odstranit, proto¾e by se interpret sna¾il vyhodnotit
<strong>(println i)</strong> je¹tì pøed spu¹tìním funkce
<strong>forloop-generator2</strong>. Druhé závorky se vytvoøily proto, ¾e
symboly tvoøící tìlo smyèky jsou pøedávány formou nepovinných parametrù, které
se v¾dy ukládají do seznamu. Aby se tato chyba napravila, musíme být schopni
nìjak zplo¹tit seznam pøedstavující tìlo smyèky, tj.&nbsp;získat z&nbsp;tohoto
seznamu pouze jeho prvky. To je operace, kterou provádí poslední <i>reader
makro</i> nazvané &bdquo;unquote-splicing&ldquo;, které se zapisuje dvojicí
znakù ~@. Tøetí verze generátoru smyèky bude vypadat následovnì:</p>

<pre>
(defn <strong>forloop-generator3</strong>
    [[variable start end] &amp; code]
    `(loop [~variable ~start]
        (when (&lt;= ~variable ~end)
            ~@code
            (recur (inc ~variable)))))
</pre>

<p>Nezbývá ne¾ tuto verzi smyèky otestovat:</p>

<pre>
user=&gt; <strong>(forloop-generator3 '[i 1 10] '(println i))</strong>
(clojure.core/loop [i 1] (clojure.core/when (clojure.core/&lt;= i 10) (println i) (
recur (clojure.core/inc i))))
&nbsp;
&nbsp;
user=&gt; <strong>(eval (forloop-generator3 '[i 1 10] '(println i)))</strong>
1
2
3
4
5
6
7
8
9
10
nil
&nbsp;
&nbsp;
user=&gt;
</pre>

<p>Chování se zdá být v&nbsp;poøádku, tak¾e mù¾eme pøistoupit k&nbsp;vytvoøení
makra, co¾ je jednoduché, proto¾e prostì nahradíme <strong>defn</strong> za
<strong>defmacro</strong>:</p>

<pre>
(defmacro <strong>forloop</strong>
    [[variable start end] &amp; code]
    `(loop [~variable ~start]
        (when (&lt;= ~variable ~end)
            ~@code
            (recur (inc ~variable)))))
</pre>

<p>A ihned mù¾eme toto makro odzkou¹et &ndash; tentokrát ji¾ samozøejmì není
zapotøebí (a ani to není korektní) quotovat pøedávaný vektor ani tìlo
smyèky!</p>

<pre>
user=&gt; <strong>(forloop [x 1 10] (println x))</strong>
1
2
3
4
5
6
7
8
9
10
nil
&nbsp;
&nbsp;
user=&gt; <strong>(forloop [x 1 10] (println (* x x)))</strong>
1
4
9
16
25
36
49
64
81
100
nil
&nbsp;
&nbsp;
user=&gt;
&nbsp;
<i>; finito</i>
</pre>

<p>Zbývá nám pouze doøe¹it jediný zbývající problém, co¾ je druhý úkol pro
ètenáøe. Makro je vhodné upravit takovým zpùsobem, aby se koncová hodnota
poèitadla vyhodnocovala pouze jedenkrát a nikoli na zaèátku ka¾dé iterace.
V&nbsp;na¹ich demonstraèních pøíkladech jsme jako koncovou hodnotu pou¾ívali
celé èíslo, ov¹em kdyby se jednalo o volání funkce s&nbsp;vedlej¹ím efektem,
vznikl by problém. Øe¹ení této chyby není ve skuteènosti tì¾ké &ndash;
postaèuje pou¾ít lokální generovaný symbol naplnìný ve speciální formì
<strong>let</strong>, která bude celou smyèku &bdquo;obalovat&ldquo; &ndash;
viz té¾ poslední verzi makra <strong>trace</strong>, kde se pou¾ívá podobné
øe¹ení.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Eulerovo èíslo<br />
<a href="http://cs.wikipedia.org/wiki/Eulerovo_èíslo">http://cs.wikipedia.org/wiki/Eulerovo_èíslo</a>
</li>

<li>List comprehension<br />
<a href="http://en.wikipedia.org/wiki/List_comprehension">http://en.wikipedia.org/wiki/List_comprehension</a>
</li>

<li>List Comprehensions in Clojure<br />
<a href="http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html">http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html</a>
</li>

<li>Clojure Programming Concepts: List Comprehension<br />
<a href="http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension">http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension</a>
</li>

<li>Clojure core API: for macro<br />
<a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for">http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for</a>
</li>

<li>cirrus machina - The Clojure for macro<br />
<a href="http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/">http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/</a>
</li>

<li>Clojure.org: Clojure home page<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>A Couple of Clojure Agent Examples<br />
<a href="http://lethain.com/a-couple-of-clojure-agent-examples/">http://lethain.com/a-couple-of-clojure-agent-examples/</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/">http://java.sun.com/developer/technicalArticles/DynTypeLang/</a>
</li>

<li>JSR 223: Scripting for the Java<sup>TM</sup> Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=223">http://jcp.org/en/jsr/detail?id=223</a>
</li>

<li>JSR 292: Supporting Dynamically Typed Languages on the Java<sup>TM</sup> Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=292">http://jcp.org/en/jsr/detail?id=292</a>
</li>

<li>Java 7: A complete invokedynamic example<br />
<a href="http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html">http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html</a>
</li>

<li>InvokeDynamic: Actually Useful?<br />
<a href="http://blog.headius.com/2007/01/invokedynamic-actually-useful.html">http://blog.headius.com/2007/01/invokedynamic-actually-useful.html</a>
</li>

<li>A First Taste of InvokeDynamic<br />
<a href="http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html">http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html</a>
</li>

<li>Java 6 try/finally compilation without jsr/ret<br />
<a href="http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html">http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Root.cz: Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM<br />
<a href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/</a></a>
</li>

<li>Root.cz: JamVM aneb alternativa k HotSpotu nejenom pro embedded zaøízení a chytré telefony<br />
<a href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>FindBugs<br />
<a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a>
</li>

<li>GNU Classpath<br />
<a href="www.gnu.org/s/classpath/">www.gnu.org/s/classpath/</a></li>

<li>Java VMs Compared<br />
<a href="http://bugblogger.com/java-vms-compared-160/">http://bugblogger.com/java-vms-compared-160/</a>
</li>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Scala Programming Language<br />
<a href="http://www.scala-lang.org/">http://www.scala-lang.org/</a>
</li>

<li>Run Scala in Apache Tomcat in 10 minutes<br />
<a href="http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes">http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes</a>
</li>

<li>Fast Web Development With Scala<br />
<a href="http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html">http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html</a>
</li>

<li>Top five scripting languages on the JVM<br />
<a href="http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855">http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>CloseableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html">http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

