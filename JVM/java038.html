<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Clojure 7: dal¹í podpùrné funkce pro paralelní programování</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Clojure 7: dal¹í podpùrné funkce pro paralelní programování</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;dne¹ní èásti seriálu o programovacím jazyce Java i o virtuálním stroji Javy dokonèíme popis objektù typu &bdquo;futures&ldquo; nabízených programovacím jazykem Clojure. Kromì toho si øekneme, jak lze vyu¾ít objekty typu &bdquo;promise&ldquo; a navíc se budeme zabývat velmi zajímavou technologií &ndash; STM neboli Software Transactional Memory.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Malé zopakování z&nbsp;minula &ndash; objekty typu &bdquo;futures&ldquo;</a></p>
<p><a href="#k02">2. Dal¹í funkce a makra pou¾ívaná pøi práci s&nbsp;objekty typu &bdquo;futures&ldquo;</a></p>
<p><a href="#k03">3. Objekty typu &bdquo;promise&ldquo;</a></p>
<p><a href="#k04">4. Nebezpeèí, které hrozí pøi práci s&nbsp;objekty typu &bdquo;promise&ldquo;</a></p>
<p><a href="#k05">5. Architektura dataflow realizovaná s&nbsp;vyu¾itím objektù typu &bdquo;promise&ldquo;</a></p>
<p><a href="#k06">6. Technologie STM &ndash; Software Transactional Memory</a></p>
<p><a href="#k07">7. Funkce a makra pou¾ívaná pøi práci s&nbsp;transakcemi</a></p>
<p><a href="#k08">8. Demonstraèní pøíklad: transakce pøi pøevodu penìz mezi dvìma úèty</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Malé zopakování z&nbsp;minula &ndash; objekty typu &bdquo;futures&ldquo;</h2>

<p>V&nbsp;pøedchozí èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o Javì
i o vlastnostech virtuálního stroje Javy</a> jsme si mj.&nbsp;popsali i
takzvané objekty typu <i>futures</i>, které pøedstavují jednu z&nbsp;nìkolika
technologií programovacího jazyka <i>Clojure</i> vyvinutých pro snadnou tvorbu
vícevláknových aplikací. Pøipomeòme si, ¾e s&nbsp;vyu¾itím objektù typu
<i>futures</i> je mo¾né spustit nìjaký výpoèet (obecnì se jedná o vyhodnocení
funkce, zavolání makra èi o zavolání speciální formy), který je provádìn
asynchronnì v&nbsp;samostatném vláknì, tj.&nbsp;tak, ¾e hlavní vlákno mù¾e
ihned pokraèovat v&nbsp;provádìní dal¹ích pøíkazù a nemusí èekat na dokonèení
tohoto výpoètu. V&nbsp;pøípadì, ¾e asynchronní výpoèet skonèí døív, ne¾ je
zapotøebí znát jeho výsledek, nemusí vùbec dojít k&nbsp;synchronizaci vláken,
ov¹em ve chvíli, kdy se programátor dotazuje na výsledek asynchronního výpoètu,
který je¹tì není dokonèen (tj.&nbsp;pøi ètení výsledku s&nbsp;pou¾itím funkce
<strong>deref</strong> nebo makra <strong>@</strong>), je hlavní vlákno
programu pozastaveno tak, aby se poèkalo na dokonèení výpoètu.</p>

<p>Díky tomuto chování je práce s&nbsp;objekty typu <i>futures</i> velmi snadná
a bezpeèná (tj.&nbsp;pøi správné metodì programování by nemìlo dojít
k&nbsp;deadlockùm, &bdquo;vyhladovìní/starvation&ldquo; vláken atd.).
Jednoduchý program spou¹tìjící výpoèty v&nbsp;asynchronnì bì¾ících samostatných
vláknech mù¾e vypadat napøíklad takto (podrobnìj¹í popis viz pøedchozí èást
seriálu):</p>

<pre>
; funkce pro velmi pomalý výpoèet èlenù Fibonacciho øady
(defn fibonacci
    [n]
    (if (&gt; n 2)
        n
        (+ (fibonacci (- n 2)) (fibonacci (- n 1)))))
&nbsp;
&nbsp;
; namísto pøímého volání funkce fibonacci v¹ak spustíme
; dva asynchronní výpoèty s vyu¾itím (future funkce)
&nbsp;
user=&gt; (def future_fibonacci1 (future (fibonacci 35)))
#'user/future_fibonacci1
&nbsp;
user=&gt; (def future_fibonacci2 (future (fibonacci 35)))
#'user/future_fibonacci2
&nbsp;
; oba výpoèty jsou nyní provádìny ve svých vláknech na pozadí
; - lze se o tom pøesvìdèit napøíklad programem "top"
;   nebo s vyu¾itím JConsole/VisualVM spu¹tìné nad interpretrem
;   programovacího jazyka Clojure
&nbsp;
; nyní si explicitnì vy¾ádáme výsledek výpoètu
; - zde ji¾ mù¾e být hlavní vlákno pozastaveno,
;   aby mohl být výpoèet dokonèen
user=&gt; @future_fibonacci1
9227465
&nbsp;
user=&gt; @future_fibonacci2
9227465
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Dal¹í funkce a makra pou¾ívaná pøi práci s&nbsp;objekty typu &bdquo;futures&ldquo;</h2>

<p>V&nbsp;mnoha pøípadech mù¾eme vystaèit pouze s&nbsp;pou¾itím makra
<strong>future</strong> (viz té¾ demonstraèní pøíklad uvedený <a
href="#k01">v&nbsp;pøedchozí kapitole</a>) s&nbsp;tím, ¾e pro získání výsledku
výpoètu bude slou¾it funkce <strong>deref</strong>, která se velmi èasto
v&nbsp;programech zapisuje pouze pomocí zavináèe @ (v&nbsp;tomto pøípadì jde o
makro zabudované do preprocesoru). Ov¹em ve slo¾itìj¹ích aplikacích je mnohdy
nutné se explicitnì dotázat na to, zda ji¾ asynchronní výpoèet skonèil. Tento
dotaz by mìl probìhnout bez toho, aby se hlavní vlákno pozastavilo,
popø.&nbsp;takté¾ mohou nastat situace, které si vynutí ukonèení jednoho èi
více tìchto výpoètù.  Pro v¹echny podobné situace samozøejmì programovací jazyk
<i>Clojure</i> nabízí odpovídající funkce èi makra. Dotaz na stav výpoètu se
provádí s&nbsp;vyu¾itím funkce <strong>realized?</strong>. Jak ji¾ z&nbsp;názvu
této funkce (otazník na konci) vyplývá, jedná se o predikát vracející
pravdivostní hodnotu <strong>true</strong> nebo <strong>false</strong>
v&nbsp;závislosti na tom, jestli byl asynchronní výpoèet pøedstavovaný objektem
typu <i>future</i> ji¾ ukonèen èi nikoli.</p>

<p>Podívejme se nyní na demonstraèní pøíklad, v&nbsp;nìm¾ se aktivnì (tudí¾
nepøíli¹ chytøe :-) èeká na dokonèení vlákna s&nbsp;výpoètem:</p>

<pre>
; rekurzivní zápis funkce pro výpoèet jednoho èlenu
; Fibonacciho posloupnosti
(defn fibonacci
    [n]
    (if (&gt; n 2)
        n
        (+ (fibonacci (- n 2)) (fibonacci (- n 1)))))
&nbsp;
&nbsp;
; pomocná funkce, která pozastaví aktivní
; vlákno na pøibli¾nì jednu sekundu
(defn wait-one-sec [] (Thread/sleep 1000))
&nbsp;
; vytvoøení future objektu s asynchronním výpoètem
(def future_fibonacci1 (future (fibonacci 40)))
&nbsp;
; aktivní èekání na dokonèení výpoètu
(while (not (realized? future_fibonacci1))
       (println "Cekam na konec vypoctu... ")
       (wait-one-sec)
)
&nbsp;
; tisk výsledku výpoètu
(println "Vysledek: " @future_fibonacci1)
</pre>

<p>Podobným zpùsobem je mo¾né pou¾ít i predikát <strong>future-done?</strong>.
Ten je mo¾né aplikovat pouze na objekty typu <i>future</i>, zatímco predikát
<strong>realized?</strong> je mo¾né aplikovat i na lazy sekvence atd.:</p>

<pre>
; vytvoøení future objektu s asynchronním výpoètem
(def future_fibonacci1 (future (fibonacci 40)))
&nbsp;
; aktivní èekání na dokonèení výpoètu
(while (not (future-done? future_fibonacci1))
       (println "Cekam na konec vypoctu... ")
       (wait-one-sec)
)
&nbsp;
; tisk výsledku výpoètu
(println "Vysledek: " @future_fibonacci1)
</pre>

<p>Asynchronní výpoèet lze takté¾ násilnì ukonèit funkcí
<strong>future-cancel</strong>. Pokud k&nbsp;ukonèení výpoètu skuteènì dojde,
vrátí tato funkce pravdivostní hodnotu <strong>true</strong>, v&nbsp;opaèném
pøípadì (výpoèet ji¾ byl ukonèen) se vrátí pravdivostní hodnota
<strong>false</strong>. Opìt se podívejme na jednoduchý demonstraèní
pøíklad:</p>

<pre>
; vytvoøení future objektu s asynchronním výpoètem
(def future_fibonacci1 (future (fibonacci 100)))
#'user/future_fibonacci1
&nbsp;
; èekání jednu sekundu (výpoèet by je¹tì nemìl být ukonèen)
(wait-one-sec)
nil
&nbsp;
; násilné ukonèení asynchronního výpoètu
(future-cancel future_fibonacci1)
true
&nbsp;
; pøi druhém pokusu o násilné ukonèení
; asynchronního výpoètu se pouze vrátí hodnota false
(future-cancel future_fibonacci1)
false
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Objekty typu &bdquo;promise&ldquo;</h2>

<p>S&nbsp;objekty typu <i>future</i> dosti úzce souvisí i funkce
<strong>deliver</strong> a objekty typu <i>promise</i>, které mohou být pou¾ity
pro ulo¾ení výsledku výpoètu do zvolené promìnné (stále se sice bavíme o
výpoètu, ale mù¾e se samozøejmì jednat o jakoukoli dlouhotrvající operaci,
napøíklad zavolání webové slu¾by, ètení dat z&nbsp;SQL databáze atd. atd.).
V&nbsp;programovacím jazyku Clojure pøedstavují objekty typu <i>promise</i>
takové hodnoty, které je¹tì nemusí v&nbsp;dobì své deklarace vùbec existovat,
tj.&nbsp;mù¾e se jednat o hodnoty, je¾ teprve vzniknou, typicky na základì
asynchronnì bì¾ícího výpoètu (pou¾ití objektù typu <i>promise</i>
v&nbsp;jednovláknovém programu je sice mo¾né, ale vìt¹inou zbyteènì
komplikované a souèasnì i nebezpeèné). S&nbsp;tìmito objekty lze provést pouze
dvì èinnosti &ndash; mù¾e se jim nastavit nìjaká hodnota (a to pouze jedenkrát,
nelze ji potom zmìnit) a mù¾e se pøeèíst, pøesnìji øeèeno dereferencovat,
jejich hodnota. Dùle¾ité je, ¾e pokud tato hodnota je¹tì neexistuje
(tj.&nbsp;asynchronní výpoèet se je¹tì nedokonèil), je vlákno, které hodnotu
dereferencuje (ète) pozastaveno na tak dlouho, dokud není hodnota objektu typu
<i>promise</i> skuteènì nastavena. Ihned poté, co je hodnota nastavena, mohou
k&nbsp;této hodnotì ihned pøistupovat i v¹echna ostatní vlákna.</p>

<p>Práce s&nbsp;objekty typu <i>promise</i> je ve skuteènosti velmi jednoduchá.
Nejprve se objekt <i>promise</i> vytvoøí zavoláním funkce
<strong>promise</strong> (která nemá ¾ádné parametry) a samozøejmì se tento
objekt mù¾e navázat na libovolný symbol s&nbsp;vyu¾itím speciální formy
<strong>def</strong>, tj.&nbsp;takto: <strong>(def symbol (promise))</strong>.
Hodnotu lze objektu typu <i>promise</i> pøiøadit s&nbsp;vyu¾itím funkce
<strong>deliver</strong>, které se pøedá jak symbol navázaný na objekt
<i>promise</i>, tak i hodnota, jen¾ se má k&nbsp;objektu pøiøadit:
<strong>(deliver jméno-objektu-promise hodnota)</strong>. Od této chvíle mohou
tuto hodnotu pou¾ívat v¹echna vlákna, která k&nbsp;ní mohou pøistupovat buï
s&nbsp;vyu¾itím funkce <strong>(deref jméno-objektu-promise)</strong> nebo
zkrácenì <strong>@jméno-objektu-promise</strong> (opìt se zde setkáváme
s&nbsp;makrem @ vytvoøeným v&nbsp;preprocesoru). V&nbsp;následujícím
demonstraèním pøíkladu je vytvoøen objekt typu <i>promise</i>, jen¾ je navázán
na symbol <strong>promise-test</strong>. Následnì je tomuto objektu pøiøazena
hodnota 42, která je následnì vypsána. V¹echny tyto èinnosti se provádí
v&nbsp;jediném vláknu, nedochází zde tedy k&nbsp;vytvoøení samostatného vlákna
pro &bdquo;výpoèet&ldquo;:</p>

<pre>
; vytvoøení objektu typu promise
; a navázání na symbol promise-test
(def promise-test (promise))
#'user/promise-test
&nbsp;
; nastavení hodnoty
(deliver promise-test 42)
#&lt;core$promise$reify__6153@1318b: 42&gt;
&nbsp;
; získání nastavené hodnoty
@promise-test
42
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Nebezpeèí, které hrozí pøi práci s&nbsp;objekty typu &bdquo;promise&ldquo;</h2>

<p>Dùle¾itý je takté¾ ji¾ <a href="#k03">v&nbsp;pøede¹lé kapitole</a> zmínìný
fakt, ¾e hodnotu do objektu typu <i>promise</i> je mo¾né nastavit pouze
jedenkrát, tj.&nbsp;po nastavení ji ji¾ nelze zmìnit. Dal¹í pokusy o nastavení
jiné hodnoty jsou jazykem <i>Clojure</i> ignorovány (v&nbsp;nìkterých verzích
se navíc pøi pokusu o pøepis ji¾ nastavené hodnoty vyvolá výjimka &ndash; je
nutné otestovat). Opìt si to mù¾eme ukázat na jednoduchém demonstraèním
pøíkladu, kdy se do <strong>promise-test</strong> nejprve ulo¾í hodnota 42 a
poté se sna¾íme do stejného objektu typu promise ulo¾it odli¹nou hodnotu: 100.
To se nepovede, tak¾e výraz <strong>@promise-test</strong> je vyhodnocen na
42:</p>

<pre>
; vytvoøení objektu typu promise
; a navázání na symbol promise-test
(def promise-test (promise))
#'user/promise-test
&nbsp;
; nastavení hodnoty
(deliver promise-test 42)
#&lt;core$promise$reify__6153@1318b: 42&gt;
&nbsp;
; pokus o nové nastavení hodnoty
(deliver promise-test 100)
nil
&nbsp;
; získání nastavené hodnoty
@promise-test
42
; vidíme, ¾e se vrátila prvnì nastavená hodnota
</pre>

<p>Pøi práci s&nbsp;objekty typu <i>promise</i> hrozí jedno velké nebezpeèí,
s&nbsp;ním¾ jsme se vlastnì pøi popisu vlastností programovacího jazyka Clojure
je¹tì nesetkali &ndash; v&nbsp;pøípadì, ¾e se do tohoto objektu nepøiøadí ¾ádná
hodnota s&nbsp;vyu¾itím funkce <strong>deliver</strong> a nìkteré vlákno se
bude sna¾it pøeèíst hodnotu pøiøazenou k&nbsp;objektu <i>promise</i>, nastane
deadlock. Pøíklad deadlocku je v&nbsp;tomto pøípadì a¾ neskuteènì jednoduchý,
proto¾e pouze postaèuje vytvoøit objekt typu <i>promise</i> a ihned poté se
v&nbsp;tomté¾ vláknì sna¾it pøeèíst k&nbsp;nìmu nastavenou hodnotu. To se
samozøejmì nepovede, tak¾e smyèka <i>REPL</i> bude v&nbsp;deadlocku èekat,
jestli náhodou jiné vlákno pøece jen ký¾enou hodnotu nenastaví:</p>

<pre>
; vytvoøení objektu typu promise
; a navázání na symbol promise-test
(def promise-test (promise))
#'user/promise-test
&nbsp;
; pokus o ètení nenastavené hodnoty
@promise-test
*** deadlock ***
</pre>

<p>V&nbsp;nìkterých pøípadech je nutné pøed ètením hodnoty pøiøazené
k&nbsp;objektu typu <i>promise</i> zjistit, zda je tomuto objektu hodnota ji¾
pøiøazena. Zde nám pomù¾e známý predikát <strong>realized?</strong>, viz té¾
následující demonstraèní pøíklad:</p>

<pre>
; vytvoøení objektu typu promise
; a navázání na symbol promise-test
(def promise-test (promise))
#'user/promise-test
&nbsp;
; test, zda je hodnota ji¾ pøiøazena
(realized? promise-test)
false
; ... samozøejmì je¹tì není
&nbsp;
; nastavení hodnoty
(deliver promise-test 42)
#&lt;core$promise$reify__6153@1318b: 42&gt;
&nbsp;
; dal¹í test, zda je hodnota ji¾ pøiøazena
(realized? promise-test)
true
; ... nyní ji¾ jsme úspì¹nìj¹í
&nbsp;
@promise-test
42
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Architektura dataflow realizovaná s&nbsp;vyu¾itím objektù typu &bdquo;promise&ldquo;</h2>

<p>Po pøeètení pøedchozích dvou kapitol by se mo¾ná mohlo zdát, ¾e objekty typu
<i>promise</i> pøiná¹í pøi tvorbì reálných aplikací jen problémy a nemìly by se
vlastnì vùbec pou¾ívat. Ve skuteènosti se v¹ak mù¾e jednat o velmi u¾iteènou
technologii, jen¾ umo¾òuje tvoøit aplikace ponìkud jiným zpùsobem, ne¾ je tomu
obvykle zvykem. Vìt¹ina dne¹ních programovacích jazykù je toti¾ zalo¾ena na
imperativním zpùsobu zápisu programù, v&nbsp;nich¾ se explicitnì zapisuje tok
bìhu programu: sekvence pøíkazù, rozvìtvení programu, programové smyèky,
rekurze. Alternativnì je ov¹em mo¾né vyu¾ít i zpùsob, který mù¾eme nalézt
v&nbsp;systémech s&nbsp;architekturou <i>dataflow</i> &ndash; v&nbsp;tìchto
systémech se (dosti zjednodu¹enì øeèeno) popisuje, co se má stát ve chvíli, kdy
do nìjakého funkèního bloku pøijdou v¹echny potøebné vstupní údaje a u¾ se
vìt¹inou explicitnì neuvádí, v&nbsp;jakém poøadí jsou jednotlivé funkèní bloky
vykonávány. Èistì teoreticky mohou v¹echny funkèní bloky pracovat paralelnì,
co¾ je také jeden z&nbsp;dùvodù, proè se v&nbsp;minulosti <i>dataflow</i>
systémùm vìnovala pomìrnì velká pozornost.</p>

<p>V&nbsp;souèasnosti lze za dataflow systém pova¾ovat napøíklad grafický
akcelerátor, ov¹em právì s&nbsp;pou¾itím objektù typu <i>promise</i> a takté¾
s&nbsp;vyu¾itím objektù <i>future</i> je mo¾né podobný systém vytvoøit i
v&nbsp;jazyku <i>Clojure</i>. Ostatnì podívejme se na jednoduchý demonstraèní
pøíklad:</p>

<pre>
; funkce pro velmi pomalý výpoèet èlenù Fibonacciho øady
(defn fibonacci
    [n]
    (if (&gt; n 2)
        n
        (+ (fibonacci (- n 2)) (fibonacci (- n 1)))))
&nbsp;
&nbsp;
; vytvoøení tøí objektù typu promise
(def x (promise))
(def y (promise))
(def z (promise))
&nbsp;
; tøi asynchronnì bì¾ící výpoèty,
; v nich¾ se postupnì (nìkdy v budoucnu)
; nastaví hodnoty v¹ech tøí objektù
; typu promise
(def task-1
    (future
        (deliver z (+ @x @y))))
&nbsp;
(def task-2
    (future
        (deliver x (fibonacci 35))))
&nbsp;
(def task-3
    (future
        (deliver y (fibonacci 40))))
&nbsp;
&nbsp;
; výpoèty nyní bì¾í, pøièem¾ ve skuteènosti první
; výpoèet musí èekat na dokonèení ostatních dvou
; asynchronních vláken
&nbsp;
; kdykoli se mù¾eme dotázat na @x, @y èi @z
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Technologie STM &ndash; Software Transactional Memory</h2>

<p>S&nbsp;vyu¾itím objektù typu <i>future</i> je mo¾né, jak ji¾ po pøeètení
pøedchozích odstavcù víme, velmi snadno realizovat asynchronnì bì¾ící výpoèty.
Podobnì je tomu i v&nbsp;pøípadì takzvaných <i>agentù</i>, s&nbsp;nimi¾ se
podrobnìji seznámíme v&nbsp;následující èásti tohoto seriálu. Pøi programování
reálných vícevláknových aplikací se v¹ak èasto setkáme s&nbsp;problémy, které
lze vyøe¹it buï slo¾itì s&nbsp;vyu¾itím zámkù èi synchronizovaných blokù (co¾
je postup pou¾ívaný velmi èasto v&nbsp;Javì, která pro tyto úèely má vyhrazeno
i klíèové slovo), popø.&nbsp;jednodu¹¹í cestou &ndash; pomocí <i>transakcí</i>.
Jednou z&nbsp;dùle¾itých technologií, kterou programovací jazyk <i>Clojure</i>
vývojáøùm nabízí, je toti¾ i takzvaná <i>STM</i> neboli &bdquo;Software
Transactional Memory&ldquo;, díky ní¾ lze transakce realizovat. Pod pojmem
transakce rozumíme takovou operaci, která se z&nbsp;hlediska ostatních vláken
provede atomicky, tj.&nbsp;v&nbsp;jeden okam¾ik. Souèasnì je transakce
provádìna izolovanì; operace provádìné uvnitø transakce (zmìna nìkterých
referencí atd.) není viditelná zvenku a¾ do chvíle, kdy je transakce ukonèena.
Takté¾ je mo¾né spustit transakci uvnitø jiné transakce &ndash; vnitøní
transakce v&nbsp;tomto pøípadì provede <i>commit</i>&ndash;ulo¾ení výsledkù a¾
souèasnì s&nbsp;transakcí vnìj¹í (co¾ je oèekávatelné chování). Obecnì je
mo¾né øíci, ¾e transakce v&nbsp;Clojure splòují vlastnost ACID (viz té¾
databázové transakce), s&nbsp;tím, ¾e o konzistenci se musí postarat sám
programátor.</p>

<p>Transakce implementované v&nbsp;programovacím jazyce <i>Clojure</i> navíc
nepou¾ívají ¾ádné zámky a sna¾í se být pøi svém spou¹tìní
&bdquo;optimistické&ldquo;. Co to v&nbsp;praxi vlastnì znamená? Pokud je nìjaká
èást kódu vykonávána v&nbsp;transakci, provede se nejprve kopie v¹ech
referencí, které jsou uvnitø transakce mìnìny a v¹echny operace se následnì
provádí nad tìmito kopiemi (zvnìj¹ku to tedy vypadá tak, ¾e transakce nemìní
¾ádné jiné objekty). Navíc se v¹echny transakce mohou spou¹tìt paralelnì a
nezávisle na sobì. Co se v¹ak stane v&nbsp;pøípadì, ¾e nìjaká transakce po svém
ukonèení zjistí, ¾e jí vypoètené hodnoty, které se sna¾í <i>commitovat</i>, ji¾
byly mezitím zmìnìny? Systém v&nbsp;tomto pøípadì jednodu¹e transakci spustí
znova a vyu¾ije pøitom ji¾ zmìnìné hodnoty. V&nbsp;praxi to sice mù¾e znamenat,
¾e nastávají situace, kdy bude jedna transakce spu¹tìna klidnì i nìkolikrát,
ov¹em zde velmi zále¾í na tom, co konkrétní aplikace vlastnì provádí &ndash;
uvádí se, ¾e <strong>obecnì</strong> je vyu¾ití transakcí rychlej¹í, ne¾
explicitní pou¾ití zámkù/synchronizovaných blokù, ov¹em mù¾e se stát, ¾e
aplikace bude mít spu¹tìno nìkolik tisíc transakcí, které na sobì budou závislé
a zde bude ji¾ situace odli¹ná (popravdì øeèeno bych v¹ak nechtìl takovou
aplikaci vyu¾ívající zámky/synchronizované bloky ladit).</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Funkce a makra pou¾ívaná pøi práci s&nbsp;transakcemi</h2>

<p>V&nbsp;transakcích se vìt¹inou pracuje nikoli s&nbsp;globálními promìnnými,
ale s&nbsp;objekty typu <i>ref</i>. S&nbsp;tìmito typy objektù jsme se sice
prozatím je¹tì nesetkali, i kdy¾ je na nich v&nbsp;podstatì zalo¾ena filozofie
jazyka <i>Clojure</i>, ov¹em práce s&nbsp;nimi je z&nbsp;u¾ivatelského hlediska
velmi jednoduchá. Objekt typu <i>ref</i> se vytvoøí zavoláním funkce
<strong>ref</strong>, které se pøedá i poèáteèní hodnota tohoto objektu. Aby se
s&nbsp;<i>ref</i> mohlo dále pracovat, navazuje se obvykle na nìjaký symbol
s&nbsp;vyu¾itím speciální formy <strong>def</strong> (tím se objekt
&bdquo;pojmenuje&ldquo;). Podívejme se na dvì definice objektu typu <i>ref</i>
s&nbsp;navázáním tìchto objektù na dvojici globálních symbolù:</p>

<pre>
user=&gt; (def my-ref (ref 42))
#'user/my-ref
&nbsp;
user=&gt; (def string-ref (ref "Hello world"))
#'user/string-ref
</pre>

<p>Hodnotu, resp.&nbsp;pøesnìji øeèeno stav objektu <i>ref</i> lze získat
s&nbsp;vyu¾itím funkce <strong>deref:</strong></p>

<pre>
user=&gt; (deref my-ref)
42
&nbsp;
user=&gt; (deref string-ref)
"Hello world"
</pre>

<p>Pro zjednodu¹ení se v¹ak v&nbsp;reálných programech namísto volání
<strong>deref</strong> pou¾ívá spí¹e makro preprocesoru zapisované pomocí
zavináèe:</p>

<pre>
user=&gt; @my-ref
42
user&gt; @string-ref
"Hello world"
</pre>

<p>Nyní se ji¾ koneènì dostáváme k&nbsp;pou¾ití objektù typu <i>ref</i>
v&nbsp;transakcích. Pro zmìnu stavu tìchto objektù slou¾í funkce
<strong>ref-set</strong> a takté¾ funkce <strong>alter</strong>. Odli¹nost mezi
tìmito funkcemi spoèívá v&nbsp;tom, ¾e se pomocí <strong>ref-set</strong> pøímo
nastavuje nová hodnota (nový stav <i>ref</i>), zatímco pøes
<strong>alter</strong> je hodnotu mo¾né zmìnit tak, ¾e se na pùvodní stav
zavolá vybraná funkce, která samozøejmì mù¾e mít i dal¹í parametry. Nejprve se
podívejme na to, co se stane ve chvíli, kdy se pokusíme zavolat funkci
<strong>ref-set</strong> <i>mimo transakci</i>:</p>

<pre>
user=&gt; (ref-set my-ref 10)
IllegalStateException No transaction running  clojure.lang.LockingTransaction.getEx (LockingTransaction.java:208)
&nbsp;
user=&gt; (ref-set string-ref "xyzzy")
IllegalStateException No transaction running  clojure.lang.LockingTransaction.getEx (LockingTransaction.java:208)
</pre>

<p>Je vidìt, ¾e <i>Clojure</i> v&nbsp;tomto pøípadì nebyl pøíli¹ nad¹ený :-),
jeliko¾ je funkce <strong>ref-set</strong> urèena pro pou¾ití uvnitø transakcí
a nikoli pro obecné pou¾ití mimo transakce. Podobnì to dopadne v&nbsp;pøípadì
funkce <strong>alter</strong>:</p>

<pre>
user=&gt; (alter my-ref + 10)
IllegalStateException No transaction running  clojure.lang.LockingTransaction.getEx (LockingTransaction.java:208)
</pre>

<p>Aby se zmìna stavu objektu <i>ref</i> podaøila, musíme ji provést
v&nbsp;transakci, která se nejjednodu¹eji zapisuje pomocí makra
<strong>dosync</strong>. V&nbsp;tomto makru mù¾e být uvedeno libovolné mno¾ství
forem, které se postupnì provedou a to takovým zpùsobem, ¾e zaruèí v¹echny
vlastnosti transakcí &ndash; tj.&nbsp;klasický ACID:</p>

<pre>
user=&gt; (dosync (ref-set my-ref 10))
10
</pre>

<p>Více pøíkazù v&nbsp;jedné transakci se zapisuje následujícím zpùsobem:</p>

<pre>
(dosync
    (ref-set my-ref 20)
    (ref-set string-ref "xyzzy"))
</pre>

<p>Zbývá nám ukázat funkci <strong>alter</strong>, která se takté¾ musí volat
uvnitø transakce:</p>

<pre>
user=&gt; (dosync (alter my-ref + 10))
30
</pre>

<p>Popø:</p>

<pre>
(dosync
    (ref-set string-ref "root.cz")
    (alter my-ref * 2))
</pre>

<p>Ètení hodnoty (stavu) objektu <i>ref</i> lze provést kdykoli, tj.&nbsp;i
mimo transakci:</p>

<pre>
user=&gt; @string-ref
&nbsp;
"root.cz"
user=&gt; @my-ref 
40
</pre>

<p>Pøi práci s&nbsp;transakcemi je nutné dbát pøedev¹ím na to, aby se do funkce
<strong>alter</strong> pøedávaly jen takové funkce, které nemají vedlej¹í
efekt. Proè tomu tak musí být? Vzpomeòme si na pøedchozí kapitolu, kde jsme si
øekli, ¾e transakce mù¾e být v&nbsp;pøípadì potøeby spu¹tìna i nìkolikrát za
sebou, tak¾e si asi doká¾ete pøedstavit, jaké problémy by funkce
s&nbsp;vedlej¹ím efektem mohla v&nbsp;reálných aplikacích zpùsobit.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Demonstraèní pøíklad: transakce pøi pøevodu penìz mezi dvìma úèty</h2>

<p>Typickým pøíkladem, na nìm¾ se velmi èasto vysvìtlují databázové transakce,
je funkce (v&nbsp;SQL databázích spí¹e ulo¾ená procedura) provádìjící pøevod
penìz z&nbsp;jednoho úètu na druhý. V&nbsp;reálném svìtì jde
z&nbsp;pochopitelných dùvodù o dosti choulostivou operaci, u ní¾ je (alespoò
z&nbsp;pohledu vìt¹iny úèastníkù :-) ¾ádoucí, aby byly peníze buï skuteènì
pøevedeny a obsahy obou úètù nále¾itì zmìnìny, nebo aby naopak obsahy obou úètù
zùstaly nezmìnìny v&nbsp;pøípadì, kdy by nìjaká èást transakce z&nbsp;rùzných
dùvodù selhala. Podobnou aplikaci s&nbsp;transakcemi mù¾eme naprogramovat i
s&nbsp;vyu¾itím programovacího jazyka <i>Clojure</i> a bude se kupodivu jednat
o velmi jednoduchý program. Nejprve pro jednoduchost vytvoøíme tøi globální
symboly nazvané <strong>account-1</strong>, <strong>account-2</strong> a
<strong>account-3</strong>, které budou pøedstavovat trojici úètù v&nbsp;bance.
Na prvním úètu je na zaèátku aplikace ulo¾eno 10000 Kè, na druhém úètu 20000 Kè
a na úètu tøetím nejsou prozatím ulo¾eny peníze ¾ádné:</p>

<pre>
(def account-1 (ref 10000))
(def account-2 (ref 20000))
(def account-3 (ref 0))
</pre>

<p>Pro dal¹í zkrácení programu si nadefinujeme pomocnou funkci nazvanou
<strong>print-accounts</strong>, která slou¾í k&nbsp;tisku aktuálního obsahu
v¹ech tøí úètù (obecnì v¹ak není dobré programovat podobné funkce, které
pøistupují pøímo ke globálním symbolùm; berme to jako daò za snahu o co
nejkrat¹í program):</p>

<pre>
(defn print-accounts []
    (println "Account 1 : " @account-1)
    (println "Account 2 : " @account-2)
    (println "Account 3 : " @account-3))
</pre>

<p>Nyní ji¾ mù¾eme naprogramovat nejdùle¾itìj¹í a nejzajímavìj¹í èást celého
demonstraèního pøíkladu. Jedná se o funkci nazvanou pøíhodnì
<strong>transfer-money</strong>, která odeète od prvního vybraného úètu
(pøedanému jako první parametr) zadanou sumu a pøesnì tuté¾ sumu pøiète ke
druhému úètu (pøedanému jako druhý parametr). Tento pøesun penìz je proveden
v&nbsp;transakci, tj.&nbsp;uvnitø makra <strong>dosync</strong>. Modifikace
obsahu obou úètù zaji¹»uje funkce <strong>alter</strong>, která na hodnotu
prvního úètu aplikuje funkci - a na hodnotu druhého úètu pak funkci +:</p>

<pre>
(defn transfer-money [from to amount]
    (dosync
        (alter from - amount)
        (alter to + amount)))
</pre>

<p>Nyní si ji¾ mù¾eme si celý program otestovat:</p>

<pre>
(println "Before transactions: ")
(print-accounts)
&nbsp;
Before transactions:
Account 1 :  10000
Account 2 :  20000
Account 3 :  0
nil
</pre>

<p>Poèáteèní hodnota úètù tedy byla nastavena dobøe. Zkusíme provést dvojici
transakcí:</p>

<pre>
(transfer-money account-1 account-2 1000)
(transfer-money account-2 account-3 10000)
</pre>

<p>A vypsat hodnoty úètù po provedení obou transakcí:</p>

<pre>
(println "After transactions: ")
(print-accounts)
&nbsp;
After transactions:
Account 1 :  9000
Account 2 :  11000
Account 3 :  10000
nil
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Clojure home page<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/">http://java.sun.com/developer/technicalArticles/DynTypeLang/</a>
</li>

<li>JSR 223: Scripting for the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=223">http://jcp.org/en/jsr/detail?id=223</a>
</li>

<li>JSR 292: Supporting Dynamically Typed Languages on the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=292">http://jcp.org/en/jsr/detail?id=292</a>
</li>

<li>Java 7: A complete invokedynamic example<br />
<a href="http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html">http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html</a>
</li>

<li>InvokeDynamic: Actually Useful?<br />
<a href="http://blog.headius.com/2007/01/invokedynamic-actually-useful.html">http://blog.headius.com/2007/01/invokedynamic-actually-useful.html</a>
</li>

<li>A First Taste of InvokeDynamic<br />
<a href="http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html">http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html</a>
</li>

<li>Java 6 try/finally compilation without jsr/ret<br />
<a href="http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html">http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Root.cz: Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM<br />
<a href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/</a></a>
</li>

<li>Root.cz: JamVM aneb alternativa k HotSpotu nejenom pro embedded zaøízení a chytré telefony<br />
<a href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>FindBugs<br />
<a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a>
</li>

<li>GNU Classpath<br />
<a href="www.gnu.org/s/classpath/">www.gnu.org/s/classpath/</a></li>

<li>Java VMs Compared<br />
<a href="http://bugblogger.com/java-vms-compared-160/">http://bugblogger.com/java-vms-compared-160/</a>
</li>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Scala Programming Language<br />
<a href="http://www.scala-lang.org/">http://www.scala-lang.org/</a>
</li>

<li>Run Scala in Apache Tomcat in 10 minutes<br />
<a href="http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes">http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes</a>
</li>

<li>Fast Web Development With Scala<br />
<a href="http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html">http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html</a>
</li>

<li>Top five scripting languages on the JVM<br />
<a href="http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855">http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>CloseableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html">http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

