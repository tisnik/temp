<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Clojure 9: validátory, pozorovatelé a kooperace mezi Clojure a Javou</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Clojure 9: validátory, pozorovatelé a kooperace mezi Clojure a Javou</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;dne¹ní èásti seriálu o programovacím jazyce Java i o virtuálním stroji Javy se ji¾ podeváté budeme zabývat popisem jazyka Clojure postaveného nad JVM. Dnes se seznámíme s takzvanými validátory (validators), hlídaèi/pozorovateli (watchers) a takté¾ zpùsobem kooperace mezi jazykem Clojure a jazykem Java.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Krátké zopakování z&nbsp;minula: identity, stavy a reference v&nbsp;programovacím jazyku Clojure</a></p>
<p><a href="#k02">2. Pøíklad zmìny stavu identity &ndash; tøi verze jednoduchého èítaèe</a></p>
<p><a href="#k03">3. Validátory: validators</a></p>
<p><a href="#k04">4. Demonstraèní pøíklady na pou¾ití validátorù</a></p>
<p><a href="#k05">5. Pozorovatelé/hlídaèi: watchers</a></p>
<p><a href="#k06">6. Kooperace mezi programovacími jazyky Clojure a Java</a></p>
<p><a href="#k07">7. Volání konstruktorù </a></p>
<p><a href="#k08">8. Volání metod javovských objektù</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Krátké zopakování z&nbsp;minula: identity, stavy a reference v&nbsp;programovacím jazyku Clojure</h2>

<p><a
href="http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/">V&nbsp;minulé èásti</a> <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o Javì
i o virtuálním stroji Javy</a> jsme se zabývali technikami, které se
v&nbsp;programovacím jazyku <i>Clojure</i> (postaveným nad JVM) pou¾ívají pro
nastavení a zmìnu stavu v&nbsp;bì¾ící aplikaci. Z&nbsp;èistì teoretického
pohledu by sice zmìna stavu aplikace ve funkcionálních jazycích nemìla být
vùbec umo¾nìna, èím¾ by se mimochodem do znaèné míry vyøe¹il problém
s&nbsp;paralelizací (a s&nbsp;ní souvisejícími deadlocky), ov¹em v&nbsp;praxi
je vìt¹inou nutné se umìt se zmìnou stavu vypoøádat takovým zpùsobem, aby se
jednalo o èinnost, která je provedena za pøesnì stanovených podmínek (viz té¾
programovací jazyk <i>Haskell</i>, v&nbsp;nìm¾ jsou pro tento úèel pou¾ité
<i>monády</i>, které jsou z&nbsp;teoretického hlediska velmi èistým øe¹ením
tohoto problému, ov¹em odli¹ným od øe¹ení, ke kterému se pøiklonil <i>Rich
Hickey</i> v&nbsp;pøípadì jazyka <i>Clojure</i>).</p>

<p>Kvùli podpoøe zmìny stavu za pøesnì stanovených podmínek se
v&nbsp;programovacím jazyku <i>Clojure</i> zcela zámìrnì
<strong>ne</strong>pou¾ívá koncept bì¾ných promìnných, které se mohou mìnit
kdykoli a v&nbsp;jakémkoli vláknì (kde je promìnná viditelná) a namísto toho se
zavedl koncept takzvaných <i>identit</i>, které mohou v&nbsp;rùzném èase bìhu
aplikace nabývat rùzných stavù, pøièem¾ se zde pojmem <i>stav</i> oznaèují
hodnoty libovolného <strong>nemìnitelného</strong> datového typu (do této
kategorie ostatnì spadají v¹echny datové typy nabízené pøímo jazykem
<i>Clojure</i>). S&nbsp;identitami a jejich stavy se v&nbsp;<i>Clojure</i>
pracuje pomocí takzvaných <i>referencí</i>. Zmìna stavù identit mù¾e být
provedena buï <i>koordinovanì</i> (v&nbsp;transakci, s&nbsp;vyu¾itím softwarovì
øízené transakèní pamìti) èi naopak <i>nezávisle</i> na ostatních identitách.
Koordinovanou zmìnu stavu umo¾òují reference typu <i>ref</i>, nezávislou zmìnu
stavu pak reference typu <i>atom</i> a <i>agent</i>.</p>

<p>Zmìna, resp.&nbsp;zmìny stavù identit se takté¾ odli¹ují v&nbsp;tom, ¾e
mohou být provedeny buï <i>synchronnì</i> èi <i>asynchronnì</i> &ndash; opìt
v&nbsp;závislosti na potøebách konkrétní vyvíjené aplikace. Synchronní zmìna
stavu identit je provedena ihned a tudí¾ pøímo ve vláknu, které tuto zmìnu
provádí (synchronní a souèasnì i nezávislá zmìna stavu identity je tedy
z&nbsp;hlediska vývojáøe prakticky toto¾ná se zmìnou hodnoty promìnné). Naopak
asynchronní zmìna stavu identit(y) nemusí být provedena ihned, ale nìkdy
v&nbsp;blí¾e neurèené budoucnosti. To znamená, ¾e asynchronní zmìnu je mo¾né
implementovat v&nbsp;jiném vláknì. Synchronní zmìna stavu je provedena
v&nbsp;pøípadì pou¾ití referencí typu <i>ref</i> a <i>atom</i>, asynchronní
zmìna stavu identit je provádìna v&nbsp;pøípadì vyu¾ití referencí typu
<i>agent</i>:</p>

<table>
<tr><th>Jméno</th><th>Var</th><th>Ref</th><th>Atom</th><th>Agent</th></tr>
<tr><td>Zmìna stavu</td><td>synchronní</td><td>synchronní</td><td>synchronní</td><td>asynchronní</td></tr>
<tr><td>Typ zmìny</td><td>lokální, v rámci jednoho vlákna</td><td>koordinovaná</td><td>nezávislá</td><td>nezávislá</td></tr>
<tr><td>Podpora transakcí</td><td>ne</td><td>ano</td><td>ne</td><td>ne</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Pøíklad zmìny stavu identity &ndash; tøi verze jednoduchého èítaèe</h2>

<p>Pokud se programovací jazyk Clojure uèí vývojáø, který ji¾ pracoval
v&nbsp;nìjakém jiném programovacím jazyce, a» ji¾ se jedná o jazyk funkcionální
èi imperativní, mù¾e mu koncept identit, jejich stavù a referencí pou¾itých pro
pøístup ke stavùm identit pøipadat v&nbsp;nìkterých pøípadech zbyteènì slo¾itý
a omezující (napøíklad mu mù¾e vadit nutnost pou¾ití transakcí èi nutnost
dereferencování hodnot pøi ètení stavu). To je ov¹em ve skuteènosti vlastnost a
nikoli chyba v&nbsp;návrhu Clojure, proto¾e ve chvíli, kdy by vývojáøi mohli
pou¾ívat bì¾né promìnné a mìnit tak jejich stavy prakticky kdykoli, vytratila
by se jedna z&nbsp;pøedností tohoto programovacího jazyka, tj.&nbsp;do znaèné
míry bezproblémový návrh paralelních programù. Pro urèitou analogii nemusíme
chodit daleko &ndash; zavedení silného typového systému takté¾ programátory do
urèité míry omezuje oproti systému slabì typovému, ale výhody silného typového
systému nakonec ve vìt¹inì pøípadù pøeva¾ují, a to nezávisle na tom, zda je
typová kontrola provádìna staticky èi dynamicky.</p>

<p>Podívejme se nyní na jednoduchý problém a nìkteré zpùsoby jeho øe¹ení. Jedná
se o implementaci èítaèe, který má nìjakou poèáteèní hodnotu (pro jednoduchost
nulu) a existuje operace pro zvý¹ení jeho hodnoty a samozøejmì pro pøeètení
jeho hodnoty. Nejjednodu¹¹í implementace èítaèe by spoèívala ve vyu¾ití
reference typu <i>var</i>, co¾ je referenèní typ, který se nejvíce pøibli¾uje
chápání bì¾né promìnné v&nbsp;dal¹ích programovacích jazycích. Pokud má v¹ak
být èítaè vytvoøen tak, aby ho bylo mo¾né pou¾ít ve více vláknech, je vhodnìj¹í
ho implementovat buï jako <i>atom</i> nebo jako referenci typu <i>ref</i>,
její¾ hodnota se zvy¹uje v&nbsp;transakci. Podívejme se nejprve na øe¹ení
vyu¾ívající referenci typu <i>atom</i>:</p>

<pre>
; vytvoøení èítaèe
(def counter (atom 0))
&nbsp;
; jeden ze zpùsobù zvý¹ení hodnoty èítaèe
(swap! counter + 1)
(swap! counter inc)
&nbsp;
; pøeètení hodnoty èítaèe
@counter
</pre>

<p>Pou¾ití softwarovì øízené transakèní pamìti pro implementaci èítaèe sice
vypadá jako kanón na vrabce, ale mù¾e mít v&nbsp;nìkterých pøípadech své
opodstatnìní, napøíklad tehdy, pokud se v&nbsp;transakci nìjak pracuje
s&nbsp;aktuální hodnotou èítaèe:</p>

<pre>
; vytvoøení èítaèe
(def counter (ref 0))
&nbsp;
; jeden ze zpùsobù zvý¹ení hodnoty èítaèe
(dosync (
    (alter counter +1))
&nbsp;
(dosync (
    (alter counter inc))
&nbsp;
; pøeètení hodnoty èítaèe
@counter
</pre>

<p>Jako malou kuriozitu si mù¾eme ukázat i pou¾ití agentù, ov¹em zmìna hodnoty
èítaèe je v&nbsp;tomto pøípadì provedena asynchronnì v&nbsp;jiném vláknu, co¾
znamená, ¾e pøi ètení hodnoty èítaèe (pøes dereferencování) se musí vlákna opìt
sesynchronizovat. To je pochopitelnì nároènìj¹í, ne¾ pouhé atomické pøiètení
jednièky. Jedná se v¹ak pouze o demonstraèní pøíklad:</p>

<pre>
; vytvoøení èítaèe
(def counter (agent 0))
&nbsp;
; jeden ze zpùsobù zvý¹ení hodnoty èítaèe
(send counter + 1)
(send counter inc)
; pøeètení hodnoty èítaèe
@counter
</pre>

<p>Vá¾ený ètenáø ji¾ asi odhadl, ¾e v&nbsp;tomto pøípadì je nejlep¹í a
z&nbsp;implementaèního hlediska i nejefektivnìj¹í pro implementaci èítaèe
pou¾ít referenci typu <i>atom</i>, proto si uka¾me, jak by se dal èítaè
jednodu¹e implementovat s&nbsp;vyu¾itím uzávìru (closure):</p>

<pre>
; funkce counter a s ni "uzavrena" hodnota n
(let
    [n (atom 0)]
    (defn counter
        []
        (swap! n inc)))
&nbsp;
user=&gt; (counter) 
1 
user=&gt; (counter)
2 
user=&gt; (counter) 
3
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Validátory: validators</h2>

<p>Prozatím jsme si popsali pouze ètyøi typy operací, které lze
s&nbsp;referencemi v¹ech ètyø typù provádìt. Jednalo se zejména o vlastní
vytvoøení nové reference. Dále pak o nastavení reference na urèitou hodnotu,
resp.&nbsp;pøesnìji øeèeno zmìnu stavu identity. Tøetí operací byla zmìna
hodnoty reference takovým zpùsobem, ¾e se na stávající hodnotu aplikovala
nìjaká funkce a poslední popsanou operací bylo získání aktuální hodnoty
reference s&nbsp;vyu¾itím dereferencování. V¹echny ètyøi typy operací nad v¹emi
ètyømi referenèními typy jsou vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th>Typ</th><th>Var</th><th>Ref</th><th>Atom</th><th>Agent</th></tr>
<tr><td>Vytvoøení</td><td>(def name value)</td><td>(ref value)</td><td>(atom value)</td><td>(agent value)</td></tr>
<tr><td>Nastavení hodnoty</td><td>(set! name value)</td><td>(ref-set ref value)</td><td>(reset! atom value)</td><td>&times;</td></tr>
<tr><td>Aplikace funkce</td><td>&times;</td><td>(alter ref funkce)</td><td>(swap! atom funkce)</td><td>(send agent funkce)</td></tr>
<tr><td>Ètení hodnoty</td><td>name</td><td>@ref</td><td>@ref</td><td>@ref</td></tr>
</table>

<p>Ov¹em zajímavé a mo¾ná i ponìkud pøekvapivé je to, ¾e operací provádìných
s&nbsp;referenèními typy existuje je¹tì vìt¹í mno¾ství, na rozdíl od bì¾ných
promìnných, které lze jen nastavit èi pøeèíst k&nbsp;nim pøiøazenou hodnotu.
Velmi u¾iteèné mohou být takzvané validátory (<i>validators</i>). Tímto slovem
jsou v&nbsp;programovacím jazyku Clojure oznaèeny funkce, které se volají ve
chvíli, kdy se Clojure sna¾í zmìnit stav identity. V&nbsp;tomto okam¾iku je
mo¾né s&nbsp;vyu¾itím validátoru zajistit kontrolu nad tím, ¾e stav nebude
nastaven na nìjakou nepovolenou hodnotu. Obecnì by validátor mìl být
implementován pomocí funkce bez vedlej¹ích efektù (nemìl by se tedy napøíklad
mìnit stav bì¾ícího programu), který v&nbsp;pøípadì, ¾e je nový stav
v&nbsp;poøádku, vrátí pravdivostní hodnotu <strong>true</strong> a
v&nbsp;pøípadì, ¾e nastavovaná hodnota je z&nbsp;libovolného pohledu
neakceptovatelná, vrátí buï <strong>false</strong>, nebo se vyvolá výjimka.
Validátor se pro libovolnou referenci registruje pomocí funkce
<strong>set-validator!</strong>, co¾ si uká¾eme na demonstraèních pøíkladech
uvedených <a href="#k04">ve ètvrté kapitole</a>.</p>

<p>Mo¾nost vyu¾ití validátorù pøedstavuje jednu z&nbsp;variant, jak do
vytváøeného programového kódu pøidat detekci potenciálnì chybových stavù
programu. Dùle¾ité je takté¾ chování Clojure v&nbsp;pøípadì, ¾e ji¾ pøi
registraci validátoru je aktuální stav identity nastaven na hodnotu, kterou by
validátor mìl vyhodnotit jako neakceptovatelnou &ndash; v&nbsp;tomto pøípadì se
ihned vyvolá výjimka a validátor není zaregistrován, popø.&nbsp;zùstane
zaregistrován pùvodní validátor (pokud ov¹em nìjaký validátor pøedtím
existoval). Zru¹ení registrovaného validátoru je snadné &ndash; funkci
<strong>set-validator!</strong> postaèuje namísto skuteèné funkce pøedat pouze
hodnotu <strong>nil</strong>, nezávisle na tom, zda nìjaký validátor byl èi
nebyl zaregistrován.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Demonstraèní pøíklady na pou¾ití validátorù</h2>

<p>V&nbsp;této kapitole si uká¾eme zpùsob pou¾ití validátorù. Jak ji¾ bylo
øeèeno <a href="#k03">v&nbsp;pøedchozím textu</a>, je mo¾né validátory pou¾ít
na libovolný typ reference, ov¹em my se budeme zabývat jejich pou¾itím spoleènì
s&nbsp;referenèními typy <i>ref</i>, <i>atom</i> a <i>agent</i>, proto¾e u
referenèního typu <i>ref</i> je pou¾ití validátorù omezeno na lokální vazby,
nikoli na vazby vytvoøené na globální úrovni. V&nbsp;prvním demonstraèním
pøíkladu je validátor nastaven na kontrolu referenèního typu <i>ref</i> takovým
zpùsobem, ¾e se kontroluje, zda je nová hodnota sudým èíslem:</p>

<pre>
; vytvoøení reference typu ref
user=&gt; (def x (ref 42))
#'user/x
&nbsp;
; nastavení validátoru pro tuto referenci
user=&gt; (set-validator! x (fn [val] (even? val)))
nil
&nbsp;
; otestujeme, zda validátor skuteènì funguje:
; - nastavení nové hodnoty
user=&gt; (dosync (ref-set x 10))
10
&nbsp;
; - zmìna hodnoty
user=&gt; (dosync (alter x + 10))
20
&nbsp;
; nastavení nevalidní hodnoty
user=&gt; (dosync (alter x + 1))
IllegalStateException Invalid reference state  clojure.lang.ARef.validate (ARef.java:33)
&nbsp;
</pre>

<p>V&nbsp;posledním pøípadì validátor správnì zachytil pokus o zmìnu stavu
identity na hodnotu, která není sudá. Ov¹em kontrola se provádí
&bdquo;vnì&ldquo; transakce, tudí¾ je mo¾né uvnitø transakce pøechodnì nastavit
i ¹patnou hodnotu bez toho, aby se nahlásila chyba (opìt se zde tedy uplatòují
pravidla ACID):</p>

<pre>
; vytvoøení reference typu ref
user=&gt; (def x (ref 42))
#'user/x
&nbsp;
; nastavení validátoru pro tuto referenci
user=&gt; (set-validator! x (fn [val] (even? val)))
nil
&nbsp;
; dvojí zmìna hodnoty uvnitø transakce je OK
; i kdy¾ "mezistav" je ¹patný
user=&gt; (dosync (alter x + 1) (alter x + 1))
12
</pre>

<p>Ve druhém demonstraèním pøíkladu je ukázáno pou¾ití validátoru pro
referenèní typ <i>atom</i>:</p>

<pre>
; vytvoøení reference typu atom
user=&gt; (def my-atom (atom 42))
#'user/my-atom
&nbsp;
; funkce pou¾itá validátorem
user=&gt; (defn positive? [val] (&gt; val 0))
#'user/positive?
&nbsp;
; nastavení validátoru
user=&gt; (set-validator! my-atom (fn [val] (positive? val)))
nil
&nbsp;
; test funkce validátoru
; - nastavení nové hodnoty
user=&gt; (reset! my-atom 20)
20
&nbsp;
; - nastavení ¹patné hodnoty
user=&gt; (reset! my-atom 0)
IllegalStateException Invalid reference state  clojure.lang.ARef.validate (ARef.java:33)
&nbsp;
; test funkce validátoru
; - zmìna hodnoty
user=&gt; (swap! my-atom + 2)
23
&nbsp;
; zmìna NA ¹patnou hodnotu
user=&gt; (swap! my-atom - 1000)
IllegalStateException Invalid reference state  clojure.lang.ARef.validate (ARef.java:33)
</pre>

<p>Podobnì je tomu v&nbsp;pøípadì, ¾e je validátor pou¾it pro referenèní typ
<i>agent</i>:</p>

<pre>
; vytvoøení reference typu agent
user=&gt; (def my-agent (agent 42))
#'user/my-agent
&nbsp;
; nastavení validátoru
user=&gt; (set-validator! my-agent (fn [x] (even? x)))
nil
&nbsp;
; test funkce validátoru
; - zmìna hodnoty
user=&gt; (send my-agent + 10)
#&lt;Agent@e3849c: 52&gt;
&nbsp;
; nastavila se nová hodnota?
user=&gt; @my-agent
52
&nbsp;
; test funkce validátoru
; - pokus o nastavení ¹patné hodnoty
user=&gt; (send my-agent + 1)
#&lt;Agent@e3849c: 52&gt;
; ok, validátor zmìnu hodnoty povolil 
&nbsp;
; nastavila se nová hodnota?
user=&gt; @my-agent
52
; nikoli, proto¾e validátor to nepovolil
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Pozorovatelé/hlídaèi: watchers</h2>

<p>Kromì validátorù popsaných v&nbsp;pøedchozích dvou kapitolách je mo¾né ke
ka¾dé referenci zaregistrovat i libovolné mno¾ství takzvaných pozorovatelù èi
hlídaèù (<i>watcher</i>) &ndash; pou¾ití slova &bdquo;pozorovatel&ldquo; je
mo¾ná v&nbsp;tomto pøípadì vhodnìj¹í, proto¾e &bdquo;hlídaè&ldquo; evokuje
nìjaký subjekt, který doká¾e vyvolat nìjakou dal¹í událost, co¾ v¹ak
v&nbsp;jazyce Clojure neplatí. Podobnì jako v&nbsp;pøípadì validátorù je i
pozorovatel implementován nìjakou funkcí bez vedlej¹ích efektù, která je
zavolána tehdy, pokud se zmìní hodnota nìjaké reference (= stav identity).
Zatímco v¹ak validátor vykonával nìjakou aktivní roli a zasahoval tak do
procesu zmìny stavu hodnoty, u pozorovatelù se oèekává, ¾e budou v&nbsp;tomto
ohledu pasivní, tj.&nbsp;¾e napøíklad pouze zaznamenají, ¾e ke zmìnì stavu
hodnoty do¹lo. Navíc je umo¾nìno, aby pro jednu referenci bylo zaregistrováno
vìt¹í mno¾ství pozorovatelù, které se od sebe odli¹ují pomocí unikátního klíèe
(ten je pozorovateli pøedán pøi ka¾dém jeho zavolání). Tøetím rozdílem je to,
¾e pozorovatel pøi svém zavolání získá jak starou hodnotu reference, tak i
hodnotu novou a dokonce mù¾e být zavolán i nìkolikrát &ndash; to v&nbsp;pøípadì
opakování transakcí.</p>

<p>Uka¾me si opìt nìkolik demonstraèních pøíkladù. Ve v¹ech pøíkladech bude ve
funkci pozorovatele pou¾ita funkce <strong>on-change</strong> vypsaná ní¾e,
která sice pøi striktním pohledu není bez vedlej¹ích efektù, ale vedlej¹ím
efektem ve skuteènosti není zmìna stavu programu, ale pouze výpis textu na
standardní výstup, co¾ mù¾eme akceptovat:</p>

<pre>
(defn on-change
    [key identity old-val new-val]
    (println (str "Old value: " old-val))
    (println (str "New value: " new-val)))
</pre>

<p>Nejprve si uká¾eme chování pozorovatele u referenèního typu <i>ref</i>:</p>

<pre>
; vytvoøení reference typu ref
user=&gt; (def x (ref 42))
#'user/x
&nbsp;
; registrace pozorovatele
user=&gt; (add-watch x "watch-1" on-change)
#&lt;Ref@1e903d5: 42&gt;
&nbsp;
; zmìna hodnoty reference v transakci
user=&gt; (dosync (alter x + 1 ))
Old value: 42
New value: 43
43
&nbsp;
; dvojí zmìna hodnoty reference v transakci
user=&gt; (dosync (alter x + 1) (alter x - 1))
Old value: 43
New value: 43
43
&nbsp;
; odstranìní pozorovatele
user=&gt; (remove-watch x "watch-1")
#&lt;Ref@1e903d5: 43&gt;
; zmìna hodnoty reference v transakci
user=&gt; (dosync (alter x + 1))
44
</pre>

<p>Ve druhém demonstraèním pøíkladu jsou k&nbsp;referenènímu typu <i>atom</i>
zaregistrováni dva pozorovatelé (zde pro jednoduchost pøedstavováni shodnou
funkcí):</p>

<pre>
; vytvoøení reference typu atom
user=&gt; (def my-atom (atom 42))
#'user/my-atom
&nbsp;
; registrace prvního pozorovatele
user=&gt; (add-watch my-atom "watch-1" on-change) 
#&lt;Atom@1ee148b: 42&gt;
&nbsp;
; registrace druhého pozorovatele
user=&gt; (add-watch my-atom "watch-2" on-change)
#&lt;Atom@1ee148b: 42&gt;
&nbsp;
; zmìna hodnoty reference v transakci
user=&gt; (reset! my-atom 0)
Old value: 42
New value: 0
Old value: 42
New value: 0
0
&nbsp;
; pøeètení hodnoty - dereference
user=&gt; @my-atom
0
</pre>

<p>Nyní oba pozorovatele odstraníme:</p>

<pre>
; vytvoøení reference typu agent
user=&gt; (remove-watch my-atom "watch-1")
#&lt;Atom@1ee148b: 0&gt;
&nbsp;
user=&gt; (remove-watch my-atom "watch-2")
#&lt;tom@1ee148b: 0&gt;
&nbsp;
; nastavení nové hodnoty ji¾ není sledováno
user=&gt; (reset! my-atom 99) 
99
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Kooperace mezi programovacími jazyky Clojure a Java</h2>

<p>Zajímavé je, ¾e i kdy¾ je tento èlánek ji¾ devátým èlánkem, který vychází
v&nbsp;cyklu o novém programovacím jazyce, prozatím jsme si popsali jen pomìrnì
velmi malé mno¾ství funkcí, speciálních forem a maker, které se nachází ve
standardních knihovnách <i>Clojure</i>. To je zpùsobeno dvìma fakty. První
pøíèinou je to, ¾e mnohé ji¾ popsané funkce je mo¾né aplikovat na rùzné datové
typy, typicky na seznamy, vektory, mno¾iny a nìkdy té¾ mapy. Navíc se øetìzce
pova¾ují za sekvence znakù, tudí¾ je mnoho tìchto funkcí snadno aplikovatelných
i na øetìzce. Tento pøístup je pro funkcionální jazyky do znaèné míry typický:
nabídnou vývojáøùm pouze nìkolik univerzálních datových typù a k&nbsp;nim
pøíslu¹né univerzální funkce (s&nbsp;trochou nadsázky dokonce mù¾eme øíct, ¾e
pravý opak pøedstavuje klasický objektovì-orientovaný pøístup
s&nbsp;funkcemi/metodami dostupnými pouze pro urèitý specifický datový typ
&ndash; tøídu, resp.&nbsp;pro její instance &ndash; tím nechci øíci, ¾e by OOP
pøístup byl ¹patný, má v¹ak odli¹né uplatnìní a dnes se zneu¾ívá i tam, kde
není vhodný).</p>

<p>Druhá pøíèina tohoto stavu je prozaiètìj¹í &ndash; vzhledem k&nbsp;tomu, ¾e
pùvodní implementace jazyka Clojure byla naprogramována pøímo pro virtuální
stroj Javy (JVM) a programy psané v&nbsp;Clojure jsou pøekládány do Javovského
bajtkódu, bylo by vlastnì zbyteèné a kontraproduktivní se znovu pokou¹et o
novou implementaci v¹ech knihoven, které tvoøí jak souèást Java SE API, tak i
externích knihoven a frameworkù. Jednalo by se toti¾ jak o mrhání èasu vývojáøù
Clojure (vyvinout a udr¾ovat ucelenou knihovnu skuteènì není tak jednoduché,
jak se na zaèátku vývoje mù¾e zdát), tak i èasu programátorù, kteøí by chtìli
Clojure pou¾ívat, proto¾e by se museli uèit nové API. Tento stav byl sice
naru¹en tím, ¾e Clojure je dnes mo¾né pøekládat i do JavaScriptu, to v¹ak
mù¾eme pova¾ovat pouze za indikaci toho, ¾e se zaèíná jednat o v&nbsp;urèitých
kruzích dosti populární programovací jazyk (navíc je jeho pou¾ití na webu
vhodné, napøíklad kvùli existenci agentù atd.). V&nbsp;následujících dvou
kapitolách si popí¹eme první èást rozhraní Clojure-Java. Bude se jednat o
zpùsob práce s&nbsp;Javovskými tøídami v&nbsp;Clojure.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Volání konstruktorù</h2>

<p>Pøi konstrukci instancí javovských tøíd i pøi pøístupu k&nbsp;atributùm a
metodám objektù se v&nbsp;programovacím jazyce Clojure vyu¾ívá nìkolik
speciálních forem. První z&nbsp;tìchto forem nese jméno <strong>new</strong> a
zpùsob jejího pou¾ití ji¾ vyplývá ze samotného názvu této speciální formy:
slou¾í pro vytvoøení instance libovolné javovské tøídy, pøesnìji øeèeno takové
tøídy, u ní¾ lze instance vytváøet. Podívejme se na nìkolik demonstraèních
pøíkladù, které pou¾ití tohoto makra ozøejmí:</p>

<pre>
; prázdný øetìzec
user=&gt; (new String)
""
&nbsp;
; øetìzec inicializovaný literálem
user=&gt; (new String "Hello world")
"Hello world"
&nbsp;
; vytvoøení instance tøídy java.util.Date
; (vytvoøí se s aktuálním datem)
user=&gt; (new java.util.Date)
#inst "2012-08-06T21:02:23.348-00:00"
&nbsp;
; vytvoøení instance tøídy java.awt.Color
user=&gt; (new java.awt.Color 0.0 1.0 0.0)
#&lt;Color java.awt.Color[r=0,g=255,b=0]&gt;
&nbsp;
; pokus o zavolání neexistujícího konstruktoru
user=&gt; (new Integer)
CompilerException java.lang.IllegalArgumentException: No matching ctor found for class java.lang.Integer, compiling:(NO_SOURCE_PATH:6) 
&nbsp;
; tento pøíklad je ov¹em ji¾ v&nbsp;poøádku
user=&gt; (new Integer 42)
42
&nbsp;
; ve speciální formì new lze samozøejmì volat i jiné funkce
user=&gt; (new Integer (* 6 7))
42
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Volání metod javovských objektù</h2>

<p>Druhou dùle¾itou speciální formou je forma s&nbsp;prostým názvem . (teèka).
Jedná se skuteènì o korektní jméno (identifikátor), o èem¾ se mù¾eme snadno
pøesvìdèit zavoláním makra <strong>doc</strong> s&nbsp;pøedáním teèky jako
parametru tohoto makra:</p>

<pre>
user=&gt; (doc .)
-------------------------
.
  (.instanceMember instance args*)
  (.instanceMember Classname args*)
  (Classname/staticMethod args*)
  Classname/staticField
Special Form
  The instance member form works for both fields and methods.
  They all expand into calls to the dot operator at macroexpansion time.
&nbsp;
  Please see http://clojure.org/java_interop#dot
nil
</pre>

<p>Speciální forma . se pou¾ívá pro volání metod, popø.&nbsp;pro pøístup
k&nbsp;atributùm objektù. Opìt se podívejme na nìkolik pøíkladù:</p>

<pre>
; ekvivalent pøíkazu Integer.valueOf("42");
user=&gt; (. Integer valueOf "42")
42
&nbsp;
; ekvivalent pøíkazu Float.MAX_VALUE;
user=&gt; (. Float MAX_VALUE)
3.4028235E38
&nbsp;
; ekvivalent pøíkazu Boolean.TRUE;
user=&gt; (. Boolean TRUE)
true
&nbsp;
; pøístup ke konstantnímu atributu
user=&gt; (. Math PI)
3.141592653589793
</pre>

<p>Namísto pøímého uvedení jména tøídy je mo¾né uvést i jméno navázané na
instanci nìjakého objektu:</p>

<pre>
user=&gt; (def my-string "Hello world")
#'user/my-string
&nbsp;
user=&gt; (. my-string length)
11
&nbsp;
user=&gt; (. my-string toUpperCase)
"HELLO WORLD"
&nbsp;
user=&gt; (. my-string substring 6)
"world"
</pre>

<p>Poslední dùle¾itou speciální formou je forma s&nbsp;názvem
<strong>set!</strong>, kterou lze pou¾ít pro nastavení viditelného atributu
objektu. V&nbsp;následujícím pøíkladu se nejprve vytvoøí instance tøídy
<strong>java.awt.Rectangle</strong> a posléze se nastaví ¹íøka a vý¹ka tohoto
obdélníku:</p>

<pre>
; vytvoøení instance tøídy java.awt.Rectangle
user=&gt; (def rect (new java.awt.Rectangle))
#'user/rect
&nbsp;
; pøevod objektu na øetìzec (toString)
user=&gt; rect    
#&lt;Rectangle java.awt.Rectangle[x=0,y=0,width=0,height=0]&gt;
&nbsp;
; nastavení ¹íøky obdélníku
user=&gt; (set! (. rect width) 320)
320
&nbsp;
; nastavení vý¹ky obdélníku
user=&gt; (set! (. rect height) 240)
240
&nbsp;
; pøevod objektu na øetìzec (toString)
user=&gt; rect
#&lt;Rectangle java.awt.Rectangle[x=0,y=0,width=320,height=240]&gt;
</pre>

<p>Slo¾itìj¹í, praktiètìji zamìøené pøíklady, si uká¾eme pøí¹tì.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Clojure.org: Clojure home page<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>A Couple of Clojure Agent Examples<br />
<a href="http://lethain.com/a-couple-of-clojure-agent-examples/">http://lethain.com/a-couple-of-clojure-agent-examples/</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/">http://java.sun.com/developer/technicalArticles/DynTypeLang/</a>
</li>

<li>JSR 223: Scripting for the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=223">http://jcp.org/en/jsr/detail?id=223</a>
</li>

<li>JSR 292: Supporting Dynamically Typed Languages on the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=292">http://jcp.org/en/jsr/detail?id=292</a>
</li>

<li>Java 7: A complete invokedynamic example<br />
<a href="http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html">http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html</a>
</li>

<li>InvokeDynamic: Actually Useful?<br />
<a href="http://blog.headius.com/2007/01/invokedynamic-actually-useful.html">http://blog.headius.com/2007/01/invokedynamic-actually-useful.html</a>
</li>

<li>A First Taste of InvokeDynamic<br />
<a href="http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html">http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html</a>
</li>

<li>Java 6 try/finally compilation without jsr/ret<br />
<a href="http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html">http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Root.cz: Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM<br />
<a href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/</a></a>
</li>

<li>Root.cz: JamVM aneb alternativa k HotSpotu nejenom pro embedded zaøízení a chytré telefony<br />
<a href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>FindBugs<br />
<a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a>
</li>

<li>GNU Classpath<br />
<a href="www.gnu.org/s/classpath/">www.gnu.org/s/classpath/</a></li>

<li>Java VMs Compared<br />
<a href="http://bugblogger.com/java-vms-compared-160/">http://bugblogger.com/java-vms-compared-160/</a>
</li>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Scala Programming Language<br />
<a href="http://www.scala-lang.org/">http://www.scala-lang.org/</a>
</li>

<li>Run Scala in Apache Tomcat in 10 minutes<br />
<a href="http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes">http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes</a>
</li>

<li>Fast Web Development With Scala<br />
<a href="http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html">http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html</a>
</li>

<li>Top five scripting languages on the JVM<br />
<a href="http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855">http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>CloseableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html">http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

