<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - double buffering v praxi (dokonèení)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - double buffering v praxi (dokonèení)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o virtuálním stroji Javy dokonèíme popis zpùsobù vyu¾ití double bufferingu v javovských aplikacích zalo¾ených na knihovnách AWT èi Swing. Uká¾eme si zpùsob vyu¾ití tøídy BufferStrategy pøi explicitním vytvoøení zadního bufferu.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - double buffering v praxi (dokonèení)</a></p>
<p><a href="#k02">2. První demonstraèní pøíklad: vykreslování do objektu typu Canvas bez pou¾ití double bufferingu</a></p>
<p><a href="#k03">3. Úprava pøíkladu takovým zpùsobem, aby se vykreslování provádìlo do zadního bufferu</a></p>
<p><a href="#k04">4. Druhý demonstraèní pøíklad: vykreslování do objektu typu Canvas s&nbsp;vyu¾itím double bufferingu</a></p>
<p><a href="#k05">5. Double buffering a exkluzivní celoobrazovkové grafické re¾imy</a></p>
<p><a href="#k06">6. Nastavení celoobrazovkového grafického re¾imu a vytvoøení zadního bufferu</a></p>
<p><a href="#k07">7. Tøetí demonstraèní pøíklad: double buffering v&nbsp;celoobrazovkovém grafickém re¾imu</a></p>
<p><a href="#k08">8. Repositáø se zdrojovými kódy dne¹ních demonstraèních pøíkladù</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - double buffering v praxi (dokonèení)</h2>

<p>V&nbsp;pøedchozí èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyce Java i o virtuálním stroji Javy</a> jsme si øekli, jakým
zpùsobem je double buffering pou¾it v&nbsp;knihovnì Swing a jak je mo¾né
v&nbsp;pøípadì potøeby vyu¾ití zadního bufferu vypnout. Dnes si na nìkolika
demonstraèních pøíkladech uká¾eme vyu¾ití double bufferingu pøi výbìru knihovny
AWT namísto Swing a pøi vykreslování grafiky s&nbsp;vyu¾itím celoobrazovkových
exkluzivních grafických re¾imù (kde lze takté¾ vyu¾ít mo¾ností nabízených
knihovnou AWT). Ihned na zaèátku tohoto èlánku je mo¾ná vhodné si pøipomenout
základní rozdíly mezi knihovnami AWT (Abstract Window Toolkit) a Swing.
Knihovna AWT se sna¾í vyu¾ívat nativní ovládací prvky (widgety), tak¾e na tuto
knihovnu lze pohlí¾et jako na urèitý most mezi Javou a nativními toolkity. To
napøíklad znamená, ¾e vzhled ovládacích prvkù i jejich chování je mo¾né mìnit
jen v&nbsp;urèitých (relativnì malých) mezích a souèasnì se vzhled aplikace
mù¾e na rùzných platformách odli¹ovat (co¾ nìkdy mù¾e být vhodné chování).</p>

<p>Naproti tomu jsou v&nbsp;knihovnì Swing v¹echny komponenty (ovládací prvky
atd.) vykreslovány s&nbsp;vyu¾itím metod naprogramovaných v&nbsp;Javì
s&nbsp;tím, ¾e nízkoúrovòové kreslicí operace jsou implementovány
v&nbsp;nativních funkcích resp.&nbsp;voláním metod Java2D (teprve ty internì
volají nativní metody). Díky tomu je mo¾né do znaèné míry mìnit vzhled i
chování v¹ech ovládacích prvkù, zajistit stejný vzhled aplikace na v¹ech
systémech apod. Navíc je pøi vykreslování v¹ech komponent implicitnì pou¾íván
double buffering, co¾ je problematika, kterou jsme se podrobnìji zabývali
minule.</p>

<p>Zatímco vìt¹ina javovských aplikací s&nbsp;GUI ji¾ vyu¾ívá mo¾nosti knihovny
Swing, je situace pøi návrhu hry èi jiné graficky nároèné aplikace, která
vyu¾ívá celoobrazovkové re¾imy, situace ponìkud odli¹ná, proto¾e zde vìt¹inou
nevyu¾ijeme v¹ech vlastností Swingu a navíc mù¾e být pou¾ití swingovských
komponent vykreslovaných s&nbsp;vyu¾itím kódu napsaného v&nbsp;Javì zbyteènì
limitující a pomalé. Proto si dnes uká¾eme, jak lze vyu¾ít komponenty
<strong>java.awt.Frame</strong> a <strong>java.awt.Canvas</strong> pro tvorbu
základní kostry grafického subsystému hry.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. První demonstraèní pøíklad: vykreslování do objektu typu Canvas bez pou¾ití double bufferingu</h2>

<p>První demonstraèní pøíklad je velmi jednoduchý, ov¹em pomìrnì dobøe nám
ukazuje nìkteré základní vlastnosti knihovny <i>AWT</i>. Po spu¹tìní tohoto
pøíkladu se vytvoøí nové okno pøedstavované instancí tøídy odvozené od tøídy
<strong>java.awt.Frame</strong>. Do okna je vlo¾en prvek typu
<strong>java.awt.Canvas</strong>, resp.&nbsp;pøesnìji øeèeno se opìt jedná o
instanci tøídy odvozené od <strong>java.awt.Canvas</strong>. Dùle¾ité je, ¾e
v&nbsp;odvozené tøídì do¹lo k&nbsp;pøekrytí metody <strong>public void
paint(Graphics g)</strong>, díky èemu¾ je mo¾né na Canvas (kreslicí plátno)
vykreslovat libovolný obrazec. Zde v¹ak narazíme na jednu potenciálnì
nepøíjemnou vlastnost &ndash; vzhledem k&nbsp;tomu, ¾e se v&nbsp;knihovnì
<i>AWT</i> implicitnì nepou¾ívá double buffering, bude na pomalej¹ích
poèítaèích viditelné pomalé pøekreslování obrazce, co¾ je nejlépe patrné pøi
postupném zvìt¹ování a/nebo zmen¹ování okna (rámce). Pokud je pøekreslování na
va¹em poèítaèi dostateènì rychlé, je mo¾né ne¾ádoucí grafické efekty jednodu¹e
vyvolat tak, ¾e se zmìní krok vykreslovací smyèky z&nbsp;hodnoty 0.005 na
hodnotu 0.001 èi je¹tì ni¾¹í hodnotu. Aplikace se jednodu¹e ukonèí stiskem
tlaèítka my¹i kamkoli na kreslicí plochu.</p>

<pre>
import java.awt.Canvas;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Frame;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Test vykreslovani na objekt typu Canvas v pripade, ze neni</i>
<i> * povoleno pouzivani double bufferingu.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>DoubleBufferTest1</strong> extends <strong>Frame</strong> {
&nbsp;
<i>    /**</i>
<i>     * Generated serial version UID.</i>
<i>     */</i>
    private static final long serialVersionUID = 6423061537074933572L;
&nbsp;
<i>    /**</i>
<i>     * Kreslici plocha - Canvas.</i>
<i>     */</i>
    private Drawing1 drawing = new Drawing1();
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni okna a pridani kresby do tohoto okna.</i>
<i>     */</i>
    private void <strong>run</strong>() {
<i>        // pri postupnem zvetsovani okna bude prosvitat modre pozadi</i>
        this.setBackground(Color.BLUE);
<i>        // potrebujeme aktivni okraje okna</i>
        this.setUndecorated(false);
<i>        // pridani kresby do okna</i>
        this.add(this.drawing);
        this.pack();
        this.setVisible(true);
    }
&nbsp;
<i>    /**</i>
<i>     * Spusteni testu.</i>
<i>     */</i>
    public static void <strong>main</strong>(String[] args) {
        new DoubleBufferTest1().run();
    }
&nbsp;
}
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Kreslici plocha odvozena od objektu typu Canvas.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
class <strong>Drawing1</strong> extends <strong>Canvas</strong> {
&nbsp;
<i>    /**</i>
<i>     * Generated serial version UID.</i>
<i>     */</i>
    private static final long serialVersionUID = -3936987144006140956L;
&nbsp;
<i>    /**</i>
<i>     * Konstruktor - nastaveni zakladnich parametru kreslici plochy.</i>
<i>     */</i>
    public <strong>Drawing1</strong>() {
        this.setBackground(Color.WHITE);
        this.setPreferredSize(new Dimension(800, 600));
        addCustomMouseListener();
    }
&nbsp;
<i>    /**</i>
<i>     * Mouse listener zajisti ukonceni programu po kliku na kreslici plochu.</i>
<i>     */</i>
    private void <strong>addCustomMouseListener</strong>() {
        addMouseListener(new MouseListener() {
&nbsp;
            public void <strong>mouseClicked</strong>(MouseEvent e) {
                System.exit(0);
            }
&nbsp;
            public void <strong>mousePressed</strong>(MouseEvent e) {
<i>                // prazdny blok</i>
            }
&nbsp;
            public void <strong>mouseReleased</strong>(MouseEvent e) {
<i>                // prazdny blok</i>
            }
&nbsp;
            public void <strong>mouseEntered</strong>(MouseEvent e) {
<i>                // prazdny blok</i>
            }
&nbsp;
            public void <strong>mouseExited</strong>(MouseEvent e) {
<i>                // prazdny blok</i>
            }});
    }
&nbsp;
    @Override
    public void <strong>paint</strong>(Graphics g) {
        final Graphics2D graphics2d = (Graphics2D)g;
        graphics2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        final int width = this.getWidth();
        final int height = this.getHeight();
        final double radius = Math.min(width, height) / 3.0;
&nbsp;
<i>        // casove narocne vykresleni obrazce</i>
<i>        // (na rychlejsich pocitacich lze zmenit krok 0.005 na 0.001)</i>
        int xold=0, yold=0;
        for (double d = 0; d &lt; Math.PI *2*7; d += 0.005) {
            int x = (int)(width / 2 + radius * Math.cos(d) + radius/2 * Math.sin(d/7));
            int y = (int)(height / 2 + radius * Math.sin(d) + radius/2 * Math.cos(d/7));
            graphics2d.setColor(Color.BLACK);
            if (d&gt;0) {
                graphics2d.drawLine(xold, yold, x, y);
            }
            xold = x;
            yold = y;
        }
    }
&nbsp;
}
</pre>

<img src="http://i.iinfo.cz/images/230/obr1.png" class="image-158436" width="512" height="384" alt="&#160;" />



<p><a name="k03"></a></p>
<h2 id="k03">3. Úprava pøíkladu takovým zpùsobem, aby se vykreslování provádìlo do zadního bufferu</h2>

<p>Ne¾ádoucí postupné vykreslování obrazce je mo¾né jednodu¹e pøed u¾ivateli
skrýt takovým zpùsobem, ¾e se obrazec nejprve vykreslí do neviditelného zadního
bufferu a teprve poté se buï pøesune do viditelného pøedního bufferu
popø.&nbsp;dojde k&nbsp;velmi rychlému pøepnutí mezi pøedním a zadním bufferem.
Pro explicitní øízení double bufferingu se pou¾ívá tøída
<strong>BufferStrategy</strong>, o ní¾ jsme se zmínili minule. Pøipomeòme si
tedy, ¾e se instance této tøídy vytvoøí zavoláním
<strong>java.awt.Canvas.createBufferStrategy(int)</strong> popø.&nbsp;(co¾ je
asi ménì èasté) zavoláním metody
<strong>java.awt.Window.createBufferStrategy(int)</strong>. Celoèíselná
hodnota, která se tìmto metodám pøedává, reprezentuje celkový poèet bufferù.
Pøitom je zaruèeno, ¾e se daný poèet bufferù skuteènì vytvoøí, ale
v&nbsp;závislosti na mo¾nostech konkrétního poèítaèe nemusí být podporován
<i>page flipping</i> a dokonce ani akcelerované pøená¹ení obsahu zadního
bufferu do bufferu pøedního.</p>

<p>Jakmile je korektnì nastaven double buffering, zmìní se i vykreslovací
rutina, proto¾e ta ji¾ nebude provádìt vykreslování pøímo na
<strong>java.awt.Canvas</strong> s&nbsp;vyu¾itím objektu typu
<strong>Graphics</strong> pøedaného metodì <strong>public void
paint()</strong>, ale do zadního bufferu:</p>

<pre>
BufferStrategy bufferStrategy = canvas.getBufferStrategy();
&nbsp;
while (!done) {
    Graphics graphics;
    try {
        graphics = bufferStrategy.getDrawGraphics();
        <i>... zde se provádí vykreslování ...</i>
        <i>... s vyu¾itím objektu "graphics" ...</i>
    } finally {
        graphics.dispose();
    }
    bufferStrategy.show();
}
</pre>

<p>V&nbsp;na¹em konkrétním pøípadì dojde ve vykreslovací rutinì
k&nbsp;následující zmìnì (zde je pou¾it formát unifikovaného diffu):</p>

<pre>
--- DoubleBufferTest1.java      2014-01-05 21:21:39.000000000 +0100
+++ DoubleBufferTest2.java      2014-01-05 21:21:50.000000000 +0100
@@ -1,6 +1,9 @@
     @Override
     public void paint(Graphics g) {
-        final Graphics2D graphics2d = (Graphics2D)g;
+        // ziskat objekt typu Graphics2D pro zadni buffer
+        BufferStrategy bufferStrategy = getBufferStrategy();
+        final Graphics2D graphics2d = (Graphics2D)bufferStrategy.getDrawGraphics();
+
         graphics2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
         final int width = this.getWidth();
         final int height = this.getHeight();
@@ -18,4 +21,7 @@
             xold = x;
             yold = y;
         }
+        graphics2d.dispose();
+        // prohozeni bufferu a/nebo prekresleni zadniho bufferu do bufferu predniho
+        bufferStrategy.show();
     }
</pre>

<p>Grafické zvýraznìní rozdílu mezi obìma vykreslovacími rutinami:</p>

<a href="http://i.iinfo.cz/images/540/diff.png"><img src="http://i.iinfo.cz/images/540/diff-prev.png" class="image-158435" width="370" height="128" alt="&#160;" /></a>



<p><a name="k04"></a></p>
<h2 id="k04">4. Druhý demonstraèní pøíklad: vykreslování do objektu typu Canvas s&nbsp;vyu¾itím double bufferingu</h2>

<p>Dne¹ní druhý demonstraèní pøíklad ji¾ pøi vykreslování do objektu typu
<strong>java.awt.Canvas</strong> vyu¾ívá double buffering. Princip práce
vykreslovací rutiny jsme si vysvìtlili <a href="#k03">v&nbsp;pøedchozí
kapitole</a>, ov¹em dùle¾itá je takté¾ rutina pou¾itá pro vytvoøení pøedního a
zadního bufferu. Tato rutina je souèástí metody
<strong>DoubleBufferTest2.run()</strong>, v&nbsp;ní¾ se konfigurace bufferù
provádí a¾ poté, kdy je objekt odvozený od <strong>java.awt.Canvas</strong>
vlo¾en do okna/rámce. To je dùle¾ité, proto¾e v&nbsp;pøípadì, ¾e by objekt
<strong>java.awt.Canvas</strong> je¹tì nebyl vlo¾en do jiné komponenty, do¹lo
by k&nbsp;bìhové chybì (co¾ si mù¾ete snadno otestovat):</p>

<pre>
<i>    /**</i>
<i>     * Vytvoreni okna a pridani kresby do tohoto okna.</i>
<i>     */</i>
    private void <strong>run</strong>() {
<i>        // pri postupnem zvetsovani okna bude prosvitat modre pozadi</i>
        this.setBackground(Color.BLUE);
<i>        // potrebujeme aktivni okraje okna</i>
        this.setUndecorated(false);
<i>        // pridani kresby do okna</i>
        this.add(this.drawing);
        this.pack();
<i>        // nastaveni double bufferingu</i>
        this.drawing.createBufferStrategy(2);
        this.setVisible(true);
    }
</pre>

<p>Následuje výpis zdrojového kódu dne¹ního druhého demonstraèního
pøíkladu:</p>

<pre>
import java.awt.Canvas;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Frame;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.image.BufferStrategy;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Test vykreslovani na objekt typu Canvas v pripade, ze je</i>
<i> * povoleno pouzivani double bufferingu.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>DoubleBufferTest2</strong> extends <strong>Frame</strong> {
&nbsp;
<i>    /**</i>
<i>     * Generated serial version UID.</i>
<i>     */</i>
    private static final long serialVersionUID = 6423061537074933572L;
&nbsp;
<i>    /**</i>
<i>     * Kreslici plocha - Canvas.</i>
<i>     */</i>
    private Drawing2 drawing = new Drawing2();
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni okna a pridani kresby do tohoto okna.</i>
<i>     */</i>
    private void <strong>run</strong>() {
<i>        // pri postupnem zvetsovani okna bude prosvitat modre pozadi</i>
        this.setBackground(Color.BLUE);
<i>        // potrebujeme aktivni okraje okna</i>
        this.setUndecorated(false);
<i>        // pridani kresby do okna</i>
        this.add(this.drawing);
        this.pack();
<i>        // nastaveni double bufferingu</i>
        this.drawing.createBufferStrategy(2);
        this.setVisible(true);
    }
&nbsp;
<i>    /**</i>
<i>     * Spusteni testu.</i>
<i>     */</i>
    public static void <strong>main</strong>(String[] args) {
        new DoubleBufferTest2().run();
    }
&nbsp;
}
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Kreslici plocha odvozena od objektu typu Canvas.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
class <strong>Drawing2</strong> extends <strong>Canvas</strong> {
&nbsp;
<i>    /**</i>
<i>     * Generated serial version UID.</i>
<i>     */</i>
    private static final long serialVersionUID = -3936987144006140956L;
&nbsp;
<i>    /**</i>
<i>     * Konstruktor - nastaveni zakladnich parametru kreslici plochy.</i>
<i>     */</i>
    public <strong>Drawing2</strong>() {
        this.setBackground(Color.WHITE);
        this.setPreferredSize(new Dimension(800, 600));
        addCustomMouseListener();
    }
&nbsp;
<i>    /**</i>
<i>     * Mouse listener zajisti ukonceni programu po kliku na kreslici plochu.</i>
<i>     */</i>
    private void <strong>addCustomMouseListener</strong>() {
        addMouseListener(new MouseListener() {
&nbsp;
            public void <strong>mouseClicked</strong>(MouseEvent e) {
                System.exit(0);
            }
&nbsp;
            public void <strong>mousePressed</strong>(MouseEvent e) {
<i>                // prazdny blok</i>
            }
&nbsp;
            public void <strong>mouseReleased</strong>(MouseEvent e) {
<i>                // prazdny blok</i>
            }
&nbsp;
            public void <strong>mouseEntered</strong>(MouseEvent e) {
<i>                // prazdny blok</i>
            }
&nbsp;
            public void <strong>mouseExited</strong>(MouseEvent e) {
<i>                // prazdny blok</i>
            }});
    }
&nbsp;
    @Override
    public void <strong>paint</strong>(Graphics g) {
<i>        // ziskat objekt typu Graphics2D pro zadni buffer</i>
        BufferStrategy bufferStrategy = getBufferStrategy();
        final Graphics2D graphics2d = (Graphics2D)bufferStrategy.getDrawGraphics();
&nbsp;
        graphics2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        final int width = this.getWidth();
        final int height = this.getHeight();
        final double radius = Math.min(width, height) / 3.0;
&nbsp;
<i>        // casove narocne vykresleni obrazce</i>
<i>        // (na rychlejsich pocitacich lze zmenit krok 0.005 na 0.001)</i>
        int xold=0, yold=0;
        for (double d = 0; d &lt; Math.PI *2*7; d += 0.005) {
            int x = (int)(width / 2 + radius * Math.cos(d) + radius/2 * Math.sin(d/7));
            int y = (int)(height / 2 + radius * Math.sin(d) + radius/2 * Math.cos(d/7));
            graphics2d.setColor(Color.BLACK);
            if (d&gt;0) {
                graphics2d.drawLine(xold, yold, x, y);
            }
            xold = x;
            yold = y;
        }
        graphics2d.dispose();
<i>        // prohozeni bufferu a/nebo prekresleni zadniho bufferu do bufferu predniho</i>
        bufferStrategy.show();
    }
&nbsp;
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Double buffering a exkluzivní celoobrazovkové grafické re¾imy</h2>

<p>Velmi èasté je pou¾ití programovì øízeného double bufferingu v&nbsp;tìch
pøípadech, kdy aplikace (vìt¹inou nìjaká hra) provádí vykreslování na celou
obrazovku, tj.&nbsp;pøi vyu¾ití exkluzivních celoobrazovkových grafických
re¾imù. V&nbsp;pøedchozích èástech tohoto seriálu jsme si ji¾ ukázali, jakým
zpùsobem je mo¾né provést pøepnutí do celoobrazovkového grafického re¾imu a jak
lze v&nbsp;pøípadì potøeby vyu¾ít rastrové obrázky typu
<strong>VolatileImage</strong> namísto obecnì pomalej¹ích bitmap typu
<strong>BufferedImage</strong>. Teoreticky je mo¾né
<strong>VolatileImage</strong> pou¾ít ve funkci zadního bufferu, ov¹em vìt¹inou
bývá výhodnìj¹í se spolehnout na to, ¾e grafický subsystém poèítaèe umo¾ní
v&nbsp;celoobrazovkovém re¾imu pou¾ít pøední i zadní buffer s&nbsp;tím, ¾e bude
podporovat operaci typu <i>flip</i> pro prohození funkcí obou bufferù.</p>

<p>Proè je pou¾ití <i>flip</i> mnohem výhodnìj¹í ne¾ volání operace typu
<i>BitBlt</i> pro <strong>VolatileImage</strong> je zøejmé &ndash;
v&nbsp;prvním pøípadì se jedná o jednoduchou operaci, pøi ní¾ se prakticky
nepøená¹í ¾ádná data, kde¾to v&nbsp;pøípadì druhém je nutné pøenést v¹echny
pixely zdrojového obrázku do bufferu, a to mnohdy nìkolikrát (20&times;) za
sekundu. Tento pøenos se sice v&nbsp;ideálním pøípadì provádí pouze
v&nbsp;rámci obrazové pamìti (tudí¾ akcelerovanì), i tak se v¹ak
z&nbsp;hlediska celkového výkonu a  popø.&nbsp;i energetických po¾adavkù
(notebooky tablety atd.) nejedná o ideální zpùsob, jak implementovat double
buffering.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Nastavení celoobrazovkového grafického re¾imu a vytvoøení zadního bufferu</h2>

<p>Nastavení celoobrazovkového grafického re¾imu je pomìrnì snadné, proto¾e
mù¾eme vyu¾ít znalostí, o nich¾ jsme se v&nbsp;tomto seriálu ji¾ zmínili.
Následující metoda nejprve nastaví parametry vybraného okna/rámce tak, aby bylo
zobrazeno pøes celou obrazovku (bez okrajù) a následnì vybere a nastaví
grafický re¾im s&nbsp;po¾adovaným rozli¹ením
<strong>GRAPHICS_MODE_WIDTH</strong>&times;<strong>GRAPHICS_MODE_HEIGHT</strong>
a libovolnou bitovou (barvovou) hloubkou:</p>

<pre>
<i>    /**</i>
<i>     * Nastaveni grafickeho rezimu.</i>
<i>     */</i>
    private void <strong>setFullScreenMode</strong>(Frame frame) {
        GraphicsEnvironment env = GraphicsEnvironment.getLocalGraphicsEnvironment();
        GraphicsDevice graphicsDevice = env.getDefaultScreenDevice();
        graphicsDevice.setFullScreenWindow(frame);
        DisplayMode selectedDisplayMode = null;
<i>        // pokusime se vyhledat pozadovany graficky rezim.</i>
        for (DisplayMode displayMode : graphicsDevice.getDisplayModes()) {
            if (displayMode.getWidth() == GRAPHICS_MODE_WIDTH
                    &amp;&amp; displayMode.getHeight() == GRAPHICS_MODE_HEIGHT) {
                selectedDisplayMode = displayMode;
                break;
            }
        }
        graphicsDevice.setDisplayMode(selectedDisplayMode);
    }
</pre>

<p>Pøi pou¾ití celoobrazovkového re¾imu navíc není ani nutné vyu¾ívat objekt
typu <strong>java.awt.Canvas</strong>. Namísto toho je vykreslování mo¾né
provádìt pøímo na rámec. Vzhledem k&nbsp;tomu, ¾e se vùbec nepou¾ívá callback
metoda <strong>public void paint()</strong>, je vhodné pøed zobrazením rámce
zavolat metodu <strong>Frame.setIgnoreRepaint(true)</strong>. Vlastní
vykreslení obrazce je posléze &bdquo;vynuceno&ldquo; programovým prohozením
funkce pøedního a zadního bufferu:</p>

<pre>
<i>    /**</i>
<i>     * Prekresleni obsahu ramce.</i>
<i>     */</i>
    private void <strong>repaintFrame</strong>(Frame frame, double angle) {
<i>        // ziskat objekt typu Graphics2D pro zadni buffer</i>
        BufferStrategy bufferStrategy = frame.getBufferStrategy();
        final Graphics2D graphics2d = (Graphics2D) bufferStrategy.getDrawGraphics();
&nbsp;
        graphics2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
        final int width = frame.getWidth();
        final int height = frame.getHeight();
        final double radius = Math.min(width, height) / 3.0;
&nbsp;
<i>        // casove narocne vykresleni obrazce</i>
<i>        // (na rychlejsich pocitacich lze zmenit krok 0.005 na 0.001)</i>
        int xold = 0, yold = 0;
        for (double d = 0; d &lt; Math.PI * 2 * 7; d += 0.005) {
            int x = (int) (width / 2 + radius * Math.cos(d) + radius / 2 * Math.sin(d / 7 + angle));
            int y = (int) (height / 2 + radius * Math.sin(d) + radius / 2 * Math.cos(d / 7 + angle));
            graphics2d.setColor(Color.BLACK);
            if (d &gt; 0) {
                graphics2d.drawLine(xold, yold, x, y);
            }
            xold = x;
            yold = y;
        }
        graphics2d.dispose();
&nbsp;
<i>        // prohozeni bufferu a/nebo prekresleni zadniho bufferu do bufferu</i>
<i>        // predniho</i>
        bufferStrategy.show();
    }
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Tøetí demonstraèní pøíklad: double buffering v&nbsp;celoobrazovkovém grafickém re¾imu</h2>

<p>V&nbsp;dne¹ním tøetím a souèasnì i posledním demonstraèním pøíkladu jsou
vyu¾ity principy vysvìtlené v&nbsp;pøedchozích dvou kapitolách. Po spu¹tìní
aplikace je vytvoøeno okno (rámec), následnì jsou skryty okraje tohoto okna
(dekorace) a posléze je nastaven celoobrazovkový grafický re¾im a obsah okna je
zvìt¹en tak, aby obsáhl celou plochu obrazovky. Po tìchto operacích je pro toto
okno vytvoøen pøední a zadní buffer a poté se ve smyèce volá pøekreslovací
rutina, která postupnì (bez mazání pøedního èi zadního bufferu) postupnì
dokresluje obrazec do následující podoby:</p>

<img src="http://i.iinfo.cz/images/668/obr2.png" class="image-158437" width="512" height="384" alt="&#160;" />

<p>Poté je aplikace automaticky ukonèena. Úplný zdrojový kód tohoto pøíkladu je
vypsán pod tímto odstavcem:</p>

<pre>
import java.awt.Color;
import java.awt.DisplayMode;
import java.awt.Frame;
import java.awt.Graphics2D;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.RenderingHints;
import java.awt.image.BufferStrategy;
&nbsp;
<i>/**</i>
<i> * Test vykreslovani v celoobrazovkovem grafickem rezimu pri povoleni</i>
<i> * double bufferingu.</i>
<i> * </i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>DoubleBufferTest3</strong> {
&nbsp;
<i>    /**</i>
<i>     * Generated serial version UID.</i>
<i>     */</i>
    private static final long serialVersionUID = 6423061537074933572L;
&nbsp;
<i>    /**</i>
<i>     * Horizontalni rozliseni pozadovaneho grafickeho rezimu.</i>
<i>     */</i>
    private static final int <strong>GRAPHICS_MODE_WIDTH</strong> = 1024;
&nbsp;
<i>    /**</i>
<i>     * Vertikalni rozliseni pozadovaneho grafickeho rezimu.</i>
<i>     */</i>
    private static final int <strong>GRAPHICS_MODE_HEIGHT</strong> = 768;
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni okna a pridani kresby do tohoto okna.</i>
<i>     */</i>
    private void <strong>run</strong>() {
        Frame frame = createFrame();
<i>        // nastaveni celoobrazovkoveho rezimu</i>
        setFullScreenMode(frame);
<i>        // vytvoreni zadniho bufferu</i>
        frame.createBufferStrategy(2);
<i>        // prekresleni ramce - jednoducha animace</i>
        for (double angle = 0.0; angle &lt; 1; angle += 0.1) {
            repaintFrame(frame, angle);
        }
<i>        // ukonceni aplikace</i>
        exitFromFullScreenMode();
        System.exit(0);
    }
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni ramce a nastaveni jeho vlastnosti. </i>
<i>     * @return</i>
<i>     */</i>
    private Frame <strong>createFrame</strong>() {
        Frame frame = null;
        GraphicsEnvironment env = GraphicsEnvironment.getLocalGraphicsEnvironment();
        GraphicsDevice graphicsDevice = env.getDefaultScreenDevice();
        GraphicsConfiguration graphicsConfiguration = graphicsDevice.getDefaultConfiguration();
<i>        // vytvoreni ramce</i>
        frame = new Frame(graphicsConfiguration);
<i>        // pozadi ramce</i>
        frame.setBackground(Color.WHITE);
<i>        // bez aktivnich okraju okna</i>
        frame.setUndecorated(true);
<i>        // nechceme, aby system sam okno prekreslil</i>
        frame.setIgnoreRepaint(true);
        return frame;
    }
&nbsp;
<i>    /**</i>
<i>     * Nastaveni grafickeho rezimu.</i>
<i>     */</i>
    private void <strong>setFullScreenMode</strong>(Frame frame) {
        GraphicsEnvironment env = GraphicsEnvironment.getLocalGraphicsEnvironment();
        GraphicsDevice graphicsDevice = env.getDefaultScreenDevice();
        graphicsDevice.setFullScreenWindow(frame);
        DisplayMode selectedDisplayMode = null;
<i>        // pokusime se vyhledat pozadovany graficky rezim.</i>
        for (DisplayMode displayMode : graphicsDevice.getDisplayModes()) {
            if (displayMode.getWidth() == GRAPHICS_MODE_WIDTH
                    &amp;&amp; displayMode.getHeight() == GRAPHICS_MODE_HEIGHT) {
                selectedDisplayMode = displayMode;
                break;
            }
        }
        graphicsDevice.setDisplayMode(selectedDisplayMode);
    }
&nbsp;
<i>    /**</i>
<i>     * Ukonceni grafickeho rezimu.</i>
<i>     */</i>
    private void <strong>exitFromFullScreenMode</strong>() {
        GraphicsEnvironment env = GraphicsEnvironment.getLocalGraphicsEnvironment();
        GraphicsDevice graphicsDevice = env.getDefaultScreenDevice();
        graphicsDevice.setFullScreenWindow(null);
    }
&nbsp;
<i>    /**</i>
<i>     * Prekresleni obsahu ramce.</i>
<i>     */</i>
    private void <strong>repaintFrame</strong>(Frame frame, double angle) {
<i>        // ziskat objekt typu Graphics2D pro zadni buffer</i>
        BufferStrategy bufferStrategy = frame.getBufferStrategy();
        final Graphics2D graphics2d = (Graphics2D) bufferStrategy.getDrawGraphics();
&nbsp;
        graphics2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
        final int width = frame.getWidth();
        final int height = frame.getHeight();
        final double radius = Math.min(width, height) / 3.0;
&nbsp;
<i>        // casove narocne vykresleni obrazce</i>
<i>        // (na rychlejsich pocitacich lze zmenit krok 0.005 na 0.001)</i>
        int xold = 0, yold = 0;
        for (double d = 0; d &lt; Math.PI * 2 * 7; d += 0.005) {
            int x = (int) (width / 2 + radius * Math.cos(d) + radius / 2 * Math.sin(d / 7 + angle));
            int y = (int) (height / 2 + radius * Math.sin(d) + radius / 2 * Math.cos(d / 7 + angle));
            graphics2d.setColor(Color.BLACK);
            if (d &gt; 0) {
                graphics2d.drawLine(xold, yold, x, y);
            }
            xold = x;
            yold = y;
        }
        graphics2d.dispose();
&nbsp;
<i>        // prohozeni bufferu a/nebo prekresleni zadniho bufferu do bufferu</i>
<i>        // predniho</i>
        bufferStrategy.show();
    }
&nbsp;
<i>    /**</i>
<i>     * Spusteni testu.</i>
<i>     */</i>
    public static void <strong>main</strong>(String[] args) {
        new DoubleBufferTest3().run();
    }
&nbsp;
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Repositáø se zdrojovými kódy dne¹ních demonstraèních pøíkladù</h2>

<p>Následují v&nbsp;tomto seriálu ji¾ tradièní odkazy na zdrojové kódy ulo¾ené
do Mercurial repositáøe. V&nbsp;tabulce zobrazené pod tímto odstavcem najdete
linky na prozatím nejnovìj¹í verze v¹ech tøí dnes popsaných demonstraèních
pøíkladù:</p>

<table>
<tr><th>#</th><th>Zdrojový soubor/skript</th><th>Umístìní souboru v&nbsp;repositáøi</th></tr>
<tr><td>1</td><td>DoubleBufferTest1.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/8754588b4129/jvm/gfx/DoubleBufferTest1.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/8754588b4129/jvm/gfx/DoubleBufferTest1.java</a></td></tr>
<tr><td>2</td><td>DoubleBufferTest2.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/8754588b4129/jvm/gfx/DoubleBufferTest2.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/8754588b4129/jvm/gfx/DoubleBufferTest2.java</a></td></tr>
<tr><td>3</td><td>DoubleBufferTest3.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/bec273a159be/jvm/gfx/DoubleBufferTest3.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/bec273a159be/jvm/gfx/DoubleBufferTest3.java</a></td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Class java.awt.Frame (JDK7)<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/Frame.html">http://docs.oracle.com/javase/7/docs/api/java/awt/Frame.html</a>
</li>

<li>Class java.awt.Canvas (JDK7)<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/Canvas.html">http://docs.oracle.com/javase/7/docs/api/java/awt/Canvas.html</a>
</li>

<li>Class java.awt.image.BufferStrategy (JDK6)<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferStrategy.html</a>
</li>

<li>Class java.awt.Graphics<br />
<a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/Graphics.html">http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/Graphics.html</a>
</li>

<li>Double Buffering and Page Flipping<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html</a>
</li>

<li>BufferStrategy and BufferCapabilities<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/bufferstrategy.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/bufferstrategy.html</a>
</li>

<li>Java:Tutorials: Double Buffering<br />
<a href="http://content.gpwiki.org/index.php/Java:Tutorials:Double_Buffering">http://content.gpwiki.org/index.php/Java:Tutorials:Double_Buffering</a>
</li>

<li>Double buffer in standard Java AWT<br />
<a href="http://www.codeproject.com/Articles/2136/Double-buffer-in-standard-Java-AWT">http://www.codeproject.com/Articles/2136/Double-buffer-in-standard-Java-AWT</a>
</li>

<li>Java 2D: Hardware Accelerating - Part 1 - Volatile Images<br />
<a href="http://www.javalobby.org/forums/thread.jspa?threadID=16840&tstart=0">http://www.javalobby.org/forums/thread.jspa?threadID=16840&tstart=0</a>
</li>

<li>Java 2D: Hardware Accelerating - Part 2 - Buffer Strategies<br />
<a href="http://www.javalobby.org/java/forums/t16867.html">http://www.javalobby.org/java/forums/t16867.html</a>
</li>

<li>How does paintComponent work?<br />
<a href="http://stackoverflow.com/questions/15544549/how-does-paintcomponent-work">http://stackoverflow.com/questions/15544549/how-does-paintcomponent-work</a>
</li>

<li>A Swing Architecture Overview<br />
<a href="http://www.oracle.com/technetwork/java/architecture-142923.html">http://www.oracle.com/technetwork/java/architecture-142923.html</a>
</li>

<li>Class javax.swing.JComponent<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html</a>
</li>

<li>Class java.awt.Component<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html</a>
</li>

<li>Class java.awt.Component.BltBufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.BltBufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.BltBufferStrategy.html</a>
</li>

<li>Class java.awt.Component.FlipBufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.FlipBufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.FlipBufferStrategy.html</a>
</li>

<li>Metoda java.awt.Component.isDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html#isDoubleBuffered()">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html#isDoubleBuffered()</a>
</li>

<li>Metoda javax.swing.JComponent.isDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#isDoubleBuffered()">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#isDoubleBuffered()</a>
</li>

<li>Metoda javax.swing.JComponent.setDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#setDoubleBuffered(boolean)">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#setDoubleBuffered(boolean)</a>
</li>

<li>Javadoc - tøída GraphicsDevice<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html</a>
</li>

<li>Javadoc - tøída GraphicsEnvironment<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html</a>
</li>

<li>Javadoc - tøída GraphicsConfiguration<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html</a>
</li>

<li>Javadoc - tøída DisplayMode<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html">http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html</a>
</li>

<li>Lesson: Full-Screen Exclusive Mode API<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/">http://docs.oracle.com/javase/tutorial/extra/fullscreen/</a>
</li>

<li>Full-Screen Exclusive Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html</a>
</li>

<li>Display Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html</a>
</li>

<li>Using the Full-Screen Exclusive Mode API in Java<br />
<a href="http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm">http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>GC safe-point (or safepoint) and safe-region<br />
<a href="http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html">http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html</a>
</li>

<li>Safepoints in HotSpot JVM<br />
<a href="http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html">http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html</a>
</li>

<li>Java theory and practice: Synchronization optimizations in Mustang<br />
<a href="http://www.ibm.com/developerworks/java/library/j-jtp10185/">http://www.ibm.com/developerworks/java/library/j-jtp10185/</a>
</li>

<li>How to build hsdis<br />
<a href="http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README">http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README</a>
</li>

<li>Java SE 6 Performance White Paper<br />
<a href="http://www.oracle.com/technetwork/java/6-performance-137236.html">http://www.oracle.com/technetwork/java/6-performance-137236.html</a>
</li>

<li>Lukas Stadler's Blog<br />
<a href="http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html">http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html</a>
</li>

<li>How to build hsdis-amd64.dll and hsdis-i386.dll on Windows<br />
<a href="http://dropzone.nfshost.com/hsdis.htm">http://dropzone.nfshost.com/hsdis.htm</a>
</li>

<li>PrintAssembly<br />
<a href="https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly">https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly</a>
</li>

<li>The Java Virtual Machine Specification: 3.14. Synchronization<br />
<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14</a>
</li>

<li>The Java Virtual Machine Specification: 8.3.1.4. volatile Fields<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.4. Memory Model<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.7. Non-atomic Treatment of double and long<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7</a>
</li>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (pøed verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2014</small></p>
</body>
</html>

