<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM (8.èást - instrukce urèené pro øízení bìhu programu)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>


<body>

<h1>Pohled pod kapotu JVM (8.èást - instrukce urèené pro øízení bìhu programu)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o vlastnostech JVM se ji¾ potøetí vrátíme k instrukènímu souboru zpracovávanému virtuálním strojem Javy. Popí¹eme si instrukce slou¾ící k øízení bìhu programu. Jedná se o instrukce pro ukonèení metody s pøedáním návratové hodnoty, nepodmínìné a podmínìné skoky a takté¾ o instrukce implementující rozvìtvení zapsané v Javì konstrukcí switch.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Instrukce slou¾ící pro ukonèení metody s&nbsp;pøedáním návratové hodnoty této metody</a></p>
<p><a href="#k02">2. První demonstraèní pøíklad &ndash; návrat z&nbsp;metody s&nbsp;pøedáním návratové hodnoty</a></p>
<p><a href="#k03">3. Instrukce nepodmínìného skoku + druhý demonstraèní pøíklad</a></p>
<p><a href="#k04">4. Test hodnoty jednoho operandu s&nbsp;podmínìným skokem v&nbsp;pøípadì splnìní podmínky</a></p>
<p><a href="#k05">5. Tøetí demonstraèní pøíklad &ndash; pou¾ití podmínìného skoku testujícího jeden operand</a></p>
<p><a href="#k06">6. Podmínìné skoky øízené hodnotou reference + ètvrtý demonstraèní pøíklad</a></p>
<p><a href="#k07">7. Porovnání dvou operandù s&nbsp;podmínìným skokem</a></p>
<p><a href="#k08">8. Pátý demonstraèní pøíklad &ndash; porovnání dvou operandù s&nbsp;podmínìným skokem</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Instrukce slou¾ící pro ukonèení metody s&nbsp;pøedáním návratové hodnoty této metody</h2>

<p>V&nbsp;dne¹ní èásti seriálu o programovacím jazyce Java i o virtuálním
stroji tohoto jazyka si popí¹eme dal¹í skupinu instrukcí pou¾ívaných
v&nbsp;bajtkódu. Zatímco minule a pøedminule jsme se zabývali pøedev¹ím
instrukcemi slou¾ícími pro pøesuny hodnot a takté¾ instrukcemi pro provádìní
aritmetických a bitových operací, dnes se zamìøíme na instrukce slou¾ící pro
øízení bìhu programu. Jedná se pøedev¹ím o instrukce, pomocí nich¾ se ukonèuje
aktivní metoda spoleènì se zaji¹tìním návratové hodnoty, která je pøedána
volající metodì. Dal¹í mno¾inou øídicích instrukcí jsou nepodmínìné a podmínìné
skoky, které jsou navíc doplnìny i dvojicí pomìrnì komplexních instrukcí
nazvaných <strong>tableswitch</strong> a <strong>lookupswitch</strong>. Tato
dvojice instrukcí se pou¾ívá pro implementaci rozvìtvení, jen¾ je
v&nbsp;programovacím jazyku Java zapisováno pomocí konstrukce
<strong>switch</strong> (v&nbsp;Javì 7 je v¹ak situace ponìkud slo¾itìj¹í,
proto¾e je v&nbsp;ní umo¾nìn i rozeskok na základì porovnávání øetìzce
s&nbsp;øetìzcovými literály &ndash; konstantami).</p>

<p>Popi¹me si nejdøíve instrukce, které slou¾í pro ukonèení metody
s&nbsp;pøípadným pøedáním návratové hodnoty volající metodì (<i>caller</i>). Po
provedení tìchto instrukcí dojde ke zru¹ení celého zásobníkového rámce metody,
z&nbsp;ní¾ se vyskakuje, a øízení se pøedá volající metodì. Pøipomeòme si, ¾e
volající metoda si mù¾e návratovou hodnotu vyzvednout z&nbsp;vrcholu
<strong>svého</strong> zásobníku operandù. Pou¾ití dále vypsaných instrukcí
typu <strong>*return</strong> je jedinou mo¾ností, jak mù¾e volaná metoda
modifikovat obsah zásobníku operandù metody volající &ndash; v&nbsp;ostatních
pøípadech jsou toti¾ zásobníky operandù (i datová oblast) obou metod od sebe
izolovány, co¾ pøispívá jak k&nbsp;vìt¹í bezpeènosti, tak i k&nbsp;oddìlení
jednotlivých èástí kódu. To samozøejmì zjednodu¹uje práci just-in-time
pøekladaèe pøi provádìní optimalizací. Ukonèení metody s&nbsp;ulo¾ením
návratové hodnoty zabezpeèuje ¹estice instrukcí <strong>*return</strong>, která
je vypsaná v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Datový typ na TOS</th><th>Operace</th></tr>
<tr><td>1</td><td>ireturn</td><td>0xAC</td><td>int</td><td>získání návratové hodnoty typu int z&nbsp;TOS zásobníku operandù + návrat z&nbsp;metody</td></tr>
<tr><td>2</td><td>lreturn</td><td>0xAD</td><td>long</td><td>získání návratové hodnoty typu long z&nbsp;TOS zásobníku operandù + návrat z&nbsp;metody</td></tr>
<tr><td>3</td><td>freturn</td><td>0xAE</td><td>float</td><td>získání návratové hodnoty typu float z&nbsp;TOS zásobníku operandù + návrat z&nbsp;metody</td></tr>
<tr><td>4</td><td>dreturn</td><td>0xAF</td><td>double</td><td>získání návratové hodnoty typu double z&nbsp;TOS zásobníku operandù + návrat z&nbsp;metody</td></tr>
<tr><td>5</td><td>areturn</td><td>0xB0</td><td>reference</td><td>získání návratové hodnoty typu reference na objekt z&nbsp;TOS zásobníku operandù + návrat z&nbsp;metody</td></tr>
<tr><td>6</td><td>return</td><td>0xB1</td><td>&times;</td><td>pouze návrat z&nbsp;metody, ¾ádná hodnota se nevrací</td></tr>
</table>

<p>Virtuální stroj jazyka Java samozøejmì kontroluje, zda se na zásobníku
operandù nachází operand daného typu. Tyto kontroly jsou provádìny i u dal¹ích
instrukcí, jimi¾ se budeme zabývat v&nbsp;následujících kapitolách.
V&nbsp;pøípadì, ¾e je bajtkód poru¹en, není vùbec dovoleno ho spustit.
Podívejte se ostatnì sami, co se stane, kdy¾ se v&nbsp;hexa editoru zamìní kód
instrukce <strong>ireturn</strong> (0xAC) za <strong>freturn</strong>
(0xAE):</p>

<pre>
$ java Test1
Exception in thread "main" java.lang.VerifyError: (class: Test1, method: x signature: ()I) Expecting to find float on stack
</pre>

<p>Verifikátor bajtkódu v&nbsp;tomto pøípadì velmi rychle zjistil, ¾e signatura
metody ulo¾ená v&nbsp;<i>constant poolu</i> neodpovídá obsahu bajtkódu.
V&nbsp;signatuøe je toti¾ uvedeno <strong>()I</strong>, tj.&nbsp;má se jednat o
metodu bez parametrù vracející hodnotu typu <i>int</i>, ale v&nbsp;bajtkódu je
nalezen operaèní kód instrukce <strong>freturn</strong> (metoda tedy ve
skuteènosti vrací hodnotu typu <i>float</i>).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. První demonstraèní pøíklad &ndash; návrat z&nbsp;metody s&nbsp;pøedáním návratové hodnoty</h2>

<p>Podobnì jako tomu bylo i v&nbsp;pøedchozích èástech tohoto seriálu, i dnes
si uká¾eme zpùsob pou¾ití vìt¹iny popsaných instrukcí na jednoduchých
pøíkladech. První demonstraèní pøíklad obsahuje nìkolik statických metod, které
vrací hodnoty rùzných typù s&nbsp;vyu¾itím konstrukce <strong>return
xxx;</strong>, popø.&nbsp;pouze <strong>return;</strong>. Samozøejmì platí, ¾e
metoda mù¾e být v&nbsp;nìkterých pøípadech ukonèena i bez explicitního uvedení
konstrukce <strong>return</strong>, pøelo¾ena v¹ak bude stejným zpùsobem,
jakoby se <strong>return</strong> pou¾il:</p>

<pre>
class Test1 {
    static void returnVoid() {
        return;
    }
&nbsp;
    static byte returnByte() {
        return -1;
    }
&nbsp;
    static char returnChar() {
        return 'a';
    }
&nbsp;
    static short returnShort() {
        return 0;
    }
&nbsp;
    static int returnInt() {
        return 1;
    }
&nbsp;
    static long returnLong() {
        return 2L;
    }
&nbsp;
    static float returnFloat() {
        return 3.0f;
    }
&nbsp;
    static double returnDouble() {
        return 4.0;
    }
&nbsp;
    static Object returnReference() {
        return null;
    }
&nbsp;
}
</pre>

<p>Jednotlivé metody deklarované v&nbsp;demonstraèním pøíkladu se pøelo¾í
zpùsobem uvedeným v&nbsp;následujících odstavcích:</p>

<p>Metoda s&nbsp;návratovou hodnotou typu <i>void</i> pou¾ívá instrukci
<strong>return</strong>:</p>

<pre>
static void returnVoid();
  Code:
   0:   return       // prosté ukonèení metody bez pøedání návratové hodnoty
</pre>

<p>Metoda s&nbsp;návratovou hodnotou typu <i>byte</i> ve skuteènosti pracuje
s&nbsp;návratovou hodnotou typu <i>int</i> (opìt zde mù¾eme vidìt, ¾e
<i>byte</i> není v&nbsp;kontextu bajtkódu zcela plnohodnotným datovým
typem):</p>

<pre>
static byte returnByte();
  Code:
   0:   iconst_m1    // instrukce s operandem (konstantou) ulo¾enou pøímo v bajtkódu
   1:   ireturn      // ukonèení metody s pøedáním návratové hodnoty typu int
</pre>

<p>Toté¾ platí pro metodu vracející hodnotu typu <i>char</i> (ve skuteènosti je
pou¾it typ <i>int</i>):</p>

<pre>
static char returnChar();
  Code:
   0:   bipush  97   // ulo¾ení ASCII kódu znaku 'a' na zásobník operandù
   2:   ireturn      // ukonèení metody s pøedáním návratové hodnoty typu int
</pre>

<p>A samozøejmì i pro metodu vracející hodnotu typu <i>short</i> (ve
skuteènosti je opìt pou¾it typ <i>int</i>):</p>

<pre>
static short returnShort();
  Code:
   0:   iconst_0     // instrukce s operandem (konstantou) ulo¾enou pøímo v bajtkódu
   1:   ireturn      // ukonèení metody s pøedáním návratové hodnoty typu int
</pre>

<p>Návrat hodnoty typu <i>int</i> se ji¾ obejde bez vìt¹ích pøekvapení:</p>

<pre>
static int returnInt();
  Code:
   0:   iconst_1     // instrukce s operandem ulo¾eným pøímo v bajtkódu
   1:   ireturn      // ukonèení metody s pøedáním návratové hodnoty typu int
</pre>

<p>Návrat hodnoty typu <i>long</i>:</p>

<pre>
static long returnLong();
  Code:
   0:   ldc2_w  #2;  // long 2l - konstanta ulo¾ená v constant poolu
   3:   lreturn      // ukonèení metody s pøedáním návratové hodnoty typu long
</pre>

<p>Instrukce <strong>freturn</strong> je vyu¾ita v&nbsp;pøípadì návratové
hodnoty typu <i>float</i>:</p>

<pre>
static float returnFloat();
  Code:
   0:   ldc     #4;  // float 3.0f - konstanta ulo¾ená v constant poolu
   2:   freturn      // ukonèení metody s pøedáním návratové hodnoty typu float
</pre>

<p>Instrukce <strong>dreturn</strong> je vyu¾ita v&nbsp;pøípadì návratové
hodnoty typu <i>double</i>:</p>

<pre>
static double returnDouble();
  Code:
   0:   ldc2_w  #5;  // double 4.0d - konstanta ulo¾ená v constant poolu
   3:   dreturn      // ukonèení metody s pøedáním návratové hodnoty typu double
</pre>

<p>Pro vrácení reference, neboli libovolného objektu, se pou¾ívá instrukce
<strong>areturn</strong>:</p>

<pre>
static java.lang.Object returnReference();
  Code:
   0:   aconst_null  // instrukce s operandem ulo¾eným pøímo v bajtkódu
   1:   areturn      // ukonèení metody s pøedáním návratové hodnoty typu reference
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Instrukce nepodmínìného skoku + druhý demonstraèní pøíklad</h2>

<p>V&nbsp;této kapitole se budeme zabývat pouze jedinou instrukcí. Jedná se o
instrukci nepodmínìného skoku, její¾ jméno je <strong>goto</strong>. Podobnì
jako podmínìné skoky popsané v&nbsp;následujících kapitolách, má i instrukce
<strong>goto</strong> nìkolik podstatných omezení &ndash; skok lze toti¾
provést pouze v&nbsp;rámci tìla jedné metody, není tedy mo¾né skoèit na
libovolné místo v&nbsp;bajtkódu. Toto omezení bylo zavedeno ze dvou dùvodù
&ndash; zaji¹»uje se tím vìt¹í bezpeènost a takté¾ se tím zjednodu¹uje práce
JIT pøekladaèe, který pøi optimalizacích generovaného nativního binárního kódu
mù¾e pracovat s&nbsp;izolovaným stavovým prostorem (má toti¾ jistotu, ¾e kdy¾
danou metodu celou pøelo¾í, není nutné vyhledávat, z&nbsp;jakých dal¹ích metod
jsou do právì pøelo¾ené metody provádìny skoky &ndash; jednodu¹e to není
mo¾né). Instrukce <strong>goto</strong> existuje ve dvou variantách &ndash;
&bdquo;krátké&ldquo; a &bdquo;dlouhé&ldquo;. Tyto varianty se od sebe odli¹ují
pouze poètem bajtù, které se v&nbsp;bajtkódu pou¾ijí pro ulo¾ení adresy cíle
skoku. Buï je mo¾né pou¾ít 16bitovou adresu (vyhovuje prakticky v¹em rozumnì
dlouhým metodám) nebo adresu 32bitovou (to se obecnì pøíli¹ èasto nepou¾ívá,
proto¾e existují dal¹í omezení na maximální poèet 65536 instrukcí v&nbsp;jedné
metodì):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Popis</th></tr>
<tr><td>1</td><td>goto</td><td>0xA7</td><td>highbyte, lowbyte</td><td>pøímý skok na adresu ulo¾enou v&nbsp;dvojici operandù: highbyte*256+lowbyte</td></tr>
<tr><td>2</td><td>goto_w</td><td>0xC8</td><td>byte1,byte2,byte3 byte4</td><td>pøímý skok na adresu ulo¾enou ve ètveøici operandù: byte1*2<sup>24</sup>+byte2*2<sup>16</sup>+byte3*2<sup>8</sup>+byte4</td></tr>
</table>

<p>Podívejme se na velmi jednoduchý demonstraèní pøíklad s&nbsp;trojicí
statických metod, v&nbsp;nich¾ je pou¾ita nekoneèná smyèka:</p>

<pre>
class Test2 {
&nbsp;
    static void loop1() {
        while (true) {
        }
    }
&nbsp;
    static void loop2(int x) {
        while (true) {
            x++;
        }
    }
&nbsp;
    static void loop3(float x) {
        do {
            x++;
        } while (true);
    }
&nbsp;
}
</pre>

<p>Ve v¹ech tøech pøípadech se nekoneèná smyèka pøelo¾í s&nbsp;vyu¾itím
instrukce <strong>goto</strong> (pov¹imnìte si, ¾e adresa skoku je skuteènì
lokální):</p>

<pre>
static void loop1();
  Code:
   0:   goto    0      // nekoneèná smyèka bez tìla - je pouze proveden skok na tu samou instrukci
</pre>

<pre>
static void loop2(int);
  Code:
   0:   iinc    0, 1   // tìlo nekoneèné smyèky
   3:   goto    0      // skok na zaèátek nekoneèné smyèky
</pre>

<pre>
static void loop3(float);
  Code:
   0:   fload_0        // zaèátek tìla nekoneèné smyèky
   1:   fconst_1
   2:   fadd
   3:   fstore_0
   4:   goto    0      // skok na zaèátek nekoneèné smyèky
</pre>

<p>Pøekladaè Javy v¹ak mù¾e v&nbsp;nìkterých pøípadech instrukci skoku
vynechat, a to tehdy, pokud statickou analýzou zjistí, ¾e se ve skuteènosti
smyèka nikdy neprovede (resp.&nbsp;se provede pouze jedna její iterace). Viz
té¾ následující demonstraèní pøíklad:</p>

<pre>
class Test3 {
    static void none(int x, int y, int z) {
        while(true) {              // vnìj¹í programová smyèka
            z++;
            while(true) {          // prostøední programová smyèka
                y++;
                while(true) {      // vnitøní programová smyèka
                   x++;
                }
            }
        }
    }
}
</pre>

<p>Pøi pøekladu tohoto zdrojového kódu se vygeneruje skok pouze pro
nejvnitønìj¹í smyèku:</p>

<pre>
static void none(int, int, int);
  Code:
   0:   iinc    2, 1     // tento pøíkaz zbyl z vnìj¹í smyèky: z++
   3:   iinc    1, 1     // tento pøíkaz zbyl z prostøední smyèky: y++
   6:   iinc    0, 1     // tìlo vnitøní smyèky: x++
   9:   goto    6        // implementace vnitøní smyèky
</pre>

<p>Instrukce <strong>goto</strong> je pou¾ita i v&nbsp;mnoha dal¹ích pøípadech.
S&nbsp;nìkterými z&nbsp;nich se setkáme v&nbsp;navazujících kapitolách.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Test hodnoty jednoho operandu s&nbsp;podmínìným skokem v&nbsp;pøípadì splnìní podmínky</h2>

<p>Nyní se ji¾ koneènì dostáváme k&nbsp;zajímavìj¹ímu tématu &ndash;
k&nbsp;podmínìným skokùm. V&nbsp;instrukèním kódu virtuálního stroje jazyka
Java je k&nbsp;dispozici pomìrnì velké mno¾ství typù rùzných podmínìných skokù.
V&nbsp;této kapitole si popí¹eme skoky, které se provedou resp.&nbsp;neprovedou
na základì testu hodnoty jediného operandu, který je ulo¾en na vrcholu
zásobníku operandù (<i>TOS</i>). Ve v¹ech pøípadech se pøitom musí jednat o
operand typu <i>int</i>, který je po provedení testu ze zásobníku operandù
odstranìn (samozøejmì nezávisle na tom, jak test ve skuteènosti dopadl).
Instrukce podmínìného skoku nejdøíve na základì operaèního kódu instrukce
zjistí, zda je operand nulový, nenulový, vìt¹í ne¾ nula, men¹í ne¾ nula, vìt¹í
nebo roven nule popø.&nbsp;naopak men¹í nebo roven nule. Pokud je daná podmínka
splnìna, je proveden skok na ¹estnáctibitovou lokální adresu ulo¾enou za
operaèním kódem instrukce; v&nbsp;opaèném pøípadì se pokraèuje v&nbsp;provádìní
instrukce ulo¾ené ihned za podmínìným skokem. V¹ech ¹est variant podmínìných
skokù pracujících s&nbsp;jediným operandem typu <i>int</i> je vypsáno
v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Podmínka</th><th>Operace</th></tr>
<tr><td>1</td><td>ifeq</td><td>0x99</td><td>highbyte, lowbyte</td><td>TOS=0</td><td>skok na lokální adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>2</td><td>ifne</td><td>0x9A</td><td>highbyte, lowbyte</td><td>TOS&ne;0</td><td>skok na lokální adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>3</td><td>iflt</td><td>0x9B</td><td>highbyte, lowbyte</td><td>TOS&lt;0</td><td>skok na lokální adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>4</td><td>ifge</td><td>0x9C</td><td>highbyte, lowbyte</td><td>TOS&ge;0</td><td>skok na lokální adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>5</td><td>ifgt</td><td>0x9D</td><td>highbyte, lowbyte</td><td>TOS&gt;0</td><td>skok na lokální adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>6</td><td>ifle</td><td>0x9E</td><td>highbyte, lowbyte</td><td>TOS&le;0</td><td>skok na lokální adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
</table>

<p>Mo¾ná vás nyní napadá otázka, jaké instrukce se pou¾ijí v&nbsp;pøípadì
potøeby testu hodnoty promìnných typu <i>long</i>, <i>float</i> nebo
<i>double</i>. V&nbsp;tomto pøípadì nezbývá nic jiného ne¾ vyu¾ít instrukce,
které porovnají dvì hodnoty daného typu (typicky se jedná o promìnnou a
konstantu) a ulo¾í na <i>TOS</i> hodnotu 0, 1 nebo -1 na základì výsledku
tohoto porovnání. Tyto instrukce ji¾ známe, proto¾e byly uvedeny
v&nbsp;závìreèné kapitole pøedchozí èásti tohoto seriál. Jedná se o následující
pìtici instrukcí:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operand 1</th><th>Operand 2</th><th>Výsledek</th><th>Poznámka</th></tr>
<tr><td>1</td><td>lcmp </td><td>0x94</td><td>long  </td><td>long  </td><td>1 kdy¾ operand 1 &gt; operand 2<br />0 kdy¾ operand 1 == operand 2<br />-1 kdy¾ operand 1 &lt; operand 2</td></tr>
<tr><td>2</td><td>fcmpl</td><td>0x95</td><td>float </td><td>float </td><td>1 kdy¾ operand 1 &gt; operand 2<br />0 kdy¾ operand 1 == operand 2<br />-1 kdy¾ operand 1 &lt; operand 2<br />-1 kdy¾ operand 1 je NaN<br />-1 kdy¾ operand 2 je NaN</td></tr>
<tr><td>3</td><td>fcmpg</td><td>0x96</td><td>float </td><td>float </td><td>1 kdy¾ operand 1 &gt; operand 2<br />0 kdy¾ operand 1 == operand 2<br />-1 kdy¾ operand 1 &lt; operand 2<br />1 kdy¾ operand 1 je NaN<br />1 kdy¾ operand 2 je NaN</td></tr>
<tr><td>4</td><td>dcmpl</td><td>0x97</td><td>double</td><td>double</td><td>1 kdy¾ operand 1 &gt; operand 2<br />0 kdy¾ operand 1 == operand 2<br />-1 kdy¾ operand 1 &lt; operand 2<br />-1 kdy¾ operand 1 je NaN<br />-1 kdy¾ operand 2 je NaN</td></tr>
<tr><td>5</td><td>dcmpg</td><td>0x98</td><td>double</td><td>double</td><td>1 kdy¾ operand 1 &gt; operand 2<br />0 kdy¾ operand 1 == operand 2<br />-1 kdy¾ operand 1 &lt; operand 2<br />1 kdy¾ operand 1 je NaN<br />1 kdy¾ operand 2 je NaN</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. Tøetí demonstraèní pøíklad &ndash; pou¾ití podmínìného skoku testujícího jeden operand</h2>

<p>V&nbsp;následujícím demonstraèním pøíkladu bude ukázáno jak pou¾ití v¹ech
¹esti typù podmínìných skokù, tak i vyu¾ití skoku nepodmínìného
(<strong>goto</strong>), který je pou¾it mj.&nbsp;i pøi implementaci jazykové
konstrukce <strong>if-then-else</strong>:</p>

<pre>
class Test4 {
&nbsp;
    static String iftest(int x) {
        if (x==0) {
            return "zero";
        }
        if (x&gt;0) {
            return "positive";
        }
        if (x&lt;0) {
            return "negative";
        }
        if (x&gt;=0) {
            return "positive or zero";
        }
        if (x&lt;=0) {
            return "negative or zero";
        }
        return null;
    }
&nbsp;
    static void ifelse1(int x, int y) {
        if (x==0) {
            y++;
        }
        else {
            y--;
        }
    }
&nbsp;
    static void ifelse2(int x, int y) {
        if (x&gt;=0) {
            y++;
        }
        else {
            y--;
        }
    }
&nbsp;
}
</pre>

<p>Metoda <strong>iftest()</strong> je pøelo¾ena pøímoèaøe jako sekvence
podmínìných skokù. V¹imnìte si, ¾e podmínìné skoky pou¾ívají podmínky, které
jsou pøesnì opaèné, ne¾ podmínky zapsané ve zdrojovém textu, co¾ je logické,
proto¾e skoky jsou zde pou¾ity pro pøeskoèení bloku <strong>if</strong>, nikoli
pro jeho provedení:</p>

<pre>
static java.lang.String iftest(int);
  Code:
   0:   iload_0
   1:   ifne    7      // opaèná podmínka ne¾ je podmínka zapsaná ve zdrojovém kódu
   4:   ldc #2;        // String "zero"
   6:   areturn        // ukonèení metody s návratovou hodnotou typu String
&nbsp;
   7:   iload_0
   8:   ifle    14     // opaèná podmínka ne¾ je podmínka zapsaná ve zdrojovém kódu
   11:  ldc #3;        // String "positive"
   13:  areturn        // ukonèení metody s návratovou hodnotou typu String
&nbsp;
   14:  iload_0
   15:  ifge    21     // opaèná podmínka ne¾ je podmínka zapsaná ve zdrojovém kódu
   18:  ldc #4;        // String "negative"
   20:  areturn        // ukonèení metody s návratovou hodnotou typu String
&nbsp;
   21:  iload_0
   22:  iflt    28     // opaèná podmínka ne¾ je podmínka zapsaná ve zdrojovém kódu
   25:  ldc #5;        // String "positive or zero"
   27:  areturn        // ukonèení metody s návratovou hodnotou typu String
&nbsp;
   28:  iload_0
   29:  ifgt    35     // opaèná podmínka ne¾ je podmínka zapsaná ve zdrojovém kódu
   32:  ldc #6;        // String "negative or zero"
   34:  areturn        // ukonèení metody s návratovou hodnotou typu String
&nbsp;
   35:  aconst_null
   36:  areturn        // ukonèení metody s návratovou hodnotou null
</pre>

<p>U obou zbývajících metod je pou¾it jak podmínìný skok, tak i skok
nepodmínìný pro pøeskoèení vìtve <strong>else</strong>:</p>

<pre>
static void ifelse1(int, int);
  Code:
   0:   iload_0
   1:   ifne    10         // opaèná podmínka ne¾ je podmínka zapsaná ve zdrojovém textu
   4:   iinc    1, 1       // vìtev "if"
   7:   goto    13         // konec vìtve "if" s pøeskoèením vìtve "else"
   10:  iinc    1, -1      // vìtev "else"
   13:  return
</pre>

<pre>
static void ifelse2(int, int);
  Code:
   0:   iload_0
   1:   iflt    10         // opaèná podmínka ne¾ je podmínka zapsaná ve zdrojovém textu
   4:   iinc    1, 1       // vìtev "if"
   7:   goto    13         // konec vìtve "if" s pøeskoèením vìtve "else"
   10:  iinc    1, -1      // vìtev "else"
   13:  return
</pre>

<p>Pro zajímavost se je¹tì podívejme, jak se zmìní bajtkód metody
<strong>iftest</strong> v&nbsp;pøípadì, ¾e se namísto promìnné typu <i>int</i>
pou¾ije promìnná typu <i>float</i>:</p>

<pre>
    static String iftest(float x) {
        if (x==0) {
            return "zero";
        }
        if (x&gt;0) {
            return "positive";
        }
        if (x&lt;0) {
            return "negative";
        }
        if (x&gt;=0) {
            return "positive or zero";
        }
        if (x&lt;=0) {
            return "negative or zero";
        }
        return null;
    }
</pre>

<p>Zde se ji¾ musí vygenerovat instrukce typu <strong>fcmp*</strong>,
z&nbsp;èeho¾ vyplývá i slo¾itìj¹í a samozøejmì té¾ del¹í bajtkód:</p>

<pre>
static java.lang.String iftest(float);
  Code:
   0:   fload_0
   1:   fconst_0       // porovnání bude provedeno s konstantou 0.0f
   2:   fcmpl
   3:   ifne    9
   6:   ldc     #2;    // String "zero"
   8:   areturn        // ukonèení metody s návratovou hodnotou String
&nbsp;
   9:   fload_0
   10:  fconst_0       // porovnání bude provedeno s konstantou 0.0f
   11:  fcmpl
   12:  ifle    18
   15:  ldc     #3;    // String "positive"
   17:  areturn        // ukonèení metody s návratovou hodnotou String
&nbsp;
   18:  fload_0
   19:  fconst_0       // porovnání bude provedeno s konstantou 0.0f
   20:  fcmpg
   21:  ifge    27
   24:  ldc     #4;    // String "negative"
   26:  areturn        // ukonèení metody s návratovou hodnotou String
&nbsp;
   27:  fload_0
   28:  fconst_0       // porovnání bude provedeno s konstantou 0.0f
   29:  fcmpl
   30:  iflt    36
   33:  ldc     #5;    // String "positive or zero"
   35:  areturn        // ukonèení metody s návratovou hodnotou String
&nbsp;
   36:  fload_0
   37:  fconst_0       // porovnání bude provedeno s konstantou 0.0f
   38:  fcmpg
   39:  ifgt    45
   42:  ldc     #6;    // String "negative or zero"
   44:  areturn        // ukonèení metody s návratovou hodnotou String
&nbsp;
   45:  aconst_null
   46:  areturn        // ukonèení metody s návratovou hodnotou null
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Podmínìné skoky øízené hodnotou reference + ètvrtý demonstraèní pøíklad</h2>

<p>V¹echny podmínìné skoky popsané <a href="#k04">ve ètvrté kapitole</a> jsou
urèeny pro práci s&nbsp;operandy typu <i>int</i>. Díky existenci instrukcí typu
<strong>[lfd]cmp</strong> je navíc mo¾né provést test na aktuální hodnotu
operandù typu <i>long</i>, <i>float</i> i <i>double</i>. Jak ji¾ víme
z&nbsp;pøedchozích dvou èástí tohoto seriálu, není nutné, aby existovaly
podobné instrukce i pro datové typy <i>boolean</i>, <i>byte</i>, <i>char</i> a
<i>short</i>, proto¾e operandy tìchto typù jsou automaticky pøevedeny na datový
typ <i>int</i>. Ov¹em ve skuteènosti pracuje virtuální stroj Javy je¹tì
s&nbsp;jedním datovým typem. Tím je <i>reference</i>. Parametry, lokální
promìnné èi operandy ulo¾ené na zásobníku operandù, které jsou datového typu
reference, mohou buï obsahovat speciální hodnotu <strong>NULL</strong> nebo
musí obsahovat (vìt¹inou nepøímý) ukazatel na platný objekt vytvoøený na haldì
(<i>heap</i>). Od bì¾ných ukazatelù známých napøíklad z&nbsp;céèka èi C++ se
reference odli¹ují takté¾ v&nbsp;tom ohledu, ¾e jim není mo¾né pøímo pøiøadit
hodnotu a nelze s&nbsp;nimi provádìt ukazatelovou aritmetiku (navíc je mo¾né na
64bitových platformách pou¾ívat takzvané komprimované ukazatele s&nbsp;délkou
32 bitù).</p>

<p>Vzhledem k&nbsp;tomu, ¾e s&nbsp;referencemi není mo¾né provádìt
plnohodnotnou ukazatelovou aritmetiku, není umo¾nìn ani jejich pøevod na celé
èíslo (èi naopak). Reference v¹ak lze navzájem porovnávat pomocí instrukcí, o
nich¾ se zmíníme <a href="#k07">v&nbsp;navazující kapitole</a>. Ov¹em velmi
èasto se v&nbsp;programovém kódu vyskytne podmínka typu
<strong>object==null</strong> èi naopak <strong>object!=null</strong>, kterou
je vhodné nìjakým optimálním zpùsobem pøelo¾it do instrukcí bajtkódu.
Porovnávání s&nbsp;konstantou <strong>null</strong> vytvoøenou pomocí instrukce
<strong>aconst_null</strong> a ulo¾enou na zásobník operandù je sice samozøejmì
mo¾né, ale zbyteènì slo¾ité. Z&nbsp;tohoto dùvodu byly do bajtkódu pøidány
dal¹í dva podmínìné skoky, které pøímo testují, zda je referenci umístìné na
vrcholu zásobníku operandù (<i>TOS</i>) pøiøazen platný ukazatel na existující
objekt, nebo zda tato reference obsahuje speciální hodnotu
<strong>null</strong>. Tyto dva podmínìné skoky se jmenují pøímoèaøe
<strong>ifnull</strong> a <strong>ifnonnull</strong> a jsou spoleènì se svými
operaèními kódy vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Podmínka</th><th>Operace</th></tr>
<tr><td>1</td><td>ifnull   </td><td>0xC6</td><td>highbyte, lowbyte</td><td>TOS=null</td><td>skok na adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>2</td><td>ifnonnull</td><td>0xC7</td><td>highbyte, lowbyte</td><td>TOS&ne;null</td><td>skok na adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
</table>

<p>Uka¾me si pou¾ití tìchto dvou instrukcí na velmi jednoduchém demonstraèním
pøíkladu, který obsahuje pouze dvì statické metody. Jedna z&nbsp;metod vrací
pravdivostní hodnotu <strong>true</strong> v&nbsp;pøípadì, ¾e byl metodì pøedán
nullový objekt, druhá metoda vrací ve stejném pøípadì hodnotu
<strong>false</strong>:</p>

<pre>
class Test4 {
&nbsp;
    static boolean nullp(Object object) {
        return object == null;
    }
&nbsp;
    static boolean notnullp(Object object) {
        return object != null;
    }
&nbsp;
}
</pre>

<p>Následuje výpis bajtkódu vygenerovaného pro obì vý¹e vypsané metody:</p>

<pre>
static boolean nullp(java.lang.Object);
  Code:
   0:   aload_0          // naètení prvního parametru metody
   1:   ifnonnull   8    // podmínka je oproti zdrojovému kódu negována
   4:   iconst_1         // odpovídá pravdivostní hodnotì true
   5:   goto    9
   8:   iconst_0         // odpovídá pravdivostní hodnotì false
   9:   ireturn          // konec metody s ulo¾ením návratové hodnoty
</pre>

<p>Sekvence instrukcí pro druhou metodu je prakticky stejná, jako pøedchozí
sekvence, pouze je otoèena podmínka ve druhé instrukci:</p>

<pre>
static boolean notnullp(java.lang.Object);
  Code:
   0:   aload_0          // naètení prvního parametru metody
   1:   ifnull  8        // podmínka je oproti zdrojovému kódu negována
   4:   iconst_1         // odpovídá pravdivostní hodnotì true
   5:   goto    9
   8:   iconst_0         // odpovídá pravdivostní hodnotì false
   9:   ireturn          // konec metody s ulo¾ením návratové hodnoty
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Porovnání dvou operandù s&nbsp;podmínìným skokem</h2>

<p>Z&nbsp;teoretického hlediska by podmínìné skoky popsané v&nbsp;pøedchozích
kapitolách mìly ve v¹ech pøípadech postaèovat. V&nbsp;praxi &ndash; napøíklad
pøi implementaci poèítaných programových smyèek &ndash; je v¹ak vhodné umìt
efektivnì provést podmínìný skok na základì porovnání <strong>dvou</strong>
operandù, nikoli na základì porovnání jednoho operandu vùèi nule. Samozøejmì je
mo¾né nejdøíve oba operandy od sebe odeèíst a poté provést skok na základì
výsledku tohoto rozdílu (co¾ se podobá systému pou¾ívanému u mnohých typù
mikroprocesorù), to v¹ak vy¾aduje zbyteènì dlouhou sekvenci instrukcí.
Z&nbsp;tohoto dùvodu se v&nbsp;instrukèním souboru JVM nachází i instrukce,
které porovnají dvojici operandù typu <i>int</i> ulo¾enou na nejvrchnìj¹ích
dvou pozicích zásobníku operandù a skok vykonají na základì toho, zda je první
operand vìt¹í, men¹í èi roven operandu druhému (oba operandy jsou navíc ze
zásobníku odstranìny):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Podmínka</th><th>Operace</th></tr>
<tr><td>1</td><td>if_icmpeq</td><td>0x9F</td><td>highbyte, lowbyte</td><td>value1=value2</td><td>skok na adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>2</td><td>if_icmpne</td><td>0xA0</td><td>highbyte, lowbyte</td><td>value1&ne;value2</td><td>skok na adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>3</td><td>if_icmplt</td><td>0xA1</td><td>highbyte, lowbyte</td><td>value1&lt;value2</td><td>skok na adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>4</td><td>if_icmpge</td><td>0xA2</td><td>highbyte, lowbyte</td><td>value1&ge;value2</td><td>skok na adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>5</td><td>if_icmpgt</td><td>0xA3</td><td>highbyte, lowbyte</td><td>value1&gt;value2</td><td>skok na adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>6</td><td>if_icmple</td><td>0xA4</td><td>highbyte, lowbyte</td><td>value1&le;value2</td><td>skok na adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
</table>

<p>Kromì porovnání dvou operandù typu <i>int</i> je takté¾ mo¾né porovnat dvì
reference. Ov¹em vzhledem k&nbsp;neexistenci skuteèné ukazatelové aritmetiky
(viz vý¹e) lze dvì reference porovnat pouze na rovnost nebo nerovnost, nikoli
ji¾ na to, zda je jedna reference (resp.&nbsp;hodnota ukazatele)
&bdquo;vìt¹í&ldquo; nebo &bdquo;men¹í&ldquo; ne¾ druhá. Z&nbsp;tohoto dùvodu
pro porovnávání dvou referencí existují pouze dvì instrukce vypsané
v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Podmínka</th><th>Operace</th></tr>
<tr><td>1</td><td>if_acmpeq</td><td>0xA5</td><td>highbyte, lowbyte</td><td>value1=value2</td><td>skok na adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>2</td><td>if_acmpne</td><td>0xA6</td><td>highbyte, lowbyte</td><td>value1&ne;value2</td><td>skok na adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Pátý demonstraèní pøíklad &ndash; porovnání dvou operandù s&nbsp;podmínìným skokem</h2>

<p>V¹echny demonstraèní pøíklady, které jsme si a¾ doposud ukazovali, byly co
nejjednodu¹¹í; ideálnì takové, ¾e se v&nbsp;nich nevyskytovaly ¾ádné neznámé
instrukce. Ov¹em v&nbsp;tomto okam¾iku ji¾ známe zhruba sedmdesát procent v¹ech
instrukcí, které se v&nbsp;instrukèním souboru virtuálního stroje Javy
vyskytují, tak¾e si mù¾eme ukázat ponìkud slo¾itìj¹í pøíklad, v&nbsp;nìm¾ budou
vyu¾ity jak podmínìné skoky popsané <a href="#k07">v&nbsp;pøedchozí
kapitole</a>, tak i nepodmínìný skok <strong>goto</strong>, o nìm¾ jsme se
zmínili <a href="#k03">v&nbsp;kapitole tøetí</a>. Zápis zdrojového kódu
programu v&nbsp;jazyce Java sice nevypadá pøíli¹ slo¾itì, ve skuteènosti se ale
kvùli existenci dvou do sebe vnoøených poèítaných smyèek a konstrukcí
<strong>continue</strong> a <strong>break</strong> vygenerovaný kód ponìkud
&bdquo;za¹modrchá&ldquo; (popravdì øeèeno i JIT pøekladaè bude mít s&nbsp;tímto
kódem dosti práce):</p>

<pre>
class Test5 {
&nbsp;
    static void cmpInstr() {
        for (int y = 0; y &lt; 10; y++) {
            if (y &lt; 5) continue;
            for (int x = 0; x &lt; 10; x++) {
                if (x == 5) break;
            }
        }
    }
&nbsp;
}
</pre>

<p>Následuje výpis vygenerované sekvence instrukcí s&nbsp;ruènì dopsanými
poznámkami:</p>

<pre>
static void cmpInstr();
  Code:
   0:   iconst_0        // inicializace poèitadla vnìj¹í smyèky
   1:   istore_0        // jedná se o první lokální promìnnou (s viditelností jen uvnitø smyèky)
&nbsp;
   2:   iload_0         // podmínka ukonèení vnìj¹í smyèky
   3:   bipush  10      // konstanta pøedstavující hodnotu poèitadla, pøi jejím¾ dosa¾ení se smyèka ukonèí
   5:   if_icmpge   44  // poèitadlo dosáhlo mezní hodnoty - skok ZA konec vnìj¹í smyèky
&nbsp;
   8:   iload_0         // implementace podmínky "if (y &lt; 5) continue;"
   9:   iconst_5        // konstanta, s ní¾ je hodnota poèitadla srovnávána
   10:  if_icmpge   16
   13:  goto    38      // skok ZA konec vnitøní smyèky
&nbsp;
   16:  iconst_0        // inicializace poèitadla vnitøní smyèky
   17:  istore_1        // jedná se o druhou lokální promìnnou (s viditelností jen uvnitø smyèky)
&nbsp;
   18:  iload_1         // podmínka ukonèení vnitøní smyèky
   19:  bipush  10      // konstanta pøedstavující hodnotu poèitadla, pøi jejím¾ dosa¾ení se smyèka ukonèí
   21:  if_icmpge   38  // poèitadlo dosáhlo mezní hodnoty - skok ZA konec vnitøní smyèky 
&nbsp;
   24:  iload_1         // implementace podmínky "if (x == 5) break;"
   25:  iconst_5        // konstanta, s ní¾ je hodnota poèitadla srovnávána
   26:  if_icmpne   32
   29:  goto    38      // skok ZA konec vnitøní smyèky
&nbsp;
   32:  iinc    1, 1    // zvý¹ení poèitadla vnitøní smyèky
   35:  goto    18      // dal¹í iterace vnitøní smyèky
&nbsp;
   38:  iinc    0, 1    // zvý¹ení poèitadla vnìj¹í smyèky
   41:  goto    2       // dal¹í iterace vnìj¹í smyèky
&nbsp;
   44:  return
</pre>

<p>Vzhledem k&nbsp;tomu, ¾e celý dne¹ní èlánek byl zamìøený pøedev¹ím na
problematiku nepodmínìných i podmínìných skokù, bude zajímavé si semigraficky
zvýraznit, kolik skokù je v&nbsp;na¹í demonstraèní metodì vùbec pou¾ito. Pro
samotnou implementaci poèítané smyèky <strong>for</strong> je nutné pou¾ít dva
skoky &ndash; podmínìný skok <strong>if_icmpge</strong>, který zaji¹»uje test
na koncovou podmínku a nepodmínìný skok <strong>goto</strong>, jen¾ na konci
smyèky zajistí skok na její zaèátek. Dal¹í dvojice
<strong>if_icmpge+goto</strong> je pou¾ita pro implementaci konstrukcí
<strong>break</strong> a <strong>continue</strong>:</p>

<pre>
static void cmpInstr();
             Code:
              0:   iconst_0
              1:   istore_0
+-----------&gt; 2:   iload_0
|             3:   bipush  10
|             5:   if_icmpge   44 ------------+
|             8:   iload_0                    |
|             9:   iconst_5                   |
|             10:  if_icmpge   16 ----+       |
|   +-------- 13:  goto    38         |       |
|   |         16:  iconst_0      &lt;----+       |
|   |         17:  istore_1                   |
|   |         18:  iload_1       &lt;............|.....
|   |         19:  bipush  10                 |    :
|   |         21:  if_icmpge   38 --------+   |    :
|   |         24:  iload_1                |   |    :
|   |         25:  iconst_5               |   |    :
|   |         26:  if_icmpne   32 ----+   |   |    :
|   |   +---- 29:  goto    38         |   |   |    :
|   |   |     32:  iinc    1, 1  &lt;----+   |   |    :
|   |   |     35:  goto    18    .........|...|....:
|   +---\===&gt; 38:  iinc    0, 1  &lt;--------+   |
+------------ 41:  goto    2                  |
              44:  return        &lt;------------+
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Root.cz: Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM<br />
<a href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/</a></a>
</li>

<li>Root.cz: JamVM aneb alternativa k HotSpotu nejenom pro embedded zaøízení a chytré telefony<br />
<a href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>FindBugs<br />
<a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a>
</li>

<li>GNU Classpath<br />
<a href="www.gnu.org/s/classpath/">www.gnu.org/s/classpath/</a></li>

<li>Java VMs Compared<br />
<a href="http://bugblogger.com/java-vms-compared-160/">http://bugblogger.com/java-vms-compared-160/</a>
</li>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a></li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>CloseableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html">http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

