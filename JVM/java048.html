<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Clojure 17: vyu¾ití standardních maker v praxi</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Clojure 17: vyu¾ití standardních maker v praxi</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o vlastnostech programovacího jazyka Java i JVM se ji¾ naposledy budeme zabývat popisem makrosystému programovacího jazyka Clojure. Popí¹eme si nìkterá makra, která vývojáøi tvoøící aplikace v jazyce Clojure vyu¾ívají v podstatì ka¾dý den, i kdy¾ si nìkdy neuvìdomují, ¾e volají makra a nikoli bì¾né funkce èi speciální formy.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyk Clojure 17: vyu¾ití standardních maker v praxi</a></p>
<p><a href="#k02">2. Makro <strong>comment</strong></a></p>
<p><a href="#k03">3. Makra <strong>when</strong> a <strong>when-not</strong></a></p>
<p><a href="#k04">4. Makro <strong>if-not</strong></a></p>
<p><a href="#k05">5. Univerzální podmínìné provádìní pøíkazù s&nbsp;vyu¾itím makra <strong>cond</strong></a></p>
<p><a href="#k06">6. Makro <strong>while</strong> dal¹í ponìkud skrytá &bdquo;nefunkcionální&ldquo; øídicí konstrukce</a></p>
<p><a href="#k07">7. Makro <strong>dotimes</strong>: dal¹í pøíklad pou¾ití tail rekurze v&nbsp;praxi</a></p>
<p><a href="#k08">8. Idiom <strong>with-*</strong> pou¾ívaný v&nbsp;programovacích jazycích odvozených od LISPu</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk Clojure 17: vyu¾ití maker v praxi</h2>

<p>V&nbsp;dne¹ní èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyce Java i o virtuálním stroji Javy (JVM)</a> dokonèíme popis
makrosystému jazyka <i>Clojure</i> postaveného nad JVM. V&nbsp;pøedchozích dvou
èástech tohoto seriálu jsme si øekli, jakým zpùsobem jsou makra aplikována
(je¹tì pøed pokusem o vyhodnocení formy) a na nìkolika demonstraèních
pøíkladech jsme si ukázali tvorbu vlastních u¾ivatelských maker, pøi jejich¾
zápisu jsme pou¾ívali takzvaná <i>reader makra</i> nazvaná
&bdquo;syntax-quote&ldquo; (zapisováno pomocí zpìtného apostrofu),
&bdquo;unqote&ldquo; (zapisováno znakem tilda pøed symbolem) a
&bdquo;unquote-splicing&ldquo; (zapisováno znakem tilda následovaného
zavináèem). Ov¹em i pøes mo¾nost pou¾ití tìchto znakù se speciálním významem je
tvorba u¾ivatelských maker pomìrnì slo¾itá zále¾itost, proto¾e jejich tvùrci
musí zajistit správnou funkci makra i v&nbsp;rùzných mezních pøípadech &ndash;
makro je napøíklad zavoláno bez parametrù, jeho parametrem jsou jen prázdné
závorky namísto oèekávaného seznamu pøíkazù atd.</p>

<p>Nicménì makrosystém programovacího jazyka <i>Clojure</i> je mo¾né vyu¾ít i
bez toho, aby musel vývojáø vytváøet svá vlastní u¾ivatelská makra &ndash; mù¾e
toti¾ vyu¾ít sadu maker dodávanou jako takøka nedílnou souèást samotného
<i>Clojure</i>. Nìkterá dále popisovaná makra jsou toti¾ definována
v&nbsp;souboru <strong>core.clj</strong>, jen¾ obsahuje definice zcela
základních funkcí i maker, bez nich¾ by v&nbsp;podstatì nebylo mo¾né prakticky
pou¾ívat smyèku <i>REPL</i> (teoreticky by to mo¾né sice bylo, ale èitelnost
takto vytvoøených programù by nebyla vysoká). U v¹ech dále popisovaných maker
bude uvedena i jejich definice, proto¾e právì na pøíkladu standardních maker se
mù¾eme pøiuèit nejenom to, jak se mají vyváøet u¾ivatelská makra, ale dozvíme
se i základní informace o interní struktuøe smyèky <i>REPL</i>. Takté¾ si
uká¾eme nìkteré idiomy pou¾ívané v&nbsp;mnoha LISPovských programovacích
jazycích (v&nbsp;samotném LISPu, Scheme atd.). Napøíklad se zmíníme o idiomu
(Javisté by mo¾ná øekli &bdquo;o návrhovém vzoru&ldquo;) <i>with-</i>, jen¾ lze
pou¾ít v&nbsp;mnoha místech aplikace, zejména tam, kde se pracuje
s&nbsp;externím zdrojem (nebo naopak cílem) dat.</p>

<p>V&nbsp;navazujících kapitolách budou popsána následující standardní
makra:</p>

<table>
<tr><th>Makro</th><th>Kapitola</th></tr>
<tr><td>comment</td><td><a href="#02">2</a></td></tr>
<tr><td>when</td><td><a href="#03">3</a></td></tr>
<tr><td>when-not</td><td><a href="#03">3</a></td></tr>
<tr><td>if-not</td><td><a href="#04">4</a></td></tr>
<tr><td>cond</td><td><a href="#05">5</a></td></tr>
<tr><td>while</td><td><a href="#06">6</a></td></tr>
<tr><td>dotimes</td><td><a href="#07">7</a></td></tr>
<tr><td>with-*</td><td><a href="#08">8</a></td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Makro <strong>comment</strong></h2>

<p>Jedno z&nbsp;nejjednodu¹¹ích standardních maker definovaných v&nbsp;souboru
<strong>core.clj</strong> se jmenuje <strong>comment</strong>. Jméno tohoto
makra velmi pøesnì vystihuje, k&nbsp;èemu mù¾e být vyu¾íváno: do makra
<strong>comment</strong> je toti¾ mo¾né uzavøít prakticky libovolnou èást
programu, která bude makrem &bdquo;se¾rána&ldquo; (samozøejmì v&nbsp;èase
naèítání forem) a nebude tedy docházet k&nbsp;pokusu o vyhodnocení takto
obaleného bloku. Jedinou podmínkou, kterou musí vývojáø pou¾ívající makro
<strong>comment</strong> v&nbsp;ka¾dém pøípadì dodr¾et, je nutnost
vybalancování pravých a levých kulatých závorek v&nbsp;bloku, který je makrem
<strong>comment</strong> obalen. Dùvod je prostý &ndash; objekt <i>reader</i>
toti¾ musí mít mo¾nost urèit, kde volání makra <strong>comment</strong> konèí.
Definice tohoto makra je skuteènì velmi jednoduchá, proto¾e makro
<strong>comment</strong> oèekává libovolné mno¾ství parametrù ([&amp; body]),
které nejsou ¾ádným zpùsobem dále pou¾ity ani vyhodnocovány, proto¾e tìlo makra
je prázdné:</p>

<pre>
<i>; zdrojový kód makra comment</i>
(defmacro <strong>comment</strong>
    <i>"Ignores body, yields nil"</i>
    {:added "1.0"}
    [&amp; body])
</pre>

<p>Na druhém øádku definice makra <strong>comment</strong> je zapsána
dokumentace (obdoba Javadocu), na øádku tøetím pak metadata o tom, kdy bylo
toto makro do jazyka <i>Clojure</i> pøidáno. Následuje pøíklad pou¾ití makra
<strong>comment</strong>, který asi nepotøebuje dal¹í podrobnìj¹í
vysvìtlení:</p>

<pre>
<i>; zakomentování formy</i>
user=&gt; <strong>(comment (println "Hello world!"))</strong>
nil
&nbsp;
&nbsp;
<i>; expanze makra comment je v¾dy stejná:</i>
<i>; ... transformuje jakoukoli formu na nil</i>
user=&gt; <strong>(macroexpand-1 '(comment (println "Hello world!")))</strong>
nil
&nbsp;
&nbsp;
<i>; zakomentování volání jednoduché funkce</i>
user=&gt; <strong>(comment (* (6 7)))</strong>
nil
&nbsp;
&nbsp;
<i>; zakomentovat lze i volání neexistující funkce</i>
<i>; ... nedojde k chybì, proto¾e se vyhodnocení neuskuteèní</i>
user=&gt; <strong>(comment (foo 6 7))</strong>
nil
&nbsp;
&nbsp;
<i>; pozor si musíme dát pouze na správné vybalancování závorek</i>
<i>; ... zde pøebývá pravá slo¾ená závorka</i>
user=&gt; <strong>(comment (println "Hello world!")))</strong>
nil
RuntimeException Unmatched delimiter: )  clojure.lang.Util.runtimeException (Util.java:170)
&nbsp;
&nbsp;
user=&gt;
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Makra <strong>when</strong> a <strong>when-not</strong></h2>

<p>Ve zdrojových kódech aplikací vytváøených v&nbsp;programovacím jazyce
<i>Clojure</i> mù¾eme velmi èasto narazit na volání maker nazvaných
<strong>when</strong> a <strong>when-not</strong>. Tìmto makrùm se pøedává
podmínka zapsaná jako forma (tedy výraz) a poté tìlo slo¾ené z&nbsp;libovolnì
dlouhé sekvence forem (pøíkazù). Obì makra se pøevedou na vyhodnocení prvního
pøedaného výrazu s&nbsp;tím, ¾e pokud je výraz vyhodnocen na hodnotu
<strong>true</strong> u makra <strong>when</strong> èi naopak na hodnotu
<strong>false</strong> u makra <strong>when-not</strong>, budou zbývající
výrazy vyhodnoceny v&nbsp;takovém poøadí, v&nbsp;jakém jsou zadány. Proè se
v¹ak vlastnì tato makra v&nbsp;praxi pou¾ívají namísto pøímého vyu¾ití
speciální formy <strong>if</strong>? Je to jednoduché &ndash; ve speciální
formì <strong>if</strong> je mo¾né uvést pouze jeden pøíkaz (&bdquo;tìlo
podmínky&ldquo;) vyhodnocený jen tehdy, pokud je hodnota pøedané podmínky rovna
<strong>true</strong>. Pokud programátor potøebuje uzavøít do podmínky vìt¹í
mno¾ství pøíkazù, pou¾ije právì makra <strong>when</strong> a
<strong>when-not</strong>, kde se tìlo podmínky (seznam výrazù) automaticky
uzavírá speciální formou <strong>do</strong>, která zajistí jejich sekvenèní
provedení. Navíc se pøi pou¾ití <strong>when-not</strong> vyhne pøípadné
nutnosti negování výrazu (podmínky):</p>

<pre>
<i>; zdrojový kód makra when</i>
(defmacro <strong>when</strong>
    <i>"Evaluates test. If logical true, evaluates body in an implicit do."</i>
    {:added "1.0"}
    [test &amp; body]
    (list 'if test (cons 'do body)))
</pre>

<pre>
<i>; zdrojový kód makra when-not</i>
(defmacro <strong>when-not</strong>
    <i>"Evaluates test. If logical false, evaluates body in an implicit do."</i>
    {:added "1.0"}
    [test &amp; body]
        (list 'if test nil (cons 'do body)))
</pre>

<p>Opìt si uká¾eme jednoduché pøíklady pou¾ití, vèetnì expanze maker:</p>

<pre>
<i>; definice funkce, kterou v makrech when a when-not pou¾ijeme</i>
user=&gt; <strong>(defn greater-than? [x y] (&gt; x y))</strong>
#'user/greater-than?
</pre>

<pre>
<i>; pøíklad pou¾ití makra when</i>
<i>; (pov¹imnìte si, ¾e návratovou hodnotou "do"</i>
<i>; je návratová hodnota posledního pøíkazu)</i>
user=&gt; <strong>(when (greater-than? 2 1) (print 2) (print "&gt;") (print 1))</strong>
2&gt;1nil
&nbsp;
&nbsp;
<i>; expanze makra when vypadá následovnì:</i>
user=&gt; <strong>(macroexpand-1 '(when (greater-than? 2 1) (print 2) (print "&gt;") (print 1)))</strong>
(if (greater-than? 2 1) (do (print 2) (print "&gt;") (print 1)))
&nbsp;
&nbsp;
user=&gt;
</pre>

<p>Makro <strong>when-not</strong> generuje výraz vyu¾ívající speciální formu
<strong>if</strong> se tøemi parametry: podmínkou, &bdquo;vìtví if&ldquo; a
&bdquo;vìtví else&ldquo;, pøièem¾ &bdquo;vìtev if&ldquo; obsahuje prázdné tìlo
&ndash; hodnotu <strong>nil</strong>:</p>

<pre>
<i>; pøíklad pou¾ití makra when-not</i>
user=&gt; <strong>(when-not (greater-than? 2 1) (print 2) (print "&gt;") (print 1))</strong>
nil
&nbsp;
&nbsp;
<i>; expanze makra when-not</i>
<i>; (je zde patrné, ¾e se jako druhý parametr speciální</i>
<i>;  formy "if" pøedává v¾dy nil)</i>
user=&gt; <strong>(macroexpand-1 '(when-not (greater-than? 2 1) (print 2) (print "&gt;") (print 1)))</strong>
(if (greater-than? 2 1) nil (do (print 2) (print "&gt;") (print 1)))
&nbsp;
&nbsp;
user=&gt;
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Makro <strong>if-not</strong></h2>

<p>Makra <strong>when</strong> a <strong>when-not</strong> popsaná <a
href="#k03">v&nbsp;pøedchozí kapitole</a> nejsou jedinými standardními makry,
které do programovacího jazyka <i>Clojure</i> pøidávají dal¹í øídicí konstrukce
(alespoò z&nbsp;pohledu programátora). Dal¹ím takovým dosti èasto pou¾ívaným
makrem je makro nazvané <strong>if-not</strong>, jeho¾ význam je ji¾ ze
samotného názvu tohoto makra zøejmý &ndash; jedná se o negaci funkcionality
speciální formy <strong>if</strong>. Pøipomeòme si, ¾e speciální formu
<strong>if</strong> lze volat se dvìma èi tøemi parametry. Pokud je tato forma
zavolána s&nbsp;dvojicí parametrù, je první parametr chápán jako podmínka a
druhý parametr (jen¾ samozøejmì musí být platnou formou) je vyhodnocen pouze
tehdy, pokud je první parametr vyhodnocen na <strong>true</strong>.
V&nbsp;pøípadì, ¾e je speciální forma <strong>if</strong> zavolána se tøemi
parametry, slou¾í poslední parametr jako náhrada &bdquo;vìtve else&ldquo;,
ov¹em opìt se musí jednat pouze o jediný výraz, co¾ je omezení speciální formy
<strong>if</strong>. Toto omezení se v&nbsp;praxi obchází vyu¾itím maker
<strong>when</strong> a <strong>when-not</strong> (viz pøedchozí kapitolu).</p>

<p>Zatímco tìla v¹ech tøí maker, s&nbsp;nimi¾ jsme se seznámili
v&nbsp;pøedchozí dvojici kapitol, byla velmi jednoduchá, je tìlo makra
<strong>if-not</strong> ji¾ ponìkud komplikovanìj¹í, a to ze dvou dùvodù. První
dùvod spoèívá v&nbsp;tom, ¾e u¾ivatel toto makro bude moci volat se dvìma èi
tøemi parametry, tudí¾ je nutné vytvoøit &bdquo;multimakro&ldquo;
s&nbsp;dvojicí tìl (multimakro se zapisuje stejným zpùsobem jako multifunkce
&ndash; pro ka¾dý poèet parametrù je zapsáno zvlá¹tní tìlo funkce/makra). Druhý
dùvod vìt¹í slo¾itosti makra <strong>if-not</strong> je zpùsoben pou¾itím
<i>reader maker</i> &bdquo;syntax-quote&ldquo; (zpìtný apostrof) a
&bdquo;unquote&ldquo; (tilda), díky nim¾ lze makro zapsat formou ¹ablony, co¾
je doporuèovaný zpùsob zápisu maker, s&nbsp;ním¾ jsme se podrobnìji seznámili
v&nbsp;pøedchozí èásti tohoto seriálu:</p>

<pre>
<i>; zdrojový kód makra if-not</i>
(defmacro <strong>if-not</strong>
    <i>"Evaluates test. If logical false, evaluates and returns then expr, </i>
    <i>otherwise else expr, if supplied, else nil."</i>
    {:added "1.0"}
    ([test then]
        `(if-not ~test ~then nil))
    ([test then else]
        `(if (not ~test) ~then ~else)))
</pre>

<p>Dodejme jen, ¾e <strong>test</strong>, <strong>then</strong> a
<strong>else</strong> nejsou v&nbsp;tomto pøípadì ¾ádná klíèová slova, ale
pouze názvy parametrù pøedávaných makru <strong>if-not</strong> pøi jeho volání
(názvy parametrù nesmí být quotovány, proto jsou pøed nimi zapsány tildy).</p>

<p>Jednoduchý pøíklad pou¾ití tohoto makra:</p>

<pre>
user=&gt; <strong>(if-not (zero? (- 1 1)) (println "nenulovy vysledek"))</strong>
nil
&nbsp;
&nbsp;
user=&gt; <strong>(if-not (zero? (- 2 1)) (println "nenulovy vysledek"))</strong>
nenulovy vysledek
nil
&nbsp;
&nbsp;
<i>; díky pou¾ití syntax-quote se rozepí¹e funkce not na plný název</i>
user=&gt; <strong>(macroexpand '(if-not (zero? (- 2 1)) (println "nenulovy vysledek")))</strong>
(if (clojure.core/not (zero? (- 2 1))) (println "nenulovy vysledek") nil)
&nbsp;
&nbsp;
user=&gt;
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Univerzální podmínìné provádìní pøíkazù s&nbsp;vyu¾itím makra <strong>cond</strong></h2>

<p>Pøi popisu standardních maker jazyka <i>Clojure</i> nesmíme zapomenout na
makro <strong>cond</strong>, které je nedílnou souèástí mnoha programovacích
jazykù odvozených od LISPu. Dùvod pro tuto oblibu <strong>cond</strong> (a» ji¾
se jedná v&nbsp;konkrétní implementaci jazyka o makro èi naopak o speciální
formu) je prostý: v&nbsp;pùvodním návrhu programovacího jazyka <i>LISP</i> byl
tento jazyk kromì smyèky <i>REPL</i> doplnìn o sedm základních funkcí a dvì
speciální formy: <strong>atom</strong>, <strong>car</strong>,
<strong>cdr</strong>, <strong>cond</strong>, <strong>cons</strong>,
<strong>eq</strong>, <strong>quote</strong>, <strong>lambda</strong> a
<strong>label</strong>.</p>

<p>Existence smyèky <i>REPL</i> a tìchto sedmi speciálních forem/funkcí
skuteènì staèila pro vytvoøení plnohodnotného (i kdy¾ zpoèátku ne pøíli¹
praktického) programovacího jazyka. V&nbsp;pøípadì <i>Clojure</i> je situace
vlastnì zcela opaèná, proto¾e základní speciální formou pou¾ívanou pro
konstrukci podmínek, je speciální forma <strong>if</strong>, z&nbsp;ní¾ je
relativnì snadné vytvoøit makro <strong>cond</strong>. U nìkterých implementací
LISPu je tomu pøesnì naopak &ndash; základní speciální formou je zde
<strong>cond</strong> a <strong>if</strong> je implementován jako makro.</p>

<p>Vra»me se v¹ak k&nbsp;makru <strong>cond</strong> pou¾itém
v&nbsp;programovacím jazyku <i>Clojure</i>. Toto makro akceptuje libovolný
poèet dvojic test-pøíkaz. Jednotlivé testy (jde samozøejmì o výrazy &ndash;
formy) se postupnì vyhodnocují a v&nbsp;pøípadì, ¾e se vyhodnotí na hodnotu
<strong>true</strong>, vrátí makro <strong>cond</strong> hodnotu vyhodnoceného
pøíkazu. V&nbsp;opaèném pøípadì se vyhodnotí dal¹í test atd. Pokud se ani jeden
test nevyhodnotí na logickou hodnotu <strong>true</strong>, vrátí toto makro
hodnotu <strong>nil</strong>. U makra <strong>cond</strong> je zajímavé
prostudovat jeho stavbu, proto¾e zde najdeme jak test na poèet pøedávaných
parametrù (musí být sudý, nebo» jde v¾dy o dvojice test-pøíkaz), tak i rekurzi.
Pøi rekurzivním volání makra se mu pøedají v¹echny pùvodní parametry kromì
prvních dvou (pøesnìji øeèeno kromì první dvojice test-pøíkaz). Zkuste se sami
zamyslet nad tím, kdy pøesnì k&nbsp;rekurzi dochází:</p>

<pre>
(defmacro <strong>cond</strong>
    <i>"Takes a set of test/expr pairs. It evaluates each test one at a</i>
    <i>time.  If a test returns logical true, cond evaluates and returns</i>
    <i>the value of the corresponding expr and doesn't evaluate any of the</i>
    <i>other tests or exprs. (cond) returns nil."</i>
    {:added "1.0"}
    [&amp; clauses]
      (when clauses
        (list 'if (first clauses)
              (if (next clauses)
                  (second clauses)
                  (throw (IllegalArgumentException.
                           "cond requires an even number of forms")))
              (cons 'clojure.core/cond (next (next clauses))))))
</pre>

<p>Na pøíkladu pou¾ití makra <strong>cond</strong> je patrné, ¾e velmi
efektivním zpùsobem doká¾e nahradit jak pøíkaz <strong>switch-case</strong>,
tak i sekvenci pøíkazù <strong>if-elseif-elseif-else</strong>, které se mnohdy
nevyhneme v&nbsp;jiných programovacích jazycích. Zajímavé je zde i pou¾ití
<strong>:else</strong>, co¾ je keyword (ty se zapisují s&nbsp;dvojteèkou pøed
symbolem). Vyu¾ívá se zde faktu, ¾e <strong>if :keyword ...</strong> v¾dy
povede k&nbsp;vyhodnocení tìla speciální formy <strong>if</strong>; ov¹em
skalní LISPaøi pravdìpodobnì v&nbsp;poslední vìtvi <strong>cond</strong>
pou¾ijí namísto testu pøímo hodnotu <strong>true</strong> (v&nbsp;LISPu jen
<strong>T</strong>):</p>

<pre>
<i>; definice funkce, v ní¾ je vyu¾ito makro cond</i>
(defn <strong>znamka</strong>
    [body]
    (<strong>cond</strong>
        (&gt;= body 95) "A"
        (&gt;= body 80) "B"
        (&gt;= body 70) "C"
        (&gt;= body 60) "D"
        (&gt;= body 50) "E"
        :else "F"))
&nbsp;
&nbsp;
<i>; test funkce znamka</i>
user=&gt; <strong>(znamka 0)</strong>
"F"
&nbsp;
&nbsp;
<i>; test funkce znamka</i>
user=&gt; <strong>(znamka 50)</strong>
"E"
&nbsp;
&nbsp;
<i>; test funkce znamka</i>
user=&gt; <strong>(znamka 90)</strong>
"B"
&nbsp;
&nbsp;
<i>; test funkce znamka</i>
user=&gt; <strong>(znamka 100)</strong>
"A"
&nbsp;
&nbsp;
<i>; slo¾itìj¹í pøíklad</i>
user=&gt; <strong>(map znamka (range 0 101 10))</strong>
("F" "F" "F" "F" "F" "E" "D" "C" "B" "B" "A")
&nbsp;
&nbsp;
user=&gt;
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Makro <strong>while</strong> dal¹í ponìkud skrytá &bdquo;nefunkcionální&ldquo; øídicí konstrukce</h2>

<p>Dal¹ím standardním makrem, o nìm¾ se v&nbsp;dne¹ním èlánku zmíníme, je makro
nazvané <strong>while</strong>. Asi správnì uhodnete, ¾e toto makro iterativnì
spou¹tí (èi lépe øeèeno postupnì vyhodnocuje) nìjaké tìlo smyèky, a to tak
dlouho, dokud platí, ¾e výraz zapsaný za <strong>while</strong> se vyhodnotí na
pravdivostní hodnotu <strong>true</strong>. Pov¹imnìte si, ¾e se opìt ti¹e
pøedpokládá, ¾e tìlo smyèky bude mít nìjaký vedlej¹í efekt jen¾ zpùsobí zmìnu
hodnoty výrazu smyèky <strong>while</strong> (nejedná se tedy z&nbsp;pohledu
funkcionálního programátora o pøíli¹ ¹»astnì vytvoøenou konstrukci). Typickým
vedlej¹ím efektem je nastavení hodnoty nìjaké lokální èi globální promìnné.
Pravdìpodobnì takté¾ uhodnete, jak je makro <strong>while</strong> internì
implementováno &ndash; musí se v&nbsp;nìm pou¾ít rekurze a to dokonce <i>tail
rekurze</i>, která je v&nbsp;programovacím jazyce <i>Clojure</i> pøedstavována
dvojicí <strong>loop-recur</strong>. Jak <strong>loop</strong> tak i
<strong>recur</strong> jsou speciální formy tvoøící základní jazykové
konstrukce vyu¾itelné programátorem:</p>

<pre>
<i>; definice makra while</i>
(defmacro <strong>while</strong>
  <i>"Repeatedly executes body while test expression is true. Presumes</i>
  <i>some side-effect will cause test to become false/nil. Returns nil"</i>
  {:added "1.0"}
  [test &amp; body]
  `(loop []
      (when ~test
          ~@body
          (recur))))
</pre>

<p>Demonstraèní pøíklad bude asi dosti netypický:</p>

<pre>
user=&gt; <strong>(while (&gt; (Math/random) 0.1) (println "Stale pocitam"))</strong>
Stale pocitam
Stale pocitam
Stale pocitam
Stale pocitam
Stale pocitam
Stale pocitam
Stale pocitam
Stale pocitam
Stale pocitam
nil
&nbsp;
&nbsp;
user=&gt;
</pre>

<p>Expanze vý¹e vypsané &bdquo;smyèky while&ldquo; vypadá takto:</p>

<pre>
user=&gt; <strong>(macroexpand-1 '(while (&gt; (Math/random) 0.1) (println "Stale pocitam")))</strong>
(clojure.core/<strong>loop</strong>
    []
    (clojure.core/<strong>when</strong> (&gt; (Math/random) 0.1)
        (println "Stale pocitam") (<strong>recur</strong>)))
<i>; (výstup byl zarovnán ruènì)</i>
&nbsp;
&nbsp;
user=&gt;
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Makro <strong>dotimes</strong>: dal¹í pøíklad pou¾ití tail rekurze v&nbsp;praxi</h2>

<p>V&nbsp;nìkterých typech aplikací mù¾e být pomìrnì u¾iteèné pou¾ít makro
nazvané jednodu¹e a pøitom pøíhodnì <strong>dotimes</strong>, které doká¾e
pøedaný výraz (formu) opakovat <i>n</i> krát. Pøitom toto makro mù¾e
v&nbsp;ka¾dé iteraci (opakování) nastavit zvolenou lokální promìnnou na
aktuální hodnotu poèitadla, pøièem¾ se hodnota poèitadla v&nbsp;první iteraci
v¾dy nastavuje na nulu a v&nbsp;poslední iteraci dosahuje zadaného poètu
opakování-1. Vzdálenì tedy mù¾eme toto makro pova¾ovat za ekvivalent programové
smyèky <strong>for i in range(n):</strong> v&nbsp;programovacím jazyku
<i>Python</i> èi ekvivalent k&nbsp;poèítané smyèce <strong>for (int i = 0;
i&lt;n; i++)</strong> známé z&nbsp;céèka (zde bez mo¾nosti mít lokální
promìnnou jako poèitadlo), C++, Javy atd. Vzhledem k&nbsp;tomu, ¾e se
pøedpokládá, ¾e forma &ndash; tìlo smyèky &ndash; pøedaná makru
<strong>dotimes</strong> bude mít nìjaký vedlej¹í efekt, nejedná se sice o
èistì funkcionální pøístup, nicménì makro <strong>dotimes</strong> mù¾e být
skuteènì velmi u¾iteèné, napøíklad pøi práci s&nbsp;poli (jejich pou¾ití
v&nbsp;aplikaci je vìt¹inou diktováno snahou o dosa¾ení vìt¹í efektivity
programu).</p>

<pre>
<i>; definice makra dotimes je na první pohled dosti komplikovaná</i>
<i>; (pov¹imnìte si pou¾ití makra when uvnitø definice jiného makra)</i>
(defmacro <strong>dotimes</strong>
    <i>"bindings =&gt; name n</i>
    <i>Repeatedly executes body (presumably for side-effects) with name</i>
    <i>bound to integers from 0 through n-1."</i>
    {:added "1.0"}
    [bindings &amp; body]
    <i>; kontroly</i>
    (assert-args
        (vector? bindings) "a vector for its binding"
        (= 2 (count bindings)) "exactly 2 forms in binding vector")
    <i>; vlastní výkonné tìlo makra</i>
    <i>; vyu¾ívající dvojici lokálních promìnných i a n</i>
    (let [i (first bindings)
          n (second bindings)]
        `(let [n# (long ~n)]
            (loop [~i 0]
                (when (&lt; ~i n#)
                    ~@body
                    (recur (unchecked-inc ~i)))))))
</pre>

<p>Pøíklad pou¾ití makra <strong>dotimes</strong> jsme si ji¾ v&nbsp;tomto
seriálu ukazovali:</p>

<pre>
(<strong>dotimes</strong> [i 10]
    (<strong>dotimes</strong> [j 10]
        (print (* (inc i) (inc j)) "\t"))
    (println))
</pre>

<p>A zde je ji¾ výsledek práce tohoto skriptu (poslední <strong>nil</strong> je
návratovou hodnotou makra <strong>dotimes</strong>):</p>

<pre>
1     2     3     4     5     6     7     8     9     10
2     4     6     8     10    12    14    16    18    20
3     6     9     12    15    18    21    24    27    30
4     8     12    16    20    24    28    32    36    40
5     10    15    20    25    30    35    40    45    50
6     12    18    24    30    36    42    48    54    60
7     14    21    28    35    42    49    56    63    70
8     16    24    32    40    48    56    64    72    80
9     18    27    36    45    54    63    72    81    90
10    20    30    40    50    60    70    80    90    100
nil
</pre>

<p>Na expanzi výrazu:</p>

<pre>
(dotimes [i 10] (println i))
</pre>

<p>je patrné pou¾ití lokálních symbolù s&nbsp;jedineèným jménem:</p>

<pre>
user=&gt; <strong>(macroexpand-1 '(dotimes [i 10] (println i)))</strong>
(clojure.core/<strong>let</strong> [n__4220__auto__ (clojure.core/long 10)]
    (clojure.core/<strong>loop</strong>
        [i 0]
        (clojure.core/<strong>when</strong> (clojure.core/&lt; i n__4220__auto__)
            (println i)
            (<strong>recur</strong> (clojure.core/unchecked-inc i)))))
<i>; (výstup byl zarovnán ruènì)</i>
&nbsp;
&nbsp;
user=&gt;
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Idiom <strong>with-*</strong> pou¾ívaný v&nbsp;programovacích jazycích odvozených od LISPu</h2>

<p>Pøi tvorbì reálných aplikací v&nbsp;programovacím jazyku <i>Clojure</i> se
pomìrnì èasto setkáme s&nbsp;následujícím problémem: máme za úkol otevøít
nìjaký zdroj dat (databázi, soubor...), pøeèíst z&nbsp;tohoto zdroje data a
posléze zdroj dat opìt zavøít. Dal¹ím praktickým problémem je nastavení
pøesnosti a zaokrouhlovacího re¾imu pro objekty typu
<strong>BigDecimal</strong>, provedení nìjaké matematické operace a následnì
obnovení pùvodní pøesnosti a zaokrouhlovacího re¾imu. V¹echny tyto problémy
tedy vy¾adují, aby se provedla nìjaká nastavovací operace, která vìt¹inou mìní
prostøedí programu, posléze se provede vlastní výpoèet/sekvence pøíkazù a
nakonec se obnoví pùvodní prostøedí programu. Takto chápané operace se
v&nbsp;programovacím jazyce <i>Clojure</i> pomìrnì èasto implementují
s&nbsp;vyu¾itím maker, jejich¾ název zaèíná na <strong>with-</strong>.
Pøíkladem mù¾e být makro <strong>with-precision</strong> pro doèasnou zmìnu
pøesnosti a zaokrouhlovacího re¾imu pro objekty typu
<strong>BigDecimal</strong> (viz pøedchozí text):</p>

<pre>
user=&gt; <strong>(with-precision 1 (/ 1M 3))</strong>
0.3M
&nbsp;
&nbsp;
user=&gt; <strong>(with-precision 2 (/ 1M 3))</strong>
0.33M
&nbsp;
&nbsp;
user=&gt; <strong>(with-precision 10 (/ 1M 3))</strong>
0.3333333333M
&nbsp;
&nbsp;
user=&gt;
</pre>

<p>Pøíkladem takto pojatého makra je pomìrnì u¾iteèné standardní makro
<strong>with-out-str</strong>, které doká¾e &bdquo;zachytit&ldquo; v¹echna
volání funkcí <strong>print</strong> a <strong>println</strong>. Øetìzce, které
by se pomocí tìchto funkcí normálnì vypsaly na standardní výstup, jsou namísto
vyu¾ity jako návratová hodnota makra:</p>

<pre>
user=&gt; <strong>(with-out-str (print "Hello ") (print "world") (print '!))</strong>
"Hello world!"
&nbsp;
&nbsp;
user=&gt; <strong>(def vystup (with-out-str (print "Hello ") (print "world") (print '!)))</strong>
#'user/vystup
&nbsp;
&nbsp;
user=&gt; <strong>vystup</strong>
"Hello world!"
&nbsp;
&nbsp;
user=&gt;
</pre>

<p>Jak ji¾ bylo øeèeno v&nbsp;úvodním odstavci, pracují makra
<strong>with-</strong> takovým zpùsobem, ¾e doèasnì zmìní prostøedí programu.
Nejinak je tomu i v&nbsp;pøípadì makra <strong>with-out-str</strong>, kde se
doèasnì zmìní objekt navázaný na symbol <strong>*out*</strong>, jen¾
pøedstavuje standardní výstup, neboli v&nbsp;øeèi Javy
<strong>System.out</strong>. Symbol <strong>*out*</strong> je pøi provádìní
pøíkazù pøedaných makru pøesmìrován na novou instanci objektu
<strong>java.io.StringWriter</strong>, který je po provedení tìla pøeveden na
øetìzec s&nbsp;vyu¾itím funkce <strong>str</strong>:</p>

<pre>
(defmacro <strong>with-out-str</strong>
  <i>"Evaluates exprs in a context in which *out* is bound to a fresh</i>
  <i>StringWriter.  Returns the string created by any nested printing</i>
  <i>calls."</i>
  {:added "1.0"}
  [&amp; body]
  `(let [s# (new java.io.StringWriter)]
      (binding [*out* s#]
          ~@body
          (str s#))))
</pre>

<p>Jediným neznámým symbolem je zde <strong>binding</strong>, co¾ je dal¹í
makro, které doká¾e doèasnì (v&nbsp;rámci provádìní tìla) navázat na nìjaký
symbol jinou hodnotu.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Eulerovo èíslo<br />
<a href="http://cs.wikipedia.org/wiki/Eulerovo_èíslo">http://cs.wikipedia.org/wiki/Eulerovo_èíslo</a>
</li>

<li>List comprehension<br />
<a href="http://en.wikipedia.org/wiki/List_comprehension">http://en.wikipedia.org/wiki/List_comprehension</a>
</li>

<li>List Comprehensions in Clojure<br />
<a href="http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html">http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html</a>
</li>

<li>Clojure Programming Concepts: List Comprehension<br />
<a href="http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension">http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension</a>
</li>

<li>Clojure core API: for macro<br />
<a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for">http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for</a>
</li>

<li>cirrus machina - The Clojure for macro<br />
<a href="http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/">http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/</a>
</li>

<li>Clojure.org: Clojure home page<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>A Couple of Clojure Agent Examples<br />
<a href="http://lethain.com/a-couple-of-clojure-agent-examples/">http://lethain.com/a-couple-of-clojure-agent-examples/</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/">http://java.sun.com/developer/technicalArticles/DynTypeLang/</a>
</li>

<li>JSR 223: Scripting for the Java<sup>TM</sup> Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=223">http://jcp.org/en/jsr/detail?id=223</a>
</li>

<li>JSR 292: Supporting Dynamically Typed Languages on the Java<sup>TM</sup> Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=292">http://jcp.org/en/jsr/detail?id=292</a>
</li>

<li>Java 7: A complete invokedynamic example<br />
<a href="http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html">http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html</a>
</li>

<li>InvokeDynamic: Actually Useful?<br />
<a href="http://blog.headius.com/2007/01/invokedynamic-actually-useful.html">http://blog.headius.com/2007/01/invokedynamic-actually-useful.html</a>
</li>

<li>A First Taste of InvokeDynamic<br />
<a href="http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html">http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html</a>
</li>

<li>Java 6 try/finally compilation without jsr/ret<br />
<a href="http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html">http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Root.cz: Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM<br />
<a href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/</a></a>
</li>

<li>Root.cz: JamVM aneb alternativa k HotSpotu nejenom pro embedded zaøízení a chytré telefony<br />
<a href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>FindBugs<br />
<a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a>
</li>

<li>GNU Classpath<br />
<a href="www.gnu.org/s/classpath/">www.gnu.org/s/classpath/</a></li>

<li>Java VMs Compared<br />
<a href="http://bugblogger.com/java-vms-compared-160/">http://bugblogger.com/java-vms-compared-160/</a>
</li>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Scala Programming Language<br />
<a href="http://www.scala-lang.org/">http://www.scala-lang.org/</a>
</li>

<li>Run Scala in Apache Tomcat in 10 minutes<br />
<a href="http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes">http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes</a>
</li>

<li>Fast Web Development With Scala<br />
<a href="http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html">http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html</a>
</li>

<li>Top five scripting languages on the JVM<br />
<a href="http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855">http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>CloseableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html">http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

