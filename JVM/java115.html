<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - volání funkcí OpenGL s vyu¾itím knihovny SDLJava</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - volání funkcí OpenGL s vyu¾itím knihovny SDLJava</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o virtuálním stroji Javy si uká¾eme, jakým zpùsobem je mo¾né vyu¾ít knihovnu SDLJava pro získání takzvaného vykreslovacího kontextu OpenGL a jaké rozhraní nám SDLJava nabízí pro volání funkcí grafické knihovny OpenGL.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - volání funkcí OpenGL s&nbsp;vyu¾itím knihovny SDLJava</a></p>
<p><a href="#k02">2. Inicializace knihovny SDLJava a získání kontextu OpenGL</a></p>
<p><a href="#k03">3. Inicializace stavového stroje OpenGL a vykreslení jednoduché scény</a></p>
<p><a href="#k04">4. Demonstraèní pøíklad <strong>SDLTest12</strong> &ndash; pou¾ití OpenGL pro vykreslování</a></p>
<p><a href="#k05">5. Geometrické entity v&nbsp;OpenGL 1.x a OpenGL 2.x</a></p>
<p><a href="#k06">6. Demonstraèní pøíklad <strong>SDLTest13</strong> &ndash; vykreslení geometrických primitiv</a></p>
<p><a href="#k07">7. Nastavení základních vlastností vykreslovaných objektù</a></p>
<p><a href="#k08">8. Demonstraèní pøíklad <strong>SDLTest14</strong> &ndash; nastavení základních vlastností vykreslovaných bodù</a></p>
<p><a href="#k09">9. Demonstraèní pøíklad <strong>SDLTest15</strong> &ndash; nastavení základních vlastností vykreslovaných úseèek</a></p>
<p><a href="#k10">10. Demonstraèní pøíklad <strong>SDLTest16</strong> &ndash; nastavení vlastností uzavøených plo¹ných objektù</a></p>
<p><a href="#k11">11. Repositáø se zdrojovými kódy v¹ech pìti dne¹ních demonstraèních pøíkladù</a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - volání funkcí OpenGL s&nbsp;vyu¾itím knihovny SDLJava</h2>

<p>V&nbsp;pøedchozích èástech seriálu o programovacím jazyku Java i o
virtuálním stroji Javy jsme si ukázali vyu¾ití metod nabízených knihovnou
<i>SDLJava</i> pøi vykreslování bitmap do framebufferu i zpùsoby, jakými je
mo¾né èíst èi zapisovat hodnoty jednotlivých pixelù v&nbsp;libovolném objektu
typu <i>SDLSurface</i>. Tyto mo¾nosti nabízené tøídami z&nbsp;balíèkù
<i>SDLJava</i> pøesnì odpovídají grafickým schopnostem nativní knihovny <i>SDL
1.x</i>, která kromì práce s&nbsp;bitmapami, vyplnìní obdélníku a blokového
pøenosu jedné bitmapy do bitmapy jiné ¾ádné dal¹í specializovanìj¹í funkce
nepodporuje. To znamená, ¾e napøíklad algoritmus pro vykreslení úseèky èi
vyplnìného polygonu si buï musí vývojáø sám naprogramovat, popø.&nbsp;mù¾e
alternativnì vyu¾ít nìkteré roz¹iøující moduly, které byly ke knihovnì
<i>SDL</i> vyvinuty. Ov¹em existuje je¹tì jedna mo¾nost, která mù¾e být pro
mnoho aplikací velmi u¾iteèná &ndash; vyu¾ití mo¾ností knihovny <i><a href="http://www.root.cz/serialy/graficka-knihovna-opengl/">OpenGL</a></i> a
tím pádem i schopností nabízených star¹ími i moderními grafickými
akcelerátory.</p>

<p>Vzhledem k&nbsp;tomu, ¾e knihovna <i>OpenGL</i> byla navr¾ena takovým
zpùsobem, ¾e její API je kompatibilní s&nbsp;jazyky C a Fortran, je nutné pro
pou¾ití této knihovny z&nbsp;jiných programovacích jazykù vytvoøit nìjaké
vhodné rozhraní. Týká se to i Javy, kde je toto rozhraní komplikováno
mj.&nbsp;i nutností volat v¹echny funkce <i>OpenGL</i> pøes <i>JNI (Java Native
Interface)</i>. V&nbsp;souèasnosti existuje hned nìkolik podpùrných knihoven i
celých enginù pro Javu, které javovským programátorùm mo¾nosti grafické
knihovny <i>OpenGL</i> více èi ménì pøímoèarým zpùsobem zpøístupòují; my se
v&nbsp;tomto èlánku budeme vìnovat rozhraní, které je nabízené pøímo
v&nbsp;knihovnì <i>SDLJava</i>. Toto rozhraní se nesna¾í ¾ádným zpùsobem
mo¾nosti <i>OpenGL</i> &bdquo;obalovat&ldquo; dal¹í funkcionalitou, tak¾e zde
napøíklad <strong>ne</strong>nalezneme tøídy ani metody pro vytvoøení grafu
scény, naèítání 3D formátù, tvorbu obalových tìles atd. Namísto toho se pøi
vyu¾ití <i>SDLJava</i> setkáme s&nbsp;metodami, které jsou pojmenovány stejnì
jako funkce v&nbsp;nativní knihovnì <i>OpenGL</i> a pøípadné zmìny jsou
provedeny jen kvùli rozdílùm mezi C a Javou (beznaménkové datové typy
atd.).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Inicializace knihovny SDLJava a získání kontextu OpenGL</h2>

<p>Funkce, které jsou nabízeny API grafické knihovny <i>OpenGL</i>, slou¾í pro
nastavení parametrù vykreslovací pipeline a pro zahájení vykreslování tìles
slo¾ených z&nbsp;jednoduchých geometrických prvkù typu bod, úseèka,
trojúhelník, pruh trojúhelníkù atd. V&nbsp;tomto API v¹ak nenajdeme ¾ádné
funkce pro vytvoøení okna, nastavení grafického re¾imu, konfiguraci
framebufferu èi pro prohození funkcí pøedního a zadního bufferu. Tvùrci
<i>OpenGL</i> rozumnì pøedpokládali, ¾e tyto funkce jsou zcela závislé na
konkrétním operaèním systému a tudí¾ je ¾ádným zpùsobem do standardu(ù)
<i>OpenGL</i> nezaøadili. Z&nbsp;tohoto dùvodu je nutné, aby se vytvoøení okna
pro vykreslování popø.&nbsp;nastavení celoobrazovkového grafického re¾imu
øe¹ilo s&nbsp;vyu¾itím jiných knihoven (<i>SDL</i>, <i><a href="http://www.root.cz/serialy/tvorba-prenositelnych-grafickych-aplikaci-vyuzivajicich-knihovnu-glut/">GLUT/freeglut</a></i>,
<i>GLFW</i>, <i>EGL</i> apod.), popø.&nbsp;s&nbsp;vyu¾itím API podporovaného
operaèním systémem (pøíkladem mù¾e být <i>WGL</i>). Podobnou funkcionalitu nám
samozøejmì nabízí i knihovna <i>SDLJava</i>.</p>

<p>Inicializace a získání takzvaného grafického kontextu <i>OpenGL</i> se
skládá ze dvou krokù. Nejprve je nutné inicializovat celoobrazovkový grafický
re¾im èi otevøít okno pro vykreslování s&nbsp;uvedením bitového pøíznaku
<strong>SDLVideo.SDL_OPENGL</strong>:</p>

<pre>
    <i>/**</i>
    <i> * Inicializace grafickeho rezimu ci otevreni okna pro vykreslovani.</i>
    <i> */</i>
    private static SDLSurface <strong>initVideo</strong>() throws SDLException {
        final long flags = SDLVideo.SDL_OPENGL | SDLVideo.SDL_DOUBLEBUF;
        return SDLVideo.setVideoMode(GFX_WIDTH, GFX_HEIGHT, GFX_BPP, flags);
    }
</pre>

<p>Následnì je nutné nad získaným objektem typu <strong>SDLSurface</strong>,
který pøedstavuje framebuffer, zavolat metodu <strong>getGL()</strong>
vracející instanci tøídy implementující rozhraní
<strong>org.gljava.opengl.GL</strong>:</p>

<pre>
    <i>// inicializace grafickeho rezimu ci otevreni okna pro vykreslovani</i>
    SDLSurface screen = initVideo();
&nbsp;
    <i>// inicializace celoobrazovkoveho grafickeho rezimu</i>
    GL gl = screen.getGL();
</pre>

<p>Pøes metody pøedepsané rozhraním <strong>org.gljava.opengl.GL</strong> je
ji¾ mo¾né volat v¹echny funkce <i>OpenGL</i>, co¾ si uká¾eme
v&nbsp;navazujících kapitolách na pìtici demonstraèních pøíkladù.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Inicializace stavového stroje OpenGL a vykreslení jednoduché scény</h2>

<p>Jakmile máme k&nbsp;dispozici instanci tøídy implementující rozhraní
<strong>org.gljava.opengl.GL</strong>, je ji¾ mo¾né pøes tuto instanci volat
nativní funkce knihovny <i>OpenGL</i>. Nejprve se podívejme, jak se nastavují
transformaèní matice (projekèní matice a modelview matice). Nejprve se pøes
<strong>Gl.glMatrixMode()</strong> urèí, obsah jaké matice se má nastavit a
posléze se pøes <strong>Gl.glLoadIdentity()</strong> naète jednotková matice,
co¾ pro na¹e úèely (jednoduchá 2D scéna) plnì postaèuje. Následnì se pøes
<strong>Gl.glOrtho()</strong> nastaví ortogonální promítání (bez perspektivy).
Metoda <strong>Gl.glDisable(gl.GL_DEPTH_TEST)</strong> zaká¾e provádìní testù
na hloubku (vzdálenost) jednotlivých fragmentù vytváøených v&nbsp;procesu
rasterizace objektù a metoda <strong>Gl.glClearColor(0.0f, 0.0f, 0.0f,
0.0f)</strong> specifikuje barvu, kterou se vyma¾e pozadí okna, pøesnìji øeèeno
zadní buffer ulo¾ený ve framebufferu. Pøi jejím volání se zadávají ètyøi
barvové slo¾ky (Red, Green, Blue a Alpha), z&nbsp;nich¾ ka¾dá je v&nbsp;rozsahu
0.0-1.0 (0.0 znamená nepøítomnost pøíslu¹né barvové slo¾ky ve výsledné barvì,
1.0 maximální vysvícení):</p>

<pre>
    <i>/**</i>
    <i> * Nastaveni transformacnich matic a barvy pozadi framebufferu.</i>
    <i> */</i>
    private static void <strong>initScene</strong>(GL gl, int width, int height) {
        <i>// nastaveni projekcni matice</i>
        gl.glMatrixMode(gl.GL_PROJECTION);
        <i>// jednotkova matice</i>
        gl.glLoadIdentity();
        <i>// mapovani abstraktnich souradnic do souradnic okna ci cele obrazovky</i>
        gl.glOrtho(0, width, 0, height, -1, 1);
&nbsp;
        <i>// nastaveni modelview matice</i>
        gl.glMatrixMode(gl.GL_MODELVIEW);
        gl.glLoadIdentity();
        <i>// viditelna oblast</i>
        gl.glViewport(0, 0, width, height);
&nbsp;
        <i>// vypnuti pameti hloubky pri vykreslovani</i>
        gl.glDisable(gl.GL_DEPTH_TEST);
&nbsp;
        <i>// barva pozadi framebufferu pro volani glClear()</i>
        gl.glClearColor (0.0f, 0.0f, 0.0f, 0.0f);
    }
</pre>

<p>Pøi vykreslování budeme pou¾ívat takzvaný pøímý re¾im (<i>direct mode</i>),
který byl specifikován ji¾ v&nbsp;OpenGL verze 1.x a dodnes je dodr¾ována
zpìtná kompatibilita s&nbsp;tímto re¾imem. Teoreticky se sice pøímý re¾im stal
v&nbsp;OpenGL 3.1 oficiálnì nepodporovaným, ov¹em napøíklad ovladaèe karet
<i>nVidia</i> ho stále podporují a podle tvrzení firmy i podporovat budou (nový
a obecnì i rychlej¹í zpùsob vykreslování si pøiblí¾íme v&nbsp;nìkteré
navazující èásti tohoto seriálu).</p>

<p>Metoda <strong>Gl.glBegin(Gl.GL_QUADS)</strong> zahájí vykreslování
ètyøúhelníkù, z&nbsp;nich¾ ka¾dý je specifikován ètyømi vrcholy. Tyto vrcholy
se zadávají napøíklad pøíkazem <strong>Gl.glVertex2i()</strong>, kterému
pøedáme 2D souøadnice vrcholu ètyøúhelníku. Ukonèení zadávání vrcholù zajistí
pøíkaz <strong>Gl.glEnd()</strong>, který tvoøí takzvané &bdquo;pøíkazové
závorky&ldquo; spoleènì s&nbsp;voláním <strong>Gl.glBegin()</strong>. Tyto
pøíkazy tedy v¾dy musí tvoøit pár. Posledním pøíkazem je
<strong>Gl.glFlush()</strong>, jen¾ zajistí provedení v¹ech operací na grafické
kartì. Bez uvedení tohoto pøíkazu by se mohlo stát, ¾e nìkteré objekty by
nebyly zobrazeny, proto¾e by zùstaly v&nbsp;nedokonèeném stavu v&nbsp;grafické
pipeline akcelerátoru:</p>

<pre>
    <i>/**</i>
    <i> * Vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL.</i>
    <i> */</i>
    private static void <strong>drawScene</strong>(GL gl) {
        <i>// vymazani framebufferu</i>
        gl.glClear(gl.GL_COLOR_BUFFER_BIT);
        <i>// vykresleni ctverce</i>
        gl.glBegin(gl.GL_QUADS);
            gl.glColor3f(1.0f, 0.0f, 0.0f);
            gl.glVertex2i(200, 100);
            gl.glColor3f(0.0f, 1.0f, 0.0f);
            gl.glVertex2i(600, 100);
            gl.glColor3f(1.0f, 0.0f, 1.0f);
            gl.glVertex2i(600, 500);
            gl.glColor3f(0.0f, 0.0f, 1.0f);
            gl.glVertex2i(200, 500);
        gl.glEnd();
    }
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Demonstraèní pøíklad <strong>SDLTest12</strong> &ndash; pou¾ití OpenGL pro vykreslování</h2>

<p>V&nbsp;dne¹ním prvním demonstraèním pøíkladu si uká¾eme jak inicializaci
knihovny <i>SDLJava</i>, tak i zpùsob získání kontextu <i>OpenGL</i>. Ve
chvíli, kdy je tento kontext získán, je ji¾ mo¾né provést inicializaci
stavového stroje <i>OpenGL</i> a následnì vykreslit jednoduchou scénu zpùsobem,
který jsme si popsali v&nbsp;pøedchozích dvou kapitolách:</p>

<pre>
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.video.SDLPixelFormat;
import sdljava.video.SDLSurface;
import sdljava.video.SDLVideo;
&nbsp;
import org.gljava.opengl.GL;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Dvanacty demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> *</i>
<i> * Ukazka vyuziti zakladnich moznosti graficke knihovny OpenGL -</i>
<i> * vykresleni ctyruhelniku a vypocet barvy s vyuzitim</i>
<i> * Gouraudova stinovani.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>SDLTest12</strong> {
&nbsp;
    <i>/**</i>
    <i> * Horizontalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_WIDTH</strong> = 800;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_HEIGHT</strong> = 600;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka vybraneho grafickeho rezimu.</i>
    <i> * (0 znamena automaticky vyber, ovsem lze samozrejme pouzit</i>
    <i> * i hodnoty 8, 16, 24 ci 32, podle vlastnosti graficke karty)</i>
    <i> */</i>
    private static final int <strong>GFX_BPP</strong> = 0;
&nbsp;
    <i>/**</i>
    <i> * Inicializace grafickeho rezimu ci otevreni okna pro vykreslovani.</i>
    <i> */</i>
    private static SDLSurface <strong>initVideo</strong>() throws SDLException {
        final long flags = SDLVideo.SDL_OPENGL | SDLVideo.SDL_DOUBLEBUF;
        return SDLVideo.setVideoMode(GFX_WIDTH, GFX_HEIGHT, GFX_BPP, flags);
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni transformacnich matic a barvy pozadi framebufferu.</i>
    <i> */</i>
    private static void <strong>initScene</strong>(GL gl, int width, int height) {
        <i>// nastaveni projekcni matice</i>
        gl.glMatrixMode(gl.GL_PROJECTION);
        <i>// jednotkova matice</i>
        gl.glLoadIdentity();
        <i>// mapovani abstraktnich souradnic do souradnic okna ci cele obrazovky</i>
        gl.glOrtho(0, width, 0, height, -1, 1);
&nbsp;
        <i>// nastaveni modelview matice</i>
        gl.glMatrixMode(gl.GL_MODELVIEW);
        gl.glLoadIdentity();
        <i>// viditelna oblast</i>
        gl.glViewport(0, 0, width, height);
&nbsp;
        <i>// vypnuti pameti hloubky pri vykreslovani</i>
        gl.glDisable(gl.GL_DEPTH_TEST);
&nbsp;
        <i>// barva pozadi framebufferu pro volani glClear()</i>
        gl.glClearColor (0.0f, 0.0f, 0.0f, 0.0f);
    }
&nbsp;
    <i>/**</i>
    <i> * Vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL.</i>
    <i> */</i>
    private static void <strong>drawScene</strong>(GL gl) {
        <i>// vymazani framebufferu</i>
        gl.glClear(gl.GL_COLOR_BUFFER_BIT);
        <i>// vykresleni ctverce</i>
        gl.glBegin(gl.GL_QUADS);
            gl.glColor3f(1.0f, 0.0f, 0.0f);
            gl.glVertex2i(200, 100);
            gl.glColor3f(0.0f, 1.0f, 0.0f);
            gl.glVertex2i(600, 100);
            gl.glColor3f(1.0f, 0.0f, 1.0f);
            gl.glVertex2i(600, 500);
            gl.glColor3f(0.0f, 0.0f, 1.0f);
            gl.glVertex2i(200, 500);
        gl.glEnd();
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni osmeho demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace video subsystemu knihovny SDL</i>
            SDLMain.init(SDLMain.SDL_INIT_VIDEO);
&nbsp;
            <i>// inicializace grafickeho rezimu ci otevreni okna pro vykreslovani</i>
            SDLSurface screen = initVideo();
&nbsp;
            <i>// inicializace celoobrazovkoveho grafickeho rezimu</i>
            GL gl = screen.getGL();
&nbsp;
            <i>// nastaveni transformacnich matic a barvy pozadi framebufferu</i>
            initScene(gl, GFX_WIDTH, GFX_HEIGHT);
&nbsp;
            <i>// vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL</i>
            drawScene(gl);
&nbsp;
            <i>// prepnuti predniho a zadniho bufferu</i>
            screen.glSwapBuffers();
&nbsp;
            <i>// ukonceni aplikace po peti sekundach</i>
            Thread.sleep(5000);
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
        <i>// zobrazit ziskane informace</i>
    }
&nbsp;
}
</pre>

<p>Skript pro pøeklad na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest12.java
</pre>

<p>Dávkový soubor pro pøeklad na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest12.java
</pre>

<p>Skript pro spu¹tìní na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
java -cp .:$SDL_JAVA_LIBS/sdljava.jar -Djava.library.path=$SDL_JAVA_LIBS SDLTest12
</pre>

<p>Dávkový soubor pro spu¹tìní na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest12
</pre>

<a href="http://i.iinfo.cz/images/244/java115-01.png"><img src="http://i.iinfo.cz/images/244/java115-01-prev.png" class="image-160729" width="360" height="270" alt="&#160;" /></a>
<p><i>Obrázek 1: Screenshot demonstraèního pøíkladu <strong>SDLTest12.java</strong>.</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Geometrické entity v&nbsp;OpenGL 1.x a OpenGL 2.x</h2>

<p>Pomocí pøíkazù <i>OpenGL</i> lze pøi pou¾ití <i>pøímého re¾imu</i>
vykreslovat pouze základní geometrické prvky, které nazýváme primitiva.
Z&nbsp;tìchto primitiv se potom skládají slo¾itìj¹í tìlesa a celé rozsáhlé 3D
scény. Existuje celkem deset typù primitiv, mezi ne¾ patøí: izolovaný bod,
úseèka zadaná dvìma koncovými body, øetìzec úseèek (polyèára), uzavøená smyèka
vytvoøená z&nbsp;úseèek (uzavøená polyèára), trojúhelník, trs trojúhelníkù, pás
trojúhelníkù, rovinný ètyøúhelník, pás rovinných ètyøúhelníkù a rovinný
konvexní polygon.</p>

<p>Pøi vykreslování ka¾dého primitiva musíme nejdøíve zadat pøíkaz
<strong>Gl.glBegin(<i>typ primitiva</i>)</strong>, kterým knihovnì
<i>OpenGL</i> sdìlujeme, ¾e se zaèínají zadávat jednotlivé vrcholy primitiva
popø. i vlastnosti tìchto vrcholù. Vykreslování se ukonèí párovým pøíkazem
<strong>Gl.glEnd()</strong>, který nemá ¾ádné parametry. Mezi pøíkazy
<strong>Gl.glBegin()</strong> a <strong>Gl.glEnd()</strong> lze zadat libovolný
poèet vrcholù primitiva pøíkazem <strong>Gl.glVertex*()</strong>. Vrcholy jsou
zadané svými souøadnicemi, a to buï dvìma (<strong>x</strong>,
<strong>y</strong>), tøemi (<strong>x</strong>, <strong>y</strong>,
<strong>z</strong>) nebo ètyømi (<strong>x</strong>, <strong>y</strong>,
<strong>z</strong>, <strong>w</strong>).</p>

<p>Pro dvourozmìrné scény zadáváme pouze souøadnice (<strong>x</strong>,
<strong>y</strong>) a vrcholy se zadávají pøíkazem
<strong>Gl.glVertex2*()</strong>, kde se za znak <strong>*</strong> dosadí
pøíznak udávající datový typ (<strong>i</strong>-int, <strong>f</strong>-float
apod.) parametrù. Souøadnice (<strong>z</strong>) se automaticky nastaví na
nulu a souøadnice (<strong>w</strong>) na jednièku.</p>

<p>Pro 3D scény zadáváme buï souøadnice (<strong>x</strong>,
<strong>y</strong>, <strong>z</strong>) nebo celou ètveøici
(<strong>x</strong>, <strong>y</strong>, <strong>z</strong>,
<strong>w</strong>). Pro trojici souøadnic se pro zadání vrcholù pou¾ívá pøíkaz
<strong>Gl.glVertex3*()</strong>, pro ètveøici souøadnic potom
<strong>Gl.glVertex4*()</strong>. Pokud je zadána pouze trojice souøadnic,
dosadí se za souøadnici <strong>w</strong> automaticky jednièka. Souøadnice
<strong>w</strong> je pou¾ita pøi perspektivní projekci, a udává váhu vrcholu
(<strong>w</strong>eight). Pro bì¾né pou¾ití v¾dy tuto souøadnici nastavujeme
na jednièku, proto¾e touto souøadnicí se dìlí zbylé tøi souøadnice, tedy
<strong>x'=x/w</strong>, <strong>y'=y/w</strong> a <strong>z'=z/w</strong>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Demonstraèní pøíklad <strong>SDLTest13</strong> &ndash; vykreslení geometrických primitiv</h2>

<p>Po pøekladu a spu¹tìní dne¹ního druhého demonstraèního pøíkladu se do okna
vykreslí v¹echna grafická primitiva podporovaná knihovnou <i>OpenGL</i>
v&nbsp;pøípadì, ¾e se pro vykreslování vyu¾ívá pøímý re¾im (<i>direct
mode</i>). Ve spodní èásti okna jsou postupnì vykresleny body, jednotlivé
úseèky, polyèára a uzavøená polyèára, ve druhé øadì pak trojúhelník, pruh
trojúhelníkù a trs trojúhelníkù. V&nbsp;horní øadì je zobrazen ètyøúhelník,
pruh sestavený ze ètyøúhelníkù a obecný konvexní mnohostìn:</p>

<pre>
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.video.SDLPixelFormat;
import sdljava.video.SDLSurface;
import sdljava.video.SDLVideo;
&nbsp;
import org.gljava.opengl.GL;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Trinacty demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> *</i>
<i> * Ukazka vyuziti zakladnich moznosti graficke knihovny OpenGL -</i>
<i> * vykresleni nekolika bodu a linearnich geometrickych tvaru.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>SDLTest13</strong> {
&nbsp;
    <i>/**</i>
    <i> * Horizontalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_WIDTH</strong> = 800;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_HEIGHT</strong> = 600;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka vybraneho grafickeho rezimu.</i>
    <i> * (0 znamena automaticky vyber, ovsem lze samozrejme pouzit</i>
    <i> * i hodnoty 8, 16, 24 ci 32, podle vlastnosti graficke karty)</i>
    <i> */</i>
    private static final int <strong>GFX_BPP</strong> = 0;
&nbsp;
    <i>/**</i>
    <i> * Inicializace grafickeho rezimu ci otevreni okna pro vykreslovani.</i>
    <i> */</i>
    private static SDLSurface <strong>initVideo</strong>() throws SDLException {
        final long flags = SDLVideo.SDL_OPENGL | SDLVideo.SDL_DOUBLEBUF;
        return SDLVideo.setVideoMode(GFX_WIDTH, GFX_HEIGHT, GFX_BPP, flags);
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni transformacnich matic a barvy pozadi framebufferu.</i>
    <i> */</i>
    private static void <strong>initScene</strong>(GL gl, int width, int height) {
        <i>// nastaveni projekcni matice</i>
        gl.glMatrixMode(gl.GL_PROJECTION);
&nbsp;
        <i>// jednotkova matice</i>
        gl.glLoadIdentity();
&nbsp;
        <i>// mapovani abstraktnich souradnic do souradnic okna ci cele obrazovky</i>
        gl.glOrtho(0, width*2/3, 0, height*2/3, -1, 1);
&nbsp;
        <i>// nastaveni modelview matice</i>
        gl.glMatrixMode(gl.GL_MODELVIEW);
        gl.glLoadIdentity();
&nbsp;
        <i>// viditelna oblast</i>
        gl.glViewport(0, 0, width, height);
&nbsp;
        <i>// vypnuti pameti hloubky pri vykreslovani</i>
        gl.glDisable(gl.GL_DEPTH_TEST);
&nbsp;
        <i>// barva pozadi framebufferu pro volani glClear()</i>
        gl.glClearColor (0.0f, 0.0f, 0.0f, 0.0f);
    }
&nbsp;
    <i>/**</i>
    <i> * Vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL.</i>
    <i> */</i>
    private static void <strong>drawScene</strong>(GL gl) {
        <i>// vymazani framebufferu</i>
        gl.glClear(gl.GL_COLOR_BUFFER_BIT);
&nbsp;
        <i>// nastaveni barvy pro vykreslovani</i>
        gl.glColor3f(1.0f, 1.0f, 1.0f);
        gl.glBegin(gl.GL_POINTS);                         <i>// nyni zacneme vykreslovat body</i>
            gl.glVertex2i( 50,  50);
            gl.glVertex2i(100,  50);
            gl.glVertex2i(100, 100);
            gl.glVertex2i( 50, 100);
        gl.glEnd();
&nbsp;
        gl.glColor3f(1.0f, 0.0f, 1.0f);
        gl.glBegin(gl.GL_LINES);                          <i>// nyni zacneme vykreslovat usecky</i>
            gl.glVertex2i(150,  50);
            gl.glVertex2i(200,  50);
            gl.glVertex2i(200, 100);
            gl.glVertex2i(150, 100);
        gl.glEnd();
&nbsp;
        gl.glColor3f(0.0f, 1.0f, 1.0f);
        gl.glBegin(gl.GL_LINE_STRIP);                     <i>// nyni vykreslime polycaru</i>
            gl.glVertex2i(250,  50);
            gl.glVertex2i(300,  50);
            gl.glVertex2i(300, 100);
            gl.glVertex2i(250, 100);
        gl.glEnd();
&nbsp;
        gl.glColor3f(1.0f, 1.0f, 0.0f);
        gl.glBegin(gl.GL_LINE_LOOP);                      <i>// nyni vykreslime uzavrenou polycaru</i>
            gl.glVertex2i(350,  50);
            gl.glVertex2i(400,  50);
            gl.glVertex2i(400, 100);
            gl.glVertex2i(350, 100);
        gl.glEnd();
&nbsp;
        gl.glColor3f(0.0f, 0.0f, 1.0f);
        gl.glBegin(gl.GL_TRIANGLES);                      <i>// vykresleni trojuhelniku</i>
            gl.glVertex2i( 50, 150);
            gl.glVertex2i(100, 150);
            gl.glVertex2i(100, 200);
            gl.glVertex2i( 50, 200);
        gl.glEnd();
&nbsp;
        gl.glColor3f(0.0f, 1.0f, 0.0f);
        gl.glBegin(gl.GL_TRIANGLE_STRIP);                 <i>// vykresleni pruhuÂ trojuhelniku</i>
            gl.glVertex2i(150, 150);
            gl.glVertex2i(150, 200);
            gl.glVertex2i(200, 200);
            gl.glVertex2i(200, 150);
        gl.glEnd();
&nbsp;
        gl.glColor3f(1.0f, 0.0f, 0.0f);
        gl.glBegin(gl.GL_TRIANGLE_FAN);                   <i>// vykresleni trsu trojuhelniku</i>
            gl.glVertex2i(300, 150);
            gl.glVertex2i(250, 160);
            gl.glVertex2i(270, 190);
            gl.glVertex2i(290, 200);
            gl.glVertex2i(310, 200);
            gl.glVertex2i(330, 190);
            gl.glVertex2i(350, 160);
        gl.glEnd();
&nbsp;
        gl.glColor3f(1.0f, 0.5f, 0.5f);
        gl.glBegin(gl.GL_QUADS);                          <i>// vykresleni ctyruhelniku</i>
            gl.glVertex2i( 50, 250);
            gl.glVertex2i(100, 250);
            gl.glVertex2i(100, 300);
            gl.glVertex2i( 50, 300);
        gl.glEnd();
&nbsp;
        gl.glColor3f(0.5f, 0.5f, 1.0f);
        gl.glBegin(gl.GL_QUAD_STRIP);                     <i>// vykresleni pruhu ctyruhleniku</i>
            gl.glVertex2i(150, 250);
            gl.glVertex2i(150, 300);
            gl.glVertex2i(200, 240);
            gl.glVertex2i(200, 310);
            gl.glVertex2i(250, 260);
            gl.glVertex2i(250, 290);
            gl.glVertex2i(300, 250);
            gl.glVertex2i(300, 300);
        gl.glEnd();
&nbsp;
        gl.glColor3f(0.5f, 1.0f, 0.5f);
        gl.glBegin(gl.GL_POLYGON);                        <i>// vykresleni konvexniho polygonu</i>
            gl.glVertex2i(350, 260);
            gl.glVertex2i(370, 240);
            gl.glVertex2i(390, 240);
            gl.glVertex2i(410, 260);
            gl.glVertex2i(410, 280);
            gl.glVertex2i(390, 300);
            gl.glVertex2i(370, 300);
            gl.glVertex2i(350, 280);
        gl.glEnd();
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni osmeho demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace video subsystemu knihovny SDL</i>
            SDLMain.init(SDLMain.SDL_INIT_VIDEO);
&nbsp;
            <i>// inicializace grafickeho rezimu ci otevreni okna pro vykreslovani</i>
            SDLSurface screen = initVideo();
&nbsp;
            <i>// inicializace celoobrazovkoveho grafickeho rezimu</i>
            GL gl = screen.getGL();
&nbsp;
            <i>// nastaveni transformacnich matic a barvy pozadi framebufferu</i>
            initScene(gl, GFX_WIDTH, GFX_HEIGHT);
&nbsp;
            <i>// vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL</i>
            drawScene(gl);
&nbsp;
            <i>// prepnuti predniho a zadniho bufferu</i>
            screen.glSwapBuffers();
&nbsp;
            <i>// ukonceni cele aplikace po peti sekundach</i>
            Thread.sleep(5000);
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
        <i>// zobrazit ziskane informace</i>
    }
&nbsp;
}
</pre>

<p>Skript pro pøeklad na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest13.java
</pre>

<p>Dávkový soubor pro pøeklad na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest13.java
</pre>

<p>Skript pro spu¹tìní na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
java -cp .:$SDL_JAVA_LIBS/sdljava.jar -Djava.library.path=$SDL_JAVA_LIBS SDLTest13
</pre>

<p>Dávkový soubor pro spu¹tìní na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest13
</pre>

<a href="http://i.iinfo.cz/images/621/java115-02.png"><img src="http://i.iinfo.cz/images/621/java115-02-prev.png" class="image-160730" width="360" height="270" alt="&#160;" /></a>
<p><i>Obrázek 2: Screenshot demonstraèního pøíkladu <strong>SDLTest13.java</strong>.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Nastavení základních vlastností vykreslovaných objektù</h2>

<p>Pøi vykreslování lze velmi jednodu¹e mìnit mnoho vlastností
primitiv/objektù. První vlastností, kterou lze mìnit u v¹ech typù primitiv, je
<strong>barva</strong> vrcholu. Jeliko¾ je bod zadán pouze jedním vrcholem
(pøíkazem <strong>Gl.glVertex*()</strong>), je zadaná barva pro celý bod
konstantní, pro úseèky a plo¹né útvary je tomu v¹ak jinak. Barva se zadává
pøíkazem <strong>Gl.glColor*()</strong>. Formát barvy je definován
v&nbsp;barvovém modelu RGB (Red, Green, Blue &ndash; tedy tøi barevné slo¾ky)
nebo RGBA (Red, Green, Blue, Alpha &ndash; tøi barevné slo¾ky a prùhlednost).
Jako typ dat lze pro specifikaci jednotlivých barevných slo¾ek zadat libovolný
datový typ OpenGL; my se budeme v&nbsp;demonstraèních pøíkladech dr¾et typu
<i>float</i>.</p>

<p>Druhou vlastností je <strong>velikost bodu</strong>. Velikost se zadává
pøíkazem <strong>Gl.glPointSize(float size)</strong>, kde parametr
<strong>size</strong> musí být vìt¹í ne¾ nula. Implicitní velikost bodu je
nastavena na 1.0 co¾ odpovídá jednomu pixelu na obrazovce. Velikost bodu nelze
mìnit uvnitø &bdquo;závorkových pøíkazù&ldquo; <strong>glBegin()</strong> a
<strong>glEnd()</strong>.</p>

<p>Tøetí vlastností, kterou lze vypnout nebo zapnout je <i>antialiasing</i>
bodù. Antialiasing se zapíná pøíkazem
<strong>Gl.glEnable(Gl.GL_POINT_SMOOTH)</strong> a vypíná pøíkazem
<strong>Gl.glDisable(Gl.GL_POINT_SMOOTH)</strong>. Pokud je antialiasing
vypnutý, body se zobrazují jako ètverce, pokud je zapnutý, tak by se body mìly
zobrazit jako kruhy s&nbsp;rozmazanými okraji. Zde je zapotøebí zdùraznit, ¾e
ne v¹echny grafické akcelerátory podporují kruhové body. Antialiasing nelze
zapnout a vypnout uvnitø závorkových pøíkazù <strong>glBegin()</strong> a
<strong>glEnd()</strong>. Pøi vypnutém antialiasingu se velikost bodù
zaokrouhluje na celé pixely, pokud je v¹ak antialiasing zapnutý, velikost mù¾e
být neceloèíselná.</p>

<p>Podobnì jako u bodù, i u úseèek lze mìnit jejich <strong>barvu</strong>.
Pokud se barva specifikuje pøed &bdquo;závorkovým pøíkazem&ldquo;
<strong>Gl.glBegin()</strong>, je celá úseèka vykreslena konstantní barvou.
Pokud se barva specifikuje mezi pøíkazy <strong>Gl.glBegin()</strong> a
<strong>Gl.glEnd()</strong>, mù¾e se mìnit barva jednotlivých vrcholù. Na
grafické kartì se potom automaticky provede lineární interpolace barev mezi
vrcholy. Druhou vlastností je <strong>tlou¹»ka úseèky</strong>. Ta se nastavuje
pøíkazem <strong>Gl.glLineWidth(float width)</strong>, kde
<strong>width</strong> musí být vìt¹í ne¾ nula. Implicitní tlou¹»ka úseèek je
nastavena na hodnotu 1.0 co¾ odpovídá jednomu pixelu na obrazovce.</p>

<p>Pøi vykreslování úseèek lze, podobnì jako u bodù, povolit nebo zakázat
<strong>antialiasing</strong>. Pro tento úèel se pou¾ívají pøíkazy
<strong>Gl.glEnable(Gl.GL_LINE_SMOOTH)</strong> a
<strong>Gl.glDisable(Gl.GL_LINE_SMOOTH)</strong>. Pokud je antialiasing úseèek
vypnutý, úseèka se vykreslí s&nbsp;ostrými hranami a konce úseèek budou
zarovnány s&nbsp;nejbli¾¹í souøadnou osou (konce jsou tedy horizontální nebo
vertikální). Pokud je antialiasing úseèek zapnutý, úseèka se vykreslí
s&nbsp;rozmazanými hranami a konce úseèek budou v¾dy kolmé na smìrnici
úseèky.</p>

<p>Poslední vlastností úseèek je <strong>maska</strong>, která se pou¾ívá pøi
vykreslování jednotlivých pixelù úseèky. Maska je ¹estnáctibitová hodnota, kde
jednotlivé bity urèují, zda se má nìkterá èást úseèky vykreslit. Maska tedy
specifikuje vzorek, kterým je úseèka vykreslena. Pokud je napøíklad maska
nastavena na hodnotu 0xfff0 (binárnì 1111111111110000), bude v¾dy dvanáct
pixelù vykresleno a ètyøi pixely nevykresleny. Maska se zadává pøíkazem
<strong>Gl.glLineStipple(factor, pastrongern)</strong>, kde
<strong>factor</strong> je faktor zvìt¹ení masky ve smìru úseèky (vzorek lze
tedy na úseèce &bdquo;natahovat&ldquo;) a <strong>pastrongern</strong> je
bitová maska. Pro povolení maskování se musí zavolat pøíkaz
<strong>Gl.glEnable(Gl.GL_LINE_STIPPLE)</strong>, pro zakázání
<strong>Gl.glDisable(Gl.GL_LINE_STIPPLE)</strong>. Implicitnì je maskování
zakázáno.</p>

<p>U plo¹ných útvarù lze, podobnì jako u bodù a úseèek, mìnit jejich
<strong>barvu</strong>. Pokud se barva specifikuje pøed pøíkazem
<strong>Gl.glBegin()</strong>, je celý útvar vykreslen jednou konstantní barvou
(pokud nepou¾ijeme texturování a osvìtlení &ndash; viz dal¹í díly). Pokud barvu
specifikujeme mezi &bdquo;závorkovými pøíkazy&ldquo;
<strong>Gl.glBegin()</strong> a <strong>Gl.glEnd()</strong>, lze mìnit barvu
jednotlivých vrcholù. Grafická karta nebo softwarová implementace OpenGL potom
provede interpolaci barvy. Tímto jednoduchým zpùsobem lze v&nbsp;OpenGL
dosáhnout <i>Gouraudova stínování</i>.</p>

<p>Ka¾dý plo¹ný útvar má dvì strany (<i>faces</i>) &ndash; rub a líc
(<i>back</i> a <i>front</i>). Tyto strany (orientace se zjistí
z&nbsp;normálového vektoru) mohou být vykresleny odli¹nì. Toho se dá vyu¾ít
napøíklad pøi øezu objektù, kdy je jasné, která strana le¾í uvnitø a která vnì
tìlesa. Odvrácené strany úplnì uzavøených tìles lze oøezat (operace
<i>culling</i>).</p>

<p>Pro rub a/nebo líc lze zadat <i>mód vykreslování</i>. Jsou mo¾né tøi
varianty:</p>

<ul>
<li>vykreslí se pouze vrcholy polygonu (plo¹ného útvaru)</li>
<li>vykreslí se hrany polygonu</li>
<li>vykreslí se vyplnìný polygon</li>
</ul>

<p>Mód vykreslování plo¹ných útvarù se zmìní pøíkazem
<strong>Gl.glPolygonMode(face, mode)</strong>, kde parametr
<strong>face</strong> mù¾e nabývat hodnot <strong>Gl.GL_FRONT_AND_BACK</strong>
(obì strany), <strong>Gl.GL_FRONT</strong> (pøední strana) a
<strong>Gl.GL_BACK</strong> (zadní strana). Parametr <strong>mode</strong> mù¾e
nabývat hodnot <strong>Gl.GL_POINT</strong> (vykreslují se vrcholy),
<strong>Gl.GL_LINE</strong> (vykreslují se hrany) a <strong>Gl.GL_FILL</strong>
(vyplnìný polygon).</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Demonstraèní pøíklad <strong>SDLTest14</strong> &ndash; nastavení základních vlastností vykreslovaných bodù</h2>

<p>V&nbsp;demonstraèním pøíkladu <strong>SDLTest14</strong> je ukázáno, jakým
zpùsobem lze nastavit základní vlastnosti vykreslovaných bodù. Na obrazovce
(resp.&nbsp;ve vytvoøeném oknì) se ve spodní èásti vykreslí nìkolik bodù
s&nbsp;rùznou barvou (tyto body mají velikost jednoho pixelu), nad nimi jsou
nakresleny ètvercové body o rùzné velikosti (antialiasing je zakázaný) a
v&nbsp;horní øadì pak kulaté body, opìt s&nbsp;rùznou velikostí (zde je naopak
antialiasing povolený):</p>

<pre>
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.video.SDLPixelFormat;
import sdljava.video.SDLSurface;
import sdljava.video.SDLVideo;
&nbsp;
import org.gljava.opengl.GL;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Ctrnacty demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> *</i>
<i> * Nastaveni vlastnosti zakladnich geometrickych tvaru (zde konkretne bodu)</i>
<i> * vykreslovanych pres OpenGL.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>SDLTest14</strong> {
&nbsp;
    <i>/**</i>
    <i> * Horizontalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_WIDTH</strong> = 800;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_HEIGHT</strong> = 600;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka vybraneho grafickeho rezimu.</i>
    <i> * (0 znamena automaticky vyber, ovsem lze samozrejme pouzit</i>
    <i> * i hodnoty 8, 16, 24 ci 32, podle vlastnosti graficke karty)</i>
    <i> */</i>
    private static final int <strong>GFX_BPP</strong> = 0;
&nbsp;
    <i>/**</i>
    <i> * Inicializace grafickeho rezimu ci otevreni okna pro vykreslovani.</i>
    <i> */</i>
    private static SDLSurface <strong>initVideo</strong>() throws SDLException {
        final long flags = SDLVideo.SDL_OPENGL | SDLVideo.SDL_DOUBLEBUF;
        return SDLVideo.setVideoMode(GFX_WIDTH, GFX_HEIGHT, GFX_BPP, flags);
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni transformacnich matic a barvy pozadi framebufferu.</i>
    <i> */</i>
    private static void <strong>initScene</strong>(GL gl, int width, int height) {
        <i>// nastaveni projekcni matice</i>
        gl.glMatrixMode(gl.GL_PROJECTION);
&nbsp;
        <i>// jednotkova matice</i>
        gl.glLoadIdentity();
&nbsp;
        <i>// mapovani abstraktnich souradnic do souradnic okna ci cele obrazovky</i>
        gl.glOrtho(0, width/2, 0, height/2, -1, 1);
&nbsp;
        <i>// nastaveni modelview matice</i>
        gl.glMatrixMode(gl.GL_MODELVIEW);
        gl.glLoadIdentity();
&nbsp;
        <i>// viditelna oblast</i>
        gl.glViewport(0, 0, width, height);
&nbsp;
        <i>// vypnuti pameti hloubky pri vykreslovani</i>
        gl.glDisable(gl.GL_DEPTH_TEST);
&nbsp;
        <i>// barva pozadi framebufferu pro volani glClear()</i>
        gl.glClearColor (0.0f, 0.0f, 0.0f, 0.0f);
    }
&nbsp;
    <i>/**</i>
    <i> * Vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL.</i>
    <i> */</i>
    private static void <strong>drawScene</strong>(GL gl) {
        <i>// vymazani framebufferu</i>
        gl.glClear(gl.GL_COLOR_BUFFER_BIT);
&nbsp;
        gl.glDisable(gl.GL_POINT_SMOOTH);              <i>// zakazani antialiasingu bodu</i>
        gl.glPointSize(1.0f);                          <i>// velikost vykreslovanych bodu je jeden pixel</i>
        gl.glBegin(gl.GL_POINTS);
        for (float loop=0.0f; loop&lt;=1.0f; loop+=0.1f) {<i>// vykresleni prvni rady bodu ruzne barvy</i>
            gl.glColor3f(loop, 0.5f, 1.0f-loop);       <i>// zmena barvy uvnitr prikazovych "zavorek" glBegin()/glEnd()</i>
            gl.glVertex2f(50.0f+300.0f*loop, 50.0f);
        }
        gl.glEnd();
&nbsp;
        for (float loop=0.0f; loop&lt;=1.0f; loop+=0.1f) {<i>// vykresleni druhe rady bodu ruzne velikosti a barvy</i>
            gl.glColor3f(loop, 0.5f, 1.0f-loop);       <i>// zmena barvy vne prikazovych "zavorek" glBegin()/glEnd()</i>
            gl.glPointSize(loop*20.0f+1.0f);           <i>// zmena velikosti vykreslovanych bodu</i>
            gl.glBegin(gl.GL_POINTS);
                gl.glVertex2f(50.0f+300.0f*loop, 100.0f);
            gl.glEnd();
        }
&nbsp;
        gl.glEnable(gl.GL_POINT_SMOOTH);               <i>// povoleni antialiasingu bodu</i>
        for (float loop=0.0f; loop&lt;=1.0f; loop+=0.1f) {<i>// vykresleni treti rady bodu ruzne velikosti a barvy</i>
            gl.glColor3f(loop, 0.5f, 1.0f-loop);       <i>// zmena barvy vne prikazovych "zavorek" glBegin()/glEnd()</i>
            gl.glPointSize(loop*20.0f+1.0f);           <i>// zmena velikosti vykreslovanych bodu</i>
            gl.glBegin(gl.GL_POINTS);
                gl.glVertex2f(50.0f+300.0f*loop, 150.0f);
            gl.glEnd();
        }
        gl.glFlush();                                  <i>// provedeni a vykresleni vsech zmen</i>
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni osmeho demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace video subsystemu knihovny SDL</i>
            SDLMain.init(SDLMain.SDL_INIT_VIDEO);
&nbsp;
            <i>// inicializace grafickeho rezimu ci otevreni okna pro vykreslovani</i>
            SDLSurface screen = initVideo();
&nbsp;
            <i>// inicializace celoobrazovkoveho grafickeho rezimu</i>
            GL gl = screen.getGL();
&nbsp;
            <i>// nastaveni transformacnich matic a barvy pozadi framebufferu</i>
            initScene(gl, GFX_WIDTH, GFX_HEIGHT);
&nbsp;
            <i>// vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL</i>
            drawScene(gl);
&nbsp;
            <i>// prepnuti predniho a zadniho bufferu</i>
            screen.glSwapBuffers();
&nbsp;
            <i>// ukonceni cele aplikace po peti sekundach</i>
            Thread.sleep(5000);
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
        <i>// zobrazit ziskane informace</i>
    }
&nbsp;
}
</pre>

<p>Skript pro pøeklad na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest14.java
</pre>

<p>Dávkový soubor pro pøeklad na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest14.java
</pre>

<p>Skript pro spu¹tìní na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
java -cp .:$SDL_JAVA_LIBS/sdljava.jar -Djava.library.path=$SDL_JAVA_LIBS SDLTest14
</pre>

<p>Dávkový soubor pro spu¹tìní na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest14
</pre>

<a href="http://i.iinfo.cz/images/11/java115-03.png"><img src="http://i.iinfo.cz/images/11/java115-03-prev.png" class="image-160731" width="360" height="270" alt="&#160;" /></a>
<p><i>Obrázek 3: Screenshot demonstraèního pøíkladu <strong>SDLTest14.java</strong>.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Demonstraèní pøíklad <strong>SDLTest15</strong> &ndash; nastavení základních vlastností vykreslovaných úseèek</h2>

<p>Dne¹ní pøedposlední pøíklad, jeho¾ název je <strong>SDLTest15</strong>,
slou¾í pro ukázku, jak je mo¾né nastavit vlastnosti vykreslovaných úseèek. Do
vytvoøeného okna jsou vykresleny úseèky, u nich¾ je barva poèáteèního a
koncového vrcholu odli¹ná, co¾ znamená, ¾e grafický akcelerátor musí pou¾ít
lineární stínování. Dále je u úseèek nastavena rozdílná tlou¹»ka, antialiasing
(zapnutý/vypnutý) a v&nbsp;horní èásti okna mù¾eme vidìt nìkolik úseèek, u
nich¾ se postupnì mìní jejich vzorek:</p>

<pre>
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.video.SDLPixelFormat;
import sdljava.video.SDLSurface;
import sdljava.video.SDLVideo;
&nbsp;
import org.gljava.opengl.GL;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Patnacty demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> *</i>
<i> * Nastaveni vlastnosti zakladnich geometrickych tvaru vykreslovanych</i>
<i> * pres OpenGL.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>SDLTest15</strong> {
&nbsp;
    <i>/**</i>
    <i> * Horizontalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_WIDTH</strong> = 800;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_HEIGHT</strong> = 600;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka vybraneho grafickeho rezimu.</i>
    <i> * (0 znamena automaticky vyber, ovsem lze samozrejme pouzit</i>
    <i> * i hodnoty 8, 16, 24 ci 32, podle vlastnosti graficke karty)</i>
    <i> */</i>
    private static final int <strong>GFX_BPP</strong> = 0;
&nbsp;
    <i>/**</i>
    <i> * Inicializace grafickeho rezimu ci otevreni okna pro vykreslovani.</i>
    <i> */</i>
    private static SDLSurface <strong>initVideo</strong>() throws SDLException {
        final long flags = SDLVideo.SDL_OPENGL | SDLVideo.SDL_DOUBLEBUF;
        return SDLVideo.setVideoMode(GFX_WIDTH, GFX_HEIGHT, GFX_BPP, flags);
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni transformacnich matic a barvy pozadi framebufferu.</i>
    <i> */</i>
    private static void <strong>initScene</strong>(GL gl, int width, int height) {
        <i>// nastaveni projekcni matice</i>
        gl.glMatrixMode(gl.GL_PROJECTION);
&nbsp;
        <i>// jednotkova matice</i>
        gl.glLoadIdentity();
&nbsp;
        <i>// mapovani abstraktnich souradnic do souradnic okna ci cele obrazovky</i>
        gl.glOrtho(0, width/2, 0, height/2, -1, 1);
&nbsp;
        <i>// nastaveni modelview matice</i>
        gl.glMatrixMode(gl.GL_MODELVIEW);
        gl.glLoadIdentity();
&nbsp;
        <i>// viditelna oblast</i>
        gl.glViewport(0, 0, width, height);
&nbsp;
        <i>// vypnuti pameti hloubky pri vykreslovani</i>
        gl.glDisable(gl.GL_DEPTH_TEST);
&nbsp;
        <i>// barva pozadi framebufferu pro volani glClear()</i>
        gl.glClearColor (0.0f, 0.0f, 0.0f, 0.0f);
    }
&nbsp;
    <i>/**</i>
    <i> * Vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL.</i>
    <i> */</i>
    private static void <strong>drawScene</strong>(GL gl) {
        int patterns[]={0xff00, 0xf0f0, 0xcccc, 0x5555, 0xfe10, 0x5e32};
&nbsp;
        <i>// vymazani framebufferu</i>
        gl.glClear(gl.GL_COLOR_BUFFER_BIT);
&nbsp;
        gl.glDisable(gl.GL_LINE_SMOOTH);               <i>// zakazani antialiasingu usecek</i>
        gl.glDisable(gl.GL_LINE_STIPPLE);              <i>// zakazani maskovani pixelu na care</i>
        gl.glLineWidth(1.0f);                          <i>// tloustka usecky je jeden pixel</i>
        gl.glBegin(gl.GL_LINES);
&nbsp;
        for (float loop=0.0f; loop&lt;=1.0f; loop+=0.1f) {   <i>// vykresleni prvni rady usecek ruzne barvy</i>
            gl.glColor3f(loop, 0.0f, 1.0f-loop);       <i>// zmena barvy uvnitr prikazovych "zavorek" glBegin()/glEnd()</i>
            gl.glVertex2f(50.0f+300.0f*loop, 20.0f);
            gl.glColor3f(loop, 1.0f, 1.0f-loop);
            gl.glVertex2f(100.0f+300.0f*loop, 70.0f);
        }
        gl.glEnd();
        for (float loop=0.0f; loop&lt;=1.0f; loop+=0.1f) {// vykresleni druhe rady usecek ruzne tloustky
            gl.glLineWidth(loop*10.0f+0.1f);           <i>// zmena tloustky usecky</i>
            gl.glBegin(gl.GL_LINES);
                gl.glColor3f(loop, 0.0f, 1.0f-loop);   <i>// zmena barvy uvnitr prikazovych "zavorek" glBegin()/glEnd()</i>
                gl.glVertex2f(50.0f+300.0f*loop, 90.0f);
                gl.glColor3f(loop, 1.0f, 1.0f-loop);
                gl.glVertex2f(100.0f+300.0f*loop, 140.0f);
            gl.glEnd();
        }
        gl.glEnable(gl.GL_LINE_SMOOTH);                <i>// povoleni antialiasingu usecek</i>
        for (float loop=0.0f; loop&lt;=1.0f; loop+=0.1f) {// vykresleni treti rady usecek ruzne tloustky
            gl.glLineWidth(loop*10.0f+0.1f);           <i>// zmena tloustky usecky</i>
            gl.glBegin(gl.GL_LINES);
                gl.glColor3f(loop, 0.0f, 1.0f-loop);   <i>// zmena barvy uvnitr prikazovych "zavorek" glBegin()/glEnd()</i>
                gl.glVertex2f(50.0f+300.0f*loop, 160.0f);
                gl.glColor3f(loop, 1.0f, 1.0f-loop);
                gl.glVertex2f(100.0f+300.0f*loop, 210.0f);
            gl.glEnd();
        }
        gl.glDisable(gl.GL_LINE_SMOOTH);               <i>// zakazani antialiasingu usecek</i>
        gl.glEnable(gl.GL_LINE_STIPPLE);               <i>// povoleni maskovani pixelu na care</i>
        gl.glLineWidth(1.0f);                          <i>// tloustka usecky je jeden pixel</i>
        gl.glColor3f(1.0f, 1.0f, 1.0f);                <i>// zmena barvy vne prikazovych "zavorek" glBegin()/glEnd()</i>
        for (int i=0; i&lt;6; i++) {
            gl.glLineStipple(2, patterns[i]);          <i>// nastaveni masky pri kresleni usecek</i>
            gl.glBegin(gl.GL_LINES);
                gl.glVertex2i(50, 230+i*15);           <i>// vykresleni usecky</i>
                gl.glVertex2i(350, 230+i*15);
            gl.glEnd();
        }
        gl.glFlush();                                  <i>// provedeni a vykresleni vsech zmen</i>
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni osmeho demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace video subsystemu knihovny SDL</i>
            SDLMain.init(SDLMain.SDL_INIT_VIDEO);
&nbsp;
            <i>// inicializace grafickeho rezimu ci otevreni okna pro vykreslovani</i>
            SDLSurface screen = initVideo();
&nbsp;
            <i>// inicializace celoobrazovkoveho grafickeho rezimu</i>
            GL gl = screen.getGL();
&nbsp;
            <i>// nastaveni transformacnich matic a barvy pozadi framebufferu</i>
            initScene(gl, GFX_WIDTH, GFX_HEIGHT);
&nbsp;
            <i>// vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL</i>
            drawScene(gl);
&nbsp;
            <i>// prepnuti predniho a zadniho bufferu</i>
            screen.glSwapBuffers();
&nbsp;
            <i>// ukonceni cele aplikace po peti sekundach</i>
            Thread.sleep(5000);
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
        <i>// zobrazit ziskane informace</i>
    }
&nbsp;
}
</pre>

<p>Skript pro pøeklad na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest15.java
</pre>

<p>Dávkový soubor pro pøeklad na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest15.java
</pre>

<p>Skript pro spu¹tìní na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
java -cp .:$SDL_JAVA_LIBS/sdljava.jar -Djava.library.path=$SDL_JAVA_LIBS SDLTest15
</pre>

<p>Dávkový soubor pro spu¹tìní na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest15
</pre>

<a href="http://i.iinfo.cz/images/497/java115-04.png"><img src="http://i.iinfo.cz/images/497/java115-04-prev.png" class="image-160732" width="360" height="270" alt="&#160;" /></a>
<p><i>Obrázek 4: Screenshot demonstraèního pøíkladu <strong>SDLTest15.java</strong>.</i></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Demonstraèní pøíklad <strong>SDLTest16</strong> &ndash; nastavení vlastností uzavøených plo¹ných objektù</h2>

<p>V&nbsp;posledním demonstraèním pøíkladu s&nbsp;názvem
<strong>SDLTest16</strong> je ukázán zpùsob nastavení vlastností uzavøených
plo¹ných objektù, v&nbsp;tomto konkrétním pøípadì trojúhelníkù. Trojúhelníky
jsou vykresleny rùzným zpùsobem: s&nbsp;výplní (Gouraudovo stínování), pouze
hrany a pouze vrcholy:</p>

<pre>
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.video.SDLPixelFormat;
import sdljava.video.SDLSurface;
import sdljava.video.SDLVideo;
&nbsp;
import org.gljava.opengl.GL;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Sestnacty demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> *</i>
<i> * Nastaveni vlastnosti zakladnich geometrickych tvaru vykreslovanych</i>
<i> * pres OpenGL.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>SDLTest16</strong> {
&nbsp;
    <i>/**</i>
    <i> * Horizontalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_WIDTH</strong> = 800;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_HEIGHT</strong> = 600;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka vybraneho grafickeho rezimu.</i>
    <i> * (0 znamena automaticky vyber, ovsem lze samozrejme pouzit</i>
    <i> * i hodnoty 8, 16, 24 ci 32, podle vlastnosti graficke karty)</i>
    <i> */</i>
    private static final int <strong>GFX_BPP</strong> = 0;
&nbsp;
    <i>/**</i>
    <i> * Inicializace grafickeho rezimu ci otevreni okna pro vykreslovani.</i>
    <i> */</i>
    private static SDLSurface <strong>initVideo</strong>() throws SDLException {
        final long flags = SDLVideo.SDL_OPENGL | SDLVideo.SDL_DOUBLEBUF;
        return SDLVideo.setVideoMode(GFX_WIDTH, GFX_HEIGHT, GFX_BPP, flags);
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni transformacnich matic a barvy pozadi framebufferu.</i>
    <i> */</i>
    private static void <strong>initScene</strong>(GL gl, int width, int height) {
        <i>// nastaveni projekcni matice</i>
        gl.glMatrixMode(gl.GL_PROJECTION);
&nbsp;
        <i>// jednotkova matice</i>
        gl.glLoadIdentity();
&nbsp;
        <i>// mapovani abstraktnich souradnic do souradnic okna ci cele obrazovky</i>
        gl.glOrtho(0, width*2/3, 0, height*2/3, -1, 1);
&nbsp;
        <i>// nastaveni modelview matice</i>
        gl.glMatrixMode(gl.GL_MODELVIEW);
        gl.glLoadIdentity();
&nbsp;
        <i>// viditelna oblast</i>
        gl.glViewport(0, 0, width, height);
&nbsp;
        <i>// vypnuti pameti hloubky pri vykreslovani</i>
        gl.glDisable(gl.GL_DEPTH_TEST);
&nbsp;
        <i>// barva pozadi framebufferu pro volani glClear()</i>
        gl.glClearColor (0.0f, 0.0f, 0.0f, 0.0f);
    }
&nbsp;
    <i>/**</i>
    <i> * Vykresleni trojuhelniku na urcenou pozici.</i>
    <i> */</i>
    private static void <strong>drawTriangle</strong>(GL gl, int x, int y)
    {
        gl.glBegin(gl.GL_TRIANGLES);
            gl.glColor3f(1.0f, 0.0f, 0.0f);   <i>// kazdy vertex bude vykresleny jinou barvou</i>
            gl.glVertex2i(x, y);
            gl.glColor3f(0.0f, 1.0f, 0.0f);
            gl.glVertex2i(x+100, y);
            gl.glColor3f(0.0f, 0.0f, 1.0f);
            gl.glVertex2i(x+50, y+80);
        gl.glEnd();
    }
&nbsp;
    <i>/**</i>
    <i> * Vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL.</i>
    <i> */</i>
    private static void <strong>drawScene</strong>(GL gl) {
        <i>// vymazani framebufferu</i>
        gl.glClear(gl.GL_COLOR_BUFFER_BIT);
&nbsp;
        gl.glPointSize(5.0f);                          <i>// velikost bodu je rovna peti pixelum</i>
        gl.glLineWidth(2.0f);                          <i>// tloustka usecek je rovna dvema pixelum</i>
        gl.glEnable(gl.GL_POINT_SMOOTH);               <i>// povoleni antialiasingu bodu</i>
        gl.glEnable(gl.GL_LINE_SMOOTH);                <i>// povoleni antialiasingu usecek</i>
        gl.glDisable(gl.GL_POLYGON_STIPPLE);           <i>// zakazat vzorek</i>
        gl.glPolygonMode(gl.GL_FRONT_AND_BACK, gl.GL_FILL);  <i>// vykreslovani vyplnenych trojuhelniku</i>
        drawTriangle(gl, 50, 50);
        gl.glPolygonMode(gl.GL_FRONT_AND_BACK, gl.GL_LINE);  <i>// vykreslovani pouze hran trojuhelniku</i>
        drawTriangle(gl, 180, 50);
        gl.glPolygonMode(gl.GL_FRONT_AND_BACK, gl.GL_POINT); <i>// vykreslovani pouze vrcholu trojuhelniku</i>
        drawTriangle(gl, 310, 50);
        gl.glPolygonMode(gl.GL_FRONT_AND_BACK, gl.GL_FILL);  <i>// vykreslovani vyplnenych trojuhelniku</i>
        gl.glFlush();                                  <i>// provedeni a vykresleni vsech zmen</i>
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni osmeho demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace video subsystemu knihovny SDL</i>
            SDLMain.init(SDLMain.SDL_INIT_VIDEO);
&nbsp;
            <i>// inicializace grafickeho rezimu ci otevreni okna pro vykreslovani</i>
            SDLSurface screen = initVideo();
&nbsp;
            <i>// inicializace celoobrazovkoveho grafickeho rezimu</i>
            GL gl = screen.getGL();
&nbsp;
            <i>// nastaveni transformacnich matic a barvy pozadi framebufferu</i>
            initScene(gl, GFX_WIDTH, GFX_HEIGHT);
&nbsp;
            <i>// vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL</i>
            drawScene(gl);
&nbsp;
            <i>// prepnuti predniho a zadniho bufferu</i>
            screen.glSwapBuffers();
&nbsp;
            <i>// ukonceni cele aplikace po peti sekundach</i>
            Thread.sleep(5000);
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
        <i>// zobrazit ziskane informace</i>
    }
&nbsp;
}
</pre>

<p>Skript pro pøeklad na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest16.java
</pre>

<p>Dávkový soubor pro pøeklad na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest16.java
</pre>

<p>Skript pro spu¹tìní na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
java -cp .:$SDL_JAVA_LIBS/sdljava.jar -Djava.library.path=$SDL_JAVA_LIBS SDLTest16
</pre>

<p>Dávkový soubor pro spu¹tìní na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest16
</pre>

<a href="http://i.iinfo.cz/images/607/java115-05.png"><img src="http://i.iinfo.cz/images/607/java115-05-prev.png" class="image-160733" width="360" height="270" alt="&#160;" /></a>
<p><i>Obrázek 5: Screenshot demonstraèního pøíkladu <strong>SDLTest16.java</strong>.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Repositáø se zdrojovými kódy v¹ech pìti dne¹ních demonstraèních pøíkladù</h2>

<p>V¹ech pìt dnes popsaných demonstraèních pøíkladù bylo spoleènì
s&nbsp;podpùrnými skripty urèenými pro jejich pøeklad a následné spu¹tìní
ulo¾eno do Mercurial repositáøe dostupného na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
Podobnì jako tomu bylo i v&nbsp;pøedchozích tøech dílech tohoto seriálu, i ke
dne¹ním pøíkladùm jsou pøilo¾eny skripty vyu¾itelné pro jejich pøeklad a
spu¹tìní. Navíc byly pøidány i skripty vyu¾itelné ve Windows:</p>

<table>
<tr><th> #</th><th>Zdrojový soubor/skript</th><th>Umístìní souboru v&nbsp;repositáøi</th></tr>
<tr><td> 1</td><td>SDLTest12.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest12/SDLTest12.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest12/SDLTest12.java</a></td></tr>
<tr><td> 2</td><td>SDLTest12_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest12/SDLTest12_compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest12/SDLTest12_compile.sh</a></td></tr>
<tr><td> 3</td><td>SDLTest12_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest12/SDLTest12_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest12/SDLTest12_compile_sys.sh</a></td></tr>
<tr><td> 4</td><td>SDLTest12_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest12/SDLTest12_run.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest12/SDLTest12_run.sh</a></td></tr>
<tr><td> 5</td><td>SDLTest12_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest12/SDLTest12_run_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest12/SDLTest12_run_sys.sh</a></td></tr>
<tr><td> 6</td><td>SDLTest12_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest12/SDLTest12_compile.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest12/SDLTest12_compile.bat</a></td></tr>
<tr><td> 7</td><td>SDLTest12_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest12/SDLTest12_run.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest12/SDLTest12_run.bat</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>SDLTest13.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest13/SDLTest13.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest13/SDLTest13.java</a></td></tr>
<tr><td> 9</td><td>SDLTest13_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest13/SDLTest13_compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest13/SDLTest13_compile.sh</a></td></tr>
<tr><td>10</td><td>SDLTest13_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest13/SDLTest13_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest13/SDLTest13_compile_sys.sh</a></td></tr>
<tr><td>11</td><td>SDLTest13_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest13/SDLTest13_run.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest13/SDLTest13_run.sh</a></td></tr>
<tr><td>12</td><td>SDLTest13_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest13/SDLTest13_run_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest13/SDLTest13_run_sys.sh</a></td></tr>
<tr><td>13</td><td>SDLTest13_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest13/SDLTest13_compile.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest13/SDLTest13_compile.bat</a></td></tr>
<tr><td>14</td><td>SDLTest13_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest13/SDLTest13_run.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest13/SDLTest13_run.bat</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>SDLTest14.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest14/SDLTest14.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest14/SDLTest14.java</a></td></tr>
<tr><td>16</td><td>SDLTest14_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest14/SDLTest14_compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest14/SDLTest14_compile.sh</a></td></tr>
<tr><td>17</td><td>SDLTest14_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest14/SDLTest14_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest14/SDLTest14_compile_sys.sh</a></td></tr>
<tr><td>18</td><td>SDLTest14_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest14/SDLTest14_run.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest14/SDLTest14_run.sh</a></td></tr>
<tr><td>19</td><td>SDLTest14_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest14/SDLTest14_run_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest14/SDLTest14_run_sys.sh</a></td></tr>
<tr><td>20</td><td>SDLTest14_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest14/SDLTest14_compile.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest14/SDLTest14_compile.bat</a></td></tr>
<tr><td>21</td><td>SDLTest14_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest14/SDLTest14_run.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest14/SDLTest14_run.bat</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>SDLTest15.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest15/SDLTest15.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest15/SDLTest15.java</a></td></tr>
<tr><td>23</td><td>SDLTest15_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest15/SDLTest15_compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest15/SDLTest15_compile.sh</a></td></tr>
<tr><td>24</td><td>SDLTest15_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest15/SDLTest15_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest15/SDLTest15_compile_sys.sh</a></td></tr>
<tr><td>25</td><td>SDLTest15_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest15/SDLTest15_run.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest15/SDLTest15_run.sh</a></td></tr>
<tr><td>26</td><td>SDLTest15_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest15/SDLTest15_run_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest15/SDLTest15_run_sys.sh</a></td></tr>
<tr><td>27</td><td>SDLTest15_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest15/SDLTest15_compile.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest15/SDLTest15_compile.bat</a></td></tr>
<tr><td>28</td><td>SDLTest15_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest15/SDLTest15_run.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest15/SDLTest15_run.bat</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>29</td><td>SDLTest16.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest16/SDLTest16.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest16/SDLTest16.java</a></td></tr>
<tr><td>30</td><td>SDLTest16_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest16/SDLTest16_compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest16/SDLTest16_compile.sh</a></td></tr>
<tr><td>31</td><td>SDLTest16_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest16/SDLTest16_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest16/SDLTest16_compile_sys.sh</a></td></tr>
<tr><td>32</td><td>SDLTest16_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest16/SDLTest16_run.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest16/SDLTest16_run.sh</a></td></tr>
<tr><td>33</td><td>SDLTest16_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest16/SDLTest16_run_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest16/SDLTest16_run_sys.sh</a></td></tr>
<tr><td>34</td><td>SDLTest16_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest16/SDLTest16_compile.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest16/SDLTest16_compile.bat</a></td></tr>
<tr><td>35</td><td>SDLTest16_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest16/SDLTest16_run.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/70d370f78ee0/sdljava/SDLTest16/SDLTest16_run.bat</a></td></tr>
</table>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>Root.cz: Seriál Grafická knihovna OpenGL<br />
<a href="http://www.root.cz/serialy/graficka-knihovna-opengl/">http://www.root.cz/serialy/graficka-knihovna-opengl/</a>
</li>

<li>Root.cz: Seriál Tvorba pøenositelných grafických aplikací vyu¾ívajících knihovnu GLUT<br />
<a href="http://www.root.cz/serialy/tvorba-prenositelnych-grafickych-aplikaci-vyuzivajicich-knihovnu-glut/">http://www.root.cz/serialy/tvorba-prenositelnych-grafickych-aplikaci-vyuzivajicich-knihovnu-glut/</a>
</li>

<li>SDL 1.2 Documentation: SDL_Surface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_PixelFormat<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlpixelformat.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlpixelformat.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_LockSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdllocksurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdllocksurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_UnlockSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlunlocksurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlunlocksurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_LoadBMP<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlloadbmp.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlloadbmp.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_SaveBMP<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsavebmp.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsavebmp.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_BlitSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlblitsurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlblitsurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_VideoInfo<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlvideoinfo.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlvideoinfo.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_GetVideoInfo<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlgetvideoinfo.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlgetvideoinfo.html</a>
</li>

<li>Class BufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferStrategy.html</a>
</li>

<li>Class Graphics<br />
<a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/Graphics.html">http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/Graphics.html</a>
</li>

<li>Double Buffering and Page Flipping<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html</a>
</li>

<li>BufferStrategy and BufferCapabilities<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/bufferstrategy.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/bufferstrategy.html</a>
</li>

<li>Java:Tutorials:Double Buffering<br />
<a href="http://content.gpwiki.org/index.php/Java:Tutorials:Double_Buffering">http://content.gpwiki.org/index.php/Java:Tutorials:Double_Buffering</a>
</li>

<li>Double buffer in standard Java AWT<br />
<a href="http://www.codeproject.com/Articles/2136/Double-buffer-in-standard-Java-AWT">http://www.codeproject.com/Articles/2136/Double-buffer-in-standard-Java-AWT</a>
</li>

<li>Java 2D: Hardware Accelerating - Part 1 - Volatile Images<br />
<a href="http://www.javalobby.org/forums/thread.jspa?threadID=16840&tstart=0">http://www.javalobby.org/forums/thread.jspa?threadID=16840&tstart=0</a>
</li>

<li>Java 2D: Hardware Accelerating - Part 2 - Buffer Strategies<br />
<a href="http://www.javalobby.org/java/forums/t16867.html">http://www.javalobby.org/java/forums/t16867.html</a>
</li>

<li>How does paintComponent work?<br />
<a href="http://stackoverflow.com/questions/15544549/how-does-paintcomponent-work">http://stackoverflow.com/questions/15544549/how-does-paintcomponent-work</a>
</li>

<li>A Swing Architecture Overview<br />
<a href="http://www.oracle.com/technetwork/java/architecture-142923.html">http://www.oracle.com/technetwork/java/architecture-142923.html</a>
</li>

<li>Class javax.swing.JComponent<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html</a>
</li>

<li>Class java.awt.Component<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html</a>
</li>

<li>Class java.awt.Component.BltBufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.BltBufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.BltBufferStrategy.html</a>
</li>

<li>Class java.awt.Component.FlipBufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.FlipBufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.FlipBufferStrategy.html</a>
</li>

<li>Metoda java.awt.Component.isDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html#isDoubleBuffered()">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html#isDoubleBuffered()</a>
</li>

<li>Metoda javax.swing.JComponent.isDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#isDoubleBuffered()">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#isDoubleBuffered()</a>
</li>

<li>Metoda javax.swing.JComponent.setDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#setDoubleBuffered(boolean)">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#setDoubleBuffered(boolean)</a>
</li>

<li>Javadoc - tøída GraphicsDevice<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html</a>
</li>

<li>Javadoc - tøída GraphicsEnvironment<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html</a>
</li>

<li>Javadoc - tøída GraphicsConfiguration<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html</a>
</li>

<li>Javadoc - tøída DisplayMode<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html">http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html</a>
</li>

<li>Lesson: Full-Screen Exclusive Mode API<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/">http://docs.oracle.com/javase/tutorial/extra/fullscreen/</a>
</li>

<li>Full-Screen Exclusive Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html</a>
</li>

<li>Display Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html</a>
</li>

<li>Using the Full-Screen Exclusive Mode API in Java<br />
<a href="http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm">http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>GC safe-point (or safepoint) and safe-region<br />
<a href="http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html">http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html</a>
</li>

<li>Safepoints in HotSpot JVM<br />
<a href="http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html">http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html</a>
</li>

<li>Java theory and practice: Synchronization optimizations in Mustang<br />
<a href="http://www.ibm.com/developerworks/java/library/j-jtp10185/">http://www.ibm.com/developerworks/java/library/j-jtp10185/</a>
</li>

<li>How to build hsdis<br />
<a href="http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README">http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README</a>
</li>

<li>Java SE 6 Performance White Paper<br />
<a href="http://www.oracle.com/technetwork/java/6-performance-137236.html">http://www.oracle.com/technetwork/java/6-performance-137236.html</a>
</li>

<li>Lukas Stadler's Blog<br />
<a href="http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html">http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html</a>
</li>

<li>How to build hsdis-amd64.dll and hsdis-i386.dll on Windows<br />
<a href="http://dropzone.nfshost.com/hsdis.htm">http://dropzone.nfshost.com/hsdis.htm</a>
</li>

<li>PrintAssembly<br />
<a href="https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly">https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly</a>
</li>

<li>The Java Virtual Machine Specification: 3.14. Synchronization<br />
<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14</a>
</li>

<li>The Java Virtual Machine Specification: 8.3.1.4. volatile Fields<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.4. Memory Model<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.7. Non-atomic Treatment of double and long<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7</a>
</li>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (pøed verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2014</small></p>
</body>
</html>

