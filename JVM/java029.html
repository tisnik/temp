<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM (12.èást - volání metod rozhraní, synchronizované bloky a kontrola typù za bìhu)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM (12.èást - volání metod rozhraní, synchronizované bloky a kontrola typù za bìhu)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o vlastnostech JVM dokonèíme popis instrukèního souboru virtuálního stroje Javy. Nejprve budou uvedeny informace o dnes ji¾ nepou¾ívaných instrukcích jsr a ret. Následnì se budeme zabývat pomìrnì vysokoúrovòovými instrukcemi urèenými pro volání metod rozhraní, vyhození výjimky, synchronizaci a kontrolu typù za bìhu (runtime check).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM (12.èást - volání metod rozhraní, synchronizované bloky a kontrola typù za bìhu)</a></p>
<p><a href="#k02">2. Instrukce <strong>jsr</strong>, <strong>jsr_w</strong> a <strong>ret</strong></a></p>
<p><a href="#k03">3. Problémy s&nbsp;instrukcemi <strong>jsr</strong>, <strong>jsr_w</strong> a <strong>ret</strong></a></p>
<p><a href="#k04">4. Instrukce <strong>invokeinterface</strong></a></p>
<p><a href="#k05">5. Demonstraèní pøíklad: rozdíl mezi voláním metody rozhraní a bì¾né virtuální metody</a></p>
<p><a href="#k06">6. Vyhození výjimky s&nbsp;vyu¾itím instrukce <strong>athrow</strong></a></p>
<p><a href="#k07">7. Synchronizace s&nbsp;vyu¾itím instrukcí <strong>monitorenter</strong> a <strong>monitorexit</strong></a></p>
<p><a href="#k08">8. Kontrola typù za bìhu: instrukce <strong>instanceof</strong> a <strong>checkcast</strong></a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM (12.èást - volání metod rozhraní, synchronizované bloky a kontrola typù za bìhu)</h2>

<p>V&nbsp;dne¹ní èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyce Java i o vlastnostech virtuálního stroje tohoto jazyka</a>
si popí¹eme v¹echny zbývající instrukce, které lze najít ve standardním
bajtkódu získaného pøekladem javovských tøíd, výètových typù èi rozhraní.
Prozatím tedy vynecháme ty instrukce, které se pou¾ívají v&nbsp;souvislosti
s&nbsp;dynamicky typovanými (skriptovacími) jazyky. V&nbsp;pøedchozích ¹esti
èástech tohoto seriálu [<a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-6-cast-instrukcni-soubor-virtualniho-stroje-javy/">1</a>][<a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-7-cast-dalsi-instrukce-zpracovavane-virtualnim-strojem-javy/">2</a>][<a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-8-cast-instrukce-urcene-pro-rizeni-behu-programu/">3</a>][<a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-9-cast-tajemstvi-instrukci-lookupswitch-a-tableswitch/">4</a>][<a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-10-cast-instrukce-pro-praci-s-tridami-a-objekty/">5</a>][<a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-11-cast-instrukce-pro-tvorbu-poli-a-pristup-k-prvkum-poli/">6</a>]
jsme si ji¾ vìt¹inu instrukcí JVM popsali, ov¹em je¹tì nám zbývá se zmínit o
deseti instrukcích slou¾ících pro rùzné úèely, napøíklad pro vyhození výjimky,
vstup a výstup ze synchronizovaného bloku, kontrolu typu (objektu) v&nbsp;dobì
bìhu programu (<i>runtime check</i>) atd.</p>

<p>Takté¾ jsme si prozatím nepopsali instrukce, které se v&nbsp;bajtkódu
vìt¹inou nevyskytují, a to pøedev¹ím z&nbsp;toho dùvodu, ¾e jejich pou¾ití je
z&nbsp;rùzných dùvodù problematické &ndash; to je pøípad instrukcí
<strong>jsr</strong>, <strong>jsr_w</strong> a <strong>ret</strong> popsaných
<a href="#k02">ve druhé kapitole</a>, s&nbsp;nimi¾ se ji¾ v&nbsp;bajtkódu
vytváøeném moderními implementacemi Javy (JDK6, JDK7) nesetkáme, i kdy¾
virtuální stroj Javy s&nbsp;tìmito instrukcemi umí pracovat.</p>

<p>Zaènìme v¹ak popisem nejjednodu¹¹í instrukce virtuálního stroje Javy. Jedná
se o instrukci pojmenovanou <strong>nop</strong>, kterou mù¾eme najít i
v&nbsp;instrukèních sadách reálných mikroprocesorù. Název instrukce
<strong>nop</strong> je vlastnì zkratkou vzniklou ze sousloví &bdquo;no
operation&ldquo;, proto¾e tato instrukce skuteènì nic nedìlá, pouze
v&nbsp;bajtkódu &bdquo;zabírá&ldquo; jeden bajt. V&nbsp;bajtkódu generovaném
pomocí pøekladaèe <strong>javac</strong> se s&nbsp;touto instrukcí vìt¹inou
nesetkáme, ale v&nbsp;pøípadì manipulace s&nbsp;bajtkódem, napøíklad
s&nbsp;vyu¾itím knihovny <i>ASM</i> mù¾e být instrukce <strong>nop</strong>
u¾iteèná.</p>

<p>Operaèní kód instrukce <strong>nop</strong> je snadno zapamatovatelný,
proto¾e se jedná o instrukci le¾ící na samotném zaèátku tabulky v¹ech
instrukcí, tj.&nbsp;její operaèní kód je roven 0x00:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Provádìná operace</th></tr>
<tr><td>0</td><td>nop</td><td>0x00</td><td>&times;</td><td>neprovede ¾ádnou operaci</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Instrukce <strong>jsr</strong>, <strong>jsr_w</strong> a <strong>ret</strong></h2>

<p>Instrukèní soubor virtuálního stroje Javy obsahuje i instrukce nazvané
<strong>jsr</strong> a <strong>ret</strong>. Instrukce <strong>jsr</strong>,
neboli volání subrutiny, existuje ve dvou variantách.
V&nbsp;&bdquo;krátké&ldquo; variantì <strong>jsr</strong> je za instrukèním
kódem uvedena relativní adresa (platná v&nbsp;rámci tìla metody) reprezentovaná
¹estnáctibitovým èíslem, zatímco &bdquo;dlouhá&ldquo; varianta
<strong>jsr_w</strong> pou¾ívá relativní 32bitovou adresu (opìt jde o adresu
relativní v&nbsp;rámci dané metody). Pou¾ití 32bitové adresy je v¹ak ve
skuteènosti zbyteèné, nebo» délka metod pøelo¾ených do bajtkódu je stejnì
dal¹ími okolnostmi omezena na 65535 bajtù. Zajímavé je, ¾e instrukce
<strong>ret</strong> takté¾ obsahuje parametr. Jedná se o index lokální
promìnné, která obsahuje adresu, na ní¾ se má øízení programu vrátit. Mù¾eme
zde tedy nalézt urèitou asymetrii (instrukce <strong>jsr</strong> toti¾ ukládá
návratovou adresu na zásobník operandù a nikoli do lokální promìnné), která
v¹ak byla do instrukèní sady zavedena naschvál, a to kvùli tomu, jakým zpùsobem
se mìly instrukce <strong>jsr</strong> a <strong>ret</strong> vyu¾ívat.
Operaèní kódy obou variant instrukce <strong>jsr</strong> i jediné varianty
instrukce <strong>ret</strong> jsou vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Provádìná operace</th></tr>
<tr><td>1</td><td>jsr</td><td>0xA8</td><td>highbyte, lowbyte</td><td>skok na relativní 16bitovou adresu ulo¾enou v&nbsp;highbyte a lowbyte</td></tr>
<tr><td>2</td><td>jsr_w</td><td>0xC9</td><td>byte1, byte2, byte3, byte4</td><td>skok na relativní 32bitovou adresu</td></tr>
<tr><td>3</td><td>ret</td><td>0xA9</td><td>index</td><td>skok na adresu zapsanou v&nbsp;lokální promìnné</td></tr>
</table>

<p>Plný název tìchto instrukcí &ndash; <i>jump to subroutine</i> a
<i>return</i> &ndash; sice mù¾e navozovat dojem, ¾e se jedná o instrukce
pou¾itelné pro volání funkcí èi metod (funkce = zjednodu¹enì øeèeno veøejná
statická metoda), ve skuteènosti tomu ale tak není, proto¾e instrukce
<strong>jsr</strong> a <strong>ret</strong> slou¾í, èi lépe øeèeno
v&nbsp;minulosti slou¾ily, pro skoky v&nbsp;rámci tìla jedné metody. Tyto
instrukce byly do JVM pøidány z&nbsp;toho dùvodu, aby bylo mo¾né opakující se
èásti kódu do bajtkódu zapsat pouze jednou. Ov¹em vzhledem k&nbsp;tomu, ¾e
pøekladaè prakticky neprovádí ¾ádnou optimalizaci bajtkódu (to by znemo¾nilo
pohodlné ladìní), vyu¾ívaly se tyto instrukce pouze pro zápis tìla bloku
<strong>finally</strong>. Dùvod je prostý &ndash; pøíkazy zapsané v&nbsp;bloku
<strong>finally</strong> se provedou v¾dy, tedy nezávisle na tom, zda dojde èi
nedojde k&nbsp;pøeru¹ení bìhu metody kvùli vzniklé výjimce, co¾ znamená, ¾e pøi
pøekladu do bajtkódu se vlastnì blok <strong>finally</strong>
(resp.&nbsp;pøíkazy v&nbsp;nìm uvedené) volá z&nbsp;více míst; jak po úspì¹ném
dokonèení v¹ech pøíkazù uvedených v&nbsp;bloku <strong>try</strong>, tak i po
vzniku výjimky a jejím zpracování v&nbsp;bloku <strong>catch</strong> (tìchto
blokù samozøejmì mù¾e existovat libovolné mno¾ství).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Problémy s&nbsp;instrukcemi <strong>jsr</strong>, <strong>jsr_w</strong> a <strong>ret</strong></h2>

<p>Podívejme se na jednoduchý demonstraèní pøíklad, v&nbsp;nìm¾ je
v&nbsp;metodì pojmenované <strong>tryFinally()</strong> pou¾it blok
<strong>try</strong> následovaný blokem <strong>finally</strong>. Touto
konstrukcí programátor naznaèuje, ¾e se metoda <strong>wrapItUp()</strong> má
zavolat v¾dy, nezávisle na tom, zda do¹lo ke vzniku výjimky èi nikoli:</p>

<pre>
class Test1 {
&nbsp;
    void tryFinally() {
        try {
            tryItOut();
        } finally {
            wrapItUp();
        }
    }
&nbsp;
    void tryItOut() {}
&nbsp;
    void wrapItUp() {}
&nbsp;
}
</pre>

<p>Star¹í verze JDK metodu <strong>tryFinally()</strong> pøelo¾ily následujícím
zpùsobem:</p>

<pre>
Method void tryFinally()
                            // zaèátek bloku try
   0    aload_0             // ulo¾it this (implicitní parametr) na zásobník operandù
                            // this tedy bude pøedán metodì tryItOut()
   1    invokevirtual #6    // zavolání metody tryItOut() uvnitø bloku try
   4    jsr 14              // zavolání bloku finally
   7    return              // konec bloku try a souèasnì i konec metody
&nbsp;
&nbsp;                           // blok zavolaný v pøípadì výskytu výjimky
   8    astore_1            // ulo¾it referenci na objekt reprezentující výjimku
   9    jsr 14              // zavolání bloku finally
  12    aload_1             // naèíst referenci na objekt reprezentující výjimku
  13    athrow              // skuteèné vyhození výjimky z metody
&nbsp;
&nbsp;                           // zaèátek bloku finally
  14    astore_2            // návratová adresa umístìná na TOS instrukcí jsr se ulo¾í do lokální promìnné
  15    aload_0             // ulo¾it this (implicitní parametr) na zásobník operandù
                            // this tedy bude pøedán metodì wrapItUp()
  16    invokevirtual #5    // zavolání metody wrapItUp() uvnitø bloku finally
  19    ret 2               // návrat z bloku finally (návratová adresa je naètena z promìnné #2)
&nbsp;
&nbsp;                           // tabulka pou¾ívaná pøi práci s výjimkami bude popsána v dal¹ích kapitolách
Exception table:
    From    To  Target      Type
    0       4       8           any
</pre>

<p>Pozdìji se v¹ak pøi¹lo na to, ¾e vìtvení bìhu programu s&nbsp;vyu¾itím skoku
do subrutin zvìt¹uje &ndash; a to mnohdy velmi podstatnì &ndash; stavový
prostor metody, který je kontrolován verifikátorem pøi naèítání bajtkódu. Tento
nedostatek mohl být zneu¾it k&nbsp;DOS útokùm, proto¾e virtuálnímu stroji mohl
být pøedán bajtkód se speciálnì upravenou metodou obsahující mnoho volání
subrutin. Z&nbsp;tohoto dùvodu se dnes ji¾ s&nbsp;instrukcemi
<strong>jsr</strong>, <strong>jsr_w</strong> a <strong>ret</strong> nesetkáme,
proto¾e moderní pøekladaèe vytvoøí následující batjkód:</p>

<pre>
void tryFinally();
  Code:
                            // zaèátek bloku try
   0    aload_0             // ulo¾it this (implicitní parametr) na zásobník operandù
                            // this tedy bude pøedán metodì tryItOut()
   1:   invokevirtual   #2; // zavolání metody tryItOut() uvnitø bloku try
&nbsp;                           // zde zaèíná první sekvence instrukcí odpovídající bloku finally
   4:   aload_0             // ulo¾it this (implicitní parametr) na zásobník operandù
                            // this tedy bude pøedán metodì wrapItUp()
   5:   invokevirtual   #3; // zavolání metody wrapItUp()
   8:   goto    18          // konec bloku try
&nbsp;
   11:  astore_1            // blok zavolaný v pøípadì výskytu výjimky
&nbsp;                           // zde zaèíná druhá sekvence instrukcí odpovídající bloku finally
   12:  aload_0             // ulo¾it this (implicitní parametr) na zásobník operandù
                            // this tedy bude pøedán metodì wrapItUp()
   13:  invokevirtual   #3; // zavolat metodu wrapItUp() - opakujeme se!
   16:  aload_1
   17:  athrow              // skuteèné vyhození výjimky z metody
&nbsp;
   18:  return              // konec metody
&nbsp;                           // tabulka pou¾ívaná pøi práci s výjimkami bude popsána v dal¹ích kapitolách
  Exception table:
   from   to  target type
     0     4    11   any
    11    12    11   any
</pre>

<p>Blok <strong>finally</strong> se tedy v&nbsp;bajtkódu mù¾e opakovat, ov¹em
stavový prostor metody je jednodu¹¹í a lépe verifikovatelný.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Instrukce <strong>invokeinterface</strong></h2>

<p>Dal¹í prozatím nepopsanou instrukcí je instrukce nazvaná
<strong>invokeinterface</strong>. Tato instrukce slou¾í k&nbsp;zavolání metody
rozhraní, co¾ sice mù¾e vypadat ponìkud nesmyslnì (v&nbsp;rozhraní mohou být
pouze hlavièky metod, ale ne jejich implementace), ale v&nbsp;øeèi tvùrcù
bajtkódu se tím myslí stav, kdy se volá metoda, její¾ konkrétní implementaci je
mo¾né rozeznat a¾ v&nbsp;èase bìhu programu (<i>runtime</i>). Instrukce
<strong>invokeinterface</strong> se èásteènì podobá ji¾ popsaným instrukcím
<strong>invokestatic</strong>, <strong>invokevirtual</strong> a
<strong>invokespecial</strong>, ov¹em s&nbsp;tím rozdílem, ¾e se za operaèním
kódem nachází jak dvojice bajtù obsahujících index do <i>constant poolu</i>,
tak i poèet argumentù volané metody. Ve skuteènosti se v¹ak jedná o údaj, který
se zde nachází z&nbsp;historických dùvodù a èistì teoreticky by nemusel být
uvádìn, proto¾e poèet argumentù metody lze získat i z&nbsp;její signatury
ulo¾ené na <i>constant poolu</i>. V&nbsp;následující tabulce jsou pro
pøehlednost uvedeny v¹echny ètyøi instrukce slou¾ící pro zavolání rùzných typù
metod.</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Provádìná operace</th></tr>
<tr><td>1</td><td>invokestatic   </td><td>0xB8</td><td>highbyte, lowbyte</td><td>zavolání statické metody s&nbsp;pøedáním parametrù této metodì</td></tr>
<tr><td>2</td><td>invokevirtual  </td><td>0xB6</td><td>highbyte, lowbyte</td><td>zavolání nestatické metody s&nbsp;pøedáním hodnoty <strong>this</strong> a v¹ech dal¹ích parametrù</td></tr>
<tr><td>3</td><td>invokespecial  </td><td>0xB7</td><td>highbyte, lowbyte</td><td>zavolání speciální metody, vìt¹inou konstruktoru</td></tr>
<tr><td>4</td><td>invokeinterface</td><td>0xB9</td><td>highbyte, lowbyte, count</td><td>zavolání metody deklarované v&nbsp;rozhraní, samozøejmì s&nbsp;pøedáním parametrù</td></tr>
</table>

<p>Operandy <i>highbyte</i> a <i>lowbyte</i> tvoøí ¹estnáctibitový index do
<i>constant poolu</i>. Záznam na daném indexu musí být typu
<i>FieldReference</i>, co¾ je pro pøipomenutí záznam obsahující odkaz na dal¹í
záznam typu <i>Class</i> (jméno tøídy èi rozhraní) a takté¾ na záznam typu
<i>Name and Type</i> (signatura metody èi atributu).</p>

<p>Podívejme se na pøípad, v&nbsp;nìm¾ pøekladaè musí pou¾ít metodu
<strong>invokeinterface</strong>, proto¾e v&nbsp;èase pøekladu nemù¾e
rozhodnout o tom, metoda jaké tøídy se bude ve skuteènosti volat &ndash; mù¾e
se jednat o metodu <strong>compareTo()</strong> jakékoli tøídy implementující
rozhraní <strong>Comparable</strong>:</p>

<pre>
class Test2 {
&nbsp;
    public int compare(Comparable a, Comparable b) {
        return a.compareTo(b);
    }
&nbsp;
}
</pre>

<p>Vygenerovaný bajtkód vypadá následovnì:</p>

<pre>
public int compare(java.lang.Comparable, java.lang.Comparable);
  Code:
   0:   aload_1                 // ulo¾it na zásobník první (viditelný) parametr metody - objekt a
   1:   aload_2                 // ulo¾it na zásobník druhý (viditelný) parametr metody - objekt b
   2:   invokeinterface #2,  2; // InterfaceMethod java/lang/Comparable.compareTo:(Ljava/lang/Object;)I
                                // první dvojka je index do constant poolu
                                // první dvojka je poèet parametrù metody (this, b)
   7:   ireturn                 // návrat z metody compare() s návratovou hodnotou
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Demonstraèní pøíklad: rozdíl mezi voláním metody rozhraní a bì¾né virtuální metody</h2>

<p>Z&nbsp;pøedchozího popisu nemusí být mo¾ná zcela zøejmé, ve kterých
pøípadech pou¾ije pøekladaè instrukci <strong>invokevirtual</strong> a kdy se
naopak musí uchýlit k&nbsp;instrukci <strong>invokeinterface</strong>. Uka¾me
si proto je¹tì jeden demonstraèní pøíklad, v&nbsp;nìm¾ budou pou¾ity obì
instrukce. Ve zdrojovém kódu tohoto pøíkladu je trojice metod, z&nbsp;nich¾
první pøidává prvek do obecné kolekce, tedy do v&nbsp;èase pøekladu neznámé
tøídy, o ní¾ je známo jen to, ¾e implementuje rozhraní
<strong>Collection</strong>. Ve druhé metodì se pøidává prvek do kolekce typu
seznam, tj.&nbsp;do v&nbsp;èase pøekladu neznámé tøídy implementující rozhraní
<strong>List</strong> a teprve v&nbsp;metodì tøetí se prvek pøidává do kolekce
reprezentované známou implementací &ndash; tøídou <strong>ArrayList</strong>.
V¹echny tøi metody v&nbsp;demonstraèním pøíkladu vypadají podobnì, ale jejich
bajtkód se bude li¹it:</p>

<pre>
import java.util.Collection;
import java.util.List;
import java.util.ArrayList;
&nbsp;
class Test3 {
&nbsp;
    public void addToCollection(Collection c, Object o) {
        c.add(o);
    }
&nbsp;
    public void addToList(List l, Object o) {
        l.add(o);
    }
&nbsp;
    public void addToArrayList(ArrayList l, Object o) {
        l.add(o);
    }
&nbsp;
}
</pre>

<p>V&nbsp;bajtkódu metody <strong>addCollection()</strong> se musí volat metoda
rozhraní, proto¾e pøekladaè nemù¾e v&nbsp;dobì pøekladu vìdìt, která konkrétní
tøída (resp.&nbsp;instance které tøídy) bude této metodì v&nbsp;èase bìhu
programu pøedána:</p>

<pre>
public void addToCollection(java.util.Collection, java.lang.Object);
  Code:
   0:   aload_1                 // ulo¾it první (viditelný) parametr metody na zásobník (obecná kolekce)
   1:   aload_2                 // ulo¾it druhý (viditelný) parametr metody na zásobník (prvek)
   2:   invokeinterface #2,  2; // metoda rozhraní java/util/Collection.add:(Ljava/lang/Object;)Z
                                // Z v signatuøe znaèí návratovou hodnotu typu boolean
   7:   pop                     // odstranit návratovou hodnotu vrácenou metodou Collection.add()
   8:   return                  // návrat z metody
</pre>

<p>Podobné je tomu i v&nbsp;bajtkódu metody <strong>addToList()</strong>:</p>

<pre>
public void addToList(java.util.List, java.lang.Object);
  Code:
   0:   aload_1                 // ulo¾it první (viditelný) parametr metody na zásobník (seznam)
   1:   aload_2                 // ulo¾it druhý (viditelný) parametr metody na zásobník (prvek)
   2:   invokeinterface #3,  2; // metoda rozhraní java/util/List.add:(Ljava/lang/Object;)Z
                                // Z v signatuøe znaèí návratovou hodnotu typu boolean
   7:   pop                     // odstranit návratovou hodnotu vrácenou metodou List.add()
   8:   return                  // návrat z metody
</pre>

<p>Teprve v&nbsp;metodì <strong>addToArrayList()</strong> ji¾ pøekladaè ví, ¾e
se bude volat metoda tøídy <strong>ArrayList</strong>, popø.&nbsp;metoda
potomka této tøídy. Proto mù¾e pou¾ít instrukci <strong>invokevirtual</strong>
a nikoli <strong>invokeinterface</strong>:</p>

<pre>
public void addToArrayList(java.util.ArrayList, java.lang.Object);
  Code:
   0:   aload_1                 // ulo¾it první (viditelný) parametr metody na zásobník (seznam)
   1:   aload_2                 // ulo¾it druhý (viditelný) parametr metody na zásobník (prvek)
   2:   invokevirtual   #4;     // metoda java/util/ArrayList.add:(Ljava/lang/Object;)Z
                                // Z v signatuøe znaèí návratovou hodnotu typu boolean
   5:   pop                     // odstranit návratovou hodnotu vrácenou metodou ArrayList.add()
   6:   return                  // návrat z metody
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Vyhození výjimky s&nbsp;vyu¾itím instrukce <strong>athrow</strong></h2>

<p>Dal¹í dùle¾itou instrukcí, kterou mù¾eme v&nbsp;bajtkódu èasto nalézt, je
instrukce nazvaná <strong>athrow</strong>. Tato instrukce slou¾í
k&nbsp;vyhození výjimky, pøièem¾ pøi zavolání této instrukce musí být reference
na objekt reprezentující výjimku ulo¾ena na vrcholu (<i>TOS</i>) zásobníku
operandù. Tato instrukce nemá ¾ádné operandy:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Provádìná operace</th></tr>
<tr><td>1</td><td>athrow</td><td>0xBF</td><td>&times;</td><td>vyhození výjimky</td></tr>
</table>

<p>Bajtkód ka¾dé metody navíc mù¾e obsahovat tabulku obsahující seznam výjimek,
které mohou nastat a adresy instrukcí, na nì¾ se provede skok ve chvíli, kdy
k&nbsp;dané výjimce skuteènì dojde. Pokud v¹ak tato tabulka není pøítomna,
popø.&nbsp;neobsahuje záznam s&nbsp;daným typem výjimky, je výjimka vyhozena
(<i>throw</i>) z&nbsp;metody a mù¾e být zachycena v&nbsp;nadøazených metodách,
opìt s&nbsp;vyu¾itím zmínìné tabulky.</p>

<p>Opìt se podívejme na jednoduchý demonstraèní pøíklad. Ten obsahuje dvì
metody, z&nbsp;nich¾ jedna vyvolá obecnou výjimku typu
<strong>RuntimeException()</strong>, její¾ objekt je zkonstruován
bezparametrickým konstruktorem, zatímco druhá metoda vyvolá tuté¾ výjimku,
ov¹em sestrojenou konstruktorem s&nbsp;parametrem typu
<strong>String</strong>:</p>

<pre>
class Test4 {
&nbsp;
    public static void throwRuntimeException1() {
        throw new RuntimeException();
    }
&nbsp;
    public static void throwRuntimeException2() {
        throw new RuntimeException("Hello world!");
    }
&nbsp;
}
</pre>

<p>Bajtkód první metody je velmi jednoduchý, proto¾e se v&nbsp;nìm nejdøíve
zavolá instrukce <strong>new</strong> pro vytvoøení instance tøídy
<strong>RuntimeException</strong> a následnì je zavolán její konstruktor.
Poslední instrukce výjimku skuteènì vyvolá:</p>

<pre>
public static void throwRuntimeException1();
  Code:
   0:   new     #2;         // vytvoøení instance tøídy java/lang/RuntimeException
   3:   dup                 // zachovat referenci pro instrukci athrow
   4:   invokespecial   #3; // konstruktor: metoda java/lang/RuntimeException."&lt;init&gt;":()V
   7:   athrow              // vyhození výjimky
</pre>

<p>Druhou metodu lze pova¾ovat za ponìkud kurióznì pojatou variantu na program
vypisující øetìzec &bdquo;Hello world!&ldquo;:</p>

<pre>
public static void throwRuntimeException2();
  Code:
   0:   new     #2;         // vytvoøení instance tøídy java/lang/RuntimeException
   3:   dup                 // zachovat referenci pro instrukci athrow
   4:   ldc     #4;         // konstantní øetìzec "Hello world!"
   6:   invokespecial   #5; // konstruktor: metoda java/lang/RuntimeException."&lt;init&gt;":(Ljava/lang/String;)V
   9:   athrow              // vyhození výjimky
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Synchronizace s&nbsp;vyu¾itím instrukcí <strong>monitorenter</strong> a <strong>monitorexit</strong></h2>

<p>Zajímavou dvojici instrukcí, kterou jsme si a¾ doposud nepopsali, tvoøí
instrukce nazvané <strong>monitorenter</strong> a <strong>monitorexit</strong>.
Jedná se o instrukce, které jsou vyu¾ívány zejména pro implementaci
synchronizovaných blokù, tj.&nbsp;blokù pøíkazù provádìných v&nbsp;daném
okam¾iku maximálnì jedním vláknem. Princip práce obou instrukcí je zalo¾en na
tom, ¾e ka¾dému objektu je ji¾ v&nbsp;dobì jeho konstrukce pøiøazen monitor
(tj.&nbsp;jeden z&nbsp;typù synchronizaèního primitiva), který mù¾e vlastnit
pouze (lepé øeèeno maximálnì) jedno vlákno. Instrukce
<strong>monitorenter</strong> slou¾í k&nbsp;získání tohoto monitoru s&nbsp;tím,
¾e v&nbsp;pøípadì, ¾e je ji¾ monitor daného objektu vlastnìn jiným vláknem,
bude souèasné vlákno èekat na uvolnìní tohoto monitoru, popø.&nbsp;pøi ¹patném
naprogramování dojde k&nbsp;oblíbenému deadlocku :-). Opaèný význam má
instrukce <strong>monitorexit</strong>, která naopak monitor uvolní a
zpøístupní tak dal¹ím pøípadnì èekajícím vláknùm. Obì popisované instrukce pøi
svém spu¹tìní oèekávají, ¾e se na vrcholu zásobníku operandù bude nacházet
reference na objekt, jeho¾ monitor se má pøi vstupu do synchronizovaného bloku
pou¾ít:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Provádìná operace</th></tr>
<tr><td>1</td><td>monitorenter</td><td>0xC2</td><td>&times;</td><td>vstup do synchronizovaného bloku (získání monitoru)</td></tr>
<tr><td>2</td><td>monitorexit</td><td>0xC3</td><td>&times;</td><td>výstup ze synchronizovaného bloky (uvolnìní monitoru)</td></tr>
</table>

<p>Opìt si uká¾eme jednoduchý demonstraèní pøíklad, který bude ilustrovat,
jakým zpùsobem se instrukce <strong>monitorenter</strong> a
<strong>monitorexit</strong> pou¾ívají. Zdrojový kód tohoto pøíkladu je
následující:</p>

<pre>
class Test5 {
&nbsp;
    Object zamek;
&nbsp;
    public int syncAdd(int x, int y) {
        synchronized(zamek) {
            return x + y;
        }
    }
&nbsp;
    public void syncHelloWorld() {
        synchronized(zamek) {
            System.out.println("Hello world!");
        }
    }
&nbsp;
}
</pre>

<p>Bajtkód metody <strong>syncAdd()</strong> obsahuje jak synchronizovaný blok,
tak i &ndash; co¾ je velmi dùle¾ité &ndash; sekvenci instrukcí, která zajistí
uvolnìní monitoru a to i pøi výskytu jakéhokoli typu výjimky:</p>

<pre>
public int syncAdd(int, int);
  Code:
   0:   aload_0             // ulo¾ení this na TOS
   1:   getfield        #2; // Field zamek:Ljava/lang/Object;
   4:   dup                 // duplikace reference na zámek
   5:   astore_3            // ulo¾ení zámku do lokální pomocné promìnné
&nbsp;
   6:   monitorenter        // vstup do synchronizovaného bloku
   7:   iload_1             // ulo¾ení prvního viditelného parametru metody na zásobník
   8:   iload_2             // ulo¾ení druhého viditelného parametru metody na zásobník
   9:   iadd                // souèet
   10:  aload_3             // naètení reference na zámek do TOS
   11:  monitorexit         // výstup ze synchronizovaného bloku
&nbsp;
   12:  ireturn             // návratová hodnota metody je nyní na TOS
&nbsp;
&nbsp;                           // blok instrukcí zavolaný v pøípadì výskytu výjimky
   13:  astore  4           // meziulo¾ení objektu reprezentujícího výjimku
   15:  aload_3             // naèíst zámek (referenci na zámek)
   16:  monitorexit         // výstup ze synchronizovaného bloku
   17:  aload   4           // reference na výjimku
   19:  athrow              // skuteèné vyhození výjimky
&nbsp;                           // blok instrukcí zavolaný v pøípadì výskytu výjimky
  Exception table:
   from   to  target type
     7    12    13   any
    13    17    13   any
</pre>

<p>I v&nbsp;pøípadì bajtkódu metody <strong>syncHelloWorld()</strong> je
pou¾ita sekvence instrukcí pro uvolnìní monitoru pøi výskytu výjimky:</p>

<pre>
public void syncHelloWorld();
  Code:
   0:   aload_0             // ulo¾ení this na TOS
   1:   getfield        #2; // Field zamek:Ljava/lang/Object;
   4:   dup                 // duplikace reference na zámek
   5:   astore_1            // ulo¾ení zámku do lokální pomocné promìnné
&nbsp;
   6:   monitorenter        // vstup do synchronizovaného bloku
   7:   getstatic       #3; // atribut java/lang/System.out:Ljava/io/PrintStream;
   10:  ldc     #4;         // konstantní øetìzec "Hello world!"
   12:  invokevirtual   #5; // metoda java/io/PrintStream.println:(Ljava/lang/String;)V
   15:  aload_1             // naètení reference na zámek do TOS
   16:  monitorexit         // výstup ze synchronizovaného bloku
&nbsp;
   17:  goto    25          // skok na pøíkaz return
&nbsp;
   20:  astore_2            // meziulo¾ení objektu reprezentujícího výjimku
   21:  aload_1             // naèíst zámek (referenci na zámek)
   22:  monitorexit         // výstup ze synchronizovaného bloku
   23:  aload_2             // reference na výjimku
   24:  athrow              // skuteèné vyhození výjimky
&nbsp;
   25:  return              // návrat z metody
&nbsp;
  Exception table:
   from   to  target type
     7    17    20   any
    20    23    20   any
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Kontrola typù za bìhu: instrukce <strong>instanceof</strong> a <strong>checkcast</strong></h2>

<p>Posledními dvìma instrukcemi, s&nbsp;nimi¾ se v&nbsp;dne¹ním èlánku
seznámíme, jsou instrukce nazvané <strong>instanceof</strong> a
<strong>checkcast</strong>. Instrukce <strong>instanceof</strong> je pøímým
protìj¹kem stejnojmenného operátoru nabízeného programovacím jazykem Java.
Tento operátor a tím pádem i tato instrukce slou¾í ke zji¹tìní, zda je objekt
instancí dané tøídy, pøièem¾ se tento test vìt¹inou provádí a¾ v&nbsp;èase bìhu
aplikace (JVM samozøejmì podporuje plnohodnotné RTTI &ndash; runtime type
identification). Výsledkem testu je pravdivostní hodnota <i>true</i>
popø.&nbsp;<i>false</i>. Druhá instrukce <strong>checkcast</strong> provádí
velmi podobný test, ov¹em s&nbsp;tím rozdílem, ¾e se namísto pravdivostní
hodnoty <i>false</i> v&nbsp;pøípadì neshody typu objektu vyvolá výjimka
<strong>ClassCastException</strong>. Pøekladaè tuto instrukci vkládá do
bajtkódu zejména tehdy, pokud programátor zapí¹e do zdrojového kódu
pøetypování, které nemusí být v¾dy typovì bezpeèné.</p>

<p>Operaèní kódy instrukcí <strong>instanceof</strong> a
<strong>checkcast</strong> jsou vypsány v&nbsp;tabulce umístìné pod tímto
odstavcem:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Provádìná operace</th></tr>
<tr><td>1</td><td>instanceof</td><td>0xC1</td><td>highbyte, lowbyte</td><td>test, zda je objekt zadaného typu</td></tr>
<tr><td>2</td><td>checkcast</td><td>0xC0</td><td>highbyte, lowbyte</td><td>kontrola, zda je objekt zadaného typu</td></tr>
</table>

<p>Podívejme se na demonstraèní pøíklad obsahující dvì metody. V&nbsp;první
metodì je pou¾it operátor <strong>instanceof</strong>, který se pøímo pøelo¾í
do stejnì pojmenované instrukce. Ve druhé metodì je parametr typu
<strong>Object</strong> pøetypován na objekt typu <strong>String</strong>, co¾
vede k&nbsp;tomu, ¾e pøekladaè vlo¾í do kódu nezbytné kontroly, zda lze toto
pøetypování skuteènì v&nbsp;èase bìhu programu provést:</p>

<pre>
class Test6 {
&nbsp;
    public boolean isString(Object o) {
        return o instanceof String;
    }
&nbsp;
    public String returnString(Object o) {
        return (String)o;
    }
&nbsp;
}
</pre>

<p>Bajtkód metody <strong>isString()</strong> vypadá následovnì:</p>

<pre>
public boolean isString(java.lang.Object);
  Code:
   0:   aload_1             // naètení prvního viditelného parametru metody
   1:   instanceof      #2; // test, zda se jedná o instanci java/lang/String
   4:   ireturn             // hodnota true/false je souèasnì i návratovou hodnotou metody
</pre>

<p>V&nbsp;bajtkódu metody <strong>returnString</strong> mù¾eme vidìt vlo¾enou
instrukci <strong>checkcast</strong>, její¾ zavolání mù¾e vyvolat výjimku typu
<strong>ClassCastException</strong> v&nbsp;pøípadì, ¾e metodì nebyl pøedán
objekt typu <strong>String</strong>:</p>

<pre>
public java.lang.String returnString(java.lang.Object);
  Code:
   0:   aload_1             // naètení prvního viditelného parametru metody
   1:   checkcast       #2; // kontrola, zda se jedná o instanci java/lang/String
   4:   areturn             // pokud nedo¹lo k výjimce, vrátí se reference na objekt ulo¾ený na TOS
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Java 6 try/finally compilation without jsr/ret<br />
<a href="http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html">http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Root.cz: Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM<br />
<a href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/</a></a>
</li>

<li>Root.cz: JamVM aneb alternativa k HotSpotu nejenom pro embedded zaøízení a chytré telefony<br />
<a href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>FindBugs<br />
<a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a>
</li>

<li>GNU Classpath<br />
<a href="www.gnu.org/s/classpath/">www.gnu.org/s/classpath/</a></li>

<li>Java VMs Compared<br />
<a href="http://bugblogger.com/java-vms-compared-160/">http://bugblogger.com/java-vms-compared-160/</a>
</li>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>CloseableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html">http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

