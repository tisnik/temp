<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - blending a textury s alfa kanálem v knihovnì SDLJava</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - blending a textury s alfa kanálem v knihovnì SDLJava</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Pøi práci s texturami je v mnoha aplikacích, a» ji¾ se jedná o 3D aplikace èi o hry s 2D grafikou, nutné vyu¾ívat textury, jejich¾ nìkteré texely jsou poloprùhledné èi zcela prùhledné. V dne¹ní èásti seriálu o programovacím jazyku Java si uká¾eme, jak lze (nejenom) pøi texturování vyu¾ívat takzvaný blending nabízený knihovnou SDLJava.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - blending a textury s&nbsp;alfa kanálem v&nbsp;knihovnì SDLJava</a></p>
<p><a href="#k02">2. Prùhlednost a poloprùhlednost fragmentù, alfa kanál a alfa blending</a></p>
<p><a href="#k03">3. Tvar míchací funkce (blending function) vyu¾ívané pøi vykreslování</a></p>
<p><a href="#k04">4. Význam konstant pøedávaných do metody <strong>GL.glBlendFunc()</strong></a></p>
<p><a href="#k05">5. Alfa blending provádìný pøi vykreslování trojrozmìrných scén</a></p>
<p><a href="#k06">6. Demonstraèní pøíklad <strong>SDLTest23</strong> &ndash; alfa blending u textury naètené ze souboru</a></p>
<p><a href="#k07">7. Demonstraèní pøíklad <strong>SDLTest24</strong> &ndash; nastavení poloprùhlednosti pøi vykreslování</a></p>
<p><a href="#k08">8. Demonstraèní pøíklad <strong>SDLTest25</strong> &ndash; ukázka dal¹ích mo¾ností blendingu</a></p>
<p><a href="#k09">9. Repositáø se zdrojovými kódy v¹ech ètyø dne¹ních demonstraèních pøíkladù</a></p>
<p><a href="#k10">10. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - blending a textury s&nbsp;alfa kanálem v&nbsp;knihovnì SDLJava</h2>

<p>Texturování popsané v&nbsp;pøedchozí èásti tohoto seriálu lze vyu¾ít pro
pokrytí stìn trojrozmìrných tìles nìjakým (bitmapovým) vzorkem, ov¹em stejná
technologie se v&nbsp;souèasnosti pou¾ívá napøíklad i u stále populárních 2D
her, zejména pro vyobrazení scrollujícího pozadí hry nebo pro vykreslení
pohybujících se <i>spritù</i>. V&nbsp;tìchto oblastech v¹ak ji¾ nevystaèíme se
zcela neprùhlednými texturami, ale je nutné nìjakým zpùsobem umìt pracovat
s&nbsp;texturami, v&nbsp;nich¾ jsou nìkteré texely prùhledné èi dokonce
poloprùhledné. Samotné grafické akcelerátory, grafická knihovna <i>OpenGL</i> a
zprostøedkovanì i javovská knihovna <i>SDLJava</i> samozøejmì práci
s&nbsp;texturami majícími (polo)prùhledné texely podporuje; celá tato
funkcionalita je souèástí obecnìj¹í technologie &ndash; <i>blendingu</i>
&ndash; pøi nìm¾ dochází k&nbsp;míchání barev pixelù ji¾ ulo¾ených do
framebufferu s&nbsp;právì vykreslovanými fragmenty. Podrobnosti o
<i>blendingu</i> a pøedev¹ím pak o blendingu vyu¾ívajícího alfa kanál si
popí¹eme v&nbsp;navazujících kapitolách.</p>

<p>V&nbsp;pøedchozích èástech tohoto seriálu jsme se ji¾ nìkolikrát zmínili o
barvovém prostoru pou¾ívaném pøi práci s&nbsp;barvami v&nbsp;knihovnì OpenGL.
Barvy jsou v&nbsp;tomto barvovém prostoru popsány pomocí tøí barvových slo¾ek
<strong>R</strong> (<i>Red</i>), <strong>G</strong> (<i>Green</i>) a
<strong>B</strong> (<i>Blue</i>). K&nbsp;tìmto tøem slo¾kám se èasto pøidává
je¹tì slo¾ka ètvrtá, nazývaná <strong>A</strong> (<i>Alfa</i>). Výsledný
barvový prostor se proto oznaèuje zkratkou RGBA. Pomocí alfa slo¾ky (nìkdy také
nazývané alfa-kanál) lze specifikovat míru prùhlednosti resp. naopak
neprùhlednosti vybraných objektù nebo jejich plo¹ek. Alfa slo¾ku lze také
nastavit samostatnì pro ka¾dý texel ve vykreslované textuøe, èeho¾ se pomìrnì
èasto vyu¾ívá pøi programování mnoha grafických efektù, napøíklad výbuchù. A
právì tuto vlastnost OpenGL vyu¾ijeme v&nbsp;dne¹ních demonstraèních
pøíkladech. Pøi spu¹tìní programu, který pou¾ívá pro vykreslování grafickou
knihovnu OpenGL, je vliv alfa slo¾ky na vykreslovanou plo¹ku zakázán. Proto,
pokud chceme programovat nìkteré grafické efekty, musíme pøed vykreslením
vhodnì nastavit re¾im míchání ji¾ nakreslené èásti scény s&nbsp;novì
vykreslovanými tìlesy.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Prùhlednost a poloprùhlednost fragmentù, alfa kanál a alfa blending</h2>

<p>Nejprve si pøipomeòme, ¾e takzvaný <i>fragment</i> je velmi jednoduchá
datová struktura (popisující diskrétní èást plochy) slo¾ená z&nbsp;barvy
pixelu, jeho prùhlednosti, vzdálenosti od pozorovatele (popø.&nbsp;pøevrácené
hodnoty vzdálenosti od pozorovatele) a pøípadných dal¹ích podpùrných informací.
<i>Framebuffer</i> je v&nbsp;podstatì pravidelnì uspoøádaná matice (rastr)
fragmentù, i kdy¾ vìt¹inou o framebufferu pøemý¹líme spí¹e jako o mno¾inì
nìkolika specializovaných bufferù (color-buffer, pamì» hloubky neboli Z-buffer,
stencil buffer, accumulation buffer jako¾to zobecnìná forma color-bufferu
atd.). Barvy fragmentù tvoøí ve framebufferu samostatný <i>color-buffer</i>,
který se posléze &ndash; po vykreslení celé scény &ndash; zobrazuje na
obrazovce. <i>Rasterizace</i> je proces, kterým se matematický model plo¹ky
(polygonu) pøevádí na jednotlivé fragmenty. Pøi pou¾ití <i>blendingu</i>
(tj.&nbsp;míchání barev) musíme nejdøíve specifikovat, jakým zpùsobem se budou
kombinovat právì vykreslované <i>fragmenty</i> s&nbsp;hodnotami ulo¾enými ve
<i>framebufferu</i>. Zpùsob míchání barvy ulo¾ené ve framebufferu a barvy
aktuálnì vykreslovaného fragmentu se øídí u¾ivatelem definovanou míchací funkci
(<i>blending function</i>). V&nbsp;této (velmi jednoduché) funkci vystupují
následující èleny:</p>

<ul>

<li>Zdroj (<i>source</i>) je fragment vzniklý rasterizací v&nbsp;právì bì¾ícím
rasterizaèním procesu (mù¾eme si pøedstavit napøíklad vykreslení trojúhelníku
postupnou rasterizací/diskretizací plochy trojúhelníku na jednotlivé
fragmenty).</li>

<li>Cíl (<i>destination</i>) je hodnota ji¾ døíve zapsaná do framebufferu, tj.
barva fragmentu, který ji¾ byl do framebufferu vykreslen døíve. Tato hodnota
bude v&nbsp;závislosti na aktuálnì nastavené blending funkci pøepsána nebo
jinak ovlivnìna.</li>

</ul>

<p>V&nbsp;knihovnì OpenGL lze stanovit koeficienty míchání pro ka¾dou barvovou
slo¾ku zvlá¹». Tak lze jednodu¹e dosáhnout na první pohled slo¾itých efektù,
napøíklad maskování jedné barvy apod.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Tvar míchací funkce (blending function) vyu¾ívané pøi vykreslování</h2>

<p>Míchací rovnici (pùvodnì ve vektorovém tvaru), která se pøi blendingu
pou¾ívá pro výpoèet nové barvy fragmentu, je mo¾né rozepsat do ètyø rovnic
odpovídajících barvovému modelu RGBA:</p>

<table>
<tr><td>R<sub>n</sub>=R<sub>s</sub>S<sub>r</sub>+R<sub>d</sub>D<sub>r</sub></td></tr>
<tr><td>G<sub>n</sub>=G<sub>s</sub>S<sub>g</sub>+G<sub>d</sub>D<sub>g</sub></td></tr>
<tr><td>B<sub>n</sub>=B<sub>s</sub>S<sub>b</sub>+B<sub>d</sub>D<sub>b</sub></td></tr>
<tr><td>A<sub>n</sub>=A<sub>s</sub>S<sub>a</sub>+A<sub>d</sub>D<sub>a</sub></td></tr>
</table>

<p>Význam jednotlivých èlenù pou¾itých v&nbsp;rovnicích je následující:</p>

<table>
<tr><th> #</th><th>Èlen</th><th>Význam</th></tr>
<tr><td> 1</td><td>R<sub>n</sub></td><td>novì vypoètená èervená barvová slo¾ka</td></tr>
<tr><td> 2</td><td>G<sub>n</sub></td><td>novì vypoètená zelená barvová slo¾ka</td></tr>
<tr><td> 3</td><td>B<sub>n</sub></td><td>novì vypoètená modrá barvová slo¾ka</td></tr>
<tr><td> 4</td><td>A<sub>n</sub></td><td>nová hodnota alfa slo¾ky</td></tr>
<tr><td> 5</td><td>R<sub>s</sub></td><td>èervená barvová slo¾ka zdrojového fragmentu</td></tr>
<tr><td> 6</td><td>G<sub>s</sub></td><td>zelená barvová slo¾ka zdrojového fragmentu</td></tr>
<tr><td> 7</td><td>B<sub>s</sub></td><td>modrá barvová slo¾ka zdrojového fragmentu</td></tr>
<tr><td> 8</td><td>A<sub>s</sub></td><td>alfa slo¾ka zdrojového fragmentu</td></tr>
<tr><td> 9</td><td>R<sub>d</sub></td><td>èervená barvová slo¾ka cílového fragmentu</td></tr>
<tr><td>10</td><td>G<sub>d</sub></td><td>zelená barvová slo¾ka cílového fragmentu</td></tr>
<tr><td>11</td><td>B<sub>d</sub></td><td>modrá barvová slo¾ka cílového fragmentu</td></tr>
<tr><td>12</td><td>A<sub>d</sub></td><td>alfa slo¾ka cílového fragmentu</td></tr>
<tr><td>13</td><td>S<sub>r</sub></td><td>míchací faktor pro èervenou barvu zdrojového fragmentu</td></tr>
<tr><td>14</td><td>S<sub>g</sub></td><td>míchací faktor pro zelenou barvu zdrojového fragmentu</td></tr>
<tr><td>15</td><td>S<sub>b</sub></td><td>míchací faktor pro modrou barvu zdrojového fragmentu</td></tr>
<tr><td>16</td><td>S<sub>a</sub></td><td>míchací faktor pro alfa slo¾ku zdrojového fragmentu</td></tr>
<tr><td>17</td><td>D<sub>r</sub></td><td>míchací faktor pro èervenou barvu cílového fragmentu</td></tr>
<tr><td>18</td><td>D<sub>g</sub></td><td>míchací faktor pro zelenou barvu cílového fragmentu</td></tr>
<tr><td>19</td><td>D<sub>b</sub></td><td>míchací faktor pro modrou barvu cílového fragmentu</td></tr>
<tr><td>20</td><td>D<sub>a</sub></td><td>míchací faktor pro alfa slo¾ku cílového fragmentu</td></tr>
</table>

<p>Pro praktické pou¾ití si v¹ak staèí zapamatovat význam jednotlivých písmen:
R-red, G-green, B-blue, A-alpha, n-new fragment, s-source fragment,
d-destination fragment.</p>

<p>Ve vý¹e uvedených rovnicích je nutné specifikovat míchací faktory
(koeficienty) S<sub>r</sub>, S<sub>g</sub>, S<sub>b</sub>, S<sub>a</sub>,
D<sub>r</sub>, D<sub>g</sub>, D<sub>b</sub> a D<sub>a</sub>, ostatní hodnoty
odpovídají barvám a alfa-slo¾kám zdrojových a cílových fragmentù. Koeficienty S
a D se nezadávají pøímo èíselnou hodnotou, proto¾e se mohou mìnit
v&nbsp;závislosti na barvách zdrojových a cílových fragmentù. Místo toho se
pou¾ívají symboly (symbolické konstanty), jejich¾ konkrétní hodnota se vypoète
automaticky pøi rasterizaci.</p> 



<p><a name="k04"></a></p>
<h2 id="k04">4. Význam konstant pøedávaných do metody <strong>GL.glBlendFunc()</strong></h2>

<p>Pro zadání míchacích koeficientù se pou¾ívá metoda:</p>

<pre>
org.gljava.opengl.GL.glBlendFunc(long sFactor, long dFactor);
</pre>

<p>První parametr <strong>sFactor</strong> urèuje zpùsob výpoètu míchacích
faktorù S<sub>r</sub>, S<sub>g</sub>, S<sub>b</sub> a S<sub>a</sub>, druhý
parametr <strong>dFactor</strong> pak zpùsob výpoètu faktorù D<sub>r</sub>,
D<sub>g</sub>, D<sub>b</sub> a D<sub>a</sub>.</p>

<p>Pro hodnoty, které lze do tìchto parametrù dosadit, platí základní
pravidla:</p>

<ol>

<li>Za <strong>sFactor</strong> popø. <strong>dFactor</strong> lze dosadit
nìkterou z&nbsp;konstant, které jsou pøeddefinovány v&nbsp;hlavièkovém souboru
<i>gl.h</i> (nativní rozhraní OpenGL) èi jako konstanty v&nbsp;rozhraní
<strong>org.gljava.opengl.GL</strong> (knihovna SDLJava).</li>

<li>Nìkteré z&nbsp;tìchto konstant lze zadat do obou parametrù. Jedná se
napøíklad o konstanty <i>GL_ZERO</i>, <i>GL_ONE</i> apod. Význam tìchto
konstant se samozøejmì li¹í podle toho, do kterého parametru jsou
dosazeny.</li>

<li>Nìkteré konstanty lze pou¾ít pouze pro parametr <strong>sFactor</strong>.
Jedná se napøíklad o konstanty <i>GL_DST_COLOR</i> nebo
<i>GL_ONE_MINUS_DST_COLOR</i>.</li>

<li>Nìkteré konstanty lze naopak pou¾ít pouze pro parametr
<strong>dFactor</strong>. Jde o konstanty <i>GL_SRC_COLOR</i>,
<i>GL_ONE_MINUS_SRC_COLOR</i> apod.</li>

</ol>

<p>V&nbsp;následující tabulce je vypsán význam míchacích faktorù, které mù¾eme
pou¾ít pro specifikaci koeficientù míchací rovnice. Ve sloupci <i>Název</i> je
jméno faktoru, tj.&nbsp;konstanta definovaná v&nbsp;rozhraní <i>GL</i>. Ve
sloupci <i>Pou¾ití</i> je oznaèeno, zda se mù¾e symbolická konstanta pou¾ít pro
dosazení do parametru <strong>sFactor</strong> (S), <strong>dFactor</strong>
(D) nebo do obou parametrù. Ve sloupci <i>Význam</i> jsou ve vektorovém tvaru
naznaèeny hodnoty zdrojových èi cílových koeficientù.</p>

<table>
<tr><th> #</th><th>Název</th><th>Pou¾ití</th><th>Význam</th></tr>
<tr><td> 1</td><td>GL_ZERO               </td><td>S nebo D</td><td>(0, 0, 0, 0)</td></tr>
<tr><td> 2</td><td>GL_ONE                </td><td>S nebo D</td><td>(1, 1, 1, 1)</td></tr>
<tr><td> 3</td><td>GL_DST_COLOR          </td><td>S       </td><td>(R<sub>d</sub>, G<sub>d</sub>, B<sub>d</sub>, A<sub>d</sub>)</td></tr>
<tr><td> 4</td><td>GL_SRC_COLOR          </td><td>D       </td><td>(R<sub>s</sub>, G<sub>s</sub>, B<sub>s</sub>, A<sub>s</sub>)</td></tr>
<tr><td> 5</td><td>GL_ONE_MINUS_DST_COLOR</td><td>S       </td><td>(1, 1, 1, 1)-(R<sub>d</sub>, G<sub>d</sub>, B<sub>d</sub>, A<sub>d</sub>)</td></tr>
<tr><td> 6</td><td>GL_ONE_MINUS_SRC_COLOR</td><td>D       </td><td>(1, 1, 1, 1)-(R<sub>s</sub>, G<sub>s</sub>, B<sub>s</sub>, A<sub>s</sub>)</td></tr>
<tr><td> 7</td><td>GL_SRC_ALPHA          </td><td>S nebo D</td><td>(A<sub>s</sub>, A<sub>s</sub>, A<sub>s</sub>, A<sub>s</sub>)</td></tr>
<tr><td> 8</td><td>GL_ONE_MINUS_SRC_ALPHA</td><td>S nebo D</td><td>(1, 1, 1, 1)-(A<sub>s</sub>, A<sub>s</sub>, A<sub>s</sub>, A<sub>s</sub>)</td></tr>
<tr><td> 9</td><td>GL_DST_ALPHA          </td><td>S nebo D</td><td>(A<sub>d</sub>, A<sub>d</sub>, A<sub>d</sub>, A<sub>d</sub>)</td></tr>
<tr><td>10</td><td>GL_ONE_MINUS_DST_ALPHA</td><td>S nebo D</td><td>(1, 1, 1, 1)-(A<sub>d</sub>, A<sub>d</sub>, A<sub>d</sub>, A<sub>d</sub>)</td></tr>
<tr><td>11</td><td>GL_SRC_ALPHA_SATURATE </td><td>S       </td><td>(f, f, f, 1) &nbsp; f=min(A<sub>s</sub>, 1-A<sub>d</sub>)</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. Alfa blending provádìný pøi vykreslování trojrozmìrných scén</h2>

<p>Pøi vykreslování prùhledných èi poloprùhledných trojrozmìrných tìles zále¾í
vizuální vzhled výsledné scény na zvoleném poøadí renderovaných objektù, na
rozdíl od neprùhledných tìles, kde jsou neviditelné (plnì èi èásteènì pøekryté)
stìny automaticky odstranìny díky testu na hloubku fragmentù provádìnou pøi
renderingu s&nbsp;vyu¾itím pamìti hloubky (nezávisle na poøadí vykreslování).
Jako první by se proto pøi práci s&nbsp;prùhlednými tìlesy mìly vykreslit
nejvzdálenìj¹í objekty (resp.&nbsp;pøesnìji øeèeno jejich stìny). Zejména
proto, ¾e øazení stìn podle vzdálenosti od pozorovatele je èasovì nároèné a
nejednoznaèné, je nutno metodu pro praktické vyu¾ití nepatrnì vylep¹it.
Doporuèuje se dodr¾ovat následující postup:</p>

<ul>

<li>Nejprve je zapotøebí pøi startu aplikace alokovat spoleènì s&nbsp;barvovými
buffery i pamì» hloubky (Z-buffer). V&nbsp;pøípadì pou¾ití knihovny
<i>SDLJava</i> se tato inicializace mù¾e provést automaticky pøi nastavování
grafického re¾imu.</li>

<li>Pamì» hloubky (Z-buffer) se musí nastavit do re¾imu ètení i zápisu
(read-write) hloubek fragmentù. Toho dosáhneme zavoláním pøíkazu
<i>GL.glDepthMask(true)</i>.</li>

<li>Po nastavení a povolení pamìti hloubky se vykreslí v¹echny neprùhledné
objekty, resp.&nbsp;pøesnìji øeèeno v¹echny neprùhledné stìny. Tyto objekty se
vzhledem k&nbsp;testu hloubky ka¾dého vykreslovaného fragmentu vykreslí
korektnì, tj.&nbsp;vzdálenìj¹í stìny budou korektnì pøekryty bli¾¹ími stìnami.
To je zapøíèinìno funkcí pamìti hloubky a komparátoru, který pro ka¾dý
vykreslovaný fragment testuje, zda je umístìn <strong>pøed</strong> nebo
<strong>za</strong> ji¾ vykresleným fragmentem, jeho¾ hloubka je
v&nbsp;hloubkovém bufferu ulo¾ena. Po vykreslení v¹ech neprùhledných objektù je
tedy v&nbsp;pamìti hloubky zapsána &bdquo;vý¹ková mapa&ldquo; nejbli¾¹ích
vykreslených fragmentù v&nbsp;ka¾dé buòce framebufferu (formát zde ulo¾ených
vzdáleností je vìt¹inou reprezentován èíslem 1/z, tak¾e by bylo pøesnìj¹í
mluvit o tzn. W-bufferu a ne o Z-bufferu, to je v¹ak pouze implementaèní
detail).</li>

<li>Pøed vykreslením prùhledných objektù se musí funkce pamìti hloubky nastavit
do re¾imu read-only, tj.&nbsp;hloubky fragmentù jsou z&nbsp;hloubkového bufferu
pouze èteny pøi komparaci (a tyto fragmenty jsou popø.&nbsp;odstranìny
z&nbsp;dal¹ího vykreslování). Zápis hodnot do hloubkového bufferu je zakázán,
proto¾e prùhledné objekty se musí vykreslit i tehdy, pokud jsou schovány za
dal¹ím prùhledným objektem a neprùhledné objekty se za objekty prùhlednými
nesmí vymazat. Nastavení hloubkového bufferu do re¾imu read-only provedeme
pøíkazem/metodou <i>GL.glDepthMask(false)</i>.</li>

<li>Dal¹ím krokem je programové seøazení prùhledných objektù podle jejich
hloubky (vzdálenosti) od pozorovatele. Objekty se poté vykreslí v&nbsp;tomto
poøadí, nejdøíve samozøejmì objekt nejvzdálenìj¹í.</li>

<li>Slo¾ité objekty, tj.&nbsp;objekty, jejich¾ plo¹ky jsou slo¾eny
z&nbsp;mnohoúhelníkù, je nìkdy nutné takzvanou tesselací rozdìlit na jednotlivé
trojúhelníky, jinak by mohly nastat vizuální chyby pøi pøekrývání objektù.
K&nbsp;tesselaci je mo¾né pou¾ít ji¾ existující knihovny (v&nbsp;pøípadì céèka
napøíklad knihovnu GLU).</li>

<li>Po vykreslení v¹ech prùhledných objektù se hloubkový buffer nastaví opìt do
re¾imu read-write (<i>GL.glDepthMask(true)</i>), aby se v&nbsp;pøí¹tím prùchodu
(snímku) neprùhledné objekty vykreslily korektnì.</li>

</ul>



<p><a name="k06"></a></p>
<h2 id="k06">6. Demonstraèní pøíklad <strong>SDLTest23</strong> &ndash; alfa blending u textury naètené ze souboru</h2>

<p>V&nbsp;dne¹ním prvním demonstraèním pøíkladu nazvaném
<strong>SDLTest23</strong> je ukázáno, jakým zpùsobem je mo¾né pou¾ít externí
rastrový obrázek s&nbsp;(polo)prùhlednými pixely jako texturu pou¾itou pøi
vykreslení vyplnìného ètyøúhelníku. Obrázek, který je zde pou¾itý, byl získán
z&nbsp;Wikipedie a obsahuje jak zcela neprùhledné pixely, tak i èásteènì èi
zcela prùhledné pixely. Aby bylo mo¾né korektnì ulo¾it celý alfa kanál
s&nbsp;osmibitovou hloubkou, byl vybrán formát PNG. Originální obrázek pou¾itý
ve funkci textury vypadá takto:</p>

<img src="http://i.iinfo.cz/images/575/c.png" class="image-162665" width="647" height="599" alt="&#160;" />

<p>Alfa kanál lze zobrazit následujícím zpùsobem (prùhlednost urèuje úroveò
¹edé, ¹achovnice znaèí zcela prùhledné pixely):</p>

<img src="http://i.iinfo.cz/images/193/c-alpha.png" class="image-162666" width="653" height="604" alt="&#160;" />

<p>Na detailu hrany písmena C je patrné, ¾e obrázek skuteènì obsahuje i
poloprùhledné pixely:</p>

<img src="http://i.iinfo.cz/images/291/c-zoom.png" class="image-162667" width="547" height="503" alt="&#160;" />

<p>Pov¹imnìte si, ¾e i pøesto, ¾e naètená textura obsahuje alfa kanál, je nutné
pøi texturování povolit blending, jinak by se výpoèet prùhlednosti neprovedl
korektnì (ostatnì sami si mù¾ete vyzkou¹et, co se stane, kdy¾ se následující
pøíkazy zakomentují):</p>

<pre>
<i>// nastaveni blendingu</i>
gl.glEnable(GL.GL_BLEND);
gl.glBlendFunc(GL.GL_SRC_ALPHA, GL.GL_ONE_MINUS_SRC_ALPHA);
</pre>

<p>Následuje výpis zdrojového kódu demonstraèního pøíkladu
<strong>SDLTest23</strong>:</p>

<pre>
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
&nbsp;
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.video.SDLPixelFormat;
import sdljava.video.SDLSurface;
import sdljava.video.SDLVideo;
&nbsp;
import org.gljava.opengl.GL;
import org.gljava.opengl.Texture;
import org.gljava.opengl.TextureFactory;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Dvacaty treti demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> *</i>
<i> * Texturovani, objekt typu Texture a alfa blending.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>SDLTest23</strong> {
&nbsp;
    <i>/**</i>
    <i> * Horizontalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_WIDTH</strong> = 600;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_HEIGHT</strong> = 600;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka vybraneho grafickeho rezimu.</i>
    <i> * (0 znamena automaticky vyber, ovsem lze samozrejme pouzit</i>
    <i> * i hodnoty 8, 16, 24 ci 32, podle vlastnosti graficke karty)</i>
    <i> */</i>
    private static final int <strong>GFX_BPP</strong> = 0;
&nbsp;
    <i>/**</i>
    <i> * Inicializace grafickeho rezimu ci otevreni okna pro vykreslovani.</i>
    <i> */</i>
    private static SDLSurface <strong>initVideo</strong>() throws SDLException {
        final long flags = SDLVideo.SDL_OPENGL | SDLVideo.SDL_DOUBLEBUF;
        return SDLVideo.setVideoMode(GFX_WIDTH, GFX_HEIGHT, GFX_BPP, flags);
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni transformacnich matic a barvy pozadi framebufferu.</i>
    <i> */</i>
    private static void <strong>initScene</strong>(GL gl, int width, int height) {
        <i>// nastaveni projekcni matice</i>
        gl.glMatrixMode(gl.GL_PROJECTION);
&nbsp;
        <i>// jednotkova matice</i>
        gl.glLoadIdentity();
&nbsp;
        <i>// mapovani abstraktnich souradnic do souradnic okna ci cele obrazovky</i>
        gl.glOrtho(0, width, height, 0, -1, 1);
&nbsp;
        <i>// nastaveni modelview matice</i>
        gl.glMatrixMode(gl.GL_MODELVIEW);
        gl.glLoadIdentity();
&nbsp;
        <i>// viditelna oblast</i>
        gl.glViewport(0, 0, width, height);
&nbsp;
        <i>// vypnuti pameti hloubky pri vykreslovani</i>
        gl.glDisable(gl.GL_DEPTH_TEST);
&nbsp;
        <i>// opakovani textury</i>
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_WRAP_S, gl.GL_REPEAT);
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_WRAP_T, gl.GL_REPEAT);
&nbsp;
        <i>// volba filtru</i>
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MAG_FILTER, gl.GL_NEAREST);
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MIN_FILTER, gl.GL_NEAREST);
&nbsp;
        <i>// vylepseni zobrazovani v pripade pouziti perspektivni projekce</i>
        gl.glHint(gl.GL_PERSPECTIVE_CORRECTION_HINT, gl.GL_NICEST);
&nbsp;
        <i>// barva pozadi framebufferu pro volani glClear()</i>
        gl.glClearColor (0.0f, 0.0f, 0.0f, 0.0f);
    }
&nbsp;
    <i>/**</i>
    <i> * Vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL.</i>
    <i> */</i>
    private static void <strong>drawScene</strong>(GL gl, Texture texture) {
&nbsp;
        <i>// vymazani framebufferu</i>
        gl.glClear(GL.GL_COLOR_BUFFER_BIT);
&nbsp;
        <i>// zakaz prace s texturami</i>
        gl.glDisable(gl.GL_TEXTURE_2D);
&nbsp;
        gl.glBegin(GL.GL_LINES);
            gl.glColor3f(1.0f, 0.0f, 0.0f);
            gl.glVertex2i(0, 0);
            gl.glColor3f(1.0f, 0.0f, 1.0f);
            gl.glVertex2i(600, 600);
            gl.glColor3f(0.0f, 1.0f, 0.0f);
            gl.glVertex2i(600, 0);
            gl.glColor3f(1.0f, 1.0f, 0.0f);
            gl.glVertex2i(0, 600);
        gl.glEnd();
&nbsp;
        <i>// povoleni prace s texturami</i>
        gl.glEnable(GL.GL_TEXTURE_2D);
&nbsp;
        <i>// nastaveni blendingu</i>
        gl.glEnable(GL.GL_BLEND);
        gl.glBlendFunc(GL.GL_SRC_ALPHA, GL.GL_ONE_MINUS_SRC_ALPHA);
&nbsp;
        texture.bind(gl);
&nbsp;
        <i>// vykresleni ctyruhelniku</i>
        gl.glBegin(GL.GL_QUADS);
            gl.glTexCoord2f(0.0f, 0.0f);
            gl.glVertex2i(100, 100);
            gl.glTexCoord2f(1.0f, 0.0f);
            gl.glVertex2i(500, 100);
            gl.glTexCoord2f(1.0f, 1.0f);
            gl.glVertex2i(500, 500);
            gl.glTexCoord2f(0.0f, 1.0f);
            gl.glVertex2i(100, 500);
        gl.glEnd();
&nbsp;
        gl.glFlush();                                        <i>// provedeni a vykresleni vsech zmen</i>
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni osmeho demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace video subsystemu knihovny SDL</i>
            SDLMain.init(SDLMain.SDL_INIT_VIDEO);
&nbsp;
            <i>// inicializace grafickeho rezimu ci otevreni okna pro vykreslovani</i>
            SDLSurface screen = initVideo();
&nbsp;
            <i>// inicializace celoobrazovkoveho grafickeho rezimu</i>
            GL gl = screen.getGL();
&nbsp;
            <i>// nastaveni transformacnich matic a barvy pozadi framebufferu</i>
            initScene(gl, GFX_WIDTH, GFX_HEIGHT);
&nbsp;
            <i>// nacteni textury</i>
            Texture texture = TextureFactory.getFactory().loadTexture(gl, "c.png");
&nbsp;
            <i>// vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL</i>
            drawScene(gl, texture);
&nbsp;
            <i>// prepnuti predniho a zadniho bufferu</i>
            screen.glSwapBuffers();
&nbsp;
            <i>// ukonceni cele aplikace po peti sekundach</i>
            Thread.sleep(5000);
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
        <i>// zobrazit ziskane informace</i>
    }
&nbsp;
}
</pre>

<p>Skript pro pøeklad na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest23.java
</pre>

<p>Dávkový soubor pro pøeklad na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest23.java
</pre>

<p>Skript pro spu¹tìní na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
java -cp .:$SDL_JAVA_LIBS/sdljava.jar -Djava.library.path=$SDL_JAVA_LIBS SDLTest23
</pre>

<p>Dávkový soubor pro spu¹tìní na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest23
</pre>

<img src="http://i.iinfo.cz/images/28/23.png" class="image-162662" width="600" height="600" alt="&#160;" />
<p><i>Obrázek 1: Scéna vykreslená po spu¹tìní demonstraèního pøíkladu
<strong>SDLTest23</strong>.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Demonstraèní pøíklad <strong>SDLTest24</strong> &ndash; nastavení poloprùhlednosti pøi vykreslování</h2>

<p>Jak jsme si ji¾ øekli v&nbsp;úvodních kapitolách, netýká se nastavení
prùhlednosti pouze texelù, z&nbsp;nich¾ se skládají textury, ale prùhlednost je
mo¾né nastavit i pøi vykreslování rùzných geometrických primitiv podporovaných
knihovnou <i>SDLJava</i>. V&nbsp;dne¹ním druhém demonstraèním pøíkladu je
ukázáno vyu¾ití metody <strong>GL.glColor4f()</strong> pro specifikaci barvy a
souèasnì i prùhlednosti pøi vykreslování ètvercù. V&nbsp;programové smyèce
umístìné do u¾ivatelské metody <strong>drawScene()</strong> je postupnì
vykreslen ètverec vyplnìný rùznými barvami, jeho¾ neprùhlednost je postupnì
nastavována na hodnoty 0%, 20%, 40%, 60%, 80% a 100%:</p>

<pre>
<i>// nastaveni blendingu</i>
gl.glEnable(GL.GL_BLEND);
gl.glBlendFunc(GL.GL_SRC_ALPHA, GL.GL_ONE_MINUS_SRC_ALPHA);
&nbsp;
float[][] colors = {
    {1.0f, 1.0f, 1.0f},
    {0.0f, 0.0f, 1.0f},
    {1.0f, 0.0f, 0.0f},
    {0.0f, 1.0f, 0.0f},
    {0.0f, 1.0f, 1.0f},
    {0.0f, 0.0f, 0.0f},
};
&nbsp;
<i>// vykresleni serie nekolika ctvercu ruznou barvou</i>
<i>// s ruznou pruhlednosti</i>
float alpha;
int x, y;
for (y = 0; y &lt; colors.length; y++) {
    for (x = 0, alpha = 0.0f; x &lt;= 500; x += 100, alpha += 0.2f) {
        drawSquare(gl, x, y*100, colors[y][0], colors[y][1], colors[y][2], alpha);
    }
}
</pre>

<p>Následuje výpis zdrojového kódu pøíkladu <strong>SDLTest24</strong>:</p>

<pre>
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
&nbsp;
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.video.SDLPixelFormat;
import sdljava.video.SDLSurface;
import sdljava.video.SDLVideo;
&nbsp;
import org.gljava.opengl.GL;
import org.gljava.opengl.Texture;
import org.gljava.opengl.TextureFactory;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Dvacaty ctvrty demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> *</i>
<i> * Alfa blending pri vykreslovani.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>SDLTest24</strong> {
&nbsp;
    <i>/**</i>
    <i> * Horizontalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_WIDTH</strong> = 600;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_HEIGHT</strong> = 600;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka vybraneho grafickeho rezimu.</i>
    <i> * (0 znamena automaticky vyber, ovsem lze samozrejme pouzit</i>
    <i> * i hodnoty 8, 16, 24 ci 32, podle vlastnosti graficke karty)</i>
    <i> */</i>
    private static final int <strong>GFX_BPP</strong> = 0;
&nbsp;
    <i>/**</i>
    <i> * Inicializace grafickeho rezimu ci otevreni okna pro vykreslovani.</i>
    <i> */</i>
    private static SDLSurface <strong>initVideo</strong>() throws SDLException {
        final long flags = SDLVideo.SDL_OPENGL | SDLVideo.SDL_DOUBLEBUF;
        return SDLVideo.setVideoMode(GFX_WIDTH, GFX_HEIGHT, GFX_BPP, flags);
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni transformacnich matic a barvy pozadi framebufferu.</i>
    <i> */</i>
    private static void <strong>initScene</strong>(GL gl, int width, int height) {
        <i>// nastaveni projekcni matice</i>
        gl.glMatrixMode(gl.GL_PROJECTION);
&nbsp;
        <i>// jednotkova matice</i>
        gl.glLoadIdentity();
&nbsp;
        <i>// mapovani abstraktnich souradnic do souradnic okna ci cele obrazovky</i>
        gl.glOrtho(0, width, height, 0, -1, 1);
&nbsp;
        <i>// nastaveni modelview matice</i>
        gl.glMatrixMode(gl.GL_MODELVIEW);
        gl.glLoadIdentity();
&nbsp;
        <i>// viditelna oblast</i>
        gl.glViewport(0, 0, width, height);
&nbsp;
        <i>// vypnuti pameti hloubky pri vykreslovani</i>
        gl.glDisable(gl.GL_DEPTH_TEST);
&nbsp;
        <i>// barva pozadi framebufferu pro volani glClear()</i>
        gl.glClearColor(1.0f, 1.0f, 1.0f, 0.0f);
    }
&nbsp;
    <i>/**</i>
    <i> * Vykresleni ctverce.</i>
    <i> */</i>
    private static void <strong>drawSquare</strong>(GL gl, int x, int y, float r, float g, float b, float a) {
        <i>// vykresleni ctyruhelniku</i>
        gl.glColor4f(r, g, b, a);
        gl.glBegin(GL.GL_QUADS);
            gl.glVertex2i(x+10, y+10);
            gl.glVertex2i(x+90, y+10);
            gl.glVertex2i(x+90, y+90);
            gl.glVertex2i(x+10, y+90);
        gl.glEnd();
    }
&nbsp;
    <i>/**</i>
    <i> * Vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL.</i>
    <i> */</i>
    private static void <strong>drawScene</strong>(GL gl) {
        <i>// vymazani framebufferu (bile pozadi)</i>
        gl.glClear(GL.GL_COLOR_BUFFER_BIT);
&nbsp;
        <i>// zakaz blendingu</i>
        gl.glDisable(GL.GL_BLEND);
&nbsp;
        <i>// vykresleni mrizky</i>
        gl.glColor3f(0.0f, 0.0f, 0.0f);
        gl.glBegin(GL.GL_LINES);
        for (int i=0; i &lt; GFX_WIDTH; i+=20) {
            gl.glVertex2i(i, 0);
            gl.glVertex2i(i, GFX_HEIGHT);
        }
        for (int i=0; i &lt; GFX_HEIGHT; i+=20) {
            gl.glVertex2i(0, i);
            gl.glVertex2i(GFX_WIDTH, i);
        }
        gl.glEnd();
&nbsp;
        <i>// nastaveni blendingu</i>
        gl.glEnable(GL.GL_BLEND);
        gl.glBlendFunc(GL.GL_SRC_ALPHA, GL.GL_ONE_MINUS_SRC_ALPHA);
&nbsp;
        float[][] colors = {
            {1.0f, 1.0f, 1.0f},
            {0.0f, 0.0f, 1.0f},
            {1.0f, 0.0f, 0.0f},
            {0.0f, 1.0f, 0.0f},
            {0.0f, 1.0f, 1.0f},
            {0.0f, 0.0f, 0.0f},
        };
&nbsp;
        <i>// vykresleni serie nekolika ctvercu ruznou barvou</i>
        <i>// s ruznou pruhlednosti</i>
        float alpha;
        int x, y;
        for (y = 0; y &lt; colors.length; y++) {
            for (x = 0, alpha = 0.0f; x &lt;= 500; x += 100, alpha += 0.2f) {
                drawSquare(gl, x, y*100, colors[y][0], colors[y][1], colors[y][2], alpha);
            }
        }
&nbsp;
        gl.glFlush();     <i> // provedeni a vykresleni vsech zmen</i>
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace video subsystemu knihovny SDL</i>
            SDLMain.init(SDLMain.SDL_INIT_VIDEO);
&nbsp;
            <i>// inicializace grafickeho rezimu ci otevreni okna pro vykreslovani</i>
            SDLSurface screen = initVideo();
&nbsp;
            <i>// inicializace celoobrazovkoveho grafickeho rezimu</i>
            GL gl = screen.getGL();
&nbsp;
            <i>// nastaveni transformacnich matic a barvy pozadi framebufferu</i>
            initScene(gl, GFX_WIDTH, GFX_HEIGHT);
&nbsp;
            <i>// vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL</i>
            drawScene(gl);
&nbsp;
            <i>// prepnuti predniho a zadniho bufferu</i>
            screen.glSwapBuffers();
&nbsp;
            <i>// ukonceni cele aplikace po peti sekundach</i>
            Thread.sleep(5000);
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
        <i>// zobrazit ziskane informace</i>
    }
&nbsp;
}
</pre>

<p>Skript pro pøeklad na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest24.java
</pre>

<p>Dávkový soubor pro pøeklad na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest24.java
</pre>

<p>Skript pro spu¹tìní na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
java -cp .:$SDL_JAVA_LIBS/sdljava.jar -Djava.library.path=$SDL_JAVA_LIBS SDLTest24
</pre>

<p>Dávkový soubor pro spu¹tìní na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest24
</pre>

<img src="http://i.iinfo.cz/images/186/24.png" class="image-162663" width="600" height="600" alt="&#160;" />
<p><i>Obrázek 1: Scéna vykreslená po spu¹tìní demonstraèního pøíkladu
<strong>SDLTest24</strong>.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Demonstraèní pøíklad <strong>SDLTest25</strong> &ndash; ukázka dal¹ích mo¾ností blendingu</h2>

<p>Dne¹ní tøetí a souèasnì i poslední demonstraèní pøíklad je implementován ve
tøídì s&nbsp;názvem <strong>SDLTest25</strong>. V&nbsp;tomto pøíkladu je ukázán
efekt vìt¹iny kombinací operátorù pøedávaných do metody
<strong>GL.glBlendFunc()</strong>. Celoèíselné konstanty odpovídající
operátorùm zdrojových fragmentù i fragmentù cílových jsou ulo¾eny ve dvojici
polí nazvaných <strong>sourceOperators</strong> a
<strong>destOperators</strong>:</p>

<pre>
long[] sourceOperators = {
    GL.GL_ZERO,
    GL.GL_ONE,
    GL.GL_DST_COLOR,
    GL.GL_ONE_MINUS_DST_COLOR,
    GL.GL_SRC_ALPHA,
    GL.GL_ONE_MINUS_SRC_ALPHA,
    GL.GL_DST_ALPHA,
    GL.GL_ONE_MINUS_DST_ALPHA
};
</pre>

<pre>
long[] destOperators = {
    GL.GL_ZERO,
    GL.GL_ONE,
    GL.GL_SRC_COLOR,
    GL.GL_ONE_MINUS_SRC_COLOR,
    GL.GL_SRC_ALPHA,
    GL.GL_ONE_MINUS_SRC_ALPHA,
    GL.GL_DST_ALPHA,
    GL.GL_ONE_MINUS_DST_ALPHA
};
</pre>

<p>Vzájemné kombinace tìchto operátorù jsou nastavovány ve vnoøené programové
smyèce:</p>

<pre>
<i>// vykresleni serie nekolika ctvercu ruznou barvou</i>
<i>// s ruznou pruhlednosti</i>
float alpha;
int x, y;
for (y = 0; y &lt; destOperators.length; y++) {
    for (x = 0; x &lt; sourceOperators.length; x++) {
        <i>// nastaveni blendingu</i>
        gl.glBlendFunc(sourceOperators[x], destOperators[y]);
        drawSquare(gl, x*100, y*100, 0.0f, 0.0f, 1.0f, 0.5f);
    }
}
</pre>

<p>Za pov¹imnutí stojí i zpùsob nastavení barvy pozadí framebufferu:</p>

<pre>
<i>// barva pozadi framebufferu pro volani glClear()</i>
gl.glClearColor(1.0f, 1.0f, 1.0f, 0.5f);
</pre>

<p>Úplný zdrojový kód demonstraèního pøíkladu <strong>SDLTest25</strong> má
tvar:</p>

<pre>
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
&nbsp;
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.video.SDLPixelFormat;
import sdljava.video.SDLSurface;
import sdljava.video.SDLVideo;
&nbsp;
import org.gljava.opengl.GL;
import org.gljava.opengl.Texture;
import org.gljava.opengl.TextureFactory;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Dvacaty paty demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> *</i>
<i> * Alfa blending pri vykreslovani.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>SDLTest25</strong> {
&nbsp;
    <i>/**</i>
    <i> * Horizontalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_WIDTH</strong> = 800;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_HEIGHT</strong> = 800;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka vybraneho grafickeho rezimu.</i>
    <i> * (0 znamena automaticky vyber, ovsem lze samozrejme pouzit</i>
    <i> * i hodnoty 8, 16, 24 ci 32, podle vlastnosti graficke karty)</i>
    <i> */</i>
    private static final int <strong>GFX_BPP</strong> = 0;
&nbsp;
    <i>/**</i>
    <i> * Inicializace grafickeho rezimu ci otevreni okna pro vykreslovani.</i>
    <i> */</i>
    private static SDLSurface <strong>initVideo</strong>() throws SDLException {
        final long flags = SDLVideo.SDL_OPENGL | SDLVideo.SDL_DOUBLEBUF;
        return SDLVideo.setVideoMode(GFX_WIDTH, GFX_HEIGHT, GFX_BPP, flags);
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni transformacnich matic a barvy pozadi framebufferu.</i>
    <i> */</i>
    private static void <strong>initScene</strong>(GL gl, int width, int height) {
        <i>// nastaveni projekcni matice</i>
        gl.glMatrixMode(gl.GL_PROJECTION);
&nbsp;
        <i>// jednotkova matice</i>
        gl.glLoadIdentity();
&nbsp;
        <i>// mapovani abstraktnich souradnic do souradnic okna ci cele obrazovky</i>
        gl.glOrtho(0, width, height, 0, -1, 1);
&nbsp;
        <i>// nastaveni modelview matice</i>
        gl.glMatrixMode(gl.GL_MODELVIEW);
        gl.glLoadIdentity();
&nbsp;
        <i>// viditelna oblast</i>
        gl.glViewport(0, 0, width, height);
&nbsp;
        <i>// vypnuti pameti hloubky pri vykreslovani</i>
        gl.glDisable(gl.GL_DEPTH_TEST);
&nbsp;
        <i>// barva pozadi framebufferu pro volani glClear()</i>
        gl.glClearColor(1.0f, 1.0f, 1.0f, 0.5f);
    }
&nbsp;
    <i>/**</i>
    <i> * Vykresleni ctverce.</i>
    <i> */</i>
    private static void <strong>drawSquare</strong>(GL gl, int x, int y, float r, float g, float b, float a) {
        <i>// vykresleni ctyruhelniku</i>
        gl.glColor4f(r, g, b, a);
        gl.glBegin(GL.GL_QUADS);
            gl.glVertex2i(x+10, y+10);
            gl.glVertex2i(x+90, y+10);
            gl.glVertex2i(x+90, y+90);
            gl.glVertex2i(x+10, y+90);
        gl.glEnd();
    }
&nbsp;
    <i>/**</i>
    <i> * Vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL.</i>
    <i> */</i>
    private static void <strong>drawScene</strong>(GL gl) {
        <i>// vymazani framebufferu (bile pozadi)</i>
        gl.glClear(GL.GL_COLOR_BUFFER_BIT);
&nbsp;
        <i>// zakaz blendingu</i>
        gl.glDisable(GL.GL_BLEND);
&nbsp;
        <i>// vykresleni mrizky</i>
        gl.glColor3f(0.0f, 0.0f, 0.0f);
        gl.glBegin(GL.GL_LINES);
        for (int i=0; i &lt; GFX_WIDTH; i+=20) {
            gl.glVertex2i(i, 0);
            gl.glVertex2i(i, GFX_HEIGHT);
        }
        for (int i=0; i &lt; GFX_HEIGHT; i+=20) {
            gl.glVertex2i(0, i);
            gl.glVertex2i(GFX_WIDTH, i);
        }
        gl.glEnd();
&nbsp;
        <i>// povoleni blendingu</i>
        gl.glEnable(GL.GL_BLEND);
&nbsp;
        long[] sourceOperators = {
            GL.GL_ZERO,
            GL.GL_ONE,
            GL.GL_DST_COLOR,
            GL.GL_ONE_MINUS_DST_COLOR,
            GL.GL_SRC_ALPHA,
            GL.GL_ONE_MINUS_SRC_ALPHA,
            GL.GL_DST_ALPHA,
            GL.GL_ONE_MINUS_DST_ALPHA
        };
        long[] destOperators = {
            GL.GL_ZERO,
            GL.GL_ONE,
            GL.GL_SRC_COLOR,
            GL.GL_ONE_MINUS_SRC_COLOR,
            GL.GL_SRC_ALPHA,
            GL.GL_ONE_MINUS_SRC_ALPHA,
            GL.GL_DST_ALPHA,
            GL.GL_ONE_MINUS_DST_ALPHA
        };
&nbsp;
        <i>// vykresleni serie nekolika ctvercu ruznou barvou</i>
        <i>// s ruznou pruhlednosti</i>
        float alpha;
        int x, y;
        for (y = 0; y &lt; destOperators.length; y++) {
            for (x = 0; x &lt; sourceOperators.length; x++) {
                <i>// nastaveni blendingu</i>
                gl.glBlendFunc(sourceOperators[x], destOperators[y]);
                drawSquare(gl, x*100, y*100, 0.0f, 0.0f, 1.0f, 0.5f);
            }
        }
&nbsp;
        gl.glFlush();     <i> // provedeni a vykresleni vsech zmen</i>
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace video subsystemu knihovny SDL</i>
            SDLMain.init(SDLMain.SDL_INIT_VIDEO);
&nbsp;
            <i>// inicializace grafickeho rezimu ci otevreni okna pro vykreslovani</i>
            SDLSurface screen = initVideo();
&nbsp;
            <i>// inicializace celoobrazovkoveho grafickeho rezimu</i>
            GL gl = screen.getGL();
&nbsp;
            <i>// nastaveni transformacnich matic a barvy pozadi framebufferu</i>
            initScene(gl, GFX_WIDTH, GFX_HEIGHT);
&nbsp;
            <i>// vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL</i>
            drawScene(gl);
&nbsp;
            <i>// prepnuti predniho a zadniho bufferu</i>
            screen.glSwapBuffers();
&nbsp;
            <i>// ukonceni cele aplikace po peti sekundach</i>
            Thread.sleep(5000);
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
        <i>// zobrazit ziskane informace</i>
    }
&nbsp;
}
</pre>

<p>Skript pro pøeklad na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest25.java
</pre>

<p>Dávkový soubor pro pøeklad na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest25.java
</pre>

<p>Skript pro spu¹tìní na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
java -cp .:$SDL_JAVA_LIBS/sdljava.jar -Djava.library.path=$SDL_JAVA_LIBS SDLTest25
</pre>

<p>Dávkový soubor pro spu¹tìní na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest25
</pre>

<a href="http://i.iinfo.cz/images/101/25.png"><img src="http://i.iinfo.cz/images/101/25-prev.png" class="image-162664" width="270" height="270" alt="&#160;" /></a>
<p><i>Obrázek 1: Scéna vykreslená po spu¹tìní demonstraèního pøíkladu
<strong>SDLTest25</strong>.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Repositáø se zdrojovými kódy v¹ech ètyø dne¹ních demonstraèních pøíkladù</h2>

<p>V¹echny ètyøi dnes popsané demonstraèní pøíklady byly spoleènì
s&nbsp;podpùrnými skripty urèenými pro jejich pøeklad a následné spu¹tìní
ulo¾eny do Mercurial repositáøe dostupného na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
Podobnì jako tomu bylo i v&nbsp;pøedchozích ¹esti dílech tohoto seriálu, i ke
dne¹ním pøíkladùm jsou pøilo¾eny skripty vyu¾itelné pro jejich pøeklad a
spu¹tìní. Navíc byly pøidány i skripty vyu¾itelné ve Windows:</p>

<table>
<tr><th> #</th><th>Zdrojový soubor/skript</th><th>Umístìní souboru v&nbsp;repositáøi</th></tr>
<tr><td> 1</td><td>SDLTest23.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest23/SDLTest23.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest23/SDLTest23.java</a></td></tr>
<tr><td> 2</td><td>SDLTest23_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest23/SDLTest23_compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest23/SDLTest23_compile.sh</a></td></tr>
<tr><td> 3</td><td>SDLTest23_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest23/SDLTest23_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest23/SDLTest23_compile_sys.sh</a></td></tr>
<tr><td> 4</td><td>SDLTest23_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest23/SDLTest23_run.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest23/SDLTest23_run.sh</a></td></tr>
<tr><td> 5</td><td>SDLTest23_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest23/SDLTest23_run_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest23/SDLTest23_run_sys.sh</a></td></tr>
<tr><td> 6</td><td>SDLTest23_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest23/SDLTest23_compile.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest23/SDLTest23_compile.bat</a></td></tr>
<tr><td> 7</td><td>SDLTest23_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest23/SDLTest23_run.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest23/SDLTest23_run.bat</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr> 
<tr><td> 8</td><td>SDLTest24.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest24/SDLTest24.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest24/SDLTest24.java</a></td></tr>
<tr><td> 9</td><td>SDLTest24_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest24/SDLTest24_compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest24/SDLTest24_compile.sh</a></td></tr>
<tr><td>10</td><td>SDLTest24_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest24/SDLTest24_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest24/SDLTest24_compile_sys.sh</a></td></tr>
<tr><td>11</td><td>SDLTest24_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest24/SDLTest24_run.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest24/SDLTest24_run.sh</a></td></tr>
<tr><td>12</td><td>SDLTest24_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest24/SDLTest24_run_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest24/SDLTest24_run_sys.sh</a></td></tr>
<tr><td>13</td><td>SDLTest24_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest24/SDLTest24_compile.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest24/SDLTest24_compile.bat</a></td></tr>
<tr><td>14</td><td>SDLTest24_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest24/SDLTest24_run.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest24/SDLTest24_run.bat</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr> 
<tr><td>15</td><td>SDLTest25.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest25/SDLTest25.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest25/SDLTest25.java</a></td></tr>
<tr><td>16</td><td>SDLTest25_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest25/SDLTest25_compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest25/SDLTest25_compile.sh</a></td></tr>
<tr><td>17</td><td>SDLTest25_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest25/SDLTest25_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest25/SDLTest25_compile_sys.sh</a></td></tr>
<tr><td>18</td><td>SDLTest25_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest25/SDLTest25_run.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest25/SDLTest25_run.sh</a></td></tr>
<tr><td>19</td><td>SDLTest25_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest25/SDLTest25_run_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest25/SDLTest25_run_sys.sh</a></td></tr>
<tr><td>20</td><td>SDLTest25_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest25/SDLTest25_compile.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest25/SDLTest25_compile.bat</a></td></tr>
<tr><td>21</td><td>SDLTest25_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest25/SDLTest25_run.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c0a962ff72e6/sdljava/SDLTest25/SDLTest25_run.bat</a></td></tr>
</table>



<p><a name="k10"></a></p>
<h2 id="k10">10. Odkazy na Internetu</h2>

<ol>

<li>glDrawArrays<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArrays.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArrays.xml</a>
</li>

<li>glDrawElements<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElements.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElements.xml</a>
</li>

<li>glDrawArraysInstanced<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArraysInstanced.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArraysInstanced.xml</a>
</li>

<li>glDrawElementsInstanced<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElementsInstanced.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElementsInstanced.xml</a>
</li>

<li>Root.cz: Seriál Grafická knihovna OpenGL<br />
<a href="http://www.root.cz/serialy/graficka-knihovna-opengl/">http://www.root.cz/serialy/graficka-knihovna-opengl/</a>
</li>

<li>Root.cz: Seriál Tvorba pøenositelných grafických aplikací vyu¾ívajících knihovnu GLUT<br />
<a href="http://www.root.cz/serialy/tvorba-prenositelnych-grafickych-aplikaci-vyuzivajicich-knihovnu-glut/">http://www.root.cz/serialy/tvorba-prenositelnych-grafickych-aplikaci-vyuzivajicich-knihovnu-glut/</a>
</li>

<li>Best Practices for Working with Vertex Data<br />
<a href="https://developer.apple.com/library/ios/documentation/3ddrawing/conceptual/opengles_programmingguide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html">https://developer.apple.com/library/ios/documentation/3ddrawing/conceptual/opengles_programmingguide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_Surface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_PixelFormat<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlpixelformat.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlpixelformat.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_LockSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdllocksurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdllocksurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_UnlockSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlunlocksurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlunlocksurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_LoadBMP<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlloadbmp.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlloadbmp.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_SaveBMP<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsavebmp.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsavebmp.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_BlitSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlblitsurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlblitsurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_VideoInfo<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlvideoinfo.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlvideoinfo.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_GetVideoInfo<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlgetvideoinfo.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlgetvideoinfo.html</a>
</li>

<li>Class BufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferStrategy.html</a>
</li>

<li>Class Graphics<br />
<a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/Graphics.html">http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/Graphics.html</a>
</li>

<li>Double Buffering and Page Flipping<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html</a>
</li>

<li>BufferStrategy and BufferCapabilities<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/bufferstrategy.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/bufferstrategy.html</a>
</li>

<li>Java:Tutorials:Double Buffering<br />
<a href="http://content.gpwiki.org/index.php/Java:Tutorials:Double_Buffering">http://content.gpwiki.org/index.php/Java:Tutorials:Double_Buffering</a>
</li>

<li>Double buffer in standard Java AWT<br />
<a href="http://www.codeproject.com/Articles/2136/Double-buffer-in-standard-Java-AWT">http://www.codeproject.com/Articles/2136/Double-buffer-in-standard-Java-AWT</a>
</li>

<li>Java 2D: Hardware Accelerating - Part 1 - Volatile Images<br />
<a href="http://www.javalobby.org/forums/thread.jspa?threadID=16840&tstart=0">http://www.javalobby.org/forums/thread.jspa?threadID=16840&tstart=0</a>
</li>

<li>Java 2D: Hardware Accelerating - Part 2 - Buffer Strategies<br />
<a href="http://www.javalobby.org/java/forums/t16867.html">http://www.javalobby.org/java/forums/t16867.html</a>
</li>

<li>How does paintComponent work?<br />
<a href="http://stackoverflow.com/questions/15544549/how-does-paintcomponent-work">http://stackoverflow.com/questions/15544549/how-does-paintcomponent-work</a>
</li>

<li>A Swing Architecture Overview<br />
<a href="http://www.oracle.com/technetwork/java/architecture-142923.html">http://www.oracle.com/technetwork/java/architecture-142923.html</a>
</li>

<li>Class javax.swing.JComponent<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html</a>
</li>

<li>Class java.awt.Component<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html</a>
</li>

<li>Class java.awt.Component.BltBufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.BltBufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.BltBufferStrategy.html</a>
</li>

<li>Class java.awt.Component.FlipBufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.FlipBufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.FlipBufferStrategy.html</a>
</li>

<li>Metoda java.awt.Component.isDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html#isDoubleBuffered()">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html#isDoubleBuffered()</a>
</li>

<li>Metoda javax.swing.JComponent.isDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#isDoubleBuffered()">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#isDoubleBuffered()</a>
</li>

<li>Metoda javax.swing.JComponent.setDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#setDoubleBuffered(boolean)">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#setDoubleBuffered(boolean)</a>
</li>

<li>Javadoc - tøída GraphicsDevice<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html</a>
</li>

<li>Javadoc - tøída GraphicsEnvironment<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html</a>
</li>

<li>Javadoc - tøída GraphicsConfiguration<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html</a>
</li>

<li>Javadoc - tøída DisplayMode<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html">http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html</a>
</li>

<li>Lesson: Full-Screen Exclusive Mode API<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/">http://docs.oracle.com/javase/tutorial/extra/fullscreen/</a>
</li>

<li>Full-Screen Exclusive Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html</a>
</li>

<li>Display Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html</a>
</li>

<li>Using the Full-Screen Exclusive Mode API in Java<br />
<a href="http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm">http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>GC safe-point (or safepoint) and safe-region<br />
<a href="http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html">http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html</a>
</li>

<li>Safepoints in HotSpot JVM<br />
<a href="http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html">http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html</a>
</li>

<li>Java theory and practice: Synchronization optimizations in Mustang<br />
<a href="http://www.ibm.com/developerworks/java/library/j-jtp10185/">http://www.ibm.com/developerworks/java/library/j-jtp10185/</a>
</li>

<li>How to build hsdis<br />
<a href="http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README">http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README</a>
</li>

<li>Java SE 6 Performance White Paper<br />
<a href="http://www.oracle.com/technetwork/java/6-performance-137236.html">http://www.oracle.com/technetwork/java/6-performance-137236.html</a>
</li>

<li>Lukas Stadler's Blog<br />
<a href="http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html">http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html</a>
</li>

<li>How to build hsdis-amd64.dll and hsdis-i386.dll on Windows<br />
<a href="http://dropzone.nfshost.com/hsdis.htm">http://dropzone.nfshost.com/hsdis.htm</a>
</li>

<li>PrintAssembly<br />
<a href="https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly">https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly</a>
</li>

<li>The Java Virtual Machine Specification: 3.14. Synchronization<br />
<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14</a>
</li>

<li>The Java Virtual Machine Specification: 8.3.1.4. volatile Fields<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.4. Memory Model<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.7. Non-atomic Treatment of double and long<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7</a>
</li>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (pøed verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2014</small></p>
</body>
</html>

