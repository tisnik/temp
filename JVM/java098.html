<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - základy optimalizace aplikací naprogramovaných v Javì (4)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - základy optimalizace aplikací naprogramovaných v Javì (4)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o virtuálním stroji Javy se budeme zabývat problematikou synchronizace a atomicity operací v javovských aplikacích. Mimo jiné si øekneme, jaké vá¾né problémy mù¾e zpùsobit pou¾ití atributù s modifikátorem "volatile" i zpùsob vyu¾ití takzvaných safe-pointù.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - základy optimalizace aplikací naprogramovaných v&nbsp;Javì (4)</a></p>
<p><a href="#k02">2. Atributy s&nbsp;modifikátorem <strong>volatile</strong></a></p>
<p><a href="#k03">3. Ukázkový pøíklad èíslo 1 &ndash; pou¾ití atributù typu <strong>volatile int</strong></a></p>
<p><a href="#k04">4. Výsledky bìhu prvního demonstraèního pøíkladu</a></p>
<p><a href="#k05">5. Ukázkový pøíklad èíslo 2 &ndash; pou¾ití atributù typu <strong>volatile long</strong></a></p>
<p><a href="#k06">6. Vnitøní synchronizace: technologie safe-pointù</a></p>
<p><a href="#k07">7. Princip práce safe-pointù v&nbsp;souèasných virtuálních strojích</a></p>
<p><a href="#k08">8. Obsah následující èásti seriálu</a></p>
<p><a href="#k09">9. Repositáø se zdrojovými kódy v¹ech demonstraèních i testovacích pøíkladù</a></p>
<p><a href="#k10">10. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - základy optimalizace aplikací naprogramovaných v&nbsp;Javì (4)</h2>

<p>V&nbsp;dne¹ní èásti seriálu o programovacím jazyce Java i o virtuálním
stroji Javy si øekneme, jakými zpùsoby je zaji¹tìna atomicita nìkterých operací
a takté¾ se zmíníme o tom, jak je implementována synchronizace
v&nbsp;javovských aplikacích. Nebudeme se v¹ak prozatím do podrobností zabývat
&bdquo;explicitní&ldquo; synchronizací s&nbsp;vyu¾itím synchronizovaných metod
a synchronizovaných metod, ale ponìkud ménì viditelnou, ov¹em velmi významnou
technologií &ndash; jedná se o takzvané <i>safe-pointy</i>, které jsou
pou¾ívány jak interpretrem Javy, tak i JIT pøekladaèi typu klient a server.</p>

<p>Nejprve si pro úplnost øeknìme, jakými zpùsoby je vùbec mo¾né zajistit
synchronizaci v&nbsp;aplikacích naprogramovaných v&nbsp;Javì. Pravdìpodobnì
nejznámìj¹í zpùsob spoèívá ve vyu¾ití ji¾ zmínìných synchronizovaných metod a
synchronizovaných blokù. V&nbsp;pøípadì synchronizovaných blokù se pøi pøekladu
do bajtkódu generují instrukce <strong>monitorenter</strong> a
<strong>monitorexit</strong>, jejich¾ význam a implementaci si popí¹eme pøí¹tì.
Pro synchronizované metody pøipravuje a obhospodaøuje pøíslu¹ný zámek
(<i>lock</i>) samotný JVM (to, ¾e je metoda synchronizována, je oznaèeno
jednobitovým pøíznakem v&nbsp;bajtkódu).</p>

<p>Dal¹í mo¾nost zaji¹tìní synchronizace spoèívá ve vyu¾ití rozhraní a tøíd
z&nbsp;balíèku <strong>java.util.concurrent.locks</strong>, zatímco o zaji¹tìní
atomicity vybraných operací (co¾ se synchronizací velmi úzce souvisí) se
starají rozhraní a tøídy, které lze nalézt v&nbsp;balíèku
<strong>java.util.concurrent.atomic</strong>. Programovací jazyk Java navíc
obsahuje i podporu pro modifikátor <strong>volatile</strong> slou¾ící
k&nbsp;deklaraci volatilních atributù (ne v¹ak ji¾ parametrù ani lokálních
promìnných), s&nbsp;nimi¾ se internì pracuje znaènì rozdílným zpùsobem, ne¾
s&nbsp;nevolatilními (tj.&nbsp;vlastnì &bdquo;normálními&ldquo;) atributy.
S&nbsp;pou¾itím atributù s&nbsp;modifikátorem <strong>volatile</strong> souvisí
i nìkolik na první pohled mo¾ná ne zcela zøejmých problémù, které si popí¹eme
v&nbsp;následujících pìti kapitolách.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Atributy s&nbsp;modifikátorem <strong>volatile</strong></h2>

<p>Práce s&nbsp;volatilními atributy je problematická z&nbsp;toho dùvodu, ¾e
ètení i zápis tìchto atributù musí být proveden atomicky, a to za v¹ech
okolností. To znamená, ¾e pøi zápisu nové hodnoty do volatilního atributu by
tuto hodnotu mìly posléze naèíst v¹echna ostatní vlákna. Zdánlivì se tedy o
¾ádný problém nejedná, ve skuteènosti zde v¹ak mù¾eme nalézt hned dvì
problematická místa.</p>

<p>Prvním z&nbsp;nich je zaji¹tìní atomicity ètení a zápisu atributù
s&nbsp;bitovou ¹íøkou 64 bitù na 32bitových platformách. Zatímco bì¾ný atribut
typu <strong>long</strong> èi <strong>double</strong> mù¾e být velmi snadno
pøeèten ve dvou krocích, u atributù volatilních je nutné zajistit pou¾ití
64bitových registrù &ndash; na souèasných mikroprocesorech se jedná o instrukce
SSE2 pracující s&nbsp;registry XMM0 a¾ XMM7 (konkrétnì se pro pøenos dat
z&nbsp;pamìti do XMMx èi naopak pou¾ívá instrukce <strong>movsd</strong>,
s&nbsp;ní¾ jsme se ostatnì ji¾ seznámili minule). Na star¹ích mikroprocesorech
se pou¾ívají registry matematického koprocesoru a instrukce
<strong>fild*</strong> a <strong>fist*</strong> (platí pro uniprocesorové
poèítaèe, zatímco u poèítaèù s&nbsp;více jádry je ji¾ nutné pou¾ít lock).</p>

<p>Druhý problém související s&nbsp;volatilními atributy spoèívá v&nbsp;tom, ¾e
zmìna hodnoty tìchto atributù musí být viditelná i pro dal¹í vlákna, co¾
znamená nutnost synchronizace vyrovnávacích pamìtí (cache) jednotlivých
mikroprocesorù èi procesorových jader. Navíc je nutné, aby ostatní vlákna
vidìla <i>postupnou zmìnu</i> hodnoty volatilního atributu pøesnì v&nbsp;tom
poøadí, v&nbsp;jakém ke zmìnì do¹lo. To ponìkud omezuje mo¾nosti optimalizací
pøi JIT pøekladu; nové hodnoty volatilních atributù se ihned ukládají do pamìti
a na mnoha architekturách (vèetnì x86) se pou¾ívají pamì»ové bariéry
(implementované napøíklad instrukcí pro ètení pamìti, u ní¾ je uveden prefix
<strong>lock</strong>.</p>

<p>Dùle¾itá poznámka: u volatilních atributù je zaji¹tìna pouze atomicita ètení
a zápisu, nikoli ji¾ dal¹ích slo¾itìj¹ích operací. Napøíklad u atributu
<strong>volatile long x</strong> není a nemù¾e být zaji¹tìno, ¾e operace
<strong>x++</strong> probìhne atomicky &ndash; naopak, dvì soubì¾ná vlákna si
mohou navzájem pøepsat své výsledky. Nicménì by se nikdy nemìlo stát, ¾e by pøi
operaci <strong>x=0x0000000000000000; x=0xffffffffffffffff</strong> nìjaké
dal¹í vlákno pøeèetlo hodnotu 0x00000000ffffffff èi 0xffffffff00000000, a to i
na 32bitových architekturách (u nevolatilních atributù to v¹ak velmi
pravdìpodobnì nastane :-).</p>

<p>Druhá poznámka: atomicita ètení a zápisu volatilních atributù je teoreticky
zaji¹tìna od Javy 5.0, ve skuteènosti v¹ak nìkteré verze Javy v&nbsp;tomto
ohledu pracovaly chybnì. Nicménì v&nbsp;Javì 7 by ji¾ v¹e mìlo být opraveno
podle specifikace.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Ukázkový pøíklad èíslo 1 &ndash; pou¾ití atributù typu <strong>volatile int</strong></h2>

<p>Podívejme se nyní na velmi jednoduchý ukázkový pøíklad, v&nbsp;nìm¾ je
pou¾ita tøída obsahující nevolatilní celoèíselný atribut <strong>x</strong> a
volatilní celoèíselný atribut <strong>y</strong>. První atribut je postupnì
zvy¹ován v&nbsp;programové smyèce implementované v&nbsp;metodì
<strong>VolatileTest1.testX()</strong>, druhý atribut je postupnì zvy¹ován
v&nbsp;metodì <strong>VolatileTest2.testY()</strong>. Zaznamenává se celkový
èas bìhu první i druhé testovací metody tohoto benchmarku:</p>

<pre>
public class <strong>VolatileTest1</strong> {
    private final static int <strong>ITERATIONS</strong> = 1000000;
&nbsp;
    public int x;
    public volatile int y;
&nbsp;
<i>    // test s nevolatilnim atributem</i>
    private void <strong>testX</strong>() {
        x = 0;
        for (int i=0; i&lt;ITERATIONS; i++) {
            x += 1;
        }
    }
&nbsp;
<i>    // test s volatilnim atributem</i>
    private void <strong>testY</strong>() {
        y = 0;
        for (int i=0; i&lt;ITERATIONS; i++) {
            y += 1;
        }
    }
&nbsp;
    public static void <strong>main</strong>(String[] args) {
        VolatileTest1 test = new VolatileTest1();
        long t1, t2, delta_t;
        long sumTestX=0, sumTestY=0;
&nbsp;
<i>        // provest zadany pocet testu</i>
        for (int i = 0; i &lt; 10; i++) {
<i>            // provest test a zmerit cas behu testu</i>
            t1 = System.nanoTime();
            test.testX();
            t2 = System.nanoTime();
            delta_t = t2 - t1;
            sumTestX += delta_t;
&nbsp;
<i>            // vypis casu pro jeden test</i>
            System.out.format("Round #%2d testX() time: %,12d ns\n", i, delta_t);
&nbsp;
<i>            // provest test a zmerit cas behu testu</i>
            t1 = System.nanoTime();
            test.testY();
            t2 = System.nanoTime();
            delta_t = t2 - t1;
            sumTestY += delta_t;
&nbsp;
<i>            // vypis casu pro jeden test</i>
            System.out.format("Round #%2d testY() time: %,12d ns\n", i, delta_t);
        }
&nbsp;
<i>        // vypis kumulativniho casu</i>
        System.out.format("Cumulative time for testX(): %,12d ns\n", sumTestX);
        System.out.format("Cumulative time for testY(): %,12d ns\n", sumTestY);
    }
&nbsp;
}
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Výsledky bìhu prvního demonstraèního pøíkladu</h2>

<p>Nyní si zkusíme demonstraèní pøíklad popsaný <a href="#k03">v&nbsp;pøedchozí
kapitole</a> spustit na poèítaèi s&nbsp;jedním mikroprocesorem (Pentium M) a
pøitom pou¾ijeme pøepínaè <strong>-client</strong>:</p>

<pre>
Round # 0 testX() time:    7 304 001 ns
Round # 0 testY() time:    9 380 523 ns
Round # 1 testX() time:    7 408 764 ns
Round # 1 testY() time:    9 173 512 ns
Round # 2 testX() time:    7 637 004 ns
Round # 2 testY() time:    7 637 005 ns
Round # 3 testX() time:    7 635 886 ns
Round # 3 testY() time:    7 645 665 ns
Round # 4 testX() time:    7 671 925 ns
Round # 4 testY() time:    7 644 827 ns
Round # 5 testX() time:    7 552 915 ns
Round # 5 testY() time:    7 637 004 ns
Round # 6 testX() time:    7 793 729 ns
Round # 6 testY() time:    7 647 899 ns
Round # 7 testX() time:    5 906 337 ns
Round # 7 testY() time:    7 645 385 ns
Round # 8 testX() time:    7 637 004 ns
Round # 8 testY() time:    7 645 106 ns
Round # 9 testX() time:    4 800 890 ns
Round # 9 testY() time:    7 666 897 ns
Cumulative time for testX():   71 348 455 ns
Cumulative time for testY():   79 723 823 ns
</pre>

<p>Vidíme, ¾e práce s&nbsp;volatilním atributem je nepatrnì pomalej¹í.</p>

<p>Co se ov¹em stane, pokud na stejném poèítaèi povolíme pou¾ití JIT pøekladaèe
typu server? Výsledky budou mnohem zajímavìj¹í:</p>

<pre>
Round # 0 testX() time:   18 140 294 ns
Round # 0 testY() time:   15 192 155 ns
Round # 1 testX() time:    3 523 632 ns
Round # 1 testY() time:   11 826 084 ns
Round # 2 testX() time:      158 959 ns
Round # 2 testY() time:    7 845 970 ns
Round # 3 testX() time:      158 679 ns
Round # 3 testY() time:    7 847 087 ns
Round # 4 testX() time:      158 680 ns
Round # 4 testY() time:    7 887 315 ns
Round # 5 testX() time:      158 958 ns
Round # 5 testY() time:    7 571 912 ns
Round # 6 testX() time:      158 959 ns
Round # 6 testY() time:    7 852 675 ns
Round # 7 testX() time:      158 959 ns
Round # 7 testY() time:    7 852 675 ns
Round # 8 testX() time:      158 959 ns
Round # 8 testY() time:    8 026 720 ns
Round # 9 testX() time:      158 959 ns
Round # 9 testY() time:    7 897 094 ns
Cumulative time for testX():   22 935 038 ns
Cumulative time for testY():   89 799 687 ns
</pre>

<p>Vidíme, ¾e JIT pøekladaè typu server sice dokázal dobøe optimalizovat
programovou smyèku, v&nbsp;ní¾ se mìnil nevolatilní atribut, ov¹em u atributu
volatilního ji¾ úspì¹nost nebyla nijak velká. Je tomu tak z&nbsp;toho dùvodu,
¾e nedo¹lo k&nbsp;tak dokonalému rozbalení smyèky a taky z&nbsp;dùvodu pou¾ití
pamì»ové bariéry. I v&nbsp;takto jednoduchém benchmarku je rozdíl
v&nbsp;rychlosti bìhu ètyønásobný!</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Ukázkový pøíklad èíslo 2 &ndash; pou¾ití atributù typu <strong>volatile long</strong></h2>

<p>Nyní demonstraèní pøíklad nepatrnì upravíme, a to tak, aby byly oba
celoèíselné atributy (nevolatilní i volatilní) typu <strong>long</strong> a
nikoli typu <strong>int</strong>. Druhý demonstraèní pøíklad bude mít
následující tvar:</p>

<pre>
public class <strong>VolatileTest2</strong> {
    private final static int <strong>ITERATIONS</strong> = 1000000;
&nbsp;
    public long x;
    public volatile long y;
&nbsp;
<i>    // test s nevolatilnim atributem</i>
    private void <strong>testX</strong>() {
        x = 0;
        for (int i=0; i&lt;ITERATIONS; i++) {
            x += 1;
        }
    }
&nbsp;
<i>    // test s volatilnim atributem</i>
    private void <strong>testY</strong>() {
        y = 0;
        for (int i=0; i&lt;ITERATIONS; i++) {
            y += 1;
        }
    }
&nbsp;
    public static void <strong>main</strong>(String[] args) {
        VolatileTest2 test = new VolatileTest2();
        long t1, t2, delta_t;
        long sumTestX=0, sumTestY=0;
&nbsp;
<i>        // provest zadany pocet testu</i>
        for (int i = 0; i &lt; 10; i++) {
<i>            // provest test a zmerit cas behu testu</i>
            t1 = System.nanoTime();
            test.testX();
            t2 = System.nanoTime();
            delta_t = t2 - t1;
            sumTestX += delta_t;
&nbsp;
<i>            // vypis casu pro jeden test</i>
            System.out.format("Round #%2d testX() time: %,12d ns\n", i, delta_t);
&nbsp;
<i>            // provest test a zmerit cas behu testu</i>
            t1 = System.nanoTime();
            test.testY();
            t2 = System.nanoTime();
            delta_t = t2 - t1;
            sumTestY += delta_t;
&nbsp;
<i>            // vypis casu pro jeden test</i>
            System.out.format("Round #%2d testY() time: %,12d ns\n", i, delta_t);
        }
&nbsp;
<i>        // vypis kumulativniho casu</i>
        System.out.format("Cumulative time for testX(): %,12d ns\n", sumTestX);
        System.out.format("Cumulative time for testY(): %,12d ns\n", sumTestY);
    }
&nbsp;
}
</pre>

<p>Opìt zkusíme tento demonstraèní benchmark spustit na poèítaèi
s&nbsp;mikroprocesorem Pentium M. Jedná se o 32bitovou architekturu, co¾
znamená, ¾e se JIT pøekladaè bude muset je¹tì více sna¾it o dosa¾ení atomicity
ètení a zápisu volatilního atributu typu <strong>long</strong> (64 bitù).
Nejdøíve se podívejme, co se stane v&nbsp;pøípadì pou¾ití JIT pøekladaèe typu
klient:</p>

<pre>
Round # 0 testX() time:   11 833 347 ns
Round # 0 testY() time:   27 286 150 ns
Round # 1 testX() time:   11 482 745 ns
Round # 1 testY() time:   27 220 499 ns
Round # 2 testX() time:    9 595 353 ns
Round # 2 testY() time:   25 362 721 ns
Round # 3 testX() time:    9 788 675 ns
Round # 3 testY() time:   25 414 123 ns
Round # 4 testX() time:    9 662 122 ns
Round # 4 testY() time:   25 300 702 ns
Round # 5 testX() time:   10 094 858 ns
Round # 5 testY() time:   25 423 622 ns
Round # 6 testX() time:    9 599 544 ns
Round # 6 testY() time:   25 476 701 ns
Round # 7 testX() time:    9 612 953 ns
Round # 7 testY() time:   25 164 092 ns
Round # 8 testX() time:    9 801 525 ns
Round # 8 testY() time:   25 608 282 ns
Round # 9 testX() time:    9 592 001 ns
Round # 9 testY() time:   25 394 569 ns
Cumulative time for testX():  101 063 123 ns
Cumulative time for testY():  257 651 461 ns
</pre>

<p>Vidíme, ¾e je zde zmìna volatilního atributu cca 2,5&times; pomalej¹í, ne¾ u
atributu nevolatilního.</p>

<p>V&nbsp;pøípadì pou¾ití JIT pøekladaèe typu server je rozdíl je¹tì mnohem
vìt¹í!</p>

<pre>
Round # 0 testX() time:   18 521 070 ns
Round # 0 testY() time:   28 023 393 ns
Round # 1 testX() time:    4 280 152 ns
Round # 1 testY() time:   24 841 706 ns
Round # 2 testX() time:      458 717 ns
Round # 2 testY() time:   19 393 247 ns
Round # 3 testX() time:      458 717 ns
Round # 3 testY() time:   19 441 019 ns
Round # 4 testX() time:      458 996 ns
Round # 4 testY() time:   21 765 336 ns
Round # 5 testX() time:      458 717 ns
Round # 5 testY() time:   19 263 342 ns
Round # 6 testX() time:      458 718 ns
Round # 6 testY() time:   19 510 580 ns
Round # 7 testX() time:      464 863 ns
Round # 7 testY() time:   19 269 209 ns
Round # 8 testX() time:      458 717 ns
Round # 8 testY() time:   19 280 104 ns
Round # 9 testX() time:      458 718 ns
Round # 9 testY() time:   19 446 885 ns
Cumulative time for testX():   26 477 385 ns
Cumulative time for testY():  210 234 821 ns
</pre>

<p>Zde se ji¾ jedná o skoro øádový rozdíl &ndash; zmìna volatilního atributu je
8&times; pomalej¹í, ne¾ u atributu nevolatilního.</p>

<p>Na tomto místì si mo¾ná ètenáøi øíkají, proè je vlastnì sáhodlouze
popisována problematika práce s&nbsp;64bitovými volatilními atributy
(<strong>long, double</strong>) na 32bitových architekturách, kdy¾ se dnes
mù¾eme spí¹e setkat s&nbsp;64bitovými servery èi osobními poèítaèi. Nesmíme
v¹ak zapomínat na smartphony a dal¹í mobilní zaøízení, v&nbsp;nich¾ se typicky
setkáváme s&nbsp;32bitovou architekturou ARM (a problematika volatilních
atributù je prakticky stejná, bez ohledu na to, zda virtuálnímu stroji øíkáme
Java Virtual Machine èi Dalvik ;-).</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Vnitøní synchronizace: technologie safe-pointù</h2>

<p>V¹echny synchronizaèní mechanismy zmínìné v&nbsp;pøedchozích kapitolách jsou
explicitnì vy¾adovány programátorem, a» ji¾ se jedná o pou¾ití
synchronizovaných metod a blokù èi o vyu¾ití tøíd, v&nbsp;nich¾ se
synchronizace vnitønì provádí (typickým pøíkladem je zmínìná tøída
<strong>java.util.Vector</strong> èi <strong>java.util.StringBuffer</strong>).
Ov¹em kromì tìchto na první èi druhý pohled rozpoznatelných synchronizaèních
mechanismù se synchronizace jednotlivých vláken bì¾ících ve virtuálním stroji
provádí i na ponìkud ni¾¹í úrovni, která ji¾ nemá pøímý obraz ve zdrojovém
kódu. To mimochodem znamená, ¾e pøi pohledu na zdrojový kód ji¾ není zcela
jednoduché øíci, ve kterém okam¾iku a ve kterém místì ve zdrojovém kódu
k&nbsp;této synchronizaci mù¾e docházet. Tento skrytý a pøitom velmi dùle¾itý
synchronizaèní mechanismus pou¾itý v&nbsp;HotSpotu i v&nbsp;nìkterých dal¹ích
virtuálních strojích se nazývá <i>safe-point(s)</i> (nebudu se zde sna¾it
zavádìt novou èeskou terminologii, význam anglického názvu je asi zøejmý).</p>

<p>Obecnì øeèeno se pod oznaèením <i>safe-point</i> skrývají urèitá místa
v&nbsp;bajtkódu èi v&nbsp;pøelo¾eném strojovém kódu, v&nbsp;nich¾ mù¾e dojít
k&nbsp;pozastavení bìhu vláken, aby mohl virtuální stroj Javy provést nìjakou
operaci, která vy¾aduje, aby v¹echna aplikaèní vlákna byla nejenom pozastavena,
ale aby byla navíc pozastavena v&nbsp;pøesnì definovaném stavu. Nejtypiètìj¹ím
dùvodem pro pou¾ití safe-pointù je nutnost spou¹tìt správce pamìti (<i>GC
&ndash; Garbage Collector</i>), proto¾e se pøi úklidu pamìti mohou mìnit adresy
jednotlivých objektù a v¹echna bì¾ící vlákna musí po probìhnutí GC ji¾ pracovat
s&nbsp;novými adresami (na úrovni programovacího jazyka Java samozøejmì nemáme
k&nbsp;pøímým adresám pøístup).</p>

<p>Dùvodù je ov¹em ve skuteènosti více, napøíklad nutnost pozastavit vlákna pøi
takzvaném <i>hot-swapu</i> (vlo¾ení modifikovaného bajtkódu do bì¾ící JVM),
pou¾ití instrumentace èi pøi nìkterých ladicích operacích (detekce deadlockù,
po¾adavek na vytvoøení výpisu obsahu zásobníkových rámcù apod.)</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Princip práce safe-pointù v&nbsp;souèasných virtuálních strojích</h2>

<p>Safe-pointy jsou pou¾ity jak pøi pouhé interpretaci bajtkódu, tak i ve
strojovém (nativním) kódu vygenerovaném JIT pøekladaèem typu <i>client</i>
(<i>C1</i>) i <i>server</i> (<i>C2</i>). Pou¾itím interpretru se dnes nebudeme
pøíli¹ zabývat (u¾ jen z&nbsp;praktických dùvodù), o to zajímavìj¹í je v¹ak
zpùsob implementace safe-pointù v&nbsp;souèasných verzích JIT pøekladaèù
virtuálního stroje Javy. Pøi urèování tìch oblastí, v&nbsp;nich¾ mají být
safe-pointy pou¾ity v&nbsp;generovaném zdrojovém kódu, je nutné brát ohled na
dvì navzájem protichùdná hlediska:</p>

<ol>

<li>Vzhledem k&nbsp;tomu, ¾e <i>safe-pointy</i> jsou mj.&nbsp;pou¾ívány i tìmi
správci pamìti, které pøed svým bìhem pozastavují v¹echna aplikaèní vlákna
(takzvaní <i>stop-the-world</i> èi jen <i>STW</i> správci pamìti), je
z&nbsp;tohoto hlediska vhodné, aby se v&nbsp;kódu vyskytovalo co nejvìt¹í
mno¾ství safe-pointù. Pokud by toti¾ safe-point nebyl napøíklad vlo¾en do
dlouhotrvající programové smyèky, znamenalo by to, ¾e se pøed vlastním
spu¹tìním GC pozastaví v¹echna ostatní vlákna aplikace a tato vlákna by jen
neèinnì èekala na dokonèení zmínìné smyèky v&nbsp;posledním nepozastaveném
vláknu, co¾ je zcela jistì neakceptovatelná situace (i zde tedy mù¾eme pomìrnì
názornì vidìt, ¾e pou¾ití GC není v&nbsp;¾ádném pøípadì &bdquo;zadarmo&ldquo;).
Velké mno¾ství safe-pointù takté¾ napomáhá mnohem lépe lokalizovat ta místa,
v&nbsp;nich¾ do¹lo k&nbsp;deadlocku.</li>

<li>Na druhou stranu je v¹ak vkládání safe-pointù do generovaného strojového
kódu nároèné jak z&nbsp;pamì»ového hlediska, tak i z&nbsp;hlediska èasu bìhu
v¹ech aplikaèních vláken. Teoreticky je sice mo¾né safe-point vlo¾it mezi
ka¾dou instrukci (co¾ by bylo zcela ideální, pokud by se vzalo do úvahy pouze
první hledisko), ov¹em to by znamenalo pøibli¾nì dvojnásobný nárùst pamì»ových
nárokù na velikost oblasti pamìti, do ní¾ se generují &bdquo;JITované&ldquo;
metody. Ve skuteènosti je ov¹em nutné si u ka¾dého safe-pointu zapamatovat i
dal¹í údaje, zejména takzvanou mapu referencí na objekty, tak¾e by spotøeba
pamìti byla je¹tì mnohonásobnì vìt¹í.</li>

</ol>



<p><a name="k08"></a></p>
<h2 id="k08">8. Obsah následující èásti seriálu</h2>

<p>V&nbsp;následující èásti tohoto seriálu si nejdøíve øekneme, jakým zpùsobem
vyøe¹ili autoøi HotSpotu problematiku obou protichùdných hledisek zmínìných <a
href="#k07">v&nbsp;pøedchozí kapitole</a>. Posléze se seznámíme
s&nbsp;principem generování safe-pointù na platformì x86_64; proto¾e se jedná
(alespoò podle mého názoru) o dosti elegantní øe¹ení celé problematiky, které
je &bdquo;optimistické&ldquo; v&nbsp;tom smyslu, ¾e se generuje pomìrnì velké
mno¾ství safe-pointù, ov¹em na druhou stranu se optimisticky pøedpokládá, ¾e se
tìmito safe-pointy bude ve vìt¹inì pøípadù pouze procházet bez pozastavení
vlákna.</p>

<p>Tak¾e se opìt mù¾eme tì¹it na assembler! :-)</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Repositáø se zdrojovými kódy v¹ech demonstraèních i testovacích pøíkladù</h2>

<p>Následuje &ndash; v&nbsp;tomto seriálu ji¾ tradièní &ndash; kapitola
s&nbsp;odkazy na zdrojové kódy. V&nbsp;následující tabulce najdete odkazy na
prozatím nejnovìj¹í verze obou dnes pou¾itých jednoduchých benchmarkù:</p>

<table>
<tr><th>#</th><th>Zdrojový soubor/skript</th><th>Umístìní souboru v&nbsp;repositáøi</th></tr>
<tr><td>1</td><td>VolatileTest1.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/9e93a1b7c472/jit/VolatileTest1.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/9e93a1b7c472/jit/VolatileTest1.java</a></td></tr>
<tr><td>2</td><td>VolatileTest2.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/9e93a1b7c472/jit/VolatileTest2.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/9e93a1b7c472/jit/VolatileTest2.java</a></td></tr>
</table>



<p><a name="k10"></a></p>
<h2 id="k10">10. Odkazy na Internetu</h2>

<ol>

<li>GC safe-point (or safepoint) and safe-region<br />
<a href="http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html">http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html</a>
</li>

<li>Safepoints in HotSpot JVM<br />
<a href="http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html">http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html</a>
</li>

<li>Java theory and practice: Synchronization optimizations in Mustang<br />
<a href="http://www.ibm.com/developerworks/java/library/j-jtp10185/">http://www.ibm.com/developerworks/java/library/j-jtp10185/</a>
</li>

<li>How to build hsdis<br />
<a href="http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README">http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README</a>
</li>

<li>Java SE 6 Performance White Paper<br />
<a href="http://www.oracle.com/technetwork/java/6-performance-137236.html">http://www.oracle.com/technetwork/java/6-performance-137236.html</a>
</li>

<li>Lukas Stadler's Blog<br />
<a href="http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html">http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html</a>
</li>

<li>How to build hsdis-amd64.dll and hsdis-i386.dll on Windows<br />
<a href="http://dropzone.nfshost.com/hsdis.htm">http://dropzone.nfshost.com/hsdis.htm</a>
</li>

<li>PrintAssembly<br />
<a href="https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly">https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly</a>
</li>

<li>The Java Virtual Machine Specification: 3.14. Synchronization<br />
<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14</a>
</li>

<li>The Java Virtual Machine Specification: 8.3.1.4. volatile Fields<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.4. Memory Model<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.7. Non-atomic Treatment of double and long<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7</a>
</li>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (pøed verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

