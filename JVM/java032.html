<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Clojure aneb jazyk umo¾òující tvorbu bezpeèných vícevláknových aplikací pro JVM</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Clojure aneb jazyk umo¾òující tvorbu bezpeèných vícevláknových aplikací pro JVM</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyku Java i o virtuálním stroji tohoto jazyka se seznámíme s jazykem Clojure bì¾ícím nad JVM. Jedním z nejzajímavìj¹ích rysù tohoto jazyka je jeho zamìøení na tvorbu vícevláknových aplikací bez nutnosti pou¾ití explicitnì zapisovaných zámkù èi pou¾ití jiných synchronizaèních mechanismù. Na pøíkladu Clojure lze ukázat, ¾e JVM je pou¾itelný i pro provozování vysoce paralelních aplikací.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Clojure aneb jazyk umo¾òující tvorbu bezpeèných vícevláknových aplikací pro JVM</a></p>
<p><a href="#k02">2. Moderní programovací jazyk, jeho¾ koøeny sahají a¾ do roku 1958?</a></p>
<p><a href="#k03">3. Funkcionální programovací jazyky v&nbsp;dobì vícejádrových procesorù</a></p>
<p><a href="#k04">4. Technologie, na nich¾ je postaven programovací jazyk Clojure</a></p>
<p><a href="#k05">5. Malá odboèka: historie vzniku programovacího jazyka LISP a smyèky REPL</a></p>
<p><a href="#k06">6. Zpùsoby spu¹tìní REPL jazyka Clojure i dal¹í varianty jeho pou¾ití v&nbsp;JVM</a></p>
<p><a href="#k07">7. Základní prvky programovacího jazyka Clojure</a></p>
<p><a href="#k08">8. Literály a slo¾ené formy</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Clojure aneb jazyk umo¾òující tvorbu bezpeèných vícevláknových aplikací pro JVM</h2>

<p>V&nbsp;pøedchozích èástech <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyku Java i o virtuálním stroji tohoto jazyka (JVM)</a> jsme si
popsali strukturu bajtkódu i vlastní instrukèní soubor JVM. <a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-instrukce-invokedynamic/">Minule</a>
jsme se navíc seznámili s&nbsp;novou instrukcí nazvanou pøíhodnì
<strong>invokedynamic</strong>, která byla do instrukèního souboru JVM pøidána
v&nbsp;rámci rùzných zmìn a vylep¹ení v&nbsp;JDK 7 pøedev¹ím z&nbsp;dùvodu
lep¹í podpory pøekladaèù dynamicky typovaných programovacích jazykù (samotný
pøekladaè Javy tuto instrukci nepou¾ívá a ani ji nepotøebuje pou¾ívat). Takté¾
jsme si øekli, ¾e ani virtuální stroj Javy ani jeho instrukèní soubor vlastnì
nikde striktnì nepøedpokládají, ¾e JVM bude spou¹tìt pouze bajtkód získaný
pøekladem javovských programù &ndash; ve specifikaci JVM je na nìkolika místech
explicitnì zmínìn pøedpoklad, ¾e nad virtuálním strojem Javy budou provozovány
i dal¹í programovací jazyky umo¾òující pøímý èi nepøímý pøeklad do
bajtkódu.</p>

<p>Pravdìpodobnì nejznámìj¹ím pøíkladem takového programovacího jazyka je
<i>Scala</i>, která nabízí prakticky bezproblémovou spolupráci mezi èástmi kódu
psanými ve <i>Scale</i> a zbytkem aplikace psaným v&nbsp;<i>Javì</i>
(popø.&nbsp;jsou nìkteré projekty psané pouze ve <i>Scale</i>, ov¹em
provozovány jsou napøíklad na ryze javovských serverech &ndash; <i>Tomcat</i>,
<i>Jetty</i> atd.). Díky tomu, ¾e zdrojové kódy psané ve <i>Scale</i> jsou
pøímo pøekládány do bajtkódu, získali tvùrci tohoto programovacího jazyka
prakticky zadarmo ve¹keré vymo¾enosti, které virtuální stroj Javy (èi pøesnìji
øeèeno celé JRE) poskytuje &ndash; od pomìrnì peèlivé kontroly bajtkódu pøi
jeho naèítání do virtuálního stroje pøes pou¾ití správcù pamìti a JIT
pøekladaèù (<i>Just in Time Compiler</i>) a¾ po mo¾nost vyu¾ití rozsáhlých
standardních knihoven <i>J2SE</i> a samozøejmì takté¾ mnoha dal¹ích knihoven a
frameworkù, které jsou pro JVM dostupné. Ov¹em <i>Scala</i> samozøejmì není
jediným programovacím jazykem, který díky pøekladu do bajtkódu umo¾òuje vyu¾ít
prakticky ve¹kerého potenciálu JVM/JRE.</p>

<p>Odkazy na dal¹í informaèní zdroje (týkající se vìt¹inou jazyka
<i>Scala</i>):</p>

<ol>

<li>Scala Programming Language<br />
<a href="http://www.scala-lang.org/">http://www.scala-lang.org/</a>
</li>

<li>Run Scala in Apache Tomcat in 10 minutes<br />
<a href="http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes">http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes</a>
</li>

<li>Fast Web Development With Scala<br />
<a href="http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html">http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html</a>
</li>

<li>Top five scripting languages on the JVM<br />
<a href="http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855">http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855</a>
</li>

</ol>



<p><a name="k02"></a></p>
<h2 id="k02">2. Moderní programovací jazyk, jeho¾ koøeny sahají a¾ do roku 1958?</h2>

<p>Z&nbsp;dal¹ích pøekladaèù programovacích jazykù, které pro virtuální stroj
Javy vznikly, je podle mého názoru nejzajímavìj¹ím jazykem a souèasnì i jazykem
s&nbsp;velkým potenciálem pro budoucnost programovací jazyk s&nbsp;názvem
<i>Clojure</i>, jeho¾ autorem a dodnes nejaktivnìj¹ím vývojáøem je <i>Rich
Hickey</i>. Samotný název tohoto jazyka vznikl vlo¾ením písmene &bdquo;j&ldquo;
(<u>J</u>ava/<u>J</u>VM) do slova <i>closure</i> (toto slovo se pou¾ívá ve
smyslu &bdquo;lexikální uzávìr&ldquo; &ndash; dùle¾itá abstrakce pou¾ívaná ve
funkcionálních programovacích jazycích). V&nbsp;následujících kapitolách se
alespoò ve struènosti seznámíme s&nbsp;nejzajímavìj¹ími prvky tohoto
programovacího jazyka. Hned na úvod je nutné si na rovinu øíct, ¾e velká èást
pøedností a pro mnohé vývojáøe takté¾ záporù programovacího jazyka
<i>Clojure</i> vychází z&nbsp;toho, ¾e se jedná o programovací jazyk, jeho¾
syntaxe a sémantika do znaèné míry vychází z&nbsp;<i>LISPu</i> a <i>Scheme</i>,
tedy jazykù známých pøedev¹ím tím, ¾e se v&nbsp;programech v&nbsp;nich psaných
pou¾ívá nadmìrné mno¾ství kulatých závorek.</p>

<a href="http://i.iinfo.cz/images/521/java32-01.png"><img src="http://i.iinfo.cz/images/521/java32-01-prev.png" width="370" height="231" alt="&#160;" /></a>
<p><i>Obrázek 1: Hra Abuse je z&nbsp;velké èásti napsána v&nbsp;LISPu &ndash;
nízkoúrovòové èásti pou¾ívají nativní knihovny (na Linuxu napøíklad SDL), ov¹em
ve¹kerá herní logika je skuteènì v&nbsp;LISPu a s&nbsp;tro¹kou vùle a volného
èasu lze z&nbsp;Abuse vytvoøit zcela odli¹nou hru. Zdánlivá malá výkonnost
LISPu se zde neprojevuje, proto¾e Abuse lze bez problémù hrát i na staøièkém
poèítaèi s&nbsp;mikroprocesorem 80486DX2.</i></p>

<p>Mnoho ètenáøù si nyní s&nbsp;velkou pravdìpodobností klade otázku, jestli
vùbec má smysl si nìco zaèínat s&nbsp;programovacím jazykem odvozeným od
<i>LISPu</i>, jeho¾ první verze vznikla u¾ pøed neuvìøitelnými 54 lety,
konkrétnì v&nbsp;roce 1958 (jedná se tedy po <i>Fortranu</i> o druhý nejstar¹í
stále pou¾ívaný vysokoúrovòový programovací jazyk). Mù¾e vùbec jazyk postavený
na tak &bdquo;starých&ldquo; my¹lenkách nìco nabídnout souèasné IT? Kupodivu to
smysl má (a dokonce èím dál tím vìt¹í), proto¾e kromì ji¾ zmínìné pøemíry
kulatých závorek nabízí rùzné dialekty <i>LISPu</i> programátorùm i pomìrnì
velké mno¾ství pøedností. <i>Clojure</i> k&nbsp;tìmto pøednostem pøidává
zejména mo¾nost snadného vytváøení vícevláknových aplikací, a to bez nutnosti
explicitního pou¾ívání zámkù (<i>locks</i>) èi dal¹ích synchronizaèních
prostøedkù. <i>Clojure</i> se tak øadí k&nbsp;takovým jazykùm jako je spí¹e
akademicky orientovaný <i>Haskell</i> èi naopak na praxi orientovaný
programovací jazyk <i>Erlang</i>.</p>

<img src="http://i.iinfo.cz/images/111/java32-02.png" width="564" height="517" alt="&#160;" />
<p><i>Obrázek 2: Ukázka èásti zdrojového kódu hry Abuse.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Funkcionální programovací jazyky v&nbsp;dobì vícejádrových procesorù</h2>

<p>Pravdìpodobnì nebude velkým pøekvapením zji¹tìní, ¾e jak <i>Clojure</i>, tak
i ji¾ zmínìné jazyky <i>LISP</i>, <i>Scheme</i>, <i>Haskell</i> a <i>Erlang</i>
patøí mezi skupinu funkcionálních jazykù, tj.&nbsp;programovacích jazykù
vycházejících z&nbsp;teorie takzvaného &lambda;-kalkulu, jeho¾ autorem je
<i>Alonzo Church</i> (na první návrhy LISPu se dokonce mù¾eme dívat jako na
zpùsob zápisu &lambda;-kalkulu, pro nìj¾ jen tak mimochodem existuje
mechanismus vyhodnocování jednotlivých &lambda; výrazù; takté¾ se tím
vysvìtluje pøítomnost znaku lambda v&nbsp;logu jazyka <i>Clojure</i>).
V&nbsp;dobì, kdy byl publikován návrh programovacího jazyka <i>LISP</i>, se
v&nbsp;akademické sféøe pøedpokládalo, ¾e dal¹í vývoj programovacích jazykù a
s&nbsp;nimi souvisejících technologií (typový systém, interpretry, pøekladaèe,
správci pamìti) se bude ubírat právì cestou <i>LISPU</i>, pøesnìji øeèeno
cestou funkcionálních jazykù. Toto oèekávání do jisté míry souviselo
s&nbsp;vírou v&nbsp;prudký rozvoj umìlé inteligence a spolu s&nbsp;pozdìj¹ím
vìt¹ím èi men¹ím neúspìchem mnoha projektù zamìøených na vývoj umìlé
inteligence ponìkud poklesl i zájem o <i>LISP</i> a jeho dialekty.</p>

<img src="http://i.iinfo.cz/images/457/java32-03.png" width="100" height="99" alt="&#160;" />
<p><i>Obrázek 3: Logo jazyka Clojure s&nbsp;jasnì viditelným písmenem
lambda.</i></p>

<p>Potom se po dlouhou dobu zdálo, ¾e úspìch budou slavit dnes vlastnì ji¾
&bdquo;klasické&ldquo; jazyky takzvané algolské vìtve, které do znaèné míry
kopírují technologii poèítaèe, na nich¾ jsou pøekladaèe tìchto jazykù
provozovány. Pomìrnì zásadní zmìna v&nbsp;názorech na dal¹í vývoj
programovacích jazykù pøichází vlastnì a¾ v&nbsp;posledních letech, kdy se
výpoèetní výkon poèítaèù zvy¹uje mj.&nbsp;i zvìt¹ováním poètu mikroprocesorù,
popø.&nbsp;mikroprocesorových jader. Mikroprocesory se dvìma jádry jsou dnes
ji¾ naprostým standardem a u výkonnìj¹ích poèítaèù není neobvyklé se setkat
s&nbsp;osmi, ¹estnácti atd. jádry. Aby bylo mo¾né psát výkonné aplikace i pro
poèítaèe s&nbsp;velkým mno¾stvím procesorových jader, je nutné, aby tyto
aplikace vytváøely mno¾ství vzájemnì komunikujících procesù nebo vláken.
Kritickým prvkem se pak stává vzájemná komunikace a synchronizace mezi
procesy/jádry, která je v¹ak v&nbsp;mnoha programovacích jazycích dosti
problematická a potenciálnì i nebezpeèná (nehledì na slo¾itosti vyplývající
z&nbsp;obtí¾nìj¹ího ladìní tìchto aplikací).</p>

<p>Zajímavé je, ¾e dokonce ani Java tuto problematiku nedoká¾e uspokojivì
vyøe¹it, proto¾e explicitní synchronizace s&nbsp;vyu¾itím synchronizovaných
metod èi blokù je pro skuteènì &bdquo;paralelní&ldquo; aplikace slo¾itá a
výjimkou nejsou ani deadlocky objevené pozdì, tj.&nbsp;a¾ na
poèítaèích/serverech zákazníka. A právì v&nbsp;oblasti paralelních aplikací
zaèínají programátoøi znovu objevovat kouzlo funkcionálních jazykù, dnes
pøedev¹ím <i>Erlangu</i> (který má za sebou mno¾ství komerènì úspì¹ných
projektù) a takté¾ <i>Clojure</i>.</p>

<p>Odkazy na dal¹í informaèní zdroje:</p>

<ol>

<li>Lambda kalkul<br />
<a href="http://cs.wikipedia.org/wiki/Lambda_kalkul">http://cs.wikipedia.org/wiki/Lambda_kalkul</a>
</li>

<li>McCarthy<br />
<i>&bdquo;Recursive functions of symbolic expressions and their computation by machine, part I&ldquo;</i><br />
1960
</li>

<li>Guy L. Steele<br />
<i>&bdquo;History of Scheme&ldquo;</i><br />
2006, Sun Microsystems Laboratories
</li>

<li>
Koláø J., Muller K.:<br />
<i>&bdquo;Speciální programovací jazyky&ldquo;</i><br />
Praha 1981
</li>

<li>
<i>&bdquo;AutoLISP Release 9, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., October 1987
</li>

<li>
<i>&bdquo;AutoLISP Release 10, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., September 1988
</li>

<li>McCarthy, John; Abrahams, Paul W.; Edwards, Daniel J.; Hart, Timothy P.; Levin, Michael I.<br />
<i>&bdquo;LISP 1.5 Programmer's Manual&ldquo;</i><br />
MIT Press. ISBN 0 262 130 1 1 4
</li>

<li>Carl Hewitt; Peter Bishop and Richard Steiger<br />
<i>&bdquo;A Universal Modular Actor Formalism for Artificial Intelligence&ldquo;</i><br />
1973
</li>

</ol>



<p><a name="k04"></a></p>
<h2 id="k04">4. Technologie, na nich¾ je postaven programovací jazyk Clojure</h2>

<p>Základní vlastnosti jazyka <i>Clojure</i> vychází z&nbsp;technologií, které
byly vytvoøeny ji¾ pøed více ne¾ padesáti roky v&nbsp;rámci vývoje
programovacího jazyka <i>LISP</i>. Ov¹em tyto technologie a postupy byly
upraveny tak, aby se dobøe pøizpùsobily souèasným technologiím &ndash;
pøedev¹ím just-in-time pøekladaèùm pracujícím s&nbsp;bajtkódem, správcùm pamìti
dosti odli¹ným od pomìrnì naivních správcù zalo¾ených na poèítání referencí
atd. Z&nbsp;pohledu programátora je programovací jazyk <i>Clojure</i>, stejnì
jako <i>LISP</i> a mnoho dal¹ích funkcionálních jazykù, vybaven takzvanou
smyèkou <i>REPL (Read-Evaluate-Print-Loop)</i>, tedy interaktivním prostøedím,
v&nbsp;nìm¾ je mo¾né zapisovat jednotlivé výrazy, které jsou (alespoò zdánlivì)
ihned vykonány a jejich¾ výsledek je vypsán na standardní výstup. Pomocí
<i>REPL</i> lze vytváøet nové programy (i kdy¾ zde je vìt¹inou vhodnìj¹í se
spokojit s&nbsp;vhodným integrovaným vývojovým prostøedím s&nbsp;mo¾ností
spu¹tìní <i>REPL</i>), ladit programy, popø.&nbsp;se dokonce &ndash; vzdálenì
&ndash; pøipojit k&nbsp;bì¾ící aplikaci a bez nutnosti jejího restartu
v&nbsp;ní opravit chybu (a na nìkteré zákazníky skuteènì magické sousloví
&bdquo;zero downtime&ldquo; pùsobí velmi dobøe :-).</p>

<p>Smyèku <i>REPL</i> si vìt¹inou spojujeme pøedev¹ím se skriptovacími jazyky,
které jsou provádìny interpretrem (pøíkladem mù¾e být <i>BASH</i> a nepøímo té¾
<i>Basic</i>), ov¹em ústøedním prvkem jazyka <i>Clojure</i> je ve skuteènosti
jeho <strong>pøekladaè</strong>. Mù¾e se to mo¾ná zdát pøekvapivé, ale programy
psané v&nbsp;<i>Clojure</i> jsou skuteènì pøekládány, ale nikoli pøímo do
nativního strojového kódu procesoru, na nìm¾ JVM bì¾í, ale do regulárního
bajtkódu, který je ihned po pøekladu dostupný i z&nbsp;Javy (to v&nbsp;pøípadì,
¾e by se napøíklad funkce napsaná v&nbsp;<i>Clojure</i> mìla ihned volat
z&nbsp;javovského programu). To s&nbsp;sebou pøiná¹í pomìrnì znaèné mno¾ství
výhod, proto¾e pøekladaè <i>Clojure</i> do bajtkódu mù¾e být pomìrnì pøímoèarý
a jednoduchý, podobnì jako pøekladaè Javy do bajtkódu &ndash; v&nbsp;obou
pøípadech se prakticky neprovádí ¾ádné optimalizace, proto¾e ty jsou ji¾
zále¾itostí just-in-time pøekladaèe. Výsledkem vyu¾ití bajtkódu je pøekvapivì
rychlý bìh aplikací vytvoøených v&nbsp;<i>Clojure</i>, dobrá a pøímoèará
integrace se samotnou Javou, mo¾nost pou¾ití prakticky jakýchkoli
profilovacích, testovacích aj. nástrojù vytvoøených pro Javu atd.</p>

<div class="rs-box"><p>Pou¾ití sousloví &bdquo;smyèka REPL&ldquo; není
z&nbsp;hlediska gramatiky pøíli¹ správné, proto¾e u¾ písmeno &bdquo;L&ldquo; ve
zkratce &bdquo;REPL&ldquo; znamená smyèku (viz té¾ èasté prohøe¹ky typu LED
dioda èi LCD displej). Nicménì pou¾ití jiných opisù mi pøi¹lo pomìrnì násilné,
tak¾e se za tuto vlastnì zámìrnou chybu omlouvám.</p></div>



<p><a name="k05"></a></p>
<h2 id="k05">5. Malá odboèka: historie vzniku programovacího jazyka LISP a smyèky REPL</h2>

<p><a href="http://imgs.xkcd.com/comics/lisp_cycles.png">Syntaxe jazyka LISP je ji¾ po 50 let zdrojem inspirace pro autory vtipù</a></p>

<p>Mo¾ná nebude na ¹kodu i do èlánku o zcela moderním programovacím jazyce
vlo¾it krátkou historickou vsuvku o <i>LISPu</i>. Historie programovacího
jazyka <i>LISP</i> je velmi dlouhá, nebo» se jedná o jeden z&nbsp;nejstar¹ích
vy¹¹ích programovacích jazykù vùbec. Autorem teoretického návrhu tohoto jazyka
je <i>John McCarthy</i>, který se ji¾ v&nbsp;roce 1956 pøipojil k&nbsp;týmu,
jeho¾ úkolem bylo navrhnout algebraický programovací jazyk umo¾òující
zpracování seznamù, jen¾ by byl vhodný pro vývoj systémù umìlé inteligence
&ndash; <i>AI</i> (zatímco dnes jsou &bdquo;v kurzu&ldquo; enterprise systémy
popø.&nbsp;WEB 2.0 èi &bdquo;cloud&ldquo;, v&nbsp;padesátých a ¹edesátých
letech minulého století se jednalo o umìlou inteligenci a expertní systémy).
McCarthy navrhl, aby se fakta o okolním svìtì (která mù¾e AI pøi své èinnosti
pou¾ít) reprezentovala formou vìt ve vhodnì strukturovaném formálním jazyce.
Posléze se ukázalo, ¾e je výhodné reprezentovat jednotlivé vìty formou seznamù.
McCarthy my¹lenku jazyka vhodného pro AI rozpracoval dále &ndash; odklonil se
napøíklad od infixové notace zápisu algebraických výrazù, proto¾e
naprogramování nìkterých manipulací s&nbsp;tìmito výrazy (derivace, integrace,
zjednodu¹ení výrazù, logická dedukce) bylo zbyteènì slo¾ité.</p>

<a href="http://i.iinfo.cz/images/455/lisp01.png"><img src="http://i.iinfo.cz/images/455/lisp01-prev.png" alt="lisp01" height="270" width="257" /></a>
<p><i>Obrázek 4: Na tomto grafu evoluce programovacích jazykù mù¾eme najít
prarodièe mnoha dodnes pou¾ívaných programovacích jazykù, vèetnì LISPu.</i></p>

<p>Následnì McCarthy ve svých teoretických pracích (vznikajících v&nbsp;prùbìhu
let 1957 a 1958) ukázal, ¾e je mo¾né pomocí nìkolika pomìrnì jednoduchých
operací (a notací pro zápis funkcí) vytvoøit programovací jazyk, který je
Turingovsky kompletní (tj.&nbsp;jeho výpoèetní mocnost je ekvivalentní
<i>Turingovu stroji</i>), ale zápis algoritmù v&nbsp;tomto jazyce je mnohem
jednodu¹¹í ne¾ zápis pravidel pro Turingùv stroj. Tento jazyk, jen¾ byl
z&nbsp;velké èásti zalo¾en na ji¾ zmínìném <i>Lambda kalkulu</i>, obsahoval
mo¾nost vytváøení rekurzivních funkcí (co¾ byl významný rozdíl napøíklad oproti
tehdej¹í verzi <i>FORTRANU</i>), podporoval pou¾ití funkcí jako argumentù
jiných funkcí, podmínìné výrazy (jedna z&nbsp;variant takzvané speciální
formy), funkce pro manipulaci se seznamy a v&nbsp;neposlední øadì také funkci
<i>eval</i>. Na McCarthovu teoretickou práci navázal <i>S. R. Russell</i>,
který si uvìdomil, ¾e samotná funkce <i>eval</i>, pokud by byla implementována
na nìjakém poèítaèi, mù¾e slou¾it jako základ plnohodnotného interpretru jazyka
<i>LISP</i> (interpretr LISPu se nìkdy té¾ oznaèuje takté¾ ji¾ mnohokrát
zmínìnou zkratkou <i>REPL: Read-Evaluate-Print-Loop</i>, tj.&nbsp;interpretr ve
smyèce naèítá jednotlivé výrazy, vyhodnocuje je a následnì tiskne jejich
výslednou hodnotu). Russell skuteènì celou smyèku <i>REPL</i> implementoval
&ndash; tímto zpùsobem se zrodila první reálná verze <i>LISPu</i>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Zpùsoby spu¹tìní REPL jazyka Clojure i dal¹í varianty jeho pou¾ití v&nbsp;JVM</h2>

<p>V&nbsp;této kapitole se seznámíme se tøemi základními postupy, jakými lze
pøekladaè jazyka <i>Clojure</i> vyu¾ít. Nejjednodu¹¹í je vyu¾ití smyèky
<i>REPL</i> tohoto programovacího jazyka, která se spou¹tí a následnì pou¾ívá
velmi snadno. Postaèuje si <a href="http://clojure.org/">ze stránek Clojure</a>
stáhnout poslední stabilní verzi tohoto jazyka, co¾ je jediný soubor nazvaný
<strong>clojure-1.4.0.zip</strong> (souèasná verze). Po rozbalení tohoto
archivu získáme mj.&nbsp;i Java archiv <strong>clojure-1.4.0.jar</strong>.
V&nbsp;tomto souboru je ulo¾en pøekladaè, v¹echny podpùrné knihovny jazyka i
samotný <i>REPL</i>. Ji¾ z&nbsp;koncovky názvu tohoto souboru je patrné, ¾e se
skuteènì jedná o klasický Java archiv, který lze vyu¾ít nìkolika zpùsoby.
Nejjednodu¹¹í zpùsob spoèívá se spu¹tìní interaktivního prostøedí
pøedstavovaného smyèkou <i>REPL</i>. Na pøíkazovou øádku postaèí zadat:</p>

<pre>
java -jar clojure-1.4.0.jar
</pre>

<p>Pro první seznamování s&nbsp;jazykem <i>Clojure</i> je vyu¾ití smyèky
<i>REPL</i> dostateèné, ov¹em v&nbsp;praxi se spí¹e setkáme s&nbsp;potøebou
spou¹tìt aplikace, jejich¾ èásti jsou psané v&nbsp;Javì a èásteènì
v&nbsp;<i>Clojure</i> a které tedy vy¾adují i v&nbsp;runtime podporu tohoto
jazyka (napøíklad pro dynamický pøeklad kódu). V&nbsp;tomto pøípadì postaèuje
aplikaci spustit bì¾ným postupem, ov¹em s&nbsp;tím roz¹íøením, ¾e na
<strong>CLASSPATH</strong> musí být uvedena cesta k&nbsp;Java archivu
obsahujícího <i>Clojure</i>:</p>

<pre>
java -cp .:clojure-1.4.0.jar MyApp.Main
</pre>

<p>Nìkteré aplikace navíc pøistupují ke &bdquo;skriptùm&ldquo; nikoli pøes
nìjaké proprietární aplikaèní programové rozhraní vytvoøené tvùrci daného
skriptovacího jazyka, ale sna¾í se namísto toho pou¾ít univerzální rozhraní
specifikované v&nbsp;<i>JSR 223: Scripting for the Java Platform</i>.
S&nbsp;tímto standardním rozhraním dostupným pøímo v&nbsp;JRE jsme se ji¾
v&nbsp;tomto seriálu setkali, viz té¾ odkazy uvedené na konci této kapitoly.
Pokud je nutné volat èásti kódu napsané v&nbsp;jazyku <i>Clojure</i> pomocí
rozhraní definovaného v&nbsp;<i>JSR 223</i>, musí se kromì archivu
<strong>clojure-1.4.0.jar</strong> stáhnout i archiv
<strong>clojure-jsr223.jar</strong> ze stránky <a
href="http://code.google.com/p/clojure-jsr223/">http://code.google.com/p/clojure-jsr223/</a>
a i ten se musí umístit na <strong>CLASSPATH</strong>:</p>

<pre>
java -cp .:clojure-1.4.0.jar:clojure-jsr223.jar MyApp.Main
</pre>

<p>Odkazy na dal¹í informaèní zdroje o JSR 223:</p>

<ol>

<li>Podpora skriptovacích jazykù v JDK6 a OpenJDK6<br />
<a href="http://www.root.cz/clanky/podpora-skriptovacich-jazyku-v-jdk6-a-openjdk6/">http://www.root.cz/clanky/podpora-skriptovacich-jazyku-v-jdk6-a-openjdk6/</a>
</li>

<li>Podpora skriptovacích jazykù v JDK6 a OpenJDK6 (2.èást)<br />
<a href="http://www.root.cz/clanky/podpora-skriptovacich-jazyku-v-jdk6-a-openjdk6-2-cast/">http://www.root.cz/clanky/podpora-skriptovacich-jazyku-v-jdk6-a-openjdk6-2-cast/</a>
</li>

<li>Podpora skriptovacích jazykù v JDK6 a OpenJDK6 (3.èást)<br />
<a href="http://www.root.cz/clanky/podpora-skriptovacich-jazyku-v-jdk6-a-openjdk6-3-cast/">http://www.root.cz/clanky/podpora-skriptovacich-jazyku-v-jdk6-a-openjdk6-3-cast/</a>
</li>

</ol>



<p><a name="k07"></a></p>
<h2 id="k07">7. Základní prvky programovacího jazyka Clojure</h2>

<p>Nyní se ji¾ (koneènì!) mù¾eme seznámit se základními prvky programovacího
jazyka <i>Clojure</i>. V¹echny pøíklady, které zde budou ukázány, jsou
spou¹tìny interaktivnì ze smyèky <i>REPL</i>, co¾ znamená, ¾e ka¾dý výraz je
nejprve naèten (<i>read</i>), vyhodnocen (<i>evaluate</i>), posléze je jeho
výsledek vypsán na standardní výstup (<i>print</i>) a následnì je oèekáváno
zadání dal¹ího výrazu (<i>loop</i>). V¹echny dále uvedené výrazy jsou
jednoøádkové, tak¾e na prvním øádku je vypsán vlastní výraz (tak jak má být
opsán do konzole) a na øádku druhém výsledek tohoto výrazu. V&nbsp;pøedchozích
vìtách jsme sice pro jednoduchost pou¾ívali slovo &bdquo;výraz&ldquo;
odpovídající spí¹e jazykùm typu Céèka èi Javy, ov¹em v&nbsp;<i>Clojure</i> je,
podobnì jako v&nbsp;<i>LISPu</i> èi <i>Scheme</i>, základním uceleným prvkem
programu takzvaná <i>forma (form)</i>. Právì formy se postupnì zpracovávají ve
smyèce <i>REPL</i> a <i>REPL</i> takté¾ kontroluje, zda u¾ivatel skuteènì zadal
validní formu. V&nbsp;programovacím jazyku <i>Clojure</i> existují ètyøi
základní typy forem:</p>

<ol>
<li>literály</li>
<li>symboly</li>
<li>slo¾ené formy (v&nbsp;podstatì se jedná o seznamy pøedstavující volání funkce)</li>
<li>speciální formy (podobají se slo¾eným formám, ale internì se vyhodnocují odli¹ným zpùsobem)</li>
</ol>



<p><a name="k08"></a></p>
<h2 id="k08">8. Literály a slo¾ené formy</h2>

<p>Nejjednodu¹¹ím typem formy jsou <i>literály</i>, proto¾e ty se
v&nbsp;<i>REPL</i> vyhodnocují samy na sebe. Na literály se mù¾eme dívat jako
na konstanty primitivního datového typu, mezi které v&nbsp;programovacím jazyce
<i>Clojure</i> patøí pøedev¹ím èísla (k&nbsp;dispozici jsou rùzné formy
reprezentace), znaky, øetìzce a pravdivostní hodnoty. Nyní si uká¾eme nìkolik
pøíkladù, které naznaèí, jak s&nbsp;literály pracuje <i>REPL</i> a tudí¾ i
samotný programovací jazyk <i>Clojure</i>:</p>

<p>Øetìzec je prostì ... øetìzec:</p>

<pre>
user=&gt; "Hello world!"
"Hello world!"
</pre>

<p>Dùle¾ité je, ¾e øetìzce jsou &ndash; podobnì jako v&nbsp;Javì &ndash;
konstantní a tudí¾ i nemìnné, co¾ sice v&nbsp;nìkterých pøípadech mù¾e vést
k&nbsp;tvorbì neefektivních operací, kterým se v¹ak lze v&nbsp;<i>Clojure</i>
vìt¹inou zcela vyhnout. To, ¾e jsou øetìzce nemìnné v¹ak zjednodu¹uje tvorbu
bezpeèných vícevláknových aplikací, øetìzce lze vyu¾ívat jako klíèe do
asociativních polí atd. atd., tak¾e pøednosti vìt¹inou pøeva¾ují nad
zápory.</p>

<p>Pou¾ití literálù pøedstavujících pravdivostní hodnoty asi nikoho nepøekvapí:</p>

<pre>
user=&gt; true
true
user=&gt; false
false
</pre>

<p>Èíselné literály jsou ji¾ mnohem zajímavìj¹í, proto¾e èísla lze
reprezentovat rùzným zpùsobem, napøíklad:</p>

<p>... jako celé èíslo (odpovídající konvencím zápisu podle Céèka, C++ èi
Javy):</p>

<pre>
user=&gt; 42
42
</pre>

<pre>
user=&gt; 0x2a
42
</pre>

<pre>
user=&gt; 052
42
</pre>

<p>... jako celé èíslo se zadáním základu èíselné soustavy (pøed
<strong>r</strong> mù¾e být uvedeno èíslo 2 a¾ 36):</p>

<pre>
user=&gt; 2r101010
42
</pre>

<pre>
user=&gt; 10r42
42
</pre>

<pre>
user=&gt; 16r2a
42
</pre>

<pre>
user=&gt; 36r16 
42
</pre>

<p>... jako èíslo reálné odpovídající normì IEEE 754:</p>

<pre>
user=&gt; 42.0
42.0
</pre>

<p>... jako zlomek (opìt je zde vidìt návaznost na <i>LISP</i>):</p>

<pre>
user=&gt; 100/3
100/3
</pre>

<p>... a dokonce i jako instance tøídy <strong>java.math.BigDecimal</strong>:</p>

<pre>
user=&gt; 123456789123456789123456789M
123456789123456789123456789M
</pre>

<p>Popis dal¹ích tøí typù forem programovacího jazyka <i>Clojure</i> bude
uveden a¾ v&nbsp;navazující èásti tohoto seriálu. Tam se takté¾ zmíníme o tom,
jak je mo¾né, ¾e v&nbsp;tomto jazyku lze relativnì snadno naprogramovat
bezpeèné vícevláknové aplikace &ndash; øeè bude o nemìnných (imutable) datových
typech, agentech a transakèní pamìti, co¾ jsou pomìrnì zajímavé a ve vìt¹inì
dal¹ích programovacích jazykù prakticky neznámé technologie.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Clojure home page<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/">http://java.sun.com/developer/technicalArticles/DynTypeLang/</a>
</li>

<li>JSR 223: Scripting for the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=223">http://jcp.org/en/jsr/detail?id=223</a>
</li>

<li>JSR 292: Supporting Dynamically Typed Languages on the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=292">http://jcp.org/en/jsr/detail?id=292</a>
</li>

<li>Java 7: A complete invokedynamic example<br />
<a href="http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html">http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html</a>
</li>

<li>InvokeDynamic: Actually Useful?<br />
<a href="http://blog.headius.com/2007/01/invokedynamic-actually-useful.html">http://blog.headius.com/2007/01/invokedynamic-actually-useful.html</a>
</li>

<li>A First Taste of InvokeDynamic<br />
<a href="http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html">http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html</a>
</li>

<li>Java 6 try/finally compilation without jsr/ret<br />
<a href="http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html">http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Root.cz: Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM<br />
<a href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/</a></a>
</li>

<li>Root.cz: JamVM aneb alternativa k HotSpotu nejenom pro embedded zaøízení a chytré telefony<br />
<a href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>FindBugs<br />
<a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a>
</li>

<li>GNU Classpath<br />
<a href="www.gnu.org/s/classpath/">www.gnu.org/s/classpath/</a></li>

<li>Java VMs Compared<br />
<a href="http://bugblogger.com/java-vms-compared-160/">http://bugblogger.com/java-vms-compared-160/</a>
</li>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>CloseableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html">http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

