<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Clojure 6: podpora pro paralelní programování</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Clojure 6: podpora pro paralelní programování</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;dne¹ní èásti seriálu o programovacím jazyce Java i o virtuálním stroji Javy se ji¾ po¹esté budeme zabývat popisem vlastností programovacího jazyka Clojure. Ji¾ minule jsme se struènì zmínili o jedné variantì &bdquo;paralelizace&ldquo; programù a dnes budeme v&nbsp;tomto dosti dùle¾itém tématu pokraèovat.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyk Clojure a paralelní programy</a></p>
<p><a href="#k02">2. Funkce <strong>pcalls</strong> &ndash; alternativa k&nbsp;funkci <strong>pmap</strong></a></p>
<p><a href="#k03">3. Vyu¾ití návratové hodnoty funkce <strong>pcalls</strong></a></p>
<p><a href="#k04">4. Malá odboèka &ndash; zkrácený zápis anonymních funkcí</a></p>
<p><a href="#k05">5. Funkce <strong>pcalls</strong> a lazy sekvence</a></p>
<p><a href="#k06">6. Zpùsob pou¾ití makra <strong>pvalues</strong></a></p>
<p><a href="#k07">7. Spu¹tìní výpoètù v&nbsp;samostatných vláknech pomocí <strong>future</strong></a></p>
<p><a href="#k08">8. Zpùsoby øízení &bdquo;future&ldquo; výpoètù</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk Clojure a paralelní programy</h2>

<p><a
href="http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">V&nbsp;pøedchozí èásti</a> <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">tohoto
seriálu</a> jsme zabývali pøevá¾nì problematikou zpracování <i>sekvencí</i> a
pøedev¹ím pak <i>lazy sekvencí</i>, které tvoøí velmi dùle¾itou èást
programovacího jazyka <i>Clojure</i> (skalní Lispaøi se na lazy sekvence mohou
ponìkud zjednodu¹enì dívat jako na zobecnìní seznamù). Mj.&nbsp;jsme si øekli,
¾e pøímo v&nbsp;základní knihovnì tohoto programovacího jazyka se nachází
nìkolik funkcí a maker umo¾òujících velmi jednodu¹e zajistit, aby se nìjaká
sekvence èi mno¾ina funkcí zpracovala paralelnì (programátor si ov¹em musí dát
pozor na to, ¾e se budou volat funkce bez vedlej¹ích efektù, popø.&nbsp;takové
funkce, jejich¾ vedlej¹í efekty nebudou vzájemnì kolidovat). Základem je
v&nbsp;tomto pøípadì funkce <strong>pmap</strong>, která svým chováním odpovídá
funkci <strong>map</strong>, ov¹em celá sekvence na vstupu této funkce je
zpracovávána paralelnì. To mù¾e (ale takté¾ nemusí) pøinést zvý¹ení výkonu celé
aplikace, ov¹em je ponecháno pouze na úsudku programátora, kterou z&nbsp;tìchto
funkcí ve své aplikaci pou¾ije &ndash; v&nbsp;pøípadì jednodu¹¹ích výpoètù
toti¾ re¾ie nutná pro vytvoøení nových vláken pøevá¾í nad výhodami soubì¾ného
bìhu tìchto vláken.</p>

<p>Mìøení doby bìhu nìjaké funkce (resp.&nbsp;doby vyhodnocení formy) lze
zajistit funkcí <strong>time</strong>, její¾ zpùsob pou¾ití je ukázán na
následujícím pøíkladu (pøevzatém z&nbsp;pøedchozí èásti tohoto seriálu):</p>

<pre>
(defn fibonacci
    [n]
    (if (&lt; n 2)
        n
        (+ (fibonacci (- n 2)) (fibonacci (- n 1)))))
&nbsp;
(time (dorun (map fibonacci (range 100 150))))
&nbsp;
(time (dorun (pmap fibonacci (range 100 150))))
</pre>

<p>V&nbsp;závislosti na poètu jader mikroprocesoru, nastavení parametrù
virtuálního stroje Javy (JRE) a dal¹ích parametrech poèítaèe, na nìm¾ je
pøedchozí pøíklad spu¹tìn, se budou vypisovat rozdílné èasy doby bìhu, které by
ale mìly být na moderních strojích s&nbsp;minimálnì dvoujádrovým CPU men¹í pøi
pou¾ití funkce <strong>pmap</strong> namísto funkce <strong>map</strong>.</p>

<p>Pøíklad výsledku pøedchozího jednoduchého benchmarku na stroji s&nbsp;nízkým
poètem procesorových jader:</p>

<pre>
user=&gt; (time (dorun (map fibonacci (range 20 30))))
"Elapsed time: 3105.400932 msecs"
nil
&nbsp;
user=&gt; (time (dorun (pmap fibonacci (range 20 30))))
"Elapsed time: 2558.662981 msecs"
nil
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Funkce <strong>pcalls</strong> &ndash; alternativa k&nbsp;funkci <strong>pmap</strong></h2>

<p>Kromì funkce <strong>pmap</strong>, která je pro pou¾ití v&nbsp;reálných
aplikacích velmi jednoduchá i praktická, lze v&nbsp;programovacím jazyku
<i>Clojure</i> pou¾ít i makro nazvané <strong>pvalues</strong> slou¾ící pro
paralelní vyhodnocení nìkolika forem (opìt zále¾í jen na programátorovi, aby
zajistil, ¾e nedojde ke kolizím v&nbsp;pøípadì vedlej¹ích efektù &ndash; kdo
programuje èistì funkcionálnì, nemá problém :-). Takté¾ lze pou¾ít funkci
<strong>pcalls</strong>, je¾ umo¾òuje zavolat a souèasnì (paralelnì) spustit
nìkolik funkcí pøedaných ve formì parametrù této funkce. U funkce
<strong>pcalls</strong> spoèívá jediný &ndash; ov¹em v&nbsp;mnoha pøípadech
dosti záva¾ný &ndash; problém v&nbsp;tom, ¾e volané funkce jsou
bezparametrické. V&nbsp;následujícím dosti umìlém demonstraèním pøíkladu se
paralelnì volá trojice bezparametrických funkcí, z&nbsp;nich¾ ka¾dá má vedlej¹í
efekt &ndash; výpis textu na standardní výstup (jedná se o jeden z&nbsp;ménì
zákeøných vedlej¹ích efektù). Nejprve jsou v¹echny tøi funkce nadeklarovány a
posléze je dvakrát po sobì zavolána funkce <strong>pcalls</strong>, aby bylo
patrné, ¾e poøadí výpisu na standardní výstup je z&nbsp;hlediska programátora
&bdquo;náhodné&ldquo;, proto¾e ten nemù¾e explicitnì ovlivnit poøadí spu¹tìní,
popø.&nbsp;zpùsob pøepínání vláken:</p>

<pre>
; jednoduché bezparametrické funkce,
; které pouze na standardní výstup
; vypí¹ou nìjaký text
&nbsp;
(defn fce1 [] (println "Funkce 1"))
&nbsp;
(defn fce2 [] (println "Funkce 2"))
&nbsp;
(defn fce3 [] (println "Funkce 3"))
</pre>

<pre>
; nyní v¹echny tøi funkce spustíme tak,
; ¾e ka¾dá funkce pobì¾í ve svém vláknu
&nbsp;
(pcalls fce1 fce2 fce3)
Funkce 1
Funkce 2
(Funkce 3
nil nil nil)
</pre>

<p>V&nbsp;pøedchozím výpisu do¹lo ke smíchání výpisu v¹ech tøí funkcí
s&nbsp;hodnotou, její¾ význam si popí¹eme <a href="#k03">ve tøetí
kapitole</a>.</p>

<pre>
; opakované spu¹tìní, aby bylo zøejmé,
; ¾e poøadí výpisu je "náhodné"
&nbsp;
(pcalls fce1 fce2 fce3)
Funkce 1
(Funkce 3
Funkce 2
nil nil nil)
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Vyu¾ití návratové hodnoty funkce <strong>pcalls</strong></h2>

<p>Zajímavá je takté¾ trojice hodnot <strong>nil nil nil</strong> vypsaná
pøedchozím demonstraèním pøíkladem na posledním øádku (ve skuteènosti
k&nbsp;tìmto hodnotám patøí i otevírací a uzavírací kulaté závorky, které se
v¹ak ve výpisu mohou jednodu¹e pøehlédnout: tyto závorky nám øíkají, ¾e
výsledkem je buï seznam nebo nìjaká obecná sekvence). Samozøejmì se
v&nbsp;pøípadì <strong>(nil nil nil)</strong>, jak by mìl text správnì vypadat,
jedná o výsledek samotné funkce <strong>pcalls</strong>, proto¾e smyèka
<i>REPL</i> automaticky vypisuje návratové hodnoty v¹ech vyhodnocených forem.
Ve skuteènosti toti¾ funkce <strong>pcalls</strong> vrací <i>lazy sekvenci</i>
obsahující výsledky v¹ech paralelnì spu¹tìných funkcí, èeho¾ lze samozøejmì
nále¾itì vyu¾ít. Podívejme se na ponìkud slo¾itìj¹í demonstraèní pøíklad,
v&nbsp;nìm¾ se bude paralelnì poèítat nìkolik èlenù Fibonacciho
øady/posloupnosti (<a
href="http://cs.wikipedia.org/wiki/Fibonacciho_posloupnost">http://cs.wikipedia.org/wiki/Fibonacciho_posloupnost</a>).</p>

<p>Prezentovaný výpoèet je samozøejmì z&nbsp;hlediska optimalizací algoritmu
nesmyslný, proto¾e by bylo mnohem jednodu¹¹í prostì ukládat jednotlivé
mezivýsledky do seznamu nebo vektoru. V&nbsp;na¹em pøíkladu ov¹em výpoèet
jednoho èlenu Fibonacciho øady pou¾ijeme proto, ¾e se jedná o jednoduchou a
souèasnì i snadno pochopitelnou funkci, její¾ vyhodnocení mù¾e trvat del¹í dobu
(na mém obstaro¾ním poèítaèi je ji¾ výpoèet tøicátého èlenu tak pomalý, ¾e je
prodleva ve vyhodnocení jasnì viditelná):</p>

<pre>
; nejprve je uvedena deklarace funkce pro výpoèet jednoho
; èlenu Fibonacciho øady:
&nbsp;
(defn fibonacci
    [n]
    (if (&lt; n 2)
        n
        (+ (fibonacci (- n 2)) (fibonacci (- n 1)))))
</pre>

<pre>
; následnì nadeklarujeme pomocné jednoúèelové funkce,
; které nahradí volání funkce fibonacci s parametrem
; (nejedná se o nej¹»astnìj¹í zpùsob tvorby programù :-)
&nbsp;
(defn fib20 [] (fibonacci 20))
(defn fib25 [] (fibonacci 25))
(defn fib30 [] (fibonacci 30))
</pre>

<pre>
; test, zda jsou funkce zapsány korektnì
&nbsp;
user=&gt; (fib20)
6765
&nbsp;
user=&gt; (fib25)
75025
&nbsp;
user=&gt; (fib30)
832040
</pre>

<pre>
; dobøe, mù¾eme zkusit spustit výpoèty paralelnì
&nbsp;
user=&gt; (pcalls fib20 fib25 fib30)
(6765 75025 832040)
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Malá odboèka &ndash; zkrácený zápis anonymních funkcí</h2>

<p>Pou¾ití pomocných funkcí <strong>fib20</strong>, <strong>fib25</strong> a
<strong>fib30</strong> nadeklarovaných v&nbsp;demonstraèním pøíkladu uvedeném
na konci <a href="#k03">pøedchozí kapitoly</a> bylo vynuceno ji¾ zmínìným
omezením funkce <strong>pcalls</strong> na volání funkcí, které nemají ¾ádné
parametry. Jedná se o ji¾ na první pohled velmi nepìkný zpùsob programování,
kdy se na globální úrovni (pøesnìji øeèeno v&nbsp;implicitním jmenném prostoru)
vytváøí jednoúèelové funkce. Je zajímavé, ¾e v&nbsp;objektovì orientovaných
jazycích je tomu mnohdy naopak &ndash; zde se toti¾ doporuèuje pou¾ívat
jednoduché jednoúèelové <strong>metody</strong>, ty jsou ov¹em omezeny na jednu
tøídu, popø.&nbsp;na jednu vìtev hierarchie tøíd. Zmínìné omezení funkce
<strong>pcalls</strong> lze v¹ak ve skuteènosti obejít i jinak &ndash; pomocí
<i>anonymních funkcí</i>, co¾ je ve funkcionálním jazyku obecnì pova¾ováno za
mnohem elegantnìj¹í pøístup. Jedno z&nbsp;mo¾ných øe¹ení mù¾e vypadat tak, ¾e
se pøímo ve volání funkce <strong>pcalls</strong> vytváøí potøebné anonymní
funkce (ty nesmí mít v&nbsp;tomto pøípadì ¾ádné parametry, proto¾e jejich
hodnoty by nebylo mo¾né nijak pøedat):</p>

<pre>
(pcalls
    (fn [] (fibonacci 20))
    (fn [] (fibonacci 25))
    (fn [] (fibonacci 30))
)
&nbsp;
(6765 75025 832040)
</pre>

<p>Tento zpùsob zápisu v¹ak není o moc èitelnìj¹í, ne¾ tomu bylo
v&nbsp;pøíkladu pøedchozím, proto¾e se pro vytvoøení anonymní funkce pou¾ila
speciální forma <strong>fn</strong>, která je dosti upovídaná. Krat¹í øe¹ení
ov¹em existuje &ndash; vzhledem k&nbsp;tomu, ¾e se anonymní funkce pou¾ívají
pøi tvorbì aplikací v&nbsp;programovacím jazyku Clojure velmi èasto, je mo¾né
pro jejich zápis alternativnì pou¾ít i zkrácenou formu zaèínající znakem #, za
ním¾ je v&nbsp;závorce pøímo napsáno tìlo anonymní funkce (tato forma se
pøekládá do volání <strong>fn</strong> je¹tì v&nbsp;preprocesoru smyèky
<i>REPL</i>, tj.&nbsp;samotná smyèka <i>REPL</i> ji¾ &bdquo;vidí&ldquo; pouze
zápis speciální formy <strong>fn</strong>):</p>

<pre>
#(tìlo anonymní funkce)
</pre>

<p>To, ¾e chybí jméno funkce je pochopitelné &ndash; kdyby funkce mìla jméno,
u¾ by nebyla funkcí anonymní :-) ov¹em absence jmen parametrù mo¾ná mù¾e být
ponìkud matoucí, proto¾e anonymní funkce bez parametrù by vlastnì odpovídala
vrácení konstanty (popø.&nbsp;nefunkcionálním &bdquo;¹ílenostem&ldquo; typu
<strong>random</strong> :-). Ve skuteènosti v¹ak i anonymní funkce vytvoøená
pomocí znaku # parametry mít mù¾e. Ty jsou pojmenovány v&nbsp;závislosti na své
pozici takto: %1, %2 atd. Pøedpokládá se toti¾, ¾e anonymní funkce budou velmi
krátké a s&nbsp;malým mno¾stvím parametrù &ndash; pokud by tomu tak nebylo, nic
programátorùm nebrání vrátit se ke speciální formì <strong>fn</strong>.</p>

<p>Uka¾me si nìjaké pøíklady pou¾ití vytvoøení anonymních funkcí pomocí znaku
#.</p>

<p>Aplikace anonymní funkce vytvoøené s&nbsp;vyu¾itím speciální formy
<strong>fn</strong>:</p>

<pre>
((fn [x y] (* x y)) 6 7)
</pre>

<p>Zkrácený (ekvivalentní) zpùsob zápisu:</p>

<pre>
(#(* %1 %2) 6 7)
</pre>

<p>Anonymní funkce se velmi èasto pou¾ívají jako parametry funkcí
<strong>map</strong>, <strong>pmap</strong>, <strong>filter</strong> apod.:</p>

<pre>
(map #(/ 2 %1) [1 2 3 4 5 6])
(2 1 2/3 1/2 2/5 1/3)
</pre>

<p>Popø.:</p>

<pre>
(map #(/ 2 %1) (range 1 7))
(2 1 2/3 1/2 2/5 1/3)
</pre>

<p>Vra»me se nyní k&nbsp;pùvodnímu (tro¹ku umìlému) pøíkladu. Namísto:</p>

<pre>
(pcalls
    (fn [] (fibonacci 20))
    (fn [] (fibonacci 25))
    (fn [] (fibonacci 30))
)
&nbsp;
(6765 75025 832040)
</pre>

<p>mù¾eme jednodu¹e napsat:</p>

<pre>
(pcalls
    #(fibonacci 20)
    #(fibonacci 25)
    #(fibonacci 30)
)
&nbsp;
(6765 75025 832040)
</pre>

<p>Zde máme situaci je¹tì jednodu¹¹í, proto¾e vlastnì ¾ádný parametr anonymní
funkce nepotøebujeme zpracovat a ve skuteènosti ani nemù¾eme, proto¾e &ndash;
jak jsme si ji¾ øekli &ndash; funkce <strong>pcalls</strong> nedovoluje volání
funkcí s&nbsp;parametry.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Funkce <strong>pcalls</strong> a lazy sekvence</h2>

<p>O tom, ¾e je výsledkem volání funkce <strong>pcalls</strong> skuteènì lazy
sekvence, se mù¾eme pøesvìdèit jednodu¹e. Ulo¾íme výsledek do nìjaké promìnné a
potom si vypí¹eme jak hodnotu této promìnné, tak i výsledky nìkterých
predikátù:</p>

<pre>
user=&gt; (def results (pcalls fib20 fib25 fib30)) 
#'user/results
&nbsp;
user=&gt; (list? results)
false
&nbsp;
user=&gt; (vector? results)
false
&nbsp;
user=&gt; (seq? results)
true
&nbsp;
user=&gt; results
(6765 75025 832040)
</pre>

<p>Je pøitom samozøejmé, ¾e na výslednou lazy sekvenci lze aplikovat v¹echny
funkce, které se sekvencemi mohou pracovat:</p>

<pre>
user=&gt; (map #(/ 1 %1) results)
(1/6765 1/75025 1/832040)
</pre>

<pre>
user=&gt; (map #(/ 1 (* %1 %1)) results)
(1/45765225 1/5628750625 1/692290561600)
</pre>

<p>Programovací jazyk <i>Clojure</i> je pøi práci s&nbsp;lazy sekvencemi
skuteènì &bdquo;líný&ldquo;, proto¾e se výzva smyèky <i>REPL</i> mù¾e objevit
je¹tì pøedtím, ne¾ je výpoèet dokonèen &ndash; to nám samozøejmì vùbec nevadí,
proto¾e ani funkce <strong>fibonacci</strong>, ani její &bdquo;obalující&ldquo;
funkce <strong>fib20, fib25</strong> a <strong>fib30</strong> nemají vedlej¹í
efekty. Co se v¹ak stane v&nbsp;pøípadì, kdy vedlej¹í efekt naschvál pøidáme,
napøíklad takovým zpùsobem, ¾e ka¾dá z&nbsp;pomocných funkcí vytiskne text na
zaèátku a na konci výpoètu? Mù¾eme si to snadno vyzkou¹et:</p>

<pre>
(defn fib20
    []
    (println "pocitam fibonacci 20")
    (println "dokonceno fibonacci 20 ="
        (fibonacci 20)))
&nbsp;
(defn fib25
    []
    (println "pocitam fibonacci 25")
    (println "dokonceno fibonacci 25 ="
        (fibonacci 25)))
&nbsp;
(defn fib30
    []
    (println "pocitam fibonacci30")
    (println "dokonceno fibonacci 30 ="
        (fibonacci 30)))
</pre>

<p>Sice jsme kvùli výpisu zprávy ztratili výsledek výpoètu, to nám v¹ak pro
ilustraci funkce makra <strong>pcalls</strong> nemusí vadit. Je¹tì si vytvoøíme
pomocnou funkci <strong>compute_all</strong>, která spustí výpoèet a ihned poté
vypí¹e na standardní výstup zprávu &bdquo;konec vypoctu???&ldquo;:</p>

<pre>
(defn compute_all
    []
    (println "zacatek vypoctu")
    (def result (pcalls fib20 fib25 fib30 fib30))
    (println "konec vypoctu???")
    result)
</pre>

<p>Zajímavá vìc se stane po spu¹tìní této funkce:</p>

<pre>
user=&gt; (compute_all)
<strong>zacatek vypoctu</strong>
pocitam fibonacci 20
pocitam fibonacci 25
<strong>konec vypoctu???</strong>
<strong>(</strong>pocitam fibonacci30
pocitam fibonacci30
dokonceno fibonacci 20 = 6765
dokonceno fibonacci 25 = 75025
<strong>nil</strong> dokonceno fibonacci 30 = 832040
dokonceno fibonacci 30 = 832040
<strong>nil nil nil)</strong>
</pre>

<p>V&nbsp;pøedchozích øádcích jsou navzájem promíchány tøi typy zpráv. Jsou to
zprávy ti¹tìné pomocnými funkcemi <strong>fib20</strong>,
<strong>fib25</strong> a <strong>fib30</strong>, které jsou spu¹tìny paralelnì,
co¾ je ostatnì z&nbsp;výpisu patrné. Dal¹í typ zpráv &bdquo;zacatek
vypoctu&ldquo; a &bdquo;konec vypoctu???&ldquo; tiskne funkce
<strong>compute_all</strong> a pov¹imnìte si, ¾e tato funkce vypí¹e
&bdquo;konec vypoctu???&ldquo; je¹tì pøedtím, ne¾ je výpoèet skuteènì dokonèen.
To nám v¹ak nevadí, proto¾e do promìnné <strong>result</strong> je ulo¾ena lazy
sekvence, která se vyhodnotí ve chvíli, kdy je to potøeba, popø.&nbsp;se
nevyhodnotí nikdy. Vyhodnocení jsme si vynutili posledním výrazem ve funkci
<strong>compute_all</strong>, kterým øíkáme, ¾e se má vrátit lazy sekvence.
K&nbsp;vyhodnocení dojde z&nbsp;toho dùvodu, ¾e je funkce
<strong>compute_all</strong> volána ze smyèky <i>REPL</i> a ta samozøejmì
vypí¹e ka¾dou vyhodnocenou formu &ndash; v&nbsp;tomto pøípadì jsou to tøi
hodnoty <strong>nil</strong> (bylo by jistì mo¾né funkce <strong>fib*</strong>
upravit tak, aby tyto funkce vracely správné hodnoty, to by v¹ak ji¾ vy¾adovalo
pou¾ití formy <strong>let</strong>, s&nbsp;ní¾ jsme se prozatím v&nbsp;tomto
seriálu neseznámili).</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Zpùsob pou¾ití makra <strong>pvalues</strong></h2>

<p>Z&nbsp;trojice funkcí a maker <strong>pmap</strong>, <strong>pcalls</strong>
a <strong>pvalues</strong> nám ji¾ zbývá popsat pouze makro
<strong>pvalues</strong>. To je ve skuteènosti na pou¾ití velmi jednoduché,
proto¾e umo¾òuje paralelnì vyhodnotit libovolné mno¾ství forem (výrazù),
pøièem¾ výsledkem volání makra <strong>pvalues</strong> je lazy sekvence
obsahující hodnoty v¹ech vyhodnocených forem. Mù¾e se jednat o zcela libovolné
formy, tj.&nbsp;o literály, volání funkcí s&nbsp;rùznými parametry atd:</p>

<pre>
user=&gt; (pvalues true nil "retezec" (/ 1 2) (* 6 7) (fibonacci 35))
(true nil "retezec" 1/2 42 9227465)
</pre>

<p>Pokud zùstaneme u na¹eho dosti umìlého pøíkladu s&nbsp;výpoètem prvkù
Fibonacciho øady, mù¾eme namísto volání <strong>pcalls</strong> (kde bylo nutné
pou¾ít buï anonymní funkce nebo bezparametrické &bdquo;obalové&ldquo; funkce)
pou¾ít makro <strong>pvalues</strong> následujícím zpùsobem:</p>

<pre>
; zavolání funkce Fibonacci
; s následným vyhodnocením lazy sekvence:
user=&gt; (pvalues (fibonacci 20) (fibonacci 25) (fibonacci 30))
(6765 75025 832040)
</pre>

<pre>
; výsledek je mo¾né skuteènì pou¾ít jako jakoukoli jinou lazy sekvenci
user=&gt; (filter odd? (pvalues (fibonacci 20) (fibonacci 25) (fibonacci 30)))
(6765 75025)
</pre>

<pre>
; samozøejmì i velmi u¾iteènou funkcí reduce
user=&gt; (reduce + (pvalues (fibonacci 20) (fibonacci 25) (fibonacci 30)))
913830
</pre>

<p>Vzhledem k&nbsp;tomu, ¾e i makro <strong>pcalls</strong> vrací lazy
sekvenci, je zaji¹tìno i líné vyhodnocení výsledkù a¾ ve chvíli, kdy jsou tyto
výsledky skuteènì zapotøebí:</p>

<pre>
user=&gt; (def results (pvalues (fibonacci 20) (fibonacci 25) (fibonacci 35)))
#'user/results
&nbsp;
user=&gt; results
(6765 75025 9227465)
</pre>

<p>Poznámka: makro <strong>pvalues</strong> je ve skuteènosti vytvoøeno takovým
zpùsobem, ¾e internì pou¾ívá funkci <strong>pcalls</strong>. O makrech jsme si
prozatím neøíkali ¾ádné podrobnosti, ov¹em ze zdrojového kódu makra
<strong>pvalues</strong> je zøejmé, ¾e se funkce <strong>pcalls</strong>
skuteènì vyu¾ívá (co znamenají znaky ` @ atd. si øekneme pravdìpodobnì a¾
v&nbsp;osmé èásti tohoto podseriálu):</p>

<pre>
(defmacro pvalues
  [&amp; exprs]
  `(pcalls ~@(map #(list `fn [] %) exprs)))
</pre>

<p>Poznámka^2: zajímavé takté¾ je, ¾e samotná funkce <strong>pcalls</strong>
internì volá funkci <strong>pmap</strong>, co¾ vlastnì znamená, ¾e právì
<strong>pmap</strong> je jedinou &bdquo;paralelní&ldquo; funkcí, která musí být
podporována v&nbsp;jádru jazyka Clojure a zbylá dvojice
<strong>pcalls+pvalues</strong> je ji¾ øe¹itelná v&nbsp;samotném Clojure:</p>

<pre>
(defn pcalls
  [&amp; fns] (pmap #(%) fns))
</pre>

<p>(znak % v&nbsp;anonymní funkci zde odpovídá %1, význam znaku &amp; si
vysvìtlíme pøí¹tì; zde jen bez dal¹ích podrobností uvedu, ¾e se v¹echny
skuteèné argumenty pøi volání funkce <strong>pcalls</strong> vlo¾í do
<strong>fns</strong>, tak¾e je lze zpracovat jako bì¾nou sekvenci).</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Spu¹tìní výpoètù v&nbsp;samostatných vláknech pomocí <strong>future</strong></h2>

<p>Pou¾ití trojice funkcí/maker <strong>pmap+pcalls+pvalues</strong> není
v&nbsp;¾ádném pøípadì jedinou mo¾ností, jak v&nbsp;programovacím jazyce Clojure
zapisovat algoritmy zpracovávané paralelnì. Velmi elegantní a pøitom jednoduchý
zpùsob spu¹tìní paralelního výpoètu pøedstavuje pou¾ití takzvaných
<i>futures</i>. Mimochodem, jedná se o technologii, která existuje i
v&nbsp;knihovnách programovacího jazyka Java (dokonce ji¾ od verze 5.0), i kdy¾
v&nbsp;Javì se pravdìpodobnì jedná o ménì známé API &ndash; osobnì si v¹ak
myslím, ¾e vyu¾ití <i>futures</i> v&nbsp;Javì je mnohdy výhodnìj¹í, ne¾
explicitní tvorba vláken, synchronizovaných metod/blokù a dal¹ích
nízkoúrovòových prostøedkù.</p>

<p>Co se v¹ak vlastnì pod pojmem <i>futures</i> skrývá? Kromì názvu jednoho
typu finanèního derivátu :-) pøedstavuje future(s) výpoèet, který bì¾í
asynchronnì k&nbsp;hlavnímu vláknu aplikace. U¾ivatel pouze výpoèet spustí a
teprve ve chvíli, kdy potøebuje výsledek tohoto výpoètu, zaène systém øe¹it,
<strong>jakým zpùsobem</strong> má asynchronní výpoèet ukonèit, tj.&nbsp;jak má
provést synchronizaci obou vláken. V&nbsp;ideálním pøípadì je výpoèet ji¾
dokonèen, tak¾e se pøímo pou¾ije jeho výsledek, v&nbsp;pøípadì opaèném se a¾
pøi <strong>ètení</strong> výsledku poèká na dokonèení výpoètu. Je samozøejmé,
¾e jakýkoli pøístup ke sdíleným prostøedkùm musí být omezen, co¾ v¹ak
v&nbsp;programovacím jazyce, jeho¾ hodnoty jsou nemìnitelné, není a¾ tak velký
problém (Clojure navíc pou¾ívá ponìkud jinou sémantiku zmìny stavu, ne¾ je tomu
v&nbsp;bì¾ných jazycích s&nbsp;promìnnými &ndash; více viz následující èást
tohoto seriálu).</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Zpùsoby øízení &bdquo;future&ldquo; výpoètù</h2>

<p>Podívejme se nyní, jak by bylo mo¾né paralelnì spustit dva výpoèty 35. èlenu
Fibonacci øady (pokud máte rychlý poèítaè, mù¾ete si index vypoèteného èlenu
patøiènì zvý¹it):</p>

<pre>
; opìt klasický paralelní zápis funkce fibonacci
&nbsp;
(defn fibonacci
    [n]
    (if (&gt; n 2)
        n
        (+ (fibonacci (- n 2)) (fibonacci (- n 1)))))
</pre>

<pre>
; namísto pøímého volání funkce fibonacci v¹ak spustíme
; dva asynchronní výpoèty s vyu¾itím (future funkce)
&nbsp;
user=&gt; (def future_fibonacci1 (future (fibonacci 35)))
#'user/future_fibonacci1
&nbsp;
user=&gt; (def future_fibonacci2 (future (fibonacci 35)))
#'user/future_fibonacci2
</pre>

<p>Oba výpoèty <strong>(fibonacci 35)</strong> byly spu¹tìny
v&nbsp;samostatných vláknech, co¾ mj.&nbsp;znamená, ¾e smyèka <i>REPL</i>
nemusí èekat na výsledek výpoètu a nabídne výzvu (prompt) prakticky ihned po
zadání obou pøedchozích pøíkazù. Jak se v¹ak dostaneme k&nbsp;výsledku?
Postaèuje kdekoli v&nbsp;programu èi pøímo v&nbsp;<i>REPL</i> zavolat
<strong>deref</strong>, jemu¾ se pøedá název future objektu:</p>

<pre>
user=&gt; (deref future_fibonacci1)
9227465
&nbsp;
user=&gt; (deref future_fibonacci2)
9227465
</pre>

<p>Co se vlastnì stalo? Vzhledem k&nbsp;tomu, ¾e smyèka <i>REPL</i> bì¾í
v&nbsp;jiném vláknì, ne¾ samotný výpoèet a nyní potøebuje získat návratovou
hodnotu tohoto asynchronního výpoètu, dojde k&nbsp;èekání na dokonèení
výpoètového vlákna spjatého se future objektem. Jakmile je výpoèet dokonèen, je
získán jeho výsledek a výpoètové vlákno je zru¹eno, resp.&nbsp;pøesnìji øeèeno
je vráceno do poolu, aby mohlo být kdykoli pozdìji znovu vyu¾ito (to je
dùle¾ité v&nbsp;pøípadì, ¾e se asynchronní výpoèty == futures pou¾ívají
v&nbsp;aplikaci èastìji).</p>

<p>Vzhledem k&nbsp;tomu, ¾e <strong>deref</strong> se v&nbsp;multivláknových
programech pou¾ívá pomìrnì èasto, je mo¾né pou¾ít zkrácený zpùsob zápisu, kdy
se namísto <strong>(deref foo)</strong> pou¾ije pouze <strong>@foo</strong>,
tj.&nbsp;neuvádí se ani kulaté závorky. Ekvivalentem pøedchozího pøíkladu by
tedy byl následující výpoèet:</p>

<pre>
user=&gt; (def future_fibonacci1 (future (fibonacci 35)))
#'user/future_fibonacci1
&nbsp;
user=&gt; (def future_fibonacci2 (future (fibonacci 35)))
#'user/future_fibonacci2
user=&gt; @future_fibonacci1
9227465
&nbsp;
user=&gt; @future_fibonacci2
9227465
</pre>

<p>Poznámka: hodnota 35 byla zvolena tak, aby výpoèet trval pøibli¾nì 10 sekund
na mém postar¹ím (no...velmi postar¹ím :-) poèítaèi. Poèítaèe vá¾ených ètenáøù
budou s&nbsp;velkou pravdìpodobnì mnohem rychlej¹í, tak¾e si prosím zvolte
pøíslu¹nì vìt¹í konstantu, popø.&nbsp;je mo¾né namísto výpoètu pou¾ít pouhé
èekání &ndash; ov¹em v&nbsp;tomto pøípadì neuvidíte ¾ádné zatí¾ení
v&nbsp;programu <strong>top</strong> èi <strong>htop</strong>.</p>

<p>Èekání, resp.&nbsp;pozastavení aktuálního vlákna lze provést jednodu¹e
zavoláním pøíslu¹né javovské funkce:</p>

<pre>
(Thread/sleep doba_cekani_v_milisekundach)
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Clojure home page<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/">http://java.sun.com/developer/technicalArticles/DynTypeLang/</a>
</li>

<li>JSR 223: Scripting for the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=223">http://jcp.org/en/jsr/detail?id=223</a>
</li>

<li>JSR 292: Supporting Dynamically Typed Languages on the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=292">http://jcp.org/en/jsr/detail?id=292</a>
</li>

<li>Java 7: A complete invokedynamic example<br />
<a href="http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html">http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html</a>
</li>

<li>InvokeDynamic: Actually Useful?<br />
<a href="http://blog.headius.com/2007/01/invokedynamic-actually-useful.html">http://blog.headius.com/2007/01/invokedynamic-actually-useful.html</a>
</li>

<li>A First Taste of InvokeDynamic<br />
<a href="http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html">http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html</a>
</li>

<li>Java 6 try/finally compilation without jsr/ret<br />
<a href="http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html">http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Root.cz: Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM<br />
<a href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/</a></a>
</li>

<li>Root.cz: JamVM aneb alternativa k HotSpotu nejenom pro embedded zaøízení a chytré telefony<br />
<a href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>FindBugs<br />
<a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a>
</li>

<li>GNU Classpath<br />
<a href="www.gnu.org/s/classpath/">www.gnu.org/s/classpath/</a></li>

<li>Java VMs Compared<br />
<a href="http://bugblogger.com/java-vms-compared-160/">http://bugblogger.com/java-vms-compared-160/</a>
</li>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Scala Programming Language<br />
<a href="http://www.scala-lang.org/">http://www.scala-lang.org/</a>
</li>

<li>Run Scala in Apache Tomcat in 10 minutes<br />
<a href="http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes">http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes</a>
</li>

<li>Fast Web Development With Scala<br />
<a href="http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html">http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html</a>
</li>

<li>Top five scripting languages on the JVM<br />
<a href="http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855">http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>CloseableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html">http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

