<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (9 - dal¹í vlastnosti trasovacího JITu)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (9 - dal¹í vlastnosti trasovacího JITu)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dal¹í èásti seriálu o just in time pøekladaèi nazvaném LuaJIT budeme pokraèovat v popisu funkce trasovacího pøekladaèe. Minule jsme si ukázali, jak trasovací pøekladaè doká¾e detekovat èasto pou¾ívané programové smyèky, dnes se podíváme na zpùsob detekce vìtví ve smyèkách a takté¾ detekce funkcí volaných s velkou frekvencí.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (9 - dal¹í vlastnosti trasovacího JITu)</a></p>
<p><a href="#k02">2. Trasovací JIT a programové smyèky obsahující rozvìtvení</a></p>
<p><a href="#k021">&nbsp;&nbsp;&nbsp;2.1 Demonstraèní pøíklad <strong>test48.lua</strong> &ndash; programová smyèka s&nbsp;rozvìtvením (malý poèet iterací)</a></p>
<p><a href="#k022">&nbsp;&nbsp;&nbsp;2.2 Demonstraèní pøíklad <strong>test49.lua</strong> &ndash; programová smyèka s&nbsp;rozvìtvením (velký poèet iterací)</a></p>
<p><a href="#k03">3. Programové smyèky se slo¾itìj¹ím systémem vìtvení</a></p>
<p><a href="#k031">&nbsp;&nbsp;&nbsp;3.1 Demonstraèní pøíklad <strong>test50.lua</strong> &ndash; programová smyèka se slo¾itìj¹ím rozvìtvením</a></p>
<p><a href="#k032">&nbsp;&nbsp;&nbsp;3.2 Demonstraèní pøíklad <strong>test51.lua</strong> &ndash; vnoøené vìtve</a></p>
<p><a href="#k04">4. Trasovací JIT a volání funkcí</a></p>
<p><a href="#k05">5. Zji¹tìní, která funkce se má JITovat</a></p>
<p><a href="#k06">6. Demonstraèní pøíklady</a></p>
<p><a href="#k061">&nbsp;&nbsp;&nbsp;6.1 Demonstraèní pøíklad <strong>test52.lua</strong> &ndash; opakované volání funkce</a></p>
<p><a href="#k062">&nbsp;&nbsp;&nbsp;6.2 Demonstraèní pøíklad <strong>test53.lua</strong> &ndash; opakované volání funkce z&nbsp;programové smyèky</a></p>
<p><a href="#k07">7. Zdrojové kódy v¹ech ¹esti dne¹ních demonstraèních pøíkladù</a></p>
<p><a href="#k08">8. Literatura</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (9 - dal¹í vlastnosti trasovacího JITu)</h2>

<p><a
href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-8-zakladni-vlastnosti-trasovaciho-jitu/">V&nbsp;pøedchozí èásti</a> <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu
(nejenom) o just in time pøekladaèi LuaJIT</a> jsme si øekli základní informace
o takzvaných trasovacích JIT pøekladaèích, které se v&nbsp;mnoha ohledech
chovají odli¹nì od známìj¹ích JIT pøekladaèù typu hot spot. Trasovací JIT
pøekladaèe i hot spot JITy se soustøedí na detekci èasto pou¾ívaných
programových smyèek a funkcí volaných s&nbsp;velkou frekvencí. Ov¹em na rozdíl
od klasických hot spot pøekladaèù se trasovací JIT pøekladaèe zamìøují na
sledování sekvence generovaných a následnì provádìných instrukcí a nikoli na
(potenciálnì slo¾itou) analýzu bajtkódu a u¾ vùbec ne na analýzu zdrojového
kódu (právì zde se ukazuje, ¾e vhodnì navr¾ený bajtkód popø.&nbsp;mezijazyk
mù¾e významným zpùsobem zjednodu¹it nebo naopak ztí¾it práci JIT pøekladaèù;
problémy tohoto typu jsou patrné i v&nbsp;bajtkódu JVM).</p>

<p>Sledování a následná analýza sekvence generovaných a následnì provádìných
instrukcí (tato sekvence se nazývá <i>stopa</i> neboli <i>trace</i>)
trasovacími JIT pøekladaèi vlastnì automaticky vede k&nbsp;tomu, ¾e mohou být
eliminovány nìkteré podmínìné skoky ve vytváøeném nativním (strojovém) kódu
(pøedstavme si programovou smyèku s&nbsp;vnitøním rozvìtvením). Na druhou
stranu se v¹ak do nativního kódu musí navíc vkládat strojové instrukce
testující, zda se bìh programu skuteènì ubírá správným smìrem (tyto testovací
instrukce v¹ak v&nbsp;ideálním pøípadì nevedou k&nbsp;provedení podmínìných
skokù, co¾ je u moderních mikroprocesorù dosti nároèná operace). Nezávisle na
tom, zda je pou¾it hot spot JIT èi trasovací JIT, je dal¹í fáze pøekladu,
tj.&nbsp;optimalizace, provádìna s&nbsp;vyu¾itím podobných technologií. Setkáme
se zde s&nbsp;eliminací mrtvého kódu, rozbalením smyèek, vlo¾ením tìla krat¹ích
funkcí do místa, kde se pùvodnì tato funkce volala apod.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Trasovací JIT a programové smyèky obsahující rozvìtvení</h2>

<p>Zatímco detekce programových smyèek trasovacími JIT je pomìrnì jednoduchá
úloha, které je navíc v&nbsp;pøípadì <i>LuaJIT</i> je¹tì ulehèena zpùsobem
pøekladu smyèek do bajtkódu, je detekce rozvìtvení ve smyèkách ji¾ slo¾itìj¹í,
a to zejména z&nbsp;toho dùvodu, ¾e trasovací JIT pøekladaè vlastnì nemá
&bdquo;pøedstavu&ldquo; o celkové struktuøe provádìného algoritmu, pouze doká¾e
detekovat sekvenci opakujících se instrukcí. Podívejme se proto na nìkolik
demonstraèních pøíkladù, v&nbsp;nich¾ se vyskytuje poèítaná programová smyèka a
uvnitø této smyèky rozvìtvení provádìné na základì nìjaké podmínky. U v¹ech
následujících pøíkladù bude uveden jejich zdrojový kód, standardní výstup a
takté¾ zprávy vypisované tracerem pøi specifikaci volby <strong>-jv</strong>.
Právì výstup z&nbsp;traceru nám dá pomìrnì dobrou pøedstavu o tom, jaká èást
programového kódu ji¾ byla JITována a jaká nikoli. Výsledky mohou být
v&nbsp;nìkterých pøípadech pøekvapující, o èem¾ autor <i>LuaJITu</i> su¹e øíká
&bdquo;race compilers are full of surprises like this &ndash; have fun!
:-)&ldquo;</p>



<p><a name="k021"></a></p>
<h3 id="k021">2.1 Demonstraèní pøíklad <strong>test48.lua</strong> &ndash; programová smyèka s&nbsp;rozvìtvením (malý poèet iterací)</h3>

<p>Dne¹ní první demonstraèní pøíklad je velmi jednoduchý, proto¾e obsahuje
pouze jedinou poèítanou programovou smyèku, v&nbsp;ní¾ se nachází jedno
rozvìtvení &ndash; pøíkazová struktura <strong>if-then-end</strong>. Pov¹imnìte
si, ¾e poèet iterací programové smyèky je nastaven na 100, tak¾e se tato smyèka
dostane do skupiny <i>hot loops</i> a provede se její pøeklad do nativního kódu
(poèet iterací pøekroèí magickou hodnotu <strong>hotloop=56</strong>). Naproti
tomu se interní rozvìtvení provede pouze padesátkrát, co¾ znamená, ¾e tato èást
programového kódu se nebude automaticky pøekládat a to jednodu¹e z&nbsp;toho
dùvodu, ¾e se sice detekuje stopa (<i>trace</i>), ale ta nebude provádìna tak
èasto, aby si to vy¾ádalo pou¾ití potenciálnì nároèného JIT pøekladu. Tato
programová smyèka tedy bude pøelo¾ena jen z&nbsp;poloviny a bude se pøecházet
mezi interpretovaným bajtkódem a nativním kódem:</p>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 48.</i>
<i>--</i>
<i>-- Test JITu - programová smyèka s rozvìtvením.</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>-- deklarace a inicializace lokálních promìnných</i>
<strong>local</strong> i
<strong>local</strong> x = 0
<strong>local</strong> y = 0
&nbsp;
&nbsp;
&nbsp;
<i>-- programová smyèka s rozvìtvením</i>
<strong>for</strong> i = 1,100 <strong>do</strong>
    x = x + 1
    <strong>if</strong> i &gt; 50 <strong>then</strong>
        y = y + 1
    <strong>end</strong>
<strong>end</strong>
&nbsp;
print(x, y)
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Finito.</i>
<i>--</i>
</pre>

<p>Výsledek výpoètu provedeného prvním demonstraèním pøíkladem:</p>

<pre>
100     50
</pre>

<p>Z&nbsp;výpisu trasovacích informací získaných díky pøepínaèi
<strong>-jv</strong> je patrné, ¾e se detekovala a JITovala skuteènì pouze
poèítaná programová smyèka a nikoli ji¾ rozvìtvení uvnitø této smyèky:</p>

<pre>
[TRACE   1 test48.lua:17 loop]
</pre>



<p><a name="k022"></a></p>
<h3 id="k022">2.2 Demonstraèní pøíklad <strong>test49.lua</strong> &ndash; programová smyèka s&nbsp;rozvìtvením (velký poèet iterací)</h3>

<p>Donutit <i>LuaJIT</i> k&nbsp;tomu, aby provedl i pøeklad podmínky umístìné
uvnitø poèítané programové smyèky, je ve skuteènosti velmi snadné &ndash;
postaèuje toti¾ zvý¹it poèet iterací smyèky a souèasnì i poèet vstupù do
podmínìného bloku. Dne¹ní druhý demonstraèní pøíklad pojmenovaný
<strong>test49.lua</strong> se od pøíkladu pøedchozího li¹í pouze v&nbsp;tìchto
dvou detailech (viz limit na poèet iterací a porovnání poèitadla
s&nbsp;hodnotou 500):</p>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 49.</i>
<i>--</i>
<i>-- Test JITu - programová smyèka s rozvìtvením, zvý¹ení poètu iteraci.</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>-- deklarace a inicializace lokálních promìnných</i>
<strong>local</strong> i
<strong>local</strong> x = 0
<strong>local</strong> y = 0
&nbsp;
&nbsp;
&nbsp;
<i>-- programová smyèka s rozvìtvením</i>
<strong>for</strong> i = 1,1000 <strong>do</strong>
    x = x + 1
    <strong>if</strong> i &gt; 500 <strong>then</strong>
        y = y + 1
    <strong>end</strong>
<strong>end</strong>
&nbsp;
print(x, y)
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Finito.</i>
<i>--</i>
</pre>

<p>Výsledek výpoètu provedeného prvním demonstraèním pøíkladem:</p>

<pre>
1000    500
</pre>

<p>Výpis trasovacích informací, ze kterého je patrné, ¾e se správnì detekovala
a pøelo¾ila jak celá programová smyèka (první øádek), tak i blok pøíkazù
umístìný v&nbsp;podmínce (druhý øádek):</p>

<pre>
[TRACE   1 test49.lua:17 loop]
[TRACE   2 (1/1) test49.lua:20 -&gt; 1]
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Programové smyèky se slo¾itìj¹ím systémem vìtvení</h2>

<p>Trasovací JIT pøekladaèe se samozøejmì musí umìt vyrovnat i se slo¾itìj¹ím
systémem vìtvení provádìného uvnitø programových smyèek. Ve skuteènosti je to
dokonce nutnost, proto¾e jen zcela triviální programové smyèky neobsahují vìt¹í
mno¾ství programové logiky a právì takové smyèky typicky bývají jádrem velkého
mno¾ství algoritmù. Aby bylo mo¾né si otestovat chování <i>LuaJITu</i> i
v&nbsp;takovýchto pøípadech, byly vytvoøeny dal¹í dva demonstraèní pøíklady
pojmenované <strong>test50.lua</strong> a <strong>test51.lua</strong>,
v&nbsp;nich¾ je (opìt) pou¾ita vnìj¹í poèítaná programová smyèka s&nbsp;tisíci
iteracemi. Takto velký poèet iterací si vynutí pou¾ití JIT pøekladu, o èem¾ se
ostatnì sami pøesvìdèíme.</p>



<p><a name="k031"></a></p>
<h3 id="k031">3.1 Demonstraèní pøíklad <strong>test50.lua</strong> &ndash; programová smyèka se slo¾itìj¹ím rozvìtvením</h3>

<p>V&nbsp;demonstraèním pøíkladu <strong>test50.lua</strong> se ve vnìj¹í
programové smyèce nachází hned tøi vìtve. Vzhledem k&nbsp;tomu, ¾e je poèet
iterací nastaven na hodnotu 1000 a podmínky ve vìtvích umo¾ní vstup do
podmínìných blokù v&nbsp;1000-100=900, 1000-200=800 a 1000-300=700 iteracích,
budou detekovány a následnì pøelo¾eny celkem ètyøi stopy &ndash; vlastní
programová smyèka a tøi stopy obsahující jednotlivé vìtve:</p>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 50.</i>
<i>--</i>
<i>-- Test JITu - programová smyèka se slo¾itìj¹ím rozvìtvením</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>-- deklarace a inicializace lokálních promìnných</i>
<strong>local</strong> i
<strong>local</strong> x = 0
<strong>local</strong> y = 0
<strong>local</strong> z = 0
&nbsp;
&nbsp;
&nbsp;
<i>-- programová smyèka s rozvìtvením</i>
<strong>for</strong> i = 1,1000 <strong>do</strong>
    <strong>if</strong> i &gt; 100 <strong>then</strong>
        x = x + 1
    <strong>end</strong>
    <strong>if</strong> i &gt; 200 <strong>then</strong>
        y = y + 1
    <strong>end</strong>
    <strong>if</strong> i &gt; 300 <strong>then</strong>
        z = z + 1
    <strong>end</strong>
<strong>end</strong>
&nbsp;
print(x, y, z)
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Finito.</i>
<i>--</i>
</pre>

<p>Výstupní hodnoty tohoto demonstraèního pøíkladu nám ve skuteènosti øíkají,
kolikrát se provedly jednotlivé podmínìné bloky:</p>

<pre>
900     800     700
</pre>

<p>Nejzajímavìj¹í informace o trasování získáme opìt s&nbsp;vyu¾itím pøepínaèe
<strong>-jv</strong>:</p>

<pre>
[TRACE   1 test50.lua:18 loop]
[TRACE   2 (1/1) test50.lua:20 -&gt; 1]
[TRACE   3 (2/1) test50.lua:23 -&gt; 1]
[TRACE   4 (3/1) test50.lua:26 -&gt; 1]
</pre>

<p>Z&nbsp;tohoto výpisu je patrné, ¾e smyèka byla detekována na øádku 18, co¾
je samozøejmì správné. Posléze byla detekována nová stopa zaèínající na øádku
20, co¾ je takté¾ korektní, proto¾e právì zde zaèíná první podmínìný blok. Tato
stopa je navázána na smyèku (viz hodnota 1 v&nbsp;závorce). Dal¹í stopa zaèíná
na øádku 23 a poslední stopa pak na øádku 26. Pov¹imnìte si, ¾e detekce stop je
provedena ve správném poøadí, proto¾e nejprve je provedeno (minimálnì) 56
iterací vnìj¹í programové smyèky, poté se detekuje vstup do prvního podmínìného
bloku (ve 157 iteraci), následnì vstup do druhého bloku (iterace èíslo 257) a
koneènì v&nbsp;iteraci 357 do bloku tøetího. Co se v¹ak stane, kdy¾ se prohodí
hodnoty 100, 200 a 300 v&nbsp;tìchto blocích? Podle oèekávání se stopy budou
detekovat v&nbsp;opaèném poøadí:</p>

<pre>
[TRACE   1 test50.lua:18 loop]
[TRACE   2 (1/3) test50.lua:26 -&gt; 1]
[TRACE   3 (1/2) test50.lua:23 -&gt; 1]
[TRACE   4 (1/1) test50.lua:20 -&gt; 1]
</pre>

<p>Pro úplnost si uveïme upravený pøíklad:</p>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 50 (úprava!!!).</i>
<i>--</i>
<i>-- Test JITu - programová smyèka se slo¾itìj¹ím rozvìtvením</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>-- deklarace a inicializace lokálních promìnných</i>
<strong>local</strong> i
<strong>local</strong> x = 0
<strong>local</strong> y = 0
<strong>local</strong> z = 0
&nbsp;
&nbsp;
&nbsp;
<i>-- programová smyèka s rozvìtvením</i>
<strong>for</strong> i = 1,1000 <strong>do</strong>
    <strong>if</strong> i &gt; 300 <strong>then</strong>
        x = x + 1
    <strong>end</strong>
    <strong>if</strong> i &gt; 200 <strong>then</strong>
        y = y + 1
    <strong>end</strong>
    <strong>if</strong> i &gt; 100 <strong>then</strong>
        z = z + 1
    <strong>end</strong>
<strong>end</strong>
&nbsp;
print(x, y, z)
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Finito.</i>
<i>--</i>
</pre>



<p><a name="k032"></a></p>
<h3 id="k032">3.2 Demonstraèní pøíklad <strong>test51.lua</strong> &ndash; vnoøené vìtve</h3>

<p>Ji¾ tak nelehký úkol trasovacího JIT pøekladaèe mù¾eme udìlat ponìkud
slo¾itìj¹í tím, ¾e podmínky budou vzájemnì zanoøeny. Tím se samozøejmì zcela
zmìní struktury jednotlivých stop. Nejprve se v¹ak podívejme na zdrojový kód
pøíkladu, v&nbsp;nìm¾ se nachází vnìj¹í poèítaná programová smyèka a trojice
vnoøených vìtví:</p>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 51.</i>
<i>--</i>
<i>-- Test JITu - programová smyèka se slo¾itìj¹ím rozvìtvením</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>-- deklarace a inicializace lokálních promìnných</i>
<strong>local</strong> i
<strong>local</strong> x = 0
<strong>local</strong> y = 0
<strong>local</strong> z = 0
&nbsp;
&nbsp;
&nbsp;
<i>-- programová smyèka s rozvìtvením</i>
<strong>for</strong> i = 1,1000 <strong>do</strong>
    <strong>if</strong> i &gt; 100 <strong>then</strong>
        x = x + 1
        <strong>if</strong> i &gt; 200 <strong>then</strong>
            y = y + 1
            <strong>if</strong> i &gt; 300 <strong>then</strong>
                z = z + 1
            <strong>end</strong>
        <strong>end</strong>
    <strong>end</strong>
<strong>end</strong>
&nbsp;
print(x, y, z)
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Finito.</i>
<i>--</i>
</pre>

<p>Podobnì jako tomu bylo v&nbsp;pøedchozím pøíkladu, i zde se na výstup vypí¹e
poèet vstupù do jednotlivých podmínìných blokù:</p>

<pre>
900     800     700
</pre>

<p>Výsledek trasování mo¾ná nìkoho pøekvapí svou jednoduchostí:</p>

<pre>
[TRACE   1 test51.lua:18 loop]
[TRACE   2 (1/1) test51.lua:20 -&gt; 1]
[TRACE   3 (2/1) test51.lua:22 -&gt; 1]
[TRACE   4 (3/1) test51.lua:24 -&gt; 1]
</pre>

<p>Mù¾eme zde (opìt) vidìt detekci vnìj¹í programové smyèky, co¾ pravdìpodobnì
ji¾ nikoho nepøekvapí. Následnì jsou detekovány tøi dal¹í stopy na øádcích 20,
22 a 24. To je mo¾ná ponìkud zvlá¹tní, kdy¾ si uvìdomíme, ¾e velmi podobný
výsledek jsme získali z&nbsp;pøedchozího pøíkladu (odli¹ují se jen èísla
øádkù, to kvùli zápisu <strong>end</strong> v&nbsp;pøedchozím pøíkladu):</p>

<pre>
[TRACE   1 test50.lua:18 loop]
[TRACE   2 (1/1) test50.lua:20 -&gt; 1]
[TRACE   3 (2/1) test50.lua:23 -&gt; 1]
[TRACE   4 (3/1) test50.lua:26 -&gt; 1]
</pre>

<p>Ve skuteènosti se v¹ak trasovací JIT zachoval správnì, proto¾e
implementovaná logika je stejná :-) Toto je jedna ze základních vlastností
v¹ech trasovacích JITù &ndash; nezávisle na zdrojovém textu sledují, co se dìje
v&nbsp;runtime.</p>

<p>Zkusme si pøíklad je¹tì více upravit a vytvoøit poøádné bludi¹tì:</p>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 51 (upraveno!!!).</i>
<i>--</i>
<i>-- Test JITu - programová smyèka se slo¾itìj¹ím rozvìtvením</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>-- deklarace a inicializace lokálních promìnných</i>
<strong>local</strong> i
<strong>local</strong> x = 0
<strong>local</strong> y = 0
<strong>local</strong> z = 0
&nbsp;
&nbsp;
&nbsp;
<i>-- programová smyèka s rozvìtvením</i>
<strong>for</strong> i = 1,1000 <strong>do</strong>
    <strong>if</strong> i &gt; 100 <strong>then</strong>
        x = x + 1
        <strong>if</strong> i &gt; 200 <strong>then</strong>
            y = y + 1
            <strong>if</strong> i &gt; 300 <strong>then</strong>
                z = z + 1
            <strong>end</strong>
        <strong>end</strong>
    <strong>end</strong>
    <strong>if</strong> i &gt; 60 <strong>then</strong>
        x = x * 1.5
        <strong>if</strong> i &gt; 400 <strong>then</strong>
            y = y * 1.5
            <strong>if</strong> i &gt; 600 <strong>then</strong>
                z = z * 1.5
            <strong>end</strong>
        <strong>end</strong>
    <strong>end</strong>
<strong>end</strong>
&nbsp;
print(x, y, z)
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Finito.</i>
<i>--</i>
</pre>

<p>Trasovací modul se nyní tro¹ku zapotí, proto¾e nalezne a JITuje hned sedm
stop:</p>

<pre>
[TRACE   1 test51.lua:18 loop]
[TRACE   2 (1/2) test51.lua:29 -&gt; 1]
[TRACE   3 (1/1) test51.lua:20 -&gt; 1]
[TRACE   4 (3/1) test51.lua:22 -&gt; 1]
[TRACE   5 (4/1) test51.lua:24 -&gt; 1]
[TRACE   6 (5/2) test51.lua:31 -&gt; 1]
[TRACE   7 (6/1) test51.lua:33 -&gt; 1]
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Trasovací JIT a volání funkcí</h2>

<p>Ji¾ v&nbsp;pøedchozím textu jsme si naznaèili, ¾e se <i>LuaJIT</i> zamìøuje
na hledání a optimalizaci jak poèítaných i nepoèítaných programových smyèek,
tak i èasto volaných funkcí. Zatímco se programové smyèky s&nbsp;velkým poètem
iterací, které se pøekládají do nativního kódu, oznaèují termínem <i>hot
loops</i>, jsou èasto volané funkce nazývány <i>hot calls</i>. V&nbsp;dal¹ím
textu se zamìøíme pøedev¹ím na detekci <i>hot calls</i>, prozatím v¹ak
vynecháme drobnou specialitku <i>LuaJITu</i>, kterou je detekce nìkterých typù
koncové rekurze (<i>tail call</i>). U volaných funkcí se pøi pøekladu obecnì
mohou provádìt podobné typy optimalizací, o jakých jsme se zmiòovali
v&nbsp;souvislosti s&nbsp;programovými smyèkami. Jedná se pøedev¹ím o detekci
mrtvého kódu a takté¾ o inlining tìl funkcí do volajícího kódu.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Zji¹tìní, která funkce se má JITovat</h2>

<p>Mo¾ná bude zajímavé zjistit, po kolika voláních se nìjaká volaná funkce
(resp.&nbsp;pøesnìji øeèeno její volání &ndash; call) zaøadí do skupiny <i>hot
calls</i>. Ji¾ minule jsme si øekli, ¾e programová smyèka èi její èást
(vìtvení) je zaøazena do skupiny <i>hot loops</i> ve chvíli, kdy je pøekroèen
poèet padesáti ¹esti iterací (opakování tìla smyèky). Tuto
&bdquo;magickou&ldquo; konstantu nalezneme v&nbsp;souboru
<strong>lj_jit.h</strong>, konkrétnì v&nbsp;následujícím makru:</p>

<pre>
/* Optimization parameters and their defaults. Length is a char in octal! */
#define JIT_PARAMDEF(_) \
  _(\010, maxtrace,     1000)   /* Max. # of traces in cache. */ \
  _(\011, maxrecord,    4000)   /* Max. # of recorded IR instructions. */ \
  _(\012, maxirconst,   500)    /* Max. # of IR constants of a trace. */ \
  _(\007, maxside,      100)    /* Max. # of side traces of a root trace. */ \
  _(\007, maxsnap,      500)    /* Max. # of snapshots for a trace. */ \
  \
  _(\007, <strong>hotloop,      56</strong>)    /* # of iter. to detect a hot loop/call. */ \
  _(\007, hotexit,      10)     /* # of taken exits to start a side trace. */ \
  _(\007, tryside,      4)      /* # of attempts to compile a side trace. */ \
  \
  _(\012, instunroll,   4)      /* Max. unroll for instable loops. */ \
  _(\012, loopunroll,   15)     /* Max. unroll for loop ops in side traces. */ \
  _(\012, callunroll,   3)      /* Max. unroll for recursive calls. */ \
  _(\011, recunroll,    2)      /* Min. unroll for true recursion. */ \
  \
  /* Size of each machine code area (in KBytes). */ \
  _(\011, sizemcode,    JIT_P_sizemcode_DEFAULT) \
  /* Max. total size of all machine code areas (in KBytes). */ \
  _(\010, maxmcode,     512) \
  /* End of list. */
</pre>

<p>Ve skuteènosti je v¹ak hodnota <strong>hotloop</strong> pou¾ita jak pro
detekci <i>hot loops</i>, tak i pro detekci <i>hot calls</i>, co¾ v¹ak bohu¾el
není pøímo ze zdrojových kódù ihned patrné. Vtip spoèívá v&nbsp;tom, ¾e pro
ka¾dou stopu (<i>trace</i>) je nastavena poèáteèní hodnota poèitadla na hodnotu
<strong>hotloop*2</strong> (<strong>hotloop*HOTCOUNT_LOOP</strong>). Pokud
stopa obsahuje programovou smyèku, je po ka¾dé dal¹í iteraci sní¾ena hodnota
poèitadla o dvojku (konkrétnì o konstantu <strong>HOTCOUNT_LOOP</strong>, pokud
se naopak volá nìjaká funkce, je v&nbsp;této stopì sní¾ena hodnota poèitadla o
jednièku (konkrétnì o konstantu <strong>HOTCOUNT_CALL</strong>). Ve chvíli, kdy
hodnota poèitadla dosáhne nuly, byla detekována buï <i>hot loop</i> nebo <i>hot
call</i> a je mo¾né provést JIT pøeklad. Zmínìné konstanty
<strong>HOTCOUNT_LOOP</strong> a <strong>HOTCOUNT_CALL</strong> nalezneme ve
zdrojovém souboru <strong>lj_dispatch.h</strong>:</p>

<pre>
/* Hotcount decrements. */
#define HOTCOUNT_LOOP           2
#define HOTCOUNT_CALL           1
</pre>

<p>Inicializaci poèitadla hledejte v&nbsp;souboru
<strong>lj_trace.c</strong>:</p>

<pre>
lj_trace_hot:
&nbsp;
  /* Reset hotcount. */
  hotcount_set(J2GG(J), pc, J-&gt;param[JIT_P_hotloop]*HOTCOUNT_LOOP);
</pre>

<p>Samotný programový kód, v&nbsp;nìm¾ se poèitadla sni¾ují a testují na nulu,
je ji¾ naprogramován v&nbsp;assembleru, podobnì jako i dal¹í èásti
<i>LuaJITu</i>. Jen pro zajímavost se podívejme, jak vypadají makra provádìjící
tuto èinnost v&nbsp;assemblerech pro procesory s&nbsp;architekturou x86, MIPS a
ARM (32bit):</p>

<p><strong>vm_x86.dasc</strong>:</p>

<pre>
|// Decrement hashed hotcount and trigger trace recorder if zero.
|.macro <strong>hotloop</strong>, reg
|  mov reg, PC
|  shr reg, 1
|  and reg, HOTCOUNT_PCMASK
|  sub word [DISPATCH+reg+GG_DISP2HOT], HOTCOUNT_LOOP
|  jb -&gt;vm_hotloop
|.endmacro
|
|.macro <strong>hotcall</strong>, reg
|  mov reg, PC
|  shr reg, 1
|  and reg, HOTCOUNT_PCMASK
|  sub word [DISPATCH+reg+GG_DISP2HOT], HOTCOUNT_CALL
|  jb -&gt;vm_hotcall
|.endmacro
</pre>

<p><strong>vm_mips.dasc</strong>:</p>

<pre>
|.macro <strong>hotloop</strong>
|  hotcheck HOTCOUNT_LOOP, -&gt;vm_hotloop
|.endmacro
|
|.macro <strong>hotcall</strong>
|  hotcheck HOTCOUNT_CALL, -&gt;vm_hotcall
|.endmacro
</pre>

<p><strong>vm_arm.dasc</strong>:</p>

<pre>
|.macro <strong>hotloop</strong>
|  hotcheck HOTCOUNT_LOOP
|  blo -&gt;vm_hotloop
|.endmacro
|
|.macro <strong>hotcall</strong>
|  hotcheck HOTCOUNT_CALL
|  blo -&gt;vm_hotcall
|.endmacro
</pre>

<p>Aby byla celá situace je¹tì zajímavìj¹í, byl pro potøeby <i>LuaJITu</i>
vyvinut i vlastní assembler nazvaný <i>Dynamic Assembler</i>. Podrobnìj¹í
informace o tomto nástroji lze nalézt na adrese <a
href="http://luajit.org/dynasm.html">http://luajit.org/dynasm.html</a> a <a
href="http://corsix.github.io/dynasm-doc/tutorial.html">http://corsix.github.io/dynasm-doc/tutorial.html</a>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Demonstraèní pøíklady</h2>

<p>Podívejme se nyní na dvojici demonstraèních pøíkladù, na nich¾ si uká¾eme
základní vlastnosti detekce <i>hot calls</i>. Ani jeden z&nbsp;obou pøíkladù
popsaných v&nbsp;navazujících dvou podkapitolách není pøíli¹ slo¾itý, proto¾e
se budeme sna¾it izolovat jen ty èásti <i>LuaJITu</i>, které se skuteènì <i>hot
calls</i> týkají.</p>


<p><a name="k061"></a></p>
<h3 id="k061">6.1 Demonstraèní pøíklad <strong>test52.lua</strong> &ndash; opakované volání funkce</h3>

<p>Dne¹ní pátý demonstraèní pøíklad nazvaný <strong>test52.lua</strong> je sice
velmi dlouhý, ov¹em pøi podrobném pohledu znaènì primitivní :-). Je zde
deklarována funkce pojmenovaná <strong>adder</strong>, v&nbsp;ní¾ se zvy¹ují
hodnoty promìnných x a y (jedná se o lokální promìnné v&nbsp;rámci celého
modulu, tak¾e k&nbsp;nim má funkce samozøejmì pøístup). Následnì je pøesnì
112&times; funkce <strong>adder</strong> volána. Proè zrovna 112&times;? Jedná
se o dvojnásobek hodnoty <strong>hotloop</strong>, pøièem¾ z&nbsp;pøedchozí
kapitoly víme, ¾e právì hodnota <strong>hotloop*2</strong> je pou¾ita pøi
detekci èasto volaných funkcí. Pokud se pokusíte jedno volání funkce
<strong>adder</strong> odstranit, neprovede se její JITování (co¾ je velmi
snadné odzkou¹et):</p>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 52.</i>
<i>--</i>
<i>-- Test JITu - volání funkce</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>-- deklarace a inicializace lokálních promìnných</i>
<strong>local</strong> x = 0
<strong>local</strong> y = 0
&nbsp;
&nbsp;
&nbsp;
<i>-- funkce, která se bude JITovat</i>
<strong>function</strong> adder()
    x = x + 1
    y = y + 1
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
adder()
&nbsp;
&nbsp;
&nbsp;
print(x,y)
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Finito.</i>
<i>--</i>
</pre>

<p>Výsledek bìhu tohoto pøíkladu není pøíli¹ pøekvapující, ov¹em dovoluje nám
otestovat, kolikrát se funkce <strong>adder</strong> skuteènì volala:</p>

<pre>
112     112
</pre>

<p>Trasovací modul <i>LuaJITu</i> nakonec pøi posledním volání funkce
<strong>adder</strong> uznal, ¾e je tato funkce vhodná pro JITování, tak¾e po
spu¹tìní vý¹e uvedeného pøíkladu s&nbsp;pøepínaèem <strong>-jv</strong>
dostaneme následující zprávu:</p>

<pre>
[TRACE   1 test52.lua:16 return]
</pre>



<p><a name="k062"></a></p>
<h3 id="k062">6.2 Demonstraèní pøíklad <strong>test53.lua</strong> &ndash; opakované volání funkce z&nbsp;programové smyèky</h3>

<p>©estý a souèasnì i dne¹ní poslední demonstraèní pøíklad takté¾ deklaruje
funkci <strong>adder</strong>, která se chová podobnì jako v&nbsp;pøedchozím
pøíkladu. Tato funkce je ov¹em volána v&nbsp;trojici programových smyèek.
V&nbsp;první smyèce se provede prvních padesát volání, v&nbsp;dal¹í smyèce
dal¹ích padesát volání a koneènì ve smyèce tøetí se funkce zavolá po 101 a¾
150. Proè je pøíklad organizován takovým zpùsobem? Jde nám o to zabránit
<i>LuaJITu</i> v&nbsp;detekci smyèek s&nbsp;velkým poètem iterací, pøièem¾
hodnota 50 le¾í pod hranièní hodnotou <strong>hotcall=56</strong>, tak¾e smyèky
samotné JITovány nebudou, ale funkce <strong>adder</strong> nakonec ano
(samozøejmì a¾ v&nbsp;poslední smyèce):</p>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 53.</i>
<i>--</i>
<i>-- Test JITu - volání funkce</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>-- deklarace a inicializace lokálních promìnných</i>
<strong>local</strong> i
<strong>local</strong> x = 0
<strong>local</strong> y = 0
&nbsp;
&nbsp;
&nbsp;
<i>-- funkce, která se bude JITovat</i>
<strong>function</strong> adder()
    x = x + 1
    y = y + 1
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>-- programová smyèka, která se neJITuje</i>
<strong>for</strong> i = 1,50 <strong>do</strong>
    adder()
<strong>end</strong>
print("1")
&nbsp;
<i>-- programová smyèka, která se neJITuje</i>
<strong>for</strong> i = 1,50 <strong>do</strong>
    adder()
<strong>end</strong>
print("2")
&nbsp;
<i>-- programová smyèka, která se neJITuje</i>
<strong>for</strong> i = 1,50 <strong>do</strong>
    adder()
<strong>end</strong>
print("3")
&nbsp;
print(x,y)
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Finito.</i>
<i>--</i>
</pre>

<p>Výsledek bìhu pøíkladu:</p>

<pre>
1
2
3
150     150
</pre>

<p>Z&nbsp;následujícího øádku je patrné, ¾e trasovací modul <i>LuaJITu</i>
skuteènì na¹el pouze jediné místo, které se bude JITovat, a tím je funkce
<strong>adder</strong>:</p>

<pre>
[TRACE   1 test53.lua:17 return]
</pre>

<p>Pokud tento demonstraèní pøíklad nepatrnì upravíme takovým zpùsobem, ¾e se
namísto padesáti iterací provede v&nbsp;ka¾dé smyèce iterací 150, bude ji¾
výsledek mnohem zajímavìj¹í, proto¾e se budou pøekládat jak v¹echny smyèky, tak
i funkce (která se navíc dostane do mno¾iny <i>hot calls</i> ji¾ ve smyèce
první a nikoli poslední):</p>

<pre>
[TRACE   1 test53.lua:25 loop]
1
[TRACE   2 test53.lua:17 return]
[TRACE   3 test53.lua:31 loop]
2
[TRACE   4 test53.lua:37 loop]
3
450     450
</pre>

<p>Upravený zdrojový kód:</p>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 53 (úprava!!!).</i>
<i>--</i>
<i>-- Test JITu - volání funkce</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>-- deklarace a inicializace lokálních promìnných</i>
<strong>local</strong> i
<strong>local</strong> x = 0
<strong>local</strong> y = 0
&nbsp;
&nbsp;
&nbsp;
<i>-- funkce, která se bude JITovat</i>
<strong>function</strong> adder()
    x = x + 1
    y = y + 1
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>-- programová smyèka, která se JITuje</i>
<strong>for</strong> i = 1,150 <strong>do</strong>
    adder()
<strong>end</strong>
print("1")
&nbsp;
<i>-- programová smyèka, která se JITuje</i>
<strong>for</strong> i = 1,150 <strong>do</strong>
    adder()
<strong>end</strong>
print("2")
&nbsp;
<i>-- programová smyèka, která se JITuje</i>
<strong>for</strong> i = 1,150 <strong>do</strong>
    adder()
<strong>end</strong>
print("3")
&nbsp;
print(x,y)
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Finito.</i>
<i>--</i>
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Zdrojové kódy v¹ech ¹esti dne¹ních demonstraèních pøíkladù</h2>

<p>V¹ech ¹est dnes pou¾itých demonstraèních pøíkladù bylo, jak je tomu ostatnì
v&nbsp;tomto seriálu ji¾ dlouhodobìj¹ím zvykem, ulo¾eno do Git (pøesnìji øeèeno
do <a href="http://github.com/">GitHub</a>) repositáøe umístìného na adrese <a
href="https://github.com/tisnik/luajit-examples">https://github.com/tisnik/luajit-examples</a>.</p>

<p>Následuje tabulka obsahující odkazy na poslední verze dne¹ních pøíkladù i
upraveného souboru <strong>Makefile</strong>, který obsahuje mj.&nbsp;i v¹echny
pøíkazy pro spu¹tìní pøíkladù a vygenerování v¹ech potøebných výstupních
souborù (trasovací informace apod.):</p>

<table>
<tr><th>#</th><th>Zdrojový kód</th><th>Umístìní</th></tr>
<tr><td>1</td><td>test48.lua</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/src/test48.lua">https://github.com/tisnik/luajit-examples/blob/master/src/test48.lua</a></td></tr>
<tr><td>2</td><td>test49.lua</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/src/test49.lua">https://github.com/tisnik/luajit-examples/blob/master/src/test49.lua</a></td></tr>
<tr><td>3</td><td>test50.lua</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/src/test50.lua">https://github.com/tisnik/luajit-examples/blob/master/src/test50.lua</a></td></tr>
<tr><td>4</td><td>test51.lua</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/src/test51.lua">https://github.com/tisnik/luajit-examples/blob/master/src/test51.lua</a></td></tr>
<tr><td>5</td><td>test52.lua</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/src/test52.lua">https://github.com/tisnik/luajit-examples/blob/master/src/test52.lua</a></td></tr>
<tr><td>6</td><td>test53.lua</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/src/test53.lua">https://github.com/tisnik/luajit-examples/blob/master/src/test53.lua</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>Makefile</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/Makefile">https://github.com/tisnik/luajit-examples/blob/master/Makefile</a></td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Literatura</h2>

<ol>

<li>Bolz, Cuni, Fijalkowski, Rigo:<br />
&bdquo;Tracing the Meta-Level: PyPy's Tracing JIT Compiler&ldquo;
</li>

<li>Vasanth Bala, Evelyn Duesterwald, Sanjeev Banerjia:<br />
&bdquo;Dynamo: A Transparent Dynamic Optimization System&ldquo;
</li>

<li>Bolz, Cuni, Fijalkowski, Leuschel, Pedroni, Rigo:
&bdquo;Allocation removal by partial evaluation in a tracing JIT&ldquo;
</li>

<li>Bolz:<br />
&bdquo;Automatic JIT Compiler Generation with Runtime Partial Evaluation&ldquo;
</li>

<li>Bolz, Kuhn, Lienhard, Matsakis, Nierstrasz, Renggli, Rigo and T. Verwaest:<br />
&bdquo;Back to the Future in One Week - Implementing a Smalltalk VM in PyPy&ldquo;<br />
pages 123-139. 2008.
</li>

<li>Bolz  and Rigo:<br />
&bdquo;How to not write a virtual machine&ldquo;<br />
In Proceedings of the 3rd Workshop on Dynamic Languages and Applications (DYLA), 2007
</li>

<li>Bruni, Verwaest:<br />
&bdquo;PyGirl: generating Whole-System VMs from High-Level prototypes using PyPy&ldquo;<br />
In Tools, accepted for publication, 2009.
</li>

<li>Sullivan, Bruening, Baron, Garnett and Amarasinghe:<br />
&bdquo;Dynamic native optimization of interpreters&ldquo;<br />
In Proceedings of the 2003 Workshop on Interpreters,<br />
Virtual Machines and Emulators pages 50-57, San Diego, California, 2003. ACM.
</li>

</ol>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Dynamic Assembler<br />
<a href="http://luajit.org/dynasm.html">http://luajit.org/dynasm.html</a>
</li>

<li>The Unofficial DynASM Documentation: Introduction<br />
<a href="http://corsix.github.io/dynasm-doc/index.html">http://corsix.github.io/dynasm-doc/index.html</a>
</li>

<li>Have tracing JIT compilers won?<br />
<a href="http://lambda-the-ultimate.org/node/3851">http://lambda-the-ultimate.org/node/3851</a>
</li>

<li>Tracing just-in-time compilation<br />
<a href="http://en.wikipedia.org/wiki/Tracing_just-in-time_compilation">http://en.wikipedia.org/wiki/Tracing_just-in-time_compilation</a>
</li>

<li>How does LuaJIT's trace compiler work?<br />
<a href="http://www.freelists.org/post/luajit/How-does-LuaJITs-trace-compiler-work,1">http://www.freelists.org/post/luajit/How-does-LuaJITs-trace-compiler-work,1</a>
</li>

<li>How does LuaJIT's trace compiler work?<br />
<a href="http://stackoverflow.com/questions/20266523/how-does-luajits-trace-compiler-work">http://stackoverflow.com/questions/20266523/how-does-luajits-trace-compiler-work</a>
</li>

<li>TraceMonkey<br />
<a href="https://wiki.mozilla.org/JavaScript:TraceMonkey">https://wiki.mozilla.org/JavaScript:TraceMonkey</a>
</li>

<li>TraceMonkey<br />
<a href="http://brendaneich.com/2008/08/tracemonkey-javascript-lightspeed/">http://brendaneich.com/2008/08/tracemonkey-javascript-lightspeed/</a>
</li>

<li>improving JavaScript performance with JägerMonkey<br />
<a href="http://hacks.mozilla.org/2010/03/improving-javascript-performance-with-jagermonkey/">http://hacks.mozilla.org/2010/03/improving-javascript-performance-with-jagermonkey/</a>
</li>

<li>Wikipedia: Mezijazyk<br />
<a href="http://cs.wikipedia.org/wiki/Mezijazyk">http://cs.wikipedia.org/wiki/Mezijazyk</a>
</li>

<li>The LuaJIT Project<br />
<a href="http://luajit.org/index.html">http://luajit.org/index.html</a>
</li>

<li>LuaJIT FAQ<br />
<a href="http://luajit.org/faq.html">http://luajit.org/faq.html</a>
</li>

<li>LuaJIT Performance Comparison<br />
<a href="http://luajit.org/performance.html">http://luajit.org/performance.html</a>
</li>

<li>LuaJIT 2.0 intellectual property disclosure and research opportunities<br />
<a href="http://article.gmane.org/gmane.comp.lang.lua.general/58908">http://article.gmane.org/gmane.comp.lang.lua.general/58908</a>
</li>

<li>LuaJIT Wiki<br />
<a href="http://wiki.luajit.org/Home">http://wiki.luajit.org/Home</a>
</li>

<li>LuaJIT 2.0 Bytecode Instructions<br />
<a href="http://wiki.luajit.org/Bytecode-2.0">http://wiki.luajit.org/Bytecode-2.0</a>
</li>

<li>Programming in Lua 9.1 &ndash; Coroutine Basics,<br />
<a href="http://www.lua.org/pil/9.1.html">http://www.lua.org/pil/9.1.html</a>
</li>

<li>Programming in Lua (first edition)<br />
<a href="http://www.lua.org/pil/contents.html">http://www.lua.org/pil/contents.html</a>
</li>

<li>Programming in Lua: 6 - More about Functions<br />
<a href="http://www.lua.org/pil/6.html">http://www.lua.org/pil/6.html</a>
</li>

<li>Lua Lanes<br />
<a href="http://kotisivu.dnainternet.net/askok/bin/lanes/">http://kotisivu.dnainternet.net/askok/bin/lanes/</a>
</li>

<li>Programming in Lua: 6.1 - Closures<br />
<a href="http://www.lua.org/pil/6.1.html">http://www.lua.org/pil/6.1.html</a>
</li>

<li>Programming in Lua: 9.1 - Coroutine Basics<br />
<a href="http://www.lua.org/pil/9.1.html">http://www.lua.org/pil/9.1.html</a>
</li>

<li>Programming in Lua: Numeric for<br />
<a href="http://www.lua.org/pil/4.3.4.html">http://www.lua.org/pil/4.3.4.html</a>
</li>

<li>Programming in Lua: break and return<br />
<a href="http://www.lua.org/pil/4.4.html">http://www.lua.org/pil/4.4.html</a>
</li>

<li>Programming in Lua: Tables<br />
<a href="http://www.lua.org/pil/2.5.html">http://www.lua.org/pil/2.5.html</a>
</li>

<li>Programming in Lua: Table Constructors<br />
<a href="http://www.lua.org/pil/3.6.html">http://www.lua.org/pil/3.6.html</a>
</li>

<li>Programovací jazyk Lua<br />
<a href="http://palmknihy.cz/web/kniha/programovaci-jazyk-lua-12651.htm">http://palmknihy.cz/web/kniha/programovaci-jazyk-lua-12651.htm</a>
</li>

<li>Lua: Tables Tutorial<br />
<a href="http://lua-users.org/wiki/TablesTutorial">http://lua-users.org/wiki/TablesTutorial</a>
</li>

<li>Lua: Control Structure Tutorial<br />
<a href="http://lua-users.org/wiki/ControlStructureTutorial">http://lua-users.org/wiki/ControlStructureTutorial</a>
</li>

<li>Lua Types Tutorial<br />
<a href="http://lua-users.org/wiki/LuaTypesTutorial">http://lua-users.org/wiki/LuaTypesTutorial</a>
</li>

<li>Goto Statement in Lua<br />
<a href="http://lua-users.org/wiki/GotoStatement">http://lua-users.org/wiki/GotoStatement</a>
</li>

<li>Lua 5.2 sources<br />
<a href="http://www.lua.org/source/5.2/">http://www.lua.org/source/5.2/</a>
</li>

<li>Lua 5.2 sources - lopcodes.h<br />
<a href="http://www.lua.org/source/5.2/lopcodes.h.html">http://www.lua.org/source/5.2/lopcodes.h.html</a>
</li>

<li>Lua 5.2 sources - lopcodes.c<br />
<a href="http://www.lua.org/source/5.2/lopcodes.c.html">http://www.lua.org/source/5.2/lopcodes.c.html</a>
</li>

<li>Lambda the Ultimate: Coroutines in Lua,<br />
<a href="http://lambda-the-ultimate.org/node/438">http://lambda-the-ultimate.org/node/438</a>
</li>

<li>Coroutines Tutorial,<br />
<a href="http://lua-users.org/wiki/CoroutinesTutorial">http://lua-users.org/wiki/CoroutinesTutorial</a>
</li>

<li>Lua Coroutines Versus Python Generators,<br />
<a href="http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators">http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2014</small></p>
</body>
</html>

