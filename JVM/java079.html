<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - detekce vstupu do metod s vyu¾itím rozhraní JDI</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - detekce vstupu do metod s vyu¾itím rozhraní JDI</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyku Java i o virtuálním stroji Javy si uká¾eme zpùsob detekce vstupu do metod s vyu¾itím rozhraní JDI (Java Debugger Interface). Pro zji¹tìní, jaké metody jsou ve sledovaném virtuálním stroji Javy volány, se pøi vyu¾ití JDI pou¾ívá systém událostí, s ním¾ jsme se seznámili minule.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - detekce vstupu do metod s vyu¾itím rozhraní JDI</a></p>
<p><a href="#k02">2. Registrace události vyvolané pøi vstupu do libovolné metody</a></p>
<p><a href="#k03">3. Výpis základních informací o volané metodì</a></p>
<p><a href="#k04">4. Zdrojový kód demonstraèního pøíkladu <strong>JDIMethodEntryDetection1</strong></a></p>
<p><a href="#k05">5. Filtrace tøíd, pro jejich¾ metody se vyvolá událost <strong>MethodEntryEvent</strong></a></p>
<p><a href="#k06">6. Zji¹tìní podrobnìj¹ích informací o volané metodì</a></p>
<p><a href="#k07">7. Zdrojový kód demonstraèního pøíkladu <strong>JDIMethodEntryDetection2</strong></a></p>
<p><a href="#k08">8. Zji¹tìní modifikátorù, parametrù a návratových typù volaných metod</a></p>
<p><a href="#k09">9. Zdrojový kód demonstraèního pøíkladu <strong>JDIMethodEntryDetection3</strong></a></p>
<p><a href="#k10">10. Zdrojový kód testovací tøídy <strong>Test5</strong></a></p>
<p><a href="#k11">11. Repositáø se zdrojovými kódy v¹ech tøí demonstraèních pøíkladù</a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - detekce vstupu do metod s vyu¾itím rozhraní JDI</h2>

<p>V&nbsp;pøedchozí èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyku Java i o virtuálním stroji Javy</a> jsme si øekli základní
informace o tom, jakým zpùsobem se v&nbsp;rozhraní <i>JDI (Java Debugger
Interface)</i> registrují a následnì zpracovávají takzvané
&bdquo;události&ldquo; (<i>events</i>), které jsou automaticky generovány ve
chvíli, kdy dojde ke zmìnì stavu sledovaného (monitorovaného) virtuálního
stroje Javy. Pøipomeòme si, ¾e ka¾dá událost se na stranì debuggeru projeví
vytvoøením objektu typu <strong>com.sun.jdi.event.Event</strong>, který je
ihned po svém vytvoøení vlo¾en do takzvané fronty událostí (<i>event
queue</i>). Debugger mù¾e (resp.&nbsp;pøesnìji øeèeno dokonce musí) události
postupnì z&nbsp;této fronty èíst a nìjakým zpùsobem na tyto události reagovat.
Postupné ètení událostí je vìt¹inou implementováno formou programové smyèky
(<i>event loop</i>), na jejím¾ zaèátku se pøeète nová událost z&nbsp;fronty
událostí a posléze se provede rozeskok na základì typu pøeètené události.</p>

<p>Registrovat a zpracovávat lze následující typy událostí:</p>

<ol>
<li>Start sledovaného virtuálního stroje</li>
<li>Ukonèení práce sledovaného virtuálního stroje</li>
<li>Vytvoøení a spu¹tìní nového vlákna</li>
<li>Ukonèení èinnosti vlákna</li>
<li>Vstup vlákna do stavu èekání na jiné vlákno (<i>monitor</i>)</li>
<li>Vstup na breakpoint v&nbsp;nìjakém vláknì bì¾ícím ve sledované JVM</li>
<li>Ètení èi zápis do sledovaného atributu (<i>watchpoint</i>)</li>
<li>Provedení jednoho kroku pøi krokování programu ve sledované JVM</li>
<li>Vznik výjimky</li>
<li>Vstup do metody</li>
<li>Výskok z&nbsp;metody</li>
</ol>

<p>Debugger vìt¹inou musí umìt zareagovat minimálnì na událost typu
<strong>VMDeathEvent</strong>, která nastane ve chvíli, kdy je èinnost
sledovaného virtuálního stroje ukonèována. Zpracování události tohoto typu jsme
si ukázali minule v&nbsp;demonstraèním pøíkladu <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/b4d636160962/jdi/JDIEventRequestManager.java">JDIEventRequestManager.java</a>.
Dnes si øekneme, jak mù¾e debugger jednodu¹e sledovat volání jednotlivých metod
v&nbsp;monitorovaném virtuálním stroji Javy; posléze si také uká¾eme mo¾nosti
filtrace událostí na základì jména tøídy, popø.&nbsp;jednoduchého regulárního
výrazu popisujícího vìt¹í mno¾inu jmen.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Registrace události vyvolané pøi vstupu do libovolné metody</h2>

<p>®ádost o registraci události se provádí s&nbsp;vyu¾itím tøíd
implementujících rozhraní <strong>com.sun.jdi.request.EventRequest</strong>,
které je pøedkem dal¹ích rozhraní vypsaných v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Rozhraní</th><th>Popis</th></tr>
<tr><td> 1</td><td>com.sun.jdi.request.BreakpointRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.BreakpointEvent</td></tr>
<tr><td> 2</td><td>com.sun.jdi.request.ClassPrepareRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.ClassPrepareEvent</td></tr>
<tr><td> 3</td><td>com.sun.jdi.request.ClassUnloadRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.ClassUnloadEvent</td></tr>
<tr><td> 4</td><td>com.sun.jdi.request.ExceptionRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.ExceptionEvent</td></tr>
<tr><td> 5</td><td>com.sun.jdi.request.MethodEntryRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.MethodEntryEvent</td></tr>
<tr><td> 6</td><td>com.sun.jdi.request.MethodExitRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.MethodExitEvent</td></tr>
<tr><td> 7</td><td>com.sun.jdi.request.MonitorContendedEnteredRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.MonitorContendedEnteredEvent</td></tr>
<tr><td> 8</td><td>com.sun.jdi.request.MonitorContendedEnterRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.MonitorContendedEnterEvent</td></tr>
<tr><td> 9</td><td>com.sun.jdi.request.MonitorWaitedRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.MonitorWaitedEvent</td></tr>
<tr><td>10</td><td>com.sun.jdi.request.MonitorWaitRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.MonitorWaitEvent</td></tr>
<tr><td>11</td><td>com.sun.jdi.request.StepRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.StepEvent</td></tr>
<tr><td>12</td><td>com.sun.jdi.request.ThreadDeathRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.ThreadDeathEvent</td></tr>
<tr><td>13</td><td>com.sun.jdi.request.ThreadStartRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.ThreadStartEvent</td></tr>
<tr><td>14</td><td>com.sun.jdi.request.VMDeathRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.VMDeathEvent</td></tr>
<tr><td>15</td><td>com.sun.jdi.request.WatchpointRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.WatchpointEvent</td></tr>
<tr><td>16</td><td>com.sun.jdi.request.AccessWatchpointRequest</td><td>®ádost o generování událostí typu com.sun.jdi.AccessWatchpointEvent</td></tr>
<tr><td>17</td><td>com.sun.jdi.request.ModificationWatchpointRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.ModificationWatchpointEvent</td></tr>
</table>

<p>V&nbsp;dne¹ních demonstraèních pøíkladech vyu¾ijeme pouze rozhraní
<strong>VMDeathRequest</strong> a <strong>MethodEntryRequest</strong>.
Registrace pøíslu¹ných typù událostí se provádí v&nbsp;u¾ivatelské metodì
<strong>acquireAndUseEventRequestManager()</strong>, která nejprve zaregistruje
oba typy událostí a posléze zavolá smyèku událostí implementovanou
v&nbsp;samostatné metodì:</p>

<pre>
<i>    /**</i>
<i>     * Ukazka pouziti EventRequestManageru.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>acquireAndUseEventRequestManager</strong>(VirtualMachine virtualMachine) {
        EventRequestManager eventRequestManager = virtualMachine.eventRequestManager();
        VMDeathRequest vmDeathRequest = registerVMDeathEvent(eventRequestManager);
        MethodEntryRequest methodEntryRequest = <strong>registerMethodEntryRequest</strong>(eventRequestManager);
<i>        // klasicka smycka pro zpracovani udalosti</i>
        eventLoop(virtualMachine, vmDeathRequest, methodEntryRequest);
    }
</pre>

<p>V&nbsp;metodì <strong>registerMethodEntryRequest()</strong> se vy¾ádá
generování událostí typu <strong>MethodEntryEvent</strong> a posléze se
generování tìchto typù událostí je¹tì musí explicitnì povolit:</p>

<pre>
<i>    /**</i>
<i>     * Registrace udalosti typu MethodEntry</i>
<i>     */</i>
    private static MethodEntryRequest <strong>registerMethodEntryRequest</strong>(EventRequestManager eventRequestManager) {
        MethodEntryRequest methodEntryRequest = eventRequestManager.createMethodEntryRequest();
&nbsp;
<i>        // po registraci udalosti je jeste nutne tento typ udalosti povolit</i>
        methodEntryRequest.enable();
        return methodEntryRequest;
    }
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Výpis základních informací o volané metodì</h2>

<p>Vlastní implementace smyèky událostí je, stejnì jako v&nbsp;demonstraèním
pøíkladu popsaném minule, rozdìlená do dvou u¾ivatelských metod. V&nbsp;metodì
nazvané pøíznaènì <strong>eventLoop()</strong> se nejprve získá objekt typu
<strong>EventQueue</strong> a následnì se v&nbsp;programové smyèce opakovanì
volá u¾ivatelská metoda <strong>processEvents()</strong> vracející pravdivostní
hodnotu <strong>true</strong> v&nbsp;pøípadì, ¾e se má pokraèovat ve ètení a
zpracování dal¹ích událostí a hodnotu <strong>false</strong> ve chvíli, kdy
pøi¹la událost typu <strong>VMDeathEvent</strong> a kdy má tedy debugger
ukonèit svoji èinnost. Metodu <strong>eventLoop()</strong> si dnes popisovat
nebudeme, proto¾e ji známe ji¾ z&nbsp;minula, ov¹em v&nbsp;metodì
<strong>processEvents()</strong> do¹lo k&nbsp;roz¹íøení &bdquo;rozeskoku&ldquo;
o dal¹í typ události:</p>

<pre>
<i>    /**</i>
<i>     * Precteni a zpracovani udalosti</i>
<i>     *</i>
<i>     * @param eventQueue fronta udalosti</i>
<i>     * @param vmDeathRequest objekt pro rizeni udalosti typu VMDeathEvent</i>
<i>     *</i>
<i>     * @return true pokud se ma pokracovat ve zpracovavani udalosti</i>
<i>     *         false pokud se ma sledovana VM ukoncit</i>
<i>     */</i>
    private static boolean <strong>processEvents</strong>(EventQueue eventQueue, VMDeathRequest vmDeathRequest) {
        EventSet eventSet;
        try {
<i>            // precist udalosti z fronty</i>
            eventSet = eventQueue.remove();
            int events = eventSet.size();
            System.out.println("Got " + events + " request" + (events &gt; 1 ? "s:" : ":"));
&nbsp;
<i>            // projit vsemi udalostmi</i>
            for (Event event : eventSet) {
                if (event instanceof VMStartEvent) {
                    System.out.println("    VMStartEvent");
                }
                else if (event instanceof VMDeathEvent) {
                    System.out.println("    VMDeathEvent");
<i>                    // zakazat dalsi generovani udalosti</i>
<i>                    // (u VMDeathEvent je ve skutecnosti vzdy posledni udalost poslana) </i>
                    vmDeathRequest.disable();
<i>                    // posleze se zavola shutdownVirtualMachine()</i>
                    return false;
                }
                else if (event instanceof MethodEntryEvent) {
                    <strong>printMethodEntryInfo</strong>((MethodEntryEvent)event);
                }
                else {
                    System.out.println("    other event");
                }
            }
<i>            // znovu postit vsechna vlakna</i>
            eventSet.resume();
        }
        catch (InterruptedException e) {
            e.printStackTrace();
        }
        return true;
    }
</pre>

<p>Pøi pøeètení události typu <strong>MethodEntryEvent</strong> se zavolá
u¾ivatelská metoda <strong>printMethodEntryInfo()</strong>, která ve své první
verzi pouze vytiskne jméno zavolané metody:</p>

<pre>
<i>    /**</i>
<i>     * Zavolano pri vyskytu udalosti typu MethodEntry</i>
<i>     */</i>
    private static void <strong>printMethodEntryInfo</strong>(MethodEntryEvent event) {
        String methodName = event.method().name();
&nbsp;
<i>        // nyni mame vsechny informace, lze je tedy vypsat</i>
        System.out.format("    entry into method: %s\n", methodName);
    }
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Zdrojový kód demonstraèního pøíkladu <strong>JDIMethodEntryDetection1</strong></h2>

<p>Metody popsané v&nbsp;pøedchozích dvou kapitolách jsou souèástí dne¹ního
demonstraèního pøíkladu nazvaného <strong>JDIMethodEntryDetection1</strong>.
Tento pøíklad po svém spu¹tìní vytiskne jména v¹ech volaných metod, a to
nezávisle na tom, ve kterém vláknu jsou tyto metody volány èi ke které tøídì
metody nále¾í:</p>

<pre>
import java.io.IOException;
import java.util.List;
import java.util.Map;
&nbsp;
import com.sun.jdi.Bootstrap;
import com.sun.jdi.VirtualMachine;
import com.sun.jdi.VirtualMachineManager;
import com.sun.jdi.connect.AttachingConnector;
import com.sun.jdi.connect.Connector;
import com.sun.jdi.connect.IllegalConnectorArgumentsException;
import com.sun.jdi.event.Event;
import com.sun.jdi.event.EventQueue;
import com.sun.jdi.event.EventSet;
import com.sun.jdi.event.MethodEntryEvent;
import com.sun.jdi.event.VMDeathEvent;
import com.sun.jdi.event.VMStartEvent;
import com.sun.jdi.request.EventRequestManager;
import com.sun.jdi.request.MethodEntryRequest;
import com.sun.jdi.request.VMDeathRequest;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Pripojeni k bezicimu virtualnimu stroji Javy,</i>
<i> * ktery byl spusten s parametry:</i>
<i> * java -agentlib:jdwp=transport=dt_socket,server=y,address=6502,suspend=y Trida</i>
<i> *</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>JDIMethodEntryDetection1</strong> {
&nbsp;
<i>    /**</i>
<i>     * Navratovy kod pouzity pri ukoncovani sledovane JVM.</i>
<i>     */</i>
    private static final int EXIT_VALUE = 0;
&nbsp;
<i>    /**</i>
<i>     * Jmeno konektoru, ktery pro pripojeni pouziva sockety.</i>
<i>     */</i>
    private static final String SOCKET_ATTACH_CONNECTOR_NAME = "com.sun.jdi.SocketAttach";
&nbsp;
<i>    /**</i>
<i>     * Vstupni metoda debuggeru.</i>
<i>     */</i>
    public static void <strong>main</strong>(String[] args) {
<i>        // ziskat (jedinou) instanci tridy VirtualMachineManager</i>
        VirtualMachineManager virtualMachineManager = Bootstrap.virtualMachineManager();
&nbsp;
<i>        // ziskat vsechny konektory pouzite pro pripojeni k bezici JVM</i>
        List&lt;AttachingConnector&gt; connectors = virtualMachineManager.attachingConnectors();
&nbsp;
<i>        // potrebujeme ziskat konektor pouzivajici pro pripojeni sockety</i>
        AttachingConnector connector = getSocketAttachConnector(connectors);
&nbsp;
        if (connector == null) {
            System.out.println("Socket connector is not available");
            return;
        }
&nbsp;
<i>        // jsme pripojeni ke sledovane JVM, takze lze provadet ladeni</i>
        debugVirtualMachineUsingSocket(connector);
    }
&nbsp;
<i>    /**</i>
<i>     * Ziskat konektor pouzivajici pro pripojeni sockety</i>
<i>     */</i>
    private static AttachingConnector <strong>getSocketAttachConnector</strong>(List&lt;AttachingConnector&gt; connectors) {
        for (AttachingConnector connector : connectors) {
            if (SOCKET_ATTACH_CONNECTOR_NAME.equals(connector.name())) {
                return connector;
            }
        }
<i>        // nenasli jsme zadny vhodny konektor</i>
        return null;
    }
&nbsp;
<i>    /**</i>
<i>     * Pripojeni k bezicimu virtualnimu stroji pres socket.</i>
<i>     * @throws InterruptedException </i>
<i>     */</i>
    private static void <strong>debugVirtualMachineUsingSocket</strong>(AttachingConnector connector) {
<i>        // nastaveni argumentu pouzivanych konektorem</i>
        Map&lt;String, Connector.Argument&gt; arguments = prepareConnectorArguments(connector);
&nbsp;
        try {
<i>            // pripojeni ke vzdalenemu bezicimu virtualnimu stroji Javy</i>
            VirtualMachine virtualMachine = connectToVirtualMachine(connector, arguments);
&nbsp;
<i>            // spustit sledovany virtualni stroj Javy</i>
            runVirtualMachine(virtualMachine);
&nbsp;
<i>            // ukazka pouziti EventRequestManageru</i>
            acquireAndUseEventRequestManager(virtualMachine);
&nbsp;
<i>            // ukonceni behu vzdaleneho virtualniho stroje</i>
            shutdownVirtualMachine(virtualMachine);
        }
        catch (IOException e) {
            e.printStackTrace();
        }
        catch (IllegalConnectorArgumentsException e) {
            e.printStackTrace();
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Nastaveni portu na cilove JVM, jenz debugger pouzije pro navazani spojeni.</i>
<i>     *</i>
<i>     * @param connector konektor pouzity pro pripojeni</i>
<i>     * @return mapa obsahujici parametry konektoru</i>
<i>     */</i>
    private static Map&lt;String, Connector.Argument&gt; <strong>prepareConnectorArguments</strong>(AttachingConnector connector) {
        Map&lt;String, Connector.Argument&gt; arguments = connector.defaultArguments();
        arguments.get("port").setValue("6502");
        return arguments;
    }
&nbsp;
<i>    /**</i>
<i>     * Pripojeni debuggeru ke sledovanemu virtualnimu stroji.</i>
<i>     *</i>
<i>     * @param connector konektor vyuzivajici pro spojeni sockety</i>
<i>     * @param arguments mapa obsahujici parametry pripojeni</i>
<i>     * @return sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     *</i>
<i>     * @throws IOException vyvolane v pripade, ze se pripojeni k JVM nepodari</i>
<i>     * @throws IllegalConnectorArgumentsException vyvolane v pripade spatne zadanych parametru</i>
<i>     */</i>
    private static VirtualMachine <strong>connectToVirtualMachine</strong>(AttachingConnector connector, Map&lt;String, Connector.Argument&gt; arguments)
        throws IOException, IllegalConnectorArgumentsException {
        System.out.println("Connecting to virtual machine");
        VirtualMachine virtualMachine = connector.attach(arguments);
        System.out.println("Connected");
        return virtualMachine;
    }
&nbsp;
<i>    /**</i>
<i>     * Spustit sledovany virtualni stroj</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>runVirtualMachine</strong>(VirtualMachine virtualMachine) {
        virtualMachine.resume();
    }
&nbsp;
<i>    /**</i>
<i>     * Ukonceni prace beziciho sledovaneho virtualniho stroje.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>shutdownVirtualMachine</strong>(VirtualMachine virtualMachine) {
        System.out.println("Calling exit");
        virtualMachine.exit(EXIT_VALUE);
    }
&nbsp;
<i>    /**</i>
<i>     * Ukazka pouziti EventRequestManageru.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>acquireAndUseEventRequestManager</strong>(VirtualMachine virtualMachine) {
        EventRequestManager eventRequestManager = virtualMachine.eventRequestManager();
        VMDeathRequest vmDeathRequest = registerVMDeathEvent(eventRequestManager);
        MethodEntryRequest methodEntryRequest = registerMethodEntryRequest(eventRequestManager);
<i>        // klasicka smycka pro zpracovani udalosti</i>
        eventLoop(virtualMachine, vmDeathRequest, methodEntryRequest);
    }
&nbsp;
<i>    /**</i>
<i>     * Registrace udalosti typu VMDeathEvent</i>
<i>     */</i>
    private static VMDeathRequest <strong>registerVMDeathEvent</strong>(EventRequestManager eventRequestManager) {
        VMDeathRequest vmDeathRequest = eventRequestManager.createVMDeathRequest();
<i>        // po registraci udalosti je jeste nutne tento typ udalosti povolit</i>
        vmDeathRequest.enable();
        return vmDeathRequest;
    }
&nbsp;
<i>    /**</i>
<i>     * Registrace udalosti typu MethodEntry</i>
<i>     */</i>
    private static MethodEntryRequest <strong>registerMethodEntryRequest</strong>(EventRequestManager eventRequestManager) {
        MethodEntryRequest methodEntryRequest = eventRequestManager.createMethodEntryRequest();
&nbsp;
<i>        // po registraci udalosti je jeste nutne tento typ udalosti povolit</i>
        methodEntryRequest.enable();
        return methodEntryRequest;
    }
&nbsp;
<i>    /**</i>
<i>     * Klasicka smycka pro postupne zpracovani udalosti.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     * @param vmDeathRequest objekt pro rizeni udalosti typu VMDeathEvent</i>
<i>     * @param methodEntryRequest objekt pro rizeni udalosti typu MethodEntry</i>
<i>     */</i>
    private static void <strong>eventLoop</strong>(VirtualMachine virtualMachine, VMDeathRequest vmDeathRequest, MethodEntryRequest methodEntryRequest) {
        EventQueue eventQueue = virtualMachine.eventQueue();
&nbsp;
<i>        // precist a zpracovat udalosti</i>
        while (processEvents(eventQueue, vmDeathRequest)) {
<i>            // jojo tady skutecne nic neni :)</i>
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Precteni a zpracovani udalosti</i>
<i>     *</i>
<i>     * @param eventQueue fronta udalosti</i>
<i>     * @param vmDeathRequest objekt pro rizeni udalosti typu VMDeathEvent</i>
<i>     *</i>
<i>     * @return true pokud se ma pokracovat ve zpracovavani udalosti</i>
<i>     *         false pokud se ma sledovana VM ukoncit</i>
<i>     */</i>
    private static boolean <strong>processEvents</strong>(EventQueue eventQueue, VMDeathRequest vmDeathRequest) {
        EventSet eventSet;
        try {
<i>            // precist udalosti z fronty</i>
            eventSet = eventQueue.remove();
            int events = eventSet.size();
            System.out.println("Got " + events + " request" + (events &gt; 1 ? "s:" : ":"));
&nbsp;
<i>            // projit vsemi udalostmi</i>
            for (Event event : eventSet) {
                if (event instanceof VMStartEvent) {
                    System.out.println("    VMStartEvent");
                }
                else if (event instanceof VMDeathEvent) {
                    System.out.println("    VMDeathEvent");
<i>                    // zakazat dalsi generovani udalosti</i>
<i>                    // (u VMDeathEvent je ve skutecnosti vzdy posledni udalost poslana) </i>
                    vmDeathRequest.disable();
<i>                    // posleze se zavola shutdownVirtualMachine()</i>
                    return false;
                }
                else if (event instanceof MethodEntryEvent) {
                    printMethodEntryInfo((MethodEntryEvent)event);
                }
                else {
                    System.out.println("    other event");
                }
            }
<i>            // znovu postit vsechna vlakna</i>
            eventSet.resume();
        }
        catch (InterruptedException e) {
            e.printStackTrace();
        }
        return true;
    }
&nbsp;
<i>    /**</i>
<i>     * Zavolano pri vyskytu udalosti typu MethodEntry</i>
<i>     */</i>
    private static void <strong>printMethodEntryInfo</strong>(MethodEntryEvent event) {
        String methodName = event.method().name();
&nbsp;
<i>        // nyni mame vsechny informace, lze je tedy vypsat</i>
        System.out.format("    entry into method: %s\n", methodName);
    }
&nbsp;
}
</pre>

<p>Pøíklad výstupu generovaného tímto demonstraèním pøíkladem (výstup je
zkrácen):</p>

<pre>
Got 1 request:
    entry into method: &lt;init&gt;
Got 1 request:
    entry into method: &lt;init&gt;
Got 1 request:
    entry into method: &lt;init&gt;
Got 1 request:
    entry into method: getClassSignature
...
...
...
Got 1 request:
    entry into method: hook
Got 1 request:
    entry into method: &lt;init&gt;
Got 1 request:
    entry into method: &lt;init&gt;
Got 1 request:
    entry into method: run
Got 1 request:
    entry into method: &lt;init&gt;
Got 1 request:
    entry into method: &lt;init&gt;
Got 1 request:
    entry into method: &lt;init&gt;
Got 1 request:
    entry into method: &lt;init&gt;
Got 1 request:
    entry into method: toArray
Got 1 request:
    entry into method: size
Got 1 request:
    entry into method: size
Got 1 request:
    entry into method: iterator
Got 1 request:
    entry into method: keySet
Got 1 request:
    entry into method: &lt;init&gt;
Got 1 request:
    entry into method: &lt;init&gt;
Got 1 request:
    entry into method: &lt;init&gt;
Got 1 request:
    entry into method: &lt;init&gt;
Got 1 request:
    entry into method: &lt;init&gt;
Got 1 request:
    entry into method: iterator
Got 1 request:
    entry into method: newKeyIterator
Got 1 request:
    entry into method: &lt;init&gt;
Got 1 request:
    entry into method: &lt;init&gt;
Got 1 request:
    entry into method: &lt;init&gt;
Got 1 request:
    entry into method: &lt;init&gt;
Got 1 request:
    entry into method: &lt;init&gt;
Got 1 request:
    entry into method: access$100
Got 1 request:
    entry into method: hasNext
Got 1 request:
    entry into method: access$100
Got 1 request:
    entry into method: getClass
Got 1 request:
    entry into method: reverse
Got 1 request:
    entry into method: size
Got 1 request:
    entry into method: iterator
Got 1 request:
    entry into method: &lt;init&gt;
Got 1 request:
    entry into method: &lt;init&gt;
Got 1 request:
    entry into method: &lt;init&gt;
Got 1 request:
    entry into method: hasNext
Got 1 request:
    entry into method: size
Got 1 request:
    entry into method: hasNext
Got 1 request:
    entry into method: size
Got 2 requests:
    VMDeathEvent
Calling exit
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Filtrace tøíd, pro jejich¾ metody se vyvolá událost <strong>MethodEntryEvent</strong></h2>

<p>Pokud jste si vyzkou¹eli pøelo¾it a spustit debugger z&nbsp;pøedchozí
kapitoly, zajisté jste si v¹imli, ¾e poèet událostí generovaných pøi vstupu do
metod, je znaèný, a to i pro jednoduché aplikace typu &bdquo;Hello
world!&ldquo;. Vìt¹inou v¹ak nepotøebujeme detekovat vstup do v¹ech metod, ale
jen do metod nále¾ejících nìjaké tøídì nebo nìkolika vybraným tøídám.
Samozøejmì je mo¾né pro ka¾dou událost typu <strong>MethodEntryEvent</strong>
zjistit jméno tøídy pøíslu¹né volané metody, to je v¹ak pomìrnì nároèné
z&nbsp;hlediska zpracování &ndash; filtrace se toti¾ provádí v&nbsp;pomìrnì
pozdním zpracování události (po vytvoøení události a jejím vlo¾ení do fronty
událostí).</p>

<p>Namísto toho je mo¾né pro události typu <strong>MethodEntryEvent</strong>
definovat filtr, který povolí vytvoøení událostí pouze pro metody tøíd, jejich¾
jména odpovídají zadanému regulárnímu výrazu. Pro tento úèel lze vyu¾ít
<strong>com.sun.jdi.request.MethodEntryRequest.addClassFilter(java.lang.String)</strong>
popø.&nbsp;<strong>com.sun.jdi.request.MethodEntryRequest.addClassFilter(com.sun.jdi.ReferenceType)</strong>
(zde se ji¾ regulární výraz samozøejmì nepou¾ívá). Kromì
&bdquo;pozitivního&ldquo; filtru, je mo¾né pou¾ít i filtr
&bdquo;negativní&ldquo;, který se zadává s&nbsp;vyu¾itím
<strong>com.sun.jdi.request.MethodEntryRequest.addClassExclusionFilter(java.lang.String)</strong>.
Upravme nyní u¾ivatelskou metodu <strong>registerMethodEntryRequest()</strong>
takovým zpùsobem, aby se zji¹»ovaly vstupy do metod tøídy
&bdquo;Test5&ldquo;:</p>

<pre>
<i>    /**</i>
<i>     * Registrace udalosti typu MethodEntry</i>
<i>     */</i>
    private static MethodEntryRequest <strong>registerMethodEntryRequest</strong>(EventRequestManager eventRequestManager) {
        MethodEntryRequest methodEntryRequest = eventRequestManager.createMethodEntryRequest();
&nbsp;
<i>        // pridame jeste filtr</i>
        methodEntryRequest.addClassFilter("Test5");
&nbsp;
<i>        // po registraci udalosti je jeste nutne tento typ udalosti povolit</i>
        methodEntryRequest.enable();
        return methodEntryRequest;
    }
</pre>

<p>Po pøidání filtru se výstup debuggeru výrazným zpùsobem zkrátí:</p>

<pre>
Connecting to virtual machine
Connected
Got 1 request:
    VMStartEvent
Got 1 request:
    entry into method: main
Got 1 request:
    entry into method: &lt;init&gt;
Got 1 request:
    entry into method: run
Got 1 request:
    entry into method: foo
Got 1 request:
    entry into method: bar
Got 1 request:
    entry into method: baz
Got 2 requests:
    VMDeathEvent
Calling exit
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Zji¹tìní podrobnìj¹ích informací o volané metodì</h2>

<p>U¾ivatelskou metodu <strong>printMethodEntryInfo()</strong> je samozøejmì
mo¾né rùznými zpùsoby roz¹iøovat. Kromì jména metody (co¾ je zcela základní
informace) lze zjistit i jméno pøíslu¹né tøídy a dokonce i pozici volané metody
v&nbsp;rámci zdrojového souboru pøíslu¹né tøídy. První úprava metody
<strong>printMethodEntryInfo()</strong> vyu¾ívá objekt typu
<strong>Location</strong>, s&nbsp;ním¾ jsme se ji¾ v&nbsp;tomto seriálu
setkali:</p>

<pre>
<i>    /**</i>
<i>     * Zavolano pri vyskytu udalosti typu MethodEntry</i>
<i>     */</i>
    private static void <strong>printMethodEntryInfo</strong>(MethodEntryEvent event) {
        Location location = event.location();
<i>        // ziskat vsechny informace o pozici v pozastavenem vlaknu</i>
        String className = getClassName(location);
        String methodName = getMethodName(location);
        String sourceName = getSourceName(location);
        String lineNumber = getLineNumber(location);
&nbsp;
<i>        // nyni mame vsechny informace, lze je tedy vypsat</i>
        System.out.format("    entry into method: %s.%s (%s:%s)\n", className, methodName, sourceName, lineNumber);
    }
</pre>

<p>Pro získání jména tøídy, ve které je volaná metoda deklarována, se pou¾ívá
volání <strong>com.sun.jdi.Method.declaringType()</strong> (pøesnìji øeèeno
<strong>com.sun.jdi.TypeComponent.declaringType()</strong>) vracející objekt
typu <strong>ReferenceType</strong>:</p>

<pre>
<i>    /**</i>
<i>     * Jmeno tridy, jejiz metoda byla zavolana.</i>
<i>     */</i>
    private static String <strong>getClassName</strong>(Location location) {
        return location.method().declaringType().name();
    }
</pre>

<p>Jako ukázku toho, ¾e jméno volané metody je mo¾né získat více zpùsoby, je
zde ukázáno pou¾ití <strong>Location.method()</strong> namísto
<strong>MethodEntryEvent.method()</strong>:</p>

<pre>
<i>    /**</i>
<i>     * Jmeno volane metody.</i>
<i>     */</i>
    private static String <strong>getMethodName</strong>(Location location) {
        return location.method().name();
    }
</pre>

<p>Zji¹tìní jména zdrojového kódu, v&nbsp;nìm¾ je volaná metoda a samozøejmì i
pøíslu¹ná tøída deklarována, je velmi jednoduché, proto¾e pro tento úèel lze
pou¾ít volání <strong>com.sun.jdi.Location.sourceName()</strong>.
V&nbsp;pøípadì potøeby je mo¾né zjistit i cestu k&nbsp;tomuto souboru
s&nbsp;vyu¾itím <strong>com.sun.jdi.Location.sourcePath()</strong> (tuto
informaci jsme v&nbsp;rozhraní <i>JVM TI</i> zji¹»ovali jen velmi slo¾itým
zpùsobem):</p>

<pre>
<i>    /**</i>
<i>     * Ziskani informaci o jmene zdrojoveho souboru pro danou lokaci.</i>
<i>     */</i>
    private static String <strong>getSourceName</strong>(Location location) {
        try {
            return location.sourceName();
        }
        catch (AbsentInformationException e) {
            return "unknown";
        }
    }
</pre>

<p>Informaci o èísle øádku v&nbsp;rámci zdrojového souboru (pokud je ov¹em tato
informace vùbec dostupná) získáme s&nbsp;vyu¾itím
<strong>com.sun.jdi.Location.lineNumber()</strong>, která vrátí kladné èíslo
v&nbsp;pøípadì, ¾e je èíslo øádku známé a zápornou èi nulovou hodnotu ve
chvíli, kdy èíslo øádku není mo¾né z&nbsp;nìjakého dùvodu zjistit (typicky se
jedná o nativní metody).</p>

<pre>
<i>    /**</i>
<i>     * Prevod cisla radku na retezec, pokud je to mozne.</i>
<i>     */</i>
    private static String <strong>getLineNumber</strong>(Location location) {
        int lineNumber = location.lineNumber();
<i>        // u nativnich metod nelze zjistit cisla radku</i>
        return lineNumber &gt;= 0 ? "" + lineNumber : "&lt;native method&gt;";
    }
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Zdrojový kód demonstraèního pøíkladu <strong>JDIMethodEntryDetection2</strong></h2>

<p>Vylep¹ení popsaná <a href="#k05">v&nbsp;páté</a> a <a href="#k06">¹esté
kapitole</a> jsou souèástí dne¹ního druhého demonstraèního pøíkladu nazvaného
<strong>JDIMethodEntryDetection2</strong>, jeho¾ zdrojový kód je zobrazen pod
tímto odstavcem:</p>

<pre>
import java.io.IOException;
import java.util.List;
import java.util.Map;
&nbsp;
import com.sun.jdi.AbsentInformationException;
import com.sun.jdi.Bootstrap;
import com.sun.jdi.Location;
import com.sun.jdi.VirtualMachine;
import com.sun.jdi.VirtualMachineManager;
import com.sun.jdi.connect.AttachingConnector;
import com.sun.jdi.connect.Connector;
import com.sun.jdi.connect.IllegalConnectorArgumentsException;
import com.sun.jdi.event.Event;
import com.sun.jdi.event.EventQueue;
import com.sun.jdi.event.EventSet;
import com.sun.jdi.event.MethodEntryEvent;
import com.sun.jdi.event.VMDeathEvent;
import com.sun.jdi.event.VMStartEvent;
import com.sun.jdi.request.EventRequestManager;
import com.sun.jdi.request.MethodEntryRequest;
import com.sun.jdi.request.VMDeathRequest;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Pripojeni k bezicimu virtualnimu stroji Javy,</i>
<i> * ktery byl spusten s parametry:</i>
<i> * java -agentlib:jdwp=transport=dt_socket,server=y,address=6502,suspend=y Trida</i>
<i> *</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>JDIMethodEntryDetection2</strong> {
&nbsp;
<i>    /**</i>
<i>     * Navratovy kod pouzity pri ukoncovani sledovane JVM.</i>
<i>     */</i>
    private static final int EXIT_VALUE = 0;
&nbsp;
<i>    /**</i>
<i>     * Jmeno konektoru, ktery pro pripojeni pouziva sockety.</i>
<i>     */</i>
    private static final String SOCKET_ATTACH_CONNECTOR_NAME = "com.sun.jdi.SocketAttach";
&nbsp;
<i>    /**</i>
<i>     * Vstupni metoda debuggeru.</i>
<i>     */</i>
    public static void <strong>main</strong>(String[] args) {
<i>        // ziskat (jedinou) instanci tridy VirtualMachineManager</i>
        VirtualMachineManager virtualMachineManager = Bootstrap.virtualMachineManager();
&nbsp;
<i>        // ziskat vsechny konektory pouzite pro pripojeni k bezici JVM</i>
        List&lt;AttachingConnector&gt; connectors = virtualMachineManager.attachingConnectors();
&nbsp;
<i>        // potrebujeme ziskat konektor pouzivajici pro pripojeni sockety</i>
        AttachingConnector connector = getSocketAttachConnector(connectors);
&nbsp;
        if (connector == null) {
            System.out.println("Socket connector is not available");
            return;
        }
&nbsp;
<i>        // jsme pripojeni ke sledovane JVM, takze lze provadet ladeni</i>
        debugVirtualMachineUsingSocket(connector);
    }
&nbsp;
<i>    /**</i>
<i>     * Ziskat konektor pouzivajici pro pripojeni sockety</i>
<i>     */</i>
    private static AttachingConnector <strong>getSocketAttachConnector</strong>(List&lt;AttachingConnector&gt; connectors) {
        for (AttachingConnector connector : connectors) {
            if (SOCKET_ATTACH_CONNECTOR_NAME.equals(connector.name())) {
                return connector;
            }
        }
<i>        // nenasli jsme zadny vhodny konektor</i>
        return null;
    }
&nbsp;
<i>    /**</i>
<i>     * Pripojeni k bezicimu virtualnimu stroji pres socket.</i>
<i>     * @throws InterruptedException </i>
<i>     */</i>
    private static void <strong>debugVirtualMachineUsingSocket</strong>(AttachingConnector connector) {
<i>        // nastaveni argumentu pouzivanych konektorem</i>
        Map&lt;String, Connector.Argument&gt; arguments = prepareConnectorArguments(connector);
&nbsp;
        try {
<i>            // pripojeni ke vzdalenemu bezicimu virtualnimu stroji Javy</i>
            VirtualMachine virtualMachine = connectToVirtualMachine(connector, arguments);
&nbsp;
<i>            // spustit sledovany virtualni stroj Javy</i>
            runVirtualMachine(virtualMachine);
&nbsp;
<i>            // ukazka pouziti EventRequestManageru</i>
            acquireAndUseEventRequestManager(virtualMachine);
&nbsp;
<i>            // ukonceni behu vzdaleneho virtualniho stroje</i>
            shutdownVirtualMachine(virtualMachine);
        }
        catch (IOException e) {
            e.printStackTrace();
        }
        catch (IllegalConnectorArgumentsException e) {
            e.printStackTrace();
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Nastaveni portu na cilove JVM, jenz debugger pouzije pro navazani spojeni.</i>
<i>     *</i>
<i>     * @param connector konektor pouzity pro pripojeni</i>
<i>     * @return mapa obsahujici parametry konektoru</i>
<i>     */</i>
    private static Map&lt;String, Connector.Argument&gt; <strong>prepareConnectorArguments</strong>(AttachingConnector connector) {
        Map&lt;String, Connector.Argument&gt; arguments = connector.defaultArguments();
        arguments.get("port").setValue("6502");
        return arguments;
    }
&nbsp;
<i>    /**</i>
<i>     * Pripojeni debuggeru ke sledovanemu virtualnimu stroji.</i>
<i>     *</i>
<i>     * @param connector konektor vyuzivajici pro spojeni sockety</i>
<i>     * @param arguments mapa obsahujici parametry pripojeni</i>
<i>     * @return sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     *</i>
<i>     * @throws IOException vyvolane v pripade, ze se pripojeni k JVM nepodari</i>
<i>     * @throws IllegalConnectorArgumentsException vyvolane v pripade spatne zadanych parametru</i>
<i>     */</i>
    private static VirtualMachine <strong>connectToVirtualMachine</strong>(AttachingConnector connector, Map&lt;String, Connector.Argument&gt; arguments)
        throws IOException, IllegalConnectorArgumentsException {
        System.out.println("Connecting to virtual machine");
        VirtualMachine virtualMachine = connector.attach(arguments);
        System.out.println("Connected");
        return virtualMachine;
    }
&nbsp;
<i>    /**</i>
<i>     * Spustit sledovany virtualni stroj</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>runVirtualMachine</strong>(VirtualMachine virtualMachine) {
        virtualMachine.resume();
    }
&nbsp;
<i>    /**</i>
<i>     * Ukonceni prace beziciho sledovaneho virtualniho stroje.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>shutdownVirtualMachine</strong>(VirtualMachine virtualMachine) {
        System.out.println("Calling exit");
        virtualMachine.exit(EXIT_VALUE);
    }
&nbsp;
<i>    /**</i>
<i>     * Ukazka pouziti EventRequestManageru.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>acquireAndUseEventRequestManager</strong>(VirtualMachine virtualMachine) {
        EventRequestManager eventRequestManager = virtualMachine.eventRequestManager();
        VMDeathRequest vmDeathRequest = registerVMDeathEvent(eventRequestManager);
        MethodEntryRequest methodEntryRequest = registerMethodEntryRequest(eventRequestManager);
<i>        // klasicka smycka pro zpracovani udalosti</i>
        eventLoop(virtualMachine, vmDeathRequest, methodEntryRequest);
    }
&nbsp;
<i>    /**</i>
<i>     * Registrace udalosti typu VMDeathEvent</i>
<i>     */</i>
    private static VMDeathRequest <strong>registerVMDeathEvent</strong>(EventRequestManager eventRequestManager) {
        VMDeathRequest vmDeathRequest = eventRequestManager.createVMDeathRequest();
<i>        // po registraci udalosti je jeste nutne tento typ udalosti povolit</i>
        vmDeathRequest.enable();
        return vmDeathRequest;
    }
&nbsp;
<i>    /**</i>
<i>     * Registrace udalosti typu MethodEntry</i>
<i>     */</i>
    private static MethodEntryRequest <strong>registerMethodEntryRequest</strong>(EventRequestManager eventRequestManager) {
        MethodEntryRequest methodEntryRequest = eventRequestManager.createMethodEntryRequest();
&nbsp;
<i>        // pridame filtr na jmeno tridy</i>
        methodEntryRequest.addClassFilter("Test5");
&nbsp;
<i>        // po registraci udalosti je jeste nutne tento typ udalosti povolit</i>
        methodEntryRequest.enable();
        return methodEntryRequest;
    }
&nbsp;
<i>    /**</i>
<i>     * Klasicka smycka pro postupne zpracovani udalosti.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     * @param vmDeathRequest objekt pro rizeni udalosti typu VMDeathEvent</i>
<i>     * @param methodEntryRequest objekt pro rizeni udalosti typu MethodEntry</i>
<i>     */</i>
    private static void <strong>eventLoop</strong>(VirtualMachine virtualMachine, VMDeathRequest vmDeathRequest, MethodEntryRequest methodEntryRequest) {
        EventQueue eventQueue = virtualMachine.eventQueue();
&nbsp;
<i>        // precist a zpracovat udalosti</i>
        while (processEvents(eventQueue, vmDeathRequest)) {
<i>            // jojo tady skutecne nic neni :)</i>
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Precteni a zpracovani udalosti</i>
<i>     *</i>
<i>     * @param eventQueue fronta udalosti</i>
<i>     * @param vmDeathRequest objekt pro rizeni udalosti typu VMDeathEvent</i>
<i>     *</i>
<i>     * @return true pokud se ma pokracovat ve zpracovavani udalosti</i>
<i>     *         false pokud se ma sledovana VM ukoncit</i>
<i>     */</i>
    private static boolean <strong>processEvents</strong>(EventQueue eventQueue, VMDeathRequest vmDeathRequest) {
        EventSet eventSet;
        try {
<i>            // precist udalosti z fronty</i>
            eventSet = eventQueue.remove();
            int events = eventSet.size();
            System.out.println("Got " + events + " request" + (events &gt; 1 ? "s:" : ":"));
&nbsp;
<i>            // projit vsemi udalostmi</i>
            for (Event event : eventSet) {
                if (event instanceof VMStartEvent) {
                    System.out.println("    VMStartEvent");
                }
                else if (event instanceof VMDeathEvent) {
                    System.out.println("    VMDeathEvent");
<i>                    // zakazat dalsi generovani udalosti</i>
<i>                    // (u VMDeathEvent je ve skutecnosti vzdy posledni udalost poslana) </i>
                    vmDeathRequest.disable();
<i>                    // posleze se zavola shutdownVirtualMachine()</i>
                    return false;
                }
                else if (event instanceof MethodEntryEvent) {
                    printMethodEntryInfo((MethodEntryEvent)event);
                }
                else {
                    System.out.println("    other event");
                }
            }
<i>            // znovu postit vsechna vlakna</i>
            eventSet.resume();
        }
        catch (InterruptedException e) {
            e.printStackTrace();
        }
        return true;
    }
&nbsp;
<i>    /**</i>
<i>     * Zavolano pri vyskytu udalosti typu MethodEntry</i>
<i>     */</i>
    private static void <strong>printMethodEntryInfo</strong>(MethodEntryEvent event) {
        Location location = event.location();
<i>        // ziskat vsechny informace o pozici v pozastavenem vlaknu</i>
        String className = getClassName(location);
        String methodName = getMethodName(location);
        String sourceName = getSourceName(location);
        String lineNumber = getLineNumber(location);
&nbsp;
<i>        // nyni mame vsechny informace, lze je tedy vypsat</i>
        System.out.format("    entry into method: %s.%s (%s:%s)\n", className, methodName, sourceName, lineNumber);
    }
&nbsp;
<i>    /**</i>
<i>     * Jmeno tridy, jejiz metoda byla zavolana.</i>
<i>     */</i>
    private static String <strong>getClassName</strong>(Location location) {
        return location.method().declaringType().name();
    }
&nbsp;
<i>    /**</i>
<i>     * Jmeno volane metody.</i>
<i>     */</i>
    private static String <strong>getMethodName</strong>(Location location) {
        return location.method().name();
    }
&nbsp;
<i>    /**</i>
<i>     * Ziskani informaci o jmene zdrojoveho souboru pro danou lokaci.</i>
<i>     */</i>
    private static String <strong>getSourceName</strong>(Location location) {
        try {
            return location.sourceName();
        }
        catch (AbsentInformationException e) {
            return "unknown";
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Prevod cisla radku na retezec, pokud je to mozne.</i>
<i>     */</i>
    private static String <strong>getLineNumber</strong>(Location location) {
        int lineNumber = location.lineNumber();
<i>        // u nativnich metod nelze zjistit cisla radku</i>
        return lineNumber &gt;= 0 ? "" + lineNumber : "&lt;native method&gt;";
    }
&nbsp;
}
</pre>

<p>Po spu¹tìní tohoto pøíkladu ji¾ získáme zajímavìj¹í výstup:</p>

<pre>
Connecting to virtual machine
Connected
Got 1 request:
    VMStartEvent
Got 1 request:
    entry into method: Test5.&lt;init&gt; (Test5.java:1)
Got 1 request:
    entry into method: Test5.run (Test5.java:4)
Got 1 request:
    entry into method: Test5.foo (Test5.java:10)
Got 1 request:
    entry into method: Test5.bar (Test5.java:15)
Got 1 request:
    entry into method: Test5.baz (Test5.java:19)
Got 2 requests:
    VMDeathEvent
Calling exit
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Zji¹tìní modifikátorù, parametrù a návratových typù volaných metod</h2>

<p>Pro zajímavost je¹tì debugger roz¹íøíme o výpis prakticky v¹ech informací,
které lze zjistit pro volané metody. Ji¾ jsme si ukázali, jak se zjistí a
zobrazí jméno tøídy, jméno metody, jméno zdrojového souboru s&nbsp;tøídou a
popø.&nbsp;i èíslo øádku, na nìm¾ metodu nalezneme. Tyto informace lze doplnit
o plnou hlavièku metody, vèetnì jejích modifikátorù, návratového typu i typù
argumentù metody. U¾ivatelská metoda <strong>printMethodEntryInfo()</strong> je
tedy nále¾itým zpùsobem roz¹íøena:</p>

<pre>
<i>    /**</i>
<i>     * Zavolano pri vyskytu udalosti typu MethodEntry</i>
<i>     * </i>
<i>     * @param event</i>
<i>     *            udalost typu MethodEntry</i>
<i>     */</i>
    private static void <strong>printMethodEntryInfo</strong>(MethodEntryEvent event) {
        Method method = event.method();
        Location location = event.location();
&nbsp;
<i>        // ziskat vsechny informace o pozici v pozastavenem vlaknu</i>
        String className = getClassName(location);
        String methodName = getMethodName(location);
        String sourceName = getSourceName(location);
        String lineNumber = getLineNumber(location);
&nbsp;
<i>        // typ navratove hodnoty reprezentovany jako retezec</i>
        String type = method.returnTypeName();
<i>        // priznaky pristupovych prav</i>
        String accessibilityStr = getAccessibility(method);
        String staticStr = method.isStatic() ? "static " : "";
        String finalStr = method.isFinal() ? "final " : "";
        String nativeStr = method.isNative() ? "native " : "";
        String synchronizedStr = method.isSynchronized() ? "synchronized " : "";
&nbsp;
<i>        // nyni mame vsechny informace, lze je tedy vypsat</i>
        System.out.format("    entry into method: %s%s%s%s%s%s %s.%s",
                accessibilityStr, staticStr, finalStr,
                nativeStr, synchronizedStr, type,
                className, methodName);
        printMethodArguments(method);
<i>        // po vypisu argumentu se jeste vypise jmeno zdrojoveho</i>
<i>        // souboru a cislo radku</i>
        System.out.format("   (%s:%s)\n", sourceName, lineNumber);
    }
</pre>

<p>U volaných metod je mo¾né zjistit a vypsat dal¹í dùle¾itou informaci. Jedná
se o seznam argumentù metody. V&nbsp;závislosti na tom, zda byl bajtkód
zkoumané tøídy pøelo¾en s&nbsp;pøepínaèem <strong>-g</strong> èi bez tohoto
modifikátoru, lze o argumentech zjistit buï pouze informaci o typech
jednotlivých argumentù, popø.&nbsp;i jména argumentù &ndash; v&nbsp;tomto
pøípadì je v¹ak nutné provést pøeklad s&nbsp;pøepínaèem <strong>-g</strong>,
jinak se tato informace do bajtkódu neulo¾í, proto¾e ji virtuální stroj Javy ve
skuteènosti pro spu¹tìní metody nepotøebuje. S&nbsp;vyu¾itím rozhraní
<i>JDI</i> nelze snadno zjistit, které informace o argumentech metod jsou
k&nbsp;dispozici, proto je kód metody nazvané
<strong>printMethodArguments()</strong> rozdìlen na dvì èásti. V&nbsp;první
èásti umístìné v&nbsp;bloku <strong>try {}</strong> se zji¹»ují jak jména, tak
i typy argumentù, v&nbsp;èásti umístìné v&nbsp;bloku <strong>catch {}</strong>
pak pouze typy argumentù metody, nebo» tyto informace má JVM k&nbsp;dispozici
v¾dy. Výjimka, která rozhodne o pou¾ití prvního èi druhého bloku, je vyhozena
z&nbsp;metody <strong>Method.arguments()</strong> umístìné jako první pøíkaz
v&nbsp;bloku <strong>try{}</strong> (tuto èást kódu ji¾ vlastnì známe
z&nbsp;pøedchozích èástí tohoto seriálu):</p>

<pre>
<i>    /**</i>
<i>     * Vypis argumentu metody.</i>
<i>     *</i>
<i>     * @param method metoda ve sledovanem virtualnim stroji</i>
<i>     */</i>
    private static void <strong>printMethodArguments</strong>(Method method) {
        System.out.print("(");
        boolean first = true;
&nbsp;
        try {
<i>            // idealni je zjistit jmena i typy argumentu</i>
<i>            // pokud je to samozrejme mozne</i>
            List&lt;LocalVariable&gt; arguments = method.arguments();
<i>            // vypsat typy a jmena vsech argumentu metody</i>
            for (LocalVariable argument : arguments) {
                if (first) {
                    first = false;
                }
                else {
                    System.out.print(", ");
                }
                System.out.print(argument.typeName() + " " + argument.name());
            }
        }
        catch (AbsentInformationException e) {
<i>            // pokud jmena argumentu nelze zjistit,</i>
<i>            // alespon typy jsou vzdy k dispozici</i>
            List&lt;String&gt; arguments = method.argumentTypeNames();
<i>            // vypsat typy vsech argumentu metody</i>
            for (String argument : arguments) {
                if (first) {
                    first = false;
                }
                else {
                    System.out.print(", ");
                }
                System.out.print(argument);
            }
        }
        System.out.print(");");
    }
</pre>

<p>Poslední dùle¾itou informací o volané metodì jsou její pøístupová práva,
která lze zjistit velmi snadno:</p>

<pre>
<i>    /**</i>
<i>     * Pristupova prava k atributu ci k metode (my zde tuto metodu</i>
<i>     * vyuzijeme pouze pro ziskani pristupovych prav k volanym metodam)</i>
<i>     */</i>
    private static String <strong>getAccessibility</strong>(Accessible methodOrField) {
        if (methodOrField.isPublic()) {
            return "public ";
        }
        if (methodOrField.isProtected()) {
            return "protected ";
        }
        if (methodOrField.isPrivate()) {
            return "private ";
        }
        return "";
    }
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Zdrojový kód demonstraèního pøíkladu <strong>JDIMethodEntryDetection3</strong></h2>

<p>Koneènì se dostáváme ke zdrojovému kódu dne¹ního posledního demonstraèního
pøíkladu nazvaného <strong>JDIMethodEntryDetection3</strong>. Tento pøíklad
&ndash; debugger &ndash; doká¾e vypsat v¹echny dostupné informace o volaných
metodách nále¾ejících do tøídy <strong>Test5</strong>. Kromì jmen metod se
vypí¹ou i jejich modifikátory, návratový typ a argumenty (vèetnì jmen
argumentù, pokud je ov¹em tato informace dostupná):</p>

<pre>
import java.io.IOException;
import java.util.List;
import java.util.Map;
&nbsp;
import com.sun.jdi.AbsentInformationException;
import com.sun.jdi.Accessible;
import com.sun.jdi.Bootstrap;
import com.sun.jdi.LocalVariable;
import com.sun.jdi.Location;
import com.sun.jdi.Method;
import com.sun.jdi.VirtualMachine;
import com.sun.jdi.VirtualMachineManager;
import com.sun.jdi.connect.AttachingConnector;
import com.sun.jdi.connect.Connector;
import com.sun.jdi.connect.IllegalConnectorArgumentsException;
import com.sun.jdi.event.Event;
import com.sun.jdi.event.EventQueue;
import com.sun.jdi.event.EventSet;
import com.sun.jdi.event.MethodEntryEvent;
import com.sun.jdi.event.VMDeathEvent;
import com.sun.jdi.event.VMStartEvent;
import com.sun.jdi.request.EventRequestManager;
import com.sun.jdi.request.MethodEntryRequest;
import com.sun.jdi.request.VMDeathRequest;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Pripojeni k bezicimu virtualnimu stroji Javy,</i>
<i> * ktery byl spusten s parametry:</i>
<i> * java -agentlib:jdwp=transport=dt_socket,server=y,address=6502,suspend=y Trida</i>
<i> *</i>
<i> * Detekce vstupu do metod deklarovanych ve tride Test5.</i>
<i> * U kazde metody se vypise jeji typ, jmeno i typy parametru, popr.</i>
<i> * i jmena parametru, pokud je ovsem lze zjistit.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>JDIMethodEntryDetection3</strong> {
&nbsp;
<i>    /**</i>
<i>     * Navratovy kod pouzity pri ukoncovani sledovane JVM.</i>
<i>     */</i>
    private static final int EXIT_VALUE = 0;
&nbsp;
<i>    /**</i>
<i>     * Jmeno konektoru, ktery pro pripojeni pouziva sockety.</i>
<i>     */</i>
    private static final String SOCKET_ATTACH_CONNECTOR_NAME = "com.sun.jdi.SocketAttach";
&nbsp;
<i>    /**</i>
<i>     * Vstupni metoda debuggeru.</i>
<i>     */</i>
    public static void <strong>main</strong>(String[] args) {
<i>        // ziskat (jedinou) instanci tridy VirtualMachineManager</i>
        VirtualMachineManager virtualMachineManager = Bootstrap.virtualMachineManager();
&nbsp;
<i>        // ziskat vsechny konektory pouzite pro pripojeni k bezici JVM</i>
        List&lt;AttachingConnector&gt; connectors = virtualMachineManager.attachingConnectors();
&nbsp;
<i>        // potrebujeme ziskat konektor pouzivajici pro pripojeni sockety</i>
        AttachingConnector connector = getSocketAttachConnector(connectors);
&nbsp;
        if (connector == null) {
            System.out.println("Socket connector is not available");
            return;
        }
&nbsp;
<i>        // jsme pripojeni ke sledovane JVM, takze lze provadet ladeni</i>
        debugVirtualMachineUsingSocket(connector);
    }
&nbsp;
<i>    /**</i>
<i>     * Ziskat konektor pouzivajici pro pripojeni sockety</i>
<i>     */</i>
    private static AttachingConnector <strong>getSocketAttachConnector</strong>(List&lt;AttachingConnector&gt; connectors) {
        for (AttachingConnector connector : connectors) {
            if (SOCKET_ATTACH_CONNECTOR_NAME.equals(connector.name())) {
                return connector;
            }
        }
<i>        // nenasli jsme zadny vhodny konektor</i>
        return null;
    }
&nbsp;
<i>    /**</i>
<i>     * Pripojeni k bezicimu virtualnimu stroji pres socket.</i>
<i>     * @throws InterruptedException </i>
<i>     */</i>
    private static void <strong>debugVirtualMachineUsingSocket</strong>(AttachingConnector connector) {
<i>        // nastaveni argumentu pouzivanych konektorem</i>
        Map&lt;String, Connector.Argument&gt; arguments = prepareConnectorArguments(connector);
&nbsp;
        try {
<i>            // pripojeni ke vzdalenemu bezicimu virtualnimu stroji Javy</i>
            VirtualMachine virtualMachine = connectToVirtualMachine(connector, arguments);
&nbsp;
<i>            // spustit sledovany virtualni stroj Javy</i>
            runVirtualMachine(virtualMachine);
&nbsp;
<i>            // ukazka pouziti EventRequestManageru</i>
            acquireAndUseEventRequestManager(virtualMachine);
&nbsp;
<i>            // ukonceni behu vzdaleneho virtualniho stroje</i>
            shutdownVirtualMachine(virtualMachine);
        }
        catch (IOException e) {
            e.printStackTrace();
        }
        catch (IllegalConnectorArgumentsException e) {
            e.printStackTrace();
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Nastaveni portu na cilove JVM, jenz debugger pouzije pro navazani spojeni.</i>
<i>     *</i>
<i>     * @param connector konektor pouzity pro pripojeni</i>
<i>     * @return mapa obsahujici parametry konektoru</i>
<i>     */</i>
    private static Map&lt;String, Connector.Argument&gt; <strong>prepareConnectorArguments</strong>(AttachingConnector connector) {
        Map&lt;String, Connector.Argument&gt; arguments = connector.defaultArguments();
        arguments.get("port").setValue("6502");
        return arguments;
    }
&nbsp;
<i>    /**</i>
<i>     * Pripojeni debuggeru ke sledovanemu virtualnimu stroji.</i>
<i>     *</i>
<i>     * @param connector konektor vyuzivajici pro spojeni sockety</i>
<i>     * @param arguments mapa obsahujici parametry pripojeni</i>
<i>     * @return sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     *</i>
<i>     * @throws IOException vyvolane v pripade, ze se pripojeni k JVM nepodari</i>
<i>     * @throws IllegalConnectorArgumentsException vyvolane v pripade spatne zadanych parametru</i>
<i>     */</i>
    private static VirtualMachine <strong>connectToVirtualMachine</strong>(AttachingConnector connector, Map&lt;String, Connector.Argument&gt; arguments)
        throws IOException, IllegalConnectorArgumentsException {
        System.out.println("Connecting to virtual machine");
        VirtualMachine virtualMachine = connector.attach(arguments);
        System.out.println("Connected");
        return virtualMachine;
    }
&nbsp;
<i>    /**</i>
<i>     * Spustit sledovany virtualni stroj</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>runVirtualMachine</strong>(VirtualMachine virtualMachine) {
        virtualMachine.resume();
    }
&nbsp;
<i>    /**</i>
<i>     * Ukonceni prace beziciho sledovaneho virtualniho stroje.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>shutdownVirtualMachine</strong>(VirtualMachine virtualMachine) {
        System.out.println("Calling exit");
        virtualMachine.exit(EXIT_VALUE);
    }
&nbsp;
<i>    /**</i>
<i>     * Ukazka pouziti EventRequestManageru.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>acquireAndUseEventRequestManager</strong>(VirtualMachine virtualMachine) {
        EventRequestManager eventRequestManager = virtualMachine.eventRequestManager();
<i>        // tuto udalost potrebujeme zpracovavat pro korektni ukonceni debuggeru</i>
        VMDeathRequest vmDeathRequest = registerVMDeathEvent(eventRequestManager);
        MethodEntryRequest methodEntryRequest = registerMethodEntryRequest(eventRequestManager);
<i>        // klasicka smycka pro zpracovani udalosti</i>
        eventLoop(virtualMachine, vmDeathRequest, methodEntryRequest);
    }
&nbsp;
<i>    /**</i>
<i>     * Registrace udalosti typu VMDeathEvent</i>
<i>     */</i>
    private static VMDeathRequest <strong>registerVMDeathEvent</strong>(EventRequestManager eventRequestManager) {
        VMDeathRequest vmDeathRequest = eventRequestManager.createVMDeathRequest();
<i>        // po registraci udalosti je jeste nutne tento typ udalosti povolit</i>
        vmDeathRequest.enable();
        return vmDeathRequest;
    }
&nbsp;
<i>    /**</i>
<i>     * Registrace udalosti typu MethodEntry</i>
<i>     */</i>
    private static MethodEntryRequest <strong>registerMethodEntryRequest</strong>(EventRequestManager eventRequestManager) {
        MethodEntryRequest methodEntryRequest = eventRequestManager.createMethodEntryRequest();
&nbsp;
<i>        // pridame filtr na jmeno tridy</i>
        methodEntryRequest.addClassFilter("Test5");
&nbsp;
<i>        // po registraci udalosti je jeste nutne tento typ udalosti povolit</i>
        methodEntryRequest.enable();
        return methodEntryRequest;
    }
&nbsp;
<i>    /**</i>
<i>     * Klasicka smycka pro postupne zpracovani udalosti.</i>
<i>     * </i>
<i>     * @param virtualMachine</i>
<i>     *            sledovany virtualni stroj, k nemuz je debugger vzdalene</i>
<i>     *            pripojen</i>
<i>     * @param vmDeathRequest</i>
<i>     *            objekt pro rizeni udalosti typu VMDeathEvent</i>
<i>     * @param methodEntryRequest</i>
<i>     *            objekt pro rizeni udalosti typu MethodEntry</i>
<i>     */</i>
    private static void <strong>eventLoop</strong>(VirtualMachine virtualMachine, VMDeathRequest vmDeathRequest, MethodEntryRequest methodEntryRequest) {
        EventQueue eventQueue = virtualMachine.eventQueue();
&nbsp;
<i>        // precist a zpracovat udalosti</i>
        while (processEvents(eventQueue, vmDeathRequest)) {
<i>            // jojo tady skutecne nic neni :)</i>
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Precteni a zpracovani udalosti</i>
<i>     * </i>
<i>     * @param eventQueue</i>
<i>     *            fronta udalosti</i>
<i>     * @param vmDeathRequest</i>
<i>     *            objekt pro rizeni udalosti typu VMDeathEvent</i>
<i>     * </i>
<i>     * @return true pokud se ma pokracovat ve zpracovavani udalosti false pokud</i>
<i>     *         se ma sledovana VM ukoncit</i>
<i>     */</i>
    private static boolean <strong>processEvents</strong>(EventQueue eventQueue, VMDeathRequest vmDeathRequest) {
        EventSet eventSet;
        try {
<i>            // precist udalosti z fronty</i>
            eventSet = eventQueue.remove();
            int events = eventSet.size();
            System.out.println("Got " + events + " request" + (events &gt; 1 ? "s:" : ":"));
&nbsp;
<i>            // projit vsemi udalostmi</i>
            for (Event event : eventSet) {
                if (event instanceof VMStartEvent) {
                    System.out.println("    VMStartEvent");
                }
                else if (event instanceof VMDeathEvent) {
                    System.out.println("    VMDeathEvent");
<i>                    // zakazat dalsi generovani udalosti</i>
<i>                    // (u VMDeathEvent je ve skutecnosti vzdy posledni udalost poslana) </i>
                    vmDeathRequest.disable();
<i>                    // posleze se zavola shutdownVirtualMachine()</i>
                    return false;
                }
                else if (event instanceof MethodEntryEvent) {
                    printMethodEntryInfo((MethodEntryEvent)event);
                }
                else {
                    System.out.println("    other event");
                }
            }
<i>            // znovu postit vsechna vlakna</i>
            eventSet.resume();
        }
        catch (InterruptedException e) {
            e.printStackTrace();
        }
        return true;
    }
&nbsp;
<i>    /**</i>
<i>     * Zavolano pri vyskytu udalosti typu MethodEntry</i>
<i>     * </i>
<i>     * @param event</i>
<i>     *            udalost typu MethodEntry</i>
<i>     */</i>
    private static void <strong>printMethodEntryInfo</strong>(MethodEntryEvent event) {
        Method method = event.method();
        Location location = event.location();
&nbsp;
<i>        // ziskat vsechny informace o pozici v pozastavenem vlaknu</i>
        String className = getClassName(location);
        String methodName = getMethodName(location);
        String sourceName = getSourceName(location);
        String lineNumber = getLineNumber(location);
&nbsp;
<i>        // typ navratove hodnoty reprezentovany jako retezec</i>
        String type = method.returnTypeName();
<i>        // priznaky pristupovych prav</i>
        String accessibilityStr = getAccessibility(method);
        String staticStr = method.isStatic() ? "static " : "";
        String finalStr = method.isFinal() ? "final " : "";
        String nativeStr = method.isNative() ? "native " : "";
        String synchronizedStr = method.isSynchronized() ? "synchronized " : "";
&nbsp;
<i>        // nyni mame vsechny informace, lze je tedy vypsat</i>
        System.out.format("    entry into method: %s%s%s%s%s%s %s.%s",
                accessibilityStr, staticStr, finalStr,
                nativeStr, synchronizedStr, type,
                className, methodName);
        printMethodArguments(method);
<i>        // po vypisu argumentu se jeste vypise jmeno zdrojoveho</i>
<i>        // souboru a cislo radku</i>
        System.out.format("   (%s:%s)\n", sourceName, lineNumber);
    }
&nbsp;
<i>    /**</i>
<i>     * Jmeno tridy, jejiz metoda byla zavolana.</i>
<i>     */</i>
    private static String <strong>getClassName</strong>(Location location) {
        return location.method().declaringType().name();
    }
&nbsp;
<i>    /**</i>
<i>     * Jmeno volane metody.</i>
<i>     */</i>
    private static String <strong>getMethodName</strong>(Location location) {
        return location.method().name();
    }
&nbsp;
<i>    /**</i>
<i>     * Ziskani informaci o jmene zdrojoveho souboru pro danou lokaci.</i>
<i>     */</i>
    private static String <strong>getSourceName</strong>(Location location) {
        try {
            return location.sourceName();
        }
        catch (AbsentInformationException e) {
            return "unknown";
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Prevod cisla radku na retezec, pokud je to mozne.</i>
<i>     */</i>
    private static String <strong>getLineNumber</strong>(Location location) {
        int lineNumber = location.lineNumber();
<i>        // u nativnich metod nelze zjistit cisla radku</i>
        return lineNumber &gt;= 0 ? "" + lineNumber : "&lt;native method&gt;";
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis argumentu metody.</i>
<i>     *</i>
<i>     * @param method metoda ve sledovanem virtualnim stroji</i>
<i>     */</i>
    private static void <strong>printMethodArguments</strong>(Method method) {
        System.out.print("(");
        boolean first = true;
&nbsp;
        try {
<i>            // idealni je zjistit jmena i typy argumentu</i>
<i>            // pokud je to samozrejme mozne</i>
            List&lt;LocalVariable&gt; arguments = method.arguments();
<i>            // vypsat typy a jmena vsech argumentu metody</i>
            for (LocalVariable argument : arguments) {
                if (first) {
                    first = false;
                }
                else {
                    System.out.print(", ");
                }
                System.out.print(argument.typeName() + " " + argument.name());
            }
        }
        catch (AbsentInformationException e) {
<i>            // pokud jmena argumentu nelze zjistit,</i>
<i>            // alespon typy jsou vzdy k dispozici</i>
            List&lt;String&gt; arguments = method.argumentTypeNames();
<i>            // vypsat typy vsech argumentu metody</i>
            for (String argument : arguments) {
                if (first) {
                    first = false;
                }
                else {
                    System.out.print(", ");
                }
                System.out.print(argument);
            }
        }
        System.out.print(");");
    }
&nbsp;
<i>    /**</i>
<i>     * Pristupova prava k atributu ci k metode (my zde tuto metodu</i>
<i>     * vyuzijeme pouze pro ziskani pristupovych prav k volanym metodam)</i>
<i>     */</i>
    private static String <strong>getAccessibility</strong>(Accessible methodOrField) {
        if (methodOrField.isPublic()) {
            return "public ";
        }
        if (methodOrField.isProtected()) {
            return "protected ";
        }
        if (methodOrField.isPrivate()) {
            return "private ";
        }
        return "";
    }
&nbsp;
}
</pre>

<p>Po spu¹tìní tohoto demonstraèního debuggeru získáme podrobnou informaci o
v¹ech volaných metodách tøídy <strong>Test5</strong> (tato tøída musela být
pøelo¾ena s&nbsp;volbou -g):</p>

<pre>
Connecting to virtual machine
Connected
Got 1 request:
    VMStartEvent
Got 1 request:
    entry into method: public static void Test5.main(java.lang.String[] args);   (Test5.java:23)
Got 1 request:
    entry into method: public void Test5.&lt;init&gt;();   (Test5.java:1)
Got 1 request:
    entry into method: public void Test5.run(int value, char znak);   (Test5.java:4)
Got 1 request:
    entry into method: public void Test5.foo(float value);   (Test5.java:10)
Got 1 request:
    entry into method: public void Test5.bar(float value, float[] array, java.lang.String message);   (Test5.java:15)
Got 1 request:
    entry into method: public void Test5.baz();   (Test5.java:19)
Got 2 requests:
    VMDeathEvent
Calling exit
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Zdrojový kód testovací tøídy <strong>Test5</strong></h2>

<pre>
public class <strong>Test5</strong> {
&nbsp;
    public void <strong>run</strong>(int value, char znak) {
        int int_value = 10;
        Object object_value = null;
        foo(1.0f/value);
    }
&nbsp;
    public void <strong>foo</strong>(float value) {
        Object object_value = this;
        bar(value, new float[] {value, value}, "Hello world!");
    }
&nbsp;
    public void <strong>bar</strong>(float value, float[] array, String message) {
        baz();
    }
&nbsp;
    public void <strong>baz</strong>() {
        System.out.println("baz");
    }
&nbsp;
    public static void <strong>main</strong>(String[] args) {
        System.out.println("Press any key");
        try {
            System.in.read();
        }
        catch (java.io.IOException e) {
        }
        new Test5().run(42, 'a');
    }
&nbsp;
}
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Repositáø se zdrojovými kódy v¹ech tøí demonstraèních pøíkladù</h2>

<p>Zdrojové kódy v¹ech tøech demonstraèních pøíkladù popsaných
v&nbsp;pøedchozích kapitolách byly ulo¾eny (podobnì jako tomu bylo i
v&nbsp;pøede¹lých èástech tohoto seriálu) do Mercurial repositáøe dostupného na
adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
Prozatím nejnovìj¹í verze zmínìných zdrojových souborù mù¾ete najít na
adresách:</p>

<table>
<tr><th>#</th><th>Zdrojový soubor/skript</th><th>Umístìní souboru v&nbsp;repositáøi</th></tr>
<tr><td>1</td><td>JDIMethodEntryDetection1.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/8c1c55bcd7d5/jdi/JDIMethodEntryDetection1.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/8c1c55bcd7d5/jdi/JDIMethodEntryDetection1.java</a></td></tr>
<tr><td>2</td><td>JDIMethodEntryDetection2.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/8c1c55bcd7d5/jdi/JDIMethodEntryDetection2.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/8c1c55bcd7d5/jdi/JDIMethodEntryDetection2.java</a></td></tr>
<tr><td>3</td><td>JDIMethodEntryDetection3.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/8c1c55bcd7d5/jdi/JDIMethodEntryDetection3.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/8c1c55bcd7d5/jdi/JDIMethodEntryDetection3.java</a></td></tr>
<tr><td>4</td><td>Test5.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/8c1c55bcd7d5/jdi/Test5.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/8c1c55bcd7d5/jdi/Test5.java</a></td></tr>
</table>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>Class com.sun.jdi.Bootstrap<br />
<a href="http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/package-tree.html">http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/package-tree.html</a>
</li>

<li>Interface com.sun.jdi.VirtualMachine<br />
<a href="http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/VirtualMachine.html">http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/VirtualMachine.html</a>
</li>

<li>Interface com.sun.jdi.Field<br />
<a href="http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/Field.html">http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/Field.html</a>
</li>

<li>Interface com.sun.jdi.ReferenceType<br />
<a href="http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/ReferenceType.html">http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/ReferenceType.html</a>
</li>

<li>Interface com.sun.jdi.TypeComponent<br />
<a href="http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/TypeComponent.html">http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/TypeComponent.html</a>
</li>

<li>Interface com.sun.jdi.Accessible<br />
<a href="http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/Accessible.html">http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/Accessible.html</a>
</li>

<li>Breakpoint (Wikipedia)<br />
<a href="http://cs.wikipedia.org/wiki/Breakpoint">http://cs.wikipedia.org/wiki/Breakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation<br />
<a href="http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html">http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; SetBreakpoint<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#SetBreakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#SetBreakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; ClearBreakpoint<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#ClearBreakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#ClearBreakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; Breakpoint (callback funkce)<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#Breakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#Breakpoint</a>
</li>

<li>The JVM Tool Interface (JVM TI): How VM Agents Work<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html">http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html</a>
</li>

<li>Creating a Debugging and Profiling Agent with JVMTI<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html">http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html</a>
</li>

<li>JVM TI (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/JVM_TI">http://en.wikipedia.org/wiki/JVM_TI</a>
</li>

<li>IBM JVMTI extensions<br />
<a href="http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html">http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

