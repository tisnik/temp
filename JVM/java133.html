<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - pøeklad dal¹ích øídicích struktur do bajtkódù JVM, Lua VM a Python VM</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - pøeklad dal¹ích øídicích struktur do bajtkódù JVM, Lua VM a Python VM</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyku Java i o virtuálním stroji Javy se ji¾ poètvrté budeme zabývat porovnáváním vlastností bajtkódù JVM, Python VM i Lua VM. Uká¾eme si zpùsob pøekladu pøíkazu &bdquo;return&ldquo; a zejména pak pøeklad poèítaných programových smyèek typu &bdquo;for&ldquo; (øekneme si i o historii tohoto klíèového slova).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - pøeklad dal¹ích øídicích struktur do bajtkódù JVM, Lua VM a Python VM</a></p>
<p><a href="#k02">2. Poèítaná programová smyèka <strong>for</strong> &ndash; prapøedek v¹ech strukturovaných programových smyèek</a></p>
<p><a href="#k03">3. Pøíkaz <strong>return</strong> &ndash; ukonèení bìhu funkce/metody s&nbsp;pøedáním návratové hodnoty</a></p>
<p><a href="#k04">4. Ukázky pøekladu pøíkazu <strong>return</strong> do bajtkódu</a></p>
<p><a href="#k05">5. Poèítaná programová smyèka <strong>for</strong></a></p>
<p><a href="#k06">6. Ukázky pøekladu jednoduché poèítané smyèky typu <strong>for</strong> do bajtkódu</a></p>
<p><a href="#k07">7. Slo¾itìj¹í programová smyèka typu <strong>for</strong> &ndash; výpoèet faktoriálu</a></p>
<p><a href="#k08">8. Pøeklad vnoøených poèítaných smyèek typu <strong>for</strong> do bajtkódu</a></p>
<p><a href="#k09">9. Pøíkazy <strong>break</strong> a <strong>continue</strong>, popø.&nbsp;jejich ekvivalenty</a></p>
<p><a href="#k10">10. Pøeklad pøíkazù typu <strong>break</strong> a <strong>continue</strong> do bajtkódu</a></p>
<p><a href="#k11">11. Repositáø se zdrojovými kódy v¹ech dne¹ních demonstraèních pøíkladù</a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - pøeklad dal¹ích øídicích struktur do bajtkódù JVM, Lua VM a Python VM</h2>

<p>V&nbsp;dne¹ní èásti seriálu o programovacím jazyku Java i o virtuálním
stroji Javy si nejprve uká¾eme, jakým zpùsobem se pøekládají pøíkazy
<strong>return</strong> do bajtkódu JVM, Lua VM i Python VM. Posléze se budeme
vìnovat zajímavìj¹ímu tématu &ndash; zpùsobu pøekladu poèítaných programových
smyèek typu <strong>for</strong>, proto¾e tento typ programových smyèek je (ve
své pùvodní variantì) souèástí pomìrnì velkého mno¾ství algoritmù, pøedev¹ím
numerických algoritmù, kde se pracuje s&nbsp;vektory (jednorozmìrnými poli) a
maticemi (dvourozmìrnými poli). Ostatnì právì z&nbsp;tohoto dùvodu se
s&nbsp;tímto typem smyèek mù¾eme setkat u¾ ve tøetí generaci programovacích
jazykù (v&nbsp;èele s&nbsp;<strong>FORTRANem</strong>), kde se dokonce pùvodnì
jednalo o jeden ze dvou zpùsobù tvorby programových smyèek (první zpùsob
vyu¾íval pøíkaz <strong>GOTO</strong> pro provedení skoku).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Poèítaná programová smyèka <strong>for</strong> &ndash; prapøedek v¹ech strukturovaných programových smyèek</h2>

<p>U poèítané programové smyèky <strong>for</strong> se na chvíli zastavme,
proto¾e historie jejího vzniku je velmi zajímavá a sahá vlastnì a¾ do let 1945
a 1946. V&nbsp;této dobì dokonèil slavný konstruktér poèítaèù <i>Konrad
Zuse</i> návrh svého programovacího jazyka nazvaného
<strong>Plankalkül</strong> (slovo &bdquo;plan&ldquo; zde mìlo význam podobný
slovu &bdquo;program&ldquo;, tak¾e napøíklad Zusem navrhované
&bdquo;podplány&ldquo; byly vlastnì
&bdquo;podprogramy/subrutiny/funkce&ldquo;). Pùvodnì sice nebyl tento
programovací jazyk skuteènì implementován (na to si museli nad¹enci poèkat
je¹tì zhruba padesát let), ov¹em <strong>Plankalkül</strong> ovlivnil dal¹ího
evropského prùkopníka IT &ndash; <i>Heinze Rutishausera</i>, který
v&nbsp;padesátých letech minulého století navrhl vy¹¹í programovací jazyk
nazvaný <strong>Superplan</strong>. A právì v&nbsp;tomto dnes ji¾
polozapomenutém programovacím jazyku se poprvé objevilo klíèové slovo
<strong>für</strong> (tedy nìmecká varianta <strong>for</strong>), zatímco
tvùrci <strong>FORTRANu</strong> pou¾ili klíèové slovo <strong>do</strong>,
jen¾ má dnes vìt¹inou ponìkud jiný význam.</p>

<p>Heinz Rutishauser se pozdìji podílel na vzniku návrhu programovacího jazyka
<strong>ALGOL 58</strong>, kde se pro poèítanou programovou smyèku objevilo
(v&nbsp;anglické verzi tohoto jazyka!) klíèové slovo <strong>for</strong>.
<strong>ALGOL 58</strong> sice nebyl pøíli¹ úspì¹ný, ov¹em jeho nástupce
<strong>ALGOL 60</strong> ji¾ ano a právì odtud se slovo <strong>for</strong>
dostalo jak do &bdquo;pascalské vìtve&ldquo; (Pascal, Modula, Lua), tak i do
&bdquo;céèkové vìtve&ldquo; (C, C++, Java, JavaScript...) programovacích
jazykù.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Pøíkaz <strong>return</strong> &ndash; ukonèení bìhu funkce/metody s&nbsp;pøedáním návratové hodnoty</h2>

<p>Nejprve si uká¾eme, jakým zpùsobem se do bajtkódu JVM, Lua VM a Python VM
pøekládá pøíkaz pro návrat z&nbsp;funkce èi metody. Tento pøíkaz se ve v¹ech
tøech jazycích (Java, Lua i Python) zapisuje klíèovým slovem
<strong>return</strong>, co¾ vlastnì není pøíli¹ pøekvapivé, proto¾e toto slovo
se v&nbsp;prakticky stejném významu pou¾ívá v&nbsp;programovacích jazycích ji¾
zhruba po dobu padesáti let. Svùj pùvod má v&nbsp;podobnì pojmenované strojové
instrukci pro návrat ze subrutiny a podobnì se chová i ve vy¹¹ích
programovacích jazycích (zde se v¹ak li¹í návratové typy a nìkteré jazyky mají
sémantiku slo¾itìj¹í kvùli existenci uzávìrù &ndash; <i>closures</i>).
Podívejme se v¹ak na demonstraèní pøíklady, z&nbsp;nich¾ bude patrný i rozdíl
mezi v¹emi tøemi popisovanými jazyky.</p>

<h3>Demonstraèní pøíklad <strong>Test12.java</strong></h3>

<p>V&nbsp;programovacím jazyku Java lze pøíkaz <strong>return</strong> uvést
bez výrazu, ov¹em pouze v&nbsp;pøípadì, ¾e se jedná o metodu typu
<strong>void</strong>, tj.&nbsp;metodu bez návratové hodnoty. V&nbsp;opaèném
pøípadì se musí za klíèové slovo <strong>return</strong> zapsat výraz
odpovídající návratovému typu metody &ndash; co¾ mù¾e být jeden
z&nbsp;primitivních datových typù (boolean, char, byte, short, int, long,
float, double) èi referenèní datový typ, tj.&nbsp;objekt:</p>

<pre>
<i>/**</i>
<i> * Ukazka zpusobu predavani navratovych hodnot</i>
<i> * ze statickych metod.</i>
<i> */</i>
public class <strong>Test12</strong> {
&nbsp;
    <i>/**</i>
    <i> * Navratova hodnota typu void.</i>
    <i> */</i>
    static void <strong>returnVoid</strong>() {
        <strong>return</strong>;
    }
&nbsp;
    <i>/**</i>
    <i> * Navratova hodnota typu boolean.</i>
    <i> */</i>
    static boolean <strong>returnBooleanTrue</strong>() {
        <strong>return</strong> <strong>true</strong>;
    }
&nbsp;
    <i>/**</i>
    <i> * Navratova hodnota typu boolean.</i>
    <i> */</i>
    static boolean <strong>returnBooleanFalse</strong>() {
        <strong>return</strong> <strong>false</strong>;
    }
&nbsp;
    <i>/**</i>
    <i> * Navratova hodnota typu byte.</i>
    <i> */</i>
    static byte <strong>returnByte</strong>() {
        <strong>return</strong> -1;
    }
&nbsp;
    <i>/**</i>
    <i> * Navratova hodnota typu char.</i>
    <i> */</i>
    static char <strong>returnChar</strong>() {
        <strong>return</strong> 'a';
    }
&nbsp;
    <i>/**</i>
    <i> * Navratova hodnota typu short.</i>
    <i> */</i>
    static short <strong>returnShort</strong>() {
        <strong>return</strong> 0;
    }
&nbsp;
    <i>/**</i>
    <i> * Navratova hodnota typu int.</i>
    <i> */</i>
    static int <strong>returnInt</strong>() {
        <strong>return</strong> 1;
    }
&nbsp;
    <i>/**</i>
    <i> * Navratova hodnota typu long.</i>
    <i> */</i>
    static long <strong>returnLong</strong>() {
        <strong>return</strong> 2L;
    }
&nbsp;
    <i>/**</i>
    <i> * Navratova hodnota typu float.</i>
    <i> */</i>
    static float <strong>returnFloat</strong>() {
        <strong>return</strong> 3.0f;
    }
&nbsp;
    <i>/**</i>
    <i> * Navratova hodnota typu double.</i>
    <i> */</i>
    static double <strong>returnDouble</strong>() {
        <strong>return</strong> 4.0;
    }
&nbsp;
    <i>/**</i>
    <i> * Navratova hodnota typu reference.</i>
    <i> */</i>
    static Object <strong>returnReference</strong>() {
        <strong>return</strong> <strong>null</strong>;
    }
&nbsp;
    <i>/**</i>
    <i> * Vse je nutne otestovat.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        returnVoid();
        System.out.println(returnBooleanTrue());
        System.out.println(returnBooleanFalse());
        System.out.println(returnByte());
        System.out.println(returnChar());
        System.out.println(returnShort());
        System.out.println(returnInt());
        System.out.println(returnLong());
        System.out.println(returnFloat());
        System.out.println(returnDouble());
        System.out.println(returnReference());
    }
}
</pre>

<h3>Demonstraèní pøíklad <strong>Test12.lua</strong></h3>

<p>U programovacího jazyka <strong>Lua</strong> se díky dynamickému typování
nemusí uvádìt návratové typy funkcí, tak¾e je pou¾ití pøíkazu
<strong>return</strong> v&nbsp;tomto pøípadì ponìkud volnìj¹í, ne¾ tomu bylo
v&nbsp;Javì. Pøíkaz lze uvést bez výrazu, s&nbsp;jedním výrazem èi dokonce
s&nbsp;nìkolika výrazy. Výrazy mohou být jakéhokoli podporovaného typu,
tj.&nbsp;<strong>nil</strong> (datový typ a souèasnì i jeho jediná povolená
hodnota), pravdivostní typ, èíslo (celé i reálné), øetìzec, tabulka (i
asociativní pole) a posledním zajímavým typem je funkce:</p>

<pre>
<i>--</i>
<i>-- Ukazka zpusobu predavani navratovych hodnot</i>
<i>-- z funkci</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Funkce bez navratove hodnoty</i>
<i>--</i>
function <strong>returnVoid</strong>()
    return
end
&nbsp;
<i>--</i>
<i>-- Funkce vracejici nil</i>
<i>--</i>
function <strong>returnNil</strong>()
    return <strong>nil</strong>
end
&nbsp;
<i>--</i>
<i>-- Navratova hodnota typu Boolean.</i>
<i>--</i>
function <strong>returnBooleanTrue</strong>()
    return <strong>true</strong>
end
&nbsp;
<i>--</i>
<i>-- Navratova hodnota typu Boolean.</i>
<i>--</i>
function <strong>returnBooleanFalse</strong>()
    return <strong>false</strong>
end
&nbsp;
<i>--</i>
<i>-- Navratova hodnota Number.</i>
<i>--</i>
function <strong>returnNumber1</strong>()
    return 42
end
&nbsp;
<i>--</i>
<i>-- Navratova hodnota Number.</i>
<i>--</i>
function <strong>returnNumber2</strong>()
    return 42.0
end
&nbsp;
<i>--</i>
<i>-- Navratova hodnota typu String.</i>
<i>--</i>
function <strong>returnString</strong>()
    return "Hello"
end
&nbsp;
<i>--</i>
<i>-- Navratova hodnota typu table.</i>
<i>--</i>
function <strong>returnTable</strong>()
    return {1,2,3}
end
&nbsp;
<i>--</i>
<i>-- Navratova hodnota typu function.</i>
<i>--</i>
function <strong>returnFunction</strong>()
    return function() print("Hello world!") end
end
&nbsp;
<i>--</i>
<i>-- Vse je nutne otestovat.</i>
<i>--</i>
function <strong>main</strong>()
    print(returnVoid())
    print(returnNil())
    print(returnBooleanTrue())
    print(returnBooleanFalse())
    print(returnNumber1())
    print(returnNumber2())
    print(returnString())
    print(returnTable())
    print(returnFunction())
end
&nbsp;
main()
</pre>

<h3>Demonstraèní pøíklad <strong>Test12.py</strong></h3>

<p>Pro programovací jazyk Python platí podobná pravidla pro pou¾ití pøíkazu
<strong>return</strong>, jako tomu bylo v&nbsp;Lue. Zajímavé je, ¾e lze vracet
i strukturované datové typy seznam èi n-tice a dokonce i lambda funkce (co¾ na
druhou stranu není tak pøekvapivé, ov¹em v&nbsp;Javì jsme si museli na podobnou
sémantiku poèkat témìø dvacet let :-):</p>

<pre>
<i>--</i>
<i>-- Ukazka zpusobu predavani navratovych hodnot</i>
<i>-- z funkci</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Funkce bez navratove hodnoty</i>
<i>--</i>
def <strong>returnVoid</strong>():
    return
&nbsp;
<i>--</i>
<i>-- Funkce vracejici None</i>
<i>--</i>
def <strong>returnNone</strong>():
    return None
&nbsp;
<i>--</i>
<i>-- Navratova hodnota typu Boolean.</i>
<i>--</i>
def <strong>returnBooleanTrue</strong>():
    return True
&nbsp;
<i>--</i>
<i>-- Navratova hodnota typu Boolean.</i>
<i>--</i>
def <strong>returnBooleanFalse</strong>():
    return False
&nbsp;
<i>--</i>
<i>-- Navratova hodnota Number.</i>
<i>--</i>
def <strong>returnNumber1</strong>():
    return 42
&nbsp;
<i>--</i>
<i>-- Navratova hodnota Number.</i>
<i>--</i>
def <strong>returnNumber2</strong>():
    return 42.0
&nbsp;
<i>--</i>
<i>-- Navratova hodnota typu String.</i>
<i>--</i>
def <strong>returnString</strong>():
    return "Hello"
&nbsp;
<i>--</i>
<i>-- Navratova hodnota typu tuple.</i>
<i>--</i>
def <strong>returnTuple</strong>():
    return (1,2,3)
&nbsp;
<i>--</i>
<i>-- Navratova hodnota typu lambda (anonymni funkce).</i>
<i>--</i>
def <strong>returnLambda</strong>():
    return lambda arg1, arg2: arg1 + arg2
&nbsp;
<i>--</i>
<i>-- Vse je nutne otestovat.</i>
<i>--</i>
def <strong>main</strong>():
    print(returnVoid())
    print(returnNone())
    print(returnBooleanTrue())
    print(returnBooleanFalse())
    print(returnNumber1())
    print(returnNumber2())
    print(returnString())
    print(returnTuple())
    print(returnLambda())
&nbsp;
<i>--</i>
<i>-- Vypsani bajkkodu testovane funkce</i>
<i>--</i>
def <strong>disassemble</strong>():
    from dis import dis
&nbsp;
    print("\nreturnVoid:")
    dis(returnVoid)
&nbsp;
    print("\nreturnNone:")
    dis(returnNone)
&nbsp;
    print("\nreturnBooleanTrue:")
    dis(returnBooleanTrue)
&nbsp;
    print("\nreturnBooleanFalse:")
    dis(returnBooleanFalse)
&nbsp;
    print("\nreturnNumber1:")
    dis(returnNumber1)
&nbsp;
    print("\nreturnNumber2:")
    dis(returnNumber2)
&nbsp;
    print("\nreturnString:")
    dis(returnString)
&nbsp;
    print("\nreturnTuple:")
    dis(returnTuple)
&nbsp;
    print("\nreturnLambda:")
    dis(returnLambda)
&nbsp;
main()
&nbsp;
disassemble()
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Ukázky pøekladu pøíkazu <strong>return</strong> do bajtkódu</h2>

<p>V&nbsp;této kapitole budou ukázány okomentované bajtkódy získané pøekladem
demonstraèních pøíkladù <strong>Test12.java</strong>,
<strong>Test12.lua</strong> i <strong>Test12.py</strong>.</p>

<h3>Bajtkód demonstraèního pøíkladu <strong>Test12.java</strong></h3>

<p>V&nbsp;bajtkódu JVM existuje nìkolik instrukcí pro ukonèení metody
s&nbsp;pøípadným pøedáním návratové hodnoty volající metodì (<i>caller</i>). Po
provedení tìchto instrukcí dojde ke zru¹ení celého zásobníkového rámce metody,
z&nbsp;ní¾ se vyskakuje, a øízení se pøedá volající metodì. Pøipomeòme si, ¾e
volající metoda si mù¾e návratovou hodnotu vyzvednout z&nbsp;vrcholu
<strong>svého</strong> zásobníku operandù. Pou¾ití dále vypsaných instrukcí
typu <strong>*return</strong> je jedinou mo¾ností, jak mù¾e volaná metoda
modifikovat obsah zásobníku operandù metody volající &ndash; v&nbsp;ostatních
pøípadech jsou toti¾ zásobníky operandù (i datová oblast) obou metod od sebe
izolovány, co¾ pøispívá jak k&nbsp;vìt¹í bezpeènosti, tak i k&nbsp;oddìlení
jednotlivých èástí kódu. To samozøejmì zjednodu¹uje práci just-in-time
pøekladaèe pøi provádìní optimalizací. Ukonèení metody s&nbsp;ulo¾ením
návratové hodnoty zabezpeèuje ¹estice instrukcí <strong>*return</strong>, která
je vypsaná v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Datový typ na TOS</th><th>Operace</th></tr>
<tr><td>1</td><td>ireturn</td><td>0xAC</td><td>int</td><td>získání návratové hodnoty typu int z&nbsp;TOS zásobníku operandù + návrat z&nbsp;metody</td></tr>
<tr><td>2</td><td>lreturn</td><td>0xAD</td><td>long</td><td>získání návratové hodnoty typu long z&nbsp;TOS zásobníku operandù + návrat z&nbsp;metody</td></tr>
<tr><td>3</td><td>freturn</td><td>0xAE</td><td>float</td><td>získání návratové hodnoty typu float z&nbsp;TOS zásobníku operandù + návrat z&nbsp;metody</td></tr>
<tr><td>4</td><td>dreturn</td><td>0xAF</td><td>double</td><td>získání návratové hodnoty typu double z&nbsp;TOS zásobníku operandù + návrat z&nbsp;metody</td></tr>
<tr><td>5</td><td>areturn</td><td>0xB0</td><td>reference</td><td>získání návratové hodnoty typu reference na objekt z&nbsp;TOS zásobníku operandù + návrat z&nbsp;metody</td></tr>
<tr><td>6</td><td>return</td><td>0xB1</td><td>&times;</td><td>pouze návrat z&nbsp;metody, ¾ádná hodnota se nevrací</td></tr>
</table>

<p>Zajímavé je &bdquo;pøetí¾ení&ldquo; instrukce <strong>ireturn</strong> i pro
datové typy boolean, char, byte a short, co¾ je ostatnì patrné i
z&nbsp;následujícího kódu:</p>

<pre>
Compiled from "Test12.java"
public class <strong>Test12</strong> extends java.lang.Object{
&nbsp;
static void <strong>returnVoid</strong>();
  Code:
   0:   return        <i>// instrukce pro návrat z metody bez vrácení hodnoty</i>
&nbsp;
static boolean <strong>returnBooleanTrue</strong>();
  Code:
   0:   iconst_1      <i>// ulo¾ení konstanty 1 (int) na zásobník operandù</i>
   1:   ireturn       <i>// instrukce pro návrat z metody s vrácením hodnoty typu int z vrcholu zásobníku</i>
&nbsp;
static boolean <strong>returnBooleanFalse</strong>();
  Code:
   0:   iconst_0      <i>// ulo¾ení konstanty 0 (int) na zásobník operandù</i>
   1:   ireturn       <i>// instrukce pro návrat z metody s vrácením hodnoty typu int z vrcholu zásobníku</i>
&nbsp;
static byte <strong>returnByte</strong>();
  Code:
   0:   iconst_m1     <i>// ulo¾ení konstanty -1 (int) na zásobník operandù</i>
   1:   ireturn       <i>// instrukce pro návrat z metody s vrácením hodnoty typu int z vrcholu zásobníku</i>
&nbsp;
static char <strong>returnChar</strong>();
  Code:
   0:   bipush  97    <i>// ulo¾ení konstanty 97 (int) na zásobník operandù</i>
   2:   ireturn       <i>// instrukce pro návrat z metody s vrácením hodnoty typu int z vrcholu zásobníku</i>
&nbsp;
static short <strong>returnShort</strong>();
  Code:
   0:   iconst_0      <i>// ulo¾ení konstanty 0 (int) na zásobník operandù</i>
   1:   ireturn       <i>// instrukce pro návrat z metody s vrácením hodnoty typu int z vrcholu zásobníku</i>
&nbsp;
static int <strong>returnInt</strong>();
  Code:
   0:   iconst_1      <i>// ulo¾ení konstanty 1 (int) na zásobník operandù</i>
   1:   ireturn       <i>// instrukce pro návrat z metody s vrácením hodnoty typu int z vrcholu zásobníku</i>
&nbsp;
static long <strong>returnLong</strong>();
  Code:
   0:   ldc2_w  #2;   <i>// konstanta typu long umístìná v constant poolu</i>
   3:   lreturn       <i>// instrukce pro návrat z metody s vrácením hodnoty typu long z vrcholu zásobníku</i>
&nbsp;
static float <strong>returnFloat</strong>();
  Code:
   0:   ldc     #4;   <i>// konstanta typu float umístìná v constant poolu</i>
   2:   freturn       <i>// instrukce pro návrat z metody s vrácením hodnoty typu float z vrcholu zásobníku</i>
&nbsp;
static double <strong>returnDouble</strong>();
  Code:
   0:   ldc2_w  #5;   <i>// konstanta typu double umístìná v constant poolu</i>
   3:   dreturn       <i>// instrukce pro návrat z metody s vrácením hodnoty typu double z vrcholu zásobníku</i>
&nbsp;
static java.lang.Object <strong>returnReference</strong>();
  Code:
   0:   aconst_null   <i>// speciální instrukce pro ulo¾ení "null" na vrchol zásobníku</i>
   1:   areturn       <i>// instrukce pro návrat z metody s vrácením hodnoty typu reference z vrcholu zásobníku</i>
&nbsp;
</pre>

<h3>Bajtkód demonstraèního pøíkladu <strong>Test12.lua</strong></h3>

<p>V&nbsp;bajtkódu programovacího jazyka Lua je situace jednodu¹¹í, nebo» se
zde pro návrat z&nbsp;funkce pou¾ívá jediná instrukce <strong>RETURN</strong>
kompatibilní se v¹emi datovými typy. Nejprve je nutné naèíst hodnotu
pøíslu¹ného typu do registru a posléze zavolat instrukci
<strong>RETURN</strong>, které se pøedá mj.&nbsp;i poèet registrù, jejich¾
hodnota se má pøedat volající funkci:</p>

<pre>
function &lt;<strong>Test12.lua:11,13</strong>&gt; (2 instructions at 0x9e8fc88)
0 params, 2 slots, 0 upvalues, 0 locals, 0 constants, 0 functions
        1       [12]    RETURN          0 1   <i>// explicitní vrácení "nièeho" :-)</i>
        2       [13]    RETURN          0 1   <i>// vkládáno automaticky</i>
&nbsp;
function &lt;<strong>Test12.lua:18,20</strong>&gt; (3 instructions at 0x9e8fe38)
0 params, 2 slots, 0 upvalues, 0 locals, 0 constants, 0 functions
        1       [19]    LOADNIL         0 0   <i>// pro hodnotu nil existuje specializovaná instrukce</i>
        2       [19]    RETURN          0 2
        3       [20]    RETURN          0 1   <i>// vkládáno automaticky</i>
&nbsp;
function &lt;<strong>Test12.lua:25,27</strong>&gt; (3 instructions at 0x9e8ff68)
0 params, 2 slots, 0 upvalues, 0 locals, 0 constants, 0 functions
        1       [26]    LOADBOOL        0 1 0 <i>// hodnota false</i>
        2       [26]    RETURN          0 2
        3       [27]    RETURN          0 1   <i>// vkládáno automaticky</i>
&nbsp;
function &lt;<strong>Test12.lua:32,34</strong>&gt; (3 instructions at 0x9e8fde0)
0 params, 2 slots, 0 upvalues, 0 locals, 0 constants, 0 functions
        1       [33]    LOADBOOL        0 0 0 <i>// hodnota true</i>
        2       [33]    RETURN          0 2
        3       [34]    RETURN          0 1   <i>// vkládáno automaticky</i>
&nbsp;
function &lt;<strong>Test12.lua:39,41</strong>&gt; (3 instructions at 0x9e90280)
0 params, 2 slots, 0 upvalues, 0 locals, 1 constant, 0 functions
        1       [40]    LOADK           0 -1  <i>// èíselná konstanta 42</i>
        2       [40]    RETURN          0 2
        3       [41]    RETURN          0 1   <i>// vkládáno automaticky</i>
&nbsp;
function &lt;<strong>Test12.lua:46,48</strong>&gt; (3 instructions at 0x9e90428)
0 params, 2 slots, 0 upvalues, 0 locals, 1 constant, 0 functions
        1       [47]    LOADK           0 -1  <i>// èíselná konstanta 42</i>
        2       [47]    RETURN          0 2
        3       [48]    RETURN          0 1   <i>// vkládáno automaticky</i>
&nbsp;
function &lt;<strong>Test12.lua:53,55</strong>&gt; (3 instructions at 0x9e90480)
0 params, 2 slots, 0 upvalues, 0 locals, 1 constant, 0 functions
        1       [54]    LOADK           0 -1  <i>// øetìzcová konstanta</i>
        2       [54]    RETURN          0 2
        3       [55]    RETURN          0 1   <i>// vkládáno automaticky</i>
&nbsp;
function &lt;<strong>Test12.lua:60,62</strong>&gt; (7 instructions at 0x9e90000)
0 params, 4 slots, 0 upvalues, 0 locals, 3 constants, 0 functions
        1       [61]    NEWTABLE        0 3 0 <i>// konstruktor tabulky</i>
        2       [61]    LOADK           1 -1    ; 1
        3       [61]    LOADK           2 -2    ; 2
        4       [61]    LOADK           3 -3    ; 3
        5       [61]    SETLIST         0 3 1 <i>// pøidání prvkù do tabulky</i>
        6       [61]    RETURN          0 2   <i>// vrácení tabulky</i>
        7       [62]    RETURN          0 1   <i>// vkládáno automaticky</i>
&nbsp;
function &lt;<strong>Test12.lua:67,69</strong>&gt; (3 instructions at 0x9e906e8)
0 params, 2 slots, 1 upvalue, 0 locals, 0 constants, 1 function
        1       [68]    CLOSURE         0 0   <i>// vrácení uzávìru</i>
        2       [68]    RETURN          0 2
        3       [69]    RETURN          0 1   <i>// vkládáno automaticky</i>
&nbsp;
function &lt;<strong>Test12.lua:68,68</strong>&gt; (4 instructions at 0x9e90740)
0 params, 2 slots, 1 upvalue, 0 locals, 2 constants, 0 functions
        1       [68]    GETTABUP        0 0 -1 <i>// tìlo uzávìru</i>
        2       [68]    LOADK           1 -2    ; "Hello world!"
        3       [68]    CALL            0 2 1
        4       [68]    RETURN          0      <i>// vkládáno automaticky</i>
</pre>

<h3>Bajtkód demonstraèního pøíkladu <strong>Test12.py</strong></h3>

<p>Bajtkód Python VM takté¾ pou¾ívá univerzální instrukci
<strong>RETURN_VALUE</strong>, nezávisle na datovém typu vrácené hodnoty:</p>

<pre>
<strong>returnVoid</strong>:
 12           0 LOAD_CONST               0 (None)
              3 RETURN_VALUE
&nbsp;
<strong>returnNone</strong>:
 18           0 LOAD_CONST               0 (None)
              3 RETURN_VALUE
&nbsp;
<strong>returnBooleanTrue</strong>:
 24           0 LOAD_GLOBAL              0 (True)
              3 RETURN_VALUE
&nbsp;
<strong>returnBooleanFalse</strong>:
 30           0 LOAD_GLOBAL              0 (False)
              3 RETURN_VALUE
&nbsp;
<strong>returnNumber1</strong>:
 36           0 LOAD_CONST               1 (42)
              3 RETURN_VALUE
&nbsp;
<strong>returnNumber2</strong>:
 42           0 LOAD_CONST               1 (42.0)
              3 RETURN_VALUE
&nbsp;
<strong>returnString</strong>:
 48           0 LOAD_CONST               1 ('Hello')
              3 RETURN_VALUE
&nbsp;
<strong>returnTuple</strong>:
 54           0 LOAD_CONST               4 ((1, 2, 3)) <i>// n-tice reprezentovaná konstantou</i>
              3 RETURN_VALUE
&nbsp;
<strong>returnLambda</strong>:
 60           0 LOAD_CONST               1 (code object lambda at 0xb773f968, file "Test12.py", line 60)
              3 MAKE_FUNCTION            0 <i>// z kodu se vytvorila skutecna funkce</i>
              6 RETURN_VALUE
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Poèítaná programová smyèka <strong>for</strong></h2>

<p>Nyní se budeme zabývat zpùsobem pøekladu poèítané programové smyèky typu
<strong>for</strong> o její¾ historii vzniku jsme se zmínili <a href="#k02">ve
druhé kapitole</a>. Rozdíly mezi jednotlivými programovacími jazyky budou
napsány v&nbsp;navazujících podkapitolách:</p>

<h3>Demonstraèní pøíklad <strong>Test13.java</strong></h3>

<p>V&nbsp;programovacím jazyku Java je poèítaná smyèka <strong>for</strong>
realizována zpùsobem pøevzatým z&nbsp;programovacího jazyka C, tj.&nbsp;lze
zadat jak inicializaèní výraz (výrazy), tak i podmínku ukonèení smyèky a
iteraèní pøíkaz:</p>

<pre>
<i>/**</i>
<i> * Jednoducha pocitana smycka typu for.</i>
<i> */</i>
public class <strong>Test13</strong> {
&nbsp;
    <i>/**</i>
    <i> * Metoda s jednoduchou pocitanou smyckou typu for.</i>
    <i> */</i>
    static int <strong>testForLoop</strong>() {
        int result = 0;
        <strong>for</strong> (int i = 0; i &lt;= 10; i++) {
            result++;
        }
        <strong>return</strong> result;
    }
&nbsp;
    <i>/**</i>
    <i> * Vse je nutne otestovat.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        System.out.println(testForLoop());
    }
}
</pre>

<h3>Demonstraèní pøíklad <strong>Test13.lua</strong></h3>

<p>Programovací jazyk Lua se v&nbsp;pøípadì poèítané smyèky nechal inspirovat
takovými jazyky, jako je Algol, Pascal, Modula èi BASIC. Zadává se poèáteèní a
koncová hodnota poèitadla, nepovinnì i pøírùstek (který mù¾e být záporný,
výchozí hodnota je samozøejmì 1):</p>

<pre>
<i>--</i>
<i>-- Jednoducha pocitana smycka typu "for".</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Funkce s jednoduchou pocitanou smyckou typu for.</i>
<i>--</i>
function <strong>testForLoop</strong>()
    local result = 0
    <strong>for</strong> i = 0, 10 <strong>do</strong>
        result = result + 1
    <strong>end</strong>
    return result;
end
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Vse je nutne otestovat.</i>
<i>--</i>
function <strong>main</strong>()
    print(testForLoop())
end
&nbsp;
main()
</pre>

<h3>Demonstraèní pøíklad <strong>Test13.py</strong></h3>

<p>Programovací jazyk Python sice poèítanou smyèku <strong>for</strong> pøímo
nepodporuje, ale ve skuteènosti to ani není zapotøebí, nebo» ji lze nahradit
smyèkou typu <strong>for-each</strong>, které se pøedá nìjaký objekt typu
sekvence, typicky vytvoøený pøes <strong>xrange()</strong> (v&nbsp;Pythonu 3
pak range):</p>

<pre>
<i>--</i>
<i>-- Jednoducha pocitana smycka typu for.</i>
<i>--</i>
&nbsp;
<i>--</i>
<i>-- Funkce s jednoduchou pocitanou smyckou typu for.</i>
<i>--</i>
def <strong>testForLoop</strong>():
    result = 0;
    <strong>for</strong> i in xrange(0,11):
        result = result + 1
    return result
&nbsp;
<i>--</i>
<i>-- Vse je nutne otestovat.</i>
<i>--</i>
def <strong>main</strong>():
    print(testForLoop())
&nbsp;
<i>--</i>
<i>-- Vypsani bajkkodu testovane funkce</i>
<i>--</i>
def <strong>disassemble</strong>():
    from dis import dis
&nbsp;
    print("\ntestForLoop:")
    dis(testForLoop)
&nbsp;
main()
&nbsp;
disassemble()
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Ukázky pøekladu jednoduché poèítané smyèky typu <strong>for</strong> do bajtkódu</h2>

<p>Nyní se podívejme na to, jakým zpùsobem se jednotlivé implementace poèítané
smyèky typu <strong>for</strong> pøelo¾ily do bajtkódu.</p>

<h3>Bajtkód demonstraèního pøíkladu <strong>Test13.java</strong></h3>

<p>U JVM je pøeklad proveden zpùsobem, s&nbsp;ním¾ jsme se ji¾ setkali minule
pøi popisu smyèek typu <strong>while</strong>, tj.&nbsp;s&nbsp;vyu¾itím
nízkoúrovòových podmínìných i nepodmínìných skokù:</p>

<pre>
Compiled from "Test13.java"
public class <strong>Test13</strong> extends java.lang.Object{
&nbsp;
static int <strong>testForLoop</strong>();
  Code:
   0:   iconst_0               <i>// poèáteèní hodnota promìnné result</i>
   1:   istore_0
   2:   iconst_0               <i>// poèáteèní hodnota poèitadla</i>
   3:   istore_1
   4:   iload_1                <i>// zaèátek smyèky</i>
   5:   bipush  10             <i>// hodnota horní meze</i>
   7:   if_icmpgt       19     <i>// pøi pøekroèení horní meze skok ZA konec smyèky</i>
   10:  iinc    0, 1           <i>// zvý¹it hodnotu promìnné result</i>
   13:  iinc    1, 1           <i>// zvý¹it hodnotu poèitadla</i>
   16:  goto    4              <i>// nepodmínìný skok na zaèátek smyèky</i>
   19:  iload_0
   20:  ireturn                <i>// vrátit hodnotu promìnné result</i>
</pre>

<h3>Bajtkód demonstraèního pøíkladu <strong>Test13.lua</strong></h3>

<p>Pravdìpodobnì nejzajímavìj¹í je bajtkód Lua VM, v&nbsp;nìm¾ jsou pou¾ity dvì
specializované instrukce nazvané <strong>FORPREP</strong> a
<strong>FORLOOP</strong>. První z&nbsp;tìchto instrukcí nejprve sní¾í hodnotu
poèitadla o krok, tak¾e se napøíklad namísto poèáteèní hodnoty 0 bude
v&nbsp;poèitadle nacházet hodnota -1. Souèasnì se po provedení této instrukce
pøesune øízení na instrukci <strong>FORLOOP</strong> (to není ¾ádná magie,
proto¾e relativní adresa skoku je souèástí instrukèního slova
<strong>FORPREP</strong>). Celá smyèka je pak realizována instrukcí
<strong>FORLOOP</strong>, která zvý¹í hodnotu poèitadla o krok, provede
porovnání aktuální hodnoty poèitadla s&nbsp;horní mezí a popø.&nbsp;provede
skok na zaèátek smyèky, tedy za instrukci nacházející se tìsnì za
<strong>FORPREP</strong>. Výsledkem je velmi elegantní bajtkód:</p>

<pre>
function &lt;<strong>Test13.lua:10,16</strong>&gt; (9 instructions at 0x9f49c88)
0 params, 5 slots, 0 upvalues, 5 locals, 3 constants, 0 functions
        1       [11]    LOADK           0 -1    ; 0    <i>// poèáteèní hodnota promìnné result</i>
        2       [12]    LOADK           1 -1    ; 0    <i>// poèáteèní hodnota poèitadla</i>
        3       [12]    LOADK           2 -2    ; 10   <i>// hodnota horní meze</i>
        4       [12]    LOADK           3 -3    ; 1    <i>// krok smyèky</i>
        5       [12]    FORPREP         1 1     ; to 7 <i>// pøíprava na smyèku sní¾ení hodnoty poèitadla o krok</i>
                                                       <i>// a skok na iteraèní pøíkaz</i>
        6       [13]    ADD             0 0 -3  ; - 1  <i>// zvý¹it hodnotu promìnné result</i>
        7       [12]    FORLOOP         1 -2    ; to 6 <i>// provedení iterace - zvý¹ení hodnoty poèitadla</i>
                                                       <i>// test a pøípadný skok na instrukci èíslo 6</i>
        8       [15]    RETURN          0 2            <i>// vrátit hodnotu promìnné result</i>
        9       [16]    RETURN          0 1            <i>// automaticky generovaný návrat z funkce</i>
</pre>

<h3>Bajtkód demonstraèního pøíkladu <strong>Test13.py</strong></h3>

<p>U bajtkódu programovacího jazyka Python jsou takté¾ pou¾ity specializované
instrukce bajtkódu nazvané <strong>GET_ITER</strong> a
<strong>FOR_ITER</strong>. Ty jsou pou¾ity ve v¹ech typech smyèky for-each, zde
konkrétnì pro práci s&nbsp;objektem vytvoøeným funkcí/konstruktorem
<strong>xrange</strong>:</p>

<pre>
<strong>testForLoop</strong>:
  9           0 LOAD_CONST               1 (0)        <i>// poèáteèní hodnota promìnné result</i>
              3 STORE_FAST               0 (result)
&nbsp;
 10           6 SETUP_LOOP              33 (to 42)    <i>// konstrukce programové smyèky</i>
              9 LOAD_GLOBAL              0 (xrange)   <i>// pøíprava na volání xrange()</i>
             12 LOAD_CONST               1 (0)        <i>// dolní mez</i>
             15 LOAD_CONST               2 (11)       <i>// horní mez</i>
             18 CALL_FUNCTION            2            <i>// zavolání xrange()</i>
             21 GET_ITER
             22 FOR_ITER                16 (to 41)    <i>// vlastní smyèka</i>
             25 STORE_FAST               1 (i)
&nbsp;
 11          28 LOAD_FAST                0 (result)   <i>// *</i>
             31 LOAD_CONST               3 (1)        <i>// * result = result + 1</i>
             34 BINARY_ADD                            <i>// *</i>
             35 STORE_FAST               0 (result)   <i>// *</i>
             38 JUMP_ABSOLUTE           22            <i>// dal¹í iterace (skok na zaèátek smyèky)</i>
             41 POP_BLOCK                             <i>// úklid po ukonèení smyèky</i>
&nbsp;
 12          42 LOAD_FAST                0 (result)
             45 RETURN_VALUE                          <i>// vrátit hodnotu promìnné result</i>
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Slo¾itìj¹í programová smyèka typu <strong>for</strong> &ndash; výpoèet faktoriálu</h2>

<p>Poèítaná smyèka <strong>for</strong> pou¾itá v&nbsp;pøedchozích
demonstraèních pøíkladech vlastnì pøedstavovala nejjednodu¹¹í formu této øídicí
struktury. Nyní se podíváme na praktiètìj¹í pøíklad &ndash; výpoèet faktoriálu.
Zde je ji¾ nutné, aby se uvnitø smyèky vyu¾ívala aktuální hodnota
poèitadla.</p>

<h3>Demonstraèní pøíklad <strong>Test14.java</strong></h3>

<p>Implementace výpoètu faktoriálu s&nbsp;vyu¾itím iteraèní smyèky je
v&nbsp;Javì pøímoèará:</p>

<pre>
<i>/**</i>
<i> * Jednoducha pocitana smycka typu "for"</i>
<i> * pouzita pro vypocet faktorialu.</i>
<i> */</i>
public class <strong>Test14</strong> {
&nbsp;
    <i>/**</i>
    <i> * Vypocet faktorialu pocitanou smyckou</i>
    <i> * typu "for".</i>
    <i> */</i>
    static int <strong>factorial</strong>(int n) {
        int result = 1;
        <strong>for</strong> (int i = 2; i &lt;= n; i++) {
            result *= i;
        }
        <strong>return</strong> result;
    }
&nbsp;
    <i>/**</i>
    <i> * Vse je nutne otestovat.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        <strong>for</strong> (int n = 0; n &lt;= 10; n++) {
            System.out.println(n + "\t" + factorial(n));
        }
    }
}
</pre>

<h3>Demonstraèní pøíklad <strong>Test14.lua</strong></h3>

<p>Toté¾ platí i pro programovací jazyk Lua:</p>

<pre>
<i>--</i>
<i>-- Jednoducha pocitana smycka typu "for"</i>
<i>-- pouzita pro vypocet faktorialu.</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Vypocet faktorialu pocitanou smyckou</i>
<i>-- typu "for".</i>
<i>--</i>
function <strong>factorial</strong>(n)
    local result = 1
    <strong>for</strong> i = 2, n <strong>do</strong>
        result = result * i
    <strong>end</strong>
    return result;
end
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Vse je nutne otestovat.</i>
<i>--</i>
function <strong>main</strong>()
    for n = 0, 10 do
        print(n .. "\t" .. factorial(n))
    end
end
&nbsp;
main()
</pre>

<h3>Demonstraèní pøíklad <strong>Test14.py</strong></h3>

<p>Ani v&nbsp;pøípadì programovacího jazyka Python není zapotøebí pou¾ívat
¾ádné slo¾itìj¹í jazykové konstrukce:</p>

<pre>
<i>--</i>
<i>-- Jednoducha pocitana smycka typu for</i>
<i>-- pouzita pro vypocet faktorialu.</i>
<i>--</i>
&nbsp;
<i>--</i>
<i>-- Vypocet faktorialu pocitanou smyckou</i>
<i>-- typu "for".</i>
<i>--</i>
def <strong>factorial</strong>(n):
    result = 1;
    <strong>for</strong> i in xrange(2, n+1):
        result = result * i
    return result
&nbsp;
<i>--</i>
<i>-- Vse je nutne otestovat.</i>
<i>--</i>
def <strong>main</strong>():
    for n in xrange(0, 11):
        print "%d\t%d" % (n, factorial(n))
&nbsp;
<i>--</i>
<i>-- Vypsani bajkkodu testovane funkce</i>
<i>--</i>
def <strong>disassemble</strong>():
    from dis import dis
&nbsp;
    print("\nfactorial:")
    dis(factorial)
main()
&nbsp;
disassemble()
</pre>

<p>V&nbsp;dal¹ím textu budou ukázány okomentované bajtkódy získané pøekladem
demonstraèních pøíkladù <strong>Test14.java</strong>,
<strong>Test14.lua</strong> i <strong>Test14.py</strong>.</p>



<h3>Bajtkód demonstraèního pøíkladu <strong>Test14.java</strong></h3>

<p>U JVM se výpoèet faktoriálu provádí v&nbsp;bajtkódu opìt s&nbsp;vyu¾itím
nízkoúrovòových podmínìných i nepodmínìných skokù:</p>

<pre>
Compiled from "Test14.java"
public class <strong>Test14</strong> extends java.lang.Object{
&nbsp;
static int <strong>factorial</strong>(int);
  Code:
   0:   iconst_1               <i>// poèáteèní hodnota promìnné result</i>
   1:   istore_1
   2:   iconst_2               <i>// poèáteèní hodnota poèitadla</i>
   3:   istore_2
   4:   iload_2                <i>// zaèátek smyèky</i>
   5:   iload_0                <i>// hodnota horní meze je pøedána v parametru</i>
   6:   if_icmpgt       19     <i>// pøi pøekroèení horní meze skok ZA konec smyèky</i>
   9:   iload_1
   10:  iload_2
   11:  imul                   <i>// vynásobit hodnotu promìnné result aktuální hodnotou poèitadla</i>
   12:  istore_1
   13:  iinc    2, 1           <i>// zvý¹it hodnotu poèitadla</i>
   16:  goto    4              <i>// nepodmínìný skok na zaèátek smyèky</i>
   19:  iload_1
   20:  ireturn                <i>// vrátit hodnotu promìnné result</i>
</pre>

<h3>Bajtkód demonstraèního pøíkladu <strong>Test14.lua</strong></h3>

<p>U programovacího jazyka Lua nalezneme v&nbsp;bajtkódu podle oèekávání
instrukce <strong>FORPREP</strong> i <strong>FORLOOP</strong>:</p>

<pre>
function &lt;<strong>Test14.lua:12,18</strong>&gt; (9 instructions at 0x869ec88)
1 param, 6 slots, 0 upvalues, 6 locals, 2 constants, 0 functions
        1       [13]    LOADK           1 -1    ; 1    <i>// poèáteèní hodnota promìnné result</i>
        2       [14]    LOADK           2 -2    ; 2    <i>// poèáteèní hodnota poèitadla</i>
        3       [14]    MOVE            3 0            <i>// pøesun parametru (horní mez) do registru 3</i>
        4       [14]    LOADK           4 -1    ; 1    <i>// krok smyèky</i>
        5       [14]    FORPREP         2 1     ; to 7 <i>// pøíprava na smyèku sní¾ení hodnoty poèitadla o krok</i>
                                                       <i>// a skok na iteraèní pøíkaz</i>
        6       [15]    MUL             1 1 5          <i>// tìlo smyèky zkrácené na jedinou instrukci</i>
        7       [14]    FORLOOP         2 -2    ; to 6 <i>// provedení iterace - zvý¹ení hodnoty poèitadla</i>
                                                       <i>// test a pøípadný skok na instrukci èíslo 6</i>
        8       [17]    RETURN          1 2            <i>// vrátit hodnotu promìnné result</i>
        9       [18]    RETURN          0 1            <i>// automaticky generovaný návrat z funkce</i>
</pre>

<h3>Bajtkód demonstraèního pøíkladu <strong>Test14.py</strong></h3>

<p>V&nbsp;pøípadì bajtkódu Pythonu se pro konstrukci smyèky pou¾ívají speciální
instrukce <strong>GET_ITER</strong> a <strong>FOR_ITER</strong>:</p>

<pre>
<strong>factorial</strong>:
 11           0 LOAD_CONST               1 (1)        <i>// poèáteèní hodnota promìnné result</i>
              3 STORE_FAST               1 (result)
&nbsp;
 12           6 SETUP_LOOP              37 (to 46)    <i>// konstrukce programové smyèky</i>
              9 LOAD_GLOBAL              0 (xrange)   <i>// pøíprava na volání xrange()</i>
             12 LOAD_CONST               2 (2)        <i>// dolní mez</i>
             15 LOAD_FAST                0 (n)        <i>// horní mez</i>
             18 LOAD_CONST               1 (1)        <i>// (n+1)</i>
             21 BINARY_ADD
             22 CALL_FUNCTION            2            <i>// zavolání xrange()</i>
             25 GET_ITER
             26 FOR_ITER                16 (to 45)    <i>// vlastní smyèka</i>
             29 STORE_FAST               2 (i)
&nbsp;
 13          32 LOAD_FAST                1 (result)   <i>// *</i>
             35 LOAD_FAST                2 (i)        <i>// * result = result * n</i>
             38 BINARY_MULTIPLY                       <i>// *</i>
             39 STORE_FAST               1 (result)   <i>// *</i>
             42 JUMP_ABSOLUTE           26            <i>// dal¹í iterace (skok na zaèátek smyèky)</i>
             45 POP_BLOCK                             <i>// úklid po ukonèení smyèky</i>
&nbsp;
 14          46 LOAD_FAST                1 (result)
             49 RETURN_VALUE                          <i>// vrátit hodnotu promìnné result</i>
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Pøeklad vnoøených poèítaných smyèek typu <strong>for</strong> do bajtkódu</h2>

<p>Dal¹ím typickým pøíkladem z&nbsp;praxe je pou¾ití dvou vnoøených poèítaných
smyèek typu <strong>for</strong>. V&nbsp;dne¹ním tøetím demonstraèním pøíkladu
se bude jednat o velmi jednoduchý (a v&nbsp;pøípadì výpisu výsledkù i naivní)
algoritmus pro tisk malé násobilky.</p>

<h3>Demonstraèní pøíklad <strong>Test15.java</strong></h3>

<p>V&nbsp;pøípadì Javy je tento algoritmus pøímoèarý (pro jednoduchost
ignorujme znak [TAB] na konci ka¾dého øádku):</p>

<pre>
<i>/**</i>
<i> * Vnorene smycky typu "for".</i>
<i> */</i>
public class <strong>Test15</strong> {
&nbsp;
    <i>/**</i>
    <i> * Staticka metoda s dvojici vnorenych</i>
    <i> * programovych smycek typu "for".</i>
    <i> */</i>
    static void <strong>testNestedForLoops</strong>() {
        <strong>for</strong> (int j = 1; j &lt;= 10; j++) {
            <strong>for</strong> (int i = 1; i &lt;= 10; i++) {
                System.out.print(i * j);
                System.out.print('\t');
            }
            System.out.println();
        }
    }
&nbsp;
    <i>/**</i>
    <i> * Vse je nutne otestovat.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        testNestedForLoops();
    }
}
</pre>

<h3>Demonstraèní pøíklad <strong>Test15.lua</strong></h3>

<p>V&nbsp;programovacím jazyku Lua je nutné pro tisk bez odøádkování pou¾ít
funkci io.write() namísto print():</p>

<pre>
<i>--</i>
<i>-- Vnorene smycky typu "for".</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Funkce s dvojici vnorenych</i>
<i>-- programovych smycek typu "for".</i>
<i>--</i>
function <strong>testNestedForLoops</strong>()
    <strong>for</strong> j = 1,10 <strong>do</strong>
        <strong>for</strong> i = 1,10 <strong>do</strong>
            io.write(i * j)
            io.write('\t')
        <strong>end</strong>
        print()
    <strong>end</strong>
end
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Vse je nutne otestovat.</i>
<i>--</i>
function <strong>main</strong>()
    testNestedForLoops();
end
&nbsp;
main()
</pre>

<h3>Demonstraèní pøíklad <strong>Test15.py</strong></h3>

<p>Podobnì je tomu v&nbsp;programovacím jazyku Python, kde se namísto
pøíkazu/funkce print() musí pou¾ít napøíklad sys.stdout.write():</p>

<pre>
<i>--</i>
<i>-- Vnorene smycky typu "for".</i>
<i>--</i>
&nbsp;
import sys
&nbsp;
<i>--</i>
<i>-- Funkce s dvojici vnorenych</i>
<i>-- programovych smycek typu "for".</i>
<i>--</i>
def <strong>testNestedForLoops</strong>():
    <strong>for</strong> j in xrange(1,11):
        <strong>for</strong> i in xrange(1,11):
            sys.stdout.write(str(i * j))
            sys.stdout.write("\t")
        print("")
&nbsp;
<i>--</i>
<i>-- Vse je nutne otestovat.</i>
<i>--</i>
def <strong>main</strong>():
    testNestedForLoops();
&nbsp;
<i>--</i>
<i>-- Vypsani bajkkodu testovane funkce</i>
<i>--</i>
def <strong>disassemble</strong>():
    from dis import dis
&nbsp;
    print("\ntestNestedForLoops:")
    dis(testNestedForLoops)
main()
&nbsp;
disassemble()
</pre>

<p>V&nbsp;dal¹ím textu budou ukázány okomentované bajtkódy získané pøekladem
demonstraèních pøíkladù <strong>Test15.java</strong>,
<strong>Test15.lua</strong> i <strong>Test15.py</strong>.</p>



<h3>Bajtkód demonstraèního pøíkladu <strong>Test15.java</strong></h3>

<p>V&nbsp;bajtkódu JVM je jasnì viditelná struktura obou programových
smyèek:</p>

<pre>
Compiled from "Test15.java"
public class <strong>Test15</strong> extends java.lang.Object{
public Test15();
&nbsp;
static void <strong>testNestedForLoops</strong>();
  Code:
   0:   iconst_1
   1:   istore_0
   2:   iload_0             <i>// zaèátek vnìj¹í smyèky</i>
   3:   bipush  10          <i>// hodnota horní meze vnìj¹í smyèky</i>
   5:   if_icmpgt       51  <i>// pøi pøekroèení horní meze skok ZA konec smyèky</i>
   8:   iconst_1
   9:   istore_1
   10:  iload_1             <i>// zaèátek vnitøní smyèky</i>
   11:  bipush  10          <i>// hodnota horní meze vnitøní smyèky</i>
   13:  if_icmpgt       39  <i>// pøi pøekroèení horní meze skok ZA konec smyèky</i>
   16:  getstatic       #2; <i>// Field java/lang/System.out:Ljava/io/PrintStream;</i>
   19:  iload_1
   20:  iload_0
   21:  imul
   22:  invokevirtual   #3; <i>// Method java/io/PrintStream.print:(I)V</i>
   25:  getstatic       #2; <i>// Field java/lang/System.out:Ljava/io/PrintStream;</i>
   28:  bipush  9
   30:  invokevirtual   #4; <i>// Method java/io/PrintStream.print:(C)V</i>
   33:  iinc    1, 1        <i>// zvý¹it hodnotu poèitadla vnitøní smyèky</i>
   36:  goto    10          <i>// nepodmínìný skok na zaèátek vnitøní smyèky</i>
   39:  getstatic       #2; <i>// Field java/lang/System.out:Ljava/io/PrintStream;</i>
   42:  invokevirtual   #5; <i>// Method java/io/PrintStream.println:()V</i>
   45:  iinc    0, 1        <i>// zvý¹it hodnotu poèitadla vnìj¹í smyèky</i>
   48:  goto    2           <i>// nepodmínìný skok na zaèátek vnìj¹í smyèky</i>
   51:  return              <i>// návrat z metody</i>
</pre>

<h3>Bajtkód demonstraèního pøíkladu <strong>Test15.lua</strong></h3>

<p>I v&nbsp;pøípadì bajtkódu Lua VM získáme pøehlednì strukturovaný
bajtkód:</p>

<pre>
function &lt;<strong>Test15.lua:11,19</strong>&gt; (21 instructions at 0x9356cb0)
0 params, 10 slots, 1 upvalue, 8 locals, 6 constants, 0 functions
        1       [12]    LOADK           0 -1    ; 1         <i>// poèáteèní hodnota poèitadla</i>
        2       [12]    LOADK           1 -2    ; 10        <i>// horní mez vnìj¹í smyèky</i>
        3       [12]    LOADK           2 -1    ; 1         <i>// krok vnìj¹í smyèky</i>
        4       [12]    FORPREP         0 15    ; to 20     <i>// pøípravný krok pro vnìj¹í smyèku</i>
        5       [13]    LOADK           4 -1    ; 1         <i>// poèáteèní hodnota poèitadla</i>
        6       [13]    LOADK           5 -2    ; 10        <i>// horní mez vnitøní smyèky</i>
        7       [13]    LOADK           6 -1    ; 1         <i>// krok vnitøní smyèky</i>
        8       [13]    FORPREP         4 8     ; to 17     <i>// pøípravný krok pro vnitøní smyèku</i>
        9       [14]    GETTABUP        8 0 -3  ; _ENV "io"
        10      [14]    GETTABLE        8 8 -4  ; "write"
        11      [14]    MUL             9 7 3
        12      [14]    CALL            8 2 1               <i>// zavolání funkce io.write()</i>
        13      [15]    GETTABUP        8 0 -3  ; _ENV "io"
        14      [15]    GETTABLE        8 8 -4  ; "write"
        15      [15]    LOADK           9 -5    ; "\t"
        16      [15]    CALL            8 2 1               <i>// zavolání funkce io.write()</i>
        17      [13]    FORLOOP         4 -9    ; to 9      <i>// vnitøní smyèka &ndash; zaèátek dal¹í iterace</i>
        18      [17]    GETTABUP        4 0 -6  ; _ENV "print"
        19      [17]    CALL            4 1 1               <i>// zavolání funkce print()</i>
        20      [12]    FORLOOP         0 -16   ; to 5      <i>// vnìj¹í smyèka &ndash; zaèátek dal¹í iterace</i>
        21      [19]    RETURN          0 1                 <i>// automaticky generovaný návrat z funkce</i>
</pre>

<h3>Bajtkód demonstraèního pøíkladu <strong>Test14.py</strong></h3>

<p>Nyní se podívejme na bajtkód vygenerovaný pro Python VM:</p>

<pre>
<strong>testNestedForLoops</strong>:
 12           0 SETUP_LOOP              96 (to 99)    <i>// konstrukce vnìj¹í programové smyèky</i>
              3 LOAD_GLOBAL              0 (xrange)
              6 LOAD_CONST               1 (1)        <i>// dolní mez</i>
              9 LOAD_CONST               2 (11)       <i>// horní mez</i>
             12 CALL_FUNCTION            2            <i>// zavolání xrange()</i>
             15 GET_ITER
             16 FOR_ITER                79 (to 98)    <i>// vlastní vnìj¹í smyèka</i>
             19 STORE_FAST               0 (j)
&nbsp;
 13          22 SETUP_LOOP              65 (to 90)    <i>// konstrukce vnitøní programové smyèky</i>
             25 LOAD_GLOBAL              0 (xrange)
             28 LOAD_CONST               1 (1)        <i>// dolní mez</i>
             31 LOAD_CONST               2 (11)       <i>// horní mez</i>
             34 CALL_FUNCTION            2            <i>// zavolání xrange()</i>
             37 GET_ITER
             38 FOR_ITER                48 (to 89)    <i>// vlastní vnitøní smyèka</i>
             41 STORE_FAST               1 (i)
&nbsp;
 14          44 LOAD_GLOBAL              1 (sys)
             47 LOAD_ATTR                2 (stdout)
             50 LOAD_ATTR                3 (write)
             53 LOAD_GLOBAL              4 (str)
             56 LOAD_FAST                1 (i)
             59 LOAD_FAST                0 (j)
             62 BINARY_MULTIPLY
             63 CALL_FUNCTION            1            <i>// zavolání str()</i>
             66 CALL_FUNCTION            1            <i>// zavolání sys.stdout.write()</i>
             69 POP_TOP
&nbsp;
 15          70 LOAD_GLOBAL              1 (sys)
             73 LOAD_ATTR                2 (stdout)
             76 LOAD_ATTR                3 (write)
             79 LOAD_CONST               3 ('\t')
             82 CALL_FUNCTION            1            <i>// zavolání sys.stdout.write()</i>
             85 POP_TOP
             86 JUMP_ABSOLUTE           38            <i>// dal¹í iterace (skok na zaèátek vnitøní smyèky)</i>
             89 POP_BLOCK                             <i>// úklid po ukonèení smyèky</i>
&nbsp;
 16          90 LOAD_CONST               4 ('')
             93 PRINT_ITEM
             94 PRINT_NEWLINE                         <i>// zavolání print()</i>
             95 JUMP_ABSOLUTE           16            <i>// dal¹í iterace (skok na zaèátek vnìj¹í smyèky)</i>
             98 POP_BLOCK                             <i>// úklid po ukonèení smyèky</i>
             99 LOAD_CONST               0 (None)
            102 RETURN_VALUE                          <i>// návrat se speciální hodnotou None</i>
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Pøíkazy <strong>break</strong> a <strong>continue</strong>, popø.&nbsp;jejich ekvivalenty</h2>

<p>S&nbsp;programovými smyèkami v¹ech typù (poèítané i nepoèítané) pomìrnì úzce
souvisí i pøíkazy <strong>break</strong> a <strong>continue</strong> slou¾ící
buï k&nbsp;ukonèení bìhu smyèky popø.&nbsp;k&nbsp;pøeskoèení zbytku tìla smyèky
a zahájení nové iterace. Oba zmínìné pøíkazy jsou podporovány v&nbsp;Javì a
Pythonu, ov¹em v&nbsp;pøípadì programovacího jazyka Lua je nutné pøíkaz
<strong>continue</strong> nahradit programovou logikou, v&nbsp;souèasné verzi
jazyka velmi pravdìpodobnì pøíkazem <strong>goto</strong>.</p>

<h3>Demonstraèní pøíklad <strong>Test16.java</strong></h3>

<p>Následující demonstraèní pøíklad pouze ukazuje mo¾nosti pøíkazù
<strong>break</strong> a <strong>continue</strong>, proto¾e implementovaný
algoritmus ve skuteènosti nemá ¾ádný vìt¹í význam:</p>

<pre>
<i>/**</i>
<i> * Vnorene smycky typu "for"</i>
<i> * spolecne s prikazy "break" a "continue".</i>
<i> */</i>
public class <strong>Test16</strong> {
&nbsp;
    <i>/**</i>
    <i> * Staticka metoda s dvojici vnorenych</i>
    <i> * programovych smycek typu "for".</i>
    <i> */</i>
    static void <strong>testNestedForLoops</strong>() {
        <strong>for</strong> (int y = 0; y &lt; 10; y++) {
            if (y &lt; 5) <strong>continue</strong>;
            <strong>for</strong> (int x = 0; x &lt; 10; x++) {
                if (x == 5) <strong>break</strong>;
            }
        }
    }
}
</pre>

<h3>Demonstraèní pøíklad <strong>Test16.lua</strong></h3>

<p>Implementace tého¾ algoritmu v&nbsp;programovacím jazyku Lua vy¾aduje
pou¾ití pøíkazu <strong>goto</strong> na návì¹tí umístìné na konci tìla smyèky.
Návì¹tí se podle upravené syntaxe zapisuje se &bdquo;ètyøteèkou&ldquo; na
zaèátku i na konci jeho jména:</p>

<pre>
<i>--</i>
<i>-- Vnorene smycky typu "for"</i>
<i>-- spolecne s prikazy "break" a "continue".</i>
<i>--</i>
&nbsp;
<i>--</i>
<i>-- Funlkce s dvojici vnorenych</i>
<i>-- programovych smycek typu "for".</i>
<i>--/</i>
function <strong>testNestedForLoops</strong>()
    <strong>for</strong> y = 0, 9 <strong>do</strong>
        if y &lt; 5 then
            goto continue
        end
        <strong>for</strong> x = 0, 9 <strong>do</strong>
            if x == 5 then
                break
            end
        <strong>end</strong>
        ::continue::
    <strong>end</strong>
end
</pre>

<h3>Demonstraèní pøíklad <strong>Test16.py</strong></h3>

<p>Implementace pùvodního algoritmu v&nbsp;Pythonu je prakticky stejná jako
tomu bylo v&nbsp;Javì, pokud tedy odhlédneme od pou¾ití funkce
<strong>xrange()</strong> a ponìkud odli¹né (elegantnìj¹í :-) syntaxe:</p>

<pre>
<i>--</i>
<i>-- Vnorene smycky typu "for"</i>
<i>-- spolecne s prikazy "break" a "continue".</i>
<i>--</i>
&nbsp;
<i>--</i>
<i>-- Funkce s dvojici vnorenych</i>
<i>-- programovych smycek typu "for".</i>
<i>--</i>
def <strong>testNestedForLoops</strong>():
    <strong>for</strong> y in xrange(1,11):
        if y ==5:
            <strong>continue</strong>
        <strong>for</strong> x in xrange(1,11):
            if x == 5:
                <strong>break</strong>
&nbsp;
<i>--</i>
<i>-- Vypsani bajkkodu testovane funkce</i>
<i>--</i>
def <strong>disassemble</strong>():
    from dis import dis
&nbsp;
    print("\ntestNestedForLoops:")
    dis(testNestedForLoops)
&nbsp;
disassemble()
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Pøeklad pøíkazù typu <strong>break</strong> a <strong>continue</strong> do bajtkódu</h2>

<p>V&nbsp;této kapitole budou ukázány okomentované bajtkódy získané pøekladem
demonstraèních pøíkladù <strong>Test16.java</strong>,
<strong>Test16.lua</strong> i <strong>Test16.py</strong>.</p>

<h3>Bajtkód demonstraèního pøíkladu <strong>Test16.java</strong></h3>

<p>V&nbsp;bajtkódu vytvoøeného pro JVM mù¾eme vidìt pou¾ití nepodmínìných i
podmínìných skokù; takto generovaný bajtkód do znaèné míry pøipomíná strojový
kód mnoha typù mikroprocesorù:</p>

<pre>
static void <strong>testNestedForLoops</strong>();
  Code:
   0:   iconst_0        <i>// inicializace poèitadla vnìj¹í smyèky</i>
   1:   istore_0        <i>// jedná se o první lokální promìnnou (s viditelností jen uvnitø smyèky)</i>
&nbsp;
   2:   iload_0         <i>// podmínka ukonèení vnìj¹í smyèky</i>
   3:   bipush  10      <i>// konstanta pøedstavující hodnotu poèitadla, pøi jejím¾ dosa¾ení se smyèka ukonèí</i>
   5:   if_icmpge   44  <i>// poèitadlo dosáhlo mezní hodnoty - skok ZA konec vnìj¹í smyèky</i>
&nbsp;
   8:   iload_0         <i>// implementace podmínky "if (y &lt; 5) continue;"</i>
   9:   iconst_5        <i>// konstanta, s ní¾ je hodnota poèitadla srovnávána</i>
   10:  if_icmpge   16
   13:  goto    38      <i>// skok ZA konec vnitøní smyèky</i>
&nbsp;
   16:  iconst_0        <i>// inicializace poèitadla vnitøní smyèky</i>
   17:  istore_1        <i>// jedná se o druhou lokální promìnnou (s viditelností jen uvnitø smyèky)</i>
&nbsp;
   18:  iload_1         <i>// podmínka ukonèení vnitøní smyèky</i>
   19:  bipush  10      <i>// konstanta pøedstavující hodnotu poèitadla, pøi jejím¾ dosa¾ení se smyèka ukonèí</i>
   21:  if_icmpge   38  <i>// poèitadlo dosáhlo mezní hodnoty - skok ZA konec vnitøní smyèky </i>
&nbsp;
   24:  iload_1         <i>// implementace podmínky "if (x == 5) break;"</i>
   25:  iconst_5        <i>// konstanta, s ní¾ je hodnota poèitadla srovnávána</i>
   26:  if_icmpne   32
   29:  goto    38      <i>// skok ZA konec vnitøní smyèky</i>
&nbsp;
   32:  iinc    1, 1    <i>// zvý¹ení poèitadla vnitøní smyèky</i>
   35:  goto    18      <i>// dal¹í iterace vnitøní smyèky</i>
&nbsp;
   38:  iinc    0, 1    <i>// zvý¹ení poèitadla vnìj¹í smyèky</i>
   41:  goto    2       <i>// dal¹í iterace vnìj¹í smyèky</i>
&nbsp;
   44:  return
</pre>

<h3>Bajtkód demonstraèního pøíkladu <strong>Test16.lua</strong></h3>

<p>V&nbsp;pøípadì programovacího jazyka Lua je do sekvence instrukcí
s&nbsp;dvojicí do sebe vnoøených programových smyèek vlo¾ena i dvojice skokù;
první pro implementaci <strong>continue</strong>, druhý pro implementaci
<strong>break</strong>:</p>

<pre>
function &lt;<strong>Test16.lua:10,22</strong>&gt; (15 instructions at 0x8862cb0)
0 params, 8 slots, 0 upvalues, 8 locals, 4 constants, 0 functions
        1       [11]    LOADK           0 -1    ; 0         <i>// poèáteèní hodnota poèitadla</i>
        2       [11]    LOADK           1 -2    ; 9         <i>// horní mez vnìj¹í smyèky</i>
        3       [11]    LOADK           2 -3    ; 1         <i>// krok vnìj¹í smyèky</i>
        4       [11]    FORPREP         0 9     ; to 14     <i>// pøípravný krok pro vnìj¹í smyèku</i>
        5       [12]    LT              1 3 -4  ; - 5
        6       [12]    JMP             0 7     ; to 14     <i>// implementace "continue"</i>
        7       [15]    LOADK           4 -1    ; 0         <i>// poèáteèní hodnota poèitadla</i>
        8       [15]    LOADK           5 -2    ; 9         <i>// horní mez vnitøní smyèky</i>
        9       [15]    LOADK           6 -3    ; 1         <i>// krok vnitøní smyèky</i>
        10      [15]    FORPREP         4 2     ; to 13     <i>// pøípravný krok pro vnitøní smyèku</i>
        11      [16]    EQ              1 7 -4  ; - 5
        12      [16]    JMP             0 1     ; to 14     <i>// implementace "break"</i>
        13      [15]    FORLOOP         4 -3    ; to 11     <i>// vnitøní smyèka &ndash; zaèátek dal¹í iterace</i>
        14      [11]    FORLOOP         0 -10   ; to 5      <i>// vnìj¹í smyèka &ndash; zaèátek dal¹í iterace</i>
        15      [22]    RETURN          0 1                 <i>// automaticky generovaný návrat z funkce</i>
</pre>

<h3>Bajtkód demonstraèního pøíkladu <strong>Test16.py</strong></h3>

<p>Podobnì je tomu i v&nbsp;pøípadì bajtkódu vytvoøeného pro Python VM:</p>

<pre>
<strong>testNestedForLoops</strong>:
 11           0 SETUP_LOOP              87 (to 90)    <i>// konstrukce vnìj¹í programové smyèky</i>
              3 LOAD_GLOBAL              0 (xrange)
              6 LOAD_CONST               1 (1)        <i>// dolní mez</i>
              9 LOAD_CONST               2 (11)       <i>// horní mez</i>
             12 CALL_FUNCTION            2            <i>// zavolání xrange()</i>
             15 GET_ITER
             16 FOR_ITER                70 (to 89)    <i>// vlastní vnìj¹í smyèka</i>
             19 STORE_FAST               0 (y)
&nbsp;
 12          22 LOAD_FAST                0 (y)
             25 LOAD_CONST               3 (5)
             28 COMPARE_OP               2 (==)
             31 JUMP_IF_FALSE            7 (to 41)    <i>// implementace "continue"</i>
             34 POP_TOP
&nbsp;
 13          35 JUMP_ABSOLUTE           16
             38 JUMP_FORWARD             1 (to 42)
             41 POP_TOP
&nbsp;
 14          42 SETUP_LOOP              41 (to 86)    <i>// konstrukce vnitøní programové smyèky</i>
             45 LOAD_GLOBAL              0 (xrange)
             48 LOAD_CONST               1 (1)        <i>// dolní mez</i>
             51 LOAD_CONST               2 (11)       <i>// horní mez</i>
             54 CALL_FUNCTION            2            <i>// zavolání xrange()</i>
             57 GET_ITER
             58 FOR_ITER                24 (to 85)    <i>// vlastní vnitøní smyèka</i>
             61 STORE_FAST               1 (x)
&nbsp;
 15          64 LOAD_FAST                1 (x)
             67 LOAD_CONST               3 (5)
             70 COMPARE_OP               2 (==)
             73 JUMP_IF_FALSE            5 (to 81)    <i>// implementace "break"</i>
             76 POP_TOP
&nbsp;
 16          77 BREAK_LOOP
             78 JUMP_ABSOLUTE           58
             81 POP_TOP
             82 JUMP_ABSOLUTE           58
             85 POP_BLOCK                             <i>// úklid po ukonèení smyèky</i>
             86 JUMP_ABSOLUTE           16
             89 POP_BLOCK                             <i>// úklid po ukonèení smyèky</i>
             90 LOAD_CONST               0 (None)
             93 RETURN_VALUE                          <i>// návrat se speciální hodnotou None</i>
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Repositáø se zdrojovými kódy v¹ech dne¹ních demonstraèních pøíkladù</h2>

<p>V¹echny dnes popsané a vyu¾ité demonstraèní pøíklady (naprogramované
v&nbsp;Javì, Lue i Pythonu) byly ulo¾eny do Mercurial repositáøe umístìného na
adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
Odkazy na prozatím poslední verze tìchto pøíkladù naleznete v&nbsp;tabulce pod
tímto odstavcem:</p>

<table>
<tr><th> #</th><th>Zdrojový kód</th><th>Umístìní</th></tr>
<tr><td> 1</td><td>Test12.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/26b4e0c08aec/bytecode/Java/Test12.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/26b4e0c08aec/bytecode/Java/Test12.java</a></td></tr>
<tr><td> 2</td><td>Test12.lua </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/aebd1be349ad/bytecode/Lua/Test12.lua">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/aebd1be349ad/bytecode/Lua/Test12.lua</a></td></tr>
<tr><td> 3</td><td>Test12.py  </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ec224922e4b/bytecode/Python/Test12.py">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ec224922e4b/bytecode/Python/Test12.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp; </td><td>&nbsp;</td></tr>
<tr><td> 4</td><td>Test13.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ecb2c719334/bytecode/Java/Test13.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ecb2c719334/bytecode/Java/Test13.java</a></td></tr>
<tr><td> 5</td><td>Test13.lua </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/aebd1be349ad/bytecode/Lua/Test13.lua">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/aebd1be349ad/bytecode/Lua/Test13.lua</a></td></tr>
<tr><td> 6</td><td>Test13.py  </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ec224922e4b/bytecode/Python/Test13.py">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ec224922e4b/bytecode/Python/Test13.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp; </td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>Test14.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ecb2c719334/bytecode/Java/Test14.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ecb2c719334/bytecode/Java/Test14.java</a></td></tr>
<tr><td> 8</td><td>Test14.lua </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/aebd1be349ad/bytecode/Lua/Test14.lua">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/aebd1be349ad/bytecode/Lua/Test14.lua</a></td></tr>
<tr><td> 9</td><td>Test14.py  </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ec224922e4b/bytecode/Python/Test14.py">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ec224922e4b/bytecode/Python/Test14.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp; </td><td>&nbsp;</td></tr>
<tr><td>10</td><td>Test15.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ecb2c719334/bytecode/Java/Test15.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ecb2c719334/bytecode/Java/Test15.java</a></td></tr>
<tr><td>11</td><td>Test15.lua </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/aebd1be349ad/bytecode/Lua/Test15.lua">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/aebd1be349ad/bytecode/Lua/Test15.lua</a></td></tr>
<tr><td>12</td><td>Test15.py  </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ec224922e4b/bytecode/Python/Test15.py">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ec224922e4b/bytecode/Python/Test15.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp; </td><td>&nbsp;</td></tr>
<tr><td>13</td><td>Test16.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ecb2c719334/bytecode/Java/Test16.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ecb2c719334/bytecode/Java/Test16.java</a></td></tr>
<tr><td>14</td><td>Test16.lua </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/aebd1be349ad/bytecode/Lua/Test16.lua">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/aebd1be349ad/bytecode/Lua/Test16.lua</a></td></tr>
<tr><td>15</td><td>Test16.py  </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ec224922e4b/bytecode/Python/Test16.py">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/1ec224922e4b/bytecode/Python/Test16.py</a></td></tr>
</table>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>Programming in Lua (first edition)<br />
<a href="http://www.lua.org/pil/contents.html">http://www.lua.org/pil/contents.html</a>
</li>

<li>Programming in Lua: Numeric for<br />
<a href="http://www.lua.org/pil/4.3.4.html">http://www.lua.org/pil/4.3.4.html</a>
</li>

<li>Programming in Lua: break and return<br />
<a href="http://www.lua.org/pil/4.4.html">http://www.lua.org/pil/4.4.html</a>
</li>

<li>Lua: Control Structure Tutorial<br />
<a href="http://lua-users.org/wiki/ControlStructureTutorial">http://lua-users.org/wiki/ControlStructureTutorial</a>
</li>

<li>Lua Types Tutorial<br />
<a href="http://lua-users.org/wiki/LuaTypesTutorial">http://lua-users.org/wiki/LuaTypesTutorial</a>
</li>

<li>Programovací jazyk Lua<br />
<a href="http://palmknihy.cz/web/kniha/programovaci-jazyk-lua-12651.htm">http://palmknihy.cz/web/kniha/programovaci-jazyk-lua-12651.htm</a>
</li>

<li>Goto Statement in Lua<br />
<a href="http://lua-users.org/wiki/GotoStatement">http://lua-users.org/wiki/GotoStatement</a>
</li>

<li>Python break, continue and pass Statements<br />
<a href="http://www.tutorialspoint.com/python/python_loop_control.htm">http://www.tutorialspoint.com/python/python_loop_control.htm</a>
</li>

<li>For Loop (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/For_loop">http://en.wikipedia.org/wiki/For_loop</a>
</li>

<li>Heinz Rutishauser<br />
<a href="http://en.wikipedia.org/wiki/Heinz_Rutishauser">http://en.wikipedia.org/wiki/Heinz_Rutishauser</a>
</li>

<li>Parrot<br />
<a href="http://www.parrot.org/">http://www.parrot.org/</a>
</li>

<li>Parrot languages<br />
<a href="http://www.parrot.org/languages">http://www.parrot.org/languages</a>
</li>

<li>Parrot Primer<br />
<a href="http://docs.parrot.org/parrot/latest/html/docs/intro.pod.html">http://docs.parrot.org/parrot/latest/html/docs/intro.pod.html</a>
</li>

<li>Parrot Opcodes<br />
<a href="http://docs.parrot.org/parrot/latest/html/ops.html">http://docs.parrot.org/parrot/latest/html/ops.html</a>
</li>

<li>Parrot VM<br />
<a href="http://en.wikibooks.org/wiki/Parrot_Virtual_Machine">http://en.wikibooks.org/wiki/Parrot_Virtual_Machine</a>
</li>

<li>Parrot Assembly Language<br />
<a href="http://www.perl6.org/archive/pdd/pdd06_pasm.html">http://www.perl6.org/archive/pdd/pdd06_pasm.html</a>
</li>

<li>Parrot Reference: Chapter 11 - Perl 6 and Parrot Essentials<br />
<a href="http://oreilly.com/perl/excerpts/perl-6-and-parrot-essentials/parrot-reference.html">http://oreilly.com/perl/excerpts/perl-6-and-parrot-essentials/parrot-reference.html</a>
</li>

<li>Python Bytecode: Fun With Dis<br />
<a href="http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/">http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/</a>
</li>

<li>Python's Innards: Hello, ceval.c!<br />
<a href="http://tech.blog.aknin.name/category/my-projects/pythons-innards/">http://tech.blog.aknin.name/category/my-projects/pythons-innards/</a>
</li>

<li>Byterun<br />
<a href="https://github.com/nedbat/byterun">https://github.com/nedbat/byterun</a>
</li>

<li>Python Byte Code Instructions<br />
<a href="http://document.ihg.uni-duisburg.de/Documentation/Python/lib/node56.html">http://document.ihg.uni-duisburg.de/Documentation/Python/lib/node56.html</a>
</li>

<li>Python Byte Code Instructions<br />
<a href="https://docs.python.org/3.2/library/dis.html#python-bytecode-instructions">https://docs.python.org/3.2/library/dis.html#python-bytecode-instructions</a>
</li>

<li>Lua 5.2 sources<br />
<a href="http://www.lua.org/source/5.2/">http://www.lua.org/source/5.2/</a>
</li>

<li>Lua 5.2 sources - lopcodes.h<br />
<a href="http://www.lua.org/source/5.2/lopcodes.h.html">http://www.lua.org/source/5.2/lopcodes.h.html</a>
</li>

<li>Lua 5.2 sources - lopcodes.c<br />
<a href="http://www.lua.org/source/5.2/lopcodes.c.html">http://www.lua.org/source/5.2/lopcodes.c.html</a>
</li>

<li>dis - Python module<br />
<a href="https://docs.python.org/2/library/dis.html">https://docs.python.org/2/library/dis.html</a>
</li>

<li>Comparison of Python virtual machines<br />
<a href="http://polishlinux.org/apps/cli/comparison-of-python-virtual-machines/">http://polishlinux.org/apps/cli/comparison-of-python-virtual-machines/</a>
</li>

<li>O-code<br />
<a href="http://en.wikipedia.org/wiki/O-code_machine">http://en.wikipedia.org/wiki/O-code_machine</a>
</li>

<li>BCPL<br />
<a href="http://en.wikipedia.org/wiki/BCPL">http://en.wikipedia.org/wiki/BCPL</a>
</li>

<li>The BCPL Cintcode System and Cintpos User Guide by Martin Richards<br />
<a href="http://www.cl.cam.ac.uk/users/mr/bcplman.pdf">http://www.cl.cam.ac.uk/users/mr/bcplman.pdf</a>
</li>

<li>Bootstrapping the BCPL Compiler using INTCODE<br />
<a href="http://www.gtoal.com/languages/bcpl/amiga/bcpl/booting.txt">http://www.gtoal.com/languages/bcpl/amiga/bcpl/booting.txt</a>
</li>

<li>p-code machine<br />
<a href="http://en.wikipedia.org/wiki/P-code_machine">http://en.wikipedia.org/wiki/P-code_machine</a>
</li>

<li>ucsd-psystem-vm 0.11 (a portable virtual machine for the UCSD p-System)<br />
<a href="http://ucsd-psystem-vm.sourceforge.net/">http://ucsd-psystem-vm.sourceforge.net/</a>
</li>

<li>Introduction to Smalltalk bytecodes<br />
<a href="http://marianopeck.wordpress.com/2011/05/21/introduction-to-smalltalk-bytecodes/">http://marianopeck.wordpress.com/2011/05/21/introduction-to-smalltalk-bytecodes/</a>
</li>

<li>Audio File Formats.<br />
<a href="http://sox.sourceforge.net/AudioFormats-11.html">http://sox.sourceforge.net/AudioFormats-11.html</a>
</li>

<li>TestSounds.com: pure digital sounds to test your audio<br />
<a href="http://www.testsounds.com/">http://www.testsounds.com/</a>
</li>

<li>Test Tones (20hz - 20khz)<br />
<a href="http://mdf1.tripod.com/test-tones.html">http://mdf1.tripod.com/test-tones.html</a>
</li>

<li>WAV (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/WAV">http://en.wikipedia.org/wiki/WAV</a>
</li>

<li>WAVE PCM soundfile format<br />
<a href="https://ccrma.stanford.edu/courses/422/projects/WaveFormat/">https://ccrma.stanford.edu/courses/422/projects/WaveFormat/</a>
</li>

<li>Audio Interchange File Format<br />
<a href="http://en.wikipedia.org/wiki/Aiff">http://en.wikipedia.org/wiki/Aiff</a>
</li>

<li>Musical Instrument Digital Interface,<br />
<a href="http://en.wikipedia.org/wiki/Musical_Instrument_Digital_Interface">http://en.wikipedia.org/wiki/Musical_Instrument_Digital_Interface</a>
</li>

<li>A MIDI Pedalboard Encode,<br />
<a href="http://www.pykett.org.uk/a_midi_pedalboard_encoder.htm">http://www.pykett.org.uk/a_midi_pedalboard_encoder.htm</a>
</li>

<li>MIDI Note Number, Frequency Table,<br />
<a href="http://tonalsoft.com/pub/news/pitch-bend.aspx">http://tonalsoft.com/pub/news/pitch-bend.aspx</a>
</li>

<li>Note names, MIDI numbers and frequencies,<br />
<a href="http://www.phys.unsw.edu.au/jw/notes.html">http://www.phys.unsw.edu.au/jw/notes.html</a>
</li>

<li>The MIDI Specification,<br />
<a href="http://www.gweep.net/~prefect/eng/reference/protocol/midispec.html">http://www.gweep.net/~prefect/eng/reference/protocol/midispec.html</a>
</li>

<li>Essentials of the MIDI protocol,<br />
<a href="http://ccrma.stanford.edu/~craig/articles/linuxmidi/misc/essenmidi.html">http://ccrma.stanford.edu/~craig/articles/linuxmidi/misc/essenmidi.html</a>
</li>

<li>General MIDI,<br />
<a href="http://en.wikipedia.org/wiki/General_MIDI">http://en.wikipedia.org/wiki/General_MIDI</a>
</li>

<li>Obecné MIDI (General MIDI), <br />
<a href="http://www-kiv.zcu.cz/~herout/html_sbo/midi/5.html">http://www-kiv.zcu.cz/~herout/html_sbo/midi/5.html</a>
</li>

<li>Custom Chips: Paula<br />
<a href="http://www.amiga-hardware.com/showhardware.cgi?HARDID=1460">http://www.amiga-hardware.com/showhardware.cgi?HARDID=1460</a>
</li>

<li>Big Book of Amiga Hardware<br />
<a href="http://www.amiga-resistance.info/bboahfaq/">http://www.amiga-resistance.info/bboahfaq/</a>
</li>

<li>Amiga Hardware Database<br />
<a href="http://amiga.resource.cx/">http://amiga.resource.cx/</a>
</li>

<li>ExoticA<br />
<a href="http://www.exotica.org.uk/wiki/Main_Page">http://www.exotica.org.uk/wiki/Main_Page</a>
</li>

<li>The absolute basics of Amiga audio<br />
<a href="http://www.sufo.estates.co.uk/amiga/amimus.html">http://www.sufo.estates.co.uk/amiga/amimus.html</a>
</li>

<li>Wikipedia: Tracker<br />
<a href="http://en.wikipedia.org/wiki/Tracker">http://en.wikipedia.org/wiki/Tracker</a>
</li>

<li>Wikipedia: Trackers<br />
<a href="http://en.wikipedia.org/wiki/Trackers">http://en.wikipedia.org/wiki/Trackers</a>
</li>

<li>Ultimate Soundtracker<br />
<a href="http://en.wikipedia.org/wiki/Ultimate_Soundtracker">http://en.wikipedia.org/wiki/Ultimate_Soundtracker</a>
</li>

<li>Protracker<br />
<a href="http://en.wikipedia.org/wiki/ProTracker">http://en.wikipedia.org/wiki/ProTracker</a>
</li>

<li>Impulse Tracker<br />
<a href="http://en.wikipedia.org/wiki/Impulse_Tracker">http://en.wikipedia.org/wiki/Impulse_Tracker</a>
</li>

<li>Scream Tracker<br />
<a href="http://en.wikipedia.org/wiki/ScreamTracker">http://en.wikipedia.org/wiki/ScreamTracker</a>
</li>

<li>MikMod for Java<br />
<a href="http://jmikmod.berlios.de/">http://jmikmod.berlios.de/</a>
</li>

<li>List of audio trackers<br />
<a href="http://en.wikipedia.org/wiki/List_of_audio_trackers">http://en.wikipedia.org/wiki/List_of_audio_trackers</a>
</li>

<li>Wikipedia: Module File<br />
<a href="http://en.wikipedia.org/wiki/Module_file">http://en.wikipedia.org/wiki/Module_file</a>
</li>

<li>Wikipedia: Chiptune<br />
<a href="http://en.wikipedia.org/wiki/Chiptune">http://en.wikipedia.org/wiki/Chiptune</a>
</li>

<li>SDL_mixer 2.0<br />
<a href="http://www.libsdl.org/projects/SDL_mixer/">http://www.libsdl.org/projects/SDL_mixer/</a>
</li>

<li>SDLJava: package sdljava.ttf<br />
<a href="http://sdljava.sourceforge.net/docs/api/sdljava/ttf/package-summary.html#package_description">http://sdljava.sourceforge.net/docs/api/sdljava/ttf/package-summary.html#package_description</a>
</li>

<li>SDLJava: class sdljava.ttf.SDLTTF<br />
<a href="http://sdljava.sourceforge.net/docs/api/sdljava/ttf/SDLTTF.html">http://sdljava.sourceforge.net/docs/api/sdljava/ttf/SDLTTF.html</a>
</li>

<li>SDLJava: class sdljava.ttf.SDLTrueTypeFont<br />
<a href="http://sdljava.sourceforge.net/docs/api/sdljava/ttf/SDLTrueTypeFont.html">http://sdljava.sourceforge.net/docs/api/sdljava/ttf/SDLTrueTypeFont.html</a>
</li>

<li>SDL_ttf Documentation<br />
<a href="http://www.libsdl.org/projects/SDL_ttf/docs/">http://www.libsdl.org/projects/SDL_ttf/docs/</a>
</li>

<li>SDL_ttf 2.0 (není prozatím souèástí SDLJava)<br />
<a href="http://www.libsdl.org/projects/SDL_ttf/">http://www.libsdl.org/projects/SDL_ttf/</a>
</li>

<li>SDL_ttf doc<br />
<a href="http://www.libsdl.org/projects/SDL_ttf/docs/SDL_ttf_frame.html">http://www.libsdl.org/projects/SDL_ttf/docs/SDL_ttf_frame.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_Surface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_PixelFormat<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlpixelformat.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlpixelformat.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_LockSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdllocksurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdllocksurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_UnlockSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlunlocksurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlunlocksurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_LoadBMP<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlloadbmp.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlloadbmp.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_SaveBMP<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsavebmp.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsavebmp.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_BlitSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlblitsurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlblitsurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_VideoInfo<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlvideoinfo.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlvideoinfo.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_GetVideoInfo<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlgetvideoinfo.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlgetvideoinfo.html</a>
</li>

<li>glDrawArrays<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArrays.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArrays.xml</a>
</li>

<li>glDrawElements<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElements.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElements.xml</a>
</li>

<li>glDrawArraysInstanced<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArraysInstanced.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArraysInstanced.xml</a>
</li>

<li>glDrawElementsInstanced<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElementsInstanced.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElementsInstanced.xml</a>
</li>

<li>Root.cz: Seriál Grafická knihovna OpenGL<br />
<a href="http://www.root.cz/serialy/graficka-knihovna-opengl/">http://www.root.cz/serialy/graficka-knihovna-opengl/</a>
</li>

<li>Root.cz: Seriál Tvorba pøenositelných grafických aplikací vyu¾ívajících knihovnu GLUT<br />
<a href="http://www.root.cz/serialy/tvorba-prenositelnych-grafickych-aplikaci-vyuzivajicich-knihovnu-glut/">http://www.root.cz/serialy/tvorba-prenositelnych-grafickych-aplikaci-vyuzivajicich-knihovnu-glut/</a>
</li>

<li>Best Practices for Working with Vertex Data<br />
<a href="https://developer.apple.com/library/ios/documentation/3ddrawing/conceptual/opengles_programmingguide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html">https://developer.apple.com/library/ios/documentation/3ddrawing/conceptual/opengles_programmingguide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html</a>
</li>

<li>Class BufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferStrategy.html</a>
</li>

<li>Class Graphics<br />
<a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/Graphics.html">http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/Graphics.html</a>
</li>

<li>Double Buffering and Page Flipping<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html</a>
</li>

<li>BufferStrategy and BufferCapabilities<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/bufferstrategy.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/bufferstrategy.html</a>
</li>

<li>Java:Tutorials:Double Buffering<br />
<a href="http://content.gpwiki.org/index.php/Java:Tutorials:Double_Buffering">http://content.gpwiki.org/index.php/Java:Tutorials:Double_Buffering</a>
</li>

<li>Double buffer in standard Java AWT<br />
<a href="http://www.codeproject.com/Articles/2136/Double-buffer-in-standard-Java-AWT">http://www.codeproject.com/Articles/2136/Double-buffer-in-standard-Java-AWT</a>
</li>

<li>Java 2D: Hardware Accelerating - Part 1 - Volatile Images<br />
<a href="http://www.javalobby.org/forums/thread.jspa?threadID=16840&tstart=0">http://www.javalobby.org/forums/thread.jspa?threadID=16840&tstart=0</a>
</li>

<li>Java 2D: Hardware Accelerating - Part 2 - Buffer Strategies<br />
<a href="http://www.javalobby.org/java/forums/t16867.html">http://www.javalobby.org/java/forums/t16867.html</a>
</li>

<li>How does paintComponent work?<br />
<a href="http://stackoverflow.com/questions/15544549/how-does-paintcomponent-work">http://stackoverflow.com/questions/15544549/how-does-paintcomponent-work</a>
</li>

<li>A Swing Architecture Overview<br />
<a href="http://www.oracle.com/technetwork/java/architecture-142923.html">http://www.oracle.com/technetwork/java/architecture-142923.html</a>
</li>

<li>Class javax.swing.JComponent<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html</a>
</li>

<li>Class java.awt.Component<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html</a>
</li>

<li>Class java.awt.Component.BltBufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.BltBufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.BltBufferStrategy.html</a>
</li>

<li>Class java.awt.Component.FlipBufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.FlipBufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.FlipBufferStrategy.html</a>
</li>

<li>Metoda java.awt.Component.isDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html#isDoubleBuffered()">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html#isDoubleBuffered()</a>
</li>

<li>Metoda javax.swing.JComponent.isDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#isDoubleBuffered()">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#isDoubleBuffered()</a>
</li>

<li>Metoda javax.swing.JComponent.setDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#setDoubleBuffered(boolean)">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#setDoubleBuffered(boolean)</a>
</li>

<li>Javadoc - tøída GraphicsDevice<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html</a>
</li>

<li>Javadoc - tøída GraphicsEnvironment<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html</a>
</li>

<li>Javadoc - tøída GraphicsConfiguration<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html</a>
</li>

<li>Javadoc - tøída DisplayMode<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html">http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html</a>
</li>

<li>Lesson: Full-Screen Exclusive Mode API<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/">http://docs.oracle.com/javase/tutorial/extra/fullscreen/</a>
</li>

<li>Full-Screen Exclusive Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html</a>
</li>

<li>Display Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html</a>
</li>

<li>Using the Full-Screen Exclusive Mode API in Java<br />
<a href="http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm">http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>GC safe-point (or safepoint) and safe-region<br />
<a href="http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html">http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html</a>
</li>

<li>Safepoints in HotSpot JVM<br />
<a href="http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html">http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html</a>
</li>

<li>Java theory and practice: Synchronization optimizations in Mustang<br />
<a href="http://www.ibm.com/developerworks/java/library/j-jtp10185/">http://www.ibm.com/developerworks/java/library/j-jtp10185/</a>
</li>

<li>How to build hsdis<br />
<a href="http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README">http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README</a>
</li>

<li>Java SE 6 Performance White Paper<br />
<a href="http://www.oracle.com/technetwork/java/6-performance-137236.html">http://www.oracle.com/technetwork/java/6-performance-137236.html</a>
</li>

<li>Lukas Stadler's Blog<br />
<a href="http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html">http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html</a>
</li>

<li>How to build hsdis-amd64.dll and hsdis-i386.dll on Windows<br />
<a href="http://dropzone.nfshost.com/hsdis.htm">http://dropzone.nfshost.com/hsdis.htm</a>
</li>

<li>PrintAssembly<br />
<a href="https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly">https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly</a>
</li>

<li>The Java Virtual Machine Specification: 3.14. Synchronization<br />
<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14</a>
</li>

<li>The Java Virtual Machine Specification: 8.3.1.4. volatile Fields<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.4. Memory Model<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.7. Non-atomic Treatment of double and long<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7</a>
</li>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (pøed verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2014</small></p>
</body>
</html>

