<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Clojure aneb jazyk umo¾òující tvorbu bezpeèných vícevláknových aplikací pro JVM (4.èást - kolekce, sekvence a lazy sekvence)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Clojure aneb jazyk umo¾òující tvorbu bezpeèných vícevláknových aplikací pro JVM (4.èást - kolekce, sekvence a lazy sekvence)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o vlastnostech JVM budeme, stejnì jako v&nbsp;pøedchozích tøech èástech, pokraèovat v&nbsp;popisu programovacího jazyka Clojure. Dne¹ním ústøedním tématem bude práce s&nbsp;kolekcemi a se sekvencemi, proto¾e pøedev¹ím sekvence tvoøí velmi elegantní souèást Clojure.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Predikáty a testy na ekvivalenci</a></p>
<p><a href="#k02">2. Co mo¾ná mìlo zùstat utajeno aneb programujeme imperativnì ve funkcionálním jazyce</a></p>
<p><a href="#k03">3. Makro <strong>dotimes</strong></a></p>
<p><a href="#k04">4. Speciální forma <strong>do</strong> a makro <strong>while</strong></a></p>
<p><a href="#k05">5. Základní operace s kolekcemi</a></p>
<p><a href="#k06">6. Demonstraèní pøíklady &ndash; práce s&nbsp;kolekcemi</a></p>
<p><a href="#k07">7. Sekvence, lazy sekvence a funkce <strong>range</strong></a></p>
<p><a href="#k08">8. Funkce <strong>repeat</strong> a <strong>map</strong></a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Predikáty a testy na ekvivalenci</h2>

<p>V&nbsp;dne¹ní èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyce Java i o vlastnostech virtuálního stroje tohoto jazyka</a>
si popí¹eme zpùsob práce s&nbsp;kolekcemi a takté¾ se budeme zabývat takzvanými
<i>sekvencemi</i> a <i>lazy sekvencemi</i>, které tvoøí velmi dùle¾itou souèást
programovacího jazyka <i>Clojure</i>. Je¹tì pøedtím si v¹ak popí¹eme takzvané
<i>predikáty</i>, tj.&nbsp;funkce vracející hodnotu <strong>true</strong> èi
<strong>false</strong> v&nbsp;závislosti na hodnotì a/nebo typu parametru, jen¾
je predikátu pøedán. V&nbsp;nìkterých variantách programovacího jazyka
<i>LISP</i> bylo zvykem za jméno predikátu dávat znak &bdquo;p&ldquo;, tak¾e
napøíklad funkce/predikát pro test na nulovou hodnotu (velmi èasto pou¾ívaný
predikát) mìl název <strong>zerop</strong>. V&nbsp;programovacím jazyku
<i>Clojure</i> se namísto znaku &bdquo;p&ldquo; pou¾ívá otazník, proto¾e i
otazník mù¾e být souèástí názvu identifikátoru. V&nbsp;následující tabulce jsou
vypsány základní predikáty, z&nbsp;nich¾ nìkteré pozdìji vyu¾ijeme
v&nbsp;demonstraèních pøíkladech (co¾ je ostatnì jeden z&nbsp;hlavních dùvodù,
proè jsou zde predikáty vùbec uvádìny):</p>

<table>
<tr><th> #</th><th>Predikát</th><th>Význam</th></tr>
<tr><td> 1</td><td>nil?    </td><td>test, zda je pøedaná hodnota rovna literálu <strong>nil</strong></td></tr>
<tr><td> 2</td><td>true?   </td><td>test, zda je pøedaná hodnota rovna literálu <strong>true</strong></td></tr>
Tajemná funkce <strong>contains?</strong><tr><td> 3</td><td>false?  </td><td>test, zda je pøedaná hodnota rovna literálu <strong>false</strong></td></tr>
<tr><td> 4</td><td>number? </td><td>test na èíslo (libovolného typu)</td></tr>
<tr><td> 5</td><td>integer?</td><td>test na celé èíslo</td></tr>
<tr><td> 6</td><td>ratio?  </td><td>test na zlomek (nikoli na obecné desetinné èíslo)</td></tr>
<tr><td> 7</td><td>float?  </td><td>test na desetinné èíslo</td></tr>
<tr><td> 8</td><td>decimal?</td><td>test na hodnotu typu <strong>BigDecimal</strong></td></tr>
<tr><td> 9</td><td>even?   </td><td>test na sudou hodnotu</td></tr>
<tr><td>10</td><td>odd?    </td><td>test na lichou hodnotu</td></tr>
<tr><td>11</td><td>pos?    </td><td>test na kladnou hodnotu</td></tr>
<tr><td>12</td><td>neg?    </td><td>test na zápornou hodnotu</td></tr>
<tr><td>13</td><td>zero?   </td><td>test na nulu</td></tr>
<tr><td>14</td><td>keyword?</td><td>test, zda je pøedaná hodnota typu klíèové heslo</td></tr>
<tr><td>15</td><td>symbol? </td><td>test, zda je pøedaná hodnota typu symbol</td></tr>
<tr><td>16</td><td>char?   </td><td>test, zda je pøedaná hodnota typu char</td></tr>
<tr><td>17</td><td>string? </td><td>test, zda je pøedaná hodnota typu øetìzec</td></tr>
<tr><td>18</td><td>seq?    </td><td>test, zda je pøedaná hodnota typu sekvence</td></tr>
</table>

<p>Pou¾ití predikátù je velmi jednoduché, tak¾e si uká¾eme jen nìkolik
jednoøádkových demonstraèních pøíkladù.</p>

<p>Na rozdíl od jazyka <i>LISP</i> není literál <strong>nil</strong> toto¾ný
s&nbsp;prázdným seznamem:</p>

<pre>
user=&gt; (nil? '())
false
</pre>

<p><strong>nil</strong> je vlastnì singleton/jedináèek:</p>

<pre>
user=&gt; (nil? nil)
true
</pre>

<p>Dokonce ani funkce <strong>rest</strong> (aka <strong>cdr</strong>) nevrací
<strong>nil</strong>:</p>

<pre>
user=&gt; (nil? (rest '()))
false
</pre>

<p>Ukázka pou¾ití predikátu <strong>true?</strong>:</p>

<pre>
user=&gt; (true? (and true false))
false
</pre>

<p>Rùzné testy na èíselné hodnoty:</p>

<pre>
user=&gt; (number? 42)
true
</pre>

<pre>
user=&gt; (integer? 42)
true
</pre>

<pre>
user=&gt; (integer? 42.0)
false
</pre>

<pre>
user=&gt; (ratio? 42)
false
</pre>

<p>84/2 vlastnì není zlomek, proto¾e dojde k&nbsp;jeho vyhodnocení
(zjednodu¹ení) na 42 a teprve tato hodnota je testována predikátem
<strong>ratio?</strong>:</p>

<pre>
user=&gt; (ratio? 84/2)
false
</pre>

<p>Ov¹em 4/3 u¾ nelze nijak zjednodu¹it:</p>

<pre>
user=&gt; (ratio? 4/3)
true
</pre>

<pre>
user=&gt; (even? 42)
true
</pre>

<pre>
user=&gt; (symbol? 42)
false
</pre>

<pre>
user=&gt; (def cislo 42)
#'user/cislo
</pre>

<p><strong>cislo</strong> se vyhodnotí na 42:</p>

<pre>
user=&gt; (symbol? cislo)
false
</pre>

<p>Zaká¾eme vyhodnocení pomocí apostrofu:</p>

<pre>
user=&gt; (symbol? 'cislo)
true
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Co mo¾ná mìlo zùstat utajeno aneb programujeme imperativnì ve funkcionálním jazyce</h2>

<p>Je¹tì ne¾ se pustíme do popisu vlastnosti kolekcí a sekvencí, vra»me se na
chvíli <a
href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/">k&nbsp;pøedchozí
èásti tohoto seriálu</a>, konkrétnì ke kapitolám <a
href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/#k07">7</a>
a <a
href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/#k08">8</a>,
v&nbsp;nich¾ jsme si ukázali zpùsob zápisu rekurzivních algoritmù a takté¾
algoritmù vyu¾ívajících <i>tail rekurzi</i>, která je pøekladaèem jazyka
<i>Clojure</i> pøevedena na prostý skok. Na závìr osmé kapitoly jsme si takté¾
øekli, ¾e i pøesto, ¾e je rekurze velmi u¾iteèný nástroj, není
v&nbsp;<i>Clojure</i> pou¾ívána v&nbsp;takové míøe, jak by se mo¾ná mohlo
z&nbsp;rùzných &bdquo;èistì funkcionálních&ldquo; demonstraèních pøíkladù zdát.
Namísto rekurze se velmi èasto pou¾ívají právì sekvence (viz dal¹í text), ov¹em
<i>Clojure</i> doká¾e pou¾ívat i postupy známé z&nbsp;imperativních jazykù.</p>

<div class="rs-box"><p>Z&nbsp;hlediska èistoty programovacího jazyka
<i>Clojure</i> by mo¾ná nemìly následující speciální formy a makra vùbec
existovat :-) nicménì vzhledem k&nbsp;tomu, ¾e si nìkdo dal tu práci
s&nbsp;jejich vytvoøením, mù¾eme se podívat na to, jak je mo¾né nìkteré
algoritmy zapisovat &bdquo;imperativnì&ldquo;. Na tomto místì je v¹ak nutné
varovat pøed tím, ¾e pou¾itím imperativního zpùsobu zápisu algoritmù se
napøíklad zhor¹ují mo¾nosti pøekladaèe programovacího jazyka <i>Clojure</i>
v&nbsp;optimalizaci pøekládaných programù tak, aby mohly bì¾et
paralelnì.</p></div>



<p><a name="k03"></a></p>
<h2 id="k03">3. Makro <strong>dotimes</strong></h2>

<p>V&nbsp;nìkterých programech mù¾e být pomìrnì u¾iteèné makro nazvané
jednodu¹e a pøitom pøíhodnì <strong>dotimes</strong>, které doká¾e nìjaký výraz
(formu) opakovat <i>n</i> krát. Pøitom toto makro mù¾e v&nbsp;ka¾dé iteraci
(opakování) nastavit zvolenou lokální promìnnou na aktuální hodnotu poèitadla,
pøièem¾ se hodnota poèitadla v&nbsp;první iteraci v¾dy nastavuje na nulu a
v&nbsp;poslední iteraci dosahuje zadaného poètu opakování-1. Vzdálenì tedy
mù¾eme toto makro pova¾ovat za ekvivalent programové smyèky <strong>for i in
range(n):</strong> v&nbsp;programovacím jazyku <i>Python</i> èi ekvivalent
k&nbsp;poèítané smyèce <strong>for (int i = 0; i&lt;n; i++)</strong> známé
z&nbsp;céèka (zde bez mo¾nosti mít lokální promìnnou jako poèitadlo), C++, Javy
atd. Vzhledem k&nbsp;tomu, ¾e se pøedpokládá, ¾e forma &ndash; tìlo smyèky
&ndash; pøedaná makru <strong>dotimes</strong> bude mít nìjaký vedlej¹í efekt,
nejedná se sice o èistì funkcionální pøístup, nicménì makro
<strong>dotimes</strong> mù¾e být skuteènì velmi u¾iteèné.</p>

<p>V&nbsp;jednoduchém demonstraèním pøíkladu, který si uká¾eme, se na
standardní výstup vypisuje pøevrácená hodnota celých èísel od 0 do 9. Vedlej¹ím
efektem je v&nbsp;tomto pøípadì samotný výpis na standardní výstup:</p>

<pre>
(dotimes [i 10] (println (/ 1.0 i)))
Infinity
1.0
0.5
0.3333333333333333
0.25
0.2
0.16666666666666666
0.14285714285714285
0.125
0.1111111111111111
nil
</pre>

<div class="rs-box"><p>Poznámka: poslední vypsané <strong>nil</strong> je
návratovou hodnotou samotného makra <strong>dotimes</strong>, nikoli výsledek
poslední iterace)</p></div>

<p>Podívejme se nyní na ponìkud slo¾itìj¹í pøíklad, který by se
v&nbsp;imperativních programovacích jazycích vìt¹inou øe¹il s&nbsp;vyu¾itím
dvojice do sebe vnoøených poèítaných programových smyèek. Mìjme za úkol vypsat
tabulku malé násobilky, tj.&nbsp;v¹echny výsledky vzniklé vynásobením dvojic
celých èísel od 1 do 10. Tento algoritmus je mo¾né velmi snadno realizovat
právì s&nbsp;vyu¾itím makra <strong>dotimes</strong>, napøíklad následujícím
one-linerem:</p>

<pre>
(dotimes [i 10] (dotimes [j 10] (print (* (+ i 1) (+ j 1)) "\t")) (println))
</pre>

<p>Malou optimalizací v&nbsp;tomto zápisu by byla náhrada výrazù <strong>(+ i
1)</strong> za volání funkce <strong>(inc i)</strong> s&nbsp;prakticky shodným
významem (alespoò pro èísla typu integer). Mimochodem: jméno funkce
<strong>inc</strong> mù¾e evokovat to, ¾e zvy¹uje hodnotu svého parametru, co¾
v¹ak ve skuteènosti ani není mo¾né, nebo» se jedná o bì¾nou funkci a nikoli o
makro èi o speciální formu:</p>

<pre>
(dotimes [i 10] (dotimes [j 10] (print (* (inc i) (inc j)) "\t")) (println))
</pre>

<p>Pro vìt¹í pøehlednost si mù¾eme vý¹e uvedený one-liner pøepsat na správnì
odsazený program, z&nbsp;nìho¾ je patrné, ¾e se skuteènì jedná o ekvivalent
dvou do sebe zanoøených programových smyèek:</p>

<pre>
(dotimes [i 10]
    (dotimes [j 10]
        (print (* (inc i) (inc j)) "\t"))
    (println))
</pre>

<p>A zde je ji¾ výsledek práce tohoto programu (poslední <strong>nil</strong>
je opìt návratovou hodnotou makra <strong>dotimes</strong>):</p>

<pre>
1     2     3     4     5     6     7     8     9     10
2     4     6     8     10    12    14    16    18    20
3     6     9     12    15    18    21    24    27    30
4     8     12    16    20    24    28    32    36    40
5     10    15    20    25    30    35    40    45    50
6     12    18    24    30    36    42    48    54    60
7     14    21    28    35    42    49    56    63    70
8     16    24    32    40    48    56    64    72    80
9     18    27    36    45    54    63    72    81    90
10    20    30    40    50    60    70    80    90    100
nil
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Speciální forma <strong>do</strong> a makro <strong>while</strong></h2>

<p>Pokraèujme v&nbsp;popisu &bdquo;imperativních&ldquo; konstrukcí, které byly
z&nbsp;více èi ménì racionálních dùvodù pøidány do funkcionálního
programovacího jazyka <i>Clojure</i>. Kromì makra <strong>dotimes</strong>
popsaného <a href="#k03">v&nbsp;pøedchozí kapitole</a> se je¹tì relativnì èasto
vyu¾ívá speciální forma nazvaná <strong>do</strong>. Této speciální formì lze
pøedat libovolný poèet forem/výrazù, které jsou postupnì vyhodnoceny (spu¹tìny)
v&nbsp;takovém poøadí, v&nbsp;jakém jsou zapsány. Návratovou hodnotou speciální
formy <strong>do</strong> je návratová hodnota posledního vyhodnoceného výrazu.
Vzhledem k&nbsp;tomu, ¾e návratové hodnoty v¹ech pøedchozích výrazù jsou
ztraceny, pøedpokládá se, ¾e výrazy vyhodnocované v&nbsp;<strong>do</strong>
budou mít vedlej¹í efekt, jinak by je nemìlo smysl ani vyhodnocovat; samozøejmì
a¾ na výraz poslední. Opìt se podívejme na nìkolik jednoduchých demonstraèních
pøíkladù:</p>

<p>Spu¹tìní speciální formy <strong>do</strong> bez pøedání dal¹ích
forem/výrazù pouze vede k&nbsp;vrácení literálu <strong>nil</strong>:</p>

<pre>
user=&gt; (do)
nil
</pre>

<p>Pokud je speciální formì <strong>do</strong> pøedán jediný výraz, je
vyhodnocen a jeho návratová hodnota je souèasnì i návratovou hodnotou
<strong>do</strong> (jinými slovy vlastnì <strong>do</strong> nemá v&nbsp;tomto
pøípadì ¾ádný zvlá¹tní význam):</p>

<pre>
user=&gt; (do (+ 1 2))
3
</pre>

<p>Hodnota prvního výrazu se ztratí a vrátí se hodnota výrazu druhého:</p>

<pre>
user=&gt; (do (+ 1 2) (+ 3 4))
7
</pre>

<p>Podobné pøedchozímu pøíkladu: ztratí se hodnota dvou vyhodnocených výrazù,
tøetí výraz má vedlej¹í efekt a souèasnì se vrátí jeho návratová hodnota,
kterou je <strong>nil</strong> (viz <strong>(doc println)</strong> èi
<strong>(doc print)</strong>):</p>

<pre>
user=&gt; (do (+ 1 2) (+ 3 4) (println "konec"))
konec
nil
</pre>

<p>Vzhledem k&nbsp;tomu, ¾e <strong>do</strong> vyhodnocuje výrazy
v&nbsp;takovém poøadí, jak jsou pøedány, lze se spolehnout i na správné poøadí
tisku na standardní výstup (co¾ je vedlej¹ím výrazù/forem efektem):</p>

<pre>
user=&gt; (do (println "V Ceskych Budejovicich") (println "by chtel") (println "zit kazdy")) 
V Ceskych Budejovicich
by chtel
zit kazdy
nil
</pre>

<p>Speciální forma <strong>do</strong> nemá sama o sobì moc velký význam, ov¹em
èasto se pou¾ívá spoleènì s&nbsp;makrem <strong>while</strong>. Asi správnì
uhodnete, ¾e toto makro iterativnì spou¹tí (èi lépe øeèeno vyhodnocuje) nìjaké
tìlo smyèky, a to tak dlouho dokud platí, ¾e výraz zapsaný za
<strong>while</strong> se vyhodnotí na pravdivostní hodnotu
<strong>true</strong>. Pov¹imnìte si, ¾e se opìt ti¹e pøedpokládá, ¾e tìlo
smyèky bude mít nìjaký vedlej¹í efekt jen¾ zpùsobí zmìnu hodnoty výrazu smyèky
<strong>while</strong>. Typickým vedlej¹ím efektem je nastavení hodnoty nìjaké
lokální èi globální promìnné.</p>

<p>Speciální forma <strong>do</strong> se v&nbsp;tìle smyèky pou¾ívá proto, aby
mohlo tìlo obsahovat více výrazù, podobnì jako tomu bylo u makra
<strong>dotimes</strong>. Pøíklad smyèky vyu¾ívající globální promìnnou:</p>

<pre>
(def a 10)
(while (&gt; a 0) (do (println a) (def a (- a 1))))
10
9
8
7
6
5
4
3
2
1
nil
</pre>

<p>Pro vìt¹í pøehlednost lze odeèítání provést i s&nbsp;vyu¾itím funkce
<strong>dec</strong> a test na kladnou hodnotu provádìt predikátem
<strong>pos?</strong>:</p>

<pre>
(def a 10)
(while (pos? a) (do (println a) (def a (dec a))))
10
9
8
7
6
5
4
3
2
1
nil
</pre>

<p>A pro je¹tì vìt¹í pøehlednost pøevést one-liner na správnì odsazený
program:</p>

<pre>
(def a 10)
(while (pos? a)
    (do (println a)
        (def a (dec a))))
10
9
8
7
6
5
4
3
2
1
nil
</pre>

<div class="rs-box"><p>Poznámka: opìt pova¾uji za vhodné upozornit na to, ¾e
idiomy podobné tìm uvedeným v&nbsp;této kapitole sice mohou být pøi pøestupu
z&nbsp;imperativních programovacích jazykù na <i>Clojure</i> u¾iteèné, ale
pøiná¹í celou øadu problémù, kterým se lze vyhnout.</p></div>



<p><a name="k05"></a></p>
<h2 id="k05">5. Základní operace s kolekcemi</h2>

<p>Koneènì se dostáváme k&nbsp;hlavnímu tématu tohoto èlánku &ndash;
k&nbsp;popisu kolekcí a sekvencí. Základní informace o kolekcích jsme si ji¾
øekli v&nbsp;pøedchozích dílech tohoto seriálu: z&nbsp;pohledu jazyka
<i>Clojure</i> se jedná o seznamy (<i>list</i>), vektory (<i>vector</i>),
mno¾iny (<i>set</i>) a mapy (<i>map</i>). V¹echny ètyøi typy kolekcí mají jednu
spoleènou vlastnost &ndash; jsou toti¾ nemodifikovatelné, tj.&nbsp;je zaruèeno,
¾e se obsah kolekcí nebude pøi bìhu programu nijak mìnit, co¾ zjednodu¹uje
pøístup k&nbsp;prvkùm kolekcí ve chvíli, kdy program bì¾í ve více vláknech.
Naproti tomu napøíklad pole a kolekce pou¾ívané v&nbsp;Javì jsou obecnì
modifikovatelné, tak¾e pro pøístup ke kolekcím ve vícevláknových programech je
nutné pou¾ít nìkterý z&nbsp;dostupných synchronizaèních mechanismù, co¾ je
z&nbsp;implementaèního hlediska pomìrnì slo¾ité, nehledì na to, ¾e pøi ¹patném
návrhu programu mù¾e dojít k&nbsp;dead locku a dal¹ím pro ladìní velmi
&bdquo;pøíjemným&ldquo; stavùm výsledného programu.</p>

<p>Kolekce jsou v&nbsp;programovacím jazyku Clojure dùle¾ité i z&nbsp;jiného
dùvodu &ndash; ve standardní knihovnì tohoto jazyka se toti¾ nachází velké
mno¾ství funkcí a maker pro práci s&nbsp;kolekcemi. Tvùrci <i>LISPu</i> a
z&nbsp;nìho odvozeného jazyka Clojure toti¾ zastávají názor, ¾e je lep¹í
pou¾ívat relativnì malé mno¾ství datových typù a mít pro tyto typy
k&nbsp;dispozici velké mno¾ství obecných funkcí, které je mo¾né vzájemnì
kombinovat. Naproti tomu se v&nbsp;klasickém <i>OOP</i> spí¹e upøednostòuje mít
vìt¹í poèet specializovaných datových typù (tøíd) s&nbsp;relativnì malým
mno¾stvím specializovaných funkcí aplikovatelných na tyto typy (metody). Obecnì
nelze øíci, který pøístup je lep¹í, proto¾e zále¾í na povaze øe¹ené úlohy.
Vra»me se v¹ak k&nbsp;jazyku <i>Clojure</i> a k&nbsp;jeho kolekcím.
V&nbsp;následující tabulce jsou vypsány nìkteré funkce, které lze pøi práci
s&nbsp;kolekcemi pou¾ít. Pov¹imnìte si, ¾e ¾ádná z&nbsp;tìchto funkcí
<strong>nemìní</strong> pùvodní kolekci, maximálnì vrátí jako svùj výsledek
kolekci novou, která ve vìt¹inì pøípadù pou¾ívá stejné prvky, jako kolekce
pùvodní (tím se zamezuje zbyteèným kopiím v&nbsp;pamìti).</p>

<table>
<tr><th> #</th><th>Funkce</th><th>Význam funkce</th></tr>
<tr><td> 1</td><td>count </td><td>vrátí poèet prvkù v kolekci</td></tr>
<tr><td> 2</td><td>empty?</td><td>(<i>s otazníkem na konci</i>) vrátí <strong>true</strong> v&nbsp;pøípadì, ¾e je kolekce prázdná</td></tr>
<tr><td> 3</td><td>empty</td><td>(<i>bez otazníku</i>) vrátí prázdnou kolekci stejného typu</td></tr>
<tr><td> 4</td><td>not-empty</td><td>pokud není parametrem prázdná kolekce, vrátí se tato kolekce, jinak se vrátí <strong>nil</strong></td></tr>
<tr><td> 5</td><td>distinct?</td><td>vrací <strong>true</strong>, pokud se v¹echny prvky kolekce od sebe li¹í</td></tr>
<tr><td> 6</td><td>sequential?</td><td>vrací <strong>true</strong> pro vektory, seznamy a sekvence</td></tr>
<tr><td> 7</td><td>associative?</td><td>vrací <strong>true</strong> pro asociativní typy: vektory (klíèem jsou celá èísla), mapy a struktury</td></tr>
<tr><td> 8</td><td>cons</td><td>vrátí novou kolekci s&nbsp;pøidaným prvkem (odkaz jazyka <i>LISP</i>)</td></tr>
<tr><td> 9</td><td>pop</td><td>vrátí kolekci bez prvního prvku (seznamy) nebo bez prvku posledního (vektory)</td></tr>
<tr><td>10</td><td>peek</td><td>vrátí první prvek (seznam), popø.&nbsp;poslední prvek (vektor)</td></tr>
<tr><td>11</td><td>nth</td><td>získání n-tého prvku kolekce</td></tr>
<tr><td>12</td><td>first</td><td>první prvek kolekce</td></tr>
<tr><td>13</td><td>rest</td><td>kolekce bez prvního prvku</td></tr>
</table>



<p><a name="k06"></a></p>
<h2 id="k06">6. Demonstraèní pøíklady &ndash; práce s&nbsp;kolekcemi</h2>

<p>Uka¾me si nyní nìkolik demonstraèních pøíkladù, na nich¾ je ukázán zpùsob
práce s&nbsp;kolekcemi. Pro jednoduchost si prozatím uká¾eme práci se seznamy a
vektory.</p>

<p>Nejprve vytvoøíme nový seznam a navá¾eme ho na symbol
<strong>seznam</strong>:</p>

<pre>
user=&gt; (def seznam '(1 2 3 4 5 6))
#'user/seznam
</pre>

<p>Takté¾ vytvoøíme nový vektor, který je navázán na symbol
<strong>vektor</strong>:</p>

<pre>
user=&gt; (def vektor ['a' 'b' 'c' 'd' 'e' 'f'])
#'user/vektor
</pre>

<p>Test funkce <strong>count</strong> je velmi jednoduchý:</p>

<pre>
user=&gt; (count seznam)
6
</pre>

<p>Její chování je shodné jak pro seznamy, tak i pro vektory:</p>

<pre>
user=&gt; (count vektor)
6
</pre>

<p>Toté¾ platí pro funkci-predikát <strong>empty?</strong>:</p>

<pre>
user=&gt; (empty? seznam)
false
</pre>

<p>Ta se takté¾ chová stejnì pro seznamy i pro vektory:</p>

<pre>
user=&gt; (empty? vektor)
false
</pre>

<p>Zajímavá je funkce <strong>pop</strong>, která vrátí nový seznam bez
<strong>prvního</strong> prvku:</p>

<pre>
user=&gt; (pop seznam)
(2 3 4 5 6)
</pre>

<p>Ov¹em v&nbsp;pøípadì vektorù se vrátí nový vektor bez prvku
<strong>posledního</strong>:</p>

<pre>
user=&gt; (pop vektor)
[a' b' c' d' e']
</pre>

<p>I chování funkce <strong>peek</strong> je odli¹né u seznamù a vektorù:</p>

<pre>
user=&gt; (peek seznam)
1
</pre>

<pre>
user=&gt; (peek vektor)
f'
</pre>

<p>Funkce <strong>first</strong> odpovídá funkci <strong>car</strong>
z&nbsp;klasického <i>LISPu</i>:</p>

<pre>
user=&gt; (first seznam)
1
</pre>

<pre>
user=&gt; (first vektor)
a'
</pre>

<p>Funkce <strong>rest</strong> odpovídá funkci <strong>cdr</strong>
z&nbsp;klasického <i>LISPu</i>:</p>

<pre>
user=&gt; (rest seznam)
(2 3 4 5 6)
</pre>

<pre>
user=&gt; (rest vektor)
(b' c' d' e' f')
</pre>

<p>Funkce <strong>nth</strong> vrací n-tý prvek, co¾ v¹ak není u seznamù pøíli¹
optimální operace, proto¾e má obecnì slo¾itost <i>O(n)</i>:</p>

<pre>
user=&gt; (nth seznam 4)
5
</pre>

<p>U vektorù je slo¾itost funkce <strong>nth</strong> konstantní,
tj.&nbsp;<i>O(1)</i>:</p>

<pre>
user=&gt; (nth vektor 4)
e'
</pre>

<p>S&nbsp;vyu¾itím funkce <strong>cons</strong> lze vytváøet nové seznamy:</p>

<pre>
user=&gt; (cons 1 seznam)
(1 1 2 3 4 5 6)
</pre>

<p>Popø.&nbsp;i nové vektory:</p>

<pre>
user=&gt; (cons 1 vektor)
(1 a' b' c' d' e' f')
</pre>

<p>Zajímavá vìc se stane, pokud se pøidá celá kolekce do jiné kolekce:</p>

<pre>
user=&gt; (cons seznam vektor)
((1 2 3 4 5 6) a' b' c' d' e' f')
</pre>

<pre>
user=&gt; (cons vektor seznam)
([a' b' c' d' e' f'] 1 2 3 4 5 6)
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Sekvence, lazy sekvence a funkce <strong>range</strong></h2>

<p>S&nbsp;kolekcemi pomìrnì úzce souvisí i takzvané <i>sekvence</i>. Tímto
termínem se v&nbsp;programovacím jazyce Clojure oznaèuje programové rozhraní,
které svými základními mo¾nostmi zhruba odpovídá <i>iterátorùm</i> známým
z&nbsp;programovacího jazyka Java. V&nbsp;Clojure existuje velké mno¾ství
funkcí, které doká¾ou pracovat se sekvencemi, a» ji¾ se jedná o bì¾né sekvence
(jejich¾ prvky jsou pøímo ulo¾eny v&nbsp;pamìti), nebo takzvané líné sekvence
(<i>lazy sekvence</i>), které nové prvky vytváøí èi zji¹»ují a¾ pøi konkrétním
pøístupu na tyto prvky. Mezi tyto funkce patøí napøíklad <strong>sort</strong>,
<strong>sort-by</strong>, <strong>reverse</strong> èi <strong>flatten</strong>.
Díky tomu, ¾e v¹echny kolekce (viz pøedchozí dvì kapitoly) jsou souèasnì i
sekvencemi, lze tyto funkce aplikovat i na kolekce, ov¹em ve skuteènosti jsou
sekvencemi i dal¹í typy objektù &ndash; I/O proudy (je mo¾ná ¹koda, ¾e se tímto
smìrem nevyvinulo API Javy, které je zrovna v&nbsp;pøípadì I/O operací dosti
slo¾ité), øetìzce (co¾ jsou sekvence znakù) atd.</p>

<p>Naprostý základ pro práci se sekvencemi tvoøí trojice funkcí nazvaných
<strong>first</strong>, <strong>rest</strong> a <strong>next</strong>. Funkce
<strong>first</strong> vrací první prvek v&nbsp;sekvenci, popø.&nbsp; speciální
hodnotu <strong>nil</strong> v&nbsp;pøípadì, ¾e je sekvence prázdná. Funkce
<strong>rest</strong> i <strong>next</strong> vrací zbylé prvky
v&nbsp;sekvenci, ov¹em li¹í se tím, jaká hodnota se vrátí ve chvíli, kdy ji¾
v&nbsp;sekvenci nezbyly ¾ádné prvky (kromì prvního). V&nbsp;tomto pøípadì vrátí
<strong>rest</strong> prázdnou sekvenci (napøíklad prázdný seznam), zatímco
funkce <strong>next</strong> vrátí hodnotu <strong>nil</strong>. U bì¾ných
sekvencí, napøíklad seznamù, jsou tyto funkce implementovány pøímoèaøe, ov¹em
v&nbsp;pøípadì <i>lazy sekvencí</i> se prvky vrácené pomocí funkce
<strong>first</strong> vyhodnocují a¾ za bìhu, napøíklad pomocí nìjaké
generátorové funkce. Tímto zpùsobem je mo¾né pracovat i s&nbsp;nekoneènými
sekvencemi, u nich¾ u¾ z&nbsp;principu nelze dopøedu znát celkový poèet prvkù
atd.</p>

<p>Velmi dobrým pøíkladem <i>lazy sekvence</i> je funkce
<strong>range</strong>, která dokonce existuje v&nbsp;nìkolika podobách, je¾ se
od sebe z&nbsp;hlediska programátora-u¾ivatele li¹í pøedev¹ím rùzným poètem
parametrù. Pokud se této funkci nepøedá ¾ádný parametr, vrátí funkce
<strong>range</strong> sekvenci celých èísel od nuly do nekoneèna. Zde je
patrné, proè se musí jednat o lazy sekvenci &ndash; nekoneènou øadu celých
èísel by samozøejmì v&nbsp;pøípadì normální sekvence nebylo mo¾né ulo¾it do
operaèní pamìti. Pokud se funkci <strong>range</strong> pøedá pouze jediný
parametr (kterým musí být celé èíslo &ndash; je kontrolováno v&nbsp;runtime),
je vrácena sekvence celých èísel od <i>0</i> do <i>zadané hodnoty-1</i>. Opìt
se jedná o nefal¹ovanou lazy sekvenci, tak¾e se nemusíte bát pou¾ívat i velké
<i>n</i>. Dále ji¾ následují v&nbsp;podstatì jen kosmetické úpravy &ndash;
volání funkce <strong>range</strong> se dvìma parametry <i>m</i>, <i>n</i>
vytvoøí sekvenci celých èísel od <i>m</i> do <i>n-1</i> a pokud je pou¾it je¹tì
tøetí parametr, urèuje se jím krok, který mù¾e být i záporný. V¹e si uká¾eme na
demonstraèních pøíkladech:</p>

<p>Sekvence od 0 do nekoneèna &ndash; radìji nespou¹tìt, proto¾e se sekvence
musí vyhodnotit ve smyèce <i>REPL</i>:</p>

<pre>
user=&gt; (range)
</pre>

<p>Sekvence od 0 do devíti (asi nejjednodu¹¹í pøíklad reálného pou¾ití funkce
<strong>range</strong>):</p>

<pre>
user=&gt; (range 10)
(0 1 2 3 4 5 6 7 8 9)
</pre>

<p>Nulová hodnota je tolerována:</p>

<pre>
user=&gt; (range 0)
()
</pre>

<p>Záporná hodnota je takté¾ tolerována:</p>

<pre>
user=&gt; (range -10)
()
</pre>

<p>Vrací lazy sekvenci od 10 do 19:</p>

<pre>
user=&gt; (range 10 20)
(10 11 12 13 14 15 16 17 18 19)
</pre>

<p>Podobný pøíklad, ale s&nbsp;krokem 2:</p>

<pre>
user=&gt; (range 10 20 2)
(10 12 14 16 18)
</pre>

<p>Lze pou¾ít i záporný krok:</p>

<pre>
user=&gt; (range 20 10 -1)
(20 19 18 17 16 15 14 13 12 11)
</pre>

<p>...rùzný od 1:</p>

<pre>
user=&gt; (range 20 10 -2)
(20 18 16 14 12)
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Funkce <strong>repeat</strong> a <strong>map</strong></h2>

<p>Kromì funkce <strong>range</strong> popsané v&nbsp;závìru pøedchozí kapitoly
je dal¹í u¾iteènou funkcí i funkce nazvaná <strong>repeat</strong>, která
slou¾í k&nbsp;vytvoøení lazy sekvence a zadané délce. Pokud je funkci
<strong>repeat</strong> pøedán jen jeden parametr, vytváøí nekoneènou lazy
sekvenci, kde se v&nbsp;ka¾dé iteraci vrátí tento parametr (nemusí se ani
jednat o novou instanci, proto¾e parametr je samozøejmì nemìnitelný):</p>

<pre>
(repeat x)
; opakuje x nekonecnekrat dlouho - nejlépe vùbec nespou¹tìt
</pre>

<p>V&nbsp;pøípadì, ¾e se funkci <strong>repeat</strong> pøedají dva parametry,
je první z&nbsp;nich pova¾ován za délku vytváøené sekvence:</p>

<pre>
(repeat 10 42)
(42 42 42 42 42 42 42 42 42 42)
</pre>

<pre>
(repeat 100 "Nesmim v zime olizovat zabradli")
</pre>

<p>Koneènì se dostáváme k&nbsp;zajímavému tématu &ndash; k&nbsp;funkci
<strong>map</strong>. V&nbsp;nejjednodu¹¹ím pøípadì funkce <strong>map</strong>
aplikuje nìjakou jinou funkci na v¹echny prvky nìjaké sekvence a výsledkem této
operace je nová (lazy) sekvence. Sice to mù¾e znít slo¾itì, ale pou¾ití funkce
<strong>map</strong> je ve skuteènosti dosti jednoduché, proto¾e ji¾ víme, ¾e
funkce jsou v&nbsp;Clojure plnohodnotným datovým typem a tudí¾ je lze pøedat
jako parametr jiné funkci.</p>

<p>Aplikace funkce <strong>inc</strong> na ka¾dý prvek sekvence (zde
vektoru):</p>

<pre>
(map inc [1 2 3 4 5 6 7 8])
(2 3 4 5 6 7 8 9)
</pre>

<p>U seznamù si musíme dát pozor na jejich quotování:</p>

<pre>
(map inc '(1 2 3 4 5 6 7 8))
(2 3 4 5 6 7 8 9)
</pre>

<p>Sekvenci lze samozøejmì vytvoøit i pomocí funkcí <strong>range</strong> a
<strong>repeat</strong>:</p>

<pre>
(map inc (range 1 9))
(2 3 4 5 6 7 8 9)
</pre>

<p>Je¹tì zajímavìj¹í je aplikace nìjaké funkce s&nbsp;vìt¹í aritou ne¾ 1 na dvojici, trojici atd. sekvencí:</p>

<pre>
(map * [1 2 3 4] [5 6 7 8])
(5 12 21 32)
</pre>

<p>Dtto se seznamy:</p>

<pre>
(map * '(1 2 3 4) '(5 6 7 8))
(5 12 21 32)
</pre>

<pre>
(map * (range 1 5) (range 5 9))
(5 12 21 32)
</pre>

<p>Hmm, tato èíselná øada se tu¹ím nìjak jmenovala...</p>

<pre>
(map / (range 10) (range 1 10))
(0 1/2 2/3 3/4 4/5 5/6 6/7 7/8 8/9)
</pre>

<p>Samozøejmì lze pou¾ít napøíklad i funkci &bdquo;vìt¹í ne¾&ldquo;:</p>

<pre>
(map &gt; (range 1 10) (range 10 1 -1))
(false false false false false true true true true)
</pre>

<p>Popø.&nbsp;<strong>compare</strong> vracející -1, 0, èi 1:</p>

<pre>
(map compare (range 1 10) (range 10 1 -1))
(-1 -1 -1 -1 -1 1 1 1 1)
</pre>

<p>To v¹ak není zdaleka v¹e!, ov¹em nìkteré mo¾nosti pou¾ití funkce
<strong>map</strong> a podobných funkcí si necháme na dal¹í díl tohoto
seriálu.</p>



<p><a name="k09"></a></p>
<h2 id="k9">9. Odkazy na Internetu</h2>

<ol>

<li>Clojure home page<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/">http://java.sun.com/developer/technicalArticles/DynTypeLang/</a>
</li>

<li>JSR 223: Scripting for the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=223">http://jcp.org/en/jsr/detail?id=223</a>
</li>

<li>JSR 292: Supporting Dynamically Typed Languages on the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=292">http://jcp.org/en/jsr/detail?id=292</a>
</li>

<li>Java 7: A complete invokedynamic example<br />
<a href="http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html">http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html</a>
</li>

<li>InvokeDynamic: Actually Useful?<br />
<a href="http://blog.headius.com/2007/01/invokedynamic-actually-useful.html">http://blog.headius.com/2007/01/invokedynamic-actually-useful.html</a>
</li>

<li>A First Taste of InvokeDynamic<br />
<a href="http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html">http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html</a>
</li>

<li>Java 6 try/finally compilation without jsr/ret<br />
<a href="http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html">http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Root.cz: Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM<br />
<a href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/</a></a>
</li>

<li>Root.cz: JamVM aneb alternativa k HotSpotu nejenom pro embedded zaøízení a chytré telefony<br />
<a href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>FindBugs<br />
<a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a>
</li>

<li>GNU Classpath<br />
<a href="www.gnu.org/s/classpath/">www.gnu.org/s/classpath/</a></li>

<li>Java VMs Compared<br />
<a href="http://bugblogger.com/java-vms-compared-160/">http://bugblogger.com/java-vms-compared-160/</a>
</li>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Scala Programming Language<br />
<a href="http://www.scala-lang.org/">http://www.scala-lang.org/</a>
</li>

<li>Run Scala in Apache Tomcat in 10 minutes<br />
<a href="http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes">http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes</a>
</li>

<li>Fast Web Development With Scala<br />
<a href="http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html">http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html</a>
</li>

<li>Top five scripting languages on the JVM<br />
<a href="http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855">http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>CloseableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html">http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

