<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - sledování ètení i zápisu do vybraného atributu tøídy èi atributu objektu</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - sledování ètení i zápisu do vybraného atributu tøídy èi atributu objektu</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o vlastnostech JVM si uká¾eme, jakým zpùsobem mù¾e být pou¾it JVM TI agent pro sledování ètení èi zápisu do vybraného atributu tøídy èi atributu objektu. Rozhraní JVM TI nám toti¾ dává k dispozici callback funkce zavolané ve chvíli, kdy libovolné vlákno k oznaèeným (vybraným) atributùm pøistupuje.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Callback funkce zavolaná pøi naèítání tøídy do virtuálního stroje Javy</a></p>
<p><a href="#k02">2. Callback funkce zavolaná po inicializaci tøídy</a></p>
<p><a href="#k03">3. Demonstraèní agent èíslo 27 &ndash; výpis v¹ech naèítaných a inicializovaných tøíd</a></p>
<p><a href="#k04">4. Výsledek bìhu demonstraèního agenta èíslo 27</a></p>
<p><a href="#k05">5. Sledování pøístupu (ètení, zápis) k&nbsp;vybranému atributu</a></p>
<p><a href="#k06">6. Nastavení po¾adovaných vlastností JVM TI agenta</a></p>
<p><a href="#k07">7. Nastavení re¾imù notifikace a registrace callback funkcí</a></p>
<p><a href="#k08">8. Demonstraèní agent èíslo 28 &ndash; jednoduchá detekce pøístupu k&nbsp;atributu tøídy Test28</a></p>
<p><a href="#k09">9. Výsledek bìhu demonstraèního agenta èíslo 28</a></p>
<p><a href="#k10">10. Zdrojové kódy obou demonstraèních agentù a k&nbsp;nim pøíslu¹ných testovacích pøíkladù</a></p>
<p><a href="#k11">11. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Callback funkce zavolaná pøi naèítání tøídy do virtuálního stroje Javy</h2>

<p>V&nbsp;pøedchozí èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyce Java i o vlastnostech virtuálního stroje Javy</a> jsme si
vysvìtlili èinnost demonstraèního <i>JVM TI</i> agenta, který pro vybranou
tøídu dokázal vypsat v¹echny atributy, vèetnì jejich typu a pøípadných
modifikátorù. Dnes postoupíme ponìkud dále, proto¾e si uká¾eme, jak je mo¾né
sledovat v¹echny operace ètení a pøedev¹ím pak zápisu do vybraného atributu, a»
ji¾ se jedná o tøídní atribut (statický) èi o atribut objektu (nestatický).
Nejprve si v¹ak musíme popsat je¹tì jednu funkcionalitu nabízenou rozhraním
<i>JVM TI</i>, která se týká mo¾ností sledování naèítání a inicializace tøíd ve
virtuálním stroji Javy. Jeden z&nbsp;problémù se sledováním pøístupu
k&nbsp;atributùm toti¾ spoèívá v&nbsp;tom, <strong>kdy</strong> pøesnì je mo¾né
zaregistrovat callback funkce zavolané ve chvíli, kdy je atribut èten nebo je
do nìj zapisována nová hodnota.</p>

<p>Nejjednodu¹¹í je provést registraci ve chvíli, kdy je pøíslu¹ná tøída (její¾
atribut/atributy se mají sledovat) naètena do virtuálního stroje Javy. Ve
skuteènosti se jedná o dvoufázovou èinnost, alespoò z&nbsp;hlediska <i>JVM
TI</i> agenta. Mù¾eme zachytit okam¾ik, kdy je tøída skuteènì teprve naèítána,
ale je¹tì se neprovádí její inicializace. V&nbsp;tomto okam¾iku je napøíklad
mo¾né provést takzvanou retransformaci tøídy, tj.&nbsp;napøíklad zmìnu bajtkódu
jednotlivých metod atd. Retransformace je pomìrnì èasto pou¾ívána napøíklad
tehdy, pokud je zapotøebí sledovat vstupy a výstupy z&nbsp;vybraných metod,
proto¾e pou¾ití obecných sledovacích nástrojù zalo¾ených na callback funkcích
<strong>MethodEntry()</strong> a <strong>MethodExit()</strong> vede
k&nbsp;velké degradaci výpoèetního výkonu celého sledovaného virtuálního stroje
Javy. Vra»me se v¹ak k&nbsp;okam¾iku, kdy je tøída naèítána do virtuálního
stroje Javy. Tento okam¾ik je mo¾né pro ka¾dou naèítanou tøídu jednodu¹e
detekovat; postaèuje pouze nastavit vhodný re¾im notifikace:</p>

<pre>
<i>    /* Udalost pri nacitani tridy. */</i>
    if ((error_code = set_event_notification_mode(jvmti, JVMTI_EVENT_CLASS_LOAD)) != JNI_OK)
    {
        return error_code;
    }
</pre>

<p>A následnì zaregistrovat callback funkci
<strong>ClassLoad()</strong>v&nbsp;datové struktuøe
<strong>jvmtiEventCallbacks</strong>. Volaná callback funkce musí mít
následující hlavièku:</p>

<pre>
<i>/*</i>
<i> * Callback funkce zavolana pri nacitani tridy do virtualniho stroje.</i>
<i> */</i>
static void JNICALL <strong>callback_on_class_load</strong>(
        jvmtiEnv *jvmti_env,
        JNIEnv   *jni_env,
        jthread   thread,
        jclass    class)
</pre>

<p><ins>Poznámka: pro sledování naèítání tøíd do JVM není zapotøebí nastavovat
¾ádné speciální schopnosti <i>JVM TI</i> agenta, tj.&nbsp;nemusí se mìnit obsah
struktury <strong>jvmtiCapabilities</strong>.</ins></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Callback funkce zavolaná po inicializaci tøídy</h2>

<p>Callback funkce <strong>callback_on_class_load()</strong> popsaná <a
href="#k01">v&nbsp;pøedchozí kapitole</a> je volána je¹tì pøedtím, ne¾ je tøída
korektnì inicializována, zpracována a ulo¾ena do pøíslu¹né pamì»ové oblasti
virtuálního stroje Javy. To s&nbsp;sebou pøiná¹í klady, ale samozøejmì i
zápory. Mezi klady patøí ji¾ zmínìná mo¾nost retransformace tøídy èi libovolné
úpravy tøídy pøed jejím dal¹ím standardním zpracováním. Mezi zápory pak patøí
pøedev¹ím fakt, ¾e se o tøídì v&nbsp;daném okam¾iku dá získat jen velmi málo
informací standardními prostøedky &ndash; mù¾eme napøíklad získat signaturu
tøídy, ale ji¾ ne její metody a atributy. Z&nbsp;tohoto dùvodu by pro nás bylo
vhodnìj¹í zachytit spí¹e okam¾ik, kdy je ji¾ tøída korektnì inicializována a
kdy ji¾ mù¾eme získat seznam jejich atributù. I tuto funkcionalitu nám rozhraní
<i>JVM TI</i> samozøejmì nabízí; konkrétnì se jedná o callback funkci
pojmenovanou v&nbsp;datové struktuøe <strong>jvmtiEventCallbacks</strong>
<strong>ClassPrepare()</strong>. Zajímavé je, ¾e tato callback funkce má zcela
stejnou hlavièku, jako callback funkce <strong>ClassLoad()</strong>:</p>

<pre>
<i>/*</i>
<i> * Callback funkce zavolana ve chvili, kdy je trida ve virtualnim stroji ve stavu,</i>
<i> * kdy ji lze normalne pouzivat.</i>
<i> */</i>
static void JNICALL <strong>callback_on_class_prepare</strong>(
        jvmtiEnv *jvmti_env,
        JNIEnv   *jni_env,
        jthread   thread,
        jclass    class)
{
}
</pre>

<p>Ani pro zavolání této callback funkce není zapotøebí nastavovat ¾ádnou
speciální schopnost <i>JVM TI</i> agenta, tj.&nbsp;nemusí se mìnit obsah
struktury <strong>jvmtiCapabilities</strong>.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Demonstraèní agent èíslo 27 &ndash; výpis v¹ech naèítaných a inicializovaných tøíd</h2>

<p>Obì události popsané v&nbsp;pøedchozích dvou kapitolách budou vyu¾ity
v&nbsp;dne¹ním prvním demonstraèním <i>JVM TI</i> agentovi, který na standardní
výstup postupnì vypí¹e v¹echny tøídy naèítané do virtuálního stroje Javy i
tøídy skuteènì inicializované (oba dva seznamy tøíd by samozøejmì mìly být
shodné). V&nbsp;dal¹ích odstavcích budou popsány nejzajímavìj¹í funkce
implementované v&nbsp;<i>JVM TI</i> agentovi.</p>

<p>Nejprve je nutné nastavit nové re¾imy notifikace, co¾ se provádí ve funkci
<strong>set_event_notification_modes()</strong>. V&nbsp;agentovi budou
zachytávány ètyøi typy událostí &ndash; inicializace virtuálního stroje Javy,
ukonèení práce virtuálního stroje Javy, naètení tøídy a inicializace tøídy
&ndash; z&nbsp;nich¾ ka¾dá má pøiøazen vlastní re¾im notifikace:</p>

<pre>
<i>/*</i>
<i> * Nastaveni udalosti, pro nez se maji zavolat callback funkce.</i>
<i> */</i>
jvmtiError <strong>set_event_notification_modes</strong>(jvmtiEnv *jvmti)
{
    jvmtiError error_code;
&nbsp;
<i>    /* Potrebujeme zachytavat udalost inicializace virtualniho stroje. */</i>
    if ((error_code = set_event_notification_mode(jvmti, JVMTI_EVENT_VM_INIT)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
<i>    /* Potrebujeme zachytavat udalost ukonceni prace virtualniho stroje. */</i>
    if ((error_code = set_event_notification_mode(jvmti, JVMTI_EVENT_VM_DEATH)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
<i>    /* Udalost pri nacitani tridy. */</i>
    if ((error_code = set_event_notification_mode(jvmti, JVMTI_EVENT_CLASS_LOAD)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
<i>    /* Udalost pri priprave tridy ve virtualnim stroji. */</i>
    if ((error_code = set_event_notification_mode(jvmti, JVMTI_EVENT_CLASS_PREPARE)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
    return error_code;
}
</pre>

<p>Dále je nutné v&nbsp;datové struktuøe <strong>jvmtiEventCallbacks</strong>
nastavit ukazatele na v¹echny ètyøi callback funkce (inicializace JVM, ukonèení
práce JVM, naètení tøídy, inicializace tøídy). To se provede ve funkci
<strong>register_all_callback_functions()</strong>:</p>

<pre>
<i>/*</i>
<i> * Registrace ctyr callback funkci zavolanych virtualnim strojem Javy.</i>
<i> */</i>
jvmtiError <strong>register_all_callback_functions</strong>(jvmtiEnv *jvmti)
{
    jvmtiEventCallbacks callbacks;
    jvmtiError error_code;
&nbsp;
    memset(&amp;callbacks, 0, sizeof(callbacks));
&nbsp;
    <i>/* JVMTI_EVENT_VM_INIT */</i>
    callbacks.VMInit = &amp;callback_on_vm_init;
&nbsp;
    <i>/* JVMTI_EVENT_VM_DEATH */</i>
    callbacks.VMDeath = &amp;callback_on_vm_death;
&nbsp;
    <i>/* JVMTI_EVENT_CLASS_LOAD */</i>
    callbacks.ClassLoad = &amp;callback_on_class_load;
&nbsp;
    <i>/* JVMTI_ENABLE, JVMTI_EVENT_CLASS_PREPARE */</i>
    callbacks.ClassPrepare = &amp;callback_on_class_prepare;
&nbsp;
    error_code = (*jvmti)-&gt;SetEventCallbacks(jvmti, &amp;callbacks, (jint)sizeof(callbacks));
    check_jvmti_error(jvmti, error_code, "Cannot set JVM TI callbacks");
    return error_code;
}
</pre>

<p>Callback funkce zavolaná pøi naètení ka¾dé tøídy je internì velmi jednoduchá
&ndash; pouze se v&nbsp;kritické sekci zavolá u¾ivatelská funkce
<strong>print_class_name()</strong>:</p>

<pre>
<i>/*</i>
<i> * Callback funkce zavolana pri nacitani tridy do virtualniho stroje.</i>
<i> */</i>
static void JNICALL <strong>callback_on_class_load</strong>(
        jvmtiEnv *jvmti_env,
        JNIEnv   *jni_env,
        jthread   thread,
        jclass    class)
{
    enter_critical_section(jvmti_env);
    printf("Class load:   ");
    print_class_name(jvmti_env, class);
    exit_critical_section(jvmti_env);
}
</pre>

<p>To stejné platí pro callback funkci zavolanou ve chvíli inicializace
tøídy:</p>

<pre>
<i>/*</i>
<i> * Callback funkce zavolana ve chvili, kdy je trida ve virtualnim stroji ve stavu,</i>
<i> * kdy ji lze normalne pouzivat.</i>
<i> */</i>
static void JNICALL <strong>callback_on_class_prepare</strong>(
        jvmtiEnv *jvmti_env,
        JNIEnv   *jni_env,
        jthread   thread,
        jclass    class)
{
    enter_critical_section(jvmti_env);
    printf("Class prepare:");
    print_class_name(jvmti_env, class);
    exit_critical_section(jvmti_env);
}
</pre>

<p>Pomocná u¾ivatelská funkce <strong>print_class_name()</strong> získá
signaturu tøídy (ta existuje v&nbsp;obou pøípadech, tj.&nbsp;ji¾ pøi naètení
tøídy) a následnì tuto signaturu upraví do èitelnìj¹ího tvaru, který je
následnì vyti¹tìn na standardní výstup:</p>

<pre>
<i>/*</i>
<i> * Vypise jmeno tridy pro zadany jclass</i>
<i> */</i>
void <strong>print_class_name</strong>(jvmtiEnv *jvmti_env, jclass class)
{
    jvmtiError error;
    char *class_name_ptr;
    char *updated_class_name_ptr;
&nbsp;
    <i>/* ziskat jmeno tridy */</i>
    error = (*jvmti_env)-&gt;GetClassSignature(jvmti_env, class, &amp;class_name_ptr, NULL);
    check_jvmti_error(jvmti_env, error, "get class signature");
    if (class_name_ptr == NULL)
    {
        puts("Error: class has no signature");
    }
&nbsp;
    <i>/* upravit jmeno tridy */</i>
    updated_class_name_ptr = update_class_name(class_name_ptr, ';');
&nbsp;
    <i>/* tisk upraveneho jmena tridy */</i>
    puts(updated_class_name_ptr);
&nbsp;
    <i>/* dealokace pameti po GetClassSignature() */</i>
    error = (*jvmti_env)-&gt;Deallocate(jvmti_env, (unsigned char *)class_name_ptr);
    check_jvmti_error(jvmti_env, error, "deallocate class name");
}
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Výsledek bìhu demonstraèního agenta èíslo 27</h2>

<p>Demonstraèní agent popsaný vý¹e se pøelo¾í stejným zpùsobem, jako ji¾ døíve
popsaní agenti:</p>

<pre>
gcc -Wall -ansi -I/usr/lib/jvm/java-1.6.0-openjdk/include/ -shared -o libagent27.so agent27.c
</pre>

<p>Spu¹tìní virtuálního stroje Javy spoleènì s&nbsp;<i>JVM TI</i> agentem je
zaji¹tìno pøíkazem:</p>

<pre>
java -agentpath:./libagent27.so Test27 2&gt; /dev/null
</pre>

<p>Po spu¹tìní agent na standardní výstup vypí¹e v¹echny naèítané i
inicializované tøídy. Ve výpisu je zvýraznìna testovací tøída
<strong>Test27</strong>, která je samozøejmì takté¾ naètena, proto¾e a¾ poté
mù¾e být nalezena a spu¹tìna její metoda <strong>public static void
main(String[] args)</strong>:</p>

<pre>
Agent27: Agent_OnLoad
Agent27: JVM TI version is correct
Agent27: Got VM init event
Class load:   java.lang.System;
Class load:   java.nio.charset.Charset;
Class load:   java.lang.String;
Class prepare:java.lang.ClassNotFoundException;
Class load:   java.net.URLClassLoader$1;
Class prepare:java.net.URLClassLoader$1;
Class load:   sun.misc.URLClassPath$3;
Class prepare:sun.misc.URLClassPath$3;
Class load:   sun.misc.URLClassPath$Loader;
Class load:   sun.misc.URLClassPath$JarLoader;
Class prepare:sun.misc.URLClassPath$Loader;
Class prepare:sun.misc.URLClassPath$JarLoader;
Class prepare:java.lang.StringBuffer;
Class prepare:java.lang.Short;
Class load:   sun.misc.URLClassPath$JarLoader$1;
Class prepare:sun.misc.URLClassPath$JarLoader$1;
Class load:   sun.misc.FileURLMapper;
Class prepare:sun.misc.FileURLMapper;
Class load:   java.util.zip.ZipConstants;
Class load:   java.util.zip.ZipFile;
Class load:   java.util.jar.JarFile;
Class prepare:java.util.zip.ZipConstants;
Class prepare:java.util.zip.ZipFile;
Class prepare:java.util.jar.JarFile;
Class load:   sun.misc.JavaUtilJarAccess;
Class load:   java.util.jar.JavaUtilJarAccessImpl;
Class prepare:sun.misc.JavaUtilJarAccess;
Class prepare:java.util.jar.JavaUtilJarAccessImpl;
Class load:   sun.misc.JarIndex;
Class prepare:sun.misc.JarIndex;
Class load:   sun.misc.ExtensionDependency;
Class prepare:sun.misc.ExtensionDependency;
Class load:   java.util.zip.ZipEntry;
Class prepare:java.util.zip.ZipEntry;
Class load:   java.util.jar.JarEntry;
Class load:   java.util.jar.JarFile$JarFileEntry;
Class prepare:java.util.jar.JarEntry;
Class prepare:java.util.jar.JarFile$JarFileEntry;
Class load:   java.io.DataInput;
Class load:   java.io.DataInputStream;
Class prepare:java.io.DataInput;
Class prepare:java.io.DataInputStream;
Class load:   java.util.zip.ZipFile$ZipFileInputStream;
Class prepare:java.util.zip.ZipFile$ZipFileInputStream;
Class load:   java.security.PrivilegedActionException;
Class prepare:java.security.PrivilegedActionException;
Class load:   sun.misc.URLClassPath$FileLoader;
Class prepare:sun.misc.URLClassPath$FileLoader;
Class load:   sun.misc.Resource;
Class load:   sun.misc.URLClassPath$FileLoader$1;
Class prepare:sun.misc.Resource;
Class prepare:sun.misc.URLClassPath$FileLoader$1;
Class load:   sun.nio.ByteBuffered;
Class load:   java.security.CodeSource;
Class prepare:java.security.CodeSource;
Class load:   java.security.PermissionCollection;
Class load:   java.security.Permissions;
Class prepare:java.security.PermissionCollection;
Class prepare:java.security.Permissions;
Class load:   java.net.URLConnection;
Class load:   sun.net.www.URLConnection;
Class load:   sun.net.www.protocol.file.FileURLConnection;
Class prepare:java.net.URLConnection;
Class prepare:sun.net.www.URLConnection;
Class prepare:sun.net.www.protocol.file.FileURLConnection;
Class load:   java.net.ContentHandler;
Class load:   java.net.UnknownContentHandler;
Class prepare:java.net.ContentHandler;
Class prepare:java.net.UnknownContentHandler;
Class load:   sun.net.www.MessageHeader;
Class prepare:sun.net.www.MessageHeader;
Class load:   java.io.FilePermission;
Class prepare:java.io.FilePermission;
Class load:   java.io.FilePermission$1;
Class prepare:java.io.FilePermission$1;
Class load:   java.security.Policy;
Class load:   sun.security.provider.PolicyFile;
Class prepare:java.security.Policy;
Class prepare:sun.security.provider.PolicyFile;
Class load:   java.security.Policy$UnsupportedEmptyCollection;
Class prepare:java.security.Policy$UnsupportedEmptyCollection;
Class load:   java.io.FilePermissionCollection;
Class prepare:java.io.FilePermissionCollection;
Class load:   java.security.AllPermission;
Class load:   java.security.UnresolvedPermission;
Class load:   java.security.BasicPermissionCollection;
Class prepare:java.security.BasicPermissionCollection;
Class prepare:java.security.ProtectionDomain;
Class load:   sun.misc.JavaSecurityProtectionDomainAccess;
Class load:   java.security.ProtectionDomain$2;
Class prepare:sun.misc.JavaSecurityProtectionDomainAccess;
Class prepare:java.security.ProtectionDomain$2;
Class load:   java.security.ProtectionDomain$Key;
Class prepare:java.security.ProtectionDomain$Key;
Class load:   java.security.Principal;
Class load:   java.security.cert.Certificate;
Class load:   java.lang.Object;
<strong>Class load:   Test27;</strong>
<strong>Class prepare:Test27;</strong>
Class load:   java.util.ArrayList$Itr;
Class prepare:java.util.ArrayList$Itr;
Class load:   java.util.IdentityHashMap$KeySet;
Class prepare:java.util.IdentityHashMap$KeySet;
Class load:   java.util.IdentityHashMap$IdentityHashMapIterator;
Class load:   java.util.IdentityHashMap$KeyIterator;
Class prepare:java.util.IdentityHashMap$IdentityHashMapIterator;
Class prepare:java.util.IdentityHashMap$KeyIterator;
Class load:   java.io.DeleteOnExitHook;
Class prepare:java.io.DeleteOnExitHook;
Class load:   java.util.LinkedHashSet;
Class prepare:java.util.LinkedHashSet;
Class load:   java.util.HashMap$KeySet;
Class prepare:java.util.HashMap$KeySet;
Class load:   java.util.LinkedHashMap$LinkedHashIterator;
Class load:   java.util.LinkedHashMap$KeyIterator;
Class prepare:java.util.LinkedHashMap$LinkedHashIterator;
Class prepare:java.util.LinkedHashMap$KeyIterator;
Class load:   java.util.Collections;
Class prepare:java.util.Collections;
Class load:   java.util.Collections$EmptySet;
Class prepare:java.util.Collections$EmptySet;
Class load:   java.util.Collections$EmptyList;
Class prepare:java.util.Collections$EmptyList;
Class load:   java.util.Collections$EmptyMap;
Class prepare:java.util.Collections$EmptyMap;
Agent27: Got VM Death event
Agent27: Agent_OnUnload
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Sledování pøístupu (ètení, zápis) k&nbsp;vybranému atributu</h2>

<p>V&nbsp;dal¹ím demonstraèním <i>JVM TI</i> agentovi, jeho¾ konstrukci si
postupnì popí¹eme v&nbsp;následujících ètyøech kapitolách, budeme chtít vypsat
v¹echny operace ètení a zápisu do atributu <strong>i</strong> definovaného ve
tøídì <strong>Test28</strong>. Jedná se o nestatický atribut, co¾ znamená, ¾e
v&nbsp;pamìti bude ulo¾en spoleènì s&nbsp;ka¾dou instancí tøídy
<strong>Test28</strong>. K&nbsp;atributu se pøistupuje pøedev¹ím v&nbsp;metodì
<strong>run()</strong>, kde je na nìkterých øádcích vidìt, ¾e se provádí
souèasné ètení staré hodnoty i zápis hodnoty nové:</p>

<pre>
<i>/**</i>
<i>  * Testovaci trida pouzita pro test dvacateho</i>
<i>  * osmeho demonstracniho JVM TI agenta.</i>
<i>  */</i>
public class Test28 {
    int i;
&nbsp;
    public void run() {
        i = 10;
        i = i+1;
        i--;
        i *= 2;
        ++i;
    }
&nbsp;
    <i>/**</i>
    <i>  * Spusteni testu.</i>
    <i>  */</i>
    public static void main(String[] args) {
        new Test28().run();
    }
}
</pre>

<p>(ètenáøùm tohoto seriálu asi nemá smysl popisovat, ¾e pøíkaz
<strong>++i;</strong> znamená pøeètení a souèasnì i zápis nové hodnoty do
atributu <strong>i</strong>)</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Nastavení po¾adovaných vlastností JVM TI agenta</h2>

<p>První vìcí, kterou musíme ve vytváøeném demonstraèním <i>JVM TI</i> agentovi
implementovat, je nastavení nových po¾adovaných schopností agenta. Aby bylo
mo¾né detekovat ètení i zápis do libovolného atributu, musí být v&nbsp;datové
struktuøe <strong>jvmtiCapabilities</strong> nastaveny polo¾ky
<strong>can_generate_field_access_events</strong> (ètení) a
<strong>can_generate_field_modification_events</strong> (modifikace=zápis).
Toto nastavení se provede v&nbsp;u¾ivatelské funkci
<strong>set_capabilities()</strong>, samozøejmì s&nbsp;testem, zda daný
virtuální stroj Javy tuto funkcionalitu skuteènì podporuje:</p>

<pre>
<i>/*</i>
<i> * Nastaveni pozadovanych schopnosti agenta.</i>
<i> */</i>
jvmtiError <strong>set_capabilities</strong>(jvmtiEnv *jvmti)
{
    jvmtiCapabilities capabilities;
    jvmtiError error_code;
&nbsp;
    memset(&amp;capabilities, 0, sizeof(jvmtiCapabilities));
&nbsp;
    <i>/* vyuzivame dve specialni schopnosti agenta */</i>
    capabilities.can_generate_field_access_events = 1;
    capabilities.can_generate_field_modification_events = 1;
&nbsp;
    error_code = (*jvmti)-&gt;AddCapabilities(jvmti, &amp;capabilities);
    check_jvmti_error(jvmti, error_code, "Unable to get necessary JVMTI capabilities.");
    return error_code;
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Nastavení re¾imù notifikace a registrace callback funkcí</h2>

<p>Dále je nutné vhodnì nastavit re¾imy notifikace, co¾ se v&nbsp;na¹ich
demonstraèních <i>JVM TI</i> agentech ji¾ tradiènì provádí v&nbsp;u¾ivatelské
funkci <strong>set_event_notification_modes()</strong>. Ke dvìma ji¾
existujícím re¾imùm notifikace je pøidána dal¹í dvojice &ndash;
<strong>JVMTI_EVENT_FIELD_ACCESS</strong> a
<strong>JVMTI_EVENT_FIELD_MODIFICATION</strong>:</p>

<pre>
<i>/*</i>
<i> * Nastaveni udalosti, pro nez se maji zavolat callback funkce.</i>
<i> */</i>
jvmtiError <strong>set_event_notification_modes</strong>(jvmtiEnv *jvmti)
{
    jvmtiError error_code;
&nbsp;
    <i>/* Potrebujeme zachytavat udalost inicializace virtualniho stroje. */</i>
    if ((error_code = set_event_notification_mode(jvmti, JVMTI_EVENT_VM_INIT)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
    <i>/* Potrebujeme zachytavat udalost ukonceni prace virtualniho stroje. */</i>
    if ((error_code = set_event_notification_mode(jvmti, JVMTI_EVENT_VM_DEATH)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
    <i>/* Udalost pri priprave tridy ve virtualnim stroji. */</i>
    if ((error_code = set_event_notification_mode(jvmti, JVMTI_EVENT_CLASS_PREPARE)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
    <i>/* Udalost pri pristupu k atributu. */</i>
    if ((error_code = set_event_notification_mode(jvmti, JVMTI_EVENT_FIELD_ACCESS)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
    <i>/* Udalost pri modifikaci atributu. */</i>
    if ((error_code = set_event_notification_mode(jvmti, JVMTI_EVENT_FIELD_MODIFICATION)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
    return error_code;
}
</pre>

<p>Posléze musíme zaregistrovat celkem pìt callback funkcí. Ke dvìma známým
callback funkcím (inicializace a konec práce JVM) se pøidává callback funkce
zavolaná po instalaci ka¾dé tøídy (<strong>ClassPrepare</strong>), callback
funkce zavolaná pøi pøístupu k&nbsp;atributu (<strong>FieldAccess</strong>) a
koneènì callback funkce zavolaná pøi zmìnì hodnoty atributu
(<strong>FieldModification</strong>):</p>

<pre>
<i>/*</i>
<i> * Registrace peti callback funkci zavolanych virtualnim strojem javy.</i>
<i> */</i>
jvmtiError <strong>register_all_callback_functions</strong>(jvmtiEnv *jvmti)
{
    jvmtiEventCallbacks callbacks;
    jvmtiError error_code;
&nbsp;
    memset(&amp;callbacks, 0, sizeof(callbacks));
&nbsp;
    <i>/* JVMTI_EVENT_VM_INIT */</i>
    callbacks.VMInit = &amp;callback_on_vm_init;
&nbsp;
    <i>/* JVMTI_EVENT_VM_DEATH */</i>
    callbacks.VMDeath = &amp;callback_on_vm_death;
&nbsp;
    <i>/* JVMTI_EVENT_CLASS_PREPARE */</i>
    callbacks.ClassPrepare = &amp;callback_on_class_prepare;
&nbsp;
    <i>/* JVMTI_EVENT_FIELD_ACCESS */</i>
    callbacks.FieldAccess = &amp;callback_on_field_access;
&nbsp;
    <i>/* JVMTI_EVENT_FIELD_MODIFICATION */</i>
    callbacks.FieldModification = &amp;callback_on_field_modification;
&nbsp;
    error_code = (*jvmti)-&gt;SetEventCallbacks(jvmti, &amp;callbacks, (jint)sizeof(callbacks));
    check_jvmti_error(jvmti, error_code, "Cannot set JVM TI callbacks");
    return error_code;
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Demonstraèní agent èíslo 28 &ndash; jednoduchá detekce pøístupu k&nbsp;atributu tøídy Test28</h2>

<p>Callback funkce zavolaná pøi pøístupu k&nbsp;oznaèenému atributu je prozatím
velmi jednoduchá, proto¾e obsahuje pouze hlá¹ení vypisované na standardní
výstup. Vylep¹ení této funkce si uká¾eme a¾ pøí¹tì:</p>

<pre>
<i>/*</i>
<i> * Callback funkce zavolana pri pristupu (cteni) vybranych atributu</i>
<i> */</i>
static void JNICALL <strong>callback_on_field_access</strong>(
        jvmtiEnv  *jvmti_env,
        JNIEnv    *jni_env,
        jthread    thread,
        jmethodID  method,
        jlocation  location,
        jclass     class,
        jobject    object,
        jfieldID   field)
{
    <i>/* prozatim bude telo monitoru takto jednoduche */</i>
    MSG("Field access");
}
</pre>

<p>Callback funkce volaná pøi zmìnì hodnoty atributu má prvních osm parametrù
shodných z&nbsp;pøedchozí callback funkcí
<strong>callback_on_field_access()</strong>, ov¹em pøidávají se dva nové
parametry. Pøedev¹ím poslední parametr je zajímavý, proto¾e nese informaci o
nové hodnotì, která se má do atributu pøiøadit. My si práci ponìkud
zjednodu¹íme, proto¾e víme, ¾e monitorovaný atribut <strong>i</strong> je typu
<strong>int</strong>, tudí¾ pøímo, bez dal¹ích zkoumání budeme vypisovat
hodnotu ulo¾enou v&nbsp;<strong>jvalue.i</strong>:</p>

<pre>
<i>/*</i>
<i> * Callback funkce zavolana pri zapisu vybranych atributu</i>
<i> */</i>
static void JNICALL <strong>callback_on_field_modification</strong>(
        jvmtiEnv *jvmti_env,
        JNIEnv   *jni_env,
        jthread   thread,
        jmethodID method,
        jlocation location,
        jclass    class,
        jobject   object,
        jfieldID  field,
        char signature_type,
        jvalue new_value)
{
    <i>/* prozatim vypiseme pouze novou hodnotu zapisovanou do atributu */</i>
    int value = (int)<strong>new_value.i</strong>;
    printf("i := %d\n", value);
}
</pre>

<p>Aby se tyto dvì callback funkce skuteènì zavolaly pøi ka¾dém pøístupu
k&nbsp;atributu <strong>Test28.i</strong>, musíme pro tento atribut callback
funkce zaregistrovat s&nbsp;vyu¾itím <i>JVM TI</i> funkcí
<strong>SetFieldAccessWatch()</strong> a
<strong>SetFieldModificationWatch()</strong>. Udìláme to prozatím velmi
primitivním zpùsobem &ndash; ve chvíli, kdy je naèítána tøída se jménem
<strong>Test28</strong> se pro jistotu pro v¹echny její atributy (bude ov¹em
existovat je jeden) tyto dvì registraèní funkce zavolají. Podívejte se, jak je
to udìláno:</p>

<pre>
<i>/*</i>
<i> * Callback funkce zavolana ve chvili, kdy je trida ve virtualnim stroji ve stavu,</i>
<i> * kdy ji lze normalne pouzivat.</i>
<i> */</i>
static void JNICALL <strong>callback_on_class_prepare</strong>(
        jvmtiEnv *jvmti_env,
        JNIEnv   *jni_env,
        jthread   thread,
        jclass    class)
{
    jvmtiError error;
    char *class_name_ptr;
    char *updated_class_name_ptr;
&nbsp;
    enter_critical_section(jvmti_env);
&nbsp;
    <i>/* ziskat jmeno tridy */</i>
    error = (*jvmti_env)-&gt;GetClassSignature(jvmti_env, class, &amp;class_name_ptr, NULL);
    check_jvmti_error(jvmti_env, error, "get class signature");
    if (class_name_ptr == NULL)
    {
        puts("Error: class has no signature");
    }
&nbsp;
    <i>/* upravit jmeno tridy */</i>
    updated_class_name_ptr = update_class_name(class_name_ptr, ';');
&nbsp;
    <i>/* pokud jsme nasli to pravou tridu */</i>
    if (strcmp(updated_class_name_ptr, TEST_CLASS_NAME) == 0)
    {
        puts("Class "TEST_CLASS_NAME" prepared, setting field monitor");
        prepare_field_monitor(jvmti_env, class);
    }
&nbsp;
    <i>/* dealokace pameti po GetClassSignature() */</i>
    error = (*jvmti_env)-&gt;Deallocate(jvmti_env, (unsigned char *)class_name_ptr);
    check_jvmti_error(jvmti_env, error, "deallocate class name");
    exit_critical_section(jvmti_env);
}
</pre>

<p>Pøi pohledu na funkci <strong>callback_on_class_prepare()</strong> je
patrné, ¾e ve chvíli, kdy je naèítána tøída, její¾ jméno je ulo¾eno
v&nbsp;symbolické konstantì <strong>TEST_CLASS_NAME</strong>, je pro tuto tøídu
zavolána funkce <strong>prepare_field_monitor()</strong>:</p>

<pre>
<i>/*</i>
<i> * Registrace monitoru pro vsechny atributy vybrane tridy.</i>
<i> */</i>
void <strong>prepare_field_monitor</strong>(jvmtiEnv *jvmti_env, jclass class)
{
    jvmtiError error;
    int        field_count;
    jfieldID  *fields_array;
&nbsp;
    <i>/* precist vsechny atributy tridy */</i>
    error = (*jvmti_env)-&gt;GetClassFields(jvmti_env, class, &amp;field_count, &amp;fields_array);
    check_jvmti_error(jvmti_env, error, "get class fields");
&nbsp;
    <i>/* pole atributu bylo inicializovano */</i>
    if (error == JVMTI_ERROR_NONE)
    {
        int i;
        <i>/* projit vsemi atributy a nastavit monitory */</i>
        for (i = 0; i &lt; field_count; i++)
        {
            jfieldID field = fields_array[i];
            printf("Setting monitors for field #%ld\n", (long)field);
&nbsp;
            error = (*jvmti_env)-&gt;SetFieldModificationWatch(jvmti_env, class, field);
            check_jvmti_error(jvmti_env, error, "SetFieldModificationWatch");
&nbsp;
            error = (*jvmti_env)-&gt;SetFieldAccessWatch(jvmti_env, class, field);
            check_jvmti_error(jvmti_env, error, "SetFieldAccessWatch");
        }
    }
&nbsp;
    <i>/* dealokace pole ziskaneho pres GetClassFields() */</i>
    error = (*jvmti_env)-&gt;Deallocate(jvmti_env, (unsigned char*)fields_array);
    check_jvmti_error(jvmti_env, error, "deallocate class fields array");
}
</pre>

<p>Ve funkci <strong>prepare_field_monitor()</strong> se prochází v¹echny
atributy tøídy stejným zpùsobem, jaký ji¾ známe z&nbsp;minula.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Výsledek bìhu demonstraèního agenta èíslo 28</h2>

<p>Demonstraèní agent popsaný v&nbsp;pøedchozích ètyøech kapitolách se pøelo¾í
stejným zpùsobem, jako ji¾ døíve popsaní agenti:</p>

<pre>
gcc -Wall -ansi -I/usr/lib/jvm/java-1.6.0-openjdk/include/ -shared -o libagent28.so agent28.c
</pre>

<p>Spu¹tìní virtuálního stroje Javy spoleènì s&nbsp;<i>JVM TI</i> agentem je
zaji¹tìno pøíkazem:</p>

<pre>
java -agentpath:./libagent28.so Test28 2&gt; /dev/null
</pre>

<p><i>JVM TI</i> agent po naètení, inicializaci a spu¹tìní testovací javovské
tøídy <strong>Test28</strong> vypí¹e na standardní výstup následující sekvenci
zpráv, z&nbsp;nich¾ je patrné, ¾e celkem ètyøikrát do¹lo k&nbsp;pøeètení
hodnoty atributu (<strong>i</strong>) a pìtkrát k&nbsp;zápisu nové hodnoty:</p>

<pre>
Agent28: Agent_OnLoad
Agent28: JVM TI version is correct
Agent28: Got VM init event
Class Test28; prepared, setting field monitor
Setting monitors for field #34
i := 10
Agent28: Field access
i := 11
Agent28: Field access
i := 10
Agent28: Field access
i := 20
Agent28: Field access
i := 21
Agent28: Got VM Death event
Agent28: Agent_OnUnload
</pre>

<p>Tento výpis je vhodné porovnat se zdrojovým kódem testovací javovské tøídy
<strong>Test28</strong>, který byl uveden <a href="#k05">v&nbsp;páté
kapitole</a>.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Zdrojové kódy obou demonstraèních agentù a k&nbsp;nim pøíslu¹ných testovacích pøíkladù</h2>

<p>Podobnì jako v&nbsp;mnoha pøedcházejících èástech <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">tohoto
seriálu</a> byly i dne¹ní dva demonstraèní <i>JVM TI</i> agenti kvùli snaz¹ímu
udr¾ování v¹ech zdrojových kódù ulo¾eni do Mercurial repositáøe, který je
dostupný na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
Prozatím nejnovìj¹í verze dnes popisovaných <i>JVM TI</i> agentù i dal¹ích
potøebných skriptù a testovacích javovských tøíd jsou dostupné na následujících
adresách:</p>

<table>
<tr><th>Demonstraèní pøíklad/podpùrný soubor</th><th>Umístìní</th></tr>
<tr><td>Agent #27                     </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e78af9a76fa5/jvmti-agents/agent27/agent27.c">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e78af9a76fa5/jvmti-agents/agent27/agent27.c</a></td></tr>
<tr><td>Skript pro pøeklad            </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e78af9a76fa5/jvmti-agents/agent27/compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e78af9a76fa5/jvmti-agents/agent27/compile.sh</a></td></tr>
<tr><td>Skript pro spu¹tìní           </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e78af9a76fa5/jvmti-agents/agent27/test.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e78af9a76fa5/jvmti-agents/agent27/test.sh</a></td></tr>
<tr><td>Testovací tøída Test27.java   </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e78af9a76fa5/jvmti-agents/agent27/Test27.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e78af9a76fa5/jvmti-agents/agent27/Test27.java</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Agent #28                     </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e78af9a76fa5/jvmti-agents/agent28/agent28.c">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e78af9a76fa5/jvmti-agents/agent28/agent28.c</a></td></tr>
<tr><td>Skript pro pøeklad            </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e78af9a76fa5/jvmti-agents/agent28/compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e78af9a76fa5/jvmti-agents/agent28/compile.sh</a></td></tr>
<tr><td>Skript pro spu¹tìní           </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e78af9a76fa5/jvmti-agents/agent28/test.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e78af9a76fa5/jvmti-agents/agent28/test.sh</a></td></tr>
<tr><td>Testovací tøída Test28.java   </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e78af9a76fa5/jvmti-agents/agent28/Test28.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e78af9a76fa5/jvmti-agents/agent28/Test28.java</a></td></tr>
</table>



<p><a name="k11"></a></p>
<h2 id="k11">11. Odkazy na Internetu</h2>

<ol>

<li>The JVM Tool Interface (JVM TI): How VM Agents Work<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html">http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html</a>
</li>

<li>JVM Tool Interface Version 1.2<br />
<a href="http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html">http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html</a>
</li>

<li>Creating a Debugging and Profiling Agent with JVMTI<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html">http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html</a>
</li>

<li>JVM TI (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/JVM_TI">http://en.wikipedia.org/wiki/JVM_TI</a>
</li>

<li>IBM JVMTI extensions<br />
<a href="http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html">http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

