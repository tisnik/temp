<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - zmìna pøístupových práv k metodám a atributùm libovolné tøídy</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - zmìna pøístupových práv k metodám a atributùm libovolné tøídy</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o virtuálním stroji Javy si uká¾eme jeden ze zpùsobù vyu¾ití nástroje Javassist. Øekneme si toti¾, jak je mo¾né zmìnit pøístupová práva k metodám a atributùm libovolné tøídy. Jedná se sice o pomìrnì jednoduchou problematiku, která ale ukazuje sílu a souèasnì i snadnost pou¾ití Javassistu.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - zmìna pøístupových práv k metodám a atributùm libovolné tøídy</a></p>
<p><a href="#k02">2. Zdrojový kód testovací tøídy <strong>Test</strong></a></p>
<p><a href="#k03">3. Zmìna pøístupových práv ke statické metodì libovolné tøídy</a></p>
<p><a href="#k04">4. Zmìna pøístupových práv ke statickému atributu libovolné tøídy</a></p>
<p><a href="#k05">5. Metoda pro zji¹tìní, zda skuteènì máme pøístup ke v¹em statickým atributùm i statickým metodám tøídy</a></p>
<p><a href="#k06">6. Metoda <strong>setStaticIntField()</strong></a></p>
<p><a href="#k07">7. Metoda <strong>invokeStaticMethod()</strong></a></p>
<p><a href="#k08">8. Kompletní zdrojový kód demonstraèního pøíkladu <strong>ClassModification1</strong></a></p>
<p><a href="#k09">9. Spu¹tìní demonstraèního pøíkladu bez zmìny pøístupových práv</a></p>
<p><a href="#k10">10. Spu¹tìní demonstraèního pøíkladu s&nbsp;povolením zmìn pøístupových práv ve tøídì <strong>Test</strong></a></p>
<p><a href="#k11">11. Pùvodní struktura bajtkódu tøídy <strong>Test</strong></a></p>
<p><a href="#k12">12. Nová struktura bajtkódu tøídy <strong>Test</strong></a></p>
<p><a href="#k13">13. Repositáø se zdrojovými kódy dne¹ního demonstraèního pøíkladu</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - zmìna pøístupových práv k metodám a atributùm libovolné tøídy</h2>

<p>V&nbsp;nìkolika pøedchozích èástech seriálu o programovacím jazyce Java i o
virtuálním stroji Javy jsme si ukázali, jak lze vyu¾ít nástroj <i>Javassist</i>
pro tvorbu nových tøíd, popø.&nbsp;pro výpis obsahu libovolné tøídy, vèetnì
dekódování instrukcí bajtkódu tvoøících tìla jednotlivých metod zkoumaných
tøíd. Ov¹em <i>Javassist</i> lze vyu¾ít i k&nbsp;dal¹ím operacím. Jedním
z&nbsp;pomìrnì èastých po¾adavkù &ndash; napøíklad pøi vytváøení testù &ndash;
je mít mo¾nost zavolat libovolnou metodu zvolené tøídy, a to i metodu privátní
(obecnì metodu, k&nbsp;ní¾ nemáme práva pøístupu). Podobnì je nìkdy nutné pøímo
pøistoupit k&nbsp;privátnímu atributu tøídy. Tuto problematiku lze øe¹it více
zpùsoby. První zpùsob vyu¾ívá reflexi (Reflection API), pøedev¹ím pak metodu
<strong>java.lang.reflect.AccessibleObject.setAccessible()</strong> pro
nastavení pøístupu i k&nbsp;privátním metodám/atributùm. Tento zpùsob v¹ak
doká¾e zajistit pøístup k&nbsp;metodì/atributu pouze v&nbsp;rámci bì¾ícího
virtuálního stroje Javy, zatímco pùvodní podoba tøídy zùstane nezmìnìna, co¾
mj.&nbsp;znamená, ¾e nebude mo¾né pøímo pøistoupit k&nbsp;privátnímu atributu
nebo metodì ve zdrojovém kódu &ndash; to nedovolí pøekladaè
<strong>javac</strong>.</p>

<p>Druhý zpùsob, kterým se dnes budeme zabývat, je flexibilnìj¹í a také
obecnìj¹í. Spoèívá v&nbsp;tom, ¾e se upravovaná tøída naète do virtuálního
stroje Javy a následnì se její metody a/nebo atributy zmìní s&nbsp;vyu¾itím
nástroje <i>Javassist</i>. Poté je mo¾né buï takto zmìnìnou tøídu pøímo pou¾ít,
popø.&nbsp;je navíc mo¾né zmìnìnou tøídu, pøesnìji øeèeno její bajtkód, ulo¾it
na disk do souboru s&nbsp;koncovkou .class. Oba zpùsoby lze pøitom pou¾ít i
v&nbsp;tìch pøípadech, kdy nemáme k&nbsp;dispozici zdrojový kód modifikovaných
tøíd, co¾ je v&nbsp;ne-OS svìtì pomìrnì èastý problém, proto¾e mnohdy mají
vývojáøi k&nbsp;dispozici pouze soubory .class nebo Javovský archiv .jar.
S&nbsp;vyu¾itím <i>Javassistu</i> lze i v&nbsp;tìchto pøípadech napøíklad
opravit chyby v&nbsp;nìjaké metodì èi provádìt ji¾ vý¹e zmínìné testování
(mo¾ná je to zvlá¹tní, ale v&nbsp;mnoha pøípadech vùbec nedojde k&nbsp;poru¹ení
licence, zejména tehdy, pokud se zmìnìný bajtkód neulo¾í do nového .class a
dále ne¹íøí).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Zdrojový kód testovací tøídy <strong>Test</strong></h2>

<p>Je¹tì ne¾ si uká¾eme konkrétní postupy, jak v&nbsp;nástroji <i>Javassist</i>
zajistit zmìnu pøístupových práv k&nbsp;metodám a atributùm, podíváme se na
zdrojový kód testovací tøídy nazvané <strong>Test</strong>. V&nbsp;této tøídì
je deklarována ètveøice statických metod <strong>foo()</strong>,
<strong>bar()</strong>, <strong>printX()</strong> a <strong>printY()</strong> i
dvojice statických celoèíselných atributù <strong>x</strong> a
<strong>y</strong>. Dùle¾ité je, ¾e první z&nbsp;tìchto atributù je veøejný a
druhý privátní, co¾ znamená, ¾e pøístup ke druhému atributu je kontrolován jak
pøekladaèem (ten nám nedovolí pøelo¾it kód, který k&nbsp;atributu
<strong>Test.y</strong> pøistupuje mimo jeho tøídu), tak i v&nbsp;èase bìhu
aplikace. Podobné omezení platí i v&nbsp;pøípadì metod tøídy
<strong>Test</strong>, konkrétnì u metody <strong>Test.bar()</strong>, která je
privátní a tudí¾ nepøístupná vnì této tøídy.</p>

<p>Poznámka: to, ¾e jak metody, tak i atributy jsou statické znamená, ¾e mù¾eme
tøídu testovat, ani¾ by bylo nutné vytváøet její instance. Nicménì je velmi
jednoduché testovací tøídu i dále popsaný demonstraèní pøíklad upravit tak, aby
pou¾íval nestatické (instanèní) metody a atributy.</p>

<p>Úplný zdrojový kód testovací tøídy <strong>Test</strong> je vypsán pod tímto
odstavcem:</p>

<pre>
<i>/**</i>
<i> * Testovaci trida, ktera bude modifikovana nastrojem Javassist.</i>
<i> */</i>
public class <strong>Test</strong> {
&nbsp;
    <strong>public</strong> static int <strong>x</strong>;
    <strong>private</strong> static int <strong>y</strong>;
&nbsp;
    <strong>public</strong> static void <strong>foo</strong>() {
        System.out.println("Method 'foo' called!");
    }
&nbsp;
    <strong>private</strong> static void <strong>bar</strong>() {
        System.out.println("Method 'bar' called!");
    }
&nbsp;
    <strong>public</strong> static void <strong>printX</strong>() {
        System.out.println("Field Test.x = " + x);
    }
&nbsp;
    <strong>public</strong> static void <strong>printY</strong>() {
        System.out.println("Field Test.y = " + y);
    }
}
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zmìna pøístupových práv ke statické metodì libovolné tøídy</h2>

<p>Podívejme se nyní, jak je snadné zmìnit pøístupová práva ke statické metodì
tøídy. V&nbsp;pøípadì pou¾ití nástroje <i>Javassist</i> je nejdøíve nutné pro
danou tøídu získat instanci typu <strong>CtClass</strong> s&nbsp;vyu¾itím class
poolu:</p>

<pre>
        <i>// ziskat vychozi class pool</i>
        ClassPool pool = ClassPool.getDefault();
&nbsp;
        <i>// objekt predstavujici menenou tridu</i>
        CtClass testClass;
&nbsp;
        <i>// ziskat objekt predstavujici tridu Test</i>
        <i>// (provede se vyhledani a nacteni souboru Test.class)</i>
        testClass = pool.get("Test");
</pre>

<p>Jakmile ji¾ máme získanou instanci typu <strong>CtClass</strong>, lze zmìnit
modifikátory libovolné metody. Následující kód mìní modifikátory metody
<strong>Test.bar()</strong> z&nbsp;kombinace <strong>STATIC+PRIVATE</strong> na
po¾adovanou kombinaci <strong>STATIC+PUBLIC</strong>:</p>

<pre>
<i>    /**</i>
<i>     * Modifikace metody Test.bar() - zmena pristupovych prav.</i>
<i>     * </i>
<i>     * @param testClass</i>
<i>     *            testovaci (modifikovana) trida.</i>
<i>     * @throws NotFoundException</i>
<i>     *             vyvolana v pripade, ze metoda neni nalezena.</i>
<i>     */</i>
    private static void <strong>modifyMethodBar</strong>(CtClass testClass) throws NotFoundException {
        CtMethod method = testClass.getDeclaredMethod("bar");
        method.setModifiers(Modifier.STATIC + Modifier.PUBLIC);
    }
</pre>

<p>Upozornìní: problém mù¾e nastat v&nbsp;pøípadì pøidání èi odstranìní
modifikátoru <strong>STATIC</strong>, nebo» se zmìní volací konvence této
metody a dokonce i instrukce bajtkódu provádìjícího její volání
(<strong>invokestatic</strong> versus <strong>invokevirtual</strong>).</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Zmìna pøístupových práv ke statickému atributu libovolné tøídy</h2>

<p>Stejnì snadná je i zmìna pøístupových práv ke statickému èi nestatickému
atributu tøídy. V&nbsp;následujícím kódu jsou modifikátory atributu
<strong>Test.y</strong> zmìnìny z&nbsp;kombinace
<strong>STATIC+PRIVATE</strong> na kombinaci
<strong>STATIC+PUBLIC</strong>:</p>

<pre>
<i>    /**</i>
<i>     * Modifikace atributu Test.y - zmena pristupovych prav.</i>
<i>     * </i>
<i>     * @param testClass</i>
<i>     *            testovaci (modifikovana) trida.</i>
<i>     * @throws NotFoundException</i>
<i>     *             vyvolana v pripade, ze atribut neni nalezen.</i>
<i>     */</i>
    private static void <strong>modifyFieldY</strong>(CtClass testClass) throws NotFoundException {
        CtField field = testClass.getDeclaredField("y");
        field.setModifiers(Modifier.STATIC + Modifier.PUBLIC);
    }
</pre>

<p>Upozornìní: i pokud odstraníte modifikátor <strong>FINAL</strong>, nemusí to
znamenat, ¾e bude jednodu¹e mo¾né zmìnit hodnotu tohoto atributu, která se
projeví v&nbsp;celém programu. Je tomu tak z&nbsp;toho dùvodu, ¾e se napøíklad
kombinace <strong>STATIC+FINAL</strong> pova¾uje za symbolickou konstantu a
v&nbsp;kódu se tedy nemusí provádìt explicitní ètení tohoto atributu. Ostatnì
si to mù¾eme snadno vyzkou¹et. Tøída:</p>

<pre>
public class T {
    static {
        System.out.println(Math.PI);
        System.exit(0);
    }
}
</pre>

<p>se pøelo¾í takto:</p>

<pre>
Compiled from "T.java"
public class T extends java.lang.Object{
public T();
  Code:
   0:   aload_0
   1:   invokespecial   #1; <i>//Method java/lang/Object."&lt;init&gt;":()V</i>
   4:   return
&nbsp;
static {};
  Code:
   0:   getstatic       #2; <i>//Field java/lang/System.out:Ljava/io/PrintStream;</i>
   3:   <strong>ldc2_w  #3;</strong>         <i>//double 3.141592653589793d</i>
   6:   invokevirtual   #5; <i>//Method java/io/PrintStream.println:(D)V</i>
   9:   iconst_0
   10:  invokestatic    #6; <i>//Method java/lang/System.exit:(I)V</i>
   13:  return

}
</pre>

<p>Pov¹imnìte si pøedev¹ím faktu, ¾e se namísto ètení atributu
<strong>Math.PI</strong> skuteènì pøímo pou¾ívá konstanta ulo¾ená na constant
poolu.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Metoda pro zji¹tìní, zda skuteènì máme pøístup ke v¹em statickým atributùm i statickým metodám tøídy</h2>

<p>Zji¹tìní, zda skuteènì máme povolený pøístup ke v¹em statickým atributùm i
statickým metodám testovací tøídy <strong>Test</strong>, mù¾eme provést dvìma
zpùsoby. Buï lze vytvoøit samostatnou tøídu, pøi jejím¾ pøekladu i spu¹tìní se
vyu¾ije modifikovaný bajtkód tøídy <strong>Test</strong> (pøipomeòme si, ¾e pøi
pøekladu se kontroluje, zda jsou atributy a metody tøíd dostupné), nebo lze
modifikovanou tøídu <strong>Test</strong> pou¾ít v&nbsp;tom samém virtuálním
stroji Javy, kde byl spu¹tìn nástroj <i>Javassist</i>. Tento druhý zpùsob je
sice zajímavìj¹í, ale i ponìkud slo¾itìj¹í, nebo» je nutné pou¾ít <i>Reflection
API</i>. Podívejme se nejprve na zdrojový kód metody nazvané
<strong>checkAccess()</strong>, v&nbsp;ní¾ se nejprve pøevede objekt typu
<strong>CtClass</strong> na instanci <strong>java.lang.Class</strong>. Ihned
poté je ji¾ mo¾né pou¾ít <i>Reflection API</i>, které je dostupné v&nbsp;ka¾dém
bìhovém prostøedí Javy od verze 1.1:</p>

<pre>
<i>    /**</i>
<i>     * Zjisteni, zda skutecne mame pristup ke vsem statickym metodam i statickym</i>
<i>     * atributum tridy.</i>
<i>     * </i>
<i>     * @param testClass</i>
<i>     *            testovaci (modifikovana) trida.</i>
<i>     * @throws CannotCompileException</i>
<i>     *             muze byt vyhozena v prubehu prevodu CtClass na Class</i>
<i>     */</i>
    @SuppressWarnings("unchecked")
    private static void <strong>checkAccess</strong>(CtClass testClass) throws CannotCompileException {
        Class testClassKlass = testClass.toClass();
&nbsp;
        <i>// otestovani pristupu ke vsem statickym metodam tridy</i>
        invokeStaticMethod(testClassKlass, "foo");
        invokeStaticMethod(testClassKlass, "bar");
        invokeStaticMethod(testClassKlass, "printX");
        invokeStaticMethod(testClassKlass, "printY");
&nbsp;
        <i>// otestovani pristupu ke vsem statickym atributum tridy</i>
        setStaticIntField(testClassKlass, "x", 42);
        setStaticIntField(testClassKlass, "y", 6502);
&nbsp;
        <i>// vypis novych hodnot statickych atributu</i>
        invokeStaticMethod(testClassKlass, "printX");
        invokeStaticMethod(testClassKlass, "printY");
    }
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Metoda <strong>setStaticIntField()</strong></h2>

<p>V&nbsp;metodì <strong>checkAccess()</strong> popsané <a
href="#k05">v&nbsp;pøedchozí kapitole</a> se mj.&nbsp;volá i dal¹í u¾ivatelská
metoda nazvaná <strong>setStaticIntField()</strong>. Jak ji¾ název této metody
napovídá, je mo¾né ji pou¾ít pro zmìnu hodnoty statického atributu typu
<strong>int</strong>. S&nbsp;vyu¾itím <i>Reflection API</i> se tato operace
rozdìluje na dvì èásti: získání objektu typu <strong>Field</strong>
pøedstavujícího obraz atributu a následné nastavení nové hodnoty atributu
s&nbsp;vyu¾itím <strong>Field.set()</strong>
popø.&nbsp;<strong>Field.setInt()</strong>. Této metodì je nutné pøedat
instanci tøídy, pro ní¾ se má atribut nastavit (u statických atributù je zde
namísto reference pøedána hodnota <strong>null</strong>) a ve druhém parametru
se pøedává buï instance tøídy <strong>Integer</strong> u metody
<strong>Field.set()</strong> nebo pøímo celoèíselná hodnota u metody
<strong>Field.setInt()</strong>. Pøi nastavování hodnoty atributu mohou nastat
výjimky rùzných typù &ndash; atribut nebyl nalezen, není k&nbsp;nìmu dovolen
pøístup, nastavuje se ¹patná hodnota atd.:</p>

<pre>
<i>    /**</i>
<i>     * Nastaveni statickeho atributu typu int na vybranou hodnotu.</i>
<i>     * </i>
<i>     * @param anyClass</i>
<i>     *            testovaci (modifikovana) trida.</i>
<i>     * @param fieldName</i>
<i>     *            jmeno statickeho atributu, jehoz hodnota se ma zmenit</i>
<i>     * @param fieldNewValue</i>
<i>     *            pozadovana nova hodnota atributu</i>
<i>     */</i>
    private static void <strong>setStaticIntField</strong>(Class anyClass, String fieldName, int fieldNewValue) {
        try {
            Field field = anyClass.getField(fieldName);
            field.set(null, fieldNewValue);
        }
        catch (SecurityException e) {
            e.printStackTrace();
        }
        catch (NoSuchFieldException e) {
            e.printStackTrace();
        }
        catch (IllegalArgumentException e) {
            e.printStackTrace();
        }
        catch (IllegalAccessException e) {
            e.printStackTrace();
        }
    }
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Metoda <strong>invokeStaticMethod()</strong></h2>

<p>Zavolání (statické) metody s&nbsp;vyu¾itím <i>Reflection API</i> se provádí
stejným dvoukrokovým pøístupem jako zmìna hodnoty atributu. Nejdøíve je nutné
získat objekt typu <strong>Method</strong> pøedstavující volanou metodu.
Následnì se zavolá <strong>Method.invoke()</strong>, které se v&nbsp;prvním
parametru pøedá instance tøídy (u statických tøíd zde mù¾e být
<strong>null</strong>) a v&nbsp;dal¹ích parametrech pak pøípadné parametry
volané metody. V¹echny metody z&nbsp;testovací tøídy <strong>Test</strong> jsou
bezparametrické, tak¾e jejich volání lze provést velmi jednodu¹e zpùsobem,
který je ukázán v&nbsp;kódu pod tímto odstavcem:</p>

<pre>
<i>    /**</i>
<i>     * Zavolani vybrane staticke metody</i>
<i>     * </i>
<i>     * @param anyClass</i>
<i>     *            trida, v niz je staticka metoda deklarovana</i>
<i>     * @param methodName</i>
<i>     *            jmeno staticke metody, ktera se ma spustit</i>
<i>     */</i>
    @SuppressWarnings("unchecked")
    private static void <strong>invokeStaticMethod</strong>(Class anyClass, String methodName) {
        try {
            Method method = anyClass.getMethod(methodName);
            method.invoke(null);
        }
        catch (SecurityException e) {
            e.printStackTrace();
        }
        catch (NoSuchMethodException e) {
            e.printStackTrace();
        }
        catch (IllegalArgumentException e) {
            e.printStackTrace();
        }
        catch (IllegalAccessException e) {
            e.printStackTrace();
        }
        catch (InvocationTargetException e) {
            e.printStackTrace();
        }
    }
</pre>

<p>Poznámka: zachycení v¹ech mo¾ných výjimek je provádìno ihned
v&nbsp;u¾ivatelské metodì <strong>invokeStaticMethod()</strong> z&nbsp;toho
dùvodu, aby demonstraèní program mohl po vzniku výjimky pokraèovat dále.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Kompletní zdrojový kód demonstraèního pøíkladu <strong>ClassModification1</strong></h2>

<p>Ve¹keré u¾ivatelské metody popsané vý¹e jsou souèástí dne¹ního prvního a
souèasnì i jediného demonstraèního pøíkladu nazvaného
<strong>ClassModification1</strong>. V&nbsp;tomto pøíkladu se provede trojice
operací. Nejdøíve se naète soubor <strong>Test.class</strong> a získá se
z&nbsp;nìj hodnota typu <strong>CtClass</strong>. Následnì se struktura celé
této tøídy vypí¹e na standardní výstup s&nbsp;vyu¾itím stejného postupu,
s&nbsp;jakým jsme se seznámili ji¾ v&nbsp;pøedchozích èástech tohoto seriálu
&ndash; zpìtným pøeètením kódu ka¾dé metody s&nbsp;následnou iterací pøes
získaný kód a výpisem symbolických jmen jednotlivých instrukcí. Poté dojde ke
zmìnì modifikátorù metody <strong>Test.bar()</strong> i atributu
<strong>y</strong>. Posléze se právì zmìnìná tøída <strong>Test</strong> naète
do JVM a v¹echny ètyøi její statické metody <strong>foo()</strong>,
<strong>bar()</strong>, <strong>printX()</strong> i <strong>printY()</strong>
se spustí. Dojde i ke zmìnì hodnoty obou statických atributù této tøídy.
Následuje výpis celého zdrojového kódu tohoto demonstraèního pøíkladu:</p>

<pre>
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
&nbsp;
import javassist.CannotCompileException;
import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtField;
import javassist.CtMethod;
import javassist.Modifier;
import javassist.NotFoundException;
import javassist.bytecode.BadBytecode;
import javassist.bytecode.CodeAttribute;
import javassist.bytecode.CodeIterator;
import javassist.bytecode.MethodInfo;
import javassist.bytecode.Mnemonic;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Test moznosti nastroje Javassist - zmena modifikatoru metod a atributu</i>
<i> * testovaci tridy Test. Jakmile dojde ke zmene vsech metod a atributu</i>
<i> * na "public" (verejne), jsou zmeneny hodnoty obou atributu a spusteny</i>
<i> * vsechny metody testovaci tridy.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>ClassModification1</strong> {
&nbsp;
<i>    /**</i>
<i>     * Jmeno testovaci tridy.</i>
<i>     */</i>
    private static final String <strong>TEST_CLASS_NAME</strong> = "Test";
&nbsp;
<i>    /**</i>
<i>     * Vypis struktury vybrane metody.</i>
<i>     * </i>
<i>     * @param modifiedClass</i>
<i>     *            predstavuje vytvarenou ci modifikovanou tridu</i>
<i>     * @param methodName</i>
<i>     *            jmeno metody, jejiz struktura se ma vypsat</i>
<i>     * @throws NotFoundException</i>
<i>     *             vyhozena, pokud metoda nebyla nalezena</i>
<i>     * @throws BadBytecode</i>
<i>     *             vyhozena, pokud se nalezne neplatna instrukce v bytekodu</i>
<i>     */</i>
    private static void <strong>printMethodStructure</strong>(CtClass modifiedClass, String methodName) throws NotFoundException, BadBytecode {
        System.out.println("Method '" + methodName + "' structure:");
        CtMethod method = modifiedClass.getDeclaredMethod(methodName);
        if (method == null) {
            System.out.println("   not found!");
            return;
        }
        MethodInfo methodInfo = method.getMethodInfo();
        System.out.println("    real name:    " + methodInfo.getName());
        System.out.println("    descriptor:   " + methodInfo.getDescriptor());
        System.out.println("    access flags: " + Modifier.toString(methodInfo.getAccessFlags()));
        System.out.println("    method body:");
        printMethodBody(methodInfo);
        System.out.println();
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis instrukci tvoricich telo vybrane metody.</i>
<i>     *</i>
<i>     * @throws NotFoundException</i>
<i>     *             vyhozena, pokud metoda nebyla nalezena</i>
<i>     * @throws BadBytecode</i>
<i>     *             vyhozena, pokud se nalezne neplatna instrukce v bytekodu</i>
<i>     */</i>
    private static void <strong>printMethodBody</strong>(MethodInfo methodInfo) throws BadBytecode {
        CodeAttribute ca = methodInfo.getCodeAttribute();
        CodeIterator iterator = ca.iterator();
        while (iterator.hasNext()) {
            int index = iterator.next();
            int opcode = iterator.byteAt(index);
            System.out.println("        " + Mnemonic.OPCODE[opcode]);
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis struktury vybranych metod z modifikovane tridy.</i>
<i>     * </i>
<i>     * @param modifiedClass</i>
<i>     *            predstavuje vytvarenou ci modifikovanou tridu</i>
<i>     * @throws NotFoundException</i>
<i>     *             vyhozena, pokud metoda nebyla nalezena</i>
<i>     * @throws BadBytecode </i>
<i>     */</i>
    private static void <strong>printMethodStructures</strong>(CtClass modifiedClass) throws NotFoundException, BadBytecode {
        printMethodStructure(modifiedClass, "foo");
        printMethodStructure(modifiedClass, "bar");
        printMethodStructure(modifiedClass, "printX");
        printMethodStructure(modifiedClass, "printY");
    }
&nbsp;
<i>    /**</i>
<i>     * Modifikace metody Test.bar() - zmena pristupovych prav.</i>
<i>     * </i>
<i>     * @param testClass</i>
<i>     *            testovaci (modifikovana) trida.</i>
<i>     * @throws NotFoundException</i>
<i>     *             vyvolana v pripade, ze metoda neni nalezena.</i>
<i>     */</i>
    private static void <strong>modifyMethodBar</strong>(CtClass testClass) throws NotFoundException {
        CtMethod method = testClass.getDeclaredMethod("bar");
        method.setModifiers(Modifier.STATIC + Modifier.PUBLIC);
    }
&nbsp;
<i>    /**</i>
<i>     * Modifikace atributu Test.y() - zmena pristupovych prav.</i>
<i>     * </i>
<i>     * @param testClass</i>
<i>     *            testovaci (modifikovana) trida.</i>
<i>     * @throws NotFoundException</i>
<i>     *             vyvolana v pripade, ze atribut neni nalezen.</i>
<i>     */</i>
    private static void <strong>modifyFieldY</strong>(CtClass testClass) throws NotFoundException {
        CtField field = testClass.getDeclaredField("y");
        field.setModifiers(Modifier.STATIC + Modifier.PUBLIC);
    }
&nbsp;
<i>    /**</i>
<i>     * Zjisteni, zda skutecne mame pristup ke vsem statickym metodam i statickym</i>
<i>     * atributum tridy.</i>
<i>     * </i>
<i>     * @param testClass</i>
<i>     *            testovaci (modifikovana) trida.</i>
<i>     * @throws CannotCompileException</i>
<i>     *             muze byt vyhozena v prubehu prevodu CtClass na Class</i>
<i>     */</i>
    @SuppressWarnings("unchecked")
    private static void <strong>checkAccess</strong>(CtClass testClass) throws CannotCompileException {
        Class testClassKlass = testClass.toClass();
&nbsp;
        <i>// otestovani pristupu ke vsem statickym metodam tridy</i>
        invokeStaticMethod(testClassKlass, "foo");
        invokeStaticMethod(testClassKlass, "bar");
        invokeStaticMethod(testClassKlass, "printX");
        invokeStaticMethod(testClassKlass, "printY");
&nbsp;
        <i>// otestovani pristupu ke vsem statickym atributum tridy</i>
        setStaticIntField(testClassKlass, "x", 42);
        setStaticIntField(testClassKlass, "y", 6502);
&nbsp;
        <i>// vypis novych hodnot statickych atributu</i>
        invokeStaticMethod(testClassKlass, "printX");
        invokeStaticMethod(testClassKlass, "printY");
    }
&nbsp;
<i>    /**</i>
<i>     * Nastaveni statickeho atributu typu int na vybranou hodnotu.</i>
<i>     * </i>
<i>     * @param anyClass</i>
<i>     *            testovaci (modifikovana) trida.</i>
<i>     * @param fieldName</i>
<i>     *            jmeno statickeho atributu, jehoz hodnota se ma zmenit</i>
<i>     * @param fieldNewValue</i>
<i>     *            pozadovana nova hodnota atributu</i>
<i>     */</i>
    private static void <strong>setStaticIntField</strong>(Class anyClass, String fieldName, int fieldNewValue) {
        try {
            Field field = anyClass.getField(fieldName);
            field.set(null, fieldNewValue);
        }
        catch (SecurityException e) {
            e.printStackTrace();
        }
        catch (NoSuchFieldException e) {
            e.printStackTrace();
        }
        catch (IllegalArgumentException e) {
            e.printStackTrace();
        }
        catch (IllegalAccessException e) {
            e.printStackTrace();
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Zavolani vybrane staticke metody</i>
<i>     * </i>
<i>     * @param anyClass</i>
<i>     *            trida, v niz je staticka metoda deklarovana</i>
<i>     * @param methodName</i>
<i>     *            jmeno staticke metody, ktera se ma spustit</i>
<i>     */</i>
    @SuppressWarnings("unchecked")
    private static void <strong>invokeStaticMethod</strong>(Class anyClass, String methodName) {
        try {
            Method method = anyClass.getMethod(methodName);
            method.invoke(null);
        }
        catch (SecurityException e) {
            e.printStackTrace();
        }
        catch (NoSuchMethodException e) {
            e.printStackTrace();
        }
        catch (IllegalArgumentException e) {
            e.printStackTrace();
        }
        catch (IllegalAccessException e) {
            e.printStackTrace();
        }
        catch (InvocationTargetException e) {
            e.printStackTrace();
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Spusteni modifikatoru tridy.</i>
<i>     *</i>
<i>     * @param args nevyuzito</i>
<i>     */</i>
    public static void <strong>main</strong>(String[] args) {
        <i>// ziskat vychozi class pool</i>
        ClassPool pool = ClassPool.getDefault();
&nbsp;
        <i>// objekt predstavujici menenou tridu</i>
        CtClass testClass;
&nbsp;
        try {
            <i>// ziskat objekt predstavujici tridu Test</i>
            testClass = pool.get(TEST_CLASS_NAME);
&nbsp;
            <i>// vypis puvodni struktury tridy Test</i>
            System.out.println("Original class structure:\n");
            printMethodStructures(testClass);
&nbsp;
            <i>// modifikace puvodne privatni metody</i>
            modifyMethodBar(testClass);
&nbsp;
            <i>// modifikace puvodne privatniho atributu</i>
            modifyFieldY(testClass);
&nbsp;
            <i>// vypis zmenene struktury tridy Test</i>
            System.out.println("Modified class structure:\n");
            printMethodStructures(testClass);
&nbsp;
            <i>// ulozeni bajtkodu tridy na disk</i>
            testClass.writeFile();
&nbsp;
            <i>// a otestovani, zda mame skutecne pristup ke vsem atributum</i>
            checkAccess(testClass);
        }
        catch (NotFoundException e) {
            e.printStackTrace();
        }
        catch (BadBytecode e) {
            e.printStackTrace();
        }
        catch (IOException e) {
            e.printStackTrace();
        }
        catch (CannotCompileException e) {
            e.printStackTrace();
        }
        catch (SecurityException e) {
            e.printStackTrace();
        }
        catch (IllegalArgumentException e) {
            e.printStackTrace();
        }
    }
&nbsp;
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Spu¹tìní demonstraèního pøíkladu bez zmìny pøístupových práv</h2>

<p>Podívejme se nyní, co se stane v&nbsp;pøípadì, ¾e v&nbsp;demonstraèním
pøíkladu <strong>NE</strong>provedeme zmìnu pøístupových práv, tj.&nbsp;kdy¾
nedojde k&nbsp;zavolání u¾ivatelských metod <strong>modifyMethodBar()</strong>
a <strong>modifyFieldY()</strong> (volání bylo zakomentováno). V&nbsp;tomto
pøípadì se samozøejmì korektnì vypí¹e struktura tøídy <strong>Test</strong>,
ov¹em pøi volání metody <strong>Test.bar()</strong> èi pøi pokusu o zmìnu
atributu <strong>Test.y</strong> dojde k&nbsp;vyhození (a následnému zachycení)
výjimky:</p>

<pre>
<strong>Original class structure:</strong>
&nbsp;
Method 'foo' structure:
    real name:    foo
    descriptor:   ()V
    access flags: public static
    method body:
        getstatic
        ldc
        invokevirtual
        return
&nbsp;
Method 'bar' structure:
    real name:    bar
    descriptor:   ()V
    access flags: private static
    method body:
        getstatic
        ldc
        invokevirtual
        return
&nbsp;
Method 'printX' structure:
    real name:    printX
    descriptor:   ()V
    access flags: public static
    method body:
        getstatic
        new
        dup
        ldc
        invokespecial
        getstatic
        invokevirtual
        invokevirtual
        invokevirtual
        return
&nbsp;
Method 'printY' structure:
    real name:    printY
    descriptor:   ()V
    access flags: public static
    method body:
        getstatic
        new
        dup
        ldc
        invokespecial
        getstatic
        invokevirtual
        invokevirtual
        invokevirtual
        return
</pre>

<p>&nbsp;</p>

<pre>
<strong>Modified class structure:</strong>
&nbsp;
Method 'foo' structure:
    real name:    foo
    descriptor:   ()V
    access flags: public static
    method body:
        getstatic
        ldc
        invokevirtual
        return
&nbsp;
Method 'bar' structure:
    real name:    bar
    descriptor:   ()V
    access flags: private static
    method body:
        getstatic
        ldc
        invokevirtual
        return
&nbsp;
Method 'printX' structure:
    real name:    printX
    descriptor:   ()V
    access flags: public static
    method body:
        getstatic
        new
        dup
        ldc
        invokespecial
        getstatic
        invokevirtual
        invokevirtual
        invokevirtual
        return
&nbsp;
Method 'printY' structure:
    real name:    printY
    descriptor:   ()V
    access flags: public static
    method body:
        getstatic
        new
        dup
        ldc
        invokespecial
        getstatic
        invokevirtual
        invokevirtual
        invokevirtual
        return
</pre>

<p>&nbsp;</p>

<pre>
Method 'foo' called!
Field Test.x = 0
Field Test.y = 0
java.lang.NoSuchMethodException: Test.bar()
        at java.lang.Class.getMethod(Class.java:1605)
        at ClassModification1.invokeStaticMethod(ClassModification1.java:192)
        at ClassModification1.checkAccess(ClassModification1.java:139)
        at ClassModification1.main(ClassModification1.java:246)
java.lang.NoSuchFieldException: y
        at java.lang.Class.getField(Class.java:1520)
        at ClassModification1.setStaticIntField(ClassModification1.java:164)
        at ClassModification1.checkAccess(ClassModification1.java:145)
        at ClassModification1.main(ClassModification1.java:246)
Field Test.x = 42
Field Test.y = 0
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Spu¹tìní demonstraèního pøíkladu s&nbsp;povolením zmìn pøístupových práv ve tøídì <strong>Test</strong> </h2>

<p>Pokud se demonstraèní pøíklad <strong>ClassModification1</strong> spustí bez
dal¹ích zmìn, dojde ke korektní úpravì pøístupových práv k&nbsp;metodì
<strong>Test.bar()</strong> i k&nbsp;atributu <strong>Test.y</strong>; co¾
znamená, ¾e pøi dal¹í práci se tøídou <strong>Test</strong> nebudou vyhazovány
¾ádné výjimky. O tom se mù¾eme ostatnì snadno pøesvìdèit:</p>

<pre>
<strong>Original class structure:</strong>
&nbsp;
Method 'foo' structure:
    real name:    foo
    descriptor:   ()V
    access flags: public static
    method body:
        getstatic
        ldc
        invokevirtual
        return
&nbsp;
Method 'bar' structure:
    real name:    bar
    descriptor:   ()V
    access flags: private static
    method body:
        getstatic
        ldc
        invokevirtual
        return
&nbsp;
Method 'printX' structure:
    real name:    printX
    descriptor:   ()V
    access flags: public static
    method body:
        getstatic
        new
        dup
        ldc
        invokespecial
        getstatic
        invokevirtual
        invokevirtual
        invokevirtual
        return
&nbsp;
Method 'printY' structure:
    real name:    printY
    descriptor:   ()V
    access flags: public static
    method body:
        getstatic
        new
        dup
        ldc
        invokespecial
        getstatic
        invokevirtual
        invokevirtual
        invokevirtual
        return
</pre>

<p>&nbsp;</p>

<pre>
<strong>Modified class structure:</strong>
&nbsp;
Method 'foo' structure:
    real name:    foo
    descriptor:   ()V
    access flags: public static
    method body:
        getstatic
        ldc
        invokevirtual
        return
&nbsp;
Method 'bar' structure:
    real name:    bar
    descriptor:   ()V
    access flags: public static
    method body:
        getstatic
        ldc
        invokevirtual
        return
&nbsp;
Method 'printX' structure:
    real name:    printX
    descriptor:   ()V
    access flags: public static
    method body:
        getstatic
        new
        dup
        ldc
        invokespecial
        getstatic
        invokevirtual
        invokevirtual
        invokevirtual
        return
&nbsp;
Method 'printY' structure:
    real name:    printY
    descriptor:   ()V
    access flags: public static
    method body:
        getstatic
        new
        dup
        ldc
        invokespecial
        getstatic
        invokevirtual
        invokevirtual
        invokevirtual
        return
</pre>

<p>&nbsp;</p>

<pre>
Method 'foo' called!
Method 'bar' called!
Field Test.x = 0
Field Test.y = 0
Field Test.x = 42
Field Test.y = 6502
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Pùvodní struktura bajtkódu tøídy <strong>Test</strong> </h2>

<p>Zajímavé bude zjistit, jakým zpùsobem demonstraèní pøíklad
<strong>ClassModification1</strong> zmìnil bajtkód testovací tøídy
<strong>Test</strong>. Aby byly zmìny jasnì patrné, zjistíme nejdøíve pùvodní
(nemodifikovanou) strukturu této tøídy:</p>

<pre>
javac Test.java
javap -c -private Test
</pre>

<p>Dostaneme následující výstup (zvýraznìna jsou jména a pøístupová práva metod
i atributù):</p>

<pre>
Compiled from "Test.java"
public class Test extends java.lang.Object{
&nbsp;
<strong>public static int x;</strong>
&nbsp;
<strong>private static int y;</strong>
&nbsp;
public Test();
  Code:
   0:   aload_0
   1:   invokespecial   #12; <i>//Method java/lang/Object."&lt;init&gt;":()V</i>
   4:   return
&nbsp;
public static void foo();
  Code:
   0:   getstatic       #23; <i>//Field java/lang/System.out:Ljava/io/PrintStream;</i>
   3:   ldc     #25;         <i>//String Method 'foo' called!</i>
   5:   invokevirtual   #31; <i>//Method java/io/PrintStream.println:(Ljava/lang/String;)V</i>
   8:   return
&nbsp;
<strong>private static void bar();</strong>
  Code:
   0:   getstatic       #23; <i>//Field java/lang/System.out:Ljava/io/PrintStream;</i>
   3:   ldc     #34;         <i>//String Method 'bar' called!</i>
   5:   invokevirtual   #31; <i>//Method java/io/PrintStream.println:(Ljava/lang/String;)V</i>
   8:   return
&nbsp;
<strong>public static void printX();</strong>
  Code:
   0:   getstatic       #23; <i>//Field java/lang/System.out:Ljava/io/PrintStream;</i>
   3:   new     #37;         <i>//class java/lang/StringBuilder</i>
   6:   dup
   7:   ldc     #39;         <i>//String Field Test.x = </i>
   9:   invokespecial   #41; <i>//Method java/lang/StringBuilder."&lt;init&gt;":(Ljava/lang/String;)V</i>
   12:  getstatic       #43; <i>//Field x:I</i>
   15:  invokevirtual   #47; <i>//Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</i>
   18:  invokevirtual   #51; <i>//Method java/lang/StringBuilder.toString:()Ljava/lang/String;</i>
   21:  invokevirtual   #31; <i>//Method java/io/PrintStream.println:(Ljava/lang/String;)V</i>
   24:  return
&nbsp;
<strong>public static void printY();</strong>
  Code:
   0:   getstatic       #23; <i>//Field java/lang/System.out:Ljava/io/PrintStream;</i>
   3:   new     #37;         <i>//class java/lang/StringBuilder</i>
   6:   dup
   7:   ldc     #54;         <i>//String Field Test.y = </i>
   9:   invokespecial   #41; <i>//Method java/lang/StringBuilder."&lt;init&gt;":(Ljava/lang/String;)V</i>
   12:  getstatic       #56; <i>//Field y:I</i>
   15:  invokevirtual   #47; <i>//Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</i>
   18:  invokevirtual   #51; <i>//Method java/lang/StringBuilder.toString:()Ljava/lang/String;</i>
   21:  invokevirtual   #31; <i>//Method java/io/PrintStream.println:(Ljava/lang/String;)V</i>
   24:  return
&nbsp;
}
&nbsp;
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Nová struktura bajtkódu tøídy <strong>Test</strong> </h2>

<p>Nová struktura bajtkódu tøídy <strong>Test</strong> vypadá po jeho
modifikaci a ulo¾ení nástrojem <i>Javassist</i> následovnì:</p>

<pre>
Compiled from "Test.java"
public class Test extends java.lang.Object{
&nbsp;
<strong>public static int x;</strong>
&nbsp;
<strong>public static int y;</strong>
&nbsp;
public Test();
  Code:
   0:   aload_0
   1:   invokespecial   #12; <i>//Method java/lang/Object."&lt;init&gt;":()V</i>
   4:   return
&nbsp;
<strong>public static void foo();</strong>
  Code:
   0:   getstatic       #23; <i>//Field java/lang/System.out:Ljava/io/PrintStream;</i>
   3:   ldc     #25;         <i>//String Method 'foo' called!</i>
   5:   invokevirtual   #31; <i>//Method java/io/PrintStream.println:(Ljava/lang/String;)V</i>
   8:   return
&nbsp;
<strong>public static void bar();</strong>
  Code:
   0:   getstatic       #23; <i>//Field java/lang/System.out:Ljava/io/PrintStream;</i>
   3:   ldc     #34;         <i>//String Method 'bar' called!</i>
   5:   invokevirtual   #31; <i>//Method java/io/PrintStream.println:(Ljava/lang/String;)V</i>
   8:   return
&nbsp;
<strong>public static void printX();</strong>
  Code:
   0:   getstatic       #23; <i>//Field java/lang/System.out:Ljava/io/PrintStream;</i>
   3:   new     #37;         <i>//class java/lang/StringBuilder</i>
   6:   dup
   7:   ldc     #39;         <i>//String Field Test.x = </i>
   9:   invokespecial   #41; <i>//Method java/lang/StringBuilder."&lt;init&gt;":(Ljava/lang/String;)V</i>
   12:  getstatic       #43; <i>//Field x:I</i>
   15:  invokevirtual   #47; <i>//Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</i>
   18:  invokevirtual   #51; <i>//Method java/lang/StringBuilder.toString:()Ljava/lang/String;</i>
   21:  invokevirtual   #31; <i>//Method java/io/PrintStream.println:(Ljava/lang/String;)V</i>
   24:  return
&nbsp;
<strong>public static void printY();</strong>
  Code:
   0:   getstatic       #23; <i>//Field java/lang/System.out:Ljava/io/PrintStream;</i>
   3:   new     #37;         <i>//class java/lang/StringBuilder</i>
   6:   dup
   7:   ldc     #54;         <i>//String Field Test.y = </i>
   9:   invokespecial   #41; <i>//Method java/lang/StringBuilder."&lt;init&gt;":(Ljava/lang/String;)V</i>
   12:  getstatic       #56; <i>//Field y:I</i>
   15:  invokevirtual   #47; <i>//Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</i>
   18:  invokevirtual   #51; <i>//Method java/lang/StringBuilder.toString:()Ljava/lang/String;</i>
   21:  invokevirtual   #31; <i>//Method java/io/PrintStream.println:(Ljava/lang/String;)V</i>
   24:  return
&nbsp;
}
</pre>

<p>Pro lep¹í èitelnost lze rozdíly mezi obìma strukturami získat nástrojem
<strong>diff</strong> (pou¾it je unifikovaný výstup, který je podle mého názoru
nejèitelnìj¹í):</p>

<pre>
--- Test1.out	Sat Jul 27 22:24:03 2013
+++ Test2.out	Sat Jul 27 22:24:20 2013
@@ -2,7 +2,7 @@
 public class Test extends java.lang.Object{
 public static int x;
&nbsp; 
<strong>-private static int y;</strong>
<strong>+public static int y;</strong>
 &nbsp; 
 public Test();
   Code:
@@ -17,7 +17,7 @@
    5:	invokevirtual	#31; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
    8:	return
 &nbsp; 
<strong>-private static void bar();</strong>
<strong>+public static void bar();</strong>
   Code:
    0:	getstatic	#23; //Field java/lang/System.out:Ljava/io/PrintStream;
    3:	ldc	#34; //String Method 'bar' called!
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Repositáø se zdrojovými kódy dne¹ního demonstraèního pøíkladu </h2>

<p>Následuje &ndash; v&nbsp;tomto seriálu ji¾ tradièní &ndash; kapitola
s&nbsp;odkazy na zdrojové kódy. Dnes popsaný demonstraèní pøíklad je spoleènì
s&nbsp;dal¹ími pomocnými skripty ulo¾en do Mercurial repositáøe dostupného na
adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
V&nbsp;následující tabulce najdete odkazy na prozatím nejnovìj¹í verze tìchto
zdrojových kódù:</p>

<table>
<tr><th>#</th><th>Zdrojový soubor/skript</th><th>Umístìní souboru v&nbsp;repositáøi</th></tr>
<tr><td>1</td><td>ClassModification1.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/bb4b70008ff8/javassist/ClassModification1/ClassModification1.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/bb4b70008ff8/javassist/ClassModification1/ClassModification1.java</a></td></tr>
<tr><td>2</td><td>buildClassModification1.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/bb4b70008ff8/javassist/ClassModification1/buildClassModification1.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/bb4b70008ff8/javassist/ClassModification1/buildClassModification1.sh</a></td></tr>
<tr><td>3</td><td>runClassModification1.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/bb4b70008ff8/javassist/ClassModification1/runClassModification1.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/bb4b70008ff8/javassist/ClassModification1/runClassModification1.sh</a></td></tr>
<tr><td>4</td><td>Test.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/bb4b70008ff8/javassist/ClassModification1/Test.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/bb4b70008ff8/javassist/ClassModification1/Test.java</a></td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu </h2>

<ol>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (pøed verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

