<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Novinky v&nbsp;JDK 7 aneb mírný pokrok v&nbsp;mezích zákona (4) &ndash; projekt Lambda</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Novinky v&nbsp;JDK 7 aneb mírný pokrok v&nbsp;mezích zákona &ndash; projekt Lambda</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve ètvrté èásti seriálu o nových vlastnostech programovacího jazyka Java i jeho virtuálního stroje si øekneme základní informace o projektu Lambda, který sice není &ndash; a po pøijetí plánu &bdquo;B&ldquo; ani nebude &ndash; oficiální souèástí JDK 7, ov¹em tento projekt je mo¾né pomìrnì snadným zpùsobem doinstalovat a odzkou¹et i na souèasné verzi JDK 7 nebo OpenJDK 7.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. JDK 7 a projekt Lambda</a></p>
<p><a href="#k02">2. Aplikace a utility nutné pro instalaci projektu Lambda</a></p>
<p><a href="#k03">3. Instalace projektu Lambda</a></p>
<p><a href="#k04">4. Postupný vývoj syntaxe a sémantiky pou¾ité pro zápis anonymních funkcí</a></p>
<p><a href="#k05">5. Návrh Marka Reinholda (Sun, Oracle) &ndash; slavný &bdquo;straw-man proposal&ldquo;</a></p>
<p><a href="#k06">6. Problematické èásti návrhu Marka Reinholda aneb lze vùbec vhodnì zaøadit lambda výrazy do Javy?</a></p>
<p><a href="#k07">7. Souèasná podoba implementace anonymních funkcí</a></p>
<p><a href="#k08">8. SAM a jejich inicializace</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2>1. JDK 7 a projekt Lambda</h2>

<p>V&nbsp;závìreèné kapitole
<a href="http://www.root.cz/clanky/novinky-v-nbsp-jdk-7-3-co-v-nbsp-jdk-7-naopak-nenajdeme/">
pøedchozí èásti</a> miniseriálu o novinkách,
s&nbsp;nimi¾ se mù¾eme setkat v&nbsp;<i>JDK 7</i> nebo které jsou teprve
pøipravovány v&nbsp;rámci budoucích verzí <i>JDK 8</i> a <i>JDK 9</i>, jsme se
takté¾ zmínili o projektu <i>Lambda</i>. Hlavním cílem tohoto projektu je
roz¹íøení syntaxe a sémantiky programovacího jazyka <i>Java</i> o takzvané
<i>anonymní funkce</i> a s&nbsp;nimi souvisejícími <i>uzávìry (closures)</i>.
Kromì tìchto dvou zejména sémantických zmìn se do jazyka zavedl nový datový typ
&bdquo;funkce&ldquo;, který roz¹iøuje stávající repertoár primitivních datových
typù a referencí na objekty. Spolu s&nbsp;tìmito zmìnami se zjednodu¹ila práce
s&nbsp;anonymními tøídami implementujícími pouze jednu metodu (tøídy
s&nbsp;tìmito vlastnostmi se nazývají <i>Single Abstract Method</i> neboli
<i>SAM</i>). Projekt <i>Lambda</i> sice nakonec nebude souèástí <i>JDK 7</i>,
ov¹em vzhledem k&nbsp;tomu, ¾e anonymní funkce a uzávìry pøedstavují pomìrnì
revoluèní zmìnu v&nbsp;jazyku <i>Java</i>, uká¾eme si v&nbsp;následujících
kapitolách, jakým zpùsobem je mo¾né tento projekt vyu¾ít ji¾ dnes a jaké
mo¾nosti programátorùm nabízí.</p>

<p>Zatímco prakticky v¹echny syntaktické novinky pøedstavené v&nbsp;pøedchozích
tøech èástech tohoto seriálu byly vlastnì pouze evoluèní (syntaktický cukr,
popø.&nbsp;roz¹íøení nìkteré ji¾ existující jazykové konstrukce), je zavedení
anonymních funkcí a uzávìrù spí¹e revoluce, alespoò na poli <i>Javy</i>. Tro¹ku
se tím potvrzuje známé motto, ¾e v¹echny jazyky postupným vývojem a
vylep¹ováním èasem dospìjí k&nbsp;<i>LISPu</i> :-), i kdy¾ <i>LISP</i>
samozøejmì není jediným jazykem, v&nbsp;nìm¾ se anonymní funkce a uzávìry
pou¾ívají (byl v¹ak jazykem prvním, který tyto vlastnosti podporoval). Anonymní
funkce, té¾ známé jako <i>lambda výrazy</i>, jsou v¹ak v&nbsp;<i>Javì</i>
zvlá¹tní tím, ¾e jsou staticky typované (specifikuje se jak typ lambda výrazu,
tak i typy jeho parametrù &ndash; v¹e v&nbsp;rámci hlavièky metody uvedené
v&nbsp;abstraktní tøídì nebo rozhraní), zatímco klasické lambda výrazy známe
spí¹e z&nbsp;dynamicky typovaných programovacích jazykù. Jak uvidíme
v&nbsp;dal¹ím textu, mají typované lambda výrazy oproti svým obecným protìj¹kùm
(kde se kontroly typù provádí a¾ v&nbsp;dobì bìhu programu), nìkteré výhody,
ale takté¾ zápory.</p>



<p><a name="k02"></a></p>
<h2>2. Aplikace a utility nutné pro instalaci projektu Lambda</h2>

<p>Projekt <i>Lambda</i> sice není a ani nebude souèástí oficiálního vydání
<i>JDK 7</i>, ov¹em pomìrnì jednoduchým zpùsobem je mo¾né si tento projekt
nainstalovat souèasnì s&nbsp;nìkterou z&nbsp;aktuálních verzí <i>JDK 7</i>
nabízených firmou Oracle na této stránce: <a
href="http://dlc.sun.com.edgesuite.net/jdk7/binaries/index.html">http://dlc.sun.com.edgesuite.net/jdk7/binaries/index.html</a>.
Pokud nechcete ve va¹em systému pou¾ívat binární uzavøené aplikace, je
samozøejmì mo¾né si nainstalovat nebo pøelo¾it <i>OpenJDK 7</i>, viz té¾ návod
uvedený na stránce <a
href="http://hg.openjdk.java.net/jdk7/build/raw-file/tip/README-builds.html">http://hg.openjdk.java.net/jdk7/build/raw-file/tip/README-builds.html</a>.
V&nbsp;dal¹ím textu si uká¾eme postup instalace projektu <i>Lambda</i>, který
je mo¾né pou¾ít jak spoleènì s&nbsp;<i>JDK 7</i>, tak i s&nbsp;pøedem
pøelo¾eným <i>OpenJDK 7</i>. Pro úspì¹ný pøeklad a následné vyu¾ití projektu
<i>Lambda</i> je nutné, aby ve va¹em systému byly nainstalovány následující
aplikace a utility:</p>

<ol>

<li><strong>JDK 6</strong>, <strong>OpenJDK 6</strong> nebo <strong>IcedTea
6</strong> &ndash; pou¾ito spoleènì s&nbsp;utilitou <strong>Ant</strong> pøi
pøekladu projektu <i>Lambda</i> (OpenJDK 6 resp.&nbsp;pøesnìji øeèeno IcedTea 6
se nachází v&nbsp;repositáøích prakticky v¹ech významných Linuxových
distribucí, tak¾e by s&nbsp;její instalací nemìl být problém).</li>

<li><strong>JDK 7</strong> nebo <strong>OpenJDK 7</strong> (postaèuje lokální
instalace, získaná napøíklad rozbalením archivu sta¾eného <a
href="http://dlc.sun.com.edgesuite.net/jdk7/binaries/index.html">ze stránek
spoleènosti Oracle</a>) &ndash; tato verze JDK je pou¾ívána <strong>a¾</strong>
pøi pøekladu Javovských programù vyu¾ívajících projekt <i>Lambda</i></li>

<li><strong>Ant</strong> ve verzi alespoò 1.7.0</li>

<li><strong>Mercurial</strong> &ndash; tento nástroj pro správu verzí (podobný
GIT, ale na rozdíl od nìj napsaný v&nbsp;Pythonu) je pou¾it pro sta¾ení
posledního snapshotu projektu Lambda. Ostatnì v¹echny zdrojové kódy OpenJDK,
IcedTea i podpùrných nástrojù jsou <a
href="http://hg.openjdk.java.net/">dostupné</a> právì v&nbsp;úlo¾i¹tích
spravovaných pomocí tohoto nástroje (z&nbsp;pøíkazové øádky se volá pøíkazem
<strong>hg</strong>, a asi není tì¾ké uhodnout, proè byl zvolen zrovna tento
název).</li>

</ol>



<p><a name="k03"></a></p>
<h2>3. Instalace projektu Lambda</h2>

<p>Pokud ji¾ máte v&nbsp;systému nainstalovány v¹echny nástroje zmínìné
v&nbsp;pøedchozí kapitole, je mo¾né provést sta¾ení zdrojových kódù projektu
<i>Lambda</i> a k&nbsp;nìmu pøíslu¹ných nástrojù (napøíklad se jedná o pomìrnì
rozsáhlou sadu testù). To lze provést následujícím pøíkazem:</p>

<pre>
hg clone http://hg.openjdk.java.net/lambda/lambda/langtools
</pre>

<p>Popø.&nbsp;lze zdrojové kódy ruènì stáhnout ze stránky <a
href="http://hg.openjdk.java.net/lambda/lambda/langtools">http://hg.openjdk.java.net/lambda/lambda/langtools</a>
a poté rozbalit vhodným nástrojem (unzip, tar), v&nbsp;závislosti na tom, který
typ archivu byl sta¾en. Po sta¾ení zdrojových kódù z&nbsp;úlo¾i¹tì by se mìl
v&nbsp;aktuálním adresáøi objevit podadresáø <strong>langtools</strong>. Pokud
se skuteènì tento adresáø objevil i s&nbsp;pøíslu¹nými soubory a podadresáøi,
lze pokraèovat v&nbsp;pøekladu. Nejprve se musíme dostat do adresáøe
obsahujícího <strong>build.xml</strong>:</p>

<pre>
cd langtools/make
</pre>

<p>... a v&nbsp;tomto adresáøi spustit pøíkaz <strong>ant</strong>, kterému se
ve dvou parametrech <strong>boot.java.home</strong> a
<strong>target.java.home</strong> pøedá cesta k&nbsp;nainstalované <i>JDK
6/OpenJDK 6/IcedTea 6</i> a cesta k&nbsp;(vìt¹inou pouze lokální) instalaci
<i>JDK 7/OpenJDK 7</i>. Pov¹imnìte si, ¾e cesta k&nbsp;lokální instalaci <i>JDK
7</i> je v&nbsp;ní¾e uvedeném pøíkladu zadána absolutnì. I kdy¾ by teoreticky
mìlo postaèovat zadat pouze <strong>~/jdk7/jdk1.7.0</strong>, nebudou
v&nbsp;tomto pøípadì spou¹tìcí skripty projektu <i>Lambda</i> pracovat korektnì
(tato chyba se projevila je¹tì ve vèerej¹ím snapshotu, i kdy¾ je mo¾né, ¾e ji¾
bude v&nbsp;dobì vydání tohoto èlánku opravena). Spus»me tedy vlastní
pøeklad:</p>

<pre>
ant -Dboot.java.home=/usr/lib/jvm/java-6-openjdk/ -Dtarget.java.home=/home/pavel/jdk7/jdk1.7.0/ build-all-tools
</pre>

<p>Pøeklad by mìl být na souèasných poèítaèích dokonèen maximálnì za nìkolik
desítek sekund. Èas v&nbsp;následujícím výpisu 2:13 platí pro dnes ji¾ ponìkud
dýchavièný poèítaè s&nbsp;mikroprocesorem Athlon &bdquo;Classic&ldquo; @800 MHz
s&nbsp;512 MB RAM (dùle¾itý v¹ak není èas pøekladu, ale hlá¹ení <strong>BUILD
SUCCESSFUL</strong> :-):</p>

<pre>
Buildfile: build.xml

-def-pcompile:
    [mkdir] Created dir: /home/pavel/jdk7/langtools/build/toolclasses
    [javac] Compiling 2 source files to /home/pavel/jdk7/langtools/build/toolclasses

-def-build-classes:

-def-build-bootstrap-classes:

-def-build-jar:

-def-build-bootstrap-jar:

-def-check:

-check-boot.java.home:

-def-build-tool:

-def-build-bootstrap-tool:

build-bootstrap-javac:
    [mkdir] Created dir: /home/pavel/jdk7/langtools/build/bootstrap/gensrc
    [mkdir] Created dir: /home/pavel/jdk7/langtools/build/bootstrap/classes
 [pcompile] Generating 7 resource files to /home/pavel/jdk7/langtools/build/bootstrap/gensrc
     [copy] Copying 1 file to /home/pavel/jdk7/langtools/build/bootstrap/gensrc
 [pcompile] Generating 1 resource files to /home/pavel/jdk7/langtools/build/bootstrap/gensrc
    [javac] Compiling 297 source files to /home/pavel/jdk7/langtools/build/bootstrap/classes
     [copy] Copying 3 files to /home/pavel/jdk7/langtools/build/bootstrap/classes
    [mkdir] Created dir: /home/pavel/jdk7/langtools/build/bootstrap/lib
      [jar] Building jar: /home/pavel/jdk7/langtools/build/bootstrap/lib/javac.jar
    [mkdir] Created dir: /home/pavel/jdk7/langtools/build/bootstrap/bin
     [copy] Copying 1 file to /home/pavel/jdk7/langtools/build/bootstrap/bin

-def-genstubs:

-create-import-jdk-stubs:

build-classes-javac:
    [mkdir] Created dir: /home/pavel/jdk7/langtools/build/gensrc
    [mkdir] Created dir: /home/pavel/jdk7/langtools/build/classes
 [pcompile] Generating 7 resource files to /home/pavel/jdk7/langtools/build/gensrc
     [copy] Copying 1 file to /home/pavel/jdk7/langtools/build/gensrc
 [pcompile] Generating 1 resource files to /home/pavel/jdk7/langtools/build/gensrc
    [javac] Compiling 297 source files to /home/pavel/jdk7/langtools/build/classes
     [copy] Copying 3 files to /home/pavel/jdk7/langtools/build/classes

-def-build-java-launcher:

build-javac:
    [mkdir] Created dir: /home/pavel/jdk7/langtools/dist/lib
      [jar] Building jar: /home/pavel/jdk7/langtools/dist/lib/javac.jar
    [mkdir] Created dir: /home/pavel/jdk7/langtools/dist/bin
     [copy] Copying 1 file to /home/pavel/jdk7/langtools/dist/bin
     [copy] Copying 1 file to /home/pavel/jdk7/langtools/dist/bin

build-classes-javadoc:
 [pcompile] Generating 3 resource files to /home/pavel/jdk7/langtools/build/gensrc
    [javac] Compiling 72 source files to /home/pavel/jdk7/langtools/build/classes

build-javadoc:
      [jar] Building jar: /home/pavel/jdk7/langtools/dist/lib/javadoc.jar
     [copy] Copying 1 file to /home/pavel/jdk7/langtools/dist/bin

build-classes-doclets:
 [pcompile] Generating 6 resource files to /home/pavel/jdk7/langtools/build/gensrc
    [javac] Compiling 132 source files to /home/pavel/jdk7/langtools/build/classes
     [copy] Copying 2 files to /home/pavel/jdk7/langtools/build/classes

build-doclets:
      [jar] Building jar: /home/pavel/jdk7/langtools/dist/lib/doclets.jar

build-classes-javah:
 [pcompile] Generating 3 resource files to /home/pavel/jdk7/langtools/build/gensrc
     [copy] Copying 1 file to /home/pavel/jdk7/langtools/build/gensrc
 [pcompile] Generating 1 resource files to /home/pavel/jdk7/langtools/build/gensrc
    [javac] Compiling 16 source files to /home/pavel/jdk7/langtools/build/classes

build-javah:
      [jar] Building jar: /home/pavel/jdk7/langtools/dist/lib/javah.jar
     [copy] Copying 1 file to /home/pavel/jdk7/langtools/dist/bin

build-classes-javap:
 [pcompile] Generating 1 resource files to /home/pavel/jdk7/langtools/build/gensrc
     [copy] Copying 1 file to /home/pavel/jdk7/langtools/build/gensrc
 [pcompile] Generating 1 resource files to /home/pavel/jdk7/langtools/build/gensrc
    [javac] Compiling 75 source files to /home/pavel/jdk7/langtools/build/classes
     [copy] Copying 1 file to /home/pavel/jdk7/langtools/build/classes

build-javap:
      [jar] Building jar: /home/pavel/jdk7/langtools/dist/lib/javap.jar
     [copy] Copying 1 file to /home/pavel/jdk7/langtools/dist/bin

build-classes-apt:
 [pcompile] Generating 3 resource files to /home/pavel/jdk7/langtools/build/gensrc
    [javac] Compiling 109 source files to /home/pavel/jdk7/langtools/build/classes
    [javac] Note: Some input files use or override a deprecated API.
    [javac] Note: Recompile with -Xlint:deprecation for details.
     [copy] Copying 1 file to /home/pavel/jdk7/langtools/build/classes

build-apt:
      [jar] Building jar: /home/pavel/jdk7/langtools/dist/lib/apt.jar
     [copy] Copying 1 file to /home/pavel/jdk7/langtools/dist/bin

build-all-tools:

BUILD SUCCESSFUL
Total time: 2 minutes 13 seconds
</pre>

<p>V&nbsp;adresáøi <strong>langtools</strong> by se po pøekladu mìly
mj.&nbsp;objevit i nové podadresáøe pojmenované <strong>dist/bin/</strong> a
<strong>dist/lib/</strong>. Nás bude zajímat pøedev¹ím adresáø
<strong>dist/bin</strong>, v&nbsp;nìm¾ se nachází skripty pojmenované
<strong>java</strong>, <strong>javac</strong> atd., které volají stejnì
pojmenované nástroje z&nbsp;<i>JDK 7</i>, ov¹em s&nbsp;vhodnì nastavenými
cestami k&nbsp;javovským knihovnám, v&nbsp;nich¾ je projekt <i>Lambda</i>
implementován. Demonstraèní pøíklady uvedené v&nbsp;následujících kapitolách
tedy budeme pøekládat skriptem <strong>langtools/dist/bin/javac</strong> a
výsledný pøelo¾ený bajtkód se bude spou¹tìt pomocí
<strong>langtools/dist/bin/java</strong>!</p>



<p><a name="k04"></a></p>
<h2>4. Postupný vývoj syntaxe a sémantiky pou¾ité pro zápis anonymních funkcí</h2>

<p>O mo¾nostech pøidání podpory pro anonymní funkce a uzávìry do programovacího
jazyka Java se hovoøilo ji¾ nìkolik let, minimálnì od doby, kdy zaèaly vznikat
dynamicky typované programovací jazyky <a
href="http://en.wikipedia.org/wiki/List_of_JVM_languages">urèené pro bìh nad
virtuálním strojem Javy</a> (JVM). Jedná se pøedev¹ím o jazyky
<a href="http://www.jython.org/">Jython</a> (1997),
<a href="http://groovy.codehaus.org/">Groovy</a> (2003),
<a href="http://www.scala-lang.org/">Scala</a> (2004),
<a href="http://www.jruby.org/">JRuby</a> (2006),
<a href="http://www.mozilla.org/rhino/">JavaScript</a> (Rhino) a
v&nbsp;neposlední øadì takté¾ o dialekt Lispu nazvaný <a
href="http://clojure.org/">Clojure</a> (2007). Ov¹em teprve v&nbsp;roce 2008
vzniklo nìkolik návrhù syntaxe a sémantiky pou¾ité jak pøi definici anonymních
funkcí, tak i pøi jejich volání. Tyto návrhy nejsou vzájemnì kompatibilní
&ndash; netýká se to pouze syntaxe (ta je v&nbsp;podstatì pomìrnì nedùle¾itá, i
kdy¾ viditelná ve zdrojových kódech), ale pøedev¹ím sémantiky,
tj.&nbsp;vlastností anonymních funkcí a zpùsobù jejich pou¾ití. Jednotlivé
návrhy pro zavedení podpory anonymních funkcí do Javy lze získat v&nbsp;mnoha
formách (blogy, prezentace, èlánky). Oficiální podoba návrhù je dostupná na
tìchto odkazech:</p>

<ol>

<li>Concise Instance Creation Expressions: Closures without Complexity<br />
<a href="http://docs.google.com/Doc.aspx?id=k73_1ggr36h">http://docs.google.com/Doc.aspx?id=k73_1ggr36h</a>
</li>

<li>Closures for the Java Programming Language (v0.5)<br />
<a href="http://www.javac.info/closures-v05.html">http://www.javac.info/closures-v05.html</a>
</li>

<li>First-class methods: Java-style closures<br />
<a href="https://docs.google.com/Doc?id=ddhp95vd_6hg3qhc">https://docs.google.com/Doc?id=ddhp95vd_6hg3qhc</a>
</li>

<li>Project Lambda: Straw-Man Proposal<br />
<a href="http://cr.openjdk.java.net/~mr/lambda/straw-man/">http://cr.openjdk.java.net/~mr/lambda/straw-man/</a>
</li>

</ol>

<p>Dal¹í zajímavé dokumenty, které se týkají anonymních funkcí v&nbsp;Javì, lze
najít zde:</p>

<ol>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

</ol>



<p><a name="k05"></a></p>
<h2>5. Návrh Marka Reinholda (Sun, Oracle) &ndash; slavný &bdquo;straw-man proposal&ldquo;</h2>

<p>Velmi zajímavý byl <a
href="http://cr.openjdk.java.net/~mr/lambda/straw-man/">návrh implementace
anonymních funkcí</a> pocházející od <i>Marka Reinholda</i> z&nbsp;firmy Sun
Microsystems a pozdìji Oracle. Tento návrh je známý také pod jménem
&bdquo;straw-man proposal&ldquo; (Mark ho prý vytvoøil pomìrnì rychle
v&nbsp;letadle pøi cestì na konferenci). V&nbsp;této variantì implementace
anonymních funkcí je mo¾né vytváøet lambda výrazy v&nbsp;jediném øádku a
následnì (pokud je to samozøejmì zapotøebí) pøiøadit lambda výraz do promìnné
nebo atributu mající speciální typ. Ka¾dý lambda výraz mìl v&nbsp;tomto návrhu
následující podobu:</p>

<pre>
#(parametry) (tìlo výrazu bez explicitního pøíkazu return)
#(parametry) {tìlo výrazu s pøíkazem return}
</pre>

<p>Pøi pohledu na pøedchozí ukázku si mù¾eme pov¹imnout, ¾e znak # nahrazuje
symbol &lambda; a parametry (v&nbsp;lambda kalkulu se nazývají vázané promìnné)
jsou od tìla výrazu oddìleny pomocí kulatých závorek, které nahrazují symbol
teèky, je¾ se pou¾ívá v&nbsp;<i>lambda kalkulu</i> (v&nbsp;jiných
programovacích jazycích a takté¾ v&nbsp;návrhu popsaném v&nbsp;dal¹ích
kapitolách se mù¾eme setkat napøíklad s&nbsp;pou¾itím symbolù =&gt; nebo
-&gt;). Lambda výraz bylo mo¾né pøiøadit do promìnné èi atributu s&nbsp;typem,
který se zapisoval následovnì:</p>

<pre>
#typ_návratové_hodnoty(seznam typù parametrù lambda výrazu)
</pre>

<p>Pokud se anonymní funkce pøiøazená do promìnné èi atributu mìla skuteènì
zavolat, musel se za její jméno a pøed skuteèné parametry vlo¾it znak
teèky:</p>

<pre>
lambda_výraz.(skuteèné parametry)
</pre>

<p>Uka¾me si nyní nìkolik pøíkladù:</p>

<p>Lambda výraz bez parametrù vracející konstantu:</p>

<pre>
#() (42)
</pre>

<p>Lambda výraz s&nbsp;jedním parametrem, pouze zapsaný a nikam nepøiøazený,
nevyhodnocovaný:</p>

<pre>
#(int x) (x+1);
</pre>

<p>Lambda výraz s&nbsp;dvojicí parametrù:</p>

<pre>
#(int x, int y) (x*y);
</pre>

<p>Zachycení promìnné z&nbsp;obalujícího lexikálního rozsahu platnosti:</p>

<pre>
int y = 42;
inc = #(int x) (x+y);
</pre>

<p>Lambda výraz s&nbsp;tìlem obsahujícím více pøíkazù a explicitní return:</p>

<pre>#(int x, int y){ int z = expensiveComputation(x, y);
                 if (z &lt; 0) return x;
                 if (z &lt; 0) return y;
                 return 0; }
</pre>

<p>Pøiøazení lambda výrazu do promìnné èi atributu (pov¹imnìte si typu této
promìnné/atributu):</p>

<pre>
#int(int) inc = #(int x) (x+1);
</pre>

<p>Vyhodnocení lambda výrazu (s&nbsp;teèkou pøed závorkou s&nbsp;parametry!):</p>

<pre>
int y = inc.(42)
</pre>



<p><a name="k06"></a></p>
<h2>6. Problematické èásti návrhu Marka Reinholda aneb lze vùbec vhodnì zaøadit lambda výrazy do Javy?</h2>

<p>V&nbsp;Markovì návrhu si mù¾eme v¹imnout nìkolika problematických èástí
vyplývajících pøedev¹ím ze stávající syntaxe a sémantiky programovacího jazyka
Java. Pomìrnì mnoho komentátorù tohoto návrhu si napøíklad pøálo, aby se
namísto znaku # pou¾il znak $, nebo aby se pøímo psalo nové klíèové slovo
<strong>lambda</strong>. Pøidání nového klíèového slova by v¹ak bylo
problematické, proto¾e by mohlo dojít ke komplikacím pøi pou¾ití aplikací,
v&nbsp;jejich¾ zdrojových textech se tento identifikátor pou¾ívá pro
pojmenování promìnných, atributù, metod, rozhraní nebo tøíd (snaha o
minimalizaci zásahu do této èásti syntaxe jazyka je zøejmá u¾ jen pøi pohledu
na to, kolik rùzných významù nakonec získalo klíèové slovo
<strong>final</strong>). Podobnì problematická je v¹ak i zmìna významu znaku $,
proto¾e tento znak mù¾e být (i kdy¾ se jedná o pomìrnì neznámou a málo
pou¾ívanou vlastnost) souèástí identifikátorù. Následující pøíklad je zcela
legálním a korektním Javovským programem:</p>

<pre>
class $
{
}

public class DolarTest
{
    private int $ = 42;
    private int $_$ = 6502;
    private $ $1 = new $();

    private int $$(int $)
    {
        return $&lt;&lt;1;
    }
}
</pre>

<p>Druhý problém nastal pøi návrhu zpùsobu volání lambda výrazu pøiøazeného do
promìnné. V&nbsp;tomto pøípadì bylo nutné volání lambda výrazu odli¹it od
volání funkce a to z&nbsp;jednoduchého dùvodu &ndash; programovací jazyk Java
má toti¾ oddìlené jmenné prostory pro atributy, promìnné a funkce, co¾
napøíklad znamená, ¾e je mo¾né napsat a pøelo¾it následující program:</p>

<pre>
public class NamespaceTest
{
    // jmenný prostor atributù
    public int foo = 42;

    // jmenný prostor funkcí je oddìlený:
    // - nenastane kolize jmen
    public int foo()
    {
        return this.foo;
    }

    public static void main(String[] args)
    {
        NamespaceTest test = new NamespaceTest();
        System.out.println(test.foo);
        System.out.println(test.foo());
    }
}
</pre>

<p>Pov¹imnìte si zejména toho, jakým zpùsobem pøekladaè rozli¹í pøi volání
metody <strong>System.out.println()</strong>, zda má vytisknout hodnotu
atributu <strong>foo</strong> nebo návratovou hodnotu metody
<strong>foo()</strong>. Pøi zavedení nového typu lambda výrazù pøiøazených do
atributù/promìnných, se v¹ak musí volání lambda výrazu odli¹it od volání
funkce:</p>

<pre>
public class Incrementer
{
    private static #int(int) inc = #(int x) (x+1);

    private static int inc(int x)
    {
        return x + 2;
    }

    public static void main(String[] args)
    {
        // vypise se 4 nebo 5?
        System.out.println(Incrementer.inc(3));
    }
}
</pre>

<p>Právì z&nbsp;tohoto dùvodu Mark navrhl pou¾ití teèky pøed výrazem, aby se
jeho identifikátor mohl odli¹it od shodného identifikátoru funkce.
S&nbsp;pou¾itím teèky je v¹e zøejmé, i kdy¾ na úkor &bdquo;divné&ldquo;
syntaxe:</p>

<pre>
public class Incrementer
{
    private static #int(int) inc = #(int x) (x+1);

    private static int inc(int x)
    {
        return x + 2;
    }

    public static void main(String[] args)
    {
        // vypise se 4 - vola se metoda inc()
        System.out.println(Incrementer.inc(3));
        // vypise se 5 - vyvola se lambda vyraz
        System.out.println(Incrementer.inc.(3));
    }
}
</pre>



<p><a name="k07"></a></p>
<h2>7. Souèasná podoba implementace anonymních funkcí</h2>

<p>I pøes nìkteré pøednosti návrhu Marka Reinholda byla nakonec pro projekt
<i>Lambda</i> vybrána mnohem jednodu¹¹í syntaxe a sémantika zápisu anonymních
funkcí. Tvùrci této varianty nechtìli, aby se pøidání anonymních funkcí do
<i>Javy</i> projevilo v&nbsp;nutnosti zmìn ve struktuøe generovaného bajtkódu a
takté¾ nechtìli do jazyka pøinést mnoho zcela nových konstrukcí (viz ukázky
z&nbsp;pøedchozí kapitoly). Z&nbsp;tohoto dùvodu jsou anonymní funkce
v&nbsp;souèasné verzi projektu <i>Lambda</i> internì reprezentovány jako
anonymní tøídy s&nbsp;jedinou metodou. Anonymní tøídy jsou samozøejmì souèástí
Javy ji¾ od verze 1.1, ov¹em jejich pou¾ití v&nbsp;praxi je pomìrnì slo¾ité a
pøedev¹ím nepøehledné &ndash; pro vytvoøení instance dané tøídy se toti¾
pou¾ívá následující nepøíli¹ èitelná konstrukce:</p>

<pre>
new Comparator&lt;String&gt;() {
    // konkrétní implementace metody compare,
    // její¾ hlavièka je umístìna v rozhraní
    // nebo abstraktní tøídì Comparator
    public int compare(String str1, String str2) {
        return str1.length() - str2.length();
    }
}
</pre>

<p>Metoda v&nbsp;anonymní tøídì má pøístup k&nbsp;atributùm své obalující
tøídy:</p>

<pre>
new MouseAdapter() {
    public void mouseClicked(MouseEvent e) {
        if (e.getButton() == MouseEvent.NOBUTTON)
        {
            textArea.setText("No button clicked...");
        } else if (e.getButton() == MouseEvent.BUTTON1) {
            textArea.setText("Button 1 clicked...");
        } else if (e.getButton() == MouseEvent.BUTTON2) {
            textArea.setText("Button 2 clicked...");
        } else if (e.getButton() == MouseEvent.BUTTON3) {
            textArea.setText("Button 3 clicked...");
        }
        textArea.append("Number of click: " + e.getClickCount());
        textArea.append("Click position (X, Y):  " + e.getX() + ", " + e.getY());
    }
}
</pre>

<p>Vývojáøi projektu <i>Lambda</i> provedli analýzu zdrojových kódù jak
standardních knihoven jazyka Java, tak i nìkterých dal¹ích vìt¹ích projektù
(napøíklad zdrojových kódù vývojového prostøedí <i>Netbeans</i>) a zjistili, ¾e
velká èást anonymních tøíd obsahuje pouze jedinou implementovanou metodu
&ndash; typickým pøíkladem je anonymní tøída implementující rozhraní
<strong>Runnable</strong>, <strong>Comparator</strong> (pokud se implementuje
pouze metoda <i>compare</i> a ne <i>equalTo</i>, co¾ není v¾dy nutné), vìt¹ina
listenerù pøi práci s&nbsp;grafickým u¾ivatelským rozhraním
(<strong>MouseListener</strong>), rùzné typy filtrù atd. Právì pøi tvorbì
tìchto typù anonymních tøíd, které jsou kvùli existenci jediné implementované
metody nìkdy nazývány <i>Single Abstract Method</i> neboli <i>SAM</i>, je mo¾né
pou¾ít programové konstrukce projektu <i>Lambda</i>.</p>



<p><a name="k08"></a></p>
<h2>8. SAM a jejich inicializace</h2>

<p>Podívejme se nyní, jakým zpùsobem by se dala vytvoøit jednoduchá anonymní
funkce (lambda výraz), která vrací svùj parametr zvìt¹ený o jednièku. Pro
jednoduchost pøedpokládejme, ¾e se jedná o celoèíselný parametr typu
<strong>int</strong>. V&nbsp;pojetí projektu <i>Lambda</i> je nejprve nutné
vytvoøit rozhraní nebo abstraktní tøídu s&nbsp;jedinou libovolnì pojmenovanou
metodou mající parametr typu <strong>int</strong> a vracející hodnotu typu
<strong>int</strong>:</p>

<pre>
interface SAM1
{
    int exec(int param);
}
</pre>

<p>popø. pokud ètenáø preferuje anonymní tøídy:</p>

<pre>
abstract class SAM2
{
    abstract int exec(int param);
}
</pre>

<p>Pro vytvoøení lambda výrazu lze vyu¾ít novou syntaxi:</p>

<pre>
SAM1 foo = #{ int x -&gt; x + 1 };
SAM2 bar = #{ int x -&gt; x * x };
</pre>

<p>A následnì vytvoøené lambda výrazy pou¾ít:</p>

<pre>
int x = foo.exec(10);
System.out.println(x);

System.out.println(bar2.exec(20));
</pre>

<p>Terminologie se nám ov¹em ponìkud komplikuje, proto¾e napøíklad promìnná
<strong>foo</strong> je <i>anonymní funkce (lambda výraz)</i>, který má <i>typ
rozhraní</i> SAM1 a je internì implementován jako <i>anonymní tøída</i> :-)</p>

<p>Uka¾me si je¹tì ponìkud slo¾itìj¹í pøíklad, kde je mj.&nbsp;ukázáno i
pou¾ití rozhraní <strong>Runnable</strong>:</p>

<pre>
// pøi práci s lambda výrazy prozatím nelze pou¾ít vnitøní abstraktní tøídy
abstract class SAM3
{
    abstract int method(int param);
}

public class LambdaTest
{
    interface SAM
    {
        int method(int param);
    }

    interface SAM2
    {
        int method(int x, int y);
    }

    public static void main(String[] args)
    {
        SAM sam1 = #{ int x -&gt; x + 1 };

        int x = sam1.method(10);
        System.out.println(x);
        System.out.println(sam1.method(42));

        SAM2 sam2 = #{ int x, int y -&gt; x * y };
        System.out.println(sam2.method(42, 3));

        Runnable r = #{ System.out.println("Blah") };
        r.run();

        SAM3 sam3 = #{ int x -&gt; x * x };
        System.out.println(sam3.method(42));
    }
}
</pre>

<p>Lambda výrazy samozøejmì mají pøístup k&nbsp;atributùm obalové tøídy, co¾
je, jak si øekneme pøí¹tì, pomìrnì dùle¾itá vlastnost:</p>

<pre>
public class LambdaTest2
{
    private int y = 0;

    interface SAM4
    {
        int exec(int param);
    }

    public void run()
    {
        SAM4 c = #{ int x -&gt; x + y };
        System.out.println(c.exec(10));
        y = 10;
        System.out.println(c.exec(10));
    }

    public static void main(String[] args)
    {
        new LambdaTest2().run();
    }
}
</pre>

<p>Prozatím mù¾e zavedení nové syntaxe vypadat jako pouhá hraèka pro milovníky
funkcionálních jazykù, ov¹em ve skuteènosti se jedná o velmi silnou a u¾iteènou
jazykovou konstrukci, její¾ význam si uká¾eme pøí¹tì. Jedním z&nbsp;pìkných
pøíkladù bude napøíklad implementace smyèky typu for-each, která se ve
skuteènosti bude moci provádìt paralelnì &ndash; ka¾dá iterace smyèky mù¾e
teoreticky probìhnout v&nbsp;samostatném vláknì na samostatném procesorovém
jádru.</p>



<p><a name="k09"></a></p>
<h2>9. Odkazy na Internetu</h2>

<ol>

<li>Java(TM) Platform, Standard Edition 7 Binary Snapshot Releases<br />
<a href="http://dlc.sun.com.edgesuite.net/jdk7/binaries/index.html">http://dlc.sun.com.edgesuite.net/jdk7/binaries/index.html</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>ClosableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>ArrayList (JDK 1.4)<br />
<a href="http://download.oracle.com/javase/1.4.2/docs/api/java/util/ArrayList.html">http://download.oracle.com/javase/1.4.2/docs/api/java/util/ArrayList.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2010</small></p>
</body>
</html>

