<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - instrukce invokedynamic</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - instrukce invokedynamic</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;dne¹ní èásti seriálu o programovacím jazyku Java i o vlastnostech virtuálního stroje tohoto jazyka se zamìøíme na popis nové instrukce nazvané pøíhodnì invokedynamic, která byla do JVM pøidána v&nbsp;rámci JDK 7 pøedev¹ím z&nbsp;dùvodu lep¹í podpory pøekladaèù dynamicky typovaných programovacích jazykù.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Ètyøi &bdquo;klasické&ldquo; instrukce bajtkódu JVM urèené pro volání metod</a></p>
<p><a href="#k02">2. Virtuální stroj Javy a pøekladaèe staticky typovaných programovacích jazykù</a></p>
<p><a href="#k03">3. Pou¾ití signatur metod pøi jejich volání</a></p>
<p><a href="#k04">4. Dùvody vedoucí k&nbsp;zavedení instrukce <strong>invokedynamic</strong></a></p>
<p><a href="#k05">5. Mo¾ná øe¹ení problému volání metod v&nbsp;dynamicky typovaných programovacích jazycích</a></p>
<p><a href="#k06">6. Instrukce <strong>invokedynamic</strong></a></p>
<p><a href="#k07">7. Dynamic call site (DCS)</a></p>
<p><a href="#k08">8. Novinky v&nbsp;bajtkódu Javy &ndash; nové typy záznamù v&nbsp;constant poolu</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Ètyøi &bdquo;klasické&ldquo; instrukce bajtkódu JVM urèené pro volání metod</h2>

<p>V&nbsp;závìru <a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-vliv-zmen-v-syntaxi-a-semantice-javy-na-strukturu-bajtkodu/">pøedchozí èásti</a> <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyku Java i o vlastnostech virtuálního stroje tohoto jazyka</a>
jsme se zmínili o tom, ¾e v&nbsp;rámci <i>JDK 7</i> byl instrukèní soubor JVM
roz¹íøen o novou instrukci nazvanou pøíhodnì <strong>invokedynamic</strong>.
Zajímavé je, ¾e se tato nová instrukce nevyu¾ívá v&nbsp;samotné Javì, co¾
znamená, ¾e v&nbsp;bajtkódu získaném pøekladem zdrojových kódù naprogramovaných
(èistì) v&nbsp;Javì tuto instrukci nenajdeme. Dùvod je jednoduchý &ndash;
programovací jazyk Java byl a stále zùstává staticky typovaným programovacím
jazykem, u nìj¾ pøekladaè pøi volání jakékoli metody musí vìdìt, jakého typu
jsou parametry této metody a jaký je její návratový typ. Nemusí sice ji¾ pøesnì
vìdìt, metoda jaké tøídy se má volat (to kvùli <i>polymorfismu</i>), proto¾e
tuto informaci je v&nbsp;mnoha pøípadech mo¾né zjistit a¾ v&nbsp;èase bìhu
aplikace (v&nbsp;Javì se této vlastnosti ponìkud nepøesnì øíká <i>pozdní vazba
&ndash; late binding</i>).</p>

<p>Z&nbsp;dùvodu podpory polymorfismu, volání statických metod, konstruktorù
atd. se v¹echny metody v&nbsp;Javì volají s&nbsp;vyu¾itím jedné
z&nbsp;následujících ètyø instrukcí:</p>

<table>
<tr><th>#</th><th>Instrukce JVM</th><th>Opkód</th><th>Operandy instrukce</th><th>Provádìná operace</th></tr>
<tr><td>1</td><td>invokestatic </td><td>0xB8</td><td>highbyte, lowbyte</td><td>zavolání statické metody s&nbsp;pøedáním parametrù této metodì</td></tr>
<tr><td>2</td><td>invokevirtual</td><td>0xB6</td><td>highbyte, lowbyte</td><td>zavolání nestatické (neprivátní) metody s&nbsp;pøedáním hodnoty <strong>this</strong> (první implicitní parametr) a v¹ech dal¹ích explicitnì uvedených parametrù</td></tr>
<tr><td>3</td><td>invokespecial</td><td>0xB7</td><td>highbyte, lowbyte</td><td>zavolání konstruktoru, privátní nestatické metody èi pøekryté metody</td></tr>
<tr><td>4</td><td>invokeinterface</td><td>0xB9</td><td>highbyte, lowbyte, count</td><td>zavolání metody deklarované v&nbsp;rozhraní, samozøejmì s&nbsp;pøedáním parametrù</td></tr>
</table>

<p>Operandy <i>highbyte</i> a <i>lowbyte</i>, které jsou pou¾ité u v¹ech ètyø
vý¹e uvedených instrukcí, tvoøí ¹estnáctibitový index do <i>constant poolu</i>.
Záznam ulo¾ený na daném indexu musí být typu <i>Method Reference
(MethodRef)</i>, co¾ je pro pøipomenutí záznam obsahující odkaz (index) na
dal¹í záznam typu <i>Class</i> (jméno tøídy èi rozhraní, její¾ metoda se má
zavolat, odkazuje se na øetìzec s&nbsp;názvem tøídy) a takté¾ na záznam typu
<i>Name and Type</i> obsahující signaturu metody. Pro pøipomenutí je pod tímto
odstavcem vypsán obsah <i>constant poolu</i> pro tøídu, v&nbsp;ní¾ se
s&nbsp;vyu¾itím instrukce <strong>invokespecial #2</strong> volá metoda
<strong>void OtherClass.testMethod()</strong>:</p>

<pre>
Velikost const. poolu: 18 prvku
  1   10  MethodRef         4     12             java/lang/Object.&lt;init&gt;()V
* 2 * 10  MethodRef        13--.  14----.        OtherClass.testMethod()V
  3    7  Class            15  |        |        Test
  4    7  Class            16  |        |        java/lang/Object
  5    1  String               |        |        "&lt;init&gt;"
  6    1  String         ,-&gt;   |        |        "()V"
  7    1  String         |     |        |        "Code"
  8    1  String         |     |        |        "LineNumberTable"
  9    1  String         |     |        |        "callTestMethod"
 10    1  String         |     |        |        "SourceFile"
 11    1  String         |     |        |        "Test.java"
 12   12  Name and type  |  6  |   5    |        ()V  &lt;init&gt;
 13    7  Class          | 17  `---------------&gt; OtherClass
 14   12  Name and type  `--6     18--. `------&gt; ()V  testMethod
 15    1  String                      |          "Test"
 16    1  String                      |          "java/lang/Object"
 17    1  String                      |          "OtherClass"
 18    1  String                      `--------&gt; "testMethod"
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Virtuální stroj Javy a pøekladaèe staticky typovaných programovacích jazykù</h2>

<p>V¹echny ètyøi vý¹e uvedené instrukce zpracovávané virtuálním strojem Javy
plnì dostaèují potøebám tohoto programovacího jazyka, i kdy¾ se u instrukce
<strong>invokeinterface</strong> pou¾ívá její poslední parametr <i>count</i>
ji¾ spí¹e z&nbsp;historických dùvodù. Ov¹em v&nbsp;posledních nìkolika letech
mù¾eme sledovat zvý¹ený zájem tvùrcù dal¹ích programovacích jazykù o vytvoøení
pøekladaèù tìchto jazykù do bajtkódu JVM (kromì pøekladaèù vzniklo je¹tì vìt¹í
mno¾ství rùzných interpretrù, tìmi se v¹ak v&nbsp;tomto èlánku nebudeme
prozatím zabývat). Pokud se jedná o staticky typovaný jazyk, nemìly by pøi
tvorbì jeho pøekladaèe nastat záva¾nìj¹í problémy (pokud tedy daný jazyk pøímo
nemanipuluje s&nbsp;ukazateli èi neprovádí skuteènì nízkoúrovòové operace,
které nemají pøímou podporu v&nbsp;instrukcích JVM) a programátoøi-u¾ivatelé
tohoto pøekladaèe tak mohou s&nbsp;minimálním úsilím získat kvalitní platformu
pro vývoj aplikací &ndash; bajtkód vytvoøený pøekladaèem toti¾ mù¾e být
optimalizován a následnì pøelo¾en <i>just-in-time</i> pøekladaèem pøímo do
nativního kódu, virtuální stroj Javy je vybaven nìkolika správci pamìti
(<i>garbage collector</i>), podporuje bìh programu ve více vláknech a hlavní
devizou JVM je v&nbsp;neposlední øadì i rozsáhlá standardní knihovna
s&nbsp;pøesnì definovaným rozhraním dodr¾ovaným na v¹ech podporovaných
platformách.</p>

<div class="rs-box"><p>Zajímavé je, ¾e virtuální stroj Javy byl navr¾en takovým
zpùsobem, ¾e vlastnì ani nepoèítá s&nbsp;tím, ¾e bajtkód provádìný JVM byl
skuteènì vytvoøen pøekladaèem programovacího jazyka Java. Ve skuteènosti je
pøímo ve specifikaci JVM na nìkolika místech øeèeno, ¾e bajtkód mù¾e vzniknout
v&nbsp;podstatì jakýmkoli zpùsobem (napøíklad mù¾e být syntetizován èi upraven
pomocí nástrojù <i>BCEL</i> èi <i>ASM</i>), pouze musí splòovat v¹echny
po¾adavky na nìj kladené (kupodivu je bajtkód v&nbsp;nìkterých ohledech více
dynamický ne¾ samotná Java :-).</p></div>

<p>Dobrým pøíkladem dnes pomìrnì úspì¹ného programovacího jazyka tì¾ícího
z&nbsp;pøedností infrastruktury pøedstavované virtuálním strojem Javy je
programovací jazyk <i>Scala</i>. Aplikace napsané ve <i>Scale</i> jsou
pøekládány pøímo do standardního bajtkódu JVM a mohou se tak velmi snadno
zaintegrovat do vìt¹í javovské aplikace. Ov¹em je nutné øíci, ¾e <i>Scala</i>
je z&nbsp;jazykù dostupných pro JVM spí¹e výjimkou, proto¾e pøeva¾ují
programovací jazyky dynamicky typované. Tvùrci pøekladaèù tìchto programovacích
jazykù a¾ donedávna (konkrétnì a¾ do poloviny roku 2011) stáli pøed problémem
<i>jak</i> do bajtkódu vytváøeného pøekladaèem vlo¾it instrukce pro volání
funkcí èi metod. Problém s&nbsp;voláním metod èi funkcí u tìchto jazykù spoèívá
v&nbsp;tom, ¾e instrukce <strong>invokestatic</strong>,
<strong>invokevirtual</strong>, <strong>invokespecial</strong> ani
<strong>invokeinterface</strong> nelze pøímo pou¾ít, proto¾e u dynamicky
typovaného jazyka není obecnì mo¾né v&nbsp;èase pøekladu urèit, která konkrétní
metoda se má pou¾ít: JVM toti¾ pøi volání vy¾aduje plnou signaturu metody,
tj.&nbsp;její jméno, pøesné typy v¹ech parametrù i typ návratové hodnoty.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Pou¾ití signatur metod pøi jejich volání</h2>

<p>Pøi pou¾ití instrukcí <strong>invokestatic</strong>,
<strong>invokevirtual</strong>, <strong>invokespecial</strong> a
<strong>invokeinterface</strong> je navíc nutné mít typy parametrù urèené zcela
pøesnì. Nestaèí tedy napøíklad uvést, ¾e první parametr má být typu
<strong>float</strong> a ve skuteènosti pøedávat hodnotu typu
<strong>int</strong> &ndash; prakticky v¹echny konverze musí být provedeny
explicitnì, co¾ JVM testuje pøi naèítání bajtkódu i pøi jeho vykonávání
(nìkteré konverze jsou v¹ak za urèitých okolností implicitní, napøíklad pøevod
<strong>byte</strong> èi <strong>short</strong> na <strong>int</strong>,
proto¾e datové typy <strong>byte</strong> a <strong>short</strong> nejsou
&bdquo;uzavøeny&ldquo; vùèi vìt¹inì provádìných operací v&nbsp;JVM). Konverzní
instrukce generuje samozøejmì samotný pøekladaè, proto¾e ten ji¾ pøi pøekladu
zná (a musí znát) signatury v¹ech volaných metod. Viz té¾ následující
pøíklad:</p>

<pre>
public class Test {
&nbsp;
    static int add(int x, int y) {
        return x+y;
    }
&nbsp;
    static float add(float x, float y) {
        return x+y;
    }
&nbsp;
    static String add(String x, String y) {
        return x+y;
    }
&nbsp;
    void test() {
        int   integerValue = 10;
        float floatValue = 10.0f;
&nbsp;
        // volání metody int add(int, int)
        // bez konverzí parametrù
        add(integerValue, integerValue);
&nbsp;
        // volání metody float add(float, float)
        // bez konverzí parametrù
        add(floatValue, floatValue);
&nbsp;
        // volání metody float add(float, float)
        // s konverzí prvního parametru
        add(integerValue, floatValue);
&nbsp;
        // volání metody float add(float, float)
        // s konverzí druhého parametru
        add(floatValue, integerValue);
&nbsp;
        // volání metody String add(String, String)
        // bez konverzí parametrù
        add("hello ", "world");
    }
&nbsp;
}
</pre>

<p>Pøekladaè v¾dy musí zajistit volání správné <i>konkrétní</i> metody a
souèasnì musí zajistit, ¾e jsou této metodì pøedány parametry mající korektní
typ. Proto se metoda <strong>test()</strong> pøelo¾í následovnì:</p>

<pre>
void test();
  Code:
   0:   bipush  10
   2:   istore_1
   3:   ldc     #2;         //float 10.0f
   5:   fstore_2
   6:   iload_1
   7:   iload_1
&nbsp;
   // JVM musí znát pøesnou signaturu volané metody
   // (II)I = metoda s dvojicí parametrù int vracející int
   8:   invokestatic    #3; //Method add:(II)I
   11:  pop
   12:  fload_2
   13:  fload_2
&nbsp;
   // JVM musí znát pøesnou signaturu volané metody
   // (FF)F = metoda s dvojicí parametrù float vracející float
   14:  invokestatic    #4; //Method add:(FF)F
   17:  pop
   18:  iload_1
   19:  i2f                 // explicitní konverze
   20:  fload_2
&nbsp;
   // JVM musí znát pøesnou signaturu volané metody
   // (FF)F = metoda s dvojicí parametrù float vracející float
   21:  invokestatic    #4; //Method add:(FF)F
   24:  pop
   25:  fload_2
   26:  iload_1
   27:  i2f                 // explicitní konverze
&nbsp;
   // JVM musí znát pøesnou signaturu volané metody
   // (FF)F = metoda s dvojicí parametrù float vracející float
   28:  invokestatic    #4; //Method add:(FF)F
   31:  pop
   32:  ldc     #9;         //String "hello "
   34:  ldc     #10;        //String "world"
&nbsp;
   // JVM musí znát pøesnou signaturu volané metody
   36:  invokestatic    #11; //Method add:(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
   39:  pop
   40:  return
}
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Dùvody vedoucí k&nbsp;zavedení instrukce <strong>invokedynamic</strong></h2>

<p>Pojïme si nyní ukázat, proè je vlastnì zavedení nové instrukce
<strong>invokedynamic</strong> tak dùle¾ité &ndash; dokonce tak dùle¾ité, ¾e
tuto instrukci pova¾ují nìkteøí programátoøi za nejvìt¹í novinku pøidanou do
<i>JDK 7</i> (osobnì si v¹ak myslím, ¾e vìt¹ina programátorù pou¾ívajících Javu
více ocení nìkterá dal¹í roz¹íøení tohoto jazyka, která byla do <i>JDK 7</i>
pøidána). Dejme tomu, ¾e vývojáø pou¾ívající nìkterý dynamicky typovaný
programovací jazyk napí¹e následující funkci (konkrétní syntaxe nyní nehraje
prakticky ¾ádnou roli):</p>

<pre>
define max(x, y)
    if x.lessThan(y) then
        return y
    else
        return x
end
</pre>

<p>Zápis této funkce ve skuteènosti znamená, ¾e se v&nbsp;jejím tìle zavolá
nìjaká metoda v&nbsp;èase kompilace je¹tì vìt¹inou neznámé tøídy
<strong>x</strong>, která je nazvaná <strong>lessThan</strong>. Této metodì je
pøedán parametr <strong>y</strong>, jeho¾ datový typ opìt není v&nbsp;èase
kompilace (<i>compile time</i>) vìt¹inou pøekladaèi známý. To znamená, ¾e a¾
v&nbsp;èase bìhu aplikace (<i>runtime</i>) je mo¾né na základì typù konkrétních
parametrù pøedávaných do funkce <strong>max</strong> rozhodnout, jaká konkrétní
metoda <strong>lessThan</strong> se bude ve skuteènosti volat. První problém
spoèívá v&nbsp;tom, ¾e pøíkaz typu &bdquo;najdi a zavolej vhodnou metodu
lessThan&ldquo; není mo¾né pøímo implementovat ani jednou ze ètyø vý¹e
zmínìných instrukcí typu <strong>invoke*</strong> (neznáme toti¾ pøesnou
signaturu metody, tedy informaci o typech jejích parametrù i o její návratové
hodnotì), tak¾e se vývojáøi pøekladaèù museli poohlédnout po alternativních
zpùsobech, jak pøíkaz pro nalezení a zavolání &bdquo;vhodné&ldquo; metody
odpovídající pøedávaným typùm implementovat.</p>

<p>Naproti tomu nìkteré dal¹í virtuální stroje (<i>VM</i>) ji¾ od svého zaèátku
podporují instrukce slou¾ící pro nalezení vhodné metody a pro její zavolání.
Pro ilustraci se podívejme, jak by byl celý problém s&nbsp;metodou
<strong>add</strong> z&nbsp;pøedchozí kapitoly vyøe¹ený v&nbsp;bajtkódu
virtuálního stroje programovacího jazyka <i>Python</i>. Funkce
<strong>add()</strong> by vypadala velmi jednodu¹e, proto¾e typy obou parametrù
<strong>x</strong> a <strong>y</strong> i návratový typ se vyhodnocuje a¾
v&nbsp;dobì bìhu programu:</p>

<pre>
def add(x,y):
    return x+y
</pre>

<p>Vzhledem k&nbsp;tomu, ¾e bajtkód jazyka <i>Python</i> (resp.&nbsp;jeho
virtuálního stroje) obsahuje &ndash; na rozdíl od JVM &ndash; vysokoúrovòové
instrukce, vypadá pøelo¾ená funkce <strong>add()</strong> následovnì:</p>

<pre>
import dis
dis.dis(add)
&nbsp;
    2    0 LOAD_FAST     0 (x)
         3 LOAD_FAST     1 (y)
         6 BINARY_ADD
         7 RETURN_VALUE
</pre>

<p>V¹echny ètyøi instrukce VM Pythonu jsou vlastnì polymorfní a manipulují
s&nbsp;hodnotami libovolného typu. Mù¾e se skuteènì jednat o jakékoli objekty,
pouze je za bìhu kontrolováno, zda je na nì mo¾né aplikovat operátor +, který
ve skuteènosti odpovídá volání metody <strong>__add__</strong>, kterou je mo¾né
kdykoli pøedefinovat. Naopak v&nbsp;pøípadì Javy by se naproti tomu existence
vhodné metody <strong>__add__</strong> musela kontrolovat ji¾ pøi pøekladu: to
samozøejmì v&nbsp;pøípadì, kdy by jazyk byl roz¹íøen o mo¾nosti pøetí¾ení
operátorù (co¾ v&nbsp;podstatì neznamená a¾ tak velký zásah do pøekladaèe, jak
by se mohlo zdát; prozatím v¹ak tato mo¾nost budí pomìrnì velké rozpaky).</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Mo¾ná øe¹ení problému volání metod v&nbsp;dynamicky typovaných programovacích jazycích</h2>

<p>Jednou z&nbsp;mo¾ností øe¹ení problému volání metody bez pøedem známé
signatury spoèívá v&nbsp;tom, ¾e pøekladaè vytvoøí a pou¾ije novou tøídu, která
bude reprezentovat libovolný datový typ, co¾ u mnoha dynamických jazykù kromì
pravdivostních hodnot, èísel a øetìzcù vìt¹inou zahrnuje i takové datové typy,
jakými jsou pole, seznamy, asociativní pole, n-tice atd.). Metoda
<strong>lessThan()</strong> by v&nbsp;tomto pøípadì jako svùj parametr
akceptovala právì instanci této tøídy (a sama by byla metodou této tøídy),
tak¾e by se celý problém mohl alespoò zdánlivì vyøe¹it, i kdy¾ by metoda
<strong>lessThan()</strong> ve svém tìle musela obsahovat mnoho vìtví øe¹ících
rùzné kombinace skuteènì pøedaných parametrù (<strong>lessThan()</strong>
aplikovaná na dvojici èísel se bude urèitì chovat jinak, ne¾
<strong>lessThan()</strong> aplikovaná na dva øetìzce, pole atd.) &ndash;
obecnì se vlastnì jedná o obcházení mo¾ností, které nám automaticky nabízí OOP
a polymorfismus v&nbsp;Javì. Ve skuteènosti se v¹ak o zcela obecné øe¹ení
nejedná, proto¾e nové metody èi funkce definované pozdìji u¾ivatelem by nebylo
mo¾né volat pøímo, ale musela by se pou¾ít nìjaká &bdquo;univerzální&ldquo;
metoda pojmenovaná vìt¹inou <strong>Invoke</strong> èi
<strong>Apply</strong>.</p>

<p>Druhé øe¹ení, ke kterému se mohou tvùrci pøekladaèù uchýlit, spoèívá ve
vyu¾ití <i>reflection API</i>, konkrétnì v&nbsp;pou¾ití velmi u¾iteèné tøídy <a
href="http://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Method.html">java.lang.reflect.Method</a>.
V&nbsp;této tøídì se kromì dal¹ích metod nachází i metoda nazvaná pøíhodnì
<strong>invoke</strong>. Tuto metodu pravdìpodobnì nebudou mít skalní zastánci
striktnì typovaných jazykù pøíli¹ v&nbsp;lásce :-) nicménì jde o metodu
pou¾ívanou napøíklad v&nbsp;testovacích nástrojích atd. Hlavièka metody
<strong>invoke</strong> je následující:</p>

<pre>
public Object invoke(Object obj, Object... args)
    throws IllegalAccessException,
           IllegalArgumentException,
           InvocationTargetException
</pre>

<p>Prvním parametrem metody <strong>invoke()</strong> je instance tøídy, její¾
metoda se volá, dal¹í parametry pak musí svým typem odpovídat skuteèným
parametrùm metody. Návratovou hodnotou <strong>invoke()</strong> je samozøejmì
návratová hodnota volané metody &ndash; tuto hodnotu je nutné vìt¹inou
explicitnì pøetypovat.</p>

<p>Následuje velmi jednoduchá ukázka pou¾ití <strong>invoke()</strong>:</p>

<pre>
import java.lang.reflect.*;
&nbsp;
public class Test {
&nbsp;
    // tato metoda se bude volat pøes Method.invoke()
    public int computeAnswer(Integer x, Integer y) {
        return x * y;
    }
&nbsp;
    public static void main(String[] args) {
        // základem pro práci s reflection API je tøída Class
        Class c = Test.class;
        try {
            // pokusíme se nalézt metodu s daným jménem a souèasnì
            // s daným poètem a typem parametrù - zde lze tyto informace
            // vyhodnotit a¾ v runtime, nikoli nutnì v compile time
            Method m = c.getMethod("computeAnswer", Integer.class, Integer.class);
&nbsp;
            // zavolání metody pomocí Method.invoke()
            Object answer = m.invoke(new Test(), Integer.valueOf(6), Integer.valueOf(7));
&nbsp;
            // pøevod z Object na Integer nemusíme provádìt, je nám toti¾ jedno,
            // jak se zavolá answer.toString()
            System.out.println("Answer is " + answer);
        }
        catch (NoSuchMethodException e) {
            e.printStackTrace();
        }
        catch (IllegalAccessException e) {
            e.printStackTrace();
        }
        catch (InvocationTargetException e) {
            e.printStackTrace();
        }
    }
&nbsp;
}
</pre>

<p>Pou¾ití <strong>Method.invoke()</strong> je skuteènì pro tvùrce pøekladaèe
rozumným øe¹ením, ov¹em stále zde zùstává jeden problém: v&nbsp;runtime je
nutné získat nejenom informace o konkrétním typu objektu (jeho¾ metoda se má
volat) i typu parametrù volané metody, ale navíc se je¹tì musí v¹echny tyto
typy pøevést na typy (èti objekty) &bdquo;kompatibilní&ldquo; s&nbsp;Javou.
Jinými slovy musí být v¹echny datové typy nabízené daným programovacím jazykem
pøevoditelné na objekty reprezentovatelné v&nbsp;Javì
(<strong>Integer</strong>, <strong>String</strong>, <strong>List</strong>
atd.). Nejedná se sice o neøe¹itelnou pøeká¾ku, nicménì nìkdy to vede
k&nbsp;nutnosti vytváøení &bdquo;paralelní&ldquo; hierarchie tøíd nahrazujících
javovské datové typy, co¾ není optimální z&nbsp;hlediska výpoèetního
výkonu.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Instrukce <strong>invokedynamic</strong></h2>

<p>Nová instrukce <strong>invokedynamic</strong> má pomìrnì slo¾ité chování,
které se dosti zásadním zpùsobem odli¹uje od zbylých ètyø instrukcí
<strong>invokestatic</strong>, <strong>invokevirtual</strong>,
<strong>invokespecial</strong> a <strong>invokeinterface</strong>. Je tomu tak
z&nbsp;toho dùvodu, ¾e instrukce <strong>invokedynamic</strong> má
programátorùm pøekladaèe zajistit mo¾nost volby konkrétní metody, která se má
spustit v&nbsp;èase bìhu aplikace, ov¹em na druhou stranu se musí jednat o
øe¹ení, které je dostateènì výkonné, aby se pøi ka¾dém volání nemusel stále
volat slo¾itý kód pro nalezení volané metody (není bez zajímavosti, ¾e tato
&bdquo;optimalizace&ldquo; nebyla do pùvodního návrhu pro
<strong>invokedynamic</strong> zahrnuta, co¾ by v¹ak mìlo velmi negativní
dopad na výkonnost pøelo¾eného kódu).</p>

<p>Z&nbsp;tohoto dùvodu pracuje instrukce <strong>invokedynamic</strong> tak,
¾e se pøi jejím prvním zavolání z&nbsp;daného místa bajtkódu nejprve vytvoøí
vazba (<i>link</i>) mezí tímto místem a volanou metodou a pøi ka¾dém dal¹ím
volání <strong>invokedynamic</strong> se ji¾ pøímo pou¾ije slinkovaná metoda
(tj.&nbsp;metoda svázaná s&nbsp;tímto výskytem instrukce
<strong>invokedynamic</strong>). Pøednosti tohoto øe¹ení jsou zøejmé, kdy¾ si
uvìdomíme, ¾e by se napøíklad instrukce <strong>invokedynamic</strong> pou¾ila
v&nbsp;programové smyèce.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Dynamic call site (DCS)</h2>

<p>Ka¾dá instance instrukce <strong>invokedynamic</strong> v&nbsp;bajtkódu se
nazývá <i>dynamic call site</i> neboli zkrácenì <i>DCS</i> (volnì lze tento
termín pravdìpodobnì pøelo¾it jako &bdquo;místo dynamického volání&ldquo;). Ke
ka¾dému <i>DCS</i> je pøiøazen urèitý stav, pøièem¾ ve výchozím stavu není
<i>DCS</i> slinkováno s&nbsp;¾ádnou konkrétní volanou metodou &ndash;
slinkování se toti¾ v¾dy provádí a¾ v&nbsp;èase bìhu programu (<i>runtime</i>).
Pøekladaè namísto konkrétní metody, která se bude z&nbsp;<i>DCS</i> volat (tuto
metodu, jak ji¾ víme, obecnì nemù¾e v&nbsp;èase pøekladu znát) musí pro ka¾dé
<i>DCS</i> (instanci <strong>invokedynamic</strong> v&nbsp;bajtkódu)
specifikovat takzvanou <i>bootstrap metodu</i>, a to podobným zpùsobem, jakým
se specifikují volané metody u instrukcí <strong>invokestatic</strong>,
<strong>invokevirtual</strong>, <strong>invokespecial</strong> a
<strong>invokeinterface</strong>. Kvùli <i>bootstrap metodám</i> se navíc
musely specifikovat <a href="#k08">dal¹í typy záznamù ukládaných do constant
poolu</a>.</p>

<p><i>Bootstrap metoda</i> je zavolána ve chvíli, kdy není <i>DCS</i> je¹tì
s&nbsp;nièím slinkována, tj.&nbsp;v&nbsp;okam¾iku, kdy virtuální stroj Javy
je¹tì neví, kterou konkrétní metodu má skuteènì zavolat. Namísto toho tedy
zavolá <i>bootstrap metodu</i> (tu zná &ndash; je pøímo parametrem instrukce
<strong>invokedynamic</strong>), která zajistí vytvoøení ký¾ené vazby mezi
<i>DCS</i> a nìjakou vhodnou metodou. Návratovým typem <i>bootstrap metody</i>
je toti¾ objekt, který reprezentuje vazbu (<i>link</i>). Pøi ka¾dém dal¹ím
prùchodu pøes <i>DCS</i> nyní ji¾ virtuální stroj Javy nebude volat
<i>bootstrap metodu</i>, ale metodu, na ní¾ vede vytvoøený <i>link</i> (jakým
zpùsobem jsou tyto linky ulo¾eny v&nbsp;pamìti je ji¾ vìcí vývojáøù JVM,
konkrétní implementace <i>bootstrap metody</i> naopak trápí vývojáøe
pøekladaèù).</p>

<p>Následuje (neúplný) pøíklad toho, jak by mohla <i>bootstrap metoda</i>
vypadat. Tento pøíklad navazuje na pøíklad s&nbsp;tøídou <strong>Test</strong>
a její metodou <strong>computeAnswer()</strong>:</p>

<pre>
public class InvokeDynamicTest {
&nbsp;
    public static int bootstrapMethod(CallSite site, Object... args) {
&nbsp;
        // MethodHandles.lookup() vrati objekt typu MethodHandles.Lookup
        // ten nabizi vyhledavaci mechanismus pro metody pres:
        //     MethodHandles.Lookup.findVirtual()
        //     MethodHandles.Lookup.findStatic()
        //     MethodHandles.Lookup.findSpecial()
        //     MethodHandles.Lookup.findConstrutor()
        // atd.
&nbsp;
        // vyhledavana metoda Test.computeAnswer() je NEstaticka, tudiz virtualni
        MethodHandle target = MethodHandles.lookup().findVirtual(
                // trida, ve ktere se provadi hledani metody
                Test.class,
                "computeAnswer",
                // ukazka zpusobu specifikace typu parametru i typu navratove hodnoty:
                // prvni parametr: typ navratove hodnoty
                // dalsi parametry: typy parametru metody
                MethodType.methodType(Integer.class, Integer.class, Integer.class));
                // (jedna se o pretizenou metodu, existuje ve vice variantach)
&nbsp;
        // vytvoreni linku
        site.setTarget(target);
&nbsp;
        // zde se ji¾ mù¾e zavolat metoda Test.computeAnswer()
        return MethodHandle.invoke(target, site, args);
        // pokud by metoda vyhazovala nejake vyjimky, mely by se samozrejme
        // odchytit - MethodHandle.invoke() obecne vyhazuje Throwable, tedy "vse"
    }
}
</pre>

<p>Registrace <i>bootstrap metody</i> je mo¾né jednodu¹e provést ve static
bloku:</p>

<pre>
static {
    Linkage.registerBootstrapMethod("bootstrapMethod");
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Novinky v&nbsp;bajtkódu Javy &ndash; nové typy záznamù v&nbsp;constant poolu</h2>

<p>V&nbsp;pøedchozí kapitole jsme si øekli, ¾e v&nbsp;rámci zavádìní podpory
pro dynamicky typované programovací jazyky do¹lo i k&nbsp;roz¹íøení typù
záznamù ukládaných do <i>constant poolu</i>. Pøipomeòme si, ¾e a¾ doposud jsme
se seznámili s&nbsp;následujícími typy záznamù pou¾ívanými od JDK 1.0 a¾ do JDK
6:</p>

<table>
<tr><th>Tag</th><th>Název tagu</th><th>Parametr 1</th><th>Parametr 2</th></tr>
<tr><td> 1</td><td>Utf8</td><td>délka øetìzce v&nbsp;bajtech</td><td>sekvence bajtù (poèet znakù je obecnì men¹í ne¾ poèet bajtù)</td></tr>
<tr><td> 3</td><td>Integer</td><td>ètyøbajtová celoèíselná konstanta</td><td>&times;</td></tr>
<tr><td> 4</td><td>Float</td><td>ètyøbajtová FP konstanta</td><td>&times;</td></tr>
<tr><td> 5</td><td>Long</td><td>osmibajtová celoèíselná konstanta</td><td>&times;</td></tr>
<tr><td> 6</td><td>Double</td><td>osmibajtová FP konstanta</td><td>&times;</td></tr>
<tr><td> 8</td><td>String</td><td>2 bajty: odkaz na vlastní øetìzec (záznam typu <strong>Utf8</strong>)</td><td>&times;</td></tr>
<tr><td> 7</td><td>Class</td><td>2 bajty: odkaz na jméno tøídy (záznam typu <strong>Utf8</strong>)</td><td>&times;</td></tr>
<tr><td> 9</td><td>Fieldref</td><td>2 bajty: odkaz na jméno tøídy (záznam typu <strong>Utf8</strong>)</td><td>2 bajty: odkaz na záznam typu <strong>NameAndType</strong></td></tr>
<tr><td>10</td><td>Methodref</td><td>2 bajty: odkaz na jméno tøídy (záznam typu <strong>Utf8</strong>)</td><td>2 bajty: odkaz na záznam typu <strong>NameAndType</strong></td></tr>
<tr><td>11</td><td>InterfaceMethodref</td><td>2 bajty: odkaz na jméno tøídy (záznam typu <strong>Utf8</strong>)</td><td>2 bajty: odkaz na záznam typu <strong>NameAndType</strong></td></tr>
<tr><td>12</td><td>NameAndType</td><td>2 bajty: odkaz na záznam typu <strong>Utf8</strong></td><td>2 bajty: odkaz na záznam typu <strong>Utf8</strong></td></tr>
</table>

<p>Novì se mohou v&nbsp;bajtkódu objevit je¹tì dal¹í tøi typy záznamù, které
jsou vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th>Tag</th><th>Název tagu</th><th>Parametr 1</th><th>Parametr 2</th></tr>
<tr><td>15</td><td>MethodHandle </td><td>typ reference (1-9)</td><td>index na <strong>Fieldref</strong>, <strong>Methodref</strong> èi <strong>InterfaceMethodref</strong></td></tr>
<tr><td>16</td><td>MethodType   </td><td>odkaz na záznam typu <strong>Utf8</strong> obsahující deskriptor metody</td><td>&times;</td></tr>
<tr><td>18</td><td>InvokeDynamic</td><td>index ukazující na bootstrap metodu</td><td>index na záznam typu <strong>NameAndType</strong></td></tr>
</table>

<p>U záznamu typu <strong>InvokeDynamic</strong> obsahuje první parametr index
do pole vytvoøeného pomocí atributu <strong>BootstrapMethods_attribute</strong>
(jedná se o doplòkové informace pøidané k&nbsp;bajtkódu). Bli¾¹í informace o
v¹ech tøech nových typech záznamù i zpùsobu jejich pou¾ití si øekneme
v&nbsp;nìkterém z&nbsp;následujících èástí tohoto seriálu.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/">http://java.sun.com/developer/technicalArticles/DynTypeLang/</a>
</li>

<li>JSR 223: Scripting for the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=223">http://jcp.org/en/jsr/detail?id=223</a>
</li>

<li>JSR 292: Supporting Dynamically Typed Languages on the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=292">http://jcp.org/en/jsr/detail?id=292</a>
</li>

<li>Java 7: A complete invokedynamic example<br />
<a href="http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html">http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html</a>
</li>

<li>InvokeDynamic: Actually Useful?<br />
<a href="http://blog.headius.com/2007/01/invokedynamic-actually-useful.html">http://blog.headius.com/2007/01/invokedynamic-actually-useful.html</a>
</li>

<li>A First Taste of InvokeDynamic<br />
<a href="http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html">http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html</a>
</li>

<li>Java 6 try/finally compilation without jsr/ret<br />
<a href="http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html">http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Root.cz: Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM<br />
<a href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/</a></a>
</li>

<li>Root.cz: JamVM aneb alternativa k HotSpotu nejenom pro embedded zaøízení a chytré telefony<br />
<a href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>FindBugs<br />
<a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a>
</li>

<li>GNU Classpath<br />
<a href="www.gnu.org/s/classpath/">www.gnu.org/s/classpath/</a></li>

<li>Java VMs Compared<br />
<a href="http://bugblogger.com/java-vms-compared-160/">http://bugblogger.com/java-vms-compared-160/</a>
</li>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>CloseableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html">http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

