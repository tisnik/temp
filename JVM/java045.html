<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Clojure 14: základy práce se systémem maker</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Clojure 14: základy práce se systémem maker</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o Javì, JVM i navazujících technologiích si popí¹eme dal¹í dùle¾itou vlastnost programovacího jazyka Clojure. Tento jazyk je toti¾, podobnì jako dal¹í jazyky inspirované LISPem, vybaven mocným systémem maker. V samotném Clojure jsou ji¾ nìkterá makra pevnì zabudována a dal¹í lze relativnì jednodu¹e doplnit.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyk Clojure 14: základy práce se systémem maker</a></p>
<p><a href="#k02">2. Smyèka REPL (Read-Eval-Print-Loop) a systém maker v&nbsp;tradièních LISPech</a></p>
<p><a href="#k03">3. První písmeno ve zkratce REPL: objekt Reader a jeho makra</a></p>
<p><a href="#k04">4. Makra &bdquo;comment&ldquo;, &bdquo;character&ldquo; a &bdquo;metadata&ldquo;</a></p>
<p><a href="#k05">5. Makro &bdquo;deref&ldquo;</a></p>
<p><a href="#k06">6. Makra &bdquo;quote&ldquo; a &bdquo;syntax-quote&ldquo;</a></p>
<p><a href="#k07">7. Makra &bdquo;unquote&ldquo; a &bdquo;unquote-splicing&ldquo;</a></p>
<p><a href="#k08">8. Makro &bdquo;dispatch&ldquo;</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk Clojure 14: základy práce se systémem maker</h2>

<p>V&nbsp;dne¹ní èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyku Java i o vlastnostech virtuálního stroje Javy</a> se opìt
budeme zabývat popisem zajímavých vlastností programovacího jazyka
<i>Clojure</i>, jeho¾ pùvodní implementace je postavená právì nad virtuálním
strojem Javy (JVM). Dnes si øekneme základní informace o tom, jak lze
v&nbsp;<i>Clojure</i> pou¾ívat makra, která mohou velmi významným zpùsobem
ovlivnit zpùsob tvorby programù, proto¾e právì díky pou¾ití maker lze
v&nbsp;<i>Clojure</i> vytváøet takzvané <i>doménovì orientované jazyky</i>
&ndash; napøíklad se mù¾e jedna o obdobu jazyka SQL atd. Ji¾ pøi <a
href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">popisu
základních principù</a>, na nich¾ je postaven programovací jazyk <i>Clojure</i>
jsme si øekli, ¾e je tento jazyk vybaven interpretrem kombinovaným
s&nbsp;&bdquo;utajeným&ldquo; pøekladaèem zapisovaných funkcí a forem do
bajtkódu virtuálního stroje Javy (v¹echny vyhodnocované formy jsou tedy nejprve
internì pøelo¾eny do bajtkódu a teprve poté je spu¹tìno jejich
vyhodnocení).</p>

<p>Základní vlastnosti samotného interpretu jazyka <i>Clojure</i> jsou pøitom
odvozeny od interpretrù pou¾ívaných ve vìt¹inì variant programovacího jazyka
<i>LISP</i>, co¾ znamená, ¾e autoøi <i>Clojure</i> (resp.&nbsp;pøesnìji øeèeno
pøedev¹ím jeho pùvodní a dodnes nejaktivnìj¹í autor <i>Rich Hickley</i>)
vychází z&nbsp;ovìøených technologií, které byly poprvé implementovány ji¾ pøed
více ne¾ padesáti roky v&nbsp;rámci vývoje <i>LISPu</i> a na nìj navazujících
jazykù (<i>Scheme</i>). Základem interpretru programovacího jazyka
<i>Clojure</i> je, stejnì jako v&nbsp;<i>LISPu</i>, smyèka nazývaná
<strong>REPL</strong> (<i>Read-Evaluate-Print-Loop</i>), její¾ název vyplývá
z&nbsp;toho, ¾e mohla být relativnì jednodu¹e implementována zpùsobem ukázaným
pod tímto odstavcem. Ostatnì z&nbsp;historického pohledu je zajímavé, ¾e nìjak
podobnì vlastnì <i>LISP</i> vznikl, kdy¾ si jeho autor (<i>John McCarthy</i>)
uvìdomil, ¾e na základì implementace rekurzivní podoby funkce
<strong>eval</strong> a nìkolika dal¹ích pomocných funkcí doká¾e vytvoøit
plnohodnotný programovací jazyk:</p>

<pre>
(loop (print (eval (read))))
</pre>

<p>Poznámka: v&nbsp;programovacím jazyku <i>Clojure</i> by ve skuteènosti musel
být tento &bdquo;ortodoxní&ldquo; zápis proveden ponìkud odli¹ným zpùsobem,
proto¾e zde se speciální forma <strong>loop</strong> musí zapisovat spoleènì se
speciální formou <strong>recur</strong> &ndash; <strong>loop</strong> toti¾
v&nbsp;<i>Clojure</i> slou¾í pøedev¹ím pro oznaèení bodu, kde zaèíná rekurze (a
navíc i pro urèení lokálních promìnných pou¾ívaných uvnitø opakujícího se bloku
kódu). Takté¾ je nutné nahradit funkci <strong>print</strong> za
<strong>println</strong>, tak¾e v&nbsp;<i>Clojure</i> mù¾e implementace smyèky
<strong>REPL</strong> vypadat napøíklad takto:</p>

<pre>
user=&gt; <strong>(loop [] (println (eval (read))) (recur))</strong>
<strong>(+ 1 2)</strong>
3
<strong>(* 6 7)</strong>
42
<strong>(str "Hello world")</strong>
Hello world
<strong>^D</strong>
user=&gt;
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Smyèka REPL (Read-Eval-Print-Loop) a systém maker v&nbsp;tradièních LISPech</h2>

<p>Jednoduchý interpret <i>LISPu</i> tedy mohl být teoreticky implementován
pouze s&nbsp;vyu¾itím trojice funkcí <strong>read</strong> (naètení
výrazu/formy ze standardního vstupu), <strong>print</strong> (tisk výsledku
vyhodnocení výrazu/formy na standardní výstup), <strong>eval</strong> (vìt¹inou
rekurzivnì implementovaná funkce urèená pro vyhodnocení naètené formy), které
byly doplnìny speciální formou èi makrem <strong>loop</strong> (nekoneèná
smyèka &ndash; pøi striktním pohledu se v&nbsp;tomto pøípadì nemù¾e jednat o
funkci). Ve skuteènosti je v¹ak samozøejmì nutné, aby byl prakticky pou¾itelný
programovací jazyk doplnìn o alespoò minimální mno¾ství základních funkcí a
speciálních forem. V&nbsp;pøípadì pùvodního <i>LISPu</i> se jednalo o sedm
funkcí a dvì speciální formy: <strong>atom</strong>, <strong>car</strong>,
<strong>cdr</strong>, <strong>cond</strong>, <strong>cons</strong>,
<strong>eq</strong>, <strong>quote</strong>, <strong>lambda</strong> a
<strong>label</strong>.</p>

<p>Pùvodnì relativnì velmi jednodu¹e a pøitom elegantnì implementovaný
interpret programovacího jazyka <i>LISP</i> se postupnì zaèal vyvíjet a jednou
z&nbsp;nových a pøitom mocných technik, které do nìj byly pøidány, jsou
takzvaná <i>makra</i>, která se v¹ak v&nbsp;mnoha ohledech li¹í od maker
pou¾ívaných napøíklad v&nbsp;programovacích jazycích C a C++. Zatímco
v&nbsp;céèku jsou makra zpracovávána pomìrnì &bdquo;hloupým&ldquo;
preprocesorem, který doká¾e provádìt textové substituce, naèítat vkládané
soubory a vyhodnocovat jednoduché podmínky, mohou makra implementovaná
v&nbsp;jazyce <i>LISP</i> pracovat pøímo se zadávanými formami, které makra
mohou rùzným zpùsobem modifikovat &ndash; pøitom se zde vyu¾ívá faktu, ¾e
v&nbsp;<i>LISPu</i> a tudí¾ i v&nbsp;<i>Clojure</i> jsou programy
reprezentovány ve formì (obvykle rekurzivnì vnoøených) seznamù, a zmìnou obsahu
tìchto seznamù lze vlastnì pøímo manipulovat s&nbsp;takzvaným abstraktním
syntaktickým stromem (<i>AST &ndash; Abstract Syntax Tree)</i>.</p>

<p>Není bez zajímavosti, ¾e s&nbsp;<i>AST</i> se v&nbsp;<i>LISP/Clojure</i>
mù¾e manipulovat za pou¾ití stejných mechanismù (funkcí/forem/maker), které se
pou¾ívají i pøi bì¾ném programování &ndash; jinými slovy to znamená, ¾e
<i>jazyk maker</i> je stále jazykem, v&nbsp;nìm¾ se zapisují programy (na
rozdíl od zmínìného céèka a C++, kde je jazyk maker zcela odli¹ný). Jinými
slovy to znamená, ¾e se pøi tvorbì maker musíme seznámit pouze se zpùsobem
zápisu maker, ale v&nbsp;samotných makrech se mohou pou¾ívat funkce, které jsme
si ji¾ v&nbsp;tomto seriálu popsali &ndash; vìt¹inou se bude jednat o funkce
pro práci se seznamy, co¾ je vzhledem ke zpùsobu reprezentace programù (jako do
sebe vnoøených seznamù) pochopitelné.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. První písmeno ve zkratce REPL: objekt Reader a jeho makra</h2>

<p>Pøed popisem systému maker v&nbsp;programovacím jazyku <i>Clojure</i> si
je¹tì musíme øíci, ¾e ve skuteènosti existují dva typy maker &ndash; takzvaná
<i>reader macros</i>, neboli makra zabudovaná pøímo do objektu/modulu, který
naèítá formy ze standardního vstupu a potom bì¾ná makra. Nejprve se budeme
zabývat makry pou¾ívanými pøi naèítání forem ze standardního vstupu. Dùvodù,
proè je lep¹í zaèít s&nbsp;popisem této skupiny maker je více, napøíklad fakt,
¾e tato makra nelze vytváøet a existující makra nelze modifikovat (na rozdíl od
<i>Common Lispu</i>, kde to mo¾né je) a takté¾ to, ¾e se tato makra pou¾ívají
v&nbsp;prakticky v¹ech zdrojových kódech, ani¾ by si vývojáøi vìt¹inou
uvìdomovali, ¾e ve svých programech nìjaká makra pou¾ívají :-) Dùvod existence
<i>reader maker</i> je jednoduchý &ndash; umo¾òují zkrácení zápisu programù,
zaji¹»ují mo¾nost zápisu komentáøù (ty toti¾ nejsou pova¾ovány za bì¾né formy,
proto¾e nevrací ¾ádnou hodnotu, ani <strong>nil</strong>) a takté¾ je mo¾né
s&nbsp;pomocí tohoto typu maker pøidávat k&nbsp;symbolùm, seznamùm, vektorùm,
mapám atd. takzvaná metadata.</p>

<p>Zjednodu¹enì øeèeno je mo¾né øíci, ¾e <i>reader</i> makra pracují podobnì
jako preprocesor v&nbsp;programovacích jazycích C a C++, proto¾e text
zapisovaný èi posílaný na standardní vstup je nejprve tìmito makry zpracován a
posléze je &ndash; stále v&nbsp;textové podobì &ndash; poslán funkci
<i>read</i>. Tato makra tedy slou¾í pro provádìní &bdquo;pouhých&ldquo;
textových substitucí a nikoli k&nbsp;modifikaci AST, jak je tomu u bì¾ných
maker. Která <i>reader</i> makra jsou v&nbsp;<i>Clojure</i> podporována, nám
prozradí následující tabulka, z&nbsp;ní¾ je patrné, ¾e nìkterá makra provádí
skuteènì znaènì jednoduchou èinnost, napøíklad pouhé odstranìní komentáøù:</p>

<table>
<tr><th>#</th><th>Makro</th><th>Název</th><th>Kapitola</th><th>Význam</th></tr>
<tr><td>1</td><td>; </td><td>comment</td><td><a href="#k04">4</a></td><td>umo¾òuje obejít zápis <i>(comment nìjaký text)</i> u komentáøù</td></tr>
<tr><td>2</td><td>\ </td><td>character</td><td><a href="#k04">4</a></td><td>pou¾ívané pøi zápisu znakových literálù</td></tr>
<tr><td>3</td><td>^ </td><td>metadata</td><td><a href="#k04">4</a></td><td>pøidání metadat k&nbsp;symbolùm, seznamùm, vektorùm, mapám a mno¾inám</td></tr>
<tr><td>4</td><td>' </td><td>quote</td><td><a href="#k06">6</a></td><td>nahrazuje zápis <i>(quote ...)</i></td></tr>
<tr><td>5</td><td>` </td><td>syntax-quote</td><td><a href="#k06">6</a></td><td>provádí plnou kvalifikaci symbolù + zde lze pou¾ít makra ~ a ~@</td></tr>
<tr><td>6</td><td>~ </td><td>unquote</td><td><a href="#k07">7</a></td><td>zajistí, ¾e se vyhodnotí pouze oznaèená èást formy (= provede substituci této èásti výsledkem)</td></tr>
<tr><td>7</td><td>~@</td><td>unquote-splicing</td><td><a href="#k07">7</a></td><td>podobné pøedchozími makru, ov¹em výsledná sekvence se vlo¾í ve formì samostatných prvkù do &bdquo;obalující&ldquo; sekvence</td></tr>
<tr><td>8</td><td>@ </td><td>deref</td><td><a href="#k05">5</a></td><td>nahrazuje zápis <i>(deref ...)</i></td></tr>
<tr><td>9</td><td># </td><td>dispatch</td><td><a href="#k08">8</a></td><td>má rùzné funkce: donutí reader, aby pou¾il makro z&nbsp;jiné tabulky maker</td></tr>
</table>

<p>Význam v¹ech maker zmínìných v&nbsp;pøedchozí tabulce si podrobnìji
vysvìtlíme v&nbsp;navazujících kapitolách.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Makra &bdquo;comment&ldquo;, &bdquo;character&ldquo; a &bdquo;metadata&ldquo;</h2>

<p>S&nbsp;popisem maker vestavìných do objektu <i>Reader</i> zaèneme jen
pozvolna, napøed si toti¾ popí¹eme ta nejjednodu¹¹í makra, která jsme si navíc
ji¾ ukázali v&nbsp;pøedchozích èástech tohoto seriálu. Nejjednodu¹¹ím <i>reader
makrem</i> je s&nbsp;velkou pravdìpodobností makro nazvané
&bdquo;comment&ldquo; zapisované pomocí znaku ; (støedník). Ve¹kerý text, který
je zapsaný mezi støedníkem a koncem øádku je ignorován, tak¾e toto makro lze
pou¾ít pro jednoduchý zápis jednoøádkových komentáøù. Pokud by toto
<i>reader</i> makro neexistovalo, muselo by se pro zápis komentáøù namísto toho
pou¾ívat normální makro <strong>comment</strong>, které se v¹ak musí zapisovat
stejnì, jako jakákoli jiná forma, tj.&nbsp;i s&nbsp;kulatými závorkami, co¾ na
èitelnosti komentáøù urèitì nepøidá. Nicménì makro <strong>comment</strong> má
svou nezastupitelnou úlohu, proto¾e pomocí nìho mù¾eme do komentáøe
&bdquo;uzavøít&ldquo; i del¹í èást kódu &ndash; ostatnì toto makro je pou¾ito i
v&nbsp;samotných zdrojových kódech jazyka <i>Clojure</i>. Podívejme se na
nìkolik jednoduchých demonstraèních pøíkladù:</p>

<pre>
; jednoøádkové komentáøe
user=&gt; <strong>; toto je komentar</strong>
user=&gt; <strong>; ignorovany v REPL\</strong>
user=&gt;
&nbsp;
; víceøádkový komentáø
user=&gt; <strong>(comment</strong>
<strong>komentar</strong>
<strong>muze</strong>
<strong>mit</strong>
<strong>nekolik</strong>
<strong>radku)</strong>
; pov¹imnìte si, ¾e (comment) vrací hodnotu nil
nil
&nbsp;
user=&gt;
</pre>

<p>Dal¹í velmi èasto pou¾ívané <i>reader makro</i> se zapisuje pomocí znaku \
(zpìtné lomítko). Toto makro slou¾í pro zápis znakových konstant (literálù) do
zdrojového kódu. Tisknutelné znaky je mo¾né zapsat buï pøímo za zpìtné lomítko,
nebo je mo¾né pou¾ít kód libovolného znaku z&times;Unicode, pøièem¾ kód tohoto
znaku musí být zapsán v&nbsp;hexadecimální soustavì za dvojici znakù "\u":</p>

<pre>
; bì¾ný tisknutelný znak:
user=&gt; <strong>\a</strong>
\a
&nbsp;
; dal¹í bì¾ný tisknutelný znak:
user=&gt; <strong>\1</strong>
\1
&nbsp;
; znak "u":
user=&gt; <strong>\u</strong>
\u
; znak s hexadecimální hodnotou 0x40, neboli 64:
&nbsp;
user=&gt; <strong>\u0040</strong>
\@
&nbsp;
; pokus o zápis neplatného znakového literálu:
user=&gt; <strong>\aa</strong>
RuntimeException Unsupported character: \aa  clojure.lang.Util.runtimeException (Util.java:170)
&nbsp;
user=&gt;
</pre>

<p>Posledním &bdquo;jednoduchým&ldquo; <i>reader makrem</i> je makro zapisované
pomocí znaku ^. Toto makro slou¾í k&nbsp;pøiøazení metadat k&nbsp;symbolu,
seznamu, vektoru, mno¾inì èi mapì. S&nbsp;metadaty jsme se ji¾ okrajovì setkali
v&nbsp;pøedchozí èásti tohoto seriálu a budeme se jim je¹tì vìnovat pøí¹tì.
Dnes si pouze uká¾eme základní zpùsob vyu¾ití makra ^:</p>

<pre>
; nastavení metadat k vektoru
user=&gt; <strong>^{:atribut1 "Hodnota1" :atribut2 "Hodnota2"} [1 2 3]</strong>
[1 2 3]
&nbsp;
; ulo¾ení vektoru a k nìmu pøiøazeným metadatùm
; do promìnné vektor
user=&gt; <strong>(def vektor ^{:atribut1 "Hodnota1" :atribut2 "Hodnota2"} [1 2 3])</strong>
#'user/vektor
&nbsp;
; pøeètení stavu promìnné vektor
user=&gt; <strong>vektor</strong>
[1 2 3]
&nbsp;
; pøeètení metadat pøiøazených k promìnné vektor
user=&gt; <strong>(meta vektor)</strong>
{:atribut2 "Hodnota2", :atribut1 "Hodnota1"}
&nbsp;
user=&gt;
</pre>

<p>Navíc existuje i alternativní zpùsob pou¾ití makra ^, který slou¾í pro
naplnìní jediného atributu s&nbsp;názvem :tag:</p>

<pre>
; ulo¾ení vektoru a k nìmu pøiøazeným metadatùm
; do promìnné vektor
user=&gt; <strong>(def vektor ^"xyzzy" [1 2 3])</strong>
#'user/vektor
&nbsp;
; pøeètení stavu promìnné vektor
user=&gt; <strong>vektor</strong>
[1 2 3]
&nbsp;
; pøeètení metadat pøiøazených k promìnné vektor
user=&gt; <strong>(meta vektor)</strong>
{:tag "xyzzy"}
&nbsp;
user=&gt;
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Makro &bdquo;deref&ldquo;</h2>

<p>S&nbsp;makrem objektu <i>reader</i>, které se nazývá &bdquo;deref&ldquo;,
jsme se ji¾ ve skuteènosti v&nbsp;tomto seriálu setkali, a to dokonce na
nìkolika místech. Toto makro toti¾ mù¾e být pou¾ito pro pøeètení hodnoty,
pøesnìji øeèeno stavu reference a pou¾ívá se u mnoha typù referencí
(referenèních typù):</p>

<table>
<tr><th>#</th><th>Referenèní typ</th></tr>
<tr><td>1</td><td>@ref</td></tr>
<tr><td>2</td><td>@agent</td></tr>
<tr><td>3</td><td>@var</td></tr>
<tr><td>4</td><td>@atom</td></tr>
<tr><td>5</td><td>@delay</td></tr>
<tr><td>6</td><td>@future</td></tr>
<tr><td>7</td><td>@promise</td></tr>
</table>

<p>Chování makra @ se v¹ak u rùzných typù referencí li¹í. Zatímco
<strong>@ref</strong>, <strong>@var</strong> èi <strong>@atom</strong> pouze
vrátí aktuální stav reference, v&nbsp;pøípadì pou¾ití <strong>@future</strong>,
<strong>@promise</strong> èi <strong>@agent</strong> se ve skuteènosti musí
poèkat na dokonèení výpoètu, který bì¾í v&nbsp;jiném vláknu. Pro jistotu si
pøipomeòme tabulku s&nbsp;funkcemi a makry pou¾itými pøi práci
s&nbsp;nejdùle¾itìj¹ími referenèními typy:</p>

<table>
<tr><th>Typ</th><th>Var</th><th>Ref</th><th>Atom</th><th>Agent</th></tr>
<tr><td>Vytvoøení</td><td>(def name value)</td><td>(ref value)</td><td>(atom value)</td><td>(agent value)</td></tr>
<tr><td>Nastavení hodnoty</td><td>(set! name value)</td><td>(ref-set ref value)</td><td>(reset! atom value)</td><td>&times;</td></tr>
<tr><td>Aplikace funkce</td><td>&times;</td><td>(alter ref funkce)</td><td>(swap! atom funkce)</td><td>(send agent funkce)</td></tr>
<tr><td>Ètení hodnoty</td><td>name</td><td>@ref</td><td>@atom</td><td>@agent</td></tr>
</table>

<p>Demonstraèní pøíklad na pou¾ití referencí typu ref, tedy
&bdquo;normálních&ldquo; promìnných platných v&nbsp;rámci aktuálního jmenného
prostoru (ve skuteènosti je s&nbsp;referencemi typu ref mo¾né provádìt mnoho
operací, které by s&nbsp;bì¾nými promìnnými nebyly mo¾né):</p>

<pre>
; vytvoøení refu
user=&gt; <strong>(def my-ref (ref 42))</strong>
#'user/my-ref
&nbsp;
; vytvoøení refu
user=&gt; <strong>(def string-ref (ref "Hello world"))</strong>
#'user/string-ref
&nbsp;
; pøeètení refu pomocí makra @
user=&gt; <strong>@my-ref</strong>
42
&nbsp;
; pøeètení refu pomocí makra @
user&gt; <strong>@string-ref</strong>
"Hello world"
&nbsp;
user=&gt;
</pre>

<p>Demonstraèní pøíklad na pou¾ití atomù a samozøejmì i makra @:</p>

<pre>
; vytvoøení nového atomu
user=&gt; <strong>(def x (atom 42))</strong>
#'user/x
&nbsp;
; globální symbol x je navázán
; na atom a nikoli na stav identity
; (=hodnotu)
user=&gt; <strong>x</strong>
#&lt;Atom@61a907: 42&gt;
&nbsp;
; pro získání aktuálního stavu
; je nutné pou¾ít dereferenci
user=&gt; <strong>(deref x)</strong>
42
&nbsp;
; namísto (deref x) se pou¾ívá
; makro preprocesoru @
user=&gt; <strong>@x</strong>
42
&nbsp;
&nbsp;
; atomická zmìna stavu identity
user=&gt; <strong>(reset! x 10)</strong>
10
&nbsp;
user=&gt; <strong>(reset! x (+ 1 2 3))</strong>
6
&nbsp;
user=&gt; <strong>@x</strong>
7
&nbsp;
&nbsp;
; dal¹í mo¾nost atomické zmìny
; stavu identity - nyní pøes funkci
; aplikovanou na atom a popø. i dal¹í
; parametry
user=&gt; <strong>(swap! x + 1)</strong>
7
&nbsp;
user=&gt; <strong>@x</strong>
7
&nbsp;
user=&gt;
</pre>

<p>Pøíklad vytvoøení agenta, poslání funkce agentovi a èekání na dokonèení
výpoètu právì s&nbsp;pou¾itím makra @:</p>

<pre>
; vytvoøení agenta
user=&gt; <strong>(def my-agent (agent 0))</strong>
#'user/my-agent
&nbsp;
; poslání funkce agentovi (6 je druhý parametr funkce)
user=&gt; <strong>(send my-agent + 6)</strong>
#&lt;Agent@18622f3: 0&gt;
&nbsp;
; poslání funkce agentovi (7 je druhý parametr funkce)
user=&gt; <strong>(send my-agent * 7)</strong>
#&lt;Agent@18622f3: 6&gt;
&nbsp;
; dereference - získání nového stavu - pomocí makra @
user=&gt; <strong>@my-agent</strong>
42
&nbsp;
user=&gt;
</pre>

<p>Dal¹í pøíklad s&nbsp;makrem @, tentokrát pou¾itým pro objekty
<i>future</i>:</p>

<pre>
; vytvoøení objektu typu future a spu¹tìní paralelního vlákna
user=&gt; <strong>(def future_fibonacci1 (future (fibonacci 35)))</strong>
#'user/future_fibonacci1
&nbsp;
; vytvoøení dal¹ího objektu typu future a spu¹tìní paralelního vlákna
user=&gt; <strong>(def future_fibonacci2 (future (fibonacci 35)))</strong>
#'user/future_fibonacci2
&nbsp;
; èekání na dokonèení prvního paralelnì bì¾ícího výpoètu
; - zde se vyu¾ívá makro @
user=&gt; <strong>@future_fibonacci1</strong>
9227465
&nbsp;
; èekání na dokonèení druhého paralelnì bì¾ícího výpoètu
; - zde se vyu¾ívá makro @
user=&gt; <strong>@future_fibonacci2</strong>
9227465
&nbsp;
user=&gt;
</pre>

<p>Poslední demonstraèní pøíklad: makro @ a objekty typu <i>promise</i>:</p>

<pre>
; vytvoøení objektu typu promise
; a navázání na symbol promise-test
user=&gt; <strong>(def promise-test (promise))</strong>
#'user/promise-test
&nbsp;
; nastavení hodnoty
user=&gt; <strong>(deliver promise-test 42)</strong>
#&lt;core$promise$reify__6153@1318b: 42&gt;
&nbsp;
; získání nastavené hodnoty pomocí makra @
user=&gt; <strong>@promise-test</strong>
42
&nbsp;
user=&gt;
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Makra &bdquo;quote&ldquo; a &bdquo;syntax-quote&ldquo;</h2>

<p>Koneènì se dostáváme k&nbsp;zajímavìj¹ím a u¾iteènìj¹ím makrùm. Jedno
z&nbsp;nejdùle¾itìj¹ích a nejèastìji pou¾ívaných maker se jmenuje
&bdquo;quote&ldquo; a zapisuje se pomocí apostrofu. Toto makro zakazuje
vyhodnocování seznamù, proto¾e pokud by objekt <i>reader</i> naèetl formu ve
tvaru <strong>(a b c)</strong>, pøedal by ji do funkce <i>eval</i>, kde by se
tato forma vyhodnotila jako volání funkce <strong>a</strong> s&nbsp;parametry
<strong>b</strong> a <strong>c</strong>. Pokud v¹ak <i>reader</i> naète formu
<strong>'(a b c)</strong>, ztransformuje ji do tvaru <strong>(quote (a b
c))</strong>, pøièem¾ <strong>quote</strong> je speciální forma zakazující
vyhodnocení. Na vìt¹inu ostatních objektù kromì seznamù nemá makro
&bdquo;quote&ldquo; vìt¹inou ¾ádný vliv:</p>

<pre>
; zde nemá quote ¾ádný vliv
user=&gt; <strong>'42</strong>
42
&nbsp;
; zákaz vyhodnocení seznamù jako funkce
user=&gt; <strong>'(1 2 3)</strong>
(1 2 3)
&nbsp;
; zde nemá quote ¾ádný vliv
user=&gt; <strong>'[1 2 3]</strong>
[1 2 3]
&nbsp;
; stejné jako pøedchozí forma
user=&gt; <strong>[1 2 3]</strong>
[1 2 3]
&nbsp;
; zákaz vyhodnocení seznamù jako funkce
user=&gt; <strong>'(* 6 7)</strong>
(* 6 7)
&nbsp;
; zde se v¹ak seznam vyhodnotí jako funkce *
user=&gt; <strong>(* 6 7)</strong>
42
&nbsp;
user=&gt;
</pre>

<p>Kromì makra &bdquo;quote&ldquo; je¹tì objekt <i>reader</i> rozeznává ponìkud
komplikovanìj¹í makro nazývané &bdquo;syntax-quote&ldquo;, které se zapisuje
pomocí zpìtného apostrofu: `. Chování tohoto makra se li¹í podle toho,
s&nbsp;jakým typem objektu je pou¾ito, ov¹em ve v¹ech pøípadech se makro chová
tak, aby nedocházelo k&nbsp;vyhodnocení jeho argumentù, popø.&nbsp;ani
k&nbsp;vyhodnocení vnoøených forem. V&nbsp;následujících pøíkladech dochází
k&nbsp;jednoduchému zákazu vyhodnocení pøedané formy:</p>

<pre>
user=&gt; <strong>`42</strong>
42
&nbsp;
user=&gt; <strong>`(1 2 3)</strong>
(1 2 3)
&nbsp;
user=&gt; <strong>`[1 2 3]</strong>
[1 2 3]
&nbsp;
user=&gt;
</pre>

<p>Dále toho makro doká¾e nahradit zjednodu¹ené jméno symbolu jeho plnì
kvalifikovaným jménem. Nejlépe si to opìt uká¾eme na nìkolika pøíkladech:</p>

<pre>
user=&gt; <strong>`seq</strong>
clojure.core/seq
&nbsp;
user=&gt; <strong>`map</strong>
clojure.core/map
&nbsp;
user=&gt; <strong>`Integer/valueOf</strong>
java.lang.Integer/valueOf
&nbsp;
user=&gt;
</pre>

<p>Zákaz vyhodnocení a souèasnì i náhrada zjednodu¹eného jména symbolu na plnì
kvalifikované jméno se projeví tím, ¾e se následující seznamy (a vektor na
konci) nevyhodnotí jako funkce, ale napøíklad funkce * se nahradí plným
jménem:</p>

<pre>
user=&gt; <strong>`(* 6 7)</strong>
(clojure.core/* 6 7)
&nbsp;
user=&gt; <strong>`(str "Hello" "world")</strong>
(clojure.core/str "Hello" "world")
&nbsp;
user=&gt; <strong>`[* seq str xyzzy neznamy]</strong>
[clojure.core/* clojure.core/seq clojure.core/str user/xyzzy user/neznamy]
&nbsp;
user=&gt;
</pre>

<p>Toto makro se pomìrnì èasto pou¾ívá pøi tvorbì u¾ivatelských maker, co¾ si
pøí¹tì uká¾eme na demonstraèních pøíkladech.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Makra &bdquo;unquote&ldquo; a &bdquo;unquote-splicing&ldquo;</h2>

<p>Makro nazvané &bdquo;unquote&ldquo;, které se zapisuje pomocí znaku ~
(tilda) doká¾e vynutit vyhodnocení urèité èásti výrazu, a to tehdy, pokud je
tento výraz umístìn v&nbsp;makru ` (syntax-quote), nikoli v¹ak ' (quote).
Nejprve si uka¾me zpùsob zápisu tohoto makra i to, jaký má toto makro vliv na
zapisované výrazy:</p>

<pre>
; makro quote zaká¾e vyhodnocení celého seznamu
user=&gt; <strong>'(1 2 (* 6 7) (/ 4 2))</strong>
(1 2 (* 6 7) (/ 4 2))
&nbsp;
; makro syntax-quote zaká¾e vyhodnocení takté¾ a
; souèasnì provede náhradu jmen funkcí za jejich plný tvar
user=&gt; <strong>`(1 2 (* 6 7) (/ 4 2))</strong>
(1 2 (clojure.core/* 6 7) (clojure.core// 4 2))
&nbsp;
; pomocí ~ vynutíme vyhodnocení podvýrazu (* 6 7)
user=&gt; <strong>`(1 2 ~(* 6 7) (/ 4 2))</strong>
(1 2 42 (clojure.core// 4 2))
&nbsp;
; pomocí ~ vynutíme vyhodnocení podvýrazu (/ 4 2)
user=&gt; <strong>`(1 2 (* 6 7) ~(/ 4 2))</strong>
(1 2 (clojure.core/* 6 7) 2)
&nbsp;
; pomocí dvou ~ vynutíme vyhodnocení obou podvýrazù
user=&gt; <strong>`(1 2 ~(* 6 7) ~(/ 4 2))</strong>
(1 2 42 2)
&nbsp;
user=&gt;
</pre>

<p>Podobným zpùsobem pracuje i makro ~@, ov¹em to navíc je¹tì provádí
&bdquo;zplo¹»ování seznamù&ldquo;. Prozatím si chování tohoto makra uká¾eme na
velmi jednoduchém umìlém pøíkladu, ov¹em pøí¹tì pøi popisu u¾ivatelských maker
uvidíme, jak mù¾e být ~@ ve skuteènosti u¾iteèné:</p>

<pre>
; u¾ivatelsky definovaný seznam
user=&gt; <strong>(def s '(1 2 3))</strong>
#'user/s
&nbsp;
; makro quote zcela zaká¾e vyhodnocování
user=&gt; <strong>'(1 2 3 (cons s s))</strong>
(1 2 3 (cons s s))
&nbsp;
; makro syntax-quote takté¾, ov¹em je¹tì nahradí
; v¹echny symboly jejich plnými jmény
user=&gt; <strong>`(1 2 3 (cons s s))</strong>
(1 2 3 (clojure.core/cons user/s user/s))
&nbsp;
; vynutíme si vyhodnocení podvýrazu (cons s s)
; který vrací ((1 2 3) 1 2 3)
user=&gt; <strong>`(1 2 3 ~(cons s s))</strong>
(1 2 3 ((1 2 3) 1 2 3))
&nbsp;
; dtto, ov¹em seznam, jen¾ je výsledkem (cons s s)
; je zplo¹tìn (jakoby je
odstranìna jedna úroveò zanoøení)
user=&gt; <strong>`(1 2 3 ~@(cons s s))</strong>
(1 2 3 (1 2 3) 1 2 3)
&nbsp;
user=&gt;
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Makro &bdquo;dispatch&ldquo;</h2>

<p>Posledním typem makra pou¾ívaného internì v&nbsp;objektu <i>reader</i>,
které si v&nbsp;dne¹ním èlánku popí¹eme, je makro nazvané
&bdquo;dispatch&ldquo; jen¾ je ve zdrojovém textu zapisováno pomocí znaku #
(køí¾ek, hash symbol). Pokud <i>reader</i> narazí ve vstupním textu na tento
znak, ví, ¾e má na základì <strong>tìsnì následujícího</strong> znaku vybrat
urèité makro z&nbsp;alternativní tabulky maker. To ve skuteènosti znamená, ¾e
znak # musí být následován dal¹ím znakem se speciálním významem. O jaký znak se
jedná se dozvíme v&nbsp;tabulce zobrazené pod tímto odstavcem:</p>

<table>
<tr><th>#</th><th>Dvojice znakù</th><th>Zpùsob pou¾ití</th><th>Význam</th></tr>
<tr><td>1</td><td>#{</td><td>#{prvky}</td><td>zápis mno¾iny</td></tr>
<tr><td>2</td><td>#"</td><td>#"regexp-pattern"</td><td>zápis regulárního výrazu</td></tr>
<tr><td>3</td><td>#'</td><td>#'var</td><td>quotování promìnných</td></tr>
<tr><td>4</td><td>#(</td><td>#(telo funkce)</td><td>zkrácený zápis anonymní funkce</td></tr>
<tr><td>5</td><td>#_</td><td>#_text</td><td>text je ignorován &ndash; alternativní zpùsob komentáøe</td></tr>
</table>

<p>Nìkteré zápisy uvedené v&nbsp;pøedchozí tabulce ji¾ známe, tak¾e si je
probereme pouze krátce. Asi nejjednodu¹¹í je zápis mno¾iny pomocí makra #{, za
ním¾ následují prvky mno¾iny uzavøené pravou slo¾enou závorkou. Dùvod, proè je
mno¾ina zapsána takto prapodivnì je velmi jednoduchý &ndash; pro mno¾iny ji¾
nezbyly k&nbsp;dispozici ¾ádné vhodné závorky, proto¾e kulaté závorky jsou ji¾
z&nbsp;historických dùvodù vyhrazeny pro seznamy, hranaté závorky se celkem
logicky pou¾ily pro zápis vektorù a slo¾ené závorky (bez # na zaèátku) jsou
pou¾ity pro mapy, které jsou pøece jen vyu¾ívány èastìji ne¾ mno¾iny (je¹tì by
sice bylo mo¾né pou¾ít znaky &lt; a &gt;, to by v¹ak kolidovalo s&nbsp;jejich
standardním významem.</p>

<p>Dal¹í typ makra zaèíná dvojicí znakù #" a konèí znakem " (uvozovky). Mezi
obì uvozovky se zapisují regulární výrazy, které jsou vyu¾ívány nìkterými
funkcemi, napøíklad <strong>re-seq</strong>, <strong>re-find</strong>,
<strong>re-groups</strong> a <strong>re-matches</strong>. Regulární výraz
uvedený v&nbsp;makru #" je zkontrolován a následnì zkompilován ihned
v&nbsp;èase svého naèítání, na rozdíl od regulárního výrazu zadaného
s&nbsp;vyu¾itím funkce <strong>re-pattern</strong>: v&nbsp;tomto pøípadì se
toti¾ kontrola a kompilace provede a¾ ve chvíli, kdy je tato funkce zpracována
a vyhodnocena. Více podrobností o vyu¾ití regulárních výrazù si øekneme
v&nbsp;navazujících èástech tohoto seriálu, zde si jen uká¾eme základy práce
s&nbsp;nimi:</p>

<pre>
; nalezení prvního podøetìzce vyhovujícímu regulárnímu výrazu
user=&gt; <strong>(re-find #"[0-9]+" "123qwe456asd")</strong>
"123"
&nbsp;
; nalezení podøetìzcù vyhovujících zadanému regulárnímu výrazu
user=&gt; <strong>(re-seq #"[0-9]+" "123qwe456asd")</strong>
("123" "456")
&nbsp;
; ulo¾ení výsledku do promìnné result
user=&gt; <strong>(def result (re-seq #"[0-9]+" "123qwe456asd"))</strong>
#'user/result
&nbsp;
; získání prvního podøetìzce
user=&gt; <strong>(first result)</strong>
"123"
&nbsp;
; získání druhého podøetìzce
user=&gt; <strong>(second result)</strong>
"456"
&nbsp;
user=&gt;
</pre>

<p>Dal¹ím makrem objektu <i>reader</i>, které zaèíná znakem #, je makro #(.
Toto makro slou¾í ke zkrácenému zápisu anonymní funkce. Za kulatou závorkou je
pøímo zapsáno tìlo anonymní funkce bez explicitního uvedení jmen parametrù.
Tento zápis se transformuje do volání <strong>fn</strong> je¹tì
v&nbsp;preprocesoru smyèky <i>REPL</i>, tj.&nbsp;samotná smyèka <i>REPL</i> ji¾
&bdquo;vidí&ldquo; pouze zápis speciální formy <strong>fn</strong>). Zápis
vypadá následovnì:</p>

<pre>
#(tìlo anonymní funkce)
</pre>

<p>To, ¾e chybí jméno funkce je pochopitelné &ndash; kdyby funkce mìla jméno,
u¾ by nebyla funkcí anonymní :-) ov¹em absence jmen parametrù mo¾ná mù¾e být
ponìkud matoucí, proto¾e anonymní funkce bez parametrù by vlastnì odpovídala
vrácení konstanty (popø.&nbsp;nefunkcionálním &bdquo;¹ílenostem&ldquo; typu
<strong>random</strong> :-). Ve skuteènosti v¹ak i anonymní funkce vytvoøená
pomocí znaku # parametry mít mù¾e. Ty jsou pojmenovány v&nbsp;závislosti na své
pozici takto: %1, %2 atd. Pøedpokládá se toti¾, ¾e anonymní funkce budou velmi
krátké a s&nbsp;malým mno¾stvím parametrù &ndash; pokud by tomu tak nebylo, nic
programátorùm nebrání vrátit se ke speciální formì <strong>fn</strong>.</p>

<p>Uka¾me si nìjaké pøíklady pou¾ití vytvoøení anonymních funkcí pomocí znaku
#.</p>

<p>Aplikace anonymní funkce vytvoøené s&nbsp;vyu¾itím speciální formy
<strong>fn</strong>:</p>

<pre>
((fn [x y] (* x y)) 6 7)
</pre>

<p>Zkrácený (ekvivalentní) zpùsob zápisu:</p>

<pre>
(#(* %1 %2) 6 7)
</pre>

<p>Anonymní funkce se velmi èasto pou¾ívají jako parametry funkcí
<strong>map</strong>, <strong>pmap</strong>, <strong>filter</strong> apod.:</p>

<pre>
(map #(/ 2 %1) [1 2 3 4 5 6])
(2 1 2/3 1/2 2/5 1/3)
</pre>

<p>Popø.:</p>

<pre>
(map #(/ 2 %1) (range 1 7))
(2 1 2/3 1/2 2/5 1/3)
</pre>

<p>Zbylá makra zaèínající køí¾kem si popí¹eme pøí¹tì.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Eulerovo èíslo<br />
<a href="http://cs.wikipedia.org/wiki/Eulerovo_èíslo">http://cs.wikipedia.org/wiki/Eulerovo_èíslo</a>
</li>

<li>List comprehension<br />
<a href="http://en.wikipedia.org/wiki/List_comprehension">http://en.wikipedia.org/wiki/List_comprehension</a>
</li>

<li>List Comprehensions in Clojure<br />
<a href="http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html">http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html</a>
</li>

<li>Clojure Programming Concepts: List Comprehension<br />
<a href="http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension">http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension</a>
</li>

<li>Clojure core API: for macro<br />
<a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for">http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for</a>
</li>

<li>cirrus machina - The Clojure for macro<br />
<a href="http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/">http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/</a>
</li>

<li>Clojure.org: Clojure home page<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>A Couple of Clojure Agent Examples<br />
<a href="http://lethain.com/a-couple-of-clojure-agent-examples/">http://lethain.com/a-couple-of-clojure-agent-examples/</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/">http://java.sun.com/developer/technicalArticles/DynTypeLang/</a>
</li>

<li>JSR 223: Scripting for the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=223">http://jcp.org/en/jsr/detail?id=223</a>
</li>

<li>JSR 292: Supporting Dynamically Typed Languages on the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=292">http://jcp.org/en/jsr/detail?id=292</a>
</li>

<li>Java 7: A complete invokedynamic example<br />
<a href="http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html">http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html</a>
</li>

<li>InvokeDynamic: Actually Useful?<br />
<a href="http://blog.headius.com/2007/01/invokedynamic-actually-useful.html">http://blog.headius.com/2007/01/invokedynamic-actually-useful.html</a>
</li>

<li>A First Taste of InvokeDynamic<br />
<a href="http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html">http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html</a>
</li>

<li>Java 6 try/finally compilation without jsr/ret<br />
<a href="http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html">http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Root.cz: Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM<br />
<a href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/</a></a>
</li>

<li>Root.cz: JamVM aneb alternativa k HotSpotu nejenom pro embedded zaøízení a chytré telefony<br />
<a href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>FindBugs<br />
<a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a>
</li>

<li>GNU Classpath<br />
<a href="www.gnu.org/s/classpath/">www.gnu.org/s/classpath/</a></li>

<li>Java VMs Compared<br />
<a href="http://bugblogger.com/java-vms-compared-160/">http://bugblogger.com/java-vms-compared-160/</a>
</li>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Scala Programming Language<br />
<a href="http://www.scala-lang.org/">http://www.scala-lang.org/</a>
</li>

<li>Run Scala in Apache Tomcat in 10 minutes<br />
<a href="http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes">http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes</a>
</li>

<li>Fast Web Development With Scala<br />
<a href="http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html">http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html</a>
</li>

<li>Top five scripting languages on the JVM<br />
<a href="http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855">http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>CloseableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html">http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

