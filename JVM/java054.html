<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - sledování èinnosti virtuálního stroje Javy pøes rozhraní JVM TI (2.èást)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - sledování èinnosti virtuálního stroje Javy pøes rozhraní JVM TI (2.èást)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o virtuálním stroji Javy budeme pokraèovat v popisu rozhraní JVM TI, které je mo¾né vyu¾ít pro tvorbu takzvaných agentù monitorujících popø. ovlivòujících chování aplikace v JVM. Dnes se budeme zabývat pøevá¾nì zji¹»ováním jmen i signatur volaných metod a takté¾ sledováním chování správce pamìti. Pøitom se dozvíme dal¹í podrobnosti o rozhraní JVM TI.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - sledování èinnosti virtuálního stroje Javy pøes rozhraní JVM TI (2.èást)</a></p>
<p><a href="#k02">2. Alokace a dealokace pamìti v&nbsp;agentech vyu¾ívajících rozhraní JVM TI</a></p>
<p><a href="#k03">3. Zji¹tìní jmen a signatur volaných metod</a></p>
<p><a href="#k04">4. Ètvrtý demonstraèní pøíklad: výpis signatur v¹ech volaných metod</a></p>
<p><a href="#k05">5. Pou¾ití zámkù v&nbsp;agentech vyu¾ívajících rozhraní JVM TI</a></p>
<p><a href="#k06">6. Funkce CreateRawMonitor, RawMonitorEnter a RawMonitorExit</a></p>
<p><a href="#k07">7. Pátý demonstraèní pøíklad: agent pro výpis volaných metod vyu¾ívající zámky</a></p>
<p><a href="#k08">8. ©estý demonstraèní pøíklad: agent registrující práci garbage collectoru</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - sledování èinnosti virtuálního stroje Javy pøes rozhraní JVM TI (2.èást)</h2>

<p>V&nbsp;dne¹ní èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyku Java i o jeho virtuálním stroji</a> budeme pokraèovat
v&nbsp;popisu rozhraní <i>JVM TI</i>. Navá¾eme na pøedchozí èást, v&nbsp;ní¾
byl na konci (osmá kapitola) ukázán JVM TI agent, který dokázal ve virtuálním
stroji Javy detekovat volání ka¾dé metody. Nyní si øekneme, jak lze tento
pøíklad roz¹íøit takovým zpùsobem, aby se vypisovalo i jméno metody a souèasnì
i její signatura, co¾ je zajisté mnohem u¾iteènìj¹í. Termínem signatura je zde
my¹len jednoznaèný zápis poètu a typù parametrù metody i jejího návratového
typu. Ná¹ nový agent by mìl vypisovat informace o volaných metodách
v&nbsp;tomto formátu:</p>

<pre>
called method method1 with signature (Ljava/lang/String;Ljava/lang/String;)V
called method &lt;init&gt; with signature ()V
called method &lt;init&gt; with signature (I)V
called method &lt;init&gt; with signature ()V
called method append with signature (Ljava/lang/String;)Ljava/lang/StringBuilder;
called method append with signature (Ljava/lang/String;)Ljava/lang/AbstractStringBuilder;
called method length with signature ()I
called method getChars with signature (II[CI)V
called method arraycopy with signature (Ljava/lang/Object;ILjava/lang/Object;II)V
called method append with signature (Ljava/lang/String;)Ljava/lang/StringBuilder;
called method append with signature (Ljava/lang/String;)Ljava/lang/AbstractStringBuilder;
called method length with signature ()I
called method getChars with signature (II[CI)V
called method arraycopy with signature (Ljava/lang/Object;ILjava/lang/Object;II)V
called method append with signature (Ljava/lang/String;)Ljava/lang/StringBuilder;
called method append with signature (Ljava/lang/String;)Ljava/lang/AbstractStringBuilder;
called method length with signature ()I
called method getChars with signature (II[CI)V
called method arraycopy with signature (Ljava/lang/Object;ILjava/lang/Object;II)V
called method toString with signature ()Ljava/lang/String;
called method &lt;init&gt; with signature ([CII)V
called method &lt;init&gt; with signature ()V
called method copyOfRange with signature ([CII)[C
called method min with signature (II)I
called method arraycopy with signature (Ljava/lang/Object;ILjava/lang/Object;II)V
called method method2 with signature (Ljava/lang/String;)V
called method method3 with signature (Ljava/lang/String;)V
called method println with signature (Ljava/lang/String;)V
</pre>

<p>Jméno metody má jasný význam (je¹tì ho pøí¹tì doplníme o jméno pøíslu¹né
tøídy), ov¹em signatura metody mù¾e v&nbsp;nìkterých pøípadech vypadat ponìkud
neèitelnì. Vzhledem k&nbsp;tomu, ¾e se programátoøi se signaturami metod mohou
setkat i v&nbsp;dal¹ích èástech JVM (v&nbsp;bajtkódu atd.), bude vhodné si
ozøejmit, jak se signatury vlastnì zapisují. Obecný tvar jejich zápisu je
následující:</p>

<pre>
&nbsp;
(typy_parametrù)návratový_typ
&nbsp;
</pre>

<p>V¹echny typy, tj.&nbsp;jak typy parametrù metody, tak i její návratový typ,
jsou v&nbsp;pøípadì jednoduchých (primitivních) datových typù zapisovány jedním
znakem (viz té¾ následující tabulka). V&nbsp;pøípadì polí se pou¾ívá znak [,
popø.&nbsp;u vícedimenzionálních polí se zapisuje více znakù [ za sebe. Za
tìmito znaky následuje specifikace typù prvkù polí. Pokud je typem tøída èi
rozhraní, je pøed její jméno zapsán znak L a jméno tøídy/rozhraní je ukonèeno
støedníkem:</p>

<table>
<tr><th>#</th><th>Znak/øetìzec</th><th>Datový typ</th><th>Význam</th></tr>
<tr><td> 1</td><td>B            </td><td>byte</td><td>osmibitové celé èíslo se znaménkem</td></tr>
<tr><td> 2</td><td>C            </td><td>char</td><td>znak reprezentovaný v&nbsp;Unikódu</td></tr>
<tr><td> 3</td><td>D            </td><td>double</td><td>èíslo s&nbsp;plovoucí øádovou èárkou s&nbsp;dvojitou pøesností</td></tr>
<tr><td> 4</td><td>F            </td><td>float</td><td>èíslo s&nbsp;plovoucí øádovou èárkou s&nbsp;jednoduchou pøesností</td></tr>
<tr><td> 5</td><td>I            </td><td>int</td><td>32bitové celé èíslo se znaménkem</td></tr>
<tr><td> 6</td><td>J            </td><td>long</td><td>64bitové celé èíslo se znaménkem</td></tr>
<tr><td> 7</td><td>Ljméno_tøídy;</td><td>reference</td><td>instance tøídy zadaného jména</td></tr>
<tr><td> 8</td><td>S            </td><td>short</td><td>16bitové celé èíslo se znaménkem</td></tr>
<tr><td> 9</td><td>Z            </td><td>boolean</td><td>pravdivostní hodnota true/false</td></tr>
<tr><td>10</td><td>V            </td><td>void</td><td>void &ndash; pouze u návratového typu</td></tr>
<tr><td>11</td><td>[            </td><td>reference</td><td>jednodimenzionální pole</td></tr>
</table>

<p>Podívejme se nyní na nìkolik jednoduchých pøíkladù zápisu signatur:</p>

<pre>
void foo()           ()V
int foo()            ()I
int foo(int, int)    (II)I
float foo()          ()F
double foo()         ()D
void foo(int)        (I)V
int[] foo()          ()[I
int[][] foo()        ()[[I
String foo()         ()Ljava.lang.String;
void foo(String)     (Ljava/lang/String;)V
String foo(String)   (Ljava/lang/String;)Ljava.lang.String;
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Alokace a dealokace pamìti v&nbsp;agentech vyu¾ívajících rozhraní JVM TI</h2>

<p>Je¹tì pøedtím, ne¾ si <a href="#k04">ve ètvrté kapitole</a> uká¾eme zdrojový
text ètvrtého demonstraèního agenta, se musíme dozvìdìt základní informace o
dvou funkcích nazvaných <strong>Allocate</strong> a <strong>Deallocate</strong>
z&nbsp;rozhraní <i>JVM TI</i> urèených pro alokaci a dealokaci pamìti pøímo za
bìhu agenta (<i>runtime</i>). Tato dvojice funkcí obecnì provádí správu pamìti
odli¹ným zpùsobem ne¾ céèkové funkce <strong>malloc/calloc/alloca/free</strong>
a samozøejmì se takté¾ li¹í od dvojice operátorù <strong>new/delete</strong>
pou¾ívaných v&nbsp;programovacím jazyce C++. Z&nbsp;tohoto dùvodu budu
v&nbsp;pøípadì demonstraèních agentù pøi alokacích a dealokacích pamìti
vìt¹inou pou¾ívat funkce nabízené pøímo rozhraním <i>JVM TI</i>, co¾ má tu
výhodu, ¾e není nutné slo¾itì zji¹»ovat, jakým zpùsobem se má provést dealokace
(uvolnìní) bloku pamìti ve funkci, které se &bdquo;odnìkud
z&nbsp;neznáma&ldquo; pøedává ukazatel na døíve alokovaný pamì»ový region.
Pojïme si tedy nyní obì zmiòované funkce popsat.</p>

<p>Pro alokaci pamì»ového regionu (typicky se jedná o øetìzce &ndash; názvy
tøíd, metod, atributù atd.) je vhodné namísto funkcí ze standardní céèkové
knihovny pou¾ít funkci nazvanou <strong>Allocate</strong>, které se pøedá
po¾adovaná velikost alokované pamìti (zde je pou¾it typ <strong>jlong</strong>
z&nbsp;rozhraní <i>JNI &ndash; Java Native Interface</i>, který vìt¹inou
odpovídá datovému typu <strong>long int</strong> èi <strong>long long
int</strong>) a takté¾ ukazatel na øetìzec, který je po zavolání funkce
<strong>Allocate</strong> naplnìn adresou, na ní¾ zaèíná oblast vyhrazená pro
novì alokovaný øetìzec/pamì»ový blok. Za øetìzec pova¾ujme v&nbsp;céèku pro
jednoduchost typ <strong>char*</strong>, ukazatel na øetìzec má potom typ
<strong>char**</strong>. Je nutné mít na pamìti, ¾e návratovou hodnotou této
funkce NENÍ ukazatel na vytvoøený øetìzec/pamì»ový region (jako je tomu
napøíklad u funkcí <strong>malloc</strong>, <strong>calloc</strong> èi
<strong>alloca</strong> ze standardní céèkové knihovny), ale chybový kód,
podobnì jako je tomu u vìt¹iny funkcí z&nbsp;rozhraní <i>JVM TI</i>. Ukazatel
na alokovaný pamì»ový region je nutné v¾dy získat pøes druhý parametr této
funkce:</p>

<pre>
jvmtiError
<strong>Allocate</strong>(
            jvmtiEnv* env,
            jlong size,
            unsigned char** mem_ptr)
</pre>

<p>Opakem funkce <strong>Allocate</strong> je funkce
<strong>Deallocate</strong>, která naopak provede uvolnìní døíve naalokovaného
pamì»ového regionu. Této funkci se opìt pøedává odkaz na strukturu
<strong>jvmtiEnv</strong> a ukazatel na oblast pamìti alokovanou døíve pomocí
funkce <strong>Allocate</strong>:</p>

<pre>
jvmtiError
<strong>Deallocate</strong>(
            jvmtiEnv* env,
            unsigned char* mem)
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zji¹tìní jmen a signatur volaných metod</h2>

<p>Se znalostí funkce <strong>Allocate()</strong> a pøedev¹ím pak funkce
<strong>Deallocate()</strong> je ji¾ mo¾né upravit demonstraèní pøíklad ze
závìru pøedchozího èlánku takovým zpùsobem, aby mohl vypisovat jména a
signatury v¹ech volaných metod. Pro tyto úèely mù¾e ná¹ testovací agent pou¾ít
funkci nazvanou <strong>GetMethodName()</strong>, její¾ hlavièka vypadá
následovnì:</p>

<pre>
jvmtiError
<strong>GetMethodName</strong>(
            jvmtiEnv* env,
            jmethodID method,
            char** name_ptr,
            char** signature_ptr,
            char** generic_ptr)
</pre>

<p>Prvním parametrem této funkce je odkaz na strukturu
<strong>jvmtiEnv</strong>, který je pou¾it ve vìt¹inì funkcí rozhraní <i>JVM
TI</i>, tak¾e se pro nás nejedná o ¾ádnou novinku. Druhým parametrem funkce je
identifikátor metody, který je typu <strong>jmethodID</strong>. Tento typ je
vìt¹inou v&nbsp;hlavièkovém souboru <strong>jvmti.h</strong> deklarován jako
<strong>long int</strong> èi <strong>long long int</strong> v&nbsp;závislosti
na architektuøe poèítaèe a pou¾itém systému. Dal¹í tøi parametry jsou ji¾
mnohem zajímavìj¹í, proto¾e jejich datový typ je <strong>char**</strong>,
tj.&nbsp;jedná se o ukazatele na &bdquo;øetìzce&ldquo;, kde øetìzce jsou
v&nbsp;céèku pøedstavovány typem <strong>char*</strong>,
popø.&nbsp;<strong>const char *</strong>. Dùvod, proè se do funkce
<strong>GetMethodName</strong> pøedávají ukazatele na øetìzce, je prostý
&ndash; tato funkce toti¾ sama provede alokaci tìchto øetìzcù, které budou mít
v¾dy vhodnou délku, nezávisle na tom, jak dlouhé je jméno metody a jaký je
poèet a typ jejich parametrù (to samozøejmì ovlivòuje délku signatury).
Vrácené øetìzce jsou v&nbsp;UTF-8, co¾ by v¹ak nemìl být pro moderní systémy
(a jejich konzole) ¾ádný problém :-). Pouze je zapotøebí s&nbsp;tímto kódováním
poèítat v&nbsp;tìch pøípadech, kdy by se provádìlo dal¹í zpracování øetìzcù
(regulární výrazy atd.).</p>

<p>Oproti mnoha funkcím ze standardní knihovny céèka tak nemusíme slo¾itì
pøemý¹let, jak dlouhé øetìzce je zapotøebí alokovat, pamatovat si maximální
délku øetìzcù atd. Musíme v¹ak dodr¾et jednu podmínku &ndash; øetìzce vrácené
funkcí <strong>GetMethodName</strong> je nutné (ideálnì co nejdøíve) dealokovat
zavoláním funkce <strong>Deallocate()</strong>, nelze tedy pou¾ít funkci
<strong>free()</strong> ze standardní céèkové knihovny èi
<strong>delete</strong> v&nbsp;C++. Pokud se do tøetího a¾ pátého parametru
funkce <strong>GetMethodName</strong> pøedá hodnota NULL, nebude se pøíslu¹ný
øetìzec alokovat, co¾ vyu¾ijeme u posledního parametru, jen¾ nás (prozatím)
nezajímá.</p>

<p>S&nbsp;vyu¾itím funkcí <strong>GetMethodName</strong> a
<strong>Deallocate</strong> mù¾eme napsat upravenou variantu callback funkce
<strong>callback_on_method_entry</strong>:</p>

<pre>
<i>/*</i>
<i> * Callback funkce zavolana pri zavolani metody.</i>
<i> */</i>
static void JNICALL <strong>callback_on_method_entry</strong>(jvmtiEnv *jvmti, JNIEnv* env,
        jthread thread, jmethodID method)
{
    char *name_ptr;
    char *signature_ptr;
&nbsp;
    <i>/* MSG("Got Method Entry event"); */</i>
    (*jvmti)-&gt;<strong>GetMethodName</strong>(jvmti, method, &amp;name_ptr, &amp;signature_ptr, NULL);
    printf("called method %s with signature %s\n", name_ptr, signature_ptr);
    (*jvmti)-&gt;<strong>Deallocate</strong>(jvmti, (unsigned char *)name_ptr);
    (*jvmti)-&gt;<strong>Deallocate</strong>(jvmti, (unsigned char *)signature_ptr);
}
</pre>

<p>Tato funkce bude vyu¾ita ve ètvrtém demonstraèním pøíkladu, jeho¾ zdrojový
kód je popsán <a href="#k04">v&nbsp;následující kapitole</a>.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Ètvrtý demonstraèní pøíklad: výpis signatur v¹ech volaných metod</h2>

<p>S&nbsp;vyu¾itím informací získaných v&nbsp;pøedchozích tøech kapitolách je
ji¾ pomìrnì jednoduché upravit demonstraèní pøíklad ukázaný v&nbsp;závìru
pøedchozího èlánku takovým zpùsobem, aby vypisoval jména a souèasnì i signatury
volaných metod. Pøipomeòme si, ¾e pro implementaci této funkcionality agenta je
zapotøebí provést ètyøi kroky:</p>

<ol>

<li>Nastavit po¾adovanou speciální schopnost agenta pomocí
<strong>capabilities.can_generate_method_entry_events = 1;</strong> ve funkci
<strong>set_capabilities()</strong> a otestovat, zda daný virtuální stroj tuto
schopnost nabízí.</li>

<li>Vytvoøit callback funkci <strong>callback_on_method_entry</strong> (jméno
se samozøejmì mù¾e li¹it, typy parametrù v¹ak nikoli) s&nbsp;hlavièkou
<strong>static void JNICALL callback_on_method_entry(jvmtiEnv *jvmti, JNIEnv*
env, jthread thread, jmethodID method)</strong>.</li>

<li>Zaregistrovat tuto callback funkci pomocí <strong>callbacks.MethodEntry =
&callback_on_method_entry;</strong>, co¾ se v&nbsp;na¹ich demonstraèních
agentech provádí ve funkci
<strong>register_all_callback_functions()</strong>.</li>

<li>Nastavit zachytávání tohoto typu události s&nbsp;vyu¾itím funkce
<strong>SetEventNotificationMode()</strong> volané v&nbsp;na¹ich demonstraèních
agentech z&nbsp;funkce <strong>set_event_notification_mode</strong>.</li>

</ol>

<p>Následuje výpis celého zdrojového kódu ètvrtého demonstraèního JVM TI
agenta:</p>

<pre>
<i>/*</i>
<i> * JVM TI agent, ktery dokaze registrovat vstup do metody</i>
<i> * a nasledne vypsat i jeji signaturu.</i>
<i> */</i>
&nbsp;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
&nbsp;
<i>/* Nutno nastavit cestu pres volbu -Icesta_k_jvm */</i>
#include &lt;jvmti.h&gt;
&nbsp;
#define AGENT_NAME "Agent4:"
&nbsp;
<i>/*</i>
<i> * Vypis zpravy na standardni vystup.</i>
<i> */</i>
#define MSG(message) puts(AGENT_NAME " " message)
&nbsp;
<i>/*</i>
<i> * Vypis kodu chyby a chybove zpravy.</i>
<i> */</i>
static void <strong>print_jvmti_error</strong>(jvmtiEnv *jvmti, jvmtiError error_code, const char *str)
{
    char *error_code_str = NULL;
    const char *msg_str = str == NULL ? "" : str;
    char *msg_err = NULL;
&nbsp;
    (*jvmti)-&gt;GetErrorName(jvmti, error_code, &amp;error_code_str);
    msg_err = error_code_str == NULL ? "Unknown" : error_code_str;
    printf(AGENT_NAME " ERROR: JVMTI: %d(%s): %s\n", error_code, msg_err, msg_str);
}
&nbsp;
<i>/*</i>
<i> * Pokud je predany navratovy kod chybovym kodem, vypise se hlaseni.</i>
<i> */</i>
static void <strong>check_jvmti_error</strong>(jvmtiEnv *jvmti, jvmtiError error_code, const char *str)
{
    if ( error_code != JVMTI_ERROR_NONE )
    {
        print_jvmti_error(jvmti, error_code, str);
    }
}
&nbsp;
<i>/*</i>
<i> * Nastaveni pozadovanych schopnosti agenta.</i>
<i> */</i>
jvmtiError <strong>set_capabilities</strong>(jvmtiEnv *jvmti)
{
    jvmtiCapabilities capabilities;
    jvmtiError error_code;
&nbsp;
    memset(&amp;capabilities, 0, sizeof(jvmtiCapabilities));
&nbsp;
    <i>/* jedna specialni schopnost agenta */</i>
    capabilities.can_generate_method_entry_events = 1;
&nbsp;
    error_code = (*jvmti)-&gt;AddCapabilities(jvmti, &amp;capabilities);
    check_jvmti_error(jvmti, error_code, "Unable to get necessary JVMTI capabilities.");
    return error_code;
}
&nbsp;
<i>/*</i>
<i> * Callback funkce zavolana pri inicializaci virtualniho stroje.</i>
<i> */</i>
static void JNICALL <strong>callback_on_vm_init</strong>(jvmtiEnv *jvmti_env, JNIEnv* env, jthread thread)
{
    MSG("Got VM init event");
}
&nbsp;
<i>/*</i>
<i> * Callback funkce zavolana pri ukonceni cinnosti virtualniho stroje.</i>
<i> */</i>
static void JNICALL <strong>callback_on_vm_death</strong>(jvmtiEnv *jvmti_env, JNIEnv* env)
{
    MSG("Got VM Death event");
}
&nbsp;
<i>/*</i>
<i> * Callback funkce zavolana pri zavolani metody.</i>
<i> */</i>
static void JNICALL <strong>callback_on_method_entry</strong>(jvmtiEnv *jvmti, JNIEnv* env,
        jthread thread, jmethodID method)
{
    char *name_ptr;
    char *signature_ptr;
&nbsp;
    <i>/* MSG("Got Method Entry event"); */</i>
    (*jvmti)-&gt;GetMethodName(jvmti, method, &amp;name_ptr, &amp;signature_ptr, NULL);
    printf("called method %s with signature %s\n", name_ptr, signature_ptr);
    (*jvmti)-&gt;Deallocate(jvmti, (unsigned char *)name_ptr);
    (*jvmti)-&gt;Deallocate(jvmti, (unsigned char *)signature_ptr);
}
&nbsp;
<i>/*</i>
<i> * Registrace vsech callback funkci.</i>
<i> */</i>
jvmtiError <strong>register_all_callback_functions</strong>(jvmtiEnv *jvmti)
{
    jvmtiEventCallbacks callbacks;
    jvmtiError error_code;
&nbsp;
    memset(&amp;callbacks, 0, sizeof(callbacks));
&nbsp;
    <i>/* JVMTI_EVENT_VM_INIT */</i>
    callbacks.VMInit = &amp;callback_on_vm_init;
&nbsp;
    <i>/* JVMTI_EVENT_VM_DEATH */</i>
    callbacks.VMDeath = &amp;callback_on_vm_death;
&nbsp;
    <i>/* JVMTI_EVENT_METHOD_ENTRY */</i>
    callbacks.MethodEntry = &amp;callback_on_method_entry;
&nbsp;
    error_code = (*jvmti)-&gt;SetEventCallbacks(jvmti, &amp;callbacks, (jint)sizeof(callbacks));
    check_jvmti_error(jvmti, error_code, "Cannot set JVM TI callbacks");
    return error_code;
}
&nbsp;
<i>/*</i>
<i> * Nastaveni jedne udalosti, pro nez se ma zavolat callback funkce.</i>
<i> */</i>
jvmtiError <strong>set_event_notification_mode</strong>(jvmtiEnv *jvmti, int event)
{
    jvmtiError error_code;
&nbsp;
    error_code = (*jvmti)-&gt;SetEventNotificationMode(jvmti, JVMTI_ENABLE, event, (jthread)NULL);
    check_jvmti_error(jvmti, error_code, "Cannot set event notification");
    return error_code;
}
&nbsp;
<i>/*</i>
<i> * Nastaveni udalosti, pro nez se maji zavolat callback funkce.</i>
<i> */</i>
jvmtiError <strong>set_event_notification_modes</strong>(jvmtiEnv *jvmti)
{
    jvmtiError error_code;
&nbsp;
    <i>/* Potrebujeme zachytavat udalost inicializace virtualniho stroje. */</i>
    if ((error_code = set_event_notification_mode(jvmti, JVMTI_EVENT_VM_INIT)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
    <i>/* Potrebujeme zachytavat udalost ukonceni prace virtualniho stroje. */</i>
    if ((error_code = set_event_notification_mode(jvmti, JVMTI_EVENT_VM_DEATH)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
    <i>/* Potrebujeme zachytavat udalost pri vstupu do metody. */</i>
    if ((error_code = set_event_notification_mode(jvmti, JVMTI_EVENT_METHOD_ENTRY)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
    return error_code;
}
&nbsp;
<i>/*</i>
<i> * Funkce zavolana ve chvili nacitani agenta do JVM.</i>
<i> */</i>
JNIEXPORT jint JNICALL <strong>Agent_OnLoad</strong>(JavaVM *jvm, char *options, void *reserved)
{
    jvmtiEnv *jvmti = NULL;
    jint result;
    jvmtiError error_code;
&nbsp;
    MSG("Agent_OnLoad");
    result = (*jvm)-&gt;GetEnv(jvm, (void **) &amp;jvmti, JVMTI_VERSION_1_0);
    if (result != JNI_OK || jvmti == NULL)
    {
        printf("ERROR: Unable to access JVMTI Version 1 (0x%x),"
                " is your J2SE a 1.5 or newer version? JNIEnv's GetEnv() returned %d\n",
                JVMTI_VERSION_1, (int)result);
        return result;
    }
    MSG("JVM TI version is correct");
&nbsp;
    <i>/* nastaveni pozadovanych schopnosti agenta */</i>
    if ((error_code = set_capabilities(jvmti)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
    <i>/* registrace vsech (dvou) callback funkci */</i>
    if ((error_code = register_all_callback_functions(jvmti)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
    <i>/* nastaveni udalosti, pro nez se maji zavolat callback funkce */</i>
    if ((error_code = set_event_notification_modes(jvmti)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
    return JNI_OK;
}
&nbsp;
<i>/*</i>
<i> * Funkce zavolana ve chvili odstranovani agenta z JVM.</i>
<i> */</i>
JNIEXPORT void JNICALL <strong>Agent_OnUnload</strong>(JavaVM *vm)
{
    MSG("Agent_OnUnload");
}
</pre>

<p>Funkcionalitu tohoto agenta si mù¾eme snadno odzkou¹et napøíklad na
následujícím testu:</p>

<pre>
public class <strong>Test4</strong> {
&nbsp;
    public static void <strong>method1</strong>(String s1, String s2) {
        method2(s1 + " " + s2);
    }
&nbsp;
    public static void <strong>method2</strong>(String s) {
        method3(s);
    }
&nbsp;
    public static void <strong>method3</strong>(String s) {
        System.err.println(s);
    }
&nbsp;
    public static void <strong>main</strong>(String[] args) {
        method1("Hello", "world");
        method1("Hello", "world");
    }
}
</pre>

<p>Zpùsob pøekladu i spu¹tìní je shodný se zpùsobem popsaným v&nbsp;pøedchozí
èásti tohoto seriálu, li¹í se jen název agenta i název testovacího javovského
programu:</p>

<pre>
<i># pøeklad agenta</i>
gcc -Wall -ansi -I/usr/lib/jvm/java-1.6.0-openjdk/include/ -shared -o libagent4.so agent4.c
&nbsp;
<i># pøeklad testu</i>
javac Test4.java
&nbsp;
<i># spu¹tìní JVM s agentem a testem</i>
java -agentpath:./libagent4.so Test4
</pre>

<p>Na konzoli by se mìl vypsat následující text:</p>

<pre>
Agent4: Agent_OnLoad
Agent4: JVM TI version is correct
Agent4: Got VM init event
...
...
...
called method method2 with signature (Ljava/lang/String;)V
called method method3 with signature (Ljava/lang/String;)V
called method println with signature (Ljava/lang/String;)V
...
...
...
Agent4: Got VM Death event
Agent4: Agent_OnUnload
</pre>

<p>Poèet skuteènì volaných metod se li¹í v&nbsp;závislosti na pou¾itém
virtuálním stroji Javy, ale prakticky v¾dy pùjde o nìkolik set a¾ nìkolik tisíc
(!) metod, co¾ je i jeden z&nbsp;dùvodù, proè je start JVM pomìrnì pomalý.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Pou¾ití zámkù v&nbsp;agentech vyu¾ívajících rozhraní JVM TI</h2>

<p>V&nbsp;nìkterých pøípadech je nutné zajistit, aby se nìjaká callback funkce
v&nbsp;agentovi provádìla v&nbsp;daný okam¾ik pouze v&nbsp;jednom vláknu. U
nìkterých typù callback funkcí to zaji¹»uje samotný virtuální stroj Javy, u
dal¹ích callback funkcí je zaji¹tìní synchronizace plnì v&nbsp;rukou vývojáøe,
který vytváøí agenta. Ve skuteènosti není zaji¹tìní synchronizace nic
slo¾itého, proto¾e nám pøíslu¹né prostøedky nabízí samotné rozhraní <i>JVM
TI</i>. V&nbsp;nìm lze toti¾ vyu¾ít zámek pøedstavovaný (z&nbsp;hlediska
agenta) objektem typu <strong>jrawMonitorID</strong>. Tìchto zámkù lze vytvoøit
prakticky libovolné mno¾ství, ov¹em pokud se v&nbsp;callback funkcích souèasnì
pou¾ije více zámkù, musí si programátor pohlídat, aby nedo¹lo k&nbsp;dead
locku. Aby jsme tomu zabránili, bude se v&nbsp;demonstraèních agentech pou¾ívat
pouze jeden zámek, co¾ sice nemusí být optimální z&nbsp;hlediska celkového
výkonu JVM, ale je to bezpeènìj¹í postup. Pro práci se zámky se pou¾ívá nìkolik
funkcí nazvaných <strong>CreateRawMonitor</strong>,
<strong>DestroyRawMonitor</strong>, <strong>RawMonitorEnter</strong>,
<strong>RawMonitorExit</strong>, <strong>RawMonitorWait</strong> atd. My si
prozatím vystaèíme jen se tøemi funkcemi popsanými v&nbsp;dal¹ích
odstavcích.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Funkce CreateRawMonitor, RawMonitorEnter a RawMonitorExit</h2>

<p>V&nbsp;demonstraèním agentovi budeme pou¾ívat jeden globální zámek, který
bude reprezentován objektem typu <strong>jrawMonitorID</strong>:</p>

<pre>
jrawMonitorID  global_lock;
</pre>

<p>Pro vytvoøení zámku se pou¾ívá funkce <strong>CreateRawMonitor</strong>,
které se pøedá textový identifikátor zámku a takté¾ ukazatel na na¹i globální
promìnnou. Funkce <strong>CreateRawMonitor</strong> samozøejmì vrací stavový
kód, který je vhodné otestovat:</p>

<pre>
<i>/*</i>
<i> * Vytvoreni zamku.</i>
<i> */</i>
jvmtiError <strong>create_raw_monitor</strong>(jvmtiEnv *jvmti)
{
    jvmtiError error_code;

    error_code = (*jvmti)-&gt;<strong>CreateRawMonitor</strong>(jvmti, "agent data", &amp;global_lock);
    check_jvmti_error(jvmti, error_code, "Cannot create raw monitor");

    return error_code;
}
</pre>

<p>Pro vstup do kritické sekce (hlídané monitorem/zámkem) se pou¾ívá funkce
nazvaná <strong>RawMonitorEnter</strong>. Tato funkce zajistí, ¾e do sekce mù¾e
vstoupit pouze jedno vlákno, ostatní vlákna budou èekat, a¾ aktuální vlákno
sekci opustí:</p>

<pre>
<i>/*</i>
<i> * Vstup do kriticke sekce.</i>
<i> */</i>
static void <strong>enter_critical_section</strong>(jvmtiEnv *jvmti)
{
    jvmtiError error_code;

    error_code = (*jvmti)-&gt;<strong>RawMonitorEnter</strong>(jvmti, global_lock);
    check_jvmti_error(jvmti, error_code, "Cannot enter with raw monitor");
}
</pre>

<p>Výstup z&nbsp;kritické sekce hlídané monitorem/zámkem se oznamuje zavoláním
funkce <strong>RawMonitorExit</strong>:</p>

<pre>
<i>/*</i>
<i> * Vystup z kriticke sekce</i>
<i> */</i>
static void <strong>exit_critical_section</strong>(jvmtiEnv *jvmti)
{
    jvmtiError error_code;

    error_code = (*jvmti)-&gt;<strong>RawMonitorExit</strong>(jvmti, global_lock);
    check_jvmti_error(jvmti, error_code, "Cannot exit with raw monitor");
}
</pre>

<p>Pro vìt¹í èitelnost zdrojového kódu agenta je vhodné celou kritickou sekci
omezenou voláním na¹ich funkcí <strong>enter_critical_section()</strong> a
<strong>exit_critical_section()</strong> uzavøít do samostatného bloku.
Programový kód zapsaný v&nbsp;kritické sekci by mìl být co nejkrat¹í
(z&nbsp;hlediska doby provedení) a v&nbsp;¾ádném pøípadì by se nemìl výstup
z&nbsp;kritické sekce pøeskakovat pomocí lokálních (goto) èi globálních
(longjmp) skokù:</p>

<pre>
<i>/*</i>
<i> * Callback funkce zavolana pri zavolani metody.</i>
<i> */</i>
static void JNICALL <strong>callback_on_method_entry</strong>(jvmtiEnv *jvmti, JNIEnv* env,
        jthread thread, jmethodID method)
{
    char *name_ptr;
    char *signature_ptr;

    <strong>enter_critical_section(jvmti);</strong>
    {
        /* MSG("Got Method Entry event"); */
        (*jvmti)-&gt;GetMethodName(jvmti, method, &amp;name_ptr, &amp;signature_ptr, NULL);
        printf("called method %s with signature %s\n", name_ptr, signature_ptr);
        (*jvmti)-&gt;Deallocate(jvmti, (unsigned char *)name_ptr);
        (*jvmti)-&gt;Deallocate(jvmti, (unsigned char *)signature_ptr);
    }
    <strong>exit_critical_section(jvmti);</strong>
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Pátý demonstraèní pøíklad: agent pro výpis volaných metod vyu¾ívající zámky</h2>

<p>Pátý demonstraèní agent se od ètvrtého agenta li¹í pouze v&nbsp;jedné
malièkosti &ndash; vyu¾ívá se zde globální zámek podle postupu popsaného <a
href="#k05">v&nbsp;pøedchozí kapitole</a>. ®ádné dal¹í odli¹nosti od
pøedchozího pøíkladu zde nenalezneme:</p>

<pre>
<i>/*</i>
<i> * JVM TI agent, ktery dokaze registrovat vstup do metody</i>
<i> * a nasledne vypsat i jeji signaturu.</i>
<i> *</i>
<i> * Zdrojovy kod byl doplnen o pouziti zamku.</i>
<i> */</i>
&nbsp;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
&nbsp;
<i>/* Nutno nastavit cestu pres volbu -Icesta_k_jvm */</i>
#include &lt;jvmti.h&gt;
&nbsp;
#define AGENT_NAME "Agent5:"
&nbsp;
<i>/*</i>
<i> * Vypis zpravy na standardni vystup.</i>
<i> */</i>
#define MSG(message) puts(AGENT_NAME " " message)
&nbsp;
<i>/* Zamek pouzivany agentem */</i>
jrawMonitorID  global_lock;
&nbsp;
<i>/*</i>
<i> * Vypis kodu chyby a chybove zpravy.</i>
<i> */</i>
static void <strong>print_jvmti_error</strong>(jvmtiEnv *jvmti, jvmtiError error_code, const char *str)
{
    char *error_code_str = NULL;
    const char *msg_str = str == NULL ? "" : str;
    char *msg_err = NULL;
&nbsp;
    (*jvmti)-&gt;GetErrorName(jvmti, error_code, &amp;error_code_str);
    msg_err = error_code_str == NULL ? "Unknown" : error_code_str;
    printf(AGENT_NAME " ERROR: JVMTI: %d(%s): %s\n", error_code, msg_err, msg_str);
}
&nbsp;
<i>/*</i>
<i> * Pokud je predany navratovy kod chybovym kodem, vypise se hlaseni.</i>
<i> */</i>
static void <strong>check_jvmti_error</strong>(jvmtiEnv *jvmti, jvmtiError error_code, const char *str)
{
    if ( error_code != JVMTI_ERROR_NONE )
    {
        print_jvmti_error(jvmti, error_code, str);
    }
}
&nbsp;
<i>/*</i>
<i> * Vytvoreni zamku.</i>
<i> */</i>
jvmtiError <strong>create_raw_monitor</strong>(jvmtiEnv *jvmti)
{
    jvmtiError error_code;
&nbsp;
    error_code = (*jvmti)-&gt;CreateRawMonitor(jvmti, "agent data", &amp;global_lock);
    check_jvmti_error(jvmti, error_code, "Cannot create raw monitor");
&nbsp;
    return error_code;
}
&nbsp;
<i>/*</i>
<i> * Vstup do kriticke sekce.</i>
<i> */</i>
static void <strong>enter_critical_section</strong>(jvmtiEnv *jvmti)
{
    jvmtiError error_code;
&nbsp;
    error_code = (*jvmti)-&gt;RawMonitorEnter(jvmti, global_lock);
    check_jvmti_error(jvmti, error_code, "Cannot enter with raw monitor");
}
&nbsp;
<i>/*</i>
<i> * Vystup z kriticke sekce</i>
<i> */</i>
static void <strong>exit_critical_section</strong>(jvmtiEnv *jvmti)
{
    jvmtiError error_code;
&nbsp;
    error_code = (*jvmti)-&gt;RawMonitorExit(jvmti, global_lock);
    check_jvmti_error(jvmti, error_code, "Cannot exit with raw monitor");
}
&nbsp;
<i>/*</i>
<i> * Nastaveni pozadovanych schopnosti agenta.</i>
<i> */</i>
jvmtiError <strong>set_capabilities</strong>(jvmtiEnv *jvmti)
{
    jvmtiCapabilities capabilities;
    jvmtiError error_code;
&nbsp;
    memset(&amp;capabilities, 0, sizeof(jvmtiCapabilities));
&nbsp;
    <i>/* jedna specialni schopnost agenta */</i>
    capabilities.can_generate_method_entry_events = 1;
&nbsp;
    error_code = (*jvmti)-&gt;AddCapabilities(jvmti, &amp;capabilities);
    check_jvmti_error(jvmti, error_code, "Unable to get necessary JVMTI capabilities.");
    return error_code;
}
&nbsp;
<i>/*</i>
<i> * Callback funkce zavolana pri inicializaci virtualniho stroje.</i>
<i> */</i>
static void JNICALL <strong>callback_on_vm_init</strong>(jvmtiEnv *jvmti_env, JNIEnv* env, jthread thread)
{
    MSG("Got VM init event");
}
&nbsp;
<i>/*</i>
<i> * Callback funkce zavolana pri ukonceni cinnosti virtualniho stroje.</i>
<i> */</i>
static void JNICALL <strong>callback_on_vm_death</strong>(jvmtiEnv *jvmti_env, JNIEnv* env)
{
    MSG("Got VM Death event");
}
&nbsp;
<i>/*</i>
<i> * Callback funkce zavolana pri zavolani metody.</i>
<i> */</i>
static void JNICALL <strong>callback_on_method_entry</strong>(jvmtiEnv *jvmti, JNIEnv* env,
        jthread thread, jmethodID method)
{
    char *name_ptr;
    char *signature_ptr;
&nbsp;
    <strong>enter_critical_section(jvmti);</strong>
    {
        <i>/* MSG("Got Method Entry event"); */</i>
        (*jvmti)-&gt;GetMethodName(jvmti, method, &amp;name_ptr, &amp;signature_ptr, NULL);
        printf("called method %s with signature %s\n", name_ptr, signature_ptr);
        (*jvmti)-&gt;Deallocate(jvmti, (unsigned char *)name_ptr);
        (*jvmti)-&gt;Deallocate(jvmti, (unsigned char *)signature_ptr);
    }
    <strong>exit_critical_section(jvmti);</strong>
}
&nbsp;
<i>/*</i>
<i> * Registrace vsech callback funkci.</i>
<i> */</i>
jvmtiError <strong>register_all_callback_functions</strong>(jvmtiEnv *jvmti)
{
    jvmtiEventCallbacks callbacks;
    jvmtiError error_code;
&nbsp;
    memset(&amp;callbacks, 0, sizeof(callbacks));
&nbsp;
    <i>/* JVMTI_EVENT_VM_INIT */</i>
    callbacks.VMInit = &amp;callback_on_vm_init;
&nbsp;
    <i>/* JVMTI_EVENT_VM_DEATH */</i>
    callbacks.VMDeath = &amp;callback_on_vm_death;
&nbsp;
    <i>/* JVMTI_EVENT_METHOD_ENTRY */</i>
    callbacks.MethodEntry = &amp;callback_on_method_entry;
&nbsp;
    error_code = (*jvmti)-&gt;SetEventCallbacks(jvmti, &amp;callbacks, (jint)sizeof(callbacks));
    check_jvmti_error(jvmti, error_code, "Cannot set JVM TI callbacks");
    return error_code;
}
&nbsp;
<i>/*</i>
<i> * Nastaveni jedne udalosti, pro nez se ma zavolat callback funkce.</i>
<i> */</i>
jvmtiError <strong>set_event_notification_mode</strong>(jvmtiEnv *jvmti, int event)
{
    jvmtiError error_code;
&nbsp;
    error_code = (*jvmti)-&gt;SetEventNotificationMode(jvmti, JVMTI_ENABLE, event, (jthread)NULL);
    check_jvmti_error(jvmti, error_code, "Cannot set event notification");
    return error_code;
}
&nbsp;
<i>/*</i>
<i> * Nastaveni udalosti, pro nez se maji zavolat callback funkce.</i>
<i> */</i>
jvmtiError <strong>set_event_notification_modes</strong>(jvmtiEnv *jvmti)
{
    jvmtiError error_code;
&nbsp;
    <i>/* Potrebujeme zachytavat udalost inicializace virtualniho stroje. */</i>
    if ((error_code = set_event_notification_mode(jvmti, JVMTI_EVENT_VM_INIT)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
    <i>/* Potrebujeme zachytavat udalost ukonceni prace virtualniho stroje. */</i>
    if ((error_code = set_event_notification_mode(jvmti, JVMTI_EVENT_VM_DEATH)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
    <i>/* Potrebujeme zachytavat udalost pri vstupu do metody. */</i>
    if ((error_code = set_event_notification_mode(jvmti, JVMTI_EVENT_METHOD_ENTRY)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
    return error_code;
}
&nbsp;
<i>/*</i>
<i> * Funkce zavolana ve chvili nacitani agenta do JVM.</i>
<i> */</i>
JNIEXPORT jint JNICALL <strong>Agent_OnLoad</strong>(JavaVM *jvm, char *options, void *reserved)
{
    jvmtiEnv *jvmti = NULL;
    jint result;
    jvmtiError error_code;
&nbsp;
    MSG("Agent_OnLoad");
    result = (*jvm)-&gt;GetEnv(jvm, (void **) &amp;jvmti, JVMTI_VERSION_1_0);
    if (result != JNI_OK || jvmti == NULL)
    {
        printf("ERROR: Unable to access JVMTI Version 1 (0x%x),"
                " is your J2SE a 1.5 or newer version? JNIEnv's GetEnv() returned %d\n",
                JVMTI_VERSION_1, (int)result);
        return result;
    }
    MSG("JVM TI version is correct");
&nbsp;
    <i>/* nastaveni pozadovanych schopnosti agenta */</i>
    if ((error_code = set_capabilities(jvmti)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
    <i>/* registrace vsech (dvou) callback funkci */</i>
    if ((error_code = register_all_callback_functions(jvmti)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
    <i>/* nastaveni udalosti, pro nez se maji zavolat callback funkce */</i>
    if ((error_code = set_event_notification_modes(jvmti)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
    <i>/* vytvoreni zamku */</i>
    if ((error_code = create_raw_monitor(jvmti)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
    return JNI_OK;
}
&nbsp;
<i>/*</i>
<i> * Funkce zavolana ve chvili odstranovani agenta z JVM.</i>
<i> */</i>
JNIEXPORT void JNICALL <strong>Agent_OnUnload</strong>(JavaVM *vm)
{
    MSG("Agent_OnUnload");
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. ©estý demonstraèní pøíklad: agent registrující práci garbage collectoru</h2>

<p>Dnes si uká¾eme je¹tì jeden pomìrnì praktický pøíklad &ndash; agenta, který
doká¾e registrovat zaèátek a konec èinnosti správce pamìti (garbage
collectoru). Tento agent sice nemusí správnì fungovat se v¹emi správci pamìti,
ov¹em u tìch základních (Mark and Sweep atd.) je jeho funkce zaruèena. Èinnost
agenta zaji¹»uje dvojice callback funkcí zavolaných pøi startu GC a ukonèení
GC. Ve chvíli volání tìchto callback funkcí je èinnost celého virtuálního
stroje pozastavena, i pøesto je v¹ak lep¹í tìlo tìchto dvou callback funkcí
uzavøít do kritické sekce.</p>

<p>V&nbsp;¹estém demonstraèním agentovi jsou pou¾ity dvì nové globální promìnné
nazvané <strong>gc_start</strong> a <strong>gc_total</strong>, které slou¾í ke
sledování aktuální i celkové doby bìhu správce pamìti. Promìnná
<strong>gc_start</strong> je nastavována v&nbsp;callback funkci
<strong>callback_on_gc_start</strong> na aktuální hodnotu (poèet tikù interních
systémových hodin) vrácenou funkcí <strong>clock()</strong>. Tímto zpùsobem
zaznamenaná hodnota je pou¾ita ve druhé callback funkci
<strong>callback_on_gc_finish</strong> pro výpoèet doby bìhu správce pamìti i
pro výpoèet celkové doby aktivního bìhu vlákna (vláken) se správcem pamìti:</p>

<pre>
<i>/*</i>
<i> * JVM TI agent, ktery dokaze registrovat praci GC.</i>
<i> */</i>
&nbsp;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
&nbsp;
<i>/* Nutno nastavit cestu pres volbu -Icesta_k_jvm */</i>
#include &lt;jvmti.h&gt;
&nbsp;
#define AGENT_NAME "Agent6:"
&nbsp;
<i>/*</i>
<i> * Vypis zpravy na standardni vystup.</i>
<i> */</i>
#define MSG(message) puts(AGENT_NAME " " message)
&nbsp;
<i>/* Zamek pouzivany agentem */</i>
jrawMonitorID  global_lock;
&nbsp;
<i>/* Zacatek behu GC */</i>
clock_t gc_start;
&nbsp;
<i>/* Celkovy cas behu GC */</i>
clock_t gc_total = 0;
&nbsp;
<i>/*</i>
<i> * Vypis kodu chyby a chybove zpravy.</i>
<i> */</i>
static void <strong>print_jvmti_error</strong>(jvmtiEnv *jvmti, jvmtiError error_code, const char *str)
{
    char *error_code_str = NULL;
    const char *msg_str = str == NULL ? "" : str;
    char *msg_err = NULL;
&nbsp;
    (*jvmti)-&gt;GetErrorName(jvmti, error_code, &amp;error_code_str);
    msg_err = error_code_str == NULL ? "Unknown" : error_code_str;
    printf(AGENT_NAME " ERROR: JVMTI: %d(%s): %s\n", error_code, msg_err, msg_str);
}
&nbsp;
<i>/*</i>
<i> * Pokud je predany navratovy kod chybovym kodem, vypise se hlaseni.</i>
<i> */</i>
static void <strong>check_jvmti_error</strong>(jvmtiEnv *jvmti, jvmtiError error_code, const char *str)
{
    if ( error_code != JVMTI_ERROR_NONE )
    {
        print_jvmti_error(jvmti, error_code, str);
    }
}
&nbsp;
<i>/*</i>
<i> * Vytvoreni zamku.</i>
<i> */</i>
jvmtiError <strong>create_raw_monitor</strong>(jvmtiEnv *jvmti)
{
    jvmtiError error_code;
&nbsp;
    error_code = (*jvmti)-&gt;CreateRawMonitor(jvmti, "agent data", &amp;global_lock);
    check_jvmti_error(jvmti, error_code, "Cannot create raw monitor");
&nbsp;
    return error_code;
}
&nbsp;
<i>/*</i>
<i> * Vstup do kriticke sekce.</i>
<i> */</i>
static void <strong>enter_critical_section</strong>(jvmtiEnv *jvmti)
{
    jvmtiError error_code;
&nbsp;
    error_code = (*jvmti)-&gt;RawMonitorEnter(jvmti, global_lock);
    check_jvmti_error(jvmti, error_code, "Cannot enter with raw monitor");
}
&nbsp;
<i>/*</i>
<i> * Vystup z kriticke sekce</i>
<i> */</i>
static void <strong>exit_critical_section</strong>(jvmtiEnv *jvmti)
{
    jvmtiError error_code;
&nbsp;
    error_code = (*jvmti)-&gt;RawMonitorExit(jvmti, global_lock);
    check_jvmti_error(jvmti, error_code, "Cannot exit with raw monitor");
}
&nbsp;
<i>/*</i>
<i> * Nastaveni pozadovanych schopnosti agenta.</i>
<i> */</i>
jvmtiError <strong>set_capabilities</strong>(jvmtiEnv *jvmti)
{
    jvmtiCapabilities capabilities;
    jvmtiError error_code;
&nbsp;
    memset(&amp;capabilities, 0, sizeof(jvmtiCapabilities));
&nbsp;
    <i>/* vyuzivame jednu specialni schopnost agenta */</i>
    capabilities.can_generate_garbage_collection_events = 1;
&nbsp;
    error_code = (*jvmti)-&gt;AddCapabilities(jvmti, &amp;capabilities);
    check_jvmti_error(jvmti, error_code, "Unable to get necessary JVMTI capabilities.");
    return error_code;
}
&nbsp;
<i>/*</i>
<i> * Callback funkce zavolana pri inicializaci virtualniho stroje.</i>
<i> */</i>
static void JNICALL <strong>callback_on_vm_init</strong>(jvmtiEnv *jvmti_env, JNIEnv* env, jthread thread)
{
    MSG("Got VM init event");
}
&nbsp;
<i>/*</i>
<i> * Callback funkce zavolana pri ukonceni cinnosti virtualniho stroje.</i>
<i> */</i>
static void JNICALL <strong>callback_on_vm_death</strong>(jvmtiEnv *jvmti_env, JNIEnv* env)
{
    MSG("Got VM Death event");
}
&nbsp;
<i>/*</i>
<i> * Zacatek behu GC.</i>
<i> */</i>
static void JNICALL <strong>callback_on_gc_start</strong>(jvmtiEnv *jvmti_env)
{
    enter_critical_section(jvmti_env);
    {
        gc_start = clock();
        printf("gc start\n");
    }
    exit_critical_section(jvmti_env);
}
&nbsp;
<i>/*</i>
<i> * Konec behu GC.</i>
<i> */</i>
static void JNICALL <strong>callback_on_gc_finish</strong>(jvmtiEnv *jvmti_env)
{
    enter_critical_section(jvmti_env);
    {
        clock_t gc_end = clock();
        clock_t diff = gc_end - gc_start;
        gc_total += diff;
        printf("gc end: %f sec\n", (double)diff/CLOCKS_PER_SEC);
    }
    exit_critical_section(jvmti_env);
}
&nbsp;
<i>/*</i>
<i> * Registrace vsech callback funkci.</i>
<i> */</i>
jvmtiError <strong>register_all_callback_functions</strong>(jvmtiEnv *jvmti)
{
    jvmtiEventCallbacks callbacks;
    jvmtiError error_code;
&nbsp;
    memset(&amp;callbacks, 0, sizeof(callbacks));
&nbsp;
    <i>/* JVMTI_EVENT_VM_INIT */</i>
    callbacks.VMInit = &amp;callback_on_vm_init;
&nbsp;
    <i>/* JVMTI_EVENT_VM_DEATH */</i>
    callbacks.VMDeath = &amp;callback_on_vm_death;
&nbsp;
    <i>/* JVMTI_EVENT_GARBAGE_COLLECTION_START */</i>
    callbacks.GarbageCollectionStart  = &amp;callback_on_gc_start;
&nbsp;
    <i>/* JVMTI_EVENT_GARBAGE_COLLECTION_FINISH */</i>
    callbacks.GarbageCollectionFinish = &amp;callback_on_gc_finish;
&nbsp;
    error_code = (*jvmti)-&gt;SetEventCallbacks(jvmti, &amp;callbacks, (jint)sizeof(callbacks));
    check_jvmti_error(jvmti, error_code, "Cannot set JVM TI callbacks");
    return error_code;
}
&nbsp;
<i>/*</i>
<i> * Nastaveni jedne udalosti, pro nez se ma zavolat callback funkce.</i>
<i> */</i>
jvmtiError <strong>set_event_notification_mode</strong>(jvmtiEnv *jvmti, int event)
{
    jvmtiError error_code;
&nbsp;
    error_code = (*jvmti)-&gt;SetEventNotificationMode(jvmti, JVMTI_ENABLE, event, (jthread)NULL);
    check_jvmti_error(jvmti, error_code, "Cannot set event notification");
    return error_code;
}
&nbsp;
<i>/*</i>
<i> * Nastaveni udalosti, pro nez se maji zavolat callback funkce.</i>
<i> */</i>
jvmtiError <strong>set_event_notification_modes</strong>(jvmtiEnv *jvmti)
{
    jvmtiError error_code;
&nbsp;
    <i>/* Potrebujeme zachytavat udalost inicializace virtualniho stroje. */</i>
    if ((error_code = set_event_notification_mode(jvmti, JVMTI_EVENT_VM_INIT)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
    <i>/* Potrebujeme zachytavat udalost ukonceni prace virtualniho stroje. */</i>
    if ((error_code = set_event_notification_mode(jvmti, JVMTI_EVENT_VM_DEATH)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
    <i>/* Potrebujeme zachytavat udalost pri zacatku behu GC. */</i>
    if ((error_code = set_event_notification_mode(jvmti, JVMTI_EVENT_GARBAGE_COLLECTION_START)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
    <i>/* Potrebujeme zachytavat udalost pri ukonceni behu GC. */</i>
    if ((error_code = set_event_notification_mode(jvmti, JVMTI_EVENT_GARBAGE_COLLECTION_FINISH)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
    return error_code;
}
&nbsp;
<i>/*</i>
<i> * Funkce zavolana ve chvili nacitani agenta do JVM.</i>
<i> */</i>
JNIEXPORT jint JNICALL <strong>Agent_OnLoad</strong>(JavaVM *jvm, char *options, void *reserved)
{
    jvmtiEnv *jvmti = NULL;
    jint result;
    jvmtiError error_code;
&nbsp;
    MSG("Agent_OnLoad");
    result = (*jvm)-&gt;GetEnv(jvm, (void **) &amp;jvmti, JVMTI_VERSION_1_0);
    if (result != JNI_OK || jvmti == NULL)
    {
        printf("ERROR: Unable to access JVMTI Version 1 (0x%x),"
                " is your J2SE a 1.5 or newer version? JNIEnv's GetEnv() returned %d\n",
                JVMTI_VERSION_1, (int)result);
        return result;
    }
    MSG("JVM TI version is correct");
&nbsp;
    <i>/* nastaveni pozadovanych schopnosti agenta */</i>
    if ((error_code = set_capabilities(jvmti)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
    <i>/* registrace vsech callback funkci */</i>
    if ((error_code = register_all_callback_functions(jvmti)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
    <i>/* nastaveni udalosti, pro nez se maji zavolat callback funkce */</i>
    if ((error_code = set_event_notification_modes(jvmti)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
    <i>/* vytvoreni zamku */</i>
    if ((error_code = create_raw_monitor(jvmti)) != JNI_OK)
    {
        return error_code;
    }
&nbsp;
    return JNI_OK;
}
&nbsp;
<i>/*</i>
<i> * Funkce zavolana ve chvili odstranovani agenta z JVM.</i>
<i> */</i>
JNIEXPORT void JNICALL <strong>Agent_OnUnload</strong>(JavaVM *vm)
{
    MSG("Agent_OnUnload");
    printf("Total GC time: %f sec\n", (double)gc_total/CLOCKS_PER_SEC);
}
</pre>

<p>Funkci agenta otestujeme na velmi jednoduchém javovském programu, který i
pøes svoji jednoduchost správce pamìti docela hodnì &bdquo;potrápí&ldquo;,
proto¾e ka¾dé pou¾ití operátoru + nad øetìzcem vede k&nbsp;vytvoøení nového
objektu:</p>

<pre>
public class Test6 {
&nbsp;
    public static void main(String[] args) {
        String s = "";
        for (int i=0; i &lt; 10000; i++)
        {
            s = s + " " + i;
        }
    }
&nbsp;
}
</pre>

<p>Skript pro pøeklad agenta a spu¹tìní JVM s&nbsp;agentem:</p>

<pre>
<i># pøeklad agenta</i>
gcc -Wall -ansi -I/usr/lib/jvm/java-1.6.0-openjdk/include/ -shared -o libagent6.so agent6.c
&nbsp;
<i># pøeklad testu</i>
javac Test6.java
&nbsp;
<i># spu¹tìní JVM s agentem</i>
java -agentpath:./libagent6.so Test6
</pre>

<p>Po spu¹tìní JVM s&nbsp;agentem a testem by se na konzoli mìly vypsat zprávy
podobající se následujícímu výpisu:</p>

<pre>
Agent6: Agent_OnLoad
Agent6: JVM TI version is correct
Agent6: Got VM init event
gc start
gc end: 0.010000 sec
...
...
...
gc start
gc end: 0.000000 sec
gc start
gc end: 0.000000 sec
gc start
gc end: 0.000000 sec
gc start
gc end: 0.000000 sec
...
...
...
Agent6: Got VM Death event
Agent6: Agent_OnUnload
Total GC time: 0.220000 sec
</pre>

<p>Z&nbsp;tohoto výpisu je patrné, ¾e správce pamìti je spou¹tìn (nad young
generation) s&nbsp;pomìrnì velkou frekvencí takovým zpùsobem, aby nemuselo
docházet k&nbsp;pozastavení bìhu vláken aplikace po del¹í dobu, co¾ by se mohlo
negativnì promítnout do doby odezvy aplikace.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>The JVM Tool Interface (JVM TI): How VM Agents Work<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html">http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html</a>
</li>

<li>JVM Tool Interface Version 1.2<br />
<a href="http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html">http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html</a>
</li>

<li>Creating a Debugging and Profiling Agent with JVMTI<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html">http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html</a>
</li>

<li>JVM TI (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/JVM_TI">http://en.wikipedia.org/wiki/JVM_TI</a>
</li>

<li>IBM JVMTI extensions<br />
<a href="http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html">http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html</a>
</li>

<li>ClojureScript One: Index<br />
<a href="http://clojurescriptone.com/index.html">http://clojurescriptone.com/index.html</a>
</li>

<li>ClojureScript One: Documentation<br />
<a href="http://clojurescriptone.com/documentation.html">http://clojurescriptone.com/documentation.html</a>
</li>

<li>ClojureScript One: Wiki<br />
<a href="https://github.com/brentonashworth/one/wiki">https://github.com/brentonashworth/one/wiki</a>
</li>

<li>ClojureScript: Quick Start<br />
<a href="https://github.com/clojure/clojurescript/wiki/Quick-Start">https://github.com/clojure/clojurescript/wiki/Quick-Start</a>
</li>

<li>Getting Started with ClojureScript (and FW/1)<br />
<a href="http://corfield.org/entry/getting-started-with-clojurescript-and-fw-1">http://corfield.org/entry/getting-started-with-clojurescript-and-fw-1</a>
</li>

<li>First ClojureScript experiences: using Raphaël<br />
<a href="http://maurits.wordpress.com/2012/02/13/first-clojurescript-experiences-using-raphael/">http://maurits.wordpress.com/2012/02/13/first-clojurescript-experiences-using-raphael/</a>
</li>

<li>Raphaël-JavaScript Library<br />
<a href="http://raphaeljs.com/">http://raphaeljs.com/</a>
</li>

<li>A detailed installation Guide for VimClojure 2.2<br />
<a href="http://www.duenas.at/new_homepage/vimclojure">http://www.duenas.at/new_homepage/vimclojure</a>
</li>

<li>VimClojure : A filetype, syntax and indent plugin for Clojure<br />
<a href="http://www.vim.org/scripts/script.php?script_id=2501">http://www.vim.org/scripts/script.php?script_id=2501</a>
</li>

<li>Nailgun server<br />
<a href="http://www.martiansoftware.com/nailgun/background.html">http://www.martiansoftware.com/nailgun/background.html</a>
</li>

<li>SLIME (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/SLIME">http://en.wikipedia.org/wiki/SLIME</a>
</li>

<li>slime.vim<br />
<a href="http://s3.amazonaws.com/mps/slime.vim">http://s3.amazonaws.com/mps/slime.vim</a>
</li>

<li>Textový editor Vim jako IDE: 1. èást<br />
<a href="http://www.root.cz/clanky/textovy-editor-vim-jako-ide/">http://www.root.cz/clanky/textovy-editor-vim-jako-ide/</a>
</li>

<li>Textový editor Vim jako IDE: 2. èást<br />
<a href="http://www.root.cz/clanky/textovy-editor-vim-jako-ide-2-cast/">http://www.root.cz/clanky/textovy-editor-vim-jako-ide-2-cast/</a>
</li>

<li>Textový editor Vim jako IDE: 3. èást (omni completion)<br />
<a href="http://www.root.cz/clanky/textovy-editor-vim-jako-ide-3-cast/">http://www.root.cz/clanky/textovy-editor-vim-jako-ide-3-cast/</a>
</li>

<li>Textový editor Vim jako IDE: 4. èást<br />
<a href="http://www.root.cz/clanky/textovy-editor-vim-jako-ide-4-cast/">http://www.root.cz/clanky/textovy-editor-vim-jako-ide-4-cast/</a>
</li>

<li>Textový editor Vim jako IDE: 5. èást<br />
<a href="http://www.root.cz/clanky/textovy-editor-vim-jako-ide-5-cast/">http://www.root.cz/clanky/textovy-editor-vim-jako-ide-5-cast/</a>
</li>

<li>Textový editor Vim jako IDE: 6. èást &ndash; Vim Script<br />
<a href="http://www.root.cz/clanky/textovy-editor-vim-jako-ide-6-cast-vim-script/">http://www.root.cz/clanky/textovy-editor-vim-jako-ide-6-cast-vim-script/</a>
</li>

<li>Textový editor Vim jako IDE: 7. èást &ndash; Vim Script<br />
<a href="http://www.root.cz/clanky/textovy-editor-vim-jako-ide-7-cast-vim-script/">http://www.root.cz/clanky/textovy-editor-vim-jako-ide-7-cast-vim-script/</a>
</li>

<li>Textový editor Vim jako IDE: 8. èást<br />
<a href="http://www.root.cz/clanky/textovy-editor-vim-jako-ide-8-cast/">http://www.root.cz/clanky/textovy-editor-vim-jako-ide-8-cast/</a>
</li>

<li>Textový editor Vim jako IDE: 9. èást &ndash; pluginy Netrw a snipMate<br />
<a href="http://www.root.cz/clanky/textovy-editor-vim-jako-ide-9-cast-pluginy-netrw-a-snipmate/">http://www.root.cz/clanky/textovy-editor-vim-jako-ide-9-cast-pluginy-netrw-a-snipmate/</a>
</li>

<li>Textový editor Vim jako IDE: 10. èást &ndash; rùzné tipy a triky<br />
<a href="http://www.root.cz/clanky/textovy-editor-vim-jako-ide-10-cast-ruzne-tipy-a-triky/">http://www.root.cz/clanky/textovy-editor-vim-jako-ide-10-cast-ruzne-tipy-a-triky/</a>
</li>

<li>Pøenos textù mezi Vimem a dal¹ími aplikacemi<br />
<a href="http://www.root.cz/clanky/prenos-textu-mezi-vimem-a-dalsimi-aplikacemi/">http://www.root.cz/clanky/prenos-textu-mezi-vimem-a-dalsimi-aplikacemi/</a>
</li>

<li>Textový editor Vim: konfigurace pravítka a stavového øádku<br />
<a href="http://www.root.cz/clanky/textovy-editor-vim-jako-ide-12-cast-konfigurace-pravitka-a-stavoveho-radku/">http://www.root.cz/clanky/textovy-editor-vim-jako-ide-12-cast-konfigurace-pravitka-a-stavoveho-radku/</a>
</li>

<li>Textový editor Vim: automatické formátování textù<br />
<a href="http://www.root.cz/clanky/textovy-editor-vim-jako-ide-14-cast-automaticke-formatovani-textu/">http://www.root.cz/clanky/textovy-editor-vim-jako-ide-14-cast-automaticke-formatovani-textu/</a>
</li>

<li>Textový editor Vim: automatické formátování textù<br />
<a href="http://www.root.cz/clanky/textovy-editor-vim-jako-ide-automaticke-formatovani-textu-dokonceni/">http://www.root.cz/clanky/textovy-editor-vim-jako-ide-automaticke-formatovani-textu-dokonceni/</a>
</li>

<li>Textový editor Vim: editace XML a HTML<br />
<a href="http://www.root.cz/clanky/textovy-editor-vim-jako-ide-15-cast-editace-xml-a-html/">http://www.root.cz/clanky/textovy-editor-vim-jako-ide-15-cast-editace-xml-a-html/</a>
</li>

<li>Textový editor Vim: kooperace mezi Vimem a skripty<br />
<a href="http://www.root.cz/clanky/textovy-editor-vim-jako-ide-16-cast-kooperace-mezi-vimem-a-skriptovacimi-jazyky/">http://www.root.cz/clanky/textovy-editor-vim-jako-ide-16-cast-kooperace-mezi-vimem-a-skriptovacimi-jazyky/</a>
</li>

<li>Textový editor Vim: kooperace mezi Vimem a jazykem Perl<br />
<a href="http://www.root.cz/clanky/textovy-editor-vim-jako-ide-17-cast-kooperace-mezi-vimem-a-jazykem-perl/">http://www.root.cz/clanky/textovy-editor-vim-jako-ide-17-cast-kooperace-mezi-vimem-a-jazykem-perl/</a>
</li>

<li>Textový editor Vim: konfigurace a pøeklad Vimu<br />
<a href="http://www.root.cz/clanky/textovy-editor-vim-jako-ide-18-cast-konfigurace-a-preklad-vimu/">http://www.root.cz/clanky/textovy-editor-vim-jako-ide-18-cast-konfigurace-a-preklad-vimu/</a>
</li>

<li>Counterclockwise<br />
<a href="http://code.google.com/p/counterclockwise/">http://code.google.com/p/counterclockwise/</a>
</li>

<li>Clojure IDEs - The Grand Tour<br />
<a href="http://www.bestinclass.dk/index.clj/2010/03/clojure-ides-the-grand-tour-getting-started.html">http://www.bestinclass.dk/index.clj/2010/03/clojure-ides-the-grand-tour-getting-started.html</a>
</li>

<li>Light Table - a new IDE concept<br />
<a href="http://www.chris-granger.com/2012/04/12/light-table---a-new-ide-concept/">http://www.chris-granger.com/2012/04/12/light-table---a-new-ide-concept/</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Èistì funkcionální (datové struktury, jazyky, programování)<br />
<a href="http://cs.wikipedia.org/wiki/Èistì_funkcionální">http://cs.wikipedia.org/wiki/Èistì_funkcionální</a>
</li>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Eulerovo èíslo<br />
<a href="http://cs.wikipedia.org/wiki/Eulerovo_èíslo">http://cs.wikipedia.org/wiki/Eulerovo_èíslo</a>
</li>

<li>List comprehension<br />
<a href="http://en.wikipedia.org/wiki/List_comprehension">http://en.wikipedia.org/wiki/List_comprehension</a>
</li>

<li>List Comprehensions in Clojure<br />
<a href="http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html">http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html</a>
</li>

<li>Clojure Programming Concepts: List Comprehension<br />
<a href="http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension">http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension</a>
</li>

<li>Clojure core API: for macro<br />
<a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for">http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for</a>
</li>

<li>cirrus machina - The Clojure for macro<br />
<a href="http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/">http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/</a>
</li>

<li>Clojure.org: Clojure home page<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>A Couple of Clojure Agent Examples<br />
<a href="http://lethain.com/a-couple-of-clojure-agent-examples/">http://lethain.com/a-couple-of-clojure-agent-examples/</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/">http://java.sun.com/developer/technicalArticles/DynTypeLang/</a>
</li>

<li>JSR 223: Scripting for the Java<sup>TM</sup> Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=223">http://jcp.org/en/jsr/detail?id=223</a>
</li>

<li>JSR 292: Supporting Dynamically Typed Languages on the Java<sup>TM</sup> Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=292">http://jcp.org/en/jsr/detail?id=292</a>
</li>

<li>Java 7: A complete invokedynamic example<br />
<a href="http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html">http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html</a>
</li>

<li>InvokeDynamic: Actually Useful?<br />
<a href="http://blog.headius.com/2007/01/invokedynamic-actually-useful.html">http://blog.headius.com/2007/01/invokedynamic-actually-useful.html</a>
</li>

<li>A First Taste of InvokeDynamic<br />
<a href="http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html">http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html</a>
</li>

<li>Java 6 try/finally compilation without jsr/ret<br />
<a href="http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html">http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Root.cz: Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM<br />
<a href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/</a></a>
</li>

<li>Root.cz: JamVM aneb alternativa k HotSpotu nejenom pro embedded zaøízení a chytré telefony<br />
<a href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>FindBugs<br />
<a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a>
</li>

<li>GNU Classpath<br />
<a href="www.gnu.org/s/classpath/">www.gnu.org/s/classpath/</a></li>

<li>Java VMs Compared<br />
<a href="http://bugblogger.com/java-vms-compared-160/">http://bugblogger.com/java-vms-compared-160/</a>
</li>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Scala Programming Language<br />
<a href="http://www.scala-lang.org/">http://www.scala-lang.org/</a>
</li>

<li>Run Scala in Apache Tomcat in 10 minutes<br />
<a href="http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes">http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes</a>
</li>

<li>Fast Web Development With Scala<br />
<a href="http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html">http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html</a>
</li>

<li>Top five scripting languages on the JVM<br />
<a href="http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855">http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>CloseableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html">http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

