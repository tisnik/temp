<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Novinky v&nbsp;JDK 7 (3) + co v&nbsp;JDK 7 naopak nenajdeme</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Novinky v&nbsp;JDK 7 (3) + co v&nbsp;JDK 7 naopak nenajdeme</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve tøetí èásti seriálu o nových vlastnostech programovacího jazyka Java i jeho virtuálního stroje dokonèíme popis syntaktických a sémantických zmìn, které lze najít v&nbsp;JDK 7. Ve druhé èásti èlánku si navíc øekneme, na které zmìny budeme naopak muset poèkat a¾ do vydání JDK 8 (v&nbsp;ideálním pøípadì bude tato verze k&nbsp;dispozici v&nbsp;polovinì roku 2012) &ndash; kromì usnadnìní práce s&nbsp;kolekcemi se napøíklad jedná o projekt Lambda, který pomìrnì zásadním zpùsobem roz¹iøuje sémantiku Javy o anonymní funkce a uzávìry.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Práce s&nbsp;výjimkami v&nbsp;Javì</a></p>
<p><a href="#k02">2. Vylep¹ené zpracování výjimek &ndash; motivace</a></p>
<p><a href="#k03">3. Vylep¹ené zpracování výjimek &ndash; demonstraèní pøíklad</a></p>
<p><a href="#k04">4. Co v&nbsp;JDK 7 nakonec nenajdeme?</a></p>
<p><a href="#k05">5. Zjednodu¹ená inicializace kolekcí</a></p>
<p><a href="#k06">6. Pøístup k&nbsp;prvkùm kolekcí pøes &bdquo;indexové&ldquo; závorky</a></p>
<p><a href="#k07">7. Elvis operátory</a></p>
<p><a href="#k08">8. Projekt Lambda &ndash; radikální roz¹íøení syntaxe a sémantiky Javy</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2>1. Práce s&nbsp;výjimkami v&nbsp;Javì</h2>

<p>V&nbsp;pøedchozích dvou èástech miniseriálu o novinkách, které mù¾eme najít
v&nbsp;novì pøipravovaném <i>JDK 7</i> nebo takté¾ v&nbsp;<i>OpenJDK 7</i>,
jsme si popsali nìkteré zmìny (pøesnìji øeèeno roz¹íøení) v&nbsp;syntaxi a
sémantice jazyka Java, které byly do Javy pøidány v&nbsp;rámci projektu
<i>Coin</i>. Kromì mo¾nosti zápisu binárních èísel a èíselných konstant
s&nbsp;podtr¾ítky (co¾ je skuteènì nepatrná a spí¹e kosmetická zmìna), se
jednalo o roz¹íøení pøíkazu <strong>switch</strong> takovým zpùsobem, ¾e se
v&nbsp;jednotlivých vìtvích dají pou¾ívat øetìzcové literály, dále o roz¹íøení
bloku <strong>try</strong> v&nbsp;programové konstrukci
<strong>try-catch-finally</strong> o mo¾nost vytváøení (finálních) objektù
implementujících rozhraní <strong>AutoCloseable</strong>, pro nì¾ se
automaticky zavolá metoda <i>close()</i> a v&nbsp;neposlední øadì takté¾ o
zavedení nového operátoru <i>diamant</i>, který lze pou¾ít pro zjednodu¹ení
deklarace (s&nbsp;generikami) a souèasnì i konstrukce objektù. Ve v¹ech
pøípadech se v&nbsp;podstatì jednalo o &bdquo;syntaktický cukr&ldquo;, proto¾e
stejné funkcionality je mo¾né dosáhnout i v&nbsp;souèasném <i>JDK 6/OpenJDK
6</i>, i kdy¾ za cenu del¹ího a nìkdy ménì èitelného kódu.</p>

<p>I dal¹í novinka, která byla v&nbsp;rámci projektu <i>Coin</i> do <i>JDK
7</i> pøidána, byla navr¾ena z&nbsp;toho dùvodu, aby se zjednodu¹il a
takté¾ zestruènil zápis programù. Jedná se o roz¹íøení mo¾ností bloku
<strong>catch</strong>. V&nbsp;souèasné verzi <i>JDK</i> lze blok
<strong>catch</strong> zapsat pouze takovým zpùsobem, ¾e doká¾e zachytit jen
jeden typ výjimky. Samozøejmì i zde ov¹em platí hierarchie tøíd, tj.&nbsp;ve
skuteènosti se zachytí urèitý typ výjimky nebo potomek této výjimky. Po jednom bloku
<strong>try</strong> mù¾e následovat libovolný poèet blokù
<strong>catch</strong>, z&nbsp;nich¾ ka¾dý musí zachycovat jinou výjimku,
popø.&nbsp;obecnìj¹í výjimku, ne¾ pøedchozí bloky <strong>catch</strong>
&ndash; je tomu tak kvùli tomu, ¾e se jednotlivé bloky <strong>catch</strong>
chovají podle pravidla KDPTDM (&bdquo;kdo døív pøijde, ten døív mele
:-)&ldquo;), tj.&nbsp;první blok <strong>catch</strong>, který mù¾e výjimku
daného typu zachytit, to skuteènì udìlá. Tato podmínka pro vzájemné øazení
blokù <strong>catch</strong> je testována pøímo pøi pøekladu programu, tak¾e se
napøíklad následující zdrojový kód nepodaøí pøelo¾it:</p>

<pre>
import java.io.File;
import java.net.URI;

public class ExceptionTest1
{
    public static void main(String[] args)
    {
        try
        {
            File f = new File(new URI(args[0]));
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
        catch (NullPointerException e)
        {
            e.printStackTrace();
        }
        catch (IllegalArgumentException e)
        {
            e.printStackTrace();
        }
    }
}
</pre>

<p>Pøi pokusu o pøeklad se vypí¹e následující chybové hlá¹ení:</p>

<pre>
javac ExceptionTest1.java 
ExceptionTest0.java:16: exception java.lang.NullPointerException has already been caught
        catch (NullPointerException e)
        ^
ExceptionTest0.java:20: exception java.lang.IllegalArgumentException has already been caught
        catch (IllegalArgumentException e)
        ^
2 errors
</pre>

<p>Naproti tomu se nepatrnì upravený zdrojový kód pøelo¾í v&nbsp;poøádku,
proto¾e obecná výjimka typu <strong>Exception</strong> je zachycována a¾
v&nbsp;posledním bloku <strong>catch</strong> a konkrétnìj¹í typy výjimek jsou
zachyceny pøed tímto blokem:</p>

<pre>
import java.io.File;
import java.net.URI;

public class ExceptionTest2
{
    public static void main(String[] args)
    {
        try
        {
            File f = new File(new URI(args[0]));
        }
        catch (NullPointerException e)
        {
            e.printStackTrace();
        }
        catch (IllegalArgumentException e)
        {
            e.printStackTrace();
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }
}
</pre>

<p>Pro zajímavost se mù¾eme podívat do vygenerovaného bajtkódu na to, jakým
zpùsobem jsou jednotlivé bloky <strong>catch</strong> pøelo¾eny. V&nbsp;tomto
pøípadì se vyu¾ívají takzvané <i>tabulky výjimek</i>, které pro ka¾dý blok
<strong>catch</strong> obsahují rozsah adres, pro který je daný blok platný,
dále adresu, na kterou pøejde øízení programu ve chvíli, kdy k&nbsp;výjimce
dojde a takté¾ typ výjimky. Blok <strong>try</strong> je tedy reprezentován
instrukcemi na adresách 0 a¾ 18 a jednotlivé handlery výjimek zaèínají na
adresách 21, 29 a 37 (jednotlivé bloky kódu jsou oddìleny ruènì pøidaným øádkem
s&nbsp;pomlèkami):</p>

<pre>
Compiled from "ExceptionTest2.java"
public class Test1 extends java.lang.Object{
public ExceptionTest2();
  Code:
   0:   aload_0
   1:   invokespecial   #1; //Method java/lang/Object."&lt;init&gt;":()V
   4:   return

public static void main(java.lang.String[]);
  Code:
// ----------------------------------------------------------------
   0:   new     #2; //class java/io/File
   3:   dup
   4:   new     #3; //class java/net/URI
   7:   dup
   8:   aload_0
   9:   iconst_0
   10:  aaload
   11:  invokespecial   #4; //Method java/net/URI."&lt;init&gt;":(Ljava/lang/String;)V
   14:  invokespecial   #5; //Method java/io/File."&lt;init&gt;":(Ljava/net/URI;)V
   17:  astore_1
   18:  goto    42
// ----------------------------------------------------------------
   21:  astore_1
   22:  aload_1
   23:  invokevirtual   #7; //Method java/lang/NullPointerException.printStackTrace:()V
   26:  goto    42
// ----------------------------------------------------------------
   29:  astore_1
   30:  aload_1
   31:  invokevirtual   #9; //Method java/lang/IllegalArgumentException.printStackTrace:()V
   34:  goto    42
// ----------------------------------------------------------------
   37:  astore_1
   38:  aload_1
   39:  invokevirtual   #11; //Method java/lang/Exception.printStackTrace:()V
// ----------------------------------------------------------------
   42:  return
  Exception table:
   from   to  target type
     0    18    21   Class java/lang/NullPointerException
     0    18    29   Class java/lang/IllegalArgumentException
     0    18    37   Class java/lang/Exception
}
</pre>



<p><a name="k02"></a></p>
<h2>2. Vylep¹ené zpracování výjimek &ndash; motivace</h2>

<p>Zpùsob zachycování výjimek implementovaný v&nbsp;<i>JDK 6</i> i ve v¹ech
pøedchozích verzích <i>JDK</i> s&nbsp;sebou pøiná¹í jednu nevýhodu, která se
projeví zejména ve chvíli, kdy v&nbsp;bloku <strong>try</strong> mù¾e nastat
nìkolik vzájemnì zcela odli¹ných výjimek, na nì¾ se reaguje stejnou nebo
podobnou sekvencí pøíkazù (napøíklad se mù¾e jednat o pøíkazy, které výjimku
zapí¹ou do logu, provedou rollback v&nbsp;databázi atd.). Jako pøíklad &ndash;
který je kvùli omezení délky opìt vyumìlkovaný! &ndash; si uka¾me, jak by se
v&nbsp;souèasné oficiální verzi <i>JDK 6</i> mohl napsat program provádìjící
jednoduchý výpoèet s&nbsp;èíslem, které je programu pøedáno jako argument na
pøíkazovém øádku. Pøi spu¹tìní programu mù¾e nastat nìkolik stavù, které
vyvolají výjimku: argument není vùbec zadán, tj.&nbsp;pole
<strong>args</strong> je prázdné; argument je sice zadán, ale neobsahuje celé
èíslo (nepovede se jeho parsing) a takté¾ se mù¾e jednat o platné èíslo nula,
které v¹ak vyvolá pøi dìlení výjimku (primitivní datový typ
<strong>int</strong> nemù¾e, na rozdíl od <strong>double</strong>, obsahovat
konstanty typu <i>Infinity</i>, <i>-Infinity</i>, <i>NaN</i> atd.). Pøi
zpracování výjimky se vypí¹e chybové hlá¹ení na chybový výstup a souèasnì se
textová reprezentace výjimky ulo¾í do jednoduchého logu, který je pøed koncem
bìhu programu vypsán na standardní výstup:</p>

<pre>
import java.util.List;
import java.util.ArrayList;

public class ExceptionTest3
{
    public static List&lt;String&gt; log = new ArrayList&lt;String&gt;();

    public static void main(String[] args)
    {
        try
        {
            int i = Integer.parseInt(args[0]);
            System.out.format("1000 / %d = %d\n", i, 1000/i);
        }
        catch (IndexOutOfBoundsException e)
        {
            System.err.println("Chyba - jako prvni argument programu musi byt zadano cele cislo");
            log.add(e.toString());
        }
        catch (NumberFormatException e)
        {
            System.err.println("Chyba - jako prvni argument programu musi byt zadano cele cislo");
            log.add(e.toString());
        }
        catch (ArithmeticException e)
        {
            System.err.println("Deleni nulou!");
            log.add(e.toString());
        }
        finally
        {
            System.out.println("\nError log: ");
            for (String str : log)
            {
                System.out.println(str);
            }
        }
    }
}
</pre>

<p>Chování vý¹e uvedeného programu si mù¾eme jednodu¹e otestovat:</p>

<pre>
$ java ExceptionTest3
Chyba - jako prvni argument programu musi byt zadano cele cislo

Error log: 
java.lang.ArrayIndexOutOfBoundsException: 0
</pre>

<pre>
$ java ExceptionTest3 hola
Chyba - jako prvni argument programu musi byt zadano cele cislo

Error log: 
java.lang.NumberFormatException: For input string: "hola"
</pre>

<pre>
$ java ExceptionTest3 0
Deleni nulou!

Error log: 
java.lang.ArithmeticException: / by zero
</pre>

<pre>
$ java ExceptionTest3 42
1000 / 42 = 23

Error log: 
</pre>



<p><a name="k03"></a></p>
<h2>3. Vylep¹ení zpracování výjimek &ndash; demonstraèní pøíklad</h2>

<p>Pøi pohledu na demonstraèní pøíklad uvedený v&nbsp;pøedchozí kapitole mù¾eme
zjistit, ¾e se v&nbsp;nìm dvakrát opakuje stejná sekvence pøíkazù &ndash; jedná
se o pøíkazy zapsané v&nbsp;blocích <strong>catch</strong>, které zachycují
výjimky typu <strong>IndexOutOfBoundsException</strong> (tj.&nbsp;u¾ivatel na
pøíkazové øádce nezadal ¾ádný argument, tak¾e je pole <strong>args</strong>
prázdné) a <strong>NumberFormatException</strong> (zadaný argument není
parsovatelný na celé èíslo). V&nbsp;souèasné (pøesnìji øeèeno oficiální) verzi
<i>JDK 6</i> lze tuto duplikaci vyøe¹it napøíklad zachycením nìjaké obecnìj¹í
výjimky. Ov¹em to s&nbsp;sebou pøiná¹í nìkolik problémù; pøedev¹ím to, ¾e po
pøidání dal¹ích pøíkazù do bloku <strong>try</strong> mù¾e dojít k&nbsp;tomu,
¾e obecný handler v&nbsp;bloku <strong>catch</strong> bude nekorektnì
obsluhovat (a pøedev¹ím zachytávat) i ty výjimky, s&nbsp;kterými autor
pùvodního kódu nepoèítal &ndash; a pøekladaè na tuto skuteènost samozøejmì
nemusí upozornit, zejména v&nbsp;pøípadech, kdy se kvùli snaze o zjednodu¹ení
programu zachycují obecné výjimky typu <strong>Exception</strong> nebo
<strong>RuntimeException</strong>.</p>

<p>V&nbsp;<i>JDK 7</i> je mo¾né tento problém vyøe¹it s&nbsp;vyu¾itím
upraveného bloku <strong>catch</strong>, v&nbsp;nìm¾ je pou¾it pøetí¾ený
operátor |, pomocí nìho¾ lze blok <strong>catch</strong> vyu¾ít pro nìkolik
typù (i navzájem nesouvisejících) výjimek. Syntaxe nového zpùsobu zápisu je
následující (pov¹imnìte si pøedev¹ím v&nbsp;tomto pøípadì povinného
modifikátoru <strong>final</strong>):</p>

<pre>
catch (final ExceptionType1 | ExceptionType2 | ... ExceptionTypeN ex)
{
}
</pre>

<p>S&nbsp;vyu¾itím vý¹e uvedené nové syntaxe bloku <strong>catch</strong> lze
demonstraèní pøíklad z&nbsp;pøedchozí kapitoly pøepsat následovnì (navíc je
je¹tì provedeno jedno malé zjednodu¹ení &ndash; pou¾ití operátoru
<i>diamant</i> pøi vytváøení seznamu):</p>

<pre>
import java.util.List;
import java.util.ArrayList;

public class ExceptionTest4
{
    public static List&lt;String&gt; log = new ArrayList&lt;&gt;();

    public static void main(String[] args)
    {
        try
        {
            int i = Integer.parseInt(args[0]);
            System.out.format("1000 / %d = %d\n", i, 1000/i);
        }
        catch (final IndexOutOfBoundsException | NumberFormatException e)
        {
            System.err.println("Chyba - jako prvni argument programu musi byt zadano cele cislo");
            log.add(e.toString());
        }
        catch (ArithmeticException e)
        {
            System.err.println("Deleni nulou!");
            log.add(e.toString());
        }
        finally
        {
            System.out.println("\nError log: ");
            for (String str : log)
            {
                System.out.println(str);
            }
        }
    }
}
</pre>

<p>Upravený pøíklad pracuje stejnì, jako jeho pøedchozí varianta:</p>

<pre>
$ ./java ExceptionTest4
Chyba - jako prvni argument programu musi byt zadano cele cislo

Error log: 
java.lang.ArrayIndexOutOfBoundsException: 0
</pre>

<pre>
$ ./java ExceptionTest4 hej
Chyba - jako prvni argument programu musi byt zadano cele cislo

Error log: 
java.lang.NumberFormatException: For input string: "hej"
</pre>

<pre>
$ ./java ExceptionTest4 0
Deleni nulou!

Error log: 
java.lang.ArithmeticException: / by zero
</pre>

<pre>
$ ./java ExceptionTest4 8
1000 / 8 = 125

Error log: 
</pre>

<p>Pro zajímavost se opìt mù¾eme podívat na to, jak se tento pøíklad pøelo¾í do
bajtkódu. Za pov¹imnutí stojí pøedev¹ím tabulka se seznamem zachytávaných
výjimek &ndash; ta nyní obsahuje sedm polo¾ek. První tøi polo¾ky odpovídají
dvojici blokù <strong>catch</strong> explicitnì zapsaných programátorem (blok
<strong>catch</strong> s&nbsp;pøetí¾eným operátorem | je reprezentován dvojicí
polo¾ek). Dal¹í ètyøi polo¾ky jsou urèeny pro zachycení obecných výjimek jak ve
vlastním bloku <strong>try</strong>, tak i ve v¹ech blocích
<strong>catch</strong>. Je tomu tak z&nbsp;toho dùvodu, aby se v¾dy provedl
blok <strong>finally</strong> (pokud by v¹ak blok <strong>finally</strong> nebyl
uveden, obsahovala by tabulka pouze první tøi polo¾ky, co¾ si mù¾ete jednodu¹e
vyzkou¹et po pøekladu zdrojového kódu do souboru .class následovaného zpìtným
pøekladem pomocí nástroje <strong>javapc</strong>):</p>

<pre>
Compiled from "ExceptionTest4.java"
public class ExceptionTest4 extends java.lang.Object {
  public static java.util.List&lt;java.lang.String&gt; log;

  public ExceptionTest4();
    Code:
       0: aload_0       
       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V
       4: return        

  public static void main(java.lang.String[]);
    Code:
// ----------------------------------------------------------------
// tìlo bloku try
// ----------------------------------------------------------------
       0: aload_0       
       1: iconst_0      
       2: aaload        
       3: invokestatic  #2                  // Method java/lang/Integer.parseInt:(Ljava/lang/String;)I
       6: istore_1      
       7: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
      10: ldc           #4                  // String 1000 / %d = %d\n
      12: iconst_2      
      13: anewarray     #5                  // class java/lang/Object
      16: dup           
      17: iconst_0      
      18: iload_1       
      19: invokestatic  #6                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
      22: aastore       
      23: dup           
      24: iconst_1      
      25: sipush        1000
      28: iload_1       
      29: idiv          
      30: invokestatic  #6                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
      33: aastore       
      34: invokevirtual #7                  // Method java/io/PrintStream.format:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;
      37: pop           
      38: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
// ----------------------------------------------------------------
// blok finally volaný tehdy, kdy¾ nenastane ¾ádná nezachytitelná výjimka
// ----------------------------------------------------------------
      41: ldc           #8                  // String \nError log: 
      43: invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      46: getstatic     #10                 // Field log:Ljava/util/List;
      49: invokeinterface #11,  1           // InterfaceMethod java/util/List.iterator:()Ljava/util/Iterator;
      54: astore_1      
      55: aload_1       
      56: invokeinterface #12,  1           // InterfaceMethod java/util/Iterator.hasNext:()Z
      61: ifeq          84
      64: aload_1       
      65: invokeinterface #13,  1           // InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object;
      70: checkcast     #14                 // class java/lang/String
      73: astore_2      
      74: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
      77: aload_2       
      78: invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      81: goto          55
      84: goto          283
// ----------------------------------------------------------------
      87: astore_1      
      88: getstatic     #17                 // Field java/lang/System.err:Ljava/io/PrintStream;
      91: ldc           #18                 // String Chyba - jako prvni argument programu musi byt zadano cele cislo
      93: invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      96: getstatic     #10                 // Field log:Ljava/util/List;
      99: aload_1       
     100: invokevirtual #19                 // Method java/lang/RuntimeException.toString:()Ljava/lang/String;
     103: invokeinterface #20,  2           // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z
     108: pop           
     109: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
// ----------------------------------------------------------------
     112: ldc           #8                  // String \nError log: 
     114: invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
     117: getstatic     #10                 // Field log:Ljava/util/List;
     120: invokeinterface #11,  1           // InterfaceMethod java/util/List.iterator:()Ljava/util/Iterator;
     125: astore_1      
     126: aload_1       
     127: invokeinterface #12,  1           // InterfaceMethod java/util/Iterator.hasNext:()Z
     132: ifeq          155
     135: aload_1       
     136: invokeinterface #13,  1           // InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object;
     141: checkcast     #14                 // class java/lang/String
     144: astore_2      
     145: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
     148: aload_2       
     149: invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
     152: goto          126
     155: goto          283
// ----------------------------------------------------------------
     158: astore_1      
     159: getstatic     #17                 // Field java/lang/System.err:Ljava/io/PrintStream;
     162: ldc           #22                 // String Deleni nulou!
     164: invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
     167: getstatic     #10                 // Field log:Ljava/util/List;
     170: aload_1       
     171: invokevirtual #23                 // Method java/lang/ArithmeticException.toString:()Ljava/lang/String;
     174: invokeinterface #20,  2           // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z
     179: pop           
     180: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
     183: ldc           #8                  // String \nError log: 
     185: invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
     188: getstatic     #10                 // Field log:Ljava/util/List;
     191: invokeinterface #11,  1           // InterfaceMethod java/util/List.iterator:()Ljava/util/Iterator;
     196: astore_1      
     197: aload_1       
     198: invokeinterface #12,  1           // InterfaceMethod java/util/Iterator.hasNext:()Z
     203: ifeq          226
     206: aload_1       
     207: invokeinterface #13,  1           // InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object;
     212: checkcast     #14                 // class java/lang/String
     215: astore_2      
     216: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
     219: aload_2       
     220: invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
     223: goto          197
     226: goto          283
// ----------------------------------------------------------------
// blok finally volaný tehdy, kdy¾ nastane jiná výjimka
// ----------------------------------------------------------------
     229: astore_3      
     230: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
     233: ldc           #8                  // String \nError log: 
     235: invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
     238: getstatic     #10                 // Field log:Ljava/util/List;
     241: invokeinterface #11,  1           // InterfaceMethod java/util/List.iterator:()Ljava/util/Iterator;
     246: astore        4
     248: aload         4
     250: invokeinterface #12,  1           // InterfaceMethod java/util/Iterator.hasNext:()Z
     255: ifeq          281
     258: aload         4
     260: invokeinterface #13,  1           // InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object;
     265: checkcast     #14                 // class java/lang/String
     268: astore        5
     270: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
     273: aload         5
     275: invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
     278: goto          248
     281: aload_3       
     282: athrow        
// ----------------------------------------------------------------
     283: return        
    Exception table:
       from    to  target type
           0    38    87   Class java/lang/IndexOutOfBoundsException
           0    38    87   Class java/lang/NumberFormatException
           0    38   158   Class java/lang/ArithmeticException
           0    38   229   any
          87   109   229   any
         158   180   229   any
         229   230   229   any

  static {};
    Code:
       0: new           #24                 // class java/util/ArrayList
       3: dup           
       4: invokespecial #25                 // Method java/util/ArrayList."&lt;init&gt;":()V
       7: putstatic     #10                 // Field log:Ljava/util/List;
      10: return        
}
</pre>



<p><a name="k04"></a></p>
<h2>4. Co v&nbsp;JDK 7 nakonec nenajdeme?</h2>

<p>Ji¾ v&nbsp;první èásti tohoto miniseriálu jsme si øekli, ¾e nìkterá
vylep¹ení <i>Javy</i>, která se pùvodnì mìla objevit ji¾ v&nbsp;<i>JDK 7</i>,
byla po pøijetí plánu &bdquo;B&ldquo; pøesunuta a¾ do <i>JDK 8</i>
popø.&nbsp;do <i>JDK 9</i>. U nìkterých nových vlastností v¹ak není zøejmé, ve
kterých budoucích verzích <i>JDK</i> se skuteènì tyto vlastnosti objeví.
V&nbsp;následujícím textu si nìkterá z&nbsp;tìchto vlastností popí¹eme, proto¾e
s&nbsp;urèitou pravdìpodobností budou s&nbsp;pøedstihem implementována
v&nbsp;<i>OpenJDK 7</i> (ostatnì i dnes je mo¾né si pøelo¾it napøíklad
<i>OpenJDK 7</i> i s&nbsp;dále zmínìným projektem <i>Lambda</i>). Jedná se o
následující roz¹íøení:</p>

<ol>
<li>Zjednodu¹ená inicializace kolekcí.</li>
<li>Pøístup k&nbsp;prvkùm kolekcí pomocí &bdquo;indexového&ldquo; operátoru.</li>
<li>Zavedení podpory pro takzvané Elvis operátory.</li>
<li>Zavedení (resp.&nbsp;roz¹íøení) podpory pro anonymní funkce a uzávìry.</li>
</ol>



<p><a name="k05"></a></p>
<h2>5. Zjednodu¹ená inicializace kolekcí</h2>

<p>Jednou z&nbsp;novinek plánovaných v&nbsp;rámci projektu <i>Coin</i>, které
v¹ak nakonec v&nbsp;<i>JDK 7</i> neuvidíme, je zjednodu¹ení inicializace
kolekcí. Jedná se pøedev¹ím o odstranìní nutnosti pou¾ívat metody typu
<strong>put()</strong> a <strong>add()</strong> pøi deklaraci kolekce
následované ihned její konstrukcí a naplnìním daty (prvky). Konstrukci a
souèasné naplnìní kolekce v&nbsp;oficiálním <i>JDK 6</i> není mo¾né zapsat
pomocí jednoho pøíkazu (jen ne¹ikovnì pomocí <strong>Arrays.asList()</strong>
apod.), na rozdíl od polí. Pole je toti¾ mo¾né deklarovat, vytvoøit a souèasnì
i naplnit, popø.&nbsp;lze pouze vytvoøit a ihned naplnit anonymní pole:</p>

<pre>
public class ArrayTest
{
    int[]    pole1 = new int[] {1,2,3,4};
    int[][]  pole2 = new int[][] { {1,2,3}, {4,5,6}, {7,8,9} };
    String[] pole3 = new String[] {"aaa", "bbb", "ccc"};

    // výbìr druhého prvku z anonymního pole
    int x = new int[] {1,2,3,4}[1];
}
</pre>

<p>V&nbsp;<i>JDK 8</i> bude (doufejme) mo¾né podobnou konstrukci pou¾ít i pro
kolekce, nejenom pro pole. Pro seznamy byla zvolena konstrukce obsahující
hranaté závorky:</p>

<pre>
List&lt;Integer&gt; numbers =
[
    1, 2, 4, 8, 16, 32, 64, 128
];
</pre>

<p>Pov¹imnìte si absence <strong>new</strong>.</p>

<pre>
List&lt;String&gt; strings =
[
    "www", "root", "cz"
];
</pre>

<p>Pro mno¾iny byla naproti tomu zvolena konstrukce se slo¾enými závorkami:</p>

<pre>
Set&lt;Integer&gt; numbers =
{
    256, 512, 1024, 2048, 4096
};
</pre>

<pre>
Set&lt;String&gt; strings =
{
    "www", "java", "net"
};
</pre>

<p>Ètenáøùm velmi pravdìpodobnì dobøe známý <i>Joshua Bloch</i> <a
href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001193.html">uvádí
velmi pìkný pøíklad</a> (kupodivu ne¾ije v&nbsp;ÈR):</p>

<pre>
Set&lt;Senator&gt; honestSenators = {};
</pre>

<p>Pro mapy (asociativní pole) se pou¾ívá konstrukce, která se nápadnì podobná
syntaxi známé z&nbsp;nìkterých skriptovacích jazykù:</p>

<pre>
Map&lt;String, String&gt; translations =
{
    "Hi"      : "Bonjour",
    "Goodbye" : "Au revoir",
    "Thanks"  : "Merci"
};
</pre>

<p>S&nbsp;velkou pravdìpodobností bude umo¾nìna i tvorba slo¾itìj¹ích datových
struktur (opìt se jedná o pøíklad pøevzatý od <i>Joshuy Blocha</i>):</p>

<pre>
List&lt;List&lt;Integer&gt;&gt; pascalsTriangle =
[
    [1],
    [1, 1],
    [1, 2, 1],
    [1, 3, 3, 1],
    [1, 4, 6, 4, 1]
];
</pre>

<p>V¹echny vý¹e zmínìné konstrukce bude samozøejmì mo¾né pou¾ít jak pøi
inicializaci atributù objektù nebo tøíd, tak i pøi inicializaci lokálních
promìnných, podobnì jako je tomu u inicializace &bdquo;jednoduchých&ldquo;
objektù, primitivních datových typù i polí.</p>



<p><a name="k06"></a></p>
<h2>6. Pøístup k&nbsp;prvkùm kolekcí pøes &bdquo;indexové&ldquo; závorky</h2>

<p>S&nbsp;inicializacemi kolekcí souvisí i dal¹í nová vlastnost, která by se
mohla objevit v&nbsp;<i>JDK 8</i>. Jedná se o mo¾nost pøistupovat k&nbsp;prvkùm
kolekcí, pøesnìji øeèeno k&nbsp;seznamùm a mapám (asociativním polím), nejenom
s&nbsp;vyu¾itím metod <strong>get()</strong>, <strong>set()</strong> a
<strong>put()</strong>, ale té¾ pomocí hranatých &bdquo;indexových&ldquo;
závorek, tedy podobným zpùsobem, jakým se pøistupuje k&nbsp;prvkùm polí. U
seznamù se pou¾ívá stejná syntaxe jako u polí, tj.&nbsp;uvnitø hranatých
závorek se musí nacházet celoèíselná konstanta nebo výraz, jen¾ se vyhodnocuje
na celé èíslo. Identifikátor seznamu následovaný hranatými závorkami
s&nbsp;indexem lze pou¾ít jak na levé stranì pøiøazovacího pøíkazu (zde
nahrazuje metodu <strong>set()</strong>), tak i jako souèást libovolného výrazu
(zde nahrazuje metodu <strong>get()</strong>). Následuje jednoduchá ukázka,
z&nbsp;které je zøejmé, ¾e s&nbsp;vyu¾itím nové syntaxe mù¾e dojít ke
zjednodu¹ení zápisu nìkterých algoritmù:</p>

<pre>
public class CollectionTest2
{
    public static void main(String[] args)
    {
        List&lt;String&gt; list = ["aaa", "bbb", "ccc"];
        String firstElement = list[0];         // list.get(0);
        list[2] = "nova hodnota";              // list.set(2, "nova hodnota");
    }
}
</pre>

<p>Podobný zpùsob zápisu bude mo¾né pou¾ít i pro mapy (asociativní pole), ov¹em
s&nbsp;tím rozdílem, ¾e se v&nbsp;tomto pøípadì nahrazují metody
<strong>get()</strong> a <strong>put()</strong>. Navíc se jako
&bdquo;indexy&ldquo; nepou¾ívají pouze celá èísla, ale klíèe, jejich¾ typy
odpovídají typùm klíèù dané mapy:</p>

<pre>
public class CollectionTest2
{
    public static void main(String[] args)
    {
        Map&lt;String, String&gt; map = new HashMap&lt;Integer, String&gt;(4);
        map["Klic"] = "Hodnota";                // map.put("Klic", "Hodnota");
        System.out.println(map["Jiny klic"]);   // map.get("Jiny klic");
    }
}
</pre>



<p><a name="k07"></a></p>
<h2>7. Elvis operátory</h2>

<p>Dal¹ím roz¹íøením syntaxe a sémantiky <i>Javy</i>, na jeho¾ koneènou
implementaci si budeme muset je¹tì nìkolik mìsícù poèkat, je zavedení
takzvaných <i>Elvis operátorù</i> (nena¹el jsem nikde pøesné vysvìtlení, proè
mají takový název ani jaký je správný èeský ekvivalent názvu). Tyto typy
operátorù nejsou v&nbsp;¾ádném pøípadì ve svìtì programovacích jazykù nové,
mù¾eme je nalézt napøíklad v&nbsp;jazyku <i>Groovy</i> a pod jiným oznaèením i
v&nbsp;<i>C#</i>. V&nbsp;<i>JDK 8</i> by mìla být mno¾ina ji¾ zavedených
operátorù roz¹íøena o dal¹í trojici: binární (nikoli ternární!) operátor
<strong>?:</strong>, dále o operátor <strong>?.</strong> a koneènì o operátor
<strong>?[]</strong>. V¹echny tøi nové operátory mají zjednodu¹it práci
s&nbsp;objekty, které mohou nabývat hodnoty <strong>null</strong>.
V&nbsp;souèasné Javì se v&nbsp;programech èasto pou¾ívají (nìkdy kvùli ¹patnì
navr¾enému API!) podmínky typu <strong>if (xxx != null)</strong>,
<strong>xxx!=null ? xxx.doIt() : pass()</strong>, popø.&nbsp;se odchytává
výjimka typu <strong>NPE &ndash; Null Pointer Exception</strong>. Trojice
nových operátorù mù¾e tyto programy zjednodu¹it.</p>

<p>Binární operátor <strong>?:</strong> nejprve zjistí, zda je objekt na jeho
levé stranì roven <strong>null</strong>. Pokud tomu tak skuteènì je, vrátí se
vyhodnocená pravá strana výrazu. V&nbsp;opaèném pøípadì, tj.&nbsp;pokud je
objekt na levé stranì rozdílný od <strong>null</strong>, je tento objekt vrácen
bez ohledu na pravou stranu výrazu (ta se zcela ignoruje). Pou¾ití tohoto
operátoru je jednodu¹¹í ne¾ jeho popis:</p>

<pre>
displayName = user.name ?: "Anonymous";
</pre>

<p>Popø.&nbsp;ponìkud slo¾itìj¹í pou¾ití (nikdy nedojde
k&nbsp;<strong>NPE</strong>):</p>

<pre>
Integer ival = ...;  // mù¾e být klidnì i null
int i = ival ?: -1;  // provádí se unboxing, ale nedojde k NPE
</pre>

<p>Druhý operátor <strong>?.</strong> pracuje podobnì jako stávající operátor .
(teèka), ov¹em pravá strana (metoda, atribut...) se zpracuje pouze tehdy, pokud
je objekt na levé stranì tohoto operátoru rozdílný od <strong>null</strong>.
Tyto operátory lze samozøejmì &bdquo;zøetìzit&ldquo;, tj.&nbsp;lze napøíklad
pøistupovat k&nbsp;atributùm atributù, a to bez nebezpeèí, ¾e by do¹lo
k&nbsp;vyvolání <strong>NPE</strong>:</p>

<pre>
object?.callMethod();
streetName = user?.address?.street;
String s = mayBeNull?.toString() ?: "null";
</pre>

<p>Poslední z&nbsp;nových operátorù se zapisuje pomocí znakù
<strong>?[]</strong>, tak¾e ji¾ ètenáøi pravdìpodobnì uhodli, ¾e se jedná o
operátor indexace polí (a pravdìpodobnì i kolekcí &ndash; viz pøedcházející
kapitolu!), který ov¹em pøistupuje k&nbsp;prvkùm pole (kolekce) pouze
v&nbsp;pøípadì, ¾e daný objekt typu pole (kolekce) nemá hodnotu
<strong>null</strong>:</p>

<pre>
members?[2];       // nevyhodí NPE ani kdy¾ members==null
</pre>

<p>Slo¾itìj¹í pøíklad:</p>

<pre>
String aMember = null;
if (g != null &amp;&amp; g.members != null &amp;&amp; g.members[0].name != null)
{
    aMember = g.members[0].name;
}
else
{
    aMember = "nobody";
}
</pre>

<p>bude mo¾né nahradit jednoduchým a mnohem pøehlednìj¹ím one-linerem:</p>

<pre>
String aMember = g?.members?[0]?.name ?: "nobody";
</pre>



<p><a name="k08"></a></p>
<h2>8. Projekt Lambda &ndash; radikální roz¹íøení syntaxe a sémantiky Javy</h2>

<p>Posledním roz¹íøením syntaxe a sémantiky <i>Javy</i>, které v¹ak nakonec
nebylo do <i>JDK 7</i> zaøazeno, je podpora pro tvorbu anonymních funkcí,
datového typu funkce a uzávìrù (<i>closure(s)</i>). Tyto vlastnosti jsou ji¾
z&nbsp;velké èásti implementovány v&nbsp;rámci projektu <i>Lambda</i>. Zatímco
v¹echny pøedchozí syntaktické novinky byly vlastnì pouze evoluèní, je zavedení
anonymních funkcí a uzávìrù spí¹e revoluce, alespoò na poli <i>Javy</i> (a
tro¹ku se tím potvrzuje známé motto, ¾e v¹echny jazyky postupem èasu dospìjí
k&nbsp;<i>LISPu</i> :-). Anonymní funkce (té¾ <i>lambda výrazy</i>) jsou v¹ak
v&nbsp;<i>Javì</i> zvlá¹tní tím, ¾e jsou staticky typované, zatímco klasické
lambda výrazy známe spí¹e z&nbsp;dynamicky typovaných programovacích
jazykù.</p>

<p>Zatímco sémantika lambda výrazù je celkem zøejmá (podrobnìji se tímto
tématem budeme zabývat pøí¹tì), syntaxe, která byla zvolena pro <i>Javu</i>,
vyvolává mezi u¾ivateli pomìrnì velké polemiky: samotný symbol lambdy je
nahrazen køí¾kem (co¾ je jeden z&nbsp;mála volných tisknutelných symbolù
v&nbsp;ASCII), celé tìlo je od parametrù oddìleno pomocí kulatých závorek (jiné
jazyky pou¾ívají napøíklad èitelnìj¹í zápis =&gt;) a pøi volání lambda výrazu
se musí pou¾ít teèka pøed závorkami s&nbsp;parametry, co¾ souvisí s&nbsp;tím,
¾e <i>Java</i> má z&nbsp;historických dùvodù rozdìlený jmenný prostor pro
funkce a atributy/promìnné (a nebylo by tedy zøejmé, zda se má zavolat lambda
výraz pøiøazený do atributu nebo stejnì pojmenovaná metoda!). Projektem
<i>Lambda</i> se budeme podrobnìji zabývat pøí¹tì, zde si pouze uvedeme nìkolik
pøíkladù:</p>

<pre>
// lambda výraz, pouze zapsaný a nikam nepøiøazený, nevyhodnocovaný
#(int x) (x+1);
</pre>

<pre>
// pøiøazení lambda výrazu do promìnné èi atributu
// (pov¹imnìte si typu této promìnné/atributu)
#int(int) inc = #(int x) (x+1);
</pre>

<pre>
// vyhodnocení (s teèkou pøed závorkou s parametry!)
int y = inc.(42)
</pre>



<p><a name="k09"></a></p>
<h2>9. Odkazy na Internetu</h2>

<ol>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>ClosableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>ArrayList (JDK 1.4)<br />
<a href="http://download.oracle.com/javase/1.4.2/docs/api/java/util/ArrayList.html">http://download.oracle.com/javase/1.4.2/docs/api/java/util/ArrayList.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2010</small></p>
</body>
</html>

