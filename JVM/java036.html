<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Clojure aneb jazyk umo¾òující tvorbu bezpeèných vícevláknových aplikací pro JVM (5.èást - sekvence, lazy sekvence a paralelní programy)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Clojure aneb jazyk umo¾òující tvorbu bezpeèných vícevláknových aplikací pro JVM (5.èást - sekvence, lazy sekvence a paralelní programy)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o vlastnostech JVM se ji¾ popáté budeme zabývat jazykem Clojure postaveným nad virtuálním strojem Javy. Øekneme si dal¹í informace o sekvencích i lazy sekvencích, vèetnì zpùsobu jejich základního vyu¾ití pøi paralelních výpoètech.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Krátké zopakování pøedchozí èásti seriálu: sekvence a lazy sekvence</a></p>
<p><a href="#k02">2. Funkce <strong>nth</strong> a <strong>take</strong></a></p>
<p><a href="#k03">3. Funkce <strong>take-while</strong></a></p>
<p><a href="#k04">4. Pøímé vytvoøení lazy sekvence</a></p>
<p><a href="#k05">5. Pou¾ití <strong>iterate</strong> pro vytvoøení lazy sekvence</a></p>
<p><a href="#k06">6. Funkce <strong>filter</strong> a <strong>apply</strong></a></p>
<p><a href="#k07">7. Sekvence a paralelní výpoèty</a></p>
<p><a href="#k08">8. Funkce <strong>pmap</strong></a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Krátké zopakování pøedchozí èásti seriálu: sekvence a lazy sekvence</h2>

<p><a
href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">V&nbsp;pøedchozí
èásti</a> <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyce Java i o vlastnostech virtuálního stroje tohoto jazyka</a>
jsme se zabývali popisem kolekcí (tj.&nbsp;seznamù, vektorù, map a mno¾in) a
takté¾ popisem sekvencí i takzvaných lazy sekvencí. <i>Sekvence</i>, které
svými základními mo¾nostmi zhruba odpovídají <i>iterátorùm</i> známým
z&nbsp;programovacího jazyka Java, jsou velmi dùle¾itou souèástí <i>Clojure</i>
a najdeme je v&nbsp;prakticky v¹ech aplikacích, které jsou v&nbsp;Clojure
naprogramovány. V&nbsp;nìkterých typech aplikací mù¾e být takté¾ u¾iteèná
mo¾nost zpracovat sekvenci (v&nbsp;tomto pøípadì nejèastìji lazy sekvenci)
s&nbsp;vyu¾itím funkce <strong>pmap</strong>, neboli <i>parallel
<strong>map</strong></i>. Zajímavé je, ¾e i výsledkem funkce
<strong>pmap</strong> je lazy sekvence, tj.&nbsp;prvky této sekvence mohou být
vyhodnoceny a¾ ve chvíli, kdy jsou skuteènì zapotøebí.</p>

<p>Minule jsme si takté¾ øekli, ¾e základ pro práci se sekvencemi tvoøí trojice
funkcí nazvaných <strong>first</strong>, <strong>rest</strong> a
<strong>next</strong>. Funkce <strong>first</strong> vrací první prvek
v&nbsp;sekvenci, popø.&nbsp; speciální hodnotu <strong>nil</strong>
v&nbsp;pøípadì, ¾e je sekvence prázdná. Funkce <strong>rest</strong> i
<strong>next</strong> vrací zbylé prvky v&nbsp;sekvenci, ov¹em li¹í se tím,
jaká hodnota se vrátí ve chvíli, kdy ji¾ v&nbsp;sekvenci nezbyly ¾ádné prvky
(kromì prvního). V&nbsp;tomto pøípadì vrátí <strong>rest</strong> prázdnou
sekvenci (napøíklad prázdný seznam), zatímco funkce <strong>next</strong> vrátí
hodnotu <strong>nil</strong>. V&nbsp;pøípadì <i>lazy sekvencí</i> se prvky
vrácené pomocí funkce <strong>first</strong> vyhodnocují a¾ za bìhu, typicky
s&nbsp;vyu¾itím nìjaké generátorové funkce (napøíklad <strong>range</strong>).
Tímto zpùsobem je mo¾né pracovat i s&nbsp;nekoneènými sekvencemi, u nich¾ u¾
z&nbsp;principu nelze dopøedu znát celkový poèet prvkù atd.</p>

<p>Z&nbsp;nìkterých funkcí pracujících se sekvencemi a lazy sekvencemi jsme si
popsali pøedev¹ím funkci <strong>range</strong> (generování potenciálnì
nekoneèné aritmetické øady), <strong>repeat</strong> (generování potenciálnì
nekoneèné øady stejných hodnot) a nakonec jsme se zabývali velmi u¾iteènou
funkcí <strong>map</strong>, jejím¾ výsledkem je lazy sekvence a to opìt
sekvence, která mù¾e mít v&nbsp;nìkterých pøípadech nekoneèný poèet prvkù. Bez
dal¹ího podrobnìj¹ího popisu si je¹tì uká¾eme nìkolik pøíkladù uvedených ji¾
v&nbsp;pøedchozí èásti tohoto seriálu (tam takté¾ najdete popis tìchto
pøíkladù):</p>

<p>Sekvence od nuly do devíti (asi nejjednodu¹¹í pøíklad reálného pou¾ití
funkce <strong>range</strong>):</p>

<pre>
user=&gt; (range 10)
(0 1 2 3 4 5 6 7 8 9)
</pre>

<p>Pou¾ití záporného kroku rùzného od jednièky:</p>

<pre>
user=&gt; (range 20 10 -2)
(20 18 16 14 12)
</pre>

<p>Vytvoøení sekvence obsahující deset hodnot 42:</p>

<pre>
(repeat 10 42)
(42 42 42 42 42 42 42 42 42 42)
</pre>

<p>Aplikace funkce <strong>inc</strong> na ka¾dý prvek sekvence (zde
vektoru):</p>

<pre>
(map inc [1 2 3 4 5 6 7 8])
(2 3 4 5 6 7 8 9)
</pre>

<p>Sekvenci lze samozøejmì vytvoøit i s&nbsp;vyu¾itím funkcí
<strong>range</strong> a <strong>repeat</strong> (pøièem¾ první zmiòovaná
funkce je mnohem u¾iteènìj¹í):</p>

<pre>
(map inc (range 1 9))
(2 3 4 5 6 7 8 9)
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Funkce <strong>nth</strong> a <strong>take</strong></h2>

<p>Pøi práci s&nbsp;lazy sekvencemi, které obsahují nekoneèný poèet prvkù, si
musíme dát pozor na to, aby se náhodou nespustilo vyhodnocení celé (nekoneèné)
sekvence. V&nbsp;reálných programech k&nbsp;tomuto problému v&nbsp;naprosté
vìt¹inì pøípadù nedochází, u¾ jen z&nbsp;toho dùvodu, ¾e napøíklad funkce
<strong>map</strong> jako svùj parametr akceptuje lazy sekvenci a jejím
výsledkem je takté¾ lazy sekvence. To napøíklad znamená, ¾e následující dvojice
pøíkazù se provede prakticky ihned, ani¾ by se interpret programovacího jazyka
Clojure sna¾il o vyhodnocení v¹ech prvkù vytváøených funkcí
<strong>range</strong>:</p>

<pre>
user=&gt; (def lazy-seq-1 (range))
#'user/lazy-seq-1
&nbsp;
user=&gt; (def lazy-seq-2 (map inc lazy-seq-1))
#'user/lazy-seq-2
</pre>

<p>Problém v¹ak mù¾e nastat v&nbsp;pøípadì, kdy se o vyhodnocení v¹ech prvkù
nekoneèné sekvence bude sna¾it samotná smyèka <i>REPL</i>, tak¾e napøíklad
jeden z&nbsp;následujících dvou pøíkazù skonèí výpisem VELMI dlouhé øady
èíselných hodnot:</p>

<pre>
user=&gt; (range)
&nbsp;
user=&gt; (map inc lazy-seq-1)
</pre>

<p>My ov¹em v&nbsp;následujících kapitolách budeme muset zjistit a vypsat
hodnotu alespoò nìkolika prvkù nekoneèných lazy sekvencí. K&nbsp;tomuto úèelu
nám dobøe poslou¾í funkce <strong>nth</strong>, <strong>take</strong> a nìkdy
takté¾ ponìkud slo¾itìj¹í funkce <strong>take-while</strong>. Nejjednodu¹¹í
z&nbsp;této trojice funkcí je funkce <strong>nth</strong>, je¾ &ndash; jak jste
ji¾ asi z&nbsp;jejího názvu uhodli &ndash; vrací <i>n</i>-tý prvek sekvence,
co¾ vìt¹inou znamená, ¾e se vyhodnotí i pøedchozích <i>n-1</i> prvkù (ov¹em ve
skuteènosti se výsledky ukládají do vyrovnávací pamìti, tak¾e nìkdy
k&nbsp;vyhodnocení nedochází):</p>

<pre>
user=&gt; (nth (range) 10)
10
</pre>

<pre>
user=&gt; (nth (range 1 100 2) 10)
21
</pre>

<p>Následuje ponìkud umìlý pøíklad, proto¾e funkce <strong>repeat</strong>
vrací nekoneènou lazy sekvenci stejných hodnot, tudí¾ je ve skuteènosti jedno,
který prvek sekvence získáme:</p>

<pre>
user=&gt; (nth (repeat "opakujeme") 10)
"opakujeme"
</pre>

<p>Vra»me se nyní k&nbsp;úvodnímu pøíkladu této kapitoly:</p>

<pre>
user=&gt; (def lazy-seq-1 (range))
#'user/lazy-seq-1
&nbsp;
user=&gt; (def lazy-seq-2 (map inc lazy-seq-1))
#'user/lazy-seq-2
&nbsp;
user=&gt; (nth lazy-seq-1 10)
10
&nbsp;
user=&gt; (nth lazy-seq-2 10)
11
</pre>

<p>Zatímco funkce <strong>nth</strong> vrátí konkrétní prvek z&nbsp;lazy
sekvence, je dal¹í u¾iteèná funkce &ndash; <strong>take</strong> &ndash;
ponìkud obecnìj¹í, nebo» ta vrací prvních <i>n</i> prvkù lazy sekvence. Ov¹em
výsledkem není vektor èi seznam tìchto prvkù, ale takté¾ lazy sekvence, co¾
znamená, ¾e k&nbsp;vyhodnocení (získání) prvkù dochází pozdìji a nìkdy takté¾
vùbec ne. My ov¹em v&nbsp;na¹ich pøíkladech budeme výsledek funkce
<strong>take</strong> vypisovat pomocí <i>REPL</i>, tak¾e k&nbsp;vyhodnocení
dojde v¾dy:</p>

<pre>
user=&gt; (take 10 (range))
(0 1 2 3 4 5 6 7 8 9)
</pre>

<pre>
user=&gt; (take 10 (repeat :x))
(:x :x :x :x :x :x :x :x :x :x)
</pre>

<pre>
user=&gt; (take 10 (range 0 10000 3))
(0 3 6 9 12 15 18 21 24 27)
</pre>

<p>Opìt se vra»me k&nbsp;prvnímu pøíkladu z&nbsp;této kapitoly:</p>

<pre>
user=&gt; (def lazy-seq-1 (range))
#'user/lazy-seq-1
&nbsp;
user=&gt; (def lazy-seq-2 (map inc lazy-seq-1))
#'user/lazy-seq-2
&nbsp;
user=&gt; (take 10 lazy-seq-1)
(0 1 2 3 4 5 6 7 8 9)
&nbsp;
user=&gt; (take 10 lazy-seq-2)
(1 2 3 4 5 6 7 8 9 10)
</pre>

<p>Pov¹imnìte si toho, ¾e parametry funkce <strong>nth</strong> a funkce
<strong>take</strong> jsou uvedeny v&nbsp;opaèném poøadí, co¾ je ponìkud
matoucí.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Funkce <strong>take-while</strong></h2>

<p>V&nbsp;nìkterých pøípadech nám bude u¾iteèná i ponìkud komplikovanìj¹í
funkce, která je nazvaná <strong>take-while</strong>. Zatímco u funkce
<strong>take</strong> se pøímo zadával poèet prvkù lazy sekvence, která se má
vrátit, je v&nbsp;pøípadì funkce <strong>take-while</strong> namísto
konstantního poètu prvkù výsledné sekvence pøedán predikát, tj.&nbsp;funkce
s&nbsp;(v&nbsp;tomto pøípadì) jedním parametrem, jejím¾ výsledkem by mìla být
pravdivostní hodnota <strong>true</strong> nebo <strong>false</strong> (asi si
ji¾ nemusíme pøipomínat, ¾e funkce lze v&nbsp;Clojure pou¾ít na stejném místì,
jako jiné typy hodnot, tedy i funkce lze bez problémù pøedat jako parametr do
jiné funkce).</p>

<p>Návratovou hodnotou funkce <strong>take-while</strong> je opìt lazy sekvence
získaná ze vstupní sekvence, ov¹em vráceno je pouze prvních <i>n</i> prvkù, pro
nì¾ predikát vrací hodnotu <strong>true</strong>. Nejedná se v¹ak o klasický
filtr (viz té¾ dal¹í kapitoly), proto¾e ihned ve chvíli, kdy predikát poprvé
vrátí hodnotu <strong>false</strong>, je lazy sekvence ukonèena. Pokud vrátí
predikát hodnotu <strong>false</strong> ji¾ pøi prvním volání, je výsledkem
prázdná sekvence, pokud naopak vrací hodnotu <strong>true</strong> v¾dy, vrátí
se potenciálnì nekoneèná lazy sekvence (co¾ v¹ak nìkdy nemusí vadit, pokud se
tedy nebudeme sna¾it o výpis v¹ech prvkù). Vzhledem k&nbsp;urèitým omezením
<strong>take-while</strong> je nutné, aby mìl predikát pouze jeden parametr,
co¾ vìt¹inou znamená, ¾e si musíme vypomoci novou funkcí (popø.&nbsp;anonymní
funkcí).</p>

<p>Následuje pøíklad velmi jednoduchého pomocného predikátu, tj.&nbsp;funkce,
která vrací hodnotu <strong>true</strong> v&nbsp;pøípadì, ¾e je jí pøedaný
parametr men¹í nebo roven èíselné konstantì 42:</p>

<pre>
user=&gt;  (defn end-of-lazy-seq [x] (&lt;= x 42))
#'user/end-of-lazy-seq
</pre>

<p>Tento predikát ji¾ mù¾eme pou¾ít ve funkci <strong>take-while</strong>
aplikované na nekoneènou aritmetickou øadu generovanou funkcí
<strong>range</strong>:</p>

<pre>
user=&gt; (take-while end-of-lazy-seq (range))
(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42)
</pre>

<p>Popø:</p>

<pre>
user=&gt; (take-while end-of-lazy-seq (range 1 100 3))
(1 4 7 10 13 16 19 22 25 28 31 34 37 40)
</pre>

<p>Mnozí programátoøi dávají pøednost pou¾ití anonymních funkcí, co¾ je mnohdy
velmi elegantní øe¹ení:</p>

<pre>
user=&gt; (take-while (fn [x] (&lt;= x 42)) (range))
(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42)
</pre>

<p>Jen v&nbsp;nìkterých pøípadech lze pøímo pou¾ít predikáty, které jsou
souèástí základních knihoven programovacího jazyka Clojure:</p>

<pre>
; pøíklad koneèné lazy sekvence se záporným krokem
user=&gt; (range 10 -10 -1)
(10 9 8 7 6 5 4 3 2 1 0 -1 -2 -3 -4 -5 -6 -7 -8 -9)
&nbsp;
; získáme a následnì vypí¹eme pouze kladné hodnoty z této sekvence
user=&gt; (take-while pos? (range 10 -10 -1))
(10 9 8 7 6 5 4 3 2 1)
&nbsp;
; ov¹em pokud prekikát vrátí hned v prvním kroku hodnotu false,
; je výsledkem prázdná sekvence
user=&gt; (take-while neg? (range 10 -10 -1))
()
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Pøímé vytvoøení lazy sekvence</h2>

<p>V&nbsp;demonstraèních pøíkladech jsme se ji¾ setkali minimálnì se tøemi
funkcemi, jejich¾ výsledkem je lazy sekvence. Jednalo se o funkce
<strong>range</strong>, <strong>repeat</strong> a <strong>map</strong>. Ov¹em
prozatím vlastnì ani nevíme, jakým zpùsobem je mo¾né vytvoøit vlastní lazy
sekvenci. Ve skuteènosti to ani není pøíli¹ slo¾ité, proto¾e nám programovací
jazyk Clojure pro tyto úèely poskytuje makro nazvané pøímoèaøe
<strong>lazy-seq</strong>. S&nbsp;vyu¾itím tohoto makra lze ve velkém mno¾ství
pøípadù generovat lazy sekvenci takovým zpùsobem, ani¾ by bylo nutné pøi
výpoètu pou¾ít rekurzi, jeliko¾ ji¾ z&nbsp;pøedchozích èástí tohoto seriálu
víme, ¾e rekurze s&nbsp;sebou pøiná¹í i urèité problémy pøi ukládání parametrù
a návratových adres na zásobník a øe¹ení ve formì tail rekurze není v¾dy snadno
dostupné. Podívejme se nyní na zpùsob vyu¾ití makra <strong>lazy-seq</strong>
v&nbsp;praxi.</p>

<p>Se znalostí funkcí <strong>nth</strong>, <strong>take</strong> a
<strong>take-while</strong> si nyní mù¾eme naprogramovat vlastní èítaè, který
v¹ak namísto aritmetické øady (co¾ je zále¾itost standardní funkce
<strong>range</strong>, kterou ji¾ známe) bude vytváøet øadu geometrickou,
kterou lze v&nbsp;rámci zjednodu¹ení pova¾ovat za nekoneènou øadu. Problémy
nastanou s&nbsp;pøeteèením výsledkù i to v¹ak lze èásteènì øe¹it
s&nbsp;vyu¾itím <strong>BigDecimal</strong>. Takový èítaè by mohl být
deklarován jako funkce vracející lazy sekvenci, kterému se pøedá hodnota prvku
<i>a<sub>0</sub></i> a koeficient <i>q</i>:</p>

<pre>
(defn geom-counter [a_n q]
    (lazy-seq
        (cons a_n (geom-counter (* a_n q) q))))
</pre>

<p>Funkci <strong>cons</strong> ji¾ známe &ndash; jde o konstruktor seznamu
(resp.&nbsp;obecné sekvence), který vytvoøí nový seznam pøipojením dal¹ího
prvku. Pov¹imnìte si, ¾e pøi deklaraci funkce <strong>geom-counter</strong> je
sice pou¾ita rekurze, tak¾e by se mohlo zdát, ¾e jsme se problému
s&nbsp;pøeteèením zásobníku nakonec nevyhnuli, ov¹em díky pou¾ití makra
<strong>lazy-seq</strong> je výpoèet dal¹ího prvku lazy sekvence spu¹tìn a¾ ve
chvíli, kdy je známý pøedchozí prvek, tudí¾ k&nbsp;rekurzi ve skuteènosti
nedojde. Mù¾eme si to ostatnì vyzkou¹et.</p>

<p>Prvních deset prvkù mocnin dvojky:</p>

<pre>
user=&gt; (take 10 (geom-counter 1 2))
(1 2 4 8 16 32 64 128 256 512)
</pre>

<p>Vrácení desátého prvku stejné geometrické øady:</p>

<pre>
user=&gt; (nth (geom-counter 1 2) 10)
1024
</pre>

<p>Mù¾eme se pokusit získat tisící prvek, ov¹em aby se zabránilo pøeteèení
celých èísel, je nutné interpretru Clojure &bdquo;vnutit&ldquo; konstantu typu
<strong>BigDecimal</strong> (suffix M u hodnoty prvku a<sub>0</sub>):</p>

<pre>
user=&gt; (nth (geom-counter 1M 2) 1000)
10715086071862673209484250490600018105614048117055336074437503883703510
51124936122493198378815695858127594672917553146825187145285692314043598
45775746985748039345677748242309854210746050623711418779541821530464749
83581941267398767559165543946077062914571196477686542167660429831652624
386837205668069376M
</pre>

<p>Co by se v¹ak stalo, kdyby se namísto generátoru lazy sekvence pou¾il pouhý
pøímoèarý rekurzivní výpoèet? Mù¾eme si to snadno otestovat:</p>

<pre>
(defn geom-counter [a_n q]
    (cons a_n (geom-counter (* a_n q) q)))
</pre>

<p>Pøi vyhodnocení <i>n</i>-tého prvku sekvence s&nbsp;vyu¾itím funkce
<strong>nth</strong> samozøejmì dojde k&nbsp;nekoneèné rekurzi a po malé chvíli
i k&nbsp;pøeteèení zásobníku. Nikde toti¾ nemáme zadanou podmínku pro ukonèení
rekurze, co¾ v¹ak v&nbsp;pøípadì pøedchozího pøíkladu s&nbsp;generátorem lazy
sekvence vùbec nevadilo:</p>

<pre>
user=&gt; (nth (geom-counter 1 2) 1)
ArithmeticException integer overflow  clojure.lang.Numbers.throwIntOverflow (Numbers.java:1388)
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Pou¾ití <strong>iterate</strong> pro vytvoøení lazy sekvence</h2>

<p>Vyu¾ití makra <strong>lazy-seq</strong> pro vytvoøení nové lazy sekvence je
sice v&nbsp;mnoha pøípadech u¾iteèné, ov¹em nìkdy je jednodu¹¹í a pøímoèaøej¹í
namísto tohoto makra pou¾ít funkci <strong>iterate</strong>, která se takté¾
nachází ve standardní knihovnì programovacího jazyka Clojure. Funkce
<strong>iterate</strong> generuje nekoneènou sekvenci takovým zpùsobem, ¾e
postupnì aplikuje vybranou funkci (svùj první parametr) na prvek získaný
v&nbsp;pøedchozí iteraci. Poèáteèní hodnota prvku pro nultou iteraci je pøedána
funkci <strong>iterate</strong> jako druhý parametr. Dobrým pøíkladem pou¾ití
funkce <strong>iterate</strong> je lazy sekvence obsahující v¹echna kladná
èísla. Ta se získají jednodu¹e &ndash; prvním prvkem celé sekvence je hodnota
nula (popø.&nbsp;hodnota jedna, pokud potøebujeme, aby øada nezaèínala od nuly)
a ka¾dý dal¹í prvek se získá z&nbsp;prvku pøedchozího s&nbsp;vyu¾itím nám ji¾
známé funkce <strong>inc</strong> (<i>increment</i>). Pouze si opìt musíme dát
pozor na to, aby se smyèka <i>REPL</i> nesna¾ila o vyhodnocení a o následný
výpis v¹ech kladných èísel:</p>

<pre>
user=&gt; (def kladna-cisla (iterate inc 0))
#'user/kladna-cisla
&nbsp;
user=&gt; (nth kladna-cisla 42)
42
&nbsp;
user=&gt; (take 10 kladna-cisla)
(0 1 2 3 4 5 6 7 8 9)
</pre>

<p>Popø.&nbsp;si mù¾eme vygenerovat geometrickou øadu:</p>

<pre>
user=&gt; (defn two-times [x] (* x 2))
#'user/two-times
&nbsp;
user=&gt; (def power-2 (iterate two-times 1))
#'user/power-2
&nbsp;
user=&gt; (take 10 power-2)
(1 2 4 8 16 32 64 128 256 512)
</pre>

<p>Pokud preferujete pou¾ívání anonymních funkcí, lze poèet forem zmen¹it na
pouhé dvì formy:</p>

<pre>
user=&gt; (def power-2 (iterate (fn [x] (* x 2)) 1))
#'user/power-2
&nbsp;
user=&gt; (take 10 power-2)
(1 2 4 8 16 32 64 128 256 512)
</pre>

<p>Se znalostí funkce <strong>iterate</strong> je mo¾né vytvoøit lazy sekvenci
vyu¾ívající èítaè napøíklad takto:</p>

<pre>
user=&gt; (defn lazy-counter [a_n q] (iterate (fn [n] (* n q)) a_n))
#'user/lazy-counter
&nbsp;
user=&gt; (take 10 (lazy-counter 2 3))
(2 6 18 54 162 486 1458 4374 13122 39366)
</pre>

<p>První one-liner vypadá ponìkud neèitelnì, tak¾e ho pøepi¹me tak, aby byly
vidìt oba parametry funkce <strong>iterate</strong> &ndash; prvním parametrem
je anonymní funkce pro výpoèet <i>n+1</i> prvku na základì <i>n</i>-tého prvku,
druhým parametrem je hodnota prvního prvku v&nbsp;øadì:</p>

<pre>
(defn lazy-counter [a_n q]
    (iterate
        (fn [n] (* n q))
        a_n))
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Funkce <strong>filter</strong> a <strong>apply</strong></h2>

<p>Pøi vytváøení reálných aplikací s&nbsp;vyu¾itím programovacího jazyka
Clojure se takté¾ èasto mù¾eme setkat s&nbsp;funkcemi nazvanými
<strong>filter</strong> a <strong>apply</strong>. Jedná se o známé funkce,
které lze najít v&nbsp;mnoha funkcionálních programovacích jazycích. Funkce
<strong>filter</strong> je v&nbsp;urèitém pohledu podobná ji¾ døíve popsané
funkci <strong>take-while</strong>, proto¾e i zde je na lazy sekvenci aplikován
nìjaký predikát, tj.&nbsp;funkce zavolaná pro ka¾dý prvek zpracovávané lazy
sekvence, která vrací pravdivostní hodnotu <strong>true</strong> nebo
<strong>false</strong>. Výsledkem práce funkce <strong>filter</strong> je dal¹í
lazy sekvence, která obsahuje ty prvky vstupní sekvence, pro nì¾ predikát vrátí
pravdivostní hodnotu <strong>true</strong>. Vzhledem k&nbsp;tomu, ¾e jak
vstupem, tak i výstupem funkce <strong>filter</strong> je lazy sekvence, je i
samotná funkce <strong>filter</strong> &bdquo;líná&ldquo;, tj.&nbsp;vyhodnocuje
jednotlivé prvky a¾ ve chvíli, kdy je to skuteènì zapotøebí. Lze ji tedy pou¾ít
i pro nekoneèné lazy sekvence:</p>

<pre>
user=&gt; (filter odd? (range 0 10))
(1 3 5 7 9)
&nbsp;
user=&gt; (filter even? (range 0 10))
(0 2 4 6 8)
&nbsp;
(user=&gt; (defn less-than-10 [x] (&lt; x 10))
#'user/less-than-10
&nbsp;
user=&gt; (filter less-than-10 (range 0 1000))
(0 1 2 3 4 5 6 7 8 9)
</pre>

<p>Pou¾ití anonymní funkce:</p>

<pre>
user=&gt; (filter (fn [x] (&lt; x 10)) (range 0 1000))
(0 1 2 3 4 5 6 7 8 9)
</pre>

<p>Funkci <strong>apply</strong> lze pøedat dva a více parametrù. Prvním
parametrem je v¾dy nìjaká funkce a posledním parametrem je sekvence,
popø.&nbsp;kolekce (která je ov¹em té¾ sekvencí). V&nbsp;pøípadì, ¾e je funkci
<strong>apply</strong> pøedáno více parametrù, jsou tyto pova¾ovány za
parametry pøedávané funkce. Návratovou hodnotou funkce <strong>apply</strong>
je návratová hodnota funkce, které se pøedají v¹echny parametry, tudí¾ i prvky
sekvence. Jinými slovy to znamená, ¾e:</p>

<pre>
(apply fce a b c [d e f])
</pre>

<p>je toto¾né s&nbsp;voláním:</p>

<pre>
(fce a b c d e f)
</pre>

<p>Zajímavìj¹í v¹ak je, ¾e funkce <strong>apply</strong> doká¾e volání vybrané
funkce s&nbsp;pøedáním parametrù vytvoøit dynamicky, napøíklad takto:</p>

<pre>
(apply * (range 1 6))
</pre>

<p>Co¾ odpovídá:</p>

<pre>
(* 1 2 3 4 5 6)
</pre>

<p>Tudí¾ se jedná o výpoèet faktoriálu zapsaný nerekurzivnì.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Sekvence a paralelní výpoèty</h2>

<p>V&nbsp;perexu èlánku bylo napsáno, ¾e se dnes budeme zabývat i vyu¾itím
sekvencí (a tudí¾ i kolekcí) v&nbsp;souvislosti s&nbsp;paralelními výpoèty.
Hned na úvod je nutné øíci, ¾e programovací jazyk Clojure v&nbsp;souèasné verzi
nedoká¾e (a ani to evidentnì není jeho cílem) automaticky pøevádìt volání
funkcí pracujících se sekvencemi takovým zpùsobem, aby se vyu¾il bìh výpoètu ve
více vláknech. Pokud napøíklad budeme pomocí funkce <strong>map</strong>
aplikovat operaci <strong>inc</strong> na v¹echny prvky seznamu, bude tento
výpoèet provádìn v&nbsp;jednom vláknì prvek po prvku (i kdy¾ ve skuteènosti
dojde k&nbsp;&bdquo;línému&ldquo; vyhodnocení). Toto chování má dva dùvody
&ndash; první dùvod je ten, ¾e interpret je stále velmi jednoduchý a druhým
dùvodem (mo¾ná záva¾nìj¹ím) je fakt, ¾e samotné vytvoøení mnoha vláken a jejich
následná synchronizace pøi zpracování výsledkù mù¾e být v&nbsp;nìkterých
pøípadech nároènìj¹í na výpoèetní výkon, ne¾ samotný sekvenèní výpoèet. ®e se
nejedná o pouhou domnìnku si uká¾eme hned v&nbsp;následující kapitole.</p>

<p>Programovací jazyk Clojure ov¹em paralelní programování podporuje, a to hned
na nìkolika úrovních. Kromì takzvaných <i>agentù</i>, jejich¾ popisem se budeme
zabývat hned v&nbsp;následující èásti tohoto seriálu, Clojure programátorùm
nabízí i trojici funkcí èi maker nazvaných <strong>pmap</strong> (funkce),
<strong>pvalues</strong> (funkce zaji¹»ující vyhodnocení nìkolika forem
paralelnì) a <strong>pcalls</strong> (v&nbsp;souèasnosti makro, které doká¾e
zavolat nìkolik funkcí paralelnì). Dnes se budeme zabývat pøedev¹ím funkcí
<strong>pmap</strong>, proto¾e zpùsob jejího pou¾ití je velmi jednoduchý a
vlastnì ho ji¾ známe.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Funkce <strong>pmap</strong></h2>

<p>Funkce <strong>pmap</strong> se chová stejným zpùsobem jako ji¾ minule
popsaná funkce <strong>map</strong>. V&nbsp;nejjednodu¹¹ím pøípadì
<strong>map/pmap</strong> aplikuje nìjakou jinou funkci na v¹echny prvky nìjaké
sekvence a výsledkem této operace je nová (lazy) sekvence. Sice to mù¾e znít
slo¾itì, ale pou¾ití funkce <strong>map</strong> je ve skuteènosti dosti
jednoduché, proto¾e ji¾ víme, ¾e funkce jsou v&nbsp;Clojure plnohodnotným
datovým typem a tudí¾ je lze pøedat jako parametr jiné funkci.</p>

<pre>
(map inc [1 2 3 4 5 6 7 8])
(2 3 4 5 6 7 8 9)
</pre>

<p>Je¹tì zajímavìj¹í je aplikace nìjaké funkce s&nbsp;vìt¹í aritou ne¾ 1 na
dvojici, trojici atd. sekvencí:</p>

<pre>
(map * [1 2 3 4] [5 6 7 8])
(5 12 21 32)
</pre>

<p><strong>pmap</strong> vyhodnocuje jednotlivé prvky výsledné lazy sekvence
paralelnì, co¾ s&nbsp;sebou mù¾e pøiná¹et jak výhody, tak i nevýhody. Nespornou
výhodou je &bdquo;rozprostøení&ldquo; výpoètu do více vláken, ov¹em platíme za
to urèitou cenou, proto¾e jednotlivá vlákna se musí vytvoøit atd. Z&nbsp;tohoto
dùvodu se doporuèuje pou¾ívat funkci <strong>pmap</strong> pøedev¹ím
v&nbsp;tìch pøípadech, kdy jsou provádìné výpoèty skuteènì slo¾ité a/nebo
obsahují napøíklad nìjaké I/O operace atd. Ostatnì èasový rozdíl mezi funkcí
<strong>map</strong> a <strong>pmap</strong> lze snadno zjistit s&nbsp;vyu¾itím
funkce <strong>time</strong>, tedy jakýchsi stopek:</p>

<pre>
user=&gt; (time (dorun (map inc (range 1 1000)))) 
"Elapsed time: 8.483482 msecs"
nil
user=&gt; (time (dorun (pmap inc (range 1 1000))))
"Elapsed time: 246.6987 msecs"
nil
</pre>

<p>Dùvod, proè je zde <strong>pmap</strong> výraznì pomalej¹í ne¾
<strong>map</strong> je zøejmý &ndash; aby se provedl tak primitivní výpoèet,
jako je zvý¹ení hodnoty celého èísla o jednièku v&nbsp;samostatném vláknì, tak
re¾ie nutná pro vytvoøení tohoto vlákna pøevy¹uje jakýkoli benefit získaný
paralelním výpoètem.</p>

<p>Sami si mù¾ete vyzkou¹et, jak se situace zmìní v&nbsp;pøípadì
dlouhotrvajících výpoètù:</p>

<pre>
(defn fibonacci
    [n]
    (if (&lt; n 2)
        n
        (+ (fibonacci (- n 2)) (fibonacci (- n 1)))))
&nbsp;
(time (dorun (map fibonacci (range 100 150))))
&nbsp;
(time (dorun (pmap fibonacci (range 100 150))))
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Clojure home page<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/">http://java.sun.com/developer/technicalArticles/DynTypeLang/</a>
</li>

<li>JSR 223: Scripting for the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=223">http://jcp.org/en/jsr/detail?id=223</a>
</li>

<li>JSR 292: Supporting Dynamically Typed Languages on the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=292">http://jcp.org/en/jsr/detail?id=292</a>
</li>

<li>Java 7: A complete invokedynamic example<br />
<a href="http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html">http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html</a>
</li>

<li>InvokeDynamic: Actually Useful?<br />
<a href="http://blog.headius.com/2007/01/invokedynamic-actually-useful.html">http://blog.headius.com/2007/01/invokedynamic-actually-useful.html</a>
</li>

<li>A First Taste of InvokeDynamic<br />
<a href="http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html">http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html</a>
</li>

<li>Java 6 try/finally compilation without jsr/ret<br />
<a href="http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html">http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Root.cz: Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM<br />
<a href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/</a></a>
</li>

<li>Root.cz: JamVM aneb alternativa k HotSpotu nejenom pro embedded zaøízení a chytré telefony<br />
<a href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>FindBugs<br />
<a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a>
</li>

<li>GNU Classpath<br />
<a href="www.gnu.org/s/classpath/">www.gnu.org/s/classpath/</a></li>

<li>Java VMs Compared<br />
<a href="http://bugblogger.com/java-vms-compared-160/">http://bugblogger.com/java-vms-compared-160/</a>
</li>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Scala Programming Language<br />
<a href="http://www.scala-lang.org/">http://www.scala-lang.org/</a>
</li>

<li>Run Scala in Apache Tomcat in 10 minutes<br />
<a href="http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes">http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes</a>
</li>

<li>Fast Web Development With Scala<br />
<a href="http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html">http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html</a>
</li>

<li>Top five scripting languages on the JVM<br />
<a href="http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855">http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>CloseableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html">http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

