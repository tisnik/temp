<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - práce s texturami v knihovnì SDLJava</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - práce s texturami v knihovnì SDLJava</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o virtuálním stroji Javy si popí¹eme princip texturování implementovaný v knihovnì OpenGL i zpùsob práce s texturami (naètení, pou¾ití, specifikace vlastností) v SDLJava s vyu¾itím tøíd org.gljava.opengl.Texture a org.gljava.opengl.TextureFactory.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - práce s texturami v knihovnì SDLJava</a></p>
<p><a href="#k02">2. Nastavení parametrù textur v&nbsp;OpenGL</a></p>
<p><a href="#k03">3. Roz¹íøená podpora formátù textur</a></p>
<p><a href="#k04">4. Tøída <strong>TextureFactory</strong> a objekt typu <strong>Texture</strong></a></p>
<p><a href="#k05">5. Demonstraèní pøíklad <strong>SDLTest20</strong> &ndash; texturování a objekt typu <strong>Texture</strong></a></p>
<p><a href="#k06">6. Demonstraèní pøíklad <strong>SDLTest21</strong> &ndash; opakování textury</a></p>
<p><a href="#k07">7. Demonstraèní pøíklad <strong>SDLTest22</strong> &ndash; volba filtru pou¾itého pøi zvìt¹ování a zmen¹ování textury</a></p>
<p><a href="#k08">8. Repositáø se zdrojovými kódy v¹ech ètyø dne¹ních demonstraèních pøíkladù</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - práce s texturami v knihovnì SDLJava</h2>

<p>V&nbsp;dne¹ní èásti tohoto seriálu si uká¾eme, jak je mo¾né s&nbsp;vyu¾itím
knihovny <i>SDLJava</i> a s&nbsp;ní propojené knihovny <i>OpenGL</i> pou¾ívat
<i>texturování</i>. Texturováním (resp. ponìkud pøesnìji øeèeno <i>naná¹ením
textur</i>) je oznaèen princip obarvení povrchu zobrazovacích tìles rùznými
obrazci. Dùle¾ité pøitom je, ¾e se nijak nemìní geometrické vlastnosti tìles,
pouze se jiným zpùsobem zobrazuje jejich povrch. Obrazce, které se na povrch
tìles naná¹ejí, se nazývají <i>textury</i> (textures). Tyto textury jsou
vìt¹inou pøedstavovány plo¹nými obrázky (dvoudimenzionální textury), nìkteré
grafické systémy v¹ak podporují i vykreslování jednorozmìrných a dokonce
trojrozmìrných (objemových) textur.</p>

<p>Obrazce pro textury se mohou vytváøet nìkolika zpùsoby. Buï je mo¾né pou¾ít
klasické rastrové obrázky (vzniklé napøíklad namalováním, vyfocením nebo
naskenováním) nebo se textura mù¾e vytváøet pomocí rùzných algoritmù zalo¾ených
vìt¹inou na procedurálních a fraktálních technikách &ndash; tímto zpùsobem
vznikají takzvané <i>procedurální textury</i>. Procedurální textury lze pou¾ít
buï pro výpoèet rastrových obrázkù pøed vlastním vykreslováním (po výpoètu
obrázku se tato textura chová jako ka¾dý jiný rastrový obrázek se v¹emi
výhodami i nevýhodami) nebo se mù¾e výpoèet textur provádìt v&nbsp;reálném èase
a¾ pøi vykreslování, pøièem¾ se parametry výpoètu textury nastaví podle
aktuální velikosti a orientace plo¹ky, na kterou se textura naná¹í. Tuto druhou
mo¾nost v¹ak OpenGL pøímo nepodporuje, výpoèet procedurálních textur je tedy
nutné provádìt &bdquo;ruènì&ldquo;, popø.&nbsp;lze pou¾ít <i>shadery</i>,
tj.&nbsp;programy vykonávané pøímo na GPU.</p>

<p>V&nbsp;dal¹ím textu se budeme témìø výhradnì zabývat texturami
reprezentovanými rastrovými obrázky, nezávisle na tom, jakým zpùsobem vznikly.
I kdy¾ øeè bude pøevá¾nì o dvoudimenzionálních texturách (tedy <i>bitmapách</i>
a <i>pixmapách</i>), vìt¹ina zde popisovaných vlastností se vztahuje i na
jednorozmìrné a trojrozmìrné textury. Podobnì jako je <i>bitmapa</i> èi
<i>pixmapa</i> slo¾ená ze základních rastrových elementù (<i>pixelù</i>), tak
je textura slo¾ena z <i>texelù</i>. Pixel a texel mají stejné vlastnosti a
podobný èi dokonce ekvivalentní zpùsob ulo¾ení v&nbsp;pamìti. V&nbsp;dal¹ím
textu v¹ak budeme oba pojmy navzájem oddìlovat, tj.&nbsp;pixel je element
vykreslovaný na obrazovce, kde¾to texel je rastrový element (vìt¹inou)
dvourozmìrné textury. Texturování potom spoèívá v&nbsp;naná¹ení texelù na
vykreslovaný povrch.</p>

<p>Pou¾ití rastrových textur s&nbsp;sebou pøiná¹í samozøejmì své výhody i
nevýhody. Jak jsme si ji¾ øekli, pou¾ívá se technika texturování jako urèitá
náhrada pøi zobrazování slo¾itých povrchù tìles (zeï, omítka, døevo, kámen),
kdy se tento obecnì nehomogenní povrch nahradí plo¹kou s nanesenou texturou.
Zále¾í na vhodné volbì textury, velikosti objektu a nasvícení celé scény, zda
tato náhrada bude dostateèná, èi zda u¾ivatel uvidí vizuální chyby ve scénì.
Dal¹í pøedností texturování je, ¾e pokud u textur pou¾ijeme prùhlednost
(nazývanou také <i>alfa kanál</i>), je mo¾né vizuálnì zmìnit geometrii
pøedmìtù, proto¾e se pøedmìt mù¾e na nìkterých místech jevit jako dìravý.
Poznamenejme, ¾e pøi pou¾ití prùhlednosti je nutné programovì setøídit
prùhledné nebo poloprùhledné plo¹ky, jeliko¾ by v&nbsp;tomto pøípadì Z-buffer
(pamì» hloubky) nepracoval korektnì &ndash; i prùhledné texely by se
&bdquo;vykreslily&ldquo; a po¹kodily tak informaci o hloubce fragmentu ulo¾enou
v&nbsp;Z-bufferu.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Nastavení parametrù textur v&nbsp;OpenGL</h2>

<p>V&nbsp;OpenGL lze také zvolit rùzné filtrace textur, re¾imy mapování textur
na plo¹ky, multitexturování a dal¹í grafické efekty, které si dále probereme.
Musíme si v¹ak uvìdomit, ¾e pokud pou¾ijeme nìkterý grafický efekt, který není
grafickým akcelerátorem podporován, dojde k&nbsp;výpoètùm pomocí hlavního
procesoru poèítaèe, co¾ znaènì zpomaluje celý systém. Proto je nejprve vhodné
zjistit, které efekty jsou na grafickém akcelerátoru podporovány a pøípadnì dát
u¾ivateli na¹í aplikace na výbìr mezi kvalitou a rychlostí zobrazení
(s&nbsp;tìmito omezeními se dnes u¾ prakticky nesetkáme).</p>

<p>Parametry textury (tj.&nbsp;napøíklad zpùsob, jakým je textura mapována na
povrch vykreslovaného tìlesa) lze nastavit voláním metody:</p>

<pre>
org.gljava.opengl.GL:
void <strong>glTexParameterf</strong>(
    long target,
    long pname,
    float param
);
</pre>

<p>nebo metody:</p>

<pre>
org.gljava.opengl.GL:
void <strong>glTexParameteri</strong>(
    long target,
    long pname,
    int param
);
</pre>

<p>Alternativnì lze také zavolat metody, které jako svùj poslední parametr
akceptují místo skalární hodnoty pole hodnot, které je v¹ak v&nbsp;pøípadì
SDLJava reprezentováno bufferem:</p>

<pre>
org.gljava.opengl.GL:
void <strong>glTexParameterfv</strong>(
    long target,
    long pname,
    java.nio.FloatBuffer params
);
</pre>

<pre>
void <strong>glTexParameteriv</strong>(
    long target,
    long pname,
    java.nio.IntBuffer params
);
</pre>

<p>První parametr (<i>target</i>) mù¾e podle zvolené dimenze textury nabývat
hodnot <i>GL.GL_TEXTURE_1D</i> (jednodimenzionální texura, tj.&nbsp;barevný
pøechod) nebo <i>GL.GL_TEXTURE_2D</i> (nejbì¾nìj¹í, rastrová textura). Hodnoty
parametrù dal¹ích dvou parametrù <i>pname</i> a <i>value</i> jsou uvedeny
v&nbsp;následujícím seznamu:</p>

<ul>

<li>Parametr <i>GL.GL_TEXTURE_WRAP_S</i>:<br> tímto parametrem specifikujeme,
zda se má pøi pøekroèení rozsahu texturovací souøadnice ve smìru osy
<strong>s</strong> provést opakování motivu na textuøe
(<i>value=GL.GL_REPEAT</i>) nebo prota¾ení první èi poslední hodnoty
(<i>value=GL.GL_CLAMP</i>). Opakování motivu na textuøe je vhodné pou¾ít
v&nbsp;pøípadech, ¾e zobrazujeme rùzné na sebe navazující motivy, napøíklad
cihlové zdi, podlahy apod. Prota¾ením textury lze v&nbsp;nìkterých pøípadech
zamezit vizuálním artefaktùm, které by se mohly objevit pøi napojování textur.
Pøekroèení rozsahu není tedy v&nbsp;¾ádném pøípadì chybou, vyvoláme ho
napøíklad pøíkazem <i>GL.glTexCoord2f(2.0, 0.5)</i>.</li>

<li>Parametr <i>GL.GL_TEXTURE_WRAP_T</i>:<br> tento parametr má podobný význam
jako parametr pøedchozí s&nbsp;tím rozdílem, ¾e se místo na souøadnici ve smìru
osy <strong>s</strong> vztahuje na souøadnici ve smìru osy <strong>t</strong>.
U 1D textur nemá hodnota tohoto parametru vliv na zobrazení textury, pou¾itelný
je pouze u 2D textur. Opakování resp.&nbsp;prota¾ení textury lze pro souøadnice
ve v¹ech smìrech nastavovat nezávisle.</li>

<li>Parametr <i>GL.GL_TEXTURE_MIN_FILTER</i>:<br> tímto parametrem je mo¾né
zvolit filtr pou¾itý pøi zmen¹ování textury, tj.&nbsp;tehdy, jestli¾e na plochu
jednoho vykreslovaného pixelu musíme pou¾ít barvy nìkolika sousedních texelù.
Nejjednodu¹¹í a nejrychlej¹í filtr se volí hodnotou <i>GL.GL_NEAREST</i>. U
tohoto filtru se barva vykreslovaného pixelu vypoète z&nbsp;barvy texelu, jeho¾
souøadnice nejpøesnìji odpovídají zadaným souøadnicím do textury. Ponìkud
sofistikovanìj¹í filtr se zadává hodnotou <i>GL.GL_LINEAR</i>, kdy se barva
vykreslovaného pixelu spoèítá pomocí bilineární interpolace z&nbsp;barev
sousedních texelù. Dal¹í ètyøi filtry (<i>GL.GL_NEAREST_MIPMAP_NEAREST</i>,
<i>GL.GL_NEAREST_MIPMAP_LINEAR</i>, <i>GL.GL_LINEAR_MIPMAP_NEAREST</i> a
<i>GL.GL_LINEAR_MIPMAP_LINEAR</i>) vyu¾ívají takzvané <i>mipmapy</i>, jejich¾
význam si vysvìtlíme pøí¹tì.</li>

<li>Parametr <i>GL.GL_TEXTURE_MAX_FILTER</i>:<br> tímto parametrem se volí
filtr pou¾itý pøi zvìt¹ování textury, tj.&nbsp;v&nbsp;pøípadì, ¾e vykreslovaný
pixel obsahuje pouze malou plochu texelu. Mo¾né hodnoty jsou
<i>GL.GL_NEAREST</i> (pou¾ije se nejbli¾¹í texel) nebo <i>GL.GL_LINEAR</i>
(pou¾ije se lineární interpolace mezi barvami sousedních texelù).</li>

<li>Parametr <i>GL.GL_TEXTURE_BORDER_COLOR</i>:<br> tímto parametrem lze zvolit
barvu rámeèku okolo textury (pokud je rámeèek pou¾it, tj.&nbsp;pokud má
nenulovou ¹íøku). V&nbsp;pøípadì zadávání barvy je nutné pou¾ít pøíkazy
<i>GL.glTexParameteriv()</i> resp.&nbsp;<i>GL.glTexParameterfv()</i>, proto¾e
barva se zadává jako vektor (pole, buffer) ètyø slo¾ek R, G, B a A. Implicitní
barva rámeèku je (0, 0, 0, 0), tedy èerná.</li>

</ul>



<p><a name="k03"></a></p>
<h2 id="k03">3. Roz¹íøená podpora formátù textur</h2>

<p>Kromì základních formátù textur je mo¾né pou¾ívat v&nbsp;OpenGL verze 1.2 a
vy¹¹ích i dal¹í roz¹íøené formáty. Jaká výhoda plyne z&nbsp;pou¾ití takových
formátù? Pøedev¹ím jde o to, ¾e pou¾itím nìkterých formátù s&nbsp;malou nebo
dostateènou bitovou hloubkou mù¾eme u¹etøit pamì» alokovanou pro textury.
Druhou výhodou je mo¾nost pou¾ít textury naètené z&nbsp;rùzných externích
souborù, které mají mnohdy exotický formát. V&nbsp;následující tabulce budou
ukázány roz¹íøené formáty textur spolu se základním formátem a typem dat pro
ka¾dou barvovou slo¾ku:</p>

<table>
<tr><th>Roz¹íøený formát</th><th>Základní formát</th><th>Poèet bitù R</th><th>Poèet bitù G</th><th>Poèet bitù B</th><th>Poèet bitù A</th><th>Luminance (úroveò bílé)</th><th>Intenzita (úroveò bílé=alpha)</th></tr>
<tr><td>GL_ALPHA4             </td><td>GL_ALPHA          </td><td> &nbsp; </td><td> &nbsp; </td> <td> &nbsp; </td> <td>  4     </td><td> &nbsp; </td><td> &nbsp; </td></tr>
<tr><td>GL_ALPHA8             </td><td>GL_ALPHA          </td><td> &nbsp; </td><td> &nbsp; </td> <td> &nbsp; </td> <td>  8     </td><td> &nbsp; </td><td> &nbsp; </td></tr>
<tr><td>GL_ALPHA12            </td><td>GL_ALPHA          </td><td> &nbsp; </td><td> &nbsp; </td> <td> &nbsp; </td> <td> 12     </td><td> &nbsp; </td><td> &nbsp; </td></tr>
<tr><td>GL_ALPHA16            </td><td>GL_ALPHA          </td><td> &nbsp; </td><td> &nbsp; </td> <td> &nbsp; </td> <td> 16     </td><td> &nbsp; </td><td> &nbsp; </td></tr>
<tr><td>GL_LUMINANCE4         </td><td>GL_LUMINANCE      </td><td> &nbsp; </td><td> &nbsp; </td> <td> &nbsp; </td> <td> &nbsp; </td><td>  4     </td><td> &nbsp; </td></tr>
<tr><td>GL_LUMINANCE8         </td><td>GL_LUMINANCE      </td><td> &nbsp; </td><td> &nbsp; </td> <td> &nbsp; </td> <td> &nbsp; </td><td>  8     </td><td> &nbsp; </td></tr>
<tr><td>GL_LUMINANCE12        </td><td>GL_LUMINANCE      </td><td> &nbsp; </td><td> &nbsp; </td> <td> &nbsp; </td> <td> &nbsp; </td><td> 12     </td><td> &nbsp; </td></tr>
<tr><td>GL_LUMINANCE16        </td><td>GL_LUMINANCE      </td><td> &nbsp; </td><td> &nbsp; </td> <td> &nbsp; </td> <td> &nbsp; </td><td> 16     </td><td> &nbsp; </td></tr>
<tr><td>GL_LUMINANCE4_ALPHA4  </td><td>GL_LUMINANCE_ALPHA</td><td> &nbsp; </td><td> &nbsp; </td> <td> &nbsp; </td> <td>  4     </td><td>  4     </td><td> &nbsp; </td></tr>
<tr><td>GL_LUMINANCE6_ALPHA2  </td><td>GL_LUMINANCE_ALPHA</td><td> &nbsp; </td><td> &nbsp; </td> <td> &nbsp; </td> <td>  2     </td><td>  6     </td><td> &nbsp; </td></tr>
<tr><td>GL_LUMINANCE8_ALPHA8  </td><td>GL_LUMINANCE_ALPHA</td><td> &nbsp; </td><td> &nbsp; </td> <td> &nbsp; </td> <td>  8     </td><td>  8     </td><td> &nbsp; </td></tr>
<tr><td>GL_LUMINANCE12_ALPHA4 </td><td>GL_LUMINANCE_ALPHA</td><td> &nbsp; </td><td> &nbsp; </td> <td> &nbsp; </td> <td>  4     </td><td> 12     </td><td> &nbsp; </td></tr>
<tr><td>GL_LUMINANCE12_ALPHA12</td><td>GL_LUMINANCE_ALPHA</td><td> &nbsp; </td><td> &nbsp; </td> <td> &nbsp; </td> <td> 12     </td><td> 12     </td><td> &nbsp; </td></tr>
<tr><td>GL_LUMINANCE16_ALPHA16</td><td>GL_LUMINANCE_ALPHA</td><td> &nbsp; </td><td> &nbsp; </td> <td> &nbsp; </td> <td> 16     </td><td> 16     </td><td> &nbsp; </td></tr>
<tr><td>GL_INTENSITY4         </td><td>GL_INTENSITY      </td><td> &nbsp; </td><td> &nbsp; </td> <td> &nbsp; </td> <td> &nbsp; </td><td> &nbsp; </td><td>  4     </td></tr>
<tr><td>GL_INTENSITY8         </td><td>GL_INTENSITY      </td><td> &nbsp; </td><td> &nbsp; </td> <td> &nbsp; </td> <td> &nbsp; </td><td> &nbsp; </td><td>  8     </td></tr>
<tr><td>GL_INTENSITY12        </td><td>GL_INTENSITY      </td><td> &nbsp; </td><td> &nbsp; </td> <td> &nbsp; </td> <td> &nbsp; </td><td> &nbsp; </td><td> 12     </td></tr>
<tr><td>GL_INTENSITY16        </td><td>GL_INTENSITY      </td><td> &nbsp; </td><td> &nbsp; </td> <td> &nbsp; </td> <td> &nbsp; </td><td> &nbsp; </td><td> 16     </td></tr>
<tr><td>GL_R3_G3_B2           </td><td>GL_RGB            </td><td>  3     </td><td>  3     </td> <td>  2     </td> <td> &nbsp; </td><td> &nbsp; </td><td> &nbsp; </td></tr>
<tr><td>GL_RGB4               </td><td>GL_RGB            </td><td>  4     </td><td>  4     </td> <td>  4     </td> <td> &nbsp; </td><td> &nbsp; </td><td> &nbsp; </td></tr>
<tr><td>GL_RGB5               </td><td>GL_RGB            </td><td>  5     </td><td>  5     </td> <td>  5     </td> <td> &nbsp; </td><td> &nbsp; </td><td> &nbsp; </td></tr>
<tr><td>GL_RGB8               </td><td>GL_RGB            </td><td>  8     </td><td>  8     </td> <td>  8     </td> <td> &nbsp; </td><td> &nbsp; </td><td> &nbsp; </td></tr>
<tr><td>GL_RGB10              </td><td>GL_RGB            </td><td> 10     </td><td> 10     </td> <td> 10     </td> <td> &nbsp; </td><td> &nbsp; </td><td> &nbsp; </td></tr>
<tr><td>GL_RGB12              </td><td>GL_RGB            </td><td> 12     </td><td> 12     </td> <td> 12     </td> <td> &nbsp; </td><td> &nbsp; </td><td> &nbsp; </td></tr>
<tr><td>GL_RGB16              </td><td>GL_RGB            </td><td> 16     </td><td> 16     </td> <td> 16     </td> <td> &nbsp; </td><td> &nbsp; </td><td> &nbsp; </td></tr>
<tr><td>GL_RGBA2              </td><td>GL_RGBA           </td><td>  2     </td><td>  2     </td> <td>  2     </td> <td>  2     </td><td> &nbsp; </td><td> &nbsp; </td></tr>
<tr><td>GL_RGBA4              </td><td>GL_RGBA           </td><td>  4     </td><td>  4     </td> <td>  4     </td> <td>  4     </td><td> &nbsp; </td><td> &nbsp; </td></tr>
<tr><td>GL_RGB5_A1            </td><td>GL_RGBA           </td><td>  5     </td><td>  5     </td> <td>  5     </td> <td>  1     </td><td> &nbsp; </td><td> &nbsp; </td></tr>
<tr><td>GL_RGBA8              </td><td>GL_RGBA           </td><td>  8     </td><td>  8     </td> <td>  8     </td> <td>  8     </td><td> &nbsp; </td><td> &nbsp; </td></tr>
<tr><td>GL_RGB10_A2           </td><td>GL_RGBA           </td><td> 10     </td><td> 10     </td> <td> 10     </td> <td>  2     </td><td> &nbsp; </td><td> &nbsp; </td></tr>
<tr><td>GL_RGBA12             </td><td>GL_RGBA           </td><td> 12     </td><td> 12     </td> <td> 12     </td> <td> 12     </td><td> &nbsp; </td><td> &nbsp; </td></tr>
<tr><td>GL_RGBA16             </td><td>GL_RGBA           </td><td> 16     </td><td> 16     </td> <td> 16     </td> <td> 16     </td><td> &nbsp; </td><td> &nbsp; </td></tr>
</table>

<p>Pro ¹etøení pamìtí jsou zajímavé napøíklad formáty <i>GL_R3_G3_B2</i>, kdy
pamì» pro jeden texel zabírá pouze jeden byte, nebo <i>GL_RGB5_A1</i>, kde
ka¾dá barvová slo¾ka zabírá 5 bitù (celkem je tedy pro barvu vyhrazeno 15 bitù)
a alfa slo¾ka jeden bit (rozli¹ujeme tedy pouze prùhlednost èi neprùhlednost
texelu).</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Tøída <strong>TextureFactory</strong> a objekt typu <strong>Texture</strong></h2>

<p>Grafická knihovna OpenGL neobsahuje ¾ádné funkce pro naètení textury ze
souboru èi ke konverzím mezi rùznými formáty pixelù/texelù. Programátoøi
vyu¾ívající pouze OpenGL tedy musí pøíslu¹ný programový kód napsat ruènì, ov¹em
vzhledem k&nbsp;tomu, ¾e se jedná stále o stejné operace, existuje
v&nbsp;knihovnì <i>SDLJava</i> dvojice tøíd, které doká¾ou texturu naèíst a
posléze s&nbsp;ní jednodu¹e pracovat. První z&nbsp;tìchto tøíd se jmenuje
<strong>org.gljava.opengl.TextureFactory</strong> a najdeme v&nbsp;ní jak
statickou metodu <strong>getFactory()</strong> vracející instanci této tøídy
(konstruktor není viditelný), tak i trojici metod
<strong>loadTexture()</strong> pro naètení textury z&nbsp;externího souboru
popø.&nbsp;z&nbsp;obrázku typu BufferedImage (co¾ se mù¾e hodit v&nbsp;pøípadì,
¾e je textura napøíklad vytvoøena procedurálnì):</p>

<table>
<tr><th>#</th><th>Návratový typ</th><th>Metoda</th><th>Popis</th></tr>
<tr><td>1</td><td>TextureFactory</td><td>getFactory()</td><td>získání instance tøídy TextureFactory</td></tr>
<tr><td>2</td><td>Texture</td><td>loadTexture(GL gl, java.lang.String path)</td><td>naètení textury ze souboru specifikovaného jménem</td></tr>
<tr><td>3</td><td>Texture</td><td>loadTexture(GL gl, java.net.URL url)</td><td>naètení textury ze souboru/zdroje specifikovaného URL</td></tr>
<tr><td>4</td><td>Texture</td><td>loadTexture(GL gl, java.awt.image.BufferedImage bufferedImage, int target, int dstPixelFormat, int minFilter, int magFilter)</td><td>naètení textury z&nbsp;obrázku typu BufferedImage</td></tr>
</table>

<p>Návratovou hodnotou metod <strong>TextureFactory.loadTexture()</strong> je
instance tøídy typu <strong>org.gljava.opengl.Texture</strong>, která
pøedstavuje texturu pou¾itelnou pøi vykreslování objektù. Velmi dùle¾itou
metodou, kterou musíme pøi vykreslování pou¾ít, je
<strong>Texture.bind()</strong> slou¾ící pro navázání textury na kontext
OpenGL. Dále tato tøída obsahuje metody pro zji¹tìní rozmìrù textury,
popø.&nbsp;pro nastavení tìchto rozmìrù:</p>

<table>
<tr><th>#</th><th>Návratový typ</th><th>Metoda</th><th>Popis</th></tr>
<tr><td>1</td><td>void </td><td>bind(GL gl)     </td><td>nejdùle¾itìj¹í metoda, navázání textury na kontext OpenGL</td></tr>
<tr><td>2</td><td>float</td><td>getWidth()      </td><td>zji¹tìní skuteèné ¹íøky textury</td></tr>
<tr><td>3</td><td>float</td><td>getHeight()     </td><td>zji¹tìní skuteèné vý¹ky textury</td></tr>
<tr><td>4</td><td>int  </td><td>getImageWidth() </td><td>zji¹tìní ¹íøky pixmapy (v&nbsp;pixelech)</td></tr>
<tr><td>5</td><td>int  </td><td>getImageHeight()</td><td>zji¹tìní vý¹ky pixmapy (v&nbsp;pixelech)</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. Demonstraèní pøíklad <strong>SDLTest20</strong> &ndash; texturování a objekt typu <strong>Texture</strong></h2>

<p>V&nbsp;dne¹ním prvním demonstraèním pøíkladu nazvaném
<strong>SDLTest20</strong> je ukázána základní práce s&nbsp;texturami. Ihned po
inicializaci knihovny <i>SDLJava</i>, nastavení grafického re¾imu a získání
kontextu OpenGL je naèten rastrový obrázek &bdquo;xscorch.bmp&ldquo;, který si
mù¾ete stáhnout <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/raw-file/6fe0d3a6edeb/sdljava/img/xscorch.bmp">z&nbsp;této
adresy</a>. Tento obrázek je reprezentován instancí tøídy
<strong>Texture</strong>, která bude následnì pou¾ita pøi vykreslování:</p>

<pre>
<i>// nacteni textury</i>
Texture texture = TextureFactory.getFactory().loadTexture(gl, "xscorch.bmp");
</pre>

<p>Následnì je nutné nastavit základní parametry texturování, co¾ jsou operace
provádìné pøes knihovnu OpenGL. Texturování je nejprve potøeba povolit a poté
nastavit re¾im opakování textury, filtry pou¾ité pøi zvìt¹ování èi zmen¹ování
textury a re¾im vykreslování pøi pou¾ití perspektivní projekce (resp.&nbsp;pøi
urèení ètvrté souøadnice vrcholù):</p>

<pre>
<i>// povoleni prace s texturami</i>
gl.glEnable(gl.GL_TEXTURE_2D);
&nbsp;
<i>// opakovani textury</i>
gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_WRAP_S, gl.GL_REPEAT);
gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_WRAP_T, gl.GL_REPEAT);
&nbsp;
<i>// volba filtru</i>
gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MAG_FILTER, gl.GL_NEAREST);
gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MIN_FILTER, gl.GL_NEAREST);
&nbsp;
<i>// vylepseni zobrazovani v pripade pouziti perspektivni projekce</i>
gl.glHint(gl.GL_PERSPECTIVE_CORRECTION_HINT, gl.GL_NICEST);
</pre>

<p>Pøi vykreslování je zapotøebí nejdøíve urèit, která textura se má pou¾ít,
co¾ se provede navázáním textury na kontext OpenGL (zmìní se tím vnitøní stav
OpenGL):</p>

<pre>
texture.bind(gl);
</pre>

<p>Pøi vykreslování objektu je nutné u ka¾dého vertexu urèit i souøadnice
v&nbsp;prostoru textury (u-v souøadnice):</p>

<pre>
<i>// vykresleni ctyruhelniku</i>
gl.glBegin(gl.GL_QUADS);
    gl.glTexCoord2f(0.0f, 0.0f);
    gl.glVertex2i(200, 100);
    gl.glTexCoord2f(1.0f, 0.0f);
    gl.glVertex2i(600, 100);
    gl.glTexCoord2f(1.0f, 1.0f);
    gl.glVertex2i(600, 300);
    gl.glTexCoord2f(0.0f, 1.0f);
    gl.glVertex2i(200, 600);
gl.glEnd();
</pre>

<p>Následuje úplný výpis programového kódu tohoto demonstraèního pøíkladu:</p>

<pre>
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
&nbsp;
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.video.SDLPixelFormat;
import sdljava.video.SDLSurface;
import sdljava.video.SDLVideo;
&nbsp;
import org.gljava.opengl.GL;
import org.gljava.opengl.Texture;
import org.gljava.opengl.TextureFactory;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Dvacaty demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> *</i>
<i> * Texturovani a objekt typu Texture.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>SDLTest20</strong> {
&nbsp;
    <i>/**</i>
    <i> * Horizontalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_WIDTH</strong> = 200;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_HEIGHT</strong> = 200;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka vybraneho grafickeho rezimu.</i>
    <i> * (0 znamena automaticky vyber, ovsem lze samozrejme pouzit</i>
    <i> * i hodnoty 8, 16, 24 ci 32, podle vlastnosti graficke karty)</i>
    <i> */</i>
    private static final int <strong>GFX_BPP</strong> = 0;
&nbsp;
    <i>/**</i>
    <i> * Inicializace grafickeho rezimu ci otevreni okna pro vykreslovani.</i>
    <i> */</i>
    private static SDLSurface <strong>initVideo</strong>() throws SDLException {
        final long flags = SDLVideo.SDL_OPENGL | SDLVideo.SDL_DOUBLEBUF;
        return SDLVideo.setVideoMode(GFX_WIDTH, GFX_HEIGHT, GFX_BPP, flags);
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni transformacnich matic a barvy pozadi framebufferu.</i>
    <i> */</i>
    private static void <strong>initScene</strong>(GL gl, int width, int height) {
        <i>// nastaveni projekcni matice</i>
        gl.glMatrixMode(gl.GL_PROJECTION);
&nbsp;
        <i>// jednotkova matice</i>
        gl.glLoadIdentity();
&nbsp;
        <i>// mapovani abstraktnich souradnic do souradnic okna ci cele obrazovky</i>
        gl.glOrtho(0, width, height, 0, -1, 1);
&nbsp;
        <i>// nastaveni modelview matice</i>
        gl.glMatrixMode(gl.GL_MODELVIEW);
        gl.glLoadIdentity();
&nbsp;
        <i>// viditelna oblast</i>
        gl.glViewport(0, 0, width, height);
&nbsp;
        <i>// vypnuti pameti hloubky pri vykreslovani</i>
        gl.glDisable(gl.GL_DEPTH_TEST);
&nbsp;
        <i>// povoleni prace s texturami</i>
        gl.glEnable(gl.GL_TEXTURE_2D);
&nbsp;
        <i>// opakovani textury</i>
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_WRAP_S, gl.GL_REPEAT);
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_WRAP_T, gl.GL_REPEAT);
&nbsp;
        <i>// volba filtru</i>
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MAG_FILTER, gl.GL_NEAREST);
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MIN_FILTER, gl.GL_NEAREST);
&nbsp;
        <i>// vylepseni zobrazovani v pripade pouziti perspektivni projekce</i>
        gl.glHint(gl.GL_PERSPECTIVE_CORRECTION_HINT, gl.GL_NICEST);
&nbsp;
        <i>// barva pozadi framebufferu pro volani glClear()</i>
        gl.glClearColor (0.0f, 0.0f, 0.0f, 0.0f);
    }
&nbsp;
    <i>/**</i>
    <i> * Vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL.</i>
    <i> */</i>
    private static void <strong>drawScene</strong>(GL gl, Texture texture) {
&nbsp;
        <i>// vymazani framebufferu</i>
        gl.glClear(gl.GL_COLOR_BUFFER_BIT);
&nbsp;
        texture.bind(gl);
&nbsp;
        <i>// vykresleni ctyruhelniku</i>
        gl.glBegin(gl.GL_QUADS);
            gl.glTexCoord2f(0.0f, 0.0f);
            gl.glVertex2i(200, 100);
            gl.glTexCoord2f(1.0f, 0.0f);
            gl.glVertex2i(600, 100);
            gl.glTexCoord2f(1.0f, 1.0f);
            gl.glVertex2i(600, 300);
            gl.glTexCoord2f(0.0f, 1.0f);
            gl.glVertex2i(200, 600);
        gl.glEnd();
&nbsp;
        gl.glFlush();       <i>// provedeni a vykresleni vsech zmen</i>
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni osmeho demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace video subsystemu knihovny SDL</i>
            SDLMain.init(SDLMain.SDL_INIT_VIDEO);
&nbsp;
            <i>// inicializace grafickeho rezimu ci otevreni okna pro vykreslovani</i>
            SDLSurface screen = initVideo();
&nbsp;
            <i>// inicializace celoobrazovkoveho grafickeho rezimu</i>
            GL gl = screen.getGL();
&nbsp;
            <i>// nastaveni transformacnich matic a barvy pozadi framebufferu</i>
            initScene(gl, GFX_WIDTH, GFX_HEIGHT);
&nbsp;
            <i>// nacteni textury</i>
            Texture texture = TextureFactory.getFactory().loadTexture(gl, "xscorch.bmp");
&nbsp;
            <i>// vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL</i>
            drawScene(gl, texture);
&nbsp;
            <i>// prepnuti predniho a zadniho bufferu</i>
            screen.glSwapBuffers();
&nbsp;
            <i>// ukonceni cele aplikace po peti sekundach</i>
            Thread.sleep(5000);
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
        <i>// zobrazit ziskane informace</i>
    }
&nbsp;
}
</pre>

<p>Skript pro pøeklad na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest20.java
</pre>

<p>Dávkový soubor pro pøeklad na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest20.java
</pre>

<p>Skript pro spu¹tìní na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
java -cp .:$SDL_JAVA_LIBS/sdljava.jar -Djava.library.path=$SDL_JAVA_LIBS SDLTest20
</pre>

<p>Dávkový soubor pro spu¹tìní na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest20
</pre>

<img src="http://i.iinfo.cz/images/437/11701.png" class="image-162010" width="600" height="600" alt="&#160;" />
<p><i>Obrázek 1: Scéna vykreslená po spu¹tìní demonstraèního pøíkladu
<strong>SDLTest20</strong>.</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Demonstraèní pøíklad <strong>SDLTest21</strong> &ndash; opakování textury</h2>

<p>Dne¹ní druhý demonstraèní pøíklad má název <strong>SDLTest21</strong> a je
na nìm ukázán efekt opakování textury v&nbsp;pøípadì, ¾e souøadnice
v&nbsp;prostoru textury pøekraèují interval 0.0 a¾ 1.0. Nastavení grafického
re¾imu, inicializace OpenGL se získáním kontextu OpenGL i naètení textury
probíhá zcela stejným zpùsobem, jako tomu bylo v&nbsp;pøedchozím pøíkladu.
Stejné je i nastavení parametrù texturování:</p>

<pre>
<i>// povoleni prace s texturami</i>
gl.glEnable(gl.GL_TEXTURE_2D);
&nbsp;
<i>// opakovani textury</i>
gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_WRAP_S, gl.GL_REPEAT);
gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_WRAP_T, gl.GL_REPEAT);
&nbsp;
<i>// volba filtru</i>
gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MAG_FILTER, gl.GL_NEAREST);
gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MIN_FILTER, gl.GL_NEAREST);
&nbsp;
<i>// vylepseni zobrazovani v pripade pouziti perspektivni projekce</i>
gl.glHint(gl.GL_PERSPECTIVE_CORRECTION_HINT, gl.GL_NICEST);
</pre>

<p>Pøi vlastním vykreslování jsou v¹ak zadány souøadnice v&nbsp;prostoru
textury, které v&nbsp;nìkterých pøípadech le¾í mimo rozsah 0.0 a¾ 1.0, co¾
znamená, ¾e grafický akcelerátor bude texturu naná¹et na objekt opakovanì
(jakoby se jednalo o dla¾dice). V&nbsp;následujícím úryvku kódu si v¹imnìte
parametrù pøedávaných do metody <strong>gl.glTexCoord2f()</strong>:</p>

<pre>
<i>// vykresleni ctyruhelniku</i>
gl.glBegin(gl.GL_QUADS);
    gl.glTexCoord2f(0.0f, 0.0f);
    gl.glVertex2i(200, 100);
    gl.glTexCoord2f(3.0f, 0.0f);
    gl.glVertex2i(600, 100);
    gl.glTexCoord2f(1.0f, 3.0f);
    gl.glVertex2i(600, 300);
    gl.glTexCoord2f(-1.0f, 1.0f);
    gl.glVertex2i(100, 600);
gl.glEnd();
</pre>

<p>Úplný výpis demonstraèního pøíkladu <strong>SDLTest21</strong> je zobrazen
pod tímto odstavcem:</p>

<pre>
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
&nbsp;
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.video.SDLPixelFormat;
import sdljava.video.SDLSurface;
import sdljava.video.SDLVideo;
&nbsp;
import org.gljava.opengl.GL;
import org.gljava.opengl.Texture;
import org.gljava.opengl.TextureFactory;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Dvacaty prvni demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> *</i>
<i> * Texturovani a objekt typu Texture - opakovani textury.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>SDLTest21</strong> {
&nbsp;
    <i>/**</i>
    <i> * Horizontalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_WIDTH</strong> = 200;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_HEIGHT</strong> = 200;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka vybraneho grafickeho rezimu.</i>
    <i> * (0 znamena automaticky vyber, ovsem lze samozrejme pouzit</i>
    <i> * i hodnoty 8, 16, 24 ci 32, podle vlastnosti graficke karty)</i>
    <i> */</i>
    private static final int <strong>GFX_BPP</strong> = 0;
&nbsp;
    <i>/**</i>
    <i> * Inicializace grafickeho rezimu ci otevreni okna pro vykreslovani.</i>
    <i> */</i>
    private static SDLSurface <strong>initVideo</strong>() throws SDLException {
        final long flags = SDLVideo.SDL_OPENGL | SDLVideo.SDL_DOUBLEBUF;
        return SDLVideo.setVideoMode(GFX_WIDTH, GFX_HEIGHT, GFX_BPP, flags);
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni transformacnich matic a barvy pozadi framebufferu.</i>
    <i> */</i>
    private static void <strong>initScene</strong>(GL gl, int width, int height) {
        <i>// nastaveni projekcni matice</i>
        gl.glMatrixMode(gl.GL_PROJECTION);
&nbsp;
        <i>// jednotkova matice</i>
        gl.glLoadIdentity();
&nbsp;
        <i>// mapovani abstraktnich souradnic do souradnic okna ci cele obrazovky</i>
        gl.glOrtho(0, width, height, 0, -1, 1);
&nbsp;
        <i>// nastaveni modelview matice</i>
        gl.glMatrixMode(gl.GL_MODELVIEW);
        gl.glLoadIdentity();
&nbsp;
        <i>// viditelna oblast</i>
        gl.glViewport(0, 0, width, height);
&nbsp;
        <i>// vypnuti pameti hloubky pri vykreslovani</i>
        gl.glDisable(gl.GL_DEPTH_TEST);
&nbsp;
        <i>// povoleni prace s texturami</i>
        gl.glEnable(gl.GL_TEXTURE_2D);
&nbsp;
        <i>// opakovani textury</i>
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_WRAP_S, gl.GL_REPEAT);
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_WRAP_T, gl.GL_REPEAT);
&nbsp;
        <i>// volba filtru</i>
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MAG_FILTER, gl.GL_NEAREST);
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MIN_FILTER, gl.GL_NEAREST);
&nbsp;
        <i>// vylepseni zobrazovani v pripade pouziti perspektivni projekce</i>
        gl.glHint(gl.GL_PERSPECTIVE_CORRECTION_HINT, gl.GL_NICEST);
&nbsp;
        <i>// barva pozadi framebufferu pro volani glClear()</i>
        gl.glClearColor (0.0f, 0.0f, 0.0f, 0.0f);
    }
&nbsp;
    <i>/**</i>
    <i> * Vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL.</i>
    <i> */</i>
    private static void <strong>drawScene</strong>(GL gl, Texture texture) {
&nbsp;
        <i>// vymazani framebufferu</i>
        gl.glClear(gl.GL_COLOR_BUFFER_BIT);
&nbsp;
        texture.bind(gl);
&nbsp;
        <i>// vykresleni ctyruhelniku</i>
        gl.glBegin(gl.GL_QUADS);
            gl.glTexCoord2f(0.0f, 0.0f);
            gl.glVertex2i(200, 100);
            gl.glTexCoord2f(3.0f, 0.0f);
            gl.glVertex2i(600, 100);
            gl.glTexCoord2f(1.0f, 3.0f);
            gl.glVertex2i(600, 300);
            gl.glTexCoord2f(-1.0f, 1.0f);
            gl.glVertex2i(100, 600);
        gl.glEnd();
&nbsp;
        gl.glFlush();                                        <i>// provedeni a vykresleni vsech zmen</i>
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni osmeho demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace video subsystemu knihovny SDL</i>
            SDLMain.init(SDLMain.SDL_INIT_VIDEO);
&nbsp;
            <i>// inicializace grafickeho rezimu ci otevreni okna pro vykreslovani</i>
            SDLSurface screen = initVideo();
&nbsp;
            <i>// inicializace celoobrazovkoveho grafickeho rezimu</i>
            GL gl = screen.getGL();
&nbsp;
            <i>// nastaveni transformacnich matic a barvy pozadi framebufferu</i>
            initScene(gl, GFX_WIDTH, GFX_HEIGHT);
&nbsp;
            <i>// nacteni textury</i>
            Texture texture = TextureFactory.getFactory().loadTexture(gl, "xscorch.bmp");
&nbsp;
            <i>// vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL</i>
            drawScene(gl, texture);
&nbsp;
            <i>// prepnuti predniho a zadniho bufferu</i>
            screen.glSwapBuffers();
&nbsp;
            <i>// ukonceni cele aplikace po peti sekundach</i>
            Thread.sleep(5000);
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
        <i>// zobrazit ziskane informace</i>
    }
&nbsp;
}
</pre>

<p>Skript pro pøeklad na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest21.java
</pre>

<p>Dávkový soubor pro pøeklad na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest21.java
</pre>

<p>Skript pro spu¹tìní na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
java -cp .:$SDL_JAVA_LIBS/sdljava.jar -Djava.library.path=$SDL_JAVA_LIBS SDLTest21
</pre>

<p>Dávkový soubor pro spu¹tìní na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest21
</pre>

<img src="http://i.iinfo.cz/images/399/11702.png" class="image-162011" width="600" height="600" alt="&#160;" />
<p><i>Obrázek 1: Scéna vykreslená po spu¹tìní demonstraèního pøíkladu
<strong>SDLTest21</strong>.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Demonstraèní pøíklad <strong>SDLTest22</strong> &ndash; prota¾ení textury</h2>

<p>Pøi zvìt¹ení èi naopak zmen¹ení textury se zaèínají uplatòovat filtry
provádìné grafickým akcelerátorem. Filtry se nepou¾ijí pouze v&nbsp;jednom
pøípadì &ndash; kdy¾ je velikost pixelù a texelù zcela shodná a souèasnì se
plochy pixelù a texelù pøesnì pøekrývají (objekt není natoèen ani posunut
oproti souøadnému systému obrazovky). Prozatím jsme si neøekli bli¾¹í informace
o takzvaném mipmappingu, ov¹em i bez vyu¾ití této technologie lze zvolit
minimálnì mezi dvìma typy filtrù: velmi rychlý filtr typu
&bdquo;nearest&ldquo;, který v¾dy vybere barvu nejbli¾¹ího texelu a ponìkud
pomalej¹í (více pøístupù do texturovací pamìti) filtr provádìjící (bili)neární
interpolaci na základì barev pøeètených z&nbsp;nejbli¾¹ích texelù.
V&nbsp;dne¹ním posledním demonstraèním pøíkladu je ukázán rozdíl mezi tìmito
filtry.</p>

<p>Objekt, v&nbsp;na¹em pøípadì jednoduchý obdélník, je vykreslen dvakrát.
Jednou s&nbsp;vyu¾itím filtru typu &bdquo;nearest&ldquo;:</p>

<pre>
<i>// volba filtru</i>
gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MAG_FILTER, gl.GL_NEAREST);
gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MIN_FILTER, gl.GL_NEAREST);
&nbsp;
<i>// vykresleni ctyruhelniku</i>
gl.glBegin(gl.GL_QUADS);
    gl.glTexCoord2f(0.0f, 0.3f);
    gl.glVertex2i(0, 0);
    gl.glTexCoord2f(0.5f, 0.3f);
    gl.glVertex2i(300, 0);
    gl.glTexCoord2f(0.5f, 0.8f);
    gl.glVertex2i(300, 200);
    gl.glTexCoord2f(0.0f, 0.8f);
    gl.glVertex2i(0, 200);
gl.glEnd();
</pre>

<p>A podruhé s&nbsp;vyu¾itím filtru provádìjícího bilineární interpolaci:</p>

<pre>
<i>// volba filtru</i>
gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MAG_FILTER, gl.GL_LINEAR);
gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MIN_FILTER, gl.GL_LINEAR);
&nbsp;
texture.bind(gl);
&nbsp;
<i>// vykresleni ctyruhelniku</i>
gl.glBegin(gl.GL_QUADS);
    gl.glTexCoord2f(0.0f, 0.3f);
    gl.glVertex2i(0, 200);
    gl.glTexCoord2f(0.5f, 0.3f);
    gl.glVertex2i(300, 200);
    gl.glTexCoord2f(0.5f, 0.8f);
    gl.glVertex2i(300, 400);
    gl.glTexCoord2f(0.0f, 0.8f);
    gl.glVertex2i(0, 400);
gl.glEnd();
</pre>

<p>Následuje úplný výpis zdrojového kódu tøetího demonstraèního pøíkladu:</p>

<pre>
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
&nbsp;
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.video.SDLPixelFormat;
import sdljava.video.SDLSurface;
import sdljava.video.SDLVideo;
&nbsp;
import org.gljava.opengl.GL;
import org.gljava.opengl.Texture;
import org.gljava.opengl.TextureFactory;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Dvacaty druhy demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> *</i>
<i> * Texturovani a objekt typu Texture - volba ruznych filtru pouzitych pri texturovani.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>SDLTest22</strong> {
&nbsp;
    <i>/**</i>
    <i> * Horizontalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_WIDTH</strong> = 300;
&nbsp;
    <i>/**</i>
    <i> * Vertikalni rozliseni vybraneho grafickeho rezimu ci okna.</i>
    <i> */</i>
    private static final int <strong>GFX_HEIGHT</strong> = 400;
&nbsp;
    <i>/**</i>
    <i> * Bitova hloubka vybraneho grafickeho rezimu.</i>
    <i> * (0 znamena automaticky vyber, ovsem lze samozrejme pouzit</i>
    <i> * i hodnoty 8, 16, 24 ci 32, podle vlastnosti graficke karty)</i>
    <i> */</i>
    private static final int <strong>GFX_BPP</strong> = 0;
&nbsp;
    <i>/**</i>
    <i> * Inicializace grafickeho rezimu ci otevreni okna pro vykreslovani.</i>
    <i> */</i>
    private static SDLSurface <strong>initVideo</strong>() throws SDLException {
        final long flags = SDLVideo.SDL_OPENGL | SDLVideo.SDL_DOUBLEBUF;
        return SDLVideo.setVideoMode(GFX_WIDTH, GFX_HEIGHT, GFX_BPP, flags);
    }
&nbsp;
    <i>/**</i>
    <i> * Nastaveni transformacnich matic a barvy pozadi framebufferu.</i>
    <i> */</i>
    private static void <strong>initScene</strong>(GL gl, int width, int height) {
        <i>// nastaveni projekcni matice</i>
        gl.glMatrixMode(gl.GL_PROJECTION);
&nbsp;
        <i>// jednotkova matice</i>
        gl.glLoadIdentity();
&nbsp;
        <i>// mapovani abstraktnich souradnic do souradnic okna ci cele obrazovky</i>
        gl.glOrtho(0, width, height, 0, -1, 1);
&nbsp;
        <i>// nastaveni modelview matice</i>
        gl.glMatrixMode(gl.GL_MODELVIEW);
        gl.glLoadIdentity();
&nbsp;
        <i>// viditelna oblast</i>
        gl.glViewport(0, 0, width, height);
&nbsp;
        <i>// vypnuti pameti hloubky pri vykreslovani</i>
        gl.glDisable(gl.GL_DEPTH_TEST);
&nbsp;
        <i>// povoleni prace s texturami</i>
        gl.glEnable(gl.GL_TEXTURE_2D);
&nbsp;
        <i>// opakovani textury</i>
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_WRAP_S, gl.GL_REPEAT);
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_WRAP_T, gl.GL_REPEAT);
&nbsp;
        <i>// vylepseni zobrazovani v pripade pouziti perspektivni projekce</i>
        gl.glHint(gl.GL_PERSPECTIVE_CORRECTION_HINT, gl.GL_NICEST);
&nbsp;
        <i>// barva pozadi framebufferu pro volani glClear()</i>
        gl.glClearColor (0.0f, 0.0f, 0.0f, 0.0f);
    }
&nbsp;
    <i>/**</i>
    <i> * Vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL.</i>
    <i> */</i>
    private static void <strong>drawScene</strong>(GL gl, Texture texture) {
&nbsp;
        <i>// vymazani framebufferu</i>
        gl.glClear(gl.GL_COLOR_BUFFER_BIT);
&nbsp;
        texture.bind(gl);
&nbsp;
        <i>// volba filtru</i>
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MAG_FILTER, gl.GL_NEAREST);
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MIN_FILTER, gl.GL_NEAREST);
&nbsp;
        <i>// vykresleni ctyruhelniku</i>
        gl.glBegin(gl.GL_QUADS);
            gl.glTexCoord2f(0.0f, 0.3f);
            gl.glVertex2i(0, 0);
            gl.glTexCoord2f(0.5f, 0.3f);
            gl.glVertex2i(300, 0);
            gl.glTexCoord2f(0.5f, 0.8f);
            gl.glVertex2i(300, 200);
            gl.glTexCoord2f(0.0f, 0.8f);
            gl.glVertex2i(0, 200);
        gl.glEnd();
&nbsp;
        <i>// volba filtru</i>
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MAG_FILTER, gl.GL_LINEAR);
        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MIN_FILTER, gl.GL_LINEAR);
&nbsp;
        texture.bind(gl);
&nbsp;
        <i>// vykresleni ctyruhelniku</i>
        gl.glBegin(gl.GL_QUADS);
            gl.glTexCoord2f(0.0f, 0.3f);
            gl.glVertex2i(0, 200);
            gl.glTexCoord2f(0.5f, 0.3f);
            gl.glVertex2i(300, 200);
            gl.glTexCoord2f(0.5f, 0.8f);
            gl.glVertex2i(300, 400);
            gl.glTexCoord2f(0.0f, 0.8f);
            gl.glVertex2i(0, 400);
        gl.glEnd();
        gl.glFlush();     <i>// provedeni a vykresleni vsech zmen</i>
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni osmeho demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace video subsystemu knihovny SDL</i>
            SDLMain.init(SDLMain.SDL_INIT_VIDEO);
&nbsp;
            <i>// inicializace grafickeho rezimu ci otevreni okna pro vykreslovani</i>
            SDLSurface screen = initVideo();
&nbsp;
            <i>// inicializace celoobrazovkoveho grafickeho rezimu</i>
            GL gl = screen.getGL();
&nbsp;
            <i>// nastaveni transformacnich matic a barvy pozadi framebufferu</i>
            initScene(gl, GFX_WIDTH, GFX_HEIGHT);
&nbsp;
            <i>// nacteni textury</i>
            Texture texture = TextureFactory.getFactory().loadTexture(gl, "xscorch.bmp");
&nbsp;
            <i>// vykresleni velmi jednoduche sceny s vyuzitim funkci OpenGL</i>
            drawScene(gl, texture);
&nbsp;
            <i>// prepnuti predniho a zadniho bufferu</i>
            screen.glSwapBuffers();
&nbsp;
            <i>// ukonceni cele aplikace po peti sekundach</i>
            Thread.sleep(5000);
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            <i>// musime obnovit puvodni graficky rezim</i>
            <i>// i v tom pripade, ze nastane nejaka vyjimka</i>
            SDLMain.quit();
        }
        <i>// zobrazit ziskane informace</i>
    }
&nbsp;
}
</pre>

<p>Skript pro pøeklad na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest22.java
</pre>

<p>Dávkový soubor pro pøeklad na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest22.java
</pre>

<p>Skript pro spu¹tìní na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
java -cp .:$SDL_JAVA_LIBS/sdljava.jar -Djava.library.path=$SDL_JAVA_LIBS SDLTest22
</pre>

<p>Dávkový soubor pro spu¹tìní na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest22
</pre>

<img src="http://i.iinfo.cz/images/309/11703.png" class="image-162012" width="300" height="400" alt="&#160;" />
<p><i>Obrázek 1: Scéna vykreslená po spu¹tìní demonstraèního pøíkladu
<strong>SDLTest22</strong>.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Repositáø se zdrojovými kódy v¹ech tøí dne¹ních demonstraèních pøíkladù</h2>

<p>V¹echny tøi dnes popsané demonstraèní pøíklady byly spoleènì
s&nbsp;podpùrnými skripty urèenými pro jejich pøeklad a následné spu¹tìní
ulo¾eny do Mercurial repositáøe dostupného na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
Podobnì jako tomu bylo i v&nbsp;pøedchozích pìti dílech tohoto seriálu, i ke
dne¹ním pøíkladùm jsou pøilo¾eny skripty vyu¾itelné pro jejich pøeklad a
spu¹tìní. Navíc byly pøidány i skripty vyu¾itelné ve Windows:</p>

<table>
<tr><th> #</th><th>Zdrojový soubor/skript</th><th>Umístìní souboru v&nbsp;repositáøi</th></tr>
<tr><td> 1</td><td>SDLTest20.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/02880fee963a/sdljava/SDLTest20/SDLTest20.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/02880fee963a/sdljava/SDLTest20/SDLTest20.java</a></td></tr>
<tr><td> 2</td><td>SDLTest20_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest20/SDLTest20_compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest20/SDLTest20_compile.sh</a></td></tr>
<tr><td> 3</td><td>SDLTest20_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest20/SDLTest20_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest20/SDLTest20_compile_sys.sh</a></td></tr>
<tr><td> 4</td><td>SDLTest20_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest20/SDLTest20_run.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest20/SDLTest20_run.sh</a></td></tr>
<tr><td> 5</td><td>SDLTest20_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest20/SDLTest20_run_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest20/SDLTest20_run_sys.sh</a></td></tr>
<tr><td> 6</td><td>SDLTest20_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest20/SDLTest20_compile.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest20/SDLTest20_compile.bat</a></td></tr>
<tr><td> 7</td><td>SDLTest20_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest20/SDLTest20_run.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest20/SDLTest20_run.bat</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr> 
<tr><td> 8</td><td>SDLTest21.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/02880fee963a/sdljava/SDLTest21/SDLTest21.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/02880fee963a/sdljava/SDLTest21/SDLTest21.java</a></td></tr>
<tr><td> 9</td><td>SDLTest21_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest21/SDLTest21_compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest21/SDLTest21_compile.sh</a></td></tr>
<tr><td>10</td><td>SDLTest21_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest21/SDLTest21_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest21/SDLTest21_compile_sys.sh</a></td></tr>
<tr><td>11</td><td>SDLTest21_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest21/SDLTest21_run.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest21/SDLTest21_run.sh</a></td></tr>
<tr><td>12</td><td>SDLTest21_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest21/SDLTest21_run_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest21/SDLTest21_run_sys.sh</a></td></tr>
<tr><td>13</td><td>SDLTest21_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest21/SDLTest21_compile.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest21/SDLTest21_compile.bat</a></td></tr>
<tr><td>14</td><td>SDLTest21_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest21/SDLTest21_run.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d9d2ef329fbd/sdljava/SDLTest21/SDLTest21_run.bat</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr> 
<tr><td>15</td><td>SDLTest22.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/02880fee963a/sdljava/SDLTest22/SDLTest22.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/02880fee963a/sdljava/SDLTest22/SDLTest22.java</a></td></tr>
<tr><td>16</td><td>SDLTest22_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/02880fee963a/sdljava/SDLTest22/SDLTest22_compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/02880fee963a/sdljava/SDLTest22/SDLTest22_compile.sh</a></td></tr>
<tr><td>17</td><td>SDLTest22_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/02880fee963a/sdljava/SDLTest22/SDLTest22_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/02880fee963a/sdljava/SDLTest22/SDLTest22_compile_sys.sh</a></td></tr>
<tr><td>18</td><td>SDLTest22_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/02880fee963a/sdljava/SDLTest22/SDLTest22_run.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/02880fee963a/sdljava/SDLTest22/SDLTest22_run.sh</a></td></tr>
<tr><td>19</td><td>SDLTest22_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/02880fee963a/sdljava/SDLTest22/SDLTest22_run_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/02880fee963a/sdljava/SDLTest22/SDLTest22_run_sys.sh</a></td></tr>
<tr><td>20</td><td>SDLTest22_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/02880fee963a/sdljava/SDLTest22/SDLTest22_compile.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/02880fee963a/sdljava/SDLTest22/SDLTest22_compile.bat</a></td></tr>
<tr><td>21</td><td>SDLTest22_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/02880fee963a/sdljava/SDLTest22/SDLTest22_run.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/02880fee963a/sdljava/SDLTest22/SDLTest22_run.bat</a></td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>glDrawArrays<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArrays.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArrays.xml</a>
</li>

<li>glDrawElements<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElements.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElements.xml</a>
</li>

<li>glDrawArraysInstanced<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArraysInstanced.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArraysInstanced.xml</a>
</li>

<li>glDrawElementsInstanced<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElementsInstanced.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElementsInstanced.xml</a>
</li>

<li>Root.cz: Seriál Grafická knihovna OpenGL<br />
<a href="http://www.root.cz/serialy/graficka-knihovna-opengl/">http://www.root.cz/serialy/graficka-knihovna-opengl/</a>
</li>

<li>Root.cz: Seriál Tvorba pøenositelných grafických aplikací vyu¾ívajících knihovnu GLUT<br />
<a href="http://www.root.cz/serialy/tvorba-prenositelnych-grafickych-aplikaci-vyuzivajicich-knihovnu-glut/">http://www.root.cz/serialy/tvorba-prenositelnych-grafickych-aplikaci-vyuzivajicich-knihovnu-glut/</a>
</li>

<li>Best Practices for Working with Vertex Data<br />
<a href="https://developer.apple.com/library/ios/documentation/3ddrawing/conceptual/opengles_programmingguide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html">https://developer.apple.com/library/ios/documentation/3ddrawing/conceptual/opengles_programmingguide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_Surface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_PixelFormat<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlpixelformat.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlpixelformat.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_LockSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdllocksurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdllocksurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_UnlockSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlunlocksurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlunlocksurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_LoadBMP<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlloadbmp.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlloadbmp.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_SaveBMP<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsavebmp.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsavebmp.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_BlitSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlblitsurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlblitsurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_VideoInfo<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlvideoinfo.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlvideoinfo.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_GetVideoInfo<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlgetvideoinfo.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlgetvideoinfo.html</a>
</li>

<li>Class BufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferStrategy.html</a>
</li>

<li>Class Graphics<br />
<a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/Graphics.html">http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/Graphics.html</a>
</li>

<li>Double Buffering and Page Flipping<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html</a>
</li>

<li>BufferStrategy and BufferCapabilities<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/bufferstrategy.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/bufferstrategy.html</a>
</li>

<li>Java:Tutorials:Double Buffering<br />
<a href="http://content.gpwiki.org/index.php/Java:Tutorials:Double_Buffering">http://content.gpwiki.org/index.php/Java:Tutorials:Double_Buffering</a>
</li>

<li>Double buffer in standard Java AWT<br />
<a href="http://www.codeproject.com/Articles/2136/Double-buffer-in-standard-Java-AWT">http://www.codeproject.com/Articles/2136/Double-buffer-in-standard-Java-AWT</a>
</li>

<li>Java 2D: Hardware Accelerating - Part 1 - Volatile Images<br />
<a href="http://www.javalobby.org/forums/thread.jspa?threadID=16840&tstart=0">http://www.javalobby.org/forums/thread.jspa?threadID=16840&tstart=0</a>
</li>

<li>Java 2D: Hardware Accelerating - Part 2 - Buffer Strategies<br />
<a href="http://www.javalobby.org/java/forums/t16867.html">http://www.javalobby.org/java/forums/t16867.html</a>
</li>

<li>How does paintComponent work?<br />
<a href="http://stackoverflow.com/questions/15544549/how-does-paintcomponent-work">http://stackoverflow.com/questions/15544549/how-does-paintcomponent-work</a>
</li>

<li>A Swing Architecture Overview<br />
<a href="http://www.oracle.com/technetwork/java/architecture-142923.html">http://www.oracle.com/technetwork/java/architecture-142923.html</a>
</li>

<li>Class javax.swing.JComponent<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html</a>
</li>

<li>Class java.awt.Component<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html</a>
</li>

<li>Class java.awt.Component.BltBufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.BltBufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.BltBufferStrategy.html</a>
</li>

<li>Class java.awt.Component.FlipBufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.FlipBufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.FlipBufferStrategy.html</a>
</li>

<li>Metoda java.awt.Component.isDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html#isDoubleBuffered()">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html#isDoubleBuffered()</a>
</li>

<li>Metoda javax.swing.JComponent.isDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#isDoubleBuffered()">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#isDoubleBuffered()</a>
</li>

<li>Metoda javax.swing.JComponent.setDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#setDoubleBuffered(boolean)">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#setDoubleBuffered(boolean)</a>
</li>

<li>Javadoc - tøída GraphicsDevice<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html</a>
</li>

<li>Javadoc - tøída GraphicsEnvironment<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html</a>
</li>

<li>Javadoc - tøída GraphicsConfiguration<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html</a>
</li>

<li>Javadoc - tøída DisplayMode<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html">http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html</a>
</li>

<li>Lesson: Full-Screen Exclusive Mode API<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/">http://docs.oracle.com/javase/tutorial/extra/fullscreen/</a>
</li>

<li>Full-Screen Exclusive Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html</a>
</li>

<li>Display Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html</a>
</li>

<li>Using the Full-Screen Exclusive Mode API in Java<br />
<a href="http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm">http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>GC safe-point (or safepoint) and safe-region<br />
<a href="http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html">http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html</a>
</li>

<li>Safepoints in HotSpot JVM<br />
<a href="http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html">http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html</a>
</li>

<li>Java theory and practice: Synchronization optimizations in Mustang<br />
<a href="http://www.ibm.com/developerworks/java/library/j-jtp10185/">http://www.ibm.com/developerworks/java/library/j-jtp10185/</a>
</li>

<li>How to build hsdis<br />
<a href="http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README">http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README</a>
</li>

<li>Java SE 6 Performance White Paper<br />
<a href="http://www.oracle.com/technetwork/java/6-performance-137236.html">http://www.oracle.com/technetwork/java/6-performance-137236.html</a>
</li>

<li>Lukas Stadler's Blog<br />
<a href="http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html">http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html</a>
</li>

<li>How to build hsdis-amd64.dll and hsdis-i386.dll on Windows<br />
<a href="http://dropzone.nfshost.com/hsdis.htm">http://dropzone.nfshost.com/hsdis.htm</a>
</li>

<li>PrintAssembly<br />
<a href="https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly">https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly</a>
</li>

<li>The Java Virtual Machine Specification: 3.14. Synchronization<br />
<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14</a>
</li>

<li>The Java Virtual Machine Specification: 8.3.1.4. volatile Fields<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.4. Memory Model<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.7. Non-atomic Treatment of double and long<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7</a>
</li>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (pøed verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2014</small></p>
</body>
</html>

