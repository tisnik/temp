<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - nastavení breakpointù s vyu¾itím rozhraní JVM TI (dokonèení)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - nastavení breakpointù s vyu¾itím rozhraní JVM TI (dokonèení)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o vlastnostech JVM dokonèíme popis zpùsobu nastavení breakpointù pøes rozhraní JVM TI. Uká¾eme si kompletní demonstraèní program, na nìm¾ bude shrnuta vìt¹ina postupù, s nimi¾ jsme se seznámili v pøedchozích ètrnácti èástech tohoto seriálu.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - nastavení breakpointù s vyu¾itím rozhraní JVM TI (dokonèení)</a></p>
<p><a href="#k02">2. Testovací tøída pou¾itá pro tøicátého druhého demonstraèního JVM TI agenta</a></p>
<p><a href="#k03">3. Pole obsahující jména metod a èísla øádkù, pro nì¾ se mají nastavit breakpointy</a></p>
<p><a href="#k04">4. Nastavení vlastností JVM TI agenta (funkce <strong>set_capabilities</strong>)</a></p>
<p><a href="#k05">5. Prùchod naèítanými tøídami s&nbsp;vyhledáním tøídy, pro ni¾ se breakpoint nastaví (funkce <strong>prepare_breakpoints</strong>)</a></p>
<p><a href="#k06">6. Pøíprava a registrace breakpointù pro vybrané metody (funkce <strong>set_breakpoint_for_selected_method</strong>)</a></p>
<p><a href="#k07">7. Vlastní nastavení breakpointu (funkce <strong>set_breakpoint</strong>)</a></p>
<p><a href="#k08">8. Výpis ve¹kerých informací o nav¹tíveném breakpointu (funkce <strong>callback_on_breakpoint</strong>)</a></p>
<p><a href="#k09">9. Výpis obsahu zásobníkových rámcù pøi nav¹tívení breakpointu (funkce <strong>print_stack_trace</strong>)</a></p>
<p><a href="#k10">10. Zdrojové kódy tøicátého druhého demonstraèního agenta i k&nbsp;nìmu pøíslu¹ných testovacích pøíkladù a skriptù</a></p>
<p><a href="#k11">11. Zbylá funkcionalita rozhraní JVM TI aneb co si popí¹eme v&nbsp;navazujících èláncích</a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - nastavení breakpointù s vyu¾itím rozhraní JVM TI (dokonèení)</h2>

<p>V&nbsp;dne¹ní èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyce Java i o vlastnostech virtuálního stroje Javy</a> se ji¾
popatnácté budeme vìnovat popisu rozhraní <i>JVM TI</i>. Ve skuteènosti jsme si
ji¾ staèili popsat vìt¹inu funkcí, které toto rozhraní programátorùm nabízí,
proto nastal èas pro malou rekapitulaci. V&nbsp;tøicátém druhém demonstraèním
<i>JVM TI</i> agentovi, jeho¾ zdrojové kódy naleznete pod odkazy uvedenými <a
href="#k10">v&nbsp;desáté kapitole</a>, pou¾ijeme pomìrnì velké mno¾ství ji¾
popsaných funkcí nabízených pøes <i>JVM TI</i> i u¾ivatelských funkcí pou¾itých
v&nbsp;pøedchozích agentech. Tento demonstraèní agent nejprve zaregistruje tøi
breakpointy pro tøi rùzné Javovské metody a ve chvíli, kdy nìjaké vlákno dojde
k&nbsp;nastavenému breakpointu, zavolá se v&nbsp;<i>JVM TI</i> agentovi
vytvoøená callback funkce, která vypí¹e podrobnìj¹í informace o vláknu, které
do breakpointu vstoupilo. Vedle pøesné lokalizace breakpointu se toti¾ vypí¹e i
<i>stack trace</i>, pøesnìji øeèeno obsah zásobníkového rámce vlákna (historie
volání metod).</p>

<p>Po spu¹tìní testovací tøídy <strong>Test32</strong> se v&nbsp;pøípadì, ¾e je
pøi spu¹tìní virtuálního stroje Javy zaregistrován <i>JVM TI</i> agent, vypí¹ou
na standardní výstup následující hlá¹ení, z&nbsp;nich¾ je patrné, ¾e se
nejdøíve nastaví breakpoint pro metody <strong>Test32.run()</strong>,
<strong>Test32.foo()</strong> a <strong>Test32.bar()</strong> a posléze se pøi
vstupu na zaregistrované breakpointy vypí¹e obsah zásobníkového rámce,
tj.&nbsp;seznam volaných metod. Styl výpisu zásobníkových rámcù byl zvolen
takovým zpùsobem, aby se co nejvíce podobal výpisu, který získáme pøi vzniku
výjimky zavoláním metody <strong>Throwable.printStackTrace()</strong>:</p>

<pre>
Test32.run()
Test32.foo()
Test32.bar() line 12
Test32.bar() line 13
Test32.bar() line 14
Test32.bar() line 15
Agent32: Agent_OnLoad
Agent32: JVM TI version is correct
Agent32: Got VM init event
Agent32: Class Test32; prepared, setting breakpoints for its methods
Agent32: Found method(): &lt;init&gt; with signature ()V
Agent32: Found method(): main with signature ([Ljava/lang/String;)V
Agent32: Found method(): run with signature ()V
Agent32: ...going to set breakpoint for this method
Agent32: Found method(): x with signature ()I
Agent32: Found method(): x with signature (I)I
Agent32: Found method(): x with signature (IZ)I
Agent32: Found method(): x with signature ([I[[D)[I
Agent32: Found method(): foo with signature ()V
Agent32: ...going to set breakpoint for this method
Agent32: Found method(): bar with signature ()V
Agent32: ...going to set breakpoint for this method
&nbsp;
<strong>Agent32: *** visited breakpoint in method Test32.run(Test32.java:19) ***</strong>
<strong>Agent32: Stack Trace (depth = 2)</strong>
<strong>Agent32:	at Test32.run(Test32.java:19)</strong>
<strong>Agent32:	at Test32.main(Test32.java:32)</strong>
&nbsp;
<strong>Agent32: *** visited breakpoint in method Test32.foo(Test32.java:7) ***</strong>
<strong>Agent32: Stack Trace (depth = 3)</strong>
<strong>Agent32:	at Test32.foo(Test32.java:7)</strong>
<strong>Agent32:	at Test32.run(Test32.java:20)</strong>
<strong>Agent32:	at Test32.main(Test32.java:32)</strong>
&nbsp;
<strong>Agent32: *** visited breakpoint in method Test32.bar(Test32.java:14) ***</strong>
<strong>Agent32: Stack Trace (depth = 4)</strong>
<strong>Agent32:	at Test32.bar(Test32.java:14)</strong>
<strong>Agent32:	at Test32.foo(Test32.java:8)</strong>
<strong>Agent32:	at Test32.run(Test32.java:20)</strong>
<strong>Agent32:	at Test32.main(Test32.java:32)</strong>
&nbsp;
Agent32: Got VM Death event
Agent32: Agent_OnUnload
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Testovací tøída pou¾itá pro tøicátého druhého demonstraèního JVM TI agenta</h2>

<p>Testovací javovská tøída, která je pou¾ita spoleènì s&nbsp;tøicátým druhým
demonstraèním <i>JVM TI</i> agentem, vypadá následovnì:</p>

<pre>
<i>/**</i>
<i>  * Testovaci trida pouzite pro test tricateho</i>
<i>  * druheho demonstracniho JVM TI agenta.</i>
<i>  */</i>
public class <strong>Test32</strong> {
    public void <strong>foo</strong>() {
        System.out.println("Test32.foo()");
        bar();
    }
&nbsp;
    public void <strong>bar</strong>() {
        System.out.println("Test32.bar() line 12");
        System.out.println("Test32.bar() line 13");
        System.out.println("Test32.bar() line 14");
        System.out.println("Test32.bar() line 15");
    }
&nbsp;
    public void <strong>run</strong>() {
        System.out.println("Test32.run()");
        foo();
    }
&nbsp;
    public int <strong>x</strong>() {return 0;}
    public int <strong>x</strong>(int y) {return 0;}
    public int <strong>x</strong>(int y, boolean z) {return 0;}
    public int[] <strong>x</strong>(int[] y, double[][] z) {return null;}
&nbsp;
<i>    /**</i>
<i>      * Spusteni testu.</i>
<i>      */</i>
    public static void <strong>main</strong>(String[] args) {
        new Test32().run();
    }
}
</pre>

<p>Dùle¾ité je, aby se do tøídy <strong>Test32</strong> nepøidával ani neubíral
¾ádný programový kód vèetnì prázdných øádkù, proto¾e breakpointy jsou
v&nbsp;<i>JVM TI</i> agentovi nastavovány na konkrétní metodu a na konkrétní
èíslo øádku. Pokud by napøíklad do¹lo k&nbsp;pøidání prázdného øádku èi
jednoøádkové poznámky na zaèátek deklarace tøídy <strong>Test32</strong>, mohlo
by to vést k&nbsp;tomu, ¾e by do¹lo k&nbsp;chybì pøi registraci breakpointu,
popø.&nbsp;by byl breakpoint &bdquo;pouze&ldquo; nastaven na ¹patnou
pozici.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Pole obsahující jména metod a èísla øádkù, pro nì¾ se mají nastavit breakpointy</h2>

<p>Dnes popisovaný demonstraèní <i>JVM TI</i> agent je zalo¾ený na <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2a7ebf111840/jvmti-agents/agent31/agent31.c">zdrojovém souboru tøicátého prvního agenta popsaného</a> <a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-nastaveni-breakpointu-s-vyuzitim-rozhrani-jvm-ti-pokracovani/">v&nbsp;pøedchozí
èásti tohoto seriálu</a>. Tento agent ov¹em pouze dokázal zaregistrovat
breakpoint pro jednu metodu a navíc jen struènì vypsal, ¾e do¹lo k&nbsp;projití
breakpointem. Dnes popisovaný agent musí být schopen zaregistrovat vìt¹í
mno¾ství breakpointù a z&nbsp;tohoto dùvodu v&nbsp;nìm bude muset dojít
k&nbsp;nìkolika zmìnám. Informace o nastavovaném breakpointu budou ukládány do
struktury nazvané <strong>t_breakpoint</strong>. Tato struktura bude obsahovat
jméno metody, pro ní¾ se má breakpoint nastavit a takté¾ èíslo øádky (poèítané
od zaèátku souboru, nikoli od zaèátku tøídy):</p>

<pre>
<i>/*</i>
<i> * Struktura obsahujici jmeno metody a cislo</i>
<i>  *radku na nemz se ma nastavit breakpoint.</i>
<i> */</i>
typedef struct {
    char *method_name;
    int   line_number;
} <strong>t_breakpoint</strong>;
</pre>

<p>Na dal¹ím úryvku kódu je ukázáno, jak se jednodu¹e vytvoøí pole obsahující
informace o tøech breakpointech, které se mají v&nbsp;<i>JVM TI</i> agentovi
nastavit (pro jednoduchost se jedná o globální promìnnou). Pov¹imnìte si
posledního (ètvrtého) záznamu, který namísto jména metody obsahuje pouze
konstantu/makro <strong>NULL</strong>. Jde o zará¾ku, která bude pou¾ita
v&nbsp;agentovi pro detekci konce pole s&nbsp;breakpointy:</p>

<pre>
<i>/*</i>
<i> * Breakpointy se budou nastavovat celkem pro tri metody.</i>
<i> */</i>
<strong>t_breakpoint</strong> breakpoints[] = {
    {"foo", 7},
    {"bar", 14},
    {"run", 19},
    {NULL,  0}    <i>/* zarazka - je pouzita pri prochazeni timto polem! */</i>
};
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Nastavení vlastností JVM TI agenta (funkce <strong>set_capabilities</strong>)</h2>

<p>Podobnì jako tomu bylo v&nbsp;pøedchozích dvou èástech tohoto seriálu, i
dnes si postupnì popí¹eme nìkteré dùle¾ité funkce, které jsou implementovány
v&nbsp;demonstraèním <i>JVM TI</i> agentovi. První u¾ivatelskou funkci ji¾
známe &ndash; jde o funkci nazvanou <strong>set_capabilities()</strong>, která
slou¾í k&nbsp;tomu, aby <i>JVM TI</i> agent informoval virtuální stroj Javy o
tom, které technologie nabízené <i>JVM TI</i> rozhraním budou vyu¾ity.
V&nbsp;na¹em pøípadì vy¾adujeme, aby agent mohl vyu¾ívat tøi technologie:
získání tabulky obsahující pøepoèet mezi èísly øádkù a hodnotou
<i>jlocation</i> (bude vyu¾ito pøi výpisu obsahu zásobníkových rámcù), získání
jména zdrojového souboru pro danou tøídu (takté¾ bude vyu¾ito pøi výpisu obsahu
zásobníkových rámcù) a koneènì potøebujeme, aby virtuální stroj Javy zavolal
pøedem zaregistrovanou callback funkci ve chvíli, kdy nìjaké vlákno dojde
k&nbsp;breakpointu. Funkce <strong>set_capabilities()</strong> tedy bude
vypadat následovnì:</p>

<pre>
<i>/*</i>
<i> * Nastaveni pozadovanych schopnosti agenta.</i>
<i> */</i>
jvmtiError <strong>set_capabilities</strong>(jvmtiEnv *jvmti)
{
    jvmtiCapabilities capabilities;
    jvmtiError error_code;
&nbsp;
    memset(&amp;capabilities, 0, sizeof(jvmtiCapabilities));
&nbsp;
<i>    /* vyuzivame tri specialni schopnosti agenta */</i>
    capabilities.can_get_line_numbers = 1;
    capabilities.can_get_source_file_name = 1;
    capabilities.can_generate_breakpoint_events = 1;
&nbsp;
    error_code = (*jvmti)-&gt;<strong>AddCapabilities</strong>(jvmti, &amp;capabilities);
    check_jvmti_error(jvmti, error_code, "Unable to get necessary JVMTI capabilities.");
    return error_code;
}
</pre>

<p>Podobnì jako v&nbsp;mnoha pøedchozích demonstraèních <i>JVM TI</i> agentech,
i zde je u¾ivatelská funkce <strong>set_capabilities()</strong> zavolána
z&nbsp;funkce <strong>Agent_OnLoad()</strong>, která je automaticky spu¹tìna
virtuálním strojem Javy:</p>

<pre>
<i>/*</i>
<i> * Funkce zavolana ve chvili nacitani agenta do JVM.</i>
<i> */</i>
JNIEXPORT jint JNICALL <strong>Agent_OnLoad</strong>(JavaVM *jvm, char *options, void *reserved)
{
   ...
   ...
   ...
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Prùchod naèítanými tøídami s&nbsp;vyhledáním tøídy, pro ni¾ se breakpoint nastaví (funkce <strong>prepare_breakpoints</strong>)</h2>

<p>Funkci nazvanou <strong>prepare_breakpoint()</strong> u¾ sice máme
pøipravenou od minulého týdne, ov¹em kvùli tomu, ¾e dne¹ní demonstraèní agent
podporuje nastavení vìt¹ího mno¾ství breakpointù, do¹lo pøi úpravách této
funkce k&nbsp;men¹ímu refaktoringu a èást její funkcionality byla pøevedena do
nové funkce <strong>set_breakpoint_for_selected_method()</strong> popsané dále.
Pøipomeòme si, ¾e se funkce <strong>prepare_breakpoint()</strong> volá
z&nbsp;callback funkce nazvané <strong>callback_on_class_prepare()</strong>,
je¾ je automaticky zavolána ve chvíli, kdy dojde k&nbsp;naètení nìjaké tøídy do
virtuálního stroje Javy. Funkci <strong>prepare_breakpoint()</strong> se
z&nbsp;<strong>callback_on_class_prepare()</strong> pøedá identifikátor tøídy
(typu <strong>jclass</strong>) a následnì se pøeètou v¹echny metody, které jsou
ve tøídì deklarovány. Pro ka¾dou metodu je zavolána nová u¾ivatelská funkce
nazvaná <strong>set_breakpoint_for_selected_method()</strong>, která bude
popsána v&nbsp;následující kapitole:</p>

<pre>
<i>/*</i>
<i> * Registrace breakpointu pro zvolene metody.</i>
<i> */</i>
void <strong>prepare_breakpoints</strong>(jvmtiEnv *jvmti_env, jclass class)
{
    jvmtiError  error;
    int         method_count;
    jmethodID  *methods_array;
&nbsp;
<i>    /* precist vsechny metody tridy */</i>
    error = (*jvmti_env)-&gt;<strong>GetClassMethods</strong>(jvmti_env, class, &amp;method_count, &amp;methods_array);
    check_jvmti_error(jvmti_env, error, "get class methods");
&nbsp;
<i>    /* pole metod bylo inicializovano */</i>
    if (error == JVMTI_ERROR_NONE)
    {
        int i;
&nbsp;
<i>        /* projit vsemi metodami a nastavit breakpoint pro zvolenou metodu */</i>
        for (i = 0; i &lt; method_count; i++)
        {
            jmethodID method = methods_array[i];
            <strong>set_breakpoint_for_selected_method</strong>(jvmti_env, method);
        }
    }
&nbsp;
<i>    /* dealokace pole ziskaneho pres GetClassFields() */</i>
    error = (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char*)methods_array);
    check_jvmti_error(jvmti_env, error, "deallocate class fields array");
}
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Pøíprava a registrace breakpointù pro vybrané metody (funkce <strong>set_breakpoint_for_selected_method</strong>)</h2>

<p>Novì pøidaná funkce pojmenovaná
<strong>set_breakpoint_for_selected_method()</strong> je zavolána pro ka¾dou
metodu tøídy, její¾ jméno je (pro jednoduchost) ulo¾eno v&nbsp;symbolické
konstantì nazvané <strong>TEST_CLASS_NAME</strong>. Uvnitø této funkce je
implementována programová smyèka, která projde globálním polem
<strong>breakpoints</strong> obsahujícím struktury typu
<strong>t_breakpoint</strong> (viz té¾ <a href="#k03">podrobnìj¹í popis ve
tøetí kapitole</a>). V&nbsp;pøípadì, ¾e je nalezena metoda se jménem uvedeným
v&nbsp;poli <strong>breakpoints</strong>, je z&nbsp;pøíslu¹né datové struktury
získáno èíslo øádku, na nìm¾ má být breakpoint nastaven. Následnì se zavolá
dal¹í u¾ivatelská funkce <strong>set_breakpoint()</strong>, které se pøedá jak
identifikátor metody (ten je typu <strong>jmethodID</strong>), tak i èíslo
øádku s&nbsp;nastavovaným breakpointem (celé kladné èíslo):</p>

<pre>
<i>/*</i>
<i> * Pokud se metoda nachazi v poli breakpoints, nastavi se pro ni breakpoint.</i>
<i> */</i>
void <strong>set_breakpoint_for_selected_method</strong>(jvmtiEnv *jvmti_env, jmethodID method)
{
    jvmtiError  error;
    char *method_name;
    char *method_signature;
&nbsp;
    error = (*jvmti_env)-&gt;<strong>GetMethodName</strong>(jvmti_env, method, &amp;method_name, &amp;method_signature, NULL);
<i>    /* podarilo se ziskat jmeno metody, otestujme tedy, zda pro ni mame nastavit breakpoint */</i>
    if (error == JVMTI_ERROR_NONE)
    {
        int j;
        printf(AGENT_NAME " Found method(): %s with signature %s\n", method_name, method_signature);
&nbsp;
        for (j=0; breakpoints[j].method_name != NULL; j++)
        {
            if (strcmp(method_name, breakpoints[j].method_name) == 0)
            {
                puts(AGENT_NAME " ...going to set breakpoint for this method");
                <strong>set_breakpoint</strong>(jvmti_env, method, breakpoints[j].line_number);
            }
        }
&nbsp;
        (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char*)method_name);
        (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char*)method_signature);
    }
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vlastní nastavení breakpointu (funkce <strong>set_breakpoint</strong>)</h2>

<p>Funkce <strong>set_breakpoint()</strong> zavolaná <a href="#k06">z&nbsp;vý¹e
popsané</a> funkce <strong>set_breakpoint_for_selected_method()</strong>, je,
podobnì jako u <a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-nastaveni-breakpointu-s-vyuzitim-rozhrani-jvm-ti-pokracovani/">pøedchozího</a>
<i>JVM TI</i> agenta, velmi jednoduchá &ndash; nejprve zjistí hodnotu
<strong>jlocation</strong> a posléze pouze zavolá <i>JVM TI</i> funkci
<strong>SetBreakpoint()</strong> se v¹emi vy¾adovanými parametry:</p>

<pre>
<i>/*</i>
<i> * Nastaveni breakpointu pro zvolenou metodu na danem radku.</i>
<i> */</i>
void <strong>set_breakpoint</strong>(jvmtiEnv *jvmti_env, jmethodID method, int line)
{
    jvmtiError  error;
    jlocation   location = get_location_for_line(jvmti_env, method, line);
&nbsp;
    error = (*jvmti_env)-&gt;<strong>SetBreakpoint</strong>(jvmti_env, method, location);
    check_jvmti_error(jvmti_env, error, "set breakpoint");
}
</pre>

<p>Pro pøevod mezi èíslem øádku (kladné celé èíslo) a hodnotou typu
<strong>jlocation</strong> se pou¾ije u¾ivatelská funkce
<strong>get_location_for_line()</strong>:</p>

<pre>
<i>/*</i>
<i> * Ziskani indexu instrukce pro dane cislo radku.</i>
<i> */</i>
jlocation <strong>get_location_for_line</strong>(jvmtiEnv *jvmti_env, jmethodID method, int line)
{
    int count;
    int i;
    jvmtiLineNumberEntry *location_table;
    jvmtiError error_code;
<i>    /* pokud se cislo radku nenalezne nebo zde není zadny kod, vrati se chybova hodnota -1 */</i>
    jlocation  location = -1;
&nbsp;
<i>    /* pokud nebyla predana zadna metoda */</i>
    if (method == NULL)
    {
        return -1;
    }
&nbsp;
<i>    /* test na korektne zadane cislo radky */</i>
    if (line &lt;= 0)
    {
        return -1;
    }
&nbsp;
<i>    /* nacteni tabulky s cisly radku a indexy instrukci */</i>
    error_code = (*jvmti_env)-&gt;GetLineNumberTable(jvmti_env, method, &amp;count, &amp;location_table);
<i>    /* v nekterych pripadech se nacist tabulku nemusi podarit */</i>
    if (error_code != JVMTI_ERROR_NONE)
    {
        return -1;
    }
&nbsp;
<i>    /* projit celou tabulkou */</i>
    for (i = 0; i &lt; count; i++)
    {
        jvmtiLineNumberEntry entry = location_table[i];
        if (entry.line_number == line)
        {
            location = entry.start_location;
            break;
        }
    }
&nbsp;
<i>    /* nesmíme zapomenout na dealokaci tabulky (pole) s dvojicemi cislo radku:location */</i>
    (*jvmti_env)-&gt;Deallocate(jvmti_env, (unsigned char *)location_table);
    return location;
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Výpis ve¹kerých informací o nav¹tíveném breakpointu (funkce <strong>callback_on_breakpoint</strong>)</h2>

<p>V&nbsp;demonstraèním <i>JVM TI</i> agentovi popsaném <a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-nastaveni-breakpointu-s-vyuzitim-rozhrani-jvm-ti-pokracovani/">minule</a>
byla callback funkce zavolaná pøi pøístupu na nastavený breakpoint velmi
jednoduchá, proto¾e pouze vypisovala zprávu &bdquo;*** visited breakpoint!!!
***&ldquo;:</p>

<pre>
<i>/*</i>
<i> * Callback funkce zavolana pri zapisu vybranych atributu</i>
<i> */</i>
static void JNICALL <strong>callback_on_breakpoint</strong>(
        jvmtiEnv *jvmti_env,
        JNIEnv*   jni_env,
        jthread   thread,
        jmethodID method,
        jlocation location)
{
    printf("*** visited breakpoint!!! ***\n");
}
</pre>

<p>My v¹ak po dnes popisovaném <i>JVM TI</i> agentovi budeme vy¾adovat mnohem
vìt¹í funkcionalitu, u¾ jen z&nbsp;toho dùvodu, ¾e callback funkce
<strong>callback_on_breakpoint()</strong> mù¾e být volána pro tøi breakpointy
nastavené pro tøi rùzné metody. Do zprávy vypisované touto funkcí tedy doplníme
informace o tøídì a metodì, v&nbsp;ní¾ byl breakpoint nav¹tíven a tuto
informaci je¹tì doplníme jménem pøíslu¹ného zdrojového souboru tøídy a èíslem
øádku (mù¾eme toti¾ samozøejmì mít hned nìkolik breakpointù registrovaných pro
stejnou metodu). Zpráva produkovaná novou variantou callback funkce
<strong>callback_on_breakpoint()</strong> by mìla vypadat následovnì:</p>

<strong>Agent32: *** visited breakpoint in method Test32.run(Test32.java:19) ***</strong>

<p>Implementace této funkce není ve skuteènosti nijak slo¾itá, proto¾e
vyu¾ijeme ji¾ známé <i>JVM TI</i> funkce <strong>GetMethodName()</strong>,
<strong>GetMethodDeclaringClass()</strong> (chybí nám toti¾ informace o tøídì,
v&nbsp;ní¾ je metoda deklarována), <strong>GetClassSignature()</strong> a
<strong>GetSourceFileName()</strong>. Ve¹keré øetìzce naplnìné pøímo rozhraním
<i>JVM TI</i> se samozøejmì musí uvolnit pomocí funkce
<strong>Deallocate()</strong>:</p>

<pre>
<i>/*</i>
<i> * Callback funkce zavolana pri zapisu vybranych atributu</i>
<i> */</i>
static void JNICALL <strong>callback_on_breakpoint</strong>(
        jvmtiEnv *jvmti_env,
        JNIEnv   *jni_env,
        jthread   thread,
        jmethodID method,
        jlocation location)
{
    char      *method_name_ptr;
    char      *method_signature_ptr;
    char      *class_name_ptr;
    char      *updated_class_name_ptr;
    char      *source_file_name;
    jclass     method_class;
    jvmtiError error;
    int        line_number;
&nbsp;
<i>    /* veskere operace se budou provadet v kriticke sekci */</i>
    enter_critical_section(jvmti_env);
&nbsp;
<i>    /* ziskat jmeno a signaturu metody a signaturu tridy */</i>
    (*jvmti_env)-&gt;<strong>GetMethodName</strong>(jvmti_env, method, &amp;method_name_ptr, &amp;method_signature_ptr, NULL);
    (*jvmti_env)-&gt;<strong>GetMethodDeclaringClass</strong>(jvmti_env, method, &amp;method_class);
    (*jvmti_env)-&gt;<strong>GetClassSignature</strong>(jvmti_env, method_class, &amp;class_name_ptr, NULL);
&nbsp;
<i>    /* upravit jmeno tridy */</i>
    updated_class_name_ptr = update_class_name(class_name_ptr, '.');
&nbsp;
<i>    /* ziskat jmeno zdrojoveho souboru volajici metody */</i>
    error = (*jvmti_env)-&gt;<strong>GetSourceFileName</strong>(jvmti_env, method_class, &amp;source_file_name);
    check_jvmti_error(jvmti_env, error, "GetSourceFileName() failed");
&nbsp;
<i>    /* ziskat cislo radku */</i>
    line_number = get_line_number(jvmti_env, method, location);
&nbsp;
<i>    /* vypis vsech informaci o vyjimce */</i>
    printf(AGENT_NAME " *** visited breakpoint in method %s%s(%s:%d) ***\n",
            updated_class_name_ptr,
            method_name_ptr,
            source_file_name,
            line_number);
    <strong>print_stack_trace</strong>(jvmti_env, thread);
&nbsp;
<i>    /* dealokace vsech ziskanych pametovych struktur */</i>
    error = (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char *)source_file_name);
    check_jvmti_error(jvmti_env, error, "deallocate source file name");
    error = (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char *)method_name_ptr);
    check_jvmti_error(jvmti_env, error, "deallocate method name");
    error = (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char *)method_signature_ptr);
    check_jvmti_error(jvmti_env, error, "deallocate signature");
    error = (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char *)class_name_ptr);
    check_jvmti_error(jvmti_env, error, "deallocate class name");
&nbsp;
<i>    /* a vystup z kriticke sekce */</i>
    exit_critical_section(jvmti_env);
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Výpis obsahu zásobníkových rámcù pøi nav¹tívení breakpointu (funkce <strong>print_stack_trace</strong>)</h2>

<p>Pøi pøístupu na breakpoint ná¹ demonstraèní <i>JVM TI</i> agent takté¾
vypí¹e obsah zásobníkových rámcù, pøesnìji øeèeno ne hodnoty v¹ech pøedávaných
parametrù, ale &bdquo;pouze&ldquo; jména volaných metod. Tato funkcionalita
není implementována pøímo v&nbsp;callback funkci
<strong>callback_on_breakpoint()</strong>, ale v&nbsp;samostatné funkci nazvané
jednodu¹e <strong>print_stack_trace()</strong>. V&nbsp;této funkci je alokováno
pole obsahující prvky typu <strong>jvmtiFrameInfo</strong>. Následnì je toto
pole naplnìno s&nbsp;vyu¾itím <i>JVM TI</i> funkce nazvané
<strong>GetStackTrace()</strong>, pøièem¾ je s&nbsp;vyu¾itím symbolické
konstanty <strong>MAX_STACK_TRACE_DEPTH</strong> pøeètena historie maximálnì
deseti volaných metod (hodnotu této konstanty lze samozøejmì zvý¹it,
v&nbsp;pøípadì na¹í testovací Javovské tøídy je to v¹ak zbyteèné). Následnì se
v&nbsp;programové smyèce prochází v¹emi naplnìnými prvky typu
<strong>jvmtiFrameInfo</strong> a pro ka¾dý prvek se zjistí jméno metody (pøes
<strong>jvmtiFrameInfo.method</strong> i èíslo øádku, na nìm¾ k&nbsp;volání
do¹lo (pøes <strong>jvmtiFrameInfo.location</strong>):</p>

<pre>
<i>/*</i>
<i> * Vypis obsahu zasobniku.</i>
<i> */</i>
void <strong>print_stack_trace</strong>(
            jvmtiEnv *jvmti_env,
            jthread   thread)
{
#define MAX_STACK_TRACE_DEPTH 10
    jvmtiFrameInfo stack_frames[MAX_STACK_TRACE_DEPTH];
    jclass     declaring_class;
    int        count;
    char      *method_name_ptr;
    char      *method_signature_ptr;
    char      *class_name_ptr;
    char      *updated_class_name_ptr;
    char      *source_file_name;
    int        line_number;
    int i;
&nbsp;
<i>    /* Ziskat trasovaci inforamce */</i>
    (*jvmti_env)-&gt;<strong>GetStackTrace</strong>(jvmti_env, thread, 0, MAX_STACK_TRACE_DEPTH, stack_frames, &amp;count);
    if (count == 1)
    {
        printf(AGENT_NAME " No stack trace!\n");
    }
    printf(AGENT_NAME " Stack Trace (depth = %d)\n", count); 
<i>    /* Vypis zasobnikovych ramcu */</i>
    for (i = 0; i &lt; count; i++) {
        jvmtiFrameInfo stack_frame = stack_frames[i];
&nbsp;
<i>        /* ziskat jmeno metody i jeji tridu */</i>
        (*jvmti_env)-&gt;<strong>GetMethodName</strong>(jvmti_env, stack_frame.method, &amp;method_name_ptr, &amp;method_signature_ptr, NULL);
        (*jvmti_env)-&gt;<strong>GetMethodDeclaringClass</strong>(jvmti_env, stack_frame.method, &amp;declaring_class);
        (*jvmti_env)-&gt;<strong>GetClassSignature</strong>(jvmti_env, declaring_class, &amp;class_name_ptr, NULL);
&nbsp;
<i>        /* upravit jmeno tridy */</i>
        updated_class_name_ptr = update_class_name(class_name_ptr, '.');
&nbsp;
<i>        /* ziskat jmeno zdrojoveho souboru volajici metody */</i>
        (*jvmti_env)-&gt;<strong>GetSourceFileName</strong>(jvmti_env, declaring_class, &amp;source_file_name);
&nbsp;
<i>        /* ziskat cislo radku */</i>
        line_number = get_line_number(jvmti_env, stack_frame.method, stack_frame.location);
&nbsp;
<i>        /* provest vlastni vypis */</i>
        printf(AGENT_NAME "\tat %s%s(%s:%d)\n", updated_class_name_ptr, method_name_ptr, source_file_name, line_number);
&nbsp;
<i>        /* dealokace vsech ziskanych pametovych struktur */</i>
        (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char*)method_name_ptr);
        (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char*)method_signature_ptr);
        (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char*)class_name_ptr);
    }
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Zdrojové kódy tøicátého druhého demonstraèního agenta i k&nbsp;nìmu pøíslu¹ných testovacích pøíkladù a skriptù</h2>

<p>Zdrojový kód tøicátého druhého demonstraèního <i>JVM TI</i> agenta je,
spoleènì s&nbsp;testovací tøídou <strong>Test32</strong> i skripty pou¾itými
pro pøeklad a spu¹tìní agenta, ulo¾en do Mercurial repositáøe dostupného na
adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
Prozatím nejnovìj¹í verze v¹ech zmínìných zdrojových souborù jsou dostupné na
adresách:</p>

<table>
<tr><td>Agent #32                     </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/fc1a7b3ac5ac/jvmti-agents/agent32/agent32.c">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/fc1a7b3ac5ac/jvmti-agents/agent32/agent32.c</a></td></tr>
<tr><td>Skript pro pøeklad agenta #32 </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/fc1a7b3ac5ac/jvmti-agents/agent32/compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/fc1a7b3ac5ac/jvmti-agents/agent32/compile.sh</a></td></tr>
<tr><td>Skript pro spu¹tìní agenta #32</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/fc1a7b3ac5ac/jvmti-agents/agent32/test.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/fc1a7b3ac5ac/jvmti-agents/agent32/test.sh</a></td></tr>
<tr><td>Testovací tøída Test32.java   </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/fc1a7b3ac5ac/jvmti-agents/agent32/Test32.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/fc1a7b3ac5ac/jvmti-agents/agent32/Test32.java</a></td></tr>
</table>



<p><a name="k11"></a></p>
<h2 id="k11">11. Zbylá funkcionalita rozhraní JVM TI aneb co si popí¹eme v&nbsp;navazujících èláncích</h2>

<p>Jak jsme si ji¾ øekli <a href="#k01">v&nbsp;úvodní kapitole</a>, byla
v&nbsp;pøedchozích ètrnácti èástech tohoto seriálu popsána vìt¹ina funkcí
nabízených rozhraním <i>JVM TI</i>. Zbývá nám popsat a na demonstraèních
pøíkladech ukázat pouze dvì relativnì malé skupiny funkcí. Do první skupiny
patøí funkce zaèínající prefixem <strong>ForceEarlyReturn*</strong>. Tyto
funkce slou¾í k&nbsp;tomu, aby si <i>JVM TI</i> agent vynutil opu¹tìní nìjaké
metody a souèasnì vrátil zadanou hodnotu. Mù¾e se jednat jak o hodnotu
primitivního datového typu (<strong>boolean</strong>, <strong>char</strong>,
<strong>byte</strong>, <strong>short</strong>, <strong>int</strong>,
<strong>long</strong>, <strong>float</strong>, <strong>double</strong>) èi o
referenci (tj.&nbsp;odkaz na instanci nìjaké tøídy).</p>

<p>Do druhé skupiny prozatím nepopsaných funkcí patøí funkce zaèínající
prefixem <strong>GetLocal*</strong>. Tyto funkce slou¾í k&nbsp;získání hodnot
lokálních promìnných a lze je vyu¾ít napøíklad pøi práci s&nbsp;breakpointy,
v&nbsp;callback funkci zavolané pøi vstupu do metody, v&nbsp;callback funkci
zavolané pøi vstupu do výjimky atd. Podrobnìj¹í informace o tìchto dvou
skupinách funkcí si øekneme pøí¹tì.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>Breakpoint (Wikipedia)<br />
<a href="http://cs.wikipedia.org/wiki/Breakpoint">http://cs.wikipedia.org/wiki/Breakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation<br />
<a href="http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html">http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; SetBreakpoint<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#SetBreakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#SetBreakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; ClearBreakpoint<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#ClearBreakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#ClearBreakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; Breakpoint (callback funkce)<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#Breakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#Breakpoint</a>
</li>

<li>The JVM Tool Interface (JVM TI): How VM Agents Work<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html">http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html</a>
</li>

<li>Creating a Debugging and Profiling Agent with JVMTI<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html">http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html</a>
</li>

<li>JVM TI (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/JVM_TI">http://en.wikipedia.org/wiki/JVM_TI</a>
</li>

<li>IBM JVMTI extensions<br />
<a href="http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html">http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

