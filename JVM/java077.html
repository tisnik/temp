<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - získání informací o tøídách ve sledované JVM s vyu¾itím rozhraní JDI</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - získání informací o tøídách ve sledované JVM s vyu¾itím rozhraní JDI</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyku Java i o virtuálním stroji Javy si uká¾eme zpùsob vyu¾ití rozhraní JDI (Java Debugger Interface) pro získání v¹ech informací o tøídách naètených do sledovaného (monitorovaného) virtuálního stroje Javy. Pøes JDI lze získat napøíklad v¹echny metody i atributy vybrané tøídy, informace o parametrech metod atd.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - získání informací o tøídách ve sledované JVM s&nbsp;vyu¾itím rozhraní JDI</a></p>
<p><a href="#k02">2. Získání seznamu v¹ech tøíd ve sledovaném virtuálním stroji</a></p>
<p><a href="#k03">3. Výpis v¹ech základních informací o tøídì</a></p>
<p><a href="#k04">4. Výpis informací o v¹ech atributech tøídy</a></p>
<p><a href="#k05">5. Výpis informací o v¹ech metodách tøídy</a></p>
<p><a href="#k06">6. Získání jmen a typù argumentù metod</a></p>
<p><a href="#k07">7. Kompletní zdrojový kód demonstraèního pøíkladu <strong>JDIAllClassesList</strong></a></p>
<p><a href="#k08">8. Spu¹tìní demonstraèního pøíkladu <strong>JDIAllClassesList</strong></a></p>
<p><a href="#k09">9. Repositáø se zdrojovými kódy demonstraèního pøíkladu <strong>JDIAllClassesList</strong> i podpùrných skriptù</a></p>
<p><a href="#k10">10. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - získání informací o tøídách ve sledované JVM s&nbsp;vyu¾itím rozhraní JDI</h2>

<p>V&nbsp;dne¹ní èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyku Java i o virtuálním stroji Javy</a> si na praktickém
demonstraèním pøíkladu uká¾eme, jakým zpùsobem je mo¾né s&nbsp;vyu¾itím
rozhraní <i>JDI (Java Debugger Interface)</i> získat v¹echny dùle¾ité informace
o tøídách naètených do sledovaného (monitorovaného) virtuálního stroje Javy.
Pøes JDI je mo¾né pøeèíst napøíklad v¹echny metody i atributy vybrané tøídy,
informace o parametrech metod atd. Tyto údaje jsou velmi dùle¾ité, proto¾e je
vyu¾ijeme pøi programování skuteèného (i kdy¾ velmi jednoduchého)
debuggeru.</p>

<p>Dnes popsané èi pou¾ité metody rozhraní <i>JDI</i>:</p>

<table>
<tr><th>#</th><th>Tøída/rozhraní</th><th>Návratový typ</th><th>Metoda</th></tr>
<tr><td> 1</td><td>com.sun.jdi.VirtualMachine</td><td>void</td><td>resume()</td></tr>
<tr><td> 2</td><td>com.sun.jdi.VirtualMachine</td><td>void</td><td>suspend()</td></tr>
<tr><td> 3</td><td>com.sun.jdi.VirtualMachine</td><td>List&lt;ReferenceType&gt;</td><td>allClasses()</td></tr>
<tr><td> 4</td><td>com.sun.jdi.ReferenceType</td><td>String</td><td>name()</td></tr>
<tr><td> 5</td><td>com.sun.jdi.ReferenceType</td><td>List&lt;Field&gt;</td><td>allFields()</td></tr>
<tr><td> 6</td><td>com.sun.jdi.ReferenceType</td><td>List&lt;Method&gt;</td><td>allMethods()</td></tr>
<tr><td> 7</td><td>com.sun.jdi.Type</td><td>String</td><td>signature()</td></tr>
<tr><td> 8</td><td>com.sun.jdi.ReferenceType</td><td>String</td><td>genericSignature()</td></tr>
<tr><td> 9</td><td>com.sun.jdi.ReferenceType</td><td>String</td><td>sourceName()</td></tr>
<tr><td>10</td><td>com.sun.jdi.TypeComponent</td><td>boolean</td><td>isStatic()</td></tr>
<tr><td>11</td><td>com.sun.jdi.TypeComponent</td><td>boolean</td><td>isFinal()</td></tr>
<tr><td>12</td><td>com.sun.jdi.Field</td><td>boolean</td><td>isTransient()</td></tr>
<tr><td>13</td><td>com.sun.jdi.Field</td><td>boolean</td><td>isVolatile()</td></tr>
<tr><td>14</td><td>com.sun.jdi.Method</td><td>boolean</td><td>isNative()</td></tr>
<tr><td>15</td><td>com.sun.jdi.Method</td><td>boolean</td><td>isSynchronized()</td></tr>
<tr><td>16</td><td>com.sun.jdi.Accessible</td><td>boolean</td><td>isPublic()</td></tr>
<tr><td>17</td><td>com.sun.jdi.Accessible</td><td>boolean</td><td>isProtected()</td></tr>
<tr><td>18</td><td>com.sun.jdi.Accessible</td><td>boolean</td><td>isPrivate()</td></tr>
<tr><td>19</td><td>com.sun.jdi.Method</td><td>List&lt;LocalVariable&gt;</td><td>arguments()</td></tr>
<tr><td>20</td><td>com.sun.jdi.Method</td><td>List&lt;String&gt;</td><td>argumentTypeNames()</td></tr>
<tr><td>21</td><td>com.sun.jdi.LocalVariable</td><td>String</td><td>name()</td></tr>
<tr><td>22</td><td>com.sun.jdi.LocalVariable</td><td>String</td><td>typeName()</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Získání seznamu v¹ech tøíd ve sledovaném virtuálním stroji</h2>

<p>Zdrojové kódy dne¹ního demonstraèního pøíkladu nazvaného
<strong>JDIAllClassesList</strong> jsou z&nbsp;velké èásti zalo¾eny na
zdrojových kódem pøíkladu <strong>JDIMethodVariables</strong> [<a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/773bb88e02b6/jdi/JDIMethodVariables.java">1</a>],
který byl popsán <a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-cteni-informaci-o-parametrech-i-o-lokalnich-promennych-metod-s-vyuzitim-rozhrani-jdi/">v&nbsp;pøedchozí èásti</a> <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">tohoto
seriálu</a>. Tento program se nejprve pokusí o pøipojení ke sledovanému
virtuálnímu stroji Javy s&nbsp;vyu¾itím konektoru pou¾ívajícího socket na portu
6502 (èíslo portu je pou¾ito pøi spou¹tìní sledované JVM). Následnì je
sledovaná JVM spu¹tìna po dobu pøibli¾nì jedné sekundy a po jejím opìtovném
zastavení je ji¾ témìø jisté, ¾e do virtuálního stroje byly naèteny v¹echny
tøídy, které posléze budeme moci zkoumat pøes rozhraní <i>JDI</i>.</p>

<p>V&nbsp;metodì <strong>printFilteredClassList()</strong>, která je souèástí
demonstraèního pøíkladu, se nejprve s&nbsp;vyu¾itím metody
<strong>VirtualMachine.allClasses()</strong> získá seznam v¹ech tøíd, které
byly naèteny do sledovaného virtuálního stroje Javy a posléze se na základì
jména ka¾dé tøídy provede výbìr pouze tìch tøíd, v&nbsp;jejich¾ názvu se
vyskytují øetìzce "String" a "Test". Tyto øetìzce jsou ulo¾eny v&nbsp;poli
<strong>CLASS_NAME_FILTERS</strong>, tak¾e je snadné je zmìnit,
popø.&nbsp;upravit demonstraèní pøíklad takovým zpùsobem, aby se tyto parametry
naèítaly napøíklad z&nbsp;pøíkazové øádky. Dùle¾ité je, ¾e metoda
<strong>VirtualMachine.allClasses()</strong> vrací seznam objektù typu
<strong>ReferenceType</strong>, nikoli objektù typu <strong>Class</strong>. To
je ov¹em pochopitelné, proto¾e pøes <i>JDI</i> sice doká¾eme získat v¹echny
potøebné informace, ov¹em napøíklad tøída <strong>String</strong> mù¾e být ve
sledované JVM zcela odli¹ná od tøídy <strong>String</strong> pou¾ité
v&nbsp;debuggeru/demonstraèním pøíkladu. Obì aplikace napøíklad mohou bì¾et na
jiných typech virtuálního stroje a dokonce i na jiném poèítaèi:</p>

<pre>
<i>    /**</i>
<i>     * Vypis vyfiltrovanych trid nactenych do sledovaneho virtualniho stroje.</i>
<i>     * Filtr se nastavuje pres {@link JDIAllClassesList#CLASS_NAME_FILTERS}</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>printFilteredClassList</strong>(VirtualMachine virtualMachine) {
        List&lt;ReferenceType&gt; allClasses = virtualMachine.allClasses();
&nbsp;
<i>        // projit vsemi tridami, ktere se nachazi ve sledovanem virtualnim stroji</i>
        for (ReferenceType klass : allClasses) {
            String className = klass.name();
<i>            // zjistit, zda se ma tato trida vyfiltrovat ci nikoli</i>
            boolean filterClass = true;
<i>            // jednoduchy filtr</i>
            for (String filter : CLASS_NAME_FILTERS) {
                if (className.contains(filter)) {
                    filterClass = false;
                    break;
                }
            }
<i>            // cast jmena tridy nebyla v CLASS_NAME_FILTERS nalezena</i>
            if (filterClass) {
                continue;
            }
            printClassInfo(klass);
        }
    }
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Výpis v¹ech základních informací o tøídì</h2>

<p>V&nbsp;pøípadì, ¾e jméno tøídy obsahuje øetìzec "String" nebo "Test", je
v&nbsp;debuggeru zavolána metoda <strong>printClassInfo()</strong> slou¾ící pro
výpis témìø v¹ech dostupných informací o nalezené tøídì. Zdrojový kód této
metody je velmi jednoduchý:</p>

<pre>
<i>    /**</i>
<i>     * Vypis vsech relevantnich informaci o vybrane tride.</i>
<i>     *</i>
<i>     * @param klass trida ve sledovanem virtualnim stroji Javy</i>
<i>     */</i>
    private static void <strong>printClassInfo</strong>(ReferenceType klass) {
        printBasicClassInfo(klass);
        printClassFields(klass);
        printClassMethods(klass);
        printSeparator();
    }
</pre>

<p>Zajímavìj¹í je a¾ zdrojový kód metody nazvané
<strong>printBasicClassInfo()</strong>, v&nbsp;ní¾ se zji¹»ují ètyøi dùle¾ité
údaje o prozkoumávané tøídì. V&nbsp;první øadì se jedná o jméno tøídy
v&nbsp;podobì, v&nbsp;jaké je jméno pou¾ito (napøíklad jako identifikátor)
v&nbsp;samotném programovacím jazyku Java. Dále se pak zji¹»uje signatura
tøídy, její¾ formát jsme si popsali <a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-2-cast-podrobnejsi-analyza-obsahu-constant-poolu/#k06">ve
druhé èásti tohoto seriálu vìnované popisu bajtkódu JVM</a>. Kromì signatury
tøídy se pøeète i její takzvaná obecná signatura, z&nbsp;ní¾ je mo¾né
mj.&nbsp;získat seznam implementovaných rozhraní. O pøeètení jména zdrojového
souboru s&nbsp;definicí tøídy se stará samostatná metoda nazvaná
<strong>getClassSourceName()</strong>, která je popsána v&nbsp;dal¹ím
odstavci:</p>

<pre>
<i>    /**</i>
<i>     * Zakladni informace o tride.</i>
<i>     *</i>
<i>     * @param klass trida ve sledovanem virtualnim stroji Javy</i>
<i>     */</i>
    private static void <strong>printBasicClassInfo</strong>(ReferenceType klass) {
        String className = klass.name();
        String classSignature = klass.signature();
        String genericSignature = klass.genericSignature();
        String sourceName = getClassSourceName(klass);
&nbsp;
        System.out.println("Class " + className);
        System.out.println("    Signature:         " + classSignature);
        System.out.println("    Generic signature: " + (genericSignature == null ? "not present" : genericSignature));
        System.out.println("    Source:            " + sourceName);
    }
</pre>

<p>Poslední obecnou informací, která se zji¹»uje pro zkoumanou tøídu, je jméno
zdrojového souboru s&nbsp;definicí tøídy. Toto jméno nemusí být
v&nbsp;nìkterých pøípadech dostupné, napøíklad tehdy, pokud se jedná o pole
libovolného typu, tj.&nbsp;napøíklad o tøídu <strong>String[]</strong> apod.
V&nbsp;takovém pøípadì se namísto skuteèného jména zdrojového souboru vrátí
øetìzec "unknown". V&nbsp;rozhraní <i>JDI</i> nelze pøímo zjistit, zda je jméno
zdrojového souboru dostupné, jinak, ne¾ zachycením výjimky:</p>

<pre>
<i>    /**</i>
<i>     * Zjisteni jmena zdrojoveho souboru.</i>
<i>     *</i>
<i>     * @param klass trida ve sledovanem virtualnim stroji Javy</i>
<i>     * @return jmeno zdrojoveho souboru</i>
<i>     */</i>
    private static String <strong>getClassSourceName</strong>(ReferenceType klass) {
        String sourceName;
        try {
            sourceName = klass.sourceName();
        }
        catch (AbsentInformationException e) {
            sourceName = "unknown";
        }
        return sourceName;
    }
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Výpis informací o v¹ech atributech tøídy</h2>

<p>Dal¹í dùle¾itou a zajímavou metodou pou¾itou v&nbsp;dne¹ním demonstraèním
pøíkladu je metoda s&nbsp;názvem <strong>printClassFields()</strong>, která
slou¾í k&nbsp;výpisu informací o v¹ech atributech zkoumané tøídy. Atributy jsou
získány s&nbsp;vyu¾itím metody
<strong>com.sun.jdi.ReferenceType.allFields()</strong> vracející seznam objektù
typu <strong>com.sun.jdi.Field</strong>. Tyto objekty mají spoleèné rozhraní
<strong>com.sun.jdi.TypeComponent</strong> a
<strong>com.sun.jdi.Accessible</strong> s&nbsp;objekty typu
<strong>com.sun.jdi.Method</strong>, èeho¾ vyu¾ijeme pozdìji. Jaké informace
v¹ak lze o atributech tøídy získat? Jedná se samozøejmì o jméno atributu, dále
pak o typ atributu (popø.&nbsp;v&nbsp;na¹em pøípadì o jméno typu) a
v&nbsp;neposlední øadì takté¾ o prakticky v¹echny modifikátory atributu &ndash;
<strong>static</strong>, <strong>final</strong>, <strong>transient</strong>,
<strong>volatile</strong> &ndash; i o pøístupová práva k&nbsp;atributùm &ndash;
<strong>public</strong>, <strong>protected</strong>, <strong>private</strong> a
(<strong>package protected</strong>):</p>

<pre>
<i>    /**</i>
<i>     * Vypis informaci o vsech atributech tridy.</i>
<i>     *</i>
<i>     * @param klass trida ve sledovanem virtualnim stroji Javy</i>
<i>     */</i>
    private static void <strong>printClassFields</strong>(ReferenceType klass) {
        System.out.println("    Fields:");
        List&lt;Field&gt; fields = klass.allFields();
&nbsp;
<i>        // projit vsemi atributy</i>
        for (Field field : fields) {
            String name = field.name();
            String type = field.typeName();
            String accessibilityStr = getAccessibility(field);
            String staticStr = field.isStatic() ? "static " : "";
            String finalStr = field.isFinal() ? "final " : "";
            String transientStr = field.isTransient() ? "transient " : "";
            String volatileStr = field.isVolatile() ? "volatile " : "";
&nbsp;
            System.out.format("        %s%s%s%s%s%s %s; \n",
                    accessibilityStr, staticStr, finalStr,
                    transientStr, volatileStr, type, name);
        }
    }
</pre>

<p>Mimochodem &ndash; je zajímavé, jak modifikátory a pøístupová práva atributù
získaná pøes rozhraní <i>JDI</i> korespondují s&nbsp;informacemi o atributech
ulo¾ených pøímo v&nbsp;bajtkódu dané tøídy, co¾ bylo téma podrobnìji popsané ve
ètvrté èásti tohoto seriálu v&nbsp;kapitolách <a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-4-cast-dokonceni-popisu-struktury-souboru-class/#k03">3</a>
a <a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-4-cast-dokonceni-popisu-struktury-souboru-class/#k03">4</a>:</p>

<table>
<tr><th>#</th><th>Název masky	</th><th>Hodnota</th><th>Význam, pokud je maska nastavena</th></tr>
<tr><td>1</td><td>ACC_PUBLIC	</td><td>0x0001	</td><td>veøejná datová polo¾ka dostupná vnì tøídy i vnì balíèku</td></tr>
<tr><td>2</td><td>ACC_PRIVATE	</td><td>0x0002	</td><td>privátní datová polo¾ka dostupná pouze uvnitø tøídy</td></tr>
<tr><td>3</td><td>ACC_PROTECTED	</td><td>0x0004	</td><td>chránìná datová polo¾ka dostupná uvnitø tøídy, z pøípadných odvozených tøíd i v rámci celého balíèku</td></tr>
<tr><td>4</td><td>ACC_STATIC	</td><td>0x0008	</td><td>statická datová polo¾ka, mù¾e se kombinovat s pøedchozí trojicí pøíznakù</td></tr>
<tr><td>5</td><td>ACC_FINAL	</td><td>0x0010	</td><td>finální datová polo¾ka</td></tr>
<tr><td>6</td><td>ACC_VOLATILE	</td><td>0x0040	</td><td>pøíznak volatile - hodnota se v¾dy pøeète èi zapí¹e do pamìti (nezùstane ulo¾ena pouze v registrech)</td></tr>
<tr><td>7</td><td>ACC_TRANSIENT	</td><td>0x0080	</td><td>pøíznak transient - nebude se zpracovávat pøi (de)serializaci objektu</td></tr>
<tr><td>8</td><td>ACC_SYNTHETIC	</td><td>0x1000	</td><td>syntetická datová polo¾ka, která nemá svùj protìj¹ek ve zdrojovém kódu (je generována pøekladaèem)</td></tr>
<tr><td>9</td><td>ACC_ENUM	</td><td>0x4000	</td><td>jedná se o prvek výètového typu</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. Výpis informací o v¹ech metodách tøídy</h2>

<p>Podobným zpùsobem, jakým jsme získali informace o v¹ech atributech sledované
tøídy, je mo¾né pøeèíst i informace o jejích metodách. S&nbsp;vyu¾itím rozhraní
<i>JDI</i> lze pøeèíst jméno metody, její návratový typ (popø.&nbsp;jméno
návratového typu, co¾ je pro nás jednodu¹¹í a pøedev¹ím dostaèující),
modifikátory metody (<strong>static</strong>, <strong>final</strong>,
<strong>native</strong>, <strong>synchronized</strong>) a samozøejmì i
modifikátory pøístupu k&nbsp;metodì, tj.&nbsp;<strong>public</strong>,
<strong>private</strong>, <strong>protected</strong> a nepøímo i
<strong>package protected</strong> (implicitní modifikátor). Samostatnì je
implementován výpis v¹ech parametrù metody, co¾ je téma podrobnìji popsané a¾
<a href="#k06">v&nbsp;¹esté kapitole</a>:</p>

<pre>
<i>    /**</i>
<i>     * Vypis informaci o vsech metodach tridy.</i>
<i>     *</i>
<i>     * @param klass trida ve sledovanem virtualnim stroji Javy</i>
<i>     */</i>
    private static void <strong>printClassMethods</strong>(ReferenceType klass) {
        System.out.println("    Methods:");
        List&lt;Method&gt; methods = klass.allMethods();
<i>        // projit vsemi metodami</i>
        for (Method method : methods) {
            String name = method.name();
            String type = method.returnTypeName();
            String accessibilityStr = getAccessibility(method);
            String staticStr = method.isStatic() ? "static " : "";
            String finalStr = method.isFinal() ? "final " : "";
            String nativeStr = method.isNative() ? "native " : "";
            String synchronizedStr = method.isSynchronized() ? "synchronized " : "";
            System.out.format("        %s%s%s%s%s%s %s",
                    accessibilityStr, staticStr, finalStr,
                    nativeStr, synchronizedStr, type, name);
            printMethodArguments(method);
        }
    }
</pre>

<p>V&nbsp;metodách <strong>printClassFields()</strong> i
<strong>printClassMethods()</strong> implementovaných v&nbsp;dne¹ním
demonstraèním pøíkladu bylo mj.&nbsp;nutné zjistit i modifikátory pøístupu
k&nbsp;metodám a k&nbsp;atributùm zkoumané tøídy. Vzhledem k&nbsp;tomu, ¾e
metody zkoumané tøídy jsou v&nbsp;debuggeru reprezentovány objekty typu
<strong>com.sun.jdi.Method</strong> a atributy jsou reprezentovány objekty typu
<strong>com.sun.jdi.Field</strong>, které mají spoleèné rozhraní
<strong>com.sun.jdi.Accessible</strong>, je implementace metody
<strong>getAccessibility()</strong>  (vracející textovou podobu modifikátorù)
velmi jednoduchá a hlavnì spoleèná jak pro atributy, tak i pro metody sledované
tøídy:</p>

<pre>
<i>    /**</i>
<i>     * Pristupova prava k atributu ci k metode.</i>
<i>     */</i>
    private static String <strong>getAccessibility</strong>(Accessible methodOrField) {
        if (methodOrField.isPublic()) {
            return "public ";
        }
        if (methodOrField.isProtected()) {
            return "protected ";
        }
        if (methodOrField.isPrivate()) {
            return "private ";
        }
        return "";
    }
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Získání jmen a typù argumentù metod</h2>

<p>U metod zkoumané tøídy je nutné zjistit a vypsat je¹tì jednu dùle¾itou
informaci. Jedná se o seznam argumentù metody. V&nbsp;závislosti na tom, zda
byl bajtkód zkoumané tøídy pøelo¾en s&nbsp;pøepínaèem <strong>-g</strong> èi
bez tohoto modifikátoru, lze o argumentech zjistit buï pouze informaci o typech
jednotlivých argumentù, popø.&nbsp;i jména argumentù &ndash; v&nbsp;tomto
pøípadì je v¹ak nutné provést pøeklad s&nbsp;pøepínaèem <strong>-g</strong>,
jinak se tato informace do bajtkódu neulo¾í, proto¾e ji virtuální stroj Javy ve
skuteènosti nepotøebuje. S&nbsp;vyu¾itím rozhraní <i>JDI</i> nelze snadno
zjistit, které informace o argumentech metod jsou k&nbsp;dispozici, proto je
kód metody nazvané <strong>printMethodArguments()</strong> rozdìlen na dvì
èásti. V&nbsp;první èásti umístìné v&nbsp;bloku <strong>try {}</strong> se
zji¹»ují jak jména, tak i typy argumentù, v&nbsp;èásti umístìné v&nbsp;bloku
<strong>catch {}</strong> pak pouze typy argumentù metody, nebo» tyto informace
má JVM k&nbsp;dispozici v¾dy. Výjimka, která rozhodne o pou¾ití prvního èi
druhého bloku, je vyhozena z&nbsp;metody <strong>Method.arguments()</strong>
umístìné jako první pøíkaz v&nbsp;bloku <strong>try{}</strong>:</p>

<pre>
<i>    /**</i>
<i>     * Vypis argumentu metody.</i>
<i>     *</i>
<i>     * @param method metoda ve sledovanem virtualnim stroji</i>
<i>     */</i>
    private static void <strong>printMethodArguments</strong>(Method method) {
        System.out.print("(");
        boolean first = true;
&nbsp;
        try {
<i>            // idealni je zjistit jmena i typy argumentu</i>
            List&lt;LocalVariable&gt; arguments = method.arguments();
&nbsp;
<i>            // vypsat typy a jmena vsech argumentu metody</i>
            for (LocalVariable argument : arguments) {
                if (first) {
                    first = false;
                }
                else {
                    System.out.print(", ");
                }
                System.out.print(argument.typeName() + " " + argument.name());
            }
        }
        catch (AbsentInformationException e) {
<i>            // pokud jmena argumentu nelze zjistit, jejich typy jsou vzdy k dispozici</i>
            List&lt;String&gt; arguments = method.argumentTypeNames();
&nbsp;
<i>            // vypsat typy vsech argumentu metody</i>
            for (String argument : arguments) {
                if (first) {
                    first = false;
                }
                else {
                    System.out.print(", ");
                }
                System.out.print(argument);
            }
        }
        System.out.println(");");
    }
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Kompletní zdrojový kód demonstraèního pøíkladu <strong>JDIAllClassesList</strong></h2>

<p>V&nbsp;pøedchozích kapitolách byly popsány ty nejdùle¾itìj¹í a
nejzajímavìj¹í metody, které jsou souèástí dne¹ního demonstraèního pøíkladu
nazvaného <strong>JDIAllClassesList</strong>. Pod tímto odstavcem je vypsán
celý zdrojový kód tohoto pøíkladu; jeho originální verzi pak lze najít <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">v&nbsp;Mercurial
repositáøi</a> popsaném <a href="#k09">v&nbsp;deváté kapitole</a>:</p>

<pre>
import java.io.IOException;
import java.util.List;
import java.util.Map;
&nbsp;
import com.sun.jdi.AbsentInformationException;
import com.sun.jdi.Accessible;
import com.sun.jdi.Bootstrap;
import com.sun.jdi.Field;
import com.sun.jdi.LocalVariable;
import com.sun.jdi.Method;
import com.sun.jdi.ReferenceType;
import com.sun.jdi.VirtualMachine;
import com.sun.jdi.VirtualMachineManager;
import com.sun.jdi.connect.AttachingConnector;
import com.sun.jdi.connect.Connector;
import com.sun.jdi.connect.IllegalConnectorArgumentsException;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Pripojeni k bezicimu virtualnimu stroji Javy,</i>
<i> * ktery byl spusten s parametry:</i>
<i> * java -agentlib:jdwp=transport=dt_socket,server=y,address=6502,suspend=y Trida</i>
<i> *</i>
<i> * Po pripojeni se vypisou vsechny tridy nactene do sledovaneho virtualniho stroje,</i>
<i> * pricemz jmena trid (ktere maji byt vypsany) jsou vyfiltrovany na zaklade retezcu</i>
<i> * ulozenych v konstante {@link JDIAllClassesList#CLASS_NAME_FILTERS}.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>JDIAllClassesList</strong> {
&nbsp;
<i>    /**</i>
<i>     * Navratovy kod pouzity pri ukoncovani sledovane JVM.</i>
<i>     */</i>
    private static final int <strong>EXIT_VALUE</strong> = 0;
&nbsp;
<i>    /**</i>
<i>     * Jmeno konektoru, ktery pro pripojeni pouziva sockety.</i>
<i>     */</i>
    private static final String <strong>SOCKET_ATTACH_CONNECTOR_NAME</strong> = "com.sun.jdi.SocketAttach";
&nbsp;
<i>    /**</i>
<i>     * Filtr, pomoci nehoz jsou vybrany pouze tridy urciteho jmena.</i>
<i>     */</i>
    private static final String[] <strong>CLASS_NAME_FILTERS</strong> = {
        "String",
        "Test"
    };
&nbsp;
<i>    /**</i>
<i>     * Vstupni metoda debuggeru.</i>
<i>     */</i>
    public static void <strong>main</strong>(String[] args) {
<i>        // ziskat (jedinou) instanci tridy VirtualMachineManager</i>
        VirtualMachineManager virtualMachineManager = Bootstrap.virtualMachineManager();
&nbsp;
<i>        // ziskat vsechny konektory pouzite pro pripojeni k bezici JVM</i>
        List&lt;AttachingConnector&gt; connectors = virtualMachineManager.attachingConnectors();
&nbsp;
<i>        // potrebujeme ziskat konektor pouzivajici pro pripojeni sockety</i>
        AttachingConnector connector = getSocketAttachConnector(connectors);
&nbsp;
        if (connector == null) {
            System.out.println("Socket connector is not available");
            return;
        }
&nbsp;
        debugVirtualMachineUsingSocket(connector);
    }
&nbsp;
<i>    /**</i>
<i>     * Ziskat konektor pouzivajici pro pripojeni sockety</i>
<i>     */</i>
    private static AttachingConnector <strong>getSocketAttachConnector</strong>(List&lt;AttachingConnector&gt; connectors) {
        for (AttachingConnector connector : connectors) {
            if (SOCKET_ATTACH_CONNECTOR_NAME.equals(connector.name())) {
                return connector;
            }
        }
<i>        // nenasli jsme zadny vhodny konektor</i>
        return null;
    }
&nbsp;
<i>    /**</i>
<i>     * Pripojeni k bezicimu virtualnimu stroji pres socket.</i>
<i>     * @throws InterruptedException </i>
<i>     */</i>
    private static void <strong>debugVirtualMachineUsingSocket</strong>(AttachingConnector connector) {
<i>        // nastaveni argumentu pouzivanych konektorem</i>
        Map&lt;String, Connector.Argument&gt; arguments = prepareConnectorArguments(connector);
&nbsp;
        try {
<i>            // pripojeni ke vzdalenemu bezicimu virtualnimu stroji Javy</i>
            VirtualMachine virtualMachine = connectToVirtualMachine(connector, arguments);
&nbsp;
<i>            // spustit sledovany virtualni stroj po dobu jedne sekundy</i>
            runVirtualMachineForOneSecond(virtualMachine);
&nbsp;
<i>            // vypis vsech vybranych trid nactenych ve sledovanem virtualnim stroji</i>
            printFilteredClassList(virtualMachine);
&nbsp;
<i>            // ukonceni behu vzdaleneho virtualniho stroje</i>
            shutdownVirtualMachine(virtualMachine);
        }
        catch (IOException e) {
            e.printStackTrace();
        }
        catch (IllegalConnectorArgumentsException e) {
            e.printStackTrace();
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Nastaveni portu na cilove JVM, jenz debugger pouzije pro navazani spojeni.</i>
<i>     *</i>
<i>     * @param connector konektor pouzity pro pripojeni</i>
<i>     * @return mapa obsahujici parametry konektoru</i>
<i>     */</i>
    private static Map&lt;String, Connector.Argument&gt; <strong>prepareConnectorArguments</strong>(AttachingConnector connector) {
        Map&lt;String, Connector.Argument&gt; arguments = connector.defaultArguments();
        arguments.get("port").setValue("6502");
        return arguments;
    }
&nbsp;
<i>    /**</i>
<i>     * Pripojeni debuggeru ke sledovanemu virtualnimu stroji.</i>
<i>     *</i>
<i>     * @param connector konektor vyuzivajici pro spojeni sockety</i>
<i>     * @param arguments mapa obsahujici parametry pripojeni</i>
<i>     * @return sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     *</i>
<i>     * @throws IOException vyvolane v pripade, ze se pripojeni k JVM nepodari</i>
<i>     * @throws IllegalConnectorArgumentsException vyvolane v pripade spatne zadanych parametru</i>
<i>     */</i>
    private static VirtualMachine <strong>connectToVirtualMachine</strong>(AttachingConnector connector, Map&lt;String, Connector.Argument&gt; arguments)
        throws IOException, IllegalConnectorArgumentsException {
        System.out.println("Connecting to virtual machine");
        VirtualMachine virtualMachine = connector.attach(arguments);
        System.out.println("Connected");
        return virtualMachine;
    }
&nbsp;
<i>    /**</i>
<i>     * Spustit sledovany virtualni stroj po dobu jedne sekundy</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>runVirtualMachineForOneSecond</strong>(VirtualMachine virtualMachine) {
        virtualMachine.resume();
        try {
            Thread.sleep(1000);
        }
        catch (InterruptedException e) {
            e.printStackTrace();
        }
        virtualMachine.suspend();
    }
&nbsp;
<i>    /**</i>
<i>     * Ukonceni prace beziciho sledovaneho virtualniho stroje.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>shutdownVirtualMachine</strong>(VirtualMachine virtualMachine) {
        System.out.println("Calling exit");
        virtualMachine.exit(EXIT_VALUE);
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis vyfiltrovanych trid nactenych do sledovaneho virtualniho stroje.</i>
<i>     * Filtr se nastavuje pres {@link JDIAllClassesList#CLASS_NAME_FILTERS}</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>printFilteredClassList</strong>(VirtualMachine virtualMachine) {
        List&lt;ReferenceType&gt; allClasses = virtualMachine.allClasses();
&nbsp;
<i>        // projit vsemi tridami, ktere se nachazi ve sledovanem virtualnim stroji</i>
        for (ReferenceType klass : allClasses) {
            String className = klass.name();
<i>            // zjistit, zda se ma tato trida vyfiltrovat ci nikoli</i>
            boolean filterClass = true;
<i>            // jednoduchy filtr</i>
            for (String filter : CLASS_NAME_FILTERS) {
                if (className.contains(filter)) {
                    filterClass = false;
                    break;
                }
            }
<i>            // cast jmena tridy nebyla v CLASS_NAME_FILTERS nalezena</i>
            if (filterClass) {
                continue;
            }
            printClassInfo(klass);
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis vsech relevantnich informaci o vybrane tride.</i>
<i>     *</i>
<i>     * @param klass trida ve sledovanem virtualnim stroji Javy</i>
<i>     */</i>
    private static void <strong>printClassInfo</strong>(ReferenceType klass) {
        printBasicClassInfo(klass);
        printClassFields(klass);
        printClassMethods(klass);
        printSeparator();
    }
&nbsp;
<i>    /**</i>
<i>     * &lt;hr&gt;</i>
<i>     */</i>
    private static void <strong>printSeparator</strong>() {
        System.out.println("-------------------------------------------------------");
    }
&nbsp;
<i>    /**</i>
<i>     * Zakladni informace o tride.</i>
<i>     *</i>
<i>     * @param klass trida ve sledovanem virtualnim stroji Javy</i>
<i>     */</i>
    private static void <strong>printBasicClassInfo</strong>(ReferenceType klass) {
        String className = klass.name();
        String classSignature = klass.signature();
        String genericSignature = klass.genericSignature();
        String sourceName = getClassSourceName(klass);
&nbsp;
        System.out.println("Class " + className);
        System.out.println("    Signature:         " + classSignature);
        System.out.println("    Generic signature: " + (genericSignature == null ? "not present" : genericSignature));
        System.out.println("    Source:            " + sourceName);
    }
&nbsp;
<i>    /**</i>
<i>     * Zjisteni jmena zdrojoveho souboru.</i>
<i>     *</i>
<i>     * @param klass trida ve sledovanem virtualnim stroji Javy</i>
<i>     * @return jmeno zdrojoveho souboru</i>
<i>     */</i>
    private static String <strong>getClassSourceName</strong>(ReferenceType klass) {
        String sourceName;
        try {
            sourceName = klass.sourceName();
        }
        catch (AbsentInformationException e) {
            sourceName = "unknown";
        }
        return sourceName;
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis informaci o vsech atributech tridy.</i>
<i>     *</i>
<i>     * @param klass trida ve sledovanem virtualnim stroji Javy</i>
<i>     */</i>
    private static void <strong>printClassFields</strong>(ReferenceType klass) {
        System.out.println("    Fields:");
        List&lt;Field&gt; fields = klass.allFields();
&nbsp;
<i>        // projit vsemi atributy</i>
        for (Field field : fields) {
            String name = field.name();
            String type = field.typeName();
            String accessibilityStr = getAccessibility(field);
            String staticStr = field.isStatic() ? "static " : "";
            String finalStr = field.isFinal() ? "final " : "";
            String transientStr = field.isTransient() ? "transient " : "";
            String volatileStr = field.isVolatile() ? "volatile " : "";
&nbsp;
            System.out.format("        %s%s%s%s%s%s %s; \n",
                    accessibilityStr, staticStr, finalStr,
                    transientStr, volatileStr, type, name);
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis informaci o vsech metodach tridy.</i>
<i>     *</i>
<i>     * @param klass trida ve sledovanem virtualnim stroji Javy</i>
<i>     */</i>
    private static void <strong>printClassMethods</strong>(ReferenceType klass) {
        System.out.println("    Methods:");
        List&lt;Method&gt; methods = klass.allMethods();
<i>        // projit vsemi metodami</i>
        for (Method method : methods) {
            String name = method.name();
            String type = method.returnTypeName();
            String accessibilityStr = getAccessibility(method);
            String staticStr = method.isStatic() ? "static " : "";
            String finalStr = method.isFinal() ? "final " : "";
            String nativeStr = method.isNative() ? "native " : "";
            String synchronizedStr = method.isSynchronized() ? "synchronized " : "";
            System.out.format("        %s%s%s%s%s%s %s",
                    accessibilityStr, staticStr, finalStr,
                    nativeStr, synchronizedStr, type, name);
            printMethodArguments(method);
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis argumentu metody.</i>
<i>     *</i>
<i>     * @param method metoda ve sledovanem virtualnim stroji</i>
<i>     */</i>
    private static void <strong>printMethodArguments</strong>(Method method) {
        System.out.print("(");
        boolean first = true;
&nbsp;
        try {
<i>            // idealni je zjistit jmena i typy argumentu</i>
            List&lt;LocalVariable&gt; arguments = method.arguments();
&nbsp;
<i>            // vypsat typy a jmena vsech argumentu metody</i>
            for (LocalVariable argument : arguments) {
                if (first) {
                    first = false;
                }
                else {
                    System.out.print(", ");
                }
                System.out.print(argument.typeName() + " " + argument.name());
            }
        }
        catch (AbsentInformationException e) {
<i>            // pokud jmena argumentu nelze zjistit, jejich typy jsou vzdy k dispozici</i>
            List&lt;String&gt; arguments = method.argumentTypeNames();
&nbsp;
<i>            // vypsat typy vsech argumentu metody</i>
            for (String argument : arguments) {
                if (first) {
                    first = false;
                }
                else {
                    System.out.print(", ");
                }
                System.out.print(argument);
            }
        }
        System.out.println(");");
    }
&nbsp;
<i>    /**</i>
<i>     * Pristupova prava k atributu ci k metode.</i>
<i>     */</i>
    private static String <strong>getAccessibility</strong>(Accessible methodOrField) {
        if (methodOrField.isPublic()) {
            return "public ";
        }
        if (methodOrField.isProtected()) {
            return "protected ";
        }
        if (methodOrField.isPrivate()) {
            return "private ";
        }
        return "";
    }
&nbsp;
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Spu¹tìní demonstraèního pøíkladu <strong>JDIAllClassesList</strong></h2>

<p>Dne¹ní demonstraèní pøíklad si vyzkou¹íme spustit proti virtuálnímu stroji,
v&nbsp;nìm¾ pobì¾í testovací aplikace <strong>Test3</strong>, kterou jsme
pou¾ili ji¾ minule. Pøeklad a spu¹tìní této aplikace v&nbsp;cílovém virtuálním
stroji Javy se provede následujícím zpùsobem (dùle¾ité je zde pøedev¹ím èíslo
portu, k&nbsp;nìmu¾ se následnì pøipojíme s&nbsp;vyu¾itím rozhraní
<i>JDI</i>):</p>

<pre>
javac Test3.java
java -agentlib:jdwp=transport=dt_socket,server=y,address=6502,suspend=y Test3
</pre>

<p>Nyní ji¾ zbývá provést pøeklad a spu¹tìní na¹eho demonstraèního pøíkladu
v&nbsp;samostatné JVM:</p>

<pre>
javac -classpath /usr/lib/jvm/java-6-openjdk/lib/tools.jar:. JDIAllClassesList.java
java -cp /usr/lib/jvm/java-6-openjdk/lib/tools.jar:. JDIAllClassesList
</pre>

<p>Po spu¹tìní by se mìl na standardním výstupu objevit pøibli¾nì následující
text obsahující metody a atributy vybraných tøíd. Pov¹imnìte si, ¾e kvùli
pøekladu tøídy <strong>Test3</strong> bez pou¾ití pøepínaèe <strong>-g</strong>
nezískáme jména argumentù metod, ale pouze jejich typy:</p>

<pre>
Connecting to virtual machine
Connected
Class Test3
    Signature:         LTest3;
    Generic signature: not present
    Source:            Test3.java
    Fields:
    Methods:
        public void &lt;init&gt;();
        public void run(int, char);
        public void foo(float);
        public void bar(float, float[], java.lang.String);
        public static void main(java.lang.String[]);
        public void &lt;init&gt;();
        private static native void registerNatives();
        public final native java.lang.Class getClass();
        public native int hashCode();
        public boolean equals(java.lang.Object);
        protected native java.lang.Object clone();
        public java.lang.String toString();
        public final native void notify();
        public final native void notifyAll();
        public final native void wait(long);
        public final void wait(long, int);
        public final void wait();
        protected void finalize();
        static void &lt;clinit&gt;();
-------------------------------------------------------
Class java.lang.String
    Signature:         Ljava/lang/String;
    Generic signature: Ljava/lang/Object;Ljava/io/Serializable;Ljava/lang/Comparable&lt;Ljava/lang/String;&gt;;Ljava/lang/CharSequence;
    Source:            String.java
    Fields:
        private final char[] value; 
        private final int offset; 
        private final int count; 
        private int hash; 
        private static final long serialVersionUID; 
        private static final java.io.ObjectStreamField[] serialPersistentFields; 
        public static final java.util.Comparator CASE_INSENSITIVE_ORDER; 
    Methods:
        public void &lt;init&gt;();
        public void &lt;init&gt;(java.lang.String);
        public void &lt;init&gt;(char[]);
        public void &lt;init&gt;(char[], int, int);
        public void &lt;init&gt;(int[], int, int);
        public void &lt;init&gt;(byte[], int, int, int);
        public void &lt;init&gt;(byte[], int);
        private static void checkBounds(byte[], int, int);
        public void &lt;init&gt;(byte[], int, int, java.lang.String);
        public void &lt;init&gt;(byte[], int, int, java.nio.charset.Charset);
        public void &lt;init&gt;(byte[], java.lang.String);
        public void &lt;init&gt;(byte[], java.nio.charset.Charset);
        public void &lt;init&gt;(byte[], int, int);
        public void &lt;init&gt;(byte[]);
        public void &lt;init&gt;(java.lang.StringBuffer);
        public void &lt;init&gt;(java.lang.StringBuilder);
        void &lt;init&gt;(int, int, char[]);
        public int length();
        public boolean isEmpty();
        public char charAt(int);
        public int codePointAt(int);
        public int codePointBefore(int);
        public int codePointCount(int, int);
        public int offsetByCodePoints(int, int);
        void getChars(char[], int);
        public void getChars(int, int, char[], int);
        public void getBytes(int, int, byte[], int);
        public byte[] getBytes(java.lang.String);
        public byte[] getBytes(java.nio.charset.Charset);
        public byte[] getBytes();
        public boolean equals(java.lang.Object);
        public boolean contentEquals(java.lang.StringBuffer);
        public boolean contentEquals(java.lang.CharSequence);
        public boolean equalsIgnoreCase(java.lang.String);
        public int compareTo(java.lang.String);
        public int compareToIgnoreCase(java.lang.String);
        public boolean regionMatches(int, java.lang.String, int, int);
        public boolean regionMatches(boolean, int, java.lang.String, int, int);
        public boolean startsWith(java.lang.String, int);
        public boolean startsWith(java.lang.String);
        public boolean endsWith(java.lang.String);
        public int hashCode();
        public int indexOf(int);
        public int indexOf(int, int);
        public int lastIndexOf(int);
        public int lastIndexOf(int, int);
        public int indexOf(java.lang.String);
        public int indexOf(java.lang.String, int);
        static int indexOf(char[], int, int, char[], int, int, int);
        public int lastIndexOf(java.lang.String);
        public int lastIndexOf(java.lang.String, int);
        static int lastIndexOf(char[], int, int, char[], int, int, int);
        public java.lang.String substring(int);
        public java.lang.String substring(int, int);
        public java.lang.CharSequence subSequence(int, int);
        public java.lang.String concat(java.lang.String);
        public java.lang.String replace(char, char);
        public boolean matches(java.lang.String);
        public boolean contains(java.lang.CharSequence);
        public java.lang.String replaceFirst(java.lang.String, java.lang.String);
        public java.lang.String replaceAll(java.lang.String, java.lang.String);
        public java.lang.String replace(java.lang.CharSequence, java.lang.CharSequence);
        public java.lang.String[] split(java.lang.String, int);
        public java.lang.String[] split(java.lang.String);
        public java.lang.String toLowerCase(java.util.Locale);
        public java.lang.String toLowerCase();
        public java.lang.String toUpperCase(java.util.Locale);
        public java.lang.String toUpperCase();
        public java.lang.String trim();
        public java.lang.String toString();
        public char[] toCharArray();
        public static java.lang.String format(java.lang.String, java.lang.Object[]);
        public static java.lang.String format(java.util.Locale, java.lang.String, java.lang.Object[]);
        public static java.lang.String valueOf(java.lang.Object);
        public static java.lang.String valueOf(char[]);
        public static java.lang.String valueOf(char[], int, int);
        public static java.lang.String copyValueOf(char[], int, int);
        public static java.lang.String copyValueOf(char[]);
        public static java.lang.String valueOf(boolean);
        public static java.lang.String valueOf(char);
        public static java.lang.String valueOf(int);
        public static java.lang.String valueOf(long);
        public static java.lang.String valueOf(float);
        public static java.lang.String valueOf(double);
        public native java.lang.String intern();
        public int compareTo(java.lang.Object);
        static void &lt;clinit&gt;();
        public void &lt;init&gt;();
        private static native void registerNatives();
        public final native java.lang.Class getClass();
        public native int hashCode();
        public boolean equals(java.lang.Object);
        protected native java.lang.Object clone();
        public java.lang.String toString();
        public final native void notify();
        public final native void notifyAll();
        public final native void wait(long);
        public final void wait(long, int);
        public final void wait();
        protected void finalize();
        static void &lt;clinit&gt;();
        public int compareTo(java.lang.Object);
        public int length();
        public char charAt(int);
        public java.lang.CharSequence subSequence(int, int);
        public java.lang.String toString();
-------------------------------------------------------
</pre>

<p>V&nbsp;pøípadì, ¾e se testovací tøída pøelo¾í i s&nbsp;ladicími
informacemi:</p>

<pre>
javac <strong>-g</strong> Test3.java
java -agentlib:jdwp=transport=dt_socket,server=y,address=6502,suspend=y Test3
</pre>

<p>Získáme po spu¹tìní demonstraèního pøíkladu:</p>

<pre>
java -cp /usr/lib/jvm/java-6-openjdk/lib/tools.jar:. JDIAllClassesList
</pre>

<p>výstup, v&nbsp;nìm¾ budou zobrazena i jména argumentù metod testovací
tøídy:</p>

<pre>
Connecting to virtual machine
Connected
Class Test3
    Signature:         LTest3;
    Generic signature: not present
    Source:            Test3.java
    Fields:
    Methods:
        public void &lt;init&gt;();
        public void run(int value, char znak);
        public void foo(float value);
        public void bar(float value, float[] array, java.lang.String message);
        public static void main(java.lang.String[] args);
        public void &lt;init&gt;();
        private static native void registerNatives();
        public final native java.lang.Class getClass();
        public native int hashCode();
        public boolean equals(java.lang.Object);
        protected native java.lang.Object clone();
        public java.lang.String toString();
        public final native void notify();
        public final native void notifyAll();
        public final native void wait(long);
        public final void wait(long, int);
        public final void wait();
        protected void finalize();
        static void &lt;clinit&gt;();
-------------------------------------------------------
Class java.lang.String
    Signature:         Ljava/lang/String;
    Generic signature: Ljava/lang/Object;Ljava/io/Serializable;Ljava/lang/Comparable&lt;Ljava/lang/String;&gt;;Ljava/lang/CharSequence;
    Source:            String.java
    Fields:
        private final char[] value; 
        private final int offset; 
        private final int count; 
        private int hash; 
        private static final long serialVersionUID; 
        private static final java.io.ObjectStreamField[] serialPersistentFields; 
        public static final java.util.Comparator CASE_INSENSITIVE_ORDER; 
    Methods:
        public void &lt;init&gt;();
        public void &lt;init&gt;(java.lang.String);
        public void &lt;init&gt;(char[]);
        public void &lt;init&gt;(char[], int, int);
        public void &lt;init&gt;(int[], int, int);
        public void &lt;init&gt;(byte[], int, int, int);
        public void &lt;init&gt;(byte[], int);
        private static void checkBounds(byte[], int, int);
        public void &lt;init&gt;(byte[], int, int, java.lang.String);
        public void &lt;init&gt;(byte[], int, int, java.nio.charset.Charset);
        public void &lt;init&gt;(byte[], java.lang.String);
        public void &lt;init&gt;(byte[], java.nio.charset.Charset);
        public void &lt;init&gt;(byte[], int, int);
        public void &lt;init&gt;(byte[]);
        public void &lt;init&gt;(java.lang.StringBuffer);
        public void &lt;init&gt;(java.lang.StringBuilder);
        void &lt;init&gt;(int, int, char[]);
        public int length();
        public boolean isEmpty();
        public char charAt(int);
        public int codePointAt(int);
        public int codePointBefore(int);
        public int codePointCount(int, int);
        public int offsetByCodePoints(int, int);
        void getChars(char[], int);
        public void getChars(int, int, char[], int);
        public void getBytes(int, int, byte[], int);
        public byte[] getBytes(java.lang.String);
        public byte[] getBytes(java.nio.charset.Charset);
        public byte[] getBytes();
        public boolean equals(java.lang.Object);
        public boolean contentEquals(java.lang.StringBuffer);
        public boolean contentEquals(java.lang.CharSequence);
        public boolean equalsIgnoreCase(java.lang.String);
        public int compareTo(java.lang.String);
        public int compareToIgnoreCase(java.lang.String);
        public boolean regionMatches(int, java.lang.String, int, int);
        public boolean regionMatches(boolean, int, java.lang.String, int, int);
        public boolean startsWith(java.lang.String, int);
        public boolean startsWith(java.lang.String);
        public boolean endsWith(java.lang.String);
        public int hashCode();
        public int indexOf(int);
        public int indexOf(int, int);
        public int lastIndexOf(int);
        public int lastIndexOf(int, int);
        public int indexOf(java.lang.String);
        public int indexOf(java.lang.String, int);
        static int indexOf(char[], int, int, char[], int, int, int);
        public int lastIndexOf(java.lang.String);
        public int lastIndexOf(java.lang.String, int);
        static int lastIndexOf(char[], int, int, char[], int, int, int);
        public java.lang.String substring(int);
        public java.lang.String substring(int, int);
        public java.lang.CharSequence subSequence(int, int);
        public java.lang.String concat(java.lang.String);
        public java.lang.String replace(char, char);
        public boolean matches(java.lang.String);
        public boolean contains(java.lang.CharSequence);
        public java.lang.String replaceFirst(java.lang.String, java.lang.String);
        public java.lang.String replaceAll(java.lang.String, java.lang.String);
        public java.lang.String replace(java.lang.CharSequence, java.lang.CharSequence);
        public java.lang.String[] split(java.lang.String, int);
        public java.lang.String[] split(java.lang.String);
        public java.lang.String toLowerCase(java.util.Locale);
        public java.lang.String toLowerCase();
        public java.lang.String toUpperCase(java.util.Locale);
        public java.lang.String toUpperCase();
        public java.lang.String trim();
        public java.lang.String toString();
        public char[] toCharArray();
        public static java.lang.String format(java.lang.String, java.lang.Object[]);
        public static java.lang.String format(java.util.Locale, java.lang.String, java.lang.Object[]);
        public static java.lang.String valueOf(java.lang.Object);
        public static java.lang.String valueOf(char[]);
        public static java.lang.String valueOf(char[], int, int);
        public static java.lang.String copyValueOf(char[], int, int);
        public static java.lang.String copyValueOf(char[]);
        public static java.lang.String valueOf(boolean);
        public static java.lang.String valueOf(char);
        public static java.lang.String valueOf(int);
        public static java.lang.String valueOf(long);
        public static java.lang.String valueOf(float);
        public static java.lang.String valueOf(double);
        public native java.lang.String intern();
        public int compareTo(java.lang.Object);
        static void &lt;clinit&gt;();
        public void &lt;init&gt;();
        private static native void registerNatives();
        public final native java.lang.Class getClass();
        public native int hashCode();
        public boolean equals(java.lang.Object);
        protected native java.lang.Object clone();
        public java.lang.String toString();
        public final native void notify();
        public final native void notifyAll();
        public final native void wait(long);
        public final void wait(long, int);
        public final void wait();
        protected void finalize();
        static void &lt;clinit&gt;();
        public int compareTo(java.lang.Object);
        public int length();
        public char charAt(int);
        public java.lang.CharSequence subSequence(int, int);
        public java.lang.String toString();
-------------------------------------------------------
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Repositáø se zdrojovými kódy demonstraèního pøíkladu <strong>JDIAllClassesList</strong> i podpùrných skriptù</h2>

<p>Zdrojové kódy dne¹ního demonstraèního pøíkladu
<strong>JDIAllClassesList</strong>, testovací tøídy <strong>Test3</strong> i
skriptù pou¾itých pro spu¹tìní tohoto demonstraèního pøíkladu, byly ulo¾eny
(podobnì jako tomu bylo i v&nbsp;mnoha pøedchozích èástech tohoto seriálu) do
Mercurial repositáøe dostupného na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
Navíc byly do repositáøe dodány i výsledky bìhu tohoto pøíkladu oproti tøídì
<strong>Test3</strong> pøelo¾ené bez pøidání ladicích informací i
s&nbsp;ladicími informacemi (jedná se o soubory
<i>JDIAllClassesList_debug.txt</i> a <i>JDIAllClassesList_nodebug.txt</i>).
Prozatím nejnovìj¹í verze v¹ech zmínìných zdrojových souborù a skriptù mù¾ete
najít na adresách:</p>

<table>
<tr><th>#</th><th>Zdrojový soubor/skript</th><th>Umístìní souboru v&nbsp;repositáøi</th></tr>
<tr><td>1</td><td>JDIAllClassesList.java       </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/22bec18f2089/jdi/JDIAllClassesList.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/22bec18f2089/jdi/JDIAllClassesList.java</a></td></tr>
<tr><td>2</td><td>JDIAllClassesList_debug.txt</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/22bec18f2089/jdi/JDIAllClassesList_debug.txt">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/22bec18f2089/jdi/JDIAllClassesList_debug.txt</a></td></tr>
<tr><td>3</td><td>JDIAllClassesList_nodebug.txt</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/22bec18f2089/jdi/JDIAllClassesList_nodebug.txt">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/22bec18f2089/jdi/JDIAllClassesList_nodebug.txt</a></td></tr>
<tr><td>4</td><td>Test3.java                   </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/773bb88e02b6/jdi/Test3.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/773bb88e02b6/jdi/Test3.java</a></td></tr>
<tr><td>5</td><td>Test3.sh                     </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/773bb88e02b6/jdi/Test3.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/773bb88e02b6/jdi/Test3.sh</a></td></tr>
</table>



<p><a name="k10"></a></p>
<h2 id="k10">10. Odkazy na Internetu</h2>

<ol>

<li>Class com.sun.jdi.Bootstrap<br />
<a href="http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/package-tree.html">http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/package-tree.html</a>
</li>

<li>Interface com.sun.jdi.VirtualMachine<br />
<a href="http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/VirtualMachine.html">http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/VirtualMachine.html</a>
</li>

<li>Interface com.sun.jdi.Field<br />
<a href="http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/Field.html">http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/Field.html</a>
</li>

<li>Interface com.sun.jdi.ReferenceType<br />
<a href="http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/ReferenceType.html">http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/ReferenceType.html</a>
</li>

<li>Interface com.sun.jdi.TypeComponent<br />
<a href="http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/TypeComponent.html">http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/TypeComponent.html</a>
</li>

<li>Interface com.sun.jdi.Accessible<br />
<a href="http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/Accessible.html">http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/Accessible.html</a>
</li>

<li>Breakpoint (Wikipedia)<br />
<a href="http://cs.wikipedia.org/wiki/Breakpoint">http://cs.wikipedia.org/wiki/Breakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation<br />
<a href="http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html">http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; SetBreakpoint<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#SetBreakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#SetBreakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; ClearBreakpoint<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#ClearBreakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#ClearBreakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; Breakpoint (callback funkce)<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#Breakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#Breakpoint</a>
</li>

<li>The JVM Tool Interface (JVM TI): How VM Agents Work<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html">http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html</a>
</li>

<li>Creating a Debugging and Profiling Agent with JVMTI<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html">http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html</a>
</li>

<li>JVM TI (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/JVM_TI">http://en.wikipedia.org/wiki/JVM_TI</a>
</li>

<li>IBM JVMTI extensions<br />
<a href="http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html">http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

