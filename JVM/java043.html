<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Clojure 12: pøeklad programù z Clojure do bajtkódu JVM</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Clojure 12: pøeklad programù z Clojure do bajtkódu JVM</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o virtuálním stroji Javy se seznámíme se zpùsobem pøekladu aplikací napsaných v programovacím jazyce Clojure do bajtkódu JVM. V prùbìhu vývoje programù je sice vìt¹inou vhodné pou¾ívat interaktivní interpret Clojure, ov¹em výsledná aplikace se lépe dodává a nasazuje do produkce napøíklad ve formì Java archivu (JAR).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyk Clojure 12: pøeklad programù napsaných v&nbsp;Clojure do bajtkódu JVM</a></p>
<p><a href="#k02">2. Jednoduché datové typy Clojure</a></p>
<p><a href="#k03">3. Strukturované datové typy &ndash; kolekce</a></p>
<p><a href="#k04">4. Práce s&nbsp;poli programovacího jazyka Java</a></p>
<p><a href="#k05">5. Zjednodu¹ená konstrukce polí</a></p>
<p><a href="#k06">6. Pøístup k&nbsp;prvkùm polí</a></p>
<p><a href="#k07">7. Pøeklad funkcí Clojure do bajtkódu JVM</a></p>
<p><a href="#k08">8. Obsah vygenerovaných souborù <strong>.class</strong></a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk Clojure 12: pøeklad programù napsaných v&nbsp;Clojure do bajtkódu JVM</h2>

<p>V&nbsp;dne¹ní èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o Javì
i o virtuálním stroji Javy</a> si øekneme, jakým zpùsobem se aplikace napsané
v&nbsp;programovacím jazyku <i>Clojure</i> mohou pøelo¾it do bajtkódu JVM.
Výsledkem pøekladu programù napsaných v&nbsp;<i>Clojure</i> je ve v¹ech
pøípadech bajtkód (ulo¾ený v&nbsp;souborech s&nbsp;koncovkou
<strong>.class</strong>), jen¾ je pou¾itelný na prakticky libovolném virtuálním
stroji Javy, co¾ mù¾e být ponìkud pøekvapivé, kdy¾ si uvìdomíme, ¾e
<i>Clojure</i> je &ndash; na rozdíl od Javy &ndash; funkcionální a dynamicky
typovaný programovací jazyk. Nicménì právì na pøíkladu <i>Clojure</i> je mo¾né
ukázat, ¾e bajtkód JVM lze kupodivu vyu¾ít i tímto ponìkud netypickým zpùsobem.
Pøi vývoji nových aplikací vìt¹inou není nutné se nijak zabývat pøekladem
jednotlivých zapisovaných forem (vyhodnocovaných výrazù), proto¾e tento pøeklad
za nás automaticky provádí samotný interpret jazyka <i>Clojure</i> &ndash;
formy a tím pádem i programy tudí¾ nejsou pøímo interpretovány, ale nejdøíve
jsou pøelo¾eny do bajtkódu a posléze spu¹tìny (bajtkód se v&nbsp;tomto pøípadì
dynamicky zavádí do JVM, není tedy nutné generovat externí soubory
<strong>.class</strong>).</p>

<p>Ov¹em ve chvíli, kdy se má aplikace nainstalovat na poèítaèe klientù èi
napøíklad nasadit na aplikaèní server, je vhodnìj¹í dodat administrátorùm ji¾
pøelo¾ené soubory <strong>.class</strong> nebo je¹tì lépe Javovský èi webový
archiv s&nbsp;aplikací (.jar, .war). Je¹tì ne¾ se budeme zabývat vlastním
zpùsobem pøekladu programù z&nbsp;Clojure do bajtkódu, musíme si øíci (a
èásteènì tak zopakovat ji¾ v&nbsp;pøedchozích èláncích zmínìné informace),
jakým zpùsobem jsou reprezentována data, s&nbsp;nimi¾ se v&nbsp;<i>Clojure</i>
pracuje. Vzhledem k&nbsp;tomu, ¾e programy v&nbsp;<i>Clojure</i> jsou
pøekládány do bajtkódu (a» ji¾ explicitnì na ¾ádost programátora èi implicitnì
interpretrem), musí jakýkoli objekt, s&nbsp;ním¾ se v&nbsp;aplikaci pracuje,
mít i odpovídající rozhraní èi tøídu v&nbsp;Javì, proto¾e v&nbsp;JVM se pro
volání metod pou¾ívají instrukce vypsané v&nbsp;následující tabulce, které
vy¾adují, aby existovala jednoznaèná <strong>signatura</strong> volané metody,
v&nbsp;ní¾ jsou mj.&nbsp;zapsány i typy pøedávaných parametrù a souèasnì i typ
návratové hodnoty:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Provádìná operace</th></tr>
<tr><td>1</td><td>invokestatic</td><td>0xB8</td><td>highbyte, lowbyte</td><td>zavolání statické metody s&nbsp;pøedáním parametrù této metodì</td></tr>
<tr><td>2</td><td>invokevirtual</td><td>0xB6</td><td>highbyte, lowbyte</td><td>zavolání nestatické metody s&nbsp;pøedáním hodnoty <strong>this</strong> a v¹ech dal¹ích parametrù</td></tr>
<tr><td>3</td><td>invokespecial</td><td>0xB7</td><td>highbyte, lowbyte</td><td>zavolání speciální metody, vìt¹inou konstruktoru</td></tr>
<tr><td>4</td><td>invokeinterface</td><td>0xB9</td><td>highbyte, lowbyte, count</td><td>zavolání metody deklarované v&nbsp;rozhraní, samozøejmì s&nbsp;pøedáním parametrù</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Jednoduché datové typy Clojure</h2>

<p>V&nbsp;pøedchozích èástech tohoto seriálu jsme si øekli, jakým zpùsobem se
v&nbsp;programovacím jazyku <i>Clojure</i> pracuje se základními datovými typy,
které jsou nedílnou souèástí tohoto jazyka, resp.&nbsp;pøesnìji øeèeno jsou
souèástí jeho jádra, i kdy¾ to je relativnì snadno modifikovatelné. Jedná se o
jednoduché datové typy, mezi nì¾ patøí napøíklad numerické hodnoty (ty se dále
dìlí na celá èísla, èísla s&nbsp;plovoucí øádovou èárkou, zlomky a èísla typu
<i>BigDecimal</i> a <i>BigInt</i> &ndash; viz dal¹í text), pravdivostní
hodnoty, øetìzce, jednotlivé znaky a takté¾ takzvané klíèe (<i>keywords</i>).
Hodnotu jakéhokoli zmínìného jednoduchého datového typu lze získat buï zápisem
jejího literálu (tj.&nbsp;z&nbsp;jazykového hlediska &bdquo;konstanty&ldquo;),
popø.&nbsp;ji lze získat ve formì výsledku nìjaké funkce nebo speciální formy.
Vzhledem k&nbsp;tomu, ¾e hodnoty jednoduchých datových typù lze pou¾ít jako
parametry pøi volání metod javovských tøíd èi je naopak získat jako výsledek
volání nìjaké metody, je v&nbsp;následující tabulce zapsáno i jméno pøíslu¹ného
rozhraní (<i>interface</i>) èi pøímo implementované tøídy programovacího jazyka
Java:</p>

<table>
<tr><th>#</th><th>Typ      </th><th>Literál v&nbsp;Clojure</th><th>Implementovaná tøída èi rozhraní v Javì</th></tr>
<tr><td>1</td><td>Boolean  </td><td>true</td><td>java.lang.Boolean</td></tr>
<tr><td>2</td><td>Number   </td><td>42</td><td>java.lang.Number</td></tr>
<tr><td>3</td><td>String   </td><td>"string"</td><td>java.lang.String</td></tr>
<tr><td>4</td><td>Character</td><td>\x</td><td>java.lang.Character</td></tr>
<tr><td>5</td><td>Keyword  </td><td>:klíè</td><td>clojure.lang.Keyword</td></tr>
</table>

<p>Z&nbsp;pøedchozí tabulky vyplývá, ¾e numerické hodnoty jsou v¾dy
reprezentovány objektem, který je instancí tøídy implementující rozhraní
<strong>java.lang.Number</strong>. O jaké konkrétní tøídy se jedná nám prozradí
druhá tabulka umístìná pod tímto odstavcem. Za zmínku stojí pøedev¹ím fakt, ¾e
tvùrci programovacího jazyka <i>Clojure</i> preferují vyu¾ívání co nejmen¹ího
mno¾ství javovských tøíd (èi spí¹e jejich instancí), tak¾e se nesetkáme
napøíklad s&nbsp;instancemi tøíd <strong>java.lang.Short</strong>,
<strong>java.lang.Integer</strong> èi <strong>java.lang.Float</strong>, co¾ je
docela praktické a dobøe to odpovídá filozofii vysokoúrovòových jazykù (podobnì
je tomu i v&nbsp;implementaci JavaScriptu &ndash; viz té¾ projekt Rhino):</p>

<table>
<tr><th>#</th><th>Literál v&nbsp;Clojure</th><th>Implementovaná tøída èi rozhraní v Javì</th><th>Poznámka</th></tr>
<tr><td>1</td><td>42</td><td>java.lang.Long</td><td>desítková soustava</td></tr>
<tr><td>2</td><td>16RFF</td><td>java.lang.Long</td><td>èíselná soustava zapsaná za znakem "R"</td></tr>
<tr><td>3</td><td>42.0</td><td>java.lang.Double</td><td>bì¾ná hodnota reprezentovaná v&nbsp;systému plovoucí øádové èárky</td></tr>
<tr><td>4</td><td>1/2</td><td>clojure.lang.Ratio</td><td>provádìné operace v¾dy zlomek zjednodu¹í</td></tr>
<tr><td>5</td><td>42M</td><td>java.math.BigDecimal</td><td>lze aplikovat bì¾né funkce jako na dal¹í numerické hodnoty</td></tr>
<tr><td>6</td><td>42N</td><td>clojure.lang.BigInt</td><td>lze aplikovat bì¾né funkce jako na dal¹í numerické hodnoty</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Strukturované datové typy &ndash; kolekce</h2>

<p>Kromì jednoduchých datových typù popsaných <a href="#k02">v&nbsp;pøedchozí
kapitole</a> se v¹ak v&nbsp;<i>Clojure</i> samozøejmì pou¾ívají i strukturované
datové typy pøedstavované rùznými kolekcemi. Pokud prozatím zùstaneme a
nativních kolekcí podporovaných ji¾ v&nbsp;jádru tohoto jazyka, mù¾e ka¾dý
vývojáø pou¾ívající programovací jazyk <i>Clojure</i> pracovat se seznamy (co¾
asi oèekáváme od v¹ech LISPovských jazykù), vektory, mapami a mno¾inami.
Vìt¹ina slo¾itìj¹ích datových struktur se vytváøí právì s&nbsp;vyu¾itím
seznamù, vektorù, map a mno¾in, proto¾e to dobøe odpovídá filozofii dynamicky
typovaných funkcionálních jazykù, u nich¾ mají programátoøi k&nbsp;dispozici
velké mno¾ství univerzálních funkcí akceptujících jako své parametry právì
ètyøi vý¹e zmínìné strukturované datové typy, resp.&nbsp;jakoukoli sekvenci (u
objektovì orientovaných jazykù je naproti tomu funkcionalita navázána pouze na
konkrétní datový typ &ndash; tøídu). Ve tøetí tabulce jsou v¹echny ètyøi
základní typy datové typy <i>Clojure</i> vypsány i s&nbsp;odpovídajícími
literály:</p>

<table>
<tr><th>#</th><th>Typ kolekce</th><th>Zápis</th><th>Konstruktor</th><th>Implementovaná tøída</th></tr>
<tr><td>1</td><td>Seznam </td><td>(prvky)</td><td>(prvky)</td><td>clojure.lang.PersistentList</td></tr>
<tr><td>2</td><td>Vektor </td><td>[prvky]</td><td>(vector prvky)</td><td>clojure.lang.PersistentVector</td></tr>
<tr><td>3</td><td>Mapa   </td><td>{dvojice klíè-hodnota}</td><td>(hash-map dvojice klíè-hodnota)</td><td>clojure.lang.PersistentArrayMap</td></tr>
<tr><td>4</td><td>Mno¾ina</td><td>#{unikátní prvky}</td><td>(hash-set unikátní prvky)</td><td>clojure.lang.PersistentHashSet</td></tr>
</table>

<p>V¹echny ètyøi vý¹e zmínìné typy kolekcí jsou sice implementovány tøídami
z&nbsp;balíèku <strong>clojure.lang</strong>, souèasnì ov¹em implementují i
nìkterá rozhraní, která jsou souèástí standardního API programovacího jazyka
Java. S&nbsp;následující tabulkou jsme se sice ji¾ setkali, ale mo¾ná nebude na
¹kodu si zopakovat, která rozhraní jsou základními kolekcemi implementována a
ve kterých pøípadech je tedy mo¾né tyto kolekce v&nbsp;Javì vyu¾ít:</p>

<table>
<tr><th>Rozhraní</th><th>seznam</th><th>vektor</th><th>mapa</th><th>mno¾ina</th></tr>
<tr><td>java.util.Collection  </td><td>ano</td><td>ano</td><td>ne </td><td>ano</td></tr>
<tr><td>java.util.List        </td><td>ano</td><td>ano</td><td>ne </td><td>ne </td></tr>
<tr><td>java.util.Map         </td><td>ne </td><td>ne </td><td>ano</td><td>ne </td></tr>
<tr><td>java.util.Set         </td><td>ne </td><td>ne </td><td>ne </td><td>ano</td></tr>
<tr><td>java.util.RandomAccess</td><td>ne </td><td>ano</td><td>ne </td><td>ne </td></tr>
<tr><td>java.lang.Iterable    </td><td>ano</td><td>ano</td><td>ano</td><td>ano</td></tr>
<tr><td>java.lang.Comparable  </td><td>ne </td><td>ano</td><td>ne </td><td>ne </td></tr>
</table>

<p>Na závìr této kapitoly si pøipomeòme, ¾e v&nbsp;programovacím jazyce
<i>Clojure</i> jsou v¹echny kolekce nemìnitelné &ndash; <i>immutable</i> a
ka¾dý pokus o jejich zmìnu z&nbsp;Javy, napøíklad zavolání metody
<strong>Collection.add()</strong>, <strong>Collection.remove()</strong> èi
dokonce <strong>Collection.clear()</strong> povede ke vzniku bìhové výjimky
(<i>runtime exception</i>).</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Práce s&nbsp;poli programovacího jazyka Java</h2>

<p>Ètenáøùm tohoto seriálu asi není zapotøebí pøipomínat, ¾e
v&nbsp;programovacím jazyku <i>Java</i> je mo¾né vytváøet pole,
tj.&nbsp;homogenní datové struktury, které mohou obsahovat buï hodnoty
primitivních datových typù nebo naopak reference na objekty (vytvoøené na
haldì). Pole jsou vytváøena dynamicky, tj.&nbsp;velikost jejich dimenzí mù¾e
být vypoètena a¾ v&nbsp;dobì bìhu programu (<i>runtime</i>). Prvky ulo¾ené
v&nbsp;polích jsou navíc mìnitelné &ndash; <i>mutable</i>. Tato poslední
vlastnost je z&nbsp;hlediska programovacího jazyka <i>Clojure</i> nevýhodná,
ov¹em práci s&nbsp;poli se v&nbsp;<i>Clojure</i> v&nbsp;nìkterých pøípadech
nevyhneme, a to ze dvou dùvodù. První dùvod je ten, ¾e mnoho metod ze
standardního API Javy jako svùj argument akceptuje právì pole, popø.&nbsp;je
pole návratovou hodnotou nìjaké metody. Druhý dùvod spoèívá v&nbsp;tom, ¾e
práce s&nbsp;poli, zejména s&nbsp;poli primitivních datových typù (pole celých
èísel atd.), je v&nbsp;mnoha algoritmech velmi efektivní, a to jak
z&nbsp;hlediska vyu¾ití operaèní pamìti, tak i z&nbsp;hlediska rychlého
pøístupu k&nbsp;prvkùm polí pøes indexy a navíc s&nbsp;vyu¾itím speciálních
instrukcí bajtkódu:</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Provádìná operace</th></tr>
<tr><td> 1</td><td>newarray</td><td>0xBC</td><td>arraytype</td><td>Vytvoøí nové pole s prvky primitivního datového typu</td></tr>
<tr><td> 2</td><td>anewarray</td><td>0xBD</td><td>highbyte, lowbyte</td><td>Vytvoøí nové pole objektù</td></tr>
<tr><td> 3</td><td>multianewarray</td><td>0xC5</td><td>highbyte, lowbyte, dimensions</td><td>Vytvoøí vícedimenzionální pole o <i>dimensions</i> dimenzích</td></tr>
<tr><td> 4</td><td>iaload</td><td>0x2E</td><td>&times;</td><td>Pøeètení prvku z pole typu int[]</td></tr>
<tr><td> 5</td><td>laload</td><td>0x2F</td><td>&times;</td><td>Pøeètení prvku z pole typu long[]</td></tr>
<tr><td> 6</td><td>faload</td><td>0x30</td><td>&times;</td><td>Pøeètení prvku z pole typu float[]</td></tr>
<tr><td> 7</td><td>daload</td><td>0x31</td><td>&times;</td><td>Pøeètení prvku z pole typu double[]</td></tr>
<tr><td> 8</td><td>aaload</td><td>0x32</td><td>&times;</td><td>Pøeètení prvku z pole typu reference[]</td></tr>
<tr><td> 9</td><td>baload</td><td>0x33</td><td>&times;</td><td>Pøeètení prvku z pole typu byte[] nebo boolean[]</td></tr>
<tr><td>10</td><td>caload</td><td>0x34</td><td>&times;</td><td>Pøeètení prvku z pole typu char[]</td></tr>
<tr><td>11</td><td>saload</td><td>0x35</td><td>&times;</td><td>Pøeètení prvku z pole typu short[]</td></tr>
<tr><td>12</td><td>iastore</td><td>0x4F</td><td>&times;</td><td>Zápis nové hodnoty prvku do pole typu int[]</td></tr>
<tr><td>13</td><td>lastore</td><td>0x50</td><td>&times;</td><td>Zápis nové hodnoty prvku do pole typu long[]</td></tr>
<tr><td>14</td><td>fastore</td><td>0x51</td><td>&times;</td><td>Zápis nové hodnoty prvku do pole typu float[]</td></tr>
<tr><td>15</td><td>dastore</td><td>0x52</td><td>&times;</td><td>Zápis nové hodnoty prvku do pole typu double[]</td></tr>
<tr><td>16</td><td>aastore</td><td>0x53</td><td>&times;</td><td>Zápis nové hodnoty prvku do pole typu reference[]</td></tr>
<tr><td>17</td><td>bastore</td><td>0x54</td><td>&times;</td><td>Zápis nové hodnoty prvku do pole typu byte[] nebo boolean[]</td></tr>
<tr><td>18</td><td>castore</td><td>0x55</td><td>&times;</td><td>Zápis nové hodnoty prvku do pole typu char[]</td></tr>
<tr><td>19</td><td>sastore</td><td>0x56</td><td>&times;</td><td>Zápis nové hodnoty prvku do pole typu short[]</td></tr>
</table>

<p>Z&nbsp;tohoto dùvodu se v&nbsp;následujícím textu seznámíme se základy práce
s&nbsp;poli pøímo z&nbsp;jazyka <i>Clojure</i>. Pro vytvoøení nového pole
s&nbsp;jednou dimenzí se pou¾ívá funkce <strong>make-array</strong>, které se
musí pøedat dva parametry: typ prvkù pole a velikost pole. Typem je zde my¹lena
Javovská tøída, ov¹em v&nbsp;pøípadì, ¾e se má vytvoøit pole obsahující prvky
nìkterého primitivního datového typu, pou¾ívá se namísto tøídy zápis:
<strong>jméno_obalové_tøídy/TYPE</strong> (viz té¾ JavaDoc k&nbsp;obalovým
tøídám primitivních datových typù). Podívejme se na nìkolik demonstraèních
pøíkladù:</p>

<pre>
; desetiprvkové pole typu int
user=&gt; <strong>(make-array Integer/TYPE 10)</strong>
#&lt;int[] [I@1c5466b&gt;
&nbsp;
; stoprvkové pole typu double
user=&gt; <strong>(make-array Double/TYPE 100)</strong>
#&lt;double[] [D@d0220c&gt;
&nbsp;
; dvouprvkové pole typu boolean
user=&gt; <strong>(make-array Boolean/TYPE 2)</strong>
#&lt;boolean[] [Z@2d189c&gt;
&nbsp;
user=&gt;
</pre>

<p>Pole objektù, tj.&nbsp;pole obsahující <i>reference</i> na objekty, se
vytváøí stejnì snadno:</p>

<pre>
; desetiprvkové pole typu Integer
user=&gt; <strong>(make-array Integer 10)</strong>
#&lt;Integer[] [Ljava.lang.Integer;@6ed322&gt;
&nbsp;
; stoprvkové pole typu Double
user=&gt; <strong>(make-array Double 100)</strong>
#&lt;Double[] [Ljava.lang.Double;@16917ee&gt;
&nbsp;
; pole obsahující tisíc øetìzcù
user=&gt; <strong>(make-array String 1000)</strong>
#&lt;String[] [Ljava.lang.String;@c2ee15&gt;
&nbsp;
; pole obsahující tisíc barev (instancí tøídy java.awt.Color)
user=&gt; <strong>(make-array java.awt.Color 1000)</strong>
#&lt;Color[] [Ljava.awt.Color;@1fe571f&gt;
&nbsp;
user=&gt;
</pre>

<p>Vícerozmìrná pole se vytváøí jednodu¹e takovým zpùsobem, ¾e se velikost v¹ech dimenzí zapí¹e ihned za typ prvkù pole:</p>

<pre>
; matice 3x3 prvky typu int
user=&gt; <strong>(make-array Integer/TYPE 3 3)</strong>
#&lt;int[][] [[I@18e8541&gt;
&nbsp;
; trojrozmìrné pole 3x4x5 prvkù typu Double
user=&gt; <strong>(make-array Double/TYPE 3 4 5)</strong>
#&lt;double[][][] [[[D@29c58e&gt;
&nbsp;
; dvourozmìrné pole øetìzcù
user=&gt; <strong>(make-array String 10 10)</strong>
#&lt;String[][] [[Ljava.lang.String;@1c7980c&gt;
&nbsp;
user=&gt;
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Zjednodu¹ená konstrukce polí</h2>

<p>Jak jsme si ji¾ øekli <a href="#k04">v&nbsp;pøedchozí kapitole</a>,
pou¾ívají se pole i v&nbsp;tìch pøípadech, kdy je zapotøebí nìjaký algoritmus
(pracující napøíklad intenzivnì s&nbsp;vektory a s&nbsp;maticemi) napsat co
nejefektivnìj¹ím zpùsobem. Vzhledem k&nbsp;tomu, ¾e se v&nbsp;tìchto pøípadech
prakticky v¾dy vyu¾ívají pole obsahující prvky primitivních datových typù,
obsahuje programovací jazyk <i>Clojure</i> i nìkolik funkcí umo¾òujících tato
pole snadno vytvoøit, proto¾e pou¾ití funkce <strong>make-array</strong> je
dosti neèitelné kvùli nutnosti zapisovat typ prvkù pole. Alternativnì je
namísto funkce <strong>make-array</strong> mo¾né pou¾ít následující funkce:</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Význam</th></tr>
<tr><td>1</td><td>boolean-array</td><td>vytvoøení pole obsahujícího prvky typu boolean</td></tr>
<tr><td>2</td><td>byte-array</td><td>vytvoøení pole obsahujícího prvky typu char</td></tr>
<tr><td>3</td><td>char-array</td><td>vytvoøení pole obsahujícího prvky typu char</td></tr>
<tr><td>4</td><td>short-array</td><td>vytvoøení pole obsahujícího prvky typu short</td></tr>
<tr><td>5</td><td>int-array</td><td>vytvoøení pole obsahujícího prvky typu int</td></tr>
<tr><td>6</td><td>long-array</td><td>vytvoøení pole obsahujícího prvky typu long</td></tr>
<tr><td>7</td><td>float-array</td><td>vytvoøení pole obsahujícího prvky typu float</td></tr>
<tr><td>8</td><td>double-array</td><td>vytvoøení pole obsahujícího prvky typu double</td></tr>
</table>

<p>V¹ech sedm funkcí z&nbsp;pøedchozí tabulky existuje ve ètyøech variantách,
tj.&nbsp;ve skuteènosti existuje 32 zpùsobù vytvoøení pole obsahujících prvky
vybraného primitivního datového typu. Uka¾me si tyto mo¾nosti na pøíkladu
funkce <strong>int-array</strong>:</p>

<table>
<tr><th>#</th><th>Zápis</th><th>Význam</th></tr>
<tr><td>1</td><td>(int-array size)</td><td>vytvoøení pole zadané velikosti</td></tr>
<tr><td>2</td><td>(int-array size value)</td><td>vytvoøení pole zadané velikosti a naplnìní v¹ech prvkù zvolenou hodnotou</td></tr>
<tr><td>3</td><td>(int-array collection)</td><td>vytvoøení pole z&nbsp;kolekce (prvky kolekce jsou pøevedeny na int)</td></tr>
<tr><td>4</td><td>(int-array size collection)</td><td>jako pøedchozí funkce, ale zbývající prvky pole jsou naplnìny nulami</td></tr>
</table>

<p>Nyní nám zbývá si ukázat nìkolik jednoduchých demonstraèních pøíkladù,
v&nbsp;nich¾ se vytvoøí pole prvkù typu <i>integer</i> nìkolika rùznými
zpùsoby:</p>

<pre>
; vytvoøení pole obsahujícího deset prvkù typu int
; (prvky budou nulové)
user=&gt; <strong>(int-array 10)</strong>
#&lt;int[] [I@14e113b&gt;
&nbsp;
; vytvoøení pole obsahujícího deset prvkù typu int
; a inicializace v¹ech prvkù na hodnotu -1
user=&gt; <strong>(int-array 10 -1)</strong>
#&lt;int[] [I@1236cd5&gt;
&nbsp;
; vytvoøení ètyøprvkového pole a inicializace
; prvkù pole ze zadané kolekce - vektoru
user=&gt; <strong>(int-array [1 2 3 4])</strong>
#&lt;int[] [I@15d3388&gt;
&nbsp;
; vytvoøení ètyøprvkového pole a inicializace
; prvkù pole ze zadané kolekce - mno¾iny
user=&gt; <strong>(int-array #{1 2 3 4})</strong>
#&lt;int[] [I@15d3388&gt;
&nbsp;
; vytvoøení ètyøprvkového pole a inicializace
; prvkù pole ze zadané kolekce - seznamu
user=&gt; <strong>(int-array '(1 2 3 4))</strong>
#&lt;int[] [I@1c54796&gt;
&nbsp;
; vytvoøení tisíciprvkového pole a inicializace
; pouze prvních ètyø prvkù pole ze zadané kolekce
; (ostatní prvky budou nulové)
user=&gt; <strong>(int-array 1000 [1 2 3 4])</strong>
#&lt;int[] [I@d58939&gt;
&nbsp;
user=&gt;
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Pøístup k&nbsp;prvkùm polí</h2>

<p>Pole je mo¾né takté¾ vytvoøit z&nbsp;libovolné kolekce s&nbsp;vyu¾itím
funkcí <strong>to-array</strong> a <strong>to-array-2d</strong>. První
z&nbsp;tìchto funkcí vytvoøí pole objektù typu <strong>Object</strong>
(resp.&nbsp;instancí potomkù této tøídy) s&nbsp;vyu¾itím metody
<strong>java.util.Collection.toArray()</strong>, druhá funkce je ji¾ internì
ponìkud slo¾itìj¹í. Opìt následuje nìkolik demonstraèních pøíkladù na vyu¾ití
funkce <strong>to-array</strong> a <strong>to-array-2d</strong>:</p>

<pre>
; vytvoøení pìtiprvkového pole
user=&gt; <strong>(to-array [1 2 3 4 5])</strong>
#&lt;Object[] [Ljava.lang.Object;@8c4a77&gt;
&nbsp;
; vytvoøení pole s tisíci prvky
user=&gt; <strong>(to-array (range 1 1000))</strong>
#&lt;Object[] [Ljava.lang.Object;@13c6641&gt;
&nbsp;
; vytvoøení matice 3x3 prvky
user=&gt; <strong>(to-array-2d [[1 2 3] [4 5 6] [7 8 9]])</strong>
#&lt;Object[][] [[Ljava.lang.Object;@e35bb7&gt;
&nbsp;
; druhá dimenze se automaticky dopoèítá
user=&gt; <strong>(to-array-2d [(range 1 10) (range 1 100) (range 1 1000)])</strong>
#&lt;Object[][] [[Ljava.lang.Object;@186d484&gt;
&nbsp;
user=&gt;
</pre>

<p>Nyní si ji¾ mù¾eme popsat dal¹í funkce pou¾ívané pøi práci s&nbsp;poli.
Jedná se pøedev¹ím o funkce pro ètení prvku a pro zápis nové hodnoty prvku. Ve
skuteènosti existuje funkce pro zápis nové hodnoty prvku v&nbsp;nìkolika
variantách, proto¾e kromì obecné funkce <strong>aset</strong> pou¾ívané pro
pole obsahující reference na objekty je k&nbsp;dispozici i osmice funkcí
odpovídajících osmi primitivním datovým typùm programovacího jazyka Java. Mezi
dal¹í u¾iteèné funkce patøí funkce pro klonování pole a koneènì i funkce pro
zji¹tìní velikosti pole:</p>

<table>
<tr><th> #</th><th>Funkce</th><th>Parametry</th><th>Význam</th></tr>
<tr><td> 1</td><td>aget</td><td>pole index(y)</td><td>pøeètení prvku z n-rozmìrného pole</td></tr>
<tr><td> 2</td><td>aset</td><td>pole index(y) hodnota</td><td>zápis prvku do pole obsahujícího reference na objekty</td></tr>
<tr><td> 3</td><td>aset-boolean</td><td>pole index(y) hodnota</td><td>zápis prvku do pole obsahujícího prvky typu boolean</td></tr>
<tr><td> 4</td><td>aset-byte</td><td>pole index(y) hodnota</td><td>zápis prvku do pole obsahujícího prvky typu byte</td></tr>
<tr><td> 5</td><td>aset-char</td><td>pole index(y) hodnota</td><td>zápis prvku do pole obsahujícího prvky typu char</td></tr>
<tr><td> 6</td><td>aset-short</td><td>pole index(y) hodnota</td><td>zápis prvku do pole obsahujícího prvky typu short</td></tr>
<tr><td> 7</td><td>aset-int</td><td>pole index(y) hodnota</td><td>zápis prvku do pole obsahujícího prvky typu int</td></tr>
<tr><td> 8</td><td>aset-long</td><td>pole index(y) hodnota</td><td>zápis prvku do pole obsahujícího prvky typu long</td></tr>
<tr><td> 9</td><td>aset-float</td><td>pole index(y) hodnota</td><td>zápis prvku do pole obsahujícího prvky typu float</td></tr>
<tr><td>10</td><td>aset-double</td><td>pole index(y) hodnota</td><td>zápis prvku do pole obsahujícího prvky typu double</td></tr>
<tr><td>11</td><td>aclone</td><td>pole</td><td>klonování pole</td></tr>
<tr><td>12</td><td>alength</td><td>pole</td><td>zji¹tìní velikosti pole (resp.&nbsp;jedné jeho dimenze)</td></tr>
</table>

<p>Nìkteré z&nbsp;tìchto funkcí si mù¾eme ihned vyzkou¹et:</p>

<pre>
; vytvoøení desetiprvkového pole
user=&gt; <strong>(def pole (int-array 10))</strong>
#'user/pole
&nbsp;
; nastavení hodnoty prvního prvku v poli
user=&gt; <strong>(aset pole 0 42)</strong>
42
&nbsp;
; pøeètení hodnoty prvního prvku v poli
user=&gt; <strong>(aget pole 0)</strong>
42
&nbsp;
; nastavení hodnoty posledního prvku v poli
user=&gt; <strong>(aset-int pole 9 -1)</strong>
-1
&nbsp;
; pøeètení hodnoty posledního prvku v poli
user=&gt; <strong>(aget pole 9)</strong>
-1
&nbsp;
; pøeètení (implicitnì nastavené) hodnoty druhého prvku v poli
user=&gt; <strong>(aget pole 1)</strong>
0
&nbsp;
; pokus o pøekroèení indexu vede ke známé výjimce
user=&gt; <strong>(aget pole 10)</strong>
ArrayIndexOutOfBoundsException 10  clojure.lang.RT.aget (RT.java:2094)
&nbsp;
; pøeètení délky pole
user=&gt; <strong>(alength pole)</strong>
10
&nbsp;
; klonování pole
user=&gt; <strong>(aclone pole)</strong>
#&lt;int[] [I@b3319f&gt;
&nbsp;
user=&gt;
</pre>

<p>Kromì tìchto funkcí lze pøi práci s&nbsp;poli vyu¾ít i ponìkud slo¾itìj¹í
funkce se jmény <strong>amap</strong> a <strong>areduce</strong>, které si
popí¹eme pøí¹tì.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Pøeklad funkcí Clojure do bajtkódu JVM</h2>

<p>Nyní ji¾ máme velmi dobrou pøedstavu o tom, jakým zpùsobem programovací
jazyk <i>Clojure</i> uchovává hodnoty jednoduchých i strukturovaných datových
typù, ov¹em je¹tì nevíme, jak provádí pøeklad funkcí (a popøípadì i
multifunkcí, které jsme si je¹tì nepopisovali) do bajtkódu virtuálního stroje
jazyka Java. V&nbsp;nejjednodu¹¹ím pøípadì, kdy¾ se nesna¾íme o vytváøení
plnohodnotných tøíd a jejich instancí, ale o pøeklad jednotlivých funkcí, je
ka¾dá funkce ve jmenném prostoru pøelo¾ena do zvlá¹tního souboru
<strong>.class</strong>, tj.&nbsp;ka¾dá funkce je &bdquo;obalena&ldquo; svojí
tøídou. Navíc je pro ka¾dý jmenný prostor vytvoøeno nìkolik dal¹ích pomocných
tøíd, které se starají o inicializaci a prvotní konfiguraci. Pøed popisem této
relativnì slo¾ité struktury se podívejme na to, jak lze provést pøeklad
nìkolika funkcí naprogramovaných v&nbsp;<i>Clojure</i> do bajtkódu JVM. Tyto
funkce musí být ulo¾eny v&nbsp;externím souboru (nelze provést pøeklad funkcí
zapisovaných do interpretru) a navíc v&nbsp;tomto souboru musí být nastaven
jmenný prostor s&nbsp;toto¾ným názvem, jaký má jméno souboru.</p>

<p>Následující výpis je nutné ulo¾it do souboru pojmenovaného
<strong>Test.clj</strong> a ulo¾it tento soubor do podadresáøe
<strong>classes</strong>, proto¾e právì zde bude tento zdrojový soubor hledán
pøi svém pøekladu:</p>

<pre>
(ns Test)
&nbsp;
(defn plus
    [x y]
    (+ x y))
&nbsp;
(defn hello
    []
    (println "Hello world!"))
</pre>

<p>Vidíme, ¾e obsah není nijak komplikovaný &ndash; pouze se s&nbsp;vyu¾itím
makra <strong>ns</strong> nastaví jmenný prostor <strong>Test</strong>
(odpovídá názvu souboru <strong>Test.clj</strong>) a jsou zde deklarovány dvì
funkce <strong>plus</strong> a <strong>hello</strong>.</p>

<p>Pøeklad je mo¾né spustit pøímo z&nbsp;interpretru, ov¹em pøi jeho startu
nesmíme zapomenout zaøadit podadresáø <strong>classes</strong> na
CLASSPATH:</p>

<pre>
java -cp .;classes;clojure-1.4.0.jar clojure.main
</pre>

<p>Jakmile se interpret spustí, postaèí zadat pøíkaz:</p>

<pre>
user=&gt; <strong>(compile 'Test)</strong>
Test
user=&gt;
</pre>

<p>který povede k&nbsp;vytvoøení nìkolika souborù s&nbsp;koncovkou
<strong>.class</strong> v&nbsp;podadresáøi <strong>classes</strong>.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Obsah vygenerovaných souborù <strong>.class</strong></h2>

<p>Podívejme se nyní podrobnìji na to, jaké tøídy se vlastnì pøi pøekladu
vytvoøily. Ihned po pøekladu by mìl obsah podadresáøe <strong>classes</strong>
obsahovat pìtici souborù (jejich délky se mohou nepatrnì li¹it):</p>

<table>
<tr><th>#</th><th>Soubor</th><th>Velikost</th><th>Popis</th></tr>
<tr><td>1</td><td>Test.clj</td><td>  99</td><td>zdrojový kód v&nbsp;Clojure</td></tr>
<tr><td>2</td><td>Test$loading__4784__auto__.class</td><td>1472</td><td>pomocné metody vyu¾ívané &bdquo;interpretrem&ldquo;</td></tr>
<tr><td>3</td><td>Test__init.class</td><td>2647</td><td>pomocné metody vyu¾ívané &bdquo;interpretrem&ldquo;</td></tr>
<tr><td>4</td><td>Test$plus.class</td><td> 865</td><td>pøelo¾ený kód funkce <i>plus</i></td></tr>
<tr><td>5</td><td>Test$hello.class</td><td> 828</td><td>pøelo¾ený kód funkce <i>hello</i></td></tr>
</table>

<p>V&nbsp;tuto chvíli nás budou zajímat pøedev¹ím soubory
<strong>Test$plus.class</strong> a <strong>Test$hello.class</strong>, proto¾e
ty obsahují &bdquo;obalové&ldquo; tøídy pro dvojici funkcí
<strong>plus</strong> a <strong>hello</strong>. Interní struktura obou souborù
je dosti podobná: najdeme zde jednu statickou promìnnou, statický blok, veøejný
konstruktor a pøedev¹ím pak metodu nazvanou <strong>invoke</strong> vracející
instanci <strong>java.lang.Object</strong>. Poèet parametrù této metody pøesnì
odpovídá poètu parametrù obou funkcí, tj.&nbsp;v&nbsp;pøípadì funkce
<strong>hello</strong> nemá jí odpovídající metoda <strong>invoke</strong>
¾ádné parametry a v&nbsp;pøípadì funkce <strong>plus</strong> jde o metodu
s&nbsp;dvojicí parametrù typu <strong>java.lang.Object</strong>, co¾ je
zpùsobeno tím, ¾e jsme nikde blí¾e nedeklarovali, jakého typu mají být
parametry funkce <strong>plus</strong> (i to je v¹ak v&nbsp;Clojure mo¾né).</p>

<p>Výpis interní struktury tøídy <strong>Test$hello</strong> (komentáøe byly
dopsány):</p>

<pre>
<strong>javap Test$hello</strong>
Compiled from "Test.clj"
public final class Test$hello extends clojure.lang.AFunction{
&nbsp;
    ; statická promìnná
    public static final clojure.lang.Var const__0;
&nbsp;
    ; statický blok
    public static {};
&nbsp;
    ; veøejný konstruktor
    public Test$hello();
&nbsp;
    ; veøejná metoda invoke() bez parametrù
    public java.lang.Object invoke();
}
</pre>

<p>Výpis interní struktury tøídy <strong>Test$plus</strong>:</p>

<pre>
<strong>javap Test$plus</strong>
Compiled from "Test.clj"
public final class Test$plus extends clojure.lang.AFunction{
&nbsp;
    ; statická promìnná
    public static final clojure.lang.Var const__0;
&nbsp;
    ; statický blok
    public static {};
&nbsp;
    ; veøejný konstruktor
    public Test$plus();
&nbsp;
    ; veøejná metoda invoke() s dvojicí parametrù
    public java.lang.Object invoke(java.lang.Object, java.lang.Object);
}
</pre>

<p>Na závìr si je¹tì uká¾eme podrobnìj¹í strukturu tøídy
<strong>Test$plus</strong>, opìt s&nbsp;ruènì dopsanými komentáøi:</p>

<pre>
<strong>javap -c Test$plus</strong>
Compiled from "Test.clj"
public final class Test$plus extends clojure.lang.AFunction{
public static final clojure.lang.Var const__0;
&nbsp;
; statický blok
public static {};
  Code:
   0:   ldc     #11; //String clojure.core
   2:   ldc     #13; //String +
   4:   invokestatic    #19; //Method clojure/lang/RT.var:(Ljava/lang/String;Ljava/lang/String;)Lclojure/lang/Var;
   7:   checkcast       #21; //class clojure/lang/Var
   10:  putstatic       #23; //Field const__0:Lclojure/lang/Var;
   13:  return
&nbsp;
; konstruktor v nem¾ se volá konstruktor tøídy clojure.lang.AFunction
public Test$plus();
  Code:
   0:   aload_0
   1:   invokespecial   #26; //Method clojure/lang/AFunction."&lt;init&gt;":()V
   4:   return
&nbsp;
; Nejzajímavìj¹í èást celého bajtkódu:
; metoda invoke() která reprezentuje na¹i funkci (plus [x y] (+ x y))
&nbsp;
; Funkce + ve skuteènosti odpovídá statické metodì clojure.lang.Numbers.add
; která doká¾e seèíst jakákoli dvì èísla, tedy napøíklad i dva zlomky.
public java.lang.Object invoke(java.lang.Object, java.lang.Object);
  Code:
   0:   aload_1         ; ulo¾it první parametr metody na zásobník
   1:   aconst_null
   2:   astore_1        ; dosazení null do prvního parametru (le¾í v oblasti lokálních promìnných)
   3:   aload_2         ; ulo¾it druhý parametr metody na zásobník
   4:   aconst_null
   5:   astore_2        ; dosazení null do druhého parametru (le¾í v oblasti lokálních promìnných)
                        ; nyní jsou na zásobníku obì pøedané reference
                        ; - mù¾eme zavolat metodu clojure.lang.Numbers.add(x y)
   6:   invokestatic    #34; //Method clojure/lang/Numbers.add:(Ljava/lang/Objec
t;Ljava/lang/Object;)Ljava/lang/Number;
   9:   areturn         ; výsledek vrácený touto metodou je souèasnì i návratovou hodnotou
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Eulerovo èíslo<br />
<a href="http://cs.wikipedia.org/wiki/Eulerovo_èíslo">http://cs.wikipedia.org/wiki/Eulerovo_èíslo</a>
</li>

<li>List comprehension<br />
<a href="http://en.wikipedia.org/wiki/List_comprehension">http://en.wikipedia.org/wiki/List_comprehension</a>
</li>

<li>List Comprehensions in Clojure<br />
<a href="http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html">http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html</a>
</li>

<li>Clojure Programming Concepts: List Comprehension<br />
<a href="http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension">http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension</a>
</li>

<li>Clojure core API: for macro<br />
<a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for">http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for</a>
</li>

<li>cirrus machina - The Clojure for macro<br />
<a href="http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/">http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/</a>
</li>

<li>Clojure.org: Clojure home page<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>A Couple of Clojure Agent Examples<br />
<a href="http://lethain.com/a-couple-of-clojure-agent-examples/">http://lethain.com/a-couple-of-clojure-agent-examples/</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/">http://java.sun.com/developer/technicalArticles/DynTypeLang/</a>
</li>

<li>JSR 223: Scripting for the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=223">http://jcp.org/en/jsr/detail?id=223</a>
</li>

<li>JSR 292: Supporting Dynamically Typed Languages on the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=292">http://jcp.org/en/jsr/detail?id=292</a>
</li>

<li>Java 7: A complete invokedynamic example<br />
<a href="http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html">http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html</a>
</li>

<li>InvokeDynamic: Actually Useful?<br />
<a href="http://blog.headius.com/2007/01/invokedynamic-actually-useful.html">http://blog.headius.com/2007/01/invokedynamic-actually-useful.html</a>
</li>

<li>A First Taste of InvokeDynamic<br />
<a href="http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html">http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html</a>
</li>

<li>Java 6 try/finally compilation without jsr/ret<br />
<a href="http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html">http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Root.cz: Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM<br />
<a href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/</a></a>
</li>

<li>Root.cz: JamVM aneb alternativa k HotSpotu nejenom pro embedded zaøízení a chytré telefony<br />
<a href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>FindBugs<br />
<a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a>
</li>

<li>GNU Classpath<br />
<a href="www.gnu.org/s/classpath/">www.gnu.org/s/classpath/</a></li>

<li>Java VMs Compared<br />
<a href="http://bugblogger.com/java-vms-compared-160/">http://bugblogger.com/java-vms-compared-160/</a>
</li>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Scala Programming Language<br />
<a href="http://www.scala-lang.org/">http://www.scala-lang.org/</a>
</li>

<li>Run Scala in Apache Tomcat in 10 minutes<br />
<a href="http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes">http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes</a>
</li>

<li>Fast Web Development With Scala<br />
<a href="http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html">http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html</a>
</li>

<li>Top five scripting languages on the JVM<br />
<a href="http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855">http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>CloseableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html">http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

