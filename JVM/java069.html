<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - práce s parametry a lokálními promìnnými metod pøes rozhraní JVM TI</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - práce s parametry a lokálními promìnnými metod pøes rozhraní JVM TI</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyku Java i o virtuálním stroji Javy si øekneme, jakým zpùsobem lze s vyu¾itím rozhraní JVM TI získat informace o parametrech a lokálních promìnných statických i nestatických metod. Tyto informace je mo¾né vyu¾ít napøíklad ve chvíli, kdy je v nìjaké metodì vstoupeno na breakpoint a je nutné prozkoumat aktuální stav procesu.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - práce s parametry a lokálními promìnnými metod pøes rozhraní JVM TI</a></p>
<p><a href="#k02">2. JVM TI funkce <strong>GetLocalVariableTable()</strong> a struktura <strong>jvmtiLocalVariableEntry</strong></a></p>
<p><a href="#k03">3. Nastavení po¾adovaných vlastností JVM TI agenta</a></p>
<p><a href="#k04">4. Tvar callback funkce <strong>callback_on_class_prepare()</strong></a></p>
<p><a href="#k05">5. U¾ivatelská funkce <strong>print_local_variables_for_all_methods()</strong></a></p>
<p><a href="#k06">6. U¾ivatelská funkce <strong>print_method_name_and_signature()</strong></a></p>
<p><a href="#k07">7. U¾ivatelská funkce <strong>print_local_variables()</strong></a></p>
<p><a href="#k08">8. U¾ivatelská funkce <strong>print_local_variable_info()</strong></a></p>
<p><a href="#k09">9. U¾ivatelská funkce <strong>print_signature_of_local_variable()</strong></a></p>
<p><a href="#k10">10. Testovací tøída pou¾itá spoleènì s&nbsp;demonstraèním JVM TI agentem</a></p>
<p><a href="#k11">11. Spu¹tìní 34. demonstraèního JVM TI agenta</a></p>
<p><a href="#k12">12. Porovnání výstupu JVM TI agenta s&nbsp;výpisem získaným pøes nástroj <strong>javap</strong></a></p>
<p><a href="#k13">13. Zdrojové kódy 34.demonstraèního agenta i k&nbsp;nìmu pøíslu¹ných testovacích pøíkladù a skriptù</a></p>
<p><a href="#k14">14. Literatura a odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - práce s parametry a lokálními promìnnými metod pøes rozhraní JVM TI</h2>

<p>V&nbsp;pøedchozích tøech èástech [<a 
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-nastaveni-breakpointu-s-vyuzitim-rozhrani-jvm-ti/">65</a>]
[<a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-nastaveni-breakpointu-s-vyuzitim-rozhrani-jvm-ti-pokracovani/">66</a>]
a [<a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-nastaveni-breakpointu-s-vyuzitim-rozhrani-jvm-ti-dokonceni/">67</a>]
<a href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyku Java i o virtuálním stroji Javy</a> jsme si øekli, jakým
zpùsobem je mo¾né pøes rozhraní <i>JVM TI</i> pracovat s&nbsp;breakpointy. Víme
ji¾, jak se breakpointy nastavují i jak je mo¾né v&nbsp;pøíslu¹né callback
funkci reagovat na událost vstupu nìjakého vlákna na breakpoint. Mù¾eme
napøíklad velmi snadno získat obsah zásobníkových rámcù, tj.&nbsp;vlastnì èást
historie ¾ivota daného vlákna. Kromì vyu¾ití breakpointù je takté¾ pomìrnì
snadné sledovat ètení i zápis do vybraného atributu tøídy èi atributu objektu,
co¾ je problematika, které jsme se podrobnì vìnovali v&nbsp;èástech <a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-sledovani-cteni-i-zapisu-do-vybraneho-atributu-tridy-ci-atributu-objektu/">63</a>
a <a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-sledovani-cteni-i-zapisu-do-vybraneho-atributu-tridy-ci-atributu-objektu-dokonceni/">64</a>.
Prozatím nám v¹ak chybí je¹tì schopnost pøeèíst informace o typech a hodnotách
parametrù metod i lokálních promìnných tìchto metod.</p>

<p>Ji¾ <a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-predcasny-vyskok-z-metody-s-vyuzitim-rozhrani-jvm-ti/">v&nbsp;pøedchozí
èásti tohoto seriálu</a>, v&nbsp;ní¾ jsme se vìnovali popisu zpùsobu
pøedèasného výskoku z&nbsp;metod, jsme si øekli, ¾e v¹echny parametry metod i
v¹echny lokální promìnné dané metody jsou ulo¾eny v&nbsp;zásobníkovém rámci
(<i>stack frame</i>) vytvoøeném ve chvíli, kdy je metoda zavolána. Pokud se
jedná o nestatickou metodu, je mezi parametry poèítán i
&bdquo;neviditelný&ldquo; parametr <strong>this</strong>. K&nbsp;obìma typùm
dat, tj.&nbsp;jak k&nbsp;parametrùm, tak i k&nbsp;lokálním promìnným, se
v&nbsp;bajtkódu virtuálního stroje Javy pøistupuje s&nbsp;vyu¾itím indexu:
první údaj má index 0, dal¹í údaj má index 1 atd. Z&nbsp;toho, ¾e se uvnitø
metody vlastnì nedìlá ¾ádný rozdíl mezi jejími parametry a lokálními promìnnými
vyplývá, ¾e i hodnotu parametrù lze uvnitø metody mìnit, ov¹em jedná se pouze o
lokální zmìnu viditelnou uvnitø metody. Na zásobníkový rámec je ulo¾ena buï
kopie hodnoty primitivního datového typu nebo kopie reference (co¾ znamená, ¾e
v&nbsp;tomto pøípadì ve skuteènosti LZE mìnit stav objektu voláním jeho metod
èi pøímým nastavováním jeho atributù &ndash; o defenzivní kopii objektu se musí
v&nbsp;pøípadì potøeby postarat sám programátor).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. JVM TI funkce <strong>GetLocalVariableTable()</strong> a struktura <strong>jvmtiLocalVariableEntry</strong></h2>

<p>V&nbsp;rozhraní <i>JVM TI</i> lze získat informace o parametrech i o
lokálních promìnných zvolené metody s&nbsp;vyu¾itím funkce nazvané
<strong>GetLocalVariableTable()</strong>. Této funkci se musí pøedat
jednoznaèný identifikátor metody, který je nastaven ve chvíli, kdy je do
virtuálního stroje Javy naèítána tøída, v&nbsp;ní¾ je metoda deklarována.
Logicky z&nbsp;toho vyplývá, ¾e nejjednodu¹eji lze získat ve¹keré potøebné
informace o metodì v&nbsp;callback funkci zavolané pøi naèítání tøídy. <i>JVM
TI</i> funkce <strong>GetLocalVariableTable()</strong> má následující
hlavièku:</p>

<pre>
jvmtiError <strong>GetLocalVariableTable</strong>(
            jvmtiEnv* env,
            jmethodID method,
            jint*     entry_count_ptr,
            jvmtiLocalVariableEntry** table_ptr)
</pre>

<p>Význam jednotlivých parametrù této funkce je vypsán v&nbsp;tabulce:</p>

<table>
<tr><th>#</th><th>Typ</th><th>Jméno parametru</th><th>Popis</th></tr>
<tr><td>1</td><td>jvmtiEnv*</td><td>env</td><td>JVM TI prostøedí agenta (je pøedáváno do vìt¹iny funkcí nabízených rozhraním JVM TI)</td></tr>
<tr><td>2</td><td>jmethodID</td><td>method</td><td>identifikátor metody, pro ní¾ se zji¹»ují informace</td></tr>
<tr><td>3</td><td>jint*</td><td>entry_count_ptr</td><td>celkový poèet parametrù a lokálních promìnných</td></tr>
<tr><td>4</td><td>jvmtiLocalVariableEntry**</td><td>table_ptr</td><td>tabulka obsahující informace o parametrech i o lokálních promìnných</td></tr>
</table>

<p>U popisované <i>JVM TI</i> funkce je nutné kontrolovat její návratovou
hodnotu, jeliko¾ rozhraní <i>JVM TI</i> doká¾e získat potøebné informace o
zvolené metodì pouze v&nbsp;tom pøípadì, kdy se v&nbsp;bajtkódu nachází v¹echny
potøebné ladicí informace. Tøídu/tøídy je z&nbsp;tohoto dùvodu nutné pøekládat
s&nbsp;pøepínaèem <strong>-g</strong>. Význam prvních dvou parametrù funkce
<strong>GetLocalVariableTable()</strong> je zøejmý. Tøetí parametr slou¾í pro
zpìtné pøedání poètu parametrù a lokálních promìnných &ndash; souèasnì se jedná
o poèet záznamù v&nbsp;poli naplnìném pøes poslední (ètvrtý) parametr. Toto
pole obsahuje struktury <strong>jvmtiLocalVariableEntry</strong>:</p>

<pre>
typedef struct {
    jlocation start_location;
    jint      length;
    char*     name;
    char*     signature;
    char*     generic_signature;
    jint      slot;
} <strong>jvmtiLocalVariableEntry</strong>;
</pre>

<p>Opìt si popí¹eme význam jednotlivých prvkù této struktury:</p>

<table>
<tr><th>#</th><th>Typ</th><th>Jméno prvku</th><th>Popis</th></tr>
<tr><td>1</td><td>jlocation</td><td>start_location   </td><td>pozice v&nbsp;bajtkódu (vnitøní pøíkazový blok), od ní¾ je lokální promìnná platná</td></tr>
<tr><td>2</td><td>jint     </td><td>length           </td><td>velikost pøíkazového bloku, v&nbsp;nìm¾ je lokální promìnná platná</td></tr>
<tr><td>3</td><td>char*    </td><td>name             </td><td>jméno promìnné</td></tr>
<tr><td>4</td><td>char*    </td><td>signature        </td><td>úplná signatura promìnné (datový typ)</td></tr>
<tr><td>5</td><td>char*    </td><td>generic_signature</td><td>signatura generického typu v&nbsp;pøípadì, ¾e je promìnná typu Typ1&lt;Typ2&gt; apod.</td></tr>
<tr><td>6</td><td>jint     </td><td>slot             </td><td>slot lokální promìnné (význam si vysvìtlíme pøí¹tì)</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Nastavení po¾adovaných vlastností JVM TI agenta</h2>

<p>V&nbsp;následujícím textu si popí¹eme dùle¾ité funkce, z&nbsp;nich¾ se
skládá tøicátý ètvrtý demonstraèní <i>JVM TI</i> agent. Zdrojový kód tohoto
agenta je z&nbsp;velké èásti postaven na zdrojovém kódu <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/6f4c18dd1787/jvmti-agents/agent33/agent33.c">tøicátého
tøetího JVM TI agenta</a>, s&nbsp;jeho¾ popisem jsme se seznámili ji¾ minule.
Jedna ze zmìn mezi obìma agenty je zpùsobena tím, ¾e u nového agenta vy¾adujeme
jiné vlastnosti, ne¾ u agenta popsaného minule. 33.&nbsp;agent toti¾ potøeboval
pracovat s&nbsp;breakpointy a takté¾ jsme vy¾adovali podporu pro volání funkcí
typu <strong>ForceEarlyReturn*()</strong>. Pùvodnì bylo tedy nutné si od
virtuálního stroje Javy vy¾ádat vyu¾ití hned tøí speciálních funkcí <i>JVM
TI</i>:</p>

<pre>
<i>/*</i>
<i> * Nastaveni pozadovanych schopnosti agenta.</i>
<i> */</i>
jvmtiError <strong>set_capabilities</strong>(jvmtiEnv *jvmti)
{
    jvmtiCapabilities capabilities;
    jvmtiError error_code;
&nbsp;
    memset(&amp;capabilities, 0, sizeof(jvmtiCapabilities));
&nbsp;
<i>    /* vyuzivame pouze tri specialni schopnosti agenta */</i>
    capabilities.can_get_line_numbers = 1;
    capabilities.can_generate_breakpoint_events = 1;
    capabilities.can_force_early_return = 1;
&nbsp;
    error_code = (*jvmti)-&gt;AddCapabilities(jvmti, &amp;capabilities);
    check_jvmti_error(jvmti, error_code, "Unable to get necessary JVMTI capabilities.");
    return error_code;
}
</pre>

<p>V&nbsp;dnes popisovaném agentovi sice není zapotøebí nastavovat breakpointy
ani vyu¾ívat funkce typu <strong>ForceEarlyReturn*()</strong>, ov¹em navíc je
nutné pøistupovat k&nbsp;lokálním promìnným. Z&nbsp;tohoto dùvodu bude nová
varianta u¾ivatelské funkce <strong>set_capabilities()</strong> vypadat ponìkud
odli¹nì:</p>

<pre>
<i>/*</i>
<i> * Nastaveni pozadovanych schopnosti agenta.</i>
<i> */</i>
jvmtiError <strong>set_capabilities</strong>(jvmtiEnv *jvmti)
{
    jvmtiCapabilities capabilities;
    jvmtiError error_code;
&nbsp;
    memset(&amp;capabilities, 0, sizeof(jvmtiCapabilities));
&nbsp;
<i>    /* vyuzivame pouze dve specialni schopnosti agenta */</i>
    capabilities.can_get_line_numbers = 1;
    capabilities.can_access_local_variables = 1;
&nbsp;
    error_code = (*jvmti)-&gt;<strong>AddCapabilities</strong>(jvmti, &amp;capabilities);
    check_jvmti_error(jvmti, error_code, "Unable to get necessary JVMTI capabilities.");
    return error_code;
}
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Tvar callback funkce <strong>callback_on_class_prepare()</strong></h2>

<p>V&nbsp;demonstraèním <i>JVM TI</i> agentovi je zaregistrována callback
funkce nazvaná <strong>callback_on_class_prepare()</strong>, která je, podobnì
jako i v&nbsp;nìkolika agentech pøedchozích, zavolána ve chvíli, kdy je do
virtuálního stroje Javy naèítána nìjaká tøída a kdy je zpracován její bajtkód.
V&nbsp;této callback funkci nejprve kontrolujeme, zda je jméno naèítané tøídy
toto¾né s&nbsp;øetìzcem "Test34". Pokud tomu tak skuteènì je, znamená to, ¾e se
aktuálnì naèítá právì testovací tøída <strong>Test34</strong> a mù¾eme tedy
vypsat informace o v¹ech jejích metodách. Výpis se provede v&nbsp;u¾ivatelské
funkci <strong>print_local_variables_for_all_methods</strong> popsané <a
href="#k05">v&nbsp;páté kapitole</a>:</p>

<pre>
<i>/*</i>
<i> * Callback funkce zavolana ve chvili, kdy je trida ve virtualnim stroji ve stavu,</i>
<i> * kdy ji lze normalne pouzivat.</i>
<i> */</i>
static void JNICALL <strong>callback_on_class_prepare</strong>(
        jvmtiEnv *jvmti_env,
        JNIEnv   *jni_env,
        jthread   thread,
        jclass    class)
{
    jvmtiError error;
    char *class_name_ptr;
    char *updated_class_name_ptr;
&nbsp;
    enter_critical_section(jvmti_env);
&nbsp;
<i>    /* ziskat jmeno tridy */</i>
    error = (*jvmti_env)-&gt;<strong>GetClassSignature</strong>(jvmti_env, class, &amp;class_name_ptr, NULL);
    check_jvmti_error(jvmti_env, error, "get class signature");
    if (class_name_ptr == NULL)
    {
        puts("Error: class has no signature");
    }
&nbsp;
<i>    /* upravit jmeno tridy */</i>
    updated_class_name_ptr = update_class_name(class_name_ptr, ';');
&nbsp;
<i>    /* pokud jsme nasli to pravou tridu */</i>
    if (strcmp(updated_class_name_ptr, TEST_CLASS_NAME) == 0)
    {
        puts(AGENT_NAME " Class "TEST_CLASS_NAME" prepared, processing all methods in this class");
        <strong>print_local_variables_for_all_methods</strong>(jvmti_env, class);
    }
&nbsp;
<i>    /* dealokace pameti po GetClassSignature() */</i>
    error = (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char *)class_name_ptr);
    check_jvmti_error(jvmti_env, error, "deallocate class name");
    exit_critical_section(jvmti_env);
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. U¾ivatelská funkce <strong>print_local_variables_for_all_methods()</strong></h2>

<p>Úkolem u¾ivatelské funkce
<strong>print_local_variables_for_all_methods()</strong>, která je volaná
z&nbsp;callback funkce <strong>callback_on_class_prepare()</strong>, je vypsat
jméno a signaturu ka¾dé metody deklarované v&nbsp;testovací tøídì
<strong>Test34</strong>. Posléze se pro ka¾dou metodu vypí¹ou informace o
jejích parametrech a lokálních promìnných. V&nbsp;popisované funkci se nejprve
s&nbsp;vyu¾itím <i>JVM TI</i> funkce <strong>GetClassMethods()</strong> získá
pole v¹ech metod tøídy a posléze se tímto polem prochází podobným zpùsobem,
jaký ji¾ známe z&nbsp;pøedchozích èástí tohoto seriálu. Na konci samozøejmì
nesmíme zapomenout na uvolnìní pole s&nbsp;metodami z&nbsp;operaèní pamìti, co¾
zajistí <i>JVM TI</i> funkce <strong>Deallocate</strong>:</p>

<pre>
<i>/*</i>
<i> * Vypise lokalni promenne vsech metod ve vybrane tride.</i>
<i> */</i>
void <strong>print_local_variables_for_all_methods</strong>(jvmtiEnv *jvmti_env, jclass class)
{
    jvmtiError  error;
    int         method_count;
    jmethodID  *methods_array;
&nbsp;
<i>    /* precist vsechny metody tridy */</i>
    error = (*jvmti_env)-&gt;<strong>GetClassMethods</strong>(jvmti_env, class, &amp;method_count, &amp;methods_array);
    check_jvmti_error(jvmti_env, error, "get class methods");
&nbsp;
<i>    /* pole metod bylo inicializovano */</i>
    if (error == JVMTI_ERROR_NONE)
    {
        int i;
<i>        /* projit vsemi metodami a vypsat jejich lokalni promenne */</i>
        for (i = 0; i &lt; method_count; i++)
        {
            jmethodID method = methods_array[i];
            <strong>print_method_name_and_signature</strong>(jvmti_env, method);
            <strong>print_local_variables</strong>(jvmti_env, method);
        }
    }
&nbsp;
<i>    /* dealokace pole ziskaneho pres GetClassFields() */</i>
    error = (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char*)methods_array);
    check_jvmti_error(jvmti_env, error, "deallocate class fields array");
}
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. U¾ivatelská funkce <strong>print_method_name_and_signature()</strong></h2>

<p>Funkce <strong>print_method_name_and_signature()</strong> je velmi
jednoduchá, proto¾e v&nbsp;ní pouze potøebujeme vypsat jméno a signaturu
metody, její¾ identifikátor je do této funkce pøedán jako parametr. ®ádnou
novou funkcionalitu rozhraní <i>JVM TI</i> zde nevyu¾íváme. Funkcí
<strong>GetMethodName()</strong> se získá jak jméno metody, tak i její
signatura, z&nbsp;ní¾ lze odvodit poèet a typ parametrù funkce i její
návratovou hodnotu. V&nbsp;demonstraèním <i>JVM TI</i> agentovi se oba øetìzce
pouze vypí¹ou na standardní výstup a posléze se uvolní z&nbsp;operaèní pamìti
s&nbsp;vyu¾itím funkce <strong>Deallocate()</strong>:</p>

<pre>
<i>/*</i>
<i> * Vypis jmena a signatury zvolene metody</i>
<i> */</i>
void <strong>print_method_name_and_signature</strong>(jvmtiEnv *jvmti_env, jmethodID method)
{
    jvmtiError  error;
    char *method_name;
    char *method_signature;
&nbsp;
<i>    /* precist jmeno metody */</i>
    error = (*jvmti_env)-&gt;<strong>GetMethodName</strong>(jvmti_env, method, &amp;method_name, &amp;method_signature, NULL);
    check_jvmti_error(jvmti_env, error, "get method name");
&nbsp;
<i>    /* tisk jmena a signatury metody */</i>
    printf(AGENT_NAME"\n");
    printf(AGENT_NAME"     method %s with signature %s\n", method_name, method_signature);
&nbsp;
<i>    /* dealokace retezcu ziskanych pres GetMethodName() */</i>
    error = (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char*)method_name);
    check_jvmti_error(jvmti_env, error, "deallocate method name");
&nbsp;
<i>    /* dealokace retezcu ziskanych pres GetMethodName() */</i>
    error = (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char*)method_signature);
    check_jvmti_error(jvmti_env, error, "deallocate method signature");
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. U¾ivatelská funkce <strong>print_local_variables()</strong></h2>

<p>U¾ivatelská funkce <strong>print_local_variables()</strong> se nejprve
s&nbsp;vyu¾itím <i>JVM TI</i> funkce nazvané
<strong>GetLocalVariableTable()</strong> pokusí získat pole obsahující
informace o v¹ech parametrech i o lokálních promìnných metody, její¾
identifikátor je do této funkce pøedán v&nbsp;parametru
<strong>method</strong>. Jak jsme si ji¾ øekli <a href="#k02">v&nbsp;úvodu</a>
tohoto èlánku, je bezpodmíneènì nutné otestovat návratovou hodnotu funkce
<strong>GetLocalVariableTable()</strong>, proto¾e ta mù¾e korektnì pracovat jen
v&nbsp;tom pøípadì, ¾e byl bajtkód zpracovávané tøídy pøelo¾en s&nbsp;volbou
<strong>-g</strong>, proto¾e jen v&nbsp;tom pøípadì jsou do bajtkódu vlo¾eny
potøebné ladicí informace o lokálních promìnných. Volbu <strong>-g</strong> lze
v&nbsp;pøípadì potøeby omezit na pouhé generování urèitého typu informací
s&nbsp;pou¾itím <strong>-g:vars</strong>, <strong>-g:lines</strong> èi
<strong>-g:source</strong> (popø.&nbsp;kombinací tìchto mo¾ností). Vra»me se
v¹ak k&nbsp;funkci <strong>print_local_variables()</strong>. Pokud se pøeètení
informací o lokálních promìnných zdaøí, zaène prùchod vráceným polem, pøièem¾
se v&nbsp;ka¾dé iteraci zavolá dal¹í u¾ivatelská funkce nazvaná
<strong>print_local_variable_info()</strong>:</p>

<pre>
<i>/*</i>
<i> * Vypis lokalnich promennych zvolene metody</i>
<i> */</i>
void <strong>print_local_variables</strong>(jvmtiEnv *jvmti_env, jmethodID method)
{
    jvmtiError  error;
    jint   variables_count;
    jvmtiLocalVariableEntry *local_variable_table;
&nbsp;
<i>    /* nacteni tabulky lokalnich promennych */</i>
    error = (*jvmti_env)-&gt;<strong>GetLocalVariableTable</strong>(jvmti_env, method, &amp;variables_count, &amp;local_variable_table);
&nbsp;
<i>    /* pokud se nacteni podarilo */</i>
    if (error == JVMTI_ERROR_NONE)
    {
        int i;
        printf(AGENT_NAME"         number of local variables %d:\n", (int)variables_count);
<i>        /* projit tabulkou a vypsat vsechny udaje o lokalni promenne */</i>
        for (i = 0; i &lt; variables_count; i++)
        {
            <strong>print_local_variable_info</strong>(i, local_variable_table[i]);
        }
    }
    else
    {
        printf(AGENT_NAME"         can not read local variable table");
    }
&nbsp;
<i>    /* dealokace tabulky lokalnich promennych */</i>
    error = (*jvmti_env)-&gt;<strong>Deallocate</strong>(jvmti_env, (unsigned char*)local_variable_table);
    check_jvmti_error(jvmti_env, error, "deallocate local variable table");
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. U¾ivatelská funkce <strong>print_local_variable_info()</strong></h2>

<p>Pøedposlední funkcí, jejím¾ podrobnìj¹ím popisem se dnes budeme zabývat, je
u¾ivatelská funkce nazvaná <strong>print_local_variable_info()</strong>. Jak
ji¾ víme z&nbsp;pøedchozího textu, je tato funkce zavolána pro ka¾dou metodu a
pro ka¾dý parametr/lokální promìnnou testovací tøídy <strong>Test34</strong>.
Do funkce <strong>print_local_variable_info()</strong> se pøedávají pouze dva
údaje &ndash; index parametru èi lokální promìnné a struktura typu
<strong>jvmtiLocalVariableEntry</strong>, její¾ popis byl uveden <a
href="#k02">ve druhé kapitole</a>. U ka¾dého parametru èi lokální promìnné se
nejprve vypí¹e jeho index (co¾ je triviální) a takté¾ jméno, které je získáno
z&nbsp;prvku <strong>var_info.name</strong>. Jméno je kódováno v&nbsp;UTF-8, i
kdy¾ ve vìt¹inì rozumných javovských aplikací lze pøedpokládat pouze pou¾ití
ASCII znakù. Ve druhé èásti popisované funkce se vypí¹e signatura parametru èi
lokální promìnné, z&nbsp;ní¾ lze jednoznaènì zjistit datový typ, a to jak
v&nbsp;pøípadì, ¾e se jedná o promìnnou primitivního typu, pole èi o objekt
(referenci).</p>

<p>Posléze se vypí¹e i signatura generického datového typu. Tato signatura je
pou¾ita v&nbsp;pøípadì, ¾e je parametr èi lokální promìnná metody deklarována
napøíklad jako <strong>List&lt;String&gt;</strong>. Tato podrobnìj¹í informace
o typu není souèástí signatury metody (ta obsahuje pouze plné jméno
tøídy/rozhraní, tedy <strong>java.util.List</strong>), ov¹em lze ji získat
právì z&nbsp;tìchto doplòujících metadat:</p>

<pre>
<i>/*</i>
<i> * Vypis informaci o jedne lokalni promenne</i>
<i> */</i>
void <strong>print_local_variable_info</strong>(int i, jvmtiLocalVariableEntry var_info)
{
<i>    /* vypis poradi lokalni promenne a jmena promenne */</i>
    printf(AGENT_NAME"         %2d  %-20s  ", i, var_info.name);
&nbsp;
<i>    /* vypis upravene signatury promenne */</i>
    <strong>print_signature_of_local_variable</strong>(var_info.signature);
    putchar('\t');
&nbsp;
<i>    /* vypis upravene signatury generickeho typu (pokud existuje) */</i>
    <strong>print_signature_of_local_variable</strong>(var_info.generic_signature);
    putchar('\n');
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. U¾ivatelská funkce <strong>print_signature_of_local_variable()</strong></h2>

<p>Signaturu parametru/lokální promìnné i signaturu generického datového typu
lze buï vypsat pøímo ve formátu vráceném rozhraním <i>JVM TI</i>, popø.&nbsp;je
mo¾né provést úpravu vráceného øetìzce do tvaru, který je lépe èitelný. Právì
tato úprava formátu se provádí v&nbsp;poslední dnes popisované u¾ivatelské
funkci <strong>print_signature_of_local_variable()</strong>. Ta buï jednodu¹e
zobrazí pøedaný øetìzec, popø.&nbsp;provede jeho pøeformátování (¾ádné nové
informace se v¹ak do vypisovaného textu pochopitelnì nedodají). Chování této
funkce je ovlivnìno symbolickou konstantou <strong>UPDATE_VAR_NAMES</strong>.
Samotná konverze je vlastnì velmi jednoduchá, proto¾e primitivní datový typ je
zakódován jedním znakem [BSIJCFDZ], ka¾dá dimenze pole je pøedstavována znakem
"[" a jméno tøídy zaèíná znakem "L". Ve jménì tøídy se vyskytují lomítka
namísto teèek a celé jméno konèí støedníkem (ten je pøi výpisu odstranìn).
Ponìkud slo¾itìj¹í je situace v&nbsp;pøípadì generických typù, kde je nutné pøi
výpisu vkládat mezi jména tøíd èárky:</p>

<pre>
<i>/*</i>
<i> * Vypis upravene signatury lokalni promenne.</i>
<i> */</i>
void <strong>print_signature_of_local_variable</strong>(char *signature)
{
<strong>#if</strong> (UPDATE_VAR_NAMES==1)
<i>    /* nastaveno, pokud je promenna instanci nejake tridy */</i>
<i>    /* a ne zakladni typ ci pole zakladniho typu */</i>
    int is_a_class = 0;
&nbsp;
<i>    /* nastaveno uvnitr zavorek &lt; a &gt; */</i>
    int inside_generic = 0;
&nbsp;
    char *c;
<i>    /* signatura nemusi byt vzdy znama */</i>
    if (signature == NULL)
    {
        return;
    }
&nbsp;
<i>    /* projit celym retezcem se signaturou lokalni promenne */</i>
    for (c = signature; *c != 0; c++)
    {
<i>        /* za znakem 'L' se nachazi plne kvalifikovane jmeno tridy */</i>
        if (is_a_class)
        {
            switch (*c)
            {
                case '/':
                    putchar('.');
                    break;
                case ';':
<i>                    /* oddeleni jmen trid uvnitr sekvence &lt; ... &gt; */</i>
                    if (inside_generic &amp;&amp; *(c+1)!='&gt;')
                    {
                        putchar(',');
                    }
                    is_a_class = 0;
                    break;
                case '&lt;':
                    is_a_class = 0;
                    inside_generic = 1;
                    putchar(*c);
                    break;
                default:
                    putchar(*c);
                    break;
            }
        }
        else
        {
            switch (*c)
            {
                case '[': <i>/* znak oznacujici jednu dimenzi pole */</i>
                    printf("array of ");
                    break;
                case 'B':
                    printf("byte");
                    break;
                case 'S':
                    printf("short");
                    break;
                case 'I':
                    printf("int");
                    break;
                case 'J':
                    printf("long");
                    break;
                case 'C':
                    printf("char");
                    break;
                case 'F':
                    printf("float");
                    break;
                case 'D':
                    printf("double");
                    break;
                case 'Z':
                    printf("boolean");
                    break;
                case 'L': <i>/* zacatek plne kvalifikovaneho jmena tridy */</i>
                    is_a_class=1;
                    break;
                default:
                    putchar(*c);
                    break;
            }
        }
    }
    printf("  ");
<strong>#else</strong>
    printf("%-20s", signature);
<strong>#endif</strong>
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Testovací tøída pou¾itá spoleènì s&nbsp;demonstraèním JVM TI agentem</h2>

<p>Abychom si funkci vý¹e popsaného demonstraèního <i>JVM TI</i> agenta
otestovali, byla vytvoøena javovská tøída nazvaná <strong>Test34</strong>,
která obsahuje celkem dvacet metod, které lze rozdìlit do ètyø skupin:</p>

<ol>
<li>Konstruktor pøedstavovaný ve výsledném bajtkódu metodou <strong>&lt;init&gt;</strong></li>
<li>Statická metoda <strong>main()</strong></li>
<li>Nestatické metody nazvané <strong>method1()</strong> a¾ <strong>method9()</strong></li>
<li>Statické metody nazvané <strong>static_method1()</strong> a¾ <strong>static_method9()</strong></li>
</ol>

<p>Jednotlivé metody se od sebe li¹í poètem svých parametrù i poètem a typem
lokálních promìnných.</p>

<p>Následuje výpis zdrojového kódu testovací tøídy <strong>Test34</strong>:</p>

<pre>
import java.awt.Color;
import java.util.*;
&nbsp;
<i>/**</i>
<i>  * Testovaci trida pouzita pro test tricateho</i>
<i>  * ctvrteho demonstracniho JVM TI agenta.</i>
<i>  *</i>
<i>  * Trida obsahuje nekolik metod s ruznym poctem</i>
<i>  * a typy lokalnich promennych.</i>
<i>  */</i>
public class <strong>Test34</strong> {
&nbsp;
    private void <strong>method1</strong>() {
    }
&nbsp;
    private void <strong>method2</strong>() {
        int x = 0;
    }
&nbsp;
    private void <strong>method3</strong>() {
        int x = 1;
        int y = 2;
    }
&nbsp;
    private void <strong>method4</strong>() {
        byte    byte_variable = 1;
        short   short_variable = 2;
        int     int_variable = 3;
        long    long_variable = 4;
    }
&nbsp;
    private void <strong>method5</strong>() {
        char    char_variable = 'a';
        float   float_variable = 1/2f;
        double  double_variable = 1/2.0;
        boolean boolean_variable = true;
    }
&nbsp;
    private void <strong>method6</strong>() {
        int[]   int_array = null;
        float[] float_array = null;
        int[][] int_matrix = null;
    }
&nbsp;
    private void <strong>method7</strong>() {
        String  str = null;
        Color   color = null;
        Color[] colors = null;
    }
&nbsp;
    private void <strong>method8</strong>() {
        List&lt;String&gt;       list = null;
        Set&lt;Integer&gt;       set = null;
        Map&lt;Float, String&gt; map = null;
        Queue&lt;Color&gt;       queue = null;
        Deque&lt;String&gt;      double_ended_queue = null;
    }
&nbsp;
    private void <strong>method9</strong>(int x, float y, boolean z) {
        List&lt;String&gt;       list = null;
        Set&lt;Integer&gt;       set = null;
        Map&lt;Float, String&gt; map = null;
        Queue&lt;Color&gt;       queue = null;
        Deque&lt;String&gt;      double_ended_queue = null;
    }
&nbsp;
    private static void <strong>static_method1</strong>() {
    }
&nbsp;
    private static void <strong>static_method2</strong>() {
        int x = 0;
    }
&nbsp;
    private static void <strong>static_method3</strong>() {
        int x = 1;
        int y = 2;
    }
&nbsp;
    private static void <strong>static_method4</strong>() {
        byte    byte_variable = 1;
        short   short_variable = 2;
        int     int_variable = 3;
        long    long_variable = 4;
    }
&nbsp;
    private static void <strong>static_method5</strong>() {
        char    char_variable = 'a';
        float   float_variable = 1/2f;
        double  double_variable = 1/2.0;
        boolean boolean_variable = true;
    }
&nbsp;
    private static void <strong>static_method6</strong>() {
        int[]   int_array = null;
        float[] float_array = null;
        int[][] int_matrix = null;
    }
&nbsp;
    private static void <strong>static_method7</strong>() {
        String  str = null;
        Color   color = null;
        Color[] colors = null;
    }
&nbsp;
    private static void <strong>static_method8</strong>() {
        List&lt;String&gt;       list = null;
        Set&lt;Integer&gt;       set = null;
        Map&lt;Float, String&gt; map = null;
        Queue&lt;Color&gt;       queue = null;
        Deque&lt;String&gt;      double_ended_queue = null;
    }
&nbsp;
    private static void <strong>static_method9</strong>(int x, float y, boolean z) {
        List&lt;String&gt;       list = null;
        Set&lt;Integer&gt;       set = null;
        Map&lt;Float, String&gt; map = null;
        Queue&lt;Color&gt;       queue = null;
        Deque&lt;String&gt;      double_ended_queue = null;
    }
&nbsp;
<i>    /**</i>
<i>      * Spusteni testu.</i>
<i>      */</i>
    public static void <strong>main</strong>(String[] args) {
    }
&nbsp;
}
</pre>

<p>Nesmíme zapomenout na to, ¾e se tato testovací tøída musí pøekládat
s&nbsp;pøepínaèem <strong>-g</strong>, aby do¹lo k&nbsp;ulo¾ení v¹ech
dùle¾itých ladicích informací do výsledného bajtkódu:</p>

<pre>
javac -g Test34.java
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Spu¹tìní 34. demonstraèního JVM TI agenta</h2>

<p>Po pøekladu tøicátého ètvrtého demonstraèního <i>JVM TI</i> agenta je ji¾
mo¾né si vyzkou¹et jeho spu¹tìní. Pokud je pøi pøekladu nastavena symbolická
konstanta <strong>UPDATE_VAR_NAMES</strong> na nulovou hodnotu, vypí¹e agent po
své inicializaci a spu¹tìní následující informace o metodách testovací tøídy
<strong>Test34</strong>. Za pov¹imnutí stojí pøedev¹ím rozdíl mezi statickou a
nestatickou variantou té¾e metody (<strong>method1</strong> vs
<strong>static_method1</strong> apod.):</p>

<pre>
Agent34: Agent_OnLoad
Agent34: JVM TI version is correct
Agent34: Got VM init event
Agent34: Class Test34; prepared, processing all methods in this class
Agent34:
Agent34:     <strong>method &lt;init&gt; with signature ()V</strong>
Agent34:         number of local variables 1:
Agent34:          0  this                  LTest34;             (null)
Agent34:
Agent34:     <strong>method main with signature ([Ljava/lang/String;)V</strong>
Agent34:         number of local variables 1:
Agent34:          0  args                  [Ljava/lang/String;  (null)
Agent34:
Agent34:     <strong>method method1 with signature ()V</strong>
Agent34:         number of local variables 1:
Agent34:          0  this                  LTest34;             (null)
Agent34:
Agent34:     <strong>method method2 with signature ()V</strong>
Agent34:         number of local variables 2:
Agent34:          0  this                  LTest34;             (null)
Agent34:          1  x                     I                    (null)
Agent34:
Agent34:     <strong>method method3 with signature ()V</strong>
Agent34:         number of local variables 3:
Agent34:          0  this                  LTest34;             (null)
Agent34:          1  x                     I                    (null)
Agent34:          2  y                     I                    (null)
Agent34:
Agent34:     <strong>method method4 with signature ()V</strong>
Agent34:         number of local variables 5:
Agent34:          0  this                  LTest34;             (null)
Agent34:          1  byte_variable         B                    (null)
Agent34:          2  short_variable        S                    (null)
Agent34:          3  int_variable          I                    (null)
Agent34:          4  long_variable         J                    (null)
Agent34:
Agent34:     <strong>method method5 with signature ()V</strong>
Agent34:         number of local variables 5:
Agent34:          0  this                  LTest34;             (null)
Agent34:          1  char_variable         C                    (null)
Agent34:          2  float_variable        F                    (null)
Agent34:          3  double_variable       D                    (null)
Agent34:          4  boolean_variable      Z                    (null)
Agent34:
Agent34:     <strong>method method6 with signature ()V</strong>
Agent34:         number of local variables 4:
Agent34:          0  this                  LTest34;             (null)
Agent34:          1  int_array             [I                   (null)
Agent34:          2  float_array           [F                   (null)
Agent34:          3  int_matrix            [[I                  (null)
Agent34:
Agent34:     <strong>method method7 with signature ()V</strong>
Agent34:         number of local variables 4:
Agent34:          0  this                  LTest34;             (null)
Agent34:          1  str                   Ljava/lang/String;   (null)
Agent34:          2  color                 Ljava/awt/Color;     (null)
Agent34:          3  colors                [Ljava/awt/Color;    (null)
Agent34:
Agent34:     <strong>method method8 with signature ()V</strong>
Agent34:         number of local variables 6:
Agent34:          0  this                  LTest34;             (null)
Agent34:          1  list                  Ljava/util/List;     Ljava/util/List&lt;Ljava/lang/String;&gt;;
Agent34:          2  set                   Ljava/util/Set;      Ljava/util/Set&lt;Ljava/lang/Integer;&gt;;
Agent34:          3  map                   Ljava/util/Map;      Ljava/util/Map&lt;Ljava/lang/Float;Ljava/lang/String;&gt;;
Agent34:          4  queue                 Ljava/util/Queue;    Ljava/util/Queue&lt;Ljava/awt/Color;&gt;;
Agent34:          5  double_ended_queue    Ljava/util/Deque;    Ljava/util/Deque&lt;Ljava/lang/String;&gt;;
Agent34:
Agent34:     <strong>method method9 with signature (IFZ)V</strong>
Agent34:         number of local variables 9:
Agent34:          0  this                  LTest34;             (null)
Agent34:          1  x                     I                    (null)
Agent34:          2  y                     F                    (null)
Agent34:          3  z                     Z                    (null)
Agent34:          4  list                  Ljava/util/List;     Ljava/util/List&lt;Ljava/lang/String;&gt;;
Agent34:          5  set                   Ljava/util/Set;      Ljava/util/Set&lt;Ljava/lang/Integer;&gt;;
Agent34:          6  map                   Ljava/util/Map;      Ljava/util/Map&lt;Ljava/lang/Float;Ljava/lang/String;&gt;;
Agent34:          7  queue                 Ljava/util/Queue;    Ljava/util/Queue&lt;Ljava/awt/Color;&gt;;
Agent34:          8  double_ended_queue    Ljava/util/Deque;    Ljava/util/Deque&lt;Ljava/lang/String;&gt;;
Agent34:
Agent34:     <strong>method static_method1 with signature ()V</strong>
Agent34:         number of local variables 0:
Agent34:
Agent34:     <strong>method static_method2 with signature ()V</strong>
Agent34:         number of local variables 1:
Agent34:          0  x                     I                    (null)
Agent34:
Agent34:     <strong>method static_method3 with signature ()V</strong>
Agent34:         number of local variables 2:
Agent34:          0  x                     I                    (null)
Agent34:          1  y                     I                    (null)
Agent34:
Agent34:     <strong>method static_method4 with signature ()V</strong>
Agent34:         number of local variables 4:
Agent34:          0  byte_variable         B                    (null)
Agent34:          1  short_variable        S                    (null)
Agent34:          2  int_variable          I                    (null)
Agent34:          3  long_variable         J                    (null)
Agent34:
Agent34:     <strong>method static_method5 with signature ()V</strong>
Agent34:         number of local variables 4:
Agent34:          0  char_variable         C                    (null)
Agent34:          1  float_variable        F                    (null)
Agent34:          2  double_variable       D                    (null)
Agent34:          3  boolean_variable      Z                    (null)
Agent34:
Agent34:     <strong>method static_method6 with signature ()V</strong>
Agent34:         number of local variables 3:
Agent34:          0  int_array             [I                   (null)
Agent34:          1  float_array           [F                   (null)
Agent34:          2  int_matrix            [[I                  (null)
Agent34:
Agent34:     <strong>method static_method7 with signature ()V</strong>
Agent34:         number of local variables 3:
Agent34:          0  str                   Ljava/lang/String;   (null)
Agent34:          1  color                 Ljava/awt/Color;     (null)
Agent34:          2  colors                [Ljava/awt/Color;    (null)
Agent34:
Agent34:     <strong>method static_method8 with signature ()V</strong>
Agent34:         number of local variables 5:
Agent34:          0  list                  Ljava/util/List;     Ljava/util/List&lt;Ljava/lang/String;&gt;;
Agent34:          1  set                   Ljava/util/Set;      Ljava/util/Set&lt;Ljava/lang/Integer;&gt;;
Agent34:          2  map                   Ljava/util/Map;      Ljava/util/Map&lt;Ljava/lang/Float;Ljava/lang/String;&gt;;
Agent34:          3  queue                 Ljava/util/Queue;    Ljava/util/Queue&lt;Ljava/awt/Color;&gt;;
Agent34:          4  double_ended_queue    Ljava/util/Deque;    Ljava/util/Deque&lt;Ljava/lang/String;&gt;;
Agent34:
Agent34:     <strong>method static_method9 with signature (IFZ)V</strong>
Agent34:         number of local variables 8:
Agent34:          0  x                     I                    (null)
Agent34:          1  y                     F                    (null)
Agent34:          2  z                     Z                    (null)
Agent34:          3  list                  Ljava/util/List;     Ljava/util/List&lt;Ljava/lang/String;&gt;;
Agent34:          4  set                   Ljava/util/Set;      Ljava/util/Set&lt;Ljava/lang/Integer;&gt;;
Agent34:          5  map                   Ljava/util/Map;      Ljava/util/Map&lt;Ljava/lang/Float;Ljava/lang/String;&gt;;
Agent34:          6  queue                 Ljava/util/Queue;    Ljava/util/Queue&lt;Ljava/awt/Color;&gt;;
Agent34:          7  double_ended_queue    Ljava/util/Deque;    Ljava/util/Deque&lt;Ljava/lang/String;&gt;;
Agent34: Got VM Death event
Agent34: Agent_OnUnload
</pre>

<p>V&nbsp;pøípadì, ¾e naopak nastavíme symbolickou konstantu
<strong>UPDATE_VAR_NAMES</strong> na hodnotu 1, dojde pøi výpisu parametrù
metod i jejich lokálních promìnných k&nbsp;úpravì typu promìnné i pøípadné
úpravì generického typu, tak¾e je výstup mnohem èitelnìj¹í:</p>

<pre>
Agent34: Agent_OnLoad
Agent34: JVM TI version is correct
Agent34: Got VM init event
Agent34: Class Test34; prepared, processing all methods in this class
Agent34:
Agent34:     <strong>method &lt;init&gt; with signature ()V</strong>
Agent34:         number of local variables 1:
Agent34:          0  this                  Test34
Agent34:
Agent34:     <strong>method main with signature ([Ljava/lang/String;)V</strong>
Agent34:         number of local variables 1:
Agent34:          0  args                  array of java.lang.String
Agent34:
Agent34:     <strong>method method1 with signature ()V</strong>
Agent34:         number of local variables 1:
Agent34:          0  this                  Test34
Agent34:
Agent34:     <strong>method method2 with signature ()V</strong>
Agent34:         number of local variables 2:
Agent34:          0  this                  Test34
Agent34:          1  x                     int
Agent34:
Agent34:     <strong>method method3 with signature ()V</strong>
Agent34:         number of local variables 3:
Agent34:          0  this                  Test34
Agent34:          1  x                     int
Agent34:          2  y                     int
Agent34:
Agent34:     <strong>method method4 with signature ()V</strong>
Agent34:         number of local variables 5:
Agent34:          0  this                  Test34
Agent34:          1  byte_variable         byte
Agent34:          2  short_variable        short
Agent34:          3  int_variable          int
Agent34:          4  long_variable         long
Agent34:
Agent34:     <strong>method method5 with signature ()V</strong>
Agent34:         number of local variables 5:
Agent34:          0  this                  Test34
Agent34:          1  char_variable         char
Agent34:          2  float_variable        float
Agent34:          3  double_variable       double
Agent34:          4  boolean_variable      boolean
Agent34:
Agent34:     <strong>method method6 with signature ()V</strong>
Agent34:         number of local variables 4:
Agent34:          0  this                  Test34
Agent34:          1  int_array             array of int
Agent34:          2  float_array           array of float
Agent34:          3  int_matrix            array of array of int
Agent34:
Agent34:     <strong>method method7 with signature ()V</strong>
Agent34:         number of local variables 4:
Agent34:          0  this                  Test34
Agent34:          1  str                   java.lang.String
Agent34:          2  color                 java.awt.Color
Agent34:          3  colors                array of java.awt.Color
Agent34:
Agent34:     <strong>method method8 with signature ()V</strong>
Agent34:         number of local variables 6:
Agent34:          0  this                  Test34
Agent34:          1  list                  java.util.List       java.util.List&lt;java.lang.String&gt;;
Agent34:          2  set                   java.util.Set        java.util.Set&lt;java.lang.Integer&gt;;
Agent34:          3  map                   java.util.Map        java.util.Map&lt;java.lang.Float,java.lang.String&gt;;
Agent34:          4  queue                 java.util.Queue      java.util.Queue&lt;java.awt.Color&gt;;
Agent34:          5  double_ended_queue    java.util.Deque      java.util.Deque&lt;java.lang.String&gt;;
Agent34:
Agent34:     <strong>method method9 with signature (IFZ)V</strong>
Agent34:         number of local variables 9:
Agent34:          0  this                  Test34
Agent34:          1  x                     int
Agent34:          2  y                     float
Agent34:          3  z                     boolean
Agent34:          4  list                  java.util.List       java.util.List&lt;java.lang.String&gt;;
Agent34:          5  set                   java.util.Set        java.util.Set&lt;java.lang.Integer&gt;;
Agent34:          6  map                   java.util.Map        java.util.Map&lt;java.lang.Float,java.lang.String&gt;;
Agent34:          7  queue                 java.util.Queue      java.util.Queue&lt;java.awt.Color&gt;;
Agent34:          8  double_ended_queue    java.util.Deque      java.util.Deque&lt;java.lang.String&gt;;
Agent34:
Agent34:     <strong>method static_method1 with signature ()V</strong>
Agent34:         number of local variables 0:
Agent34:
Agent34:     <strong>method static_method2 with signature ()V</strong>
Agent34:         number of local variables 1:
Agent34:          0  x                     int
Agent34:
Agent34:     <strong>method static_method3 with signature ()V</strong>
Agent34:         number of local variables 2:
Agent34:          0  x                     int
Agent34:          1  y                     int
Agent34:
Agent34:     <strong>method static_method4 with signature ()V</strong>
Agent34:         number of local variables 4:
Agent34:          0  byte_variable         byte
Agent34:          1  short_variable        short
Agent34:          2  int_variable          int
Agent34:          3  long_variable         long
Agent34:
Agent34:     <strong>method static_method5 with signature ()V</strong>
Agent34:         number of local variables 4:
Agent34:          0  char_variable         char
Agent34:          1  float_variable        float
Agent34:          2  double_variable       double
Agent34:          3  boolean_variable      boolean
Agent34:
Agent34:     <strong>method static_method6 with signature ()V</strong>
Agent34:         number of local variables 3:
Agent34:          0  int_array             array of int
Agent34:          1  float_array           array of float
Agent34:          2  int_matrix            array of array of int
Agent34:
Agent34:     <strong>method static_method7 with signature ()V</strong>
Agent34:         number of local variables 3:
Agent34:          0  str                   java.lang.String
Agent34:          1  color                 java.awt.Color
Agent34:          2  colors                array of java.awt.Color
Agent34:
Agent34:     <strong>method static_method8 with signature ()V</strong>
Agent34:         number of local variables 5:
Agent34:          0  list                  java.util.List       java.util.List&lt;java.lang.String&gt;;
Agent34:          1  set                   java.util.Set        java.util.Set&lt;java.lang.Integer&gt;;
Agent34:          2  map                   java.util.Map        java.util.Map&lt;java.lang.Float,java.lang.String&gt;;
Agent34:          3  queue                 java.util.Queue      java.util.Queue&lt;java.awt.Color&gt;;
Agent34:          4  double_ended_queue    java.util.Deque      java.util.Deque&lt;java.lang.String&gt;;
Agent34:
Agent34:     <strong>method static_method9 with signature (IFZ)V</strong>
Agent34:         number of local variables 8:
Agent34:          0  x                     int
Agent34:          1  y                     float
Agent34:          2  z                     boolean
Agent34:          3  list                  java.util.List       java.util.List&lt;java.lang.String&gt;;
Agent34:          4  set                   java.util.Set        java.util.Set&lt;java.lang.Integer&gt;;
Agent34:          5  map                   java.util.Map        java.util.Map&lt;java.lang.Float,java.lang.String&gt;;
Agent34:          6  queue                 java.util.Queue      java.util.Queue&lt;java.awt.Color&gt;;
Agent34:          7  double_ended_queue    java.util.Deque      java.util.Deque&lt;java.lang.String&gt;;
Agent34: Got VM Death event
Agent34: Agent_OnUnload
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Porovnání výstupu JVM TI agenta s&nbsp;výpisem získaným pøes nástroj <strong>javap</strong></h2>

<p>Po kontrolu korektnosti informací vypsaných demonstraèním <i>JVM TI</i>
agentem si vyzkou¹ejme, jaké informace se zobrazí po zadání pøíkazu:</p>

<pre>
javap -verbose -private Test34
</pre>

<p>Pokud byla testovací tøída <strong>Test34</strong> pøelo¾ena s&nbsp;ladicími
informacemi, získáme následující výstup:</p>

<pre>
Compiled from "Test34.java"
public class Test34 extends java.lang.Object
  SourceFile: "Test34.java"
  minor version: 0
  major version: 50
  Constant pool:
const #1 = Method       #9.#89; //  java/lang/Object."&lt;init&gt;":()V
const #2 = long 4l;
const #4 = float        0.5f;
const #5 = double       0.5d;
const #7 = class        #46;    //  "[[I"
const #8 = class        #90;    //  Test34
const #9 = class        #91;    //  java/lang/Object
const #10 = Asciz       &lt;init&gt;;
const #11 = Asciz       ()V;
const #12 = Asciz       Code;
const #13 = Asciz       LineNumberTable;
const #14 = Asciz       LocalVariableTable;
const #15 = Asciz       this;
const #16 = Asciz       LTest34;;
const #17 = Asciz       method1;
const #18 = Asciz       method2;
const #19 = Asciz       x;
const #20 = Asciz       I;
const #21 = Asciz       method3;
const #22 = Asciz       y;
const #23 = Asciz       method4;
const #24 = Asciz       byte_variable;
const #25 = Asciz       B;
const #26 = Asciz       short_variable;
const #27 = Asciz       S;
const #28 = Asciz       int_variable;
const #29 = Asciz       long_variable;
const #30 = Asciz       J;
const #31 = Asciz       method5;
const #32 = Asciz       char_variable;
const #33 = Asciz       C;
const #34 = Asciz       float_variable;
const #35 = Asciz       F;
const #36 = Asciz       double_variable;
const #37 = Asciz       D;
const #38 = Asciz       boolean_variable;
const #39 = Asciz       Z;
const #40 = Asciz       method6;
const #41 = Asciz       int_array;
const #42 = Asciz       [I;
const #43 = Asciz       float_array;
const #44 = Asciz       [F;
const #45 = Asciz       int_matrix;
const #46 = Asciz       [[I;
const #47 = Asciz       method7;
const #48 = Asciz       str;
const #49 = Asciz       Ljava/lang/String;;
const #50 = Asciz       color;
const #51 = Asciz       Ljava/awt/Color;;
const #52 = Asciz       colors;
const #53 = Asciz       [Ljava/awt/Color;;
const #54 = Asciz       method8;
const #55 = Asciz       list;
const #56 = Asciz       Ljava/util/List;;
const #57 = Asciz       set;
const #58 = Asciz       Ljava/util/Set;;
const #59 = Asciz       map;
const #60 = Asciz       Ljava/util/Map;;
const #61 = Asciz       queue;
const #62 = Asciz       Ljava/util/Queue;;
const #63 = Asciz       double_ended_queue;
const #64 = Asciz       Ljava/util/Deque;;
const #65 = Asciz       LocalVariableTypeTable;
const #66 = Asciz       Ljava/util/List&lt;Ljava/lang/String;&gt;;;
const #67 = Asciz       Ljava/util/Set&lt;Ljava/lang/Integer;&gt;;;
const #68 = Asciz       Ljava/util/Map&lt;Ljava/lang/Float;Ljava/lang/String;&gt;;;
const #69 = Asciz       Ljava/util/Queue&lt;Ljava/awt/Color;&gt;;;
const #70 = Asciz       Ljava/util/Deque&lt;Ljava/lang/String;&gt;;;
const #71 = Asciz       method9;
const #72 = Asciz       (IFZ)V;
const #73 = Asciz       z;
const #74 = Asciz       static_method1;
const #75 = Asciz       static_method2;
const #76 = Asciz       static_method3;
const #77 = Asciz       static_method4;
const #78 = Asciz       static_method5;
const #79 = Asciz       static_method6;
const #80 = Asciz       static_method7;
const #81 = Asciz       static_method8;
const #82 = Asciz       static_method9;
const #83 = Asciz       main;
const #84 = Asciz       ([Ljava/lang/String;)V;
const #85 = Asciz       args;
const #86 = Asciz       [Ljava/lang/String;;
const #87 = Asciz       SourceFile;
const #88 = Asciz       Test34.java;
const #89 = NameAndType #10:#11;//  "&lt;init&gt;":()V
const #90 = Asciz       Test34;
const #91 = Asciz       java/lang/Object;
&nbsp;
{
<strong>public Test34();</strong>
  Code:
   Stack=1, Locals=1, Args_size=1
   0:   aload_0
   1:   invokespecial   #1; //Method java/lang/Object."&lt;init&gt;":()V
   4:   return
  LineNumberTable:
   line 11: 0
&nbsp;
  LocalVariableTable:
   Start  Length  Slot  Name   Signature
   0      5       0     this   LTest34;
&nbsp;
&nbsp;
<strong>private void method1();</strong>
  Code:
   Stack=0, Locals=1, Args_size=1
   0:   return
  LineNumberTable:
   line 14: 0
&nbsp;
  LocalVariableTable:
   Start  Length  Slot  Name   Signature
   0      1       0     this   LTest34;
&nbsp;
&nbsp;
<strong>private void method2();</strong>
  Code:
   Stack=1, Locals=2, Args_size=1
   0:   iconst_0
   1:   istore_1
   2:   return
  LineNumberTable:
   line 17: 0
   line 18: 2
&nbsp;
  LocalVariableTable:
   Start  Length  Slot  Name   Signature
   0      3       0     this   LTest34;
   2      1       1     x      I
&nbsp;
&nbsp;
<strong>private void method3();</strong>
  Code:
   Stack=1, Locals=3, Args_size=1
   0:   iconst_1
   1:   istore_1
   2:   iconst_2
   3:   istore_2
   4:   return
  LineNumberTable:
   line 21: 0
   line 22: 2
   line 23: 4
&nbsp;
  LocalVariableTable:
   Start  Length  Slot  Name   Signature
   0      5       0     this   LTest34;
   2      3       1     x      I
   4      1       2     y      I
&nbsp;
&nbsp;
<strong>private void method4();</strong>
  Code:
   Stack=2, Locals=6, Args_size=1
   0:   iconst_1
   1:   istore_1
   2:   iconst_2
   3:   istore_2
   4:   iconst_3
   5:   istore_3
   6:   ldc2_w  #2; //long 4l
   9:   lstore  4
   11:  return
  LineNumberTable:
   line 26: 0
   line 27: 2
   line 28: 4
   line 29: 6
   line 30: 11
&nbsp;
  LocalVariableTable:
   Start  Length  Slot  Name           Signature
   0      12      0     this           LTest34;
   2      10      1     byte_variable  B
   4       8      2     short_variable S
   6       6      3     int_variable   I
   11      1      4     long_variable  J
&nbsp;
&nbsp;
<strong>private void method5();</strong>
  Code:
   Stack=2, Locals=6, Args_size=1
   0:   bipush  97
   2:   istore_1
   3:   ldc     #4; //float 0.5f
   5:   fstore_2
   6:   ldc2_w  #5; //double 0.5d
   9:   dstore_3
   10:  iconst_1
   11:  istore  5
   13:  return
  LineNumberTable:
   line 33: 0
   line 34: 3
   line 35: 6
   line 36: 10
   line 37: 13
&nbsp;
  LocalVariableTable:
   Start  Length  Slot  Name             Signature
   0      14      0     this             LTest34;
   3      11      1     char_variable    C
   6       8      2     float_variable   F
   10      4      3     double_variable  D
   13      1      5     boolean_variable Z
&nbsp;
&nbsp;
<strong>private void method6();</strong>
  Code:
   Stack=1, Locals=4, Args_size=1
   0:   aconst_null
   1:   astore_1
   2:   aconst_null
   3:   astore_2
   4:   aconst_null
   5:   checkcast       #7; //class "[[I"
   8:   astore_3
   9:   return
  LineNumberTable:
   line 40: 0
   line 41: 2
   line 42: 4
   line 43: 9
&nbsp;
  LocalVariableTable:
   Start  Length  Slot  Name         Signature
   0      10      0     this         LTest34;
   2      8       1     int_array    [I
   4      6       2     float_array  [F
   9      1       3     int_matrix   [[I
&nbsp;
&nbsp;
<strong>private void method7();</strong>
  Code:
   Stack=1, Locals=4, Args_size=1
   0:   aconst_null
   1:   astore_1
   2:   aconst_null
   3:   astore_2
   4:   aconst_null
   5:   astore_3
   6:   return
  LineNumberTable:
   line 46: 0
   line 47: 2
   line 48: 4
   line 49: 6
&nbsp;
  LocalVariableTable:
   Start  Length  Slot  Name      Signature
   0      7       0     this      LTest34;
   2      5       1     str       Ljava/lang/String;
   4      3       2     color     Ljava/awt/Color;
   6      1       3     colors    [Ljava/awt/Color;
&nbsp;
&nbsp;
<strong>private void method8();</strong>
  Code:
   Stack=1, Locals=6, Args_size=1
   0:   aconst_null
   1:   astore_1
   2:   aconst_null
   3:   astore_2
   4:   aconst_null
   5:   astore_3
   6:   aconst_null
   7:   astore  4
   9:   aconst_null
   10:  astore  5
   12:  return
  LineNumberTable:
   line 52: 0
   line 53: 2
   line 54: 4
   line 55: 6
   line 56: 9
   line 57: 12
&nbsp;
  LocalVariableTable:
   Start  Length  Slot  Name                Signature
   0      13      0     this                LTest34;
   2      11      1     list                Ljava/util/List;
   4       9      2     set                 Ljava/util/Set;
   6       7      3     map                 Ljava/util/Map;
   9       4      4     queue               Ljava/util/Queue;
   12      1      5     double_ended_queue  Ljava/util/Deque;
&nbsp;
  LocalVariableTypeTable: length = 0x34
   00 05 00 02 00 0B 00 37 00 42 00 01 00 04 00 09
   00 39 00 43 00 02 00 06 00 07 00 3B 00 44 00 03
   00 09 00 04 00 3D 00 45 00 04 00 0C 00 01 00 3F
   00 46 00 05
&nbsp;
<strong>private void method9(int, float, boolean);</strong>
  Code:
   Stack=1, Locals=9, Args_size=4
   0:   aconst_null
   1:   astore  4
   3:   aconst_null
   4:   astore  5
   6:   aconst_null
   7:   astore  6
   9:   aconst_null
   10:  astore  7
   12:  aconst_null
   13:  astore  8
   15:  return
  LineNumberTable:
   line 60: 0
   line 61: 3
   line 62: 6
   line 63: 9
   line 64: 12
   line 65: 15
&nbsp;
  LocalVariableTable:
   Start  Length  Slot  Name                Signature
   0      16      0     this                LTest34;
   0      16      1     x                   I
   0      16      2     y                   F
   0      16      3     z                   Z
   3      13      4     list                Ljava/util/List;
   6      10      5     set                 Ljava/util/Set;
   9       7      6     map                 Ljava/util/Map;
   12      4      7     queue               Ljava/util/Queue;
   15      1      8     double_ended_queue  Ljava/util/Deque;
&nbsp;
  LocalVariableTypeTable: length = 0x34
   00 05 00 03 00 0D 00 37 00 42 00 04 00 06 00 0A
   00 39 00 43 00 05 00 09 00 07 00 3B 00 44 00 06
   00 0C 00 04 00 3D 00 45 00 07 00 0F 00 01 00 3F
   00 46 00 08
&nbsp;
<strong>private static void static_method1();</strong>
  Code:
   Stack=0, Locals=0, Args_size=0
   0:   return
  LineNumberTable:
   line 68: 0
&nbsp;
&nbsp;
<strong>private static void static_method2();</strong>
  Code:
   Stack=1, Locals=1, Args_size=0
   0:   iconst_0
   1:   istore_0
   2:   return
  LineNumberTable:
   line 71: 0
   line 72: 2
&nbsp;
  LocalVariableTable:
   Start  Length  Slot  Name   Signature
   2      1       0     x      I
&nbsp;
&nbsp;
<strong>private static void static_method3();</strong>
  Code:
   Stack=1, Locals=2, Args_size=0
   0:   iconst_1
   1:   istore_0
   2:   iconst_2
   3:   istore_1
   4:   return
  LineNumberTable:
   line 75: 0
   line 76: 2
   line 77: 4
&nbsp;
  LocalVariableTable:
   Start  Length  Slot  Name   Signature
   2      3       0     x      I
   4      1       1     y      I
&nbsp;
&nbsp;
<strong>private static void static_method4();</strong>
  Code:
   Stack=2, Locals=5, Args_size=0
   0:   iconst_1
   1:   istore_0
   2:   iconst_2
   3:   istore_1
   4:   iconst_3
   5:   istore_2
   6:   ldc2_w  #2; //long 4l
   9:   lstore_3
   10:  return
  LineNumberTable:
   line 80: 0
   line 81: 2
   line 82: 4
   line 83: 6
   line 84: 10
&nbsp;
  LocalVariableTable:
   Start  Length  Slot  Name            Signature
   2      9       0     byte_variable   B
   4      7       1     short_variable  S
   6      5       2     int_variable    I
   10     1       3     long_variable   J
&nbsp;
&nbsp;
<strong>private static void static_method5();</strong>
  Code:
   Stack=2, Locals=5, Args_size=0
   0:   bipush  97
   2:   istore_0
   3:   ldc     #4; //float 0.5f
   5:   fstore_1
   6:   ldc2_w  #5; //double 0.5d
   9:   dstore_2
   10:  iconst_1
   11:  istore  4
   13:  return
  LineNumberTable:
   line 87: 0
   line 88: 3
   line 89: 6
   line 90: 10
   line 91: 13
&nbsp;
  LocalVariableTable:
   Start  Length  Slot  Name              Signature
   3      11      0     char_variable     C
   6       8      1     float_variable    F
   10      4      2     double_variable   D
   13      1      4     boolean_variable  Z
&nbsp;
&nbsp;
<strong>private static void static_method6();</strong>
  Code:
   Stack=1, Locals=3, Args_size=0
   0:   aconst_null
   1:   astore_0
   2:   aconst_null
   3:   astore_1
   4:   aconst_null
   5:   checkcast       #7; //class "[[I"
   8:   astore_2
   9:   return
  LineNumberTable:
   line 94: 0
   line 95: 2
   line 96: 4
   line 97: 9
&nbsp;
  LocalVariableTable:
   Start  Length  Slot  Name          Signature
   2      8       0     int_array     [I
   4      6       1     float_array   [F
   9      1       2     int_matrix    [[I
&nbsp;
&nbsp;
<strong>private static void static_method7();</strong>
  Code:
   Stack=1, Locals=3, Args_size=0
   0:   aconst_null
   1:   astore_0
   2:   aconst_null
   3:   astore_1
   4:   aconst_null
   5:   astore_2
   6:   return
  LineNumberTable:
   line 100: 0
   line 101: 2
   line 102: 4
   line 103: 6
&nbsp;
  LocalVariableTable:
   Start  Length  Slot  Name      Signature
   2      5       0     str       Ljava/lang/String;
   4      3       1     color     Ljava/awt/Color;
   6      1       2     colors    [Ljava/awt/Color;
&nbsp;
&nbsp;
<strong>private static void static_method8();</strong>
  Code:
   Stack=1, Locals=5, Args_size=0
   0:   aconst_null
   1:   astore_0
   2:   aconst_null
   3:   astore_1
   4:   aconst_null
   5:   astore_2
   6:   aconst_null
   7:   astore_3
   8:   aconst_null
   9:   astore  4
   11:  return
  LineNumberTable:
   line 106: 0
   line 107: 2
   line 108: 4
   line 109: 6
   line 110: 8
   line 111: 11
&nbsp;
  LocalVariableTable:
   Start  Length  Slot  Name                Signature
   2      10      0     list                Ljava/util/List;
   4       8      1     set                 Ljava/util/Set;
   6       6      2     map                 Ljava/util/Map;
   8       4      3     queue               Ljava/util/Queue;
   11      1      4     double_ended_queue  Ljava/util/Deque;
&nbsp;
  LocalVariableTypeTable: length = 0x34
   00 05 00 02 00 0A 00 37 00 42 00 00 00 04 00 08
   00 39 00 43 00 01 00 06 00 06 00 3B 00 44 00 02
   00 08 00 04 00 3D 00 45 00 03 00 0B 00 01 00 3F
   00 46 00 04
&nbsp;
<strong>private static void static_method9(int, float, boolean);</strong>
  Code:
   Stack=1, Locals=8, Args_size=3
   0:   aconst_null
   1:   astore_3
   2:   aconst_null
   3:   astore  4
   5:   aconst_null
   6:   astore  5
   8:   aconst_null
   9:   astore  6
   11:  aconst_null
   12:  astore  7
   14:  return
  LineNumberTable:
   line 114: 0
   line 115: 2
   line 116: 5
   line 117: 8
   line 118: 11
   line 119: 14
&nbsp;
  LocalVariableTable:
   Start  Length  Slot  Name                Signature
   0      15      0     x                   I
   0      15      1     y                   F
   0      15      2     z                   Z
   2      13      3     list                Ljava/util/List;
   5      10      4     set                 Ljava/util/Set;
   8       7      5     map                 Ljava/util/Map;
   11      4      6     queue               Ljava/util/Queue;
   14      1      7     double_ended_queue  Ljava/util/Deque;
&nbsp;
  LocalVariableTypeTable: length = 0x34
   00 05 00 02 00 0D 00 37 00 42 00 03 00 05 00 0A
   00 39 00 43 00 04 00 08 00 07 00 3B 00 44 00 05
   00 0B 00 04 00 3D 00 45 00 06 00 0E 00 01 00 3F
   00 46 00 07
&nbsp;
<strong>public static void main(java.lang.String[]);</strong>
  Code:
   Stack=0, Locals=1, Args_size=1
   0:   return
  LineNumberTable:
   line 125: 0
&nbsp;
  LocalVariableTable:
   Start  Length  Slot  Name   Signature
   0      1       0     args   [Ljava/lang/String;
&nbsp;
&nbsp;
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Zdrojové kódy 34.demonstraèního agenta i k&nbsp;nìmu pøíslu¹ných testovacích pøíkladù a skriptù</h2>

<p>Zdrojový kód tøicátého ètvrtého demonstraèního <i>JVM TI</i> agenta je,
spoleènì s&nbsp;testovací tøídou nazvanou <strong>Test34</strong> i se skripty
pou¾itými pro pøeklad a spu¹tìní agenta, ulo¾en do Mercurial repositáøe
dostupného na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
Prozatím nejnovìj¹í verze v¹ech zmínìných zdrojových souborù mù¾ete najít na
adresách:</p>

<table>
<tr><td>Agent #34                     </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/b6e6ecaed221/jvmti-agents/agent34/agent34.c">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/b6e6ecaed221/jvmti-agents/agent34/agent34.c</a></td></tr>
<tr><td>Testovací tøída Test34.java   </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/b6e6ecaed221/jvmti-agents/agent34/Test34.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/b6e6ecaed221/jvmti-agents/agent34/Test34.java</a></td></tr>
<tr><td>Skript pro pøeklad agenta #34 </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/b6e6ecaed221/jvmti-agents/agent34/compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/b6e6ecaed221/jvmti-agents/agent34/compile.sh</a></td></tr>
<tr><td>Skript pro spu¹tìní agenta #34</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/b6e6ecaed221/jvmti-agents/agent34/test.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/b6e6ecaed221/jvmti-agents/agent34/test.sh</a></td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Literatura a odkazy na Internetu</h2>

<ol>

<li>Breakpoint (Wikipedia)<br />
<a href="http://cs.wikipedia.org/wiki/Breakpoint">http://cs.wikipedia.org/wiki/Breakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation<br />
<a href="http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html">http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; SetBreakpoint<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#SetBreakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#SetBreakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; ClearBreakpoint<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#ClearBreakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#ClearBreakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; Breakpoint (callback funkce)<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#Breakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#Breakpoint</a>
</li>

<li>The JVM Tool Interface (JVM TI): How VM Agents Work<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html">http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html</a>
</li>

<li>Creating a Debugging and Profiling Agent with JVMTI<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html">http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html</a>
</li>

<li>JVM TI (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/JVM_TI">http://en.wikipedia.org/wiki/JVM_TI</a>
</li>

<li>IBM JVMTI extensions<br />
<a href="http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html">http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

