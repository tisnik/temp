<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Clojure 8: identity, stavy, nemìnné hodnoty a referenèní typy</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Clojure 8: identity, stavy, nemìnné hodnoty a referenèní typy</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;dne¹ní èásti seriálu o programovacím jazyce Java i o virtuálním stroji Javy se budeme zabývat zpùsobem reprezentace stavu aplikace v programovacím jazyce Clojure i technikami, které se mohou pou¾ít pro zmìnu tohoto stavu. V Clojure se toti¾ pro ulo¾ení stavu aplikace nepou¾ívají bì¾né promìnné ani atributy objektù, ale takzvané referenèní typy (zkrácenì reference).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyk Clojure 8: identity, stavy, nemìnné hodnoty a referenèní typy</a></p>
<p><a href="#k02">2. Ètyøi typy referencí podporovaných programovacím jazykem Clojure</a></p>
<p><a href="#k03">3. Zpùsoby vytvoøení v¹ech ètyø typù referencí</a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#k031">3.1 Vytvoøení reference typu &bdquo;var&ldquo;</a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#k032">3.2 Vytvoøení reference typu &bdquo;ref&ldquo;</a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#k033">3.3 Vytvoøení reference typu &bdquo;atom&ldquo;</a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#k034">3.4 Vytvoøení reference typu &bdquo;agent&ldquo;</a></p>
<p><a href="#k04">4. Referenèní typ &bdquo;Var&ldquo;</a></p>
<p><a href="#k05">5. Referenèní typ &bdquo;Ref&ldquo;</a></p>
<p><a href="#k06">6. Referenèní typ &bdquo;Atom&ldquo;</a></p>
<p><a href="#k07">7. Referenèní typ &bdquo;Agent&ldquo;</a></p>
<p><a href="#k08">8. Èekání na dokonèení akce poslané agentovi</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk Clojure 8: identity, stavy, nemìnné hodnoty a referenèní typy</h2>

<p>V&nbsp;pøedchozích dvou èástech <a
href="http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">[1]</a><a
href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">[2]</a>
<a href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">tohoto
seriálu</a> jsme se seznámili s&nbsp;nìkterými technologiemi poskytovanými
programovacím jazykem <i>Clojure</i>, které slou¾í k&nbsp;usnadnìní tvorby
vícevláknových programù. Pøipomeòme si, ¾e se v&nbsp;prvé øadì jednalo o
trojici funkcí/maker <strong>pmap</strong>, <strong>pcalls</strong> a
<strong>pvalues</strong>, které je mo¾né pou¾ít pro explicitní spu¹tìní
nìkolika výpoètù provádìných paralelnì. Dále jsme se pak zabývali objekty typu
<i>future</i> a <i>promise</i> slou¾ícími takté¾ ke spou¹tìní výpoètù
v&nbsp;samostatných vláknech. Následnì jsme si popsali technologii <i>STM
&ndash; Software Transactional Memory</i>, jen¾ umo¾òuje
&bdquo;zapouzdøit&ldquo; urèitou sekvenci pøíkazù do transakce reprezentované
funkcí <strong>dosync</strong>, která se provede z&nbsp;pohledu ostatních
vláken atomicky (resp.&nbsp;tak, ¾e jsou zaji¹tìny vlastnosti ACID).</p>

<p>Ov¹em tvùrci programovacího jazyka <i>Clojure</i>, pøevá¾nì pak jeho hlavní
vývojáø a souèasnì i zakladatel tohoto projektu <i>Rich Hickey</i>, si byli
vìdomi toho, ¾e pøi tvorbì paralelních programù je mnohdy nutné vyu¾ít vìt¹í
mno¾ství rùzných pøístupù k&nbsp;vývoji vícevláknových aplikací, které se od
sebe li¹í pøedev¹ím ve zpùsobu, jakým se mìní <i>stav</i> sdílených objektù,
neboli <i>identit</i> (v&nbsp;Clojure se pojmem <i>stav</i> oznaèují hodnoty
libovolného nemìnitelného &ndash; immutable &ndash; datového typu, napøíklad
èísla, pravdivostní hodnoty, seznamu, vektoru, mapy èi mno¾iny). Zmìna stavù
více identit toti¾ mù¾e být provedena buï <i>koordinovanì</i> èi naopak zcela
<i>nezávisle</i> na ostatních identitách. Koordinovaná zmìna stavu více identit
je provádìna uvnitø transakcí popsaných minule, tj.&nbsp;s&nbsp;vyu¾itím
objektù typu <i>ref</i>. Mimochodem: slovem <i>ref</i> se v&nbsp;Clojure
oznaèuje jeden ze ètyø typù &bdquo;referencí&ldquo;, ov¹em samotný pojem
&bdquo;reference&ldquo; má v&nbsp;programovacím jazyku Clojure odli¹ný význam,
ne¾ je tomu v&nbsp;Javì èi podobných programovacích jazycích. V&nbsp;jazyku
Clojure toti¾ reference v¾dy ukazuje na nemìnná data (ji¾ zmínìné numerické
hodnoty, seznamy, mno¾iny atd.).</p>

<p>Zmìna, resp.&nbsp;zmìny stavù identit se takté¾ odli¹ují v&nbsp;tom, ¾e
mohou být provedeny buï <i>synchronnì</i> èi <i>asynchronnì</i> &ndash; opìt
v&nbsp;závislosti na potøebách konkrétní vyvíjené aplikace. Synchronní zmìna
stavu identit je provedena ihned a tudí¾ pøímo ve vláknu, které tuto zmìnu
provádí (synchronní a souèasnì i nezávislá zmìna stavu identity je tedy
z&nbsp;hlediska vývojáøe prakticky toto¾ná se zmìnou hodnoty promìnné). Naopak
asynchronní zmìna stavu identit(y) nemusí být provedena ihned, ale nìkdy
v&nbsp;blí¾e neurèené budoucnosti. To znamená, ¾e asynchronní zmìnu je mo¾né
implementovat v&nbsp;jiném vláknì. Pou¾ití asynchronních zmìn je jedním
z&nbsp;nejjednodu¹¹ích zpùsobù vyu¾ití více vláken ve vyvíjených aplikacích,
co¾ jsme si ji¾ ostatnì ukázali na pøíkladu objektù typu <i>future</i> a
<i>promise</i>. Jak uvidíme v&nbsp;dal¹ích kapitolách, pou¾ívají se pro
implementaci asynchronnì probíhajících výpoètù i takzvaní <i>agenti</i>
(<i>agents</i>).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Ètyøi typy referencí podporovaných programovacím jazykem Clojure</h2>

<p><a href="#k01">V&nbsp;pøedchozí kapitole</a> jsme si øekli, ¾e
v&nbsp;programovacím jazyce Clojure existují ètyøi typy referencí, pøesnìji
øeèeno ètyøi takzvané <i>referenèní typy</i>. Reference v¾dy ukazují na nemìnná
data, proto¾e filozofie jazyka Clojure je zalo¾ena nikoli na jednoduché zmìnì
obsahu promìnných (èi zmìnì stavu objektù &ndash; tj.&nbsp;jejich atributù,
pokud budeme uva¾ovat i o objektovì orientovaných jazycích), ale na takzvaných
<i>identitách</i> asociovaných s&nbsp;rùznými <i>stavy</i>, které se
v&nbsp;rùzných èasových okam¾icích bì¾ícího programu mohou li¹it. Samotný stav
je pøedstavován nemìnnou (immutable) hodnotou, co¾ v¹ak neznamená, ¾e by
reference po celou dobu bìhu programu musela odkazovat na stejný stav.
Reference toti¾ mù¾e být pøesmìrována na jinou nemìnnou hodnotu &ndash;
zkrácenì budeme øíkat, ¾e se zmìnila hodnota reference, i kdy¾ je to ponìkud
nepøesné. Zmínìné ètyøi typy referencí pou¾itých v&nbsp;programovacím jazyku
Clojure se od sebe odli¹ují pøedev¹ím v&nbsp;tom, zda je zmìna hodnot referencí
synchronní èi asynchronní a zda je realizována koordinovanì
(tj.&nbsp;v&nbsp;transakci) èi nezávisle na zmìnì hodnot ostatních
referencí.</p>

<p>V¹echny ètyøi podporované referenèní typy jsou vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th>Jméno</th><th>Var</th><th>Ref</th><th>Atom</th><th>Agent</th></tr>
<tr><td>Zmìna stavu</td><td>synchronní</td><td>synchronní</td><td>synchronní</td><td>asynchronní</td></tr>
<tr><td>Typ zmìny</td><td>lokální, v rámci jednoho vlákna</td><td>koordinovaná</td><td>nezávislá</td><td>nezávislá</td></tr>
<tr><td>Podpora transakcí</td><td>ne</td><td>ano</td><td>ne</td><td>ne</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zpùsoby vytvoøení v¹ech ètyø typù referencí</h2>

<p>Kromì prvního typu reference (<i>var</i>) je nutné u dal¹ích tøech typù
referencí pro pøeètení stavu identity, s&nbsp;ní¾ je tato reference svázána,
pou¾ít funkci <strong>deref</strong>, popø.&nbsp;namísto této funkce vyu¾ít
makro preprocesoru zapisované pomocí zavináèe <strong>@</strong>. Nutnost
pou¾ití funkce <strong>deref</strong> namísto pøímého ètení hodnoty vychází
z&nbsp;toho, ¾e se napøíklad v&nbsp;pøípadì agentù musí provést synchronizace
vláken, popø.&nbsp;je nutné zajistit atomiènost ètení/zmìny hodnoty atd. Ka¾dý
typ reference se vytváøí pomocí jiné funkce, z&nbsp;nich¾ ka¾dá je popsána ve
zvlá¹tní podkapitole:</p>



<p><a name="k031"></a></p>
<h3>3.1 Vytvoøení reference typu &bdquo;var&ldquo;</h3>

<p>Pøi vytváøení reference typu <i>var</i> se specifikuje jak jméno reference,
tak i (i kdy¾ nepovinnì) její poèáteèní hodnota. Pro tento úèel se pou¾ívá nám
ji¾ známá speciální forma <strong>def</strong>:</p>

<pre>
(def jméno poèáteèní_hodnota)
</pre>



<p><a name="k032"></a></p>
<h3>3.2 Vytvoøení reference typu &bdquo;ref&ldquo;</h3>

<p>Pro vytvoøení reference typu <i>ref</i> se pou¾ívá funkce
<strong>ref</strong>. Pov¹imnìte si v¹ak, ¾e se nikde nepøedává jméno vytvoøené
reference &ndash; pøiøazení ke jménu je toti¾ ji¾ zále¾itostí programátora:</p>

<pre>
(ref poèáteèní_hodnota)
</pre>

<p>Pøíklad vytvoøení reference s&nbsp;navázáním na symbol (jméno):</p>

<pre>
(def account-1 (ref 10000))
</pre>



<p><a name="k033"></a></p>
<h3>3.3 Vytvoøení reference typu &bdquo;atom&ldquo;</h3>

<p>Vytvoøení reference typu <i>atom</i> je v&nbsp;mnoha ohledech podobné
vytvoøení pøede¹lého typu reference:</p>

<pre>
(atom poèáteèní_hodnota)
</pre>

<p>Pokud je zapotøebí navázat referenci na symbol (co¾ zapotøebí skuteènì
bývá), pou¾ívá se tento idiom:</p>

<pre>
(def answer (atom 42))
</pre>



<p><a name="k034"></a></p>
<h3>3.4 Vytvoøení reference typu &bdquo;agent&ldquo;</h3>

<p>Posledním podporovaným typem referencí jsou takzvaní agenti, jen¾ se vytváøí
s&nbsp;vyu¾itím funkce <strong>agent</strong>:</p>

<pre>
(agent poèáteèní_hodnota)
</pre>

<p>I v&nbsp;pøípadì agentù je nìkdy ¾ádoucí je navázat na symbol:</p>

<pre>
(def agent007 (agent 7))
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Referenèní typ &bdquo;Var&ldquo;</h2>

<p>Vývojáøùm, kteøí kromì Clojure znají i jiný (imperativní èi funkcionální)
programovací jazyk, bude první typ referencí &ndash; <i>var(s)</i> &ndash;
pøipadat povìdomý, proto¾e práce s&nbsp;tímto referenèním typem se nejvíce
pøibli¾uje zpùsobu práce s&nbsp;bì¾nými promìnnými (i kdy¾ je obecnì
bezpeènìj¹í pou¾ívat spí¹e <i>atomy</i> popsané <a href="#k06">v&nbsp;dal¹ím
textu</a>). Jak jsme si ji¾ øekli <a href="#k02">v&nbsp;pøedchozí kapitole</a>,
vytváøí se nová reference typu <i>var</i> s&nbsp;vyu¾itím speciální formy
<strong>def</strong>, které se pøedá jak jméno reference, tak i její poèáteèní
hodnota: <strong>(def jméno hodnota)</strong>. Alternativnì je mo¾né referenci
pouze vytvoøit a nepøiøadit jí ¾ádnou poèáteèní hodnotu: <strong>(def
jméno)</strong>. Programovací jazyk Clojure samozøejmì pøi ka¾dém pokusu o
pøístup k&nbsp;hodnotì pøiøazené k&nbsp;referenci kontroluje, zda tato hodnota
existuje èi nikoli a v&nbsp;pøípadì pokusu o pøeètení neinicializované
reference dojde k&nbsp;chybì. Podívejme se na jednoduchý demonstraèní pøíklad,
v&nbsp;nìm¾ budou vytvoøeny dvì reference typu <i>var</i>:</p>

<pre>
; vytvoøení první reference, která v¹ak
; není navázána na ¾ádnou hodnotu
user=&gt; (def foo)
#'user/foo
&nbsp;
; vytvoøení druhé reference, která je
; navázána na (nemìnitelnou) hodnotu 42
user=&gt; (def bar 42)
#'user/bar
&nbsp;
; pokus o pøístup k hodnotì navázané
; na první referenci
user=&gt; foo
#&lt;Unbound Unbound: #'user/foo&gt;
&nbsp;
; pokus o pøístup k hodnotì navázané
; na druhou referenci
user=&gt; bar
42
</pre>

<p>Reference vytvoøené s&nbsp;vyu¾itím speciální formy <strong>def</strong>
(bez pou¾ití dal¹ích metadat) mù¾eme pova¾ovat za statické globální promìnné a
právì takovým zpùsobem jsme s&nbsp;nimi vlastnì u¾ pracovali:</p>

<pre>
user=&gt; (def x 2)
#'user/x
&nbsp;
user=&gt; (def y 3)
#'user/y
&nbsp;
user=&gt; (+ x y)
5
&nbsp;
user=&gt; (* (+ x y) (- x y))
-5
</pre>

<p>Reference typu <i>var</i> lze pomocí dal¹ího volání <strong>def</strong>
zmìnit tak, aby ukazovaly na jinou nemìnitelnou hodnotu:</p>

<pre>
user=&gt; (def foo 10)
#'user/foo
&nbsp;
user=&gt; foo
10
&nbsp;
user=&gt; (def foo [1 2 3 4])
#'user/foo
&nbsp;
user=&gt; foo
[1 2 3 4]
</pre>

<p>Zatímco reference vytvoøené s&nbsp;vyu¾itím speciální formy
<strong>def</strong> jsou globální a tudí¾ i sdílené mezi vlákny, je mo¾né
vytvoøit i lokální &bdquo;promìnnou&ldquo;, a to s&nbsp;vyu¾itím speciální
formy nazvané <strong>let</strong>. V&nbsp;této formì je mo¾né deklarovat
obdobu &bdquo;lokálních promìnných&ldquo; obsahujících opìt nemìnitelné hodnoty
a navíc takté¾ sekvenci výrazù, v&nbsp;nich¾ se mohou tyto &bdquo;lokální
promìnné&ldquo; pou¾ít:</p> 

<pre>
; uvnitø speciální formy let lze vyu¾ít
; lokální reference pojmenované local-y a local-y
user=&gt; (let [local-x 6 local-y 7] (* local-x local-y))
42
&nbsp;
; pokus o pøístup k obìma referencím
; mimo "let" skonèí neúspìchem:
user=&gt; local-x
CompilerException java.lang.RuntimeException: Unable to resolve symbol: local-x in this context, compiling:(NO_SOURCE_PATH:0) 
</pre>

<p>Speciální forma <strong>let</strong> se vyu¾ívá pro zjednodu¹ení zápisu
funkcí, kdy je mo¾né výsledek nìjakého mezivýpoètu svázat s&nbsp;lokálnì
viditelnou referencí a tím ho vlastnì pojmenovat:</p>

<pre>
; výpoèet prùmìru v¹ech hodnot
; ulo¾ených ve vektoru
; (neoptimalizovaná verze výpoètu)
(defn average [vektor]
      (let [
            vector-size (count vektor)
            suma (reduce + vektor)
           ]
           (/ suma vector-size)))
&nbsp;
user=&gt; (average [1 2 3 4])
5/2
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Referenèní typ &bdquo;Ref&ldquo;</h2>

<p>S&nbsp;referenèním typem <i>ref</i> jsme se ji¾ setkali <a
href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">v&nbsp;pøedcházející
èásti tohoto seriálu</a>. S&nbsp;vyu¾itím tohoto referenèního typu je mo¾né
vytvoøit a pou¾ívat identity, jejich¾ stav se mìní <i>synchronnì</i>
(tj.&nbsp;ihned a pøímo ve vláknu, v&nbsp;nìm¾ je funkce pro zmìnu stavu
identit zavolána) a souèasnì i <i>koordinovanì</i>. Aby byly obì tyto
vlastnosti skuteènì zaruèeny, musí se funkce mìnící stav identit, na ni¾
odkazuje reference typu <i>ref</i>, volat uvnitø transakce, tj.&nbsp;uvnitø
makra <strong>dosync</strong> &ndash; to je ostatnì kontrolováno pøi bìhu
programu. Pøi ètení stavu identity, na ní¾ je reference vázána, se pou¾ívá
funkce <strong>deref</strong>, popøípadì makro preprocesoru @. Zmìna stavu
&ndash; volaná v&nbsp;transakci &ndash; se provádí s&nbsp;vyu¾itím funkcí
<strong>ref-set</strong> a <strong>alter</strong>. Demonstraèní pøíklad,
v&nbsp;nìm¾ jsou pou¾ity tøi reference typu <i>ref</i>, jsme si ukazovali
minule, ale pro úplnost si ho mù¾eme zopakovat:</p>

<pre>
; vytvoøení tøí globálních symbolù
; navázaných na trojici referencí typu ref
(def account-1 (ref 10000))
(def account-2 (ref 20000))
(def account-3 (ref 0))
&nbsp;
&nbsp;
; pomocná funkce, která vytiskne aktuální
; stav identit, na nì¾ jsou navázány tøi
; reference
(defn print-accounts []
    (println "Account 1 : " @account-1)
    (println "Account 2 : " @account-2)
    (println "Account 3 : " @account-3))
&nbsp;
&nbsp;
; funkce, v ní¾ se *v transakci*
; mìní stav identit
(defn transfer-money [from to amount]
    (dosync
        (alter from - amount)
        (alter to + amount)))
&nbsp;
&nbsp;
; výpis hodnot pøed provedením transakce
(println "Before transactions: ")
(print-accounts)
&nbsp;
Before transactions:
Account 1 :  10000
Account 2 :  20000
Account 3 :  0
nil
&nbsp;
&nbsp;
; provedení dvojice transakcí, z nich¾
; ka¾dá splòuje ACID
(transfer-money account-1 account-2 1000)
(transfer-money account-2 account-3 10000)
&nbsp;
&nbsp;
; výpis hodnot po provedení transakce
(println "After transactions: ")
(print-accounts)
&nbsp;
After transactions:
Account 1 :  9000
Account 2 :  11000
Account 3 :  10000
nil
&nbsp;
&nbsp;
; zmìna stavu identity mimo transakci
; není mo¾ná
user=&gt; (ref-set account-1 0)
IllegalStateException No transaction running  clojure.lang.LockingTransaction.getEx (LockingTransaction.java:208)
&nbsp;
&nbsp;
; je proto nutné ve¹kerou zmìnu stavu
; provádìt v makru dosync
user=&gt; (dosync (ref-set account-1 0))
0
</pre>

<p>Programátor si v¹ak musí dát pozor na to, aby uvnitø transakce nevolal
funkce s&nbsp;vedlej¹ím efektem, proto¾e v&nbsp;pøípadì kolize mù¾e být
transakce vykonána i nìkolikrát. V&nbsp;následujícím pøíkladu je volána funkce
s&nbsp;vedlej¹ím efektem, co¾ znamená, ¾e by se mohl øetìzec informující o
provádìném souètu vypsat vícekrát, co¾ asi není fatální, ale v&nbsp;pøípadì
zápisu do souboru atd. by to ji¾ mohlo vadit:</p>

<pre>
(defn myplus
    [x y]
    (println "scitam" x "a" y)
    (+ x y))
&nbsp;
(dosync
    (alter account-1 myplus 10))
&nbsp;
scitam 10 a 10
20
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Referenèní typ &bdquo;Atom&ldquo;</h2>

<p>Zatímco s&nbsp;referenèními typy <i>var</i> a <i>ref</i> jsme se ji¾ setkali
v&nbsp;pøedchozích èástech tohoto seriálu, referenèní typ pojmenovaný
<i>atom</i> je pro nás (prozatím) novým pojmem. Zmìna stavu identit
referencovaných pøes <i>atom</i> se provádí synchronnì, tj.&nbsp;podobnì, jako
tomu bylo u referenèního typu <i>ref</i>. Ov¹em zatímco se u referenèního typu
<i>ref</i> ve¹keré zmìny stavu identit provádìly v&nbsp;transakci (kde se mohlo
nacházet libovolné mno¾ství výrazù &ndash; typicky výrazy pracující s&nbsp;více
identitami), je u atomù zmìna jejich hodnoty provedena <i>atomicky</i> a
<i>nezávisle</i> &ndash; ostatní vlákna tedy ihned budou pracovat s&nbsp;novou
hodnotou. Práce s&nbsp;atomy je sice obecnì efektivnìj¹í, ne¾
s&nbsp;<i>ref</i>, proto¾e podpora transakcí není úplnì zadarmo, ov¹em pokud
bychom se sna¾ili demonstraèní pøíklad uvedený v&nbsp;pøedchozí kapitole
implementovat s&nbsp;vyu¾itím atomù, nebyla by zaruèena konzistence dat pøi
odeètení èástky z&nbsp;prvního úètu a <strong>pøed</strong> pøiètením této
èástky k&nbsp;úètu druhému.</p>

<p>Práce s&nbsp;atomy je v&nbsp;praxi velmi jednoduchá, proto¾e si programátor
vystaèí se ètveøicí funkcí, k&nbsp;nim¾ mù¾eme pøipoèíst je¹tì jedno makro
preprocesoru. V¹echny ètyøi zmínìné funkce mù¾eme nalézt v&nbsp;následující
tabulce:</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Význam</th></tr>
<tr><td>1</td><td>atom</td><td>vytvoøení reference typu atom</td></tr>
<tr><td>2</td><td>deref</td><td>dereference, vrátí se stav identity</td></tr>
<tr><td>3</td><td>reset!</td><td>atomická zmìna stavu identity na zvolenou hodnotu</td></tr>
<tr><td>4</td><td>swap!</td><td>atomická zmìna stavu identity zavoláním zvolené funkce</td></tr>
</table>

<pre>
; vytvoøení nového atomu
user=&gt; (def x (atom 42))
#'user/x
&nbsp;
; globální symbol x je navázán
; na atom a nikoli na stav identity
; (=hodnotu)
user=&gt; x
#&lt;Atom@61a907: 42&gt;
&nbsp;
; pro získání aktuálního stavu
; je nutné pou¾ít dereferenci
user=&gt; (deref x)
42
&nbsp;
; namísto (deref x) se pou¾ívá
; makro preprocesoru @
user=&gt; @x
42
&nbsp;
&nbsp;
; atomická zmìna stavu identity
user=&gt; (reset! x 10)
10
&nbsp;
user=&gt; (reset! x (+ 1 2 3))
6
&nbsp;
user=&gt; @x
7
&nbsp;
&nbsp;
; dal¹í mo¾nost atomické zmìny
; stavu identity - nyní pøes funkci
; aplikovanou na atom a popø. i dal¹í
; parametry
user=&gt; (swap! x + 1)
7
&nbsp;
user=&gt; @x
7
</pre>

<p>K&nbsp;tìmto ètyøem funkcím mù¾eme pøidat je¹tì nízkoúrovòovou funkci
pojmenovanou pøíznaènì <strong>compare-and-set!</strong> (odvozeno od atomické
operace <i>test-and-set</i>), která nastaví nový stav identity pouze za
pøedpokladu, ¾e se její stará hodnota rovná hodnotì pøedané do
<strong>compare-and-set!</strong>. Na rozdíl od funkcí <strong>reset!</strong>
a <strong>swap!</strong>, její¾ návratová hodnota odpovídá novému stavu
identity, je návratová hodnota funkce <strong>compare-and-set!</strong> rovna
true èi false podle toho, jak porovnání (a tím pádem i nastavení) dopadlo:</p>

<pre>
user=&gt; (compare-and-set! x 42 0)
false
&nbsp;
user=&gt; @x
7
&nbsp;
user=&gt; (compare-and-set! x 7 0)
true
&nbsp;
user=&gt; @x
0
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Referenèní typ &bdquo;Agent&ldquo;</h2>

<p>Ètvrtý referenèní typ, který nese název <i>agent</i>, je z&nbsp;hlediska
programátora pravdìpodobnì nejzajímavìj¹í a v&nbsp;mnoha ohledech, pøedev¹ím
s&nbsp;ohledem na tvorbu vícevláknových aplikací, i neju¾iteènìj¹í.
S&nbsp;vyu¾itím agentù je toti¾ mo¾né volat asynchronnì provádìné funkce, které
pøi svém vyhodnocení bì¾í v&nbsp;samostatných vláknech získaných z&nbsp;poolu
(vlákna tedy nemusí být neustále znovu vytváøena). Ji¾ na první pohled se tedy
agenti podobají objektùm typu <i>future</i>, s&nbsp;nimi¾ jsme se ji¾
v&nbsp;tomto seriálu setkali, ov¹em nesmíme zapomínat na to, ¾e objekty
<i>future</i> slou¾ily k&nbsp;asynchronnímu spu¹tìní prakticky libovolných
výpoètù, zatímco agenti jsou skuteèným referenèním typem navázaným na nìjakou
identitu a její stav. Agenti toti¾ nejen¾e asynchronnì vykonají nìjaký výpoèet,
ale souèasnì i zmìní stav &bdquo;své&ldquo; identity na základì výsledku tohoto
výpoètu. To by zajisté bylo mo¾né zaøídit i s&nbsp;vyu¾itím
<i>future/promise</i>, ale proè to dìlat zbyteènì komplikovanì, kdy¾ je pou¾ití
agentù velmi elegantní a souèasnì se jedná o techniku, která se zaèíná tì¹it
urèité oblibì i mimo programovací jazyk Clojure?</p>

<p>V&nbsp;následující tabulce je vypsána ètveøice základních funkcí pou¾ívaných
pro práci s&nbsp;agenty:</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Význam</th></tr>
<tr><td>1</td><td>agent</td><td>vytvoøení reference typu agent</td></tr>
<tr><td>2</td><td>deref</td><td>dereference, vrátí se stav identity</td></tr>
<tr><td>3</td><td>send</td><td>poslání akce agentovi (libovolné funkce)</td></tr>
<tr><td>3</td><td>send-off</td><td>poslání akce agentovi (libovolné funkce)</td></tr>
</table>

<p>Rozdíl mezi funkcemi <strong>send</strong> a <strong>send-off</strong>
spoèívá v&nbsp;tom, ¾e první z&nbsp;tìchto funkcí by se mìla pou¾ívat pro
spu¹tìní nároènìj¹ích výpoètù, zatímco funkce druhá spí¹e pro operace, které
budou blokující a nebo budou pracovat s&nbsp;I/O systémem. Pokud se vybere
&bdquo;¹patná&ldquo; funkce, bude se program chovat stále korektnì, ov¹em
vyu¾ití vláken plánovaèem nemusí být optimální.</p>

<p>Jednoduchý demonstraèní pøíklad na pou¾ití agentù:</p>

<pre>
; vytvoøení agenta
user=&gt; (def my-agent (agent 0))
#'user/my-agent
&nbsp;
; poslání funkce agentovi (6 je druhý parametr funkce)
user=&gt; (send my-agent + 6)
#&lt;Agent@18622f3: 0&gt;
&nbsp;
; poslání funkce agentovi (7 je druhý parametr funkce)
user=&gt; (send my-agent * 7)
#&lt;Agent@18622f3: 6&gt;
&nbsp;
; dereference - získání nového stavu
user=&gt; @my-agent
42
</pre>

<p>Vidíme, ¾e návratová hodnota funkcí + èi * se stala novým stavem pøiøazeným
k&nbsp;identitì, na ní¾ je agent navázán.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Èekání na dokonèení akce poslané agentovi</h2>

<p>Demonstraèní pøíklad ukázaný v&nbsp;závìru pøedchozí kapitoly zdánlivì
pracoval bez chyby, proto¾e jsme pomocí <strong>@my-agent</strong> získali v¾dy
novou hodnotu pøiøazenou agentovi. Ve skuteènosti v¹ak ji¾ víme, ¾e akce
poslané agentovi (tj.&nbsp;pøedané funkce) se provádí v&nbsp;samostatných
vláknech a nemusí být tedy pøi dereferencování je¹tì dokonèeny. V&nbsp;tomto
pøípadì se pøi dereferenci jednodu¹e vrátí starý stav agenta. Mù¾eme si to
ukázat na jednoduchém pøíkladu, v&nbsp;nìm¾ se agentovi po¹le akce &ndash;
funkce, která zmìní jeho hodnotu za pøibli¾nì deset sekund, tj.&nbsp;za dobu,
která èlovìku staèí k&nbsp;tomu, aby ve smyèce <i>REPL</i> nìkolikrát spustil
dereferencování stavu agenta:</p>

<pre>
; definice funkce pro "pomalé" sèítání
user=&gt; (defn slow-inc
    [x]
    (Thread/sleep 10000)
    (inc x))
#'user/slow-inc
&nbsp;
; vytvoøení nového agenta
user=&gt; (def x (agent 0))
#'user/x
&nbsp;
; zaslání akce agentovi
user=&gt; (send x slow-inc)
#&lt;Agent@32060c: 0&gt;
&nbsp;
; dereferencování
user=&gt; @x
0
&nbsp;
user=&gt; @x
0
&nbsp;
user=&gt; @x
0
&nbsp;
user=&gt; @x
0
&nbsp;
user=&gt; @x
0
&nbsp;
; teprve po pøibli¾nì deseti sekundách se koneènì
; zmìnil stav identity
user=&gt; @x
1
</pre>

<p>Pro aktivní èekání na dokonèení akce poslané jednomu agentovi èi více
agentùm se pou¾ívá dvojice funkcí:</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Význam</th></tr>
<tr><td>1</td><td>await          </td><td>èekání na dokonèení akce poslané jednomu èi více agentùm</td></tr>
<tr><td>2</td><td>await-for      </td><td>dtto, ale lze specifikovat i timeout</td></tr>
</table>

<p>První funkce nazvaná <strong>await</strong> umo¾òuje èekat na dokonèení akce
více agenty, ov¹em toto èekání není shora nijak omezeno. V&nbsp;nìkterých
pøípadech je tudí¾ u¾iteènìj¹í pou¾ít druhou funkci <strong>await-for</strong>,
které se navíc pøedá i hodnota timeoutu zadaná v&nbsp;milisekundách. To, zda
do¹lo k&nbsp;timeoutu, je mo¾né zjistit z&nbsp;návratové hodnoty funkce
<strong>await-for</strong> (true/false).</p>

<p>Pøíklad pou¾ití funkce <strong>await</strong>:</p>

<pre>
; definice funkce pro "pomalé" sèítání
user=&gt; (defn slow-inc
    [x]
    (Thread/sleep 10000)
    (inc x))
#'user/slow-inc
&nbsp;
; vytvoøení prvního agenta
user=&gt; (def agent1 (agent 0))
#'user/agent1
&nbsp;
; vytvoøení druhého agenta
user=&gt; (def agent2 (agent 0))
#'user/agent2
</pre>

<pre>
; poslání dlouhotrvající akce prvnímu agentu
user=&gt; (send agent1 slow-inc)
#&lt;Agent@1efb4be: 0&gt;
&nbsp;
; poslání dlouhotrvající akce druhému agentu
user=&gt; (send agent2 slow-inc)
#&lt;Agent@5976c2: 0&gt;
&nbsp;
; ihned pøeèteme hodnotu obou agentù
user=&gt; @agent1
0
user=&gt; @agent2
0
</pre>

<pre>
; blokující èekání na dokonèení akcí
(await agent1 agent2)
nil
&nbsp;
; ihned poté pøeèteme hodnotu obou agentù
user=&gt; @agent1
1
user=&gt; @agent2
1
</pre>

<p>Pøíklad na pou¾ití funkce <strong>await-for</strong></p>

<pre>
; definice funkce pro "pomalé" sèítání
user=&gt; (defn slow-inc
    [x]
    (Thread/sleep 10000)
    (inc x))
#'user/slow-inc
&nbsp;
; vytvoøení prvního agenta
user=&gt; (def agent1 (agent 0))
#'user/agent1
&nbsp;
; vytvoøení druhého agenta
user=&gt; (def agent2 (agent 0))
#'user/agent2
</pre>

<pre>
; poslání dlouhotrvající akce prvnímu agentu
user=&gt; (send agent1 slow-inc)
#&lt;Agent@1efb4be: 0&gt;
&nbsp;
; poslání dlouhotrvající akce druhému agentu
user=&gt; (send agent2 slow-inc)
#&lt;Agent@5976c2: 0&gt;
</pre>

<pre>
; èekáme na dokonèení akce - ale pouze sekundu!
user=&gt; (await-for 1000 agent1 agent2)
false
&nbsp;
; stav agentù se za jednu sekundu je¹tì nezmìnil
user=&gt; @agent1
0
&nbsp;
user=&gt; @agent2
0
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Clojure.org: Clojure home page<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>A Couple of Clojure Agent Examples<br />
<a href="http://lethain.com/a-couple-of-clojure-agent-examples/">http://lethain.com/a-couple-of-clojure-agent-examples/</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/">http://java.sun.com/developer/technicalArticles/DynTypeLang/</a>
</li>

<li>JSR 223: Scripting for the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=223">http://jcp.org/en/jsr/detail?id=223</a>
</li>

<li>JSR 292: Supporting Dynamically Typed Languages on the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=292">http://jcp.org/en/jsr/detail?id=292</a>
</li>

<li>Java 7: A complete invokedynamic example<br />
<a href="http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html">http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html</a>
</li>

<li>InvokeDynamic: Actually Useful?<br />
<a href="http://blog.headius.com/2007/01/invokedynamic-actually-useful.html">http://blog.headius.com/2007/01/invokedynamic-actually-useful.html</a>
</li>

<li>A First Taste of InvokeDynamic<br />
<a href="http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html">http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html</a>
</li>

<li>Java 6 try/finally compilation without jsr/ret<br />
<a href="http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html">http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Root.cz: Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM<br />
<a href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/</a></a>
</li>

<li>Root.cz: JamVM aneb alternativa k HotSpotu nejenom pro embedded zaøízení a chytré telefony<br />
<a href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>FindBugs<br />
<a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a>
</li>

<li>GNU Classpath<br />
<a href="www.gnu.org/s/classpath/">www.gnu.org/s/classpath/</a></li>

<li>Java VMs Compared<br />
<a href="http://bugblogger.com/java-vms-compared-160/">http://bugblogger.com/java-vms-compared-160/</a>
</li>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Scala Programming Language<br />
<a href="http://www.scala-lang.org/">http://www.scala-lang.org/</a>
</li>

<li>Run Scala in Apache Tomcat in 10 minutes<br />
<a href="http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes">http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes</a>
</li>

<li>Fast Web Development With Scala<br />
<a href="http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html">http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html</a>
</li>

<li>Top five scripting languages on the JVM<br />
<a href="http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855">http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>CloseableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html">http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

