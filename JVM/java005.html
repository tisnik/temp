<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Novinky v&nbsp;JDK 7 (5) &ndash; projekt Lambda a anonymní funkce v&nbsp;pøíkladech</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Novinky v&nbsp;JDK 7 (5) &ndash; projekt Lambda a anonymní funkce v&nbsp;pøíkladech</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;páté èásti seriálu o nových vlastnostech programovacího jazyka Java i jeho virtuálního stroje budeme pokraèovat v&nbsp;popisu pou¾ití anonymních funkcí, které jsou implementovány v&nbsp;rámci projektu Lambda. Mezi typické mo¾nosti vyu¾ití anonymních funkcí patøí implementace komparátorù, filtrù, funkcí reagujících na události vznikající v&nbsp;grafických u¾ivatelských rozhraních aplikací psaných v&nbsp;Javì atd.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Projekt Lambda a anonymní funkce v&nbsp;pøíkladech</a></p>
<p><a href="#k02">2. Rychlé vytvoøení a spu¹tìní vlákna</a></p>
<p><a href="#k03">3. Obejití nutnosti reagovat na kontrolované výjimky</a></p>
<p><a href="#k04">4. Implementace komparátorù kompatibilních s&nbsp;JDK 1.2 a¾ JDK 1.4</a></p>
<p><a href="#k05">5. Implementace komparátorù vyu¾ívající nových mo¾ností JDK 5 a JDK 6</a></p>
<p><a href="#k06">6. Vyu¾ití anonymních funkcí pro implementaci komparátorù</a></p>
<p><a href="#k07">7. Rozdíl v&nbsp;bajtkódu generovaného pøi pøekladu prvního a druhého demonstraèního pøíkladu</a></p>
<p><a href="#k08">8. Anonymní funkce v&nbsp;roli filtrù</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2>1. Projekt Lambda a anonymní funkce v&nbsp;pøíkladech</h2>

<p>V&nbsp;<a
href="http://www.root.cz/clanky/novinky-v-nbsp-jdk-7-aneb-mirny-pokrok-v-nbsp-mezich-zakona-ndash-projekt-lambda/">pøedchozí
èásti</a> seriálu o novinkách pøipravovaných pro <i>JDK 7</i> i o vlastnostech,
které nakonec nebyly do této verze JDK zahrnuty, jsme si øekli základní
informace o projektu <i>Lambda</i>, jeho¾ cílem je zavedení podpory anonymních
funkcí (èi metod) do Javy. Poslední podoba syntaxe a sémantiky anonymních
funkcí, která je v&nbsp;projektu <i>Lambda</i> implementována, je zalo¾ena na
anonymních tøídách (které lze pou¾ívat ji¾ od dob JDK 1.1) s&nbsp;jedinou
implementovanou metodou. Tøídy s&nbsp;tìmito vlastnostmi se nazývají <i>Single
Abstract Method</i> neboli zkrácenì <i>SAM</i>. <i>SAM</i> se pøi programování
v&nbsp;Javì pou¾ívají pomìrnì èasto, a» ji¾ pøi implementaci komparátorù
(anonymních tøíd, jejich¾ jediná metoda je zavolána pøi øazení prvkù
v&nbsp;poli èi kolekci), rùzných filtrù, kódu reagujícího na událost, která
vznikne jako reakce na operace provádìné u¾ivatelem v&nbsp;grafickém
u¾ivatelském rozhraní atd.</p>

<p>Následuje typický pøíklad pou¾ití <i>SAM</i> v&nbsp;takzvaném event
handleru, který doká¾e zachytit pozici kurzoru my¹i ve chvíli, kdy u¾ivatel
stiskne nìkteré její tlaèítko, a následnì ji ulo¾it do finálních atributù
objektu, v&nbsp;nìm¾ je instance tøídy <strong>MouseAdapter</strong>
pou¾ita:</p>

<pre>
p.addMouseListener(new MouseAdapter()
{
    public void mouseClicked(MouseEvent e)
    {
        x = e.getX();
        y = e.getY();
    }
});
</pre>

<p>V&nbsp;rámci projektu <i>Lambda</i> byla pro vytváøení <i>SAM</i> zavedena
ponìkud jednodu¹¹í (a pøedev¹ím krat¹í) syntaxe, která spoèívá v&nbsp;tom, ¾e
se mezi dvojici znakù <strong>#{</strong> a <strong>}</strong> zapí¹ou jak
parametry implementované metody (samozøejmì vèetnì jejich typù), tak i vlastní
tìlo metody. Pokud lze celou metodu zapsat pouze jediným pøíkazem typu
<strong>return výraz</strong>, je mo¾né celý zápis je¹tì více zkrátit a namísto
tìla <i>SAM</i> zapsat pouze výraz bez pøíkazu <strong>return</strong>. Ka¾dá
takto vytvoøená <i>SAM</i> musí implementovat buï nìjaké rozhraní s&nbsp;jednou
pøedepsanou metodou, nebo abstraktní tøídu, takté¾ s&nbsp;jednou metodou.
Následující pøíklad slou¾í pro pøipomenutí syntaxe zápisu <i>SAM</i>:</p>

<pre>
public class Lambda1
{
    interface SAM
    {
        int method(int param);
    }
&nbsp;
    interface SAM2
    {
        int method(int x, int y);
    }
&nbsp;
    public static void main(String[] args)
    {
        // namísto tìla funkce se pou¾ije pouze výraz
        SAM sam1a = #{ int x -&gt; x + 1 };
&nbsp;
        // zde je pou¾ito tìlo funkce s jediným pøíkazem return
        SAM sam1b = #{ int x -&gt; return x + 1 };
&nbsp;
        int x = sam1.method(10);
        System.out.println(x);
        System.out.println(sam1a.method(42));
        System.out.println(sam1b.method(42));
&nbsp;
        // dvojice parametrù, namísto tìla funkce se pou¾ije pouze výraz
        SAM2 sam2a = #{ int x, int y  -&gt; x * y };
&nbsp;
        // zde je pou¾ito tìlo funkce s jediným pøíkazem return
        SAM2 sam2b = #{ int x, int y  -&gt; return x * y };
&nbsp;
        System.out.println(sam2a.method(42, 3));
        System.out.println(sam2b.method(42, 3));
    }
}
</pre>



<p><a name="k02"></a></p>
<h2>2. Rychlé vytvoøení a spu¹tìní vlákna</h2>

<p>Novou syntaxi pro zjednodu¹enou tvorbu anonymních tøíd s&nbsp;jedinou
metodou (<i>SAM</i>) lze vyu¾ít mnoha rùznými zpùsoby. V&nbsp;nìkterých
aplikacích &ndash; a nemusí se jednat pouze o implementaci serveru, ale
napøíklad i o èasovì nároèný a pøitom dobøe paralelizovatelný výpoèet &ndash;
se napøíklad èasto vytváøí nová vlákna, která v¹ak mají provést pouze nìkolik
pøíkazù. V&nbsp;tomto pøípadì je mo¾né pou¾ít napøíklad zpùsob zápisu ukázaný
v&nbsp;následujícím demonstraèním pøíkladu. V&nbsp;tomto pøíkladu se nejdøíve
s&nbsp;vyu¾itím syntaxe projektu <i>Lambda</i> vytvoøí anonymní tøídy
implementující rozhraní <strong>Runnable</strong>. Jedná se tedy o objekty
mající pouze jedinou metodu <strong>run</strong>, která je následnì pomocí
pøíkazu <strong>new Thread(runnable).start()</strong> spu¹tìna v&nbsp;novém
vláknì. Pokud by se z&nbsp;tìla vlákna mìlo pøistupovat ke sdíleným objektùm
nebo jejich atributùm, je samozøejmì mo¾né &ndash; a vìt¹inou i nutné &ndash;
pou¾ít v¹echny mo¾nosti synchronizace, které Java programátorùm nabízí,
popø.&nbsp;lze v&nbsp;nìkterých pøípadech vyu¾ít modifikátor
<i>volatile</i>:</p>

<pre>
public class ThreadTest1
{
    public static void main(String[] args)
    {
        // Vytvoøení ètyø objektù implementujících rozhraní Runnable.
        // To znamená, ¾e ka¾dý vytvoøený objekt obsahuje pouze jedinou metodu run().
        Runnable r1 = #{ Thread.sleep(3000); System.out.println("Prvni vlakno"); };
        Runnable r2 = #{ Thread.sleep(2000); System.out.println("Druhe vlakno"); };
        Runnable r3 = #{ Thread.sleep(1000); System.out.println("Treti vlakno"); };
        Runnable r4 = #{ Thread.sleep(500);  System.out.println("Ctvrte vlakno"); };
&nbsp;
        System.out.println("-----------");
        new Thread(r1).start();
        System.out.println("-----------");
        new Thread(r2).start();
        System.out.println("-----------");
        new Thread(r3).start();
        System.out.println("-----------");
        new Thread(r4).start();
        System.out.println("-----------");
    }
}
</pre>

<p>Tento program po svém spu¹tìní nejdøíve ètyøikrát vypí¹e øadu pomlèek,
proto¾e tento kód bì¾í v&nbsp;hlavním vláknì bez pozastavení. Posléze se
postupnì (s&nbsp;èasovým zpo¾dìním) vypí¹ou øetìzce "Ctvrte vlakno", "Treti
vlakno" atd. Poøadí výpisu tìchto øetìzcù sice není zaruèeno, ov¹em
s&nbsp;velkou pravdìpodobností se nejdøíve vypí¹e text ze ètvrtého vlákna,
posléze ze tøetího, druhého a nakonec z&nbsp;vlákna prvního:</p>

<pre>
tisnik@bender:~/java/jdk7/langtools/dist/bin$ ./java ThreadTest1
-----------
-----------
-----------
-----------
-----------
Ctvrte vlakno
Treti vlakno
Druhe vlakno
Prvni vlakno
</pre>



<p><a name="k03"></a></p>
<h2>3. Obejití nutnosti reagovat na kontrolované výjimky</h2>

<p>Ve zdrojovém kódu demonstraèního pøíkladu uvedeného v&nbsp;pøedchozí
kapitole si pov¹imnìte je¹tì jedné zmìny oproti situaci, kdy by se <i>SAM</i>
vytváøela takovým zpùsobem, jak bylo v&nbsp;JDK 6 i v&nbsp;pøedchozích verzích
JDK zvykem, napøíklad takto <strong>new Runnable() {public void run()
{...}};</strong>. V&nbsp;tomto pøípadì by bylo nutné volání
<strong>Thread.sleep()</strong> umístit do bloku <strong>try-catch</strong>,
proto¾e pøi èekání vlákna na uplynutí zadaného èasového intervalu mù¾e být
signalizováno z&nbsp;vnìj¹ku (napøíklad zavoláním
<strong>Thread.interrupt()</strong>), ¾e má být vlákno ukonèeno, co¾ ve vláknì
vede ke vzniku výjimky typu <strong>InterruptedException</strong>.</p>

<p>Pokud se v¹ak pou¾ije zpùsob vytvoøení <i>SAM</i> podporovaný projektem
<i>Lambda</i>, není striktnì vy¾adováno tuto výjimku zachycovat, i kdy¾ to je
samozøejmì mo¾né a v&nbsp;mnoha pøípadech i nutné pro korektní práci programu!
Je tomu tak z&nbsp;toho dùvodu, ¾e autoøi projektu <i>Lambda</i> odstranili
povinnost zpracovávat kontrolované výjimky (<i>checked exceptions</i>),
tj.&nbsp;výjimky, jejich¾ zpracování je hlídáno pøekladaèem ji¾ v&nbsp;dobì
pøekladu zdrojových textù do bajtkódu. Existence kontrolovaných výjimek sice
bezesporu vede k&nbsp;tvorbì robustnìj¹ího kódu, ov¹em na druhou stranu
existují situace, kdy je zpracování nìkterých typù výjimek ryze formální
zále¾itostí:</p>

<pre>
public class Threads
{
    public static void main(String[] args)
    {
        Runnable r1 = new Runnable() {
            public void run() {
                try {
                    Thread.sleep(3000);
                }
                catch (InterruptedException e) {}
                System.out.println("Prvni vlakno");
            }
        };
        Runnable r2 = new Runnable() {
            public void run() {
                try {
                    Thread.sleep(2000);
                }
                catch (InterruptedException e) {}
                System.out.println("Druhe vlakno");
            }
        };
        Runnable r3 = new Runnable() {
            public void run() {
                try {
                    Thread.sleep(1000);
                }
                catch (InterruptedException e) {}
                System.out.println("Treti vlakno");
            }
        };
        Runnable r4 = new Runnable() {
            public void run() {
                try {
                    Thread.sleep(500);
                }
                catch (InterruptedException e) {}
                System.out.println("Ctvrte vlakno");
            }
        };
&nbsp;
        new Thread(r1).start();
        System.out.println("-----------");
        new Thread(r2).start();
        System.out.println("-----------");
        new Thread(r3).start();
        System.out.println("-----------");
        new Thread(r4).start();
        System.out.println("-----------");
    }
}
</pre>

<p>Poznámka: vyvolání výjimky typu <strong>InterruptedException</strong>
souèasnì vede k&nbsp;vymazání pøíznaku, ¾e vlákno bylo pøeru¹eno. To znamená,
¾e pokud se napøíklad nìjaký výpoèet provádí ve smyèce s&nbsp;testem na
ukonèení vlákna z&nbsp;vnìj¹ku, je <i>vhodné</i> na výjimku typu
<strong>InterruptedException</strong> korektnì reagovat, napøíklad nastavením
lokální pravdivostní promìnné, která je pou¾ita k&nbsp;rozhodnutí, zda a kdy má
být vlákno ukonèeno. Popø.&nbsp;lze pøímo v&nbsp;obsluze výjimky zavolat pøíkaz
<strong>Thread.currentThread().interrupt();</strong>, aby se obnovil pøíznak
nesoucí stav pøeru¹ení vlákna.</p>



<p><a name="k04"></a></p>
<h2>4. Implementace komparátorù kompatibilní s&nbsp;JDK 1.2 a¾ JDK 1.4</h2>

<p>Druhou oblastí, v&nbsp;ní¾ se mù¾eme setkat s&nbsp;pou¾itím <i>SAM</i>, je
vytváøení vlastních komparátorù, které mohou být pou¾ity napøíklad pøi øazení
prvkù ulo¾ených v&nbsp;polích nebo v&nbsp;kolekcích (typicky v&nbsp;seznamech).
Nejprve si uká¾eme, jak se komparátory vytváøely v&nbsp;<i>JDK 1.2</i>, kde
bylo rozhraní &ndash; pojmenované ponìkud ne¹»astnì <i>Comparator</i> &ndash;
poprvé zaøazeno do veøejného API. Dále uvedený zpùsob byl pou¾íván a¾ do <i>JDK
1.4</i>. Nejprve si vytvoøíme pomocnou tøídu s&nbsp;informacemi o
zamìstnancích. Jedná se o typickou tøídu pou¾ívanou v&nbsp;demonstraèních
pøíkladech (ov¹em na rozdíl od mnoha jiných implementací jsem zvolil tøídu
s&nbsp;finálními atributy), její¾ instance budeme ukládat do seznamu a posléze
tøídit podle rùzných kritérií:</p>

<pre>
class Employee
{
    private final String name;
    private final int age;
    private final int salary;
&nbsp;
    public Employee(String name, int age, int salary)
    {
        this.name = name;
        this.age = age;
        this.salary = salary;
    }
&nbsp;
    public String getName()
    {
        return this.name;
    }
&nbsp;
    public int getAge()
    {
        return this.age;
    }
&nbsp;
    public int getSalary()
    {
        return this.salary;
    }
&nbsp;
    @Override
    public String toString()
    {
        return String.format("%10s(%2d) ... $%d", this.getName(), this.getAge(), this.getSalary());
    }
}
</pre>

<p>Ka¾dý komparátor je v&nbsp;JDK 1.2 a¾ JDK 1.4 pøedstavován tøídou
implementující rozhraní <i>Comparator</i>. Tato tøída musí obsahovat metodu
<strong>int compare(Object, Object)</strong>, která vrací záporné èíslo
v&nbsp;pøípadì, ¾e je první objekt &bdquo;men¹í ne¾&ldquo; objekt druhý,
hodnotu nula, pokud jsou objekty &bdquo;stejné&ldquo; a kladné èíslo, pokud je
první objekt &bdquo;vìt¹í ne¾&ldquo; objekt druhý. Význam slov &bdquo;men¹í
ne¾&ldquo;, &bdquo;stejný&ldquo; a &bdquo;vìt¹í ne¾&ldquo; samozøejmì zále¾í na
tom, jakým zpùsobem vývojáø metodu <strong>compare</strong> nadefinuje (mù¾e
napøíklad porovnávat dvì komplexní èísla podle jejich absolutní hodnoty,
vektory podle vypoètené délky, rodná èísla pouze v&nbsp;závislosti na prvních
¹esti cifrách, tj.&nbsp;ignorováním ètyø posledních &bdquo;rozli¹ovacích&ldquo;
cifer atd.):</p>

<pre>
class EmployeeComparatorByName implements Comparator
{
    public final int compare(Object o1, Object o2)
    {
        String name1 = ((Employee)o1).getName();
        String name2 = ((Employee)o2).getName();
        return name1.compareTo(name2);
        // popr. napriklad porovnani podle DELKY jmena
        // return name1.length() - name2.length();
    }
}
&nbsp;
class EmployeeComparatorByAge implements Comparator
{
    public final int compare(Object o1, Object o2)
    {
        int age1 = ((Employee)o1).getAge();
        int age2 = ((Employee)o2).getAge();
        return age1 - age2;
    }
}
&nbsp;
class EmployeeComparatorBySalary implements Comparator
{
    public final int compare(Object o1, Object o2)
    {
        int salary1 = ((Employee)o1).getSalary();
        int salary2 = ((Employee)o2).getSalary();
        return salary1 - salary2;
    }
}
</pre>

<p>Poznámka: pokud by mìl být komparátor pou¾it i v&nbsp;jiném pøípadì, ne¾
pouze pøi volání metody <i>Collections.sort(List list, Comparator c)</i>
popø.&nbsp;<i>Arrays.sort(Object[] a, Comparator c)</i>, je ¾ádoucí pøetí¾it i
metodu <i>equals()</i>, a to takovým zpùsobem, aby tato metoda vracela hodnotu
<i>true</i> v&nbsp;pøípadì, ¾e metoda <i>compareTo()</i> vrací nulu.</p>

<p>Vý¹e deklarované komparátory si mù¾eme snadno vyzkou¹et:</p>

<pre>
public class SortTest1
{
&nbsp;
    private void printEmployees(List&lt;Employee&gt; employees)
    {
        for (Employee employee : employees)
        {
            System.out.println(employee.toString());
        }
    }
&nbsp;
    public void run()
    {
        List&lt;Employee&gt; employees = new ArrayList&lt;Employee&gt;();
        employees.add(new Employee("CEO",       50, 50000));
        employees.add(new Employee("Porter",    16, 10000));
        employees.add(new Employee("Tester",    35, 30000));
        employees.add(new Employee("Developer", 30, 40000));
&nbsp;
        System.out.println("Original order:");
        printEmployees(employees);
&nbsp;
        Collections.sort(employees, new EmployeeComparatorByName());
        System.out.println("\nSorted by name:");
        printEmployees(employees);
&nbsp;
        Collections.sort(employees, new EmployeeComparatorByAge());
        System.out.println("\nSorted by age:");
        printEmployees(employees);
&nbsp;
        Collections.sort(employees, new EmployeeComparatorBySalary());
        System.out.println("\nSorted by salary:");
        printEmployees(employees);
    }
&nbsp;
    public static void main(String[] args)
    {
        new SortTest1().run();
    }
}
</pre>

<p>S&nbsp;následujícím výsledkem:</p>

<pre>
~/$ java SortTest1
Original order:
       CEO(50) ... $50000
    Porter(16) ... $10000
    Tester(35) ... $30000
 Developer(30) ... $40000
&nbsp;
Sorted by name:
       CEO(50) ... $50000
 Developer(30) ... $40000
    Porter(16) ... $10000
    Tester(35) ... $30000
&nbsp;
Sorted by age:
    Porter(16) ... $10000
 Developer(30) ... $40000
    Tester(35) ... $30000
       CEO(50) ... $50000
&nbsp;
Sorted by salary:
    Porter(16) ... $10000
    Tester(35) ... $30000
 Developer(30) ... $40000
       CEO(50) ... $50000
</pre>



<p><a name="k05"></a></p>
<h2>5. Implementace komparátorù vyu¾ívající nových mo¾ností JDK 5 a JDK 6</h2>

<p>V&nbsp;<i>JDK 5</i> a <i>JDK 6</i> má vývojáø implementující komparátory
ponìkud snadnìj¹í situaci. Mù¾e toti¾ pou¾ít generiky a vytvoøit komparátor
specializovaný pouze na porovnání dvou objektù urèitého typu nebo samozøejmì
potomkù dané tøídy. Toto øe¹ení má jednu podstatnou výhodu v&nbsp;tom, ¾e není
nutné provádìt explicitní kontrolu typù (tu jsme stejnì v&nbsp;pøedchozím
pøíkladu neprovádìli), navíc se v&nbsp;metodì <i>compare()</i> nemusí provádìt
pøetypování z&nbsp;obecného objektu (<i>Object</i>) na konkrétní typ
objektu:</p>

<pre>
class EmployeeComparatorByName implements Comparator&lt;Employee&gt;
{
    public final int compare(Employee o1, Employee o2)
    {
        String name1 = o1.getName();
        String name2 = o2.getName();
        return name1.compareTo(name2);
    }
}
&nbsp;
class EmployeeComparatorByAge implements Comparator&lt;Employee&gt;
{
    public final int compare(Employee o1, Employee o2)
    {
        int age1 = o1.getAge();
        int age2 = o2.getAge();
        return age1 - age2;
    }
}
&nbsp;
class EmployeeComparatorBySalary implements Comparator&lt;Employee&gt;
{
    public final int compare(Employee o1, Employee o2)
    {
        return o1.getSalary() - o2.getSalary();
    }
}
&nbsp;
public class SortTest2
{
&nbsp;
    private void printEmployees(List&lt;Employee&gt; employees)
    {
        for (Employee employee : employees)
        {
            System.out.println(employee.toString());
        }
    }
&nbsp;
    public void run()
    {
        List&lt;Employee&gt; employees = new ArrayList&lt;Employee&gt;();
        employees.add(new Employee("CEO",       50, 50000));
        employees.add(new Employee("Porter",    16, 10000));
        employees.add(new Employee("Tester",    35, 30000));
        employees.add(new Employee("Developer", 30, 40000));
&nbsp;
        System.out.println("Original order:");
        printEmployees(employees);
&nbsp;
        Collections.sort(employees, new EmployeeComparatorByName());
        System.out.println("\nSorted by name:");
        printEmployees(employees);
&nbsp;
        Collections.sort(employees, new EmployeeComparatorByAge());
        System.out.println("\nSorted by age:");
        printEmployees(employees);
&nbsp;
        Collections.sort(employees, new EmployeeComparatorBySalary());
        System.out.println("\nSorted by salary:");
        printEmployees(employees);
    }
&nbsp;
    public static void main(String[] args)
    {
        new SortTest2().run();
    }
}
</pre>

<p>Je ov¹em zapotøebí si dát pozor na to, ¾e pøekladaè nekontroluje, zda se
metodì <i>Collections.sort(List list, Comparator c)</i> skuteènì pøedává seznam
správného typu. Pokud tomu tak není, vyvolá se a¾ za bìhu programu výjimka typu
<strong>ClassCastException</strong>. Po mírné úpravì pøedchozího programu se
sice zobrazí mnoho varování (volba <strong>-Xlint</strong>), ov¹em skuteèná
chyba nastane a¾ pøi bìhu aplikace. Zmìna nastala pouze v&nbsp;metodì
<i>run()</i>, tak¾e zde bude uveden pouze výpis této metody:</p>

<pre>
    public void run()
    {
        // netypovany seznam!!!
        List employees = new ArrayList();
        employees.add(new Employee("CEO",       50, 50000));
        employees.add(new Employee("Porter",    16, 10000));
        employees.add(new Employee("Tester",    35, 30000));
        employees.add(new Employee("Developer", 30, 40000));
&nbsp;
        // asi nastanou problemy :-)
        employees.add("toto neni dobry napad!");
&nbsp;
        System.out.println("Original order:");
        printEmployees(employees);
&nbsp;
        Collections.sort(employees, new EmployeeComparatorByName());
        System.out.println("\nSorted by name:");
        printEmployees(employees);
&nbsp;
        Collections.sort(employees, new EmployeeComparatorByAge());
        System.out.println("\nSorted by age:");
        printEmployees(employees);
&nbsp;
        Collections.sort(employees, new EmployeeComparatorBySalary());
        System.out.println("\nSorted by salary:");
        printEmployees(employees);
    }
</pre>

<p>Výsledek bìhu aplikace:</p>

<pre>
Original order:
       CEO(50) ... $50000
    Porter(16) ... $10000
    Tester(35) ... $30000
 Developer(30) ... $40000
Exception in thread "main" java.lang.ClassCastException: java.lang.String cannot be cast to Employee
	at SortTest2.printEmployees(SortTest2.java:71)
	at SortTest2.run(SortTest2.java:89)
	at SortTest2.main(SortTest2.java:106)
</pre>



<p><a name="k06"></a></p>
<h2>6. Vyu¾ití anonymních funkcí pro implementaci komparátorù</h2>

<p>Koneènì se dostáváme k&nbsp;tomu, jak je mo¾né komparátory vytvoøit pomocí
anonymních funkcí. První úprava vý¹e uvedeného demonstraèního pøíkladu spoèívá
v&nbsp;tom, ¾e se namísto nových tøíd
<strong>EmployeeComparatorByName</strong>,
<strong>EmployeeComparatorByAge</strong> a
<strong>EmployeeComparatorBySalary</strong> vytvoøí v&nbsp;metodì <i>run()</i>
lokální promìnné typu <i>anonymní funkce</i>, co¾ je typ toto¾ný
s&nbsp;<i>Comparator&lt;Employee&gt;</i>. Základní princip odvození typù byl
vysvìtlen v&nbsp;pøedchozí èásti tohoto seriálu. Zdrojový kód programu je
v&nbsp;tomto pøípadì struènìj¹í (a podle skromného názoru autora tohoto èlánku
i èitelnìj¹í, co¾ je ov¹em otázka zvyku):</p>

<pre>
    public void run()
    {
        Comparator&lt;Employee&gt; ageComparator = #{ Employee o1, Employee o2 -&gt;
            return o1.getAge() - o2.getAge();
        };
&nbsp;
        Comparator&lt;Employee&gt; nameComparator = #{ Employee o1, Employee o2 -&gt;
            String name1 = o1.getName();
            String name2 = o2.getName();
            return name1.compareTo(name2);
        };
&nbsp;
        Comparator&lt;Employee&gt; salaryComparator = #{ Employee o1, Employee o2 -&gt;
            return o1.getSalary() - o2.getSalary();
        };
&nbsp;
        List&lt;Employee&gt; employees = new ArrayList&lt;Employee&gt;();
        employees.add(new Employee("CEO",       50, 50000));
        employees.add(new Employee("Porter",    16, 10000));
        employees.add(new Employee("Tester",    35, 30000));
        employees.add(new Employee("Developer", 30, 40000));
&nbsp;
        System.out.println("Original order:");
        printEmployees(employees);
&nbsp;
        Collections.sort(employees, nameComparator);
        System.out.println("\nSorted by name:");
        printEmployees(employees);
&nbsp;
        Collections.sort(employees, ageComparator);
        System.out.println("\nSorted by age:");
        printEmployees(employees);
&nbsp;
        Collections.sort(employees, salaryComparator);
        System.out.println("\nSorted by salary:");
        printEmployees(employees);
    }
</pre>

<p>Ve skuteènosti v¹ak není nutné anonymní funkce ukládat do promìnných, ale
lze je pøímo pøi vytváøení pøedat metodì <i>Collections.sort()</i>. Na tomto
místì si prosím pov¹imnìte, ¾e se v&nbsp;následujícím programu
<strong>nikde</strong> nepí¹e, jakého typu je #{ Employee o1, Employee o2
.....}. Správný typ si odvodí samotný pøekladaè!</p>

<pre>
    public void run()
    {
        List&lt;Employee&gt; employees = new ArrayList&lt;Employee&gt;();
        employees.add(new Employee("CEO",       50, 50000));
        employees.add(new Employee("Porter",    16, 10000));
        employees.add(new Employee("Tester",    35, 30000));
        employees.add(new Employee("Developer", 30, 40000));
&nbsp;
        System.out.println("Original order:");
        printEmployees(employees);

        Collections.sort(employees, #{ Employee o1, Employee o2 -&gt;
            String name1 = o1.getName();
            String name2 = o2.getName();
            return name1.compareTo(name2);
        });
&nbsp;
        System.out.println("\nSorted by name:");
        printEmployees(employees);
&nbsp;
        Collections.sort(employees, #{ Employee o1, Employee o2 -&gt;
            return o1.getAge() - o2.getAge();
        });
&nbsp;
        System.out.println("\nSorted by age:");
        printEmployees(employees);
&nbsp;
        Collections.sort(employees, #{ Employee o1, Employee o2 -&gt;
            return o1.getSalary() - o2.getSalary();
        });
&nbsp;
        System.out.println("\nSorted by salary:");
        printEmployees(employees);
    }
}
</pre>

<p>Ji¾ v&nbsp;úvodních kapitolách jsme si øekli, ¾e pokud anonymní funkce
obsahuje ve svém tìle pouze pøíkaz <strong>return</strong>, lze tìlo nahradit
pouze jediným výrazem a zápis tak je¹tì více zjednodu¹it:</p>

<pre>
    public void run()
    {
        List&lt;Employee&gt; employees = new ArrayList&lt;Employee&gt;();
        employees.add(new Employee("CEO",       50, 50000));
        employees.add(new Employee("Porter",    16, 10000));
        employees.add(new Employee("Tester",    35, 30000));
        employees.add(new Employee("Developer", 30, 40000));
&nbsp;
        System.out.println("Original order:");
        printEmployees(employees);
&nbsp;
        Collections.sort(employees, #{ Employee o1, Employee o2 -&gt; o1.getName().compareTo(o2.getName()) });
&nbsp;
        System.out.println("\nSorted by name:");
        printEmployees(employees);
&nbsp;
        Collections.sort(employees, #{ Employee o1, Employee o2 -&gt; o1.getAge() - o2.getAge() });
&nbsp;
        System.out.println("\nSorted by age:");
        printEmployees(employees);
&nbsp;
        Collections.sort(employees, #{ Employee o1, Employee o2 -&gt; o1.getSalary() - o2.getSalary() });
&nbsp;
        System.out.println("\nSorted by salary:");
        printEmployees(employees);
    }
</pre>



<p><a name="k07"></a></p>
<h2>7. Rozdíl v&nbsp;bajtkódu generovaném pøi pøekladu prvního a druhého demonstraèního pøíkladu</h2>

<p>Podívejme se nyní pro zajímavost na to, jak jsou jednotlivé implementace
komparátorù pøelo¾eny do bajtkódu. Pro jednoduchost si porovnáme pouze
implementaci komparátoru pro porovnání vìku zamìstnancù. Bajtkód první
implementace kompatibilní s&nbsp;JDK 1.2 a¾ JDK 1.4, je pøímoèarý (poznámky
jsou samozøejmì doplnìny ruènì a pokud hledáte význam prvního parametru metody,
postaèuje si vzpomenout na &bdquo;skryté&ldquo; <strong>this</strong>, neboli
na referenci na instanci tøídy, pro ní¾ se metoda volá):</p>

<pre>
Compiled from "SortTest1.java"
class EmployeeComparatorByAge extends java.lang.Object implements java.util.Comparator{
EmployeeComparatorByAge();
  Code:
   0:   aload_0
   1:   invokespecial   #1; //Method java/lang/Object."&lt;init&gt;":()V
   4:   return
&nbsp;
public final int compare(java.lang.Object, java.lang.Object);
  Code:
   // *** druhy parametr metody - o1 ***
   0:   aload_1
&nbsp;
   // *** kontrola, zda lze provest pretypovani ***
   1:   checkcast       #2; //class Employee
   4:   invokevirtual   #3; //Method Employee.getAge:()I
   7:   istore_3
&nbsp;
   // *** treti parametr metody - o2 ***
   8:   aload_2
&nbsp;
   // *** kontrola, zda lze provest pretypovani ***
   9:   checkcast       #2; //class Employee
   12:  invokevirtual   #3; //Method Employee.getAge:()I
   15:  istore  4
&nbsp;
   // *** provedeni vlastniho vypoctu ***
   17:  iload_3
   18:  iload   4
   20:  isub
   21:  ireturn
}
</pre>

<p>Bajtkód &bdquo;typovaného&ldquo; komparátoru popsaného v&nbsp;páté kapitole
je ji¾ ponìkud slo¾itìj¹í. Mù¾eme zde vidìt, ¾e se kromì explicitnì zapsané
metody <i>compare()</i> s&nbsp;obìma parametry typu <strong>Employee</strong>
automaticky vytvoøila dal¹í (nefinální) metoda <i>compare()</i>, která má
naopak oba parametry typu <strong>Object</strong>. V&nbsp;této druhé metodì
jsou pou¾ity instrukce <strong>checkcast</strong> pro kontrolu typù obou
parametrù. Tímto zpùsobem bylo mo¾né vygenerovat bajtkód kompatibilní se
star¹ími JRE:</p>

<pre>
Compiled from "SortTest2.java"
class EmployeeComparatorByAge extends java.lang.Object implements java.util.Comparator{
EmployeeComparatorByAge();
  Code:
   0:   aload_0
   1:   invokespecial   #1; //Method java/lang/Object."&lt;init&gt;":()V
   4:   return
&nbsp;
public final int compare(Employee, Employee);
  Code:
   // *** druhy parametr metody - o1 ***
   0:   aload_1
&nbsp;
   // *** volani metody bez kontroly pretypovani ***
   1:   invokevirtual   #2; //Method Employee.getAge:()I
   4:   istore_3
&nbsp;
   // *** treti parametr metody - o2 ***
   5:   aload_2
&nbsp;
   // *** volani metody bez kontroly pretypovani ***
   6:   invokevirtual   #2; //Method Employee.getAge:()I
   9:   istore  4
&nbsp;
   // *** provedeni vlastniho vypoctu ***
   11:  iload_3
   12:  iload   4
   14:  isub
   15:  ireturn
&nbsp;
public int compare(java.lang.Object, java.lang.Object);
  Code:
   0:   aload_0
   1:   aload_1
   2:   checkcast       #3; //class Employee
   5:   aload_2
   6:   checkcast       #3; //class Employee
   9:   invokevirtual   #4; //Method compare:(LEmployee;LEmployee;)I
   12:  ireturn
}
</pre>

<p>V&nbsp;pøípadì, ¾e je namísto nové tøídy
<strong>EmployeeComparatorByAge</strong> ve zdrojovém kódu uvedena pouze
anonymní funkce (viz pøedchozí kapitolu), je struktura bajtkódu ponìkud
odli¹ná. První rozdíl spoèívá v&nbsp;tom, ¾e se namísto bajtkódu ulo¾eného
v&nbsp;souboru <strong>EmployeeComparatorByAge.class</strong> vytvoøí soubor
<strong>SortTest3$1.class</strong>, tj.&nbsp;první anonymní tøída deklarovaná
v&nbsp;rámci tøídy <strong>SortTest3</strong>. Druhý rozdíl spoèívá v&nbsp;tom,
¾e instance této tøídy obsahuje referenci na instanci tøídy
<strong>SortTest3</strong> ulo¾enou v&nbsp;atributu <strong>this$0</strong>,
jen¾ je automaticky naplòován v&nbsp;konstruktoru. Pravdìpodobnì jste ji¾
uhodli, k&nbsp;èemu tato reference slou¾í, ostatnì jeden pøíklad pou¾ití mù¾ete
najít v&nbsp;první kapitole. Dále se ji¾ vygenerovaný bajtkód odli¹uje od svých
pøedchùdcù pouze v&nbsp;tom, ¾e nejsou pou¾ity lokální promìnné, ale výpoèet se
provádí pøímo s&nbsp;hodnotami ulo¾enými na lokálním zásobníku (co¾ je
korektní, proto¾e se v&nbsp;anonymní funkci ¾ádné promìnné skuteènì
nepou¾ily):</p>

<pre>
Compiled from "SortTest3.java"
class SortTest3$1 extends java.lang.Object implements java.util.Comparator<Employee> {
  final SortTest3 this$0;
&nbsp;
  SortTest3$1(SortTest3);
    Code:
       0: aload_0       
       1: aload_1       
       2: putfield      #1                  // Field this$0:LSortTest3;
       5: aload_0       
       6: invokespecial #2                  // Method java/lang/Object."<init>":()V
       9: return        
&nbsp;
  public int compare(Employee, Employee);
    Code:
   // *** druhy parametr metody - o1 ***
       0: aload_1       
&nbsp;
   // *** volani metody bez kontroly pretypovani ***
       1: invokevirtual #3                  // Method Employee.getAge:()I
&nbsp;
   // *** treti parametr metody - o2 ***
       4: aload_2       
&nbsp;
   // *** volani metody bez kontroly pretypovani ***
       5: invokevirtual #3                  // Method Employee.getAge:()I
&nbsp;
   // *** provedeni vlastniho vypoctu ***
       8: isub          
       9: ireturn       
&nbsp;
  public int compare(java.lang.Object, java.lang.Object);
    Code:
       0: aload_0       
       1: aload_1       
       2: checkcast     #4                  // class Employee
       5: aload_2       
       6: checkcast     #4                  // class Employee
       9: invokevirtual #5                  // Method compare:(LEmployee;LEmployee;)I
      12: ireturn       
}
</pre>



<p><a name="k08"></a></p>
<h2>8. Anonymní funkce v&nbsp;roli filtrù</h2>

<p>Dal¹í zpùsob pou¾ití anonymních funkcí mù¾e být v&nbsp;pøípadì implementace
rùzných filtrù. V&nbsp;následujícím kódu, který si podrobnì popí¹eme a¾ pøí¹tì,
je ukázáno, jakým zpùsobem lze vytvoøit filtr pou¾itý pøi výpisu pouze tìch
zamìstnancù, jejich¾ atributy odpovídají zadané podmínce (vìk, vý¹e platu,
pozice jména v&nbsp;abecedì). Pov¹imnìte si, ¾e filtru (resp.&nbsp;anonymní
funkci) lze pøedat parametr èi parametry a ¾e filtry je mo¾né v&nbsp;pøípadì
potøeby psát dosti obecnì, napøíklad lze namísto <strong>Object param</strong>
pou¾ít promìnný poèet parametrù (<i>varrags</i>) atd.:</p>

<pre>
interface Filter
{
    public boolean filter(Employee e, Object param);
}

public class FilterTest4
{

    private void printEmployees(List&lt;Employee&gt; employees, Filter filter, Object param)
    {
        for (Employee employee : employees)
        {
            if (filter.filter(employee, param))
            {
                System.out.println(employee.toString());
            }
        }
    }

    public void run()
    {
        List&lt;Employee&gt; employees = new ArrayList&lt;Employee&gt;();
        employees.add(new Employee("CEO",       50, 50000));
        employees.add(new Employee("Porter",    16, 10000));
        employees.add(new Employee("Tester",    35, 30000));
        employees.add(new Employee("Developer", 30, 40000));

        System.out.println("\nOlder employees:");
        printEmployees(employees, #{ Employee o, Object age -&gt; o.getAge() &gt; (Integer)age}, 30);

        System.out.println("\nYounger employees:");
        printEmployees(employees, #{ Employee o, Object age -&gt; o.getAge() &lt; (Integer)age}, 30);

        System.out.println("\nRich employees:");
        printEmployees(employees, #{ Employee o, Object salary -&gt; o.getSalary() &gt; (Integer)salary}, 35000);

        System.out.println("\nAt the beginning of alphabet:");
        printEmployees(employees, #{ Employee o, Object chr -&gt; o.getName().charAt(0) &lt; (Character)chr}, 'E');
    }

    public static void main(String[] args)
    {
        new FilterTest4().run();
    }
}
</pre>



<p><a name="k09"></a></p>
<h2>9. Odkazy na Internetu</h2>

<ol>

<li>Java(TM) Platform, Standard Edition 7 Binary Snapshot Releases<br />
<a href="http://dlc.sun.com.edgesuite.net/jdk7/binaries/index.html">http://dlc.sun.com.edgesuite.net/jdk7/binaries/index.html</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>ClosableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>ArrayList (JDK 1.4)<br />
<a href="http://download.oracle.com/javase/1.4.2/docs/api/java/util/ArrayList.html">http://download.oracle.com/javase/1.4.2/docs/api/java/util/ArrayList.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2010</small></p>
</body>
</html>

