<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - pøipojení debuggeru k bì¾ícímu virtuálnímu stroji pøes rozhraní JDI (2)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - pøipojení debuggeru k bì¾ícímu virtuálnímu stroji pøes rozhraní JDI (2)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyku Java i o virtuálním stroji Javy si øekneme, jakým zpùsobem lze vyu¾ít metody nabízené rozhraním com.sun.jdi.VirtualMachine pro získání základních informací o cílovém virtuálním stroji Javy, zejména o vláknech a tøídách spravovaných tímto JVM.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - pøipojení debuggeru k bì¾ícímu virtuálnímu stroji pøes rozhraní JDI (2)</a></p>
<p><a href="#k02">2. Pøipojení debuggeru k&nbsp;cílové JVM</a></p>
<p><a href="#k03">3. Získání konektoru, který pro pøipojení k&nbsp;JVM vyu¾ívá sockety</a></p>
<p><a href="#k04">4. Pøipojení debuggeru k&nbsp;bì¾ícímu virtuálnímu stroji pøes socket</a></p>
<p><a href="#k05">5. Nastavení parametrù JDI konektoru</a></p>
<p><a href="#k06">6. Metody <strong>connectToVirtualMachine</strong> a <strong>shutdownVirtualMachine</strong></a></p>
<p><a href="#k07">7. Výpis základních informací o JVM, k ní¾ se debugger pøipojil</a></p>
<p><a href="#k08">8. Výpis informací o vláknech existujících ve cílové JVM</a></p>
<p><a href="#k09">9. Základní informace o vláknech, které lze pøes JDI získat</a></p>
<p><a href="#k10">10. Výpis informací o tøídách naètených do cílové JVM</a></p>
<p><a href="#k11">11. Kompletní zdrojový kód demonstraèního pøíkladu <strong>JDIVirtualMachineInfo</strong></a></p>
<p><a href="#k12">12. Pøeklad a spu¹tìní demonstraèního pøíkladu</a></p>
<p><a href="#k13">13. Zdrojové kódy demonstraèního pøíkladu i podpùrných skriptù</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - pøipojení debuggeru k bì¾ícímu virtuálnímu stroji pøes rozhraní JDI (2)</h2>

<p>V&nbsp;dne¹ní èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyku Java i o virtuálním stroji Javy</a> se ji¾ poètvrté
vrátíme k&nbsp;popisu rozhraní <i>JDI (Java Debugger Interface)</i>. Ji¾
v&nbsp;pøedchozích dílech jsme si pomìrnì dopodrobna popsali dva základní
zpùsoby pøipojení debuggeru èi jiného podobného nástroje k&nbsp;takzvanému
sledovanému (cílovému) virtuálnímu stroji Javy. Nyní se ji¾ k&nbsp;tomuto
tématu nebudeme vracet a budeme pøedpokládat, ¾e je cílová JVM v¾dy spu¹tìna
takovým zpùsobem, aby se k&nbsp;ní mohl debugger pøipojit pøes sockety.
Konkrétnì to znamená, ¾e cílová JVM bude spu¹tìna následujícím zpùsobem
(dùle¾ité je zde pøedev¹ím zvolené èíslo portu, které musí znát i
debugger):</p>

<pre>
java -agentlib:jdwp=transport=dt_socket,server=y,address=6502,suspend=y Test
</pre>

<p>Dnes si øekneme, jak lze s&nbsp;vyu¾itím metod nabízených rozhraním
<strong>com.sun.jdi.VirtualMachine</strong> získat základní informace o cílové
JVM. Zajímat nás budou zpoèátku informace o vláknech vytvoøených v&nbsp;cílové
JVM (a» ji¾ se jedná o vlákna bì¾ící èi naopak o vlákna pozastavená) i
informace o tøídách, které byly do tohoto virtuálního stroje Javy naèteny.
Podobnì, jako tomu bylo v&nbsp;pøedchozí èásti tohoto seriálu, se uká¾e, ¾e
javovské rozhraní <i>JDI</i> je na pou¾ití mnohem jednodu¹¹í, ne¾ nativní
rozhraní <i>JVM TI</i>.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Pøipojení debuggeru k&nbsp;cílové JVM</h2>

<p>Podobnì jako minule, i dnes si funkce nabízené rozhraním <i>JDI</i> popí¹eme
a vyu¾ijeme v&nbsp;relativnì jednoduchém demonstraèním pøíkladu, jeho¾ úplný
zdrojový kód najdete <a href="#k11">v&nbsp;jedenácté kapitole</a>. Tento
demonstraèní pøíklad pøedstavuje kostru debuggeru, který se k&nbsp;cílovému
virtuálnímu stroji Javy pøipojuje pøes sockety. To znamená, ¾e je nejprve nutné
získat v¹echny nabízené konektory implementující rozhraní
<strong>com.sun.jdi.connect.AttachingConnector</strong> s&nbsp;vyu¾itím metody
<strong>VirtualMachineManager.AttachingConnector()</strong> a posléze je nutné
z&nbsp;tohoto seznamu vybrat jediný konektor umo¾òující spojení s&nbsp;cílovou
JVM pøes sockety &ndash; samotný výbìr konektoru zaji¹»uje u¾ivatelská metoda
<strong>getSocketAttachConnector()</strong> vypsaná <a
href="#k03">v&nbsp;následující kapitole</a>. Jakmile se pøíslu¹ný konektor
získá, zavolá se dal¹í u¾ivatelská metoda nazvaná
<strong>debugVirtualMachineUsingSocket()</strong>, jejím¾ popisem se budeme
zabývat <a href="#k04">v&nbsp;kapitole ètvrté</a>:</p>

<pre>
    public static void <strong>main</strong>(String[] args) {
<i>        // ziskat (jedinou) instanci tridy VirtualMachineManager</i>
        VirtualMachineManager virtualMachineManager = <strong>Bootstrap.virtualMachineManager</strong>();
&nbsp;
<i>        // ziskat vsechny konektory pouzite pro pripojeni k bezici JVM</i>
        List&lt;AttachingConnector&gt; connectors = <strong>virtualMachineManager.attachingConnectors</strong>();
&nbsp;
<i>        // potrebujeme ziskat konektor pouzivajici pro pripojeni sockety</i>
        AttachingConnector connector = <strong>getSocketAttachConnector</strong>(connectors);
&nbsp;
        if (connector == null) {
            System.out.println("Socket connector is not available");
            return;
        }
&nbsp;
        debugVirtualMachineUsingSocket(connector);
    }
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Získání konektoru, který pro pøipojení k&nbsp;JVM vyu¾ívá sockety</h2>

<p>Metoda <strong>getSocketAttachConnector()</strong>, která je volána pøímo
z&nbsp;metody <strong>main()</strong> [<a href="#k02">kapitola 2</a>], je
implementována sice jednodu¹e, ov¹em (alespoò zdánlivì) neefektivnì.
Porovnáváme zde toti¾ jména jednotlivých konektorù s&nbsp;øetìzcovou konstantou
(literálem) a pokud je nalezen konektor se jménem "com.sun.jdi.SocketAttach"
(tento øetìzec je ulo¾en v&nbsp;konstantì
<strong>SOCKET_ATTACH_CONNECTOR_NAME</strong>), je tento konektor metodou ihned
vrácen. Na tomto místì je vhodné poznamenat, ¾e vzhledem k&nbsp;souèasnému
stavu <i>JDI</i> zde není mo¾né pou¾ít napøíklad operátor
<strong>instanceof</strong>, proto¾e konkrétní jméno tøídy èi rozhraní, kterou
musí konektor typu "SocketAttach" implementovat, není pøesnì zdokumentováno a
stabilizováno mezi rùznými implementacemi JVM (poznámka: zde popisovaná metoda
je shodná se stejnì pojmenovanou metodou pou¾itou v&nbsp;pøedchozí èásti tohoto
seriálu):</p>

<pre>
<i>    /**</i>
<i>     * Ziskat konektor pouzivajici pro pripojeni sockety</i>
<i>     */</i>
    private static AttachingConnector <strong>getSocketAttachConnector</strong>(List&lt;AttachingConnector&gt; connectors) {
        for (AttachingConnector connector : connectors) {
            if (SOCKET_ATTACH_CONNECTOR_NAME.equals(connector.name())) {
                return connector;
            }
        }
        return null;
    }
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Pøipojení debuggeru k&nbsp;bì¾ícímu virtuálnímu stroji pøes socket</h2>

<p>Dostáváme se k&nbsp;metodì
<strong>debugVirtualMachineUsingSocket()</strong>, která tvoøí ústøední èást
na¹eho zatím stále je¹tì velmi jednoduchého debuggeru. V&nbsp;této metodì se
nejprve pøes u¾ivatelskou metodu <strong>prepareConnectorArguments()</strong>
[<a href="#k05">kapitola 5</a>] nastaví v¹echny argumenty pou¾ívané konektorem
pøi pøipojování k&nbsp;cílovému virtuálnímu stroji Javy, provede se vlastní
pøipojení v&nbsp;dal¹í u¾ivatelské metodì
<strong>connectToVirtualMachine()</strong> [<a href="#k06">kapitola 6</a>] a
posléze se na standardní výstup vytisknou v¹echny informace získané
z&nbsp;cílové JVM. Následnì je cílová JVM zastavena v&nbsp;metodì
<strong>shutdownVirtualMachine()</strong> [<a href="#k06">kapitola 6</a>], a to
pøedev¹ím z&nbsp;toho dùvodu, ¾e by bylo pomìrnì obtí¾né navázat s&nbsp;cílovou
JVM dal¹í spojení ve chvíli, kdy se ji¾ jeden debugger odpojil.</p>

<pre>
<i>    /**</i>
<i>     * Pripojeni k bezicimu virtualnimu stroji pres socket.</i>
<i>     * @throws InterruptedException </i>
<i>     */</i>
    private static void <strong>debugVirtualMachineUsingSocket</strong>(AttachingConnector connector) {
<i>        // nastaveni argumentu pouzivanych konektorem</i>
        Map&lt;String, Connector.Argument&gt; arguments = prepareConnectorArguments(connector);
&nbsp;
        try {
<i>            // pripojeni ke vzdalenemu bezicimu virtualnimu stroji Javy</i>
            VirtualMachine virtualMachine = connectToVirtualMachine(connector, arguments);
&nbsp;
<i>            // vypis zakladnich informaci o pripojenem VM</i>
            printVirtualMachineInfo(virtualMachine);
&nbsp;
<i>            // ukonceni behu vzdaleneho virtualniho stroje</i>
            shutdownVirtualMachine(virtualMachine);
        }
        catch (IOException e) {
            e.printStackTrace();
        }
        catch (IllegalConnectorArgumentsException e) {
            e.printStackTrace();
        }
    }
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Nastavení parametrù JDI konektoru</h2>

<p>Ve chvíli, kdy ji¾ máme vybrán správný konektor, je mo¾né se pøipojit
k&nbsp;bì¾ícímu virtuálnímu stroji Javy. Aby se pøipojení skuteènì provedlo,
musí se nejprve nastavit port, pøes který se debugger k&nbsp;cílové JVM
pøipojí. My jsme si zvolili port èíslo 6502 a nastavení pøíslu¹ného parametru
(èi pøesnìji øeèeno argumentu) konektoru je provedeno v&nbsp;samostatné
u¾ivatelské metodì nazvané <strong>prepareConnectorArguments()</strong>. Tato
metoda pracuje velmi jednodu¹e &ndash; nejprve pøeète v¹echny výchozí argumenty
konektoru a posléze zmìní argument ulo¾ený pod klíèem "port". Pøipomeòme si, ¾e
mapa vrácená pøes <strong>AttachingConnector.defaultArguments()</strong> je
nemìnitelná v&nbsp;tom smyslu, ¾e do ní nelze pøidávat èi z&nbsp;ní odebírat
dal¹í prvky, ov¹em hodnoty jednotlivých prvkù je samozøejmì mo¾né mìnit:</p>

<pre>
<i>    /**</i>
<i>     * Nastaveni portu na cilove JVM, jenz debugger pouzije pro navazani spojeni.</i>
<i>     *</i>
<i>     * @param connector konektor pouzity pro pripojeni</i>
<i>     * @return mapa obsahujici parametry konektoru</i>
<i>     */</i>
    private static Map&lt;String, Connector.Argument&gt; <strong>prepareConnectorArguments</strong>(AttachingConnector connector) {
        Map&lt;String, Connector.Argument&gt; arguments = connector.defaultArguments();
        arguments.get("port").setValue("6502");
        return arguments;
    }
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Metody <strong>connectToVirtualMachine</strong> a <strong>shutdownVirtualMachine</strong></h2>

<p>V&nbsp;této kapitole si struènì popí¹eme význam dvou pomocných u¾ivatelských
metod nazvaných <strong>connectToVirtualMachine</strong> a
<strong>shutdownVirtualMachine</strong>. První z&nbsp;tìchto metod slou¾í
k&nbsp;pøipojení k&nbsp;cílovému virtuálnímu stroji Javy, co¾ je uvnitø metody
zaji¹tìno voláním <strong>AttachingConnector.attach()</strong>, kterému se
pøedá mapa obsahující nové argumenty (parametry) konektoru. V&nbsp;na¹em
demonstraèním debuggeru je modifikován argument "port" v&nbsp;ji¾ popsané
metodì <strong>prepareConnectorArguments()</strong> [<a href="#k05">kapitola
5</a>]:</p>

<pre>
<i>    /**</i>
<i>     * Pripojeni debuggeru ke sledovanemu virtualnimu stroji.</i>
<i>     *</i>
<i>     * @param connector konektor vyuzivajici pro spojeni sockety</i>
<i>     * @param arguments mapa obsahujici parametry pripojeni</i>
<i>     * @return sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     *</i>
<i>     * @throws IOException vyvolane v pripade, ze se pripojeni k JVM nepodari</i>
<i>     * @throws IllegalConnectorArgumentsException vyvolane v pripade spatne zadanych parametru</i>
<i>     */</i>
    private static VirtualMachine <strong>connectToVirtualMachine</strong>(AttachingConnector connector, Map&lt;String, Connector.Argument&gt; arguments)
        throws IOException, IllegalConnectorArgumentsException {
        System.out.println("Connecting to virtual machine");
        VirtualMachine virtualMachine = connector.attach(arguments);
        System.out.println("Connected");
        return virtualMachine;
    }
</pre>

<p>Dal¹í pomocná metoda nazvaná <strong>shutdownVirtualMachine()</strong>
slou¾í pro násilné ukonèení cílové JVM s&nbsp;pøedáním návratového kódu, který
je následnì vrácen operaènímu systému:</p>

<pre>
<i>    /**</i>
<i>     * Ukonceni prace beziciho sledovaneho virtualniho stroje.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>shutdownVirtualMachine</strong>(VirtualMachine virtualMachine) {
        System.out.println("Calling exit");
        virtualMachine.exit(EXIT_VALUE);
    }
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Výpis základních informací o JVM, k ní¾ se debugger pøipojil</h2>

<p>Jakmile se ná¹ demonstraèní debugger pøipojí k&nbsp;cílovému virtuálnímu
stroji Javy, je mo¾né s&nbsp;vyu¾itím rozhraní
<strong>com.sun.jdi.VirtualMachine</strong> získat mnoho dùle¾itých informací o
sledované JVM. V¹echny informace jsou získávány a vypisovány v&nbsp;u¾ivatelské
metodì nazvané <strong>printVirtualMachineInfo()</strong>, z&nbsp;ní¾ se volá
ètveøice dal¹ích u¾ivatelských metod <strong>printDescription()</strong>,
<strong>printVersion()</strong>, <strong>printThreadInfo()</strong> a
<strong>printClassesInfo()</strong>:</p>

<pre>
<i>    /**</i>
<i>     * Vypis informaci ziskanych ze sledovaneho virtualniho stroje.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>printVirtualMachineInfo</strong>(VirtualMachine virtualMachine) {
        System.out.println("Basic virtual machine info:");
        printDescription(virtualMachine);
        printVersion(virtualMachine);
        printThreadInfo(virtualMachine);
        printClassesInfo(virtualMachine);
    }
</pre>

<p>Zajímavá je metoda <strong>printDescription()</strong>, která na standardní
výstup vypí¹e podrobnìj¹í víceøádkový popis propojení mezi cílovým JVM a
debuggerem. Pro tento úèel se uvnitø této metody volá bezparametrická metoda
<strong>VirtualMachine.description()</strong> vracející øetìzec:</p>

<pre>
<i>    /**</i>
<i>     * Slovni viceradkovy popis sledovaneho virtualniho stroje.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>printDescription</strong>(VirtualMachine virtualMachine) {
        String description = virtualMachine.description();
        System.out.println("Description: " + description);
        System.out.println();
    }
</pre>

<p>Zpráva získaná touto metodou mù¾e vypadat napøíklad takto:</p>

<pre>
Java Debug Interface (Reference Implementation) version 1.6 
Java Debug Wire Protocol (Reference Implementation) version 1.6
JVM Debug Interface version 1.1
JVM version 1.6.0_01 (Java HotSpot(TM) Client VM, mixed mode, sharing)
</pre>

<p>Dal¹í metoda vypí¹e verzi cílového virtuálního stroje Javy, kterou je mo¾né
pou¾ít napøíklad pro rozhodování, které informace je mo¾né z&nbsp;této JVM
získat. Uvnitø je vyu¾ito volání bezparametrické metody
<strong>VirtualMachine.version()</strong> vracející øetìzec (nikoli celé
èíslo!):</p>

<pre>
<i>    /**</i>
<i>     * Verze sledovaneho virtualniho stroje.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>printVersion</strong>(VirtualMachine virtualMachine) {
        String version = virtualMachine.version();
        System.out.println("Version: " + version);
        System.out.println();
    }
</pre>

<p>Zpráva vypsaná touto metodou mù¾e vypadat takto:</p>

<pre>
Version: 1.6.0_01
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Výpis informací o vláknech existujících ve cílové JVM</h2>

<p>S&nbsp;vyu¾itím metod dostupných pøes rozhraní
<strong>com.sun.jdi.VirtualMachine</strong> je mo¾né pøeèíst i informace o
v¹ech vláknech vytvoøených ve sledovaném virtuálním stroji Javy. Jedná se o
vlákna, která se mohou nacházet v&nbsp;libovolném stavu, tj.&nbsp;o vlákna
bì¾ící, pozastavená, je¹tì nespu¹tìná, vlákna èekající na uvolnìní zámku atd.
atd. Seznam v¹ech vláken se pøeète metodou
<strong>VirtualMachine.allThreads()</strong>, pøièem¾ prvky tohoto seznamu jsou
typu <strong>com.sun.jdi.ThreadReference</strong>. Ka¾dý objekt tohoto typu
obsahuje mnoho informací o jednotlivých vláknech, napøíklad unikátní
identifikátor vlákna, jeho jméno, stav vlákna a takté¾ informaci o tom, zda je
vlákno pozastaveno samotným debuggerem. O pøeètení informací o v¹ech vláknech a
následný výpis tìchto informací se stará u¾ivatelská metoda nazvaná
<strong>printThreadInfo()</strong>:</p>

<pre>
<i>    /**</i>
<i>     * Vypis informaci o vlaknech existujicich ve sledovanem virtualnim stroji.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>printThreadInfo</strong>(VirtualMachine virtualMachine) {
        System.out.println("Thread info:");
        System.out.println("    UniqueID    Thread name            Status       Suspended");
        List&lt;ThreadReference&gt; threads = <strong>virtualMachine.allThreads()</strong>;
        for (ThreadReference thread : threads) {
            String threadName = thread.name();
            String threadStatus = getThreadStatus(thread);
            String threadSuspended = getThreadSuspended(thread);
            long uniqueID = thread.uniqueID();
            System.out.format("    %8d    %-20s   %-12s    %-5s\n", uniqueID, threadName, threadStatus, threadSuspended);
        }
        System.out.println();
    }
</pre>

<p>Pou¾ité metody:</p>

<pre>
String  com.sun.jdi.ThreadReference.name()
long    com.sun.jdi.ObjectReference.uniqueID() - zdìdìno
int     com.sun.jdi.ThreadReference.status()
boolean com.sun.jdi.ThreadReference.isSuspended()
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Základní informace o vláknech, které lze pøes JDI získat</h2>

<p>U¾ivatelská metoda <strong>printThreadInfo()</strong> popsaná <a
href="#k08">v&nbsp;pøedchozí kapitole</a> ve skuteènosti volá dvì dal¹í
u¾ivatelské metody nazvané <strong>getThreadStatus()</strong> a
<strong>getThreadSuspended()</strong>. Metoda
<strong>getThreadStatus()</strong> vrací stav vlákna jako øetìzec. Ve
skuteènosti je toti¾ stav vlákna reprezentován celoèíselnou konstantou (nikoli
plnohodnotným výètovým typem), který lze na øetìzec pøevést napøíklad
s&nbsp;vyu¾itím strukturovaného pøíkazu <i>switch</i> (osobnì si myslím, ¾e by
tento pøíkaz nemusel být v&nbsp;objektovì orientovaném jazyce vùbec
implementován, ov¹em jeho interní implementace je v&nbsp;pøípadì celoèíselných
konstant pomìrnì efektivní, a to jak po pamì»ové stránce, tak po stránce
efektivity vygenerovaného bajtkódu):</p>

<pre>
<i>    /**</i>
<i>     * Prevod stavu vlakna na retezec.</i>
<i>     *</i>
<i>     * @param thread JDI objekt predstavujici vlakno</i>
<i>     * @return stav vlakna v retezcove podobe</i>
<i>     */</i>
    private static String <strong>getThreadStatus</strong>(ThreadReference thread) {
        switch (thread.status()) {
        case ThreadReference.THREAD_STATUS_NOT_STARTED:
            return "not started";
        case ThreadReference.THREAD_STATUS_RUNNING:
            return "running";
        case ThreadReference.THREAD_STATUS_SLEEPING:
            return "sleeping";
        case ThreadReference.THREAD_STATUS_MONITOR:
            return "wait/monitor";
        case ThreadReference.THREAD_STATUS_WAIT:
            return "Object.wait";
        case ThreadReference.THREAD_STATUS_ZOMBIE:
            return "zombie";
        case ThreadReference.THREAD_STATUS_UNKNOWN:
            return "*unkwnown*";
        default:
            return "should not happen!";
        }
    }
</pre>

<p>Dal¹í pomocná u¾ivatelská metoda nazvaná
<strong>getThreadSuspended()</strong> je velmi jednoduchá &ndash; vrací pouze
øetìzec "yes" èi "no" na základì toho, zda je dané vlákno v&nbsp;cílovém
virtuálním stroji Javy pozastaveno debuggerem èi nikoli (tento stav je nutné
odli¹it od pùvodního stavu vlákna):</p>

<pre>
<i>    /**</i>
<i>     * Informace (ve tvaru retezce) o tom, zda je vlakno pozastaveno ci nikoli.</i>
<i>     *</i>
<i>     * @param thread JDI objekt predstavujici vlakno</i>
<i>     * @return stav pozastaveni vlakna v retezcove podobe</i>
<i>     */</i>
    private static String <strong>getThreadSuspended</strong>(ThreadReference thread) {
        return thread.isSuspended() ? "yes" : "no";
    }
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Výpis informací o tøídách naètených do cílové JVM</h2>

<p>Mezi dal¹í dùle¾ité informace o cílovém virtuálním stroji Javy patøí seznam
tøíd, které jsou do této JVM naèteny jak pøi inicializaci virtuálního stroje,
tak i pøi bìhu aplikace. V¹echny dostupné tøídy lze získat s&nbsp;vyu¾itím
metody <strong>com.sun.jdi.VirtualMachine.allClasses()</strong> vracející
seznam objektù typu <strong>com.sun.jdi.ReferenceType</strong>, co¾ je tøída
odvozená od obecnìj¹í tøídy <strong>com.sun.jdi.Type</strong>, s&nbsp;ní¾ se
pravdìpodobnì seznámíme pøí¹tì. O ka¾dé tøídì lze získat mnoho informací,
samozøejmì vèetnì jejího jména a signatury. Aby nebyl výpis pøíli¹ dlouhý,
omezíme se v&nbsp;na¹em testovacím pøíkladu na výpis tøíd obsahujících øetìzec
"String":</p>

<pre>
<i>    /**</i>
<i>     * Vypis zakladnich informaci o tridach nactenych do sledovane JVM.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>printClassesInfo</strong>(VirtualMachine virtualMachine) {
        System.out.println("Class info:");
        System.out.format("    %-45s    %-45s   %s\n", "Name", "Signature", "Source");
        List&lt;ReferenceType&gt; classes = virtualMachine.allClasses();
        for (ReferenceType klass : classes) {
            String className = klass.name();
<i>            /* jednoduchy filtr */</i>
            if (!className.contains("String")) continue;
            String classSignature = klass.signature();
            String sourceName;
            try {
                sourceName = klass.sourceName();
            }
            catch (AbsentInformationException e) {
                sourceName = "unknown";
            }
            System.out.format("    %-45s    %-45s   %s\n", className, classSignature, sourceName);
        }
        System.out.println();
    }
</pre>

<p>Pou¾ité metody:</p>

<pre>
String com.sun.jdi.ReferenceType.name()
String com.sun.jdi.ReferenceType.sourceName()
String com.sun.jdi.Type.signature() - zdìdìno
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Kompletní zdrojový kód demonstraèního pøíkladu <strong>JDIVirtualMachineInfo</strong></h2>

<p>V&nbsp;pøedchozích kapitolách byly popsány prakticky v¹echny metody, které
jsou souèástí dne¹ního demonstraèního pøíkladu tvoøícího kostru debuggeru. Pod
tímto odstavcem je vypsán celý zdrojový kód tohoto velmi jednoduchého
debuggeru:</p>

<pre>
import java.io.IOException;
import java.util.List;
import java.util.Map;
&nbsp;
import com.sun.jdi.AbsentInformationException;
import com.sun.jdi.Bootstrap;
import com.sun.jdi.IncompatibleThreadStateException;
import com.sun.jdi.ReferenceType;
import com.sun.jdi.ThreadReference;
import com.sun.jdi.VirtualMachine;
import com.sun.jdi.VirtualMachineManager;
import com.sun.jdi.connect.AttachingConnector;
import com.sun.jdi.connect.Connector;
import com.sun.jdi.connect.IllegalConnectorArgumentsException;
&nbsp;
<i>/**</i>
<i> * Pripojeni k bezicimu virtualnimu stroji Javy,</i>
<i> * ktery byl spusten s parametry:</i>
<i> * java -agentlib:jdwp=transport=dt_socket,server=y,address=6502,suspend=y Trida</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>JDIVirtualMachineInfo</strong> {
&nbsp;
<i>    /**</i>
<i>     * Navratovy kod pouzity pri ukoncovani sledovane JVM.</i>
<i>     */</i>
    private static final int EXIT_VALUE = 0;
&nbsp;
<i>    /**</i>
<i>     * Jmeno konektoru, ktery pro pripojeni pouziva sockety.</i>
<i>     */</i>
    private static final String SOCKET_ATTACH_CONNECTOR_NAME = "com.sun.jdi.SocketAttach";
&nbsp;
    public static void <strong>main</strong>(String[] args) {
<i>        // ziskat (jedinou) instanci tridy VirtualMachineManager</i>
        VirtualMachineManager virtualMachineManager = Bootstrap.virtualMachineManager();
&nbsp;
<i>        // ziskat vsechny konektory pouzite pro pripojeni k bezici JVM</i>
        List&lt;AttachingConnector&gt; connectors = virtualMachineManager.attachingConnectors();
&nbsp;
<i>        // potrebujeme ziskat konektor pouzivajici pro pripojeni sockety</i>
        AttachingConnector connector = getSocketAttachConnector(connectors);
&nbsp;
        if (connector == null) {
            System.out.println("Socket connector is not available");
            return;
        }
&nbsp;
        debugVirtualMachineUsingSocket(connector);
    }
&nbsp;
<i>    /**</i>
<i>     * Ziskat konektor pouzivajici pro pripojeni sockety</i>
<i>     */</i>
    private static AttachingConnector <strong>getSocketAttachConnector</strong>(List&lt;AttachingConnector&gt; connectors) {
        for (AttachingConnector connector : connectors) {
            if (SOCKET_ATTACH_CONNECTOR_NAME.equals(connector.name())) {
                return connector;
            }
        }
        return null;
    }
&nbsp;
<i>    /**</i>
<i>     * Pripojeni k bezicimu virtualnimu stroji pres socket.</i>
<i>     * @throws InterruptedException </i>
<i>     */</i>
    private static void <strong>debugVirtualMachineUsingSocket</strong>(AttachingConnector connector) {
<i>        // nastaveni argumentu pouzivanych konektorem</i>
        Map&lt;String, Connector.Argument&gt; arguments = prepareConnectorArguments(connector);
&nbsp;
        try {
<i>            // pripojeni ke vzdalenemu bezicimu virtualnimu stroji Javy</i>
            VirtualMachine virtualMachine = connectToVirtualMachine(connector, arguments);
&nbsp;
<i>            // vypis zakladnich informaci o pripojenem VM</i>
            printVirtualMachineInfo(virtualMachine);
&nbsp;
<i>            // ukonceni behu vzdaleneho virtualniho stroje</i>
            shutdownVirtualMachine(virtualMachine);
        }
        catch (IOException e) {
            e.printStackTrace();
        }
        catch (IllegalConnectorArgumentsException e) {
            e.printStackTrace();
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Nastaveni portu na cilove JVM, jenz debugger pouzije pro navazani spojeni.</i>
<i>     *</i>
<i>     * @param connector konektor pouzity pro pripojeni</i>
<i>     * @return mapa obsahujici parametry konektoru</i>
<i>     */</i>
    private static Map&lt;String, Connector.Argument&gt; <strong>prepareConnectorArguments</strong>(AttachingConnector connector) {
        Map&lt;String, Connector.Argument&gt; arguments = connector.defaultArguments();
        arguments.get("port").setValue("6502");
        return arguments;
    }
&nbsp;
<i>    /**</i>
<i>     * Pripojeni debuggeru ke sledovanemu virtualnimu stroji.</i>
<i>     *</i>
<i>     * @param connector konektor vyuzivajici pro spojeni sockety</i>
<i>     * @param arguments mapa obsahujici parametry pripojeni</i>
<i>     * @return sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     *</i>
<i>     * @throws IOException vyvolane v pripade, ze se pripojeni k JVM nepodari</i>
<i>     * @throws IllegalConnectorArgumentsException vyvolane v pripade spatne zadanych parametru</i>
<i>     */</i>
    private static VirtualMachine <strong>connectToVirtualMachine</strong>(AttachingConnector connector, Map&lt;String, Connector.Argument&gt; arguments)
        throws IOException, IllegalConnectorArgumentsException {
        System.out.println("Connecting to virtual machine");
        VirtualMachine virtualMachine = connector.attach(arguments);
        System.out.println("Connected");
        return virtualMachine;
    }
&nbsp;
<i>    /**</i>
<i>     * Ukonceni prace beziciho sledovaneho virtualniho stroje.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>shutdownVirtualMachine</strong>(VirtualMachine virtualMachine) {
        System.out.println("Calling exit");
        virtualMachine.exit(EXIT_VALUE);
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis informaci ziskanych ze sledovaneho virtualniho stroje.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>printVirtualMachineInfo</strong>(VirtualMachine virtualMachine) {
        System.out.println("Basic virtual machine info:");
        printDescription(virtualMachine);
        printVersion(virtualMachine);
        printThreadInfo(virtualMachine);
        printClassesInfo(virtualMachine);
    }
&nbsp;
<i>    /**</i>
<i>     * Slovni viceradkovy popis sledovaneho virtualniho stroje.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>printDescription</strong>(VirtualMachine virtualMachine) {
        String description = virtualMachine.description();
        System.out.println("Description: " + description);
        System.out.println();
    }
&nbsp;
<i>    /**</i>
<i>     * Verze sledovaneho virtualniho stroje.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>printVersion</strong>(VirtualMachine virtualMachine) {
        String version = virtualMachine.version();
        System.out.println("Version: " + version);
        System.out.println();
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis informaci o vlaknech existujicich ve sledovanem virtualnim stroji.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>printThreadInfo</strong>(VirtualMachine virtualMachine) {
        System.out.println("Thread info:");
        System.out.println("    UniqueID    Thread name            Status       Suspended");
        List&lt;ThreadReference&gt; threads = virtualMachine.allThreads();
        for (ThreadReference thread : threads) {
            String threadName = thread.name();
            String threadStatus = getThreadStatus(thread);
            String threadSuspended = getThreadSuspended(thread);
            long uniqueID = thread.uniqueID();
            System.out.format("    %8d    %-20s   %-12s    %-5s\n", uniqueID, threadName, threadStatus, threadSuspended);
        }
        System.out.println();
    }
&nbsp;
<i>    /**</i>
<i>     * Prevod stavu vlakna na retezec.</i>
<i>     *</i>
<i>     * @param thread JDI objekt predstavujici vlakno</i>
<i>     * @return stav vlakna v retezcove podobe</i>
<i>     */</i>
    private static String <strong>getThreadStatus</strong>(ThreadReference thread) {
        switch (thread.status()) {
        case ThreadReference.THREAD_STATUS_NOT_STARTED:
            return "not started";
        case ThreadReference.THREAD_STATUS_RUNNING:
            return "running";
        case ThreadReference.THREAD_STATUS_SLEEPING:
            return "sleeping";
        case ThreadReference.THREAD_STATUS_MONITOR:
            return "wait/monitor";
        case ThreadReference.THREAD_STATUS_WAIT:
            return "Object.wait";
        case ThreadReference.THREAD_STATUS_ZOMBIE:
            return "zombie";
        case ThreadReference.THREAD_STATUS_UNKNOWN:
            return "*unkwnown*";
        default:
            return "should not happen!";
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Informace (ve tvaru retezce) o tom, zda je vlakno pozastaveno ci nikoli.</i>
<i>     *</i>
<i>     * @param thread JDI objekt predstavujici vlakno</i>
<i>     * @return stav pozastaveni vlakna v retezcove podobe</i>
<i>     */</i>
    private static String <strong>getThreadSuspended</strong>(ThreadReference thread) {
        return thread.isSuspended() ? "yes" : "no";
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis zakladnich informaci o tridach nactenych do sledovane JVM.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>printClassesInfo</strong>(VirtualMachine virtualMachine) {
        System.out.println("Class info:");
        System.out.format("    %-45s    %-45s   %s\n", "Name", "Signature", "Source");
        List&lt;ReferenceType&gt; classes = virtualMachine.allClasses();
        for (ReferenceType klass : classes) {
            String className = klass.name();
<i>            /* jednoduchy filtr */</i>
            if (!className.contains("String")) continue;
            String classSignature = klass.signature();
            String sourceName;
            try {
                sourceName = klass.sourceName();
            }
            catch (AbsentInformationException e) {
                sourceName = "unknown";
            }
            System.out.format("    %-45s    %-45s   %s\n", className, classSignature, sourceName);
        }
        System.out.println();
    }
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Pøeklad a spu¹tìní demonstraèního pøíkladu</h2>

<p>Pøeklad demonstraèního pøíkladu zajistí následující pøíkaz, který byl
odladìn na OpenJDK6. Pokud je vyu¾ita jiná JDK èi odli¹ná verze OpenJDK, je
nutné upravit cestu k&nbsp;java archivu <strong>tools.jar</strong>:</p>

<pre>
javac -classpath /usr/lib/jvm/java-6-openjdk/lib/tools.jar:. JDIVirtualMachineInfo.java
</pre>

<p>Pro kontrolu funkènosti na¹eho demonstraèního pøíkladu se pou¾ije
následující testovací tøída (stejná tøída byla pou¾ita i minule):</p>

<pre>
public class <strong>Test</strong> {
&nbsp;
    public static void main(String[] args) {
        while (true) {
            System.out.println("Hello world!");
        }
    }
&nbsp;
}
</pre>

<p>Po pøekladu testovací tøídy:</p>

<pre>
javac Test
</pre>

<p>se provede její spu¹tìní následujícím zpùsobem:</p>

<pre>
java -agentlib:jdwp=transport=dt_socket,server=y,address=6502,suspend=y Test
</pre>

<p>Demonstraèní debugger, který byl popsaný v&nbsp;pøedchozích kapitolách, je
nutné spustit tak, aby virtuální stroj Javy na¹el i archiv
<strong>tools.jar</strong>:</p>

<pre>
java -cp /usr/lib/jvm/java-6-openjdk/lib/tools.jar:. JDIVirtualMachineInfo
</pre>

<p>Po spu¹tìní by se mìla na standardním výstupu objevit pøibli¾nì tato zpráva
(její konkrétní znìní se mù¾e li¹it v&nbsp;závislosti na tom, jaká JRE je
pou¾ita pro spu¹tìní cílové JVM):</p>

<pre>
Connecting to virtual machine
Connected
Basic virtual machine info:
Description: Java Debug Interface (Reference Implementation) version 1.6 
Java Debug Wire Protocol (Reference Implementation) version 1.6
JVM Debug Interface version 1.1
JVM version 1.6.0_01 (Java HotSpot(TM) Client VM, mixed mode, sharing)
&nbsp;
Version: 1.6.0_01
&nbsp;
Thread info:
    UniqueID    Thread name            Status       Suspended
           2    Attach Listener        running         yes  
           3    Signal Dispatcher      running         yes  
           4    Finalizer              Object.wait     yes  
           5    Reference Handler      Object.wait     yes  
           1    main                   running         yes  
&nbsp;
Class info:
    Name                                             Signature                                       Source
    java.lang.AbstractStringBuilder                  Ljava/lang/AbstractStringBuilder;               AbstractStringBuilder.java
    java.lang.String                                 Ljava/lang/String;                              String.java
    java.lang.String$CaseInsensitiveComparator       Ljava/lang/String$CaseInsensitiveComparator;    String.java
    java.lang.StringBuffer                           Ljava/lang/StringBuffer;                        StringBuffer.java
    java.lang.StringBuilder                          Ljava/lang/StringBuilder;                       StringBuilder.java
    java.lang.StringCoding                           Ljava/lang/StringCoding;                        StringCoding.java
    java.lang.StringCoding$StringDecoder             Ljava/lang/StringCoding$StringDecoder;          StringCoding.java
    java.lang.StringCoding$StringEncoder             Ljava/lang/StringCoding$StringEncoder;          StringCoding.java
    java.lang.String[]                               [Ljava/lang/String;                             unknown
    java.util.StringTokenizer                        Ljava/util/StringTokenizer;                     StringTokenizer.java
&nbsp;
Calling exit
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Zdrojové kódy demonstraèního pøíkladu i podpùrných skriptù</h2>

<p>Zdrojové kódy demonstraèního pøíkladu, testovací tøídy i skriptù pou¾itých
pro pøeklad a spu¹tìní demonstraèního pøíkladu, byly ulo¾eny do Mercurial
repositáøe dostupného na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
Prozatím nejnovìj¹í verze v¹ech zmínìných zdrojových souborù a skriptù mù¾ete
najít na adresách:</p>

<table>
<tr><th>#</th><th>Zdrojový soubor/skript</th><th>Umístìní v&nbsp;repositáøi</th></tr>
<tr><td>1</td><td>JDIVirtualMachineInfo</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/cadf0d815a2b/jdi/JDIVirtualMachineInfo.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/cadf0d815a2b/jdi/JDIVirtualMachineInfo.java</a></td></tr>
<tr><td>2</td><td>compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/cadf0d815a2b/jdi/compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/cadf0d815a2b/jdi/compile.sh</a></td></tr>
<tr><td>3</td><td>Test.java                               </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/716580c5d0ab/jdi/Test.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/716580c5d0ab/jdi/Test.java</a></td></tr>
<tr><td>4</td><td>Test.sh                                 </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/716580c5d0ab/jdi/Test.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/716580c5d0ab/jdi/Test.sh</a></td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Breakpoint (Wikipedia)<br />
<a href="http://cs.wikipedia.org/wiki/Breakpoint">http://cs.wikipedia.org/wiki/Breakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation<br />
<a href="http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html">http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; SetBreakpoint<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#SetBreakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#SetBreakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; ClearBreakpoint<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#ClearBreakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#ClearBreakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; Breakpoint (callback funkce)<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#Breakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#Breakpoint</a>
</li>

<li>The JVM Tool Interface (JVM TI): How VM Agents Work<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html">http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html</a>
</li>

<li>Creating a Debugging and Profiling Agent with JVMTI<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html">http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html</a>
</li>

<li>JVM TI (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/JVM_TI">http://en.wikipedia.org/wiki/JVM_TI</a>
</li>

<li>IBM JVMTI extensions<br />
<a href="http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html">http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

