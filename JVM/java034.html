<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Clojure aneb jazyk umo¾òující tvorbu bezpeèných vícevláknových aplikací pro JVM (3.èást - funkcionální programování)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Clojure aneb jazyk umo¾òující tvorbu bezpeèných vícevláknových aplikací pro JVM (3.èást - funkcionální programování)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o vlastnostech JVM se ji¾ potøetí vrátíme k&nbsp;popisu programovacího jazyka Clojure. Zatímco v&nbsp;pøedchozích dvou èástech jsme se zabývali pøedev¹ím popisem zpùsobu zápisu rùzných forem, dnes se ji¾ koneènì zaèneme zabývat tvorbou programù, a to pøedev¹ím se zamìøením na funkcionální paradigma.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Tvorba skuteèných aplikací programù v&nbsp;programovacím jazyce Clojure</a></p>
<p><a href="#k02">2. Speciální forma <strong>def</strong></a></p>
<p><a href="#k03">3. Jmenné prostory</a></p>
<p><a href="#k04">4. Role a vlastnosti funkcí ve funkcionálních programovacích jazycích</a></p>
<p><a href="#k05">5. Vytvoøení u¾ivatelských funkcí</a></p>
<p><a href="#k06">6. Zjednodu¹ená deklarace funkcí, funkce s&nbsp;více aritami</a></p>
<p><a href="#k07">7. Programové smyèky ve funkcionálních jazycích? Nikoli, spí¹e rekurze!</a></p>
<p><a href="#k08">8. Mo¾né problémy s&nbsp;rekurzí a øe¹ení tìchto problémù &ndash; tail rekurze</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Tvorba skuteèných aplikací v&nbsp;programovacím jazyce Clojure</h2>

<p>V&nbsp;pøedchozí èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyce Java i o vlastnostech virtuálního stroje tohoto jazyka</a>
jsme dokonèili popis zpùsobu zápisu v¹ech ètyø typù forem, z&nbsp;nich¾ se
skládají v¹echny zdrojové kódy napsané v&nbsp;programovacím jazyce
<i>Clojure</i>. Takté¾ jsme si øekli, ¾e s&nbsp;vyu¾itím takzvaných
<i>slo¾ených forem</i> je mo¾né zapsat jak kolekce (v&nbsp;Clojure pøedev¹ím
seznamy, vektory, mno¾iny, mapy &ndash; asociativní pole), tak i volání funkcí,
proto¾e zpùsob zápisu volání funkcí odpovídá v&nbsp;Clojure &ndash; a takté¾
v&nbsp;LISPu èi Scheme &ndash; zápisu seznamu, pøièem¾ první prvek seznamu
v&nbsp;tomto pøípadì pøedstavuje jméno funkce (resp.&nbsp;pøesnìji øeèeno
symbol navázaný na funkci) a dal¹í prvky seznamu jsou (po vyhodnocení) volané
funkci pøedány jako její parametry. Pøipomeòme si také, ¾e kromì slo¾ených
forem bylo nutné programovací jazyk Clojure vybavit i takzvanými <i>speciálními
formami</i>, které jsou obecnì zpracovávány odli¹ným zpùsobem &ndash; vìt¹inou
se napøíklad nevyhodnocují jejich parametry.</p>

<p>Jen pro malé pøipomenutí si v&nbsp;této kapitole uvedeme nìkolik
demonstraèních pøíkladù, na nich¾ bude ukázán zpùsob pou¾ití slo¾ených forem
(seznamù, vektorù, mno¾in a map) a takté¾ speciálních forem, pøesnìji øeèeno
prozatím jen speciální formy <strong>if</strong>.</p>

<p>Základní slo¾enou formou je <i>seznam (list)</i>, co¾ ostatnì nebude velkým
pøekvapením, nebo» Clojure je potomek jazyka LISP, jeho¾ název je odvozen od
sousloví &bdquo;LISt Processing&ldquo;. V&nbsp;následujícím pøíkladu je
vytvoøen seznam obsahující dal¹í seznamy (zde se vlastnì jedná o nevyvá¾ený
binární strom). Apostrof pøed seznamem musí být uveden z&nbsp;toho dùvodu, aby
se celý zápis nechápal jako volání funkce navázané na symbol
<strong>1</strong>. Taková funkce toti¾ neexistuje a ani existovat nemù¾e,
nebo» jméno symbolu nemù¾e zaèínat èíslicí:</p>

<pre>
user=&gt; '(1 (2 (3 (4 5))))
(1 (2 (3 (4 5))))
</pre>

<p>Následuje ukázka zápisu vektoru. Vzhledem k&nbsp;tomu, ¾e v&nbsp;pøípadì
vektorù lze velmi efektivnì pøistupovat k&nbsp;jeho prvkùm pomocí indexù,
podobají se vektory javovskému typu pole/array:</p>

<pre>
user=&gt; [ [1 2 3] [4 5 6] [7 8 9]]
[[1 2 3] [4 5 6] [7 8 9]]
</pre>

<p>V¹echny kolekce lze samozøejmì rùzným zpùsobem kombinovat; napøíklad zde je
uveden vektor seznamù:</p>

<pre>
user=&gt; [ '(:jedna :dva) '(:tri :ctyri) '(:pet :sest) ]
[(:jedna :dva) (:tri :ctyri) (:pet :sest)]
</pre>

<p>Mapa, popø.&nbsp;té¾ asociativní pole, se v&nbsp;reálných aplikacích pou¾ívá
pomìrnì èasto, nebo» odstraòuje nìkteré nevýhody seznamù i vektorù:</p>

<pre>
user=&gt; {:prvni 1, :druhy 2}
{:druhy 2, :prvni 1}
</pre>

<p>Zbývají nám ji¾ jen mno¾iny:</p>

<pre>
user=&gt; #{"toto" "je" "mnozina"}                   
#{"mnozina" "toto" "je"}
</pre>

<p>Pøíklad volání funkcí * (souèin) a + (souèet):</p>

<pre>
user=&gt; (* (+ 1 2 3) (+ 3 4))
42
</pre>

<p>Pøíklad pou¾ití speciální formy <strong>if</strong>:</p>

<pre>
; na základì podmínky se vyhodnotí (a vrátí jako výsledek)
; buï øetìzec "mensi" nebo "vetsi"
(if (&lt; 1 2) "mensi" "vetsi")
"mensi"
</pre>

<p>V&nbsp;tomto pøípadì je zaruèeno, ¾e se na základì podmínky &ndash; tedy
prvního parametru speciální formy <strong>if</strong> &ndash; vyhodnotí
<i>buï</i> druhý parametr <i>nebo</i> tøetí parametr, nikoli v¹ak oba parametry
souèasnì. Právì z&nbsp;tohoto dùvodu je <strong>if</strong> implementován jako
speciální forma a nikoli jako bì¾ná slo¾ená forma &ndash; funkce.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Speciální forma <strong>def</strong></h2>

<p>První speciální formou, s&nbsp;ní¾ se dnes seznámíme, je speciální forma
nazvaná <strong>def</strong>. Ta se vìt¹inou pou¾ívá k&nbsp;navázání libovolné
hodnoty (napøíklad èísla, pravdivostní hodnoty, øetìzce, seznamu a jak uvidíme
dále, tak i funkce) na symbol. Ménì èasté je pou¾ití této speciální formy
k&nbsp;pouhému vytvoøení symbolu. V&nbsp;pøípadì, ¾e Clojure vyhodnotí
(&bdquo;spustí&ldquo;) tuto speciální formu, dojde k&nbsp;vytvoøení nové
globální promìnné v&nbsp;aktuálnì nastaveném jmenném prostoru (nejde tedy o
skuteènou globální promìnnou, ale o promìnnou identifikovatelnou pøes jmenný
prostor &ndash; viz dále) a k&nbsp;inicializaci této promìnné. Pokud ji¾
globální promìnná stejného jména existuje, dojde k&nbsp;&bdquo;pøepisu&ldquo;
její hodnoty. Ve skuteènosti v¹ak stará hodnota nemusí pøestat existovat,
proto¾e mù¾e být navázána na dal¹í promìnné. Navíc je mo¾né pomocí nepovinného
parametru k&nbsp;promìnné pøiøadit i dokumentaèní øetìzec; jak se to dìlá, si
uká¾eme v&nbsp;jednom demonstraèním pøíkladu.</p>

<div class="rs-box"><p>Poznámka: <i>Clojure</i> nám sice bez jakéhokoli varování umo¾ní zmìnit
hodnotu globální promìnné s&nbsp;vyu¾itím formy <strong>def</strong>, ov¹em
v&nbsp;praxi se tento obrat nedoporuèuje pou¾ívat, proto¾e zmìna tìchto
promìnných obecnì není ve vícevláknových programech bezpeèná a programová zmìna
globálních promìnných je z&nbsp;tohoto dùvodu pova¾ována za ¹patný návyk.
Naproti tomu manuální zmìna je mo¾ná a nìkdy i nutná.</p></div>

<p>Podívejme se nyní na demonstraèní pøíklady, na nich¾ je ukázán základní
zpùsob pou¾ití speciální formy <strong>def</strong>:</p>

<p>Vytvoøení nové globální promìnné nazvané <i>message</i> a její pou¾ití ve
funkci <strong>println</strong> (co tato funkce dìlá pravdìpodobnì není
zapotøebí podrobnì vysvìtlovat :-):</p>

<pre>
user=&gt; (def message "Hello world")
#'user/message
&nbsp;
user=&gt; (println message)
Hello world
nil
</pre>

<p>Vytvoøení globálních promìnných <strong>x</strong> a <strong>y</strong>
s&nbsp;jejich inicializací pomocí èíselného literálu. Posléze se vytvoøí tøetí
globální promìnná nazvaná <strong>answer</strong> a naplní se výsledkem
vyhodnocené formy <strong>(* x y)</strong>. Následnì je hodnota globální
promìnné <strong>answer</strong> vyti¹tìna, proto¾e jméno promìnné se v¾dy
vyhodnotí na její hodnotu:</p>

<pre>
user=&gt; (def x 6)
#'user/x
&nbsp;
user=&gt; (def y 7)
#'user/y
&nbsp;
user=&gt; (def answer (* x y))
#'user/answer
&nbsp;
user=&gt; answer
42
</pre>

<p>Jak jsme se ji¾ øekli <a href="#k02">v&nbsp;úvodním odstavci této
kapitoly</a>, je mo¾né ke globální promìnné pøiøadit i takzvaný <i>dokumentaèní
øetìzec</i>:</p>

<pre>
user=&gt; (def answer "Odpoved na otazku o ... vesmiru, zivote a vubec" 42)
#'user/answer
</pre>

<p>Tento dokumentaèní øetìzec lze kdykoli zobrazit s&nbsp;vyu¾itím makra
<strong>doc</strong>:</p>

<pre>
user=&gt; (doc answer)
-------------------------
user/answer
  Odpoved na otazku o ... vesmiru, zivote a vubec
</pre>

<p>Bli¾¹í informace o tomto makru podá samozøejmì pøíkaz:</p>

<pre>
(doc doc)
-------------------------
clojure.repl/doc
([name])
Macro
  Prints documentation for a var or special form given its name
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Jmenné prostory</h2>

<p><a href="#k02">V&nbsp;pøedchozí kapitole</a> jsme se poprvé explicitnì
zmínili o takzvaných <i>jmenných prostorech</i>. Jmenné prostory byly do
programovacího jazyka Clojure pøidány zejména z&nbsp;toho dùvodu, ¾e pou¾ití
globálních symbolù je v&nbsp;reálných programech velmi nebezpeèné a to zejména
proto, ¾e jiná èást programu, která mù¾e být klidnì vytvoøena i jiným
vývojáøem, mù¾e nechtìnì pøedeklarovat ji¾ existující globální symbol. Co je
je¹tì hor¹í &ndash; tato pøedeklarace nemusí nutnì vést k&nbsp;okam¾ité chybì
pøi práci s&nbsp;programem (ideálnì pøi jeho testování), ale mù¾e se projevit
a¾ pøi urèité shodì okolností &ndash; podle v¹eobecnì platného zákona tedy ve
chvíli, kdy se aplikace pøedvádí ¹éfovi èi zákazníkovi :-). Pøipomeòme si, ¾e
mezi globální symboly patøí i symboly pøedstavující jména funkcí, tak¾e je asi
pøedstavitelné, co by se stalo, kdyby nìjaká importovaná knihovna náhodou
obsahovala funkci pojmenovanou stejnì, jako funkce vytvoøená programátorem
vyvíjené aplikace. Jmenné prostory proto pøedstavují jeden z&nbsp;mo¾ných
zpùsobù, jak tento problém pomìrnì elegantnì vyøe¹it.</p>

<p>My jsme se ji¾ vlastnì s&nbsp;jedním jmenným prostorem setkali
v&nbsp;textech vypisovaných smyèkou <i>REPL</i>, i kdy¾ jsme si prozatím
nevysvìtlili, ¾e se skuteènì jedná o jmenný symbol. Pøi pou¾ívání smyèky REPL
je toti¾ jméno aktuálního jmenného prostoru vypisováno jako souèást <i>výzvy
(prompt)</i>:</p>

<pre>
user=&gt;
</pre>

<p>V&nbsp;programovacím jazyku Clojure je mo¾né vytvoøit takøka libovolný poèet
jmenných prostorù a posléze se mezi tìmito jmennými prostory pøepínat,
tj.&nbsp;lze zvolit, který jmenný prostor bude jmenným prostorem aktuálním. Pro
tuto èinnost se pou¾ívá makro nazvané <strong>ns</strong>:</p>

<pre>
(ns název_jmenného_prostoru)
</pre>

<p>Podívejme se nyní na jednoduchý demonstraèní pøíklad, v&nbsp;nìm¾ jsou
vytvoøeny dvì globální promìnné nazvané <strong>answer</strong>. Ka¾dé promìnné
je pøiøazena jiná hodnota a ka¾dá promìnná tudí¾ musí být ulo¾ena v&nbsp;jiném
jmenném prostoru. Pov¹imnìte si takté¾ toho, jak se zmìní výzva (prompt) pøi
pøepnutí aktuálního jmenného prostoru:</p>

<pre>
; vytvoøení globální promìnné umístìné ve jmenném prostoru "user"
user=&gt; (def answer 42)
#'user/answer
&nbsp;
; jméno promìnné se vyhodnotí na hodnotu promìnné
user=&gt; answer
42
&nbsp;
; vytvoøení nového jmenného prostoru nazvaného "novy"
user=&gt; (ns novy)
nil
&nbsp;
; lze v tomto jmenném prostoru vyhodnotit (=najít) promìnnou answer?
novy=&gt; answer
CompilerException java.lang.RuntimeException: Unable to resolve symbol: answer
in this context, compiling:(NO_SOURCE_PATH:0)
&nbsp;
; vytvoøení nové globální promìnné ve jmenném prostoru "novy"
novy=&gt; (def answer "?")
#'novy/answer
&nbsp;
; její hodnotu nyní mù¾eme získat (vyhodnotit), ani¾ by do¹lo k chybì
novy=&gt; answer
"?"
&nbsp;
; pøepnutí jmenného prostoru
novy=&gt; (ns user)
nil
&nbsp;
; nyní je opìt viditelná první globální promìnná se jménem answer
user=&gt; answer
42
</pre>

<p>Ve skuteènosti v¹ak nejsou jednotlivé jmenné prostory od sebe izolovány,
tak¾e se mù¾eme odkazovat na symbol umístìný v&nbsp;jiném jmenném prostoru
pomocí zápisu <strong>jmenný_prostor/symbol</strong>. Ostatnì i kvùli podpoøe
tohoto zpùsobu zápisu není mo¾né pou¾ít znak / ve jménì ¾ádného symbolu (znaky
* èi - je v¹ak mo¾né pou¾ít, co¾ se takté¾ èasto dìje, proto¾e - se pou¾ívá pro
oddìlení jednotlivých slov v&nbsp;názvu symbolu a hvìzdièka je podle konvencí
pou¾ívána pro konstanty). Podívejme se nyní na zpùsob vyu¾ití zápisu
<strong>jmenný_prostor/symbol</strong>:</p>

<pre>
; pøepnutí jmenného prostoru
user=&gt; (ns user)
nil
&nbsp;
; promìnná z aktuálního jmenného prostoru
user=&gt; answer
42
&nbsp;
; promìnná z jiného jmenného prostoru
user=&gt; novy/answer
"?"
&nbsp;
; pøepnutí jmenného prostoru
user=&gt; (ns novy)
nil
&nbsp;
; promìnná z aktuálního jmenného prostoru
novy=&gt; answer
"?"
&nbsp;
; promìnná z aktuálního jmenného prostoru
novy=&gt; novy/answer
"?"
&nbsp;
; promìnná z jiného jmenného prostoru
novy=&gt; user/answer
42
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Role a vlastnosti funkcí ve funkcionálních programovacích jazycích</h2>

<p>V&nbsp;dne¹ním èlánku se budeme zabývat pøedev¹ím popisem tvorby
u¾ivatelských funkcí v&nbsp;programovacím jazyku Clojure. Pøipomeòme si, ¾e
Clojure patøí mezi funkcionální jazyky, které se kromì dal¹ích zajímavých
vlastností vyznaèují i tím, ¾e funkce jsou v&nbsp;nich zpracovávány prakticky
stejným zpùsobem, jako jiné hodnoty, napøíklad celá èísla èi øetìzce. Pro tuto
vlastnost funkcionálních programovacích jazykù se vìt¹inou pou¾ívá termín
<i>first-class functions</i>, ale ji¾ ménì èasto se vysvìtluje, co vlastnì
tento termín v&nbsp;daném programovacím jazyku znamená. Uka¾me si pro zaèátek,
jakým zpùsobem se vlastnì pracuje s&nbsp;bì¾nými <strong>hodnotami</strong>, a
to nikoli ve funkcionálním jazyku, ale v&nbsp;jazyku objektovì orientovaném
&ndash; v&nbsp;Javì. V&nbsp;následujícím demonstraèním pøíkladu je pou¾ita
celoèíselná <strong>hodnota</strong> 42, která je vyu¾ita hned nìkolika rùznými
zpùsoby:</p>

<pre>
public class Test {
&nbsp;
    int testMethod(int param) {
        // hodnotu je mo¾né ulo¾it do promìnné (navázat na jméno)
        int i = 42;
&nbsp;
        // hodnotu je mo¾né pou¾ít ve výrazu
        // (zde není na ¾ádné jméno navázána)
        int j = param * i * 42;
&nbsp;
        // hodnotu je mo¾né pøedat volané metodì (funkci)
        j += Math.max(42, param);
&nbsp;
        // hodnotu je mo¾né vrátit pøi ukonèení metody (funkce)
        return 42;
    }
&nbsp;
    public static void main(String[] args) {
        // hodnotu je mo¾né pøedat jako parametr metody (funkce)
        new Test().testMethod(42);
    }
}
</pre>

<p>Tento zpùsob práce s&nbsp;hodnotami mají prakticky v¹ichni programátoøi
za¾itý a vlastnì je vùbec nepøekvapuje. Ji¾ men¹í mno¾ství vývojáøù je v¹ak
seznámeno s&nbsp;tím, ¾e ve funkcionálních jazycích je mo¾né namísto slova
<strong>hodnota</strong> pou¾ít i slovo <strong>funkce</strong>, proto¾e funkce
jsou, jak ji¾ víme, v&nbsp;tìchto jazycích plnohodnotnými hodnotami.
S&nbsp;vìdomím toho, jak se s&nbsp;hodnotami zacházelo v&nbsp;pøedchozím
demonstraèním pøíkladu a toho, ¾e ve funkcionálních jazycích lze
s&nbsp;funkcemi pracovat stejnì jako s&nbsp;jinými hodnotami tedy lze øíci, ¾e
funkce mají mj.&nbsp;i tyto vlastnosti:</p>

<ol>

<li>Funkce mohou být vytvoøeny kdykoli v&nbsp;èase bìhu programu
(<i>runtime</i>). To, jak je funkce v&nbsp;<i>runtime</i> pøelo¾ena, je ji¾
interní zále¾itostí daného programovacího jazyka.</li>

<li>Funkce mohou být ulo¾eny do promìnné (resp.&nbsp;pøesnìji øeèeno navázány
na jméno promìnné) èi mohou být ulo¾eny do jakékoli datové struktury (seznam
funkcí, vektor funkcí atd.)</li>

<li>Funkce mohou být pøedány jako parametr do jiné funkce.</li>

<li>Funkce mù¾e být vrácena ve formì návratové hodnoty jiné funkce.</li>

<li>Jméno sice není souèástí funkce, ov¹em funkce mù¾e být na jméno (symbol)
navázána. Toto je pravdìpodobnì jedna z&nbsp;nejvíce matoucích vlastností
funkcionálních jazykù, proto¾e z&nbsp;jazykù procedurálních jsme zvyklí na to,
¾e funkce v¾dy <strong>má</strong> jméno, které je v&nbsp;naprosté vìt¹inì
pøípadù známé ji¾ v&nbsp;dobì pøekladu. U jazykù funkcionálních
(popø.&nbsp;jazykù hybridních) se v¹ak velmi èasto pou¾ívají funkce beze jména,
neboli <i>funkce anonymní</i>.</li>

</ol>



<p><a name="k05"></a></p>
<h2 id="k05">5. Vytvoøení u¾ivatelských funkcí</h2>

<p>Ji¾ známe alespoò základní vlastnosti funkcí v&nbsp;Clojure, jak se v¹ak
funkce v&nbsp;tomto programovacím jazyku skuteènì definují? Pro vytvoøení nové
bezejmenné (tj.&nbsp;anonymní) funkce se pou¾ívá speciální forma nazvaná
<strong>fn</strong>, které se v&nbsp;tom nejjednodu¹¹ím pøípadì pøedá vektor
obsahující jména parametrù, za ním¾ je uveden seznam, jen¾ pøedstavuje tìlo
funkce (znalci LISPu patrnì znají formu <strong>lambda</strong>, která má
podobný význam). Samozøejmì, ¾e v&nbsp;tìle funkce je mo¾né pou¾ít symbolická
jména jejích parametrù a návratovou hodnotou funkce je hodnota získaná
vyhodnocením tìla funkce. Speciální forma <strong>fn</strong> pøi pou¾ití ve
smyèce REPL vypí¹e øetìzec, který reprezentuje interní identifikátor funkce
&ndash; jinými slovy na tento øetìzec mù¾eme v&nbsp;naprosté vìt¹inì pøípadù
zapomenout, proto¾e se s&nbsp;ním pøímo nepracuje. Uka¾me si tedy zpùsob
deklarace funkce se dvìma parametry pojmenovanými <strong>x</strong> a
<strong>y</strong>, která vypoèítá a vrátí souèin tìchto parametrù:</p>

<pre>
user=&gt; (fn [x y] (* x y))
#&lt;user$eval46$fn__47 user$eval46$fn__47@1697b67&gt;
</pre>

<p>Co se vlastnì stalo? Vytvoøili jsme novou funkci, která v¹ak nebyla
pøiøazena k&nbsp;¾ádnému symbolu (tj.&nbsp;nebyla &bdquo;pojmenována&ldquo;)
ani jsme tuto funkci nikde nezavolali. Vý¹e uvedený zápis je tedy prakticky
stejnì u¾iteèný, jako prosté zapsání jakékoli hodnoty nebo symbolu na vstup
smyèky REPL. Pokud by se funkce mìla zavolat, lze pou¾ít nám ji¾ známý zápis ve
tvaru seznamu &ndash; ji¾ víme, ¾e prvním parametrem vyhodnocovaného seznamu
(není pøed ním apostrof!) je funkce a dal¹ími prvky pak parametry této
funkce:</p>

<pre>
user=&gt; ((fn [x y] (* x y)) 6 7)
42
</pre>

<p>Sice je pìkné, ¾e jsme dokázali funkci zavolat s&nbsp;pøedáním parametrù,
ov¹em mnohdy (ne v¾dy!) je nutné funkci &bdquo;pojmenovat&ldquo;, pøesnìji
øeèeno ji pøiøadit k&nbsp;symbolu. My vlastnì ji¾ víme, jak se to dìlá, proto¾e
funkce jsou hodnotami a pro pøiøazení symbolu k&nbsp;hodnotì se pou¾ívá
speciální forma <strong>def</strong>. Tudí¾ následující zápis je sice
zdlouhavý, ale zcela korektní:</p>

<pre>
user=&gt; (def multiply (fn [x y] (* x y)))
#'user/multiply
</pre>

<p>Pøedchozím pøíkazem jsme vytvoøili novou funkci a navázali ji na symbol,
tudí¾ do¹lo k&nbsp;jejímu pojmenování. Nyní je ji¾ mo¾né funkci zavolat
s&nbsp;vyu¾itím navázaného symbolu. Samozøejmì se zde opìt vyu¾ívá nám ji¾
známý zápis ve tvaru seznamu:</p>

<pre>
user=&gt; (multiply 7 8)
56
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Zjednodu¹ená deklarace funkcí, funkce s&nbsp;více aritami</h2>

<p>Vzhledem k&nbsp;tomu, ¾e se u¾ivatelské funkce v&nbsp;reálných programech
vytváøí a souèasnì i pojmenovávají velmi èasto, vznikla potøeba nahradit zápis
<strong>(def název (fn parametry (tìlo)))</strong> nìèím krat¹ím, ideálnì i
s&nbsp;pou¾itím men¹ího mno¾ství závorek. Pro tyto úèely vzniklo makro se
jménem <strong>defn</strong>, které se a¾ na malé detaily podobá LISPovskému
zápisu <strong>defun</strong>. Pøi pou¾ití makra <strong>defn</strong> se
v&nbsp;tom nejjednodu¹¹ím pøípadì pøedávají tøi parametry: název novì vytváøené
funkce, vektor obsahující jména parametrù funkce a koneènì seznam pøedstavující
tìlo této funkce. Na¹i funkci <strong>multiply</strong> tedy mù¾eme vytvoøit a
souèasnì i pojmenovat následujícím zpùsobem:</p>

<pre>
user=&gt; (defn multiply [x y] (* x y))
#'user/multiply
</pre>

<p>A ihned ji mù¾eme pou¾ít:</p>

<pre>
user=&gt; (multiply 6 7)
42
</pre>

<p>Zbývá jen dodat, ¾e novì vytvoøená funkce je polymorfní vzhledem
k&nbsp;typùm parametrù, proto¾e se její chování li¹í v&nbsp;závislosti na tom,
jaké hodnoty jsou funkci v&nbsp;èase bìhu programu pøedány. Uka¾me si to na
pøíkladech tøí typù numerických hodnot: celých èísel, zlomkù a hodnot typu
<strong>BigDecimal</strong>:</p>

<pre>
user=&gt; (multiply 6 7)
42
user=&gt; (multiply 1/2 1/3)
1/6
user=&gt; (multiply 10000000M 2000000M)
20000000000000M
user=&gt;
</pre>

<p>V&nbsp;programovacím jazyku Clojure lze vytváøet i funkce s&nbsp;promìnným
poètem parametrù (uká¾eme si pøí¹tì) a s&nbsp;promìnnou aritou. Jen pro
zajímavost se nyní podívejme na zpùsob, jakým se vytvoøí funkce
<strong>multiply</strong>, kterou lze volat s&nbsp;jedním parametrem, se dvìma
parametry popø.&nbsp;alternativnì se tøemi parametry. Tìlo této funkce je
poka¾dé odli¹né:</p>

<pre>
user=&gt; (defn multiply ([x] (* x x)) ([x y] (* x y)) ([x y z] (* x y z)))
#'user/multiply
</pre>

<p>Vý¹e popsaný zpùsob zápisu není moc èitelný, proto si je¹tì jednou funkci
<strong>multiply</strong> rozepí¹eme tak, jak je to v&nbsp;Clojure/LISPu
zvykem:</p>

<pre>
(defn multiply
    ([x]
     (* x x))
    ([x y]
     (* x y))
    ([x y z] (* x y z)))
</pre>

<p>Vidíme, ¾e vektor parametrù i tìla jednotlivých variant jsou ulo¾eny ve
zvlá¹tním seznamu.</p>

<p>Mù¾eme se pustit do testování:</p>

<pre>
; volání varianty funkce multiply s jedním parametrem
user=&gt; (multiply 6)
36
&nbsp;
; volání varianty funkce multiply se dvìma parametry
user=&gt; (multiply 6 7)
42
&nbsp;
; volání varianty funkce multiply se tøemi parametry
user=&gt; (multiply 6 7 8)
336
&nbsp;
; pou¾ití ètyø parametrù povede k chybì pøi pokusu o vyhodnocení formy
user=&gt; (multiply 6 7 8 9)
ArityException Wrong number of args (4) passed to: user$multiply  clojure.lang.A
Fn.throwArity (AFn.java:437)
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Programové smyèky ve funkcionálních jazycích? Nikoli, spí¹e rekurze!</h2>

<p>Dostáváme se k&nbsp;dal¹í, mo¾ná ponìkud kontroverzní vlastnosti
programovacího jazyka Clojure. Tento jazyk toti¾, podobnì jako mnohé dal¹í
programovací jazyky, preferuje rekurzi pøed masivním pou¾íváním programových
smyèek. Jsou pro to samozøejmì dobré dùvody, jak teoretické, tak i praktické
(opìt jde o paralelní výpoèty). Ve skuteènosti je v¹ak Clojure jazykem
orientovaným na praktické pou¾ití, tak¾e ve skuteènosti obsahuje
&bdquo;nefunkcionální&ldquo; smyèku <strong>while</strong> (samozøejmì nejde o
pøíkaz, ale v&nbsp;tomto pøípadì o makro), popø.&nbsp;o ryze
&bdquo;funkcionální&ldquo; makro <strong>for</strong> pou¾ívané pøi zpracování
seznamù. Toto makro je v¹estranné a souèasnì i velmi u¾iteèné, proto se
s&nbsp;ním pøí¹tì seznámíme podrobnìji. Vra»me se v¹ak k&nbsp;rekurzi.
V&nbsp;Clojure lze vìt¹inou pou¾ít pøímý zápis rekurze, tj.&nbsp;v&nbsp;tìle
vytváøené funkce se mù¾e objevit volání této funkce. Zcela typickým pøíkladem
rekurzivní funkce je funkce pro výpoèet faktoriálu, její¾ jednoduchá varianta
(neochránìná pøed v¹emi typy vstupù) mù¾e vypadat takto:</p>

<pre>
user=&gt; (defn fact [n] (if (&lt;= n 1) 1 (* n (fact (- n 1)))))
#'user/fact
</pre>

<p>Pokud jste se &ndash; stejnì jako já &ndash; ztratili v&nbsp;závorkách,
pou¾ijeme místo málo èitelného one-lineru strukturovanìj¹í zápis, kde je
zøejmé, jak je funkce vytvoøena:</p>

<pre>
(defn fact
    [n]
    (if (&lt;= n 1)
        1
        (* n (fact (- n 1)))))
</pre>

<p>Ihned mù¾eme provést jednoduchý test:</p>

<pre>
user=&gt; (fact 0)
0
user=&gt; (fact 1)
1
user=&gt; (fact 10)
3628800
</pre>

<p>Faktoriál se v¹ak nemusí poèítat pouze s&nbsp;celými èísly reprezentovanými
internì jako hodnoty typu <i>int</i>. Mù¾eme vyu¾ít i ji¾ vícekrát zmínìného
faktu, ¾e Clojure doká¾e provádìt výpoèty i s&nbsp;hodnotami, které
v&nbsp;programovacím jazyku Java odpovídají instancím tøíd
<i>java.math.BigInteger</i> a <i>java.math.BigDecimal</i>. Mù¾eme se napøíklad
pokusit vypoèítat 100!. Zde je ji¾ nutné v&nbsp;Clojure pou¾ít za konstantou
znak M, aby se výpoèet neprovádìl pouze s&nbsp;èísly typu <i>int</i>:</p>

<pre>
user=&gt; (fact 100M)
93326215443944152681699238856266700490715968264381621468592963895217599993229915
608941463976156518286253697920827223758251185210916864000000000000000000000000M
</pre>

<p>Pøíli¹nému nad¹ení nad tím, jak jednodu¹e nyní mù¾eme poèítat faktoriál
z&nbsp;libovolnì velkého èísla, v¹ak nepodléhejme, proto¾e napøíklad ji¾ pro
10000! dojde k&nbsp;nepøíjemnému pøekvapení:</p>

<pre>
user=&gt; (fact 10000M)
StackOverflowError   clojure.lang.PersistentHashMap$BitmapIndexedNode.index (Per
sistentHashMap.java:510)
</pre>

<p>Dùvodem vedoucím ke vzniku této chyby i zpùsobem její nápravy se budeme
zabývat v&nbsp;následující kapitole.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Mo¾né problémy s&nbsp;rekurzí a øe¹ení tìchto problémù &ndash; tail rekurze</h2>

<p>Dùvod, proè pøedchozí volání funkce <strong>fact</strong> skonèilo
s&nbsp;chybou, spoèívá v&nbsp;tom, ¾e do¹lo k&nbsp;pøeplnìní zásobníku pøi
rekurzivním volání. Na zásobník se toti¾ musí ukládat parametry pøedávané
volané funkci a takté¾ body návratu (zjednodu¹enì øeèeno návratové adresy). Aby
k&nbsp;pøeteèení zásobníku nedocházelo, mù¾eme na¹i funkci
<strong>fact</strong> upravit tak, aby se vyu¾ívalo takzvané <i>tail
rekurze</i>. Velmi zjednodu¹enì øeèeno je <i>tail rekurze</i> pou¾ita tehdy,
pokud je posledním pøíkazem nìjaké funkce pøíkaz pro rekurzivní volání té samé
funkce. V&nbsp;tomto pøípadì se nemusí na zásobník nic ukládat a namísto toho
se prostì provede skok. V&nbsp;Clojure se v¹ak musí <i>tail rekurze</i> zapsat
explicitnì, co¾ má své pøednosti i zápory (podle mì pøeva¾ují pøednosti,
proto¾e ji¾ ze zápisu programu je zcela zøejmé, kdy k&nbsp;<i>tail rekurzi</i>
skuteènì dojde).</p>

<p>Na základì informací, které jsme se dozvìdìli v&nbsp;pøedchozím textu, se
tedy pokusme upravit pùvodní èistì rekurzivní zpùsob zápisu funkce pro výpoèet
faktoriálu takovým zpùsobem, aby bylo mo¾né vyu¾ít tail rekurzi. Funkci je
nutné upravit tak, aby jejím posledním pøíkazem bylo opìt volání
<strong>fact</strong> &ndash; u pùvodní verze tomu tak nebylo, proto¾e
posledním pøíkazem bylo násobení. První pokus o úpravu spoèívá v&nbsp;zavedení
akumulátoru výsledku:</p>

<pre>
(defn fact
    [n acc]
    (if (&lt;= n 1)
        acc
        (fact (- n 1) (* acc n))))
</pre>

<p>Zápis mù¾eme zjednodu¹it náhradou <strong>(- n 1)</strong> za <strong>(dec
n)</strong>:</p>

<pre>
(defn fact
    [n acc]
    (if (&lt;= n 1)
        acc
        (fact (dec n) (* acc n))))
</pre>

<p>Ov¹em stále je zde jeden problém &ndash; z&nbsp;pùvodní funkce s&nbsp;jedním
parametrem se nyní stala funkce, jí¾ je nutné pøedávat i druhý parametr, který
navíc musí být nastavený na jednièku. Náprava je prostá a spoèívá
v&nbsp;pou¾ití funkce <strong>fact</strong> s&nbsp;volitelnou aritou
(popø.&nbsp;by bylo mo¾né vytvoøit pomocnou funkci, ov¹em mì se následující
zápis líbí více, proto¾e se zbyteènì nevytváøí pomocné funkce):</p>

<pre>
(defn fact
    ([n]
     (fact n 1))
    ([n acc]
     (if (&lt;= n 1)
         acc
         (fact (dec n) (* acc n)))))
</pre>

<p>Vý¹e uvedená funkce ji¾ mù¾e vyu¾ívat tail rekurze, ov¹em jak jsme si ji¾
øekli, je nutné tail rekurzi zapsat explicitnì. Proto i zde dojde k&nbsp;chybì
pøi pøeteèení zásobníku (na rozdíl od mnoha LISPù):</p>

<pre>
user=&gt; (fact 10000M)
StackOverflowError   clojure.lang.PersistentHashMap$BitmapIndexedNode.index (Per
sistentHashMap.java:510)
</pre>

<p>Explicitní zápis rekurze spoèívá ve vyu¾ití speciální formy
<strong>recur</strong>, která se zapí¹e pøesnì do místa, kde má k&nbsp;tail
rekurzi (=skoku) dojít:</p>

<pre>
(defn fact
    ([n]
     (fact n 1))
    ([n acc]
     (if (&lt;= n 1)
         acc
         (recur (dec n) (* acc n)))))
</pre>

<p>Pokud máte dostatek pamìti a trpìlivosti, mù¾ete zadat tento pøíkaz a
zjistit, zda dojde èi nedojde k&nbsp;pøeteèení zásobníku:</p>

<pre>
user=&gt; (fact 10000M)
</pre>

<p>Mohlo by se zdát, ¾e by pøekladaè programovacího jazyka Clojure snad bylo
mo¾né zmást a pou¾ít <strong>recur</strong> jako náhradu skoku kdekoli. Ve
skuteènosti si v¹ak pøekladaè hlídá, zda je <strong>recur</strong> pou¾ito
správnì:</p>

<pre>
(defn fact
    [n]
    (if (&lt;= n 1)
        1
        (* n (recur (- n 1)))))
CompilerException java.lang.UnsupportedOperationException: Can only recur from t
ail position, compiling:(NO_SOURCE_PATH:24)
</pre>

<div class="rs-box"><p>Pokud vám pou¾ití rekurze èi tail rekurze
z&nbsp;nìjakého dùvodu vadí, vìzte, ¾e ve skuteènì velkém mno¾ství pøípadù je
øe¹ením pou¾ití ji¾ zmínìného makra <strong>for</strong>, které si pøedstavíme
pøí¹tì.</p></div>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Clojure home page<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/">http://java.sun.com/developer/technicalArticles/DynTypeLang/</a>
</li>

<li>JSR 223: Scripting for the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=223">http://jcp.org/en/jsr/detail?id=223</a>
</li>

<li>JSR 292: Supporting Dynamically Typed Languages on the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=292">http://jcp.org/en/jsr/detail?id=292</a>
</li>

<li>Java 7: A complete invokedynamic example<br />
<a href="http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html">http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html</a>
</li>

<li>InvokeDynamic: Actually Useful?<br />
<a href="http://blog.headius.com/2007/01/invokedynamic-actually-useful.html">http://blog.headius.com/2007/01/invokedynamic-actually-useful.html</a>
</li>

<li>A First Taste of InvokeDynamic<br />
<a href="http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html">http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html</a>
</li>

<li>Java 6 try/finally compilation without jsr/ret<br />
<a href="http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html">http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Root.cz: Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM<br />
<a href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/</a></a>
</li>

<li>Root.cz: JamVM aneb alternativa k HotSpotu nejenom pro embedded zaøízení a chytré telefony<br />
<a href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>FindBugs<br />
<a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a>
</li>

<li>GNU Classpath<br />
<a href="www.gnu.org/s/classpath/">www.gnu.org/s/classpath/</a></li>

<li>Java VMs Compared<br />
<a href="http://bugblogger.com/java-vms-compared-160/">http://bugblogger.com/java-vms-compared-160/</a>
</li>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Scala Programming Language<br />
<a href="http://www.scala-lang.org/">http://www.scala-lang.org/</a>
</li>

<li>Run Scala in Apache Tomcat in 10 minutes<br />
<a href="http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes">http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes</a>
</li>

<li>Fast Web Development With Scala<br />
<a href="http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html">http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html</a>
</li>

<li>Top five scripting languages on the JVM<br />
<a href="http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855">http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>CloseableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html">http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

