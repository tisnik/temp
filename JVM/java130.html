<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - porovnání bajtkódu virtuálního stroje Javy s Lua a Pythonem</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - porovnání bajtkódu virtuálního stroje Javy s Lua a Pythonem</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyku Java i o virtuálním stroji Javy zaèneme porovnávat tøi vzájemnì rozdílné bajtkódy &ndash; bajtkód JVM, bajtkód vyu¾ívaný virtuálním strojem jazyka Lua a koneènì bajtkód, který je pou¾it Pythonem (pøesnìji øeèeno CPythonem).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - porovnání bajtkódu virtuálního stroje Javy s Lua a Pythonem</a></p>
<p><a href="#k02">2. Historie vývoje bajtkódu a jeho vyu¾ití</a></p>
<p><a href="#k03">3. Zásobníkové vs. registrové virtuální stroje</a></p>
<p><a href="#k04">4. Praktická ukázka rozdílu mezi bajtkódem urèeným pro zásobníkový a registrový VM</a></p>
<p><a href="#k05">5. Bajtkód virtuálního stroje jazyka Java (JVM)</a></p>
<p><a href="#k06">6. Pøíklady metod pøelo¾ených do bajtkódu JVM</a></p>
<p><a href="#k07">7. Bajtkód vyu¾ívaný jazykem Lua</a></p>
<p><a href="#k08">8. Pøíklady funkcí pøelo¾ených do bajtkódu jazyka Lua</a></p>
<p><a href="#k09">9. Bajtkód vyu¾ívaný jazykem Python</a></p>
<p><a href="#k10">10. Pøíklady funkcí pøelo¾ených do bajtkódu Pythonu</a></p>
<p><a href="#k11">11. Repositáø se zdrojovými kódy v¹ech tøí dne¹ních demonstraèních pøíkladù</a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - porovnání bajtkódu virtuálního stroje Javy s Lua a Pythonem</h2>

<p>V&nbsp;dne¹ní èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyku Java i o virtuálním stroji Javy</a> se, prozatím ov¹em bez
vìt¹ích podrobností, pokusíme o porovnání základních vlastností bajtkódu JVM
s&nbsp;dal¹ími dnes èasto pou¾ívanými bajtkódy, zejména s&nbsp;bajtkódy
vyu¾ívanými virtuálními stroji jazykù Lua a Python. Toto porovnání sice mù¾e
vypadat ponìkud odta¾itì od dennodenní programátorské praxe, ve skuteènosti se
ov¹em ukazuje, ¾e zvolený bajtkód (formát instrukcí, podporované datové typy
atd.) daného virtuálního stroje do znaèné míry urèuje a nìkdy takté¾ omezuje
vlastnosti programovacích jazykù, jejich¾ pøekladaèe jsou nad daným bajtkódem
postaveny. To platí ve velké míøe takté¾ pro programovací jazyk Java &ndash;
týká se to jak komplikací pøi implementaci nových sémantických prvkù do Javy
(lambda výrazy a obecnì funkce jako plnohodnotný datový typ), tak i takových
zdánlivých &bdquo;malièkostí&ldquo;, jako je neuzavøenost aritmetických operací
nad celoèíselnými datovými typy <strong>byte</strong> a
<strong>short</strong>.</p>

<p>Nejprve se v¹ak ve struènosti seznámíme s&nbsp;historií pou¾ívání bajtkódu,
která je pomìrnì dlouhá a pøitom i z&nbsp;programátorského hlediska zajímavá,
proto¾e úspìch mnoha programovacích jazykù vycházel mj.&nbsp;i z&nbsp;toho, ¾e
se díky pou¾ití bajtkódù (a s&nbsp;nimi souvisejících virtuálních strojù) mohly
jejich pøekladaèe snadno a relativnì rychle roz¹iøovat na rùzné platformy a
architektury poèítaèù (a to se v&nbsp;¾ádném pøípadì netýká pouze Javy, ale
døíve napøíklad i Pascalu èi BPCL, co¾ je pradávný pøedchùdce rodiny jazykù C a
C++).</p>

<p>Bajtkód je vyu¾íván pøedev¹ím dvìma nástroji. Na jedné stranì se jedná o
pøekladaè (napøíklad v&nbsp;pøípadì Javy to mù¾e být pøekladaè
<strong>javac</strong>, API tohoto pøekladaèe dostupné v&nbsp;moderních JDK èi
interní pøekladaè vyu¾ívaný nìjakým integrovaným vývojovým prostøedím), který
pøekládá zdrojový kód napsaný programátorem (èi poloautomaticky vygenerovaný
v&nbsp;IDE :-) do bajtkódu; co¾ mj.&nbsp;znamená, ¾e je pøeklad zcela nezávislý
na pou¾ité platformì. Na stranì druhé ji¾ jednou pøelo¾ený bajtkód vyu¾ívá
interpret èi dnes ji¾ v&nbsp;mnoha pøípadech spí¹e JIT (<i>just in time</i>)
pøekladaè. Ve skuteènosti v¹ak s&nbsp;bajtkódem mù¾e pracovat i mnoho dal¹ích
nástrojù. Pøíkladem ve svìtì Javy a bajtkódu JVM mohou být napøíklad nástroje
typu <i>Cobertura</i> a <i>EMMA</i> slou¾ící pro zji¹tìní, které èásti
zdrojového kódu aplikací jsou pokryty (jednotkovými) testy. Tyto nástroje musí
umìt dobøe kooperovat s&nbsp;virtuálním strojem Javy, proto nejprve modifikují
bajtkódy testovaných tøíd, aby bylo mo¾né pøi bìhu testù dynamicky zjistit,
které øádky kódu jsou skuteènì z&nbsp;testù volány.</p>

<p>Podobným zpùsobem je bajtkód modifikován nástroji podporujícími aspektovì
orientované programování (<i>aspect oriented programming</i>), které takté¾
mohou zasahovat do bajtkódu vygenerovaného pøekladaèem. Teoreticky je sice
mo¾né pøi pou¾ití aspektovì orientovaného programování transformovat pøímo
zdrojové kódy programù (co¾ je pou¾ito pøedev¹ím v&nbsp;jiných programovacích
jazycích), ale transformace bajtkódu je v&nbsp;pøípadì Javy mnohem snaz¹í. Ze
stejného dùvodu (analýza bajtkódu je jednodu¹¹í ne¾ analýza zdrojového textu)
je bajtkód pou¾it pro statickou analýzu a hledání potenciálních chyb nástrojem
<i>FindBugs</i>.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Historie vývoje bajtkódu a jeho vyu¾ití</h2>

<p>My¹lenka na vyu¾ití bajtkódu pro pøeklad a následnou interpretaci programù
je v&nbsp;informatice úspì¹nì vyu¾ívána pomìrnì dlouho. Jedním z&nbsp;prvních
známých a roz¹íøených bajtkódù byl <strong>OPCODE</strong>, který byl vyvinut
pro potøeby programovacího jazyka <strong>BCPL</strong>. Jazyk
<strong>BPCL</strong> (<i>Basic Combined Programming Language</i>), jen¾ byl
vytvoøen Martinem Richardsem ji¾ v&nbsp;roce 1966, je z&nbsp;hlediska historie
IT dùle¾itý pøedev¹ím proto, ¾e z&nbsp;nìho Ken Thompson odvodil nový
programovací jazyk nazvaný jednodu¹e <strong>B</strong> a z&nbsp;jazyka
<strong>B</strong> se postupnì vyvinulo klasické Céèko (nejdøíve K&amp;R C a
posléze dodnes pou¾ívané ANSI/ISO C). Bajtkód nazvaný <strong>OPCODE</strong>
byl zalo¾en na instrukcích pracujících se zásobníkem operandù a v&nbsp;práci
s&nbsp;daty dostupnými pøes indexové registry. Napøíklad výraz <strong>x / y +
z</strong> se pro promìnné <strong>x</strong>, <strong>y</strong> a
<strong>z</strong> ulo¾ené na pozicích 1, 2 a 10 pøelo¾il do bajtkódu
<strong>OPCODE</strong> následujícím zpùsobem, který se nápadnì podobá bajtkódu
JVM (co¾ ostatnì není náhoda, jak si øekneme dále):</p>

<pre>
LP   1
LP   2
DIV
LP   10
PLUS
</pre>

<p>Popularita pou¾ívání bajtkódu byla úzce spojena i s&nbsp;úspì¹ností
takzvaného <strong>p-code</strong>, co¾ byl (a ostatnì stále je¹tì je) bajtkód
vyu¾ívaný nìkterými pøekladaèi programovacího jazyka Pascal (to se ov¹em netýká
Turbo Pascalu). Díky vyu¾ití <strong>p-code</strong> bylo snadnìj¹í portovat
jak pøekladaè Pascalu na rùzné platformy, tak i interpret vlastního p-kódu.
Tento bajtkód je v&nbsp;souèasnosti je¹tì vyu¾íván na nìkterých ¹kolách pøi
výuce IT; mj.&nbsp;i z&nbsp;tohoto dùvodu se jedná o stále ¾ivý projekt, o èem¾
ostatnì mohou svìdèit i stránky projektu UCSD p-system Virtual Machine dostupné
na adrese <a
href="http://ucsd-psystem-vm.sourceforge.net/">http://ucsd-psystem-vm.sourceforge.net/</a>.
Dále je vhodné zmínit bajtkód vyu¾ívaný <i>Smalltalkem</i>. Jedná se o pomìrnì
vysokoúrovòový bajtkód, který se v&nbsp;nìkterých ohledech pøibli¾uje bajtkódu
pou¾ívaném Pythonem (posílání zpráv je v&nbsp;tomto pøípadì velmi podobné
volání virtuálních metod apod.). Mimochodem &ndash; velká èást bajtkódu
<i>Smalltalku</i> je reflexivnì dostupná i z&nbsp;vlastního jazyka, viz
napøíklad <a
href="http://marianopeck.files.wordpress.com/2011/05/screen-shot-2011-05-21-at-6-51-24-pm.png">http://marianopeck.files.wordpress.com/2011/05/screen-shot-2011-05-21-at-6-51-24-pm.png</a>.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zásobníkové vs. registrové virtuální stroje</h2>

<p>Vyu¾ívání bajtkódù má v&nbsp;souèasnosti za sebou zhruba ètyøicet let
postupného vývoje, tak¾e není divu, ¾e za tuto pomìrnì dlouhou dobu bylo
navr¾eno a implementováno mnoho rùzných øe¹ení virtuálního stroje+bajtkódu,
která se od sebe v&nbsp;mnoha ohledech odli¹ovala, a to jak úrovní abstrakce
bajtkódu (nízkoúrovòové instrukce dobøe transformovatelné na strojový kód vs.
vysokoúrovòové instrukce podporující napøíklad polymorfismus vyu¾ívaný
napøíklad virtuálním strojem Pythonu), tak i zpùsobem, jakým jednotlivé
instrukce pracovaly s&nbsp;argumenty. Naprostou vìt¹inu existujících a
v&nbsp;souèasnosti pou¾ívaných bajtkódù lze rozdìlit do dvou skupin.
V&nbsp;první skupinì se nachází bajtkódy zpracovávané virtuálními stroji
zalo¾enými na zásobníku operandù (<i>operand stack</i>) a v&nbsp;druhé skupinì
se nachází bajtkódy vyu¾ívající sadu registrù (<i>register set</i>) nabízených
virtuálním strojem. Oba pøístupy mají své pøednosti i zápory a takté¾ skalní
zastánce i odpùrce, jak je tomu ostatnì v&nbsp;IT dobrým zvykem :-)</p>

<p>Bajtkódy a virtuální stroje vyu¾ívající zásobník operandù a instrukce pro
práci s&nbsp;argumenty ulo¾enými na tomto zásobníku vìt¹inou obsahují mnoho
bezparametrických instrukcí, jejich¾ operaèní kódy tak mohou být velmi krátké a
typicky bývají ulo¾eny v&nbsp;jednom bajtu (z&nbsp;toho také ostatnì oznaèení
&bdquo;bajtkód&ldquo; vychází). Interpretace takového bajtkódu bývá velmi
jednoduchá a lze ji efektivnì provádìt i na tìch mikroprocesorech, které
obsahují velmi malé mno¾ství pracovních registrù, z&nbsp;èeho¾ ostatnì vyplývá
i oblíbenost takto navr¾ených bajtkódù v&nbsp;dobì osmibitových mikroprocesorù
a mikroøadièù (ponìkud speciálním pøípadem je jazyk <i>Forth</i>). Pøed
pøibli¾nì deseti lety, kdy se ve vìt¹í míøe zaèaly roz¹iøovat JIT pøekladaèe,
se pøedpokládalo, ¾e nové JIT pøekladaèe budou mít problémy s&nbsp;pøekladem
instrukcí zalo¾ených na pou¾ití zásobníku operandù do strojového kódu moderních
mikroprocesorù (ty mají vìt¹inou velkou sadu pracovních registrù), ov¹em
ukázalo se, ¾e JIT doká¾í bez vìt¹ích problémù pracovat jak se zásobníkovými
instrukcemi, tak i s&nbsp;instrukcemi vyu¾ívajícími sadu pracovních registrù
VM.</p>

<p>Tím se pomalu dostáváme ke druhému roz¹íøenému typu bajtkódù. Jedná se o
bajtkódy, jejich¾ instrukce doká¾ou pracovat s&nbsp;obsahem mno¾iny pracovních
registrù zvoleného virtuálního stroje. Délka instrukèního slova i mo¾nosti
takto navr¾ených bajtkódù závisí pøedev¹ím na poètu tìchto pracovních registrù;
v&nbsp;moderních VM se setkáme minimálnì s&nbsp;pou¾itím ¹estnácti èi 32
registry, co¾ znamená, ¾e mnoho instrukcí má délku minimálnì dva bajty, mnohdy
i tøi èi ètyøi bajty. Li¹í se takté¾ poèet operandù instrukcí &ndash; nìkteré
bajtkódy vyu¾ívají takzvaný dvouadresový kód (pou¾ívají dva registry &ndash;
jeden registr zdrojový a druhý registr souèasnì zdrojový i cílový), jiné se
zamìøují na tøíadresový kód (dva zdrojové registry a jeden registr cílový).
Zpùsob interpretace takto navr¾ených bajtkódù mù¾e být problematiètìj¹í
v&nbsp;pøípadì, ¾e mikroprocesor, na nìm¾ interpret bì¾í, obsahuje men¹í
mno¾ství fyzických pracovních registrù, ov¹em (jak ji¾ bylo øeèeno
v&nbsp;pøedchozím odstavci), pøi pou¾ití JIT se rozdíly mezi obìma zpùsoby
práce s&nbsp;operandy do znaèné míry rozostøují.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Praktická ukázka rozdílu mezi bajtkódem urèeným pro zásobníkový a registrový VM</h2>

<p>Podívejme se nyní na dvì ukázky, jak se mù¾e li¹it bajtkód zalo¾ený na
zásobníkovém virtuálním stroji od bajtkódu, který je urèen pro registrový
virtuální stroj. V&nbsp;obou pøíkladech se má vyhodnotit jednoduchý výraz
<strong>result = a+b*c-d</strong>; pro jednoduchost pøedpokládejme, ¾e v¹ech
pìt promìnných je lokálních a souèasnì mají typ celé èíslo (integer). Zpùsob
pøekladu do bajtkódu vyu¾ívajícího zásobník operandù (konkrétnì je pou¾it
bajtkód JVM) mù¾e vypadat následovnì:</p>

<pre>
              <i>; 0 je index promìnné <strong>a</strong></i>
              <i>; 1 je index promìnné <strong>b</strong></i>
              <i>; 2 je index promìnné <strong>c</strong></i>
              <i>; 3 je index promìnné <strong>d</strong></i>
              <i>; 4 je index promìnné <strong>result</strong></i>
0: iload  0   <i>; ulo¾ení obsahu promìnné <strong>a</strong> na zásobník</i>
1: iload  1   <i>; ulo¾ení obsahu promìnné <strong>b</strong> na zásobník</i>
2: iload  2   <i>; ulo¾ení obsahu promìnné <strong>c</strong> na zásobník</i>
3: imul       <i>; provedení operace <strong>b*c</strong>, výsledek je ponechán na zásobníku</i>
4: iadd       <i>; provedení operace <strong>a+(b*c)</strong></i>
5: iload  3   <i>; ulo¾ení obsahu promìnné <strong>d</strong> na zásobník</i>
6: isub       <i>; dokonèit pøíkaz <strong>a+(b*c)+d</strong></i>
7: istore 4   <i>; ulo¾ení výsledku z TOS (obsah zásobníku operandù) do promìnné <strong>result</strong></i>
</pre>

<p>Pøíklad kompilace tého¾ pøíkazu <strong>result = a+b*c-d</strong> do
bajtkódu vyu¾ívajícího pracovní registry, konkrétnì do bajtkódu vyu¾ívaného
programovacím jazykem Lua:</p>

<pre>
                               <i>; 0 je index promìnné <strong>a</strong></i>
                               <i>; 1 je index promìnné <strong>b</strong></i>
                               <i>; 2 je index promìnné <strong>c</strong></i>
                               <i>; 3 je index promìnné <strong>d</strong></i>
                               <i>; 4 je index promìnné <strong>result</strong></i>
1       [101]   MUL    4 1 2   <i>; pøímé vynásobení obsahu promìnných <strong>b</strong> a <strong>c</strong></i>
2       [101]   ADD    4 0 4   <i>; pøièíst k obsahu promìnné <strong>a</strong> mezivýsledek, výsledek ulo¾it do promìnné <strong>result</strong></i>
3       [101]   SUB    4 4 3   <i>; odeèíst od mezivýsledku obsah promìnné <strong>b</strong>, výsledek ulo¾it do promìnné <strong>result</strong></i>
</pre>

<p>Ve druhém pøípadì se nemusely vùbec pou¾ít instrukce pro ulo¾ení promìnných
na zásobník ani pro naètení hodnoty zpìt ze zásobníku operandù do promìnné,
ov¹em na druhou stranu musely mít v¹echny aritmetické instrukce
v&nbsp;instrukèním slovu ulo¾eny i indexy operandù.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Bajtkód virtuálního stroje jazyka Java (JVM)</h2>

<p>První typ v&nbsp;souèasnosti pou¾ívaného bajtkódu, s&nbsp;ním¾ se ve
struènosti seznámíme, je bajtkód vyu¾ívaný JVM. Virtuální stroj jazyka Java
samozøejmì vyu¾ívá jiný soubor &bdquo;strojových&ldquo; instrukcí, ne¾ fyzický
mikroprocesor, na nìm¾ jsou Javovské programy spou¹tìny. Dokonce ani
mikroprocesory urèené pro pøímé spou¹tìní bajtkódu &ndash; dnes ji¾ zpola
zapomenuté projekty <i>MicroJava</i> a <i>PicoJava</i>, dokonce i ARM procesory
s&nbsp;technologií <i>Jazelle</i> &ndash; nedokázaly nativnì vykonávat v¹echny
instrukce bajtkódu. V&nbsp;prvních nìkolika letech existence Javy byly
instrukce bajtkódu (tvoøící tìla jednotlivých metod) v&nbsp;naprosté vìt¹inì
pøípadù pouze interpretovány, a to mnohdy velmi jednoduchým zpùsobem:
v&nbsp;programové smyèce se postupnì naèítaly kódy jednotlivých instrukcí a
následnì se pro ka¾dou instrukci zavolala nativní funkce, která danou instrukci
vykonala, vìt¹inou s&nbsp;parametry ulo¾enými v&nbsp;zásobníkovém rámci nebo
v&nbsp;zásobníku operandù (bli¾¹í popis bude uveden v&nbsp;následujících
kapitolách).</p>

<p>Naprogramování naivního interpretru pro bajtkód virtuálního stroje Javy není
pøíli¹ slo¾ité, proto¾e samotná instrukèní sada je pomìrnì jednoduchá. Moderní
interpretry, napøíklad ji¾ v&nbsp;tomto seriálu popsaný <a
href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">JamVM</a>,
jsou navíc naprogramovány takovým zpùsobem, aby byl jejich pøenos na dal¹í
procesorové architektury snadný a pøitom se bajtkód interpretoval co
nejefektivnìj¹ím zpùsobem, ideálnì s&nbsp;ruènì optimalizovanou vnitøní smyèkou
(naprogramovanou v&nbsp;pøípadì ruènì provádìných optimalizací vìt¹inou
assembleru).</p>

<p>Ov¹em i pøes ve¹kerou snahu programátorù interpretrù nemù¾e bìh programù
napsaných v&nbsp;Javì a spou¹tìných v&nbsp;JVM s&nbsp;interpretovaným bajtkódem
v&nbsp;rychlosti soutì¾it s&nbsp;nativními aplikacemi. Právì z&nbsp;tohoto
dùvodu vznikly takzvané <i>just-in-time (JIT)</i> pøekladaèe, které doká¾ou
pøelo¾it buï jen urèitou sekvenci instrukcí JVM nebo i celý bajtkód do
nativního strojového kódu, který je následnì spu¹tìn. Nìkteré JIT pøekladaèe,
napøíklad stále populární <i>HotSpot</i> pùvodnì vyvinutý spoleèností Sun
Microsystems, pou¾ívají <i>adaptivní pøeklad</i>, v&nbsp;nìm¾ je bajtkód
analyzován v&nbsp;dobì bìhu, tak¾e má JIT pøekladaè k&nbsp;dispozici mnohem
více informací, ne¾ pøi statickém pøekladu. <i>HotSpot</i> navíc umo¾òuje
pomocí takzvaný sond (<i>probes</i> sledovat, který kód je pøekládán a jaký typ
pøekladu je pøitom pou¾it, to je v¹ak ji¾ pomìrnì pokroèilá a nepøíli¹ èasto
pou¾ívaná technologie. Ov¹em nezávisle na tom, zda jsou instrukce JVM
&bdquo;pouze&ldquo; interpretovány, nebo je nejdøíve pou¾it <i>JIT</i>, musí
být v¾dy dodr¾eny v¹echny vlastnosti jazyka Java i JVM. <i>JIT</i> napøíklad
mù¾e odstranit kontrolu mezí pøi indexování polí, ale jen tehdy, kdy¾ je
zøejmé, ¾e nedojde k&nbsp;pøekroèení tìchto mezí.</p>

<p>V&nbsp;této kapitole si ve struènosti pøipomeneme základní vlastnosti
bajtkódu virtuálního stroje Javy. Struktura i vlastnosti JVM jsou pøesnì
popsány ve specifikaci JVM, vèetnì pøesného formátu v¹ech datových typù (znakù,
celých èísel, èísel s&nbsp;plovoucí øádovou teèkou). Díky dodr¾ování této
specifikace rùznými výrobci virtuálního stroje Javy je zaruèeno, ¾e programy
napsané v&nbsp;Javì jsou pøenositelné na poèítaèe s&nbsp;mnohdy velmi rozdílnou
architekturou: od smartphonù s&nbsp;jednojádrovými mikroprocesory a¾ po
superpoèítaèe s&nbsp;velkým mno¾stvím výpoèetních uzlù a mnohdy s&nbsp;nìkolika
desítkami tisíc procesorových jader. Rùzné nekompatibility, s&nbsp;nimi¾
programátoøi bojovali pøedev¹ím v&nbsp;minulosti (ale samozøejmì i dnes, i kdy¾
v&nbsp;mnohem men¹í míøe), bývají zpùsobeny buï chybami v&nbsp;implementaci
nìkterého virtuálního stroje (a nedodr¾ení specifikace lze pova¾ovat za chybu)
èi nekompatibilitami ve standardních knihovnách, popø.&nbsp;chybami
v&nbsp;nativních knihovnách, které lze z&nbsp;JVM volat.</p>

<p>Specifikace virtuálního stroje Javy popisuje nìkteré jeho èásti velmi
preciznì (napøíklad se jedná o ji¾ zmínìné datové typy èi o formát instrukcí
nebo o strukturu zásobníkového rámce), ov¹em u nìkterých dal¹ích èástí jsou
popsány jen základní vlastnosti a zùstává pouze na tvùrci konkrétní JVM, jakým
zpùsobem se bude daná èást virtuálního stroje ve skuteènosti implementovat. Asi
nejtypiètìj¹ím pøíkladem je specifikace haldy (<i>heap</i>), u ní¾ se sice
pøedpokládá vyu¾ití automatické správy pamìti, ale nikde ji¾ není øeèeno, jaký
konkrétní algoritmus správy pamìti se má pou¾ít (v&nbsp;souèasnosti se vyu¾ívá
hned nìkolik algoritmù) ani jaký formát má být pou¾it pro ukládání referencí na
objekty. Díky tomu bylo mo¾né Javu jednodu¹e pøenést z&nbsp;pùvodní 32bitové
architektury jak na 16bitové procesory, tak i na procesory pracující
s&nbsp;64bitovými ukazateli (u nich¾ lze navíc v&nbsp;pøípadì potøeby vyu¾ít i
<a
href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">komprimované
ukazatele na objekty</a>) &ndash; to v¹e bez nutnosti zásahu do zdrojových kódù
Javovských programù i bez nutnosti jejich rekompilace.</p>

<p>Virtuální stroj jazyka Java obsahuje instrukce, které pracují
s&nbsp;operandy nìkolika datových typù. Na rozdíl od mnoha fyzických procesorù
se v&nbsp;pøípadì JVM provádí kontroly, zda jsou operace skuteènì aplikovány na
správné operandy. Není napøíklad mo¾né, aby se operace souètu provádìla
s&nbsp;jedním operandem typu <strong>int</strong> a druhým operandem typu
<strong>long</strong> &ndash; takový bajtkód by byl pøi svém naèítání odmítnut
a vùbec by nebyl spu¹tìn (to v¹ak jinými slovy znamená, ¾e bajtkód je zbyteènì
redundantní, zejména v&nbsp;porovnání s&nbsp;bajtkódy jazykù Lua a Python).
Zajímavé je, ¾e jen velmi málo instrukcí JVM podporuje práci s&nbsp;datovými
typy <strong>boolean</strong>, <strong>byte</strong>, <strong>short</strong> a
<strong>char</strong>. Promìnné a parametry metod tìchto typù musí být
napøíklad pøed provedením nìkteré aritmetické operace nejprve pøevedeny na typ
<strong>int</strong> pomocí konverzních instrukcí (tìch existuje celkem
patnáct).</p>

<p>Vìt¹ina instrukcí virtuálního stroje Javy pracuje s&nbsp;operandy ulo¾enými
na takzvaném <i>zásobníku operandù (operand stack)</i>. Zásobník operandù
(v&nbsp;tomto pøípadì se ji¾ jedná o skuteèný zásobník typu <i>LIFO &ndash;
Last In, First Out</i>) je vytváøen v&nbsp;èase bìhu aplikace pro ka¾dou
zavolanou metodu, co¾ mj.&nbsp;znamená, ¾e je pøi spu¹tìní metody v¾dy prázdný
(zásobník operandù je podle specifikace souèástí zásobníkového rámce, jeho
konkrétní umístìní v¹ak je libovolné). Ji¾ v&nbsp;èase pøekladu zdrojového kódu
je pro ka¾dou metodu zji¹tìno, jak velká oblast pamìti má být pro zásobník
operandù vyhrazena a samozøejmì je provádìna kontrola, zda se v&nbsp;dobì bìhu
aplikace tato velikost nepøekroèí (to by se nemìlo u validního bajtkódu
stát).</p>

<p>Virtuální stroj Javy kontroluje typy operandù ulo¾ených na zásobník operandù
a zaji¹»uje, ¾e se nad tìmito operandy budou provádìt pouze typovì bezpeèné
operace. V&nbsp;praxi to napøíklad znamená, ¾e není mo¾né na zásobník ulo¾it
dvì hodnoty typu <strong>float</strong> a následnì provést instrukci
<strong>iadd</strong>, proto¾e tato instrukce vy¾aduje, aby na zásobníku byly
ulo¾eny dvì hodnoty typu <strong>int</strong> (i kdy¾ <strong>float</strong> i
<strong>int</strong> mají shodnou bitovou ¹íøku).</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Pøíklady metod pøelo¾ených do bajtkódu JVM</h2>

<p>Základní vlastnosti bajtkódu virtuálního stroje Javy si uká¾eme na zpùsobu
pøekladu testovací tøídy obsahující nìkolik statických metod. Tím, ¾e jsou
v¹echny testované metody statické, je zaji¹tìno, ¾e se jim nebude pøedávat
dal¹í (ve zdrojovém kódu skrytý) parametr <strong>this</strong>, jiný
významnìj¹í rozdíl mezi statickými a nestatickými metodami v&nbsp;bajtkódu
nenajdeme. První dvì metody <strong>nop1()</strong> a <strong>nop2()</strong>
jsou bezparametrické, mají prázdné tìlo a nevrací ¾ádnou hodnotu, tak¾e lze
pøedpokládat, ¾e jejich bajtkód bude velmi jednoduchý. Dal¹í metoda, která se
jmenuje <strong>answer()</strong>, je takté¾ bezparametrická, ale vrací
konstantní celoèíselnou hodnotu 42. Následuje pøetí¾ená metoda
<strong>add()</strong>, její¾ jednotlivé varianty akceptují rùzné celoèíselné i
reálné hodnoty; poslední varianta této metody spojuje øetìzce (a to stejným
operátorem +). Na pøíkladu metod <strong>add()</strong> si pov¹imnìte toho, ¾e
operace + není pro datové typy <strong>byte</strong> a <strong>short</strong>
uzavøena (výsledkem je hodnota typu <strong>int</strong>), co¾ vychází
z&nbsp;vlastností bajtkódu. Ostatnì ani dal¹í aritmetické operace pro tyto
datové typy takté¾ nejsou uzavøeny.</p>

<p>Následuje dal¹í testovací metoda pojmenovaná <strong>isNegative()</strong>
obsahující podmínìný pøíkaz. Ten by zde ve skuteènosti nemusel být uveden,
nebo» celé tìlo metody lze zkrátit do jediného výrazu, jeho¾ výsledek by byl
vracen pøíkazem <strong>return</strong>, ov¹em my potøebujeme zjistit, jakým
zpùsobem se do bajtkódu JVM pøekládají konstrukce typu
<strong>if-then-else</strong>. Ve zdrojovém kódu metody
<strong>fibonacciIter()</strong> jsou pou¾ity jak podmínky, tak i poèítaná
programová smyèka typu <strong>for</strong> a v&nbsp;poslední testované metodì
<strong>fibonacciRecursive()</strong> je pou¾ita rekurze, tj.&nbsp;metoda pøímo
volá samu sebe. Podívejme se nyní na celý zdrojový kód testovací tøídy, který
je mimochodem dostupný na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/b91d2ad8f871/bytecode/Java/Test1.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/b91d2ad8f871/bytecode/Java/Test1.java</a>:</p>

<pre>
<i>/**</i>
<i> * Trida s nekolika jednoduchymi statickymi metodami</i>
<i> * pro otestovani zakladnich vlastnosti bajtkodu JVM.</i>
<i> */</i>
public class <strong>Test</strong> {
&nbsp;
    <i>/**</i>
    <i> * Prazdna metoda bez parametru.</i>
    <i> */</i>
    public static void <strong>nop1</strong>() {
    }
&nbsp;
    <i>/**</i>
    <i> * Taktez prazdna metoda bez parametru.</i>
    <i> */</i>
    public static void <strong>nop2</strong>() {
        return;
    }
&nbsp;
    <i>/**</i>
    <i> * Metoda bez parametru vracejici konstantu.</i>
    <i> */</i>
    public static int <strong>answer</strong>() {
        return 42;
    }
&nbsp;
    <i>/**</i>
    <i> * Soucet dvou celych cisel typu byte.</i>
    <i> */</i>
    public static byte <strong>add</strong>(byte x, byte y) {
        return (byte)(x+y);
    }
&nbsp;
    <i>/**</i>
    <i> * Soucet dvou celych cisel typu short.</i>
    <i> */</i>
    public static short <strong>add</strong>(short x, short y) {
        return (short)(x+y);
    }
&nbsp;
    <i>/**</i>
    <i> * Soucet dvou celych cisel typu int.</i>
    <i> */</i>
    public static int <strong>add</strong>(int x, int y) {
        return x+y;
    }
&nbsp;
    <i>/**</i>
    <i> * Soucet dvou celych cisel typu long.</i>
    <i> */</i>
    public static long <strong>add</strong>(long x, long y) {
        return x+y;
    }
&nbsp;
    <i>/**</i>
    <i> * Soucet dvou celych cisel typu float.</i>
    <i> */</i>
    public static float <strong>add</strong>(float x, float y) {
        return x+y;
    }
&nbsp;
    <i>/**</i>
    <i> * Soucet dvou celych cisel typu double.</i>
    <i> */</i>
    public static double <strong>add</strong>(double x, double y) {
        return x+y;
    }
&nbsp;
    <i>/**</i>
    <i> * Spojeni dvou retezcu.</i>
    <i> */</i>
    public static String <strong>add</strong>(String x, String y) {
        return x+y;
    }
&nbsp;
    <i>/**</i>
    <i> * Metoda s podminkou.</i>
    <i> */</i>
    public static boolean <strong>isNegative</strong>(int x) {
        if (x &lt; 0) {
            return true;
        }
        return false;
    }
&nbsp;
    <i>/**</i>
    <i> * Metoda s podminkou a se smyckou.</i>
    <i> */</i>
    public static long <strong>fibonacciIter</strong>(int n) {
        if (n &lt;= 1) {
            return n;
        }
        long result = 0;
        long n1 = 0;
        long n2 = 1;
        for(n--; n &gt; 0; n--) {
            result = n1 + n2;
            n1 = n2;
            n2 = result;
        }
        return result;
    }
&nbsp;
    <i>/**</i>
    <i> * Metoda s rekurzi.</i>
    <i> */</i>
    public static long <strong>fibonacciRecursive</strong>(int n) {
        if (n &lt;= 1) {
            return n;
        }
        else {
            return fibonacciRecursive(n-1) + fibonacciRecursive(n-2);
        }
    }
&nbsp;
    <i>/**</i>
    <i> * Vse je nutne otestovat.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        nop1();
        nop2();
        System.out.println(answer());
        System.out.println(add((byte)1, (byte)2));
        System.out.println(add((short)1, (short)2));
        System.out.println(add(1, 2));
        System.out.println(add(1L, 2L));
        System.out.println(add(1f, 2f));
        System.out.println(add(1., 2.));
        System.out.println(add("Hello ", "world!"));
        System.out.println(isNegative(-10));
&nbsp;
        for (int n=0; n &lt;= 10; n++) {
            System.out.println(n + "\t" + fibonacciIter(n) + "\t" + fibonacciRecursive(n));
        }
&nbsp;
    }
}
</pre>

<p>Bajtkód pøelo¾ených metod je vypsán pod tímto odstavcem.</p>

<p>V&nbsp;metodì <strong>nop1()</strong> je pou¾ita pouze jediná instrukce
<strong>return</strong> pro návrat z&nbsp;tìla metody:</p>

<pre>
public static void <strong>nop1</strong>();
  Code:
   0:   return     <i>; pouze návrat z metody</i>
</pre>

<p>Toté¾ platí pro metodu <strong>nop2()</strong>:</p>

<pre>
public static void <strong>nop2</strong>();
  Code:
   0:   return     <i>; pouze návrat z metody</i>
</pre>

<p>V&nbsp;metodì <strong>answer()</strong> je s&nbsp;vyu¾itím instrukce
<strong>ireturn</strong> vrácena hodnota ulo¾ená na vrcholu zásobníku operandù
(TOS):</p>

<pre>
public static int <strong>answer</strong>();
  Code:
   0:   bipush  42 <i>; ulo¾it na zásobník konstantu 42</i>
   2:   ireturn    <i>; výskok z metody s pøedáním návratové hodnoty</i>
</pre>

<p>Metoda <strong>add()</strong> vyu¾ívá pro typ <strong>byte</strong>
automatický pøevod hodnotu argumentu èi lokální promìnné na typ
<strong>int</strong>, ov¹em výsledek se musí zpìtnì konvertovat:</p>

<pre>
public static byte <strong>add</strong>(byte, byte);
  Code:
   0:   iload_0    <i>; ulo¾it první parametr na zásobník (+ provést konverzi na int)</i>
   1:   iload_1    <i>; ulo¾it druhý parametr na zásobník (+ provést konverzi na int)</i>
   2:   iadd       <i>; provést souèet</i>
   3:   i2b        <i>; zpìtná konverze na byte</i>
   4:   ireturn    <i>; výskok z metody s pøedáním návratové hodnoty</i>
</pre>

<p>Toté¾ platí v&nbsp;pøípadì pou¾ití celoèíselného datového typu
<strong>short</strong>:</p>

<pre>
public static short <strong>add</strong>(short, short);
  Code:
   0:   iload_0    <i>; ulo¾it první parametr na zásobník (+ provést konverzi na int)</i>
   1:   iload_1    <i>; ulo¾it druhý parametr na zásobník (+ provést konverzi na int)</i>
   2:   iadd       <i>; provést souèet</i>
   3:   i2s        <i>; zpìtná konverze na short</i>
   4:   ireturn    <i>; výskok z metody s pøedáním návratové hodnoty</i>
</pre>

<p>Souèet dvou èísel typu <strong>int</strong> s&nbsp;vyu¾itím zásobníku
operandù je podporován pøímo instrukcí bajtkódu:</p>

<pre>
public static int <strong>add</strong>(int, int);
  Code:
   0:   iload_0    <i>; ulo¾it první parametr na zásobník</i>
   1:   iload_1    <i>; ulo¾it druhý parametr na zásobník</i>
   2:   iadd       <i>; provést souèet</i>
   3:   ireturn    <i>; výskok z metody s pøedáním návratové hodnoty</i>
</pre>

<p>Souèet dvou èísel typu <strong>long</strong> s&nbsp;vyu¾itím zásobníku
operandù je takté¾ podporován pøímo instrukcí bajtkódu:</p>

<pre>
public static long <strong>add</strong>(long, long);
  Code:
   0:   lload_0    <i>; ulo¾it první parametr na zásobník</i>
   1:   lload_2    <i>; ulo¾it druhý parametr na zásobník</i>
   2:   ladd       <i>; provést souèet</i>
   3:   lreturn    <i>; výskok z metody s pøedáním návratové hodnoty</i>
</pre>

<p>Toté¾ platí pro argumenty èi promìnné typu <strong>float</strong>:</p>

<pre>
public static float <strong>add</strong>(float, float);
  Code:
   0:   fload_0    <i>; ulo¾it první parametr na zásobník</i>
   1:   fload_1    <i>; ulo¾it druhý parametr na zásobník</i>
   2:   fadd       <i>; provést souèet</i>
   3:   freturn    <i>; výskok z metody s pøedáním návratové hodnoty</i>
</pre>

<p>Toté¾ platí pro argumenty èi promìnné typu <strong>double</strong>:</p>

<pre>
public static double <strong>add</strong>(double, double);
  Code:
   0:   dload_0    <i>; ulo¾it první parametr na zásobník</i>
   1:   dload_2
   2:   dadd       <i>; provést souèet</i>
   3:   dreturn    <i>; výskok z metody s pøedáním návratové hodnoty</i>
</pre>

<p>Spojení dvou øetìzcù je naproti tomu realizováno pøes instanci tøídy
<strong>StringBuilder</strong> a metody <strong>append()</strong>. Výsledek je
nutné pøevést na øetìzec metodou <strong>toString()</strong>:</p>

<pre>
public static java.lang.String <strong>add</strong>(java.lang.String, java.lang.String);
  Code:
                   <i>; tato lokální promìnná se pou¾ije pøi spojování øetìzcù</i>
   0:   new     #2; //class java/lang/StringBuilder
   3:   dup
                   <i>; zavolat konstruktor tøídy StringBuilder</i>
   4:   invokespecial   #3; //Method java/lang/StringBuilder."init":()V
                   <i>; zavolat metodu append() tøídy StringBuilder pro první parametr</i>
   7:   aload_0
   8:   invokevirtual   #4; //Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
                   <i>; zavolat metodu append() tøídy StringBuilder pro druhý parametr</i>
   11:  aload_1
   12:  invokevirtual   #4; //Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
                   <i>; zpìtný pøevod na øetìzec</i>
   15:  invokevirtual   #5; //Method java/lang/StringBuilder.toString:()Ljava/lang/String;
   18:  areturn    <i>; výskok z metody s pøedáním návratové hodnoty</i>
</pre>

<p>V&nbsp;metodì <strong>isNegative()</strong> je pou¾ita instrukce pro
podmínìný skok <strong>ifge</strong>. Pov¹imnìte si toho, ¾e pravdivostní
hodnoty jsou v&nbsp;bajtkódu reprezentovány celoèíselnými konstantami 0 a
1:</p>

<pre>
public static boolean <strong>isNegative</strong>(int);
  Code:
   0:   iload_0    <i>; ulo¾it parametr na zásobník</i>
   1:   ifge    6  <i>; podmínìný skok na lokální adresu 6 pøi splnìní podmínky</i>
   4:   iconst_1   <i>; 1==true</i>
   5:   ireturn    <i>; výskok z metody s pøedáním návratové hodnoty true</i>
   6:   iconst_0   <i>; 0==false</i>
   7:   ireturn    <i>; výskok z metody s pøedáním návratové hodnoty false</i>
</pre>

<p>Nejslo¾itìj¹í je bajtkód metody <strong>fibonacciIter()</strong>, v&nbsp;ní¾
je pou¾ito nìkolika podmínìných skokù i jednoho skoku nepodmínìného:</p>

<pre>
public static long <strong>fibonacciIter</strong>(int);
  Code:
   0:   iload_0    <i>; ulo¾it první parametr na zásobník</i>
   1:   iconst_1   <i>; n se bude porovnávat s hodnotou 1</i>
   2:   if_icmpgt 8<i>; podmínìný skok na instrukci na indexu 8</i>
   5:   iload_0    <i>; pro n men¹í nebo rovno 1 se vrátí pøímo n</i>
   6:   i2l        <i>; konverze n na long</i>
   7:   lreturn    <i>; výskok z metody s pøedáním návratové hodnoty false</i>
&nbsp;
   8:   lconst_0   <i>; pøíprava pro zahájení poèítané programové smyèky</i>
   9:   lstore_1
   10:  lconst_0
   11:  lstore_3
   12:  lconst_1
   13:  lstore  5
   15:  iinc    0, -1
&nbsp;
   18:  iload_0    <i>; zde zaèíná programová smyèka</i>
   19:  ifle    39 <i>; test na ukonèení programové smyèky</i>
   22:  lload_3
   23:  lload   5
   25:  ladd
   26:  lstore_1
   27:  lload   5
   29:  lstore_3
   30:  lload_1
   31:  lstore  5
   33:  iinc    0, -1
   36:  goto    18 <i>; skok na zaèátek programové smyèky</i>
   39:  lload_1
   40:  lreturn    <i>; výskok z metody s pøedáním návratové hodnoty false</i>
</pre>

<p>Bajtkód metody <strong>fibonacciRecursive()</strong> pomìrnì pøesnì odpovídá
své zdrojové pøedloze:</p>

<pre>
public static long <strong>fibonacciRecursive</strong>(int);
  Code:
   0:   iload_0    <i>; ulo¾it první parametr na zásobník</i>
   1:   iconst_1   <i>; n se bude porovnávat s hodnotou 1</i>
   2:   if_icmpgt 8<i>; podmínìný skok na instrukci na indexu 8</i>
   5:   iload_0    <i>; pro n men¹í nebo rovno 1 se vrátí pøímo n</i>
   6:   i2l        <i>; konverze n na long</i>
   7:   lreturn    <i>; výskok z metody s pøedáním návratové hodnoty false</i>
&nbsp;
   8:   iload_0
   9:   iconst_1
   10:  isub       <i>; provedení operace n-1</i>
                   <i>; rekurzivní volání metody</i>
   11:  invokestatic    #6; //Method fibonacciRecursive:(I)J
&nbsp;
   14:  iload_0
   15:  iconst_2
   16:  isub       <i>; provedení operace n-2</i>
                   <i>; rekurzivní volání metody</i>
   17:  invokestatic    #6; //Method fibonacciRecursive:(I)J
&nbsp;
   20:  ladd       <i>; seèíst výsledek (návratovou hodnotu) obou rekurzivnì volaných metod</i>
   21:  lreturn    <i>; výskok z metody s pøedáním návratové hodnoty false</i>
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Bajtkód vyu¾ívaný jazykem Lua</h2>

<p>Dal¹ím bajtkódem, s&nbsp;ním¾ se v&nbsp;dne¹ním èlánku alespoò ve struènosti
seznámíme, je bajtkód vyu¾ívaný programovacím jazykem <i>Lua</i>. Bajtkód
tohoto jazyka se v&nbsp;mnoha ohledech odli¹uje od bajtkódu JVM. Pravdìpodobnì
nejnápadnìj¹ím rozdílem mezi bajtkódem JVM a bajtkódem jazyka Lua je fakt, ¾e
se v&nbsp;Lua VM nepou¾ívá zásobník operandù, proto¾e indexy operandù jsou
pøímo souèástí instrukèního slova. I formát instrukèních kódù je od JVM velmi
odli¹ný, proto¾e zatímco v&nbsp;pøípadì bajtkódu JVM je kód instrukce ulo¾en
v&nbsp;celém bajtu (s&nbsp;nìkolika málo výjimkami), je u Lua VM kód instrukce
ulo¾en v&nbsp;pouhých ¹esti bitech, zatímco zbylých 26 bitù instrukèního slova
je rezervováno pro ulo¾ení indexù operandù èi konstant. Bytekód Lua VM takté¾
obsahuje spí¹e vysokoúrovòové instrukce, které dobøe reflektují vlastnosti
tohoto programovacího jazyka. Existují napøíklad instrukce pro implementaci
programové smyèky <strong>for</strong>, instrukce pro práci
s&nbsp;(asociativními) poli tvoøícími nejdùle¾itìj¹í strukturovaný datový typ
jazyka Lua a dokonce se v&nbsp;bajtkódu nachází instrukce pro vytvoøení uzávìru
(<i>closure</i>) a pro tail call.</p>

<p>Instrukce mohou mít jeden z&nbsp;následujících formátù:</p>

<h3>iABC</h3>

<table>
<tr><th>#</th><th>Oznaèení</th><th>Délka bitového pole</th><th>Význam</th></tr>
<tr><td>1</td><td>i</td><td>6</td><td>kód instrukce</td></tr>
<tr><td>2</td><td>A</td><td>8</td><td>index èi hodnota prvního operandu</td></tr>
<tr><td>3</td><td>B</td><td>9</td><td>index èi hodnota druhého operandu</td></tr>
<tr><td>4</td><td>C</td><td>9</td><td>index èi hodnota tøetího operandu</td></tr>
</table>

<h3>iABx</h3>

<table>
<tr><th>#</th><th>Oznaèení</th><th>Délka bitového pole</th><th>Význam</th></tr>
<tr><td>1</td><td>i</td><td>6</td><td>kód instrukce</td></tr>
<tr><td>2</td><td>A</td><td>8</td><td>index èi hodnota prvního operandu</td></tr>
<tr><td>3</td><td>Bx</td><td>18</td><td>index èi hodnota druhého operandu</td></tr>
</table>

<h3>iAsBx</h3>

<table>
<tr><th>#</th><th>Oznaèení</th><th>Délka bitového pole</th><th>Význam</th></tr>
<tr><td>1</td><td>i</td><td>6</td><td>kód instrukce</td></tr>
<tr><td>2</td><td>A</td><td>8</td><td>index èi hodnota prvního operandu</td></tr>
<tr><td>3</td><td>sBx</td><td>18</td><td>index èi hodnota druhého operandu (zde se znaménkem)</td></tr>
</table>

<h3>iAx</h3>

<table>
<tr><th>#</th><th>Oznaèení</th><th>Délka bitového pole</th><th>Význam</th></tr>
<tr><td>1</td><td>i</td><td>6</td><td>kód instrukce</td></tr>
<tr><td>2</td><td>Ax</td><td>26</td><td>index èi hodnota prvního (jediného) operandu</td></tr>
</table>

<p>Podrobnosti si vysvìtlíme pøí¹tì.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Pøíklady funkcí pøelo¾ených do bajtkódu jazyka Lua</h2>

<p>Pro porovnání bajtkódù JVM a Lua VM vytvoøíme sadu funkcí, které se do co
nejvìt¹í míry podobají metodám pou¾itým ve tøídì <strong>Test1.java</strong>.
Jedním z&nbsp;velkých rozdílù mezi jazyky Java a Lua je dynamická povaha
datových typù v&nbsp;Lue, co¾ napøíklad znamená, ¾e se pùvodní pøetí¾ená metoda
<strong>add()</strong> musí implementovat funkcí <strong>add()</strong> pro
èísla a funkcí <strong>addStr()</strong> pro øetìzce:</p>

<pre>
<i>--</i>
<i>-- Modul s nekolika jednoduchymi funkcemi</i>
<i>-- pro otestovani zakladnich vlastnosti bajtkodu jazyka Lua</i>
<i>--</i>
&nbsp;
<i>--</i>
<i>-- Prazdna funkce bez parametru.</i>
<i>--</i>
function <strong>nop1</strong>()
end
&nbsp;
<i>--</i>
<i>-- Taktez prazdna funkce bez parametru.</i>
<i>--</i>
function <strong>nop2</strong>()
    return
end
&nbsp;
<i>--</i>
<i>-- Funkce bez parametru vracejici konstantu.</i>
<i>--</i>
function <strong>answer</strong>()
    return 42
end
&nbsp;
<i>--</i>
<i>-- Soucet dvou cisel.</i>
<i>--</i>
function <strong>add</strong>(x, y)
    return x+y
end
&nbsp;
<i>--</i>
<i>-- Spojeni dvou retezcu.</i>
<i>--</i>
function <strong>addStr</strong>(x, y)
    return x..y
end
&nbsp;
<i>--</i>
<i>-- Funkce s podminkou.</i>
<i>--</i>
function <strong>isNegative</strong>(x)
    if x &lt; 0 then
        return true
    end
    return false
end
&nbsp;
<i>--</i>
<i>-- Funkce s podminkou a se smyckou.</i>
<i>--</i>
function <strong>fibonacciIter</strong>(n)
    if n &lt;= 1 then
        return n
    end
&nbsp;
    local result = 0
    local n1 = 0
    local n2 = 1
&nbsp;
    for i = n-1, 1, -1 do
        result = n1 + n2
        n1 = n2
        n2 = result
    end
&nbsp;
    return result
end
&nbsp;
<i>--</i>
<i>-- Funkce s rekurzi.</i>
<i>--</i>
function <strong>fibonacciRecursive</strong>(n)
    if n &lt;= 1 then
        return n
    else
        return fibonacciRecursive(n-1) + fibonacciRecursive(n-2)
    end
end
&nbsp;
<i>--</i>
<i>-- Vse je nutne otestovat.</i>
<i>--</i>
function <strong>main</strong>()
    nop1()
    nop2()
    print(answer())
    print(add(1, 2))
    print(addStr("Hello ", "world!"))
    print(isNegative(-10))
&nbsp;
    for n = 0, 10 do
        print(n .. "\t" .. fibonacciIter(n) .. "\t" .. fibonacciRecursive(n))
    end
end
&nbsp;
main()
</pre>

<p>Podívejme se nyní na vygenerovaný bajtkód:</p>

<p>Funkce <strong>nop1()</strong> obsahuje pouze jedinou instrukci pro návrat
z&nbsp;funkce. První a druhý parametr instrukce <strong>RETURN</strong> urèuje,
které registry budou pou¾ity pro návratové hodnoty (mù¾e jich být více):</p>

<pre>
function &lt;<strong>Test.lua:9,10</strong>&gt; (1 instruction at 0x90a7c88)
0 params, 2 slots, 0 upvalues, 0 locals, 0 constants, 0 functions
        1       [10]    RETURN          0 1
</pre>

<p>U funkce <strong>nop2()</strong> ponìkud pøekvapivì narazíme na dvojici
instrukcí <strong>RETURN</strong>, proto¾e pøekladaè provádí pøeklad bez
optimalizací (co¾ oceníme pøi ladìní):</p>

<pre>
function &lt;<strong>Test.lua:15,17</strong>&gt; (2 instructions at 0x90a7de0)
0 params, 2 slots, 0 upvalues, 0 locals, 0 constants, 0 functions
        1       [16]    RETURN          0 1
        2       [17]    RETURN          0 1
</pre>

<p>Ve funkci <strong>answer()</strong> se vrací konstanta 42 a opìt zde mù¾eme
vidìt automaticky vytvoøenou koncovou instrukci <strong>RETURN</strong> (ve
skuteènosti RETURN nil):</p>

<pre>
function &lt;<strong>Test.lua:22,24</strong>&gt; (3 instructions at 0x90a7f08)
0 params, 2 slots, 0 upvalues, 0 locals, 1 constant, 0 functions
        1       [23]    LOADK           0 -1    ; 42
        2       [23]    RETURN          0 2
        3       [24]    RETURN          0 1
</pre>

<p>Souèet dvou parametrù pøedaných funkci <strong>add()</strong> je velmi
jednoduchý &ndash; seètou se hodnoty parametru èíslo 0 s&nbsp;hodnotou
parametru èíslo 1, výsledek se ulo¾í do registru 2, který je následnì vrácen
první instrukcí <strong>RETURN</strong>:</p>

<pre>
function &lt;<strong>Test.lua:29,31</strong>&gt; (3 instructions at 0x90a7d88)
2 params, 3 slots, 0 upvalues, 2 locals, 0 constants, 0 functions
        1       [30]    ADD             2 0 1
        2       [30]    RETURN          2 2
        3       [31]    RETURN          0 1
</pre>

<p>V&nbsp;bajtkódu nalezneme i instrukci pro konkatenaci øetìzcù:</p>

<pre>
function &lt;<strong>Test.lua:36,38</strong>&gt; (5 instructions at 0x90a8308)
2 params, 4 slots, 0 upvalues, 2 locals, 0 constants, 0 functions
        1       [37]    MOVE            2 0
        2       [37]    MOVE            3 1
        3       [37]    CONCAT          2 2 3
        4       [37]    RETURN          2 2
        5       [38]    RETURN          0 1
</pre>

<p>V&nbsp;bajtkódu funkce <strong>isNegative()</strong> si pov¹imnìte zpùsobu
naètení pravdivostních konstant do registru 1 i zpùsobu provedení podmínìného
skoku:</p>

<pre>
function &lt;<strong>Test.lua:43,48</strong>&gt; (7 instructions at 0x90a8500)
1 param, 2 slots, 0 upvalues, 1 local, 1 constant, 0 functions
        1       [44]    LT              0 0 -1  ; - 0
        2       [44]    JMP             0 2     ; to 5
        3       [45]    LOADBOOL        1 1 0
        4       [45]    RETURN          1 2
        5       [47]    LOADBOOL        1 0 0
        6       [47]    RETURN          1 2
        7       [48]    RETURN          0 1
</pre>

<p>Bajtkód funkce <strong>fibonacciIter()</strong> je relativnì krátký
(v&nbsp;porovnání s&nbsp;JVM), proto¾e se zde vyu¾ívají speciální instrukce
<strong>FORPREP</strong> a <strong>FORLOOP</strong>, jimi¾ je implementována
programová smyèka typu <strong>for</strong>:</p>

<pre>
function &lt;<strong>Test.lua:53,69</strong>&gt; (16 instructions at 0x90a7fa0)
1 param, 8 slots, 0 upvalues, 8 locals, 3 constants, 0 functions
        1       [54]    LE              0 0 -1  ; - 1
        2       [54]    JMP             0 1     ; to 4
        3       [55]    RETURN          0 2
        4       [58]    LOADK           1 -2    ; 0
        5       [59]    LOADK           2 -2    ; 0
        6       [60]    LOADK           3 -1    ; 1
        7       [62]    SUB             4 0 -1  ; - 1
        8       [62]    LOADK           5 -1    ; 1
        9       [62]    LOADK           6 -3    ; -1
        10      [62]    FORPREP         4 3     ; to 14
        11      [63]    ADD             1 2 3
        12      [64]    MOVE            2 3
        13      [65]    MOVE            3 1
        14      [62]    FORLOOP         4 -4    ; to 11
        15      [68]    RETURN          1 2
        16      [69]    RETURN          0 1
</pre>

<p>Zpùsob rekurzivního volání funkce si vy¾ádá podrobnìj¹í vysvìtlení, které
bude uvedeno pøí¹tì:</p>

<pre>
function &lt;<strong>Test.lua:74,80</strong>&gt; (13 instructions at 0x90a87d8)
1 param, 4 slots, 1 upvalue, 1 local, 3 constants, 0 functions
        1       [75]    LE              0 0 -1  ; - 1
        2       [75]    JMP             0 2     ; to 5
        3       [76]    RETURN          0 2
        4       [76]    JMP             0 8     ; to 13
        5       [78]    GETTABUP        1 0 -2  ; _ENV "fibonacciRecursive"
        6       [78]    SUB             2 0 -1  ; - 1
        7       [78]    CALL            1 2 2
        8       [78]    GETTABUP        2 0 -2  ; _ENV "fibonacciRecursive"
        9       [78]    SUB             3 0 -3  ; - 2
        10      [78]    CALL            2 2 2
        11      [78]    ADD             1 1 2
        12      [78]    RETURN          1 2
        13      [80]    RETURN          0 1
</pre>

<p>Bajtkód pou¾ívaný Lua VM je (alespoò podle mého názoru) nejenom èitelnìj¹í,
ale i krat¹í, a to mj.&nbsp;i kvùli existenci specializovaných instrukcí pro
implementaci programové smyèky <strong>for</strong> i díky existenci
aritmetických a logických instrukcí vyu¾ívajících tøíadresový kód (není potøeba
slo¾itì manipulovat s&nbsp;hodnotami ukládanými na zásobník operandù).</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Bajtkód vyu¾ívaný jazykem Python</h2>

<p>Posledním v&nbsp;souèasnosti pou¾ívaným bajtkódem, o nìm¾ se v&nbsp;dne¹ním
èlánku zmíníme, je bajtkód vyu¾ívaný programovacím jazykem Python, konkrétnì
jeho pùvodní verzí CPython (kromì tohoto bajtkódu lze najít i dal¹í bajtkódy
Pythonu urèené pro jiné VM, napøíklad Mamba atd.). Ji¾ v&nbsp;pøedchozích
kapitolách jsme si øekli, ¾e bajtkód JVM je pomìrnì nízkoúrovòový, zejména
v&nbsp;porovnání s&nbsp;bajtkódem pou¾ívaným v&nbsp;programovacím jazyku Lua
(resp.&nbsp;pøesnìji øeèeno virtuálním strojem tohoto jazyka). Toté¾ platí, a
to dokonce je¹tì ve vìt¹í míøe, i pro bajtkód jazyka Python. Ten je opìt
zalo¾en na zásobníku operandù, ov¹em mnohé instrukce pracující s&nbsp;jedním èi
dvìma operandy (samozøejmì ulo¾enými na zásobníku) ve skuteènosti mohou volat
metody objektù a nikoli pouze provádìt operace nad primitivními datovými typy.
Platí to pøedev¹ím pro v¹echny &bdquo;aritmetické&ldquo; operace, napøíklad i
pro operátor +, který se pøekládá do instrukce <strong>BINARY_ADD</strong>.</p>

<p>To napøíklad znamená, ¾e se jednoduchá funkce <strong>add()</strong> se
dvìma operandy:</p>

<pre>
def <strong>add</strong>(x, y):
    return x+y
</pre>

<p>pøelo¾í do následující ètveøice instrukcí bajtkódu:</p>

<pre>
<strong>add</strong>:
 28           0 LOAD_FAST                0 (x)
              3 LOAD_FAST                1 (y)
              6 BINARY_ADD          
              7 RETURN_VALUE        
</pre>

<p>Tuto funkci lze ov¹em volat jak s&nbsp;èíselnými parametry, tak i
s&nbsp;øetìzci, n-ticemi, seznamy èi objekty s&nbsp;implementovanou metodou
<strong>__add__</strong>, tak¾e instrukce <strong>BINARY_ADD</strong> není
zcela porovnatelná napøíklad s&nbsp;JVM instrukcemi <strong>iadd</strong>,
<strong>ladd</strong> atd. operujícími pouze nad konkrétním primitivním datovým
typem.:</p>

<pre>
    print(add(1, 2))
    print(add(1., 2))
    print(add("Hello ", "world!"))
    print(add([1,2,3], [4,5,6]))
    print(add((1,2,3), (4,5,6)))
</pre>

<p>Kromì toho mù¾e bajtkód Pythonu obsahovat i instrukce pro snaz¹í tvorbu
smyèek (<strong>BREAK_LOOP</strong>, <strong>CONTINUE_LOOP</strong>) i pro
práci s&nbsp;kolekcemi (<strong>LIST_APPEND</strong>, <strong>MAP_ADD</strong>,
<strong>BUILD_SLICE</strong> apod).</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Pøíklady funkcí pøelo¾ených do bajtkódu Pythonu</h2>

<p>Podobnì jako tomu bylo v&nbsp;pøípadì Javy i programovacího jazyka Lua, i
pro Python byla vytvoøena demonstraèní aplikace s&nbsp;funkcemi, které se sna¾í
co nejvíce pøiblí¾it pùvodním zdrojovým kódùm v&nbsp;Javì a Lue (právì proto
zde nejsou pou¾ity nìkteré pro Python typické idiomy). Podívejme se nejdøíve na
zdrojový kód tohoto pøíkladu, který ve své závìreèné èásti obsahuje funkci pro
disassembling bajtkódu:</p>

<pre>
<i>#</i>
<i># Modul s nekolika jednoduchymi funkcemi</i>
<i># pro otestovani zakladnich vlastnosti bajtkodu jazyka Python</i>
<i>#</i>
&nbsp;
<i>#</i>
<i># Prazdna funkce bez parametru.</i>
<i>#</i>
def <strong>nop1</strong>():
    pass
&nbsp;
<i>#</i>
<i># Taktez prazdna funkce bez parametru.</i>
<i>#</i>
def <strong>nop2</strong>():
    return
&nbsp;
<i>#</i>
<i># Funkce bez parametru vracejici konstantu.</i>
<i>#</i>
def <strong>answer</strong>():
    return 42
&nbsp;
<i>#</i>
<i># Soucet dvou cisel.</i>
<i>#</i>
def <strong>add</strong>(x, y):
    return x+y
&nbsp;
<i>#</i>
<i># Funkce s podminkou.</i>
<i>#</i>
def <strong>isNegative</strong>(x):
    if x &lt; 0:
        return True
    return False
&nbsp;
<i>#</i>
<i># Funkce s podminkou a se smyckou.</i>
<i>#</i>
def <strong>fibonacciIter</strong>(n):
    if n &lt;= 1:
        return n
&nbsp;
    result = 0
    n1 = 0
    n2 = 1
&nbsp;
    for i in xrange(n-1, 0, -1):
        result = n1 + n2
        n1 = n2
        n2 = result
&nbsp;
    return result
&nbsp;
<i>#</i>
<i># Funkce s rekurzi.</i>
<i>#</i>
def <strong>fibonacciRecursive</strong>(n):
    if n &lt;= 1:
        return n
    else:
        return fibonacciRecursive(n-1) + fibonacciRecursive(n-2)
&nbsp;
<i>#</i>
<i># Vse je nutne otestovat.</i>
<i>#</i>
def <strong>main</strong>():
    nop1()
    nop2()
    print(answer())
    print(add(1, 2))
    print(add("Hello ", "world!"))
    print(isNegative(-10))
&nbsp;
    for n in xrange(0,11):
        print(str(n) + "\t" + str(fibonacciIter(n)) + "\t" + str(fibonacciRecursive(n)))
&nbsp;
<i>#main()</i>
&nbsp;
def <strong>disassemble</strong>():
    from dis import dis
&nbsp;
    print("\nnop1:")
    dis(nop1)
&nbsp;
    print("\nnop2:")
    dis(nop2)
&nbsp;
    print("\nanswer:")
    dis(answer)
&nbsp;
    print("\nadd:")
    dis(add)
&nbsp;
    print("\nisNegative:")
    dis(isNegative)
&nbsp;
    print("\nfibonacciIter:")
    dis(fibonacciIter)
&nbsp;
    print("\nfibonacciRecursive:")
    dis(fibonacciRecursive)
&nbsp;
disassemble()
</pre>

<p>Opìt se podívejme, jak bude vypadat bajtkód vygenerovaný pøekladaèem
Pythonu, resp.&nbsp;pøesnìji øeèeno CPythonu:</p>

<p>Na pøekladu funkce <strong>nop1()</strong> pravdìpodobnì nenajdeme nic
pøekvapivého:</p>

<pre>
<strong>nop1</strong>:
 10           0 LOAD_CONST               0 (None)
              3 RETURN_VALUE        
</pre>

<p>Stejným zpùsobem je pøelo¾ena i funkce <strong>nop2()</strong>, co¾ je
pochopitelné:</p>

<pre>
<strong>nop2</strong>:
 16           0 LOAD_CONST               0 (None)
              3 RETURN_VALUE        
</pre>

<p>V&nbsp;bajtkódu funkce <strong>answer()</strong> se na zásobník nejdøíve
ulo¾í èíselná konstanta 42, která je následnì instrukcí
<strong>RETURN_VALUE</strong> vrácena volající funkci:</p>

<pre>
<strong>answer</strong>:
 22           0 LOAD_CONST               1 (42)
              3 RETURN_VALUE        
</pre>

<p>Ve funkci <strong>add()</strong> se pou¾ívá instrukce
<strong>BINARY_ADD</strong>, která v¹ak ve skuteènosti mù¾e pracovat nejenom
s&nbsp;èísly, ale i s&nbsp;øetìzci, n-ticemi apod., co¾ je velký rozdíl oproti
bajtkódu JVM, co¾ jsme ostatnì mohli vidìt v&nbsp;pøedchozích kapitolách:</p>

<pre>
<strong>add</strong>:
 28           0 LOAD_FAST                0 (x)
              3 LOAD_FAST                1 (y)
              6 BINARY_ADD          
              7 RETURN_VALUE        
</pre>

<p>V&nbsp;bajtkódu funkce <strong>isNegative()</strong> je zajímavá pøedev¹ím
kombinace instrukcí <strong>COMPARE_OP</strong> (s&nbsp;operandem &lt;) a
<strong>JUMP_IF_FALSE</strong>. Instrukce bajtkódu Pythonu evidentnì nejsou
pojmenovány s&nbsp;ohledem na jejich ruèní zápis :-):</p>

<pre>
<strong>isNegative</strong>:
 34           0 LOAD_FAST                0 (x)
              3 LOAD_CONST               1 (0)
              6 COMPARE_OP               0 (&lt;)
              9 JUMP_IF_FALSE            5 (to 17)
             12 POP_TOP             
&nbsp;
 35          13 LOAD_GLOBAL              0 (True)
             16 RETURN_VALUE        
        &gt;&gt;   17 POP_TOP             

 36          18 LOAD_GLOBAL              1 (False)
             21 RETURN_VALUE        
</pre>

<p>I v&nbsp;bajtkódu funkce <strong>fibonacciIter()</strong> nalezneme dvojici
instrukcí <strong>COMPARE_OP</strong> s&nbsp;<strong>JUMP_IF_FALSE</strong>.
Kromì toho si pov¹imnìte instrukce <strong>FOR_ITER</strong>, která pro zadaný
iterátor ulo¾ený na zásobníku vytvoøí základ pro programovou smyèku for:</p>

<pre>
<strong>fibonacciIter</strong>:
 42           0 LOAD_FAST                0 (n)
              3 LOAD_CONST               1 (1)
              6 COMPARE_OP               1 (&lt;=)
              9 JUMP_IF_FALSE            5 (to 17)
             12 POP_TOP             
&nbsp;
 43          13 LOAD_FAST                0 (n)
             16 RETURN_VALUE        
        &gt;&gt;   17 POP_TOP             
&nbsp;
 45          18 LOAD_CONST               2 (0)
             21 STORE_FAST               1 (result)
&nbsp;
 46          24 LOAD_CONST               2 (0)
             27 STORE_FAST               2 (n1)
&nbsp;
 47          30 LOAD_CONST               1 (1)
             33 STORE_FAST               3 (n2)
&nbsp;
 49          36 SETUP_LOOP              52 (to 91)
             39 LOAD_GLOBAL              0 (xrange)
             42 LOAD_FAST                0 (n)
             45 LOAD_CONST               1 (1)
             48 BINARY_SUBTRACT     
             49 LOAD_CONST               2 (0)
             52 LOAD_CONST               3 (-1)
             55 CALL_FUNCTION            3
             58 GET_ITER            
        &gt;&gt;   59 FOR_ITER                28 (to 90)
             62 STORE_FAST               4 (i)
&nbsp;
 50          65 LOAD_FAST                2 (n1)
             68 LOAD_FAST                3 (n2)
             71 BINARY_ADD          
             72 STORE_FAST               1 (result)
&nbsp;
 51          75 LOAD_FAST                3 (n2)
             78 STORE_FAST               2 (n1)
&nbsp;
 52          81 LOAD_FAST                1 (result)
             84 STORE_FAST               3 (n2)
             87 JUMP_ABSOLUTE           59
        &gt;&gt;   90 POP_BLOCK           
&nbsp;
 54     &gt;&gt;   91 LOAD_FAST                1 (result)
             94 RETURN_VALUE        
</pre>

<p>V&nbsp;bajtkódu funkce <strong>fibonacciRecursive()</strong> si pov¹imnìte
zejména instrukce pojmenované <strong>LOAD_GLOBAL</strong>, kterou je mo¾né
vyu¾ít pro ulo¾ení hodnoty globálního symbolu na zásobník:</p>

<pre>
<strong>fibonacciRecursive</strong>:
 60           0 LOAD_FAST                0 (n)
              3 LOAD_CONST               1 (1)
              6 COMPARE_OP               1 (&lt;=)
              9 JUMP_IF_FALSE            5 (to 17)
             12 POP_TOP             
&nbsp;
 61          13 LOAD_FAST                0 (n)
             16 RETURN_VALUE        
        &gt;&gt;   17 POP_TOP             

 63          18 LOAD_GLOBAL              0 (fibonacciRecursive)
             21 LOAD_FAST                0 (n)
             24 LOAD_CONST               1 (1)
             27 BINARY_SUBTRACT     
             28 CALL_FUNCTION            1
             31 LOAD_GLOBAL              0 (fibonacciRecursive)
             34 LOAD_FAST                0 (n)
             37 LOAD_CONST               2 (2)
             40 BINARY_SUBTRACT     
             41 CALL_FUNCTION            1
             44 BINARY_ADD          
             45 RETURN_VALUE        
             46 LOAD_CONST               0 (None)
             49 RETURN_VALUE        
</pre>

<p>Vzhledem ke znaèným rozdílùm mezi bajtkódem Python VM a bajtkódem JVM se
budeme podrobnìj¹ími rozdíly zabývat v&nbsp;navazující èásti tohoto seriálu,
kde se zmíníme i o mo¾nosti pøekladu Pythonu èi zdrojových kódù napsaných
v&nbsp;jazyce Lua do bajtkódu JVM.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Repositáø se zdrojovými kódy v¹ech tøí dne¹ních demonstraèních pøíkladù</h2>

<p>V¹echny tøi dne¹ní demonstraèní pøíklady <strong>Test1.java</strong>,
<strong>Test1.lua</strong> i <strong>Test1.py</strong> jsou ulo¾eny do
Mercurial repositáøe umístìného na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>:</p>

<table>
<tr><th>#</th><th>Zdrojový kód</th><th>Umístìní</th></tr>
<tr><td>1</td><td>Test1.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/b91d2ad8f871/bytecode/Java/Test1.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/b91d2ad8f871/bytecode/Java/Test1.java</a></td></tr>
<tr><td>2</td><td>Test1.lua </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/b91d2ad8f871/bytecode/Lua/Test1.lua">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/b91d2ad8f871/bytecode/Lua/Test1.lua</a></td></tr>
<tr><td>3</td><td>Test1.py  </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/b91d2ad8f871/bytecode/Python/Test1.py">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/b91d2ad8f871/bytecode/Python/Test1.py</a></td></tr>
</table>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>Python Bytecode: Fun With Dis<br />
<a href="http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/">http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/</a>
</li>

<li>Python's Innards: Hello, ceval.c!<br />
<a href="http://tech.blog.aknin.name/category/my-projects/pythons-innards/">http://tech.blog.aknin.name/category/my-projects/pythons-innards/</a>
</li>

<li>Byterun<br />
<a href="https://github.com/nedbat/byterun">https://github.com/nedbat/byterun</a>
</li>

<li>Python Byte Code Instructions<br />
<a href="http://document.ihg.uni-duisburg.de/Documentation/Python/lib/node56.html">http://document.ihg.uni-duisburg.de/Documentation/Python/lib/node56.html</a>
</li>

<li>Python Byte Code Instructions<br />
<a href="https://docs.python.org/3.2/library/dis.html#python-bytecode-instructions">https://docs.python.org/3.2/library/dis.html#python-bytecode-instructions</a>
</li>

<li>Programovací jazyk Lua<br />
<a href="http://palmknihy.cz/web/kniha/programovaci-jazyk-lua-12651.htm">http://palmknihy.cz/web/kniha/programovaci-jazyk-lua-12651.htm</a>
</li>

<li>Lua 5.2 sources<br />
<a href="http://www.lua.org/source/5.2/">http://www.lua.org/source/5.2/</a>
</li>

<li>Lua 5.2 sources - lopcodes.h<br />
<a href="http://www.lua.org/source/5.2/lopcodes.h.html">http://www.lua.org/source/5.2/lopcodes.h.html</a>
</li>

<li>Lua 5.2 sources - lopcodes.c<br />
<a href="http://www.lua.org/source/5.2/lopcodes.c.html">http://www.lua.org/source/5.2/lopcodes.c.html</a>
</li>

<li>dis - Python module<br />
<a href="https://docs.python.org/2/library/dis.html">https://docs.python.org/2/library/dis.html</a>
</li>

<li>Comparison of Python virtual machines<br />
<a href="http://polishlinux.org/apps/cli/comparison-of-python-virtual-machines/">http://polishlinux.org/apps/cli/comparison-of-python-virtual-machines/</a>
</li>

<li>O-code<br />
<a href="http://en.wikipedia.org/wiki/O-code_machine">http://en.wikipedia.org/wiki/O-code_machine</a>
</li>

<li>BCPL<br />
<a href="http://en.wikipedia.org/wiki/BCPL">http://en.wikipedia.org/wiki/BCPL</a>
</li>

<li>The BCPL Cintcode System and Cintpos User Guide by Martin Richards<br />
<a href="http://www.cl.cam.ac.uk/users/mr/bcplman.pdf">http://www.cl.cam.ac.uk/users/mr/bcplman.pdf</a>
</li>

<li>Bootstrapping the BCPL Compiler using INTCODE<br />
<a href="http://www.gtoal.com/languages/bcpl/amiga/bcpl/booting.txt">http://www.gtoal.com/languages/bcpl/amiga/bcpl/booting.txt</a>
</li>

<li>p-code machine<br />
<a href="http://en.wikipedia.org/wiki/P-code_machine">http://en.wikipedia.org/wiki/P-code_machine</a>
</li>

<li>ucsd-psystem-vm 0.11 (a portable virtual machine for the UCSD p-System)<br />
<a href="http://ucsd-psystem-vm.sourceforge.net/">http://ucsd-psystem-vm.sourceforge.net/</a>
</li>

<li>Introduction to Smalltalk bytecodes<br />
<a href="http://marianopeck.wordpress.com/2011/05/21/introduction-to-smalltalk-bytecodes/">http://marianopeck.wordpress.com/2011/05/21/introduction-to-smalltalk-bytecodes/</a>
</li>

<li>Audio File Formats.<br />
<a href="http://sox.sourceforge.net/AudioFormats-11.html">http://sox.sourceforge.net/AudioFormats-11.html</a>
</li>

<li>TestSounds.com: pure digital sounds to test your audio<br />
<a href="http://www.testsounds.com/">http://www.testsounds.com/</a>
</li>

<li>Test Tones (20hz - 20khz)<br />
<a href="http://mdf1.tripod.com/test-tones.html">http://mdf1.tripod.com/test-tones.html</a>
</li>

<li>WAV (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/WAV">http://en.wikipedia.org/wiki/WAV</a>
</li>

<li>WAVE PCM soundfile format<br />
<a href="https://ccrma.stanford.edu/courses/422/projects/WaveFormat/">https://ccrma.stanford.edu/courses/422/projects/WaveFormat/</a>
</li>

<li>Audio Interchange File Format<br />
<a href="http://en.wikipedia.org/wiki/Aiff">http://en.wikipedia.org/wiki/Aiff</a>
</li>

<li>Musical Instrument Digital Interface,<br />
<a href="http://en.wikipedia.org/wiki/Musical_Instrument_Digital_Interface">http://en.wikipedia.org/wiki/Musical_Instrument_Digital_Interface</a>
</li>

<li>A MIDI Pedalboard Encode,<br />
<a href="http://www.pykett.org.uk/a_midi_pedalboard_encoder.htm">http://www.pykett.org.uk/a_midi_pedalboard_encoder.htm</a>
</li>

<li>MIDI Note Number, Frequency Table,<br />
<a href="http://tonalsoft.com/pub/news/pitch-bend.aspx">http://tonalsoft.com/pub/news/pitch-bend.aspx</a>
</li>

<li>Note names, MIDI numbers and frequencies,<br />
<a href="http://www.phys.unsw.edu.au/jw/notes.html">http://www.phys.unsw.edu.au/jw/notes.html</a>
</li>

<li>The MIDI Specification,<br />
<a href="http://www.gweep.net/~prefect/eng/reference/protocol/midispec.html">http://www.gweep.net/~prefect/eng/reference/protocol/midispec.html</a>
</li>

<li>Essentials of the MIDI protocol,<br />
<a href="http://ccrma.stanford.edu/~craig/articles/linuxmidi/misc/essenmidi.html">http://ccrma.stanford.edu/~craig/articles/linuxmidi/misc/essenmidi.html</a>
</li>

<li>General MIDI,<br />
<a href="http://en.wikipedia.org/wiki/General_MIDI">http://en.wikipedia.org/wiki/General_MIDI</a>
</li>

<li>Obecné MIDI (General MIDI), <br />
<a href="http://www-kiv.zcu.cz/~herout/html_sbo/midi/5.html">http://www-kiv.zcu.cz/~herout/html_sbo/midi/5.html</a>
</li>

<li>Custom Chips: Paula<br />
<a href="http://www.amiga-hardware.com/showhardware.cgi?HARDID=1460">http://www.amiga-hardware.com/showhardware.cgi?HARDID=1460</a>
</li>

<li>Big Book of Amiga Hardware<br />
<a href="http://www.amiga-resistance.info/bboahfaq/">http://www.amiga-resistance.info/bboahfaq/</a>
</li>

<li>Amiga Hardware Database<br />
<a href="http://amiga.resource.cx/">http://amiga.resource.cx/</a>
</li>

<li>ExoticA<br />
<a href="http://www.exotica.org.uk/wiki/Main_Page">http://www.exotica.org.uk/wiki/Main_Page</a>
</li>

<li>The absolute basics of Amiga audio<br />
<a href="http://www.sufo.estates.co.uk/amiga/amimus.html">http://www.sufo.estates.co.uk/amiga/amimus.html</a>
</li>

<li>Wikipedia: Tracker<br />
<a href="http://en.wikipedia.org/wiki/Tracker">http://en.wikipedia.org/wiki/Tracker</a>
</li>

<li>Wikipedia: Trackers<br />
<a href="http://en.wikipedia.org/wiki/Trackers">http://en.wikipedia.org/wiki/Trackers</a>
</li>

<li>Ultimate Soundtracker<br />
<a href="http://en.wikipedia.org/wiki/Ultimate_Soundtracker">http://en.wikipedia.org/wiki/Ultimate_Soundtracker</a>
</li>

<li>Protracker<br />
<a href="http://en.wikipedia.org/wiki/ProTracker">http://en.wikipedia.org/wiki/ProTracker</a>
</li>

<li>Impulse Tracker<br />
<a href="http://en.wikipedia.org/wiki/Impulse_Tracker">http://en.wikipedia.org/wiki/Impulse_Tracker</a>
</li>

<li>Scream Tracker<br />
<a href="http://en.wikipedia.org/wiki/ScreamTracker">http://en.wikipedia.org/wiki/ScreamTracker</a>
</li>

<li>MikMod for Java<br />
<a href="http://jmikmod.berlios.de/">http://jmikmod.berlios.de/</a>
</li>

<li>List of audio trackers<br />
<a href="http://en.wikipedia.org/wiki/List_of_audio_trackers">http://en.wikipedia.org/wiki/List_of_audio_trackers</a>
</li>

<li>Wikipedia: Module File<br />
<a href="http://en.wikipedia.org/wiki/Module_file">http://en.wikipedia.org/wiki/Module_file</a>
</li>

<li>Wikipedia: Chiptune<br />
<a href="http://en.wikipedia.org/wiki/Chiptune">http://en.wikipedia.org/wiki/Chiptune</a>
</li>

<li>SDL_mixer 2.0<br />
<a href="http://www.libsdl.org/projects/SDL_mixer/">http://www.libsdl.org/projects/SDL_mixer/</a>
</li>

<li>SDLJava: package sdljava.ttf<br />
<a href="http://sdljava.sourceforge.net/docs/api/sdljava/ttf/package-summary.html#package_description">http://sdljava.sourceforge.net/docs/api/sdljava/ttf/package-summary.html#package_description</a>
</li>

<li>SDLJava: class sdljava.ttf.SDLTTF<br />
<a href="http://sdljava.sourceforge.net/docs/api/sdljava/ttf/SDLTTF.html">http://sdljava.sourceforge.net/docs/api/sdljava/ttf/SDLTTF.html</a>
</li>

<li>SDLJava: class sdljava.ttf.SDLTrueTypeFont<br />
<a href="http://sdljava.sourceforge.net/docs/api/sdljava/ttf/SDLTrueTypeFont.html">http://sdljava.sourceforge.net/docs/api/sdljava/ttf/SDLTrueTypeFont.html</a>
</li>

<li>SDL_ttf Documentation<br />
<a href="http://www.libsdl.org/projects/SDL_ttf/docs/">http://www.libsdl.org/projects/SDL_ttf/docs/</a>
</li>

<li>SDL_ttf 2.0 (není prozatím souèástí SDLJava)<br />
<a href="http://www.libsdl.org/projects/SDL_ttf/">http://www.libsdl.org/projects/SDL_ttf/</a>
</li>

<li>SDL_ttf doc<br />
<a href="http://www.libsdl.org/projects/SDL_ttf/docs/SDL_ttf_frame.html">http://www.libsdl.org/projects/SDL_ttf/docs/SDL_ttf_frame.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_Surface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_PixelFormat<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlpixelformat.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlpixelformat.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_LockSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdllocksurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdllocksurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_UnlockSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlunlocksurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlunlocksurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_LoadBMP<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlloadbmp.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlloadbmp.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_SaveBMP<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsavebmp.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsavebmp.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_BlitSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlblitsurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlblitsurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_VideoInfo<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlvideoinfo.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlvideoinfo.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_GetVideoInfo<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlgetvideoinfo.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlgetvideoinfo.html</a>
</li>

<li>glDrawArrays<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArrays.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArrays.xml</a>
</li>

<li>glDrawElements<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElements.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElements.xml</a>
</li>

<li>glDrawArraysInstanced<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArraysInstanced.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArraysInstanced.xml</a>
</li>

<li>glDrawElementsInstanced<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElementsInstanced.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElementsInstanced.xml</a>
</li>

<li>Root.cz: Seriál Grafická knihovna OpenGL<br />
<a href="http://www.root.cz/serialy/graficka-knihovna-opengl/">http://www.root.cz/serialy/graficka-knihovna-opengl/</a>
</li>

<li>Root.cz: Seriál Tvorba pøenositelných grafických aplikací vyu¾ívajících knihovnu GLUT<br />
<a href="http://www.root.cz/serialy/tvorba-prenositelnych-grafickych-aplikaci-vyuzivajicich-knihovnu-glut/">http://www.root.cz/serialy/tvorba-prenositelnych-grafickych-aplikaci-vyuzivajicich-knihovnu-glut/</a>
</li>

<li>Best Practices for Working with Vertex Data<br />
<a href="https://developer.apple.com/library/ios/documentation/3ddrawing/conceptual/opengles_programmingguide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html">https://developer.apple.com/library/ios/documentation/3ddrawing/conceptual/opengles_programmingguide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html</a>
</li>

<li>Class BufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferStrategy.html</a>
</li>

<li>Class Graphics<br />
<a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/Graphics.html">http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/Graphics.html</a>
</li>

<li>Double Buffering and Page Flipping<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html</a>
</li>

<li>BufferStrategy and BufferCapabilities<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/bufferstrategy.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/bufferstrategy.html</a>
</li>

<li>Java:Tutorials:Double Buffering<br />
<a href="http://content.gpwiki.org/index.php/Java:Tutorials:Double_Buffering">http://content.gpwiki.org/index.php/Java:Tutorials:Double_Buffering</a>
</li>

<li>Double buffer in standard Java AWT<br />
<a href="http://www.codeproject.com/Articles/2136/Double-buffer-in-standard-Java-AWT">http://www.codeproject.com/Articles/2136/Double-buffer-in-standard-Java-AWT</a>
</li>

<li>Java 2D: Hardware Accelerating - Part 1 - Volatile Images<br />
<a href="http://www.javalobby.org/forums/thread.jspa?threadID=16840&tstart=0">http://www.javalobby.org/forums/thread.jspa?threadID=16840&tstart=0</a>
</li>

<li>Java 2D: Hardware Accelerating - Part 2 - Buffer Strategies<br />
<a href="http://www.javalobby.org/java/forums/t16867.html">http://www.javalobby.org/java/forums/t16867.html</a>
</li>

<li>How does paintComponent work?<br />
<a href="http://stackoverflow.com/questions/15544549/how-does-paintcomponent-work">http://stackoverflow.com/questions/15544549/how-does-paintcomponent-work</a>
</li>

<li>A Swing Architecture Overview<br />
<a href="http://www.oracle.com/technetwork/java/architecture-142923.html">http://www.oracle.com/technetwork/java/architecture-142923.html</a>
</li>

<li>Class javax.swing.JComponent<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html</a>
</li>

<li>Class java.awt.Component<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html</a>
</li>

<li>Class java.awt.Component.BltBufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.BltBufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.BltBufferStrategy.html</a>
</li>

<li>Class java.awt.Component.FlipBufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.FlipBufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.FlipBufferStrategy.html</a>
</li>

<li>Metoda java.awt.Component.isDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html#isDoubleBuffered()">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html#isDoubleBuffered()</a>
</li>

<li>Metoda javax.swing.JComponent.isDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#isDoubleBuffered()">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#isDoubleBuffered()</a>
</li>

<li>Metoda javax.swing.JComponent.setDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#setDoubleBuffered(boolean)">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#setDoubleBuffered(boolean)</a>
</li>

<li>Javadoc - tøída GraphicsDevice<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html</a>
</li>

<li>Javadoc - tøída GraphicsEnvironment<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html</a>
</li>

<li>Javadoc - tøída GraphicsConfiguration<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html</a>
</li>

<li>Javadoc - tøída DisplayMode<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html">http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html</a>
</li>

<li>Lesson: Full-Screen Exclusive Mode API<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/">http://docs.oracle.com/javase/tutorial/extra/fullscreen/</a>
</li>

<li>Full-Screen Exclusive Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html</a>
</li>

<li>Display Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html</a>
</li>

<li>Using the Full-Screen Exclusive Mode API in Java<br />
<a href="http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm">http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>GC safe-point (or safepoint) and safe-region<br />
<a href="http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html">http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html</a>
</li>

<li>Safepoints in HotSpot JVM<br />
<a href="http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html">http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html</a>
</li>

<li>Java theory and practice: Synchronization optimizations in Mustang<br />
<a href="http://www.ibm.com/developerworks/java/library/j-jtp10185/">http://www.ibm.com/developerworks/java/library/j-jtp10185/</a>
</li>

<li>How to build hsdis<br />
<a href="http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README">http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README</a>
</li>

<li>Java SE 6 Performance White Paper<br />
<a href="http://www.oracle.com/technetwork/java/6-performance-137236.html">http://www.oracle.com/technetwork/java/6-performance-137236.html</a>
</li>

<li>Lukas Stadler's Blog<br />
<a href="http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html">http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html</a>
</li>

<li>How to build hsdis-amd64.dll and hsdis-i386.dll on Windows<br />
<a href="http://dropzone.nfshost.com/hsdis.htm">http://dropzone.nfshost.com/hsdis.htm</a>
</li>

<li>PrintAssembly<br />
<a href="https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly">https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly</a>
</li>

<li>The Java Virtual Machine Specification: 3.14. Synchronization<br />
<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14</a>
</li>

<li>The Java Virtual Machine Specification: 8.3.1.4. volatile Fields<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.4. Memory Model<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.7. Non-atomic Treatment of double and long<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7</a>
</li>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (pøed verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2014</small></p>
</body>
</html>

