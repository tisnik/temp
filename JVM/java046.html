<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Clojure 15: tvorba u¾ivatelských maker</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Clojure 15: tvorba u¾ivatelských maker</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;dne¹ní èásti seriálu o vlastnostech programovacího jazyka Java i JVM budeme pokraèovat v popisu makrosystému, který tvoøí nedílnou souèást jazyka Clojure. Minule jsme si popsali makra objektu Reader, pøedev¹ím makra nazvaná quote, syntax-quote, unquote a unquote-splicing, která vyu¾ijeme dnes pøi tvorbì skuteèných u¾ivatelských maker.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyk Clojure 15: tvorba u¾ivatelských maker</a></p>
<p><a href="#k02">2. Generování kódu ve skriptovacích programovacích jazycích</a></p>
<p><a href="#k03">3. Dva zpùsoby vytvoøení seznamu obsahujícího èást programu vykonaného funkcí <strong>eval</strong></a></p>
<p><a href="#k04">4. Vyu¾ití funkcí <strong>eval</strong> a <strong>read-string</strong></a></p>
<p><a href="#k05">5. Tvorba jednoduchých maker s&nbsp;vyu¾itím <strong>defmacro</strong></a></p>
<p><a href="#k06">6. Expanze maker: <strong>macroexpand-1</strong> a <strong>macroexpand</strong></a></p>
<p><a href="#k07">7. Pou¾ití reader maker &bdquo;syntax-quote&ldquo; a &bdquo;unquote&ldquo; pøi tvorbì u¾ivatelských maker</a></p>
<p><a href="#k08">8. Problém s&nbsp;vytváøením lokálních (unikátních) symbolù a øe¹ení tohoto problému</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk Clojure 15: tvorba u¾ivatelských maker</h2>

<p>V&nbsp;pøedchozí èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
vlastnostech programovacího jazyka Java i virtuálního stroje Javy (JVM)</a>
jsme si nejdøíve zopakovali význam smyèky <i>REPL (Read-Eval-Print-Loop)</i>,
kterou je vybavena vìt¹ina skriptovacích jazykù i jazykù zalo¾ených na LISPu, a
posléze jsme se zabývali popisem interních maker pou¾ívaných objektem
<i>Reader</i>. Pøipomeòme si, ¾e tato makra jsou aplikována ihned pøi naèítání
forem ze standardního vstupu, popø.&nbsp;pøi naèítání jednotlivých forem ze
zdrojového souboru. Pro jednoduchost si mù¾eme pøedstavit, ¾e tato makra
provádí textové substituce, i kdy¾ tyto substituce jsou obecnì slo¾itìj¹í, ne¾
napøíklad substituce provádìné preprocesorem programovacího jazyka C èi C++, a
to zejména z&nbsp;toho dùvodu, ¾e <i>reader makra</i> pou¾ívají informace
získané z&nbsp;interpretru jazyka <i>Clojure</i> &ndash; to se týká pøedev¹ím
makra nazvaného &bdquo;syntax-quote&ldquo;, které doká¾e (kromì jiného) získat
informace o jmenném prostoru, v&nbsp;nìm¾ je nìjaký symbol definován.</p>

<p>V&nbsp;následující tabulce jsou vypsána makra objektu <i>Reader</i>, která
lze v&nbsp;aplikacích napsaných v&nbsp;programovacím jazyce <i>Clojure</i>
vyu¾ít:</p>

<table>
<tr><th>#</th><th>Makro</th><th>Název</th><th>Význam</th></tr>
<tr><td>1</td><td>; </td><td>comment</td><td>umo¾òuje obejít zápis <i>(comment nìjaký text)</i> u komentáøù</td></tr>
<tr><td>2</td><td>\ </td><td>character</td><td>pou¾ívané pøi zápisu znakových literálù</td></tr>
<tr><td>3</td><td>^ </td><td>metadata</td><td>pøidání metadat k&nbsp;symbolùm, seznamùm, vektorùm, mapám a mno¾inám</td></tr>
<tr><td>4</td><td>' </td><td>quote</td><td>nahrazuje zápis <i>(quote ...)</i></td></tr>
<tr><td>5</td><td>` </td><td>syntax-quote</td><td>provádí plnou kvalifikaci symbolù + zde lze pou¾ít makra ~ a ~@</td></tr>
<tr><td>6</td><td>~ </td><td>unquote</td><td>zajistí, ¾e se vyhodnotí pouze oznaèená èást formy (= provede substituci této èásti výsledkem)</td></tr>
<tr><td>7</td><td>~@</td><td>unquote-splicing</td><td>podobné pøedchozími makru, ov¹em výsledná sekvence se vlo¾í ve formì samostatných prvkù do &bdquo;obalující&ldquo; sekvence</td></tr>
<tr><td>8</td><td>@ </td><td>deref</td><td>nahrazuje zápis <i>(deref ...)</i></td></tr>
<tr><td>9</td><td># </td><td>dispatch</td><td>má rùzné funkce: donutí reader, aby pou¾il makro z&nbsp;jiné tabulky maker</td></tr>
</table>

<p>Makro <i>dispatch</i> má ve skuteènosti nìkolik významù v&nbsp;závislosti na
tom, jaký znak je uveden ihned po køí¾ku (#):</p>

<table>
<tr><th>#</th><th>Dvojice znakù</th><th>Zpùsob pou¾ití</th><th>Význam</th></tr>
<tr><td>1</td><td>#{</td><td>#{prvky}</td><td>zápis mno¾iny</td></tr>
<tr><td>2</td><td>#"</td><td>#"regexp-pattern"</td><td>zápis regulárního výrazu</td></tr>
<tr><td>3</td><td>#'</td><td>#'var</td><td>quotování promìnných</td></tr>
<tr><td>4</td><td>#(</td><td>#(telo funkce)</td><td>zkrácený zápis anonymní funkce</td></tr>
<tr><td>5</td><td>#_</td><td>#_text</td><td>text je ignorován &ndash; alternativní zpùsob komentáøe</td></tr>
</table>

<p>Aby toho nebylo málo, má køí¾ek (hash) je¹tì jeden význam &ndash; pomocí
nìho je toti¾ mo¾né vytváøet lokální symboly s&nbsp;jednoznaèným jménem, co¾ je
problematika týkající se maker, které se budeme podrobnìji vìnovat <a
href="#k07">v&nbsp;sedmé kapitole</a>.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Generování kódu ve skriptovacích programovacích jazycích</h2>

<p>Pøed popisem tvorby u¾ivatelských maker je vhodné se zmínit o funkcích
<strong>eval</strong> a <strong>read-string</strong>, proto¾e právì
s&nbsp;vyu¾itím tìchto dvou funkcí je mo¾né ukázat zpùsob interpretace programù
v&nbsp;<i>Clojure</i> a skládání programù z&nbsp;do sebe vnoøených seznamù. Ji¾
nìkolikrát jsme si v&nbsp;tomto seriálu øekli, ¾e programovací jazyk
<i>Clojure</i>, resp.&nbsp;pøesnìji øeèeno jeho varianta urèená pro bìh nad
JVM, v&nbsp;sobì spojuje nìkteré pøednosti interpretovaných jazykù i jazykù
pøekládaných (kompilovaných). Jakýkoli výraz, neboli forma, je nejdøíve naèten
objektem <i>Reader</i>, který na zadaný vstupní text aplikuje svoje makra.
Posléze je výsledek pøedán internímu pøekladaèi, který z&nbsp;textu vytvoøí
bajtkód (pøitom mù¾e v&nbsp;pøípadì potøeby tìsnì pøed pøekladem aplikovat
u¾ivatelská makra). Vytvoøený bajtkód je následnì zpracován virtuálním strojem
Javy naprosto stejným zpùsobem jako bajtkód vzniklý pøekladem bì¾ných
Javovských zdrojových kódù.</p>

<p>Obvykle bývá vstupní zdrojový text napsaný v&nbsp;<i>Clojure</i> pøedáván
interpretru interaktivnì, tj.&nbsp;ve smyèce <i>REPL</i>, nebo je pøeklad
proveden ze zdrojových kódù, a to buï implicitnì (<i>Clojure</i> se chová jako
interpret a bajtkód je vytváøen jen v&nbsp;pamìti) nebo explicitnì (vzniknou
soubory <i>.class</i>). Ov¹em vzhledem k&nbsp;tomu, ¾e tento pøeklad (a
následné vyhodnocení formy) mù¾e probíhat a¾ v&nbsp;èase bìhu aplikace
(v&nbsp;<i>runtime</i>), je mo¾né, aby byla èást programu vytvoøena dynamicky,
napøíklad na základì dat získaných od u¾ivatele atd. Jedná se o vlastnost,
která se poprvé objevila v&nbsp;<i>LISPu</i> pøed více ne¾ padesáti lety a
programovací jazyk <i>Clojure</i> samozøejmì tuto vlastnost podporuje takté¾.
Základem této technologie je funkce <strong>eval</strong>, které se musí pøedat
korektní výraz (forma). Tato forma je funkcí <strong>eval</strong> internì
pøelo¾ena a vyhodnocena, pøièem¾ návratovou hodnotou funkce
<strong>eval</strong> je hodnota vyhodnocené formy.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Dva zpùsoby vytvoøení seznamu obsahujícího èást programu vykonaného funkcí <strong>eval</strong></h2>

<p>Dùle¾ité je nezapomenout na to, ¾e funkce <strong>eval</strong> oèekává, ¾e
jí bude pøedána korektní forma a nikoli øetìzec èi nìco podobného. Pøipomeòme
si, ¾e korektní forma je seznamem, na jeho¾ prvním místì je uveden název nìjaké
funkce (èi speciální formy), za ním¾ následují parametry této funkce. Tyto
parametry mohou být opìt rekurzivnì zapsány ve formì funkce s&nbsp;parametry.
Podívejme se nyní na pøíklad vytvoøení seznamu, který je souèasnì i korektnì
zapsanou formou. Následnì je tento seznam vyhodnocen pomocí
<strong>eval</strong>:</p>

<pre>
<i>; vytvoøení nové globální promìnné</i>
<i>; a pøiøazení SEZNAMU do této promìnné</i>
user=&gt; <strong>(def hello-code '(println "Hello world!"))</strong>
#'user/hello-code
&nbsp;
&nbsp;
<i>; hodnotu promìnné (tedy obsah seznamu)</i>
<i>; lze samozøejmì kdykoli získat</i>
user=&gt; <strong>hello-code</strong>
(println "Hello world!")
&nbsp;
&nbsp;
<i>; i kdy¾ promìnná obsahuje seznam s korektním</i>
<i>; voláním funkce, není mo¾né pou¾ít následující</i>
<i>; formu pro zavolání této funkce</i>
user=&gt; <strong>(hello-code)</strong>
ClassCastException clojure.lang.PersistentList cannot be cast to clojure.lang.IFn  user/eval1 (NO_SOURCE_FILE:3)
&nbsp;
&nbsp;
<i>; namísto toho se musí pou¾ít funkce eval</i>
user=&gt; <strong>(eval hello-code)</strong>
Hello world!
nil
&nbsp;
&nbsp;
user=&gt;
</pre>

<p>Seznam obsahující formu lze samozøejmì vytvoøit i &bdquo;dynamiètìji&ldquo;
s&nbsp;pou¾itím funkce <strong>list</strong>. Vìt¹í dynamiènost spoèívá
v&nbsp;tom, ¾e se díky <strong>ne</strong>pou¾ití makra <i>quote</i> mohou
jednotlivé prvky seznamu získat jako výsledek nìjaké jiné funkce:</p>

<pre>
<i>; vytvoøení nové globální promìnné</i>
<i>; a pøiøazení SEZNAMU do této promìnné</i>
user=&gt; <strong>(def hello-code2 (list 'println "Hello world"))</strong>
#'user/hello-code2
&nbsp;
&nbsp;
<i>; hodnotu promìnné (tedy obsah seznamu)</i>
<i>; lze samozøejmì kdykoli získat</i>
user=&gt; <strong>hello-code2</strong>
(println "Hello world")
&nbsp;
&nbsp;
<i>; i kdy¾ promìnná obsahuje seznam s korektním</i>
<i>; voláním funkce, není mo¾né pou¾ít následující</i>
<i>; formu pro zavolání této funkce</i>
user=&gt; <strong>(hello-code2)</strong>
ClassCastException clojure.lang.PersistentList cannot be cast to clojure.lang.IFn  user/eval1 (NO_SOURCE_FILE:3)
&nbsp;
&nbsp;
<i>; namísto toho se musí pou¾ít funkce eval</i>
user=&gt; <strong>(eval hello-code2)</strong>
Hello world
nil
&nbsp;
&nbsp;
user=&gt;
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Vyu¾ití funkcí <strong>eval</strong> a <strong>read-string</strong></h2>

<p><a href="#k03">V&nbsp;pøedchozí kapitole</a> jsme si øekli, ¾e do funkce
<strong>eval</strong> je mo¾né pøedat pouze korektnì zapsanou formu.
V&nbsp;nìkterých pøípadech je v¹ak urèitý výraz nebo i vìt¹í èást programù
dostupná pouze ve formì øetìzce &ndash; ten mù¾e být pøeèten napøíklad ze
souboru, zadán u¾ivatelem v&nbsp;nìjakém GUI dialogu atd. Problém nastane
v&nbsp;pøípadì, kdy se pokusíme tento øetìzec pøedat funkci
<strong>eval</strong> v&nbsp;domnìní, ¾e se pøedávaný øetìzec
&bdquo;automagicky&ldquo; bude transformovat na korektní formu a ta se následnì
vyhodnotí. Pøedpoklad, ¾e <strong>eval</strong> bude jako svùj parametr
akceptovat øetìzec, mù¾e vycházet ze zku¹eností vývojáøe s&nbsp;jinými
programovacími jazyky, kde tomu tak skuteènì mù¾e být, ov¹em
v&nbsp;<i>Clojure</i> to neplatí a pro toto chování jsou i dobré dùvody &ndash;
mimo jiné i bezpeènost (a takté¾ to, ¾e parsování øetìzce skuteènì není prací
pro <strong>eval</strong>). Podívejme se nyní, co se stane, pokud se pokusíme
nechat vyhodnotit øetìzec obsahující zápis korektní formy, ov¹em pouze
v&nbsp;textové podobì:</p>

<pre>
<i>; vytvoøení symbolu a pøiøazení hodnoty</i>
<i>; (øetìzce) k tomuto symbolu</i>
user=&gt; <strong>(def hello-code "(println \"Hello world!\")")</strong>
#'user/hello-code
&nbsp;
&nbsp;
<i>; symbol je skuteènì navázán na øetìzec</i>
user=&gt; <strong>hello-code</strong>
"(println \"Hello world!\")"
&nbsp;
&nbsp;
<i>; toto zaruèenì nebude fungovat</i>
user=&gt; <strong>(hello-code)</strong>
ClassCastException java.lang.String cannot be cast to clojure.lang.IFn  user/eval9 (NO_SOURCE_FILE:10)
&nbsp;
&nbsp;
<i>; následující zápis sice fungovat bude,</i>
<i>; ale to jen proto, ¾e se øetìzec vyhodnotí</i>
<i>; na ten samý øetìzec (co¾ asi není oèekávaný výsledek)</i>
user=&gt; <strong>(eval hello-code)</strong>
"(println \"Hello world!\")"
&nbsp;
&nbsp;
user=&gt;
</pre>

<p>Pro pøevod øetìzce na objekt zpracovatelný pomocí <strong>eval</strong> je
v¹ak mo¾né pou¾ít funkci <strong>read</strong>. Návratovou hodnotou této funkce
mù¾e být hodnota jakéhokoli typu, tj.&nbsp;napøíklad èíslo, seznam, vektor,
symbol atd. V&nbsp;øetìzci v¹ak musí být ulo¾ena textová podoba korektní formy,
jinak dojde k&nbsp;chybì:</p>

<pre>
<i>; èíslo ulo¾ené v øetìzci se pøevede na skuteènou</i>
<i>; èíselnou hodnotu</i>
user=&gt; <strong>(read-string "42")</strong>
42
&nbsp;
&nbsp;
<i>; textová podoba seznamu ulo¾eného</i>
<i>; v øetìzci se stane seznamem</i>
user=&gt; <strong>(read-string "(* 6 7)")</strong>
(* 6 7)
&nbsp;
&nbsp;
<i>; textová podoba seznamu ulo¾eného</i>
<i>; v øetìzci se stane seznamem</i>
<i>; obsahujícím podseznamy (nedojde ke zplo¹tìní seznamu)</i>
user=&gt; <strong>(read-string "(+ 1 (+ 2 (+ 3 (+ 4 5))))")</strong>
(+ 1 (+ 2 (+ 3 (+ 4 5))))
&nbsp;
&nbsp;
<i>; textová podoba vektoru ulo¾eného</i>
<i>; v øetìzci se stane seznamem</i>
user=&gt; <strong>(read-string "[1 2 3 4]")</strong>
[1 2 3 4]
&nbsp;
&nbsp;
<i>; toto v¹ak není korektní forma!!!</i>
user=&gt; <strong>(read-string "(((")</strong>
RuntimeException EOF while reading  clojure.lang.Util.runtimeException (Util.java:170)
&nbsp;
&nbsp;
user=&gt; 
</pre>

<p>Nyní ji¾ víme, jak lze z&nbsp;øetìzce získat napøíklad seznam a tento seznam
následnì vyhodnotit:</p>

<pre>
; vytvoøení symbolu a pøiøazení hodnoty
<i>; (øetìzce) k tomuto symbolu</i>
<i>user=&gt; <strong>(def hello-code "(println \"Hello world!\")")</strong></i>
#'user/hello-code
&nbsp;
&nbsp;
<i>; pøevod øetìzce na skuteèný objekt</i>
user=&gt; <strong>(read-string hello-code)</strong>
(println "Hello world!")
&nbsp;
&nbsp;
<i>; tento objekt ji¾ LZE vyhodnotit</i>
user=&gt; <strong>(eval (read-string hello-code))</strong>
Hello world!
nil
&nbsp;
&nbsp;
user=&gt;
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Tvorba jednoduchých maker s&nbsp;vyu¾itím <strong>defmacro</strong></h2>

<p>Koneènì se dostáváme k&nbsp;ústøednímu tématu tohoto èlánku &ndash;
k&nbsp;tvorbì u¾ivatelských maker. Význam u¾ivatelských maker spoèívá pøedev¹ím
v&nbsp;tom, ¾e se tato makra provedou (aplikují) pøi zpracování zadávaných
forem tìsnì pøedtím, ne¾ jsou tyto formy zkompilovány do bajtkódu. To má dva
dùsledky: makro je v&nbsp;daném místì programu vykonáno pouze jednou a navíc
makro mù¾e pracovat pøímo s&nbsp;u¾ivatelem zadanou formou bez toho, aby se
daná forma automaticky vyhodnotila. To mj.&nbsp;znamená, ¾e s&nbsp;vyu¾itím
u¾ivatelských maker lze realizovat i speciální formy, napøíklad nové typy
programových smyèek (to si uká¾eme pøí¹tì) apod. V&nbsp;následujícím textu se
budeme sna¾it vytvoøit pomìrnì jednoduché makro nazvané <strong>trace</strong>
slou¾ící k&nbsp;tomu, aby se pøi jeho pou¾ití vypisovaly na standardní výstup
<i>trasovací</i> informace o tom, jaký výraz (forma) je volána a jaká je
návratová hodnota této formy po vyhodnocení. Toto makro by tedy mìlo být pøi
zápisu:</p>

<pre>
(trace vyraz)
</pre>

<p>...expandováno (v&nbsp;první velmi nedokonalé verzi) na následující
formu:</p>

<pre>
(let [x vyraz]
    (println "vyraz = " x)
    x)
</pre>

<p>Dùvod, proè je vyu¾ita lokální promìnná je jednoduchý &ndash; hodnotu
vyhodnoceného výrazu musíme vypsat a souèasnì i vrátit (co¾ je ono
<strong>x</strong> na posledním øádku); navíc by nebylo správné výraz
vyhodnocovat dvakrát kvùli vedlej¹ím efektùm. Za <strong>vyraz</strong> je
pøitom mo¾né dosadit jakýkoli platný výraz akceptovaný interpretrem
<i>Clojure</i>, co¾ znamená, ¾e po zápisu:</p>

<pre>
(trace (* 6 7))
</pre>

<p>By se mìla ve skuteènosti vytvoøit (v&nbsp;<i>compile time</i>) a následnì
v&nbsp;èase bìhu (<i>runtime</i>) vyhodnotit tato forma:</p>

<pre>
(let [x (* 6 7)]
    (println "(* 6 7)=" x)
    x)
</pre>

<p>Resp. pravdìpodobnì spí¹e následující forma:</p>

<pre>
(let [x (* 6 7)]
    (println (quote (* 6 7)) "=" x)
    x)
</pre>

<p>(pøipomeòme si, ¾e <strong>quote</strong> se obvykle zapisuje pomocí
apostrofu, co¾ v¹ak zde nebude mo¾né, proto¾e pøedchozí výraz budeme
<i>konstruovat</i> jako seznam a nikoli zapisovat z&nbsp;klávesnice).</p>

<p>Vygenerování výrazu odpovídajícího po¾adovanému chování
<strong>trace</strong> vlastnì není pøíli¹ slo¾ité, kdy¾ si pøipomeneme, jak
jsme výrazy vytváøeli v&nbsp;pøedchozích dvou kapitolách. Staèí si uvìdomit, ¾e
apostrofy zaká¾ou vyhodnocení symbolu, který je zapsán ihned za apostrofem a
funkce <strong>list</strong> slou¾í k&nbsp;vytvoøení seznamu z&nbsp;prvkù,
které jsou funkci <strong>list</strong> pøedány, tj.&nbsp;zápis <strong>(list a
b c)</strong> vrátí seznam <strong>(a b c)</strong>:</p>

<pre>
(defn gen-trace [vyraz]
    (list
        'let ['x vyraz]
        (list 'println (list 'quote vyraz) "=" 'x)
        'x))
</pre>

<p>Chování tohoto &bdquo;generátoru výrazù <strong>trace</strong>&ldquo; si
mù¾eme jednodu¹e otestovat:</p>

<pre>
user=&gt; <strong>(gen-trace 42)</strong>
(let [x 42] (println (quote 42) "=" x) x)
&nbsp;
&nbsp;
<i>; pozor na to, ¾e musíme zabránit vyhodnocení</i>
<i>; symbolù, které pøedáváme generátoru výrazù</i>
<i>; (nejedná se o speciální formu)</i>
user=&gt; <strong>(gen-trace 'x)</strong>
(let [x x] (println (quote x) "=" x) x)
&nbsp;
&nbsp;
<i>; pozor na to, ¾e musíme zabránit vyhodnocení</i>
<i>; symbolù, které pøedáváme generátoru výrazù</i>
<i>; (nejedná se o speciální formu)</i>
user=&gt; <strong>(gen-trace '(* 6 7))</strong>
(let [x (* 6 7)] (println (quote (* 6 7)) "=" x) x)
&nbsp;
&nbsp;
user=&gt;
</pre>

<p>Podle pøedchozích testù mù¾eme usoudit, ¾e generátor vytváøí korektní kód
(formu), tudí¾ lze jeho výstup &ndash; onen vygenerovaný seznam &ndash; pøedat
funkci <i>eval</i>:</p>

<pre>
user=&gt; <strong>(eval (gen-trace '(* 6 7)))</strong>
(* 6 7) = 42
42
user=&gt;
</pre>

<p>Opìt se zdá, ¾e v¹e je v&nbsp;poøádku, tak¾e zbývá udìlat dal¹í krok &ndash;
vytvoøit skuteèné u¾ivatelské makro. To je velmi jednoduché, proto¾e postaèuje
namísto <strong>defn</strong> (definice funkce) pou¾ít
<strong>defmacro</strong> (definice makra). Výsledkem je objekt aplikovaný
v&nbsp;èase zadávání nových forem, co¾ nám umo¾ní pøedávat makru výrazy bez
nutnosti jejich quotování (uvození pomocí znaku apostrof nebo
<strong>quote</strong>):</p>

<pre>
(defn gen-trace [vyraz]
    (list
        'let ['x vyraz]
        (list 'println (list 'quote vyraz) "=" 'x)
        'x))
&nbsp;
&darr;&nbsp;&darr;&nbsp;&darr;
&darr;&nbsp;&darr;&nbsp;&darr;
&darr;&nbsp;&darr;&nbsp;&darr;
&nbsp;
(defmacro trace [vyraz]
    (list
        'let ['x vyraz]
        (list 'println (list 'quote vyraz) "=" 'x)
        'x))
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Expanze maker: <strong>macroexpand-1</strong> a <strong>macroexpand</strong></h2>

<p>Tvar makra vytvoøeného na konci pøedchozí kapitoly sice je¹tì není koneèný
(a to hned z&nbsp;nìkolika dùvodù), ov¹em ji¾ nyní je mo¾né toho makro
otestovat na nìkolika jednoduchých demonstraèních pøíkladech. Pokud nìjaký
korektní výraz &bdquo;obalíme&ldquo; voláním makra <strong>trace</strong>, mìl
by se na standardní výstup vypsat tvar tohoto výrazu a za znakem = pak i jeho
hodnota. Nakonec se tato hodnota i vrátí jako výsledek, co¾ znamená, ¾e makro
<strong>trace</strong> mù¾eme vkládat pøímo do programového kódu, ani¾ by to
tento kód nìjak naru¹ilo, pokud samozøejmì budeme akceptovat vedlej¹í efekt,
který makro provádí:</p>

<pre>
<i>; nejprve zadáme interpretru tvar makra</i>
<strong>(defmacro trace [vyraz]</strong>
<strong>    (list</strong>
<strong>        'let ['x vyraz]</strong>
<strong>        (list 'println (list 'quote vyraz) "=" 'x)</strong>
<strong>        'x))</strong>
&nbsp;
&nbsp;
<i>; otestování makra na hodnotì</i>
user=&gt; <strong>(trace 42)</strong>
42 = 42
42
&nbsp;
&nbsp;
<i>; otestování makra na quotovaném symbolu</i>
<i>; (do¹lo zde pouze k expanzi reader makra)</i>
user=&gt; <strong>(trace '42)</strong>
(quote 42) = 42
42
&nbsp;
&nbsp;
<i>; otestování makra na volání funkce</i>
user=&gt; <strong>(trace (* 6 7))</strong>
(* 6 7) = 42
42
&nbsp;
&nbsp;
<i>; otestování makra na volání slo¾itìj¹í funkce</i>
user=&gt; <strong>(trace (list (range 1 10) (range 20 30)))</strong>
(list (range 1 10) (range 20 30)) = ((1 2 3 4 5 6 7 8 9) (20 21 22 23 24 25 26 27 28 29))
((1 2 3 4 5 6 7 8 9) (20 21 22 23 24 25 26 27 28 29))
&nbsp;
&nbsp;
user=&gt;
</pre>

<p>Jak pøi tvorbì nových u¾ivatelských maker, tak i pøi pou¾ívání ji¾
vytvoøených maker, které jsou souèástí knihoven programovacího jazyka
<i>Clojure</i> je mnohdy dùle¾ité prozkoumat, jak bylo makro expandováno,
tj.&nbsp;jakým zpùsobem zmìnilo výraz, který byl makru pøedán. Pro tyto úèely
lze vyu¾ít dvojici funkcí nazvaných <strong>macroexpand</strong> a
<strong>macroexpand-1</strong>. Funkce <strong>macroexpand-1</strong>, které se
pøedá volání makra (jde o funkci, tak¾e je zapotøebí volání zkoumaného makra
quotovat!), vrátí expandovaný tvar makra, tj.&nbsp;formu, která je dále
zpracována. Pøitom se provádí v¾dy jen expanze prvnì aplikovaného makra. Jedná
se o funkci, která se velmi èasto pou¾ívá pøi ladìní u¾ivatelských maker,
proto¾e nás vìt¹inou nezajímá, jak se expandují dal¹í makra (napøíklad
<strong>when</strong> apod.) pou¾itá v&nbsp;expandovaném výrazu. Pokud je
z&nbsp;nìjakého dùvodu nutné vidìt celou expanzi výrazu a¾ do té míry,
v&nbsp;jaké je výraz pøedán pøekladaèi, lze pro tento úèel pou¾ít funkci
nazvanou <strong>macroexpand</strong> (její chování velmi zhruba odpovídá
chování preprocesoru jazyka C èi C++, který takté¾ vrátí v¹echna makra
rekurzivnì expandovaná).</p>

<p>Podívejme se, jak funkce <strong>macroexpand-1</strong> expanduje na¹e makro
<strong>trace</strong>:</p>

<pre>
user=&gt; <strong>(macroexpand-1 '(trace 42))</strong>
(let [x 42] (println (quote 42) "=" x) x)
&nbsp;
&nbsp;
user=&gt; <strong>(macroexpand-1 '(trace '42))</strong>
(let [x (quote 42)] (println (quote (quote 42)) "=" x) x)
&nbsp;
&nbsp;
user=&gt; <strong>(macroexpand-1 '(trace (* 6 7)))</strong>
(let [x (* 6 7)] (println (quote (* 6 7)) "=" x) x)
&nbsp;
&nbsp;
user=&gt; <strong>(macroexpand-1 '(trace (list (range 1 10) (range 20 30))))</strong>
(let [x (list (range 1 10) (range 20 30))] (println (quote (list (range 1 10) (range 20 30))) "=" x) x)
user=&gt;
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Pou¾ití reader maker &bdquo;syntax-quote&ldquo; a &bdquo;unquote&ldquo; pøi tvorbì u¾ivatelských maker</h2>

<p>Podívejme se je¹tì jednou na výraz, na který jsme chtìli expandovat zápis
<strong>(trace vyraz)</strong>:</p>

<pre>
(let [x vyraz]
    (println (quote vyraz) " = " x)
    x)
</pre>

<p>Abychom vytvoøili tento výraz ve formì rekurzivnì zanoøeného seznamu,
definovali jsme makro <strong>trace</strong> s&nbsp;následující podobou:</p>

<pre>
(defmacro trace [vyraz]
    (list
        'let ['x vyraz]
        (list 'println (list 'quote vyraz) "=" 'x)
        'x))
</pre>

<p>Toto makro sice v&nbsp;rámci mo¾ností funguje (a¾ na nìkolik chybièek),
ov¹em zpùsob jeho zápisu a vlastnì i zpùsob jeho vytvoøení je, eufemicky
øeèeno, pomìrnì nehezký :-) Proè tomu tak je je zøejmé &ndash; ve vytváøeném
seznamu jsme museli v¹echny funkce quotovat, seznam se musel explicitnì
vytváøet s&nbsp;vyu¾itím funkce <strong>list</strong> atd. Bylo by urèitì
mnohem zajímavìj¹í, jednodu¹¹í a souèasnì i elegantnìj¹í mít mo¾nost zápisu
makra ve formì jakési ¹ablony, do ní¾ by se pouze dosazovaly èásti pùvodního
výrazu pøedaného makru pro expanzi. Po¾adavek na snadnou formu makra pomocí
&bdquo;¹ablony&ldquo; ve skuteènosti není nijak nový, proto¾e se zaèal
objevovat ji¾ záhy po vytvoøení programovacího jazyka <i>LISP</i>,
tj.&nbsp;pøed zhruba padesáti lety. Tvùrci rùzných variant <i>LISPu</i> se
tomuto po¾adavku sna¾ili vyhovìt rùznými zpùsoby; my si v&nbsp;následujícím
textu øekneme, jak je tomu v&nbsp;pøípadì <i>Clojure</i>. Vylep¹ený &ndash; a
nutno øíci, ¾e prozatím nefunkèní &ndash; tvar makra <strong>trace</strong>
mù¾e vypadat následovnì:</p>

<pre>
(defmacro trace2 [vyraz]
  `(let [x ~vyraz] (println '~vyraz "=" x) x))
</pre>

<p>Co se vlastnì zmìnilo? Ji¾ zde nepou¾íváme nepìkný zpùsob vytváøení seznamu
s&nbsp;vyu¾itím funkcí <strong>list</strong> a quotovaných jmen volaných funkcí
a speciálních forem (konkrétnì <strong>let</strong>, <strong>println</strong> a
<strong>quote</strong>). Namísto toho je po¾adovaný výsledný tvar makra
jednodu¹e zapsán a pøed tento zápis je vlo¾en znak zpìtného apostrofu, který se
v&nbsp;objektu <i>Reader</i> pøepí¹e (expanduje) jako makro
&bdquo;syntax-quote&ldquo;, jeho¾ funkci jsme si popsali ji¾ v&nbsp;pøedchozí
èásti tohoto seriálu. Ov¹em pouze s&nbsp;aplikací &bdquo;syntax-quote&ldquo; se
daleko nedostaneme, proto¾e ve skuteènosti potøebujeme hned na dvou místech do
makra vlo¾it vstupní výraz. Aby to bylo mo¾né, je uvnitø
&bdquo;syntax-quote&ldquo; pou¾ita tilda, neboli <i>reader makro</i> nazvané
&bdquo;dequote&ldquo;, které pro nejbli¾¹í následující symbol ru¹í funkci
quotování. Pøedchozí vìta sice mù¾e znít slo¾itì, ale pøi praktickém pou¾ití
nám postaèuje vìdìt, ¾e pokud v&nbsp;makru potøebujeme pou¾ít parametr tohoto
makra, zapisuje se pøed nìj tilda, proto¾e v&nbsp;opaèném pøípadì by se namísto
konkrétního obsahu tohoto parametru v&nbsp;makru pouze pou¾ilo jeho jméno.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Problém s&nbsp;vytváøením lokálních (unikátních) symbolù a øe¹ení tohoto problému</h2>

<p>Nezbývá, ne¾ na¹e nové makro, o nìm¾ jsem napsal, ¾e je nefunkèní,
vyzkou¹et. Nejprve ho nadefinujeme:</p>

<pre>
user=&gt; <strong>(defmacro trace2 [vyraz]</strong>
  `(let [x ~vyraz] (println '~vyraz "=" x) x))
#'user/trace2
&nbsp;
&nbsp;
user=&gt;
</pre>

<p>Poté se ho pokusíme pou¾ít na expanzi jednoduchého výrazu 42:</p>

<pre>
user=&gt; <strong>(trace2 42)</strong>
CompilerException java.lang.RuntimeException: Can't let qualified name: user/x, compiling:(NO_SOURCE_PATH:110) 
&nbsp;
&nbsp;
user=&gt;
</pre>

<p>Co se vlastnì stalo? Pøekladaè <i>Clojure</i> si stì¾uje na to, ¾e nezná
symbol <strong>user/x</strong>, co¾ je zajisté pravda, proto¾e jsme takový
symbol (globální pro celý jmenný prostor <strong>user</strong>) nevytváøeli.
Zde jsme se vlastnì nepøímo dotkli jedné chyby v&nbsp;pùvodním makru &ndash;
nefungovalo by správnì ve chvíli, kdyby bylo pou¾ito v&nbsp;souvislosti
s&nbsp;výrazem pou¾ívajícím symbol <strong>x</strong>. Pøekladaè <i>Clojure</i>
si v&nbsp;tomto pøípadì stì¾uje z&nbsp;toho dùvodu, ¾e
&bdquo;syntax-quote&ldquo; kromì dal¹ích manipulací se svým vstupem nahrazuje
jména v¹ech symbolù jejich plnými jmény, tj.&nbsp;napøíklad doplòuje názvy
jmenných prostorù atd. To je zajisté výhodné pøi pou¾ití makra v&nbsp;jiném
jmenném prostoru. Jak expanze vypadá?:</p>

<pre>
user=&gt; <strong>(macroexpand-1 '(trace2 42))</strong>
(clojure.core/let [user/x 42] (clojure.core/println (quote 42) "=" user/x) user/x)
&nbsp;
&nbsp;
user=&gt;
</pre>

<p>Aby makro fungovalo správnì, musíme umìt vytvoøit lokální symbol
s&nbsp;unikátním jménem. Pro tento úèel se pou¾ívá (tak jako v&nbsp;mnoha
dal¹ích situacích) znak køí¾ku zapisovaný <strong>ZA</strong> nìjakým symbolem.
<i>Clojure</i> zápis <strong>symbol#</strong> expanduje na
<strong>symbol_generované_jmeno</strong>, které bude unikátní, co¾ je pøesnì
to, co potøebujeme. Ve tøetí verzi na¹eho makra tedy nahradíme
<strong>x</strong> za <strong>x#</strong>:</p>

<pre>
(defmacro trace3 [vyraz]
  `(let [x# ~vyraz] (println '~vyraz "=" x#) x#))
</pre>

<p>Bude to fungovat?:</p>

<pre>
<i>; vytvoøíme nové makro</i>
user=&gt; <strong>(defmacro trace3 [vyraz]</strong>
<strong>  `(let [x# ~vyraz] (println '~vyraz "=" x#) x#))</strong>
#'user/trace3
&nbsp;
&nbsp;
<i>; otestujeme ho na jednoduchém volání funkce</i>
user=&gt; <strong>(trace3 (* 6 7))</strong>
(* 6 7) = 42
42
&nbsp;
&nbsp;
<i>; finito</i>
</pre>

<p>Na závìr se je¹tì podíváme na expanzi tøetí verze na¹eho makra. Zejména nás
bude zajímat, jak byl expandován zápis x#:</p>

<pre>
user=&gt; <strong>(macroexpand-1 '(trace3 (* 6 7)))</strong>
(clojure.core/let [x__165__auto__ (* 6 7)] (clojure.core/println (quote (* 6 7)) "=" x__165__auto__) x__165__auto__)
</pre>

<p>Je zøejmé, ¾e symbol <strong>x__165__auto__</strong> je jak lokální, tak i
unikátní (to mo¾ná zøejmé není, ale je tomu tak :-), co¾ je pøesnì to, co
potøebujeme.</p>

<p>Pøí¹tì si uká¾eme, jak u¾ivatelská makra vyu¾ít praktiètìj¹ím zpùsobem.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Eulerovo èíslo<br />
<a href="http://cs.wikipedia.org/wiki/Eulerovo_èíslo">http://cs.wikipedia.org/wiki/Eulerovo_èíslo</a>
</li>

<li>List comprehension<br />
<a href="http://en.wikipedia.org/wiki/List_comprehension">http://en.wikipedia.org/wiki/List_comprehension</a>
</li>

<li>List Comprehensions in Clojure<br />
<a href="http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html">http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html</a>
</li>

<li>Clojure Programming Concepts: List Comprehension<br />
<a href="http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension">http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension</a>
</li>

<li>Clojure core API: for macro<br />
<a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for">http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for</a>
</li>

<li>cirrus machina - The Clojure for macro<br />
<a href="http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/">http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/</a>
</li>

<li>Clojure.org: Clojure home page<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>A Couple of Clojure Agent Examples<br />
<a href="http://lethain.com/a-couple-of-clojure-agent-examples/">http://lethain.com/a-couple-of-clojure-agent-examples/</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/">http://java.sun.com/developer/technicalArticles/DynTypeLang/</a>
</li>

<li>JSR 223: Scripting for the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=223">http://jcp.org/en/jsr/detail?id=223</a>
</li>

<li>JSR 292: Supporting Dynamically Typed Languages on the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=292">http://jcp.org/en/jsr/detail?id=292</a>
</li>

<li>Java 7: A complete invokedynamic example<br />
<a href="http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html">http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html</a>
</li>

<li>InvokeDynamic: Actually Useful?<br />
<a href="http://blog.headius.com/2007/01/invokedynamic-actually-useful.html">http://blog.headius.com/2007/01/invokedynamic-actually-useful.html</a>
</li>

<li>A First Taste of InvokeDynamic<br />
<a href="http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html">http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html</a>
</li>

<li>Java 6 try/finally compilation without jsr/ret<br />
<a href="http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html">http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Root.cz: Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM<br />
<a href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/</a></a>
</li>

<li>Root.cz: JamVM aneb alternativa k HotSpotu nejenom pro embedded zaøízení a chytré telefony<br />
<a href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>FindBugs<br />
<a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a>
</li>

<li>GNU Classpath<br />
<a href="www.gnu.org/s/classpath/">www.gnu.org/s/classpath/</a></li>

<li>Java VMs Compared<br />
<a href="http://bugblogger.com/java-vms-compared-160/">http://bugblogger.com/java-vms-compared-160/</a>
</li>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Scala Programming Language<br />
<a href="http://www.scala-lang.org/">http://www.scala-lang.org/</a>
</li>

<li>Run Scala in Apache Tomcat in 10 minutes<br />
<a href="http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes">http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes</a>
</li>

<li>Fast Web Development With Scala<br />
<a href="http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html">http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html</a>
</li>

<li>Top five scripting languages on the JVM<br />
<a href="http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855">http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>CloseableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html">http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

