<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - je grafický subsystém Javy vhodný pro 2D hry?</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - je grafický subsystém Javy vhodný pro 2D hry?</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Dne¹ní èást seriálu o programovacím jazyce Java i o virtuálním stroji Javy pojednává o problematice grafického subsystému Javy, zejména s ohledem na tvorbu 2D her popø. interaktivních programù èi dem. Ukazuje se, ¾e pøi volbì správných technik lze i v této oblasti dosáhnout uspokojivých výsledkù srovnatelných s jinými technologiemi (SDL, PyGame atd.).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - je grafický subsystém Javy vhodný pro 2D hry?</a></p>
<p><a href="#k02">2. Práce s&nbsp;bitmapami a nìkteré pøíèiny nízkého grafického výkonu aplikací psaných v&nbsp;Javì</a></p>
<p><a href="#k03">3. Zápis pixelù do bitmap typu <strong>BufferedImage</strong>: tøi úrovnì abstrakce</a></p>
<p><a href="#k04">4. Demonstraèní benchmark &ndash; vytvoøení rastrového obrázku s&nbsp;gradientním pøechodem</a></p>
<p><a href="#k05">5. Nejvy¹¹í úroveò abstrakce pøi zápisu pixelù: metoda BufferedImage.setRGB()</a></p>
<p><a href="#k06">6. Støední úroveò abstrakce pøi zápisu pixelù: metoda WritableRaster.setPixel()</a></p>
<p><a href="#k07">7. Vylep¹ení pøedchozí metody</a></p>
<p><a href="#k08">8. Ni¾¹í úroveò abstrakce: objekt DataBuffer a metoda DataBuffer.setElem()</a></p>
<p><a href="#k09">9. Výsledky bìhu demonstraèního benchmarku</a></p>
<p><a href="#k10">10. Úplný zdrojový kód demonstraèního benchmarku</a></p>
<p><a href="#k11">11. Repositáø se zdrojovými soubory demonstraèního benchmarku</a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - je grafický subsystém Javy vhodný pro 2D hry?</h2>

<p>V&nbsp;dne¹ní èásti seriálu o programovacím jazyce Java i o virtuálním
stroji tohoto jazyka se budeme zabývat nìkterými problémy, které musí vývojáøi
øe¹it pøi programování 2D her, popø.&nbsp;rùzných aplikací vy¾adujících pou¾ití
interaktivní 2D grafiky a animací. Platforma Javy toti¾ dává programátorùm
k&nbsp;dispozici pomìrnì velké mno¾ství balíèkù a knihoven pro práci s&nbsp;2D
grafikou, co¾ v¹ak mù¾e ve výsledku mít (ponìkud paradoxnì) negativní dopad na
výkon vytváøených aplikací v&nbsp;pøípadì, ¾e vývojáø zvolí nesprávný postup
popø.&nbsp;napøíklad zbyteènì pou¾ije vysokoúrovòové grafické operace nebo
vytvoøí takové formáty bitmap, pøi jejich¾ vykreslování nebude mo¾né vyu¾ít
operací nabízených grafickými akcelerátory. Ukazuje se v¹ak, ¾e minimálnì
v&nbsp;pøípadì JDK6 a JDK7 lze pøi pou¾ití správných postupù v&nbsp;Javì
dosáhnout takové rychlosti vykreslování, která je srovnatelná napøíklad
s&nbsp;knihovnou SDL popø.&nbsp;s&nbsp;2D funkcemi dostupnými v&nbsp;DirectX
(poznámka: existuje i mo¾nost volání funkcí SDL pøímo z&nbsp;javovských
programù, to v¹ak není zcela jednoduché a takté¾ dosa¾ená rychlost vykreslování
není kvùli pou¾ití rozhraní JNI ideální).</p>

<p>V&nbsp;následujícím textu (zejména pak v&nbsp;navazující èásti seriálu) se
zamìøíme pøedev¹ím na ty grafické operace, které lze najít v&nbsp;typických 2D
hrách. Bude se tedy jednat o vytváøení a vykreslování bitmap, vyu¾ití pamìti
grafické karty èi grafického akcelerátoru pro ukládání bitmap, nastavení
grafického re¾imu (s&nbsp;exkluzivním pøístupem ke framebufferu) atd.
Problematikou tvorby grafického u¾ivatelského rozhraní èi vysokoúrovòovými
grafickými operacemi se zabývat (alespoò prozatím) <strong>ne</strong>budeme,
proto¾e jak pou¾ití GUI (èi vùbec vykreslování do okna) tak i operace nabízené
rozhraními <i>Graphics</i> a <i>Graphics2D</i> vìt¹inou nejsou pro tvorbu
interaktivních 2D her vhodné, i kdy¾ i zde mù¾e JVM v&nbsp;nìkterých pøípadech
vyu¾ít mo¾nosti grafických akcelerátorù (paradoxnì jsou mnohdy tyto
vysokoúrovòové operace pou¾ity v&nbsp;appletech, jejich¾ slabý grafický výkon
pak mnohdy vede k&nbsp;odsouzení celé platformy Javy jako¾to technologie zcela
nevhodné pro tvorbu her).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Práce s&nbsp;bitmapami a nìkteré pøíèiny nízkého grafického výkonu aplikací psaných v&nbsp;Javì</h2>

<p>Typické 2D hry jsou zalo¾eny na neustálém vykreslování bitmap. Bitmapy jsou
napøíklad pou¾ity ve funkci <i>spritù</i>, tj.&nbsp;rastrových obrázkù
s&nbsp;prùhlednými èi prùsvitnými pixely. Sprity jsou pou¾ity pro reprezentaci
objektù ve høe, mnohdy se v¹ak pou¾ívají i pro tisk znakù atd. Bitmapy jsou ale
i cílem ve¹kerých vykreslovacích operací, proto¾e i vlastní framebuffer
(k&nbsp;nìmu¾ mù¾eme mít pøímo z&nbsp;Javy pøístup) je reprezentován bitmapou.
Souèasné verze JDK doká¾ou pøi vykreslování bitmap vyu¾ít operace nabízené
grafickými akcelerátory (jedná se o operaci typu <i>BitBLT/blit</i>) a dokonce
mohou programátorovi nabídnout pøístup do framebufferu, prohazování pøedního a
zadního bufferu (<i>front buffer</i>, <i>back buffer</i>) atd. &ndash; ov¹em
jen v&nbsp;tom pøípadì, ¾e programátor dodr¾í nìkterá pravidla. Pøedev¹ím je
nutné v¹echny bitmapy, s&nbsp;nimi¾ se pracuje, vytvoøit ve formátu
kompatibilním s&nbsp;formátem framebufferu &ndash; to ostatnì není ¾ádná umìle
zavedená podmínka, ale setkáme se s&nbsp;ní i v&nbsp;ji¾ zmínìné knihovnì
<i>SDL</i>.</p>

<p>Dále je nutné zabránit tomu, aby se mìnil obsah bitmap zmìnou jednotlivých
pixelù nebo pøes rozhraní <i>Graphics/Graphics2D</i>. Pokud by toti¾
k&nbsp;tìmto operacím do¹lo, ztratila by se jedna z&nbsp;nejvìt¹ích výhod
nabízených grafickými kartami a akcelerátory: mo¾nost mít bitmapu ulo¾enou
pøímo v&nbsp;obrazové pamìti, tak¾e se pøi operacích typu <i>BitBLT/blit</i>
nebudou muset data pøená¹et po sbìrnici z&nbsp;hlavní pamìti do grafické karty,
ale namísto toho se vyu¾ije obecnì velmi rychlá (a ¹iroká) interní sbìrnice na
akcelerátoru. Sice se to mù¾e na první pohled zdát tro¹ku podivné, ale i tuto
podmínku je mo¾né v&nbsp;naprosté vìt¹inì 2D her relativnì snadno splnit.</p>

<p>Poznámka: význam výrazu <strong>BitBLT</strong> je následující:</p>

<p>Tato zkratka byla poprvé pou¾ita pøi programování systému poèítaèe <i>Xerox
Alto</i>, který pou¾íval pro zobrazování v¹ech informací na monitoru výhradnì
rastrovou grafiku, konkrétnì se jednalo o èernobílé bitmapové obrázky. Pøi
programování grafických rutin pro tento poèítaè a zaèleòování vytváøených rutin
do operaèního systému si autoøi programového vybavení uvìdomili, ¾e pomìrnì
velkou èást ji¾ implementovaných funkcí lze zobecnit do jediné operace, která
tyto funkce mù¾e nahradit. Tìmito autory byli Daniel Ingalls, Larry Tesler, Bob
Sproull a Diana Merry, kteøí svoji zobecnìnou rastrovou operaci pojmenovali
<strong>BitBLT</strong>, neboli <i>Bit Block Transfer</i>. První èást názvu,
tj.&nbsp;slovo <strong>Bit</strong> naznaèuje, ¾e se jedná o operaci provádìnou
nad bitmapami. Druhá polovina názvu, tj.&nbsp;zkratka <strong>BLT</strong>,
byla odvozena ze jména instrukce pro blokový pøenos dat, jen¾ byla pou¾ívaná
v&nbsp;assembleru poèítaèe <i>DEC PDP-10</i>.</p>

<img src="http://i.iinfo.cz/images/123/lang08-9.jpg" width="380" height="472" alt=" " />
<p><i>Obrázek 1: Grafické u¾ivatelské rozhraní Smalltalku na poèítaèi Xerox
Alto.</i></p>

<p>Pomocí operace <strong>BitBLT</strong> lze provádìt, jak její název
naznaèuje, blokové pøenosy bitmap nebo jejich výøezù, popø.&nbsp;v&nbsp;rámci
pøenosu nad bitmapami provádìt rùzné operace. První implementace operace
<strong>BitBLT</strong> byla pou¾ita v&nbsp;roce 1975 ve <i>Smalltalku-72</i> a
od té doby ji najdeme prakticky v&nbsp;ka¾dé implementaci tohoto programovacího
jazyka, která obsahuje i knihovny pro práci s&nbsp;grafikou (mj.&nbsp;se jedná
i o <i>Squeak</i>). Pro <i>Smalltalk-74</i> vytvoøil Daniel Ingalls
optimalizovanou variantu operace <strong>BitBLT</strong> implementovanou
v&nbsp;mikrokódu. Operace <strong>BitBLT</strong> se tak stala souèástí
operaèního systému a bylo ji mo¾né volat jak z&nbsp;assembleru, tak i
z&nbsp;programù napsaných v&nbsp;jazyce <i>BCPL</i> a samozøejmì i ze
<i>Smalltalku</i>. Posléze se díky své univerzalitì tato funkce roz¹íøila i do
mnoha dal¹ích operaèních systémù a grafických knihoven (v&nbsp;<i>SDL</i> ji
najdeme ve funkci <strong>SDL_BlitSurface()</strong>, v&nbsp;Javì zase
v&nbsp;metodì <strong>Graphics.drawImage()</strong>).</p>

<a href="http://i.iinfo.cz/images/272/lang09-16.png"><img src="http://i.iinfo.cz/images/272/lang09-16-prev.png" width="370" height="170" alt=" " /></a>
<p><i>Obrázek 2: Èást pùvodního kódu operace BitBLT naprogramované Danielem
Ingallsem.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zápis pixelù do bitmap typu <strong>BufferedImage</strong>: tøi úrovnì abstrakce</h2>

<p>V&nbsp;nìkterých aplikacích je nutné pøeèíst èi zapsat hodnotu jednotlivých
pixelù do vytvoøené bitmapy (pro jednoduchost nyní uva¾ujme bitmapy typu
<strong>BufferedImage</strong>). Tuto zdánlivì jednoduchou a pøímoèarou operaci
lze provést minimálnì na tøech úrovních abstrakce, v&nbsp;závislosti na tom,
pøes jaký typ objektu se bude k&nbsp;bitmapì a pixelùm pøistupovat. Na úrovni
nejvy¹¹í se pro ètení a zápis pixelù vyu¾ívají operace
<strong>BufferedImage.getRGB()</strong> a
<strong>BufferedImage.setRGB()</strong>. Tyto operace jsou sice snadno
pochopitelné i jednodu¹e pou¾itelné, ov¹em (co¾ asi ètenáøe tohoto èlánku
pøíli¹ nepøekvapí) se jedná o ty nejpomalej¹í metody, které lze pro práci na
úrovni jednotlivých pixelù pou¾ít.</p>

<p>Na ni¾¹í úrovni lze k&nbsp;pixelùm ulo¾eným v&nbsp;bitmapì pøistupovat pøes
metody <strong>Raster.getPixel()</strong>, <strong>Raster.getPixels()</strong>,
<strong>WritableRaster.setPixel()</strong> a
<strong>WritableRaster.setPixels()</strong>. Samotný objekt typu
<strong>Raster/WritableRaster</strong> lze získat snadno, jeliko¾ je samotná
bitmapa (<strong>BufferedImage</strong>) slo¾ena právì z&nbsp;instance toho
typu objektu, který je doplnìn o instanci objektu typu
<strong>ColorModel</strong>. Jak rychlé jsou tyto operace si uká¾eme na
benchmarku.</p>

<p>Ov¹em je dokonce mo¾né pou¾ít metodu <strong>Raster.getDataBuffer()</strong>
pro získání objektu typu <strong>DataBuffer</strong>. Zde se ji¾ nacházíme na
nejni¾¹í úrovni, proto¾e se zde pracuje s&nbsp;jednotlivými pixely, u nich¾
musíme znát formát jejich ulo¾ení (bajt, short, ...). Ve tøídì
<strong>Raster</strong> mù¾eme najít metody <strong>Raster.getElem()</strong> a
<strong>Raster.setElem()</strong>. Zda se skuteènì jedná o nejrychlej¹í mo¾ný
zpùsob pøístupu k&nbsp;jednotlivým pixelùm nám opìt prozradí benchmark.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Demonstraèní benchmark &ndash; vytvoøení rastrového obrázku s&nbsp;gradientním pøechodem</h2>

<p>Pro praktické otestování rychlosti nìkolika rùzných zpùsobù zápisu barev
pixelù byl vytvoøen následující (pomìrnì jednoúèelový) benchmark. V&nbsp;tomto
benchmarku je nejprve vytvoøena bitmapa, pøesnìji øeèeno objekt typu
<strong>BufferedImage</strong> o rozli¹ení 512&times;512 pixelù. Pro vìt¹í
pøehlednost celého benchmarku byl zvolen jeden z&nbsp;nejjednodu¹¹ích formátù
bitmapy &ndash; ka¾dý pixel je zde reprezentován jediným bajtem, jeho¾ hodnota
vyjadøuje svìtlost pixelu. Jedná se o formát
<strong>BufferedImage.TYPE_BYTE_GRAY</strong>. Benchmark následnì spustí
v&nbsp;pìti implementacích rozhraní <strong>PatternPainter</strong> metodu
<strong>fillImageByPattern()</strong>. Ka¾dá tøída implementující toto rozhraní
by mìla do pøedané bitmapy vykreslit gradientní pøechod od èerného pixelu (levý
horní roh) k&nbsp;bílým pixelùm. Vytvoøená bitmapa by mìla vypadat
následovnì:</p>

<img src="http://i.iinfo.cz/images/441/java-gfx-3.png" class="image-153981" width="512" height="512" alt="&#160;" />
<p><i>Obrázek 3: Bitmapa vytvoøená tøídami implementujícími rozhraní
<strong>PatternPainter</strong>.</i></p>

<p>Ve zdrojovém kódu benchmarku nejsou (prozatím) uvedeny jednotlivé
implementace rozhraní <strong>PatternPainter</strong>, ty budou popsány
v&nbsp;navazujících kapitolách:</p>

<pre>
import java.awt.Color;
import java.awt.color.ColorSpace;
import java.awt.image.BufferedImage;
import java.awt.image.DataBuffer;
import java.awt.image.WritableRaster;
import java.io.File;
import java.io.IOException;
&nbsp;
import javax.imageio.ImageIO;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Rozhrani implementovane vsemi tridami, ktere dokazou vykreslit</i>
<i> * do bitmapy gradientni prechod.</i>
<i> */</i>
interface <strong>PatternPainter</strong> {
    public void fillImageByPattern(BufferedImage image);
}
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Test rychlosti ruznych zpusobu zapisu barev pixelu do rastroveho</i>
<i> * obrazku.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>ImageRendererTest</strong> {
    <i>/**</i>
<i>     * Implementace jednotlivych trid, ktere zapisuji pixely do rastroveho obrazku.</i>
<i>     */</i>
    private static final PatternPainter[] patternPainters = new PatternPainter[5];
&nbsp;
    static {
        patternPainters[0] = new PatternPainterVersion1();
        patternPainters[1] = new PatternPainterVersion2();
        patternPainters[2] = new PatternPainterVersion3();
        patternPainters[3] = new PatternPainterVersion4();
        patternPainters[4] = new PatternPainterVersion5();
    }
&nbsp;
    <i>/**</i>
<i>     * Prefix jmena souboru s vygenerovanou bitmapou.</i>
<i>     */</i>
    private static final String <strong>OUTPUT_FILE_NAME_PREFIX</strong> = "test";
&nbsp;
    <i>/**</i>
<i>     * Horizontalni rozmer bitmapy.</i>
<i>     */</i>
    private static final int <strong>IMAGE_HEIGHT</strong> = 512;
&nbsp;
    <i>/**</i>
<i>     * Vertikalni rozmer bitmapy.</i>
<i>     */</i>
    private static final int <strong>IMAGE_WIDTH</strong> = 512;
&nbsp;
    <i>/**</i>
<i>     * Pocet iteraci zahrivaci faze benchmarku.</i>
<i>     */</i>
    private static final int <strong>WARMUP_ITERS</strong> = 10;
&nbsp;
    <i>/**</i>
<i>     * Pocet iteraci merene faze benchmarku.</i>
<i>     */</i>
    private static final int <strong>BENCHMARK_ITERS</strong> = 2;
&nbsp;
    <i>/**</i>
<i>     * Vytvoreni nove bitmapy se stupni sedi.</i>
<i>     *</i>
<i>     * @return nove vytvorena bitmapa</i>
<i>     */</i>
    private static BufferedImage <strong>createEmptyImage</strong>() {
        return new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_BYTE_GRAY);
    }
&nbsp;
    <i>/**</i>
<i>     * Zapis bitmapy na disk ve formatu PNG.</i>
<i>     * </i>
<i>     * @param image</i>
<i>     *            testovaci bitmapa</i>
<i>     * @throws IOException</i>
<i>     */</i>
    private static void <strong>writeImageIntoFile</strong>(BufferedImage image, String fileName) throws IOException {
        ImageIO.write(image, "png", new File(fileName));
    }
&nbsp;
    <i>/**</i>
<i>     * Zahrivaci faze benchmarku.</i>
<i>     */</i>
    private static void <strong>warmup</strong>() throws IOException {
        System.out.print("warmup begin  ");
        for (int i = 0; i &lt; WARMUP_ITERS; i++) {
            System.out.print(" " + i);
            for (PatternPainter painter : patternPainters) {
                warmup(painter);
            }
        }
        System.out.println();
    }
&nbsp;
    <i>/**</i>
<i>     * Zahrivaci faze benchmarku volana pro kazdy PatternPainter.</i>
<i>     */</i>
    private static void <strong>warmup</strong>(PatternPainter patternPainter) {
        <i>// vytvoreni bitmapy</i>
        BufferedImage image = createEmptyImage();
&nbsp;
        <i>// vyplneni bitmapy vzorkem</i>
        patternPainter.fillImageByPattern(image);
    }
&nbsp;
    <i>/**</i>
<i>     * Vlastni benchmark.</i>
<i>     */</i>
    private static void <strong>benchmark</strong>() throws IOException {
        for (int i = 0; i &lt; BENCHMARK_ITERS; i++) {
            System.out.println("benchmark #" + i + " begin");
            int j = 0;
            for (PatternPainter painter : patternPainters) {
                benchmark(painter, ++j);
            }
        }
    }
&nbsp;
    <i>/**</i>
<i>     * Benchmark volany pro kazdy PatternPainter.</i>
<i>     */</i>
    private static void <strong>benchmark</strong>(PatternPainter patternPainter, int testNumber) throws IOException {
        <i>// vytvoreni bitmapy</i>
        BufferedImage image = createEmptyImage();
&nbsp;
        <i>// cas zacatku vypoctu</i>
        long t1 = System.nanoTime();
&nbsp;
        <i>// vyplneni bitmapy vzorkem</i>
        patternPainter.fillImageByPattern(image);
&nbsp;
        <i>// cas konce vypoctu</i>
        long t2 = System.nanoTime();
        System.out.println("Method #" + testNumber + ": " + (t2-t1) + " ns");
&nbsp;
        <i>// zapis bitmapy na disk pro pozdejsi kontrolu</i>
        writeImageIntoFile(image, OUTPUT_FILE_NAME_PREFIX + testNumber + ".png");
    }
&nbsp;
    <i>/**</i>
<i>     * Spusteni benchmarku.</i>
<i>     *</i>
<i>     * @param args</i>
<i>     * @throws IOException</i>
<i>     */</i>
    public static void <strong>main</strong>(String[] args) throws IOException {
        warmup();
        benchmark();
    }
&nbsp;
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Nejvy¹¹í úroveò abstrakce pøi zápisu pixelù: metoda BufferedImage.setRGB()</h2>

<p>Na nejvy¹¹í úrovni abstrakce lze pro zápis barev jednotlivých pixelù pou¾ít
metodu <strong>BufferedImage.setRGB()</strong>. Tato metoda je sice velmi
jednoduchá na pou¾ití, ov¹em je takté¾ nejpomalej¹í, a to zejména z&nbsp;toho
dùvodu, ¾e se vìt¹inou provádí i pøevod mezi barvovými prostory, jeliko¾ metoda
<strong>BufferedImage.setRGB()</strong> oèekává, ¾e barvy pixelù budou
reprezentovány vektorem v&nbsp;prostoru sRGB. To mj.&nbsp;znamená, ¾e pøi
pou¾ití lineárního pøechodu 0..255 dostaneme kvùli tomuto pøevodu mnohem tmav¹í
obrázek, ne¾ je oèekáváno. Následující kód je sice rychlej¹í, ov¹em
nepøesný:</p>

<pre>
    <i>// provest vypocet barev pixelu a jejich vykresleni</i>
    for (int y = 0; y &lt; height; y++) {
        for (int x = 0; x &lt; width; x++) {
            int gray = (x+y) &amp; 0xff;
            int rgb = (gray &lt;&lt; 16 ) | (gray &lt;&lt; 8) | (gray) | 0xff000000;
            image.setRGB(x, y, rgb);
        }
    }
</pre>

<p>Pøesnìj¹í výpoèet je <strong>velmi</strong> pomalý:</p>

<pre>
    <i>// provest vypocet barev pixelu a jejich vykresleni</i>
    for (int y = 0; y &lt; height; y++) {
        for (int x = 0; x &lt; width; x++) {
            float gray = ((x+y) &amp; 0xff)/255.0f;
            int rgb = new Color(colorSpace, new float[] {gray, gray, gray}, 1.0f).getRGB();
            image.setRGB(x, y, rgb);
        }
    }
</pre>

<p>Právì tento pomalej¹í výpoèet je implementován ve tøídì
<strong>PatternPainterVersion1</strong> pou¾ité v&nbsp;benchmarku:</p>

<pre>
<i>/**</i>
<i> * Varianta vyuzivajici metodu BufferedImage.setRGB().</i>
<i> * Poznamka: zde se navic uplatni gamma konverze.</i>
<i> */</i>
class <strong>PatternPainterVersion1</strong> implements <strong>PatternPainter</strong> {
&nbsp;
<i>    /* (non-Javadoc)</i>
<i>     * @see PatternPainter#fillImageByPattern(java.awt.image.BufferedImage)</i>
<i>     */</i>
    public void <strong>fillImageByPattern</strong>(BufferedImage image) {
        <i>// rozmery bitmapy</i>
        final int width = image.getWidth();
        final int height = image.getHeight();
        ColorSpace colorSpace = ColorSpace.getInstance(ColorSpace.CS_GRAY);
&nbsp;
        <i>// provest vypocet barev pixelu a jejich vykresleni</i>
        for (int y = 0; y &lt; height; y++) {
            for (int x = 0; x &lt; width; x++) {
                float gray = ((x+y) &amp; 0xff)/255.0f;
                int rgb = new Color(colorSpace, new float[] {gray, gray, gray}, 1.0f).getRGB();
                image.setRGB(x, y, rgb);
            }
        }
    }
}
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Støední úroveò abstrakce pøi zápisu pixelù: metoda WritableRaster.setPixel()</h2>

<p>Na støední úrovni abstrakce je pro zápis barev pixelù pou¾ita metoda
<strong>WritableRaster.setPixel()</strong>. Ponìkud obtí¾né je volání této
metody, proto¾e se vy¾aduje pøedání pole s&nbsp;barvovými slo¾kami pixelu.
V&nbsp;na¹em pøípadì bitmapy ve stupních ¹edi se pøedává jednoprvkové pole.
Naivní implementace, v&nbsp;ní¾ se pole vytváøí uvnitø smyèky, mù¾e vypadat
následovnì:</p>

<pre>
<i>/**</i>
<i> * Varianta vyuzivajici metodu WritableRaster.setPixel().</i>
<i> */</i>
class <strong>PatternPainterVersion2</strong> implements <strong>PatternPainter</strong> {
&nbsp;
<i>    /* (non-Javadoc)</i>
<i>     * @see PatternPainter#fillImageByPattern(java.awt.image.BufferedImage)</i>
<i>     */</i>
    public void <strong>fillImageByPattern</strong>(BufferedImage image) {
        <i>// rozmery bitmapy</i>
        final int width = image.getWidth();
        final int height = image.getHeight();
        WritableRaster raster = image.getRaster();
&nbsp;
        <i>// provest vypocet barev pixelu a jejich vykresleni</i>
        for (int y = 0; y &lt; height; y++) {
            for (int x = 0; x &lt; width; x++) {
                raster.setPixel(x, y, new int[] {x+y});
            }
        }
    }
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vylep¹ení pøedchozí metody</h2>

<p>Pøedchozí implementaci lze snadno vylep¹it, a to tak, ¾e se pole vytvoøí
pouze jedenkrát, ov¹em vyu¾ito bude pro zápis ka¾dého pixelu. Namísto
512&times;512=262144 alokací jednoprvkového pole se tak provede alokace jediná,
co¾ je zaruèenì rychlej¹í:</p>

<pre>
<i>/**</i>
<i> * Varianta vyuzivajici metodu WritableRaster.setPixel(),</i>
<i> * pomocne pole se vytvari vne smycky.</i>
<i> */</i>
class <strong>PatternPainterVersion3</strong> implements <strong>PatternPainter</strong> {
&nbsp;
<i>    /* (non-Javadoc)</i>
<i>     * @see PatternPainter#fillImageByPattern(java.awt.image.BufferedImage)</i>
<i>     */</i>
    public void <strong>fillImageByPattern</strong>(BufferedImage image) {
        <i>// rozmery bitmapy</i>
        final int width = image.getWidth();
        final int height = image.getHeight();
        WritableRaster raster = image.getRaster();
&nbsp;
        <i>// pole pouzite uvnitr smycky</i>
        int[] array = new int[1];
&nbsp;
        <i>// provest vypocet barev pixelu a jejich vykresleni</i>
        for (int y = 0; y &lt; height; y++) {
            for (int x = 0; x &lt; width; x++) {
                array[0] = x+y;
                raster.setPixel(x, y, array);
            }
        }
    }
}
</pre>

<p>Dal¹í vylep¹ení (jedná se skuteènì o vylep¹ení? &ndash; viz výsledky)
spoèívá v&nbsp;tom, ¾e se barvy v¹ech pixelù zapí¹ou jedinou operací, a to
pomocí metody <strong>WritableRaster.setPixels()</strong>. Nejprve je nutné
pøipravit jednodimenzionální pole obsahující hodnoty v¹ech pixelù, následnì
toto pole naplnit a pøepsat je do bitmapy:</p>

<pre>
<i>/**</i>
<i> * Varianta vyuzivajici metodu WritableRaster.setPixels().</i>
<i> */</i>
class <strong>PatternPainterVersion4</strong> implements <strong>PatternPainter</strong> {
&nbsp;
<i>    /* (non-Javadoc)</i>
<i>     * @see PatternPainter#fillImageByPattern(java.awt.image.BufferedImage)</i>
<i>     */</i>
    public void <strong>fillImageByPattern</strong>(BufferedImage image) {
        <i>// rozmery bitmapy</i>
        final int width = image.getWidth();
        final int height = image.getHeight();
        WritableRaster raster = image.getRaster();
        int[] array = new int[width * height];
&nbsp;
        <i>// provest vypocet barev pixelu</i>
        int i = 0;
        for (int y = 0; y &lt; height; y++) {
            for (int x = 0; x &lt; width; x++) {
                array[i] = x + y;
                i++;
            }
        }
&nbsp;
        <i>// provest vykresleni vsech pixelu</i>
        raster.setPixels(0, 0, width, height, array);
    }
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Ni¾¹í úroveò abstrakce: objekt DataBuffer a metoda DataBuffer.setElem()</h2>

<p>Poslední mo¾ností je vyu¾ití metody <strong>Raster.getDataBuffer()</strong>
pro získání objektu typu <strong>DataBuffer</strong>. Zde se ji¾ nacházíme na
nejni¾¹í úrovni, kde lze pro zápis barvy pixelu pou¾ít metodu
<strong>Raster.setElem()</strong>:</p>

<pre>
<i>/**</i>
<i> * Varianta vyuzivajici metodu DataBuffer.setElem().</i>
<i> */</i>
class <strong>PatternPainterVersion5</strong> implements <strong>PatternPainter</strong> {
&nbsp;
<i>    /* (non-Javadoc)</i>
<i>     * @see PatternPainter#fillImageByPattern(java.awt.image.BufferedImage)</i>
<i>     */</i>
    public void <strong>fillImageByPattern</strong>(BufferedImage image) {
        <i>// rozmery bitmapy</i>
        final int width = image.getWidth();
        final int height = image.getHeight();
&nbsp;
        <i>// ziskani objektu obsahujiciho hodnoty vsech pixelu bitmapy</i>
        DataBuffer dataBuffer = image.getRaster().getDataBuffer();
&nbsp;
        <i>// provest vypocet barev pixelu a jejich vykresleni</i>
        int i=0;
        for (int y = 0; y &lt; height; y++) {
            for (int x = 0; x &lt; width; x++) {
                dataBuffer.setElem(i, x+y);
                i++;
            }
        }
    }
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Výsledky bìhu demonstraèního benchmarku</h2>

<p>Podívejme se nyní na výsledky bìhu benchmarku získané jak pro interpret, tak
i pro JIT pøekladaèe typu klient a server. Výsledky si následnì graficky
porovnáme:</p>

<p>Re¾im interpretru (-Xint):</p>

<pre>
warmup begin   0 1 2 3 4 5 6 7 8 9
benchmark #0 begin
Method #1: 17204373742 ns
Method #2: 428374556 ns
Method #3: 347463154 ns
Method #4: 54061062 ns
Method #5: 92748380 ns
benchmark #1 begin
Method #1: 17252366434 ns
Method #2: 425173870 ns
Method #3: 348450710 ns
Method #4: 53940936 ns
Method #5: 92857052 ns
</pre>

<p>Re¾im JIT klient (-client):</p>

<pre>
warmup begin   0 1 2 3 4 5 6 7 8 9
benchmark #0 begin
Method #1: 8090542232 ns
Method #2: 38028856 ns
Method #3: 24550884 ns
Method #4: 6392992 ns
Method #5: 8662832 ns
benchmark #1 begin
Method #1: 8133280628 ns
Method #2: 36035306 ns
Method #3: 24821030 ns
Method #4: 6696940 ns
Method #5: 8680154 ns
</pre>

<p>Re¾im JIT server (-server):</p>

<pre>
warmup begin   0 1 2 3 4 5 6 7 8 9
benchmark #0 begin
Method #1: 7744233134 ns
Method #2: 29595102 ns
Method #3: 21738516 ns
Method #4: 3614426 ns
Method #5: 922184 ns
benchmark #1 begin
Method #1: 7840402342 ns
Method #2: 27052042 ns
Method #3: 19576510 ns
Method #4: 5522768 ns
Method #5: 919950 ns
</pre>

<p>Re¾im okam¾ité kompilace (-Xcomp):</p>

<pre>
warmup begin   0 1 2 3 4 5 6 7 8 9
benchmark #0 begin
Method #1: 8231745934 ns
Method #2: 53280516 ns
Method #3: 22943976 ns
Method #4: 7597056 ns
Method #5: 929728 ns
benchmark #1 begin
Method #1: 8384165306 ns
Method #2: 29740932 ns
Method #3: 22824410 ns
Method #4: 3548496 ns
Method #5: 928330 ns
</pre>

<p>Pokud budou v&nbsp;jednou grafu vyneseny i èasy bìhu operace
<strong>BufferedImage.setRGB()</strong>, jasnì vidíme, ¾e se jedná o zdaleka
nejpomalej¹í mo¾nou operaci zápisu barev pixelù, a to zcela nezávisle na tom,
zda je pou¾it interpret èi JIT pøekladaè:</p>

<img src="http://i.iinfo.cz/images/441/java-gfx-1.png" class="image-153979" width="596" height="540" alt="&#160;" />

<p>Zajímavìj¹í budou ostatní výsledky, pokud èasy bìhu operace
<strong>BufferedImage.setRGB()</strong> z&nbsp;grafu odstraníme (mìní nám toti¾
mìøítko). Zde ji¾ jsou výsledky zajímavìj¹í a ukazují, ¾e v&nbsp;re¾imu
interpretru je nejvýhodnìj¹í nejdøíve naplnit pole barvami pixelù a posléze
pou¾ít metodu <strong>Raster.setPixels()</strong>. Na druhou stranu mù¾eme
pøedpokládat, ¾e se èistý interpret nebude nikdy a nikde pou¾ívat, tak¾e se
soustøeïme na druhý, tøetí a ètvrtou skupinu sloupcù. Z&nbsp;výsledkù vyplývá,
¾e nejrychlej¹ím zpùsobem zápisu barev pixelù bude pou¾ití nejni¾¹í úrovnì
abstrakce, konkrétnì metody <strong>DataBuffer.setElem()</strong>. Výjimkou je
re¾im JIT klienta, kde je opìt naplnìní pole výhodnìj¹í, ne¾ neustále volání
metody <strong>DataBuffer.setElem()</strong> (co¾ ov¹em dává smysl, kdy¾ si
uvìdomíme, jak JIT klient NEoptimalizuje volání metod èi rozbalení smyèky).</p>

<img src="http://i.iinfo.cz/images/441/java-gfx-2.png" class="image-153980" width="479" height="545" alt="&#160;" />



<p><a name="k10"></a></p>
<h2 id="k10">10. Úplný zdrojový kód demonstraèního benchmarku</h2>

<p>Pro pøehlednost si je¹tì uvedeme kompletní zdrojový kód demonstraèního
benchmarku, vèetnì v¹ech pìti implementací rozhraní
<strong>PatternPainter</strong>:</p>

<pre>
import java.awt.Color;
import java.awt.color.ColorSpace;
import java.awt.image.BufferedImage;
import java.awt.image.DataBuffer;
import java.awt.image.WritableRaster;
import java.io.File;
import java.io.IOException;
&nbsp;
import javax.imageio.ImageIO;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Rozhrani implementovane vsemi tridami, ktere dokazou vykreslit</i>
<i> * do bitmapy gradientni prechod.</i>
<i> */</i>
interface <strong>PatternPainter</strong> {
    public void fillImageByPattern(BufferedImage image);
}
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Varianta vyuzivajici metodu BufferedImage.setRGB().</i>
<i> * Poznamka: zde se navic uplatni gamma konverze.</i>
<i> */</i>
class <strong>PatternPainterVersion1</strong> implements <strong>PatternPainter</strong> {
&nbsp;
<i>    /* (non-Javadoc)</i>
<i>     * @see PatternPainter#fillImageByPattern(java.awt.image.BufferedImage)</i>
<i>     */</i>
    public void <strong>fillImageByPattern</strong>(BufferedImage image) {
<i>        // rozmery bitmapy</i>
        final int width = image.getWidth();
        final int height = image.getHeight();
        ColorSpace colorSpace = ColorSpace.getInstance(ColorSpace.CS_GRAY);
&nbsp;
<i>        // provest vypocet barev pixelu a jejich vykresleni</i>
        for (int y = 0; y &lt; height; y++) {
            for (int x = 0; x &lt; width; x++) {
                float gray = ((x+y) &amp; 0xff)/255.0f;
                int rgb = new Color(colorSpace, new float[] {gray, gray, gray}, 1.0f).getRGB();
                image.setRGB(x, y, rgb);
            }
        }
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Varianta vyuzivajici metodu WritableRaster.setPixel().</i>
<i> */</i>
class <strong>PatternPainterVersion2</strong> implements <strong>PatternPainter</strong> {
&nbsp;
<i>    /* (non-Javadoc)</i>
<i>     * @see PatternPainter#fillImageByPattern(java.awt.image.BufferedImage)</i>
<i>     */</i>
    public void <strong>fillImageByPattern</strong>(BufferedImage image) {
<i>        // rozmery bitmapy</i>
        final int width = image.getWidth();
        final int height = image.getHeight();
        WritableRaster raster = image.getRaster();
&nbsp;
<i>        // provest vypocet barev pixelu a jejich vykresleni</i>
        for (int y = 0; y &lt; height; y++) {
            for (int x = 0; x &lt; width; x++) {
                raster.setPixel(x, y, new int[] {x+y});
            }
        }
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Varianta vyuzivajici metodu WritableRaster.setPixel(),</i>
<i> * pomocne pole se vytvari vne smycky.</i>
<i> */</i>
class <strong>PatternPainterVersion3</strong> implements <strong>PatternPainter</strong> {
&nbsp;
<i>    /* (non-Javadoc)</i>
<i>     * @see PatternPainter#fillImageByPattern(java.awt.image.BufferedImage)</i>
<i>     */</i>
    public void <strong>fillImageByPattern</strong>(BufferedImage image) {
<i>        // rozmery bitmapy</i>
        final int width = image.getWidth();
        final int height = image.getHeight();
        WritableRaster raster = image.getRaster();
&nbsp;
<i>        // pole pouzite uvnitr smycky</i>
        int[] array = new int[1];
&nbsp;
<i>        // provest vypocet barev pixelu a jejich vykresleni</i>
        for (int y = 0; y &lt; height; y++) {
            for (int x = 0; x &lt; width; x++) {
                array[0] = x+y;
                raster.setPixel(x, y, array);
            }
        }
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Varianta vyuzivajici metodu WritableRaster.setPixels().</i>
<i> */</i>
class <strong>PatternPainterVersion4</strong> implements <strong>PatternPainter</strong> {
&nbsp;
<i>    /* (non-Javadoc)</i>
<i>     * @see PatternPainter#fillImageByPattern(java.awt.image.BufferedImage)</i>
<i>     */</i>
    public void <strong>fillImageByPattern</strong>(BufferedImage image) {
<i>        // rozmery bitmapy</i>
        final int width = image.getWidth();
        final int height = image.getHeight();
        WritableRaster raster = image.getRaster();
        int[] array = new int[width * height];
&nbsp;
<i>        // provest vypocet barev pixelu</i>
        int i = 0;
        for (int y = 0; y &lt; height; y++) {
            for (int x = 0; x &lt; width; x++) {
                array[i] = x + y;
                i++;
            }
        }
&nbsp;
<i>        // provest vykresleni vsech pixelu</i>
        raster.setPixels(0, 0, width, height, array);
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Varianta vyuzivajici metodu DataBuffer.setElem().</i>
<i> */</i>
class <strong>PatternPainterVersion5</strong> implements <strong>PatternPainter</strong> {
&nbsp;
<i>    /* (non-Javadoc)</i>
<i>     * @see PatternPainter#fillImageByPattern(java.awt.image.BufferedImage)</i>
<i>     */</i>
    public void <strong>fillImageByPattern</strong>(BufferedImage image) {
<i>        // rozmery bitmapy</i>
        final int width = image.getWidth();
        final int height = image.getHeight();
&nbsp;
<i>        // ziskani objektu obsahujiciho hodnoty vsech pixelu bitmapy</i>
        DataBuffer dataBuffer = image.getRaster().getDataBuffer();
&nbsp;
<i>        // provest vypocet barev pixelu a jejich vykresleni</i>
        int i=0;
        for (int y = 0; y &lt; height; y++) {
            for (int x = 0; x &lt; width; x++) {
                dataBuffer.setElem(i, x+y);
                i++;
            }
        }
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Test rychlosti ruznych zpusobu zapisu barev pixelu do rastroveho</i>
<i> * obrazku.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>ImageRendererTest</strong> {
    <i>/**</i>
<i>     * Implementace jednotlivych trid, ktere zapisuji pixely do rastroveho obrazku.</i>
<i>     */</i>
    private static final PatternPainter[] patternPainters = new PatternPainter[5];
&nbsp;
    static {
        patternPainters[0] = new PatternPainterVersion1();
        patternPainters[1] = new PatternPainterVersion2();
        patternPainters[2] = new PatternPainterVersion3();
        patternPainters[3] = new PatternPainterVersion4();
        patternPainters[4] = new PatternPainterVersion5();
    }
&nbsp;
    <i>/**</i>
<i>     * Prefix jmena souboru s vygenerovanou bitmapou.</i>
<i>     */</i>
    private static final String <strong>OUTPUT_FILE_NAME_PREFIX</strong> = "test";
&nbsp;
    <i>/**</i>
<i>     * Horizontalni rozmer bitmapy.</i>
<i>     */</i>
    private static final int <strong>IMAGE_HEIGHT</strong> = 512;
&nbsp;
    <i>/**</i>
<i>     * Vertikalni rozmer bitmapy.</i>
<i>     */</i>
    private static final int <strong>IMAGE_WIDTH</strong> = 512;
&nbsp;
    <i>/**</i>
<i>     * Pocet iteraci zahrivaci faze benchmarku.</i>
<i>     */</i>
    private static final int <strong>WARMUP_ITERS</strong> = 10;
&nbsp;
    <i>/**</i>
<i>     * Pocet iteraci merene faze benchmarku.</i>
<i>     */</i>
    private static final int <strong>BENCHMARK_ITERS</strong> = 2;
&nbsp;
    <i>/**</i>
<i>     * Vytvoreni nove bitmapy se stupni sedi.</i>
<i>     *</i>
<i>     * @return nove vytvorena bitmapa</i>
<i>     */</i>
    private static BufferedImage <strong>createEmptyImage</strong>() {
        return new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_BYTE_GRAY);
    }
&nbsp;
    <i>/**</i>
<i>     * Zapis bitmapy na disk ve formatu PNG.</i>
<i>     * </i>
<i>     * @param image</i>
<i>     *            testovaci bitmapa</i>
<i>     * @throws IOException</i>
<i>     */</i>
    private static void <strong>writeImageIntoFile</strong>(BufferedImage image, String fileName) throws IOException {
        ImageIO.write(image, "png", new File(fileName));
    }
&nbsp;
    <i>/**</i>
<i>     * Zahrivaci faze benchmarku.</i>
<i>     */</i>
    private static void <strong>warmup</strong>() throws IOException {
        System.out.print("warmup begin  ");
        for (int i = 0; i &lt; WARMUP_ITERS; i++) {
            System.out.print(" " + i);
            for (PatternPainter painter : patternPainters) {
                warmup(painter);
            }
        }
        System.out.println();
    }
&nbsp;
    <i>/**</i>
<i>     * Zahrivaci faze benchmarku volana pro kazdy PatternPainter.</i>
<i>     */</i>
    private static void <strong>warmup</strong>(PatternPainter patternPainter) {
        <i>// vytvoreni bitmapy</i>
        BufferedImage image = createEmptyImage();
&nbsp;
        <i>// vyplneni bitmapy vzorkem</i>
        patternPainter.fillImageByPattern(image);
    }
&nbsp;
    <i>/**</i>
<i>     * Vlastni benchmark.</i>
<i>     */</i>
    private static void <strong>benchmark</strong>() throws IOException {
        for (int i = 0; i &lt; BENCHMARK_ITERS; i++) {
            System.out.println("benchmark #" + i + " begin");
            int j = 0;
            for (PatternPainter painter : patternPainters) {
                benchmark(painter, ++j);
            }
        }
    }
&nbsp;
    <i>/**</i>
<i>     * Benchmark volany pro kazdy PatternPainter.</i>
<i>     */</i>
    private static void <strong>benchmark</strong>(PatternPainter patternPainter, int testNumber) throws IOException {
        <i>// vytvoreni bitmapy</i>
        BufferedImage image = createEmptyImage();
&nbsp;
        <i>// cas zacatku vypoctu</i>
        long t1 = System.nanoTime();
&nbsp;
        <i>// vyplneni bitmapy vzorkem</i>
        patternPainter.fillImageByPattern(image);
&nbsp;
        <i>// cas konce vypoctu</i>
        long t2 = System.nanoTime();
        System.out.println("Method #" + testNumber + ": " + (t2-t1) + " ns");
&nbsp;
        <i>// zapis bitmapy na disk pro pozdejsi kontrolu</i>
        writeImageIntoFile(image, OUTPUT_FILE_NAME_PREFIX + testNumber + ".png");
    }
&nbsp;
    <i>/**</i>
<i>     * Spusteni benchmarku.</i>
<i>     *</i>
<i>     * @param args</i>
<i>     * @throws IOException</i>
<i>     */</i>
    public static void <strong>main</strong>(String[] args) throws IOException {
        warmup();
        benchmark();
    }
&nbsp;
}
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Repositáø se zdrojovými soubory demonstraèního benchmarku</h2>

<p>Následuje &ndash; v&nbsp;tomto seriálu ji¾ tradièní &ndash; kapitola
s&nbsp;odkazy na zdrojové kódy ulo¾ené do Mercurial repositáøe.
V&nbsp;následující tabulce najdete odkazy na prozatím nejnovìj¹í verzi dnes
popsaného demonstraèního pøíkladu (benchmarku):</p>

<table>
<tr><th>#</th><th>Zdrojový soubor/skript</th><th>Umístìní souboru v&nbsp;repositáøi</th></tr>
<tr><td>1</td><td>ImageRendererTest.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d43fb5c88eb4/jvm/gfx/ImageRendererTest/ImageRendererTest.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d43fb5c88eb4/jvm/gfx/ImageRendererTest/ImageRendererTest.java</a></td></tr>
<tr><td>2</td><td>Test.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d43fb5c88eb4/jvm/gfx/ImageRendererTest/Test.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d43fb5c88eb4/jvm/gfx/ImageRendererTest/Test.sh</a></td></tr>
<tr><td>3</td><td>Test.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d43fb5c88eb4/jvm/gfx/ImageRendererTest/Test.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/d43fb5c88eb4/jvm/gfx/ImageRendererTest/Test.bat</a></td></tr>
</table>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>GC safe-point (or safepoint) and safe-region<br />
<a href="http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html">http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html</a>
</li>

<li>Safepoints in HotSpot JVM<br />
<a href="http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html">http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html</a>
</li>

<li>Java theory and practice: Synchronization optimizations in Mustang<br />
<a href="http://www.ibm.com/developerworks/java/library/j-jtp10185/">http://www.ibm.com/developerworks/java/library/j-jtp10185/</a>
</li>

<li>How to build hsdis<br />
<a href="http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README">http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README</a>
</li>

<li>Java SE 6 Performance White Paper<br />
<a href="http://www.oracle.com/technetwork/java/6-performance-137236.html">http://www.oracle.com/technetwork/java/6-performance-137236.html</a>
</li>

<li>Lukas Stadler's Blog<br />
<a href="http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html">http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html</a>
</li>

<li>How to build hsdis-amd64.dll and hsdis-i386.dll on Windows<br />
<a href="http://dropzone.nfshost.com/hsdis.htm">http://dropzone.nfshost.com/hsdis.htm</a>
</li>

<li>PrintAssembly<br />
<a href="https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly">https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly</a>
</li>

<li>The Java Virtual Machine Specification: 3.14. Synchronization<br />
<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14</a>
</li>

<li>The Java Virtual Machine Specification: 8.3.1.4. volatile Fields<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.4. Memory Model<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.7. Non-atomic Treatment of double and long<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7</a>
</li>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (pøed verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

