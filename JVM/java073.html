<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - pøipojení debuggeru k bì¾ícímu virtuálnímu stroji pøes rozhraní JDI</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - pøipojení debuggeru k bì¾ícímu virtuálnímu stroji pøes rozhraní JDI</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyku Java i o virtuálním stroji Javy se ji¾ potøetí budeme zabývat rozhraním JDI (Java Debugger Interface). Øekneme si, jakým zpùsobem je mo¾né toto rozhraní vyu¾ít pro pøipojení debuggeru èi jiného podobného nástroje k ji¾ bì¾ícímu javovskému virtuálnímu stroji.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pøipojení debuggeru k&nbsp;bì¾ícímu virtuálnímu stroji pøes konektor typu AttachingConnector</a></p>
<p><a href="#k02">2. První demonstraèní pøíklad &ndash; výpis v¹ech dostupných konektorù vyu¾itelných pro pøipojení k&nbsp;bì¾ícímu JVM</a></p>
<p><a href="#k03">3. Výstup vygenerovaný prvním demonstraèním pøíkladem</a></p>
<p><a href="#k04">4. Druhý demonstraèní pøíklad &ndash; výpis argumentù v¹ech nalezených konektorù typu AttachingConnector</a></p>
<p><a href="#k05">5. Výstup vygenerovaný druhým demonstraèním pøíkladem</a></p>
<p><a href="#k06">6. Realizace pøipojení k&nbsp;ji¾ bì¾ícímu virtuálnímu stroji Javy</a></p>
<p><a href="#k07">7. Spu¹tìní &bdquo;cílové&ldquo; JVM a èekání na pøipojení debuggeru</a></p>
<p><a href="#k08">8. Výbìr konektoru vyu¾ívajícího pro pøipojení sockety</a></p>
<p><a href="#k09">9. Obnovení a ukonèení bìhu &bdquo;cílové&ldquo; JVM</a></p>
<p><a href="#k10">10. Tøetí demonstraèní pøíklad &ndash; praktické vyu¾ití konektoru typu AttachingConnector</a></p>
<p><a href="#k11">11. Zdrojové kódy v¹ech demonstraèních pøíkladù i podpùrných skriptù</a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pøipojení debuggeru k&nbsp;bì¾ícímu virtuálnímu stroji pøes konektor typu AttachingConnector</h2>

<p><a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-spusteni-a-monitorovani-virtualniho-stroje-javy-s-vyuzitim-rozhrani-jdi/">V&nbsp;pøedchozí
èásti</a> <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyku Java i o virtuálním stroji Javy</a> jsme si popsali a na
jednoduchém demonstraèním pøíkladu i prakticky ukázali, jakým zpùsobem je mo¾né
s&nbsp;vyu¾itím rozhraní <i>JDI (Java Debugger Interface)</i> spustit pøímo
z&nbsp;debuggeru novou instanci takzvané &nbsp;&bdquo;cílové&ldquo; JVM
s&nbsp;testovanou aplikací a jak lze zachytit standardní výstup
(popø.&nbsp;naprosto stejným zpùsobem i chybový výstup) této aplikace. Tento
postup vyu¾ívají napøíklad mnohá integrovaná vývojová prostøedí, která díky
tomu, ¾e pøes rozhraní <i>JDI</i> pøímo spustí cílovou JVM, mají nad tímto
virtuálním strojem velkou kontrolu a mohou napøíklad získat pøehled o bì¾ících
vláknech aplikace, zásobníkových rámcích jednotlivých vláken, breakpointech
apod. Ov¹em ne v¾dy je tento zpùsob sledování a ladìní javovské aplikace
nejvýhodnìj¹í. V&nbsp;nìkterých pøípadech mù¾e být mnohem lep¹í, kdy¾ se
&bdquo;cílová&ldquo; JVM spustí zcela samostatnì a debugger se k&nbsp;ji¾
inicializovanému virtuálnímu stroji pøipojí pozdìji, tøeba i vzdálenì.</p>

<p>I tento re¾im práce debuggerù a dal¹ích podobných nástrojù rozhraní
<i>JDI</i> samozøejmì podporuje. Pøipomeòme si krátce, ¾e v&nbsp;<i>JDI</i>
mají vývojáøi debuggerù k&nbsp;dispozici celkem tøi skupiny takzvaných
<i>konektorù</i> slou¾ících pro pøipojení k&nbsp;cílové JVM. První skupina
konektorù implementuje rozhraní <strong>LaunchingConnector</strong> a je
typická tím, ¾e konektor sám spustí cílovou JVM i s&nbsp;ladìnou aplikací.
Vyu¾ití tohoto typu konektorù jsme si ukázali <a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-spusteni-a-monitorovani-virtualniho-stroje-javy-s-vyuzitim-rozhrani-jdi/">minule</a>.
Druhá skupina konektorù implementuje rozhraní
<strong>AttachingConnector</strong>. Jedná se o konektory, které se doká¾ou
pøipojit k&nbsp;ji¾ bì¾ící JVM a zpùsob práce tìchto typù konektorù si popí¹eme
v&nbsp;navazujících kapitolách. Tøetí typ konektorù implementuje rozhraní
<strong>ListeningConnector</strong>. Tyto konektory slou¾í k&nbsp;tomu, aby se
cílová JVM sama aktivnì pøipojila k&nbsp;debuggeru, který ji¾ musí být spu¹tìn.
V¹echny tøi skupiny konektorù jsou pro vìt¹í pøehled vypsány v&nbsp;dal¹í
tabulce i s&nbsp;pøíslu¹nými implementacemi:</p>

<table>
<tr><th>#</th><th>Typ konektoru</th><th>Metoda propojení debuggeru a JVM</th><th>Implementace</th></tr>
<tr><td>1</td><td>LaunchingConnector</td><td>debugger spou¹tí JVM</td><td>com.sun.jdi.CommandLineLaunch, com.sun.jdi.RawCommandLineLaunch</td></tr>
<tr><td>2</td><td>AttachingConnector</td><td>debugger se pøipojuje k&nbsp;bì¾ící JVM</td><td>com.sun.jdi.SocketAttach, com.sun.jdi.SharedMemoryAttach, com.sun.jdi.ProcessAttach</td></tr>
<tr><td>3</td><td>ListeningConnector</td><td>debugger akceptuje ¾ádost JVM o pøipojení</td><td>com.sun.jdi.SocketListen, com.sun.jdi.SharedMemoryListen</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. První demonstraèní pøíklad &ndash; výpis v¹ech dostupných konektorù vyu¾itelných pro pøipojení k&nbsp;bì¾ícímu JVM</h2>

<p>Ze v¹ech tøí typù konektorù popsaných <a href="#k01">v&nbsp;pøedchozí
kapitole</a> si dnes popí¹eme konektory, které se doká¾ou pøipojit k&nbsp;ji¾
bì¾ícímu virtuálnímu stroji Javy. Seznam tìchto konektorù nabízených
v&nbsp;daném okam¾iku bì¾ícím virtuálním strojem Javy je mo¾né získat
s&nbsp;vyu¾itím metody</p>

<pre>
List&lt;AttachingConnector&gt; VirtualMachineManager.attachingConnectors()</strong>
</pre>

<p>vracející v¹echny dostupné (prozatím nenakonfigurované) <i>JDI</i> konektory
implementující rozhraní <strong>com.sun.jdi.connect.AttachingConnector</strong>
a tím pádem implementující i rozhraní
<strong>com.sun.jdi.connect.Connector</strong>. Poèet tìchto konektorù je
závislý na operaèním systému, na nìm¾ je JVM spu¹tìna. Na Linuxu, který nás
samozøejmì zajímá nejvíce, je dostupný konektor <strong>SocketAttach</strong>,
jen¾ se k&nbsp;cílové JVM pøipojuje pøes sockety; na operaèním systému
Microsoft Windows je navíc k&nbsp;dispozici i konektor
<strong>SharedMemoryAttach</strong> vyu¾ívající pro komunikaci s&nbsp;cílovým
virtuálním strojem Javy sdílenou pamì».</p>

<p>Jaké konektory implementující rozhraní <i>AttachingConnector</i> jsou na
právì pou¾ívaném operaèním systému k&nbsp;dispozici, lze zjistit pomocí
dne¹ního prvního demonstraèního pøíkladu, který u ka¾dého konektoru vypí¹e jak
jeho jméno (metoda <strong>com.sun.jdi.connect.Connector.name()</strong>), tak
i jeho jednoøádkový popis (metoda
<strong>com.sun.jdi.connect.Connector.description()</strong>) a tøídu, která
tento konektor implementuje. Na tomto místì je vhodné upozornit na fakt, ¾e
tato tøída se mù¾e v&nbsp;rùzných verzích èi implementacích JVM li¹it &ndash;
nejedná se toti¾ o tøídy zahrnuté do standardního API Javy:</p>

<pre>
import java.util.List;
&nbsp;
import com.sun.jdi.Bootstrap;
import com.sun.jdi.VirtualMachineManager;
import com.sun.jdi.connect.AttachingConnector;
&nbsp;
<i>/**</i>
<i> * Vypis vsech konektoru, ktere lze pouzit pro pripojeni k bezici JVM.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>JDIListAttachingConnectors</strong> {
&nbsp;
    public static void <strong>main</strong>(String[] args) {
<i>        // ziskat (jedinou) instanci tridy VirtualMachineManager</i>
        VirtualMachineManager virtualMachineManager = <strong>Bootstrap.virtualMachineManager()</strong>;
&nbsp;
<i>        // ziskat vsechny konektory pouzite pro pripojeni k bezici JVM</i>
        List&lt;AttachingConnector&gt; connectors = <strong>virtualMachineManager.attachingConnectors()</strong>;
&nbsp;
<i>        // vypis informaci o vsech konektorech</i>
        listConnectors(connectors);
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis informaci o vsech konektorech pouzitelnych</i>
<i>     * pro pripojeni k bezici JVM.</i>
<i>     */</i>
    private static void <strong>listConnectors</strong>(List&lt;AttachingConnector&gt; connectors) {
        for (AttachingConnector connector : connectors) {
            System.out.println("Connector: " + connector.name());
            System.out.println("    class: " + connector.getClass().getName()); <i>// systemove zavisle</i>
            System.out.println("    description: " + connector.description());  <i>// popis pro lidske operatory</i>
            System.out.println();
        }
    }
&nbsp;
}
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Výstup vygenerovaný prvním demonstraèním pøíkladem</h2>

<p>Podobnì jako tomu bylo v&nbsp;demonstraèních pøíkladech uvedených pøedminule
a minule, i dne¹ní první demonstraèní pøíklad je nutné pøekládat s&nbsp;volbou
<strong>-classpath</strong>, v&nbsp;ní¾ bude uvedena cesta k&nbsp;java archivu
<strong>tools.jar</strong>. Pokud se napøíklad pro pøeklad pou¾ije OpenJDK 6
nainstalovaná ze standardních balíèkù, mù¾e být pøeklad proveden následujícím
pøíkazem:</p>

<pre>
javac -classpath /usr/lib/jvm/java-6-openjdk/lib/tools.jar:. JDIListAttachingConnectors.java
</pre>

<p>I pøi spu¹tìní demonstraèního pøíkladu je nutné uvést cestu k&nbsp;java
archivu <strong>tools.jar</strong>:</p>

<pre>
java -cp /usr/lib/jvm/java-6-openjdk/lib/tools.jar:. JDIListAttachingConnectors
</pre>

<p>Pøi spu¹tìní dne¹ního prvního demonstraèního pøíkladu na operaèním systému
Microsoft Windows získáme seznam tøí konektorù implementujících rozhraní
<i>AttachingConnector</i>:</p>

<pre>
Connector: com.sun.jdi.SocketAttach
    class: com.sun.tools.jdi.SocketAttachingConnector
    description: Attaches by socket to other VMs
&nbsp;
Connector: com.sun.jdi.SharedMemoryAttach
    class: com.sun.tools.jdi.SharedMemoryAttachingConnector
    description: Attaches by shared memory to other VMs
&nbsp;
Connector: com.sun.jdi.ProcessAttach
    class: com.sun.tools.jdi.ProcessAttachingConnector
    description: Attaches to debuggee by process-id (pid)
&nbsp;
</pre>

<p>Na Linuxu mù¾e naproti tomu nabídka konektorù typu <i>AttachingConnector</i>
vypadat následovnì:</p>

<pre>
Connector: com.sun.jdi.SocketAttach
    class: com.sun.tools.jdi.SocketAttachingConnector
    description: Attaches by socket to other VMs
&nbsp;
Connector: com.sun.jdi.ProcessAttach
    class: com.sun.tools.jdi.ProcessAttachingConnector
    description: Attaches to debuggee by process-id (pid)
&nbsp;
</pre>

<p>Z&nbsp;výpisù je patrné, ¾e na obou operaèních systémech jsou
k&nbsp;dispozici dva shodné konektory &ndash; "com.sun.jdi.SocketAttach" a
"com.sun.jdi.ProcessAttach". To tedy znamená, ¾e konektor vyu¾ívající pro
pøipojení k&nbsp;cílové JVM sockety lze bez vìt¹ích problémù pou¾ít v¾dy.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Druhý demonstraèní pøíklad &ndash; výpis argumentù v¹ech nalezených konektorù typu AttachingConnector</h2>

<p>Konektorùm, které umo¾òují pøipojení k&nbsp;ji¾ bì¾ícímu virtuálnímu stroji
Javy, je nutné pøedat i nìkteré dùle¾ité parametry potøebné pro provedení
vlastního pøipojení. Pøíkladem mù¾e být konektor zaji¹»ující pøipojení pøes
sockety, kterému je nutné pøedat èíslo portu, na nìm¾ cílová JVM pøipojení
oèekává, popø.&nbsp;i adresu poèítaèe s&nbsp;cílovou JVM. <a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-spusteni-a-monitorovani-virtualniho-stroje-javy-s-vyuzitim-rozhrani-jdi/">V&nbsp;pøedchozí
èásti</a> jsme si ukázali, jak lze vypsat a posléze i zmìnit parametry
implicitního konektoru &ndash; ten implementuje rozhraní
<strong>com.sun.jdi.connect.LaunchingConnector</strong> &ndash;, ov¹em naprosto
stejný postup lze pou¾ít i pro konektory implementující rozhraní
<strong>com.sun.jdi.connect.AttachingConnector</strong>. Výpis v¹ech implicitnì
nastavených parametrù zvoleného konektoru zajistí následující programová
smyèka, která je i souèástí dne¹ního druhého demonstraèního pøíkladu:</p>

<pre>
<i>// vypsat vsechny parametry konektoru</i>
Map&lt;String, Argument&gt; arguments = <strong>connector.defaultArguments()</strong>;
for (Map.Entry&lt;String, Connector.Argument&gt; argument : arguments.entrySet()) {
    System.out.format("        %-12s %s\n",
            argument.getKey(),
            argument.getValue());
}
</pre>

<p>Úplný zdrojový kód druhého demonstraèního pøíkladu vypadá následovnì:</p>

<pre>
import java.util.List;
import java.util.Map;
&nbsp;
import com.sun.jdi.Bootstrap;
import com.sun.jdi.VirtualMachineManager;
import com.sun.jdi.connect.AttachingConnector;
import com.sun.jdi.connect.Connector;
import com.sun.jdi.connect.Connector.Argument;
&nbsp;
<i>/**</i>
<i> * Vypis vsech konektoru, ktere lze pouzit pro pripojeni k bezici JVM.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>JDIListAttachingConnectorsArguments</strong> {
&nbsp;
    public static void <strong>main</strong>(String[] args) {
<i>        // ziskat (jedinou) instanci tridy VirtualMachineManager</i>
        VirtualMachineManager virtualMachineManager = <strong>Bootstrap.virtualMachineManager()</strong>;
&nbsp;
<i>        // ziskat vsechny konektory pouzite pro pripojeni k bezici JVM</i>
        List&lt;AttachingConnector&gt; connectors = <strong>virtualMachineManager.attachingConnectors()</strong>;
&nbsp;
<i>        // vypis informaci o vsech konektorech</i>
        listConnectors(connectors);
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis informaci o vsech konektorech pouzitelnych</i>
<i>     * pro pripojeni k bezici JVM.</i>
<i>     */</i>
    private static void <strong>listConnectors</strong>(List&lt;AttachingConnector&gt; connectors) {
        for (AttachingConnector connector : connectors) {
            System.out.println("Connector: " + connector.name());
            System.out.println("    class: " + connector.getClass().getName());
            System.out.println("    description: " + connector.description());
            System.out.println("    arguments:");
&nbsp;
<i>            // vypsat vsechny parametry konektoru</i>
            Map&lt;String, Argument&gt; arguments = <strong>connector.defaultArguments()</strong>;
            for (Map.Entry&lt;String, Connector.Argument&gt; argument : arguments.entrySet()) {
                System.out.format("        %-12s %s\n",
                        argument.getKey(),
                        argument.getValue());
            }
            System.out.println();
        }
    }
&nbsp;
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Výstup vygenerovaný druhým demonstraèním pøíkladem</h2>

<p>Pøeklad druhého demonstraèního pøíkladu se provede pomocí
<strong>javac</strong>, jemu¾ se opìt pøedá cesta
k&nbsp;<strong>tools.jar</strong>:</p>

<pre>
javac -classpath /usr/lib/jvm/java-6-openjdk/lib/tools.jar:. JDIListAttachingConnectorsArguments.java
</pre>

<p>I pøi spu¹tìní demonstraèního pøíkladu je nutné uvést cestu k&nbsp;java
archivu <strong>tools.jar</strong>:</p>

<pre>
java -cp /usr/lib/jvm/java-6-openjdk/lib/tools.jar:. JDIListAttachingConnectorsArguments
</pre>

<p>Výstup druhého demonstraèního pøíkladu na operaèním systému Microsoft
Windows mù¾e vypadat následovnì (li¹it se bude pøedev¹ím hodnota parametru
"hostname"):</p>

<pre>
Connector: com.sun.jdi.SocketAttach
    class: com.sun.tools.jdi.SocketAttachingConnector
    description: Attaches by socket to other VMs
    arguments:
        timeout      timeout=
        hostname     hostname=bender6502
        port         port=
&nbsp;
Connector: com.sun.jdi.SharedMemoryAttach
    class: com.sun.tools.jdi.SharedMemoryAttachingConnector
    description: Attaches by shared memory to other VMs
    arguments:
        timeout      timeout=
        name         name=
&nbsp;
Connector: com.sun.jdi.ProcessAttach
    class: com.sun.tools.jdi.ProcessAttachingConnector
    description: Attaches to debuggee by process-id (pid)
    arguments:
        pid          pid=
        timeout      timeout=
&nbsp;
</pre>

<p>Výstup druhého demonstraèního pøíkladu na Linuxu bude podle oèekávání
zkrácen, proto¾e zde není k&nbsp;dispozici konektor typu
"com.sun.jdi.SharedMemoryAttach":</p>

<pre>
Connector: com.sun.jdi.SocketAttach
    class: com.sun.tools.jdi.SocketAttachingConnector
    description: Attaches by socket to other VMs
    arguments:
        timeout      timeout=
        hostname     hostname=bender
        port         port=
&nbsp;
Connector: com.sun.jdi.ProcessAttach
    class: com.sun.tools.jdi.ProcessAttachingConnector
    description: Attaches to debuggee by process-id (pid)
    arguments:
        pid          pid=
        timeout      timeout=
&nbsp;
</pre>

<p>Dùle¾ité jsou pro nás pøedev¹ím argumenty s&nbsp;názvem
<strong>hostname</strong> a <strong>port</strong>, proto¾e ty se musí nastavit
vhodným zpùsobem tak, aby se debugger skuteènì mohl pøipojit k&nbsp;cílovému
virtuálnímu stroji Javy. Pøi lokálním spojení v&nbsp;rámci jednoho poèítaèe
není zapotøebí argument s&nbsp;názvem <strong>hostname</strong> mìnit, ov¹em
<strong>port</strong> je nutné explicitnì specifikovat v¾dy, co¾ si ostatnì
uká¾eme v&nbsp;navazujících kapitolách.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Realizace pøipojení k&nbsp;ji¾ bì¾ícímu virtuálnímu stroji Javy</h2>

<p>V&nbsp;této kapitole si teoreticky øekneme, jakým zpùsobem lze realizovat
pøipojení k&nbsp;bì¾ící cílové (ladìné) JVM s&nbsp;vyu¾itím spojení pomocí
socketù. Aplikace, která má být spu¹tìna v&nbsp;cílovém virtuálním stroji Javy,
se pøelo¾í zcela bì¾ným zpùsobem &ndash; není tedy zapotøebí provádìt ¾ádné
zásahy do zdrojového kódu ani mìnit parametry pøekladu. Ov¹em pøi spu¹tìní
cílové JVM je nutné pou¾ít parametr <strong>-agentlib</strong>, kterému se
pøedá jméno JVM TI agenta, co¾ je v&nbsp;na¹em pøípadì <strong>jdwp</strong>.
Jak ji¾ víme z&nbsp;pøedchozích dílù, znamená tato zkratka <i>Java Debug Wire
Protocol</i>, z&nbsp;èeho¾ vyplývá, ¾e JVM TI agent s&nbsp;názvem
<strong>jdwp</strong> tento protokol implementuje. <strong>jdwp</strong> je
samozøejmì souèasnì i název nativní knihovny, v&nbsp;ní¾ je komunikaèní èást
implementována &ndash; na Linuxu se jedná o knihovnu pojmenovanou
<strong>libjdwp.so</strong> a na systému Microsoft Windows pak o dynamickou
knihovnu <strong>jdwp.dll</strong> (jeden z&nbsp;tìchto souborù je souèástí
standardní instalace JRE).</p>

<p>Dále je nutné tomuto agentovi pøedat nìkolik parametrù, které jsou vypsány
v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Parametr</th><th>Hodnota</th><th>Význam</th></tr>
<tr><td>1</td><td>transport</td><td>dt_socket</td><td>spojení bude provedeno pøes sockety, tj.&nbsp;startovaná (cílová) JVM otevøe socket na specifikovaném portu a bude oèekávat, ¾e debugger tento port vyu¾ije</td></tr>
<tr><td>2</td><td>server   </td><td>y</td><td>cílová JVM bude spu¹tìna v&nbsp;re¾imu serveru, tj.&nbsp;aktivnì pøipojovat se bude agent, nikoli naopak</td></tr>
<tr><td>3</td><td>address  </td><td>6502</td><td>v&nbsp;re¾imu serveru je zde specifikováno jen èíslo portu (adresa odpovídá stroji, na nìm¾ je cílová JVM nastartována), 6502 je jen &bdquo;témìø náhodnì&ldquo; zvolená konstanta; lze vyu¾ít jakýkoli port, který mù¾e u¾ivatel otevøít</td></tr>
<tr><td>4</td><td>suspend  </td><td>y</td><td>cílová JVM je ihned po spu¹tìní pozastavena a èeká na pøipojení debuggeru &ndash; aplikace tedy není ihned spu¹tìna, co¾ je pro ladìní výhodné</td></tr>
</table>

<p>V¹echny parametry <strong>jdwp</strong> agenta se na pøíkazovou øádku
zapisují následujícím (mo¾ná ponìkud matoucím) zpùsobem, kdy se za
<strong>-agentlib:jdwp</strong> pøidá znak "=" a za ním v¾dy dvojice
"jméno_parametru=hodnota_parametru", pøièem¾ se jednotlivé dvojice od sebe
oddìlují èárkami:</p>

<pre>
java -agentlib:jdwp=transport=dt_socket,server=y,address=6502,suspend=y Test
</pre>

<p>("Test" je samozøejmì jméno spou¹tìné tøídy).</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Spu¹tìní &bdquo;cílové&ldquo; JVM a èekání na pøipojení debuggeru</h2>

<p>Podívejme se nyní na velmi jednoduchý pøíklad spu¹tìní javovské aplikace
v&nbsp;cílovém (ladìném) virtuálním stroji Javy. Samotná aplikace po svém
spu¹tìní zaène v&nbsp;nekoneèné programové smyèce na standardní výstup
vypisovat text &bdquo;Hello world!&ldquo;, skuteènì se tedy nejedná o
nejgeniálnìj¹í program, který byl kdy naprogramován :-) :</p>

<pre>
public class <strong>Test</strong> {
&nbsp;
    public static void <strong>main</strong>(String[] args) {
        <strong>while</strong> (<i>true</i>) {
            System.out.println("Hello world!");
        }
    }
&nbsp;
}
</pre>

<p>Cílovou JVM i s&nbsp;testovanou aplikací spustíme následujícím zpùsobem:</p>

<pre>
java -agentlib:jdwp=transport=dt_socket,server=y,address=6502,suspend=y Test
</pre>

<p>Po spu¹tìní se stane zajímavá vìc. Na standardní výstup se namísto nekoneèné
sekvence &bdquo;Hello world!&ldquo; vypí¹e pouze jediný øádek, který by mìl
vypadat pøibli¾nì takto:</p>

<pre>
Listening for transport dt_socket at address: 6502
</pre>

<p>Proè tomu tak je by mìlo být po pøeètení <a href="#k06">¹esté kapitoly</a>
zøejmé &ndash; díky parametru <strong>suspend=y</strong> je cílová JVM ihned po
své inicializaci pozastavena a oèekává pøipojení debuggeru.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Výbìr konektoru vyu¾ívajícího pro pøipojení sockety</h2>

<p>Samotný debbuger (èi jiný podobný nástroj), který se bude pøipojovat
k&nbsp;cílové JVM pøes sockety, musí nejprve získat v¹echny konektory
implementující rozhraní
<strong>com.sun.jdi.connect.AttachingConnector</strong>. To se provede
s&nbsp;vyu¾itím metody
<strong>VirtualMachineManager.AttachingConnector()</strong>, která vrátí seznam
v¹ech konektorù umo¾òujících pøipojení k&nbsp;ji¾ bì¾ícímu virtuálnímu stroji
Javy. Následnì je nutné ze seznamu tìchto konektorù vybrat konektor umo¾òující
spojení s&nbsp;cílovou JVM pøes sockety:</p>

<pre>
<i>// ziskat (jedinou) instanci tridy VirtualMachineManager</i>
VirtualMachineManager virtualMachineManager = <strong>Bootstrap.virtualMachineManager()</strong>;
&nbsp;
<i>// ziskat vsechny konektory pouzite pro pripojeni k bezici JVM</i>
List&lt;AttachingConnector&gt; connectors = <strong>virtualMachineManager.attachingConnectors()</strong>;
&nbsp;
<i>// potrebujeme ziskat konektor pouzivajici pro pripojeni sockety</i>
AttachingConnector connector = <strong>getSocketAttachConnector(connectors)</strong>;
&nbsp;
if (connector == null) {
    System.out.println("Socket connector is not available");
    return;
}
...
...
...
</pre>

<p>Samotná metoda <strong>getSocketAttachConnector()</strong> je implementována
sice jednodu¹e, ov¹em (alespoò zdánlivì) neefektivnì. Porovnáváme zde toti¾
jména jednotlivých konektorù s&nbsp;øetìzcovou konstantou a pokud je nalezen
konektor se jménem "com.sun.jdi.SocketAttach", je tento konektor metodou ihned
vrácen. Na tomto místì je vhodné poznamenat, ¾e vzhledem k&nbsp;souèasnému
stavu <i>JDI</i> zde není mo¾né pou¾ít napøíklad operátor
<strong>instanceof</strong>, proto¾e konkrétní jméno tøídy èi rozhraní, kterou
musí konektor "SocketAttach" implementovat, není pøesnì zdokumentováno a
stabilizováno mezi rùznými implementacemi JVM:</p>

<pre>
<i>    /**</i>
<i>     * Ziskat konektor pouzivajici pro pripojeni sockety</i>
<i>     */</i>
    private static AttachingConnector <strong>getSocketAttachConnector</strong>(List&lt;AttachingConnector&gt; connectors) {
        for (AttachingConnector connector : connectors) {
            if (SOCKET_ATTACH_CONNECTOR_NAME.equals(connector.name())) {
                return connector;
            }
        }
        return null;
    }
</pre>

<p>V&nbsp;metodì <strong>getSocketAttachConnector()</strong> je pou¾ita
øetìzcová konstanta <strong>SOCKET_ATTACH_CONNECTOR_NAME</strong>, která musí
obsahovat øetìzec "com.sun.jdi.SocketAttach". Deklarace této konstanty vypadá
následovnì:</p>

<pre>
private static final String <strong>SOCKET_ATTACH_CONNECTOR_NAME</strong> = "com.sun.jdi.SocketAttach";
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Obnovení a ukonèení bìhu &bdquo;cílové&ldquo; JVM</h2>

<p>Ve chvíli, kdy ji¾ máme vybrán správný konektor, je mo¾né se pøipojit
k&nbsp;bì¾ícímu virtuálnímu stroji Javy. Aby se pøipojení skuteènì provedlo,
musí se nejprve nastavit port, pøes který se debugger k&nbsp;cílové JVM
pøipojí. Zmìna portu je ve skuteènosti velmi jednoduchá, jak ostatnì ukazuje
následující úryvek kódu:</p>

<pre>
Map&lt;String, Connector.Argument&gt; arguments = connector.defaultArguments();
arguments.get("port").setValue("6502");
</pre>

<p>Vlastní pøipojení k&nbsp;cílové JVM zaji¹»uje metoda
<strong>AttachingConnector.attach()</strong>, které se pøedá mapa obsahující
nové argumenty (parametry) konektoru:</p>

<pre>
VirtualMachine virtualMachine = <strong>connector.attach(arguments)</strong>;
</pre>

<p>Následnì je nutné cílový virtuální stroj pøepnout ze stavu "suspend", do
nìho¾ byl nastaven volbou "suspend=y" pøi startu JVM. Znovuspu¹tìní cílové JVM
je ve skuteènosti velmi snadné:</p>

<pre>
<strong>virtualMachine.resume()</strong>;
</pre>

<p>Kdykoli lze cílovou JVM násilnì ukonèit, a to zavoláním metody:</p>

<pre>
<strong>virtualMachine.exit(exit_kód)</strong>;
</pre>

<p>V¹echna funkcionalita popsaná v&nbsp;pøede¹lém textu je pou¾ita
v&nbsp;metodì nazvané <strong>connectToVirtualMachine()</strong>. Nejprve se
nastaví argumenty konektoru tak, aby se pøipojoval na port èíslo 6502, poté se
provede vlastní pøipojení, cílový virtuální stroj Javy se znovuspustí a po cca
desetinì vteøiny dojde k&nbsp;jeho násilnému ukonèení:</p>

<pre>
<i>    /**</i>
<i>     * Pripojeni k bezicimu virtualnimu stroji pres socket.</i>
<i>     * @throws InterruptedException </i>
<i>     */</i>
    private static void <strong>connectToVirtualMachine</strong>(AttachingConnector connector) {
<i>        // zmena hodnoty argumentu se jmenem "port"</i>
        Map&lt;String, Connector.Argument&gt; arguments = connector.defaultArguments();
        arguments.get("port").setValue("6502");
&nbsp;
<i>        // pripojeni ke vzdalenemu bezicimu virtualnimu stroji Javy</i>
        try {
            System.out.println("Connecting to virtual machine");
            VirtualMachine virtualMachine = <strong>connector.attach(arguments)</strong>;
&nbsp;
<i>            // zmena stavu suspend-&gt;resume</i>
            System.out.println("Connected, calling resume");
            <strong>virtualMachine.resume()</strong>;
&nbsp;
<i>            // nechame vzdalenou JVM bezet priblizne 100ms</i>
            Thread.sleep(100);
&nbsp;
<i>            // ukonceni behu vzdaleneho virtualniho stroje</i>
            System.out.println("Calling exit");
            <strong>virtualMachine.exit(0)</strong>;
        }
        catch (IOException e) {
            e.printStackTrace();
        }
        catch (IllegalConnectorArgumentsException e) {
            e.printStackTrace();
        }
        catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
&nbsp;
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Tøetí demonstraèní pøíklad &ndash; praktické vyu¾ití konektoru typu AttachingConnector</h2>

<p>Nyní si ji¾ mù¾eme ukázat celý zdrojový text dne¹ního tøetího demonstraèního
pøíkladu a následnì si ukázat, jakým zpùsobem lze tento pøíklad pou¾ít:</p>

<pre>
import java.io.IOException;
import java.util.List;
import java.util.Map;
&nbsp;
import com.sun.jdi.Bootstrap;
import com.sun.jdi.VirtualMachine;
import com.sun.jdi.VirtualMachineManager;
import com.sun.jdi.connect.AttachingConnector;
import com.sun.jdi.connect.Connector;
import com.sun.jdi.connect.IllegalConnectorArgumentsException;
&nbsp;
<i>/**</i>
<i> * Pripojeni k bezicimu virtualnimu stroji Javy,</i>
<i> * ktery byl spusten s parametry:</i>
<i> * java -agentlib:jdwp=transport=dt_socket,server=y,address=6502,suspend=y Trida</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>JDIAttachingConnectorTest</strong> {
&nbsp;
    private static final String SOCKET_ATTACH_CONNECTOR_NAME = "com.sun.jdi.SocketAttach";
&nbsp;
    public static void <strong>main</strong>(String[] args) {
<i>        // ziskat (jedinou) instanci tridy VirtualMachineManager</i>
        VirtualMachineManager virtualMachineManager = <strong>Bootstrap.virtualMachineManager()</strong>;
&nbsp;
<i>        // ziskat vsechny konektory pouzite pro pripojeni k bezici JVM</i>
        List&lt;AttachingConnector&gt; connectors = <strong>virtualMachineManager.attachingConnectors()</strong>;
&nbsp;
<i>        // potrebujeme ziskat konektor pouzivajici pro pripojeni sockety</i>
        AttachingConnector connector = <strong>getSocketAttachConnector(connectors)</strong>;
&nbsp;
        if (connector == null) {
            System.out.println("Socket connector is not available");
            return;
        }
&nbsp;
        <strong>connectToVirtualMachine</strong>(connector);
    }
&nbsp;
<i>    /**</i>
<i>     * Ziskat konektor pouzivajici pro pripojeni sockety</i>
<i>     */</i>
    private static AttachingConnector <strong>getSocketAttachConnector</strong>(List&lt;AttachingConnector&gt; connectors) {
        for (AttachingConnector connector : connectors) {
            if (SOCKET_ATTACH_CONNECTOR_NAME.equals(connector.name())) {
                return connector;
            }
        }
        return null;
    }
&nbsp;
<i>    /**</i>
<i>     * Pripojeni k bezicimu virtualnimu stroji pres socket.</i>
<i>     * @throws InterruptedException </i>
<i>     */</i>
    private static void <strong>connectToVirtualMachine</strong>(AttachingConnector connector) {
<i>        // zmena hodnoty argumentu se jmenem "port"</i>
        Map&lt;String, Connector.Argument&gt; arguments = <strong>connector.defaultArguments()</strong>;
        arguments.get("port").setValue("6502");
&nbsp;
<i>        // pripojeni ke vzdalenemu bezicimu virtualnimu stroji Javy</i>
        try {
            System.out.println("Connecting to virtual machine");
            VirtualMachine virtualMachine = <strong>connector.attach(arguments)</strong>;
&nbsp;
<i>            // zmena stavu suspend-&gt;resume</i>
            System.out.println("Connected, calling resume");
            <strong>virtualMachine.resume()</strong>;
&nbsp;
<i>            // nechame vzdalenou JVM bezet priblizne 100ms</i>
            Thread.sleep(100);
&nbsp;
<i>            // ukonceni behu vzdaleneho virtualniho stroje</i>
            System.out.println("Calling exit");
            <strong>virtualMachine.exit(0)</strong>;
        }
        catch (IOException e) {
            e.printStackTrace();
        }
        catch (IllegalConnectorArgumentsException e) {
            e.printStackTrace();
        }
        catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
&nbsp;
}
</pre>

<p>Pokud tento demonstraèní pøíklad pøelo¾íme a pøímo spustíme pomocí
skriptu</p>

<pre>
javac -classpath /usr/lib/jvm/java-6-openjdk/lib/tools.jar:. JDIAttachingConnectorTest.java
&nbsp;
java -cp /usr/lib/jvm/java-6-openjdk/lib/tools.jar:. JDIAttachingConnectorTest
</pre>

<p>zále¾í chování programu na tom, zda je èi není spu¹tìná i cílová JVM (viz
té¾ <a href="#k07">sedmou kapitolu</a>). V&nbsp;pøípadì, ¾e cílová JVM spu¹tìna
není, dopadneme neslavnì, nebo» se do terminálu pouze vypí¹e hlá¹ení o výjimce
zpùsobené tím, ¾e se program nedokázal pøipojit:</p>

<pre>
Connecting to virtual machine
java.net.ConnectException: Connection refused: connect
        at java.net.PlainSocketImpl.socketConnect(Native Method)
        at java.net.PlainSocketImpl.doConnect(PlainSocketImpl.java:333)
        at java.net.PlainSocketImpl.connectToAddress(PlainSocketImpl.java:195)
        at java.net.PlainSocketImpl.connect(PlainSocketImpl.java:182)
        at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:366)
        at java.net.Socket.connect(Socket.java:519)
        at com.sun.tools.jdi.SocketTransportService.attach(SocketTransportService.java:204)
        at com.sun.tools.jdi.GenericAttachingConnector.attach(GenericAttachingConnector.java:98)
        at com.sun.tools.jdi.SocketAttachingConnector.attach(SocketAttachingConnector.java:72)
        at JDIAttachingConnectorTest.connectToVirtualMachine(JDIAttachingConnectorTest.java:68)
        at JDIAttachingConnectorTest.main(JDIAttachingConnectorTest.java:41)
</pre>

<p>Pokud v¹ak nejprve spustíme cílovou JVM ji¾ dvakrát zmínìným pøíkazem</p>

<pre>
java -agentlib:jdwp=transport=dt_socket,server=y,address=6502,suspend=y Test
</pre>

<p>mìlo by se pøipojení (=demonstraèní pøíklad spu¹tìný z&nbsp;jiné konzole)
podaøit a mìli bychom získat následující výstup:</p>

<pre>
Connecting to virtual machine
Connected, calling resume
Calling exit
</pre>

<p>Souèasnì by se mìl na konzoli s&nbsp;testovacím pøíkladem nìkolikrát objevit
text "Hello world!". Pokud se neobjeví, mù¾e to znamenat, ¾e doba sta
milisekund pou¾itá v&nbsp;demonstraèním pøíkladu je pøíli¹ krátká na
znovuspu¹tìní cílové JVM a následný vstup do nekoneèné programové smyèky
<strong>while</strong> &ndash; proto mù¾ete tuto hodnotu zvý¹it napøíklad na
pùl sekundy.</p>

<p>Mù¾e takté¾ nastat pøípad, ¾e se k&nbsp;cílovému virtuálnímu stroji budeme
sna¾it pøipojit dvìma instancemi tøetího demonstraèního pøíkladu. To není
mo¾né, proto¾e k&nbsp;JVM se mù¾e pøipojit jen jeden debugger a navíc je i port
6502 ji¾ pou¾it pro pøipojení prvního debuggeru:</p>

<pre>
ERROR: transport error 202: bind failed: Adresa je u¾ívána
ERROR: JDWP Transport dt_socket failed to initialize, TRANSPORT_INIT(510)
JDWP exit error AGENT_ERROR_TRANSPORT_INIT(197): No transports initialized [../../../src/share/back/debugInit.c:708]
FATAL ERROR in native method: JDWP No transports initialized, jvmtiError=AGENT_ERROR_TRANSPORT_INIT(197)
./Test.sh: øádek 2:  1919 Neúspì¹nì ukonèen (SIGABRT)        java -agentlib:jdwp=transport=dt_socket,server=y,address=6502,suspend=y Test
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Zdrojové kódy v¹ech demonstraèních pøíkladù i podpùrných skriptù</h2>

<p>Zdrojové kódy v¹ech tøí dnes popsaných demonstraèních pøíkladù, testovací
tøídy i skriptù pou¾itých pro pøeklad a spu¹tìní demonstraèních pøíkladù, byly
ulo¾eny do Mercurial repositáøe dostupného na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
Prozatím nejnovìj¹í verze v¹ech zmínìných zdrojových souborù a skriptù mù¾ete
najít na adresách:</p>

<table>
<tr><th>#</th><th>Zdrojový soubor/skript</th><th>Umístìní v&nbsp;repositáøi</th></tr>
<tr><td>1</td><td>JDIListAttachingConnectors.java         </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/716580c5d0ab/jdi/JDIListAttachingConnectors.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/716580c5d0ab/jdi/JDIListAttachingConnectors.java</a></td></tr>
<tr><td>2</td><td>JDIListAttachingConnectors.sh           </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/716580c5d0ab/jdi/JDIListAttachingConnectors.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/716580c5d0ab/jdi/JDIListAttachingConnectors.sh</a></td></tr>
<tr><td>3</td><td>JDIListAttachingConnectorsArguments.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/716580c5d0ab/jdi/JDIListAttachingConnectorsArguments.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/716580c5d0ab/jdi/JDIListAttachingConnectorsArguments.java</a></td></tr>
<tr><td>4</td><td>JDIListAttachingConnectorsArguments.sh  </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/716580c5d0ab/jdi/JDIListAttachingConnectorsArguments.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/716580c5d0ab/jdi/JDIListAttachingConnectorsArguments.sh</a></td></tr>
<tr><td>5</td><td>Test.java                               </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/716580c5d0ab/jdi/Test.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/716580c5d0ab/jdi/Test.java</a></td></tr>
<tr><td>6</td><td>Test.sh                                 </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/716580c5d0ab/jdi/Test.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/716580c5d0ab/jdi/Test.sh</a></td></tr>
<tr><td>7</td><td>JDIAttachingConnectorTest.java          </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/716580c5d0ab/jdi/JDIAttachingConnectorTest.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/716580c5d0ab/jdi/JDIAttachingConnectorTest.java</a></td></tr>
<tr><td>8</td><td>JDIAttachingConnectorTest.sh            </td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/716580c5d0ab/jdi/JDIAttachingConnectorTest.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/716580c5d0ab/jdi/JDIAttachingConnectorTest.sh</a></td></tr>
</table>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>Breakpoint (Wikipedia)<br />
<a href="http://cs.wikipedia.org/wiki/Breakpoint">http://cs.wikipedia.org/wiki/Breakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation<br />
<a href="http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html">http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; SetBreakpoint<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#SetBreakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#SetBreakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; ClearBreakpoint<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#ClearBreakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#ClearBreakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; Breakpoint (callback funkce)<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#Breakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#Breakpoint</a>
</li>

<li>The JVM Tool Interface (JVM TI): How VM Agents Work<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html">http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html</a>
</li>

<li>Creating a Debugging and Profiling Agent with JVMTI<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html">http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html</a>
</li>

<li>JVM TI (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/JVM_TI">http://en.wikipedia.org/wiki/JVM_TI</a>
</li>

<li>IBM JVMTI extensions<br />
<a href="http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html">http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

