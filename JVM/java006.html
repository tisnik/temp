<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;dne¹ní èásti seriálu o novinkách, které mù¾eme najít v&nbsp;syntaxi a sémantice programovacího jazyka Java i v&nbsp;jeho virtuálním stroji, si popí¹eme vlastnost, která sice byla pùvodnì plánována a¾ pro oficiální verzi JDK 7, ale nakonec ji mohou vyu¾ít i programátoøi a u¾ivatelé pou¾ívající JDK 1.6.0 14 a samozøejmì také OpenJDK 6. Jedná se o zavedení takzvaných komprimovaných ukazatelù na objekty, které lze pou¾ívat na 64bitových platformách, vèetnì x86_64.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM</a></p>
<p><a href="#k02">2. Platforma i386 a 32bitové operaèní systémy</a></p>
<p><a href="#k03">3. Platforma x86_64 &ndash; roz¹íøení adresování na 64 bitù</a></p>
<p><a href="#k04">4. JVM v&nbsp;32bitových a 64bitových systémech</a></p>
<p><a href="#k05">5. Komprimované ukazatele na objekty</a></p>
<p><a href="#k06">6. Co se stane s&nbsp;hodnotami NULL?</a></p>
<p><a href="#k07">7. Testovací pøíklady</a></p>
<p><a href="#k08">8. Porovnání rychlosti a obsazení pamìti pøi pou¾ití komprimovaných ukazatelù</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2>1. Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM</h2>

<p>Ve v¹ech pøedchozích pìti èástech seriálu o novinkách, které lze najít
v&nbsp;<i>JDK 7</i>, jsme se zabývali pøedev¹ím tìmi novými vlastnostmi
platformy Javy, které jsou skuteènì implementovány a¾ v&nbsp;sedmé verzi
<i>JDK</i>, popø. &ndash; alespoò prozatím &ndash; jako zcela samostatný
projekt, který lze spolu s&nbsp;<i>JDK 7</i> pou¾ít (jedná se pøedev¹ím o
projekt <i>Lambda</i> popsaný <a
href="http://www.root.cz/clanky/novinky-v-nbsp-jdk-7-5-ndash-projekt-lambda-a-anonymni-funkce-v-nbsp-prikladech/">minule</a>
a <a
href="http://www.root.cz/clanky/novinky-v-nbsp-jdk-7-aneb-mirny-pokrok-v-nbsp-mezich-zakona-ndash-projekt-lambda/">pøedminule</a>).
Dnes si naopak popí¹eme jednu vlastnost <i>JDK</i>, která sice byla pùvodnì
plánována a¾ pro <i>JDK 7</i>, ov¹em vzhledem k&nbsp;tomu, ¾e zavedení tohoto
vylep¹ení nevedlo k&nbsp;nutnosti zmìny syntaxe ani sémantiky jazyka a dokonce
ani nedo¹lo k&nbsp;¾ádným zmìnám v&nbsp;generovaném bajtkódu, se tato novinka
mohla objevit ji¾ v&nbsp;novìj¹ích verzích <i>OpenJDK 6</i> a takté¾
v&nbsp;oficiálním (binárním) <i>JDK 6</i> nabízeným firmou Oracle. Konkrétnì je
tato vlastnost zahrnuta v&nbsp;<a
href="http://www.oracle.com/technetwork/java/javase/6u14-137039.html?ssSourceSiteId=otncn">JDK
1.6.0_14 (6u14)</a> (je o pøibli¾nì rok staré vydání JDK) a samozøejmì i ve v¹ech
následujících (novìj¹ích) oficiálních vydáních <i>JDK 6</i>.</p>

<p>Vlastnost <i>JDK</i>, kterou se dnes budeme zabývat, se jmenuje
<i>compressed oops</i>, co¾ je mo¾né pøelo¾it jako komprimované ukazatele na
(obyèejné) objekty, nebo» zkratka <strong>oop</strong> ve skuteènosti vznikla
ze sousloví &bdquo;ordinary object pointer&ldquo; a poslední &bdquo;s&ldquo; ve
zkratce je jen vyjádøením mno¾ného èísla v&nbsp;angliètinì. Zkratkou
<strong>oop</strong> jsou pojmenovány ukazatele na objekty vytváøené a
spravované v&nbsp;rámci virtuálního stroje. Programátoøi vytváøející programy
v&nbsp;Javì vìdí, ¾e v&nbsp;jejich programech je mo¾né pou¾ívat jak primitivní
datové typy (celá èísla, znaky, numerické hodnoty s&nbsp;pohyblivou øádovou
èárkou, pravdivostní hodnotu), tak i objektové typy (referenèní typy). Promìnné
èi atributy primitivních datových typù jsou reprezentovány pøímo svou hodnotou,
zatímco objektové typy jsou ulo¾eny jako reference, co¾ není nic jiného ne¾
ukazatel na objekt vytvoøený na <i>haldì &ndash; heapu</i> (ve skuteènosti v¹ak
specifikace JVM neøíká, ¾e se musí jednat o pøímé ukazatele na instance
javovských tøíd, proto¾e napøíklad pro rychlé pøesuny objektù v&nbsp;rámci
haldy mohou být vhodnìj¹í ukazatele nepøímé). V&nbsp;samotné Javì nejsou tyto
ukazatele pøímo mìnitelné, ani s&nbsp;nimi nelze provádìt ukazatelovou
aritmetiku (tak jako je tomu v&nbsp;céèku èi C++), ale jejich hodnotu je mo¾né
zjistit napøíklad v&nbsp;rùzných monitorovacích a debugovacích nástrojích.</p>



<p><a name="k02"></a></p>
<h2>2. Platforma i386 a 32bitové operaèní systémy</h2>

<p>Maximální velikost haldy a tím pádem i poèet objektù, které se na haldu
mohou ulo¾it, je shora omezena jak mo¾nostmi operaèního systému, tak i pou¾itým
mikroprocesorem a jím podporovaným rozsahem adres. Programovací jazyk Java byl
i se svým bìhovým prostøedím (<i>JRE</i>) portován na poèítaèe PC
v&nbsp;dobách, kdy byly tyto poèítaèe vybavené 32bitovými mikroprocesory
(<i>JDK 1.0</i> zaèalo být nabízeno v&nbsp;roce 1996, 32bitové mikroprocesory
øady x86 existují ji¾ od roku 1985). Tyto mikroprocesory sice mohly být
z&nbsp;dùvodu zpìtné kompatibility s&nbsp;aplikacemi urèenými pro operaèní
systém DOS pøepnuty do ¹estnáctibitového re¾imu (buï se jednalo o reálný re¾im
&ndash; real mode &ndash; èi o re¾im virtuální), nicménì samotné bìhové
prostøedí Javy (<i>JRE</i>) bylo urèeno pro nativní plnohodnotný 32bitový re¾im
tìchto mikroprocesorù, v&nbsp;nìm¾ se pou¾ívají 32bitové pracovní registry a
32bitové ukazatele. Kvùli pou¾ití 32bitových ukazatelù (vèetnì 32bitového PC a
ESP) je mo¾né adresovat a tím pádem i vyu¾ít &bdquo;pouze&ldquo; adresní
prostor o velikosti 4 GB (2<sup>32</sup> bajtù), do nìho¾ jsou v¹ak kromì
vlastní operaèní pamìti adresovány napøíklad i oblasti pamìti dostupné pøes PCI
sbìrnici èi port AGP (typicky se jedná o framebuffer grafické karty) a èást
z&nbsp;tohoto rozsahu si nárokuje i samotné jádro operaèního systému
(v&nbsp;pøípadì Linuxu a¾ 1 GB adresního rozsahu).</p>

<p>Informace uvedené v&nbsp;pøedchozím odstavci jsou ponìkud zjednodu¹ené,
proto¾e ¹íøka logické adresy mù¾e díky pou¾ití selektorù dosáhnout a¾
13+1+32=46 bitù (zmínìných 13+1 bitù je umístìno v&nbsp;pøíslu¹ném 16bitovém
selektoru, který nahradil pùvodní segmentové registry známé z&nbsp;reálného
re¾imu, pøièem¾ 13 bitù ukazuje do globální èi lokální tabulky deskriptorù a
zbývající bit rozhoduje o tom, zda se pou¾ije lokální èi globální tabulka
deskriptorù &ndash; LDT èi GDT). Ov¹em výsledná fyzická adresa je na pùvodní
architektuøe <i>x86</i> skuteènì jen 32bitová, a to bez ohledu na to, zda je
zapnuto èi vypnuto stránkování (<i>paging</i>). Navíc se v&nbsp;souèasných
operaèních systémech pou¾ívá pouze stránkování a pou¾ití selektorù/deskriptorù
se obchází takovým zpùsobem, ¾e se rozsahy v¹ech ètyø selektorových segmentù
nastavují na plný rozsah 4 GB a nulovou bázovou adresu. Èásteènì lze zmínìné
omezení adresového prostoru na rozsah &bdquo;pouhých&ldquo; ètyø gigabajtù na
moderních mikroprocesorech (a systémech, které to umo¾òují!) obejít pou¾itím
<i>PAE (Physical Address Extension)</i> a zvý¹it tak adresovatelnou kapacitu
operaèní pamìti v&nbsp;Linuxu a¾ na 64 GB. Vìt¹í adresní rozsah je pøi pou¾ití
<i>PAE</i> zaji¹tìn díky pou¾ití 64bitových adres v&nbsp;tabulce stránek
&ndash; page table. Ov¹em velikost ukazatelù pou¾ívaných jednotlivými procesy
zùstává stále omezena na 32 bitù. Z&nbsp;toho vyplývá, ¾e jeden proces
(napøíklad ji¾ zmínìné bìhové prostøedí Javy &ndash; <i>JRE</i> i se svou
haldou) mù¾e stále vyu¾ívat maximálnì necelé ètyøi gigabajty operaèní
pamìti.</p>



<p><a name="k03"></a></p>
<h2>3. Platforma x86_64 &ndash; roz¹íøení adresování na 64 bitù</h2>

<p>Java v¹ak samozøejmì není pou¾ívána pouze na 32bitových platformách. Nìkteré
moderní mikroprocesory pou¾ívané na PC je toti¾ mo¾né pøepnout, pokud
k&nbsp;tomu samozøejmì existuje podpora v&nbsp;operaèním systému, do
plnohodnotného 64bitového re¾imu oznaèovaného jako <i>x86_64</i> (rùzní výrobci
procesorù pou¾ívají rùzná oznaèení, zmínìné <i>x86_64</i> je neutrální a
nepreferuje registrované názvy jednotlivých výrobcù CPU). V&nbsp;tomto re¾imu
se bitová ¹íøka pracovních registrù (pou¾ívaných kromì bì¾ných aritmetických a
logických operací mj.&nbsp;i pro adresování) zvy¹uje na plných ¹edesát ètyøi
bitù a navíc se namísto pùvodní osmice pracovních 32bitových registrù EAX, EBX, ECX, EDX,
EBP, ESP, ESI, EDI pou¾ívá dvojnásobný poèet pracovních registrù RAX, RBX, RCX,
RDX, RBP, RSP, RSI, RDI, R8, R9, R10, R11, R12, R13, R14, R15, èeho¾ samozøejmì
vyu¾ívá jak interpret Javy, tak i JIT pøekladaè, jeho¾ úkolem je detekovat ty
èásti javovského kódu, které se èasto pou¾ívají a tyto bloky následnì pøelo¾it
do nativního kódu mikroprocesoru. Díky pou¾ití 64bitových ukazatelù je
teoreticky mo¾né i v&nbsp;rámci jednoho procesu adresovat a¾ 16 EB pamìti
(2<sup>64</sup> bajtù), i kdy¾ v&nbsp;souèasnosti je z&nbsp;praktických dùvodù
tato kapacita omezena na 40 a¾ 48 bitù adresy, co¾ odpovídá 2<sup>40</sup>=1 TB
a¾ 2<sup>48</sup>=256 TB.</p>

<p>Napøíklad u mikroprocesorù <i>Opteron</i> lze pou¾ít 48 bitù virtuální
adresy a 40 bitù fyzické adresy, co¾ jinými slovy znamená, ¾e nelze
nainstalovat více ne¾ 1 TB operaèní pamìti. To je minimálnì pro osobní poèítaèe
prozatím skoro neskuteèná kapacita, i kdy¾, kdo ví, kam se v&nbsp;budoucnu
posunou nároky neustále vznikajícího bloatware :-). Vìt¹í rozsah fyzické
adresy, konkrétnì 48 bitù, podporují napøíklad mikroprocesory <i>Intel Core
i3</i>, <i>Intel Core i5</i>, <i>Intel Core i7</i>, <i>Intel Atom</i> a takté¾
<i>AMD Phenom</i>. V&nbsp;souèasných verzích mikroprocesorù jsou dokonce i
tabulky pamì»ových stránek zmen¹eny (optimalizovány) takovým zpùsobem, ¾e se
v&nbsp;nich pou¾ívají pouze 48 bitové adresy s&nbsp;tím, ¾e se pøedpokládá, ¾e
ètyøicátý osmý bit adresy (s&nbsp;indexem 47) je pøi výpoètech adres zdánlivì
opakován i ve zbývajících vy¹¹ích bitech s&nbsp;indexy 48 a¾ 63 (jakoby byla
adresa celým èíslem se znaménkem). Ve výsledku se tedy celý 64bitový adresní
rozsah mikroprocesoru rozdìlí na tøi èásti &ndash; spodní oblast pamìti (adresy
00000000&nbsp;00000000 a¾ 00007FFF&nbsp;FFFFFFFF), kde jsou ulo¾eny aplikace a
jejich data, neobsazenou oblast o rozsahu 00008000&nbsp;00000000 a¾
FFFF7FFF&nbsp;FFFFFFFF a koneènì o horní oblast pamìti o rozsahu
FFFF8000&nbsp;00000000 a¾ FFFFFFFF&nbsp;FFFFFFFF rezervovanou pro potøeby jádra
&ndash; viz té¾ vysvìtlující obrázky na Wikipedii <a
href="http://en.wikipedia.org/wiki/X86-64#Canonical_form_addresses">http://en.wikipedia.org/wiki/X86-64#Canonical_form_addresses</a>.</p>



<p><a name="k04"></a></p>
<h2>4. JVM v&nbsp;32bitových a 64bitových systémech</h2>

<p>Aplikace naprogramované v&nbsp;Javì jsou, jak je známo, do velké míry
nezávislé na pou¾ité platformì i operaèním systému. Mezi výjimky
v&nbsp;nezávislosti patøí napøíklad volání nativních funkcí nebo rùzné chyby
(které kupodivu nebývají kompatibilní mezi jednotlivými systémy :-). Ov¹em
vlastnosti platformy i operaèního systému pøesto chování javovských programù
ovlivòují. Týká se to pøedev¹ím maximální velikosti haldy, která mù¾e mít na
32bitových platformách maximální teoretickou velikost 4 GB (prakticky je to cca
2,5 GB), proto¾e se pro adresování objektù na haldì ulo¾ených pou¾ívají nativní
32bitové ukazatele. Naproti tomu pøi pøechodu na 64bitovou platformu pou¾ívá
JVM internì 64bitové nativní ukazatele a velikost haldy je tudí¾ na souèasných
poèítaèích prakticky neomezená. Mohlo by se tedy zdát, ¾e programátoøi ani
u¾ivatelé pou¾ívající javovské programy na 64bitových platformách (dnes
pøedev¹ím na platformì <i>x86_64</i>) nebudou mít díky vìt¹í maximální
velikosti haldy s&nbsp;provozem i rozsáhlých a datovì nároènìj¹ích aplikací
¾ádné problémy, spí¹e naopak.</p>

<p>Ve skuteènosti ov¹em pou¾ití nativních 64bitových ukazatelù mù¾e mít
v&nbsp;nìkterých pøípadech negativní dopad na výkonnost aplikací a také na
potøebnou kapacitu operaèní pamìti, kterou je zapotøebí alokovat pro haldu
(heap). Samotná operaèní pamì» je sice dnes pomìrnì levnou komoditou, to ov¹em
ani zdaleka neplatí pro vyrovnávací pamìti první a druhé úrovnì, jejich¾
velikost a rychlost do znaèné míry ovlivòuje výkonnost celého poèítaèe. To
znamená, ¾e pokud je napøíklad kvùli pou¾ití 64bitových ukazatelù nutné
alokovat cca 1,5 násobek velikosti haldy potøebné pùvodnì v&nbsp;32 bitovém
prostøedí, bude pøi pøístupu k&nbsp;objektùm docházet èastìji k&nbsp;výpadkùm
stránek z&nbsp;vyrovnávací pamìti a celý výpoèet se zpomalí (mno¾ství pøístupù
k&nbsp;objektùm na haldì navíc není mo¾né snadno ovlivnit, proto¾e ve vláknech
na pozadí bì¾í garbage collector, co¾ bude mimochodem téma nìkterého
z&nbsp;dal¹ích èlánkù). Vývojáøi JDK ve firmì Oracle provedli mìøení, o kolik
se zvý¹í potøebná kapacita haldy pøi pøechodu z&nbsp;32bitových na 64bitové
ukazatele a do¹li k&nbsp;hodnotám 20% a¾ 50% &ndash; to znamená, ¾e nìkteré
programy pou¾ívají velké mno¾ství referencí, které významným zpùsobem ovlivòují
zaplnìní haldy (viz té¾ hodnoty uvedené v&nbsp;osmé kapitole).</p>



<p><a name="k05"></a></p>
<h2>5. Komprimované ukazatele na objekty</h2>

<p>Zdánlivì jsme se tedy ocitli v&nbsp;urèité pasti: pou¾ití platformy
<i>x86_64</i> je sice z&nbsp;jednoho pohledu velmi výhodné, proto¾e je mo¾né
pou¾ívat dvojnásobný poèet pracovních registrù a kapacita haldy je prakticky
neomezená, ov¹em na druhou stranu je na haldì nutné alokovat o x-desítek
procent více bajtù, co¾ vede k&nbsp;vìt¹í pravdìpodobnosti výpadkù stránek
z&nbsp;vyrovnávací pamìti a tudí¾ i ke zpomalení výpoètù. Nicménì právì
v&nbsp;tomto ohledu je mo¾né vyu¾ít toho, ¾e javovské programy nejsou
pøekládány pøímo do nativního kódu, ale jsou buï interpretovány v&nbsp;JRE
popø.&nbsp;a¾ v&nbsp;dobì bìhu aplikace pøekládány JITem. Navíc programátoøi
nemají v&nbsp;Javì mo¾nost pøímo pracovat s&nbsp;hodnotami referencí na objekty
&ndash; mohou tyto reference pouze vytváøet (operátorem <strong>new</strong> èi
konstrukcí statického pole), pøedávat jako parametry a pøiøazovat je atributùm
a lokálním promìnným. Z&nbsp;tohoto dùvodu je mo¾né &ndash; na rozdíl od
napøíklad céèkovských programù &ndash; aby se namísto nativních 64bitových
ukazatelù (=referencí na objekty) pou¾ívaly napøíklad pouze 32bitové
ukazatele.</p>

<p>Výsledkem této my¹lenky jsou komprimované ukazatele neboli <i>compressed
oops</i>. Tyto ukazatele mají i na platformì <i>x86_64</i> ¹íøku 32bitù, ov¹em
<strong>neobsahují</strong> pøímo adresu objektu na haldì, nýbr¾ index
vyjádøený jako násobek osmi bajtù. Jinými slovy &ndash; skuteèná adresa objektu
na haldì se vypoèítá z&nbsp;32bitového indexu vynásobeného osmi, neboli
posunutého o tøi bity doleva (jiné hodnoty posunu a tím pádem i jinou maximální
velikost haldy, prozatím <strong>nejde nastavit</strong>). To znamená, ¾e
v¹echny objekty musí být na haldì
zarovnané na osm bajtù, co¾ v&nbsp;reálných pøípadech není nijak velké plýtvání
pamìtí. Díky 32bitovým indexùm lze mít na haldì ulo¾eny a¾ 4 miliardy objektù
(pøesnìji 2<sup>32</sup>-1) a souèasnì mù¾e velikost haldy dosahovat velikosti
a¾ 32 GB (2<sup>32</sup>&times;8). Pokud je pøi spu¹tìní JRE specifikováno
(-Xmx atd.), ¾e má mít halda vìt¹í kapacitu ne¾ 32 GB, je pou¾ití
komprimovaných ukazatelù automaticky vypnuto (s&nbsp;takovou aplikací jsem se
sice prozatím nesetkal, ale vìøím, ¾e napøíklad pro nìjaké in-memory databáze
existuje). V&nbsp;nìkterých verzích JDK nejsou i pøi men¹í kapacitì haldy
komprimované ukazatele povoleny, co¾ je mo¾né pøi startu JRE napravit
následujícím pøepínaèem:</p>

<pre>
-XX:+UseCompressedOops
</pre>

<p>Nìkdy je výhodné naopak pou¾ití compressed oops zakázat, proto¾e nìkteré
nástroje (debuggery) mohou mít problémy s&nbsp;analýzou obsahu haldy (navíc
byla teprve nedávno opravena chyba, která zpùsobovala pády Eclipse):</p>

<pre>
-XX:-UseCompressedOops
</pre>

<p>Navíc se pou¾ití komprimovaných ukazatelù týká pouze bì¾ícího programu,
proto¾e v&nbsp;pøekládaném bajtkódu k&nbsp;¾ádným zmìnám nedo¹lo (ostatnì
v&nbsp;samotném bajtkódu existuje mno¾ství zcela jiných omezení týkajících se
poètu atributù a konstant v&nbsp;jedné tøídì, poètu metod, délky metod, poètu
parametrù metod, poètu lokálních promìnných a poètu dimenzí pole).</p>



<p><a name="k06"></a></p>
<h2>6. Co se stane s&nbsp;hodnotami NULL?</h2>

<p>S&nbsp;komprimovanými ukazateli souvisí je¹tì jeden problém, který se týká
zpùsobu práce s&nbsp;hodnotou <strong>NULL</strong>. Tato hodnota bývá internì
skuteènì reprezentována nulou (tj.&nbsp;ukazatelem na adresu 0), ov¹em vzhledem
k&nbsp;tomu, ¾e se explicitní èi implicitní test na <strong>NULL</strong>
vyskytuje v&nbsp;bì¾ících programech velmi èasto (èastìji jde o test implicitní
provádìný napøíklad pøi volání metod), je v&nbsp;JRE pou¾ita velmi jednoduchá a
vìt¹inou i úèinná metoda, která nutnost provádìní tìchto testù eliminuje. Halda
je jak na 32bitových, tak i na 64bitových platformách umístìna v&nbsp;segmentu
pamìti s&nbsp;nulovou bázovou adresou a navíc nultá stránka pamìti buï není
vùbec mapována nebo je do ní zakázán pøístup (samotná halda v¹ak nemusí ve
skuteènosti zaèínat ji¾ od poèátku pamìti, zále¾í na konkrétních hodnotách
ukazatelù pøidìlovaných JRE). To znamená, ¾e pokud se programátor bude sna¾it
pøistupovat k&nbsp;objektu pøes referenci rovnou <strong>NULL</strong>
(adresa=0), dojde na úrovni operaèního systému k&nbsp;poslání signálu do JRE,
která tento signál vìt¹inou zpracuje jednodu¹e tak, ¾e v&nbsp;aplikaci vyvolá
nechvalnì známou výjimku <strong>NPE &ndash; Null Pointer Exception</strong>
(samotný systém ¾ádný test na pøístup k&nbsp;nulté stránce samozøejmì
neprovádí, to je vìcí mikroprocesoru a v&nbsp;nìm integrovaného øadièe
pamìti).</p>

<p>Daní za toto zjednodu¹ení a urychlení práce JRE je v¹ak to, ¾e celá jedna
stránka pamìti (bì¾nì 4 kB, pokud se nepou¾ívají huge-pages) není vyu¾itelná
pro ¾ádná data. Pøi pou¾ití komprimovaných ukazatelù se JRE takté¾ sna¾í o
vytvoøení haldy v&nbsp;pamìti s&nbsp;nulovou bází a opìt se sna¾í o uzamknutí
nulté stránky pamìti. Po dekódování adresy z&nbsp;indexu, tj.&nbsp;po bitovém
posuvu indexu o tøi bity doleva, je vìt¹inou provedeno zdánlivé ètení
z&nbsp;dekódované adresy, které v&nbsp;pøípadì, ¾e se jedná o referenci
<strong>NULL</strong> opìt vede k&nbsp;vyvolání výjimky mechanismem podobným,
jaký byl popsán vý¹e. U tìch platforem, kde není mo¾né, aby halda zaèínala od
adresy 0, se alespoò na úrovni JRE eliminují testy na <strong>NULL</strong> u
tìch typù referencí, u nich¾ je zøejmé, ¾e tuto speciální hodnotu nikdy nebudou
obsahovat. Týká se to napøíklad návratové hodnoty metody
<i>Object.getClass()</i>.</p>



<p><a name="k07"></a></p>
<h2>7. Testovací pøíklady</h2>

<p>Pro úèely testování vlivu pou¾ití komprimovaných ukazatelù na celkové
vyu¾ití haldy mù¾eme pou¾ít demonstraèní pøíklady, jejich¾ pamì»ové nároky lze
prozkoumat napøíklad nástrojem <i>jconsole</i>, který se doká¾e pøipojit
k&nbsp;bì¾ící <i>JRE</i> a zjistit velké mno¾ství parametrù tohoto virtuálního
stroje. Mù¾e se pøitom jednat jak o virtuální stroj bì¾ící na stejném poèítaèi
jako samotná <i>jconsole</i>, tak i o vzdálené JRE, co¾ je zvlá¹tì výhodné
napøíklad pro monitorování zatí¾ení serverù. První demonstraèní pøíklad je
velmi jednoduchý &ndash; po svém spu¹tìní vytvoøí seznam, do nìho¾ vlo¾í
<i>n</i> objektù typu <i>Pair</i>, z&nbsp;nich¾ ka¾dý obsahuje dvojici objektù
typu <i>Item</i>. Na haldì by se po zkonstruování <i>n</i> objektù a jejich
vlo¾ení do seznamu mìla alokovat pamì» obsahující jak hodnoty primitivního
datového typu <i>int</i> (co¾ jsou 4 bajty), tak i mno¾ství referencí, které
mohou mít podle nastavených parametrù JRE i mo¾ností pou¾ité platformy délku
ètyø nebo osmi bajtù. Zdrojový kód tohoto pøíkladu je velmi jednoduchý:</p>

<pre>
import java.util.*;
&nbsp;
class Item
{
    public Item(int i)
    {
        this.i = i;
    }
    int i;
}
&nbsp;
class Pair
{
    public Item item1;
    public Item item2;
&nbsp;
    public Pair(int i1, int i2)
    {
        this.item1=new Item(i1);
        this.item2=new Item(i2);
    }
}
&nbsp;
public class Test
{
    public static void main(String[] args)
    {
        System.console().readLine("press enter to begin");
&nbsp;
        int n = Integer.parseInt(args[0]);
        List&lt;Pair&gt; list = new ArrayList&lt;Pair&gt;();
        for (int i=0; i&lt;n; i++)
        {
            if (i%1000 == 0)
            {
                System.out.print(i + "\t");
            }
            list.add(new Pair(i, i));
        }
&nbsp;
        System.console().readLine("\ndone, press enter again");
    }
}
</pre>

<p>Druhý demonstraèní pøíklad byl získán ze stránky <i>Great Computer Language
Shootout</i> (<a
href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>).
V&nbsp;tomto pøíkladu se vytváøí binární strom, jeho¾ uzly obsahují jak
reference na dvojici poduzlù, tak i ulo¾enou hodnotu typu <i>int</i>. I
v&nbsp;tomto pøípadì by mìl být rozdíl mezi pou¾itím komprimovaných ukazatelù a
nekomprimovaných ukazatelù na platformì <i>x86_64</i> pøi mìøení viditelný:</p>

<pre>
/* The Great Computer Language Shootout
   http://shootout.alioth.debian.org/
 &nbsp;
   contributed by Jarkko Miettinen
*/
&nbsp;
public class binarytrees {
&nbsp;
    private final static int minDepth = 4;
&nbsp;
    public static void main(String[] args){
        int n = 0;
        if (args.length &gt; 0) n = Integer.parseInt(args[0]);
&nbsp;
        int maxDepth = (minDepth + 2 &gt; n) ? minDepth + 2 : n;
        int stretchDepth = maxDepth + 1;
&nbsp;
        int check = (TreeNode.bottomUpTree(0,stretchDepth)).itemCheck();
        System.out.println("stretch tree of depth "+stretchDepth+"\t check: " + check);
&nbsp;
        TreeNode longLivedTree = TreeNode.bottomUpTree(0,maxDepth);
&nbsp;
        for (int depth=minDepth; depth&lt;=maxDepth; depth+=2){
            int iterations = 1 &lt;&lt; (maxDepth - depth + minDepth);
            check = 0;
&nbsp;
            for (int i=1; i&lt;=iterations; i++){
                check += (TreeNode.bottomUpTree(i,depth)).itemCheck();
                check += (TreeNode.bottomUpTree(-i,depth)).itemCheck();
            }
            System.out.println((iterations*2) + "\t trees of depth " + depth + "\t check: " + check);
        }   
        System.out.println("long lived tree of depth " + maxDepth + "\t check: "+ longLivedTree.itemCheck());
    }
&nbsp;
    private static class TreeNode
    {
        private TreeNode left, right;
        private int item;
&nbsp;
        TreeNode(int item){
            this.item = item;
        }
&nbsp;
        private static TreeNode bottomUpTree(int item, int depth){
            if (depth&gt;0){
                return new TreeNode(
                        bottomUpTree(2*item-1, depth-1)
                        , bottomUpTree(2*item, depth-1)
                        , item
                );
            }
            else {
                return new TreeNode(item);
            }
        }
&nbsp;
        TreeNode(TreeNode left, TreeNode right, int item){
            this.left = left;
            this.right = right;
            this.item = item;
        }
&nbsp;
        private int itemCheck(){
            // if necessary deallocate here
            if (left==null) return item;
            else return item + left.itemCheck() - right.itemCheck();
        }
    }
}
</pre>



<p><a name="k08"></a></p>
<h2>8. Porovnání rychlosti a obsazení pamìti pøi pou¾ití komprimovaných ukazatelù</h2>

<p>V&nbsp;materiálech firmy <i>Oracle</i> se pí¹e o tom, ¾e se pou¾itím
komprimovaných ukazatelù mù¾e výraznì sní¾it velikost haldy a souèasnì i
urychlit bìh aplikací. To je sice z&nbsp;teoretického hlediska oprávnìné
tvrzení, proto¾e jediná operace navíc, kterou musí JITovaný kód
s&nbsp;komprimovanými ukazateli provést, jsou bitové posuny, ov¹em statistické
výsledky si samozøejmì musíme zfal¹ovat sami :-). Nejprve se podívejme, jak
vypadá první pøíklad spu¹tìný na systému <i>RHEL 5</i> na platformì
<i>x86_64</i>. Testování probíhalo s&nbsp;<i>IcedTea6 HEAD</i> (zkompilováno
dnes se standardními volbami pøi pøekladu), pro vlastní mìøení byl pou¾it ji¾
zmínìný nástroj <i>jconsole</i>. U grafù si pov¹imnìte i zmìøeného èasu bìhu
garbage collectoru. Ve v¹ech pøípadech byla maximální velikost haldy nastavena
na 2,5 GB:</p>

<a href="http://i.iinfo.cz/images/480/java0601.png"><img src="http://i.iinfo.cz/images/480/java0601-prev.png" width="370" height="240" alt=" " /></a>
<p><i>Graf 1: První demonstraèní pøíklad pøi vlo¾ení 10 milionù prvkù do
seznamu se zapnutou komprimací ukazatelù.</i></p>

<a href="http://i.iinfo.cz/images/110/java0602.png"><img src="http://i.iinfo.cz/images/110/java0602-prev.png" width="370" height="240" alt=" " /></a>
<p><i>Graf 2: První demonstraèní pøíklad pøi vlo¾ení 10 milionù prvkù do
seznamu s&nbsp;vypnutou komprimací ukazatelù.</i></p>

<a href="http://i.iinfo.cz/images/679/java0603.png"><img src="http://i.iinfo.cz/images/679/java0603-prev.png" width="370" height="241" alt=" " /></a>
<p><i>Graf 3: První demonstraèní pøíklad pøi vlo¾ení 20 milionù prvkù do
seznamu se zapnutou komprimací ukazatelù.</i></p>

<a href="http://i.iinfo.cz/images/564/java0604.png"><img src="http://i.iinfo.cz/images/564/java0604-prev.png" width="370" height="239" alt=" " /></a>
<p><i>Graf 4: První demonstraèní pøíklad pøi vlo¾ení 20 milionù prvkù do
seznamu s&nbsp;vypnutou komprimací ukazatelù.</i></p>

<p>Druhý demonstraèní pøíklad byl spu¹tìn s&nbsp;volbou 23, která urèuje
maximální hloubku vytváøeného stromu (24 úrovní). U tohoto pøíkladu jsem zmìøil
i èas bìhu programu pomocí unixové utility <strong>time</strong>. Èas tedy
zahrnuje i spu¹tìní JRE a prvotní &bdquo;JITování&ldquo; bajtkódu do nativního
strojového kódu:</p>

<p>Druhý demonstraèní pøíklad spu¹tìný se zapnutou komprimací ukazatelù:</p>

<pre>
real    1m23.141s
user    2m23.154s
sys     0m1.465s
</pre>

<p>Druhý demonstraèní pøíklad spu¹tìný s&nbsp;vypnutou komprimací
ukazatelù:</p>

<pre>
real    3m48.769s
user    6m9.920s
sys     0m2.323s
</pre>

<p>Rozdíly v&nbsp;èasech bìhu jsou mj.&nbsp;zpùsobeny i rozdílnou dobou bìhu
garbage collectoru, co¾ je ostatnì patrné i z&nbsp;údajù uvedených pod
následujícími grafy:</p>

<a href="http://i.iinfo.cz/images/327/java0605.png"><img src="http://i.iinfo.cz/images/327/java0605-prev.png" width="370" height="239" alt=" " /></a>
<p><i>Graf 5: Druhý demonstraèní pøíklad pøi hloubce binárního stromu 24 úrovní
se zapnutou komprimací ukazatelù.</i></p>

<a href="http://i.iinfo.cz/images/685/java0606.png"><img src="http://i.iinfo.cz/images/685/java0606-prev.png" width="370" height="239" alt=" " /></a>
<p><i>Graf 6: Druhý demonstraèní pøíklad pøi hloubce binárního stromu 24 úrovní
s&nbsp;vypnutou komprimací ukazatelù.</i></p>

<p>Vý¹e uvedené grafy a hodnoty skuteènì ukazují sní¾ení alokované pamìti pro
haldu, ov¹em mìøení pro konkrétní situaci (napøíklad aplikaèní server
s&nbsp;nasazenými aplikacemi) si samozøejmì musí vývojáø provést sám &ndash; je
toti¾ pravdìpodobné, ¾e jím namìøené hodnoty se mohou odli¹ovat.</p>



<p><a name="k09"></a></p>
<h2>9. Odkazy na Internetu</h2>

<ol>

<li>Compressed oops in the Hotspot JVM<br />
<a href="http://wikis.sun.com/display/HotSpotInternals/CompressedOops">http://wikis.sun.com/display/HotSpotInternals/CompressedOops</a>
</li>

<li>32-bit or 64-bit JVM? How about a Hybrid?<br />
<a href="http://blog.juma.me.uk/2008/10/14/32-bit-or-64-bit-jvm-how-about-a-hybrid/">http://blog.juma.me.uk/2008/10/14/32-bit-or-64-bit-jvm-how-about-a-hybrid/</a>
</li>

<li>Compressed object pointers in Hotspot VM<br />
<a href="http://blogs.sun.com/nike/entry/compressed_object_pointers_in_hotspot">http://blogs.sun.com/nike/entry/compressed_object_pointers_in_hotspot</a>
</li>

<li>Java HotSpot(tm) Virtual Machine Performance Enhancements<br />
<a href="http://download.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html">http://download.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html</a>
</li>

<li>Using jconsole<br />
<a href="http://download.oracle.com/javase/1.5.0/docs/guide/management/jconsole.html">http://download.oracle.com/javase/1.5.0/docs/guide/management/jconsole.html</a>
</li>

<li>jconsole &ndash; Java Monitoring and Management Console<br />
<a href="http://download.oracle.com/javase/1.5.0/docs/tooldocs/share/jconsole.html">http://download.oracle.com/javase/1.5.0/docs/tooldocs/share/jconsole.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>x86-64<br />
<a href="http://en.wikipedia.org/wiki/X86-64">http://en.wikipedia.org/wiki/X86-64</a>
</li>

<li>Physical Address Extension<br />
<a href="http://en.wikipedia.org/wiki/Physical_Address_Extension">http://en.wikipedia.org/wiki/Physical_Address_Extension</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>1.6.0_14 (6u14)<br />
<a href="http://www.oracle.com/technetwork/java/javase/6u14-137039.html?ssSourceSiteId=otncn">http://www.oracle.com/technetwork/java/javase/6u14-137039.html?ssSourceSiteId=otncn</a>
</li>

<li>Update Release Notes<br />
<a href="http://www.oracle.com/technetwork/java/javase/releasenotes-136954.html">http://www.oracle.com/technetwork/java/javase/releasenotes-136954.html</a>
</li>

<li>4.10 Limitations of the Java Virtual Machine<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#88659">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#88659</a>
</li>

<li>Java(TM) Platform, Standard Edition 7 Binary Snapshot Releases<br />
<a href="http://dlc.sun.com.edgesuite.net/jdk7/binaries/index.html">http://dlc.sun.com.edgesuite.net/jdk7/binaries/index.html</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>ClosableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>ArrayList (JDK 1.4)<br />
<a href="http://download.oracle.com/javase/1.4.2/docs/api/java/util/ArrayList.html">http://download.oracle.com/javase/1.4.2/docs/api/java/util/ArrayList.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2010</small></p>
</body>
</html>

