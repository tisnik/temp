<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (11 - JIT pøeklad do nativního kódu procesorù s architekturami x86 a ARM)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (11 - JIT pøeklad do nativního kódu procesorù s architekturami x86 a ARM)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Tøetím krokem JIT pøekladu provádìného LuaJITem je transformace pseudoinstrukcí do nativního kódu mikroprocesoru, na nìm¾ je LuaJIT spu¹tìn. LuaJIT podporuje pøeklad s vyu¾itím instrukèních sad mikroprocesorù Intel i AMD (32 bit, 64 bit), ARM (prozatím 32 bit), MIPS a PowerPC. Právì touto problematikou se budeme zabývat dnes.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (11 - JIT pøeklad do nativního kódu procesorù s architekturami x86 a ARM)</a></p>
<p><a href="#k02">2. Specifika pøekladu pro rùzné mikroprocesorové architektury</a></p>
<p><a href="#k03">3. x86 (32 bit)</a></p>
<p><a href="#k04">4. x86_64 (64 bit)</a></p>
<p><a href="#k05">5. ARM (32 bit)</a></p>
<p><a href="#k06">6. Demonstraèní pøíklad: jednoduchá programová smyèka typu <strong>while</strong></a></p>
<p><a href="#k07">7. Pøeklad demonstraèního pøíkladu do nativního kódu</a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k071">7.1 Pøeklad pro architekturu x86 (32 bit)</a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k072">7.2 Pøeklad pro architekturu x86_64 (64 bit)</a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k073">7.3 Pøeklad pro architekturu ARM (32 bit)</a></p>
<p><a href="#k08">8. Literatura</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (11 - JIT pøeklad do nativního kódu procesorù s architekturami x86 a ARM)</h2>

<p>V&nbsp;dne¹ní èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
trasovacím just-in-time pøekladaèi LuaJIT</a> se budeme zabývat pøevá¾nì
zpùsobem transformace pseudokódu do nativního (strojového) kódu zvoleného typu
mikroprocesoru. Pøipomeòme si, ¾e se jedná o tøetí pøeklad (èi mo¾ná lépe
øeèeno transformaci) provádìný LuaJITem. První pøeklad je aplikován na ve¹kerý
spou¹tìný kód: zdrojový text napsaný v&nbsp;Lue je pøekládán do bajtkódu (<a
href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-2/">[1]</a>,
<a
href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-3/">[2]</a>,
<a
href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-4/">[3]</a>,
<a
href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-5-tabulky-a-pole/">[4]</a>,
<a
href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-6-preklad-programovych-smycek-do-mezijazyka-luajitu/">[5]</a>
a <a
href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-7-dokonceni-popisu-mezijazyka-luajitu/">[6]</a>).</p>

<p>Tento bajtkód je následnì interpretován a teprve ve chvíli, kdy se zjistí,
¾e nìjakou èást bajtkódu lze pova¾ovat za <i>hot loop</i> èi <i>hot call</i>,
je spu¹tìn vlastní just-in-time pøeklad, který detekované &bdquo;stopy&ldquo;
(<i>trace</i>) transformuje do mezikódu a následnì pak do nativního kódu
kompatibilního s&nbsp;aktuálnì pou¾ívaným mikroprocesorem.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Specifika pøekladu pro rùzné mikroprocesorové architektury</h2>

<p><i>LuaJIT</i> pøi pøekladu do nativního kódu vyu¾ívá nìkteré optimalizaèní
techniky, ov¹em velmi dùle¾itý je i fakt, ¾e se sna¾í o zji¹tìní, zda se
v&nbsp;promìnných (a výrazech, programových smyèkách apod.) pøi práci
s&nbsp;numerickými hodnotami pou¾ívají celá èísla (<i>integer</i>) èi èísla
reálná (<i>float/double</i>). V&nbsp;programovacím jazyku Lua, pøesnìji øeèeno
v&nbsp;jeho doposud pou¾ívaných verzích, se toti¾ pøedpokládá, ¾e numerické
hodnoty jsou typu <i>double</i>, co¾ je z&nbsp;hlediska vysokoúrovòového
skriptovacího jazyka pochopitelné (omezí se tím pomìrnì velký poèet bìhových
chyb typu pøeteèení apod.).</p>

<p>Na druhou stranu ov¹em naprostá vìt¹ina v&nbsp;souèasnosti pou¾ívaných
mikroprocesorových architektur je postavena na bázi celoèíselné
aritmeticko-logické jednotky (ALU), která je sice (vìt¹inou!) doplnìna
matematickým koprocesorem, ov¹em pro nìkteré operace, typicky pro implementace
programových smyèek atd., je výhodnìj¹í vyu¾ívat celoèíselnou ALU a takté¾
celoèíselné pracovní registry. Detekce tìch promìnných, v&nbsp;nich¾ se pracuje
jen s&nbsp;celými èísly, je tedy pro LuaJIT dùle¾itá, pøedev¹ím na architektuøe
ARM se soft-float. <i>LuaJIT</i> ov¹em musí poèítat s&nbsp;tím, ¾e mù¾e dojít
k&nbsp;pøeteèení, kterému se musí zabránit a tedy ti¹e a zejména bez ovlivnìní
bìhu aplikace pøejít z&nbsp;celoèíselného typu <i>int</i> na <i>double</i>.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. x86 (32 bit)</h2>

<p>Na 32bitové platformì x86 se vyu¾ívají jak celoèíselné registry
<strong>EAX</strong>, <strong>EBX</strong>, <strong>ECX</strong>,
<strong>EDX</strong>, <strong>ESI</strong>, <strong>EDI</strong> a èásteènì i
<strong>EBP</strong>, tak i registry pøidané v&nbsp;rámci roz¹iøující
instrukèní sady <i>SSE</i>. Nová sada registrù je pojmenovaná
<strong>XMM0</strong> a¾ <strong>XMM7</strong>. V¹echny nové registry mají
¹íøku 128 bitù, tj.&nbsp;jsou dvakrát ¹ir¹í, ne¾ registry pou¾ívané
v&nbsp;<i>MMX</i> i <i>3DNow!</i> a ètyøikrát ¹ir¹í, ne¾ bì¾né pracovní
registry na platformì <i>x86</i> (bavíme se nyní o 32bitovém re¾imu). Do
ka¾dého registru je mo¾né ulo¾it ètveøici reálných numerických hodnot
reprezentovaných v&nbsp;systému plovoucí øádové teèky podle normy <i>IEEE 754
(single)</i>, pøièem¾ tato norma je dodr¾ována pøesnìji, ne¾ v&nbsp;pøípadì
<i>3DNow!</i> (rùzné zaokrouhlovací re¾imy èi práce s&nbsp;denormalizovanými
èísly sice mohou vypadat tro¹ku jako èerná magie, ov¹em napøíklad
v&nbsp;knihovnách pro numerické výpoèty, které musí v¾dy za specifikovaných
okolností dát stejný výsledek, se jedná o velmi dùle¾itou vlastnost).
K&nbsp;osmi novým registrùm <strong>XMM*</strong> byl je¹tì pøidán jeden
32bitový registr nazvaný <strong>MXCSR</strong>, jen¾ byl urèený pro nastavení
(øízení) re¾imù výpoètu.</p>

<p>Ve skuteènosti je v¹ak vìt¹ina instrukcí <i>SSE</i> pro jazyk Lua
nepou¾itelná :-), proto¾e tyto instrukce pracují pouze s&nbsp;numerickými
hodnotami typu <i>single</i>. Podpora pro hodnoty typu <i>double</i> se
objevuje a¾ v&nbsp;roz¹iøující instrukèní sadì <i>SSE2</i>. V&nbsp;rámci
<i>SSE2</i> toti¾ byly zavedeny dvouprvkové vektory obsahující hodnoty
reprezentované ve formátu plovoucí øádové èárky, ov¹em tentokrát se jedná o
èísla ulo¾ená v&nbsp;64 bitech (2&times;64=128) odpovídající dvojité pøesnosti
(<i>double</i>) z&nbsp;normy <i>IEEE 754</i>. LuaJIT <i>SSE2</i> doká¾e velmi
efektivnì vyu¾ít, co¾ ostatnì uvidíme i na zpùsobu pøekladu demonstraèního
pøíkladu. V¹echny nové operace implementované v&nbsp;<i>SSE2</i> jsou vypsány
v&nbsp;následující tabulce. Ve tøetím sloupci je naznaèeno, jaké vektory jsou
danou operací zpracovávány, pøièem¾ první èíslo znamená poèet prvkù vektoru, za
ním¾ následuje bitová ¹íøka jednotlivých prvkù:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Operace/funkce</th><th>Struktura vektoru</th><th>Datový typ</th><th>Saturace?</th><th>Poznámka</th></tr>
<tr><td> 1</td><td>addpd  </td><td>souèet            </td><td>2&times;64bit</td><td>double  </td><td>&times;</td><td>&nbsp;</td></tr>
<tr><td> 2</td><td>addsd  </td><td>souèet            </td><td>1&times;64bit</td><td>double  </td><td>&times;</td><td>operace provedena jen s&nbsp;pravým prvkem vektorù</td></tr>
<tr><td> 3</td><td>subpd  </td><td>rozdíl            </td><td>2&times;64bit</td><td>double  </td><td>&times;</td><td>&nbsp;</td></tr>
<tr><td> 4</td><td>subsd  </td><td>rozdíl            </td><td>1&times;64bit</td><td>double  </td><td>&times;</td><td>operace provedena jen s&nbsp;pravým prvkem vektorù</td></tr>
<tr><td> 5</td><td>mulpd  </td><td>souèin            </td><td>2&times;64bit</td><td>double  </td><td>&times;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>mulsd  </td><td>souèin            </td><td>1&times;64bit</td><td>double  </td><td>&times;</td><td>operace provedena jen s&nbsp;pravým prvkem vektorù</td></tr>
<tr><td> 7</td><td>divpd  </td><td>podíl             </td><td>2&times;64bit</td><td>double  </td><td>&times;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>divsd  </td><td>podíl             </td><td>1&times;64bit</td><td>double  </td><td>&times;</td><td>operace provedena jen s&nbsp;pravým prvkem vektorù</td></tr>
<tr><td> 9</td><td>paddb  </td><td>souèet            </td><td>16&times;8bit</td><td>integer </td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>10</td><td>paddw  </td><td>souèet            </td><td>8&times;16bit</td><td>integer </td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>11</td><td>paddd  </td><td>souèet            </td><td>4&times;32bit</td><td>integer </td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>12</td><td>paddq  </td><td>souèet            </td><td>2&times;64bit</td><td>integer </td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>13</td><td>paddsb </td><td>souèet            </td><td>16&times;8bit</td><td>integer </td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>14</td><td>paddsw </td><td>souèet            </td><td>8&times;16bit</td><td>integer </td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>paddusb</td><td>souèet            </td><td>16&times;8bit</td><td>unsigned</td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>paddusw</td><td>souèet            </td><td>8&times;16bit</td><td>unsigned</td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>17</td><td>psubb  </td><td>rozdíl            </td><td>16&times;8bit</td><td>integer </td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>18</td><td>psubw  </td><td>rozdíl            </td><td>8&times;16bit</td><td>integer </td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>19</td><td>psubd  </td><td>rozdíl            </td><td>4&times;32bit</td><td>integer </td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>20</td><td>psubq  </td><td>rozdíl            </td><td>2&times;64bit</td><td>integer </td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>21</td><td>psubsb </td><td>rozdíl            </td><td>16&times;8bit</td><td>integer </td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>psubsw </td><td>rozdíl            </td><td>8&times;16bit</td><td>integer </td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>23</td><td>psubusb</td><td>rozdíl            </td><td>16&times;8bit</td><td>unsigned</td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>24</td><td>psubusw</td><td>rozdíl            </td><td>8&times;16bit</td><td>unsigned</td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>25</td><td>maxpd  </td><td>maximum           </td><td>2&times;64bit</td><td>double  </td><td>&times;</td><td>&nbsp;</td></tr>
<tr><td>26</td><td>maxsd  </td><td>maximum           </td><td>2&times;64bit</td><td>double  </td><td>&times;</td><td>operace provedena jen s&nbsp;pravým prvkem vektorù</td></tr>
<tr><td>27</td><td>minpd  </td><td>minimum           </td><td>2&times;64bit</td><td>double  </td><td>&times;</td><td>&nbsp;</td></tr>
<tr><td>28</td><td>minsd  </td><td>minimum           </td><td>2&times;64bit</td><td>double  </td><td>&times;</td><td>operace provedena jen s&nbsp;pravým prvkem vektorù</td></tr>
<tr><td>29</td><td>pmaddwd</td><td>souèin/add        </td><td>8&times;16bit</td><td>integer </td><td>&times;</td><td>&nbsp;</td></tr>
<tr><td>30</td><td>pmulhw </td><td>souèin            </td><td>8&times;16bit</td><td>integer </td><td>&times;</td><td>vrací vektor horních 16 bitù výsledkù</td></tr>
<tr><td>31</td><td>pmullw </td><td>souèin            </td><td>8&times;16bit</td><td>integer </td><td>&times;</td><td>vrací vektor dolních 16 bitù výsledkù</td></tr>
<tr><td>32</td><td>pmuludq</td><td>souèin            </td><td>4&times;32bit</td><td>integer </td><td>&times;</td><td>64 bitový výsledek pro ka¾dý souèin  </td></tr>
<tr><td>33</td><td>rcpps  </td><td>pøevrácená hodnota</td><td>4&times;32bit</td><td>single  </td><td>&times;</td><td>aproximace</td></tr>
<tr><td>34</td><td>rcpss  </td><td>pøevrácená hodnota</td><td>4&times;32bit</td><td>single  </td><td>&times;</td><td>operace provedena jen s&nbsp;pravým prvkem vektorù</td></tr>
<tr><td>35</td><td>sqrtpd </td><td>druhá odmocnina   </td><td>2&times;64bit</td><td>double  </td><td>&times;</td><td>&nbsp;</td></tr>
<tr><td>36</td><td>sqrtsd </td><td>druhá odmocnina   </td><td>2&times;64bit</td><td>double  </td><td>&times;</td><td>&nbsp; operace provedena jen s&nbsp;pravým prvkem vektorù</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. x86_64 (64 bit)</h2>

<p>Pokud <i>LuaJIT</i> zjistí, ¾e je provozován na mikroprocesoru, který
podporuje 64bitovou instrukèní sadu x86_64 (x64) a souèasnì bì¾ícího
v&nbsp;64bitovém re¾imu, doká¾e pøi just-in-time pøekladu vyu¾ít v¹ech ¹estnáct
univerzálních pracovních registrù (namísto pùvodních osmi registrù),
v&nbsp;nich¾ lze navíc pracovat s&nbsp;64bitovými hodnotami a nejenom
s&nbsp;hodnotami 32bitovými. Mo¾ná dùle¾itìj¹í je v¹ak fakt, ¾e i poèet
<strong>XMM*</strong> registrù pou¾ívaných v&nbsp;<i>SSE/SSE2</i> se
zdvojnásobil z&nbsp;osmi (<strong>XMM0</strong>-<strong>XMM7</strong>) na
¹estnáct, tak¾e lineární alokátor registrù zde má ponìkud snaz¹í práci.
V&nbsp;mnoha dal¹ích ohledech se v¹ak nativní kód urèený pro 32bitový re¾im a
64bitový re¾im li¹it nebude, alespoò u tìch demonstraèních pøíkladù, které si
budeme ukazovat v&nbsp;navazujících kapitolách popø.&nbsp;i v&nbsp;následujícím
pokraèování tohoto seriálu.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. ARM (32 bit)</h2>

<p>V&nbsp;pøípadì procesorù z&nbsp;rodiny <i>ARM</i> mù¾e LuaJIT, na základì
konkrétní konfigurace a mo¾ností daného procesoru, vyu¾ívat soft-float ABI a
soft-float operace s&nbsp;numerickými hodnotami typu <i>double</i> (co¾ je
nejpomalej¹í varianta), dále pak soft-float ABI a operace VFPv2
popø.&nbsp;hard-float ABI a takté¾ operace VFPv2. Kdykoli je to mo¾né &ndash;
napøíklad u mnoha typù programových smyèek &ndash; provádí se operace
s&nbsp;celoèíselnými registry a tím pádem se tyto výpoèty odehrávají v&nbsp;ALU
procesorù ARM. Význam nìkterých &bdquo;celoèíselných&ldquo; instrukcí pou¾itých
v&nbsp;nativním kódu <a href="#k06">dále popsaného demonstraèního pøíkladu</a>
je uveden v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>adds</td><td>r0:=r1+r2 a nastav pøíznaky N, V, Z, C</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>2</td><td>cmp </td><td>operand1-operand2 (compare a nastav pøíznaky N, V, Z, C)</td></tr>
<tr><td>3</td><td>cmn </td><td>operand1+operand2 (compare negative a nastav pøíznaky N, V, Z, C)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td>blne</td><td>podmínìný skok provedený pøi nerovnosti (Z=0)</td></tr>
<tr><td>5</td><td>blvs</td><td>podmínìný skok provedený pøi pøeteèení (V=1)</td></tr>
<tr><td>6</td><td>blge</td><td>podmínìný skok provedený pøi N=V</td></tr>
<tr><td>7</td><td>blt </td><td>podmínìný skok provedený pøi N!=V</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>8</td><td>bl  </td><td>skok do subrutiny</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>9</td><td>ldrd</td><td>naètení hodnoty do registru</td></tr>
</table>

<p>Vra»me se nyní na chvíli k&nbsp;numerickým hodnotám s&nbsp;plovoucí øádovou
èárkou. Technologie <i>VFP</i> byla navr¾ena takovým zpùsobem, aby ji bylo
mo¾né pou¾ít v&nbsp;mnoha aplikaèních oblastech, napøíklad v&nbsp;øídicích
jednotkách automobilù, pro zpracování obrazu (konvoluèní filtry, rychlá
Fourierova transformace, rasterizace a dal¹í operace provádìné v&nbsp;tiskových
procesorech), pøi zpracování øeèi (kodeky) a takté¾ pro provádìní rùzných 3D
operací (transformace) &ndash; právì v&nbsp;tìchto oblastech lze toti¾ vyu¾ít
práci nikoli pouze se skalárními hodnotami, ale takté¾ s&nbsp;vektory o dvou a¾
osmi prvcích. Zajímavé je, ¾e pozdìji do¹lo ke slouèení <i>VFP</i>
s&nbsp;architekturou <i>NEON</i>.</p>

<p>Pùvodní architektura <i>VFPv1</i> je ji¾ dnes pova¾ována za pøekonanou a
v&nbsp;¾ádných souèasných èipech se s&nbsp;ní¾ ji¾ nesetkáme. Druhá verze této
architektury <i>VFPv2</i> zaèala být pou¾ívána na nìkterých èipech ARMv5E,
ARMv5TEJ a takté¾ na ARMv6 &ndash; instrukce <i>VFP</i> v&nbsp;tomto pøípadì
roz¹iøovaly pùvodní instrukèní sady <i>ARM</i>. Zajímavìj¹í je dnes tøetí verze
architektury <i>VFP</i> znaèená <i>VFPv3</i> pou¾ívaná od <i>ARMv7</i>
(samozøejmì jen u vybraných èipù &ndash; zdaleka ne v¹echny aplikaèní oblasti
toti¾ nutnì vy¾adují matematický koprocesor). V&nbsp;tomto pøípadì lze nové
&bdquo;vektorové&ldquo; instrukce pou¾ívat v&nbsp;instrukèní sadì ARM, Thumb i
ThumbEE.</p>

<p>Z&nbsp;hlediska programovacího jazyka Lua je dùle¾ité, ¾e se u technologie
<i>VFP</i> pou¾ívají pøedev¹ím formáty <i>single/float</i> a <i>double</i>,
pøièem¾ existují roz¹íøení i pro formáty s&nbsp;polovièní pøesností
(<i>half-float</i>), které lze v&nbsp;nìkterých oblastech s&nbsp;výhodou
pou¾ívat, napøíklad pro ukládání barvových slo¾ek pixelù (zvý¹í se tím
mj.&nbsp;i dynamický rozsah pøi filtraci obrazu). Vzhledem k&nbsp;tomu, ¾e
technologie <i>VFP</i> je urèena i pro aplikaci v&nbsp;systémech, v&nbsp;nich¾
je mnohdy dùle¾ité dosáhnout co nejvìt¹ího výpoèetního výkonu popø.&nbsp;co
nejkrat¹í doby odezvy (RT aplikace), mù¾e matematický koprocesor <i>VFP</i>
pracovat buï v&nbsp;re¾imu <i>full compliance</i>, který je pøímo kompatibilní
s&nbsp;normou <i>IEEE 754</i>, popø.&nbsp;je mo¾né provést pøepnutí do re¾imu
<i>RunFast</i>, v&nbsp;nìm¾ se negenerují nìkteré výjimky a takté¾ mù¾e dojít
ke ztrátì pøesnosti v&nbsp;nejni¾¹ích bitech mantisy (vìt¹inou pouze
v&nbsp;bitu nejni¾¹ím). Vlastnosti obou re¾imù jsou samozøejmì velmi pøesnì
popsány, tak¾e zále¾í jen na vývojáøi, který re¾im v&nbsp;daný okam¾ik pou¾ije
&ndash; v&nbsp;pøípadì jazyka Lua to bude typ <i>double</i> a pravdìpodobnì i
re¾im <i>full compliance</i>.</p>

<p>Matematické koprocesory <i>VFP</i> obecnì obsahují ¹estnáct pracovních
registrù, ka¾dý o ¹íøce 64 bitù. Tyto registry lze pou¾ít buï pro práci
s&nbsp;hodnotami s&nbsp;dvojitou pøesností (<i>double</i>) &ndash; potom se
tyto registry v&nbsp;assembleru oznaèují jmény <strong>d0</strong> a¾
<strong>d15</strong> (podobnì jsou oznaèeny ve zdrojových kódech <i>LuaJITu</i>,
akorát s&nbsp;velkými písmeny). Ov¹em takté¾ je mo¾né libovolný registr
rozdìlit na dva registry o ¹íøce 32 bitù, z&nbsp;nich¾ ka¾dý doká¾e pojmout
èíselnou hodnotu s&nbsp;jednoduchou pøesností (<i>single/float</i>). Díky
tomuto rozdìlení se poèet registrù pro formát <i>single</i> zvìt¹il na
dvojnásobek &ndash; tyto registry jsou v&nbsp;assembleru pojmenovány
<strong>s0</strong> a¾ <strong>s31</strong>. Podle konvence dodr¾ované jak
pøekladaèi, tak i v&nbsp;programových knihovnách se pøi volání subrutin
pou¾ívají registry <strong>d0</strong> a¾ <strong>d7</strong> pro pøedávání
parametrù subrutinì, popø.&nbsp;pro získání návratových hodnot ze subrutiny.
Samozøejmì se tyto registry takté¾ pou¾ívají pøi výpoètech v&nbsp;subrutinì.
Ostatní registry lze takté¾ pou¾ít, ov¹em jejich hodnota by mìla být pøi
návratu ze subrutiny obnovena.</p>

<p>Pøi vzniku technologie <i>VFP</i> se její tvùrci zamìøili na to, aby
instrukèní sada <i>VFP</i> umo¾òovala jak práci se skalárními hodnotami, tak i
práci s&nbsp;vektory. Na první pohled by se tedy mohlo zdát, ¾e se jedná o
jednu z&nbsp;mnoha aplikací architektury <i>SIMD</i>, ve skuteènosti se ov¹em
v&nbsp;pøípadì <i>VFP</i> vektory zpracovávají sekvenènì. To napøíklad znamená,
¾e souèet dvou osmiprvkových vektorù realizovaný instrukcí
<strong>VADD</strong> pou¾ívá tu samou FP-sèítaèku a prvky vektorù jsou tedy
seèítány postupnì. Stále se jedná o rychlej¹í operaci, ne¾ osm krát opakovaná
instrukce <strong>ADF</strong> (mimo jiné se u¹etøí cykly strávené pøi naèítání
a dekódování instrukce &ndash; <i>instruction fetch</i> a <i>instruction
decode</i>) &ndash; ov¹em reálný <i>SIMD</i> systém to není, na rozdíl od na
první pohled obdobných technologií: <i>3DNow!</i>, <i>SSE</i> atd. Zmìna pøi¹la
a¾ pøi slouèení <i>VFP</i> s&nbsp;technologií <i>NEON</i>, která na procesory
<i>ARM</i> pøinesla skuteèné operace <i>SIMD</i>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Demonstraèní pøíklad: jednoduchá programová smyèka typu <strong>while</strong></h2>

<p>Pro ukázku pøekladu z&nbsp;mezikódu do nativního kódu bude pou¾it
demonstraèní pøíklad, s&nbsp;ním¾ jsme se ji¾ ve struènosti seznámili minule.
V&nbsp;tomto pøíkladu je implementována programová smyèka typu
<strong>while</strong>, v&nbsp;ní¾ se pracuje s&nbsp;dvojicí promìnných &ndash;
poèitadla <strong>i</strong> a takté¾ promìnné <strong>sum</strong>. Po
provedení 100 iterací je vypsána aktuální hodnota promìnné
<strong>sum</strong>:</p>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 43.</i>
<i>--</i>
<i>-- Test JITu.</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<strong>local</strong> i = 0
<strong>local</strong> sum = 0
&nbsp;
<strong>while</strong> i &lt; 100 <strong>do</strong>
    sum = sum + 1
    i = i + 1
<strong>end</strong>
&nbsp;
print(sum)
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Finito.</i>
<i>--</i>
</pre>

<p>Tento typ programové smyèky je díky provedení 100 iterací detekován jako
stopa vhodná pro JITování (<i>hot loop</i>). Struktura bajtkódu detekované
stopy pou¾ívá instrukci <strong>LOOP</strong>, která je doplnìna o
<strong>ISGE</strong>:</p>

<pre>
---- TRACE 1 start test43.lua:12
0007  ADDVN    1   1   0  ; 1
0008  ADDVN    0   0   0  ; 1
0009  JMP      2 =&gt; 0003
0003  KSHORT   2 100
0004  ISGE     0   2
0005  JMP      2 =&gt; 0010
0006  LOOP     2 =&gt; 0010
</pre>

<p>Transformace bajtkódu do sekvence pseudoinstrukcí:</p>

<pre>
---- TRACE 1 IR
0001 &gt;  int SLOAD  #2    T
0002 &gt;+ int ADDOV  0001  +1  
0003 &gt;  int SLOAD  #1    T
0004 &gt;+ int ADDOV  0003  +1  
0005 &gt;  int LT     0004  +100
0006 ------ LOOP ------------
0007 &gt;+ int ADDOV  0002  +1  
0008 &gt;+ int ADDOV  0004  +1  
0009 &gt;  int LT     0008  +100
0010    int PHI    0002  0007
0011    int PHI    0004  0008
---- TRACE 1 stop -&gt; loop
</pre>

<p>Pov¹imnìte si pøedev¹ím pou¾ití datového typu <i>int</i> a takté¾ vyu¾ití
pseudoinstrukcí <strong>ADDOV</strong>. <i>LuaJIT</i> pøedpokládá, ¾e jak
promìnná <strong>i</strong>, tak i promìnná <strong>sum</strong> bude obsahovat
celá èísla typu <i>int</i>, co¾ je sice pravda, ov¹em pøi zvy¹ování hodnoty
tìchto promìnných mù¾e dojít k&nbsp;pøeteèení, kterému je zapotøebí zamezit.
V&nbsp;následujících podkapitolách uvidíme, ¾e se tyto pseudoinstrukce
v&nbsp;nìkterých pøípadech pøekládají pomìrnì slo¾itým zpùsobem, a to kvùli
tomu, aby se detekovalo ji¾ zmínìné pøeteèení výsledku a pøechod na pou¾ití
jiného datového typu.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Pøeklad demonstraèního pøíkladu do nativního kódu</h2>

<p>Pojïme se nyní podívat na pøeklad demonstraèního pøíkladu just-in-time
pøekladaèem do nativního kódu procesorù s&nbsp;architekturou x86 (32bit),
x86_64 (64bit) a ARM (32bit).</p>



<p><a name="k071"></a></p>
<h3 id="k071">7.1 Pøeklad pro architekturu x86 (32 bit)</h3>

<p>Pro 32bitovou platformu x86 se detekovaný <i>hot loop</i> pøelo¾í
následujícím zpùsobem:</p>

<pre>
---- TRACE 1 mcode 95
0xb7f68f97  mov      dword [0xb7d9f2bc], 0x1
0xb7f68fa1  movsd    xmm1, [0xb7db1bb0]
0xb7f68fa9  movsd    xmm0, [0xb7db1bb8]
0xb7f68fb1  cmp      dword [edx+0xc], -0x0f
0xb7f68fb5  jnb      0xb7f61008    -&gt;0
0xb7f68fbb  movsd    xmm6, [edx+0x8]
0xb7f68fc0  addsd    xmm6, xmm1
0xb7f68fc4  cmp      dword [edx+0x4], -0x0f
0xb7f68fc8  jnb      0xb7f61008    -&gt;0
0xb7f68fce  movsd    xmm7, [edx]
0xb7f68fd2  addsd    xmm7, xmm1
0xb7f68fd6  ucomisd  xmm0, xmm7
0xb7f68fda  jbe      0xb7f6100c    -&gt;1
-&gt;LOOP:
0xb7f68fe0  addsd   xmm6, xmm1          <i>; registr xmm1 obsahuje jednièku, která se pøiète k obsahu xmm6</i>
0xb7f68fe4  movaps  xmm5, xmm7
0xb7f68fe7  addsd   xmm7, xmm1          <i>; dal¹í pøiètení jednièky</i>
0xb7f68feb  ucomisd xmm0, xmm7          <i>; test, zda nemá dojít k ukonèení smyèky</i>
0xb7f68fef  ja      0xb7f68fe0 -&gt;LOOP   <i>; opakování smyèky</i>
0xb7f68ff1  jmp     0xb7f61014    -&gt;3
---- TRACE 1 stop -&gt; loop
</pre>

<p>Mù¾eme zde vidìt nìkolik podmínìných skokù (<strong>jnb</strong> &ndash;
<i>jump if not below</i>, <strong>jbe</strong> &ndash; <i>jump if below or
equal</i>) a <strong>ja</strong> &ndash; <i>jump if above</i> s&nbsp;podobným
významem jako v&nbsp;pøedchozím nativním kódu.</p>

<p>Z&nbsp;instrukcí, které nebyly vypsány <a href="#k03">ve tøetí kapitole</a>
stojí za zmínku <strong>movaps</strong> (pøenos celého 128bitového slova mezi
dvìma XMM registry) a <strong>ucomisd</strong> (porovnání obsahu spodní
poloviny dvou registrù a nastavení pøíznakù v&nbsp;EFLAGS podobným zpùsobem,
jako u instrukce <strong>cmp</strong> &ndash; zde se v¹ak porovnávají dvì
hodnoty typu <i>double</i>). Vidíme, ¾e v¹echny výpoèty probíhají
v&nbsp;registrech XMM a vyu¾ívá se zde instrukèní sada <i>SSE2</i>, co¾ se
pozná podle toho, ¾e instrukce konèí na písmeno <strong>d</strong> &ndash;
<i>double</i>.</p>



<p><a name="k072"></a></p>
<h3 id="k072">7.2 Pøeklad pro architekturu x86_64 (64 bit)</h3>

<p>Pro platformu x86_64 dostaneme v&nbsp;detailech nepatrnì odli¹ný
&bdquo;stroják&ldquo;:</p>

<pre>
---- TRACE 1 mcode 104
0x0bceff8e  mov     dword [0x409604a0], 0x1
0x0bceff99  movsd   xmm1, [0x404b0d38]
0x0bceffa2  movsd   xmm0, [0x404b0d40]
0x0bceffab  cmp     dword [rdx+0xc], 0xfffeffff
0x0bceffb2  jnb     0x0bce0010        -&gt;0
0x0bceffb8  movsd   xmm6, [rdx+0x8]
0x0bceffbd  addsd   xmm6, xmm1
0x0bceffc1  cmp     dword [rdx+0x4], 0xfffeffff
0x0bceffc8  jnb     0x0bce0010        -&gt;0
0x0bceffce  movsd   xmm7, [rdx]
0x0bceffd2  addsd   xmm7, xmm1
0x0bceffd6  ucomisd xmm0, xmm7
0x0bceffda  jbe     0x0bce0014        -&gt;1
-&gt;LOOP:
0x0bceffe0  addsd   xmm6, xmm1          <i>; registr xmm1 obsahuje jednièku, která se pøiète k obsahu xmm6</i>
0x0bceffe4  movaps  xmm5, xmm7
0x0bceffe7  addsd   xmm7, xmm1          <i>; dal¹í pøiètení jednièky</i>
0x0bceffeb  ucomisd xmm0, xmm7          <i>; test, zda nemá dojít k ukonèení smyèky</i>
0x0bceffef  ja      0x0bceffe0 -&gt;LOOP   <i>; opakování smyèky</i>
0x0bcefff1  jmp     0x0bce001c        -&gt;3
---- TRACE 1 stop -&gt; loop
</pre>

<p>V&nbsp;tomto jednoduchém demonstraèním pøíkladu se od sebe oba vygenerované
kódy na úrovni zdrojových kódù prakticky neli¹í, a¾ na pou¾ití odli¹ných
registrù: <strong>EDX</strong> vs. <strong>RDX</strong>. Programová smyèka typu
<i>while</i> dokonce byla pøelo¾ena toto¾ným zpùsobem:</p>

<pre>
x86 (32bit)                    x86_64 (64bit)
-----------------------------------------------------------
addsd   xmm6, xmm1             addsd   xmm6, xmm1
movaps  xmm5, xmm7             movaps  xmm5, xmm7
addsd   xmm7, xmm1             addsd   xmm7, xmm1
ucomisd xmm0, xmm7             ucomisd xmm0, xmm7
ja      0xb7f68fe0 -&gt;LOOP      ja      0x0bceffe0 -&gt;LOOP
</pre>

<p>Ve skuteènosti se dá toto chování oèekávat, proto¾e èást <i>LuaJITu</i>,
která se stará o pøeklad na 32bitovou a 64bitovou architekturu, je prakticky
shodná.</p>



<p><a name="k073"></a></p>
<h3 id="k073">7.3 Pøeklad pro architekturu ARM (32 bit)</h3>

<p>Pøeklad do nativního strojového kódu pro 32bitové mikroprocesory ARM vypadá
ji¾ na první pohled velmi èitelnì (co¾ jen ukazuje, jak mù¾e být RISCová
instrukèní sada elegantní):</p>

<pre>
---- TRACE 1 start test43.lua:12
---- TRACE 1 mcode 84
0x00397fac  ldrd  r4, [r9, #8]
0x00397fb0  cmn   r5, #14
0x00397fb4  blne  0x00390018      -&gt;0
0x00397fb8  adds  r4, r4, #1
0x00397fbc  blvs  0x00390018      -&gt;0
0x00397fc0  ldrd  r6, [r9]
0x00397fc4  cmn   r7, #14
0x00397fc8  blne  0x00390018      -&gt;0
0x00397fcc  adds  r6, r6, #1
0x00397fd0  blvs  0x00390018      -&gt;0
0x00397fd4  cmp   r6, #100
0x00397fd8  blge  0x0039001c      -&gt;1
-&gt;LOOP:
0x00397fdc  mov   r11, r6                <i>; pøenos hodnot promìnných do pracovních registrù</i>
0x00397fe0  mov   r10, r4
0x00397fe4  adds  r4, r10, #1            <i>; pøiètení jednièky s ulo¾ením výsledku do nového registru a nastavením pøíznakù</i>
0x00397fe8  blvs  0x00390020      -&gt;2    <i>; test na pøeteèení</i>
0x00397fec  adds  r6, r11, #1            <i>; pøiètení jednièky s ulo¾ením výsledku do nového registru a nastavením pøíznakù</i>
0x00397ff0  blvs  0x00390020      -&gt;2    <i>; test na pøeteèení</i>
0x00397ff4  cmp   r6, #100               <i>; test na ukonèení smyèky</i>
0x00397ff8  blt   0x00397fdc      -&gt;LOOP <i>; skok na zaèátek smyèky - dal¹í iterace</i>
0x00397ffc  bl    0x00390024      -&gt;3
---- TRACE 1 stop -&gt; loop
</pre>

<p>Pov¹imnìte si pøedev¹ím mno¾ství podmínìných skokù (<strong>blne</strong>,
<strong>blvs</strong>), kterými jsou realizovány asserce zmínìné
v&nbsp;pøedchozím textu. Dále stojí za zmínku pou¾ití instrukcí pracujících
pouze s&nbsp;celoèíselnými registry &ndash; v&nbsp;tomto pøípadì <i>LuaJIT</i>
zvolil pou¾ití operací s&nbsp;celými èísly typu <i>integer</i> o ¹íøce 32 bitù.
To si vy¾ádalo úpravu programové smyèky takovým zpùsobem, aby se kontrolovalo
pøeteèení (instrukce <strong>adds</strong> nastaví v¹echny potøebné pøíznaky
testované ihned poté podmínìným skokem <strong>blvs</strong>). Pokud by mìl
<i>LuaJIT</i> jistotu, ¾e k&nbsp;pøeteèení nedojde, mohly by se instrukce
<strong>adds</strong> nahradit za <strong>add</strong> a skoky
<strong>blvs</strong> zcela odstranit (snad se doèkáme v&nbsp;dal¹í verzi).</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Literatura</h2>

<ol>

<li>Bolz, Cuni, Fijalkowski, Rigo:<br />
&bdquo;Tracing the Meta-Level: PyPy's Tracing JIT Compiler&ldquo;
</li>

<li>Vasanth Bala, Evelyn Duesterwald, Sanjeev Banerjia:<br />
&bdquo;Dynamo: A Transparent Dynamic Optimization System&ldquo;
</li>

<li>Bolz, Cuni, Fijalkowski, Leuschel, Pedroni, Rigo:
&bdquo;Allocation removal by partial evaluation in a tracing JIT&ldquo;
</li>

<li>Bolz:<br />
&bdquo;Automatic JIT Compiler Generation with Runtime Partial Evaluation&ldquo;
</li>

<li>Bolz, Kuhn, Lienhard, Matsakis, Nierstrasz, Renggli, Rigo and T. Verwaest:<br />
&bdquo;Back to the Future in One Week - Implementing a Smalltalk VM in PyPy&ldquo;<br />
pages 123-139. 2008.
</li>

<li>Bolz  and Rigo:<br />
&bdquo;How to not write a virtual machine&ldquo;<br />
In Proceedings of the 3rd Workshop on Dynamic Languages and Applications (DYLA), 2007
</li>

<li>Bruni, Verwaest:<br />
&bdquo;PyGirl: generating Whole-System VMs from High-Level prototypes using PyPy&ldquo;<br />
In Tools, accepted for publication, 2009.
</li>

<li>Sullivan, Bruening, Baron, Garnett and Amarasinghe:<br />
&bdquo;Dynamic native optimization of interpreters&ldquo;<br />
In Proceedings of the 2003 Workshop on Interpreters,<br />
Virtual Machines and Emulators pages 50-57, San Diego, California, 2003. ACM.
</li>

</ol>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Static single assignment form (SSA)<br />
<a href="http://en.wikipedia.org/wiki/Static_single_assignment_form">http://en.wikipedia.org/wiki/Static_single_assignment_form</a>
</li>

<li>LuaJIT 2.0 SSA IR</li>
<a href="http://wiki.luajit.org/SSA-IR-2.0">http://wiki.luajit.org/SSA-IR-2.0</a>
</li>

<li>Dynamic Assembler<br />
<a href="http://luajit.org/dynasm.html">http://luajit.org/dynasm.html</a>
</li>

<li>The Unofficial DynASM Documentation: Introduction<br />
<a href="http://corsix.github.io/dynasm-doc/index.html">http://corsix.github.io/dynasm-doc/index.html</a>
</li>

<li>Have tracing JIT compilers won?<br />
<a href="http://lambda-the-ultimate.org/node/3851">http://lambda-the-ultimate.org/node/3851</a>
</li>

<li>Tracing just-in-time compilation<br />
<a href="http://en.wikipedia.org/wiki/Tracing_just-in-time_compilation">http://en.wikipedia.org/wiki/Tracing_just-in-time_compilation</a>
</li>

<li>How does LuaJIT's trace compiler work?<br />
<a href="http://www.freelists.org/post/luajit/How-does-LuaJITs-trace-compiler-work,1">http://www.freelists.org/post/luajit/How-does-LuaJITs-trace-compiler-work,1</a>
</li>

<li>How does LuaJIT's trace compiler work?<br />
<a href="http://stackoverflow.com/questions/20266523/how-does-luajits-trace-compiler-work">http://stackoverflow.com/questions/20266523/how-does-luajits-trace-compiler-work</a>
</li>

<li>TraceMonkey<br />
<a href="https://wiki.mozilla.org/JavaScript:TraceMonkey">https://wiki.mozilla.org/JavaScript:TraceMonkey</a>
</li>

<li>TraceMonkey<br />
<a href="http://brendaneich.com/2008/08/tracemonkey-javascript-lightspeed/">http://brendaneich.com/2008/08/tracemonkey-javascript-lightspeed/</a>
</li>

<li>Improving JavaScript performance with JägerMonkey<br />
<a href="http://hacks.mozilla.org/2010/03/improving-javascript-performance-with-jagermonkey/">http://hacks.mozilla.org/2010/03/improving-javascript-performance-with-jagermonkey/</a>
</li>

<li>Wikipedia: Mezijazyk<br />
<a href="http://cs.wikipedia.org/wiki/Mezijazyk">http://cs.wikipedia.org/wiki/Mezijazyk</a>
</li>

<li>The LuaJIT Project<br />
<a href="http://luajit.org/index.html">http://luajit.org/index.html</a>
</li>

<li>LuaJIT FAQ<br />
<a href="http://luajit.org/faq.html">http://luajit.org/faq.html</a>
</li>

<li>LuaJIT Performance Comparison<br />
<a href="http://luajit.org/performance.html">http://luajit.org/performance.html</a>
</li>

<li>LuaJIT 2.0 intellectual property disclosure and research opportunities<br />
<a href="http://article.gmane.org/gmane.comp.lang.lua.general/58908">http://article.gmane.org/gmane.comp.lang.lua.general/58908</a>
</li>

<li>LuaJIT Wiki<br />
<a href="http://wiki.luajit.org/Home">http://wiki.luajit.org/Home</a>
</li>

<li>LuaJIT 2.0 Bytecode Instructions<br />
<a href="http://wiki.luajit.org/Bytecode-2.0">http://wiki.luajit.org/Bytecode-2.0</a>
</li>

<li>Programming in Lua 9.1 &ndash; Coroutine Basics,<br />
<a href="http://www.lua.org/pil/9.1.html">http://www.lua.org/pil/9.1.html</a>
</li>

<li>Programming in Lua (first edition)<br />
<a href="http://www.lua.org/pil/contents.html">http://www.lua.org/pil/contents.html</a>
</li>

<li>Programming in Lua: 6 - More about Functions<br />
<a href="http://www.lua.org/pil/6.html">http://www.lua.org/pil/6.html</a>
</li>

<li>Lua Lanes<br />
<a href="http://kotisivu.dnainternet.net/askok/bin/lanes/">http://kotisivu.dnainternet.net/askok/bin/lanes/</a>
</li>

<li>Programming in Lua: 6.1 - Closures<br />
<a href="http://www.lua.org/pil/6.1.html">http://www.lua.org/pil/6.1.html</a>
</li>

<li>Programming in Lua: 9.1 - Coroutine Basics<br />
<a href="http://www.lua.org/pil/9.1.html">http://www.lua.org/pil/9.1.html</a>
</li>

<li>Programming in Lua: Numeric for<br />
<a href="http://www.lua.org/pil/4.3.4.html">http://www.lua.org/pil/4.3.4.html</a>
</li>

<li>Programming in Lua: break and return<br />
<a href="http://www.lua.org/pil/4.4.html">http://www.lua.org/pil/4.4.html</a>
</li>

<li>Programming in Lua: Tables<br />
<a href="http://www.lua.org/pil/2.5.html">http://www.lua.org/pil/2.5.html</a>
</li>

<li>Programming in Lua: Table Constructors<br />
<a href="http://www.lua.org/pil/3.6.html">http://www.lua.org/pil/3.6.html</a>
</li>

<li>Programovací jazyk Lua<br />
<a href="http://palmknihy.cz/web/kniha/programovaci-jazyk-lua-12651.htm">http://palmknihy.cz/web/kniha/programovaci-jazyk-lua-12651.htm</a>
</li>

<li>Lua: Tables Tutorial<br />
<a href="http://lua-users.org/wiki/TablesTutorial">http://lua-users.org/wiki/TablesTutorial</a>
</li>

<li>Lua: Control Structure Tutorial<br />
<a href="http://lua-users.org/wiki/ControlStructureTutorial">http://lua-users.org/wiki/ControlStructureTutorial</a>
</li>

<li>Lua Types Tutorial<br />
<a href="http://lua-users.org/wiki/LuaTypesTutorial">http://lua-users.org/wiki/LuaTypesTutorial</a>
</li>

<li>Goto Statement in Lua<br />
<a href="http://lua-users.org/wiki/GotoStatement">http://lua-users.org/wiki/GotoStatement</a>
</li>

<li>Lua 5.2 sources<br />
<a href="http://www.lua.org/source/5.2/">http://www.lua.org/source/5.2/</a>
</li>

<li>Lua 5.2 sources - lopcodes.h<br />
<a href="http://www.lua.org/source/5.2/lopcodes.h.html">http://www.lua.org/source/5.2/lopcodes.h.html</a>
</li>

<li>Lua 5.2 sources - lopcodes.c<br />
<a href="http://www.lua.org/source/5.2/lopcodes.c.html">http://www.lua.org/source/5.2/lopcodes.c.html</a>
</li>

<li>Lambda the Ultimate: Coroutines in Lua,<br />
<a href="http://lambda-the-ultimate.org/node/438">http://lambda-the-ultimate.org/node/438</a>
</li>

<li>Coroutines Tutorial,<br />
<a href="http://lua-users.org/wiki/CoroutinesTutorial">http://lua-users.org/wiki/CoroutinesTutorial</a>
</li>

<li>Lua Coroutines Versus Python Generators,<br />
<a href="http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators">http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators</a>
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the World's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>Sixth Generation Processors<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g6.htm">http://www.pcguide.com/ref/cpu/fam/g6.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>The VFP architecture<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0056d/Bcfibfha.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0056d/Bcfibfha.html</a>
</li>

<li>ARM Floating Point Accelerator (ARM FPA)<br />
<a href="http://vswww.kaist.ac.kr/ver4.0/index.php/research/past-research/arm-fpa.html">http://vswww.kaist.ac.kr/ver4.0/index.php/research/past-research/arm-fpa.html</a>
</li>

<li>The ARM Processor Architecture<br />
<a href="http://www.arm.com/products/processors/technologies/instruction-set-architectures.php">http://www.arm.com/products/processors/technologies/instruction-set-architectures.php</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2014</small></p>
</body>
</html>

