<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - tvorba programových smyèek s&nbsp;vyu¾itím nástroje Javassist</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - tvorba programových smyèek s&nbsp;vyu¾itím nástroje Javassist</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o virtuálním stroji Javy si uká¾eme, jak lze s vyu¾itím nástroje Javassist tvoøit bajtkód metod obsahujících programové smyèky. Uvidíme, ¾e nejproblematiètìj¹ím úkolem je v tomto pøípadì výpoèet cílù nepodmínìných i podmínìných skokù.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - tvorba programových smyèek s&nbsp;vyu¾itím nástroje Javassist</a></p>
<p><a href="#k02">2. Ukázky rùzných zpùsobù generování bajtkódu poèítané programové smyèky <strong>for</strong></a></p>
<p><a href="#k03">3. Generování metody s&nbsp;poèítanou programovou smyèkou <strong>for</strong> v&nbsp;Javassistu</a></p>
<p><a href="#k04">4. Výpoèet cílù podmínìných a nepodmínìných skokù</a></p>
<p><a href="#k05">5. Tvorba bajtkódu programové smyèky &ndash; slo¾itìj¹í varianta</a></p>
<p><a href="#k06">6. Tvorba bajtkódu programové smyèky &ndash; jednodu¹¹í varianta</a></p>
<p><a href="#k07">7. Vylep¹ený výpis struktur bajtkódù obou testovacích metod <strong>loopTest1()</strong> a <strong>loopTest2()</strong></a></p>
<p><a href="#k08">8. Úplný zdrojový kód demonstraèního pøíkladu <strong>ClassGenerationTest9</strong></a></p>
<p><a href="#k09">9. Výstup demonstraèního pøíkladu <strong>ClassGenerationTest9</strong></a></p>
<p><a href="#k10">10. Bajtkód tøídy <strong>GeneratedClass9</strong></a></p>
<p><a href="#k11">11. Repositáø se zdrojovými kódy dne¹ního demonstraèního pøíkladu <strong>ClassGenerationTest9</strong></a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - tvorba programových smyèek s&nbsp;vyu¾itím nástroje Javassist</h2>

<p>V&nbsp;dne¹ní èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyku Java i o virtuálním stroji Javy</a> si uká¾eme, jak je
mo¾né nástroj <i>Javassist</i> vyu¾ít pro generování bajtkódu metod,
v&nbsp;jejich¾ tìle se nachází poèítané programové smyèky èi bì¾né smyèky
s&nbsp;podmínkou testovanou na zaèátku èi na konci ka¾dé iterace. Navá¾eme tak
na pøedchozí èást, v&nbsp;ní¾ jsme &bdquo;pouze&ldquo; upravili ji¾ existující
bajtkód metody s&nbsp;programovou smyèkou. V&nbsp;souèasné verzi
<i>Javassistu</i> sice není tvorba programových smyèek zcela jednoduchá, ov¹em
uvidíme, ¾e i pøes nìkterá omezení spoèívající v&nbsp;nutnosti pou¾ít
nízkoúrovòové operace, je <i>Javassist</i> mo¾né k&nbsp;této èinnosti vyu¾ít.
Jen pro úplnost si pøipomeòme, jaké instrukce se v&nbsp;bajtkódu virtuálního
stroje Javy pou¾ívají v&nbsp;pøípadì potøeby provést nepodmínìný èi podmínìný
skok. Tabulka zobrazená pod tímto odstavcem vznikla slouèením tabulek popsaných
v&nbsp;pøedchozí èásti tohoto seriálu:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Popis</th></tr>
<tr><td>1</td><td>goto</td><td>0xA7</td><td>highbyte, lowbyte</td><td>pøímý skok na adresu ulo¾enou v&nbsp;dvojici operandù: highbyte*256+lowbyte</td></tr>
<tr><td>2</td><td>goto_w</td><td>0xC8</td><td>byte1,byte2,byte3 byte4</td><td>pøímý skok na adresu ulo¾enou ve ètveøici operandù: byte1*2<sup>24</sup>+byte2*2<sup>16</sup>+byte3*2<sup>8</sup>+byte4</td></tr>
<tr><td>3</td><td>ifeq</td><td>0x99</td><td>highbyte, lowbyte</td><td>TOS=0</td><td>skok na lokální adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>4</td><td>ifne</td><td>0x9A</td><td>highbyte, lowbyte</td><td>TOS&ne;0</td><td>skok na lokální adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>5</td><td>iflt</td><td>0x9B</td><td>highbyte, lowbyte</td><td>TOS&lt;0</td><td>skok na lokální adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>6</td><td>ifge</td><td>0x9C</td><td>highbyte, lowbyte</td><td>TOS&ge;0</td><td>skok na lokální adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>7</td><td>ifgt</td><td>0x9D</td><td>highbyte, lowbyte</td><td>TOS&gt;0</td><td>skok na lokální adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>8</td><td>ifle</td><td>0x9E</td><td>highbyte, lowbyte</td><td>TOS&le;0</td><td>skok na lokální adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>9</td><td>if_icmpeq</td><td>0x9F</td><td>highbyte, lowbyte</td><td>value1=value2</td><td>skok na adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>10</td><td>if_icmpne</td><td>0xA0</td><td>highbyte, lowbyte</td><td>value1&ne;value2</td><td>skok na adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>11</td><td>if_icmplt</td><td>0xA1</td><td>highbyte, lowbyte</td><td>value1&lt;value2</td><td>skok na adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>12</td><td>if_icmpge</td><td>0xA2</td><td>highbyte, lowbyte</td><td>value1&ge;value2</td><td>skok na adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>13</td><td>if_icmpgt</td><td>0xA3</td><td>highbyte, lowbyte</td><td>value1&gt;value2</td><td>skok na adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
<tr><td>14</td><td>if_icmple</td><td>0xA4</td><td>highbyte, lowbyte</td><td>value1&le;value2</td><td>skok na adresu highbyte*256+lowbyte pøi splnìní podmínky</td></tr>
</table>

<p>Jak si øekneme v&nbsp;navazujícím textu, jsou adresy cílù skokù uvedeny
relativnì vùèi aktuálnímu indexu instrukce, co¾ je velmi dùle¾ité pøi výpoètu
cíle skoku.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Ukázky rùzných zpùsobù generování bajtkódu poèítané programové smyèky <strong>for</strong></h2>

<p>Nyní se dostáváme k&nbsp;pomìrnì dùle¾ité problematice týkající se zpùsobu
pøekladu zdrojových kódù Javy do bajtkódu. Obecnì je mo¾né øíci, ¾e se
pøekladaèe Javy nesna¾í o provádìní ¾ádných zásadních optimalizací, proto¾e
výsledný bajtkód není ve vìt¹inì pøípadù interpretován, ale následnì pøelo¾en
do nativního zdrojového kódu pomocí <i>JIT</i> pøekladaèe. I z&nbsp;tohoto
dùvodu je vìt¹inou generovaný bajtkód pomìrnì snadno èitelný a dobøe odrá¾í
pùvodní algoritmus napsaný pøímo v&nbsp;Javì. Ov¹em urèitý problém spoèívá
v&nbsp;tom, ¾e i pøes pøesnou definici syntaxe a sémantiky programovacího
jazyka Java (<i>Java Language Specification &ndash; JLS</i>) i pøesnou
specifikaci bajtkódu a významu jednotlivých instrukcí není v&nbsp;¾ádné normì
popsáno, jakým zpùsobem se mají jednotlivé bloky zdrojového kódu zkompilovat do
sekvence instrukcí JVM. To jinými slovy znamená, ¾e ka¾dý pøekladaè Javy mù¾e
generovat odli¹né sekvence instrukcí a pøitom bude stále splòovat jak
<i>JLS</i>, tak i <i>JVM Specification</i> (na tuto vlastnost se nelze dívat
jako na nedostatek, ale spí¹e na svobodu volby tvùrcù pøekladaèù).</p>

<p>Uka¾me si v¹ak konkrétní pøíklad, napøíklad jednoduchou poèítanou smyèku
<strong>for</strong>:</p>

<pre>
<i>/**</i>
<i> * Testovaci trida.</i>
<i> */</i>
public class <strong>LoopTest</strong> {
&nbsp;
    private static void <strong>loopTest1</strong>() {
        int i = 0;
        while (i &lt; 10) {
            System.out.println("Hello world!");
            i++;
        }
    }
&nbsp;
}
</pre>

<p>Pøekladaè <strong>javac</strong> vytvoøí následující sekvenci instrukcí,
v&nbsp;ní¾ se test poèitadla smyèky na koncovou hodnotu provádí
v&nbsp;instrukcích 2, 3 a 5, zatímco na konci smyèky mù¾eme nalézt nepodmínìný
skok <strong>goto</strong>:</p>

<pre>
private static void <strong>loopTest1()</strong>;
  Code:
   0:           iconst_0
   1:           istore_0
   2:           iload_0
   3:           bipush          10
   5:           <strong>if_icmpge       22</strong>
   8:           getstatic       #2; //Field java/lang/System.out:Ljava/io/PrintStream;
   11:          ldc             #3; //String Hello world!
   13:          invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
   16:          iinc            0, 1
   19:          <strong>goto            2</strong>
   22:          return
</pre>

<p>Naproti tomu <strong>ecj</strong> (zále¾í ov¹em na verzi) vytvoøí ponìkud
odli¹ný kód, v&nbsp;nìm¾ je test na hodnotu poèitadla uveden na konci smyèky,
co¾ ale znamená, ¾e ihned na poèátku (pøed první iterací) je nutné se pomocí
nepodmínìného skoku na tento test pøesunout:</p>

<pre>
private static void <strong>loopTest1()</strong>;
  Code:
   0:           iconst_0
   1:           istore_0
   2:           <strong>goto            16</strong>
   5:           getstatic       #20; //Field java/lang/System.out:Ljava/io/PrintStream;
   8:           ldc             #22; //String Hello world!
   10:          invokevirtual   #28; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
   13:          iinc            0, 1
   16:          iload_0
   17:          bipush          10
   19:          <strong>if_icmplt       5</strong>
   22:          return
</pre>

<p>Pov¹imnìte si, ¾e v&nbsp;obou pøípadech má bajtkód délku 23 bajtù a obsahuje
jeden nepodmínìný skok <strong>goto</strong> a jeden skok podmínìný, a to buï
<strong>if_icmpge</strong> nebo k&nbsp;nìmu inverzní test
<strong>if_icmplt</strong>.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Generování metody s&nbsp;poèítanou programovou smyèkou <strong>for</strong> v&nbsp;Javassistu</h2>

<p>V&nbsp;této kapitole i v&nbsp;kapitolách následujících jsou popsány nìkteré
dùle¾ité metody, které jsou souèástí demonstraèního pøíkladu nazvaného
<strong>ClassGenerationTest9</strong>. Tento pøíklad po svém spu¹tìní vytvoøí
bajtkód nové tøídy <strong>GeneratedClass9</strong> se statickými metodami
<strong>main()</strong>, <strong>loopTest1()</strong> a
<strong>loopTest2()</strong>. Obì zmínìné metody loopTest*() po svém zavolání
vytisknou deset øádkù obsahujících shodný textový øetìzec. Bajtkódy tìchto
metod jsou ve skuteènosti prakticky shodné, ov¹em pro jejich vytvoøení
pou¾ijeme nejdøíve slo¾itìj¹í postup s&nbsp;nízkoúrovòovými operacemi a u druhé
metody pak postup, v&nbsp;nìm¾ se bude pou¾ívat vy¹¹í úroveò abstrakce.
Bajtkódy metod jsou stále generovány stejným zpùsobem &ndash; nejprve se
vytvoøí vlastní záznam o metodì, vèetnì údajù o jejích pøíznacích, návratovém
typu i typu jednotlivých parametrù a posléze se ka¾dé metodì pøiøadí atribut
"CODE" s&nbsp;vlastním bajtkódem.</p>

<p>Vytvoøení metody <strong>loopTest1()</strong>:</p>

<pre>
<i>    /**</i>
<i>     * Vytvoreni staticke metody loopTest1() bez navratove hodnoty.</i>
<i>     * Instrukce tvorici telo metody jsou vytvoreny s vyuzitim tridy Bytecode.</i>
<i>     *</i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu</i>
<i>     */</i>
    private static void <strong>constructMethodLoopTest1</strong>(CtClass generatedClass) throws CannotCompileException {
        MethodInfo methodInfo = prepareMethod(generatedClass, "loopTest1");
&nbsp;
        <i>// vytvoreni tela metody</i>
        ConstPool constPool = methodInfo.getConstPool();
        Bytecode bytecode = generateBytecodeForMethodLoopTest1(constPool);
        addCodeAttributeToGeneratedMethod(methodInfo, bytecode);
    }
</pre>

<p>Vytvoøení metody <strong>loopTest2()</strong> je prakticky shodné:</p>

<pre>
<i>    /**</i>
<i>     * Vytvoreni staticke metody loopTest2() bez navratove hodnoty.</i>
<i>     * Instrukce tvorici telo metody jsou vytvoreny s vyuzitim tridy Bytecode.</i>
<i>     *</i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu</i>
<i>     */</i>
    private static void <strong>constructMethodLoopTest2</strong>(CtClass generatedClass) throws CannotCompileException {
        MethodInfo methodInfo = prepareMethod(generatedClass, "loopTest2");
&nbsp;
        <i>// vytvoreni tela metody</i>
        ConstPool constPool = methodInfo.getConstPool();
        Bytecode bytecode = generateBytecodeForMethodLoopTest2(constPool);
        addCodeAttributeToGeneratedMethod(methodInfo, bytecode);
    }
</pre>

<p>U¾ivatelská metoda <strong>prepareMethod()</strong> je takté¾ shodná pro
vytvoøení <strong>loopTest1()</strong> i <strong>loopTest2()</strong>, proto¾e
se v&nbsp;ní nastavují shodné modifikátory, stejný návratový typ (void) i
stejné typy parametrù (nulový poèet):</p>

<pre>
<i>    /**</i>
<i>     * Priprava bajtkodu metody.</i>
<i>     * </i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @param methodName</i>
<i>     *            jmeno vytvarene metody</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu</i>
<i>     */</i>
    private static MethodInfo <strong>prepareMethod</strong>(CtClass generatedClass, String methodName) throws CannotCompileException {
        CtClass returnType = CtClass.voidType;
        CtClass[] parameterTypes = {};
&nbsp;
        <i>// u metody je nutne znat jeji jmeno, navratovou hodnotu i typy parametru</i>
        CtMethod loopTestMethod = new CtMethod(returnType, methodName, parameterTypes, generatedClass);
&nbsp;
        <i>// zmena modifikatoru</i>
        loopTestMethod.setModifiers(Modifier.STATIC | Modifier.PUBLIC);
&nbsp;
        <i>// telo metody</i>
        generatedClass.addMethod(loopTestMethod);
&nbsp;
        MethodInfo methodInfo = loopTestMethod.getMethodInfo();
        return methodInfo;
    }
</pre>

<p>Pøiøazení atributu "CODE" k&nbsp;vygenerované metodì je velmi jednoduchý
úkon:</p>

<pre>
<i>    /**</i>
<i>     * Pridani atributu "CODE" k vygenerovane metode.</i>
<i>     *</i>
<i>     * @param methodInfo</i>
<i>     * @param bytecode</i>
<i>     */</i>
    private static void <strong>addCodeAttributeToGeneratedMethod</strong>(MethodInfo methodInfo, Bytecode bytecode) {
        CodeAttribute codeAttribute = bytecode.toCodeAttribute();
&nbsp;
        methodInfo.setCodeAttribute(codeAttribute);
    }
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Výpoèet cílù podmínìných a nepodmínìných skokù</h2>

<p>Jak jsme si ji¾ ukázali <a href="#k02">ve druhé kapitole</a>, nevyhneme se
pøi implementaci poèítaných programových smyèek pou¾ití nepodmínìných i
podmínìných skokù, u nich¾ je nutné vhodným zpùsobem vypoèítat jejich cíl,
tj.&nbsp;adresu, na kterou se má skok provést. Pøipomeòme si, ¾e instrukce jsou
adresovány v&nbsp;ka¾dé metodì od nuly, proto¾e ve virtuálním stroji Javy
neexistuje pøímo adresovatelný globální adresový prostor. Navíc jsou cíle skokù
zapsány ve formì <i>offsetù</i>, tj.&nbsp;relativních adres, které je nutné
nejprve pøipoèíst k&nbsp;adrese zpracovávané instrukce, abychom získali adresu
absolutní (pøesnìji øeèeno absolutní v&nbsp;rámci lokálního adresního prostoru
metody). Jedním z&nbsp;problémù, které musíme vyøe¹it, je tedy výpoèet ji¾
zmínìného <i>offsetu</i>. K&nbsp;tomu nám dopomù¾e metoda
<strong>Bytecode.currentPc()</strong> vracející index právì zapsané instrukce.
Tento index lze ulo¾it do pomocné promìnné a následnì ho na vhodném místì
vyu¾ít pro výpoèet <i>offsetu</i>.</p>

<p>Dále musíme vyu¾ít dvì nové metody: <strong>Bytecode.addGap(poèet)</strong>
pro vlo¾ení neinicializovaných bajtù do bajtkódu a metodu
<strong>Bytecode.write(index, data)</strong> pro zápis hodnoty bajtu do
bajtkódu na adresu urèenou indexem. Díky existenci této metody je mo¾né se
vrátit k&nbsp;oblasti vyplnìné pomocí <strong>Bytecode.addGap()</strong> a
ulo¾it na toto místo vypoètenou adresu cíle skoku.</p>

<p>Podívejme se nyní na zpùsob vlo¾ení instrukce <strong>GOTO</strong>
provádìjící dopøedný skok. Pøi dopøedném skoku je¹tì nemusíme pøesnì vìdìt
hodnotu <i>offsetu</i>, to v¹ak není nutné. Nejprve vlo¾íme operaèní kód
instrukce <strong>GOTO</strong>, za ní¾ ponecháme dva volné bajty. Souèasnì si
zapamatujeme index instrukce <strong>GOTO</strong> (to pro výpoèet offsetu) i
index prvního volného bajtu:</p>

<pre>
        <i>// za instrukci GOTO nasleduje 16bitovy cil skoku</i>
        <i>// - tyto dva bajty prozatim preskocime</i>
        <i>// - a zapamatujeme si jejich index pro pozdejsi inicializaci</i>
        int gotoInstructionIndex = bytecode.currentPc();
        bytecode.addOpcode(Opcode.GOTO);
        int gotoOperandIndex = bytecode.currentPc();
        bytecode.addGap(2);
</pre>

<p>Na místì, kam má skok smìøovat, opìt získáme hodnotu indexu:</p>

<pre>
        <i>// ted jiz vime, ze sem bude smerovat cil skoku</i>
        int gotoDestinationPC = bytecode.currentPc();
</pre>

<p>Na závìr generování bajtkódu ji¾ snadno vypoèteme <i>offset</i> a zapí¹eme
jeho dva bajty do výplnì za instrukcí <strong>GOTO</strong>. Pøipomeòme si, ¾e
<i>offset</i> mù¾e být jak kladný (dopøedný skok), tak i záporný (skok
zpìt):</p>

<pre>
        <i>// nyni je jiz mozne vyplnit cilovou adresu skoku</i>
        int offset = gotoDestinationPC - gotoInstructionIndex;
        bytecode.write(gotoOperandIndex, offset &gt;&gt; 8);
        bytecode.write(gotoOperandIndex+1, offset);
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Tvorba bajtkódu programové smyèky &ndash; slo¾itìj¹í varianta</h2>

<p>V&nbsp;této chvíli ji¾ máme v¹echny potøebné znalosti nutné pro vytvoøení
bajtkódu metod <strong>loopTest1()</strong> a <strong>loopTest2()</strong>.
Metoda <strong>loopTest1()</strong> bude (zejména kvùli studijním úèelùm)
vytvoøena slo¾itìj¹ím zpùsobem, v&nbsp;nìm¾ jsou pou¾ity pøedev¹ím
nízkoúrovòové operace, které pøímo odpovídají jedenácti instrukcím bajtkódu,
s&nbsp;jejich¾ pomocí má být metoda vytvoøena:.</p>

<pre>
   0:           iconst_0
   1:           istore_0
   2:           goto            16
   5:           getstatic       #14; <i>//Field java/lang/System.out:Ljava/io/PrintStream;</i>
   8:           ldc             #16; <i>//String Hello</i>
   10:          invokevirtual   #22; <i>//Method java/io/PrintStream.println:(Ljava/lang/String;)V</i>
   13:          iinc            0, 1
   16:          iload_0
   17:          bipush          10
   19:          if_icmplt       5
   22:          return
</pre>

<p>Pov¹imnìte si, jakým zpùsobem je uvedených jedenáct instrukcí generováno.
Jedinou problematiètìj¹í èást tvoøí výpoèet cílù skokù:</p>

<pre>
<i>    /**</i>
<i>     * Vytvoreni bajtkodu predstavujiciho sekvenci instrukci pro metodu int</i>
<i>     * loopTest1().</i>
<i>     * </i>
<i>     * @param constPool</i>
<i>     *            tabulka konstant pouzivana metodou</i>
<i>     * @return bajtkod predstavujici sekvenci instrukci pro metodu int foo()</i>
<i>     */</i>
    private static Bytecode <strong>generateBytecodeForMethodLoopTest1</strong>(ConstPool constPool)
    {
        <i>// bajtkod by mel odpovidat nasledujicimu kodu</i>
        <i>//         for (int i = 0; i &lt; 10; i++) {</i>
        <i>//             System.out.println("Hello");</i>
        <i>//         }</i>
&nbsp;
        <i>// coz zhruba odpovida sekvenci instrukci</i>
        <i>//        0:   iconst_0</i>
        <i>//        1:   istore_0</i>
        <i>//        2:   goto    16</i>
        <i>//        5:   getstatic       #20; //Field java/lang/System.out:Ljava/io/PrintStream;</i>
        <i>//        8:   ldc             #42; //String Hello world!</i>
        <i>//        10:  invokevirtual   #28; //Method java/io/PrintStream.println:(Ljava/lang/String;)V</i>
        <i>//        13:  iinc    0, 1</i>
        <i>//        16:  iload_0</i>
        <i>//        17:  bipush  10</i>
        <i>//        19:  if_icmplt       5</i>
        <i>//        22:  return</i>
&nbsp;
        final int stackSize = 1;
        final int localVars = 1;
        Bytecode bytecode = new Bytecode(constPool, stackSize, localVars);
        bytecode.addOpcode(Opcode.ICONST_0);
        bytecode.addOpcode(Opcode.ISTORE_0);
&nbsp;
        <i>// za instrukci GOTO nasleduje 16bitovy cil skoku</i>
        <i>// - tyto dva bajty prozatim preskocime</i>
        <i>// - a zapamatujeme si jejich index pro pozdejsi inicializaci</i>
        int gotoInstructionIndex = bytecode.currentPc();
        bytecode.addOpcode(Opcode.GOTO);
        int gotoOperandIndex = bytecode.currentPc();
        bytecode.addGap(2);
&nbsp;
        <i>// v teto promenne bude ulozen index prvni instrukce smycky</i>
        int loopStartIndex = bytecode.currentPc();
        bytecode.addGetstatic("java.lang.System", "out", "Ljava/io/PrintStream;");
        bytecode.addLdc("Hello");
        bytecode.addInvokevirtual("java.io.PrintStream", "println", "(Ljava/lang/String;)V");
&nbsp;
        <i>// zvyseni hodnoty pocitadla o jednicku</i>
        bytecode.addOpcode(Opcode.IINC);
        bytecode.add(0, 1);
        <i>// ted jiz vime, ze sem bude smerovat cil skoku</i>
        int gotoDestinationPC = bytecode.currentPc();
        bytecode.addOpcode(Opcode.ILOAD_0);
        bytecode.addOpcode(Opcode.BIPUSH);
        bytecode.addOpcode(10);
        int currentPC = bytecode.currentPc();
&nbsp;
        <i>// na konci smycky je umisten podmineny skok</i>
        bytecode.addOpcode(Opcode.IF_ICMPLT);
        <i>// vypocet cile podmineneho skoku -> zacatek smycky</i>
        bytecode.addIndex(loopStartIndex - currentPC);
&nbsp;
        <i>// instrukce Return</i>
        bytecode.addOpcode(Opcode.RETURN);
&nbsp;
        <i>// nyni je jiz mozne vyplnit cilovou adresu skoku</i>
        int offset = gotoDestinationPC - gotoInstructionIndex;
        bytecode.write(gotoOperandIndex, offset &gt;&gt; 8);
        bytecode.write(gotoOperandIndex+1, offset);
&nbsp;
        <i>// finito</i>
        return bytecode;
    }
</pre>

<p>Podmínìný skok <strong>if_icmplt</strong> je provádìn smìrem vzad, tudí¾
není nutné pro cíl skoku rezervovat ¾ádné bajty ani do nich zpìtnì zapisovat
pomocí <strong>Bytecode.write()</strong>. Namísto toho je mo¾né vyu¾ít
praktiètìj¹í metodu <strong>Bytecode.addIndex()</strong> akceptující
¹estnáctibitový index.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Tvorba bajtkódu programové smyèky &ndash; jednodu¹¹í varianta</h2>

<p>Jak jsme si ji¾ naznaèili v&nbsp;pøedchozích kapitolách, je bajtkód metody
<strong>loopTest2()</strong> sice shodný s&nbsp;bajtkódem metody
<strong>loopTest1()</strong>, ov¹em pøi jeho generování jsou vyu¾ity ponìkud
abstraktnìj¹í operace. Týká se to zejména náhrady volání
<strong>Bytecode.addOpcode(Opcode.ICONST_0)</strong> apod. za obecnìj¹í
<strong>Bytecode.addIconst(0)</strong>. Nástroj <i>Javassist</i> sám na základì
parametru rozhodne, jaká instrukce se pou¾ije, co¾ platí i pro
<strong>Bytecode.addIconst(10)</strong>, co¾ se pøelo¾í na instrukci
<strong>BIPUSH 10</strong>. Podobnì je zjednodu¹ena tvorba bajtkódu pro volání
metody <strong>System.out.println()</strong> èi pro návrat z&nbsp;metody
instrukcí <strong>RETURN</strong>. Výpoèet cílù skokù v¹ak není zjednodu¹en a
stále je nutné pou¾ívat pomocné promìnné s&nbsp;ulo¾enými indexy instrukcí
a/nebo jejich operandù:</p>

<pre>
<i>    /**</i>
<i>     * Vytvoreni bajtkodu predstavujiciho sekvenci instrukci pro metodu int</i>
<i>     * loopTest1().</i>
<i>     * </i>
<i>     * @param constPool</i>
<i>     *            tabulka konstant pouzivana metodou</i>
<i>     * @return bajtkod predstavujici sekvenci instrukci pro metodu int foo()</i>
<i>     */</i>
    private static Bytecode <strong>generateBytecodeForMethodLoopTest2</strong>(ConstPool constPool)
    {
        <i>// bajtkod by mel odpovidat nasledujicimu kodu</i>
        <i>//         for (int i = 0; i &lt; 10; i++) {</i>
        <i>//             System.out.println("world!");</i>
        <i>//         }</i>
&nbsp;
        <i>// coz zhruba odpovida sekvenci instrukci</i>
        <i>//        0:   iconst_0</i>
        <i>//        1:   istore_0</i>
        <i>//        2:   goto    16</i>
        <i>//        5:   getstatic       #20; //Field java/lang/System.out:Ljava/io/PrintStream;</i>
        <i>//        8:   ldc             #42; //String Hello world!</i>
        <i>//        10:  invokevirtual   #28; //Method java/io/PrintStream.println:(Ljava/lang/String;)V</i>
        <i>//        13:  iinc    0, 1</i>
        <i>//        16:  iload_0</i>
        <i>//        17:  bipush  10</i>
        <i>//        19:  if_icmplt       5</i>
        <i>//        22:  return</i>
&nbsp;
        final int stackSize = 1;
        final int localVars = 1;
        Bytecode bytecode = new Bytecode(constPool, stackSize, localVars);
        bytecode.addIconst(0);
        bytecode.addIstore(0);
&nbsp;
        <i>// za instrukci GOTO nasleduje 16bitovy cil skoku</i>
        <i>// - tyto dva bajty prozatim preskocime</i>
        <i>// - a zapamatujeme si jejich index pro pozdejsi inicializaci</i>
        int gotoInstructionIndex = bytecode.currentPc();
        bytecode.addOpcode(Opcode.GOTO);
        int gotoOperandIndex = bytecode.currentPc();
        bytecode.addGap(2);
&nbsp;
        <i>// v teto promenne bude ulozen index prvni instrukce smycky</i>
        int loopStartIndex = bytecode.currentPc();
        bytecode.addPrintln("world!");
&nbsp;
        <i>// zvyseni hodnoty pocitadla o jednicku</i>
        bytecode.addOpcode(Opcode.IINC);
        bytecode.add(0, 1);
        <i>// ted jiz vime, ze sem bude smerovat cil skoku</i>
        int gotoDestinationPC = bytecode.currentPc();
        bytecode.addIload(0);
        <i>// pro hodnotu 10 se vygeneruje instrukce BIPUSH 10</i>
        bytecode.addIconst(10);
&nbsp;
        <i>// tuto hodnotu potrebujeme pro vypocet cile podmineneho skoku</i>
        <i>// (pocita se relativne vuci teto instrukci)</i>
        int currentPC = bytecode.currentPc();
&nbsp;
        <i>// na konci smycky je umisten podmineny skok</i>
        bytecode.addOpcode(Opcode.IF_ICMPLT);
        <i>// vypocet cile podmineneho skoku -> zacatek smycky</i>
        bytecode.addIndex(loopStartIndex - currentPC);
&nbsp;
        <i>// instrukce Return</i>
        bytecode.addReturn(CtClass.voidType);
&nbsp;
        <i>// nyni je jiz mozne vyplnit cilovou adresu skoku</i>
        int offset = gotoDestinationPC - gotoInstructionIndex;
        bytecode.write(gotoOperandIndex, offset &gt;&gt; 8);
        bytecode.write(gotoOperandIndex+1, offset);
&nbsp;
        <i>// finito</i>
        return bytecode;
    }
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vylep¹ený výpis struktur bajtkódù obou testovacích metod <strong>loopTest1()</strong> a <strong>loopTest2()</strong></h2>

<p>Souèástí dne¹ního demonstraèního pøíkladu bude i výpis bajtkódu v¹ech
vygenerovaných metod. Na rozdíl od nástroje <strong>javap</strong> v¹ak budeme
pro vìt¹í názornost potøebovat, aby se kromì mnemotechnických kódù jednotlivých
instrukcí zobrazily i hexadecimální hodnoty bajtù tvoøících jak kód instrukce,
tak i její operand èi operandy. Díky tomu si budeme moci lépe ukázat, jak jsou
zakódovány cíle nepodmínìných i podmínìných skokù, napøíklad:</p>

<pre>
03                      iconst_0
3b                      istore_0
a7 00 0e                goto
b2 00 0e                getstatic
12 10                   ldc
b6 00 16                invokevirtual
84 00 01                iinc
1a                      iload_0
10 0a                   bipush
a1 ff f2                if_icmplt
b1                      return
</pre>

<p>U¾ivatelská metoda <strong>printMethodStructures()</strong> je ve
skuteènosti velmi jednoduchá, proto¾e pro v¹echny tøi zkoumané metody zavolá
dal¹í u¾ivatelskou metodu <strong>printMethodStructure()</strong>:</p>

<pre>
<i>    /**</i>
<i>     * Vypis struktury vybranych metod z generovane tridy.</i>
<i>     * </i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws NotFoundException</i>
<i>     *             vyhozena, pokud metoda nebyla nalezena</i>
<i>     * @throws BadBytecode </i>
<i>     */</i>
    private static void <strong>printMethodStructures</strong>(CtClass generatedClass) throws NotFoundException, BadBytecode {
        printMethodStructure(generatedClass, "main");
        printMethodStructure(generatedClass, "loopTest1");
        printMethodStructure(generatedClass, "loopTest2");
    }
</pre>

<p>V&nbsp;u¾ivatelské metodì nazvané <strong>printMethodStructure()</strong> se
nejprve získá instance tøídy <strong>CtMethod</strong> pøedstavující obraz
zkoumané metody. Následnì se pøes volání
<strong>CtMethod.getMethodInfo()</strong> získá instance tøídy
<strong>MethodInfo</strong> obsahující, jak ji¾ název této tøídy napovídá,
informace o zkoumané metodì. My vyu¾ijeme následující ètveøici getterù, které
jsou ve tøídì <strong>MethodInfo</strong> deklarovány:</p>

<table>
<tr><th>#</th><th>Metoda</th><th>Popis</th></tr>
<tr><td>1</td><td>javassist.bytecode.MethodInfo.getName()</td><td>vrátí jméno metody</td></tr>
<tr><td>2</td><td>javassist.bytecode.MethodInfo.getDescriptor()</td><td>vrátí deskriptor metody (èást její signatury)</td></tr>
<tr><td>3</td><td>javassist.bytecode.MethodInfo.getAccessFlags()</td><td>vrátí pøístupová práva a dal¹í modifikátory metody (STATIC...)</td></tr>
<tr><td>4</td><td>javassist.bytecode.MethodInfo.getCodeAttribute()</td><td>vrátí atribut metody reprezentující její tìlo</td></tr>
</table>

<p>V&nbsp;následujícím úryvku zdrojového kódu si pov¹imnìte, jak lze velmi
snadno pøevést modifikátory metody na øetìzec s&nbsp;vyu¾itím
<strong>Modifier.toString()</strong>:</p>

<pre>
<i>    /**</i>
<i>     * Vypis struktury vybrane metody.</i>
<i>     * </i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @param methodName</i>
<i>     *            jmeno metody, jejiz struktura se ma vypsat</i>
<i>     * @throws NotFoundException</i>
<i>     *             vyhozena, pokud metoda nebyla nalezena</i>
<i>     * @throws BadBytecode</i>
<i>     *             vyhozena, pokud se nalezne neplatna instrukce v bytekodu</i>
<i>     */</i>
    private static void <strong>printMethodStructure</strong>(CtClass generatedClass, String methodName) throws NotFoundException, BadBytecode {
        System.out.println("Method '" + methodName + "' structure:");
        CtMethod method = generatedClass.getDeclaredMethod(methodName);
        if (method == null) {
            System.out.println("   not found!");
            return;
        }
        MethodInfo methodInfo = method.getMethodInfo();
        System.out.println("    real name:    " + methodInfo.getName());
        System.out.println("    descriptor:   " + methodInfo.getDescriptor());
        System.out.println("    access flags: " + Modifier.toString(methodInfo.getAccessFlags()));
        System.out.println("    method body:");
        printMethodBody(methodInfo);
        System.out.println();
    }
</pre>

<p>Podívejme se nyní na dal¹í u¾ivatelskou metodu nazvanou
<strong>printMethodBody()</strong>, která vlastnì pøedstavuje ústøední èást
na¹eho jednoduchého &bdquo;disassembleru&ldquo;. V&nbsp;této metodì se prochází
pøes jednotlivé instrukce bajtkódu (metoda <strong>CodeIterator.next()</strong>
mù¾e pøeskoèit o více ne¾ jeden bajt) a následnì jsou vypsány mnemotechnické
zkratky v¹ech pøeètených instrukcí. My ov¹em potøebujeme vypsat i hexadecimální
hodnoty v¹ech bajtù tvoøících jednu instrukci. Kvùli tomu je vypoèten index
následující instrukce a následnì se ve vlo¾ené programové smyèce prochází v¹emi
indexy mezi souèasnì zpracovávanou instrukcí a instrukcí následující. Hodnota
ka¾dého bajtu ulo¾eného na tomto indexu je vypsána a souèasnì se i sní¾í
hodnota pomocné promìnné <i>spaces</i> pou¾ité pro zarovnání názvù operaèních
kódù instrukcí:</p>

<pre>
<i>    /**</i>
<i>     * Vypis instrukci tvoricich telo vybrane metody.</i>
<i>     *</i>
<i>     * @throws NotFoundException</i>
<i>     *             vyhozena, pokud metoda nebyla nalezena</i>
<i>     * @throws BadBytecode</i>
<i>     *             vyhozena, pokud se nalezne neplatna instrukce v bytekodu</i>
<i>     */</i>
    private static void <strong>printMethodBody</strong>(MethodInfo methodInfo) throws BadBytecode {
        CodeAttribute ca = methodInfo.getCodeAttribute();
        CodeIterator iterator = ca.iterator();
        while (iterator.hasNext()) {
            int index = iterator.next();
            int opcode = iterator.byteAt(index);
            int nextIndex = iterator.lookAhead();
            int spaces = 16;
            for (int i = index; i &lt; nextIndex; i++) {
                System.out.format("%02x ", iterator.byteAt(i));
                spaces-=3;
            }
            for (int i = 0; i &lt; spaces; i++) {
                System.out.print(' ');
            }
            System.out.println("        " + Mnemonic.OPCODE[opcode]);
        }
    }
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Úplný zdrojový kód demonstraèního pøíkladu <strong>ClassGenerationTest9</strong></h2>

<p>V&nbsp;této kapitole bude uveden výpis úplného zdrojového kódu dne¹ního
demonstraèního pøíkladu pojmenovaného <strong>ClassGenerationTest9</strong>. Po
spu¹tìní tohoto pøíkladu se nejdøíve vytvoøí bajtkód tøídy
<strong>GeneratedClass9</strong>, která bude obsahovat trojici statických metod
<strong>main()</strong>, <strong>loopTest1()</strong> a
<strong>loopTest2()</strong>, pøièem¾ bajtkód metody
<strong>loopTest1()</strong> je vytvoøen na základì algoritmu uvedeného <a
href="#k05">v&nbsp;páté kapitole</a> a bajtkód metody
<strong>loopTest2()</strong> byl vytvoøen algoritmem popsaným <a
href="#k06">v&nbsp;kapitole ¹esté</a>. Po vytvoøení celé tøídy se následnì
vypí¹e i její struktura, a to vèetnì hexadecimálního výpisu bajtù tvoøících
operaèní kódy i operandy jednotlivých instrukcí bajtkódu (viz té¾ <a
href="#k07">pøedchozí kapitolu</a>):</p>

<pre>
import java.io.IOException;
&nbsp;
import javassist.CannotCompileException;
import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtMethod;
import javassist.Modifier;
import javassist.NotFoundException;
import javassist.bytecode.BadBytecode;
import javassist.bytecode.Bytecode;
import javassist.bytecode.CodeAttribute;
import javassist.bytecode.CodeIterator;
import javassist.bytecode.ConstPool;
import javassist.bytecode.MethodInfo;
import javassist.bytecode.Mnemonic;
import javassist.bytecode.Opcode;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Test moznosti nastroje Javassist - vygenerovani jednoduche tridy</i>
<i> * s metodou main a nekolika dalsimi metodami obsahujicimi programove smycky.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>ClassGenerationTest9</strong> {
&nbsp;
<i>    /**</i>
<i>     * Jmeno vygenerovane tridy.</i>
<i>     */</i>
    private static final String <strong>GENERATED_CLASS_NAME</strong> = "GeneratedClass9";
&nbsp;
<i>    /**</i>
<i>     * Zdrojovy kod metody main(), ktery bude nasledne zkompilovan</i>
<i>     * do bajtkodu a zakomponovan do vytvorene tridy.</i>
<i>     */</i>
    private static final String <strong>MAIN_METHOD_SOURCE_TEXT</strong> =
        "public static void main(String[] args)" +
        "{" +
        "    loopTest1();" +
        "    loopTest2();" +
        "}";
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni metody main() z jejiho zdrojoveho kodu.</i>
<i>     * </i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu</i>
<i>     */</i>
    private static void <strong>addMethodMain</strong>(CtClass generatedClass) throws CannotCompileException {
        CtMethod methodMain = CtMethod.make(MAIN_METHOD_SOURCE_TEXT, generatedClass);
        generatedClass.addMethod(methodMain);
    }
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni staticke metody loopTest1() bez navratove hodnoty.</i>
<i>     * Instrukce tvorici telo metody jsou vytvoreny s vyuzitim tridy Bytecode.</i>
<i>     *</i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu</i>
<i>     */</i>
    private static void <strong>constructMethodLoopTest1</strong>(CtClass generatedClass) throws CannotCompileException {
        MethodInfo methodInfo = prepareMethod(generatedClass, "loopTest1");
&nbsp;
        <i>// vytvoreni tela metody</i>
        ConstPool constPool = methodInfo.getConstPool();
        Bytecode bytecode = generateBytecodeForMethodLoopTest1(constPool);
        addCodeAttributeToGeneratedMethod(methodInfo, bytecode);
    }
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni staticke metody loopTest2() bez navratove hodnoty.</i>
<i>     * Instrukce tvorici telo metody jsou vytvoreny s vyuzitim tridy Bytecode.</i>
<i>     *</i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu</i>
<i>     */</i>
    private static void <strong>constructMethodLoopTest2</strong>(CtClass generatedClass) throws CannotCompileException {
        MethodInfo methodInfo = prepareMethod(generatedClass, "loopTest2");
&nbsp;
        <i>// vytvoreni tela metody</i>
        ConstPool constPool = methodInfo.getConstPool();
        Bytecode bytecode = generateBytecodeForMethodLoopTest2(constPool);
        addCodeAttributeToGeneratedMethod(methodInfo, bytecode);
    }
&nbsp;
<i>    /**</i>
<i>     * Pridani atributu "CODE" k vygenerovane metode.</i>
<i>     *</i>
<i>     * @param methodInfo</i>
<i>     * @param bytecode</i>
<i>     */</i>
    private static void <strong>addCodeAttributeToGeneratedMethod</strong>(MethodInfo methodInfo, Bytecode bytecode) {
        CodeAttribute codeAttribute = bytecode.toCodeAttribute();
&nbsp;
        methodInfo.setCodeAttribute(codeAttribute);
    }
&nbsp;
<i>    /**</i>
<i>     * Priprava bajtkodu metody.</i>
<i>     * </i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @param methodName</i>
<i>     *            jmeno vytvarene metody</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu</i>
<i>     */</i>
    private static MethodInfo <strong>prepareMethod</strong>(CtClass generatedClass, String methodName) throws CannotCompileException {
        CtClass returnType = CtClass.voidType;
        CtClass[] parameterTypes = {};
&nbsp;
        <i>// u metody je nutne znat jeji jmeno, navratovou hodnotu i typy parametru</i>
        CtMethod loopTestMethod = new CtMethod(returnType, methodName, parameterTypes, generatedClass);
&nbsp;
        <i>// zmena modifikatoru</i>
        loopTestMethod.setModifiers(Modifier.STATIC | Modifier.PUBLIC);
&nbsp;
        <i>// telo metody</i>
        generatedClass.addMethod(loopTestMethod);
&nbsp;
        MethodInfo methodInfo = loopTestMethod.getMethodInfo();
        return methodInfo;
    }
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni bajtkodu predstavujiciho sekvenci instrukci pro metodu int</i>
<i>     * loopTest1().</i>
<i>     * </i>
<i>     * @param constPool</i>
<i>     *            tabulka konstant pouzivana metodou</i>
<i>     * @return bajtkod predstavujici sekvenci instrukci pro metodu int foo()</i>
<i>     */</i>
    private static Bytecode <strong>generateBytecodeForMethodLoopTest1</strong>(ConstPool constPool)
    {
        <i>// bajtkod by mel odpovidat nasledujicimu kodu</i>
        <i>//         for (int i = 0; i &lt; 10; i++) {</i>
        <i>//             System.out.println("Hello");</i>
        <i>//         }</i>
&nbsp;
        <i>// coz zhruba odpovida sekvenci instrukci</i>
        <i>//        0:   iconst_0</i>
        <i>//        1:   istore_0</i>
        <i>//        2:   goto    16</i>
        <i>//        5:   getstatic       #20; //Field java/lang/System.out:Ljava/io/PrintStream;</i>
        <i>//        8:   ldc     #42; //String Hello world!</i>
        <i>//        10:  invokevirtual   #28; //Method java/io/PrintStream.println:(Ljava/lang/String;)V</i>
        <i>//        13:  iinc    0, 1</i>
        <i>//        16:  iload_0</i>
        <i>//        17:  bipush  10</i>
        <i>//        19:  if_icmplt       5</i>
        <i>//        22:  return</i>
&nbsp;
        final int stackSize = 1;
        final int localVars = 1;
        Bytecode bytecode = new Bytecode(constPool, stackSize, localVars);
        bytecode.addOpcode(Opcode.ICONST_0);
        bytecode.addOpcode(Opcode.ISTORE_0);
&nbsp;
        <i>// za instrukci GOTO nasleduje 16bitovy cil skoku</i>
        <i>// - tyto dva bajty prozatim preskocime</i>
        <i>// - a zapamatujeme si jejich index pro pozdejsi inicializaci</i>
        int gotoInstructionIndex = bytecode.currentPc();
        bytecode.addOpcode(Opcode.GOTO);
        int gotoOperandIndex = bytecode.currentPc();
        bytecode.addGap(2);
&nbsp;
        <i>// v teto promenne bude ulozen index prvni instrukce smycky</i>
        int loopStartIndex = bytecode.currentPc();
        bytecode.addGetstatic("java.lang.System", "out", "Ljava/io/PrintStream;");
        bytecode.addLdc("Hello");
        bytecode.addInvokevirtual("java.io.PrintStream", "println", "(Ljava/lang/String;)V");
&nbsp;
        <i>// zvyseni hodnoty pocitadla o jednicku</i>
        bytecode.addOpcode(Opcode.IINC);
        bytecode.add(0, 1);
        <i>// ted jiz vime, ze sem bude smerovat cil skoku</i>
        int gotoDestinationPC = bytecode.currentPc();
        bytecode.addOpcode(Opcode.ILOAD_0);
        bytecode.addOpcode(Opcode.BIPUSH);
        bytecode.addOpcode(10);
        int currentPC = bytecode.currentPc();
&nbsp;
        <i>// na konci smycky je umisten podmineny skok</i>
        bytecode.addOpcode(Opcode.IF_ICMPLT);
        <i>// vypocet cile podmineneho skoku -> zacatek smycky</i>
        bytecode.addIndex(loopStartIndex - currentPC);
&nbsp;
        <i>// instrukce Return</i>
        bytecode.addOpcode(Opcode.RETURN);
&nbsp;
        <i>// nyni je jiz mozne vyplnit cilovou adresu skoku</i>
        int offset = gotoDestinationPC - gotoInstructionIndex;
        bytecode.write(gotoOperandIndex, offset &gt;&gt; 8);
        bytecode.write(gotoOperandIndex+1, offset);
&nbsp;
        <i>// finito</i>
        return bytecode;
    }
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni bajtkodu predstavujiciho sekvenci instrukci pro metodu int</i>
<i>     * loopTest1().</i>
<i>     * </i>
<i>     * @param constPool</i>
<i>     *            tabulka konstant pouzivana metodou</i>
<i>     * @return bajtkod predstavujici sekvenci instrukci pro metodu int foo()</i>
<i>     */</i>
    private static Bytecode <strong>generateBytecodeForMethodLoopTest2</strong>(ConstPool constPool)
    {
        <i>// bajtkod by mel odpovidat nasledujicimu kodu</i>
        <i>//         for (int i = 0; i &lt; 10; i++) {</i>
        <i>//             System.out.println("world!");</i>
        <i>//         }</i>
&nbsp;
        <i>// coz zhruba odpovida sekvenci instrukci</i>
        <i>//        0:   iconst_0</i>
        <i>//        1:   istore_0</i>
        <i>//        2:   goto    16</i>
        <i>//        5:   getstatic       #20; //Field java/lang/System.out:Ljava/io/PrintStream;</i>
        <i>//        8:   ldc     #42; //String Hello world!</i>
        <i>//        10:  invokevirtual   #28; //Method java/io/PrintStream.println:(Ljava/lang/String;)V</i>
        <i>//        13:  iinc    0, 1</i>
        <i>//        16:  iload_0</i>
        <i>//        17:  bipush  10</i>
        <i>//        19:  if_icmplt       5</i>
        <i>//        22:  return</i>
&nbsp;
        final int stackSize = 1;
        final int localVars = 1;
        Bytecode bytecode = new Bytecode(constPool, stackSize, localVars);
        bytecode.addIconst(0);
        bytecode.addIstore(0);
&nbsp;
        <i>// za instrukci GOTO nasleduje 16bitovy cil skoku</i>
        <i>// - tyto dva bajty prozatim preskocime</i>
        <i>// - a zapamatujeme si jejich index pro pozdejsi inicializaci</i>
        int gotoInstructionIndex = bytecode.currentPc();
        bytecode.addOpcode(Opcode.GOTO);
        int gotoOperandIndex = bytecode.currentPc();
        bytecode.addGap(2);
&nbsp;
        <i>// v teto promenne bude ulozen index prvni instrukce smycky</i>
        int loopStartIndex = bytecode.currentPc();
        bytecode.addPrintln("world!");
&nbsp;
        <i>// zvyseni hodnoty pocitadla o jednicku</i>
        bytecode.addOpcode(Opcode.IINC);
        bytecode.add(0, 1);
        <i>// ted jiz vime, ze sem bude smerovat cil skoku</i>
        int gotoDestinationPC = bytecode.currentPc();
        bytecode.addIload(0);
        <i>// pro hodnotu 10 se vygeneruje instrukce BIPUSH 10</i>
        bytecode.addIconst(10);
&nbsp;
        <i>// tuto hodnotu potrebujeme pro vypocet cile podmineneho skoku</i>
        <i>// (pocita se relativne vuci teto instrukci)</i>
        int currentPC = bytecode.currentPc();
&nbsp;
        <i>// na konci smycky je umisten podmineny skok</i>
        bytecode.addOpcode(Opcode.IF_ICMPLT);
        <i>// vypocet cile podmineneho skoku -> zacatek smycky</i>
        bytecode.addIndex(loopStartIndex - currentPC);
&nbsp;
        <i>// instrukce Return</i>
        bytecode.addReturn(CtClass.voidType);
&nbsp;
        <i>// nyni je jiz mozne vyplnit cilovou adresu skoku</i>
        int offset = gotoDestinationPC - gotoInstructionIndex;
        bytecode.write(gotoOperandIndex, offset &gt;&gt; 8);
        bytecode.write(gotoOperandIndex+1, offset);
&nbsp;
        <i>// finito</i>
        return bytecode;
    }
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni tridy s metodou main().</i>
<i>     * </i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu metody main()</i>
<i>     * @throws IOException</i>
<i>     *             pokud dojde k chybe pri zapisu bajtkodu na disk</i>
<i>     * @throws NotFoundException</i>
<i>     *             pokud dojde k chybe pri zapisu bajtkodu na disk</i>
<i>     */</i>
    private static CtClass <strong>generateClass</strong>() throws CannotCompileException, NotFoundException, IOException {
        <i>// ziskat vychozi class pool</i>
        ClassPool pool = ClassPool.getDefault();
&nbsp;
        <i>// vytvoreni nove verejne tridy</i>
        CtClass generatedClass = pool.makeClass(GENERATED_CLASS_NAME);
&nbsp;
        <i>// konstrukce nove metody loopTest1()</i>
        constructMethodLoopTest1(generatedClass);
&nbsp;
        <i>// konstrukce nove metody loopTest2()</i>
        constructMethodLoopTest2(generatedClass);
&nbsp;
        <i>// pridani metody do teto tridy</i>
        addMethodMain(generatedClass);
&nbsp;
        <i>// ulozeni bajtkodu na disk</i>
        generatedClass.writeFile();
&nbsp;
        return generatedClass;
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis struktury vybrane metody.</i>
<i>     * </i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @param methodName</i>
<i>     *            jmeno metody, jejiz struktura se ma vypsat</i>
<i>     * @throws NotFoundException</i>
<i>     *             vyhozena, pokud metoda nebyla nalezena</i>
<i>     * @throws BadBytecode</i>
<i>     *             vyhozena, pokud se nalezne neplatna instrukce v bytekodu</i>
<i>     */</i>
    private static void <strong>printMethodStructure</strong>(CtClass generatedClass, String methodName) throws NotFoundException, BadBytecode {
        System.out.println("Method '" + methodName + "' structure:");
        CtMethod method = generatedClass.getDeclaredMethod(methodName);
        if (method == null) {
            System.out.println("   not found!");
            return;
        }
        MethodInfo methodInfo = method.getMethodInfo();
        System.out.println("    real name:    " + methodInfo.getName());
        System.out.println("    descriptor:   " + methodInfo.getDescriptor());
        System.out.println("    access flags: " + Modifier.toString(methodInfo.getAccessFlags()));
        System.out.println("    method body:");
        printMethodBody(methodInfo);
        System.out.println();
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis instrukci tvoricich telo vybrane metody.</i>
<i>     *</i>
<i>     * @throws NotFoundException</i>
<i>     *             vyhozena, pokud metoda nebyla nalezena</i>
<i>     * @throws BadBytecode</i>
<i>     *             vyhozena, pokud se nalezne neplatna instrukce v bytekodu</i>
<i>     */</i>
    private static void <strong>printMethodBody</strong>(MethodInfo methodInfo) throws BadBytecode {
        CodeAttribute ca = methodInfo.getCodeAttribute();
        CodeIterator iterator = ca.iterator();
        while (iterator.hasNext()) {
            int index = iterator.next();
            int opcode = iterator.byteAt(index);
            int nextIndex = iterator.lookAhead();
            int spaces = 16;
            for (int i = index; i &lt; nextIndex; i++) {
                System.out.format("%02x ", iterator.byteAt(i));
                spaces-=3;
            }
            for (int i = 0; i &lt; spaces; i++) {
                System.out.print(' ');
            }
            System.out.println("        " + Mnemonic.OPCODE[opcode]);
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis struktury vybranych metod z generovane tridy.</i>
<i>     * </i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws NotFoundException</i>
<i>     *             vyhozena, pokud metoda nebyla nalezena</i>
<i>     * @throws BadBytecode </i>
<i>     */</i>
    private static void <strong>printMethodStructures</strong>(CtClass generatedClass) throws NotFoundException, BadBytecode {
        printMethodStructure(generatedClass, "main");
        printMethodStructure(generatedClass, "loopTest1");
        printMethodStructure(generatedClass, "loopTest2");
    }
&nbsp;
<i>    /**</i>
<i>     * Spusteni generatoru tridy.</i>
<i>     *</i>
<i>     * @param args nevyuzito</i>
<i>     */</i>
    public static void <strong>main</strong>(String[] args) {
        System.out.println("class generation begin: " + GENERATED_CLASS_NAME);
        try {
            CtClass generatedClass = generateClass();
            <i>// dulezite - generovana trida nesmi byt "zmrazena"</i>
            generatedClass.defrost();
            printMethodStructures(generatedClass);
        }
        catch (CannotCompileException e) {
            e.printStackTrace();
        }
        catch (NotFoundException e) {
            e.printStackTrace();
        }
        catch (IOException e) {
            e.printStackTrace();
        }
        catch (BadBytecode e) {
            e.printStackTrace();
        }
        System.out.println("class generation end: " + GENERATED_CLASS_NAME);
    }
&nbsp;
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Výstup demonstraèního pøíkladu <strong>ClassGenerationTest9</strong></h2>

<p>Podívejme se nyní na to, jak vypadá výstup dne¹ního demonstraèního pøíkladu
<strong>ClassGenerationTest9</strong>. Asi nejzajímavìj¹í informací je zpùsob
ulo¾ení cílù skokù ihned za operaèními kódy instrukcí <strong>goto</strong> a
<strong>if_icmplt</strong>. Pov¹imnìte si, ¾e se skuteènì jedná o dvoubajtovou
celoèíselnou hodnotu se znaménkem. To napøíklad znamená, ¾e sekvence bajtù
<strong>a7 00 0e</strong> znaèí nepodmínìný skok (<strong>goto</strong>) o
ètrnáct bajtù smìrem dopøedu, zatímco sekvence bajtù <strong>a1 ff f2</strong>
je podmínìný skok (konkrétnì <strong>if_icmplt</strong>) o ètrnáct bajtù smìrem
dozadu (oba offsety jsou vypoèteny od zaèátku pøíslu¹né instrukce):</p>

<pre>
class generation begin: GeneratedClass9
Method 'main' structure:
    real name:    main
    descriptor:   ([Ljava/lang/String;)V
    access flags: public static
    method body:
b8 00 21                invokestatic
b8 00 23                invokestatic
b1                      return
&nbsp;
Method 'loopTest1' structure:
    real name:    loopTest1
    descriptor:   ()V
    access flags: public static
    method body:
03                      iconst_0
3b                      istore_0
a7 00 0e                goto
b2 00 0e                getstatic
12 10                   ldc
b6 00 16                invokevirtual
84 00 01                iinc
1a                      iload_0
10 0a                   bipush
a1 ff f2                if_icmplt
b1                      return
&nbsp;
Method 'loopTest2' structure:
    real name:    loopTest2
    descriptor:   ()V
    access flags: public static
    method body:
03                      iconst_0
3b                      istore_0
a7 00 0e                goto
b2 00 1b                getstatic
12 1d                   ldc
b6 00 16                invokevirtual
84 00 01                iinc
1a                      iload_0
10 0a                   bipush
a1 ff f2                if_icmplt
b1                      return
&nbsp;
class generation end: GeneratedClass9
&nbsp;
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Bajtkód tøídy <strong>GeneratedClass9</strong></h2>

<p>Podívejme se nyní na zpùsob, jakým je bajtkód tøídy
<strong>GeneratedClass9</strong> vypsán standardním nástrojem
<strong>javap</strong>. Vzhledem k&nbsp;tomu, ¾e budeme chtít vidìt výpis
bajtkódu jednotlivých metod, a to vèetnì metod soukromých, je nutné nástroj
<strong>javap</strong> spustit následujícím zpùsobem:</p>

<pre>
javap -c -private GeneratedClass9
</pre>

<p>Nástroj <strong>javap</strong> nám v¹ak ve své souèasné verzi nedoká¾e
vypsat i hexadecimální hodnoty bajtù tvoøících operaèní kódy a operandy
instrukcí, tak¾e u skokù budeme vidìt pouze absolutní adresy (samozøejmì platné
v&nbsp;rámci tìla metody):</p>

<pre>
Compiled from "GeneratedClass9.java"
public class <strong>GeneratedClass9</strong> extends java.lang.Object{
&nbsp;
public static void <strong>loopTest1()</strong>;
  Code:
   0:           iconst_0
   1:           istore_0
   2:           goto            16
   5:           getstatic       #14; <i>//Field java/lang/System.out:Ljava/io/PrintStream;</i>
   8:           ldc             #16; <i>//String Hello</i>
   10:          invokevirtual   #22; <i>//Method java/io/PrintStream.println:(Ljava/lang/String;)V</i>
   13:          iinc            0, 1
   16:          iload_0
   17:          bipush          10
   19:          if_icmplt       5
   22:          return
&nbsp;
public static void <strong>loopTest2()</strong>;
  Code:
   0:           iconst_0
   1:           istore_0
   2:           goto            16
   5:           getstatic       #27; <i>//Field java/lang/System.err:Ljava/io/PrintStream;</i>
   8:           ldc             #29; <i>//String world!</i>
   10:          invokevirtual   #22; <i>//Method java/io/PrintStream.println:(Ljava/lang/String;)V</i>
   13:          iinc            0, 1
   16:          iload_0
   17:          bipush          10
   19:          if_icmplt       5
   22:          return
&nbsp;
public static void <strong>main</strong>(java.lang.String[]);
  Code:
   0:           invokestatic    #33; <i>//Method loopTest1:()V</i>
   3:           invokestatic    #35; <i>//Method loopTest2:()V</i>
   6:           return
&nbsp;
public GeneratedClass9();
  Code:
   0:           aload_0
   1:           invokespecial   #38; <i>//Method java/lang/Object."<init>":()V</i>
   4:           return
&nbsp;
}
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Repositáø se zdrojovými kódy dne¹ního demonstraèního pøíkladu <strong>ClassGenerationTest9</strong></h2>

<p>Následuje &ndash; v&nbsp;tomto seriálu ji¾ tradièní &ndash; kapitola
s&nbsp;odkazy na zdrojové kódy. Dnes popsaný demonstraèní pøíklad
<strong>ClassGenerationTest9</strong> je ulo¾en do Mercurial repositáøe
dostupného na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
V&nbsp;následující tabulce najdete odkazy na prozatím nejnovìj¹í verze tohoto
zdrojového kódu:</p>

<table>
<tr><th>#</th><th>Zdrojový soubor/skript</th><th>Umístìní souboru v&nbsp;repositáøi</th></tr>
<tr><td>1</td><td>ClassGenerationTest9.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c4872d13d7c1/javassist/ClassGenerationTest9/ClassGenerationTest9.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/c4872d13d7c1/javassist/ClassGenerationTest9/ClassGenerationTest9.java</a></td></tr>
</table>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>GOTO instruction<br />
<a href="http://www.vmth.ucdavis.edu/incoming/Jasmin/ref-_goto.html">http://www.vmth.ucdavis.edu/incoming/Jasmin/ref-_goto.html</a>
</li>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>IF_ICMPLT instruction<br />
<a href="http://www.vmth.ucdavis.edu/incoming/Jasmin/ref--29.html">http://www.vmth.ucdavis.edu/incoming/Jasmin/ref--29.html</a>
</li>

<li>IFEQ instruction<br />
<a href="http://www.vmth.ucdavis.edu/incoming/Jasmin/ref-_ifeq.html">http://www.vmth.ucdavis.edu/incoming/Jasmin/ref-_ifeq.html</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (pøed verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

