<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (8 - základní vlastnosti trasovacího JITu)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (8 - vlastnosti trasovacího JITu)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V osmé èásti èlánku o Just in Time pøekladaèi LuaJIT si øekneme základní informace o èinnosti takzvaného trasovacího JITu pou¾ívaného pro detekci tìch èástí programového kódu aplikace, které se budou v&nbsp;runtime pøekládat do nativního (strojového) kódu. Trasovací JIT tvoøí zajímavou a dnes stále populárnìj¹í skupinu just-in-time pøekladaèù.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (8 - vlastnosti trasovacího JITu)</a></p>
<p><a href="#k02">2. Princip èinnosti trasovacích JITù</a></p>
<p><a href="#k03">3. Sledování èinnosti trasovacího JITu v&nbsp;runtime: modul &bdquo;v.lua&ldquo; (<i>verbose mode</i>)</a></p>
<p><a href="#k04">4. Demonstraèní pøíklad <strong>test40.lua</strong> &ndash; prostá interpretace poèítané programové smyèky typu <strong>for</strong></a></p>
<p><a href="#k05">5. Demonstraèní pøíklady <strong>test41.lua</strong> a <strong>test42.lua</strong> &ndash; JIT pøeklad poèítané programové smyèky typu <strong>for</strong></a></p>
<p><a href="#k06">6. Demonstraèní pøíklad <strong>test43.lua</strong> &ndash; JIT pøeklad smyèky typu <strong>while</strong></a></p>
<p><a href="#k07">7. Demonstraèní pøíklady <strong>test44.lua</strong>, <strong>test45.lua</strong> a <strong>test46.lua</strong> &ndash; vnoøené poèítané smyèky typu <strong>for</strong></a></p>
<p><a href="#k08">8. Demonstraèní pøíklad <strong>test47.lua</strong> &ndash; trasování dvou vìtví ve vnoøené programové smyèce</a></p>
<p><a href="#k09">9. Zdrojové kódy v¹ech osmi dne¹ních demonstraèních pøíkladù</a></p>
<p><a href="#k10">10. Literatura</a></p>
<p><a href="#k11">11. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (8 - vlastnosti trasovacího JITu)</h2>

<p>Po pomìrnì podrobném vysvìtlení principu pøekladu zdrojových textù napsaných
v&nbsp;programovacím jazyce <i>Lua</i> do bajtkódu pou¾ívaného v&nbsp;projektu
<i>LuaJIT</i> ji¾ máme dostatek informací na to, abychom se mohli zaèít
soustøedit na zajímavìj¹í a vlastnì i mnohem dùle¾itìj¹í oblast &ndash; na
vlastní just-in-time pøeklad, tj.&nbsp;na detekci tìch èástí kódu (bajtkódu),
které se budou pøekládat do nativního (strojového) kódu optimalizovaného pro
aktuálnì pou¾ívanou architekturu. Dùle¾ité je, ¾e v&nbsp;projektu <i>LuaJIT</i>
se vyu¾ívá takzvaný &bdquo;trasovací JIT pøekladaè&ldquo;, který se
v&nbsp;nìkolika ohledech odli¹uje od dnes asi známìj¹ích JIT pøekladaèù typu
hot spot (typickým pøíkladem je HotSpot JIT pou¾itý v&nbsp;JVM, jeho¾ pomìrnì
podrobnému popisu jsme se ji¾ <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">v&nbsp;tomto
seriálu</a> vìnovali).</p>

<p>Trasovací JIT jsou sice zalo¾eny na pomìrnì staré my¹lence, která byla
v&nbsp;minulosti populární pøedev¹ím v&nbsp;akademických projektech, ov¹em do
popøedí zájmu se dostávají a¾ v&nbsp;souèasnosti, a to spoleènì s&nbsp;rozvojem
a stále vìt¹ím roz¹iøováním dynamicky typovaných programovacích jazykù &ndash;
Python, JavaScript apod. Pøíkladem mù¾e být implementace trasovacích JITù
v&nbsp;projektech <i>TraceMonkey</i> (<a
href="https://wiki.mozilla.org/JavaScript:TraceMonkey">https://wiki.mozilla.org/JavaScript:TraceMonkey</a>),
který je dnes postupnì nahrazován ponìkud slo¾itìj¹ím JITem <i>JägerMonkey</i>
èi pravdìpodobnì je¹tì známìj¹í projekt <i>PyPy</i> (<a
href="http://pypy.org/">http://pypy.org/</a>), na nìm¾ se testují nové my¹lenky
a technologie trasovacích JITù. Navíc se v&nbsp;<i>PyPy</i> objevuje zajímavá
alternativa, v&nbsp;ní¾ se trasuje nikoli bajtkód ale vlastní interpret, jen¾
je naprogramovaný v&nbsp;Pythonu (viz té¾ <a href="#k10">desátou kapitolu</a>
s&nbsp;odkazy na literaturu).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Princip èinnosti trasovacích JITù</h2>

<p>Èinnost trasovacích JITù je zalo¾ena na dvou snadno pochopitelných
pøedpokladech. Prvním pøedpokladem je, ¾e typické aplikace tráví nejvíce èasu
(pøesnìji øeèeno strojového èasu) v&nbsp;programových smyèkách (tento
pøedpoklad je nìkdy roz¹íøen i o tail rekurzi). Druhým pøedpokladem je, ¾e
pokud se vykonává programová smyèka, bude cesta v&nbsp;kódu pravdìpodobnì v¾dy
stejná popø.&nbsp;v&nbsp;hor¹ím pøípadì ¾e bude existovat jen nìkolik cest
v&nbsp;programovém kódu (cestou je my¹lena sekvence instrukcí). Trasovací JITy
zalo¾ené na tìchto pøedpokladech se soustøedí na detekci tzv. <i>hot-loops</i>,
tedy èasto vykonávaných programových smyèek. Tyto smyèky jsou následnì
optimalizovány a pøelo¾eny do nativního kódu mikroprocesoru.</p>

<p>Pøi optimalizacích se provádí mnoho operací, s&nbsp;nimi¾ se mù¾eme setkat i
s&nbsp;bì¾ných pøekladaèích &ndash; eliminace mrtvého kódu (zmen¹ují se nároky
na instrukèní cache), rozbalení smyèek (sni¾uje se poèet skokù a tím pádem se i
vylep¹uje vyu¾ití instrukèní pipeline) atd. Detekce <i>hot-loops</i> byla
v&nbsp;tradièních trasovacích JITech implementována analýzou zpìtných
podmínìných skokù (vedoucích na zaèátek smyèky), ov¹em v&nbsp;<i>LuaJITu</i> to
není nutné, a to díky speciálním instrukcím bajtkódu: <strong>LOOP</strong> a
<strong>FORI</strong>.</p>

<p>Zpracování programu v&nbsp;trasovacích JITech je rozdìlena do nìkolika
fází:</p>

<table>
<tr><th>#</th><th>Fáze</th><th>Význam</th></tr>
<tr><td>1</td><td>Interpretation+Profiling</td><td>provádí se interpretace bajtkódu + sumarizace, kolikrát se daná programová smyèka provedla</td></tr>
<tr><td>2</td><td>Tracing</td><td>speciální re¾im interpretru se záznamem historie (historií) provádìných instrukcí</td></tr>
<tr><td>3</td><td>Code generation+Optimization</td><td>pøeklad vybrané stopy/stop do nativního kódu s&nbsp;provedením optimalizací naznaèených v pøedchozím odstavci</td></tr>
<tr><td>4</td><td>Execution</td><td>v této fázi se ji¾ spou¹tí nativní kód a nikoli interpretovaný bajtkód</td></tr>
</table>

<p>Záznam historie neboli &bdquo;stopy&ldquo; provádìného kódu je
z&nbsp;hlediska implementace nejzajímavìj¹í èástí trasovacího JITu. Samotná
stopa je vìt¹inou reprezentována jednodu¹e jako seznam provádìných operací, ve
skuteènosti se ov¹em ve smyèce mohou nacházet rùzné podmínky vedoucí
k&nbsp;vìtvení kódu a tím pádem i ke vzniku dal¹ích &bdquo;stop&ldquo;. Aby se
zajistilo korektní vykonání jedné iterace smyèky, nachází se v&nbsp;generovaném
nativním kódu na místì ka¾dého mo¾ného vìtvení takzvané <i>guard instrukce</i>
detekující jakoukoli odchylku. Detekce odchylky mù¾e vést k&nbsp;dal¹ímu
JITování, co¾ si uká¾eme na jednom demonstraèním pøíkladu ní¾e.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Sledování èinnosti trasovacího JITu v&nbsp;runtime: modul &bdquo;v.lua&ldquo; (<i>verbose mode</i>)</h2>

<p>V&nbsp;<i>LuaJITu</i> existuje mo¾nost jednoduchého sledování základní
èinnosti trasovacího JITu. Postaèuje pou¾ít volbu <strong>-jv</strong>.
V&nbsp;tomto pøípadì se bude informace o trasování vypisovat na standardní
výstup:</p>

<pre>
luajit -jv test47.lua
</pre>

<p>Alternativnì je mo¾né specifikovat výstupní soubor, do nìho¾ se budou
postupnì vypisovat informace o trasování:</p>

<pre>
luajit -jv=test47.out test47.lua
</pre>

<p>Podívejme se na pøíklad výstupu:</p>

<pre>
[TRACE   1 test47.lua:14 loop]
[TRACE   2 test47.lua:12 -&gt; 1]
[TRACE   3 (1/3) test47.lua:16 -&gt; 2]
[TRACE   4 (2/1) test47.lua:18 -&gt; 2]
[TRACE   5 (3/1) test47.lua:11 -&gt; 2]
</pre>

<p>Význam jednotlivých hodnot je struènì vypsán v&nbsp;následující tabulce:</p>

<table>
<tr><th>Hodnota</th><th>Význam</th></tr>
<tr><td>TRACE     </td><td>identifikace øádku vypsaného modulem v.lua (trasování)</td></tr>
<tr><td>1         </td><td>hodnota interního poèitadla stopy (historie provádìní instrukcí)</td></tr>
<tr><td>test47.lua</td><td>jméno zdrojového kódu, kde byl tracer inicializován</td></tr>
<tr><td>:14       </td><td>øádek zdrojového kódu, na nìm¾ byl tracer inicializován</td></tr>
<tr><td>loop      </td><td>typ hot spotu, zde konkrétnì programová smyèka (hot loop)</td></tr>
<tr><td>(1/3)     </td><td>hodnota interního poèitadla rodièovské stopy (pro vnitøní smyèky atd.) + navázání na dal¹í stopu</td></tr>
<tr><td> -&gt; 2  </td><td>èíslo (hodnota poèitadla) stopy, na které vnitøní stopa navazuje</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Demonstraèní pøíklad <strong>test40.lua</strong> &ndash; prostá interpretace poèítané programové smyèky typu <strong>for</strong></h2>

<p>Podívejme se na dne¹ní první demonstraèní pøíklad nazvaný
<strong>test40.lua</strong>. Tento pøíklad je velmi jednoduchý, proto¾e se
v&nbsp;nìm nachází pouze jediná poèítaná programová smyèka typu
<strong>for</strong>, která je provádìna celkem 50&times;:</p>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 40.</i>
<i>--</i>
<i>-- Test JITu.</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<strong>local</strong> i
<strong>local</strong> sum = 0
&nbsp;
<strong>for</strong> i = 1,50 <strong>do</strong>
    sum = sum + 1
<strong>end</strong>
&nbsp;
print(sum)
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Finito.</i>
<i>--</i>
</pre>

<p>Pøi spu¹tìní tohoto demonstraèního pøíkladu pøíkazem:</p>

<pre>
luajit -jv test40.lua
</pre>

<p>se na standardní výstup nevypí¹e ¾ádná zpráva zaèínající na [TRACE...], co¾
znamená, ¾e trasovací JIT nedokázal detekovat ¾ádnou <i>hot loop</i>. Jak je to
mo¾né? Pøi pohledu na zdrojový kód <strong>lj_jit.h</strong>, který je dostupný
na adrese <a
href="http://repo.or.cz/w/luajit-2.0.git/blob_plain/HEAD:/src/lj_jit.h">http://repo.or.cz/w/luajit-2.0.git/blob_plain/HEAD:/src/lj_jit.h</a>.
to snadno zjistíme:</p>

<pre>
...
...
...
  _(\007, hotloop,	56)	/* # of iter. to detect a hot loop/call. */ \
...
...
...
</pre>

<p>To znamená, ¾e <i>hot loop</i> se bude detekovat a¾ po probìhnutí minimálnì
57 iterací! Proè se jedná zrovna o tuto konstantu je tro¹ku záhada, mù¾eme jen
pøedpokládat, ¾e jde o výsledek mìøení chování JITu v&nbsp;reálných
aplikacích.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Demonstraèní pøíklady <strong>test41.lua</strong> a <strong>test42.lua</strong> &ndash; JIT pøeklad poèítané programové smyèky typu <strong>for</strong></h2>

<p>Upravme si tedy demonstraèní pøíklad tak, ¾e ve smyèce pou¾ijeme vìt¹í poèet
iterací:</p>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 41.</i>
<i>--</i>
<i>-- Test JITu.</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<strong>local</strong> i
<strong>local</strong> sum = 0
&nbsp;
<strong>for</strong> i = 1,60 <strong>do</strong>
    sum = sum + 1
<strong>end</strong>
&nbsp;
print(sum)
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Finito.</i>
<i>--</i>
</pre>

<p>Zde je ji¾ situace zajímavìj¹í, proto¾e po spu¹tìní tohoto pøíkladu se na
standardní výstup vypí¹ou dva øádky:</p>

<pre>
[TRACE   1 test41.lua:12 loop]
60
</pre>

<p>Druhý øádek je zcela jistì vypsán samotným pøíkladem, ov¹em øádek první ji¾
naznaèuje, ¾e trasovací JIT na¹el (a následnì pøelo¾il) <i>hot loop</i>. Tato
smyèka zaèíná na øádku dvanáct a jedná se o první a jedinou zaznamenanou stopu
(historii), která byl LuaJITem zpracována. To je dosti podstatný rozdíl
napøíklad pøi porovnání s&nbsp;HotSpotem, kde se je¹tì pøed vlastním spu¹tìním
aplikace (i typu &bdquo;Hello world!&ldquo; pøelo¾í nìkolik desítek i stovek
metod.</p>

<p>Zkusme si zvý¹it poèet iterací a¾ na 1&nbsp;00&nbsp;000&nbsp;000:</p>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 42.</i>
<i>--</i>
<i>-- Test JITu.</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<strong>local</strong> i
<strong>local</strong> sum = 0
&nbsp;
<strong>for</strong> i = 1,1e8 <strong>do</strong>
    sum = sum + 1
<strong>end</strong>
&nbsp;
print(sum)
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Finito.</i>
<i>--</i>
</pre>

<p>I pøesto, ¾e je poèet iterací o mnoho øádù vy¹¹í, ne¾ v&nbsp;pøedchozím
pøíkladu, bude trasovací JIT provádìt pøeklad stejné programové smyèky:</p>

<pre>
[TRACE   1 test42.lua:12 loop]
100000000
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Demonstraèní pøíklad <strong>test43.lua</strong> &ndash; JIT pøeklad smyèky typu <strong>while</strong></h2>

<p>Trasovací JIT dokázal detekovat poèítanou programovou smyèku
<strong>for</strong> díky tomu, ¾e se tato smyèka pøelo¾í do bajtkódu LuaJITu
následujícím zpùsobem vysvìtleným minule i pøedminule:</p>

<pre>
+---&gt;  <strong>FORI</strong> --+  <i>; vstup do poèítané programové smyèky typu for</i>
|      <strong>?</strong>      |
|      <strong>?</strong>      |  <i>; instrukce tvoøící tìlo smyèky</i>
|      <strong>?</strong>      |  <i>; instrukce tvoøící tìlo smyèky</i>
|      <strong>?</strong>      |  <i>; instrukce tvoøící tìlo smyèky</i>
|      <strong>?</strong>      |
+----- <strong>FORL</strong>   |  <i>; dal¹í iterace, skok na zaèátek programové smyèky</i>
      &lt;-------+
</pre>

<p>V&nbsp;pøedchozích èástech jsme si takté¾ øekli, jak se pøelo¾í programová
smyèka typu <strong>while</strong> s&nbsp;podmínkou vyhodnocovanou na zaèátku.
Zde se namísto speciální instrukce <strong>FORI</strong> pou¾ívá instrukce
<strong>LOOP</strong>:</p>

<pre>
+---&gt; <strong>IS??</strong>     <i>; podmínka odvozená z invertované podmínky zapsané ve zdrojovém kódu</i>
|     <strong>JMP</strong> --+  <i>; podmínìný skok ZA konec programové smyèky</i>
|     <strong>LOOP</strong>  |  <i>; oznaèení generické programové smyèky (pro detekci hot spotù)</i>
|     <strong>?</strong>     |
|     <strong>?</strong>     |  <i>; instrukce tvoøící tìlo smyèky</i>
|     <strong>?</strong>     |  <i>; instrukce tvoøící tìlo smyèky</i>
|     <strong>?</strong>     |  <i>; instrukce tvoøící tìlo smyèky</i>
|     <strong>?</strong>     |
|     <strong>?</strong>     |  <i>; end loop</i>
+---- <strong>JMP</strong>   |  <i>; nepodmínìný skok na zaèátek programové smyèky</i>
      &lt;-----+
</pre>

<p>Trasovací JIT by tedy nemìl mít problém ani s&nbsp;detekcí tohoto typu
smyèky, co¾ si ostatnì ihned otestujeme na dal¹ím demonstraèním pøíkladu:</p>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 43.</i>
<i>--</i>
<i>-- Test JITu.</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<strong>local</strong> i = 0
<strong>local</strong> sum = 0
&nbsp;
<strong>while</strong> i &lt; 100 <strong>do</strong>
    sum = sum + 1
    i = i + 1
<strong>end</strong>
&nbsp;
print(sum)
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Finito.</i>
<i>--</i>
</pre>

<p>A skuteènì, podívejme se na výsledek:</p>

<pre>
[TRACE   1 test43.lua:12 loop]
100
</pre>

<p>Z&nbsp;tohoto výpisu je patrné, ¾e trasovací pøekladaè bez problémù
detekoval i existenci smyèky typu <strong>while</strong>.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Demonstraèní pøíklady <strong>test44.lua</strong>, <strong>test45.lua</strong> a <strong>test46.lua</strong> &ndash; vnoøené poèítané smyèky typu <strong>for</strong></h2>

<p>V&nbsp;pøedchozích kapitolách jsme si ukázali, jak doká¾e trasovací JIT
detekovat jednoduché programové smyèky. Nyní se podívejme na to, co se stane
v&nbsp;pøípadì, ¾e pou¾ijeme dvojici vnoøených poèítaných smyèek typu
<strong>for</strong>. V&nbsp;demonstraèním pøíkladu nazvaném
<strong>test44.lua</strong> jsou pou¾ity dvì vnoøené smyèky, pøièem¾ poèet
iterací je v&nbsp;obou smyèkách nastaven pouze na deset iterací, co¾ by
v&nbsp;pøípadì jednoduchých smyèek znamenalo, ¾e trasovací JIT bude tyto smyèky
ignorovat (nebude se jednat o <i>hot loop</i>). Ov¹em vzhledem k&nbsp;tomu, ¾e
jsou smyèky vnoøené, je situace ve skuteènosti dosti odli¹ná:</p>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 44.</i>
<i>--</i>
<i>-- Test JITu.</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<strong>local</strong> i,j
<strong>local</strong> sum = 0
&nbsp;
<strong>for</strong> i = 1,10 <strong>do</strong>
    <strong>for</strong> j = 1,10 <strong>do</strong>
        sum = sum + 1
    <strong>end</strong>
<strong>end</strong>
&nbsp;
print(sum)
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Finito.</i>
<i>--</i>
</pre>

<p>Z&nbsp;výpisu je patrné, ¾e byla detekována <i>hot loop</i> zaèínající na
øádku tøináct. Jedná se tedy o vnitøní smyèku, která bude
&bdquo;JITována&ldquo; (pøelo¾ena) do nativního kódu, zatímco smyèka vnìj¹í
nikoli:</p>

<pre>
[TRACE   1 test44.lua:13 loop]
100
</pre>

<p>Nyní se pokusme poèet iterací provedených ve vnìj¹í a souèasnì i vnitøní
smyèce zvý¹it, a to (v&nbsp;obou pøípadech) nad hodnotu, která ji¾ bude
trasovacím JIT chápána jako <i>hot loop</i>. Víme, ¾e hranice je 57 iterací,
tak¾e pou¾ijeme hodnotu vy¹¹í, konkrétnì sto iterací:</p>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 45.</i>
<i>--</i>
<i>-- Test JITu.</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<strong>local</strong> i,j
<strong>local</strong> sum = 0
&nbsp;
<strong>for</strong> i = 1,100 <strong>do</strong>
    <strong>for</strong> j = 1,100 <strong>do</strong>
        sum = sum + 1
    <strong>end</strong>
<strong>end</strong>
&nbsp;
print(sum)
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Finito.</i>
<i>--</i>
</pre>

<p>Výstup trasovacího JIT je ji¾ mnohem zajímavìj¹í, proto¾e zde mù¾eme vidìt
dvì skuteènosti &ndash; nejprve byla detekována <i>hot loop</i> ve vnitøní
smyèce zaèínající na øádku tøináct (první øádek) a teprve poté byla jako <i>hot
loop</i> oznaèena i vnìj¹í smyèka. První historie (stopa) dostala èíslo 1,
druhá stopa pak èíslo 2, pøièem¾ druhá stopa je navázána na stopu první:</p>

<pre>
[TRACE   1 test45.lua:13 loop]
[TRACE   2 (1/3) test45.lua:12 -&gt; 1]
10000
</pre>

<p>Pojïme je¹tì dále a vyzkou¹ejme si detekci tøí vnoøených <i>hot
loop</i>:</p>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 46.</i>
<i>--</i>
<i>-- Test JITu.</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<strong>local</strong> i,j,k
<strong>local</strong> sum = 0
&nbsp;
<strong>for</strong> i = 1,100 <strong>do</strong>
    <strong>for</strong> j = 1,100 <strong>do</strong>
        <strong>for</strong> k = 1,100 <strong>do</strong>
            sum = sum + 1
        <strong>end</strong>
    <strong>end</strong>
<strong>end</strong>
&nbsp;
print(sum)
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Finito.</i>
<i>--</i>
</pre>

<p>Podle oèekávání byla jako <i>hot loop</i> nejdøíve detekována nejvnitønìj¹í
programová smyèka zaèínající na øádku ètrnáct. Posléze na¹el trasovací JIT
dal¹í <i>hot loop</i> zaèínající na øádku tøináct a navázanou na první <i>hot
loop</i> (první èíslice v&nbsp;závorce). Nakonec na¹el trasovací JIT i poslední
<i>hot loop</i>, a to podle oèekávání na øádku dvanáct s&nbsp;návazností na
druhou <i>hot loop</i> (opìt viz první èíslice v&nbsp;závorce):</p>

<pre>
[TRACE   1 test46.lua:14 loop]
[TRACE   2 (1/3) test46.lua:13 -&gt; 1]
[TRACE   3 (2/1) test46.lua:12 -&gt; 1]
1000000
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Demonstraèní pøíklad <strong>test47.lua</strong> &ndash; trasování dvou vìtví ve vnoøené programové smyèce</h2>

<p>A¾ doposud byla práce trasovacího JITu pomìrnì jednoduchá, ov¹em ji¾
v&nbsp;úvodních kapitolách jsme si øekli, ¾e se pøi trasování musí vzít
v&nbsp;úvahu v¹echny mo¾né cesty. Upravme tedy jeden demonstraèní pøíklad
takovým zpùsobem, ¾e se ve vnitøní smyèce bude provádìt rozvìtvení, pøièem¾
jedna z&nbsp;vìtví bude takté¾ obsahovat programovou smyèku:</p>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 47.</i>
<i>--</i>
<i>-- Test JITu.</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<strong>local</strong> i,j,k
<strong>local</strong> sum = 0
&nbsp;
<strong>for</strong> i = 1,100 <strong>do</strong>
    <strong>for</strong> j = 1,100 <strong>do</strong>
        <strong>if</strong> j &gt;= 50 <strong>then</strong>
            <strong>for</strong> k = 1,100 <strong>do</strong>
                sum = sum + 1
            <strong>end</strong>
        <strong>else</strong>
            sum = sum / 100
        <strong>end</strong>
    <strong>end</strong>
<strong>end</strong>
&nbsp;
print(sum)
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Finito.</i>
<i>--</i>
</pre>

<p>Výsledek je v&nbsp;tomto pøípadì ji¾ dosti slo¾itìj¹í:</p>

<pre>
[TRACE   1 test47.lua:15 loop]
[TRACE   2 test47.lua:13 -&gt; 1]
[TRACE   3 (1/3) test47.lua:17 -&gt; 2]
[TRACE   4 (2/1) test47.lua:19 -&gt; 2]
[TRACE   5 (3/1) test47.lua:12 -&gt; 2]
5100
</pre>

<p>Prvnì byla jako <i>hot loop</i> detekována nejvnitønìj¹í smyèka, co¾ se dalo
oèekávat (viz hranice pro detekci <i>hot loop</i>). Dal¹í stopa/historie
odpovídá prostøední smyèce, pøièem¾ konec této smyèky je shodný s&nbsp;koncem
první <i>hot loop</i>. Dal¹í dvì stopy vlastnì neodpovídají celému tìlu
programové smyèky, ale jen jeho èásti (tøetí øádek nejvnitønìj¹í smyèce, øádek
ètvrtý pak smyèce prostøední). Nakonec byla detekována i vnìj¹í smyèka se
stejným koncovým bodem, jako pøedchozí fragmenty. To je zajímavé, proto¾e tento
výsledek neodpovídá pøesnì intuici programátora. Proè tomu tak je si øekneme
pøí¹tì.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Zdrojové kódy v¹ech osmi dne¹ních demonstraèních pøíkladù</h2>

<p>V¹ech osm dnes pou¾itých demonstraèních pøíkladù bylo, jak je tomu ostatnì
v&nbsp;tomto seriálu ji¾ dlouhodobìj¹ím zvykem, ulo¾eno do Git (pøesnìji øeèeno
do <a href="http://github.com/">GitHub</a>) repositáøe umístìného na adrese <a
href="https://github.com/tisnik/luajit-examples">https://github.com/tisnik/luajit-examples</a>.</p>

<p>Následuje tabulka s&nbsp;odkazy na poslední verze dne¹ních pøíkladù:</p>

<table>
<tr><th>#</th><th>Zdrojový kód</th><th>Umístìní</th></tr>
<tr><td>1</td><td>test40.lua</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/src/test40.lua">https://github.com/tisnik/luajit-examples/blob/master/src/test40.lua</a></td></tr>
<tr><td>2</td><td>test41.lua</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/src/test41.lua">https://github.com/tisnik/luajit-examples/blob/master/src/test41.lua</a></td></tr>
<tr><td>3</td><td>test42.lua</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/src/test42.lua">https://github.com/tisnik/luajit-examples/blob/master/src/test42.lua</a></td></tr>
<tr><td>4</td><td>test43.lua</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/src/test43.lua">https://github.com/tisnik/luajit-examples/blob/master/src/test43.lua</a></td></tr>
<tr><td>5</td><td>test44.lua</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/src/test44.lua">https://github.com/tisnik/luajit-examples/blob/master/src/test44.lua</a></td></tr>
<tr><td>6</td><td>test45.lua</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/src/test45.lua">https://github.com/tisnik/luajit-examples/blob/master/src/test45.lua</a></td></tr>
<tr><td>7</td><td>test46.lua</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/src/test46.lua">https://github.com/tisnik/luajit-examples/blob/master/src/test46.lua</a></td></tr>
<tr><td>8</td><td>test47.lua</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/src/test47.lua">https://github.com/tisnik/luajit-examples/blob/master/src/test47.lua</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>9</td><td>Makefile</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/Makefile">https://github.com/tisnik/luajit-examples/blob/master/Makefile</a></td></tr>
</table>



<p><a name="k10"></a></p>
<h2 id="k10">10. Literatura</h2>

<ol>

<li>Bolz, Cuni, Fijalkowski, Rigo:<br />
&bdquo;Tracing the Meta-Level: PyPy's Tracing JIT Compiler&ldquo;
</li>

<li>Vasanth Bala, Evelyn Duesterwald, Sanjeev Banerjia:<br />
&bdquo;Dynamo: A Transparent Dynamic Optimization System&ldquo;
</li>

<li>Bolz, Cuni, Fijalkowski, Leuschel, Pedroni, Rigo:
&bdquo;Allocation removal by partial evaluation in a tracing JIT&ldquo;
</li>

<li>Bolz:<br />
&bdquo;Automatic JIT Compiler Generation with Runtime Partial Evaluation&ldquo;
</li>

<li>Bolz, Kuhn, Lienhard, Matsakis, Nierstrasz, Renggli, Rigo and T. Verwaest:<br />
&bdquo;Back to the Future in One Week - Implementing a Smalltalk VM in PyPy&ldquo;<br />
pages 123-139. 2008.
</li>

<li>Bolz  and Rigo:<br />
&bdquo;How to not write a virtual machine&ldquo;<br />
In Proceedings of the 3rd Workshop on Dynamic Languages and Applications (DYLA), 2007
</li>

<li>Bruni, Verwaest:<br />
&bdquo;PyGirl: generating Whole-System VMs from High-Level prototypes using PyPy&ldquo;<br />
In Tools, accepted for publication, 2009.
</li>

<li>Sullivan, Bruening, Baron, Garnett and Amarasinghe:<br />
&bdquo;Dynamic native optimization of interpreters&ldquo;<br />
In Proceedings of the 2003 Workshop on Interpreters,<br />
Virtual Machines and Emulators pages 50-57, San Diego, California, 2003. ACM.
</li>

</ol>



<p><a name="k11"></a></p>
<h2 id="k11">11. Odkazy na Internetu</h2>

<ol>

<li>Have tracing JIT compilers won?<br />
<a href="http://lambda-the-ultimate.org/node/3851">http://lambda-the-ultimate.org/node/3851</a>
</li>

<li>Tracing just-in-time compilation<br />
<a href="http://en.wikipedia.org/wiki/Tracing_just-in-time_compilation">http://en.wikipedia.org/wiki/Tracing_just-in-time_compilation</a>
</li>

<li>How does LuaJIT's trace compiler work?<br />
<a href="http://www.freelists.org/post/luajit/How-does-LuaJITs-trace-compiler-work,1">http://www.freelists.org/post/luajit/How-does-LuaJITs-trace-compiler-work,1</a>
</li>

<li></li>How does LuaJIT's trace compiler work?<br />
<a href="http://stackoverflow.com/questions/20266523/how-does-luajits-trace-compiler-work">http://stackoverflow.com/questions/20266523/how-does-luajits-trace-compiler-work</a>
</li>

<li>TraceMonkey<br />
<a href="https://wiki.mozilla.org/JavaScript:TraceMonkey">https://wiki.mozilla.org/JavaScript:TraceMonkey</a>
</li>

<li>TraceMonkey<br />
<a href="http://brendaneich.com/2008/08/tracemonkey-javascript-lightspeed/">http://brendaneich.com/2008/08/tracemonkey-javascript-lightspeed/</a>
</li>

<li>improving JavaScript performance with JägerMonkey<br />
<a href="http://hacks.mozilla.org/2010/03/improving-javascript-performance-with-jagermonkey/">http://hacks.mozilla.org/2010/03/improving-javascript-performance-with-jagermonkey/</a>
</li>

<li>Wikipedia: Mezijazyk<br />
<a href="http://cs.wikipedia.org/wiki/Mezijazyk">http://cs.wikipedia.org/wiki/Mezijazyk</a>
</li>

<li>The LuaJIT Project<br />
<a href="http://luajit.org/index.html">http://luajit.org/index.html</a>
</li>

<li>LuaJIT FAQ<br />
<a href="http://luajit.org/faq.html">http://luajit.org/faq.html</a>
</li>

<li>LuaJIT Performance Comparison<br />
<a href="http://luajit.org/performance.html">http://luajit.org/performance.html</a>
</li>

<li>LuaJIT 2.0 intellectual property disclosure and research opportunities<br />
<a href="http://article.gmane.org/gmane.comp.lang.lua.general/58908">http://article.gmane.org/gmane.comp.lang.lua.general/58908</a>
</li>

<li>LuaJIT Wiki<br />
<a href="http://wiki.luajit.org/Home">http://wiki.luajit.org/Home</a>
</li>

<li>LuaJIT 2.0 Bytecode Instructions<br />
<a href="http://wiki.luajit.org/Bytecode-2.0">http://wiki.luajit.org/Bytecode-2.0</a>
</li>

<li>Programming in Lua 9.1 &ndash; Coroutine Basics,<br />
<a href="http://www.lua.org/pil/9.1.html">http://www.lua.org/pil/9.1.html</a>
</li>

<li>Programming in Lua (first edition)<br />
<a href="http://www.lua.org/pil/contents.html">http://www.lua.org/pil/contents.html</a>
</li>

<li>Programming in Lua: 6 - More about Functions<br />
<a href="http://www.lua.org/pil/6.html">http://www.lua.org/pil/6.html</a>
</li>

<li>Lua Lanes<br />
<a href="http://kotisivu.dnainternet.net/askok/bin/lanes/">http://kotisivu.dnainternet.net/askok/bin/lanes/</a>
</li>

<li>Programming in Lua: 6.1 - Closures<br />
<a href="http://www.lua.org/pil/6.1.html">http://www.lua.org/pil/6.1.html</a>
</li>

<li>Programming in Lua: 9.1 - Coroutine Basics<br />
<a href="http://www.lua.org/pil/9.1.html">http://www.lua.org/pil/9.1.html</a>
</li>

<li>Programming in Lua: Numeric for<br />
<a href="http://www.lua.org/pil/4.3.4.html">http://www.lua.org/pil/4.3.4.html</a>
</li>

<li>Programming in Lua: break and return<br />
<a href="http://www.lua.org/pil/4.4.html">http://www.lua.org/pil/4.4.html</a>
</li>

<li>Programming in Lua: Tables<br />
<a href="http://www.lua.org/pil/2.5.html">http://www.lua.org/pil/2.5.html</a>
</li>

<li>Programming in Lua: Table Constructors<br />
<a href="http://www.lua.org/pil/3.6.html">http://www.lua.org/pil/3.6.html</a>
</li>

<li>Programovací jazyk Lua<br />
<a href="http://palmknihy.cz/web/kniha/programovaci-jazyk-lua-12651.htm">http://palmknihy.cz/web/kniha/programovaci-jazyk-lua-12651.htm</a>
</li>

<li>Lua: Tables Tutorial<br />
<a href="http://lua-users.org/wiki/TablesTutorial">http://lua-users.org/wiki/TablesTutorial</a>
</li>

<li>Lua: Control Structure Tutorial<br />
<a href="http://lua-users.org/wiki/ControlStructureTutorial">http://lua-users.org/wiki/ControlStructureTutorial</a>
</li>

<li>Lua Types Tutorial<br />
<a href="http://lua-users.org/wiki/LuaTypesTutorial">http://lua-users.org/wiki/LuaTypesTutorial</a>
</li>

<li>Goto Statement in Lua<br />
<a href="http://lua-users.org/wiki/GotoStatement">http://lua-users.org/wiki/GotoStatement</a>
</li>

<li>Lua 5.2 sources<br />
<a href="http://www.lua.org/source/5.2/">http://www.lua.org/source/5.2/</a>
</li>

<li>Lua 5.2 sources - lopcodes.h<br />
<a href="http://www.lua.org/source/5.2/lopcodes.h.html">http://www.lua.org/source/5.2/lopcodes.h.html</a>
</li>

<li>Lua 5.2 sources - lopcodes.c<br />
<a href="http://www.lua.org/source/5.2/lopcodes.c.html">http://www.lua.org/source/5.2/lopcodes.c.html</a>
</li>

<li>Lambda the Ultimate: Coroutines in Lua,<br />
<a href="http://lambda-the-ultimate.org/node/438">http://lambda-the-ultimate.org/node/438</a>
</li>

<li>Coroutines Tutorial,<br />
<a href="http://lua-users.org/wiki/CoroutinesTutorial">http://lua-users.org/wiki/CoroutinesTutorial</a>
</li>

<li>Lua Coroutines Versus Python Generators,<br />
<a href="http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators">http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2014</small></p>
</body>
</html>

