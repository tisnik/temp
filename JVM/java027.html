<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM (10.èást - instrukce pro práci s tøídami a objekty)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM (10.èást - instrukce pro práci s tøídami a objekty)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o vlastnostech JVM se ji¾ popáté budeme zabývat popisem instrukèního souboru virtuálního stroje Javy. Zamìøíme se na popis instrukcí, které jsou urèené pro práci s tøídami a objekty, zejména na instrukce pro pøístup k atributùm a metodám tøíd a objektù.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Instrukce slou¾ící pro pøístup k&nbsp;atributùm tøíd (statickým datovým atributùm)</a></p>
<p><a href="#k02">2. Instrukce slou¾ící pro pøístup k&nbsp;atributùm objektù</a></p>
<p><a href="#k03">3. Demonstraèní pøíklad &ndash; pøístup k&nbsp;atributùm tøíd a objektù</a></p>
<p><a href="#k04">4. Instrukce <strong>invokestatic</strong> a <strong>invokevirtual</strong></a></p>
<p><a href="#k05">5. Demonstraèní pøíklad &ndash; vyu¾ití instrukcí <strong>invokestatic</strong> a <strong>invokevirtual</strong> v&nbsp;bajtkódu</a></p>
<p><a href="#k06">6. Instrukce <strong>invokevirtual</strong> pøi volání metody deklarované v&nbsp;pøedkovi tøídy</a></p>
<p><a href="#k07">7. Instrukce <strong>invokespecial</strong></a></p>
<p><a href="#k08">8. Demonstraèní pøíklady &ndash; vyu¾ití instrukce <strong>invokespecial</strong></a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Instrukce slou¾ící pro pøístup k&nbsp;atributùm tøíd (statickým datovým atributùm)</h2>

<p>Po popisu v¹ech instrukcí slou¾ících pro provádìní aritmetických a bitových
operací i instrukcí umo¾òujících øízení bìhu programu, nám je¹tì zbývá si
popsat nìkolik dal¹ích skupin instrukcí. Velmi dùle¾ité jsou pøedev¹ím
instrukce, které slou¾í pro práci s&nbsp;tøídami a objekty. Tyto instrukce
umo¾òují pøístup k&nbsp;atributùm tøíd (tj.&nbsp;k&nbsp;atributùm
s&nbsp;nastaveným modifikátorem &bdquo;static&ldquo;, nìkdy se jim proto také
øíká statické datové atributy) i k&nbsp;atributùm objektù. Dal¹í instrukce pak
slou¾í pro volání statických i virtuálních metod, vèetnì volání konstruktorù.
První skupinu instrukcí, se kterou se dnes seznámíme, tvoøí instrukce slou¾ící
pro pøesuny dat mezi <i>zásobníkem operandù</i> a vybraným atributem tøídy
(statickým datovým atributem) èi atributem objektu. Tyto instrukce nepracují
pøímo s&nbsp;adresou vybraného atributu (tu ostatnì ani nelze nijak zjistit),
ale s&nbsp;jeho signaturou, která je ulo¾ena v&nbsp;<i>constant poolu</i>. Díky
tomu je umo¾nìn dynamický výbìr správného atributu provádìný a¾ v&nbsp;èase
bìhu aplikace.</p>

<p>V&nbsp;následující tabulce jsou vypsány dvì instrukce, které umo¾òují práci
s&nbsp;tøídními (statickými) atributy:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Provádìná operace</th></tr>
<tr><td>1</td><td>getstatic</td><td>0xB2</td><td>highbyte, lowbyte</td><td>získá z&nbsp;constant poolu záznam typu FieldReference a ulo¾í hodnotu získaného atributu na zásobník operandù</td></tr>
<tr><td>2</td><td>putstatic</td><td>0xB3</td><td>highbyte, lowbyte</td><td>opak pøedchozí instrukce: pøesun hodnoty ze zásobníku operandù do statického atributu</td></tr>
</table>

<p>Operandy <i>highbyte</i> a <i>lowbyte</i> tvoøí ¹estnáctibitový index do
<i>constant poolu</i>. Záznam na daném indexu musí být typu
<i>FieldReference</i>, co¾ je pro pøipomenutí záznam obsahující odkaz na dal¹í
záznam typu <i>Class</i> (jméno tøídy) a takté¾ na záznam typu <i>Name and
Type</i> (signatura metody èi atributu).</p>

<p>Pov¹imnìte si jedné zajímavosti: obì dvì instrukce vypsané v&nbsp;pøedchozí
tabulce doká¾ou pracovat s&nbsp;jakýmkoli datovým typem atributu. Virtuální
stroj Javy toti¾ ze signatury atributu zjistí jeho typ a pøekladaè musí
zajistit, aby se na <i>zásobníku operandù</i> skuteènì nacházel operand daného
typu (co¾ platí pro instrukci <strong>putstatic</strong>, zde ov¹em mù¾e dojít
k&nbsp;implicitním typovým konverzím popsaným v&nbsp;dal¹í kapitole), jinak
dojde k&nbsp;chybì pøi analýze bajtkódu pøi jeho naèítání do virtuálního stroje
Javy. Situace je ponìkud slo¾itìj¹í v&nbsp;pøípadì polí, co¾ je v¹ak
problematika, kterou se budeme podrobnìji zabývat a¾ v&nbsp;navazující èásti <a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-8-cast-instrukce-urcene-pro-rizeni-behu-programu/">tohoto
seriálu</a> (pro pøístup k&nbsp;prvkùm polí toti¾ existuje samostatná sada
instrukcí rozdìlených podle typu pole, resp.&nbsp;podle typù prvkù ulo¾ených
v&nbsp;poli).</p>

<p>U instrukce <strong>putstatic</strong> se kontroluje, zda atribut není
finální (klíèové slovo <strong>final</strong>). Pokud tomu tak je, vyvolá se
výjimka typu <i>IllegalAccessError</i>. Samozøejmì se jedná o stav, který je
kontrolován ji¾ pøi pøekladu, ov¹em kvùli dynamiènosti celého JVM se mù¾e stát,
¾e se v&nbsp;bajtkódu mìní atribut tøídy jiné verze, ne¾ byla verze pou¾itá pøi
pøekladu.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Instrukce slou¾ící pro pøístup k&nbsp;atributùm objektù</h2>

<p>Instrukce <strong>getstatic</strong> a <strong>putstatic</strong> <a
href="#k01">z&nbsp;pøedchozí kapitoly</a> doká¾ou pøeèíst èi naopak nastavit
pouze statický atribut, tj.&nbsp;atribut spoleèný pro v¹echny instance jedné
tøídy. Pro ètení èi zápis atributu pøiøazeného ke konkrétnímu objektu
(=instanci tøídy) se naproti tomu pou¾ívají instrukce nazvané
<strong>getfield</strong> a <strong>putfield</strong>, které se od obou
pøedchozích instrukcí li¹í v&nbsp;jednom dùle¾itém detailu: tyto instrukce
oèekávají, ¾e na <i>zásobníku operandù</i> bude ulo¾ena reference na objekt
daného typu.</p>

<p>V&nbsp;tomto ohledu je pro popis jednodu¹¹í instrukce
<strong>getfield</strong>, která pracuje pouze s&nbsp;prvkem ulo¾eným na
vrcholu zásobníku operandù (<i>TOS</i> neboli <i>top of stack</i>). Tento prvek
musí obsahovat referenci na objekt, jeho¾ atribut se má pøeèíst. Reference je
pøi provádìní instrukce <strong>getfield</strong> ze zásobníku operandù
odstranìna a namísto ní se na zásobník operandù ulo¾í hodnota pøeèteného
atributu.</p>

<p>Instrukce <strong>putfield</strong> pracuje s&nbsp;dvojicí prvkù ulo¾ených
na <i>zásobníku operandù</i>. Na TOS musí být ulo¾ena hodnota, na kterou se má
atribut nastavit a pod TOS je oèekávána reference na objekt daného typu. Oba
prvky jsou po provedení instrukce <strong>putfield</strong> ze zásobníku
operandù odstranìny. Navíc se pøi provádìní instrukce <strong>putfield</strong>
provádí stejná kontrola na &bdquo;finálnost&ldquo; atributu, jako tomu bylo u
instrukce <strong>putstatic</strong>.</p>

<p>Operaèní kódy a struèný popis instrukcí <strong>getfield</strong> a
<strong>putfield</strong> jsou vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Provádìná operace</th></tr>
<tr><td>3</td><td>getfield</td><td>0xB4</td><td>highbyte, lowbyte</td><td>získá hodnotu atributu objektu, jeho¾ reference je ulo¾ena na TOS a tuto hodnotu následnì ulo¾í na zásobník operandù</td></tr>
<tr><td>4</td><td>putfield</td><td>0xB5</td><td>highbyte, lowbyte</td><td>obsah TOS se pøenese do atributu objektu, jeho¾ reference je ulo¾ena na druhém místì zásobníku operandù</td></tr>
</table>

<p>Operandy <i>highbyte</i> a <i>lowbyte</i> opìt spoleènì tvoøí
¹estnáctibitový index do <i>constant poolu</i>.</p>

<p>U instrukcí <strong>putstatic</strong> a <strong>putfield</strong> mù¾e
docházet k&nbsp;typovým konverzím mezi prvkem ulo¾eným na zásobníku operandù a
skuteèným typem atributu tøídy èi objektu. Ke konverzím dochází u atributù typu
<i>boolean</i>, <i>byte</i>, <i>char</i> a <i>short</i>, proto¾e hodnoty tohoto
typu nemohou být na zásobníku operandù ulo¾eny (nìkterými dùvody, proè tomu tak
je, jsme se ji¾ zabývali v&nbsp;pøedchozích èástech tohoto seriálu). Virtuální
stroj Javy v¹ak doká¾e automaticky a bez varování èi dokonce zobrazení chybové
zprávy pøevést hodnotu prvku typu <i>int</i> na hodnotu atributu typu
<i>boolean/byte/char/short</i>, a to i v&nbsp;tìch pøípadech, kdy pøi konverzi
dojde k&nbsp;zanedbání nejvy¹¹ích bitù hodnoty.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Demonstraèní pøíklad &ndash; pøístup k&nbsp;atributùm tøíd a objektù</h2>

<p>Zpùsob vyu¾ití v¹ech ètyø instrukcí popsaných v&nbsp;tabulkách uvedených <a
href="#k01">v&nbsp;první kapitole</a> a takté¾ <a href="#k02">ve druhé
kapitole</a> si uká¾eme na jednoduchém demonstraèním pøíkladu. Ve zdrojovém
kódu tohoto pøíkladu je deklarována ètveøice metod. Dvì metody jsou statické a
v&nbsp;jejich tìle se pøistupuje k&nbsp;dvojici statických atributù, zatímco ve
zbývajících dvou metodách se pøistupuje k&nbsp;nestatickým atributùm (atributùm
objektù). Zdrojový kód dne¹ního prvního demonstraèního pøíkladu má tvar:</p>

<pre>
class Test1 {
&nbsp;
    // staticky atribut
    static int staticField;
&nbsp;
    // nestaticky atribut
    int nonStaticField;
&nbsp;
    static void setStaticField(int x) {
        staticField = x;
    }
&nbsp;
    static int getStaticField() {
        return staticField;
    }
&nbsp;
    void setNonStaticField(int x) {
        this.nonStaticField = x;
    }
&nbsp;
    int getNonStaticField() {
        return this.nonStaticField;
    }
&nbsp;
}
</pre>

<p>V&nbsp;dal¹ím popisu nám pomù¾e znalost obsahu <i>constant poolu</i>,
pøedev¹ím tìch záznamù, které jsou ohranièeny hvìzdièkou. Jedná se o záznamy
typu <i>FieldReference</i>, z&nbsp;nich¾ lze vyèíst celou signaturu atributu
(touto problematikou jsme se ji¾ takté¾ v&nbsp;minulosti zabývali):</p>

<pre>
Velikost const. poolu: 25 prvku
  1   10  MethodRef         5  21    java/lang/Object.&lt;init&gt;()V
***************************************************************
  2    9  FieldRef          4  22    Test1.staticField:I
  3    9  FieldRef          4  23    Test1.nonStaticField:I
***************************************************************
  4    7  Class            24        Test1
  5    7  Class            25        java/lang/Object
  6    1  String                     "staticField"
  7    1  String                     "I"
  8    1  String                     "nonStaticField"
  9    1  String                     "&lt;init&gt;"
 10    1  String                     "()V"
 11    1  String                     "Code"
 12    1  String                     "LineNumberTable"
 13    1  String                     "setStaticField"
 14    1  String                     "(I)V"
 15    1  String                     "getStaticField"
 16    1  String                     "()I"
 17    1  String                     "setNonStaticField"
 18    1  String                     "getNonStaticField"
 19    1  String                     "SourceFile"
 20    1  String                     "Test1.java"
 21   12  Name and type    10   9    ()V  &lt;init&gt;
 22   12  Name and type     7   6    I  staticField
 23   12  Name and type     7   8    I  nonStaticField
 24    1  String                     "Test1"
 25    1  String                     "java/lang/Object"
</pre>

<p>Výpis bajtkódu vygenerovaného pro statickou metodu pojmenovanou
<strong>getStaticField</strong>, v&nbsp;ní¾ se ète hodnota statického atributu,
která je následnì pou¾ita jako návratová hodnota metody:</p>

<pre>
static int getStaticField();
  Code:
   0:   getstatic   #2; // ulo¾ení hodnoty atributu specifikovaného
                        // záznamem èíslo 2 z constant poolu na zásobník
                        // operandù
   3:   ireturn         // výskok z metody s pøedáním návratové hodnoty
                        // ulo¾ené na TOS
</pre>

<p>Výpis bajtkódu vygenerovaného pro statickou metodu
<strong>setStaticField</strong>, v&nbsp;ní¾ se modifikuje hodnota statického
atributu:</p>

<pre>
static void setStaticField(int);
  Code:
   0:   iload_0         // ulo¾it na zásobník operandù
                        // první (a jediný) parametr metody
   1:   putstatic   #2; // pøenos hodnoty ulo¾ené na zásobníku operandù
                        // do atributu specifikovaného záznamem èíslo 2
                        // v constant poolu (Test1.staticField:I)
                        // Pùvodní obsah TOS je odstranìn.
   4:   return          // výskok z metody bez pøedání návratové hodnoty
</pre>

<p>Výpis bajtkódu vygenerovaného pro nestatickou metodu
<strong>getNonStaticField</strong>, v&nbsp;ní¾ se ète hodnota nestatického
atributu:</p>

<pre>
int getNonStaticField();
  Code:
   0:   aload_0         // ulo¾it na zásobník operandù neviditelný
                        // parametr metody (this)
   1:   getfield    #3; // ulo¾ení hodnoty atributu specifikovaného
                        // záznamem èíslo 3 z constant poolu na zásobník
                        // operandù. Pùvodní obsah TOS (hodnota this)
                        // je pou¾it a následnì odstranìn.
   4:   ireturn         // výskok z metody s pøedáním návratové hodnoty
                        // ulo¾ené na TOS
</pre>

<p>Výpis bajtkódu vygenerovaného pro nestatickou metodu
<strong>setNonStaticField</strong>, v&nbsp;ní¾ se modifikuje hodnota
nestatického atributu. Zde se pracuje s&nbsp;dvojicí prvkù ulo¾ených na
zásobníku operandù, jedná se tedy o nejslo¾itìj¹í pøípad:</p>

<pre>
void setNonStaticField(int);
  Code:
   0:   aload_0         // ulo¾it na zásobník operandù neviditelný
                        // parametr metody (this)
   1:   iload_1         // ulo¾it na zásobník operandù první viditelný
                        // parametr metody (int)
   2:   putfield    #3; // pøenos hodnoty ulo¾ené na zásobníku operandù
                        // do atributu specifikovaného záznamem èíslo 3
                        // v constant poolu (Test1.nonStaticField:I)
                        // Pùvodní obsah TOS i hodnoty pod TOS jsou odstranìny
   5:   return          // výskok z metody bez pøedání návratové hodnoty
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Instrukce <strong>invokestatic</strong> a <strong>invokevirtual</strong></h2>

<p>Dal¹í skupina instrukcí slou¾í pro volání metod, a» ji¾ se jedná o metody
statické, nestatické (vìt¹inou tedy o metody virtuální), tak i o metody
speciální, mezi nì¾ patøí zejména konstruktory. Základními instrukcemi
patøícími do této skupiny jsou instrukce nazvané <strong>invokestatic</strong>
a <strong>invokevirtual</strong>. Instrukce <strong>invokestatic</strong>
slou¾í, jak ji¾ ostatnì název této instrukce napovídá, k&nbsp;zavolání statické
metody, tj.&nbsp;metody, kterou je mo¾né zavolat i v&nbsp;pøípadì, ¾e
neexistuje ¾ádná instance tøídy, v&nbsp;ní¾ je tato metoda deklarována
(samozøejmì za pøedpokladu, ¾e jsou vhodnì nastavena pøístupová práva
k&nbsp;metodì). Naproti tomu druhá instrukce ze stejné skupiny &ndash;
instrukce <strong>invokevirtual</strong> &ndash; je urèena pro zavolání
nestatické metody, tj.&nbsp;metody, které je jako první (skrytý) parametr
pøedána reference na objekt, v&nbsp;jeho¾ rámci je metoda zavolána (metoda v¹ak
nesmí být privátní, v&nbsp;tomto pøípadì by se musela pou¾ít instrukce
<strong>invokespecial</strong>). Obì instrukce pracují se signaturami metod
ulo¾enými v&nbsp;<i>constant poolu</i> (je to tro¹ku podobné instrukcím
uvedeným <a href="#k01">v&nbsp;první</a> a <a href="#k02">ve druhé
kapitole</a>) a pøed zavoláním statické èi nestatické metody je nutné na
zásobník operandù ulo¾it v¹echny parametry, které se mají volané metodì
pøedat.</p>

<p>Formát obou zmínìných instrukcí je vypsán v&nbsp;tabulce zobrazené pod tímto
odstavcem:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Provádìná operace</th></tr>
<tr><td>1</td><td>invokestatic </td><td>0xB8</td><td>highbyte, lowbyte</td><td>zavolání statické metody s&nbsp;pøedáním parametrù této metodì</td></tr>
<tr><td>2</td><td>invokevirtual</td><td>0xB6</td><td>highbyte, lowbyte</td><td>zavolání nestatické metody s&nbsp;pøedáním hodnoty <strong>this</strong> a v¹ech dal¹ích parametrù</td></tr>
</table>

<p>Operandy <i>highbyte</i> a <i>lowbyte</i> tvoøí ¹estnáctibitový index do
<i>constant poolu</i>. Záznam ulo¾ený na daném indexu musí být typu
<i>MethodReference</i>, co¾ je pro pøipomenutí záznam obsahující odkaz na
záznam typu <i>Class</i> (jméno tøídy) a takté¾ na záznam typu <i>Name and
Type</i> (signatura metody èi atributu). A¾ na rozdíl mezi
<i>FieldReference</i> a <i>MethodReference</i> je tedy význam operandù
<i>highbyte</i> a <i>lowbyte</i> stejný, jako tomu bylo u instrukcí
<strong>putfield</strong>, <strong>putstatic</strong>,
<strong>getfield</strong> a <strong>getstatic</strong>.</p>

<p>V&nbsp;pøípadì instrukce <strong>invokevirtual</strong> je v¹ak situace
ponìkud slo¾itìj¹í, proto¾e virtuální stroj Javy musí zjistit, metoda které
tøídy má být ve skuteènosti zavolána &ndash; mù¾e se toti¾ jednat o metodu
pøedka, a to v&nbsp;libovolné úrovni (klidnì se mù¾e jednat i o metodu
prapøedka v¹ech tøíd &ndash; tøídy <strong>Object</strong>). Proto virtuální
stroj Javy rekurzivnì prochází pøedky tøídy, její¾ instance je ulo¾ena na
zásobníku operandù a hledá metodu se signaturou stejnou, jako je signatura
ulo¾ená v&nbsp;<i>constant poolu</i>. Jakmile je taková metoda nalezena, je
rekurzivní vyhledávání je ukonèeno a nalezená metoda je zavolána se v¹emi
parametry, vèetnì skrytého parametru pøedstavujícího <strong>this</strong>
(referenci na objekt, pro nìj¾ je metoda zavolána).</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Demonstraèní pøíklad &ndash; vyu¾ití instrukcí <strong>invokestatic</strong> a <strong>invokevirtual</strong> v&nbsp;bajtkódu</h2>

<p>Zpùsob vyu¾ití instrukcí <strong>invokestatic</strong> a
<strong>invokevirtual</strong> si uká¾eme na demonstraèním pøíkladu se ètveøicí
metod. První dvì metody, z&nbsp;nich¾ jedna je statická
(<strong>staticMethod</strong>) a druhá nestatická
(<strong>nonStaticMethod</strong>), mají dva parametry typu <i>int</i>, ale pro
jednoduchost je jejich tìlo prázdné. Tyto metody jsou volány z&nbsp;dal¹ích
dvou metod, z&nbsp;nich¾ je opìt jedna metoda statická
(<strong>callStaticMethod</strong>) a druhá nestatická
(<strong>callNonStaticMethod</strong>):</p>

<pre>
class Test2 {
&nbsp;
    static void staticMethod(int x, int y) {
        // nic = prazdne telo
    }
&nbsp;
    void nonStaticMethod(int x, int y) {
        // nic = prazdne telo
    }
&nbsp;
    void callStaticMethod() {
        staticMethod(10, 20);
    }
&nbsp;
    void callNonStaticMethod() {
        nonStaticMethod(10, 20);
    }
}
</pre>

<p>Podobnì jako u prvního demonstraèního pøíkladu, i zde si nejdøíve uká¾eme
obsah <i>constant poolu</i> se zvýraznìním záznamù, s&nbsp;nimi¾ se bude dále
pracovat:</p>

<pre>
Velikost const. poolu: 21 prvku
  1   10  MethodRef         5  17    java/lang/Object.&lt;init&gt;()V
***************************************************************
  2   10  MethodRef         4  18    Test2.staticMethod(II)V
  3   10  MethodRef         4  19    Test2.nonStaticMethod(II)V
***************************************************************
  4    7  Class            20        Test2
  5    7  Class            21        java/lang/Object
  6    1  String                     "&lt;init&gt;"
  7    1  String                     "()V"
  8    1  String                     "Code"
  9    1  String                     "LineNumberTable"
 10    1  String                     "staticMethod"
 11    1  String                     "(II)V"
 12    1  String                     "nonStaticMethod"
 13    1  String                     "callStaticMethod"
 14    1  String                     "callNonStaticMethod"
 15    1  String                     "SourceFile"
 16    1  String                     "Test2.java"
 17   12  Name and type     7   6    ()V  &lt;init&gt;
 18   12  Name and type    11  10    (II)V  staticMethod
 19   12  Name and type    11  12    (II)V  nonStaticMethod
 20    1  String                     "Test2"
 21    1  String                     "java/lang/Object"
</pre>

<p>Bajtkód volané statické metody nazvané <strong>staticMethod</strong> je
velmi jednoduchý:</p>

<pre>
static void staticMethod(int, int);
  Code:
                          // tato metoda nemá ¾ádné tìlo, obsahuje jen
                          // instrukci pro návrat
   0:   return            // výskok z metody bez pøedání návratové hodnoty
</pre>

<p>Podobnì je tomu u bajtkódu nestatické metody
<strong>nonStaticMethod</strong>:</p>

<pre>
void nonStaticMethod(int, int);
  Code:
                          // tato metoda nemá ¾ádné tìlo, obsahuje jen
                          // instrukci pro návrat
   0:   return            // výskok z metody bez pøedání návratové hodnoty
</pre>

<p>Pøi volání statické metody se na zásobník operandù ukládají pouze viditelné
parametry volané metody:</p>

<pre>
void callStaticMethod();
  Code:
   0:   bipush  10        // první parametr volané statické metody
   2:   bipush  20        // druhý parametr volané statické metody
   4:   invokestatic #2;  // Method staticMethod:(II)V
                          // oba prvky na zásobníku operandù se pøi
                          // návratu odstraní
   7:   return            // výskok z metody bez pøedání návratové hodnoty
</pre>

<p>Slo¾itìj¹í je to v&nbsp;pøípadì metody nestatické, proto¾e na zásobník
operandù je nutné kromì viditelných parametrù ulo¾it i neviditelný parametr
<strong>this</strong>:</p>

<pre>
void callNonStaticMethod();
  Code:
   0:   aload_0           // implicitní parametr (this) volané nestatické metody
   1:   bipush  10        // první viditelný parametr volané nestatické metody
   3:   bipush  20        // druhý viditelný parametr volané nestatické metody
   5:   invokevirtual #3; // Method nonStaticMethod:(II)V
                          // v¹echny tøi prvky na zásobníku operandù se pøi
                          // návratu odstraní
   8:   return            // výskok z metody bez pøedání návratové hodnoty
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Instrukce <strong>invokevirtual</strong> pøi volání metody deklarované v&nbsp;pøedkovi tøídy</h2>

<p><a href="#k04">Ve ètvrté kapitole</a> jsme si øekli, ¾e zpùsob zji¹tìní
metody, která se má skuteènì zavolat instrukcí <strong>invokevirtual</strong>
je pomìrnì slo¾itý, proto¾e daná metoda mù¾e být deklarována v&nbsp;nìkterém
pøedkovi tøídy, nikoli v&nbsp;samotné tøídì (pøesnìji øeèeno instanci této
tøídy), pro kterou se metoda volá. Toto chování si mù¾eme ukázat na
demonstraèním pøíkladu s&nbsp;trojicí tøíd <strong>ClassA</strong>,
<strong>ClassB</strong> a <strong>ClassC</strong> tvoøících hierarchii, na
jejím¾ vrcholu stojí tøída <strong>ClassA</strong> (jejím¾ pøedkem je
samozøejmì tøída <strong>Object</strong>):</p>

<pre>
class ClassA {
    void methodA() {
    }
}
&nbsp;
class ClassB extends ClassA {
}
&nbsp;
class ClassC extends ClassB {
    void methodC() {
        // zde se vola metoda deklarovana
        // v prapredkovi = tride ClassA
        methodA();
    }
}
</pre>

<p>Podívejme se nyní, jak vypadá bajtkód metody <strong>methodC</strong>:</p>

<pre>
void methodC();
  Code:
   Stack=1, Locals=1, Args_size=1
   0:   aload_0
   1:   invokevirtual   #2; // Method methodA:()V
                            // ClassC.methodA:()V
   4:   return
</pre>

<p>Ve skuteènosti se v¹ak v&nbsp;bajtkódu tøídy <strong>ClassC</strong> ¾ádná
metoda nazvaná <strong>methodA</strong> nenachází. Z&nbsp;tohoto dùvodu musí
virtuální stroj Javy danou metodu postupnì hledat v&nbsp;pøedcích dané tøídy,
tj.&nbsp;nejdøíve ve tøídì <strong>ClassB</strong> (bez úspìchu) a posléze ve
tøídì <strong>ClassA</strong> (zde ji¾ s&nbsp;úspìchem).</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Instrukce <strong>invokespecial</strong></h2>

<p>Dal¹í instrukcí urèenou pro volání metod, je instrukce nazvaná
<strong>invokespecial</strong>. Tato instrukce se pou¾ívá zejména pøi
inicializaci objektu, konkrétnì pøi volání konstruktoru pøedka poté, co je
objekt vytvoøen, ale takté¾ pøi volání privátních metod, popø.&nbsp;pøekrytých
metod. Struktura instrukce <strong>invokespecial</strong> je vypsána
v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Provádìná operace</th></tr>
<tr><td>1</td><td>invokespecial</td><td>0xB7</td><td></td><td></td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Demonstraèní pøíklady &ndash; vyu¾ití instrukce <strong>invokespecial</strong></h2>

<p>Jak jsme si ji¾ øekli v&nbsp;pøedchozí kapitole, má instrukce
<strong>invokespecial</strong> hned nìkolik vyu¾ití. Prvním z&nbsp;nich je
volání privátní metody. Rozdíl mezi voláním privátní a neprivátní metody
ilustruje následující demonstraèní pøíklad:</p>

<pre>
class PrivateAndPublicCall1 {
&nbsp;
    private void privateMethod() {
        // nic = prazdne telo
    }
&nbsp;
    public void publicMethod() {
        // nic = prazdne telo
    }
&nbsp;
    void call() {
        privateMethod();
        publicMethod();
    }
}
</pre>

<p>Zajímat nás samozøejmì bude bajtkód metody <strong>call</strong>, která volá
jak privátní metodu, tak i metodu veøejnou:</p>

<pre>
void call();
  Code:
   0:   aload_0             // ulo¾it referenci "this"
                            // na zásobník operandù
   1:   invokespecial   #2; // Method privateMethod:()V
                            // privátní metoda = invokespecial
   4:   aload_0             // ulo¾it referenci "this"
                            // na zásobník operandù
   5:   invokevirtual   #3; //Method publicMethod:()V
                            // veøejná metoda = invokevirtual
   8:   return
</pre>

<p>Aby to v¹ak nebylo tak jednoduché, je situace pøi volání
<strong>statických</strong> privátních a veøejných metod odli¹ná, proto¾e se
zde pou¾ije stejná instrukce:</p>

<pre>
class PrivateAndPublicCall2 {
&nbsp;
    private static void privateStaticMethod() {
        // nic = prazdne telo
    }
&nbsp;
    public static void publicStaticMethod() {
        // nic = prazdne telo
    }
&nbsp;
    void callStatic() {
        privateStaticMethod();
        publicStaticMethod();
    }
&nbsp;
}
</pre>

<p>V&nbsp;tomto pøípadì je bajtkód metody <strong>callStatic</strong>
následující:</p>

<pre>
void callStatic();
  Code:
   0:   invokestatic    #4; //Method privateStaticMethod:()V
   3:   invokestatic    #5; //Method publicStaticMethod:()V
   6:   return
</pre>

<p>Instrukce <strong>invokespecial</strong> se vyu¾ívá takté¾ pøi inicializaci
objektù, co¾ si uká¾eme na ponìkud odli¹ném demonstraèním pøíkladu
s&nbsp;následujícím zdrojovým kódem, v&nbsp;jeho¾ metodách se konstruují
instance tøíd <strong>Test3</strong>, <strong>Integer</strong> a
<strong>String</strong>:</p>

<pre>
class Test3 {
&nbsp;
    public static void testInvokeSpecial1() {
        new Test3();
    }
&nbsp;
    public static Integer testInvokeSpecial2() {
        return new Integer(42);
    }
&nbsp;
    public static void testInvokeSpecial3() {
        new String("pokus");
    }
&nbsp;
}
</pre>

<p>Opìt nebude na ¹kodu si ukázat obsah <i>constant poolu</i> ulo¾eného
v&nbsp;bajtkódu. Dùle¾ité záznamy jsou ohranièeny hvìzdièkami:</p>

<pre>
Velikost const. poolu: 29 prvku
  1   10  MethodRef         9  20    java/lang/Object.&lt;init&gt;()V
  2    7  Class            21        Test3
***************************************************************
  3   10  MethodRef         2  20    Test3.&lt;init&gt;()V
***************************************************************
  4    7  Class            22        java/lang/Integer
***************************************************************
  5   10  MethodRef         4  23    java/lang/Integer.&lt;init&gt;(I)V
***************************************************************
  6    7  Class            24        java/lang/String
  7    8  String const     25        "pokus"
***************************************************************
  8   10  MethodRef         6  26    java/lang/String.&lt;init&gt;(Ljava/lang/String;)V
***************************************************************
  9    7  Class            27        java/lang/Object
 10    1  String                     "&lt;init&gt;"
 11    1  String                     "()V"
 12    1  String                     "Code"
 13    1  String                     "LineNumberTable"
 14    1  String                     "testInvokeSpecial1"
 15    1  String                     "testInvokeSpecial2"
 16    1  String                     "()Ljava/lang/Integer;"
 17    1  String                     "testInvokeSpecial3"
 18    1  String                     "SourceFile"
 19    1  String                     "Test3.java"
 20   12  Name and type    11  10    ()V  &lt;init&gt;
 21    1  String                     "Test3"
 22    1  String                     "java/lang/Integer"
 23   12  Name and type    28  10    (I)V  &lt;init&gt;
 24    1  String                     "java/lang/String"
 25    1  String                     "pokus"
 26   12  Name and type    29  10    (Ljava/lang/String;)V  &lt;init&gt;
 27    1  String                     "java/lang/Object"
 28    1  String                     "(I)V"
 29    1  String                     "(Ljava/lang/String;)V"
</pre>

<p>V&nbsp;bajtkódu metody <strong>testInvokeSpecial1</strong> se nejdøíve
pomocí instrukce <strong>new</strong> vytvoøí instance tøídy
<strong>Test3</strong> a posléze se zavolá speciální metoda nazvaná
<strong>&lt;init&gt;</strong>, která (ponìkud zjednodu¹enì øeèeno) odpovídá
konstruktoru této tøídy. Pov¹imnìte si také dvojice instrukcí
<strong>dup</strong> a <strong>pop</strong> na adresách 3 a 7. Tyto instrukce
slou¾í pro úschovu a následné odstranìní reference na objekt vytvoøený pomocí
<strong>new</strong>, i kdy¾ ve skuteènosti není tato reference nikde pou¾ita
(instrukce <strong>invokespecial</strong> takté¾ vyu¾ívá referenci na vytvoøený
objekt, ov¹em tato reference je pøi zpracování této instrukce z&nbsp;TOS
odstranìna):</p>

<pre>
public static void testInvokeSpecial1();
  Code:
   0:   new #2;           // vytvoøení instance tøídy Test3
   3:   dup               // invokespecial vyu¾ije a zahodí referenci
                          // ulo¾enou na TOS, proto javac vygeneruje
                          // tuto instrukci, která referenci na
                          // zásobníku zachová
   4:   invokespecial #3; // zavolání konstruktoru bez parametrù:
                          // Method "&lt;init&gt;":()V
                          // na zásobníku operandù je ulo¾ena reference
                          // vytvoøeného objektu
   7:   pop               // objekt je sice vytvoøen, ale jeho referenci
                          // nevyu¾íváme: je odstranìna pomocí pop
   8:   return            // výskok z metody bez pøedání návratové hodnoty
</pre>

<p>V&nbsp;metodì <strong>testInvokeSpecial2</strong> je vytvoøen objekt typu
<strong>Integer</strong>, pøièem¾ je vyu¾it jednoparametrický konstruktor této
tøídy. Pov¹imnìte si, ¾e v&nbsp;bajtkódu je opìt vyu¾ita instrukce
<strong>dup</strong> pro vytvoøení kopie reference na vytvoøený objekt, a
v&nbsp;tomto pøípadì je kopie skuteènì vyu¾ita instrukcí
<strong>areturn</strong>:</p>

<pre>
public static java.lang.Integer testInvokeSpecial2();
  Code:
   0:   new #4;           // vytvoøení instance tøídy java.lang.Integer
   3:   dup               // invokespecial vyu¾ije a zahodí referenci
                          // ulo¾enou na TOS, proto javac vygeneruje
                          // tuto instrukci, která referenci na
                          // zásobníku zachová
   4:   bipush  42        // parametr pøedaný konstruktoru tøídy Integer
   6:   invokespecial #5; // zavolání konstruktoru s jedním parametrem:
                          // Method java/lang/Integer."&lt;init&gt;":(I)V
                          // na zásobníku operandù je ulo¾ena reference
                          // vytvoøeného objektu
   9:   areturn           // výskok z metody s pøedáním návratové hodnoty
</pre>

<p>V&nbsp;metodì <strong>testInvokeSpecial3</strong> je nejprve vytvoøena
instance tøídy <strong>String</strong>, a to mimochodem znaènì neefektivním a
amatérským zpùsobem :-)  Konstruktor tøídy <strong>String</strong> je volán
s&nbsp;jedním parametrem, kterým je øetìzcová konstanta ulo¾ená
v&nbsp;<i>constant poolu</i>. I pøesto, ¾e se s&nbsp;referencí na vytvoøený
objekt nijak nepracuje, vygeneruje pøekladaè dvojici instrukcí
<strong>dup</strong> a <strong>pop</strong>, podobnì jako tomu bylo
v&nbsp;metodì <strong>testInvokeSpecial1</strong>:</p>

<pre>
public static void testInvokeSpecial3();
  Code:
   0:   new #6;           // vytvoøení instance tøídy java.lang.String
   3:   dup               // invokespecial vyu¾ije a zahodí referenci
                          // ulo¾enou na TOS, proto javac vygeneruje
                          // tuto instrukci, která referenci na
                          // zásobníku zachová
   4:   ldc #7;           // String pokus
   6:   invokespecial #8; // zavolání konstruktoru s jedním parametrem:
                          // Method java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V
   9:   pop               // objekt je sice vytvoøen, ale jeho referenci
                          // nevyu¾íváme: je odstranìna pomocí pop
   10:  return            // výskok z metody bez pøedání návratové hodnoty
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Root.cz: Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM<br />
<a href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/</a></a>
</li>

<li>Root.cz: JamVM aneb alternativa k HotSpotu nejenom pro embedded zaøízení a chytré telefony<br />
<a href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>FindBugs<br />
<a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a>
</li>

<li>GNU Classpath<br />
<a href="www.gnu.org/s/classpath/">www.gnu.org/s/classpath/</a></li>

<li>Java VMs Compared<br />
<a href="http://bugblogger.com/java-vms-compared-160/">http://bugblogger.com/java-vms-compared-160/</a>
</li>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>CloseableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html">http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

