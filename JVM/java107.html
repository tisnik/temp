<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - exkluzivní celoobrazovkové grafické re¾imy</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - exkluzivní celoobrazovkové grafické re¾imy</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Dne¹ní èást seriálu o programovacím jazyce Java i o virtuálním stroji Javy je zamìøena na popis základních vlastností exkluzivních celoobrazovkových grafických re¾imù, které lze v Javì pou¾ít pro tvorbu her a dem. Uká¾eme si, jak lze zjistit základní informace o dostupných grafických re¾imech i jak se provádí zapnutí vybraného re¾imu.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - exkluzivní celoobrazovkové grafické re¾imy</a></p>
<p><a href="#k02">2. Zji¹tìní informací o nainstalovaných grafických kartách</a></p>
<p><a href="#k03">3. Zji¹tìní informací o v¹ech dostupných grafických re¾imech</a></p>
<p><a href="#k04">4. První demonstraèní pøíklad: výpis informací o v¹ech dostupných grafických re¾imech</a></p>
<p><a href="#k05">5. Ukázky výstupu prvního demonstraèního pøíkladu</a></p>
<p><a href="#k06">6. Nastavení celoobrazovkového grafického re¾imu</a></p>
<p><a href="#k07">7. Druhý demonstraèní pøíklad: postupné nastavení v¹ech dostupných celoobrazovkových grafických re¾imù</a></p>
<p><a href="#k08">8. Problematika tvorby a vykreslování bitmap podruhé</a></p>
<p><a href="#k09">9. Repositáø se zdrojovými soubory obou demonstraèních pøíkladù</a></p>
<p><a href="#k10">10. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - exkluzivní celoobrazovkové grafické re¾imy</h2>

<p>V&nbsp;dne¹ní èásti seriálu o programovacím jazyce Java i o virtuálním
stroji Javy se seznámíme s&nbsp;API Javy, které je urèeno pro
&bdquo;exkluzivní&ldquo; práci s&nbsp;takzvanými celoobrazovkovými grafickými
re¾imy. I pøes tento ponìkud honosný název jsou tøídy, rozhraní a metody
nabízené tímto API pomìrnì snadno pochopitelné i pou¾itelné. Základem tohoto
rozhraní jsou tøídy a metody umo¾òující zjistit informace o v¹ech dostupných
grafických re¾imech. Vybraný grafický re¾im je následnì mo¾né zapnout a poté
vyu¾ívat &bdquo;exkluzivní&ldquo; pøístup na obrazovku bez toho, aby se musela
aplikace èi nìjaká grafická knihovna zabývat a zdr¾ovat zobrazováním oken
jiných aplikací. V&nbsp;celoobrazovkových re¾imech je navíc mo¾né vykreslovat
bitmapy (rastrové obrázky) obecnì rychleji, ne¾ by tomu bylo pøi práci
v&nbsp;oknì (rámci). Rychlej¹ího vykreslování je dosa¾eno pou¾itím funkcí
grafických akcelerátorù a takté¾ tím, ¾e bitmapy, s&nbsp;nimi¾ se èasto
pracuje, mohou být ulo¾eny pøímo v&nbsp;obrazové pamìti a nikoli v&nbsp;hlavní
pamìti (potom by bylo nutné neustále bitmapy pøená¹et a tím zbyteènì zatì¾ovat
CPU).</p>

<p>Dnes popisované API navíc umo¾òuje rozdìlení obrazové pamìti
(<i>framebufferu</i>) na takzvaný pøední a zadní buffer (<i>front buffer</i>,
<i>back buffer</i>) s&nbsp;tím, ¾e vykreslování lze provádìt do neviditelného
zadního bufferu bez toho, aby u¾ivatel vidìl jednotlivé fáze vykreslování. Ve
chvíli, kdy je vykreslení celého obrázku v&nbsp;zadním bufferu dokonèeno, se
úlohy pøedního a zadního bufferu jednodu¹e prohodí, co¾ je opìt operace
podporovaná v¹emi grafickými akcelerátory. V&nbsp;souvislosti
s&nbsp;framebufferem je na tomto místì vhodné zmínit i tøídu
<strong>java.awt.image.VolatileImage</strong> slou¾ící k&nbsp;ulo¾ení bitmapy
v&nbsp;obrazové pamìti s&nbsp;tím, ¾e obsah této bitmapy mù¾e (grafický) systém
kdykoli zmìnit (pøesnìji øeèeno po¹kodit), co¾ znamená nutnost jeho následné
obnovy. Mohlo by se mo¾ná zdát, ¾e tato tøída nebude mít oproti
<strong>BufferedImage</strong> ¾ádnou výhodu, nebo» programátorovi spí¹ pøidává
starosti, ov¹em v&nbsp;nìkterých pøípadech je mo¾né
<strong>VolatileImage</strong> s&nbsp;výhodou vyu¾ít, napøíklad pøi
programování animací atd. Podrobnìji se s&nbsp;touto zajímavou problematikou
seznámíme pøí¹tì.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Zji¹tìní informací o nainstalovaných grafických kartách</h2>

<p><a href="#k01">V&nbsp;pøedchozí kapitole</a> jsme si øekli, ¾e rozhraní pro
práci s&nbsp;exkluzivními celoobrazovkovými grafickými re¾imy nabízí
v&nbsp;první øadì metody pro zji¹tìní, které re¾imy lze vùbec na daném poèítaèi
vyu¾ít. K&nbsp;získání tìchto informací je nutné pou¾ít nìkolik tøíd. První
tøídou, kterou ná¹ popis zaène, je tøída <a
href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html">java.awt.GraphicsEnvironment</a>,
která programátorùm vrací informace o mo¾nostech a konfiguraci grafického
prostøedí Javy. Tato abstraktní tøída obsahuje pøedev¹ím statickou metodu
<strong>getLocalGraphicsEnvironment()</strong> vracející jednu konkrétní
instanci této tøídy. To znamená, ¾e bì¾ným zpùsobem získání instance této tøídy
není volání konstruktoru (ten má modifikátor <strong>protected</strong>, tudí¾
ho ve skuteènosti ani volat nelze), ale následující pøíkaz:</p>

<pre>
GraphicsEnvironment graphicsEnvironment = GraphicsEnvironment.getLocalGraphicsEnvironment();
</pre>

<p>Jakmile jsme získali konkrétní instanci tøídy
<strong>GraphicsEnvironment</strong>, je mo¾né napøíklad zjistit v¹echny
pou¾itelné fonty atd. Nás bude ale zajímat pøedev¹ím informace o grafických
re¾imech. Nejprve je nutné zjistit, jaké grafické karty jsou v&nbsp;systému
nainstalovány. To zajistí následující pøíkaz vracející pole objektù typu <a
href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html">java.awt.GraphicsDevice</a>:</p>

<pre>
GraphicsDevice[] graphicsDevices = graphicsEnvironment.getScreenDevices();
</pre>

<p>O ka¾dé grafické kartì vrácené v&nbsp;poli mù¾eme získat podrobnìj¹í
informace s&nbsp;vyu¾itím metod:</p>

<table>
<tr><th>Metoda</th><th>Popis</th></tr>
<tr><td>GraphicsDevice.getAvailableAcceleratedMemory()</td><td>volná pamì» pro alokaci bitmap, mnohdy vrací -1==nelze zjistit</td></tr>
<tr><td>GraphicsDevice.isDisplayChangeSupported()</td><td>hodnota <i>true</i> kdy¾ je podporována zmìna grafického re¾imu, popí¹eme si ní¾e, kdy lze volat</td></tr>
<tr><td>GraphicsDevice.isFullScreenSuported()</td><td>hodnota <i>true</i> kdy¾ lze zapnout vybraný celoobrazovkový re¾im</td></tr>
<tr><td>GraphicsDevice.getType()</td><td>typ zaøízení: mìla by se vrátit hodnota <strong>TYPE_RASTER_SCREEN</strong></td></tr>
<tr><td>GraphicsDevice.getIDstring()</td><td>øetìzec s&nbsp;identifikátorem grafické karty (li¹í se podle systému i JDK, obecnì nepøenositelný údaj)</td></tr>
</table>

<p>Od JDK verze 1.7 lze navíc zjistit, zda je podporována prùhlednost a/nebo
prùsvitnost pixelù. V&nbsp;závislosti na mo¾nostech grafické karty je mo¾né
pracovat s&nbsp;plnì prùhlednými èi naopak plnì neprùhlednými pixely
(<strong>WindowTranslucency.PERPIXEL_TRANSPARENT</strong>), bitmapou èi oknem
se zadanou prùhledností (<strong>WindowTranslucency.TRANSLUCENT</strong>) èi
dokonce s&nbsp;pixely, z&nbsp;nich¾ ka¾dý mù¾e mít nastavenou jinou úroveò
prùhlednosti <strong>WindowTranslucency.PERPIXEL_TRANSLUCENT</strong>). Tato
poslední mo¾nost je nejpomalej¹í, tak¾e se v&nbsp;mnoha hrách stejnì vyu¾ívají
pouze bitmapy/okna s&nbsp;plnì prùhlednými a plnì neprùhlednými pixely
(<strong>WindowTranslucency.TRANSLUCENT</strong>):</p>

<table>
<tr><th>Metoda</th><th>Popis</th></tr>
<tr><td>GraphicsDevice.isWindowTranslucencySupported(WindowTranslucency.PERPIXEL_TRANSPARENT</td><td>plnì prùhledné/neprùhledné pixely</td></tr>
<tr><td>GraphicsDevice.isWindowTranslucencySupported(WindowTranslucency.TRANSLUCENT</td><td>prùhlednost nastavená pro celou bitmapu/okno</td></tr>
<tr><td>GraphicsDevice.isWindowTranslucencySupported(WindowTranslucency.PERPIXEL_TRANSLUCENT</td><td>prùhlednost nastavená pro jednotlivé pixely</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zji¹tìní informací o v¹ech dostupných grafických re¾imech</h2>

<p>Pro pøeètení informací o v¹ech grafických re¾imech nabízených a
podporovaných vybranou grafickou kartou se pou¾ívá metoda
<strong>GraphicsDevice.getDisplayModes()</strong>. Tato metoda vrací pole
objektù typu <a
href="http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html">java.awt.DisplayMode</a>,
co¾ znamená, ¾e v¹echny dostupné grafické re¾imy získáme pøíkazem:</p>

<pre>
DisplayMode[] modes = graphicsDevice.getDisplayModes();
</pre>

<p>Pro ka¾dý grafický re¾im lze pøeèíst tøi základní informace: rozli¹ení
(horizontální a vertikální poèet pixelù), bitovou hloubku a
obnovovací/snímkovou frekvenci. Kupodivu ji¾ nelze pøeèíst dal¹í informace,
napøíklad o formátu ulo¾ení pixelù v&nbsp;obrazové pamìti, skuteènou délku
obrazového øádku atd. Navíc se v&nbsp;nìkterých pøípadech kvùli omezení
mo¾ností grafického subsystému namísto skuteèné bitové hloubky vrací hodnota -1
(jde o celoèíselnou konstantu <strong>DisplayMode.BIT_DEPTH_MULTI</strong>).
Podobnì tomu je i v&nbsp;pøípadì frekvence, kdy na nìkterých systémech
dostaneme namísto údaje v&nbsp;hertzích (jde o celoèíselnou a tudí¾ mnohdy
nepøesnou hodnotu) pouze nulovou konstantu
(odpovídající <strong>DisplayMode.REFRESH_RATE_UNKNOWN</strong>):</p>

<table>
<tr><th>Metoda</th><th>Popis</th></tr>
<tr><td>DisplayMode.getWidth()</td><td>horizontální rozli¹ení grafického re¾imu (poèet viditelných pixelù na øádku)</td></tr>
<tr><td>DisplayMode.getHeight()</td><td>vertikální rozli¹ení grafického re¾imu (poèet viditelných obrazových øádkù)</td></tr>
<tr><td>DisplayMode.getBitDepth()</td><td>bitová hloubka popø.&nbsp;konstanta <strong>DisplayMode.BIT_DEPTH_MULTI</strong></td></tr>
<tr><td>DisplayMode.getRefreshRate()</td><td>snímková frekvence popø.&nbsp;konstanta <strong>DisplayMode.REFRESH_RATE_UNKNOWN</strong></td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. První demonstraèní pøíklad: výpis informací o v¹ech dostupných grafických re¾imech</h2>

<p>V¹echny tøídy a metody popsané <a href="#k02">ve druhé</a> i <a
href="#k03">ve tøetí</a> kapitole jsou vyu¾ity v&nbsp;dne¹ním prvním
demonstraèním pøíkladu, který po svém spu¹tìní vypí¹e na standardní výstup
základní informace o grafické konfiguraci i o dostupných grafických re¾imech.
Tento pøíklad je pøelo¾itelný na JDK7, v&nbsp;pøípadì pou¾ití star¹ích JDK (od
verze 1.4) se v¹ak budou hlásit chyby z&nbsp;toho dùvodu, ¾e tøída
<strong>java.awt.GraphicsDevice.WindowTranslucency</strong> není viditelná
(resp.&nbsp;nemá modifikátor <strong>public</strong>). V&nbsp;tomto pøípadì je
nutné jak odstranit pøíslu¹ný import, tak i trojici øádkù zji¹»ujících
dostupnost operací pro práci s&nbsp;prùhlednými èi prùsvitnými pixely:</p>

<pre>
import java.awt.DisplayMode;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.GraphicsDevice.WindowTranslucency;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Vypis zakladnich vlastnosti grafickych zarizeni, ktere lze vyuzit primo</i>
<i> * z Javy.</i>
<i> */</i>
public class <strong>GraphicsDevicesTest</strong> {
&nbsp;
<i>    /**</i>
<i>     * Vstupni bod do tohoto testu.</i>
<i>     */</i>
    public static void <strong>main</strong>(String[] args) {
        GraphicsDevice[] graphicsDevices = getScreenGraphicsDevices();
        printInfoAboutEachGraphicsDevice(graphicsDevices);
    }
&nbsp;
<i>    /**</i>
<i>     * Ziska pole se vsemi dostupnymi grafickymi zarizenimi.</i>
<i>     *</i>
<i>     * @return pole se vsemi dostupnymi grafickymi zarizenimi</i>
<i>     */</i>
    private static GraphicsDevice[] <strong>getScreenGraphicsDevices</strong>() {
        GraphicsEnvironment graphicsEnvironment = GraphicsEnvironment.getLocalGraphicsEnvironment();
        GraphicsDevice[] graphicsDevices = graphicsEnvironment.getScreenDevices();
        return graphicsDevices;
    }
&nbsp;
<i>    /**</i>
<i>     * Vypise informaci o vsech grafickych zarizenich predanych v parametru</i>
<i>     * graphicsDevices.</i>
<i>     *</i>
<i>     * @param graphicsDevices</i>
<i>     *            pole se vsemi dostupnymi grafickymi zarizenimi</i>
<i>     */</i>
    private static void <strong>printInfoAboutEachGraphicsDevice</strong>(GraphicsDevice[] graphicsDevices) {
        for (int j = 0; j &lt; graphicsDevices.length; j++) { 
           GraphicsDevice graphicsDevice = graphicsDevices[j];
           printGraphicsDeviceInfo(graphicsDevice);
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Vypise informaci o grafickem zarizeni predanem v parametru</i>
<i>     * graphicsDevice.</i>
<i>     *</i>
<i>     * @param graphicsDevice</i>
<i>     *            objekt reprezentujici dostupne graficke zarizeni.</i>
<i>     */</i>
    private static void <strong>printGraphicsDeviceInfo</strong>(GraphicsDevice graphicsDevice) {
        System.out.println("Device ID: " + graphicsDevice.getIDstring());
        System.out.println("Type:      " + getDeviceType(graphicsDevice));
        System.out.println("Accelerated memory size:  " + graphicsDevice.getAvailableAcceleratedMemory());
        System.out.println("Display change supported: " + graphicsDevice.isDisplayChangeSupported());
        System.out.println("Full screen supported:    " + graphicsDevice.isFullScreenSupported());
        System.out.println("Transparency/translucency support:");
        System.out.println("    Per pixel transparency:  " + graphicsDevice.isWindowTranslucencySupported(WindowTranslucency.PERPIXEL_TRANSPARENT));
        System.out.println("    Per pixel translucency:  " + graphicsDevice.isWindowTranslucencySupported(WindowTranslucency.PERPIXEL_TRANSLUCENT));
        System.out.println("    Per window translucency: " + graphicsDevice.isWindowTranslucencySupported(WindowTranslucency.TRANSLUCENT));
        System.out.println("Graphics modes:");
        DisplayMode[] modes = graphicsDevice.getDisplayModes();
        printAvailableDisplayModes(modes);
        System.out.println();
    }
&nbsp;
<i>    /**</i>
<i>     * Vrati typ grafickeho zarizeni.</i>
<i>     *</i>
<i>     * @param graphicsDevice</i>
<i>     *            objekt reprezentujici dostupne graficke zarizeni.</i>
<i>     * @return typ zarizeni (textova reprezentace)</i>
<i>     */</i>
    private static String <strong>getDeviceType</strong>(GraphicsDevice graphicsDevice) {
        switch (graphicsDevice.getType()) {
        case GraphicsDevice.TYPE_RASTER_SCREEN:
            return "raster screen";
        case GraphicsDevice.TYPE_PRINTER:
            return "printer";
        case GraphicsDevice.TYPE_IMAGE_BUFFER:
            return "image buffer";
        default: // nemelo by nastat
            return "???";
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Vypise dostupne graficke rezimy a jejich zakladni vlastnosti.</i>
<i>     *</i>
<i>     * @param modes pole s grafickymi rezimy pro dane zarizeni.</i>
<i>     */</i>
    private static void <strong>printAvailableDisplayModes</strong>(DisplayMode[] modes) {
        for (DisplayMode mode : modes) {
            final int width = mode.getWidth();
            final int height = mode. getHeight();
            final int bpp = mode.getBitDepth();
            final int refreshRate = mode.getRefreshRate();
            System.out.println("    " +
                    width + "x" + height +
                    "@" + bpp + " bpp\t(" + refreshRate + " Hz)");
        }
    }
&nbsp;
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Ukázky výstupu prvního demonstraèního pøíkladu</h2>

<p>Podívejme se nyní na výsledky získané po spu¹tìní dne¹ního prvního
demonstraèního pøíkladu na nìkolika poèítaèích vybavených rùznými operaèními
systémy a samozøejmì i rozdílnými grafickými kartami. Prvním poèítaèem je
starobylý (více ne¾ desetiletý) notebook s&nbsp;Oracle JDK7 a neaktualizovaným
:-) systémem Microsoft Windows XP vybavený èipsetem Intel 855 GME. Jak je
z&nbsp;následujícího výpisu patrné, je maximální dostupné rozli¹ení nabízených
grafických re¾imù v&nbsp;tomto pøípadì limitováno fyzickým rozli¹ením displeje
tohoto notebooku (1024&times;768 pixelù), stejnì tak i maximální snímková
frekvence (70 Hz):</p>

<pre>
Device ID: \Display0
Type:      raster screen
Accelerated memory size:  -1
Display change supported: false
Full screen supported:    true
Transparency/translucency support:
    Per pixel transparency:  true
    Per pixel translucency:  true
    Per window translucency: true
Graphics modes:
    320x200@8 bpp       (70 Hz)
    320x200@16 bpp      (70 Hz)
    320x200@32 bpp      (70 Hz)
    320x240@8 bpp       (70 Hz)
    320x240@16 bpp      (70 Hz)
    320x240@32 bpp      (70 Hz)
    400x300@8 bpp       (70 Hz)
    400x300@16 bpp      (70 Hz)
    400x300@32 bpp      (70 Hz)
    512x384@8 bpp       (70 Hz)
    512x384@16 bpp      (70 Hz)
    512x384@32 bpp      (70 Hz)
    640x480@8 bpp       (60 Hz)
    640x400@8 bpp       (70 Hz)
    800x600@8 bpp       (60 Hz)
    1024x768@8 bpp      (60 Hz)
    640x480@16 bpp      (60 Hz)
    800x600@16 bpp      (60 Hz)
    1024x768@16 bpp     (60 Hz)
    640x480@32 bpp      (60 Hz)
    800x600@32 bpp      (60 Hz)
    1024x768@32 bpp     (60 Hz)
    640x400@16 bpp      (70 Hz)
    640x400@32 bpp      (70 Hz)
</pre>

<p>Zajímavé je, ¾e v&nbsp;nìkterých pøípadech (typicky na Linuxu s&nbsp;X
Window) se nevrátí kompletní informace o podporovaných grafických re¾imech,
popø.&nbsp;se vrátí obecnìj¹í informace, ne¾ jakou by programátor mnohdy
potøeboval znát. V&nbsp;následujícím pøíkladu se napøíklad nevrátila pøesná
informace o bitové hloubce, ale hodnota -1, která odpovídá ji¾ vý¹e zmínìné
konstantì <strong>BIT_DEPTH_MULTI</strong>. Jedná se o OpenJDK7 spu¹tìné na
Fedoøe 19:</p>

<pre>
Device ID: :0.0
Type:      raster screen
Accelerated memory size:  -1
Display change supported: false
Full screen supported:    true
Transparency/translucency support:
    Per pixel transparency:  true
    Per pixel translucency:  true
    Per window translucency: true
Graphics modes:
    1366x768@-1 bpp     (60 Hz)
    1024x768@-1 bpp     (60 Hz)
    800x600@-1 bpp      (60 Hz)
    800x600@-1 bpp      (56 Hz)
    640x480@-1 bpp      (60 Hz)
</pre>

<p>Mnohé grafické karty nabízí v&nbsp;kombinaci se správným typem monitoru
mnohem vìt¹í mno¾ství grafických re¾imù, od re¾imù s&nbsp;nízkým rozli¹ením,
které dnes mají spí¹e historický význam (ale mù¾e je vyu¾ít napøíklad DOSBox),
a¾ po re¾imy se støedním a vysokým (HD) rozli¹ením. Pov¹imnìte si, ¾e nìkteré
grafické re¾imy jsou nabízeny ve více variantách, které se li¹í barevnou
hloubkou a/nebo obnovovací frekvencí (OpenJDK6 na Debianu a Ubuntu):</p>

<pre>
Device ID: :0.0
Type:      raster screen
Accelerated memory size:  -1
Display change supported: false
Full screen supported:    true
Transparency/translucency support:
Graphics modes:
    1280x1024@-1 bpp    (50 Hz)
    1280x1024@-1 bpp    (51 Hz)
    1280x960@-1 bpp     (52 Hz)
    1152x864@-1 bpp     (53 Hz)
    1152x864@-1 bpp     (54 Hz)
    1152x864@-1 bpp     (55 Hz)
    1152x864@-1 bpp     (56 Hz)
    1024x768@-1 bpp     (57 Hz)
    1024x768@-1 bpp     (58 Hz)
    1024x768@-1 bpp     (59 Hz)
    960x600@-1 bpp      (60 Hz)
    960x540@-1 bpp      (61 Hz)
    840x525@-1 bpp      (62 Hz)
    840x525@-1 bpp      (63 Hz)
    840x525@-1 bpp      (64 Hz)
    832x624@-1 bpp      (65 Hz)
    800x600@-1 bpp      (66 Hz)
    800x600@-1 bpp      (67 Hz)
    800x600@-1 bpp      (68 Hz)
    800x600@-1 bpp      (69 Hz)
    800x600@-1 bpp      (70 Hz)
    800x600@-1 bpp      (71 Hz)
    800x512@-1 bpp      (72 Hz)
    720x450@-1 bpp      (73 Hz)
    680x384@-1 bpp      (74 Hz)
    680x384@-1 bpp      (75 Hz)
    640x512@-1 bpp      (76 Hz)
    640x512@-1 bpp      (77 Hz)
    640x480@-1 bpp      (78 Hz)
    640x480@-1 bpp      (79 Hz)
    640x480@-1 bpp      (80 Hz)
    640x480@-1 bpp      (81 Hz)
    576x432@-1 bpp      (82 Hz)
    576x432@-1 bpp      (83 Hz)
    576x432@-1 bpp      (84 Hz)
    576x432@-1 bpp      (85 Hz)
    512x384@-1 bpp      (86 Hz)
    512x384@-1 bpp      (87 Hz)
    512x384@-1 bpp      (88 Hz)
    416x312@-1 bpp      (89 Hz)
    400x300@-1 bpp      (90 Hz)
    400x300@-1 bpp      (91 Hz)
    400x300@-1 bpp      (92 Hz)
    400x300@-1 bpp      (93 Hz)
    320x240@-1 bpp      (94 Hz)
    320x240@-1 bpp      (95 Hz)
    320x240@-1 bpp      (96 Hz)
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Nastavení celoobrazovkového grafického re¾imu</h2>

<p>Pozorné ètenáøe pravdìpodobnì pøekvapilo, ¾e na v¹ech tøech testovaných
poèítaèích zobrazil dne¹ní první demonstraèní pøíklad zprávu:</p>

<pre>
Display change supported: false
</pre>

<p>Tato zpráva vlastnì znamená, ¾e dané grafické zaøízení (grafická karta)
zdánlivì nepodporuje pøepínání a nastavování celoobrazovkových grafických
re¾imù, co¾ je zajisté podivné, proto¾e tuto funkci provádí prakticky ka¾dá
hra. Ve skuteènosti je ale chování metody
<strong>GraphicsDevice.isDisplayChangeSupported()</strong> závislé na tom, zda
je nastaven celoobrazovkový re¾im èi nikoli. Pokud celoobrazovkový re¾im
nastavený není (co¾ je výchozí konfigurace), vrací metoda
<strong>GraphicsDevice.isDisplayChangeSupported()</strong> hodnotu
<i>false</i>, nezávisle na skuteèných mo¾nostech grafického akcelerátoru.
Celoobrazovkový re¾im se nastavuje (resp.&nbsp;povoluje) metodou
<strong>GraphicsDevice.setFullScreenWindow()</strong>, které se musí pøedat
objekt typu <strong>java.awt.Window</strong>, co¾ je typicky instance tøídy
<strong>java.awt.Frame</strong>. Toto okno/rámec následnì získá rozmìry
grafického re¾imu, který bude mo¾né následnì pøepnout:</p>

<pre>
Frame frame = new Frame();
graphicsDevice.setFullScreenWindow(frame);
graphicsDevice.setDisplayMode(selectedDisplayMode);
</pre>

<p>Celoobrazovkový re¾im je následnì mo¾né vypnout opìtovným zavoláním metody
<strong>GraphicsDevice.setFullScreenWindow()</strong>, tentokrát se ov¹em
namísto objektu typu <strong>java.awt.Window</strong> pøedává hodnota
<strong>null</strong>:</p>

<pre>
graphicsDevice.setFullScreenWindow(null);
</pre>

<p>Shròme si nyní, jaké metody je nutné pou¾ít pro nastavení popø.&nbsp;pro
vypnutí vybraného grafického celoobrazovkového re¾imu:</p>

<table>
<tr><th>Metoda</th><th>Popis</th></tr>
<tr><td>GraphicsDevice.setFullScreenWindow(Window)</td><td>povolení celoobrazovkového re¾imu</td></tr>
<tr><td>GraphicsDevice.setFullScreenWindow(null)</td><td>vypnutí celoobrazovkového re¾imu</td></tr>
<tr><td>GraphicsDevice.setDisplayMode(DisplayMode)</td><td>nastavení grafického re¾imu</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Druhý demonstraèní pøíklad: postupné nastavení v¹ech dostupných celoobrazovkových grafických re¾imù</h2>

<p>Metody <strong>GraphicsDevice.setFullScreenWindow()</strong> a
<strong>GraphicsDevice.setDisplayMode()</strong> jsou vyu¾ity v&nbsp;dne¹ním
druhém (a souèasnì i posledním :-) demonstraèním pøíkladu. Po spu¹tìní tohoto
pøíkladu se opìt získají v¹echny nainstalované grafické karty a pro ka¾dou
kartu se následnì pøeètou dostupné grafické re¾imy. Následnì je ka¾dý re¾im na
chvíli (konkrétnì na pìt sekund, aby se mohl ustálit monitor) nastaven a na
obrazovku se vypí¹ou základní údaje o tomto re¾imu &ndash; rozli¹ení, bitová
hloubka, velikost obrazové pamìti (vìt¹inou v¹ak -1). Pov¹imnìte si, ¾e ve
v¹ech re¾imech je pou¾it stejný objekt typu <strong>Frame</strong>
s&nbsp;textem umístìným uprostøed:</p>

<pre>
import java.awt.Color;
import java.awt.Frame;
import java.awt.Font;
import java.awt.Label;
import java.awt.DisplayMode;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Ukazka, jakym zpusobem lze nastavit graficke rezimy.</i>
<i> */</i>
public class <strong>GraphicsModesTest</strong> {
&nbsp;
<i>    /**</i>
<i>     * Vstupni bod do tohoto testu.</i>
<i>     */</i>
    public static void <strong>main</strong>(String[] args) {
        GraphicsDevice[] graphicsDevices = getScreenGraphicsDevices();
        printInfoAboutEachGraphicsDevice(graphicsDevices);
    }
&nbsp;
<i>    /**</i>
<i>     * Ziska pole se vsemi dostupnymi grafickymi zarizenimi.</i>
<i>     *</i>
<i>     * @return pole se vsemi dostupnymi grafickymi zarizenimi</i>
<i>     */</i>
    private static GraphicsDevice[] <strong>getScreenGraphicsDevices</strong>() {
        GraphicsEnvironment graphicsEnvironment = GraphicsEnvironment.getLocalGraphicsEnvironment();
        GraphicsDevice[] graphicsDevices = graphicsEnvironment.getScreenDevices();
        return graphicsDevices;
    }
&nbsp;
<i>    /**</i>
<i>     * Vypise informaci o vsech grafickych zarizenich predanych v parametru</i>
<i>     * graphicsDevices.</i>
<i>     *</i>
<i>     * @param graphicsDevices</i>
<i>     *            pole se vsemi dostupnymi grafickymi zarizenimi</i>
<i>     */</i>
    private static void <strong>printInfoAboutEachGraphicsDevice</strong>(GraphicsDevice[] graphicsDevices) {
        for (int j = 0; j &lt; graphicsDevices.length; j++) { 
           GraphicsDevice graphicsDevice = graphicsDevices[j];
           printGraphicsDeviceInfo(graphicsDevice);
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Vypise informaci o grafickem zarizeni predanem v parametru</i>
<i>     * graphicsDevice.</i>
<i>     *</i>
<i>     * @param graphicsDevice</i>
<i>     *            objekt reprezentujici dostupne graficke zarizeni.</i>
<i>     */</i>
    private static void <strong>printGraphicsDeviceInfo</strong>(GraphicsDevice graphicsDevice) {
        System.out.println("Device ID: " + graphicsDevice.getIDstring());
        System.out.println("Type:      " + getDeviceType(graphicsDevice));
        System.out.println("Accelerated memory size:  " + graphicsDevice.getAvailableAcceleratedMemory());
        System.out.println("Display change supported: " + graphicsDevice.isDisplayChangeSupported());
        System.out.println("Full screen supported:    " + graphicsDevice.isFullScreenSupported());
        System.out.println("Transparency/translucency support:");
        System.out.println("Graphics modes:");
        DisplayMode[] modes = graphicsDevice.getDisplayModes();
        tryToSetDisplayModes(graphicsDevice, modes);
        System.out.println();
    }
&nbsp;
<i>    /**</i>
<i>     * Vrati typ grafickeho zarizeni.</i>
<i>     *</i>
<i>     * @param graphicsDevice</i>
<i>     *            objekt reprezentujici dostupne graficke zarizeni.</i>
<i>     * @return typ zarizeni (textova reprezentace)</i>
<i>     */</i>
    private static String <strong>getDeviceType</strong>(GraphicsDevice graphicsDevice) {
        switch (graphicsDevice.getType()) {
        case GraphicsDevice.TYPE_RASTER_SCREEN:
            return "raster screen";
        case GraphicsDevice.TYPE_PRINTER:
            return "printer";
        case GraphicsDevice.TYPE_IMAGE_BUFFER:
            return "image buffer";
        default: // nemelo by nastat
            return "???";
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Pokusi se nastavit vsechny graficke rezimy.</i>
<i>     *</i>
<i>     * @param modes pole s grafickymi rezimy pro dane zarizeni.</i>
<i>     */</i>
    private static void <strong>tryToSetDisplayModes</strong>(GraphicsDevice device, DisplayMode[] modes) {
        // Frame bude pouzit ve fullscreen rezimu.
        Frame frame = new Frame();
&nbsp;
<i>        // Vypis informaci o rezimu bude provaden pres label primo na ramec.</i>
        Label label = new Label("");
        label.setFont(new Font(Font.DIALOG, Font.BOLD, 24)); // zmensit font pro rezim &lt;400x300 pixelu!!!
        label.setAlignment(Label.CENTER);
        frame.add(label);
&nbsp;
<i>        // projit vsemi rezimy</i>
        for (DisplayMode mode : modes) {
<i>            // zjistit informace o rezimu</i>
            final int width = mode.getWidth();
            final int height = mode. getHeight();
            final int bpp = mode.getBitDepth();
            final int refreshRate = mode.getRefreshRate();
<i>            // nastavit fullscreen rezim</i>
            device.setFullScreenWindow(frame);
            device.setDisplayMode(mode);
<i>            // a vypsat o nem informace</i>
            System.out.println("Display change supported in FS mode: " + device.isDisplayChangeSupported());
            label.setText("Mode: " + width + "x" + height + "@" + bpp + " bpp\t(" + refreshRate + " Hz)");
            try {
                Thread.sleep(5000);
            }
            catch (Exception e) {
            }
<i>            // zruseni fullscreen rezimu a navrat do "okenniho" rezimu</i>
            device.setFullScreenWindow(null);
        }
    }
&nbsp;
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Problematika tvorby a vykreslování bitmap podruhé</h2>

<p>Jakmile je grafický re¾im nastaven, lze jednodu¹e provádìt vykreslování do
okna èi rámce nastaveného metodou
<strong>GraphicsDevice.setFullScreenWindow()</strong>, a to stejným zpùsobem,
jakoby se jednalo o bì¾né okno. Typicky se v¹ak neprovádí ¾ádné vysokoúrovòové
operace typu vykreslování tvarù (Shape) s&nbsp;oøezáváním èi aplikací afinních
transformací. Mnoho 2D her se spokojí s&nbsp;vykreslováním bitmap a zde se
dostáváme k&nbsp;problematice zmínìné ji¾ minule &ndash; aby bylo vykreslování
bitmap co nejrychlej¹í a k&nbsp;tomu je¹tì provádìné grafickým akcelerátorem,
je vìt¹inou vy¾adováno, aby byl formát tìchto bitmap shodný s&nbsp;formátem
framebufferu. Toho nelze (obecnì) dosáhnout pomocí konstruktoru <strong>new
BufferedImage(width, height, type)</strong>, ale je nutné pou¾ít jiné metody,
konkrétnì metody nabízené tøídou <a
href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html">java.awt.GraphicsConfiguration</a>.</p>

<p>Tyto metody lze rozdìlit na dvì èásti &ndash; tvorbu instancí tøídy
<strong>BufferedImage</strong> a tvorbu instancí tøídy
<strong>VolatileImage</strong>:</p>

<table>
<tr><th>Metoda</th><th>Popis</th></tr>
<tr><td>GraphicsConfiguration.createCompatibleImage(int width, int height)</td><td>základní metoda pro vytvoøení bitmapy o zadaných rozmìrech</td></tr>
<tr><td>GraphicsConfiguration.createCompatibleImage(int width, int height, int transparency)</td><td>dtto ale s&nbsp;volbou, jak se má reprezentovat prùhlednost/prùsvitnost</td></tr>
<tr><td>GraphicsConfiguration.createCompatibleVolatileImage(int width, int height)</td><td>základní zpùsob vytvoøení bitmapy typu <strong>VolatileImage</strong></td></tr>
<tr><td>GraphicsConfiguration.createCompatibleVolatileImage(int width, int height, int transparency)</td><td>dtto, navíc volba reprezentace prùhlednosti/prùsvitnosti</td></tr>
<tr><td>GraphicsConfiguration.createCompatibleVolatileImage(int width, int height, ImageCapabilities caps)</td><td>specifikace dal¹ích parametrù (popí¹eme pøí¹tì)</td></tr>
<tr><td>GraphicsConfiguration.createCompatibleVolatileImage(int width, int height, ImageCapabilities caps, int transparency)</td><td>dtto, navíc volba reprezentace prùhlednosti/prùsvitnosti</td></tr>
</table>

<p>Volba správného typu bitmapy pro vykreslování mù¾e velmi významnì ovlivnit
výkonnost celé aplikace, tak¾e je nutné parametry bitmapy volit takovým
zpùsobem, aby bylo dosa¾eno po¾adované funkcionality (napøíklad vykreslování
spritù), ov¹em aby grafický subsystém nemusel provádìt zbyteèné operace
(prùhlednost specifikovaná zvlá¹» pro ka¾dý pixel atd. atd.).</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Repositáø se zdrojovými soubory obou demonstraèních pøíkladù</h2>

<p>Následují ji¾ tradièní odkazy na zdrojové kódy ulo¾ené do Mercurial
repositáøe. V&nbsp;následující tabulce najdete linky na prozatím nejnovìj¹í
verzi obou dnes popsaných demonstraèních pøíkladù pro zji¹tìní a nastavení
v¹ech dostupných grafických re¾imù:</p>

<table>
<tr><th>#</th><th>Zdrojový soubor/skript</th><th>Umístìní souboru v&nbsp;repositáøi</th></tr>
<tr><td>1</td><td>GraphicsDevicesTest.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f6d21d14f927/jvm/gfx/GraphicsDevicesTest.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f6d21d14f927/jvm/gfx/GraphicsDevicesTest.java</a></td></tr>
<tr><td>2</td><td>GraphicsModesTest.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f6d21d14f927/jvm/gfx/GraphicsModesTest.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/f6d21d14f927/jvm/gfx/GraphicsModesTest.java</a></td></tr>
</table>



<p><a name="k10"></a></p>
<h2 id="k10">10. Odkazy na Internetu</h2>

<ol>

<li>Javadoc - tøída GraphicsDevice<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html</a>
</li>

<li>Javadoc - tøída GraphicsEnvironment<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html</a>
</li>

<li>Javadoc - tøída GraphicsConfiguration<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html</a>
</li>

<li>Javadoc - tøída DisplayMode<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html">http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html</a>
</li>

<li>Lesson: Full-Screen Exclusive Mode API<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/">http://docs.oracle.com/javase/tutorial/extra/fullscreen/</a>
</li>

<li>Full-Screen Exclusive Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html</a>
</li>

<li>Display Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html</a>
</li>

<li>Using the Full-Screen Exclusive Mode API in Java<br />
<a href="http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm">http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>GC safe-point (or safepoint) and safe-region<br />
<a href="http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html">http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html</a>
</li>

<li>Safepoints in HotSpot JVM<br />
<a href="http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html">http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html</a>
</li>

<li>Java theory and practice: Synchronization optimizations in Mustang<br />
<a href="http://www.ibm.com/developerworks/java/library/j-jtp10185/">http://www.ibm.com/developerworks/java/library/j-jtp10185/</a>
</li>

<li>How to build hsdis<br />
<a href="http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README">http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README</a>
</li>

<li>Java SE 6 Performance White Paper<br />
<a href="http://www.oracle.com/technetwork/java/6-performance-137236.html">http://www.oracle.com/technetwork/java/6-performance-137236.html</a>
</li>

<li>Lukas Stadler's Blog<br />
<a href="http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html">http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html</a>
</li>

<li>How to build hsdis-amd64.dll and hsdis-i386.dll on Windows<br />
<a href="http://dropzone.nfshost.com/hsdis.htm">http://dropzone.nfshost.com/hsdis.htm</a>
</li>

<li>PrintAssembly<br />
<a href="https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly">https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly</a>
</li>

<li>The Java Virtual Machine Specification: 3.14. Synchronization<br />
<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14</a>
</li>

<li>The Java Virtual Machine Specification: 8.3.1.4. volatile Fields<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.4. Memory Model<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.7. Non-atomic Treatment of double and long<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7</a>
</li>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (pøed verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

