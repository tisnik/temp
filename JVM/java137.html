<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - slo¾ené datové typy a programová smyèka typu for-each v JVM, Lua VM a Python VM</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - slo¾ené datové typy a programová smyèka typu for-each v JVM, Lua VM a Python VM</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o JVM i o programovacím jazyku Java si øekneme, jakým zpùsobem se do bajtkódu virtuálního stroje Javy pøekládá programová smyèka typu &bdquo;for-each&ldquo;. Pou¾ití této smyèky si uká¾eme na ètveøici demonstraèních pøíkladù vyu¾ívajících pole, seznamy, mno¾iny i mapy.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - slo¾ené datové typy a programová smyèka typu &bdquo;for-each&ldquo; v JVM, Lua VM a Python VM</a></p>
<p><a href="#k02">2. Programová smyèka typu &bdquo;for-each&ldquo; v&nbsp;programovacím jazyku Java</a></p>
<p><a href="#k03">3. Demonstraèní pøíklad <strong>Test23.java</strong>: pole a smyèka typu &bdquo;for-each&ldquo; v&nbsp;JVM</a></p>
<p><a href="#k04">4. Okomentovaný bajtkód demonstraèního pøíkladu <strong>Test23.java</strong></a></p>
<p><a href="#k05">5. Demonstraèní pøíklad <strong>Test24.java</strong>: seznamy a programová smyèka typu &bdquo;for-each&ldquo; v&nbsp;JVM</a></p>
<p><a href="#k06">6. Okomentovaný bajtkód demonstraèního pøíkladu <strong>Test24.java</strong></a></p>
<p><a href="#k07">7. Demonstraèní pøíklad <strong>Test25.java</strong>: mno¾iny a programová smyèka typu &bdquo;for-each&ldquo; v&nbsp;JVM</a></p>
<p><a href="#k08">8. Okomentovaný bajtkód demonstraèního pøíkladu <strong>Test25.java</strong></a></p>
<p><a href="#k09">9. Demonstraèní pøíklad <strong>Test26.java</strong>: mapy a programová smyèka typu &bdquo;for-each&ldquo; v&nbsp;JVM</a></p>
<p><a href="#k10">10. Okomentovaný bajtkód demonstraèního pøíkladu <strong>Test26.java</strong></a></p>
<p><a href="#k11">11. Repositáø se zdrojovými kódy v¹ech ètyø dne¹ních demonstraèních pøíkladù</a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - slo¾ené datové typy a programová smyèka typu &bdquo;for-each&ldquo; v JVM, Lua VM a Python VM</h2>

<p>V&nbsp;pøedchozích dvou èástech <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyce Java i o JVM</a> jsme si øekli, jakým zpùsobem se do
bajtkódù virtuálních strojù Javy, Pythonu i jazyka Lua pøekládají základní
operace se slo¾enými datovými typy. Jedná se pøedev¹ím o operace pro ètení a
popø.&nbsp;i zápis prvkù slo¾ených datových typù (polí, tabulek, seznamù,
n-tic) a takté¾ o operaci získání celkového poètu prvkù daného slo¾eného
datového typu. V&nbsp;nìkterých demonstraèních pøíkladech jsme si takté¾
ukázali zpùsob pou¾ití poèítané programové smyèky typu <strong>for</strong> pøi
pøístupu k&nbsp;prvkùm slo¾ených datových typù. Ve skuteènosti se ov¹em velké
mno¾ství operací (pravdìpodobnì vìt¹ina operací) se slo¾enými datovými typy
neprovádí s&nbsp;vyu¾itím poèítané smyèky typu <strong>for</strong>, ale spí¹e
s&nbsp;pou¾itím smyèky typu <strong>for-each</strong>, která je v&nbsp;urèité
podobì implementována ve v¹ech tøech virtuálních strojích (JVM, Lua VM i Python
VM).</p>

<p>Dnes si na ètveøici demonstraèních pøíkladù uká¾eme, jakým zpùsobem se
programová smyèka typu <strong>for-each</strong> pou¾ívá a pøekládá
v&nbsp;Javì. V&nbsp;navazující èásti tohoto seriálu na dne¹ní díl navá¾eme,
proto¾e si uká¾eme ekvivalentní pøíklady, ov¹em naprogramované v&nbsp;Pythonu,
programovacím jazyce Lua a novì takté¾ v&nbsp;Perlu 6.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Programová smyèka typu &bdquo;for-each&ldquo; v&nbsp;programovacím jazyku Java</h2>

<p>Programová smyèka typu <strong>for-each</strong> se v&nbsp;programovacím
jazyku Java objevila ve verzi/specifikaci 5.0. Jednalo se o jedno
z&nbsp;nìkolika roz¹íøení tohoto jazyka, které bylo vy¾adováno jak komunitou
vývojáøù, tak i de facto vynuceno situací na trhu, na nìm¾ se zaèaly ve vìt¹í
míøe prosazovat konkurenèní programovací jazyky, pøedev¹ím C# a takté¾ dosti
velká skupina vysokoúrovòových skriptovacích jazykù (Python, Ruby, ...). Smyèku
typu <strong>for-each</strong> lze v&nbsp;Javì vyu¾ít pro postupné procházení
v¹ech prvkù polí. Syntaxe v&nbsp;tomto pøípadì vypadá následovnì:</p>

<pre>
for (type variable : array) {
    tìlo smyèky
}
</pre>

<p>Vý¹e uvedený zápis smyèky je do znaèné míry ekvivalentní poèítané smyèce
typu <strong>for</strong>, ov¹em s&nbsp;tím rozdílem, ¾e programátor nemá
v&nbsp;pøedchozí verzi smyèky pøístup k&nbsp;poèitadlu <strong>i</strong>
(hodnotu poèitadla lze vyu¾ít napøíklad pøi tvorbì tabulek atd.):</p>

<pre>
for (int i = 0; i &lt; array.length; i++) { 
    type variable = array[i];
    tìlo smyèky
}
</pre>

<p>Kromì polí je mo¾né programovou smyèku typu <strong>for-each</strong> pou¾ít
i pro procházení v¹emi prvky kolekcí. Zápis je v&nbsp;tomto pøípadì prakticky
shodný se zápisem smyèky pro prùchod v¹emi prvky pole:</p>

<pre>
for (type variable : collection) {
    tìlo smyèky
}
</pre>

<p>Tento zápis je ekvivalentní následujícímu zápisu; ov¹em opìt s&nbsp;tím
rozdílem, ¾e ve zkrácené <strong>for-each</strong> variantì nemá programátor
pøímý pøístup k&nbsp;iterátoru, co¾ mù¾e v&nbsp;nìkterých pøípadech komplikovat
zápis algoritmu:</p>

<pre>
for (Iterator&lt;type&gt; iterator = collection.iterator(); iterator.hasNext(); ) {
    type variable = iterator.next();
    tìlo smyèky
}
</pre>

<p>Ve skuteènosti se v¹ak pou¾ití smyèky <strong>for-each</strong> neomezuje
pouze na pole a kolekce, ale lze ji vyu¾ít pro instance v¹ech tøíd
implementujících rozhraní <strong>Iterable&lt;T&gt;</strong>, tj.&nbsp;pro ty
tøídy, v&nbsp;nich¾ je implementována metoda <strong>Iterator&lt;T&gt;
iterator()</strong>. Díky tomuto roz¹íøení sémantiky smyèky
<strong>for-each</strong> lze implementovat napøíklad rùzné typy prùchodù
binárními stromy atd.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Demonstraèní pøíklad <strong>Test23.java</strong>: pole a smyèka typu &bdquo;for-each&ldquo; v&nbsp;JVM</h2>

<p>Zpùsob pøekladu programové smyèky typu <strong>for-each</strong> do bajtkódu
JVM si nejlépe uká¾eme na nìkolika demonstraèních pøíkladech. V&nbsp;prvním
demonstraèním pøíkladu, který nese název <strong>Test23.java</strong>, je
implementována pøetí¾ená metoda <strong>sum()</strong>, v&nbsp;jejím¾ tìle se
vypoèítá suma/souèet v¹ech prvkù pole, které je do této metody pøedáno (jako
reference). Metoda je pøetí¾ená pro v¹ech ¹est primitivních numerických
datových typù &ndash; byte, short, int, long, float i double. Navíc je
v&nbsp;tomto pøíkladu implementována i metoda <strong>hashsum()</strong>,
v&nbsp;ní¾ se vypoète souèet he¹ovacích kódù v¹ech objektù ulo¾ených
v&nbsp;poli pøedaném do této metody. Ve v¹ech zmínìných metodách je vyu¾ita
smyèka typu <strong>for-each</strong> pro prùchod v¹emi prvky pole, nezávisle
na typu prvkù:</p>

<pre>
<i>/**</i>
<i> * Demonstracni priklad cislo 23.</i>
<i> *</i>
<i> * Pole a programova smycka typu for-each.</i>
<i> */</i>
public class <strong>Test23</strong> {
&nbsp;
    <i>/**</i>
    <i> * Vypocet souctu vsech prvku pole typu byte[].</i>
    <i> */</i>
    static int <strong>sum</strong>(byte[] array) {
        int sum = 0;
        for (byte item : array) {
            sum += item;
        }
        return sum;
    }
&nbsp;
    <i>/**</i>
    <i> * Vypocet souctu vsech prvku pole typu short[].</i>
    <i> */</i>
    static int <strong>sum</strong>(short[] array) {
        int sum = 0;
        for (short item : array) {
            sum += item;
        }
        return sum;
    }
&nbsp;
    <i>/**</i>
    <i> * Vypocet souctu vsech prvku pole typu int[].</i>
    <i> */</i>
    static int <strong>sum</strong>(int[] array) {
        int sum = 0;
        for (int item : array) {
            sum += item;
        }
        return sum;
    }
&nbsp;
    <i>/**</i>
    <i> * Vypocet souctu vsech prvku pole typu long[].</i>
    <i> */</i>
    static long <strong>sum</strong>(long[] array) {
        long sum = 0;
        for (long item : array) {
            sum += item;
        }
        return sum;
    }
&nbsp;
    <i>/**</i>
    <i> * Vypocet souctu vsech prvku pole typu float[].</i>
    <i> */</i>
    static float <strong>sum</strong>(float[] array) {
        float sum = 0;
        for (float item : array) {
            sum += item;
        }
        return sum;
    }
&nbsp;
    <i>/**</i>
    <i> * Vypocet souctu vsech prvku pole typu double[].</i>
    <i> */</i>
    static double <strong>sum</strong>(double[] array) {
        double sum = 0;
        for (double item : array) {
            sum += item;
        }
        return sum;
    }
&nbsp;
    <i>/**</i>
    <i> * Vypocet souctu hesovacich kodu vsech prvku pole typu Object[].</i>
    <i> */</i>
    static int <strong>hashsum</strong>(Object[] array) {
        int sum = 0;
        for (Object item : array) {
            sum += item.hashCode();
        }
        return sum;
    }
&nbsp;
    <i>/**</i>
    <i> * Test demonstracnich metod.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        byte[]   byteArray   = {1, 2, 3, 4};
        short[]  shortArray  = {1, 2, 3, 4};
        int[]    intArray    = {1, 2, 3, 4};
        long[]   longArray   = {1L,2L,3L,4L};
        float[]  floatArray  = {1f,2f,3f,4f};
        double[] doubleArray = {1.,2.,3.,4.};
        String[] stringArray = {"1","2","3","4"};
&nbsp;
        System.out.println(sum(byteArray));
        System.out.println(sum(shortArray));
        System.out.println(sum(intArray));
        System.out.println(sum(longArray));
        System.out.println(sum(floatArray));
        System.out.println(sum(doubleArray));
        System.out.println(hashsum(stringArray));
    }
}
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Okomentovaný bajtkód demonstraèního pøíkladu <strong>Test23.java</strong></h2>

<p>Podívejme se nyní na zpùsob pøekladu jednotlivých metod
z&nbsp;demonstraèního pøíkladu <strong>Test23.java</strong> do bajtkódu JVM.
První metoda <strong>sum(byte[])</strong> vyu¾ívá pìt pozic (slotù) na
zásobníkovém rámci, které jsou vyhrazeny pro lokální promìnné, a» ji¾ promìnné
explicitnì zapsané programátorem, nebo pomocné promìnné vyu¾ívané interpretrem
bajtkódu:</p>

<table>
<tr><th>Pozice</th><th>Lokální promìnná</th></tr>
<tr><td>1</td><td>lokální promìnná <strong>sum</strong></td></tr>
<tr><td>2</td><td>reference na zpracovávané pole</td></tr>
<tr><td>3</td><td>délka zpracovávaného pole</td></tr>
<tr><td>4</td><td>hodnota poèitadla smyèky <strong>for</strong>, nazvìme poèitadlo <strong>i</strong></td></tr>
<tr><td>5</td><td>hodnota právì zpracovávaného prvku pole (<strong>i</strong>-tý prvek)</td></tr>
</table>

<p>Z&nbsp;výpisu bajtkódu je patrné, ¾e i kdy¾ byla pou¾ita programová smyèka
typu <strong>for-each</strong>, provedl se pøeklad takovým zpùsobem, jakoby
programátor ve skuteènosti pou¾il poèítanou programovou smyèku typu
<strong>for</strong>:</p>

<pre>
static int <strong>sum</strong>(byte[]);
  Code:
   0:   iconst_0                <i>// poèáteèní hodnota lokální promìnné "sum"</i>
   1:   istore_1                <i>// inicializace lokální promìnné "sum"</i>
   2:   aload_0                 <i>// ulo¾it první (jediný) parametr metody na zásobník</i>
   3:   astore_2                <i>// reference na zpracovávané pole je umístìna do druhé lokální promìnné</i>
   4:   aload_2
   5:   arraylength             <i>// vypoèítat délku pole a ulo¾it na TOS</i>
   6:   istore_3                <i>// ulo¾it délku pole do tøetí lokální promìnné</i>
   7:   iconst_0                <i>// poèáteèní hodnota poèitadla</i>
   8:   istore  4               <i>// ulo¾it do ètvrté lokální promìnné</i>
&nbsp;
   10:  iload   4               <i>// zaèátek programové smyèky "for"</i>
   12:  iload_3                 <i>// porovnat hodnotu poèitadla s délkou pole</i>
   13:  if_icmpge       33      <i>// test na ukonèení programové smyèky</i>
   16:  aload_2                 <i>// naèíst referenci na pole</i>
   17:  iload   4               <i>// hodnota poèitadla je pou¾ita jako index</i>
   19:  baload                  <i>// získat i-tý prvek z pole typu byte[] (i=hodnota poèitadla)</i>
   20:  istore  5               <i>// ulo¾it hodnotu prvku do páté lokální promìnné</i>
&nbsp;
   22:  iload_1                 <i>// lokální promìnná "sum" na TOS</i>
   23:  iload   5
   25:  iadd                    <i>// pøièíst k promìnné "sum" hodnotu i-tého prvku pole</i>
   26:  istore_1                <i>// pøenos hodnoty z TOS do lokální promìnné "sum"</i>
&nbsp;
   27:  iinc    4, 1            <i>// zvý¹it hodnotu poèitadla o jednièku</i>
   30:  goto    10              <i>// skok na zaèátek programové smyèky</i>
&nbsp;
   33:  iload_1                 <i>// naèíst aktuální hodnotu lokální promìnné "sum"</i>
   34:  ireturn                 <i>// a vrátit ji jako výsledek metody</i>
</pre>

<p>Prakticky stejný pøeklad byl proveden pro metodu
<strong>sum(short[])</strong>, pouze s&nbsp;tím rozdílem, ¾e se namísto
instrukce <strong>baload</strong> pou¾ila pro ètení prvku pole instrukce
<strong>saload</strong>:</p>

<pre>
static int <strong>sum</strong>(short[]);
  Code:
   0:   iconst_0                <i>// poèáteèní hodnota lokální promìnné "sum"</i>
   1:   istore_1                <i>// inicializace lokální promìnné "sum"</i>
   2:   aload_0                 <i>// ulo¾it první (jediný) parametr metody na zásobník</i>
   3:   astore_2                <i>// reference na zpracovávané pole je umístìna do druhé lokální promìnné</i>
   4:   aload_2
   5:   arraylength             <i>// vypoèítat délku pole a ulo¾it na TOS</i>
   6:   istore_3                <i>// ulo¾it délku pole do tøetí lokální promìnné</i>
   7:   iconst_0                <i>// poèáteèní hodnota poèitadla</i>
   8:   istore  4               <i>// ulo¾it do ètvrté lokální promìnné</i>
&nbsp;
   10:  iload   4               <i>// zaèátek programové smyèky "for"</i>
   12:  iload_3                 <i>// porovnat hodnotu poèitadla s délkou pole</i>
   13:  if_icmpge       33      <i>// test na ukonèení programové smyèky</i>
   16:  aload_2                 <i>// naèíst referenci na pole</i>
   17:  iload   4               <i>// hodnota poèitadla je pou¾ita jako index</i>
   19:  saload                  <i>// získat i-tý prvek z pole typu short[] (i=hodnota poèitadla)</i>
   20:  istore  5               <i>// ulo¾it hodnotu prvku do páté lokální promìnné</i>
&nbsp;
   22:  iload_1                 <i>// lokální promìnná "sum" na TOS</i>
   23:  iload   5
   25:  iadd                    <i>// pøièíst k promìnné "sum" hodnotu i-tého prvku pole</i>
   26:  istore_1                <i>// pøenos hodnoty z TOS do lokální promìnné "sum"</i>
&nbsp;
   27:  iinc    4, 1            <i>// zvý¹it hodnotu poèitadla o jednièku</i>
   30:  goto    10              <i>// skok na zaèátek programové smyèky</i>
&nbsp;
   33:  iload_1                 <i>// naèíst aktuální hodnotu lokální promìnné "sum"</i>
   34:  ireturn                 <i>// a vrátit ji jako výsledek metody</i>
</pre>

<p>Toté¾ platí i pro pøeklad metody <strong>sum(int[])</strong>, jen se namísto
<strong>baload/saload</strong> vyu¾ívá &ndash; podle oèekávání &ndash;
instrukce <strong>iaload</strong>:</p>

<pre>
static int <strong>sum</strong>(int[]);
  Code:
   0:   iconst_0                <i>// poèáteèní hodnota lokální promìnné "sum"</i>
   1:   istore_1                <i>// inicializace lokální promìnné "sum"</i>
   2:   aload_0                 <i>// ulo¾it první (jediný) parametr metody na zásobník</i>
   3:   astore_2                <i>// reference na zpracovávané pole je umístìna do druhé lokální promìnné</i>
   4:   aload_2
   5:   arraylength             <i>// vypoèítat délku pole a ulo¾it na TOS</i>
   6:   istore_3                <i>// ulo¾it délku pole do tøetí lokální promìnné</i>
   7:   iconst_0                <i>// poèáteèní hodnota poèitadla</i>
   8:   istore  4               <i>// ulo¾it do ètvrté lokální promìnné</i>
&nbsp;
   10:  iload   4               <i>// zaèátek programové smyèky "for"</i>
   12:  iload_3                 <i>// porovnat hodnotu poèitadla s délkou pole</i>
   13:  if_icmpge       33      <i>// test na ukonèení programové smyèky</i>
   16:  aload_2                 <i>// naèíst referenci na pole</i>
   17:  iload   4               <i>// hodnota poèitadla je pou¾ita jako index</i>
   19:  iaload                  <i>// získat i-tý prvek z pole typu int[] (i=hodnota poèitadla)</i>
   20:  istore  5               <i>// ulo¾it hodnotu prvku do páté lokální promìnné</i>
&nbsp;
   22:  iload_1                 <i>// lokální promìnná "sum" na TOS</i>
   23:  iload   5
   25:  iadd                    <i>// pøièíst k promìnné "sum" hodnotu i-tého prvku pole</i>
   26:  istore_1                <i>// pøenos hodnoty z TOS do lokální promìnné "sum"</i>
&nbsp;
   27:  iinc    4, 1            <i>// zvý¹it hodnotu poèitadla o jednièku</i>
   30:  goto    10              <i>// skok na zaèátek programové smyèky</i>
&nbsp;
   33:  iload_1                 <i>// naèíst aktuální hodnotu lokální promìnné "sum"</i>
   34:  ireturn                 <i>// a vrátit ji jako výsledek metody</i>
</pre>

<p>Pøeklad metody <strong>sum(long[])</strong> je ponìkud odli¹ný, a to zejména
proto, ¾e lokální promìnné typu long jsou ulo¾eny ve dvou pozicích/slotech.
Celkový poèet obsazených slotù na zásobníkovém rámci je tedy o dvì vy¹¹í, ne¾ u
pøedchozích tøí variant metody <strong>sum()</strong>:</p>

<table>
<tr><th>Pozice</th><th>Lokální promìnná</th></tr>
<tr><td>1+2</td><td>lokální promìnná <strong>sum</strong></td></tr>
<tr><td>3</td><td>reference na zpracovávané pole</td></tr>
<tr><td>4</td><td>délka zpracovávaného pole</td></tr>
<tr><td>5</td><td>hodnota poèitadla smyèky <strong>for</strong>, nazvìme poèitadlo <strong>i</strong></td></tr>
<tr><td>6</td><td>hodnota právì zpracovávaného prvku pole (<strong>i</strong>-tý prvek)</td></tr>
</table>

<p>Bajtkód pøelo¾ené metody <strong>sum(long[])</strong>:</p>

<pre>
static long <strong>sum</strong>(long[]);
  Code:
   0:   lconst_0                <i>// poèáteèní hodnota lokální promìnné "sum"</i>
   1:   lstore_1                <i>// inicializace lokální promìnné "sum"</i>
   2:   aload_0                 <i>// ulo¾it první (jediný) parametr metody na zásobník</i>
   3:   astore_3                <i>// reference na zpracovávané pole je umístìna do tøetí lokální promìnné</i>
   4:   aload_3
   5:   arraylength             <i>// vypoèítat délku pole a ulo¾it na TOS</i>
   6:   istore  4               <i>// ulo¾it délku pole do ètvrté lokální promìnné</i>
   8:   iconst_0                <i>// poèáteèní hodnota poèitadla</i>
   9:   istore  5               <i>// ulo¾it do páté lokální promìnné</i>
&nbsp;
   11:  iload   5               <i>// zaèátek programové smyèky "for"</i>
   13:  iload   4               <i>// porovnat hodnotu poèitadla s délkou pole</i>
   15:  if_icmpge       35      <i>// test na ukonèení programové smyèky</i>
   18:  aload_3                 <i>// naèíst referenci na pole</i>
   19:  iload   5               <i>// hodnota poèitadla je pou¾ita jako index</i>
   21:  laload                  <i>// získat i-tý prvek z pole typu long[] (i=hodnota poèitadla)</i>
   22:  lstore  6               <i>// ulo¾it hodnotu prvku do ¹esté lokální promìnné</i>
&nbsp;
   24:  lload_1                 <i>// lokální promìnná "sum" na TOS</i>
   25:  lload   6
   27:  ladd                    <i>// pøièíst k promìnné "sum" hodnotu i-tého prvku pole</i>
   28:  lstore_1                <i>// pøenos hodnoty z TOS do lokální promìnné "sum"</i>
&nbsp;
   29:  iinc    5, 1            <i>// zvý¹it hodnotu poèitadla o jednièku</i>
   32:  goto    11              <i>// skok na zaèátek programové smyèky</i>
&nbsp;
   35:  lload_1                 <i>// naèíst aktuální hodnotu lokální promìnné "sum"</i>
   36:  lreturn                 <i>// a vrátit ji jako výsledek metody</i>
</pre>

<p>Metoda <strong>sum(float[])</strong> je pøelo¾ena podobnì, jako tomu bylo u
metody <strong>sum(int[])</strong>, samozøejmì a¾ na rozdíly v&nbsp;nìkterých
instrukcích (<strong>iconst_0</strong>/<strong>fconst_0</strong>,
<strong>iload_1</strong>/<strong>fload_1</strong>,
<strong>iadd</strong>/<strong>fadd</strong> atd.):</p>

<pre>
static float <strong>sum</strong>(float[]);
  Code:
   0:   fconst_0                <i>// poèáteèní hodnota lokální promìnné "sum"</i>
   1:   fstore_1                <i>// inicializace lokální promìnné "sum"</i>
   2:   aload_0                 <i>// ulo¾it první (jediný) parametr metody na zásobník</i>
   3:   astore_2                <i>// reference na zpracovávané pole je umístìna do druhé lokální promìnné</i>
   4:   aload_2
   5:   arraylength             <i>// vypoèítat délku pole a ulo¾it na TOS</i>
   6:   istore_3                <i>// ulo¾it délku pole do tøetí lokální promìnné</i>
   7:   iconst_0                <i>// poèáteèní hodnota poèitadla</i>
   8:   istore  4               <i>// ulo¾it do ètvrté lokální promìnné</i>
&nbsp;
   10:  iload   4               <i>// zaèátek programové smyèky "for"</i>
   12:  iload_3                 <i>// porovnat hodnotu poèitadla s délkou pole</i>
   13:  if_icmpge       33      <i>// test na ukonèení programové smyèky</i>
   16:  aload_2                 <i>// naèíst referenci na pole</i>
   17:  iload   4               <i>// hodnota poèitadla je pou¾ita jako index</i>
   19:  faload                  <i>// získat i-tý prvek z pole typu float[] (i=hodnota poèitadla)</i>
   20:  fstore  5               <i>// ulo¾it hodnotu prvku do páté lokální promìnné</i>
&nbsp;
   22:  fload_1                 <i>// lokální promìnná "sum" na TOS</i>
   23:  fload   5
   25:  fadd                    <i>// pøièíst k promìnné "sum" hodnotu i-tého prvku pole</i>
   26:  fstore_1                <i>// pøenos hodnoty z TOS do lokální promìnné "sum"</i>
&nbsp;
   27:  iinc    4, 1            <i>// zvý¹it hodnotu poèitadla o jednièku</i>
   30:  goto    10              <i>// skok na zaèátek programové smyèky</i>
&nbsp;
   33:  fload_1                 <i>// naèíst aktuální hodnotu lokální promìnné "sum"</i>
   34:  freturn                 <i>// a vrátit ji jako výsledek metody</i>
</pre>

<p>U metody <strong>sum(double[])</strong> platí stejná poznámka, jaká byla
uvedena v&nbsp;pøípadì <strong>sum(long[])</strong>, tj.&nbsp;promìnné typu
<strong>long</strong> i <strong>double</strong> obsazují v¾dy dvì pozice/sloty
na zásobníkovém rámci:</p>

<pre>
static double <strong>sum</strong>(double[]);
  Code:
   0:   dconst_0                <i>// poèáteèní hodnota lokální promìnné "sum"</i>
   1:   dstore_1                <i>// inicializace lokální promìnné "sum"</i>
   2:   aload_0                 <i>// ulo¾it první (jediný) parametr metody na zásobník</i>
   3:   astore_3                <i>// reference na zpracovávané pole je umístìna do tøetí lokální promìnné</i>
   4:   aload_3
   5:   arraylength             <i>// vypoèítat délku pole a ulo¾it na TOS</i>
   6:   istore  4               <i>// ulo¾it délku pole do ètvrté lokální promìnné</i>
   8:   iconst_0                <i>// poèáteèní hodnota poèitadla</i>
   9:   istore  5               <i>// ulo¾it do páté lokální promìnné</i>
&nbsp;
   11:  iload   5               <i>// zaèátek programové smyèky "for"</i>
   13:  iload   4               <i>// porovnat hodnotu poèitadla s délkou pole</i>
   15:  if_icmpge       35      <i>// test na ukonèení programové smyèky</i>
   18:  aload_3                 <i>// naèíst referenci na pole</i>
   19:  iload   5               <i>// hodnota poèitadla je pou¾ita jako index</i>
   21:  daload                  <i>// získat i-tý prvek z pole typu double[] (i=hodnota poèitadla)</i>
   22:  dstore  6               <i>// ulo¾it hodnotu prvku do ¹esté lokální promìnné</i>
&nbsp;
   24:  dload_1                 <i>// lokální promìnná "sum" na TOS</i>
   25:  dload   6
   27:  dadd                    <i>// pøièíst k promìnné "sum" hodnotu i-tého prvku pole</i>
   28:  dstore_1                <i>// pøenos hodnoty z TOS do lokální promìnné "sum"</i>
&nbsp;
   29:  iinc    5, 1            <i>// zvý¹it hodnotu poèitadla o jednièku</i>
   32:  goto    11              <i>// skok na zaèátek programové smyèky</i>
&nbsp;
   35:  dload_1                 <i>// naèíst aktuální hodnotu lokální promìnné "sum"</i>
   36:  dreturn                 <i>// a vrátit ji jako výsledek metody</i>
</pre>

<pre>
static int <strong>hashsum</strong>(java.lang.Object[]);
  Code:
   0:   iconst_0                <i>// poèáteèní hodnota lokální promìnné "sum"</i>
   1:   istore_1                <i>// inicializace lokální promìnné "sum"</i>
   2:   aload_0                 <i>// ulo¾it první (jediný) parametr metody na zásobník</i>
   3:   astore_2                <i>// reference na zpracovávané pole je umístìna do druhé lokální promìnné</i>
   4:   aload_2
   5:   arraylength             <i>// vypoèítat délku pole a ulo¾it na TOS</i>
   6:   istore_3                <i>// ulo¾it délku pole do tøetí lokální promìnné</i>
   7:   iconst_0                <i>// poèáteèní hodnota poèitadla</i>
   8:   istore  4               <i>// ulo¾it do ètvrté lokální promìnné</i>
&nbsp;
   10:  iload   4               <i>// zaèátek programové smyèky "for"</i>
   12:  iload_3                 <i>// porovnat hodnotu poèitadla s délkou pole</i>
   13:  if_icmpge       33      <i>// test na ukonèení programové smyèky</i>
   16:  aload_2                 <i>// naèíst referenci na pole</i>
   17:  iload   4               <i>// hodnota poèitadla je pou¾ita jako index</i>
   19:  aaload                  <i>// získat i-tý prvek (=referenci) z pole typu Object[] (i=hodnota poèitadla)</i>
   20:  astore  5               <i>// ulo¾it hodnotu prvku (=referenci) do páté lokální promìnné</i>
&nbsp;
   22:  iload_1                 <i>// lokální promìnná "sum" na TOS</i>
   23:  aload   5
                                <i>// výpoèet he¹ovacího kódu</i>
   25:  invokevirtual   #2;     <i>// Method java/lang/Object.hashCode:()I</i>
   28:  iadd                    <i>// pøièíst k promìnné "sum" hodnotu he¹ovacího kódu i-tého prvku pole</i>
   29:  istore_1                <i>// pøenos hodnoty z TOS do lokální promìnné "sum"</i>
&nbsp;
   30:  iinc    4, 1            <i>// zvý¹it hodnotu poèitadla o jednièku</i>
   33:  goto    10              <i>// skok na zaèátek programové smyèky</i>
&nbsp;
   36:  iload_1                 <i>// naèíst aktuální hodnotu lokální promìnné "sum"</i>
   37:  ireturn                 <i>// a vrátit ji jako výsledek metody</i>
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Demonstraèní pøíklad <strong>Test24.java</strong>: seznamy a programová smyèka typu &bdquo;for-each&ldquo; v&nbsp;JVM</h2>

<p>V&nbsp;dne¹ním druhém demonstraèním pøíkladu s&nbsp;názvem
<strong>Test24.java</strong> je na dvojici metod pojmenovaných
<strong>sum()</strong> a <strong>hashsum()</strong> ukázáno pou¾ití programové
smyèky typu <strong>for-each</strong> pøi prùchodu v¹emi prvky ulo¾enými do
seznamu, tj.&nbsp;do kolekce implementující rozhraní <strong>List</strong>.
V&nbsp;metodì <strong>sum()</strong> se pøedpokládá, ¾e v¹echny prvky seznamu
budou typu <strong>Integer</strong>, co¾ je kontrolováno jak pøi pøekladu, tak
i pøi bìhu aplikace (proto¾e pøekladaè nedoká¾e kvùli dynamickému linkování
zaruèit, jak bude metoda <strong>sum()</strong> pøesnì volána):</p>

<pre>
<i>/**</i>
<i> * Demonstracni priklad cislo 24.</i>
<i> *</i>
<i> * Seznamy a programova smycka typu for-each.</i>
<i> */</i>
&nbsp;
import java.util.List;
&nbsp;
public class <strong>Test24</strong> {
&nbsp;
    <i>/**</i>
    <i> * Vypocet souctu vsech prvku seznamu typu List&lt;Integer&gt;.</i>
    <i> */</i>
    static int <strong>sum</strong>(List&lt;Integer&gt; list) {
        int sum = 0;
        for (int item : list) {
            sum += item;
        }
        return sum;
    }
&nbsp;
    <i>/**</i>
    <i> * Vypocet souctu hesovacich kodu vsech prvku seznamu typu List&lt;? extends Object&gt.</i>
    <i> */</i>
    static int <strong>hashsum</strong>(List&lt;? extends Object&gt; list) {
        int sum = 0;
        for (Object item : list) {
            sum += item.hashCode();
        }
        return sum;
    }
&nbsp;
    <i>/**</i>
    <i> * Test demonstracnich metod.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        List&lt;Integer&gt; integerList = java.util.Arrays.asList(1,2,3,4);
        List&lt;? extends Object&gt;  objectList = java.util.Arrays.asList("1","2","3","4");
        System.out.println(sum(integerList));
        System.out.println(hashsum(objectList));
    }
}
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Okomentovaný bajtkód demonstraèního pøíkladu <strong>Test24.java</strong></h2>

<p>Metoda <strong>sum(java.util.List)</strong> (pov¹imnìte si, ¾e se pøi
pøekladu &bdquo;vytratila&ldquo; informace o typu prvkù seznamù, co¾ v¹ak
pøesnì odpovídá specifikaci Javy) vyu¾ívá na zásobníkovém rámci kupodivu pouze
tøi pozice/sloty, co¾ je znaèný rozdíl oproti pøedchozímu pøíkladu, v&nbsp;nìm¾
se pou¾ívalo vìt¹inou pìt slotù:</p>

<table>
<tr><th>Pozice</th><th>Lokální promìnná</th></tr>
<tr><td>1</td><td>lokální promìnná <strong>sum</strong></td></tr>
<tr><td>2</td><td>reference na iterátor získaný pro seznam</td></tr>
<tr><td>3</td><td>hodnota právì zpracovávaného prvku seznamu</td></tr>
</table>

<p>Pøeklad metody <strong>sum(java.util.List)</strong> je pøímoèarý a odpovídá
oèekávání. Nejprve se získá iterátor pro seznam a posléze se volají metody
<strong>Iterator.hasNext()</strong> pro test ukonèení smyèky a
<strong>Iterator.next()</strong> pro pøeètení dal¹ího prvku. Zajímavá je v¹ak
instrukce <strong>checkcast</strong> pro otestování typu ka¾dého prvku
v&nbsp;seznamu, co¾ je dùle¾ité, nebo» ji¾ víme, ¾e se tato informace
&bdquo;vytratila&ldquo; z&nbsp;hlavièky metody (je jen souèástí metadat):</p>

<pre>
static int <strong>sum</strong>(java.util.List);
  Code:
   0:   iconst_0                <i>// poèáteèní hodnota lokální promìnné "sum"</i>
   1:   istore_1                <i>// inicializace lokální promìnné "sum"</i>
   2:   aload_0                 <i>// ulo¾it první (jediný) parametr metody na zásobník</i>
                                <i>// získat iterátor pro kolekci (zde konkrétnì seznam)</i>
   3:   invokeinterface #2,  1; <i>// InterfaceMethod java/util/List.iterator:()Ljava/util/Iterator;</i>
   8:   astore_2                <i>// ulo¾it iterátor do druhé lokální promìnné</i>
&nbsp;
   9:   aload_2                 <i>// zaèátek programové smyèky</i>
                                <i>// test na ukonèení programové smyèky</i>
   10:  invokeinterface #3,  1; <i>// InterfaceMethod java/util/Iterator.hasNext:()Z</i>
   15:  ifeq    38              <i>// po dosa¾ení konce kolekce se programová smyèka ukonèí</i>
   18:  aload_2                 <i>// naèíst iterátor na TOS</i>
                                <i>// ètení prvku z kolekce</i>
   19:  invokeinterface #4,  1; <i>// InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object;</i>
                                <i>// test, zda je prvek skuteènì typu Integer</i>
   24:  checkcast       #5;     <i>// class java/lang/Integer</i>
                                <i>// pøevod z Integer na int</i>
   27:  invokevirtual   #6;     <i>// Method java/lang/Integer.intValue:()I</i>
&nbsp;
   30:  istore_3                <i>// hodnotu prvku ulo¾it do tøetí lokální promìnné</i>
   31:  iload_1                 <i>// naèíst aktuální hodnotu lokální promìnné "sum"</i>
   32:  iload_3                 <i>// naèíst hodnotu prvku z kolekce</i>
   33:  iadd                    <i>// pøièíst k promìnné "sum" hodnotu prvku kolekce</i>
   34:  istore_1                <i>// pøenos hodnoty z TOS do lokální promìnné "sum"</i>
&nbsp;
   35:  goto    9               <i>// skok na zaèátek programové smyèky</i>
&nbsp;
   38:  iload_1                 <i>// naèíst aktuální hodnotu lokální promìnné "sum"</i>
   39:  ireturn                 <i>// a vrátit ji jako výsledek metody</i>
</pre>

<p>Podobným zpùsobem je zkonstruován i bajtkód metody
<strong>hashsum()</strong>, v&nbsp;ní¾ se v¹ak namísto ètení a zpracování
objektù typu <strong>Integer</strong> volá pro v¹echny objekty nalezené
v&nbsp;seznamu metoda <strong>Object.hashCode()</strong>. I z&nbsp;tohoto
dùvodu zde ji¾ nenalezneme pou¾ití instrukce <strong>checkcast</strong>:</p>

<pre>
static int <strong>hashsum</strong>(java.util.List);
  Code:
   0:   iconst_0                <i>// poèáteèní hodnota lokální promìnné "sum"</i>
   1:   istore_1                <i>// inicializace lokální promìnné "sum"</i>
   2:   aload_0                 <i>// ulo¾it první (jediný) parametr metody na zásobník</i>
                                <i>// získat iterátor pro kolekc (zde konkrétnì pro seznam)</i>
   3:   invokeinterface #2,  1; <i>// InterfaceMethod java/util/List.iterator:()Ljava/util/Iterator;</i>
   8:   astore_2                <i>// ulo¾it iterátor do druhé lokální promìnné</i>
&nbsp;
   9:   aload_2                 <i>// zaèátek programové smyèky</i>
                                <i>// test na ukonèení programové smyèky</i>
   10:  invokeinterface #3,  1; <i>// InterfaceMethod java/util/Iterator.hasNext:()Z</i>
   15:  ifeq    35              <i>// po dosa¾ení konce kolekce se programová smyèka ukonèí</i>
   18:  aload_2                 <i>// naèíst iterátor na TOS</i>
                                <i>// ètení prvku z kolekce</i>
   19:  invokeinterface #4,  1; <i>// InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object;</i>
&nbsp;
   24:  astore_3                <i>// hodnotu prvku ulo¾it do tøetí lokální promìnné</i>
   25:  iload_1                 <i>// naèíst aktuální hodnotu lokální promìnné "sum"</i>
   26:  aload_3                 <i>// naèíst hodnotu prvku (=referenci) z kolekce</i>
                                <i>// výpoèet he¹ovacího kódu objektu</i>
   27:  invokevirtual   #7;     <i>// Method java/lang/Object.hashCode:()I</i>
   30:  iadd                    <i>// pøièíst k promìnné "sum" hodnotu prvku kolekce</i>
   31:  istore_1                <i>// pøenos hodnoty z TOS do lokální promìnné "sum"</i>
&nbsp;
   32:  goto    9               <i>// skok na zaèátek programové smyèky</i>
&nbsp;
   35:  iload_1                 <i>// naèíst aktuální hodnotu lokální promìnné "sum"</i>
   36:  ireturn                 <i>// a vrátit ji jako výsledek metody</i>
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Demonstraèní pøíklad <strong>Test25.java</strong>: mno¾iny a programová smyèka typu &bdquo;for-each&ldquo; v&nbsp;JVM</h2>

<p>Dal¹í, dnes ji¾ tøetí demonstraèní pøíklad se jmenuje
<strong>Test25.java</strong>. Jeho zdrojový kód se do znaèné míry podobá
zdrojovému kódu <a href="#k05">pøedchozího</a> demonstraèního pøíkladu
<strong>Test24.java</strong>, a¾ na ten rozdíl, ¾e se namísto prvkù ulo¾ených
do seznamù prochází v¹emi prvky mno¾iny, tj.&nbsp;jakékoli kolekce
implementující rozhraní <strong>Set</strong>. Pov¹imnìte si, ¾e tìla metod jsou
shodná s&nbsp;pøedchozím demonstraèním pøíkladem, co¾ vlastnì není pøíli¹
pøekvapivé, kdy¾ si uvìdomíme, ¾e jak seznamy, tak i mno¾iny implementují
rozhraní <strong>Iterable</strong> a programová smyèka typu
<strong>for-each</strong> je urèena mj.&nbsp;právì pro vyu¾ití iterátorù:</p>

<pre>
<i>/**</i>
<i> * Demonstracni priklad cislo 25.</i>
<i> *</i>
<i> * Mnoziny a programova smycka typu for-each.</i>
<i> */</i>
&nbsp;
import java.util.Arrays;
import java.util.Set;
import java.util.TreeSet;
&nbsp;
public class <strong>Test25</strong> {
&nbsp;
    <i>/**</i>
    <i> * Vypocet souctu vsech prvku mnoziny typu Set&lt;Integer&gt;.</i>
    <i> */</i>
    static int <strong>sum</strong>(Set&lt;Integer&gt; set) {
        int sum = 0;
        for (int item : set) {
            sum += item;
        }
        return sum;
    }
&nbsp;
    <i>/**</i>
    <i> * Vypocet souctu hesovacich kodu vsech prvku mnoziny typu Set&lt;Object&gt;.</i>
    <i> */</i>
    static int <strong>hashsum</strong>(Set&lt;? extends Object&gt; set) {
        int sum = 0;
        for (Object item : set) {
            sum += item.hashCode();
        }
        return sum;
    }
&nbsp;
    <i>/**</i>
    <i> * Test demonstracnich metod.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        Set&lt;Integer&gt; integerSet = new TreeSet<Integer>(Arrays.asList(1,2,3,4));
        Set&lt;? extends Object&gt; objectSet = new TreeSet(Arrays.asList("1","2","3","4"));
        System.out.println(sum(integerSet));
        System.out.println(hashsum(objectSet));
    }
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Okomentovaný bajtkód demonstraèního pøíkladu <strong>Test25.java</strong></h2>

<p>Bajtkód vzniklý pøekladem demonstraèního pøíkladu
<strong>Test25.java</strong> je a¾ na nìkolik malých rozdílù prakticky stejný
jako bajtkód pøedchozího pøíkladu <strong>Test24.java</strong>. Nejprve si
uka¾me, jakým zpùsobem jsou vyu¾ity pozice/sloty alokované v&nbsp;zásobníkovém
rámci (<i>stack frame</i>):</p>

<table>
<tr><th>Pozice</th><th>Lokální promìnná</th></tr>
<tr><td>1</td><td>lokální promìnná <strong>sum</strong></td></tr>
<tr><td>2</td><td>reference na iterátor získaný pro mno¾inu</td></tr>
<tr><td>3</td><td>hodnota právì zpracovávaného prvku mno¾iny</td></tr>
</table>

<p>Nyní ji¾ následuje okomentovaný výpis bajtkódu pøíkladu
<strong>Test25.java</strong>:</p>

<pre>
static int <strong>sum</strong>(java.util.Set);
  Code:
   0:   iconst_0                <i>// poèáteèní hodnota lokální promìnné "sum"</i>
   1:   istore_1                <i>// inicializace lokální promìnné "sum"</i>
   2:   aload_0                 <i>// ulo¾it první (jediný) parametr metody na zásobník</i>
                                <i>// získat iterátor pro kolekci (zde konkrétnì mno¾inu)</i>
   3:   invokeinterface #2,  1; <i>// InterfaceMethod java/util/Set.iterator:()Ljava/util/Iterator;</i>
   8:   astore_2                <i>// ulo¾it iterátor do druhé lokální promìnné</i>
&nbsp;
   9:   aload_2                 <i>// zaèátek programové smyèky</i>
                                <i>// test na ukonèení programové smyèky</i>
   10:  invokeinterface #3,  1; <i>// InterfaceMethod java/util/Iterator.hasNext:()Z</i>
   15:  ifeq    38              <i>// po dosa¾ení konce kolekce se programová smyèka ukonèí</i>
   18:  aload_2                 <i>// naèíst iterátor na TOS</i>
                                <i>// ètení prvku z kolekce</i>
   19:  invokeinterface #4,  1; <i>// InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object;</i>
                                <i>// test, zda je prvek skuteènì typu Integer</i>
   24:  checkcast       #5;     <i>// class java/lang/Integer</i>
                                <i>// pøevod z Integer na int</i>
   27:  invokevirtual   #6;     <i>// Method java/lang/Integer.intValue:()I</i>
&nbsp;
   30:  istore_3                <i>// hodnotu prvku ulo¾it do tøetí lokální promìnné</i>
   31:  iload_1                 <i>// naèíst aktuální hodnotu lokální promìnné "sum"</i>
   32:  iload_3                 <i>// naèíst hodnotu prvku z kolekce</i>
   33:  iadd                    <i>// pøièíst k promìnné "sum" hodnotu prvku kolekce</i>
   34:  istore_1                <i>// pøenos hodnoty z TOS do lokální promìnné "sum"</i>
&nbsp;
   35:  goto    9               <i>// skok na zaèátek programové smyèky</i>
&nbsp;
   38:  iload_1                 <i>// naèíst aktuální hodnotu lokální promìnné "sum"</i>
   39:  ireturn                 <i>// a vrátit ji jako výsledek metody</i>
</pre>

<pre>
static int <strong>hashsum</strong>(java.util.Set);
  Code:
   0:   iconst_0                <i>// poèáteèní hodnota lokální promìnné "sum"</i>
   1:   istore_1                <i>// inicializace lokální promìnné "sum"</i>
   2:   aload_0                 <i>// ulo¾it první (jediný) parametr metody na zásobník</i>
                                <i>// získat iterátor pro kolekc (zde konkrétnì pro mno¾inu)</i>
   3:   invokeinterface #2,  1; <i>// InterfaceMethod java/util/Set.iterator:()Ljava/util/Iterator;</i>
   8:   astore_2                <i>// ulo¾it iterátor do druhé lokální promìnné</i>
&nbsp;
   9:   aload_2                 <i>// zaèátek programové smyèky</i>
                                <i>// test na ukonèení programové smyèky</i>
   10:  invokeinterface #3,  1; <i>// InterfaceMethod java/util/Iterator.hasNext:()Z</i>
   15:  ifeq    35              <i>// po dosa¾ení konce kolekce se programová smyèka ukonèí</i>
   18:  aload_2                 <i>// naèíst iterátor na TOS</i>
                                <i>// ètení prvku z kolekce</i>
   19:  invokeinterface #4,  1; <i>// InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object;</i>
&nbsp;
   24:  astore_3                <i>// hodnotu prvku ulo¾it do tøetí lokální promìnné</i>
   25:  iload_1                 <i>// naèíst aktuální hodnotu lokální promìnné "sum"</i>
   26:  aload_3                 <i>// naèíst hodnotu prvku (=referenci) z kolekce</i>
                                <i>// výpoèet he¹ovacího kódu objektu</i>
   27:  invokevirtual   #7;     <i>// Method java/lang/Object.hashCode:()I</i>
   30:  iadd                    <i>// pøièíst k promìnné "sum" hodnotu prvku kolekce</i>
   31:  istore_1                <i>// pøenos hodnoty z TOS do lokální promìnné "sum"</i>
&nbsp;
   32:  goto    9               <i>// skok na zaèátek programové smyèky</i>
&nbsp;
   35:  iload_1                 <i>// naèíst aktuální hodnotu lokální promìnné "sum"</i>
   36:  ireturn                 <i>// a vrátit ji jako výsledek metody</i>
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Demonstraèní pøíklad <strong>Test26.java</strong>: mapy a programová smyèka typu &bdquo;for-each&ldquo; v&nbsp;JVM</h2>

<p>V&nbsp;dne¹ním posledním demonstraèním pøíkladu, který nese název
<strong>Test26.java</strong>, se ve dvojici metod <strong>sum1()</strong> a
<strong>sum2()</strong> prochází mapou, tj.&nbsp;takovou datovou strukturou,
v&nbsp;ní¾ jsou ulo¾eny dvojice klíè:hodnota, pøièem¾ klíèe musí být
v&nbsp;rámci jedné mapy jednoznaèné a unikátní. V&nbsp;metodì
<strong>sum1()</strong> se sèítají celoèíselné klíèe, zatímco v&nbsp;metodì
<strong>sum2()</strong> dochází k&nbsp;souètu (takté¾ celoèíselných) hodnot.
V&nbsp;obou zmínìných metodách je samozøejmì vyu¾ita programová smyèka typu
<strong>for-each</strong> pro procházení prvky mno¾iny typu
<strong>Map.Entry</strong>:</p>

<pre>
<i>/**</i>
<i> * Demonstracni priklad cislo 26.</i>
<i> *</i>
<i> * Mapy a programova smycka typu for-each.</i>
<i> */</i>
&nbsp;
import java.util.Map;
import java.util.TreeMap;
&nbsp;
public class <strong>Test26</strong> {
&nbsp;
    <i>/**</i>
    <i> * Vypocet souctu klicu vsech prvku mapy typu Map&lt;Integer,Integer&gt;.</i>
    <i> */</i>
    static int <strong>sum1</strong>(Map&lt;Integer,Integer&gt; map) {
        int sum = 0;
        for (Map.Entry&lt;Integer,Integer&gt; item : map.entrySet()) {
            sum += item.getKey();
        }
        return sum;
    }
&nbsp;
    <i>/**</i>
    <i> * Vypocet souctu hodnot vsech prvku mapy typu Map&lt;Integer,Integer&gt;.</i>
    <i> */</i>
    static int <strong>sum2</strong>(Map&lt;Integer,Integer&gt; map) {
        int sum = 0;
        for (Map.Entry&lt;Integer,Integer&gt; item : map.entrySet()) {
            sum += item.getValue();
        }
        return sum;
    }
&nbsp;
    <i>/**</i>
    <i> * Test demonstracnich metod.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        Map&lt;Integer, Integer&gt; map = new TreeMap&lt;Integer,Integer&gt;();
        for (int i=0; i&lt;=4; i++) {
            map.put(i,i);
        }
        System.out.println(sum1(map));
        System.out.println(sum2(map));
    }
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Okomentovaný bajtkód demonstraèního pøíkladu <strong>Test26.java</strong></h2>

<p>Pøed popisem bajtkódu demonstraèního pøíkladu <strong>Test26.java</strong>
se podívejme, podobnì jako tomu bylo u v¹ech tøí pøedchozích demonstraèních
pøíkladù, na obsazení zásobníkového rámce:</p>

<table>
<tr><th>Pozice</th><th>Lokální promìnná</th></tr>
<tr><td>1</td><td>lokální promìnná <strong>sum</strong></td></tr>
<tr><td>2</td><td>reference na iterátor získaný pro mapu s&nbsp;prvky typu Map.Entry</td></tr>
<tr><td>3</td><td>hodnota právì zpracovávaného prvku mapy (typ Map.Entry)</td></tr>
</table>

<p>Bajtkód metody <strong>sum1()</strong> je pomìrnì dlouhý, a to pøedev¹ím
z&nbsp;toho dùvodu, ¾e se pro prùchod mapou musí nejdøíve získat mno¾ina
s&nbsp;prvky <strong>Map.Entry</strong>, a to konkrétnì s&nbsp;vyu¾itím metody
<strong>Map.entrySet()</strong>. Následnì se získá iterátor pro tuto mno¾inu a
pøi prùchodu v¹emi prvky vracenými iterátorem se (zbyteènì) provádí test na
jejich typ s&nbsp;vyu¾itím instrukce <strong>checkcast</strong>. Stejná
instrukce je pou¾ita pro testování typu klíèe &ndash; opìt se zde ukazuje, jaké
problémy zpùsobuje fakt, ¾e typ prvkù/klíèù/hodnot není jednoznaènou souèástí
popisu datového typu kolekce:</p>

<pre>
static int <strong>sum1</strong>(java.util.Map);
  Code:
   0:   iconst_0                <i>// poèáteèní hodnota lokální promìnné "sum"</i>
   1:   istore_1                <i>// inicializace lokální promìnné "sum"</i>
   2:   aload_0                 <i>// ulo¾it první (jediný) parametr metody na zásobník</i>
                                <i>// získat objekt typu Map.Entry</i>
   3:   invokeinterface #2,  1; <i>// InterfaceMethod java/util/Map.entrySet:()Ljava/util/Set;</i>
                                <i>// získat iterátor pro kolekci (zde konkrétnì mno¾inu)</i>
   8:   invokeinterface #3,  1; <i>// InterfaceMethod java/util/Set.iterator:()Ljava/util/Iterator;</i>
   13:  astore_2                <i>// ulo¾it iterátor do druhé lokální promìnné</i>
&nbsp;
   14:  aload_2                 <i>// zaèátek programové smyèky</i>
                                <i>// test na ukonèení programové smyèky</i>
   15:  invokeinterface #4,  1; <i>// InterfaceMethod java/util/Iterator.hasNext:()Z</i>
   20:  ifeq    51              <i>// po dosa¾ení konce kolekce se programová smyèka ukonèí</i>
   23:  aload_2                 <i>// naèíst iterátor na TOS</i>
                                <i>// ètení prvku z kolekce</i>
   24:  invokeinterface #5,  1; <i>// InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object;</i>
                                <i>// test, zda je prvek skuteènì typu Map.Entry (to musí být celkem zbyteèná konstrukce)</i>
   29:  checkcast       #6;     <i>// class java/util/Map$Entry</i>
   32:  astore_3                <i>// ulo¾it objekt vrácený iterátorem z TOS do tøetí lokální promìnné</i>
   33:  iload_1                 <i>// naèíst hodnotu lokální promìnné "sum"</i>
   34:  aload_3                 <i>// ulo¾it objekt vrácený iterátorem na TOS</i>
                                <i>// získat klíè z dvojice Map.Entry</i>
   35:  invokeinterface #7,  1; <i>// InterfaceMethod java/util/Map$Entry.getKey:()Ljava/lang/Object;</i>
                                <i>// test, zda je klíè typu Integer</i>
   40:  checkcast       #8;     <i>// class java/lang/Integer</i>
                                <i>// pøevod z Integer na int</i>
   43:  invokevirtual   #9;     <i>// Method java/lang/Integer.intValue:()I</i>
   46:  iadd                    <i>// pøièíst k promìnné "sum" hodnotu prvku kolekce</i>
   47:  istore_1                <i>// pøenos hodnoty z TOS do lokální promìnné "sum"</i>
&nbsp;
   48:  goto    14              <i>// skok na zaèátek programové smyèky</i>
&nbsp;
   51:  iload_1                 <i>// naèíst aktuální hodnotu lokální promìnné "sum"</i>
   52:  ireturn                 <i>// a vrátit ji jako výsledek metody</i>
</pre>

<p>Bajtkód metody <strong>sum2()</strong> se od bajtkódu metody
<strong>sum1()</strong> li¹í pouze v&nbsp;jednom ohledu &ndash; získávají a
zpracovávají se zde hodnoty, nikoli klíèe, tj.&nbsp;pro objekty typu
<strong>Map.Entry</strong> se volá metoda <strong>getValue()</strong> a nikoli
metoda <strong>getKey()</strong>:</p>

<pre>
static int <strong>sum2</strong>(java.util.Map);
  Code:
   0:   iconst_0                <i>// poèáteèní hodnota lokální promìnné "sum"</i>
   1:   istore_1                <i>// inicializace lokální promìnné "sum"</i>
   2:   aload_0                 <i>// ulo¾it první (jediný) parametr metody na zásobník</i>
                                <i>// získat objekt typu Map.Entry</i>
   3:   invokeinterface #2,  1; <i>// InterfaceMethod java/util/Map.entrySet:()Ljava/util/Set;</i>
                                <i>// získat iterátor pro kolekci (zde konkrétnì mno¾inu)</i>
   8:   invokeinterface #3,  1; <i>// InterfaceMethod java/util/Set.iterator:()Ljava/util/Iterator;</i>
   13:  astore_2                <i>// ulo¾it iterátor do druhé lokální promìnné</i>
&nbsp;
   14:  aload_2                 <i>// zaèátek programové smyèky</i>
                                <i>// test na ukonèení programové smyèky</i>
   15:  invokeinterface #4,  1; <i>// InterfaceMethod java/util/Iterator.hasNext:()Z</i>
   20:  ifeq    51              <i>// po dosa¾ení konce kolekce se programová smyèka ukonèí</i>
   23:  aload_2                 <i>// naèíst iterátor na TOS</i>
                                <i>// ètení prvku z kolekce</i>
   24:  invokeinterface #5,  1; <i>// InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object;</i>
                                <i>// test, zda je prvek skuteènì typu Map.Entry (to musí být celkem zbyteèná konstrukce)</i>
   29:  checkcast       #6;     <i>// class java/util/Map$Entry</i>
   32:  astore_3                <i>// ulo¾it objekt vrácený iterátorem z TOS do tøetí lokální promìnné</i>
   33:  iload_1                 <i>// naèíst hodnotu lokální promìnné "sum"</i>
   34:  aload_3                 <i>// ulo¾it objekt vrácený iterátorem na TOS</i>
                                <i>// získat hodnotu (value) z dvojice Map.Entry</i>
   35:  invokeinterface #10,  1;<i>// InterfaceMethod java/util/Map$Entry.getValue:()Ljava/lang/Object;</i>
                                <i>// test, zda je hodnota typu Integer</i>
   40:  checkcast       #8;     <i>// class java/lang/Integer</i>
                                <i>// pøevod z Integer na int</i>
   43:  invokevirtual   #9;     <i>// Method java/lang/Integer.intValue:()I</i>
   46:  iadd                    <i>// pøièíst k promìnné "sum" hodnotu prvku kolekce</i>
   47:  istore_1                <i>// pøenos hodnoty z TOS do lokální promìnné "sum"</i>
&nbsp;
   48:  goto    14              <i>// skok na zaèátek programové smyèky</i>
&nbsp;
   51:  iload_1                 <i>// naèíst aktuální hodnotu lokální promìnné "sum"</i>
   52:  ireturn                 <i>// a vrátit ji jako výsledek metody</i>
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Repositáø se zdrojovými kódy v¹ech ètyø dne¹ních demonstraèních pøíkladù</h2>

<p>V¹echny ètyøi dnes popsané a vyu¾ité demonstraèní pøíklady (naprogramované
v&nbsp;Javì, proto¾e pøíklady pro jazyky Python a Lua budou popsány pøí¹tì)
byly ulo¾eny do Mercurial repositáøe umístìného na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
Odkazy na prozatím poslední verze tìchto pøíkladù naleznete v&nbsp;tabulce pod
tímto odstavcem:</p>

<table>
<tr><th>#</th><th>Zdrojový kód</th><th>Umístìní</th></tr>
<tr><td>1</td><td>Test23.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/3adbe748c94a/bytecode/Java/Test23.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/3adbe748c94a/bytecode/Java/Test23.java</a></td></tr>
<tr><td>2</td><td>Test24.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/3adbe748c94a/bytecode/Java/Test24.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/3adbe748c94a/bytecode/Java/Test24.java</a></td></tr>
<tr><td>3</td><td>Test25.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/3adbe748c94a/bytecode/Java/Test25.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/3adbe748c94a/bytecode/Java/Test25.java</a></td></tr>
<tr><td>4</td><td>Test26.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/3adbe748c94a/bytecode/Java/Test26.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/3adbe748c94a/bytecode/Java/Test26.java</a></td></tr>
</table>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>For-each Loop in Java<br />
<a href="http://www.leepoint.net/notes-java/flow/loops/foreach.html">http://www.leepoint.net/notes-java/flow/loops/foreach.html</a>
</li>

<li>Programming in Lua (first edition)<br />
<a href="http://www.lua.org/pil/contents.html">http://www.lua.org/pil/contents.html</a>
</li>

<li>Programming in Lua: Numeric for<br />
<a href="http://www.lua.org/pil/4.3.4.html">http://www.lua.org/pil/4.3.4.html</a>
</li>

<li>Programming in Lua: break and return<br />
<a href="http://www.lua.org/pil/4.4.html">http://www.lua.org/pil/4.4.html</a>
</li>

<li>Programming in Lua: Tables<br />
<a href="http://www.lua.org/pil/2.5.html">http://www.lua.org/pil/2.5.html</a>
</li>

<li>Programming in Lua: Table Constructors<br />
<a href="http://www.lua.org/pil/3.6.html">http://www.lua.org/pil/3.6.html</a>
</li>

<li>Programovací jazyk Lua<br />
<a href="http://palmknihy.cz/web/kniha/programovaci-jazyk-lua-12651.htm">http://palmknihy.cz/web/kniha/programovaci-jazyk-lua-12651.htm</a>
</li>

<li>Lua: Tables Tutorial<br />
<a href="http://lua-users.org/wiki/TablesTutorial">http://lua-users.org/wiki/TablesTutorial</a>
</li>

<li>Lua: Control Structure Tutorial<br />
<a href="http://lua-users.org/wiki/ControlStructureTutorial">http://lua-users.org/wiki/ControlStructureTutorial</a>
</li>

<li>Lua Types Tutorial<br />
<a href="http://lua-users.org/wiki/LuaTypesTutorial">http://lua-users.org/wiki/LuaTypesTutorial</a>
</li>

<li>Goto Statement in Lua<br />
<a href="http://lua-users.org/wiki/GotoStatement">http://lua-users.org/wiki/GotoStatement</a>
</li>

<li>Python break, continue and pass Statements<br />
<a href="http://www.tutorialspoint.com/python/python_loop_control.htm">http://www.tutorialspoint.com/python/python_loop_control.htm</a>
</li>

<li>For Loop (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/For_loop">http://en.wikipedia.org/wiki/For_loop</a>
</li>

<li>Heinz Rutishauser<br />
<a href="http://en.wikipedia.org/wiki/Heinz_Rutishauser">http://en.wikipedia.org/wiki/Heinz_Rutishauser</a>
</li>

<li>Parrot<br />
<a href="http://www.parrot.org/">http://www.parrot.org/</a>
</li>

<li>Parrot languages<br />
<a href="http://www.parrot.org/languages">http://www.parrot.org/languages</a>
</li>

<li>Parrot Primer<br />
<a href="http://docs.parrot.org/parrot/latest/html/docs/intro.pod.html">http://docs.parrot.org/parrot/latest/html/docs/intro.pod.html</a>
</li>

<li>Parrot Opcodes<br />
<a href="http://docs.parrot.org/parrot/latest/html/ops.html">http://docs.parrot.org/parrot/latest/html/ops.html</a>
</li>

<li>Parrot VM<br />
<a href="http://en.wikibooks.org/wiki/Parrot_Virtual_Machine">http://en.wikibooks.org/wiki/Parrot_Virtual_Machine</a>
</li>

<li>Parrot Assembly Language<br />
<a href="http://www.perl6.org/archive/pdd/pdd06_pasm.html">http://www.perl6.org/archive/pdd/pdd06_pasm.html</a>
</li>

<li>Parrot Reference: Chapter 11 - Perl 6 and Parrot Essentials<br />
<a href="http://oreilly.com/perl/excerpts/perl-6-and-parrot-essentials/parrot-reference.html">http://oreilly.com/perl/excerpts/perl-6-and-parrot-essentials/parrot-reference.html</a>
</li>

<li>Python Bytecode: Fun With Dis<br />
<a href="http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/">http://akaptur.github.io/blog/2013/08/14/python-bytecode-fun-with-dis/</a>
</li>

<li>Python's Innards: Hello, ceval.c!<br />
<a href="http://tech.blog.aknin.name/category/my-projects/pythons-innards/">http://tech.blog.aknin.name/category/my-projects/pythons-innards/</a>
</li>

<li>Byterun<br />
<a href="https://github.com/nedbat/byterun">https://github.com/nedbat/byterun</a>
</li>

<li>Python Byte Code Instructions<br />
<a href="http://document.ihg.uni-duisburg.de/Documentation/Python/lib/node56.html">http://document.ihg.uni-duisburg.de/Documentation/Python/lib/node56.html</a>
</li>

<li>Python Byte Code Instructions<br />
<a href="https://docs.python.org/3.2/library/dis.html#python-bytecode-instructions">https://docs.python.org/3.2/library/dis.html#python-bytecode-instructions</a>
</li>

<li>Lua 5.2 sources<br />
<a href="http://www.lua.org/source/5.2/">http://www.lua.org/source/5.2/</a>
</li>

<li>Lua 5.2 sources - lopcodes.h<br />
<a href="http://www.lua.org/source/5.2/lopcodes.h.html">http://www.lua.org/source/5.2/lopcodes.h.html</a>
</li>

<li>Lua 5.2 sources - lopcodes.c<br />
<a href="http://www.lua.org/source/5.2/lopcodes.c.html">http://www.lua.org/source/5.2/lopcodes.c.html</a>
</li>

<li>dis - Python module<br />
<a href="https://docs.python.org/2/library/dis.html">https://docs.python.org/2/library/dis.html</a>
</li>

<li>Comparison of Python virtual machines<br />
<a href="http://polishlinux.org/apps/cli/comparison-of-python-virtual-machines/">http://polishlinux.org/apps/cli/comparison-of-python-virtual-machines/</a>
</li>

<li>O-code<br />
<a href="http://en.wikipedia.org/wiki/O-code_machine">http://en.wikipedia.org/wiki/O-code_machine</a>
</li>

<li>BCPL<br />
<a href="http://en.wikipedia.org/wiki/BCPL">http://en.wikipedia.org/wiki/BCPL</a>
</li>

<li>The BCPL Cintcode System and Cintpos User Guide by Martin Richards<br />
<a href="http://www.cl.cam.ac.uk/users/mr/bcplman.pdf">http://www.cl.cam.ac.uk/users/mr/bcplman.pdf</a>
</li>

<li>Bootstrapping the BCPL Compiler using INTCODE<br />
<a href="http://www.gtoal.com/languages/bcpl/amiga/bcpl/booting.txt">http://www.gtoal.com/languages/bcpl/amiga/bcpl/booting.txt</a>
</li>

<li>p-code machine<br />
<a href="http://en.wikipedia.org/wiki/P-code_machine">http://en.wikipedia.org/wiki/P-code_machine</a>
</li>

<li>ucsd-psystem-vm 0.11 (a portable virtual machine for the UCSD p-System)<br />
<a href="http://ucsd-psystem-vm.sourceforge.net/">http://ucsd-psystem-vm.sourceforge.net/</a>
</li>

<li>Introduction to Smalltalk bytecodes<br />
<a href="http://marianopeck.wordpress.com/2011/05/21/introduction-to-smalltalk-bytecodes/">http://marianopeck.wordpress.com/2011/05/21/introduction-to-smalltalk-bytecodes/</a>
</li>

<li>Audio File Formats.<br />
<a href="http://sox.sourceforge.net/AudioFormats-11.html">http://sox.sourceforge.net/AudioFormats-11.html</a>
</li>

<li>TestSounds.com: pure digital sounds to test your audio<br />
<a href="http://www.testsounds.com/">http://www.testsounds.com/</a>
</li>

<li>Test Tones (20hz - 20khz)<br />
<a href="http://mdf1.tripod.com/test-tones.html">http://mdf1.tripod.com/test-tones.html</a>
</li>

<li>WAV (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/WAV">http://en.wikipedia.org/wiki/WAV</a>
</li>

<li>WAVE PCM soundfile format<br />
<a href="https://ccrma.stanford.edu/courses/422/projects/WaveFormat/">https://ccrma.stanford.edu/courses/422/projects/WaveFormat/</a>
</li>

<li>Audio Interchange File Format<br />
<a href="http://en.wikipedia.org/wiki/Aiff">http://en.wikipedia.org/wiki/Aiff</a>
</li>

<li>Musical Instrument Digital Interface,<br />
<a href="http://en.wikipedia.org/wiki/Musical_Instrument_Digital_Interface">http://en.wikipedia.org/wiki/Musical_Instrument_Digital_Interface</a>
</li>

<li>A MIDI Pedalboard Encode,<br />
<a href="http://www.pykett.org.uk/a_midi_pedalboard_encoder.htm">http://www.pykett.org.uk/a_midi_pedalboard_encoder.htm</a>
</li>

<li>MIDI Note Number, Frequency Table,<br />
<a href="http://tonalsoft.com/pub/news/pitch-bend.aspx">http://tonalsoft.com/pub/news/pitch-bend.aspx</a>
</li>

<li>Note names, MIDI numbers and frequencies,<br />
<a href="http://www.phys.unsw.edu.au/jw/notes.html">http://www.phys.unsw.edu.au/jw/notes.html</a>
</li>

<li>The MIDI Specification,<br />
<a href="http://www.gweep.net/~prefect/eng/reference/protocol/midispec.html">http://www.gweep.net/~prefect/eng/reference/protocol/midispec.html</a>
</li>

<li>Essentials of the MIDI protocol,<br />
<a href="http://ccrma.stanford.edu/~craig/articles/linuxmidi/misc/essenmidi.html">http://ccrma.stanford.edu/~craig/articles/linuxmidi/misc/essenmidi.html</a>
</li>

<li>General MIDI,<br />
<a href="http://en.wikipedia.org/wiki/General_MIDI">http://en.wikipedia.org/wiki/General_MIDI</a>
</li>

<li>Obecné MIDI (General MIDI), <br />
<a href="http://www-kiv.zcu.cz/~herout/html_sbo/midi/5.html">http://www-kiv.zcu.cz/~herout/html_sbo/midi/5.html</a>
</li>

<li>Custom Chips: Paula<br />
<a href="http://www.amiga-hardware.com/showhardware.cgi?HARDID=1460">http://www.amiga-hardware.com/showhardware.cgi?HARDID=1460</a>
</li>

<li>Big Book of Amiga Hardware<br />
<a href="http://www.amiga-resistance.info/bboahfaq/">http://www.amiga-resistance.info/bboahfaq/</a>
</li>

<li>Amiga Hardware Database<br />
<a href="http://amiga.resource.cx/">http://amiga.resource.cx/</a>
</li>

<li>ExoticA<br />
<a href="http://www.exotica.org.uk/wiki/Main_Page">http://www.exotica.org.uk/wiki/Main_Page</a>
</li>

<li>The absolute basics of Amiga audio<br />
<a href="http://www.sufo.estates.co.uk/amiga/amimus.html">http://www.sufo.estates.co.uk/amiga/amimus.html</a>
</li>

<li>Wikipedia: Tracker<br />
<a href="http://en.wikipedia.org/wiki/Tracker">http://en.wikipedia.org/wiki/Tracker</a>
</li>

<li>Wikipedia: Trackers<br />
<a href="http://en.wikipedia.org/wiki/Trackers">http://en.wikipedia.org/wiki/Trackers</a>
</li>

<li>Ultimate Soundtracker<br />
<a href="http://en.wikipedia.org/wiki/Ultimate_Soundtracker">http://en.wikipedia.org/wiki/Ultimate_Soundtracker</a>
</li>

<li>Protracker<br />
<a href="http://en.wikipedia.org/wiki/ProTracker">http://en.wikipedia.org/wiki/ProTracker</a>
</li>

<li>Impulse Tracker<br />
<a href="http://en.wikipedia.org/wiki/Impulse_Tracker">http://en.wikipedia.org/wiki/Impulse_Tracker</a>
</li>

<li>Scream Tracker<br />
<a href="http://en.wikipedia.org/wiki/ScreamTracker">http://en.wikipedia.org/wiki/ScreamTracker</a>
</li>

<li>MikMod for Java<br />
<a href="http://jmikmod.berlios.de/">http://jmikmod.berlios.de/</a>
</li>

<li>List of audio trackers<br />
<a href="http://en.wikipedia.org/wiki/List_of_audio_trackers">http://en.wikipedia.org/wiki/List_of_audio_trackers</a>
</li>

<li>Wikipedia: Module File<br />
<a href="http://en.wikipedia.org/wiki/Module_file">http://en.wikipedia.org/wiki/Module_file</a>
</li>

<li>Wikipedia: Chiptune<br />
<a href="http://en.wikipedia.org/wiki/Chiptune">http://en.wikipedia.org/wiki/Chiptune</a>
</li>

<li>SDL_mixer 2.0<br />
<a href="http://www.libsdl.org/projects/SDL_mixer/">http://www.libsdl.org/projects/SDL_mixer/</a>
</li>

<li>SDLJava: package sdljava.ttf<br />
<a href="http://sdljava.sourceforge.net/docs/api/sdljava/ttf/package-summary.html#package_description">http://sdljava.sourceforge.net/docs/api/sdljava/ttf/package-summary.html#package_description</a>
</li>

<li>SDLJava: class sdljava.ttf.SDLTTF<br />
<a href="http://sdljava.sourceforge.net/docs/api/sdljava/ttf/SDLTTF.html">http://sdljava.sourceforge.net/docs/api/sdljava/ttf/SDLTTF.html</a>
</li>

<li>SDLJava: class sdljava.ttf.SDLTrueTypeFont<br />
<a href="http://sdljava.sourceforge.net/docs/api/sdljava/ttf/SDLTrueTypeFont.html">http://sdljava.sourceforge.net/docs/api/sdljava/ttf/SDLTrueTypeFont.html</a>
</li>

<li>SDL_ttf Documentation<br />
<a href="http://www.libsdl.org/projects/SDL_ttf/docs/">http://www.libsdl.org/projects/SDL_ttf/docs/</a>
</li>

<li>SDL_ttf 2.0 (není prozatím souèástí SDLJava)<br />
<a href="http://www.libsdl.org/projects/SDL_ttf/">http://www.libsdl.org/projects/SDL_ttf/</a>
</li>

<li>SDL_ttf doc<br />
<a href="http://www.libsdl.org/projects/SDL_ttf/docs/SDL_ttf_frame.html">http://www.libsdl.org/projects/SDL_ttf/docs/SDL_ttf_frame.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_Surface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_PixelFormat<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlpixelformat.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlpixelformat.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_LockSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdllocksurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdllocksurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_UnlockSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlunlocksurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlunlocksurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_LoadBMP<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlloadbmp.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlloadbmp.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_SaveBMP<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsavebmp.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsavebmp.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_BlitSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlblitsurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlblitsurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_VideoInfo<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlvideoinfo.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlvideoinfo.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_GetVideoInfo<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlgetvideoinfo.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlgetvideoinfo.html</a>
</li>

<li>glDrawArrays<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArrays.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArrays.xml</a>
</li>

<li>glDrawElements<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElements.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElements.xml</a>
</li>

<li>glDrawArraysInstanced<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArraysInstanced.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArraysInstanced.xml</a>
</li>

<li>glDrawElementsInstanced<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElementsInstanced.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElementsInstanced.xml</a>
</li>

<li>Root.cz: Seriál Grafická knihovna OpenGL<br />
<a href="http://www.root.cz/serialy/graficka-knihovna-opengl/">http://www.root.cz/serialy/graficka-knihovna-opengl/</a>
</li>

<li>Root.cz: Seriál Tvorba pøenositelných grafických aplikací vyu¾ívajících knihovnu GLUT<br />
<a href="http://www.root.cz/serialy/tvorba-prenositelnych-grafickych-aplikaci-vyuzivajicich-knihovnu-glut/">http://www.root.cz/serialy/tvorba-prenositelnych-grafickych-aplikaci-vyuzivajicich-knihovnu-glut/</a>
</li>

<li>Best Practices for Working with Vertex Data<br />
<a href="https://developer.apple.com/library/ios/documentation/3ddrawing/conceptual/opengles_programmingguide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html">https://developer.apple.com/library/ios/documentation/3ddrawing/conceptual/opengles_programmingguide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html</a>
</li>

<li>Class BufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferStrategy.html</a>
</li>

<li>Class Graphics<br />
<a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/Graphics.html">http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/Graphics.html</a>
</li>

<li>Double Buffering and Page Flipping<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html</a>
</li>

<li>BufferStrategy and BufferCapabilities<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/bufferstrategy.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/bufferstrategy.html</a>
</li>

<li>Java:Tutorials:Double Buffering<br />
<a href="http://content.gpwiki.org/index.php/Java:Tutorials:Double_Buffering">http://content.gpwiki.org/index.php/Java:Tutorials:Double_Buffering</a>
</li>

<li>Double buffer in standard Java AWT<br />
<a href="http://www.codeproject.com/Articles/2136/Double-buffer-in-standard-Java-AWT">http://www.codeproject.com/Articles/2136/Double-buffer-in-standard-Java-AWT</a>
</li>

<li>Java 2D: Hardware Accelerating - Part 1 - Volatile Images<br />
<a href="http://www.javalobby.org/forums/thread.jspa?threadID=16840&tstart=0">http://www.javalobby.org/forums/thread.jspa?threadID=16840&tstart=0</a>
</li>

<li>Java 2D: Hardware Accelerating - Part 2 - Buffer Strategies<br />
<a href="http://www.javalobby.org/java/forums/t16867.html">http://www.javalobby.org/java/forums/t16867.html</a>
</li>

<li>How does paintComponent work?<br />
<a href="http://stackoverflow.com/questions/15544549/how-does-paintcomponent-work">http://stackoverflow.com/questions/15544549/how-does-paintcomponent-work</a>
</li>

<li>A Swing Architecture Overview<br />
<a href="http://www.oracle.com/technetwork/java/architecture-142923.html">http://www.oracle.com/technetwork/java/architecture-142923.html</a>
</li>

<li>Class javax.swing.JComponent<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html</a>
</li>

<li>Class java.awt.Component<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html</a>
</li>

<li>Class java.awt.Component.BltBufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.BltBufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.BltBufferStrategy.html</a>
</li>

<li>Class java.awt.Component.FlipBufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.FlipBufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.FlipBufferStrategy.html</a>
</li>

<li>Metoda java.awt.Component.isDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html#isDoubleBuffered()">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html#isDoubleBuffered()</a>
</li>

<li>Metoda javax.swing.JComponent.isDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#isDoubleBuffered()">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#isDoubleBuffered()</a>
</li>

<li>Metoda javax.swing.JComponent.setDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#setDoubleBuffered(boolean)">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#setDoubleBuffered(boolean)</a>
</li>

<li>Javadoc - tøída GraphicsDevice<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html</a>
</li>

<li>Javadoc - tøída GraphicsEnvironment<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html</a>
</li>

<li>Javadoc - tøída GraphicsConfiguration<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html</a>
</li>

<li>Javadoc - tøída DisplayMode<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html">http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html</a>
</li>

<li>Lesson: Full-Screen Exclusive Mode API<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/">http://docs.oracle.com/javase/tutorial/extra/fullscreen/</a>
</li>

<li>Full-Screen Exclusive Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html</a>
</li>

<li>Display Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html</a>
</li>

<li>Using the Full-Screen Exclusive Mode API in Java<br />
<a href="http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm">http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>GC safe-point (or safepoint) and safe-region<br />
<a href="http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html">http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html</a>
</li>

<li>Safepoints in HotSpot JVM<br />
<a href="http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html">http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html</a>
</li>

<li>Java theory and practice: Synchronization optimizations in Mustang<br />
<a href="http://www.ibm.com/developerworks/java/library/j-jtp10185/">http://www.ibm.com/developerworks/java/library/j-jtp10185/</a>
</li>

<li>How to build hsdis<br />
<a href="http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README">http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README</a>
</li>

<li>Java SE 6 Performance White Paper<br />
<a href="http://www.oracle.com/technetwork/java/6-performance-137236.html">http://www.oracle.com/technetwork/java/6-performance-137236.html</a>
</li>

<li>Lukas Stadler's Blog<br />
<a href="http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html">http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html</a>
</li>

<li>How to build hsdis-amd64.dll and hsdis-i386.dll on Windows<br />
<a href="http://dropzone.nfshost.com/hsdis.htm">http://dropzone.nfshost.com/hsdis.htm</a>
</li>

<li>PrintAssembly<br />
<a href="https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly">https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly</a>
</li>

<li>The Java Virtual Machine Specification: 3.14. Synchronization<br />
<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14</a>
</li>

<li>The Java Virtual Machine Specification: 8.3.1.4. volatile Fields<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.4. Memory Model<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.7. Non-atomic Treatment of double and long<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7</a>
</li>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (pøed verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2014</small></p>
</body>
</html>

