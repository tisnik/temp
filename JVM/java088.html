<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - pøímé generování instrukcí bajtkódu s vyu¾itím nástroje Javassist (2)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - pøímé generování instrukcí bajtkódu s vyu¾itím nástroje Javassist (2)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o virtuálním stroji Javy si øekneme, jak se s vyu¾itím nástroje Javassist dají tvoøit i slo¾itìj¹í metody (resp. jejich bajtkód). Dále si uká¾eme jednu velmi u¾iteènou funkcionalitu Javassistu - jeho schopnost naèíst právì vytvoøenou èi modifikovanou tøídu do JVM a ihned ji zaèít pou¾ívat.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - pøímé generování instrukcí bajtkódu s vyu¾itím nástroje Javassist (2)</a></p>
<p><a href="#k02">2. Sekvence instrukcí pro vypsání øetìzce "Hello world!"</a></p>
<p><a href="#k03">3. Základ demonstraèního pøíkladu: metoda <strong>constructMethodHello()</strong></a></p>
<p><a href="#k04">4. Metody <strong>prepareMethod()</strong> a <strong>setCodeAttributeForMethod()</strong></a></p>
<p><a href="#k05">5. Dal¹í souèást demonstraèního pøíkladu: abstraktní tøída <strong>BytecodeGenerator</strong></a></p>
<p><a href="#k06">6. První zpùsob výpisu øetìzce &ndash; vyu¾ití <strong>Bytecode.addPrintln()</strong></a></p>
<p><a href="#k07">7. Druhý zpùsob výpisu øetìzce &ndash; vyu¾ití <strong>Bytecode.addGetstatic()</strong>, <strong>Bytecode.addLdc()</strong> a <strong>Bytecode.addInvokevirtual()</strong></a></p>
<p><a href="#k08">8. Tøetí zpùsob výpisu øetìzce &ndash; pou¾ití tøídy <strong>CtClass</strong> namísto signatur tøíd a metod</a></p>
<p><a href="#k09">9. Ètvrtý zpùsob výpisu øetìzce &ndash; pøevod instance tøídy <strong>Class</strong> na <strong>CtClass</strong></a></p>
<p><a href="#k10">10. Spu¹tìní metod právì vytvoøené tøídy ve stejném virtuálním stroji</a></p>
<p><a href="#k11">11. Zdrojový kód demonstraèního pøíkladu <strong>ClassGenerationTest8</strong></a></p>
<p><a href="#k12">12. Výpis bajtkódu vygenerovaného demonstraèním pøíkladem <strong>ClassGenerationTest8</strong></a></p>
<p><a href="#k13">13. Repositáø se zdrojovými kódy dne¹ního demonstraèního pøíkladu</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - pøímé generování instrukcí bajtkódu s vyu¾itím nástroje Javassist (2)</h2>

<p>V&nbsp;pøedchozí èásti seriálu o programovacím jazyce Java i o virtuálním
stroji Javy jsme si vysvìtlili základní zpùsob tvorby bajtkódu metod
s&nbsp;vyu¾itím tøíd <strong>javassist.bytecode.Bytecode</strong> a
<strong>javassist.bytecode.Opcode</strong>. Pøipomeòme si, ¾e v&nbsp;první
tøídì se nachází mnoho metod urèených pro pøidávání nových instrukcí do
bajtkódu zvolené metody (pøesnìji øeèeno do bytového pole tvoøícího hodnotu
atributu &bdquo;Code&ldquo;). Jednotlivé instrukèní kódy se samozøejmì nemusí
zadávat ruènì, proto¾e jsou ulo¾eny jako konstanty v&nbsp;ji¾ zmínìné tøídì
<strong>javassist.bytecode.Opcode</strong>. Minule jsme si ukázali, jak lze
s&nbsp;vyu¾itím této dvojice tøíd vytvoøit jednoduchou metodu, která buï vrátí
celoèíselnou konstantu nebo nejprve seète hodnotu svých dvou parametrù a vrátí
výsledek tohoto souètu. Podobným zpùsobem lze zkonstruovat i metody se
slo¾itìj¹ími výpoèty, které mohou vyu¾ívat hodnoty libovolného primitivního
datového typu (byte, short, int, long, float, double, boolean èi char).<p>

<p>Dnes si uká¾eme zpùsob volání nestatické metody, pøesnìji øeèeno zpùsob
konstrukce sekvence instrukcí pou¾itých pro volání metody. To je ji¾ ponìkud
komplikovanìj¹í èinnost, nebo» vzhledem k&nbsp;vlastnostem virtuálního stroje
Javy je pøi volání metody v¾dy pou¾ito plnì kvalifikované jméno tøídy i
signatura metody &ndash; nepou¾ívají se tedy adresy, a» ji¾ v&nbsp;absolutní èi
relativní podobì. I kdy¾ se mù¾e nepøímý zpùsob volání metod s&nbsp;vyu¾itím
jména tøídy a signatury metody znát ponìkud komplikovaný èi zdlouhavý, umo¾òuje
relativnì snadnou implementaci zámìny tøíd (rùzné verze tøídy od jiného
dodavatele, tøída upravená pomocí <i>Javassistu</i>), rùzné manipulace
s&nbsp;classloadery atd. Komplikovanost volání je tedy vyvá¾ena vìt¹ími
mo¾nostmi v&nbsp;porovnání s&nbsp;pouhým skokem na urèenou adresu (druhým
neménì dùle¾itým dùvodem je fakt, ¾e vìt¹ina metod je pova¾ována za metody
virtuální).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Sekvence instrukcí pro vypsání øetìzce "Hello world!"</h2>

<p>V&nbsp;demonstraèním pøíkladu, který bude postupnì popsán
v&nbsp;navazujících kapitolách, se bude tvoøit bajtkód metod, jejich¾ jediným
úkolem je vypsání øetìzce na standardní èi chybový výstup. Nejjednodu¹eji je
tisk øetìzce realizován (pøetí¾enými) metodami
<strong>System.out.println()</strong> a <strong>System.err.println()</strong>,
pøièem¾ první metoda slou¾í pro tisk na standardní výstup a metoda druhá pro
tisk na výstup chybový. Podívejme se nyní, jakým zpùsobem se vlastnì pøelo¾í
volání tìchto dvou zmínìných metod. Po pøelo¾ení následující testovací
tøídy:</p>

<pre>
public class <strong>Test</strong> {
    static {
        System.out.println("Hello world!");
        System.err.println("Hello world!");
        System.exit(0);
    }
}
</pre>

<p>pøíkazem:</p>

<pre>
javac Test
</pre>

<p>vznikne, jak zajisté ètenáøi tohoto èlánku vìdí, soubor
<strong>Test.class</strong> obsahující mj.&nbsp;i bajtkód s&nbsp;instrukcemi
tvoøícími tìlo statického bloku (ten se &bdquo;spustí&ldquo; po naètení tøídy
do JVM). Obsah souboru <strong>Test.class</strong> mù¾eme snadno dekompilovat
pøíkazem:</p>

<pre>
javap -c -v Test
</pre>

<p>Podívejme se nyní na výstup získaný tímto pøíkazem:</p>

<pre>
Compiled from "Test.java"
public class Test extends java.lang.Object
  SourceFile: "Test.java"
  minor version: 0
  major version: 50
  Constant pool:
const #1 = Method   #8.#16;            <i>//  java/lang/Object."&lt;init&gt;":()V</i>
const #2 = Field    #17.#18;           <i>//  java/lang/System.out:Ljava/io/PrintStream;</i>
const #3 = String   #19;               <i>//  Hello world!</i>
const #4 = Method   #20.#21;           <i>//  java/io/PrintStream.println:(Ljava/lang/String;)V</i>
const #5 = Field    #17.#22;           <i>//  java/lang/System.err:Ljava/io/PrintStream;</i>
const #6 = Method   #17.#23;           <i>//  java/lang/System.exit:(I)V</i>
const #7 = class    #24;               <i>//  Test</i>
const #8 = class    #25;               <i>//  java/lang/Object</i>
const #9 = Asciz    &lt;init&gt;;
const #10 = Asciz   ()V;
const #11 = Asciz   Code;
const #12 = Asciz   LineNumberTable;
const #13 = Asciz   &lt;clinit&gt;
const #14 = Asciz   SourceFile;
const #15 = Asciz   Test.java;
const #16 = NameAndType #9:#10;        <i>//  "&lt;init&gt;":()V</i>
const #17 = class   #26;               <i>//  java/lang/System</i>
const #18 = NameAndType #27:#28;       <i>//  out:Ljava/io/PrintStream;</i>
const #19 = Asciz   Hello world!;
const #20 = class   #29;               <i>//  java/io/PrintStream</i>
const #21 = NameAndType #30:#31;       <i>//  println:(Ljava/lang/String;)V</i>
const #22 = NameAndType #32:#28;       <i>//  err:Ljava/io/PrintStream;</i>
const #23 = NameAndType #33:#34;       <i>//  exit:(I)V</i>
const #24 = Asciz   Test;
const #25 = Asciz   java/lang/Object;
const #26 = Asciz   java/lang/System;
const #27 = Asciz   out;
const #28 = Asciz   Ljava/io/PrintStream;;
const #29 = Asciz   java/io/PrintStream;
const #30 = Asciz   println;
const #31 = Asciz   (Ljava/lang/String;)V;
const #32 = Asciz   err;
const #33 = Asciz   exit;
const #34 = Asciz   (I)V;
&nbsp;
{
public <strong>Test</strong>();
  Code:
   Stack=1, Locals=1, Args_size=1
   0:   aload_0
   1:   invokespecial   #1;            <i>//Method java/lang/Object."&lt;init&gt;":()V</i>
   4:   return
  LineNumberTable: 
   line 1: 0
&nbsp;
&nbsp;
static {};
  Code:
   Stack=2, Locals=0, Args_size=0
&nbsp;
   0:   getstatic     #2;              <i>//Field java/lang/System.out:Ljava/io/PrintStream;</i>
   3:   ldc           #3;              <i>//String Hello world!</i>
   5:   invokevirtual #4;              <i>//Method java/io/PrintStream.println:(Ljava/lang/String;)V</i>
&nbsp;
   8:   getstatic     #5;              <i>//Field java/lang/System.err:Ljava/io/PrintStream;</i>
   11:  ldc           #3;              <i>//String Hello world!</i>
   13:  invokevirtual #4;              <i>//Method java/io/PrintStream.println:(Ljava/lang/String;)V</i>
&nbsp;
   16:  iconst_0
   17:  invokestatic  #6;              <i>//Method java/lang/System.exit:(I)V</i>
   20:  return
  LineNumberTable: 
   line 3: 0
   line 4: 8
   line 5: 16
   line 6: 20
&nbsp;
&nbsp;
}
</pre>

<p>Nejzajímavìj¹í je v&nbsp;tuto chvíli zji¹tìní, jak je realizováno volání
metody <strong>System.out.println()</strong>. Jedná se o nestatickou metodu se
signaturou &bdquo;(Ljava/lang/String;)V&ldquo; ze tøídy
<strong>java.io.PrintStream</strong>. V&nbsp;bajtkódu je nejdøíve nutné
s&nbsp;vyu¾itím instrukce <strong>getstatic</strong> získat statický atribut
nazvaný &bdquo;out&ldquo; ze tøídy <strong>java.lang.System</strong> (co¾ je
instance <strong>java.io.PrintStream</strong>) a ulo¾it tuto referenci na
zásobník. Následnì je nutné ulo¾it na zásobník odkaz (referenci) na øetìzec a
poslední (tøetí) instrukcí je zavolání pøíslu¹né metody &ndash; jedná se o
instrukci <strong>invokevirtual</strong>. Øetìzec (reference) je pøitom pou¾it
jako parametr metody. V¹echny tøi instrukce pøitom pou¾ívají index do constant
poolu:</p>

<pre>
const #2 = Field    #17.#18;   <i>// java/lang/System.out:Ljava/io/PrintStream;</i>
const #3 = String   #19;       <i>// Hello world!</i>
const #4 = Method   #20.#21;   <i>// java/io/PrintStream.println:(Ljava/lang/String;)V</i>
&nbsp;
getstatic     #2;              <i>// Field java/lang/System.out:Ljava/io/PrintStream;</i>
ldc           #3;              <i>// String Hello world!</i>
invokevirtual #4;              <i>// Method java/io/PrintStream.println:(Ljava/lang/String;)V</i>
</pre>

<p>Zcela stejným zpùsobem je realizováno volání metody
<strong>System.err.println()</strong>:</p>

<pre>
const #5 = Field    #17.#22;   <i>// java/lang/System.err:Ljava/io/PrintStream;</i>
const #3 = String   #19;       <i>// Hello world!</i>
const #4 = Method   #20.#21;   <i>// java/io/PrintStream.println:(Ljava/lang/String;)V</i>
&nbsp;
getstatic     #5;              <i>// Field java/lang/System.err:Ljava/io/PrintStream;</i>
ldc           #3;              <i>// String Hello world!</i>
invokevirtual #4;              <i>// Method java/io/PrintStream.println:(Ljava/lang/String;)V</i>
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Základ demonstraèního pøíkladu: metoda <strong>constructMethodHello()</strong></h2>

<p>V&nbsp;následujících kapitolách si popí¹eme ètyøi varianty konstrukce
bajtkódu, jeho¾ úkolem bude vypsat øetìzec na standardní èi na chybový výstup.
Vzhledem k&nbsp;tomu, ¾e základ konstrukce nové metody je v¾dy stejný, mù¾eme
kvùli zjednodu¹ení zdrojového kódu dne¹ního demonstraèního pøíkladu provést
(oproti pøíkladùm popsaným minule) nìkolik zmìn. První zmìna se týká toho, ¾e
metody v&nbsp;novì vytváøené tøídì se budou konstruovat v&nbsp;jediné spoleèné
metodì s&nbsp;názvem <strong>constructMethodHello</strong>. Této metodì se
pøedá odkaz na právì vytváøenou tøídu (je typu <strong>CtClass</strong>), dále
pak jméno vytváøené metody a koneènì tøetím parametrem této metody je tøída
pøedstavující vlastní generátor bajtkódu (viz té¾ <a href="#k05">kapitolu èíslo
5</a> s&nbsp;podrobnìj¹ím vysvìtlením). Z&nbsp;následujícího výpisu je patrné,
¾e se nejdøíve vytvoøí kostra nové prázdné metody
(<strong>prepareMethod</strong>) a následnì se k&nbsp;této metodì pøiøadí
atribut &bdquo;Code&ldquo; obsahující bajtkód pøedstavující tìlo této
metody:</p>

<pre>
<i>    /**</i>
<i>     * Vytvoreni metody public static void hello*().</i>
<i>     * </i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @param methodName</i>
<i>     *            jmeno vytvarene metody</i>
<i>     * @param generator</i>
<i>     *            generator bajtkodu vytvarene metody</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu nebo strukturalni chyby v bajtkodu</i>
<i>     * @throws NotFoundException</i>
<i>     *             vyhozena v pripade, ze nebyla nalezena nektera pomocna trida</i>
<i>     */</i>
    private static void <strong>constructMethodHello</strong>(CtClass generatedClass, String methodName, BytecodeGenerator generator) throws CannotCompileException, NotFoundException {
        MethodInfo methodInfo = prepareMethod(generatedClass, methodName);
        ConstPool constPool = methodInfo.getConstPool();
        Bytecode bytecode = generator.generateBytecode(constPool);
        setCodeAttributeForMethod(methodInfo, bytecode);
    }
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Metody <strong>prepareMethod()</strong> a <strong>setCodeAttributeForMethod()</strong></h2>

<p>Vytvoøení metody bez pøiøazeného atributu &bdquo;Code&ldquo; je
v&nbsp;pøípadì nástroje <i>Javassist</i> velmi jednoduché. Kostra metody se
vytvoøí konstruktorem <strong>new CtMethod()</strong>, kterému se pøedá
návratový typ metody, jméno metody, typy v¹ech parametrù metody i tøída, do ní¾
bude metoda vlo¾ena. Následnì se metodì pøiøadí pøíslu¹né pøíznaky, zde
konkrétnì pøíznak statické metody a pøíznak pro metodu veøejnou. Posledním
úkonem je vlo¾ení metody do její tøídy s&nbsp;vyu¾itím volání
<strong>CtClass.addMethod()</strong>:</p>

<pre>
<i>    /**</i>
<i>     * Vytvoreni kostry metody a vraceni objektu typu MethodInfo.</i>
<i>     *</i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @param methodName</i>
<i>     *            jmeno vytvarene metody</i>
<i>     * @return</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu nebo strukturalni chyby v bajtkodu</i>
<i>     */</i>
    private static MethodInfo <strong>prepareMethod</strong>(CtClass generatedClass, String methodName) throws CannotCompileException {
        CtClass returnType = CtClass.voidType;
        CtClass[] parameterTypes = {};
&nbsp;
<i>        // u metody je nutne znat jeji jmeno, navratovou hodnotu i typy parametru</i>
        CtMethod helloMethod = new CtMethod(returnType, methodName, parameterTypes, generatedClass);
&nbsp;
<i>        // zmena modifikatoru</i>
        helloMethod.setModifiers(Modifier.STATIC | Modifier.PUBLIC);
&nbsp;
<i>        // pridani metody do tridy</i>
        generatedClass.addMethod(helloMethod);
&nbsp;
<i>        // ziskani informace o metoda</i>
        MethodInfo methodInfo = helloMethod.getMethodInfo();
        return methodInfo;
    }
</pre>

<p>Pokud ji¾ máme k&nbsp;dispozici bajtkód nové metody (to je úkol pøedstavený
v&nbsp;dal¹ích kapitolách), je pøiøazení tohoto bajtkódu k&nbsp;metodì takté¾
velmi jednoduché, co¾ snadno zjistíme pøi pohledu na kód dal¹í u¾ivatelské
metody nazvané pøíznaènì <strong>setCodeAttributeForMethod()</strong>:</p>

<pre>
<i>    /**</i>
<i>     * Nastaveni atributu "Code" s bajktodem pro vybranou metodu.</i>
<i>     * </i>
<i>     * @param methodInfo</i>
<i>     *            objekt typu MethodInfo</i>
<i>     * @param bytecode</i>
<i>     *            bajtkod vytvarene metody.</i>
<i>     */</i>
    private static void <strong>setCodeAttributeForMethod</strong>(MethodInfo methodInfo, Bytecode bytecode) {
        CodeAttribute codeAttribute = bytecode.toCodeAttribute();
        methodInfo.setCodeAttribute(codeAttribute);
    }
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Dal¹í souèást demonstraèního pøíkladu: abstraktní tøída <strong>BytecodeGenerator</strong></h2>

<p><a href="#k03">Ve tøetí kapitole</a> jsme si øekli, ¾e se v¹echny ètyøi
varianty metody typu <strong>void helloWorld()</strong> budou tvoøit prakticky
stejným zpùsobem, bude se li¹it pouze zpùsob generování jejich bajtkódu. Aby
bylo mo¾né tuto funkcionalitu zaruèit, pøedává se ve tøetím parametru
u¾ivatelské metody <strong>constructMethodHello()</strong> (uvedené právì <a
href="#k03">ve tøetí kapitole</a>) odkaz na instanci tøídy
<strong>BytecodeGenerator</strong>, resp.&nbsp;pøesnìji øeèeno odkaz na
instanci nìkterého potomka této tøídy, proto¾e ve skuteènosti je
<strong>BytecodeGenerator</strong> tøídou èistì abstraktní (mohlo by se jednat
i o rozhraní, nenapadl mì v¹ak ¾ádný vhodný název pro toto rozhraní, proto jsem
zùstal u abstraktní tøídy :-). Ve tøídì <strong>BytecodeGenerator</strong> je
pøedepsána pouze jediná metoda nazvaná <strong>generateBytecode()</strong>,
které se pøedá odkaz na constant pool a návratovou hodnotou je bajtkód nìkteré
z&nbsp;variant metody <strong>void helloWorld()</strong>:</p>

<pre>
<i>/**</i>
<i> * Abstraktni trida, kterou mohou rozsirit vsechny tridy urcenyme pro generovani bajtkodu.</i>
<i> */</i>
abstract class <strong>BytecodeGenerator</strong> {
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni bajtkodu predstavujiciho sekvenci instrukci pro libovolnou</i>
<i>     * metodu.</i>
<i>     * </i>
<i>     * @param constPool</i>
<i>     *            tabulka konstant pouzivana metodou</i>
<i>     * @return bajtkod predstavujici sekvenci instrukci pro vytvorenou metodu</i>
<i>     * @throws NotFoundException</i>
<i>     *             vyvolana v pripade, ze se nenaleznou nektere pomocne tridy</i>
<i>     */</i>
    abstract public Bytecode <strong>generateBytecode</strong>(ConstPool constPool) throws NotFoundException;
}
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. První zpùsob výpisu øetìzce &ndash; vyu¾ití <strong>Bytecode.addPrintln()</strong></h2>

<p>První zpùsob konstrukce bajtkódu metody, jejím¾ úkolem bude výpis øetìzce,
je velmi jednoduchý, proto¾e zde vyu¾ijeme volání
<strong>Bytecode.addPrintln()</strong>. Výpis øetìzce je toti¾ tak èasto
provádìnou funkcí, ¾e se autoøi nástroje <i>Javassist</i> rozhodli nám
zjednodu¹it práci a vytvoøit v¹echny tøi potøebné instrukce s&nbsp;vyu¾itím
volání této jediné metody. Z&nbsp;tohoto dùvodu je mo¾né první verzi generátoru
bajtkódu napsat velmi snadno, ov¹em pov¹imnìte si, ¾e nesmíme zapomenout na
konec bajtkódu vlo¾it instrukci <strong>return</strong> zaji¹»ující korektní
návrat z&nbsp;metody. Ve skuteènosti nás v¹ak <i>Javassist</i> nijak pøi tvorbì
bajtkódu nekontroluje, tak¾e se mù¾eme pokusit tuto instrukci odstranit a
sledovat, jak bude s&nbsp;takto vytvoøeným bajtkódem &bdquo;spokojen&ldquo;
virtuální stroj Javy:</p>

<pre>
<i>/**</i>
<i> * Generator bajtkodu prvni verze metody hello().</i>
<i> */</i>
class <strong>HelloMethodGenerator1</strong> extends <strong>BytecodeGenerator</strong> {
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni bajtkodu predstavujiciho sekvenci instrukci pro metodu</i>
<i>     * void hello1().</i>
<i>     * </i>
<i>     * @param constPool</i>
<i>     *            tabulka konstant pouzivana metodou</i>
<i>     * @return bajtkod predstavujici sekvenci instrukci pro vytvorenou metodu</i>
<i>     */</i>
    @Override
    public Bytecode <strong>generateBytecode</strong>(ConstPool constPool) {
        final int stackSize = 1;
        final int localVars = 0;
&nbsp;
<i>        // vygenerovat bajtkod</i>
        Bytecode bytecode = new Bytecode(constPool, stackSize, localVars);
&nbsp;
<i>        // instrukce pro tisk retezce lze vygenerovat (pridat do bajtkodu)</i>
<i>        // velmi jednoduse s vyuzitim metody Bytecode.addPrintln()</i>
        bytecode.addPrintln("Hello world #1!");
&nbsp;
<i>        // dulezite je taktez spravne ukoncit volani metody a zabezpecit</i>
<i>        // navrat do metody volajici</i>
        bytecode.addOpcode(Opcode.RETURN);
&nbsp;
<i>        // vratit prave vytvoreny bajtkod</i>
        return bytecode;
    }
&nbsp;
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Druhý zpùsob výpisu øetìzce &ndash; vyu¾ití <strong>Bytecode.addGetstatic()</strong>, <strong>Bytecode.addLdc()</strong> a <strong>Bytecode.addInvokevirtual()</strong></h2>

<p>Druhý zpùsob konstrukce bajtkódu metody, jejím¾ úkolem bude výpis øetìzce,
je ji¾ ponìkud komplikovanìj¹í, jeliko¾ zde ji¾ budeme zapisovat v¹echny tøi
instrukce explicitnì. Nejprve je v¹ak nutné do constant poolu vlo¾it nový
øetìzec, co¾ zaji¹»uje volání <strong>ConstPool.addStringInfo()</strong>.
Návratovou hodnotou tohoto volání je index nové polo¾ky ulo¾ené do constant
poolu; tento index je nutné si zapamatovat, nebo» ho vyu¾ijeme dále. Dal¹í
postup je ji¾ pomìrnì pøímoèarý, nebo» nástroj <i>Javassist</i> nabízí metody
<strong>Bytecode.addGetstatic()</strong>, <strong>Bytecode.addLdc()</strong> a
<strong>Bytecode.addInvokevirtual()</strong>. Tyto tøi metody jsou pøetí¾ené a
my zde vyu¾ijeme varianty, v&nbsp;ní¾ jsou plná jména tøíd a signatury metod
reprezentovány øetìzci. Internì musí <i>Javassist</i> tyto øetìzce takté¾
ulo¾it do constant poolu, co¾ jsme ostatnì ji¾ vidìli <a href="#k02">ve druhé
kapitole</a>:</p>

<pre>
<i>/**</i>
<i> * Generator bajtkodu druhe verze metody hello().</i>
<i> */</i>
class <strong>HelloMethodGenerator2</strong> extends <strong>BytecodeGenerator</strong> {
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni bajtkodu predstavujiciho sekvenci instrukci pro metodu</i>
<i>     * void hello2().</i>
<i>     * </i>
<i>     * @param constPool</i>
<i>     *            tabulka konstant pouzivana metodou</i>
<i>     * @return bajtkod predstavujici sekvenci instrukci pro vytvorenou metodu</i>
<i>     */</i>
    @Override
    public Bytecode <strong>generateBytecode</strong>(ConstPool constPool) {
        final int stackSize = 1;
        final int localVars = 0;
&nbsp;
<i>        // pridat do konstant poolu novy retezec</i>
        final int stringConstant = constPool.addStringInfo("Hello world #2!");
&nbsp;
<i>        // vygenerovat bajtkod</i>
        Bytecode bytecode = new Bytecode(constPool, stackSize, localVars);
&nbsp;
<i>        // vygenerovani trojice instrukci:</i>
<i>        // getstatic</i>
<i>        // ldc</i>
<i>        // invokevirtual</i>
        bytecode.addGetstatic("java.lang.System", "err", "Ljava/io/PrintStream;");
        bytecode.addLdc(stringConstant);
        bytecode.addInvokevirtual("java.io.PrintStream", "println", "(Ljava/lang/String;)V");
&nbsp;
<i>        // dulezite je taktez spravne ukoncit volani metody a zabezpecit</i>
<i>        // navrat do metody volajici</i>
        bytecode.addOpcode(Opcode.RETURN);
&nbsp;
<i>        // vratit prave vytvoreny bajtkod</i>
        return bytecode;
    }
&nbsp;
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Tøetí zpùsob výpisu øetìzce &ndash; pou¾ití tøídy <strong>CtClass</strong> namísto signatur tøíd a metod</h2>

<p>V&nbsp;pøedchozí kapitole jsme si uvedli jeden ze zpùsobù vyu¾ití metod
<strong>Bytecode.addGetstatic()</strong>, <strong>Bytecode.addLdc()</strong> a
<strong>Bytecode.addInvokevirtual()</strong>. Pov¹imnìte si, ¾e metodì
<strong>Bytecode.addGetstatic()</strong> bylo nutné pøedat jméno tøídy se
statickým atributem, jméno atributu i jeho typ (ve formì signatury). Podobnì
bylo nutné metodì <strong>Bytecode.addInvokevirtual()</strong> pøedat jméno
tøídy, jméno volané metody a její plnou signaturu (návratový typ i typy
parametrù). Existují situace, kdy je pøedávání tìchto øetìzcù vhodné &ndash;
mù¾e se napøíklad jednat o specializované pøekladaèe &ndash; ov¹em nìkdy je
výhodnìj¹í pou¾ít typovì bezpeènìj¹í pøístup. Ve skuteènosti je toti¾ mo¾né
pou¾ít i alternativní podobu metod <strong>Bytecode.addGetstatic()</strong> a
<strong>Bytecode.addInvokevirtual()</strong>. Tìmto metodám se pøedají
pøíslu¹né instance tøídy typu <strong>CtClass</strong> (ty lze vytvoøit rùzným
zpùsobem) a parametry èi návratový typ u <strong>addInvokevirtual()</strong>
mù¾e být takté¾ reprezentován instancemi tøídy <strong>CtClass</strong>.
Základní zpùsob vyu¾ití je vidìt ze tøetí verze generátoru metody typu
&bdquo;Hello world&ldquo;:</p>

<pre>
<i>/**</i>
<i> * Generator bajtkodu treti verze metody hello().</i>
<i> */</i>
class <strong>HelloMethodGenerator3</strong> extends <strong>BytecodeGenerator</strong> {
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni bajtkodu predstavujiciho sekvenci instrukci pro metodu</i>
<i>     * void hello3().</i>
<i>     * </i>
<i>     * @param constPool</i>
<i>     *            tabulka konstant pouzivana metodou</i>
<i>     * @return bajtkod predstavujici sekvenci instrukci pro vytvorenou metodu</i>
<i>     */</i>
    @Override
    public Bytecode <strong>generateBytecode</strong>(ConstPool constPool) throws NotFoundException {
        final int stackSize = 1;
        final int localVars = 0;
&nbsp;
<i>        // pridat do konstant poolu novy retezec</i>
        final int stringConstant = constPool.addStringInfo("Hello world #3!");
&nbsp;
<i>        // ziskat vychozi class pool</i>
        final ClassPool pool = ClassPool.getDefault();
&nbsp;
<i>        // pripravit obrazy trid, s nimiz se bude dale pracovat</i>
        final CtClass classJavaLangSystem = pool.get("java.lang.System");
        final CtClass classJavaIoPrintStream = pool.get("java.io.PrintStream");
        final CtClass classString = pool.get("java.lang.String");
&nbsp;
<i>        // parametry vytvorene metody</i>
        final CtClass params[] = {classString};
&nbsp;
<i>        // vygenerovat bajtkod</i>
        Bytecode bytecode = new Bytecode(constPool, stackSize, localVars);
&nbsp;
<i>        // vygenerovani trojice instrukci:</i>
<i>        // getstatic</i>
<i>        // ldc</i>
<i>        // invokevirtual</i>
        bytecode.addGetstatic(classJavaLangSystem, "err", "Ljava/io/PrintStream;");
        bytecode.addLdc(stringConstant);
        bytecode.addInvokevirtual(classJavaIoPrintStream, "println", CtClass.voidType, params);
&nbsp;
<i>        // dulezite je taktez spravne ukoncit volani metody a zabezpecit</i>
<i>        // navrat do metody volajici</i>
        bytecode.addOpcode(Opcode.RETURN);
&nbsp;
<i>        // vratit prave vytvoreny bajtkod</i>
        return bytecode;
    }
&nbsp;
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Ètvrtý zpùsob výpisu øetìzce &ndash; pøevod instance tøídy <strong>Class</strong> na <strong>CtClass</strong></h2>

<p>Existuje dokonce je¹tì jednodu¹¹í zpùsob, jak získat instance tøídy
<strong>CtClass</strong> pøedstavující obrazy tøíd <strong>System</strong>,
<strong>PrintStream</strong> èi <strong>String</strong>. Jeden
z&nbsp;konstruktorù tøídy <strong>CtClass</strong> toti¾ jako svùj argument
akceptuje i tøídu <strong>java.lang.Class</strong>, její¾ instanci lze získat
pro ka¾dou tøídu èi pro ka¾dé rozhraní v&nbsp;bì¾ícím virtuálním stroji Javy.
Pro instanci libovolné tøídy staèí pou¾ít volání
<strong>Object.getClass()</strong>, pro tøídu samotnou (tedy pro datový typ)
pak existuje literál .class (Foo.class, X.class, String.class). To tedy
znamená, ¾e vùbec nemusíme v&nbsp;na¹em kódu explicitnì pou¾ívat øetìzcovou
podobu jmen tøíd &bdquo;java.lang.System&ldquo;,
&bdquo;java.io.PrintStream&ldquo; èi &bdquo;java.lang.String&ldquo;, proto¾e
lze snadno získat objety typu <strong>Class</strong> a z&nbsp;nich pak vytvoøit
objekty typu <strong>CtClass</strong>:</p>

<pre>
<i>/**</i>
<i> * Generator bajtkodu ctvrte verze metody hello().</i>
<i> */</i>
class <strong>HelloMethodGenerator4</strong> extends <strong>BytecodeGenerator</strong> {
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni bajtkodu predstavujiciho sekvenci instrukci pro metodu</i>
<i>     * void hello4().</i>
<i>     * </i>
<i>     * @param constPool</i>
<i>     *            tabulka konstant pouzivana metodou</i>
<i>     * @return bajtkod predstavujici sekvenci instrukci pro vytvorenou metodu</i>
<i>     */</i>
    @Override
    public Bytecode <strong>generateBytecode</strong>(ConstPool constPool) throws NotFoundException {
        final int stackSize = 1;
        final int localVars = 0;
&nbsp;
<i>        // pridat do konstant poolu novy retezec</i>
        final int stringConstant = constPool.addStringInfo("Hello world #4!");
&nbsp;
<i>        // ziskat vychozi class pool</i>
        ClassPool pool = ClassPool.getDefault();
&nbsp;
<i>        // pripravit obrazy trid, s nimiz se bude dale pracovat</i>
&nbsp;
<i>        // java.lang.System</i>
        String classJavaLangSystemName = System.class.getName();
        CtClass classJavaLangSystem = pool.get(classJavaLangSystemName);
&nbsp;
<i>        // java.lang.System.err</i>
        String classJavaIoPrintStreamName = System.err.getClass().getName();
        CtClass classJavaIoPrintStream = pool.get(classJavaIoPrintStreamName);
&nbsp;
<i>        // java.lang.String</i>
        String classStringName = "foo".getClass().getName();
        CtClass classString = pool.get(classStringName);
&nbsp;
<i>        // parametry vytvorene metody</i>
        CtClass params[] = {classString};
&nbsp;
<i>        // vygenerovat bajtkod</i>
        Bytecode bytecode = new Bytecode(constPool, stackSize, localVars);
&nbsp;
<i>        // vygenerovani trojice instrukci:</i>
<i>        // getstatic</i>
<i>        // ldc</i>
<i>        // invokevirtual</i>
        bytecode.addGetstatic(classJavaLangSystem, "err", "Ljava/io/PrintStream;");
        bytecode.addLdc(stringConstant);
        bytecode.addInvokevirtual(classJavaIoPrintStream, "println", CtClass.voidType, params);
&nbsp;
<i>        // dulezite je taktez spravne ukoncit volani metody a zabezpecit</i>
<i>        // navrat do metody volajici</i>
        bytecode.addOpcode(Opcode.RETURN);
&nbsp;
<i>        // vratit prave vytvoreny bajtkod</i>
        return bytecode;
    }
&nbsp;
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Spu¹tìní metod právì vytvoøené tøídy ve stejném virtuálním stroji</h2>

<p>Prozatím v¹echny tøídy (a jejich metody), které jsme generovali
s&nbsp;vyu¾itím nástroje <i>Javassist</i>, byly spou¹tìny mimo virtuální stroj
Javy, v&nbsp;nìm¾ byl spu¹tìn tento nástroj. To je sice v&nbsp;mnoha pøípadech
v&nbsp;poøádku, zejména tehdy, pokud potøebujeme nìjakou tøídu vytvoøit èi
modifikovat pouze jednou, ov¹em ve chvíli, kdy je nutné
vytvoøenou/modifikovanou tøídu ihned pou¾ít by bylo vhodnìj¹í, aby se tøída
naèetla a inicializovala ve stejném virtuálním stroji. I tuto mo¾nost nástroj
<i>Javassist</i> programátorùm nabízí, tak¾e je ho mo¾né vyu¾ít napøíklad u
aspektovì orientovaného programování atd. Podívejme se nyní na základní zpùsob
inicializace vytvoøené tøídy a spu¹tìní jejich metod. Pou¾ijeme pøitom dvì
techniky &ndash; pøevod instance <strong>CtClass</strong> na
<strong>java.lang.Class</strong>, co¾ zaji¹»uje metoda
<strong>CtClass.toClass()</strong> (toto není tak jednoduché, jak by se mohlo
na první pohled zdát, proto¾e <i>Javassist+JVM</i> zde musí provést velké
mno¾ství inicializaèních operací):</p>

<pre>
<i>    /**</i>
<i>     * Spusteni vsech metod typu "hello*()"</i>
<i>     * </i>
<i>     * @param generatedClass</i>
<i>     *            Trida vygenerovana nastrojem Javassist.</i>
<i>     * </i>
<i>     * @throws CannotCompileException</i>
<i>     *             muze byt vyhozena v prubehu prevodu CtClass na Class</i>
<i>     * @throws InstantiationException</i>
<i>     *             muze byt vyhozena v prubehu prevodu CtClass na Class</i>
<i>     * @throws IllegalAccessException</i>
<i>     *             muze byt vyhozena v prubehu spusteni vybrane metody</i>
<i>     * @throws NoSuchMethodException</i>
<i>     *             muze byt vyhozena v prubehu spusteni vybrane metody</i>
<i>     * @throws InvocationTargetException</i>
<i>     *             muze byt vyhozena v prubehu spusteni vybrane metody</i>
<i>     */</i>
    private static void <strong>runMethodsFromNewClass</strong>(CtClass generatedClass) throws CannotCompileException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {
        Class c = generatedClass.toClass();
        for (int i = 1; i &lt;= 4; i++) {
            invokeStaticMethod(c, "hello" + i);
        }
    }
</pre>

<p>Druhou zde pou¾itou technikou je zavolání metody s&nbsp;vyu¾itím
<i>reflection API</i>. Vzhledem k&nbsp;tomu, ¾e v¹echny ètyøi spou¹tìné metody
jsou statické a souèasnì i bezparametrické, nepøedává se ve volání
<strong>Method.invoke()</strong> ¾ádná hodnota (ono <strong>null</strong> pouze
nahrazuje hodnotu <strong>this</strong> pou¾itou u nestatických metod):</p>

<pre>
<i>    /**</i>
<i>     * Zavolani vybrane staticke metody</i>
<i>     * </i>
<i>     * @param anyClass</i>
<i>     *            trida, v niz je staticka metoda deklarovana</i>
<i>     * @param methodName</i>
<i>     *            jmeno staticke metody</i>
<i>     * @throws IllegalAccessException</i>
<i>     *             muze byt vyhozena v prubehu spusteni vybrane metody</i>
<i>     * @throws NoSuchMethodException</i>
<i>     *             muze byt vyhozena v prubehu spusteni vybrane metody</i>
<i>     * @throws InvocationTargetException</i>
<i>     *             muze byt vyhozena v prubehu spusteni vybrane metody</i>
<i>     */</i>
    @SuppressWarnings("unchecked")
    private static void <strong>invokeStaticMethod</strong>(Class anyClass, String methodName) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
        Method hello = anyClass.getMethod(methodName);
        hello.invoke(null);
    }
</pre>

<p>Existují ale i lep¹í zpùsoby spu¹tìní metod vytvoøené tøídy, v&nbsp;ideálním
pøípadì lze nadeklarovat rozhraní èi abstraktní rodièovskou tøídu a provést
spu¹tìní pøímo, tj.&nbsp;bez pou¾ití <i>reflection API</i>.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Zdrojový kód demonstraèního pøíkladu <strong>ClassGenerationTest8</strong></h2>

<p>Ve¹keré u¾ivatelské metody i pìtice pomocných tøíd je souèástí dne¹ního
prvního a souèasnì i jediného demonstraèního pøíkladu nazvaného
<strong>ClassGenerationTest8</strong>. V&nbsp;tomto pøíkladu se provede trojice
operací. Nejdøíve se vytvoøí nová tøída nazvaná
<strong>GeneratedClass8</strong> s&nbsp;pìticí vygenerovaných metod
<strong>main()</strong>, <strong>hello1()</strong> a¾ <strong>hello4()</strong>
a následnì se struktura celé této tøídy vypí¹e na standardní výstup
s&nbsp;vyu¾itím stejného postupu, s&nbsp;jakým jsme se seznámili ji¾
v&nbsp;pøedchozí èásti tohoto seriálu &ndash; zpìtným pøeètením kódu ka¾dé
metody s&nbsp;následnou iterací pøes získaný kód a výpisem symbolických jmen
jednotlivých instrukcí. Posléze se novì vytvoøená tøída
<strong>GeneratedClass8</strong> naète do JVM a v¹echny ètyøi statické metody
<strong>hello1()</strong> a¾ <strong>hello4()</strong> se spustí. Následuje
výpis celého zdrojového kódu tohoto demonstraèního pøíkladu:</p>

<pre>
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
&nbsp;
import javassist.CannotCompileException;
import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtMethod;
import javassist.Modifier;
import javassist.NotFoundException;
import javassist.bytecode.BadBytecode;
import javassist.bytecode.Bytecode;
import javassist.bytecode.CodeAttribute;
import javassist.bytecode.CodeIterator;
import javassist.bytecode.ConstPool;
import javassist.bytecode.MethodInfo;
import javassist.bytecode.Mnemonic;
import javassist.bytecode.Opcode;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Abstraktni trida, kterou mohou rozsirit vsechny tridy urcenyme pro generovani bajtkodu.</i>
<i> */</i>
abstract class <strong>BytecodeGenerator</strong> {
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni bajtkodu predstavujiciho sekvenci instrukci pro libovolnou</i>
<i>     * metodu.</i>
<i>     * </i>
<i>     * @param constPool</i>
<i>     *            tabulka konstant pouzivana metodou</i>
<i>     * @return bajtkod predstavujici sekvenci instrukci pro vytvorenou metodu</i>
<i>     * @throws NotFoundException</i>
<i>     *             vyvolana v pripade, ze se nenaleznou nektere pomocne tridy</i>
<i>     */</i>
    abstract public Bytecode <strong>generateBytecode</strong>(ConstPool constPool) throws NotFoundException;
}
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Generator bajtkodu prvni verze metody hello().</i>
<i> */</i>
class <strong>HelloMethodGenerator1</strong> extends <strong>BytecodeGenerator</strong> {
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni bajtkodu predstavujiciho sekvenci instrukci pro metodu</i>
<i>     * void hello1().</i>
<i>     * </i>
<i>     * @param constPool</i>
<i>     *            tabulka konstant pouzivana metodou</i>
<i>     * @return bajtkod predstavujici sekvenci instrukci pro vytvorenou metodu</i>
<i>     */</i>
    @Override
    public Bytecode <strong>generateBytecode</strong>(ConstPool constPool) {
        final int stackSize = 1;
        final int localVars = 0;
&nbsp;
<i>        // vygenerovat bajtkod</i>
        Bytecode bytecode = new Bytecode(constPool, stackSize, localVars);
&nbsp;
<i>        // instrukce pro tisk retezce lze vygenerovat (pridat do bajtkodu)</i>
<i>        // velmi jednoduse s vyuzitim metody Bytecode.addPrintln()</i>
        bytecode.addPrintln("Hello world #1!");
&nbsp;
<i>        // dulezite je taktez spravne ukoncit volani metody a zabezpecit</i>
<i>        // navrat do metody volajici</i>
        bytecode.addOpcode(Opcode.RETURN);
&nbsp;
<i>        // vratit prave vytvoreny bajtkod</i>
        return bytecode;
    }
&nbsp;
}
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Generator bajtkodu druhe verze metody hello().</i>
<i> */</i>
class <strong>HelloMethodGenerator2</strong> extends <strong>BytecodeGenerator</strong> {
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni bajtkodu predstavujiciho sekvenci instrukci pro metodu</i>
<i>     * void hello2().</i>
<i>     * </i>
<i>     * @param constPool</i>
<i>     *            tabulka konstant pouzivana metodou</i>
<i>     * @return bajtkod predstavujici sekvenci instrukci pro vytvorenou metodu</i>
<i>     */</i>
    @Override
    public Bytecode <strong>generateBytecode</strong>(ConstPool constPool) {
        final int stackSize = 1;
        final int localVars = 0;
&nbsp;
<i>        // pridat do konstant poolu novy retezec</i>
        final int stringConstant = constPool.addStringInfo("Hello world #2!");
&nbsp;
<i>        // vygenerovat bajtkod</i>
        Bytecode bytecode = new Bytecode(constPool, stackSize, localVars);
&nbsp;
<i>        // vygenerovani trojice instrukci:</i>
<i>        // getstatic</i>
<i>        // ldc</i>
<i>        // invokevirtual</i>
        bytecode.addGetstatic("java.lang.System", "err", "Ljava/io/PrintStream;");
        bytecode.addLdc(stringConstant);
        bytecode.addInvokevirtual("java.io.PrintStream", "println", "(Ljava/lang/String;)V");
&nbsp;
<i>        // dulezite je taktez spravne ukoncit volani metody a zabezpecit</i>
<i>        // navrat do metody volajici</i>
        bytecode.addOpcode(Opcode.RETURN);
&nbsp;
<i>        // vratit prave vytvoreny bajtkod</i>
        return bytecode;
    }
&nbsp;
}
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Generator bajtkodu treti verze metody hello().</i>
<i> */</i>
class <strong>HelloMethodGenerator3</strong> extends <strong>BytecodeGenerator</strong> {
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni bajtkodu predstavujiciho sekvenci instrukci pro metodu</i>
<i>     * void hello3().</i>
<i>     * </i>
<i>     * @param constPool</i>
<i>     *            tabulka konstant pouzivana metodou</i>
<i>     * @return bajtkod predstavujici sekvenci instrukci pro vytvorenou metodu</i>
<i>     */</i>
    @Override
    public Bytecode <strong>generateBytecode</strong>(ConstPool constPool) throws NotFoundException {
        final int stackSize = 1;
        final int localVars = 0;
&nbsp;
<i>        // pridat do konstant poolu novy retezec</i>
        final int stringConstant = constPool.addStringInfo("Hello world #3!");
&nbsp;
<i>        // ziskat vychozi class pool</i>
        final ClassPool pool = ClassPool.getDefault();
&nbsp;
<i>        // pripravit obrazy trid, s nimiz se bude dale pracovat</i>
        final CtClass classJavaLangSystem = pool.get("java.lang.System");
        final CtClass classJavaIoPrintStream = pool.get("java.io.PrintStream");
        final CtClass classString = pool.get("java.lang.String");
&nbsp;
<i>        // parametry vytvorene metody</i>
        final CtClass params[] = {classString};
&nbsp;
<i>        // vygenerovat bajtkod</i>
        Bytecode bytecode = new Bytecode(constPool, stackSize, localVars);
&nbsp;
<i>        // vygenerovani trojice instrukci:</i>
<i>        // getstatic</i>
<i>        // ldc</i>
<i>        // invokevirtual</i>
        bytecode.addGetstatic(classJavaLangSystem, "err", "Ljava/io/PrintStream;");
        bytecode.addLdc(stringConstant);
        bytecode.addInvokevirtual(classJavaIoPrintStream, "println", CtClass.voidType, params);
&nbsp;
<i>        // dulezite je taktez spravne ukoncit volani metody a zabezpecit</i>
<i>        // navrat do metody volajici</i>
        bytecode.addOpcode(Opcode.RETURN);
&nbsp;
<i>        // vratit prave vytvoreny bajtkod</i>
        return bytecode;
    }
&nbsp;
}
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Generator bajtkodu ctvrte verze metody hello().</i>
<i> */</i>
class <strong>HelloMethodGenerator4</strong> extends <strong>BytecodeGenerator</strong> {
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni bajtkodu predstavujiciho sekvenci instrukci pro metodu</i>
<i>     * void hello4().</i>
<i>     * </i>
<i>     * @param constPool</i>
<i>     *            tabulka konstant pouzivana metodou</i>
<i>     * @return bajtkod predstavujici sekvenci instrukci pro vytvorenou metodu</i>
<i>     */</i>
    @Override
    public Bytecode <strong>generateBytecode</strong>(ConstPool constPool) throws NotFoundException {
        final int stackSize = 1;
        final int localVars = 0;
&nbsp;
<i>        // pridat do konstant poolu novy retezec</i>
        final int stringConstant = constPool.addStringInfo("Hello world #4!");
&nbsp;
<i>        // ziskat vychozi class pool</i>
        ClassPool pool = ClassPool.getDefault();
&nbsp;
<i>        // pripravit obrazy trid, s nimiz se bude dale pracovat</i>
&nbsp;
<i>        // java.lang.System</i>
        String classJavaLangSystemName = System.class.getName();
        CtClass classJavaLangSystem = pool.get(classJavaLangSystemName);
&nbsp;
<i>        // java.lang.System.err</i>
        String classJavaIoPrintStreamName = System.err.getClass().getName();
        CtClass classJavaIoPrintStream = pool.get(classJavaIoPrintStreamName);
&nbsp;
<i>        // java.lang.String</i>
        String classStringName = "foo".getClass().getName();
        CtClass classString = pool.get(classStringName);
&nbsp;
<i>        // parametry vytvorene metody</i>
        CtClass params[] = {classString};
&nbsp;
<i>        // vygenerovat bajtkod</i>
        Bytecode bytecode = new Bytecode(constPool, stackSize, localVars);
&nbsp;
<i>        // vygenerovani trojice instrukci:</i>
<i>        // getstatic</i>
<i>        // ldc</i>
<i>        // invokevirtual</i>
        bytecode.addGetstatic(classJavaLangSystem, "err", "Ljava/io/PrintStream;");
        bytecode.addLdc(stringConstant);
        bytecode.addInvokevirtual(classJavaIoPrintStream, "println", CtClass.voidType, params);
&nbsp;
<i>        // dulezite je taktez spravne ukoncit volani metody a zabezpecit</i>
<i>        // navrat do metody volajici</i>
        bytecode.addOpcode(Opcode.RETURN);
&nbsp;
<i>        // vratit prave vytvoreny bajtkod</i>
        return bytecode;
    }
&nbsp;
}
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Test moznosti nastroje Javassist - vygenerovani jednoduche tridy</i>
<i> * s metodou main a nekolika dalsimi statickymi bezparametrickymi metodami</i>
<i> * "hello*()"</i>
<i> * Jakmile je trida vytvorena, je nactena do JVM a jeji staticke metody jsou</i>
<i> * spusteny. </i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>ClassGenerationTest8</strong> {
&nbsp;
<i>    /**</i>
<i>     * Jmeno vygenerovane tridy.</i>
<i>     */</i>
    private static final String <strong>GENERATED_CLASS_NAME</strong> = "GeneratedClass8";
&nbsp;
<i>    /**</i>
<i>     * Zdrojovy kod metody main(), ktery bude nasledne zkompilovan</i>
<i>     * do bajtkodu a zakomponovan do vytvorene tridy.</i>
<i>     */</i>
    private static final String <strong>MAIN_METHOD_SOURCE_TEXT</strong> =
        "public static void main(String[] args)" +
        "{" +
        "    hello1();" +
        "    hello2();" +
        "    hello3();" +
        "    hello4();" +
        "}";
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni metody main() z jejiho zdrojoveho kodu.</i>
<i>     * </i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu</i>
<i>     */</i>
    private static void <strong>addMethodMain</strong>(CtClass generatedClass) throws CannotCompileException {
        CtMethod methodMain = CtMethod.make(MAIN_METHOD_SOURCE_TEXT, generatedClass);
        generatedClass.addMethod(methodMain);
    }
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni metody public static void hello*().</i>
<i>     * </i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @param methodName</i>
<i>     *            jmeno vytvarene metody</i>
<i>     * @param generator</i>
<i>     *            generator bajtkodu vytvarene metody</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu nebo strukturalni chyby v bajtkodu</i>
<i>     * @throws NotFoundException</i>
<i>     *             vyhozena v pripade, ze nebyla nalezena nektera pomocna trida</i>
<i>     */</i>
    private static void <strong>constructMethodHello</strong>(CtClass generatedClass, String methodName, BytecodeGenerator generator) throws CannotCompileException, NotFoundException {
        MethodInfo methodInfo = prepareMethod(generatedClass, methodName);
        ConstPool constPool = methodInfo.getConstPool();
        Bytecode bytecode = generator.generateBytecode(constPool);
        setCodeAttributeForMethod(methodInfo, bytecode);
    }
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni kostry metody a vraceni objektu typu MethodInfo.</i>
<i>     *</i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @param methodName</i>
<i>     *            jmeno vytvarene metody</i>
<i>     * @return</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu nebo strukturalni chyby v bajtkodu</i>
<i>     */</i>
    private static MethodInfo <strong>prepareMethod</strong>(CtClass generatedClass, String methodName) throws CannotCompileException {
        CtClass returnType = CtClass.voidType;
        CtClass[] parameterTypes = {};
&nbsp;
<i>        // u metody je nutne znat jeji jmeno, navratovou hodnotu i typy parametru</i>
        CtMethod helloMethod = new CtMethod(returnType, methodName, parameterTypes, generatedClass);
&nbsp;
<i>        // zmena modifikatoru</i>
        helloMethod.setModifiers(Modifier.STATIC | Modifier.PUBLIC);
&nbsp;
<i>        // pridani metody do tridy</i>
        generatedClass.addMethod(helloMethod);
&nbsp;
<i>        // ziskani informace o metoda</i>
        MethodInfo methodInfo = helloMethod.getMethodInfo();
        return methodInfo;
    }
&nbsp;
<i>    /**</i>
<i>     * Nastaveni atributu "Code" s bajktodem pro vybranou metodu.</i>
<i>     * </i>
<i>     * @param methodInfo</i>
<i>     *            objekt typu MethodInfo</i>
<i>     * @param bytecode</i>
<i>     *            bajtkod vytvarene metody.</i>
<i>     */</i>
    private static void <strong>setCodeAttributeForMethod</strong>(MethodInfo methodInfo, Bytecode bytecode) {
        CodeAttribute codeAttribute = bytecode.toCodeAttribute();
        methodInfo.setCodeAttribute(codeAttribute);
    }
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni tridy s metodou main().</i>
<i>     * </i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu metody main()</i>
<i>     *             nebo pri strukturalni chybe bajtkodu metod hello1()-hello4().</i>
<i>     * @throws IOException</i>
<i>     *             pokud dojde k chybe pri zapisu bajtkodu na disk</i>
<i>     * @throws NotFoundException</i>
<i>     *             pokud dojde k chybe pri zapisu bajtkodu na disk</i>
<i>     */</i>
    private static CtClass <strong>generateClass</strong>() throws CannotCompileException, NotFoundException, IOException {
<i>        // ziskat vychozi class pool</i>
        ClassPool pool = ClassPool.getDefault();
&nbsp;
<i>        // vytvoreni nove verejne tridy</i>
        CtClass generatedClass = pool.makeClass(GENERATED_CLASS_NAME);
&nbsp;
<i>        // konstrukce nove metody void hello1()</i>
        constructMethodHello(generatedClass, "hello1", new HelloMethodGenerator1());
&nbsp;
<i>        // konstrukce nove metody void hello2()</i>
        constructMethodHello(generatedClass, "hello2", new HelloMethodGenerator2());
&nbsp;
<i>        // konstrukce nove metody void hello3()</i>
        constructMethodHello(generatedClass, "hello3", new HelloMethodGenerator3());
&nbsp;
<i>        // konstrukce nove metody void hello4()</i>
        constructMethodHello(generatedClass, "hello4", new HelloMethodGenerator4());
&nbsp;
<i>        // pridani metody do teto tridy</i>
        addMethodMain(generatedClass);
&nbsp;
<i>        // ulozeni bajtkodu na disk</i>
        generatedClass.writeFile();
&nbsp;
        return generatedClass;
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis struktury vybrane metody.</i>
<i>     * </i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @param methodName</i>
<i>     *            jmeno metody, jejiz struktura se ma vypsat</i>
<i>     * @throws NotFoundException</i>
<i>     *             vyhozena, pokud metoda nebyla nalezena</i>
<i>     * @throws BadBytecode</i>
<i>     *             vyhozena, pokud se nalezne neplatna instrukce v bytekodu</i>
<i>     */</i>
    private static void <strong>printMethodStructure</strong>(CtClass generatedClass, String methodName) throws NotFoundException, BadBytecode {
        System.out.println("Method '" + methodName + "' structure:");
        CtMethod method = generatedClass.getDeclaredMethod(methodName);
        if (method == null) {
            System.out.println("   not found!");
            return;
        }
        MethodInfo methodInfo = method.getMethodInfo();
        System.out.println("    real name:    " + methodInfo.getName());
        System.out.println("    descriptor:   " + methodInfo.getDescriptor());
        System.out.println("    access flags: " + Modifier.toString(methodInfo.getAccessFlags()));
        System.out.println("    method body:");
        printMethodBody(methodInfo);
        System.out.println();
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis instrukci tvoricich telo vybrane metody.</i>
<i>     *</i>
<i>     * @throws NotFoundException</i>
<i>     *             vyhozena, pokud metoda nebyla nalezena</i>
<i>     * @throws BadBytecode</i>
<i>     *             vyhozena, pokud se nalezne neplatna instrukce v bytekodu</i>
<i>     */</i>
    private static void <strong>printMethodBody</strong>(MethodInfo methodInfo) throws BadBytecode {
        CodeAttribute ca = methodInfo.getCodeAttribute();
        CodeIterator iterator = ca.iterator();
        while (iterator.hasNext()) {
            int index = iterator.next();
            int opcode = iterator.byteAt(index);
            System.out.println("        " + Mnemonic.OPCODE[opcode]);
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis struktury vybranych metod z generovane tridy.</i>
<i>     * </i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws NotFoundException</i>
<i>     *             vyhozena, pokud metoda nebyla nalezena</i>
<i>     * @throws BadBytecode </i>
<i>     */</i>
    private static void <strong>printMethodStructures</strong>(CtClass generatedClass) throws NotFoundException, BadBytecode {
        printMethodStructure(generatedClass, "main");
        printMethodStructure(generatedClass, "hello1");
        printMethodStructure(generatedClass, "hello2");
        printMethodStructure(generatedClass, "hello3");
        printMethodStructure(generatedClass, "hello4");
    }
&nbsp;
<i>    /**</i>
<i>     * Spusteni vsech metod typu "hello*()"</i>
<i>     * </i>
<i>     * @param generatedClass</i>
<i>     *            Trida vygenerovana nastrojem Javassist.</i>
<i>     * </i>
<i>     * @throws CannotCompileException</i>
<i>     *             muze byt vyhozena v prubehu prevodu CtClass na Class</i>
<i>     * @throws InstantiationException</i>
<i>     *             muze byt vyhozena v prubehu prevodu CtClass na Class</i>
<i>     * @throws IllegalAccessException</i>
<i>     *             muze byt vyhozena v prubehu spusteni vybrane metody</i>
<i>     * @throws NoSuchMethodException</i>
<i>     *             muze byt vyhozena v prubehu spusteni vybrane metody</i>
<i>     * @throws InvocationTargetException</i>
<i>     *             muze byt vyhozena v prubehu spusteni vybrane metody</i>
<i>     */</i>
    private static void <strong>runMethodsFromNewClass</strong>(CtClass generatedClass) throws CannotCompileException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {
        Class c = generatedClass.toClass();
        for (int i = 1; i &lt;= 4; i++) {
            invokeStaticMethod(c, "hello" + i);
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Zavolani vybrane staticke metody</i>
<i>     * </i>
<i>     * @param anyClass</i>
<i>     *            trida, v niz je staticka metoda deklarovana</i>
<i>     * @param methodName</i>
<i>     *            jmeno staticke metody</i>
<i>     * @throws IllegalAccessException</i>
<i>     *             muze byt vyhozena v prubehu spusteni vybrane metody</i>
<i>     * @throws NoSuchMethodException</i>
<i>     *             muze byt vyhozena v prubehu spusteni vybrane metody</i>
<i>     * @throws InvocationTargetException</i>
<i>     *             muze byt vyhozena v prubehu spusteni vybrane metody</i>
<i>     */</i>
    @SuppressWarnings("unchecked")
    private static void <strong>invokeStaticMethod</strong>(Class anyClass, String methodName) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
        Method hello = anyClass.getMethod(methodName);
        hello.invoke(null);
    }
&nbsp;
<i>    /**</i>
<i>     * Spusteni generatoru tridy.</i>
<i>     *</i>
<i>     * @param args nevyuzito</i>
<i>     */</i>
    public static void <strong>main</strong>(String[] args) {
        System.out.println("class generation begin: " + GENERATED_CLASS_NAME);
        try {
            CtClass generatedClass = generateClass();
<i>            // dulezite - generovana trida nesmi byt "zmrazena"</i>
            generatedClass.defrost();
<i>            // vypis struktury bajtkodu vsech metod</i>
            printMethodStructures(generatedClass);
<i>            // spusteni metod</i>
            runMethodsFromNewClass(generatedClass);
        }
        catch (CannotCompileException e) {
            e.printStackTrace();
        }
        catch (NotFoundException e) {
            e.printStackTrace();
        }
        catch (IOException e) {
            e.printStackTrace();
        }
        catch (BadBytecode e) {
            e.printStackTrace();
        }
        catch (InstantiationException e) {
            e.printStackTrace();
        }
        catch (IllegalAccessException e) {
            e.printStackTrace();
        }
        catch (SecurityException e) {
            e.printStackTrace();
        }
        catch (NoSuchMethodException e) {
            e.printStackTrace();
        }
        catch (IllegalArgumentException e) {
            e.printStackTrace();
        }
        catch (InvocationTargetException e) {
            e.printStackTrace();
        }
        System.out.println("class generation end: " + GENERATED_CLASS_NAME);
    }
&nbsp;
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Výpis bajtkódu vygenerovaného demonstraèním pøíkladem <strong>ClassGenerationTest8</strong></h2>

<p>Demonstraèní pøíklad <strong>ClassGenerationTest8</strong> po svém spu¹tìní
vytvoøí tøídu <strong>GeneratedClass8</strong> a navíc na standardní výstup
vypí¹e základní strukturu této tøídy. Na závìr jsou spu¹tìny v¹echny ètyøi
metody <strong>hello*()</strong>, které provedou výpis na chybový výstup:</p>

<pre>
class generation begin: <strong>GeneratedClass8</strong>
Method 'main' structure:
    real name:    <strong>main</strong>
    descriptor:   ([Ljava/lang/String;)V
    access flags: public static
    method body:
        invokestatic
        invokestatic
        invokestatic
        invokestatic
        return
&nbsp;
Method 'hello1' structure:
    real name:    <strong>hello1</strong>
    descriptor:   ()V
    access flags: public static
    method body:
        getstatic
        ldc
        invokevirtual
        return
&nbsp;
Method 'hello2' structure:
    real name:    <strong>hello2</strong>
    descriptor:   ()V
    access flags: public static
    method body:
        getstatic
        ldc
        invokevirtual
        return
&nbsp;
Method 'hello3' structure:
    real name:    <strong>hello3</strong>
    descriptor:   ()V
    access flags: public static
    method body:
        getstatic
        ldc
        invokevirtual
        return
&nbsp;
Method 'hello4' structure:
    real name:    <strong>hello4</strong>
    descriptor:   ()V
    access flags: public static
    method body:
        getstatic
        ldc
        invokevirtual
        return
&nbsp;
class generation end: GeneratedClass8
&nbsp;
Hello world #1!
Hello world #2!
Hello world #3!
Hello world #4!
</pre>

<p>Bude jistì zajímavé podívat se i na strukturu bajtkódu tøídy
<strong>GeneratedClass8</strong> vygenerované dne¹ním druhým demonstraèním
pøíkladem <strong>ClassGenerationTest8</strong>. Pro výpis struktury bajtkódu
opìt vyu¾ijeme standardní nástroj <strong>javap</strong>:</p>

<pre>
javap -c -private GeneratedClass8
</pre>

<p>Z&nbsp;výpisu vypsaného disassemblerem je patrné, ¾e v¹echny ètyøi metody
jsou tvoøeny stejnou sekvencí instrukcí, nezávisle na tom, jakým zpùsobem byly
tyto metody ve skuteènosti zkonstruovány. Dále je patrné, ¾e nástroj
<i>Javassist</i> automaticky vytvoøil v¹echny potøebné záznamy v&nbsp;constant
poolu. Jedná se o v¹echny záznamy typu <strong>NameAndType</strong>,
<strong>Method</strong>, <strong>Class</strong> a s&nbsp;nimi související
záznamy typu <strong>Asciz</strong>:</p>

<pre>
Compiled from "GeneratedClass8.java"
<strong>public class GeneratedClass8 extends java.lang.Object</strong>
  SourceFile: "GeneratedClass8.java"
  minor version: 0
  major version: 50
  Constant pool:
const #1 = Asciz        GeneratedClass8;
const #2 = class        #1;            <i>//  GeneratedClass8</i>
const #3 = Asciz        java/lang/Object;
const #4 = class        #3;            <i>//  java/lang/Object</i>
const #5 = Asciz        SourceFile;
const #6 = Asciz        GeneratedClass8.java;
const #7 = Asciz        hello1;
const #8 = Asciz        ()V;
const #9 = Asciz        java/lang/System;
const #10 = class       #9;            <i>//  java/lang/System</i>
const #11 = Asciz       err;
const #12 = Asciz       Ljava/io/PrintStream;;
const #13 = NameAndType #11:#12;       <i>//  err:Ljava/io/PrintStream;</i>
const #14 = Field       #10.#13;       <i>//  java/lang/System.err:Ljava/io/PrintStream;</i>
const #15 = Asciz       Hello world #1!;
const #16 = String      #15;           <i>//  Hello world #1!</i>
const #17 = Asciz       java/io/PrintStream;
const #18 = class       #17;           <i>//  java/io/PrintStream</i>
const #19 = Asciz       println;
const #20 = Asciz       (Ljava/lang/String;)V;
const #21 = NameAndType #19:#20;       <i>//  println:(Ljava/lang/String;)V</i>
const #22 = Method      #18.#21;       <i>//  java/io/PrintStream.println:(Ljava/lang/String;)V</i>
const #23 = Asciz       Code;
const #24 = Asciz       hello2;
const #25 = Asciz       Hello world #2!;
const #26 = String      #25;           <i>//  Hello world #2!</i>
const #27 = Asciz       hello3;
const #28 = Asciz       Hello world #3!;
const #29 = String      #28;           <i>//  Hello world #3!</i>
const #30 = Asciz       hello4;
const #31 = Asciz       Hello world #4!;
const #32 = String      #31;           <i>//  Hello world #4!</i>
const #33 = Asciz       main;
const #34 = Asciz       ([Ljava/lang/String;)V;
const #35 = NameAndType #7:#8;         <i>//  hello1:()V</i>
const #36 = Method      #2.#35;        <i>//  GeneratedClass8.hello1:()V</i>
const #37 = NameAndType #24:#8;        <i>//  hello2:()V</i>
const #38 = Method      #2.#37;        <i>//  GeneratedClass8.hello2:()V</i>
const #39 = NameAndType #27:#8;        <i>//  hello3:()V</i>
const #40 = Method      #2.#39;        <i>//  GeneratedClass8.hello3:()V</i>
const #41 = NameAndType #30:#8;        <i>//  hello4:()V</i>
const #42 = Method      #2.#41;        <i>//  GeneratedClass8.hello4:()V</i>
const #43 = Asciz       &lt;init&gt;;
const #44 = NameAndType #43:#8;        <i>//  "&lt;init&gt;":()V</i>
const #45 = Method      #4.#44;        <i>//  java/lang/Object."&lt;init&gt;":()V</i>
&nbsp;
{
<strong>public static void hello1();</strong>
  Code:
   Stack=2, Locals=0, Args_size=0
   0:   getstatic       #14;           <i>//Field java/lang/System.err:Ljava/io/PrintStream;</i>
   3:   ldc             #16;           <i>//String Hello world #1!</i>
   5:   invokevirtual   #22;           <i>//Method java/io/PrintStream.println:(Ljava/lang/String;)V</i>
   8:   return
&nbsp;
<strong>public static void hello2();</strong>
  Code:
   Stack=2, Locals=0, Args_size=0
   0:   getstatic       #14;           <i>//Field java/lang/System.err:Ljava/io/PrintStream;</i>
   3:   ldc             #26;           <i>//String Hello world #2!</i>
   5:   invokevirtual   #22;           <i>//Method java/io/PrintStream.println:(Ljava/lang/String;)V</i>
   8:   return
&nbsp;
<strong>public static void hello3();</strong>
  Code:
   Stack=2, Locals=0, Args_size=0
   0:   getstatic       #14;           <i>//Field java/lang/System.err:Ljava/io/PrintStream;</i>
   3:   ldc             #29;           <i>//String Hello world #3!</i>
   5:   invokevirtual   #22;           <i>//Method java/io/PrintStream.println:(Ljava/lang/String;)V</i>
   8:   return
&nbsp;
<strong>public static void hello4();</strong>
  Code:
   Stack=2, Locals=0, Args_size=0
   0:   getstatic       #14;           <i>//Field java/lang/System.err:Ljava/io/PrintStream;</i>
   3:   ldc             #32;           <i>//String Hello world #4!</i>
   5:   invokevirtual   #22;           <i>//Method java/io/PrintStream.println:(Ljava/lang/String;)V</i>
   8:   return
&nbsp;
<strong>public static void main(java.lang.String[]);</strong>
  Code:
   Stack=0, Locals=1, Args_size=1
   0:   invokestatic    #36;           <i>//Method hello1:()V</i>
   3:   invokestatic    #38;           <i>//Method hello2:()V</i>
   6:   invokestatic    #40;           <i>//Method hello3:()V</i>
   9:   invokestatic    #42;           <i>//Method hello4:()V</i>
   12:  return
&nbsp;
<strong>public GeneratedClass8();</strong>
  Code:
   Stack=1, Locals=1, Args_size=1
   0:   aload_0
   1:   invokespecial   #45;           <i>//Method java/lang/Object."&lt;init&gt;":()V</i>
   4:   return
&nbsp;
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Repositáø se zdrojovými kódy dne¹ního demonstraèního pøíkladu</h2>

<p>Následuje &ndash; v&nbsp;tomto seriálu ji¾ tradièní &ndash; kapitola
s&nbsp;odkazy na zdrojové kódy. Dnes popsaný demonstraèní pøíklad je spoleènì
s&nbsp;dal¹ími pomocnými skripty ulo¾en do Mercurial repositáøe dostupného na
adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
V&nbsp;následující tabulce najdete odkazy na prozatím nejnovìj¹í verze tìchto
zdrojových kódù:</p>

<table>
<tr><th>#</th><th>Zdrojový soubor/skript</th><th>Umístìní souboru v&nbsp;repositáøi</th></tr>
<tr><td>1</td><td>ClassGenerationTest8.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2588b1e9c0da/javassist/ClassGenerationTest8/ClassGenerationTest8.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2588b1e9c0da/javassist/ClassGenerationTest8/ClassGenerationTest8.java</a></td></tr>
<tr><td>2</td><td>buildClassGenerator8.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2588b1e9c0da/javassist/ClassGenerationTest8/buildClassGenerator8.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2588b1e9c0da/javassist/ClassGenerationTest8/buildClassGenerator8.sh</a></td></tr>
<tr><td>3</td><td>runClassGenerator8.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2588b1e9c0da/javassist/ClassGenerationTest8/runClassGenerator8.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2588b1e9c0da/javassist/ClassGenerationTest8/runClassGenerator8.sh</a></td></tr>
<tr><td>4</td><td>runGeneratedClass8.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2588b1e9c0da/javassist/ClassGenerationTest8/runGeneratedClass8.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/2588b1e9c0da/javassist/ClassGenerationTest8/runGeneratedClass8.sh</a></td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (pøed verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

