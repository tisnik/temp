<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Podpora skriptovacích jazykù v JDK6 a OpenJDK6</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Podpora skriptovacích jazykù v JDK6 a OpenJDK6</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve ètrnácté èásti seriálu o programovacím jazyce Java a vlastnostech JDK se seznámíme s API urèeným pro práci se skripty napsanými v rùzných skriptovacích programovacích jazycích. Toto API bylo navr¾eno tak, aby byl zpùsob volání skriptù, pøedávání parametrù skriptùm, získávání návratových hodnot i dal¹í èinnosti provádìny jednotným zpùsobem nezávislým na pou¾itém skriptovacím jazyku.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Podpora skriptovacích jazykù v JDK6 a OpenJDK6</a></p>
<p><a href="#k02">2. Skriptovací jazyky a JSR 223</a></p>
<p><a href="#k03">3. Tøídy a rozhraní pou¾ívané pøi práci se skripty</a></p>
<p><a href="#k04">4. První demonstraèní pøíklad: výpis v¹ech dostupných skriptovacích enginù</a></p>
<p><a href="#k05">5. Druhý demonstraèní pøíklad: získání skriptovacího engine nìkolika zpùsoby</a></p>
<p><a href="#k06">6. Tøetí demonstraèní pøíklad: nìkolik zpùsobù spu¹tìní skriptu</a></p>
<p><a href="#k07">7. Ètvrtý demonstraèní pøíklad: návratové hodnoty skriptù</a></p>
<p><a href="#k08">8. Pátý demonstraèní pøíklad: pøedávání parametrù a volání funkcí</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2>1. Podpora skriptovacích jazykù v JDK6 a OpenJDK6</h2>

<p>V&nbsp;pøedchozích èástech seriálu o programovacím jazyku Java i o
vlastnostech JDK a OpenJDK jsme se zabývali pøedev¹ím tím, jakým zpùsobem
internì pracují správci pamìti a jak lze v&nbsp;nìkterých pøípadech zvý¹it
výkonnost aplikací napsaných v&nbsp;Javì (zmìnou GC, nastavením parametrù
haldy/heapu, povolením <i>huge/large pages</i>, pou¾itím alternativních
knihoven nabízených v&nbsp;Oracle JDK), popø.&nbsp;sní¾it jejich pamì»ové
nároky, napøíklad pou¾itím komprimovaných ukazatelù na objekty (<i>compressed
oops</i>), konfigurací velikostí jednotlivých oblastí na haldì atd. Dnes
ponìkud od tìchto témat odboèíme, proto¾e se budeme zabývat podporou
skriptovacích jazykù v&nbsp;<i>JDK</i> a <i>JRE</i>. V&nbsp;minulosti bylo
vyvinuto pomìrnì velké mno¾ství skriptovacích jazykù urèených pro bìh na
virtuálním stroji jazyka Java (<i>JVM</i>), a» ji¾ se jedná o reimplementace
ji¾ existujících programovacích jazykù (<i>Basic</i>, <i>Cobol</i>,
<i>Lisp</i>, <i>Erlang</i>, <i>Forth</i>, <i>Logo</i>, <i>Python</i>,
<i>Ruby</i> èi <i>Scheme</i>), tak i jazykù zcela nových, mezi nì¾ patøí
napøíklad <i>BeanShell</i>, <i>Groovy</i>, <i>Scala</i> èi právì vznikající
jazyk <i>Ceylon</i>.</p>

<p>Dùvodù, proè pro virtuální stroj jazyka Java vznikly a stále vznikají nové
skriptovací jazyky, je více. Mezi ty hlavní dùvody v¹ak patøí pøedev¹ím
existence mnoha knihoven pro Javu (vèetnì knihoven, které jsou souèástí ka¾dé
<i>JVM</i>, co¾ mj.&nbsp;znamená podporu pro práci se sítìmi, tvorbu GUI atd.),
dnes ji¾ relativnì dobrá pøenositelnost aplikací bì¾ících nad <i>JVM</i> na
rùzné platformy, vèetnì platforem mobilních, automatická správa pamìti
alokované v&nbsp;rámci virtuálního stroje a v&nbsp;nìkterých pøípadech takté¾
to, ¾e skripty je mo¾né pøekládat do plnohodnotného javovského bajtkódu, který
je poté pøi bìhu aplikace buï interpretován nebo opìt pøekládán
<i>just-in-time</i> pøekladaèem do nativního kódu mikroprocesoru pou¾itého na
poèítaèi, kde je virtuální stroj Javy spu¹tìn. To, ¾e pro platformu Javy
existuje velké mno¾ství skriptovacích jazykù rùzné slo¾itosti a takté¾
vyjadøovacích schopností, je samozøejmì dobøe, proto¾e je mo¾né podporu pro
skripty vlo¾it do u¾ivatelských aplikací, co¾ mù¾e mít velký vliv na obchodní
úspìch takové aplikace (známým pøíkladem je napøíklad <i>AutoCAD</i>, pro nìj¾
vzniklo díky podpoøe <i>AutoLISPu</i> velké mno¾ství amatérských i
profesionálních nadstaveb, co¾ na druhou stranu roz¹íøilo i okruh u¾ivatelù,
kteøí si <i>AutoCAD</i> poøídili).</p>



<p><a name="k02"></a></p>
<h2>2. Skriptovací jazyky a JSR 223</h2>

<p>Zpoèátku skriptovací jazyky urèené pro bìh na virtuálním stroji Javy
vznikaly takovým zpùsobem, ¾e ka¾dý jazyk nabízel programátorùm odli¹né
programátorské rozhraní pro komunikaci mezi programy napsanými v&nbsp;Javì a
skripty. To samozøejmì nebyl ideální stav, proto¾e to komplikovalo práci jak
vývojáøùm daného skriptovacího jazyka (ti museli vymyslet vhodné API a to
takté¾ popsat), tak i vývojáøùm, kteøí chtìli podporu pro nìjaký skriptovací
jazyk implementovat ve svých programech. Z&nbsp;tohoto dùvodu vznikl
v&nbsp;rámci jednoho &bdquo;po¾adavku na zmìnu&ldquo; (<i>JSR &ndash; Java
Specification Request</i>) i návrh jednotného API pou¾itelného pro rùzné
skriptovací jazyky. Tento <i>JSR</i> získal poøadové èíslo <i>223</i> a
výsledná specifikace je známá pod celým svým názvem <i>JSR 223: Scripting for
the Java<sup>TM</sup> Platform</i>. Ve specifikaci <i>JSR 223</i> je popsáno
jak API, které by mìli tvùrci jednotlivých skriptovacích jazykù (nebo spí¹e
skriptovacích enginù, které skripty zpracovávají) dodr¾et, tak i zpùsob, jak
jsou jednotlivé skriptovací enginy inicializovány v&nbsp;dobì bìhu aplikace,
podpora pro skripty kompilované do bajtkódu atd.</p>

<p>Aby to v¹ak nebylo málo, byl do <i>JDK</i> integrován projekt <a
href="http://www.mozilla.org/rhino/">Rhino</a>, co¾ je skriptovací engine
urèený pro programovací jazyk <i>JavaScript</i> (resp.&nbsp;jeho standard
<i>ECMA-262</i>), který je kompletnì napsán v&nbsp;Javì a navíc byl uvolnìn
jako open-source. Zatímco jsou pøelo¾ené tøídy tvoøící skriptovací engine
<i>Rhino</i> v&nbsp;Oracle JDK ulo¾eny pøímo v&nbsp;archivu <i>rt.jar</i>,
mù¾eme tento engine v&nbsp;IcedTea6 najít v&nbsp;samostatném archivu
<i>rhino.jar</i>, umístìném ve stejném adresáøi, jako <i>rt.jar</i> (jre/lib).
Díky tomu, ¾e je <i>Rhino</i> souèástí <i>JDK</i>, lze v&nbsp;javovských
programech volat JavaScriptové programy, dokonce lze spustit i JavaScriptový
shell. Navíc, pokud by bylo nutné pou¾ít vlastní (novìj¹í) implementaci
<i>Rhina</i>, ne¾ nabízí pou¾ívaná <i>JDK</i>, mù¾e se <i>rhino*.jar</i>
umístit na classpath a samotná <i>JDK</i> se ji¾ postará o to, aby mìl tento
archiv pøednost pøed <i>Rhinem</i> dodávaným spolu s&nbsp;<i>JDK</i>. Vzhledem
k&nbsp;tomu, ¾e je dnes <i>Rhino</i> souèástí JDK, budou v¹echny dne¹ní
demonstraèní pøíklady poèítat s&nbsp;jeho podporou.</p>



<p><a name="k03"></a></p>
<h2>3. Tøídy a rozhraní pou¾ívané pøi práci se skripty</h2>

<p>Pro jednotnou práci s&nbsp;rùznými skriptovacími enginy, spou¹tìní celých
skriptù (pøíkaz po pøíkazu), volání vybraných funkcí èi metod ve skriptech i
pro provádìní dal¹ích èinností je v&nbsp;API Javy specifikováno pouze ¹est
rozhraní a ¹est tøíd; z&nbsp;toho jedna tøída pøedstavuje obecnou výjimku
vzniklou pøi práci se skripty. V¹ech ¹est rozhraní a ¹est tøíd je ulo¾eno
v&nbsp;balíèku <strong>javax.script</strong>. V&nbsp;praxi, zejména tehdy,
pokud se nebude pracovat s&nbsp;kompilovanými skripty, se v¹ak poèet skuteènì
pou¾ívaných tøíd a rozhraní sni¾uje &ndash; zpravidla se pou¾ívá pouze tøída
<strong>ScriptEngineManager</strong> a rozhraní <strong>ScriptEngine</strong>,
<strong>Invocable</strong> a <strong>ScriptException</strong>.
V&nbsp;následující tabulce jsou vypsána v¹echna rozhraní definovaná
v&nbsp;balíèku <strong>javax.script</strong>:</p>

<table>
<tr><th>Jméno rozhraní</th><th>Popis</th></tr>
<tr><td><a href="http://download.oracle.com/javase/6/docs/api/javax/script/Bindings.html">Bindings</a></td><td>Mapa obsahující klíèe typu øetìzec (jedná se o tøídu zapouzdøující jednu z&nbsp;implementací rozhraní <i>Map</i>).</td></tr>
<tr><td><a href="http://download.oracle.com/javase/6/docs/api/javax/script/Compilable.html">Compilable</a></td><td>Rozhraní, které mù¾e být implementované skriptovacím enginem podporujícím pøeklad skriptù.</td></tr>
<tr><td><a href="http://download.oracle.com/javase/6/docs/api/javax/script/Invocable.html">Invocable</a></td><td>Rozhraní, které mù¾e být implementované skriptovacím enginem podporujícím volání jednotlivých funkcí nebo metod.</td></tr>
<tr><td><a href="http://download.oracle.com/javase/6/docs/api/javax/script/ScriptContext.html">ScriptContext</a></td><td>Tøídy implementující toto rozhraní zaji¹»ují komunikaci mezi skriptovacím enginem a ostatními objekty.</td></tr>
<tr><td><a href="http://download.oracle.com/javase/6/docs/api/javax/script/ScriptEngine.html">ScriptEngine</a></td><td>Rozhraní implementované v¹emi skriptovacími enginy.</td></tr>
<tr><td><a href="http://download.oracle.com/javase/6/docs/api/javax/script/ScriptEngineFactory.html">ScriptEngineFactory</a></td><td>Rozhraní pro tøídy pou¾ívané pro získávání informací o jednotlivých skriptovacích enginech, popø.&nbsp;pro vytvoøení (èi získání) instance nìkterého enginu.</td></tr>
</table>

<p>V&nbsp;dal¹í tabulce je vypsáno v¹ech ¹est vý¹e zmínìných tøíd, které jsou
takté¾ souèástí balíèku <strong>javax.script</strong>:</p>

<table>
<tr><th>Jméno tøídy</th><th>Popis</th></tr>
<tr><td><a href="http://download.oracle.com/javase/6/docs/api/javax/script/AbstractScriptEngine.html">AbstractScriptEngine</a></td><td>Standardní implementace pøetí¾ené metody eval().</td></tr>
<tr><td><a href="http://download.oracle.com/javase/6/docs/api/javax/script/CompiledScript.html">CompiledScript</a></td><td>Instance potomkù této tøídy reprezentují pøelo¾ený skript.</td></tr>
<tr><td><a href="http://download.oracle.com/javase/6/docs/api/javax/script/ScriptEngineManager.html">ScriptEngineManager</a></td><td>Tøída pou¾ívaná pøedev¹ím pro vytvoøení (získání) instance vybraného skriptovacího enginu.</td></tr>
<tr><td><a href="http://download.oracle.com/javase/6/docs/api/javax/script/SimpleBindings.html">SimpleBindings</a></td><td>Implementace rozhraní Bindings (viz pøedchozí tabulka) pomocí HashMapy.</td></tr>
<tr><td><a href="http://download.oracle.com/javase/6/docs/api/javax/script/SimpleScriptContext.html">SimpleScriptContext</a></td><td>Implementace rozhraní ScriptContext (viz pøedchozí tabulka).</td></tr>
<tr><td><a href="http://download.oracle.com/javase/6/docs/api/javax/script/ScriptException.html">ScriptException</a></td><td>Tøída reprezentující výjimky vyvolávané pøi inicializaci a spou¹tìní skriptù. Dùle¾ité je, ¾e tato výjimka mù¾e nést i informaci o jménu souboru se skriptem i pøesné lokalizaci chyby (èíslo øádku i èíslo sloupce).</td></tr>
</table>



<p><a name="k04"></a></p>
<h2>4. První demonstraèní pøíklad: výpis v¹ech dostupných skriptovacích enginù</h2>

<p>V&nbsp;dne¹ním prvním demonstraèním pøíkladu je ukázáno, jakým zpùsobem je
mo¾né získat informace o v¹ech skriptovacích enginech, které jsou
v&nbsp;javovském virtuálním stroji, v&nbsp;nìm¾ je testovací aplikace spu¹tìná,
dostupné. Nejprve je vytvoøena instance tøídy
<strong>StringEngineManager</strong>, po její¾ inicializaci je ji¾ mo¾né získat
informace o v¹ech podporovaných skriptovacích enginech pomocí metody
<strong>StringEngineManager.getEngineFactories()</strong>, která vrací seznam
objektù implementující rozhraní <strong>StringEngineFactory</strong>. Toto
rozhraní pøedepisuje nìkteré metody, které je mo¾né vyu¾ít pro získání jména a
verze podporovaného skriptovacího jazyka a takté¾ seznam aliasù (pøezdívek)
daného skriptovacího enginu, co¾ je pomìrnì dùle¾itá informace pou¾itá
v&nbsp;následujícím demonstraèním pøíkladu uvedeném v&nbsp;dal¹í kapitole.
Zdrojový kód prvního demonstraèního pøíkladu je pomìrnì jednoduchý:</p>

<pre>
import javax.script.ScriptEngineFactory;
import javax.script.ScriptEngineManager;



/**
 * Utilita, ktera po svem spusteni vypise vsechny dostupne skriptovaci enginy a
 * programovaci jazyky podporovane danym enginem.
 *
 * @author Pavel Tisnovsky
 */
public class ScriptingTest1
{
    private static void listAllScriptEngines()
    {
        // Zakladni pristupovy bod ke skriptovacim technologiim
        // zajistuje v JDK trida ScriptEngineManager.
        ScriptEngineManager engineManager = new ScriptEngineManager();

        // Ziskani vsech dostupnych skriptovacich enginu a vypis
        // jejich vlastnosti i podporovanych jazyku.
        for (ScriptEngineFactory factory : engineManager.getEngineFactories())
        {
            String engineName      = factory.getEngineName();
            String engineVersion   = factory.getEngineVersion();
            String languageName    = factory.getLanguageName();
            String languageVersion = factory.getLanguageVersion();
            System.out.printf("Language: %s (%s)\n", languageName, languageVersion);
            System.out.printf("Script engine: %s (%s)\n", engineName, engineVersion);

            // Vypis vsech aliasu.
            for (String name : factory.getNames())
            {
                System.out.printf("    Engine Alias: %s\n", name);
            }
        }
    }

    public static void main(String[] args)
    {
        listAllScriptEngines();
    }

}
</pre>

<p>Následuje pøíklad textového výstupu generovaného touto testovací aplikací
pøi jejím pøekladu a spu¹tìní pomocí <i>IcedTea6-1.8.x</i> (IcedTea je OpenJDK
pøelo¾ené pomocí GNU nástrojù a s&nbsp;pou¾itím pomìrnì velkého mno¾ství
patchù, které nebyly z&nbsp;rùzných dùvodù zaøazeny pøímo do OpenJDK):</p>

<pre>
Language: ECMAScript (1.6)
Script engine: Mozilla Rhino (1.6 release 2)
    Engine Alias: js
    Engine Alias: rhino
    Engine Alias: JavaScript
    Engine Alias: javascript
    Engine Alias: ECMAScript
    Engine Alias: ecmascript
</pre>



<p><a name="k05"></a></p>
<h2>5. Druhý demonstraèní pøíklad: získání skriptovacího engine nìkolika zpùsoby</h2>

<p>Ve druhém demonstraèním pøíkladu je ukázáno nìkolik zpùsobù, jakými je mo¾né
získat skriptovací engine podporující po¾adovaný skriptovací jazyk.
V&nbsp;tomto pøíkladu se poèítá s&nbsp;tím, ¾e JRE, v&nbsp;nìm¾ je pøíklad
spu¹tìn, má nainstalovánu podporu pro <i>JavaScript</i>, popø.&nbsp;jsou
potøebné knihovny dostupné na CLASSPATH. Jak jsme se ji¾ dozvìdìli
z&nbsp;pøedchozích kapitol, je <i>JavaScript</i> podporován jak v&nbsp;Oracle
JDK, tak i v&nbsp;OpenJDK &ndash; v&nbsp;obou pøípadech je pou¾ita implementace
skriptovacího enginu <i>Rhino</i>. V&nbsp;demonstraèním pøíkladu se pro získání
instance tohoto enginu pou¾ívá jak výbìr pomocí jména èi aliasu, tak i pomocí
pøípony souborù se skripty, popø.&nbsp;pomocí MIME typu. Pokud není skriptovací
engine odpovídající zadané podmínce nalezen, vrátí se pouze hodnota
<strong>NULL</strong>, tj.&nbsp;NEdojde pøímo k&nbsp;vyvolání výjimky; a¾ pøi
pokusu o pøístup k&nbsp;neexistujícímu objektu samozøejmì dojde
k&nbsp;<strong>NPE</strong> :-). Následuje výpis zdrojového kódu druhého
demonstraèního pøíkladu:</p>

<pre>
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;



/**
 * V teto utilite je ukazano nekolik zpusobu, jakymi je mozne ziskat
 * skriptovaci engine.
 *
 * @author Pavel Tisnovsky
 */
public class ScriptingTest2
{
    ScriptEngineManager engineManager;

    /**
      * Ziskani skriptovaciho engine podle jmena.
      */
    private void getEngineByNameTest(String name)
    {
        System.out.print("Hledani podle jmena '" + name + "'");
        printEngineInfo(this.engineManager.getEngineByName(name));
    }

    /**
      * Ziskani skriptovaciho engine podle pripony.
      */
    private void getEngineByExtensionTest(String extension)
    {
        System.out.print("Hledani podle pripony '" + extension + "'");
        printEngineInfo(this.engineManager.getEngineByExtension(extension));
    }

    /**
      * Ziskani skriptovaciho engine podle MIME typu.
      */
    private void getEngineByMimeTypeTest(String mimeType)
    {
        System.out.print("Hledani podle MIME typu '" + mimeType + "'");
        printEngineInfo(this.engineManager.getEngineByMimeType(mimeType));
    }

    private void runTests()
    {
        this.engineManager = new ScriptEngineManager();
        getEngineByNameTest("JavaScript");
        getEngineByNameTest("javaScript"); // spatne jmeno!
        getEngineByNameTest("javascript");
        getEngineByNameTest("EcmaScript"); // nektere verze Rhina podporuji "ECMAScript"
        getEngineByNameTest("ecmaScript"); // spatne jmeno!
        getEngineByNameTest("ecmascript");
        getEngineByExtensionTest("js");
        getEngineByExtensionTest("bas");   // pravdepodobne se nenalezne
        getEngineByMimeTypeTest("text/javascript");
        getEngineByMimeTypeTest("text/ecmascript");
        getEngineByMimeTypeTest("application/javascript");
        getEngineByMimeTypeTest("application/ecmascript");
    }

    /**
      * Vypis informace o tom, zda byl ci nebyl odpovidajici
      * skriptovaci engine nalezen.
      */
    private void printEngineInfo(ScriptEngine engine)
    {
        String answer = engine == null ? "ne" : "";
        System.out.println(":  skriptovaci engine " + answer + "byl nalezen");
    }

    public static void main(String[] args)
    {
        new ScriptingTest2().runTests();
    }

}
</pre>

<p>Pod tímto odstavcem je opìt uvedena ukázka textového výstupu testovací
aplikace v&nbsp;pøípadì, ¾e je pro její spu¹tìní pou¾ito
<i>IcedTea6-1.8</i>:</p>

<pre>
Hledani podle jmena 'JavaScript':  skriptovaci engine byl nalezen
Hledani podle jmena 'javaScript':  skriptovaci engine nebyl nalezen
Hledani podle jmena 'javascript':  skriptovaci engine byl nalezen
Hledani podle jmena 'EcmaScript':  skriptovaci engine nebyl nalezen
Hledani podle jmena 'ecmaScript':  skriptovaci engine nebyl nalezen
Hledani podle jmena 'ecmascript':  skriptovaci engine byl nalezen
Hledani podle pripony 'js':  skriptovaci engine byl nalezen
Hledani podle pripony 'bas':  skriptovaci engine nebyl nalezen
Hledani podle MIME typu 'text/javascript':  skriptovaci engine byl nalezen
Hledani podle MIME typu 'text/ecmascript':  skriptovaci engine byl nalezen
Hledani podle MIME typu 'application/javascript':  skriptovaci engine byl nalezen
Hledani podle MIME typu 'application/ecmascript':  skriptovaci engine byl nalezen
</pre>



<p><a name="k06"></a></p>
<h2>6. Tøetí demonstraèní pøíklad: nìkolik zpùsobù spu¹tìní skriptu</h2>

<p>Tøetí demonstraèní aplikace je ji¾ zamìøena ponìkud praktiètìji, ne¾
pøedchozí dva pøíklady. Po vytvoøení instance tøídy
<strong>ScriptEngineManager</strong> a získání skriptovacího enginu urèeného
pro programovací jazyk <i>JavaScript</i> se pomocí metody
<strong>ScriptEngine.eval()</strong> spustí jednoduchý skript, a to tøemi
rùznými zpùsoby. Pøi pou¾ití prvního zpùsobu je skript ulo¾en v&nbsp;øetìzci,
pøi pou¾ití zpùsobu druhého je získán z&nbsp;nìkteré tøídy implementující
rozhraní <strong>Reader</strong> (mù¾e se jednat napøíklad o sta¾ení skriptu ze
sítì, jeho naètení z&nbsp;archivu typu ZIP atd.) a koneènì v&nbsp;pøípadì
tøetím je skript naèten z&nbsp;bì¾ného souboru, popø.&nbsp;ze souboru ulo¾eného
v&nbsp;javovském archivu (JAR), v&nbsp;nìm¾ je zabalena celá aplikace.
V&nbsp;pøípadì, ¾e pøi spu¹tìní skriptu dojde k&nbsp;nìjaké chybì, je
vygenerována výjimka typu <strong>ScriptException</strong>, z&nbsp;ní¾ je mo¾né
v&nbsp;nìkterých pøípadech získat i informace o èísle textového øádku,
popø.&nbsp;i sloupce, ve kterém k&nbsp;chybì do¹lo:</p>

<pre>
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.StringReader;
import java.io.IOException;

import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;



/**
 * Demonstracni priklad, v nemz je ukazano nekolik zpusobu spusteni skriptu.
 *
 * @author Pavel Tisnovsky
 */
public class ScriptingTest3
{
    static final String script = "println('Hello world');";
    ScriptEngineManager engineManager;
    ScriptEngine scriptEngine;

    /**
      * Spusteni skriptu, ktery je ulozen v retezci.
      */
    private void runScriptStoredInString()
    {
        try
        {
            this.scriptEngine.eval(script);
        }
        catch (ScriptException e)
        {
            e.printStackTrace();
        }
    }

    /**
      * Spusteni skriptu, ktery je ziskan z objektu typu Reader nebo
      * z nektereho potomka teto tridy.
      */
    private void runScriptFromReader()
    {
        StringReader stringReader = new StringReader(script);
        try
        {
            this.scriptEngine.eval(stringReader);
        }
        catch (ScriptException e)
        {
            e.printStackTrace();
        }
        finally
        {
            stringReader.close();
        }
    }

    /**
      * Spusteni skriptu, ktery je ulozen v externim souboru.
      */
    private void runScriptStoredInFile()
    {
        InputStream inputStream = this.getClass().getResourceAsStream("scripts/test1.js");
        try
        {
            this.scriptEngine.eval(new InputStreamReader(inputStream));
        }
        catch (ScriptException e)
        {
            e.printStackTrace();
        }
        finally
        {
            try
            {
                inputStream.close();
            }
            catch (IOException e)
            {
                e.printStackTrace();
            }
        }
    }

    /**
      * Spusteni skriptu tremi ruznymi moznostmi.
      */
    private void runTests()
    {
        this.engineManager = new ScriptEngineManager();
        this.scriptEngine = engineManager.getEngineByName("JavaScript");
        runScriptStoredInString();
        runScriptFromReader();
        runScriptStoredInFile();
    }

    public static void main(String[] args)
    {
        new ScriptingTest3().runTests();
    }

}
</pre>

<p>Pro správnou funkci aplikace je nutné, aby byl v&nbsp;podadresáøi
<strong>scripts</strong> vytvoøen soubor nazvaný <strong>test1.js</strong>,
který mù¾e obsahovat napøíklad následující pøíkaz:</p>

<pre>
println('Hello world');
</pre>



<p><a name="k07"></a></p>
<h2>7. Ètvrtý demonstraèní pøíklad: návratové hodnoty skriptù</h2>

<p>Skripty naprogramované v&nbsp;<i>JavaScriptu</i>, nebo v&nbsp;nìkterém
dal¹ím programovacím jazyku implementovaném skriptovacím enginem, samozøejmì
musí umìt nìjakým zpùsobem komunikovat s&nbsp;javovským programem, který skript
spou¹tí. Nejjednodu¹¹ím zpùsobem, jakým je mo¾né tuto komunikaci zajistit, je
naètení návratové hodnoty skriptu. Metoda <strong>ScriptEngine.eval()</strong>
toti¾ vrací objekt, který vznikl vyhodnocením posledního pøíkazu skriptu
(ponìkud odli¹ná je situace pøi pou¾ití metody
<strong>Invocable.invokeFunction()</strong> èi
<strong>Invocable.invokeMethod()</strong>, viz dal¹í kapitolu). Metoda
<strong>ScriptEngine.eval()</strong> má sice v&nbsp;deklaraci jako typ
návratové hodnoty specifikován <strong>Object</strong>, ve skuteènosti se v¹ak
skriptovací engine sna¾í vytvoøit javovský objekt takového typu, který se co
nejvíce pøibli¾uje návratovému typu výrazu, co¾ ov¹em není v¾dy úplnì
jednoduché a ani jednoznaèné, proto¾e skriptovací jazyky jsou vìt¹inou
dynamicky typované a nìkdy takté¾ nerozli¹ují napøíklad mezi celými èísly a
èísly reálnými. V&nbsp;následujícím pøíkladu je ukázáno, jak lze vyhodnotit
poslední pøíkaz skriptu na javovský objekt typu <strong>Double</strong>,
<strong>String</strong> èi dokonce <strong>Date</strong>. Pov¹imnìte si,
jak lze pøímo ve skriptu vytvoøit nový javovský objekt:</p>

<pre>
import java.util.Date;

import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;



/**
 * Demonstracni priklad, v nemz je ukazano, jak muze skript vratit
 * Javovskemu programu navratovou hodnotu a jaky ma tato hodnota typ.
 *
 * @author Pavel Tisnovsky
 */
public class ScriptingTest4
{
    ScriptEngineManager engineManager;
    ScriptEngine scriptEngine;

    public void runSimpleScriptWhichReturnsDouble() throws ScriptException
    {
        final String script =
            "1.5/2;";

        Double result = (Double)this.scriptEngine.eval(script);
        System.out.println("Navratova hodnota skriptu '" + script + "': " + result);
    }

    public void runSimpleScriptWhichReturnsString() throws ScriptException
    {
        final String script =
            "'Hello' + ' ' + 'world'";

        String result = (String)this.scriptEngine.eval(script);
        System.out.println("Navratova hodnota skriptu '" + script + "': " + result);
    }

    public void createJavaObject1() throws ScriptException
    {
        final String script =
            "new java.util.Date()";

        Object result = this.scriptEngine.eval(script);
        System.out.println("Navratova hodnota skriptu '" + script + "': " + result);
    }

    public void createJavaObject2() throws ScriptException
    {
        final String script =
            "new java.util.Date()";

        Date result = (Date)this.scriptEngine.eval(script);
        System.out.println("Navratova hodnota skriptu '" + script + "': " + result);
    }

    /**
      * Spusteni skriptu tremi ruznymi moznostmi.
      */
    private void runTests()
    {
        this.engineManager = new ScriptEngineManager();
        this.scriptEngine = engineManager.getEngineByName("JavaScript");
        try
        {
            runSimpleScriptWhichReturnsDouble();
            runSimpleScriptWhichReturnsString();
            createJavaObject1();
            createJavaObject2();
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    public static void main(String[] args)
    {
        new ScriptingTest4().runTests();
    }

}
</pre>

<p>Pøíklad výstupu pøedchozího pøíkladu:</p>

<pre>
Navratova hodnota skriptu '1/2;': 0.5
Navratova hodnota skriptu ''Hello' + ' ' + 'world'': Hello world
Navratova hodnota skriptu 'new java.util.Date()': Tue Apr 12 21:50:43 CEST 2011
Navratova hodnota skriptu 'new java.util.Date()': Tue Apr 12 21:50:43 CEST 2011
</pre>



<p><a name="k08"></a></p>
<h2>8. Pátý demonstraèní pøíklad: pøedávání parametrù a volání funkcí</h2>

<p>Demonstraèní pøíklad uvedený v&nbsp;pøedchozí kapitole pou¾íval pro
komunikaci mezi skriptem a Javovským programem v&nbsp;podstatì velmi primitivní
zpùsob, který je mo¾né pou¾ít pouze v&nbsp;tìch nejjednodu¹¹ích pøípadech.
V&nbsp;praxi se v¹ak vìt¹inou setkáme s&nbsp;tím, ¾e je celý skript rozdìlen do
mnoha funkcí, které by bylo vhodné volat z&nbsp;programù napsaných v&nbsp;Javì,
samozøejmì i s&nbsp;tím, ¾e se tìmto funkcím pøedají nìjaké parametry a funkce
vrátí výsledek. I toho je samozøejmì mo¾né ve standardním
&bdquo;skriptovacím&ldquo; API dosáhnout a to pomìrnì jednodu¹e, ov¹em pouze za
pøedpokladu, ¾e to daný skriptovací jazyk a skriptovací engine umo¾òuje.
V&nbsp;pøípadì pou¾ití projektu <i>Rhino</i> (<i>JavaScript</i>) implementuje
jeho skriptovací engine rozhraní <strong>Invocable</strong>, které
mj.&nbsp;obsahuje i metodu <strong>Invocable.invokeFunction()</strong>. Tato
metoda má jeden povinný parametr, kterým je název volané funkce, a potom
libovolný poèet dal¹ích parametrù, které jsou pøímo pøedány volané funkci
(samozøejmì po konverzi mezi datovými typy Javy a daného skriptovacího jazyka).
V&nbsp;následujícím demonstraèním pøíkladu je ukázáno, jak lze metodu
<strong>Invocable.invokeFunction()</strong> pou¾ít. Pov¹imnìte si, ¾e skript
musí být nejdøíve &bdquo;vyhodnocen&ldquo; pomocí <strong>eval()</strong>:</p>

<pre>
import java.util.Date;

import javax.script.Invocable;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;



/**
 * Demonstracni priklad, v nemz je ukazano spousteni vybranych funkci,
 * predavani parametru skriptum a ziskavani navratovych hodnot funkci.
 *
 * @author Pavel Tisnovsky
 */
public class ScriptingTest5
{
    ScriptEngineManager engineManager;
    ScriptEngine scriptEngine;
    Invocable invocableEngine;

    private void testInvokeFunction() throws ScriptException, NoSuchMethodException
    {
        final String script =
            "function foo() {\n" +
            "    println('Hello, world!');\n" +
            "}\n";

        this.scriptEngine.eval(script);
        this.invocableEngine.invokeFunction("foo");
    }

    private void testInvokeFunctionWithParameters() throws ScriptException, NoSuchMethodException {
        final String script =
            "function printHello(str1, str2) {\n" +
            "    println(str1 + ' ' + str2);\n" +
            "}\n";

        this.scriptEngine.eval(script);
        this.invocableEngine.invokeFunction("printHello", "hello", "world");
    }

    private void printFunctionResult(String script, Object result)
    {
        System.out.println("Navratova hodnota funkce:\n" + script + "je: " + result);
        System.out.println("Typ navratove hodnoty: " + result.getClass().getName() + "\n");
    }

    private void testInvokeFunctionWhichReturnsNumber() throws Exception
    {
        final String script =
            "function plus(x, y) {\n" +
            "    return x + y;\n" +
            "}\n";

        this.scriptEngine.eval(script);
        Object result = this.invocableEngine.invokeFunction("plus", 1, 2);
        printFunctionResult(script, result);
    }

    private void testInvokeFunctionWhichReturnsString() throws Exception
    {
        final String script =
            "function concatenateWords(str1, str2) {\n" +
            "    return str1 + ' ' + str2;\n" +
            "}\n";

        this.scriptEngine.eval(script);
        Object result = this.invocableEngine.invokeFunction("concatenateWords", "Hello", "world");
        printFunctionResult(script, result);
    }

    private void testInvokeFunctionWhichReturnsDate() throws Exception
    {
        final String script =
            "function calculateDate(epochTime) {\n" +
            "    var date = new java.util.Date(epochTime);\n" +
            "    return date;\n" +
            "}\n";

        this.scriptEngine.eval(script);
        Object result = this.invocableEngine.invokeFunction("calculateDate", 0);
        printFunctionResult(script, result);
        result = this.invocableEngine.invokeFunction("calculateDate", System.currentTimeMillis());
        printFunctionResult(script, result);
    }

    /**
      * Spusteni skriptu tremi ruznymi moznostmi.
      */
    private void runTests()
    {
        this.engineManager = new ScriptEngineManager();
        this.scriptEngine = engineManager.getEngineByName("JavaScript");
        this.invocableEngine = (Invocable)this.scriptEngine;
        try
        {
            testInvokeFunction();
            testInvokeFunctionWithParameters();
            testInvokeFunctionWhichReturnsNumber();
            testInvokeFunctionWhichReturnsString();
            testInvokeFunctionWhichReturnsDate();
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    public static void main(String[] args)
    {
        new ScriptingTest5().runTests();
    }

}

</pre>

<p>Po spu¹tìní vý¹e uvedeného pøíkladu se vypí¹e následující text:</p>

<pre>
Hello, world!
hello world
Navratova hodnota funkce:
function plus(x, y) {
    return x + y;
}
je: 3.0
Typ navratove hodnoty: java.lang.Double *** nìkdy té¾ java.lang.Integer ***

Navratova hodnota funkce:
function concatenateWords(str1, str2) {
    return str1 + ' ' + str2;
}
je: Hello world
Typ navratove hodnoty: java.lang.String

Navratova hodnota funkce:
function calculateDate(epochTime) {
    var date = new java.util.Date(epochTime);
    return date;
}
je: Thu Jan 01 01:00:00 CET 1970
Typ navratove hodnoty: java.util.Date

Navratova hodnota funkce:
function calculateDate(epochTime) {
    var date = new java.util.Date(epochTime);
    return date;
}
je: Tue Apr 12 22:17:12 CEST 2011
Typ navratove hodnoty: java.util.Date
</pre>



<p><a name="k09"></a></p>
<h2>9. Odkazy na Internetu</h2>

<ol>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Package javax.script (JavaDoc)<br />
<a href="http://download.oracle.com/javase/6/docs/api/javax/script/package-summary.html">http://download.oracle.com/javase/6/docs/api/javax/script/package-summary.html</a>
</li>

<li>javax.script.Bindings<br />
<a href="http://download.oracle.com/javase/6/docs/api/javax/script/Bindings.html">http://download.oracle.com/javase/6/docs/api/javax/script/Bindings.html</a>
</li>

<li>javax.script.Compilable<br />
<a href="http://download.oracle.com/javase/6/docs/api/javax/script/Compilable.html">http://download.oracle.com/javase/6/docs/api/javax/script/Compilable.html</a>
</li>

<li>javax.script.Invocable<br />
<a href="http://download.oracle.com/javase/6/docs/api/javax/script/Invocable.html">http://download.oracle.com/javase/6/docs/api/javax/script/Invocable.html</a>
</li>

<li>javax.script.ScriptContext<br />
<a href="http://download.oracle.com/javase/6/docs/api/javax/script/ScriptContext.html">http://download.oracle.com/javase/6/docs/api/javax/script/ScriptContext.html</a>
</li>

<li>javax.script.ScriptEngine<br />
<a href="http://download.oracle.com/javase/6/docs/api/javax/script/ScriptEngine.html">http://download.oracle.com/javase/6/docs/api/javax/script/ScriptEngine.html</a>
</li>

<li>javax.script.ScriptEngineFactory<br />
<a href="http://download.oracle.com/javase/6/docs/api/javax/script/ScriptEngineFactory.html">http://download.oracle.com/javase/6/docs/api/javax/script/ScriptEngineFactory.html</a>
</li>

<li>javax.script.AbstractScriptEngine<br />
<a href="http://download.oracle.com/javase/6/docs/api/javax/script/AbstractScriptEngine.html">http://download.oracle.com/javase/6/docs/api/javax/script/AbstractScriptEngine.html</a>
</li>

<li>javax.script.CompiledScript<br />
<a href="http://download.oracle.com/javase/6/docs/api/javax/script/CompiledScript.html">http://download.oracle.com/javase/6/docs/api/javax/script/CompiledScript.html</a></td>
</li>

<li>javax.script.ScriptEngineManager<br />
<a href="http://download.oracle.com/javase/6/docs/api/javax/script/ScriptEngineManager.html">http://download.oracle.com/javase/6/docs/api/javax/script/ScriptEngineManager.html</a>
</li>

<li>javax.script.SimpleBindings<br />
<a href="http://download.oracle.com/javase/6/docs/api/javax/script/SimpleBindings.html">http://download.oracle.com/javase/6/docs/api/javax/script/SimpleBindings.html</a>
</li>

<li>javax.script.SimpleScriptContext<br />
<a href="http://download.oracle.com/javase/6/docs/api/javax/script/SimpleScriptContext.html">http://download.oracle.com/javase/6/docs/api/javax/script/SimpleScriptContext.html</a>
</li>

<li>javax.script.ScriptException<br />
<a href="http://download.oracle.com/javase/6/docs/api/javax/script/ScriptException.html">http://download.oracle.com/javase/6/docs/api/javax/script/ScriptException.html</a>
</li>

<li>The Java Compatibility Test Tools: JavaTest Harness<br />
<a href="http://java.sun.com/developer/technicalArticles/JCPtools2/">http://java.sun.com/developer/technicalArticles/JCPtools2/</a>
</li>

<li>JavaScript engine (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/JavaScript_engine">http://en.wikipedia.org/wiki/JavaScript_engine</a>
</li>

<li>Rhino (JavaScript engine)<br />
<a href="http://en.wikipedia.org/wiki/Rhino_(JavaScript_engine)">http://en.wikipedia.org/wiki/Rhino_(JavaScript_engine)</a>
</li>

<li>Rhino: JavaScript for Java<br />
<a href="http://www.mozilla.org/rhino/">http://www.mozilla.org/rhino/</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a></li>

<li>HugePages<br />
<a href="http://linux-mm.org/HugePages">http://linux-mm.org/HugePages</a>
</li>

<li>Tuning big java heap and linux huge pages<br />
<a href="http://www.tikalk.com/alm/forums/tuning-big-java-heap-and-linux-huge-pages">http://www.tikalk.com/alm/forums/tuning-big-java-heap-and-linux-huge-pages</a>
</li>

<li>How do I set up hugepages in Red Hat Enterprise Linux 4<br />
<a href="http://magazine.redhat.com/2007/05/29/how-do-i-set-up-hugepages-in-red-hat-enterprise-linux-4/">http://magazine.redhat.com/2007/05/29/how-do-i-set-up-hugepages-in-red-hat-enterprise-linux-4/</a>
</li>

<li>Java SE Tuning Tip: Large Pages on Windows and Linux<br />
<a href="http://blogs.sun.com/dagastine/entry/java_se_tuning_tip_large">http://blogs.sun.com/dagastine/entry/java_se_tuning_tip_large</a>
</li>

<li>Translation lookaside buffer<br />
<a href="http://en.wikipedia.org/wiki/Translation_lookaside_buffer">http://en.wikipedia.org/wiki/Translation_lookaside_buffer</a>
</li>

<li>Physical Address Extension<br />
<a href="http://en.wikipedia.org/wiki/Physical_Address_Extension">http://en.wikipedia.org/wiki/Physical_Address_Extension</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a>
</li>

<li>Amdahl's law<br />
<a href="http://en.wikipedia.org/wiki/Amdahl_law">http://en.wikipedia.org/wiki/Amdahl_law</a>
</li>

<li>Garbage collection (computer science)<br />
<a href="http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)</a>
</li>

<li>Dr. Dobb's | G1: Java's Garbage First Garbage Collector<br />
<a href="http://www.drdobbs.com/article/printableArticle.jhtml?articleId=219401061&amp;dept_url=/java/">http://www.drdobbs.com/article/printableArticle.jhtml?articleId=219401061&amp;dept_url=/java/</a>
</li>

<li>Java's garbage-collected heap<br />
<a href="http://www.javaworld.com/javaworld/jw-08-1996/jw-08-gc.html">http://www.javaworld.com/javaworld/jw-08-1996/jw-08-gc.html</a>
</li>

<li>Compressed oops in the Hotspot JVM<br />
<a href="http://wikis.sun.com/display/HotSpotInternals/CompressedOops">http://wikis.sun.com/display/HotSpotInternals/CompressedOops</a>
</li>

<li>32-bit or 64-bit JVM? How about a Hybrid?<br />
<a href="http://blog.juma.me.uk/2008/10/14/32-bit-or-64-bit-jvm-how-about-a-hybrid/">http://blog.juma.me.uk/2008/10/14/32-bit-or-64-bit-jvm-how-about-a-hybrid/</a>
</li>

<li>Compressed object pointers in Hotspot VM<br />
<a href="http://blogs.sun.com/nike/entry/compressed_object_pointers_in_hotspot">http://blogs.sun.com/nike/entry/compressed_object_pointers_in_hotspot</a>
</li>

<li>Java HotSpot(tm) Virtual Machine Performance Enhancements<br />
<a href="http://download.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html">http://download.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html</a>
</li>

<li>Using jconsole<br />
<a href="http://download.oracle.com/javase/1.5.0/docs/guide/management/jconsole.html">http://download.oracle.com/javase/1.5.0/docs/guide/management/jconsole.html</a>
</li>

<li>jconsole &ndash; Java Monitoring and Management Console<br />
<a href="http://download.oracle.com/javase/1.5.0/docs/tooldocs/share/jconsole.html">http://download.oracle.com/javase/1.5.0/docs/tooldocs/share/jconsole.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>x86-64<br />
<a href="http://en.wikipedia.org/wiki/X86-64">http://en.wikipedia.org/wiki/X86-64</a>
</li>

<li>Physical Address Extension<br />
<a href="http://en.wikipedia.org/wiki/Physical_Address_Extension">http://en.wikipedia.org/wiki/Physical_Address_Extension</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>1.6.0_14 (6u14)<br />
<a href="http://www.oracle.com/technetwork/java/javase/6u14-137039.html?ssSourceSiteId=otncn">http://www.oracle.com/technetwork/java/javase/6u14-137039.html?ssSourceSiteId=otncn</a>
</li>

<li>Update Release Notes<br />
<a href="http://www.oracle.com/technetwork/java/javase/releasenotes-136954.html">http://www.oracle.com/technetwork/java/javase/releasenotes-136954.html</a>
</li>

<li>Java virtual machine: 4.10 Limitations of the Java Virtual Machine<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#88659">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#88659</a>
</li>

<li>Java(TM) Platform, Standard Edition 7 Binary Snapshot Releases<br />
<a href="http://dlc.sun.com.edgesuite.net/jdk7/binaries/index.html">http://dlc.sun.com.edgesuite.net/jdk7/binaries/index.html</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>ClosableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>ArrayList (JDK 1.4)<br />
<a href="http://download.oracle.com/javase/1.4.2/docs/api/java/util/ArrayList.html">http://download.oracle.com/javase/1.4.2/docs/api/java/util/ArrayList.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2011</small></p>
</body>
</html>

