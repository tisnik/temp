<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Clojure 18: základní techniky optimalizace aplikací</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Clojure 18: základní techniky optimalizace aplikací</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o vlastnostech programovacího jazyka Java i JVM se opìt budeme zabývat popisem jazyka Clojure postaveného nad JVM. Dnes si uká¾eme nìkteré základní techniky pou¾ívané pøi optimalizaci aplikací psaných v Clojure na rychlost a/nebo spotøebu operaèní pamìti.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyk Clojure 18: základní techniky optimalizace aplikací</a></p>
<p><a href="#k02">2. Referenènì transparentní funkce a jejich význam pøi optimalizaci aplikací</a></p>
<p><a href="#k03">3. Vyu¾ití funkce <strong>memoize</strong> pro úschovu a dal¹í pou¾ití ji¾ vypoètených návratových hodnot funkcí</a></p>
<p><a href="#k04">4. Praktický pøíklad pou¾ití funkce <strong>memoize</strong></a></p>
<p><a href="#k05">5. Volba vhodných kolekcí pøi implementaci slo¾itìj¹ích datových typù</a></p>
<p><a href="#k06">6. Seznamy vs. vektory</a></p>
<p><a href="#k07">7. Implementace seznamù v&nbsp;programovacím jazyku Clojure</a></p>
<p><a href="#k08">8. Implementace vektorù v&nbsp;programovacím jazyku Clojure</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk Clojure 18: základní techniky optimalizace aplikací</h2>

<p><strong>&bdquo;First make it right. Then make it fast&ldquo;</strong></p>

<p>V&nbsp;pøedchozích èástech <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o Javì
i o virtuálním stroji Javy (JVM)</a> jsme se pøi popisu programovacího jazyka
<i>Clojure</i> zabývali pøedev¹ím tím, jak se v&nbsp;tomto jazyku pou¾ívají
jednotlivé technologie, které <i>Clojure</i> vývojáøùm nabízí. Popsali jsme si
pøedev¹ím zpùsob práce se symboly a hodnotami navázanými na tyto symboly,
vytváøení nových funkcí vèetnì funkcí anonymních, pou¾ití nemìnných
(<i>immutable</i>) kolekcí, pou¾ití sekvencí a samozøejmì takté¾ <i>lazy</i>
sekvencí, zpùsoby spou¹tìní funkcí v&nbsp;samostatných vláknech, pou¾ití
transakcí ve vícevláknových programech, navázání symbolù na takzvané
validátory, kooperaci mezi programovacími jazyky <i>Clojure</i> a <i>Java</i> a
v&nbsp;neposlední øadì jsme se takté¾ zabývali makrosystémem programovacího
jazyka <i>Clojure</i>. Ov¹em prozatím jsme si øekli jen velmi málo informací o
tom, jak je mo¾né aplikace vytváøené v&nbsp;<i>Clojure</i> optimalizovat, a to
jak s&nbsp;ohledem na rychlost výsledných aplikací (popø.&nbsb;na dobu odezvy)
i s&nbsp;ohledem na pamì»ovou nároènost.</p>

<p>To, ¾e se touto pomìrnì dùle¾itou zále¾itostí zabýváme a¾ v&nbsp;osmnácté
èásti na¹eho povídání o programovacím jazyce <i>Clojure</i> je ve skuteènosti
zámìr, proto¾e nìkteré optimalizace je (pøedev¹ím u velkých aplikací) mo¾né a
vhodné provádìt a¾ ve chvíli, kdy je aplikace z&nbsp;velké èásti funkèní a kdy
se na reálných datech uká¾e, kde jsou ve skuteènosti nejvìt¹í problémy
zpùsobující napøíklad pomalý bìh aplikace, její pomalé odezvy èi její velkou
pamì»ovou nároènost. Èistì teoreticky by mìlo být mo¾né tato místa objevit ji¾
v&nbsp;dobì analýzy, ov¹em pomìrnì velká èást aplikací prochází redesignem a¾
v&nbsp;dobì vývoje (zákazník napøíklad potøebuje do aplikace pøidat dal¹í
funkce, které zmìní strukturu databáze, co¾ se v&nbsp;lep¹ím pøípadì projeví
jen ve zmìnì hierarchie tøíd/funkcí, v&nbsp;hor¹ím pøípadì pak v&nbsp;nutnosti
vertikálnì èi horizontálnì rozdìlit databázi atd. atd.). Pokud se v¹ak vìt¹í
èást aplikace vytváøí v&nbsp;programovacím jazyku <i>Clojure</i>, je mo¾né se
zpoèátku soustøedit na implementaci vlastních algoritmù, zamìøit se na správné
pou¾ití funkcionálních technik (tím si programátor otevírá cestu
k&nbsp;mo¾nosti relativnì snadno zvý¹it výkonnost aplikace) a teprve posléze se
zabývat optimalizací na ni¾¹ích úrovních.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Referenènì transparentní funkce a jejich význam pøi optimalizaci aplikací</h2>

<p>Ji¾ v&nbsp;úvodních èláncích o programovacím jazyce <i>Clojure</i> jsme si
øekli, ¾e tento jazyk patøí, spoleènì s&nbsp;klasickým <i>LISPem</i>,
<i>Scheme</i>, <i>Haskellem</i> èi <i>Erlangem</i> do skupiny (ne v¾dy nutnì
èistì) funkcionálních jazykù, tj.&nbsp;programovacích jazykù vycházejících
z&nbsp;teorie takzvaného &lambda;-kalkulu, jeho¾ autorem je <i>Alonzo
Church</i> (na první návrhy LISPu se dokonce mù¾eme dívat jako na jeden
z&nbsp;formalizovaných zpùsobù zápisu &lambda;-kalkulu, pro nìj¾ jen tak
mimochodem existuje mechanismus vyhodnocování jednotlivých &lambda; výrazù;
takté¾ se tím vysvìtluje pøítomnost znaku lambda v&nbsp;logu jazyka
<i>Clojure</i>). Ve skuteènosti sice <i>Clojure</i> není èistì funkcionálním
jazykem, ov¹em v&nbsp;pøípadì, ¾e vývojáø bude pøi tvorbì svých aplikací
dodr¾ovat zásady funkcionálního programování, bude pro nìj mnohem snadnìj¹í
vytváøet skuteènì výkonné aplikace; a» se to ji¾ týká snadnìj¹í tvorby
bezpeèných vícevláknových aplikací èi mo¾nosti pou¾ití funkce
<strong>memoize</strong> popsané <a href="#k03">v&nbsp;následující
kapitole</a>.</p>

<p>Pøipomeòme si, ¾e v&nbsp;programovacím jazyce <i>Clojure</i> jsou funkce
pova¾ovány za plnohodnotné datové typy, co¾ znamená, ¾e funkce lze navázat na
libovolný symbol (a tím vlastnì pùvodnì anonymní funkci pojmenovat), funkce lze
pøedávat jako parametry do jiných funkcí a funkce mohou být takté¾ návratovou
hodnotou jiných funkcí &ndash; funkce tedy mù¾e vytvoøit a vrátit jinou funkci.
<i>Clojure</i> takté¾ podporuje práci s&nbsp;uzávìry (<i>closure(s)</i>),
tj.&nbsp;funkcí svázaných s&nbsp;nìjakým symbolem vytvoøeným vnì funkce.
Podpora uzávìrù umo¾òuje napøíklad tvorbu funkcí sdílejících spoleèný kontext
(GUI) atd. Ov¹em vzhledem k&nbsp;tomu, ¾e &ndash; jak ji¾ víme &ndash;
<i>Clojure</i> není èistì funkcionálním jazykem, je mo¾né pøi vytváøení
u¾ivatelských funkcí pøímo z&nbsp;dané funkce pøistupovat k&nbsp;nìjakému
globálnímu symbolu, pøesnìji øeèeno k&nbsp;symbolu &bdquo;globálnímu&ldquo;
v&nbsp;rámci nìjakého jmenného prostoru. Takté¾ lze vytváøet funkce
s&nbsp;vedlej¹ím efektem, které napøíklad zapisují data do souborù, mìní
hodnotu navázanou na globální symboly atd.</p>

<p>Vývojáøi by v¹ak nemìli tyto mo¾nosti nabízené programovacím jazykem
<i>Clojure</i> zneu¾ívat, proto¾e tím znemo¾òují vyu¾ití nìkterých
optimalizaèních technik a v&nbsp;neposlední øadì si takté¾ komplikují mo¾nost
testování takto vytvoøených funkcí. Namísto toho se ukazuje být velmi výhodné
vytváøet takzvané <i>referenènì transparentní funkce</i>, co¾ jsou funkce,
které nepøistupují k&nbsp;¾ádným globálním symbolùm, nemají ¾ádný vedlej¹í
efekt ani si nepamatují ¾ádný vnitøní stav (pøíkladem &bdquo;funkce&ldquo;
s&nbsp;vnitøním stavem je napøíklad <strong>Math/random</strong>). Referenènì
transparentní funkci jsou pøi jejím volání pøedány parametry a funkce
<strong>pouze</strong> na základì hodnot pøedaných parametrù vrátí nìjaký
výsledek. Tato (pochopitelná) vlastnost má jeden dùle¾itý dùsledek &ndash;
chování referenènì transparentní funkce je nezávislé na stavu aplikace a je
takté¾ zcela nezávislé na tom, kdy je funkce zavolána.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Vyu¾ití funkce <strong>memoize</strong> pro úschovu a dal¹í pou¾ití ji¾ vypoètených návratových hodnot funkcí</h2>

<p>Chování <i>referenènì transparentní funkce</i> je v&nbsp;èase nemìnné a
navíc platí, ¾e pokud se funkce volá se stejnými parametry, v¾dy pro tyto
parametry vrátí stejnou návratovou hodnotu. Díky tomu, ¾e chování funkce je
izolované od zbytku aplikace, nemusí se pøi jejím volání pou¾ívat ¾ádná
synchronizace s&nbsp;ostatními vlákny (není ostatnì bez zajímavosti, ¾e vý¹e
zmínìná &bdquo;funkce&ldquo; <strong>Math/random</strong> internì pou¾ívá
synchronizaci &ndash; zámky). <a href="#k02">V&nbsp;pøedchozí kapitole</a> jsme
si øekli, ¾e návratová hodnota <i>referenènì transparentní funkce</i> je
závislá pouze na hodnotì parametrù pøedaných této funkci, co¾ mj.&nbsp;znamená,
¾e je mo¾né volání funkce nahradit konstantou, která byla nìkdy
v&nbsp;minulosti volanou funkcí vrácena pro zadané parametry. Teoreticky je
tedy mo¾né vytvoøit tabulku (èi spí¹e mapu), která pro zadané parametry vrátí
stejnou hodnotu, jaká by se vrátila pøi volání zvolené funkce. Jak je v¹ak
mo¾né tuto teoretickou vlastnost pou¾ít v&nbsp;praxi? Ve skuteènosti to není
nijak obtí¾né, proto¾e mù¾eme vyu¾ít funkci <strong>memoize</strong>, která je
souèástí standardní knihovny programovacího jazyka <i>Clojure</i>.</p>

<p>Zajímavé je, ¾e funkce <strong>memoize</strong> je implementována velmi
jednodu¹e, co¾ jen ukazuje, jak flexibilní programovací jazyk <i>Clojure</i>
mù¾e být:</p>

<pre>
(defn <strong>memoize</strong>
    <i>"Returns a memoized version of a referentially transparent function. The</i>
    <i>memoized version of the function keeps a cache of the mapping from arguments</i>
    <i>to results and, when calls with the same arguments are repeated often, has</i>
    <i>higher performance at the expense of higher memory use."</i>
    {:added "1.0"
     :static true}
    [f]
    (let [mem (atom {})]
        (fn [&amp; args]
            (if-let [e (find @mem args)]
                (val e)
                (let [ret (apply f args)]
                    (swap! mem assoc args ret)
                    ret)))))
</pre>

<p>Ve funkci <strong>memoize</strong>, které se v&nbsp;parametru
<strong>f</strong> pøedává libovolná referenènì transparentní funkce (ve
skuteènosti zcela libovolná funkce &ndash; ¾ádná kontrola se neprovádí!), je
internì pou¾ita mapa navázaná na symbol <strong>mem</strong>, do ní¾ se jako
klíèe ukládají parametry volané funkce a jako pøíslu¹né hodnoty pak návratové
hodnoty zavolané funkce. Dvojice klíè-hodnota mapy <strong>mem</strong> se
postupnì roz¹iøují a vytváøí se tak cache pro danou funkci. V&nbsp;pøípadì, ¾e
se pøi &bdquo;volání&ldquo; funkce <strong>f</strong> v&nbsp;mapì nalezne klíè
odpovídající pøedávaným parametrùm, vrátí se pøímo hodnota ulo¾ená v&nbsp;mapì
pomocí <strong>(val e)</strong>, v&nbsp;opaèném pøípadì se funkce zavolá (forma
<strong>apply f args</strong>) a její návratová hodnota se ulo¾í do mapy
<strong>mem</strong> (<strong>swap! ...</strong>). Pou¾ití
<strong>memoize</strong> má pouze tøi nedostatky: interní mapu
<strong>mem</strong> není mo¾né pøi bìhu aplikace smazat, neprovádí se ¾ádné
kontroly na to, zda je pøedávaná funkce skuteènì referenènì transparentní a
mapa s&nbsp;ulo¾enými výsledky není automaticky serializována/deserializována
pøi restartu aplikace &ndash; proto se pøi restartu zaène vytváøet znovu
(serializovanou mapu by navíc bylo mo¾né pou¾ít v&nbsp;testech).</p>

<p>Pov¹imnìte si, co je výsledkem volání funkce <strong>memoize</strong>
&ndash; je jím anonymní funkce (pøesnìji øeèeno uzávìr), kterou lze pøiøadit
k&nbsp;symbolu pomocí <strong>def/defn</strong>.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Praktický pøíklad pou¾ití funkce <strong>memoize</strong></h2>

<p>Uka¾me si nyní, jak je mo¾né v&nbsp;praxi vyu¾ít funkci
<strong>memoize</strong> popsanou <a href="#k03">v&nbsp;pøedchozí kapitole</a>.
V&nbsp;jedné z&nbsp;pøedcházejících èástí tohoto seriálu byla jako demonstraèní
pøíklad pou¾ita rychlá varianta funkce pro výpoèet faktoriálu. O rychlou
variantu se jednalo z&nbsp;toho dùvodu, ¾e v&nbsp;ní nebyla pou¾ita rekurze
(pøesnìji øeèeno tail rekurze), ale namísto toho se jednodu¹e aplikovala funkce
* (násobení) na sekvenci hodnot 1..n. Mírnì upravená rychlá podoba funkce
<strong>fact</strong> je vypsána pod tímto odstavcem. Úprava oproti tvaru
funkce pou¾ité v&nbsp;pøedchozích èláncích spoèívá v&nbsp;pou¾ití konstanty 1M
pøi volání funkce <strong>range</strong>, èím¾ docílíme toho, ¾e se pøi
vlastním výpoètu namísto hodnot typu <strong>long</strong> (rozsah 64 bitù)
budou pou¾ívat instance tøídy <strong>java.math.BigDecimal</strong>, èím¾ se
roz¹íøí rozsah výsledných hodnot:</p>

<pre>
<i>; rychlý výpoèet faktoriálu</i>
(defn <strong>fact</strong>
    [n]
    (apply *
        (range 1M (inc n))))
</pre>

<p>Výpoèet faktoriálu je sice skuteènì relativnì rychlý, ov¹em v&nbsp;pøípadì,
¾e budeme tuto funkci volat stále se stejným parametrem, bude se výpoèet
neustále opakovat. To se ji¾ mù¾e negativnì projevit na výsledném výkonu
aplikace, zejména tehdy, pokud se bude poèítat faktoriál velkého èísla
<i>n</i>, co¾ v&nbsp;dané implementaci vy¾aduje <i>n</i> násobení, které není
v&nbsp;pøípadì <strong>java.math.BigDecimal</strong> rychlou operací. Ostatnì
se o tom mù¾eme jednodu¹e pøesvìdèit sami:</p>

<pre>
user=&gt; <strong>(dotimes [i 10] (time (fact 10000)))</strong>
"Elapsed time: 1351.005784 msecs"
"Elapsed time: 1308.91524 msecs"
"Elapsed time: 1307.073668 msecs"
"Elapsed time: 1367.755396 msecs"
"Elapsed time: 1516.798644 msecs"
"Elapsed time: 1357.112148 msecs"
"Elapsed time: 1343.379676 msecs"
"Elapsed time: 1397.393524 msecs"
"Elapsed time: 1319.43194 msecs"
"Elapsed time: 1311.928468 msecs"
nil
&nbsp;
user=&gt;
</pre>

<p>Ka¾dý výpoèet trval pøibli¾nì 1,3 sekundy, nezávisle na tom, ¾e jsme volali
referenènì transparentní funkci se stále stejným parametrem. Pokud v¹ak
vyu¾ijeme funkci <strong>memoize</strong>, bude v¹e vypadat zcela jinak:</p>

<pre>
<i>; rychlý výpoèet faktoriálu se zapamatováním výsledku výpoètu</i>
(def <strong>fact2</strong>
    (<strong>memoize</strong> (
        fn [n]
        (apply *
            (range 1M (inc n))))))
</pre>

<p>Pøedchozí zápis znamená vytvoøení nového symbolu se jménem
<strong>fact2</strong> navázaného na výsledek funkce <strong>memoize</strong>,
které se pøedala anonymní funkce pro výpoèet faktoriálu (vlastní zápis výpoètu
se vùbec nezmìnil). Pøi ka¾dém volání <strong>fact2</strong> se zkontroluje,
zda ji¾ pro pøedávaný parametr neexistuje výsledek a ten se pøípadnì pou¾ije.
Èasy bìhu funkce <strong>fact2</strong> pro stejný parametr pak budou
diametrálnì odli¹né:</p>

<pre>
user=&gt; <strong>(dotimes [i 10] (time (fact2 10000)))</strong>
"Elapsed time: 1320.770096 msecs"
"Elapsed time: 0.022908 msecs"
"Elapsed time: 0.013688 msecs"
"Elapsed time: 0.013692 msecs"
"Elapsed time: 0.013688 msecs"
"Elapsed time: 0.013408 msecs"
"Elapsed time: 0.013412 msecs"
"Elapsed time: 0.013412 msecs"
"Elapsed time: 0.013132 msecs"
"Elapsed time: 0.013968 msecs"
nil
&nbsp;
user=&gt;
</pre>

<p>Vidíme, ¾e výpoèet probìhl pouze jednou a posléze se ji¾ prakticky ihned
vracel výsledek ulo¾ený ve vyrovnávací pamìti (mapì)! Jedná se tedy o klasický
typ optimalizace, v&nbsp;ní¾ se programátor rozhoduje mezi dobou bìhu a nároky
na operaèní pamì».</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Volba vhodných kolekcí pøi implementaci slo¾itìj¹ích datových typù</h2>

<p>Kromì snahy o pou¾ití referenènì transparentních funkcí mù¾e programátor
dosti podstatným zpùsobem ovlivnit výkonnost aplikace takté¾ volbou vhodných
typù kolekcí, s&nbsp;jejich¾ vyu¾itím se vytváøí slo¾itìj¹í datové struktury
&ndash; stromy, grafy atd. Pøipomeòme si, ¾e programovací jazyk <i>Clojure</i>
podporuje ètyøi typy kolekcí. Ve v¹ech pøípadech se jedná o nemìnitelné
(<i>immutable</i>) kolekce, jejich¾ obsah není mo¾né mìnit &ndash; nelze do
nich tedy pøidávat dal¹í prvky, ubírat prvky ani mìnit hodnotu prvkù. Ve
standardní knihovnì ov¹em existuje velké mno¾ství funkcí, které vezmou kolekci
jako svùj vstupní parametr a vrátí kolekci jinou, napøíklad pùvodní kolekci
s&nbsp;pøidaným novým prvkem atd. (pùvodní kolekce v¹ak zùstane nezmìnìna).
V¹echny ètyøi typy kolekcí jsou i se svými konstruktory vypsány
v&nbsp;následující tabulce:</p>

<table>
<tr><th>Typ kolekce</th><th>Zápis kolekce (syntaktický cukr)</th><th>Konstruktor</th></tr>
<tr><td>Seznam </td><td>(prvky)</td><td>(prvky)</td></tr>
<tr><td>Vektor </td><td>[prvky]</td><td>(vector prvky)</td></tr>
<tr><td>Mapa   </td><td>{dvojice klíè-hodnota}</td><td>(hash-map dvojice klíè-hodnota)</td></tr>
<tr><td>Mno¾ina</td><td>#{unikátní prvky}</td><td>(hash-set unikátní prvky)</td></tr>
</table>

<p>Pøi volbì vhodné kolekce, která má tvoøit základ datové struktury, se
vývojáø mù¾e orientovat i podle toho, jaké rozhraní (ve smyslu programovacího
jazyka Java) jednotlivé kolekce implementují. Tím jsou urèeny základní
vlastnosti ka¾dé kolekce:</p>

<table>
<tr><th>Rozhraní</th><th>seznam</th><th>vektor</th><th>mapa</th><th>mno¾ina</th></tr>
<tr><td>java.util.Collection  </td><td>ano</td><td>ano</td><td>ne </td><td>ano</td></tr>
<tr><td>java.util.List        </td><td>ano</td><td>ano</td><td>ne </td><td>ne </td></tr>
<tr><td>java.util.Map         </td><td>ne </td><td>ne </td><td>ano</td><td>ne </td></tr>
<tr><td>java.util.Set         </td><td>ne </td><td>ne </td><td>ne </td><td>ano</td></tr>
<tr><td>java.util.RandomAccess</td><td>ne </td><td>ano</td><td>ne </td><td>ne </td></tr>
<tr><td>java.lang.Iterable    </td><td>ano</td><td>ano</td><td>ano</td><td>ano</td></tr>
<tr><td>java.lang.Comparable  </td><td>ne </td><td>ano</td><td>ne </td><td>ne </td></tr>
</table>

<p>Programátoøi vìt¹inou nemívají problém s&nbsp;rozhodnutím, zda se má pou¾ít
seznam/vektor na jedné stranì èi mapa na stranì druhé &ndash; pokud se má pøi
pøístupu k&nbsp;prvkùm pou¾ít neceloèíselný klíè, je vìt¹inou na místì pou¾ít
mapu. Ov¹em ponìkud hor¹í situaci má vývojáø pøi rozhodování, pro které datové
struktury má vyu¾ít seznam (<i>list</i>) a kde naopak vektor (<i>vector</i>).
To je i téma <a href="#k06">následující kapitoly</a>.</p>

<p>Odkazy na související èlánky:</p>

<ol>

<li>Clojure Data Structures<br />
<a href="http://clojure.org/data_structures">http://clojure.org/data_structures</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 2.2.1  Representing Sequences<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 3.3.1  Mutable List Structure<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1</a>
</li>

</ol>



<p><a name="k06"></a></p>
<h2 id="k06">6. Seznamy vs. vektory</h2>

<p>Programovací jazyk <i>LISP</i>, z&nbsp;nìho¾ je <i>Clojure</i> ve velké míøe
odvozen, byl pùvodnì zalo¾en prakticky pouze na pou¾ití seznamù, které se
vyu¾ívaly jak pro ukládání dat, tak i pro reprezentaci vlastního programu,
proto¾e program (jeho funkce) lze reprezentovat jako seznam seznamù. Nejinak je
tomu i v&nbsp;programovacím jazyce <i>Clojure</i>, jen¾ v¹ak kromì seznamù
pomìrnì intenzivnì pou¾ívá i vektory (napøíklad parametry funkce se zapisují do
vektorù atd.), co¾ musí mít svoje opodstatnìní. Seznamy a vektory se toti¾ od
sebe odli¹ují pøedev¹ím svojí vnitøní strukturou, z&nbsp;ní¾ pøímo vyplývají i
operace, které lze s&nbsp;tìmito kolekcemi provádìt a v&nbsp;neposlední øadì i
slo¾itost jednotlivých operací, která nás dnes takté¾ zajímá.</p>

<table>
<tr><th>Kolekce</th><th>Implementované rozhraní</th><th>Implementováno v...</th><th>Predikát</th></tr>
<tr><td>Seznam</td><td>IPersistentList  </td><td>PersistentList.java</td><td>list?</td></tr>
<tr><td>Vektor</td><td>IPersistentVector</td><td>PersistentVector.java</td><td>vector?</td></tr>
</table>

<p>Jeden z&nbsp;rozdílù mezi obìma kolekcemi spoèívá v&nbsp;tom, ¾e prvky
vektorù je mo¾né èíst jako pøímou sekvenci i jako sekvenci otoèenou (od
posledního prvku k&nbsp;prvku prvnímu). Nad vektorem lze tedy zavolat funkci
<strong>seq</strong> i <strong>rseq</strong>, zatímco u seznamù pouze funkci
<strong>seq</strong> &ndash; prvky lze èíst pouze od zaèátku seznamu do konce.
Dal¹í rozdíl mezi seznamy a vektory spoèívá v&nbsp;odli¹ném chování funkce
<strong>conj</strong>, kterou lze pou¾ít k&nbsp;vytvoøení kopie pùvodní kolekce
doplnìné o nové prvky. U seznamù se prvky pøidávají na jeho zaèátek, zatímco u
vektorù je tomu pøesnì naopak &ndash; vrácen je nový vektor s&nbsp;prvky
pøidanými na jeho konci. Podobnì se li¹í chování funkcí <strong>pop</strong> a
<strong>peek</strong>. Shròme si nyní jednotlivé funkèní rozdíly mezi seznamy a
vektory pøehlednì do tabulky:</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Seznam</th><th>Vektor</th></tr>
<tr><td>1</td><td>seq  </td><td>podporováno</td><td>podporováno</td></tr>
<tr><td>2</td><td>rseq </td><td>není podporováno</td><td>podporováno</td></tr>
<tr><td>3</td><td>conj </td><td>nové prvky + pùvodní seznam</td><td>vektor + nové prvky</td></tr>
<tr><td>4</td><td>pop  </td><td>seznam bez prvního prvku</td><td>vektor bez posledního prvku</td></tr>
<tr><td>5</td><td>peek </td><td>první prvek seznamu</td><td>poslední prvek vektoru</td></tr>
<tr><td>5</td><td>first</td><td>první prvek seznamu</td><td>první prvek vektoru</td></tr>
<tr><td>6</td><td>last </td><td>poslední prvek seznamu</td><td>poslední prvek vektoru</td></tr>
<tr><td>7</td><td>nth  </td><td>n-tý prvek seznamu</td><td>n-tý prvek vektoru</td></tr>
<tr><td>8</td><td>count</td><td>poèet prvkù seznamu</td><td>poèet prvkù vektoru</td></tr>
</table>

<p>Dùle¾ité je pøi optimalizaci aplikací i porovnání výpoèetní slo¾itosti
nìkterých funkcí z&nbsp;pøedchozí tabulky, proto¾e právì odli¹ná slo¾itost mù¾e
výrazným zpùsobem ovlivnit výkonnost celé aplikace, zejména tehdy, pokud se
budou pou¾ívat kolekce s&nbsp;velkým mno¾stvím prvkù. Zajímavé je, ¾e funkce
<strong>count</strong> má v&nbsp;obou pøípadech konstantní slo¾itost:
<i>O(1)</i>. To znamená, ¾e v&nbsp;<i>Clojure</i> nemá smysl poèítat poèet
prvkù seznamu s&nbsp;vyu¾itím rekurzivní funkce, co¾ je jeden z&nbsp;oblíbených
¹kolních pøíkladù pou¾ívaných pøi výuce LISPu :-) Naproti tomu funkce
<strong>nth</strong> se sice u obou typù kolekcí chová stejnì, má v¹ak výraznì
odli¹nou slo¾itost: <i>O(n)</i> v&nbsp;pøípadì seznamù (lineární slo¾itost) a
<i>O(log<sub>32</sub>N)</i> v&nbsp;pøípadì vektorù (logaritmická slo¾itost). U
krátkých vektorù (do 32 prvkù) je slo¾itost konstantní a i u del¹ích vektorù je
poèet krokù nutných pro získání n-tého prvku velmi malý (napøíklad dva kroky
pro vektory o délce pøibli¾nì 1000 prvkù atd.). Slo¾itost funkce
<strong>peek</strong> je v&nbsp;pøípadì vektoru takté¾ rovna
<i>O(log<sub>32</sub>N)</i>, na rozdíl od funkce <strong>last</strong> se
slo¾itostí <i>O(N)</i> &ndash; v&nbsp;pøípadì vektorù tedy v¾dy pou¾ívejte
<strong>peek</strong>!</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Seznam</th><th>Vektor</th></tr>
<tr><td>1</td><td>count</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>2</td><td>nth  </td><td>O(N)</td><td>O(log<sub>32</sub>N)</td></tr>
<tr><td>3</td><td>pop  </td><td>O(1)</td><td>O(log<sub>32</sub>N)</td></tr>
<tr><td>4</td><td>peek </td><td>O(1)</td><td>O(log<sub>32</sub>N)</td></tr>
<tr><td>5</td><td>first</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>6</td><td>last </td><td>O(N)</td><td>O(N)</td></tr>
</table>

<p>Pov¹imnìte si, ¾e vektory ve skuteènosti neodpovídají slo¾itostí nìkterých
funkcí bì¾nì chápaným vektorùm-jednorozmìrným polím. Je tomu tak z&nbsp;toho
dùvodu, ¾e v&nbsp;<i>Clojure</i> jsou vektory implementovány odli¹ným zpùsobem
a to zejména proto, aby bylo mo¾né jednodu¹e implementovat funkci
<strong>conj</strong>, tj.&nbsp;aby se ji¾ vytvoøená datová struktura mohla
sdílet mezi vìt¹ím mno¾stvím vektorù (to je mo¾né i díky jejich nemìnnosti),
Proè se od sebe seznamy a vektory tak diametrálnì odli¹ují, si øekneme
v&nbsp;následujících dvou kapitolách.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Implementace seznamù v&nbsp;programovacím jazyku Clojure</h2>

<p>Programovací jazyk <i>LISP</i>, který je ideovým pøedchùdcem jazyka
<i>Clojure</i>, byl pùvodnì zalo¾en prakticky pouze na pou¾ití seznamù, které
byly pova¾ovány za zcela univerzální datovou strukturu. V&nbsp;tradièních
<i>LISPech</i> jsou seznamy implementované pomocí takzvaných teèka-dvojic
(<i>dot-pair</i>), co¾ jsou dvojice prvkù, pøièem¾ ka¾dý prvek buï mù¾e
obsahovat nìjakou hodnotu nebo obsahuje odkaz na dal¹í teèka-dvojici. Bì¾ný
seznam pak byl vytvoøen jako jednosmìrnì vázaný lineární seznam slo¾ený
z&nbsp;teèka-dvojic, kde první prvek ve dvojici obsahoval nìjakou hodnotu a
druhý prvek pak odkaz na prvek následující. U nìkterých variant programovacího
jazyka <i>LISP</i> se navíc obsah ka¾dého prvku v&nbsp;teèka dvojici rozdìloval
na takzvaný <i>tag</i> (øeknìme zjednodu¹enì popis datového typu) a vlastní
hodnotu, co¾ bylo z&nbsp;hlediska obsazení operaèní pamìti pomìrnì efektivní
øe¹ení. Pro pøístup k&nbsp;prvkùm seznamù se pou¾ívaly dvì funkce pojmenované
z&nbsp;historických dùvodù <strong>car</strong> a <strong>cdr</strong>. Funkce
<strong>car</strong> vracela první prvek seznamu a funkce <strong>cdr</strong>
zbytek seznamu, tj.&nbsp;v¹echny prvky následující.</p>

<p>Vzhledem k&nbsp;tomu, ¾e seznam byl implementován formou na sebe
navazujících teèka dvojic, byla implementace obou funkcí
<strong>car/cdr</strong> triviální a tyto funkce mìly konstantní slo¾itost.
Naproti tomu funkce <strong>nth</strong> (pøístup k&nbsp;<i>n</i>-tému prvku
seznamu) mìla slo¾itost lineární: <i>O(n)</i>. Podobnì funkce zji¹»ující poèet
prvkù seznamu <strong>count</strong> mìla lineární slo¾itost. V&nbsp;pøípadì
programovacího jazyka <i>Clojure</i> je situace ponìkud odli¹ná od vìt¹iny
dal¹ích implementací <i>LISPu</i>. První odli¹nost spoèívá v&nbsp;tom, ¾e prvky
seznamu jsou typu <strong>java.lang.Object</strong> a jedná se tedy v¾dy o
reference a nikoli pøímo o hodnoty. Na celý seznam se tedy mù¾eme dívat jako na
posloupnost referencí, internì je ov¹em celý seznam tvoøen rekurzivní
strukturou slo¾enou z&nbsp;prvního prvku a zbytku seznamu (jde tedy o obdobu
teèka-dvojic) &ndash; právì tato vlastnost vede k&nbsp;tomu, ¾e pøidání dal¹ích
prvkù na zaèátek seznamu pomocí funkce <strong>conj</strong> je výpoèetnì
nenároènou operací. Vlastní hodnoty jsou pak ulo¾eny nìkde na haldì (heapu).
Druhá odli¹nost spoèívá v&nbsp;tom, ¾e ka¾dý seznam si pamatuje svoji délku,
tak¾e slo¾itost funkce <strong>count</strong> je v&nbsp;jazyce <i>Clojure</i>
konstantní.</p>

<p>Jen pro zajímavost se podívejme na èást kódu s&nbsp;implementací
seznamu:</p>

<pre>
public class <strong>PersistentList</strong> extends ASeq implements IPersistentList, IReduce, List, Counted {
&nbsp;
    <i>// první prvek seznamu</i>
    private final Object _first;
    <i>// dal¹í prvky seznamu</i>
    private final IPersistentList _rest;
    <i>// délka seznamu</i>
    private final int _count;
&nbsp;
<i>// slo¾itost O(1)</i>
public Object <strong>first</strong>(){
    return _first;
}
&nbsp;
<i>// slo¾itost O(1)</i>
public ISeq <strong>next</strong>(){
    if(_count == 1)
        return null;
    return (ISeq) _rest;
}
<i>// slo¾itost O(n)</i>
public Object <strong>get</strong>(int index){
    return RT.nth(this, index);
}
</pre>

<p>Volání funkce <strong>nth</strong> internì vede k&nbsp;volání následující metody:</p>

<pre>
static Object <strong>nthFrom</strong>(Object coll, int n){
    else if(coll instanceof Sequential) {
        ISeq seq = RT.seq(coll);
        coll = null;
        for(int i = 0; i &lt;= n &amp;&amp; seq != null; ++i, seq = seq.next()) {
            if(i == n)
                return seq.first();
        }
        throw new IndexOutOfBoundsException();
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Implementace vektorù v&nbsp;programovacím jazyku Clojure</h2>

<p>V&nbsp;programovacím jazyku <i>Clojure</i> se na mnoha místech seznamy
nahrazují za vektory, proto¾e práce s&nbsp;vektory mù¾e být více efektivní.
Vektor mù¾eme pova¾ovat za jednorozmìrné pole hodnot libovolných typù, tak¾e by
se mohlo zdát, ¾e slo¾itost pøístupu k&nbsp;jeho prvkùm bude konstantní
<i>O(N)</i>. Ve skuteènosti jsou v¹ak vektory internì implementovány ponìkud
slo¾itìj¹ím (a velmi zajímavým) zpùsobem a to pøedev¹ím z&nbsp;toho dùvodu, aby
bylo snadné k&nbsp;vektorùm pøipojovat dal¹í prvky &ndash; tak vznikne nový
vektor, ov¹em pùvodní vektor musí samozøejmì zùstat zachovaný. Proto se
v&nbsp;<i>Clojure</i> (a v&nbsp;nìkterých dal¹ích moderních programovacích
jazycích) pou¾ívají pro implementaci vektorù takzvané <i>RRB-Stromy (RRB-Trees,
Relaxed Radix Balanced Trees)</i>. V&nbsp;<i>Clojure</i> jsou pou¾ity
(vyvá¾ené) RRB-stromy, které mají v&nbsp;ka¾dém listu ulo¾eno jednorozmìrné
pole o délce 32 prvkù. Pokud se pracuje s&nbsp;krat¹ím vektorem, je pro jeho
ulo¾ení pou¾it strom pouze s&nbsp;jedním listem a tudí¾ je vektor skuteènì
reprezentován jednorozmìrným polem (ve skuteènosti se vedle vlastního stromu
pou¾ívá je¹tì pomocné pole <strong>tail</strong>, pro jednoduchost v¹ak jeho
roli v&nbsp;tomto textu ponìkud zanedbáme).</p>

<p>U del¹ích vektorù se v&nbsp;32prvkovém poli ulo¾eném v&nbsp;koøenu stromu
<strong>ne</strong>nachází pøímo prvky vektoru, ale reference na dal¹í listy,
z&nbsp;nich¾ ka¾dý opìt obsahuje 32prvkové pole. To znamená, ¾e vektor
s&nbsp;a¾ 1024 prvky mù¾e být ulo¾en ve stromu o vý¹ce 1, ve stromu o vý¹ce 2
je celkový (mo¾ný) poèet prvkù vektoru roven 32768 (1024 listù á 32 prvkù) atd.
Operace vrácení <i>n</i>-tého prvku má tedy slo¾itost
<i>O(log<sub>32</sub>N)</i>, co¾ sice není konstantní slo¾itost <i>O(1)</i>,
ale pro vektory bì¾ných délek mù¾eme tuto slo¾itost takté¾ pova¾ovat za
konstantní. Pøedností vektorù je tedy rychlej¹í pøístup k&nbsp;jeho prvkùm, ale
nesmíme zapomenout ani na pamì»ové nároky &ndash; vektory internì potøebují
mnohem ménì referencí, ne¾ je tomu u seznamù, tudí¾ i pamì»ové nároky budou
ni¾¹í, a to zejména na 64bitových systémech; samozøejmì pokud zde u¾ivatelé
nepovolí pou¾ití komprimovaných ukazatelù (<i>compressed oops</i>).</p>

<p>Interní strukturu vektoru opìt mù¾eme zjistit pøímo ze zdrojových textù
programovacího jazyka <i>Clojure</i>:</p>

<pre>
public class <strong>PersistentVector</strong> extends APersistentVector implements IObj, IEditableCollection{
    <i>// délka vektoru</i>
    final int cnt;
&nbsp;
    <i>// vý¹ka stromu</i>
    final int shift;
&nbsp;
    <i>// koøen stromu</i>
    final Node root;
&nbsp;
    <i>// a¾ 32 posledních prvkù vektoru je ulo¾eno v tomto pomocném poli</i>
    final Object[] tail;
&nbsp;
</pre>

<p>Zajímavá je implementace funkce <strong>nth</strong>:</p>

<pre>
<i>// získání i-tého prvku vektoru</i>
public Object <strong>nth</strong>(int i){
    <i>// uzel stromu, který obsahuje pøíslu¹ný prvek</i>
    Object[] node = arrayFor(i);
    <i>// nyní nás zajímá pouze index 0..31</i>
    return node[i &amp; 0x01f];
}
&nbsp;
<i>// rekurzivní vyhledání pøíslu¹ného listu</i>
public Object[] <strong>arrayFor</strong>(int i){
    if(i &gt;= 0 &amp;&amp; i &lt; cnt)
        {
        <i>// prvek hledejme v pomocném poli tail</i>
        if(i &gt;= tailoff())
            return tail;
        Node node = root;
        <i>// vlastní rekurzivní prùchod stromem</i>
        for(int level = shift; level &gt; 0; level -= 5)
            node = (Node) node.array[(i &gt;&gt;&gt; level) &amp; 0x01f];
        return node.array;
        }
    throw new IndexOutOfBoundsException();
}
&nbsp;
final int <strong>tailoff</strong>(){
    if(cnt &lt; 32)
        return 0;
    return ((cnt - 1) &gt;&gt;&gt; 5) &lt;&lt; 5;
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Èistì funkcionální (datové struktury, jazyky, programování)<br />
<a href="http://cs.wikipedia.org/wiki/Èistì_funkcionální">http://cs.wikipedia.org/wiki/Èistì_funkcionální</a>
</li>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Eulerovo èíslo<br />
<a href="http://cs.wikipedia.org/wiki/Eulerovo_èíslo">http://cs.wikipedia.org/wiki/Eulerovo_èíslo</a>
</li>

<li>List comprehension<br />
<a href="http://en.wikipedia.org/wiki/List_comprehension">http://en.wikipedia.org/wiki/List_comprehension</a>
</li>

<li>List Comprehensions in Clojure<br />
<a href="http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html">http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html</a>
</li>

<li>Clojure Programming Concepts: List Comprehension<br />
<a href="http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension">http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension</a>
</li>

<li>Clojure core API: for macro<br />
<a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for">http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for</a>
</li>

<li>cirrus machina - The Clojure for macro<br />
<a href="http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/">http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/</a>
</li>

<li>Clojure.org: Clojure home page<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>A Couple of Clojure Agent Examples<br />
<a href="http://lethain.com/a-couple-of-clojure-agent-examples/">http://lethain.com/a-couple-of-clojure-agent-examples/</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/">http://java.sun.com/developer/technicalArticles/DynTypeLang/</a>
</li>

<li>JSR 223: Scripting for the Java<sup>TM</sup> Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=223">http://jcp.org/en/jsr/detail?id=223</a>
</li>

<li>JSR 292: Supporting Dynamically Typed Languages on the Java<sup>TM</sup> Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=292">http://jcp.org/en/jsr/detail?id=292</a>
</li>

<li>Java 7: A complete invokedynamic example<br />
<a href="http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html">http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html</a>
</li>

<li>InvokeDynamic: Actually Useful?<br />
<a href="http://blog.headius.com/2007/01/invokedynamic-actually-useful.html">http://blog.headius.com/2007/01/invokedynamic-actually-useful.html</a>
</li>

<li>A First Taste of InvokeDynamic<br />
<a href="http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html">http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html</a>
</li>

<li>Java 6 try/finally compilation without jsr/ret<br />
<a href="http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html">http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Root.cz: Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM<br />
<a href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/</a></a>
</li>

<li>Root.cz: JamVM aneb alternativa k HotSpotu nejenom pro embedded zaøízení a chytré telefony<br />
<a href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>FindBugs<br />
<a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a>
</li>

<li>GNU Classpath<br />
<a href="www.gnu.org/s/classpath/">www.gnu.org/s/classpath/</a></li>

<li>Java VMs Compared<br />
<a href="http://bugblogger.com/java-vms-compared-160/">http://bugblogger.com/java-vms-compared-160/</a>
</li>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Scala Programming Language<br />
<a href="http://www.scala-lang.org/">http://www.scala-lang.org/</a>
</li>

<li>Run Scala in Apache Tomcat in 10 minutes<br />
<a href="http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes">http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes</a>
</li>

<li>Fast Web Development With Scala<br />
<a href="http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html">http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html</a>
</li>

<li>Top five scripting languages on the JVM<br />
<a href="http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855">http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>CloseableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html">http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

