<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (6 - pøeklad programových smyèek do mezijazyka LuaJITu)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (6 - pøeklad programových smyèek do mezijazyka LuaJITu)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V ¹esté èásti èlánku o Just in Time pøekladaèi nazvaném LuaJIT si vysvìtlíme, jakým zpùsobem se pøekládají programové smyèky typu while, repeat-until i smyèky typu for-each pou¾ívané jak pøi procházení bì¾ných polí (s prvky adresovanými s vyu¾itím indexù), tak i pøi procházení v¹emi prvky asociativních polí.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (6 - pøeklad programových smyèek do mezijazyka LuaJITu)</a></p>
<p><a href="#k02">2. Pøeklad programové smyèky typu <strong>while</strong></a></p>
<p><a href="#k021">&nbsp;&nbsp;2.1 Zdrojový kód pøíkladu <strong>test30.lua</strong></a></p>
<p><a href="#k022">&nbsp;&nbsp;2.2 Pøeklad pøíkladu <strong>test30.lua</strong> do mezijazyka LuaJITu</a></p>
<p><a href="#k03">3. Pøeklad programové smyèky typu <strong>repeat-until</strong></a></p>
<p><a href="#k031">&nbsp;&nbsp;3.1 Zdrojový kód pøíkladu <strong>test31.lua</strong></a></p>
<p><a href="#k032">&nbsp;&nbsp;3.2 Pøeklad pøíkladu <strong>test31.lua</strong> do mezijazyka LuaJITu</a></p>
<p><a href="#k04">4. Programová smyèka typu <strong>while</strong> a pøíkaz <strong>break</strong></a></p>
<p><a href="#k041">&nbsp;&nbsp;4.1 Zdrojový kód pøíkladu <strong>test32.lua</strong></a></p>
<p><a href="#k042">&nbsp;&nbsp;4.2 Pøeklad pøíkladu <strong>test32.lua</strong> do mezijazyka LuaJITu</a></p>
<p><a href="#k05">5. Programová smyèka typu <strong>repeat-until</strong> a pøíkaz <strong>break</strong></a></p>
<p><a href="#k051">&nbsp;&nbsp;5.1 Zdrojový kód pøíkladu <strong>test33.lua</strong></a></p>
<p><a href="#k052">&nbsp;&nbsp;5.2 Pøeklad pøíkladu <strong>test33.lua</strong> do mezijazyka LuaJITu</a></p>
<p><a href="#k06">6. Prùchod v¹emi prvky pole ve smyèce <strong>while</strong> s&nbsp;vyu¾itím funkce <strong>next()</strong></a></p>
<p><a href="#k061">&nbsp;&nbsp;6.1 Zdrojový kód pøíkladu <strong>test34.lua</strong></a></p>
<p><a href="#k062">&nbsp;&nbsp;6.2 Pøeklad pøíkladu <strong>test34.lua</strong> do mezijazyka LuaJITu</a></p>
<p><a href="#k07">7. Programová smyèka <strong>for</strong> a <strong>for-each</strong></a></p>
<p><a href="#k071">&nbsp;&nbsp;7.1 Poèítaná programová smyèka typu <strong>for</strong></a></p>
<p><a href="#k072">&nbsp;&nbsp;7.2 Smyèka typu <strong>for-each</strong> pøi prùchodu polem</a></p>
<p><a href="#k073">&nbsp;&nbsp;7.3 Smyèka typu <strong>for-each</strong> pøi prùchodu asociativním polem</a></p>
<p><a href="#k08">8. Zdrojové kódy v¹ech pìti dne¹ních demonstraèních pøíkladù</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (6 - pøeklad programových smyèek do mezijazyka LuaJITu)</h2>

<p>Velmi dùle¾itou souèástí mezijazyka pou¾ívaného Just in Time pøekladaèem
<i>LuaJIT</i> jsou instrukce pou¾ité pøi implementaci programových smyèek.
Autor <i>LuaJITu</i> toti¾ (velmi správnì) usoudil, ¾e vìt¹ina hot-spotù, tedy
tìch èástí kódu, které se vyplatí pøekládat JIT pøekladaèem, se nachází právì
v&nbsp;programových smyèkách. Kvùli zjednodu¹ení práce JIT pøekladaèe tedy
mezijazyk <i>LuaJITu</i> obsahuje pomìrnì velké mno¾ství speciálních instrukcí
pou¾itých právì pøi pøekladu programových smyèek, i kdy¾ mnohé jiné bajtkódy si
vystaèí s&nbsp;prostými podmínìnými a nepodmínìnými skoky. Konstrukci
programových smyèek si uká¾eme na pìti demonstraèních pøíkladech, v&nbsp;nich¾ budou
implementovány jak jednoduché smyèky typu <strong>while</strong> a
<strong>repeat-until</strong>, tak i ponìkud slo¾itìj¹í smyèky, v&nbsp;nich¾ je
pou¾it pøíkaz <strong>break</strong> (ten je v&nbsp;programovacím jazyku
<i>Lua</i> samozøejmì podporován). V&nbsp;pøelo¾ených kódech se setkáme
mj.&nbsp;i s&nbsp;následujícími instrukcemi (z&nbsp;nich¾ vìt¹inu ji¾
známe):</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Operandy</th><th>Popis</th></tr>
<tr><td> 1</td><td>JMP  </td><td>adresa</td><td>nepodmínìný skok, popø.&nbsp;podmínìný skok, pokud mu pøedchází instrukce I*</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 2</td><td>ISLT </td><td>slot, slot</td><td>následuje skok provedený pøi splnìní podmínky A &lt; D</td></tr>
<tr><td> 3</td><td>ISGE </td><td>slot, slot</td><td>následuje skok provedený pøi splnìní podmínky A &ge; D</td></tr>
<tr><td> 4</td><td>ISLE </td><td>slot, slot</td><td>následuje skok provedený pøi splnìní podmínky A &le; D</td></tr>
<tr><td> 5</td><td>ISGT </td><td>slot, slot</td><td>následuje skok provedený pøi splnìní podmínky A &gt; D</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>ISEQV</td><td>slot, slot</td><td>následuje skok provedený pøi splnìní podmínky A = D   </td></tr>
<tr><td> 7</td><td>ISNEV</td><td>slot, slot</td><td>následuje skok provedený pøi splnìní podmínky A &ne; D</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>ISEQN</td><td>slot, konstanta</td><td>následuje skok provedený pøi splnìní podmínky A = konstanta</td></tr>
<tr><td> 9</td><td>ISNEN</td><td>slot, konstanta</td><td>následuje skok provedený pøi splnìní podmínky A &ne; konstanta</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>ISEQP</td><td>slot, pri</td><td>následuje skok provedený pøi splnìní podmínky A = pri_type</td></tr>
<tr><td>11</td><td>ISNEP</td><td>slot, pri</td><td>následuje skok provedený pøi splnìní podmínky A &ne; pri_type</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>12</td><td>ISEQS</td><td>slot, string</td><td>následuje skok provedený pøi splnìní podmínky A = string</td></tr>
<tr><td>13</td><td>ISNES</td><td>slot, string</td><td>následuje skok provedený pøi splnìní podmínky A &ne; string</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>14</td><td>IST</td><td>slot</td><td>následuje skok provedený pøi splnìní podmínky A = true</td></tr>
<tr><td>15</td><td>ISF</td><td>slot</td><td>následuje skok provedený pøi splnìní podmínky A = false</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>ITERC </td><td>base, lit, lit</td><td>volání iterátoru A s&nbsp;parametry v A+1 a A+2</td></tr>
<tr><td>17</td><td>ITERN </td><td>base, lit, lit</td><td>varianta instrukce ITERC pro funkci next() èi pairs()</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>LOOP  </td><td>rbase, jump</td><td>pou¾ití pøi JITování a detekci hot-spotù, neprovádí se skok!</td></tr>
<tr><td>19</td><td>ITERL </td><td>base, jump</td><td>iterátor pro smyèku typu for-each, kontrola na hodnotu odli¹nou od nil a podmínìný skok</td></tr>
<tr><td>20</td><td>ISNEXT</td><td>base, jump</td><td>pou¾ito se speciální instrukcí ITERN pro podmínìný skok</td></tr>
</table>

<p>Pou¾ití tìchto instrukcí, pøedev¹ím pak instrukcí <strong>IS*</strong>,
<strong>JMP</strong> a <strong>LOOP</strong> si uká¾eme na pìti demonstraèních
pøíkladech popsaných v&nbsp;navazujících kapitolách.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Pøeklad programové smyèky typu <strong>while</strong></h2>

<p>Nejjednodu¹¹ím typem programové smyèky v&nbsp;jazyce <i>Lua</i> je smyèka
typu <strong>while</strong>, tj.&nbsp;taková smyèka, v&nbsp;ní¾ se podmínka pro
její ukonèení testuje pøed zaèátkem ka¾dé dal¹í iterace. Takto zkonstruovaná
smyèka nemusí probìhnout ani jedenkrát (pokud je ji¾ pøed první iterací
podmínka neplatná) a souèasnì se jedná o zcela univerzální programovou smyèku.
V&nbsp;pøípadì <i>LuaJITu</i> je pøeklad této smyèky proveden podle jednotné
¹ablony následujícím zpùsobem:</p>

<pre>
+---&gt; <strong>IS??</strong>     <i>; podmínka odvozená z invertované podmínky zapsané ve zdrojovém kódu</i>
|     <strong>JMP</strong> --+  <i>; podmínìný skok ZA konec programové smyèky</i>
|     <strong>LOOP</strong>  |  <i>; oznaèení generické programové smyèky (pro detekci hot spotù)</i>
|     <strong>?</strong>     |
|     <strong>?</strong>     |  <i>; instrukce tvoøící tìlo smyèky</i>
|     <strong>?</strong>     |  <i>; instrukce tvoøící tìlo smyèky</i>
|     <strong>?</strong>     |  <i>; instrukce tvoøící tìlo smyèky</i>
|     <strong>?</strong>     |
|     <strong>?</strong>     |  <i>; end loop</i>
+---- <strong>JMP</strong>   |  <i>; nepodmínìný skok na zaèátek programové smyèky</i>
      &lt;-----+
</pre>

<p>Pseudoinstrukce <strong>IS??</strong> znaèí jednu ze ètrnácti instrukcí
vypsaných v&nbsp;tabulce uvedené <a href="#k01">v&nbsp;první kapitole</a>. Za
pov¹imnutí stojí otoèení podmínky a takté¾ pou¾ití speciální instrukce
<strong>LOOP</strong>, která sice zdánlivì nemá ¾ádný význam, ve skuteènosti se
v¹ak jedná o místo v&nbsp;mezijazyku, kam bude mo¾né vlo¾it JITovaný kód.</p>



<p><a name="k021"></a></p>
<h3 id="k021">2.1 Zdrojový kód pøíkladu <strong>test30.lua</strong></h3>

<p>Otestování zpùsobu pøekladu programové smyèky typu <strong>while</strong>
bude velmi jednoduché:</p>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 30.</i>
<i>--</i>
<i>-- Programová smyèka typu while.</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>-- poèitadlo smyèky</i>
<strong>local</strong> i = 10
&nbsp;
<i>-- programová smyèka typu while</i>
<strong>while</strong> i &gt;= 0 <strong>do</strong>
    print(i)
    i = i - 1
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>-- finito</i>
</pre>



<p><a name="k022"></a></p>
<h3 id="k022">2.2 Pøeklad pøíkladu <strong>test30.lua</strong> do mezijazyka LuaJITu</h3>

<p>V&nbsp;pøelo¾ené sekvenci instrukcí skuteènì mù¾eme vidìt ¹ablonu, o ní¾
jsme se zmínili <a href="#k02">na zaèátku této kapitoly</a>:</p>

<pre>
<i>; Pøeklad demonstraèního pøíkladu test30.lua</i>
<i>; do IR vyu¾ívaného virtuálním strojem a JIT</i>
<i>; pøekladaèem LuaJIT.</i>
&nbsp;
&nbsp;
&nbsp;
<i>; metadata se základními informacemi o zdrojovém kódu,</i>
<i>; který byl pou¾it pro vygenerování tohoto IR</i>
-- BYTECODE -- test30.lua:0-22
&nbsp;
&nbsp;
&nbsp;
<i>; poèitadlo smyèky</i>
<i>; local i = 10</i>
0001    <strong>KSHORT</strong>   0  10        <i>; inicializace poèitadla hodnotou 10</i>
&nbsp;
<i>; programová smyèka typu while</i>
<i>; while i&gt;=0 do</i>
0002 =&gt; <strong>KSHORT</strong>   1   0        <i>; ulo¾it konstantu 0 do promìnné #1</i>
0003    <strong>ISGT</strong>     1   0        <i>; porovnání poèitadla s konstantou 0</i>
0004    <strong>JMP</strong>      1 =&gt; 0011    <i>; podmínìný skok ZA konec programové smyèky</i>
0005    <strong>LOOP</strong>     1 =&gt; 0011    <i>; oznaèení generické programové smyèky (pro detekci hot spotù)</i>
&nbsp;
<i>; print(i)</i>
0006    <strong>GGET</strong>     1   0        <i>; získání reference na funkci se jménem "print"</i>
0007    <strong>MOV</strong>      2   0        <i>; bude se tisknout hodnota promìnné i (promìnná #0)</i>
0008    <strong>CALL</strong>     1   1   2    <i>; volání funkce print()</i>
&nbsp;
<i>; i = i - 1</i>
0009    <strong>SUBVN</strong>    0   0   0    <i>; odeètení jednièky (konstanta #0) od promìnné i (promìnná #0)</i>
&nbsp;
<i>; end loop</i>
0010    <strong>JMP</strong>      1 =&gt; 0002    <i>; nepodmínìný skok na zaèátek programové smyèky</i>
&nbsp;
<i>; ka¾dý program je automaticky ukonèen následující instrukcí</i>
0011 =&gt; <strong>RET0</strong>     0   1
&nbsp;
<i>; konec</i>
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Pøeklad programové smyèky typu <strong>repeat-until</strong></h2>

<p>Programová smyèka typu <strong>repeat-until</strong> je zrcadlovým obrazem
<a href="#k02">ji¾ vý¹e zmínìné</a> programové smyèky <strong>while</strong>.
Podmínka je zde testována na konci ka¾dé iterace (tato smyèka tedy probìhne
minimálnì jedenkrát) a navíc se pøi splnìní podmínky smyèka ukonèí, zatímco u
smyèky typu <strong>while</strong> bylo splnìní podmínky pøíznakem, ¾e se má
pokraèovat: spustit dal¹í iterace (mnemotechnická pomùcka &ndash; u obou smyèek
znamená splnìní podmínky pokraèování bìhu programu smìrem dolù). Programová
smyèka typu <strong>repeat-until</strong> se opìt pøekládá podle jednotné
¹ablony:</p>

<pre>
+---&gt; <strong>LOOP</strong>     <i>; oznaèení generické programové smyèky (pro detekci hot spotù)</i>
|     <strong>?</strong>
|     <strong>?</strong>        <i>; instrukce tvoøící tìlo smyèky</i>
|     <strong>?</strong>        <i>; instrukce tvoøící tìlo smyèky</i>
|     <strong>?</strong>        <i>; instrukce tvoøící tìlo smyèky</i>
|     <strong>?</strong>
|     <strong>IS??</strong>     <i>; podmínka odvozená z podmínky zapsané ve zdrojovém kódu</i>
+---- <strong>JMP</strong>      <i>; podmínìný skok na zaèátek programové smyèky</i>
</pre>

<p>Instrukèní kód je zde o jednu instrukci krat¹í, proto¾e není nutné
implementovat (závìreèný) nepodmínìný skok.</p>



<p><a name="k031"></a></p>
<h3 id="k031">3.1 Zdrojový kód pøíkladu <strong>test31.lua</strong></h3>

<p>Ukázka pou¾ití programové smyèky typu <strong>repeat-until</strong> je opìt
velmi jednoduchá (pov¹imnìte si, ¾e výstup tohoto programu se ponìkud li¹í od
výstupu programu pøedchozího &ndash; proè?):</p>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 31.</i>
<i>--</i>
<i>-- Programová smyèka typu repeat-until.</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>-- poèitadlo smyèky</i>
<strong>local</strong> i = 10
&nbsp;
<i>-- Programová smyèka typu repeat-until</i>
<strong>repeat</strong>
    print(i)
    i = i - 1
<strong>until</strong> i==0
&nbsp;
&nbsp;
&nbsp;
<i>-- finito</i>
</pre>



<p><a name="k032"></a></p>
<h3 id="k032">3.2 Pøeklad pøíkladu <strong>test31.lua</strong> do mezijazyka LuaJITu</h3>

<p>Po pøekladu do mezijazyka <i>LuaJITu</i> nalezneme ve vytvoøené sekvenci
instrukcí jak instrukci <strong>LOOP</strong>, tak i konec smyèky tvoøený
podmínkou a podmínìným skokem:</p>

<pre>
<i>; Pøeklad demonstraèního pøíkladu test31.lua</i>
<i>; do IR vyu¾ívaného virtuálním strojem a JIT</i>
<i>; pøekladaèem LuaJIT.</i>
&nbsp;
&nbsp;
&nbsp;
<i>; metadata se základními informacemi o zdrojovém kódu,</i>
<i>; který byl pou¾it pro vygenerování tohoto IR</i>
-- BYTECODE -- test31.lua:0-22
&nbsp;
&nbsp;
&nbsp;
<i>; poèitadlo smyèky</i>
<i>; local i = 10</i>
0001    <strong>KSHORT</strong>   0  10        <i>; inicializace poèitadla hodnotou 10</i>
&nbsp;
<i>; programová smyèka typu repeat-until</i>
<i>; repeat</i>
0002 =&gt; <strong>LOOP</strong>     1 =&gt; 0009    <i>; oznaèení generické programové smyèky (pro detekci hot spotù)</i>
&nbsp;
<i>; print(i)</i>
0003    <strong>GGET</strong>     1   0        <i>; získání reference na funkci se jménem "print"</i>
0004    <strong>MOV</strong>      2   0        <i>; bude se tisknout hodnota promìnné i (promìnná #0)</i>
0005    <strong>CALL</strong>     1   1   2    <i>; volání funkce print()</i>
&nbsp;
<i>; i = i - 1</i>
0006    <strong>SUBVN</strong>    0   0   0    <i>; odeètení jednièky (konstanta #0) od promìnné i (promìnná #0)</i>
0007    <strong>ISNEN</strong>    0   1        <i>; porovnání poèitadla s konstantou</i>
&nbsp;
<i>; until i==0</i>
0008    <strong>JMP</strong>      1 =&gt; 0002    <i>; podmínìný skok na zaèátek programové smyèky</i>
<i>; (end loop)</i>
&nbsp;
<i>; ka¾dý program je automaticky ukonèen následující instrukcí</i>
0009 =&gt; <strong>RET0</strong>     0   1
&nbsp;
<i>; konec</i>
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Programová smyèka typu <strong>while</strong> a pøíkaz <strong>break</strong></h2>

<p>V&nbsp;programovacím jazyku <i>Lua</i> je mo¾né pøedèasnì ukonèit smyèku
typu <strong>while</strong> pøíkazem <strong>break</strong>, který bývá typicky
pou¾it uvnitø nìjaké podmínky. Pøi pøekladu takto vytvoøené smyèky se opìt
vyu¾ívá jednotná ¹ablona:</p>

<pre>
+---&gt; <strong>IS??</strong>     <i>; podmínka odvozená z invertované podmínky zapsané ve zdrojovém kódu</i>
|     <strong>JMP</strong> --+  <i>; podmínìný skok ZA konec programové smyèky</i>
|     <strong>LOOP</strong>  |  <i>; oznaèení generické programové smyèky (pro detekci hot spotù)</i>
|     <strong>?</strong>     |
|     <strong>?</strong>     |  <i>; instrukce tvoøící tìlo smyèky</i>
|     <strong>?</strong>     |  <i>; instrukce tvoøící tìlo smyèky</i>
|     <strong>?</strong>     |  <i>; instrukce tvoøící tìlo smyèky</i>
|     <strong>?</strong>     |
|     <strong>JMP</strong> --+  <i>; break: nepodmínìný skok ZA konec programové smyèky</i>
|     <strong>?</strong>     |
|     <strong>?</strong>     |  <i>; instrukce tvoøící tìlo smyèky</i>
|     <strong>?</strong>     |  <i>; instrukce tvoøící tìlo smyèky</i>
|     <strong>?</strong>     |  <i>; instrukce tvoøící tìlo smyèky</i>
|     <strong>?</strong>     |  <i>; end loop</i>
+---- <strong>JMP</strong>   |  <i>; nepodmínìný skok na zaèátek programové smyèky</i>
      &lt;-----+
</pre>



<p><a name="k041"></a></p>
<h3 id="k041">4.1 Zdrojový kód pøíkladu <strong>test32.lua</strong></h3>

<p>V&nbsp;dne¹ním tøetím demonstraèním pøíkladu si uká¾eme podmínìný výskok
(ukonèení) nekoneèné smyèky tvoøené pøíkazem <strong>while true</strong>:</p>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 32.</i>
<i>--</i>
<i>-- Programová smyèka typu while s pøíkazem break.</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>-- poèitadlo smyèky</i>
<strong>local</strong> i = 10
&nbsp;
<i>-- programová smyèka typu while</i>
<strong>while</strong> true <strong>do</strong>
    print(i)
    i = i - 1
    <strong>if</strong> i == 0 <strong>then</strong>
        <strong>break</strong>
    <strong>end</strong>
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>-- finito</i>
</pre>



<p><a name="k042"></a></p>
<h3 id="k042">4.2 Pøeklad pøíkladu <strong>test32.lua</strong> do mezijazyka LuaJITu</h3>

<p>Na zaèátku této kapitoly prezentovaná ¹ablona je v&nbsp;kódu tøetího
demonstraèního pøíkladu pøelo¾eného do mezijazyka pomìrnì dobøe viditelná:</p>

<pre>
<i>; Pøeklad demonstraèního pøíkladu test32.lua</i>
<i>; do IR vyu¾ívaného virtuálním strojem a JIT</i>
<i>; pøekladaèem LuaJIT.</i>
&nbsp;
&nbsp;
&nbsp;
<i>; metadata se základními informacemi o zdrojovém kódu,</i>
<i>; který byl pou¾it pro vygenerování tohoto IR</i>
-- BYTECODE -- test32.lua:0-25
&nbsp;
&nbsp;
&nbsp;
<i>; poèitadlo smyèky</i>
<i>; local i = 10</i>
0001    <strong>KSHORT</strong>   0  10        <i>; inicializace poèitadla hodnotou 10</i>
&nbsp;
<i>; programová smyèka typu while</i>
<i>; while true do</i>
0002 =&gt; <strong>LOOP</strong>     1 =&gt; 0011    <i>; oznaèení generické programové smyèky (pro detekci hot spotù)</i>
&nbsp;
<i>; print(i)</i>
0003    <strong>GGET</strong>     1   0        <i>; získání reference na funkci se jménem "print"</i>
0004    <strong>MOV</strong>      2   0        <i>; bude se tisknout hodnota promìnné i (promìnná #0)</i>
0005    <strong>CALL</strong>     1   1   2    <i>; volání funkce print()</i>
&nbsp;
<i>; i = i - 1</i>
0006    <strong>SUBVN</strong>    0   0   0    <i>; odeètení jednièky (konstanta #0) od promìnné i (promìnná #0)</i>
&nbsp;
<i>; if i == 0 then</i>
0007    <strong>ISNEN</strong>    0   1        <i>; porovnání poèitadla s konstantou 0</i>
&nbsp;
<i>; "else"</i>
0008    <strong>JMP</strong>      1 =&gt; 0002    <i>; podmínìný skok na zaèátek programové smyèky</i>
&nbsp;
<i>; break</i>
0009    <strong>JMP</strong>      1 =&gt; 0011    <i>; nepodmínìný skok ZA konec programové smyèky</i>
&nbsp;
<i>; end loop</i>
0010    <strong>JMP</strong>      1 =&gt; 0002    <i>; nepodmínìný skok na zaèátek programové smyèky</i>
&nbsp;
<i>; ka¾dý program je automaticky ukonèen následující instrukcí</i>
0011 =&gt; <strong>RET0</strong>     0   1
&nbsp;
<i>; konec</i>
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Programová smyèka typu <strong>repeat-until</strong> a pøíkaz <strong>break</strong></h2>

<p>Pøíkazem <strong>break</strong> je samozøejmì mo¾né ukonèit i provádìní
programové smyèky typu <strong>repeat-until</strong>. Opìt se nejdøíve
podívejme na to, podle jaké jednotné ¹ablony se zdrojový kód pøekládá do
mezijazyka <i>LuaJITu</i>:</p>

<pre>
+---&gt; <strong>LOOP</strong>     <i>; oznaèení generické programové smyèky (pro detekci hot spotù)</i>
|     <strong>?</strong>
|     <strong>?</strong>        <i>; instrukce tvoøící tìlo smyèky</i>
|     <strong>?</strong>        <i>; instrukce tvoøící tìlo smyèky</i>
|     <strong>?</strong>        <i>; instrukce tvoøící tìlo smyèky</i>
|     <strong>?</strong>
|     <strong>JMP</strong> --+  <i>; break: nepodmínìný skok ZA konec programové smyèky</i>
|     <strong>?</strong>     |
|     <strong>?</strong>     |  <i>; instrukce tvoøící tìlo smyèky</i>
|     <strong>?</strong>     |  <i>; instrukce tvoøící tìlo smyèky</i>
|     <strong>?</strong>     |  <i>; instrukce tvoøící tìlo smyèky</i>
|     <strong>?</strong>     |
|     <strong>IS??</strong>  |  <i>; podmínka odvozená z podmínky zapsané ve zdrojovém kódu</i>
+---- <strong>JMP</strong>   |  <i>; podmínìný skok na zaèátek programové smyèky</i>
      &lt;-----+
</pre>



<p><a name="k051"></a></p>
<h3 id="k051">5.1 Zdrojový kód pøíkladu <strong>test33.lua</strong></h3>

<p>Ve ètvrtém demonstraèním pøíkladu je nekoneèná smyèka typu
<strong>repeat-until</strong> ukonèena pøíkazem <strong>break</strong> pøi
splnìní zapsané podmínky:</p>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 33.</i>
<i>--</i>
<i>-- Programová smyèka typu repeat-until s pøíkazem break.</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>-- poèitadlo smyèky</i>
<strong>local</strong> i = 10
&nbsp;
<i>-- Programová smyèka typu repeat-until</i>
<strong>repeat</strong>
    print(i)
    i = i - 1
    <strong>if</strong> i == 0 <strong>then</strong>
        <strong>break</strong>
    <strong>end</strong>
<strong>until</strong> false
&nbsp;
&nbsp;
&nbsp;
<i>-- finito</i>
</pre>



<p><a name="k052"></a></p>
<h3 id="k052">5.2 Pøeklad pøíkladu <strong>test33.lua</strong> do mezijazyka LuaJITu</h3>

<p>Následuje výpis sekvence vzniklé po pøekladu tohoto demonstraèního pøíkladu
do mezijazyka:</p>

<pre>
<i>; Pøeklad demonstraèního pøíkladu test33.lua</i>
<i>; do IR vyu¾ívaného virtuálním strojem a JIT</i>
&nbsp;
&nbsp;
<i>; pøekladaèem LuaJIT.</i>
<i>; metadata se základními informacemi o zdrojovém kódu,</i>
<i>; který byl pou¾it pro vygenerování tohoto IR</i>
-- BYTECODE -- test33.lua:0-25
&nbsp;
&nbsp;
&nbsp;
<i>; poèitadlo smyèky</i>
<i>; local i = 10</i>
0001    <strong>KSHORT</strong>   0  10        <i>; inicializace poèitadla hodnotou 10</i>
&nbsp;
<i>; programová smyèka typu repeat-until</i>
<i>; repeat</i>
0002 =&gt; <strong>LOOP</strong>     1 =&gt; 0012    <i>; oznaèení generické programové smyèky (pro detekci hot spotù)</i>
&nbsp;
<i>; print(i)</i>
0003    <strong>GGET</strong>     1   0        <i>; získání reference na funkci se jménem "print"</i>
0004    <strong>MOV</strong>      2   0        <i>; bude se tisknout hodnota promìnné i (promìnná #0)</i>
0005    <strong>CALL</strong>     1   1   2    <i>; volání funkce print()</i>
&nbsp;
<i>; i = i - 1</i>
0006    <strong>SUBVN</strong>    0   0   0    <i>; odeètení jednièky (konstanta #0) od promìnné i (promìnná #0)</i>
&nbsp;
<i>; if i == 0 then</i>
0007    <strong>ISNEN</strong>    0   1        <i>; porovnání poèitadla s konstantou 0</i>
&nbsp;
<i>; "else"</i>
0008    <strong>JMP</strong>      1 =&gt; 0010    <i>; podmínìný skok za if</i>
&nbsp;
<i>; break</i>
0009    <strong>JMP</strong>      1 =&gt; 0012    <i>; nepodmínìný skok ZA konec programové smyèky</i>
&nbsp;
<i>; end</i>
0010 =&gt; <strong>JMP</strong>      1 =&gt; 0011    <i>; nepodmínìný skok NA konec programové smyèky</i>
&nbsp;
<i>; until false</i>
0011 =&gt; <strong>JMP</strong>      1 =&gt; 0002    <i>; nepodmínìný skok na zaèátek programové smyèky</i>
&nbsp;
<i>; ka¾dý program je automaticky ukonèen následující instrukcí</i>
0012 =&gt; <strong>RET0</strong>     0   1
&nbsp;
<i>; konec</i>
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Prùchod v¹emi prvky pole ve smyèce <strong>while</strong> s&nbsp;vyu¾itím funkce <strong>next()</strong></h2>

<p>Velmi èasto se v&nbsp;reálných programech prochází v¹emi prvky pole èi
tabulky. Pro tento úèel lze vyu¾ít programovou smyèku typu
<strong>while</strong> a funkci <strong>next()</strong>, která po svém zavolání
vrátí následující prvek v&nbsp;tabulce a souèasnì i index èi klíè dal¹ího
prvku. Pokud ji¾ dal¹í prvek neexistuje, vrátí se namísto indexu/klíèe hodnota
<strong>nil</strong>.</p>



<p><a name="k061"></a></p>
<h3 id="k061">6.1 Zdrojový kód pøíkladu <strong>test34.lua</strong></h3>

<p>Uka¾me si základní pou¾ití smyèky <strong>while</strong> a funkce
<strong>next()</strong>. Jak je ze zdrojového kódu patrné, nejedná se o pøíli¹
elegantní øe¹ení:</p>

<pre>
<i>--</i>
<i>-- LuaJIT: demonstraèní pøíklad èíslo 34.</i>
<i>--</i>
<i>-- Práce s tabulkami:</i>
<i>--    * vytvoøení a inicializace neprázdné tabulky</i>
<i>--    * programová smyèka typu while vyu¾ívající</i>
<i>--      funkci next pou¾itá pro prùchod tabulkou</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>-- vytvoøení desetiprvkové tabulky</i>
<strong>local</strong> tbl = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1}
&nbsp;
<i>-- inicializace - získání prvního prvku a jeho indexu z tabulky</i>
<strong>local</strong> index,val = next(tbl, nil)
&nbsp;
<i>-- programová smyèka typu while</i>
<strong>while</strong> index <strong>do</strong>
    print(index,val)
    index,val = next(tbl, index)
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>-- finito</i>
</pre>



<p><a name="k062"></a></p>
<h3 id="k062">6.2 Pøeklad pøíkladu <strong>test34.lua</strong> do mezijazyka LuaJITu</h3>

<p>Zajímavé je, ¾e pro pøeklad demonstraèního pøíkladu
<strong>test34.lua</strong> do mezijazyka není pou¾ita ¾ádná speciální
&bdquo;smyèková&ldquo; instrukce, samozøejmì kromì instrukce
<strong>LOOP</strong>:</p>

<pre>
<i>; Pøeklad demonstraèního pøíkladu test34.lua</i>
<i>; do IR vyu¾ívaného virtuálním strojem a JIT</i>
<i>; pøekladaèem LuaJIT.</i>
&nbsp;
&nbsp;
<i>; metadata se základními informacemi o zdrojovém kódu,</i>
<i>; který byl pou¾it pro vygenerování tohoto IR</i>
-- BYTECODE -- test34.lua:0-28
&nbsp;
&nbsp;
&nbsp;
<i>; local tbl = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1}</i>
0001    <strong>TDUP</strong>     0   0        <i>; vytvoøení a inicializace tabulky (pole)</i>
&nbsp;
<i>; local index,val = next(tbl, nil)</i>
0002    <strong>GGET</strong>     1   1        <i>; získání reference na funkci se jménem "next"</i>
0003    <strong>MOV</strong>      2   0        <i>; prvním argumentem funkce "next" je tabulka</i>
0004    <strong>KPRI</strong>     3   0        <i>; druhým argumentem funkce "next" je konstanta nil</i>
0005    <strong>CALL</strong>     1   3   3    <i>; zavolání funkce next</i>
&nbsp;
<i>; while index do</i>
0006 =&gt; <strong>ISF</strong>          1        <i>; podmínka pro ukonèení programové smyèky</i>
0007    <strong>JMP</strong>      3 =&gt; 0020    <i>; podmínìný skok ZA konec programové smyèky</i>
0008    <strong>LOOP</strong>     3 =&gt; 0020    <i>; oznaèení generické programové smyèky (pro detekci hot spotù)</i>
&nbsp;
<i>; print(index,val)</i>
0009    <strong>GGET</strong>     3   2        <i>; získání reference na funkci se jménem "print"</i>
0010    <strong>MOV</strong>      4   1        <i>; bude se tisknout index</i>
0011    <strong>MOV</strong>      5   2        <i>; a souèasnì i hodnota prvku</i>
0012    <strong>CALL</strong>     3   1   3    <i>; volání funkce print()</i>
&nbsp;
<i>; index,val = next(tbl, index)</i>
0013    <strong>GGET</strong>     3   1        <i>; získání reference na funkci se jménem "next"</i>
0014    <strong>MOV</strong>      4   0        <i>; prvním argumentem funkce "next" je tabulka</i>
0015    <strong>MOV</strong>      5   1        <i>; druhým argumentem funkce "next" je index</i>
0016    <strong>CALL</strong>     3   3   3    <i>; zavolání funkce next</i>
0017    <strong>MOV</strong>      2   4        <i>; ulo¾ení návratových hodnot do správných slotù</i>
0018    <strong>MOV</strong>      1   3        <i>; ulo¾ení návratových hodnot do správných slotù</i>
&nbsp;
<i>; end loop</i>
0019    <strong>JMP</strong>      3 =&gt; 0006    <i>; nepodmínìný skok na zaèátek programové smyèky</i>
&nbsp;
<i>; ka¾dý program je automaticky ukonèen následující instrukcí</i>
0020 =&gt; <strong>RET0</strong>     0   1
&nbsp;
<i>; konec</i>
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Programová smyèka <strong>for</strong> a <strong>for-each</strong></h2>

<p>V&nbsp;programovacím jazyku <i>Lua</i> nalezneme kromì vý¹e zmínìných
programových smyèek typu <strong>while</strong> a <strong>repeat-until</strong>
i smyèku reprezentovanou klíèovými slovy <strong>for</strong>,
<strong>do</strong> a <strong>end</strong>. Tuto smyèku lze vyu¾ít dvìma
zpùsoby &ndash; ve funkci klasické poèítané smyèky známé ji¾ z&nbsp;dob
FORTRANU popø.&nbsp;ve funkci smyèky for-each, která se typicky pou¾ívá pro
prùchod tabulkami.</p>



<p><a name="k071"></a></p>
<h2 id="k071">7.1 Poèítaná programová smyèka typu <strong>for</strong></h2>

<p>S&nbsp;pøekladem poèítané programové smyèky typu <strong>for</strong> jsme
se ji¾ setkali, tak¾e si pouze øeknìme, ¾e se v&nbsp;mezijazyku vyskytují
instrukce <strong>FORI</strong> a <strong>FORL</strong>. Instrukce
<strong>FORI</strong> je skuteènì pou¾ita na zaèátku programové smyèky, je¹tì
pøed jejím tìlem, a to pro zji¹tìní, zda ji¾ pøed vstupem do smyèky náhodou
nedo¹lo k&nbsp;situaci typu <i>for i = 10,9</i> atd. Naopak instrukce
<strong>FORL</strong> na konci smyèky provádí mnoho operací &ndash; zvý¹ení
hodnoty poèitadla, test na ukonèení smyèky a souèasnì i podmínìný skok na
zaèátek smyèky. Jak <strong>FORI</strong> tak i <strong>FORL</strong> pracuje
se tøemi sloty &ndash; poèitadlem, koncovou hodnotou a krokem:</p>

<pre>
+---&gt;  <strong>FORI</strong> --+  <i>; vstup do poèítané programové smyèky typu for</i>
|      <strong>?</strong>      |
|      <strong>?</strong>      |  <i>; instrukce tvoøící tìlo smyèky</i>
|      <strong>?</strong>      |  <i>; instrukce tvoøící tìlo smyèky</i>
|      <strong>?</strong>      |  <i>; instrukce tvoøící tìlo smyèky</i>
|      <strong>?</strong>      |
+----- <strong>FORL</strong>   |  <i>; dal¹í iterace, skok na zaèátek programové smyèky</i>
      &lt;-------+
</pre>

<p><a name="k072"></a></p>
<h2 id="k072">7.2 Smyèka typu <strong>for-each</strong> pøi prùchodu polem</h2>

<p>Slo¾itìj¹í je situace ve chvíli, kdy se ve zdrojovém kódu vyskytuje
programová smyèka typu <strong>for-each</strong> urèená pro prùchod polem,
tj.&nbsp;takovou tabulkou, v&nbsp;ní¾ jsou prvky adresovány s&nbsp;pou¾itím
celoèíselných indexù. Pro prùchod takovým polem se ve zdrojovém kódu vyu¾ívá
iterátoru <i>ipairs()</i> a v&nbsp;pøelo¾eném kódu nalezneme jak volání tohoto
iterátoru, tak i dvojici nových instrukcí nazvaných <strong>ITERC</strong> a
<strong>ITERL</strong>. Instrukce <strong>ITERC</strong> zavolá znovu iterátor,
pøièem¾ parametry tohoto iterátoru jsou vìt¹inou ji¾ pøipraveny
v&nbsp;rezervovaných slotech po celou dobu &bdquo;¾ivota&ldquo; programové
smyèky. Vlastní test, zda se má provést dal¹í iterace a tím pádem i skok, je
pøedstavován funkcí <strong>ITERL</strong>:</p>

<pre>
       <strong>GGET</strong>      <i>; získání reference na funkci se jménem "ipairs"</i>
       <strong>MOV</strong>       <i>; pøedání iterátoru jako parametru funkce</i>
       <strong>CALL</strong>      <i>; zavolání funkce ipairs()</i>
       <strong>JMP</strong>  --+  <i>; pøímý skok na instrukci ITERC</i>
+---&gt;  <strong>?</strong>      |
|      <strong>?</strong>      |  <i>; instrukce tvoøící tìlo smyèky</i>
|      <strong>?</strong>      |  <i>; instrukce tvoøící tìlo smyèky</i>
|      <strong>?</strong>      |  <i>; instrukce tvoøící tìlo smyèky</i>
|      <strong>?</strong>      |
|      <strong>ITERC</strong>&lt;-+
+----  <strong>ITERL</strong>    <i>; návrat na zaèátek smyèky (dal¹í iterace)</i>
</pre>

<p>Podrobnosti si uká¾eme pøí¹tì na nìkolika demonstraèních pøíkladech.</p>



<p><a name="k073"></a></p>
<h2 id="k073">7.3 Smyèka typu <strong>for-each</strong> pøi prùchodu asociativním polem</h2>

<p>Podobným zpùsobem je pøelo¾ena i programová smyèka typu
<strong>for-each</strong> ve chvíli, kdy se prochází v¹emi prvky asociativního
pole, tj.&nbsp;takové tabulky, v&nbsp;ní¾ je ka¾dý prvek indexován klíèem
(typicky øetìzcem). Pøi pøekladu do bajtkódu se pou¾ívají instrukce
<strong>ISNEXT</strong>, <strong>ITERN</strong> a <strong>ITERL</strong> (tato
instrukce je tedy stejná, jako tomu bylo i v&nbsp;pøedchozím pøípadì).
Instrukce <strong>ITERN</strong> doká¾e spolupracovat (volat) funkce
<i>next()</i> èi <i>pairs()</i> a tím pádem implementovat jak naètení dal¹ího
prvku z&nbsp;asociativního pole, tak i pøípravu pro test, zda se má provést
dal¹í iterace:</p>

<pre>
       <strong>GGET</strong>      <i>; získání reference na funkci se jménem "pairs"</i>
       <strong>MOV</strong>       <i>; pøedání iterátoru jako parametru funkce</i>
       <strong>CALL</strong>      <i>; zavolání funkce pairs()</i>
       <strong>ISNEXT</strong>-+  <i>; pøímý skok na instrukci ITERN</i>
+---&gt;  <strong>?</strong>      |
|      <strong>?</strong>      |  <i>; instrukce tvoøící tìlo smyèky</i>
|      <strong>?</strong>      |  <i>; instrukce tvoøící tìlo smyèky</i>
|      <strong>?</strong>      |  <i>; instrukce tvoøící tìlo smyèky</i>
|      <strong>?</strong>      |
|      <strong>ITERN</strong>&lt;-+
+----  <strong>ITERL</strong>     <i>; návrat na zaèátek smyèky (dal¹í iterace)</i>
</pre>

<p>Podrobnosti o pøekladu této smyèky si takté¾ uká¾eme pøí¹tì na nìkolika
demonstraèních pøíkladech.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Zdrojové kódy v¹ech pìti dne¹ních demonstraèních pøíkladù</h2>

<p>V¹echny dnes pou¾ité demonstraèní pøíklady jsou, jak je tomu v&nbsp;tomto
seriálu ji¾ dlouhodobìj¹ím zvykem, ulo¾eny do Git (<a
href="http://github.com/">GitHub</a>) repositáøe umístìného na adrese <a
href="https://github.com/tisnik/luajit-examples">https://github.com/tisnik/luajit-examples</a>:</p>

<table>
<tr><th> #</th><th>Zdrojový kód</th><th>Umístìní</th></tr>
<tr><td> 1</td><td>test30.lua</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/src/test30.lua">https://github.com/tisnik/luajit-examples/blob/master/src/test30.lua</a></td></tr>
<tr><td> 2</td><td>test31.lua</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/src/test31.lua">https://github.com/tisnik/luajit-examples/blob/master/src/test31.lua</a></td></tr>
<tr><td> 3</td><td>test32.lua</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/src/test32.lua">https://github.com/tisnik/luajit-examples/blob/master/src/test32.lua</a></td></tr>
<tr><td> 4</td><td>test33.lua</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/src/test33.lua">https://github.com/tisnik/luajit-examples/blob/master/src/test33.lua</a></td></tr>
<tr><td> 5</td><td>test34.lua</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/src/test34.lua">https://github.com/tisnik/luajit-examples/blob/master/src/test34.lua</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>test30.asm</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/asm/test30.asm">https://github.com/tisnik/luajit-examples/blob/master/asm/test30.asm</a></td></tr>
<tr><td> 7</td><td>test31.asm</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/asm/test31.asm">https://github.com/tisnik/luajit-examples/blob/master/asm/test31.asm</a></td></tr>
<tr><td> 8</td><td>test32.asm</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/asm/test32.asm">https://github.com/tisnik/luajit-examples/blob/master/asm/test32.asm</a></td></tr>
<tr><td> 9</td><td>test33.asm</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/asm/test33.asm">https://github.com/tisnik/luajit-examples/blob/master/asm/test33.asm</a></td></tr>
<tr><td>10</td><td>test34.asm</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/asm/test34.asm">https://github.com/tisnik/luajit-examples/blob/master/asm/test34.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>Makefile</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/Makefile">https://github.com/tisnik/luajit-examples/blob/master/Makefile</a></td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Wikipedia: Mezijazyk<br />
<a href="http://cs.wikipedia.org/wiki/Mezijazyk">http://cs.wikipedia.org/wiki/Mezijazyk</a>
</li>

<li>The LuaJIT Project<br />
<a href="http://luajit.org/index.html">http://luajit.org/index.html</a>
</li>

<li>LuaJIT FAQ<br />
<a href="http://luajit.org/faq.html">http://luajit.org/faq.html</a>
</li>

<li>LuaJIT Performance Comparison<br />
<a href="http://luajit.org/performance.html">http://luajit.org/performance.html</a>
</li>

<li>LuaJIT 2.0 intellectual property disclosure and research opportunities<br />
<a href="http://article.gmane.org/gmane.comp.lang.lua.general/58908">http://article.gmane.org/gmane.comp.lang.lua.general/58908</a>
</li>

<li>LuaJIT Wiki<br />
<a href="http://wiki.luajit.org/Home">http://wiki.luajit.org/Home</a>
</li>

<li>LuaJIT 2.0 Bytecode Instructions<br />
<a href="http://wiki.luajit.org/Bytecode-2.0">http://wiki.luajit.org/Bytecode-2.0</a>
</li>

<li>Programming in Lua 9.1 &ndash; Coroutine Basics,<br />
<a href="http://www.lua.org/pil/9.1.html">http://www.lua.org/pil/9.1.html</a>
</li>

<li>Programming in Lua (first edition)<br />
<a href="http://www.lua.org/pil/contents.html">http://www.lua.org/pil/contents.html</a>
</li>

<li>Programming in Lua: 6 - More about Functions<br />
<a href="http://www.lua.org/pil/6.html">http://www.lua.org/pil/6.html</a>
</li>

<li>Lua Lanes<br />
<a href="http://kotisivu.dnainternet.net/askok/bin/lanes/">http://kotisivu.dnainternet.net/askok/bin/lanes/</a>
</li>

<li>Programming in Lua: 6.1 - Closures<br />
<a href="http://www.lua.org/pil/6.1.html">http://www.lua.org/pil/6.1.html</a>
</li>

<li>Programming in Lua: 9.1 - Coroutine Basics<br />
<a href="http://www.lua.org/pil/9.1.html">http://www.lua.org/pil/9.1.html</a>
</li>

<li>Programming in Lua: Numeric for<br />
<a href="http://www.lua.org/pil/4.3.4.html">http://www.lua.org/pil/4.3.4.html</a>
</li>

<li>Programming in Lua: break and return<br />
<a href="http://www.lua.org/pil/4.4.html">http://www.lua.org/pil/4.4.html</a>
</li>

<li>Programming in Lua: Tables<br />
<a href="http://www.lua.org/pil/2.5.html">http://www.lua.org/pil/2.5.html</a>
</li>

<li>Programming in Lua: Table Constructors<br />
<a href="http://www.lua.org/pil/3.6.html">http://www.lua.org/pil/3.6.html</a>
</li>

<li>Programovací jazyk Lua<br />
<a href="http://palmknihy.cz/web/kniha/programovaci-jazyk-lua-12651.htm">http://palmknihy.cz/web/kniha/programovaci-jazyk-lua-12651.htm</a>
</li>

<li>Lua: Tables Tutorial<br />
<a href="http://lua-users.org/wiki/TablesTutorial">http://lua-users.org/wiki/TablesTutorial</a>
</li>

<li>Lua: Control Structure Tutorial<br />
<a href="http://lua-users.org/wiki/ControlStructureTutorial">http://lua-users.org/wiki/ControlStructureTutorial</a>
</li>

<li>Lua Types Tutorial<br />
<a href="http://lua-users.org/wiki/LuaTypesTutorial">http://lua-users.org/wiki/LuaTypesTutorial</a>
</li>

<li>Goto Statement in Lua<br />
<a href="http://lua-users.org/wiki/GotoStatement">http://lua-users.org/wiki/GotoStatement</a>
</li>

<li>Lua 5.2 sources<br />
<a href="http://www.lua.org/source/5.2/">http://www.lua.org/source/5.2/</a>
</li>

<li>Lua 5.2 sources - lopcodes.h<br />
<a href="http://www.lua.org/source/5.2/lopcodes.h.html">http://www.lua.org/source/5.2/lopcodes.h.html</a>
</li>

<li>Lua 5.2 sources - lopcodes.c<br />
<a href="http://www.lua.org/source/5.2/lopcodes.c.html">http://www.lua.org/source/5.2/lopcodes.c.html</a>
</li>

<li>Lambda the Ultimate: Coroutines in Lua,<br />
<a href="http://lambda-the-ultimate.org/node/438">http://lambda-the-ultimate.org/node/438</a>
</li>

<li>Coroutines Tutorial,<br />
<a href="http://lua-users.org/wiki/CoroutinesTutorial">http://lua-users.org/wiki/CoroutinesTutorial</a>
</li>

<li>Lua Coroutines Versus Python Generators,<br />
<a href="http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators">http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2014</small></p>
</body>
</html>

