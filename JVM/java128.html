<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - pøehrávání a mixování zvukù s vyu¾itím knihovny SDLJava</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - pøehrávání a mixování zvukù s vyu¾itím knihovny SDLJava</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V pøedchozí èásti seriálu o JVM i o programovacím jazyku Java jsme si popsali zpùsob pøehrávání hudby s vyu¾itím knihovny SDLJava. Dnes si øekneme, jakým zpùsobem je mo¾né zajistit naèítání, pøehrávání i mixování zvukù, nebo» i ty jsou souèástí mnoha multimediálních aplikací.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - pøehrávání a mixování zvukù s vyu¾itím knihovny SDLJava</a></p>
<p><a href="#k02">2. Podporované zvukové formáty</a></p>
<p><a href="#k03">3. Formát souborù RIFF/WAVE</a></p>
<p><a href="#k04">4. Utilita pro naètení a výpis základních informací o souborech typu RIFF/WAVE</a></p>
<p><a href="#k05">5. Naètení souboru se zvukem do aplikace vyu¾ívající knihovnu SDLJava</a></p>
<p><a href="#k06">6. Demonstraèní pøíklad <strong>SDLTest66</strong> &ndash; naètení a pøehrání zvuku</a></p>
<p><a href="#k07">7. Demonstraèní pøíklad <strong>SDLTest67</strong> &ndash; vliv velikosti bufferu na vznik chyb pøi pøehrávání zvukù</a></p>
<p><a href="#k08">8. Demonstraèní pøíklad <strong>SDLTest68</strong> &ndash; vyu¾ití osmi zvukových kanálù pro mixování</a></p>
<p><a href="#k09">9. Repositáø se zdrojovými kódy v¹ech ètyø dne¹ních demonstraèních pøíkladù</a></p>
<p><a href="#k10">10. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - pøehrávání a mixování zvukù s vyu¾itím knihovny SDLJava</h2>

<p>V&nbsp;pøedchozí èásti seriálu o programovacím jazyku Java i o virtuálním
stroji Javy jsme si na ètveøici demonstraèních pøíkladù ukázali, jakým zpùsobem
je mo¾né v&nbsp;knihovnì <i>SDLJava</i> pøehrávat hudbu, a to s&nbsp;vyu¾itím
tøídy <i>SDLMixer</i>. Stejná tøída, pøesnìji øeèeno metody implementované
v&nbsp;této tøídì, se pou¾ívají i pøi pøehrávání a mixování zvukù, co¾ je téma,
kterému se budeme vìnovat dnes. Pøehrávání hudby bylo pomìrnì snadné, proto¾e
se &ndash; alespoò z&nbsp;hlediska aplikaèního programátora &ndash; pro naètení
a pøehrání hudby pou¾ilo pouze nìkolik metod. U zvukù mù¾e být situace
paradoxnì slo¾itìj¹í, a to zejména z&nbsp;toho dùvodu, ¾e zvuky jsou
v&nbsp;multimediálních aplikacích (pøedev¹ím ve hrách) navázány na nìjakou
událost a zvolený zvuk se musí v&nbsp;ideálním pøípadì zaèít pøehrávat pøesnì
ve chvíli, kdy k&nbsp;dané události dojde. Ov¹em tento po¾adavek je pomìrnì
problematické splnit a to pøedev¹ím kvùli existenci bufferù, do nich¾ se
zvuková data vkládají a absenci potøebných RT roz¹íøení operaèních systémù.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Podporované zvukové formáty</h2>

<p>Knihovna <i>SDLJava</i> podporuje nìkolik zvukových formátù pou¾itelných
jako zdroj zvukù pro vytváøenou multimediální aplikaci. Tyto formáty jsou
vypsány v&nbsp;tabulce umístìné pod tímto odstavcem:</p>

<table>
<tr><th>#</th><th>Formát</th><th>Struèný popis</th></tr>
<tr><td>1</td><td>.wav</td><td>Zvukové vzorky ulo¾ené ve formátu RIFF/WAVE</td></tr>
<tr><td>2</td><td>.aif, .aiff</td><td>Audio Interchange File Format odvozený od star¹ího formátu .iff (Amiga)</td></tr>
<tr><td>3</td><td>.voc</td><td>Zvukové vzorky ulo¾ené ve formátu VOC (pou¾ito v&nbsp;SW od firmy Creative Labs, výrobce SoundBlasterù)</td></tr>
<tr><td>4</td><td>.ogg</td><td>Zvukový/hudební formát Ogg Vorbis</td></tr>
</table>

<p>Pov¹imnìte si mnoha rozdílù oproti podporovaným hudebním formátùm (viz té¾
pøedchozí èást tohoto seriálu, v&nbsp;ní¾ jsme se speciálnì vìnovali Amiga
modulùm i formátu General MIDI):</p>

<table>
<tr><th>#</th><th>Typ (koncovka souboru)</th><th>Popis</th></tr>
<tr><td>1</td><td>.wav </td><td>zvukové vzorky ulo¾ené ve formátu RIFF/WAVE</td></tr>
<tr><td>2</td><td>.voc </td><td>zvukové vzorky ulo¾ené ve formátu VOC (pou¾ito v&nbsp;SW od firmy Creative Labs, výrobce SoundBlasterù)</td></tr>
<tr><td>3</td><td>.mod </td><td>Amiga moduly a odvozené formáty</td></tr>
<tr><td>4</td><td>.xm  </td><td>Amiga moduly a odvozené formáty</td></tr>
<tr><td>5</td><td>.s3m </td><td>Amiga moduly a odvozené formáty</td></tr>
<tr><td>6</td><td>.669,</td><td>Amiga moduly a odvozené formáty</td></tr>
<tr><td>7</td><td>.it  </td><td>Amiga moduly a odvozené formáty</td></tr>
<tr><td>8</td><td>.midi</td><td>Hudební formát MIDI</td></tr>
<tr><td>9</td><td>.ogg </td><td>Zvukový/hudební formát Ogg Vorbis</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Formát souborù RIFF/WAVE</h2>

<p>Velká èást her postavených na (nativní) knihovnì <i>SDL</i> pou¾ívá pro
ukládání zvukù formát RIFF/WAVE, tj.&nbsp;soubory, které mají vìt¹inou pøíponu
<strong>.wav</strong>. Jedná se o obecný formát, který zpoèátku umo¾òoval pouze
ukládání nezkomprimované hudby s&nbsp;vyu¾itím PCM (pulznì kódové modulace),
ov¹em posléze byl roz¹íøen i o mo¾nosti vyu¾ití rùzných metod pro bezeztrátovou
i ztrátovou komprimaci zvukù. Vzhledem k&nbsp;jednoduchosti a takté¾
univerzálnosti formátu RIFF/WAVE se mù¾eme s&nbsp;tímto formátem setkat i
v&nbsp;dal¹ích oblastech, které pøímo nesouvisí se zpracováním zvuku &ndash; do
souborù s&nbsp;koncovkou .wav je toti¾ mo¾né ukládat prakticky libovolné
digitalizované jednorozmìrné signály o teoretické maximální vzorkovací
frekvenci a¾ 16 GHz (2<sup>32</sup>-1 Hz), pøièem¾ (opìt teoretický) poèet
kanálù mù¾e dosahovat a¾ 65535. To znamená, ¾e do .wav lze ukládat napøíklad
signály získané z&nbsp;rùzných èidel, signály urèené pro digitální osciloskopy
atd. Právì z&nbsp;tohoto dùvodu si základní formát souborù WAVE popí¹eme
podrobnìji, proto¾e se mù¾e programátorùm v&nbsp;nìkterých situacích hodit (a
vìt¹inou nemá smysl znovuvynalézat kolo :-).</p>

<p>Soubory typu RIFF/WAVE se skládají z&nbsp;takzvaných <i>chunkù</i>, pøièem¾
ka¾dý chunk (budeme mu mo¾ná ponìkud nepøesnì øíkat blok) na svém zaèátku
obsahuje ètyøi bajty s&nbsp;jednoznaèným jménem, za ním¾ jsou ulo¾eny dal¹í
ètyøi bajty, v&nbsp;nich¾ je ulo¾ena délka bloku. Jednotlivé bloky se mohou
vnoøovat, co¾ napøíklad znamená, ¾e &bdquo;hlavní&ldquo; blok má délku rovnou
velikosti celého souboru. Nás v&nbsp;tuto chvíli zajímají pøedev¹ím ty soubory
RIFF/WAVE, v&nbsp;nich¾ jsou ulo¾ena nezkomprimovaná zvuková data. Tyto soubory
se skládají ze tøí typù blokù, jejich¾ jména jsou vypsána v&nbsp;následující
tabulce:</p>

<table>
<tr><th>Jméno bloku</th><th>Význam</th></tr>
<tr><td>"RIFF"</td><td><td>blok obsahující hlavièku se základními informacemi o souboru</td></tr>
<tr><td>"fmt "</td><td><td>blok obsahující informace o formátu ulo¾ených zvukových dat</td></tr>
<tr><td>"data"</td><td><td>vlastní zvuková data (a» ji¾ zkomprimovaná èi nezkomprimovaná)</td></tr>
</table>

<p>Hlavní blok má název &bdquo;RIFF&ldquo; a jeho hlavièka má délku pouze
dvanáct bajtù. V&nbsp;prvních ètyøech bajtech je ulo¾eno jméno bloku, co¾ musí
být ASCII znaky "R", "I", "F" a "F" v&nbsp;uvedeném poøadí. Za tìmito ètyømi
bajty následuje délka bloku &ndash; proto¾e se jedná o hlavní blok, je jeho
délka rovna délce celého souboru, ov¹em do této délky není zapoèteno prvních
osm bajtù hlavièky. Samotná délka i dal¹í celoèíselné informace pou¾ívá poøadí
ukládání bajtù little endian. Následují ètyøi bajty obsahující informace o
formátu souboru/dat; v&nbsp;pøípadì zvukových dat jsou zde ulo¾eny bajty
obsahující ASCII znaky "W", "A", "V" a "E", pokud by v¹ak soubor obsahoval jiné
multimediální informace, byla by zde ulo¾ena jiná ètveøice znakù (takový soubor
by v¹ak nemìl koncovku .wav):</p>

<table>
<tr><th>Offset</th><th>©íøka</th><th>Jméno</th><th>Význam</th></tr>
<tr><td>0</td><td>4 bajty</td><td>ChunkID</td><td>musí obsahovat ASCII znaky "RIFF" v uvedeném poøadí</td></tr>
<tr><td>4</td><td>4 bajty</td><td>ChunkSize</td><td>délka souboru sní¾ená o osm bajtù</td></tr>
<tr><td>8</td><td>4 bajty</td><td>Format</td><td>musí obsahovat ASCII znaky "WAVE" v uvedeném poøadí</td></tr>
</table>

<p>Ve zvukových souborech .wav následuje ihned za hlavním blokem
&bdquo;RIFF&ldquo; blok s&nbsp;názvem &bdquo;fmt &ldquo; (i s&nbsp;mezerou na
konci), který obsahuje, jak ji¾ název tohoto bloku naznaèuje, informace o
zpùsobu ulo¾ení zvukových dat. Po jménu tohoto bloku (ètveøice znakù tvoøících
øetìzec &bdquo;fmt &ldquo;) je ve ètyøech bajtech ulo¾ena délka bloku, která je
u vìt¹iny souborù konstantní: 16 bajtù. Na dal¹ích dvou bajtech je ulo¾ena
celoèíselná konstanta reprezentující formát dat. Pro nezkomprimované zvukové
soubory vyu¾ívající PCM (pulznì kódovou modulaci) obsahuje tato dvojice bajtù
hodnotu 1. V&nbsp;dal¹í dvojici bajtù je ulo¾en celkový poèet zvukových kanálù,
co¾ typicky bývá jeden kanál pro mono výstup popø.&nbsp;dva kanály pro stereo
výstup, ov¹em teoreticky je mo¾né vyu¾ít a¾ 65535 zvukových kanálù.</p>

<p>Dal¹í ètyøi bajty obsahují vzorkovací frekvenci, typicky 11025, 22050, 44100
èi 48000 Hz, ov¹em lze nalézt i zvukové soubory s&nbsp;odli¹nými frekvencemi.
Za touto hodnotou je v&nbsp;navazujících ètyøech bajtech ulo¾ena rychlost
pøenosu dat, která se dá vypoèítat pomocí vzorce
<i>SampleRate*NumChannels*BitsPerSample/8</i>. Dal¹ím údajem je hodnota o
zarovnání bloku, která se dá takté¾ vypoèítat, a to s&nbsp;vyu¾itím vzorce
<i>NumChannels*BitsPerSample/8</i>. Poslední údaj je velmi dùle¾itý &ndash; ve
dvou bajtech je ulo¾en poèet bitù pro ka¾dý zvukový vzorek. U osmibitového
samplování je zde ulo¾ena hodnota 8, u 16bitového samplování (CD) hodnota 16,
ov¹em nìkteré zvukové soubory mohou pou¾ívat i dal¹í hodnoty, napøíklad 24
apod.:</p>

<table>
<tr><th>Offset</th><th>©íøka</th><th>Jméno</th><th>Význam</th></tr>
<tr><td>12</td><td>4 bajty</td><td>Subchunk1ID  </td><td>musí obsahovat ASCII znaky "fmt " (i s mezerou na konci)</td></tr>
<tr><td>16</td><td>4 bajty</td><td>Subchunk1Size</td><td>délka tohoto bloku, pro PCM je zde ulo¾ena hodnota 16</td></tr>
<tr><td>20</td><td>2 bajty</td><td>AudioFormat  </td><td>pro PCM je zde ulo¾ena hodnota 1</td></tr>
<tr><td>22</td><td>2 bajty</td><td>NumChannels  </td><td>poèet zvukových kanálù, typicky 1 pro mono výstup a 2 pro stereo výstup</td></tr>
<tr><td>24</td><td>4 bajty</td><td>SampleRate   </td><td>vzorkovací frekvence, typicky 11025 (star¹í SW), 22050, 44100 (CD) èi 48000 (DAT a dal¹í profi zaøízení) atd.</td></tr>
<tr><td>28</td><td>4 bajty</td><td>ByteRate     </td><td>rychlost pøenosu dat do zvukového subsystému (SampleRate*NumChannels*BitsPerSample/8)</td></tr>
<tr><td>32</td><td>2 bajty</td><td>BlockAlign   </td><td>zarovnání bloku (NumChannels*BitsPerSample/8)</td></tr>
<tr><td>34</td><td>2 bajty</td><td>BitsPerSample</td><td>poèet bitù na ka¾dý zvukový vzorek, typicky 8, 16 èi 24</td></tr>
</table>

<p>Vlastní zvuková data jsou ulo¾ena v&nbsp;bloku s&nbsp;názvem
&bdquo;data&ldquo;. Tento blok opìt zaèíná svým jménem (ètveøicí ASCII znakù),
délkou odpovídající vzorci <i>NumSamples*NumChannels*BitsPerSample/8</i> a
samotnými samply, tj.&nbsp;zvukovými vzorky tvoøícími digitální signál
v&nbsp;jednotlivých zvukových kanálech. Pøi formátu PCM nedochází k&nbsp;¾ádné
komprimaci, snad s&nbsp;výjimkou ètyøbitových samplù, kde je dvojice vzorkù
spojena do jednoho bajtu, ov¹em dnes snad u¾ nikdo ètyøbitové samplování
nepou¾ívá :-)</p>

<table>
<tr><th>Offset</th><th>©íøka</th><th>Jméno</th><th>Význam</th></tr>
<tr><td>36</td><td>4 bajty</td><td>Subchunk2ID</td><td>musí obsahovat ASCII znaky "data"</td></tr>
<tr><td>40</td><td>4 bajty</td><td>Subchunk2Size</td><td>délka datového bloku (==NumSamples*NumChannels*BitsPerSample/8)</td></tr>
<tr><td>44</td><td>promìnná délka</td><td>Data</td><td>vlastní zvuková data (za sebou ulo¾ené vzorky jednotlivých zvukových kanálù)</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Utilita pro naètení a výpis základních informací o souborech typu RIFF/WAVE</h2>

<p>Podívejme se nyní na zdrojový kód jednoduché utility, která se pokusí naèíst
a následnì zobrazit základní informace o souborech typu RIFF/WAVE. Tato utilita
pracuje velmi jednodu¹e &ndash; postupnì naèítá jednotlivé prvky ze dvou nám
ji¾ známých blokù &bdquo;RIFF&ldquo; a &bdquo;fmt &ldquo;, pøièem¾ je kód
utility napsán takovým zpùsobem, aby pracoval korektnì jak na architekturách
s&nbsp;poøadím bajtù little endian, tak i na architekturách s&nbsp;poøadím
bajtù big endian (nebo se smí¹eným poøadím, co¾ je v¹ak dnes spí¹e ji¾
historická zále¾itost). Tuto utilitu by mìlo jít (doufejme) pøelo¾it jakýmkoli
pøekladaèem ANSI C:</p>

<pre>
<i>/*</i>
<i> * Nastroj pro vypis zakladnich udaju prectenych z hlavicky souboru .wav</i>
<i> *</i>
<i> * Pavel Tisnovsky 2014</i>
<i> *</i>
<i> * Preklad;</i>
<i> * gcc -ansi -Wall -pedantic read_wav_header.c</i>
<i> */</i>
&nbsp;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Funkce zavolana v pripade, ze pri cteni ze souboru dojde k chybe.</i>
<i> */</i>
void <strong>read_error</strong>(FILE *fin)
{
    printf("Chyba pri cteni bajtu na offsetu %ld\n", ftell(fin));
    if (fclose(fin))
    {
        puts("... a uzavreni souboru taky selhalo!");
    }
    exit(1);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Precteni jednoho bajtu ze souboru s kontrolou, zda nedoslo k chybe.</i>
<i> */</i>
uint8_t <strong>read_byte</strong>(FILE *fin)
{
    int i = fgetc(fin);
    if (i == EOF)
    {
        read_error(fin);
    }
    return i;
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Precteni dvou bajtu ze souboru s kontrolou, zda nedoslo k chybe.</i>
<i> * (format little endian)</i>
<i> */</i>
uint16_t <strong>read_two_bytes</strong>(FILE *fin)
{
    int i1 = read_byte(fin);
    int i2 = read_byte(fin);
    return (i2 &lt;&lt; 8) | (i1);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Precteni ctyr bajtu ze souboru s kontrolou, zda nedoslo k chybe.</i>
<i> * (format little endian)</i>
<i> */</i>
uint32_t <strong>read_four_bytes</strong>(FILE *fin)
{
    int i1 = read_byte(fin);
    int i2 = read_byte(fin);
    int i3 = read_byte(fin);
    int i4 = read_byte(fin);
    return (i4 &lt;&lt; 24) | (i3 &lt;&lt; 16) | (i2 &lt;&lt; 8) | (i1);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Precteni identifikatoru hlavniho bloku z hlavicky souboru .wav</i>
<i> */</i>
void <strong>print_chunk_id</strong>(FILE *fin)
{
    uint32_t chunkID = read_four_bytes(fin);
    <i>/* identifikator musi byt slozen ze znaku "RIFF" */</i>
    if (chunkID == (('R' ) | ('I' &lt;&lt; 8) | ('F' &lt;&lt; 16) | ('F' &lt;&lt; 24)))
    {
        puts("ChunkID         = 'RIFF', ok");
    }
    else
    {
        printf("Wrong chunkID %x\n", chunkID);
        exit(1);
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Precteni velikosti hlavniho bloku z hlavicky souboru .wav</i>
<i> */</i>
void <strong>print_chunk_size</strong>(FILE *fin)
{
    uint32_t chunk_size = read_four_bytes(fin);
    printf("Chunk size      = %d bytes\n", chunk_size);
    printf("Total file size = %d bytes\n", chunk_size + 8);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Precteni formatu souboru z hlavicky souboru .wav</i>
<i> */</i>
void <strong>print_format</strong>(FILE *fin)
{
    uint32_t format = read_four_bytes(fin);
    <i>/* identifikator musi byt slozen ze znaku "WAVE" */</i>
    if (format == (('W' ) | ('A' &lt;&lt; 8) | ('V' &lt;&lt; 16) | ('E' &lt;&lt; 24)))
    {
        puts("Format          = 'WAVE', ok");
    }
    else
    {
        printf("Wrong format %x\n", format);
        exit(1);
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Precteni identifikatoru prvniho subbloku z hlavicky souboru .wav</i>
<i> */</i>
void <strong>print_subchunk1_id</strong>(FILE *fin)
{
    uint32_t chunkID = read_four_bytes(fin);
    <i>/* identifikator musi byt slozen ze znaku "fmt " */</i>
    if (chunkID == (('f' ) | ('m' &lt;&lt; 8) | ('t' &lt;&lt; 16) | (' ' &lt;&lt; 24)))
    {
        puts("Subchunk1ID     = 'fmt ', ok");
    }
    else
    {
        printf("Wrong Subchunk1ID %x\n", chunkID);
        exit(1);
    }
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Precteni velikosti prvniho subbloku z hlavicky souboru .wav</i>
<i> */</i>
void <strong>print_subchunk1_size</strong>(FILE *fin)
{
    uint32_t chunk_size = read_four_bytes(fin);
    printf("Subchunk1 size  = %d bytes\n", chunk_size);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Precteni audio formatu z hlavicky souboru .wav</i>
<i> */</i>
void <strong>print_audio_format</strong>(FILE *fin)
{
    uint16_t audio_format = read_two_bytes(fin);
    printf("Audio format    = %s\n", audio_format == 1 ? "PCM" : "compressed");
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Precteni poctu audio kanalu z hlavicky souboru .wav</i>
<i> */</i>
void <strong>print_num_channels</strong>(FILE *fin)
{
    uint16_t num_channels = read_two_bytes(fin);
    printf("Audio channels  = %d\n", num_channels);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Precteni vzorkovaci frekvence z hlavicky souboru .wav</i>
<i> */</i>
void <strong>print_sample_rate</strong>(FILE *fin)
{
    uint32_t sample_rate = read_four_bytes(fin);
    printf("Sample rate     = %d samples/sec\n", sample_rate);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Precteni rychlosti prenosu dat do audio subsystemu z hlavicky souboru .wav</i>
<i> */</i>
void <strong>print_byte_rate</strong>(FILE *fin)
{
    uint32_t byte_rate = read_four_bytes(fin);
    printf("Byte rate       = %d bytes/sec\n", byte_rate);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Precteni poctu bitu na jeden vzorek z hlavicky souboru .wav</i>
<i> */</i>
void <strong>print_bits_per_sample</strong>(FILE *fin)
{
    uint16_t bits_per_sample = read_two_bytes(fin);
    printf("Bits per sample = %d\n", bits_per_sample);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Tisk zakladnich informaci ziskanych z hlavicky souboru .wav</i>
<i> */</i>
int <strong>print_wav_header</strong>(char *file_name)
{
    FILE *fin;
    fin = fopen(file_name, "rb");
    if (!fin)
    {
        perror("File open error");
        return 1;
    }
    print_chunk_id(fin);
    print_chunk_size(fin);
    print_format(fin);
    print_subchunk1_id(fin);
    print_subchunk1_size(fin);
    print_audio_format(fin);
    print_num_channels(fin);
    print_sample_rate(fin);
    print_byte_rate(fin);
    read_two_bytes(fin);
    print_bits_per_sample(fin);
    fclose(fin);
    return 0;
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Zaciname...</i>
<i> */</i>
int <strong>main</strong>(int argc, char **argv)
{
    if (argc != 2)
    {
        puts("Usage: read_wav_header test.wav");
        return 1;
    }
    return print_wav_header(argv[1]);
}
&nbsp;
&nbsp;
&nbsp;
<i>/*</i>
<i> * Finito</i>
<i> */</i>
</pre>

<p>Pøeklad této utility se provede jednodu¹e:</p>

<pre>
gcc -ansi -Wall -pedantic read_wav_header.c -o read_wav_header
</pre>

<p>Pøíklad pou¾ití si uká¾eme na ètveøici demonstraèních souborù .WAV:</p>

<p><strong>8x8bitpcm.wav:</strong></p>

<pre>
ChunkID         = 'RIFF', ok
Chunk size      = 110524 bytes
Total file size = 110532 bytes
Format          = 'WAVE', ok
Subchunk1ID     = 'fmt ', ok
Subchunk1 size  = 16 bytes
Audio format    = PCM
Audio channels  = 1
Sample rate     = 8000 samples/sec
Byte rate       = 8000 bytes/sec
Bits per sample = 8
</pre>

<p><strong>11k8bitpcm.wav:</strong></p>

<pre>
ChunkID         = 'RIFF', ok
Chunk size      = 152304 bytes
Total file size = 152312 bytes
Format          = 'WAVE', ok
Subchunk1ID     = 'fmt ', ok
Subchunk1 size  = 16 bytes
Audio format    = PCM
Audio channels  = 1
Sample rate     = 11025 samples/sec
Byte rate       = 11025 bytes/sec
Bits per sample = 8
</pre>

<p><strong>11k16bitpcm.wav:</strong></p>

<pre>
ChunkID         = 'RIFF', ok
Chunk size      = 304570 bytes
Total file size = 304578 bytes
Format          = 'WAVE', ok
Subchunk1ID     = 'fmt ', ok
Subchunk1 size  = 16 bytes
Audio format    = PCM
Audio channels  = 1
Sample rate     = 11025 samples/sec
Byte rate       = 22050 bytes/sec
Bits per sample = 16
</pre>

<p><strong>Kitten.wav:</strong></p>

<pre>
ChunkID         = 'RIFF', ok
Chunk size      = 37412 bytes
Total file size = 37420 bytes
Format          = 'WAVE', ok
Subchunk1ID     = 'fmt ', ok
Subchunk1 size  = 16 bytes
Audio format    = PCM
Audio channels  = 1
Sample rate     = 22050 samples/sec
Byte rate       = 44100 bytes/sec
Bits per sample = 16
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Naètení souboru se zvukem do aplikace vyu¾ívající knihovnu SDLJava</h2>

<p>Pro naètení souboru se zvukem s&nbsp;vyu¾itím knihovny <i>SDLJava</i>
nemusíme podrobnì znát vnitøní formát zvukových souborù. Musíme pouze korektnì
inicializovat zvukový subsystém, nastavit hlasitost zvukových kanálù a zahájit
pøehrávání. Inicializace zvukového subsystému se provádí nám ji¾ známou metodou
<strong>SDLMixer.openAudio()</strong>, které se pøedá frekvence pøehrávaných
samplù (na výstupu, nikoli nutnì na vstupu), formát samplù, poèet výstupních
zvukových kanálù a velikost bufferu pou¾itého pøi pøehrávání a mixování:</p>

<pre>
SDLMixer.openAudio(44100, SDLMixer.AUDIO_S16, 1, 1024);
</pre>

<p>Frekvence pøehrávaných samplù se u her vìt¹inou nastavuje na 22050,
tj.&nbsp;na polovièní frekvenci, ne¾ je pou¾ita u Audio CD. Tato frekvence na
jednu stranu zajistí pomìrnì kvalitní zvukový výstup, na stranu druhou není
zbyteènì zatì¾ován procesor v&nbsp;prùbìhu mixování. Jen pro zajímavost se
podívejme na nìkteré èasto pou¾ívané samplovací/pøehrávací frekvence:</p>

<table>
<tr><th> #</th><th>Frekvence</th><th>Pou¾ito</th></tr>
<tr><td> 1</td><td> 8000</td><td>nìkteré wireless telefony a dal¹í zaøízení zamìøené pouze na pøenos lidského hlasu</td></tr>
<tr><td> 2</td><td>11025</td><td>ètvrtina samplovací frekvence CD, pou¾ito napøíklad u&nbsp;nìkterých MPEG nebo i v&nbsp;poèítaèových hrách pro hlas a zvuky (nikoli pro hudbu)</td></tr>
<tr><td> 3</td><td>16000</td><td>pou¾ito ve VoiP (postaèuje bez vìt¹ích zkreslení pro pøenos lidského hlasu)</td></tr>
<tr><td> 4</td><td>22050</td><td>polovina samplovací frekvence CD, pou¾ito i v mnoha hrách (výhodný pomìr kvalita/nároky na mixování)</td></tr>
<tr><td> 5</td><td>22254</td><td>kdysi pou¾ito na poèítaèích Macintosh, proto souèást mnoha pøedev¹ím star¹ích multimediálních aplikací</td></tr>
<tr><td> 6</td><td>32000</td><td>digi rádio apod. (dosa¾itelný frekvenèní rozsah odpovídá FM radiu)</td></tr>
<tr><td> 7</td><td>44056</td><td>pou¾ito v systémech, které kombinují audio signál s NTSC videem (pøesnì 3 samply na ka¾dý video øádek)</td></tr>
<tr><td> 8</td><td>44100</td><td>samplovací frekvence CD, ve hrách mù¾e zpùsobit problémy pøi mixování vìt¹ího mno¾ství kanálù (nìkdy i nutnost zvìt¹ení bufferu)</td></tr>
<tr><td> 9</td><td>48000</td><td>vìt¹ina profi audio zaøízení</td></tr>
<tr><td>10</td><td>88200</td><td>vìt¹ina profi zaøízení, pou¾ito ve chvíli, kdy má být výsledek ulo¾en na CD</td></tr>
<tr><td>11</td><td>96000</td><td>DVD-audio</td></tr>
</table>

<p>Naètení souboru se zvukem zajistí metoda <strong>SDLMixer.loadWAV()</strong>:</p>

<pre>
MixChunk effect = SDLMixer.loadWAV(fileName);
</pre>

<p>Samotné pøehrávání (i na v¹ech kanálech) zajistí pøíkaz
<strong>SDLMixer.playChannel()</strong>, kde lze i specifikovat, kolikrát se má
zvuk pøehrát (poslední parametr). Lze dokonce zvolit i neustálé opakování
pøehrávání (loop) zadáním záporné hodnoty -1:</p>

<pre>
SDLMixer.playChannel(ALL_SOUND_CHANNELS, effect, 0);
</pre>

<p>Test, zda se na urèitém kanálu èi na libovolném kanálu provádí pøehrávání
zvuku, provádí metoda <strong>SDLMixer.playing()</strong> vracející poèet
aktivních kanálù, popø.&nbsp;(pøi volbì jen jednoho kanálu) hodnotu 1 (pøehrává
se) èi 0 (nepøehrává se):</p>

<pre>
while (SDLMixer.playing(ALL_SOUND_CHANNELS) &gt; 0) {
    SDLTimer.delay(100);
}
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Demonstraèní pøíklad <strong>SDLTest66</strong> &ndash; naètení a pøehrání zvuku</h2>

<p>V&nbsp;dne¹ním prvním demonstraèním pøíkladu pojmenovaném
<strong>SDLTest66</strong> je ukázán nejjednodu¹¹í zpùsob pøehrávání zvukù
s&nbsp;vyu¾itím knihovny <i>SDLJava</i>. Nejprve je provedena inicializace
zvukového subsystému zavoláním metody <strong>SDLMixer.openAudio(44100,
SDLMixer.AUDIO_S16, 1, 1024)</strong>, v&nbsp;ní¾ je specifikováno, ¾e se má
vytvoøit jeden (mono) výstupní zvukový kanál, frekvence mixování a pøehrávání
samplù má být 44100 Hz, formát pøehrávaných a mixovaných samplù odpovídá
¹estnáctibitovým celým èíslùm (integer) se znaménkem a velikost zvukového
bufferu má být 1024 bajtù, co¾ je pøi pøehrávání zvuku v&nbsp;jednom kanálu
dostaèující. Následnì je nastavena hlasitost v¹ech zvukových kanálù metodou
<strong>SDLMixer.volume(ALL_SOUND_CHANNELS, 100)</strong>, zvuk je naèten
pøíkazem <strong>SDLMixer.loadWAV(fileName)</strong> a koneènì se zahájí jeho
pøehrávání s&nbsp;vyu¾itím metody
<strong>SDLMixer.playChannel(ALL_SOUND_CHANNELS, effect, 0)</strong>. To, zda
se stále provádí pøehrávání zvuku, lze zjistit metodou
<strong>SDLMixer.playing(ALL_SOUND_CHANNELS)</strong>.</p>

<p>Následuje výpis zdrojového kódu tohoto demonstraèního pøíkladu:</p>

<pre>
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.SDLTimer;
&nbsp;
import sdljava.mixer.SDLMixer;
import sdljava.mixer.MixChunk;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Sedesaty sesty demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> *</i>
<i> * Prehravani zvuku s vyuzitim knihovny SDLJava.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>SDLTest66</strong> {
&nbsp;
    <i>/**</i>
    <i> * Konstanta zastupujici vsechny zvukove kanaly.</i>
    <i> */</i>
    static final int <strong>ALL_SOUND_CHANNELS</strong> = -1;
&nbsp;
    <i>/**</i>
    <i> * Prehrani zvukoveho vzorku.</i>
    <i> */</i>
    public static void <strong>playSample</strong>(String fileName) throws SDLException, InterruptedException {
        <i>// nastaveni vlastnosti zvukoveho subsystemu i vybranych zvukovych kanalu</i>
        SDLMixer.openAudio(44100, SDLMixer.AUDIO_S16, 1, 1024);
        SDLMixer.volume(ALL_SOUND_CHANNELS, 100);
&nbsp;
        <i>// nacteni samplu z externiho souboru</i>
        MixChunk effect = SDLMixer.loadWAV(fileName);
&nbsp;
        <i>// prehrani samplu</i>
        SDLMixer.playChannel(ALL_SOUND_CHANNELS, effect, 0);
&nbsp;
        <i>// musime pockat na ukonceni prehravani</i>
        while (SDLMixer.playing(ALL_SOUND_CHANNELS) &gt; 0) {
            SDLTimer.delay(100);
        }
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni sedesateho sesteho demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace knihovny SDLJava</i>
            SDLMain.init(SDLMain.SDL_INIT_AUDIO);
&nbsp;
            if (args.length != 1) {
                System.out.println("Usage: java SDLTest66 filename.wav");
            }
&nbsp;
            <i>// ziskat jmeno prehravaneho samplu</i>
            final String fileName = args[0];
&nbsp;
            <i>// prehrani zvukoveho vzorku</i>
            playSample(fileName);
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            SDLMain.quit();
        }
    }
&nbsp;
}
</pre>

<p>Skript pro pøeklad tohoto demonstraèního pøíkladu na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest66.java
</pre>

<p>Dávkový soubor pro pøeklad tohoto demonstraèního pøíkladu na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest66.java
</pre>

<p>Skript pro spu¹tìní na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
java -cp .:$SDL_JAVA_LIBS/sdljava.jar -Djava.library.path=$SDL_JAVA_LIBS SDLTest66
</pre>

<p>Dávkový soubor pro spu¹tìní na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest66
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Demonstraèní pøíklad <strong>SDLTest67</strong> &ndash; vliv velikosti bufferu na vznik chyb pøi pøehrávání zvukù</h2>

<p>V&nbsp;dne¹ním druhém demonstraèním pøíkladu pojmenovaném
<strong>SDLTest67</strong> je ukázáno, k&nbsp;jakým problémùm mù¾e dojít, pokud
se zvolí pøíli¹ malá velikost bufferu pou¾ívaného v&nbsp;prùbìhu pøehrávání i
mixování zvukù. <a href="#k06">V&nbsp;pøedchozím pøíkladu</a>
<strong>SDLTest66</strong> byla velikost tohoto bufferu nastavena na 1024
bajtù, co¾ odpovídá 512 ¹estnáctibitovým samplùm, tj.&nbsp;pøibli¾nì 12 ms
pøehrávání pøi pou¾ití frekvence 44100 Hz. To (ponìkud zjednodu¹enì øeèeno)
znamená, ¾e mikroprocesor mìl v&nbsp;prùbìhu pøehrávání zvukù i hudby
k&nbsp;dispozici maximálnì onìch 12 ms, aby dokázal postupnì mixovat a
doplòovat audio data do bufferu. V&nbsp;pøíkladu <strong>SDLTest67</strong> je
naproti tomu velikost bufferu sní¾ena na pouhých 32 bajtù, co¾ znamená, ¾e pøi
pøehrávání bude prakticky na v¹ech poèítaèích docházet k&nbsp;jasnì sly¹itelným
chybám, co¾ si ostatnì lze snadno ovìøit pøekladem a následným spu¹tìním tohoto
demonstraèního pøíkladu (velikost bufferu je mo¾né je¹tì více sní¾it nebo
naopak zvý¹it &ndash; pro pøehrávání hudby se napøíklad doporuèuje hodnota 4096
bajtù).</p>

<pre>
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.SDLTimer;
&nbsp;
import sdljava.mixer.SDLMixer;
import sdljava.mixer.MixChunk;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Sedesaty sedmy demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> *</i>
<i> * Prehravani zvuku s vyuzitim knihovny SDLJava.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>SDLTest67</strong> {
&nbsp;
    <i>/**</i>
    <i> * Konstanta zastupujici vsechny zvukove kanaly.</i>
    <i> */</i>
    static final int <strong>ALL_SOUND_CHANNELS</strong> = -1;
&nbsp;
    <i>/**</i>
    <i> * Prehrani zvukoveho vzorku.</i>
    <i> */</i>
    public static void <strong>playSample</strong>(String fileName) throws SDLException, InterruptedException {
        <i>// nastaveni vlastnosti zvukoveho subsystemu i vybranych zvukovych kanalu</i>
        <i>// velikost bufferu je velmi mala, coz povede k problemum pri prehravani zvuku</i>
        SDLMixer.openAudio(44100, SDLMixer.AUDIO_S16, 1, 32);
        SDLMixer.volume(ALL_SOUND_CHANNELS, 100);
&nbsp;
        <i>// nacteni samplu z externiho souboru</i>
        MixChunk effect = SDLMixer.loadWAV(fileName);
&nbsp;
        <i>// prehrani samplu</i>
        SDLMixer.playChannel(ALL_SOUND_CHANNELS, effect, 0);
&nbsp;
        <i>// musime pockat na ukonceni prehravani</i>
        while (SDLMixer.playing(ALL_SOUND_CHANNELS) &gt; 0) {
            SDLTimer.delay(100);
        }
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni sedesateho sedmeho demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace knihovny SDLJava</i>
            SDLMain.init(SDLMain.SDL_INIT_AUDIO);
&nbsp;
            if (args.length != 1) {
                System.out.println("Usage: java SDLTest66 filename.wav");
            }
&nbsp;
            <i>// ziskat jmeno prehravaneho samplu</i>
            final String fileName = args[0];
&nbsp;
            <i>// prehrani zvukoveho vzorku</i>
            playSample(fileName);
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            SDLMain.quit();
        }
    }
&nbsp;
}
</pre>

<p>Skript pro pøeklad tohoto demonstraèního pøíkladu na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest67.java
</pre>

<p>Dávkový soubor pro pøeklad tohoto demonstraèního pøíkladu na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest67.java
</pre>

<p>Skript pro spu¹tìní na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
java -cp .:$SDL_JAVA_LIBS/sdljava.jar -Djava.library.path=$SDL_JAVA_LIBS SDLTest67
</pre>

<p>Dávkový soubor pro spu¹tìní na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest67
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Demonstraèní pøíklad <strong>SDLTest68</strong> &ndash; vyu¾ití osmi zvukových kanálù pro mixování</h2>

<p>V&nbsp;dne¹ním posledním demonstraèním pøíkladu <strong>SDLTest68</strong>
je ukázáno, jakým zpùsobem lze zajistit mixování vìt¹ího mno¾ství vstupních
zvukových kanálù do jediného kanálu výstupního. Vzhledem k&nbsp;tomu, ¾e se má
mixovat a pøehrávat osm zvukových kanálù, je velikost bufferu v&nbsp;metodì
<strong>SDLMixer.openAudio(44100, SDLMixer.AUDIO_S16, 1, 2048)</strong>
zvìt¹ena na 2048 bajtù. Tato velikost je dostaèující i na mém obstaro¾ním deset
let starém poèítaèi. Následnì je naèten jediný zvuk metodou
<strong>SDLMixer.loadWAV(fileName)</strong> a posléze zaène být tento zvuk
pøehráván osmkrát, v¾dy se zpo¾dìním pøibli¾nì 100 ms, èím¾ vznikne efekt
nìkolikanásobného echa:</p>

<pre>
<i>// prehrani samplu na osmi kanalech</i>
for (int channel = 0; channel &lt; CHANNELS; channel++) {
    SDLTimer.delay(100);
    SDLMixer.playChannel(channel, effect, 0);
}
</pre>

<p>Test na ukonèení pøehrávání je stále prakticky toto¾ný s&nbsp;testy, které
jsme ji¾ vidìli i v&nbsp;pøedchozích demonstraèních pøíkladech:</p>

<pre>
int channels;
while ((channels = (SDLMixer.playing(ALL_SOUND_CHANNELS))) &gt; 0) {
    System.out.println(channels + " channel(s) are playing");
    SDLTimer.delay(100);
}
</pre>

<p>Zdrojový kód demonstraèního pøíkladu <strong>SDLTest68</strong> vypadá
následovnì:</p>

<pre>
import sdljava.SDLMain;
import sdljava.SDLException;
import sdljava.SDLTimer;
&nbsp;
import sdljava.mixer.SDLMixer;
import sdljava.mixer.MixChunk;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Sedesaty osmy demonstracni priklad vyuzivajici knihovnu SDLjava.</i>
<i> *</i>
<i> * Prehravani a mixovani zvuku s vyuzitim knihovny SDLJava.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>SDLTest68</strong> {
&nbsp;
    <i>/**</i>
    <i> * Konstanta zastupujici vsechny zvukove kanaly.</i>
    <i> */</i>
    static final int <strong>ALL_SOUND_CHANNELS</strong> = -1;
&nbsp;
    <i>/**</i>
    <i> * Pocet pouzitych zvukovych kanalu.</i>
    <i> */</i>
    static final int <strong>CHANNELS</strong> = 8;
&nbsp;
    <i>/**</i>
    <i> * Prehrani zvukoveho vzorku.</i>
    <i> */</i>
    public static void <strong>playSample</strong>(String fileName) throws SDLException, InterruptedException {
        <i>// nastaveni vlastnosti zvukoveho subsystemu i vybranych zvukovych kanalu</i>
        SDLMixer.openAudio(44100, SDLMixer.AUDIO_S16, 1, 2048);
&nbsp;
        <i>// nastavit pocet zvukovych kanalu</i>
        SDLMixer.allocateChannels(CHANNELS);
&nbsp;
        <i>// nastavit hlasitost vsech kanalu</i>
        SDLMixer.volume(ALL_SOUND_CHANNELS, 100);
&nbsp;
        <i>// nacteni samplu z externiho souboru</i>
        MixChunk effect = SDLMixer.loadWAV(fileName);
&nbsp;
        <i>// prehrani samplu na osmi kanalech</i>
        for (int channel = 0; channel &lt; CHANNELS; channel++) {
            SDLTimer.delay(100);
            SDLMixer.playChannel(channel, effect, 0);
        }
&nbsp;
        <i>// musime pockat na ukonceni prehravani</i>
        int channels;
        while ((channels = (SDLMixer.playing(ALL_SOUND_CHANNELS))) &gt; 0) {
            System.out.println(channels + " channel(s) are playing");
            SDLTimer.delay(100);
        }
    }
&nbsp;
    <i>/**</i>
    <i> * Spusteni sedesateho osmeho demonstracniho prikladu.</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) {
        try {
            <i>// inicializace knihovny SDLJava</i>
            SDLMain.init(SDLMain.SDL_INIT_AUDIO);
&nbsp;
            if (args.length != 1) {
                System.out.println("Usage: java SDLTest66 filename.wav");
            }
&nbsp;
            <i>// ziskat jmeno prehravaneho samplu</i>
            final String fileName = args[0];
&nbsp;
            <i>// prehrani zvukoveho vzorku</i>
            playSample(fileName);
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            SDLMain.quit();
        }
    }
&nbsp;
}
</pre>

<p>Skript pro pøeklad tohoto demonstraèního pøíkladu na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
javac -cp $SDL_JAVA_LIBS/sdljava.jar SDLTest68.java
</pre>

<p>Dávkový soubor pro pøeklad tohoto demonstraèního pøíkladu na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
javac -cp %SDL_JAVA_LIBS%\sdljava.jar SDLTest68.java
</pre>

<p>Skript pro spu¹tìní na Linuxu:</p>

<pre>
#!/bin/sh
&nbsp;
SDL_JAVA_LIBS=./sdljava-0.9.1/lib
&nbsp;
java -cp .:$SDL_JAVA_LIBS/sdljava.jar -Djava.library.path=$SDL_JAVA_LIBS SDLTest68
</pre>

<p>Dávkový soubor pro spu¹tìní na Windows:</p>

<pre>
set SDL_JAVA_LIBS=.\sdljava-0.9.1\lib
&nbsp;
java -cp .;%SDL_JAVA_LIBS%\sdljava.jar -Djava.library.path=%SDL_JAVA_LIBS% SDLTest68
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Repositáø se zdrojovými kódy v¹ech ètyø dne¹ních demonstraèních pøíkladù</h2>

<p>V¹echny ètyøi dnes popsané demonstraèní pøíklady byly spoleènì
s&nbsp;podpùrnými skripty urèenými pro jejich pøeklad a následné spu¹tìní
ulo¾eny do Mercurial repositáøe dostupného na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
Podobnì jako tomu bylo i v&nbsp;pøedchozích nìkolika dílech tohoto seriálu, i
ke dne¹ním pøíkladùm jsou pøilo¾eny skripty vyu¾itelné pro jejich pøeklad a
spu¹tìní. Navíc byly pøidány i skripty vyu¾itelné ve Windows:</p>

<table>
<tr><th> #</th><th>Zdrojový soubor/skript</th><th>Umístìní souboru v&nbsp;repositáøi</th></tr>
<tr><td> 1</td><td>SDLTest66.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest66/SDLTest66.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest66/SDLTest66.java</a></td></tr>
<tr><td> 2</td><td>SDLTest66_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest66/SDLTest66_compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest66/SDLTest66_compile.sh</a></td></tr>
<tr><td> 3</td><td>SDLTest66_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest66/SDLTest66_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest66/SDLTest66_compile_sys.sh</a></td></tr>
<tr><td> 4</td><td>SDLTest66_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest66/SDLTest66_run.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest66/SDLTest66_run.sh</a></td></tr>
<tr><td> 5</td><td>SDLTest66_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest66/SDLTest66_run_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest66/SDLTest66_run_sys.sh</a></td></tr>
<tr><td> 6</td><td>SDLTest66_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest66/SDLTest66_compile.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest66/SDLTest66_compile.bat</a></td></tr>
<tr><td> 7</td><td>SDLTest66_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest66/SDLTest66_run.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest66/SDLTest66_run.bat</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>SDLTest67.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest67/SDLTest67.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest67/SDLTest67.java</a></td></tr>
<tr><td> 9</td><td>SDLTest67_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest67/SDLTest67_compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest67/SDLTest67_compile.sh</a></td></tr>
<tr><td>10</td><td>SDLTest67_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest67/SDLTest67_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest67/SDLTest67_compile_sys.sh</a></td></tr>
<tr><td>11</td><td>SDLTest67_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest67/SDLTest67_run.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest67/SDLTest67_run.sh</a></td></tr>
<tr><td>12</td><td>SDLTest67_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest67/SDLTest67_run_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest67/SDLTest67_run_sys.sh</a></td></tr>
<tr><td>13</td><td>SDLTest67_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest67/SDLTest67_compile.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest67/SDLTest67_compile.bat</a></td></tr>
<tr><td>14</td><td>SDLTest67_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest67/SDLTest67_run.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest67/SDLTest67_run.bat</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>SDLTest68.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest68/SDLTest68.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest68/SDLTest68.java</a></td></tr>
<tr><td>16</td><td>SDLTest68_compile.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest68/SDLTest68_compile.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest68/SDLTest68_compile.sh</a></td></tr>
<tr><td>17</td><td>SDLTest68_compile_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest68/SDLTest68_compile_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest68/SDLTest68_compile_sys.sh</a></td></tr>
<tr><td>18</td><td>SDLTest68_run.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest68/SDLTest68_run.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest68/SDLTest68_run.sh</a></td></tr>
<tr><td>19</td><td>SDLTest68_run_sys.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest68/SDLTest68_run_sys.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest68/SDLTest68_run_sys.sh</a></td></tr>
<tr><td>20</td><td>SDLTest68_compile.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest68/SDLTest68_compile.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest68/SDLTest68_compile.bat</a></td></tr>
<tr><td>21</td><td>SDLTest68_run.bat</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest68/SDLTest68_run.bat">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/e9dd7f620b94/sdljava/SDLTest68/SDLTest68_run.bat</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>read_wav_header.c</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/75f0ad3bfdc7/tools/read_wav_header.c">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/75f0ad3bfdc7/tools/read_wav_header.c</a></td></tr>
</table>



<p><a name="k10"></a></p>
<h2 id="k10">10. Odkazy na Internetu</h2>

<ol>

<li>Audio File Formats.<br />
<a href="http://sox.sourceforge.net/AudioFormats-11.html">http://sox.sourceforge.net/AudioFormats-11.html</a>
</li>

<li>TestSounds.com: pure digital sounds to test your audio<br />
<a href="http://www.testsounds.com/">http://www.testsounds.com/</a>
</li>

<li>Test Tones (20hz - 20khz)<br />
<a href="http://mdf1.tripod.com/test-tones.html">http://mdf1.tripod.com/test-tones.html</a>
</li>

<li>WAV (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/WAV">http://en.wikipedia.org/wiki/WAV</a>
</li>

<li>WAVE PCM soundfile format<br />
<a href="https://ccrma.stanford.edu/courses/422/projects/WaveFormat/">https://ccrma.stanford.edu/courses/422/projects/WaveFormat/</a>
</li>

<li>Audio Interchange File Format<br />
<a href="http://en.wikipedia.org/wiki/Aiff">http://en.wikipedia.org/wiki/Aiff</a>
</li>

<li>Musical Instrument Digital Interface,<br />
<a href="http://en.wikipedia.org/wiki/Musical_Instrument_Digital_Interface">http://en.wikipedia.org/wiki/Musical_Instrument_Digital_Interface</a>
</li>

<li>A MIDI Pedalboard Encode,<br />
<a href="http://www.pykett.org.uk/a_midi_pedalboard_encoder.htm">http://www.pykett.org.uk/a_midi_pedalboard_encoder.htm</a>
</li>

<li>MIDI Note Number, Frequency Table,<br />
<a href="http://tonalsoft.com/pub/news/pitch-bend.aspx">http://tonalsoft.com/pub/news/pitch-bend.aspx</a>
</li>

<li>Note names, MIDI numbers and frequencies,<br />
<a href="http://www.phys.unsw.edu.au/jw/notes.html">http://www.phys.unsw.edu.au/jw/notes.html</a>
</li>

<li>The MIDI Specification,<br />
<a href="http://www.gweep.net/~prefect/eng/reference/protocol/midispec.html">http://www.gweep.net/~prefect/eng/reference/protocol/midispec.html</a>
</li>

<li>Essentials of the MIDI protocol,<br />
<a href="http://ccrma.stanford.edu/~craig/articles/linuxmidi/misc/essenmidi.html">http://ccrma.stanford.edu/~craig/articles/linuxmidi/misc/essenmidi.html</a>
</li>

<li>General MIDI,<br />
<a href="http://en.wikipedia.org/wiki/General_MIDI">http://en.wikipedia.org/wiki/General_MIDI</a>
</li>

<li>Obecné MIDI (General MIDI), <br />
<a href="http://www-kiv.zcu.cz/~herout/html_sbo/midi/5.html">http://www-kiv.zcu.cz/~herout/html_sbo/midi/5.html</a>
</li>

<li>Custom Chips: Paula<br />
<a href="http://www.amiga-hardware.com/showhardware.cgi?HARDID=1460">http://www.amiga-hardware.com/showhardware.cgi?HARDID=1460</a>
</li>

<li>Big Book of Amiga Hardware<br />
<a href="http://www.amiga-resistance.info/bboahfaq/">http://www.amiga-resistance.info/bboahfaq/</a>
</li>

<li>Amiga Hardware Database<br />
<a href="http://amiga.resource.cx/">http://amiga.resource.cx/</a>
</li>

<li>ExoticA<br />
<a href="http://www.exotica.org.uk/wiki/Main_Page">http://www.exotica.org.uk/wiki/Main_Page</a>
</li>

<li>The absolute basics of Amiga audio<br />
<a href="http://www.sufo.estates.co.uk/amiga/amimus.html">http://www.sufo.estates.co.uk/amiga/amimus.html</a>
</li>

<li>Wikipedia: Tracker<br />
<a href="http://en.wikipedia.org/wiki/Tracker">http://en.wikipedia.org/wiki/Tracker</a>
</li>

<li>Wikipedia: Trackers<br />
<a href="http://en.wikipedia.org/wiki/Trackers">http://en.wikipedia.org/wiki/Trackers</a>
</li>

<li>Ultimate Soundtracker<br />
<a href="http://en.wikipedia.org/wiki/Ultimate_Soundtracker">http://en.wikipedia.org/wiki/Ultimate_Soundtracker</a>
</li>

<li>Protracker<br />
<a href="http://en.wikipedia.org/wiki/ProTracker">http://en.wikipedia.org/wiki/ProTracker</a>
</li>

<li>Impulse Tracker<br />
<a href="http://en.wikipedia.org/wiki/Impulse_Tracker">http://en.wikipedia.org/wiki/Impulse_Tracker</a>
</li>

<li>Scream Tracker<br />
<a href="http://en.wikipedia.org/wiki/ScreamTracker">http://en.wikipedia.org/wiki/ScreamTracker</a>
</li>

<li>MikMod for Java<br />
<a href="http://jmikmod.berlios.de/">http://jmikmod.berlios.de/</a>
</li>

<li>List of audio trackers<br />
<a href="http://en.wikipedia.org/wiki/List_of_audio_trackers">http://en.wikipedia.org/wiki/List_of_audio_trackers</a>
</li>

<li>Wikipedia: Module File<br />
<a href="http://en.wikipedia.org/wiki/Module_file">http://en.wikipedia.org/wiki/Module_file</a>
</li>

<li>Wikipedia: Chiptune<br />
<a href="http://en.wikipedia.org/wiki/Chiptune">http://en.wikipedia.org/wiki/Chiptune</a>
</li>

<li>SDL_mixer 2.0<br />
<a href="http://www.libsdl.org/projects/SDL_mixer/">http://www.libsdl.org/projects/SDL_mixer/</a>
</li>

<li>SDLJava: package sdljava.ttf<br />
<a href="http://sdljava.sourceforge.net/docs/api/sdljava/ttf/package-summary.html#package_description">http://sdljava.sourceforge.net/docs/api/sdljava/ttf/package-summary.html#package_description</a>
</li>

<li>SDLJava: class sdljava.ttf.SDLTTF<br />
<a href="http://sdljava.sourceforge.net/docs/api/sdljava/ttf/SDLTTF.html">http://sdljava.sourceforge.net/docs/api/sdljava/ttf/SDLTTF.html</a>
</li>

<li>SDLJava: class sdljava.ttf.SDLTrueTypeFont<br />
<a href="http://sdljava.sourceforge.net/docs/api/sdljava/ttf/SDLTrueTypeFont.html">http://sdljava.sourceforge.net/docs/api/sdljava/ttf/SDLTrueTypeFont.html</a>
</li>

<li>SDL_ttf Documentation<br />
<a href="http://www.libsdl.org/projects/SDL_ttf/docs/">http://www.libsdl.org/projects/SDL_ttf/docs/</a>
</li>

<li>SDL_ttf 2.0 (není prozatím souèástí SDLJava)<br />
<a href="http://www.libsdl.org/projects/SDL_ttf/">http://www.libsdl.org/projects/SDL_ttf/</a>
</li>

<li>SDL_ttf doc<br />
<a href="http://www.libsdl.org/projects/SDL_ttf/docs/SDL_ttf_frame.html">http://www.libsdl.org/projects/SDL_ttf/docs/SDL_ttf_frame.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_Surface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_PixelFormat<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlpixelformat.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlpixelformat.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_LockSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdllocksurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdllocksurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_UnlockSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlunlocksurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlunlocksurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_LoadBMP<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlloadbmp.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlloadbmp.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_SaveBMP<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsavebmp.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlsavebmp.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_BlitSurface<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlblitsurface.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlblitsurface.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_VideoInfo<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlvideoinfo.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlvideoinfo.html</a>
</li>

<li>SDL 1.2 Documentation: SDL_GetVideoInfo<br />
<a href="http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlgetvideoinfo.html">http://www.libsdl.org/release/SDL-1.2.15/docs/html/sdlgetvideoinfo.html</a>
</li>

<li>glDrawArrays<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArrays.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArrays.xml</a>
</li>

<li>glDrawElements<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElements.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElements.xml</a>
</li>

<li>glDrawArraysInstanced<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArraysInstanced.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawArraysInstanced.xml</a>
</li>

<li>glDrawElementsInstanced<br />
<a href="http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElementsInstanced.xml">http://www.opengl.org/sdk/docs/man4/xhtml/glDrawElementsInstanced.xml</a>
</li>

<li>Root.cz: Seriál Grafická knihovna OpenGL<br />
<a href="http://www.root.cz/serialy/graficka-knihovna-opengl/">http://www.root.cz/serialy/graficka-knihovna-opengl/</a>
</li>

<li>Root.cz: Seriál Tvorba pøenositelných grafických aplikací vyu¾ívajících knihovnu GLUT<br />
<a href="http://www.root.cz/serialy/tvorba-prenositelnych-grafickych-aplikaci-vyuzivajicich-knihovnu-glut/">http://www.root.cz/serialy/tvorba-prenositelnych-grafickych-aplikaci-vyuzivajicich-knihovnu-glut/</a>
</li>

<li>Best Practices for Working with Vertex Data<br />
<a href="https://developer.apple.com/library/ios/documentation/3ddrawing/conceptual/opengles_programmingguide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html">https://developer.apple.com/library/ios/documentation/3ddrawing/conceptual/opengles_programmingguide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html</a>
</li>

<li>Class BufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferStrategy.html</a>
</li>

<li>Class Graphics<br />
<a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/Graphics.html">http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/Graphics.html</a>
</li>

<li>Double Buffering and Page Flipping<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html</a>
</li>

<li>BufferStrategy and BufferCapabilities<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/bufferstrategy.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/bufferstrategy.html</a>
</li>

<li>Java:Tutorials:Double Buffering<br />
<a href="http://content.gpwiki.org/index.php/Java:Tutorials:Double_Buffering">http://content.gpwiki.org/index.php/Java:Tutorials:Double_Buffering</a>
</li>

<li>Double buffer in standard Java AWT<br />
<a href="http://www.codeproject.com/Articles/2136/Double-buffer-in-standard-Java-AWT">http://www.codeproject.com/Articles/2136/Double-buffer-in-standard-Java-AWT</a>
</li>

<li>Java 2D: Hardware Accelerating - Part 1 - Volatile Images<br />
<a href="http://www.javalobby.org/forums/thread.jspa?threadID=16840&tstart=0">http://www.javalobby.org/forums/thread.jspa?threadID=16840&tstart=0</a>
</li>

<li>Java 2D: Hardware Accelerating - Part 2 - Buffer Strategies<br />
<a href="http://www.javalobby.org/java/forums/t16867.html">http://www.javalobby.org/java/forums/t16867.html</a>
</li>

<li>How does paintComponent work?<br />
<a href="http://stackoverflow.com/questions/15544549/how-does-paintcomponent-work">http://stackoverflow.com/questions/15544549/how-does-paintcomponent-work</a>
</li>

<li>A Swing Architecture Overview<br />
<a href="http://www.oracle.com/technetwork/java/architecture-142923.html">http://www.oracle.com/technetwork/java/architecture-142923.html</a>
</li>

<li>Class javax.swing.JComponent<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html</a>
</li>

<li>Class java.awt.Component<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html</a>
</li>

<li>Class java.awt.Component.BltBufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.BltBufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.BltBufferStrategy.html</a>
</li>

<li>Class java.awt.Component.FlipBufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.FlipBufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.FlipBufferStrategy.html</a>
</li>

<li>Metoda java.awt.Component.isDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html#isDoubleBuffered()">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html#isDoubleBuffered()</a>
</li>

<li>Metoda javax.swing.JComponent.isDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#isDoubleBuffered()">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#isDoubleBuffered()</a>
</li>

<li>Metoda javax.swing.JComponent.setDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#setDoubleBuffered(boolean)">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#setDoubleBuffered(boolean)</a>
</li>

<li>Javadoc - tøída GraphicsDevice<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html</a>
</li>

<li>Javadoc - tøída GraphicsEnvironment<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html</a>
</li>

<li>Javadoc - tøída GraphicsConfiguration<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html</a>
</li>

<li>Javadoc - tøída DisplayMode<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html">http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html</a>
</li>

<li>Lesson: Full-Screen Exclusive Mode API<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/">http://docs.oracle.com/javase/tutorial/extra/fullscreen/</a>
</li>

<li>Full-Screen Exclusive Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html</a>
</li>

<li>Display Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html</a>
</li>

<li>Using the Full-Screen Exclusive Mode API in Java<br />
<a href="http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm">http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>GC safe-point (or safepoint) and safe-region<br />
<a href="http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html">http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html</a>
</li>

<li>Safepoints in HotSpot JVM<br />
<a href="http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html">http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html</a>
</li>

<li>Java theory and practice: Synchronization optimizations in Mustang<br />
<a href="http://www.ibm.com/developerworks/java/library/j-jtp10185/">http://www.ibm.com/developerworks/java/library/j-jtp10185/</a>
</li>

<li>How to build hsdis<br />
<a href="http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README">http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README</a>
</li>

<li>Java SE 6 Performance White Paper<br />
<a href="http://www.oracle.com/technetwork/java/6-performance-137236.html">http://www.oracle.com/technetwork/java/6-performance-137236.html</a>
</li>

<li>Lukas Stadler's Blog<br />
<a href="http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html">http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html</a>
</li>

<li>How to build hsdis-amd64.dll and hsdis-i386.dll on Windows<br />
<a href="http://dropzone.nfshost.com/hsdis.htm">http://dropzone.nfshost.com/hsdis.htm</a>
</li>

<li>PrintAssembly<br />
<a href="https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly">https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly</a>
</li>

<li>The Java Virtual Machine Specification: 3.14. Synchronization<br />
<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14</a>
</li>

<li>The Java Virtual Machine Specification: 8.3.1.4. volatile Fields<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.4. Memory Model<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.7. Non-atomic Treatment of double and long<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7</a>
</li>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (pøed verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2014</small></p>
</body>
</html>

