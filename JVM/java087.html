<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - pøímé generování instrukcí bajtkódu s vyu¾itím nástroje Javassist</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - pøímé generování instrukcí bajtkódu s vyu¾itím nástroje Javassist</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o virtuálním stroji Javy se ji¾ potøetí budeme vìnovat popisu mo¾ností nástroje Javassist. Dnes si uká¾eme, jak lze pøímo generovat jednotlivé &bdquo;strojové&ldquo; instrukce bajtkódu s vyu¾itím pøíslu¹ných pomocných tøíd Javassistu.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - pøímé generování instrukcí bajtkódu s&nbsp;vyu¾itím nástroje Javassist: sekvence instrukcí jako atribut pøiøazený k&nbsp;metodì</a></p>
<p><a href="#k02">2. Vygenerování metody bez pøiøazeného atributu <strong>code</strong> (metoda bez instrukcí)</a></p>
<p><a href="#k03">3. Zdrojový kód demonstraèního pøíkladu <strong>ClassGenerationTest6</strong></a></p>
<p><a href="#k04">4. Výpis bajtkódu vygenerovaného demonstraèním pøíkladem <strong>ClassGenerationTest6</strong></a></p>
<p><a href="#k05">5. Spu¹tìní tøídy vygenerované demonstraèním pøíkladem <strong>ClassGenerationTest6</strong></a></p>
<p><a href="#k06">6. Tvorba kódu metod na úrovni jednotlivých &bdquo;strojových&ldquo; instrukcí</a></p>
<p><a href="#k07">7. Vygenerování metody <strong>int foo()</strong></a></p>
<p><a href="#k08">8. Vygenerování metody <strong>int add(int, int)</strong></a></p>
<p><a href="#k09">9. Zdrojový kód demonstraèního pøíkladu <strong>ClassGenerationTest7</strong></a></p>
<p><a href="#k10">10. Výpis bajtkódu vygenerovaného demonstraèním pøíkladem <strong>ClassGenerationTest7</strong></a></p>
<p><a href="#k11">11. Repositáø se zdrojovými kódy obou dne¹ních demonstraèních pøíkladù</a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - pøímé generování instrukcí bajtkódu s&nbsp;vyu¾itím nástroje Javassist: sekvence instrukcí jako atribut pøiøazený k&nbsp;metodì</h2>

<p>V&nbsp;dne¹ní èásti seriálu o programovacím jazyce Java i o virtuálním
stroji Javy si uká¾eme zpùsob vytváøení nových metod na ni¾¹í úrovni abstrakce,
konkrétnì na úrovni jednotlivých instrukcí bajtkódu. Navá¾eme tak na èást
pøedchozí, v&nbsp;ní¾ jsme se seznámili se zpùsobem tvorby metod
v&nbsp;pøípadì, ¾e máme k&nbsp;dispozici textovou podobu jejich tìl,
tj.&nbsp;blokù obsahujících lokální deklarace, lokální promìnné i jednotlivé
(strukturované) pøíkazy. Nejdøíve si v¹ak ve struènosti zopakujme, jak vlastnì
vypadá struktura bajtkódu ka¾dé pøelo¾ené tøídy èi rozhraní, tj.&nbsp;struktura
ka¾dého souboru s&nbsp;koncovkou <strong>.class</strong>. Celý soubor je
rozdìlen do nìkolika sekcí, které jsou dále rozdìlovány do dal¹ích podsekcí. Na
nejvy¹¹í úrovni se nachází sekce s&nbsp;hlavièkou bajtkódu, constant poolem,
seznamem datových polo¾ek, kódy jednotlivých metod a koneènì dal¹ími metadaty
(atributy) tøídy:</p>

<pre>
+-----------------------------------------+
|   Hlavièka bajtkódu                     |
|                                         |
|  +-------------------------+---------+  |
|  | Magická konstanta       | 4 bajty |  |
|  +-------------------------+---------+  |
|  | Minoritní verze formátu | 2 bajty |  |
|  +-------------------------+---------+  |
|  | Majoritní verze formátu | 2 bajty |  |
|  +-------------------------+---------+  |
|                                         |
+-----------------------------------------+
|   Constant pool                         |
|                                         |
|  +-------------------------+---------+  |
|  | Poèet záznamù v poolu   | 2 bajty |  |
|  +-------------------------+---------+  |
|  | záznam #1               | x bajtù |  |
|  | záznam #2               | x bajtù |  |
|  | ...                     |         |  |
|  | záznam #n               | x bajtù |  |
|  +-------------------------+---------+  |
|                                         |
+-----------------------------------------+
|   Definice pøíznakù tøídy/rozhraní      |
|                                         |
|  +-------------------------+---------+  |
|  | Bitové pole s pøíznaky  | 2 bajty |  |
|  +-------------------------+---------+  |
|                                         |
+-----------------------------------------+
|   Jméno tøídy a nadtøídy                |
|                                         |
|  +-------------------------+---------+  |
|  | Index do constant poolu | 2 bajty |  |
|  +-------------------------+---------+  |
|  | Index do constant poolu | 2 bajty |  |
|  +-------------------------+---------+  |
|                                         |
+-----------------------------------------+
|   Implementovaná rozhraní               |
|                                         |
|  +-------------------------+---------+  |
|  | Poèet jmen rozhraní     | 2 bajty |  |
|  +-------------------------+---------+  |
|  | Index do const. poolu #1| 2 bajty |  |
|  | Index do const. poolu #2| 2 bajty |  |
|  | ...                     |         |  |
|  | Index do const. poolu #n| 2 bajty |  |
|  +-------------------------+---------+  |
|                                         |
+-----------------------------------------+
|   Datové polo¾ky deklarované ve tøídì   |
|   .....                                 |
|   .....                                 |
|   .....                                 |
+-----------------------------------------+
|   Kódy jednotlivých metod               |
|   .....                                 |
|   .....                                 |
|   .....                                 |
+-----------------------------------------+
|   Dal¹í metadata tøídy                  |
|   (atributy tøídy)                      |
|   .....                                 |
|   .....                                 |
|   .....                                 |
+-----------------------------------------+
</pre>

<p>Nás dnes bude zajímat pøedev¹ím zpùsob ulo¾ení instrukcí tvoøících tìla
jednotlivých metod. Ponìkud pøekvapivì jsou tato velmi dùle¾itá data ulo¾ena ve
formì atributù pøiøazených k&nbsp;jednotlivým metodám. Ke ka¾dé datové polo¾ce
èi metodì toti¾ mù¾e být pøiøazen libovolný poèet atributù, které umo¾òují
ulo¾ení dal¹ích informací o této datové polo¾ce/metodì, resp.&nbsp;o jejích
vlastnostech. Poèet atributù je libovolný, samozøejmì mù¾e být i nulový (to se
ostatnì týká vìt¹iny nefinálních datových polo¾ek, kterým ¾ádný atribut nebývá
pøiøazen).</p>

<p>Ka¾dý atribut se obecnì skládá z&nbsp;dvojice obsahující jméno atributu a
jeho hodnotu. Jméno atributu je zadáno nepøímo jako odkaz do <i>constant
poolu</i>, proto¾e se v&nbsp;mnoha pøípadech mù¾eme setkat s&nbsp;tím, ¾e
shodný atribut je pou¾it u vìt¹ího mno¾ství datových polo¾ek (jedná se
napøíklad o atribut se jménem <strong>ConstantValue</strong> odkazující na
konstantu ulo¾enou té¾ v&nbsp;poolu). Následující tabulka obsahuje jména a
struèný popis atributù popsaných pøímo ve specifikaci virtuálního stroje
Javy:</p>

<table>
<tr><th> #</th><th>Jméno atributu</th><th>Význam</th></tr>
<tr><td> 1</td><td>ConstantValue</td><td>odkaz na konstantu u finální datové polo¾ky</td></tr>
<tr><td> 2</td><td>Code</td><td>instrukce tvoøící tìlo metody (právì tento atribut dnes vyu¾ijeme)</td></tr>
<tr><td> 3</td><td>Exceptions</td><td>informace o výjimkách, které mù¾e metoda vyhazovat</td></tr>
<tr><td> 4</td><td>InnerClasses</td><td>informace o vnitøních tøídách (jedná se o atribut tøídy)</td></tr>
<tr><td> 5</td><td>EnclosingMethod</td><td>informace uvádìná u vnitøních a anonymních tøíd</td></tr>
<tr><td> 6</td><td>Synthetic</td><td>atribut bez hodnoty (délka=0) uvádìný u syntetických tøíd, metod èi datových polo¾ek</td></tr>
<tr><td> 7</td><td>Signature</td><td>atribut obsahující odkaz na signaturu tøídy, metody èi datové polo¾ky</td></tr>
<tr><td> 8</td><td>SourceFile</td><td>atribut obsahující odkaz na jméno zdrojového souboru (ulo¾ené v&nbsp;constant poolu)</td></tr>
<tr><td> 9</td><td>LineNumberTable</td><td>atribut obsahující pole s&nbsp;mapováním mezi instrukcemi metody a odpovídajícím zdrojovým øádkem</td></tr>
<tr><td>10</td><td>LocalVariableTable</td><td>atribut obsahující ladicí informace o lokálních promìnných</td></tr>
<tr><td>11</td><td>LocalVariableTypeTable</td><td>atribut obsahující ladicí informace o typech lokálních promìnných</td></tr>
<tr><td>11</td><td>Deprecated</td><td>atribut bez hodnoty (délka=0) uvádìný u tøíd, metod a datových polo¾ek s&nbsp;anotací @Deprecated</td></tr>
</table>

<p>Jak je z&nbsp;pøedchozí tabulky patrné, jsou instrukce tvoøící tìla metod
ulo¾eny do atributu s&nbsp;názvem <strong>Code</strong>. Hodnotu tohoto
atributu v¹ak nebudeme muset vytváøet ruènì bajt po bajtu, proto¾e budeme moci
vyu¾ít mo¾ností nabízených knihovnou <i>Javassist</i>, pøedev¹ím pak její
tøídou <strong>Bytecode</strong> a <strong>Opcode</strong>.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Vygenerování metody bez pøiøazeného atributu <strong>code</strong> (metoda bez instrukcí)</h2>

<p>Nástroj <i>Javassist</i> podporuje vytváøení nových metod s&nbsp;následným
pøidáním tìchto metod do libovolné tøídy. Jakým zpùsobem se nové metody mohou
vytvoøit jsme si ukázali v&nbsp;pøedchozí èásti tohoto seriálu. Ov¹em prozatím
v¹echny námi vytváøené metody obsahovaly i tìlo, tj.&nbsp;pøíkazový blok.
Jinými slovy to znamená, ¾e ke v¹em prozatím vytváøeným metodám byl nástrojem
<i>Javassist</i> vygenerován i atribut se jménem <strong>Code</strong>
obsahující pøíslu¹ný seznam instrukcí vzniklých pøekladem tìl metod. Ve
skuteènosti v¹ak nìkteré metody nemusí mít nutnì pøiøazen atribut
<strong>Code</strong>. Jedná se napøíklad o abstraktní metody
(v&nbsp;abstraktních tøídách) èi metody deklarované v&nbsp;nìjakém
rozhraní.</p>

<p>Podívejme se na konkrétní pøíklad, v&nbsp;nìm¾ je metoda <strong>int
foo()</strong> vytvoøena jako bì¾ná neabstraktní metoda, abstraktní metoda
v&nbsp;abstraktní tøídì a koneènì jako pouhá hlavièka metody, která je souèástí
rozhraní:</p>

<pre>
<strong>class X</strong> {
    int foo() {
        return 42;
    }
}
&nbsp;
<strong>abstract class Y</strong> {
    abstract int foo();
}
&nbsp;
<strong>interface Z</strong> {
    int foo();
}
</pre>

<p>Po pøekladu tøíd <strong>X</strong> a <strong>Y</strong> i rozhraní
<strong>Z</strong> získáme podle oèekávání trojici souborù s&nbsp;koncovkou
<strong>.class</strong>. Tyto soubory lze velmi snadno analyzovat, napøíklad
v&nbsp;tomto seriálu ji¾ popsaným jednoduchým nástrojem
<strong>decompiler5.c</strong> (<a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/0b0f51cf19d2/decompiler/decompiler5.c">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/0b0f51cf19d2/decompiler/decompiler5.c</a>).
Pro tøídu <strong>X</strong> snadno zjistíme,
¾e k&nbsp;metodì <strong>int foo()</strong> je skuteènì pøiøazený atribut
<strong>Code</strong>:</p>

<pre>
Magicka konstanta: cafebabe
Cislo verze:       50
Cislo podverze:    0
&nbsp;
Velikost const. poolu: 14 prvku
&nbsp;
Class/interface attributes: 0x0020
    ACC_SUPER
&nbsp;
Class name is stored in constant pool #1
Class            13        X
Super class name is stored in constant pool #2
Class            14        java/lang/Object
&nbsp;
Number of implemented interfaces: 0
&nbsp;
Number of declared fields: 0
&nbsp;
Number of declared methods: 2
  Method name:'&lt;init&gt;'
  Descriptor:  ()V
    Field flags: 0x0000
  Attributes:  1
    Name:  'Code'
    Value: ' 00 01 00 01 00 00 00 05 2a b7 00 01 b1 00 00 00 01 00 07 00 00 00 06 00 01 00 00 00 01'
&nbsp;
  Method name:'foo'
  Descriptor:  ()I
    Field flags: 0x0000
  Attributes:  1
    Name:  'Code'
    Value: ' 00 01 00 01 00 00 00 03 10 2a ac 00 00 00 01 00 07 00 00 00 06 00 01 00 00 00 03'
</pre>

<p>V&nbsp;pøelo¾ené tøídì <strong>Y</strong> sice takté¾ existuje metoda
<strong>int foo()</strong>, ov¹em tato metoda je abstraktní (viz její pøíznaky
&ndash; fields) a tudí¾ k&nbsp;ní není pøiøazen ¾ádný atribut
<strong>Code</strong> (jediný kód je souèástí konstruktoru tøídy):</p>

<pre>
Magicka konstanta: cafebabe
Cislo verze:       50
Cislo podverze:    0
&nbsp;
Velikost const. poolu: 14 prvku
&nbsp;
Class/interface attributes: 0x0420
    ACC_ABSTRACT
    ACC_SUPER
&nbsp;
Class name is stored in constant pool #1
Class            13        Y
Super class name is stored in constant pool #2
Class            14        java/lang/Object
&nbsp;
Number of implemented interfaces: 0
&nbsp;
Number of declared fields: 0
&nbsp;
Number of declared methods: 2
  Method name:'&lt;init&gt;'
  Descriptor:  ()V
    Field flags: 0x0000
  Attributes:  1
    Name:  'Code'
    Value: ' 00 01 00 01 00 00 00 05 2a b7 00 01 b1 00 00 00 01 00 07 00 00 00 06 00 01 00 00 00 07'
&nbsp;
  Method name:'foo'
  Descriptor:  ()I
    Field flags: 0x0400
    ACC_ABSTRACT
  Attributes:  0
</pre>

<p>Podobné je to i v&nbsp;pøípadì rozhraní <strong>Z</strong>, kde do¹lo jen
k&nbsp;malé zmìnì &ndash; nenajdeme zde konstruktor a navíc je metoda
<strong>int foo()</strong> nejenom abstraktní, ale i veøejná (public):</p>

<pre>
Magicka konstanta: cafebabe
Cislo verze:       50
Cislo podverze:    0
&nbsp;
Velikost const. poolu: 8 prvku
&nbsp;
Class/interface attributes: 0x0600
    ACC_ABSTRACT
    ACC_INTERFACE
&nbsp;
Class name is stored in constant pool #0
Class             7        Z
Super class name is stored in constant pool #1
Class             8        java/lang/Object
&nbsp;
Number of implemented interfaces: 0
&nbsp;
Number of declared fields: 0
&nbsp;
Number of declared methods: 1
  Method name:'foo'
  Descriptor:  ()I
    Field flags: 0x0401
    ACC_PUBLIC
    ACC_ABSTRACT
  Attributes:  0
</pre>

<p>Vytvoøení metody bez pøiøazeného atributu <strong>Code</strong> je
v&nbsp;pøípadì nástroje <i>Javassist</i> velmi jednoduché. Kostra metody se
vytvoøí konstruktorem <strong>new CtMethod()</strong>, kterému se pøedá
návratový typ metody, jméno metody, typy v¹ech parametrù metody i tøída, do ní¾
bude metoda vlo¾ena. Následnì se metodì pøiøadí pøíslu¹né pøíznaky, zde
konkrétnì pøíznak statické metody a pøíznak pro metodu veøejnou. Posledním
úkonem je vlo¾ení metody do její tøídy s&nbsp;vyu¾itím volání
<strong>CtClass.addMethod()</strong>:</p>

<pre>
<i>    /**</i>
<i>     * Vytvoreni bezparametricke staticke metody foo() vracejici int.</i>
<i>     * Instrukce tvorici telo metody jsou vytvoreny s vyuzitim tridy Bytecode.</i>
<i>     *</i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu</i>
<i>     */</i>
    private static void <strong>constructMethodFoo</strong>(CtClass generatedClass) throws CannotCompileException {
        CtClass returnType = CtClass.intType;
        CtClass[] parameterTypes = {};
&nbsp;
        <i>// u metody je nutne znat jeji jmeno, navratovou hodnotu i typy parametru</i>
        CtMethod fooMethod = new CtMethod(returnType, "foo", parameterTypes, generatedClass);
&nbsp;
        <i>// zmena modifikatoru</i>
        fooMethod.setModifiers(Modifier.STATIC | Modifier.PUBLIC);
&nbsp;
        <i>// telo metody muze byt slozeno z jednoho vyrazu</i>
        generatedClass.addMethod(fooMethod);
    }
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zdrojový kód demonstraèního pøíkladu <strong>ClassGenerationTest6</strong></h2>

<p>Metoda <strong>constructMethodFoo()</strong> popsaná <a
href="#k02">v&nbsp;pøedchozí kapitole</a> je souèástí dne¹ního prvního
demonstraèního pøíkladu nazvaného <strong>ClassGenerationTest6</strong>. Jedná
se o velmi jednoduchý pøíklad, který vlastnì oproti obìma pøíkladùm popsaným
minule nepøiná¹í nic nového. Pov¹imnìte si, ¾e vytváøená tøída není abstraktní
a navíc se v&nbsp;metodì <strong>main()</strong> volá i metoda
<strong>foo()</strong>, která v¹ak nemá ¾ádné tìlo. Tento fakt nástroj
<i>Javassist</i> implicitnì nekontroluje, tak¾e je mo¾né s&nbsp;jeho pomocí
vytvoøit i takové soubory <strong>.class</strong>, které by nebylo mo¾né
vygenerovat s&nbsp;vyu¾itím standardního pøekladaèe <strong>javac</strong>:</p>

<pre>
import java.io.IOException;
&nbsp;
import javassist.CannotCompileException;
import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtMethod;
import javassist.Modifier;
import javassist.NotFoundException;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Test moznosti nastroje Javassist - vygenerovani jednoduche tridy</i>
<i> * s metodou main a metodou foo(), ktera vsak neobsahuje zadny kod.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>ClassGenerationTest6</strong> {
&nbsp;
<i>    /**</i>
<i>     * Jmeno vygenerovane tridy.</i>
<i>     */</i>
    private static final String <strong>GENERATED_CLASS_NAME</strong> = "GeneratedClass6";
&nbsp;
<i>    /**</i>
<i>     * Zdrojovy kod metody main(), ktery bude nasledne zkompilovan</i>
<i>     * do bajtkodu a zakomponovan do vytvorene tridy.</i>
<i>     */</i>
    private static final String <strong>MAIN_METHOD_SOURCE_TEXT</strong> =
        "public static void main(String[] args)" +
        "{" +
        "    System.out.println(foo());" +
        "}";
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni metody main() z jejiho zdrojoveho kodu.</i>
<i>     * </i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu</i>
<i>     */</i>
    private static void <strong>addMethodMain</strong>(CtClass generatedClass) throws CannotCompileException {
        CtMethod methodMain = CtMethod.make(MAIN_METHOD_SOURCE_TEXT, generatedClass);
        generatedClass.addMethod(methodMain);
    }
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni bezparametricke staticke metody foo() vracejici int.</i>
<i>     * Instrukce tvorici telo metody jsou vytvoreny s vyuzitim tridy Bytecode.</i>
<i>     *</i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu</i>
<i>     */</i>
    private static void <strong>constructMethodFoo</strong>(CtClass generatedClass) throws CannotCompileException {
        CtClass returnType = CtClass.intType;
        CtClass[] parameterTypes = {};
&nbsp;
        <i>// u metody je nutne znat jeji jmeno, navratovou hodnotu i typy parametru</i>
        CtMethod fooMethod = new CtMethod(returnType, "foo", parameterTypes, generatedClass);
&nbsp;
        <i>// zmena modifikatoru</i>
        fooMethod.setModifiers(Modifier.STATIC | Modifier.PUBLIC);
&nbsp;
        <i>// telo metody muze byt slozeno z jednoho vyrazu</i>
        generatedClass.addMethod(fooMethod);
    }
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni tridy s metodou main().</i>
<i>     * </i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu metody main()</i>
<i>     * @throws IOException</i>
<i>     *             pokud dojde k chybe pri zapisu bajtkodu na disk</i>
<i>     * @throws NotFoundException</i>
<i>     *             pokud dojde k chybe pri zapisu bajtkodu na disk</i>
<i>     */</i>
    private static CtClass <strong>generateClass</strong>() throws CannotCompileException, NotFoundException, IOException {
        <i>// ziskat vychozi class pool</i>
        ClassPool pool = ClassPool.getDefault();
&nbsp;
        <i>// vytvoreni nove verejne tridy</i>
        CtClass generatedClass = pool.makeClass(GENERATED_CLASS_NAME);
&nbsp;
        <i>// konstrukce nove metody foo()</i>
        constructMethodFoo(generatedClass);
&nbsp;
        <i>// pridani metody do teto tridy</i>
        addMethodMain(generatedClass);
&nbsp;
        <i>// ulozeni bajtkodu na disk</i>
        generatedClass.writeFile();
&nbsp;
        return generatedClass;
    }
&nbsp;
<i>    /**</i>
<i>     * Spusteni generatoru tridy.</i>
<i>     *</i>
<i>     * @param args nevyuzito</i>
<i>     */</i>
    public static void <strong>main</strong>(String[] args) {
        System.out.println("class generation begin: " + GENERATED_CLASS_NAME);
        try {
            generateClass();
        }
        catch (CannotCompileException e) {
            e.printStackTrace();
        }
        catch (NotFoundException e) {
            e.printStackTrace();
        }
        catch (IOException e) {
            e.printStackTrace();
        }
        System.out.println("class generation end: " + GENERATED_CLASS_NAME);
    }
&nbsp;
}
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Výpis bajtkódu vygenerovaného demonstraèním pøíkladem <strong>ClassGenerationTest6</strong></h2>

<p>Podívejme se nyní na interní strukturu bajtkódu tøídy
<strong>GeneratedClass6</strong> vytvoøené dne¹ním prvním demonstraèním
pøíkladem <strong>ClassGenerationTest6</strong>. Interní strukturu vypí¹eme
jednodu¹e s&nbsp;vyu¾itím standardního nástroje <strong>javap</strong>:</p>

<pre>
javap -c -private GeneratedClass6
</pre>

<p>Získáme následující výstup, na nìm¾ je nejzajímavìj¹í (i kdy¾ oèekávanou)
informací fakt, ¾e metoda <strong>foo()</strong> skuteènì nemá ¾ádné tìlo,
tj.&nbsp;neobsahuje ¾ádné instrukce bajtkódu, na rozdíl od konstruktoru i
od metody <strong>main()</strong>:</p>

<pre>
Compiled from "GeneratedClass6.java"
public class GeneratedClass6 extends java.lang.Object{
&nbsp;
<strong>public static int foo();</strong>
&nbsp;
<strong>public static void main(java.lang.String[]);</strong>
  Code:
   0:   getstatic       #16; //Field java/lang/System.out:Ljava/io/PrintStream;
   3:   invokestatic    #18; //Method foo:()I
   6:   invokevirtual   #24; //Method java/io/PrintStream.println:(I)V
   9:   return
&nbsp;
<strong>public GeneratedClass6();</strong>
  Code:
   0:   aload_0
   1:   invokespecial   #29; //Method java/lang/Object."<init>":()V
   4:   return
&nbsp;
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Spu¹tìní tøídy vygenerované demonstraèním pøíkladem <strong>ClassGenerationTest6</strong></h2>

<p>Zajímavé bude zjistit, co se stane v&nbsp;pøípadì, ¾e se pokusíme o
inicializaci a následné &bdquo;spu¹tìní&ldquo; tøídy
<strong>GeneratedClass6</strong> vygenerované dne¹ním prvním demonstraèním
pøíkladem. Inicializaci a spu¹tìní této tøídy (pøesnìji øeèeno zavolání metody
<strong>public static void main(String[] args)</strong>) by mìl zajistit tento
pøíkaz:</p>

<pre>
java GeneratedClass6
</pre>

<p>Ve skuteènosti v¹ak virtuální stroj jazyka Java provádí pøi naèítání ka¾dé
tøídy pomìrnì velké mno¾ství kontrol, v&nbsp;jejich¾ prùbìhu se spou¹tí nìkolik
typù takzvaných verifikátorù naèítaného bajtkódu. Jedním ze základních zpùsobù
verifikace je i zji¹tìní, zda v¹echny neabstraktní a nenativní metody skuteènì
obsahují atribut s&nbsp;názvem <strong>Code</strong>. V&nbsp;pøípadì, ¾e tomu
tak není &ndash; co¾ je i pøípad na¹í tøídy <strong>GeneratedClass6</strong>
&ndash; neprojde daný bajtkód verifikaèním procesem. O tom se lze velmi snadno
pøesvìdèit, kdy¾ se podíváme na chybové hlá¹ení vypsané pøíkazem <strong>java
GeneratedClass6</strong>:</p>

<pre>
Exception in thread "main" java.lang.ClassFormatError: Absent Code attribute in method that is not native or abstract in class file GeneratedClass6
        at java.lang.ClassLoader.defineClass1(Native Method)
        at java.lang.ClassLoader.defineClass(ClassLoader.java:634)
        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
        at java.net.URLClassLoader.defineClass(URLClassLoader.java:277)
        at java.net.URLClassLoader.access$000(URLClassLoader.java:73)
        at java.net.URLClassLoader$1.run(URLClassLoader.java:212)
        at java.security.AccessController.doPrivileged(Native Method)
        at java.net.URLClassLoader.findClass(URLClassLoader.java:205)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:321)
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:294)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:266)
Could not find the main class: GeneratedClass6. Program will exit.
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Tvorba kódu metod na úrovni jednotlivých &bdquo;strojových&ldquo; instrukcí</h2>

<p>Nyní se ji¾ koneènì budeme zabývat dùle¾itìj¹í èástí dne¹ního èlánku &ndash;
zpùsobem vytvoøení kódù metod poskládaných z&nbsp;jednotlivých
&bdquo;strojových&ldquo; instrukcí bajtkódu. Uvidíme, ¾e se nemusí jednat o
pøíli¹ slo¾itou problematiku, proto¾e mnoho nízkoúrovòových operací za nás
doká¾e provést pøímo knihovna <i>Javassist</i>. Struènì lze zpùsob vytvoøení
tìla metod s&nbsp;pou¾itím instrukcí shrnout do nìkolika bodù:</p>

<ol>
<li>Vytvoøení obrazu metody, tj.&nbsp;objektu typu <strong>CtMethod</strong>  (ji¾ známe).</li>
<li>Nastavení pøíznakù metody pøes <strong>CtMethod.setModifiers()</strong> (takté¾ ji¾ známe).</li>
<li>Pøidání metody do pøíslu¹né tøídy s&nbsp;pomocí <strong>CtClass.addMethod()</strong>.</li>
<li>Získání objektu typu <strong>MethodInfo</strong> pøes <strong>CtMethod.getMethodInfo()</strong></li>
<li>Získání objektu typu <strong>ConstPool</strong> pøes <strong>MethodInfo.getConstPool()</strong></li>
<li>Vytvoøení objektu typu <strong>Bytecode</strong> (zde se pou¾ije instance tøídy <strong>ConstPool</strong>).</li>
<li>Pøidání libovolného poètu instrukcí do objektu typu <strong>Bytecode</strong>.</li>
<li>Pøevod bajtkódu na atribut pøes <strong>Bytecode.toCodeAttribute()</strong></li>
<li>Pøidání nového atributu k&nbsp;metodì s&nbsp;vyu¾itím <strong>MethodInfo.setCodeAttribute()</strong></li>
</ol>

<p>Prakticky v¹echny vý¹e zmínìné body (kromì bodu èíslo 7) jsou implementovány
ve dvojici u¾ivatelských metod nazvaných <strong>constructMethodFoo()</strong>
a <strong>constructMethodAdd()</strong>. První z&nbsp;tìchto metod slou¾í pro
konstrukci metody s&nbsp;hlavièkou <strong>public static int foo()</strong>,
druhá pak pro vytvoøení metody <strong>public static int add(int,
int)</strong>. Obì generované metody se tedy od sebe li¹í v&nbsp;jednom
dùle¾itém ohledu &ndash; poètu svých argumentù.</p>

<p>Následuje výpis zdrojového kódu u¾ivatelské metody
<strong>constructMethodFoo()</strong>:</p>

<pre>
<i>    /**</i>
<i>     * Vytvoreni bezparametricke staticke metody foo() vracejici int.</i>
<i>     * Instrukce tvorici telo metody jsou vytvoreny s vyuzitim tridy Bytecode.</i>
<i>     *</i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu</i>
<i>     */</i>
    private static void <strong>constructMethodFoo</strong>(CtClass generatedClass) throws CannotCompileException {
        CtClass returnType = CtClass.intType;
        CtClass[] parameterTypes = {};
&nbsp;
        <i>// u metody je nutne znat jeji jmeno, navratovou hodnotu i typy parametru</i>
        CtMethod fooMethod = new CtMethod(returnType, "foo", parameterTypes, generatedClass);
&nbsp;
        <i>// zmena modifikatoru</i>
        fooMethod.setModifiers(Modifier.STATIC | Modifier.PUBLIC);
&nbsp;
        <i>// telo metody muze byt slozeno z jednoho vyrazu</i>
        generatedClass.addMethod(fooMethod);
&nbsp;
        MethodInfo methodInfo = fooMethod.getMethodInfo();
&nbsp;
        ConstPool constPool = methodInfo.getConstPool();
        Bytecode bytecode = generateBytecodeForMethodFoo(constPool);
        CodeAttribute codeAttribute = bytecode.toCodeAttribute();
&nbsp;
        methodInfo.setCodeAttribute(codeAttribute);
    }
</pre>

<p>U¾ivatelská metoda <strong>constructMethodAdd()</strong> je prakticky stejná
s&nbsp;metodou <strong>constructMethodFoo()</strong>; jediná vìt¹í odli¹nost
spoèívá ve specifikaci argumentù vytváøené metody <strong>add()</strong>:</p>

<pre>
<i>    /**</i>
<i>     * Vytvoreni metody public static int add(int x, int y).</i>
<i>     *</i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu</i>
<i>     */</i>
    private static void <strong>constructMethodAdd</strong>(CtClass generatedClass) throws CannotCompileException {
        CtClass returnType = CtClass.intType;
        CtClass[] parameterTypes = {CtClass.intType, CtClass.intType};
&nbsp;
        <i>// u metody je nutne znat jeji jmeno, navratovou hodnotu i typy parametru</i>
        CtMethod addMethod = new CtMethod(returnType, "add", parameterTypes, generatedClass);
&nbsp;
        <i>// zmena modifikatoru</i>
        addMethod.setModifiers(Modifier.STATIC | Modifier.PUBLIC);
&nbsp;
        <i>// telo metody muze byt slozeno z jednoho vyrazu</i>
        generatedClass.addMethod(addMethod);
&nbsp;
        MethodInfo methodInfo = addMethod.getMethodInfo();
&nbsp;
        ConstPool constPool = methodInfo.getConstPool();
        Bytecode bytecode = generateBytecodeForMethodAdd(constPool);
        CodeAttribute codeAttribute = bytecode.toCodeAttribute();
&nbsp;
        methodInfo.setCodeAttribute(codeAttribute);
    }
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vygenerování metody <strong>int foo()</strong></h2>

<p>Zbývá nám programovì vytvoøit sekvenci instrukcí tvoøících tìla metod
<strong>int foo()</strong> a <strong>int add(int, int)</strong>. Jednodu¹¹í je
tìlo metody <strong>int foo()</strong>, proto¾e zde vy¾adujeme pouze to, aby
metoda jednodu¹e vrátila celoèíselnou konstantu 42. Tuto operaci lze realizovat
s&nbsp;vyu¾itím dvojice instrukcí. První instrukce ulo¾í zmínìnou celoèíselnou
konstantu 42 na lokální zásobník operandù vytvoøený pøi vstupu do metody a
následnì se tato hodnota vrátí s&nbsp;vyu¾itím instrukce
<strong>ireturn</strong>. Pro ulo¾ení celoèíselné konstanty na zásobník
operandù slou¾í instrukce <strong>bipush</strong>, <strong>sipush</strong>,
<strong>ldc</strong>, <strong>ldc_w</strong> a navíc i specializované instrukce
<strong>iconst_m1</strong>, <strong>iconst_0</strong>,
<strong>iconst_1</strong> a¾ <strong>iconst_5</strong>:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Data 1</th><th>Data 2</th><th>Typ na zásobníku</th><th>Popis</th></tr>
<tr><td>1</td><td>iconst_m1</td><td>0x02</td><td>&nbsp;</td><td>&nbsp;</td><td>int</td><td>ulo¾ení konstanty -1 na zásobník</td></tr>
<tr><td>2</td><td>iconst_0</td><td>0x03</td><td>&nbsp;</td><td>&nbsp;</td><td>int</td><td>ulo¾ení konstanty 0 na zásobník</td></tr>
<tr><td>3</td><td>iconst_1</td><td>0x04</td><td>&nbsp;</td><td>&nbsp;</td><td>int</td><td>ulo¾ení konstanty 1 na zásobník</td></tr>
<tr><td>4</td><td>iconst_2</td><td>0x05</td><td>&nbsp;</td><td>&nbsp;</td><td>int</td><td>ulo¾ení konstanty 2 na zásobník</td></tr>
<tr><td>5</td><td>iconst_3</td><td>0x06</td><td>&nbsp;</td><td>&nbsp;</td><td>int</td><td>ulo¾ení konstanty 3 na zásobník</td></tr>
<tr><td>6</td><td>iconst_4</td><td>0x07</td><td>&nbsp;</td><td>&nbsp;</td><td>int</td><td>ulo¾ení konstanty 4 na zásobník</td></tr>
<tr><td>7</td><td>iconst_5</td><td>0x08</td><td>&nbsp;</td><td>&nbsp;</td><td>int</td><td>ulo¾ení konstanty 5 na zásobník</td></tr>
<tr><td>8</td><td>bipush</td><td>0x10</td><td>byteconst</td><td>&nbsp;</td><td>int</td><td>ulo¾ení "byteconst" na zásobník s konverzí na int</td></tr>
<tr><td>9</td><td>sipush</td><td>0x11</td><td>hi-byte</td><td>lowbyte</td><td>int</td><td>ulo¾ení slova hibyte-lowbyte na zásobník s konverzí na int</td></tr>
<tr><td>10</td><td>ldc</td><td>0x12</td><td>index  </td><td>&nbsp; </td><td>string/ref/int/float</td><td>naète konstantu z&nbsp;constant poolu (mù¾e se jednat i o referenci)</td></tr>
<tr><td>11</td><td>ldc_w</td><td>0x13</td><td>hi-byte</td><td>lowbyte</td><td>string/ref/int/float</td><td>naète konstantu z&nbsp;constant poolu (index je ¹estnáctibitový)</td></tr>
</table>

<p>My se v¹ak vìt¹inou nemusíme starat o to, kterou z&nbsp;tìchto instrukcí
pou¾ít, proto¾e je mo¾né jednodu¹e vyu¾ít metodu
<strong>Bytecode.addIconst()</strong>, která ji¾ potøebnou optimalizaci provede
automaticky. V&nbsp;následující metodì si pov¹imnìte, ¾e pøi vytváøení instance
tøídy <strong>Bytecode</strong> je nutné ruènì uvést maximální velikost
zásobníku operandù i poèet lokálních promìnných:</p>

<pre>
<i>    /**</i>
<i>     * Vytvoreni bajtkodu predstavujiciho sekvenci instrukci pro metodu int</i>
<i>     * foo().</i>
<i>     * </i>
<i>     * @param constPool</i>
<i>     *            tabulka konstant pouzivana metodou</i>
<i>     * @return bajtkod predstavujici sekvenci instrukci pro metodu int foo()</i>
<i>     */</i>
    private static Bytecode <strong>generateBytecodeForMethodFoo</strong>(ConstPool constPool)
    {
        final int stackSize = 1;
        final int localVars = 0;
        Bytecode bytecode = new Bytecode(constPool, stackSize, localVars);
        <i>// bipush 42</i>
        bytecode.addIconst(42);
        <i>// ireturn</i>
        bytecode.addReturn(CtClass.intType);
        <i>// bajtkod bude obsahovat:</i>
        <i>// bipush 42</i>
        <i>// ireturn</i>
        return bytecode;
    }
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Vygenerování metody <strong>int add(int, int)</strong></h2>

<p>Vytvoøení bajtkódu metody <strong>int add(int, int)</strong> je ji¾ nepatrnì
slo¾itìj¹í. Tato metoda toti¾ musí na zásobník operandù ulo¾it hodnotu svých
dvou argumentù, provést souèet tìchto hodnot a výsledek operace vrátit
s&nbsp;vyu¾itím nám ji¾ známé instrukce <strong>ireturn</strong>. Oba
celoèíselné argumenty lze na zásobník operandù ulo¾it pomocí instrukcí
<strong>iload n</strong>, kde se za <strong>n</strong> doplní index pøíslu¹ného
argumentu. Vzhledem k&nbsp;tomu, ¾e se jedná o statickou metodu (do ní¾ se
nepøedává implicitní argument <strong>this</strong>), je ulo¾ení hodnoty
prvního argumentu na zásobník operandù zaji¹tìno instrukcí <strong>iload
0</strong> a ulo¾ení hodnoty argumentu druhého pak instrukcí <strong>iload
1</strong>. Následný souèet zajistí instrukce <strong>iadd</strong> (ta nemá
¾ádný parametr). Pov¹imnìte si toho, jak se zvìt¹ila kapacita zásobníku
operandù i poèet lokálních promìnných:</p>

<pre>
<i>    /**</i>
<i>     * Vytvoreni bajtkodu predstavujiciho sekvenci instrukci pro metodu int</i>
<i>     * add(int, int).</i>
<i>     * </i>
<i>     * @param constPool</i>
<i>     *            tabulka konstant pouzivana metodou</i>
<i>     * @return bajtkod predstavujici sekvenci instrukci pro metodu int add(int,</i>
<i>     *         int)</i>
<i>     */</i>
    private static Bytecode <strong>generateBytecodeForMethodAdd</strong>(ConstPool constPool)
    {
        final int stackSize = 2;
        final int localVars = 2;
        Bytecode bytecode = new Bytecode(constPool, stackSize, localVars);
        <i>// iload 0 nebo iload_0</i>
        bytecode.addIload(0);
        <i>// iload 1 nebo iload_1</i>
        bytecode.addIload(1);
        <i>// iadd</i>
        bytecode.add(Opcode.IADD);
        <i>// ireturn</i>
        bytecode.addReturn(CtClass.intType);
        return bytecode;
    }
</pre>

<p>Zajímavé je, ¾e nìkteré instrukce je nutné generovat pøímo s&nbsp;vyu¾itím
tøídy <strong>Opcode</strong>, pøesnìji øeèeno konstant deklarovaných
v&nbsp;této tøídì, zatímco pro vytvoøení jiných instrukcí existují pøíslu¹né
metody ve tøídì <strong>Bytecode</strong>. Tyto metody jsou implementovány
z&nbsp;toho dùvodu, ¾e na základì konkrétní hodnoty svého argumentu doká¾ou
vybrat tu instrukci bajtkódu, která je optimální z&nbsp;hlediska jeho celkové
velikosti, co¾ si uká¾eme <a href="#k10">v&nbsp;kapitole èíslo 10</a>. Nic nám
v¹ak nebrání pou¾ívat pøímo konstanty z&nbsp;tøídy <strong>Opcode</strong> ve
v¹ech pøípadech a zabránit tak v¹em optimalizacím.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Zdrojový kód demonstraèního pøíkladu <strong>ClassGenerationTest7</strong></h2>

<p>V¹echny ètyøi vý¹e popsané u¾ivatelské metody
<strong>constructMethodFoo()</strong>, <strong>constructMethodAdd()</strong>,
<strong>generateBytecodeForMethodFoo()</strong> a
<strong>generateBytecodeForMethodAdd()</strong> jsou souèástí dne¹ního druhého
demonstraèního pøíkladu nazvaného <strong>ClassGenerationTest7</strong>.
V&nbsp;tomto pøíkladu se provede dvojice operací. Nejdøíve se vytvoøí nová
tøída nazvaná <strong>GeneratedClass7</strong> s&nbsp;trojicí vygenerovaných
metod <strong>main()</strong>, <strong>foo()</strong> a <strong>add()</strong>
a následnì se struktura celé této tøídy vypí¹e na standardní výstup
s&nbsp;vyu¾itím stejného postupu, s&nbsp;jakým jsme se seznámili ji¾
v&nbsp;pøedchozí èásti tohoto seriálu &ndash; zpìtným pøeètením kódu ka¾dé
metody s&nbsp;následnou iterací pøes získaný kód a výpisem symbolických jmen
jednotlivých instrukcí. Následuje výpis celého zdrojového kódu tohoto
demonstraèního pøíkladu:</p>

<pre>
import java.io.IOException;
&nbsp;
import javassist.CannotCompileException;
import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtMethod;
import javassist.Modifier;
import javassist.NotFoundException;
import javassist.bytecode.BadBytecode;
import javassist.bytecode.Bytecode;
import javassist.bytecode.CodeAttribute;
import javassist.bytecode.CodeIterator;
import javassist.bytecode.ConstPool;
import javassist.bytecode.MethodInfo;
import javassist.bytecode.Mnemonic;
import javassist.bytecode.Opcode;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Test moznosti nastroje Javassist - vygenerovani jednoduche tridy</i>
<i> * s metodou main a nekolika dalsimi metodami.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>ClassGenerationTest7</strong> {
&nbsp;
<i>    /**</i>
<i>     * Jmeno vygenerovane tridy.</i>
<i>     */</i>
    private static final String <strong>GENERATED_CLASS_NAME</strong> = "GeneratedClass7";
&nbsp;
<i>    /**</i>
<i>     * Zdrojovy kod metody main(), ktery bude nasledne zkompilovan</i>
<i>     * do bajtkodu a zakomponovan do vytvorene tridy.</i>
<i>     */</i>
    private static final String <strong>MAIN_METHOD_SOURCE_TEXT</strong> =
        "public static void main(String[] args)" +
        "{" +
        "    System.out.println(foo());" +
        "    System.out.println(add(1,2));" +
        "}";
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni metody main() z jejiho zdrojoveho kodu.</i>
<i>     * </i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu</i>
<i>     */</i>
    private static void <strong>addMethodMain</strong>(CtClass generatedClass) throws CannotCompileException {
        CtMethod methodMain = CtMethod.make(MAIN_METHOD_SOURCE_TEXT, generatedClass);
        generatedClass.addMethod(methodMain);
    }
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni bezparametricke staticke metody foo() vracejici int.</i>
<i>     * Instrukce tvorici telo metody jsou vytvoreny s vyuzitim tridy Bytecode.</i>
<i>     *</i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu</i>
<i>     */</i>
    private static void <strong>constructMethodFoo</strong>(CtClass generatedClass) throws CannotCompileException {
        CtClass returnType = CtClass.intType;
        CtClass[] parameterTypes = {};
&nbsp;
        <i>// u metody je nutne znat jeji jmeno, navratovou hodnotu i typy parametru</i>
        CtMethod fooMethod = new CtMethod(returnType, "foo", parameterTypes, generatedClass);
&nbsp;
        <i>// zmena modifikatoru</i>
        fooMethod.setModifiers(Modifier.STATIC | Modifier.PUBLIC);
&nbsp;
        <i>// telo metody muze byt slozeno z jednoho vyrazu</i>
        generatedClass.addMethod(fooMethod);
&nbsp;
        MethodInfo methodInfo = fooMethod.getMethodInfo();
&nbsp;
        ConstPool constPool = methodInfo.getConstPool();
        Bytecode bytecode = generateBytecodeForMethodFoo(constPool);
        CodeAttribute codeAttribute = bytecode.toCodeAttribute();
&nbsp;
        methodInfo.setCodeAttribute(codeAttribute);
    }
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni metody public static int add(int x, int y).</i>
<i>     *</i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu</i>
<i>     */</i>
    private static void <strong>constructMethodAdd</strong>(CtClass generatedClass) throws CannotCompileException {
        CtClass returnType = CtClass.intType;
        CtClass[] parameterTypes = {CtClass.intType, CtClass.intType};
&nbsp;
        <i>// u metody je nutne znat jeji jmeno, navratovou hodnotu i typy parametru</i>
        CtMethod addMethod = new CtMethod(returnType, "add", parameterTypes, generatedClass);
&nbsp;
        <i>// zmena modifikatoru</i>
        addMethod.setModifiers(Modifier.STATIC | Modifier.PUBLIC);
&nbsp;
        <i>// telo metody muze byt slozeno z jednoho vyrazu</i>
        generatedClass.addMethod(addMethod);
&nbsp;
        MethodInfo methodInfo = addMethod.getMethodInfo();
&nbsp;
        ConstPool constPool = methodInfo.getConstPool();
        Bytecode bytecode = generateBytecodeForMethodAdd(constPool);
        CodeAttribute codeAttribute = bytecode.toCodeAttribute();
&nbsp;
        methodInfo.setCodeAttribute(codeAttribute);
    }
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni bajtkodu predstavujiciho sekvenci instrukci pro metodu int</i>
<i>     * foo().</i>
<i>     * </i>
<i>     * @param constPool</i>
<i>     *            tabulka konstant pouzivana metodou</i>
<i>     * @return bajtkod predstavujici sekvenci instrukci pro metodu int foo()</i>
<i>     */</i>
    private static Bytecode <strong>generateBytecodeForMethodFoo</strong>(ConstPool constPool)
    {
        final int stackSize = 1;
        final int localVars = 0;
        Bytecode bytecode = new Bytecode(constPool, stackSize, localVars);
        bytecode.addIconst(42);
        bytecode.addReturn(CtClass.intType);
        <i>// bajtkod bude obsahovat:</i>
        <i>// bipush 42</i>
        <i>// ireturn</i>
        return bytecode;
    }
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni bajtkodu predstavujiciho sekvenci instrukci pro metodu int</i>
<i>     * add(int, int).</i>
<i>     * </i>
<i>     * @param constPool</i>
<i>     *            tabulka konstant pouzivana metodou</i>
<i>     * @return bajtkod predstavujici sekvenci instrukci pro metodu int add(int,</i>
<i>     *         int)</i>
<i>     */</i>
    private static Bytecode <strong>generateBytecodeForMethodAdd</strong>(ConstPool constPool)
    {
        final int stackSize = 2;
        final int localVars = 2;
        Bytecode bytecode = new Bytecode(constPool, stackSize, localVars);
        bytecode.addIload(0);
        bytecode.addIload(1);
        bytecode.add(Opcode.IADD);
        bytecode.addReturn(CtClass.intType);
        return bytecode;
    }
&nbsp;
<i>    /**</i>
<i>     * Vytvoreni tridy s metodou main().</i>
<i>     * </i>
<i>     * @throws CannotCompileException</i>
<i>     *             vyhozena v pripade chyby ve zdrojovem kodu metody main()</i>
<i>     * @throws IOException</i>
<i>     *             pokud dojde k chybe pri zapisu bajtkodu na disk</i>
<i>     * @throws NotFoundException</i>
<i>     *             pokud dojde k chybe pri zapisu bajtkodu na disk</i>
<i>     */</i>
    private static CtClass <strong>generateClass</strong>() throws CannotCompileException, NotFoundException, IOException {
        <i>// ziskat vychozi class pool</i>
        ClassPool pool = ClassPool.getDefault();
&nbsp;
        <i>// vytvoreni nove verejne tridy</i>
        CtClass generatedClass = pool.makeClass(GENERATED_CLASS_NAME);
&nbsp;
        <i>// konstrukce nove metody foo()</i>
        constructMethodFoo(generatedClass);
&nbsp;
        <i>// konstrukce nove metody add()</i>
        constructMethodAdd(generatedClass);
&nbsp;
        <i>// pridani metody do teto tridy</i>
        addMethodMain(generatedClass);
&nbsp;
        <i>// ulozeni bajtkodu na disk</i>
        generatedClass.writeFile();
&nbsp;
        return generatedClass;
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis struktury vybrane metody.</i>
<i>     * </i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @param methodName</i>
<i>     *            jmeno metody, jejiz struktura se ma vypsat</i>
<i>     * @throws NotFoundException</i>
<i>     *             vyhozena, pokud metoda nebyla nalezena</i>
<i>     * @throws BadBytecode</i>
<i>     *             vyhozena, pokud se nalezne neplatna instrukce v bytekodu</i>
<i>     */</i>
    private static void <strong>printMethodStructure</strong>(CtClass generatedClass, String methodName) throws NotFoundException, BadBytecode {
        System.out.println("Method '" + methodName + "' structure:");
        CtMethod method = generatedClass.getDeclaredMethod(methodName);
        if (method == null) {
            System.out.println("   not found!");
            return;
        }
        MethodInfo methodInfo = method.getMethodInfo();
        System.out.println("    real name:    " + methodInfo.getName());
        System.out.println("    descriptor:   " + methodInfo.getDescriptor());
        System.out.println("    access flags: " + Modifier.toString(methodInfo.getAccessFlags()));
        System.out.println("    method body:");
        printMethodBody(methodInfo);
        System.out.println();
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis instrukci tvoricich telo vybrane metody.</i>
<i>     *</i>
<i>     * @throws NotFoundException</i>
<i>     *             vyhozena, pokud metoda nebyla nalezena</i>
<i>     * @throws BadBytecode</i>
<i>     *             vyhozena, pokud se nalezne neplatna instrukce v bytekodu</i>
<i>     */</i>
    private static void <strong>printMethodBody</strong>(MethodInfo methodInfo) throws BadBytecode {
        CodeAttribute ca = methodInfo.getCodeAttribute();
        CodeIterator iterator = ca.iterator();
        while (iterator.hasNext()) {
            int index = iterator.next();
            int opcode = iterator.byteAt(index);
            System.out.println("        " + Mnemonic.OPCODE[opcode]);
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis struktury vybranych metod z generovane tridy.</i>
<i>     * </i>
<i>     * @param generatedClass</i>
<i>     *            predstavuje vytvarenou tridu</i>
<i>     * @throws NotFoundException</i>
<i>     *             vyhozena, pokud metoda nebyla nalezena</i>
<i>     * @throws BadBytecode </i>
<i>     */</i>
    private static void <strong>printMethodStructures</strong>(CtClass generatedClass) throws NotFoundException, BadBytecode {
        printMethodStructure(generatedClass, "main");
        printMethodStructure(generatedClass, "foo");
        printMethodStructure(generatedClass, "add");
    }
&nbsp;
<i>    /**</i>
<i>     * Spusteni generatoru tridy.</i>
<i>     *</i>
<i>     * @param args nevyuzito</i>
<i>     */</i>
    public static void <strong>main</strong>(String[] args) {
        System.out.println("class generation begin: " + GENERATED_CLASS_NAME);
        try {
            CtClass generatedClass = generateClass();
            <i>// dulezite - generovana trida nesmi byt "zmrazena"</i>
            generatedClass.defrost();
            printMethodStructures(generatedClass);
        }
        catch (CannotCompileException e) {
            e.printStackTrace();
        }
        catch (NotFoundException e) {
            e.printStackTrace();
        }
        catch (IOException e) {
            e.printStackTrace();
        }
        catch (BadBytecode e) {
            e.printStackTrace();
        }
        System.out.println("class generation end: " + GENERATED_CLASS_NAME);
    }
&nbsp;
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Výpis bajtkódu vygenerovaného demonstraèním pøíkladem <strong>ClassGenerationTest7</strong></h2>

<p>Bude jistì zajímavé podívat se na strukturu bajtkódu tøídy
<strong>GeneratedClass7</strong> vygenerované dne¹ním druhým demonstraèním
pøíkladem <strong>ClassGenerationTest7</strong>. Pro výpis struktury bajtkódu
opìt vyu¾ijeme standardní nástroj <strong>javap</strong>:</p>

<pre>
javap -c -private GeneratedClass7
</pre>

<p>Z&nbsp;výpisu uvedeného pod tímto odstavcem je patrné, ¾e se skuteènì obì
metody <strong>foo()</strong> i <strong>add()</strong> vytvoøily zpùsobem,
který byl vy¾adován. Pov¹imnìte si v¹ak nìkterých &bdquo;optimalizací&ldquo;,
které nástroj <i>Javassist</i> provedl. První optimalizací je ulo¾ení konstanty
42 na zásobník operandù s&nbsp;vyu¾itím instrukce <strong>bipush</strong>,
tj.&nbsp;instrukce slou¾ící pro ulo¾ení bajtu, který je následnì expandován na
plnohodnotný typ <i>integer</i>. Druhá optimalizace spoèívá v&nbsp;pou¾ití
instrukcí <strong>iload_0</strong> a <strong>iload_1</strong> namísto obecných
instrukcí <strong>iload x</strong>. I v&nbsp;tomto pøípadì <i>Javassist</i>
zvolil takový typ instrukcí, které vedou k&nbsp;vytvoøení co nejkrat¹ího
bajtkódu, a to v&nbsp;souladu se specifikací virtuálního stroje Javy (podobné
základní optimalizace ostatnì provádí i samotný nástroj
<strong>javac</strong>):</p>

<pre>
Compiled from "GeneratedClass7.java"
public class <strong>GeneratedClass7</strong> extends java.lang.Object{
<strong>public static int foo();</strong>
  Code:
   0:	bipush	42
   2:	ireturn
&nbsp;
<strong>public static int add(int, int);</strong>
  Code:
   0:	iload_0
   1:	iload_1
   2:	iadd
   3:	ireturn
&nbsp;
<strong>public static void main(java.lang.String[]);</strong>
  Code:
   0:	getstatic	#19; //Field java/lang/System.out:Ljava/io/PrintStream;
   3:	invokestatic	#21; //Method foo:()I
   6:	invokevirtual	#27; //Method java/io/PrintStream.println:(I)V
   9:	getstatic	#19; //Field java/lang/System.out:Ljava/io/PrintStream;
   12:	iconst_1
   13:	iconst_2
   14:	invokestatic	#29; //Method add:(II)I
   17:	invokevirtual	#27; //Method java/io/PrintStream.println:(I)V
   20:	return
&nbsp;
<strong>public GeneratedClass7();</strong>
  Code:
   0:	aload_0
   1:	invokespecial	#33; //Method java/lang/Object."&lt;init&gt;":()V
   4:	return

}
</pre>

<p>Tento výpis si mù¾eme porovnat s&nbsp;analýzou bajtkódu provedenou
v&nbsp;samotném demonstraèním pøíkladu:</p>

<pre>
class generation begin: GeneratedClass7
<strong>Method 'main' structure:</strong>
    real name:    main
    descriptor:   ([Ljava/lang/String;)V
    access flags: public static
    method body:
        getstatic
        invokestatic
        invokevirtual
        getstatic
        iconst_1
        iconst_2
        invokestatic
        invokevirtual
        return
&nbsp;
<strong>Method 'foo' structure:</strong>
    real name:    foo
    descriptor:   ()I
    access flags: public static
    method body:
        bipush
        ireturn
&nbsp;
<strong>Method 'add' structure:</strong>
    real name:    add
    descriptor:   (II)I
    access flags: public static
    method body:
        iload_0
        iload_1
        iadd
        ireturn
&nbsp;
class generation end: GeneratedClass7
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Repositáø se zdrojovými kódy obou dne¹ních demonstraèních pøíkladù</h2>

<p>Následuje &ndash; v&nbsp;tomto seriálu ji¾ tradièní &ndash; kapitola
s&nbsp;odkazy na zdrojové kódy :-) Oba dnes popsané demonstraèní pøíklady jsou
spoleènì s&nbsp;dal¹ími pomocnými skripty ulo¾eny do Mercurial repositáøe
dostupného na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
V&nbsp;následující tabulce najdete odkazy na prozatím nejnovìj¹í verze tìchto
zdrojových kódù:</p>

<table>
<tr><th>#</th><th>Zdrojový soubor/skript</th><th>Umístìní souboru v&nbsp;repositáøi</th></tr>
<tr><td>1</td><td>ClassGenerationTest6.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/038eed7ad772/javassist/ClassGenerationTest6/ClassGenerationTest6.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/038eed7ad772/javassist/ClassGenerationTest6/ClassGenerationTest6.java</a></td></tr>
<tr><td>2</td><td>buildClassGenerator6.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/038eed7ad772/javassist/ClassGenerationTest6/buildClassGenerator6.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/038eed7ad772/javassist/ClassGenerationTest6/buildClassGenerator6.sh</a></td></tr>
<tr><td>3</td><td>runClassGenerator6.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/038eed7ad772/javassist/ClassGenerationTest6/runClassGenerator6.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/038eed7ad772/javassist/ClassGenerationTest6/runClassGenerator6.sh</a></td></tr>
<tr><td>4</td><td>runGeneratedClass6.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/038eed7ad772/javassist/ClassGenerationTest6/runGeneratedClass6.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/038eed7ad772/javassist/ClassGenerationTest6/runGeneratedClass6.sh</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>ClassGenerationTest7.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/038eed7ad772/javassist/ClassGenerationTest7/ClassGenerationTest7.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/038eed7ad772/javassist/ClassGenerationTest7/ClassGenerationTest7.java</a></td></tr>
<tr><td>6</td><td>buildClassGenerator7.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/038eed7ad772/javassist/ClassGenerationTest7/buildClassGenerator7.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/038eed7ad772/javassist/ClassGenerationTest7/buildClassGenerator7.sh</a></td></tr>
<tr><td>7</td><td>runClassGenerator7.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/038eed7ad772/javassist/ClassGenerationTest7/runClassGenerator7.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/038eed7ad772/javassist/ClassGenerationTest7/runClassGenerator7.sh</a></td></tr>
<tr><td>8</td><td>runGeneratedClass7.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/038eed7ad772/javassist/ClassGenerationTest7/runGeneratedClass7.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/038eed7ad772/javassist/ClassGenerationTest7/runGeneratedClass7.sh</a></td></tr>
</table>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (pøed verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

