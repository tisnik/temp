<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - vyu¾ití systémù událostí pøi sledování èinnosti JVM s vyu¾itím rozhraní JDI</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - vyu¾ití systémù událostí pøi sledování èinnosti JVM s vyu¾itím rozhraní JDI</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyku Java i o virtuálním stroji Javy si popí¹eme vyu¾ití systému událostí implementovaného v rozhraní JDI (Java Debugger Interface). Události &ndash; events &ndash; jsou toti¾ v JDI vyu¾ívány pøi zkoumání mnoha èinností provádìných v monitorovaném JVM.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - vyu¾ití systémù událostí pøi sledování èinnosti JVM s vyu¾itím rozhraní JDI</a></p>
<p><a href="#k02">2. Rozhraní deklarovaná v&nbsp;balíèku <strong>com.sun.jdi.event</strong></a></p>
<p><a href="#k03">3. Obecné události vzta¾ené k&nbsp;celému sledovanému virtuálnímu stroji</a></p>
<p><a href="#k04">4. Události, které vznikají v&nbsp;konkrétních vláknech a na známém místì v&nbsp;aplikaci</a></p>
<p><a href="#k05">5. Rozhraní deklarovaná v&nbsp;balièku <strong>com.sun.jdi.request</strong></a></p>
<p><a href="#k06">6. Získání objektu typu <strong>com.sun.jdi.request.EventRequestManager</strong></a></p>
<p><a href="#k07">7. Registrace nového typu události a povolení generování událostí</a></p>
<p><a href="#k08">8. Smyèka událostí implementovaná s&nbsp;vyu¾itím objektu typu <strong>com.sun.jdi.event.EventQueue</strong></a></p>
<p><a href="#k09">9. Zpracování jednotlivých typù událostí a reakce na ukonèení práce sledované JVM</a></p>
<p><a href="#k10">10. Kompletní zdrojový kód demonstraèního pøíkladu <strong>JDIEventRequestManager</strong></a></p>
<p><a href="#k11">11. Repositáø se zdrojovými kódy demonstraèního pøíkladu <strong>JDIEventRequestManager</strong> i podpùrných skriptù</a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - vyu¾ití systémù událostí pøi sledování èinnosti JVM s vyu¾itím rozhraní JDI</h2>

<p>Dne¹ní èást <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyku Java i o virtuálním stroji Javy</a> je vìnována velmi
dùle¾ité èásti rozhraní <i>JDI (Java Debugger Interface)</i>, bez ní¾ by nebylo
mo¾né efektivnì sledovat v¹echny èinnosti provádìné ve sledované (cílové) JVM.
Jedná se o systém událostí (<i>events</i>), pøièem¾ termínem
&bdquo;událost&ldquo; je zde my¹lena nìjaká zmìna stavu sledovaného virtuálního
stroje Javy, která se na stranì debuggeru projeví vznikem objektu typu
<strong>com.sun.jdi.event.Event</strong>. Debugger mù¾e tyto události postupnì
èíst z&nbsp;takzvané fronty událostí (<i>event queue</i>) a nìjakým zpùsobem na
tyto události reagovat. Postupné ètení událostí je vìt¹inou implementováno
formou programové smyèky (<i>event loop</i>), na jejím¾ zaèátku se pøeète nová
událost z&nbsp;fronty událostí a posléze se provede rozeskok na základì typu
pøeètené události. Debugger vìt¹inou musí reagovat minimálnì na událost typu
<strong>VMDeathEvent</strong>, která nastane ve chvíli, kdy je èinnost
sledovaného virtuálního stroje ukonèována.</p>

<p>Jaké události je vlastnì mo¾né zpracovávat? Jedná se napøíklad o následující
èinnosti probíhající ve sledovaném virtuálním stroji:</p>

<ol>
<li>Start sledovaného virtuálního stroje</li>
<li>Ukonèení práce sledovaného virtuálního stroje</li>
<li>Vytvoøení a spu¹tìní nového vlákna</li>
<li>Ukonèení èinnosti vlákna</li>
<li>Vstup vlákna do stavu èekání na jiné vlákno (<i>monitor</i>)</li>
<li>Vstup na breakpoint v&nbsp;nìjakém vláknì bì¾ícím ve sledované JVM</li>
<li>Ètení èi zápis do sledovaného atributu (<i>watchpoint</i>)</li>
<li>Provedení jednoho kroku pøi krokování programu ve sledované JVM</li>
<li>Vznik výjimky</li>
<li>Vstup do metody</li>
<li>Výskok z&nbsp;metody</li>
</ol>

<p>V&nbsp;následujících kapitolách si na demonstraèním pøíkladu uká¾eme, jakým
zpùsobem je mo¾né sestavit velmi jednoduchý debugger, který nejprve povolí
pøíjem nìkterých typù událostí a posléze tyto události bude zpracovávat ve
smyèce událostí (<i>event loop</i>).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Rozhraní deklarovaná v&nbsp;balíèku <strong>com.sun.jdi.event</strong></h2>

<p>Události, které mù¾e debugger vyu¾ívající rozhraní <i>JDI</i> zpracovávat, i
nìkteré dal¹í pomocné objektové typy, jsou souèástí balíèku
<strong>com.sun.jdi.event</strong>. Tento balíèek ve skuteènosti neobsahuje
¾ádné veøejné tøídy, ale pouze sadu rozhraní, která jsou internì implementována
zpùsobem, který mù¾e být závislý na verzi <i>JDI</i>. V&nbsp;první tabulce je
vypsáno pìt základních rozhraní, které mù¾eme v&nbsp;balíèku
<strong>com.sun.jdi.event</strong> nalézt a takté¾ vyu¾ít:</p>

<table>
<tr><th>#</th><th>Rozhraní</th><th>Popis</th></tr>
<tr><td>1</td><td>com.sun.jdi.event.EventQueue</td><td>Pøedstavuje frontu událostí, z&nbsp;ní¾ debugger postupnì mù¾e události vybírat a dále s&nbsp;nimi pracovat</td></tr>
<tr><td>2</td><td>com.sun.jdi.event.EventSet</td><td>Události nejsou z&nbsp;fronty vybírány jednotlivì, ale po skupinách sdru¾ených v&nbsp;objektech implementujících rozhraní EventSet</td></tr>
<tr><td>3</td><td>com.sun.jdi.event.EventIterator </td><td>Jednotlivými událostmi ulo¾enými v&nbsp;EventSet lze procházet pøes tento iterátor získaný metodou EventSet.eventIterator()</td></tr>
<tr><td>4</td><td>com.sun.jdi.event.Event</td><td>Obecná libovolná událost (pøedek dal¹ích rozhraní popsaných dále)</td></tr>
<tr><td>5</td><td>com.sun.jdi.event.LocatableEvent</td><td>Obecná událost vzta¾ená ke konkrétnímu vláknu a pozici v&nbsp;tomto vláknu</td></tr>
</table>

<p>Fronta událostí, tj.&nbsp;objekt typu
<strong>com.sun.jdi.event.EventQueue</strong> se získá velmi snadno ve chvíli,
kdy debugger vytvoøil objekt typu
<strong>com.sun.jdi.VirtualMachine</strong>:</p>

<pre>
EventQueue eventQueue = virtualMachine.eventQueue();
</pre>

<p>Dùle¾ité je, ¾e pro ka¾dý sledovaný virtuální stroj existuje pouze jedna
fronta událostí, tak¾e tato metoda vrátí v¾dy stejný objekt typu
<strong>EventQueue</strong>. To znamená, ¾e debugger vìt¹inou v¹echny události
zpracovává v&nbsp;jediné èásti kódu a nemù¾e napøíklad získat dvì fronty pro
rùzné typy událostí. Vzhledem k&nbsp;tomu, ¾e se ka¾dý typ události typicky
zpracovává zcela odli¹ným zpùsobem (napøíklad vstup na breakpoint versus
detekce vzniku výjimky), nevyhneme se pøi implementaci debuggeru nutnosti
implementovat nìjaký typ rozeskoku.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Obecné události vzta¾ené k&nbsp;celému sledovanému virtuálnímu stroji</h2>

<p><a href="#k03">V&nbsp;pøedchozí kapitole</a> bylo naznaèeno, ¾e se
jednotlivé události rozdìlují do dvou skupin. V&nbsp;první skupinì najdeme
události reprezentující zmìnu stavu cílové JVM jako celku a ve druhé skupinì
najdeme události, které jsou vzta¾eny ke konkrétnímu vláknu a ke konkrétnímu
místu kódu, kde k&nbsp;události do¹lo. Nejprve se budeme zabývat první skupinou
obecných událostí. Celkem existuje sedm typù tìchto událostí a v¹echny tyto
typy jsou vypsány v&nbsp;tabulce ní¾e:</p>

<table>
<tr><th>#</th><th>Rozhraní</th><th>Popis</th></tr>
<tr><td>1</td><td>com.sun.jdi.event.VMStartEvent</td><td>Tato událost vznikne tìsnì pøed okam¾ikem, kdy je spu¹tìno hlavní vlákno aplikace, tj.&nbsp;vìt¹inou metoda main().</td></tr>
<tr><td>2</td><td>com.sun.jdi.event.VMDeathEvent</td><td>Tato událost informuje debugger o tom, ¾e cílová JVM bude ukonèena. V&nbsp;závislosti na nastavení debuggeru mohou vzniknout dvì události tohoto typu.</td></tr>
<tr><td>3</td><td>com.sun.jdi.event.VMDisconnectEvent</td><td>Tato událost informuje debugger o odpojení sledované JVM pøi jejím ukonèování.</td></tr>
<tr><td>4</td><td>com.sun.jdi.event.ClassPrepareEvent</td><td>Událost vygenerovaná ve chvíli, kdy se v&nbsp;cílové JVM naèítá a pøipravuje tøída.</td></tr>
<tr><td>5</td><td>com.sun.jdi.event.ClassUnloadEvent</td><td>Událost vygenerovaná pøi odstraòování tøídy ze sledované JVM (pokud JVM podporuje odstraòování tøíd z&nbsp;pamìti)</td></tr>
<tr><td>6</td><td>com.sun.jdi.event.ThreadStartEvent</td><td>Událost informující debugger o tom, ¾e vzniklo vlákno, které se bude spou¹tìt (událost je vygenerována je¹tì pøed vlastním spu¹tìním vlákna)</td></tr>
<tr><td>7</td><td>com.sun.jdi.event.ThreadDeathEvent</td><td>Událost informující debugger o ukonèení nìjakého vlákna</td></tr>
</table>

<p>Poznámka: události typu <strong>VMStartEvent</strong>,
<strong>VMDeathEvent</strong> a <strong>VMDisconnectEvent</strong> jsou
generovány v¾dy, tj.&nbsp;i tehdy, pokud nebyly explicitnì povoleny!</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Události, které vznikají v&nbsp;konkrétních vláknech a na známém místì v&nbsp;aplikaci</h2>

<p>Následující události jsou, na rozdíl od událostí popsaných <a
href="#k03">vý¹e</a>, naopak vzta¾eny ke konkrétnímu vláknu a debugger mù¾e
díky tomu pøesnì zjistit, ve které èásti kódu k&nbsp;události do¹lo (co¾ je
mnohdy velmi dùle¾ité, napøíklad v&nbsp;pøípadì pou¾ití breakpointù):</p>

<table>
<tr><th>#</th><th>Rozhraní</th><th>Popis</th></tr>
<tr><td> 1</td><td>com.sun.jdi.event.BreakpointEvent</td><td>Vstup na breakpoint.</td></tr>
<tr><td> 2</td><td>com.sun.jdi.event.ExceptionEvent</td><td>Vznik výjimky (generováno v&nbsp;javovském kódu; pokud výjimka vznikne v&nbsp;nativním kódu, dojde ke vzniku události a¾ pozdìji)</td></tr>
<tr><td> 3</td><td>com.sun.jdi.event.MethodEntryEvent</td><td>Vstup do metody</td></tr>
<tr><td> 4</td><td>com.sun.jdi.event.MethodExitEvent</td><td>Výskok z&nbsp;metody (libovolný <strong>return</strong>, ne ov¹em pøi vzniku výjimky &ndash; tehdy se generuje jiná událost)</td></tr>
<tr><td> 5</td><td>com.sun.jdi.event.WatchpointEvent</td><td>Pøedek následující dvojice rozhraní:</td></tr>
<tr><td> 6</td><td>com.sun.jdi.event.AccessWatchpointEvent</td><td>Ètení hodnoty sledovaného atributu</td></tr>
<tr><td> 7</td><td>com.sun.jdi.event.ModificationWatchpointEvent</td>Zápis nové hodnoty do sledovaného atributu<td></td></tr>
<tr><td> 8</td><td>com.sun.jdi.event.MonitorContendedEnteredEvent</td><td>Vstup do re¾imu èekání s&nbsp;právì uvolnìným zámkem</td></tr>
<tr><td> 9</td><td>com.sun.jdi.event.MonitorContendedEnterEvent</td><td>Vstup do re¾imu èekání se zámkem, který ji¾ vlastní jiné vlákno</td></tr>
<tr><td>10</td><td>com.sun.jdi.event.MonitorWaitedEvent</td><td>Vlákno ukonèilo èekání na synchronizaci (i timeout èekání)</td></tr>
<tr><td>11</td><td>com.sun.jdi.event.MonitorWaitEvent</td><td>Vlákno vstoupí do re¾imu èekání na synchronizaci (<i>monitor</i>)</td></tr>
<tr><td>12</td><td>com.sun.jdi.event.StepEvent</td><td>Jeden krok pøi krokování aplikace</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. Rozhraní deklarovaná v&nbsp;balièku <strong>com.sun.jdi.request</strong></h2>

<p>Kromì rozhraní z&nbsp;balíèku <strong>com.sun.jdi.event</strong> je nutné
pøi práci s&nbsp;událostmi vyu¾ívat i nìkolik rozhraní, která najdeme
v&nbsp;balíèku <strong>com.sun.jdi.request</strong>. Aby toti¾ debugger mohl ve
smyèce událostí jednotlivé události získávat a dále zpracovávat, je nutné daný
typ události nejprve povolit, a to právì pøes zmínìná rozhraní. V&nbsp;balíèku
<strong>com.sun.jdi.request</strong> nalezneme pøedev¹ím tuto dvojici
rozhraní:</p>

<table>
<tr><th>#</th><th>Rozhraní</th><th>Popis</th></tr>
<tr><td>1</td><td>com.sun.jdi.request.EventRequest</td><td>Pøedek v¹ech rozhraní uvedených v&nbsp;dal¹í tabulce</td></tr>
<tr><td>2</td><td>com.sun.jdi.request.EventRequestManager</td><td>Objekt (existující pro sledovanou JVM jako singleton), pøes nìj¾ lze po¾adovat generování urèitého typu událostí</td></tr>
</table>

<p>Objekt typu <strong>com.sun.jdi.request.EventRequestManager</strong> lze
získat chvíli, kdy debugger vytvoøil objekt typu
<strong>com.sun.jdi.VirtualMachine</strong>:</p>

<pre>
EventRequestManager eventRequestManager = virtualMachine.eventRequestManager();
</pre>

<p>V&nbsp;pøedchozí tabulce bylo uvedeno, ¾e rozhraní
<strong>com.sun.jdi.request.EventRequest</strong> je pøedkem pro dal¹í
rozhraní. Ta jsou uvedena nyní. Ka¾dé rozhraní z&nbsp;této tabulky odpovídá
jednomu typu události:</p>

<table>
<tr><th>#</th><th>Rozhraní</th><th>Popis</th></tr>
<tr><td> 1</td><td>com.sun.jdi.request.BreakpointRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.BreakpointEvent</td></tr>
<tr><td> 2</td><td>com.sun.jdi.request.ClassPrepareRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.ClassPrepareEvent</td></tr>
<tr><td> 3</td><td>com.sun.jdi.request.ClassUnloadRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.ClassUnloadEvent</td></tr>
<tr><td> 4</td><td>com.sun.jdi.request.ExceptionRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.ExceptionEvent</td></tr>
<tr><td> 5</td><td>com.sun.jdi.request.MethodEntryRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.MethodEntryEvent</td></tr>
<tr><td> 6</td><td>com.sun.jdi.request.MethodExitRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.MethodExitEvent</td></tr>
<tr><td> 7</td><td>com.sun.jdi.request.MonitorContendedEnteredRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.MonitorContendedEnteredEvent</td></tr>
<tr><td> 8</td><td>com.sun.jdi.request.MonitorContendedEnterRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.MonitorContendedEnterEvent</td></tr>
<tr><td> 9</td><td>com.sun.jdi.request.MonitorWaitedRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.MonitorWaitedEvent</td></tr>
<tr><td>10</td><td>com.sun.jdi.request.MonitorWaitRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.MonitorWaitEvent</td></tr>
<tr><td>11</td><td>com.sun.jdi.request.StepRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.StepEvent</td></tr>
<tr><td>12</td><td>com.sun.jdi.request.ThreadDeathRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.ThreadDeathEvent</td></tr>
<tr><td>13</td><td>com.sun.jdi.request.ThreadStartRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.ThreadStartEvent</td></tr>
<tr><td>14</td><td>com.sun.jdi.request.VMDeathRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.VMDeathEvent</td></tr>
<tr><td>15</td><td>com.sun.jdi.request.WatchpointRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.WatchpointEvent</td></tr>
<tr><td>16</td><td>com.sun.jdi.request.AccessWatchpointRequest</td><td>®ádost o generování událostí typu com.sun.jdi.AccessWatchpointEvent</td></tr>
<tr><td>17</td><td>com.sun.jdi.request.ModificationWatchpointRequest</td><td>®ádost o generování událostí typu com.sun.jdi.event.ModificationWatchpointEvent</td></tr>
</table>

<p>Pov¹imnìte si absence &bdquo;povolovacích rozhraní&ldquo; pro události typu
<strong>VMStartEvent</strong> a <strong>VMDisconnectEvent</strong>. Tyto
události jsou generovány v¾dy, tudí¾ pro jejich øízení není zapotøebí ¾ádných
specializovaných objektù.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Získání objektu typu <strong>com.sun.jdi.request.EventRequestManager</strong></h2>

<p>Koneènì známe v¹echna rozhraní, s&nbsp;nimi¾ bude ná¹ demonstraèní debugger
pracovat, tak¾e si mù¾eme vysvìtlit, jak je mo¾né po pøipojení k&nbsp;cílové
JVM povolit nìkteré typy událostí a jak implementovat smyèku událostí. Dne¹ní
demonstraèní pøíklad je zalo¾en na pøíkladech vysvìtlených v&nbsp;pøedchozích
èástech tohoto seriálu, co¾ znamená, ¾e u¾ si nebudeme vysvìtlovat zpùsob
pøipojení k&nbsp;cílové JVM, ale hned si uvedeme zdrojový kód metody zavolaný
po pøipojení k&nbsp;této JVM. V&nbsp;této metodì je nejprve získán objekt typu
<strong>EventRequestManager</strong>, co¾ je pro danou instanci tøídy
<strong>virtualMachine</strong> singleton. Dále se s&nbsp;vyu¾itím tohoto
objektu zaregistruje a povolí události typu <strong>VMDeathEvent</strong> a
ihned poté se vstoupí do smyèky událostí:</p>

<pre>
<i>    /**</i>
<i>     * Ukazka pouziti EventRequestManageru.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>acquireAndUseEventRequestManager</strong>(VirtualMachine virtualMachine) {
        EventRequestManager eventRequestManager = virtualMachine.eventRequestManager();
        VMDeathRequest vmDeathRequest = registerVMDeathEvent(eventRequestManager);
<i>        // klasicka smycka pro zpracovani udalosti</i>
        eventLoop(virtualMachine, vmDeathRequest);
    }
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Registrace nového typu události a povolení generování událostí</h2>

<p>Vlastní ¾ádost o registraci události typu <strong>VMDeathEvent</strong> je
velmi jednoduchá, proto¾e vyu¾ijeme metodu
<strong>eventRequestManager.createVMDeathRequest()</strong> vracející objekt
typu <strong>VMDeathRequest</strong> (viz té¾ <a href="#k05">kapitola èíslo
pìt</a>). Jakmile tento objekt získáme, je dùle¾ité povolit generování
událostí:</p>

<pre>
<i>    /**</i>
<i>     * Registrace udalosti typu VMDeathEvent</i>
<i>     */</i>
    private static VMDeathRequest <strong>registerVMDeathEvent</strong>(EventRequestManager eventRequestManager) {
        VMDeathRequest vmDeathRequest = eventRequestManager.createVMDeathRequest();
<i>        // po registraci udalosti je jeste nutne tento typ udalosti povolit</i>
        vmDeathRequest.enable();
        return vmDeathRequest;
    }
</pre>

<p>V&nbsp;rozhraní <strong>com.sun.jdi.request.EventRequestManager</strong>
jsou pøedepsány tyto metody urèené pro získání objektù typu
<strong>com.sun.jdi.request.*Request</strong>:</p>

<table>
<tr><th>#</th><th>Návratový typ</th><th>Jméno metody</th><th>Parametry</th></tr>
<tr><td> 1</td><td>com.sun.jdi.request.AccessWatchpointRequest</td><td>createAccessWatchpointRequest</td><td>(Field field)</td></tr>
<tr><td> 2</td><td>com.sun.jdi.request.BreakpointRequest</td><td>createBreakpointRequest</td><td>(Location location)</td></tr>
<tr><td> 3</td><td>com.sun.jdi.request.ClassPrepareRequest</td><td>createClassPrepareRequest</td><td>()</td></tr>
<tr><td> 4</td><td>com.sun.jdi.request.ClassUnloadRequest</td><td>createClassUnloadRequest</td><td>()                                                                    </td></tr>
<tr><td> 5</td><td>com.sun.jdi.request.ExceptionRequest</td><td>createExceptionRequest</td><td>(ReferenceType refType, boolean notifyCaught, boolean notifyUncaught) </td></tr>
<tr><td> 6</td><td>com.sun.jdi.request.MethodEntryRequest</td><td>createMethodEntryRequest</td><td>()</td></tr>
<tr><td> 7</td><td>com.sun.jdi.request.MethodExitRequest</td><td>createMethodExitRequest</td><td>()</td></tr>
<tr><td> 8</td><td>com.sun.jdi.request.ModificationWatchpointRequest</td><td>createModificationWatchpointRequest</td><td>(Field field)</td></tr>
<tr><td> 9</td><td>com.sun.jdi.request.MonitorContendedEnteredRequest</td><td>createMonitorContendedEnteredRequest</td><td>()</td></tr>
<tr><td>10</td><td>com.sun.jdi.request.MonitorContendedEnterRequest</td><td>createMonitorContendedEnterRequest</td><td>()</td></tr>
<tr><td>11</td><td>com.sun.jdi.request.MonitorWaitedRequest</td><td>createMonitorWaitedRequest</td><td>()</td></tr>
<tr><td>12</td><td>com.sun.jdi.request.MonitorWaitRequest</td><td>createMonitorWaitRequest</td><td>()</td></tr>
<tr><td>13</td><td>com.sun.jdi.request.StepRequest</td><td>createStepRequest</td><td>(ThreadReference thread, int size, int depth)</td></tr>
<tr><td>14</td><td>com.sun.jdi.request.ThreadDeathRequest</td><td>createThreadDeathRequest</td><td>()</td></tr>
<tr><td>15</td><td>com.sun.jdi.request.ThreadStartRequest</td><td>createThreadStartRequest</td><td>()</td></tr>
<tr><td>16</td><td>com.sun.jdi.request.VMDeathRequest</td><td>createVMDeathRequest</td><td>()</td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Smyèka událostí implementovaná s&nbsp;vyu¾itím objektu typu <strong>com.sun.jdi.event.EventQueue</strong></h2>

<p>Vlastní implementace smyèky událostí je rozdìlená do dvou u¾ivatelských
metod. V&nbsp;metodì nazvané pøíznaènì <strong>eventLoop()</strong> se nejprve
získá objekt typu <strong>EventQueue</strong> a následnì se v&nbsp;programové
smyèce opakovanì volá u¾ivatelská metoda <strong>processEvents()</strong>
vracející pravdivostní hodnotu <strong>true</strong> v&nbsp;pøípadì, ¾e se má
pokraèovat ve ètení a zpracování dal¹ích událostí a hodnotu
<strong>false</strong> ve chvíli, kdy pøi¹la událost typu
<strong>VMDeathEvent</strong> a kdy má tedy debugger ukonèit svoji èinnost:</p>

<pre>
<i>    /**</i>
<i>     * Klasicka smycka pro postupne zpracovani udalosti.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     * @param vmDeathRequest objekt pro rizeni udalosti typu VMDeathEvent</i>
<i>     */</i>
    private static void <strong>eventLoop</strong>(VirtualMachine virtualMachine, VMDeathRequest vmDeathRequest) {
        EventQueue eventQueue = virtualMachine.eventQueue();
&nbsp;
<i>        // precist a zpracovat udalosti</i>
        while (processEvents(vmDeathRequest, eventQueue)) {
<i>            // jojo tady skutecne nic neni :)</i>
        }
    }
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Zpracování jednotlivých typù událostí a reakce na ukonèení práce sledované JVM</h2>

<p>Koneènì se dostáváme k&nbsp;nejdùle¾itìj¹í èásti celého debuggeru &ndash;
k&nbsp;vlastnímu ètení a zpracování jednotlivých událostí. Dùle¾ité je si
uvìdomit, ¾e události se z&nbsp;fronty událostí ètou po skupinách ulo¾ených
v&nbsp;objektu typu <strong>EventSet</strong> (co¾ jsme si ji¾ ostatnì øekli <a
href="#k02">ve druhé kapitole</a>). Vzhledem k&nbsp;tomu, ¾e
<strong>EventSet</strong> implementuje rozhraní <strong>Collection</strong> i
<strong>Iterable</strong>, je snadné iterovat pøes v¹echny události ulo¾ené
v&nbsp;tomto objektu. Ve vnitøní smyèce je proveden rozeskok v&nbsp;závislosti
na typu události, pøièem¾ pøedpokládáme, ¾e se budou èíst pouze události typu
<strong>VMStartEvent</strong> a <strong>VMDeathEvent</strong> (teoreticky té¾
<strong>VMDisconnectEvent</strong>, ov¹em my ukonèíme debugger døíve, ne¾ tato
událost nastane :-). Jakmile získáme první událost typu
<strong>VMDeathEvent</strong>, dojde k&nbsp;ukonèení debuggeru &ndash; ze
smyèky se vrátí hodnota <strong>false</strong>, která ve funkci
<strong>eventLoop</strong> (<a href="#k08">pøedchozí kapitola</a>) povede
k&nbsp;ukonèení:</p>

<pre>
<i>    /**</i>
<i>     * Precteni a zpracovani udalosti</i>
<i>     *</i>
<i>     * @param vmDeathRequest objekt pro rizeni udalosti typu VMDeathEvent</i>
<i>     * @param eventQueue fronta udalosti</i>
<i>     *</i>
<i>     * @return true pokud se ma pokracovat ve zpracovavani udalosti</i>
<i>     *         false pokud se ma sledovana VM ukoncit</i>
<i>     */</i>
    private static boolean <strong>processEvents</strong>(VMDeathRequest vmDeathRequest, EventQueue eventQueue) {
        EventSet eventSet;
        try {
<i>            // precist udalosti z fronty</i>
            eventSet = eventQueue.remove();
            int events = eventSet.size();
            System.out.println("Got " + events + " request" + (events &gt; 1 ? "s" : ""));
&nbsp;
<i>            // projit vsemi udalostmi</i>
            for (Event event : eventSet) {
                if (event instanceof VMStartEvent) {
                    System.out.println("VMStartEvent");
                }
                else if (event instanceof VMDeathEvent) {
                    System.out.println("VMDeathEvent");
<i>                    // zakazat dalsi generovani udalosti</i>
<i>                    // (u VMDeathEvent je ve skutecnosti vzdy posledni udalost poslana) </i>
                    vmDeathRequest.disable();
<i>                    // posleze se zavola shutdownVirtualMachine()</i>
                    return false;
                }
                else {
                    System.out.println("other event");
                }
            }
<i>            // znovu postit vsechna vlakna</i>
            eventSet.resume();
        }
        catch (InterruptedException e) {
            e.printStackTrace();
        }
        return true;
    }
</pre>

<p>Volání metody <strong>EventSet.resume()</strong> slou¾í ke znovuspu¹tìní
vláken, které jsou pøi vzniku události ve sledované JVM pozastaveny.
V&nbsp;na¹em pøípadì sice není volání této metody nutné, proto¾e zpracováváme
pouze události platné pro celou JVM, ale pro jistotu zde tato metoda je uvedena
(pøí¹tì bude navíc pøemístìna do bloku <strong>finally</strong>).</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Kompletní zdrojový kód demonstraèního pøíkladu <strong>JDIEventRequestManager</strong></h2>

<p>V&nbsp;pøedchozích kapitolách jsme si popsali dùle¾ité metody, které jsou
vyu¾ity v&nbsp;demonstraèním pøíkladu <strong>JDIEventRequestManager</strong>.
Kompletní zdrojový kód tohoto pøíkladu je vypsán pod tímto odstavcem, odkaz na
poslední verzi zdrojového kódu ulo¾eného do Mercurial repositáøe naleznete <a
href="#k11">v&nbsp;jedenácté kapitole</a>:</p>

<pre>
import java.io.IOException;
import java.util.List;
import java.util.Map;
&nbsp;
import com.sun.jdi.Bootstrap;
import com.sun.jdi.VirtualMachine;
import com.sun.jdi.VirtualMachineManager;
import com.sun.jdi.connect.AttachingConnector;
import com.sun.jdi.connect.Connector;
import com.sun.jdi.connect.IllegalConnectorArgumentsException;
import com.sun.jdi.event.Event;
import com.sun.jdi.event.EventQueue;
import com.sun.jdi.event.EventSet;
import com.sun.jdi.event.VMDeathEvent;
import com.sun.jdi.event.VMStartEvent;
import com.sun.jdi.request.EventRequestManager;
import com.sun.jdi.request.VMDeathRequest;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Pripojeni k bezicimu virtualnimu stroji Javy,</i>
<i> * ktery byl spusten s parametry:</i>
<i> * java -agentlib:jdwp=transport=dt_socket,server=y,address=6502,suspend=y Trida</i>
<i> *</i>
<i> * Po pripojeni se zaregistruje udalost zavolana ve chvili, kdy dojde k ukonceni</i>
<i> * behu sledovaneho virtualniho stroje Javy.</i>
<i> *</i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>JDIEventRequestManager</strong> {
&nbsp;
<i>    /**</i>
<i>     * Navratovy kod pouzity pri ukoncovani sledovane JVM.</i>
<i>     */</i>
    private static final int EXIT_VALUE = 0;
&nbsp;
<i>    /**</i>
<i>     * Jmeno konektoru, ktery pro pripojeni pouziva sockety.</i>
<i>     */</i>
    private static final String SOCKET_ATTACH_CONNECTOR_NAME = "com.sun.jdi.SocketAttach";
&nbsp;
<i>    /**</i>
<i>     * Vstupni metoda debuggeru.</i>
<i>     */</i>
    public static void <strong>main</strong>(String[] args) {
<i>        // ziskat (jedinou) instanci tridy VirtualMachineManager</i>
        VirtualMachineManager virtualMachineManager = Bootstrap.virtualMachineManager();
&nbsp;
<i>        // ziskat vsechny konektory pouzite pro pripojeni k bezici JVM</i>
        List&lt;AttachingConnector&gt; connectors = virtualMachineManager.attachingConnectors();
&nbsp;
<i>        // potrebujeme ziskat konektor pouzivajici pro pripojeni sockety</i>
        AttachingConnector connector = getSocketAttachConnector(connectors);
&nbsp;
        if (connector == null) {
            System.out.println("Socket connector is not available");
            return;
        }
&nbsp;
<i>        // jsme pripojeni ke sledovane JVM, takze lze provadet ladeni</i>
        debugVirtualMachineUsingSocket(connector);
    }
&nbsp;
<i>    /**</i>
<i>     * Ziskat konektor pouzivajici pro pripojeni sockety</i>
<i>     */</i>
    private static AttachingConnector <strong>getSocketAttachConnector</strong>(List&lt;AttachingConnector&gt; connectors) {
        for (AttachingConnector connector : connectors) {
            if (SOCKET_ATTACH_CONNECTOR_NAME.equals(connector.name())) {
                return connector;
            }
        }
<i>        // nenasli jsme zadny vhodny konektor</i>
        return null;
    }
&nbsp;
<i>    /**</i>
<i>     * Pripojeni k bezicimu virtualnimu stroji pres socket.</i>
<i>     * @throws InterruptedException </i>
<i>     */</i>
    private static void <strong>debugVirtualMachineUsingSocket</strong>(AttachingConnector connector) {
<i>        // nastaveni argumentu pouzivanych konektorem</i>
        Map&lt;String, Connector.Argument&gt; arguments = prepareConnectorArguments(connector);
&nbsp;
        try {
<i>            // pripojeni ke vzdalenemu bezicimu virtualnimu stroji Javy</i>
            VirtualMachine virtualMachine = connectToVirtualMachine(connector, arguments);
&nbsp;
<i>            // spustit sledovany virtualni stroj Javy</i>
            runVirtualMachine(virtualMachine);
&nbsp;
<i>            // ukazka pouziti EventRequestManageru</i>
            acquireAndUseEventRequestManager(virtualMachine);
&nbsp;
<i>            // ukonceni behu vzdaleneho virtualniho stroje</i>
            shutdownVirtualMachine(virtualMachine);
        }
        catch (IOException e) {
            e.printStackTrace();
        }
        catch (IllegalConnectorArgumentsException e) {
            e.printStackTrace();
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Nastaveni portu na cilove JVM, jenz debugger pouzije pro navazani spojeni.</i>
<i>     *</i>
<i>     * @param connector konektor pouzity pro pripojeni</i>
<i>     * @return mapa obsahujici parametry konektoru</i>
<i>     */</i>
    private static Map&lt;String, Connector.Argument&gt; <strong>prepareConnectorArguments</strong>(AttachingConnector connector) {
        Map&lt;String, Connector.Argument&gt; arguments = connector.defaultArguments();
        arguments.get("port").setValue("6502");
        return arguments;
    }
&nbsp;
<i>    /**</i>
<i>     * Pripojeni debuggeru ke sledovanemu virtualnimu stroji.</i>
<i>     *</i>
<i>     * @param connector konektor vyuzivajici pro spojeni sockety</i>
<i>     * @param arguments mapa obsahujici parametry pripojeni</i>
<i>     * @return sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     *</i>
<i>     * @throws IOException vyvolane v pripade, ze se pripojeni k JVM nepodari</i>
<i>     * @throws IllegalConnectorArgumentsException vyvolane v pripade spatne zadanych parametru</i>
<i>     */</i>
    private static VirtualMachine <strong>connectToVirtualMachine</strong>(AttachingConnector connector, Map&lt;String, Connector.Argument&gt; arguments)
        throws IOException, IllegalConnectorArgumentsException {
        System.out.println("Connecting to virtual machine");
        VirtualMachine virtualMachine = connector.attach(arguments);
        System.out.println("Connected");
        return virtualMachine;
    }
&nbsp;
<i>    /**</i>
<i>     * Spustit sledovany virtualni stroj</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>runVirtualMachine</strong>(VirtualMachine virtualMachine) {
        virtualMachine.resume();
    }
&nbsp;
<i>    /**</i>
<i>     * Ukonceni prace beziciho sledovaneho virtualniho stroje.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>shutdownVirtualMachine</strong>(VirtualMachine virtualMachine) {
        System.out.println("Calling exit");
        virtualMachine.exit(EXIT_VALUE);
    }
&nbsp;
<i>    /**</i>
<i>     * Ukazka pouziti EventRequestManageru.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     */</i>
    private static void <strong>acquireAndUseEventRequestManager</strong>(VirtualMachine virtualMachine) {
        EventRequestManager eventRequestManager = virtualMachine.eventRequestManager();
        VMDeathRequest vmDeathRequest = registerVMDeathEvent(eventRequestManager);
<i>        // klasicka smycka pro zpracovani udalosti</i>
        eventLoop(virtualMachine, vmDeathRequest);
    }
&nbsp;
<i>    /**</i>
<i>     * Registrace udalosti typu VMDeathEvent</i>
<i>     */</i>
    private static VMDeathRequest <strong>registerVMDeathEvent</strong>(EventRequestManager eventRequestManager) {
        VMDeathRequest vmDeathRequest = eventRequestManager.createVMDeathRequest();
<i>        // po registraci udalosti je jeste nutne tento typ udalosti povolit</i>
        vmDeathRequest.enable();
        return vmDeathRequest;
    }
&nbsp;
<i>    /**</i>
<i>     * Klasicka smycka pro postupne zpracovani udalosti.</i>
<i>     *</i>
<i>     * @param virtualMachine sledovany virtualni stroj, k nemuz je debugger vzdalene pripojen</i>
<i>     * @param vmDeathRequest objekt pro rizeni udalosti typu VMDeathEvent</i>
<i>     */</i>
    private static void <strong>eventLoop</strong>(VirtualMachine virtualMachine, VMDeathRequest vmDeathRequest) {
        EventQueue eventQueue = virtualMachine.eventQueue();
&nbsp;
<i>        // precist a zpracovat udalosti</i>
        while (processEvents(vmDeathRequest, eventQueue)) {
<i>            // jojo tady skutecne nic neni :)</i>
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Precteni a zpracovani udalosti</i>
<i>     *</i>
<i>     * @param vmDeathRequest objekt pro rizeni udalosti typu VMDeathEvent</i>
<i>     * @param eventQueue fronta udalosti</i>
<i>     *</i>
<i>     * @return true pokud se ma pokracovat ve zpracovavani udalosti</i>
<i>     *         false pokud se ma sledovana VM ukoncit</i>
<i>     */</i>
    private static boolean <strong>processEvents</strong>(VMDeathRequest vmDeathRequest, EventQueue eventQueue) {
        EventSet eventSet;
        try {
<i>            // precist udalosti z fronty</i>
            eventSet = eventQueue.remove();
            int events = eventSet.size();
            System.out.println("Got " + events + " request" + (events &gt; 1 ? "s" : ""));
&nbsp;
<i>            // projit vsemi udalostmi</i>
            for (Event event : eventSet) {
                if (event instanceof VMStartEvent) {
                    System.out.println("VMStartEvent");
                }
                else if (event instanceof VMDeathEvent) {
                    System.out.println("VMDeathEvent");
<i>                    // zakazat dalsi generovani udalosti</i>
<i>                    // (u VMDeathEvent je ve skutecnosti vzdy posledni udalost poslana) </i>
                    vmDeathRequest.disable();
<i>                    // posleze se zavola shutdownVirtualMachine()</i>
                    return false;
                }
                else {
                    System.out.println("other event");
                }
            }
<i>            // znovu postit vsechna vlakna</i>
            eventSet.resume();
        }
        catch (InterruptedException e) {
            e.printStackTrace();
        }
        return true;
    }
&nbsp;
}
</pre>

<p>Pokud je tento jednoduchý debugger pøipojen k&nbsp;virtuálnímu stroji Javy
s&nbsp;testovací aplikací <strong>Test4</strong>, mìl by na standardní výstup
vypsat následující text:</p>

<pre>
Connecting to virtual machine
Connected
Got 1 request:
    VMStartEvent
Got 2 requests:
    VMDeathEvent
Calling exit
</pre>

<p>Po výpisu tìchto zpráv by debugger mìl ukonèit jak cílovou JVM, tak i sám
sebe. Poznámka: testovací aplikace <strong>Test4</strong> èeká na stisk
libovolné klávesy, teprve poté dojde ke vzniku události typu
<strong>VMDeathEvent</strong>:</p>

<pre>
import java.io.IOException;
&nbsp;
public class <strong>Test4</strong> {
&nbsp;
    public static void <strong>main</strong>(String[] args) throws IOException {
        System.out.println("Press any key");
        System.in.read();
    }
&nbsp;
}
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Repositáø se zdrojovými kódy demonstraèního pøíkladu <strong>JDIEventRequestManager</strong> i podpùrných skriptù</h2>

<p>Zdrojové kódy dne¹ního demonstraèního pøíkladu
<strong>JDIEventRequestManager</strong>, testovací tøídy <strong>Test4</strong>
i skriptù pou¾itých pro pøeklad i spu¹tìní tohoto demonstraèního pøíkladu, byly
ulo¾eny (podobnì jako tomu bylo i v&nbsp;mnoha pøedchozích èástech tohoto
seriálu) do Mercurial repositáøe dostupného na adrese <a
href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/</a>.
Prozatím nejnovìj¹í verze v¹ech zmínìných zdrojových souborù a skriptù mù¾ete
najít na adresách:</p>

<table>
<tr><th>#</th><th>Zdrojový soubor/skript</th><th>Umístìní souboru v&nbsp;repositáøi</th></tr>
<tr><td>1</td><td>JDIEventRequestManager.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/b4d636160962/jdi/JDIEventRequestManager.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/b4d636160962/jdi/JDIEventRequestManager.java</a></td></tr>
<tr><td>2</td><td>compile_JDIEventRequestManager.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/b4d636160962/jdi/compile_JDIEventRequestManager.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/b4d636160962/jdi/compile_JDIEventRequestManager.sh</a></td></tr>
<tr><td>3</td><td>Test4.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/b4d636160962/jdi/Test4.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/b4d636160962/jdi/Test4.java</a></td></tr>
<tr><td>4</td><td>Test4.sh</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/b4d636160962/jdi/Test4.sh">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/b4d636160962/jdi/Test4.sh</a></td></tr>
</table>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>Class com.sun.jdi.Bootstrap<br />
<a href="http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/package-tree.html">http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/package-tree.html</a>
</li>

<li>Interface com.sun.jdi.VirtualMachine<br />
<a href="http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/VirtualMachine.html">http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/VirtualMachine.html</a>
</li>

<li>Interface com.sun.jdi.Field<br />
<a href="http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/Field.html">http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/Field.html</a>
</li>

<li>Interface com.sun.jdi.ReferenceType<br />
<a href="http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/ReferenceType.html">http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/ReferenceType.html</a>
</li>

<li>Interface com.sun.jdi.TypeComponent<br />
<a href="http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/TypeComponent.html">http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/TypeComponent.html</a>
</li>

<li>Interface com.sun.jdi.Accessible<br />
<a href="http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/Accessible.html">http://docs.oracle.com/javase/6/docs/jdk/api/jpda/jdi/com/sun/jdi/Accessible.html</a>
</li>

<li>Breakpoint (Wikipedia)<br />
<a href="http://cs.wikipedia.org/wiki/Breakpoint">http://cs.wikipedia.org/wiki/Breakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation<br />
<a href="http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html">http://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; SetBreakpoint<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#SetBreakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#SetBreakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; ClearBreakpoint<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#ClearBreakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#ClearBreakpoint</a>
</li>

<li>JVM Tool Interface Version 1.2 Documentation &ndash; Breakpoint (callback funkce)<br />
<a href="http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#Breakpoint">http://docs.oracle.com/javase/6/docs/platform/jvmti/jvmti.html#Breakpoint</a>
</li>

<li>The JVM Tool Interface (JVM TI): How VM Agents Work<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html">http://www.oracle.com/technetwork/articles/javase/jvm-ti-141370.html</a>
</li>

<li>Creating a Debugging and Profiling Agent with JVMTI<br />
<a href="http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html">http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html</a>
</li>

<li>JVM TI (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/JVM_TI">http://en.wikipedia.org/wiki/JVM_TI</a>
</li>

<li>IBM JVMTI extensions<br />
<a href="http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html">http://publib.boulder.ibm.com/infocenter/realtime/v2r0/index.jsp?topic=%2Fcom.ibm.softrt.doc%2Fdiag%2Ftools%2Fjvmti_extensions.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

