<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Clojure 10: kooperace mezi Clojure a Javou (pokraèování)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Clojure 10: kooperace mezi Clojure a Javou (pokraèování)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;dne¹ní èásti seriálu o programovacím jazyce Java i o virtuálním stroji Javy budeme pokraèovat v popisu komunikace mezi objekty a tøídami napsanými v Javì na jedné stranì a skripty, které jsou napsány v programovacím jazyce Clojure na stranì druhé. Takté¾ se budeme zabývat makrem import a vztahem mezi vestavìnými datovými typy Clojure a pøíslu¹nými typy v Javì.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Vytváøení javovských objektù s&nbsp;vyu¾itím speciální formy <strong>new</strong></a></p>
<p><a href="#k02">2. Volání metod s&nbsp;vyu¾itím speciální formy . (teèka)</a></p>
<p><a href="#k03">3. Syntaktický cukr, který lze pou¾ít pro volání nestatických metod</a></p>
<p><a href="#k04">4. Zkrácená forma volání statických (tøídních) metod a ètení tøídních atributù</a></p>
<p><a href="#k05">5. Syntaktický cukr vyu¾itelný pro volání konstruktorù</a></p>
<p><a href="#k06">6. Import tøíd pomocí makra <strong>import</strong></a></p>
<p><a href="#k07">7. Vztah mezi vestavìnými typy jazyka Clojure a standardními tøídami v&nbsp;Javì</a></p>
<p><a href="#k08">8. Strukturované vestavìné typy jazyka Clojure a k&nbsp;nim korespondující rozhraní</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Vytváøení javovských objektù s&nbsp;vyu¾itím speciální formy <strong>new</strong></h2>

<p>V&nbsp;závìreèné kapitole <a
href="http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/">pøedchozí
èásti</a> <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
virtuálním stroji Javy</a> jsme si øekli základní informace o zpùsobu práce
s&nbsp;javovskými tøídami pøímo v&nbsp;programovacím jazyce <i>Clojure</i>.
Pøipomeòme si, ¾e pro vytvoøení instance libovolné tøídy jazyka Java se pou¾ívá
speciální forma <strong>new</strong>, které se pøedá jméno tøídy následované
parametry, které jsou pøedány do konstruktoru tøídy. Jméno tøídy je symbol,
který není dále vyhodnocován a podle dynamicky zji¹tìného poètu a typu
parametrù se zavolá správný konstruktor, samozøejmì za pøedpokladu, ¾e je
vhodný konstruktor nalezen (tedy ¾e existuje a souèasnì má nastavena pøíslu¹ná
pøístupová práva). Návratovou hodnotou speciální formy <strong>new</strong> je
instance zvolené tøídy, kterou je samozøejmì mo¾né pøiøadit k&nbsp;nìjakému
jménu s&nbsp;vyu¾itím <strong>def</strong> atd.</p>

<p>Pro zopakování se podívejme na nìkolik jednoduchých demonstraèních pøíkladù,
v&nbsp;nich¾ se vyu¾ívá speciální forma <strong>new</strong>:</p>

<pre>
; zavolání konstruktoru new java.lang.Boolean("true")
<strong>user=&gt; (new Boolean "true")</strong>
true
&nbsp;
; zavolání konstruktoru new java.lang.Integer(42)
<strong>user=&gt; (new Integer 42)</strong>
42
&nbsp;
; zavolání konstruktoru new java.lang.Integer("42")
<strong>user=&gt; (new Integer "42")</strong>
42
&nbsp;
; konstruktor bez parametrù
<strong>user=&gt; (new java.util.Date)</strong>
#inst "2012-08-11T18:19:05.383-00:00"
&nbsp;
; vytvoøení prázdného seznamu s implicitnì nastavenou kapacitou
<strong>user=&gt; (new java.util.ArrayList)</strong>
#&lt;ArrayList []&gt;
&nbsp;
; vytvoøení prázdného seznamu s kapacitou nastavenou na 100 prvkù
<strong>user=&gt; (new java.util.ArrayList 100)</strong>
#&lt;ArrayList []&gt;
&nbsp;
; vytvoøení seznamu z ji¾ pøipravené kolekce
; (proè to funguje si vysvìtlíme dále)
<strong>user=&gt; (new java.util.ArrayList '(1 2 3 4))</strong>
#&lt;ArrayList [1, 2, 3, 4]&gt;
&nbsp;
; vytvoøení seznamu z ji¾ pøipravené kolekce
; (proè to funguje si vysvìtlíme dále)
<strong>user=&gt; (new java.util.ArrayList ["clojure" "a" "java"])</strong>
#&lt;ArrayList [clojure, a, java]&gt;
&nbsp;
user=&gt;
</pre>

<p>Ji¾ na pøíkladu vytvoøení instance tøídy <strong>ArrayList</strong> bylo
vidìt, ¾e <i>Clojure</i> skuteènì doká¾e vybrat správný konstruktor, co¾ v¹ak
obecnì nemusí být v¾dy úplnì jednoduché, proto¾e mezi datovými typy vyu¾ívanými
v&nbsp;jazyce Java a v&nbsp;jazyce Clojure neexistuje jednoznaèný vztah 1:1.
Parametry pøedávané konstruktoru samozøejmì mohou být libovolného typu, co¾ je
názornì vidìt na rùzných zpùsobech vytvoøení instance tøídy
<strong>java.awt.Rectange</strong> pou¾ívané v&nbsp;Javì napøíklad pøi práci
s&nbsp;GUI:</p>

<pre>
; ~ new Rectangle()
<strong>user=&gt; (new java.awt.Rectangle)</strong>
#&lt;Rectangle java.awt.Rectangle[x=0,y=0,width=0,height=0]&gt;
&nbsp;
; ~ new Rectangle(int width, int height)
<strong>user=&gt; (new java.awt.Rectangle 320 240)</strong>
#&lt;Rectangle java.awt.Rectangle[x=0,y=0,width=320,height=240]&gt;
&nbsp;
; ~ new Rectangle(int x, int y, int width, int height)
<strong>user=&gt; (new java.awt.Rectangle 10 10 320 240)</strong>
#&lt;Rectangle java.awt.Rectangle[x=10,y=10,width=320,height=240]&gt;
&nbsp;
; ~ new Rectangle(Point p)
<strong>user=&gt; (new java.awt.Rectangle (new java.awt.Point 100 100))</strong>
#&lt;Rectangle java.awt.Rectangle[x=100,y=100,width=0,height=0]&gt;
&nbsp;
; ~ Rectangle(Point p, Dimension d)
<strong>user=&gt; (new java.awt.Rectangle (new java.awt.Point 10 10) (new java.awt.Dimension 320 240))</strong>
#&lt;Rectangle java.awt.Rectangle[x=10,y=10,width=320,height=240]&gt;
&nbsp;
user=&gt;
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Volání metod s&nbsp;vyu¾itím speciální formy . (teèka)</h2>

<p>Minule jsme si takté¾ øekli, jakým zpùsobem je mo¾né volat metody objektù,
popø.&nbsp;statické metody tøíd. K&nbsp;tomuto úèelu se vyu¾ívá speciální forma
s&nbsp;názvem . (teèka). Prvním parametrem této speciální formy je buï název
tøídy, popø.&nbsp;instance objektu vrácená speciální formou
<strong>new</strong> popsanou <a href="#k01">v&nbsp;pøedchozí kapitole</a>.
V&nbsp;pøípadì, ¾e prvním parametrem speciální formy . (teèka) je název tøídy,
je zavolána její statická metoda (zcela stejným zpùsobem jako v&nbsp;Javì).
Pokud je prvním parametrem speciální formy . naopak instance objektu, zavolá se
buï statická metoda nebo metoda objektu &ndash; v&nbsp;tomto pøípadì se
instance objektu pøedá jako první neviditelný parametr volané metody (opìt
stejnì jako v&nbsp;Javì, kde se tento parametr skrývá pod klíèovým slovem
<strong>this</strong>). V&nbsp;Clojure se nijak nerozli¹uje mezi voláním metody
s&nbsp;pøístupem k&nbsp;atributu tøídy èi objektu, proto¾e se v&nbsp;obou
pøípadech vrací nìjaká hodnota. To znamená, ¾e pomocí speciální formy . mù¾eme
èíst i atributy, a» ji¾ atributy konstantní, tak i atributy nastavované bìhem
&bdquo;¾ivota&ldquo; objektu. Opìt si uka¾me nìkolik jednoduchých
demonstraèních pøíkladù:</p>

<p>Pøístup ke konstantním atributùm tøíd:</p>

<pre>
; maximální reprezentovatelná celoèíselná hodnota
; kterou lze ulo¾it do 32 bitù se znaménkem
<strong>user=&gt; (. Integer MAX_VALUE)</strong>
2147483647
&nbsp;
; minimální reprezentovatelná celoèíselná hodnota
; kterou lze ulo¾it do 32 bitù se znaménkem
<strong>user=&gt; (. Integer MIN_VALUE)</strong>
-2147483648
&nbsp;
; velikost integeru v bitech
<strong>user=&gt; (. Integer SIZE)</strong>
32
&nbsp;
; primitivní typ, který obaluje tøída Integer
<strong>user=&gt; (. Integer TYPE)</strong>
int
&nbsp;
; Ludolfovo èíslo (resp. hodnota, která se mu pøibli¾uje)
<strong>user=&gt; (. Math PI)</strong>
3.141592653589793
&nbsp;
; základ pøirozených logaritmù
<strong>user=&gt; (. Math E)</strong>
2.718281828459045
&nbsp;
; èíslo typu double, které se nejvíce pøibli¾uje k nule
<strong>user=&gt; (. Double MIN_VALUE)</strong>
4.9E-324
</pre>

<p>Volání statických metod:</p>

<pre>
; v obalových tøídách primitivních datových typù
; se nachází spousta u¾iteèných metod
<strong>user=&gt; (. Integer toBinaryString 42)</strong>
"101010"
&nbsp;
; jeden ze zpùsobù výpoètu konstanty Pí
<strong>user=&gt; (* 4 (. Math atan 1))</strong>
3.141592653589793
&nbsp;
; pøevod øetìzce na èíslo s vyu¾itím statické metody Integer.valueOf(String)
<strong>user=&gt; (. Integer valueOf "42")</strong>
42
&nbsp;
; zmìna èíselné soustavy
<strong>user=&gt; (. Integer valueOf "42" 5)</strong>
22
&nbsp;
; pøi volání metody samozøejmì mù¾e nastat výjimka
<strong>user=&gt; (. Integer valueOf "ja nejsem cislo")</strong>
NumberFormatException For input string: "ja nejsem cislo"
java.lang.NumberFormatException.forInputString (NumberFormatException.java:48)
</pre>

<p>Volání metod objektù (&bdquo;nestatických metod&ldquo;):</p>

<pre>
; vytvoøení øetìzce a zavolání metody String.length()
<strong>user=&gt; (. (new String "Hello world") length)</strong>
11
&nbsp;
; u¾iteèná je automatická konverze mezi øetìzci v Clojure a Javì
; (ve skuteènosti jde o stejný objektový typ)
<strong>user=&gt; (. "Hello world" length)</strong>
11
&nbsp;
; pøevod øetìzce na velká písmena (vytvoøí se NOVÝ øetìzec)
<strong>user=&gt; (. "Hello world" toUpperCase)</strong>
"HELLO WORLD"
&nbsp;
; zavolání metody String.substring()
<strong>user=&gt; (. "Hello world" substring 0 5)</strong>
"Hello"
&nbsp;
; v tomto pøípadì je v¹ak jednodu¹¹í pou¾ít vestavìnou
; funkci subs
<strong>user=&gt; (subs "Hello world" 0 5)</strong>
"Hello"
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Syntaktický cukr, který lze pou¾ít pro volání nestatických metod</h2>

<p>Vzhledem k&nbsp;tomu, ¾e tvùrci programovacího jazyka <i>Clojure</i>
pøedpokládali, ¾e se v&nbsp;programech budou velmi èasto pou¾ívat tøídy a
objekty programovacího jazyka Java, byl do <i>Clojure</i> kromì speciálních
forem <strong>new</strong> a <strong>.</strong> pøidán navíc i
&bdquo;syntaktický cukr&ldquo;, s&nbsp;jeho¾ vyu¾itím je mo¾né zapisovat
konstruktory a volání nestatických metod (èi ètení atributù objektù) ponìkud
èitelnìj¹ím zpùsobem, který si více podobá volání bì¾ných funkcí <i>Clojure</i>
(ve skuteènosti se v¹ak o plnohodnotné funkce nejedná &ndash; viz dal¹í
text).</p>

<p>Namísto volání:</p>

<pre>
(. objekt metoda parametry_metody)
</pre>

<p>je mo¾né alternativnì pou¾ít tento &bdquo;funkcionální&ldquo; zpùsob
zápisu:</p>

<pre>
(.metoda objekt parametry_metody)
</pre>

<p>Vý¹e uvedený alternativní zpùsob volání metod si uká¾eme na dal¹ích
demonstraèních pøíkladech:</p>

<pre>
; vytvoøení instance tøídy java.awt.Color
; a zavolání nestatické metody getRGB
<strong>user=&gt; (.getRGB (new java.awt.Color 0.0 1.0 0.5))</strong>
-16711808
&nbsp;
; odpovídá new String("Hello world").length()
<strong>user=&gt; (.length (new String "Hello world"))</strong>
11
&nbsp;
; efektivnìj¹í varianta
<strong>user=&gt; (.length "Hello world")</strong>
11
&nbsp;
; odpovídá new String("Hello world").toLowerCase()
<strong>user=&gt; (.toLowerCase "Hello world")</strong>
"hello world"
</pre>

<p>Podobnì je mo¾né èíst i nestatické atributy objektù:</p>

<pre>
<strong>user=&gt; (.x (new java.awt.Rectangle 10 10 320 240))</strong>
10
</pre>

<p>Nebo s&nbsp;vyu¾itím reference:</p>

<pre>
; vytvoøení objektu a navázání na symbol "rect"
<strong>user=&gt; (def rect (new java.awt.Rectangle 10 10 320 240))</strong>
#'user/rect
&nbsp;
; ètení atributu x
<strong>user=&gt; (.x rect)</strong>
10
&nbsp;
; ètení atributu y
<strong>user=&gt; (.y rect)</strong>
10
&nbsp;
; ètení atributu width
<strong>user=&gt; (.width rect)</strong>
320
&nbsp;
; ètení atributu height
<strong>user=&gt; (.height rect)</strong>
240
&nbsp;
user=&gt;
</pre>

<p>Vý¹e uvedený alternativní zpùsob zápisu volání metody/ètení atributu vlastnì
odpovídá tomu, jak se nestatické metody volají ve skuteènosti i v&nbsp;Javì
&ndash; v&nbsp;prvním (v&nbsp;Javì explicitnì neuvádìném) parametru je jim
toti¾ skuteènì pøedána reference na objekt, který je uvnitø metody pøístupný
pøes klíèové slovo <strong>this</strong>. Tento zpùsob zápisu ov¹em
<strong>nelze</strong> pou¾ít pro volání statických metod èi pro ètení
statických atributù. To v¹ak neznamená, ¾e by pro tento pøípad neexistoval
pøíslu¹ný &bdquo;syntaktický cukr&ldquo;. Ten je popsán <a
href="#k04">v&nbsp;následující kapitole</a>.</p>

<p>Pou¾ití alternativního zpùsobu zápisu si uká¾eme na fragmentu programu, jen¾
po svém spu¹tìní vytvoøí okno, nastaví jeho základní parametry a posléze ho
zobrazí na obrazovce. Tento fragment programu budeme v&nbsp;dal¹ích kapitolách
postupnì upravovat a vylep¹ovat:</p>

<pre>
; vytvoøení nového okna
<strong>(def frame</strong>
<strong>    (new javax.swing.JFrame))</strong>
&nbsp;
; nastavení výchozí velikosti okna
; (zde se vyu¾ívá syntaktický cukr pro zavolání metody objektu)
<strong>(.setSize frame 400 300)</strong>
&nbsp;
; nastavení akce zavolané pøi pokusu o zavøení okna
<strong>(.setDefaultCloseOperation frame</strong>
<strong>    (. javax.swing.WindowConstants DISPOSE_ON_CLOSE))</strong>
&nbsp;
; v¹e je pøipraveno, mù¾eme okno zobrazit
<strong>(.setVisible frame true)</strong>
</pre>

<p>Tento zpùsob zápisu programù je v&nbsp;podstatì imperativní, co¾ je v¹ak do
znaèné míry zapøíèinìno zpùsobem návrhu tøíd v&nbsp;balíèku
<strong>javax.swing</strong>, které k&nbsp;tomuto zápisu vedou.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Zkrácená forma volání statických (tøídních) metod a ètení tøídních atributù</h2>

<p>V&nbsp;programovacím jazyce <i>Clojure</i> mají vývojáøi k&nbsp;dispozici i
dal¹í typ &bdquo;syntaktického cukru&ldquo;, který lze vyu¾ít pøi volání
statických metod i pøi ètení atributù tøídy, tj.&nbsp;atributù, které jsou
spoleèné v¹em instancím tøídy a existují i v&nbsp;pøípadì, ¾e ¾ádná instance
je¹tì vùbec není vytvoøena. Zatímco v&nbsp;Javì i dal¹ích objektovì
orientovaných jazycích vìt¹inou není ze syntaktického pohledu rozdíl mezi
voláním statické a nestatické metody èi mezi ètením statického a nestatického
atributu, v&nbsp;<i>Clojure</i> je pou¾it jiný pøístup, který více odpovídá
lispovskému zpùsobu zápisu forem, v&nbsp;nìm¾ je v¾dy prvním prvkem seznamu
jméno funkce, speciální formy èi makra a za ním následují pøípadné parametry.
Statické atributy se v¾dy jednodu¹e vyhodnotí na svou hodnotu, proto se pøi
jejich zápisu pou¾ívá syntaxe <strong>(jméno_tøídy/jméno_atributu)</strong>,
pøièem¾ mezi jménem tøídy, lomítkem a jménem atributu nesmí být uvedeny ¾ádné
mezery, proto¾e zápis <strong>(jméno_tøídy / jméno_atributu)</strong> znamená
zavolání metody <strong>jméno_tøídy</strong> s&nbsp;dvojicí parametrù / a
<strong>jméno_atributu</strong>, tedy nìco zcela jiného:</p>

<pre>
; konstanta Pí
<strong>user=&gt; (Math/PI)</strong>
3.141592653589793
&nbsp;
; ¾ádné mezery!
<strong>user=&gt; (Math / PI)</strong>
RuntimeException Expecting var, but Math is mapped to class java.lang.Math
cloj ure.lang.Util.runtimeException (Util.java:170)
&nbsp;
; základ pøirozených logaritmù
<strong>user=&gt; (Math/E)</strong>
2.718281828459045
&nbsp;
; maximální reprezentovatelná celoèíselná hodnota
; kterou lze ulo¾it do 32 bitù se znaménkem
<strong>user=&gt; (Integer/MAX_VALUE)</strong>
2147483647
&nbsp;
; minimální reprezentovatelná celoèíselná hodnota
; kterou lze ulo¾it do 32 bitù se znaménkem
<strong>user=&gt; (Integer/MIN_VALUE)</strong>
-2147483648
&nbsp;
; velikost integeru v bitech
<strong>user=&gt; (Integer/SIZE)</strong>
32
&nbsp;
; primitivní typ, který obaluje tøída Integer
<strong>user=&gt; (Integer/TYPE)</strong>
int
&nbsp;
; èíslo typu double, které se nejvíce pøibli¾uje k nule
<strong>user=&gt; (Double/MIN_VALUE)</strong>
4.9E-324
&nbsp;
; konstanta reprezentující zelenou barvu
<strong>user=&gt; (java.awt.Color/GREEN)</strong>
#&lt;Color java.awt.Color[r=0,g=255,b=0]&gt;
</pre>

<p>Podobným zpùsobem je mo¾né zavolat libovolnou statickou metodu a pøípadnì jí
pøedat i nìjaké parametry:</p>

<pre>
; pøevod celého èísla na øetìzec
; s jeho binární reprezentací
<strong>user=&gt; (Integer/toBinaryString 42)</strong>
"101010"
&nbsp;
; pøevod øetìzce na èíslo
<strong>user=&gt; (Integer/parseInt "42")</strong>
42
&nbsp;
; jeden ze zpùsobù výpoètu konstanty Pí
<strong>user=&gt; (* 4 (Math/atan 1))</strong>
3.141592653589793
</pre>

<p>Demonstraèní pøíklad uvedený <a href="#k03">na konci pøedchozí kapitoly</a>
je mo¾né s&nbsp;vyu¾itím syntaktického cukru
<strong>(název_tøídy/název_atributu)</strong> zkrátit následujícím
zpùsobem:</p>

<pre>
; vytvoøení nového okna
<strong>(def frame</strong>
<strong>    (new javax.swing.JFrame))</strong>
&nbsp;
; nastavení výchozí velikosti okna
; (zde se vyu¾ívá syntaktický cukr pro zavolání metody objektu)
<strong>(.setSize frame 400 300)</strong>
&nbsp;
; nastavení akce zavolané pøi pokusu o zavøení okna
; (zde se vyu¾ívá syntaktický cukr pro pøístup ke statickému atributu)
<strong>(.setDefaultCloseOperation frame javax.swing.WindowConstants/DISPOSE_ON_CLOSE)</strong>
&nbsp;
; v¹e je pøipraveno, mù¾eme okno zobrazit
<strong>(.setVisible frame true)</strong>
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Syntaktický cukr vyu¾itelný pro volání konstruktorù</h2>

<p>Poslední formou &bdquo;syntaktického cukru&ldquo;, s&nbsp;ní¾ se
v&nbsp;dne¹ním èlánku seznámíme, je zjednodu¹ené volání konstruktorù javovských
tøíd. Ji¾ <a href="#k01">v&nbsp;první kapitole</a> jsme si øekli, ¾e
konstruktor se volá s&nbsp;vyu¾itím speciální formy <strong>new</strong>
následujícím zpùsobem:</p>

<pre>
; ~ new Rectangle()
<strong>user=&gt; (new java.awt.Rectangle)</strong>
#&lt;Rectangle java.awt.Rectangle[x=0,y=0,width=0,height=0]&gt;
&nbsp;
; ~ new Rectangle(int width, int height)
<strong>user=&gt; (new java.awt.Rectangle 320 240)</strong>
#&lt;Rectangle java.awt.Rectangle[x=0,y=0,width=320,height=240]&gt;
&nbsp;
; ~ new Rectangle(int x, int y, int width, int height)
<strong>user=&gt; (new java.awt.Rectangle 10 10 320 240)</strong>
#&lt;Rectangle java.awt.Rectangle[x=10,y=10,width=320,height=240]&gt;
&nbsp;
; ~ new Rectangle(Point p)
<strong>user=&gt; (new java.awt.Rectangle (new java.awt.Point 100 100))</strong>
#&lt;Rectangle java.awt.Rectangle[x=100,y=100,width=0,height=0]&gt;
&nbsp;
; ~ Rectangle(Point p, Dimension d)
<strong>user=&gt; (new java.awt.Rectangle (new java.awt.Point 10 10) (new java.awt.Dimension 320 240))</strong>
#&lt;Rectangle java.awt.Rectangle[x=10,y=10,width=320,height=240]&gt;
</pre>

<p>To je ov¹em pøíli¹ nepøehledné a proto je v&nbsp;programovacím jazyku
<i>Clojure</i> mo¾né namísto speciální formy <strong>new</strong> jednodu¹e
napsat jméno tøídy, za ním¾ je napsána teèka, a to bez jakéhokoli oddìlovaèe
(to je zde velmi dùle¾ité). Pokud má konstruktor nìjaké parametry, zapisují se
a¾ za touto teèkou, samozøejmì ji¾ normálnì oddìlené mezerou nebo jiným bílým
znakem (znaky). Z&nbsp;pohledu programátora je tedy konstruktor jen dal¹í
bì¾nou funkcí s&nbsp;tro¹ku neobvyklým jménem, jeho¾ návratovou hodnotou je
instance tøídy. Pøedchozích pìt konstruktorù by tedy bylo mo¾né zapsat i
následujícím zkráceným zpùsobem:</p>

<pre>
; ~ new Rectangle()
<strong>user=&gt; (java.awt.Rectangle.)</strong>
#&lt;Rectangle java.awt.Rectangle[x=0,y=0,width=0,height=0]&gt;
&nbsp;
; ~ new Rectangle(int width, int height)
<strong>user=&gt; (java.awt.Rectangle. 320 240)</strong>
#&lt;Rectangle java.awt.Rectangle[x=0,y=0,width=320,height=240]&gt;
&nbsp;
; ~ new Rectangle(int x, int y, int width, int height)
<strong>user=&gt; (java.awt.Rectangle. 10 10 320 240)</strong>
#&lt;Rectangle java.awt.Rectangle[x=10,y=10,width=320,height=240]&gt;
&nbsp;
; ~ new Rectangle(Point p)
<strong>user=&gt; (java.awt.Rectangle. (java.awt.Point. 100 100))</strong>
#&lt;Rectangle java.awt.Rectangle[x=100,y=100,width=0,height=0]&gt;
&nbsp;
; ~ Rectangle(Point p, Dimension d)
<strong>user=&gt; (java.awt.Rectangle. (java.awt.Point. 100 100) (java.awt.Dimension. 320 240))</strong>
#&lt;Rectangle java.awt.Rectangle[x=100,y=100,width=320,height=240]&gt;
&nbsp;
user=&gt;
</pre>

<p>Opìt se vra»me k&nbsp;fragmentu programu pro vytvoøení a zobrazení okna. Ten
lze pøepsat tak, aby vyu¾íval alternativní zpùsob zápisu konstruktorù
následujícím zpùsobem:</p>

<pre>
; vytvoøení nového okna
; (zde se pou¾ívá syntaktický cukr pro zavolání konstruktoru)
<strong>(def frame (javax.swing.JFrame.))</strong>
&nbsp;
; nastavení výchozí velikosti okna
; (zde se vyu¾ívá syntaktický cukr pro zavolání metody objektu)
<strong>(.setSize frame 400 300)</strong>
&nbsp;
; nastavení akce zavolané pøi pokusu o zavøení okna
; (zde se vyu¾ívá syntaktický cukr pro pøístup ke statickému atributu)
<strong>(.setDefaultCloseOperation frame javax.swing.WindowConstants/DISPOSE_ON_CLOSE)</strong>
&nbsp;
; v¹e je pøipraveno, mù¾eme okno zobrazit
<strong>(.setVisible frame true)</strong>
</pre>

<p>Popø. mù¾eme pøímo nastavit i titulek okna:</p>

<pre>
; vytvoøení nového okna s titulkem
<strong>(def frame (javax.swing.JFrame. "Testovací okno))</strong>
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Import tøíd pomocí makra <strong>import</strong></h2>

<p>Pøi ètení pøedchozích demonstraèních pøíkladù si pozorný ètenáø
pravdìpodobnì øíkal, ¾e zápis celého jména tøídy i s&nbsp;pøíslu¹ným jménem
balíèku je zbyteènì zdlouhavý a vede k&nbsp;tvorbì nepøehledných programù. To
je skuteènì pravda, ov¹em v&nbsp;<i>Clojure</i> je mo¾né pro zkrácení zápisu
pou¾ít makro <strong>import</strong>, které provede následující operaci:
vytvoøí nové mapování mezi prostým jménem tøídy a úplným jménem tøídy
(tj.&nbsp;jménem balíèku + názvem tøídy). Zdánlivì se jedná o stejnou funkci,
kterou provádí direktiva <strong>import</strong> v&nbsp;programovacím jazyku
Java, ov¹em zatímco v&nbsp;Javì je tato direktiva pou¾ita pouze v&nbsp;èase
pøekladu (nemá prakticky ¾ádný vliv na generovaný bajtkód), v&nbsp;pøípadì
jazyka <i>Clojure</i> je mapování provedeno v&nbsp;dobì bìhu programu. Makro
<strong>import</strong> se pou¾ívá následujícím zpùsobem:</p>

<pre>
<strong>(import (jméno_balíèku seznam_jmen_tøíd))</strong>
</pre>

<p>Pøíklad pou¾ití:</p>

<pre>
; import trojice tøíd z balíèku java.util
<strong>user=&gt; (import (java.util List ArrayList Date))</strong>
java.util.Date
&nbsp;
; zavolání bezparametrického konstruktoru tøídy Date
<strong>user=&gt; (Date.)</strong>
#inst "2012-08-12T10:29:42.262-00:00"
&nbsp;
user=&gt;
</pre>

<p>Potí¾e nastanou ve chvíli, kdy dojde k&nbsp;importu stejnì pojmenovaných
tøíd nále¾ejících do rùzných balíèkù. V&nbsp;tìchto pøípadech je nejjednodu¹¹í
prostì import jedné z&nbsp;tìchto tøíd neprovádìt a namísto toho uvádìt celý
název tøídy (co¾ ostatnì bude pøípadné ètenáøe zdrojového kódu ménì
matoucí):</p>

<pre>
; import tøídy java.util.Date
<strong>user=&gt; (import (java.util Date))</strong>
java.util.Date
&nbsp;
; pokus o import tøídy java.sql.Date
<strong>user=&gt; (import (java.sql Date))</strong>
IllegalStateException Date already refers to: class java.util.Date in namespace:
 user  clojure.lang.Namespace.referenceClass (Namespace.java:140)
&nbsp;
user=&gt;
</pre>

<p>Ji¾ naposledy se podívejme na ná¹ demonstraèní pøíklad s&nbsp;vytvoøením a
následným zobrazením okna. Jeho koneèná podoba mù¾e s&nbsp;vyu¾itím makra
<strong>import</strong> vypadat následovnì:</p>

<pre>
; import dvou tøíd JFrame a WindowConstants z balíèku javax.swing
<strong>user=&gt; (import (javax.swing JFrame WindowConstants))</strong>
javax.swing.WindowConstants
&nbsp;
; vytvoøení nového okna - nemusíme uvádìt plné jméno tøídy
; (zde se pou¾ívá syntaktický cukr pro zavolání konstruktoru)
<strong>user=&gt; (def frame (JFrame.))</strong>
#'user/frame
&nbsp;
; nastavení výchozí velikosti okna
; (zde se vyu¾ívá syntaktický cukr pro zavolání metody objektu)
<strong>user=&gt; (.setSize frame 400 300)</strong>
nil
&nbsp;
; nastavení akce zavolané pøi pokusu o zavøení okna
; - nemusíme uvádìt plné jméno tøídy s konstantou DISPOSE_ON_CLOSE
; (zde se vyu¾ívá syntaktický cukr pro pøístup ke statickému atributu)
<strong>user=&gt; (.setDefaultCloseOperation frame WindowConstants/DISPOSE_ON_CLOSE)</strong>
nil
&nbsp;
; v¹e je pøipraveno, mù¾eme okno zobrazit
<strong>user=&gt; (.setVisible frame true)</strong>
nil
&nbsp;
user=&gt;
</pre>

<p>Stále se jedná o a¾ nepøíjemnì imperativní kód, tomu se v¹ak pøi práci
s&nbsp;GUI, které je &bdquo;stavové&ldquo;, pravdìpodobnì jen tì¾ko ubráníme
:-) Ostatnì není bez zajímavosti, ¾e právì v&nbsp;GUI lze asi nejlépe vyu¾ít
principy OOP, na rozdíl od nìkterých jiných oblastí informatiky.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vztah mezi vestavìnými typy jazyka Clojure a standardními tøídami v&nbsp;Javì</h2>

<p>Pøi komunikaci mezi èástí programu napsanou v&nbsp;programovacím jazyku Java
a jinou èástí naprogramovanou s&nbsp;vyu¾itím Clojure je samozøejmì nutné mezi
obìma èástmi pøedávat nìjaká data (typicky se jedná o parametry volaných
metod). Problém nastává v&nbsp;tom, jakého typu tato data mají být. Zdaleka se
nejedná jen o problém programovacího jazyka Clojure, ale jakéhokoli jiného
dynamicky typovaného jazyka, který má komunikovat s&nbsp;jazykem staticky
typovaným. Pro pøíklad nemusíme chodit daleko, staèí se podívat na rùzné
chování standardního interpretru jazyka <i>JavaScript</i>, který je souèástí
JDK6 i JDK7.</p>

<p>Asi nejjednodu¹¹í je pøevod primitivních datových typù, resp.&nbsp;instancí
jejich obalových tøíd, do skriptù psaných v&nbsp;<i>Clojure</i>. Základní
mapování mezi jednoduchými typy Clojure a pøíslu¹nou tøídou èi rozhraním
v&nbsp;Javì je vypsáno v&nbsp;následující tabulce:</p>

<table>
<tr><th>Typ      </th><th>Literál v&nbsp;Clojure</th><th>Java tøída/rozhraní</th></tr>
<tr><td>Boolean  </td><td>true</td><td>java.lang.Boolean</td></tr>
<tr><td>Number   </td><td>42</td><td>java.lang.Number</td></tr>
<tr><td>String   </td><td>"string"</td><td>java.lang.String</td></tr>
<tr><td>Character</td><td>\x</td><td>java.lang.Character</td></tr>
<tr><td>Keyword  </td><td>:klíè</td><td>clojure.lang.Keyword</td></tr>
</table>

<p>V&nbsp;praxi samozøejmì není mo¾né vytvoøit pøímo instanci rozhraní
<strong>java.lang.Number</strong>, ale musí se pou¾ít instance nìkteré
konkrétní obalové tøídy, napøíklad <strong>java.lang.Long</strong> èi
<strong>java.lang.Double</strong>. Vyzkou¹ejme si tedy, jak se jednoduché
datové typy pøevádí z&nbsp;Clojure do Javy &ndash; nesmíme toti¾ zapomenout na
to, ¾e skripty v&nbsp;Clojure jsou kompilovány do zcela bì¾ného javovského
bajtkódu, tudí¾ se v&nbsp;nìm musí pou¾ívat buï primitivní datové typy Javy
nebo vhodné objektové typy, popø.&nbsp;obalové tøídy nad primitivními datovými
typy.</p>

<p>U neèíselných datových typù je situace jednoduchá:</p>

<pre>
<strong>user=&gt; (.getClass true)</strong>
java.lang.Boolean
&nbsp;
<strong>user=&gt; (.getClass "Hello world!")</strong>
java.lang.String
&nbsp;
<strong>user=&gt; (.getClass \x)</strong>
java.lang.Character
&nbsp;
<strong>user=&gt; (.getClass :klicove-slovo)</strong>
clojure.lang.Keyword
</pre>

<p>V&nbsp;pøípadì èíselných datových typù se vìt¹inou (ale ne v¾dy) u celých
èísel pou¾ívá primitivní datový typ <strong>long</strong> s&nbsp;jeho obalovou
tøídou <strong>java.lang.Long</strong> a u èísel s&nbsp;desetinnou teèkou pak
primitivní datový typ <strong>double</strong> s&nbsp;obalovou tøídou
<strong>java.lang.Double</strong>. Ov¹em u zlomkù je situace odli¹ná, podobnì
jako u hodnoty typu <strong>java.lang.BigDecimal</strong> apod.:</p>

<pre>
<strong>user=&gt; (.getClass 42)</strong>
java.lang.Long
&nbsp;
<strong>user=&gt; (.getClass 16RFF)</strong>
java.lang.Long
&nbsp;
<strong>user=&gt; (.getClass 42.0)</strong>
java.lang.Double
&nbsp;
<strong>user=&gt; (.getClass 1/2)</strong>
clojure.lang.Ratio
&nbsp;
<strong>user=&gt; (.getClass 42M)</strong>
java.math.BigDecimal
</pre>

<p>V&nbsp;praxi to díky automatickému boxingu a unboxingu znamená, ¾e mù¾eme
velmi snadno zavolat jakoukoli javovskou metodu, která jako svùj parametr èi
parametry oèekává èíselnou hodnotu a v&nbsp;pøípadì hodnot typu
<strong>double</strong> lze pracovat i s&nbsp;nekoneènem èi speciální hodnotou
NaN:</p>

<pre>
<strong>user=&gt; (Math/log 0)</strong>
-Infinity
&nbsp;
<strong>user=&gt; (Math/log 10)</strong>
2.302585092994046
&nbsp;
<strong>user=&gt; (Math/exp 100)</strong>
2.6881171418161356E43
&nbsp;
<strong>user=&gt; (Math/exp 1000)</strong>
Infinity
&nbsp;
<strong>user=&gt; (Math/sin (Math/exp 1000))</strong>
NaN
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Strukturované vestavìné typy jazyka Clojure a k&nbsp;nim korespondující rozhraní</h2>

<p>Vzhledem k&nbsp;tomu, ¾e v&nbsp;<i>Clojure</i> se vìt¹ina slo¾itìj¹ích
datových struktur vytváøí s&nbsp;vyu¾itím seznamù, vektorù, map a mno¾in, bude
zajímavé zjistit, jakým zpùsobem se tyto datové typy mapují na rozhraní
v&nbsp;Javì. Pravdìpodobnì (a to zcela správnì) oèekáváte, ¾e seznamy, vektory
a mno¾iny budou implementovat rozhraní <strong>java.util.Collection</strong> a
v&nbsp;pøípadì map bude implementováno rozhraní <strong>java.util.Map</strong>.
Navíc v¹echny ètyøi zmínìné datové typy implementují i rozhraní
<strong>java.util.Iterable</strong> a v&nbsp;pøípadì vektorù i
<strong>java.util.Comparable</strong>:</p>

<table>
<tr><th>Rozhraní</th><th>seznam</th><th>vektor</th><th>mapa</th><th>mno¾ina</th></tr>
<tr><td>java.util.Collection  </td><td>ano</td><td>ano</td><td>ne </td><td>ano</td></tr>
<tr><td>java.util.List        </td><td>ano</td><td>ano</td><td>ne </td><td>ne </td></tr>
<tr><td>java.util.Map         </td><td>ne </td><td>ne </td><td>ano</td><td>ne </td></tr>
<tr><td>java.util.Set         </td><td>ne </td><td>ne </td><td>ne </td><td>ano</td></tr>
<tr><td>java.util.RandomAccess</td><td>ne </td><td>ano</td><td>ne </td><td>ne </td></tr>
<tr><td>java.lang.Iterable    </td><td>ano</td><td>ano</td><td>ano</td><td>ano</td></tr>
<tr><td>java.lang.Comparable  </td><td>ne </td><td>ano</td><td>ne </td><td>ne </td></tr>
</table>

<p>Co to v¹ak znamená v&nbsp;praxi? Podívejme se na následující pøíklad,
v&nbsp;nìm¾ je vytvoøena instance tøídy <strong>java.util.TreeSet</strong>,
jejímu¾ konstruktoru (teèka na konci názvu tøídy) je pøedán vektor, tedy
nativní strukturovaný datový typ jazyka <i>Clojure</i>. Následnì je do mno¾iny
pøidán dal¹í vektor:</p>

<pre>
<strong>user=&gt; (def mnozina (java.util.TreeSet. [10 20 1 2 0]))</strong>
#'user/mnozina
&nbsp;
<strong>user=&gt; (.addAll mnozina [0 1 2 3 4])</strong>
true
&nbsp;
<strong>user=&gt; (.toString mnozina)</strong>
"[0, 1, 2, 3, 4, 10, 20]"
&nbsp;
user=&gt;
</pre>

<p>Vý¹e uvedený pøíklad byl naprosto korektní, proto¾e ve tøídì
<strong>java.util.TreeSet</strong> existuje jak konstruktor:</p>

<pre>
TreeSet(Collection&lt;? extends E&gt; c)
</pre>

<p>tak i metoda:</p>

<pre>
addAll(Collection&lt;? extends E&gt; c)
</pre>

<p>Generikami se v&nbsp;tomto pøípadì vùbec nemusíme zabývat, proto¾e informace
o nich se stejnì v&nbsp;bajtkódu nepou¾ívají a programy v&nbsp;<i>Clojure</i>
jsou pøekládány do bajtkódu, tudí¾ se volá konstruktor:</p>

<pre>
TreeSet(Collection c)
</pre>

<p>a metoda:</p>

<pre>
addAdd(Collection c)
</pre>

<p>Podívejme se nyní na slo¾itìj¹í pøíklad, kde je vyu¾ita funkce
<strong>range</strong> vracející takté¾ kolekci:</p>

<pre>
; konstrukce mno¾iny + její inicializace
<strong>user=&gt; (def mnozina (java.util.HashSet. (range 1 10)))</strong>
#'user/mnozina
&nbsp;
; pøidání dal¹ích prvkù do mno¾iny
<strong>user=&gt; (.addAll mnozina (range 20 30))</strong>
true
&nbsp;
; výpis aktuálního obsahu mno¾iny
<strong>user=&gt; (.toString mnozina)</strong>
"[1, 2, 3, 4, 5, 6, 7, 8, 9, 21, 20, 23, 22, 25, 24, 27, 26, 29, 28]"
&nbsp;
; odstranìní vybraných prvkù 15..25 (jen tìch, které existují)
<strong>user=&gt; (.removeAll mnozina (range 15 25))</strong>
true
&nbsp;
; výpis aktuálního obsahu mno¾iny
<strong>user=&gt; (.toString mnozina)</strong>
"[1, 2, 3, 4, 5, 6, 7, 8, 9, 25, 27, 26, 29, 28]"
&nbsp;
user=&gt;
</pre>

<p>Musíme si v¹ak dát dobrý pozor na to, ¾e v¹echny ètyøi strukturované datové
typy <i>Clojure</i> jsou nemìnitelné (<i>immutable</i>), tak¾e pøi pokusu o
modifikaci obsahu nìjaké struktury dojde k&nbsp;výjimce:</p>

<pre>
<strong>user=&gt; (java.util.Collections/sort '(1 2 3 4))</strong>
UnsupportedOperationException   java.util.Collections$UnmodifiableList$1.set
(Co llections.java:1186)
&nbsp;
<strong>user=&gt; (java.util.Collections/sort [1 2 3 4])</strong>
UnsupportedOperationException   clojure.lang.APersistentVector$1.set
(APersisten tVector.java:231)
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Clojure.org: Clojure home page<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>A Couple of Clojure Agent Examples<br />
<a href="http://lethain.com/a-couple-of-clojure-agent-examples/">http://lethain.com/a-couple-of-clojure-agent-examples/</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/">http://java.sun.com/developer/technicalArticles/DynTypeLang/</a>
</li>

<li>JSR 223: Scripting for the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=223">http://jcp.org/en/jsr/detail?id=223</a>
</li>

<li>JSR 292: Supporting Dynamically Typed Languages on the JavaTM Platform<br />
<a href="http://jcp.org/en/jsr/detail?id=292">http://jcp.org/en/jsr/detail?id=292</a>
</li>

<li>Java 7: A complete invokedynamic example<br />
<a href="http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html">http://niklasschlimm.blogspot.com/2012/02/java-7-complete-invokedynamic-example.html</a>
</li>

<li>InvokeDynamic: Actually Useful?<br />
<a href="http://blog.headius.com/2007/01/invokedynamic-actually-useful.html">http://blog.headius.com/2007/01/invokedynamic-actually-useful.html</a>
</li>

<li>A First Taste of InvokeDynamic<br />
<a href="http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html">http://blog.headius.com/2008/09/first-taste-of-invokedynamic.html</a>
</li>

<li>Java 6 try/finally compilation without jsr/ret<br />
<a href="http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html">http://cliffhacks.blogspot.com/2008/02/java-6-tryfinally-compilation-without.html</a>
</li>

<li>An empirical study of Java bytecode programs<br />
<a href="http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/">http://www.mendeley.com/research/an-empirical-study-of-java-bytecode-programs/</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Root.cz: Vyu¾ití komprimovaných ukazatelù na objekty v&nbsp;JVM<br />
<a href="http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/">http://www.root.cz/clanky/vyuziti-komprimovanych-ukazatelu-na-objekty-v-nbsp-jvm/</a></a>
</li>

<li>Root.cz: JamVM aneb alternativa k HotSpotu nejenom pro embedded zaøízení a chytré telefony<br />
<a href="http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/">http://www.root.cz/clanky/jamvm-aneb-alternativa-k-hotspotu-nejenom-pro-embedded-zarizeni-tablety-a-chytre-telefony/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>FindBugs<br />
<a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a>
</li>

<li>GNU Classpath<br />
<a href="www.gnu.org/s/classpath/">www.gnu.org/s/classpath/</a></li>

<li>Java VMs Compared<br />
<a href="http://bugblogger.com/java-vms-compared-160/">http://bugblogger.com/java-vms-compared-160/</a>
</li>

<li>JSRs: Java Specification Requests &ndash; JSR 223: Scripting for the Java Platform<br />
<a href="http://www.jcp.org/en/jsr/detail?id=223">http://www.jcp.org/en/jsr/detail?id=223</a>
</li>

<li>Scripting for the Java Platform<br />
<a href="http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/">http://java.sun.com/developer/technicalArticles/J2SE/Desktop/scripting/</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">http://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>Java Community Process<br />
<a href="http://en.wikipedia.org/wiki/Java_Specification_Request">http://en.wikipedia.org/wiki/Java_Specification_Request</a>
</li>

<li>Java HotSpot VM Options<br />
<a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a>
</li>

<li>Great Computer Language Shootout<br />
<a href="http://c2.com/cgi/wiki?GreatComputerLanguageShootout">http://c2.com/cgi/wiki?GreatComputerLanguageShootout</a>
</li>

<li>Java performance<br />
<a href="http://en.wikipedia.org/wiki/Java_performance">http://en.wikipedia.org/wiki/Java_performance</a>
</li>

<li>Trying the prototype<br />
<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html">http://mail.openjdk.java.net/pipermail/lambda-dev/2010-August/002179.html</a>
</li>

<li>Better closures (for Java)<br />
<a href="http://blogs.sun.com/jrose/entry/better_closures">http://blogs.sun.com/jrose/entry/better_closures</a>
</li>

<li>Lambdas in Java: An In-Depth Analysis<br />
<a href="http://www.infoq.com/articles/lambdas-java-analysis">http://www.infoq.com/articles/lambdas-java-analysis</a>
</li>

<li>Class ReflectiveOperationException<br />
<a href="http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html">http://download.java.net/jdk7/docs/api/java/lang/ReflectiveOperationException.html</a>
</li>

<li>Scala Programming Language<br />
<a href="http://www.scala-lang.org/">http://www.scala-lang.org/</a>
</li>

<li>Run Scala in Apache Tomcat in 10 minutes<br />
<a href="http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes">http://www.softwaresecretweapons.com/jspwiki/run-scala-in-apache-tomcat-in-10-minutes</a>
</li>

<li>Fast Web Development With Scala<br />
<a href="http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html">http://chasethedevil.blogspot.cz/2007/09/fast-web-development-with-scala.html</a>
</li>

<li>Top five scripting languages on the JVM<br />
<a href="http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855">http://www.infoworld.com/d/developer-world/top-five-scripting-languages-the-jvm-855</a>
</li>

<li>Proposal: Indexing access syntax for Lists and Maps<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/001108.html</a>
</li>

<li>Proposal: Elvis and Other Null-Safe Operators<br />
<a href="http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html">http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html</a>
</li>

<li>Java 7 : Oracle pushes a first version of closures<br />
<a href="http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/">http://www.baptiste-wicht.com/2010/05/oracle-pushes-a-first-version-of-closures/</a>
</li>

<li>Groovy: An agile dynamic language for the Java Platform<br />
<a href="http://groovy.codehaus.org/Operators">http://groovy.codehaus.org/Operators</a>
</li>

<li>Better Strategies for Null Handling in Java<br />
<a href="http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java">http://www.slideshare.net/Stephan.Schmidt/better-strategies-for-null-handling-in-java</a>
</li>

<li>Control Flow in the Java Virtual Machine<br />
<a href="http://www.artima.com/underthehood/flowP.html">http://www.artima.com/underthehood/flowP.html</a>
</li>

<li>Java Virtual Machine<br />
<a href="http://en.wikipedia.org/wiki/Java_virtual_machine">http://en.wikipedia.org/wiki/Java_virtual_machine</a>
</li>

<li>==, .equals(), compareTo(), and compare()<br />
<a href="http://leepoint.net/notes-java/data/expressions/22compareobjects.html">http://leepoint.net/notes-java/data/expressions/22compareobjects.html</a>
</li>

<li>New JDK7 features<br />
<a href="http://openjdk.java.net/projects/jdk7/features/">http://openjdk.java.net/projects/jdk7/features/</a>
</li>

<li>Project Coin: Bringing it to a Close(able)<br />
<a href="http://blogs.sun.com/darcy/entry/project_coin_bring_close">http://blogs.sun.com/darcy/entry/project_coin_bring_close</a>
</li>

<li>CloseableFinder source code<br />
<a href="http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java">http://blogs.sun.com/darcy/resource/ProjectCoin/CloseableFinder.java</a>
</li>

<li>Joe Darcy blog about JDK<br />
<a href="http://blogs.sun.com/darcy">http://blogs.sun.com/darcy</a>
</li>

<li>Java 7 - more dynamics<br />
<a href="http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/">http://www.baptiste-wicht.com/2010/04/java-7-more-dynamics/</a>
</li>

<li>New JDK 7 Feature: Support for Dynamically Typed Languages in the Java Virtual Machine<br />
<a href="http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html">http://java.sun.com/developer/technicalArticles/DynTypeLang/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

