<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled pod kapotu JVM - double buffering v praxi</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled pod kapotu JVM - double buffering v&nbsp;praxi</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o programovacím jazyce Java i o virtuálním stroji Javy si popí¹eme a na nìkolika demonstraèních pøíkladech uká¾eme, jakým zpùsobem je mo¾né pøi vykreslování vyu¾ívat double buffering, co¾ mù¾e vést ke znaènému urychlení celé graficky nároèné aplikace.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pohled pod kapotu JVM - double buffering v&nbsp;praxi</a></p>
<p><a href="#k02">2. Vyu¾ití vìt¹ího mno¾ství zadních bufferù</a></p>
<p><a href="#k03">3. Zji¹tìní konfigurace bufferù u v¹ech nainstalovaných grafických subsystémù</a></p>
<p><a href="#k04">4. První demonstraèní pøíklad: výpis informací o pøedním a zadním bufferu</a></p>
<p><a href="#k05">5. Výsledek prvního demonstraèního pøíkladu na Windows XP s&nbsp;integrovanou grafickou kartou</a></p>
<p><a href="#k06">6. Výsledek prvního demonstraèního pøíkladu na Linuxu se samostatným grafickým akcelerátorem</a></p>
<p><a href="#k07">7. Double buffering vyu¾ívaný pøi vykreslování komponent knihovny <i>Swing</i></a></p>
<p><a href="#k08">8. Druhý demonstraèní pøíklad: zapnutí a vypnutí double bufferingu pøi práci s&nbsp;komponentami knihovny <i>Swing</i></a></p>
<p><a href="#k09">9. Vyu¾ití tøídy <strong>BufferStrategy</strong> pro øízení double bufferingu</a></p>
<p><a href="#k10">10. Repositáø se zdrojovými kódy obou dne¹ních demonstraèních pøíkladù</a></p>
<p><a href="#k11">11. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pohled pod kapotu JVM - double buffering v&nbsp;praxi</h2>

<p>V&nbsp;dne¹ní èásti <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">seriálu o
programovacím jazyce Java i o virtuálním stroji Javy</a> si øekneme, jakým
zpùsobem je mo¾né v&nbsp;praxi vyu¾ít takzvaný <i>double buffering</i>.
Pøipomeòme si, ¾e se tímto názvem oznaèuje známý a v&nbsp;poèítaèové grafice
ji¾ velmi dlouho vyu¾ívaný postup, pøi nìm¾ se vykreslování grafického
u¾ivatelského rozhraní aplikace popø.&nbsp;prostøedí hry neprovádí pøímo na
obrazovku, ale do pomocné bitmapy oznaèované termínem <i>zadní buffer (back
buffer)</i>. Obrazovka, resp.&nbsp;pøesnìji øeèeno bitmapa zobrazená na
obrazovce a tedy viditelná u¾ivateli, je pøi pou¾ití double bufferingu
oznaèována termínem <i>pøední buffer (front buffer) </i>. Vykreslování je do
neviditelného zadního bufferu provádìno z&nbsp;toho dùvodu, aby u¾ivatel
nevidìl nepøíjemné poblikávání obrazu pøi mazání/kreslení pozadí a takté¾ pøi
postupném pøikreslování v¹ech dal¹ích grafických prvkù, které mají být na
obrazovce viditelné.</p>

<p>Po dokonèení vykreslení v¹ech grafických objektù do zadního bufferu je v¹ak
nutné tento buffer uèinit viditelným. To lze provést dvìma zpùsoby.
V&nbsp;pøípadì, ¾e je zadní buffer ulo¾en v&nbsp;pamìti grafické karty, je
vìt¹inou mo¾né jednodu¹e prohodit role pøedního a zadního bufferu, a to velmi
jednoduchou operací nevy¾adující ¾ádné pøenosy dat. Tento zpùsob se nazývá
<i>page flipping</i> a je samozøejmì podporován i v&nbsp;JVM, ov¹em
v&nbsp;mnoha pøípadech pouze pøi pou¾ití exkluzivního celoobrazovkového re¾imu
(prohození obsahu obou bufferù se typicky provádí ve chvíli takzvaného
vertikálního zatemnìní &ndash; <i>vertical blank (VBLANK)</i>).</p>

<p>Druhý zpùsob spoèívá v&nbsp;blokovém pøenosu obsahu celého zadního bufferu
do bufferu pøedního, a to operací typu <i>BitBlt (BLIT)</i>. Opìt zále¾í na
mo¾nostech konkrétního grafického subsystému i na zpùsobu ulo¾ení zadního
bufferu, zda je tato operace provedena pøímo na grafickém akcelerátoru (co¾ je
samozøejmì rychlej¹í øe¹ení) èi zda je nutné pøená¹et obsah zadního bufferu do
bufferu pøedního pøes systémovou sbìrnici. Ponìkud pøedbìhneme, ale u¾ zde je
zapotøebí øíci, ¾e v&nbsp;pøípadì pou¾ití double bufferingu a ulo¾ení zadního
bufferu v&nbsp;operaèní pamìti nemusí aplikace pracovat optimálnì, co¾ typicky
nastává u nìkterých aplikací vyu¾ívajících knihovnu <i>Swing</i>.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Vyu¾ití vìt¹ího mno¾ství zadních bufferù</h2>

<p>V&nbsp;pøedchozí kapitole jsme si øekli, ¾e <i>double buffering</i> mù¾e být
realizován minimálnì dvìma zpùsoby &ndash; operací typu <i>BitBlt</i> èi
<i>page flippingem</i>. Ve skuteènosti se v¹ak v&nbsp;nìkterých pøípadech
nepou¾ívají pouze dva buffery (tj.&nbsp;jeden pøední a jeden zadní buffer), ale
dokonce i vìt¹í mno¾ství zadních bufferù. V&nbsp;nìkterých hrách èi dal¹ích
graficky nároèných aplikacích se typicky pou¾ívají tøi buffery: pøední
(viditelný) buffer, první zadní (neviditelný) buffer s&nbsp;ji¾ pøipravenou
scénou a tøetí (takté¾ neviditelný) buffer, do nìho¾ se právì provádí
vykreslování. Výhoda této konfigurace spoèívá v&nbsp;tom, ¾e aplikace mù¾e
provádìt vykreslování nejvy¹¹í mo¾nou rychlostí a nemusí èekat na synchronizaci
s&nbsp;vertikálním zatemnìním obrazu, kdy je mo¾né a vhodné prohodit obsah
pøedního a zadního bufferu (jen v&nbsp;tomto okam¾iku toti¾ nebudou patrné
ru¹ivé elementy v&nbsp;obrazu &ndash; typický je horizontální
&bdquo;zlom&ldquo; ve chvíli, kdy se obraz pøená¹í bez synchronizace).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zji¹tìní konfigurace bufferù u v¹ech nainstalovaných grafických subsystémù</h2>

<p>Pro vývoj aplikací, které mají vyu¾ívat mo¾nosti grafického subsystému
optimálním zpùsobem, je nutné zjistit, kolik zadních bufferù lze pou¾ít a jakým
zpùsobem je vlastnì double buffering na daném systému implementován (èi zda je
vùbec podporován). K&nbsp;tomuto úèelu lze v&nbsp;Javì pou¾ít metodu
<strong>GraphicsConfiguration.getBufferCapabilities()</strong> vracející objekt
typu <strong>BufferCapabilities</strong>. Ve tøídì
<strong>BufferCapabilities</strong> najdeme nìkolik dùle¾itých metod:</p>

<table>
<tr><th>#</th><th>Metoda</th><th>Význam</th></tr>
<tr><td>1</td><td>boolean isMultiBufferAvailable()</td><td>vrací pravdivostní hodnotu <i>true</i>, kdy¾ existuje více ne¾ jeden zadní buffer</td></tr>
<tr><td>2</td><td>boolean isPageFlipping()</td><td>vrací pravdivostní hodnotu <i>true</i>, kdy¾ je podporováno prohazování pøedního a zadního bufferu</td></tr>
<tr><td>3</td><td>boolean isFullScreenRequired()</td><td>vrací pravdivostní hodnotu <i>true</i>, kdy¾ je nutné se pøepnout do exkluzivního re¾imu pro vyu¾ití double bufferingu</td></tr>
</table>

<p>Dále je mo¾né s&nbsp;vyu¾itím dvou metod
<strong>BufferCapabilities.getFrontBufferCapabilities()</strong> a
<strong>BufferCapabilities.getBackBufferCapabilities()</strong> zjistit
pøesnìj¹í informace o pøedním a zadním bufferu:</p>

<table>
<tr><th>#</th><th>Metoda</th><th>Význam</th></tr>
<tr><td>1</td><td>boolean isAccelerated()</td><td>vrací pravdivostní hodnotu <i>true</i>, kdy¾ je práce s&nbsp;bufferem realizována na grafickém akcelerátoru</td></tr>
<tr><td>2</td><td>boolean isTrueVolatile()</td><td>vrací pravdivostní hodnotu <i>true</i>, kdy¾ se mù¾e obsah bufferu ztratit napøíklad pøi pøepnutí aplikace</td></tr>
</table>

<p>Obecnì platí, ¾e volatilní budou pouze ty buffery, které jsou souèasnì
akcelerované; opaèná implikace v¹ak nemusí být splnìna, co¾ znamená, ¾e lze mít
nevolatilní a souèasnì i akcelerované buffery, co¾ je z&nbsp;hlediska
programátora ideální situace.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. První demonstraèní pøíklad: výpis informací o pøedním a zadním bufferu</h2>

<p>Metody pro zji¹tìní schopností grafického subsystému, které byly struènì
popsány <a href="#k03">v&nbsp;pøedchozí kapitole</a>, budou pou¾ity
v&nbsp;dne¹ním prvním demonstraèním pøíkladu nazvaném
<strong>GraphicsDevicesTest2</strong>, jen¾ je zalo¾en na star¹ím pøíkladu
<strong>GraphicsDevicesTest</strong>. Tento pøíklad po svém pøekladu a spu¹tìní
nejdøíve zjistí, jaká grafická zaøízení jsou na daném operaèním systému
dostupná a posléze vypí¹e jak základní konfiguraci ka¾dého zaøízení, tak i
podporované celoobrazovkové grafické re¾imy. Kromì toho jsou vypsány i
informace o podpoøe <i>double bufferingu</i>, pøedev¹ím to, zda je podporováno
vìt¹í mno¾ství zadních bufferù, zda je podporován rychlý <i>page flipping</i>
(prohození funkcí pøedního a zadního bufferu) i to, zda je nutné pro vyu¾ití
double bufferingu provést pøepnutí do exkluzivního celoobrazovkového grafického
re¾imu. Dále se vypí¹ou i základní informace o pøedním i zadním bufferu &ndash;
zejména zda je jejich vykreslování øe¹eno grafickým akcelerátorem a zde se mù¾e
obsah bufferu v&nbsp;nìkterém okam¾iku po¹kodit (<i>volatile</i>).</p>

<p>Následuje výpis celého zdrojového kódu dne¹ního prvního demonstraèního
pøíkladu:</p>

<pre>
import java.awt.BufferCapabilities;
import java.awt.DisplayMode;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.ImageCapabilities;
import java.awt.GraphicsDevice.WindowTranslucency;
&nbsp;
&nbsp;
&nbsp;
<i>/**</i>
<i> * Vypis zakladnich vlastnosti grafickych zarizeni, ktere lze vyuzit primo</i>
<i> * z Javy. Vypisou se i informace o prednim a zadnim bufferu.</i>
<i> */</i>
public class <strong>GraphicsDevicesTest2</strong> {
&nbsp;
<i>    /**</i>
<i>     * Vstupni bod do tohoto testu.</i>
<i>     */</i>
    public static void <strong>main</strong>(String[] args) {
        GraphicsDevice[] graphicsDevices = getScreenGraphicsDevices();
        printInfoAboutEachGraphicsDevice(graphicsDevices);
    }
&nbsp;
<i>    /**</i>
<i>     * Ziska pole se vsemi dostupnymi grafickymi zarizenimi.</i>
<i>     *</i>
<i>     * @return pole se vsemi dostupnymi grafickymi zarizenimi</i>
<i>     */</i>
    private static GraphicsDevice[] <strong>getScreenGraphicsDevices</strong>() {
        GraphicsEnvironment graphicsEnvironment = GraphicsEnvironment.getLocalGraphicsEnvironment();
        GraphicsDevice[] graphicsDevices = graphicsEnvironment.getScreenDevices();
        return graphicsDevices;
    }
&nbsp;
<i>    /**</i>
<i>     * Vypise informaci o vsech grafickych zarizenich predanych v parametru</i>
<i>     * graphicsDevices.</i>
<i>     *</i>
<i>     * @param graphicsDevices</i>
<i>     *            pole se vsemi dostupnymi grafickymi zarizenimi</i>
<i>     */</i>
    private static void <strong>printInfoAboutEachGraphicsDevice</strong>(GraphicsDevice[] graphicsDevices) {
        for (int j = 0; j &lt; graphicsDevices.length; j++) { 
           GraphicsDevice graphicsDevice = graphicsDevices[j];
           printGraphicsDeviceInfo(graphicsDevice);
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Vypise informaci o grafickem zarizeni predanem v parametru</i>
<i>     * graphicsDevice.</i>
<i>     *</i>
<i>     * @param graphicsDevice</i>
<i>     *            objekt reprezentujici dostupne graficke zarizeni.</i>
<i>     */</i>
    private static void <strong>printGraphicsDeviceInfo</strong>(GraphicsDevice graphicsDevice) {
        System.out.println("Device ID: " + graphicsDevice.getIDstring());
        System.out.println("Type:      " + getDeviceType(graphicsDevice));
        System.out.println("Accelerated memory size:  " + graphicsDevice.getAvailableAcceleratedMemory());
        System.out.println("Display change supported: " + graphicsDevice.isDisplayChangeSupported());
        System.out.println("Full screen supported:    " + graphicsDevice.isFullScreenSupported());
        printTransparencyInfo(graphicsDevice);
        printBuffersConfiguration(graphicsDevice);
        System.out.println("Graphics modes:");
        DisplayMode[] modes = graphicsDevice.getDisplayModes();
        printAvailableDisplayModes(modes);
        System.out.println();
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis zda zarizeni podporuje pruhlednost a/nebo prusvitnost.</i>
<i>     *</i>
<i>     * @param graphicsDevice</i>
<i>     *            objekt reprezentujici dostupne graficke zarizeni.</i>
<i>     */</i>
    private static void <strong>printTransparencyInfo</strong>(GraphicsDevice graphicsDevice) {
        System.out.println("Transparency/translucency support:");
        System.out.println("    Per pixel transparency:  " + graphicsDevice.isWindowTranslucencySupported(WindowTranslucency.PERPIXEL_TRANSPARENT));
        System.out.println("    Per pixel translucency:  " + graphicsDevice.isWindowTranslucencySupported(WindowTranslucency.PERPIXEL_TRANSLUCENT));
        System.out.println("    Per window translucency: " + graphicsDevice.isWindowTranslucencySupported(WindowTranslucency.TRANSLUCENT));
    }
&nbsp;
<i>    /**</i>
<i>     * Vypis informace o bufferech (prednim a zadnim bufferu atd.).</i>
<i>     *</i>
<i>     * @param graphicsDevice</i>
<i>     *            objekt reprezentujici dostupne graficke zarizeni.</i>
<i>     */</i>
    private static void <strong>printBuffersConfiguration</strong>(GraphicsDevice graphicsDevice) {
<i>        // ziskat vsechny dostupne graficke konfigurace</i>
        GraphicsConfiguration[] graphicsConfigurations = graphicsDevice.getConfigurations();
        for (GraphicsConfiguration graphicsConfiguration : graphicsConfigurations) {
            System.out.println("Graphics configuration: " + graphicsConfiguration.toString());
            BufferCapabilities bufferCapabilities = graphicsConfiguration.getBufferCapabilities();
            System.out.println("    Buffers configuration:");
            System.out.println("        Multi buffer available:   " + bufferCapabilities.isMultiBufferAvailable());
            System.out.println("        Page flipping supported:  " + bufferCapabilities.isPageFlipping());
            System.out.println("        Full screen required:     " + bufferCapabilities.isFullScreenRequired());
            <i>// moznosti predniho bufferu</i>
            ImageCapabilities frontBuffer = bufferCapabilities.getFrontBufferCapabilities();
            <i>// moznosti zadniho bufferu</i>
            ImageCapabilities backBuffer = bufferCapabilities.getBackBufferCapabilities();
            System.out.println("        Front buffer accelerated: " + frontBuffer.isAccelerated());
            System.out.println("        Front buffer volatile:    " + frontBuffer.isTrueVolatile());
            System.out.println("        Back buffer accelerated:  " + backBuffer.isAccelerated());
            System.out.println("        Back buffer volatile:     " + backBuffer.isTrueVolatile());
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Vrati typ grafickeho zarizeni.</i>
<i>     *</i>
<i>     * @param graphicsDevice</i>
<i>     *            objekt reprezentujici dostupne graficke zarizeni.</i>
<i>     * @return typ zarizeni (textova reprezentace)</i>
<i>     */</i>
    private static String <strong>getDeviceType</strong>(GraphicsDevice graphicsDevice) {
        switch (graphicsDevice.getType()) {
        case GraphicsDevice.TYPE_RASTER_SCREEN:
            return "raster screen";
        case GraphicsDevice.TYPE_PRINTER:
            return "printer";
        case GraphicsDevice.TYPE_IMAGE_BUFFER:
            return "image buffer";
        default: // nemelo by nastat
            return "???";
        }
    }
&nbsp;
<i>    /**</i>
<i>     * Vypise dostupne graficke rezimy a jejich zakladni vlastnosti.</i>
<i>     *</i>
<i>     * @param modes pole s grafickymi rezimy pro dane zarizeni.</i>
<i>     */</i>
    private static void <strong>printAvailableDisplayModes</strong>(DisplayMode[] modes) {
        for (DisplayMode mode : modes) {
            final int width = mode.getWidth();
            final int height = mode. getHeight();
            final int bpp = mode.getBitDepth();
            final int refreshRate = mode.getRefreshRate();
            System.out.println("    " +
                    width + "x" + height +
                    "@" + bpp + " bpp\t(" + refreshRate + " Hz)");
        }
    }
&nbsp;
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Výsledek prvního demonstraèního pøíkladu na Windows XP s&nbsp;integrovanou grafickou kartou</h2>

<p>Podívejme se nyní na výsledky získané po spu¹tìní demonstraèního pøíkladu
<i>GraphicsDevicesTest2</i> na nìkolika poèítaèích vybavených rùznými
operaèními systémy a samozøejmì i rozdílnými grafickými kartami. Prvním
poèítaèem je ji¾ nìkolikrát zmiòovaný starobylý (více ne¾ desetiletý) notebook
s&nbsp;nainstalovaným Oracle JDK7 a neaktualizovaným :-) systémem Microsoft
Windows XP vybavený èipsetem Intel 855 GME. Zajímavé je, ¾e na tomto systému
není (alespoò v&nbsp;aktuální konfiguraci) podporován <i>page flipping</i>, co¾
znamená, ¾e double buffering zde bude realizován fyzickým pøenosem dat. Takté¾
zde není dostupné vìt¹í mno¾ství zadních bufferù, co¾ mù¾e zpùsobit problémy
pøi bìhu nìkterých aplikací vy¾adujících napøíklad dva zadní buffery:</p>

<pre>
Device ID: \Display0
Type:      raster screen
Accelerated memory size:  -1
Display change supported: false
Full screen supported:    true
Transparency/translucency support:
    Per pixel transparency:  true
    Per pixel translucency:  true
    Per window translucency: true
Graphics configuration: sun.awt.Win32GraphicsConfig@2a15cd[dev=Win32GraphicsDevice[screen=0],pixfmt=0]
    Buffers configuration:
        Multi buffer available:   false
        Page flipping supported:  false
        Full screen required:     false
        Front buffer accelerated: false
        Front buffer volatile:    false
        Back buffer accelerated:  false
        Back buffer volatile:     false
Graphics modes:
    320x200@8 bpp   (70 Hz)
    320x200@16 bpp  (70 Hz)
    320x200@32 bpp  (70 Hz)
    320x240@8 bpp   (70 Hz)
    320x240@16 bpp  (70 Hz)
    320x240@32 bpp  (70 Hz)
    400x300@8 bpp   (70 Hz)
    400x300@16 bpp  (70 Hz)
    400x300@32 bpp  (70 Hz)
    512x384@8 bpp   (70 Hz)
    512x384@16 bpp  (70 Hz)
    512x384@32 bpp  (70 Hz)
    640x480@8 bpp   (60 Hz)
    640x400@8 bpp   (70 Hz)
    800x600@8 bpp   (60 Hz)
    1024x768@8 bpp  (60 Hz)
    640x480@16 bpp  (60 Hz)
    800x600@16 bpp  (60 Hz)
    1024x768@16 bpp (60 Hz)
    640x480@32 bpp  (60 Hz)
    800x600@32 bpp  (60 Hz)
    1024x768@32 bpp (60 Hz)
    640x400@16 bpp  (70 Hz)
    640x400@32 bpp  (70 Hz)
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Výsledek prvního demonstraèního pøíkladu na Linuxu se samostatným grafickým akcelerátorem</h2>

<p>Pøi spu¹tìní demonstraèního pøíkladu <strong>GraphicsDevicesTest2</strong>
na poèítaèi s&nbsp;OpenJDK (Linux, X Window) a samostatným grafickým
akcelerátorem získáme ponìkud odli¹né výsledky. Grafická karta zde podporuje
více grafických konfigurací a navíc &ndash; co¾ je mnohem dùle¾itìj¹í &ndash;
podporuje i rychlý <i>page flipping</i>, co¾ je ostatnì patrné i
z&nbsp;následujícího výpisu:</p>

<pre>
Device ID: :0.0
Type:      raster screen
Accelerated memory size:  -1
Display change supported: false
Full screen supported:    true
Graphics configuration: X11GraphicsConfig[dev=X11GraphicsDevice[screen=0],vis=0x21]
    Buffers configuration:
        Multi buffer available:   false
        Page flipping supported:  true
        Full screen required:     false
        Front buffer accelerated: true
        Front buffer volatile:    false
        Back buffer accelerated:  true
        Back buffer volatile:     false
Graphics configuration: X11GraphicsConfig[dev=X11GraphicsDevice[screen=0],vis=0x23]
    Buffers configuration:
        Multi buffer available:   false
        Page flipping supported:  true
        Full screen required:     false
        Front buffer accelerated: true
        Front buffer volatile:    false
        Back buffer accelerated:  true
        Back buffer volatile:     false
Graphics configuration: X11GraphicsConfig[dev=X11GraphicsDevice[screen=0],vis=0x24]
    Buffers configuration:
        Multi buffer available:   false
        Page flipping supported:  true
        Full screen required:     false
        Front buffer accelerated: true
        Front buffer volatile:    false
        Back buffer accelerated:  true
        Back buffer volatile:     false
Graphics configuration: X11GraphicsConfig[dev=X11GraphicsDevice[screen=0],vis=0x25]
    Buffers configuration:
        Multi buffer available:   false
        Page flipping supported:  true
        Full screen required:     false
        Front buffer accelerated: true
        Front buffer volatile:    false
        Back buffer accelerated:  true
        Back buffer volatile:     false
Graphics configuration: X11GraphicsConfig[dev=X11GraphicsDevice[screen=0],vis=0x26]
    Buffers configuration:
        Multi buffer available:   false
        Page flipping supported:  true
        Full screen required:     false
        Front buffer accelerated: true
        Front buffer volatile:    false
        Back buffer accelerated:  true
        Back buffer volatile:     false
Graphics configuration: X11GraphicsConfig[dev=X11GraphicsDevice[screen=0],vis=0x27]
    Buffers configuration:
        Multi buffer available:   false
        Page flipping supported:  true
        Full screen required:     false
        Front buffer accelerated: true
        Front buffer volatile:    false
        Back buffer accelerated:  true
        Back buffer volatile:     false
Graphics configuration: X11GraphicsConfig[dev=X11GraphicsDevice[screen=0],vis=0x28]
    Buffers configuration:
        Multi buffer available:   false
        Page flipping supported:  true
        Full screen required:     false
        Front buffer accelerated: true
        Front buffer volatile:    false
        Back buffer accelerated:  true
        Back buffer volatile:     false
Graphics configuration: X11GraphicsConfig[dev=X11GraphicsDevice[screen=0],vis=0x29]
    Buffers configuration:
        Multi buffer available:   false
        Page flipping supported:  true
        Full screen required:     false
        Front buffer accelerated: true
        Front buffer volatile:    false
        Back buffer accelerated:  true
        Back buffer volatile:     false
Graphics configuration: X11GraphicsConfig[dev=X11GraphicsDevice[screen=0],vis=0x2a]
    Buffers configuration:
        Multi buffer available:   false
        Page flipping supported:  true
        Full screen required:     false
        Front buffer accelerated: true
        Front buffer volatile:    false
        Back buffer accelerated:  true
        Back buffer volatile:     false
Graphics configuration: X11GraphicsConfig[dev=X11GraphicsDevice[screen=0],vis=0x2b]
    Buffers configuration:
        Multi buffer available:   false
        Page flipping supported:  true
        Full screen required:     false
        Front buffer accelerated: true
        Front buffer volatile:    false
        Back buffer accelerated:  true
        Back buffer volatile:     false
Graphics configuration: X11GraphicsConfig[dev=X11GraphicsDevice[screen=0],vis=0x2c]
    Buffers configuration:
        Multi buffer available:   false
        Page flipping supported:  true
        Full screen required:     false
        Front buffer accelerated: true
        Front buffer volatile:    false
        Back buffer accelerated:  true
        Back buffer volatile:     false
Graphics configuration: X11GraphicsConfig[dev=X11GraphicsDevice[screen=0],vis=0x2d]
    Buffers configuration:
        Multi buffer available:   false
        Page flipping supported:  true
        Full screen required:     false
        Front buffer accelerated: true
        Front buffer volatile:    false
        Back buffer accelerated:  true
        Back buffer volatile:     false
Graphics configuration: X11GraphicsConfig[dev=X11GraphicsDevice[screen=0],vis=0x2e]
    Buffers configuration:
        Multi buffer available:   false
        Page flipping supported:  true
        Full screen required:     false
        Front buffer accelerated: true
        Front buffer volatile:    false
        Back buffer accelerated:  true
        Back buffer volatile:     false
Graphics configuration: X11GraphicsConfig[dev=X11GraphicsDevice[screen=0],vis=0x2f]
    Buffers configuration:
        Multi buffer available:   false
        Page flipping supported:  true
        Full screen required:     false
        Front buffer accelerated: true
        Front buffer volatile:    false
        Back buffer accelerated:  true
        Back buffer volatile:     false
Graphics configuration: X11GraphicsConfig[dev=X11GraphicsDevice[screen=0],vis=0x30]
    Buffers configuration:
        Multi buffer available:   false
        Page flipping supported:  true
        Full screen required:     false
        Front buffer accelerated: true
        Front buffer volatile:    false
        Back buffer accelerated:  true
        Back buffer volatile:     false
Graphics configuration: X11GraphicsConfig[dev=X11GraphicsDevice[screen=0],vis=0x31]
    Buffers configuration:
        Multi buffer available:   false
        Page flipping supported:  true
        Full screen required:     false
        Front buffer accelerated: true
        Front buffer volatile:    false
        Back buffer accelerated:  true
        Back buffer volatile:     false
Graphics configuration: X11GraphicsConfig[dev=X11GraphicsDevice[screen=0],vis=0xa7]
    Buffers configuration:
        Multi buffer available:   false
        Page flipping supported:  true
        Full screen required:     false
        Front buffer accelerated: true
        Front buffer volatile:    false
        Back buffer accelerated:  true
        Back buffer volatile:     false
Graphics modes:
    1280x1024@-1 bpp    (50 Hz)
    1280x1024@-1 bpp    (51 Hz)
    1280x960@-1 bpp     (52 Hz)
    1152x864@-1 bpp     (53 Hz)
    1152x864@-1 bpp     (54 Hz)
    1152x864@-1 bpp     (55 Hz)
    1152x864@-1 bpp     (56 Hz)
    1024x768@-1 bpp     (57 Hz)
    1024x768@-1 bpp     (58 Hz)
    1024x768@-1 bpp     (59 Hz)
    960x600@-1 bpp      (60 Hz)
    960x540@-1 bpp      (61 Hz)
    840x525@-1 bpp      (62 Hz)
    840x525@-1 bpp      (63 Hz)
    840x525@-1 bpp      (64 Hz)
    832x624@-1 bpp      (65 Hz)
    800x600@-1 bpp      (66 Hz)
    800x600@-1 bpp      (67 Hz)
    800x600@-1 bpp      (68 Hz)
    800x600@-1 bpp      (69 Hz)
    800x600@-1 bpp      (70 Hz)
    800x600@-1 bpp      (71 Hz)
    800x512@-1 bpp      (72 Hz)
    720x450@-1 bpp      (73 Hz)
    680x384@-1 bpp      (74 Hz)
    680x384@-1 bpp      (75 Hz)
    640x512@-1 bpp      (76 Hz)
    640x512@-1 bpp      (77 Hz)
    640x480@-1 bpp      (78 Hz)
    640x480@-1 bpp      (79 Hz)
    640x480@-1 bpp      (80 Hz)
    640x480@-1 bpp      (81 Hz)
    576x432@-1 bpp      (82 Hz)
    576x432@-1 bpp      (83 Hz)
    576x432@-1 bpp      (84 Hz)
    576x432@-1 bpp      (85 Hz)
    512x384@-1 bpp      (86 Hz)
    512x384@-1 bpp      (87 Hz)
    512x384@-1 bpp      (88 Hz)
    416x312@-1 bpp      (89 Hz)
    400x300@-1 bpp      (90 Hz)
    400x300@-1 bpp      (91 Hz)
    400x300@-1 bpp      (92 Hz)
    400x300@-1 bpp      (93 Hz)
    320x240@-1 bpp      (94 Hz)
    320x240@-1 bpp      (95 Hz)
    320x240@-1 bpp      (96 Hz)
</pre>

<p>Poznámka: o tom, ¾e v&nbsp;nìkterých pøípadech (typicky na Linuxu s&nbsp;X
Window) se nevrátí kompletní informace o podporovaných grafických re¾imech,
popø.&nbsp;se vrátí obecnìj¹í informace, ne¾ jakou by programátor mnohdy
potøeboval znát, jsme se ji¾ zmiòovali. Ve vý¹e zobrazeném výpisu se napøíklad
nevrátila pøesná informace o bitové hloubce, ale hodnota -1, která odpovídá
konstantì <strong>BIT_DEPTH_MULTI</strong>.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Double buffering vyu¾ívaný pøi vykreslování komponent knihovny <i>Swing</i></h2>

<p>Double buffering se pou¾ívá i v&nbsp;knihovnì <i>Swing</i> pøi vykreslování
v¹ech komponent, tj.&nbsp;ovládacích prvkù grafického u¾ivatelského rozhraní.
Díky pou¾ití double bufferingu se vykreslování i slo¾itìj¹ích komponent,
napøíklad tabulek èi stromù, obejde bez nepøíjemného poblikávání, a to i
v&nbsp;pøípadì, ¾e je Javovská aplikace spu¹tìna na pomalej¹ích poèítaèích.
Ov¹em právì na ménì výkonných strojích mù¾e double buffering vyu¾ívaný
knihovnou <i>Swing</i> zpùsobit jiné problémy &ndash; pomalou odezvu na pøíkazy
zadávané u¾ivatelem. S&nbsp;urèitou (ale ne moc velkou) nadsázkou je dokonce
mo¾né øíci, ¾e double buffering ve Swingu nemalou mìrou pøispìl k&nbsp;tomu, ¾e
je Java pova¾ována za nevhodnou platformu pro vývoj aplikací pro desktop. Proè
tomu tak je? Ji¾ <a href="#k05">v&nbsp;páté kapitole</a> jsme vidìli, ¾e na
nìkterých typech poèítaèù a operaèních systémù nemusí být podporováno
hardwarovì urychlené pøepínání bufferù (<i>page flipping</i>) ani rychlý
blokový pøenos pixelù ze zadního bufferu do bufferu pøedního.</p>

<p>V&nbsp;tomto pøípadì mù¾e být double buffering aplikovaný na v¹echna okna a
v¹echny dialogy skuteènì kontraproduktivní, proto¾e sice zamezí vzniku
vizuálních chyb pøi pøekreslování okna/dialogu, ov¹em ve¹keré reakce na pøíkazy
zadávané u¾ivatelem (stisk tlaèítka, výbìr jedné polo¾ky z&nbsp;listboxu,
rozbalení stromu atd.) budou opo¾dìny. Navíc se zvý¹í spotøeba operaèní pamìti,
proto¾e se zadní buffer bude vytváøet pro ka¾dé okno èi dialog, co¾ napøíklad
pro hlavní maximalizované okno o velikosti 1280&times;1024 pixelù mù¾e vést
k&nbsp;alokaci dal¹ích pìti megabajtù (ty je navíc nutné pøená¹et po sbìrnici).
Nicménì double buffering je mo¾né vypnout, a to i selektivnì pro ka¾dou
komponentu. Praktický význam v¹ak má zapnutí èi vypnutí double bufferingu jen
pøi aplikaci na <strong>rootPane</strong> okna èi dialogu. Zapnutí èi vypnutí
double bufferingu zajistí metoda
<strong>JComponent.setDoubleBuffered(boolean)</strong>, na aktuální nastavení
se lze kdykoli dotázat metodou
<strong>JComponent.isDoubleBuffered()</strong>.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Druhý demonstraèní pøíklad: zapnutí a vypnutí double bufferingu pøi práci s&nbsp;komponentami knihovny <i>Swing</i></h2>

<p>To, jakým zpùsobem se mù¾e projevit vypnutí double bufferingu
v&nbsp;knihovnì <i>Swing</i>, si uká¾eme na dne¹ním druhém demonstraèním
pøíkladu. Jedná se o dialog obsahující textový editor se zobrazenou HTML
stránkou a zavírací tlaèítko. HTML stránka je pomìrnì rozsáhlá (konkrétnì se
jedná o neupravený pøedchozí díl tohoto seriálu), co¾ znamená, ¾e <i>Swing</i>
bude pøi pøekreslování celého dialogu volat velké mno¾ství svých interních
metod pro zobrazení øetìzce, výpoèet mezer mezi znaky atd. S&nbsp;vyu¾itím
atributu <strong>DOUBLE_BUFFERING</strong> je mo¾né povolit èi naopak zakázat
double buffering celého dialogu. Zmìna se projeví jak pøi editaci HTML stránky
(zde je v¹ak rozdíl viditelný jen na skuteènì velmi pomalých strojích), tak
zejména pøi zvìt¹ování okna v&nbsp;pøípadì, ¾e je obsah okna neustále
pøekreslován (je nutné správnì nastavit správce oken, aby se kontinuální
pøekreslování skuteènì provádìlo). Pokud je double buffering zapnutý, bude sice
pøekreslování dokonalé a bez vizuálních vad, ov¹em okno bude pøekresleno
znatelnì pomaleji, pøi vypnutém double bufferingu budou naproti tomu viditelné
vizuální chyby a poblikávání èástí dialogu.</p>

<p>Následuje výpis zdrojového kódu dne¹ního druhého demonstraèního
pøíkladu:</p>

<pre>
import java.awt.BorderLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
&nbsp;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JScrollPane;
import javax.swing.WindowConstants;
&nbsp;
<i>/**</i>
<i> * Jednoduchy dialog pro testovani moznosti double bufferingu.</i>
<i> * </i>
<i> * @author Pavel Tisnovsky</i>
<i> */</i>
public class <strong>TestDialog</strong> extends JDialog {
&nbsp;
    <i>/**</i>
    <i> * Generated serial version UID.</i>
    <i> */</i>
    private static final long serialVersionUID = -6415126729773286780L;
&nbsp;
    <i>/**</i>
    <i> * Povoleni ci naopak zakaz double bufferingu.</i>
    <i> */</i>
    private static final boolean <strong>DOUBLE_BUFFERING</strong> = false;
&nbsp;
    <i>/**</i>
    <i> * Konstruktor testovaciho dialogu.</i>
    <i> *</i>
    <i> * @throws IOException</i>
    <i> */</i>
    public <strong>TestDialog</strong>() throws IOException {
        setPreferredSize(new java.awt.Dimension(1024, 768));
&nbsp;
        <i>/* nastaveni double bufferingu */</i>
        JComponent rootPane = this.rootPane;
        System.out.println("double buffering enabled by default: " + rootPane.isDoubleBuffered());
        rootPane.setDoubleBuffered(DOUBLE_BUFFERING);
&nbsp;
        addTextArea();
        addCloseButton();
        this.pack();
    }
&nbsp;
    <i>/**</i>
    <i> * Pridani editoru s nactenou HTML strankou do dialogu.</i>
    <i> *</i>
    <i> * @throws FileNotFoundException</i>
    <i> * @throws IOException</i>
    <i> */</i>
    private void <strong>addTextArea</strong>() throws FileNotFoundException, IOException {
        StringBuilder htmlPage = new StringBuilder();
        readHtmlFile(htmlPage);
&nbsp;
        this.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
        JEditorPane textArea = new JEditorPane("text/html", htmlPage.toString());
        textArea.setEditable(true);
&nbsp;
        this.add(new JScrollPane(textArea), BorderLayout.CENTER);
    }
&nbsp;
    <i>/**</i>
    <i> * Pridani zaviraciho tlacitka do dialogu.</i>
    <i> */</i>
    private void <strong>addCloseButton</strong>() {
        JButton closeButton = new JButton("Close");
        closeButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                dispose();
            }
        });
        this.add(closeButton, BorderLayout.SOUTH);
    }
&nbsp;
    <i>/**</i>
    <i> * Nacteni HTML stranky.</i>
    <i> *</i>
    <i> * @param htmlPage</i>
    <i> * @throws FileNotFoundException</i>
    <i> * @throws IOException</i>
    <i> */</i>
    private void <strong>readHtmlFile</strong>(StringBuilder htmlPage) throws FileNotFoundException, IOException {
        final FileInputStream fileInputStream = new FileInputStream("java109.html");
        InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream, "UTF-8");
        BufferedReader reader = new BufferedReader(inputStreamReader);
        String line;
        while ((line = reader.readLine()) != null) {
            htmlPage.append(line);
        }
        reader.close();
    }
&nbsp;
    <i>/**</i>
    <i> * Zobrazeni testovaciho dialogu.</i>
    <i> *</i>
    <i> * @param args</i>
    <i> * @throws IOException</i>
    <i> */</i>
    public static void <strong>main</strong>(String[] args) throws IOException {
        new TestDialog().setVisible(true);
    }
&nbsp;
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Vyu¾ití tøídy <strong>BufferStrategy</strong> pro øízení double bufferingu</h2>

<p>Knihovna <i>Swing</i> sice provádí double buffering automaticky, ov¹em pøi
vykreslování prostøedí hry èi v&nbsp;dal¹ích situacích je vìt¹inou nutné pøední
a zadní buffer øídit programovì. K&nbsp;tomu slou¾í tøída nazvaná ponìkud
zvlá¹tnì <strong>BufferStrategy</strong>. Instance této tøídy se vytvoøí
zavoláním <strong>java.awt.Canvas.createBufferStrategy(int)</strong>
popø.&nbsp;(co¾ je asi ménì èasté) zavoláním metody
<strong>java.awt.Window.createBufferStrategy(int)</strong>. Celoèíselná
hodnota, která se tìmto metodám pøedává, reprezentuje celkový poèet bufferù.
Pøitom je zaruèeno, ¾e se daný poèet bufferù skuteènì vytvoøí, ale
v&nbsp;závislosti na mo¾nostech konkrétního poèítaèe nemusí být podporován
<i>page flipping</i> a dokonce ani akcelerované pøená¹ení obsahu zadního
bufferu do bufferu pøedního. Na to je zapotøebí dát pozor, proto¾e na mnoha
systémech není mo¾né vytvoøit více ne¾ dva akcelerované buffery a ¾ádost o
vytvoøení vìt¹ího mno¾ství bufferù zde tedy povede spí¹e ke sní¾ení celkového
výkonu.</p>

<p>Jakmile je nastaven double buffering, zmìní se i vykreslovací rutina,
proto¾e ta ji¾ nebude provádìt vykreslování pøímo na canvas, ale do zadního
bufferu:</p>

<pre>
BufferStrategy bufferStrategy = canvas.getBufferStrategy();
&nbsp;
while (!done) {
    Graphics graphics;
    try {
        graphics = bufferStrategy.getDrawGraphics();
        <i>... zde se provádí vykreslování ...</i>
        <i>... s vyu¾itím objektu "graphics" ...</i>
    } finally {
        graphics.dispose();
    }
    bufferStrategy.show();
}
</pre>

<p>Prakticky si tuto mo¾nost otestujeme pøí¹tì na dvojici demonstraèních
pøíkladù.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Repositáø se zdrojovými kódy obou dne¹ních demonstraèních pøíkladù</h2>

<p>Následují odkazy na zdrojové kódy ulo¾ené do Mercurial
repositáøe. V&nbsp;následující tabulce najdete linky na prozatím nejnovìj¹í
verze obou dnes popsaných demonstraèních pøíkladù:</p>

<table>
<tr><th>#</th><th>Zdrojový soubor/skript</th><th>Umístìní souboru v&nbsp;repositáøi</th></tr>
<tr><td>1</td><td>GraphicsDevicesTest2.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/086ce0554efb/jvm/gfx/GraphicsDevicesTest2.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/086ce0554efb/jvm/gfx/GraphicsDevicesTest2.java</a></td></tr>
<tr><td>2</td><td>TestDialog.java</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/086ce0554efb/jvm/gfx/TestDialog.java">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/086ce0554efb/jvm/gfx/TestDialog.java</a></td></tr>
<tr><td>3</td><td>java109.html (datový soubor)</td><td><a href="http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/086ce0554efb/jvm/gfx/java109.html">http://icedtea.classpath.org/people/ptisnovs/jvm-tools/file/086ce0554efb/jvm/gfx/java109.html</a></td></tr>
</table>



<p><a name="k11"></a></p>
<h2 id="k11">11. Odkazy na Internetu</h2>

<ol>

<li>Class BufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/image/BufferStrategy.html</a>
</li>

<li>Class Graphics<br />
<a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/Graphics.html">http://docs.oracle.com/javase/1.5.0/docs/api/java/awt/Graphics.html</a>
</li>

<li>Double Buffering and Page Flipping<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/doublebuf.html</a>
</li>

<li>BufferStrategy and BufferCapabilities<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/bufferstrategy.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/bufferstrategy.html</a>
</li>

<li>Java:Tutorials:Double Buffering<br />
<a href="http://content.gpwiki.org/index.php/Java:Tutorials:Double_Buffering">http://content.gpwiki.org/index.php/Java:Tutorials:Double_Buffering</a>
</li>

<li>Double buffer in standard Java AWT<br />
<a href="http://www.codeproject.com/Articles/2136/Double-buffer-in-standard-Java-AWT">http://www.codeproject.com/Articles/2136/Double-buffer-in-standard-Java-AWT</a>
</li>

<li>Java 2D: Hardware Accelerating - Part 1 - Volatile Images<br />
<a href="http://www.javalobby.org/forums/thread.jspa?threadID=16840&tstart=0">http://www.javalobby.org/forums/thread.jspa?threadID=16840&tstart=0</a>
</li>

<li>Java 2D: Hardware Accelerating - Part 2 - Buffer Strategies<br />
<a href="http://www.javalobby.org/java/forums/t16867.html">http://www.javalobby.org/java/forums/t16867.html</a>
</li>

<li>How does paintComponent work?<br />
<a href="http://stackoverflow.com/questions/15544549/how-does-paintcomponent-work">http://stackoverflow.com/questions/15544549/how-does-paintcomponent-work</a>
</li>

<li>A Swing Architecture Overview<br />
<a href="http://www.oracle.com/technetwork/java/architecture-142923.html">http://www.oracle.com/technetwork/java/architecture-142923.html</a>
</li>

<li>Class javax.swing.JComponent<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html</a>
</li>

<li>Class java.awt.Component<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html</a>
</li>

<li>Class java.awt.Component.BltBufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.BltBufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.BltBufferStrategy.html</a>
</li>

<li>Class java.awt.Component.FlipBufferStrategy<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.FlipBufferStrategy.html">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.FlipBufferStrategy.html</a>
</li>

<li>Metoda java.awt.Component.isDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html#isDoubleBuffered()">http://docs.oracle.com/javase/6/docs/api/java/awt/Component.html#isDoubleBuffered()</a>
</li>

<li>Metoda javax.swing.JComponent.isDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#isDoubleBuffered()">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#isDoubleBuffered()</a>
</li>

<li>Metoda javax.swing.JComponent.setDoubleBuffered()<br />
<a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#setDoubleBuffered(boolean)">http://docs.oracle.com/javase/6/docs/api/javax/swing/JComponent.html#setDoubleBuffered(boolean)</a>
</li>

<li>Javadoc - tøída GraphicsDevice<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsDevice.html</a>
</li>

<li>Javadoc - tøída GraphicsEnvironment<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsEnvironment.html</a>
</li>

<li>Javadoc - tøída GraphicsConfiguration<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html">http://docs.oracle.com/javase/7/docs/api/java/awt/GraphicsConfiguration.html</a>
</li>

<li>Javadoc - tøída DisplayMode<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html">http://docs.oracle.com/javase/7/docs/api/java/awt/DisplayMode.html</a>
</li>

<li>Lesson: Full-Screen Exclusive Mode API<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/">http://docs.oracle.com/javase/tutorial/extra/fullscreen/</a>
</li>

<li>Full-Screen Exclusive Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/exclusivemode.html</a>
</li>

<li>Display Mode<br />
<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/displaymode.html</a>
</li>

<li>Using the Full-Screen Exclusive Mode API in Java<br />
<a href="http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm">http://www.developer.com/java/other/article.php/3609776/Using-the-Full-Screen-Exclusive-Mode-API-in-Java.htm</a>
</li>

<li>Java quick guide: JVM Instruction Set (tabulka v¹ech instrukcí JVM)<br />
<a href="http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html">http://www.mobilefish.com/tutorials/java/java_quickguide_jvm_instruction_set.html</a>
</li>

<li>The JVM Instruction Set<br />
<a href="http://mpdeboer.home.xs4all.nl/scriptie/node14.html">http://mpdeboer.home.xs4all.nl/scriptie/node14.html</a>
</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>GC safe-point (or safepoint) and safe-region<br />
<a href="http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html">http://xiao-feng.blogspot.cz/2008/01/gc-safe-point-and-safe-region.html</a>
</li>

<li>Safepoints in HotSpot JVM<br />
<a href="http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html">http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html</a>
</li>

<li>Java theory and practice: Synchronization optimizations in Mustang<br />
<a href="http://www.ibm.com/developerworks/java/library/j-jtp10185/">http://www.ibm.com/developerworks/java/library/j-jtp10185/</a>
</li>

<li>How to build hsdis<br />
<a href="http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README">http://hg.openjdk.java.net/jdk7/hotspot/hotspot/file/tip/src/share/tools/hsdis/README</a>
</li>

<li>Java SE 6 Performance White Paper<br />
<a href="http://www.oracle.com/technetwork/java/6-performance-137236.html">http://www.oracle.com/technetwork/java/6-performance-137236.html</a>
</li>

<li>Lukas Stadler's Blog<br />
<a href="http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html">http://classparser.blogspot.cz/2010/03/hsdis-i386dll.html</a>
</li>

<li>How to build hsdis-amd64.dll and hsdis-i386.dll on Windows<br />
<a href="http://dropzone.nfshost.com/hsdis.htm">http://dropzone.nfshost.com/hsdis.htm</a>
</li>

<li>PrintAssembly<br />
<a href="https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly">https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly</a>
</li>

<li>The Java Virtual Machine Specification: 3.14. Synchronization<br />
<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14</a>
</li>

<li>The Java Virtual Machine Specification: 8.3.1.4. volatile Fields<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.4. Memory Model<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4</a>
</li>

<li>The Java Virtual Machine Specification: 17.7. Non-atomic Treatment of double and long<br />
<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.7</a>
</li>

<li>Open Source ByteCode Libraries in Java<br />
<a href="http://java-source.net/open-source/bytecode-libraries">http://java-source.net/open-source/bytecode-libraries</a>
</li>

<li>ASM Home page<br />
<a href="http://asm.ow2.org/">http://asm.ow2.org/</a>
</li>

<li>Seznam nástrojù vyu¾ívajících projekt ASM<br />
<a href="http://asm.ow2.org/users.html">http://asm.ow2.org/users.html</a>
</li>

<li>ObjectWeb ASM (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ObjectWeb_ASM">http://en.wikipedia.org/wiki/ObjectWeb_ASM</a>
</li>

<li>Java Bytecode BCEL vs ASM<br />
<a href="http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/">http://james.onegoodcookie.com/2005/10/26/java-bytecode-bcel-vs-asm/</a>
</li>

<li>BCEL Home page<br />
<a href="http://commons.apache.org/bcel/">http://commons.apache.org/bcel/</a>
</li>

<li>Byte Code Engineering Library (pøed verzí 5.0)<br />
<a href="http://bcel.sourceforge.net/">http://bcel.sourceforge.net/</a>
</li>

<li>Byte Code Engineering Library (verze &gt;= 5.0)<br />
<a href="http://commons.apache.org/proper/commons-bcel/">http://commons.apache.org/proper/commons-bcel/</a>
</li>

<li>BCEL Manual<br />
<a href="http://commons.apache.org/bcel/manual.html">http://commons.apache.org/bcel/manual.html</a>
</li>

<li>Byte Code Engineering Library (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/BCEL">http://en.wikipedia.org/wiki/BCEL</a>
</li>

<li>BCEL Tutorial<br />
<a href="http://www.smfsupport.com/support/java/bcel-tutorial!/">http://www.smfsupport.com/support/java/bcel-tutorial!/</a>
</li>

<li>Bytecode Engineering<br />
<a href="http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html">http://book.chinaunix.net/special/ebook/Core_Java2_Volume2AF/0131118269/ch13lev1sec6.html</a>
</li>

<li>Bytecode Outline plugin for Eclipse (screenshoty + info)<br />
<a href="http://asm.ow2.org/eclipse/index.html">http://asm.ow2.org/eclipse/index.html</a>
</li>

<li>Javassist<br />
<a href="http://www.jboss.org/javassist/">http://www.jboss.org/javassist/</a>
</li>

<li>Byteman<br />
<a href="http://www.jboss.org/byteman">http://www.jboss.org/byteman</a>
</li>

<li>Java programming dynamics, Part 7: Bytecode engineering with BCEL<br />
<a href="http://www.ibm.com/developerworks/java/library/j-dyn0414/">http://www.ibm.com/developerworks/java/library/j-dyn0414/</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>aspectj (Eclipse)<br />
<a href="http://www.eclipse.org/aspectj/">http://www.eclipse.org/aspectj/</a>
</li>

<li>Aspect-oriented programming (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Aspect_oriented_programming">http://en.wikipedia.org/wiki/Aspect_oriented_programming</a>
</li>

<li>AspectJ (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AspectJ">http://en.wikipedia.org/wiki/AspectJ</a>
</li>

<li>EMMA: a free Java code coverage tool<br />
<a href="http://emma.sourceforge.net/">http://emma.sourceforge.net/</a>
</li>

<li>Cobertura<br />
<a href="http://cobertura.sourceforge.net/">http://cobertura.sourceforge.net/</a>
</li>

<li>jclasslib bytecode viewer<br />
<a href="http://www.ej-technologies.com/products/jclasslib/overview.html">http://www.ej-technologies.com/products/jclasslib/overview.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2013</small></p>
</body>
</html>

