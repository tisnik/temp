<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Podpora instrukcí typu SIMD na mikroprocesorech ARM</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Podpora instrukcí typu SIMD na mikroprocesorech ARM</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o architekturách poèítaèù se opìt budeme zabývat popisem mikroprocesorù patøících do rodiny ARM. Zamìøíme se pøedev¹ím na popis SIMD instrukcí, které sice pùvodnì nebyly souèástí mikroprocesorù ARM, ale postupnì zaèaly být implementovány jako volitelná roz¹íøení do nìkterých mikroprocesorových jader.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Podpora instrukcí typu SIMD na mikroprocesorech ARM</a></p>
<p><a href="#k02">2. Nové instrukce urèené pro podporu zpracování signálù (DSP)</a></p>
<p><a href="#k03">3. Architektura NEON</a></p>
<p><a href="#k04">4. Nová sada pracovních registrù pou¾ívaných v&nbsp;jednotce NEON</a></p>
<p><a href="#k05">5. Instrukce typu Load &amp; Store</a></p>
<p><a href="#k06">6. Podpora SIMD instrukcí ve vy¹¹ích programovacích jazycích</a></p>
<p><a href="#k07">7. Podpora SIMD instrukcí pro &bdquo;hardcore&ldquo; programátory</a></p>
<p><a href="#k08">8. Interní funkce (intrinsic) nabízené pøekladaèem C a C++</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Podpora instrukcí typu SIMD na mikroprocesorech ARM</h2>

<p>Jak ji¾ bylo øeèeno v&nbsp;perexu èlánku, budeme se v&nbsp;dne¹ní èásti
seriálu o architekturách poèítaèù zabývat popisem zpùsobu implementace
<i>SIMD</i> instrukcí na mikroprocesorech <i>ARM</i>. Pøipomeòme si, ¾e
<i>SIMD</i> instrukce, tj.&nbsp;instrukce, pomocí nich¾ se aplikuje jedna
operace na vektor dat (vìt¹inou se jedná o dvojici vektorù pevné délky), zaèaly
být postupnì zavádìny na rùzných typech mikroprocesorù, a» ji¾ se jedná o
mikroprocesory s&nbsp;architekturou <i>CISC</i> (roz¹íøení instrukèní sady
<i>MMX</i>, <i>3DNow!</i>, <i>SSE</i>, <i>SSE2</i> atd. na platformì 80x86),
nebo naopak o mikroprocesory s&nbsp;architekturou <i>RISC</i> (roz¹íøení
instrukèní sady <i>MDMX/MaDMaX</i> a <i>MIPS-3D</i> na procesorech <i>MIPS</i>,
instrukèní sada <i>MAX-1</i> na mikroprocesorech <i>HP PA-RISC</i>, sada
<i>VIS</i> na mikroprocesorech <i>SPARC</i> atd.). Dokonce se dá s&nbsp;trochou
nadsázky øíci, ¾e témìø ka¾dý výrobce mikroprocesorù (snad s&nbsp;výjimkou
výrobcù osmibitových mikroøadièù) døíve èi pozdìji nabídl roz¹íøení pùvodní
instrukèní sady o instrukce typu <i>SIMD</i> a mikroprocesory <i>ARM</i>
v&nbsp;tomto ohledu nejsou výjimkou.</p>

<a href="http://i.iinfo.cz/images/311/pc158-5.png"><img src="http://i.iinfo.cz/images/311/pc158-5-prev.png" width="259" height="270" alt="&#160;" /></a>
<p><i>Obrázek 1: Schéma systému (mikroprocesoru) patøícího do kategorie SISD.
Jedna instrukce je vykonána pouze nad skalárními operandy.</i></p>

<p>Instrukce <i>SIMD</i> pøedstavují pouze jednou z&nbsp;mo¾ností zvý¹ení
výpoèetního výkonu mikroprocesorù. Dal¹í variantou jsou &ndash; podle pou¾ívané
<i>Flynnovy</i> klasifikace sekvenèních a paralelních systémù &ndash;
instrukce/architektura <i>MISD</i> vyu¾ívaná ve specializovaných aplikacích èi
nejobecnìj¹í architektura <i>MIMD</i>. Ve více ne¾ padesátileté historii vývoje
výpoèetní techniky se ji¾ objevily v¹echny ètyøi mo¾né kombinace instrukèního a
datového paralelismu. Viz té¾ následující tabulka:</p>

<table>
<tr><th>Zkratka klasifikace</th><th>Anglický význam zkratky</th><th>Vyu¾ití systémù s&nbsp;danou klasifikací</th></tr>
<tr><td>SISD</td><td>Single Instruction Stream, Single Data</td><td>klasická architektura pro procesory CISC a RISC</td></tr>
<tr><td>SIMD</td><td>Single Instruction Stream, Multiple Data</td><td>vektorové procesory, GPU, procesory s&nbsp;instrukèní sadou SSE/MMX...</td></tr>
<tr><td>MISD</td><td>Multiple Instructions Stream, Single Data Stream</td><td>pomìrnì speciální pøípady, øídicí poèítaèe raketoplánù (Space Shuttle)</td></tr>
<tr><td>MIMD</td><td>Multiple Instructions Stream, Multiple Data Stream</td><td>Connection Machine, transputery, symetrické multiprocesory</td></tr>
</table>

<a href="http://i.iinfo.cz/images/311/pc158-7.png"><img src="http://i.iinfo.cz/images/311/pc158-7-prev.png" width="205" height="270" alt="&#160;" /></a>
<p><i>Obrázek 2: Schéma systému patøícího do kategorie SIMD. Jedna instrukce
pracuje s&nbsp;vektorem èi vektory dat.</i></p>

<p>U¾iteèné odkazy na vybrané pøedchozí èásti tohoto seriálu:</p>

<ol>

<li>Vektorové procesory aneb dal¹í pokus o zvý¹ení výpoèetního výkonu poèítaèù<br />
<a href="http://www.root.cz/clanky/vektorove-procesory-aneb-dalsi-pokus-o-zvyseni-vypocetniho-vykonu-pocitacu/">http://www.root.cz/clanky/vektorove-procesory-aneb-dalsi-pokus-o-zvyseni-vypocetniho-vykonu-pocitacu/</a>
</li>

<li>SIMD instrukce vyu¾ívané v moderních mikroprocesorech øady x86<br />
<a href="http://www.root.cz/clanky/simd-instrukce-vyuzivane-v-modernich-mikroprocesorech-rady-x86/">http://www.root.cz/clanky/simd-instrukce-vyuzivane-v-modernich-mikroprocesorech-rady-x86/</a>
</li>

<li>SIMD instrukce v moderních mikroprocesorech øady x86 (2.èást: SSE)<br />
<a href="http://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-2-cast-sse/">http://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-2-cast-sse/</a>
</li>

<li>SIMD instrukce v moderních mikroprocesorech øady x86 (3.èást: SSE2)<br />
<a href="http://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-3-cast-sse2/">http://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-3-cast-sse2/</a>
</li>

<li>Instrukce typu SIMD na mikroprocesorech RISC<br />
<a href="http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc/">http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc/</a>
</li>

<li>Instrukce typu SIMD na mikroprocesorech RISC (2. èást)<br />
<a href="http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc-2-cast/">http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc-2-cast/</a>
</li>

<li>Instrukce typu SIMD na mikroprocesorech RISC (3.èást - MIPS-3D a VIS)<br />
<a href="http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc-3-cast-mips-3d-a-vis/">http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc-3-cast-mips-3d-a-vis/</a>
</li>

</ol>



<p><a name="k02"></a></p>
<h2 id="k02">2. Nové instrukce urèené pro podporu zpracování signálù (DSP)</h2>

<p>V&nbsp;pøedchozí èásti tohoto seriálu jsme se zamìøili na popis instrukèní
sady <i>VFP</i> neboli <i>Vector Floating Point</i>. Jedná se o instrukèní sadu
podporovanou nìkterými jádry <i>ARM</i>, v&nbsp;ní¾ jsou programátorùm
nabídnuty instrukce pro provádìní rùzných aritmetických a logických operací
s&nbsp;vektory èísel reprezentovaných v&nbsp;systému plovoucí øádové èárky
(<i>FP &ndash; Floating Point</i>). Na první pohled by se tedy mohlo zdát, ¾e
se jedná o jednu z&nbsp;mnoha aplikací architektury <i>SIMD</i>, ve skuteènosti
se ov¹em v&nbsp;pøípadì <i>VFP</i> vektory zpracovávají sekvenènì. To napøíklad
znamená, ¾e souèet dvou osmiprvkových vektorù realizovaný instrukcí
<strong>VADD</strong> pou¾ívá tu samou FP-sèítaèku a prvky vektorù jsou tedy
seèítány postupnì (u¹etøí se v¹ak èas na naètení a dekódování zbylých sedmi
instrukcí). Mikroprocesory <i>ARM</i> se ov¹em zaèaly vyu¾ívat i v&nbsp;oblasti
zpracování signálù, kde se vìt¹inou pracuje s&nbsp;celoèíselnými údaji
(<i>integer</i>), popø.&nbsp;s&nbsp;èísly s&nbsp;pevnou øádovou èárkou
(<i>fixed point</i>), s&nbsp;nimi¾ se v&nbsp;aritmeticko-logické jednotce
pracuje podobným zpùsobem jako s&nbsp;celými èísly.</p>

<a href="http://i.iinfo.cz/images/311/pc158-9.png"><img src="http://i.iinfo.cz/images/311/pc158-9-prev.png" width="275" height="270" alt="&#160;" /></a>
<p><i>Obrázek 3: Schéma systému patøícího do kategorie MISD.</i></p>

<p>Právì pro oblast zpracování signálù (<i>DSP</i>) a takté¾ pro implementaci
multimediálních aplikací bylo urèeno roz¹íøení pro <i>DSP</i> operace
v&nbsp;mikroprocesorech s&nbsp;jádrem <i>ARMv5TE</i>. Nové instrukce byly
vyu¾itelné napøíklad pøi kódování a dekódování videa, pøi zpracování zvukového
signálu (vèetnì zvukové syntézy), práci s&nbsp;rastrovými obrazy (<i>image
processing</i>) atd. Instrukce typu <i>Load &amp; Store</i> mohly pracovat
s&nbsp;registrovými páry, zavedeny byly nové adresovací re¾imy, aritmetika se
saturací (tj.&nbsp;bez pøeteèení) a takté¾ instrukce typu &bdquo;multiply and
accumulate (<strong>MAC</strong>)&ldquo; 16&times;16 bitù a 32&times;16 bitù,
které mohly být v&nbsp;instrukèní pipeline vykonány v&nbsp;rozmezí jednoho
taktu (v&nbsp;jejich prùbìhu se tedy mohly zaèít zpracovávat dal¹í instrukce).
Uvádí se, ¾e pøi zpracování signálù byla výkonnost nových instrukcí
v&nbsp;jádrech <i>ARMv5TE</i> dvakrát a¾ tøikrát vy¹¹í, ne¾ pøi pou¾ití
&bdquo;bì¾ných&ldquo; jader <i>ARMv5</i> (samozøejmì za pøedpokladu ruèní
optimalizace kódu, co¾ ostatnì a¾ na nìkteré výjimky platí dodnes).</p>

<a href="http://i.iinfo.cz/images/311/pc158-10.png"><img src="http://i.iinfo.cz/images/311/pc158-10-prev.png" width="222" height="270" alt="&#160;" /></a>
<p><i>Obrázek 4: Schéma systému patøícího do kategorie MIMD.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Architektura NEON</h2>

<p>Mo¾ná to nemusí být na první pohled patrné, ale instrukce typu <i>SIMD</i>
provádìné (pøedev¹ím) s&nbsp;jedním èi dvìma vektory celých èísel vlastnì velmi
dobøe zapadají do filozofie, na které jsou postaveny mikroprocesory <i>ARM</i>
&ndash; tato filozofie je zalo¾ena na dosa¾ení optimálního výpoèetního výkonu
za pøedpokladu, ¾e se nebude zbyteènì zvìt¹ovat poèet tranzistorù a tím pádem
ani spotøeba (pøíkon) èipu. Podívejme se napøíklad na typickou operaci
provádìnou pøi zpracování rastrového obrazu &ndash; zvý¹ení jasu celého obrazu
o nìjaký offset <i>n</i>. V&nbsp;pøípadì, ¾e jsou pixely ulo¾eny
v&nbsp;barvovém modelu RGB s&nbsp;osmi bity rezervovanými pro ka¾dou barvovou
slo¾ku, znamená to, ¾e se souèet s&nbsp;èíslem <i>n</i> musí provést
<i>width&times;height&times;3</i> krát (pro jednoduchost nyní pomiòme nutnost
provádìt souèet se saturací &ndash; bez pøeteèení &ndash; i fakt, ¾e se touto
operací mù¾e zmìnit barevný tón obrazu).</p>

<img src="http://i.iinfo.cz/images/51/pc140-11.png" width="256" height="256" alt=" " />
<p><i>Obrázek 5: Zdrojový rastrový obrázek (známá fotografie Lenny), který
tvoøí zdroj pro jednoduchý konvoluèní (FIR) filtr, jen¾ zvy¹uje hodnoty pixelù
o pevnì zadanou konstantu (offset).</i></p>

<p>Ov¹em pøi zmínìném provádìní souètu <i>width&times;height&times;3</i> krát
je 32bitová aritmeticko-logická jednotka vyu¾ita pouze z&nbsp;jedné ètvrtiny,
proto¾e výsledek souètu bude pouze osmibitový (devátý bit supluje pøeteèení).
Pokud by se v&nbsp;tomto pøípadì pou¾ily <i>SIMD</i> instrukce provádìjící
souèet ètyøprvkového vektoru osmibitových èísel (dohromady tedy 32bitového
slova), byla by aritmeticko-logická jednotka zcela vytí¾ena, ov¹em celkový
poèet operací souètu by se sní¾il na pouhou ètvrtinu &ndash; to ov¹em za
pøedpokladu, ¾e aritmeticko-logická jednotka bude relativnì snadno (=
s&nbsp;malým poètem nových tranzistorù) upravena na mo¾nost seèíst dvouprvkové
èi ètyøprvkové vektory.</p>

<img src="http://i.iinfo.cz/images/51/pc140-12.png" width="256" height="256" alt=" " />
<p><i>Obrázek 6: Pokud je pro pøiètení offsetu pou¾ita operace souètu se
zanedbáním pøenosu (carry), tj.&nbsp;kdy¾ se poèítá systémem &bdquo;modulo
N&ldquo;, dochází pøi pøekroèení maximální hodnoty pixelu (èistì bílá barva)
k&nbsp;jasnì viditelným chybám.</i></p>

<p>Není tedy divu, ¾e se instrukce typu <i>SIMD</i> postupnì na platformì
mikroprocesorù <i>ARM</i> roz¹iøovaly. Po ji¾ zmínìném jádru <i>ARMv5TE</i>
bylo dal¹í roz¹íøení o instrukce <i>SIMD</i> pou¾ito u nìkterých jader
<i>ARMv6</i>, kde zaèaly být podporovány napøíklad operace typu
<strong>MAC</strong> 32&times;32 bitù se zlomky (resp.&nbsp;s&nbsp;bitovým
posunem mezivýsledkù), aritmetické operace provádìné nad dvojicí registrù atd.
Oproti <i>ARMv5TE</i> byla výkonnost multimediálních aplikací pøibli¾nì
dvojnásobná. Ov¹em mnohem zajímavìj¹í je technologie <i>NEON</i>, která dosti
revoluèním zpùsobem mìní i konfiguraci interních blokù mikroprocesorù, zavádí
pøibli¾nì 100 nových instrukcí <i>SIMD</i> a takté¾ roz¹iøuje pùvodní sadu
pracovních registrù o 32 nových registrù, z&nbsp;nich¾ ka¾dý má ¹íøku 64 bitù.
Pøi návrhu technologie <i>NEON</i> se její tvùrci zamìøili na implementaci tìch
operací, které se v&nbsp;praxi skuteènì provádí, tak¾e je napøíklad pomìrnì
snadné (a pøedev¹ím efektivní) pracovat s&nbsp;rùznými formáty rastrových
bitmap, zpracovávat 16bitové zvukové vzorky pøi práci se stereo signálem
atd.</p>

<img src="http://i.iinfo.cz/images/51/pc140-13.png" width="256" height="256" alt=" " />
<p><i>Obrázek 7: Pøi pou¾ití operace souètu se saturací sice takté¾ dojde ke
ztrátì informace (vzniknou oblasti s&nbsp;pixely majícími hodnotu 255), ov¹em
viditelná chyba je mnohem men¹í, ne¾ na pøedchozím obrázku.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Nová sada pracovních registrù pou¾ívaných v&nbsp;jednotce NEON</h2>

<p>V&nbsp;rámci technologie <i>NEON</i> byla pùvodní sada registrù
mikroprocesorù <i>ARM</i> roz¹íøena o 32 nových 64bitových registrù nazvaných
<i>d0</i> a¾ <i>d31</i>. Tyto registry se mohou u nìkterých instrukcí sdru¾ovat
do párù a vytváøet tak sadu 128bitových registrù nazvaných <i>q0</i> a¾
<i>q15</i> (<i>d0+d1</i> vytvoøí registr <i>q0</i> atd.). V&nbsp;pøípadì, ¾e
daný mikroprocesor implementuje jak sadu <i>VFP</i>, tak i <i>NEON</i>, mohou
být registry mezi sebou sdíleny, co¾ mù¾e komplikovat souèasné provádìní
&bdquo;vektorových&ldquo; operací s&nbsp;FP hodnotami a s&nbsp;hodnotami
celoèíselnými. 64 èi 128bitové registry mohou podle typu provádìné instrukce
obsahovat operace rùzných typù. Technologie <i>NEON</i> podporuje vektory
obsahující osmibitové hodnoty (typicky napøíklad barvové slo¾ky pixelù),
16bitové hodnoty (zvukové vzorky), 32bitové hodnoty i hodnoty 64bitové &ndash;
podle potøeby se znaménkem (<i>signed</i>) i bez znaménka (<i>unsigned</i>).
Kromì toho mohou nìkteré instrukce pracovat i s&nbsp;32bitovými hodnotami
reprezentovanými v&nbsp;systému plovoucí øádové èárky (jedná se o standardní
datový typ <i>float/single</i>).</p>

<a href="http://i.iinfo.cz/images/311/pc158-8.jpg"><img src="http://i.iinfo.cz/images/311/pc158-8-prev.jpg" width="370" height="155" alt="&#160;" /></a>
<p><i>Obrázek 8: Vybrané typy vektorù, s&nbsp;nimi¾ pracují instrukce
NEON.</i></p>

<p>Dùvodù pro zavedení nových registrù existovalo nìkolik. Samozøejmì platí, ¾e
èím více obecných registrù je k&nbsp;dispozici, tím lehèí práci mají pøekladaèe
a tím ménì èasu musí mikroprocesor èekat na pomalou pamì» RAM, popø.&nbsp;na o
nìco rychlej¹í vyrovnávací pamì». Ov¹em záva¾nìj¹ím dùvodem je to, ¾e instrukce
zavedené v&nbsp;technologii <i>NEON</i> jsou v&nbsp;jednotce/modulu <i>NEON</i>
zpracovávány oddìlenì od ostatních instrukcí procesorù <i>ARM</i>. V¹e funguje
tak, ¾e je ka¾dá instrukce naètena do klasické pipeline procesorù <i>ARM</i> a
ve chvíli, kdy se rozpozná, ¾e se jedná o <i>SIMD</i> instrukci, je tato
instrukce vlo¾ena do krátké ¹estnáctiprvkové fronty instrukcí (délka fronty se
li¹í podle typu jádra) a z&nbsp;hlediska procesoru <i>ARM</i> je takto
&bdquo;odklonìná&ldquo; instrukce vlastnì ihned dokonèena, tak¾e jádro
<i>ARM</i> mù¾e ihned pokraèovat v&nbsp;provádìní dal¹ích bì¾ných instrukcí.
Jednotka <i>NEON</i> postupnì vybírá instrukce z&nbsp;ji¾ zmínìné 16prvkové
fronty a provádí je s&nbsp;vyu¾itím své sady registrù zcela oddìlenì od jádra
<i>ARM</i> (mimochodem &ndash; pipeline u jednotky <i>NEON</i> má typicky deset
øezù a nìkteré jednotky jsou zdvojené èi dokonce ztrojené, aby se dosáhlo
vy¹¹ího výpoèetního výkonu). Tato kooperace a paralelní bìh se zastaví ve
chvíli, kdy je fronta jednotky <i>NEON</i> zaplnìná, popø.&nbsp;se musí vymìnit
data mezi pracovními registry jádra <i>ARM</i> a registry jednotky
<i>NEON</i>.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Instrukce typu Load &amp; Store</h2>

<p>Ji¾ z&nbsp;mnoha pøedchozích èástí tohoto seriálu víme, ¾e mikroprocesory
s&nbsp;architekturou <i>RISC</i> jsou typické mj.&nbsp;i tím, ¾e se ve¹keré
operace provádí s&nbsp;hodnotami ulo¾enými v&nbsp;pracovních registrech a práce
s&nbsp;operaèní pamìtí je omezena pouze na instrukce typu <i>Load &amp;
Store</i>. Ve skuteènosti v¹ak mnohdy právì tyto instrukce provádí je¹tì nìjaké
pøedzpracování dat, popø.&nbsp;konverzi dat pøi ukládání. Typicky se u mnoha
RISCových procesorù mù¾e provádìt znaménkové roz¹íøení naèítaného operandu
(v&nbsp;pøípadì, ¾e bitová ¹íøka operandu je men¹í, ne¾ ¹íøka pracovních
registrù). Ov¹em u technologie <i>NEON</i> byly mo¾nosti instrukcí <i>Load
&amp; Store</i> pomìrnì významnì roz¹íøeny, proto¾e umo¾òují provádìt naètení
èi ulo¾ení vektorù s&nbsp;tím, ¾e prvky vektorù mohou být rùzným zpùsobem
pøeskládány èi konvertovány. Nejprve si øeknìme, ¾e pro naètení vektorù
(nìkolika prvkù) do vybraných registrù se pou¾ívá instrukce
<strong>VLD</strong> (<i>Vector LoaD</i>) a pro zpìtné ulo¾ení vektoru do
pamìti se pou¾ívá instrukce <strong>VST</strong> (<i>Vector STore</i>).</p>

<p>Podívejme se nyní na mo¾nosti, které programátorùm nabízí instrukce
<strong>VLD</strong>. Ta se v&nbsp;assembleru zapisuje podle následujícího
vzoru:</p>

<pre>
&nbsp;
VLD interleave.bits{seznam registrù}, adresa
&nbsp;
</pre>

<p>V&nbsp;tomto vzoru je pouze mnemotechnická zkratka instrukce
<strong>VLD</strong> nemìnná. Dal¹í (promìnné) údaje mají tento význam:</p>

<ul>

<li>Hodnota <i>interleave</i> mù¾e být nastavena na 1, 2, 3 èi 4. Pomocí této
hodnoty se urèuje &bdquo;mezera&ldquo; mezi dvìma prvky v&nbsp;pamìti, které
mají být ve výsledném vektoru ulo¾eny za sebou. Pøi pou¾ití <strong>VLD
1</strong> se prvky do vektoru naètou tak, jak jsou ulo¾eny v&nbsp;pamìti,
instrukce <strong>VLD 2</strong> se pou¾ívá tehdy, pokud jsou v&nbsp;pamìti
ulo¾eny zvukové vzorky v&nbsp;systému levý kanál:pravý kanál (zvukové vzorky),
instrukce <strong>VLD 3</strong> se vyu¾ívá u rastrových obrázkù ve formátu RGB
(dojde k&nbsp;extrakci barvových slo¾ek do tøí vektorù) a koneènì instrukce
<strong>VLD 4</strong> napøíklad u obrázkù ve formátu RGBA èi ARGB.</li>

<li>Hodnota <i>bits</i> urèuje poèet bitù rezervovaných pro ka¾dý prvek
vektoru. Podporované hodnoty jsou 8, 16 a 32.</li>

<li>V&nbsp;seznamu registrù mù¾e být umístìn jeden a¾ ètyøi pracovní registry
<strong>d0</strong> a¾ <strong>d31</strong>, v&nbsp;závislosti na hodnotách
<i>interleave</i> a <i>bits</i> (zápis vypadá takto: <strong>{d0,
d1}</strong>). Pøi pou¾ití <strong>VLD 1</strong> se naètou prvky do ètyø
specifikovaných registrù (neprovádí se ¾ádné prohazování prvkù), pøi
<strong>VLD 2</strong> se pou¾ívá dvojice registrù èi ètveøice registrù, pøi
<strong>VLD 3</strong> trojice pracovních registrù (první prvek bude naèten do
prvního registru, druhý do registru druhého, tøetí do tøetího, ètvrtý opìt do
prvního atd.) a pøi <strong>VLD 4</strong> se pou¾ívají ètyøi pracovní
registry.</li>

<li>Zbývá nám vysvìtlit význam <i>adresy</i>. Zde se vìt¹inou pou¾ívá nìkterý
pracovní registr <i>ARM</i>, napøíklad <strong>[r0]</strong> (pracovní registry
<i>NEON</i> vìt¹inou adresu neobsahují). Hodnotu tohoto registru lze buï pouze
beze zmìny vyu¾ít, nebo ji lze i inkrementovat a to buï o poèet skuteènì
naètených bajtù (nikoli o jednièku &ndash; to by nemìlo ¾ádný praktický
význam), nebo ji lze zvý¹it o hodnotu registru <i>Rm</i>, který mù¾e být takté¾
souèástí instrukce. Tato druhá mo¾nost se pou¾ívá napøíklad tehdy, pokud se
prochází dvourozmìrným polem po sloupcích a nikoli po øádcích (co to udìlá se
strukturou vyrovnávací pamìti je vìc druhá).</li>

</ul>

<p>Uka¾me si pro ilustraci dvì instrukce:</p>

<pre>
&nbsp;
; naètení ètyø 16bitových elementù do prvního registru (vektoru)
; naètení ètyø 16bitových elementù do registru druhého
; prolo¾ení 1:1
VLD2.16
&nbsp;
; naètení dvou 32bitových elementù do prvního registru (vektoru)
; naètení dvou 32bitových elementù do registru druhého
; prolo¾ení 1:1
VLD2.32
&nbsp;
</pre>

<p>Nyní si uká¾eme tro¹ku slo¾itìj¹í pøíklad &ndash; pøevod rastrového obrazu
z&nbsp;formátu RGB do formátu BGR, tj.&nbsp;prohození hodnoty R a B
v&nbsp;ka¾dém pixelu. Tuto relativnì èasto provádìnou operaci (viz rozdílné
formáty framebufferu) lze snadno provést pro osmici sousedních pixelù
spoleènì:</p>

<pre>
; registr r0 ukazuje na prvni bajt
; pixelu ulozeneho ve formatu BGR
&nbsp;
; nacteni RGB hodnot osmi pixelu
; barvove slozky jsou rozdeleny
; do trech pracovnich registru d0, d1 a d2
; + zmena adresy
vld3.8 {d0, d1, d2}, [r0]!
&nbsp;
; prohozeni barvovych slozek B a R
; (prohozeni vektoru ulozenych v d0 a d2
;  nezavisle na internim formatu)
&nbsp;
vswp d0, d2
&nbsp;
; registr r1 ukazuje na prvni bajt
; pixelu ulozeneho ve formatu RGB
&nbsp;
; zpetne slozeni barvovych slozek
; osmi pixelu, ktere byly rozdeleny
; + zmena adresy
vst3.8 {d0, d1, d2}, [r1]!
&nbsp;
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Podpora SIMD instrukcí ve vy¹¹ích programovacích jazycích</h2>

<p>Nové instrukce zavedené v&nbsp;rámci technologie <i>NEON</i> lze samozøejmì
vyu¾ívat pøedev¹ím pøímo v&nbsp;assembleru, co¾ je sice ta nejobtí¾nìj¹í
varianta, na druhou stranu v¹ak má programátor v&nbsp;tomto pøípadì mo¾nost
pøímo a do v¹ech podrobností ovlivnit výslednou podobu programu. Ov¹em naprostá
vìt¹ina programového kódu je v&nbsp;souèasnosti vytváøena ve vy¹¹ích
programovacích jazycích. Z&nbsp;tohoto dùvodu musí existovat nìjaká mo¾nost,
jak tyto nové instrukce ve vy¹¹ích programovacích jazycích vyu¾ívat.
Z&nbsp;hlediska programátora je nejjednodu¹¹í mo¾ností vyu¾ít ji¾ existující
odladìné a optimalizované knihovny implementované právì s&nbsp;pomocí
<i>SIMD</i> instrukcí, co¾ je vìt¹inou ideální øe¹ení v&nbsp;pøípadech, kdy
tyto knihovny ji¾ obsahují implementaci èasovì nejnároènìj¹ích èástí programù.
Mezi takové knihovny patøí v&nbsp;pøípadì mikroprocesorù <i>ARM</i> a
technologie <i>NEON</i> napøíklad knihovna <i>OpenMAX DL</i>, v&nbsp;ní¾ jsou
implementovány rùzné zvukové i video kodeky: èásti algoritmù pro komprimaci a
dekomprimaci pomocí <i>JPEG</i> (rastrové obrazy), <i>MP3</i> (zvuk),
<i>H.264</i> (AV kodek), <i>MPEG-4</i> (takté¾ AV kodek) atd.</p>

<p>Kromì tìchto algoritmù èi jejich èástí jsou v&nbsp;knihovnì <i>OpenMAX
DL</i> implementovány i funkce urèené pro filtraci a zpracování signálù,
pøedev¹ím <i>FIR</i>, <i>IIR</i> (èíslicové filtry s&nbsp;koneènou a nekoneènou
impulsní odezvou) a <i>FFT</i> (rychlá Fourierova transformace). <i>SIMD</i>
instrukce byly pou¾ity i pøi optimalizaci známé knihovny <i>Cairo</i> pro
procesory <i>ARM</i>, kde se napøíklad podaøilo zrychlit nìkteré operace
s&nbsp;rastrovým obrazem (<i>alpha blending</i>) a¾ osmkrát v&nbsp;porovnání se
&bdquo;sekvenèním&ldquo; øe¹ením (v&nbsp;pøípadì <i>Cairo</i> se v¹ak podle
mých informací ve¹keré optimalizace týkaly pouze úpravy nìkterých funkcí pro
práci s&nbsp;rastrovým obrazem; ne¹lo tedy o optimalizaci vìt¹iny funkcí, které
jsou v&nbsp;této pomìrnì rozsáhlé knihovnì implementovány).</p>

<p>U¾iteèné odkazy:</p>

<ol>

<li>Porovnání výkonnosti knihovny Cairo pøi SW renderingu:<br />
<a href="http://ssvb.github.com/2012/05/04/xorg-drivers-and-software-rendering.html">http://ssvb.github.com/2012/05/04/xorg-drivers-and-software-rendering.html</a>
</li>

<li>Dal¹í porovnání výkonnosti SW renderingu:<br />
<a href="http://people.freedesktop.org/~siamashka/files/20100216/pixman-0.17.6/">http://people.freedesktop.org/~siamashka/files/20100216/pixman-0.17.6/</a>
</li>

<li>Ne10: A New Open Source Library to Accelerate your Applications with NEON:<br />
<a href="http://blogs.arm.com/software-enablement/703-ne10-a-new-open-source-library-to-accelerate-your-applications-with-neon/">http://blogs.arm.com/software-enablement/703-ne10-a-new-open-source-library-to-accelerate-your-applications-with-neon/</a>
</li>

<li>Khronos Standards (odkazy na implementované knihovny):<br />
<a href="http://www.arm.com/community/multimedia/standards-apis.php">http://www.arm.com/community/multimedia/standards-apis.php</a>
</li>

</ol>



<p><a name="k07"></a></p>
<h2 id="k07">7. Podpora SIMD instrukcí pro &bdquo;hardcore&ldquo; programátory</h2>

<p>Dal¹í mo¾nost vyu¾ití instrukcí typu <i>SIMD</i> i z&nbsp;vy¹¹ích
programovacích jazykù spoèívá v&nbsp;takzvané automatické
&bdquo;vektorizaci&ldquo;. Pøekladaèe jazykù C a C++ (<i>GCC</i> u procesorù
<i>ARM</i>) toti¾ v&nbsp;nìkterých pøípadech doká¾ou rozpoznat, ¾e je mo¾né
nìjakou programovou smyèku provádìt nikoli èistì sekvenènì, ale s&nbsp;vyu¾itím
operací provádìných nad vektory. Programátor v¹ak musí v&nbsp;tìchto pøípadech
pøekladaèi vhodným zpùsobem &bdquo;napovìdìt&ldquo;, napøíklad tak, ¾e pøímo
v&nbsp;programu naznaèí, ¾e poèet cyklù ve smyèce bude za v¹ech okolností
dìlitelný ètyømi èi osmi atd. To nemusí být v¾dy úplnì jednoduché, u¾ jen
z&nbsp;toho dùvodu, ¾e jazyky C a C++ nepodporují zápis metadat do programu
(v&nbsp;Javì by to bylo umo¾nìno s&nbsp;vyu¾itím anotací). Podívejme se na
následující pøíklad, kde je pøi zápisu poèítané smyèky typu
<strong>for</strong> pøekladaèi céèka naznaèeno, ¾e poèet opakování smyèky bude
v¾dy dìlitelný ètyømi, resp.&nbsp;¾e poslední dva bity horní meze poèitadla
budou nulové (hodnota <strong>n</strong> je maskována èíslem, které má ve svých
dvou nejni¾¹ích bitech nuly):</p>

<pre>
&nbsp;
void add_offset_to_vector(int * __restrict px, int * __restrict py, int n, int offset)
{
    unsigned int i;
    for (i=0; i &lt; (n &amp; ~3); i++)
    {
        px[i] = py[i] + offset;
    }
}
&nbsp;
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Interní funkce (intrinsic) nabízené pøekladaèem C a C++</h2>

<p>Automatická &bdquo;vektorizace&ldquo; popsaná <a
href="#k07">v&nbsp;pøedchozí kapitole</a> v¹ak nedoká¾e (alespoò
v&nbsp;souèasnosti) vyu¾ít celého potenciálu technologie <i>NEON</i>.
Z&nbsp;tohoto dùvodu mohou programátoøi v&nbsp;pøípadì potøeby zavolat pøímo
z&nbsp;programù psaných v&nbsp;C èi C++ takzvané <a
href="http://en.wikipedia.org/wiki/Intrinsic_function">interní (intrinsic)</a>
funkce, tj.&nbsp;funkce, které jsou pøekladaèem spravovány speciálním zpùsobem.
Jejich pou¾ití se sice podobá volání bì¾né funkce, ve skuteènosti se v¹ak jedná
o makro, které pøekladaè vhodným zpùsobem expanduje do pou¾ití nìkteré
instrukce zavedené v&nbsp;technologii <i>NEON</i>. Pøíklad pou¾ití
<i>intrinsic</i> funkce je ukázán ní¾e na volání instrukce pro souèet dvou
vektorù. Ze zápisu je patrné, ¾e seèítané vektory (oba pøedstavované jednou
strukturou) obsahují 32bitová èísla bez znaménka (<i>unsigned</i>) a ¾e tyto
vektory jsou ulo¾ené ve 128bitovém registru <i>qx</i> (ten je, jak ji¾ víme,
sestaven z&nbsp;registrových párù <i>dn</i> a <i>d(n+1)</i>:</p>

<pre>
&nbsp;
#include &lt;arm_neon.h&gt;
&nbsp;
uint32x4_t double_elements(uint32x4_t input)
{ 
    return(vaddq_u32(input, input)); 
}
&nbsp;
</pre>

<p>Seznam v¹ech podporovaných intrinsic funkcí lze nalézt napøíklad na této
adrese:<br />
<a href="http://gcc.gnu.org/onlinedocs/gcc/ARM-NEON-Intrinsics.html">http://gcc.gnu.org/onlinedocs/gcc/ARM-NEON-Intrinsics.html</a></p>

<p>Poslední mo¾ností je samozøejmì ji¾ zmínìné vyu¾ití assembleru, a to buï
pøímo (èást funkcí bude zapsaná v&nbsp;assembleru a pøekládaná do objektového
kódu pomocí <i>GAS</i>) nebo s&nbsp;vyu¾itím inline assembleru zapisovaného
pøímo do tìla céèkových funkcí èi C++ových metod. Zde ji¾ samozøejmì dochází ke
ztrátì pøenositelnosti, která v&nbsp;pøedchozích pøípadech vlastnì zùstávala
zachována (i ona zmínìná instrukce <strong>vaddq_u32</strong> by toti¾ mohla
být pro úèely pøenositelnosti implementována jako bì¾né makro èi pøímo céèková
funkce pøi pøekladu na tìch mikroprocesorech, které nejsou technologií
<i>NEON</i> vybaveny).</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>The VFP architecture<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0056d/Bcfibfha.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0056d/Bcfibfha.html</a>
</li>

<li>NEON<br />
<a href="http://www.arm.com/products/processors/technologies/neon.php">http://www.arm.com/products/processors/technologies/neon.php</a>
</li>

<li>ARM Floating Point Accelerator (ARM FPA)<br />
<a href="http://vswww.kaist.ac.kr/ver4.0/index.php/research/past-research/arm-fpa.html">http://vswww.kaist.ac.kr/ver4.0/index.php/research/past-research/arm-fpa.html</a>
</li>

<li>Coding for NEON - Part 1: Load and Stores<br />
<a href="http://blogs.arm.com/software-enablement/161-coding-for-neon-part-1-load-and-stores/">http://blogs.arm.com/software-enablement/161-coding-for-neon-part-1-load-and-stores/</a>
</li>

<li>Coding for NEON - Part 2: Dealing With Leftovers<br />
<a href="http://blogs.arm.com/software-enablement/196-coding-for-neon-part-2-dealing-with-leftovers/">http://blogs.arm.com/software-enablement/196-coding-for-neon-part-2-dealing-with-leftovers/</a>
</li>

<li>Coding for NEON - Part 3: Matrix Multiplication<br />
<a href="http://blogs.arm.com/software-enablement/241-coding-for-neon-part-3-matrix-multiplication/">http://blogs.arm.com/software-enablement/241-coding-for-neon-part-3-matrix-multiplication/</a>
</li>

<li>Coding for NEON - Part 4: Shifting Left and Right<br />
<a href="http://blogs.arm.com/software-enablement/277-coding-for-neon-part-4-shifting-left-and-right/">http://blogs.arm.com/software-enablement/277-coding-for-neon-part-4-shifting-left-and-right/</a>
</li>

<li>DSP &amp; SIMD<br />
<a href="http://www.arm.com/products/processors/technologies/dsp-simd.php">http://www.arm.com/products/processors/technologies/dsp-simd.php</a>
</li>

<li>Improving ARM Code Density and Performance<br />
<a href="New Thumb Extensions to the ARM Architecture Richard Phelan">New Thumb Extensions to the ARM Architecture Richard Phelan</a>
</li>

<li>The ARM Processor Architecture<br />
<a href="http://www.arm.com/products/processors/technologies/instruction-set-architectures.php">http://www.arm.com/products/processors/technologies/instruction-set-architectures.php</a>
</li>

<li>Thumb-2 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html</a>
</li>

<li>Introduction to ARM thumb<br />
<a href="http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb">http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb</a>
</li>

<li>ARM, Thumb, and ThumbEE instruction sets<br />
<a href="http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm">http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm</a>
</li>

<li>An Introduction to ARM Assembly Language<br />
<a href="http://dev.emcelettronica.com/introduction-to-arm-assembly-language">http://dev.emcelettronica.com/introduction-to-arm-assembly-language</a>
</li>

<li>Processors - ARM<br />
<a href="http://www.arm.com/products/processors/index.php">http://www.arm.com/products/processors/index.php</a>
</li>

<li>The ARM Instruction Set<br />
<a href="http://simplemachines.it/doc/arm_inst.pdf">http://simplemachines.it/doc/arm_inst.pdf</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ARM_architecture">http://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>BBC BASIC<br />
<a href="http://www.bbcbasic.co.uk/bbcbasic.html">http://www.bbcbasic.co.uk/bbcbasic.html</a>
</li>

<li>BBC BASIC<br />
<a href="http://mdfs.net/Software/BBCBasic/">http://mdfs.net/Software/BBCBasic/</a>
</li>

<li>BBC BASIC (Z80) for the ZX Spectrum<br />
<a href="http://mdfs.net/Software/BBCBasic/Spectrum/">http://mdfs.net/Software/BBCBasic/Spectrum/</a>
</li>

<li>BBC BASIC (Wikipedia CZ)<br />
<a href="http://en.wikipedia.org/wiki/BBC_BASIC">http://en.wikipedia.org/wiki/BBC_BASIC</a>
</li>

<li>MIPS-3D(r) ASE<br />
<a href="http://www.mips.com/products/architectures/mips-3d-ase/">http://www.mips.com/products/architectures/mips-3d-ase/</a>
</li>

<li>An introduction to SPARC's SIMD offerings<br />
<a href="http://mikeburrell.wordpress.com/2007/12/14/an-introduction-to-sparcs-simd-offerings/">http://mikeburrell.wordpress.com/2007/12/14/an-introduction-to-sparcs-simd-offerings/</a>
</li>

<li>MIPS64<sup>TM</sup> Architecture for Programmers Volume IV-c: The MIPS-3D<sup>TM</sup> Application-Specific Extension to the MIPS64<sup>TM</sup><br />
<a href="http://www.weblearn.hs-bremen.de/risse/RST/docs/MIPS/MD00099-2B-MIPS3D64-AFP-01.11.pdf">http://www.weblearn.hs-bremen.de/risse/RST/docs/MIPS/MD00099-2B-MIPS3D64-AFP-01.11.pdf</a>
</li>

<li>Visual Instruction Set<br />
<a href="http://www.enotes.com/topic/Visual_Instruction_Set">http://www.enotes.com/topic/Visual_Instruction_Set</a>
</li>

<li>NEON<br />
<a href="http://www.arm.com/products/processors/technologies/neon.php">http://www.arm.com/products/processors/technologies/neon.php</a>
</li>

<li>Architecture and Implementation of the ARM Cortex-A8 Microprocessor<br />
<a href="http://www.design-reuse.com/articles/11580/architecture-and-implementation-of-the-arm-cortex-a8-microprocessor.html">http://www.design-reuse.com/articles/11580/architecture-and-implementation-of-the-arm-cortex-a8-microprocessor.html</a>
</li>

<li>Multimedia Acceleration eXtensions (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Multimedia_Acceleration_eXtensions">http://en.wikipedia.org/wiki/Multimedia_Acceleration_eXtensions</a>
</li>

<li>AltiVec (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AltiVec">http://en.wikipedia.org/wiki/AltiVec</a>
</li>

<li>Visual Instruction Set (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Visual_Instruction_Set">http://en.wikipedia.org/wiki/Visual_Instruction_Set</a>
</li>

<li>MAJC (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/MAJC">http://en.wikipedia.org/wiki/MAJC</a>
</li>

<li>MDMX (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/MDMX">http://en.wikipedia.org/wiki/MDMX</a>
</li>

<li>MIPS Multiply Unit<br />
<a href="http://programmedlessons.org/AssemblyTutorial/Chapter-14/ass14_3.html">http://programmedlessons.org/AssemblyTutorial/Chapter-14/ass14_3.html</a>
</li>

<li>Silicon Graphics Introduces Enhanced MIPS Architecture<br />
<a href="http://bwrc.eecs.berkeley.edu/CIC/otherpr/enhanced_mips.html">http://bwrc.eecs.berkeley.edu/CIC/otherpr/enhanced_mips.html</a>
</li>

<li>MIPS-3D (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/MIPS-3D">http://en.wikipedia.org/wiki/MIPS-3D</a>
</li>

<li>MIPS Technologies, Inc. announces new MIPS-3D technology to provide silicon-efficient 3D graphics acceleration<br />
<a href="http://www.design-reuse.com/news/2057/mips-mips-3d-technology-silicon-efficient-3d-graphics-acceleration.html">http://www.design-reuse.com/news/2057/mips-mips-3d-technology-silicon-efficient-3d-graphics-acceleration.html</a>
</li>

<li>MIPS-3D Built-in Function (gcc.gnu.org)<br />
<a href="http://gcc.gnu.org/onlinedocs/gcc/MIPS_002d3D-Built_002din-Functions.html">http://gcc.gnu.org/onlinedocs/gcc/MIPS_002d3D-Built_002din-Functions.html</a>
</li>

<li>Baha Guclu Dundar:<br />
Intel MMX, SSE, SSE2, SSE3/SSSE3/SSE4 Architectures
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>Intel MMX<sup>TM</sup> Technology Overview<br />
Intel corporation, 1996</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>
</li>

<li>AMD K5 ("K5" / "5k86")<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g5K5-c.html">http://www.pcguide.com/ref/cpu/fam/g5K5-c.html</a>
</li>

<li>Sixth Generation Processors<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g6.htm">http://www.pcguide.com/ref/cpu/fam/g6.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Very_long_instruction_word">http://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>Tour of the Black Holes of Computing!: Floating Point<br />
<a href="http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt">http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt</a>
</li>

<li>3Dnow! Technology Manual<br />
AMD Inc., 2000</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>Control unit (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Control_unit">http://en.wikipedia.org/wiki/Control_unit</a>
</li>

<li>Cray History<br />
<a href="http://www.cray.com/About/History.aspx?404;http://www.cray.com:80/about_cray/history.html">http://www.cray.com/About/History.aspx?404;http://www.cray.com:80/about_cray/history.html</a>
</li>

<li>Cray Historical Timeline<br />
<a href="http://www.cray.com/Assets/PDF/about/CrayTimeline.pdf">http://www.cray.com/Assets/PDF/about/CrayTimeline.pdf</a>
</li>

<li>Computer Speed Claims 1980 to 1996<br />
<a href="http://homepage.virgin.net/roy.longbottom/mips.htm">http://homepage.virgin.net/roy.longbottom/mips.htm</a>
</li>

<li>Superpoèítaèe Cray<br />
<a href="http://www.root.cz/clanky/superpocitace-cray/">http://www.root.cz/clanky/superpocitace-cray/</a>
</li>

<li>Superpoèítaèe Cray (druhá èást)<br />
<a href="http://www.root.cz/clanky/superpocitace-cray-druha-cast/">http://www.root.cz/clanky/superpocitace-cray-druha-cast/</a>
</li>

<li>Superpoèítaèe Cray (tøetí èást)<br />
<a href="http://www.root.cz/clanky/superpocitace-cray-treti-cast/">http://www.root.cz/clanky/superpocitace-cray-treti-cast/</a>
</li>

<li>Superpoèítaèe Cray (ètvrtá èást)<br />
<a href="http://www.root.cz/clanky/superpocitace-cray-ctvrta-cast/">http://www.root.cz/clanky/superpocitace-cray-ctvrta-cast/</a>
</li>

<li>Superpoèítaèe Cray (pátá èást): architektura Cray X-MP<br />
<a href="http://www.root.cz/clanky/superpocitace-cray-pata-cast-architektura-pocitace-cray-x-mp-a-jeho-pouziti-ve-filmovem-prumyslu/">http://www.root.cz/clanky/superpocitace-cray-pata-cast-architektura-pocitace-cray-x-mp-a-jeho-pouziti-ve-filmovem-prumyslu/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

