<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Mikroprocesory ARM a instrukèní sada Thumb - dokonèení</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Mikroprocesory ARM a instrukèní sada Thumb - dokonèení</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o architekturách poèítaèù dokonèíme popis instrukèní sady Thumb, která mù¾e být pou¾ita u novìj¹ích mikroprocesorù s architekturou ARM. Minule jsme si popsali formát aritmetických a logických instrukcí i instrukcí skoku, dnes se zamìøíme pøedev¹ím na instrukce typu Load &amp; Store, tj. na instrukce urèené pro pøenos dat mezi registry a operaèní pamìtí.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Naètení èi ulo¾ení 32bitových slov s&nbsp;vyu¾itím adresy ve tvaru báze:offset</a></p>
<p><a href="#k02">2. Souèasné naètení èi ulo¾ení vìt¹ího mno¾ství pracovních registrù</a></p>
<p><a href="#k03">3. Práce s&nbsp;jednotlivými bajty + konverze</a></p>
<p><a href="#k04">4. Naètení èi ulo¾ení bajtu se znaménkovým roz¹íøením na 32bitové slovo</a></p>
<p><a href="#k05">5. Práce se 16bitovými slovy</a></p>
<p><a href="#k06">6. Relativní adresování vyu¾ívající PC (Program Counter)</a></p>
<p><a href="#k07">7. Relativní adresování vyu¾ívající SP (Stack Pointer)</a></p>
<p><a href="#k08">8. Instrukèní sada Thumb: shrnutí</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Naètení èi ulo¾ení 32bitových slov s&nbsp;vyu¾itím adresy ve tvaru báze:offset</h2>

<p>V&nbsp;pøedchozí èásti <a
href="http://www.root.cz/serialy/co-se-deje-v-pocitaci/">seriálu o
architekturách poèítaèù</a> jsme si popsali velké mno¾ství instrukcí patøících
do instrukèní sady <i>Thumb</i>. Pøipomeòme si, ¾e se jedná o alternativní
instrukèní sadu mikroprocesorù <i>ARM</i>, která byla navr¾ena s&nbsp;ohledem
na dosa¾ení co nejvìt¹í hustoty kódu a tím pádem i s&nbsp;ohledem na lep¹í
vyu¾ití vyrovnávacích pamìtí (cache). Tato sada navíc vznikla na základì
analýzy strojových kódù generovaných pøekladaèi, tak¾e v&nbsp;ní mù¾eme najít
mno¾ství instrukcí zvolených èistì pragmaticky (tím se instrukèní sada
<i>Thumb</i> odli¹uje od pùvodní RISCové sady <i>ARM</i>).</p>

<p>Mezi základní instrukce typu <i>Load &amp; Store</i> patøí na RISCových
mikroprocesorech s&nbsp;architekturou <i>ARM</i> instrukce urèené pro pøenos
32bitových slov mezi vybraným pracovním registrem a operaèní pamìtí. Vzhledem
k&nbsp;tomu, ¾e v&nbsp;16bitových instrukèních slovech instrukèní sady
<i>Thumb</i> je prakticky nemo¾né vyhradit dostateèný poèet bitù pro ulo¾ení
adresy nebo její významné èásti, vyu¾ili autoøi instrukèní sady <i>Thumb</i>
pro adresování obsah nìkterého z&nbsp;pracovních registrù. Pøi studiu reálných
programù (èi pøesnìji øeèeno jejich strojového kódu) si navíc tvùrci ISA
pov¹imli, ¾e se v&nbsp;kódech velmi èasto vyskytují operace pracující
s&nbsp;prvky pole a/nebo datovými polo¾kami sdru¾enými do <i>záznamù (struct,
record)</i>. V&nbsp;tìchto pøípadech je vhodné, aby se adresa místa
v&nbsp;pamìti skládala ze dvou èástí: <i>báze</i> a <i>offsetu</i>.
V&nbsp;pøípadì polí je jako <i>báze</i> zvolena adresa prvního prvku
v&nbsp;poli, v&nbsp;pøípadì datových struktur/záznamù se takté¾ jedná o adresu
první polo¾ky. <i>Offset</i> potom mù¾e odpovídat napøíklad indexu prvku
v&nbsp;poli (po bitovém posunu). Pro adresování ve tvaru <i>báze:offset</i> se
pou¾ívá následující formát instrukèního slova:</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 1 | 0 | 1 | L | 0 | 0 |    Ro     |    Rb     |    Rd     |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>

<p>Z&nbsp;vý¹e uvedeného formátu instrukèního slova je patrné, ¾e instrukce
<i>Load &amp; Store</i> pou¾ívají tøi pracovní registry, pøesnìji øeèeno
registry z&nbsp;&bdquo;dolní&ldquo; skupiny <strong>R0</strong> a¾
<strong>R7</strong>. Význam v¹ech tøí registrù je popsán v&nbsp;tabulce:</p>

<table>
<tr><th>Registr</th><th>Význam</th></tr>
<tr><td>Rb</td><td>registr obsahující 32bitovou bázovou adresu</td></tr>
<tr><td>Ro</td><td>registr obsahující 32bitový offset</td></tr>
<tr><td>Rd</td><td>registr, který se má ulo¾it èi naèíst z/do pamìti</td></tr>
</table>

<p>Pøi podrobnìj¹ím pohledu na formát instrukèního slova objevíme kromì
konstantních bitù a bitù rezervovaných pro ulo¾ení indexù pou¾itých registrù
je¹tì bit s&nbsp;indexem 11 (<strong>L</strong>), pomocí nìho¾ je urèeno, zda
se má obsah pracovního registru <strong>Rd</strong> naèíst (<i>Load</i>)
z&nbsp;operaèní pamìti, konkrétnì z&nbsp;adresy <i>báze+offset</i>, èi zda se
naopak jeho obsah má ulo¾it (<i>Store</i>) do operaèní pamìti:</p>

<table>
<tr><th>Bit 11 (L)</th><th>Význam</th></tr>
<tr><td>0</td><td>Store &ndash; ulo¾ení registru do operaèní pamìti</td></tr>
<tr><td>1</td><td>Load &ndash; naètení registru z&nbsp;pamìti RAM èi ROM</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Souèasné naètení èi ulo¾ení vìt¹ího mno¾ství pracovních registrù</h2>

<p>Instrukèní sada <i>Thumb</i> obsahuje i instrukce, pomocí nich¾ je mo¾né
ulo¾it èi naopak naèíst celou øadu vybraných pracovních registrù, nikoli pouze
registr jediný. Zatímco u 32bitové instrukèní sady <i>ARM</i> byly pro tento
úèel vyhrazeny instrukce <strong>LDM</strong> a <strong>STM</strong>, které
pracovaly se v¹emi ¹estnácti pracovními registry, je u instrukèní sady
<i>Thumb</i> ze zøejmých dùvodù pou¾ito pouze prvních osm registrù (dùvodem je
to, ¾e v&nbsp;16bitovém instrukèním slovu prostì není místo na ulo¾ení
16bitového pole obsahujícího seznam registrù, s&nbsp;nimi¾ se má pracovat).
Vra»me se v¹ak k&nbsp;instrukèní sadì <i>Thumb</i>, v&nbsp;ní¾ najdeme
instrukce <strong>LDMIA</strong> a <strong>STMIA</strong>. Tyto instrukce
obsahují ve svém instrukèním slovu index registru, v&nbsp;nìm¾ je ulo¾ena
bázová adresa a takté¾ je zde umístìno osmibitové pole obsahující jednièku u
tìch registrù, které se skuteènì mají ulo¾it do pamìti èi se naopak mají
z&nbsp;pamìti naèíst. Formát instrukèního slova instrukcí
<strong>LDMIA</strong> a <strong>STMIA</strong> vypadá následovnì:</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 0 | 0 | L |    Rd     |        seznam registrù        |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>

<p>Do spodních osmi bitù instrukèního slova se ukládají pøíznaky odpovídající
pracovním registrùm <strong>R0</strong> a¾ <strong>R7</strong>. Pokud je bit
s&nbsp;indexem <i>n</i> nastaven na jednièku, je instrukce <i>Load/Store</i>
provedena i s&nbsp;registrem <strong>Rn</strong>. Poøadí registrù v¹ak není
mo¾né mìnit, lze pouze urèit, které registry se budou operace úèastnit.</p>

<p>Podobnì jako u instrukcí popsaných v&nbsp;pøedchozí kapitole, i zde je
pomocí bitu 11 (<strong>L</strong>) urèeno, zda se jedná o instrukci typu
<i>Load</i> èi naopak o instrukci typu <i>Store</i>:</p>

<table>
<tr><th>Bit 11 (L)</th><th>Význam</th></tr>
<tr><td>0</td><td>Store &ndash; ulo¾ení registrù (urèených bitovým polem) do pamìti</td></tr>
<tr><td>1</td><td>Load &ndash; naètení registrù (urèených bitovým polem) z&nbsp;pamìti</td></tr>
</table>

<p>Pøipomeòme si, ¾e podobný formát instrukèního slova mù¾eme najít i u
instrukcí typu <i>push</i> a <i>pop</i>, které jsme si ji¾ popsali <a
href="http://www.root.cz/clanky/mikroprocesory-arm-a-instrukcni-sada-thumb/#k08">v&nbsp;osmé
kapitole pøedchozí èásti tohoto seriálu</a>. Jednalo se o následující
formát:</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 0 | 1 | 1 | L | 1 | 0 | R |        seznam registrù        |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

L: 0 - push
   1 - pop
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Práce s&nbsp;jednotlivými bajty + konverze</h2>

<p>Jak jsme si ji¾ øekli v&nbsp;úvodní kapitole, byla instrukèní sada
<i>Thumb</i> navr¾ena dosti pragmaticky s&nbsp;ohledem na co nejlep¹í uplatnìní
v&nbsp;praxi. Proto mo¾ná není divu, ¾e v&nbsp;ní najdeme i instrukce typu
<i>Load &amp; Store</i>, které je mo¾né pou¾ít pro manipulaci
s&nbsp;jednotlivými bajty. Puristé by sice mo¾ná prohlásili, ¾e tyto instrukce
k&nbsp;procesorùm s&nbsp;architekturou <i>RISC</i> nepatøí (a mìli by èásteènì
pravdu!), pøi tvorbì aplikací se v¹ak ukazuje, ¾e mnoho dat je a bude stále
organizováno po bajtech &ndash; jedná se napøíklad o ASCII øetìzce, øetìzce
kódované v&nbsp;UTF-8, hodnoty pixelù (barvové slo¾ky Red/Green/Blue a
prùhlednost Alpha) atd. Aritmetické a logické instrukce sice stále zpracovávají
pouze 32bitové operandy, ov¹em data naèítaná z&nbsp;operaèní pamìti mohou mít
jiný formát. Nejjednodu¹¹ími instrukcemi typu <i>Load &amp; Store</i>, které
doká¾ou pracovat s&nbsp;jednotlivými bajty, jsou instrukce
<strong>LDRB</strong> (<i>Load Byte</i>) a <strong>STRB</strong> (<i>Store
Byte</i>), v&nbsp;nich¾ se neprovádí znaménkové roz¹íøení hodnoty bajtu na celé
32bitové èíslo. Tyto instrukce mají následující formát, který se vlastnì
prakticky vùbec neli¹í od formátu instrukcí uvedeného v&nbsp;pøedchozí kapitole
(zmìnil se jen obsah jediného bitu, konkrétnì bitu èíslo 10):</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 1 | 0 | 1 | L | 1 | 0 |    Ro     |    Rb     |    Rd     |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>

<p>Význam v¹ech bitových polí instrukèního slova zùstává zachován, tj.:</p>

<table>
<tr><th>Registr</th><th>Význam</th></tr>
<tr><td>Rb</td><td>registr obsahující 32bitovou bázovou adresu bajtu</td></tr>
<tr><td>Ro</td><td>registr obsahující 32bitový offset bajtu</td></tr>
<tr><td>Rd</td><td>registr, jeho¾ spodních osm bitù se má ulo¾it èi naèíst z/do pamìti</td></tr>
</table>

<table>
<tr><th>Bit 11 (L)</th><th>Význam</th></tr>
<tr><td>0</td><td>Store &ndash; ulo¾ení spodních osmi bitù registru Rd do pamìti</td></tr>
<tr><td>1</td><td>Load &ndash; naètení bajtu z&nbsp;pamìti a ulo¾ení do spodních osmi bitù registru Rd</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Naètení èi ulo¾ení bajtu se znaménkovým roz¹íøením na 32bitové slovo</h2>

<p>Ji¾ <a href="#k03">v&nbsp;pøedchozí kapitole</a> jsme se zmínili o tom, ¾e
aritmeticko-logická jednotka mikroprocesorù <i>ARM</i> doká¾e pracovat pouze
s&nbsp;32bitovými operandy. Vzhledem k&nbsp;tomu, ¾e s&nbsp;vyu¾itím instrukcí
<strong>LDRB</strong> a <strong>STRB</strong> lze z&nbsp;ka¾dého 32bitového
registru získat pouze jeho spodních osm bitù, mohlo by se zdát, ¾e nám toto
omezení v&nbsp;praxi nebude nijak vadit. To je sice, pravda, ale pouze
v&nbsp;pøípadì, ¾e se pracuje s&nbsp;bajty obsahujícími celá èísla bez znaménka
(0..255), ASCII kódy znakù atd. Problémy by ov¹em mohly nastat napøíklad tehdy,
pokud by bylo nutné pracovat s&nbsp;bajty, v&nbsp;nich¾ je ulo¾ena celoèíselná
hodnota se znaménkem (-128..127). V&nbsp;tomto pøípadì je toti¾ nutné, aby se
pøi naètení bajtu provedlo takzvané <i>znaménkové roz¹íøení</i> na ¹íøku 32
bitù. Znaménkové roz¹íøení se provádí následovnì: v&nbsp;naèítaném bajtu je
znaménko ulo¾eno v&nbsp;nejvy¹¹ím bitu, tj.&nbsp;bitu s&nbsp;indexem 7. Hodnota
tohoto bitu je následnì zkopírována do bitù 8 a¾ 31. To znamená, ¾e pokud je
naètena hodnota 0..127, jsou bity 8 a¾ 31 nulové (a bit 7 samozøejmì taky),
v&nbsp;opaèném pøípadì je bit 7 nastavený na jednièku, která je zkopírována i
do bitù 8 a¾ 31.</p>

<p>Pøíslu¹ná instrukce, která provede naètení bajtu z&nbsp;operaèní pamìti
spoleènì se znaménkovým roz¹íøením, má název <strong>LDSB</strong> (<i>Load
Sign-extended Byte</i>), a formát jejího instrukèního slova vypadá
následovnì:</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 1 | 0 | 1 | 0 | 1 | 1 |    Ro     |    Rb     |    Rd     |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>

<p>Význam registrù <strong>Ro</strong>, <strong>Rb</strong> a
<strong>Rd</strong> zùstává zachován:</p>

<table>
<tr><th>Registr</th><th>Význam</th></tr>
<tr><td>Rb</td><td>registr obsahující 32bitovou bázovou adresu</td></tr>
<tr><td>Ro</td><td>registr obsahující 32bitový offset</td></tr>
<tr><td>Rd</td><td>registr, do nìho¾ se ulo¾í bajt pøeètený z&nbsp;operaèní pamìti, který je znaménkovì roz¹íøen</td></tr>
</table>

<p><ins>Poznámka: pov¹imnìte si, ¾e k&nbsp;instrukci <strong>LDSB</strong>
neexistuje ekvivalentní instrukce <strong>STSB</strong>. To ve skuteènosti ani
není nutné, proto¾e pro ulo¾ení bajtu obsahujícího hodnotu se znaménkem lze
vyu¾ít instrukci <strong>STRB</strong> popsanou v&nbsp;pøedchozí kapitole (pøi
ukládání toti¾ není nutné provádìt ¾ádné konverze, tj.&nbsp;ani manipulaci
s&nbsp;ukládanými bity).</ins></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Práce se 16bitovými slovy</h2>

<p>Vzhledem k&nbsp;tomu, ¾e jsme si ji¾ popsali instrukce pro naètení èi
ulo¾ení 32bitových slov i instrukce pro naètení èi ulo¾ení jednotlivých bajtù,
asi ka¾dého ètenáøe napadne, jak je tomu s&nbsp;16bitovými daty. I tato data se
v&nbsp;praxi velmi èasto pou¾ívají (nasamplované zvuky, znaky v&nbsp;kódování
<i>USC-2</i> èi <i>UTF-16</i>, èíselné hodnoty typu <i>short int</i> atd.
atd.), proto asi není ¾ádným pøekvapením, ¾e se v&nbsp;instrukèní sadì
<i>Thumb</i> setkáme i s&nbsp;instrukcemi, které umo¾òují pracovat se slovy
majícími ¹íøku ¹estnáct bitù. Jedná se o trojici instrukcí
<strong>LDRH</strong> (<i>Load Halfword</i>), <strong>STRH</strong> (<i>Store
Halfword</i>) a <strong>LDSH</strong> (<i>Load Sign-extended Halfword</i>).
Instrukèní slovo pro v¹echny tøi instrukce má stejný tvar:</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 1 | 0 | 1 | H | S | 1 |    Ro     |    Rb     |    Rd     |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>

<p>Význam registrù <strong>Ro</strong>, <strong>Rb</strong> a
<strong>Rd</strong> se nemìní, proto si ho zde ji¾ nebudeme uvádìt.</p>

<p>Pomocí bitù 10 (<strong>S</strong>) a 11 (<strong>H</strong>) je urèeno, o
kterou instrukci se má jednat:</p>

<table>
<tr><th>Bit H</th><th>Bit S</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>0</td><td>0</td><td>STRH</td><td>Store Halfword</td></tr>
<tr><td>0</td><td>1</td><td>LDRH</td><td>Load Halfword</td></tr>
<tr><td>1</td><td>1</td><td>LDSH</td><td>Load Sign-extended Halfword</td></tr>
</table>

<p>Poslední kombinace bitù <strong>H</strong> a <strong>S</strong>, kterou jsme
si v&nbsp;pøedchozí tabulce neuvedli, je ve skuteènosti vyu¾ita pro instrukci
<strong>LDSB</strong>, je¾ byla popsána v&nbsp;pøedchozí kapitole.</p>

<p><ins>Poznámka: opìt platí, ¾e po naètení 16bitového slova do pracovního
registru jsou ji¾ v¹echny aritmetické i logické operace provádìny s&nbsp;plnou
¹íøkou 32 bitù, podobnì jako tomu bylo u pùvodnì osmibitových hodnot.</ins></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Relativní adresování vyu¾ívající PC (Program Counter)</h2>

<p>Ji¾ v&nbsp;pøedchozích èástech tohoto seriálu jsme se zmínili o urèitém
problému, který nastane v&nbsp;tom pøípadì, kdy se má do nìjakého pracovního
registru ulo¾it nová 32bitová konstanta. Tento problém spoèívá v&nbsp;tom, ¾e
&ndash; na rozdíl od mnoha procesorù s&nbsp;architekturou typu <i>CISC</i>
&ndash; není mo¾né mít ihned za instrukcí (instrukèním slovem) ulo¾enou
pøíslu¹nou 32bitovou konstantu, která by se do zvoleného pracovního registru
mohla naèíst. V&nbsp;mnoha pøípadech lze sice vyu¾ít naètení krátké konstanty
umístìné pøímo v&nbsp;instrukèním slovu (viz té¾ <a
href="http://www.root.cz/clanky/mikroprocesory-arm-a-instrukcni-sada-thumb/">minule
popsané</a> <a
href="http://www.root.cz/clanky/mikroprocesory-arm-a-instrukcni-sada-thumb/#k03">tøíbitové
a osmibitové konstanty</a> pou¾ívané v&nbsp;nìkterých ALU instrukcích), ov¹em
nìkdy to není mo¾né, proto¾e je nutné pracovat s&nbsp;vìt¹í konstantou. Zde
programátorùm a pøekladaèùm pøichází na pomoc instrukce <strong>LDR Rd,
[PC+#offset]</strong>, která pro adresování druhého operandu (konstanty
v&nbsp;pamìti) vyu¾ívá obsah registru <strong>PC/R15</strong> a <i>offset</i>.
Konstanta toti¾ mù¾e být ulo¾ena spoleènì s&nbsp;programovým kódem, ale nikoli
pøímo za instrukèním slovem, ale napøíklad a¾ ZA koncem subrutiny èi
v&nbsp;nìkterých pøípadech ihned za instrukcemi skoku. Instrukce <strong>LDR
Rd, [PC+#offset]</strong> má následující formát:</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 1 | 0 | 0 | 1 |    Rd     |             offset            |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>

<p>V&nbsp;bitech 8 a¾ 10 je ulo¾en index pracovního registru, do nìho¾ se má
konstanta naèíst. Zajímavìj¹í je obsah bitù 0 a¾ 7. Zde je ulo¾ena osmibitová
konstanta, která je nejprve posunuta o dva bity doleva (tj.&nbsp;provede se
vynásobení ètyømi) a následnì je výsledek seèten s&nbsp;obsahem registru
<strong>PC</strong>, který se v¹ak mezitím stihl zvý¹it o hodnotu 4 (vliv
instrukèní pipeline). Na rozdíl od instrukcí skoku je v¹ak offset v¾dy chápán
jako celé kladné èíslo (<i>unsigned</i>), co¾ znamená, ¾e se v¾dy naèítá
konstanta umístìná nìkde ZA pozicí instrukce, konkrétnì na adresách vzdálených
0 a¾ 1020 bajtù od aktuální adresy, na ní¾ ukazuje registru
<strong>PC</strong>.</p>

<p><ins>Za zmínku mo¾ná stojí fakt, ¾e konstantu lze z&nbsp;oblasti, v&nbsp;ní¾
se nachází strojový kód programu, pouze naèíst a nikoli ulo¾it (pro ulo¾ení by
bylo nutné pou¾ít jiné instrukce). To v&nbsp;naprosté vìt¹inì pøípadù nevadí,
navíc je mnoho procesorù <i>ARM</i> vyu¾íváno ve funkci mikroøadièe, kde je
program ulo¾en v&nbsp;pamìti typu (E)ROM (dnes typu FLASH).</ins></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Relativní adresování vyu¾ívající SP (Stack Pointer)</h2>

<p><a href="#k06">V&nbsp;pøedchozí kapitole</a> jsme si popsali instrukci typu
<strong>LDR Rd, [PC+#offset]</strong>, tj.&nbsp;instrukci, pomocí ní¾ je mo¾né
naèíst konstantu umístìnou v&nbsp;oblasti, kde se nachází i strojový kód
programu. Jedná se vlastnì o speciální adresovací re¾im, který byl do
instrukèní sady <i>Thumb</i> pøidán z&nbsp;toho dùvodu, aby se dosáhlo co
nejvy¹¹í mo¾né hustoty kódu. V&nbsp;této kapitole se takté¾ budeme zabývat
instrukcemi pou¾ívajícími speciální adresovací re¾im. Jedná se o re¾im
pou¾ívaný pøi pøístupu k&nbsp;prvkùm ukládaným na zásobník. Pøipomeòme si, ¾e
v&nbsp;instrukèní sadì <i>Thumb</i> je jako ukazatel na vrchol zásobníku
rezervován registr <strong>R13</strong>. V&nbsp;manuálech i assembleru se sice
pro tento registru pou¾ívá i alternativní oznaèení <strong>SP</strong>
(<i>Stack Pointer</i>), ve skuteènosti se v¹ak spí¹e jedná o bázový registr
ukazující v&nbsp;dané proceduøe/subrutinì na zaèátek <i>zásobníkového rámce
(stack frame)</i>. V&nbsp;praxi se toti¾ vìt¹inou mìní obsah registru
<strong>R13/SP</strong> právì pøi vstupu do subrutiny, popø.&nbsp;pøi návratu
ze subrutiny.</p>

<p>Aby bylo mo¾né velmi efektivnì pøistupovat k&nbsp;parametrùm pøedávaným pøes
zásobník (a takté¾ k&nbsp;lokálním promìnným!), je nutné umìt adresovat polo¾ky
na zásobníku relativnì k&nbsp;<strong>R13/SP</strong>. Právì k&nbsp;tomu slou¾í
instrukce s&nbsp;následujícím formátem:</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 0 | 0 | 0 | L |    Rd     |             offset            |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>

<p>Jak je z&nbsp;formátu instrukèního slova patrné, jedná se o formát velmi
podobný slovu popsanému v&nbsp;pøedchozí kapitole. I zde toti¾ mù¾eme najít
index jednoho pracovního registru <i>Rd</i> a osmibitový offset. Ten je je¹tì
pøed pøiètením k&nbsp;registru <strong>R13/PC</strong> posunut o dva bity
doleva. Urèitì stojí za zmínku fakt, ¾e se opìt jedná o offset chápaný jako
celé èíslo bez znaménka, tj.&nbsp;s&nbsp;vyu¾itím tìchto instrukcí není mo¾né
mìnit obsah zásobníkových rámcù vytvoøených pro nadøazené subrutiny (to
èásteènì pøispívá k&nbsp;vìt¹í bezpeènosti). V&nbsp;praxi je tak mo¾né, aby
daná subrutina vyu¾ívala a¾ 256 32bitových parametrù a lokálních promìnných.
Obsah parametrù a lokálních promìnných je samozøejmì nutné takté¾ mìnit;
z&nbsp;tohoto dùvodu je v&nbsp;bitu 11 (<strong>L</strong>) urèeno, zda se
jedná o instrukci typu <i>Load</i> èi <i>Store</i>:</p>

<table>
<tr><th>Bit 11 (L)</th><th>Význam</th></tr>
<tr><td>0</td><td>Store &ndash; ulo¾ení registru do pamìti (na zásobník)</td></tr>
<tr><td>1</td><td>Load &ndash; naètení registru z&nbsp;pamìti (ze zásobníku)</td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Instrukèní sada Thumb: shrnutí</h2>

<p>Popis instrukèní sady <i>Thumb</i> se blí¾í k&nbsp;závìru. Nepopsali jsme si
sice zcela v¹echny instrukce, které lze v&nbsp;této instrukèní sadì nalézt, ale
pøibli¾nì 90% instrukcí ano. Pro pøehlednost jsou v&nbsp;následující tabulce
vypsány a¾ doposud zmínìné formáty instrukèních slov. Z&nbsp;tabulky je patrné,
¾e tvùrci instrukèní sady <i>Thumb</i> skuteènì dokázali vyu¾ít prakticky ka¾dý
bit instrukce:</p>

<pre>
 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 |operace|      offset       |    Rs     |    Rd     | bitový posun èi rotace
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 1 | 1 | 0 | op|    Rn     |    Rs     |    Rd     | ALU operace Rd := Rs +- Rn
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 1 | 1 | 1 | op|  const.   |    Rs     |    Rd     | ALU operace Rd := Rs +- const (3bity)
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 0 | 1 |operace|    Rd     |      osmibitová konstanta     | ALU operace s osmibitovou konstantou
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 1 | 0 | 0 | 0 | 0 |    operace    |    Rs     |    Rd     | ALU operace Rd := Rd op Rs (16 operací)
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 1 | 0 | 1 | L | 0 | 0 |    Ro     |    Rb     |    Rd     | LDR, STR Rd, [Rb+Rd] (32 bit)
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 1 | 0 | 1 | L | 1 | 0 |    Ro     |    Rb     |    Rd     | LDRB, STRB Rd, [Rb+Rd] (bajt)
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 1 | 0 | 1 | 0 | 1 | 1 |    Ro     |    Rb     |    Rd     | LDSB (bajt, roz¹íøení znaménka)
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 1 | 0 | 1 | H | S | 1 |    Ro     |    Rb     |    Rd     | LDRH, STRH, LDSH (16bit slovo, roz¹íøení znaménka)
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 0 | 1 | 0 | 0 | 1 |    Rd     |             offset            | LDR Rd, [PC+#offset]
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 0 | 0 | 0 | L |    Rd     |             offset            | LRD/STR Rd, [SP+#offset]
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 0 | 1 | 1 | 0 | 0 | 0 | 0 | S |         konstanta         | zmìna hodnoty SP
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 0 | 1 | 1 | L | 1 | 0 | R |        seznam registrù        | operace PUSH a POP
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 0 | 0 | L |    Rd     |        seznam registrù        | LDMIA, STMIA (naètení/ulo¾ení více registrù)
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 0 | 1 |   podmínka    |      osmibitová konstanta     | podmínìný skok
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 0 | 0 |         jedenáctibitová konstanta         | nepodmínìný skok (branch)
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 1 | H |         jedenáctibitová konstanta         | skok + link (branch and link)
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Introduction to ARM thumb<br />
<a href="http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb">http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb</a>
</li>

<li>ARM, Thumb, and ThumbEE instruction sets<br />
<a href="http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm">http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm</a>
</li>

<li>An Introduction to ARM Assembly Language<br />
<a href="http://dev.emcelettronica.com/introduction-to-arm-assembly-language">http://dev.emcelettronica.com/introduction-to-arm-assembly-language</a>
</li>

<li>Processors - ARM<br />
<a href="http://www.arm.com/products/processors/index.php">http://www.arm.com/products/processors/index.php</a>
</li>

<li>The ARM Instruction Set<br />
<a href="http://simplemachines.it/doc/arm_inst.pdf">http://simplemachines.it/doc/arm_inst.pdf</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ARM_architecture">http://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>BBC BASIC<br />
<a href="http://www.bbcbasic.co.uk/bbcbasic.html">http://www.bbcbasic.co.uk/bbcbasic.html</a>
</li>

<li>BBC BASIC<br />
<a href="http://mdfs.net/Software/BBCBasic/">http://mdfs.net/Software/BBCBasic/</a>
</li>

<li>BBC BASIC (Z80) for the ZX Spectrum<br />
<a href="http://mdfs.net/Software/BBCBasic/Spectrum/">http://mdfs.net/Software/BBCBasic/Spectrum/</a>
</li>

<li>BBC BASIC (Wikipedia CZ)<br />
<a href="http://en.wikipedia.org/wiki/BBC_BASIC">http://en.wikipedia.org/wiki/BBC_BASIC</a>
</li>

<li>MIPS-3D(r) ASE<br />
<a href="http://www.mips.com/products/architectures/mips-3d-ase/">http://www.mips.com/products/architectures/mips-3d-ase/</a>
</li>

<li>An introduction to SPARC's SIMD offerings<br />
<a href="http://mikeburrell.wordpress.com/2007/12/14/an-introduction-to-sparcs-simd-offerings/">http://mikeburrell.wordpress.com/2007/12/14/an-introduction-to-sparcs-simd-offerings/</a>
</li>

<li>MIPS64<sup>TM</sup> Architecture for Programmers Volume IV-c: The MIPS-3D<sup>TM</sup> Application-Specific Extension to the MIPS64<sup>TM</sup><br />
<a href="http://www.weblearn.hs-bremen.de/risse/RST/docs/MIPS/MD00099-2B-MIPS3D64-AFP-01.11.pdf">http://www.weblearn.hs-bremen.de/risse/RST/docs/MIPS/MD00099-2B-MIPS3D64-AFP-01.11.pdf</a>
</li>

<li>Visual Instruction Set<br />
<a href="http://www.enotes.com/topic/Visual_Instruction_Set">http://www.enotes.com/topic/Visual_Instruction_Set</a>
</li>

<li>NEON<br />
<a href="http://www.arm.com/products/processors/technologies/neon.php">http://www.arm.com/products/processors/technologies/neon.php</a>
</li>

<li>Architecture and Implementation of the ARM Cortex-A8 Microprocessor<br />
<a href="http://www.design-reuse.com/articles/11580/architecture-and-implementation-of-the-arm-cortex-a8-microprocessor.html">http://www.design-reuse.com/articles/11580/architecture-and-implementation-of-the-arm-cortex-a8-microprocessor.html</a>
</li>

<li>Multimedia Acceleration eXtensions (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Multimedia_Acceleration_eXtensions">http://en.wikipedia.org/wiki/Multimedia_Acceleration_eXtensions</a>
</li>

<li>AltiVec (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AltiVec">http://en.wikipedia.org/wiki/AltiVec</a>
</li>

<li>Visual Instruction Set (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Visual_Instruction_Set">http://en.wikipedia.org/wiki/Visual_Instruction_Set</a>
</li>

<li>MAJC (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/MAJC">http://en.wikipedia.org/wiki/MAJC</a>
</li>

<li>MDMX (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/MDMX">http://en.wikipedia.org/wiki/MDMX</a>
</li>

<li>MIPS Multiply Unit<br />
<a href="http://programmedlessons.org/AssemblyTutorial/Chapter-14/ass14_3.html">http://programmedlessons.org/AssemblyTutorial/Chapter-14/ass14_3.html</a>
</li>

<li>Silicon Graphics Introduces Enhanced MIPS Architecture<br />
<a href="http://bwrc.eecs.berkeley.edu/CIC/otherpr/enhanced_mips.html">http://bwrc.eecs.berkeley.edu/CIC/otherpr/enhanced_mips.html</a>
</li>

<li>MIPS-3D (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/MIPS-3D">http://en.wikipedia.org/wiki/MIPS-3D</a>
</li>

<li>MIPS Technologies, Inc. announces new MIPS-3D technology to provide silicon-efficient 3D graphics acceleration<br />
<a href="http://www.design-reuse.com/news/2057/mips-mips-3d-technology-silicon-efficient-3d-graphics-acceleration.html">http://www.design-reuse.com/news/2057/mips-mips-3d-technology-silicon-efficient-3d-graphics-acceleration.html</a>
</li>

<li>MIPS-3D Built-in Function (gcc.gnu.org)<br />
<a href="http://gcc.gnu.org/onlinedocs/gcc/MIPS_002d3D-Built_002din-Functions.html">http://gcc.gnu.org/onlinedocs/gcc/MIPS_002d3D-Built_002din-Functions.html</a>
</li>

<li>Baha Guclu Dundar:<br />
Intel MMX, SSE, SSE2, SSE3/SSSE3/SSE4 Architectures
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>

<li>Intel MMX<sup>TM</sup> Technology Overview<br />
Intel corporation, 1996</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>AMD K5 ("K5" / "5k86")<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g5K5-c.html">http://www.pcguide.com/ref/cpu/fam/g5K5-c.html</a>
</li>

<li>Sixth Generation Processors<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g6.htm">http://www.pcguide.com/ref/cpu/fam/g6.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Very_long_instruction_word">http://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>Tour of the Black Holes of Computing!: Floating Point<br />
<a href="http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt">http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt</a>
</li>

<li>3Dnow! Technology Manual<br />
AMD Inc., 2000</li>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>Control unit (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Control_unit">http://en.wikipedia.org/wiki/Control_unit</a>
</li>

<li>Cray History<br />
<a href="http://www.cray.com/About/History.aspx?404;http://www.cray.com:80/about_cray/history.html">http://www.cray.com/About/History.aspx?404;http://www.cray.com:80/about_cray/history.html</a>
</li>

<li>Cray Historical Timeline<br />
<a href="http://www.cray.com/Assets/PDF/about/CrayTimeline.pdf">http://www.cray.com/Assets/PDF/about/CrayTimeline.pdf</a>
</li>

<li>Computer Speed Claims 1980 to 1996<br />
<a href="http://homepage.virgin.net/roy.longbottom/mips.htm">http://homepage.virgin.net/roy.longbottom/mips.htm</a>
</li>

<li>Superpoèítaèe Cray<br />
<a href="http://www.root.cz/clanky/superpocitace-cray/">http://www.root.cz/clanky/superpocitace-cray/</a>
</li>

<li>Superpoèítaèe Cray (druhá èást)<br />
<a href="http://www.root.cz/clanky/superpocitace-cray-druha-cast/">http://www.root.cz/clanky/superpocitace-cray-druha-cast/</a>
</li>

<li>Superpoèítaèe Cray (tøetí èást)<br />
<a href="http://www.root.cz/clanky/superpocitace-cray-treti-cast/">http://www.root.cz/clanky/superpocitace-cray-treti-cast/</a>
</li>

<li>Superpoèítaèe Cray (ètvrtá èást)<br />
<a href="http://www.root.cz/clanky/superpocitace-cray-ctvrta-cast/">http://www.root.cz/clanky/superpocitace-cray-ctvrta-cast/</a>
</li>

<li>Superpoèítaèe Cray (pátá èást): architektura Cray X-MP<br />
<a href="http://www.root.cz/clanky/superpocitace-cray-pata-cast-architektura-pocitace-cray-x-mp-a-jeho-pouziti-ve-filmovem-prumyslu/">http://www.root.cz/clanky/superpocitace-cray-pata-cast-architektura-pocitace-cray-x-mp-a-jeho-pouziti-ve-filmovem-prumyslu/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

