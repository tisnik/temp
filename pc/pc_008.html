<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Dal¹í instrukce zpracovávané v Benderovì hlavì</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Dal¹í instrukce zpracovávané v Benderovì hlavì</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V osmé èásti seriálu o architekturách poèítaèù si øekneme, jakým zpùsobem je mo¾né naèítat konstanty do pracovních registrù mikroprocesoru, popí¹eme si instrukce pro pøesun registrù z a do operaèní pamìti, instrukce pro skok a návrat z podprogramu a na závìr bitové rotace a aritmetický posun.</p>



<h1>Obsah</h1>
<p>
<a href="#k01">1. Naètení konstanty do pracovních registrù mikroprocesoru</a><br />
<a href="#k02">2. Naètení hodnoty ulo¾ené v operaèní pamìti do registru</a><br />
<a href="#k03">3. Ulo¾ení obsahu registru do operaèní pamìti</a><br />
<a href="#k04">4. Skok do podprogramu a návrat z&nbsp;podprogramu</a><br />
<a href="#k05">5. Instrukce <strong>TEST</strong> a pøíklady jejího vyu¾ití</a><br />
<a href="#k06">6. Bitové rotace</a><br />
<a href="#k07">7. Bitové rotace provádìné pøes pøíznak pøenosu</a><br />
<a href="#k08">8. Aritmetický posun doprava</a><br />
<a href="#k09">9. Obsah dal¹í èásti seriálu</a><br />
</p>



<p><a name="k01"></a></p>
<h1>1. Naètení konstanty do pracovních registrù mikroprocesoru</h1>

<p>V&nbsp;pøedchozích èástech tohoto seriálu jsme si sice popsali mnoho
aritmetických i logických instrukcí, které pracují s&nbsp;obsahem pracovních
registrù, dosud ov¹em nevíme, jak do tìchto registrù naèíst nìjaké konstantní
hodnoty. Pro tento úèel disponuje ná¹ ukázkový mikroprocesor instrukcí
<strong>LD</strong>, co¾ je mnemotechnická zkratka anglického slova
<i>Load</i>. Tato instrukce, kterou disponuje prakticky ka¾dý mikroprocesor, má
v&nbsp;na¹í instrukèní sadì operaèní kód 11 (hexadecimálnì), za ním¾ následuje
adresní byte, pomocí kterého se rozhoduje, do jakého pracovního registru
<strong>A</strong> èi <strong>B</strong> se má konstanta ulo¾it (tento byte má
i dal¹í význam, který bude popsán <a href="#k02">v&nbsp;následující
kapitole</a>). Za adresním bytem následuje dvojice bytù (tj.&nbsp;¹estnáct
bitù) s&nbsp;obsahem, který je naèten do zvoleného pracovního registru. Celá
instrukce <strong>LD</strong> má tedy délku ètyø bytù. Obì varianty instrukce,
je¾ se od sebe odli¹ují pouze cílovým pracovním registrem (tj.&nbsp;adresním
bytem), jsou vypsány v&nbsp;následující tabulce.</p>

<table>
<tr><th>Strojový kód</th><th>Zápis v assembleru</th><th>Význam</th></tr>
<tr><td>11 00 xx yy</td><td>LD A,#konstanta</td><td>naètení konstanty <i>xxyy</i> do pracovního registru A</td></tr>
<tr><td>11 01 xx yy</td><td>LD B,#konstanta</td><td>naètení konstanty <i>xxyy</i> do pracovního registru B</td></tr>
</table>

<image id="6124" />
<p-center>Mikroprocesor provádìjící operaci <strong>LD A, #konstanta</strong></p-center>

<p>Následuje jednoduchý pøíklad pou¾ití:</p>

<code-area>; souèet dvou konstant
LD A,#10     ; naètení konstanty 10 do pracovního registru A
LD B,#20     ; naètení konstanty 20 do pracovního registru B
ADD A,B      ; výsledek souètu je ulo¾en do pracovního registru A
             ; a souèasnì jsou ovlivnìny oba pøíznakové registry
             ; Carry flag i Zero flag
</code-area>

<p>V¹imnìte si, ¾e se jedná o jednu instrukci nále¾ející do skupiny instrukcí,
které ve svém zápisu ve strojovém kódu obsahují i konkrétní hodnotu operandu,
se kterým se dále pracuje. Zde se konkrétnì jedná o konstantu ukládanou do
jednoho z&nbsp;pracovních registrù; u instrukcí skoku se naproti tomu jedná o
adresu, na kterou má být skok proveden. Tyto hodnoty do strojového kódu vkládá
pøímo pøekladaè a v&nbsp;pøípadì, ¾e se nepou¾ijí rùzné "¹pinavé" triky typu
automodifikujícího se kódu (ten si mo¾ná také nìkdy popí¹eme), jsou tyto
konstanty ulo¾eny pøímo ve spustitelných souborech, které ve své nejjednodu¹¹í
podobì pøedstavují strojový kód pøelo¾eného programu.</p>

<p>Dále stojí za pozornost vlastní zpùsob ulo¾ení konstanty v&nbsp;adresní
èásti instrukce. Pøi rozlo¾ení ¹estnáctibitového èísla na dva byty, které
pøedstavují nejmen¹í adresovatelnou jednotku operaèní pamìti, je toti¾ mo¾né
pou¾ít dva hlavní zpùsoby &ndash; <i>little endian</i> (první byte ulo¾ený
v&nbsp;operaèní pamìti èi registru obsahuje v&nbsp;pøípadì ¹estnáctibitového
mikroprocesoru bity 0-7) a <i>big endian</i> (první byte obsahuje bity 8-15).
Rùzné mikroprocesory, resp.&nbsp;rùzní výrobci mikroprocesorù, pou¾ívají i
rùzný zpùsob ulo¾ení, proto se nìkdy mù¾eme setkat s&nbsp;oznaèením <i>Intel
order</i> (little endian) a <i>Motorola (Sun) order</i> (big endian). Ka¾dý
z&nbsp;obou zpùsobù má své pøednosti i zápory &ndash; pøi pou¾ití little endian
se snáze provádí konverze mezi rùznými datovými typy, big endian se zase snáze
ète z&nbsp;výpisù obsahu operaèní pamìti. Ov¹em vìt¹inou (jak je to bì¾né
v&nbsp;podobných pøípadech) je zcela jedno, který zpùsob daný mikroprocesor
pou¾ívá, jen je zapotøebí pamatovat na to, ¾e u nìkterých instrukcí je znalost
konkrétního zpùsobu ulo¾ení bytù zcela nezbytná (práce s&nbsp;binárními
soubory, sí»ové protokoly, ovládání periferních zaøízení atd.).</p>

<image id="6125" />
<p-center>Mikroprocesor provádìjící operaci <strong>LD B, #konstanta</strong></p-center>



<p><a name="k02"></a></p>
<h1>2. Naètení hodnoty ulo¾ené v operaèní pamìti do registru</h1>

<p>Instrukce pro naètení hodnoty ulo¾ené na libovolné adrese v&nbsp;operaèní
pamìti do pracovního registru, je u¾ na první pohled velmi podobná
s&nbsp;pøedchozí instrukcí. Jediný, zato v¹ak podstatný rozdíl spoèívá
v&nbsp;tom, ¾e v&nbsp;samotné instrukci není ulo¾ena konstanta, která se má do
zvoleného pracovního registru naèíst, ale ¹estnáctibitová adresa, která urèuje
pamì»ové místo, na kterém po¾adovaná hodnota le¾í. I samotný zápis instrukce
v&nbsp;assembleru (jazyku symbolických adres) je ponìkud odli¹ný, aby na první
pohled bylo patrné, o jakou instrukci se jedná. Zatímco pøed konstantou byl
uveden znak køí¾ku "#", je adresa zapsána do hranatých závorek (ve své podstatì
se jedná o mix syntaxí mikroprocesorù Motorola a Intel). Operaèní kód instrukce
<strong>LD registr, [adresa]</strong> je shodný s&nbsp;operaèním kódem
instrukce <strong>LD registr, #konstanta</strong>, ov¹em li¹í se adresní byte
(konkrétnì: pátý bit je nastaven na jednièku), co¾ je ostatnì patrné pøi
porovnání tabulky uvedené v&nbsp;první kapitole s&nbsp;tabulkou zobrazenou
ní¾e.</p>

<table>
<tr><th>Strojový kód</th><th>Zápis v assembleru</th><th>Význam</th></tr>
<tr><td>11 10 xx yy</td><td>LD A,[adresa]</td><td>naètení hodnoty ulo¾ené v operaèní pamìti do pracovního registru A</td></tr>
<tr><td>11 11 xx yy</td><td>LD B,[adresa]</td><td>naètení hodnoty ulo¾ené v operaèní pamìti do pracovního registru B</td></tr>
</table>

<p>I samotné provedení instrukce je ponìkud odli¹né. Zatímco pøi naèítání
konstanty se z&nbsp;operaèní pamìti pøeèetlo ¹estnáctibitové slovo ulo¾ené za
adresním bytem a ihned poté se pøes interní sbìrnici zapsalo do zvoleného
pracovního registru, musí se pøi naèítání hodnoty z&nbsp;urèené adresy pomocí
instrukce <strong>LD registr, [adresa]</strong> operaèní pamì» obslou¾it (èíst)
dvakrát. Pøi prvním ètení operaèní pamìti se naète samotná instrukce
s&nbsp;adresním bytem a ¹estnáctibitovou adresou. Posléze je na adresovou
sbìrnici poslána pøeètená adresa, pomocí které se v&nbsp;operaèní pamìti vybere
a následnì vrátí obsah zvolené pamì»ové buòky (a buòky s&nbsp;adresou o
jednièku vìt¹í, proto¾e pracujeme se ¹estnáctibitovými slovy a pamì» je
adresována po bytech) a teprve tento obsah je pøes interní sbìrnici
mikroprocesoru zapsán do zvoleného pracovního registru. Rozdíl mezi obìma
zpùsoby naètení hodnoty do pracovního registru je ilustrován na následujícím
obrázku:</p>

<image id="6126" />
<p-center>Instrukce <strong>LD A,#1234</strong></p-center>

<image id="6127" />
<p-center>Instrukce <strong>LD A,[1234]</strong></p-center>



<p><a name="k03"></a></p>
<h1>3. Ulo¾ení obsahu registru do operaèní pamìti</h1>

<p>Kromì naèítání hodnot do pracovních registrù je samozøejmì nutné provádìt i
opaènou operaci, tj.&nbsp;ulo¾ení hodnoty pracovního registru na zvolené místo
v&nbsp;operaèní pamìti. Pro tento úèel obsahuje ná¹ ukázkový mikroprocesor
instrukci nazvanou <strong>ST</strong>, co¾ je mnemotechnická zkratka
anglického slova <i>Store</i>. Strojový kód této instrukce je dlouhý ètyøi
byty. V&nbsp;prvním byte je operaèní kód (<i>opkód</i>) s&nbsp;hodnotou 0x12 za
ním¾ následuje adresový byte, s&nbsp;jeho¾ pomocí je zvolen jeden
z&nbsp;pracovních registrù. Poslední dva byty obsahují ¹estnáctibitovou adresu,
na kterou se hodnota pracovního registru ulo¾í (ve skuteènosti se hodnota
rozlo¾í do dvou pamì»ových bunìk, proto¾e pracovní registr má ¹íøku ¹estnáct
bitù a buòka pamìti je osmibitová). Vzhledem k&nbsp;tomu, ¾e tento
mikroprocesor mù¾e pamì» obsluhovat pouze pomocí instrukcí <strong>LD</strong>
a <strong>ST</strong>, nále¾í do kategorie mikroprocesorù nazývaných nìkdy
termínem <i>Load-Store machines</i>. Prakticky v¹echny RISC procesory nále¾í do
této kategorie, bli¾¹í informace si v¹ak uvedeme a¾ pøí¹tì.</p>

<table>
<tr><th>Strojový kód</th><th>Zápis v assembleru</th><th>Význam</th></tr>
<tr><td>12 00 xx yy</td><td>ST A,[adresa]</td><td>ulo¾ení hodnoty z pracovního registru A do operaèní pamìti na zadanou adresu</td></tr>
<tr><td>12 01 xx yy</td><td>ST B,[adresa]</td><td>ulo¾ení hodnoty z pracovního registru B do operaèní pamìti na zadanou adresu</td></tr>
</table>

<image id="6128" />
<p-center>Instrukce <strong>ST A,[1234]</strong></p-center>



<p><a name="k04"></a></p>
<h1>4. Skok do podprogramu a návrat z&nbsp;podprogramu</h1>

<p>Pro implementaci podprogramù, které je mo¾né volat i rekurzivnì, ná¹
mikroprocesor obsahuje instrukce urèené pro skok do podprogramu a instrukci pro
návrat z&nbsp;podprogramu. Instrukce pro skok do podprogramu se jmenuje
<strong>CALL</strong>, o návrat z&nbsp;podprogramu se stará instrukce
<strong>RET</strong> (<i>Return</i>). Skok do podprogramu je realizován
prakticky stejným zpùsobem jako bì¾ný skok, tj.&nbsp;adresa zapsaná za
operaèním kódem instrukce je vlo¾ena do registru <strong>PC</strong>, èím¾
dojde k&nbsp;pøemístìní øízení na uvedenou adresu. Ov¹em pùvodní hodnota
registru <strong>PC</strong> je ulo¾ena na zásobník, tak¾e si mikroprocesor
vlastnì zapamatuje, na které adrese se pøed skokem do podprogramu nacházel.
Instrukce <strong>RET</strong> vyjme hodnotu ulo¾enou na vrcholu zásobníku a
pøenese ji do pracovního registru <strong>PC</strong> (ve skuteènosti se do
tohoto registru pøenese hodnota o tøi vìt¹í, proto¾e samotná instrukce
<strong>CALL</strong> má délku pøesnì tøi byty). To znamená, ¾e po provedení
instrukce <strong>RET</strong> se øízení programu vrátí na adresu, která le¾í
tìsnì za pùvodní instrukcí <strong>CALL</strong>.</p>

<table>
<tr><th>Strojový kód</th><th>Zápis v assembleru</th><th>Význam</th></tr>
<tr><td>17 xx yy</td><td>CALL adr</td><td>skok na adresu <i>xxyy</i> s&nbsp;ulo¾ením stavu PC na zásobník</td></tr>
<tr><td>18      </td><td>RET     </td><td>návrat na adresu, je¾ je ulo¾ena na vrcholu zásobníku (obnovení PC)</td></tr>
</table>

<p>Instrukci <strong>RET</strong> je mo¾né pou¾ít ve funkci "aritmetického
GOTO". Jedná se o pøíkaz známý napøíklad z&nbsp;nìkterých interpretù
programovacího jazyka Basic, ve kterých bylo mo¾né provádìt skok na øádek,
jeho¾ èíslo bylo vypoètené pomocí aritmetického výrazu. V&nbsp;assembleru se
tato technika pou¾ívá velmi èasto, napøíklad pøi implementaci rozhodovacích
tabulek (<i>decision tables</i>), popøípadì jako náhrada za strukturovaný
pøíkaz typu <i>switch-case</i>. Vzhledem k&nbsp;tomu, ¾e ná¹ mikroprocesor
neobsahuje instrukci nepøímého skoku typu <strong>JMP A</strong> èi <strong>JMP
B</strong>, musí se "aritmetické GOTO" vytvoøit nepøímo. Vyu¾ijeme pøitom toho,
¾e instrukce <strong>RET</strong> oèekává na vrcholu zásobníku adresu, která se
naète do registru <strong>PC</strong>, proto¾e je mo¾né pomocí dále popsaných
instrukcí <strong>PUSH A</strong> èi <strong>PUSH B</strong> do zásobníku
ulo¾it obsah jednoho z&nbsp;pracovních registrù a poté zavolat instrukci
<strong>RET</strong>, která po¾adovaný nepøímý skok provede. Tento zpùsob
vyu¾ití (èi spí¹e zneu¾ití) zásobníku je v&nbsp;nìkterých pøípadech pou¾it
napøíklad i pøi pokusu o napadení nativních aplikací. Pou¾itím zásobníku se
budeme podrobnìji zabývat v&nbsp;následující èásti tohoto seriálu.</p>



<p><a name="k05"></a></p>
<h1>5. Instrukce <strong>TEST</strong> a pøíklady jejího vyu¾ití</h1>

<p>Instrukce <strong>TEST</strong> slou¾í k&nbsp;provedení logické operace
konjunkce (and) bit po bitu s&nbsp;po¾adovanou dvojicí pracovních registrù,
tj.&nbsp;jedná se o stejnou funkci, jakou provádí ji¾ minule popsaná instrukce
<strong>AND</strong>. Jediný, zato v¹ak podstatný rozdíl spoèívá v&nbsp;tom, ¾e
zatímco instrukce <strong>AND</strong> ulo¾ila výsledek operace do pracovního
registru, který byl jejím prvním operandem, tak instrukce <strong>TEST</strong>
výsledek operace "zapomene", tj.&nbsp;obsah ¾ádného pracovního registru se
nezmìní. Nastaví se v¹ak pøíznakový bit <i>Zero flag</i> v&nbsp;závislosti na
tom, zda je výsledek konjunkce nulový èi nenulový. Tato instrukce se pou¾ívá
pøedev¹ím pøi implementaci rùzných podmínek èi programových smyèek, podobnì
jako minule popsaná instrukce <strong>CMP</strong>. V¹echny ètyøi varianty této
instrukce jsou vypsány v&nbsp;ní¾e uvedené tabulce, ze které je patrné, ¾e je
mo¾né provádìt test registru se sebou samým. Mezi operacemi <strong>TEST
A,B</strong> a <strong>TEST B,A</strong> není ¾ádný podstatný rozdíl, proto¾e
v&nbsp;tomto pøípadì nezále¾í na poøadí operandù (na rozdíl od instrukce
<strong>CMP</strong>).</p>

<image id="6129" />
<p-center>Mikroprocesor provádìjící operaci <strong>TEST A,A</strong></p-center>

<table>
<tr><th>Strojový kód</th><th>Zápis v assembleru</th><th>Význam</th></tr>
<tr><td>10 00</td><td>TEST A,A</td><td>A &amp; A</td></tr>
<tr><td>10 01</td><td>TEST A,B</td><td>A &amp; B</td></tr>
<tr><td>10 10</td><td>TEST B,A</td><td>B &amp; A</td></tr>
<tr><td>10 11</td><td>TEST B,B</td><td>B &amp; B</td></tr>
</table>

<p>Typické pou¾ití této instrukce spoèívá v&nbsp;implementaci podmínky typu
<i>if (a and b)</i> èi pro test na nulovost nìkterého z&nbsp;registrù, proto¾e
pøíznakový bit <i>Zero flag</i> je u instrukce <strong>TEST A,A</strong>
resp.&nbsp;<strong>TEST B,B</strong> nastaven na jednièku pouze v&nbsp;pøípadì,
¾e je obsah pracovního registru nulový. Pøipomeòme si, jak instrukce
<strong>AND</strong> a tím i instrukce <strong>TEST</strong> zpracuje rùzné
hodnoty (v&nbsp;pøípadì instrukce <strong>TEST</strong> není výsledek nikam
ulo¾en, "pouze" se nastaví pøíznak <i>Zero flag</i>):</p>

<table>
<tr><th></th><th>hex</th><th>binárnì</th><th>Zero flag</th></tr>
<tr><td>operand 1</td><td>0000</td><td>0000000000000000</td><td></td></tr>
<tr><td>operand 2</td><td>0000</td><td>0000000000000000</td><td></td></tr>
<tr><td>výsledek </td><td>0000</td><td>0000000000000000</td><td>1</td></tr>
<tr><td colspan="4"></td></tr>
<tr><td>operand 1</td><td>2A2A</td><td>0010101000101010</td><td></td></tr>
<tr><td>operand 2</td><td>00FF</td><td>0000000011111111</td><td></td></tr>
<tr><td>výsledek </td><td>002A</td><td>0000000000101010</td><td>0</td></tr>
<tr><td colspan="4"></td></tr>
<tr><td>operand 1</td><td>0FF0</td><td>0000111111110000</td><td></td></tr>
<tr><td>operand 2</td><td>FF00</td><td>1111111100000000</td><td></td></tr>
<tr><td>výsledek </td><td>0F00</td><td>0000111100000000</td><td>0</td></tr>
<tr><td colspan="4"></td></tr>
<tr><td>operand 1</td><td>00FF</td><td>0000000011111111</td><td></td></tr>
<tr><td>operand 2</td><td>FF00</td><td>1111111100000000</td><td></td></tr>
<tr><td>výsledek </td><td>0000</td><td>0000000000000000</td><td>1</td></tr>
</table>

<image id="6130" />
<p-center>Mikroprocesor provádìjící operaci <strong>TEST A,B</strong></p-center>



<p><a name="k06"></a></p>
<h1>6. Bitové rotace</h1>

<p>V&nbsp;assembleru se pomìrnì èasto pou¾ívají instrukce provádìjící takzvané
<i>bitové rotace</i>. O co se vlastnì jedná? Jde o posun v¹ech ¹estnácti bitù
v&nbsp;nìkterém z&nbsp;pracovních registrù, ov¹em tak, ¾e se jedná o uzavøenou
smyèku, tj.&nbsp;obsah bitu, který by se provedením posunu ztratil (byl by
vysunut), je naopak zkopírován na vstup. Kromì toho se tento bit zkopíruje do
pøíznakového bitu <i>Carry flag</i>, co¾ není samoúèelné, proto¾e se této
skuteènosti dá vyu¾ít pro provedení skoku v&nbsp;závislosti na hodnotì jednoho
konkrétního bitu, implementaci generátoru pseudonáhodných èísel nebo pøi
programování aritmetických operací násobení a dìlení, pro které nemá ná¹
mikroprocesor specializované instrukce ani obvody. Pro takto chápanou bitovou
rotaci existují dvì instrukce, první pro rotaci obsahu pracovního registru
doleva a druhá pro rotaci doprava. Ka¾dá instrukce zpùsobí rotaci pouze o jeden
bit, v&nbsp;pøípadì potøeby provedení vìt¹ího mno¾ství rotací je nutné
instrukce zopakovat (vìt¹ina moderních mikroprocesorù pou¾ívá takzvaný
<i>barell shifter</i>, co¾ je obvod umo¾òující bitový posun èi rotaci i o vìt¹í
poèet bitù). V¹echny ètyøi instrukce (levá a pravá rotace) aplikované na jeden
z&nbsp;pracovních registrù, jsou vypsány v&nbsp;tabulce:</p>

<table>
<tr><th>Strojový kód</th><th>Zápis v assembleru</th><th>Význam</th></tr>
<tr><td>0a 00</td><td>RL A</td><td>bitová rotace registru A doleva</td></tr>
<tr><td>0a 01</td><td>RL B</td><td>bitová rotace registru B doleva</td></tr>
<tr><td>0c 00</td><td>RR A</td><td>bitová rotace registru A doprava</td></tr>
<tr><td>0c 01</td><td>RR B</td><td>bitová rotace registru B doprava</td></tr>
</table>

<p>Jak samotná instrukce rotace ovlivní obsah pracovního registru i pøíznakový
bit <i>Carry flag</i>, je ukázáno na pøíkladu ní¾e:</p>

<table>
<tr><th>registr A (binárnì)</th><th>instrukce</th><th>po provedení instrukce</th><th>Carry flag</th></tr>
<tr><td>0000000000000001</td><td>RL A</td><td>0000000000000010</td><td>0</td></tr>
<tr><td>1000000000000000</td><td>RL A</td><td>0000000000000001</td><td>1</td></tr>
<tr><td>0000000000000001</td><td>RR A</td><td>1000000000000000</td><td>1</td></tr>
<tr><td>1000000000000000</td><td>RR A</td><td>0100000000000000</td><td>0</td></tr>
</table>

<image id="6131" />
<p-center>Rotace doleva i doprava</p-center>



<p><a name="k07"></a></p>
<h1>7. Bitové rotace provádìné pøes pøíznak pøenosu</h1>

<p>Kromì bì¾ných bitových rotací má mnoho mikroprocesorù implementovány i
rotace provádìné pøes pøíznak pøenosu (<i>Carry flag</i>). V&nbsp;podstatì se
jedná o roz¹íøení bitové ¹íøky rotovaného registru o jeden bit, který je
pøedstavovaný právì pøíznakem pøenosu, tj.&nbsp;neprovádí se rotace ¹estnácti
bitù, ale bitù sedmnácti. Pou¾ití tìchto typù rotací spoèívá napøíklad
v&nbsp;implementaci víceslovní aritmetiky (rotuje se pøes více
¹estnáctibitových slov), popø.&nbsp;pøi po¾adavku na vlo¾ení hodnoty pøíznaku
pøenosu do urèeného bitu pracovního registru (booleovské operace).
V&nbsp;pøípadì, ¾e je pøíznak pøenosu vhodnou instrukcí nastaven na nulu,
stávají se z&nbsp;tìchto rotací vlastnì bitové posuvy (<i>bit shifts</i>);
z&nbsp;tohoto dùvodu je není nutné do instrukèní sady pøidávat. Nákres rotace
doleva i doprava pøes pøíznak pøenosu, je naznaèen na obrázku:</p>

<image id="6132" />
<p-center>Rotace doleva i doprava pøes pøíznak pøenosu</p-center>

<table>
<tr><th>Strojový kód</th><th>Zápis v assembleru</th><th>Význam</th></tr>
<tr><td>0b 00</td><td>RLC A</td><td>bitová rotace registru A doleva pøes pøíznak pøenosu</td></tr>
<tr><td>0b 01</td><td>RLC B</td><td>bitová rotace registru B doleva pøes pøíznak pøenosu</td></tr>
<tr><td>0d 00</td><td>RRC A</td><td>bitová rotace registru A doprava pøes pøíznak pøenosu</td></tr>
<tr><td>0d 01</td><td>RRC B</td><td>bitová rotace registru B doprava pøes pøíznak pøenosu</td></tr>
</table>



<p><a name="k08"></a></p>
<h1>8. Aritmetický posun doprava</h1>

<p>Ke ètyøem typùm bitových rotací je v&nbsp;instrukèní sadì na¹eho uèebního
mikroprocesoru pøidán i takzvaný <i>aritmetický posun doprava</i>
(<i>ASR=Arithmetic Shift Right</i>). Jedná se vlastnì o obdobu bitového posunu
doprava, ov¹em s&nbsp;tím rozdílem, ¾e obsah nejvy¹¹ího bitu zùstává za v¹ech
okolností zachován (a samozøejmì je je¹tì zkopírován do druhého nejvy¹¹ího
bitu). Pokud si uvìdomíme, jakým zpùsobem jsou reprezentovány hodnoty
v&nbsp;systému dvojkového doplòku (viz pøedchozí èásti tohoto seriálu), je
zøejmé, ¾e tato instrukce ve vìt¹inì pøípadù (99,99% u ¹estnáctibitových èísel)
provádí dìlení dvìma, a to i pro záporné hodnoty. Pro aritmetický posun doleva
¾ádná specializovaná instrukce není dostupná, proto¾e ji lze nahradit bì¾ným
posunem (platí i pro záporná èísla reprezentovaná v&nbsp;systému dvojkového
doplòku).</p>

<image id="6133" />
<p-center>Aritmetický posun doprava</p-center>

<table>
<tr><th>Strojový kód</th><th>Zápis v assembleru</th><th>Význam</th></tr>
<tr><td>0e 00 0x</td><td>ASR A</td><td>aritmetický posuv registru A doprava o <i>x</i> bitù</td></tr>
<tr><td>0e 01 0x</td><td>ASR B</td><td>aritmetický posuv registru B doprava o <i>x</i> bitù</td></tr>
</table>



<p><a name="k09"></a></p>
<h1>9. Obsah dal¹í èásti seriálu</h1>

<p>V&nbsp;následující èásti seriálu o èinnosti poèítaèe koneènì dokonèíme popis
celého instrukèního souboru na¹eho cvièného mikroprocesoru popisem zbývajících
instrukcí <strong>IRET</strong>, <strong>NOP</strong> a <strong>HALT</strong> i
instrukcí pro práci se zásobníkem. Uká¾eme si také, jakým zpùsobem
mikroprocesor reaguje na vnìj¹í èi vnitøní pøeru¹ení a z&nbsp;jakého dùvodu se
vlastnì pøeru¹ení u mikroprocesorù (a poèítaèù obecnì) pou¾ívá. Také si
øekneme, jaké existují architektury mikroprocesorù, zpùsob èlenìní
mikroprocesorù do kategorií a pøednosti i zápory jednotlivých architektur.</p>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2008</small></p>
</body>
</html>

