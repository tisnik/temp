<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk APL - dokonèení</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk APL - dokonèení</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o historii výpoèetní techniky dokonèíme popis zajímavého &bdquo;hieroglyfického&ldquo; jazyka APL. Ozøejmíme si význam funkcí pro porovnávání skalárních hodnot i prvkù polí, funkci pro kompresi polí, operátory &bdquo;outer product&ldquo; a &bdquo;inner product&ldquo; i zpùsob práce s hierarchickými datovými strukturami.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Funkce pro porovnání skalárních hodnot i prvkù polí</a></p>
<p><a href="#k02">2. Komprese polí</a></p>
<p><a href="#k03">3. Malý dáreèek Lispaøùm &ndash; funkce &bdquo;take&ldquo; a &bdquo;drop&ldquo;</a></p>
<p><a href="#k04">4. Pou¾ití funkcí &bdquo;take&ldquo; a &bdquo;drop&ldquo;</a></p>
<p><a href="#k05">5. Operátor &bdquo;outer product&ldquo;</a></p>
<p><a href="#k06">6. Operátor &bdquo;inner product&ldquo;</a></p>
<p><a href="#k07">7. Hierarchické datové struktury</a></p>
<p><a href="#k08">8. Literatura</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2>1. Funkce pro porovnání skalárních hodnot i prvkù polí</h2>

<p>Podobnì jako v&nbsp;prakticky v¹ech ostatních programovacích jazycích, je i
v&nbsp;jazyku <i>APL</i> k&nbsp;dispozici mechanismus umo¾òující vzájemné
porovnání èíselných hodnot èi znakù. Zatímco v&nbsp;mnoha jazycích je tento
mechanismus realizován pomocí relaèních operátorù, v&nbsp;<i>APL</i> se jedná o
primitivní dyadické funkce reprezentované pomocí symbolù, které známe
z&nbsp;matematiky. Ostatní programovací jazyky sice nìkteré z&nbsp;tìchto
symbolù takté¾ vyu¾ívají, ale omezují se pouze na ty znaky, které lze nalézt
v&nbsp;tabulce ASCII, co¾ mj.&nbsp;znamená, ¾e napøíklad symbol &le; bývá
nahrazen dvojicí znakù &lt;= atd. Nejvìt¹í problémy bývají se symbolem =, jen¾
mù¾e mít význam relaèní operace &bdquo;rovná se&ldquo; nebo pøiøazení (co¾
vùbec neodpovídá pùvodnímu matematickému významu tohoto symbolu). V&nbsp;jazyku
<i>APL</i> je pøiøazení realizováno matematickým symbolem &#8592;, tak¾e zde
k&nbsp;nedorozumìní nedochází. V&nbsp;následující tabulce jsou vypsány v¹echny
dyadické primitivní funkce urèené pro porovnání èíselných hodnot èi znakù:</p>

<table>
<tr><th>Symbol</th><th>Unicode</th><th>Význam funkce</th></tr>
<tr><td>&lt;  </td><td>003C</td><td>men¹í ne¾</td></tr>
<tr><td>&le;  </td><td>2264</td><td>men¹í nebo rovno</td></tr>
<tr><td>=     </td><td>003D</td><td>rovno</td></tr>
<tr><td>&ge;  </td><td>2265</td><td>vìt¹í nebo rovno</td></tr>
<tr><td>&gt;  </td><td>003E</td><td>vìt¹í ne¾</td></tr>
<tr><td>&ne;  </td><td>2260</td><td>nerovno</td></tr>
<tr><td>&isin;</td><td>220A</td><td>obsahuje (dotaz na existenci prvku v poli)</td></tr>
</table>

<p>V¹echny vý¹e uvedené funkce vrací v&nbsp;pøípadì porovnání dvou skalárù
(tj.&nbsp;dvojice èísel èi dvojice znakù) hodnotu 1 pokud daná podmínka skuteènì
platí a hodnotu 0 v&nbsp;opaèném pøípadì. Tyto hodnoty lze pova¾ovat za hodnoty
pravdivostní (napøíklad v&nbsp;Javì pøedstavované typem <i>boolean</i> a
v&nbsp;C++ typem <i>bool</i>), proto¾e na nì lze aplikovat Booleovské operace
logického souètu (&#8744;), souèinu (&#8743;), ekvivalence (=), nonekvivalence
(&ne;) atd. Ètenáøi pøedchozích èástí tohoto èlánku se jistì ptají, co se
stane, pokud se porovnává dvojice polí, tj.&nbsp;napøíklad vektorù èi matic.
Jazyk <i>APL</i> samozøejmì takové porovnání podporuje (díky tomu opìt mù¾e
dojít k&nbsp;u¹etøení programových smyèek) a vrací pole o stejném poètu dimenzí
i velikosti, jako pole porovnávaná, pøièem¾ prvky tohoto výsledného pole mají
nastaveny hodnoty 0 nebo 1 podle toho, zda zapsaná podmínka neplatí èi naopak
platí (pole se porovnávají prvek po prvku). Význam takto vrácené hodnoty si
vysvìtlíme v&nbsp;následujícím textu, nejprve se v¹ak podíváme na nìkolik
jednoduchých pøíkladù:</p>

<pre>
    10 &lt; 20
1

    10 &ge; 20
0

    MATICE1 &#8592; 2 2 &rho; 1 2 3 4
    MATICE2 &#8592; 2 2 &rho; 4 3 2 1

    MATICE1
1 2
3 4
    MATICE2
4 3
2 1

    MATICE1 &lt; MATICE2
1 1
0 0

    Prodeje &#8592; 1100 1200 1300 900 850 930 1050 970
    Prodeje &gt; 1000
1 1 1 0 0 0 1 0
</pre>

<p>Zastavme se u posledního pøíkazu, v&nbsp;nìm¾ se provedlo porovnání vektoru
(pøesnìji v¹ech prvkù vektoru) se skalární hodnotou. To je povolená operace,
podobnì jako napøíklad pøiètení skalární hodnoty ke v¹em prvkùm vektoru (viz
první èást èlánku o jazyku <i>APL</i>), ale její výsledek (v&nbsp;tomto pøípadì
vektor binárních hodnot) lze vyu¾ít k&nbsp;mnoha úèelùm, napøíklad ke zji¹tìní,
v&nbsp;kolika mìsících pøesáhly prodeje hodnotu 1000; samozøejmì opìt bez
pou¾ití programové smyèky, která je nahrazena operátorem <i>reduce</i> (/)
spolu s&nbsp;funkcí souètu (+). Nejbli¾¹ím ekvivalentem následujícího pøíkazu
je pravdìpodobnì SQL dotaz <i>SELECT count(*) FROM prodeje WHERE value &gt;
1000</i>:</p>

<pre>
    Prodeje &#8592; 1100 1200 1300 900 850 930 1050 970
    +/Prodeje &gt; 1000
4
</pre>

*** image ***
<p><i>Typové koleèko v&nbsp;minulosti pou¾ívané v&nbsp;tiskárnách pøi tisku
programù v&nbsp;jazyce APL. Tento typ tiskáren obsahoval rotující koleèko nebo
&bdquo;soudek&ldquo; se v¹emi tisknutelnými znaky. Koleèko se pøi své rotaci
posouvalo nad papírem (podobnì jako tisková hlava jehlièkových tiskáren) a ve
chvíli, kdy se natoèilo do správné polohy, bylo pøitisknuto pøes barvicí pásku
k&nbsp;papíru. Výsledkem byl na svou dobu velmi kvalitní tisk, který odpovídal
kvalitì psacích strojù. Nevýhodou typového koleèka bylo to, ¾e se muselo pøi
po¾adavku na zmìnu znakové sady (národní znaky, symboly APL, kurzíva) ruènì
vymìnit.</i></p>



<p><a name="k02"></a></p>
<h2>2. Komprese polí</h2>

<p>S&nbsp;vektory èi maticemi obsahujícími binární hodnoty úzce souvisí i
funkce provádìjící takzvanou <i>kompresi</i> polí. Jedná se o dyadickou
primitivní funkci pøedstavovanou symbolem /, která na základì pole (vektoru,
matice) obsahujícího pouze binární hodnoty 0 nebo 1 vybere z&nbsp;jiného pole o
stejné dimenzi i velikosti ty prvky, u nich¾ je odpovídající binární hodnota
rovna jednièce. Nejlépe si funkci komprese pole uká¾eme na jednoduchém
pøíkladu, ve kterém bude opìt pou¾it vektor <i>Prodeje</i>, s&nbsp;ním¾ jsme se
ji¾ setkali v&nbsp;pøedchozí kapitole:</p>

<pre>
    Prodeje &#8592; 1100 1200 1300 900 850 930 1050 970
    Prodeje
1100 1200 1300 900 850 930 1050 970
    0 1 0 1 0 1 0 1 / Prodeje
1200 900 930 970
</pre>

<p>Binární vektor lze samozøejmì získat na základì jiného pøíkazu; napøíklad je
mo¾né vzít výsledek funkce porovnání (relace) popsané v&nbsp;pøedchozím
odstavci a na základì hodnoty výsledného binárního vektoru vybrat z&nbsp;pole
<i>Prodeje</i> jen hodnoty odpovídající zvolené podmínce:</p>

<pre>
    Prodeje &#8592; 1100 1200 1300 900 850 930 1050 970
    (Prodeje &gt; 1000) / Prodeje
1100 1200 1300 1050
</pre>

<p>V&nbsp;pøípadì, ¾e je zapotøebí získat indexy prvkù a nikoli jejich hodnoty,
mù¾eme si vypomoci vektorem zkonstruovaným pomocí funkce &iota; (jóta) se
stejnou délkou, jako má pùvodní vektor:</p>

<pre>
    Prodeje &#8592; 1100 1200 1300 900 850 930 1050 970
    Prodeje
1100 1200 1300 900 850 930 1050 970
    Prodeje &gt; 1000
1 1 1 0 0 0 1 0
    &rho;Prodeje
8
    &iota;&rho;Prodeje
1 2 3 4 5 6 7 8
</pre>

<p>Máme tedy dva mezivýsledky, oba ve formì vektoru o shodné délce (konkrétnì
vektor 1 1 1 0 0 0 1 0 a 1 2 3 4 5 6 7 8), které je mo¾né zkonstruovat a
souèasnì i vzájemnì zkombinovat v&nbsp;jednom pøíkazu a získat tak indexy prvkù
odpovídajících zapsané podmínce:</p>

<pre>
    (Prodeje&gt;1000)/&iota;&rho;Prodeje
1 2 3 7
</pre>



<p><a name="k03"></a></p>
<h2>3. Malý dáreèek Lispaøùm &ndash; funkce &bdquo;take&ldquo; a &bdquo;drop&ldquo;</h2>

<p>Programovací jazyk <i>APL</i> obsahuje i dvojici funkcí, které se pou¾ívají
pro manipulaci se seznamy, jen¾ jsou reprezentovány pomocí vektorù,
tj.&nbsp;jednodimenzionálních polí. Jedná se o funkce pojmenované
&bdquo;take&ldquo; a &bdquo;drop&ldquo;. Funkce &bdquo;take&ldquo;, která se
zapisuje pomocí symbolu &#8593;, slou¾í k&nbsp;získání prvních <i>n</i> prvkù
seznamu. Pokud je pou¾ita monadická forma této funkce, vrátí se pouze první
prvek (co¾ v&nbsp;Lispu odpovídá funkci <i>car</i>), v&nbsp;pøípadì pou¾ití
dyadické formy se vrátí takový poèet prvkù, jaký udává hodnota prvního
parametru této funkce (druhým parametrem je samotný seznam). Naproti tomu
funkce &bdquo;drop&ldquo; zapisovaná pomocí symbolu &#8595;
&bdquo;zahodí&ldquo; prvních <i>n</i> prvkù seznamu a následnì vrátí jeho
zbytek (tak¾e 1&#8595; odpovídá v&nbsp;Lispu funkci <i>cdr</i>).
U obou funkcí lze <i>n</i> zadat i jako záporné èíslo. V&nbsp;tomto
pøípadì se prvky vybírají èi zahazují z&nbsp;konce seznamu a nikoli z&nbsp;jeho
zaèátku. Následuje jednoduchý pøíklad ukazující vlastnosti obou vý¹e zmínìných
funkcí &bdquo;take&ldquo; a &bdquo;drop&ldquo;. V&nbsp;pøíkladu jsou pou¾ita
záporná èísla, která jsou oznaèena symbolem &#175; (overbar, high-minus) a
nikoli funkcí - (minus):</p>

<pre>
    Seznam &#8592; &iota;10
    Seznam
1 2 3 4 5 6 7 8 9 10
    1 &#8593; Seznam
1
    1 &#8595; Seznam
2 3 4 5 6 7 8 9 10
    &#8593; Seznam
1
    4 &#8593; Seznam
1 2 3 4
    5 &#8595; Seznam
6 7 8 9 10
    &#175;1 &#8593; Seznam
10
    &#175;1 &#8595; Seznam
1 2 3 4 5 6 7 8 9
</pre>


<p><a name="k04"></a></p>
<h2>4. Pou¾ití funkcí &bdquo;take&ldquo; a &bdquo;drop&ldquo;</h2>

<p>Funkce &bdquo;take&ldquo; a &bdquo;drop&ldquo; je mo¾né pou¾ít i ke
slo¾itìj¹ím výpoètùm s&nbsp;vektory, opìt (jak je tomu v&nbsp;programovacím
jazyce <i>APL</i> zvykem) bez pou¾ití programových smyèek. Jedná se o výpoèty,
ve kterých je nutné provádìt aritmetické èi logické operace se sousedními
hodnotami ulo¾enými ve vektoru, a to tehdy, kdy¾ není mo¾né pou¾ít minule
popsané operátory <i>reduce</i> a <i>scan</i>. Napøíklad budeme chtít vypoèítat
mezimìsíèní rozdíly mezi tr¾bami nìjaké firmy (tr¾by jsou ulo¾eny ve vektoru
<i>Trzby</i>), a to jak v&nbsp;absolutních hodnotách, tak i rozdíly vyjádøené
v&nbsp;procentech poklesu èi naopak vzrùstu. Nejprve si vytvoøíme dva pomocné
vektory, z&nbsp;nich¾ jeden <strong>ne</strong>obsahuje první prvek pùvodního
vektoru a druhý naopak <strong>ne</strong>obsahuje jeho prvek poslední.
Vytvoøení pomocných vektorù zajistí funkce &bdquo;drop&ldquo; (bylo by sice
mo¾né pou¾ít i funkci &bdquo;take&ldquo;, ale u té by se musela vypoèítat délka
vektoru, co¾ je zbyteènì komplikované):</p>

<pre>
    Trzby &#8592; 56 59 67 64 60 61 68 73 78 75 81 84
    Trzby
56 59 67 64 60 61 68 73 78 75 81 84
    1 &#8595; Trzby
59 67 64 60 61 68 73 78 75 81 84
    &#175;1 &#8595; Trzby
56 59 67 64 60 61 68 73 78 75 81
</pre>

<p>Výpoèet rozdílù mezi jednotlivými mìsíèními tr¾bami je po získání pomocných
vektorù triviální, nebo» tyto vektory staèí od sebe odeèíst:</p>

<pre>
    (1 &#8595; Trzby) - (&#175;1 &#8595; Trzby)
3 8 &#175;3 &#175;4 1 7 5 5 &#175;3 6 3
</pre>

<p>Následuje vzorec pro výpoèet rùstu èi poklesu tr¾eb vyjádøeného
v&nbsp;procentech, opìt bez pou¾ití programových smyèek a pomocných
promìnných:</p>

<pre>
    100 &times; ((1 &#8595; Trzby) &divide; (&#175;1 &#8595; Trzby)) - 1
5.35 13.56 &#175;4.48 ...
</pre>

<p>V&nbsp;pøípadì nejistoty, zda se nejdøíve provede odeètení jednièky od
mezivýsledku èi vynásobení mezivýsledku hodnotou 100 si pøipomeòme, ¾e
v&nbsp;jazyku <i>APL</i> se parametry v¹ech funkcí vyhodnocují zprava doleva,
tj.&nbsp;nejdøíve je od podílu odeètena jednièka a teprve poté je proveden
pøevod na procentní vyjádøení výsledku celého výpoètu (pomocí závorek se
samozøejmì dá poøadí vyhodnocování v&nbsp;pøípadì potøeby upravit).</p>



<p><a name="k05"></a></p>
<h2>5. Operátor &bdquo;outer product&ldquo;</h2>

<p>V&nbsp;pøedchozí èásti tohoto èlánku jsme se zabývali významem
<i>operátorù</i> v&nbsp;programovacím jazyce <i>APL</i> a takté¾ jsme si
nìkteré operátory popsali. Jednalo se o operátory &bdquo;reduce&ldquo;,
&bdquo;scan&ldquo; a &bdquo;axis&ldquo;. Ov¹em v&nbsp;<i>APL</i> je mo¾né
pou¾ít minimálnì dal¹í tøi operátory, pøièem¾ modernìj¹í verze interpretrù a
pøekladaèù tohoto jazyka navíc zavádí i nìkolik operátorù dal¹ích.
V&nbsp;následující tabulce jsou pro pøipomenutí vypsány základní operátory,
které by mìly být dostupné ve v¹ech implementacích programovacího jazyka
<i>APL</i>:</p>

<table>
<tr><th>Operátor</th><th>Unicode</th><th>Jméno</th></tr>
<tr><td>&#168;  </td><td>00a8      </td><td>each</td></tr>
<tr><td>/       </td><td>002f      </td><td>slash, reduce</td></tr>
<tr><td>\       </td><td>005c      </td><td>backslash, scan</td></tr>
<tr><td>[]      </td><td>005b, 005d</td><td>axis</td></tr>
<tr><td>.       </td><td>002e      </td><td>inner product</td></tr>
<tr><td>&#9702;.</td><td>25e6, 002e</td><td>outer product</td></tr>
</table>

<p>Jedním z&nbsp;prozatím nepopsaných operátorù je operátor nazvaný &bdquo;outer product&ldquo; zapisovaný dvojicí symbolù &#9702;. (koleèko+teèka) za ní¾ následuje jméno èi symbol nìjaké dyadické funkce. Tento operátor je zalo¾en na principu aplikace zvolené dyadické funkce na dvojici vektorù <i>x</i> a <i>y</i>, pøièem¾ vybraná funkce je aplikována na v¹echny mo¾né kombinace slo¾ek prvního a druhého vektoru. Výsledkem je matice <i>Z</i> obsahující v&nbsp;prvku <i>z<sub>ij</sub></i> návratovou hodnotu funkce aplikované na prvky <i>x<sub>i</sub></i> a <i>y<sub>j</sub></i>. Nejlépe si význam i princip práce tohoto operátoru vysvìtlíme na pøíkladu, ve kterém se pokusíme vypsat èást tabulky malé násobilky:</p>

<pre>
     1 2 3 4 5 &#9702;.&times; 1 2 3 4 5
1 2 3 4 5
2 4 6 8 10
3 6 9 12 15
4 8 12 16 20
5 10 15 20 25
</pre>

<p>Programátoøi v&nbsp;<i>APL</i> by ale spí¹e napsali:</p>

<pre>
     (&iota;5)&#9702;.&times;(&iota;5)
1 2 3 4 5
2 4 6 8 10
3 6 9 12 15
4 8 12 16 20
5 10 15 20 25
</pre>

<p>V&nbsp;první èásti èlánku o jazyce <i>APL</i> jsme si uvedli i primitivní
funkci *, která slou¾í k&nbsp;umocnìní dvou èísel, tj.&nbsp;provedení operace
<i>x<sup>y</sup></i>. Tabulku mocnin prvních ètyø pøirozených èísel lze získat
snadno:</p>

<pre>
     (&iota;4)&#9702;.*(&iota;4)
1 1 1 1
2 4 8 16
3 9 27 81
4 16 64 256
</pre>

<p>Tento operátor je samozøejmì mo¾né pou¾ít i v&nbsp;kombinaci s&nbsp;dal¹ími
funkcemi, nejenom s&nbsp;násobením a umocòováním. Pomìrnì èasto se pou¾ívá
napøíklad ke konstrukci jednotkové matice èi trojúhelníkové matice obsahující
pouze prvky s&nbsp;hodnotou 0 a 1. Konstrukce tìchto matic je s&nbsp;vyu¾itím
vý¹e uvedených porovnávacích (relaèních) funkcí velmi snadná a rychlá:</p>

<pre>
     (&iota;5)&#9702;.=(&iota;5)
1 0 0 0 0
0 1 0 0 0
0 0 1 0 0
0 0 0 1 0
0 0 0 0 1
     (&iota;5)&#9702;.&lt;(&iota;5)
0 1 1 1 1
0 0 1 1 1
0 0 0 1 1
0 0 0 0 1
0 0 0 0 0
     (&iota;5)&#9702;.&le;(&iota;5)
1 1 1 1 1
0 1 1 1 1
0 0 1 1 1
0 0 0 1 1
0 0 0 0 1
     (&iota;5)&#9702;.&ge;(&iota;5)
1 0 0 0 0
1 1 0 0 0
1 1 1 0 0
1 1 1 1 0
1 1 1 1 1
</pre>



<p><a name="k06"></a></p>
<h2>6. Operátor &bdquo;inner product&ldquo;</h2>

<p>Druhý z&nbsp;doposud nepopsaných operátorù je operátor &bdquo;inner
product&ldquo; zapisovaný formou teèky okolo které se uvádí programátorem
zvolená dvojice funkcí (mù¾e se jednat jak o u¾ivatelské funkce, tak i o funkce
primitivní). V&nbsp;podstatì se jedná o zobecnìnou operaci násobení matic,
ov¹em s&nbsp;tím roz¹íøením, ¾e obì aritmetické operace pou¾ité pøi násobení
matic (tj.&nbsp;souèin a souèet) je pøi pou¾ití operátoru &bdquo;inner
product&ldquo; mo¾né zadat formou dvojice dyadických funkcí. To znamená, ¾e
pouze pøi pou¾ití cca dvaceti základních primitivních funkcí je mo¾né vytvoøit
a¾ 400 jejich kombinací a nahradit tak pomìrnì znaènou èást (nejenom
maticových) algoritmù pouhou aplikací jednoho operátoru na dvojici funkcí.
Kromì násobení matic lze napøíklad pomocí &bdquo;inner productu&ldquo; vyjádøit
hodnotu polynomu pro libovolné <i>x</i> (polynom je zadán vektorem koeficientù
<i>a<sub>i</sub></i>) atd.</p>



<p><a name="k07"></a></p>
<h2>7. Hierarchické datové struktury</h2>

<p>Ve v¹ech pøedchozích pøíkladech jsme pou¾ívali buï skalární hodnoty, vektory
(jednorozmìrná pole) nebo pravidelné matice (dvourozmìrná pole). Programovací
jazyk <i>APL</i> v¹ak ve svých moderních implementacích podporuje i
hierarchické datové struktury, které jsou ov¹em stále reprezentovány pomocí
polí. Jednou z&nbsp;nejpou¾ívanìj¹ích struktur jsou vnoøené seznamy, na které
se lze také dívat jako na &bdquo;zubaté&ldquo; pole, resp.&nbsp;jako na matici
s&nbsp;nestejnì dlouhými øádky. Zápis takové struktury je velmi jednoduchý
(pov¹imnìte si, ¾e pøi inicializaci není nutné uvádìt  dimenze ani velikost
pole):</p>

<pre>
DATA &#8592; (1 2 3) (4 5) (6 7) (8 9 10 11)
</pre>

<p>Pøedchozí struktura pøedstavuje vektor, jeho¾ prvky jsou takté¾ vektory.
Podobnou strukturu lze vytvoøit i z&nbsp;matic &ndash; prvkem matice toti¾ mù¾e
být skalární hodnota, vektor, matice èi pole o prakticky libovolné dimenzi
(vìt¹inou jsme omezeni 63 dimenzemi, tak¾e se o skuteèné omezení ani nejedná).
Následující pøíkaz vytvoøí tabulku (matici) o dvou øádcích a tøech sloupcích.
První prvek matice je takté¾ maticí, tentokrát o velikosti 2&times;2 prvky,
druhý prvek je seznamem (vektorem) o pìti prvcích, tøetí prvek je øetìzcem
(seznamem ¹esti znakù) atd. Pov¹imnìte si nutnosti uzávorkování nìkterých
podvýrazù:</p>

<pre>
NEST &#8592; 2 3&rho;(2 2&rho;&iota;4) (&iota;5) 'HELLO!' (2 4&rho;&iota;8) 23 (3 2&rho; 'APL')
NEST
1 2       1 2 3 4 5  HELLO!
3 4

1 2 3 4          23  APL APL
5 6 7 8              APL APL
                     APL APL
</pre>

<p>Rozmìr pole lze zjistit, jak u¾ víme z&nbsp;pøedchozích èástí seriálu,
pomocí monadické formy primitivní funkce &rho;:</p>

<pre>
&rho;NEST
2 3
</pre>

<p>Pøi práci s&nbsp;hierarchickými strukturami je nìkdy nutné zjistit stupeò
zanoøení zpracovávané datové struktury. Pro zji¹tìní stupnì zanoøení jakéhokoli
objektu zpracovávaného jazykem <i>APL</i> je urèena funkce <i>depth</i>
zapisovaná pomocí symbolu &#8801;. Platí, ¾e skalární hodnoty mají v¾dy stupeò
zanoøení roven nule, kde¾to pole (vektory, matice, ...) obsahující pouze
skalární hodnoty mají stupeò zanoøení 1. Vý¹e uvedené pole <i>NEST</i> má
stupeò zanoøení roven dvìma, proto¾e jako svùj prvek obsahuje matice.
Vlastnosti funkce &#8801; si mù¾eme snadno ovìøit na nìkolika hodnotách:</p>

<pre>
&#8801;42
0

&#8801;1 2 3
1

&#8801;2 2&rho;3 4 5 6
1

&#8801;NEST
2
</pre>

<p>Programovací jazyk <i>APL</i> oplývá mnoha dal¹ími vlastnostmi, které jsme
si nestaèili v&nbsp;tomto èlánku popsat. Nìkteré z&nbsp;tìchto vlastností budou
vysvìtleny v&nbsp;následující èásti seriálu, v&nbsp;ní¾ se budeme vìnovat
programovacímu jazyku <i>J</i>, který z&nbsp;<i>APL</i> ideovì vychází (není se
ostatnì èemu divit, proto¾e oba jazyky mají spoleèného autora).</p>



<p><a name="k08"></a></p>
<h2>8. Literatura</h2>

<ol>

<li>Ajay Askoolum, &bdquo;<i>System Building with APL + WIN,</i>&ldquo;<br />Wiley, ISBN: 0-470-03020-8, August 2006.</li>

<li>Brown et. al. &bdquo;<i>APL2 at a Glance,</i>&ldquo;<br />Prentice Hall, ISBN 0-13-038670-7.</li>

<li>T. Budd, &bdquo;<i>An APL Compiler,</i>&ldquo;<br />Springer-Verlag.</li>

<li>Maurice Dalois, &bdquo;<i>Introduction to APL*PLUS PC,</i>&ldquo;</li>

<li>J. Ever and C. Fair, &bdquo;<i>Guidelines for APL Systems,</i>&ldquo;<br />DPD 22 IBM 037301, March 1976.</li>

<li>Gilman and Rose, &bdquo;<i>APL - An Interactive Approach,</i>&ldquo;<br /> Wiley, ISBN 220-471-30022-5.</li>

<li>Ulf Grenander, &bdquo;<i>Mathematical Experiments on the Computer,</i>&ldquo;<br />Academic Press, 1982, ISBN 0-12-301750-5.</li>

<li>Kent Haralson, &bdquo;<i>Useful APL Defined Functions</i>&ldquo;,<br />IBM Technical Report, TR 00.2409, Feb. 8 1973.</li>

<li>Timothy Holls, &bdquo;<i>APL Programming Guide,</i>&ldquo;<br />IBM G320-6103, 1978, and G320-6735, 1981.</li>

<li>IBM, &bdquo;<i>APL2 Programming: Language Reference</i>&ldquo;<br />(Version 2, SH21-1061; Version 1, SH20-9227).</li>

<li>IBM, &bdquo;<i>The APL Handbook of Techniques</i>&ldquo;,<br />IBM publication number S320-5996, April 1978.</li>

<li>IBM, &bdquo;<i>The IBM System Journal, V. 30, No. 4 (1991)</i>&ldquo;,<br />Special Issue Devoted to APL.</li>

<li>MicroAPL, &bdquo;<i>Learning APL with APLX</i>&ldquo;,<br />Version 5.0 July 2009</li>

<li>A.D. Falkoff, K.E Iverson, E.H Sussenguth, &bdquo;<i>A formal description of System/360,</i>&ldquo;<br />The IBM System Journal, V. 3, No. 3 (1964)</li>

<li>K. E. Iverson, &bdquo;<i>A Programming Language</i>&ldquo;,<br />Wiley, 1962.</li>

<li>K. E. Iverson, &bdquo;<i>Algebra : an algorithmic treatment</i>&ldquo;,<br />APL Press 1977, Copyright 1972 by Addison Wesley,<br />Preliminary Edition entitled &bdquo;<i>Elementary Algebra</i>&ldquo;<br />Copyright 1971 by IBM Corporation.</li>

<li>K. E. Iverson, &bdquo;<i>Elementary analysis</i>&ldquo;,<br />APL press 1976, Preliminary Edition &bdquo;<i>Elementary Functions</i>&ldquo;<br />Copyright 1974 by IBM Corporation ISBN 0-917326-01-6</li>

<li>K. E. Iverson, &bdquo;<i>An introduction to APL for Scientists and Engineers</i>&ldquo;,<br />APL Press 1976,<br />First published by IMB Corporation as Technical Report No 320-3019 March 1973 - ISBN 0-917326-04-0</li>

<li>K. E. Iverson, &bdquo;<i>APL in exposition</i>&ldquo;,<br />APL Press 1976,<br />First published by IBM Corporation as Technical Report No 320-3010 March 1973 - ISBN 0-917326-02-4.</li>

<li>K. E. Iverson, &bdquo;<i>Introduction To APL</i>&ldquo;,<br />(1984-APL Press Palo Alto) ISBN 0-917326-14-8.</li>

<li>K. E. Iverson, &bdquo;<i>A personal view of APL,</i>&ldquo;<br />IBM Systems Journal,</li>

<li> K. E. Iverson, &bdquo;<i>Concrete Mathematics Companion</i>&ldquo;.</li>

<li>S. Kamin, &bdquo;<i>Programming Languages: An Interpreter-Based Approach,</i>&ldquo;<br />contains (among other things) toy implementations of Lisp, APL, Scheme, SASL, CLU, Smalltalk, and Prolog, Addison-Wesley, 1990, ISBN 0-201-06824-9.</li>

<li>Bernard LEGRAND, &bdquo;<i>Les APL Etendus,</i>&ldquo;<br />Masson, Paris, 1994. An introduction to modern APL (French).</li>

<li>Jon McGrew, &bdquo;<i>An Introduction to APL2,</i>&ldquo;<br />IBM (SH20-9229).</li>

<li>James A. Mason, &bdquo;<i>Learning APL: An Array Processing Language,</i>&ldquo;<br />Harper &amp; Row Publishers Inc., New York, 1986, ISBN 0-06-044243-3 260 pp.</li>

<li>Peelle, &bdquo;<i>APL an Introduction</i>&ldquo;,<br />Holt, Rinehart &amp; Winston, ISBN 0-03-004953-9.</li>

<li>Reiter &amp; Jones, &bdquo;<i>APL with a Mathematical Accent</i>&ldquo;,<br />Brooks/Cole ISBN 0-534-12864-5, (now being distributed by Chapman &amp; Hall).</li>

<li>C. Reiter, &bdquo;<i>Fractuals Visualization and J</i>&ldquo;,<br />Iverson Software, Inc, 1995 ISBN 1-895721-11-3.</li>

<li>Adrian Smith, &bdquo;<i>APL, A Design Handbook for Commercial Systems,</i>&ldquo;<br />Wiley series in information processing, Wiley &amp; Sons, 1982, ISBN 0-471-10092-7.</li>

<li>D. Stiers, M.J. Goovaerts, J. De Kerf, &bdquo;<i>APL - The Language and its Actuarial Applications</i>&ldquo;</li>

<li>Norman D. Thomson, Raymond P. Polivka, &bdquo;<i>APL2 in Depth,</i>&ldquo;<br />Springer-Verlag, 1995, ISBN 0-387-94213-0.</li>

<li>Jerry R. Turner, &bdquo;<i>APL IS EASY!,</i>&ldquo;<br />Manugistics, 1993.</li>

<li>&bdquo;<i>SHARP APL Reference Manual,</i>&ldquo;<br />2nd ed., Soliton Associates Limited PC Version: Iverson Software, 1993, ISBN 1-895721-07-5.</li>

<li>&bdquo;<i>A Source Book in APL,</i>&ldquo;<br />APL Press, 1981, ISBN 0-917326-10-5.</li>

<li>&bdquo;<i>J Phrases,</i>&ldquo;<br />Iverson Software, 1996, ISBN 1-895721-12-1</li>

<li>&bdquo;<i>Exploring Math</i>&ldquo;, Iverson Software, 1996, ISBN 1-895721-13-X</li>

<li>&bdquo;<i>J Primer,</i>&ldquo;<br />Iverson Software, 1996, ISBN 1-895721-14-8</li>

<li>Linda Alvord and Norman Thomson, &bdquo;<i>Easy-J: An Introduction to the World's most Remarkable Programming Language</i>&ldquo;<br />October 2002</li>

</ol>



<p><a name="k09"></a></p>
<h2>9. Odkazy na Internetu</h2>

<ol>

<li>APL &ndash; A Glimpse of Heaven<br />
<a href="http://www.vector.org.uk/archive/v231/legrand.htm">http://www.vector.org.uk/archive/v231/legrand.htm</a>
</li>

<li>Vector (obsahuje odkazy na èlánky, knihy a blogy o programovacích jazycích APL, J a K)<br />
<a href="http://www.vector.org.uk/">http://www.vector.org.uk/</a>
</li>

<li>APL Interpreters<br />
<a href="http://www.vector.org.uk/?area=interpreters">http://www.vector.org.uk/?area=interpreters</a>
</li>

<li>APL_(programming_language<br />
<a href="http://en.wikipedia.org/wiki/APL_(programming_language">http://en.wikipedia.org/wiki/APL_(programming_language</a>
</li>

<li>APL FAQ<br />
<a href="http://www.faqs.org/faqs/apl-faq/">http://www.faqs.org/faqs/apl-faq/</a>
</li>

<li>APL FAQ (nejnovìj¹í verze)<br />
<a href="http://home.earthlink.net/~swsirlin/apl.faq.html">http://home.earthlink.net/~swsirlin/apl.faq.html</a>
</li>

<li>A+<br />
<a href="http://www.aplusdev.org/">http://www.aplusdev.org/</a>
</li>

<li>APLX<br />
<a href="http://www.microapl.co.uk/">http://www.microapl.co.uk/</a>
</li>

<li>FreeAPL<br />
<a href="http://www.pyr.fi/apl/index.htm">http://www.pyr.fi/apl/index.htm</a>
</li>

<li>J: a modern, high-level, general-purpose, high-performance programming language<br />
<a href="http://www.jsoftware.com/">http://www.jsoftware.com/</a>
</li>

<li>K, Kdb: an APL derivative for Solaris, Linux, Windows<br />
<a href="http://www.kx.com">http://www.kx.com</a>
</li>

<li>openAPL (GPL)<br />
<a href="http://sourceforge.net/projects/openapl">http://sourceforge.net/projects/openapl</a>
</li>

<li>Parrot APL (GPL)<br />
<a href="http://www.parrotcode.org/">http://www.parrotcode.org/</a>
</li>

<li>Learning J (Roger Stokes)<br />
<a href="http://www.jsoftware.com/help/learning/contents.htm">http://www.jsoftware.com/help/learning/contents.htm</a>
</li>

<li>Rosetta Code<br />
<a href="http://rosettacode.org/wiki/Main_Page">http://rosettacode.org/wiki/Main_Page</a>
</li>

<li>Why APL<br />
<a href="http://www.acm.org/sigapl/whyapl.htm">http://www.acm.org/sigapl/whyapl.htm</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2009</small></p>
</body>
</html>

