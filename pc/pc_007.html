<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Uèíme trpaslíky poèítat podruhé</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Uèíme trpaslíky poèítat podruhé</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V sedmé èásti seriálu o architekturách poèítaèù si øekneme, které logické instrukce je mo¾né provádìt v aritmeticko-logické jednotce. Pøedev¹ím se ale budeme zabývat problematikou porovnávání dvou hodnot ulo¾ených v pracovních registrech a souèinností porovnávacích instrukcí s podmínìnými skoky.</p>



<h1>Obsah</h1>
<p>
<a href="#k01">1. Logické operace provádìné v&nbsp;ALU</a><br />
<a href="#k02">2. Logická operace <strong>AND</strong></a><br />
<a href="#k03">3. Logická operace <strong>OR</strong></a><br />
<a href="#k04">4. Logická operace <strong>XOR</strong></a><br />
<a href="#k05">5. Logická operace <strong>COM</strong></a><br />
<a href="#k06">6. Nepodmínìný skok</a><br />
<a href="#k07">7. Podmínìné skoky</a><br />
<a href="#k08">8. Pou¾ití instrukce <strong>CMP</strong> v&nbsp;souèinnosti s&nbsp;podmínìnými skoky</a><br />
<a href="#k09">9. Obsah následující èásti seriálu</a><br />
</p>



<p><a name="k01"></a></p>
<h1>1. Logické operace provádìné v&nbsp;ALU</h1>

<p>Vìt¹ina aritmeticko-logických jednotek pou¾itých v&nbsp;mikroprocesorech
podporuje provádìní nejménì ètyø základních logických operací, ke kterým se
v&nbsp;nìkterých pøípadech mohou pøidat i operace dal¹í. Jedná se o operaci
logického bitového souèinu (<strong>AND</strong>) nad v¹emi korespondujícími
bity pracovních registrù èi jednoho pracovního registru, operaci logického
souètu (<strong>OR</strong>), nonekvivalenci (<strong>XOR</strong> èi
<strong>EOR</strong>) a koneènì operaci bitové negace (<strong>COM</strong>)
v¹ech bitù jednoho z&nbsp;pracovních registrù <strong>A</strong> èi
<strong>B</strong>.</p>

<p>První tøi operace, tj.&nbsp;logický souèin, logický souèet a nonekvivalence,
jsou operacemi binárními, co¾ znamená, ¾e vy¾adují dva operandy (vìt¹inou oba
pracovní registry), poslední operace &ndash; negace &ndash;, je operací unární,
tj.&nbsp;na vstupu vy¾aduje pouze obsah pracovního registru <strong>A</strong>
èi <strong>B</strong>. V¹echny ètyøi podporované logické instrukce jsou vypsány
v&nbsp;následující tabulce, pro jejich podrobnìj¹í popis jsou vyhrazeny
samostatné kapitoly: <a href="#k02">AND</a>, <a href="#k03">OR</a>, <a
href="#k04">XOR</a> a <a href="#k05">COM</a>.</p>

<table>
<tr><th colspan="3">Logické instrukce</th></tr>
<tr><th>Kód instrukce (hex)</th><th>Mnemotechnická zkratka instrukce</th><th>Význam</th></tr>
<tr><td>06</td><td>AND</td><td>operace bitového souèinu nad v¹emi korespondujícími bity pracovních registrù (A a B)</td></tr>
<tr><td>07</td><td>OR</td><td>operace bitového souètu nad v¹emi korespondujícími bity pracovních registrù (A a B)</td></tr>
<tr><td>08</td><td>XOR</td><td>operace bitové nonekvivalence nad v¹emi korespondujícími bity pracovních registrù (A a B)</td></tr>
<tr><td>09</td><td>COM</td><td>negace v¹ech bitù jednoho z registrù A èi B</td></tr>
</table>



<p><a name="k02"></a></p>
<h1>2. Logická operace <strong>AND</strong></h1>

<p>V&nbsp;programech psaných ve strojovém kódu nebo jazyku symbolických
instrukcí se velmi èasto pou¾ívá logická operace <strong>AND</strong>, která
provádí logický souèin obsahu pracovního registru <strong>A</strong>
s&nbsp;obsahem pracovního registru <strong>B</strong> (je v¹ak mo¾né provést i
logický souèin pouze s&nbsp;registrem <strong>A</strong> èi registrem
<strong>B</strong>). Souèin je provádìn bit po bitu. Výsledek je ulo¾en do
jednoho z&nbsp;pracovních registrù v&nbsp;závislosti na adresní èásti
instrukce.</p>

<image id="6070" />
<p-center>Prùbìh logické operace AND je shodný napøíklad se souètem</p-center>

<p>Podle výsledku operace je nastaven pøíznak <strong>Zero flag</strong>
(výsledek je nulový èi nenulový), naopak pøíznak <strong>Carry flag</strong> si
zachová pùvodní hodnotu. Tato operace slou¾í jak k&nbsp;implementaci logického
souèinu s&nbsp;pravdivostními hodnotami (pracovní registry v&nbsp;tomto pøípadì
typicky obsahují hodnoty 0x0000 nebo 0xFFFF), tak i k&nbsp;maskování vybraných
bitù jednoho z&nbsp;pracovních registrù. Obsah druhého pracovního registru
slou¾í jako takzvaná <i>maska</i>: pokud je nìjaký bit masky roven nule, je
vynulován i pøíslu¹ný bit prvního pracovního registru. Následují pøíklady
pou¾ití této instrukce:</p>

<table>
<tr><th></th><th>hex</th><th>binárnì</th><th>Zero flag</th></tr>
<tr><td>operand 1</td><td>0000</td><td>0000000000000000</td><td></td></tr>
<tr><td>operand 2</td><td>0000</td><td>0000000000000000</td><td></td></tr>
<tr><td>výsledek </td><td>0000</td><td>0000000000000000</td><td>1</td></tr>
<tr><td colspan="4"></td></tr>
<tr><td>operand 1</td><td>2A2A</td><td>0010101000101010</td><td></td></tr>
<tr><td>operand 2</td><td>00FF</td><td>0000000011111111</td><td></td></tr>
<tr><td>výsledek </td><td>002A</td><td>0000000000101010</td><td>0</td></tr>
<tr><td colspan="4"></td></tr>
<tr><td>operand 1</td><td>0FF0</td><td>0000111111110000</td><td></td></tr>
<tr><td>operand 2</td><td>FF00</td><td>1111111100000000</td><td></td></tr>
<tr><td>výsledek </td><td>0F00</td><td>0000111100000000</td><td>0</td></tr>
<tr><td colspan="4"></td></tr>
<tr><td>operand 1</td><td>00FF</td><td>0000000011111111</td><td></td></tr>
<tr><td>operand 2</td><td>FF00</td><td>1111111100000000</td><td></td></tr>
<tr><td>výsledek </td><td>0000</td><td>0000000000000000</td><td>1</td></tr>
</table>

<p>Vzhledem k&nbsp;tomu, ¾e má smysl pou¾ít instrukci <strong>AND</strong> na
shodný pracovní registr, existují ètyøi varianty této instrukce, které jsou
navzájem odli¹eny adresním bytem:</p>

<table>
<tr><th>Strojový kód</th><th>Zápis v assembleru</th><th>Význam</th></tr>
<tr><td>06 00</td><td>AND A,A</td><td>A&larr;A &amp; A</td></tr>
<tr><td>06 01</td><td>AND A,B</td><td>A&larr;A &amp; B</td></tr>
<tr><td>06 10</td><td>AND B,A</td><td>B&larr;A &amp; B</td></tr>
<tr><td>06 11</td><td>AND B,B</td><td>B&larr;B &amp; B</td></tr>
</table>



<p><a name="k03"></a></p>
<h1>3. Logická operace <strong>OR</strong></h1>

<p>Logická operace <strong>OR</strong> je urèena k&nbsp;provedení logického
souètu (opìt bit po bitu) s&nbsp;obsahy pracovních registrù <strong>A</strong>
a <strong>B</strong>. Výsledek je ulo¾en do registru, který tvoøí první
parametr instrukce, tj.&nbsp;je uveden na prvním místì pøi zápisu instrukce
v&nbsp;assembleru. Tato operace se pou¾ívá napøíklad pro nastavení urèených
bitù pracovního registru na jednièku (jedná se opìt o maskování, i kdy¾
opaèného významu, ne¾ u instrukce <strong>AND</strong>) nebo pro implementaci
booleovských (pravdivostních) výrazù. Podle výsledku aplikace operace
<strong>OR</strong> se nastaví pøíznak <strong>Zero flag</strong>, zatímco
obsah pøíznaku <strong>Carry flag</strong> zùstane v&nbsp;nezmìnìné (pùvodní)
podobì. Opìt následují pøíklady pou¾ití této operace:</p>

<table>
<tr><th></th><th>hex</th><th>binárnì</th><th>Zero flag</th></tr>
<tr><td>operand 1</td><td>0000</td><td>0000000000000000</td><td></td></tr>
<tr><td>operand 2</td><td>0000</td><td>0000000000000000</td><td></td></tr>
<tr><td>výsledek </td><td>0000</td><td>0000000000000000</td><td>1</td></tr>
<tr><td colspan="4"></td></tr>
<tr><td>operand 1</td><td>2A2A</td><td>0010101000101010</td><td></td></tr>
<tr><td>operand 2</td><td>00FF</td><td>0000000011111111</td><td></td></tr>
<tr><td>výsledek </td><td>2AFF</td><td>0010101011111111</td><td>0</td></tr>
<tr><td colspan="4"></td></tr>
<tr><td>operand 1</td><td>0FF0</td><td>0000111111110000</td><td></td></tr>
<tr><td>operand 2</td><td>FF00</td><td>1111111100000000</td><td></td></tr>
<tr><td>výsledek </td><td>FFF0</td><td>1111111111110000</td><td>0</td></tr>
<tr><td colspan="4"></td></tr>
<tr><td>operand 1</td><td>00FF</td><td>0000000011111111</td><td></td></tr>
<tr><td>operand 2</td><td>FF00</td><td>1111111100000000</td><td></td></tr>
<tr><td>výsledek </td><td>FFFF</td><td>1111111111111111</td><td>0</td></tr>
</table>

<p>U této operace je pou¾it naprosto stejný zpùsob kódování adresní èásti
instrukce, jako u logického souèinu, proto¾e má smysl provádìt logickou operaci
<strong>OR</strong> nad tím samým pracovním registrem (zji¹tìní nulovosti v¹ech
bitù, vynulování pøíznaku <strong>Zero flag</strong> atd.).</p>

<table>
<tr><th>Strojový kód</th><th>Zápis v assembleru</th><th>Význam</th></tr>
<tr><td>07 00</td><td>OR A,A</td><td>A&larr;A | A</td></tr>
<tr><td>07 01</td><td>OR A,B</td><td>A&larr;A | B</td></tr>
<tr><td>07 10</td><td>OR B,A</td><td>B&larr;A | B</td></tr>
<tr><td>07 11</td><td>OR B,B</td><td>B&larr;B | B</td></tr>
</table>



<p><a name="k04"></a></p>
<h1>4. Logická operace <strong>XOR</strong></h1>

<p>Pomocí instrukce <strong>XOR</strong>, která bývá v&nbsp;nìkterých
assemblerech oznaèována mnemotechnickou zkratkou <strong>EOR</strong>, se
provádí operace nonekvivalence, tj.&nbsp;exkluzivní (výluèný) logický souèet
obou zadaných operandù a to opìt, stejnì jako u pøedchozích dvou instrukcí, bit
po bitu. Podle výsledku této instrukce je nastaven pøíznak <strong>Zero
flag</strong>, podobnì jako u vý¹e uvedených operací <strong>AND</strong> a
<strong>OR</strong>.</p>

<p>Zatímco logický souèet i souèin se mj.&nbsp;pou¾ívá pro implementaci
logických výrazù známých z&nbsp;vy¹¹ích programovacích jazykù, je operace
nonekvivalence pou¾ívána k&nbsp;selektivní negaci vybraných bitù, proto¾e ve
chvíli, kdy jsou oba korespondující bity nastaveny na logickou jednièku, je
výsledkem logická nula. Tuto instrukci lze vyu¾ít v&nbsp;poèítaèové grafice,
¹ifrování, generátorech pseudonáhodných posloupností èísel (RND), konstrukci
kontrolních souètù èi cyklických kódù (CRC) atd. Je pøitom
vyu¾ito faktu, ¾e dvojí pou¾ití operace <strong>XOR</strong> se stejným druhým
operandem vede k&nbsp;tomu, ¾e výsledkem je pùvodní hodnota, pøedaná operaci
v&nbsp;prvním kroku. Následují pøíklady pou¾ití, ve kterých stojí za pov¹imnutí
"negující" vlastnost této instrukce (poslední pøíklad) i to, ¾e aplikace
nonekvivalence na tu samou hodnotu dává nulový výsledek (tøetí pøíklad).</p>

<table>
<tr><th></th><th>hex</th><th>binárnì</th><th>Zero flag</th></tr>
<tr><td>operand 1</td><td>0000</td><td>0000000000000000</td><td></td></tr>
<tr><td>operand 2</td><td>0000</td><td>0000000000000000</td><td></td></tr>
<tr><td>výsledek </td><td>0000</td><td>0000000000000000</td><td>1</td></tr>
<tr><td colspan="4"></td></tr>
<tr><td>operand 1</td><td>2A2A</td><td>0010101000101010</td><td></td></tr>
<tr><td>operand 2</td><td>00FF</td><td>0000000011111111</td><td></td></tr>
<tr><td>výsledek </td><td>2AD5</td><td>0010101011010101</td><td>0</td></tr>
<tr><td colspan="4"></td></tr>
<tr><td>operand 1</td><td>2A2A</td><td>0010101000101010</td><td></td></tr>
<tr><td>operand 2</td><td>2A2A</td><td>0010101000101010</td><td></td></tr>
<tr><td>výsledek </td><td>0000</td><td>0000000000000000</td><td>1</td></tr>
<tr><td colspan="4"></td></tr>
<tr><td>operand 1</td><td>0FF0</td><td>0000111111110000</td><td></td></tr>
<tr><td>operand 2</td><td>FF00</td><td>1111111100000000</td><td></td></tr>
<tr><td>výsledek </td><td>F0F0</td><td>1111000011110000</td><td>0</td></tr>
<tr><td colspan="4"></td></tr>
<tr><td>operand 1</td><td>00FF</td><td>0000000011111111</td><td></td></tr>
<tr><td>operand 2</td><td>FF00</td><td>1111111100000000</td><td></td></tr>
<tr><td>výsledek </td><td>FFFF</td><td>1111111111111111</td><td>0</td></tr>
<tr><td colspan="4"></td></tr>
<tr><td>operand 1</td><td>002A</td><td>0000000000101010</td><td></td></tr>
<tr><td>operand 2</td><td>FFFF</td><td>1111111111111111</td><td></td></tr>
<tr><td>výsledek </td><td>FFD5</td><td>1111111111010101</td><td>0</td></tr>
</table>

<p>I logickou operaci nonekvivalence je mo¾né aplikovat na ten samý pracovní
registr (registr vystupuje v&nbsp;roli obou vstupních operandù). Z&nbsp;tohoto
dùvodu existují ètyøi varianty instrukce odli¹ené její adresní èástí,
tj.&nbsp;bytem umístìným za vlastní operaèní kód instrukce:</p>

<table>
<tr><th>Strojový kód</th><th>Zápis v assembleru</th><th>Význam</th></tr>
<tr><td>08 00</td><td>XOR A,A</td><td>A&larr;A ^ A</td></tr>
<tr><td>08 01</td><td>XOR A,B</td><td>A&larr;A ^ B</td></tr>
<tr><td>08 10</td><td>XOR B,A</td><td>B&larr;A ^ B</td></tr>
<tr><td>08 11</td><td>XOR B,B</td><td>B&larr;B ^ B</td></tr>
</table>



<p><a name="k05"></a></p>
<h1>5. Logická operace <strong>COM</strong></h1>

<p>V&nbsp;pøedcházející èásti seriálu jsme si popsali mj.&nbsp;zpùsob odeèítání
dvou celoèíselných hodnot. Z&nbsp;dùvodu implementace sèítaèky i odèítaèky tím
samým obvodem, se na jednom ze vstupù sèítaèky nachází blok ¹estnácti
invertorù. Ten je (samozøejmì kromì zmínìného odèítání a dále vysvìtlené
instrukce <strong>CMP</strong>) vyu¾it i pro provedení operace negace v¹ech
bitù jednoho z&nbsp;pracovních registrù <strong>A</strong> èi
<strong>B</strong>.</p>

<image id="6071" />
<p-center>Prùbìh logické operace COM A se podobá napøíklad instrukcím inkrementace a dekrementace</p-center>

<p>Jedná se o instrukci nazvanou <strong>COM</strong>, co¾ je zkratka
anglického slova <i>complement</i> (doplnìk). Ohlednì mnemotechnické zkratky
této instrukce panuje pomìrnì velký zmatek, proto¾e nìkteøí výrobci
mikroprocesorù (kteøí vìt¹inou souèasnì zkratky instrukcí pro svoje výrobky
definují) pou¾ívají zkratku <strong>NEG</strong> èi <strong>NOT</strong>, a
jiní naopak zkratku <strong>NEG</strong> vyhradili pro instrukci urèenou pro
vytvoøení dvojkového doplòku, tj.&nbsp;zmìny znaménka èísla. My se v¹ak budeme
dr¾et zkratky <strong>COM</strong>, která se pou¾ívá napøíklad u mikroprocesorù
firmy Intel èi Motorola. Následuje pøíklad pou¾ití této instrukce:</p>

<table>
<tr><th>                                 </th><th>dec unsigned</th><th>dec signed</th><th>hex</th><th>binárnì</th></tr>
<tr><td>pùvodní hodnota                  </td><td>    0</td><td>     0</td><td>0000</td><td>0000000000000000</td></tr>
<tr><td>po provedení <strong>COM</strong></td><td>65535</td><td>    -1</td><td>FFFF</td><td>1111111111111111</td></tr>
<tr><td colspan="4"></td></tr>
<tr><td>pùvodní hodnota                  </td><td>   42</td><td>    42</td><td>002A</td><td>0000000000101010</td></tr>
<tr><td>po provedení <strong>COM</strong></td><td>65493</td><td>   -43</td><td>FFD5</td><td>1111111111010101</td></tr>
<tr><td colspan="4"></td></tr>
<tr><td>pùvodní hodnota                  </td><td>12345</td><td> 12345</td><td>3039</td><td>0011000000111001</td></tr>
<tr><td>po provedení <strong>COM</strong></td><td>53190</td><td>-12346</td><td>CFC6</td><td>1100111111000110</td></tr>
</table>

<p>Jeliko¾ se jedná o unární operaci, je zdrojový i cílový registr zakódován
pouze jedním adresním bitem, tj.&nbsp;celá adresní èást instrukce (jednobytová)
nabývá buï hodnoty 00 nebo 01:</p>

<table>
<tr><th>Strojový kód</th><th>Zápis v assembleru</th><th>Význam</th></tr>
<tr><td>09 00</td><td>COM A</td><td>A&larr;~A</td></tr>
<tr><td>09 01</td><td>COM B</td><td>B&larr;~B</td></tr>
</table>

<image id="6072" />
<p-center>Prùbìh logické operace COM B</p-center>



<p><a name="k06"></a></p>
<h1>6. Nepodmínìný skok</h1>

<p>Dal¹ím typem instrukcí, které v&nbsp;rùzné podobì najdeme prakticky u v¹ech
mikroprocesorù, jsou instrukce provádìjící skoky na nìjakou adresu
v&nbsp;operaèní pamìti. Implementace skoku není v&nbsp;pøípadì na¹eho
jednoduchého mikroprocesoru nijak slo¾itá, proto¾e v&nbsp;nìm není vyu¾íváno
zøetìzené zpracování instrukcí (<i>pipelining</i>), co¾ je technologie, kterou
si popí¹eme pozdìji (právì kvùli pipeliningu jsou dnes skoky pova¾ovány za
pomalé pøíkazy a v&nbsp;moderních mikroprocesorech se pro zmírnìní následkù
skoku pou¾ívají rùzné <i>prediktory</i>).</p>

<image id="6073" />
<p-center>Zpùsob naèítání instrukèních kódù do øadièe</p-center>

<p>Skoky dìlíme na <i>podmínìné</i> a <i>nepodmínìné</i>. Skoky nepodmínìné
jsou jednodu¹¹í a svou podstatou odpovídají pøíkazu <strong>goto</strong>
známého z&nbsp;nìkterých programovacích jazykù a také mnoha èlánkù, ve kterých
autoøi bez hlub¹ího zamy¹lení se nad pùvodní my¹lenkou opakují, ¾e by se goto
nemìlo pøi strukturovaném programování pou¾ívat :-). V&nbsp;assembleru se v¹ak
skoky vesele pou¾ívají, nebo» právì pomocí nich se vytváøí základní konstrukce
strukturovaného programování &ndash; podmínky a programové smyèky.</p>

<image id="6074" />
<p-center>Po provedení ka¾dé instrukce (kromì skoku) je PC v ALU zvý¹en o hodnotu odpovídající poètu bytù instrukce</p-center>

<p>Nepodmínìný skok je implementován velmi jednodu¹e a pøímoèaøe &ndash; za
operaèním kódem instrukce se nachází ¹estnáctibitová adresa, která je naètena
do registru <strong>PC</strong>. Vzhledem k&nbsp;tomu, ¾e mikroprocesor ète
instrukce v&nbsp;závislosti na obsahu registru <strong>PC</strong>, znamená
zmìna tohoto registru skuteèný pøesun na zadanou adresu, proto¾e dal¹í
instrukce bude ètena z&nbsp;adresy, kterou <strong>PC</strong> obsahuje.</p>

<image id="6075" />
<p-center>Provedení nepodmínìného skoku: za opkódem instrukce se nachází adresa, která je naètena a následnì ulo¾ena do PC</p-center>

<p>Ná¹ mikroprocesor má implementovánu pouze jednu podobu nepodmínìného skoku:
jedná se o <i>absolutní skok</i>, nebo» adresa ulo¾ená za operaèním kódem je
chápána absolutnì &ndash; pøepí¹e <strong>PC</strong> bez ohledu na jeho
pøedchozí hodnotu. Dále uvedené <i>podmínìné skoky</i> jsou skoky
<i>relativní</i>. Operaèní kód instrukce pro provedení nepodmínìného
absolutního skoku má hodnotu 0x16, jak ostatnì ukazuje následující tabulka. Pøi
psaní programu v&nbsp;jazyku symbolických instrukcí (assembleru) se vìt¹inou
nezapisuje adresa skoku pøímo (jako èíslo), ale symbolicky, tj.&nbsp;pomocí
identifikátoru adresy (takzvaný <i>label</i>).</p>

<table>
<tr><th colspan="3">Nepodmínìný skok</th></tr>
<tr><th>Kód instrukce (hex)</th><th>Mnemotechnická zkratka instrukce</th><th>Význam</th></tr>
<tr><td>16</td><td>JMP</td><td>nepodmínìný skok na zadanou adresu</td></tr>
</table>



<p><a name="k07"></a></p>
<h1>7. Podmínìné skoky</h1>

<p>Mnohem zajímavìj¹í jsou <i>podmínìné skoky</i>, které se pøi programování
v&nbsp;assembleru èi strojovém kódu pou¾ívají pro implementaci programových
smyèek a konstrukcí typu if-then-else atd. Podmínìný skok je proveden èi
neproveden na základì nìjaké podmínky. Vzhledem k&nbsp;tomu, ¾e pracujeme na té
nejni¾¹í programové úrovni, tj.&nbsp;na úrovni strojových instrukcí, není
samozøejmì mo¾né podmínku definovat nìjakým slo¾itým a sofistikovaným zpùsobem
&ndash; musí se jednat o operaci, kterou mikroprocesor doká¾e jednodu¹e a
rychle zpracovat.</p>

<image id="6076" />
<p-center>Provedení podmínìného skoku: za opkódem instrukce se nachází relativní adresa, která je v pøípadì splnìní podmínky pøiètena k obsahu PC</p-center>

<p>Z&nbsp;tohoto dùvodu jsou podmínky zalo¾eny na testování jednoho
z&nbsp;pøíznakových bitù èi negací tìchto bitù, co¾ je v&nbsp;na¹em pøípadì
<strong>Carry flag</strong> a <strong>Zero flag</strong>, tj.&nbsp;<i>pøíznak
pøenosu</i> a <i>pøíznak nulovosti</i>. Existují tedy ètyøi varianty
podmínìného skoku, které jsou vypsány v&nbsp;následující tabulce.
V&nbsp;pøípadì, ¾e podmínka není splnìna (tj.&nbsp;testovaný pøíznakový bit má
opaènou hodnotu ne¾ oèekávanou), není skok proveden, tj.&nbsp;mikroprocesor
instrukci skoku v&nbsp;podstatì ignoruje a pokraèuje v&nbsp;naètení instrukce
uvedené ihned za skokem.</p>

<table>
<tr><th colspan="3">Podmínìné skoky</th></tr>
<tr><th>Kód instrukce (hex)</th><th>Mnemotechnická zkratka instrukce</th><th>Význam</th></tr>
<tr><td>1a</td><td>JC</td><td>podmínìný skok za pøedpokladu, ¾e je nastaven pøíznak pøenosu (<strong>Carry flag</strong>)</td></tr>
<tr><td>1b</td><td>JNC</td><td>podmínìný skok za pøedpokladu, ¾e je vynulován pøíznak pøenosu (<strong>Carry flag</strong>)</td></tr>
<tr><td>1c</td><td>JZ</td><td>podmínìný skok za pøedpokladu, ¾e je nastaven pøíznak nulovosti (<strong>Zero flag</strong>)</td></tr>
<tr><td>1d</td><td>JNZ</td><td>podmínìný skok za pøedpokladu, ¾e je vynulován pøíznak nulovosti (<strong>Zero flag</strong>)</td></tr>
</table>

<p>Za operaèním kódem podmínìného skoku následuje adresní èást, která má
velikost pouze <i>jednoho</i> bytu. Vzhledem k&nbsp;tomu, ¾e adresní prostor
na¹eho mikroprocesoru je ¹estnáctibitový (obsahující v¹echny adresy 0x0000 a¾
0xFFFF), musí existovat zpùsob, jak tuto jednobytovou (tj.&nbsp;osmibitovou)
adresu zpracovat. Øe¹ení, které je z&nbsp;nìkolika hledisek optimální, spoèívá
v&nbsp;tom, ¾e onu osmibitovou adresní èást pova¾ujeme za <i>relativní
adresu</i> (reprezentovanou ve dvojkovém doplòku), která musí být pøiètena
k&nbsp;aktuální hodnotì registru <strong>PC</strong>.</p>

<p>Tento zpùsob adresování má nìkolik dùsledkù: samotná adresa je krátká, co¾
vede na úsporné strojové instrukce a pøedev¹ím je program pou¾ívající pouze
relativní skoky pøemístitelný na libovolné místo v&nbsp;pamìti, neboli
<i>realokovatelný</i>. Co to znamená? Vzhledem k&nbsp;tomu, ¾e je adresa
zapsána zpùsobem +xx resp.&nbsp; -yy, je mo¾né program posunout v&nbsp;operaèní
pamìti na prakticky jakékoli místo, proto¾e se tato relativní adresa nemusí
mìnit, zatímco absolutní adresa by se mìnit musela.</p>



<p><a name="k08"></a></p>
<h1>8. Pou¾ití instrukce <strong>CMP</strong> v&nbsp;souèinnosti s&nbsp;podmínìnými skoky</h1>

<p>V&nbsp;pøedchozí kapitole jsme si øekli, ¾e podmínìné relativní skoky jsou
pou¾ity pro implementaci programových smyèek a podmínek. K&nbsp;tomuto úèelu se
podmínìné skoky kombinují s&nbsp;nìkterou instrukcí, která modifikuje
pøíznakové registry. Napøíklad jednoduchou poèítanou smyèku by bylo mo¾né
implementovat kombinací instrukce <strong>DEC</strong> (ta nastavuje pøíznak
nuly, tj.&nbsp;<strong>Zero flag</strong>) a podmínìného skoku
<strong>JNZ</strong>, který je proveden tehdy, pokud pøíznak nuly <i>není</i>
nastaven:</p>

<code-area>
        LD A, poèet_opakování  ; poèet opakování smyèky
SMYCKA  pøíkaz 1               ; libovolné instrukce, jejich¾ celková
        pøíkaz 2               ; délka musí být men¹í ne¾ cca 120 bytù
        pøíkaz X               ; (kvùli omezení relativního skoku)
        DEC A                  ; sní¾ení èítaèe smyèky o jednièku
        JNZ SMYCKA             ; pøelo¾í se jako relativní skok -xx
</code-area>

<p>Spolu s&nbsp;podmínìnými skoky se velmi èasto pou¾ívá je¹tì nepopsaná
instrukce <strong>CMP</strong>. Ve své podstatì se jedná o bì¾né odeèítání,
tj.&nbsp;instrukci <strong>SUB</strong>, ov¹em s&nbsp;tím rozdílem, ¾e
výsledek, tj.&nbsp;rozdíl není nikam zapsán, co¾ znamená, ¾e se obsah
pracovních registrù provedením této instrukce nezmìní. Na první pohled mù¾e
vypadat tato instrukce nesmyslnì &ndash; proè se mají odeèítat dvì hodnoty,
kdy¾ se výsledek hned zapomene? Ov¹em samotný výsledek není v¹e, proto¾e pøi
odeèítání si mikroprocesor v&nbsp;pøíznakových registrech zapamatuje i to, zda
byla odeèítaná èísla shodná (<strong>Zero flag</strong> je roven jedné) èi zda
byla druhá hodnota vìt¹í ne¾ hodnota první (<strong>Carry flag</strong> je
roven jedné). Instrukce <strong>CMP</strong> je vypsána v&nbsp;následující
tabulce:</p>

<table>
<tr><th colspan="3">Testování a porovnání</th></tr>
<tr><th>Kód instrukce (hex)</th><th>Mnemotechnická zkratka instrukce</th><th>Význam</th></tr>
<tr><td>0f</td><td>CMP</td><td>aritmetické porovnání obsahu registrù a ovlivnìní pøíznakù</td></tr>
</table>

<image id="6077" />
<p-center>Prùbìh instrukce CMP A, B</p-center>

<p>Tato instrukce existuje ve ètyøech variantách li¹ících se porovnávanými
registry (zde zále¾í na poøadí operandù, stejnì jako u odèítání!):</p>

<table>
<tr><th>Strojový kód</th><th>Zápis v assembleru</th><th>Význam</th></tr>
<tr><td>0f 00</td><td>CMP A,A</td><td>A-A</td></tr>
<tr><td>0f 01</td><td>CMP A,B</td><td>A-B</td></tr>
<tr><td>0f 10</td><td>CMP B,A</td><td>B-A</td></tr>
<tr><td>0f 11</td><td>CMP B,B</td><td>B-B</td></tr>
</table>

<p>Uveïme si nìkolik pøíkladù, jak se pomocí instrukce <strong>CMP</strong>
nastavují pøíznakové bity:</p>

<table>
<tr><th>men¹enec</th><th>men¹itel</th><th>Zero flag</th><th>Carry flag</th></tr>
<tr><td>0000</td><td>0000</td><td>1</td><td>0</td></tr>
<tr><td>0010</td><td>0005</td><td>0</td><td>0</td></tr>
<tr><td>0010</td><td>0010</td><td>1</td><td>0</td></tr>
<tr><td>0005</td><td>0010</td><td>0</td><td>1</td></tr>
</table>

<p>Z&nbsp;tìchto pøíkladù vyplývá to, jak mù¾eme pøíznakové bity pou¾ít.
Jestli¾e je zapotøebí testovat dvì hodnoty na rovnost, postaèí zjistit, zda je
<strong>Zero flag</strong> nastavený na jednièku. Pokud potøebujeme otestovat,
jestli je první hodnota men¹í ne¾ druhá, lze zjistit hodnotu pøíznaku
<strong>Carry flag</strong> atd. Test na nulovou hodnotu lze provést odeètením
nuly &ndash; výsledek bude ulo¾en v&nbsp;<strong>Zero flagu</strong>:</p>

<code-area>

; test na rovnost dvou hodnot
LD  A, hodnota 1
LD  B, hodnota 2
CMP A,B
JZ  JE_ROVNO    ; skok na kód provedený v pøípadì rovnosti
JNZ NENI_ROVNO  ; skok na kód provedený v pøípadì nerovnosti


; zji¹tìní relace dvou èísel
LD  A, hodnota 1
LD  B, hodnota 2
CMP A,B
JNC A_JE_VETSI_NEBO_ROVNO_B
JC  A_JE_MENSI_NEZ_B


; test na nulovost
LD  A, hodnota
SUB B,B          ; vynulování registru B (lze i XOR B,B)
CMP A,B
JZ  A_JE_NULOVE



; poèítaná smyèka s krokem
        LD A, 0xFFFF-poèáteèní_hodnota*krok ; (vypoèítá assembler v dobì pøekladu)
        LD B, krok
SMYCKA  pøíkaz 1               ; libovolné instrukce, jejich¾ celková
        pøíkaz 2               ; délka musí být men¹í ne¾ cca 120 bytù
        pøíkaz X               ; (kvùli omezení relativního skoku)
        ADD A,B                ; zvý¹ení èítaèe smyèky o krok
        JNC SMYCKA             ; pøíznak se nastaví pøi pøekroèení 0xFFFF

; jak se bude mìnit hodnota A pøi poèáteèním nastavení A=0xFFF0 a B=0x0002:
reg. A   Carry flag
0xFFF0   0
0xFFF2   0
0xFFF4   0
0xFFF6   0
0xFFF8   0
0xFFFA   0
0xFFFC   0
0xFFFE   0
0x0001   1 : konec smyèky (dùvod, proè nepou¾ít JNZ v tomto typu smyèky)

</code-area>

<p>Tímto zpùsobem se dají vytváøet i dal¹í podmínky èi smyèky. Dal¹í pøíklady
si uvedeme pøí¹tì, pøi vysvìtlování instrukcí pro rotace a aritmetické
posuvy.</p>

<image id="6078" />
<p-center>Prùbìh instrukce CMP A, A</p-center>



<p><a name="k09"></a></p>
<h1>9. Obsah následující èásti seriálu</h1>

<p>V&nbsp;dal¹í èásti seriálu o èinnosti poèítaèe budeme pokraèovat
v&nbsp;popisu instrukèního souboru na¹eho jednoduchého cvièného mikroprocesoru.
Øekneme si, jakým zpùsobem je mo¾né naèítat konstanty do pracovních registrù,
popí¹eme si instrukce pro pøesun obsahu pracovních registrù z&nbsp;a do
operaèní pamìti a také dokonèíme èást vìnovanou skokùm popisem instrukcí pro
skok do podprogramu a návratu z&nbsp;podprogramu, vèetnì dvou instrukcí
urèených pro práci se zásobníkem. Budeme tedy znát v¹echny instrukce potøebné
pro programování ve strojovém kódu nebo jazyku symbolických instrukcí
(assembleru).</p>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2008</small></p>
</body>
</html>

