<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Scheme: definice anonymních i pojmenovaných funkcí, iterace</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Scheme: definice anonymních i pojmenovaných funkcí, iterace</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o historii výpoèetní techniky si øekneme, jakým zpùsobem se v programovacím jazyce Scheme vytváøí nové funkce, a to jak funkce pojmenované, tak i funkce anonymní (oba typy funkcí mohou mít pevný èi promìnný poèet parametrù). Dále si popí¹eme, jak lze ve Scheme zapsat iteraci &ndash; pomocí rekurze, s&nbsp;vyu¾itím universální smyèky "do" èi makrem "while".</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Vytváøení nových u¾ivatelských funkcí</a></p>
<p><a href="#k02">2. Pojmenování u¾ivatelských funkcí</a></p>
<p><a href="#k03">3. Anonymní funkce</a></p>
<p><a href="#k04">4. Anonymní funkce s&nbsp;promìnným poètem parametrù</a></p>
<p><a href="#k05">5. Pojmenované funkce s&nbsp;promìnným poètem parametrù</a></p>
<p><a href="#k06">6. Rekurze</a></p>
<p><a href="#k07">7. Programová smyèka typu &bdquo;do&ldquo;</a></p>
<p><a href="#k08">8. Makro &bdquo;while&ldquo;</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2>1. Vytváøení nových u¾ivatelských funkcí</h2>

<p>V&nbsp;pøedchozí èásti seriálu o historii výpoèetní techniky jsme si popsali
nìkteré základní programové konstrukce, ze kterých se skládají prakticky
v¹echny programy napsané v&nbsp;programovacím jazyku <i>Scheme</i>. Ov¹em pro
tvorbu skuteèných programù, nejenom jednoduchých demonstraèních pøíkladù, je
zapotøebí znát i nìkteré dal¹í u¾iteèné konstrukce. Naprostým základem pøi
tvorbì ka¾dé jen tro¹ku rozsáhlej¹í aplikace je dekompozice problému na men¹í
èásti, které je mo¾né realizovat snadnìji, proto¾e se výchozí problém více
konkretizuje (a pøibli¾uje se tak jak mo¾nostem programovacího jazyka, tak i
schopnosti vývojáøe problém naprogramovat :-). V&nbsp;programovacím jazyku
<i>Scheme</i> se, podobnì jako v&nbsp;mnoha dal¹ích imperativních a pøedev¹ím
funkcionálních programovacích jazycích, pro rozklad problému na men¹í èásti
pou¾ívají u¾ivatelsky definované funkce, a to jak funkce pojmenované, tak i
funkce anonymní (tento typ funkcí je pøedstavován lambda výrazy).</p>

<p>V&nbsp;této kapitole si popí¹eme zpùsob tvorby pojmenovaných funkcí a <a
href="#k02">v&nbsp;kapitole následující</a> se budeme zabývat problémem tvorby
funkcí anonymních, s&nbsp;èím¾ souvisí i problematika vytvoøení a následného
pou¾ití lokálních promìnných. Mo¾ná by na tomto místì bylo vhodné pøipomenout,
¾e z&nbsp;èistì teoretického hlediska by se mìly anonymní funkce popsat døíve
ne¾ funkce pojmenované, proto¾e právì anonymní funkce tvoøí základ pro
vytváøení jak funkcí pojmenovaných, tak i lokálních promìnných (a mnoha dal¹ích
u¾iteèných jazykových konstrukcí). Vytvoøení u¾ivatelské pojmenované funkce je
v&nbsp;programovacím jazyku <i>Scheme</i> velmi jednoduché &ndash; pou¾ije se
speciální forma <strong>define</strong>, za ní¾ se do seznamu zapí¹e jméno novì
vytváøené funkce i jména jejích formálních parametrù. Za tímto seznamem
následuje tìlo funkce, tj.&nbsp;výraz èi sekvence výrazù, které se mají
vyhodnotit (v&nbsp;tìchto výrazech je samozøejmì mo¾né pou¾ívat formální
parametry funkce).</p>

<p>Hodnota posledního vyhodnoceného výrazu se stává i návratovou hodnotou celé
funkce, co¾ mj.&nbsp;znamená, ¾e v¹echny pøedchozí výrazy musí mít vedlej¹í
efekt, jinak je jejich volání (pou¾ití v&nbsp;tìle funkce) vlastnì zbyteèné.
Formálnì vypadá vytvoøení nové funkce následovnì:</p>

<pre>
(define ([jméno funkce] [formální parametry]) [tìlo funkce])
</pre>

<p>Postup vytvoøení u¾ivatelské funkce s&nbsp;jedním parametrem a jejího
následného pou¾ití:</p>

<pre>
(define (square x) (* x x))

(square 42)
1764

(square (+ 1 2))
9

(+ (square 3) (square 4))
25
</pre>

<p>Samozøejmì je mo¾né vytvoøit i funkci víceparametrickou:</p>

<pre>
(define (kvadratic a b c x) (+ (* a x x) (* b x) c))

(kvadratic 1 0 0 1)
1

(kvadratic 2 2 2 4)
42
</pre>



<p><a name="k02"></a></p>
<h2>2. Pojmenování u¾ivatelských funkcí</h2>

<p>V&nbsp;programovacím jazyku <i>Scheme</i> lze vytváøet i funkce,
v&nbsp;jejich¾ názvu se nachází rùzné nealfanumerické znaky. Je to ostatnì
logické, proto¾e se jedná o jeden z&nbsp;jazykù, v&nbsp;nich¾ neexistují ani
operátory (zapisované vìt¹inou právì pomocí nealfanumerických znakù) ani
vìt¹ina dal¹ích speciálních syntaktických konstrukcí. V&nbsp;pøedchozí èásti
tohoto seriálu jsme si ji¾ ukázali nìkteré <i>predikáty</i>, u nich¾ je
obvyklé, ¾e jsou jejich jména ukonèena znakem otazník (<strong>?</strong>).
Také jsme se seznámili s&nbsp;konverzními funkcemi pou¾ívajícími ve svém
názvu dvojici znakù <strong>-&gt;</strong>.
Mnohdy se také mù¾eme setkat s&nbsp;tím, ¾e se jméno u¾ivatelské funkce skládá
z&nbsp;více slov oddìlených pomlèkou (<strong>-</strong>), která je
v&nbsp;jiných programovacích jazycích vìt¹inou rezervována pro zápis operátoru
rozdílu popø.&nbsp;zmìny znaménka. V&nbsp;následujících pøíkladech je ukázáno,
¾e jména u¾ivatelských funkcí mohou opravdu obsahovat témìø jakýkoli
nealfanumerický znak (výjimek je pouze nìkolik, vypsány jsou napøíklad
v&nbsp;<i>R<sub>5</sub>RS</i>):</p>

<pre>
(define (&gt;= x y)
    (or (&gt; x y) (= x y))
)

; druhá mo¾ná definice
(define (&gt;= x y)
    (not (&lt; x y))
)
</pre>

<p>První pøiblí¾ení k&nbsp;tomu, jak by se mohl zapsat ternární výraz. Tento
pøíklad v¹ak má jeden pomìrnì záva¾ný nedostatek vyplývající z&nbsp;vlastnosti
jazyka <i>Scheme</i>. Doká¾ete pøijít na to, o jaký nedostatek se jedná?</p>

<pre>
(define (?: podminka prvni-vyraz druhy-vyraz)
    (if podminka prvni-vyraz druhy-vyraz)
)

; test
(?: #t 1 2)
1

(?: #f 1 2)
2

; Pøi tisku jednotlivých slov lze namísto
; øetìzcù pou¾ít i symboly
(?: (&lt; 1 2) 'mensi 'vetsi)
mensi

(?: (&lt; 2 1) 'mensi 'vetsi) 
vetsi
</pre>

<p>Programátoøi v&nbsp;Basicu pravdìpodobnì znají operátor &lt;&gt;
(nerovnost), který lze ve <i>Scheme</i> velmi jednodu¹e vytvoøit jako
u¾ivatelskou funkci:</p>

<pre>
(define (&lt;&gt; x y)
    (not (= x y))
)

(&lt;&gt; 1 2)
 #t

(&lt;&gt; 1 1)
 #f
</pre>

<p>Ov¹em vý¹e uvedenou funkci mù¾eme té¾ zobecnit na libovolný typ
parametrù:</p>

<pre>
(define (&lt;&gt; a b)
    (not (equal? a b))
)

(&lt;&gt; 'a 'b)
#t

(&lt;&gt; "hello" "world")
#t

(&lt;&gt; "hello" "hello")
#f
</pre>



<p><a name="k03"></a></p>
<h2>3. Anonymní funkce</h2>

<p>Kromì pojmenovaných funkcí popsaných v&nbsp;pøedchozích dvou kapitolách je
mo¾né v&nbsp;programovacím jazyce <i>Scheme</i>, podobnì jako
v&nbsp;<i>LISPu</i>, ale i mnoha dal¹ích jazycích umo¾òujících funkcionální
programování, vytváøet a pou¾ívat takzvané funkce anonymní. Tyto funkce, které
je mo¾né s&nbsp;výhodou vyu¾ít napøíklad pøi zápisu iterací nad prvky seznamù
èi pøi omezování oblasti platnosti promìnných, se vytváøí pomocí speciální
formy <strong>lambda</strong>, její¾ název je odvozen ze slavné Churchovy
teorie Lambda kalkulu, která má pomìrnì velký význam jak v&nbsp;teoretické
informatice, tak i v&nbsp;dal¹ích odvìtvích informatiky (viz té¾ odkazy uvedené
<a href="#k09">v&nbsp;poslední kapitole</a>). Samotný zápis anonymní funkce se
pøíli¹ neli¹í od zápisu funkce pojmenované &ndash; jediný syntaktický rozdíl
spoèívá v&nbsp;tom, ¾e se pøi zápisu speciální formy <strong>lambda</strong>
nikde neuvádí jméno funkce, pouze seznam (jména) formálních parametrù, za nimi¾
následuje tìlo funkce:</p>

<pre>
(lambda ([formální parametry]) [tìlo anonymní funkce])
</pre>

<p>Zápis i volání anonymních funkcí si mù¾eme ihned vyzkou¹et:</p>

<pre>
; pouze vytvoøení anonymní funkce bez
; jejího dal¹ího pou¾ití (umìlý pøíklad, který
; nemá vìt¹í význam, proto¾e se anonymní funkce
; nikde nevolá)
(lambda (x) (* x x))
#&lt;procedure #f (x)&gt;

; vytvoøení anonymní funkce s jejím následným
; zavoláním s parametrem 42
((lambda (x) (* x x)) 42)
1764

; anonymní funkce s více parametry
(lambda (a b c) (+ a b c))
#&lt;procedure #f (a b c)&gt;
((lambda (a b c) (+ a b c)) 1 2 3)
6
</pre>

<p>Mezi funkcemi pojmenovanými a anonymními existuje velmi úzká vazba, kterou
si mù¾eme vysvìtlit na jednoduchém pøíkladu. Mìjme u¾ivatelskou funkci nazvanou
<strong>plus</strong>, která seète své dva parametry (pro jednoduchost
pova¾ujme tyto parametry v¾dy za èísla) a vrátí souèet hodnot obou parametrù.
Definice takové funkce je velmi jednoduchá:</p>

<pre>
(define (plus x y) (+ x y))

; test
(plus 1 2)
3
</pre>

<p>Vý¹e uvedený zápis je ekvivalentní s&nbsp;následujícím zápisem, ve kterém se
vytváøí promìnná nazvaná <strong>plus</strong>, která jako svoji hodnotu
obsahuje (anonymní) funkci. Ji¾ v&nbsp;úvodním èlánku o programovacím jazyku
<i>Scheme</i> jsme si øekli, ¾e funkce lze pou¾ívat na stejných místech jako
hodnoty jiných typù, tak¾e je tento zápis korektní:</p>

<pre>
(define plus (lambda (x y) (+ x y)))

; test
(plus 1 2)
3
</pre>



<p><a name="k04"></a></p>
<h2>4. Anonymní funkce s&nbsp;promìnným poètem parametrù</h2>

<p>Kromì anonymních funkcí, v&nbsp;nich¾ jsou explicitnì vyjmenovány v¹echny
jejich parametry, lze v&nbsp;programovacím jazyku <i>Scheme</i> vytváøet a
následnì i volat funkce s&nbsp;promìnným poètem parametrù, co¾ mù¾e být
v&nbsp;nìkterých pøípadech velmi u¾iteèné. V&nbsp;nejjednodu¹¹ím pøípadì, pokud
mají být v¹echny parametry promìnné (tj.&nbsp;ve skuteènosti se anonymní funkce
nemusí volat s&nbsp;parametrem ¾ádným) se pou¾ívá následující zpùsob vytvoøení
anonymní funkce:</p>

<pre>
(lambda [jméno jediného formálního parametru] [tìlo anonymní funkce])
</pre>

<p>To tedy znamená, ¾e mezi následujícími dvìma výrazy je pomìrnì velký
rozdíl:</p>

<pre>
(lambda (x) ...)
(lambda x ...)
</pre>

<p>Pøi volání této anonymní funkce se do formálního parametru pøedá
<i>seznam</i> obsahující v¹echny skuteènì pøedávané parametry. S&nbsp;tímto
seznamem je mo¾né pracovat jako s&nbsp;kterýmkoli jiným seznamem,
tj.&nbsp;napøíklad lze procházet pøes jeho prvky atd:</p>

<pre>
; jeden ze zpùsobù vytvoøení seznamu
((lambda x x) 1 2 3 4)
(1 2 3 4)

; souèet hodnot v¹ech pøedaných parametrù
; (apply bude popsána dále)
((lambda x (apply + x)) 1 2 3 4)

; na parametr (seznam) lze aplikovat rùzné funkce
((lambda x (length x)) 'a 'b 'c 'd)
4
</pre>

<p>Ve <i>Scheme</i> lze té¾ pou¾ít kombinaci obou pøedchozích zpùsobù,
tj.&nbsp;vytvoøení anonymní funkce vy¾adující pevný poèet povinných parametrù
s&nbsp;tím, ¾e v¹echny ostatní hodnoty pøedané anonymní funkci jsou nepovinné.
V¹echny nepovinné hodnoty jsou pøi volání anonymní funkce ulo¾eny do seznamu
pøiøazeného poslednímu parametru, pøièem¾ tento parametr musí být pøi definici
anonymní funkce od ostatních parametrù oddìlen teèkou. Pov¹imnìte si, ¾e se
v&nbsp;tomto pøípadì nejedná o nìjakou speciální syntaxi, kterou bylo nutné do
jazyka zavést, ale pouze o vyu¾ití ji¾ existujících mo¾ností <i>Scheme</i>,
které podporuje, podobnì jako <i>LISP</i>, explicitní zápis teèka-dvojic:</p>

<pre>
(lambda ([formální parametry].poslední parametr) [tìlo anonymní funkce])
</pre>

<p>Následují pøíklady pou¾ití anonymní funkce s&nbsp;nìkolika povinnými
(pojmenovanými) parametry a mo¾ností pøedání dal¹ích hodnot v&nbsp;seznamu
pøedanému poslednímu parametru. Ve v¹ech pøíkladech se v&nbsp;tìle anonymní
funkce pouze vytiskne obsah posledního &bdquo;seznamového&ldquo; parametru:</p>

<pre>
((lambda (a . b) b) 1 2 3 4)
(2 3 4)

((lambda (a b . c) c) 1 2 3 4)
(3 4)

((lambda (a b c . d) d) 1 2 3 4)
(4)

((lambda (a b c d . e) e) 1 2 3 4)
()
</pre>



<p><a name="k05"></a></p>
<h2>5. Pojmenované funkce s&nbsp;promìnným poètem parametrù</h2>

<p>Vzhledem k&nbsp;tomu, ¾e speciální formu <strong>define</strong> lze kdykoli
zapsat pomocí speciální formy <strong>lambda</strong>, je ve <i>Scheme</i>
mo¾né nadefinovat pojmenovanou funkci akceptující promìnný
(tj.&nbsp;v&nbsp;krajním pøípadì i nulový) poèet parametrù, z&nbsp;nich¾ je pøi
volání funkce automaticky vytvoøen seznam, se kterým je mo¾né v&nbsp;tìle
funkce libovolným zpùsobem manipulovat. Syntakticky vypadá definice takové
funkce následovnì:</p>

<pre>
(define (jméno funkce . parametr) [tìlo funkce])
</pre>

<p>Co¾ je ekvivalentní zápisu:</p>

<pre>
(define jméno funkce (lambda parametr [tìlo funkce]))
</pre>

<p>Pøíklad pou¾ití:</p>

<pre>
; funkce vracející poèet skuteènì pøedaných parametrù
(define (foo . parametry) (length parametry))

(foo 1 2 3 4)
4

; alternativní forma zápisu
(define foo (lambda parametry (length parametry)))

; volání funkce se tøemi parametry (zde se jedná o trojici symbolù)
(foo 'a 'b 'c)
3

; volání funkce bez parametrù
(foo)
0
</pre>



<p><a name="k06"></a></p>
<h2>6. Rekurze</h2>

<p>V&nbsp;úvodní èásti na¹eho povídání o programovacím jazyku <i>Scheme</i>
jsme si mj.&nbsp;øekli, ¾e iteraci, tj.&nbsp;opakování èásti kódu (vìt¹inou
s&nbsp;rùznými parametry), lze vyjádøit buï pomocí rekurze nebo s&nbsp;vyu¾itím
explicitnì èi implicitnì zapsaných programových smyèek. Pou¾ití rekurze je
doporuèovaná mo¾nost, proto¾e se nejvíce blí¾í funkcionálnímu stylu
programování a v&nbsp;mnoha pøípadech takté¾ vychází rekurzivní zápis pøímo
z&nbsp;algoritmu, který se v&nbsp;jazyce <i>Scheme</i> implementuje. Následuje
pøíklad nìkolika jednoduchých funkcí zapsaných rekurzivnì. Pov¹imnìte si
pøedev¹ím toho, ¾e se v&nbsp;tìchto rekurzivních funkcích nevyskytují ¾ádné
pomocné lokální promìnné, jejich¾ pou¾ití bychom se nemohli vyhnout
v&nbsp;pøípadì zápisu obdobných výpoètù v&nbsp;nerekurzivní podobì:</p>

<pre>
; rekurzivní zápis výpoètu faktoriálu
(define (factorial n)
    (if (&lt;= n 1)
        1
        (* n (factorial (- n 1)))
    )
)

; rekurzivní výpoèet Fibonacciho posloupnosti
(define (fib n)
    (cond ((= n 0) 0)
          ((= n 1) 1)
          (else (+ (fib (- n 1)) (fib (- n 2))))
    )
)

; rekurzivní výpoèet Ackermannovy funkce
(define (A x y)
    (cond ((= y 0) 0)
          ((= x 0) (* 2 y))
          ((= y 1) 2)
          (else (A (- x 1) (A x (- y 1))))
    )
)
</pre>

<div class="poll" id="poll-1745"><em>Pokud máte mo¾nost nìkterou konstrukci napsat pomocí rekurze nebo programové smyèky, pro co se rozhodujete èastìji?</em></div>



<p><a name="k07"></a></p>
<h2>7. Programová smyèka typu &bdquo;do&ldquo;</h2>

<p>Ov¹em v&nbsp;nìkterých pøípadech mù¾e být vhodnìj¹í nahradit rekurzivní
zápis algoritmu zápisem, v&nbsp;nìm¾ jsou pou¾ity programové smyèky. Pro tyto
úèely obsahuje jazyk <i>Scheme</i> universální smyèku pøedstavovanou speciální
formou <strong>do</strong>. Tuto programovou smyèku lze pou¾ít napøíklad pro
tvorbu cyklu, v&nbsp;nìm¾ se postupnì mìní hodnota øídicí promìnné (èi øídicích
promìnných), cyklu procházejícího pøes prvky seznamu èi cyklu, v&nbsp;nìm¾ se
postupnì naèítají a zpracovávají data ulo¾ená v&nbsp;externím souboru. Pøi
zápisu formy <strong>do</strong> je mo¾né specifikovat seznam lokálních
promìnných platných v&nbsp;tìle smyèky (tyto promìnné mohou být pou¾ity
napøíklad jako poèitadla), výraz, pomocí kterého se hodnota tìchto promìnných
zmìní na konci tìla smyèky, podmínka pro ukonèení smyèky a samozøejmì té¾ tìlo
smyèky, tj.&nbsp;pøíkazy provádìné v&nbsp;ka¾dé iteraci. Následuje jednoduchý
pøíklad pou¾ití speciální formy <strong>do</strong>, pomocí nìho¾ je vytvoøena
klasická poèítaná smyèka:</p>

<pre>
(do ((i 1 (+ i 1)))  ; poèáteèní hodnota poèitadla a iteraèní výraz provedený na konci smyèky
    ((= i 10))       ; podmínka vyhodnocovaná pro ukonèení smyèky
        (display i)  ; tìlo smyèky
        (newline)
)

1
2
3
4
5
6
7
8
9
</pre>

<p>Pøi zápisu speciální formy <strong>do</strong> lze vytvoøit i vìt¹í mno¾ství
lokálních promìnných platných v&nbsp;rámci tìla smyèky, viz následující pøíklad
s&nbsp;trojicí promìnných, z&nbsp;nich¾ ka¾dá se na konci smyèky (pøed zaèátkem
dal¹í iterace) modifikuje na základì vyhodnocení rùzných výrazù:</p>

<pre>
(do (
        (x 1 (* x 2))    ; poèáteèní hodnota promìnné a iteraèní výraz provedený na konci smyèky
        (y 1000 (- y 1)) ; dtto
        (z 0 (* x y))    ; dtto
    )
    ((&lt; y x))         ; podmínka vyhodnocovaná pro ukonèení smyèky
        (display (list x y z)) ; tìlo smyèky
        (newline)
)

(1 1000 0)
(2 999 1000)
(4 998 1998)
(8 997 3992)
(16 996 7976)
(32 995 15936)
(64 994 31840)
(128 993 63616)
(256 992 127104)
(512 991 253952)
</pre>

<p>V&nbsp;dal¹ím pøíkladu je ukázáno postupné zpracování prvkù ulo¾ených
v&nbsp;seznamu (ov¹em tento pøíklad by ve skuteènosti bylo mo¾né napsat mnohem
lépe a jednodu¹eji):</p>

<pre>
(do ((x '(1 2 3 4 5 6) (cdr x))) ; poèáteèní hodnota promìnné a iteraèní výraz provedený na konci smyèky
    ((null? x))                  ; podmínka vyhodnocovaná pro ukonèení smyèky
        (display (car x))        ; tìlo smyèky
        (newline)
)

1
2
3
4
5
6
</pre>

<p>Následuje ponìkud slo¾itìj¹í pøíklad, ve kterém je ukázáno pou¾ití vnoøených
poèítaných smyèek pøi výpoètu podílu v¹ech kombinací dvou celých èísel le¾ících
v&nbsp;rozsahu 1 a¾ 10 (pøipomeòme, ¾e výsledkem podílu dvou celých èísel je ve
<i>Scheme</i> hodnota typu <i>rational</i> tj.&nbsp;racionální èíslo). Na tomto
pøíkladu je patrné, ¾e pro zápis slo¾itìj¹ích programových struktur je vhodné
pou¾ívat pomocné funkce, co¾ je ostatnì zásada, kterou je vhodné dodr¾ovat i
v&nbsp;dal¹ích programovacích jazycích:</p>

<pre>
(do ((y 1 (+ y 1)))               ; poèáteèní hodnota poèitadla a iteraèní pøíkaz
    ((&gt; y 10))                    ; podmínka pro ukonèení smyèky
        (do ((x 1 (+ x 1)))       ; vnitøní smyèka
            ((&gt; x 10))            ; podmínka pro ukonèení vnitøní smyèky
                (display (/ x y)) ; tisk výsledku
                (display "\t")    ; pøechod na dal¹í tabelaèní zará¾ku 
        )
        (newline)                 ; pøechod na dal¹í øádek
)

1       2       3       4       5       6       7       8       9       10
1/2     1       3/2     2       5/2     3       7/2     4       9/2     5
1/3     2/3     1       4/3     5/3     2       7/3     8/3     3       10/3
1/4     1/2     3/4     1       5/4     3/2     7/4     2       9/4     5/2
1/5     2/5     3/5     4/5     1       6/5     7/5     8/5     9/5     2
1/6     1/3     1/2     2/3     5/6     1       7/6     4/3     3/2     5/3
1/7     2/7     3/7     4/7     5/7     6/7     1       8/7     9/7     10/7
1/8     1/4     3/8     1/2     5/8     3/4     7/8     1       9/8     5/4
1/9     2/9     1/3     4/9     5/9     2/3     7/9     8/9     1       10/9
1/10    1/5     3/10    2/5     1/2     3/5     7/10    4/5     9/10    1
</pre>



<p><a name="k08"></a></p>
<h2>8. Makro &bdquo;while&ldquo;</h2>

<p>V&nbsp;nìkterých pøípadech mù¾e být pou¾ití speciální formy
<strong>do</strong> zbyteènì komplikované, pøedev¹ím proto, ¾e se pøi zápisu
této formy pou¾ívá velké mno¾ství závorek, které mohou být pro ètenáøe programù
ponìkud matoucí (napøíklad pro ty u¾ivatele, pro nì¾ není jazyk <i>Scheme</i>
&bdquo;rodným programovacím jazykem&ldquo; :-). V&nbsp;dialektu jazyka
<i>Scheme</i> nazvaného <i>Guile</i> (s&nbsp;pomìrnì velkou pravdìpodobností ho
máte ve svém Linuxu nainstalovaný) se v¹ak mj.&nbsp;nachází i pomìrnì u¾iteèné
makro nazvané <strong>while</strong>, které se ze syntaktického (zpùsob zápisu)
i sémantického (význam zápisu) hlediska podobá klasickým smyèkám
<strong>while</strong> známým z&nbsp;mnoha imperativních programovacích jazykù.
Toto makro lze pou¾ít velmi jednodu¹e &ndash; za jeho jméno postaèuje zapsat
podmínku vyhodnocovanou na zaèátku provádìní ka¾dé iterace (podmínka je
samozøejmì zapsána formou výrazu), za ní¾ následuje tìlo smyèky:</p>

<pre>
(define i 0)           ; pomocná (globální) promìnná - poèitadlo

(while (&lt; i 10)     ; podmínka pro ukonèení provádìní smyèky
    (display i)        ; tìlo smyèky
    (newline)
    (set! i (+ i 1))   ; zvý¹ení hodnoty globální promìnné
)                      ; (pou¾ití nového define by zde vedlo k navázání nové promìnné)

0
1
2
3
4
5
6
7
8
9
</pre>

<p>Výpoèet tabulky podílù dvou celých èísel, který jsme si ji¾ ukázali
v&nbsp;pøedchozí kapitole, lze s&nbsp;vyu¾itím makra <strong>while</strong>
napsat následovnì:</p>

<pre>
(define x 1)                      ; øídicí promìnné obou smyèek
(define y 1)                      ; je zapotøebí explicitnì definovat

(while (&lt;= y 10)                  ; podmínka pro ukonèení vnìj¹í smyèky
    (set! x 1)
    (while (&lt;= x 10)              ; podmínka pro ukonèení vnitøní smyèky
        (display (/ x y))         ; tisk výsledku
        (display "\t")            ; pøechod na dal¹í tabelaèní zará¾ku
        (set! x (+ x 1))
    )
    (set! y (+ y 1))
    (newline)                     ; pøechod na dal¹í øádek
)

1       2       3       4       5       6       7       8       9       10
1/2     1       3/2     2       5/2     3       7/2     4       9/2     5
1/3     2/3     1       4/3     5/3     2       7/3     8/3     3       10/3
1/4     1/2     3/4     1       5/4     3/2     7/4     2       9/4     5/2
1/5     2/5     3/5     4/5     1       6/5     7/5     8/5     9/5     2
1/6     1/3     1/2     2/3     5/6     1       7/6     4/3     3/2     5/3
1/7     2/7     3/7     4/7     5/7     6/7     1       8/7     9/7     10/7
1/8     1/4     3/8     1/2     5/8     3/4     7/8     1       9/8     5/4
1/9     2/9     1/3     4/9     5/9     2/3     7/9     8/9     1       10/9
1/10    1/5     3/10    2/5     1/2     3/5     7/10    4/5     9/10    1
</pre>

<p>Poznámka: rekurzivní zápis pøedchozího pøíkladu by mohl vypadat
následovnì:</p>

<pre>
(define (forx x y limit)
    (display (/ x y))           ; tisk výsledku
    (display "\t")              ; pøechod na dal¹í tabelaèní zará¾ku
    (if (&lt; x limit)
        (forx (+ x 1) y limit)  ; rekurze
    )
)

(define (fory y limit)
    (forx 1 y limit)            ; výpoèet celého øádku hodnot
    (newline)                   ; pøechod na nový øádek
    (if (&lt; y limit)
        (fory (+ y 1) limit)    ; rekurze
    )
)

(fory 1 10)
</pre>

<div class="poll" id="poll-1746"><em>Který ze zpùsobù zápisu programu pro výpoèet podílù dvou èísel vám pøipadá nejvhodnìj¹í?</em></div>



<p><a name="k09"></a></p>
<h2>9. Odkazy na Internetu</h2>

<ol>

<li>Lambda calculus<br />
<a href="http://en.wikipedia.org/wiki/Lambda_calculus">http://en.wikipedia.org/wiki/Lambda_calculus</a>
</li>

<li>A Short Introduction to the Lambda Calculus<br />
<a href="http://www.cs.bham.ac.uk/~axj/pub/papers/lambda-calculus.pdf">http://www.cs.bham.ac.uk/~axj/pub/papers/lambda-calculus.pdf</a>
</li>

<li>A Tutorial Introduction to the Lambda Calculus<br />
<a href="http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf">http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf</a>
</li>

<li>(welcome '(schemers . org))<br />
<a href="http://www.schemers.org/">http://www.schemers.org/</a>
</li>

<li>Revised<sup>5</sup> Report on the Algorithmic Language Scheme<br />
<a href="http://www.schemers.org/Documents/Standards/R5RS/">http://www.schemers.org/Documents/Standards/R5RS/</a>
</li>

<li>The Revised<sup>6</sup> Report on the Algorithmic Language Scheme<br />
<a href="http://www.r6rs.org/">http://www.r6rs.org/</a>
</li>

<li>Scheme<br />
<a href="http://groups.csail.mit.edu/mac/projects/scheme/">http://groups.csail.mit.edu/mac/projects/scheme/</a>
</li>

<li>The Kawa language framework<br />
<a href="http://www.gnu.org/software/kawa/">http://www.gnu.org/software/kawa/</a>
</li>

<li>Scheme 48<br />
<a href="http://s48.org/">http://s48.org/</a>
</li>

<li>Introductory textbooks for Schemers<br />
<a href="http://www.schemers.org/Documents/#intro-texts">http://www.schemers.org/Documents/#intro-texts</a>
</li>

<li>Scheme (programming language)<br />
<a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)">http://en.wikipedia.org/wiki/Scheme_(programming_language)</a>
</li>

<li>Scheme<br />
<a href="http://cs.wikipedia.org/wiki/Scheme">http://cs.wikipedia.org/wiki/Scheme</a>
</li>

<li>Scheme-faq<br />
<a href="http://community.schemewiki.org/?scheme-faq">http://community.schemewiki.org/?scheme-faq</a>
</li>

<li>Scheme implementations<br />
<a href="http://community.schemewiki.org/?scheme-faq-standards#implementations">http://community.schemewiki.org/?scheme-faq-standards#implementations</a>
</li>

<li>Successful Scheme<br />
<a href="http://www.itworld.com/swol-1013-regex">http://www.itworld.com/swol-1013-regex</a>
</li>

<li>Guy L. Steele, Jr.<br />
<a href="http://en.wikipedia.org/wiki/Guy_L._Steele">http://en.wikipedia.org/wiki/Guy_L._Steele</a>
</li>

<li>Gerald Jay Sussman<br />
<a href="http://en.wikipedia.org/wiki/Gerald_Jay_Sussman">http://en.wikipedia.org/wiki/Gerald_Jay_Sussman</a>
</li>

<li>PLT Scheme<br />
<a href="http://www.plt-scheme.org/">http://www.plt-scheme.org/</a>
</li>

<li>Quick: An Introduction to PLT Scheme with Pictures<br />
<a href="http://docs.plt-scheme.org/quick/">http://docs.plt-scheme.org/quick/</a>
</li>

<li>PLT Scheme<br />
<a href="http://en.wikipedia.org/wiki/Plt_scheme">http://en.wikipedia.org/wiki/Plt_scheme</a>
</li>

<li>PLT Scheme Guide<br />
<a href="http://docs.plt-scheme.org/guide/">http://docs.plt-scheme.org/guide/</a>
</li>

<li>The DrScheme Project: An Overview<br />
<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.9543">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.9543</a>
</li>

<li>DrScheme<br />
<a href="http://en.wikipedia.org/wiki/DrScheme">http://en.wikipedia.org/wiki/DrScheme</a>
</li>

<li>How to Design Programs<br />
<a href="http://www.htdp.org/">http://www.htdp.org/</a>
</li>

<li>An Introduction to Scheme<br />
<a href="http://www.acm.org/crossroads/xrds1-2/scheme.html">http://www.acm.org/crossroads/xrds1-2/scheme.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2010</small></p>
</body>
</html>

