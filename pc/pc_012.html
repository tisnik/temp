<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Techniky zvý¹ení výpoèetního výkonu mikroprocesorù 2</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Techniky zvý¹ení výpoèetního výkonu mikroprocesorù 2</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o funkci poèítaèù budeme pokraèovat v popisu rùzných metod, kterými se výrobci sna¾í zvý¹it výpoèetní výkon mikroprocesorù i víceprocesorových systémù. Popí¹eme si superskalární architekturu, èlenìní poèítaèù do kategorií SISD, SIMD, MISD a MISD i takzvané prediktory skokù.</p>



<h1>Obsah</h1>
<p>
<a href="#k01">1. Skalární architektura</a><br />
<a href="#k02">2. Pøekonání omezení daných skalární architekturou</a><br />
<a href="#k03">3. Superskalární architektura</a><br />
<a href="#k04">4. Prediktory skokù &ndash; jedna z&nbsp;cest k&nbsp;vyøe¹ení problémù se zøetìzeným zpracováním instrukcí</a><br />
<a href="#k05">5. Záhadné zkratky SISD, SIMD, MISD, MIMD</a><br />
<a href="#k06">6. Architektura SISD</a><br />
<a href="#k07">7. Architektura SIMD</a><br />
<a href="#k08">8. Architektura MISD</a><br />
<a href="#k09">9. Architektura MIMD</a><br />
</p>



<p><a name="k01"></a></p>
<h1>1. Skalární architektura</h1>

<p>Pøevá¾ná èást osmibitových a ¹estnáctibitových mikroprocesorù i první
generace mikroprocesorù tøicetidvoubitových byla postavena na takzvané
<i>skalární architektuøe</i>. Tímto termínem jsou oznaèovány mikroprocesory,
které v&nbsp;jednou taktu naètou maximálnì jednu instrukci a provedou na
základì jejího operaèního kódu pouze jednu aritmetickou èi logickou operaci
s&nbsp;jednoduchou (skalární) hodnotou. I ná¹ ukázkový mikroprocesor popsaný
v&nbsp;pøedchozích èástech tohoto seriálu má typicky skalární architekturu.
Teoretická maximální rychlost zpracování instrukcí u této architektury je jedna
naètená (a provedená) instrukce v&nbsp;jednom taktu a to je¹tì pouze za
pøedpokladu, ¾e se pou¾ije zøetìzené zpracování instrukcí (<i>pipelining</i>),
nebo je frekvence hodinového signálu tak nízká, ¾e mikroprocesor celou
instrukci stihne provést za jeden hodinový takt (to ov¹em znamená, ¾e se
v&nbsp;tomto pøípadì uvnitø mikroprocesoru hodinový signál rozkládá na je¹tì
krat¹í impulzy, napøíklad na základì jeho nábì¾ných a sestupných hran).</p>

<p>Bez pou¾ití pipeliningu nebo v&nbsp;pøípadì men¹ího mno¾ství øezù instrukèní
pipeliny se jedna instrukce na skalární architektuøe zpracovává ve více
taktech. Tato vlastnost byla typická pro vìt¹inu osmibitových mikroprocesorù
(<strong>Intel 8080</strong>, <strong>MOS 6502</strong>, <strong>Zilog
Z80</strong> a dal¹í slavná jména), které jednu instrukci dokázaly provést
napøíklad ve tøech a¾ dvanácti taktech. Mikroprocesor <strong>Motorola
6800</strong> dokázal nejjednodu¹¹í instrukce, napøíklad souèet akumulátoru
s&nbsp;konstantou, provést ve dvou taktech a instrukci nejslo¾itìj¹í, co¾
v&nbsp;tomto pøípadì byl skok do podprogramu, v&nbsp;taktech osmi, pøièem¾
nebylo pou¾ito ¾ádné zøetìzené provádìní instrukcí (to se také nedá od
mikroprocesoru této kategorie oèekávat). Z&nbsp;typicky skalárních
mikroprocesorù do dne¹ní doby pøe¾ila stále pomìrnì populární typová øada
mikroøadièù <strong>Intel 8051</strong> (nìkteré varianty vyrábìla
v&nbsp;minulosti i na¹e Tesla) a <strong>Motorola 68HC11</strong>.</p>

<p>V¹echny CISCové mikroprocesory firmy Intel øady <strong>x86</strong> od
je¹tì z&nbsp;poloviny osmibitového <strong>8088</strong> a¾ do modelu
<strong>486</strong> (vèetnì) jsou postavené na skalární architektuøe, stejnì
jako velké mno¾ství mikroøadièù èi signálových procesorù (<i>DSP &ndash;
Digital Signal Processor</i>). Mezi pøednosti skalární architektury patøí
pøedev¹ím jednoduchý øadiè, který mù¾e být buï mikroprogramový (<strong>Intel
8086</strong>) èi nanoprogramový (<strong>Motorola 68000</strong>) nebo pevnì
zapojený (<strong>Motorola 6809</strong>). Nevýhodou ov¹em je, ¾e rychlost
naèítání a tím i zpracování instrukcí je shora omezena a ¾e ani s&nbsp;vyu¾itím
velmi dlouhé pipeliny se nedá pøekonat limit jedné zpracovaná instrukce za
jeden takt. Pøíli¹ velké mno¾ství øezù (<i>slices</i>) pipeline má naopak i své
zápory, pøedev¹ím pøi zpracování skokù, návratù z&nbsp;podprogramù èi odezvy na
pøeru¹ení &ndash; ve v¹ech tìchto pøípadech je nutné vyøe¹it problém, co se má
udìlat s&nbsp;instrukcemi, které se nachází v&nbsp;rozpracovaném stavu
v&nbsp;pipeline (mohou se buï zahodit nebo naopak dokonèit, podle toho, jakým
zpùsobem byl lineární bìh programu pøeru¹en).</p>

<image id="6365" original="no" />
<p-center>Známý osmibitový mikroprocesor Motorola 6809</p-center>



<p><a name="k02"></a></p>
<h1>2. Pøekonání omezení daných skalární architekturou</h1>

<p>Jednou z&nbsp;mo¾ností urychlení vykonávání instrukcí je pou¾ití ji¾ minule
popsané architektury <i>VLIW</i> (<i>Very Long Instruction Word</i>).
Mikroprocesory zalo¾ené na VLIW sice doká¾ou v&nbsp;jednom taktu zpracovat
vìt¹í mno¾ství instrukcí (tj.&nbsp;provést více operací), ov¹em za tu cenu, ¾e
je program v¾dy znovu nutné pøelo¾it pøímo pro daný typ mikroprocesoru a není
tak zaruèena binární kompatibilita se star¹ími typy mikroprocesorù. Pro nìkteré
aplikace to není na závadu (signálové procesory pou¾ité ve vestavìných
zaøízeních), ov¹em na osobních poèítaèích, u kterých je z&nbsp;rùzných dùvodù
po¾adována binární kompatibilita, není mo¾né VLIW pøímo pou¾ít. Navíc je
instrukèní slovo málokdy vyu¾ito stoprocentnì, co¾ zbyteènì zvy¹uje nároky na
kapacitu i rychlost operaèní pamìti. Z&nbsp;tìchto dùvodù (a samozøejmì ve
snaze v&nbsp;co nejvy¹¹í míøe urychlit vykonávání instrukcí) se zaèala
prosazovat takzvaná <i>superskalární architektura</i>, která bude popsaná
v&nbsp;následující kapitole.</p>

<image id="6366" />
<p-center>I poslední verze mikroprocesoru 486 mìla skalární architekturu</p-center>



<p><a name="k03"></a></p>
<h1>3. Superskalární architektura</h1>

<p>Mikroprocesory postavené na superskalární architektuøe doká¾ou, podobnì jako
procesory typu VLIW, v&nbsp;jednom taktu zaèít vykonávat více ne¾ jednu
instrukci, pøièem¾ souèasnì vykonávané instrukce (resp.&nbsp;souèasnì
vykonávané stejné fáze instrukcí) pou¾ívají samostatné moduly na
mikroprocesoru.</p>

<p>V&nbsp;praxi to napøíklad mù¾e znamenat to, ¾e mikroprocesor obsahuje dvì
aritmeticko-logické jednotky (ALU), dvì jednotky pro adresaci s&nbsp;vyu¾itím
indexových registrù, dvì jednotky umo¾òující provedení skokù atd.
V&nbsp;nìkterých pøípadech není tato duplikace (èi dokonce multiplikace,
proto¾e je mo¾né mít klidnì i ètyøi nezávislé ALU) výkonných jednotek
mikroprocesoru zcela symetrická, proto¾e mikroprocesor napøíklad mù¾e obsahovat
pouze jednu jednotku pro provádìní operací v&nbsp;pohyblivé øádové èárce (FPU)
èi jen jednu násobièku atd. To je i pøípad prvních superskalárních
mikroprocesorù øady x86 &ndash; <strong>Intel Pentium</strong>, které
obsahovaly dvì pipeliny (ve skuteènosti se jednalo u superskalární
mikroprocesor se zøetìzeným zpracováním instrukcí) nazvané <i>U</i> a <i>V</i>,
které ov¹em nebyly zcela symetrické &ndash; ne v¹echny instrukce bylo mo¾né
v&nbsp;první pipelinì zpracovat. Èím se v¹ak superskalární architektura li¹í od
architektury VLIW, kdy¾ základní my¹lenka, tj.&nbsp;zvý¹ení poètu paralelnì a
nezávisle na sobì pracujících jednotek, je stejná?</p>

<image id="6367" />
<p-center>První procesor kompatibilní s øadou x86 se superskalární architekturou</p-center>

<p>Zásadní rozdíl spoèívá v&nbsp;tom, ¾e zatímco u VLIW je paralelní spou¹tìní
instrukcí zalo¾eno na instrukèním slovu, ve kterém se nachází jednotlivé
operaèní kódy souèasnì provádìných operací (<i>explicitní instrukèní
paralelismus</i>), rozhoduje u superskalární architektury o paralelním
provádìní operací a¾ øadiè na základì toho, jak vyhodnotí obsazení pracovních
registrù a strukturu programu. Operaèní kódy instrukcí jsou tedy naèteny
z&nbsp;fronty instrukcí (ta byla minule popsaná) a teprve øadiè rozhodne, zda a
jak je mo¾né instrukce zpracovávat paralelnì. Toto øe¹ení s&nbsp;sebou pøiná¹í
nìkolik pøedností i záporù. První pøednost je zøejmá &ndash; je zachována
binární kompatibilita, tj.&nbsp;i strojový kód urèený pro star¹í mikroprocesory
té¾e øady (napøíklad <strong>x86</strong>) mù¾e být provozován na
superskalárních mikroprocesorech a to nezávisle na tom, kolik paralelnì
pracujících jednotek tyto mikroprocesory obsahují. Zatímco mikroprocesory
<strong>486</strong> mìly jednu pipelinu pro zpracování instrukcí, u
<strong>Pentií</strong> se objevily pipeliny dvì, poté ètyøi atd.</p>

<p>Mezi nevýhody této architektury patøí slo¾itìj¹í øadiè, který kromì své
bì¾né èinnosti, tj.&nbsp;øízení pipeliny a jednotlivých funkèních jednotek
mikroprocesoru, je¹tì musí rozhodovat o tom, které instrukce je mo¾né
<i>párovat</i> a spou¹tìt souèasnì. Také &ndash; i kdy¾ je zaruèena zpìtná
binární kompatibilita &ndash; je vìt¹inou ¾ádoucí upravit strojový kód programu
tak, aby co nejvíce instrukcí bylo mo¾né spou¹tìt paralelnì, k&nbsp;èemu¾ je
ji¾ potøebná znalost jednotlivých závislostí mezi instrukcemi a jejich operandy
(napøíklad manuál k&nbsp;párování instrukcí na prvních Pentiích mìl skoro sto
stran a to byly pou¾ity pouze dvì instrukèní pipeliny). To je ostatnì také
jeden z&nbsp;dùvodù, proè je ten stejný program pøelo¾ený nejprve v&nbsp;re¾imu
kompatibility s&nbsp;386 a posléze pøelo¾ený pro Pentium ve druhém pøípadì
provádìn na stejném mikroprocesoru i konfiguraci celého poèítaèe rychleji
(zcela jiným dùvodem urychlení nìkterých algoritmù je roz¹íøená instrukèní
sada, napøíklad MMX a SSE, tou se v¹ak budeme podrobnìji zabývat a¾
v&nbsp;dal¹í èásti tohoto seriálu).</p>

<p>Vìt¹inou se pro tento úèel pou¾ívají pøekladaèe vy¹¹ích programovacích
jazykù, které potøebné optimalizace v&nbsp;urèité míøe provádí. Ov¹em ve
speciálních pøípadech je zapotøebí sáhnout k&nbsp;ruèní optimalizaci programù
na úrovni assembleru èi strojového kódu, proto¾e v&nbsp;této oblasti sice mohou
optimalizující pøekladaèe velmi pomoci, ale nejsou samospasitelné (pøekladaè
toti¾ nemá k&nbsp;dispozici stejné mno¾ství informací jako programátor). Také
mnohé <i>just-in-time</i> pøekladaèe (<i>JIT</i>), tj.&nbsp;pøekladaèe spu¹tìné
v&nbsp;dobì bìhu programu, který dynamicky pøekládají, je¾ jsou pou¾ité
napøíklad u platformy Java, mohou provádìt optimalizace, a to v&nbsp;nìkterých
pøípadech je¹tì lépe ne¾ bì¾né pøekladaèe, proto¾e JIT mohou vyu¾ít statistické
informace získané z&nbsp;bì¾ícího programu, optimalizovat pøímo pro daný
mikroprocesor atd. Tato technika, která se zaèíná objevovat i u bì¾ných
pøekladaèù (optimalizace na základì výsledkù nìkolikerého bìhu profileru), se
v&nbsp;pozitivním slova smyslu projeví pøedev¹ím u dlouho bì¾ících aplikací,
napøíklad na serverech.</p>



<p><a name="k04"></a></p>
<h1>4. Prediktory skokù &ndash; jedna z&nbsp;cest k&nbsp;vyøe¹ení problémù se zøetìzeným zpracováním instrukcí</h1>

<p>V&nbsp;pøedchozím textu jsme si øekli, ¾e maximální rychlost zpracování u
skalárních mikroprocesorù je jedna instrukce za jeden takt (nezávisle na
taktovací frekvenci a bitové ¹íøce). U superskalárních mikroprocesorù se
maximální rychlost zvy¹uje se stejnou mírou, jakou stoupá poèet instrukèních
pipeline. Napøíklad první Pentia s&nbsp;dvojicí pipeline dokázaly zpracovat
maximálnì dvì instrukce v&nbsp;jednom taktu. Ov¹em to jsou výsledky dosa¾itelné
za ideálních podmínek, které není mo¾né v&nbsp;reálných programech v¾dy
stoprocentnì splnit. Mezi vlivy, které reálnou rychlost zpracování instrukcí
sni¾ují, patøí pøedev¹ím pøepínání kontextù (zmìna bì¾ící úlohy, která ov¹em
nastává relativnì zøídka, napøíklad 100&times; za sekundu, co¾ je
z&nbsp;hlediska mikroprocesoru velmi dlouhá doba), nedostupnost instrukcí èi
operandù ve vyrovnávací pamìti (výpadek cache), pøíchod pøeru¹ení a
v&nbsp;neposlední øadì také provedení skoku, a» u¾ pøímého, nepøímého,
absolutního, relativního, podmínìného èi nepodmínìného. Mezi skok se poèítá i
vstup do podprogramu a návrat z&nbsp;podprogramu.</p>

<p>Pøi výskytu skoku se toti¾ musí vyøe¹it problém, co se má udìlat
s&nbsp;instrukcemi, které se nachází v&nbsp;rozpracovaném stavu uvnitø
pipeline. Vìt¹inou nastává nejhor¹í pøípad, kdy se tyto instrukce musí zahodit
a po provedení skoku se musí pipeline znovu naplnit, tentokrát jinými
instrukcemi. To má samozøejmì za následek sní¾ení výpoèetního výkonu, které
mù¾e být nìkdy velmi radikální (napøíklad Pentium 4 má pipeline rozdìlenou na
více ne¾ 30 øezù, tj.&nbsp;mù¾e se v&nbsp;ní nacházet tøicet rozpracovaných
instrukcí). Je tedy vhodné nìjakým zpùsobem skoky co nejvíce omezit èi sní¾it
jejich negativní dopad na rychlost bìhu programu. První metoda,
tj.&nbsp;omezení skokù, je zále¾itostí pøekladaèe èi ruèní optimalizace kódu.
Pou¾ívají se rùzné postupy, napøíklad <i>inline funkce</i> (kód funkce je pøímo
vlo¾en na dané místo kódu, aby se funkce nemusela volat) èi rozbalování smyèek
(<i>loop unrolling</i>). To v¹ak není zdaleka v¹e, pou¾ívají se i dal¹í
techniky. Nìkteré procesory místo podmínìných skokù nabízí podmínìné instrukce,
u instrukcí skokù lze &ndash; opìt pouze u nìkterých mikroprocesorù &ndash;
jedním bitem naznaèit, zda je pravdìpodobnìj¹í provedení podmínìného skoku èi
naopak jeho neprovedení atd.</p>

<p>Velmi zajímavou technologií jsou <i>prediktory skokù</i>. Ty slou¾í, jak
ostatnì jejich název napovídá, k&nbsp;tomu, ¾e dopøedu odhadnou, zda se skok
provede èi nikoli a na základì toho zaènou do instrukèní pipeline vkládat (a
postupnì zpracovávat) buï instrukce, které se nachází ihned za skokem èi naopak
v&nbsp;cíli skoku. U jednotlivých skokù nahrazujících konstrukci typu <i>if</i>
je samozøejmì predikce spí¹e loterií, ov¹em známé pravidlo 90/10 (nebo 80/20)
nám øíká, ¾e 90 procent èasu bìhu programu se stráví v&nbsp;pouhých deseti
procentech kódu, tj.&nbsp;musí se jednat o nìjaké smyèky, u kterých by bylo
dobré skoky predikovat. Existuje více zpùsobù implementace prediktorù skokù, my
si vysvìtlíme prediktory jednobitové a dvoubitové.</p>

<p>Jednoduchý jednobitový prediktor skokù pracuje tak, ¾e si procesor u ka¾dého
skoku v&nbsp;jednom bitu zapamatuje, zda byl skok proveden èi nikoli. Kdy¾ se
v&nbsp;instrukèní pipeline znovu skok objeví (souhlasí jeho adresa), tak se
procesor na základì pøede¹lého bìhu programu rozhodne, které dal¹í instrukce se
pravdìpodobnì budou zpracovávat. Pøi prvním volání skoku má prediktor pouze
padesátiprocentní úspì¹nost, ta se potom zvy¹uje. Napøíklad u smyèky, která by
mìla probìhnout 100&times; (to ov¹em procesor dopøedu neví) se sice pøi prvním
prùchodu prediktor splete (za co¾ je penalizován "vysypáním" pipeline), ov¹em
v&nbsp;dal¹ích 98 prùchodech u¾ správnì odhadne, ¾e se skok provede. Poslední
prùchod je znovu odhadnut ¹patnì, co¾ je ov¹em pochopitelné. Výsledkem je
pomìrnì úspì¹né a pøedev¹ím rychlé provedení v¹ech instrukcí ve smyèce, pøièem¾
je úspì¹nost predikce skvìlých 98 procent (to je ov¹em ideální pøípad).</p>

<p>Dvoubitový prediktor pracuje velmi podobným zpùsobem, ov¹em pamatuje si
nejenom pøedchozí výsledek skoku (proveden, neproveden), ale i minulý stav
predikce. Pro mnoho typù podmínek je výhodnìj¹í, ne¾ jednobitový prediktor,
proto¾e i jeden ¹patný odhad je¹tì nezmìní stav prediktoru. Zpùsob predikce
u dvoubitového prediktoru skokù je mo¾né naznaèit stavovým diagramem:</p>



<p><a name="k05"></a></p>
<h1>5. Záhadné zkratky SISD, SIMD, MISD, MIMD</h1>

<p>Pøi popisu technik vedoucích k&nbsp;urychlení zpracování instrukcí se
nemù¾eme nezmínit o zkratkách <strong>SISD</strong>, <strong>SIMD</strong>,
<strong>MISD</strong> a <strong>MIMD</strong>. Jedná se o zkratky, které
vyjadøují jak míru paralelnosti dané architektury (ve své podstatì nejde jen o
architekturu samotného mikroprocesoru, ale celého poèítaèe, zejména tìch èástí,
které se týkají vlastních výpoètù), tak i zpùsob práce s&nbsp;daty. Struèný
význam tìchto zkratek je uveden v&nbsp;následující tabulce:</p>

<table>
<tr><th>Zkratka</th><th>Anglický význam zkratky</th></tr>
<tr><td>SISD</td><td>Single Instruction, Single Data</td></tr>
<tr><td>SIMD</td><td>Single Instruction, Multiple Data</td></tr>
<tr><td>MISD</td><td>Multiple Instructions, Single Data</td></tr>
<tr><td>MIMD</td><td>Multiple Instructions, Multiple Data</td></tr>
</table>



<p><a name="k06"></a></p>
<h1>6. Architektura SISD</h1>

<p>Ná¹ ukázkový mikroprocesor byl typu <strong>SISD</strong>, neboli <i>Single
Instruction, Single Data</i>. Ka¾dá instrukce pracovala maximálnì se dvìma
operandy; napøíklad u instrukce <strong>ADD</strong> se jednalo o oba sèítance.
Jedná se o tu nejjednodu¹¹í prakticky pou¾itelnou architekturu, která mù¾e být
roz¹íøena o ji¾ popsané zøetìzené zpracování instrukcí a také implementací
vìt¹ího mno¾ství výkonných jednotek. Stále se v¹ak jedná o architekturu, kde
jedna instrukce mù¾e zpracovat velmi omezené mno¾ství dat, které odpovídají
dané operaci a pøípadný paralelismus tedy není øe¹en na úrovni jednotlivých
instrukcí. Jde sice o nejjednodu¹¹í architekturu, která je v¹ak nejobecnìj¹í a
tudí¾ stále pou¾ívaná (nìkdy v&nbsp;kombinaci s&nbsp;následujícím typem).</p>



<p><a name="k07"></a></p>
<h1>7. Architektura SIMD</h1>

<p>Dnes velmi populární je architektura <strong>SIMD</strong>, její¾ koøeny
v¹ak sahají hluboko do minulosti (sedmdesátá léta minulého století). Jedná se o
architekturu, ve které se pomocí jedné instrukce mù¾e zpracovat vìt¹í mno¾ství
dat. Napøíklad u roz¹íøené instrukèní sady <strong>MMX</strong> je mo¾né pomocí
jediné instrukce provést souèet dvou vektorù èíselných hodnot, napøíklad se
mù¾e jednat o osm osmibitových hodnot ulo¾ených v&nbsp;jednom vektoru, ètyøi
¹estnáctibitové hodnoty v&nbsp;jednom vektoru atd. Této vlastnosti se dá
v&nbsp;mnoha pøípadech vyu¾ít pro urychlení bìhu programù, proto¾e nìkteré
algoritmy provádí velké mno¾ství stejných operací s&nbsp;rozsáhlým objemem dat
&ndash; napøíklad se mù¾e jednat o aplikaci konvoluèního filtru na rastrový
obrázek, zpracování zvukového signálu atd. Pøedností <strong>SIMD</strong> je
jak relativnì kompaktní instrukèní sada, tak i paralelní a tím i rychlý bìh
mnoha algoritmù, ov¹em za cenu vìt¹ích nárokù na programátora. Vìt¹inu
<strong>SIMD</strong> konstrukcí není mo¾né zapsat v&nbsp;konvenèním vy¹¹ím
programovacím jazyce, musí se pou¾ít buï hotová makra, ruènì optimalizované
knihovní funkce nebo specializované jazyky typu *Lisp.</p>

<image id="6368" />
<p-center>Pentium MMX zavedlo instrukèní sadu MMX, která je zalo¾ena na SIMD</p-center>



<p><a name="k08"></a></p>
<h1>8. Architektura MISD</h1>

<p>Architektura <strong>MISD</strong> umo¾òuje na jedny data (pøeètená
z&nbsp;pracovního registru nebo operaèní pamìti) aplikovat více operací
zapsaných ve více instrukcích za sebou; jde tedy o zobecnìnou pipeline (ta
ov¹em pracuje na úrovni instrukèních øezù, tedy na ni¾¹í úrovni, ne¾ je tomu u
MISD). Existují pøípady, kdy je vhodné tuto architekturu pou¾ít, je jich v¹ak
ménì, ne¾ u <strong>SIMD</strong>, proto není <strong>MISD</strong> u bì¾ných
(nespecializovaných) mikroprocesorù pøíli¹ roz¹íøena. Zásobníkové procesory je
mo¾né pova¾ovat za flexibilnìji navr¾enou architekturu
<strong>MISD</strong>.</p>



<p><a name="k09"></a></p>
<h1>9. Architektura MIMD</h1>

<p>Nejvìt¹í úroveò paralelismu nabízí architektura <strong>MIMD</strong>.
V&nbsp;procesoru nebo procesorovém poli je paralelnì zpracováváno vìt¹í
mno¾ství dat a to nezávisle na sobì (vìt¹inou asynchronnì). V&nbsp;minulosti se
tato architektura pou¾ívala velmi èasto napøíklad u superpoèítaèù (zde byly
procesory spojeny napøíklad sítí s&nbsp;topologií toroidu, hyperkostky èi
"tlustého" binárního stromu), dnes se této úrovnì paralelismu dosahuje i na
bì¾ných "stolních" procesorech s&nbsp;více jádry (i kdy¾ zde existuje
principiální omezení poètu jader). Problémem je, ¾e opravdu masivní
paralelismus s&nbsp;nìkolika desítkami, stovkami èi tisíci procesorù vy¾aduje i
jiný pøístup k&nbsp;programování a pou¾ití specializovaných jazykù, napøíklad
"paralelního" LISPu s&nbsp;v¹eøíkajícím názvem <strong>*Lisp</strong>.
Pravdìpodobnì nejzajímavìj¹í technologií pou¾ívající MIMD, jsou slavné
<i>Connection Machine</i>, zejména CM-5 vytvoøená z&nbsp;RISCových procesorù
SPARC (z&nbsp;pohledu CM jsou moderní dvoujádrové èi ètyøjádrové mikroprocesory
pouhé hraèky, proto¾e v&nbsp;CM bylo mo¾né souèasnì pou¾ívat a¾ 65536
procesorù :-).</p>

<image id="6369" />
<p-center>Futuristický design Connection Machine 5</p-center>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2008</small></p>
</body>
</html>

