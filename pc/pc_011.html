<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Techniky zvý¹ení výpoèetního výkonu mikroprocesorù</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Techniky zvý¹ení výpoèetního výkonu mikroprocesorù</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o funkci poèítaèù si vysvìtlíme, jakými technikami je mo¾né zvy¹ovat výpoèetní výkon mikroprocesorù. Uká¾eme si napøíklad pou¾ití zøetìzeného zpracování instrukcí, explicitního i paralelního zpracování instrukcí, podporu pro bìh více vláken i mikroprocesory s více jádry.</p>



<h1>Obsah</h1>
<p>
<a href="#k01">1. Techniky zvý¹ení výpoèetního výkonu mikroprocesorù</a><br />
<a href="#k02">2. Roz¹íøení bitové ¹íøky zpracovávaných dat</a><br />
<a href="#k03">3. Zvý¹ení poètu pracovních registrù</a><br />
<a href="#k04">4. Hierarchické uspoøádání pamìti</a><br />
<a href="#k05">5. Fronta instrukcí</a><br />
<a href="#k06">6. Zøetìzené zpracování instrukcí (pipelining)</a><br />
<a href="#k07">7. Explicitní paralelní zpracování instrukcí (VLIW)</a><br />
<a href="#k08">8. Obsah dal¹í èásti seriálu</a><br />
</p>



<p><a name="k01"></a></p>
<h1>1. Techniky zvý¹ení výpoèetního výkonu mikroprocesorù</h1>

<p><i>Motto: number of transistors per square inch doubles about every 18 months<br />(Moore)</i></p>

<p>O tom, ¾e se výpoèetní výkon mikroprocesorù, tj.&nbsp;poèet strojových
instrukcí vykonaných za jednotku èasu, neustále zvìt¹uje, není pochyb. Platí to
jak pro mikroprocesory urèené pro bì¾né desktopy, tak i pro mikroøadièe,
signálové procesory a programovatelné èipy typu FPGA (tìmito zajímavými
souèástkami se také je¹tì budeme zabývat, proto¾e pøedstavují jednu
z&nbsp;mo¾ností tvorby &bdquo;open hardware&ldquo;). Tento prozatím stálý
výkonnostní rùst bez vìt¹ích výkyvù je zpùsoben pomìrnì znaèným mno¾stvím
vlivù. Asi nejvíce patrný je vývoj samotné technologie výroby èipù
s&nbsp;integrovanými obvody, kde se výrobcùm daøí zmen¹ovat ¹íøky spojù mezi
jednotlivými tranzistory, s&nbsp;èím¾ souvisí i zmen¹ování samotných
tranzistorù, sni¾ování napájecího napìtí (to má velký vliv na sní¾enou spotøebu
procesoru a tím i míry vyzaøovaného tepla) a souèasného zvy¹ování taktovací
frekvence. Obecnì toti¾ u unipolárních technologií èipù platí, ¾e vyzáøený
výkon=frekvence&times;napìtí<sup>2</sup>, tj.&nbsp;zmen¹ení napájecího napìtí
vede k&nbsp;radikálnímu sní¾ení vyzaøovaného tepla (dnes si nikdo ani neumí
pøedstavit, jak by &bdquo;topil&ldquo; mikroprocesor taktovaný souèasnými
frekvencemi a napájený pìti volty, co¾ byl pøípad v¹ech mikroprocesorù øady x86
a¾ do pøíchodu prvních Pentií).</p>

<p>Souèasnì se daøí zvìt¹ovat i samotnou plochu èipu na <i>waferu</i>
(destièce, na které se vìt¹inou napaøováním vytvoøí vìt¹í mno¾ství jader
mikroprocesorù a která se posléze rozøe¾e, èím¾ vznikne základ mikroprocesoru,
který je nanesen na nosnou destièku èipu a jsou k&nbsp;nìmu vìt¹inou za studena
&ndash; tlakem &ndash; pøivaøeny zlaté kontakty), co¾ spolu se zmen¹ující se
tlou¹»kou tranzistorù vede k&nbsp;tomu, ¾e jejich poèet v&nbsp;ka¾dé generaci
mikroprocesoru roste. Rùst poètu tranzistorù, taktovacích frekvencí a také
nìkolikaøádové sni¾ování ¹íøky spojù je ostatnì patrný i z&nbsp;následující
tabulky (zamìøené pøedev¹ím na produktovou øadu firmy Intel, ani ne tak kvùli
její oblibì, jako mo¾nosti porovnání víceménì zpìtnì kompatibilních
mikroprocesorù &ndash; výjimku samozøejmì pøedstavují relativnì neúspì¹ná
Itania):</p>

<table>
<tr><th>Mikroprocesor</th><th>Bitù</th><th>Datum</th><th>Tranzistorù</th><th>Frekvence [MHz]</th><th>©íøka spojù [nm]</th></tr>
<tr><td>4004       </td><td>   4</td><td>1971</td><td>        2 250</td><td>   0.1</td><td>10 000</td></tr>
<tr><td>8008       </td><td>   8</td><td>1972</td><td>        3 500</td><td>   0.2</td><td>10 000</td></tr>
<tr><td>8080       </td><td>   8</td><td>1974</td><td>        6 000</td><td>   2.0</td><td> 6 000</td></tr>
<tr><td>8088       </td><td>16/8</td><td>1979</td><td>       29 000</td><td>   8.0</td><td> 3 000</td></tr>
<tr><td>8086       </td><td>  16</td><td>1978</td><td>       29 000</td><td>   8.0</td><td> 3 000</td></tr>
<tr><td>80286      </td><td>  16</td><td>1982</td><td>      134 000</td><td>  12.5</td><td> 1 500</td></tr>
<tr><td>80386      </td><td>  32</td><td>1985</td><td>      275 000</td><td>  20.0</td><td> 1 500</td></tr>
<tr><td>80486      </td><td>  32</td><td>1989</td><td>    1 200 000</td><td>  25.0</td><td> 1 000</td></tr>
<tr><td>Pentium    </td><td>  32</td><td>1993</td><td>    3 100 000</td><td>  66.0</td><td>   800</td></tr>
<tr><td>Pentium    </td><td>  32</td><td>1994</td><td>    3 300 000</td><td>  75.0</td><td>   600</td></tr>
<tr><td>Pentium    </td><td>  32</td><td>1995</td><td>    3 300 000</td><td> 120.0</td><td>   350</td></tr>
<tr><td>Pentium II </td><td>  32</td><td>1997</td><td>    7 500 000</td><td> 233.0</td><td>   350</td></tr>
<tr><td>Pentium II </td><td>  32</td><td>1998</td><td>    7 500 000</td><td> 300.0</td><td>   250</td></tr>
<tr><td>Pentium III</td><td>  32</td><td>1999</td><td>    9 500 000</td><td> 450.0</td><td>   250</td></tr>
<tr><td>Pentium III</td><td>  32</td><td>2000</td><td>   28 000 000</td><td> 533.0</td><td>   180</td></tr>
<tr><td>Pentium 4  </td><td>  32</td><td>2000</td><td>   42 000 000</td><td>1500.0</td><td>   180</td></tr>
<tr><td>Pentium 4  </td><td>  32</td><td>2002</td><td>   55 000 000</td><td>2200.0</td><td>   130</td></tr>
<tr><td>Pentium 4  </td><td>  32</td><td>2004</td><td>  125 000 000</td><td>2800.0</td><td>    90</td></tr>
<tr><td>Pentium 4  </td><td>  32</td><td>2006</td><td>  188 000 000</td><td>3200.0</td><td>    65</td></tr>
<tr><td>Itanium    </td><td>  64</td><td>2001</td><td>   25 000 000</td><td> 733.0</td><td>   180</td></tr>
<tr><td>Itanium 2  </td><td>  64</td><td>2003</td><td>  220 000 000</td><td> 900.0</td><td>   180</td></tr>
<tr><td>Itanium 2  </td><td>  64</td><td>2004</td><td>  592 000 000</td><td>1300.0</td><td>   130</td></tr>
<tr><td>Itanium 2  </td><td>  64</td><td>2006</td><td>1 720 000 000</td><td>1400.0</td><td>    90</td></tr>
<tr><td>Core 2     </td><td>  64</td><td>2006</td><td>  291 000 000</td><td>1860.0</td><td>    65</td></tr>
<tr><td>Core 2     </td><td>  64</td><td>2008</td><td>  800 000 000</td><td>&nbsp;</td><td>    45</td></tr>
</table>

<p>Otázkou zùstává, jakým zpùsobem se nové tranzistory, které lze do jednoho
mikroprocesoru vmìstnat, dají vyu¾ít a jak to ovlivní jeho výpoèetní výkon.</p>



<p><a name="k02"></a></p>
<h1>2. Roz¹íøení bitové ¹íøky zpracovávaných dat</h1>

<p>Pravdìpodobnì nejsnaz¹í metodou zvý¹ení výpoèetního výkonu je roz¹íøení
poètu bitù, které mikroprocesory doká¾í v&nbsp;ka¾dé instrukci zpracovávat. I
tento trend je v&nbsp;tabulce uvedené v&nbsp;pøedchozí kapitole jasnì patrný.
Ètyøbitové mikroprocesory pøestaly být, spolu s&nbsp;krachujícím obchodem se
stolními kalkulátory, zajímavé a velmi rychle se pøe¹lo na mikroprocesory
osmibitové, které byly pou¾ity mj.&nbsp;v&nbsp;prvních herních konzolích a
pøedev¹ím domácích poèítaèích. Dodnes jsou jejich moderní varianty pou¾ívány ve
formì mikroøadièù (mikroprocesorù, které na jednom èipu mají zaintegrovánu i
pamì» ROM a RWM), co¾ je oblast velmi citlivá ke zvy¹ování cen a pøíkonu. Mezi
èasto pou¾ívané mikroøadièe patøí øada Intel 8051 (a jejich klony), Motorola
68HC11 nebo mikroprocesory PIC. ©estnáctibitové mikroprocesory tvoøily
mezistupeò k&nbsp;mikroprocesorùm tøicetidvoubitovým, které jsou (po cca
dvaceti letech) v&nbsp;oblasti desktopu v&nbsp;poslední dobì nahrazovány
mikroprocesory ¹edesátiètyøbitovými.</p>

<image id="6295" />
<p-center>Z&nbsp;dne¹ního pohledu znaènì primitivní struktura prvního
mikroprocesoru na svìtì &ndash; Intel 4004 (v¹imnìte si iniciál Federica
Fagina)</p-center>



<p><a name="k03"></a></p>
<h1>3. Zvý¹ení poètu pracovních registrù</h1>

<p>Dal¹í mo¾ností vyu¾ití &bdquo;nových&ldquo; tranzistorù, které jsou
návrháøùm k&nbsp;dispozici, je zvý¹ení poètu pracovních registrù. I kdy¾ se to
z&nbsp;dne¹ního pohledu mù¾e zdát takøka neuvìøitelné, tak se je¹tì
v&nbsp;mnoha osmibitových mikroprocesorech s&nbsp;pracovními registry ¹etøilo
mj.&nbsp;i z&nbsp;toho dùvodu, ¾e se jejich poèet projevil na výrobní cenì (i
revoluèní cena MOS 6502, která odstartovala boom domácích poèítaèù, se
mj.&nbsp;odvíjela od minimálního poètu pouhých tøí pracovních registrù, druhým
faktorem byla vìt¹í výtì¾nost výroby, ne¾ jaké dosahovala konkurence,
tj.&nbsp;pøedev¹ím firmy Intel a Motorola). Dnes bývá soubor pracovních
registrù pomìrnì rozsáhlý (proto¾e registry zabírají na plo¹e èipu minimální
místo, napøíklad pøi porovnání s&nbsp;moderní ALU èi FPU) a tvoøí tak vlastnì
nejrychlej¹í úroveò pamìti.</p>

<image id="6296" />
<p-center>Struktura osmibitového mikroprocesoru MOS 6502 je ji¾ o poznání
slo¾itìj¹í (barevnì jsou zvýraznìny jednotlivé èásti &ndash; ALU, øadiè,
pracovní registry atd.)</p-center>



<p><a name="k04"></a></p>
<h1>4. Hierarchické uspoøádání pamìti</h1>

<p>Dal¹í metodou, která do jisté míry zasahuje do celé architektury poèítaèù,
je pou¾ití hierarchického uspoøádání pamìtí. Idea je vcelku prostá &ndash;
vzhledem k&nbsp;tomu, ¾e není z&nbsp;cenových aj. dùvodù mo¾né celou operaèní
pamì» vytvoøit z&nbsp;pomocí té nejrychlej¹í dostupné technologie (napøíklad se
jedná o bipolární statické pamìti), je vytvoøena hierarchická struktura, na
jejím¾ vrcholku stojí kapacitnì malá, zato v¹ak velmi rychlá pamì» tvoøená
pracovními registry umístìnými pøímo na mikroprocesoru, která je následovaná
vyrovnávací pamìtí (<i>cache</i>) první úrovnì (<i>Level 1 cache</i>), dnes
takté¾ vìt¹inou umístìná na èipu mikroprocesoru. Dále se v&nbsp;hierarchii
nachází vyrovnávací pamìti druhé úrovnì (<i>Level 2 cache</i>), které jsou
ponìkud pomalej¹í, ale zato mají vìt¹í kapacitu. Pod touto pamìtí je ji¾
vlastní operaèní pamì», je¾ je z&nbsp;hlediska mikroprocesoru velmi pomalá (a
k&nbsp;tomu ne zcela náhodnì pøístupná), ov¹em její kapacita mù¾e u desktopù
dosahovat øádu gigabytù.</p>

<p>Vzhledem k&nbsp;tomu, ¾e mikroprocesory urèené pro desktopy a servery
podporují virtuální pamì», jde hierarchie je¹tì dále, proto¾e se operaèní pamì»
roz¹iøuje o nìkolik øádù pomalej¹í a souèasnì o nìkolik øádù objemnìj¹í pevné
disky. Z&nbsp;hlediska programátora se tato hierarchie vìt¹inou omezuje na
pracovní registry a virtuální pamì» tvoøenou jak operaèní pamìtí, tak i èástí
kapacity pevného disku (èi Flash disku atd.), proto¾e vyrovnávací pamìti jsou
z&nbsp;jeho pohledu transparentní &ndash; jejich absence sice povede
k&nbsp;pomalej¹ímu bìhu programu, ale samotný program nebude zapotøebí
v&nbsp;naprosté vìt¹inì pøípadù mìnit.</p>



<p><a name="k05"></a></p>
<h1>5. Fronta instrukcí</h1>

<p>Vzhledem k&nbsp;tomu, ¾e mikroprocesory jsou obecnì rychlej¹í ne¾ operaèní
pamìti a vyu¾ití pamìti není zcela uniformní (doba trvání instrukcí mìøená
v&nbsp;poètu taktù se mù¾e li¹it), zaèali výrobci do mikroprocesorù vkládat
takzvanou <i>frontu instrukcí</i>. Ta funguje pomìrnì jednoduchým zpùsobem.
Jedná se o skuteènou frontu, do které jsou postupnì vkládány operaèní kódy
instrukcí naèítané z&nbsp;operaèní pamìti. Z&nbsp;druhé strany fronty si
operaèní kódy vybírá øadiè. V&nbsp;pøípadì, ¾e se provádí nìkteré slo¾itìj¹í
instrukce (napøíklad násobení), mohou se mezitím (paralelnì) do fronty
instrukcí naèítat dal¹í operaèní kódy a ve chvíli, kdy se provádí rychlé
operace (souèet dvou registrù, inkrementace, porovnávání, logické operace) se
operaèní kódy mohou velmi rychle èíst z&nbsp;fronty a mikroprocesor nemusí
èekat na relativnì pomalou operaèní pamì». Fronta instrukcí se musí vyprázdnit
v&nbsp;pøípadì, ¾e dojde ke zmìnì bìhu programu, tj.&nbsp;po pøíchodu
pøeru¹ení, provedení instrukce skoku, skoku do podprogramu èi návratu
z&nbsp;podprogramu.</p>

<image id="6297" />
<p-center>Typické umístìní fronty instrukcí</p-center>



<p><a name="k06"></a></p>
<h1>6. Zøetìzené zpracování instrukcí (pipelining)</h1>

<p>Velmi èasto pou¾ívanou &bdquo;urychlovací&ldquo; technologií je <i>zøetìzené
provádìní instrukcí</i> neboli <i>pipelining</i>. Pro vysvìtlení funkce
pipeliningu si nejdøíve pøipomeòme, jakým zpùsobem je na na¹em hypotetickém
mikroprocesoru provádìna nìjaká základní instrukce, napøíklad souèet dvou
pracovních registrù <strong>A</strong> a <strong>B</strong>. Nejprve
mikroprocesor naète z&nbsp;operaèní pamìti operaèní kód instrukce,
tj.&nbsp;známým zpùsobem zakódovanou sekvenci <strong>ADD A,B</strong>.
Operaèní kód je pøenesen do øadièe, který ihned zaène vykonávat v¹echny
potøebné èinnosti. Nejdøíve se pøenese obsah pracovního registru
<strong>A</strong> do vyrovnávacího registru pøed ALU. Toté¾ se provede
s&nbsp;obsahem pracovního registru <strong>B</strong>. Poté øadiè pøiká¾e ALU,
¾e má provést souèet obou vyrovnávacích registrù a následnì (samozøejmì a¾
poté, co ALU operaci vykoná) se výsledek ulo¾í do pracovního registru
<strong>A</strong>. Celá operace trvá nìkolik taktù, proto¾e se minimálnì
provede nìkolik krokù:</p>

<ol>

<li>Naètení instrukce z&nbsp;operaèní pamìti (<strong>fetch</strong>)</li>
<li>Dekódování instrukce v&nbsp;øadièi (<strong>decode</strong>)</li>
<li>Pøenos obsahù pracovních registrù (<strong>memory access</strong>)</li>
<li>Vlastní provedení instrukce (<strong>execute</strong>)</li>
<li>Ulo¾ení výsledku zpìt do pracovního registru (<strong>write back</strong>)</li>

</ol>

<image id="6298" />
<p-center>Naètení a dekódování instrukce (<strong>fetch</strong>, <strong>decode</strong>)</p-center>

<p>Zajímavé pøitom je, ¾e se tyto kroky vìt¹inou provádí v&nbsp;jiné èásti
mikroprocesoru: o naèítání se stará pamì»ový subsystém, dekódování provádí
øadiè, pøenosy jsou realizovány na interní sbìrnici, provedení instrukce je
øe¹eno v&nbsp;ALU a ulo¾ení výsledkù je práce pro interní sbìrnici a jeden
z&nbsp;pracovních registrù. To jinými slovy vlastnì znamená, ¾e v&nbsp;jeden
okam¾ik pracuje pouze velmi malá èást mikroprocesoru a ostatní èásti na ní
èekají.</p>

<image id="6299" />
<p-center>Práce s&nbsp;registry, provedení instrukce a ulo¾ení výsledkù (<strong>memory access</strong>, <strong>execute</strong>, <strong>write back</strong>)</p-center>

<p>My¹lenka <i>pipeliningu</i> spoèívá v&nbsp;tom, ¾e se instrukce zøetìzí
v&nbsp;tom smyslu, ¾e se souèasnì zpracovává vìt¹í mno¾ství instrukcí, ov¹em
ka¾dá instrukce se nachází v&nbsp;jiné fázi zpracování. Napøíklad je mo¾né
provádìt nìjakou aritmetickou operaci na ALU (<strong>execute</strong>) a
pøitom ukládat výsledek pøedchozí operace do pracovního registru a souèasnì ji¾
z&nbsp;operaèní pamìti naèítat operaèní kód instrukce následující. Vy¾aduje to
sice nìjaké úpravy v&nbsp;interní struktuøe mikroprocesoru (napøíklad rozdìlení
interní sbìrnice), ov¹em výsledkem je velké urychlení výpoètù. Zatímco pøi
samostatném zpracování jedné instrukce celý krok trval dejme tomu 8 strojových
cyklù, s&nbsp;plným vyu¾itím pipeliningu je to pouze jeden cyklus (celá
instrukce samozøejmì poøád trvá onìch osm cyklù, ale v&nbsp;jejich prùbìhu se
rozpracuje èi ukonèí sedm dal¹ích instrukcí, tak¾e v&nbsp;dostateènì velkém
èasovém horizontu opravdu se opravdu v&nbsp;ka¾dém taktu zpracuje jedna
instrukce). To je samozøejmì ideální pøípad, proto¾e pøi skocích, pøeru¹ení èi
kolizi registrù se musí u¾ rozpracované instrukce &bdquo;zahodit&ldquo;. Této
pomìrnì záva¾né problematice se budeme vìnovat pøí¹tì.</p>

<p>Pipelining je v&nbsp;rùzné podobì pou¾it prakticky u v¹ech typù
mikroprocesorù. V&nbsp;nìkterých pøípadech se s&nbsp;ním programátor setká u¾
pøi psaní programù v&nbsp;assembleru (napøíklad se jedná o zásobníkové
mikroprocesory Chucka Moorea, které obsahují sério-paralelní sèítaèky), ale
vìt¹inou se jedná o pomìrnì dobøe skrytou vlastnost, která se projeví jen ve
specifických pøípadech, napøíklad pøi zpracování pøeru¹ení nebo pøepínání
procesù. V&nbsp;ka¾dém pøípadì se jedná o jednu z&nbsp;nejlep¹ích metod (pokud
je dobøe implementována), proto¾e urychlení vykonávání programù bývá velké a
souèasnì se pøíli¹ nezvìt¹ují nároky na poèet tranzistorù (jinými slovy &ndash;
implementace pipeliningu výrobce moc nestojí). Je¹tì patrnìj¹í je situace u
specializovaných obvodù, napøíklad grafických èipù, kde mù¾e mít pipeline a¾
nìkolik stovek øezù (krokù).</p>

<p>Vìt¹inou se popisuje klasický pøípad pipeliningu, kdy je zpracování
instrukce rozdìleno do pìti krokù (zhruba to odpovídá krokùm uvedeným vý¹e),
ov¹em v&nbsp;praxi mù¾e být poèet krokù mnohem vìt¹í, co¾ znamená, ¾e jsou
kroky jednodu¹¹í a tím pádem mohou trvat krat¹í dobu (zvy¹uje se taktovací
frekvence). Nìkteré moderní mikroprocesory instrukce rozdìlují na více ne¾ 30
krokù (implementace jednoho kroku, se nazývá <i>øez</i>).</p>



<p><a name="k07"></a></p>
<h1>7. Explicitní paralelní zpracování instrukcí (VLIW)</h1>

<p>Dal¹í metoda, kterou nìkteøí výrobci mikroprocesorù pou¾ili pro urychlení
vykonávání instrukcí, spoèívá v&nbsp;tom, ¾e na mikroprocesoru jsou v¹echny
výkonné jednotky umístìny paralelnì vedle sebe, pøièem¾ mohou vykonávat operace
souèasnì a nezávisle na sobì (za pøedpokladu, ¾e nenastane kolize
v&nbsp;pou¾itých registrech). V&nbsp;praxi to mù¾e vypadat napøíklad tak, ¾e na
mikroprocesoru jsou umístìny dvì jednotky pro provádìní aritmetických a
logických operací (jedná se vlastnì o klasické ALU), jedna násobièka, jedna
dìlièka a nakonec jednotka pro provedení skokù. Jakým zpùsobem se v¹ak tìchto
celkem pìt výkonných jednotek bude ovládat? Klasický princip &bdquo;pøeèíst
instrukci-vykonat instrukci&ldquo; by k&nbsp;¾ádnému urychlení nevedl a
jednotky by zùstávaly nevyu¾ity. Proto je zapotøebí nìjakým zpùsobem docílit
toho, aby byly výkonné jednotky ovládány naráz a aby souèasnì nedocházelo ke
kolizím v&nbsp;pou¾itých registrech (napøíklad ten samý registr nemù¾e být
pou¾it pro ulo¾ení výsledkù dvou paralelnì bì¾ících operací).</p>

<p>Ve snaze o pou¾ití co nejjednodu¹¹ího (a tím i dostateènì rychlého) øadièe
mikroprocesoru, pou¾ili výrobci speciální formát operaèních kódù, který byl
sestaven tak, ¾e v&nbsp;jedné instrukci jsou ulo¾eny operaèní kódy pro v¹echny
výkonné jednotky. Výsledkem je architektura nazvaná <strong>VLIW</strong>,
neboli <i>Very Long Instruction Word</i>. Pro ná¹ hypotetický mikroprocesor
s&nbsp;dvojicí ALU, jednou násobièkou, jednou dìlièkou a jednotkou pro
provedení skokù by celá instrukce mohla vypadat napøíklad následovnì:</p>

<table>
<tr>
<td>operace pro ALU 1</td>
<td>operace pro ALU 2</td>
<td>specifikace násobení</td>
<td>specifikace dìlení</td>
<td>konstanta</td>
<td>kód podmínky</td>
<td>adresa skoku</td>
</tr>
</table>

<p>Zpùsob kódování jednotlivých instrukcí v&nbsp;instrukèním slovu je rùzný.
Pro operace ALU se napøíklad mù¾e tøemi bity specifikovat, která operace se má
pou¾ít (<strong>ADD</strong>, <strong>SUB</strong>, <strong>AND</strong>,
<strong>OR</strong>, <strong>XOR</strong>, <strong>NOT</strong>,
<strong>ROR</strong>, <strong>ROL</strong>), dal¹ími ètyømi bity první registr
vstupující do operace a následujícími ètyømi bity registr druhý. U operací
násobení a dìlení jsou také zadány registry (ètyøi+ètyøi bity) a jedním bitem
je urèeno, zda se má operace vùbec provádìt (tj.&nbsp;jsou dvì mo¾nosti, buï
<strong>MUL</strong>/<strong>DIV</strong> èi <strong>NOP</strong>). Konstanta
v&nbsp;instrukèním slovì je pou¾ita pro naplnìní vybraného pracovního registru.
Kód podmínky pro podmínìné skoky mù¾e být zakódován ve tøech bitech
(<strong>JC</strong>, <strong>JZ</strong>, <strong>JNC</strong>,
<strong>JNZ</strong>, <strong>JMP</strong> &ndash; nepodmínìný skok atd.) a
adresa skoku bývá relativní, ulo¾ená napøíklad na tøináct bitù (rozsah 4kB bývá
dostateèný). Ve výsledku tedy mù¾e instrukèní slovo vypadat takto:</p>

<table>
<tr><th>Bity</th><th>Význam</th></tr>
<tr><td>3</td><td>ALU operace èíslo 1</td></tr>
<tr><td>4</td><td>registr 1 pro ALU operaci</td></tr>
<tr><td>4</td><td>registr 2 pro ALU operaci</td></tr>
<tr><td>3</td><td>ALU operace èíslo 2</td></tr>
<tr><td>4</td><td>registr 1 pro ALU operaci</td></tr>
<tr><td>4</td><td>registr 2 pro ALU operaci</td></tr>
<tr><td>1</td><td>MUL operace èi NOP</td></tr>
<tr><td>4</td><td>registr 1 pro MUL operaci</td></tr>
<tr><td>4</td><td>registr 2 pro MUL operaci</td></tr>
<tr><td>1</td><td>DIV operace èi NOP</td></tr>
<tr><td>4</td><td>registr 1 pro DIV operaci</td></tr>
<tr><td>4</td><td>registr 2 pro DIV operaci</td></tr>
<tr><td>32</td><td>konstanta</td></tr>
<tr><td>3</td><td>specifikace podmínìného èi nepodmínìného skoku</td></tr>
<tr><td>13</td><td>adresa skoku</td></tr>
</table>

<p>Vidíme ¾e oznaèení <i>Very Long Instruction Word</i> je zcela na místì,
proto¾e se jedná o slovo délky 88 bitù, tj.&nbsp;11 bytù. A to jsem je¹tì
vynechal operace FPU, které u nìkterých mikroprocesorù také bývají do
instrukèního slova zahrnuty. Díky tomuto &bdquo;horizontálnímu&ldquo; formátu
instrukcí mù¾e øadiè zùstat velmi jednoduchý a navíc mohou v¹echny jednotky
pracovat zcela paralelnì. Co samotný mikroprocesor ¾ádným zpùsobem neøe¹í (a
vìt¹inou ani nedetekuje) jsou kolize pracovních registrù: ty je zapotøebí
o¹etøit u¾ pøi vytváøení strojového kódu, tj.&nbsp;jde o práci pøekladaèe,
který má na podobné optimalizace (vìt¹inou) dostatek èasu. Pøekladaè samozøejmì
také musí pøeskládat instrukce tak, aby bylo instrukèní slovo co nejvíce
zaplnìné, proto¾e pokud se nepodaøí vedle sebe ulo¾it v¹ech pìt na sobì
nezávislých instrukcí, ztrácí se nejvìt¹í výhoda této architektury.</p>

<p>Pøedností <strong>VLIW</strong> je pomìrnì velká jednoduchost øadièe, který
není o mnoho slo¾itìj¹í, ne¾ øadiè klasických <strong>RISC</strong>ových
mikroprocesorù. Dal¹ího urychlení zpracovávaných instrukcí je mo¾né dosáhnout
zvý¹ením poètu výkonných jednotek (napøíklad 4&times;ALU), ov¹em zdaleka ne
v¹echny programy jsou pro toto urychlení vhodné. Nejvìt¹í nevýhoda architektury
<strong>VLIW</strong> spoèívá v&nbsp;tom, ¾e se ve¹keré optimalizace musí
provádìt v&nbsp;závislosti na konkrétní konfiguraci daného mikroprocesoru. U¾
jen malé zmìny v&nbsp;èasování èi pøidání jedné výkonné jednotky zpùsobí, ¾e se
programy musí znovu pøelo¾it, proto¾e se kompletnì zmìní instrukèní slovo. Tato
architektura také obecnì není vhodná v&nbsp;pøípadech, ¾e se pou¾ívá
interpretovaný kód, proto¾e interprety nemají (na rozdíl od pøekladaèù) tolik
èasu na provádìní zde zcela nutných optimalizací. Tento problém je typický
napøíklad pøi interpretaci a JIT kompilaci bytekódu JVM (tj.&nbsp;vìt¹inou Javy
èi programù napsaných v&nbsp;jiných jazycích pøelo¾ené do bytekódu Javy).</p>

<p>Z&nbsp;tohoto dùvodu se procesory postavené na architektuøe
<strong>VLIW</strong> prosadily zejména v&nbsp;oblasti zpracování signálù a
embedded zaøízeních, které mají výrobci programù stoprocentnì pod kontrolou a
mohou pro nì cílenì vytváøet aplikace. Mnoho signálových procesorù je typu
<strong>VLIW</strong>, pøièem¾ navíc pou¾ívají jednotky FPU èi FXU (<i>Floating
Point Unit</i>, <i>Fixed Point Unit</i>). Bli¾¹í informace o <i>Fixed Point</i>
aritmetice jsem popsal v&nbsp;seriálu <a
href="http://www.root.cz/serialy/fixed-point-arithmetic/">Fixed Point
Aritmetika</a>.</p>



<p><a name="k08"></a></p>
<h1>8. Obsah dal¹í èásti seriálu</h1>

<p>Na relativnì malém prostoru vyhrazeném pro jeden èlánek jsme si samozøejmì
nemohli podrobnì popsat v¹echny metody, které výrobci pou¾ívají
k&nbsp;urychlení práce mikroprocesorù. Na dal¹í technologie a metody se tedy
je¹tì podíváme pøí¹tì. Zejména se budeme zabývat vektorovým zpracováním
instrukcí, mikroprocesory s&nbsp;podporou instrukcí typu SIMD (<i>Single
Instruction, Multiple Data</i>) èi naopak MISD <i>Multiple Instruction, Single
Data</i>(), prediktory skokù, podporou pro bìh více vláken
(<i>multithreading</i>) i podporou pro bìh více samostatných procesù
(<i>multi-core</i>).</p>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2008</small></p>
</body>
</html>

