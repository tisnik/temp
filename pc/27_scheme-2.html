<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Základy programování v jazyku Scheme</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Základy programování v jazyku Scheme</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o historii výpoèetní techniky si popí¹eme naprosté základy tvorby programù v jazyku Scheme. Øekneme si napøíklad s jakými základními datovými typy lze v tomto jazyku pracovat i to, jakým zpùsobem se pou¾ívají takzvané predikáty èi konstruují podmínky.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Základní operace se symboly</a></p>
<p><a href="#k02">2. Èísla, výrazy s&nbsp;èísly, funkce pro práci s&nbsp;èísly</a></p>
<p><a href="#k03">3. Znaky a øetìzce</a></p>
<p><a href="#k04">4. Øetìzce</a></p>
<p><a href="#k05">5. Pravdivostní hodnoty a logické výrazy</a></p>
<p><a href="#k06">6. Predikáty</a></p>
<p><a href="#k07">7. Zápis podmínek</a></p>
<p><a href="#k08">8. Pou¾ití forem and a or pøi zápisu podmínek</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2>1. Základní operace se symboly</h2>

<p>V&nbsp;pøedchozí èásti seriálu o historii výpoèetní techniky jsme se
seznámili s&nbsp;programovacím jazykem <i>Scheme</i>. Øekli jsme si, ¾e se
jedná o jeden ze známých a v&nbsp;nìkterých oblastech IT pomìrnì èasto
pou¾ívaných dialektù jazyka <i>LISP</i>, který se od pùvodního
&bdquo;klasického&ldquo; LISPu v&nbsp;nìkolika ohledech nepatrnì odli¹uje.
Autoøi <i>Scheme</i> (známý Guy L. Steele a Gerald Jay Sussman) vytvoøili jazyk
vhodný mj.&nbsp;i pro výuku programování (i kdy¾ to nebylo jejich primárním
cílem, pùvodnì se jednalo o jazyk urèený pro jejich vlastní výzkumné úèely),
co¾ znamená, ¾e programy napsané ve <i>Scheme</i> bývají èitelnìj¹í ne¾ obdobné
programy napsané v&nbsp;pùvodním LISPu (který se mj.&nbsp;vyznaèoval i
dynamickým rozsahem viditelnosti promìnných). Dnes si uká¾eme základní
programové konstrukce, které lze ve <i>Scheme</i> vytváøet. Základní syntaxí i
zpùsobem vyhodnocování funkcí se nebudeme detailnì zabývat, proto¾e se
v&nbsp;tomto ohledu <i>Scheme</i> pøíli¹ neli¹í od <i>LISPu</i> (nìkteré
rozdíly si samozøejmì uká¾eme).</p>

<p>Programovací jazyk <i>Scheme</i> je, podobnì jako <i>LISP</i>, zamìøen na
práci se symboly, tak¾e nás pravdìpodobnì nepøekvapí, ¾e jedním ze základních
typù, se kterými je mo¾né ve <i>Scheme</i> pracovat, jsou právì symboly.
Symboly je mo¾né pou¾ít hned nìkolika zpùsoby &ndash; jako hodnoty výètového
typu, jako klíèe asociativních polí (he¹ovacích tabulek) i pro jména
promìnných. Symbol je v&nbsp;programu reprezentován svým jménem, které je
v&nbsp;celém programu unikátní (existuje právì jednou). Z&nbsp;tohoto dùvodu je
mo¾né symboly porovnávat pomocí efektivní operace <strong>(eq)</strong> namísto
<strong>equal?</strong> (i tuto operaci, pøesnìji øeèeno predikát, lze
samozøejmì pou¾ít). Pokud se symbol zapisuje do programu, je nutné pøed jeho
jméno pøidat znak ' (<i>quote</i>), proto¾e v&nbsp;opaèném pøípadì by
interpretr jazyka <i>Scheme</i> jméno symbolu chápal jako jméno promìnné a
sna¾il by se tuto promìnnou vyhodnotit na její hodnotu. Pøi práci se symboly je
mo¾né vyu¾ít nìkolika funkcí, z&nbsp;nich¾ ty nejèastìji pou¾ívané jsou vypsány
v&nbsp;následující tabulce:</p>

<table>
<tr><th>Funkce</th><th>Význam</th></tr>
<tr><td>symbol?</td><td>predikát, který vrací #t nebo #f podle toho, zda je jeho parametrem symbol</td></tr>
<tr><td>symbol-&gt;string</td><td>pøevod symbolu na øetìzec</td></tr>
<tr><td>string-&gt;symbol</td><td>pøevod øetìzce na symbol (mù¾e i vytvoøit nový symbol, pokud je¹tì neexistuje)</td></tr>
<tr><td>eq?</td><td>nejefektivnìj¹í zpùsob porovnání dvou symbolù na rovnost</td></tr>
<tr><td>eqv?</td><td>dal¹í zpùsob porovnání dvou symbolù na rovnost</td></tr>
<tr><td>equal?</td><td>dal¹í zpùsob porovnání dvou symbolù na rovnost</td></tr>
</table>

<p>Následuje nìkolik pøíkladù práce se symboly. Na tomto místì mo¾ná stojí za
pøipomenutí, ¾e <strong>#t</strong> znaèí ve <i>Scheme</i> pravdivostní hodnotu
<i>true</i> a <strong>#f</strong> naopak pravdivostní hodnotu <i>false</i>:</p>

<pre>
; vytvoøení nového symbolu
'abc
abc

; jméno symbolu mù¾e obsahovat i nìkteré nealfanumerické znaky
'x^y
x^y

'ì¹èø¾ýáíé
ì¹èø¾ýáíé

; pou¾ití predikátu symbol?
(symbol? 'hello)
#t
(symbol? "hello")
#f
(symbol? 42)  
#f

; rùzné zpùsoby porovnání symbolù
(eq? 'aaa 'aaa)
#t

(eq? 'aaa 'bbb)
#f

(equal? 'aaa 'aaa)
#t

; porovnání symbolù a promìnných nesoucích symbol
; pov¹imnìte si, ¾e v tomto pøípadì není rozdíl
; mezi chováním eq, eqv a equal (u jiných typù dat
; tomu v¹ak tak být nemusí)
(define X 'aaa)
(define Y 'aaa)
(eq? X Y)
#t
(eq? X 'aaa)
#t
(eqv? X Y)
#t
(eqv? X 'aaa)
#t
(equal? X Y)
#t
(equal? X 'aaa)
#t

; pøevod symbolu na øetìzec
(symbol-&gt;string 'aaa)
"aaa"

; pøevod øetìzce na symbol (v tomto pøípadì se vytvoøí nový symbol)
(string-&gt;symbol "hello")
hello
</pre>



<p><a name="k02"></a></p>
<h2>2. Èísla, výrazy s&nbsp;èísly, funkce pro práci s&nbsp;èísly</h2>

<p>Dal¹ím datovým typem, s&nbsp;ním¾ se mù¾eme setkat prakticky v&nbsp;ka¾dém
programu, je numerický datový typ. Programovací jazyk <i>Scheme</i> dìlí
numerické hodnoty (èísla) do nìkolika kategorií, pøièem¾ s&nbsp;ka¾dou
kategorií internì pracuje ponìkud odli¹ným zpùsobem. Jedná se o celá èísla
(<i>integer</i>), racionální èísla (<i>rationals</i>) reprezentovatelná zlomkem
s&nbsp;celoèíselným èitatelem i jmenovatelem, reálná èísla (<i>real</i>) a
koneènì èísla komplexní (<i>complex</i>). Reálná èísla se navíc rozli¹ují podle
toho, zda je mù¾e interpretr jazyka <i>Scheme</i> reprezentovat pøesnì nebo jen
s&nbsp;urèitou pøesností. Zajímavý je zpùsob ulo¾ení numerických hodnot
v&nbsp;operaèní pamìti poèítaèe. Interpretry jazyka <i>Scheme</i> napøíklad
celá èísla, jejich¾ hodnota le¾í v&nbsp;rozsahu bì¾ných ètyøbajtových nebo
osmibajtových celých èísel zpracovávaných pøímo mikroprocesorem (v&nbsp;céèku
by se jednalo o datové typy <i>int</i> a <i>long</i>, popø.&nbsp;<i>long
long</i>), uchovávají i zpracovávají stejným zpùsobem, jaký známe napøíklad
z&nbsp;céèka, Pascalu èi Javy, tj.&nbsp;ka¾dá numerická hodnota je ulo¾ena ve
ètyøech èi osmi bajtech pamìti, podle toho, jaké typy jsou podporovány CPU a
jaké lze ulo¾it do pracovních registrù procesoru..</p>

<p>Pro vìt¹í celoèíselné hodnoty se pou¾ívá vícebajtová aritmetika, co¾
mj.&nbsp;znamená, ¾e rozsah reprezentovaných hodnot je omezen pouze rychlostí
zpracování tìchto hodnot a kapacitou operaèní pamìti (viz pøíklad výpoètu
faktoriálu uvedený v&nbsp;pøedchozí èásti tohoto seriálu). <i>Scheme</i> tedy,
jako vysokoúrovòový programovací jazyk, programátory odstiòuje od konkrétního
zpùsobu ulo¾ení a zpracování numerických hodnot poèítaèem a na druhou stranu,
pokud je to mo¾né, pou¾ívá efektivní zpùsob ulo¾ení dat i rychlý zpùsob výpoètu
aritmetických výrazù. U¾iteèná je i existence èísel racionálních, pomocí nich¾
lze obejít nìkteré nedostatky reálných èísel, pøesnìji øeèeno zpùsob ulo¾ení
podmno¾iny reálných èísel v&nbsp;datových typech <i>float</i> èi <i>double</i>.
Napøíklad je známým faktem, ¾e reálnou hodnotu 0.1 není mo¾né pøesnì ulo¾it ani
v&nbsp;promìnné typu <i>float</i> ani <i>double</i>. Naproti tomu reprezentace
racionálních èísel v&nbsp;programovacím jazyku <i>Scheme</i> je zcela pøesná a
navíc i pøehledná &ndash; postaèuje napsat <strong>1/10</strong>. Pøi
numerických výpoètech je mo¾né pou¾ít velké mno¾ství rùzných funkcí,
napøíklad:</p>

<table>
<tr><th>Funkce</th><th>Význam</th></tr>
<tr><td>number?  </td><td>predikát testující, zda je pøedaný parametr èíslem (libovolné kategorie)</td></tr>
<tr><td>integer? </td><td>predikát testující, zda numerická hodnota le¾í v kategorii celé èíslo</td></tr>
<tr><td>real?    </td><td>predikát testující, zda numerická hodnota le¾í v kategorii celé èíslo, racionální èíslo èi èíslo reálné (celá èísla samozøejmì tvoøí podmno¾inu èísel reálných)</td></tr>
<tr><td>odd?     </td><td>test na liché èíslo</td></tr>
<tr><td>even?    </td><td>test na èíslo sudé</td></tr>
<tr><td>quotient </td><td>celoèíselné dìlení</td></tr>
<tr><td>remainder</td><td>zbytek po celoèíselném dìlení</td></tr>
<tr><td>gcd      </td><td>nejvìt¹í spoleèný dìlitel</td></tr>
<tr><td>log      </td><td>výpoèet pøirozeného logaritmu</td></tr>
<tr><td>sin      </td><td>výpoèet sinu úhlu zapsaného v&nbsp;radiánech (+ dal¹í goniometrické funkce)</td></tr>
<tr><td>expt     </td><td>výpoèet x^y</td></tr>
</table>

<p>Následuje nìkolik pøíkladù práce s&nbsp;èísly:</p>

<pre>
; ve Scheme lze pou¾ívat rùzné základy èíselné soustavy:

; binární reprezentace
#b101010
42

; reprezentace v osmièkové soustavì
#o52
42

; pou¾ití hexadecimální soustavy
#x2a
42

; zápis reálného èísla, které nelze reprezentovat pøesnì
#i1.4142135623731
1.4142135623731

; výpoèty s reálnými èísly, které nelze reprezentovat pøesnì
(- #i1000.0 #i999.9)
#i0.10000000000002274
; výsledkem by mìla být hodnota 0.1

; podíl dvou celých èísel, výsledkem je èíslo racionální
(/ 20 100)
1/5

(/ 10 7)
10/7

; práce se zlomky i s jejich zjednodu¹ováním
(+ 1/3 1/4)
7/12

(/ 1/3 1/4)
4/3

; pou¾ití predikátù
(number? #i0.999)
#t

(number? 42)
#t

(number? (/ 123 456))
#t

(number? "hello")
#f

(number? 'symbol)
#f

; slo¾itìj¹í výpoèty se zapisují a vyhodnocují
; podobnì jako v LISPu
(gcd (- 20 10) (+ 2 3))
5

; práce s velkými celými èísly (big integers)
(expt 123 456)

99250068772098856700831462057469632637295940819886900519816
29888138286710474939907792112866142614463805542423693627187
24928003527416499021181438196726015699981001207904967595176
36465445895625741609866209900500198407153244604778968016963
02805031026141761591446872991824068548787861764597693906346
43579861657117309763994785076492286863414669671679101266533
42134942744851463899927487092486610977146112763567101672645
95313219648143933987301708814041466127119850033325571309614
23351514146306516830655187840812036784877030028020820912366
03519026256880624499681781387227574035484831271515683123742
14909556926046360965597770093884458061193124649516620869554
03136981400116380273225662526897808381363518287953142721621
11222231170901715612355701347552371530013693855379834865667
06001464330245910042978365396691378300229078428345562828335
54705299329560514844771293338811599302127586876027950885792
30431661696010232187390436601614145603241902386663442520160
735566561
</pre>



<p><a name="k03"></a></p>
<h2>3. Znaky</h2>

<p>Dal¹ími dvìma základními datovými typy pou¾ívanými (samozøejmì nejenom)
v&nbsp;programovacím jazyce <i>Scheme</i> jsou znaky a øetìzce. Nejprve si
øeknìme, jakým zpùsobem se pracuje s&nbsp;jednotlivými znaky. Ty jsou internì
reprezentovány jako 21 bitové hodnoty, v&nbsp;nich¾ jsou ulo¾eny kódy znakù
odpovídající standardu Unicode (zda je onìch 21 bitù ulo¾eno ve ètyøech bajtech
èi jiným zpùsobem, je ji¾ ponecháno na konkrétní implementaci <i>Scheme</i>,
zde si pouze pov¹imnìte rozdílu v&nbsp;chápání datového typu &bdquo;char&ldquo;
ve <i>Scheme</i> a napøíklad v&nbsp;<i>Javì</i>, kde se ve skuteènosti nejedná
o plnohodnotné znaky schopné reprezentovat v¹echny národní abecedy). Pro
pøevody mezi znaky a jejich kódy se pou¾ívá dvojice funkcí nazvaných
<strong>char-&gt;integer</strong> a <strong>integer-&gt;char</strong>. Tisk
znaku lze provést pomocí funkce <strong>display</strong>. Tisknutelný znak je
ve zdrojovém kódu programù i ve výstupech interpretru reprezentován trojicí
znakù <strong>#\X</strong>, kde <strong>X</strong> je grafická podoba
tisknutelného znaku, napøíklad:</p>

<pre>
#\A
#\A

#\a
#\a

#\(
#\(

#\#
#\#

#\\
#\\
</pre>

<p>Pro znaky, které nemají tisknutelnou podobu, nebo které by se slo¾itì
zapisovaly do zdrojového kódu (národní abecedy) se pou¾ívá formát
<strong>#\uCAFE</strong>, kde <strong>CAFE</strong> je hexadecimálnì zapsaný
kód znaku definovaný v&nbsp;Unicode. Nìkteré znaky mohou být v&nbsp;programech
reprezentovány svým symbolickým jménem; typickým pøíkladem je
<strong>#\space</strong>. Následující pøíklady pou¾ívají vý¹e popsané pøevodní
funkce <strong>char-&gt;integer</strong>, <strong>integer-&gt;char</strong> i
funkci <strong>display</strong>:</p>

<pre>
(display #\A)
A

(integer-&gt;char 65)
#\A

(char-&gt;integer #\A)
65

(char-&gt;integer #\space)
32

(integer-&gt;char 32)
#\space

(integer-&gt;char 27)
#\esc
</pre>



<p><a name="k04"></a></p>
<h2>4. Øetìzce</h2>

<p>Programovací jazyk <i>Scheme</i> samozøejmì podporuje i práci
s&nbsp;øetìzci, které se zapisují, jak je tomu ostatnì zvykem v&nbsp;mnoha
dal¹ích programovacích jazycích, do uvozovek. Na rozdíl od ji¾ popsaných
symbolù, které jsou v&nbsp;programu jedineèné, mohou být øetìzce se stejným
obsahem (tj.&nbsp;se stejnou sekvencí znakù) ulo¾eny v&nbsp;pamìti vícekrát,
tak¾e je jejich porovnávání ponìkud slo¾itìj¹í, ne¾ v&nbsp;pøípadì symbolù.
Ostatnì si to mù¾eme ukázat na jednoduchém pøíkladu, v&nbsp;nìm¾ je nejprve
vytvoøena dvojice promìnných obsahujících obsahovì shodné øetìzce, ov¹em ka¾dý
z&nbsp;øetìzcù mù¾e le¾et v&nbsp;jiné oblasti pamìti, co¾ znamená, ¾e porovnání
jejich referencí (adres) pomocí funkce (predikátu) <strong>eq?</strong> vrátí
pravdivostní hodnotu #f, zatímco porovnání skuteèného obsahu øetìzcù funkcí
<strong>equal?</strong> naopak vrátí oèekávanou hodnotu #t.</p>

<pre>
(define A "hello")
(define B "hello")

(eq? A B)
#f

(equal? A B)
#t
</pre>

<p>Pro lep¹í èitelnost programù, zejména v&nbsp;pøípadì, ¾e si programátor je
jistý, ¾e pøedané hodnoty jsou skuteènì typu øetìzec, je výhodnìj¹í porovnávat
øetìzce pomocí následující dvojice funkcí:</p>

<table>
<tr><th>Funkce</th><th>Význam</th></tr>
<tr><td>string=?</td><td>porovnání dvou øetìzcù s&nbsp;výsledkem #t nebo #f</td></tr>
<tr><td>string-ci=?</td><td>porovnání výsledkù s&nbsp;ignorováním velikosti písmen</td></tr>
</table>

<p>Vý¹e uvedené funkce si mù¾eme ihned vyzkou¹et:</p>

<pre>
(define A "hello")
(define B "hello")
(define C "Hello")

(string=? A B)
#t

(string=? B C)
#f

(string-ci=? B C)
#t
</pre>

<p>Dal¹í skupina funkcí doká¾e zjistit, zda nìjaký znak spadá do urèité
kategorie znakù, tj.&nbsp;zda se napøíklad jedná o písmeno, èíslo nebo nìjaký
&bdquo;bílý&ldquo; znak:</p>

<pre>
(char-alphabetic? #\A)
#t

(char-numeric? #\0)
#t

(char-whitespace? #\newline)
#t
</pre>



<p><a name="k05"></a></p>
<h2>5. Pravdivostní hodnoty a logické výrazy</h2>

<p>S&nbsp;pravdivostními hodnotami jsme se ji¾ nìkolikrát setkali
v&nbsp;demonstraèních pøíkladech uvedených v&nbsp;pøedchozích kapitolách. Proto
si pouze pøipomeòme, ¾e <i>Scheme</i> se v&nbsp;tomto ohledu ponìkud odli¹uje
od <i>LISPu</i> v&nbsp;nìm¾ je prakticky v¹e kromì prázdného seznamu pova¾ováno
za hodnotu &bdquo;pravda&ldquo; a prázdný seznam (ekvivalentní se symbolem
<strong>nil</strong>) je pova¾ován za &bdquo;nepravdu&ldquo;.
V&nbsp;programovacím jazyku <i>Scheme</i> se logická hodnota
&bdquo;pravda&ldquo; zapisuje pomocí (jedineèného) symbolu <strong>#t</strong>
a &bdquo;nepravda&ldquo; pomocí symbolu <strong>#f.</strong> V¹echny hodnoty
kromì <strong>#f</strong> (ale vèetnì prázdného seznamu) se pøi vyèíslování
pravdivostních výrazù, podmínek atd. pova¾ují takté¾ za pravdu, ostatnì podobnì
je tomu i v&nbsp;dal¹ích vysokoúrovòových programovacích jazycích. Pøi zápisu
logických výrazù je mo¾né pou¾ít speciální formy <strong>and</strong>,
<strong>or</strong> a <strong>not</strong>, jak je ostatnì ukázáno
v&nbsp;následujících pøíkladech:</P>

<pre>
; symboly #t a #f se vyhodnocují samy na sebe,
; proto se pøed nì nemusí psát apostrof
#t
#t

#f
#f

; pou¾ití funkce not, na ní¾ si mù¾eme demonstrovat,
; jak se v¹echny ostatní hodnoty kromì #f automaticky
; pøevádí na #t (pravdu)
(not #t) 
#f

(nor #f)
#t

(not 'A)
#f

(not (not 'A))
#t

(not 42)
#f

(not (not 42))
#t

; jak se bude chovat "negace prázdného seznamu"?
(not '())
#f
(not (not '()))
#t
</pre>



<p><a name="k06"></a></p>
<h2>6. Predikáty</h2>

<p>V&nbsp;pøedchozím textu jsme se nìkolikrát setkali se slovem
&bdquo;predikát&ldquo;. Na predikátech není vùbec nic tajemného, nebo» se jedná
o pojmenování funkcí vracejících pravdivostní hodnotu <strong>#t</strong> nebo
<strong>#f</strong> v&nbsp;závislosti na tom, zda byla èi naopak nebyla splnìna
nìjaká podmínka. Predikáty lze ve <i>Scheme</i> poznat velice snadno, nebo» se
jedná o funkce konèící znakem otazník (jak jste si ji¾ mohli v¹imnout, mù¾e se
ve jménech funkcí vyskytovat velké mno¾ství nealfanumerických znakù, co¾ je
mj.&nbsp;umo¾nìno i díky tomu, ¾e <i>Scheme</i> pou¾ívá prefixovou syntaxi se
striktním oddìlením jednotlivých jazykových prvkù buï nìjakým bílým znakem nebo
levou èi pravou kulatou závorkou). Mezi standardní predikáty patøí napøíklad
funkce zji¹»ující, zda je pøedaný parametr urèitého typu &ndash; viz tabulka
uvedená pod tímto odstavcem. Pøitom platí dùle¾itá podmínka, ¾e ka¾dý objekt
v&nbsp;jazyce <i>Scheme</i> patøí pouze do jedné z&nbsp;následujících
kategorií:</p>

<table>
<tr><th>Predikát</th><th>Význam</th></tr>
<tr><td>boolean?</td><td>parametr je typu pravdivostní hodnota</td></tr>
<tr><td>pair?   </td><td>parametr je typu (teèka)dvojice</td></tr>
<tr><td>symbol? </td><td>parametr je symbol</td></tr>
<tr><td>number? </td><td>parametr je èíslo</td></tr>
<tr><td>char?   </td><td>parametr je znak</td></tr>
<tr><td>string? </td><td>parametr je øetìzec</td></tr>
<tr><td>vector? </td><td>parametr je vektor (viz dal¹í èást seriálu)</td></tr>
<tr><td>port?   </td><td>parametr je port (viz dal¹í èást seriálu)</td></tr>
<tr><td>procedure?</td><td>parametr je procedura</td></tr>
</table>

<p>Pøíklady pou¾ití vý¹e uvedených predikátù:</p>

<pre>
(boolean? #t)
#t

(boolean? #f)
#t

(boolean? 42)
#f

(number? 42)
#t

(number? 42)
#t

(string? 42)
#f

(string? "42")
#t

; V èlánku o programovacím jazyku LISP jsme si mj. uvedli
; jakým zpùsobem jsou v operaèní pamìti reprezentovány seznamy.
; Ze znalosti ulo¾ení seznamù lze odvodit, proè se predikát
; pair? chová tak, jak je naznaèeno v tìchto pøíkladech:
(pair? '())
#f

(pair? '(a))
#t

(pair? '(a b))
#t

(pair? '(a.b))
#t

(pair? '(a b c))
#t
</pre>

<p>Kromì vý¹e uvedených predikátù jsou ve <i>Scheme</i> dostupné i mnohé
predikáty dal¹í, napøíklad:</p>

<table>
<tr><th>Predikát</th><th>Význam</th></tr>
<tr><td>list?</td><td>parametr je seznam</td></tr>
<tr><td>null?</td><td>parametr je prázdný seznam</td></tr>
<tr><td>symbol?</td><td>predikát, který vrací #t nebo #f podle toho, zda je jeho parametrem symbol</td></tr>
<tr><td>eq?</td><td>porovnání referencí obou parametrù (nejpøísnìj¹í podmínka ekvivalence)</td></tr>
<tr><td>eqv?</td><td>vrací #t pokud lze oba parametry pova¾ovat za shodný objekt</td></tr>
<tr><td>equal?</td><td>porovnání dvou objektù s&nbsp;rekurzivním vyhodnocováním pokud objekt (napøíklad seznam) obsahuje dal¹í podobjekty</td></tr>
<tr><td>odd?     </td><td>test na liché èíslo</td></tr>
<tr><td>even?    </td><td>test na èíslo sudé</td></tr>
<tr><td>zero?    </td><td>test na èíslo nulové</td></tr>
<tr><td>positive?</td><td>test na èíslo kladné</td></tr>
<tr><td>negative?</td><td>test na èíslo záporné</td></tr>
<tr><td>complex? </td><td>test zda je parametr èíslem spadajícím do dané kategorie</td></tr>
<tr><td>real?    </td><td>dtto</td></tr>
<tr><td>rational?</td><td>dtto</td></tr>
<tr><td>integer? </td><td>dtto</td></tr>
<tr><td>exact?   </td><td>test zda je reálné èíslo reprezentovatelné pøesnì</td></tr>
<tr><td>inexact? </td><td>opak pøedchozího predikátu</td></tr>
</table>



<p><a name="k07"></a></p>
<h2>7. Zápis podmínek</h2>

<p>Pøi programování prakticky jakéhokoli slo¾itìj¹ího programu se nevyhneme
nutnosti zápisu podmínìných blokù kódu (v&nbsp;bloku se mù¾e napøíklad
vyskytovat volání nìjaké funkce atd.). V&nbsp;programovacím jazyku
<i>Scheme</i> je mo¾né podmínìné pøíkazy zapisovat nìkolika zpùsoby,
z&nbsp;nich¾ nejpou¾ívanìj¹í je konstrukce se speciální formou
<strong>if</strong> a <strong>cond</strong>. Oba typy konstrukcí byly pøevzaty
z&nbsp;pùvodního <i>LISPu</i> a posléze u nich¾ do¹lo k&nbsp;nìkolika úpravám.
Nejprve si na pøíkladech uka¾me pou¾ití formy <strong>if</strong>, která se
pøíli¹ neli¹í od pøíkazu typu <strong>if</strong> v&nbsp;dal¹ích programovacích
jazycích (samozøejmì a¾ na nutnost pou¾ívat kulaté závorky):</p>

<pre>
(define x -42)

; pou¾ijeme pouze jednu vìtev speciální formy if
; která se provede v pøípadì, ¾e se podmínka vyhodnotí na #t
(if (number? x) (display "parametr je typu cislo"))
parametr je typu cislo

; pou¾ijeme obì vìtve speciální formy if
(if (positive? x) (display "kladna hodnota") (display "zaporna hodnota"))
zaporna hodnota

; ponìkud èitelnìj¹í zápis pøedchozí podmínky
(if (positive? x)                ; podmínka
    (display "kladna hodnota")   ; vìtev "then"
    (display "zaporna hodnota")  ; vìtev "else"
)
zaporna hodnota

; co se stane kdy¾ není zavolána první vìtev formy if
; a druhá vìtev neexistuje?
(define x 'symbol)
(if (number? x) (display "parametr je typu cislo"))
; nic se nevrátilo
</pre>

<p>Forma <strong>cond</strong> (zkrácenina od slova &bdquo;condition&ldquo;) se
sice zdánlivì podobá pøíkazu <strong>switch</strong> z&nbsp;céèka èi Javy,
ov¹em je zde jeden významný rozdíl &ndash; <strong>cond</strong> vrací, jako
mnoho dal¹ích speciálních forem i funkcí (vèetnì dal¹ích typù podmínek),
hodnotu, tak¾e ji lze pou¾ít ve výrazu. V&nbsp;následujícím pøíkladu se vrátí
jeden ze tøí øetìzcù v&nbsp;závislosti na tom, jaká èíselná hodnota je
formì <strong>cond</strong> pøedána:</p>

<pre>
(define x -42)

(cond
    ((negative? x) "zaporne cislo")
    ((positive? x) "kladne cislo")
    (else "nula")                   ; znáte "default" v Javì/céèku?
)
"zaporne cislo"

(define x 0)
(cond
    ((negative? x) "zaporne cislo")
    ((positive? x) "kladne cislo")
    (else "nula")
)
"nula
</pre>



<p><a name="k08"></a></p>
<h2>8. Pou¾ití forem and a or pøi zápisu podmínek</h2>

<p>V&nbsp;nìkterých pøípadech mù¾e být výhodnìj¹í namísto speciální formy
<strong>if</strong> pou¾ít formy <strong>and</strong> èi <strong>or</strong>,
tj.&nbsp;logický souèin a logický souèet, proto¾e druhý (èi jakýkoli dal¹í)
parametr tìchto speciálních forem je vyhodnocován pouze v&nbsp;tom pøípadì,
pokud NENÍ z&nbsp;vyhodnoceného prvního parametru zøejmý výsledek výrazu. Jedná
se o takzvané zkrácené vyhodnocování logických výrazù, které pomìrnì èasto
pou¾ívají napøíklad programátoøi v&nbsp;jazyce <i>Perl</i> (jedná se o jeden
z&nbsp;idiomù tohoto programovacího jazyka):</p>

<pre>
(define x 0)

; ponìkud nepøíjemné je to, ¾e and a or mohou vrátit
; pravdivostní hodnotu - výsledek vyhodnocení prvního parametru
(and (negative? x) (display "sem vubec nedojdu"))
#f

; první parametr se vyhodnotí na #t, tak¾e se
; musí vyhodnotit i parametr druhý
(and (zero? x) (display "a sem naopak dojdu"))
a sem naopak dojdu

; forma or se chová podobnì, akorát vyhodnocuje druhý
; parametr tehdy, kdy¾ je první parametr #f
(or (negative? x) (display "sem dojdu"))
sem dojdu

(or (zero? x) (display "a sem zase ne"))
#t
</pre>

<p>Výhoda pou¾ití speciálních forem <strong>and</strong> a <strong>or</strong>
spoèívá v&nbsp;tom, ¾e je mo¾né tvoøit øetìzce pøíkazù, které jsou provádìny
pouze tehdy, pokud se v¹echny pøedchozí parametry vyhodnotily na
<strong>#t</strong> (v&nbsp;pøípadì speciální formy <strong>and</strong>) nebo
naopak na <strong>#f</strong> (pokud je pou¾ita forma <strong>or</strong>).
Interpretr programovacího jazyka <i>Scheme</i> toti¾ zaruèuje, ¾e parametry
budou vyhodnocovány zleva doprava a díky zkrácenému vyhodnocování se zavolají
jen ty (nejlevìj¹í) parametry, které jsou nutné pro urèení výsledné hodnoty
formy <strong>and</strong> èi <strong>or</strong> (díky prefixové notaci mohou
obì formy akceptovat libovolný poèet parametrù):</p>

<pre>
; POZOR - následující pøíklady jsou znaènì umìlé, pro plné vyu¾ití
;         speciálních forem and a or je¹tì neznáme v¹echny prostøedky
;         programovacího jazyka Scheme

; øetìzec vypsaný funkcí display a návratová hodnota formy and
(and #t (display "tady jsem") #f (display "a tady uz ne"))
tady jsem#f 

; vyhodnotí se jen první parametr, ostatní se ignorují
(and #f (display "tady jsem") #f (display "a tady uz ne"))
#f

; vyhodnotí se v¹echny parametry
(and #t (display "nekolik ") (display "zretezenych ") (display "volani."))
nekolik zretezenych volani
</pre>



<p><a name="k09"></a></p>
<h2>9. Odkazy na Internetu</h2>

<ol>

<li>(welcome '(schemers . org))<br />
<a href="http://www.schemers.org/">http://www.schemers.org/</a>
</li>

<li>Revised<sup>5</sup> Report on the Algorithmic Language Scheme<br />
<a href="http://www.schemers.org/Documents/Standards/R5RS/">http://www.schemers.org/Documents/Standards/R5RS/</a>
</li>

<li>The Revised<sup>6</sup> Report on the Algorithmic Language Scheme<br />
<a href="http://www.r6rs.org/">http://www.r6rs.org/</a>
</li>

<li>Scheme<br />
<a href="http://groups.csail.mit.edu/mac/projects/scheme/">http://groups.csail.mit.edu/mac/projects/scheme/</a>
</li>

<li>The Kawa language framework<br />
<a href="http://www.gnu.org/software/kawa/">http://www.gnu.org/software/kawa/</a>
</li>

<li>Scheme 48<br />
<a href="http://s48.org/">http://s48.org/</a>
</li>

<li>Introductory textbooks for Schemers<br />
<a href="http://www.schemers.org/Documents/#intro-texts">http://www.schemers.org/Documents/#intro-texts</a>
</li>

<li>Scheme (programming language)<br />
<a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)">http://en.wikipedia.org/wiki/Scheme_(programming_language)</a>
</li>

<li>Scheme<br />
<a href="http://cs.wikipedia.org/wiki/Scheme">http://cs.wikipedia.org/wiki/Scheme</a>
</li>

<li>Scheme-faq<br />
<a href="http://community.schemewiki.org/?scheme-faq">http://community.schemewiki.org/?scheme-faq</a>
</li>

<li>Scheme implementations<br />
<a href="http://community.schemewiki.org/?scheme-faq-standards#implementations">http://community.schemewiki.org/?scheme-faq-standards#implementations</a>
</li>

<li>Successful Scheme<br />
<a href="http://www.itworld.com/swol-1013-regex">http://www.itworld.com/swol-1013-regex</a>
</li>

<li>Guy L. Steele, Jr.<br />
<a href="http://en.wikipedia.org/wiki/Guy_L._Steele">http://en.wikipedia.org/wiki/Guy_L._Steele</a>
</li>

<li>Gerald Jay Sussman<br />
<a href="http://en.wikipedia.org/wiki/Gerald_Jay_Sussman">http://en.wikipedia.org/wiki/Gerald_Jay_Sussman</a>
</li>

<li>PLT Scheme<br />
<a href="http://www.plt-scheme.org/">http://www.plt-scheme.org/</a>
</li>

<li>Quick: An Introduction to PLT Scheme with Pictures<br />
<a href="http://docs.plt-scheme.org/quick/">http://docs.plt-scheme.org/quick/</a>
</li>

<li>PLT Scheme<br />
<a href="http://en.wikipedia.org/wiki/Plt_scheme">http://en.wikipedia.org/wiki/Plt_scheme</a>
</li>

<li>PLT Scheme Guide<br />
<a href="http://docs.plt-scheme.org/guide/">http://docs.plt-scheme.org/guide/</a>
</li>

<li>The DrScheme Project: An Overview<br />
<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.9543">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.9543</a>
</li>

<li>DrScheme<br />
<a href="http://en.wikipedia.org/wiki/DrScheme">http://en.wikipedia.org/wiki/DrScheme</a>
</li>

<li>How to Design Programs<br />
<a href="http://www.htdp.org/">http://www.htdp.org/</a>
</li>

<li>An Introduction to Scheme<br />
<a href="http://www.acm.org/crossroads/xrds1-2/scheme.html">http://www.acm.org/crossroads/xrds1-2/scheme.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2010</small></p>
</body>
</html>

