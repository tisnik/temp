<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Instrukèní sada mikroprocesorù ARM</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Instrukèní sada mikroprocesorù ARM</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o architekturách poèítaèù se ji¾ potøetí budeme zabývat popisem mikroprocesorù s architekturou ARM. Øekneme si dal¹í informace o jejich instrukèní sadì, a to jak té pùvodní RISCové, tak i instrukèní sady Thumb, jen¾ byla pozdìji roz¹íøena takovým zpùsobem, aby bylo mo¾né pou¾ívat instrukce o variabilní ¹íøce 16 a 32 bitù.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Instrukèní sada v&nbsp;re¾imu ARM</a></p>
<p><a href="#k02">2. Instrukce podmínìného i nepodmínìného skoku</a></p>
<p><a href="#k03">3. Výpoèet konstanty ulo¾ené do instrukèního slova skoku</a></p>
<p><a href="#k04">4. Skok do podprogramu a návrat z&nbsp;podprogramu</a></p>
<p><a href="#k05">5. Aritmetické a logické instrukce</a></p>
<p><a href="#k06">6. Aritmetické a logické instrukce podrobnìji</a></p>
<p><a href="#k07">7. Problematika naètení 32bitové konstanty do registrù</a></p>
<p><a href="#k08">8. Instrukèní sada Thumb</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Instrukèní sada v&nbsp;re¾imu ARM</h2>

<p>V&nbsp;pøedchozí èásti <a
href="http://www.root.cz/serialy/co-se-deje-v-pocitaci/">seriálu o
architekturách poèítaèù</a> jsme si øekli základní informace o mikroprocesorech
ARM z&nbsp;pohledu programátora. Zamìøili jsme se pøitom pøedev¹ím na situaci,
kdy mikroprocesor pracuje v&nbsp;re¾imu, v&nbsp;nìm¾ naèítá a zpracovává
pùvodní RISCové instrukce s&nbsp;pevnou ¹íøkou 32 bitù. Víme ji¾, ¾e
v&nbsp;tomto re¾imu mají v¹echny instrukce v&nbsp;nejvy¹¹ích ètyøech bitech
zakódovánu podmínku urèující, zda se má tato instrukce vykonat èi nikoli. Díky
existenci tìchto ètyø bitù bylo mo¾né eliminovat nìkteré podmínìné skoky,
jejich¾ vykonání je (stále) problematické, a to prakticky na v¹ech typech
mikroprocesorù vybavených instrukèní pipeline. Dále bylo díky pou¾ití instrukcí
pevné ¹íøky 32 bitù umo¾nìno, aby nìkteré typy instrukcí obsahovaly i bitové
pole vyu¾ívané <i>barrel shifterem</i>, jen¾ je zapojen pøed
aritmeticko-logickou jednotku takovým zpùsobem, aby bylo mo¾né provést bitový
posun èi rotaci druhého operandu vstupujícího do ALU. Díky tomu neobsahuje
pùvodní instrukèní sada ARM ¾ádné specializované instrukce pro bitový posun èi
rotaci (viz té¾ <a href="#k05">pátou kapitolu</a>).</p>

<p>Pøipomeòme si je¹tì, jak vypadá formát bitových polí vìt¹iny instrukcí
v&nbsp;re¾imu ARM. Nìkteré instrukce mají odli¹ný formát; napøíklad se jedná o
instrukce pro práci s&nbsp;koprocesory èi o instrukci pro vyvolání programového
pøeru¹ení (<i>software interrupt</i>):</p>

<pre>
Instrukce load a store, aritmetické operace atd.:
31     27           15                  0
+------+--------------------------------+
| cond | opkód | Rn | Rd |  operand 2   |
+------+--------------------------------+
&nbsp;
Instrukce pou¾ívající násobièku:
31     27           15                  0
+------+--------------------------------+
| cond | opkód | Rn | Rd | Rs | op.| Rm |
+------+--------------------------------+
&nbsp;
Instrukce load a store s offsetem:
31     27           15                  0
+------+--------------------------------+
| cond | opkód | Rn | Rd |  offset      |
+------+--------------------------------+
&nbsp;
Instrukce LDM a STM:
31     27           15                  0
+------+--------------------------------+
| cond | opkód | Rn |  bitové pole reg. |
+------+--------------------------------+
&nbsp;
Instrukce skoku:
31     27    23                         0
+------+--------------------------------+
| cond |opkód|       offset skoku       |
+------+--------------------------------+
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Instrukce podmínìného i nepodmínìného skoku</h2>

<p>Podobnì jako u dal¹ích instrukèních sad (<i>ISA</i>), najdeme i
v&nbsp;instrukèním souboru mikroprocesorù <i>ARM</i> nìkolik instrukcí skoku.
Tyto instrukce lze (ponìkud zjednodu¹enì øeèeno) pova¾ovat za instrukce, které
do registru <i>PC/R15</i> vlo¾í novou konstantu, popø.&nbsp;navíc ulo¾í pùvodní
obsah registru <i>PC/14</i> do registru <i>LR/R14</i> (v&nbsp;tomto pøípadì je
v¹ak situace komplikovanìj¹í, proto¾e obsah registru PC se ji¾ kvùli posunu
instrukce v&nbsp;pipeline zvý¹il o hodnotu 8; podrobnosti si øekneme
v&nbsp;dal¹ím textu). Základní instrukcí skoku je instrukce pojmenovaná
jednodu¹e <strong>B</strong> od slova <i>branch</i>. 32bitové slovo této
instrukce je rozdìleno na tøi èásti. V&nbsp;nejvy¹¹ích ètyøech bitech se
nachází kód podmínky, co¾ v&nbsp;dùsledku znamená, ¾e jediná instrukce
<strong>B</strong> mù¾e nahradit v¹echny formy podmínìných skokù (pøesnìji
øeèeno ètrnáct typù podmínìných skokù a jeden skok nepodmínìný). Za tìmito
ètyømi bity následuje takté¾ ètyøbitový operaèní kód <strong>1010</strong> a ve
zbylých 24 bitech je pak ulo¾ena konstanta, z&nbsp;ní¾ se vypoèítá offset
skoku:</p>

<pre>
31     27     23                         0
+------+------+--------------------------+
| cond | 1010 |       offset skoku       |
+------+------+--------------------------+
</pre>

<p>Vzhledem k&nbsp;tomu, ¾e v¹echny instrukce jsou v&nbsp;operaèní pamìti
zarovnány na adresu dìlitelnou ètyømi, je pøed provedením skoku 24bitová
konstanta obsa¾ená v&nbsp;instrukci posunuta o dva bity doleva. Výsledkem je
26bitová konstanta (mající dva nejni¾¹í bity nulové), která je pøi provádìní
skoku pøiètena k&nbsp;aktuální hodnotì registru <i>PC</i>. Jednodu¹e lze
spoèítat, ¾e díky pou¾ití 26bitové konstanty lze provést podmínìný èi
nepodmínìný skok v&nbsp;rozsahu +-32 MB. Dùle¾ité je, ¾e se pøi pøekladu
programu z&nbsp;assembleru musí pøi výpoètu offsetu odeèíst od aktuální hodnoty
registru <i>PC</i> hodnota osm, a to z&nbsp;toho dùvodu, ¾e se skok provádí a¾
ve fázi <i>execute</i>, tj.&nbsp;ve chvíli, kdy se ji¾ v&nbsp;instrukèní
pipeline nachází dal¹í dvì instrukce: jedna ve fázi <i>decode</i> (ta byla
pøeètena z&nbsp;adresy <i>pùvodní PC+4</i>) a druhá teprve ve fázi <i>fetch</i>
a registr <i>PC</i> ji¾ obsahuje adresu této nejpozdìji naètené instrukce
(<i>pùvodní PC+8</i>). Pozdìj¹í varianty mikroprocesorù ARM sice ji¾ mají
pipeline s&nbsp;jiným poètem øezù, ov¹em toto chování zùstalo kvùli zpìtné
kompatibilitì zachováno.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Výpoèet konstanty ulo¾ené do instrukèního slova skoku</h2>

<p>Nyní si mù¾eme zkusit provést jednoduchý výpoèet skuteèného offsetu
ulo¾eného do 32bitového slova obsahujícího instrukci skoku. Pøedpokládejme
následující program napsaný v&nbsp;assembleru, kde se na adrese 0x0004 nachází
skok na adresu 0x0010 (ve skuteènosti by v¹echny adresy mìly být 32bitové, zde
si v¹ak pro pøehlednost dovolím vynechat poèáteèní nuly). Program by mohl
vypadat následovnì:</p>

<pre>
0x0004       b cil
0x0008       libovolná instrukce
0x000c       libovolná instrukce
0x0010 cil:  libovolná instrukce
</pre>

<p>24bitová konstanta, která se má ulo¾it do instrukèního kódu, se vypoèítá
takto:</p>

<pre>
constant = (cil - PC) / 4     (dìlíme ètyømi kvùli tomu, ¾e spodní dva bity=00)
cil = 0x0010
PC = 0x004 + 8 = 0x0000c      (zmìna PC kvùli naètení dal¹ích dvou instrukcí do pipeline)
constant = (0x0010-0x000c) / 4 = 4/4 = 1
</pre>

<p>32bitové slovo skoku tedy bude slo¾eno ze tøí bitových polí:</p>

<table>
<tr><th>Bity</th><th>Obsah (bin)</th><th>Význam</th></tr>
<tr><td>31-28</td><td>1110</td><td>podmínkový kód <i>AL=always</i> (viz té¾ pøedchozí díl seriálu)</td></tr>
<tr><td>27-24</td><td>1010</td><td>kód instrukce skoku</td></tr>
<tr><td>23-00</td><td>0..01</td><td>konstanta, z ní¾ se vypoèítá offset</td></tr>
</table>

<p>Dohromady tedy získáme hexadecimální hodnotu instrukce: <strong>0xea000001</strong>.</p>

<p><ins>Poznámka: provedení skoku znamená vyprázdnìní instrukèní pipeline, co¾
na pùvodní architektuøe <i>ARM</i> s&nbsp;tøíøezovou pipeline znamená zdr¾ení o
dva takty, proto¾e instrukce umístìná v&nbsp;cíli skoku musí projít v¹emi tøemi
fázemi: <i>fetch, decode, execute</i></ins></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Skok do podprogramu a návrat z&nbsp;podprogramu</h2>

<p>Dal¹í dùle¾itou instrukcí mikroprocesorù ARM je instrukce slou¾ící pro skok
do podprogramu. Zatímco na mnoha jiných architekturách mikroprocesorù se ukládá
návratová adresa do zásobníku, na mikroprocesorech ARM je pro ulo¾ení návratové
hodnoty pou¾it pracovní registr <i>R14</i> nazývaný z&nbsp;tohoto dùvodu takté¾
<i>link register</i>. Pro skok do podprogramu se pou¾ívá instrukce
<strong>BL</strong>, neboli <i>branch and link</i>. Pøi provádìní této
instrukce provede mikroprocesor ve skuteènosti dvì operace: vypoèítá adresu
skoku stejným zpùsobem, jako tomu bylo u instrukce <strong>B</strong>
(<i>branch</i>) a ulo¾í tuto adresu do registru <i>R15/PC</i>. Souèasnì v¹ak
takté¾ vlo¾í adresu <i>aktuální PC-4</i> do registru <i>R14/LR</i>, proto¾e
právì hodnota <i>aktuální PC-4</i> je adresou instrukce le¾ící tìsnì ZA
instrukcí skoku (nesmíme zapomenout na to, ¾e se pøi provedení skoku ve
skuteènosti ji¾ obsah registru <i>PC</i> staèil dvakrát zvý¹it o hodnotu 4).
Formát instrukce <strong>BL</strong> se a¾ na odli¹ný opkód neli¹í od instrukce
<strong>B</strong>:</p>

<pre>
31     27     23                         0
+------+------+--------------------------+
| cond | 1011 |       offset skoku       |
+------+------+--------------------------+
</pre>

<p>Jak se v¹ak provede návrat z&nbsp;podprogramu? Zajímavé je, ¾e ve
skuteènosti ¾ádná speciální instrukce typu <strong>RET</strong> nebo
<strong>RETURN</strong> na mikroprocesorech ARM neexistuje. V¹e, co musí
programátor udìlat, je obnovit obsah registru <i>R15/PC</i> z&nbsp;registru
<i>R14</i>, a to prostým pøesunem dat:</p>

<pre>
MOV PC, LR
</pre>

<p>Jak pøi skoku do podprogramu, tak i pøi výskoku z&nbsp;nìho (obecnì pøi
zmìnì <i>PC</i>) dojde k&nbsp;vyprázdnìní instrukèní pipeline a tedy pozdr¾ení
vykonávání následující instrukce.</p>

<p>U mikroprocesorù ARM podporujících instrukèní sadu Thumb, popøípadì i
technologii Jazelle (bajtkód JVM) existují kromì vý¹e zmínìné dvojice skokových
instrukcí i instrukce dal¹í, které doká¾ou na základì hodnoty adresy pøepnout
instrukèní sady (adresa je ulo¾ena v&nbsp;pracovním registru a testuje se jeho
nejni¾¹í bit). Pro pøehlednost jsou v¹echny skokové instrukce vypsány
v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>B  </td><td>prostý skok</td></tr>
<tr><td>2</td><td>BL </td><td>skok + ulo¾ení návratové hodnoty do link registru</td></tr>
<tr><td>3</td><td>BX </td><td>skok + pøepnutí do re¾imu Thumb èi zpìt</td></tr>
<tr><td>4</td><td>BLX</td><td>kombinace instrukcí BL+BX</td></tr>
<tr><td>5</td><td>BXJ</td><td>skok + pøepnutí do re¾imu Jazelle</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. Aritmetické a logické instrukce</h2>

<p>Velkou skupinu instrukcí v&nbsp;instrukèním souboru mikroprocesorù
<i>ARM</i> pøedstavují aritmetické a logické instrukce. Vìt¹ina tìchto
instrukcí obsahuje v&nbsp;instrukèním slovì bitové pole pro tøi operandy:
cílový registr, zdrojový registr (první operand) a druhý operand. Zatímco
prvním operandem je v¾dy pracovní registr, druhým operandem mù¾e být buï jeden
z&nbsp;pracovních registrù, nebo té¾ osmibitová konstanta. Druhý operand je
navíc pøed vstupem do aritmeticko-logické jednotky zpracován v&nbsp;<i>barrel
shifteru</i>, který mù¾e provést buï bitovou rotaci nebo bitový posun. Navíc je
mo¾né poèet míst, o nì¾ se rotace èi posun provede, urèit buï pìtibitovou
konstantou nebo obsahem dal¹ího pracovního registru. Obecný formát
aritmetických a logických instrukcí je následující:</p>

<pre>
31     27           15                  0
+------+--------------------------------+
| cond | opkód | Rn | Rd |  operand 2   |
+------+--------------------------------+
</pre>

<p>Flexibilita aritmetických a logických instrukcí v¹ak jde je¹tì dále, proto¾e
u ka¾dé instrukce lze pomocí nejvy¹¹ích ètyø bitù zvolit, za jakých podmínek se
instrukce provede (to ji¾ známe z&nbsp;pøedchozího textu). Navíc vìt¹ina tìchto
instrukcí je¹tì obsahuje <i>S-bit</i> urèující, zda má instrukce nastavit
pøíznaky ALU (N, V, Z, C) na základì výsledku operace. Jediné instrukce, u
nich¾ je tento bit nastaven stále, jsou instrukce provádìjící porovnání bez
ulo¾ení výsledku operace. Jak podmínka urèující provedení/neprovedení
instrukce, tak i bit S a samozøejmì takté¾ specifikace rotace/bitového posunu,
se zapisuje do jediné instrukce, tak¾e napøíklad instrukce pro souèet mù¾e mít
mnoho formátù a ve skuteènosti nemusí provádìt pouhý souèet, ale napøíklad i
souèin:</p>

<pre>
ADD    r0, r1, r2         r0:=r1+r2  (bì¾ný souèet bez nastavení pøíznakù)
ADDEQ  r0, r1, r2         if (Z==1) r0:=r1+r2
ADDS   r0, r1, r2         r0:=r1+r2 a nastav pøíznaky N, V, Z, C
ADDEQS r0, r1, r2         jako ADDEQ + nastavení pøíznakù
ADD    r0, r1, r1, LSL#2  r0:=r1*5
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Aritmetické a logické instrukce podrobnìji</h2>

<p>Mezi základní aritmetické instrukce patøí samozøejmì instrukce souètu a
rozdílu. U instrukcí rozdílu je zajímavé, ¾e existují ve dvou variantách podle
toho, zda se odeèítá první operand od druhého nebo naopak. Motivace je zøejmá
&ndash; pro oba operandy existují odli¹ná pravidla:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>ADD</td><td>operand1+operand2</td></tr>
<tr><td>2</td><td>ADC</td><td>operand1+operand2+carry</td></tr>
<tr><td>3</td><td>SUB</td><td>operand1-operand2</td></tr>
<tr><td>4</td><td>SBC</td><td>operand1-operand2+carry-1</td></tr>
<tr><td>5</td><td>RSB</td><td>operand2-operand1</td></tr>
<tr><td>6</td><td>RSC</td><td>operand2-operand1+carry-1</td></tr>
</table>

<p>Dal¹í skupinou instrukcí jsou instrukce provádìjící nìjakou aritmetickou èi
logickou operaci. Ov¹em výsledek této operace se nikam neulo¾í, pouze se
nastaví pøíznakové bity (navíc se tyto bity nastaví v¾dy, není zde mo¾nost
volby bitu <i>S</i>):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>CMP</td><td>operand1-operand2</td></tr>
<tr><td>2</td><td>CMN</td><td>operand1+operand2 (compare negative)</td></tr>
<tr><td>3</td><td>TST</td><td>operand1 and operand2</td></tr>
<tr><td>4</td><td>TEQ</td><td>operand1 xor operand2</td></tr>
</table>

<p>Nesmíme samozøejmì zapomenout ani na logické operace provádìné bit po
bitu:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>AND</td><td>operand1 and operand2</td></tr>
<tr><td>2</td><td>ORR</td><td>operand1 or operand2</td></tr>
<tr><td>3</td><td>EOR</td><td>operand1 xor operand2</td></tr>
<tr><td>4</td><td>BIC</td><td>operand1 and not operand2</td></tr>
</table>

<p>Na závìr této kapitoly si je¹tì uvedeme seznam operací provádìných <i>barrel
shifterem</i> se druhým operandem vstupujícím do aritmeticko-logické jednotky.
Nejedná se o samostatné instrukce, ale o modifikátory zapisované za vlastní ALU
instrukci (viz pøíklad uvedený v&nbsp;¹esté kapitole):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>ASR</td><td>aritmetický posun doprava (kopie nejvy¹¹ího bitu)</td></tr>
<tr><td>2</td><td>LSL</td><td>logický posun doleva (zprava se nasouvá nula)</td></tr>
<tr><td>3</td><td>LSR</td><td>logický posun doprava (zleva se nasouvá nula)</td></tr>
<tr><td>4</td><td>ROR</td><td>rotace doprava, nejni¾¹í bit se kopíruje do C</td></tr>
<tr><td>5</td><td>RRX</td><td>rotace doprava pøes C (rotuje tedy 33 bitù)</td></tr>
</table>

<p>Tro¹ku stranou stojí instrukce vyu¾ívající násobièku (tyto instrukce mají i
jiný formát). Instrukcí tohoto typu existuje vìt¹í mno¾ství a zále¾í na
konkrétním typu jádra, které z&nbsp;instrukcí jsou podporovány:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>MUL</td><td>násobení 32&times;32 bitù : 32bitù</td></tr>
<tr><td>2</td><td>MLA</td><td>násobení + souèet</td></tr>
<tr><td>3</td><td>UMULL</td><td>násobení 32&times;32 bitù : 64bitù unsigned</td></tr>
<tr><td>4</td><td>UMLAL</td><td>násobení + souèet</td></tr>
<tr><td>5</td><td>SMULL</td><td>násobení 32&times;32 bitù : 64bitù signed</td></tr>
<tr><td>6</td><td>SMLAL</td><td>násobení + souèet</td></tr>
</table>

<p>Navíc je¹tì existují instrukce <strong>SMULxx</strong> pro násobení
16bitových slov atd.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Problematika naètení 32bitové konstanty do registrù</h2>

<p>Ji¾ nìkolikrát jsme se zmínili o tom, ¾e kvùli konstantní ¹íøce v¹ech
instrukcí mù¾e být problematické ulo¾ení konstanty do nìkterého pracovního
registru. Problém je to logický a vlastnì shodný pro v¹echny
&bdquo;klasické&ldquo; RISCové mikroprocesory: ¹íøka pracovních registrù je 32
bitù a souèasnì je ¹íøka instrukcí takté¾ 32 bitù, tudí¾ není mo¾né, aby se
v&nbsp;instrukci vedle operaèního kódu nacházela i 32 bitová konstanta. Tvùrci
dal¹ích RISCových mikroprocesorù se s&nbsp;touto problematikou sna¾ili
vypoøádat rùzným zpùsobem, napøíklad zavedli speciální instrukci pro naplnìní
horních ¹estnácti bitù registru, zatímco pro naplnìní spodních ¹estnácti bitù
bylo mo¾né pou¾ít napøíklad instrukci <strong>ADD</strong> s&nbsp;konstantou a
nulovým registrem <i>R0</i> (zhruba takovýmto zpùsobem je tato problematika
øe¹ena na mikroprocesorech <i>MIPS</i>). U mikroprocesorù ARM se zdá, ¾e jeho
konstruktéøi nechtìli &bdquo;obìtovat&ldquo; dal¹í tranzistory na podobné typy
instrukcí, tak¾e se pro naètení konstanty pou¾ívá dvojice instrukcí se stejným
formátem, jako mají ostatní aritmetické a logické instrukce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>MOV</td><td>naètení osmibitové konstanty 0..255</td></tr>
<tr><td>2</td><td>MVN</td><td>naètení osmibitové konstanty s&nbsp;negací -1..-256</td></tr>
</table>

<p>To je samozøejmì pro mnoho úèelù zcela nedostateèné, ov¹em ve skuteènosti je
mo¾né tuto konstantu pomocí <i>barrel shifteru</i> posunout o sudý poèet míst
0, 2, 4, .. 30, tak¾e se ve skuteènosti celkový poèet konstant zvy¹uje na
hodnotu 8192 z&nbsp;celkového mno¾ství kombinací 2<sup>32</sup>. Aby
programátoøi mohli relativnì snadno naèíst <strong>libovolnou</strong>
konstantu do zvoleného registru, nabízí vìt¹ina assemblerù pro mikroprocesory
<i>ARM</i> pseudoinstrukci <strong>LDR</strong> ve tvaru:</p>

<pre>
LDR Rx, =konstanta
</pre>

<p>Podle hodnoty pou¾ité konstanty se tato instrukce buï pøevede na instrukci
<strong>MOV</strong>, alternativnì <strong>MVN</strong>, nebo na instrukci
<strong>LDR</strong> naèítající konstantu ulo¾enou nìkde v&nbsp;programovém
kódu (napøíklad za tìlem subrutiny, kde lze vyhradit prostor pomocí direktivy
LTORG). Tato konstanta je potom adresována relativnì k&nbsp;hodnotì registru
<i>PC</i>, pouze je nutné dát pozor na to, ¾e offset pro relativní adresování
má pouze dvanáct bitù, tak¾e tato konstanta nemù¾e být ulo¾ena pøíli¹
&bdquo;daleko&ldquo; (na to ostatnì upozorní assembler).</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Instrukèní sada Thumb</h2>

<p>Ji¾ <a
href="http://www.root.cz/clanky/mikroprocesory-s-architekturou-arm/">v&nbsp;pøedminulé
èásti</a> tohoto seriálu jsme si øekli, ¾e moderní verze mikroprocesorù ARM
kromì pùvodní instrukèní sady podporují i instrukèní sadu nazvanou
<i>Thumb</i>. Tato instrukèní sada byla zavedena v&nbsp;jádru <i>ARMv4T</i> a
posléze byla roz¹íøena na <i>Thumb2</i> v&nbsp;jádru <i>ARMv6T2</i>.
V&nbsp;pøípadì <i>Thumb</i> se jedná o instrukèní sadu obsahující podmno¾inu
instrukcí vybranou na základì analýzy strojových programù generovaných
pøekladaèi jazykù C a C++. Dále se v&nbsp;této instrukèní sadì ji¾ neobjevují
bity urèené pro podmínìné provádìní instrukcí, co¾ znamená, ¾e je nutné se
vrátit k&nbsp;pou¾ití podmínìných skokù. Ostatnì i spolukonstruktérka procesorù
ARM <i>Sophie Wilson</i> se sama vyjádøila v&nbsp;tom smyslu, ¾e podmínkové
kódy mìly v&nbsp;minulosti svùj velký význam a splnily svoji roli, ov¹em
v&nbsp;embedded systémech a takté¾ na strojích s&nbsp;velmi rychlými CPU a
pomalými DRAM se ji¾ jejich význam ponìkud sní¾il a dùle¾itìj¹ím faktorem se
stává hustota kódu.</p>

<p>Obecnì je mo¾né øíci, ¾e se instrukce <i>Thumb</i> relativnì jednoduchým
zpùsobem transformují na pùvodní instrukce ARM, ov¹em zpìtnì to neplatí,
tj.&nbsp;existují takové instrukce ARM, které nelze pøevést na jedinou
instrukci <i>Thumb</i> (to je v¹ak logické, v¾dy» z&nbsp;pùvodních
2<sup>32</sup> kombinací se v&nbsp;<i>Thumb</i> pou¾ívá jen 2<sup>16</sup>
kombinací). Na druhou stranu se v¹ak délka <i>v¹ech</i> instrukcí mohla zkrátit
na ¹estnáct bitù, co¾ dovoluje dosa¾ení vìt¹í &bdquo;hustoty&ldquo; kódu.</p>

<p>Programátorùm, kteøí mají znalosti instrukèní sady jiných typù
mikroprocesorù, se bude instrukèní sada <i>Thumb</i> zdát blízká, proto¾e se
namísto tøíadresových instrukcí s&nbsp;podmínkovými kódy, S-bitem a pøípadnou
rotací:</p>

<pre>
ADDEQ  r0, r1, r1, LSL#2
</pre>

<p>setkají s&nbsp;instrukcemi jednodu¹¹ími, tj.&nbsp;napøíklad
s&nbsp;&bdquo;bì¾ným&ldquo; souètem <strong>ADD</strong>, nepodmínìným skokem
<strong>B</strong> (s&nbsp;dvanáctibitovým offsetem), podmínìným skokem
<strong>BEQ</strong> (jen s&nbsp;devítibitovým offsetem) èi se samostatnou
instrukcí logického posunu <strong>LSL</strong>. Navíc se kvùli u¾¹ímu
instrukènímu slovu muselo zavést vìt¹í mno¾ství formátù bitových polí, tak¾e
zatímco v&nbsp;pøípadì pùvodní instrukèní sady pou¾ívala vìt¹ina instrukcí
jeden z&nbsp;pìti formátù, je u instrukèní sady <i>Thumb</i> pou¾ito celkem
devatenáct rùzných formátù, co¾ v¹ak naprostou vìt¹inu programátorù nemusí
trápit (pokud se tedy nezabývají studiem vygenerovaných binárních souborù).</p>

<p>Jak je tomu s&nbsp;proklamovanou vìt¹í hustotou kódu v&nbsp;reálných
aplikacích si øekneme v&nbsp;navazující èásti tohoto seriálu.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Introduction to ARM thumb<br />
<a href="http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb">http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb</a>
</li>

<li>ARM, Thumb, and ThumbEE instruction sets<br />
<a href="http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm">http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm</a>
</li>

<li>An Introduction to ARM Assembly Language<br />
<a href="http://dev.emcelettronica.com/introduction-to-arm-assembly-language">http://dev.emcelettronica.com/introduction-to-arm-assembly-language</a>
</li>

<li>Processors - ARM<br />
<a href="http://www.arm.com/products/processors/index.php">http://www.arm.com/products/processors/index.php</a>
</li>

<li>The ARM Instruction Set<br />
<a href="http://simplemachines.it/doc/arm_inst.pdf">http://simplemachines.it/doc/arm_inst.pdf</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ARM_architecture">http://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>BBC BASIC<br />
<a href="http://www.bbcbasic.co.uk/bbcbasic.html">http://www.bbcbasic.co.uk/bbcbasic.html</a>
</li>

<li>BBC BASIC<br />
<a href="http://mdfs.net/Software/BBCBasic/">http://mdfs.net/Software/BBCBasic/</a>
</li>

<li>BBC BASIC (Z80) for the ZX Spectrum<br />
<a href="http://mdfs.net/Software/BBCBasic/Spectrum/">http://mdfs.net/Software/BBCBasic/Spectrum/</a>
</li>

<li>BBC BASIC (Wikipedia CZ)<br />
<a href="http://en.wikipedia.org/wiki/BBC_BASIC">http://en.wikipedia.org/wiki/BBC_BASIC</a>
</li>

<li>MIPS-3D(r) ASE<br />
<a href="http://www.mips.com/products/architectures/mips-3d-ase/">http://www.mips.com/products/architectures/mips-3d-ase/</a>
</li>

<li>An introduction to SPARC's SIMD offerings<br />
<a href="http://mikeburrell.wordpress.com/2007/12/14/an-introduction-to-sparcs-simd-offerings/">http://mikeburrell.wordpress.com/2007/12/14/an-introduction-to-sparcs-simd-offerings/</a>
</li>

<li>MIPS64<sup>TM</sup> Architecture for Programmers Volume IV-c: The MIPS-3D<sup>TM</sup> Application-Specific Extension to the MIPS64<sup>TM</sup><br />
<a href="http://www.weblearn.hs-bremen.de/risse/RST/docs/MIPS/MD00099-2B-MIPS3D64-AFP-01.11.pdf">http://www.weblearn.hs-bremen.de/risse/RST/docs/MIPS/MD00099-2B-MIPS3D64-AFP-01.11.pdf</a>
</li>

<li>Visual Instruction Set<br />
<a href="http://www.enotes.com/topic/Visual_Instruction_Set">http://www.enotes.com/topic/Visual_Instruction_Set</a>
</li>

<li>NEON<br />
<a href="http://www.arm.com/products/processors/technologies/neon.php">http://www.arm.com/products/processors/technologies/neon.php</a>
</li>

<li>Architecture and Implementation of the ARM Cortex-A8 Microprocessor<br />
<a href="http://www.design-reuse.com/articles/11580/architecture-and-implementation-of-the-arm-cortex-a8-microprocessor.html">http://www.design-reuse.com/articles/11580/architecture-and-implementation-of-the-arm-cortex-a8-microprocessor.html</a>
</li>

<li>Multimedia Acceleration eXtensions (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Multimedia_Acceleration_eXtensions">http://en.wikipedia.org/wiki/Multimedia_Acceleration_eXtensions</a>
</li>

<li>AltiVec (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AltiVec">http://en.wikipedia.org/wiki/AltiVec</a>
</li>

<li>Visual Instruction Set (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Visual_Instruction_Set">http://en.wikipedia.org/wiki/Visual_Instruction_Set</a>
</li>

<li>MAJC (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/MAJC">http://en.wikipedia.org/wiki/MAJC</a>
</li>

<li>MDMX (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/MDMX">http://en.wikipedia.org/wiki/MDMX</a>
</li>

<li>MIPS Multiply Unit<br />
<a href="http://programmedlessons.org/AssemblyTutorial/Chapter-14/ass14_3.html">http://programmedlessons.org/AssemblyTutorial/Chapter-14/ass14_3.html</a>
</li>

<li>Silicon Graphics Introduces Enhanced MIPS Architecture<br />
<a href="http://bwrc.eecs.berkeley.edu/CIC/otherpr/enhanced_mips.html">http://bwrc.eecs.berkeley.edu/CIC/otherpr/enhanced_mips.html</a>
</li>

<li>MIPS-3D (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/MIPS-3D">http://en.wikipedia.org/wiki/MIPS-3D</a>
</li>

<li>MIPS Technologies, Inc. announces new MIPS-3D technology to provide silicon-efficient 3D graphics acceleration<br />
<a href="http://www.design-reuse.com/news/2057/mips-mips-3d-technology-silicon-efficient-3d-graphics-acceleration.html">http://www.design-reuse.com/news/2057/mips-mips-3d-technology-silicon-efficient-3d-graphics-acceleration.html</a>
</li>

<li>MIPS-3D Built-in Function (gcc.gnu.org)<br />
<a href="http://gcc.gnu.org/onlinedocs/gcc/MIPS_002d3D-Built_002din-Functions.html">http://gcc.gnu.org/onlinedocs/gcc/MIPS_002d3D-Built_002din-Functions.html</a>
</li>

<li>Baha Guclu Dundar:<br />
Intel MMX, SSE, SSE2, SSE3/SSSE3/SSE4 Architectures
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>

<li>Intel MMX<sup>TM</sup> Technology Overview<br />
Intel corporation, 1996</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>AMD K5 ("K5" / "5k86")<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g5K5-c.html">http://www.pcguide.com/ref/cpu/fam/g5K5-c.html</a>
</li>

<li>Sixth Generation Processors<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g6.htm">http://www.pcguide.com/ref/cpu/fam/g6.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Very_long_instruction_word">http://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>Tour of the Black Holes of Computing!: Floating Point<br />
<a href="http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt">http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt</a>
</li>

<li>3Dnow! Technology Manual<br />
AMD Inc., 2000</li>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>Control unit (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Control_unit">http://en.wikipedia.org/wiki/Control_unit</a>
</li>

<li>Cray History<br />
<a href="http://www.cray.com/About/History.aspx?404;http://www.cray.com:80/about_cray/history.html">http://www.cray.com/About/History.aspx?404;http://www.cray.com:80/about_cray/history.html</a>
</li>

<li>Cray Historical Timeline<br />
<a href="http://www.cray.com/Assets/PDF/about/CrayTimeline.pdf">http://www.cray.com/Assets/PDF/about/CrayTimeline.pdf</a>
</li>

<li>Computer Speed Claims 1980 to 1996<br />
<a href="http://homepage.virgin.net/roy.longbottom/mips.htm">http://homepage.virgin.net/roy.longbottom/mips.htm</a>
</li>

<li>Superpoèítaèe Cray<br />
<a href="http://www.root.cz/clanky/superpocitace-cray/">http://www.root.cz/clanky/superpocitace-cray/</a>
</li>

<li>Superpoèítaèe Cray (druhá èást)<br />
<a href="http://www.root.cz/clanky/superpocitace-cray-druha-cast/">http://www.root.cz/clanky/superpocitace-cray-druha-cast/</a>
</li>

<li>Superpoèítaèe Cray (tøetí èást)<br />
<a href="http://www.root.cz/clanky/superpocitace-cray-treti-cast/">http://www.root.cz/clanky/superpocitace-cray-treti-cast/</a>
</li>

<li>Superpoèítaèe Cray (ètvrtá èást)<br />
<a href="http://www.root.cz/clanky/superpocitace-cray-ctvrta-cast/">http://www.root.cz/clanky/superpocitace-cray-ctvrta-cast/</a>
</li>

<li>Superpoèítaèe Cray (pátá èást): architektura Cray X-MP<br />
<a href="http://www.root.cz/clanky/superpocitace-cray-pata-cast-architektura-pocitace-cray-x-mp-a-jeho-pouziti-ve-filmovem-prumyslu/">http://www.root.cz/clanky/superpocitace-cray-pata-cast-architektura-pocitace-cray-x-mp-a-jeho-pouziti-ve-filmovem-prumyslu/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

