<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Speciální formy, lambda výrazy a makra v programovacím jazyku LISP</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Speciální formy, lambda výrazy a makra v programovacím jazyku LISP</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;dne¹ní èásti seriálu o historii výpoèetní techniky dokonèíme popis základních vlastností programovacího jazyka LISP. Uká¾eme si, jakým zpùsobem se v LISPu (pøesnìji øeèeno v dialektu Common Lisp) vytváøí a volají u¾ivatelské funkce, øekneme si, k&nbsp;èemu je mo¾né vyu¾ít lambda výrazy a nakonec si popí¹eme základy tvorby maker v&nbsp;Common Lispu i zpùsob vyu¾ití ji¾ hotových maker, které jsou programátorùm dostupné v Common Lispovských knihovnách.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Tvorba u¾ivatelských funkcí</a></p>
<p><a href="#k02">2. Lambda výrazy</a></p>
<p><a href="#k03">3. Makra v Common Lispu</a></p>
<p><a href="#k04">4. Makra a tajemné znaky ` , a @</a></p>
<p><a href="#k05">5. Výpis expandovaného makra</a></p>
<p><a href="#k06">6. Pøíklady pou¾ití knihovního makra &bdquo;loop&ldquo;: operace nad seznamy</a></p>
<p><a href="#k07">7. Pøíklady pou¾ití knihovního makra &bdquo;loop&ldquo;: poèítané smyèky</a></p>
<p><a href="#k08">8. Literatura</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2>1. Tvorba u¾ivatelských funkcí</h2>

<p>V&nbsp;programovacím jazyce <i>LISP</i> je mo¾né kromì základních
(interních, primitivních) funkcí definovat a následnì i volat funkce
u¾ivatelské, podobnì jako v&nbsp;mnoha dal¹ích programovacích jazycích. Ve
skuteènosti je velká èást programù napsaných v&nbsp;LISPu tvoøena právì
definicemi nových funkcí. V&nbsp;<i>Common Lispu</i>, co¾ je jedna
z&nbsp;nejroz¹íøenìj¹ích a také nejkomplexnìj¹ích implementací tohoto jazyka,
se funkce vytváøí pomocí speciální formy nazvané <strong>defun</strong>
(<strong>de</strong>fine <strong>fun</strong>ction). Formát volání formy
<strong>defun</strong> pøi tvorbì nové funkce je velmi jednoduchý, programátor
si ov¹em musí dát pozor na správné uzávorkování:</p>

<pre>
(defun název_funkce(parametry funkce) tìlo funkce)
</pre>

<p>Návratovou hodnotou novì vytvoøené funkce (po jejím zavolání a vykonání) je
hodnota výrazu tvoøícího tìlo funkce, co¾ znamená, ¾e není nutné pou¾ívat
nìjakou formu pøíkazu <strong>return</strong> tak, jak je tomu v&nbsp;mnoha
dal¹ích programovacích jazycích. Uka¾me si nyní zpùsob vytvoøení dvou
jednoduchých funkcí a následného zavolání tìchto funkcí:</p>

<pre>
; funkce vracející druhou mocninu svého jediného parametru
(defun sqr(x) (* x x))

; funkce, která seète hodnoty svých dvou parametrù a vrátí výsledek souètu
(defun plus(x y) (+ x y))

; zavoláme první funkci
(sqr 42)
1764

; a nyní druhou
(plus 2 3)
5

; funkce lze samozøejmì libovolným zpùsobem kombinovat
(plus (sqr 3) (sqr 4))
25
</pre>



<p><a name="k02"></a></p>
<h2>2. Lambda výrazy</h2>

<p>Zpùsob vytváøení nových funkcí, který byl ukázán v&nbsp;pøedchozí kapitole,
není jediný mo¾ný, proto¾e <i>LISP</i> obsahuje mnohem obecnìj¹í a
v&nbsp;nìkolika ohledech i zajímavìj¹í mechanismus nazývaný <i>lambda
definice</i> nebo <i>lambda výrazy</i> pøedstavovaný speciální formou
<strong>lambda</strong>. Slovo &bdquo;lambda&ldquo; není zvoleno náhodnì,
proto¾e princip lambda výrazù vychází ze slavné Churchovy teorie <i>Lambda
kalkulu</i>. Zatímco funkce vytvoøené pomocí speciální formy
<strong>defun</strong> jsou pojmenované (a lze je tedy volat zápisem jejich
jména v&nbsp;programu), funkce vytvoøené pomocí speciální formy
<strong>lambda</strong> jméno nemají, tak¾e se takté¾ oznaèují termínem
<i>anonymní funkce</i>. Na následující dvojici pøíkladù je ukázán zpùsob
vytvoøení anonymní funkce (která není nikde pou¾ita) a následnì vytvoøení a
souèasnì i zavolání anonymní funkce:</p>

<pre>
; pouze vytvoøení anonymní funkce bez jejího dal¹ího pou¾ití
; (umìlý pøíklad)
(lambda (x) (* x x))

; vytvoøení anonymní funkce a její zavolání s parametrem 42
((lambda (x) (* x x)) 42)
1764
</pre>

<p>K&nbsp;èemu jsou ale lambda výrazy dobré, kdy¾ lze pomocí nich vytvoøit
&bdquo;pouze&ldquo; bezejmenná funkce? Pou¾ití bezejmenných funkcí je výhodné
v&nbsp;tom pøípadì, kdy¾ funkce má být pou¾ita pouze na jednom místì
v&nbsp;programu. Funkce je zde pøímo explicitnì definována, co¾ mù¾e zlep¹it
èitelnost programu. Uka¾me si to na jednoduchém pøíkladu. Prakticky v¹echny
dialekty jazyka <i>LISP</i> obsahují primitivní funkci <strong>mapcar</strong>,
která aplikuje nìjakou jinou funkci na v¹echny prvky seznamu (pou¾itím funkce
<strong>mapcar</strong> lze nahradit velké mno¾ství programových smyèek). Pokud
napøíklad potøebujeme získat druhé mocniny èíselných hodnot ulo¾ených
v&nbsp;seznamu, mù¾eme nejdøíve vytvoøit funkci <i>sqr</i>, kterou potom pomocí
<strong>mapcar</strong> aplikujeme na v¹echny potøebné hodnoty:</p>

<pre>
(defun sqr(x) (* x x))
(mapcar 'sqr '(1 2 3 4 5))
; výsledkem pøedchozího volání je nový seznam
(1 4 9 16 25)
</pre>

<p>Pokud by byla funkce <strong>sqr</strong> pou¾ita jen na jediném místì
programu, je zbyteèné, aby její jméno bylo ulo¾eno v&nbsp;jeho jmenném prostoru
a bude tedy výhodnìj¹í pou¾ít anonymní funkci, která se navíc vytváøí pøímo
v&nbsp;místì, kde má být pou¾ita (nemusíme tedy hledat definici funkce
v&nbsp;celém programu nebo v&nbsp;jeho knihovnách):</p>

<pre>
(mapcar (lambda (x) (* x x)) '(1 2 3 4 5))
(1 4 9 16 25)
</pre>

<p>Poznamenejme, ¾e výsledkem lambda výrazu je plnohodnotný LISPovský objekt,
který je napøíklad mo¾né ulo¾it do promìnné a následnì lze takovou
&bdquo;pojmenovanou anonymní funkci&ldquo; zavolat pomocí
<strong>funcall</strong>:</p>

<pre>
; vytvoøíme anonymní funkci, kterou ulo¾íme do promìnné "z"
(setq z (lambda(x) (* x x)))
#&lt;FUNCTION :LAMBDA (X) (* X X)&gt;
; vý¹e uvedený øádek je vypsán proto¾e se jedná o návratovou hodnotu
; speciální formy setq (set quote)

; zavolání funkce
(funcall z 42)
1764
</pre>



<p><a name="k03"></a></p>
<h2>3. Makra v Common Lispu</h2>

<p>Jednou z&nbsp;nejzajímavìj¹ích vlastností <i>LISPu</i> (pøesnìji øeèeno
nìkterých jeho implementací, jejích¾ typickým zástupcem je v&nbsp;nadpisu této
kapitoly zmínìný <i>Common Lisp</i>) je mo¾nost tvorby maker. Vzhledem
k&nbsp;tomu, ¾e LISPovské programy jsou tvoøeny, stejnì jako data, pomocí
rekurzivnì vnoøených seznamù, jsou LISPovská makra zalo¾ena na manipulaci se
seznamy tvoøícími program, co¾ je velký rozdíl napøíklad oproti makrùm
implementovaným v&nbsp;céèkovém preprocesoru, kde se jedná o pomìrnì jednoduché
textové zámìny. Vzhledem k&nbsp;tomu, ¾e LISPovská makra doká¾ou manipulovat
s&nbsp;vlastním programem, je mo¾né pomocí nich vytváøet napøíklad úplnì nové
jazykové konstrukce (rùzné smyèky, podmínìné pøíkazy, èásteènì vyhodnocované
formy atd.) s&nbsp;vlastní syntaxí, co¾ je pomìrnì unikátní vlastnost, kterou u
vìt¹iny dal¹ích programovacích jazykù nenajdeme. Zpùsob definice maker se
v&nbsp;nìkterých ohledech podobá definici funkcí, ale mezi funkcemi a makry
existuje jeden zásadní rozdíl.</p>

<p>LISPovské funkce získávají jako svoje argumenty LISPovské hodnoty,
tj.&nbsp;vìt¹inou atomy, (anonymní) funkce nebo seznamy, a vrací takté¾ nìjakou
LISPovskou hodnotu &ndash; opìt se mù¾e jednat o atom, (anonymní) funkci nebo
seznam. Funkce jsou vyhodnocovány (volány) a¾ pøi spu¹tìní programu. Makra jako
svùj vstup získávají LISPovský kód (zapsaný formou rekurzivnì zanoøeného
seznamu) a vrací takté¾ LISPovský kód, co¾ nepøedstavuje oproti funkcím ¾ádný
zásadnìj¹í rozdíl. Ov¹em na rozdíl od funkcí jsou makra volána ji¾ pøi prvotním
zpracovávání programu, podobnì jako jsou céèková makra zpracovávána céèkovým
preprocesorem (cpp) je¹tì pøed vlastní kompilací. Teprve výsledek volání makra
(nazývaný takté¾ expanze makra) je pova¾ován za zápis výrazu, který mù¾e být
dále zpracován, tj.&nbsp;buï vyhodnocen (interpretaèní varianty LISPu) nebo
zkompilován (varianty LISPu vybavené pøekladaèem). Poznamenejme je¹tì, ¾e
v&nbsp;tìle makra se mù¾e vyskytovat volání dal¹ího makra, co¾ znamená, ¾e LISP
musí pøi expanzi maker pou¾ít rekurzi.</p>



<p><a name="k04"></a></p>
<h2>4. Makra a tajemné znaky ` , a @</h2>

<p>Pøi zápisu maker se pomìrnì èasto pou¾ívají znaky <strong>`</strong> (zpìtný
apostrof), <strong>,</strong> (èárka) a <strong>@</strong> (zavináè). Zpìtný
apostrof se zapisuje pøed seznam, kde má podobný význam jako bì¾ný apostrof,
který, jak ji¾ víme, zabraòuje tomu, aby byl seznam vyhodnocen (jedná se o
zkrácený zápis speciální formy <strong>quote</strong>). V&nbsp;pøípadì zpìtného
apostrofu je takté¾ zabránìno vyhodnocení seznamu, který se za apostrofem
nachází, ov¹em navíc lze uvnitø takového seznamu pou¾ít symbol èárka, který
oznaèuje ty polo¾ky seznamu, které se naopak vyhodnotit mají. Symbol zavináèe
zapsaný (spoleènì s&nbsp;èárkou) pøed nìjakou polo¾ku seznamu takté¾ vede
k&nbsp;vyhodnocení této polo¾ky, ale odli¹ným zpùsobem &ndash; polo¾ka (kterou
mù¾e být napøíklad dal¹í seznam) se pøímo vlo¾í do seznamu uvozeného zpìtným
apostrofem. Zní to celé slo¾itì? Nejlep¹í bude, kdy¾ si zpùsob pou¾ití v¹ech
tøí symbolù uká¾eme na jednoduchých pøíkladech:</p>

<pre>
; vytvoøíme si dvì promìnné x a y obsahující hodnoty 1 a 2
(setq x 1)
1
(setq y 2)
2

; pokus o vyhodnocení seznamu (x y) musí skonèit chybou, proto¾e
; x není jméno ¾ádné funkce ale promìnné obsahující atom
(x y)
*** - EVAL: undefined function X

; pou¾ití normálního apostrofu zabraòuje vyhodnocení seznamu
'(x y)
(X Y)

; pou¾ití zpìtného apostrofu takté¾ zabraòuje vyhodnocení seznamu
`(x y)
(X Y)

; zabráníme vyhodnocení celého seznamu, ale naopak si vynutíme vyhodnocení y
`(x ,y)
(X 2)

; zabráníme vyhodnocení celého seznamu, ale naopak si vynutíme vyhodnocení x
`(,x y)
(1 Y)

; seznam jako celek vyhodnocen není (ty by vedlo k chybì - viz vý¹e)
; ale jsou vyhodnoceny promìnné x a y
`(,x ,y)
(1 2)
</pre>

<p>Pou¾ití zavináèe je ponìkud komplikovanìj¹í:</p>

<pre>
; promìnná z obsahuje seznam se tøemi symboly
(setq z '(www root cz))
(WWW ROOT CZ) 

; zabráníme vyhodnocení seznamu obsahujícího z (tedy dal¹í seznam)
`(1 2 3 z 4 5 6)
(1 2 3 Z 4 5 6)

; seznam jako celek není vyhodnocen, ale promìnná z ano
`(1 2 3 ,z 4 5 6)
(1 2 3 (WWW ROOT CZ) 4 5 6)

; podobné pøedchozímu, ov¹em s tím rozdílem, ¾e je seznam ulo¾ený
; v promìnné z "rozpu¹tìn" (zmizí závorky okolo trojice symbolù
; www root cz)
`(1 2 3 ,@z 4 5 6)
(1 2 3 WWW ROOT CZ 4 5 6)
</pre>

<p>Nyní si koneènì mù¾eme nìjaké jednoduché makro ukázat. Namísto formy
<strong>defun</strong> se pøi tvorbì maker pou¾ívá forma
<strong>defmacro</strong>:</p>

<pre>
(defmacro Square (x) 
  `(* ,x ,x))
</pre>

<p>Toto makro funguje následujícím zpùsobem: pøi prvotním naèítání LISPovských
výrazù (forem) se jakýkoli výskyt <strong>(Square cokoli)</strong> nahradí
formou <strong>(* cokoli cokoli)</strong>. Teprve tato forma je pøedána
interpretru nebo pøekladaèi pro dal¹í zpracování, napøíklad prímému
vyhodnocení. Kdy¾ je LISPovský program pøekládán, tak se pøelo¾í a¾ výsledek
aplikace makra, co¾ je opìt shodné se zpùsobem pøekladu céèkového programu.</p>

<p>Makro si mù¾eme ihned vyzkou¹et:</p>

<pre>
(Square 42)
1764

(Square (+ 1 2))
9
</pre>



<p><a name="k05"></a></p>
<h2>5. Výpis expandovaného makra</h2>

<p>Pøi tvorbì maker se mù¾e stát, ¾e makro kvùli nìjaké chybì neprovádí pøesnì
tu èinnost, jakou programátor zamý¹lel. Zatímco funkce jsou volány a¾
v&nbsp;dobì bìhu programu, tj.&nbsp;je mo¾né do jejich tìla vkládat rùzné
ladicí pøíkazy (výpis hodnot, logování, aserce) èi dokonce bìh programu
trasovat, u maker to není mo¾né, proto¾e jsou expandována ji¾ pøi pøekladu
programu. Ov¹em v&nbsp;<i>Common Lispu</i> je mo¾né si pomocí zabudované funkce
<strong>macroexpand</strong> nebo <strong>macroexpand-1</strong> zobrazit výpis
makra po expanzi, co¾ mù¾e být velmi u¾iteèné. Zatímco funkce
<strong>macroexpand</strong> zobrazí plnì expandované makro (tj.&nbsp;výsledný
LISPovský kód po expanzi v¹ech maker, i tìch vnoøených), je po zavolání makra
<strong>macroexpand-1</strong> zobrazeno makro pouze po první expanzi, co¾
znamená, ¾e uvnitø expandovaného kódu se mù¾e vyskytovat i volání dal¹ích
maker. V&nbsp;praxi se pøi ladìní maker èastìji pou¾ívá právì funkce
<strong>macroexpand-1</strong>, její¾ pou¾ití je velmi jednoduché:</p>

<pre>
; nejprve znovu vytvoøíme pomocnou funkci Square
(defmacro Square (x)
  `(* ,x ,x)
)

; expanze makra pøi volání funkce Square s parametrem jen¾ je atomem
(macroexpand-1 '(Square 42))
(* 42 42) ;

; expanze makra pøi volání funkce Square s parametrem jen¾ je formou
(macroexpand-1 '(Square (+ 1 2)))
(* (+ 1 2) (+ 1 2)) ;

; makro se expanduje i v pøípadì, ¾e se pou¾ije neznámý symbol "plus"
(macroexpand-1 '(Square (plus 1 2)))
(* (PLUS 1 2) (PLUS 1 2)) ;
</pre>

<p>A¾ pøi pohledu na expandované makro nás mù¾e napadnout, ¾e vlastnì nepracuje
dokonale, v&nbsp;nìkterých pøípadech dokonce pracuje chybnì. Problém spoèívá
v&nbsp;tom, ¾e se pøedaný parametr po expanzi makra vyhodnocuje dvakrát, co¾
samozøejmì není vìt¹í problém v&nbsp;pøípadì, ¾e se pøedává atomická hodnota
(èíslo) nebo jednoduchý výraz, ov¹em kdyby se jednalo napøíklad o funkci
naèítající hodnotu z&nbsp;databáze nebo ze souboru (popø.&nbsp;ze standardního
vstupu), bylo by toto naèítání provádìno dvakrát a ne jedenkrát, jak by ka¾dý
programátor pøi pohledu na program volající makro oèekával. Mù¾eme si to
ostatnì vyzkou¹et (funkce <strong>read</strong> provádí naètení výrazu ze
standardního vstupu):</p>

<pre>
(Square (read))
2 ; zadáno u¾ivatelem z klávesnice
3 ; zadáno (druhá a jiná! hodnota) takté¾ z klávesnice
6 ; výsledek volání makra = 2*3
</pre>

<p>Makro lze &bdquo;opravit&ldquo; napøíklad tak, ¾e se pou¾ije pomocná lokální
promìnná <i>temp</i>:</p>

<pre>
(defmacro Square2 (x)
    `(let ((temp ,x)) (* temp temp))
)

; podíváme se na expanzi pøi jeho volání
; s parametrem (+ 1 2)
(macroexpand-1 '(Square2 (+ 1 2)))
(LET ((TEMP (+ 1 2))) (* TEMP TEMP)) ;
; vidíme, ¾e se výraz (+ 1 2) vyhodnocuje pouze jedenkrát

; otestujeme volání makra pøi pøedání funkce read
(Square2 (read))
2 ; zadáno u¾ivatelem z klávesnice
4 ; správný výsledek a navíc program vy¾adoval pouze jediný vstup z klávesnice
</pre>

<p>Pomocí <strong>macroexpand-1</strong> je mo¾né prozkoumat i makra dostupná
v&nbsp;základní knihovnì jazyka:</p>

<pre>
; makra or a and jsou implementovány tak, aby podporovaly
; zkrácené vyhodnocení logických výrazù
(macroexpand-1 '(or foo bar))
(COND (FOO) (T BAR)) ;

(macroexpand-1 '(and (foo t) (foo nil)))
(COND ((NOT (FOO T)) NIL) (T (FOO NIL))) ;
</pre>



<p><a name="k06"></a></p>
<h2>6. Pøíklady pou¾ití knihovního makra &bdquo;loop&ldquo;: operace nad seznamy</h2>
 
<p>Jedním z&nbsp;neju¾iteènìj¹ích maker, které se nachází v&nbsp;knihovnì
<i>Common Lispu</i>, je makro nazvané prozaicky <strong>loop</strong>, jen¾ je
doplnìné o nìkolik dal¹ích pomocných maker a symbolù (ty jsou pou¾ity pro
doplnìní syntaxe o dal¹í &bdquo;klíèová slova&ldquo;). Pomocí makra
<strong>loop</strong> lze v&nbsp;<i>LISPu</i> (tj.&nbsp;jazyku zalo¾eném
èásteènì na funkcionálním paradigmatu, který pùvodnì vedl u¾ivatele
k&nbsp;pou¾ívání rekurze namísto psaní programových smyèek) realizovat znaèné
mno¾ství rùzných typù programových smyèek, napøíklad smyèky poèítané
(s&nbsp;mo¾ností zmìny kroku, o který se zmìní hodnota èítaèe èi èítaèù
smyèek pøi ka¾dé iteraci), smyèky s&nbsp;podmínkou (odpovídá napøíklad
Pascalovským smyèkám typu <strong>while-do</strong> a
<strong>repeat-until</strong>) èi iteraèní smyèky, která v&nbsp;ka¾dé iteraci
operuje nad prvky seznamù, polí èi asociativních polí
(<strong>for-each</strong>). Na pøíkladu makra <strong>loop</strong> je pìknì a
názornì ukázána jedna z&nbsp;nejvìt¹ích výhod <i>LISPovských</i> maker &ndash;
právì pomocí maker a nìkterých dal¹ích vlastností <i>LISPu</i> je mo¾né
vytvoøit zcela nový jazyk s&nbsp;vlastní syntaxí. Na následujících
demonstraèních pøíkladech si uká¾eme nìkteré mo¾nosti, které makro
<strong>loop</strong> programátorùm nabízí:</p>

<p>Smyèka, která postupnì iteruje nad v¹emi elementy ulo¾enými
v&nbsp;seznamu (tj.&nbsp;postupnì v¹emi prvky prochází):</p>

<pre>
(loop for i in '(a b c d) do (print i))

A
B
C
D
</pre>

<p><i>Poznámka: samotné makro <strong>loop</strong> vrací jako svoji návratovou
hodnotu (vìt¹inou) atom NIL, který ve výpisech pro vìt¹í pøehlednost neuvádím.
Pokud si pøíklady budete sami spou¹tìt v&nbsp;interpretru Common Lispu, bude po
skonèení smyèky na standardní výstup navíc vypsán øádek obsahující právì
NIL.</i></p>

<p>Pokud se ve zpracovávaném seznamu nachází dal¹í rekurzivnì vnoøené seznamy,
jsou pøi iterování seznamem chápány jako jeden prvek:</p>

<pre>
(loop for i in '(a (b c) d) do (print i))

A 
(B C) 
D 
</pre>

<p>Smyèka, která postupnì iteruje (prochází) pøes CDR zvoleného seznamu.
V&nbsp;první iteraci je do promìnné <i>i</i> pøiøazen celý seznam <i>s</i>, ve
druhé iteraci <i>(cdr s)</i>, ve tøetí iteraci <i>(cdr (cdr s))</i> atd.:</p>

<pre>
(loop for i on '(a b c d) do (print i))

(A B C D)
(A B C)
(B C)
(C)
</pre>

<p>Zpracování seznamu obsahujícího ve druhém prvku podseznam:</p>

<pre>
(loop for i on '(a (b c) d) do (print i))

(A (B C) D) 
((B C) D) 
(D) 
</pre>

<p>Iterace nad dvojicí seznamù a postupná konstrukce seznamu obsahujícího
dvojice prvkù ze seznamu prvního a druhého. Výsledek není v&nbsp;tomto pøípadì
tisknut, ale vrácen jako návratová hodnota smyèky, tj.&nbsp;lze ho napøíklad
pøiøadit promìnné:</p>

<pre>
(loop for x in '(a b c d e)
      for y in '(1 2 3 4 5)
      collect (list x y)
)

((A 1) (B 2) (C 3) (D 4) (E 5))
</pre>

<p>Pøiøazení výsledného seznamu vytvoøeného smyèkou do promìnné:</p>

<pre>
(setq a (loop for x in '(a b c d e)
              for y in '(1 2 3 4 5)
              collect (list x y)
        )
)
((A 1) (B 2) (C 3) (D 4) (E 5))

; tisk hodnoty promìnné a
a
((A 1) (B 2) (C 3) (D 4) (E 5))
</pre>



<p><a name="k07"></a></p>
<h2>7. Pøíklady pou¾ití knihovního makra &bdquo;loop&ldquo;: poèítané smyèky</h2>

<p>V&nbsp;pøedchozím textu jsme si øekli, ¾e makro <strong>loop</strong> je
mo¾né pou¾ít mj.&nbsp;i pro tvorbu poèítaných smyèek, tj.&nbsp;smyèek, které
v&nbsp;ka¾dé iteraci zvy¹ují nebo naopak sni¾ují hodnotu èítaèe (lokální
promìnné platné v&nbsp;rámci smyèky). Syntaxe, kterou makro
<strong>loop</strong> pro tento typ smyèek pou¾ívá, je v&nbsp;mnoha ohledech
podobná syntaxi Pascalu èi nìkterých verzí Basicu, jak se ostatnì mù¾ete sami
pøesvìdèit na následujících demonstraèních pøíkladech:</p>

<p>Základní tvar poèítané smyèky se zadáním horní a dolní meze èítaèe.
Hodnota èítaèe se v&nbsp;tomto pøípadì v&nbsp;ka¾dé iteraci zvìt¹uje o
jednièku, jak je to ostatnì u poèítaných smyèek bì¾né:</p>

<pre>
(loop for i from 1 to 10 do (print i))

1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
</pre>

<p>Poèítaná smyèka s&nbsp;èítaèem, jeho¾ hodnota se v&nbsp;ka¾dé iteraci
zmen¹uje. Pov¹imnìte si pou¾ití slova <strong>downto</strong>, které se
vyskytuje napøíklad i v&nbsp;Pascalu:</p>

<pre>
(loop for i from 10 downto 1 do (print i))

10 
9 
8 
7 
6 
5 
4 
3 
2 
1 
</pre>

<p>U poèítaných smyèek lze mìnit krok, tj.&nbsp;hodnotu, o kterou se èítaè
smyèky v&nbsp;ka¾dé iteraci zvìt¹í nebo naopak zmen¹í:</p>

<pre>
(loop for i from 1 to 10 by 1.5 do (print i))

1 
2.5 
4.0 
5.5 
7.0 
8.5 
10.0 
</pre>

<p>V&nbsp;mnoha implementacích programovacího jazyka <i>LISP</i> je podporován
i numerický datový typ &bdquo;zlomek&ldquo;, co¾ je racionální èíslo vyjádøené
èitatelem a jmenovatelem oddìleným znakem / (lomítko). V&nbsp;poèítaných
smyèkách lze samozøejmì zlomky vyu¾ívat, jak je to patrné z&nbsp;následujících
dvou pøíkladù:</p>

<pre>
(loop for i from 0 to 10 by 3/2 do (print i))

0 
3/2 
3 
9/2 
6 
15/2 
9 

(loop for i from 10 downto 0 by 4/3 do (print i))

10 
26/3 
22/3 
6 
14/3 
10/3 
2 
2/3 
</pre>

<p>Hodnoty èítaèe lze omezit prakticky libovolnou podmínkou.
V&nbsp;následujícím pøíkladu je pou¾it predikát <strong>evenp</strong>, který
vrací hodnotu T (pravda) v&nbsp;tom pøípadì, kdy je parametr tohoto predikátu
sudé èíslo:</p>

<pre>
(loop for i from 1 to 10 when (evenp i) do (print i))

2 
4 
6 
8 
10 
</pre>

<p>Hodnoty, kterých postupnì nabývá èítaè smyèky, lze mít ulo¾eny
v&nbsp;seznamu (i kdy¾ tento pøíklad je ponìkud umìlý, proto¾e lze napsat
jednodu¹¹ím zpùsobem):</p>

<pre>
(loop with a = '(1 42 3) for i in a do (print i))

1
42
3
</pre>

<p>Na závìr si uká¾eme zpùsob zápisu smyèky, která souèasnì prochází v¹emi
prvky seznamu a navíc mìní hodnotu èítaèe. Právì tento typ smyèky mnohdy
citelnì chybí v&nbsp;ostatních programovacích jazycích, které nabízí buï
striktnì poèítanou smyèku nebo smyèku typu <i>for-each</i>:</p>

<pre>
(loop for x in '(a b c d e)
      for y from 1 do
      (format t "~s = ~s~%" y x)
)
1 = A
2 = B
3 = C
4 = D
5 = E
</pre>

<p>Poznámka: funkce <strong>format</strong> se v&nbsp;mnoha ohledech podobá
napøíklad céèkové funkci <strong>printf</strong>. Prvním parametrem této funkce
je výstupní proud, do kterého se má výsledek tisknout (s&nbsp;tou výjimkou, ¾e
<strong>nil</strong> znaèí, ¾e se výsledek nikam netiskne, ale je navrácen ve
formì øetìzce, a <strong>T</strong> naopak odpovídá standardnímu výstupu),
druhým parametrem je formátovací øetìzec a dal¹í parametry jsou postupnì
tisknuty na výstup podle pravidel zadaných ve formátovacím øetìzci. Ve vý¹e
uvedeném pøíkladu jsou pou¾ita dvì formátovací pravidla: <strong>~s</strong> =
tisk hodnoty, <strong>~%</strong> = odøádkování.</p>



<p><a name="k08"></a></p>
<h2>8. Literatura</h2>

<ol>

<li>Hillis, D.<br />
<i>&bdquo;New Computer Architectures and Their Relationship to Physics or Why CS is No Good&ldquo;</i></br>
Int J. Theoretical Physics 21 (3/4) 255-262.
</li>

<li>Lewis W. Tucker, George G. Robertson,<br />
<i>&bdquo;Architecture and Applications of the Connection Machine&ldquo;</i></br>
Computer, vol. 21, no. 8, pp. 26&ndash;38, August, 1988.
</li>

<li>Arthur Trew and Greg Wilson (eds.) (1991)<br />
<i>&bdquo;Past, Present, Parallel: A Survey of Available Parallel Computing Systems&ldquo;</i></br>
New York: Springer-Verlag. ISBN 0-387-19664-1.
</li>

<li>W. Daniel Hillis and Lewis W. Tucker<br />
<i>&bdquo;The CM-5 Connection Machine: A Scalable Supercomputer&ldquo;</i></br>
In Communications of the ACM, Vol. 36, No. 11 (November 1993)
</li>

<li>Cliff Lasser, Jeff Mincy, J.P. Massar<br />
<i>&bdquo;The Essential *LISP Manual&ldquo;</i></br>
Thinking Machines Corporation, 1986.
</li>

<li>Anonymous<br />
<i>&bdquo;Getting Started in *Lisp, Version 6.1&ldquo;</i></br>
Thinking Machines Corporation, Cambridge, Massachusetts, June 1991.
</li>

<li>Anonymous<br />
<i>&bdquo;*Lisp Dictionary&ldquo;</i></br>
Thinking Machines Corporation, Cambridge, Massachusetts.
</li>

<li>Anonymous<br />
<i>&bdquo;*Lisp Timesharing User's Guide&ldquo;</i></br>
Online at CMU AI Repository
</li>

<li>Zdzislaw Meglicki<br />
<i>&bdquo;The CM5 *Lisp Course&ldquo;</i></br>
Centre for Information Science Research, The Australian National University, 1994
</li>

<li>McCarthy<br />
<i>&bdquo;Recursive functions of symbolic expressions and their computation by machine, part I&ldquo;</i><br />
1960
</li>

<li>Guy L. Steele<br />
<i>&bdquo;History of Scheme&ldquo;</i><br />
2006, Sun Microsystems Laboratories
</li>

<li>
Koláø J., Muller K.:<br />
<i>&bdquo;Speciální programovací jazyky&ldquo;</i><br />
Praha 1981
</li>

<li>
<i>&bdquo;AutoLISP Release 9, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., October 1987
</li>

<li>
<i>&bdquo;AutoLISP Release 10, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., September 1988
</li>

<li>McCarthy, John; Abrahams, Paul W.; Edwards, Daniel J.; Hart, Timothy P.; Levin, Michael I.<br />
<i>&bdquo;LISP 1.5 Programmer's Manual&ldquo;</i><br />
MIT Press. ISBN 0 262 130 1 1 4
</li>

<li>Carl Hewitt; Peter Bishop and Richard Steiger<br />
<i>&bdquo;A Universal Modular Actor Formalism for Artificial Intelligence&ldquo;</i><br />
1973
</li>

<li>Feiman, J.<br />
<i>&bdquo;The Gartner Programming Language Survey (October 2001)&ldquo;</i><br />
Gartner Advisory
</li>

</ol>



<p><a name="k09"></a></p>
<h2>9. Odkazy na Internetu</h2>

<ol>

<li>Lecture Notes: Macros<br />
<a href="http://www.apl.jhu.edu/~hall/Lisp-Notes/Macros.html">http://www.apl.jhu.edu/~hall/Lisp-Notes/Macros.html
</a>
</li>

<li>Common Lisp's Loop Macro Examples for Beginners<br />
<a href="http://www.unixuser.org/~euske/doc/cl/loop.html">http://www.unixuser.org/~euske/doc/cl/loop.html</a>
</li>

<li>Macro LOOP<br />
<a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_loop.htm">http://www.lispworks.com/documentation/HyperSpec/Body/m_loop.htm</a>
</li>

<li>Loop<br />
<a href="http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node235.html">http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node235.html</a>
</li>

<li>Tutorial for the Common Lisp Loop Macro<br />
<a href="http://www.ai.sri.com/~pkarp/loop.html">http://www.ai.sri.com/~pkarp/loop.html</a>
</li>

<li>LISPová makra aneb programovatelný programovací jazyk<br />
<a href="http://www.root.cz/clanky/lispova-makra-aneb-programovatelny-programovaci-jazyk/">http://www.root.cz/clanky/lispova-makra-aneb-programovatelny-programovaci-jazyk/</a>
</li>

<li>Jemný úvod do LISPu<br />
<a href="http://www.root.cz/clanky/jemny-uvod-do-lispu/">http://www.root.cz/clanky/jemny-uvod-do-lispu/</a>
</li>

<li>*Lisp<br />
<a href="http://en.wikipedia.org/wiki/*Lisp">http://en.wikipedia.org/wiki/*Lisp</a>
</li>

<li>Lisp machine<br />
<a href="http://en.wikipedia.org/wiki/Lisp_machine">http://en.wikipedia.org/wiki/Lisp_machine</a>
</li>

<li>MIT CADR Lisp Machine FAQ<br />
<a href="http://www.unlambda.com/cadr/cadr_faq.html">http://www.unlambda.com/cadr/cadr_faq.html</a>
</li>

<li>Symbolics LISP Machines<br />
<a href="http://www.frobenius.com/symbolics.htm">http://www.frobenius.com/symbolics.htm</a>
</li>

<li>UNIVAC<br />
<a href="http://en.wikipedia.org/wiki/Univac">http://en.wikipedia.org/wiki/Univac</a>
</li>

<li>UNIVAC 1100/2200 series<br />
<a href="http://en.wikipedia.org/wiki/UNIVAC_1100/2200_series#UNIVAC_1100_series">http://en.wikipedia.org/wiki/UNIVAC_1100/2200_series#UNIVAC_1100_series</a>
</li>

<li>Allegro CL Examples and Utilities<br />
<a href="http://examples.franz.com/index.html">http://examples.franz.com/index.html</a>
</li>

<li>LISP 1.5 for the Univac 1100 Mainframe<br />
<a href="http://www.frobenius.com/univac.htm">http://www.frobenius.com/univac.htm</a>
</li>

<li>STARSIM: Thinking Machines' *Lisp Simulator<br />
<a href="http://www-2.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/lisp/impl/starlisp/0.html">http://www-2.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/lisp/impl/starlisp/0.html</a>
</li>

<li>Connection Machine<br />
<a href="http://en.wikipedia.org/wiki/Connection_Machine">http://en.wikipedia.org/wiki/Connection_Machine</a>
</li>

<li>Connection Machine -1-2-5<br />
<a href="http://ed-thelen.org/comp-hist/vs-cm-1-2-5.html">http://ed-thelen.org/comp-hist/vs-cm-1-2-5.html</a>
</li>

<li>Richard Feynman and The Connection Machine<br />
<a href="http://www.longnow.org/essays/richard-feynman-connection-machine/">http://www.longnow.org/essays/richard-feynman-connection-machine/</a>
</li>

<li>Sheryl Handler<br />
<a href="http://en.wikipedia.org/wiki/Sheryl_Handler">http://en.wikipedia.org/wiki/Sheryl_Handler</a>
</li>

<li>W. Daniel Hillis<br />
<a href="http://en.wikipedia.org/wiki/Danny_Hillis">http://en.wikipedia.org/wiki/Danny_Hillis</a>
</li>

<li>The Rise and Fall of Thinking Machines<br />
<a href="http://www.inc.com/magazine/19950915/2622.html">http://www.inc.com/magazine/19950915/2622.html</a>
</li>

<li>Lisp (programming language)<br />
<a href="http://en.wikipedia.org/wiki/Lisp_(programming_language)">http://en.wikipedia.org/wiki/Lisp_(programming_language)</a>
</li>

<li>On Lisp<br />
<a href="http://paulgraham.com/onlisptext.html?asdf">http://paulgraham.com/onlisptext.html?asdf</a>
</li>

<li>Lambda calculus<br />
<a href="http://en.wikipedia.org/wiki/Lambda_calculus">http://en.wikipedia.org/wiki/Lambda_calculus</a>
</li>

<li>A Short Introduction to the Lambda Calculus<br />
<a href="http://www.cs.bham.ac.uk/~axj/pub/papers/lambda-calculus.pdf">http://www.cs.bham.ac.uk/~axj/pub/papers/lambda-calculus.pdf</a>
</li>

<li>A Tutorial Introduction to the Lambda Calculus<br />
<a href="http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf">http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf</a>
</li>

<li>Scheme (programming language)<br />
<a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)">http://en.wikipedia.org/wiki/Scheme_(programming_language)</a>
</li>

<li>An Introduction to Scheme and its Implementation<br />
<a href="ftp://ftp.cs.utexas.edu/pub/garbage/cs345/schintro-v14/schintro_toc.html">ftp://ftp.cs.utexas.edu/pub/garbage/cs345/schintro-v14/schintro_toc.html</a>
</li>

<li>The latest version of the Scheme standard: R6RS<br />
<a href="http://www.r6rs.org/">http://www.r6rs.org/</a>
</li>

<li>Humor on Computers, Systems and Programming<br />
<a href="http://www-crypto.htw-saarland.de/weber/misc/programming.html">http://www-crypto.htw-saarland.de/weber/misc/programming.html</a>
</li>

<li>Teach Yourself Scheme in Fixnum Days<br />
<a href="http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme.html">http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme.html</a>
</li>

<li>AutoLISP<br />
<a href="http://en.wikipedia.org/wiki/AutoLISP">http://en.wikipedia.org/wiki/AutoLISP</a>
</li>

<li>Rosetta Code &ndash; Category:Lisp<br />
<a href="http://rosettacode.org/wiki/Category:Lisp">http://rosettacode.org/wiki/Category:Lisp</a>
</li>

<li>Retrocomputing &ndash; MIT CADR Lisp Machines<br />
<a href="http://www.unlambda.com/cadr/index.html">http://www.unlambda.com/cadr/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2010</small></p>
</body>
</html>

