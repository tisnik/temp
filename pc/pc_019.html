<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Architektury vyrovnávacích pamìtí</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Architektury vyrovnávacích pamìtí</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o mikropoèítaèích si vysvìtlíme, jakým zpùsobem pracují nìkteré typické konfigurace vyrovnávacích pamìtí (cache memory). Zejména si popí¹eme vliv asociativity vyrovnávacích pamìtí a strategie pøidìlování blokù na celkový výkon poèítaèe.</p>



<h1>Obsah</h1>
<p>
<a href="#k01">1. Podmínka úèinnosti vyrovnávací pamìti: lokalita dat èi programového kódu</a><br />
<a href="#k02">2. Struktura údajù ulo¾ených ve vyrovnávací pamìti</a><br />
<a href="#k03">3. Asociativita vyrovnávací pamìti</a><br />
<a href="#k04">4. Pøímo mapovaná vyrovnávací pamì»</a><br />
<a href="#k05">5. Plnì asociativní vyrovnávací pamì»</a><br />
<a href="#k06">6. Dvoucestná èi ètyøcestná asociativní vyrovnávací pamì»</a><br />
<a href="#k07">7. Strategie pøidìlování blokù</a><br />
<a href="#k08">8. Literatura a odkazy na Internetu</a><br />
<a href="#k09">9. Obsah dal¹ího pokraèování seriálu</a><br />
</p>



<p><a name="k01"></a></p>
<h1>1. Podmínka úèinnosti vyrovnávací pamìti: lokalita dat èi programového kódu</h1>

<p>V&nbsp;pøedchozí èásti tohoto seriálu jsme si popsali hierarchii pamìti
(pyramidovou strukturu) i základní zpùsob zapojení vyrovnávacích pamìtí první a
druhé úrovnì (<i>L1 cache, L2 cache</i>) do pamì»ového subsystému poèítaèù.
Vyrovnávací pamìti jsou obecnì velmi rychlé, ov¹em jejich kapacita je pomìrnì
malá, typicky dosahuje pouhého jednoho promile a¾ jednoho procenta kapacity
operaèní pamìti (ta je zalo¾ena na relativnì pomalé ov¹em levné DRAM, která se
mj.&nbsp;vyznaèuje velkou integrací). Cena, pøesnìji øeèeno èasové zpo¾dìní,
které zaplatíme za operaci ètení èi zápisu z&nbsp;adresy, je¾ se nenachází ve
vyrovnávací pamìti (<i>cache miss</i>) mù¾e být docela vysoká, proto se tvùrci
architektury vyrovnávacích pamìtí sna¾í, aby byla vyrovnávací pamì» i pøes
svoji malou kapacitu pou¾ita pro co nejvìt¹í mno¾ství ètecích i zápisových
operací, tj.&nbsp;aby se minimalizoval poèet &bdquo;výpadkù &ldquo; (<i>cache
miss</i>) a naopak maximalizoval poèet <i>cache hits</i>, tj.&nbsp;situací, kdy
se po¾adovaná data nachází ve vyrovnávací pamìti.</p>

<p>Nejlépe si tuto snahu vysvìtlíme na údajích z&nbsp;praxe. Napøíklad u
typické konfigurace poèítaèe zalo¾eného na procesoru <i>Intel Pentium M</i>
(pou¾ívaného v&nbsp;noteboocích) èi <i>Celeron</i> se uvádí následující údaje;
v¹e v&nbsp;poètu taktù (cyklù procesoru):</p>

<table>
<tr><th>Ètení èi zápis z/do</th><th>Poèet cyklù</th></tr>
<tr><td>Pracovní registr</td><td>1 èi ménì v&nbsp;pøípadì úspì¹ného zøetìzení instrukcí</td></tr>
<tr><td>Vyrovnávací pamì» první úrovnì</td><td>cca 3</td></tr>
<tr><td>Vyrovnávací pamì» druhé úrovnì</td><td>cca 14</td></tr>
<tr><td>Operaèní pamì»</td><td>cca 240</td></tr>
</table>

<p>Pokud nìjaký program má na této konfiguraci pøeèíst 1000000 adres (a nìco
s&nbsp;jejich obsahem udìlat, napøíklad provést jejich souèet s&nbsp;ulo¾ením
výsledku do pracovního registru) a efektivita vyrovnávací pamìti je rovna 95
procentùm, stráví mikroprocesor ètením adres celkem:</p>

<p>1000000&times;0,95&times;3=<strong>2850000</strong> taktù pøi ètení z&nbsp;L1 cache a<br />
1000000&times;(1-0,95)&times;240=<strong>12000000</strong> taktù pøi ètení z&nbsp;operaèní pamìti,<br />
celkem tedy: <strong>14850000</strong> taktù (pøíklad je velmi zjednodu¹ený,
nepoèítá napøíklad s&nbsp;vyrovnávací pamìtí druhé úrovnì, blokovým ètením
s&nbsp;DRAM apod., omezené kapacitì vyrovnávací pamìti atd.).</p>

<p>Vliv efektivity vyrovnávací pamìti (pomìru <i>cache hit</i> vùèi v¹em
operacím), je patrný i z&nbsp;následující tabulky, opìt platné pro pøedchozí
konfiguraci:</p>

<table>
<tr><th>Efektivita</th><th>L1 cache (taktù)</th><th>DRAM (taktù)</th><th>Celkem</th></tr>
<tr><td>  0%</td><td>      0</td><td>240000000</td><td>240000000</td></tr>
<tr><td>  5%</td><td> 150000</td><td>228000000</td><td>228150000</td></tr>
<tr><td> 10%</td><td> 300000</td><td>216000000</td><td>216300000</td></tr>
<tr><td> 15%</td><td> 450000</td><td>204000000</td><td>204450000</td></tr>
<tr><td> 20%</td><td> 600000</td><td>192000000</td><td>192600000</td></tr>
<tr><td> 25%</td><td> 750000</td><td>180000000</td><td>180750000</td></tr>
<tr><td> 30%</td><td> 900000</td><td>168000000</td><td>168900000</td></tr>
<tr><td> 35%</td><td>1050000</td><td>156000000</td><td>157050000</td></tr>
<tr><td> 40%</td><td>1200000</td><td>144000000</td><td>145200000</td></tr>
<tr><td> 45%</td><td>1350000</td><td>132000000</td><td>133350000</td></tr>
<tr><td> 50%</td><td>1500000</td><td>120000000</td><td>121500000</td></tr>
<tr><td> 55%</td><td>1650000</td><td>108000000</td><td>109650000</td></tr>
<tr><td> 60%</td><td>1800000</td><td> 96000000</td><td> 97800000</td></tr>
<tr><td> 65%</td><td>1950000</td><td> 84000000</td><td> 85950000</td></tr>
<tr><td> 70%</td><td>2100000</td><td> 72000000</td><td> 74100000</td></tr>
<tr><td> 75%</td><td>2250000</td><td> 60000000</td><td> 62250000</td></tr>
<tr><td> 80%</td><td>2400000</td><td> 48000000</td><td> 50400000</td></tr>
<tr><td> 85%</td><td>2550000</td><td> 36000000</td><td> 38550000</td></tr>
<tr><td> 90%</td><td>2700000</td><td> 24000000</td><td> 26700000</td></tr>
<tr><td> 95%</td><td>2850000</td><td> 12000000</td><td> 14850000</td></tr>
<tr><td>100%</td><td>3000000</td><td>        0</td><td>  3000000</td></tr>
</table>

<image id="6705" original="no" />
<p-center><i>Závislost celkového poètu taktù nutných pro pøeètení jednoho milionu adres na efektivitì vyrovnávací pamìti první úrovnì (zjednodu¹ený pøíklad)</i></p-center>

<p>Jednou z&nbsp;podmínek pro dosa¾ení co nejvìt¹í efektivity vyrovnávacích
pamìtí je <i>lokalita dat</i> (pro datové cache) èi <i>lokalita programového
kódu</i> (pro instrukèní cache). Této ¾ádoucí vlastnosti lze dosáhnout vhodným
naprogramováním aplikace, vìt¹inou v¹ak vyplývá u¾ ze samotné podstaty øe¹eného
problému &ndash; programy obsahují vlo¾ené (nìkdy ne explicitnì zapsané)
programové smyèky, které po pøekladu pøímo vedou k&nbsp;lokalitì programového
kódu a ve velkém mno¾ství pøípadù se zpracovávají neustále ta stejná data,
která se v&nbsp;ideálním pøípadì mohou celá vlo¾it do datové vyrovnávací pamìti
a tím znaèným zpùsobem urychlit bìh programu díky sní¾enému mno¾ství pøenosù
z&nbsp;operaèní pamìti do vyrovnávací pamìti a zpìt. Vlastnost lokality se
v&nbsp;literatuøe oznaèuje jako <i>pravidlo 80-20</i>, popø.&nbsp;<i>pravidlo
90-10</i>, které lze vyjádøit i slovnì: <i>80% èasu stráví program pouze ve 20%
kódu</i>. Pokud by tato pravidla nebyla platná (napøíklad by byly jednotlivé
instrukce programu v&nbsp;operaèní pamìti &bdquo;rozházeny&ldquo; zcela
náhodnì), ztrácelo by pou¾ití vyrovnávacích pamìtí svùj význam.</p>



<p><a name="k02"></a></p>
<h1>2. Struktura údajù ulo¾ených ve vyrovnávací pamìti</h1>

<p>Ji¾ minule jsme si øekli, ¾e data jsou ve vyrovnávací pamìti ulo¾ena po
blocích pevné délky. Tyto bloky se nazývají <i>lines</i>, popø.&nbsp;<i>cache
lines</i>. Ka¾dý blok má kapacitu dosahující vìt¹inou 32 nebo 64 bytù
(tj.&nbsp;256 nebo 512 bitù). Napøíklad vyrovnávací pamì» o kapacitì 512 kB a
velikosti bloku 32 bytù obsahuje celkem 16384 blokù. Ke ka¾dému bloku je
pøidána dal¹í informaèní struktura (tj.&nbsp;pamì»ové buòky) obsahující index
tohoto bloku v&nbsp;hlavní pamìti (jedná se o adresu bez ni¾¹ích <i>n</i> bitù,
kde <i>n</i> odpovídá velikosti bloku a ¹íøce zpracovávaného slova), popø. i
dal¹í informace, napøíklad o tom, kolikrát byl tento blok pou¾it pøi ètení èi
zápisu dat, zda se jedná o &bdquo;¹pinavý&ldquo; (<i>dirty</i>) blok, jeho¾
obsah musí být v&nbsp;budoucnu ulo¾en do hlavní pamìti atd. Tyto doplòující
informace se oznaèují jako <i>tag</i> a jejich délka je rùzná podle konkrétní
architektury vyrovnávací pamìti (typicky se jedná o hodnotu 32 bitù, ale mù¾e
být i odli¹ná).</p>

<p>Nutnost ulo¾ení doplòujících informací ke ka¾dému bloku ve vyrovnávací
pamìti je jeden z&nbsp;hlavních dùvodù, proè se ve vyrovnávacích pamìtech
pou¾ívají bloky o kapacitì vìt¹í ne¾ jedno adresovatelné slovo &ndash; i pro
samotný <i>tag</i> je toti¾ nutné vyhradit èást kapacity vyrovnávací pamìti a
kdyby byly bloky pøíli¹ malé, zabraly by jejich <i>tagy</i> zbyteènì mnoho
drahého místa v&nbsp;pamì»ových buòkách, nehledì na to, ¾e spolu se sni¾ující
se velikostí blokù stoupá poèet bitù nutných pro ulo¾ení jeho indexu (adresy)
v&nbsp;operaèní pamìti (tím se zvìt¹uje poèet bitù nutných pro ulo¾ení ka¾dého
tagu). Souèasné pamìti DDR a DDR2 navíc obsahují ve svém pøenosovém protokolu
pøíkazy, kterými je mo¾né provést blokový pøesun (<i>burst read, burst
write</i>), jeho¾ délka v&nbsp;ideálním pøípadì odpovídá právì velikosti bloku
vyrovnávací pamìti. Pøi tomto pøesunu se zdrojová èi cílová adresa pøená¹í
pouze jedenkrát, co¾ samozøejmì celý pøenos urychluje. Pokud je ¹íøka datové
sbìrnice 64 bitù (DDR), je pro pøesun celého bloku o délce 64 bytù zapotøebí
vykonat 64&times;8/64=8 ètecích èi zápisových operací.</p>



<p><a name="k03"></a></p>
<h1>3. Asociativita vyrovnávací pamìti</h1>

<p><i>Asociativita vyrovnávací pamìti</i> zjednodu¹enì øeèeno urèuje, jakým
zpùsobem mohou být mapovány bloky z&nbsp;operaèní pamìti do blokù v&nbsp;pamìti
vyrovnávací. Obecnì toti¾ <strong>ne</strong>platí, ¾e jakýkoli blok
z&nbsp;operaèní pamìti mù¾e být ulo¾en kdekoli v&nbsp;pamìti vyrovnávací
&ndash; tuto na první pohled u¾iteènou vlastnost je sice mo¾né zaruèit, ov¹em
za cenu zpomalení práce vyrovnávací pamìti a zvý¹ené slo¾itosti logických
obvodù, které práci vyrovnávacích pamìtí øídí. Ji¾ minule jsme si uvádìli
jednoduchý pøíklad konfigurace poèítaèe s&nbsp;64 MB operaèní pamìti, 512 kB
vyrovnávací pamìti a velikosti bloku 32 bytù: vyrovnávací pamì» mù¾e pojmout
16384 blokù (<i>512&times;2<sup>10</sup>/32</i>), operaèní pamì» je rozdìlena
do 2097152 blokù (<i>64&times;2<sup>20</sup>/32</i>). Pro rozli¹ení onìch
2097152 blokù je zapotøebí 21 bitù, proto¾e platí <i>2<sup>21</sup>=2097152</i>
(nebo také se znalostí výpoètu logaritmu o libovolném základu
<i>log(2097152)/log(2)=ln(2097152)/ln(2)=21</i>), co¾ je také minimální
teoretická ¹íøka <i>tagu</i> ka¾dého bloku (pro jednoduchost pøedpokládejme, ¾e
tagy jsou ulo¾eny mimo onìch 512 kB vyrovnávací pamìti, co¾ je mnohdy
pravda.</p>

<p>Existují rùzné míry asociativity vyrovnávací pamìti, z&nbsp;nich¾ ty
nejtypiètìj¹í jsou popsány v&nbsp;následujících kapitolách.</p>



<p><a name="k04"></a></p>
<h1>4. Pøímo mapovaná vyrovnávací pamì»</h1>

<p>V&nbsp;pøípadì <strong>pøímo mapované vyrovnávací pamìti</strong> (<i>direct
mapped cache</i>) se jedná o implementaènì nejjednodu¹¹í strukturu
vyrovnávacích pamìtí, ve které se ji¾ pøímo z&nbsp;indexu bloku
(tj.&nbsp;nejvy¹¹ích bitù adresy) urèuje, ve kterém místì se blok mù¾e nacházet
ve vyrovnávací pamìti &ndash; konkrétnì se jedná o jedno jediné místo vypoètené
pomocí vztahu <i>index modulo n</i>, kde <i>n</i> je celkový poèet blokù, které
vyrovnávací pamì» obsahuje. Vý¹e uvedený vztah se samozøejmì v&nbsp;praxi
nemusí poèítat, proto¾e poèet blokù ve vyrovnávací pamìti je roven celoèíselné
mocninì dvou, tak¾e nejni¾¹ích <i>x</i> bitù indexu bloku v&nbsp;operaèní
pamìti pøímo urèuje umístìní bloku v&nbsp;pamìti vyrovnávací (samozøejmì platí
<i>2<sup>x</sup>=n</i>). Takto zkonstruovaná vyrovnávací pamì» je pøi výbìru
blokù velmi rychlá, ov¹em omezení daná zpùsobem mapování blokù jsou nejvìt¹í:
dva bloky, jejich¾ indexy se li¹í o celoèíselný násobek <i>n</i> nemohou být
souèasnì ve vyrovnávací pamìti umístìny, co¾ mù¾e vést k&nbsp;relativnì vysoké
míøe <i>cache miss</i> a tím pádem i k&nbsp;ni¾¹í celkové efektivitì.</p>



<p><a name="k05"></a></p>
<h1>5. Plnì asociativní vyrovnávací pamì»</h1>

<p><strong>Plnì asociativní vyrovnávací pamì»</strong> (<i>fully associative
cache </i>) je ve své podstatì pravým opakem pøímo mapované vyrovnávací pamìti.
Zatímco u pøedchozí konstrukce byla pozice bloku pevnì dána jeho indexem, u
plnì asociativní pamìti prakticky neexistuje ¾ádné omezení, co se týèe mapování
blokù (jediným omezením je, aby se blok ve vyrovnávací pamìti nacházel pouze
v&nbsp;jedné kopii, co¾ je logické jak kvùli koherenci dat, tak i
z&nbsp;hlediska co nejlep¹ího vyu¾ití kapacity této pamìti). Vzhledem
k&nbsp;minimálnímu omezení mapování blokù (a tím i nejvìt¹ím mo¾nostem, které
má <i>alokátor</i> blokù) se u tohoto typu konstrukce vyrovnávací pamìti
dosahuje nejni¾¹í míry <i>cache miss</i>, tak¾e by se zdálo, ¾e se tato
konstrukce pou¾ívá nejèastìji. Ve skuteènosti tomu tak v¾dy není, proto¾e
v&nbsp;takto vytvoøené vyrovnávací pamìti je nutné implementovat rychlý
mechanismus mapování a hledání blokù, co¾ vìt¹inou vede na nutnost pou¾ití
nìjakého typu <i>CAM (Content Addressable Memory)</i>, tj.&nbsp;pamìti
adresované obsahem (zde je obsahem my¹len index bloku). Tyto obvody jsou drahé
a také relativnì pomalé, proto plnì asociativní vyrovnávací pamì» není obecnì
tak rychlá, jako pøímo mapovaná pamì».</p>



<p><a name="k06"></a></p>
<h1>6. Dvoucestná èi ètyøcestná asociativní vyrovnávací pamì»</h1>

<p>Tak, jak je u¾ v&nbsp;IT i jiných disciplínách skoro pravidlem, je
v&nbsp;praxi výhodnìj¹í nepou¾ívat ¾ádnou z&nbsp;vý¹e uvedených limitních
pøípadù asociativity (pøímé mapování, tj.&nbsp;nultá míra asociativity versus
plná asociativita), ale spí¹e nìjaký vhodnì navr¾ený kompromis. Ten je
pøedstavován <strong>dvoucestnou asociativní vyrovnávací pamìtí</strong>
(<i>2-way set associative cache</i>) popø. <strong>ètyøcestnou asociativní
vyrovnávací pamìtí</strong> (<i>4-way set associative cache</i>). Název tìchto
konstrukcí ji¾ naznaèuje jejich základní vlastnosti. U dvoucestné asociativní
vyrovnávací pamìti je mo¾né ka¾dý blok z&nbsp;operaèní pamìti mapovat do dvou
míst v&nbsp;pamìti vyrovnávací; ètyøcestná asociativní vyrovnávací pamì»
naproti tomu umo¾òuje jeden blok mapovat do ètyø míst (samozøejmì ne do v¹ech
souèasnì, alokátor si musí vybrat na základì zvolené strategie). Na první
pohled je výbìr pouhých dvou èi ètyø míst oproti místu jednomu (jak tomu bylo
v&nbsp;pøípadì pøímo mapované pamìti) bezvýznamný, v&nbsp;praxi se v¹ak
ukazuje, ¾e se výraznì sni¾uje míra <i>cache miss</i>. Ani konstrukce tìchto
pamìtí není slo¾itá (pùvodní CAM se redukuje na relativnì jednoduchý
rozhodovací obvod), proto se tyto pamìti pou¾ívají pomìrnì èasto.</p>

<img src="http://upload.wikimedia.org/wikipedia/commons/9/93/Cache%2Cassociative-fill-both.png" /><br />
<p-center><i>Pøímo mapovaná a dvoucestná vyrovnávací pamì»</i></p-center>



<p><a name="k07"></a></p>
<h1>7. Strategie pøidìlování blokù</h1>

<p>Ve chvíli, kdy mikroprocesor potøebuje provést ètení èi zápis dat do bloku
<strong>X</strong>, který se nenachází ve vyrovnávací pamìti (jinými slovy
nastane <i>cache miss</i>), pou¾ije se takzvaný <i>alokátor blokù</i>, co¾ je
logický obvod, který na základì nìkolika kritérií rozhodne, jakým zpùsobem se
po¾adovaný blok <strong>X</strong> do vyrovnávací pamìti dostane. Nejjednodu¹¹í
práci má alokátor v&nbsp;pøípadì, ¾e vyrovnávací pamì» je pøímo mapovaná
&ndash; index bloku <strong>X</strong> v&nbsp;tomto pøípadì pøímo urèuje, na
které místo ve vyrovnávací pamìti se blok <strong>X</strong> má naèíst. Pùvodní
blok <strong>Y</strong> je (v&nbsp;pøípadì, ¾e byl zmìnìn, tj.&nbsp;byl u nìj
nastaven pøíznakový bit <i>dirty</i>) ulo¾en zpìt do operaèní pamìti (provádí
se <i>burst write</i> neboli blokový zápis do operaèní pamìti) a poté je do
stejného místa vyrovnávací pamìti naèten po¾adovaný blok <strong>X</strong>
(provádí se <i>burst read</i> neboli blokové ètení z operaèní pamìti). Toto
øe¹ení je nejrychlej¹í z&nbsp;hlediska práce alokátoru, ov¹em poèet blokových
pøenosù z a do operaèní pamìti je pomìrnì velký &ndash; viz <a
href="#k04">ètvrtá kapitola</a>.</p>

<p>Ponìkud více práce èeká na <i>alokátor blokù</i> v&nbsp;pøípadì, ¾e je
pou¾ita dvoucestná, ètyøcestná èi dokonce plnì asociativní vyrovnávací pamì».
Celou èinnost si vysvìtlíme na dvoucestné asociativní vyrovnávací pamìti,
problém je v¹ak stejný i v&nbsp;ostatních pøípadech. U dvoucestné pamìti musí
alokátor rozhodnout, který z&nbsp;blokù <strong>Y<sub>1</sub></strong> èi
<strong>Y<sub>2</sub></strong> bude ulo¾en zpìt do operaèní pamìti, aby na
stejné místo mohl být naèten po¾adovaný blok <strong>X</strong>. Rozhodnutí
mezi blokem <strong>Y<sub>1</sub></strong> a <strong>Y<sub>2</sub></strong> je
provedeno na základì strategie pøidìlování blokù, která dosti podstatným
zpùsobem ovlivòuje efektivitu vyrovnávací pamìti (nejvíce je to patrné u plnì
asociativní pamìti). Pravdìpodobnì nejvíce známá je strategie, pøi které je
&bdquo;zahozen&ldquo; ten blok <strong>Y<sub>n</sub></strong>, který byl
pou¾íván ménì èasto, ne¾ ostatní kandidáti na &bdquo;zahození&ldquo;
(&bdquo;zahození&ldquo; v&nbsp;tomto pøípadì mù¾e znamenat i ulo¾ení do
operaèní pamìti v&nbsp;pøípadì, ¾e byl obsah bloku zmìnìn). Tato strategie se
oznaèuje zkratkou <i>LRU (Least Recently Used)</i> a vy¾aduje, aby se u ka¾dého
bloku ulo¾eného ve vyrovnávací pamìti udr¾ovaly i informace o posledním pou¾ití
tohoto bloku (jedná se o celé èíslo).</p>

<p>Podobnou strategií je strategie nazvaná <i>LFU (Least Frequently Used)</i>,
u ní¾ se ke ka¾dému bloku pamatuje informace o tom, jak èasto byl blok
po¾adován. Mo¾né jsou i kombinace, napøíklad u <i>Adaptive Replacement Cache
(ARC)</i>, ve které se vhodným zpùsobem kombinuje strategie <i>LRU</i> a
<i>LFU</i> s&nbsp;tím cílem, aby se efektivita vyu¾ití vyrovnávací pamìti co
nejvíce zvý¹ila i v&nbsp;pøípadì dat, u nich¾ jednotlivé predikce nepracují
optimálnì (LRU i LFU jsou toti¾ ve skuteènosti jednoduché prediktory, které se
sna¾í odhadnout, které bloky budou v&nbsp;budoucnost pou¾ity ménì èastìji a
které èastìji).</p>



<p><a name="k08"></a></p>
<h1>8. Literatura a odkazy na Internetu</h1>

<ol>

<li>Pavel Valá¹ek, Roman Loskot: <i>Polovodièové pamìti</i>,<br />
BEN - Technická literatura, Praha 1998, ISBN-80-86056-18-X</li>

<li>Budínský J.: <i>Polovodièové pamìti a jejich pou¾ití</i>,<br />
SNTL, Praha 1977</li>

<li>Budínský J.: <i>Polovodièové pamìti - Názvosloví a definice</i>,<br />
TESLA VÚST, Praha 1980</li>

<li>Janù K.: <i>Pamìti a øadièe - èást I.</i>,<br />
ÈSVTS, Kni¾nice mikroprocesorová technika, Praha 1982</li>

<li><i>Great Microprocessors of the Past and Present (V 13.0.0)</i></li>

<li><a href="http://www.pcguide.com/ref/mbsys/cache/funcMapping-c.html">Cache Mapping and Associativity</a> (http://www.pcguide.com/ref/mbsys/cache/funcMapping-c.html)</li>

<li><a href="http://en.wikipedia.org/wiki/Cache">Wikipedia: Cache</a> (http://en.wikipedia.org/wiki/Cache)</li>

<li><a href="http://en.wikipedia.org/wiki/CPU_cache">Wikipedia: CPU cache</a> (http://en.wikipedia.org/wiki/CPU_cache)</li>

<li><a href="http://en.wikipedia.org/wiki/Cache_algorithms">Wikipedia: Cache algorithms</a> (http://en.wikipedia.org/wiki/Cache_algorithms)</li>

<li><a href="http://lwn.net/Articles/252125/">Memory part 2: CPU caches</a> (http://lwn.net/Articles/252125/)</li>

<li><a href="http://www.cs.wisc.edu/multifacet/misc/spec2000cache-data/">Cache Performance for SPEC CPU2000 Benchmarks</a> (http://www.cs.wisc.edu/multifacet/misc/spec2000cache-data/)</li>

<li><a href="http://www.cs.umd.edu/class/spring2003/cmsc311/Notes/Memory/fully.html">Fully Associative Cache</a> (http://www.cs.umd.edu/class/spring2003/cmsc311/Notes/Memory/fully.html)</li>

</ol>



<p><a name="k09"></a></p>
<h1>9. Obsah dal¹ího pokraèování seriálu</h1>

<p>V&nbsp;následující èásti tohoto seriálu si popí¹eme práci vyrovnávacích
pamìtí v&nbsp;systémech, které obsahují více relativnì samostatnì pracujících
procesorových jednotek nebo vìt¹í mno¾ství procesorových jader (<i>dual core,
quad core</i>). Na tìchto systémech je pou¾ití vyrovnávacích pamìtí takøka
nezbytné, proto¾e jinak by byl celý výpoèetní výkon ztracen pøi pøístupu do
operaèní pamìti. Také se budeme zabývat tím, jakým zpùsobem se vyrovnávací
pamìti a fronty instrukcí musí zkonstruovat v&nbsp;pøípadì, ¾e je povolena
modifikace spustitelného kódu (<i>self-modyfying code, code morphing</i>),
tj.&nbsp;programový zásah do sekvence operaèních kódù. Jedná se o pomìrnì
aktuální téma, zejména pøi pou¾ití dnes velmi èasto pou¾ívaných programovacích
jazykù, jejich¾ virtuální stroje obsahují <i>JIT (Just in Time)</i> pøekladaè.
Jedná se jak o Javu èi platformu .NET, tak i o nìkteré implementace Lispu.</p>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2008</small></p>
</body>
</html>

