<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Èinnost mikroprocesoru bez záhad, aneb jde to i bez trpaslíkù</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Èinnost mikroprocesoru bez záhad, aneb jde to i bez trpaslíkù</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o architekturách poèítaèù si vysvìtlíme, jakým zpùsobem pracuje mikroprocesor. Pøedev¹ím si (s vyu¾itím animací) uká¾eme postup naèítání instrukcí z operaèní pamìti a jejich provádìní za pomoci øadièe, aritmeticko-logické jednotky, pracovních registrù a pomocných registrù.</p>



<h1>Obsah</h1>
<p>
<a href="#k01">1. Èinnost mikroprocesoru bez záhad, aneb jde to i bez trpaslíkù</a><br />
<a href="#k02">2. Hodinový signál</a><br />
<a href="#k03">3. Inicializace mikroprocesoru pomocí signálu <strong>Reset</strong></a><br />
<a href="#k04">4. Naèítání instrukcí z&nbsp;operaèní pamìti a role registru <strong>PC</strong></a><br />
<a href="#k05">5. Operaèní kódy instrukcí (opkódy), strojový kód a assembler</a><br />
<a href="#k06">6. Podrobnìj¹í popis instrukèního souboru</a><br />
<a href="#k07">7. Instrukce pro pøesuny dat mezi registry</a><br />
<a href="#k08">8. Obsah následující èásti tohoto seriálu</a><br />
</p>



<p><a name="k01"></a></p>
<h1>1. Èinnost mikroprocesoru bez záhad, aneb jde to i bez trpaslíkù</h1>

<p>V&nbsp;pøedchozí èásti tohoto seriálu jsme si ukázali schéma velmi
jednoduchého "uèebního" mikroprocesoru, na kterém si nyní budeme vysvìtlovat
jednotlivé funkce, které mikroprocesory pøi své práci provádí. Také jsme si
vypsali takzvanou <i>instrukèní sadu</i> tohoto mikroprocesoru,
tj.&nbsp;<i>operaèní kódy</i> (opkódy) instrukcí spolu s&nbsp;jejich
mnemotechnickými zkratkami, které ná¹ jednoduchý procesor doká¾e zpracovat.
Dnes ji¾ zaèneme s&nbsp;podrobnìj¹ím popisem jednotlivých instrukcí, vèetnì
vysvìtlení zpùsobu provádìní tìchto instrukcí uvnitø mikroprocesoru, za vyu¾ití
v¹ech interních blokù, které se v&nbsp;nìm nachází,
tj.&nbsp;aritmeticko-logické jednotky, mikroprogramového øadièe, pracovních
registrù, pomocných registrù a interní sbìrnice. Prùbìh jednotlivých krokù bude
doplnìn animacemi; ov¹em mo¾ná budete zklamáni, proto¾e se v&nbsp;nich ¾ádní
trpaslíci, kterými se tak èasto zaklínají nìkteøí u¾ivatelé (a také pár
uèitelù), nebudou vyskytovat. Uèební mikroprocesor má následující
architekturu:</p>

<image id="5994" />
<p-center>Interní schéma "uèebního" mikroprocesoru</p-center>



<p><a name="k02"></a></p>
<h1>2. Hodinový signál</h1>

<p>Ka¾dá instrukce, kterou mikroprocesor provádí, je internì rozlo¾ena do jedné
nebo nìkolika jednodu¹¹ích akcí, napøíklad do pøenosu dat mezi pracovním
registrem a pomocným registrem, vykonáním aritmetické èi logické operace
v&nbsp;ALU, zvý¹ení hodnoty registru PC o jednièku, èi zápisu dat do operaèní
pamìti. Jednotlivé akce musí být vzájemnì synchronizovány, k&nbsp;èemu¾ slou¾í
takzvané <i>hodinové signály</i> pøivádìné do mikroprocesoru pomocí vstupu
nazývaného celkem pøíhodnì <strong>Clock</strong>,
popø.&nbsp;<strong>CLK</strong> èi <strong>&phi;</strong>. Samotné generování
hodinového signálu s&nbsp;obdélníkovým prùbìhem (jedná se tedy o binární
signál) je provádìno oscilátorem postaveným napøíklad na astabilním èi
monostabilním klopném obvodu, Schmittovì klopném obvodu doplnìném krystalem,
popø.&nbsp;také na oscilátorech harmonických signálù doplnìných Schmittovým
klopným obvodem, který z&nbsp;pùvodnì sinusových prùbìhù vytvoøí ¾ádoucí
obdélníkový signál. Nejjednodu¹¹ím generátorem je Schmittùv klopný obvod
doplnìný o zpìtnovazební odpor a kondenzátor zapojený mezi vstupní signál a
zem. Hodnota R a C potom urèuje periodu:</p>

<image id="5995" />
<p-center>Velmi jednoduchý oscilátor zalo¾ený na Schmittovì klopném obvodu</p-center>

<p>Nìkteré mikroprocesory a zejména mikroøadièe mají oscilátor zabudovaný pøímo
na èipu a vìt¹inou pro svoji èinnost vy¾adují pouze pøipojení externího
krystalu pro dosa¾ení pøesné taktovací frekvence &ndash; krystal je toti¾
pomìrnì velká a pøitom cizorodá souèástka (navíc s&nbsp;mechanicky namáhanými
èástmi), která se pøímo do mikroprocesoru, tj.&nbsp;na vlastní polovodièový èip
¹patnì integruje. Star¹í mikroprocesory vy¾adovaly více hodinových signálù
oznaèovaných napøíklad &phi;<sub>1</sub> a &phi;<sub>2</sub>, které byly
internì pou¾ity v&nbsp;øadièi pro generování pøíkazù pomocí klopných obvodù
typu JK.</p>

<p>Na tomto místì je vhodné podotknout, ¾e samotná frekvence hodinového signálu
vcelku nic nevypovídá o výkonnosti mikroprocesoru, tj.&nbsp;mù¾e se stát, ¾e
mikroprocesor s&nbsp;frekvencí hodinového signálu 200&nbsp;MHz bude výkonnìj¹í,
ne¾ mikroprocesor s&nbsp;frekvencí 500&nbsp;MHz. V&nbsp;úvahu je nutné brát jak
¹íøku zpracovaných dat, tak i prùmìrný poèet strojových instrukcí zpracovaných
v&nbsp;jednom taktu (popø.&nbsp;naopak poèet taktù nutných pro zpracování jedné
instrukce), dostupnost nìkterých operací, samotnou architekturu pou¾itého
mikroprocesoru (vektorové zpracování instrukcí, VLIW, SIMD) atd.</p>

<image id="5996" />
<p-center>Stále pomìrnì jednoduchý (a nepøesný) oscilátor vytvoøený z&nbsp;logických hradel</p-center>

<p>Navíc se ukazuje, ¾e sázka nìkterých firem na uvádìní výkonu svých
mikroprocesorù pomocí hodnoty frekvence hodinového signálu (a nikoli na jiných
jednotkách, napøíklad syntetizovaných benchmarcích) se èasto obrací proti svým
tvùrcùm, zejména pøi nástupu mikroprocesorù s&nbsp;více jádry (<i>cores</i>)
&ndash; to je v¹ak téma, kterým se budeme zabývat v&nbsp;nìkteré z&nbsp;dal¹ích
èástí tohoto seriálu (ostatnì se ukazuje, ¾e lidé èasto a rádi porovnávají
vlastnosti rùzných výrobkù pomocí jediného èísla, které v¹ak vùbec nemusí
výrobek dostateènì popisovat: výkon motorù v&nbsp;automobilech se èasto uvádí
pouze v&nbsp;KW, vlastnosti fotoaparátu pouze údajem o poètu megapixelù
atd.).</p>

<image id="5997" />
<p-center>Dal¹í mo¾nosti zapojení jednoduchých oscilátorù (bez krystalu)</p-center>



<p><a name="k03"></a></p>
<h1>3. Inicializace mikroprocesoru pomocí signálu <strong>Reset</strong></h1>

<p>Mikroprocesor je velmi slo¾itý integrovaný obvod, který uvnitø obsahuje
pomìrnì velké mno¾sví navzájem propojených kombinaèních i sekvenèních logických
obvodù. Pøi zapnutí mikroprocesoru, tj.&nbsp;pøivedení napájecího napìtí a
hodinového signálu, se jednotlivé obvody uvniø mikroprocesoru obecnì nachází
v&nbsp;neurèeném stavu. Samozøejmì je nutné, aby se mikroprocesor (jako celek)
po zapnutí dostal do pøesnì stanoveného výchozího stavu. Vìt¹inou také
potøebujeme mikroprocesor kdykoli restartovat, tj.&nbsp;dostat ho do výchozího
stavu, ve kterém se nacházel po zapnutí. K&nbsp;tìmto funkcím slou¾í signál
<strong>Reset</strong>, na který reaguje øadiè mikroprocesoru. U jednodu¹¹ích
poèítaèù bývá signál <strong>Reset</strong> generován tlaèítkem doplnìným o
monostabilní integrovaný obvod, který zajistí automatické vygenerování tohoto
signálu po pøipojení napájení (vìt¹ina mikroprocesorù toti¾ vy¾aduje, aby
signál <strong>Reset</strong> trval urèitou minimální dobu, napøíklad deset
taktù hodinového signálu).</p>

<p>Ve chvíli, kdy øadiè detekuje signál <strong>Reset</strong>, provede nìkolik
operací. Pøedev¹ím sám sebe nastaví do výchozího stavu, ve kterém mù¾e na
signál <strong>Reset</strong> adekvátnì reagovat. Posléze vy¹le na interní
sbìrnici mikroprocesoru sekvenci øídicích signálù, pomocí kterých nastaví obsah
pracovních registrù na po¾adované výchozí hodnoty. Pracovní registry
<strong>A</strong> a <strong>B</strong> jsou vynulovány, oba dva pøíznaky,
tj.&nbsp;<strong>Carry flag</strong> a <strong>Zero flag</strong> jsou takté¾
vynulovány, programový èítaè <strong>PC</strong> je nastaven na adresu 0x0000,
tj.&nbsp;na první buòku operaèní pamìti a ukazatel na vrchol zásobníku
<strong>SP</strong> naopak na adresu 0xffff, tj.&nbsp;poslední buòku operaèní
pamìti.</p>

<p>Poznámka: ve¹keré adresy i operaèní kódy instrukcí budou zapisovány
v&nbsp;hexadecimální soustavì, pøièem¾ budu dodr¾ovat "céèkovský" zpùsob zápisu
s&nbsp;prefixem 0x. Vzhledem k&nbsp;¹estnáctibitové ¹íøce v¹ech registrù
nesoucích adresu, tj.&nbsp;registrù <strong>PC</strong> a <strong>SP</strong>,
je adresový rozsah mikroprocesoru roven 0-2<sup>16</sup>-1,
tj.&nbsp;hexadecimálnì 0x0000 a¾ 0xffff.</p>

<image id="5998" />
<p-center>Reakce øadièe mikroprocesoru na pøíchod signálu <strong>Reset</strong></p-center>



<p><a name="k04"></a></p>
<h1>4. Naèítání instrukcí z&nbsp;operaèní pamìti a role registru <strong>PC</strong></h1>

<p>Jeliko¾ je ná¹ ukázkový mikroprocesor postaven na von Neumannovì
architektuøe, je celá jeho èinnost øízená programem zapsaným v&nbsp;operaèní
pamìti. Mikroprocesor je pomocí <i>adresové sbìrnice</i>, <i>datové
sbìrnice</i> a <i>øídicí sbìrnice</i> pøipojený k&nbsp;pamì»ovému subsystému,
tj.&nbsp;jednomu èi nìkolika èipùm, na nich¾ je vytvoøena pamì» typu RWM/RAM
(pro ètení i zápis) a pamì» typu ROM (pouze pro ètení). O pamì»ovém subsystému
a rùzných technologiích pamìtí si je¹tì nìco øekneme v&nbsp;navazujících
èástech tohoto seriálu, dnes si v¹ak musíme ukázat, jakým zpùsobem
mikroprocesor mù¾e naèítat údaje ulo¾ené v&nbsp;tìchto pamìtech, pøedev¹ím nás
zajímá ètení programového kódu, tj.&nbsp;jak instrukcí tak i dat, které jsou
k&nbsp;instrukcím pøidru¾ena. Po stránce vnìj¹í komunikace mikroprocesoru
s&nbsp;pamìtí je situace jednoduchá: procesor na adresovou sbìrnici zapí¹e
po¾adovanou adresu, ze které potøebuje instrukci èíst a na øídicí sbìrnici
po¹le pøíkaz pro ètení (R/Read). Po pøedem známé dobì pamì» vypí¹e po¾adovaný
údaj na datovou sbìrnici, odkud ho mikroprocesor pøeète.</p>

<p>Nyní tedy zbývá vyøe¹it, jaké adresy bude mikroprocesor zapisovat na
adresovou sbìrnici. Von Neumann mimo jiné pøedepsal, ¾e procesor má instrukce
vykonávat postupnì tak, jak jsou zapsány v&nbsp;pamìti a jediný zpùsob, jak
tuto posloupnost instrukcí zmìnit, je pou¾ití pøíkazù pro skoky
(popø.&nbsp;pou¾ití pøeru¹ení). Mikroprocesor si pamatuje adresu instrukce,
která se má pøeèíst z&nbsp;operaèní pamìti, v&nbsp;registru nazvaném
<strong>PC</strong> (<i>Program Counter</i>). V&nbsp;pøípadì, ¾e není pou¾ita
instrukce skoku, tak se hodnota tohoto registru postupnì zvy¹uje o hodnotu
odpovídající délce právì pøeètené instrukce. Jinými slovy &ndash; pokud má
instrukce délku jednoho bytu, je <strong>PC</strong> zvý¹en o jednièku, pokud
je instrukce del¹í, napøíklad dva byty, je <strong>PC</strong> zvý¹en o dvojku.
Poèáteèní hodnota <strong>PC</strong> po restartu mikroprocesoru je rovna nule,
tj.&nbsp;mikproprocesor zaèíná naèítat program od zaèátku (nulté adresy)
operaèní pamìti (jiné mikroprocesory v¹ak mohou pou¾ívat odli¹nou startovací
adresu).</p>

<p>Na následující animaci je ukázáno, jakým zpùsobem mikroprocesor zvy¹uje
hodnotu registru <strong>PC</strong> o jednièku. Vzhledem k&nbsp;tomu, ¾e je
ná¹ mikroprocesor opravdu velmi jednoduchý, neobsahuje specializovaný obvod,
který by toto zvy¹ování provádìl autonomnì (napøíklad paralelnì s&nbsp;jinou
operací), ale je zapotøebí pou¾ít univerzální ALU, která obsahuje po¾adovanou
instrukci <strong>INC</strong>, tj.&nbsp;zvý¹ení hodnoty prvního pomocného
registru o jednièku. Toto øe¹ení je sice jednoduché a ¹etøí zdroje
(tranzistory, hradla), na druhou stranu v¹ak mù¾e znamenat zpomalení provádìní
instrukcí, co¾ nás v¹ak prozatím nemusí pøíli¹ trápit (také nás netrápí
zbyteèné "rozøedìní" operaèních kódù instrukcí a jejich adresních èástí, jak si
ostatnì uká¾eme v&nbsp;následujících tøech kapitolách).</p>

<image id="5999" />
<p-center>Zpùsob zvý¹ení hodnoty registru <strong>PC</strong> o jednièku pomocí ALU</p-center>



<p><a name="k05"></a></p>
<h1>5. Operaèní kódy instrukcí (opkódy), strojový kód a assembler</h1>

<p>Mikroprocesor zpracovává program zapsaný ve <i>strojovém jazyku</i> neboli
<i>strojovém kódu</i>. Jedná se o binární formát slo¾ený z&nbsp;jednotlivých
<i>operaèních kódù instrukcí</i> doplnìných o <i>adresní èást</i>,
popø.&nbsp;konstanty. Ka¾dý mikroprocesor, resp.&nbsp;ka¾dá navzájem
kompatibilní vývojová øada mikroprocesorù, má svùj vlastní strojový kód, který
není obecnì pøenositelný na ostatní mikroprocesory. Operaèní kód instrukce
jednoznaènì urèuje, jakou operaci má mikroprocesor provést, pomocí adresní
èásti se specifikuje, s&nbsp;jakými operandy (registry, místy pamìti,
periferními zaøízeními) se má daná operace provést a koneènì konstanty mohou
urèovat hodnotu, která se zùèastní aritmetické operace, absolutní èi relativní
adresu, na kterou se má provést skok, hodnotu posunu, která se pøiète
k&nbsp;adrese ulo¾ené v&nbsp;registru atd. Program zapsaný ve strojovém kódu
mù¾e vypadat po výpisu v&nbsp;hexadecimální soustavì a doplnìním sloupce
s&nbsp;adresami následovnì:</p>

<code-area>0000: B81300
0003: CD10
0005: 6800A0
0008: 07
0009: 33FF
000B: B106
000D: C706750100E0
0013: BE4001
0016: B520
0018: 33C0
001A: 8BE8
001C: 93
001D: 8BC5
001F: D3F8
0021: F7E8
0023: 50
0024: 8BC3
0026: D3F8
0028: F7E8
002A: 268905
002D: 8BC5
002F: D3F8
0031: C1FB05
</code-area>

<p>Co¾ zajisté není pøíli¹ èitelné. Z&nbsp;dùvodu snadnìj¹í tvorby programù byl
vyvinut <i>jazyk symbolických instrukcí</i> (JSI), nìkdy také nazývaný <i>jazyk
symbolických adres</i> (JSA), ov¹em nejèastìji se setkáme s&nbsp;ponìkud
nepøesným názvem <i>assembler</i> èi <i>assembly language</i>. Jedná se o
jazyk, ve kterém je program zapsán pomocí mnemotechnických zkratek instrukcí a
ne jejich èíselnými kódy. Také je mo¾né pou¾ívat takzvaná <i>návì¹tí</i>
(labels), co¾ jsou vlastnì pojmenované adresy, na kterých mù¾e le¾et buï
zaèátek nìjaké funkce, zpracovávaná data nebo cíl skoku. Kromì toho mnoho
assemblerù podporuje i pseudoinstrukce a také makra, která jsou mnohdy pomìrnì
vysokoúrovòová. Vý¹e uvedený program by v&nbsp;assembleru mikroprocesoru 80386
v&nbsp;¹estnáctibitovém re¾imu vypadal následovnì (v&nbsp;levé èásti je pro
porovnání zobrazen i strojový kód, který je generovaný z&nbsp;assemblerovského
zdrojového kódu):</p>

<code-area>0000: B81300                       mov       ax,00013
0003: CD10                         int       010
0005: 6800A0                       push      0A000
0008: 07                           pop       es
0009: 33FF                         xor       di,di
000B: B106                         mov       cl,006
000D: C706750100E0                 mov       w,[00175],0E000
0013: BE4001                       mov       si,00140
0016: B520                         mov       ch,020
0018: 33C0                         xor       ax,ax
001A: 8BE8                         mov       bp,ax
001C: 93                           xchg      bx,ax
001D: 8BC5                         mov       ax,bp
001F: D3F8                         sar       ax,cl
0021: F7E8                         imul      ax
0023: 50                           push      ax
0024: 8BC3                         mov       ax,bx
0026: D3F8                         sar       ax,cl
0028: F7E8                         imul      ax
002A: 268905                       mov       es:[di],ax
002D: 8BC5                         mov       ax,bp
002F: D3F8                         sar       ax,cl
0031: C1FB05                       sar       bx,005
</code-area>

<p>Ponìkud matoucí mù¾e být to, ¾e program napsaný v&nbsp;<i>assembleru</i> se
pøekládá pøekladaèem nazvaným <i>assembler</i>, v&nbsp;praxi v¹ak je
z&nbsp;okolností patrné, o èem se mluví: "pí¹u to v&nbsp;assembleru" vs.
"pøelo¾il jsem ten program assemblerem".</p>

<image id="6000" />
<p-center>Naètení operaèního kódu instrukce do øadièe</p-center>

<p>Na rozhraní mezi assemblerem a vy¹¹ími programovacími jazyky (napøíklad
Céèkem, Pascalem atd.) le¾í takzvaný <strong>autokód</strong>. Jedná se vlastnì
o velmi jednoduchý programovací jazyk, ve kterém je v¹ak mo¾né pou¾ívat pouze
ty objekty, se kterými se pracuje v&nbsp;samotném assembleru. Mj.&nbsp;to
znamená, ¾e sice existuje mo¾nost zápisu jednoduchých aritmetických výrazù:</p>

<code-area>A=A+B   (odpovídá add A, B v assembleru)
</code-area>

<p>nebo podmínek:</p>

<code-area>if A go to L1:L2:L3  (kdy¾ A&lt;0, skok na L1, kdy¾ A=0 skok na L2, jinak skok na L3)
</code-area>

<p>ale ¾ádné vy¹¹í operace èi datové typy ji¾ není mo¾né pou¾ít. Autokód se
v&nbsp;souèasnosti pøíli¹ èasto nepou¾ívá, místo toho se (v&nbsp;odùvodnìných
pøípadech) kombinuje zápis èásti programu v&nbsp;assembleru s&nbsp;programem
napsaným v&nbsp;nìkterém plnohodnotném vy¹¹ím programovacím jazyce, napøíklad
v&nbsp;céèku. V&nbsp;minulosti byla snaha o vytvoøení jakéhosi hybrida mezi
céèkem a assemblerem pro architekturu x86 &ndash; jednalo se o jazyk
<strong>C--</strong>, který byl pomìrnì vynalézavý, napøíklad znal operátor
&gt;&lt; &ndash; ov¹em dnes u¾ pravdìpodobnì není aktivnì vyvíjen (poslední
verzi si pamatuji je¹tì z&nbsp;dob DOSu).</p>



<p><a name="k06"></a></p>
<h1>6. Podrobnìj¹í popis instrukèního souboru</h1>

<p>V&nbsp;pøedchozí èásti tohoto seriálu byl uveden celý instrukèní soubor,
tj.&nbsp;sada instrukcí, kterou ná¹ ukázkový mikroprocesor doká¾e provádìt.
Jedná se o celkem 32 instrukcí rozdìlených do sedmi skupin:</p>

<table>
<tr><th>Kód instrukce (hex)</th><th>Mnemotechnická zkratka instrukce</th><th>Význam</th></tr>
<tr><th colspan="3">Aritmetické instrukce</th></tr>
<tr><td>00</td><td>ADD</td><td>souèet obsahu registrù A a B</td></tr>
<tr><td>01</td><td>ADC</td><td>souèet obsahu registrù s pøenosem</td></tr>
<tr><td>02</td><td>SUB</td><td>rozdíl obsahu registrù A a B</td></tr>
<tr><td>03</td><td>SBB</td><td>rozdíl obsahu registrù s výpùjèkou</td></tr>
<tr><td>04</td><td>INC</td><td>zvý¹ení obsahu registru A èi B o 1</td></tr>
<tr><td>05</td><td>DEC</td><td>sní¾ení obsahu registru A èi B o 1</td></tr>
<tr><th colspan="3">Logické instrukce</th></tr>
<tr><td>06</td><td>AND</td><td>operace bitového souèinu nad v¹emi korespondujícími bity registrù A a B</td></tr>
<tr><td>07</td><td>OR</td><td>operace bitového souètu nad v¹emi korespondujícími bity registrù A a B</td></tr>
<tr><td>08</td><td>XOR</td><td>operace bitové nonekvivalence nad v¹emi korespondujícími bity registrù A a B</td></tr>
<tr><td>09</td><td>COM</td><td>negace v¹ech bitù jednoho z registrù A èi B</td></tr>
<tr><th colspan="3">Posuvy a rotace</th></tr>
<tr><td>0a</td><td>RL</td><td>rotace obsahu registru A èi B doleva</td></tr>
<tr><td>0b</td><td>RLC</td><td>rotace obsahu registru A èi B doleva pøes pøíznak pøenosu</td></tr>
<tr><td>0c</td><td>RR</td><td>rotace obsahu registru A èi B doprava</td></tr>
<tr><td>0d</td><td>RRC</td><td>rotace obsahu registru A èi B doprava pøes pøíznak pøenosu</td></tr>
<tr><td>0e</td><td>ASR</td><td>aritmetický posun obsah registru A èi B doprava</td></tr>
<tr><th colspan="3">Testování a porovnání</th></tr>
<tr><td>0f</td><td>CMP</td><td>aritmetické porovnání obsahu registrù a ovlivnìní pøíznakù</td></tr>
<tr><td>10</td><td>TEST</td><td>bitové porovnání obsahu registrù a ovlivnìní pøíznakù</td></tr>
<tr><th colspan="3">Pøesuny mezi pamìtí a registry</th></tr>
<tr><td>11</td><td>LD</td><td>naètení konstanty èi obsahu adresy z pamìti do registru A èi B</td></tr>
<tr><td>12</td><td>ST</td><td>ulo¾ení obsahu registru A èi B na danou adresu pamìti</td></tr>
<tr><td>13</td><td>MOV</td><td>pøesun dat mezi registry</td></tr>
<tr><td>14</td><td>PUSH</td><td>ulo¾ení obsahu registru A èi B na zásobník</td></tr>
<tr><td>15</td><td>POP</td><td>obnovení obsahu registru A èi B ze zásobníku</td></tr>
<tr><th colspan="3">Skokové a návratové instrukce</th></tr>
<tr><td>16</td><td>JMP</td><td>nepodmínìný skok na zadanou adresu</td></tr>
<tr><td>17</td><td>CALL</td><td>volání podprogramu</td></tr>
<tr><td>18</td><td>RET</td><td>návrat z podprogramu</td></tr>
<tr><td>19</td><td>IRET</td><td>návrat z pøeru¹ení (interrupt)</td></tr>
<tr><td>1a</td><td>JC</td><td>podmínìný skok za pøedpokladu, ¾e je nastaven pøíznak pøenosu (<strong>carry flag</strong>)</td></tr>
<tr><td>1b</td><td>JNC</td><td>podmínìný skok za pøedpokladu, ¾e je vynulován pøíznak pøenosu (<strong>carry flag</strong>)</td></tr>
<tr><td>1c</td><td>JZ</td><td>podmínìný skok za pøedpokladu, ¾e je nastaven pøíznak nulovosti (<strong>zero flag</strong>)</td></tr>
<tr><td>1d</td><td>JNZ</td><td>podmínìný skok za pøedpokladu, ¾e je vynulován pøíznak nulovosti (<strong>zero flag</strong>)</td></tr>
<tr><th colspan="3">Nezaøazené zbývající instrukce</th></tr>
<tr><td>1e</td><td>NOP</td><td>neprovádí se ¾ádná operace, mikroprocesor pøejde na dal¹í instrukci</td></tr>
<tr><td>1f</td><td>HALT</td><td>mikroprocesor se zastaví a èeká na pøíchod externího pøeru¹ení</td></tr>
</table>

<p>V&nbsp;prvním sloupci vý¹e uvedené tabulky je uveden takzvaný <i>operaèní
kód instrukce</i>, co¾ je v&nbsp;tomto pøípadì hexadecimální hodnota bytu
naèítaného z&nbsp;operaèní pamìti. Ve druhém sloupci je zapsáno jméno
instrukce, neboli mnemotechnická zkratka anglického názvu instrukce. U
jednotlivých procesorù, popø.&nbsp;výrobních øad procesorù, jsou pou¾ity rùzné
délky mnemotechnických zkratek, od dnes ji¾ málo pou¾ívaných jednopísmenných
zkratek (<strong>L</strong>-load, <strong>A</strong>-add,
<strong>R</strong>-move to register) pøes pravdìpodobnì nejèastìji pou¾ívané
tøípísmenové zkratky (<strong>ADD</strong>, <strong>SUB</strong>-subtract,
<strong>MOV</strong>-move, <strong>JMP</strong>-jump) po názvy instrukcí
slo¾ených z&nbsp;celých anglických slov, nejenom jejich zkratek
(<strong>ADD</strong>, <strong>LOAD</strong>, <strong>STORE</strong>,
<strong>MOVE</strong>, <strong>JUMP</strong>). V&nbsp;následující kapitole bude
popsána instrukce <strong>MOV</strong> slou¾ící pro pøesuny dat mezi registry A
a B.</p>



<p><a name="k07"></a></p>
<h1>7. Instrukce pro pøesuny dat mezi registry</h1>

<p>Mezi èasto pou¾ívané instrukce patøí instrukce slou¾ící pro pøesun dat mezi
jednotlivými pracovními registry mikroprocesoru. Vzhledem k&nbsp;tomu, ¾e ná¹
ukázkový mikroprocesor obsahuje pouze dva pracovní registry oznaèené
<strong>A</strong> a <strong>B</strong>, jsou k&nbsp;dispozici pouze dvì
instrukce pro pøesun dat: první slou¾í pro pøesun hodnoty z&nbsp;registru
<strong>B</strong> do registru <strong>A</strong> a druhá pro opaèný pøesun,
tj.&nbsp;z&nbsp;registru <strong>A</strong> do registru <strong>B</strong>.
Instrukce pro pøesun dat má mnemotechnickou zkratku <strong>mov</strong> se
základním operaèním kódem 0x13. Rozhodnutí o cílovém registru se
v&nbsp;assembleru rozli¹uje zápisem instrukce:</p>

<code-area>mov A,B    ; pøesun z registru B do registru A
mov B,A    ; pøesun z registru A do registru B
</code-area>

<p>V&nbsp;závislosti na tom, ze kterého registru se data ètou a do kterého
registru se zapisují, se musí roz¹íøit i samotná instrukce o adresní èást.
V&nbsp;pøípadì, ¾e byte následující za operaèním kódem ve strojovém kódu
obsahuje hodnotu 0x01, bude se provádìt pøesun z&nbsp;registru A do registru B
(cílem je B), v&nbsp;pøípadì hodnoty 0x00 bude pøesun opaèný,
tj.&nbsp;z&nbsp;registru B do registru A (cílem je A). Mo¾ná vás napadlo, ¾e
vzhledem k&nbsp;tomu, ¾e ná¹ mikroprocesor obsahuje pouze 32 instrukcí, které
lze kódovat pomocí pìti bitù (2<sup>5</sup>=32), je mo¾né onen jediný bit
rozhodující o tom, která ze dvou pøenosových operací se skuteènì pou¾ije,
vlo¾it pøímo do operaèního kódu. Je to my¹lenka správná a prakticky v¹echny
mikroprocesory mají svoji instrukèní sadu "hutnìj¹í" ne¾ ná¹ mikroprocesor,
ov¹em pro úèely snaz¹ího ètení strojového kódu ponechám operaèní kód a adresní
èást v&nbsp;samostatných bytech, i kdy¾ to podstatným zpùsobem program
prodlu¾uje:</p>

<table>
<tr><th>Strojový kód</th><th>Význam</th></tr>
<tr><td>13 00</td><td>mov A,B</td></tr>
<tr><td>13 01</td><td>mov B,A</td></tr>
</table>

<p>U nìkterých mikroprocesorù, které obsahují vìt¹í mno¾ství pracovních
registrù, samozøejmì stoupá i poèet rùzných "cest", kterými mohou data putovat.
Napøíklad u mikroprocesoru Intel 8080 je celkem 63 operaèních kódù z&nbsp;256,
tj.&nbsp;celá ètvrtina, rezervovaná právì pro pøesuny dat, pøièem¾ bylo mo¾né
kódovat i instrukce typu <strong>mov b,b</strong>, tj.&nbsp;pøesun
z&nbsp;registru do toho samého registru (v&nbsp;podstatì se jedná o jinak
zakódovanou instrukci <strong>nop</strong>). Samotná implementace pøesunu je
uvnitø mikroprocesoru celkem jednoduchá, jak ostatnì ukazují následující dvì
animace.</p>

<image id="6001" />
<p-center>Zpùsob provedení instrukce <strong>mov A, B</strong></p-center>

<p>Je¹tì dodám, ¾e existují i mikroprocesory, které nemohou pro pøesuny pou¾ít
interní sbìrnici &ndash; v&nbsp;tomto pøípadì jdou ve¹kerá data pøes ALU, která
musí obsahovat operaci, která pouze pøevede vstupní data na výstup bez jejich
úpravy. Tato zdánlivá nelogiènost má svoje opodstatnìní, proto¾e se zjednodu¹í
jak øízení celého mikroprocesoru, tak i jeho interní struktura.</p>

<image id="6002" />
<p-center>Zpùsob provedení instrukce <strong>mov B, A</strong></p-center>



<p><a name="k08"></a></p>
<h1>8. Obsah následující èásti tohoto seriálu</h1>

<p>I v&nbsp;dal¹í èásti seriálu budeme pokraèovat v&nbsp;popisu funkcí, které
provádí mikroprocesor pøi zpracování instrukcí, pøesnìji øeèeno operaèních kódù
(opkódù), naèítaných z&nbsp;operaèní pamìti. Pøedev¹ím si vysvìtlíme v¹echny
aritmetické a logické instrukce a jejich pou¾ití (spolu s&nbsp;instrukcemi
skoku a pøíznakovým registrem) pro øízení bìhu programu.</p>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2008</small></p>
</body>
</html>

