<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Architektury mikroprocesorù</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Architektury mikroprocesorù</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V jubilejní desáté èásti seriálu o funkci poèítaèù, si popí¹eme nìkteré typické architektury mikroprocesorù, zejména architektury oznaèované témìø magickými zkratkami RISC, CISC èi MISC. Øekneme si také, jaké pøednosti a zápory jednotlivé architektury mají z hlediska jejich dal¹ího vývoje.</p>



<h1>Obsah</h1>
<p>
<a href="#k01">1. Architektury mikroprocesorù</a><br />
<a href="#k02">2. Platforma IBM System/360 a vznik architektury CISC</a><br />
<a href="#k03">3. RISC &ndash; jednoduchost a rychlost</a><br />
<a href="#k04">4. Zásobníkové architektury</a><br />
<a href="#k05">5. Rozdìlení instrukèních sad podle poètu explicitnì adresovaných operandù</a><br />
<a href="#k06">6. Obsah dal¹í èásti seriálu</a><br />
</p>



<p><a name="k01"></a></p>
<h1>1. Architektury mikroprocesorù</h1>

<p>V&nbsp;padesátých a ¹edesátých letech minulého století byl ka¾dý typ tehdy
vyrobeného poèítaèe vlastnì unikátem, který v&nbsp;naprosté vìt¹inì pøípadù
nebyl kompatibilní ani s&nbsp;pøedchozími modely té¾e firmy, ani s&nbsp;modely
jiných firem. To mimo jiné znamenalo, ¾e program napsaný pro jeden typ poèítaèe
byl prakticky nepøenositelný na jiné poèítaèe &ndash; li¹ily se jak pou¾ité
procesory (procesorové jednotky), tak i interní a externí sbìrnice, pamì»ové
subsystémy i pøedchùdci dne¹ních operaèních systémù (v&nbsp;té dobì se
v&nbsp;podstatì jednalo o sady ovladaèù, popø.&nbsp;nìjaký jednoduchý správce
dávkovì spou¹tìných úloh). S&nbsp;pøechodem na jiný typ poèítaèe tedy firmy
musely investovat do nového programového vybavení a &ndash; co bylo
z&nbsp;pohledu dne¹ních výrobcù softwaru a hardwaru je¹tì hor¹í &ndash;
prakticky nic nedr¾elo zákazníky u øe¹ení jedné firmy, proto¾e zmìna typu
poèítaèe stejnì vedla k&nbsp;zahození prakticky v¹ech aplikací a mnohdy i
k&nbsp;nákladné konverzi dat na jiná pamì»ová média a do jiného formátu.</p>

<image id="6226" />
<p-center>Eniac byl samozøejmì naprostý unikát kompatibilní maximálnì sám se
sebou (minimálnì do doby, ne¾ se program "pøedrátoval")</p-center>

<p>Od konce ¹edesátých let do pøibli¾nì poloviny let sedmdesátých docházelo
k&nbsp;postupné unifikaci v&nbsp;oblasti výpoèetní techniky; jak formátù dat
(EBCDIC èi ASCII byly v&nbsp;té dobì pro mnoho výrobcù i u¾ivatelù ¾havé
novinky), tak i programù, proto¾e s&nbsp;nástupem pøekladaèù vy¹¹ích
programovacích jazykù bylo mo¾né psát skuteènì pøenositelné aplikace. Výkon
poèítaèù i kapacity jejich pamìtí dosáhl takové míry, ¾e bylo mo¾né èást výkonu
(samozøejmì do urèité míry a v&nbsp;nìkterých aplikacích)
&bdquo;obìtovat&ldquo; pro programy napsané v&nbsp;interpretovaných jazycích.
Nás v¹ak budou v&nbsp;této chvíli zajímat srdce v¹ech poèítaèù,
tj.&nbsp;procesory a pozdìj¹í mikroprocesory. I ty se do urèité míry
unifikovaly (zejména s&nbsp;nástupem integrovaných obvodù s&nbsp;velkou mírou
integrace), ale souèasnì byla patrná snaha o dosa¾ení lep¹ích výpoèetních
výkonù, men¹í ceny èi rychlej¹í reakce na pøeru¹ení pomocí aplikace rùzných
technologií. To postupnì vedlo ke vzniku nìkolika typických konfigurací
mikroprocesorù, které nazýváme <i>architekturou</i>. V&nbsp;následujících
kapitolách si nìkteré typické architektury popí¹eme.</p>

<image id="6227" />
<p-center>Ov¹em procesory øady i8080 byly ji¾ tak standardizované, ¾e jejich
klony vyrábìly i státy RVHP (ov¹em okolní svìt v&nbsp;té dobì ji¾ pou¾íval
¹estnáctibitové mikroprocesory)</p-center>

<image id="6228" />



<p><a name="k02"></a></p>
<h1>2. Platforma IBM System/360 a vznik architektury CISC</h1>

<p>V&nbsp;roce 1962 se firma IBM rozhodla navrhnout do znaèné míry univerzální
architekturu poèítaèù, která by pokrývala jak nároky jednodu¹¹ích úloh (pro
které staèily ménì výkonné a tím pádem i levnìj¹í poèítaèe), tak i nároky
mnohem vìt¹í. Pøedností této architektury mìlo být to, ¾e systém
&bdquo;rostl&ldquo; souèasnì s&nbsp;rostoucími po¾adavky zákazníka bez nutnosti
mìnit programové vybavení. Výsledkem tìchto snah firmy IBM byla platforma
nazvaná <i>System/360</i>, resp. zkrácenì <i>S/360</i>. Pro tuto platformu byla
vytvoøena pomìrnì rozsáhlá a slo¾itá instrukèní sada (<i>ISA</i>), která mimo
bì¾né binární aritmetiky obsahovala i instrukce pro práci s&nbsp;textem, rùzné
numerické formáty dat známé napøíklad z&nbsp;kalkulaèek, ale i podporu BCD
aritmetiky, která se dodnes pou¾ívá napøíklad pøi výpoètech s&nbsp;mìnou.
V&nbsp;té dobì toti¾ vládlo pøesvìdèení, ¾e bohat¹í instrukèní sada ulehèí
práci pøekladaèùm z&nbsp;vy¹¹ích programovacích jazykù, vyplní takzvanou
<i>sémantickou mezeru</i> mezi assemblerem a vy¹¹ími programovacími jazyky
atd.</p>

<p>Vzhledem ke slo¾itosti instrukèní sady System/360 se v&nbsp;praxi pou¾ívaly
mikroprogramy, tj.&nbsp;jednodu¹¹í procesory s&nbsp;touto architekturou
kompatibilní mnoho instrukcí pøímo nevykonávaly, ale vlastnì emulovaly na
základì takzvaného <i>mikrokódu</i> (mikroinstrukcí ulo¾ených v&nbsp;øadièi)
&ndash; jednalo se tedy o obdobu dnes populárních bytekódù, které také mohou
být emulovány pøímo v&nbsp;mikroprocesorech (mikroprogramem), nikoli
u¾ivatelským programem. Teprve mnohem pozdìji byly podobnì koncipované
instrukèní sady a mikroprocesory nazvány <strong>CISC</strong> neboli
<i>Complex Instruction Set Code</i> (v&nbsp;nìkterých pøípadech byly i
<i>mikroinstrukce</i> pro pøímé vykonání zbyteènì slo¾ité a proto byly
rozkládány do takzvaných <i>nanoinstrukcí</i>, co¾ vedlo ke sní¾ení potøebné
kapacity pamìti v&nbsp;øadièi i zjednodu¹ení návrhu samotného
mikroprocesoru).</p>

<image id="6229" />
<p-center>Jeden z&nbsp;poèítaèù platformy System/360</p-center>

<p>Procesory s&nbsp;architekturou CISC se vìt¹inou vyznaèují velmi obsáhlou
instrukèní sadou, mnohdy do znaèné míry ortogonální (tj.&nbsp;vìt¹ina instrukcí
mù¾e být pou¾ita se v¹emi adresními re¾imy). To ov¹em vede k&nbsp;nutnosti
pou¾ití slo¾itého øadièe, instrukce trvají i nìkolik desítek èi stovek taktù a
celková slo¾itost mikroprocesoru obecnì roste. Pøed nìkolika lety se zdálo, ¾e
celá architektura CISC bude opu¹tìna a nahrazena architekturou RISC. Ve
skuteènosti v¹ak vznikly jakési hybridní architektury &ndash; dnes
nejpopulárnìj¹í mikroprocesory jsou sice internì vytvoøeny jako RISCové, ale
jejich instrukèní sada je CISCová. V&nbsp;této kombinaci se ukazují výhody obou
architektur: velká rychlost a interní jednoduchost RISCù a souèasnì krat¹í kód
instrukcí u CISC procesorù (sni¾ují se nároky na vyrovnávací pamìti). Pro
pøíklad nemusíme chodit daleko, proto¾e do tohoto stavu do¹la i platforma x86
(a pøed ní <i>VAX</i> èi <i>Motorola 68060</i>). I populární RISCové procesory
ARM obsahují instrukèní sadu nazvanou <i>Thumb</i>, která umo¾òuje sní¾ení
velikosti programù o cca 30-40% (kromì toho je pro tyto procesory dostupná i
technologie <i>Jazelle</i> urèená pro pøímé provádìní Javovského bytekódu).</p>

<image id="6230" />
<p-center>Mikroprocesor Motorola 68000 patøí mezi zástupce architektury CISC s&nbsp;témìø ortogonální instrukèní sadou</p-center>

<p>Skok do podprogramu, návrat z&nbsp;podprogramu i podmínìný skok jsou pro
CISC procesor takovou malou tragédií, proto¾e musí zapomenout v¹echny
rozpracované instrukce a zaèít plnit instrukèní <i>pipeline</i> pìknì od
zaèátku (bli¾¹í informace si uvedeme v&nbsp;následující èásti seriálu).
Z&nbsp;tohoto dùvodu se u CISC procesorù zaèaly objevovat rùzné technologie,
vytvoøené pùvodnì pro RISC, umo¾òující takzvanì <i>predikovat</i> podmínìný
skok (typické jsou jednobitové a dvoubitové prediktory skokù), pøekladaèe na
po¾ádání rozbalují smyèky (<i>loop unrolling</i>), vyu¾ívají inline funkce
apod. ®ádnou z&nbsp;tìchto technologií není zapotøebí pou¾ívat napøíklad u
zásobníkových èi akumulátorových mikroprocesorù (viz dal¹í kapitoly), co¾
samozøejmì pøispívá k&nbsp;jejich konstrukèní jednoduchosti.</p>

<p>Pro ilustraci &bdquo;komplexnosti&ldquo; instrukèní sady následuje pøíklad
èásti programu napsaného v&nbsp;assembleru CISCové architektury x86. V¹imnìte
si rùzných adresních re¾imù, implicitnì zadaných operandù u instrukce
<strong>imul</strong>, segmentového adresování pomocí segmentového registru
<strong>es</strong>, i toho, ¾e u aritmetických instrukcí je mo¾né pou¾ívat
operandy pøímo naèítané z&nbsp;operaèní pamìti (<strong>mov es:[di],
ax</strong>, <strong>add ax,[zy1]</strong>), co¾ je pro CISCové architektury
typické a naopak netypické pro architekturu RISC:</p>

<code-area>
mov     ax,bp
sar     ax,cl
imul    ax          ; implicitní operandy: dx:ax=ax*ax
push    ax

mov     ax,bx
sar     ax,cl       ; pøi bitovém posunu se musí pou¾ít registr cl
imul    ax
mov     es:[di],ax  ; ulo¾ení obsahu registru do pamìti

mov     ax,bp
sar     ax,cl
sar     bx,5
imul    bx          ; implicitní operandy: dx:ax=ax*bx
add     ax,[zy1]    ; jeden z operandù je naèten z operaèní pamìti
xchg    ax,bx

pop     ax
push    ax
sub     ax,es:[di]
add     ax,[zx1]
mov     bp, ax
pop     ax
add     ax,es:[di]
dec     ch
jz      short pokrac
cmp     ax,4*P
jc      short opak
stosb               ; dal¹í instrukce s implicitními operandy (poru¹ení ortogonality)
</code-area>

<image id="6231" />
<p-center>I platforma x86 je architekturou CISC, i kdy¾ do ortogonality své
instrukèní sady mìla zejména v&nbsp;minulosti daleko</p-center>



<p><a name="k03"></a></p>
<h1>3. RISC &ndash; jednoduchost a rychlost</h1>

<p>V&nbsp;pøedchozí kapitole jsme si øekli, ¾e jednou z&nbsp;motivací zavedení
komplexní instrukèní sady byla pomoc programátorùm i pøekladaèùm s&nbsp;tvorbou
efektivních programù. Slo¾ité instrukce s&nbsp;mnoha adresními re¾imy apod.
mìly programátorùm umo¾nit programovat v&nbsp;assembleru podobnì, jako ve
vy¹¹ím programovacím jazyku (ostatnì napøíklad assembler Motoroly 68000 se dost
pøibli¾uje Céèku). I pøekladaèe mìly mít ulehèenou práci, proto¾e se mnoho
konstrukcí z&nbsp;vy¹¹ích programovacích jazykù dalo zapsat malým mno¾stvím
strojových instrukcí.</p>

<p>Ov¹em nakonec se ukázalo, ¾e vìt¹ina programátorù i pøekladaèù zdaleka
nepou¾ívá v¹echny dostupné instrukce, v&nbsp;nìkterých pøípadech se vyu¾ívalo
jen 30% v¹ech mo¾ných kombinací. To mj.&nbsp;znamená, ¾e investice do slo¾itého
CISC mikroprocesoru byla vlastnì v&nbsp;tom pøípadì zbyteèná, proto¾e jeho
velká èást zùstala nevyu¾ita. Kdy¾ k&nbsp;tomuto faktu je¹tì pøipoèteme, ¾e
samotné CISC procesory jsou velmi slo¾ité a v&nbsp;minulosti pro nì prakticky
nebylo mo¾né implementovat rùzné urychlovací technologie (prediktory skokù,
out-of-order provádìní instrukcí, spekulativní provádìní instrukcí atd.), nelze
se divit tomu, ¾e se výrobci i vìdci zaèali ohlí¾et po zcela odli¹ném øe¹ení:
místo filozofie &bdquo;more is better&ldquo; se tedy zaèala upøednostòovat
filozofie &bdquo;less is better&ldquo; (ta je ostatnì výhodnìj¹í i
v&nbsp;dal¹ích oblastech).</p>

<p>V&nbsp;roce 1980 firma IBM a lidé z&nbsp;University of Berkeley pøi¹li
s&nbsp;my¹lenkou vytvoøit procesor s&nbsp;jednoduchými instrukcemi
s&nbsp;omezením ortogonality, men¹ím mno¾stvím adresních re¾imù atd. Vzhledem
k&nbsp;tomu, ¾e v&nbsp;té dobì zaèaly být mikroprocesory rychlej¹í ne¾
k&nbsp;nim pøipojované pamìti (tento trend trvá dodnes, ov¹em
&bdquo;nù¾ky&ldquo; v&nbsp;rychlosti se je¹tì více rozevøely), byla RISC
procesorùm dána do vínku dal¹í u¾iteèná vlastnost: velké mno¾ství pracovních
registrù, které bylo mnohdy je¹tì více zvìt¹ené pomocí takzvaného
<i>registrového okna</i> (více sad registrù, mezi kterými se dá pøepínat).
Pracovní registry slou¾í jako cache pamì» nulté úrovnì. Dùle¾ité je, ¾e se
v¹echny aritmetické i logické instrukce provádí právì s&nbsp;tìmito registry,
které jsou si rovnocenné (není zde tedy privilegovaný akumulátor), co¾ velmi
ulehèuje práci jak pøekladaèùm (alokace registrù), tak i programátorùm pí¹ícím
programy v&nbsp;assembleru.</p>

<p>U RISC procesorù nastávají problémy pøi volání podprogramù a návratech
z&nbsp;podprogramù, proto¾e se pøeru¹í plynulý tok instrukcí a tím pádem je
zapotøebí vyprázdnit polozpracované instrukce z&nbsp;fronty instrukcí
(<i>pipeline</i>). V&nbsp;praxi se tento problém øe¹í buï pøi pøekladu
(rozbalování smyèek &ndash; <i>loop unrolling</i>) nebo za bìhu pomocí
prediktorù skokù, out-of-order zpracováním instrukcí atd. Více si o tìchto
technologiích povíme pøí¹tì.</p>

<image id="6232" />
<p-center>PA RISC firmy Hewlett-Packard (mikroprocesor spolu s&nbsp;podpùrnými
obvody a vyrovnávacími pamì»mi)</p-center>

<p>Mezi velmi úspì¹né RISC procesory patøí celá rodina mikroprocesorù
oznaèovaná <i>MIPS</i>. Mikroprocesory patøící do této rodiny byly pou¾ity jak
u výkonných grafických stanic firmy SGI, tak i ve zcela opaèném trhu:
v&nbsp;embedded aplikacích, Nintendu 64, Sony PlayStation, PlayStation 2 atd.
Èín¹tí výrobci mají svoji verzi MIPS oznaèovanou jako <i>Godson</i>
popø.&nbsp;v&nbsp;anglicky mluvících zemích <i>Dragon</i>. Dùvod velké
oblíbenosti MIPS spoèívá pøedev¹ím v&nbsp;mo¾nosti propojení jádra
mikroprocesoru s&nbsp;dal¹ími obvody na jednom èipu, co¾ je velmi èasto
vyu¾íváno zejména v&nbsp;embedded aplikacích. V&nbsp;praxi to znamená mo¾nost
mít celé zaøízení umístìné na jednom jediném èipu a programovat pøitom na
známé, výkonné a mnoha lety praxe odladìné architektuøe.</p>

<image id="6233" />
<p-center>Mikroprocesor MIPS</p-center>

<p>O tom, ¾e ne v¾dy je mo¾né se pøesnì rozhodnout, zda je nìjaký mikroprocesor
typu RISC èi CISC, svìdèí následující graf, na kterém jsou mikroprocesory
rozdìleny jak podle bitové ¹íøky, tj.&nbsp;¹íøky zpracovávaných operandù, tak i
podle toho, zda se blí¾í spí¹e typické CISC architektuøe nebo kanonické
architektuøe RISC.</p>

<pre>
    Complex/                                                         Simple/
      CISC____________________________________________________________RISC
      |                                                         14500B*
4-bit |                                                    *Am2901
      |                                   *4004
      |                                *4040
8-bit |                                     6800,650x         *1802
      |                       8051*  *  *8008   *    SC/MP
      |                              Z8    *         *    *F8
      |                F100-L*   8080/5  2650          
      |                             *       *NOVA        *  *PIC16x
      |          MCP1600*   *Z-80         *6809    IMS6100
16-bit|          *Z-280           *PDP11             80C166*  *M17
      |                      *8086    *TMS9900
      |                 *Z8000          *65816
      |                *56002
      |            32016*   *68000 ACE HOBBIT  Clipper      R3000
32-bit|432           96002 *68020    *   *  *  *   *29000     *   *ARM
      | *         *VAX * 80486 68040 *PSC i960    *SPARC         *SH
      |          Z80000*    *  *    TRON48    PA-RISC
      |    PPro  Pent*    -- T9000 -*-------     *    *88100
      | *    *    -- 860 -*--*-----            *     *88110
64-bit|Rekurs         POWER PowerPC   *        CDC6600     *R4000
      |            x86-64*   *620 U-SPARC *     *R8000         *Alpha
      |     ------- IA-64 -------      R10000
</pre>



<p><a name="k04"></a></p>
<h1>4. Zásobníkové architektury</h1>

<p>V&nbsp;pøedchozích dvou èástech tohoto seriálu, konkrétnì u popisu pøedávání
parametrù do podprogramù a samotného volání podprogramù èi pøeru¹ovacích rutin,
jsme si ukázali význam zásobníku pøi zpracování strukturovaného programového
kódu. Ov¹em zásobníky se v&nbsp;nìkterých pøípadech vyu¾ívají i pøi vyèíslování
aritmetických a logických výrazù, kopírování dat a øízení programového kódu.
<i>Zásobníkové procesory</i> jsou takové procesory, které manipulaci se
zásobníkem podporují ji¾ ve svých instrukcích a mnohdy dokonce ve svém jádru
jeden èi více zásobníkù obsahují (nebo alespoò nìkolik nejvy¹¹ích polo¾ek
zásobníku). Nejedná se v¹ak pouze o základní manipulaci se zásobníkem (tu
zvládají prakticky v¹echny procesory), ale napøíklad o instrukce urèené pro
efektivní provádìní výpoètù nad hodnotami ulo¾enými v&nbsp;zásobníku, instrukce
typu <strong>OVER</strong>, <strong>DUP</strong> apod. V&nbsp;praxi se mù¾eme
setkat jak s&nbsp;èistì zásobníkovými procesory, tak i s&nbsp;rùznými
modifikacemi, napøíklad kombinací zásobníkového procesoru a procesoru typu
RISC.</p>

<image id="6234" />
<p-center>Zásobníkový mikroprocesor SEAforth-24</p-center>

<p>Zásobníkové procesory jsou urèeny pøedev¹ím ve vestavìných systémech
(<i>embedded devices</i>), u kterých hrají velkou roli nepatrné systémové
po¾adavky a cena. Vzhledem k&nbsp;tomu, ¾e programový kód je u zásobníkových
procesorù obecnì krat¹í (nezávisle na slo¾itosti programu) ne¾ u procesorù typu
<i>RISC</i> a <i>CISC</i> (nemluvì o <i>VLIW</i>), mohou být také pou¾ity
pamìti s&nbsp;men¹í kapacitou a tím se mù¾e sní¾it i finální cena výrobku.
Samotný zásobníkový procesor je také velmi jednoduchý, proto¾e nemusí obsahovat
sadu obecných registrù ani plánovaè instrukcí. Dal¹í aplikaèní oblastí
zásobníkových procesorù jsou systémy, u kterých je po¾adována vysoká rychlost
zpracování a pøedev¹ím rychlé odezvy systému na pøeru¹ení (není zapotøebí
ukládat stav procesoru pøi pøíchodu pøeru¹ení, proto¾e v¹e podstatné je stejnì
ulo¾eno na zásobníku). V&nbsp;neposlední øadì jsou zásobníkové procesory
pou¾ity i v&nbsp;nìkterých dru¾icích, kde provádí øídicí a mìøící èinnosti. Na
druhou stranu jsou v¹ak zásobník èi zásobníky úzkým místem, které do jisté míry
zabraòuje vyu¾ití instrukèního paralelismu.</p>

<p>Mezi zásobníkové procesory patøí napøíklad v¹echny výrobky firem <i>Minimum
Instruction Set Computer, Inc.</i>, <i>Novix</i>, nìkolik mikroprocesorù firmy
<i>Harris Semiconductor</i>, minimalistické mikroprocesory <i>F21</i> a
<i>X18</i> Chucka Moorea atd. Ov¹em i procesory urèené pro bìh Javy
(<i>UltraJava</i>, <i>MicroJava</i> a <i>PicoJava</i>) jsou ve skuteènosti
zásobníkovými procesory.</p>

<p>Nejvìt¹ím rozdílem mezi zásobníkovými procesory a procesory typu RISC je
fakt, ¾e zásobníkové procesory pou¾ívají instrukce bez explicitního adresování
operandù. U RISC procesorù se typicky pou¾ívají instrukce se dvìma operandy,
kterými bývají pracovní registry (viz <a href="#k05">pátá kapitola</a>).
Jedinou výjimku tvoøí instrukce typu <strong>LOAD</strong> a
<strong>STORE</strong>, které naèítají obsah pracovního registru
z&nbsp;operaèní pamìti, nebo naopak ukládají obsah registru do operaèní pamìti.
Pro zajímavost: u mnoha zásobníkových mikroprocesorù se tyto instrukce jmenují
<strong>FETCH</strong> a <strong>STORE</strong>, co¾ vychází z&nbsp;pojmenování
základních pøíkazù programovacího jazyka <i>Forth</i> (viz <a
href="http://www.root.cz/serialy/programovaci-jazyk-forth">seriál o
programovacím jazyce Forth</a>).</p>

<p>Celková velikost programového kódu je u zásobníkových procesorù obecnì
men¹í, ne¾ u RISC procesorù. RISC procesory toti¾ mají velké mno¾ství registrù,
pro jejich¾ specifikaci (adresaci) je nutné pou¾ít vìt¹ího mno¾ství bitù v kódu
instrukce. Dokonce se uvádí vtip, ¾e velikost vyrovnávací pamìti (<i>cache</i>)
u RISC procesoru musí být vìt¹í ne¾ kapacita CELÉ operaèní pamìti u
zásobníkového procesoru, pøièem¾ na obou procesorech bì¾í programy stejnou
rychlostí.</p>

<p>Jak mù¾e vypadat assemblerovský kód urèený pro zásobníkové procesory?
V¹imnìte si, ¾e se u instrukcí nepou¾ívají operandy a celý kód vzdálenì
pøipomíná <strong>Forth</strong>, co¾ samozøejmì není náhoda:</p>

<pre>; èást kódu napsaná v assembleru pro zásobníkový procesor
; která vyèíslí výraz z=x*x+y*y
prom_x FETCH  ; naètení promìnné x a ulo¾ení na zásobník
DUP           ; duplikace nejvy¹¹í hodnoty ulo¾ené na zásobníku (x)
MUL           ; na vrcholu zásobníku je nyní výsledek výrazu x*x
prom_y FETCH  ; naètení promìnné y a ulo¾ení na zásobník
DUP           ; duplikace nejvy¹¹í hodnoty ulo¾ené na zásobníku (y)
MUL           ; na vrcholu zásobníku je nyní výsledek výrazu y*y
ADD           ; na vrcholu zásobníku je nyní výsledek výrazu x*x+y*y
prom_z        ; na zásobník se ulo¾í adresa promìnné, kam se má výsledek ulo¾it
STORE         ; ulo¾ení výsledku a jeho odstranìní spolu s adresou
</pre>



<p><a name="k05"></a></p>
<h1>5. Rozdìlení instrukèních sad podle poètu explicitnì adresovaných operandù</h1>

<p>Instrukèní sady mikroprocesorù je mo¾né rozdìlit podle rùzných kritérií.
Jedním kritériem, které je patrné ji¾ na první pohled z&nbsp;libovolného (i
docela krátkého) kódu napsaného pro daný mikroprocesor, je zalo¾eno na poètu
operandù, které jsou explicitnì adresovány v&nbsp;adresní èásti instrukce.
Mohlo by se zdát, ¾e u vìt¹iny aritmetických a logických instrukcí se v¾dy bude
jednat o dva vstupní operandy a jeden operand výstupní (napøíklad <strong>ADD
A,B,C</strong>, kde <strong>A</strong> je pracovní registr, do kterého se ulo¾í
výsledek operace), ov¹em ve skuteènosti je situace ponìkud slo¾itìj¹í a tøi
operandy (2 vstupní a 1 výstupní) se pou¾ívají pouze v&nbsp;malém mno¾ství
pøípadù, proto¾e vìt¹í mno¾ství adres u instrukce celé instrukèní slovo
prodlu¾uje, co¾ se projevuje zejména u procesorù typu RISC, které obecnì mají
velký poèet pracovních registrù (napøíklad pro výbìr jednoho z&nbsp;32 registrù
je zapotøebí 5 bitù). Pojïme si nyní øíci, jaké mo¾nosti pøi adresování
operandù máme:</p>

<ul>

<li><strong>®ádné explicitnì zadané operandy</strong> se pou¾ívají zejména u
<i>zásobníkových mikroprocesorù</i>. Operandy není zapotøebí v&nbsp;adresní
èásti instrukce v&nbsp;tomto pøípadì zadávat, proto¾e je dopøedu známo, ¾e se
vybírají ze zásobníku, konkrétnì z&nbsp;nejvy¹¹í polo¾ky (<i>TOS &ndash; Top Of
Stack</i>) a druhé, popø.&nbsp;u slo¾itìj¹ích instrukcí i tøetí polo¾ky.
Výsledek operace se takté¾ ukládá na zásobník, vìt¹inou pouze do nejvy¹¹í
polo¾ky (<i>TOS</i>). Výhodou tìchto takzvaných bezadresových instrukcí je
jejich velmi krátká délka, proto¾e se v&nbsp;instrukèním kódu nemusí vytváøet
prostor pro specifikaci zdrojù a cíle dat. Nevýhodou je úzké místo, které
zásobník pøedstavuje pøi pøípravì dat na výpoèet. Zástupcem tohoto typu
procesorù je napøíklad <i>MISC M17</i>, <i>F21</i> (a dal¹í mikroprocesory
vytvoøené Chuckem Moorem), <i>RTX 32P</i>, <i>b16</i> a ve své podstatì i
mikroprocesory urèené pro pøímé provádìní &bdquo;strojového kódu&ldquo;
zpracovávaného JVM (<i>Java Virtual Machine</i>).</li>

<li><strong>Jeden explicitnì zadaný operand</strong> je pou¾it typicky u
takzvaných <i>akumulátorových mikroprocesorù</i> (jedná se o nepøesný název,
ov¹em pøedev¹ím v&nbsp;minulosti se pomìrnì èasto pou¾íval). Tyto
mikroprocesory jsou charakteristické tím, ¾e obsahují jeden specifický registr
nazývaný <i>akumulátor</i>. Tento registr je pou¾itý pøi prakticky v¹ech
výpoètech, proto ho není zapotøebí v&nbsp;instrukèním kódu uvádìt
(mikroprocesor ví, ¾e jeden z&nbsp;operandù je v¾dy akumulátor a i výsledek se
do nìj ukládá &ndash; akumuluje). Typicky bývá akumulátor pou¾it jako první
operand a také jako místo, kam se ulo¾í výsledek operace. Zástupcem tohoto typu
procesorù, které byly vyrábìné pøedev¹ím v&nbsp;minulosti, je <i>Intel
8080</i>, <i>Intel 8048</i> a také <i>MOS 6502</i>. Výhody a nevýhody
akumulátorových procesorù jsou stejné (nevýhody jsou v¹ak vìt¹í), jako
v&nbsp;pøípadì procesorù zásobníkových: pomìrnì krátké instrukce a existence
úzkého místa, kterým je nyní akumulátor. V&nbsp;praxi vypadají programy psané
pro akumulátorové procesory tak, ¾e cca 1/4 a¾ 1/3 instrukcí tvoøí pøesuny mezi
akumulátorem a ostatními pracovními registry popø.&nbsp;pamìtí.</li>

<li><strong>Dva explicitnì zadané operandy</strong> jsou pou¾ity u takzvaných
<i>registrových mikroprocesorù</i>, tj. u tìch typù procesorù, které obsahují
vìt¹í mno¾ství obecnì pou¾itelných (a v&nbsp;instrukcích adresovatelných)
registrù. Jedná se o dnes nejpou¾ívanìj¹í procesory typu <i>RISC</i> i
<i>CISC</i>. V&nbsp;instrukèním kódu jsou specifikovány dva pracovní registry
nebo pamì»ová místa &ndash; jeden registr je zdrojový a souèasnì i cílový,
druhý registr obsahuje druhý operand, který do instrukce vstupuje (samozøejmì
se musí jednat o binární instrukce, unární instrukce pou¾ívají pouze jeden
registr). Výhodou tìchto typu mikroprocesorù je snadná tvorba slo¾itìj¹ích
výpoètù a z&nbsp;toho plynoucí jednodu¹¹í práce pro pøekladaèe. Nevýhodou jsou
dlouhé instrukèní kódy a praktická nutnost pou¾ití pipeliningu. Známou
architekturu <i>Intel x86</i> lze zaøadit do této kategorie, i kdy¾ vykazuje i
nìkteré vlastnosti kategorie pøedchozí. Dále sem patøí legendární <i>Motorola
68000</i>.</li>

<li><strong>Tøi explicitnì zadané operandy</strong> jsou pou¾ívané takté¾ u
<i>registrových mikroprocesorù</i>. Rozdíl oproti pøedchozí skupinì je ten, ¾e
jsou explicitnì specifikovány jak oba zdrojové operandy, tak i operand cílový.
Ruèní i automatická tvorba strojového kódu je jednoduchá (zde mají pøekladaèe
snadnou práci, zejména ve chvíli, kdy mají k&nbsp;dispozici dostatek pracovních
registrù), nevýhodou jsou dlouhé instrukce (samotný operaèní kód je stejný,
ov¹em prodlu¾uje se adresní èást instrukce). Tøíadresový kód je èasto pou¾it
jako abstraktní mezikód pøi pøekladu programu z&nbsp;vy¹¹ích programovacích
jazykù, proto¾e nad tøíadresovým kódem je mo¾né relativnì snadno provádìt rùzné
optimalizace. Mezi zástupce mikroprocesorù vyu¾ívajících tøíadresové instrukce
patøí u¾ zmínìná architektura <i>MIPS</i>, ve které jsou registry adresovány
pomocí pìti bitù, tj.&nbsp;je k&nbsp;dispozici 32 pracovních registrù,
z&nbsp;nich¾ nìkteré mají speciální význam (napøíklad jeden z&nbsp;registrù
v¾dy obsahuje nulu, èeho¾ se u mnoha instrukcí dá vyu¾ít).</li>

</ul>



<p><a name="k06"></a></p>
<h1>6. Obsah dal¹í èásti seriálu</h1>

<p>V&nbsp;následující èásti tohoto seriálu si podrobnìji popí¹eme nìkteré
zpùsoby urychlení vykonávání strojových instrukcí v&nbsp;mikroprocesoru.
Mo¾ností urychlení existuje mnoho &ndash; pou¾ití rychlej¹ích pamìtí
(<i>cache</i>), rozdìlení instrukcí do men¹ích èástí a vykovávání tìchto èástí
paralelnì (<i>pipelining</i>), zmírnìní negativního dopadu pou¾ití èasovì
nároèných skokù (<i>speculative branches, branch predicting</i>), paralelní
zpracování instrukcí (<i>VLIW</i>, <i>MMX</i>, vektorové instrukce), paralelní
zpracovávání více vláken (<i>multithreading</i>) èi dokonce paralelní
zpracování celých procesù v&nbsp;samostatných jádrech propojených pøepínací
sítí (<i>multi-core</i>) atd.</p>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2008</small></p>
</body>
</html>

