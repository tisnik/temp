<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Uèíme trpaslíky poèítat</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Uèíme trpaslíky poèítat</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V ¹esté èásti seriálu o architekturách poèítaèù si popí¹eme, jakým zpùsobem se provádí základní matematické operace v aritmeticko-logické jednotce mikroprocesoru. Také si vysvìtlíme význam pøíznakových bitù Carry flag a Zero flag, které hrají velký roli jak pøi poèítání, tak pøi programování podmínek.</p>



<h1>Obsah</h1>
<p>
<a href="#k01">1. Reprezentace celoèíselných hodnot v&nbsp;pracovních registrech i operaèní pamìti</a><br />
<a href="#k02">2. Celá èísla bez znaménka</a><br />
<a href="#k03">3. Celá èísla se znaménkem (dvojkový doplnìk)</a><br />
<a href="#k04">4. ALU a základní matematické operace</a><br />
<a href="#k05">5. Zvý¹ení èi sní¾ení hodnoty pracovního registru o 1</a><br />
<a href="#k06">6. Aritmetické instrukce ADD (addition)</a><br />
<a href="#k07">7. Aritmetická instrukce ADC (addition with carry)</a><br />
<a href="#k08">8. Aritmetické instrukce SUB (subtraction) a SBB (subtraction with borrow)</a><br />
<a href="#k09">9. Obsah dal¹í èásti tohoto seriálu</a><br />
</p>



<p><a name="k01"></a></p>
<h1>1. Reprezentace celoèíselných hodnot v&nbsp;pracovních registrech i operaèní pamìti</h1>

<p>Aritmeticko-logická jednotka doká¾e provádìt aritmetické operace pouze
s&nbsp;celoèíselnými hodnotami, pøièem¾ pro práci s&nbsp;jinými formami
reprezentace èíselných hodnot slou¾í matematické koprocesory èi relativnì
samostatné jednotky urèené pro operace s&nbsp;hodnotami ulo¾enými ve formátu
plovoucí øádové èárky (FPU). Vìt¹ina souèasných mikroprocesorù pøi práci
s&nbsp;celými èísly umo¾òuje provádìní aritmetických operací s&nbsp;hodnotami
reprezentovanými buï v&nbsp;systému dvojkového doplòku (<i>signed integers</i>)
nebo s&nbsp;celými kladnými (bezznaménkovými) èísly (<i>unsigned integers</i>)
&ndash; ve skuteènosti mezi tìmito dvìma formami reprezentace mikroprocesor,
resp.&nbsp;jeho ALU, neèiní velké rozdíly, co¾ nás ov¹em mù¾e v&nbsp;nìkterých
pøípadech "vytrestat" (problémové jsou napøíklad aritmetické posuvy, podmínìné
skoky atd.). Vzhledem k&nbsp;tomu, ¾e ná¹ uèební mikroprocesor je plnì
¹estnáctibitový, tj.&nbsp;jeho pracovní registry i aritmeticko-logická jednotka
doká¾ou v&nbsp;jedné instrukci pracovat se ¹estnáctibitovou hodnotou èi dvìma
hodnotami, existuje celkem 2<sup>16</sup>=65536 navzájem rùzných stavù, které
lze vhodnými i ménì vhodnými zpùsoby mapovat na celá èísla (se znaménkem nebo
bez znaménka).</p>

<image id="6043" />
<p-center>Nìkteré mikroprocesory a mikroøadièe jsou umístìny v&nbsp;pouzdrech s&nbsp;minimálním poètem vývodù</p-center>



<p><a name="k02"></a></p>
<h1>2. Celá èísla bez znaménka</h1>

<p>Nejprve se podívejme, jak toto mapování vypadá v&nbsp;pøípadì pou¾ití
datového typu <i>unsigned integer</i>. Ná¹ mikroprocesor (pøesnìji øeèeno jeho
aritmeticko-logická jednotka) pou¾ívá takzvané pøirozené mapování, ov¹em ve
speciálních pøípadech se na nìkterých mikroprocesorech volí mapování jiné.
V&nbsp;minulosti byl napøíklad oblíbený Aikenùv kód. Tabulka uvedená ní¾e,
která je platná pro pøirozené mapování, nás pravdìpodobnì nièím nepøekvapí:
pokud jsou v¹echny bity èísla vyjádøeného ve dvojkové soustavì nulové, jedná se
skuteènì o nulu; èíselná øada postupnì roste a¾ k&nbsp;maximální hodnotì
pøedstavované ¹estnácti bity nastavenými na I, co¾ v&nbsp;dekadickém zápisu
odpovídá 2<sup>16</sup>-1=65535 (nesmíme toti¾ zapomenout na to, ¾e jeden stav
musí být vyhrazen pro nulu).</p>

<table>
<tr><th>Hexadecimální hodnota</th><th>Dekadický ekvivalent</th></tr>
<tr><td>0000</td><td>     0</td></tr>
<tr><td>0001</td><td>     1</td></tr>
<tr><td>0002</td><td>     2</td></tr>
<tr><td>....</td><td>    ..</td></tr>
<tr><td>000f</td><td>    15</td></tr>
<tr><td>0010</td><td>    16</td></tr>
<tr><td>....</td><td>    ..</td></tr>
<tr><td>7ffd</td><td> 32765</td></tr>
<tr><td>7ffe</td><td> 32766</td></tr>
<tr><td>7fff</td><td> 32767</td></tr>
<tr><td>8000</td><td> 32768</td></tr>
<tr><td>8001</td><td> 32769</td></tr>
<tr><td>8002</td><td> 32770</td></tr>
<tr><td>....</td><td>    ..</td></tr>
<tr><td>fffc</td><td> 65532</td></tr>
<tr><td>fffd</td><td> 65533</td></tr>
<tr><td>fffe</td><td> 65534</td></tr>
<tr><td>ffff</td><td> 65535</td></tr>
</table>

<image id="6044" />
<p-center>Mikroprocesor s&nbsp;vývody urèenými pro povrchovou montá¾</p-center>



<p><a name="k03"></a></p>
<h1>3. Celá èísla se znaménkem (dvojkový doplnìk)</h1>

<p>Celá èísla se znaménkem jsou v&nbsp;moderních mikroprocesorech prakticky
v¾dy reprezentována <i>ve dvojkovém doplòku</i>, nebo» se jedná o reprezentaci
umo¾òující pou¾ití stejné ALU pro práci s&nbsp;èísly se znaménkem i bez
znaménka. Nejvy¹¹í bit je v&nbsp;tomto pøípadì vyhrazen pro znaménko, pøièem¾
<strong>0</strong> znaèí, ¾e se jedná o kladné èíslo a <strong>I</strong>
naopak oznaèuje èíslo záporné. Záporná èísla mají navíc invertovány v¹echny své
bity (inverzí se vlastnì automaticky nastaví znaménkový bit) a po inverzi je
k&nbsp;nim pøiètena jednièka. Toto na první pohled nelogické uspoøádání
s&nbsp;sebou pøiná¹í øadu výhod, mezi jinými napøíklad tu, ¾e existuje pouze
jeden zpùsob zápisu nuly (nerozli¹uje se kladná a záporná nula), pøi sèítání a
odèítání mù¾e mikroprocesor pou¾ít stejné operace jako v&nbsp;pøípadì
bezznaménkových èísel atd., co¾ si prakticky uká¾eme v&nbsp;následujících
èástech tohoto seriálu. Pøevodní tabulka mezi interní reprezentací
¹estnáctibitové èíselné hodnoty v&nbsp;poèítaèi a jejím dekadickým ekvivalentem
vypadá následovnì:</p>

<table>
<tr><th>Hexadecimální hodnota</th><th>Dekadický ekvivalent</th><th>Poznámka</th></tr>
<tr><td>0000</td><td>     0</td><td>nula je reprezentována jednoznaènì</td></tr>
<tr><td>0001</td><td>     1</td><td></td></tr>
<tr><td>0002</td><td>     2</td><td></td></tr>
<tr><td>....</td><td>    ..</td><td></td></tr>
<tr><td>000f</td><td>    15</td><td></td></tr>
<tr><td>0010</td><td>    16</td><td></td></tr>
<tr><td>....</td><td>    ..</td><td></td></tr>
<tr><td>7ffd</td><td> 32765</td><td></td></tr>
<tr><td>7ffe</td><td> 32766</td><td></td></tr>
<tr><td>7fff</td><td> 32767</td><td>nejvy¹¹í kladné èíslo</td></tr>
<tr><td>8000</td><td>-32768</td><td>nejvy¹¹í záporné èíslo</td></tr>
<tr><td>8001</td><td>-32767</td><td></td></tr>
<tr><td>8002</td><td>-32766</td><td></td></tr>
<tr><td>....</td><td>    ..</td><td></td></tr>
<tr><td>fffc</td><td>    -4</td><td></td></tr>
<tr><td>fffd</td><td>    -3</td><td></td></tr>
<tr><td>fffe</td><td>    -2</td><td></td></tr>
<tr><td>ffff</td><td>    -1</td><td>nejni¾¹í záporné èíslo</td></tr>
</table>

<p>Pov¹imnìte si, ¾e nejvy¹¹í záporné èíslo je v&nbsp;absolutní hodnotì o
jednièku vìt¹í ne¾ nejvy¹¹í kladné èíslo. To je obecná vlastnost systému
dvojkového doplòku a mù¾eme se s&nbsp;ní setkat na mnoha místech poèítaèového
svìta. Napøíklad i u nìkterých vysokoúrovòových programovacích jazykù se pøi
popisu jejich základních datových typù (primitivních typù) tato zákonitost
objevuje.</p>

<image id="6045" />
<p-center>David (Intel 4004)</p-center>

<image id="6046" />
<p-center>A goliá¹ (PA-RISC)</p-center>



<p><a name="k04"></a></p>
<h1>4. ALU a základní matematické operace</h1>

<p>S&nbsp;pomocí aritmeticko-logické jednotky je mo¾né &ndash; samozøejmì
v&nbsp;závislosti na její konstrukci &ndash; provádìt celou øadu aritmetických
operací. Prakticky v¹echny mikroprocesory obsahují instrukci pro souèet obsahu
dvou registrù (mnemotechnická zkratka této instrukce je <strong>ADD</strong>),
popø.&nbsp;souèet obsahu dvou registrù s&nbsp;pøiètením pøenosu (mnemotechnická
zkratka této instrukce je buï <strong>ADC</strong> nebo <strong>ADDC</strong>).
Vìt¹ina mikroprocesorù (s&nbsp;výjimkou napøíklad mikroøadièù øady 8048)
obsahuje i instrukce pro rozdíl obsahu dvou registrù (<strong>SUB</strong>),
popø.&nbsp;rozdíl s&nbsp;pou¾itím pøenosu z&nbsp;pøedchozí operace
(<strong>SBC</strong>, nebo pøi opaèném chápání pøenosu <strong>SBB</strong>).
Spolu se zvy¹ujícím se stupnìm integrace a od ní odvozené mo¾nosti pou¾ití více
logických prvkù se také roz¹iøovaly aritmetické schopnosti ALU, co¾ se
projevilo napøíklad pøidáním násobièky (obsahoval ji napøíklad slavný
mikroprocesor Motorola 6809) a pozdìji dokonce i dìlièky.</p>

<p>Ná¹ demonstraèní mikroprocesor násobièku ani dìlièku neobsahuje, budeme se
tedy muset spokojit se základními aritmetickými operacemi souètu a rozdílu. Jak
si v¹ak uká¾eme v&nbsp;následující èásti tohoto seriálu, je mo¾né násobení a
dìlení naprogramovat pomocí instrukcí souètu a rozdílu doplnìných o aritmetické
posuvy o jeden bit doleva a doprava. Podívejme se tedy, které instrukce slou¾í
v&nbsp;na¹em mikroprocesoru pro provádìní základních aritmetických operací:</p>

<table>
<tr><th>Operaèní kód</th><th>Mnemotechnická zkratka</th><th>Popis instrukce</th></tr>
<tr><td>00</td><td>ADD</td><td>souèet obsahu registrù A a B</td></tr>
<tr><td>01</td><td>ADC</td><td>souèet obsahu registrù s pøenosem</td></tr>
<tr><td>02</td><td>SUB</td><td>rozdíl obsahu registrù A a B</td></tr>
<tr><td>03</td><td>SBB</td><td>rozdíl obsahu registrù s výpùjèkou</td></tr>
<tr><td>04</td><td>INC</td><td>zvìt¹ení obsahu registru A èi B o 1</td></tr>
<tr><td>05</td><td>DEC</td><td>sní¾ení obsahu registru A èi B o 1</td></tr>
</table>



<p><a name="k05"></a></p>
<h1>5. Zvý¹ení èi sní¾ení hodnoty pracovního registru o 1</h1>

<p>Nejjednodu¹¹í jsou poslední dvì uvedené instrukce,
tj.&nbsp;<strong>INC</strong> (inkrementace) a <strong>DEC</strong>
(dekrementace). Instrukce <strong>INC</strong> slou¾í ke zvý¹ení obsahu
pracovního registru <strong>A</strong> èi pracovního registru
<strong>B</strong> o jednièku. V&nbsp;pøípadì, ¾e hodnota daného registru je
<i>po</i> provedení této operace nulová, je nastaven pøíznak <strong>Zero
flag</strong>, èeho¾ se mù¾e vyu¾ít napøíklad pøi tvorbì poèítaných
programových smyèek (tato situace nastane ve chvíli, kdy obsah registru byl
roven 0xffff a po pøiètení a zanedbání pøeteèení se jako výsledek inkrementace
vrátila hodnota 0x0000). Podobný význam má instrukce <strong>DEC</strong>,
která od pracovního registru <strong>A</strong> èi <strong>B</strong> jednièku
naopak odeète a opìt v&nbsp;závislosti na tom, zda je obsah registru nulový,
nastaví pøíznak <strong>Zero flag</strong>. Ani jedna z&nbsp;tìchto dvou
operací nepracuje s&nbsp;pøíznakem <strong>Carry flag</strong> a není to
vlastnì ani nutné.</p>

<image id="6047" />
<p-center>Zvý¹ení hodnoty pracovního registru A o jednièku s&nbsp;nastavením Zero flagu (signály posílané z&nbsp;øadièe nejsou zakresleny)</p-center>

<p>Vzhledem k&nbsp;tomu, ¾e se mikroprocesor musí rozhodnout, který registr
bude inkrementován èi dekrementován, je operaèní kód instrukce doplnìn adresní
èástí, tj.&nbsp;dal¹ím bytem, ve kterém je zapsána hodnota specifikující daný
registr. Jsou pou¾ity stejné adresní kódy, jako u minule popsaných instrukcí
<strong>MOV</strong>, tj.&nbsp;00 pro pracovní registr <strong>A</strong> a 01
pro pracovní registr <strong>B</strong>. Ve strojovém kódu tedy zápis instrukcí
inkrementace a dekrementace vypadá následovnì:</p>

<table>
<tr><th>Strojový kód</th><th>Zápis v assembleru</th><th>Význam</th></tr>
<tr><td>04 00</td><td>INC A</td><td>inkrementace registru A</td></tr>
<tr><td>04 01</td><td>INC B</td><td>inkrementace registru B</td></tr>
<tr><td>05 00</td><td>DEC A</td><td>dekrementace registru A</td></tr>
<tr><td>05 01</td><td>DEC B</td><td>dekrementace registru B</td></tr>
</table>

<p>Pøeva¾ující zpùsob pou¾ití tìchto instrukcí spoèívá v&nbsp;tvorbì poèítaných
programových smyèek a také ve zpracování informací ulo¾ených do polí èi
seznamù. S&nbsp;výhodou je mo¾né pøi programování vyu¾ít faktu, ¾e tyto
instrukce ¾ádným zpùsobem neovlivòují pøíznak <strong>Carry flag</strong>,
který tak mù¾e být pou¾it pro jiné úèely, napøíklad pøi násobení dvou hodnot
pomocí bitových posuvù. Zmìna pøíznaku <strong>Zero flag</strong> je naopak
dùle¾itá, proto¾e slou¾í k&nbsp;tvorbì smyèek s&nbsp;vyu¾itím skokových
instrukcí <strong>JZ</strong> a <strong>JNZ</strong>.</p>

<image id="6048" />
<p-center>Zvý¹ení hodnoty pracovního registru B o jednièku s&nbsp;nastavením Zero flagu</p-center>



<p><a name="k06"></a></p>
<h1>6. Aritmetické instrukce ADD (addition) a ADC (addition with carry)</h1>

<p>Dal¹í aritmetickou instrukcí je instrukce <strong>ADD</strong>, která slou¾í
k&nbsp;souètu obsahu dvou pracovních registrù a ulo¾ení výsledku do jednoho
z&nbsp;tìchto registrù. Vzhledem k&nbsp;tomu, ¾e výsledkem souètu dvou
¹estnáctibitových èísel mù¾e být hodnota, která pøes tento rozsah pøeteèe
(0x8001+0x8001 je vìt¹í ne¾ 0xffff), je pøi sèítání modifikován i obsah
pøíznaku <strong>Carry flag</strong>. Pokud je výsledek men¹í ne¾ 0x10000, je
<strong>Carry flag</strong> nastaven na nulovou hodnotu, pokud dojde
k&nbsp;pøeteèení pøes 0xffff, je <strong>Carry flag</strong> nastaven na
logickou jednièku. Tato instrukce také v&nbsp;závislosti na výsledku souètu
modifikuje pøíznak <strong>Zero flag</strong>: v&nbsp;pøípadì, ¾e výsledek je
roven 0x0000 (popø.&nbsp;pøi pøeteèení 0x10000), je pøíznak <strong>Zero
flag</strong> nastaven na jednièku, ve v¹ech dal¹ích pøípadech je tento pøíznak
nastaven na nulu. Vzhledem k&nbsp;tomu, ¾e instrukce <strong>ADD</strong>
vy¾aduje dva operandy (sèítance) a výsledek se vrací do libovolného pracovního
registru, existují celkem ètyøi varianty této instrukce. Jednotlivé varianty
jsou odli¹eny adresním bytem, podobnì jako u pøedchozích instrukcí:</p>

<table>
<tr><th>Strojový kód</th><th>Zápis v assembleru</th><th>Význam</th></tr>
<tr><td>00 00</td><td>ADD A,A</td><td>A&larr;A+A</td></tr>
<tr><td>00 01</td><td>ADD A,B</td><td>A&larr;A+B</td></tr>
<tr><td>00 10</td><td>ADD B,A</td><td>B&larr;A+B</td></tr>
<tr><td>00 11</td><td>ADD B,B</td><td>B&larr;B+B</td></tr>
</table>

<image id="6049" />
<p-center>Souèet pracovních registrù A a B s&nbsp;ulo¾ením výsledku do registru A a ovlivnìním pøíznakù Carry flag a Zero flag</p-center>

<p>V&nbsp;tabulce uvedené vý¹e mù¾eme vidìt, ¾e první operand instrukce
<strong>ADD</strong> souèasnì urèuje i pracovní registr, do kterého se výsledek
ulo¾í. Tímto zpùsobem bývají zakódovány instrukce u vìt¹iny souèasných
mikroprocesorù, nebo» se tím zkracuje adresní èást instrukce oproti pøípadu,
kdy by musely být uvedeny jak oba vstupní pracovní registry, tak i registr
výstupní (u na¹eho mikroprocesoru to není patrné, proto¾e má pouze dva pracovní
registry, ov¹em napøíklad RISC procesory jich mají 32, 64 èi více).</p>

<image id="6050" />
<p-center>Souèet pracovního registru A se sebou samým s&nbsp;ovlivnìním pøíznakù Carry flag a Zero flag</p-center>



<p><a name="k07"></a></p>
<h1>7. Aritmetická instrukce ADC (addition with carry)</h1>

<p>Druhou "sèítací" instrukcí je aritmetická instrukce <strong>ADC</strong>,
která takté¾ provádí souèet dvou pracovních registrù, ov¹em do souètu vstupuje
i obsah pøíznaku <strong>Carry flag</strong>, tj.&nbsp;místo operace
<i>r=r<sub>1</sub>+r<sub>2</sub></i> je provádìna operace
<i>r=r<sub>1</sub>+r<sub>2</sub>+CF</i>. Tato instrukce se vyu¾ívá napøíklad
pøi implementaci víceslovní aritmetiky, tj.&nbsp;výpoètù, které by v&nbsp;na¹em
pøípadì pøekroèily hranici 16 bitù. V&nbsp;praxi to znamená to, ¾e souèet dvou
tøicetidvoubitových hodnot je proveden dvojicí operací: první operací je
<strong>ADD</strong> (spodních ¹estnáct bitù), druhou operací je
<strong>ADC</strong> (horních ¹estnáct bitù), proto¾e pøi souètu dolní poloviny
32bitového slova mù¾e dojít k&nbsp;pøeteèení, které se promítne do souètu horní
poloviny slova. Víceslovní aritmetiku lze implementovat prakticky na libovolném
mikroprocesoru, tj.&nbsp;napøíklad i "staré" osmibitové mikroprocesory mohou
pracovat s&nbsp;64bitovými èísly &ndash; jedinou nevýhodou bude pomìrnì znaèné
zpomalení v¹ech výpoètù. I instrukce <strong>ADC</strong> obsahuje adresní
èást:</p>

<table>
<tr><th>Strojový kód</th><th>Zápis v assembleru</th><th>Význam</th></tr>
<tr><td>01 00</td><td>ADC A,A</td><td>A&larr;A+A+CF</td></tr>
<tr><td>01 01</td><td>ADC A,B</td><td>A&larr;A+B+CF</td></tr>
<tr><td>01 10</td><td>ADC B,A</td><td>B&larr;A+B+CF</td></tr>
<tr><td>01 11</td><td>ADC B,B</td><td>B&larr;B+B+CF</td></tr>
</table>

<p>Instrukce <strong>ADC</strong> mù¾e v&nbsp;nìkterých pøípadech nahradit
podmínìný skok, napøíklad tehdy, pokud potøebujeme v&nbsp;závislosti na nìjaké
podmínce zvy¹ovat hodnotu pracovního registru. Zde se uplatní souèet
s&nbsp;registrem majícím hodnotu 0, pøièem¾ podmínka je zakódována
v&nbsp;pøíznaku <strong>Carry flag</strong>: provede se instrukce
<i>r=r+0+CF=r+CF</i>.</p>

<image id="6051" />
<p-center>Souèet pracovních registrù A a B s&nbsp;pøiètením pøíznaku pøeteèení, s&nbsp;ulo¾ením výsledku do registru A a ovlivnìním pøíznakù Carry flag a Zero flag</p-center>



<p><a name="k08"></a></p>
<h1>8. Aritmetické instrukce SUB (subtraction) SBB (subtraction with borrow)</h1>

<p>Následuje aritmetická instrukce <strong>SUB</strong>, která pøedstavuje
rozdíl hodnot dvou registrù. V&nbsp;závislosti na pùvodním obsahu obou
registrù, které vstupují do operace rozdílu je nastaven pøíznak <strong>Carry
flag</strong> i <strong>Zero flag</strong> &ndash; první pøíznak je nastaven
v&nbsp;pøípadì, ¾e do¹lo k&nbsp;pøeteèení pøes nulu (0x10-0x20), druhý pøíznak
v&nbsp;pøípadì nulového výsledku (0x10-0x10), co¾ vlastnì znamená, ¾e obsahy
obou registrù, které do operace vstupovaly, jsou shodné. Ze zápisu v¹ech
kombinací této instrukce si v¹imnìte, ¾e zde zále¾í na poøadí operandù (na
rozdíl od instrukce souètu) a také toho, ¾e instrukce <strong>SUB A,A</strong>
a <strong>SUB B,B</strong> vlastnì provádí vynulování obsahu jednoho
z&nbsp;pracovních registrù, co¾ je dùvod, proè ná¹ mikroprocesor neobsahuje
specializovanou instrukci, která by nulování pracovních registrù provádìla.</p>

<table>
<tr><th>Strojový kód</th><th>Zápis v assembleru</th><th>Význam</th></tr>
<tr><td>02 00</td><td>SUB A,A</td><td>A&larr;A-A</td></tr>
<tr><td>02 01</td><td>SUB A,B</td><td>A&larr;A-B</td></tr>
<tr><td>02 10</td><td>SUB B,A</td><td>B&larr;B-A</td></tr>
<tr><td>02 11</td><td>SUB B,B</td><td>B&larr;B-B</td></tr>
</table>

<p>Poslední aritmetickou instrukcí podporovanou na¹ím mikroprocesorem je
instrukce <strong>SBB</strong>. Tato instrukce také provádí výpoèet rozdílu
dvou pracovních registrù, navíc v¹ak od výsledku odeète obsah pøíznaku
<strong>Carry flag</strong> (zde se s&nbsp;ohledem na význam tohoto pøíznaku
místo slova "carry", tj.&nbsp;pøenos, èastìji pou¾ívá slovo "borrow", tj.
výpùjèka). Ve skuteènosti se tedy provádí operace
<i>r=r<sub>1</sub>-r<sub>2</sub>-CF</i>. Je zapotøebí si dát pozor na to, ¾e
nìkteré mikroprocesory (v&nbsp;minulosti napøíklad známý MOS 6502) obsahovaly
instrukci <strong>SBC</strong>, která pracovala s&nbsp;negací <strong>Carry
flagu</strong>, tj.&nbsp;provádìla se operace
<i>r=r<sub>1</sub>-r<sub>2</sub>-neg(CF)</i> (u 6502 byla situace slo¾itìj¹í
v&nbsp;tom, ¾e zde nebyla instrukce <strong>SUB</strong>, co¾ znamenalo, ¾e se
bì¾né odeèítání provádìlo nastavením <strong>Carry flag</strong> do jednièky
následovaným instrukcí <strong>SBC</strong>). I instrukce <strong>SBB</strong>
existuje ve ètyøech variantách odli¹ených adresní èástí:</p>

<table>
<tr><th>Strojový kód</th><th>Zápis v assembleru</th><th>Význam</th></tr>
<tr><td>03 00</td><td>SBB A,A</td><td>A&larr;A-A-CF</td></tr>
<tr><td>03 01</td><td>SBB A,B</td><td>A&larr;A-B-CF</td></tr>
<tr><td>03 10</td><td>SBB B,A</td><td>B&larr;B-A-CF</td></tr>
<tr><td>03 11</td><td>SBB B,B</td><td>B&larr;B-B-CF</td></tr>
</table>

<image id="6052" />
<p-center>Rozdíl pracovních registrù A a B s&nbsp;odeètením pøíznaku pøeteèení, s&nbsp;ulo¾ením výsledku do registru B a ovlivnìním pøíznakù Carry flag a Zero flag</p-center>



<p><a name="k09"></a></p>
<h1>9. Obsah dal¹í èásti tohoto seriálu</h1>

<p>V&nbsp;dal¹í èásti seriálu, ve kterém se vìnujeme funkcím poèítaèe a
pøedev¹ím mikroprocesoru, si popí¹eme v¹echny logické operace provádìné
aritmeticko-logickou jednotkou (ALU). Také si uká¾eme zpùsob pou¾ití operací
pro bitové rotace a posuvy, napøíklad pøi násobení dvou èísel &ndash; tuto
základní aritmetickou operaci toti¾ ná¹ ukázkový mikroprocesor nepodporuje,
podobnì jako mnoho dal¹ích mikroprocesorù a mikroøadièù.</p>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2008</small></p>
</body>
</html>

