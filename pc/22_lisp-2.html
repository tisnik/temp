<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk LISP II</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk LISP (2)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o historii výpoèetní techniky budeme pokraèovat v popisu základù programovacího jazyka LISP. Øekneme si, jakým zpùsobem jsou zapisovány a vyhodnocovány výrazy, jak se pracuje se seznamy a na závìr si uká¾eme, jak lze v LISPu pou¾ívat takzvané speciální formy.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Malá rekapitulace &ndash; programovací jazyk LISP a seznamy</a></p>
<p><a href="#k02">2. Vyhodnocování výrazù LISPem</a></p>
<p><a href="#k03">3. Prefixový zápis aritmetických a relaèních výrazù</a></p>
<p><a href="#k04">4. Ale já chci pou¾ívat &bdquo;lidský&ldquo; zápis aritmetických výrazù!</a></p>
<p><a href="#k05">5. Základní funkce pro práci se seznamy</a></p>
<p><a href="#k06">6. Demonstraèní pøíklady &ndash; pøístup k&nbsp;prvkùm seznamù a zji¹tìní délky seznamu</a></p>
<p><a href="#k07">7. Demonstraèní pøíklady &ndash; predikát LISTP a konstrukce seznamù</a></p>
<p><a href="#k08">8. Speciální formy a vyhodnocování podmínek</a></p>
<p><a href="#k09">9. Literatura a odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2>1. Malá rekapitulace &ndash; programovací jazyk LISP a seznamy</h2>

<p>V&nbsp;pøedchozí èásti seriálu o historii výpoèetní techniky jsme se
seznámili s&nbsp;nìkterými základními vlastnostmi programovacího jazyka
<i>LISP</i>. Øekli jsme si, ¾e z&nbsp;hlediska programátorù se
v&nbsp;LISPovských aplikacích zpracovávají data ulo¾ená v&nbsp;seznamech (odtud
ostatnì pramení i plný název tohoto jazyka: &bdquo;<strong>Lis</strong>t
<strong>P</strong>rocessing&ldquo;), pøièem¾ tyto seznamy mohou obsahovat jak
takzvané atomy (èísla, øetìzce, symboly), tak i dal¹í, rekurzivnì vnoøené
seznamy. Internì, tj.&nbsp;v&nbsp;operaèní pamìti poèítaèe, jsou seznamy
reprezentovány zøetìzenými dvojicemi hodnot (<i>dot-pairs</i>,
<i>teèka-dvojice</i>). Ka¾dý seznam je ukonèen dvojicí, její¾ druhý èlen
obsahuje namísto ukazatele na dal¹í dvojici konstantu <strong>nil</strong>
(tato konstanta je atomem, který se tedy vyhodnocuje v¾dy sám na sebe, souèasnì
se ov¹em takté¾ jedná o seznam, konkrétnì o prázdný seznam, co¾ znamená, ¾e
<strong>nil</strong> má v&nbsp;<i>LISPu</i> zvlá¹tní postavení). Pro pøístup
k&nbsp;prvnímu èlenu teèka-dvojice se pou¾ívá funkce <strong>car</strong>, pro
pøístup ke èlenu druhému funkce <strong>cdr</strong> (názvy tìchto funkcí jsou
odvozeny z&nbsp;názvù makroinstrukcí sálového poèítaèe IBM 704, kde slou¾ily
k&nbsp;pøístupu k&nbsp;jednotlivým èástem 36bitového slova tìchto mainframù).
Následuje pøíklad zápisu seznamu pomocí teèka dvojic, následovaného zkráceným
zápisem seznamu (který je nejpou¾ívanìj¹í) a takté¾ interní reprezentace tohoto
seznamu v&nbsp;operaèní pamìti poèítaèe:</p>

<pre>
; seznam zapsaný pomocí teèka-dvojic
(1.(2.(3.(4.(5.nil)))))

; bì¾ný zpùsob zápisu tého¾ seznamu
(1 2 3 4 5)

; interní struktura seznamu v pamìti
;         .
;        / \
;       1   .
;          / \
;         2   .
;            / \
;           3   .
;              / \
;             4   .
;                / \
;               5   nil
</pre>



<p><a name="k02"></a></p>
<h2>2. Vyhodnocování výrazù LISPem</h2>

<p>Minule jsme si takté¾ øekli, ¾e programy jsou v&nbsp;<i>LISPu</i> zapisovány
&ndash; podobnì jako data, se kterými tyto programy pracují &ndash; takté¾
pomocí seznamù a ¾e interpretry <i>LISPu</i> jsou nìkdy oznaèovány zkratkou
<i>REPL</i>, která naznaèuje, jakým zpùsobem jsou programy,
resp.&nbsp;jednotlivé výrazy, ze kterých se programy skládají, zpracovávány:
Read&ndash;Eval&ndash;Print&ndash;Loop. Ve skuteènosti v¹ak mnoho implementací
<i>LISPu</i> obsahuje i plnohodnotné pøekladaèe, které mnohdy produkují
optimalizovaný kód srovnatelný napøíklad s&nbsp;výsledky Céèkových pøekladaèù.
Dnes si zpùsob zápisu programù popí¹eme do vìt¹ích podrobností. Základem
interpretace ka¾dého LISPovského programu je naètení a rozpoznání jednoho
výrazu (<i>read</i>), vyhodnocení tohoto výrazu (<i>eval</i>) a následný tisk
výsledné hodnoty výrazu na standardní výstup (<i>print</i>). Pravidla pro
vyhodnocení výrazù (nìkdy se té¾ mù¾eme setkat s&nbsp;termínem
&bdquo;vyhodnocení forem&ldquo;) jsou v&nbsp;LISPu velmi jednoduchá a
pøímoèará, na rozdíl od mnoha jiných programovacích jazykù. Tato pravidla lze
ve zjednodu¹ené podobì sepsat do nìkolika bodù:</p>

<ol>

<li>èísla a øetìzce jsou vyhodnoceny samy na sebe (co¾ je logické &ndash; jedná
se o dále nedìlitelné objekty)</li>

<li>hodnotou symbolu je objekt, který je na tento symbol navázán (analogie
z&nbsp;jiných programovacích jazykù &ndash; hodnotou promìnné zapsané svým
jménem je hodnota ulo¾ená do promìnné)</li>

<li>seznamy jsou vyhodnocovány tak, ¾e se první prvek seznamu chápe jako jméno
funkce (èi speciální formy), které je pøedán zbytek seznamu jako parametry této
funkce (formy)</li>

<li>pokud seznam obsahuje podseznamy, jsou tyto podseznamy vyhodnoceny
nejdøíve, pøièem¾ úroveò rekurzivního zanoøování pøi vyhodnocování podseznamù
není teoreticky omezena (tj.&nbsp;podseznamy lze vnoøovat do témìø libovolné
úrovnì)</li>

</ol>

<p>Uka¾me si vyhodnocování výrazù na nìkolika pøíkladech. První øádek uvedený
pod poznámkou (uvozenou znakem <strong>;</strong>) pøedstavuje text zapsaný
u¾ivatelem na klávesnici, øádek druhý vypisuje samotný LISP:</p>

<pre>
; vyhodnocení èíselné hodnoty (konstanty)
42
42

; vyhodnocení speciální konstanty nil
nil
NIL

; nil je ekvivalentní prázdnému seznamu
()
NIL

; vyhodnocení øetìzce
"www.root.cz"

; vyhodnocení seznamu obsahujícího jako první prvek funkci
(max 10 20)
20

; vyhodnocení seznamu obsahujícího dal¹í seznamy (ka¾dý podseznam samozøejmì znamená volání funkce)
(max (min 10 20) (min 30 40))
30
</pre>

<a href="http://i.iinfo.cz/images/118/ibm07.jpg"><img src="http://i.iinfo.cz/images/118/ibm07-prev.jpg" alt="ibm07" height="270" width="331" /></a>
<p><i>Obrázek 1: Sálový poèítaè IBM-704, na nìm¾ vznikal první interpret programovacího jazyka LISP.</i></p>



<p><a name="k03"></a></p>
<h2>3. Prefixový zápis aritmetických a relaèních výrazù</h2>

<p>Zatímco v&nbsp;naprosté vìt¹inì &bdquo;mainstreamových&ldquo; programovacích
jazykù, jakými jsou napøíklad <i>Céèko</i>, <i>Java</i>, <i>JavaScript</i> èi
<i>Python</i>, se aritmetické a logické výrazy zapisují v&nbsp;takzvané
<i>infixové notaci</i>, pøi ní¾ jsou binární operátory zapisovány mezi dvojici
operandù, tvùrci jazyka <i>LISP</i> se od tohoto zpùsobu zápisu distancovali
&ndash; namísto toho jsou v&nbsp;<i>LISPu</i> v¹echny základní aritmetické i
logické (a samozøejmì té¾ relaèní) operace zapisovány jako volání funkcí
(pøesnìji øeèeno se skuteènì jedná o funkce), tj.&nbsp;v¾dy v&nbsp;<i>prefixové
podobì</i>. Dùvodù, proè byla zvolena tato forma zápisu výrazù, je více. Prvním
dùvodem je fakt, ¾e syntaxe <i>LISPu</i> byl navrhována s&nbsp;tím, ¾e pozdìji
dojde k&nbsp;její zmìnì, tj.&nbsp;samotná syntaxe nebyla pro tvùrce tohoto
programovacího jazyka tak prioritní jako jeho sémantika (paradoxní pøitom je,
¾e se nakonec syntaxe <i>LISPu</i> nezmìnila, takzvané M-výrazy se nedoèkaly
vìt¹ího roz¹íøení, podobnì jako dal¹í snahy o úpravu syntaxe <i>LISPu</i> tak,
aby se eliminovalo mno¾ství závorek èi právì prefixový zápis aritmetických
výrazù).</p>

<p>Druhý dùvod spoèíval v&nbsp;tom, ¾e zavedení infixových operátorù by do
jazyka zavádìlo dal¹í komplikace: musely by se napøíklad øe¹it a pøesnì
specifikovat priority operací (a u nìkterých operací i jejich asociativita), se
zapsanými výrazy by se slo¾itìji provádìly rùzné symbolické manipulace
(integrace, derivace, zjednodu¹ování výrazù), infixové operátory by nebylo
mo¾né pøedávat jako parametry do jiných funkcí atd. Vzhledem k&nbsp;tomu, ¾e
aritmetické operátory jsou v&nbsp;<i>LISPu</i> zapisovány jako volání funkcí,
musí se znak èi jméno pøíslu¹ného operátoru uvádìt ve vyhodnocovaném seznamu na
prvním místì, podobnì jako jméno jakékoli jiné funkce. V¹echny dílèí podvýrazy
se samozøejmì vyhodnocují døíve ne¾ celý výraz, co¾ plnì koresponduje
s&nbsp;pravidly, která jsme si uvedli v&nbsp;pøedchozí kapitole (podvýraz je
zapsán formou volání nìjaké funkce). Vìt¹ina aritmetických funkcí není omezena
pouze na dva parametry, co¾ znamená, ¾e je napøíklad mo¾né zavoláním jedné
funkce nazvané <strong>+</strong> seèíst i více ne¾ dvì numerické hodnoty:</p>

<pre>
; zaèneme pozvolna jako na základní ¹kole :-)
(+ 1 1)
2

; operace rozdílu - druhý argument funkce je odeèten od prvního
(- 1 2)
-1

; souèet øady èísel
(+ 1 2 3 4 5 6 7 8 9 10)
55

; ní¾e uvedený výraz v infixové notaci odpovídá: 1-2-3-4-5....-10:
(- 1 2 3 4 5 6 7 8 9 10)
-53

; POZOR - závorky v LISPu nemají mnoho spoleèného
; s vyjádøením priority aritmetických operací
; (nelze je pou¾ít tak volnì jako napøíklad v céèku)
(* (+ 1 2) (+ 3 4))
21

(+ (* 1 2) (* 3 4))
14

; Nìkteré implementace LISPu, napøíklad Common Lisp,
; doká¾ou pracovat se zlomky, tj. sna¾í se racionální
; èísla vyjádøit formou zlomku (ideální jazyk do ¹kol :-)
(/ 1 2)
1/2

(/ 1 2 3)
1/6

(/ 3 2)
3/2

; zkusíme výpoèet slo¾itìj¹ího zlomku
(/ (+ 1 2) (+ 3 4))
3/7

; neracionální (reálná) èísla se vypisují tak, jak to
; známe z ostatních programovacích jazykù (samozøejmì
; v pøípadì speciálních po¾adavkù programátora lze pou¾ít
; rùzné formátovací funkce na úpravu výstupu)
(* 0.3 (/ (+ 1 2) (+ 3 4)))
0.12857144
</pre>

<p>Programovací jazyk <i>LISP</i> obsahuje i úplnou sadu relaèních operátorù,
které v&nbsp;závislosti na hodnotách pøedaných parametrù (operandù) vrací
hodnotu <strong>T</strong> (pravda) èi <strong>nil</strong> (nepravda).
Pov¹imnìte si, ¾e konstanta <strong>nil</strong> má v&nbsp;LISPu pomìrnì velké
mno¾ství rùzných významù:</p>

<pre>
; porovnání dvou èíselných hodnot
; relace "men¹í ne¾"
(&lt; 1 2)
T

; relace "vìt¹í ne¾"
(&gt; 1 2)
NIL

; relace "men¹í nebo rovno"
(&lt;= 1 2)
T

; relace "vìt¹í nebo rovno"
(&gt;= 1 2)
NIL

; porovnání dvou výrazù na ekvivalenci
(equal 1 2)
NIL

(equal 1 1)
T

; podvýrazy se nejprve vyhodnotí a posléze se porovnají
; vyhodnocené výsledky (v tomto pøípadì dva atomy)
(equal (+ 1 1) (/ 4 2))
T

; na ekvivalenci lze porovnávat i seznamy, nikoli pouze atomy
(equal '(1 2) '(1 2))
T

(equal '(1 2) '(2 1))
NIL

; nil se sice v nìkterých pohledech podobá klíèovému slovu
; NULL z SQL ov¹em zpùsob vyhodnocování této konstanty
; v LISPovských výrazech je ponìkud odli¹ný
(equal nil nil)
T
</pre>



<p><a name="k04"></a></p>
<h2>4. Ale já chci pou¾ívat &bdquo;lidský&ldquo; zápis aritmetických výrazù!</h2>

<p>V&nbsp;pøípadì, ¾e se má v&nbsp;nìjaké <i>LISPovské</i> aplikaci pou¾ít
vìt¹í mno¾ství výpoètù, je¾ by mohly být pøi pou¾ití prefixové notace
nepøehledné, je mo¾né pou¾ít hned nìkolik knihoven, které slou¾í
k&nbsp;transformaci výrazù zapsaných infixovì (&bdquo;tak jak nás to uèili ve
¹kole&ldquo;) do prefixové podoby. Nìkteré z&nbsp;tìchto knihoven dokonce
doká¾ou výrazy rùzným zpùsobem zjednodu¹ovat èi kombinovat. Napøíklad knihovna
(spí¹e knihovnièka, proto¾e se skládá jen z&nbsp;nìkolika málo funkcí a maker)
<a href="http://folk.uio.no/jornv/infpre/infpre.lisp">infpre</a> urèená pro
Common Lisp nabízí u¾ivatelùm funkci <strong>infix->prefix</strong> (ano, i
takové názvy funkcí je mo¾né v&nbsp;LISPu pou¾ít, a to z&nbsp;toho dùvodu, ¾e
znaky <strong>-</strong> a <strong>&gt;</strong> nemají díky absenci operátorù
¾ádný speciální význam), kterou lze pou¾ít zpùsobem ukázaným na následujícím
jednoduchém pøíkladu. Pov¹imnìte si, ¾e mezi operandy a operátory musí být
zapsány mezery nebo» se jedná o prvky seznamù (první seznam obsahuje sedm atomù
&ndash; ètyøi èísla a tøi symboly):</p>

<pre>
(infix-&gt;prefix '(1 + 2 * 3 + 4) '(+ *))
(+ 1 (* 2 3) 4)
</pre>

<p>Z&nbsp;pøíkladu je patrné, ¾e funkce <strong>infix-&gt;prefix</strong>
vy¾aduje dva parametry. Prvním parametrem je seznam obsahující zapsaný
aritmetický (èi jakýkoli jiný!) výraz, druhým parametrem seznam, v&nbsp;nìm¾
jsou ulo¾eny pou¾ité operátory. Poøadí operátorù ve druhém seznamu urèuje
jejich prioritu, co¾ znamená, ¾e s&nbsp;pomocí funkce
<strong>infix-&lt;prefix</strong> lze vytváøet i zcela nová pravidla pro
vyèíslování aritmetických výrazù (postaèuje pouze nadefinovat pøíslu¹né funkce
a urèit priority jednotlivých operátorù). Ve vý¹e uvedeném demonstraèním
pøíkladu mohou pozorného ètenáøe pøekvapit apostrofy zapsané pøed seznam
pøedstavující aritmetický výraz i pøed seznam obsahující pou¾ité operátory.
Tyto apostrofy zabraòují tomu, aby se interpret jazyka <i>LISP</i> sna¾il
seznamy vyhodnotit, co¾ by nutnì skonèilo chybovým hlá¹ením, proto¾e 1 (první
prvek prvního seznamu) zajisté není jménem funkce, ale atom. Uvedení apostrofu
(èi pou¾ití speciální formy <strong>quote</strong> &ndash; viz dal¹í text)
zabraòuje, aby se interpretr <i>LISPu</i> sna¾il seznam vyhodnotit, jedná se
tedy o opak funkce <strong>eval</strong>.</p>



<p><a name="k05"></a></p>
<h2>5. Základní funkce pro práci se seznamy</h2>

<p>Z&nbsp;popisu programovacího jazyka <i>LISP</i> uvedeného v&nbsp;pøedchozích
kapitolách ji¾ víme, jakým zpùsobem se v&nbsp;tomto jazyku zapisují seznamy a
dokonce známe i dvì funkce slou¾ící pro získání prvního prvku seznamu
(<strong>car</strong>) a naopak zbytku seznamu bez jeho prvního prvku
(<strong>cdr</strong>). Vzhledem k&nbsp;tomu, ¾e práce se seznamy tvoøí pomìrnì
podstatnou èást èinnosti programátorù pøi psaní aplikací, obsahuje programovací
jazyk <i>LISP</i> i mnohé dal¹í funkce, s&nbsp;jejich¾ pomocí je mo¾né se
seznamy rùzným zpùsobem pracovat. Nìkteré z&nbsp;nejèastìji pou¾ívaných funkcí
jsou vypsány v&nbsp;následující tabulce. Jedná se o funkce dostupné
v&nbsp;dialektu Common Lisp, proto se v&nbsp;nìkterých jiných dialektech mù¾ete
setkat s&nbsp;odli¹ným pojmenování nìkterých funkcí (napøíklad se namísto
predikátu <strong>LISTP</strong> pou¾ívá <strong>LIST?</strong>):</p>

<table>
<tr><th>Jméno funkce</th><th>Význam</th></tr>
<tr><td>CAR</td><td>vrací první prvek seznamu</td></tr>
<tr><td>CDR</td><td>vrací zbytek seznamu bez prvního prvku</td></tr>
<tr><td>CADR</td><td>odpovídá (CAR (CDR seznam))</td></tr>
<tr><td>CDAR</td><td>odpovídá (CDR (CAR seznam))</td></tr>
<tr><td>C....R</td><td>dal¹í mo¾né kombinace písmen A a D</td></tr>
<tr><td>CONS</td><td>základní funkce &ndash; pøidání dal¹ího elementu do seznamu popø. vytvoøení teèka-dvojice</td></tr>
<tr><td>LAST</td><td>vrací poslední prvek seznamu</td></tr>
<tr><td>NTH</td><td>vrací n-tý prvek seznamu</td></tr>
<tr><td>LENGTH</td><td>zji¹tìní délky seznamu</td></tr>
<tr><td>LIST</td><td>vytvoøí nový seznam</td></tr>
<tr><td>APPEND</td><td>kombinace více seznamù</td></tr>
<tr><td>LISTP</td><td>predikát, který vrací <strong>T</strong> nebo <strong>nil</strong> v&nbsp;závislosti na tom, zda je parametrem seznam èi jiný objekt</td></tr>
</table>



<p><a name="k06"></a></p>
<h2>6. Demonstraèní pøíklady &ndash; pøístup k&nbsp;prvkùm seznamù a zji¹tìní délky seznamu</h2>

<p>Uka¾me si pou¾ití vý¹e uvedených funkcí na jednoduchých demonstraèních
pøíkladech. Pou¾ití apostrofu pøed ètyøprvkovým seznamem opìt zabraòuje tomu,
aby se interpretr sna¾il seznam vyhodnotit, tj.&nbsp;volat (neexistující)
funkci <strong>a</strong> s&nbsp;parametry <strong>b, c, d</strong>.</p>

<pre>
(car '(a b c d))
A

(cdr '(a b c d))
(B C D)

; cadr odpovídá výrazu (car (cdr seznam))
(cadr '(a b c d))
B
(car (cdr '(a b c d)))
B

(cdar '(a b c d))
nelze vyhodnotit, proto¾e se volá funkce CDR na atom A

; pozor - zde Common Lisp vrací jednoprvkový seznam
(last '(a b c d))
(D)

; prvky seznamu jsou poèítány od nuly
(nth 0 '(a b c d))
A

(nth 2 '(a b c d))
C

; pokus o pøístup k neexistujícímu prvku seznamu
(nth 4 '(a b c d))
NIL
</pre>

<p>Zji¹tìní délky seznamu:</p>

<pre>
(length '(a b c d))
4
</pre>



<p><a name="k07"></a></p>
<h2>7. Demonstraèní pøíklady &ndash; predikát LISTP a konstrukce seznamù</h2>

<p>Následují pøíklady pou¾ití predikátu <strong>LISTP</strong>. Vzhledem
k&nbsp;tomu, ¾e je <i>LISP</i> dynamicky typovaný jazyk, pou¾ívají se predikáty
v&nbsp;nìm napsaných aplikacích pomìrnì èasto:</p>

<pre>
; test, zda je jednièka (tj. atom) seznamem
(listp 1)
NIL

; test, zda je výsledek souètu dvou èísel seznamem
(listp (+ 1 2))
NIL

; test, zda je symbol A (atom) seznamem
(listp 'A)
NIL

; (a b c d) je zcela jistì seznam
(listp '(a b c d))
T

; i prázdný seznam je seznam :-)
(listp '())
T

; prázdný seznam a nil jsou ekvivalentní
(listp 'nil)
T

; nil se vyhodnocuje samo na sebe a navíc je
; ekvivalentní s prázdným seznamem - z toho
; vyplývá, ¾e se pøed nìj nemusí psát apostrof,
; proto¾e se nemusíme "bát" vyhodnocení nil
; (tro¹ku se nám to zaèíná komplikovat :-)
(listp nil)
T
</pre>

<p>Konstrukce seznamù mù¾e být na první pohled ponìkud slo¾itìj¹í, zejména
v&nbsp;pøípadì pou¾ití funkce <strong>cons</strong> (<i>constructor</i>). Kdy¾
si v¹ak uvìdomíme, ¾e tato funkce nedìlá nic jiného ne¾ konstrukci
teèka-dvojice z&nbsp;obou pøedaných parametrù, je její chování zøejmé:</p>

<pre>
; vytvoøení následující pamì»ové struktury
;   .
;  / \
; A   B
;
(cons 'a 'b)
(A . B)

; vytvoøení jednoprvkového seznamu ze symbolu (atomu)
; vytvoøí se tato struktura:
;   .
;  / \
; A   nil
;
(cons 'a nil)
(A)

; slo¾itìj¹í pøíklady
(cons '(a b) 'c)
((A B) . C)
; výsledkem je následující struktura
;       .
;      / \
;     .   C
;    / \
;   A   .
;      / \
;     B   nil

; tento pøíklad je zajímavý, proto¾e první i druhá èást
; vytvoøené teèka dvojice je sama o sobì seznamem
(cons '(a b) '(c d))
((A B) C D)

; asi nejtypiètìj¹í pou¾ití funkce cons: pøidání
; prvku na zaèátek seznamu
(cons 'a '(b c d))
(A B C D)
; výsledkem je následující struktura:
;     .
;    / \
;   A   .
;      / \
;     B   .
;        / \
;       C   .
;          / \
;         D   nil

; pokus o pøidání jediného prvku na konec seznamu
; pomocí funkce cons se nepodaøí
(cons '(a b c) 'd)
((A B C) . D)
; výsledkem je následující struktura
;       .
;      / \
;     .   D
;    / \
;   A   .
;      / \
;     B   .
;        / \
;       C   nil
; která se seznamu podobá jen velmi vzdálenì

; funkce append je v tomto pøípadì výhodnìj¹í,
; jen si musíme dát pozor na to, ¾e se spojují
; dva seznamy, nikoli seznam a atom
(append '(a b c) '(d))
</pre>



<p><a name="k08"></a></p>
<h2>8. Speciální formy a vyhodnocování podmínek</h2>

<p>Poslední dùle¾itou vlastností jazyka <i>LISP</i>, s&nbsp;ní¾ se dnes
seznámíme, je pou¾ití takzvaných <i>speciálních forem</i>. Ze syntaktického
hlediska jsou speciální formy zapisovány naprosto stejným zpùsobem jako bì¾né
funkce, ov¹em existuje zde jeden významný rozdíl &ndash; zatímco u funkcí jsou
v¹echny jejich parametry nejdøíve vyhodnoceny, u speciálních forem
k&nbsp;tomuto vyhodnocení obecnì nedochází, resp.&nbsp;jsou vyhodnoceny pouze
nìkteré parametry (které konkrétnì, to závisí na tom, o jakou speciální formu
se jedná). K&nbsp;èemu jsou speciální formy dobré? Typickým pøíkladem je zápis
podmínìných blokù kódu. V&nbsp;tomto pøípadì potøebujeme, aby se nìjaká èást
programu vykonala pouze v&nbsp;pøípadì, ¾e je splnìna (popø.&nbsp;nesplnìna)
nìjaká podmínka, v&nbsp;opaèném pøípadì nemá být tato èást programu vùbec
vykonána. Pomocí bì¾ných funkcí by nebylo mo¾né tuto funkcionalitu splnit,
proto¾e by kód (pøedaný jako parametr &ndash; jinou mo¾nost v&nbsp;LISPu
ostatnì nemáme) vykonal je¹tì pøed zavoláním &bdquo;podmínkové&ldquo; funkce.
Z&nbsp;toho vyplývá, ¾e samotná podmínka (i kdy¾ se syntakticky podobá volání
funkce) je speciální formou.</p>

<p>Ve vìt¹inì implementací jazyka <i>LISP</i> existuje speciální forma
<strong>if</strong>, která oèekává tøi parametry:</p>

<ol>
<li>podmínku (funkci, která se vyhodnotí na <strong>T</strong> èi <strong>nil</strong></li>
<li>funkci zavolanou v&nbsp;pøípadì, ¾e je podmínka splnìna</li>
<li>funkci zavolanou v&nbsp;pøípadì, ¾e podmínka není splnìna</li>
</ol>

<p>Pøíklady pou¾ití speciální formy <strong>if</strong>:</p>

<pre>
; na základì podmínky se vyhodnotí (a vrátí jako výsledek)
; buï øetìzec "mensi" nebo "vetsi"
(if (&lt; 1 2) "mensi" "vetsi")
"mensi"

(if (&gt; 1 2) "mensi" "vetsi")
"vetsi"

; test na ekvivalenci
(if (equal 1 2) "rovno" "nerovno")
"nerovno"

; test na ekvivalenci
(if (equal 1 1) "rovno" "nerovno")
"rovno"

; pou¾ití slo¾itìj¹ích funkcí ve vìtvi "then" a "else"
(if (equal 1 1) (+ 10 20) (/ 10 20))
30
(if (equal 1 2) (+ 10 20) (/ 10 20))
1/2

; samotná speciální forma if mù¾e být volána uvnitø slo¾itìj¹ího výrazu
(* 84 (if (equal 1 2) (+ 10 20) (/ 10 20)))
42

; je¹tì jste se neztratili v závorkách? Zkusíme tedy vnoøenou
; speciální formu if:
(* 112 (if (&lt; (/ 2 3) (* 2 3)) (if nil (+ 10 20) (- 1 5/8)) (/ 10 20)))
42
; (¾e by Velká otázka znìla právì takto?)
</pre>

<p>Následující demonstraèní pøíklad èeká po svém spu¹tìní na vstup od
u¾ivatele, proto¾e se volá funkce <strong>read</strong> (to je ono první
písmeno v&nbsp;oznaèení REPL). V&nbsp;pøípadì, ¾e u¾ivatel zapí¹e na standardní
vstup symbol <strong>a</strong> èi <strong>A</strong>, je zavolána funkce
<strong>print</strong>, v&nbsp;opaèném pøípadì je zavolána funkce
<strong>format-disk</strong> (která neexistuje :-). Pov¹imnìte si, ¾e pokud
u¾ivatel zadá symbol <strong>A</strong> èi <strong>a</strong>, je interpretru
<i>LISPu</i> úplnì jedno, ¾e funkce <strong>format-disk</strong> ve skuteènosti
neexistuje, proto¾e se ji ani nepokusí vykonat:</p>

<pre>
(if (equal (read) 'A) (print "v poradku") (format-disk))
</pre>

<p>S&nbsp;dal¹ími speciálními formami se seznámíme v&nbsp;následující èásti
seriálu.</p>



<p><a name="k09"></a></p>
<h2>9. Literatura a odkazy na Internetu</h2>

<ol>

<li>McCarthy<br />
<i>&bdquo;Recursive functions of symbolic expressions and their computation by machine, part I&ldquo;</i><br />
1960
</li>

<li>Guy L. Steele<br />
<i>&bdquo;History of Scheme&ldquo;</i><br />
2006, Sun Microsystems Laboratories
</li>

<li>
Koláø J., Muller K.:<br />
<i>&bdquo;Speciální programovací jazyky&ldquo;</i><br />
Praha 1981
</li>

<li>
<i>&bdquo;AutoLISP Release 9, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., October 1987
</li>

<li>
<i>&bdquo;AutoLISP Release 10, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., September 1988
</li>

<li>McCarthy, John; Abrahams, Paul W.; Edwards, Daniel J.; Hart, Timothy P.; Levin, Michael I.<br />
<i>&bdquo;LISP 1.5 Programmer's Manual&ldquo;</i><br />
MIT Press. ISBN 0 262 130 1 1 4
</li>

<li>Carl Hewitt; Peter Bishop and Richard Steiger<br />
<i>&bdquo;A Universal Modular Actor Formalism for Artificial Intelligence&ldquo;</i><br />
1973
</li>

<li>Feiman, J.<br />
<i>&bdquo;The Gartner Programming Language Survey (October 2001)&ldquo;</i><br />
Gartner Advisory
</li>

<li>Lisp (programming language)<br />
<a href="http://en.wikipedia.org/wiki/Lisp_(programming_language)">http://en.wikipedia.org/wiki/Lisp_(programming_language)</a>
</li>

<li>On Lisp<br />
<a href="http://paulgraham.com/onlisptext.html?asdf">http://paulgraham.com/onlisptext.html?asdf</a>
</li>

<li>Lambda calculus<br />
<a href="http://en.wikipedia.org/wiki/Lambda_calculus">http://en.wikipedia.org/wiki/Lambda_calculus</a>
</li>

<li>A Short Introduction to the Lambda Calculus<br />
<a href="http://www.cs.bham.ac.uk/~axj/pub/papers/lambda-calculus.pdf">http://www.cs.bham.ac.uk/~axj/pub/papers/lambda-calculus.pdf</a>
</li>

<li>A Tutorial Introduction to the Lambda Calculus<br />
<a href="http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf">http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf</a>
</li>

<li>Scheme (programming language)<br />
<a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)">http://en.wikipedia.org/wiki/Scheme_(programming_language)</a>
</li>

<li>An Introduction to Scheme and its Implementation<br />
<a href="ftp://ftp.cs.utexas.edu/pub/garbage/cs345/schintro-v14/schintro_toc.html">ftp://ftp.cs.utexas.edu/pub/garbage/cs345/schintro-v14/schintro_toc.html</a>
</li>

<li>The latest version of the Scheme standard: R6RS<br />
<a href="http://www.r6rs.org/">http://www.r6rs.org/</a>
</li>

<li>Humor on Computers, Systems and Programming<br />
<a href="http://www-crypto.htw-saarland.de/weber/misc/programming.html">http://www-crypto.htw-saarland.de/weber/misc/programming.html</a>
</li>

<li>Teach Yourself Scheme in Fixnum Days<br />
<a href="http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme.html">http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme.html</a>
</li>

<li>AutoLISP<br />
<a href="http://en.wikipedia.org/wiki/AutoLISP">http://en.wikipedia.org/wiki/AutoLISP</a>
</li>

<li>Rosetta Code &ndash; Category:Lisp<br />
<a href="http://rosettacode.org/wiki/Category:Lisp">http://rosettacode.org/wiki/Category:Lisp</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2010</small></p>
</body>
</html>

