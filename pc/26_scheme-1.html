<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>'(Programovací (cons 'jazyk 'Scheme))</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>'(Programovací (cons 'jazyk 'Scheme))</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;dne¹ní èásti seriálu o historii výpoèetní techniky se zaèneme zabývat jedním zajímavým dialektem programovacího jazyka LISP. Tento známý dialekt, který se mj.&nbsp;pomìrnì intenzivnì pou¾ívá pøi výuce programování, se jmenuje Scheme.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyk Scheme &ndash; cesta k&nbsp;&bdquo;èist¹ímu&ldquo; LISPu</a></p>
<p><a href="#k02">2. Lambda Papers</a></p>
<p><a href="#k03">3. Tajemná zkratka RnRS</a></p>
<p><a href="#k04">4. Základní vlastnosti programovacího jazyka Scheme</a></p>
<p><a href="#k05">5. Koncová rekurze (tail-recursion)</a></p>
<p><a href="#k06">6. Nìkteré rozdíly mezi LISPem a Scheme</a></p>
<p><a href="#k07">7. Obsah následující èásti seriálu</a></p>
<p><a href="#k08">8. Literatura</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2>1. Programovací jazyk Scheme &ndash; cesta k&nbsp;&bdquo;èist¹ímu&ldquo; LISPu</h2>

<p>V&nbsp;dne¹ní èásti seriálu o historii výpoèetní techniky se seznámíme se
základy programovacího jazyka <i>Scheme</i>, který je jednodu¹¹ím a
v&nbsp;nìkterých ohledech i èist¹ím dialektem jazyka <i>LISP</i>. Pùvodními
autory programovacího jazyka <i>Scheme</i> jsou <i>Guy Lewis Steele</i> a
<i>Gerald Jay Sussman</i> (Steele and Sussman, nìkdy té¾ zkracováno na S and
S), kteøí v&nbsp;dobì návrhu tohoto jazyka pracovali ve slavném
Massachussetském technologickém institutu (MIT). První verze jazyka
<i>Scheme</i> byla v&nbsp;prùbìhu roku 1975 naprogramována v&nbsp;samotném
LISPu, konkrétnì v&nbsp;MacLispu. Název tohoto dialektu programovacího jazyka
LISP ov¹em nemá nic spoleèného s&nbsp;poèítaèi firmy Apple, jednalo se o verzi
LISPu vytvoøenou takté¾ na MIT, která byla pùvodnì urèena pro poèítaèe
<i>PDP-10</i> a operaèní systém <i>Multics</i> &ndash; viz té¾ úvodní díly
tohoto seriálu, v&nbsp;nich¾ byla struènì popsána historie vzniku operaèního
systému <i>Unix</i> i souvisejících technologií.</p>

<p>Guy Steele spolu s&nbsp;Geraldem Sussmanem chtìli nový jazyk pou¾ít pro
zkoumání vlastností takzvaných <i>aktorù</i>, které se v&nbsp;dne¹ní dobì,
tj.&nbsp;celých 35 let po vzniku jazyka <i>Scheme</i>, opìt tì¹í zvý¹enému
zájmu vìdcù i programátorù, pøedev¹ím díky stále vìt¹ímu dùrazu na tvorbu
systémù, v&nbsp;nich¾ je spou¹tìno velké mno¾ství paralelnì bì¾ících a vzájemnì
kooperujících procesù (aktory je mo¾né pova¾ovat za speciální formu
<i>uzávìrù</i> &ndash; <i>closures</i>, ostatnì právì nutnost podpory uzávìrù
ve <i>Scheme</i> pomìrnì zásadnì ovlivnilo jeho návrh, zejména odli¹ný zpùsob
urèování rozsahu platnosti objektù). Výsledkem jejich snahy byl v&nbsp;mnoha
ohledech minimalistický programovací jazyk podporující rùzná paradigmata
programování, ov¹em zamìøený pøedev¹ím na paradigma funkcionální. Pùvodnì se
tento nový programovací jazyk jmenoval <i>SCHEMER</i>, ov¹em systém souborù
pou¾ívaný operaèním systémem ITS na PDP-10, na nìm¾ byly ulo¾eny zdrojové kódy
interpretru, omezoval délku názvù na ¹est znakù, tak¾e se postupnì název
zkrátil ze <i>SCHEMER</i> a <i>Scheme</i>. Oba autoøi následnì zveøejnili popis
syntaxe a pøedev¹ím sémantiky nového programovacího jazyka v&nbsp;sérii èlánkù,
které se dnes souhrnnì nazývají &bdquo;Lambda Papers&ldquo;.</p>

<p><img src="http://i.iinfo.cz/images/315/hist26-1.jpg" alt="hist26" height="250" width="177" /></p>



<p><a name="k02"></a></p>
<h2>2. Lambda Papers</h2>

<p>První èlánek o programovacím jazyku <i>Scheme</i>, který mìl pomìrnì velký
vliv na dal¹í vývoj i chápání významu programovacích jazykù z&nbsp;teoretického
i praktického hlediska, se jmenoval &bdquo;Scheme: an Interpreter for Extended
Lambda Calculus&ldquo;. Po tomto èlánku následovala dvojice neménì dùle¾itých
publikací s&nbsp;v¹eøíkajícími názvy &bdquo;Lambda: The Ultimate
Imperative&ldquo; a &bdquo;Lambda: The Ultimate Declarative&ldquo;
s&nbsp;popisem toho, jakým zpùsobem je mo¾né ve <i>Scheme</i> nahrazovat bì¾né
programové konstrukce známé napøíklad z&nbsp;tehdy pou¾ívaných imperativních
programovacích jazykù (céèka, Fortranu, Algolu, posléze i Pascalu atd.).
V&nbsp;následující tabulce jsou vypsány v¹echny publikace Guye Steela a Geralda
Sussmana vydávané v&nbsp;letech 1975 a¾ 1980, které se dnes souhrnnì nazývají
<i>Lambda Papers</i> (<a
href="http://library.readscheme.org/page1.html">http://library.readscheme.org/page1.html</a>).
I pøes svoje stáøí jsou tyto publikace stále dùle¾itou souèástí celého oboru
IT:</p>

<table>
<tr><th>Rok vydání</th><th>Název publikace</th></tr>
<tr><td>1975</td><td>Scheme: An Interpreter for Extended Lambda Calculus</td></tr>
<tr><td>1976</td><td>Lambda: The Ultimate Imperative</td></tr>
<tr><td>1976</td><td>Lambda: The Ultimate Declarative</td></tr>
<tr><td>1977</td><td>Debunking the 'Expensive Procedure Call' Myth, or, Procedure Call Implementations Considered Harmful, or, Lambda: The Ultimate GOTO</td></tr>
<tr><td>1978</td><td>The Art of the Interpreter or, the Modularity Complex (Parts Zero, One, and Two)</td></tr>
<tr><td>1978</td><td>RABBIT: A Compiler for SCHEME</td></tr>
<tr><td>1979</td><td>Design of LISP-based Processors, or SCHEME: A Dielectric LISP, or Finite Memories Considered Harmful, or LAMBDA: The Ultimate Opcode</td></tr>
<tr><td>1980</td><td>Compiler Optimization Based on Viewing LAMBDA as RENAME + GOTO</td></tr>
<tr><td>1980</td><td>Design of a Lisp-based Processor</td></tr>
</table>

<p><a href="http://i.iinfo.cz/images/315/hist26-2.jpg"><img src="http://i.iinfo.cz/images/315/hist26-2-prev.jpg" alt="hist26" height="270" width="270" /></a></p>



<p><a name="k03"></a></p>
<h2>3. Tajemná zkratka RnRS</h2>

<p>Pro dal¹í vývoj programovacího jazyka <i>Scheme</i> byl dùle¾itý rok 1978,
kdy do¹lo ke vzniku jeho prvního standardu, jen¾ byl popsán
v&nbsp;&bdquo;Revidované zprávì o algoritmickém jazyku Scheme&ldquo;
(<i>Revised Report on the Algorithmic Language Scheme</i>). Jazyk se samozøejmì
dále vyvíjel, tak¾e v&nbsp;roce 1985 vznikl dal¹í popis jeho standardu
zveøejnìný v&nbsp;dokumentu nazvaném &bdquo;Revize revidované zprávy o Scheme,
neboli neobvyklý LISP&ldquo;. Tradice ve vydávání revizí (a revizí revizí)
pùvodní zprávy o programovacím jazyku <i>Scheme</i> zùstala zachována a¾ do
dne¹ní doby. Postupnì vzniklo celkem ¹est revizí, co¾ mj.&nbsp;znamená, ¾e
vìt¹ina souèasných implementací tohoto programovacího jazyka odpovídá buï páté
revizi (&bdquo;The Revised<sup>5</sup> Report on the Algorithmic Language
Scheme&ldquo;) z&nbsp;roku 1998 nebo se pøizpùsobuje revizi ¹esté (&bdquo;The
Revised<sup>6</sup> Report on the Algorithmic Language Scheme&ldquo;), která
byla schválena v&nbsp;roce 2007.</p>

<p>Jednotlivé zprávy (tj.&nbsp;vlastnì faktické standardy jazyka <i>Scheme</i>
dodr¾ované vìt¹inou jeho implementací) se v&nbsp;literatuøe velmi èasto
oznaèují pouze zkratkou <strong>RnRS</strong>, kde se za <strong>n</strong>
dosazuje èíslo revize. V&nbsp;souèasnosti se mù¾eme v&nbsp;rùzných návodech ale
i odborných èláncích setkat pøedev¹ím se zkratkou <strong>R5RS</strong>
oznaèující pátou revizi èi <strong>R6RS</strong> oznaèující revizi ¹estou.
Zajímavé je, ¾e tyto zprávy, aè popisují prakticky v¹echna zákoutí jazyka
<i>Scheme</i> i nìkteré po¾adavky na jeho implementaci, mají po vyti¹tìní délku
pouhých padesáti stran (vysázeny jsou T<sub>E</sub>Xem písmem <i>Computer
Modern</i>), co¾ mj.&nbsp;svìdèí i o tom, ¾e se jedná o èistì a v&nbsp;mnoha
ohledech minimalisticky navr¾ený jazyk (srovnejte si napøíklad
padesátistránkovou <strong>R6RS</strong> s&nbsp;øádovì rozsáhlej¹ím standardem
<i>Common Lispu</i> nebo normy jazyka <i>C++</i>). Ostatnì název jedné
z&nbsp;populárních implementací tohoto jazyka &ndash; <i>Scheme48</i> &ndash;
vznikl z&nbsp;toho, ¾e první verze této implementace vznikla za pouhých 48
hodin.</p>

<p><img src="http://i.iinfo.cz/images/315/hist26-3.jpg" alt="hist26" height="540" width="420" /></p>



<p><a name="k04"></a></p>
<h2>4. Základní vlastnosti programovacího jazyka Scheme</h2>

<p><i>Scheme</i> je programovací jazyk, který podporuje rùzná paradigmata
programování, pøedev¹ím paradigma funkcionální (i kdy¾ se nejedná o èistì
funkcionální jazyk) a paradigma imperativní. Z&nbsp;funkcionálních jazykù se ve
<i>Scheme</i> objevuje pøedev¹ím koncept lambda výrazù, funkcí jako¾to
plnohodnotných datových typù, co¾ mj.&nbsp;znamená, ¾e funkce je mo¾né pøedávat
jako parametry jiným funkcím, funkce mohou být návratovými hodnotami jiných
funkcí atd. Naopak z&nbsp;jazykù imperativních (mezi nì¾ patøí velká èást
v&nbsp;souèasnosti pou¾ívaných programovacích jazykù) se ve <i>Scheme</i>
objevuje bloková struktura kódu pøevzatá z&nbsp;<i>Algolu 60</i>, koncept
globálních a lokálních promìnných s&nbsp;lexikální oblastí jejich platnosti
(<i>lexical scope</i>, na rozdíl od dynamického vyhodnocování platnosti, které
bylo pou¾ito v&nbsp;pùvodních LISPu a teprve pozdìji se pøe¹lo
k&nbsp;vyhodnocování lexikálnímu) a podpora programových smyèek, které se
v&nbsp;èistì funkcionálních jazycích nahrazují rekurzí èi speciálními formami,
mezi nì¾ patøí napøíklad <strong>apply</strong>, <strong>map</strong>,
<strong>for-each</strong>, <strong>mapcar</strong> èi
<strong>reduce</strong>.</p>

<p><a href="http://i.iinfo.cz/images/315/hist26-4.png"><img src="http://i.iinfo.cz/images/315/hist26-4-prev.png" alt="hist26" height="144" width="370" /></a></p>



<p><a name="k05"></a></p>
<h2>5. Koncová rekurze (tail-recursion)</h2>

<p>V&nbsp;naprosté vìt¹inì algoritmù se objevují bloky kódu, které se mají
iterativnì opakovat. Pøi programování s&nbsp;vyu¾itím funkcionálního
paradigmatu se iterace vyjadøuje formou rekurze. Ta je samozøejmì ve
<i>Scheme</i> podporována (mezi jediné známìj¹í jazyky, které rekurzi
nepodporovaly, patøil pùvodní <i>Fortran</i> a <i>Basic</i>), ov¹em specifikace
jazyka <i>Scheme</i> jde je¹tì dále, proto¾e urèuje, ve kterých pøípadech je
skuteèná rekurze (pøi ní¾ se parametry a návratové adresy musí ukládat na
zásobník) nahrazena takzvanou <i>koncovou rekurzí</i>, co¾ zjednodu¹enì øeèeno
znamená, ¾e se namísto skuteèného rekurzivního volání funkce internì provede
obyèejný skok (koncový skok èi koncové volání) bez nutnosti alokace místa na
zásobníku pro parametry volané funkce a návratové adresy. Koncová rekurze
pøedstavuje pøi správném pou¾ití velmi silnou programovací techniku, proto¾e
umo¾òuje zapisovat mnoho algoritmù v&nbsp;mnohdy elegantní rekurzivní formì,
ov¹em skuteèné zpracování takto zapsaných algoritmù je stejnì efektivní jako
provádìní programové smyèky (ka¾dou koncovou rekurzi lze nahradit smyèkou a
naopak).</p>

<p>Klasickým pøíkladem rozdílu mezi normální (plnou, skuteènou) rekurzí a
koncovou rekurzí je výpoèet faktoriálu. Ten mù¾eme zapsat mnoha zpùsoby,
napøíklad (jak je to v&nbsp;matematice obvyklé), rekurzivnì:</p>

<pre>
(define (factorial n)
    (if (= n 0) ; podmínka pro ukonèení rekurzivního zanoøování
        1       ; faktoriál nuly je definitoricky roven jedné
        (* n (factorial (- n 1)))
    )
)
</pre>

<p>Z&nbsp;teoretického hlediska není na vý¹e uvedené funkci nic nekorektního,
ov¹em pøi jejím praktickém pou¾ívání brzy narazíme na limit zpùsobený omezenou
velikostí zásobníku. Pov¹imnìte si, ¾e jazyk <i>Scheme</i> nemá velikost
datových typù omezen na <i>int</i> èi <i>double</i> tak, jako tomu je u nìkterých
dal¹ích programovacích jazykù, pøekvapivì i u mnoha jazykù vysokoúrovòových, kde
by programátor teoreticky èekal vy¹¹í úroveò abstrakce:</p>

<pre>
(factorial 1)
1

(factorial 10)
3628800

(factorial 100)
9332621544394415268169923885626670049071
5968264381621468592963895217599993229915
6089414639761565182862536979208272237582
51185210916864000000000000000000000000 
; výsledek je pro potøeby èlánku rozdìlen na ètyøi øádky

; ov¹em nyní výpoèet zhavaruje
(factorial 1000)
ERROR: Stack overflow
ABORT: (stack-overflow)
</pre>

<p>Vý¹e uvedený rekurzivní výpoèet lze relativnì malou úpravou pøevést na
výpoèet který (alespoò v&nbsp;programovacím jazyce <i>Scheme</i>) vede na
koncové volání, co¾ mj.&nbsp;znamená, ¾e pamì»ové (prostorové) nároky tohoto
programu jsou konstantní:</p>

<pre>
; výpoèet faktoriálu vyu¾ívající koncového volání
(define (factorial n)
    (let fact-iter (          ; pomocná vnitøní funkce
                  (n n)       ; poèitadlo iterací
                  (result 1)) ; prùbì¾ný výsledek
        (if (= n 0)           ; po dosa¾ení koncového stavu
            result            ; se vrátí prùbì¾ný výsledek
            (fact-iter (- n 1) (* n result)) ; koncové volání
        )
    )
)
</pre>

<p>O tom, ¾e upravený algoritmus výpoètu faktoriálu nevyu¾ívá zásobník pro
ukládání mezivýsledkù ani poèitadla iterací, se mù¾eme jednodu¹e pøesvìdèit.
Popravdì øeèeno i tento výpoèet pro nìjaké velké <i>n</i> zhavaruje, proto¾e se
pøekroèí limit pamìti alokované pro ulo¾ení mezivýsledku &ndash; promìnné
<i>result</i> (konkrétnì po zavolání (factorial 100000) u¾ moje EEE s&nbsp;1GB
pamìti zaèíná nepøíjemnì swapovat):</p>

<pre>
(factorial 1)
1

(factorial 10)
3628800

(factorial 100)
9332621544394415268169923885626670049071
5968264381621468592963895217599993229915
6089414639761565182862536979208272237582
51185210916864000000000000000000000000 
; výsledek je pro potøeby èlánku rozdìlen na ètyøi øádky

; zkusíme výpoèet faktoriálu pro nìjaké
; vìt¹í èíslo
(factorial 1000)
4023872600770937735437024339230039857193
7486421071463254379991042993851239862902
0592044208486969404800479988610197196058
6316668729948085589013238296699445909974
2450408707375991882362772718873251977950
5950995276120874975462497043601418278094
6464962910563938874378864873371191810458
2578364784997701247663288983595573543251
3185323958463075557409114262417474349347
5534286465766116677973966688202912073791
4385371958824980812686783837455973174613
6085379534524221586593201928090878297308
4313928444032812315586110369768013573042
1616874760967587134831202547858932076716
9132448426236131412508780208000261683151
0273418279777047846358681701643650241536
9139828126481021309276124489635992870511
4964975419909342221566832572080821333186
1168115536158365469840467089756029009505
3761647584772842188967964624494516076535
3408198901385442487984959953319101723355
5566021394503997362807501378376153071277
6192684903435262520001588853514733161170
2103968175921510907788019393178114194545
2572238655414610628921879602238389714760
8850627686296714667469756291123408243920
8160153780889893964518263243671616762179
1689097799119037540312746222899880051954
4441428201218736174599264295658174662830
2955570299024324153181617210465832036786
9061172601587835207515162842255402651704
8330422614397428693306169089796848259012
5458327168226458066526769958652682272807
0757813918581788896522081643483448259932
6604336766017699961283186078838615027946
5955131156552036093988180612138558600301
4356945272242063446317974605946825731037
9008402443243846565724501440282188525247
0935190620929023136493273497565513958720
5596542287497740114133469627154228458623
7738753823048386568897646192738381490014
0767310446640259899490222221765904339901
8860185665264850617997023561938970178600
4081188972991831102117122984590164192106
8884387121855646124960798722908519296819
3723886426148396573822911231250241866493
5314397013742853192664987533721894069428
1434118520158014123344828015051399694290
1534830776445690990731524332782882698646
0278986432113908350621709500259738986355
4277196742822248757586765752344220207573
6305694988250879689281627538488633969099
5982628095612145099487170124451646126037
9029309120889086942028510640182154399457
1568059418727489980942547421735824010636
7740459574178516082923013535808184009699
6372524230560855903700624271243416909004
1536901059339838357779394109700277534720
0000000000000000000000000000000000000000
0000000000000000000000000000000000000000
0000000000000000000000000000000000000000
0000000000000000000000000000000000000000
0000000000000000000000000000000000000000
0000000000000000000000000000000000000000
0000000

; uff :-)
</pre>



<p><a name="k06"></a></p>
<h2>6. Nìkteré rozdíly mezi LISPem a Scheme</h2>

<p>Zápis programù v&nbsp;jazyku <i>Scheme</i> se ze syntaktického a èásteènì i
ze sémantického hlediska podobá zápisu programù v&nbsp;<i>LISPu</i>, ov¹em mezi
obìma jazyky existuje nìkolik rozdílù, které ponìkud komplikují pøevody
programù mezi <i>LISPem</i> a <i>Scheme</i> a samozøejmì i pøevody opaèným
smìrem. Nejzásadnìj¹ím rozdílem mezi <i>Scheme</i> a mnohými star¹ími
interpretry jazyka <i>LISP</i> (kromì <i>Common Lispu</i>) je to, ¾e zatímco se
v&nbsp;LISPu oblast platnosti promìnných stanovuje dynamicky v&nbsp;èase bìhu
programu, ve <i>Scheme</i> a v&nbsp;nìkterých implementacích LISPu je oblast
platnosti promìnné urèena na základì toho, v&nbsp;jakém bloku se promìnná
nachází (tato vlastnost jazyka se oznaèuje <i>lexical scope</i>), co¾ je
podobné chování, jaké nalezneme i u naprosté vìt¹iny dal¹ích programovacích
jazykù. <i>Lexical scope</i> je v&nbsp;bì¾ných programech pøehlednìj¹í
(programátor mù¾e urèit oblast platnosti pouze ze zdrojového kódu, nemusí
pøemý¹let nad tím, jak se program chová pøi spu¹tìní) a dokonce se i snáze
implementuje.</p>

<p>Druhou odli¹ností mezi <i>Scheme</i> a <i>LISPem</i> je rozdílná
reprezentace pravdivostních hodnot. Zatímco <i>LISP</i> pova¾uje prázdný seznam
<strong>()</strong>, reprezentovaný té¾ hodnotou <strong>nil</strong>, za
nepravdu a v¹echny ostatní hodnoty za pravdu, existuje ve <i>Scheme</i> jen
jediná globálnì dostupná a v&nbsp;celém systému jedineèná nepravdivá hodnota
oznaèovaná symbolem <strong>#f</strong>. V¹echny ostatní objekty, vèetnì
prázdného seznamu, jsou pova¾ovány za hodnotu pravdivou, co¾ mù¾e komplikovat
pøevody zdrojových kódù programù, proto¾e v&nbsp;pomìrnì velkém mno¾ství
algoritmù se napøíklad zpracovávají seznamy takovým zpùsobem, ¾e se z&nbsp;nich
postupnì odebírají prvky a algoritmus skonèí v&nbsp;pøípadì odebrání posledního
prvku, nebo» se prázdný seznam vyhodnotí na nepravdivou hodnotu.</p>

<p><img src="http://i.iinfo.cz/images/315/hist26-5.jpg" alt="hist26" height="236" width="195" /></p>



<p><a name="k07"></a></p>
<h2>7. Obsah následující èásti seriálu</h2>

<p>V&nbsp;následující èásti tohoto seriálu si podrobnìji popí¹eme nìkteré
zajímavé vlastnosti programovacího jazyka <i>Scheme</i>, které si vysvìtlíme na
mnoha demonstraèních pøíkladech. Øekneme si, kdy pøesnì interpretry i
pøekladaèe tohoto jazyka nahrazují skuteènou rekurzi za pamì»ovì i rychlostnì
efektivnìj¹í koncové volání (<i>tail-call</i>) ukázané <a
href="#k05">v&nbsp;páté kapitole</a>, jakým zpùsobem se ve <i>Scheme</i>
pracuje s&nbsp;uzávìry (<i>closures</i>) èi jaké interpretry tohoto jazyka lze
v&nbsp;souèasnosti vyu¾ít a zda pro <i>Scheme</i> existuje vhodné vývojové
prostøedí. Krátce se takté¾ budeme zabývat problematikou tvorby skriptù pro
známý grafický editor <i>GIMP</i>.</p>

<p><img src="http://i.iinfo.cz/images/315/hist26-6.jpg" alt="hist26" height="241" width="201" /></p>



<p><a name="k08"></a></p>
<h2>8. Literatura</h2>

<ol>

<li>Richard Kelsey, Jonathan Rees, Mike Sperber<br />
<i>&bdquo;The Incomplete Scheme 48 Reference Manual for release 1.8&ldquo;</i><br />
(dodáváno ve spoleèném balíku se Scheme 48)</li>

<li>Carl Hewitt; Peter Bishop and Richard Steiger<br />
<i>&bdquo;A Universal Modular Actor Formalism for Artificial Intelligence&ldquo;</i><br />
1973
</li>

<li>Hillis, D.<br />
<i>&bdquo;New Computer Architectures and Their Relationship to Physics or Why CS is No Good&ldquo;</i></br>
Int J. Theoretical Physics 21 (3/4) 255-262.
</li>

<li>Lewis W. Tucker, George G. Robertson,<br />
<i>&bdquo;Architecture and Applications of the Connection Machine&ldquo;</i></br>
Computer, vol. 21, no. 8, pp. 26&ndash;38, August, 1988.
</li>

<li>Arthur Trew and Greg Wilson (eds.) (1991)<br />
<i>&bdquo;Past, Present, Parallel: A Survey of Available Parallel Computing Systems&ldquo;</i></br>
New York: Springer-Verlag. ISBN 0-387-19664-1.
</li>

<li>W. Daniel Hillis and Lewis W. Tucker<br />
<i>&bdquo;The CM-5 Connection Machine: A Scalable Supercomputer&ldquo;</i></br>
In Communications of the ACM, Vol. 36, No. 11 (November 1993)
</li>

<li>Cliff Lasser, Jeff Mincy, J.P. Massar<br />
<i>&bdquo;The Essential *LISP Manual&ldquo;</i></br>
Thinking Machines Corporation, 1986.
</li>

<li>Anonymous<br />
<i>&bdquo;Getting Started in *Lisp, Version 6.1&ldquo;</i></br>
Thinking Machines Corporation, Cambridge, Massachusetts, June 1991.
</li>

<li>Anonymous<br />
<i>&bdquo;*Lisp Dictionary&ldquo;</i></br>
Thinking Machines Corporation, Cambridge, Massachusetts.
</li>

<li>Anonymous<br />
<i>&bdquo;*Lisp Timesharing User's Guide&ldquo;</i></br>
Online at CMU AI Repository
</li>

<li>Zdzislaw Meglicki<br />
<i>&bdquo;The CM5 *Lisp Course&ldquo;</i></br>
Centre for Information Science Research, The Australian National University, 1994
</li>

<li>McCarthy<br />
<i>&bdquo;Recursive functions of symbolic expressions and their computation by machine, part I&ldquo;</i><br />
1960
</li>

<li>Guy L. Steele<br />
<i>&bdquo;History of Scheme&ldquo;</i><br />
2006, Sun Microsystems Laboratories
</li>

<li>
Koláø J., Muller K.:<br />
<i>&bdquo;Speciální programovací jazyky&ldquo;</i><br />
Praha 1981
</li>

<li>
<i>&bdquo;AutoLISP Release 9, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., October 1987
</li>

<li>
<i>&bdquo;AutoLISP Release 10, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., September 1988
</li>

<li>McCarthy, John; Abrahams, Paul W.; Edwards, Daniel J.; Hart, Timothy P.; Levin, Michael I.<br />
<i>&bdquo;LISP 1.5 Programmer's Manual&ldquo;</i><br />
MIT Press. ISBN 0 262 130 1 1 4
</li>

<li>Feiman, J.<br />
<i>&bdquo;The Gartner Programming Language Survey (October 2001)&ldquo;</i><br />
Gartner Advisory
</li>

</ol>



<p><a name="k09"></a></p>
<h2>9. Odkazy na Internetu</h2>

<ol>

<li>(welcome '(schemers . org))<br />
<a href="http://www.schemers.org/">http://www.schemers.org/</a>
</li>

<li>The Revised<sup>5</sup> Report on the Algorithmic Language Scheme<br />
<a href="http://www.schemers.org/Documents/Standards/R5RS/">http://www.schemers.org/Documents/Standards/R5RS/</a>
</li>

<li>The Revised<sup>6</sup> Report on the Algorithmic Language Scheme<br />
<a href="http://www.r6rs.org/">http://www.r6rs.org/</a>
</li>

<li>Scheme<br />
<a href="http://groups.csail.mit.edu/mac/projects/scheme/">http://groups.csail.mit.edu/mac/projects/scheme/</a>
</li>

<li>The Kawa language framework<br />
<a href="http://www.gnu.org/software/kawa/">http://www.gnu.org/software/kawa/</a>
</li>

<li>Scheme 48<br />
<a href="http://s48.org/">http://s48.org/</a>
</li>

<li>Introductory textbooks for Schemers<br />
<a href="http://www.schemers.org/Documents/#intro-texts">http://www.schemers.org/Documents/#intro-texts</a>
</li>

<li>Scheme (programming language)<br />
<a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)">http://en.wikipedia.org/wiki/Scheme_(programming_language)</a>
</li>

<li>History of the Scheme programming language<br />
<a href="http://en.wikipedia.org/wiki/History_of_the_Scheme_programming_language">http://en.wikipedia.org/wiki/History_of_the_Scheme_programming_language</a>
</li>

<li>Scheme<br />
<a href="http://cs.wikipedia.org/wiki/Scheme">http://cs.wikipedia.org/wiki/Scheme</a>
</li>

<li>Scheme-faq<br />
<a href="http://community.schemewiki.org/?scheme-faq">http://community.schemewiki.org/?scheme-faq</a>
</li>

<li>Scheme implementations<br />
<a href="http://community.schemewiki.org/?scheme-faq-standards#implementations">http://community.schemewiki.org/?scheme-faq-standards#implementations</a>
</li>

<li>Successful Scheme<br />
<a href="http://www.itworld.com/swol-1013-regex">http://www.itworld.com/swol-1013-regex</a>
</li>

<li>Why Java (and almost every other programming language) sucks (lisp)<br />
<a href="http://www.perkiset.org/forum/pythonlispschemeerlangobscurities/why_java_and_almost_every_other_programming_language_sucks_lisp-t26.0.html;msg57#msg57">http://www.perkiset.org/forum/pythonlispschemeerlangobscurities/why_java_and_almost_every_other_programming_language_sucks_lisp-t26.0.html;msg57#msg57</a>
</li>

<li>PLT Scheme<br />
<a href="http://www.plt-scheme.org/">http://www.plt-scheme.org/</a>
</li>

<li>Guy L. Steele, Jr.<br />
<a href="http://en.wikipedia.org/wiki/Guy_L._Steele">http://en.wikipedia.org/wiki/Guy_L._Steele</a>
</li>

<li>Gerald Jay Sussman<br />
<a href="http://en.wikipedia.org/wiki/Gerald_Jay_Sussman">http://en.wikipedia.org/wiki/Gerald_Jay_Sussman</a>
</li>

<li>Lecture Notes: Macros<br />
<a href="http://www.apl.jhu.edu/~hall/Lisp-Notes/Macros.html">http://www.apl.jhu.edu/~hall/Lisp-Notes/Macros.html
</a>
</li>

<li>Common Lisp's Loop Macro Examples for Beginners<br />
<a href="http://www.unixuser.org/~euske/doc/cl/loop.html">http://www.unixuser.org/~euske/doc/cl/loop.html</a>
</li>

<li>Macro LOOP<br />
<a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_loop.htm">http://www.lispworks.com/documentation/HyperSpec/Body/m_loop.htm</a>
</li>

<li>Loop<br />
<a href="http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node235.html">http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node235.html</a>
</li>

<li>Tutorial for the Common Lisp Loop Macro<br />
<a href="http://www.ai.sri.com/~pkarp/loop.html">http://www.ai.sri.com/~pkarp/loop.html</a>
</li>

<li>LISPová makra aneb programovatelný programovací jazyk<br />
<a href="http://www.root.cz/clanky/lispova-makra-aneb-programovatelny-programovaci-jazyk/">http://www.root.cz/clanky/lispova-makra-aneb-programovatelny-programovaci-jazyk/</a>
</li>

<li>Jemný úvod do LISPu<br />
<a href="http://www.root.cz/clanky/jemny-uvod-do-lispu/">http://www.root.cz/clanky/jemny-uvod-do-lispu/</a>
</li>

<li>*Lisp<br />
<a href="http://en.wikipedia.org/wiki/*Lisp">http://en.wikipedia.org/wiki/*Lisp</a>
</li>

<li>Lisp machine<br />
<a href="http://en.wikipedia.org/wiki/Lisp_machine">http://en.wikipedia.org/wiki/Lisp_machine</a>
</li>

<li>MIT CADR Lisp Machine FAQ<br />
<a href="http://www.unlambda.com/cadr/cadr_faq.html">http://www.unlambda.com/cadr/cadr_faq.html</a>
</li>

<li>Symbolics LISP Machines<br />
<a href="http://www.frobenius.com/symbolics.htm">http://www.frobenius.com/symbolics.htm</a>
</li>

<li>UNIVAC<br />
<a href="http://en.wikipedia.org/wiki/Univac">http://en.wikipedia.org/wiki/Univac</a>
</li>

<li>UNIVAC 1100/2200 series<br />
<a href="http://en.wikipedia.org/wiki/UNIVAC_1100/2200_series#UNIVAC_1100_series">http://en.wikipedia.org/wiki/UNIVAC_1100/2200_series#UNIVAC_1100_series</a>
</li>

<li>Allegro CL Examples and Utilities<br />
<a href="http://examples.franz.com/index.html">http://examples.franz.com/index.html</a>
</li>

<li>LISP 1.5 for the Univac 1100 Mainframe<br />
<a href="http://www.frobenius.com/univac.htm">http://www.frobenius.com/univac.htm</a>
</li>

<li>STARSIM: Thinking Machines' *Lisp Simulator<br />
<a href="http://www-2.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/lisp/impl/starlisp/0.html">http://www-2.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/lisp/impl/starlisp/0.html</a>
</li>

<li>Connection Machine<br />
<a href="http://en.wikipedia.org/wiki/Connection_Machine">http://en.wikipedia.org/wiki/Connection_Machine</a>
</li>

<li>Connection Machine -1-2-5<br />
<a href="http://ed-thelen.org/comp-hist/vs-cm-1-2-5.html">http://ed-thelen.org/comp-hist/vs-cm-1-2-5.html</a>
</li>

<li>Richard Feynman and The Connection Machine<br />
<a href="http://www.longnow.org/essays/richard-feynman-connection-machine/">http://www.longnow.org/essays/richard-feynman-connection-machine/</a>
</li>

<li>Sheryl Handler<br />
<a href="http://en.wikipedia.org/wiki/Sheryl_Handler">http://en.wikipedia.org/wiki/Sheryl_Handler</a>
</li>

<li>W. Daniel Hillis<br />
<a href="http://en.wikipedia.org/wiki/Danny_Hillis">http://en.wikipedia.org/wiki/Danny_Hillis</a>
</li>

<li>The Rise and Fall of Thinking Machines<br />
<a href="http://www.inc.com/magazine/19950915/2622.html">http://www.inc.com/magazine/19950915/2622.html</a>
</li>

<li>Lisp (programming language)<br />
<a href="http://en.wikipedia.org/wiki/Lisp_(programming_language)">http://en.wikipedia.org/wiki/Lisp_(programming_language)</a>
</li>

<li>On Lisp<br />
<a href="http://paulgraham.com/onlisptext.html?asdf">http://paulgraham.com/onlisptext.html?asdf</a>
</li>

<li>Lambda calculus<br />
<a href="http://en.wikipedia.org/wiki/Lambda_calculus">http://en.wikipedia.org/wiki/Lambda_calculus</a>
</li>

<li>A Short Introduction to the Lambda Calculus<br />
<a href="http://www.cs.bham.ac.uk/~axj/pub/papers/lambda-calculus.pdf">http://www.cs.bham.ac.uk/~axj/pub/papers/lambda-calculus.pdf</a>
</li>

<li>A Tutorial Introduction to the Lambda Calculus<br />
<a href="http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf">http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf</a>
</li>

<li>An Introduction to Scheme and its Implementation<br />
<a href="ftp://ftp.cs.utexas.edu/pub/garbage/cs345/schintro-v14/schintro_toc.html">ftp://ftp.cs.utexas.edu/pub/garbage/cs345/schintro-v14/schintro_toc.html</a>
</li>

<li>Humor on Computers, Systems and Programming<br />
<a href="http://www-crypto.htw-saarland.de/weber/misc/programming.html">http://www-crypto.htw-saarland.de/weber/misc/programming.html</a>
</li>

<li>Teach Yourself Scheme in Fixnum Days<br />
<a href="http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme.html">http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme.html</a>
</li>

<li>AutoLISP<br />
<a href="http://en.wikipedia.org/wiki/AutoLISP">http://en.wikipedia.org/wiki/AutoLISP</a>
</li>

<li>Rosetta Code &ndash; Category:Lisp<br />
<a href="http://rosettacode.org/wiki/Category:Lisp">http://rosettacode.org/wiki/Category:Lisp</a>
</li>

<li>Retrocomputing &ndash; MIT CADR Lisp Machines<br />
<a href="http://www.unlambda.com/cadr/index.html">http://www.unlambda.com/cadr/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2010</small></p>
</body>
</html>

