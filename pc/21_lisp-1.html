<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyky pou¾ívané (nejen) v&nbsp;SSSR (èást 3 &ndash; LISP)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>


<body>

<h1>Programovací jazyky pou¾ívané (nejen) v&nbsp;SSSR (èást 3 &ndash; LISP)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o historii výpoèetní techniky nejprve dokonèíme popis programovacího jazyka SNOBOL a poté se zamìøíme na programovací jazyk, který spolu s programovacím jazykem C snad nejvíce ovlivnil celou informatiku, a to jak v teoretické, tak i praktické rovinì. Jedná se o jazyk LISP, jen¾ byl navr¾ený ji¾ v roce 1958.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. SNOBOL: vyhledávání vzorù v&nbsp;øetìzcích</a></p>
<p><a href="#k02">2. Historie vzniku programovacího jazyka LISP</a></p>
<p><a href="#k03">3. Dialekty jazyka LISP</a></p>
<p><a href="#k04">4. Základní datové typy LISPu &ndash; atomy a seznamy</a></p>
<p><a href="#k05">5. Teèka-dvojice: základ pro tvorbu slo¾itìj¹ích datových struktur</a></p>
<p><a href="#k06">6. Vliv architektury mainframu IBM 704 na strukturu programovacího jazyka LISP</a></p>
<p><a href="#k07">7. Obsah následující èásti seriálu</a></p>
<p><a href="#k08">8. Literatura</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2>1. SNOBOL: vyhledávání vzorù v&nbsp;øetìzcích</h2>

<p>V&nbsp;pøedchozí èásti seriálu o historii výpoèetní techniky jsme si popsali
základy programování v&nbsp;jazyce <i>SNOBOL</i> (<i>StriNg Oriented SymBOlic
Language</i>), který byl vyvinut a implementován v&nbsp;prùbìhu ¹edesátých let
minulého století v&nbsp;Bellových laboratoøích Davidem J. Farberem, Ralphem E.
Griswoldem a Ivanem P. Polonskym. První verze tohoto jazyka byla vytvoøena na
sálovém poèítaèi <i>IBM 7090</i>, pozdìji v¹ak vznikly implementace pro mnoho
dal¹ích poèítaèových architektur: mainframù, minipoèítaèù a posléze i
minipoèítaèù (nìkteré z&nbsp;implementací tohoto jazyka vznikly i v&nbsp;zemích
RVHP). Takté¾ jsme si øekli, ¾e tento jazyk byl urèený pøedev¹ím pro zpracování
textových dat (rozpoznávání vzorù atd.), èemu¾ je podøízena i jeho syntaxe a
sémantika. Ka¾dý programový øádek mù¾e být slo¾en z&nbsp;pìti blokù (oddìlených
od sebe buï mezerami nebo speciálními znaky), pøièem¾ ¾ádný z&nbsp;tìchto blokù
není povinný. Jedná se o následující bloky:</p>

<ol>
<li>náve¹tí (<i>label</i>)</li>
<li>subjekt (<i>subject</i>)</li>
<li>vzor (<i>pattern</i>)</li>
<li>objekt (<i>object</i>)</li>
<li>odkaz(y) na jiné pøíkazy (<i>goto</i>)</li>
</ol>

<p>V¹echny demonstraèní pøíklady uvedené v&nbsp;pøedchozí èásti tohoto seriálu
v¹ak na svých programových øádcích obsahovaly jen nìkteré bloky, pøedev¹ím
návì¹tí, objekt (výraz èi pøíkaz) a popø.&nbsp;odkazy (skoky) na jiné
programové øádky &ndash; ve¹keré podmínìné pøíkazy i smyèky jsou toti¾
v&nbsp;jazyce <i>SNOBOL</i> realizovány právì pomocí podmínìných èi
nepodmínìných skokù. Nyní si pojïme øíci, jakým zpùsobem se pou¾ívají zbývající
dva bloky, ze kterých se mù¾e skládat ka¾dý programový øádek ve <i>SNOBOLu</i>.
Blok nazvaný vzor (<i>pattern</i>) lze vyu¾ít pro vyhledávání podøetìzce
v&nbsp;øetìzci. Pokud je vzor v&nbsp;øetìzci nalezen, je vrácen jako výsledek
výrazu, èeho¾ lze vyu¾ít pøi rozeskoku (prázdný øetìzec vrácený v&nbsp;pøípadì,
¾e vzor nebyl nalezen, odpovídá pøi rozeskocích pravdivostní hodnotì
<i>false</i>, v¹echny ostatní øetìzce jsou ekvivalentní hodnotì <i>true</i>).
Vyhledávaný vzor sice nemù¾e být zapsán pomocí plnohodnotných regulárních
výrazù (ty v&nbsp;dobì návrhu jazyka <i>SNOBOL</i> neexistovaly), ale je mo¾né
pou¾ít jejich podmno¾inu (vèetnì rekurzivní definice), jak je patrné
z&nbsp;následujících demonstraèních pøíkladù:</p>

<p>Naètení øádku ze standardního vstupu a zji¹tìní, zda zadaný øetìzec obsahuje zapsaný vzor:</p>

<pre>
ADRESA = INPUT
ADRESA 'www.root.cz'
</pre>

<p>Vyhledávaný vzor samozøejmì mù¾e být ulo¾en v&nbsp;promìnné:</p>

<pre>
ROOT = 'www.root.cz'
ADRESA = INPUT
ADRESA ROOT
</pre>

<p>Vzor pro vyhledání kombinací dvou slov popisujících typ celoèíselné promìnné
èi konstanty v&nbsp;céèku:</p>

<pre>
PREFIX = 'signed' | 'unsigned' | ''
WIDTH = 'short' | 'long' | 'long long' | ''
TYPE = 'int' | ''
DEFINITION = PREFIX WIDTH TYPE
</pre>

<p>Ve vyhledávaných vzorech lze pou¾ít i závorky pro úpravu priority.
Konkatenace dvou vzorù má vy¹¹í prioritu ne¾ zápis více alternativ pomocí
znaku |, z&nbsp;èeho¾ vyplývá, ¾e vzory <i>PATTERN1</i> a <i>PATTERN2</i> jsou
identické:</p>

<pre>
P = 'BE' | 'BEA' | 'BEAR'
Q = 'RO' | 'ROO' | 'ROOS'
R = 'DS' | 'D'
S = 'TS' | 'T'
PATTERN1 = P R | Q S
PATTERN2 = (P R) | (Q S)
PATTERN3 = P (R | Q ) S
</pre>

<p>SNOBOL4 podporuje i rekurzivní definici vzoru:</p>

<pre>
P = *P 'Z' | 'Y'
PO = P . OUTPUT
'Y' PO       (vytiskne Y)
'YZZZ' PO    (vytiskne YZZZ)
'XYZ' PO     (vytiskne YZ)
'YZZX' PO    (vytiskne YZZ)
'AYZZZZB' PO (vytiskne YZZZZ)
</pre>

<p>Následující program naèítá jednotlivé øádky ze standardního vstupu a
odstraòuje z&nbsp;nich komentáøe (které jsou reprezentovány øádky zaèínajícími
znakem #). Jedná se tedy o velmi jednoduchý filtr, jakýsi primitivní
<i>grep</i> :-) Nastavením speciální promìnné &amp;ANCHOR na jednièku se
scanner jazyka <i>SNOBOL</i> nastaví do re¾imu, ¾e vyhledává vzor pouze na
zaèátku øetìzce:</p>

<pre>
      &amp;ANCHOR = 1
BEGIN LINE = INPUT   :F(END)
      LINE '#'       :S(BEGIN)
      OUTPUT = LINE  :(BEGIN)
END
</pre>



<p><a name="k02"></a></p>
<h2>2. Historie vzniku programovacího jazyka LISP</h2>

<p><a href="http://imgs.xkcd.com/comics/lisp_cycles.png">Syntaxe jazyka LISP je ji¾ po 50 let zdrojem inspirace pro autory vtipù</a></p>

<p>Historie programovacího jazyka <i>LISP</i> je velmi dlouhá, nebo» se jedná o
jeden z&nbsp;nejstar¹ích programovacích jazykù vùbec. Autorem teoretického
návrhu tohoto jazyka je <i>John McCarthy</i>, který se ji¾ v&nbsp;roce 1956
pøipojil k&nbsp;týmu, jeho¾ úkolem bylo navrhnout algebraický programovací
jazyk umo¾òující zpracování seznamù, jen¾ by byl vhodný pro vývoj systémù umìlé
inteligence &ndash; <i>AI</i> (zatímco dnes jsou &bdquo;v kurzu&ldquo;
enterprise systémy popø.&nbsp;WEB 2.0, v&nbsp;padesátých a ¹edesátých letech
minulého století se jednalo o umìlou inteligenci a expertní systémy). McCarthy
navrhl, aby se fakta o okolním svìtì (která mù¾e AI pøi své èinnosti pou¾ít)
lze reprezentovat formou vìt ve vhodnì strukturovaném formálním jazyce. Posléze
se ukázalo, ¾e je výhodné reprezentovat jednotlivé vìty formou seznamù.
McCarthy my¹lenku jazyka vhodného pro AI rozpracoval dále &ndash; odklonil se
napøíklad od infixové notace zápisu algebraických výrazù, proto¾e
naprogramování nìkterých manipulací s&nbsp;tìmito výrazy (derivace, integrace,
zjednodu¹ení výrazù, logická dedukce) bylo zbyteènì slo¾ité.</p>

<a href="http://i.iinfo.cz/images/455/lisp01.png"><img src="http://i.iinfo.cz/images/455/lisp01-prev.png" alt="lisp01" height="270" width="257" /></a>
<p><i>Obrázek 1: Na tomto grafu evoluce programovacích jazykù mù¾eme vidìt
nìkteré jazyky, které jsme si ji¾ v&nbsp;tomto seriálu popsali (Fortran, Cobol,
SNOBOL, Algol, APL) nebo popí¹eme (LISP, Basic).</i></p>

<p>Následnì McCarthy ve svých teoretických pracích (vznikajících v&nbsp;prùbìhu
let 1957 a 1958) ukázal, ¾e je mo¾né pomocí nìkolika pomìrnì jednoduchých
operací (a notací pro zápis funkcí) vytvoøit programovací jazyk, který je
Turingovsky kompletní (tj.&nbsp;jeho výpoèetní mocnost je ekvivalentní
<i>Turingovu stroji</i>), ale zápis algoritmù v&nbsp;tomto jazyce je mnohem
jednodu¹¹í ne¾ zápis pravidel pro Turingùv stroj. Tento jazyk, jen¾ byl
z&nbsp;velké èásti zalo¾en na <i>Lambda kalkulu</i> (viz následující èást
tohoto seriálu), obsahoval mo¾nost vytváøení rekurzivních funkcí (co¾ byl
významný rozdíl napøíklad oproti tehdej¹í verzi <i>FORTRANU</i>), funkce jako
argumenty jiných funkcí, podmínìné výrazy (jedna z&nbsp;variant speciální
formy), funkce pro manipulaci se seznamy a v&nbsp;neposlední øadì také funkci
<i>eval</i>. Na McCarthovu teoretickou práci navázal <i>S. R. Russell</i>,
který si uvìdomil, ¾e samotná funkce <i>eval</i>, pokud by byla implementována
na nìjakém poèítaèi, mù¾e slou¾it jako základ plnohodnotného interpretru jazyka
<i>LISP</i> (interpretr LISPu se nìkdy té¾ oznaèuje zkratkou <i>REPL:
Read-Eval-Print-Loop</i>, tj.&nbsp;interpretr ve smyèce naèítá jednotlivé
výrazy, vyhodnocuje je a následnì tiskne jejich výslednou hodnotu). Russell
skuteènì celou smyèku <i>REPL</i> implementoval &ndash; tímto zpùsobem se
zrodila první verze <i>LISPu</i>.</p>



<p><a name="k03"></a></p>
<h2>3. Dialekty jazyka LISP</h2>

<p>V&nbsp;prùbìhu dal¹ích více ne¾ pìti desetiletí vzniklo mnoho dialektù
tohoto programovacího jazyka, napøíklad <i>MacLISP</i>, <i>InterLISP</i>,
<i>ZetaLISP</i>, <i>XLisp</i>, <i>AutoLISP</i> (pùvodnì odvozený
z&nbsp;<i>XLispu</i>), <i>Emacs LISP</i> nebo slavný <i>Common LISP</i>. Kromì
tìchto implementací jazyka LISP, které se od sebe v&nbsp;nìkolika ohledech
odli¹ují (napøíklad existencí èi neexistencí maker èi objektového systému),
vznikl v&nbsp;minulosti i nový dialekt tohoto jazyka nazvaný <i>Scheme</i>
(pùvodnì <i>Schemer</i>), jeho¾ autory jsou Guy L. Steele a Gerald Jay Sussman.
Tento dialekt je implementaènì jednodu¹¹í a také se ho lze nauèit rychleji, ne¾
mnohé dal¹í varianty jazyka LISP. Právì z&nbsp;tìchto dùvodù se <i>Scheme</i>
vyu¾ívá èi vyu¾ívalo jak pøi výuce programování, tak i v&nbsp;mnoha open-source
projektech, napøíklad v&nbsp;textovém editoru <i>Emacs</i> èi v&nbsp;grafickém
editoru <i>GIMP</i> jako jeden z&nbsp;podporovaných skriptovacích jazykù.
Richard Stallman si dokonce pøál, aby se <i>Scheme</i> stalo standardním
skriptovacím jazykem vìt¹iny GNU aplikací, co¾ je idea, která se &ndash;
pøedev¹ím po vzniku dal¹ích vysokoúrovòových programovacích jazykù
(<i>Perl</i>, <i>Python</i>, <i>TCL</i>) &ndash; nakonec neuskuteènila. Nìkteré
rozdíly mezi &bdquo;klasickým&ldquo; LISPem a programovacím jazykem Scheme si
popí¹eme v&nbsp;dal¹ích dílech tohoto seriálu.</p>



<p><a name="k04"></a></p>
<h2>4. Základní datové typy LISPu &ndash; atomy a seznamy</h2>

<p><a href="http://imgs.xkcd.com/comics/lisp.jpg">Je Matrix napsaný v LISPu nebo Perlu?</a></p>

<p>Základními datovými typy, se kterými se v&nbsp;<i>LISPu</i> pracuje, jsou
<i>atomy</i> a <i>seznamy</i>. Atomy jsou z&nbsp;hlediska tohoto programovacího
jazyka základními objekty, které není mo¾né dále dìlit, ale je je mo¾né ukládat
do seznamù. Atomy mohou být nìkolika typù: jedná se pøedev¹ím o <i>symboly</i>
(napøíklad <strong>ABC</strong>), èísla (<strong>42</strong>,
<strong>3.1415</strong> atd. &ndash; nìkteré interpretry jazyka LISP rozli¹ují
celá èísla, èísla reálná, èísla komplexní a nìkdy té¾ zlomky, tj.&nbsp;èísla
racionální), øetìzce (<strong>"pokus"</strong>, <strong>"velmi dlouhý
øetìzec"</strong>), vestavìné funkce atd. V&nbsp;reálných programech se atomy
ukládají do seznamù, pøièem¾ pro oznaèení zaèátku a konce seznamu se pou¾ívají
kulaté závorky &ndash; levá závorka samozøejmì oznaèuje zaèátek seznamu a pravá
závorka jeho konec. Prvky/elementy seznamu jsou od sebe oddìleny alespoò jednou
mezerou nebo koncem øádku, co¾ mj.&nbsp;znamená, ¾e seznam mù¾e být rozepsán na
více øádcích (to je velmi dùle¾ité ve chvíli, kdy se pomocí seznamù
reprezentují funkce).</p>

<p>Zvlá¹tním a v&nbsp;mnoha ohledech dùle¾itým typem seznamu je <i>prázdný
seznam</i>, jen¾ neobsahuje ¾ádné prvky (elementy) a proto je zapisován buï
levou závorkou, za ní¾ ihned následuje závorka pravá (mezi závorkami se tedy
nenachází ¾ádný atom ani dal¹í seznam, mohou se zde nacházet pouze mezery nebo
konce øádkù), nebo lze pro jeho zápis alternativnì pou¾ít symbol
<strong>nil</strong>, který je ekvivalentní prázdnému seznamu (souèasnì se
tímto symbolem oznaèuje logická hodnota nepravda, tj.&nbsp;prázdný seznam se
v&nbsp;logických výrazech vyhodnocuje na hodnotu <i>false</i>). Seznam mù¾e
jako své prvky (elementy) obsahovat jak atomy, tak i dal¹í vnoøené seznamy, co¾
znamená, ¾e se jedná o rekurzivní datovou strukturu, pomocí ní¾ je mo¾né popsat
i mnohé dal¹í slo¾itìj¹í datové struktury, napøíklad n-dimenzionální pole,
stromy, hierarchické møí¾ky atd. Pod tímto odstavcem je uvedeno nìkolik
pøíkladù seznamù akceptovaných interpretrem jazyka LISP. Pov¹imnìte si
pøedev¹ím dùsledného vyvá¾ení pravých a levých závorek, pøedev¹ím
v&nbsp;pøípadì, ¾e seznam obsahuje jako své prvky/elementy dal¹í
podseznamy:</p>

<pre>
; komentáøe jsou uvozené znakem støedník, jak je to demonstrováno na tomto programovém øádku

; prázdný seznam
()

; prázdný seznam - alternativní zápis
nil

; seznam obsahující ètyøi atomy (konkrétnì se jedná o trojici symbolù a jedno èíslo)
(SEZNAM OBSAHUJICI 4 ATOMY)

; seznam obsahující trojici èísel
(42 3.14159 6502)

; dvouprvkový seznam obsahující dva podseznamy, z nich¾ ka¾dý obsahuje dva atomy
((A B) (C D))

; dvouprvkový seznam obsahující dva prázdné podseznamy
(() ())

; jednoprvkový seznam obsahující takté¾ jednoprvkový podseznam obsahující prázdný podseznam :-)
((()))

; tøíprvkový seznam obsahující jeden symbol a dvì èísla
(+ 1 2)

; tøíprvkový seznam obsahující jeden symbol a dvojici podseznamù
(* (+ 1 2) (- 1 2))
</pre>

<p>Poslední dva seznamy mají zvlá¹tní význam, proto¾e jejich první element
pøedstavuje symbol reprezentující primitivní (základní) funkci. Programovací
jazyk <i>LISP</i> by tento seznam zpracoval tak, ¾e by funkci zavolal
s&nbsp;tím, ¾e jí jako parametry pøedá v¹echny dal¹í prvky seznamu (pøípadné
podseznamy se nejdøíve rekurzivnì vyhodnotí naprosto stejným zpùsobem).
Podrobnosti definování i volání funkcí si uvedeme v&nbsp;následující èásti
tohoto seriálu, kde se mj.&nbsp;seznámíme i s&nbsp;takzvanými <i>speciálními
formami</i>.</p>



<p><a name="k05"></a></p>
<h2>5. Teèka-dvojice: základ pro tvorbu slo¾itìj¹ích datových struktur</h2>

<p>V&nbsp;<a href="#k04">pøedchozí kapitole</a> jsme si øekli, ¾e programovací
jazyk <i>LISP</i> je zalo¾en na zpracování seznamù. Jak jsou v¹ak seznamy
ulo¾eny v&nbsp;operaèní pamìti poèítaèe a jak s&nbsp;nimi interpretry tohoto
jazyka pracují? Základní interní strukturou, která je v¹ak dostupná i
programátorùm aplikací v&nbsp;jazyce <i>LISP</i>, je takzvaná
<i>teèka-dvojice</i> (dotted-pair). Tuto strukturu si mù¾eme pøedstavit jako
dvojici ukazatelù, pøièem¾ ka¾dý z&nbsp;tìchto ukazatelù mù¾e obsahovat adresu
atomu, adresu dal¹í teèka-dvojice nebo speciální hodnotu <strong>nil</strong>
odpovídající v&nbsp;céèku hodnotì <strong>NULL</strong> èi v&nbsp;Javì hodnotì
<strong>null</strong>, tj.&nbsp;jedná se o speciální hodnotu, která interpretru
øíká, ¾e daný ukazatel neobsahuje ¾ádný odkaz. Teèka-dvojici lze
v&nbsp;LISPovských programech zapisovat formou dvojice výrazù (takzvaných
S-výrazù) oddìlených teèkou, které jsou uzavøeny do kulatých závorek (i kdy¾ je
pravda, ¾e se s&nbsp;teèka-dvojicemi v&nbsp;reálných programech pøíli¹ èasto
nesetkáme, pøedev¹ím z&nbsp;dùvodu nepøehledného zápisu s&nbsp;velkým mno¾stvím
závorek):</p>

<pre>
(1.2)
(1.nil)
(A.(B.C))
(A.(B.nil))
((A.B).C)
((A.B).(C.D))
(ABC.DEF)
((ABC.(DEF.UVW)).XYZ)
</pre>

<p>Pro pøístup k&nbsp;informaci (atomu èi dal¹í teèka dvojici), na kterou
odkazuje první ukazatel teèka dvojice, se pou¾ívá primitivní funkce
<strong>CAR</strong>, a pro pøístup k&nbsp;informaci, na ní¾ se odkazuje druhý
ukazatel, lze pou¾ít funkci <strong>CDR</strong> (proè jsou názvy tìchto funkcí
takto zvlá¹tní, se dozvíme <a href="#k06">v&nbsp;následující kapitole</a>).
Pomocí teèka-dvojic je mo¾né vytvoøit klasický seznam následujícím zpùsobem:
první ukazatel ka¾dé n-té teèka-dvojice odkazuje na n-tý prvek seznamu
(napøíklad atom), druhý ukazatel se odkazuje na dal¹í (n plus první)
teèka-dvojici. Speciálním pøípadem je poslední teèka-dvojice, její¾ druhý
ukazatel obsahuje vý¹e uvedenou speciální hodnotu <strong>nil</strong>.
Z&nbsp;následujícího pøíkladu (obsahujícího ekvivalentní datové struktury) je
patrné, ¾e pou¾ití syntaxe pro zápis seznamù je pøehlednìj¹í a souèasnì i
krat¹í, ne¾ explicitní zápis teèka-dvojic; ov¹em právì znalost vnitøní
reprezentace seznamù pomocí teèka-dvojic nám umo¾òuje pochopit, jak pracují
nìkteré základní funkce, vèetnì ji¾ zmínìných funkcí <strong>CAR</strong> a
<strong>CDR</strong>:</p>

<pre>
; seznam zapsaný pomocí teèka-dvojic
(1.(2.(3.(4.(5.nil)))))

; bì¾ný zpùsob zápisu seznamu
(1 2 3 4 5)

; interní struktura seznamu v pamìti
;         .
;        / \
;       1   .
;          / \
;         2   .
;            / \
;           3   .
;              / \
;             4   .
;                / \
;               5   nil
</pre>

<p>Poznamenejme, ¾e dal¹í struktury vytvoøené pomocí rekurzivnì zanoøených
teèka-dvojic není mo¾né pøevést na bì¾né seznamy. Napøíklad jednoduchý binární
strom se tøemi úrovnìmi a ètyømi listy lze reprezentovat buï pomocí
teèka-dvojic (v&nbsp;pamìti se vytvoøí skuteèná obdoba binárního stromu),
popø.&nbsp;je mo¾né tuto datovou strukturu &bdquo;simulovat&ldquo; pomocí
seznamù (ov¹em v&nbsp;tomto pøípadì bude pamì»ová nároènost vy¹¹í
kvùli nutnosti ukonèení v¹ech podseznamù teèka dvojicí obsahující ve svém
druhém ukazateli hodnotu <strong>nil</strong>):</p>

<pre>
; binární strom se tøemi úrovnìmi a ètyømi listy vytvoøený pomocí teèka dvojic
((A.B).(C.D))
; interní podoba této struktury v operaèní pamìti:
;     .
;    / \
;   .   .
;  / \ / \
;  A B C D

; binární strom vytvoøený pomocí LISPovských seznamù
((A B) (C D))
; interní podoba této struktury v operaèní pamìti:
;         .
;        / \
;       /   \
;      /     \
;     /       \
;    .         .
;   / \       / \
;   A  .     .  nil
;     / \   / \
;     B nil C  .
;             / \
;             D nil
</pre>



<p><a name="k06"></a></p>
<h2>6. Vliv architektury mainframu IBM 704 na strukturu programovacího jazyka LISP</h2>

<p>První implementace programovacího jazyka <i>LISP</i> vznikla na sálovém
poèítaèi <i>IBM 704</i>, který byl zalo¾ený na technologii elektronek a
feritových pamìtí. Tento poèítaè, pøesnìji øeèeno jeho aritmeticko-logická
jednotka, dokázal zpracovávat numerické èi znakové hodnoty ulo¾ené ve slovech,
jejich¾ ¹íøka byla rovna 36 bitùm (jednalo se buï o celá èísla se znaménkem,
èísla ulo¾ená ve formátu plovoucí øádové èárky èi ¹estici znakù, z&nbsp;nich¾
ka¾dý byl ulo¾en v&nbsp;¹esti bitech). Operaèní pamì» poèítaèe <i>IBM 704</i>
byla z&nbsp;hlediska zpracování dat organizována po slovech o ¹íøce 36 bitù
(viz pøedchozí text), pøièem¾ celkový poèet tìchto slov ulo¾ených v&nbsp;pamìti
mohl nabývat hodnot 4096, 8192 èi 32768, co¾ odpovídá postupnì 18 kB, 36 kB a
144 kB (pro pøedstavu &ndash; v&nbsp;posledním pøípadì musela feritová pamì»
obsahovat pøes jeden milion feritových jadérek a nìkolik desítek tisíc vodièù).
Právì 36bitová ¹íøka zpracovávaných slov mìla velký vliv na zpùsob ulo¾ení
datových struktur <i>LISPu</i> v&nbsp;operaèní pamìti, jak si ostatnì øekneme
v&nbsp;navazujícím odstavci.</p>

<a href="http://i.iinfo.cz/images/118/ibm07.jpg"><img src="http://i.iinfo.cz/images/118/ibm07-prev.jpg" alt="ibm07" height="270" width="331" /></a>
<p><i>Obrázek 2: Sálový poèítaè IBM-704.</i></p>

<p><a href="#k05">V&nbsp;pøedchozí kapitole</a> jsme si øekli, ¾e seznamy jsou
v&nbsp;LISPu zkonstruovány pomocí teèka-dvojic. Tento zpùsob konstrukce seznamù
vychází pøímo z&nbsp;architektury poèítaèe IBM 704, který pou¾íval 15bitové
adresy, èemu¾ odpovídá v&nbsp;pøedchozím odstavci zmínìný maximální poèet 32768
adresovatelných slov. V&nbsp;ka¾dém 36bitovém slovì bylo mo¾né ulo¾it dvì
15bitové adresy nazvané podle svého významu <i>address</i> a <i>decrement</i>.
Poèítaè IBM 704 obsahoval instrukce, pomocí nich¾ bylo mo¾né jednu z&nbsp;èástí
<i>address</i> èi <i>decrement</i> z&nbsp;36bitového slova získat a ulo¾it ji
do index registru, jen¾ se pou¾íval pøi adresování operandù strojových
instrukcí. Tvùrci první implementace jazyka <i>LISP</i> tuto mo¾nost vyu¾ili
&ndash; ukládali teèka-dvojice do 36bitového slova rozdìleného na ètyøi èásti:
<i>prefix</i> (3 bity), <i>address</i> (15 bitù), <i>decrement</i> (15 bitù) a
<i>tag</i> (3 bity). Pùvodnì v&nbsp;LISPu existovaly ètyøi funkce, pomocí nich¾
bylo mo¾né získat jednu ze ètyø èástí 36bitového slova pøedstavujícího teèka
dvojici:</p>

<table>
<tr><th>Primitivní funkce</th><th>Význam</th></tr>
<tr><td>CAR</td><td>Contents of the Address part of Register</td></tr>
<tr><td>CDR</td><td>Contents of the Decrement part of Register</td></tr>
<tr><td>CPR</td><td>Contents of the Prefix part of Register</td></tr>
<tr><td>CTR</td><td>Contents of the Tag part of Register</td></tr>
</table>

<p>Z&nbsp;tìchto funkcí nakonec ve finální verzi <i>LISPu</i> zùstaly pouze
funkce <strong>CAR</strong> a <strong>CDR</strong>, které mù¾eme nalézt
v&nbsp;prakticky ka¾dém dialektu tohoto jazyka. Druhou oblastí, v&nbsp;ní¾ se
projevila architektura poèítaèe IBM 704, byl zpùsob správy pamìti. Pùvodnì
chtìli tvùrci <i>LISPu</i> pou¾ít metodu poèítání referencí na objekty
(<i>reference counting</i>), ov¹em to bylo pomìrnì problematické &ndash;
v&nbsp;ka¾dém 36bitovém slovì zbylo pouhých ¹est bitù (<i>prefix</i> a
<i>tag</i>), navíc rozmístìných takovým zpùsobem, ¾e jejich slouèení bylo
pomìrnì obtí¾né. Pou¾ití èítaèù referencí by tedy vedlo k&nbsp;nutnosti zmìny
významu v¹ech bitù v&nbsp;36bitovém slovì, do èeho¾ se autorùm LISPu evidentnì
nechtìlo :-) Proto namísto èítaèe referencí implementovali automatickou správu
pamìti pomocí plnohodnotného <i>garbage collectoru</i>, který dokázal pracovat
korektnì i v&nbsp;pøípadech, kdy se vytvoøila datová struktura obsahující
cyklus (viz té¾ následující èásti tohoto seriálu). Pravdìpodobnì se jednalo o
první vyu¾ití garbage collectoru v&nbsp;¹iroce pou¾ívaném obecném programovacím
jazyce.</p>



<p><a name="k07"></a></p>
<h2>7. Obsah následující èásti seriálu</h2>

<p>V&nbsp;následující èásti seriálu o historii výpoèetní techniky si popí¹eme
nìkteré základní (primitivní) funkce, které jsou dostupné v&nbsp;prakticky
ka¾dém interpretru programovacího jazyka <i>LISP</i>. Takté¾ se seznámíme
s&nbsp;takzvanými <i>speciálními formami</i> i zpùsobem jejich pou¾ití pøi
tvorbì rozhodovacích konstrukcí (obdoba podmínìných pøíkazù). Na závìr si
øekneme, jak lze v&nbsp;jazyce <i>LISP</i> pou¾ít lambda výrazy, vytvoøit
(nadefinovat) u¾ivatelské funkce a pou¾ít rekurzi namísto programových smyèek.
&bdquo;Klasické&ldquo; implementace tohoto jazyka toti¾ neobsahují ¾ádnou
programovou konstrukci, pomocí ní¾ by bylo mo¾né programové smyèky zapsat,
proto¾e z&nbsp;teoretického hlediska je mo¾né ka¾dou programovou smyèku
nahradit rekurzí; ov¹em nìkteré novìj¹í implementace jazyka <i>LISP</i>
(napøíklad <i>AutoLISP</i>) buï programové smyèky pøímo podporují (jedná se o
<i>speciální formu</i>, nikoli bì¾nou primitivní funkci) nebo u¾ivatelùm nabízí
systém maker (<i>Common Lisp</i>), pomocí nich¾ lze smyèky pomìrnì pøímoèarým
zpùsobem vytvoøit.</p>



<p><a name="k08"></a></p>
<h2>8. Literatura</h2>

<ol>

<li>McCarthy<br />
<i>&bdquo;Recursive functions of symbolic expressions and their computation by machine, part I&ldquo;</i><br />
1960
</li>

<li>Guy L. Steele<br />
<i>&bdquo;History of Scheme&ldquo;</i><br />
2006, Sun Microsystems Laboratories
</li>

<li>
Koláø J., Muller K.:<br />
<i>&bdquo;Speciální programovací jazyky&ldquo;</i><br />
Praha 1981
</li>

<li>
<i>&bdquo;AutoLISP Release 9, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., October 1987
</li>

<li>
<i>&bdquo;AutoLISP Release 10, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., September 1988
</li>

<li>McCarthy, John; Abrahams, Paul W.; Edwards, Daniel J.; Hart, Timothy P.; Levin, Michael I.<br />
<i>&bdquo;LISP 1.5 Programmer's Manual&ldquo;</i><br />
MIT Press. ISBN 0 262 130 1 1 4
</li>

<li>Carl Hewitt; Peter Bishop and Richard Steiger<br />
<i>&bdquo;A Universal Modular Actor Formalism for Artificial Intelligence&ldquo;</i><br />
1973
</li>

<li>Feiman, J.<br />
<i>&bdquo;The Gartner Programming Language Survey (October 2001)&ldquo;</i><br />
Gartner Advisory
</li>

<li>Griswold R. E., Poage J. F., Polonsky I. P.:<br />
<i>&bdquo;The SNOBOL4 Programming Language&ldquo;</i><br />
second edition, Bell Telephone Laboratories, 1968, 1971
</li>

</ol>



<p><a name="k09"></a></p>
<h2>9. Odkazy na Internetu</h2>

<ol>

<li>SNOBOL4 and SPITBOL Information<br />
<a href="http://www.snobol4.com/">http://www.snobol4.com/</a>
</li>

<li>Vanilla Snobol4 Reference Manual<br />
<a href="http://burks.bton.ac.uk/burks/language/snobol/catspaw/manual/contents.htm">http://burks.bton.ac.uk/burks/language/snobol/catspaw/manual/contents.htm</a>
</li>

<li>SNOBOL4.ORG &ndash; SNOBOL4 Resources<br />
<a href="http://www.snobol4.org/">http://www.snobol4.org/</a>
</li>

<li>Snobol3 &ndash; Snobol 3 Interpreter Implemented in Java<br />
<a href="http://serl.cs.colorado.edu/~dennis/software/s3.html">http://serl.cs.colorado.edu/~dennis/software/s3.html</a>
</li>

<li>Exploring Beautiful Languages &ndash; A guick look at SNOBOL<br />
<a href="http://langexplr.blogspot.com/2007/12/quick-look-at-snobol.html">http://langexplr.blogspot.com/2007/12/quick-look-at-snobol.html</a>
</li>

<li>Rosetta Code: Roman_numerals<br />
<a href="http://rosettacode.org/wiki/Roman_numerals">http://rosettacode.org/wiki/Roman_numerals</a>
</li>

<li>Category:SNOBOL4<br />
<a href="http://rosettacode.org/wiki/Category:SNOBOL4">http://rosettacode.org/wiki/Category:SNOBOL4</a>
</li>

<li>An introduction to SNOBOL by James Ford<br />
<a href="http://drofmij.awardspace.com/snobol/">http://drofmij.awardspace.com/snobol/</a>
</li>

<li>Humor on Computers, Systems and Programming<br />
<a href="http://www-crypto.htw-saarland.de/weber/misc/programming.html">http://www-crypto.htw-saarland.de/weber/misc/programming.html</a>
</li>

<li>Rosetta Code &ndash; Category:Lisp<br />
<a href="http://rosettacode.org/wiki/Category:Lisp">http://rosettacode.org/wiki/Category:Lisp</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2010</small></p>
</body>
</html>

