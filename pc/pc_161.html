<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>SIMD instrukce v moderních mikroprocesorech øady x86 (3.èást: SSE2)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>SIMD instrukce v moderních mikroprocesorech øady x86 (3.èást: SSE2)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o architekturách poèítaèù se zamìøíme na popis technologie SSE2. Jedná se o roz¹íøenou instrukèní sadu se SIMD instrukcemi urèenou pro mikroprocesory øady x86, která byla postavena na instrukèních sadách MMX a SSE, jimi¾ jsme se zabývali v pøedchozích dvou èástech tohoto seriálu. V rámci SSE2 bylo zavedeno celkem 144 nových instrukcí a pìt &bdquo;vektorových&ldquo; datových typù.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Urychlení výpoètù s&nbsp;vyu¾itím SIMD instrukcí</a></p>
<p><a href="#k02">2. Roz¹íøení instrukèní sady SSE2 ve funkci vylep¹ené SSE</a></p>
<p><a href="#k03">3. Typy dat, s&nbsp;nim¾ je mo¾né pracovat v&nbsp;instrukèní sadì SSE2</a></p>
<p><a href="#k04">4. Nové instrukce pøidané do instrukèní sady SSE2</a></p>
<p><a href="#k05">5. Aritmetické instrukce v&nbsp;instrukèní sadì SSE2</a></p>
<p><a href="#k06">6. Logické a aritmetické posuny</a></p>
<p><a href="#k07">7. Logické operace</a></p>
<p><a href="#k08">8. Konverzí instrukce</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2>1. Urychlení výpoètù s&nbsp;vyu¾itím SIMD instrukcí</h2>

<p>V&nbsp;pøedchozí èásti seriálu o architekturách poèítaèù jsme se zabývali
popisem postupného (a pomìrnì rychlého) vývoje instrukcí typu <i>SIMD (Single
Instruction Multiple Data)</i>, tj.&nbsp;instrukcí pracujících s&nbsp;vektory
konstantní délky, na mikroprocesorech kompatibilních s&nbsp;32bitovou øadou
<i>x86</i>. Pùvodní &ndash; na platformì <i>x86</i> historicky první &ndash;
roz¹íøená instrukèní sada <i>MMX</i> spoleènosti <i>Intel</i> z&nbsp;roku 1996
byla v&nbsp;roce 1998 doplnìna o roz¹íøení instrukcí pojmenovaných
<i>3DNow!</i>, jejím¾ autorem je firma <i>AMD</i>. Nové instrukce obsa¾ené
v&nbsp;této sadì byly vìt¹inou urèeny pro provádìní výpoètù s&nbsp;numerickými
hodnotami s&nbsp;plovoucí øádovou èárkou s&nbsp;jednoduchou pøesností, které
jsou v&nbsp;programovacích jazycích vìt¹inou oznaèovány klíèovým slovem
<strong>single</strong> nebo <strong>float</strong>. Abychom byli zcela pøesní:
díky instrukcím obsa¾eným v&nbsp;sadì <i>3DNow!</i> bylo mo¾né pracovat
s&nbsp;dvouprvkovými vektory s&nbsp;ulo¾enými èísly typu <i>single</i>, proto¾e
èísla tohoto typu jsou reprezentována 32bitovými slovy, co¾ znamená, ¾e do
pùvodních <i>MMX</i> registrù o ¹íøce 64 bitù bylo mo¾né ulo¾it dvouprvkový
vektor a provádìt tak základní aritmetické operace (doplnìné o výpoèet
pøevrácené hodnoty a druhé odmocniny) s&nbsp;dvojicí dvouprvkových vektorù.</p>

<a href="http://i.iinfo.cz/images/311/pc158-8.jpg"><img src="http://i.iinfo.cz/images/311/pc158-8-prev.jpg" width="370" height="155" alt="&#160;" /></a>
<p><i>Obrázek 1: Typy vektorù, s&nbsp;nimi¾ pracují instrukce MMX.</i></p>

<p>Jak instrukce z&nbsp;instrukèní sady <i>MMX</i>, tak i instrukce ze sady
<i>3DNow!</i> vyu¾ívaly osmici registrù urèených pùvodnì pro pou¾ití
matematickým koprocesorem (<i>FPU &ndash; Floating Point Unit</i>). To
znamenalo jak úsporu plochy èipu (nejedná se samozøejmì pouze o klopné obvody
realizující jednotlivé bity registrù, ale i o úpravu interních sbìrnic atd.),
tak i kompatibilitu s&nbsp;tehdy existujícími operaèními systémy, proto¾e
nenastávaly problémy pøi pøepínání kontextu. I pøes urèitá omezení, která byla
zpùsobena nutností pøepínání mezi funkcí matematického koprocesoru a jednotkami
<i>MMX</i> èi <i>3DNow!</i> dokázali vývojáøi nìkteré algoritmy optimalizovat
takovým zpùsobem, ¾e nárùst výkonu byl v&nbsp;porovnání s&nbsp;pùvodní
&bdquo;skalární&ldquo; implementací a¾ nìkolikanásobný. Na druhém obrázku je
pro ilustraci zobrazen graf zvý¹ení výkonu v&nbsp;algoritmech pro práci
s&nbsp;videem i audiem a navíc v&nbsp;algoritmu pro aplikaci konvoluèního
filtru na rastrové obrázky. V&nbsp;tìchto pøípadech se kladnì projevily jak
mo¾nosti práce s&nbsp;vektory dat, tak i nové instrukce pro provádìní
aritmetických operací se saturací (<i>MMX</i>), které by se jinak musely øe¹it
pomocí podmínìného skoku.</p>

<img src="http://i.iinfo.cz/images/13/pc161-01.png" width="302" height="348" alt="&#160;" />
<p><i>Obrázek 2: Pøíklad ilustrující, jakým zpùsobem do¹lo k&nbsp;urychlení
algoritmù pro zpracování video a audio dat i algoritmu pro aplikaci
konvoluèního filtru díky pou¾ití instrukèní sady MMX. Na vertikální osu je
naneseno relativní zrychlení výpoètu, tj.&nbsp;v&nbsp;posledním pøípadì se bìh
programu zrychlil 4,5&times;</i></p>



<p><a name="k02"></a></p>
<h2>2. Roz¹íøení instrukèní sady SSE2 ve funkci vylep¹ené SSE</h2>

<p>Ponìkud odli¹nou cestou, ne¾ tomu bylo u technologií <i>MMX</i> a
<i>3DNow!</i>, se v&nbsp;roce 1999 vydala firma <i>Intel</i> v&nbsp;pøípadì
instrukèní sady pojmenované <i>SSE (Streaming SIMD Extensions)</i>.
Díky zavedení této technologie do¹lo k&nbsp;pøidání osmi nových
pracovních registrù s &ndash; na platformì <i>x86</i> doposud nevídanou &ndash;
¹íøkou 128 bitù. Vzhledem k&nbsp;tomu, ¾e se zmìnil poèet pracovních registrù,
bylo nutné nìkteré èásti systému i aplikací upravit takovým zpùsobem, aby pøi
pøepnutí kontextu nedocházelo ke vzájemnému pøepisování tìchto registrù (ov¹em
jen za pøedpokladu, ¾e operaèní systém práci s&nbsp;instrukcemi <i>SSE</i>
povolil). Roz¹iøující instrukèní sada <i>SSE</i> obsahovala sedmdesát nových
instrukcí orientovaných vìt¹inou na práci s&nbsp;vektory obsahujícími ètyøi
èísla typu <i>single</i>. Jednalo se o výrazné zlep¹ení oproti mo¾nostem
nabízeným konkurenèní sadou <i>3DNow!</i>, proto¾e pøi práci s&nbsp;reálnými
èísly s&nbsp;jednoduchou pøesností bylo mo¾né teoreticky dosáhnout a¾
dvojnásobného výpoèetního výkonu v&nbsp;porovnání s&nbsp;<i>3DNow!</i> a
ètyønásobného výkonu oproti práci se skalárním matematickým koprocesorem.</p>

<img src="http://i.iinfo.cz/images/147/pc161-02.png" width="500" height="323" alt="&#160;" />
<p><i>Obrázek 3: Zjednodu¹ený programátorský model mikroprocesoru x86
s&nbsp;podporou MMX a SSE (i SSE2). V&nbsp;rámci MMX do¹lo k&nbsp;pøidání
osmice 64bitových registrù sdílených s&nbsp;FPU (modrý rámeèek), zatímco
v&nbsp;rámci SSE bylo pøidáno osm registrù 128bitových a 32bitového øídicího
registru MXCSR (dva èervené rámeèky).</i></p>

<p>V&nbsp;praxi byla dosa¾ená zmìna výpoèetního výkonu samozøejmì ni¾¹í,
zejména v&nbsp;pøípadech, kdy bylo nutné data èasto pøená¹et mezi operaèní
pamìtí a registry mikroprocesoru (obecnì platí, ¾e èím více operací se provede
s&nbsp;jednou naètenými daty, tím je pøírùstek výkonu dosa¾ený díky <i>SSE</i>
a <i>3DNow!</i> vy¹¹í). Ov¹em záhy po uvedení instrukèní sady <i>SSE</i> se
mnozí vývojáøi zaèali ptát, proè se vìt¹ina instrukcí omezuje pouze na práci
s&nbsp;èísly s&nbsp;jednoduchou pøesností, kdy¾ je mnoho aplikací zalo¾ených na
celoèíselných datech (osmibitových bajtech, ¹estnáctibitových slovech,
32bitových slovech atd.), které by tak mohly vyu¾ívat v¹ech mo¾ností nabízených
novými 128bitovými registry technologie <i>SSE</i>. Vývojáøi pracující
pøedev¹ím na vývoji algoritmù z&nbsp;oblasti numerické matematiky by naopak
uvítali práci s&nbsp;èísly s&nbsp;dvojitou pøesností (<i>double</i>) ulo¾enými
v&nbsp;64 bitech (tj.&nbsp;v&nbsp;pøípadì 128bitových registrù by bylo mo¾né do
tìchto registrù ukládat dvojice èísel s&nbsp;dvojitou pøesností). Odpovìdí na
oba v&nbsp;podstatì protichùdné po¾adavky byla instrukèní sada pojmenovaná
jednodu¹e <i>SSE2</i> z&nbsp;roku 2001. Tato sada byla zpoèátku pou¾ita
v&nbsp;mikroprocesorech <i>Intel Pentium 4</i> a <i>Intel Xeon</i>, pozdìji se
v¹ak roz¹íøila i na procesory firmy <i>AMD</i> (<i>Athlon64</i>,
<i>Opteron</i>).</p>

<img src="http://i.iinfo.cz/images/503/pc160-4.jpg" width="353" height="143" alt="&#160;" />
<p><i>Obrázek 4: Jiný pohled na zjednodu¹ený programátorský model architektury
x86 v&nbsp;32bitovém re¾imu.</i></p>



<p><a name="k03"></a></p>
<h2>3. Typy dat, s&nbsp;nim¾ je mo¾né pracovat v&nbsp;instrukèní sadì SSE2</h2>

<p>Technologie <i>SSE2</i> pøinesla nové instrukce a samozøejmì i podstatné
zmìny v&nbsp;interní struktuøe vektorové jednotky, ov¹em poèet registrù ani
jejich bitová ¹íøka se nijak nezmìnila. Programátoøi pou¾ívající, a» ji¾ pøímo
èi nepøímo, roz¹íøení instrukèní sady <i>SSE2</i> mohli do osmice 128bitových
registrù pojmenovaných <i>XMM*</i> ukládat celkem ¹est rùzných typù vektorù.
Základ zùstal nezmìnìn &ndash; jednalo se o ètyøprvkové vektory obsahující
èísla reprezentovaná ve formátu plovoucí øádové èárky, pøièem¾ ka¾dé èíslo bylo
ulo¾eno v&nbsp;32 bitech (4&times;32=128 bitù), co¾ odpovídá typu
<i>single/float</i> definovanému v&nbsp;normì <i>IEEE 754</i>. Kromì toho byly
v&nbsp;rámci <i>SSE2</i> je¹tì zavedeny dvouprvkové vektory obsahující takté¾
hodnoty reprezentované ve formátu plovoucí øádové èárky, ov¹em tentokrát se
jedná o èísla ulo¾ená v&nbsp;64 bitech (2&times;64=128) odpovídající dvojité
pøesnosti (<i>double</i>) z&nbsp;normy <i>IEEE 754</i>. Zbývají nám ètyøi dal¹í
podporované datové typy. Jedná se o vektory s&nbsp;celoèíselnými prvky:
¹estnáctiprvkové vektory s&nbsp;osmibitovými hodnotami, osmiprvkové vektory
s&nbsp;¹estnáctibitovými hodnotami, ètyøprvkové vektory s&nbsp;32bitovými
hodnotami a koneènì dvouprvkové vektory s&nbsp;64bitovými celoèíselnými
hodnotami.</p>

<a href="http://i.iinfo.cz/images/221/pc161-03.png"><img src="http://i.iinfo.cz/images/221/pc161-03-prev.png" width="370" height="178" alt="&#160;" /></a>
<p><i>Obrázek 5: Nové typy vektorù, s&nbsp;kterými je novì mo¾né nativnì
pracovat na mikroprocesorech podporujících technologii SSE2.</i></p>

<p>Jak jsme si ji¾ øekli v&nbsp;pøedminulé èásti tohoto seriálu pøi popisu
roz¹íøení instrukèní sady <i>MMX</i>, je mo¾né vektory obsahující celoèíselná
data vyu¾ít pro pomìrnì velké mno¾ství aplikací, zejména pro zpracování
zvukového signálu, ale takté¾ pro rùzné operace s&nbsp;rastrovými obrázky
(filtrace, nìkteré zpùsoby komprimace apod.) nebo videem (estimace pohybu
pou¾ité v&nbsp;MPEG). Na druhé stranì spektra datových typù podporovaných
funkèní jednotkou <i>SSE2</i> le¾í vektory obsahující dvojici numerických
hodnot typu <i>double</i>, co¾ mj.&nbsp;znamená, ¾e instrukce <i>SSE2</i> je
mo¾né vyu¾ít i v&nbsp;nìkterých oblastech numerické matematiky, i kdy¾ je na
tomto místì nutné øíct, ¾e pøímo v&nbsp;<i>SSE2</i> nejsou podporována èísla
s&nbsp;roz¹íøenou pøesností (<i>extended</i>), tak¾e v&nbsp;nìkterých pøípadech
mù¾e dojít pøi výpoètech v&nbsp;jednotce <i>SSE2</i> (a nikoli <i>FPU</i>) ke
kumulaci chyb ve výsledku. Nicménì kombinace instrukcí urèených pro matematický
koprocesor s&nbsp;instrukcemi urèenými pro funkèní jednotku <i>SSE2</i> byla
mo¾ná a v&nbsp;mnoha pøípadech dokonce nutná, proto¾e matematický koprocesor
kromì základních aritmetických operací podporuje napøíklad i výpoèet
goniometrických funkcí, logaritmù atd.</p>

<a href="http://i.iinfo.cz/images/503/pc160-7.jpg"><img src="http://i.iinfo.cz/images/503/pc160-7-prev.jpg" width="370" height="75" alt="&#160;" /></a>
<p><i>Obrázek 6: Formát 32bitových slov obsahujících hodnoty s&nbsp;plovoucí
øádovou èárkou podle normy IEEE 754 (single/float) tvoøí základ instrukcí
3DNow! i SSE a je samozøejmì podporován i instrukèní sadou SSE2.</i></p>



<p><a name="k04"></a></p>
<h2>4. Nové instrukce pøidané do instrukèní sady SSE2</h2>

<p>Zatímco se v&nbsp;roz¹iøující instrukèní sadì <i>SSE</i> popsané
v&nbsp;pøedcházející èásti tohoto seriálu nacházelo &bdquo;pouze&ldquo; 70
nových instrukcí, byli tvùrci instrukèní sady <i>SSE2</i> mnohem velkorysej¹í,
proto¾e navrhli a posléze i implementovali hned 144 nových instrukcí, co¾
pøibli¾nì odpovídá poètu v¹ech základních instrukcí procesorù <i>x86</i> (pokud
samozøejmì nepoèítáme v¹echny povolené adresní re¾imy). Tento velký poèet
nových instrukcí souvisí jak s&nbsp;podporou ¹esti datových typù popsaných
v&nbsp;pøedchozí kapitole (vèetnì více ne¾ dvaceti konverzních funkcí), tak i
s&nbsp;novými re¾imy pøístupu k&nbsp;prvkùm ulo¾eným ve vektorech a se zcela
novými operacemi, které byly navr¾eny pro podporu algoritmù pro 3D grafiku a
práci s&nbsp;videem. V¹echny instrukce, které byly pøidány v&nbsp;roz¹iøující
instrukèní sadì <i>SSE2</i>, je mo¾né rozdìlit do nìkolika kategorií:</p>

<ol>
<li>Aritmetické operace provádìné s&nbsp;celými èísly (vèetnì souètu a rozdílu se saturací)</li>
<li>Aritmetické operace provádìné s&nbsp;èísly s&nbsp;plovoucí øádovou èárkou</li>
<li>Logické operace (nìkteré jsou provádìny pro v¹ech 128 bitù)</li>
<li>Bitové posuny prvkù o rùzné bitové ¹íøce</li>
<li>Porovnávací (komparaèní, relaèní) operace</li>
<li>Konverzní funkce</li>
<li>Konverze prvkù ulo¾ených ve vektorech (zvý¹ení èi sní¾ení bitové ¹íøky, shuffling apod.)</li>
<li>Naèítání a ukládání dat do operaèní pamìti</li>
<li>Øízení vyrovnávací pamìti (cache)</li>
</ol>

<img src="http://i.iinfo.cz/images/75/pc161-04.png" width="500" height="300" alt="&#160;" />
<p><i>Obrázek 7: Ukázka urychlení operace souètu 1024 èíselných prvkù
reprezentovaných ve formátu s&nbsp;plovoucí øádovou èárkou. Celkem byly pou¾ity
ètyøi algoritmy pro souèet:<br />
1 - vyu¾ití instrukcí FPU<br />
2 - vyu¾ití instrukcí FPU s&nbsp;rozbalením smyèky<br />
3 - vyu¾ití vektorových operací SSE/SSE2<br />
4 - vyu¾ití vektorových operací SSE/SSE2 s&nbsp;rozbalením smyèky</i></p>



<p><a name="k05"></a></p>
<h2>5. Aritmetické instrukce v&nbsp;instrukèní sadì SSE2</h2>

<p>Podobnì jako u roz¹iøujících instrukèních sad <i>MMX</i>, <i>3DNow!</i> a
<i>SSE</i>, tvoøí i u instrukèní sady <i>SSE2</i> nejpodstatnìj¹í èást
instrukce urèené pro provádìní aritmetických operací nad vektory prvkù rùzných
datových typù. V¹echny nové operace implementované v&nbsp;<i>SSE2</i> jsou
vypsány v&nbsp;následující tabulce. Ve tøetím sloupci je naznaèeno, jaké
vektory jsou danou operací zpracovávány, pøièem¾ první èíslo znamená poèet
prvkù vektoru, za ním¾ následuje bitová ¹íøka jednotlivých prvkù:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Operace/funkce</th><th>Struktura vektoru</th><th>Datový typ</th><th>Saturace?</th><th>Poznámka</th></tr>
<tr><td> 1</td><td>addpd  </td><td>souèet            </td><td>2&times;64bit</td><td>double  </td><td>&times;</td><td>&nbsp;</td></tr>
<tr><td> 2</td><td>addsd  </td><td>souèet            </td><td>1&times;64bit</td><td>double  </td><td>&times;</td><td>operace provedena jen s&nbsp;pravým prvkem vektorù</td></tr>
<tr><td> 3</td><td>subpd  </td><td>rozdíl            </td><td>2&times;64bit</td><td>double  </td><td>&times;</td><td>&nbsp;</td></tr>
<tr><td> 4</td><td>subsd  </td><td>rozdíl            </td><td>1&times;64bit</td><td>double  </td><td>&times;</td><td>operace provedena jen s&nbsp;pravým prvkem vektorù</td></tr>
<tr><td> 5</td><td>mulpd  </td><td>souèin            </td><td>2&times;64bit</td><td>double  </td><td>&times;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>mulsd  </td><td>souèin            </td><td>1&times;64bit</td><td>double  </td><td>&times;</td><td>operace provedena jen s&nbsp;pravým prvkem vektorù</td></tr>
<tr><td> 7</td><td>divpd  </td><td>podíl             </td><td>2&times;64bit</td><td>double  </td><td>&times;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>divsd  </td><td>podíl             </td><td>1&times;64bit</td><td>double  </td><td>&times;</td><td>operace provedena jen s&nbsp;pravým prvkem vektorù</td></tr>
<tr><td> 9</td><td>paddb  </td><td>souèet            </td><td>16&times;8bit</td><td>integer </td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>10</td><td>paddw  </td><td>souèet            </td><td>8&times;16bit</td><td>integer </td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>11</td><td>paddd  </td><td>souèet            </td><td>4&times;32bit</td><td>integer </td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>12</td><td>paddq  </td><td>souèet            </td><td>2&times;64bit</td><td>integer </td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>13</td><td>paddsb </td><td>souèet            </td><td>16&times;8bit</td><td>integer </td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>14</td><td>paddsw </td><td>souèet            </td><td>8&times;16bit</td><td>integer </td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>paddusb</td><td>souèet            </td><td>16&times;8bit</td><td>unsigned</td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>paddusw</td><td>souèet            </td><td>8&times;16bit</td><td>unsigned</td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>17</td><td>psubb  </td><td>rozdíl            </td><td>16&times;8bit</td><td>integer </td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>18</td><td>psubw  </td><td>rozdíl            </td><td>8&times;16bit</td><td>integer </td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>19</td><td>psubd  </td><td>rozdíl            </td><td>4&times;32bit</td><td>integer </td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>20</td><td>psubq  </td><td>rozdíl            </td><td>2&times;64bit</td><td>integer </td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>21</td><td>psubsb </td><td>rozdíl            </td><td>16&times;8bit</td><td>integer </td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>psubsw </td><td>rozdíl            </td><td>8&times;16bit</td><td>integer </td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>23</td><td>psubusb</td><td>rozdíl            </td><td>16&times;8bit</td><td>unsigned</td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>24</td><td>psubusw</td><td>rozdíl            </td><td>8&times;16bit</td><td>unsigned</td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>25</td><td>maxpd  </td><td>maximum           </td><td>2&times;64bit</td><td>double  </td><td>&times;</td><td>&nbsp;                                                   </td></tr>
<tr><td>26</td><td>maxsd  </td><td>maximum           </td><td>2&times;64bit</td><td>double  </td><td>&times;</td><td>operace provedena jen s&nbsp;pravým prvkem vektorù</td></tr>
<tr><td>27</td><td>minpd  </td><td>minimum           </td><td>2&times;64bit</td><td>double  </td><td>&times;</td><td>&nbsp;                                                   </td></tr>
<tr><td>28</td><td>minsd  </td><td>minimum           </td><td>2&times;64bit</td><td>double  </td><td>&times;</td><td>operace provedena jen s&nbsp;pravým prvkem vektorù</td></tr>
<tr><td>29</td><td>pmaddwd</td><td>souèin/add        </td><td>8&times;16bit</td><td>integer </td><td>&times;</td><td>&nbsp;                                                   </td></tr>
<tr><td>30</td><td>pmulhw </td><td>souèin            </td><td>8&times;16bit</td><td>integer </td><td>&times;</td><td>vrací vektor horních 16 bitù výsledkù</td></tr>
<tr><td>31</td><td>pmullw </td><td>souèin            </td><td>8&times;16bit</td><td>integer </td><td>&times;</td><td>vrací vektor dolních 16 bitù výsledkù</td></tr>
<tr><td>32</td><td>pmuludq</td><td>souèin            </td><td>4&times;32bit</td><td>integer </td><td>&times;</td><td>64 bitový výsledek pro ka¾dý souèin  </td></tr>
<tr><td>33</td><td>rcpps  </td><td>pøevrácená hodnota</td><td>4&times;32bit</td><td>single  </td><td>&times;</td><td>aproximace                                               </td></tr>
<tr><td>34</td><td>rcpss  </td><td>pøevrácená hodnota</td><td>4&times;32bit</td><td>single  </td><td>&times;</td><td>operace provedena jen s&nbsp;pravým prvkem vektorù</td></tr>
<tr><td>35</td><td>sqrtpd </td><td>druhá odmocnina   </td><td>2&times;64bit</td><td>double  </td><td>&times;</td><td>&nbsp;                                                   </td></tr>
<tr><td>36</td><td>sqrtsd </td><td>druhá odmocnina   </td><td>2&times;64bit</td><td>double  </td><td>&times;</td><td>&nbsp; operace provedena jen s&nbsp;pravým prvkem vektorù</td></tr>
</table>

<img src="http://i.iinfo.cz/images/612/pc161-05.png" width="500" height="300" alt="&#160;" />
<p><i>Obrázek 8: Ukázka urychlení operace výpoètu skalárního souèinu pro 1024
trojrozmìrných vektorù. Prvky vektorù jsou opìt reprezentovány ve formátu
s&nbsp;plovoucí øádovou èárkou. Celkem byly pou¾ity ètyøi algoritmy pro
souèet:<br />
1 - vyu¾ití instrukcí FPU<br />
2 - vyu¾ití instrukcí FPU s&nbsp;rozbalením smyèky<br />
3 - vyu¾ití vektorových operací SSE/SSE2<br />
4 - vyu¾ití vektorových operací SSE/SSE2 s&nbsp;rozbalením smyèky<br />
Dùvod, proè ze do¹lo k&nbsp;vìt¹ímu urychlení pøi pou¾ití SSE/SSE2 je
jednoduchý: s&nbsp;jednou naètenými daty (vektory) se provádìlo vìt¹í mno¾ství
operací, tak¾e se zde v&nbsp;men¹í míøe projevila latence operaèních pamìtí a
dal¹í externí vlivy. Sice je mo¾né najít i algoritmy, u nich¾ je dosa¾eno je¹tì
vìt¹ího urychlení výpoètù, ale v&nbsp;praxi je zhruba trojnásobné urychlení
(podobnì jako na tomto grafu) pova¾ováno za velký úspìch.</i></p>



<p><a name="k06"></a></p>
<h2>6. Logické a aritmetické posuny</h2>

<p>V&nbsp;instrukèní sadì <i>SSE2</i> mù¾eme najít i nové logické instrukce a
instrukce pro provádìní logických èi aritmetických posunù. Ve skuteènosti se
vlastnì jedná o pouhé roz¹íøení stávajících instrukcí <i>MMX</i> takovým
zpùsobem, aby bylo mo¾né pracovat s&nbsp;novými 128bitovými vektory,
popø.&nbsp;s&nbsp;daty ulo¾enými v&nbsp;operaèní pamìti v&nbsp;bloku ¹estnácti
bajtù (16&times;8=128 bitù). Nejprve si popi¹me instrukce pro aritmetické a
logické posuny. Ty doká¾ou pracovat s&nbsp;celoèíselnými hodnotami o velikosti
16, 32, 64 èi 128 bitù, tj.&nbsp;ka¾dá èást vektoru se posouvá zvlá¹» (je tedy
rozdíl mezi posunem jednoho 128bitového èísla a dvojice 64bitových èísel). Pøi
logických posunech se do nového bitu nasouvá v¾dy logická nula (nikoli pøíznak
<i>carry</i>), u aritmetických posunù se opakuje hodnota pùvodního nejvy¹¹ího
bitu, tj.&nbsp;instrukce pracují pøesnì tak, jak to programátoøi oèekávají:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Operace/funkce</th><th>Struktura vektoru</th><th>Datový typ</th><th>Poznámka</th></tr>
<tr><td> 1</td><td>pslldq</td><td>logický posun doleva     </td><td>1&times;128bitù</td><td>integer</td><td>&nbsp;</td></tr>
<tr><td> 2</td><td>psllq </td><td>logický posun doleva     </td><td>2&times;64bitù </td><td>integer</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>pslld </td><td>logický posun doleva     </td><td>4&times;32bitù </td><td>integer</td><td>&nbsp;</td></tr>
<tr><td> 4</td><td>psllw </td><td>logický posun doleva     </td><td>8&times;16bitù </td><td>integer</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>psrldq</td><td>logický posun doprava    </td><td>1&times;128bitù</td><td>integer</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>psrlq </td><td>logický posun doprava    </td><td>2&times;64bitù </td><td>integer</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>psrld </td><td>logický posun doprava    </td><td>4&times;32bitù </td><td>integer</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>psrlw </td><td>logický posun doprava    </td><td>8&times;16bitù </td><td>integer</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>psrad </td><td>aritmetický posun doprava</td><td>4&times;32bitù </td><td>integer</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>psraw </td><td>aritmetický posun doprava</td><td>8&times;16bitù </td><td>integer</td><td>&nbsp;</td></tr>
</table>

<img src="http://i.iinfo.cz/images/503/pc160-6.png" width="450" height="304" alt="&#160;" />
<p><i>Obrázek 9: Vektorové operace podporované instrukèní sadou SSE a
samozøejmì i SSE2.</i></p>



<p><a name="k07"></a></p>
<h2>7. Logické operace</h2>

<p>Následuje seznam instrukcí urèených pro provádìní logických operací nad
vektory rùzné délky. V&nbsp;nìkterých pøípadech (<strong>PAND, POR,
PXOR</strong>) se jedná o roz¹íøení pùvodních <i>MMX</i> instrukcí takovým
zpùsobem, aby tyto instrukce mohly pracovat se 128bitovými vektory. Dokonce i
operaèní kódy instrukcí zùstávají stejné, ov¹em v&nbsp;pøípadì <i>SSE2</i> je
pøed vlastním instrukèním kódem uveden prefix 0x66, tak¾e jsou instrukce o
jeden bajt del¹í (to ostatnì platí i pro aritmetické operace popsané o kapitolu
vý¹e):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Operace/funkce</th><th>Struktura vektoru</th><th>Datový typ</th><th>Poznámka</th></tr>
<tr><td> 1</td><td>pand  </td><td>and    </td><td>1&times;128 bitù</td><td>integer</td><td>&nbsp;</td></tr>
<tr><td> 2</td><td>pandn </td><td>not and</td><td>1&times;128 bitù</td><td>integer</td><td>první operand je negován</td></tr>
<tr><td> 3</td><td>por   </td><td>or     </td><td>1&times;128 bitù</td><td>integer</td><td>&nbsp;</td></tr>
<tr><td> 4</td><td>pxor  </td><td>xor    </td><td>1&times;128 bitù</td><td>integer</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>andpd </td><td>and    </td><td>2&times;64 bitù </td><td>double </td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>orpd  </td><td>or     </td><td>2&times;64 bitù </td><td>double </td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>xorpd </td><td>xor    </td><td>2&times;64 bitù </td><td>double </td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>andnpd</td><td>not and</td><td>2&times;64 bitù </td><td>double </td><td>první operand je negován</td></tr>
<tr><td> 9</td><td>andnps</td><td>not and</td><td>4&times;32 bitù </td><td>single </td><td>první operand je negován</td></tr>
</table>

<img src="http://i.iinfo.cz/images/503/pc160-1.jpg" width="400" height="365" alt="&#160;" />
<p><i>Obrázek 10: Intel Xeon 5600 je zástupcem mikroprocesorù urèených pro
oblast serverù. Samozøejmì takté¾ podporuje SIMD operace: MMX, SSE, SSE2, SSE3,
SSSE3, SSE4.1, SSE4.2</i></p>



<p><a name="k08"></a></p>
<h2>8. Konverzí instrukce</h2>

<p>Pøi implementaci mnoha algoritmù, pøedev¹ím pak pøi zpracování obrazových a
zvukových datových tokù, se mnohdy programátoøi dostanou do situace, kdy
potøebují zkonvertovat data do jiného formátu, ne¾ v&nbsp;jakém byla pùvodnì
ulo¾ena. Pro tyto úèely jsou v&nbsp;instrukèní sadì <i>SSE2</i>
k&nbsp;dispozici dvì desítky konverzních instrukcí zaèínajících prefixem
<strong>cvt</strong>, vypsaných v&nbsp;tabulce pod tímto odstavcem:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Konverze z...</th><th>Konverze do...</th></tr>
<tr><td> 1</td><td>cvtdq2pd </td><td>2&times;32bitový integer</td><td>2&times;64bitový double</td></tr>
<tr><td> 2</td><td>cvtdq2ps </td><td>4&times;32bitový integer</td><td>4&times;32bitový single</td></tr>
<tr><td> 3</td><td>cvtpd2pi </td><td>2&times;64bitový double </td><td>2&times;32bitový integer v&nbsp;MMX registru</td></tr>
<tr><td> 4</td><td>cvtpd2dq </td><td>2&times;64bitový double </td><td>2&times;32bitový integer ve spodní polovinì MMX registru</td></tr>
<tr><td> 5</td><td>cvtpd2ps </td><td>2&times;64bitový double </td><td>2&times;32bitový single ve spodní polovinì MMX registru</td></tr>
<tr><td> 6</td><td>cvtpi2pd </td><td>2&times;32bitový integer</td><td>2&times;32bitový single ve spodní polovinì MMX registru</td></tr>
<tr><td> 7</td><td>cvtps2dq </td><td>4&times;32bitový single </td><td>4&times;32bitový integer</td></tr>
<tr><td> 8</td><td>cvtps2pd </td><td>2&times;32bitový single </td><td>2&times;64bitový double</td></tr>
<tr><td> 9</td><td>cvtsd2si </td><td>1&times;64bitový double </td><td>1&times;32bitový integer v&nbsp;pracovním registru (CPU)</td></tr>
<tr><td>10</td><td>cvttpd2pi</td><td>2&times;64bitový double </td><td>2&times;32bitový integer (odseknutí desetinné èásti)</td></tr>
<tr><td>11</td><td>cvttpd2dq</td><td>2&times;64bitový double </td><td>2&times;32bitový integer (odseknutí desetinné èásti)</td></tr>
<tr><td>12</td><td>cvttps2dq</td><td>4&times;32bitový single </td><td>4&times;32bitový integer (odseknutí desetinné èásti)</td></tr>
<tr><td>13</td><td>cvttps2pi</td><td>2&times;32bitový single </td><td>2&times;32bitový integer (odseknutí desetinné èásti) v&nbsp;MMX registru</td></tr>
<tr><td>14</td><td>cvttsd2si</td><td>1&times;64bitový double </td><td>1&times;32bitový integer (odseknutí desetinné èásti) v&nbsp;pracovním registru</td></tr>
<tr><td>15</td><td>cvttss2si</td><td>1&times;32bitový single </td><td>1&times;32bitový integer (odseknutí desetinné èásti) v&nbsp;pracovním registru</td></tr>
<tr><td>16</td><td>cvtsi2sd </td><td>1&times;32bitový integer</td><td>1&times;64bitový double</td></tr>
<tr><td>17</td><td>cvtsi2ss </td><td>1&times;32bitový integer</td><td>1&times;32bitový single</td></tr>
<tr><td>18</td><td>cvtsd2ss </td><td>1&times;64bitový double </td><td>1&times;32bitový single (horní polovina registru se nemìní)</td></tr>
<tr><td>19</td><td>cvtss2sd </td><td>1&times;32bitový single </td><td>1&times;64bitový double</td></tr>
<tr><td>20</td><td>cvtss2si </td><td>1&times;32bitový single </td><td>1&times;32bitový integer v&nbsp;pracovním registru (CPU)</td></tr>
</table>

<a href="http://i.iinfo.cz/images/486/pc161-06.png"><img src="http://i.iinfo.cz/images/486/pc161-06-prev.png" width="370" height="182" alt="&#160;" /></a>
<p><i>Obrázek 11: Univerzální konverzní funkce PSHUF byla v&nbsp;instrukèní
sadì SSE2 roz¹íøena tak, aby dokázala pracovat i se 128bitovými
registry.</i></p>

<p><ins>Poznámka: popravdì øeèeno by se pro mnoho serverových aplikací hodily
je¹tì instrukce pro konverzi mezi <i>UTF-8</i> a <i>UCS-4</i>, co¾ je po
obvodové stránce pomìrnì jednoduchá bitová transformace, ov¹em obtí¾nì
reprezentovatelná v&nbsp;reálnì existujících strojových instrukcích.</ins></p>

<img src="http://i.iinfo.cz/images/572/pc161-07.png" width="329" height="330" alt="&#160;" />
<p><i>Obrázek 12: V&nbsp;rámci instrukèní sady Intel AVX do¹lo k&nbsp;dal¹ímu
zvý¹ení bitové ¹íøky &bdquo;vektorových&ldquo; registrù na 256 bitù.</i></p>



<p><a name="k09"></a></p>
<h2>9. Odkazy na Internetu</h2>

<ol>

<li>
Baha Guclu Dundar:<br />
Intel MMX, SSE, SSE2, SSE3/SSSE3/SSE4 Architectures
</li>

<li>
SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>
Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>
Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>
SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>
Tour of the Black Holes of Computing!: Floating Point<br />
<a href="http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt">http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt</a>
</li>

<li>3Dnow! Technology Manual<br />
AMD Inc., 2000</li>

<li>Intel MMX<sup>TM</sup> Technology Overview<br />
Intel corporation, 1996</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>AMD K5 ("K5" / "5k86")<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g5K5-c.html">http://www.pcguide.com/ref/cpu/fam/g5K5-c.html</a>
</li>

<li>Sixth Generation Processors<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g6.htm">http://www.pcguide.com/ref/cpu/fam/g6.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Very_long_instruction_word">http://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>Control unit (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Control_unit">http://en.wikipedia.org/wiki/Control_unit</a>
</li>

<li>Cray History<br />
<a href="http://www.cray.com/About/History.aspx?404;http://www.cray.com:80/about_cray/history.html">http://www.cray.com/About/History.aspx?404;http://www.cray.com:80/about_cray/history.html</a>
</li>

<li>Cray Historical Timeline<br />
<a href="http://www.cray.com/Assets/PDF/about/CrayTimeline.pdf">http://www.cray.com/Assets/PDF/about/CrayTimeline.pdf</a>
</li>

<li>Computer Speed Claims 1980 to 1996<br />
<a href="http://homepage.virgin.net/roy.longbottom/mips.htm">http://homepage.virgin.net/roy.longbottom/mips.htm</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2010</small></p>
</body>
</html>

