<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Mikroprocesory ARM a architektura VFP (Vector Floating Point)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Mikroprocesory ARM a architektura VFP (Vector Floating Point)</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o architekturách poèítaèù se ji¾ podruhé budeme zabývat zpùsobem zpracování numerických hodnot s plovoucí øádovou èárkou na mikroprocesorech ARM. Minule jsme si popsali technologii FPA (Floating Point Accelerator), dnes se zamìøíme na alternativní technologii VFP (Vector Floating Point).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Mikroprocesory ARM a architektura VFP (Vector Floating Point)</a></p>
<p><a href="#k02">2. Pracovní registry a formát zpracovávaných hodnot</a></p>
<p><a href="#k03">3. Øídicí a stavový registr FPSCR</a></p>
<p><a href="#k04">4. Skalární a vektorový re¾im FP instrukcí</a></p>
<p><a href="#k05">5. Rozdìlení registrù do bank, nastavení parametrù STRIDE a LEN</a></p>
<p><a href="#k06">6. Instrukèní sada VFP: vektorové aritmetické operace</a></p>
<p><a href="#k07">7. Porovnání dvou hodnot, porovnání s&nbsp;nulou</a></p>
<p><a href="#k08">8. Pøesuny dat, naètení konstanty a konverzní instrukce</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Mikroprocesory ARM a architektura VFP (Vector Floating Point)</h2>

<p>V&nbsp;pøedchozí èásti <a
href="http://www.root.cz/serialy/co-se-deje-v-pocitaci/">seriálu o
architekturách poèítaèù</a> jsme se seznámili s&nbsp;technologií nazvanou
<i>FPA</i> neboli <i>Floating Point Architecture</i>. Jednalo se o jednu
z&nbsp;nìkolika dostupných technologií, která umo¾òovala na mikroprocesorech
s&nbsp;architekturou <i>ARM</i> zpracovávat numerické hodnoty ulo¾ené ve
formátu plovoucí øádové èárky (<i>FP &ndash; floating point</i>). Propojení
mezi jádrem procesorù <i>ARM</i> a matematickým koprocesorem <i>FPA</i> bylo
realizováno pøes standardizované rozhraní umo¾òující kooperaci s&nbsp;rùznými
typy koprocesorù, a» ji¾ se jedná o zde popisované matematické koprocesory, tak
i napøíklad o I/O procesory (øadièe USB...), grafické moduly atd. Pøipomeòme
si, ¾e matematické koprocesory <i>FPA</i> dokázaly pracovat s&nbsp;èísly
odpovídajícími v&nbsp;normì <i>IEEE 754</i> formátùm s&nbsp;jednoduchou
pøesností (<i>single/float</i>, ¹íøka 32 bitù), s&nbsp;dvojitou pøesností
(<i>double</i>, ¹íøka 64 bitù) a takté¾ s&nbsp;roz¹íøenou pøesností
(<i>extended</i>, ¹íøka 80 bitù).</p>

<p>Ov¹em ji¾ minule jsme se zmínili o tom, ¾e technologie <i>FPA</i> není
jedinou &bdquo;floating point&ldquo; technologií, kterou je mo¾né na
procesorech <i>ARM</i> vyu¾ít. Alternativní a dnes dokonce èastìji pou¾ívanou
technologií je <i>VFP</i>, co¾ je zkratka odvozená od <i>Vector Floating
Point</i> (jedná se o oznaèení, je¾ je v&nbsp;souèasnosti mo¾ná ji¾ ponìkud
zavádìjící). Technologie <i>VFP</i> byla navr¾ena takovým zpùsobem, aby ji bylo
mo¾né pou¾ít v&nbsp;mnoha aplikaèních oblastech, napøíklad v&nbsp;øídicích
jednotkách automobilù, pro zpracování obrazu (konvoluèní filtry, rychlá
Fourierova transformace, rasterizace a dal¹í operace provádìné v&nbsp;tiskových
procesorech), pøi zpracování øeèi (kodeky) a takté¾ pro provádìní rùzných 3D
operací (transformace) &ndash; právì v&nbsp;tìchto oblastech lze toti¾ vyu¾ít
práci nikoli pouze se skalárními hodnotami, ale takté¾ s&nbsp;vektory o dvou a¾
osmi prvcích. Zajímavé je, ¾e pozdìji do¹lo ke slouèení <i>VFP</i>
s&nbsp;architekturou <i>NEON</i>, o ní¾ se v&nbsp;tomto seriálu je¹tì urèitì
zmíníme.</p>

<p>Pùvodní architektura <i>VFPv1</i> je ji¾ dnes pova¾ována za pøekonanou a
v&nbsp;¾ádných souèasných èipech se s&nbsp;ní¾ ji¾ nesetkáme. Druhá verze této
architektury <i>VFPv2</i> zaèala být pou¾ívána na nìkterých èipech ARMv5E,
ARMv5TEJ a takté¾ na ARMv6 &ndash; instrukce <i>VFP</i> v&nbsp;tomto pøípadì
roz¹iøovaly pùvodní instrukèní sady <i>ARM</i>. Zajímavìj¹í je dnes tøetí verze
architektury <i>VFP</i> znaèená <i>VFPv3</i> pou¾ívaná od <i>ARMv7</i>
(samozøejmì jen u vybraných èipù &ndash; zdaleka ne v¹echny aplikaèní oblasti
toti¾ nutnì vy¾adují matematický koprocesor). V&nbsp;tomto pøípadì lze nové
&bdquo;vektorové&ldquo; instrukce pou¾ívat v&nbsp;instrukèní sadì ARM, Thumb i
ThumbEE.</p>

<p><ins>Poznámka: zatímco matematické koprocesory <i>FPA</i> byly vytváøeny
vìt¹inou na samostatném èipu, jsou jádra <i>VFP</i> pøímo souèástí stejných
èipù, na nich¾ je implementováno samotné jádro <i>ARM</i>.</ins></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Pracovní registry a formát zpracovávaných hodnot</h2>

<p>Na rozdíl od matematických koprocesorù <i>FPA</i> podporujících formáty
<i>single</i> (32bit), <i>double</i> (64bit) i <i>extended</i> (80bit) se u
technologie <i>VFP</i> pou¾ívají pøedev¹ím formáty <i>single/float</i> a
<i>double</i>, pøièem¾ existují roz¹íøení i pro formáty s&nbsp;polovièní
pøesností (<i>half-float</i>), které lze v&nbsp;nìkterých oblastech
s&nbsp;výhodou pou¾ívat, napøíklad pro ukládání barvových slo¾ek pixelù (zvý¹í
se tím mj.&nbsp;i dynamický rozsah pøi filtraci obrazu). Vzhledem k&nbsp;tomu,
¾e technologie <i>VFP</i> je urèena i pro aplikaci v&nbsp;systémech,
v&nbsp;nich¾ je mnohdy dùle¾ité dosáhnout co nejvìt¹ího výpoèetního výkonu
popø.&nbsp;co nejkrat¹í doby odezvy (RT aplikace), mù¾e matematický koprocesor
<i>VFP</i> pracovat buï v&nbsp;re¾imu <i>full compliance</i>, který je pøímo
kompatibilní s&nbsp;normou <i>IEEE 754</i>, popø.&nbsp;je mo¾né povést pøepnutí
do re¾imu <i>RunFast</i>, v&nbsp;nìm¾ se negenerují nìkteré výjimky a takté¾
mù¾e dojít ke ztrátì pøesnosti v&nbsp;nejni¾¹ích bitech mantisy (vìt¹inou pouze
v&nbsp;bitu nejni¾¹ím). Vlastnosti obou re¾imù jsou samozøejmì velmi pøesnì
popsány, tak¾e zále¾í jen na vývojáøi, který re¾im v&nbsp;daný okam¾ik
pou¾ije.</p>

<p>Matematické koprocesory <i>VFP</i> obecnì obsahují ¹estnáct pracovních
registrù, ka¾dý o ¹íøce 64 bitù. Tyto registry lze pou¾ít buï pro práci
s&nbsp;hodnotami s&nbsp;dvojitou pøesností (<i>double</i>) &ndash; potom se
tyto registry v&nbsp;assembleru oznaèují jmény <strong>d0</strong> a¾
<strong>d15</strong>. Ov¹em takté¾ je mo¾né libovolný registr rozdìlit na dva
registry o ¹íøce 32 bitù, z&nbsp;nich¾ ka¾dý doká¾e pojmout èíselnou hodnotu
s&nbsp;jednoduchou pøesností (<i>single/float</i>). Díky tomuto rozdìlení se
poèet registrù pro formát <i>single</i> zvìt¹il na dvojnásobek &ndash; tyto
registry jsou v&nbsp;assembleru pojmenovány <strong>s0</strong> a¾
<strong>s31</strong>.  Podle konvence dodr¾ované jak pøekladaèi, tak i
v&nbsp;programových knihovnách se pøi volání subrutin pou¾ívají registry
<strong>d0</strong> a¾ <strong>d7</strong> pro pøedávání parametrù subrutinì,
popø.&nbsp;pro získání návratových hodnot ze subrutiny. Samozøejmì se tyto
registry takté¾ pou¾ívají pøi výpoètech v&nbsp;subrutinì. Ostatní registry lze
takté¾ pou¾ít, ov¹em jejich hodnota by mìla být pøi návratu ze subrutiny
obnovena.</p>

<p><ins>Poznámka: v&nbsp;pøedchozí kapitole jsme se zmínili o tøetí verzi
technologie <i>VFP</i> oznaèované <i>VFPv3</i>. Ve skuteènosti tato verze
existuje ve dvou variantách, pøièem¾ první varianta je nazvaná <i>VFPv3-D16</i>
a druhá varianta se oznaèuje <i>VFPv3-D32</i>. U první varianty platí v¹echny
informace uvedené v&nbsp;pøedchozích dvou odstavcích (16 registrù typu double
rozdìlitelných na 32 registrù typu single), ale u varianty <i>VFPv3-D32</i> se
poèet registrù typu <i>double</i> zdvojnásobil, èeho¾ lze samozøejmì
s&nbsp;výhodou vyu¾ít v&nbsp;mnoha typech aplikací (ov¹em zaplatíme za to
vìt¹ím poètem tranzistorù a tím pádem i vìt¹í plochou èipu i jeho
spotøebou).</ins></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Øídicí a stavový registr FPSCR</h2>

<p>Pøi popisu technologie <i>FPA</i> jsme se zmínili i o dvou dùle¾itých
øídicích a stavových registrech. Jednalo se o registr <strong>FPSR</strong>
(<i>Floating Point Status Register</i>) a <strong>FPCR</strong> (<i>Floating
Point Control Register</i>). Oba tyto registry mají ¹íøku 32 bitù, co¾ umo¾òuje
snadné pøenesení jejich obsahu do vybraného pracovního registru procesoru
<i>ARM</i>. Podobný typ registru existuje takté¾ u technologie <i>VFP</i>
&ndash; jedná se o registr <strong>FPSCR</strong> neboli <i>Floating Point
Status and Control Register</i>. I tento registr má ¹íøku 32 bitù a lze ho
pøená¹et do a z vybraného pracovního registru mikroprocesoru <i>ARM</i>. Ve
skuteènosti je tento pøenos dokonce nutný napøíklad v&nbsp;tìch pøípadech, kdy
je zapotøebí nastavit pouze vybranou oblast v&nbsp;tomto registru. Mù¾e se
napøíklad jednat o bitová pole <strong>STRIDE</strong> a <strong>LEN</strong>,
které mají velký význam pro provádìní vektorových operací, nebo» urèují,
s&nbsp;jak dlouhými vektory a s&nbsp;jakým uspoøádáním prvkù vektoru se bude
pracovat.</p>

<p>Pøi zmìnì hodnoty pouze nìkterých bitù registru <strong>FPSCR</strong> se
pou¾ívá následující sekvence instrukcí:</p>

<pre>
VMRS   r3,FPSCR           ; pøesun hodnoty FPSCR do registru R3
BIC    r3,r3,#0x00370000  ; vynulování bitových polí STRIDE a LEN
ORR    r3,r3,#0x00030000  ; nastavení STRIDE = 1 a LEN = 4
VMSR   FPSCR,r3           ; zpìtný pøesun hodnoty z R3 do registru FPSCR
</pre>

<p>Jaké informace v¹ak vlastnì registr <strong>FPSCR</strong> obsahuje? Jeho
obsah se li¹í v&nbsp;závislosti na tom, o jakou variantu technologie <i>VFP</i>
se jedná, ale obecnì lze øíci, ¾e zde mù¾eme najít minimálnì pìt bitových polí:
pøíznaky nastavované po aritmetických a porovnávacích operacích, výbìr
zaokrouhlovacího re¾imu, pøíznaky nastavované pøi nìkterém typu výjimky (ztráta
pøesnosti, neplatná operace...), bity, s&nbsp;jejich¾ pomocí lze blokovat tyto
výjimky a koneènì bitová pole <strong>STRIDE</strong> a <strong>LEN</strong>
pou¾ívaná pro nastavování zpùsobu provádìní vektorových operací.</p>

<p>Pro nastavení zaokrouhlovacího re¾imu postaèuje dvojice bitù:</p>

<table>
<tr><th>Kód</th><th>Re¾im</th><th>Význam</th></tr>
<tr><td>00</td><td>RN</td><td>nejbli¾¹í reprezentovatelná hodnota</td></tr>
<tr><td>01</td><td>RP</td><td>zaokrouhlení smìrem ke kladnému nekoneènu</td></tr>
<tr><td>10</td><td>RM</td><td>zaokrouhlení smìrem k&nbsp;zápornému nekoneènu</td></tr>
<tr><td>11</td><td>RZ</td><td>zaokrouhlení smìrem k&nbsp;nule</td></tr>
</table>

<p>Pøíznakové bity nastavované po aritmetických a porovnávacích operacích jsou
ètyøi, jak lze oèekávat. Tyto pøíznakové bity se vìt¹inou kopírují do
<strong>CPSR</strong>, aby se mohly vyu¾ít v&nbsp;podmínìných skocích (v¹echny
instrukèní sady) nebo v&nbsp;podmínkových bitech (instrukèní sada ARM):</p>

<table>
<tr><th>Pøíznak</th><th>Význam</th></tr>
<tr><td>N</td><td>výsledek záporný, men¹í ne¾</td></tr>
<tr><td>Z</td><td>výsledek nulový, rovnost</td></tr>
<tr><td>C</td><td>vìt¹í ne¾</td></tr>
<tr><td>V</td><td>hodnoty nelze vzájemnì uspoøádat</td></tr>
</table>

<p>Dal¹ích pìt bitù je nastavovaných pøi výskytu nìjaké výjimky v&nbsp;prùbìhu
provádìní FP operací:</p>

<table>
<tr><th>Bit</th><th>Význam</th></tr>
<tr><td>IXC</td><td>ztráta pøesnosti</td></tr>
<tr><td>UFC</td><td>podteèení</td></tr>
<tr><td>OFC</td><td>pøeteèení</td></tr>
<tr><td>DZC</td><td>dìlení nulou</td></tr>
<tr><td>IOC</td><td>neplatná operace 0/0, log -n apod.</td></tr>
</table>

<p>Vý¹e vypsané výjimky lze blokovat posledními pìti bity:</p>

<table>
<tr><th>Bit</th><th>Význam</th></tr>
<tr><td>IXE</td><td>blokace/povolení pøíznaku IXC</td></tr>
<tr><td>UFE</td><td>blokace/povolení pøíznaku UFC</td></tr>
<tr><td>OFE</td><td>blokace/povolení pøíznaku OFC</td></tr>
<tr><td>DZE</td><td>blokace/povolení pøíznaku DZC</td></tr>
<tr><td>IOE</td><td>blokace/povolení pøíznaku IOC</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Skalární a vektorový re¾im FP instrukcí</h2>

<p>Pøi vzniku technologie <i>VFP</i> se její tvùrci zamìøili na to, aby
instrukèní sada <i>VFP</i> umo¾òovala jak práci se skalárními hodnotami, tak i
práci s&nbsp;vektory. Na první pohled by se tedy mohlo zdát, ¾e se jedná o
jednu z&nbsp;mnoha aplikací architektury <i>SIMD</i>, ve skuteènosti se ov¹em
v&nbsp;pøípadì <i>VFP</i> vektory zpracovávají sekvenènì. To napøíklad znamená,
¾e souèet dvou osmiprvkových vektorù realizovaný instrukcí
<strong>VADD</strong> pou¾ívá tu samou FP-sèítaèku a prvky vektorù jsou tedy
seèítány postupnì. Stále se jedná o rychlej¹í operaci, ne¾ osm krát opakovaná
instrukce <strong>ADF</strong> (mimo jiné se u¹etøí cykly strávené pøi naèítání
a dekódování instrukce &ndash; <i>instruction fetch</i> a <i>instruction
decode</i>) &ndash; ov¹em reálný <i>SIMD</i> systém to není, na rozdíl od na
první pohled obdobných technologií: <i>3DNow!</i>, <i>SSE</i> atd. Zmìna pøi¹la
a¾ pøi slouèení <i>VFP</i> s&nbsp;technologií <i>NEON</i>, která na procesory
<i>ARM</i> pøinesla skuteèné operace <i>SIMD</i>.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Rozdìlení registrù do bank, nastavení parametrù STRIDE a LEN</h2>

<p>Pøi provádìní vektorových operací se pracovní registry rozdìlují do
takzvaných bank. V&nbsp;pøípadì pou¾ití formátu <i>single</i> jsou pou¾ity
ètyøi banky, z&nbsp;nich¾ ka¾dá obsahuje osm pracovních registrù:
<strong>s0-s7</strong>, <strong>s8-s15</strong>, <strong>s16-s23</strong>,
<strong>s24-s31</strong>. Pokud je pou¾it formát <i>double</i>, existují banky
ètyøi a ka¾dá z&nbsp;nich obsahuje ètyøi registry: <strong>d0-d3</strong>,
<strong>d4-d7</strong>, <strong>d8-d11</strong>, <strong>d12-d15</strong>. U
architektury <i>VFPv3-D32</i>, která nabízí dvojnásobný poèet registrù typu
<i>double</i>, se poèet bank s&nbsp;registry typu <i>double</i> takté¾
roz¹iøuje na osm. Význam bank je následující: vektorovou operaci lze toti¾
provést s&nbsp;dvojicí vektorù, pøièem¾ ka¾dý vektor je sestaven maximálnì
z&nbsp;osmi registrù typu <i>single</i>, popø.&nbsp;ze ètyø registrù typu
<i>double</i>, které ov¹em musí le¾et v&nbsp;jedné bance. Navíc platí, ¾e pokud
je v&nbsp;instrukci zvolen vy¹¹í registr v&nbsp;bance a délka vektoru pøesahuje
poèet zbylých registrù v&nbsp;této bance, bude se pøi indexaci prvkù vektorù
&bdquo;wrapovat&ldquo; na zaèátek banky:</p>

<pre>
Délka vektoru = 6
První registr s5 (bank s0-s7)
Vektor pou¾itý v instrukci: [s5, s6, s7, s0, s1, s2]
</pre>

<p>Toto chování sice mù¾e na první pohled vypadat dosti neobvykle, ov¹em
v&nbsp;praxi ho lze s&nbsp;výhodou pou¾ít u nìkterých algoritmù vy¾adujících
jiné uspoøádání prvkù vektoru.</p>

<p>Ji¾ ve ètvrté kapitole jsme se zmínili o tom, ¾e ve stavovém a øídicím
registru <strong>FPSCR</strong> se mj.&nbsp;nachází i bitová pole <i>LEN</i> a
<i>STRIDE</i>. Bitové pole <i>LEN</i> má ¹íøku tøi bity a obsahuje délku
zpracovávaných vektorù, od ní¾ je odeètena jednièka. Pro skalární operace tedy
postaèuje nastavit v¹echny tøi bity <i>LEN</i> na nulu, co¾ znaèí délku vektoru
jeden prvek. Bitové pole <i>STRIDE</i> (o ¹íøce 2 bity) je zajímavìj¹í &ndash;
touto hodnotou lze toti¾ zvolit, zda registry ve vektoru budou ulo¾eny
v&nbsp;po sobì jdoucích registrech, èi zda budou ulo¾eny ob jeden, dva èi tøi
FP registry. Opìt si to uka¾me na pøíkladu:</p>

<pre>
LEN=3 STRIDE=1 start=s1  odpovídá vektoru {s1, s2, s3}
LEN=3 STRIDE=2 start=s1  odpovídá vektoru {s1, s3, s5}
LEN=4 STRIDE=1 start=s6  odpovídá vektoru {s6, s7, s0, s1}
LEN=4 STRIDE=2 start=s6  odpovídá vektoru {s6, s0, s2, s4}
</pre>

<p>Pou¾ití STRIDE=2 má samozøejmì svùj význam, nebo» po sobì jdoucí registry
mohou obsahovat sekvenci souøadnic [x,y] a v&nbsp;nìkterém okam¾iku pouze
potøebujeme pracovat se v¹emi souøadnicemi x atd.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Instrukèní sada VFP: vektorové aritmetické operace</h2>

<p>Nyní se ji¾ koneènì dostáváme k&nbsp;popisu jednotlivých instrukcí, které
lze nalézt v&nbsp;instrukèní sadì <i>VFP</i>. Zajímavý je pøedev¹ím fakt, ¾e
ka¾dá instrukce obsahuje pøíznak, zda se má provádìt operace
s&nbsp;hodnotami/registry typu <i>single</i> èi <i>double</i>. Instrukce takté¾
obsahují pøíznakové bity urèující, za jakých podmínek se instrukce má provést.
Význam tìchto pøíznakových bitù je ponìkud odli¹ný od bitù pou¾itých
v&nbsp;instrukèní sadì <i>ARM</i>, a to pøedev¹ím z&nbsp;toho dùvodu, ¾e
pøíznak <strong>V</strong> má odli¹ný význam (pøeteèení hodnoty celého èísla do
znaménkového bitu versus dvì FP hodnoty nelze porovnat). To, zda se bude
vybraná operace provádìt nad dvojicí skalárních hodnot nebo nad dvojicí
registrù, je urèeno hodnotami <strong>LEN</strong> (a vlastnì té¾
<strong>STRIDE</strong>), o nich¾ jsme se zmiòovali v&nbsp;pøedchozích
kapitolách.</p>

<p>V&nbsp;následující tabulce jsou vypsány základní aritmetické operace:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th><th>Provádìný výpoèet</th></tr>
<tr><td> 1</td><td>VADD  Fd, Fn, Fm</td><td>souèet</td><td>Fd := Fn + Fm</td></tr>
<tr><td> 2</td><td>VSUB  Fd, Fn, Fm</td><td>rozdíl</td><td>Fd := Fn - Fm</td></tr>
<tr><td> 3</td><td>VNEG  Fd, Fm</td><td>zmìna znaménka</td><td>Fd := - Fm</td></tr>
<tr><td> 4</td><td>VABS  Fd, Fm</td><td>absolutní hodnota</td><td>Fd := abs(Fm)</td></tr>
<tr><td> 5</td><td>VSQRT Fd, Fm</td><td>druhá odmocnina</td><td>Fd := sqrt(Fm)</td></tr>
<tr><td> 6</td><td>VDIV  Fd, Fn, Fm</td><td>dìlení</td><td>Fd := Fn / Fm</td></tr>
<tr><td> 7</td><td>VMUL  Fd, Fn, Fm</td><td>násobení</td><td>Fd := Fn * Fm</td></tr>
<tr><td> 8</td><td>VMLA  Fd, Fn, Fm</td><td>násobení + akumulace</td><td>Fd := Fd + (Fn * Fm)</td></tr>
<tr><td> 9</td><td>VMLS  Fd, Fn, Fm</td><td>odeètení souèinu</td><td>Fd := Fd - (Fn * Fm)</td></tr>
<tr><td>10</td><td>VNMUL Fd, Fn, Fm</td><td>násobení + zmìna znaménka</td><td>Fn := - (Fn * Fm)</td></tr>
<tr><td>11</td><td>VNMLA Fd, Fn, Fm</td><td>kombinace VNMUL a VMLA</td><td>Fd := - Fd - (Fn * Fm)</td></tr>
<tr><td>12</td><td>VNMLS Fd, Fn, Fm</td><td>kombinace VNMUL a VMLS</td><td>Fd := - Fd + (Fn * Fm)</td></tr>
</table>

<p><ins>Poznámka: pov¹imnìte si pøedev¹ím ¹esti rùzných variant násobení. To je
zapøíèinìno tím, ¾e se <i>VFP</i> pou¾ívá napøíklad i pro filtraci obrazu, FFT
atd., kde lze tyto operace s&nbsp;výhodou pou¾ít.</ins></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Porovnání dvou hodnot, porovnání s&nbsp;nulou</h2>

<p>Mezi dal¹í dùle¾ité operace provádìné matematickými koprocesory
s&nbsp;technologií <i>VFP</i> patøí instrukce pro porovnání dvou hodnot
(samozøejmì ulo¾ených ve dvojici registrù), popø.&nbsp;porovnání hodnoty
jednoho registru s&nbsp;nulou. Porovnání je provedeno instrukcí
<strong>VCMP</strong>, u ní¾ lze navíc pomocí prefixu &bdquo;P&ldquo; urèit, ve
kterých pøípadech se má vyvolat výjimka. Porovnání nastaví v¹echny ètyøi
pøíznakové bity <strong>C</strong>, <strong>Z</strong>, <strong>N</strong> a
<strong>V</strong>. Pro pøesun pøíznakových bitù z&nbsp;registru
<strong>FPSCR</strong> do registru <strong>CSR</strong> je nutné pou¾ít
instrukci <strong>VMRS APSR_nzcv, FPSCR</strong>:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th><th>Provádìný výpoèet</th></tr>
<tr><td>1</td><td>VCMP Fd, Fm</td><td>Porovnání obsahu dvou registrù</td><td>Fd - Fm</td></tr>
<tr><td>2</td><td>VCMP Fd, #0.0</td><td>Porovnání jednoho registru s nulou</td><td>Fd - 0.0</td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Pøesuny dat, naètení konstanty a konverzní instrukce</h2>

<p>V&nbsp;poslední tabulce jsou vypsány instrukce provádìjící rùzné pøesuny dat
s&nbsp;pøípadnými konverzemi dat. Operace s&nbsp;hodnotami s&nbsp;polovièní
pøesností (half) jsou dostupné pouze na koprocesorech s&nbsp;architekturou
<i>VFPv3</i>:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td> 1</td><td>VCVT{C}.F64.F32 Dd, Sm</td><td>Konverze single na double</td></tr>
<tr><td> 2</td><td>VCVT{C}.F32.F64 Sd, Dm</td><td>Konverze double na single</td></tr>
<tr><td> 3</td><td>VCVT{C}.F32/F64.U32 Fd, Sm</td><td>Konverze unsigned integer na float</td></tr>
<tr><td> 4</td><td>VCVT{C}.F32/F64.S32 Fd, Sm</td><td>Konverze signed integer na float</td></tr>
<tr><td> 5</td><td>VCVT{R}{C}.U32.F32/F64 Sd, Fm</td><td>Konverze float na unsigned integer</td></tr>
<tr><td> 6</td><td>VCVT{R}{C}.S32.F32/F64 Sd, Fm</td><td>Konverze float na signed integer</td></tr>
<tr><td> 7</td><td>VCVT.F32/F64.typ Fd, Fd, #bitù</td><td>Konverze fixed-point na float (volitelná pozice teèky)</td></tr>
<tr><td> 8</td><td>VCVT.typ.F32/F64 Fd, Fd, #bitù</td><td>Konverze float na fixed-point (volitelná pozice teèky)</td></tr>
<tr><td> 9</td><td>VCVTT.F16.F32 Sd,Sm</td><td>Konverze single na half (do horních 16 bitù registru)</td></tr>
<tr><td>10</td><td>VCVTB.F16.F32 Sd,Sm</td><td>Konverze single na half (do spodních 16 bitù registru)</td></tr>
<tr><td>11</td><td>VCVTT.F32.F16 Sd,Sm</td><td>Konverze half na single</td></tr>
<tr><td>12</td><td>VCVTB.F32.F16 Sd,Sm</td><td>Konverze half na single</td></tr>
<tr><td>13</td><td>VMOV.F32/F64 Fd, Fm</td><td>Fd := Fm (prostá kopie)</td></tr>
<tr><td>14</td><td>VMOV Sn, Rd</td><td>Sn := Rd (Rd = registr ARM procesoru)</td></tr>
<tr><td>15</td><td>VMOV Rd, Sn</td><td>Rd := Sn (Rd = registr ARM procesoru)</td></tr>
<tr><td>16</td><td>VMOV Sn, Sm, Rd, Rn</td><td>Sn := Rd, Sm := Rn (kopie dvou registrù)</td></tr>
<tr><td>17</td><td>VMOV Rd, Rn, Sn, Sm</td><td>Rd := Sn, Rn := Sm (kopie dvou registrù)</td></tr>
<tr><td>18</td><td>VMOV Dm, Rd, Rn</td><td>Dm[31:0] := Rd, Dm[63:32] := Rn (pro double jsou zapotøebí dva ARM registry)</td></tr>
<tr><td>19</td><td>VMOV Rd, Rn, Dm</td><td>Rd := Dm[31:0], Rn := Dm[63:32]  (pro double jsou zapotøebí dva ARM registry)</td></tr>
<tr><td>20</td><td>VMOV Dn[0], Rd</td><td>Dn[31:0] := Rd  (pouze spodní polovina double)</td></tr>
<tr><td>21</td><td>VMOV Rd, Dn[0]</td><td>Rd := Dn[31:0]  (pouze spodní polovina double)</td></tr>
<tr><td>22</td><td>VMOV Dn[1], Rd</td><td>Dn[63:32] := Rd  (pouze horní polovina double)</td></tr>
<tr><td>23</td><td>VMOV Rd, Dn[1]</td><td>Rd := Dn[63:32]  (pouze horní polovina double)</td></tr>
<tr><td>24</td><td>VMRS APSR_nzcv, FPSCR</td><td>APSR flags := FPSCR flags (pøenos pøíznakù)</td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>The VFP architecture<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0056d/Bcfibfha.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0056d/Bcfibfha.html</a>
</li>

<li>NEON<br />
<a href="http://www.arm.com/products/processors/technologies/neon.php">http://www.arm.com/products/processors/technologies/neon.php</a>
</li>

<li>ARM Floating Point Accelerator (ARM FPA)<br />
<a href="http://vswww.kaist.ac.kr/ver4.0/index.php/research/past-research/arm-fpa.html">http://vswww.kaist.ac.kr/ver4.0/index.php/research/past-research/arm-fpa.html</a>
</li>

<li>Coding for NEON - Part 1: Load and Stores<br />
<a href="http://blogs.arm.com/software-enablement/161-coding-for-neon-part-1-load-and-stores/">http://blogs.arm.com/software-enablement/161-coding-for-neon-part-1-load-and-stores/</a>
</li>

<li>Coding for NEON - Part 2: Dealing With Leftovers<br />
<a href="http://blogs.arm.com/software-enablement/196-coding-for-neon-part-2-dealing-with-leftovers/">http://blogs.arm.com/software-enablement/196-coding-for-neon-part-2-dealing-with-leftovers/</a>
</li>

<li>Coding for NEON - Part 3: Matrix Multiplication<br />
<a href="http://blogs.arm.com/software-enablement/241-coding-for-neon-part-3-matrix-multiplication/">http://blogs.arm.com/software-enablement/241-coding-for-neon-part-3-matrix-multiplication/</a>
</li>

<li>Coding for NEON - Part 4: Shifting Left and Right<br />
<a href="http://blogs.arm.com/software-enablement/277-coding-for-neon-part-4-shifting-left-and-right/">http://blogs.arm.com/software-enablement/277-coding-for-neon-part-4-shifting-left-and-right/</a>
</li>

<li>DSP &amp; SIMD<br />
<a href="http://www.arm.com/products/processors/technologies/dsp-simd.php">http://www.arm.com/products/processors/technologies/dsp-simd.php</a>
</li>

<li>Improving ARM Code Density and Performance<br />
<a href="New Thumb Extensions to the ARM Architecture Richard Phelan">New Thumb Extensions to the ARM Architecture Richard Phelan</a>
</li>

<li>The ARM Processor Architecture<br />
<a href="http://www.arm.com/products/processors/technologies/instruction-set-architectures.php">http://www.arm.com/products/processors/technologies/instruction-set-architectures.php</a>
</li>

<li>Thumb-2 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html</a>
</li>

<li>Introduction to ARM thumb<br />
<a href="http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb">http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb</a>
</li>

<li>ARM, Thumb, and ThumbEE instruction sets<br />
<a href="http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm">http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm</a>
</li>

<li>An Introduction to ARM Assembly Language<br />
<a href="http://dev.emcelettronica.com/introduction-to-arm-assembly-language">http://dev.emcelettronica.com/introduction-to-arm-assembly-language</a>
</li>

<li>Processors - ARM<br />
<a href="http://www.arm.com/products/processors/index.php">http://www.arm.com/products/processors/index.php</a>
</li>

<li>The ARM Instruction Set<br />
<a href="http://simplemachines.it/doc/arm_inst.pdf">http://simplemachines.it/doc/arm_inst.pdf</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ARM_architecture">http://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>BBC BASIC<br />
<a href="http://www.bbcbasic.co.uk/bbcbasic.html">http://www.bbcbasic.co.uk/bbcbasic.html</a>
</li>

<li>BBC BASIC<br />
<a href="http://mdfs.net/Software/BBCBasic/">http://mdfs.net/Software/BBCBasic/</a>
</li>

<li>BBC BASIC (Z80) for the ZX Spectrum<br />
<a href="http://mdfs.net/Software/BBCBasic/Spectrum/">http://mdfs.net/Software/BBCBasic/Spectrum/</a>
</li>

<li>BBC BASIC (Wikipedia CZ)<br />
<a href="http://en.wikipedia.org/wiki/BBC_BASIC">http://en.wikipedia.org/wiki/BBC_BASIC</a>
</li>

<li>MIPS-3D(r) ASE<br />
<a href="http://www.mips.com/products/architectures/mips-3d-ase/">http://www.mips.com/products/architectures/mips-3d-ase/</a>
</li>

<li>An introduction to SPARC's SIMD offerings<br />
<a href="http://mikeburrell.wordpress.com/2007/12/14/an-introduction-to-sparcs-simd-offerings/">http://mikeburrell.wordpress.com/2007/12/14/an-introduction-to-sparcs-simd-offerings/</a>
</li>

<li>MIPS64<sup>TM</sup> Architecture for Programmers Volume IV-c: The MIPS-3D<sup>TM</sup> Application-Specific Extension to the MIPS64<sup>TM</sup><br />
<a href="http://www.weblearn.hs-bremen.de/risse/RST/docs/MIPS/MD00099-2B-MIPS3D64-AFP-01.11.pdf">http://www.weblearn.hs-bremen.de/risse/RST/docs/MIPS/MD00099-2B-MIPS3D64-AFP-01.11.pdf</a>
</li>

<li>Visual Instruction Set<br />
<a href="http://www.enotes.com/topic/Visual_Instruction_Set">http://www.enotes.com/topic/Visual_Instruction_Set</a>
</li>

<li>NEON<br />
<a href="http://www.arm.com/products/processors/technologies/neon.php">http://www.arm.com/products/processors/technologies/neon.php</a>
</li>

<li>Architecture and Implementation of the ARM Cortex-A8 Microprocessor<br />
<a href="http://www.design-reuse.com/articles/11580/architecture-and-implementation-of-the-arm-cortex-a8-microprocessor.html">http://www.design-reuse.com/articles/11580/architecture-and-implementation-of-the-arm-cortex-a8-microprocessor.html</a>
</li>

<li>Multimedia Acceleration eXtensions (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Multimedia_Acceleration_eXtensions">http://en.wikipedia.org/wiki/Multimedia_Acceleration_eXtensions</a>
</li>

<li>AltiVec (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AltiVec">http://en.wikipedia.org/wiki/AltiVec</a>
</li>

<li>Visual Instruction Set (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Visual_Instruction_Set">http://en.wikipedia.org/wiki/Visual_Instruction_Set</a>
</li>

<li>MAJC (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/MAJC">http://en.wikipedia.org/wiki/MAJC</a>
</li>

<li>MDMX (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/MDMX">http://en.wikipedia.org/wiki/MDMX</a>
</li>

<li>MIPS Multiply Unit<br />
<a href="http://programmedlessons.org/AssemblyTutorial/Chapter-14/ass14_3.html">http://programmedlessons.org/AssemblyTutorial/Chapter-14/ass14_3.html</a>
</li>

<li>Silicon Graphics Introduces Enhanced MIPS Architecture<br />
<a href="http://bwrc.eecs.berkeley.edu/CIC/otherpr/enhanced_mips.html">http://bwrc.eecs.berkeley.edu/CIC/otherpr/enhanced_mips.html</a>
</li>

<li>MIPS-3D (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/MIPS-3D">http://en.wikipedia.org/wiki/MIPS-3D</a>
</li>

<li>MIPS Technologies, Inc. announces new MIPS-3D technology to provide silicon-efficient 3D graphics acceleration<br />
<a href="http://www.design-reuse.com/news/2057/mips-mips-3d-technology-silicon-efficient-3d-graphics-acceleration.html">http://www.design-reuse.com/news/2057/mips-mips-3d-technology-silicon-efficient-3d-graphics-acceleration.html</a>
</li>

<li>MIPS-3D Built-in Function (gcc.gnu.org)<br />
<a href="http://gcc.gnu.org/onlinedocs/gcc/MIPS_002d3D-Built_002din-Functions.html">http://gcc.gnu.org/onlinedocs/gcc/MIPS_002d3D-Built_002din-Functions.html</a>
</li>

<li>Baha Guclu Dundar:<br />
Intel MMX, SSE, SSE2, SSE3/SSSE3/SSE4 Architectures
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>Intel MMX<sup>TM</sup> Technology Overview<br />
Intel corporation, 1996</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>
</li>

<li>AMD K5 ("K5" / "5k86")<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g5K5-c.html">http://www.pcguide.com/ref/cpu/fam/g5K5-c.html</a>
</li>

<li>Sixth Generation Processors<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g6.htm">http://www.pcguide.com/ref/cpu/fam/g6.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Very_long_instruction_word">http://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>Tour of the Black Holes of Computing!: Floating Point<br />
<a href="http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt">http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt</a>
</li>

<li>3Dnow! Technology Manual<br />
AMD Inc., 2000</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>Control unit (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Control_unit">http://en.wikipedia.org/wiki/Control_unit</a>
</li>

<li>Cray History<br />
<a href="http://www.cray.com/About/History.aspx?404;http://www.cray.com:80/about_cray/history.html">http://www.cray.com/About/History.aspx?404;http://www.cray.com:80/about_cray/history.html</a>
</li>

<li>Cray Historical Timeline<br />
<a href="http://www.cray.com/Assets/PDF/about/CrayTimeline.pdf">http://www.cray.com/Assets/PDF/about/CrayTimeline.pdf</a>
</li>

<li>Computer Speed Claims 1980 to 1996<br />
<a href="http://homepage.virgin.net/roy.longbottom/mips.htm">http://homepage.virgin.net/roy.longbottom/mips.htm</a>
</li>

<li>Superpoèítaèe Cray<br />
<a href="http://www.root.cz/clanky/superpocitace-cray/">http://www.root.cz/clanky/superpocitace-cray/</a>
</li>

<li>Superpoèítaèe Cray (druhá èást)<br />
<a href="http://www.root.cz/clanky/superpocitace-cray-druha-cast/">http://www.root.cz/clanky/superpocitace-cray-druha-cast/</a>
</li>

<li>Superpoèítaèe Cray (tøetí èást)<br />
<a href="http://www.root.cz/clanky/superpocitace-cray-treti-cast/">http://www.root.cz/clanky/superpocitace-cray-treti-cast/</a>
</li>

<li>Superpoèítaèe Cray (ètvrtá èást)<br />
<a href="http://www.root.cz/clanky/superpocitace-cray-ctvrta-cast/">http://www.root.cz/clanky/superpocitace-cray-ctvrta-cast/</a>
</li>

<li>Superpoèítaèe Cray (pátá èást): architektura Cray X-MP<br />
<a href="http://www.root.cz/clanky/superpocitace-cray-pata-cast-architektura-pocitace-cray-x-mp-a-jeho-pouziti-ve-filmovem-prumyslu/">http://www.root.cz/clanky/superpocitace-cray-pata-cast-architektura-pocitace-cray-x-mp-a-jeho-pouziti-ve-filmovem-prumyslu/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

