<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Vyrovnávací pamìti a optimalizace programù</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Vyrovnávací pamìti a optimalizace programù</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o èinnosti mikropoèítaèù si vysvìtlíme základní principy optimalizací programù s ohledem na èinnost vyrovnávacích pamìtí (cache memory), jejich asociativity a v neposlední øadì také strategii alokace blokù.</p>



<h1>Obsah</h1>
<p>
<a href="#k01">1. Optimalizace programù z&nbsp;hlediska pøístupu do operaèní pamìti</a><br />
<a href="#k02">2. Inkrementace èi dekrementace adres pøi práci s&nbsp;poli?</a><br />
<a href="#k03">3. Vliv optimalizace v&nbsp;pøekladaèi na výsledný strojový kód</a><br />
<a href="#k04">4. Pøístup do dvojrozmìrného pole po øádcích èi sloupcích</a><br />
<a href="#k05">5. Vliv optimalizace</a><br />
<a href="#k06">6. Slo¾itìj¹í pøíklad</a><br />
<a href="#k07">7. Literatura a odkazy na Internetu</a><br />
<a href="#k08">8. Obsah dal¹í èásti seriálu</a><br />
</p>



<p><a name="k01"></a></p>
<h1>1. Optimalizace programù z&nbsp;hlediska pøístupu do operaèní pamìti</h1>

<p>Pøi snaze o vytvoøení co nejrychleji pracujících aplikací se mnohdy
nevyhneme úvahám o tom, jak je rychlost bìhu programu ovlivnìna pøítomností
vyrovnávacích pamìtí. Pokud by se v&nbsp;poèítaèích vyrovnávací pamìti
nepou¾ívaly a operaèní pamì» by skuteènì byla RAM (<i>Random Access
Memory</i>), tj.&nbsp;náhodnì adresovatelná (se stejnou dobou pøístupu do
jakékoli buòky), je mo¾né programy optimalizovat s&nbsp;ohledem na slo¾itost
algoritmù a datových struktur, popø.&nbsp;se zamìøit na specifika dané
platformy &ndash; napøíklad pøítomnost instrukcí typu MMX, SSE, soubì¾né práce
matematického koprocesoru s&nbsp;ALU atd. Ov¹em kvùli tomu, ¾e náhodné pøístupy
do operaèní pamìti jsou provedeny pomaleji, ne¾ pøístupy sekvenèní a pøedev¹ím
díky vyrovnávacím pamìtem se situace ponìkud komplikuje, proto¾e i zdánlivì
rychlý algoritmus mù¾e být v&nbsp;praxi pomalej¹í ne¾ algoritmus s&nbsp;vy¹¹í
teoretickou slo¾itostí. Také se ukazuje, ¾e v&nbsp;nìkterých pøípadech bývá
vhodné nìkterá data nejprve transformovat a teprve poté s&nbsp;nimi provádìt
dal¹í manipulace (transpozice matice pøed maticovým násobením atd.). Dnes si
uká¾eme nìkolik jednoduchých pøíkladù takové úpravy aplikací. Pøedem je je¹tì
nutné øíci, ¾e by se optimalizace mìly provádìt a¾ ve chvíli, kdy profiler
pøesnì uká¾e na místo, ve kterém dochází ke sni¾ování výkonnosti. Profiling
by se mìl spou¹tìt na reálných datech (ne na malé mno¾inì), právì
s&nbsp;ohledem na vyrovnávací pamìti.</p>



<p><a name="k02"></a></p>
<h1>2. Inkrementace èi dekrementace adres pøi práci s&nbsp;poli?</h1>

<p>V&nbsp;nìkterých materiálech zabývajících se optimalizací, se lze doèíst, ¾e
pøi procházení polem, tj.&nbsp;sekvencí po sobì jdoucích adres, je výhodnìj¹í
procházet v¾dy od zaèátku pole k&nbsp;jeho konci. Vyplývá to pøedev¹ím
z&nbsp;funkcí nìkterých typù dynamických pamìtí, které umo¾òují blokový pøenos
dat. Ov¹em pøítomnost vyrovnávacích pamìtí v&nbsp;podstatì jakékoli rozdíly
v&nbsp;rychlosti sma¾e, jeliko¾ pøenos blokù mezi vyrovnávací pamìtí a operaèní
pamìtí je v¾dy provádìn blokovì a na vzájemné pozici blokù v&nbsp;operaèní
pamìti do velké míry nezále¾í. Samotný &bdquo;opaèný&ldquo; pøístup do
jednotlivého bloku ulo¾eného ve vyrovnávací pamìti pak nepøiná¹í ¾ádné
mìøitelné zpo¾dìní, proto¾e se jedná o SRAM. Výsledná rychlost programu tak
plnì závisí na tom, jakým zpùsobem je program pøelo¾en do strojového kódu
(uvidíme ní¾e). Testovací program vypadá následovnì:</p>

<code-area>/* ------------------------------------------------------------------------- */
/* Vypocet rozdilu casu pri pristupu do pole s inkrementaci a dekrementaci   */
/* adresy.                                                                   */
/* Autor: Pavel Tisnovsky                                                    */
/*                                                                           */
/* soucast clanku "Co se deje v pocitaci?" na www.root.cz                    */
/* (http://www.root.cz/serialy/co-se-deje-v-pocitaci/)                       */
/*                                                                           */
/* typicky preklad: gcc -std=c99 -Wall test.c                                */
/* ------------------------------------------------------------------------- */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &lt;string.h&gt;

#define INNER_LOOP_COUNT 100

/* typ polozek ulozenych v poli */
typedef unsigned int item_type;

/* typ vlastniho pole */
typedef item_type * array_type;



/* ------------------------------------------------------------------------- */
/* vypocet velikosti pole v bytech pro zadany rozmer                         */
/* ------------------------------------------------------------------------- */
size_t get_size(int width)
{
    return sizeof(item_type)*width;
}



/* ------------------------------------------------------------------------- */
/* alokace pole ve virtualni pameti                                          */
/* ------------------------------------------------------------------------- */
array_type allocate_array(int width)
{
    size_t size=get_size(width);
    array_type array=(array_type)malloc(size);
    if (array==NULL)
    {
        fprintf(stderr,
                "Nelze alokovat pole o velikosti %ld bytu!\n",
                (long)size);
        exit(-1);
    }
    return array;
}



/* ------------------------------------------------------------------------- */
/* pocatecni vypln pole - skutecna alokace vsech jeho polozek                */
/* ------------------------------------------------------------------------- */
void fill_array(array_type array, int width)
{
    memset(array, get_size(width), 0);
}



/* ------------------------------------------------------------------------- */
/* dealokace pole (na nekterych systemech se pamet skutecne uvolni)          */
/* ------------------------------------------------------------------------- */
void deallocate_array(item_type *array)
{
    free(array);
}



/* ------------------------------------------------------------------------- */
/* sekvencni pristup ke vsem polozkam v poli se zvysujici se adresou         */
/* ------------------------------------------------------------------------- */
void access_array_inc(array_type array, int width)
{
    int i;
    array_type p;
    for (p=array, i=0; i&lt;width; i++, p++)
    {
        (*p)++;
    }
}



/* ------------------------------------------------------------------------- */
/* sekvencni pristup ke vsem polozkam v poli se snizujici se adresou         */
/* ------------------------------------------------------------------------- */
void access_array_dec(array_type array, int width)
{
    int i;
    array_type p;
    for (p=array+(width-1), i=0; i&lt;width; i++, p--)
    {
        (*p)++;
    }
}



/* ------------------------------------------------------------------------- */
/* vypocet casu pro oba dva zpusoby pristupu k poli                          */
/* ------------------------------------------------------------------------- */
void compute_times(int width, double *t1, double *t2)
{
    array_type array=NULL;
    clock_t t_start, t_end;
    int i;

    array=allocate_array(width);
    fill_array(array, width);

    t_start=clock();
    for (i=0; i&lt;INNER_LOOP_COUNT; i++)
    {
        access_array_inc(array, width);
    }
    t_end=clock();
    *t1=((double)(t_end-t_start)/CLOCKS_PER_SEC);

    t_start=clock();
    for (i=0; i&lt;INNER_LOOP_COUNT; i++)
    {
        access_array_dec(array, width);
    }
    t_end=clock();
    *t2=((double)(t_end-t_start)/CLOCKS_PER_SEC);

    deallocate_array(array);
}



/* ------------------------------------------------------------------------- */
/* funkce spustena po startu procesu                                         */
/* ------------------------------------------------------------------------- */
int main(void)
{
    int i, size=1;
    double t1, t2;

    printf("array size      bytes     t1     t2   delta t\n");
    for (i=0; i&lt;24; i++)
    {
        compute_times(size, &amp;t1, &amp;t2);
        printf("%9d   %9ld  %6.3f %6.3f %6.3f\n",
                size, (long)get_size(size), t1, t2, t2-t1);
        size*=2;
    }
    return 0;
}



/* ------------------------------------------------------------------------- */
/* finito                                                                    */
/* ------------------------------------------------------------------------- */
  
</code-area>

<p>Zajímavý je pohled na to, jakým zpùsobem se jednotlivé smyèky pøelo¾í.
Pøelo¾ená smyèka funkce <strong>access_array_inc</strong> vypadá pøi vypnutých
optimalizacích následovnì:</p>

<code-area>
LOOP1:
        incl    (%edx)     - pøístup do pamìti
        addl    $4, %edx   - zde se provádí zvý¹ení hodnoty ukazatele
        decl    %eax       - poèitadlo smyèky
        jne     LOOP1
</code-area>

<p>Zatímco smyèka funkce <strong>access_array_dec</strong> pou¾ívá opaèný
prùchod:</p>

<code-area>
LOOP2:
        incl    (%edx)     - pøístup do pamìti
        subl    $4, %edx   - zde se provádí sní¾ení hodnoty ukazatele
        decl    %eax       - poèitadlo smyèky
        jne     LOOP2
</code-area>

<p>Výsledné èasy bìhu programu (dùle¾ité jsou relativní hodnoty, ne absolutní)
pro rùzné délky pole ukazuje následující tabulka:</p>

<pre>
array size      bytes     t1     t2   delta t
        1           4   0.000  0.000  0.000
        2           8   0.000  0.000  0.000
        4          16   0.000  0.000  0.000
        8          32   0.000  0.000  0.000
       16          64   0.000  0.000  0.000
       32         128   0.000  0.000  0.000
       64         256   0.000  0.000  0.000
      128         512   0.000  0.000  0.000
      256        1024   0.000  0.000  0.000
      512        2048   0.000  0.000  0.000
     1024        4096   0.000  0.000  0.000
     2048        8192   0.000  0.010  0.010
     4096       16384   0.000  0.010  0.010
     8192       32768   0.010  0.010  0.000
    16384       65536   0.020  0.020  0.000
    32768      131072   0.040  0.050  0.010
    65536      262144   0.090  0.110  0.020
   131072      524288   0.190  0.171 -0.019
   262144     1048576   0.340  0.341  0.001
   524288     2097152   0.691  0.691  0.000
  1048576     4194304   1.382  1.402  0.020
  2097152     8388608   2.784  2.794  0.010
  4194304    16777216   5.558  5.568  0.010
  8388608    33554432  11.146 11.156  0.010
</pre>



<p><a name="k03"></a></p>
<h1>3. Vliv optimalizace v&nbsp;pøekladaèi na výsledný strojový kód</h1>

<p>I po optimalizaci strojového kódu na rychlost, tj.&nbsp;pøi pou¾ití
pøepínaèù <strong>-O3 -funroll-all-loops -std=c89 -Wall</strong>, není mezi
jednotlivými pøístupy do pole ¾ádný podstatný rozdíl, i kdy¾ se samotný bìh
programu cca 2&times; urychlil:</p>

<pre>
array size      bytes     t1     t2   delta t
        1           4   0.000  0.000  0.000
        2           8   0.000  0.000  0.000
        4          16   0.000  0.000  0.000
        8          32   0.000  0.000  0.000
       16          64   0.000  0.000  0.000
       32         128   0.000  0.000  0.000
       64         256   0.000  0.000  0.000
      128         512   0.000  0.000  0.000
      256        1024   0.000  0.000  0.000
      512        2048   0.000  0.000  0.000
     1024        4096   0.000  0.000  0.000
     2048        8192   0.000  0.000  0.000
     4096       16384   0.000  0.000  0.000
     8192       32768   0.000  0.000  0.000
    16384       65536   0.010  0.000 -0.010
    32768      131072   0.010  0.010  0.000
    65536      262144   0.020  0.020  0.000
   131072      524288   0.040  0.040  0.000
   262144     1048576   0.070  0.080  0.010
   524288     2097152   0.160  0.150 -0.010
  1048576     4194304   0.661  0.651 -0.010
  2097152     8388608   1.492  1.493  0.001
  4194304    16777216   3.034  3.024 -0.010
  8388608    33554432   6.049  6.049  0.000
</pre>



<p><a name="k04"></a></p>
<h1>4. Pøístup do dvojrozmìrného pole po øádcích èi sloupcích</h1>

<p>Mnohem zásadnìj¹í je èasový rozdíl pøi pøístupu do dvojrozmìrného pole. Zde
se ji¾ naplno projeví vlastnosti DRAM i vyrovnávacích pamìtí, pøedev¹ím ve
chvíli, kdy se velikost jednotlivých polo¾ek pole odli¹uje od velikosti bloku
ve vyrovnávací pamìti. V¹e si uká¾eme na jednoduchém testovacím pøíkladu, ve
kterém se pøistupuje ke v¹em prvkùm dvojrozmìrného pole. První pøístup je
&bdquo;po øádcích&ldquo;, druhý &bdquo;po sloupcích&ldquo;. Z&nbsp;teoretického
hlediska není mezi tìmito pøístupy rozdíl (slo¾itost je <i>O(n)</i>), ov¹em
v&nbsp;praxi je patrné, ¾e ve chvíli, kdy velikost pole pøekroèí kapacitu
vyrovnávací pamìti, dojde k&nbsp;výraznému zpomalení nesekvenèního pøístupu
k&nbsp;polo¾kám pole &ndash; je tomu tak z&nbsp;toho dùvodu, ¾e se sice do
vyrovnávací pamìtí naète v¾dy celý blok (mù¾e se jednat o napøíklad 8 polo¾ek
pole), ale vyu¾ije se z&nbsp;nìj pouze jedna polo¾ka.</p>

<code-area>/* ------------------------------------------------------------------------- */
/* Vypocet rozdilu casu pri pristupu do pole po radcich a po sloupcich       */
/* Autor: Pavel Tisnovsky                                                    */
/*                                                                           */
/* soucast clanku "Co se deje v pocitaci?" na www.root.cz                    */
/* (http://www.root.cz/serialy/co-se-deje-v-pocitaci/)                       */
/*                                                                           */
/* typicky preklad: gcc -std=c99 -Wall test.c                                */
/* ------------------------------------------------------------------------- */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &lt;string.h&gt;

#define INNER_LOOP_COUNT 100

/* typ polozek ulozenych v poli */
typedef unsigned int item_type;

/* typ vlastniho pole */
typedef item_type * array_type;



/* ------------------------------------------------------------------------- */
/* vypocet velikosti pole v bytech pro zadane rozmery                        */
/* ------------------------------------------------------------------------- */
size_t get_size(int width, int height)
{
    return sizeof(item_type)*width*height;
}



/* ------------------------------------------------------------------------- */
/* alokace pole ve virtualni pameti                                          */
/* ------------------------------------------------------------------------- */
array_type allocate_array(int width, int height)
{
    size_t size=get_size(width, height);
    array_type array=(array_type)malloc(size);
    if (array==NULL)
    {
        fprintf(stderr, "Nelze alokovat pole o velikosti %ld bytu!\n", (long)size);
        exit(-1);
    }
    return array;
}



/* ------------------------------------------------------------------------- */
/* pocatecni vypln pole - skutecna alokace vsech jeho polozek                */
/* ------------------------------------------------------------------------- */
void fill_array(array_type array, int width, int height)
{
    memset(array, get_size(width, height), 0);
}



/* ------------------------------------------------------------------------- */
/* dealokace pole (na nekterych systemech se pamet skutecne uvolni)          */
/* ------------------------------------------------------------------------- */
void deallocate_array(item_type *array)
{
    free(array);
}



/* ------------------------------------------------------------------------- */
/* sekvencni pristup ke vsem polozkam v poli                                 */
/* ------------------------------------------------------------------------- */
void access_array_sequentially(array_type array, int width, int height)
{
    int i, j;
    for (j=0; j&lt;height; j++)
    {
        for (i=0; i&lt;width; i++)
        {
            array[i+j*width]++;
        }
    }
}



/* ------------------------------------------------------------------------- */
/* pristup k polozkam pole po sloupcich                                      */
/* ------------------------------------------------------------------------- */
void access_array_by_columns(array_type array, int width, int height)
{
    int i, j;
    for (i=0; i&lt;width; i++)
    {
        for (j=0; j&lt;height; j++)
        {
            array[i+j*width]++;
        }
    }
}



/* ------------------------------------------------------------------------- */
/* vypocet casu pro oba dva zpusoby pristupu k poli                          */
/* ------------------------------------------------------------------------- */
void compute_times(int width, int height, double *t1, double *t2)
{
    array_type array=NULL;
    clock_t t_start, t_end;
    int i;

    array=allocate_array(width, height);
    fill_array(array, width, height);

    t_start=clock();
    for (i=0; i&lt;INNER_LOOP_COUNT; i++)
    {
        access_array_sequentially(array, width, height);
    }
    t_end=clock();
    *t1=((double)(t_end-t_start)/CLOCKS_PER_SEC);

    t_start=clock();
    for (i=0; i&lt;INNER_LOOP_COUNT; i++)
    {
        access_array_by_columns(array, width, height);
    }
    t_end=clock();
    *t2=((double)(t_end-t_start)/CLOCKS_PER_SEC);

    deallocate_array(array);
}



/* ------------------------------------------------------------------------- */
/* funkce spustena po startu procesu                                         */
/* ------------------------------------------------------------------------- */
int main(void)
{
    int i, size=2;

    printf(" array size         bytes      t1      t2    delta t\n");
    for (i=0; i&lt;12; i++)
    {
        double t1, t2;
        double delta_t, proc;
        compute_times(size, size, &amp;t1, &amp;t2);
        delta_t=t2-t1;
        proc=t1&lt;1e-5 ? 0 : 100.0*(delta_t)/t1;
        if (t2&lt;t1) {double x=t1;t1=t2;t2=x;}
        printf("%5d x%5d    %9ld  %7.3f %7.3f %7.3f %5.1f%%\n", size, size, (long)get_size(size, size), t1, t2, delta_t, proc);
        size*=2;
    }
    return 0;
}



/* ------------------------------------------------------------------------- */
/* finito                                                                    */
/* ------------------------------------------------------------------------- */
</code-area>

<p>Podívejme se na výsledky získané pøi bìhu tohoto pøíkladu pøelo¾eného bez
optimalizací, tj.&nbsp;pouze s&nbsp;volbami <strong>-std=c99
-Wall</strong>:</p>

<pre>
 array size         bytes      t1       t2    delta t   proc poznámka
    2 x    2           16    0.000    0.000    0.000    0.0% (pod pøesnost mìøení èasu)
    4 x    4           64    0.000    0.000    0.000    0.0% (pod pøesnost mìøení èasu)
    8 x    8          256    0.000    0.000    0.000    0.0% (pod pøesnost mìøení èasu)
   16 x   16         1024    0.000    0.000    0.000    0.0% (pod pøesnost mìøení èasu)
   32 x   32         4096    0.000    0.010    0.010    0.0% (pod pøesnost mìøení èasu)
   64 x   64        16384    0.010    0.020    0.010  100.0% (pod pøesnost mìøení èasu)
  128 x  128        65536    0.040    0.040    0.000    0.0%
  256 x  256       262144    0.120    0.160    0.040   33.3%
  512 x  512      1048576    0.471    0.621    0.150   31.8%
 1024 x 1024      4194304    1.902   14.992   13.090  688.2%
 2048 x 2048     16777216    7.621   72.755   65.134  854.7%
 4096 x 4096     67108864   30.814  304.908  274.094  889.5%
</pre>

<p>Vìt¹í pole nebylo mo¾né pou¾ít, nebo» na testovacím systému (notebook) mám
pouze 256 MB operaèní pamìti, z&nbsp;toho si cca 80 MB alokuje operaèní systém
a jeho pomocné aplikace. Po alokaci dal¹ího pole s&nbsp;256 MB by tedy do¹lo ke
swapování, tj.&nbsp;meziukládání jednotlivých stránek pamìti na disk, co¾ by
celé mìøení zkreslilo.</p>



<p><a name="k05"></a></p>
<h1>5. Vliv optimalizace</h1>

<p>Mnohem zajímavìj¹ích výsledkù je mo¾né dosáhnout pøi pøekladu vý¹e uvedeného
testovacího programu se zapnutou optimalizací. Tabulka zobrazená ní¾e byla
získána po pøekladu s&nbsp;volbami <strong>-O3 -funroll-all-loops -std=c89
-Wall</strong>. V¹imnìte si, ¾e se u obou typù smyèek vìt¹inou sní¾ily èasy
výpoètu (co¾ se ostatnì dá od optimalizovaného programu oèekávat), ov¹em èasový
rozdíl mezi jednotlivými smyèkami se neúmìrnì zvý¹il. Je to logické, proto¾e
v&nbsp;optimalizovaném programu se pøekladaèi podaøilo zrychlit provádìní
samotných smyèek, ov¹em u druhého typu smyèky program pøi svém bìhu musí
neustále èekat na pøesuny dat z&nbsp;operaèní pamìti do pamìti vyrovnávací.
Z&nbsp;toho vyplývá ponauèení, ¾e je skuteènì zapotøebí dbát na dodr¾ení
lokality dat (zde mù¾e jednoduchým prohozením smyèek dojít a¾
k&nbsp;dvacetinásobnému urychlení) a také, ¾e ne v¾dy doká¾e pøekladaè program
optimalizovat tak, jak by se mo¾ná dalo pøedpokládat (to je v¹ak téma, které by
samo o sobì vydalo na celý èlánek):</p>

<pre>
 array size         bytes      t1        t2     delta t proc poznámka
    2 x    2           16    0.000    0.000    0.000    0.0% (pod pøesnost mìøení èasu)
    4 x    4           64    0.000    0.000    0.000    0.0% (pod pøesnost mìøení èasu)
    8 x    8          256    0.000    0.000    0.000    0.0% (pod pøesnost mìøení èasu)
   16 x   16         1024    0.000    0.000    0.000    0.0% (pod pøesnost mìøení èasu)
   32 x   32         4096    0.000    0.000    0.000    0.0% (pod pøesnost mìøení èasu)
   64 x   64        16384    0.000    0.000    0.000    0.0% (pod pøesnost mìøení èasu)
  128 x  128        65536    0.010    0.030    0.020  200.0%
  256 x  256       262144    0.020    0.120    0.100  500.0%
  512 x  512      1048576    0.080    0.551    0.471  588.8%
 1024 x 1024      4194304    0.661   15.312   14.651 2216.5%
 2048 x 2048     16777216    3.014   71.753   68.739 2280.7%
 4096 x 4096     67108864   12.057  307.483  295.426 2450.2%
</pre>

<p>Zoptimalizovaná èást kódu vypadá ponìkud slo¾itì, co¾ je zpùsobeno èásteèným
pøeuspoøádáním smyèek (napøíklad se na zaèátku skáèe dovnitø tìla smyèky atd.):</p>

<code-area>
L18:
        xorl    %edx, %edx
        jmp     L26
L27:
        leal    (%edx,%ecx), %eax
        incl    %edx
        incl    (%esi,%eax,4)
L26:
        cmpl    %ebx, %edx
        jl      L27
        incl    %edi
        addl    %ebx, %ecx
        cmpl    16(%ebp), %edi
        jl      L18
</code-area>



<p><a name="k06"></a></p>
<h1>6. Slo¾itìj¹í pøíklad</h1>

<p>V&nbsp;dal¹í ukázce programového kódu (jedná se konkrétnì o èást programu pro
zobrazení vektorových dat pøestavujících kolejovou sí») je jasnì patrná jak
lokalita dat, tak i lokalita programového kódu. Funkce <i>drawEntities</i> sice
obsahuje pomìrnì velké mno¾ství programových øádkù, ov¹em naprostou vìt¹inu
èasu zabere provádìní tøí do sebe vnoøených smyèek (dùle¾ité je uvidìt i onu
nejvnitønìj¹í smyèku, která je ponìkud skryta), proto¾e poèet zpracovávaných
objektù (pole <i>items</i>) v&nbsp;praxi dosahuje øádù tisícù. Lokalita dat ji¾
není tak zøejmá, ov¹em nejvìt¹í pole (<i>items</i>) je procházeno lineárnì
(sekvenènì) a men¹í pole, ve kterém je neustále provádìno vyhledávání, je tak
malé, ¾e se zcela jistì ulo¾í do nìkolika blokù datové vyrovnávací pamìti
&ndash; poèet prvkù tohoto pole dosahuje øádu desítek, proto se zde nevyplatilo
pou¾ití nìjaké slo¾itìj¹í datové struktury typu he¹ovací tabulka nebo binární
strom. Na druhou stranu lze nejvnitønìj¹í programovou smyèku skuteènì nahradit,
v&nbsp;tomto pøípadì (pøi znalosti formátu vstupních dat) dvojicí porovnání
dvou celoèíselných hodnot.</p>

<code-area>
void drawEntities(DrawBuffer * buffer, Item * items, int maxitems, DbITems * knowItems, int selected)
{
    int i,j;
    char *typEntity[]=
    {
        "Neznámá entita",
        "Polyèára",
        "Kruhový oblouk",
        "Kru¾nice",
        "Region",
        "Multibod"
    };
    printfxy(4, 32, "vybrany prvek: %d", selected);
    setTextRGBcolor(0x80, 0x00, 0x00);
    printfxy(10,  48, "ID prvku:");
    printfxy(10, 272, "typ entity:");
    setTextRGBcolor(0x00, 0x00, 0x80);
    printfxy(90,  48, "%s",   items[selected].id_prvek);
    printfxy(90, 272, typEntity[items[selected].entityType]);
    for (i=0; i&lt;maxitems; i++)
    {
        int color=0;
        int c;
        if (items[i].activeItem)
        {
            int j;
            for (j=0; knowItems[j].color; j++)
            {
                if (strncmp(knowItems[j].tudu, items[i].id_prvek, 8)==0)
                {
                    color=knowItems[j].color;
                    c=color;
                    break;
                }
            }
        }
        if (!viewAll &amp;&amp; (items[i].id_prvek==0 || strcmp(items[i].id_prvek, "")==0))
        {
            continue;
        }
        // program dále pokraèuje
    }
}
</code-area>



<p><a name="k07"></a></p>
<h1>7. Literatura a odkazy na Internetu</h1>

<ol>

<li>Pavel Valá¹ek, Roman Loskot: <i>Polovodièové pamìti</i>,<br />
BEN - Technická literatura, Praha 1998, ISBN-80-86056-18-X</li>

<li>Budínský J.: <i>Polovodièové pamìti a jejich pou¾ití</i>,<br />
SNTL, Praha 1977</li>

<li>Budínský J.: <i>Polovodièové pamìti - Názvosloví a definice</i>,<br />
TESLA VÚST, Praha 1980</li>

<li>Janù K.: <i>Pamìti a øadièe - èást I.</i>,<br />
ÈSVTS, Kni¾nice mikroprocesorová technika, Praha 1982</li>

<li><i>Great Microprocessors of the Past and Present (V 13.0.0)</i></li>

<li><a href="http://citeseer.ist.psu.edu/252861.html">Revisiting the Cache Interference Costs of Context Switching</a> (http://citeseer.ist.psu.edu/252861.html)</li>

<li><a href="http://www.ibm.com/developerworks/java/library/j-jtp04223.html">Java theory and practice: Urban performance legends</a> (http://www.ibm.com/developerworks/java/library/j-jtp04223.html)</li>

<li><a href="http://www-128.ibm.com/developerworks/java/library/j-jtp09275.html?ca=dgr-lnxw01JavaUrbanLegends">Java theory and practice: Urban performance legends, revisited</a> (http://www-128.ibm.com/developerworks/java/library/j-jtp09275.html?ca=dgr-lnxw01JavaUrbanLegends)</li>

<li><a href="http://www.lily.org/blog/2005/09/pdc05-day-five-five-things-every-win32.html">PDC05: Day Five (Five Things Every Win32 Developer Should Know)</a> (http://www.lily.org/blog/2005/09/pdc05-day-five-five-things-every-win32.html)</li>

<li><a href="http://www.majda.cz/zapisnik/?220">David Majda: Nìco málo o optimalizaci</a> (http://www.majda.cz/zapisnik/?220)</li>

<li><a href="http://www.pcguide.com/ref/mbsys/cache/funcMapping-c.html">Cache Mapping and Associativity</a> (http://www.pcguide.com/ref/mbsys/cache/funcMapping-c.html)</li>

<li><a href="http://en.wikipedia.org/wiki/Cache">Wikipedia: Cache</a> (http://en.wikipedia.org/wiki/Cache)</li>

<li><a href="http://en.wikipedia.org/wiki/CPU_cache">Wikipedia: CPU cache</a> (http://en.wikipedia.org/wiki/CPU_cache)</li>

<li><a href="http://en.wikipedia.org/wiki/Cache_algorithms">Wikipedia: Cache algorithms</a> (http://en.wikipedia.org/wiki/Cache_algorithms)</li>

<li><a href="http://lwn.net/Articles/252125/">Memory part 2: CPU caches</a> (http://lwn.net/Articles/252125/)</li>

<li><a href="http://lwn.net/Articles/255364/">Memory part 5: What programmers can do</a> (http://lwn.net/Articles/255364/)</li>

<li><a href="http://www.cs.wisc.edu/multifacet/misc/spec2000cache-data/">Cache Performance for SPEC CPU2000 Benchmarks</a> (http://www.cs.wisc.edu/multifacet/misc/spec2000cache-data/)</li>

</ol>



<p><a name="k08"></a></p>
<h1>8. Obsah dal¹í èásti seriálu</h1>

<p>V&nbsp;následující èásti seriálu o funkci poèítaèù ji¾ opustíme problematiku
operaèních pamìtí i pamìtí vyrovnávacích, proto¾e se zaèneme zabývat dal¹ím
rozsáhlým a pøitom zajímavým a stále je¹tì aktuálním tématem &ndash;
technologiemi magnetických pamìtí, pøedev¹ím páskových mechanik, disketových
jednotek a pevných diskù. Posléze se zamìøíme i na pamìti optické a
magnetooptické. I pøes velký vzrùst kapacity pamìtí typu Flash EPROM a
souèasném poklesu jejich ceny (pøepoètené na jeden bit) jsou toti¾ u mnoha
aplikací magnetické a optické pamìti prozatím tì¾ko nahraditelné.</p>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2008</small></p>
</body>
</html>

