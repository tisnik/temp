<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pohled programátora na mikroprocesory ARM</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pohled programátora na mikroprocesory ARM</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o architekturách poèítaèù budeme pokraèovat v popisu RISCových mikroprocesorù s architekturou ARM. Pøedev¹ím se seznámíme s instrukèní sadou tìchto mikroprocesorù, která se v nìkolika ohledech odli¹uje jak od CISCových mikroprocesorù (co¾ lze ostatnì oèekávat), tak i od ostatních mikroprocesorù typu RISC.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Mikroprocesory s&nbsp;architekturou ARM a jejich &bdquo;RISCová&ldquo; instrukèní sada</a></p>
<p><a href="#k02">2. Registry pøístupné programátorùm</a></p>
<p><a href="#k03">3. Pracovní registry a re¾imy mikroprocesorù ARM</a></p>
<p><a href="#k04">4. Pøíznakové registry CPSR a SPSR</a></p>
<p><a href="#k05">5. Typy instrukcí zpracovávaných mikroprocesory ARM</a></p>
<p><a href="#k06">6. Formát instrukcí zpracovávaných mikroprocesory ARM</a></p>
<p><a href="#k07">7. Jeden ze zpùsobù øe¹ení problematiky podmínìných skokù: podmínìné spou¹tìní instrukcí</a></p>
<p><a href="#k08">8. Demonstraèní pøíklad: pou¾ití podmínìného spou¹tìní instrukcí</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Mikroprocesory s&nbsp;architekturou ARM a jejich &bdquo;RISCová&ldquo; instrukèní sada</h2>

<p><a
href="http://www.root.cz/clanky/mikroprocesory-s-architekturou-arm/">V&nbsp;pøedchozí
èásti</a> <a href="http://www.root.cz/serialy/co-se-deje-v-pocitaci/">seriálu o
architekturách poèítaèù</a> jsme se seznámili s&nbsp;historií vzniku
mikroprocesorù s&nbsp;architekturou <i>ARM</i> a øekli jsme si základní
informace o vlastnostech tìchto procesorù, které je pøedurèují mj. i
k&nbsp;pou¾ití v&nbsp;mobilních zaøízeních. Dnes se zamìøíme pøedev¹ím na popis
tìchto mikroprocesorù z&nbsp;hlediska èi spí¹e pohledu programátora, proto¾e
procesory <i>ARM</i> nabízí vývojáøùm hned nìkolik unikátních vlastností, které
u jiných architektur nenajdeme. Ji¾ minule jsme si øekli, ¾e moderní varianty
mikroprocesorù <i>ARM</i> mohou pracovat s&nbsp;nìkolika instrukèními sadami,
mezi kterými je mo¾né se programovì &ndash; a to i v&nbsp;rámci jedné aplikace
&ndash; pøepínat. Jedná se o pùvodní &bdquo;RISCovou&ldquo; instrukèní sadu,
v&nbsp;ní¾ mají v¹echny instrukce shodnou ¹íøku 32 bitù, dále pak o instrukèní
sadu nazvanou <i>Thumb</i> s&nbsp;instrukcemi o ¹íøce 16 bitù, instrukèní sadu
<i>Thumb 2</i>, v&nbsp;ní¾ mohou mít instrukce promìnnou délku a u nìkterých
èipù <i>ARM</i> se mù¾eme setkat i s&nbsp;podporou technologie <i>Jazelle</i>
dovolující zpracovávat bajtkód JVM, tj.&nbsp;instrukce urèené pùvodnì pro
zpracování virtuálním strojem Javy (ve skuteènosti je v¹ak pøímo zpracovávána
pouze èást tìchto instrukcí, ostatní jsou implementovány podprogramem).</p>

<p>Nejdøíve zaèneme s&nbsp;popisem pùvodní &bdquo;RISCové&ldquo; instrukèní
sady, která je souèasnì i instrukèní sadou v&nbsp;mnoha ohledech
nejzajímavìj¹í. Jak jsme si ji¾ øekli v&nbsp;pøedchozím odstavci, mají v¹echny
instrukce patøící do této instrukèní sady ¹íøku 32 bitù, a to vèetnì instrukcí
urèených pro naètení 32 bitové konstanty (zde muselo logicky dojít
k&nbsp;urèitému kompromisu). Tìchto 32 bitù je podle typu instrukce rozdìleno
do nìkolika bitových polí rùzné ¹íøky, v&nbsp;nich¾ se nachází bitové pøíznaky,
na nich¾ vykonání instrukce závisí (viz dal¹í kapitoly s&nbsp;podrobnìj¹ím
popisem), operaèní kód instrukce, indexy registrù (operandù), s&nbsp;nimi¾
instrukce pracuje, konstanta pou¾itá pro bitový posun èi rotaci jednoho
z&nbsp;operandù atd. U instrukcí <strong>LDM</strong> a <strong>STM</strong> je
jedno bitové pole o ¹íøce 16 bitù urèeno pro oznaèení tìch pracovních registrù,
které se mají naèíst z&nbsp;operaèní pamìti, popø.&nbsp;které se naopak mají do
operaèní pamìti ulo¾it (i touto dvojicí instrukcí se je¹tì budeme v&nbsp;dal¹ím
textu podrobnìji zabývat).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Registry pøístupné programátorùm</h2>

<p>Vzhledem k&nbsp;tomu, ¾e u v¹ech mikroprocesorù s&nbsp;architekturou
<i>RISC</i> je díky existenci instrukèní pipeline pro ka¾dou instrukci
v&nbsp;ideálním pøípadì vyhrazena pouze jedna operace pøístupu k&nbsp;operaèní
pamìti (konkrétnì se jedná o ètení operaèního kódu instrukce), je nutné, aby
tyto mikroprocesory obsahovaly na svém èipu velký poèet pracovních registrù. Na
druhou stranu v¹ak pevná ¹íøka instrukèních slov (typicky 32 bitù) vede
k&nbsp;tomu, ¾e v&nbsp;jedné instrukci lze indexovat pouze omezený poèet
pracovních registrù, proto¾e RISCové instrukce vìt¹inou neobsahují implicitní
operandy (opaèným extrémem je instrukèní sada ¹estnáctibitových mikroprocesorù
<i>Intel 8086</i> obsahující mnoho instrukcí s&nbsp;implicitním operandem èi
operandy).</p>

<p>Jak jsme se ji¾ dozvìdìli v&nbsp;pøedchozích èástech tohoto seriálu, vedly
tyto dva protichùdné po¾adavky &ndash; velký poèet pracovních registrù/omezená
¹íøka instrukcí &ndash; k&nbsp;tomu, ¾e nìkteøí konstruktéøi mikroprocesorù
<i>RISC</i> (poèínaje projektem <i>Berkeley RISC</i>) zavádìli takzvaná
&bdquo;registrová okna&ldquo;, která programátorùm v&nbsp;daný okam¾ik
zpøístupòovala pouze urèitý výsek z&nbsp;celé sady registrù. Velikost
registrových oken je rùzná, poèínaje osmi registry (projekt <i>Berkeley
RISC</i>) a¾ po promìnný poèet registrù v&nbsp;registrovém oknì (pøíkladem
mohou být mikroprocesory øady <i>AMD 29000</i>).</p>

<p>Konstruktéøi mikroprocesorù <i>ARM</i> se v¹ak vydali ponìkud odli¹nou
cestou a namísto registrových oken (posouvaných vìt¹inou pøi volání podprogramu
a návratu z&nbsp;podprogramu) pou¾ili v&nbsp;u¾ivatelském (neprivilegovaném)
re¾imu pouze jednu sadu registrù, podobnì, jako je tomu napøíklad u RISCových
mikroprocesorù <i>MIPS</i>. Existence jedné sady registrù znamená, ¾e se o
alokaci registrù pro rùzné operandy musí starat pøekladaè, a to samozøejmì i
v&nbsp;pøípadì volání podprogramù (subrutin). Ov¹em vzhledem k&nbsp;tomu, ¾e je
vhodné, aby mikroprocesor dokázal velmi rychle zpracovávat pøeru¹ení èi
vykonávat funkce jádra operaèního systému, existuje u architektury <i>ARM</i>
ve skuteènosti nìkolik registrù dostupných pouze v&nbsp;pøeru¹ovací rutinì,
v&nbsp;supervisorském re¾imu atd. Instrukèní sada samozøejmì zùstává ve v¹ech
re¾imech stále stejná, proto programátor v&nbsp;jakémkoli re¾imu mù¾e pracovat
se stejným poètem pracovních registrù. Na tomto místì je takté¾ vhodné
upozornit na to, ¾e se poèet <i>re¾imù</i> mikroprocesorù <i>ARM</i> postupnì
zvy¹oval, stejnì jako poèet speciálních registrù dostupných pouze v&nbsp;jednom
re¾imu &ndash; viz té¾ <a href="#k03">následující kapitolu</a>.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Pracovní registry a re¾imy mikroprocesorù ARM</h2>

<p>V&nbsp;pøedchozí kapitole jsme si øekli, ¾e poèet re¾imù mikroprocesoru a
souèasnì i poèet &bdquo;speciálních&ldquo; pracovních registrù (pøístupných
pouze z&nbsp;jednoho re¾imu) se postupnì zvy¹oval. Následující tabulka se ¹esti
re¾imy procesoru je z&nbsp;tohoto dùvodu platná pro mikroprocesory <i>ARM</i>
patøící do rodiny <i>ARM 7</i>, nikoli napøíklad pro první dvì generace
procesorù <i>ARM1</i> a <i>ARM2</i>. Pov¹imnìte si, ¾e prvních osm pracovních
registrù je dostupných v&nbsp;jakémkoli re¾imu procesoru, stejnì jako registr
<strong>r15</strong> slou¾ící jako programový èítaè <strong>PC</strong>
(ostatnì pøidání programového èítaèe mezi &bdquo;bì¾né&ldquo; pracovní registry
je jednou z&nbsp;typických vlastností mikroprocesorù <i>ARM</i>):</p>

<table>
<tr><th>Index/Re¾im</th><th>User</th><th>FIQ</th><th>Supervisor</th><th>Abort</th><th>IRQ</th><th>Undefined</th></tr>
<tr><td> 0</td><td>r0 </td><td>r0 </td><td>r0 </td><td>r0 </td><td>r0 </td><td>r0 </td></tr>
<tr><td> 1</td><td>r1 </td><td>r1 </td><td>r1 </td><td>r1 </td><td>r1 </td><td>r1 </td></tr>
<tr><td> 2</td><td>r2 </td><td>r2 </td><td>r2 </td><td>r2 </td><td>r2 </td><td>r2 </td></tr>
<tr><td> 3</td><td>r3 </td><td>r3 </td><td>r3 </td><td>r3 </td><td>r3 </td><td>r3 </td></tr>
<tr><td> 4</td><td>r4 </td><td>r4 </td><td>r4 </td><td>r4 </td><td>r4 </td><td>r4 </td></tr>
<tr><td> 5</td><td>r5 </td><td>r5 </td><td>r5 </td><td>r5 </td><td>r5 </td><td>r5 </td></tr>
<tr><td> 6</td><td>r6 </td><td>r6 </td><td>r6 </td><td>r6 </td><td>r6 </td><td>r6 </td></tr>
<tr><td> 7</td><td>r7 </td><td>r7 </td><td>r7 </td><td>r7 </td><td>r7 </td><td>r7 </td></tr>
<tr><td> 8</td><td>r8 </td><td>r8_fiq </td><td>r8 </td><td>r8 </td><td>r8 </td><td>r8 </td></tr>
<tr><td> 9</td><td>r9 </td><td>r9_fiq </td><td>r9 </td><td>r9 </td><td>r9 </td><td>r9 </td></tr>
<tr><td>10</td><td>r10</td><td>r10_fiq</td><td>r10</td><td>r10</td><td>r10</td><td>r10</td></tr>
<tr><td>11</td><td>r11</td><td>r11_fiq</td><td>r11</td><td>r11</td><td>r11</td><td>r11</td></tr>
<tr><td>12</td><td>r12</td><td>r12_fiq</td><td>r12</td><td>r12</td><td>r12</td><td>r12</td></tr>
<tr><td>13</td><td>r13</td><td>r13_fiq</td><td>r13_svc</td><td>r13_abt</td><td>r13_irq</td><td>r13_undef</td></tr>
<tr><td>14</td><td>r14</td><td>r14_fiq</td><td>r14_svc</td><td>r14_abt</td><td>r14_irq</td><td>r14_undef</td></tr>
<tr><td>15</td><td>r15/PC</td><td>r15/PC</td><td>r15/PC</td><td>r15/PC</td><td>r15/PC</td><td>r15/PC</td></tr>
</table>

<p>Z&nbsp;tabulky je patrné, ¾e mikroprocesory <i>ARM 7</i> sice obsahují 31
pracovních registrù, ov¹em v&nbsp;ka¾dém re¾imu mikroprocesoru má programátor
pøístup pouze k&nbsp;¹estnácti registrùm, pøièem¾ registr <strong>r15</strong>
je v¾dy pova¾ován za programový èítaè (to ov¹em neznamená, ¾e se do nìj nemù¾e
provádìt zápis &ndash; ve skuteènosti je tomu právì naopak).</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Pøíznakové registry CPSR a SPSR</h2>

<p>Kromì pracovních registrù a programového èítaèe obsahují mikroprocesory
s&nbsp;architekturou <i>ARM</i> i registry, v&nbsp;nich¾ se uchovávají rùzné
pøíznaky. V&nbsp;u¾ivatelském re¾imu se pracuje s&nbsp;pøíznaky ulo¾enými
v&nbsp;registru nazvaném <strong>CPSR</strong> (<i>Current Program Status
Register</i>) a pro ka¾dý dal¹í re¾im existuje navíc zvlá¹tní registr nazvaný
<strong>SPSR</strong> (<i>Saved Program Status Register</i>), v&nbsp;nìm¾ jsou
uchovány pùvodní pøíznaky ze <strong>CPSR</strong> (zatím jsme se tedy úspì¹nì
vyhnuli nutnosti pou¾ití zásobníku :-). Podobnì jako v¹echny pracovní registry,
mají i registry <strong>CPSR</strong> a <strong>SPSR_?</strong> shodnou ¹íøku
32 bitù, co¾ má svoje výhody. Mimo jiné i to, ¾e ¹íøka 32 bitù ponechala
konstruktérùm procesorù <i>ARM</i> mnoho prostoru pro ulo¾ení rùzných
dùle¾itých informací do registrù <strong>CPSR/SPSR</strong>, tak¾e se nemuseli
uchylovat k&nbsp;nepøíli¹ promy¹leným technikám známým napøíklad
z&nbsp;platformy <i>x86</i>, kde se pùvodnì ¹estnáctibitový registr
<strong>FLAGS</strong> (<i>8086</i>) postupnì zmìnil na 32bitový registr
<strong>EFLAGS</strong> (<i>80386</i>), vedle nìho vznikl registr
<strong>MSW</strong> (<i>80286</i>) roz¹íøený na <strong>CR0</strong> atd.
atd.</p>

<p>Ve stavových registrech <strong>CPSR/SPSR</strong> mikroprocesorù <i>ARM</i>
jsou ulo¾eny pøedev¹ím bitové pøíznaky nastavované aritmeticko-logickou
jednotkou, dále pak bity urèující, jakou instrukèní sadu mikroprocesor právì
zpracovává (<i>ARM</i>, <i>Thumb</i>, <i>Jazelle</i>), pøíznak poøadí
zpracovávání bajtù (little/big endian) a takté¾ pøíznaky pou¾ívané u SIMD
operací. Zdaleka ne v¹echny mikroprocesory <i>ARM</i> v¹ak skuteènì pracují se
v¹emi bity, co¾ je logické, proto¾e napøíklad pøíznak <strong>Q</strong> je
pou¾íván jen u mikroprocesorù podporujících aritmetiku se saturací, pøíznak
<strong>J</strong> u èipù s&nbsp;podporou technologie <i>Jazelle</i> atd.:</p>

<table>
<tr><th>Pøíznak</th><th>Význam zkratky</th><th>Poznámka</th></tr>
<tr><td>N</td><td>negative</td><td>výsledek ALU operace je záporný</td></tr>
<tr><td>V</td><td>overflow</td><td>pøeteèení (znaménková aritmetika)</td></tr>
<tr><td>Z</td><td>zero</td><td>výsledek je nulový</td></tr>
<tr><td>C</td><td>carry</td><td>pøenos (bezznaménková aritmetika)</td></tr>
<tr><td>I</td><td>interrupt</td><td>zákaz IRQ (pøeru¹ení)</td></tr>
<tr><td>F</td><td>fast interrupt</td><td>zákaz FIRQ (rychlého pøeru¹ení)</td></tr>
<tr><td>Q</td><td>sticky overflow</td><td>aritmetika se saturací, od ARMv5e vý¹e</td></tr>
<tr><td>T</td><td>thumb</td><td>pøíznak zpracování instrukèní sady Thumb (jen u procesorù se znakem "T" v názvu)</td></tr>
<tr><td>J</td><td>jazelle</td><td>pøíznak zpracování instrukèní sady Jazelle (jen u procesorù se znakem "J" v názvu)</td></tr>
<tr><td>E</td><td>endianness</td><td>poøadí bajtù pøi práci s RAM (big/little endian)</td></tr>
<tr><td>GE</td><td>4 bity</td><td>pou¾ito u SIMD operací (pouze nìkteré èipy)</td></tr>
<tr><td>IF</td><td>5 bitù</td><td>pou¾ito u instrukcí Thumb2 (pouze nìkteré èipy)</td></tr>
<tr><td>M</td><td>5 bitù</td><td>re¾im práce mikroprocesoru (user, IRQ, FIRQ, ...)</td></tr>
</table>

<p><ins>Poznámka: v&nbsp;tabulce zobrazené vý¹e nejsou jednotlivé bity uvedeny
v&nbsp;takovém poøadí, v&nbsp;jakém se nachází ve stavovém registru.</ins></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Typy instrukcí zpracovávaných mikroprocesory ARM</h2>

<p>Instrukèní sada mikroprocesorù <i>ARM</i> obsahuje nìkolik typù instrukcí.
V&nbsp;první øadì se samozøejmì jedná o instrukce typu <i>Load</i> a
<i>Store</i> urèené pro naètení èi naopak ulo¾ení obsahu pracovních registrù do
operaèní pamìti (mezi operace typu <i>Load</i> se zde poèítá i naètení
konstanty). Dále jsou v&nbsp;instrukèní sadì pøítomny aritmetické operace,
logické a bitové operace, skoky (jeden typ skoku souèasnì mù¾e zmìnit i
instrukèní sadu mikroprocesoru), instrukce pro práci se stavovými registry
<strong>CPSR</strong> popø.&nbsp;<strong>SPSR</strong> a nìkolik instrukèních
kódù je takté¾ vyhrazeno pro komunikaci a øízení koprocesorù, napøíklad
matematického koprocesoru, GPU atd. Pov¹imnìte si, ¾e jsme se prozatím
nezmínili o instrukcích pro provádìní bitových posunù a rotací, co¾ je správnì,
proto¾e tyto instrukce ve skuteènosti na procesorech <i>ARM</i> samostatnì
neexistují (stále se bavíme o pùvodní RISCové instrukèní sadì). Velká èást ALU
instrukcí toti¾ umo¾òuje, aby se bitový posun èi rotace vykonal
v&nbsp;<i>barrel shifteru</i> se druhým operandem vstupujícím do ALU, tak¾e se
bitový posun/rotace musí zakódovat do nìkteré ALU instrukce, popø.&nbsp;do
instrukce pøenosu dat (to je vìt¹inou zále¾itostí pøekladaèe):</p>

<ol>
<li>Instrukce typu load/store provádìné s&nbsp;jedním pracovním registrem.</li>
<li>Instrukce typu load/store provádìné s&nbsp;0 a¾ 16 pracovními registry.</li>
<li>Aritmetické operace.</li>
<li>Logické a bitové operace.</li>
<li>Skoky a zmìna instrukèní sady mikroprocesoru.</li>
<li>Práce se stavovými registry CPSR a SPSR.</li>
<li>Instrukce koprocesoru</li>
</ol>



<p><a name="k06"></a></p>
<h2 id="k06">6. Formát instrukcí zpracovávaných mikroprocesory ARM</h2>

<p>V&nbsp;této kapitole si struènì popí¹eme formát instrukcí mikroprocesorù
<i>ARM</i>. Instrukèní slovo o konstantní ¹íøce 32 bitù je rozdìleno do
nìkolika èástí. V&nbsp;prvních ètyøech bitech se u v¹ech instrukcí nachází kód
podmínky, jeho¾ význam bude vysvìtlen <a href="#k07">v&nbsp;následující
kapitole</a>. Za kódem podmínky je ulo¾en vlastní operaèní kód instrukce o
¹íøce 4 a¾ 8 bitù, který bývá u nìkterých typù instrukcí navíc doplnìn dal¹ími
bity (napøíklad se to týká instrukcí násobení, kde lze pomocí tìchto bitù
zvolit re¾im násobení a typ výsledku). Dal¹í obsah instrukèního slova se li¹í
podle toho, o jaký typ instrukce se jedná. Napøíklad u skokù je operaèní kód
instrukce ¹iroký pouze ètyøi bity, co¾ ponechává celých 24 bitù pro ulo¾ení
offsetu skoku. Vìt¹ina aritmetických instrukcí obsahuje v&nbsp;instrukèním
slovì indexy dvou pracovních registrù (ka¾dý po 4 bitech) a navíc
dvanáctibitový operand s&nbsp;rùzným významem. Výjimku tvoøí instrukce pro
násobení, které v&nbsp;instrukèním kódu obsahují indexy hned ètyø registrù:
<i>Rd</i>, <i>Rn</i>, <i>Rs</i> a <i>Rm</i>. Dal¹í výjimkou jsou ji¾ zmínìné
instrukce <strong>LDM</strong> a <strong>STM</strong>, kde se ve spodní
polovinì instrukce, tj.&nbsp;v&nbsp;¹estnácti bitech, nachází bitové pole
urèující, které registry mají být pøeèteny èi zapsány do operaèní pamìti.</p>

<p>Pod tímto odstavcem je naznaèen formát nìkterých typù instrukcí
mikroprocesorù <i>ARM</i>. Kromì posledního formátu má operaèní kód ¹íøku osm
bitù, v&nbsp;pøípadì skokù (poslední formát) pak pouze ètyøi bity, proto¾e
zbývajících 24 bitù je pou¾ito pro ulo¾ení offsetu skoku:</p>

<pre>
31     27           15                  0
+------+--------------------------------+
| cond | opkód | Rn | Rd |  operand 2   |
+------+--------------------------------+
| cond | opkód | Rn | Rd | Rs | op.| Rm |
+------+--------------------------------+
| cond | opkód | Rn | Rd |  offset      |
+------+--------------------------------+
&nbsp;
Instrukce LDM a STM:
31     27           15                  0
+------+--------------------------------+
| cond | opkód | Rn |  bitové pole reg. |
+------+--------------------------------+
&nbsp;
Instrukce skoku:
31     27    23                         0
+------+--------------------------------+
| cond |opkód|       offset skoku       |
+------+--------------------------------+
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Jeden ze zpùsobù øe¹ení problematiky podmínìných skokù: podmínìné spou¹tìní instrukcí</h2>

<p>Pokud se podíváme na formát instrukcí zobrazený <a
href="#k06">v&nbsp;pøedchozí kapitole</a>, mù¾eme vidìt, ¾e se
v&nbsp;nejvy¹¹ích ètyøech bitech ka¾dé instrukce nachází takzvaný kód podmínky.
Konstruktéøi mikroprocesorù <i>ARM</i> toti¾ (èásteènì) vyøe¹ili problematiku
podmínìných skokù tím, ¾e umo¾nili vykonat ka¾dou instrukci pouze
v&nbsp;pøípadì, ¾e je splnìna podmínka, jejích kód je zapsán právì v&nbsp;onìch
ètyøech nejvy¹¹ích bitech instrukce. A o jakou problematiku podmínìných skokù
se vlastnì jedná? Podmínìné skoky pøedstavují pro klasickou RISCovou pipeline
obtí¾ný úkol: dùvodem existence instrukèní pipeline je to, aby se v&nbsp;ka¾dém
taktu v&nbsp;ideálním pøípadì dokonèila jedna instrukce. U skokù, zvlá¹tì tìch
podmínìných, se v¹ak ji¾ <strong>pøed</strong> rozhodnutím, zda se skok provede
èi nikoli, zaènou zpracovávat dal¹í instrukce umístìné za skokem, co¾ v¹ak
znamená, ¾e se v&nbsp;pøípadì provedení skoku tyto instrukce ve skuteènosti
nemají vykonat. Konstruktéøi RISCových a posléze i CISCových mikroprocesorù
tedy hledali rùzné zpùsoby øe¹ení této problematiky, a» se ji¾ jedná o
spekulativní provádìní instrukcí (pøíli¹ mnoho tranzistorù) èi o prediktory
skokù (ne v¾dy jsou úspì¹né).</p>

<p>Díky tomu, ¾e u mikroprocesorù <i>ARM</i> lze podmínku vykonání zadat u
ka¾dé instrukce, je mo¾né, aby se celkový poèet podmínìných skokù
v&nbsp;programu minimalizoval. Zejména se to týká skokù pou¾ívaných pro
implementaci programové konstrukce <strong>if-then-else</strong>, kde se
v&nbsp;jednotlivých vìtvích nachází jen malé mno¾ství instrukcí. Aby v¹ak mìlo
pou¾ití podmínkových kódù smysl, musela se zmìnit je¹tì jedna vlastnost
procesorù <i>ARM</i>: jejich aritmeticko-logická jednotka toti¾ zmìní stavové
bity <i>carry</i>, <i>zero</i>, <i>overflow</i> a <i>negative</i> pouze
v&nbsp;tom pøípadì, ¾e je to explicitnì v&nbsp;instrukèním kódu zapsáno
(výjimku tvoøí porovnávací instrukce). Touto vlastností se budeme zabývat a¾
v&nbsp;následující èásti seriálu.</p>

<p>První sada podmínkových kódù se pou¾ívá pro provedení èi naopak neprovedení
instrukce na základì hodnoty jednoho z&nbsp;pøíznakových bitù <i>zero</i>,
<i>overflow</i> èi <i>negative</i>. Poslední podmínkový kód z&nbsp;této skupiny
má název <i>AL (Any/Always)</i> a znaèí, ¾e se instrukce provede v&nbsp;ka¾dém
pøípadì. Tento podmínkový kód se tudí¾ vìt¹inou v&nbsp;assembleru nezapisuje,
proto¾e je pova¾ován za implicitní:</p>

<table>
<tr><th>Kód</td></th><th>Pøípona</th><th>Význam</th><th>Testovaná podmínka</th></tr>
<tr><td>0000</td><td>EQ</td><td>Z set     </td><td>rovnost (èi nulový výsledek)</td></tr>
<tr><td>0001</td><td>NE</td><td>Z clear   </td><td>nerovnost (èi nenulový výsledek)</td></tr>
<tr><td>0100</td><td>MI</td><td>N set     </td><td>výsledek je záporný</td></tr>
<tr><td>0101</td><td>PL</td><td>N clear   </td><td>výsledek je kladný èi 0</td></tr>
<tr><td>0110</td><td>VS</td><td>V set     </td><td>nastalo pøeteèení</td></tr>
<tr><td>0111</td><td>VC</td><td>V clear   </td><td>nenastalo pøeteèení</td></tr>
<tr><td>1110</td><td>AL</td><td>Any/Always</td><td>vìt¹inou se nezapisuje, implicitní podmínka</td></tr>
</table>

<p>Dal¹í ètyøi podmínkové kódy se vìt¹inou pou¾ívají pøi porovnávání dvou
hodnot bez znaménka (unsigned). V&nbsp;tìchto pøípadech se testují stavy
pøíznakových bitù <i>carry</i> a <i>zero</i>, pøesnìji øeèeno kombinací tìchto
bitù:</p>

<table>
<tr><th>Kód</td><th>Pøípona</th><th>Význam</th><th>Testovaná podmínka</th></tr>
<tr><td>0010</td><td>CS/HS</td><td>C set            </td><td>&gt;=</td></tr>
<tr><td>0011</td><td>CC/LO</td><td>C clear          </td><td>&lt;</td></tr>
<tr><td>1000</td><td>HI   </td><td>C set and Z clear</td><td>&gt;</td></tr>
<tr><td>1001</td><td>LS   </td><td>C clear or Z set </td><td>&lt;=</td></tr>
</table>

<p>Poslední ètyøi podmínkové kódy se pou¾ívají pro porovnávání hodnot se
znaménkem (signed). V&nbsp;tìchto pøípadech se namísto pøíznakových bitù
<i>carry</i> a <i>zero</i> testují kombinace bitù <i>negative</i>,
<i>overflow</i> a <i>zero</i>:</p>

<table>
<tr><th>Kód</td><th>Pøípona</th><th>Význam</th><th>Testovaná podmínka</th></tr>
<tr><td>1010</td><td>GE</td><td>N and V the same</td><td>&gt;=</td></tr>
<tr><td>1011</td><td>LT</td><td>N and V differ  </td><td>&lt;</td></tr>
<tr><td>1100</td><td>GT</td><td>Z clear, N == V </td><td>&gt;</td></tr>
<tr><td>1101</td><td>LE</td><td>Z set, N != V   </td><td>&lt;=</td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Demonstraèní pøíklad: pou¾ití podmínìného spou¹tìní instrukcí</h2>

<p>Pojïme si nyní ukázat, jak je mo¾né pou¾ít podmínkové kódy v&nbsp;praxi.
Následující demonstraèní pøíklad byl získán pøímo z&nbsp;materiálù dodávaných
k&nbsp;mikroprocesorùm <i>ARM</i>, tak¾e je jisté, ¾e byl vybrán s&nbsp;ohledem
na to, aby dobøe ilustroval pou¾ití podmínkových kódù a markantní rozdíl
v&nbsp;délce programu i délce jeho trvání (v&nbsp;praxi jsou tyto rozdíly
ponìkud men¹í). Pøíklad pøedstavuje céèkovskou funkci urèenou pro výpoèet
nejvìt¹ího spoleèného dìlitele dvou 32bitových hodnot. Algoritmus pro výpoèet
nejvìt¹ího spoleèného dìlitele lze v&nbsp;céèku zapsat následovnì:</p>

<pre>
int gcd(int a, int b)
{
    while (a != b) do
    {
        if (a &gt; b)
        {
            a = a - b;
        }
        else
        {
            b = b - a;
        }
    }
    return a;
}
</pre>

<p>Pokud by tento algoritmus byl pøelo¾en do assembleru s&nbsp;vyu¾itím
klasicky pojatých podmínìných skokù, mohl by výsledek vypadat následovnì.
Instrukce <strong>CMP</strong> porovná dva pracovní registry obsahující obì
hodnoty, pro nì¾ se poèítá nejvìt¹í spoleèný dìlitel. Na základì tohoto
porovnání se vykoná buï &bdquo;vìtev if&ldquo; nebo &bdquo;vìtev else&ldquo;,
co¾ ov¹em znamená, ¾e se v&nbsp;ka¾dé iteraci musí vykonat dvì instrukce
podmínìných skokù (<strong>BEQ, BLT</strong>) a jedna instrukce skoku
nepodmínìného (<strong>B</strong>):</p>

<pre>
gcd     CMP      r0, r1      ; porovnání registrù r0 a r1
        BEQ      end         ; pokud r0 == r1, konec smyèky
        BLT      less        ; skok kdy¾ r0 je men¹í ne¾ r1
        SUB      r0, r0, r1  ; tìlo "if"
        B        gcd         ; dal¹í iterace
less
        SUB      r1, r1, r0  ; tìlo "else"
        B        gcd         ; dal¹í iterace
end
</pre>

<p>Naproti tomu optimalizující pøekladaè mù¾e vý¹e uvedený program pøelo¾it
pouze do ètyø instrukcí, pøièem¾ obì prostøední instrukce jsou vykonány pouze
pøi splnìní zadané podmínky (viz suffix uvedený u jména instrukce):</p>

<pre>
gcd
        CMP      r0, r1      ; porovnání registrù r0 a r1
        SUBGT    r0, r0, r1  ; rozdíl jen v pøípadì, ¾e r0 byl vìt¹í ne¾ r1
        SUBLT    r1, r1, r0  ; rozdíl jen v pøípadì, ¾e r1 byl vìt¹í ne¾ r0
        BNE      gcd         ; pokud r0 != r1, skok na zaèátek smyèky
</pre>

<p>Vzhledem k&nbsp;tomu, ¾e v¹echny instrukce mají konstantní ¹íøku 32 bitù,
odpovídá zkrácení programu v&nbsp;assembleru (poèet u¹etøených øádkù) pøímo
úmìrnì i zkrácení výsledného strojového programu a souèasnì i jeho rychlej¹ímu
bìhu, proto¾e provedení podmínìného skoku vede k&nbsp;pozastavení instrukèní
pipeline na tøi takty:</p>

<table>
<tr><th>Program</th><th>Instrukcí</th><th>Bajtù</th></tr>
<tr><td>A</td><td>7</td><td>28</td></tr>
<tr><td>B</td><td>4</td><td>16</td></tr>
</table>

<p>Poznamenejme, ¾e v&nbsp;pøípadì pou¾ití instrukèní sady <i>Thumb</i> lze
pùvodní program se sedmi instrukcemi zkrátit na 14 bajtù, a to díky tomu, ¾e se
pro ka¾dou instrukci pou¾ije pouze 16 bitù.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>An Introduction to ARM Assembly Language<br />
<a href="http://dev.emcelettronica.com/introduction-to-arm-assembly-language">http://dev.emcelettronica.com/introduction-to-arm-assembly-language</a>
</li>

<li>Processors - ARM<br />
<a href="http://www.arm.com/products/processors/index.php">http://www.arm.com/products/processors/index.php</a>
</li>

<li>The ARM Instruction Set<br />
<a href="http://simplemachines.it/doc/arm_inst.pdf">http://simplemachines.it/doc/arm_inst.pdf</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ARM_architecture">http://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>BBC BASIC<br />
<a href="http://www.bbcbasic.co.uk/bbcbasic.html">http://www.bbcbasic.co.uk/bbcbasic.html</a>
</li>

<li>BBC BASIC<br />
<a href="http://mdfs.net/Software/BBCBasic/">http://mdfs.net/Software/BBCBasic/</a>
</li>

<li>BBC BASIC (Z80) for the ZX Spectrum<br />
<a href="http://mdfs.net/Software/BBCBasic/Spectrum/">http://mdfs.net/Software/BBCBasic/Spectrum/</a>
</li>

<li>BBC BASIC (Wikipedia CZ)<br />
<a href="http://en.wikipedia.org/wiki/BBC_BASIC">http://en.wikipedia.org/wiki/BBC_BASIC</a>
</li>

<li>MIPS-3D(r) ASE<br />
<a href="http://www.mips.com/products/architectures/mips-3d-ase/">http://www.mips.com/products/architectures/mips-3d-ase/</a>
</li>

<li>An introduction to SPARC's SIMD offerings<br />
<a href="http://mikeburrell.wordpress.com/2007/12/14/an-introduction-to-sparcs-simd-offerings/">http://mikeburrell.wordpress.com/2007/12/14/an-introduction-to-sparcs-simd-offerings/</a>
</li>

<li>MIPS64<sup>TM</sup> Architecture for Programmers Volume IV-c: The MIPS-3D<sup>TM</sup> Application-Specific Extension to the MIPS64<sup>TM</sup><br />
<a href="http://www.weblearn.hs-bremen.de/risse/RST/docs/MIPS/MD00099-2B-MIPS3D64-AFP-01.11.pdf">http://www.weblearn.hs-bremen.de/risse/RST/docs/MIPS/MD00099-2B-MIPS3D64-AFP-01.11.pdf</a>
</li>

<li>Visual Instruction Set<br />
<a href="http://www.enotes.com/topic/Visual_Instruction_Set">http://www.enotes.com/topic/Visual_Instruction_Set</a>
</li>

<li>NEON<br />
<a href="http://www.arm.com/products/processors/technologies/neon.php">http://www.arm.com/products/processors/technologies/neon.php</a>
</li>

<li>Architecture and Implementation of the ARM Cortex-A8 Microprocessor<br />
<a href="http://www.design-reuse.com/articles/11580/architecture-and-implementation-of-the-arm-cortex-a8-microprocessor.html">http://www.design-reuse.com/articles/11580/architecture-and-implementation-of-the-arm-cortex-a8-microprocessor.html</a>
</li>

<li>Multimedia Acceleration eXtensions (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Multimedia_Acceleration_eXtensions">http://en.wikipedia.org/wiki/Multimedia_Acceleration_eXtensions</a>
</li>

<li>AltiVec (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AltiVec">http://en.wikipedia.org/wiki/AltiVec</a>
</li>

<li>Visual Instruction Set (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Visual_Instruction_Set">http://en.wikipedia.org/wiki/Visual_Instruction_Set</a>
</li>

<li>MAJC (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/MAJC">http://en.wikipedia.org/wiki/MAJC</a>
</li>

<li>MDMX (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/MDMX">http://en.wikipedia.org/wiki/MDMX</a>
</li>

<li>MIPS Multiply Unit<br />
<a href="http://programmedlessons.org/AssemblyTutorial/Chapter-14/ass14_3.html">http://programmedlessons.org/AssemblyTutorial/Chapter-14/ass14_3.html</a>
</li>

<li>Silicon Graphics Introduces Enhanced MIPS Architecture<br />
<a href="http://bwrc.eecs.berkeley.edu/CIC/otherpr/enhanced_mips.html">http://bwrc.eecs.berkeley.edu/CIC/otherpr/enhanced_mips.html</a>
</li>

<li>MIPS-3D (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/MIPS-3D">http://en.wikipedia.org/wiki/MIPS-3D</a>
</li>

<li>MIPS Technologies, Inc. announces new MIPS-3D technology to provide silicon-efficient 3D graphics acceleration<br />
<a href="http://www.design-reuse.com/news/2057/mips-mips-3d-technology-silicon-efficient-3d-graphics-acceleration.html">http://www.design-reuse.com/news/2057/mips-mips-3d-technology-silicon-efficient-3d-graphics-acceleration.html</a>
</li>

<li>MIPS-3D Built-in Function (gcc.gnu.org)<br />
<a href="http://gcc.gnu.org/onlinedocs/gcc/MIPS_002d3D-Built_002din-Functions.html">http://gcc.gnu.org/onlinedocs/gcc/MIPS_002d3D-Built_002din-Functions.html</a>
</li>

<li>Baha Guclu Dundar:<br />
Intel MMX, SSE, SSE2, SSE3/SSSE3/SSE4 Architectures
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>Tour of the Black Holes of Computing!: Floating Point<br />
<a href="http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt">http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt</a>
</li>

<li>3Dnow! Technology Manual<br />
AMD Inc., 2000</li>

<li>Intel MMX<sup>TM</sup> Technology Overview<br />
Intel corporation, 1996</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>AMD K5 ("K5" / "5k86")<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g5K5-c.html">http://www.pcguide.com/ref/cpu/fam/g5K5-c.html</a>
</li>

<li>Sixth Generation Processors<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g6.htm">http://www.pcguide.com/ref/cpu/fam/g6.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Very_long_instruction_word">http://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>Control unit (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Control_unit">http://en.wikipedia.org/wiki/Control_unit</a>
</li>

<li>Cray History<br />
<a href="http://www.cray.com/About/History.aspx?404;http://www.cray.com:80/about_cray/history.html">http://www.cray.com/About/History.aspx?404;http://www.cray.com:80/about_cray/history.html</a>
</li>

<li>Cray Historical Timeline<br />
<a href="http://www.cray.com/Assets/PDF/about/CrayTimeline.pdf">http://www.cray.com/Assets/PDF/about/CrayTimeline.pdf</a>
</li>

<li>Computer Speed Claims 1980 to 1996<br />
<a href="http://homepage.virgin.net/roy.longbottom/mips.htm">http://homepage.virgin.net/roy.longbottom/mips.htm</a>
</li>

<li>Superpoèítaèe Cray<br />
<a href="http://www.root.cz/clanky/superpocitace-cray/">http://www.root.cz/clanky/superpocitace-cray/</a>
</li>

<li>Superpoèítaèe Cray (druhá èást)<br />
<a href="http://www.root.cz/clanky/superpocitace-cray-druha-cast/">http://www.root.cz/clanky/superpocitace-cray-druha-cast/</a>
</li>

<li>Superpoèítaèe Cray (tøetí èást)<br />
<a href="http://www.root.cz/clanky/superpocitace-cray-treti-cast/">http://www.root.cz/clanky/superpocitace-cray-treti-cast/</a>
</li>

<li>Superpoèítaèe Cray (ètvrtá èást)<br />
<a href="http://www.root.cz/clanky/superpocitace-cray-ctvrta-cast/">http://www.root.cz/clanky/superpocitace-cray-ctvrta-cast/</a>
</li>

<li>Superpoèítaèe Cray (pátá èást): architektura Cray X-MP<br />
<a href="http://www.root.cz/clanky/superpocitace-cray-pata-cast-architektura-pocitace-cray-x-mp-a-jeho-pouziti-ve-filmovem-prumyslu/">http://www.root.cz/clanky/superpocitace-cray-pata-cast-architektura-pocitace-cray-x-mp-a-jeho-pouziti-ve-filmovem-prumyslu/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

