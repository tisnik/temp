<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Instrukèní sada Thumb-2 u mikroprocesorù ARM</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Instrukèní sada Thumb-2 u mikroprocesorù ARM</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;dne¹ní èásti seriálu o architekturách poèítaèù si popí¹eme dal¹í alternativní instrukèní sadu, kterou jsou vybaveny novìj¹í modely mikroprocesorù ARM. Jedná se o instrukèní sadu pojmenovanou Thumb-2, která byla navr¾ena takovým zpùsobem, aby co nejlep¹ím zpùsobem spojila pøednosti jak pùvodní RISCové 32bitové instrukèní sady, tak i 16bitové sady Thumb.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Instrukèní sada Thumb-2 u mikroprocesorù ARM</a></p>
<p><a href="#k02">2. Dùvody vedoucí ke vzniku instrukèní sady Thumb-2</a></p>
<p><a href="#k03">3. Thumb-2 v&nbsp;porovnání s&nbsp;pùvodní instrukèní sadou ARM a sadou Thumb</a></p>
<p><a href="#k04">4. Naplnìní registru ¹estnáctibitovou konstantou, naplnìní horní poloviny registru</a></p>
<p><a href="#k05">5. Operace s&nbsp;bitovými poli ulo¾enými v&nbsp;registrech</a></p>
<p><a href="#k06">6. Instrukce pro otoèení v¹ech bitù v&nbsp;pracovním registru</a></p>
<p><a href="#k07">7. Instrukce Compare and branch if (non) zero</a></p>
<p><a href="#k08">8. Prefixová instrukce If-Then</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Instrukèní sada Thumb-2 u mikroprocesorù ARM</h2>

<p>V&nbsp;dne¹ní èásti <a
href="http://www.root.cz/serialy/co-se-deje-v-pocitaci/">seriálu o
architekturách poèítaèù</a> se ji¾ po¹esté budeme zabývat popisem
mikroprocesorù s&nbsp;architekturou <i>ARM</i>. Dnes se zamìøíme pøedev¹ím na
instrukèní sadu <i>Thumb-2</i>, kterou je mo¾né pova¾ovat za sadu, která se
v&nbsp;sobì sna¾í sdru¾it jak pøednosti pùvodní 32bitové &bdquo;RISCové&ldquo;
instrukèní sady <i>ARM</i>, tak i pøednosti ¹estnáctibitové instrukèní sady
<i>Thumb</i>. Nová instrukèní sada <i>Thumb-2</i> díky tomu na jedné stranì
dosahuje jak velké hustoty kódu (<i>code density</i>), tak i velkého
výpoèetního výkonu (viz té¾ <a href="#k03">tøetí kapitolu</a>). Zmínìný
výpoèetní výkon dosahovaný v&nbsp;reálných aplikacích byl u sady <i>Thumb</i>
v&nbsp;nìkterých pøípadech men¹í, proto¾e mnohé operace musely být provedeny
pomocí vìt¹ího mno¾ství instrukcí &ndash; instrukce <i>Thumb</i> toti¾ v¾dy
vykonávaly jen jednu operaci, na rozdíl od instrukcí <i>ARM</i>, které
obsahovaly jak podmínkové bity, tak i v&nbsp;mnoha pøípadech
&bdquo;podoperaci&ldquo; pro bitový posun èi rotaci jednoho z&nbsp;operandù
vstupujícího do aritmeticko-logické jednotky.</p>

<p>Sami konstruktéøi mikroprocesorù <i>ARM</i> se vyjádøili k&nbsp;tomu,
z&nbsp;jakého dùvodu vlastnì instrukèní sada <i>Thumb-2</i> vznikla. Pøi jejím
návrhu mìli na mysli ètyøi parametry, které se navzájem ovlivòují a vylep¹ení
jednoho z&nbsp;parametrù vìt¹inou v&nbsp;dùsledku vede ke zhor¹ení zbývajících
tøech parametrù. Jedná se o následující parametry:</p>

<ol>

<li>Cenu vlastního procesoru, která je kromì jiných okolností ovlivnìna i jeho
slo¾itostí (existence branch prediktorù, spekulativního provádìní instrukcí,
...), poètem aritmeticko-logických jednotek (obecnì zda jde o skalární èi
superskalární procesor), velikostí potøebných vyrovnávacích pamìtí atd.</li>

<li>Dosahovaný výpoèetní výkon v&nbsp;<strong>reálných</strong> aplikacích.
V&nbsp;praxi to znamená, ¾e hodnota udávaná v&nbsp;jednotkách MIPS nebo MFLOPS
nemusí být v¾dy smìrodatná: je to právì pøíklad jednodu¹¹ích instrukcí
<i>Thumb</i> v&nbsp;porovnání s&nbsp;obecnì výkonnìj¹ími instrukcemi
<i>ARM</i>.</li>

<li>Nutný energetický pøíkon procesoru (závisí na technologii výroby, napájecím
napìtí, hodinové frekvenci, poètu ALU, velikosti vyrovnávacích pamìti
atd.).</li>

<li>Cenu za vývoj a optimalizaci aplikací (tu ovlivòuje slo¾itost instrukèní
sady, nedostatky v&nbsp;instrukèní sadì: napøíklad nutnost provádìní
neefektivních skokù, slo¾itost pøi naèítání konstant do pracovních registrù
atd.).</li>

</ol>



<p><a name="k02"></a></p>
<h2 id="k02">2. Dùvody vedoucí ke vzniku instrukèní sady Thumb-2</h2>

<p>Za pov¹imnutí stojí pøedev¹ím skuteènost, ¾e snaha o vylep¹ení jednoho
parametru zmínìného <a href="#k01">v&nbsp;pøedchozí kapitole</a> skuteènì ve
vìt¹inì pøípadù vede ke zhor¹ení ostatních parametrù. Napøíklad zvý¹ení
výpoèetního výkonu pomocí vìt¹ích vyrovnávacích pamìtích ovlivní jak cenu
mikroprocesoru, tak i energetický pøíkon atd. Zajímavý je ale pøedev¹ím význam
posledního parametru: cena za vývoj a optimalizaci aplikací. Pøi zavádìní
instrukèní sady <i>Thumb</i> (zde bez dvojky) se toti¾ pøedpokládalo, ¾e
vìt¹ina kódu bude pøekládána právì do této sady, co¾ zmen¹í poèet výpadkù
vyrovnávacích pamìtí pro srovnatelný program (binární kód), a jen pøibli¾nì
deset procent kritických èástí kódu bude napsáno s&nbsp;vyu¾itím instrukcí
<i>ARM</i> (jedná se tedy o aplikaci známého pravidla 90:10 èi 80:20). To sice
mù¾e na první pohled velmi dobøe fungovat, ov¹em zji¹tìní, které jsou vlastnì
ony kritické èásti kódu, se muselo mnohdy provádìt a¾ v&nbsp;pozdních fázích
vývoje, co¾ vedlo mj.&nbsp;i k&nbsp;rostoucí cenì za vývoj (i kdy¾ popravdì
øeèeno se to týká skuteènì onìch èástí kódu, s&nbsp;nimi¾ si nìkdo dal tu práci
a optimalizoval je ruènì s&nbsp;vyu¾itím výsledkù získaných napøíklad
z&nbsp;<i>profileru</i>).</p>

<p>Navíc není pøepínání mezi instrukcemi <i>ARM</i> a <i>Thumb</i> zcela
&bdquo;zadarmo&ldquo;, co¾ ponìkud zmen¹uje mo¾nosti neustálého pøepínání,
tak¾e se hledal zpùsob, jak stávající stav je¹tì vylep¹it. Výsledkem této snahy
je instrukèní sada nazvaná <i>Thumb-2</i>. Její vznik byl umo¾nìn postupným
vylep¹ováním technologie výroby integrovaných obvodù (zjednodu¹enì øeèeno tím,
¾e bylo mo¾né na èipu implementovat vìt¹í mno¾ství tranzistorù bez razantního
nárùstu ceny a/nebo spotøeby) a navíc byl &bdquo;vynucen&ldquo; tím, ¾e se
stále zvìt¹oval rozdíl mezi rychlostí mikroprocesorù a dobou pøístupu
k&nbsp;pamìtem DRAM. Cílem tedy byl men¹í binární kód (instrukce s&nbsp;vìt¹í
hustotou) a souèasnì stále dobrá výkonnost dosa¾ená tím, ¾e ne v¹echny
instrukce <i>Thumb-2</i> jsou tak jednoduché èi jednoúèelové, jako instrukce
<i>Thumb</i>.</p>

<p><ins>Poznámka: na tomto místì je mo¾ná vhodné poznamenat, ¾e i instrukèní
sada <i>Thumb-2</i> odpovídá charakteru RISCových mikroprocesorù, na nich¾ je
implementována, tj.&nbsp;stále se jedná o instrukèní sadu s&nbsp;operacemi
provádìnými pøedev¹ím nad pracovními registry, pouze s&nbsp;omezenou mo¾ností
pøístupu do pamìti pøes instrukce typu Load &amp; Store a s&nbsp;jednoduchými
adresovacími re¾imy.</ins></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Thumb-2 v&nbsp;porovnání s&nbsp;pùvodní instrukèní sadou ARM a sadou Thumb</h2>

<p>Dùvodù pro vznik nové instrukèní sady tedy bylo více ne¾ dost, tak¾e se
podívejme na to, co se jejím tvùrcùm podaøilo splnit a co nikoli.
V&nbsp;následujícím textu budou uvedeny výsledky mìøení prezentované samotnou
spoleèností <i>ARM</i>. V&nbsp;první tabulce je porovnána &bdquo;hustota&ldquo;
binárního strojového kódu mìøená jeho délkou. Ve v¹ech pøípadech se jednalo o
stejný algoritmus, který byl poprvé implementován s&nbsp;vyu¾itím instrukèní
sady <i>ARM</i>, podruhé s&nbsp;pomocí sady <i>Thumb</i> a potøetí byla pou¾ita
instrukèní sada <i>Thumb-2</i>. Za základ je pøitom brána délka pùvodního kódu
pou¾ívajícího instrukce <i>ARM</i> (tento kód odpovídá sto procentùm, èím men¹í
èíslo, tím men¹í je i výsledný binární program):</p>

<table>
<tr><th>Instrukèní sada</th><th>Délka kódu</th></tr>
<tr><td>ARM    </td><td>100%</td></tr>
<tr><td>Thumb  </td><td> 70%</td></tr>
<tr><td>Thumb-2</td><td> 74%</td></tr>
</table>

<p>Ve druhé tabulce je uveden relativní výpoèetní výkon pøelo¾eného binárního
programu, pøièem¾ 100% odpovídá nejrychlej¹í implementaci a 75% implementaci
nejpomalej¹í:</p>

<table>
<tr><th>Instrukèní sada</th><th>Relativní výpoèetní výkon</th></tr>
<tr><td>ARM    </td><td>100%</td></tr>
<tr><td>Thumb  </td><td> 75%</td></tr>
<tr><td>Thumb-2</td><td> 98%</td></tr>
</table>

<p>Z&nbsp;výsledkù, které jsou prezentovány v&nbsp;pøede¹lých dvou tabulkách
tedy vyplývá, ¾e pro testovanou aplikaci se díky pou¾ití instrukèní sady
<i>Thumb-2</i> podaøilo zmen¹it velikost kódu na tøi ètvrtiny pùvodní velikosti
a pøitom výpoèetní výkon poklesl pouze o zhruba 2% (zde se samozøejmì projevila
i ni¾¹í pravdìpodobnost výpadku instrukèní cache, která ov¹em byla ni¾¹í i u
implementace vyu¾ívající instrukce <i>Thumb</i>).</p>

<p><ins>Poznámka: jako u v¹ech podobných mìøení je samozøejmì nutné mít na
pamìti, ¾e se jedná pouze o (reprezentativní) vzorek, který mù¾e ale takté¾
nemusí odpovídat jinému typu algoritmu. V¾dy zále¾í jen na konkrétní aplikaci,
konkrétním vývojáøi, jeho rozpoètu a èasu, zda si podobné mìøení udìlá i
v&nbsp;pøípadì jím vyvíjené aplikace, nebo zda se spolehne na cizí statistiku
:-) (to ov¹em platí i pro výbìr procesoru: opìt zále¾í na mnoha okolnostech,
vèetnì dosavadních zku¹eností vývojáøe, cenì za vývojové nástroje
atd.).</ins></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Naplnìní registru ¹estnáctibitovou konstantou, naplnìní horní poloviny registru</h2>

<p>Tvùrci instrukèní sady <i>Thumb-2</i> navrhli a implementovali celou øadu
zcela nových instrukcí, které mj.&nbsp;odstraòovaly nìkteré nedostatky
pùvodních instrukèních sad <i>Thumb</i> a <i>ARM</i>. Ji¾ nìkolikrát jsme se
napøíklad zmínili o problematice naètení konstanty do pracovního registru.
V&nbsp;instrukèní sadì <i>Thumb-2</i> jsou ji¾ stávající mo¾nosti práce
s&nbsp;konstantami roz¹íøeny o dvì nové varianty instrukce
<strong>MOV</strong>. Pøipomeòme si, ¾e programátoøi mìli k&nbsp;dispozici
obyèejnou instrukci <strong>MOV</strong> pracující s&nbsp;osmibitovou
konstantou, která mohla být posunuta v&nbsp;<i>barrel shifteru</i> a takté¾
instrukci <strong>MVN</strong>, která navíc konstantu negovala. Pou¾ití pouhé
osmibitové konstanty (i kdy¾ posunuté) v¹ak v&nbsp;mnoha pøípadech
nedostaèovalo, proto se musely konstanty ukládat pøímo do programového kódu
(napøíklad za subrutinu) s&nbsp;tím, ¾e se pro adresování tìchto konstant
pou¾íval registr <strong>PC</strong> s&nbsp;vhodným offsetem. Nejedná se o
úplnì ¹patné øe¹ení, nicménì stále vy¾aduje minimálnì 64 bitù (32 bitù pro
instrukci, 32 bitù pro konstantu).</p>

<p>Aby se velikost pamìti potøebné pro ulo¾ení programu zmen¹ila, nabízí
instrukèní sada <i>Thumb-2</i> navíc je¹tì instrukci <strong>MOVW</strong>
(<i>move wide</i>), která ve svém instrukèním slovu obsahuje plnou
¹estnáctibitovou konstantu. Tato konstanta je ulo¾ena do spodní poloviny
zvoleného cílového registru (bity 0 a¾ 15) s&nbsp;tím, ¾e horní polovina
registru (bity 16 a¾ 31) je vynulována. Této instrukci sekunduje instrukce
<strong>MOVT</strong> (<i>move top</i>), která ve svém instrukèním slovu takté¾
obsahuje ¹estnáctibitovou konstantu, ov¹em tato konstanta je pøenesena do horní
poloviny zvoleného cílového registru (bity 16 a¾ 31), pøièem¾ jeho dolní
polovina (bity 0 a¾ 15) zùstává nezmìnìna. V&nbsp;mnoha pøípadech postaèuje
pou¾ít pouze instrukci <strong>MOVW</strong>, která se v&nbsp;assembleru
zapisuje obecnou mnemotechnickou zkratkou <strong>MOV</strong> (konkrétní
instrukèní slovo vybere sám assembler). Pøi nutnosti naètení plné 32bitové
konstanty lze vyu¾ít dvojici <strong>MOVW+MOVT</strong> s&nbsp;tím, ¾e se díky
lokalitì kódu (konstanta je ulo¾ena souèasnì s&nbsp;instrukcemi) sní¾í
pravdìpodobnost výpadku instrukèní vyrovnávací pamìti.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Operace s&nbsp;bitovými poli ulo¾enými v&nbsp;registrech</h2>

<p>Mikroprocesory <i>ARM</i> nabízí vývojáøùm celou øadu aritmetických,
logických i bitových instrukcí. Kromì klasických instrukcí pro souèet a rozdíl
byly postupnì pøidány i instrukce pro souèet a rozdíl se saturací (tj.&nbsp;bez
pøeteèení výsledku), souèet a rozdíl po bajtech èi slovech, rùzné typy násobení
atd. U <i>ARMv5</i> byla navíc pøidána i zajímavá instrukce
<strong>CLZ</strong> (<i>Count Leading Zeros</i>), která vrátila poèet nul
ulo¾ených na zaèátku vybraného zdrojového registru. Podobnì je tomu u logických
a bitových instrukcí. Mohlo by se tedy znát, ¾e nabídka tohoto typu instrukcí
je vlastnì úplná a bude postaèovat pro v¹echny potøeby programátorù. Ve
skuteènosti v¹ak v&nbsp;praxi nastávají situace, kdy je nutné manipulovat pouze
s&nbsp;vybraným bitovým polem (sekvencí bitù) ulo¾eným v&nbsp;pracovním
registru. Pøedstavme si napøíklad situaci, kdy se zpracovává bitmapa,
v&nbsp;ní¾ jsou jednotlivé pixely ulo¾eny systémem <i>hi-color</i>,
tj.&nbsp;napøíklad následovnì: <i>RRRRRGGGGGGBBBBB</i> (¹estnáct bitù na pixel,
z&nbsp;toho pìt bitù pro èervenou slo¾ku, ¹est bitù pro slo¾ku zelenou a pìt
bitù pro slo¾ku modrou).</p>

<p>Pokud je programátor èi pøekladaè postaven pøed nutnost pracovat
s&nbsp;takto ulo¾enými daty, musí vìt¹inou pou¾ít instrukce pro bitové posuny
zkombinované s&nbsp;instrukcemi pro maskování èi selektivní nastavení nìkterých
bitù (AND, OR, XOR). V&nbsp;instrukèní sadì <i>Thumb-2</i> v¹ak mù¾e pou¾ít i
ètveøici nových instrukcí nazvaných <strong>BFC</strong>, <strong>BFI</strong>,
<strong>SBFX</strong> a <strong>UBFX</strong>. První z&nbsp;tìchto instrukcí
<strong>BFC</strong> získala svoji mnemotechnickou zkratku ze sousloví <i>Bit
Field Clear</i>. Tato instrukce skuteènì umo¾òuje vynulovat bitovou oblast
v&nbsp;registru, která je specifikovaná svým zaèátkem (indexem nejni¾¹ího bitu
v&nbsp;oblasti) a ¹íøkou. Obì zmínìné konstanty &ndash; zaèátek bitové oblasti
a její ¹íøka &ndash; jsou pøitom souèástí instrukèního slova.</p>

<p>Dal¹í tøi instrukce jsou ji¾ ponìkud slo¾itìj¹í, proto¾e pracují
s&nbsp;dvojicí registrù: zdrojovým registrem a registrem cílovým. Instrukce
<strong>BFI</strong> (<i>Bit Field Insert</i>) slou¾í k&nbsp;vlo¾ení <i>n</i>
nejni¾¹ích bitù zdrojového registru do registru cílového, pøièem¾ lze zvolit,
od kterého bitu se vkládání bude provádìt (obsah dal¹ích bitù mimo zvolené
bitové pole zùstane nezmìnìn). Instrukce <strong>SBFX</strong> (<i>Signed Bit
Field Extract</i>) a <strong>UBFX</strong> (<i>Unsigned Bit Field Extract</i>)
mají opaèný význam: naètení vybraného bitového pole ze zdrojového registru a
jeho ulo¾ení do registru cílového s&nbsp;pøípadným znaménkovým roz¹íøením.</p>

<p><ins>Poznámka: mo¾ná by se mohlo zdát, ¾e se jedná o pomìrnì slo¾ité
instrukce (u¾ jejich popis je slo¾itìj¹í ne¾ dejme tomu konstatování, ¾e se
&bdquo;provede souèet dvou registrù&ldquo;), nicménì jejich implementace je i
díky existenci <i>barrel shifteru</i> ve skuteènosti velmi jednoduchá a tím
pádem i vyhovující filozofii RISC.</ins></p>

<p>Podívejme se na jednoduchý pøíklad. Instrukce:</p>

<pre>
BFI r0, r1, #bitpos, #bitwidth
</pre>

<p>by se musela implementovat pomocí tøech jiných instrukcí, které navíc musí
vyu¾ívat dal¹í pomocný pracovní registr:</p>

<pre>
AND r2, r1, #bitwidth                  ; pracujeme pouze s #bitwidth nejni¾¹ími bity
BIC r0, r0, #bitwidth &lt;&lt; bitpos
ORR r0, r0, r2, LSL #bitpos            ; posun druhého operandu na správnou pozici
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Instrukce pro otoèení v¹ech bitù v&nbsp;pracovním registru</h2>

<p>Pøipomeòme si, ¾e mikroprocesory s&nbsp;architekturou <i>ARM</i> se
pou¾ívaly a dodnes pou¾ívají v&nbsp;mnoha aplikaèních oblastech. Jednou
z&nbsp;tìchto oblastí je i vyu¾ití tìchto mikroprocesorù pro zpracování signálù
(<i>DSP &ndash; Digital Signal Processing/Processor</i>). V&nbsp;této oblasti
je mo¾né vyu¾ít napøíklad ji¾ zmínìné sèítání a odèítání se saturací doplnìné
mnoha typy instrukcí pro násobení. V&nbsp;oblasti zpracování signálù se takté¾
velmi èasto implementuje algoritmus rychlé Fourierovy transformace  (<i>FFT
&ndash; Fast Fourier Transform</i>) popø.&nbsp;témìø identický algoritmus
zpìtné rychlé Fourierovy transformace (<i>IFFT &ndash; Inverse Fast Fourier
Transform</i>). Jedna z&nbsp;implementací tohoto algoritmu vy¾aduje pou¾ít pøi
adresaci prvkù v&nbsp;poli index získaný <i>reverzací bitù</i>,
tj.&nbsp;prohozením v¹ech bitù v&nbsp;pracovním registru (b0 &lt;&gt; b31, b1
&lt;&gt; b30 ... b15 &lt;&gt; b16). Tato zdánlivì jednoduchá operace se v¹ak
musí provádìt buï pomocí vhodné tabulky nebo s&nbsp;vyu¾itím vìt¹ího mno¾ství
instrukcí, co¾ je v&nbsp;obou pøípadech pomìrnì neefektivní.</p>

<p>Instrukce, která tuto reverzaci bitù provádí, se jmenuje pøíhodnì
<strong>RBIT</strong>. Tato instrukce vyu¾ívá dva pracovní registry jako
operandy. Prvním operandem je zdrojový registr <strong>Rm</strong> a druhým
operandem registr cílový <strong>Rd</strong>. Popis operace provádìné instrukcí
<strong>RBIT</strong> by mohl být zapsán následovnì (i kdy¾ se ve skuteènosti
samozøejmì ¾ádná smyèka neprovádí, proto¾e celá reverzace je zále¾itostí
jednoho taktu):</p>

<pre>
for (i = 0; i &lt; 32; i++)
{
    Rd[i] = Rm[31 - i]
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Instrukce Compare and branch if (non) zero</h2>

<p>I dal¹í instrukce, s&nbsp;nimi¾ se dnes seznámíme, vznikly takovým zpùsobem,
¾e tvùrci instrukèní sady <i>Thumb-2</i> analyzovali reálné potøeby
programátorù.  V¹imli si, ¾e se v&nbsp;programech velmi èasto vyskytuje
sekvence instrukcí, které nejdøív porovnají obsah vybraného pracovního registru
s&nbsp;nulou a posléze provedou podmínìný skok na základì toho, zda je onen
pracovní registr skuteènì nulový nebo naopak nenulový. Pomìrnì velké frekvenci
této sekvence instrukcí se nelze ani divit, proto¾e podobným zpùsobem mohou být
implementovány napøíklad testy na hodnotu <strong>NULL</strong>, poèítané
smyèky, smyèky typu <strong>do-while</strong> v&nbsp;nich¾ je pravdivostní
hodnota vyjádøena celým èíslem, práce s&nbsp;ASCIIZ øetìzci atd. Aby bylo mo¾né
zmen¹it velikost binárního kódu programu a souèasnì ho i urychlit, byly do
instrukèní sady <i>Thumb-2</i> pøidány dvì nové instrukce, které nejprve
provedou porovnání pracovního registru s&nbsp;nulou a poté provedou skok, pokud
je registr nulový èi naopak není nulový. Souèástí instrukèního slova je pøitom
i krátký offset umo¾òující provést skok do vzdálenosti PC+4 a¾ PC+130.</p>

<p>První z&nbsp;tìchto instrukcí provede skok, pokud je vybraný pracovní
registr nulový:</p>

<pre>
CBZ Rn, offset   ; compare and branch if zero
</pre>

<p>Druhá instrukce provádí skok v&nbsp;pøesnì opaèném pøípadì, tj.&nbsp;tehdy,
kdy¾ má registr nenulovou hodnotu:</p>

<pre>
CBNZ Rn, offset   ; compare and branch if non zero
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Prefixová instrukce If-Then</h2>

<p>Z&nbsp;minulého a pøedminulého dílu tohoto seriálu ji¾ víme, ¾e
z&nbsp;instrukèní sady <i>Thumb</i> byly mj.&nbsp;odstranìny i podmínkové bity,
pomocí nich¾ bylo mo¾né specifikovat, za jakých podmínek (kombinací
pøíznakových bitù) se má daná operace provést. To je tro¹ku ¹koda, proto¾e
právì díky podmínkovým bitùm bylo mo¾né eliminovat nìkteré operace skoku, které
jsou v&nbsp;mnoha ohledech problematické. Tvùrci instrukèní sady <i>Thumb-2</i>
si toho byli vìdomi a proto do této sady pøidali jednu z&nbsp;nejzajímavìj¹ích
instrukcí, které kdy pro RISCové mikroprocesory vznikly. Jedná se vlastnì o
instrukèní prefix nazvaný <strong>IT</strong> podle sousloví <i>if-then</i>.
Tento prefix mù¾e být aplikován na jednu a¾ ètyøi instrukce následující za
prefixem. Ihned za prefixem <strong>IT</strong> se (bez mezery) udává, zda má
být daná instrukce provedena pøi splnìní podmínky (<strong>T</strong> &ndash;
<i>then</i>) èi naopak pøi jejím nesplnìní (<strong>E</strong> &ndash;
<i>else</i>). U první instrukce je automaticky pøedpokládáno
<strong>T</strong>, tudí¾ se uvádí maximálnì tøi znaky T/E. Samozøejmì je
takté¾ nutné zapsat i testovanou podmínku &ndash; mù¾e se jednat o kódy
pou¾ívané jak u podmínìných skokù, tak i v&nbsp;podmínkových bitech:</p>

<table>
<tr><th>Kód</th><th>Význam</th><th>Pøedchozí operace porovnání</th></tr>
<tr><td>EQ</td><td>Z==1 (rovno)</td><td>signed i unsigned</td></tr>
<tr><td>NE</td><td>Z==0 (nerovno)</td><td>signed i unsigned</td></tr>
<tr><td>CS</td><td>C==1 (vìt¹í nebo rovno)</td><td>unsigned</td></tr>
<tr><td>CC</td><td>C==0 (men¹í ne¾)</td><td>unsigned</td></tr>
<tr><td>MI</td><td>N==1 (záporný výsledek)</td><td>signed</td></tr>
<tr><td>PL</td><td>N==0 (kladný nebo nulový výsledek)</td><td>signed</td></tr>
<tr><td>VS</td><td>V==1 (pøeteèení)</td><td>signed</td></tr>
<tr><td>VC</td><td>V==0 (nedo¹lo k pøeteèení)</td><td>signed</td></tr>
<tr><td>HI</td><td>C==1 &amp; Z==0 (vet¹í ne¾)</td><td>unsigned</td></tr>
<tr><td>LS</td><td>C==0 | Z==1 (men¹í nebo rovno)</td><td>unsigned</td></tr>
<tr><td>GE</td><td>N==V (vìt¹í nebo rovno)</td><td>signed</td></tr>
<tr><td>LT</td><td>N!=V (men¹í ne¾)</td><td>signed</td></tr>
<tr><td>GT</td><td>Z==0 &amp; N==V (vìt¹í ne¾)</td><td>signed</td></tr>
<tr><td>LE</td><td>Z==1 N!=V (men¹í nebo rovno)</td><td>signed</td></tr>
</table>

<p>V&nbsp;praxi to mù¾e znamenat, ¾e zápis:</p>

<pre>
ITEEE EQ
</pre>

<p>znaèí, ¾e pokud je nastaven pøíznak <i>zero</i> (rovnost), je provedena jen
první instrukce následující za prefixem, kde¾to dal¹í tøi instrukce nebudou
provedeny (tøikrát &bdquo;else&ldquo;).</p>

<p>Pokud by se mìly provést tøi instrukce v&nbsp;pøípadì kladného výsledku
pøedchozího porovnání, pou¾il by se zápis:</p>

<pre>
ITTT PL
</pre>

<p>Porovnejme si nyní tøi identické algoritmy. První z&nbsp;nich je
implementovaný s&nbsp;vyu¾itím instrukcí <i>ARM</i> s&nbsp;podmínkovými
bity:</p>

<pre>
        LDREQ r0,[r1]      ; if EQ then LDR
        LDRNE r0,[r2]      ; if NE then LDR
        ADDEQ r0, r3, r0   ; if EQ then ADD
        ADDNE r0, r4, r0   ; if NE then ADD
</pre>

<p>V&nbsp;pøípadì pou¾ití instrukèní sady <i>Thumb</i> musíme vyu¾ít podmínìné
skoky se v¹emi nepøíjemnostmi, které z&nbsp;toho plynou:</p>

<pre>
        BNE L1             ; opaèná podmínka - pøeskoèení instrukce
        LDR r0, [r1]
        ADD r0, r3, r0     ; máme ¹tìstí: mù¾eme prohodit poøadí instrukcí
        B L2
L1                         
        LDR r0, [r2]
        ADD r0, r4, r0
L2
</pre>

<p>U instrukèní sady <i>Thumb-2</i> lze v&nbsp;tomto pøípadu s&nbsp;výhodou
pou¾ít prefixovou instrukci <strong>IT</strong>:</p>

<pre>
        ITETE EQ
        LDR r0, [r1]
        LDR r0, [r2]
        ADD r0, r3, r0
        ADD r0, r4, r0
</pre>

<p>Na závìr si je¹tì v¹echny tøi implementace pro zajímavost porovnáme, a to
jak z&nbsp;hlediska velikosti programového kódu, tak i z&nbsp;hlediska celkové
doby trvání výpoètu:</p>

<table>
<tr><th>Instrukèní sada</th><th>Velikost kódu</th><th>Poèet cyklù</th></tr>
<tr><td>ARM (RISC)</td><td>16 bajtù</td><td>4 cykly</td></tr>
<tr><td>Thumb     </td><td>12 bajtù</td><td>4-20 cyklù</td></tr>
<tr><td>Thumb-2   </td><td>10 bajtù</td><td>4-5 cyklù</td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Improving ARM Code Density and Performance<br />
<a href="New Thumb Extensions to the ARM Architecture Richard Phelan">New Thumb Extensions to the ARM Architecture Richard Phelan</a>
</li>

<li>The ARM Processor Architecture<br />
<a href="http://www.arm.com/products/processors/technologies/instruction-set-architectures.php">http://www.arm.com/products/processors/technologies/instruction-set-architectures.php</a>
</li>

<li>Thumb-2 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html</a>
</li>

<li>Introduction to ARM thumb<br />
<a href="http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb">http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb</a>
</li>

<li>ARM, Thumb, and ThumbEE instruction sets<br />
<a href="http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm">http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm</a>
</li>

<li>An Introduction to ARM Assembly Language<br />
<a href="http://dev.emcelettronica.com/introduction-to-arm-assembly-language">http://dev.emcelettronica.com/introduction-to-arm-assembly-language</a>
</li>

<li>Processors - ARM<br />
<a href="http://www.arm.com/products/processors/index.php">http://www.arm.com/products/processors/index.php</a>
</li>

<li>The ARM Instruction Set<br />
<a href="http://simplemachines.it/doc/arm_inst.pdf">http://simplemachines.it/doc/arm_inst.pdf</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ARM_architecture">http://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>BBC BASIC<br />
<a href="http://www.bbcbasic.co.uk/bbcbasic.html">http://www.bbcbasic.co.uk/bbcbasic.html</a>
</li>

<li>BBC BASIC<br />
<a href="http://mdfs.net/Software/BBCBasic/">http://mdfs.net/Software/BBCBasic/</a>
</li>

<li>BBC BASIC (Z80) for the ZX Spectrum<br />
<a href="http://mdfs.net/Software/BBCBasic/Spectrum/">http://mdfs.net/Software/BBCBasic/Spectrum/</a>
</li>

<li>BBC BASIC (Wikipedia CZ)<br />
<a href="http://en.wikipedia.org/wiki/BBC_BASIC">http://en.wikipedia.org/wiki/BBC_BASIC</a>
</li>

<li>MIPS-3D(r) ASE<br />
<a href="http://www.mips.com/products/architectures/mips-3d-ase/">http://www.mips.com/products/architectures/mips-3d-ase/</a>
</li>

<li>An introduction to SPARC's SIMD offerings<br />
<a href="http://mikeburrell.wordpress.com/2007/12/14/an-introduction-to-sparcs-simd-offerings/">http://mikeburrell.wordpress.com/2007/12/14/an-introduction-to-sparcs-simd-offerings/</a>
</li>

<li>MIPS64<sup>TM</sup> Architecture for Programmers Volume IV-c: The MIPS-3D<sup>TM</sup> Application-Specific Extension to the MIPS64<sup>TM</sup><br />
<a href="http://www.weblearn.hs-bremen.de/risse/RST/docs/MIPS/MD00099-2B-MIPS3D64-AFP-01.11.pdf">http://www.weblearn.hs-bremen.de/risse/RST/docs/MIPS/MD00099-2B-MIPS3D64-AFP-01.11.pdf</a>
</li>

<li>Visual Instruction Set<br />
<a href="http://www.enotes.com/topic/Visual_Instruction_Set">http://www.enotes.com/topic/Visual_Instruction_Set</a>
</li>

<li>NEON<br />
<a href="http://www.arm.com/products/processors/technologies/neon.php">http://www.arm.com/products/processors/technologies/neon.php</a>
</li>

<li>Architecture and Implementation of the ARM Cortex-A8 Microprocessor<br />
<a href="http://www.design-reuse.com/articles/11580/architecture-and-implementation-of-the-arm-cortex-a8-microprocessor.html">http://www.design-reuse.com/articles/11580/architecture-and-implementation-of-the-arm-cortex-a8-microprocessor.html</a>
</li>

<li>Multimedia Acceleration eXtensions (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Multimedia_Acceleration_eXtensions">http://en.wikipedia.org/wiki/Multimedia_Acceleration_eXtensions</a>
</li>

<li>AltiVec (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AltiVec">http://en.wikipedia.org/wiki/AltiVec</a>
</li>

<li>Visual Instruction Set (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Visual_Instruction_Set">http://en.wikipedia.org/wiki/Visual_Instruction_Set</a>
</li>

<li>MAJC (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/MAJC">http://en.wikipedia.org/wiki/MAJC</a>
</li>

<li>MDMX (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/MDMX">http://en.wikipedia.org/wiki/MDMX</a>
</li>

<li>MIPS Multiply Unit<br />
<a href="http://programmedlessons.org/AssemblyTutorial/Chapter-14/ass14_3.html">http://programmedlessons.org/AssemblyTutorial/Chapter-14/ass14_3.html</a>
</li>

<li>Silicon Graphics Introduces Enhanced MIPS Architecture<br />
<a href="http://bwrc.eecs.berkeley.edu/CIC/otherpr/enhanced_mips.html">http://bwrc.eecs.berkeley.edu/CIC/otherpr/enhanced_mips.html</a>
</li>

<li>MIPS-3D (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/MIPS-3D">http://en.wikipedia.org/wiki/MIPS-3D</a>
</li>

<li>MIPS Technologies, Inc. announces new MIPS-3D technology to provide silicon-efficient 3D graphics acceleration<br />
<a href="http://www.design-reuse.com/news/2057/mips-mips-3d-technology-silicon-efficient-3d-graphics-acceleration.html">http://www.design-reuse.com/news/2057/mips-mips-3d-technology-silicon-efficient-3d-graphics-acceleration.html</a>
</li>

<li>MIPS-3D Built-in Function (gcc.gnu.org)<br />
<a href="http://gcc.gnu.org/onlinedocs/gcc/MIPS_002d3D-Built_002din-Functions.html">http://gcc.gnu.org/onlinedocs/gcc/MIPS_002d3D-Built_002din-Functions.html</a>
</li>

<li>Baha Guclu Dundar:<br />
Intel MMX, SSE, SSE2, SSE3/SSSE3/SSE4 Architectures
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>

<li>Intel MMX<sup>TM</sup> Technology Overview<br />
Intel corporation, 1996</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>AMD K5 ("K5" / "5k86")<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g5K5-c.html">http://www.pcguide.com/ref/cpu/fam/g5K5-c.html</a>
</li>

<li>Sixth Generation Processors<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g6.htm">http://www.pcguide.com/ref/cpu/fam/g6.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Very_long_instruction_word">http://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>Tour of the Black Holes of Computing!: Floating Point<br />
<a href="http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt">http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt</a>
</li>

<li>3Dnow! Technology Manual<br />
AMD Inc., 2000</li>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>Control unit (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Control_unit">http://en.wikipedia.org/wiki/Control_unit</a>
</li>

<li>Cray History<br />
<a href="http://www.cray.com/About/History.aspx?404;http://www.cray.com:80/about_cray/history.html">http://www.cray.com/About/History.aspx?404;http://www.cray.com:80/about_cray/history.html</a>
</li>

<li>Cray Historical Timeline<br />
<a href="http://www.cray.com/Assets/PDF/about/CrayTimeline.pdf">http://www.cray.com/Assets/PDF/about/CrayTimeline.pdf</a>
</li>

<li>Computer Speed Claims 1980 to 1996<br />
<a href="http://homepage.virgin.net/roy.longbottom/mips.htm">http://homepage.virgin.net/roy.longbottom/mips.htm</a>
</li>

<li>Superpoèítaèe Cray<br />
<a href="http://www.root.cz/clanky/superpocitace-cray/">http://www.root.cz/clanky/superpocitace-cray/</a>
</li>

<li>Superpoèítaèe Cray (druhá èást)<br />
<a href="http://www.root.cz/clanky/superpocitace-cray-druha-cast/">http://www.root.cz/clanky/superpocitace-cray-druha-cast/</a>
</li>

<li>Superpoèítaèe Cray (tøetí èást)<br />
<a href="http://www.root.cz/clanky/superpocitace-cray-treti-cast/">http://www.root.cz/clanky/superpocitace-cray-treti-cast/</a>
</li>

<li>Superpoèítaèe Cray (ètvrtá èást)<br />
<a href="http://www.root.cz/clanky/superpocitace-cray-ctvrta-cast/">http://www.root.cz/clanky/superpocitace-cray-ctvrta-cast/</a>
</li>

<li>Superpoèítaèe Cray (pátá èást): architektura Cray X-MP<br />
<a href="http://www.root.cz/clanky/superpocitace-cray-pata-cast-architektura-pocitace-cray-x-mp-a-jeho-pouziti-ve-filmovem-prumyslu/">http://www.root.cz/clanky/superpocitace-cray-pata-cast-architektura-pocitace-cray-x-mp-a-jeho-pouziti-ve-filmovem-prumyslu/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

