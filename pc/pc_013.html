<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Techniky zvý¹ení výpoèetního výkonu mikroprocesorù 3</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Techniky zvý¹ení výpoèetního výkonu mikroprocesorù 3</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dne¹ní èásti seriálu o èinnosti poèítaèù se opìt budeme zabývat nìkterými technikami, které se pou¾ívají pro zvý¹ení výkonu mikroprocesorù nebo celých procesorových systémù. Øekneme si základní informace jak o urychlení èinnosti jednoho mikroprocesoru, tak i zpùsobech paralelního zapojení procesorù.</p>



<h1>Obsah</h1>
<p>
<a href="#k01">1. Spekulativní provádìní instrukcí (<i>speculative execution</i>)</a><br />
<a href="#k02">2. Provádìní instrukcí mimo poøadí (<i>out of order execution</i>)</a><br />
<a href="#k03">3. Masivnì paralelní architektury</a><br />
<a href="#k04">4. Transputery</a><br />
<a href="#k05">5. Architektura NUMA a servery Origin 200/2000</a><br />
<a href="#k06">6. Topologie sítì u serverù Origin 200/2000</a><br />
<a href="#k07">7. Architektura Onyx2 - Infinite Reality</a><br />
</p>



<p><a name="k01"></a></p>
<h1>1. Spekulativní provádìní instrukcí (<i>speculative execution</i>)</h1>

<p>V&nbsp;pøedchozí èásti tohoto seriálu jsme si popsali jeden z&nbsp;velmi
èasto pou¾ívaných zpùsobù vedoucích k&nbsp;urychlení vykonávání smyèek a
podmínìných pøíkazù (tyto vy¹¹í jazykové konstrukce jsou u vìt¹iny
mikroprocesorù pøekládány na podmínìné skoky, popø.&nbsp;podmínìné pøesuny).
Jednalo se o technologii <i>predikce skokù</i> (<i>branch prediction</i>). Ta
je prakticky na v¹ech skalárních i superskalárních architekturách v¾dy doplnìna
o takzvané <i>spekulativní provádìní instrukcí</i>, neboli <i>speculative
execution</i>, proto¾e zvy¹uje efekt prediktoru na sní¾ení èasu potøebného pro
vykonání programu. Základní my¹lenka této techniky je pomìrnì jednoduchá: ve
chvíli, kdy nám prediktor skokù &bdquo;pøedpoví&ldquo;, zda bude podmínìný skok
proveden èi nikoli, je mo¾né zaèít do instrukèní pipeline vkládat instrukce,
které se nachází &ndash; samozøejmì podle výsledku pøedpovìdi &ndash; buï pøímo
za instrukcí skoku (prediktor pøedpoví, ¾e se skok neprovede) èi naopak
v&nbsp;místì, do kterého skok smìøuje (prediktor pøedpoví, ¾e skok bude
proveden).</p>

<p>V&nbsp;pøípadì, ¾e prediktor krokù skuteènì pøedpoví správný výsledek skoku,
jsou ji¾ v&nbsp;pipeline èásteènì èi úplnì zpracovány instrukce, které se mají
skuteènì provést a <i>cena za skok</i> (udávaná v&nbsp;poètu hodinových cyklù
èi zpo¾dìním) je minimalizována. Ov¹em ve chvíli, kdy se prediktor splete (co¾
bývá v&nbsp;cca dvou procentech pøípadù v&nbsp;závislosti na tvaru programu,
pou¾itém prediktoru i dal¹ích vlivech), musí se tyto pøedzpracované instrukce
z&nbsp;instrukèní pipeline odstranit, vèetnì zaji¹tìní jejich vlivu na
pøíznakové bity èi obsah pracovních registrù. V&nbsp;tomto pøípadì je cena za
skok velká; v&nbsp;praxi se mù¾e jednat i o nìkolik desítek taktù, které
mikroprocesor stráví tím, ¾e vyprázdní instrukèní pipeline, obnoví v¹echny
pracovní registry (z&nbsp;takzvaných <i>registrù stínových, shadow
registers</i>) a do vyprázdnìné instrukèní pipeline zaène naèítat nyní u¾
známou sekvenci instrukcí. Èím vìt¹í poèet øezù má instrukèní pipeline, tím
více je její vyprazdòování nároèné.</p>

<p>Uka¾me si chování prediktorù skokù i spekulativního provádìní instrukcí na
jednoduchém pøíkladu napsaném v&nbsp;jazyku symbolických instrukcí
(assembleru). Pøedpokládejme, ¾e ná¹ &bdquo;uèebnicový&ldquo; mikroprocesor,
který byl podrobnì popsán v&nbsp;pøedchozích èástech tohoto seriálu (viz odkazy
za koncem èlánku), má instrukèní pipeline, je¾ doká¾e pøedzpracovat celkem
ètyøi instrukce a také obsahuje jednobitový prediktor skokù a technologii pro
spekulativní provádìní instrukcí. Co se za tìchto podmínek stane pøi provádìní
následujícího programu pro hodnoty <strong>ZACATEK=0</strong> a
<strong>KONEC=10</strong>?</p>

<code-area>; jednoduchá poèítaná smyèka typu "for"
        LD A, ZACATEK          ; poèáteèní hodnota smyèky
        LD B, KONEC            ; koncová hodnota smyèky

SMYCKA  pøíkaz x1              ; libovolné instrukce, jejich¾ celková
        pøíkaz x2              ; délka musí být men¹í ne¾ cca 120 bytù
        pøíkaz x3              ; (kvùli omezení relativního skoku)
        INC A                  ; zvý¹ení poèitadla smyèky o jednièku
        CMP A,B
        JNZ SMYCKA             ; pøíznak "Zerro flag" se nastaví pøi rovnosti A a B

        pøíkaz y1              ; libovolné instrukce provedené a¾ po ukonèení smyèky
        pøíkaz y2
        pøíkaz y3
</code-area>

<p>Jednobitové prediktory skokù jsou vìt¹inou konstruovány tak, ¾e v&nbsp;první
fázi (kdy daný skok je¹tì nebyl ani jednou spu¹tìn) preferují skoky smìrem
vzad, proto¾e pro smyèky je typická právì tato konstrukce. Tj.&nbsp;pøi prvním
prùchodu smyèkou se je¹tì pøed vyhodnocením podmínky skoku zaènou do pipeline
znovu naèítat instrukce <strong>x1</strong>, <strong>x2</strong> a
<strong>x3</strong>. Po provedení instrukce porovnání (<strong>CMP
A,B</strong>) ji¾ mikroprocesor bezpeènì ví, ¾e byl prediktor skokù úspì¹ný a
skuteènì danou sekvenci instrukcí provede.</p>

<p>Po deseti opakováních smyèky v¹ak nastane pøípad, kdy je hodnota pracovního
registru <strong>A</strong> rovna deseti a tím pádem instrukce <strong>CMP
A,B</strong> nastaví pøíznak <strong>Zerro flag</strong> na logickou jednièku,
co¾ vede k&nbsp;<strong>NE</strong>provedení skoku a opu¹tìní smyèky. To ov¹em
prediktor skokù nemù¾e vìdìt a stále (na základì své pøedchozí zku¹enosti,
kterou si pamatuje v&nbsp;jednom bitu) procesoru tvrdí, ¾e mù¾e do pipeline
naèítat instrukce <strong>x1</strong>, <strong>x2</strong> a
<strong>x3</strong>. To se ov¹em uká¾e jako mylné, proto musí být tyto
instrukce odstranìny a do pipeline se naopak zaènou naèítat instrukce
<strong>y1</strong>, <strong>y2</strong> a <strong>y3</strong>.</p>



<p><a name="k02"></a></p>
<h1>2. Provádìní instrukcí mimo poøadí (<i>out of order execution</i>)</h1>

<p>Velmi úèinnou technikou vedoucí ke sní¾ení cyklù mikroprocesoru, ve kterých
se ¾ádná èinnost neprovádí, spoèívá v&nbsp;takzvaném provádìní instrukcí mimo
poøadí (<i>out of order</i>). U klasických <i>in order</i> mikroprocesorù,
které mají instrukèní pipeline, nastává situace, ve které musí následující
instrukce èekat na provedení instrukce pøedchozí, vìt¹inou z&nbsp;toho dùvodu,
¾e pøedchozí instrukce modifikuje nìjaký pracovní registr èi pøíznak, který
následující instrukce potøebuje ke svému zdárnému provedení. To samozøejmì
znamená ne¾ádoucí zdr¾ení, proto¾e se nevyu¾ijí v¹echny cykly mikroprocesoru.
V&nbsp;pøípadì architektury <i>out of order</i> v¹ak není nic ztraceno, proto¾e
je mo¾né zaèít provádìt nìjakou jinou instrukci, u ní¾ je zaruèeno, ¾e pou¾ívá
jiné pracovní registry a pøíznaky (popø.&nbsp;je mo¾né pou¾ít stínové pracovní
registry). Internì se øazení instrukcí provádí na základì jejich ukládání do
instrukèní fronty (nazývané také <i>rezervaèní stanice</i>), ze které jsou
instrukce vybírány ve chvíli, kdy jsou známy hodnoty jejich operandù.</p>

<p>Opìt se mù¾eme podívat na pøíklad, i kdy¾ ponìkud umìlý, proto¾e ná¹
uèebnicový mikroprocesor obsahuje pouze dva pracovní registry (zde by bylo
zavedení technologie out of order pravdìpodobnì pouze plýtváním plochou èipu
resp.&nbsp;tranzistory). Následující kód je provádìn pomìrnì pomalu, proto¾e
ka¾dá instrukce ve ètveøici musí èekat na výsledek instrukce pøedchozí a tím
pádem není vyu¾ita instrukèní pipeline:</p>

<code-area>
LD  A, [adresa_x]
RL  A
XOR A, 0x7f
ST  A, [adresa_y]

LD  B, [adresa_z]
INC B
COM B
ST  B, [adresa_w]
</code-area>

<p>Kvalitní out of order technologie by rozpoznala, ¾e se nikde nevyu¾ívají
pøíznaky <strong>Zerro flag</strong> a <strong>Carry flag</strong>, tak¾e je
mo¾né dynamicky pøeskládat instrukce napøíklad do následující podoby (spojeny
jsou v¾dy ty instrukce, které na sebe nemusí èekat):</p>

<code-area>
LD  A, [adresa_x]
LD  B, [adresa_z]

RL  A
INC B

XOR A, 0x7f
COM B

ST  A, [adresa_y]
ST  B, [adresa_w]
</code-area>

<p>Zde je nutné poznamenat, ¾e tuto úpravu kódu by mìl provést ji¾ pøekladaè,
který má na podobné optimalizaèní metody vìt¹inou dostatek èasu. Pro co
nejlep¹í vyu¾ití instrukèní pipeline je dùle¾ité, aby co nejvíce instrukcí
mohlo být provádìno souèasnì èi témìø souèasnì. To lze zajistit pøedev¹ím
velkým mno¾stvím pracovních registrù (32 a 64 u RISC procesorù jsou obvyklá
èísla), kvalitním pøekladaèem, který tyto registry vyu¾ije a sní¾í tak riziko
závislosti mezi instrukcemi a také odstranìním tìch stavových informací, které
jsou pro v¹echny instrukce spoleèné a které závisejí na konkrétním poøadí
provádìní instrukcí &ndash; vìt¹inou se jedná o pøíznakové bity. Z&nbsp;tohoto
dùvodu nejsou napøíklad u mikroprocesorù promy¹lené architektury
<strong>MIPS</strong> pøíznakové bity vùbec pou¾ity; jeho podmínìné skoky se
tak do znaèné míry blí¾í pøíkazu <strong>if</strong> známému z&nbsp;prakticky
v¹ech vy¹¹ích imperativních programovacích jazykù.</p>



<p><a name="k03"></a></p>
<h1>3. Masivnì paralelní architektury</h1>

<p>Vícejádrové mikroprocesory typu <strong>Core Duo</strong>
pøedstavují pomìrnì významný krok pro vytvoøení paralelní architektury i na
bì¾ných a cenovì dostupných desktopových poèítaèích, ov¹em v&nbsp;jejich návrhu
se (alespoò prozatím) nepou¾ily takové technologie, které by umo¾nily vývoj
skuteèných masivnì paralelních architektur s&nbsp;nìkolika desítkami a¾
stovkami jader (popravdì øeèeno by v¹ak dne¹ní aplikace na takových
architekturách nebì¾ely pøíli¹ efektivnì). Úzkým místem, které &ndash;
samozøejmì v&nbsp;pøípadì, ¾e se technologie firem Intel a AMD výraznì nezmìní
&ndash; zabraòuje zvý¹ení poètu jader nad cca 8, je systém vyrovnávacích
pamìtí, existence jediného rozhraní k&nbsp;centrální operaèní pamìti a
v&nbsp;neposlední øadì také to, ¾e dal¹í zaøízení jsou pøipojována na jedinou
sbìrnici.</p>

<p>Kvùli tomu je ostatnì také výraznì limitován poèet prakticky pøipojitelných
zaøízení, ani ne tak z&nbsp;hlediska technických charakteristik sbìrnice
(zatí¾ení výstupù a z&nbsp;toho plynoucí zkreslení signálù, odrazy signálù na
konci fyzicky dlouhé sbìrnice), jako spí¹e výrazného zpomalení a¾ znemo¾nìní
práce vìt¹ího mno¾ství zaøízení, které musí být obslou¾eny tak, aby nedo¹lo ke
ztrátì dat (sí»ové rozhraní, disky) èi nereagování na nìjaký neodkladný
po¾adavek (u¾ivatel by tì¾ko akceptoval napøíklad vynechání zvukového
výstupu).</p>

<p>Ukazuje se, ¾e pøi datových pøenosech mezi vìt¹ím mno¾stvím uzlù pomocí
propojovací sítì, hraje rozhodující úlohu topologie sítì a ménì ji¾ její bitová
¹íøka èi rychlost, jak tomu bývá u spoleèných sbìrnic. Proto se u výkonných
systémù i grafických stanic setkáváme s&nbsp;rùznými druhy pou¾itých topologií
propojovacích sítí, které mohou být buï pevnì zadané a nemìnné (èasto se k
tomuto úèelu pou¾ívá møí¾ka, krychle, hyperkrychle, torus, hypertorus atd.),
nebo se topologie naopak mohou v&nbsp;závislosti na potøebách bì¾ících aplikací
dynamicky mìnit pomocí programovatelných pøepínaèù (to èásteènì odpovídá i
architektuøe <strong>Connection Machine</strong>).</p>

<p>Masivnì paralelní systémy, které mohou obsahovat napøíklad a¾ 65536
relativnì samostatnì pracujících a spolu komunikujících mikroprocesorù, musí
být sestaveny zcela odli¹ným zpùsobem. Pravdìpodobnì nejvýraznìj¹ím rozdílem je
opu¹tìní koncepce jediné centrální sbìrnice a v&nbsp;mnoha pøípadech také
jediné operaèní pamìti, proto¾e tato dvì místa by tvoøila úzké hrdlo celé
architektury, které by zpùsobilo to, ¾e by mikroprocesory neustále èekaly na
ètení èi zápis dat. Místo sbìrnice (tj.&nbsp;lineární topologické struktury) je
pou¾ita nìjaká obecnìj¹í struktura, napøíklad v&nbsp;nejjednodu¹¹ím pøípadì
møí¾ka, dále pak hyperkostka (kostka zobecnìná do <i>n</i> dimenzí), toroid
(møí¾ka, její¾ okrajové uzly jsou spojeny s&nbsp;protilehlými uzly), "tlustý"
binární strom (blízko koøenu je pou¾ito více datových cest, ne¾
v&nbsp;blízkosti listù) atd. U v¹ech tìchto topologických struktur jsou hrany
pøedstavovány datovými linkami a uzly mikroprocesory s&nbsp;vyrovnávací pamìtí,
smìrovaèem (<i>router</i>) a nìkdy také èástí operaèní pamìti, která je sdílena
mezi jednotlivými uzly.</p>

<p>I periferní zaøízení jsou umístìna v&nbsp;uzlech, co¾ mimo jiné znamená, ¾e
mohou komunikovat mezi sebou (pøes ostatní uzly, resp.&nbsp;jejich smìrovaèe).
U nìkterých masivnì paralelních architektur se topologie celé struktury
automaticky mìní tak, aby odpovídala zpracovávanému programu.</p>

<p>Pøíkladem masivnì paralelní architektury jsou u¾ minule zmínìné systémy
<i>Connection Machine</i>, pøedev¹ím CM-5 zalo¾ená na topologii &bdquo;tlustého
&ldquo; binárního stromu, která mù¾e obsahovat a¾ 65536 mikroprocesorù.</p>



<p><a name="k04"></a></p>
<h1>4. Transputery</h1>

<p>Výpoèetní systémy zalo¾ené na transputerech nebyly nikdy komerènì pøíli¹
úspì¹né. Jedním z&nbsp;dùvodù bylo ¹patné naèasování jejich jednotlivých typù
(cenovì výhodnìj¹í osmibitové mikroøadièe na jednom konci a výkonné RISC na
konci druhém), dal¹ím dùvodem to, ¾e s&nbsp;pøíchodem architektury RISC a
technologií spekulativního vykonávání instrukcí, paralelismu øízeného øadièem,
superskalární architekturou apod. mikroprocesory úspì¹nì pøekonaly urèitou
krizi v&nbsp;rùstu výpoèetního výkonu a pøedev¹ím bylo nutné pro transputery
volit odli¹né metody programování, zatímco napøíklad u superskalárních
mikroprocesorù paralelismus (i kdy¾ na mnohem ni¾¹í úrovni) øe¹il pøekladaè
v&nbsp;souèinnosti s&nbsp;øadièem. Také pou¾ití extrémnì jednoduchých èipù pro
tvorbu transputerù se ukázalo jako ne pøíli¹ vhodné, proto¾e dnes velkou roli
v&nbsp;cenì èipu hraje i jeho pouzdro, vývody a zpùsob zapojení do základní
desky. Mnohdy bylo ekonomicky výhodnìj¹í pou¾ít velmi výkonný jednojádrový
mikroprocesor ne¾ pro stejnou úlohu vyu¾ít napøíklad ¹estnáct mnohem
jednodu¹¹ích transputerù. Jak v¹ak uvidíme v&nbsp;dal¹ích kapitolách, my¹lenka
transputerù byla pou¾ita i ve zcela odli¹ných systémech.</p>

<image id="6403" />
<p-center>Atari ABAQ s&nbsp;transputery mìlo být konkurencí k&nbsp;pracovním stanicím Sun</p-center>

<p>V&nbsp;minulosti se velké nadìje vkládaly do takzvaných <i>transputerù</i>, co¾ jsou
(zjednodu¹enì øeèeno) mikroøadièe, které na jednom èipu obsahují i komunikaèní
rozhraní schopné se pøipojit k&nbsp;dal¹ím ètyøem a¾ tøiceti dvìma sousedním
transputerùm. Dùle¾ité je, ¾e pøímo v&nbsp;instrukèní sadì transputerù jsou
obsa¾eny instrukce pro komunikaci se sousedními uzly a i celý program obsahuje
velké mno¾ství implicitnì èi explicitnì zadaných &bdquo;komunikaèních&ldquo;
operací. Poèet uzlù se mù¾e v&nbsp;závislosti na struktuøe poèítaèe pohybovat
od nìkolika desítek a¾ do nìkolika tisíc. Typickým programovacím jazykem pro
transputery je <strong>occaml</strong>, který obsahuje jak instrukce pro
komunikaci mezi jednotlivými uzly (<strong>?</strong> a <strong>!</strong>),
tak i konstrukci pro paralelní provádìní pøíkazù.</p>

<image id="6404" />



<p><a name="k05"></a></p>
<h1>5. Architektura NUMA a servery Origin 200/2000</h1>

<p>Firma <strong>Silicon Graphics Inc.</strong> (SGI) byla pøedním
výrobcem výpoèetních systémù postavených na architektuøe <strong>NUMA</strong>.
Název této architektury pochází z celého oznaèení <strong>Non-Uniform Memory
Access</strong>, èím¾ je naznaèeno, jakým zpùsobem je provedeno vzájemné
uspoøádání procesorù a operaèní pamìti.</p>

<p>Architektura <strong>NUMA</strong> byla vytvoøena za úèelem propojení
velkého mno¾ství procesorù, které mezi sebou musí urèitým zpùsobem sdílet data.
Pøi malém mno¾ství procesorù je mo¾né pou¾ít takzvaný symetrický
multiprocessing &ndash; <strong>SMP</strong>, kdy existuje pouze jedna hlavní pamì» a
procesory na tuto pamì» pøistupují pøes vhodnou propojovací strukturu, která
obsahuje i arbitr. Na bázi <strong>SMP</strong> jsou vystavìny i
víceprocesorové osobní poèítaèe a jednodu¹¹í servery (vèetnì
<strong>Core Duo</strong> a spol.). V¾dy se v¹ak jedná o propojení dvojic,
maximálnì ètveøic procesorù, rozumný limit je osm jader. Blokové schéma
architektury <strong>SMP</strong> je naznaèeno na dal¹ím obrázku.</p>

<image id="6405" original="no" />
<p-center>Blokové schéma architektury SMP</p-center>

<p>Architektura <strong>SMP</strong> je pomìrnì jednoduchá, proto je také
snadná její implementace. Potí¾e v¹ak nastávají pøi pøipojení více procesorù.
U¾ pøi ètyøech souèasnì bì¾ících procesorech se ukazuje, ¾e propojovací
struktura se stává úzkým hrdlem této architektury, proto¾e i pøes mnohdy
velikou kapacitu pamìtí cache nastávají kolize pøi pøístupu do hlavní pamìti,
kdy na sebe jednotlivé procesory musí èekat (blí¾e viz <i>Amdahlùv zákon</i>).</p>

<p>Tuto vá¾nou nevýhodu odstraòuje architektura <strong>NUMA</strong>, která
zavádí místo jednoduché lineární propojovací struktury slo¾itìj¹í topologie,
jako je møí¾ka, krychle, hyperkrychle, torus nebo hypertorus. V&nbsp;uzlech této
topologické sítì se nacházejí jednotlivé procesory, operaèní pamì» (je zde
pou¾ito obecnìj¹í schéma <strong>DSM</strong> &ndash; Distributed Shared Memory &ndash;
distribuovaná sdílená pamì», tak¾e operaèní pamì» je rozdìlena mezi jednotlivé
uzly) a dal¹í zaøízení, mimo jiné i grafický akcelerátor èi grafické
akcelerátory. Ty jsou z tohoto hlediska zcela rovnocenné procesorùm, na rozdíl
od architektury PC.</p>

<p>U serverù <strong>Origin 200/2000</strong> je pou¾ita mírná modifikace uzlù,
ve kterých je místo jednoho procesoru zapojena v¾dy dvojice procesorù. Ke
ka¾dému procesoru pøinále¾í i nìkolik cache pamìtí &ndash; instrukèní cache pamì» (na
dal¹ím obrázku je oznaèena symbolem <strong>I-c</strong>), datová cache pamì»
(na obrázku je oznaèena symbolem <strong>D-c</strong>) a èást sdílené pamìti
(oznaèena symbolem <strong>S-cache</strong>). Blokové scéma jednoho uzlu
pou¾itého u serverù <strong>Origin</strong> je zobrazeno na následujícím
obrázku.</p>

<image id="6406" original="no" />
<p-center>Jeden uzel serveru Origin 200/2000</p-center>



<p><a name="k06"></a></p>
<h1>6. Topologie sítì u serverù Origin 200/2000</h1>

<p>U serverù <strong>Origin 200/2000</strong> se pro propojování jednotlivých
uzlù pou¾ívá topologie sítì zalo¾ená na hyperkrychli
(<strong>hypercube</strong>). Hyperkrychle vzniká zobecnìním plo¹ného ètverce
èi prostorové krychle do obecnì libovolného poètu dimenzí. Ve vrcholu plo¹ného
ètverce se stýkají dvì hrany, ve vrcholu tøírozmìrné krychle tøi hrany, ve
vrcholu hyperkrychle ve ètyøech dimenzích ètyøi hrany atd. Podle poètu uzlù je
vhodnì zvolena dimenze hyperkrychle (1&ndash;7), která se v&nbsp;bì¾ných pøípadech
pohybuje od dvou uzlù do 128 uzlù. Tento poèet sice nepøedstavuje teoretické
maximum, ale s&nbsp;dal¹ím pøidáváním uzlù se pomìrnì znaèným zpùsobem zvy¹uje poèet
hran, které se stýkají v&nbsp;jednom vrcholu hyperkrychle, èím¾ se také prodlu¾uje
pøedávání dat mezi jednotlivými uzly (slo¾ité routování dat).</p>

<p>Na dal¹ím obrázku je ukázána propojovací topologie hyperkrychle pro nìkolik
základních konfigurací serverù <strong>Origin 200/2000</strong>. Ka¾dý uzel na
obrázku pøitom obsahuje dva procesory se svými cache pamì»mi.</p>

<p>Velkou výhodou pou¾ité propojovací topologie a návrhu uzlù u serverù
<strong>Origin</strong>, je vysoká ¹kálovatelnost, která umo¾òuje efektivní
pou¾ití a¾ nìkolika set procesorù. Tyto procesory se mohou vyu¾ít napøíklad pro
vykreslování trojrozmìrných scén metodou <strong>raytracingu</strong>, nebo»
tato metoda je takøka ideálnì paralelizovatelná (samozøejmì a¾ na rostoucí
pamì»ovou slo¾itost). Dal¹í èasto pou¾ívanou mo¾ností je pøipojení nìkolika
grafických akcelerátorù pro urychlení vykreslování trojrozmìrné grafiky
v&nbsp;hranièní reprezentaci, èi pou¾ití tìchto systémù pro také relativnì
snadno paralelizovatelné úlohy typu &bdquo;lámání ¹ifer&ldquo;.</p>

<image id="6407" original="no" />
<p-center>Propojovací topologie hyperkrychle pou¾ité u serverù Origin 200/2000</p-center>



<p><a name="k07"></a></p>
<h1>7. Architektura Onyx2 - Infinite Reality</h1>

<p>Výkonné grafické pracovní stanice firmy <a
href="http://www.sgi.com/">SGI</a> postavené na systému <strong>Infinite
Reality</strong>, nebo jejím pokraèovateli <strong>Infinite Reality 2</strong>,
se vyznaèují zejména masivním vyu¾itím paralelismu &ndash; ostatnì mnoho algoritmù v
poèítaèové grafice je mo¾né paralelizovat velmi dobøe, a¾ na zvy¹ující se
pamì»ové nároky (vícenásobné kopie vstupních dat, nìkolik paralelních
framebufferù atd.).</p>

<image id="6408" />

<p>Systémy postavené na IR mohou obsahovat a¾ 128 procesorù
oblíbené produktové øady MIPS R10000. Zde je patrný rozdíl oproti èasto
srovnávané architektury s&nbsp;transputery (èi dokonce CM-5), která sice pou¾ívá
mnohem více procesorù, ale tyto procesory jsou &ndash; alespoò v porovnání s MIPS
R10000 &ndash; velmi jednoduché. V&nbsp;pøípadì architektury <strong>Onyx2</strong> se
jedná o stejné procesory, jaké jsou pou¾ity i v serverech <strong>Origin
200/2000</strong>, tato øada procesorù je v¹ak populární i v jiných oblastech,
tedy nejenom v hi-end grafice, na kterou byla firma SGI zamìøena.</p>

<image id="6409" />

<p>Jedná o procesory typu <a href="http://en.wikipedia.org/wiki/RISC">RISC</a>
s ètyøcestnou superskalární architekturou, které jsou optimalizované na
zpracování velkého mno¾ství dat. Ke ka¾dému procesoru je pøipojena rychlá
externí pamì» cache o kapacitì plných ètyø megabytù (interní pamì» cache má
velikost 32kB pro kód i pro data, tato pomìrnì malá kapacita odpovídá roku
vzniku tohoto mikroprocesoru &ndash; 1995 &ndash; a èásteènì také pou¾ité
architektuøe). Oblíbenost tohoto mikroprocesoru je dána i jeho nízkou cenou,
tak¾e pøi stavbì výpoèetních systémù bylo mo¾né dosáhnout velmi slu¹ného pomìru
cena/výkon.</p>

<image id="6410" />
<image id="6411" />



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2008</small></p>
</body>
</html>

