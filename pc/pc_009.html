<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V deváté èásti seriálu o architekturách poèítaèù dokonèíme popis instrukèní sady na¹eho jednoduchého cvièného mikroprocesoru. Budou popsány instrukce pro manipulaci se zásobníkem, instrukce NOP, HALT, IRET a nakonec také princip pøeru¹ovacího systému mikroprocesoru.</p>



<h1>Obsah</h1>
<p>
<a href="#k01">1. Manipulace s&nbsp;hodnotami ulo¾enými na zásobníku</a><br />
<a href="#k02">2. Instrukce <strong>PUSH</strong> a <strong>POP</strong></a><br />
<a href="#k03">3. Instrukce <strong>NOP</strong></a><br />
<a href="#k04">4. Instrukce <strong>HALT</strong></a><br />
<a href="#k05">5. Pøeru¹ovací systém mikroprocesoru</a><br />
<a href="#k06">6. Celá instrukèní sada cvièného mikroprocesoru</a><br />
<a href="#k07">7. Obsah dal¹í èásti seriálu</a><br />
</p>



<p><a name="k01"></a></p>
<h1>1. Manipulace s&nbsp;hodnotami ulo¾enými na zásobníku</h1>

<p>Ji¾ v&nbsp;pøedchozích èástech tohoto seriálu jsme si øekli, ¾e ná¹ cvièný
mikroprocesor obsahuje kromì bì¾ných pracovních registrù <strong>A</strong> a
<strong>B</strong> i èítaè instrukcí pøedstavovaný registrem
<strong>PC</strong> (<i>program counter</i>). Navíc je programátorùm (i kdy¾
nepøímo) dostupný i takzvaný <i>ukazatel na vrchol zásobníku</i>, jen¾ je
ulo¾ený v&nbsp;registru nazvaném <strong>SP</strong> (<i>stack pointer</i>).
V&nbsp;tomto ¹estnáctibitovém registru je umístìna adresa, na které se nachází
takzvaný <i>vrchol zásobníku</i> (<i>top of stack</i>). Jinými slovy to
znamená, ¾e samotný zásobník není ulo¾en v&nbsp;mikroprocesoru (ten by pro nìj
musel obsahovat specializovanou pamì»), ale pøímo v&nbsp;operaèní pamìti, co¾
na jednu stranu zjednodu¹í a zlevní mikroprocesor (teoreticky toti¾ mù¾e
zásobník obsáhnout celou pamì»), na stranu druhou je manipulace
s&nbsp;hodnotami ulo¾enými na zásobníku ponìkud pomalej¹í, proto¾e
mikroprocesor musí pøi tìchto operacích komunikovat s&nbsp;relativnì pomalou
operaèní pamìtí.</p>

<image id="6171" />
<p-center>Obrázek 1: Registr pøedstavující ukazatel na vrchol zásobníku <strong>SP</strong></p-center>

<p>Zásobník má svoje dno (první volné místo, do kterého je mo¾né ulo¾it
hodnotu) u popisované architektury umístìné pøekvapivì na pøedposlední adrese
operaèní pamìti, tj.&nbsp;pøi ¹estnáctibitovém adresování se jedná o adresu
0xfffe. Pøi ulo¾ení hodnoty na zásobník instrukcí <strong>PUSH</strong> nebo
instrukcí <strong>CALL</strong> (zde se jedná o zapamatování návratové adresy)
se po zkopírování dané hodnoty na zásobník, tj.&nbsp;na adresu
<strong>SP</strong>, adresa ulo¾ená v&nbsp;registru <strong>SP</strong> zmen¹í
o hodnotu 2, proto¾e se v¾dy pracuje se ¹estnáctibitovými hodnotami. Naopak pøi
vyzvednutí hodnoty ze zásobníku instrukcí <strong>POP</strong> èi vyzvednutí
návratové adresy instrukcí <strong>RET</strong> se hodnota v&nbsp;registru
<strong>SP</strong> o dvojku zvý¹í. Toto chování ukazatele na vrchol zásobníku
je typická pro velkou øadu mikroprocesorù &ndash; nìkdy se také charakterizuje
slovy &bdquo;zásobník roste smìrem dolù&ldquo;, tj.&nbsp;od nejvy¹¹í adresy
k&nbsp;adrese nejni¾¹í.</p>

<image id="6172" />
<p-center>Obrázek 2: Základní operace se zásobníkem</p-center>

<p>Obsah zásobníku je tedy (kromì své inicializace) ovlivòován ètyømi
instrukcemi: <strong>PUSH</strong>, <strong>POP</strong>, <strong>CALL</strong>
a <strong>RET</strong>. Poslední dvì instrukce jsme si popsali v&nbsp;pøedchozí
èásti tohoto seriálu, zbývá nám popsat instrukce <strong>PUSH</strong> a
<strong>POP</strong>, které mají v¹estranné vyu¾ití: od volání funkcí
s&nbsp;parametry (hodnoty parametrù jsou ulo¾eny na zásobník, proto¾e tímto
zpùsobem lze zabezpeèit jejich <i>rekurentnost</i>, tj.&nbsp;mo¾nost
vícenásobného volání), pøes tvorbu rekurzivních algoritmù v&nbsp;assembleru a¾
k&nbsp;tvorbì slo¾itìj¹ích datových struktur, jejich¾ prvky jsou mnohdy ulo¾ené
právì na zásobníku. Bli¾¹í informace o funkci zásobníku (i odkazy na dal¹í
informaèní zdroje) lze nalézt napøíklad v&nbsp;mých pøedchozích seriálech <a
href="http://www.root.cz/serialy/programovaci-jazyk-forth/">Programovací jazyk Forth a zásobníkové procesory</a> èi <a
href="http://www.root.cz/serialy/zasobnikove-jazyky/">Zásobníkové programovací jazyky</a>.</p>



<p><a name="k02"></a></p>
<h1>2. Instrukce <strong>PUSH</strong> a <strong>POP</strong></h1>

<p>Nás cvièný mikroprocesor obsahuje instrukce <strong>PUSH</strong> (ulo¾ení
obsahu pracovního registru na zásobník) a <strong>POP</strong> (obnovení obsahu
pracovního registru), které jako svùj operand vy¾adují jeden z&nbsp;pracovních
registrù <strong>A</strong> èi <strong>B</strong>. Není tedy mo¾né pøímo na
zásobník ulo¾it konstantu nebo obsah nìjaké adresy operaèní pamìti (i tuto
instrukci nìkteré mikroprocesory, zejména ty mající architekturu CISC,
obsahují), ve¹keré operace je nutné provádìt pøes pracovní registry. Místo
neimplementované instrukce:</p>

<code-area>PUSH #1234</code-area>

<p>se tedy musí provést dvojice instrukcí:</p>

<code-area>LD A,#1234
PUSH A
</code-area>

<p>To, který pracovní registr bude pro operaci <strong>PUSH</strong> èi
<strong>POP</strong> pou¾it, závisí na obsahu adresní èásti instrukce, která
následuje ihned za jejím operaèním kódem, co¾ je ostatnì patrné
z&nbsp;následující tabulky:</p>

<table>
<tr><th>Strojový kód</th><th>Zápis v assembleru</th><th>Význam</th></tr>
<tr><td>14 00</td><td>PUSH A</td><td>ulo¾ení obsahu pracovního registru A na zásobník</td></tr>
<tr><td>14 01</td><td>PUSH B</td><td>ulo¾ení obsahu pracovního registru B na zásobník</td></tr>
<tr><td>15 00</td><td>POP  A</td><td>obnovení obsahu pracovního registru A ze zásobníku</td></tr>
<tr><td>15 01</td><td>POP  B</td><td>obnovení obsahu pracovního registru B ze zásobníku</td></tr>
</table>

<image id="6173" />
<p-center>Operace <strong>PUSH</strong> a <strong>POP</strong> znázornìné na mechanické analogii zásobníku</p-center>

<p>Prohození obsahu obou pracovních registrù se dá (pomìrnì naivním zpùsobem)
implementovat pomocí zásobníku:</p>

<code-area>; první varianta prohození obsahu dvou pracovních registrù
PUSH A
PUSH B
POP A
POP B
</code-area>

<p>Ve skuteènosti v¹ak bývá krat¹í a rychlej¹í pou¾ití následujícího idiomu
(støí¹kou je zde naznaèena operace <strong>XOR</strong>, nikoli umocnìní):</p>

<code-area>; druhá varianta prohození obsahu dvou pracovních registrù
XOR A,B        ; A=A^B
XOR B,A        ; B=B^(A^B)=A^(B^B)=A^0=A
XOR A,B        ; A=(A^B)^A=(A^A)^B=0^B=B
</code-area>

<p>Pøi volání funkcí se pou¾ívá postup, pøi kterém se na zásobník nejprve ulo¾í
v¹echny potøebné parametry a potom i návratová hodnota (parametry jsou
oèíslované stejnì, jako je tomu napøíklad v&nbsp;programovacím jazyku Pascal,
tj.&nbsp;pøesnì naopak, ne¾ je tomu u céèka):</p>

<code-area>; sekvence instrukcí volající funkci
LD A,param1
PUSH A         ; naètení a ulo¾ení prvního parametru funkce
LD A,param2
PUSH A         ; naètení a ulo¾ení druhého parametru funkce
CALL funkce    ; zavolání funkce (a ulo¾ení návratové adresy na zásobník)

; tìlo funkce
funkce:
POP A          ; získání hodnoty druhého parametru
POP B          ; získání hodnoty prvního parametru
...
...
...
RET            ; získání návratové hodnoty a provedení zpìtného skoku
</code-area>

<p>V&nbsp;pøípadì, ¾e je zásobník prázdný, tj.&nbsp;registr <strong>SP</strong>
obsahuje hodnotu 0xfffe, je zakázáno volat instrukce <strong>POP</strong> èi
<strong>RET</strong>, proto¾e ze zásobníku není mo¾né ¾ádnou hodnotu získat a
vrátit. Situace, kdy dojde k&nbsp;tomu, ¾e je jedna z&nbsp;tìchto instrukcí
volána nad prázdným zásobníkem, je nazývána <i>stack underflow</i>. Pøi volání
èi provádìní nìjaké nekorektnì zapsané funkce mù¾e dojít k&nbsp;jiné podobnì
zapeklité situaci, ve které zásobník obsahuje o jednu hodnotu více, ne¾
programátor pøedpokládal. Za této situace se pøi návratu z&nbsp;funkce pomocí
instrukce <strong>RET</strong> ze zásobníku získá ¹patná adresa a provádìní
programu pokraèuje na zcela jiném místì, ne¾ by se ze zápisu algoritmu zdálo.
Této situaci se nìkdy øíká <i>buffer overflow</i>, proto¾e ono ne¾ádoucí
ulo¾ení více hodnot na zásobník je mo¾né provést napøíklad kvùli nekorektní
práci s&nbsp;øetìzci nebo poli. Z&nbsp;tohoto dùvodu je vhodné, aby
programátoøi pí¹ící své programy v&nbsp;programovacích jazycích typu C, C++ èi
Pascal, vìdìli, jakým zpùsobem je vlastnì volání funkcí a pøedávání parametrù
funkcím implementováno.</p>


<image id="6174" />
<p-center>Obrázek 4: Mikroprocesor Intel 486DX</p-center>



<p><a name="k03"></a></p>
<h1>3. Instrukce <strong>NOP</strong></h1>

<p>Poslední dvì instrukce, které jsme si je¹tì nepopsali, jsou instrukce
<strong>NOP</strong> a instrukce <strong>HALT</strong>. Instrukce
<strong>NOP</strong>, její¾ mnemotechnická zkratka je odvozena od anglického
sousloví <i>No OPeration</i>, je velmi jednoduchá; jak z&nbsp;pohledu
programátora, tak i z&nbsp;hlediska její implementace v&nbsp;mikroprocesoru.
Mikroprocesor pøi pøijetí operaèního kódu instrukce <strong>NOP</strong> prostì
¾ádnou výraznou operaci neprovede a pokraèuje v&nbsp;provádìní následující
instrukce.</p>

<p>K&nbsp;jakému úèelu je mo¾né tuto instrukci pou¾ít? První zpùsob pou¾ití
spoèívá ve vytvoøení &bdquo;rezervované&ldquo; pamìti,
popø.&nbsp;k&nbsp;pøepisu nìjaké instrukce bez nutnosti pøemístìní zbytku
programu v&nbsp;operaèní pamìti. Jedná se tedy o podobnou operaci, jakou je
zakomentování èásti zdrojového kódu programu, ov¹em s&nbsp;tím rozdílem, ¾e
instrukce <strong>NOP</strong> stále zabírá jeden byte v&nbsp;operaèní pamìti.
Druhý nejèastìj¹í zpùsob pou¾ití spoèívá v&nbsp;tvorbì zpo¾ïovacích smyèek,
proto¾e je prakticky na v¹ech mikroprocesorech známá doba trvání provedení této
instrukce (napøíklad 2 takty). Tøetí oblastí pou¾ití je &bdquo;zarovnání&ldquo;
instrukcí na nìkterých architekturách tak, aby instrukce zaèínaly napøíklad na
násobku 16 bitù èi 32 bitù. To znaèným zpùsobem zrychlí naèítání instrukcí a
jejich operandù z&nbsp;operaèní pamìti. Vìt¹inou tuto výplò generují pøímo
pøekladaèe z&nbsp;vy¹¹ích programovacích jazykù. Následují dva jednoduché
pøíklady:</p>

<code-area>; v pùvodním programu nahradíme instrukci skoku instrukcí NOP
CMP A,B                   ; porovnání pracovních registrù A a B
JNZ password_incorrect    ; v pøípadì rozdílu se provede skok èást programu, který u¾ivatele nepustí dále
...                       ; èást programu provádìná v pøípadì korektního hesla

; upravený program (velmi jednoduchý, ale mnohdy úèinný "crack")
CMP A,B                   ; porovnáme pracovní registry A a B
NOP                       ; instrukce JNZ mìla délku 2 byty, tj. potøebujeme zapsat 2xNOP
NOP
...                       ; èást programu provádìná v pøípadì korektního hesla



; pou¾ití instrukce NOP ve zpo¾ïovací smyèce
LD A, #delay
opak:
    DEC A
    NOP                   ; pøidáním instrukcí NOP mù¾eme dobu trvání smyèky prodlou¾it
    NOP                   ; (nemusí se pou¾ít napøíklad v sobì zanoøená smyèka)
    JNZ opak
</code-area>

<p>Ve strojovém kódu vypadá instrukce <strong>NOP</strong> také jednodu¹e.
Dùle¾ité je, ¾e její délka je pouze jeden byte a proto se mù¾e tato instrukce
pou¾ít v¹ude tam, kde je zapotøebí vytvoøit nìjakou pamì»ovou výplò. Kdyby byla
její délka vìt¹í, mohlo by to pøedstavovat problém.</p>

<table>
<tr><th>Strojový kód</th><th>Zápis v assembleru</th><th>Význam</th></tr>
<tr><td>1e</td><td>NOP</td><td>neprovádí se ¾ádná operace, mikroprocesor pøejde na dal¹í instrukci</td></tr>
</table>

<image id="6175" />
<p-center>Obrázek 5: Mikroprocesor IBM Blue Lightning DX2 (ten mi je¹tì doma v&nbsp;jednom "psacím stroji" bez problémù funguje, i kdy¾ chladiè se pravdìpodobnì u¾ ponìkolikáté spálil)</p-center>



<p><a name="k04"></a></p>
<h1>4. Instrukce <strong>HALT</strong></h1>

<p>Instrukce <strong>HALT</strong> má sice také délku pouze jednoho bytu,
tj.&nbsp;obsahuje operaèní kód, ale adresní èást u¾ nikoli, ov¹em její funkce
je ponìkud odli¹ná od vý¹e uvedené instrukce <strong>NOP</strong>. Po naètení
této instrukce se mikroprocesor zastaví &ndash; to sice neznamená, ¾e by
pøestal pøijímat hodinové impulsy, ale z&nbsp;hlediska okolního prostøedí se
zaène jednat o zcela pasivní souèástku: mikroprocesor se odpojí od v¹ech
sbìrnic, tj.&nbsp;uvede své vstupní i výstupní vodièe (kromì dvou vodièù
zmínìných dále) do stavu vysoké impedance a pøestane s&nbsp;naèítáním dal¹ích
instrukcí, tj.&nbsp;zastaví se zvy¹ování hodnoty registru <strong>PC</strong>.
V&nbsp;této chvíli mohou operaèní pamì» i samotné sbìrnice zaèít pou¾ívat dal¹í
aktivní obvody, typicky øadiè pøímého pøístupu do pamìti (<i>DMA</i>),
matematický koprocesor èi grafický èip.</p>

<p>Mikroprocesor se z&nbsp;tohoto stavu, ve kterém se sna¾í hrát na
&bdquo;mrtvého brouka&ldquo; mù¾e dostat nìkolika zpùsoby:</p>

<ol>
<li>Pøíchodem pøeru¹ení na vstup <strong>IRQ</strong> (bude vysvìtleno v&nbsp;následující kapitole).</li>
<li>Pøíchodem signálu <strong>RESET</strong> (ve své podstatì jde o pøeru¹ení nejvy¹¹í úrovnì).</li>
<li>Odpojením mikroprocesoru od napájení.</li>
</ol>

<table>
<tr><th>Strojový kód</th><th>Zápis v assembleru</th><th>Význam</th></tr>
<tr><td>1f</td><td>HALT</td><td>mikroprocesor se zastaví a èeká na pøíchod externího pøeru¹ení</td></tr>
</table>

<image id="6176" />
<p-center>Obrázek 6: Mikroprocesor MIPS 3000 (jeden z&nbsp;nejlépe navr¾ených mikroprocesorù)</p-center>



<p><a name="k05"></a></p>
<h1>5. Pøeru¹ovací systém mikroprocesoru</h1>

<p>V&nbsp;pøedchozí kapitole jsme se lehce dotkli tématu <i>pøeru¹ovacího
systému mikroprocesoru</i>. O co se vlastnì jedná? Mikroprocesor pøi bì¾né
práci postupnì naèítá instrukce z&nbsp;operaèní pamìti a následnì je provádí
(vykonává). Pokud se nejedná o instrukci skoku, je v&nbsp;dal¹ích taktech
naètena a provedena následující instrukce, skoky a instrukce
<strong>RET</strong> povedou ke zmìnì adresy ulo¾ené v&nbsp;registru
<strong>PC</strong> atd. Program je tedy provádìn na základì algoritmu
pøevedeného do formy programu zapsaného ve strojovém kódu. V&nbsp;nìkterých
pøípadech je v¹ak vhodné, aby byla tato poklidnì provádìná sekvence instrukcí
pøeru¹ena na základì nìjakého vnitøního èi vnìj¹ího podnìtu. Typicky se jedná o
¾ádost periferního zaøízení o to, aby mu procesor poslal, èi z&nbsp;nìj naopak
vyèetl nìjaká data.</p>

<p>Typickým pøíkladem takového zaøízení je klávesnice (pøedpokládejme pro tuto
chvíli, ¾e nemá ¾ádnou hardwarovou vyrovnávací pamì»). Ve chvíli, kdy u¾ivatel
stiskne èi pustí nìjakou klávesu, je nutné, aby mikroprocesor kód této klávesy
naèetl a nìjakým zpùsobem zpracoval, jinak se mù¾e stát, ¾e se informace o
stisku zapomene ve chvíli, kdy u¾ivatel klávesu opìt pustí. Sledování stiskù
kláves je mo¾né provádìt buï aktivnì èi pasivnì.</p>

<p><i>Aktivní zpùsob</i> spoèívá v&nbsp;neustálém naèítání kódù stisknuté
klávesy z&nbsp;obvodu, který klávesnici obsluhuje, co¾ v¹ak vede k&nbsp;tomu,
¾e je celý program zaplnìn nìkolika smyèkami, které se neustále volají a i pøi
rùzných výpoètech je nutné èasto provádìt odskoky do tìchto smyèek. <i>Pasivní
re¾im</i> je mnohem jednodu¹¹í &ndash; mikroprocesor vykonává program, který
byl ulo¾en v&nbsp;operaèní pamìti a pokud dojde ke stisku klávesy, je
generováno takzvané <i>pøeru¹ení</i>, tj.&nbsp;signál, který je pøiveden na
jeden ze vstupù mikroprocesoru a zpùsobí násilné (a pøedev¹ím asynchronní)
poru¹ení bìhu programu a vìt¹inou odskok na pøedem zadanou adresu. Pøitom je
adresa, na které se program nacházel v&nbsp;dobì pøíchodu pøeru¹ení, ulo¾ena na
zásobník, spolu s&nbsp;informacemi o nastavení pøíznakových bitù <strong>Zero
flag</strong> a <strong>Carry flag</strong>.</p>

<p>Zpùsobù, jakým je pøeru¹ovací systém v&nbsp;mikroprocesorech implementován,
je nìkolik. Buï mají mikroprocesory specializované registry obsahující adresy,
na které se pøi výskytu pøeru¹ení provede skok, nebo se jedná o instrukce,
které øadiè pøeru¹ení mikroprocesoru &bdquo;vnutí&ldquo; na datovou sbìrnici
atd. Také zdrojù pøeru¹ení mù¾e být nìkolik, pøièem¾ se zavádí takzvané
<i>priority</i> &ndash; v&nbsp;pøípadì, ¾e pøijde více pøeru¹ení ve stejnou
chvíli, rozhodnì <i>prioritní dekodér</i> o tom, které pøeru¹ení má pøednost.
Vìt¹inou jsou s&nbsp;vy¹¹í prioritou obslou¾ena pomalej¹í zaøízení typu
klávesnice, sériového portu èi disketové jednotky oproti zaøízením rychlej¹ím
(koprocesor, sí»ová karta), ov¹em konkrétní pøiøazení priorit se systém od
systému li¹í.</p>

<p>Ná¹ mikroprocesor má pouze jeden vstup pro pøeru¹ení, který je oznaèen
symbolem <strong>IRQ</strong>. Jde o takzvané <i>nemaskovatelné pøeru¹ení</i>,
proto¾e programátor nemá ¾ádnou mo¾nost, jak programovì toto pøeru¹ení zakázat.
V&nbsp;pøípadì, ¾e na tento vstup mikroprocesoru pøijde úroveò logické jednièky
(pøeru¹ení lze podle povahy mikroprocesoru spou¹tìt buï hranou nebo úrovní), je
dokonèena právì probíhající instrukce a ihned poté se provedou následující
kroky:</p>

<ol>

<li>Na zásobník se ulo¾í obsah pøíznakových bitù <strong>Cary flag</strong> a
<strong>Zero flag</strong></li>

<li>Na zásobník se ulo¾í aktuální obsah registru <strong>PC</strong></li>

<li>Do registru <strong>PC</strong> je ulo¾ena nìjaká pøedem známá hodnota
specifikovaná výrobcem, napøíklad <strong>0x0008</strong></li>

<li>S&nbsp;pøíchodem dal¹ího hodinového taktu mikroprocesor zaène provádìt
instrukce ulo¾ené právì na této adrese (zde by tedy mìl být program pro obsluhu
pøeru¹ení, který napøíklad zjistí, které zaøízení pøeru¹ení vyvolalo, provede
pøíslu¹nou obsluhu a nakonec návrat zpìt do pùvodního programu).</li>

</ol>

<p>O onen návrat z&nbsp;obsluhy pøeru¹ení zpìt do pùvodního programu se stará
instrukce <strong>IRET</strong>, je¾ obnoví pùvodní obsah pøíznakových bitù
<strong>Carry flag</strong> a <strong>Zero flag</strong> i obsah èítaèe
instrukcí <strong>PC</strong>. Po provedení této instrukce se (pokud
programátor neudìlal úmyslnì èi neúmyslnì nìjaké modifikace s&nbsp;obsahem
zásobníku) øízení vrací zpìt do pùvodního programu, který v&nbsp;mnoha
pøípadech není pøíchodem pøeru¹ení ¾ádným zpùsobem ovlivnìn.</p>

<p>Pov¹imnìte si v¹ak jedné zdánlivé &bdquo;malièkosti&ldquo; &ndash; pøi
vstupu do pøeru¹ení se na zásobník automaticky neulo¾í obsah pracovních
registrù a ani pøi návratu z&nbsp;pøeru¹ení se neprovede jejich obnova. To je
(ostatnì jako u mnoha skuteèných mikroprocesorù) zcela ponecháno na
programátorovi, který pøeru¹ovací rutinu vytváøí. Dùvod je ten, ¾e
v&nbsp;obsluze pøeru¹ení se napøíklad nemusí s&nbsp;nìkterými pracovními
registry vùbec manipulovat a není tedy vhodné, aby se v¾dy automaticky ukládaly
na zásobník a posléze zase obnovovaly &ndash; to by stálo mnoho cyklù (tikù
hodinového signálu), se kterými je nutné pøi programování obslu¾né pøeru¹ovací
rutiny co nejvíce ¹etøit. Pøeru¹ovací rutina, která modifikuje obsah obou
pracovních registrù tedy musí zaèínat a konèit takto:</p>

<code-area>; pøíklad pøeru¹ovací rutiny
PUSH A   ; úschova aktuálního obsahu obou pracovních registrù
PUSH B
...      ; obsluha pøeru¹ení
POP  B
POP  A   ; obnova obsahu pracovních registrù
IRET     ; obnova pøíznakových bitù a èítaèe instrukcí
</code-area>

<p>Samotná instrukce <strong>IRET</strong> má délku jednoho bytu, proto¾e
obsahuje pouze operaèní kód a nikoli adresní èást.</p>

<table>
<tr><th>Strojový kód</th><th>Zápis v assembleru</th><th>Význam</th></tr>
<tr><td>19</td><td>IRET</td><td>návrat z pøeru¹ení</td></tr>
</table>

<image id="6177" />
<p-center>Obrázek 7: Mikroprocesor StrongARM firmy Digital</p-center>



<p><a name="k06"></a></p>
<h1>6. Celá instrukèní sada cvièného mikroprocesoru</h1>

<p>Nyní ji¾ známe celou instrukèní sadu na¹eho cvièného mikroprocesoru, tj.&nbsp;jak operaèní kódy v¹ech instrukcí, tak i obsahy jejich adresních èástí. Vzhledem k&nbsp;tomu, ¾e se je¹tì k&nbsp;programování ve strojovém kódu i assembleru vrátíme, uvedu zde celou tabulku instrukcí se v¹emi kombinacemi operaèních kódù a adres. Podobnou tabulku vydává ka¾dý výrobce mikroprocesorù, proto¾e se jedná (samozøejmì spolu se signálovými charakteristikami) o jednu z&nbsp;nejdùle¾itìj¹ích informací o tomto slo¾itém integrovaném obvodu:</p>

<table>
<tr><th>Strojový kód</th><th>Zápis v assembleru</th><th>Význam</th></tr>
<tr><th colspan="3">Aritmetické instrukce</th></tr>
<tr><td>00 00   </td><td>ADD A,A</td><td>A&larr;A+A</td></tr>
<tr><td>00 01   </td><td>ADD A,B</td><td>A&larr;A+B</td></tr>
<tr><td>00 10   </td><td>ADD B,A</td><td>B&larr;A+B</td></tr>
<tr><td>00 11   </td><td>ADD B,B</td><td>B&larr;B+B</td></tr>
<tr><td>01 00   </td><td>ADC A,A</td><td>A&larr;A+A+CF</td></tr>
<tr><td>01 01   </td><td>ADC A,B</td><td>A&larr;A+B+CF</td></tr>
<tr><td>01 10   </td><td>ADC B,A</td><td>B&larr;A+B+CF</td></tr>
<tr><td>01 11   </td><td>ADC B,B</td><td>B&larr;B+B+CF</td></tr>
<tr><td>02 00   </td><td>SUB A,A</td><td>A&larr;A-A</td></tr>
<tr><td>02 01   </td><td>SUB A,B</td><td>A&larr;A-B</td></tr>
<tr><td>02 10   </td><td>SUB B,A</td><td>B&larr;B-A</td></tr>
<tr><td>02 11   </td><td>SUB B,B</td><td>B&larr;B-B</td></tr>
<tr><td>03 00   </td><td>SBB A,A</td><td>A&larr;A-A-CF</td></tr>
<tr><td>03 01   </td><td>SBB A,B</td><td>A&larr;A-B-CF</td></tr>
<tr><td>03 10   </td><td>SBB B,A</td><td>B&larr;B-A-CF</td></tr>
<tr><td>03 11   </td><td>SBB B,B</td><td>B&larr;B-B-CF</td></tr>
<tr><td>04 00   </td><td>INC A</td><td>inkrementace registru A</td></tr>
<tr><td>04 01   </td><td>INC B</td><td>inkrementace registru B</td></tr>
<tr><td>05 00   </td><td>DEC A</td><td>dekrementace registru A</td></tr>
<tr><td>05 01   </td><td>DEC B</td><td>dekrementace registru B</td></tr>
<tr><th colspan="3">Logické instrukce</th></tr>
<tr><td>06 00   </td><td>AND A,A</td><td>A&larr;A &amp; A</td></tr>
<tr><td>06 01   </td><td>AND A,B</td><td>A&larr;A &amp; B</td></tr>
<tr><td>06 10   </td><td>AND B,A</td><td>B&larr;A &amp; B</td></tr>
<tr><td>06 11   </td><td>AND B,B</td><td>B&larr;B &amp; B</td></tr>
<tr><td>07 00   </td><td>OR A,A</td><td>A&larr;A | A</td></tr>
<tr><td>07 01   </td><td>OR A,B</td><td>A&larr;A | B</td></tr>
<tr><td>07 10   </td><td>OR B,A</td><td>B&larr;A | B</td></tr>
<tr><td>07 11   </td><td>OR B,B</td><td>B&larr;B | B</td></tr>
<tr><td>08 00   </td><td>XOR A,A</td><td>A&larr;A ^ A</td></tr>
<tr><td>08 01   </td><td>XOR A,B</td><td>A&larr;A ^ B</td></tr>
<tr><td>08 10   </td><td>XOR B,A</td><td>B&larr;A ^ B</td></tr>
<tr><td>08 11   </td><td>XOR B,B</td><td>B&larr;B ^ B</td></tr>
<tr><td>09 00   </td><td>COM A</td><td>A&larr;~A</td></tr>
<tr><td>09 01   </td><td>COM B</td><td>B&larr;~B</td></tr>
<tr><th colspan="3">Posuvy a rotace</th></tr>
<tr><td>0a 00   </td><td>RL A</td><td>bitová rotace registru A doleva</td></tr>
<tr><td>0a 01   </td><td>RL B</td><td>bitová rotace registru B doleva</td></tr>
<tr><td>0b 00   </td><td>RLC A</td><td>bitová rotace registru A doleva pøes pøíznak pøenosu</td></tr>
<tr><td>0b 01   </td><td>RLC B</td><td>bitová rotace registru B doleva pøes pøíznak pøenosu</td></tr>
<tr><td>0c 00   </td><td>RR A</td><td>bitová rotace registru A doprava</td></tr>
<tr><td>0c 01   </td><td>RR B</td><td>bitová rotace registru B doprava</td></tr>
<tr><td>0d 00   </td><td>RRC A</td><td>bitová rotace registru A doprava pøes pøíznak pøenosu</td></tr>
<tr><td>0d 01   </td><td>RRC B</td><td>bitová rotace registru B doprava pøes pøíznak pøenosu</td></tr>
<tr><td>0e 00   </td><td>ASR A</td><td>aritmetický posuv registru A doprava</td></tr>
<tr><td>0e 01   </td><td>ASR B</td><td>aritmetický posuv registru B doprava</td></tr>
<tr><td>0f 00   </td><td>CMP A,A</td><td>A-A (ovlivní se <i>Carry flag</i> a <i>Zero flag</i>)</td></tr>
<tr><td>0f 01   </td><td>CMP A,B</td><td>A-B (ovlivní se <i>Carry flag</i> a <i>Zero flag</i>)</td></tr>
<tr><td>0f 10   </td><td>CMP B,A</td><td>B-A (ovlivní se <i>Carry flag</i> a <i>Zero flag</i>)</td></tr>
<tr><td>0f 11   </td><td>CMP B,B</td><td>B-B (ovlivní se <i>Carry flag</i> a <i>Zero flag</i>)</td></tr>
<tr><th colspan="3">Testování a porovnání</th></tr>
<tr><td>10 00   </td><td>TEST A,A</td><td>A &amp; A (ovlivní se <i>Zero flag</i>)</td></tr>
<tr><td>10 01   </td><td>TEST A,B</td><td>A &amp; B (ovlivní se <i>Zero flag</i>)</td></tr>
<tr><td>10 10   </td><td>TEST B,A</td><td>B &amp; A (ovlivní se <i>Zero flag</i>)</td></tr>
<tr><td>10 11   </td><td>TEST B,B</td><td>B &amp; B (ovlivní se <i>Zero flag</i>)</td></tr>
<tr><th colspan="3">Pøesuny mezi pamìtí a registry</th></tr>
<tr><td>11 00 xx yy</td><td>LD A,#konstanta</td><td>naètení konstanty <i>xxyy</i> do pracovního registru A</td></tr>
<tr><td>11 01 xx yy</td><td>LD B,#konstanta</td><td>naètení konstanty <i>xxyy</i> do pracovního registru B</td></tr>
<tr><td>11 10 xx yy</td><td>LD A,[adresa]</td><td>naètení hodnoty ulo¾ené v operaèní pamìti do pracovního registru A</td></tr>
<tr><td>11 11 xx yy</td><td>LD B,[adresa]</td><td>naètení hodnoty ulo¾ené v operaèní pamìti do pracovního registru B</td></tr>
<tr><td>12 00 xx yy</td><td>ST A,[adresa]</td><td>ulo¾ení hodnoty z pracovního registru A do operaèní pamìti na zadanou adresu</td></tr>
<tr><td>12 01 xx yy</td><td>ST B,[adresa]</td><td>ulo¾ení hodnoty z pracovního registru B do operaèní pamìti na zadanou adresu</td></tr>
<tr><td>13 00   </td><td>MOV A,B</td><td>pøesun hodnoty z&nbsp;registru B do registru A</td></tr>
<tr><td>13 01   </td><td>MOV B,A</td><td>pøesun hodnoty z&nbsp;registru A do registru B</td></tr>
<tr><td>14 00   </td><td>PUSH A</td><td>ulo¾ení obsahu registru A na zásobník</td></tr>
<tr><td>14 01   </td><td>PUSH B</td><td>ulo¾ení obsahu registru B na zásobník</td></tr>
<tr><td>15 00   </td><td>POP  A</td><td>obnovení obsahu registru A ze zásobníku</td></tr>
<tr><td>15 01   </td><td>POP  B</td><td>obnovení obsahu registru B ze zásobníku</td></tr>
<tr><th colspan="3">Skokové a návratové instrukce</th></tr>
<tr><td>16 xx yy</td><td>JMP</td><td>nepodmínìný skok na zadanou adresu <i>xxyy</i></td></tr>
<tr><td>17 xx yy</td><td>CALL adr</td><td>skok na adresu <i>xxyy</i> s&nbsp;ulo¾ením stavu PC na zásobník</td></tr>
<tr><td>18      </td><td>RET     </td><td>návrat na adresu, je¾ je ulo¾ena na vrcholu zásobníku (obnovení PC)</td></tr>
<tr><td>19      </td><td>IRET</td><td>návrat z pøeru¹ení (obnovení <strong>PC</strong> a pøíznakových bitù)</td></tr>
<tr><td>1a rr   </td><td>JC</td><td>podmínìný relativní skok za pøedpokladu, ¾e je nastaven pøíznak pøenosu (<i>Carry flag</i>)</td></tr>
<tr><td>1b rr   </td><td>JNC</td><td>podmínìný relativní skok za pøedpokladu, ¾e je vynulován pøíznak pøenosu (<i>Carry flag</i>)</td></tr>
<tr><td>1c rr   </td><td>JZ</td><td>podmínìný relativní skok za pøedpokladu, ¾e je nastaven pøíznak nulovosti (<i>Zero flag</i>)</td></tr>
<tr><td>1d rr   </td><td>JNZ</td><td>podmínìný relativní skok za pøedpokladu, ¾e je vynulován pøíznak nulovosti (<i>Zero flag</i>)</td></tr>
<tr><th colspan="3">Nezaøazené zbývající instrukce</th></tr>
<tr><td>1e      </td><td>NOP</td><td>neprovádí se ¾ádná operace, mikroprocesor pøejde na dal¹í instrukci</td></tr>
<tr><td>1f      </td><td>HALT</td><td>mikroprocesor se zastaví a èeká na pøíchod externího pøeru¹ení</td></tr>
</table>

<image id="6178" />
<p-center>Obrázek 8: Srdce mnoha výkonných serverù &ndash; mikroprocesor Super SPARC</p-center>



<p><a name="k07"></a></p>
<h1>7. Obsah dal¹í èásti seriálu</h1>

<p>V&nbsp;následující èásti tohoto seriálu si popí¹eme nìkteré typické
architektury mikroprocesorù, zejména architektury oznaèované témìø magickými
zkratkami RISC, CISC, VLIW a MISC. Øekneme si, jaké jsou pøednosti i zápory
jednotlivých architektur, pøedev¹ím s&nbsp;ohledem na budoucí vývoj
mikroprocesorù.</p>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2008</small></p>
</body>
</html>

