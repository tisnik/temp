<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Práce s hodnotami s plovoucí øádovou èárkou na mikroprocesorech ARM</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Práce s hodnotami s plovoucí øádovou èárkou na mikroprocesorech ARM</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V seriálu o architekturách poèítaèù jsme se ji¾ seznámili se v¹emi tøemi instrukèními sadami mikroprocesorù ARM - jak s pùvodní RISCovou sadou tak i se sadou Thumb a na ni navazující Thumb-2. Je¹tì jsme si v¹ak prakticky nic neøekli o podpoøe práce s hodnotami s plovoucí øádovou èárkou na procesorech ARM. Nyní nastal pravý èas tuto informaci doplnit.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Práce s&nbsp;hodnotami s&nbsp;plovoucí øádovou èárkou na mikroprocesorech ARM</a></p>
<p><a href="#k02">2. Architektura FPA (ARM Floating Point Accelerator)</a></p>
<p><a href="#k03">3. Formáty dat pou¾ívané v&nbsp;matematických koprocesorech s&nbsp;architekturou FPA</a></p>
<p><a href="#k04">4. Sada registrù pou¾ívaná v&nbsp;matematických koprocesorech s&nbsp;architekturou FPA, speciální registry FPSR a FPCR</a></p>
<p><a href="#k05">5. Instrukèní sada matematických koprocesorù s&nbsp;architekturou FPA</a></p>
<p><a href="#k06">6. Základní aritmetické operace, latence vybraných operací</a></p>
<p><a href="#k07">7. Komparace hodnot s&nbsp;naplnìním pøíznakových registrù</a></p>
<p><a href="#k08">8. Dal¹í operace vykonávané matematickými koprocesory s&nbsp;architekturou FPA</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Práce s&nbsp;hodnotami s&nbsp;plovoucí øádovou èárkou na mikroprocesorech ARM</h2>

<p>V&nbsp;pøedchozích èástech <a
href="http://www.root.cz/serialy/co-se-deje-v-pocitaci/">seriálu o
architekturách poèítaèù</a> jsme si popsali instrukèní sady <i>ARM</i>,
<i>Thumb</i> i <i>Thumb-2</i> (navíc jsme se je¹tì zmínili o technologii
<i>Jazelle</i>). Jak je u vìt¹iny mikroprocesorových architektur zvykem, byly i
v¹echny tøi zmínìné instrukèní sady orientovány pøevá¾nì na manipulaci
s&nbsp;celoèíselnými daty o bitové ¹íøce 32 bitù a do urèité míry takté¾
¹estnáct a osm bitù (co¾ je vhodné napøíklad pro zpracování øetìzcù). U mnoha
zaøízení, v&nbsp;nich¾ byl pou¾it nìkterý z&nbsp;mikroprocesorù <i>ARM</i>,
bylo vyu¾ití pouze celoèíselných operací pro danou aplikaèní oblast dostateèné,
ov¹em spoleènì s&nbsp;tím, jak se roz¹iøovaly oblasti, v&nbsp;nich¾ byly
procesory <i>ARM</i> pou¾ívány, se ukazovalo, ¾e pro mnoho aplikací by bylo
vhodné pou¾ít i matematický koprocesor, který by dokázal zpracovávat numerické
hodnoty s&nbsp;plovoucí øádovou èárkou (<i>FP &ndash; Floating Point</i>).</p>

<p>Ideálnì by se mìlo jednat o matematický koprocesor pou¾ívající formát
numerických hodnot definovaný v&nbsp;normì <a
href="http://en.wikipedia.org/wiki/IEEE_754-2008">IEEE 754</a>, proto¾e se
jedná o standard zaruèující mj.&nbsp;i lep¹í pøenositelnost aplikací, detekci
nìkterých potenciálnì chybových stavù (dìlení nulou, pøeteèení, podteèení,
ztráta pøesnosti ...) i stabilitu numerických algoritmù. Zajímavý a pro celou
architekturu mikroprocesorù <i>ARM</i> mo¾ná i typický je fakt, ¾e postupem
èasu vzniklo hned nìkolik technologií, které procesorùm ARM umo¾nily práci
s&nbsp;<i>FP</i> hodnotami, samozøejmì za asistence matematických koprocesorù
(programová implementace <i>FP</i> operací je sice relativnì snadná, ov¹em za
její pou¾ití zaplatíme mnohdy velmi dlouhou dobu výpoètu).</p>

<p>V&nbsp;dne¹ním èlánku se zamìøíme pøedev¹ím na popis architektury <i>FPA</i>
neboli celým jménem <i>Floating Point Accelerator</i> a zmíníme se takté¾ o
v&nbsp;mnoha ohledech zajímavìj¹í a takté¾ výkonnìj¹í architektuøe <i>VFP</i>,
plným názvem <i>Vector Floating Point</i>. Vlastnosti obou architektur jsou
standardizovány, pøièem¾ je i stanoveno, ¾e v&nbsp;pøípadì, ¾e nìkterá
instrukce není pøímo implementována instalovaným matematickým koprocesorem,
bude tato instrukce zachycena (<i>trap</i>) a zpracována v&nbsp;emulátoru
matematického koprocesoru <i>FPEmulator</i>. To je v&nbsp;mnoha ohledech
výhodné, pøedev¹ím kvùli tomu, ¾e je zaji¹tìna pøenositelnost programù
nezávisle na tom, zda se na konkrétním poèítaèi/zaøízení pou¾ívá mikroprocesor
<i>ARM</i> s&nbsp;matematickým koprocesorem èi bez nìj. Navíc je umo¾nìno, aby
koprocesor implementoval pouze nìkteré FP operace, zatímco ménì èasto pou¾ívané
a souèasnì i obtí¾nìji implementovatelné operace se budou emulovat, opìt pøesnì
podle konkrétních po¾adavkù.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Architektura FPA (ARM Floating Point Accelerator)</h2>

<p>Jak ji¾ víme z&nbsp;pøedchozích èástí tohoto seriálu, neobsahovaly pùvodní
varianty mikroprocesorù s&nbsp;architekturou <i>ARM</i> ¾ádnou podporu pro
operace s&nbsp;èísly s&nbsp;plovoucí øádovou èárkou. To se zmìnilo se zavedením
matematických koprocesorù s&nbsp;architekturou <i>FPA</i>. Podobnì jako u
mikroprocesorù øady <i>8086/80286/80386</i> byly i matematické koprocesory
<i>FPA</i> pùvodnì realizovány na samostatném èipu, který pro pøipojení
k&nbsp;mikroprocesorùm <i>ARM</i> pou¾íval standardní rozhraní pro koprocesory
(tìch bylo mo¾né pøipojit a¾ ¹estnáct, pozdìji se koprocesory pøímo pøidávaly
na èip spoleèný se samotným jádrem <i>ARM</i>). Mikroprocesor <i>ARM</i>
v&nbsp;takové konfiguraci provádìl ve¹keré bì¾né instrukce, tj.&nbsp;naèítání
hodnot z&nbsp;operaèní pamìti, ukládání hodnot do pamìti, provádìní ALU
operací, skoky, skoky do subrutin atd. Úkolem matematického koprocesoru bylo
provádìní konverzí dat mezi pracovními registry <i>ARM</i> a registry
koprocesoru a samozøejmì takté¾ provádìní v¹ech <i>FP</i> operací, které navíc
mohly nastavit pøíznakové bity <strong>N</strong> (<i>negative</i>),
<strong>V</strong> (<i>overflow</i>), <strong>Z</strong> (<i>zero</i>) a
<strong>C</strong> (<i>carry</i>) vyu¾ívané procesory <i>ARM</i> pro provádìní
skokù èi instrukcí s&nbsp;podmínkou.</p>

<p>Pøi konstrukci matematického koprocesoru s&nbsp;architekturou <i>FPA</i>
bylo pou¾ito mnoho technik vyu¾ívaných v&nbsp;RISCových mikroprocesorech.
Zejména se jednalo o instrukèní pipeline a takté¾ o automatickou detekci
hazardu typu read-after-write (v&nbsp;tomto pøípadì do¹lo k&nbsp;pozdr¾ení
vykonávání instrukce ulo¾ené v&nbsp;pipeline). Díky tomu, ¾e implementovány
byly pøedev¹ím základní aritmetické operace, bylo mo¾né zkonstruovat
matematický koprocesor, jeho¾ charakteristiky (pøedev¹ím spotøeba a výpoèetní
výkon) dobøe odpovídaly i charakteristikám procesorù <i>ARM</i>. Celý
mikroprocesor byl pùvodnì umístìn v&nbsp;pouzdru PLCC s&nbsp;68 piny, jeho
výpoèetní výkon dosahoval 2 a¾ 5 MFLOPS pøi pou¾ití hodinové frekvence 40 MHz a
jeho spotøeba zhruba odpovídala 2,5 mA na ka¾dý MHz (technologie 5V a 3,3V).
Pro konstrukci mikroprocesoru bylo pou¾ito pøibli¾nì 130&nbsp;000
tranzistorù.</p>

<p>Celý matematický koprocesor byl rozdìlen na pìt hlavních blokù propojených
interními datovými cestami o ¹íøce 81 bitù. V&nbsp;prvním bloku bylo
implementováno rozhraní k&nbsp;mikroprocesorùm <i>ARM</i>, pøes nì¾ se
pøená¹ela jak zpracovávaná data, tak i øídicí informace. Druhý blok byl
pøedstavován instrukèním dekodérem, tøetí blok vykonával základní operace typu
<i>load/store</i>, ètvrtým blokem byla sada pracovních <i>FP</i> registrù (viz
té¾ <a href="#k04">ètvrtá kapitola</a>) a pátým blokem byla samozøejmì
aritmetická jednotka provádìjící aritmetické operace s&nbsp;<i>FP</i>
hodnotami, konverze data atd..</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Formáty dat pou¾ívané v&nbsp;matematických koprocesorech s&nbsp;architekturou FPA</h2>

<p>Matematické koprocesory s&nbsp;architekturou <i>FPA</i> umo¾òují práci
s&nbsp;numerickými hodnotami reprezentovanými v&nbsp;systému plovoucí øádové
èárky (<i>floating point</i>) a takté¾ s&nbsp;hodnotami pou¾ívajícími kód BCD,
v&nbsp;nìm¾ je ka¾dá èíslice (i èíslice exponentu) ulo¾ena ve ètyøech bitech
(navíc je u tohoto formátu mocnina u exponentu rovna deseti a nikoli dvìma).
Nás v¹ak budou v&nbsp;tomto èlánku zajímat pøedev¹ím formáty hodnot
s&nbsp;plovoucí øádovou èárkou, proto¾e ty jsou pou¾ívány èastìji, ne¾ formát
s&nbsp;BCD èíslicemi. FP formáty jsou v&nbsp;<i>FPA</i> (na rozdíl od dále
popsané architektury <i>VFP</i>) celkem tøi: <i>single/float</i>, <i>double</i>
a <i>extended</i>. Základní informace o tìchto tøech formátech jsou uvedeny
v&nbsp;následující tabulce:</p>

<table>
<tr><th>Datový typ</th><th>©íøka (bitù)</th><th>Znaménko (bitù)</th><th>Mantisa (bitù)</th><th>Exponent (bitù)</th></tr>
<tr><td>Single  </td><td>32</td><td>1</td><td>23</td><td> 8</td></tr>
<tr><td>Double  </td><td>64</td><td>1</td><td>52</td><td>11</td></tr>
<tr><td>Extended</td><td>80</td><td>1</td><td>64</td><td>15</td></tr>
</table>

<p>FP formát <i>single</i> (=jednoduchá pøesnost) èi <i>float</i> pou¾íval
mantisu o ¹íøce 23 bitù a exponent o ¹íøce osm bitù. Pro reprezentaci èísla se
tedy muselo vyu¾ít 32 bitù, proto¾e nesmíme zapomenout na jednobitové znaménko
mantisy:</p>

<pre>
 +-+--------+-----------------------+
 |s|exponent|  mantisa, bity 0..22  |
 +-+--------+-----------------------+
31 30     23 22                     0
</pre>

<p>U FP formátu <i>double</i> (=dvojitá pøesnost) se bitová ¹íøka mantisy i
exponentu roz¹íøila takovým zpùsobem, ¾e na ulo¾ení bylo nutné pou¾ít 64 bitù.
Samozøejmì se zvìt¹ila jak pøesnost, tak i rozsah reprezentovatelných
hodnot:</p>

<pre>
 +-+-----------+--------------------+
 |s| exponent  |mantisa, bity 32..51|
 +-+-----------+--------------------+
63 62        52 51                 32

 +----------------------------------+
 |        mantisa, bity 0..31       |
 +----------------------------------+
31                                  0
</pre>

<p>U FP formátu <i>extended</i> je nutné pou¾ít 80bitová slova:</p>

<pre>
 +-+--------+
 |s|exponent|
 +-+--------+
79 78     64

 +----------------------------------+
 |        mantisa, bity 32..64      |
 +----------------------------------+
63                                 32

 +----------------------------------+
 |        mantisa, bity 0..31       |
 +----------------------------------+
31                                  0
</pre>

<p>V¹echny tøi FP formáty podporovaly i reprezentaci nìkterých speciálních
hodnot, pøedev¹ím kladné a záporné nuly, kladného a záporného nekoneèna,
hodnoty <i>NaN</i> (napøíklad výsledek operace 0/0) èi denormalizovaných
èísel.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Sada registrù pou¾ívaná v&nbsp;matematických koprocesorech s&nbsp;architekturou FPA, speciální registry FPSR a FPCR</h2>

<p>Matematické koprocesory s&nbsp;architekturou <i>FPA</i> obsahují celkem osm
FP registrù, které se v&nbsp;assembleru znaèí jmény <strong>f0</strong> a¾
<strong>f7</strong>. Ka¾dý z&nbsp;tìchto FP registrù má ¹íøku osmdesát bitù
(deset bajtù) a mù¾e tedy reprezentovat numerickou hodnotu ve formátu
<i>single</i>, <i>double</i> nebo <i>extended</i>. Díky tomu, ¾e instrukèní kód
<i>FPA</i> je tøíadresový, lze FP registry pou¾ívat zcela libovolnì, netvoøí
tedy zásobník, jak tomu pùvodnì bylo u koprocesorù <i>8087</i>. Nicménì pøi
volání subrutin se vìt¹inou dodr¾uje pravidlo, ¾e registry <strong>f0</strong>
a¾ <strong>f3</strong> se pou¾ívají pro pøedání parametrù do subrutin,
popø.&nbsp;pro pøenos návratové hodnoty do kódu, který subrutinu zavolal.
Zbývající registry <strong>f4</strong> a¾ <strong>f7</strong> se samozøejmì
takté¾ mohou v&nbsp;subrutinách vyu¾ít, nicménì se pøed jejich modifikací
ukládají (do pamìti èi na zásobníkový rámec) a pøed ukonèením bìhu subrutiny se
jejich obsah obnovuje.</p>

<p>Kromì toho obsahují koprocesory i registr <strong>FPSR</strong> (<i>Floating
Point Status Register</i>) a popøípadì i <strong>FPCR</strong> (<i>Floating
Point Control Register</i>). <strong>FPSR</strong> obsahuje nìkolik dùle¾itých
údajù, pøedev¹ím <i>System ID</i>, z&nbsp;nìho¾ lze vyèíst, zda se pou¾ívá
skuteèný hardwarovì implementovaný matematický koprocesor, èi zda se FP výpoèty
provádí programovì. Dále je v&nbsp;tomto registru ulo¾eno pìt pøíznakù
nastavovaných pøi aritmetických operacích:</p>

<pre>
IXC - ztráta pøesnosti
UFC - podteèení
OFC - pøeteèení
DZC - dìlení nulou
IOC - neplatná operace 0/0, log -n apod.
</pre>

<p>Nastavení tìchto pøíznakù je mo¾né blokovat pomocí dal¹ích pìti øídicích bitù:</p>

<pre>
IXE - blokace/povolení pøíznaku IXC
UFE - blokace/povolení pøíznaku UFC
OFE - blokace/povolení pøíznaku OFC
DZE - blokace/povolení pøíznaku DZC
IOE - blokace/povolení pøíznaku IOC
</pre>

<p>Registr <strong>FPCR</strong> mù¾e být pou¾it pøi ukládání a pøená¹ení
stavových a øídicích informací pøi kooperaci mezi hardwarovì implementovaným
matematickým koprocesorem a programovými rutinami provádìjícími nìkteré FP
operace (výpoèet goniometrických funkcí apod.). Tento registr nemusí ve v¹ech
pøípadech existovat a i kdy¾ existuje, tak není pøedepsán jeho vnitøní
formát, na rozdíl od vý¹e zmínìného registru <strong>FPSR</strong>.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Instrukèní sada matematických koprocesorù s&nbsp;architekturou FPA</h2>

<p>Matematické koprocesory s&nbsp;architekturou <i>FPA</i> pou¾ívají instrukèní
sadu, která se v&nbsp;nìkterých ohledech podobá pùvodní instrukèní sadì
mikroprocesorù <i>ARM</i>, co¾ zajisté není náhoda. V¹echny instrukce mají
¹íøku 32 bitù a u ka¾dé instrukce lze specifikovat podmínku, pøi jejím¾ splnìní
se instrukce vykoná. Do 32bitových instrukcí se ve¹ly i dal¹í dùle¾ité pøíznaky
a pøepínaèe. Jedním z&nbsp;nich je po¾adovaný re¾im zaokrouhlení, jen¾ se
zapisuje i formou sufixu pøímo do mnemotechnického kódu instrukce:</p>

<table>
<tr><th>Kód</th><th>Sufix</th><th>Význam</th></tr>
<tr><td>00</td><td>-</td><td>nejbli¾¹í reprezentovatelná hodnota</td></tr>
<tr><td>01</td><td>P</td><td>zaokrouhlení smìrem ke kladnému nekoneènu</td></tr>
<tr><td>10</td><td>M</td><td>zaokrouhlení smìrem k zápornému nekoneènu</td></tr>
<tr><td>11</td><td>Z</td><td>zaokrouhlení smìrem k&nbsp;nule</td></tr>
</table>

<p>Dal¹ím pøíznakem je specifikace formátu výsledku. Opìt se jedná o údaj,
který lze u nìkterých instrukcí zapsat formou sufixu za jméno instrukce:</p>

<table>
<tr><th>Kód</th><th>Sufix</th><th>Význam</th></tr>
<tr><td>00</td><td>S</td><td>single</td></tr>
<tr><td>01</td><td>D</td><td>double</td></tr>
<tr><td>10</td><td>E</td><td>extended</td></tr>
<tr><td>11</td><td>-</td><td>nedefinováno</td></tr>
</table>

<p>Mo¾ná nejzajímavìj¹í je v¹ak fakt, ¾e druhým operandem aritmetických èi
komparativních operací mù¾e být jak nìkterý z&nbsp;FP registrù, tak i
konstanta, její¾ kód je ulo¾en pøímo v&nbsp;instrukci. To je velmi u¾iteèná
vlastnost, proto¾e se tím mù¾e zkrátit relativnì velké mno¾ství algoritmù.
Celkem je mo¾né v&nbsp;instrukèním slovu pou¾ít jednu z&nbsp;osmi konstant:</p>

<table>
<tr><th>Bitový kód</th><th>FP konstanta</th></tr>
<tr><td>000</td><td> 0.0</td></tr>
<tr><td>001</td><td> 1.0</td></tr>
<tr><td>010</td><td> 2.0</td></tr>
<tr><td>011</td><td> 3.0</td></tr>
<tr><td>100</td><td> 4.0</td></tr>
<tr><td>101</td><td> 5.0</td></tr>
<tr><td>110</td><td> 0.5</td></tr>
<tr><td>111</td><td>10.0</td></tr>
</table>



<p><a name="k06"></a></p>
<h2 id="k06">6. Základní aritmetické operace, latence vybraných operací</h2>

<p>V&nbsp;této kapitole budou popsány základní aritmetické operace podporované
v&nbsp;instrukèní sadì <i>FPA</i>. Jedná se o operace provádìné s&nbsp;dvojicí
operandù, jen¾ jsou vìt¹inou ulo¾eny ve dvojici <i>FP</i> registrù
(popø.&nbsp;mù¾e být jako druhý operand pou¾ita konstanta &ndash; viz té¾ <a
href="#k05">pøedchozí kapitolu</a>). Výsledek operace je ulo¾en do dal¹ího
zvoleného FP registru. Jedná se tedy o tøíadresový kód, podobnì jako je tomu i
u pùvodní RISCové instrukèní sady <i>ARM</i>. Dùvod pro toto uspoøádání
instrukcí je zøejmý &ndash; s&nbsp;tøíadresovým kódem mohou velmi snadno a
efektivnì pracovat pøekladaèe, které mají zjednodu¹enou práci pøi alokaci
registrù i pøi pøekladu slo¾itìj¹ích aritmetických výrazù. Pov¹imnìte si
takté¾, ¾e se v&nbsp;instrukèní sadì vyskytují i operace typu
&bdquo;reverse...&ldquo;, u nich¾ je prohozen význam obou operandù. Dùvodem je
mo¾nost pou¾ití konstanty na místì prvního èi druhého operandu:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th><th>Provádìný výpoèet</th></tr>
<tr><td>1</td><td>ADF</td><td>Add                </td><td>Fd := Fn + Fm</td></tr>
<tr><td>2</td><td>SUF</td><td>Subtract           </td><td>Fd := Fn - Fm</td></tr>
<tr><td>3</td><td>RSF</td><td>Reverse Subtract   </td><td>Fd := Fm - Fn</td></tr>
<tr><td>4</td><td>MUF</td><td>Multiply           </td><td>Fd := Fn * Fm</td></tr>
<tr><td>5</td><td>DVF</td><td>Divide             </td><td>Fd := Fn / Fm</td></tr>
<tr><td>6</td><td>RDF</td><td>Reverse Divide     </td><td>Fd := Fm / Fn</td></tr>
<tr><td>7</td><td>FML</td><td>Fast Multiply      </td><td>Fd := Fn * Fm</td></tr>
<tr><td>8</td><td>FDV</td><td>Fast Divide        </td><td>Fd := Fn / Fm</td></tr>
<tr><td>9</td><td>FRD</td><td>Fast Reverse Divide</td><td>Fd := Fm / Fn</td></tr>
</table>

<p>Poslední tøi instrukce <strong>FML</strong>, <strong>FDV</strong> a
<strong>FRD</strong> sice provádí plnohodnotné operace násobení a dìlení, ov¹em
jedná se o instrukce, které pracují pouze s&nbsp;numerickými hodnotami
s&nbsp;jednoduchou pøesností, tj.&nbsp;s&nbsp;datovým typem <i>single</i>.
Nejvìt¹í pøedností tìchto instrukcí je vy¹¹í rychlost výpoètu, ov¹em výsledky
se mohou v&nbsp;nìkterých pøípadech li¹it v&nbsp;nejni¾¹ím bitu mantisy od
výsledkù získaných s&nbsp;vyu¾itím &bdquo;plnohodnotných&ldquo; operací
násobení a dìlení, v&nbsp;nich¾ se následnì provede korektní zaokrouhlení.</p>

<p>Zajímavá a v&nbsp;mnoha pøípadech dùle¾itá je takté¾ informace o
<i>latenci</i> instrukcí. Jedná se o (celoèíselnou) hodnotu, která udává poèet
taktù (hodinových cyklù) nutných pro dokonèení operace zapsané
v&nbsp;instrukci. Tato hodnota je tedy mìøena od naètení instrukce a¾ po
korektní ulo¾ení výsledkù zpìt do <i>FP</i> registrù; v&nbsp;praxi se v¹ak díky
existenci instrukèní pipeline mohou zaèít zpracovávat i dal¹í instrukce
pøedtím, ne¾ je daná operace zcela dokonèena. Latence je (oèekávatelnì)
nejni¾¹í u aditivních operací a nejvy¹¹í u instrukcí podílu, latence se takté¾
u nìkterých operací zvy¹uje spoleènì s&nbsp;po¾adovanou pøesností výpoètu, co¾
je ostatnì patrné i pøi pohledu na následující tabulku:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th><th>Latence</th><th>Poznámka</th></tr>
<tr><td>1</td><td>ADF</td><td>Add          </td><td> 4</td><td>&times;</td></tr>
<tr><td>2</td><td>MUF</td><td>Multiply     </td><td> 9</td><td>&times;</td></tr>
<tr><td>3</td><td>FML</td><td>Fast Multiply</td><td> 6</td><td>pouze single</td></tr>
<tr><td>4</td><td>DVF</td><td>Divide       </td><td>31</td><td>single</td></tr>
<tr><td>5</td><td>DVF</td><td>Divide       </td><td>59</td><td>double</td></tr>
<tr><td>6</td><td>DVF</td><td>Divide       </td><td>71</td><td>extended</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Komparace hodnot s&nbsp;naplnìním pøíznakových registrù</h2>

<p>Matematické koprocesory s&nbsp;architekturou <i>FPA</i> obsahují i ètveøici
instrukcí, které na základì porovnání dvou FP hodnot mohou nastavit pøíznakové
bity <strong>N</strong> (<i>negative</i>), <strong>V</strong>
(<i>overflow</i>), <strong>Z</strong> (<i>zero</i>) a <strong>C</strong>
(<i>carry</i>). Ji¾ víme, ¾e tyto pøíznakové bity slou¾í pro provádìní
podmínìných skokù (v¹echny instrukèní sady), popø.&nbsp;pro urèení, zda se má
èi nemá nìkterá instrukce provést na základì podmínkových bitù (instrukèní sada
<i>ARM</i> a èásteènì i <i>Thumb-2</i>). Pøi porovnání dvou FP hodnot v¹ak
mohou mít nastavené bitové pøíznaky ponìkud jiný význam, ne¾ je tomu u
celoèíselných porovnání &ndash; viz té¾ následující tabulku:</p>

<table>
<tr><th>Pøíznak</th><th>Význam po FP porovnání</th></tr>
<tr><td>N</td><td>men¹í ne¾</td></tr>
<tr><td>Z</td><td>rovnost</td></tr>
<tr><td>C</td><td>vìt¹í ne¾, popø. rovnost</td></tr>
<tr><td>V</td><td>hodnoty nelze navzájem uspoøádat</td></tr>
</table>

<p>Pøíznak <strong>V</strong> je nastaven tehdy, pokud je jedna
z&nbsp;porovnávaných hodnot NaN, tj.&nbsp;pokud nelze dvojici hodnot navzájem
uspoøádat. V&nbsp;dal¹í tabulce jsou vypsány v¹echny ètyøi komparaèní operace,
které koprocesory <i>FPA</i> realizují. První dvì operace se pou¾ívají
pøedev¹ím pro test na rovnost èi nerovnost (pøíznak <strong>Z</strong>) a na
zji¹tìní, zda vùbec lze hodnoty porovnat (pøíznak <strong>V</strong>). Druhé
dvì operace je mo¾né pou¾ít i pro test relací typu &bdquo;vìt¹í ne¾&ldquo;,
&bdquo;vìt¹í nebo rovno&ldquo; atd.:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th><th>Provádìný výpoèet/operace</th></tr>
<tr><td>1</td><td>CMF </td><td>Compare Floating                       </td><td>Fn &lt;?&gt;  Fm</td></tr>
<tr><td>2</td><td>CNF </td><td>Compare Negated Floating               </td><td>Fn &lt;?&gt; -Fm</td></tr>
<tr><td>3</td><td>CMFE</td><td>Compare Floating with Exception        </td><td>Fn &lt;?&gt;  Fm</td></tr>
<tr><td>4</td><td>CNFE</td><td>Compare Negated Floating with Exception</td><td>Fn &lt;?&gt; -Fm</td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Dal¹í operace vykonávané matematickými koprocesory s&nbsp;architekturou FPA</h2>

<p>Kromì základních aritmetických operací a komparativních operací mohly
matematické koprocesory s&nbsp;architekturou <i>FPA</i> vykonávat i mnoho
dal¹ích instrukcí. Jednalo se pøedev¹ím o pøesuny dat. Dokonce byl podporován i
pøesun dat a¾ ze ètyø registrù souèasnì:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th><th>Provádìný výpoèet/operace</th></tr>
<tr><td>1</td><td>LDFS</td><td>Load Single</td><td>Naètení FP hodnoty typu single (jeden registr)</td></tr>
<tr><td>2</td><td>LDFD</td><td>Load Double</td><td>Naètení FP hodnoty typu double (jeden registr)</td></tr>
<tr><td>3</td><td>LDFE</td><td>Load Extended</td><td>Naètení FP hodnoty typu extended (jeden registr)</td></tr>
<tr><td>4</td><td>STFS</td><td>Store Single</td><td>Ulo¾ení FP hodnoty typu single (jeden registr)</td></tr>
<tr><td>5</td><td>STFD</td><td>Store Double</td><td>Ulo¾ení FP hodnoty typu double (jeden registr)</td></tr>
<tr><td>6</td><td>STFE</td><td>Store Extended</td><td>Ulo¾ení FP hodnoty typu extended (jeden registr)</td></tr>
<tr><td>7</td><td>LFM </td><td>Load Floating Multiple </td><td>Naètení hodnoty do 1-4 FP registrù</td></tr>
<tr><td>8</td><td>SFM </td><td>Store Floating Multiple</td><td>Ulo¾ení hodnoty 1-4 FP registrù</td></tr>
</table>

<p>V&nbsp;následující tabulce jsou vypsány unární aritmetické a konverzní
operace, které jsou provádìny pouze s&nbsp;dvojicí FP registrù. Jeden
z&nbsp;registrù je v&nbsp;tomto pøípadì zdrojový, druhý cílový:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th><th>Provádìný výpoèet/operace</th></tr>
<tr><td> 1</td><td>MVF</td><td>Move                   </td><td>Fd := Fm (pouhý pøesun hodnoty)</td></tr>
<tr><td> 2</td><td>MNF</td><td>Move Negated           </td><td>Fd := -Fm (pøesun hodnoty se zmìnou znaménka)</td></tr>
<tr><td> 3</td><td>ABS</td><td>Absolute               </td><td>Fd := | Fm | (výpoèet absolutní hodnoty)</td></tr>
<tr><td> 4</td><td>URD</td><td>Round to Integral Value</td><td>Fd := int. Fm</td></tr>
<tr><td> 5</td><td>NRM</td><td>Normalise result       </td><td>Fd := normalizovaný Fm</td></tr>
<tr><td> 6</td><td>FLT</td><td>Integer to floating point conversion</td><td>Fn := Rd</td></tr>
<tr><td> 7</td><td>FIX</td><td>Floating point to integer conversion</td><td>Rd := Fm</td></tr>
<tr><td> 8</td><td>WFS</td><td>Write Floating Point Status n       </td><td>FPSR := Rd</td></tr>
<tr><td> 9</td><td>RFS</td><td>Read Floating Point Status          </td><td>Rd := FPSR</td></tr>
<tr><td>10</td><td>WFC</td><td>Write Floating Point Control        </td><td>FPCR := Rd</td></tr>
<tr><td>11</td><td>RFC</td><td>Read Floating Point Control         </td><td>Rd := FPCR</td></tr>
</table>

<p><ins>Poznámka: pov¹imnìte si, ¾e instrukce uvedené v&nbsp;pøedchozí tabulce
na øádcích 6 a¾ 11 ve skuteènosti provádí pøenos dat mezi matematickým
koprocesorem a vybraným pracovním registrem R0-R15 mikroprocesoru
<i>ARM</i>.</ins></p>

<p>V&nbsp;poslední tabulce jsou uvedeny operace provádìné programovì. Tyto
operace se sice takté¾ mohly zapisovat jako bì¾né instrukce, ov¹em
v&nbsp;pøípadì, ¾e se procesor pokusil tuto instrukci provést, do¹lo
k&nbsp;zachycení neznámého operaèního kódu (<i>trap</i>) a zbytek výpoètu mohl
provést pøíslu¹ný podprogram:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th><th>Provádìný výpoèet/operace</th></tr>
<tr><td> 1</td><td>SQT</td><td>Square Root            </td><td>Fd := Fm<sup>(1/2)</sup></td></tr>
<tr><td> 2</td><td>POW</td><td>Power                  </td><td>Fd := Fn<sup>Fm</sup></td></tr>
<tr><td> 3</td><td>RPW</td><td>Reverse Power          </td><td>Fd := Fm<sup>Fn</sup></td></tr>
<tr><td> 4</td><td>RMF</td><td>Remainder              </td><td>Fd := zbytek po Fn/Fm</td></tr>
<tr><td> 5</td><td>POL</td><td>Polar Angle            </td><td>výpoèet hodnoty arctan z&nbsp;podílu Fn/Fm</td></tr>
<tr><td> 6</td><td>RND</td><td>Round to Integral Value</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>LOG</td><td>Logarithm to base 10   </td><td>Fd := log<sub>10</sub> Fm</td></tr>
<tr><td> 8</td><td>LGN</td><td>Logarithm to base e    </td><td>Fd := log<sub>e</sub> Fm</td></tr>
<tr><td> 9</td><td>EXP</td><td>Exponent               </td><td>Fd := e<sup>Fm</sup></td></tr>
<tr><td>10</td><td>SIN</td><td>Sine                   </td><td>Fd := sin Fm</td></tr>
<tr><td>11</td><td>COS</td><td>Cosine                 </td><td>Fd := cos Fm</td></tr>
<tr><td>12</td><td>TAN</td><td>Tangent                </td><td>Fd := tan Fm</td></tr>
<tr><td>13</td><td>ASN</td><td>Arc Sine               </td><td>Fd := arcsin Fm</td></tr>
<tr><td>14</td><td>ACS</td><td>Arc Cosine             </td><td>Fd := arccos Fm</td></tr>
<tr><td>15</td><td>ATN</td><td>Arc Tangent            </td><td>Fd := arctan Fm</td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>ARM Floating Point Accelerator (ARM FPA)<br />
<a href="http://vswww.kaist.ac.kr/ver4.0/index.php/research/past-research/arm-fpa.html">http://vswww.kaist.ac.kr/ver4.0/index.php/research/past-research/arm-fpa.html</a>
</li>

<li>The VFP architecture<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0056d/Bcfibfha.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0056d/Bcfibfha.html</a>
</li>

<li>NEON<br />
<a href="http://www.arm.com/products/processors/technologies/neon.php">http://www.arm.com/products/processors/technologies/neon.php</a>
</li>

<li>Coding for NEON - Part 1: Load and Stores<br />
<a href="http://blogs.arm.com/software-enablement/161-coding-for-neon-part-1-load-and-stores/">http://blogs.arm.com/software-enablement/161-coding-for-neon-part-1-load-and-stores/</a>
</li>

<li>Coding for NEON - Part 2: Dealing With Leftovers<br />
<a href="http://blogs.arm.com/software-enablement/196-coding-for-neon-part-2-dealing-with-leftovers/">http://blogs.arm.com/software-enablement/196-coding-for-neon-part-2-dealing-with-leftovers/</a>
</li>

<li>Coding for NEON - Part 3: Matrix Multiplication<br />
<a href="http://blogs.arm.com/software-enablement/241-coding-for-neon-part-3-matrix-multiplication/">http://blogs.arm.com/software-enablement/241-coding-for-neon-part-3-matrix-multiplication/</a>
</li>

<li>Coding for NEON - Part 4: Shifting Left and Right<br />
<a href="http://blogs.arm.com/software-enablement/277-coding-for-neon-part-4-shifting-left-and-right/">http://blogs.arm.com/software-enablement/277-coding-for-neon-part-4-shifting-left-and-right/</a>
</li>

<li>DSP &amp; SIMD<br />
<a href="http://www.arm.com/products/processors/technologies/dsp-simd.php">http://www.arm.com/products/processors/technologies/dsp-simd.php</a>
</li>

<li>Improving ARM Code Density and Performance<br />
<a href="New Thumb Extensions to the ARM Architecture Richard Phelan">New Thumb Extensions to the ARM Architecture Richard Phelan</a>
</li>

<li>The ARM Processor Architecture<br />
<a href="http://www.arm.com/products/processors/technologies/instruction-set-architectures.php">http://www.arm.com/products/processors/technologies/instruction-set-architectures.php</a>
</li>

<li>Thumb-2 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html</a>
</li>

<li>Introduction to ARM thumb<br />
<a href="http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb">http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb</a>
</li>

<li>ARM, Thumb, and ThumbEE instruction sets<br />
<a href="http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm">http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm</a>
</li>

<li>An Introduction to ARM Assembly Language<br />
<a href="http://dev.emcelettronica.com/introduction-to-arm-assembly-language">http://dev.emcelettronica.com/introduction-to-arm-assembly-language</a>
</li>

<li>Processors - ARM<br />
<a href="http://www.arm.com/products/processors/index.php">http://www.arm.com/products/processors/index.php</a>
</li>

<li>The ARM Instruction Set<br />
<a href="http://simplemachines.it/doc/arm_inst.pdf">http://simplemachines.it/doc/arm_inst.pdf</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ARM_architecture">http://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>BBC BASIC<br />
<a href="http://www.bbcbasic.co.uk/bbcbasic.html">http://www.bbcbasic.co.uk/bbcbasic.html</a>
</li>

<li>BBC BASIC<br />
<a href="http://mdfs.net/Software/BBCBasic/">http://mdfs.net/Software/BBCBasic/</a>
</li>

<li>BBC BASIC (Z80) for the ZX Spectrum<br />
<a href="http://mdfs.net/Software/BBCBasic/Spectrum/">http://mdfs.net/Software/BBCBasic/Spectrum/</a>
</li>

<li>BBC BASIC (Wikipedia CZ)<br />
<a href="http://en.wikipedia.org/wiki/BBC_BASIC">http://en.wikipedia.org/wiki/BBC_BASIC</a>
</li>

<li>MIPS-3D(r) ASE<br />
<a href="http://www.mips.com/products/architectures/mips-3d-ase/">http://www.mips.com/products/architectures/mips-3d-ase/</a>
</li>

<li>An introduction to SPARC's SIMD offerings<br />
<a href="http://mikeburrell.wordpress.com/2007/12/14/an-introduction-to-sparcs-simd-offerings/">http://mikeburrell.wordpress.com/2007/12/14/an-introduction-to-sparcs-simd-offerings/</a>
</li>

<li>MIPS64<sup>TM</sup> Architecture for Programmers Volume IV-c: The MIPS-3D<sup>TM</sup> Application-Specific Extension to the MIPS64<sup>TM</sup><br />
<a href="http://www.weblearn.hs-bremen.de/risse/RST/docs/MIPS/MD00099-2B-MIPS3D64-AFP-01.11.pdf">http://www.weblearn.hs-bremen.de/risse/RST/docs/MIPS/MD00099-2B-MIPS3D64-AFP-01.11.pdf</a>
</li>

<li>Visual Instruction Set<br />
<a href="http://www.enotes.com/topic/Visual_Instruction_Set">http://www.enotes.com/topic/Visual_Instruction_Set</a>
</li>

<li>NEON<br />
<a href="http://www.arm.com/products/processors/technologies/neon.php">http://www.arm.com/products/processors/technologies/neon.php</a>
</li>

<li>Architecture and Implementation of the ARM Cortex-A8 Microprocessor<br />
<a href="http://www.design-reuse.com/articles/11580/architecture-and-implementation-of-the-arm-cortex-a8-microprocessor.html">http://www.design-reuse.com/articles/11580/architecture-and-implementation-of-the-arm-cortex-a8-microprocessor.html</a>
</li>

<li>Multimedia Acceleration eXtensions (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Multimedia_Acceleration_eXtensions">http://en.wikipedia.org/wiki/Multimedia_Acceleration_eXtensions</a>
</li>

<li>AltiVec (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AltiVec">http://en.wikipedia.org/wiki/AltiVec</a>
</li>

<li>Visual Instruction Set (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Visual_Instruction_Set">http://en.wikipedia.org/wiki/Visual_Instruction_Set</a>
</li>

<li>MAJC (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/MAJC">http://en.wikipedia.org/wiki/MAJC</a>
</li>

<li>MDMX (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/MDMX">http://en.wikipedia.org/wiki/MDMX</a>
</li>

<li>MIPS Multiply Unit<br />
<a href="http://programmedlessons.org/AssemblyTutorial/Chapter-14/ass14_3.html">http://programmedlessons.org/AssemblyTutorial/Chapter-14/ass14_3.html</a>
</li>

<li>Silicon Graphics Introduces Enhanced MIPS Architecture<br />
<a href="http://bwrc.eecs.berkeley.edu/CIC/otherpr/enhanced_mips.html">http://bwrc.eecs.berkeley.edu/CIC/otherpr/enhanced_mips.html</a>
</li>

<li>MIPS-3D (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/MIPS-3D">http://en.wikipedia.org/wiki/MIPS-3D</a>
</li>

<li>MIPS Technologies, Inc. announces new MIPS-3D technology to provide silicon-efficient 3D graphics acceleration<br />
<a href="http://www.design-reuse.com/news/2057/mips-mips-3d-technology-silicon-efficient-3d-graphics-acceleration.html">http://www.design-reuse.com/news/2057/mips-mips-3d-technology-silicon-efficient-3d-graphics-acceleration.html</a>
</li>

<li>MIPS-3D Built-in Function (gcc.gnu.org)<br />
<a href="http://gcc.gnu.org/onlinedocs/gcc/MIPS_002d3D-Built_002din-Functions.html">http://gcc.gnu.org/onlinedocs/gcc/MIPS_002d3D-Built_002din-Functions.html</a>
</li>

<li>Baha Guclu Dundar:<br />
Intel MMX, SSE, SSE2, SSE3/SSSE3/SSE4 Architectures
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>

<li>Intel MMX<sup>TM</sup> Technology Overview<br />
Intel corporation, 1996</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>AMD K5 ("K5" / "5k86")<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g5K5-c.html">http://www.pcguide.com/ref/cpu/fam/g5K5-c.html</a>
</li>

<li>Sixth Generation Processors<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g6.htm">http://www.pcguide.com/ref/cpu/fam/g6.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Very_long_instruction_word">http://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>Tour of the Black Holes of Computing!: Floating Point<br />
<a href="http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt">http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt</a>
</li>

<li>3Dnow! Technology Manual<br />
AMD Inc., 2000</li>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>Control unit (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Control_unit">http://en.wikipedia.org/wiki/Control_unit</a>
</li>

<li>Cray History<br />
<a href="http://www.cray.com/About/History.aspx?404;http://www.cray.com:80/about_cray/history.html">http://www.cray.com/About/History.aspx?404;http://www.cray.com:80/about_cray/history.html</a>
</li>

<li>Cray Historical Timeline<br />
<a href="http://www.cray.com/Assets/PDF/about/CrayTimeline.pdf">http://www.cray.com/Assets/PDF/about/CrayTimeline.pdf</a>
</li>

<li>Computer Speed Claims 1980 to 1996<br />
<a href="http://homepage.virgin.net/roy.longbottom/mips.htm">http://homepage.virgin.net/roy.longbottom/mips.htm</a>
</li>

<li>Superpoèítaèe Cray<br />
<a href="http://www.root.cz/clanky/superpocitace-cray/">http://www.root.cz/clanky/superpocitace-cray/</a>
</li>

<li>Superpoèítaèe Cray (druhá èást)<br />
<a href="http://www.root.cz/clanky/superpocitace-cray-druha-cast/">http://www.root.cz/clanky/superpocitace-cray-druha-cast/</a>
</li>

<li>Superpoèítaèe Cray (tøetí èást)<br />
<a href="http://www.root.cz/clanky/superpocitace-cray-treti-cast/">http://www.root.cz/clanky/superpocitace-cray-treti-cast/</a>
</li>

<li>Superpoèítaèe Cray (ètvrtá èást)<br />
<a href="http://www.root.cz/clanky/superpocitace-cray-ctvrta-cast/">http://www.root.cz/clanky/superpocitace-cray-ctvrta-cast/</a>
</li>

<li>Superpoèítaèe Cray (pátá èást): architektura Cray X-MP<br />
<a href="http://www.root.cz/clanky/superpocitace-cray-pata-cast-architektura-pocitace-cray-x-mp-a-jeho-pouziti-ve-filmovem-prumyslu/">http://www.root.cz/clanky/superpocitace-cray-pata-cast-architektura-pocitace-cray-x-mp-a-jeho-pouziti-ve-filmovem-prumyslu/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2012</small></p>
</body>
</html>

