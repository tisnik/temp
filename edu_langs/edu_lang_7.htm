<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Fyzikální engine implementovaný v knihovně LÖVE (2.část)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Fyzikální engine implementovaný v knihovně LÖVE (2.část)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhém článku o fyzikálním enginu, který je součástí knihovny LÖVE, si na čtveřici demonstračních příkladů ukážeme použití jiných tvarů těles v&nbsp;simulovaném světě, seznámíme se s&nbsp;konceptem takzvaných obalových těles používaných při detekci kolizí a taktéž se způsobem řešení některých problémů plynoucích z&nbsp;nepřesných výpočtů těchto kolizí.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Fyzikální engine implementovaný v&nbsp;knihovně LÖVE (2.část)</a></p>
<p><a href="#k02">2. Použití dalších tvarů těles v&nbsp;simulovaném světě</a></p>
<p><a href="#k03">3. Zdrojový kód prvního demonstračního příkladu</a></p>
<p><a href="#k04">4. Detekce kolizí a obalová tělesa používaná v&nbsp;knihovně LÖVE</a></p>
<p><a href="#k05">5. Zdrojový kód druhého demonstračního příkladu</a></p>
<p><a href="#k06">6. Problematika &bdquo;průstřelu&ldquo; tenkých stěn a způsob jejího řešení</a></p>
<p><a href="#k07">7. Zdrojový kód třetího demonstračního příkladu</a></p>
<p><a href="#k08">8. Použití přesnějšího výpočtu kolizí</a></p>
<p><a href="#k09">9. Zdrojový kód čtvrtého demonstračního příkladu</a></p>
<p><a href="#k10">10. Repositář se zdrojovými kódy všech čtyř dnešních demonstračních příkladů</a></p>
<p><a href="#k11">11. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Fyzikální engine implementovaný v&nbsp;knihovně LÖVE (2.část)</h2>

<p><a href="http://fedora.cz/fyzikalni-engine-implementovany-v-knihovne-love/">V&nbsp;prvním článku o fyzikálním enginu implementovaném v&nbsp;knihovně LÖVE</a> jsme si řekli základní informace o tom, k&nbsp;čemu se vlastně tento engine využívá a jakým způsobem je ho možné zařadit do vyvíjených aplikací napsaných v&nbsp;programovacím jazyku Lua. Taktéž jsme se seznámili se základními typy objektů, s&nbsp;nimiž tento engine pracuje a z&nbsp;nichž se vytváří simulovaný (například herní) svět. Připomeňme si tedy jen ve stručnosti, že fyzikální engine je v&nbsp;knihovně LÖVE dostupný přes modul pojmenovaný <strong>love.physics</strong> a &ndash; podobně jako celá knihovna LÖVE &ndash; je orientován téměř výhradně na dvoudimenzionální (2D) grafiku. Díky omezení počtu rozměrů bylo možné všechny výpočty dynamiky těles urychlit a navíc je celé programové rozhraní modulu <strong>love.physics</strong> poměrně snadno pochopitelné, a to i pro začátečníky (na tomto místě je vhodné si uvědomit, že samotný engine je interně dosti složitý, ovšem úlohou správně navrženého API je tuto složitost od uživatelů odstínit, což se v&nbsp;tomto případě podařilo, i tak je však <strong>love.physics</strong> nejrozsáhlejším modulem v&nbsp;celé knihovně LÖVE).</p>

<a href="http://fedora.cz/wp-content/uploads/2015/10/01.gif"><img class="alignnone size-full wp-image-5764" src="http://fedora.cz/wp-content/uploads/2015/10/01.gif" alt="01" width="400" height="300" /></a>
<p><i>Obrázek 1: Jednoduchá simulace vytvořená s&nbsp;využitím modulu <strong>love.physics</strong>.</i></p>

<p>V&nbsp;předchozím článku jsme se taktéž dozvěděli, že celý simulovaný svět i všechna tělesa, která se v&nbsp;tomto světě pohybují, se popisuje pomocí následujících pěti typů objektů:</p>

<table>
<tr><th>#</th><th>Typ</th><th>Význam</th></tr>
<tr><td>1</td><td>World  </td><td>objekt představující celý simulovaný dvourozměrný svět</td></tr>
<tr><td>2</td><td>Body   </td><td>objekt představující nestlačitelnou hmotu v&nbsp;simulovaném světě</td></tr>
<tr><td>3</td><td>Shape  </td><td>geometrický tvar přiřazený k&nbsp;tělesu</td></tr>
<tr><td>4</td><td>Fixture</td><td>vazba mezi již vytvořeným tvarem (<i>shape</i>) a tělesem (<i>body</i>)</td></tr>
<tr><td>5</td><td>Joint  </td><td>vazba mezi tělesy, které se nachází v&nbsp;simulovaném světě</td></tr>
</table>

<a href="http://fedora.cz/wp-content/uploads/2015/09/031.png"><img class="alignnone size-medium wp-image-5735" src="http://fedora.cz/wp-content/uploads/2015/09/031-450x450.png" alt="03" width="450" height="450" /></a>
<p><i>Obrázek 2: Vztah mezi čtyřmi základními typy objektů: World, Body(ies), Shape(s) a Fixture(s), bližší informace viz <a href="http://fedora.cz/fyzikalni-engine-implementovany-v-knihovne-love/">první článek na toto téma</a>.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Použití dalších tvarů těles v&nbsp;simulovaném světě</h2>

<p>V&nbsp;předchozích dvou demonstračních příkladech byly použity statické i pohybující se objekty, jejichž tvar (<i>shape</i>) odpovídal obdélníkům. Jedná se o jeden z&nbsp;nejjednodušších tvarů, s&nbsp;nímž může engine <strong>love.physics</strong> pracovat, pro většinu aplikací by to ale bylo zcela nedostatečné. Proto jsou k&nbsp;dispozici i další tvary. Všechny dostupné tvary i jejich konstruktory (tj.&nbsp;funkce volané pro jejich vytvoření) jsou pro přehlednost vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Tvar</th><th>Konstruktor</th><th>Popis</th></tr>
<tr><td>1</td><td>rectangle</td><td>love.physics.newRectangleShape()</td><td>obdélník či čtverec (libovolně natočený)</td></tr>
<tr><td>2</td><td>polygon</td><td>love.physics.newPolygonShape()</td><td>konvexní polygon s&nbsp;maximálně osmi vrcholy</td></tr>
<tr><td>3</td><td>circle</td><td>love.physics.newCircleShape()</td><td>kruh/kružnice</td></tr>
<tr><td>4</td><td>edge</td><td>love.physics.newEdgeShape()</td><td>jen úsečka, tento tvar nemá vnitřek, omezené použití</td></tr>
<tr><td>5</td><td>chain</td><td>love.physics.newChainShape()</td><td>polyčára, tento tvar nemá vnitřek, omezené použití</td></tr>
</table>

<a href="http://fedora.cz/wp-content/uploads/2015/09/041.png"><img class="alignnone size-medium wp-image-5736" src="http://fedora.cz/wp-content/uploads/2015/09/041-450x450.png" alt="04" width="450" height="450" /></a>
<p><i>Obrázek 3: V&nbsp;tomto simulovaném světě se používají pouze tělesa s&nbsp;tvarem obdélníku.</i></p>

<p>Poznámka 1: pro pohybující se objekty je možné reálně využít jen první tři tvary: <i>rectangle</i> (speciální typ polygonu), konvexní <i>polygon</i> a <i>circle</i>. Další dva tvary jsou určeny pro nehybná tělesa, takže je možné je použít například pro vymodelování terénu. Zajímavý a potenciálně užitečný je v&nbsp;tomto ohledu tvar <i>edge shape</i>, který nemusí být konvexní, na rozdíl od tvaru <i>polygon</i> (a samozřejmě automaticky též <i>rectangle</i>).</p>

<p>Poznámka 2: v&nbsp;modulu <strong>love.physics</strong> se žádným způsobem neřeší způsob vykreslení tvarů na obrazovku. Tuto činnost musí explicitně zajistit programátor a to typicky takovým způsobem, že s&nbsp;využitím metod <strong>objekt.shape:getPoints()</strong>, <strong>objekt.body:getX()</strong>, <strong>objekt.body:getY()</strong> a <strong>objekt.body:getRadius()</strong> přečte aktuální pozici a rozměry tvaru, které následně předá do kreslicích funkcí modulu <strong>love.graphics</strong>. Alternativně je samozřejmě možné pouze získat pozici tvaru a vykreslit zcela odlišný objekt, například sprite. Volání zmíněných funkcí se většinou provádí v&nbsp;callback funkci <strong>love.draw</strong>, což použijeme i v&nbsp;demonstračních příkladech.</p>

<a href="http://fedora.cz/wp-content/uploads/2015/09/141.png"><img class="alignnone size-medium wp-image-5746" src="http://fedora.cz/wp-content/uploads/2015/09/141-450x450.png" alt="14" width="450" height="450" /></a>
<p><i>Obrázek 4: V&nbsp;další simulaci se již používají i kulatá tělesa.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zdrojový kód prvního demonstračního příkladu</h2>

<p>Použití dalších tvarů těles, zde konkrétně tvaru kruhu/kružnice, je ukázáno v&nbsp;dnešním prvním demonstračním příkladu. Ten je založen na obou příkladech, s&nbsp;nimiž jsme se seznámili minule, ovšem do simulovaného světa byly přidány dva míčky:</p>

<pre>
<i>--</i>
<i>-- Funkce volaná při inicializaci aplikace.</i>
<i>--</i>
<strong>function</strong> love.load()
    ...
    ...
    ...
    <i>-- těleso představující první míček</i>
    objects.ball1 = {}
    <i>-- počáteční umístění tělesa</i>
    objects.ball1.body = love.physics.newBody(world, 400, 100, "dynamic")
    <i>-- tvar a rozměry</i>
    objects.ball1.shape = love.physics.newCircleShape(40)
    <i>-- propojení tvaru s tělesem</i>
    objects.ball1.fixture = love.physics.newFixture(objects.ball1.body, objects.ball1.shape, 5)
    objects.ball1.fixture:setRestitution(0.9)
&nbsp;
    <i>-- těleso představující druhý míček</i>
    objects.ball2 = {}
    <i>-- počáteční umístění tělesa</i>
    objects.ball2.body = love.physics.newBody(world, 225, 50, "dynamic")
    <i>-- tvar a rozměry</i>
    objects.ball2.shape = love.physics.newCircleShape(50)
    <i>-- propojení tvaru s tělesem</i>
    objects.ball2.fixture = love.physics.newFixture(objects.ball2.body, objects.ball2.shape, 5000)
    objects.ball2.fixture:setRestitution(0.1)
    ...
    ...
    ...
<strong>end</strong>
</pre>

<p>Tyto míčky se v&nbsp;callback funkci <strong>love.draw()</strong> vykreslí velmi snadno s&nbsp;využitím metod pro přečtení aktuální souřadnice středu a poloměru zmíněných v&nbsp;předchozí kapitole:</p>

<pre>
<i>--</i>
<i>-- Tato funkce je volána automaticky při překreslení obsahu</i>
<i>-- okna či obrazovky.</i>
<i>--</i>
<strong>function</strong> love.draw()
    ...
    ...
    ...
&nbsp;
    <i>-- vykreslení prvního tělesa (míčku)</i>
    love.graphics.setColor(250, 150, 150)
    love.graphics.circle("line", objects.ball1.body:getX(), objects.ball1.body:getY(),
                                 objects.ball1.shape:getRadius())
&nbsp;
    <i>-- vykreslení druhého tělesa (míčku)</i>
    love.graphics.setColor(150, 150, 250)
    love.graphics.circle("line", objects.ball2.body:getX(), objects.ball2.body:getY(),
                                 objects.ball2.shape:getRadius())
    ...
    ...
    ...
<strong>end</strong>
</pre>

<a href="http://fedora.cz/wp-content/uploads/2015/10/05.png"><img class="alignnone size-medium wp-image-5765" src="http://fedora.cz/wp-content/uploads/2015/10/05-450x450.png" alt="05" width="450" height="450" /></a>
<p><i>Obrázek 5: Svět simulovaný v&nbsp;dnešním prvním demonstračním příkladu.</i></p>

<p>Úplný zdrojový kód demonstračního příkladu:</p>

<pre>
<i>--</i>
<i>-- Knihovna LÖVE</i>
<i>--</i>
<i>-- Dvacátý demonstrační příklad</i>
<i>--</i>
<i>-- Jednoduchý "svět", v němž se nachází dva míčky a jeden kvádr.</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>-- rozměry okna, do něhož se bude provádět vykreslování</i>
width = 600
height = 600
ground_height = 50
&nbsp;
<i>-- tíhové zrychlení</i>
G = 9.81
&nbsp;
<i>-- počet pixelů odpovídající jednomu metru v simulovaném světě</i>
pixels_per_meter = 64
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Funkce volaná při inicializaci aplikace.</i>
<i>--</i>
<strong>function</strong> love.load()
    <i>-- načtení standardního fontu a nastavení grafického režimu</i>
    <strong>local</strong> font = love.graphics.newFont(love.default_font, 40)
&nbsp;
    <i>-- inicializace grafického režimu</i>
    love.graphics.setMode(width, height, false, false, 0)
&nbsp;
    <i>-- nastavení rozměrů simulovaného světa</i>
    <i>-- (mapování fyzikálních jednotek na pixely)</i>
    love.physics.setMeter(pixels_per_meter)
&nbsp;
    <i>-- vytvoření simulovaného světa</i>
    world = love.physics.newWorld(0, G * pixels_per_meter, true)
&nbsp;
    <i>-- tabulka s tělesy</i>
    objects = {}
&nbsp;
    <i>-- těleso představující zemi</i>
    objects.ground = {}
    <i>-- počáteční umístění tělesa</i>
    objects.ground.body = love.physics.newBody(world, width/2, height-ground_height/2-40)
    <i>-- tvar a rozměry</i>
    objects.ground.shape = love.physics.newRectangleShape(0, 0, width, ground_height, -0.15)
    <i>-- propojení tvaru s tělesem</i>
    objects.ground.fixture = love.physics.newFixture(objects.ground.body, objects.ground.shape, 5)
    objects.ground.fixture:setRestitution(0.7)
&nbsp;
    <i>-- těleso představující první míček</i>
    objects.ball1 = {}
    <i>-- počáteční umístění tělesa</i>
    objects.ball1.body = love.physics.newBody(world, 400, 100, "dynamic")
    <i>-- tvar a rozměry</i>
    objects.ball1.shape = love.physics.newCircleShape(40)
    <i>-- propojení tvaru s tělesem</i>
    objects.ball1.fixture = love.physics.newFixture(objects.ball1.body, objects.ball1.shape, 5)
    objects.ball1.fixture:setRestitution(0.9)
&nbsp;
    <i>-- těleso představující druhý míček</i>
    objects.ball2 = {}
    <i>-- počáteční umístění tělesa</i>
    objects.ball2.body = love.physics.newBody(world, 225, 50, "dynamic")
    <i>-- tvar a rozměry</i>
    objects.ball2.shape = love.physics.newCircleShape(50)
    <i>-- propojení tvaru s tělesem</i>
    objects.ball2.fixture = love.physics.newFixture(objects.ball2.body, objects.ball2.shape, 5000)
    objects.ball2.fixture:setRestitution(0.1)
&nbsp;
    <i>-- těleso představující kvádr</i>
    objects.block3 = {}
    <i>-- počáteční umístění tělesa</i>
    objects.block3.body = love.physics.newBody(world, 450, 50, "dynamic")
    <i>-- tvar a rozměry</i>
    objects.block3.shape = love.physics.newRectangleShape(100, 100)
    <i>-- propojení tvaru s tělesem</i>
    objects.block3.fixture = love.physics.newFixture(objects.block3.body, objects.block3.shape, 5)
    objects.block3.fixture:setRestitution(0.0)
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Funkce volaná cca 30x za sekundu</i>
<i>--</i>
<strong>function</strong> love.update(dt)
    <i>-- přepočítat parametry celého "světa"</i>
    world:update(dt)
&nbsp;
    <strong>local</strong> delay = 1/30
    <strong>if</strong> dt &lt; delay <strong>then</strong>
        love.timer.sleep(delay - dt)
    <strong>end</strong>
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Tato funkce je volána automaticky při překreslení obsahu</i>
<i>-- okna či obrazovky.</i>
<i>--</i>
<strong>function</strong> love.draw()
    <i>-- vykreslení země</i>
    love.graphics.setColor(72, 160, 14)
    love.graphics.polygon("line", objects.ground.body:getWorldPoints(objects.ground.shape:getPoints()))
&nbsp;
    <i>-- vykreslení prvního tělesa (míčku)</i>
    love.graphics.setColor(250, 150, 150)
    love.graphics.circle("line", objects.ball1.body:getX(), objects.ball1.body:getY(),
                                 objects.ball1.shape:getRadius())
&nbsp;
    <i>-- vykreslení druhého tělesa (míčku)</i>
    love.graphics.setColor(150, 150, 250)
    love.graphics.circle("line", objects.ball2.body:getX(), objects.ball2.body:getY(),
                                 objects.ball2.shape:getRadius())
&nbsp;
    <i>-- vykreslení třetího tělesa (kvádru)</i>
    love.graphics.setColor(150, 250, 150)
    love.graphics.polygon("line", objects.block3.body:getWorldPoints(objects.block3.shape:getPoints()))
&nbsp;
    <i>-- výpis zprávy</i>
    love.graphics.setColor(250, 250, 250)
    love.graphics.print("Escape: to exit.", 20, 615)
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Callback funkce zavolaná při stisku klávesy.</i>
<i>--</i>
<strong>function</strong> love.keypressed(k)
    <strong>if</strong> k == 'escape' <strong>then</strong>
    <i>-- klávesou "Escape" se aplikace ukončí</i>
        love.event.quit()
    <strong>end</strong>
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- finito</i>
<i>--</i>
</pre>

<a href="http://fedora.cz/wp-content/uploads/2015/10/06.png"><img class="alignnone size-medium wp-image-5766" src="http://fedora.cz/wp-content/uploads/2015/10/06-450x450.png" alt="06" width="450" height="450" /></a>
<p><i>Obrázek 6: Svět simulovaný v&nbsp;dnešním prvním demonstračním příkladu.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Detekce kolizí a obalová tělesa používaná v&nbsp;knihovně LÖVE</h2>

<p>V&nbsp;mnoha aplikacích, především ve hrách, je nutné zaregistrovat okamžik, ve kterém dojde ke kolizi dvou či většího množství těles. Může se například jednat o střet hráče se stěnou, náraz střely do protihráče apod. Engine pak vypočte, jakým způsobem se od sebe tělesa odrazí (připomeňme si, že se stále jedná o nestlačitelná a dokonale neelastická tělesa, takže náraz ani odraz nezmění tvar tělesa). Samotná detekce kolizí je &ndash; i když jsou veškeré výpočty prováděny pouze v&nbsp;dvourozměrné ploše &ndash; poměrně výpočetně náročná, proto je také množina tvarů, které je možné navázat na tělesa, omezená na výše zmíněné kruhy/kružnice a (uzavřené) konvexní polygony s&nbsp;maximálně osmi hranami. Každý tvar (<i>shape</i>) je navíc vždy uzavřen do takzvaného &bdquo;obalového tělesa&ldquo; (<i>bounding rectangle</i>, obecně <i>bounding box</i> či jen <i>bbox</i>), jehož strany jsou rovnoběžné se souřadnými osami a tudíž je detekce kolizí výrazně jednodušší než v&nbsp;případě obecného polygonu či kruhu. Pokud se totiž neprotínají či ani nedotýkají obalové boxy, nemá smysl provádět složitější výpočet skutečného dotyku těles, což se v&nbsp;praxi ukazuje být velmi významnou optimalizační technikou (dokonce ještě větší význam má v&nbsp;3D enginech).</p>

<a href="http://fedora.cz/wp-content/uploads/2015/10/07.gif"><img class="alignnone size-medium wp-image-5767" src="http://fedora.cz/wp-content/uploads/2015/10/07.gif" alt="07" width="400" height="300" /></a>
<p><i>Obrázek 7: Obalová tělesa (bounding boxes) zobrazená pro všechny objekty v&nbsp;simulovaném světě.</i></p>

<p>Obalový obdélník (<i>bounding box</i>) je možné pro libovolný tvar získat metodou <strong>Fixture:getBoundingBox()</strong>, což si taktéž ukážeme v&nbsp;následujícím demonstračním příkladu. Při každé změně pozice i natočení tvaru je velikost obalového tělesa přepočítána tak, aby tvar vždy ležel uvnitř tohoto tělesa a současně byla jeho plocha minimální (jak bude z&nbsp;animací patrné, tato podmínka není vždy splněna, protože se ještě bere v&nbsp;úvahu vektor rychlosti pohybu tělesa). Jak jsme si již řekli v&nbsp;předchozím odstavci, probíhá detekce kolizí vždy nejprve nad obalovými tělesy a teprve v&nbsp;okamžiku, kdy dojde k&nbsp;jejich prolnutí (či alespoň dotyku) nastává obecně složitější část výpočtu &ndash; detekce kolize samotných tvarů. Jen pro úplnost: výše zmíněná metoda <strong>Fixture:getBoundingBox()</strong> vrací dva protilehlé vrcholy obalového obdélníku. V&nbsp;předchozích verzích knihovny LÖVE existovala i podobně pojmenovaná metoda <strong>Shape:getBoundingBox()</strong> vracející čtveřici vrcholů (tedy osm souřadnic). Předností této metody byl fakt, že její návratové hodnoty (osm hodnot) bylo možné ihned předat funkci <strong>love.draw.polygon()</strong> a obalové těleso tak vykreslit na obrazovku.</p>

<a href="http://fedora.cz/wp-content/uploads/2015/10/08.gif"><img class="alignnone size-medium wp-image-5768" src="http://fedora.cz/wp-content/uploads/2015/10/08.gif" alt="08" width="400" height="300" /></a>
<p><i>Obrázek 8: Obalová tělesa (bounding boxes) zobrazená pro všechny objekty v&nbsp;simulovaném světě (i pro polygon).</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Zdrojový kód druhého demonstračního příkladu</h2>

<p>V&nbsp;dnešním druhém demonstračním příkladu je ukázáno, jakým způsobem je možné pro všechny objekty, které se nachází v&nbsp;simulovaném světě, získat a následně zobrazit obalové těleso, a to nezávisle na tom, jaký má objekt tvar. Jediná změna byla provedena v&nbsp;callback funkci <strong>love.draw()</strong>:</p>

<pre>
<i>--</i>
<i>-- Tato funkce je volána automaticky při překreslení obsahu</i>
<i>-- okna či obrazovky.</i>
<i>--</i>
<strong>function</strong> love.draw()
    ...
    ...
    ...
    <i>-- vykreslení obalových těles</i>
    love.graphics.setColor(128, 128, 128)
    <strong>local</strong> x1,y1,x2,y2 = objects.ball1.fixture:getBoundingBox()
    love.graphics.rectangle("line", x1, y1, x2-x1, y2-y1)
    <strong>local</strong> x1,y1,x2,y2 = objects.ball2.fixture:getBoundingBox()
    love.graphics.rectangle("line", x1, y1, x2-x1, y2-y1)
    <strong>local</strong> x1,y1,x2,y2 = objects.block3.fixture:getBoundingBox()
    love.graphics.rectangle("line", x1, y1, x2-x1, y2-y1)
    ...
    ...
    ...
<strong>end</strong>
</pre>

<a href="http://fedora.cz/wp-content/uploads/2015/10/09.png"><img class="alignnone size-medium wp-image-5769" src="http://fedora.cz/wp-content/uploads/2015/10/09-450x450.png" alt="09" width="450" height="450" /></a>
<p><i>Obrázek 9: Povšimněte si, jak se při pohybu obalová tělesa &bdquo;natahují&ldquo; a neodpovídají přímo tvarům objektů.</i></p>

<p>Úplný zdrojový kód demonstračního příkladu:</p>

<pre>
<i>--</i>
<i>-- Knihovna LÖVE</i>
<i>--</i>
<i>-- Dvacátý první demonstrační příklad</i>
<i>--</i>
<i>-- Jednoduchý "svět", v němž se nachází dva míčky a jeden kvádr.</i>
<i>-- Při vykreslování scény se zvýrazní i obalová tělesa.</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>-- rozměry okna, do něhož se bude provádět vykreslování</i>
width = 600
height = 600
ground_height = 50
&nbsp;
<i>-- tíhové zrychlení</i>
G = 9.81
&nbsp;
<i>-- počet pixelů odpovídající jednomu metru v simulovaném světě</i>
pixels_per_meter = 64
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Funkce volaná při inicializaci aplikace.</i>
<i>--</i>
<strong>function</strong> love.load()
    <i>-- načtení standardního fontu a nastavení grafického režimu</i>
    <strong>local</strong> font = love.graphics.newFont(love.default_font, 40)
&nbsp;
    <i>-- inicializace grafického režimu</i>
    love.graphics.setMode(width, height, false, false, 0)
&nbsp;
    <i>-- nastavení rozměrů simulovaného světa</i>
    <i>-- (mapování fyzikálních jednotek na pixely)</i>
    love.physics.setMeter(pixels_per_meter)
&nbsp;
    <i>-- vytvoření simulovaného světa</i>
    world = love.physics.newWorld(0, G * pixels_per_meter, true)
&nbsp;
    <i>-- tabulka s tělesy</i>
    objects = {}
&nbsp;
    <i>-- těleso představující zemi</i>
    objects.ground = {}
    <i>-- počáteční umístění tělesa</i>
    objects.ground.body = love.physics.newBody(world, width/2, height-ground_height/2-40)
    <i>-- tvar a rozměry</i>
    objects.ground.shape = love.physics.newRectangleShape(0, 0, width, ground_height, -0.07)
    <i>-- propojení tvaru s tělesem</i>
    objects.ground.fixture = love.physics.newFixture(objects.ground.body, objects.ground.shape, 5)
    objects.ground.fixture:setRestitution(0.7)
&nbsp;
    <i>-- těleso představující první míček</i>
    objects.ball1 = {}
    <i>-- počáteční umístění tělesa</i>
    objects.ball1.body = love.physics.newBody(world, 400, 100, "dynamic")
    <i>-- tvar a rozměry</i>
    objects.ball1.shape = love.physics.newCircleShape(40)
    <i>-- propojení tvaru s tělesem</i>
    objects.ball1.fixture = love.physics.newFixture(objects.ball1.body, objects.ball1.shape, 5)
    objects.ball1.fixture:setRestitution(0.2)
&nbsp;
    <i>-- těleso představující druhý míček</i>
    objects.ball2 = {}
    <i>-- počáteční umístění tělesa</i>
    objects.ball2.body = love.physics.newBody(world, 260, 10, "dynamic")
    <i>-- tvar a rozměry</i>
    objects.ball2.shape = love.physics.newCircleShape(50)
    <i>-- propojení tvaru s tělesem</i>
    objects.ball2.fixture = love.physics.newFixture(objects.ball2.body, objects.ball2.shape, 5000)
    objects.ball2.fixture:setRestitution(0.1)
&nbsp;
    <i>-- těleso představující kvádr</i>
    objects.block3 = {}
    <i>-- počáteční umístění tělesa</i>
    objects.block3.body = love.physics.newBody(world, 400, 20, "dynamic")
    <i>-- tvar a rozměry</i>
    objects.block3.shape = love.physics.newRectangleShape(150, 10)
    <i>-- propojení tvaru s tělesem</i>
    objects.block3.fixture = love.physics.newFixture(objects.block3.body, objects.block3.shape, 5)
    objects.block3.fixture:setRestitution(0.1)
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Funkce volaná cca 30x za sekundu</i>
<i>--</i>
<strong>function</strong> love.update(dt)
    <i>-- přepočítat parametry celého "světa"</i>
    world:update(dt)
&nbsp;
    <strong>local</strong> delay = 1/30
    <strong>if</strong> dt &lt; delay <strong>then</strong>
        love.timer.sleep(delay - dt)
    <strong>end</strong>
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Tato funkce je volána automaticky při překreslení obsahu</i>
<i>-- okna či obrazovky.</i>
<i>--</i>
<strong>function</strong> love.draw()
    <i>-- vykreslení země</i>
    love.graphics.setColor(72, 160, 14)
    love.graphics.polygon("line", objects.ground.body:getWorldPoints(objects.ground.shape:getPoints()))
&nbsp;
    <i>-- vykreslení prvního tělesa (míčku)</i>
    love.graphics.setColor(250, 150, 150)
    love.graphics.circle("line", objects.ball1.body:getX(), objects.ball1.body:getY(),
                                 objects.ball1.shape:getRadius())
&nbsp;
    <i>-- vykreslení druhého tělesa (míčku)</i>
    love.graphics.setColor(150, 150, 250)
    love.graphics.circle("line", objects.ball2.body:getX(), objects.ball2.body:getY(),
                                 objects.ball2.shape:getRadius())
&nbsp;
    <i>-- vykreslení třetího tělesa (kvádru)</i>
    love.graphics.setColor(150, 250, 150)
    love.graphics.polygon("line", objects.block3.body:getWorldPoints(objects.block3.shape:getPoints()))
&nbsp;
    <i>-- vykreslení obalových těles</i>
    love.graphics.setColor(128, 128, 128)
    <strong>local</strong> x1,y1,x2,y2 = objects.ball1.fixture:getBoundingBox()
    love.graphics.rectangle("line", x1, y1, x2-x1, y2-y1)
    <strong>local</strong> x1,y1,x2,y2 = objects.ball2.fixture:getBoundingBox()
    love.graphics.rectangle("line", x1, y1, x2-x1, y2-y1)
    <strong>local</strong> x1,y1,x2,y2 = objects.block3.fixture:getBoundingBox()
    love.graphics.rectangle("line", x1, y1, x2-x1, y2-y1)
&nbsp;
    <i>-- výpis zprávy</i>
    love.graphics.setColor(250, 250, 250)
    love.graphics.print("Escape: to exit.", 20, 615)
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Callback funkce zavolaná při stisku klávesy.</i>
<i>--</i>
<strong>function</strong> love.keypressed(k)
    <strong>if</strong> k == 'escape' <strong>then</strong>
    <i>-- klávesou "Escape" se aplikace ukončí</i>
        love.event.quit()
    <strong>end</strong>
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- finito</i>
<i>--</i>
&nbsp;
</pre>

<a href="http://fedora.cz/wp-content/uploads/2015/10/10.png"><img class="alignnone size-medium wp-image-5770" src="http://fedora.cz/wp-content/uploads/2015/10/10-450x450.png" alt="10" width="450" height="450" /></a>
<p><i>Obrázek 10: Screenshot z&nbsp;demonstračního příkladu.</i></p>

<a href="http://fedora.cz/wp-content/uploads/2015/10/11.png"><img class="alignnone size-medium wp-image-5771" src="http://fedora.cz/wp-content/uploads/2015/10/11-450x450.png" alt="11" width="450" height="450" /></a>
<p><i>Obrázek 11: Povšimněte si, že při kolizi těles dochází k&nbsp;protnutí jejich bounding boxů.</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Problematika &bdquo;průstřelu&ldquo; tenkých stěn a způsob jejího řešení</h2>

<p>Při použití modulu <strong>love.physics</strong> v&nbsp;simulovaných světech, ve kterých se pohybují objekty vysokou rychlostí a kde se současně nachází úzké stěny, může dojít k&nbsp;případům, kdy kvůli numerickým chybám vzniklým při výpočtu dynamiky těles dojde k&nbsp;nechtěnému &bdquo;průstřelu&ldquo; stěny, tj.&nbsp;těleso je jakoby teleportováno na druhou stranu aniž by došlo k&nbsp;detekci kolize. Aby k&nbsp;tomu problému došlo, musí být splněny dvě tři podmínky:</p>

<ul>
<li>Těleso se musí pohybovat poměrně vysokou rychlostí.</li>
<li>Stěna musí být úzká.</li>
<li>Navíc musí být stěna taktéž pohyblivá, protože u statických objektů je použit odlišný výpočet kolizí.</li>
</ul>

<p>Podívejme se nyní na příklad, který problematiku průstřelu ilustruje. Nejprve vytvořme v&nbsp;simulovaném světě úzkou stěnu (její šířka je řízena proměnnou <strong>wall_width</strong>:</p>

<pre>
    <i>-- těleso představující stěnu</i>
    objects.wall = {}
    <i>-- počáteční umístění tělesa</i>
    objects.wall.body = love.physics.newBody(world, 200, height/2, "dynamic")
    <i>-- tvar a rozměry</i>
    <i>-- hodnota wall_width bude typicky hodně malá, například 1, 2, 3 jednotky</i>
    objects.wall.shape = love.physics.newRectangleShape(wall_width, 200)
    <i>-- propojení tvaru s tělesem</i>
    objects.wall.fixture = love.physics.newFixture(objects.wall.body, objects.wall.shape, 5)
    objects.wall.fixture:setRestitution(0.7)
</pre>

<p>Následně je do scény přidáno těleso, které se ke stěně rychle přibližuje (v&nbsp;kolmém směru, ale to ve skutečnosti není zcela nezbytné):</p>

<pre>
    <i>-- těleso představující první míček</i>
    objects.ball1 = {}
    <i>-- počáteční umístění tělesa</i>
    objects.ball1.body = love.physics.newBody(world, 550, height/2, "dynamic")
    <i>-- vysoká počáteční rychlost s vektorem směřujícím doleva</i>
    objects.ball1.body:setLinearVelocity(-10000000,0)
    <i>-- tvar a rozměry</i>
    objects.ball1.shape = love.physics.newCircleShape(5)
    <i>-- propojení tvaru s tělesem</i>
    objects.ball1.fixture = love.physics.newFixture(objects.ball1.body, objects.ball1.shape, 5)
    objects.ball1.fixture:setRestitution(0.2)
</pre>

<p>Co se nyní stane dobře ilustrují následující tři obrázky, na nichž je taktéž vidět obalové těleso míčku:</p>

<a href="http://fedora.cz/wp-content/uploads/2015/10/12.png"><img class="alignnone size-medium wp-image-5772" src="http://fedora.cz/wp-content/uploads/2015/10/12-450x450.png" alt="12" width="450" height="450" /></a>
<p><i>Obrázek 12: Začátek simulace; ve světě se nachází jen podlaha a stěna.</i></p>

<a href="http://fedora.cz/wp-content/uploads/2015/10/13.png"><img class="alignnone size-medium wp-image-5773" src="http://fedora.cz/wp-content/uploads/2015/10/13-450x450.png" alt="13" width="450" height="450" /></a>
<p><i>Obrázek 13: Ke stěně se začíná přibližovat rychle se pohybující těleso. Povšimněte si &bdquo;natažení&ldquo; jeho bounding boxu.</i></p>

<a href="http://fedora.cz/wp-content/uploads/2015/10/14.png"><img class="alignnone size-medium wp-image-5774" src="http://fedora.cz/wp-content/uploads/2015/10/14-450x450.png" alt="14" width="450" height="450" /></a>
<p><i>Obrázek 14: Těleso se pohybuje tak rychle, že algoritmus detekce kolize nezareagoval na průstřel (kulička by se měla odrazit).</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Zdrojový kód třetího demonstračního příkladu</h2>

<p>Problematiku průstřelu úzkých stěn si můžeme snadno předvést na dalším (dnes již třetím) demonstračním příkladu. V&nbsp;něm jsou vytvořena pouhá tři tělesa: nehybná podlaha, stěna (ta musí být &bdquo;dynamická&ldquo;, aby se použil správný algoritmus detekce kolize) a samotná rychle se pohybující kulička. Po spuštění by mělo dojít k&nbsp;průstřelu, na který ani jedno těleso (stěna, kulička) správně nezareaguje: kulička stěnou prolétne a stěna spadne na podlahu (dokonce se ani nenakloní). Následuje výpis zdrojového kódu dnešního třetího demonstračního příkladu:</p>

<pre>
<i>--</i>
<i>-- Knihovna LÖVE</i>
<i>--</i>
<i>-- Dvacátý druhý demonstrační příklad</i>
<i>--</i>
<i>-- Jednoduchý "svět", v němž se nachází stěna a rychle se pohybující kulička</i>
<i>-- ("střela").</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>-- rozměry okna, do něhož se bude provádět vykreslování</i>
width = 600
height = 600
&nbsp;
<i>-- parametry podlahy a stěny</i>
ground_height = 50
wall_width = 2
&nbsp;
<i>-- tíhové zrychlení</i>
G = 9.81
&nbsp;
<i>-- počet pixelů odpovídající jednomu metru v simulovaném světě</i>
pixels_per_meter = 64
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Funkce volaná při inicializaci aplikace.</i>
<i>--</i>
<strong>function</strong> love.load()
    <i>-- načtení standardního fontu a nastavení grafického režimu</i>
    <strong>local</strong> font = love.graphics.newFont(love.default_font, 40)
&nbsp;
    <i>-- inicializace grafického režimu</i>
    love.graphics.setMode(width, height, false, false, 0)
&nbsp;
    <i>-- nastavení rozměrů simulovaného světa</i>
    <i>-- (mapování fyzikálních jednotek na pixely)</i>
    love.physics.setMeter(pixels_per_meter)
&nbsp;
    <i>-- vytvoření simulovaného světa</i>
    world = love.physics.newWorld(0, G * pixels_per_meter, true)
&nbsp;
    <i>-- tabulka s tělesy</i>
    objects = {}
&nbsp;
    <i>-- těleso představující zemi</i>
    objects.ground = {}
    <i>-- počáteční umístění tělesa</i>
    objects.ground.body = love.physics.newBody(world, width/2, height-ground_height/2-40)
    <i>-- tvar a rozměry</i>
    objects.ground.shape = love.physics.newRectangleShape(width, ground_height)
    <i>-- propojení tvaru s tělesem</i>
    objects.ground.fixture = love.physics.newFixture(objects.ground.body, objects.ground.shape, 5)
    objects.ground.fixture:setRestitution(0.7)
&nbsp;
    <i>-- těleso představující stěnu</i>
    objects.wall = {}
    <i>-- počáteční umístění tělesa</i>
    objects.wall.body = love.physics.newBody(world, 200, height/2, "dynamic")
    <i>-- tvar a rozměry</i>
    objects.wall.shape = love.physics.newRectangleShape(wall_width, 200)
    <i>-- propojení tvaru s tělesem</i>
    objects.wall.fixture = love.physics.newFixture(objects.wall.body, objects.wall.shape, 5)
    objects.wall.fixture:setRestitution(0.7)
&nbsp;
    <i>-- těleso představující první míček</i>
    objects.ball1 = {}
    <i>-- počáteční umístění tělesa</i>
    objects.ball1.body = love.physics.newBody(world, 550, height/2, "dynamic")
    objects.ball1.body:setLinearVelocity(-10000000,0)
    <i>-- tvar a rozměry</i>
    objects.ball1.shape = love.physics.newCircleShape(5)
    <i>-- propojení tvaru s tělesem</i>
    objects.ball1.fixture = love.physics.newFixture(objects.ball1.body, objects.ball1.shape, 5)
    objects.ball1.fixture:setRestitution(0.2)
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Funkce volaná cca 30x za sekundu</i>
<i>--</i>
<strong>function</strong> love.update(dt)
    <i>-- přepočítat parametry celého "světa"</i>
    world:update(dt)
&nbsp;
    <strong>local</strong> delay = 1/30
    <strong>if</strong> dt &lt; delay <strong>then</strong>
        love.timer.sleep(delay - dt)
    <strong>end</strong>
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Tato funkce je volána automaticky při překreslení obsahu</i>
<i>-- okna či obrazovky.</i>
<i>--</i>
<strong>function</strong> love.draw()
    <i>-- vykreslení země</i>
    love.graphics.setColor(72, 160, 14)
    love.graphics.polygon("line", objects.ground.body:getWorldPoints(objects.ground.shape:getPoints()))
&nbsp;
    <i>-- vykreslení stěny</i>
    love.graphics.setColor(250, 100, 100)
    love.graphics.polygon("line", objects.wall.body:getWorldPoints(objects.wall.shape:getPoints()))
&nbsp;
    <i>-- vykreslení míčku</i>
    love.graphics.setColor(250, 250, 150)
    love.graphics.circle("line", objects.ball1.body:getX(), objects.ball1.body:getY(),
                                 objects.ball1.shape:getRadius())
&nbsp;
    <i>-- vykreslení obalových těles</i>
    love.graphics.setColor(128, 128, 128)
    <strong>local</strong> x1,y1,x2,y2 = objects.ball1.fixture:getBoundingBox()
    love.graphics.rectangle("line", x1, y1, x2-x1, y2-y1)
&nbsp;
    <i>-- výpis zprávy</i>
    love.graphics.setColor(250, 250, 250)
    love.graphics.print("Escape: to exit.", 20, 615)
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Callback funkce zavolaná při stisku klávesy.</i>
<i>--</i>
<strong>function</strong> love.keypressed(k)
    <strong>if</strong> k == 'escape' <strong>then</strong>
    <i>-- klávesou "Escape" se aplikace ukončí</i>
        love.event.quit()
    <strong>end</strong>
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- finito</i>
<i>--</i>
</pre>

<a href="http://fedora.cz/wp-content/uploads/2015/10/15.png"><img class="alignnone size-medium wp-image-5775" src="http://fedora.cz/wp-content/uploads/2015/10/15-450x321.png" alt="15" width="450" height="321" /></a>
<p><i>Obrázek 15: Namísto přímého vykreslení tvarů s&nbsp;využitím úseček, polyčar, kružnic a polygonů lze použít i sprity.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Použití přesnějšího výpočtu kolizí</h2>

<p>V&nbsp;enginu používaném modulem <strong>love.physics</strong> je možné provést výběr algoritmu pro výpočet kolizí. Pro statická tělesa (která se nepohybují) je implementován přesnější a současně i pomalejší výpočet, pro dynamická tělesa (která se naopak pohybují) pak výpočet rychlejší, ovšem s&nbsp;výše zmíněnou nepřesností. Pokud však programátor ví, že se v&nbsp;jeho simulovaném světě budou nacházet rychle se pohybující tělesa a úzké stěny, může algoritmus detekce kolizí pro <i>vybraná tělesa</i> jednoduše přepnout, a to konkrétně metodou <strong>Body:setBullet()</strong>. Této metodě se předává pravdivostní hodnota <strong>true</strong> či <strong>false</strong> podle toho, zda má být dané těleso považováno za &bdquo;střelu&ldquo;, tj.&nbsp;rychle se pohybující předmět či za běžné pomaleji se pohybující těleso.</p>

<p>V&nbsp;praxi se celá simulace při přepnutí míčku do režimu &bdquo;střely&ldquo; bude diametrálně odlišovat. Opět se podívejme na čtyři ilustrační obrázky, kde se míček/střela pohybuje velkou rychlostí proti úzké stěně:</p>

<a href="http://fedora.cz/wp-content/uploads/2015/10/16.png"><img class="alignnone size-medium wp-image-5776" src="http://fedora.cz/wp-content/uploads/2015/10/16-450x450.png" alt="16" width="450" height="450" /></a>
<p><i>Obrázek 16: Začátek simulace; ve světě se prozatím nachází jen podlaha a stěna.</i></p>

<a href="http://fedora.cz/wp-content/uploads/2015/10/17.png"><img class="alignnone size-medium wp-image-5777" src="http://fedora.cz/wp-content/uploads/2015/10/17-450x450.png" alt="17" width="450" height="450" /></a>
<p><i>Obrázek 17: Ke stěně se začíná přibližovat rychle se pohybující těleso (střela). Opět si povšimněte &bdquo;natažení&ldquo; jeho bounding boxu.</i></p>

<a href="http://fedora.cz/wp-content/uploads/2015/10/18.png"><img class="alignnone size-medium wp-image-5778" src="http://fedora.cz/wp-content/uploads/2015/10/18-450x450.png" alt="18" width="450" height="450" /></a>
<p><i>Obrázek 18: Došlo ke kolizi a odrazu těles &ndash; stěna se posunula směrem doleva, kulička se odrazila doprava a ztratila část své rychlosti (vektor rychlosti se současně otočil).</i></p>

<a href="http://fedora.cz/wp-content/uploads/2015/10/19.png"><img class="alignnone size-medium wp-image-5779" src="http://fedora.cz/wp-content/uploads/2015/10/19-450x450.png" alt="19" width="450" height="450" /></a>
<p><i>Obrázek 19: Jak na stěnu, tak i na kuličku začíná výrazněji působit gravitace.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Zdrojový kód čtvrtého demonstračního příkladu</h2>

<p>Přepnutí algoritmu pro výpočet kolizí na jeho přesnější a současně i pomalejší variantu je jednoduché, což je ostatně patrné i z&nbsp;následujícího úryvku zdrojového kódu, v&nbsp;němž je příslušný programový řádek zvýrazněn. Povšimněte si, že volbu algoritmu je možné provést pro každé těleso zvlášť, takže závisí jen a pouze na vývojáři, ve kterých případech bude preferovat rychlejší výpočet a kdy naopak výpočet přesnější:</p>

<pre>
<i>--</i>
<i>-- Funkce volaná při inicializaci aplikace.</i>
<i>--</i>
<strong>function</strong> love.load()
    ...
    ...
    ...
    <i>-- těleso představující první míček</i>
    objects.ball1 = {}
    <i>-- počáteční umístění tělesa</i>
    objects.ball1.body = love.physics.newBody(world, 550, height/2, "dynamic")
    objects.ball1.body:setLinearVelocity(-10000000,0)
    <i>-- nutno nastavit na "true" - použije se pomalejší ale přesnější algoritmus výpočtu</i>
    <strong>objects.ball1.body:setBullet(true)</strong>
    <i>-- tvar a rozměry</i>
    objects.ball1.shape = love.physics.newCircleShape(5)
    <i>-- propojení tvaru s tělesem</i>
    objects.ball1.fixture = love.physics.newFixture(objects.ball1.body, objects.ball1.shape, 5)
    objects.ball1.fixture:setRestitution(0.2)
    ...
    ...
    ...
<strong>end</strong>
</pre>

<p>Podívejme se nyní na výpis zdrojového kódu dnešního čtvrtého demonstračního příkladu:</p>

<pre>
<i>--</i>
<i>-- Knihovna LÖVE</i>
<i>--</i>
<i>-- Dvacátý třetí demonstrační příklad</i>
<i>--</i>
<i>-- Vyřešení problémů s rychle se pohybujícími tělesy</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>-- rozměry okna, do něhož se bude provádět vykreslování</i>
width = 600
height = 600
&nbsp;
<i>-- parametry podlahy a stěny</i>
ground_height = 50
wall_width = 2
&nbsp;
<i>-- tíhové zrychlení</i>
G = 9.81
&nbsp;
<i>-- počet pixelů odpovídající jednomu metru v simulovaném světě</i>
pixels_per_meter = 64
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Funkce volaná při inicializaci aplikace.</i>
<i>--</i>
<strong>function</strong> love.load()
    <i>-- načtení standardního fontu a nastavení grafického režimu</i>
    <strong>local</strong> font = love.graphics.newFont(love.default_font, 40)
&nbsp;
    <i>-- inicializace grafického režimu</i>
    love.graphics.setMode(width, height, false, false, 0)
&nbsp;
    <i>-- nastavení rozměrů simulovaného světa</i>
    <i>-- (mapování fyzikálních jednotek na pixely)</i>
    love.physics.setMeter(pixels_per_meter)
&nbsp;
    <i>-- vytvoření simulovaného světa</i>
    world = love.physics.newWorld(0, G * pixels_per_meter, true)
&nbsp;
    <i>-- tabulka s tělesy</i>
    objects = {}
&nbsp;
    <i>-- těleso představující zemi</i>
    objects.ground = {}
    <i>-- počáteční umístění tělesa</i>
    objects.ground.body = love.physics.newBody(world, width/2, height-ground_height/2-40)
    <i>-- tvar a rozměry</i>
    objects.ground.shape = love.physics.newRectangleShape(width, ground_height)
    <i>-- propojení tvaru s tělesem</i>
    objects.ground.fixture = love.physics.newFixture(objects.ground.body, objects.ground.shape, 5)
    objects.ground.fixture:setRestitution(0.7)
&nbsp;
    <i>-- těleso představující stěnu</i>
    objects.wall = {}
    <i>-- počáteční umístění tělesa</i>
    objects.wall.body = love.physics.newBody(world, 200, height/2, "dynamic")
    <i>-- tvar a rozměry</i>
    objects.wall.shape = love.physics.newRectangleShape(wall_width, 200)
    <i>-- propojení tvaru s tělesem</i>
    objects.wall.fixture = love.physics.newFixture(objects.wall.body, objects.wall.shape, 5)
    objects.wall.fixture:setRestitution(0.7)
&nbsp;
    <i>-- těleso představující první míček</i>
    objects.ball1 = {}
    <i>-- počáteční umístění tělesa</i>
    objects.ball1.body = love.physics.newBody(world, 550, height/2, "dynamic")
    objects.ball1.body:setLinearVelocity(-10000000,0)
    <i>-- nutno nastavit na "true" - použije se pomalejší ale přesnější algoritmus výpočtu</i>
    objects.ball1.body:setBullet(true)
    <i>-- tvar a rozměry</i>
    objects.ball1.shape = love.physics.newCircleShape(5)
    <i>-- propojení tvaru s tělesem</i>
    objects.ball1.fixture = love.physics.newFixture(objects.ball1.body, objects.ball1.shape, 5)
    objects.ball1.fixture:setRestitution(0.2)
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Funkce volaná cca 30x za sekundu</i>
<i>--</i>
<strong>function</strong> love.update(dt)
    <i>-- přepočítat parametry celého "světa"</i>
    world:update(dt)
&nbsp;
    <strong>local</strong> delay = 1/30
    <strong>if</strong> dt &lt; delay <strong>then</strong>
        love.timer.sleep(delay - dt)
    <strong>end</strong>
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Tato funkce je volána automaticky při překreslení obsahu</i>
<i>-- okna či obrazovky.</i>
<i>--</i>
<strong>function</strong> love.draw()
    <i>-- vykreslení země</i>
    love.graphics.setColor(72, 160, 14)
    love.graphics.polygon("line", objects.ground.body:getWorldPoints(objects.ground.shape:getPoints()))
&nbsp;
    <i>-- vykreslení stěny</i>
    love.graphics.setColor(250, 100, 100)
    love.graphics.polygon("line", objects.wall.body:getWorldPoints(objects.wall.shape:getPoints()))
&nbsp;
    <i>-- vykreslení míčku</i>
    love.graphics.setColor(250, 250, 150)
    love.graphics.circle("line", objects.ball1.body:getX(), objects.ball1.body:getY(),
                                 objects.ball1.shape:getRadius())
&nbsp;
    <i>-- vykreslení obalových těles</i>
    love.graphics.setColor(128, 128, 128)
    <strong>local</strong> x1,y1,x2,y2 = objects.ball1.fixture:getBoundingBox()
    love.graphics.rectangle("line", x1, y1, x2-x1, y2-y1)
&nbsp;
    <i>-- výpis zprávy</i>
    love.graphics.setColor(250, 250, 250)
    love.graphics.print("Escape: to exit.", 20, 615)
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Callback funkce zavolaná při stisku klávesy.</i>
<i>--</i>
<strong>function</strong> love.keypressed(k)
    <strong>if</strong> k == 'escape' <strong>then</strong>
    <i>-- klávesou "Escape" se aplikace ukončí</i>
        love.event.quit()
    <strong>end</strong>
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- finito</i>
<i>--</i>
</pre>

<a href="http://fedora.cz/wp-content/uploads/2015/10/20.gif"><img class="alignnone size-medium wp-image-5780" src="http://fedora.cz/wp-content/uploads/2015/10/20.gif" alt="20" width="400" height="300" /></a>
<p><i>Obrázek 20: V&nbsp;příští části miniseriálu o modulu <strong>love.physics</strong> si ukážeme způsob vzájemného propojení těles různými vazbami.</i></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Repositář se zdrojovými kódy všech čtyř dnešních demonstračních příkladů</h2>

<p>Všechny čtyři demonstrační příklady, s&nbsp;nimiž jsme se v&nbsp;dnešním článku seznámili, byly uloženy do Git repositáře umístěného na GitHubu (<a href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>). Každý demonstrační příklad je, podobně jako tomu bylo i u obou příkladů z&nbsp;předchozího článku, tvořen pouze zdrojovým kódem uloženým v&nbsp;souboru <strong>main.lua</strong>:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Zdrojový kód</th></tr>
<tr><td>1</td><td>example20</td><td><a href="https://github.com/tisnik/presentations/tree/master/love/example20">https://github.com/tisnik/presentations/tree/master/love/example20</a></td></tr>
<tr><td>2</td><td>example21</td><td><a href="https://github.com/tisnik/presentations/tree/master/love/example21">https://github.com/tisnik/presentations/tree/master/love/example21</a></td></tr>
<tr><td>3</td><td>example22</td><td><a href="https://github.com/tisnik/presentations/tree/master/love/example22">https://github.com/tisnik/presentations/tree/master/love/example22</a></td></tr>
<tr><td>4</td><td>example23</td><td><a href="https://github.com/tisnik/presentations/tree/master/love/example23">https://github.com/tisnik/presentations/tree/master/love/example23</a></td></tr>
</table>

<p>Poznámka: demonstrační příklady jsou číslovány průběžně, protože tento článek (alespoň nepřímo) navazuje na seriál o programovacích jazycích vhodných pro výuku počítačové grafiky.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Odkazy na Internetu</h2>

<ol>

<li>Bounding Boxes<br />
<a href="http://www.3dkingdoms.com/weekly/weekly.php?a=21">http://www.3dkingdoms.com/weekly/weekly.php?a=21</a>
</li>

<li>Box2D (stránka projektu)<br />
<a href="http://box2d.org/">http://box2d.org/</a>
</li>

<li>Box2D FAQ<br />
<a href="https://github.com/erincatto/Box2D/wiki/FAQ">https://github.com/erincatto/Box2D/wiki/FAQ</a>
</li>

<li>Box2D v2.2.0 User Manual<br />
<a href="http://www.box2d.org/manual.html">http://www.box2d.org/manual.html</a>
</li>

<li>Bounding Box (OpenStreetMap)<br />
<a href="http://wiki.openstreetmap.org/wiki/Bounding_Box">http://wiki.openstreetmap.org/wiki/Bounding_Box</a>
</li>

<li>Minimum Bounding Rectange (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Minimum_bounding_rectangle">https://en.wikipedia.org/wiki/Minimum_bounding_rectangle</a>
</li>

<li>Minimum bounding box (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Minimum_bounding_box">https://en.wikipedia.org/wiki/Minimum_bounding_box</a>
</li>

<li>2D Bounding Box Collision Detection<br />
<a href="http://www.dreamincode.net/forums/topic/180069-xna-2d-bounding-box-collision-detection/">http://www.dreamincode.net/forums/topic/180069-xna-2d-bounding-box-collision-detection/</a>
</li>

<li>Chipmunk2D (další fyzikální engine)<br />
<a href="http://chipmunk-physics.net/">http://chipmunk-physics.net/</a>
</li>

<li>Physics Engine (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Physics_engine">https://en.wikipedia.org/wiki/Physics_engine</a>
</li>

<li>Modul love.physics<br />
<a href="https://love2d.org/wiki/love.physics">https://love2d.org/wiki/love.physics</a>
</li>

<li>Modul love.physics: Objekt typu World<br />
<a href="https://love2d.org/wiki/World">https://love2d.org/wiki/World</a>
</li>

<li>Modul love.physics: Objekt typu Body<br />
<a href="https://love2d.org/wiki/Body">https://love2d.org/wiki/Body</a>
</li>

<li>Modul love.physics: Objekt typu Shape<br />
<a href="https://love2d.org/wiki/Shape">https://love2d.org/wiki/Shape</a>
</li>

<li>Modul love.physics: Objekt typu Joint<br />
<a href="https://love2d.org/wiki/Joint">https://love2d.org/wiki/Joint</a>
</li>

<li>Modul love.physics: Objekt typu Fixture<br />
<a href="https://love2d.org/wiki/Fixture">https://love2d.org/wiki/Fixture</a>
</li>

<li>Particle Systems From the Ground Up<br />
<a href="http://buildnewgames.com/particle-systems/">http://buildnewgames.com/particle-systems/</a>
</li>

<li>Particle Systems<br />
<a href="http://natureofcode.com/book/chapter-4-particle-systems/">http://natureofcode.com/book/chapter-4-particle-systems/</a>
</li>

<li>Domovská stránka systému LÖVE<br />
<a href="http://love2d.org/">http://love2d.org/</a>
</li>

<li>Dokumentace k&nbsp;systému LÖVE<br />
<a href="http://love2d.org/wiki/love">http://love2d.org/wiki/love</a>
</li>

<li>Domovská stránka programovacího jazyka Lua<br />
<a href="http://www.lua.org/ ">http://www.lua.org/ </a>
</li>

<li>Seriál o programovacím jazyku Lua (root.cz):<br />
<a href="http://www.root.cz/serialy/programovaci-jazyk-lua/">http://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>Domovská stránka systému LÖVE<br />
<a href="http://love2d.org/">http://love2d.org/</a>
</li>

<li>Domovská stránka programovacího jazyka Lua<br />
<a href="http://www.lua.org/ ">http://www.lua.org/ </a>
</li>

<li>Web o Lieru, Gusanos, GeneRally, Atari atd.<br />
<a href="http://karelik.wz.cz/">http://karelik.wz.cz/</a>
</li>

<li>Web o Lieru, Gusanos<br />
<a href="http://karelik.wz.cz/gusanos.php">http://karelik.wz.cz/gusanos.php</a>
</li>

<li>GUSANOS<br />
<a href="http://gusanos.sourceforge.net/">http://gusanos.sourceforge.net/</a>
</li>

<li>GUSANOS Download<br />
<a href="http://sourceforge.net/projects/gusanos/">http://sourceforge.net/projects/gusanos/</a>
</li>

<li>Lua<br />
<a href="http://www.linuxexpres.cz/praxe/lua">http://www.linuxexpres.cz/praxe/lua</a>
</li>

<li>Lua<br />
<a href="http://cs.wikipedia.org/wiki/Lua">http://cs.wikipedia.org/wiki/Lua</a>
</li>

<li>Lua (programming language)<br />
<a href="http://en.wikipedia.org/wiki/Lua_(programming_language)">http://en.wikipedia.org/wiki/Lua_(programming_language)</a>
</li>

<li>The Lua Programming Language<br />
<a href="http://www.tiobe.com/index.php/paperinfo/tpci/Lua.html">http://www.tiobe.com/index.php/paperinfo/tpci/Lua.html</a>
</li>

<li>Lua Programming Gems<br />
<a href="http://www.lua.org/gems/">http://www.lua.org/gems/</a>
</li>

<li>LuaForge<br />
<a href="http://luaforge.net/">http://luaforge.net/</a>
</li>

<li>Forge project tree<br />
<a href="http://luaforge.net/softwaremap/trove_list.php">http://luaforge.net/softwaremap/trove_list.php</a>
</li>

<li>SdlBasic home page<br />
<a href="http://www.sdlbasic.altervista.org/main/">http://www.sdlbasic.altervista.org/main/</a>
</li>

<li>SdlBasic examples<br />
<a href="http://nitrofurano.linuxkafe.com/sdlbasic/">http://nitrofurano.linuxkafe.com/sdlbasic/</a>
</li>

<li>SdlBasic na Wikipedii<br />
<a href="http://en.wikipedia.org/wiki/SdlBasic">http://en.wikipedia.org/wiki/SdlBasic</a>
</li>

<li>Simple DirectMedia Layer<br />
<a href="http://en.wikipedia.org/wiki/Simple_DirectMedia_Layer">http://en.wikipedia.org/wiki/Simple_DirectMedia_Layer</a>
</li>

<li>SDLBASIC &ndash; The high-level interpreter for all?<br />
<a href="http://openbytes.wordpress.com/2008/11/08/sdlbasic-the-high-level-interpreter-for-all/">http://openbytes.wordpress.com/2008/11/08/sdlbasic-the-high-level-interpreter-for-all/</a>
</li>

<li>FreeBasic home page<br />
<a href="http://www.freebasic.net/">http://www.freebasic.net/</a>
</li>

<li>FreeBASIC (Wikipedia EN)<br />
<a href="https://en.wikipedia.org/wiki/FreeBASIC">https://en.wikipedia.org/wiki/FreeBASIC</a>
</li>

<li>FreeBASIC Wiki<br />
<a href="http://www.freebasic.net/wiki/wikka.php?wakka=FBWiki">http://www.freebasic.net/wiki/wikka.php?wakka=FBWiki</a>
</li>

<li>FreeBASIC Manual<br />
<a href="http://www.freebasic.net/wiki/wikka.php?wakka=DocToc">http://www.freebasic.net/wiki/wikka.php?wakka=DocToc</a>
</li>

<li>FreeBASIC (Wikipedia CZ)<br />
<a href="http://cs.wikipedia.org/wiki/FreeBASIC">http://cs.wikipedia.org/wiki/FreeBASIC</a>
</li>

<li>The Griffon Legend<br />
<a href="http://syn9.thingie.net/?table=griffonlegend">http://syn9.thingie.net/?table=griffonlegend</a>
</li>

<li>Seriál Letní škola programovacího jazyka Logo<br />
<a href="http://www.root.cz/serialy/letni-skola-programovaciho-jazyka-logo/">http://www.root.cz/serialy/letni-skola-programovaciho-jazyka-logo/</a>
</li>

<li>Scratch: oficiální stránka projektu<br />
<a href="http://scratch.mit.edu/">http://scratch.mit.edu/</a>
</li>

<li>Scratch: galerie projektů vytvořených ve Scratchi<br />
<a href="http://scratch.mit.edu/galleries/browse/newest">http://scratch.mit.edu/galleries/browse/newest</a>
</li>

<li>Scratch: nápověda<br />
<a href="file:///usr/share/scratch/Help/en/index.html">file:///usr/share/scratch/Help/en/index.html</a>
</li>

<li>Scratch: obrazovky nápovědy<br />
<a href="file:///usr/share/scratch/Help/en/allscreens.html">file:///usr/share/scratch/Help/en/allscreens.html</a>
</li>

<li>Scratch (Wikipedie CZ)<br />
<a href="http://cs.wikipedia.org/wiki/Scratch">http://cs.wikipedia.org/wiki/Scratch</a>
</li>

<li>Scratch (programming language)<br />
<a href="http://en.wikipedia.org/wiki/Scratch_(programming_language)">http://en.wikipedia.org/wiki/Scratch_(programming_language)</a>
</li>

<li>Scratch Modification<br />
<a href="http://wiki.scratch.mit.edu/wiki/Scratch_Modification">http://wiki.scratch.mit.edu/wiki/Scratch_Modification</a>
</li>

<li>Scratch Lowers Resistance to Programming<br />
<a href="http://www.wired.com/gadgetlab/2009/03/scratch-lowers/">http://www.wired.com/gadgetlab/2009/03/scratch-lowers/</a>
</li>

<li>Snap!<br />
<a href="http://snap.berkeley.edu/">http://snap.berkeley.edu/</a>
</li>

<li>Prostředí Snap!<br />
<a href="http://snap.berkeley.edu/snapsource/snap.html">http://snap.berkeley.edu/snapsource/snap.html</a>
</li>

<li>Alternatives to Scratch<br />
<a href="http://wiki.scratch.mit.edu/wiki/Alternatives_to_Scratch">http://wiki.scratch.mit.edu/wiki/Alternatives_to_Scratch</a>
</li>

<li>Basic-256 home page<br />
<a href="http://www.basic256.org/index_en">http://www.basic256.org/index_en</a>
</li>

<li>Basic-256 Language Documentation<br />
<a href="http://doc.basic256.org/doku.php">http://doc.basic256.org/doku.php</a>
</li>

<li>Basic-256 Art Gallery<br />
<a href="http://www.basic256.org/artgallery">http://www.basic256.org/artgallery</a>
</li>

<li>Basic-256 Tutorial<br />
<a href="http://www.basic256.org/tutorials">http://www.basic256.org/tutorials</a>
</li>

<li>Why BASIC?<br />
<a href="http://www.basic256.org/whybasic">http://www.basic256.org/whybasic</a>
</li>

<li>A book to teach ANYBODY how to program a computer (using BASIC)<br />
<a href="http://www.basicbook.org/">http://www.basicbook.org/</a>
</li>

<li>BASIC Computer Games (published 1978) - Hammurabi<br />
<a href="http://atariarchives.org/basicgames/showpage.php?page=78">http://atariarchives.org/basicgames/showpage.php?page=78</a>
</li>

<li>Hamurabi - zdrojový kód v BASICu<br />
<a href="http://www.dunnington.u-net.com/public/basicgames/HMRABI">http://www.dunnington.u-net.com/public/basicgames/HMRABI</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2015</small></p>
</body>
</html>

