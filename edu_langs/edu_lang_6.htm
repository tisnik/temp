<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Fyzikální engine implementovaný v knihovně LÖVE</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Fyzikální engine implementovaný v knihovně LÖVE</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Knihovna LÖVE, s&nbsp;jejímiž základními vlastnostmi jsme se seznámili <a href="http://fedora.cz/stitek/vyuka/">v&nbsp;seriálu o programovacích jazycích i knihovnách určených pro výuku počítačové grafiky</a>, obsahuje i poměrně snadno použitelný fyzikální engine založený na známém projektu Box2D. Dnes si na dvojici demonstračních příkladů ukážeme některé možnosti, které tento fyzikální engine vývojářům přináší.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Fyzikální engine implementovaný v&nbsp;knihovně LÖVE</a></p>
<p><a href="#k02">2. Modul <strong>love.physics</strong></a></p>
<p><a href="#k03">3. Základní objekty, které jsou využívané modulem <strong>love.physics</strong></a></p>
<p><a href="#k04">4. Vytvoření simulovaného 2D světa</a></p>
<p><a href="#k05">5. Vytvoření &bdquo;podlahy&ldquo; v&nbsp;simulovaném světě</a></p>
<p><a href="#k06">6. Přidání dvojice padajících kvádrů</a></p>
<p><a href="#k07">7. Automatická změna stavu simulovaného světa</a></p>
<p><a href="#k08">8. Vykreslení objektů tvořících simulovaný svět</a></p>
<p><a href="#k09">9. Úplný zdrojový kód prvního demonstračního příkladu</a></p>
<p><a href="#k10">10. Změna odrazivosti těles</a></p>
<p><a href="#k11">11. Naklonění kvádru v&nbsp;simulovaném světě</a></p>
<p><a href="#k12">12. Úplný zdrojový kód druhého demonstračního příkladu</a></p>
<p><a href="#k13">13. Repositář se zdrojovými kódy obou dnešních demonstračních příkladů</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Fyzikální engine implementovaný v&nbsp;knihovně LÖVE</h2>

<p>Knihovnu <i>LÖVE</i>, kterou jsme si popsali v&nbsp;předchozích částech <a href="http://fedora.cz/stitek/vyuka/">seriálu o programovacích jazycích a knihovnách vhodných pro výuku počítačové grafiky</a>, je možné rozdělit na dvě části. V&nbsp;první části nalezneme základní moduly určené skutečně pro tvorbu dvourozměrných her, interaktivních animací či grafických dem. Ve druhé, rozšiřující části, se pak jedná o moduly, které mají své uplatnění ve specifických případech. Připomeňme si ve stručnosti, že mezi základní moduly, které knihovna LÖVE nabízí vývojářům a samozřejmě taktéž studentům či dalším zájemcům o počítačovou grafiku, patří především moduly určené pro práci s&nbsp;plošnou (2D) grafikou (<strong>love.graphics</strong>, <strong>love.font</strong> a <strong>love.image</strong>, v&nbsp;menší míře pak i <strong>love.window</strong>), zvuky a hudbou (<strong>love.audio</strong> a <strong>love.sound</strong>) a se vstupními zařízeními (<strong>love.event</strong>, <strong>love.joystick</strong>, <strong>love.mouse</strong> a <strong>love.keyboard</strong>). Mezi rozšiřující moduly, které naleznou uplatnění jen v&nbsp;některých aplikacích, pak můžeme zařadit <strong>love.filesystem</strong>, <strong>love.math</strong>, <strong>love.timer</strong> a <strong>love.thread</strong>.</p>

<a href="http://fedora.cz/wp-content/uploads/2015/09/01.png"><img class="alignnone size-medium wp-image-5733" src="http://fedora.cz/wp-content/uploads/2015/09/01-450x450.png" alt="01" width="450" height="450" /></a>
<p><i>Obrázek 1: První snímek simulace využívající fyzikální engine z&nbsp;knihovny LÖVE.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Modul <strong>love.physics</strong></h2>

<p>Dnes se budeme zabývat popisem pravděpodobně nejsložitějšího modulu, který lze v&nbsp;knihovně <i>LÖVE</i> nalézt. Jedná se o modul nazvaný <strong>love.physics</strong>, který programátorům zprostředkovává přístup ke známému fyzikálnímu engine <i>Box2D</i>. S&nbsp;využitím tohoto engine je možné simulovat vzájemné interakce (kolize a odrazy) pevných dvojrozměrných těles, vytvářet složitější objekty složené ze vzájemně provázaných základních tvarů (<i>shape</i>) a těles (<i>body</i>) i ovlivňovat trajektorii pohybujících se těles s&nbsp;využitím externích sil, které mohou na tato tělesa různým způsobem působit. Asi nejčastěji využívanou externí silou je pochopitelně gravitace. Taktéž je možné libovolnou část tělesa navázat ke kurzoru myši, takže se současně s&nbsp;pohybem myši pohybuje i tato část tělesa, která může ovlivnit i části další, s&nbsp;nimiž je spojena s&nbsp;využitím programově vytvořené vazby. To jsou však již poněkud složitější případy, kterými se dnes nebudeme zabývat. Naopak se zaměříme na popis základních konceptů, na nichž je modul <strong>love.physics</strong> postaven a vytvoříme si jednoduchý dvourozměrný svět s&nbsp;několika padajícími a vzájemně se odrážejícími tělesy.</p>

<a href="http://fedora.cz/wp-content/uploads/2015/09/02.png"><img class="alignnone size-medium wp-image-5734" src="http://fedora.cz/wp-content/uploads/2015/09/02-450x450.png" alt="02" width="450" height="450" /></a>
<p><i>Obrázek 2: Další snímek ze simulace využívající fyzikální engine z&nbsp;knihovny LÖVE.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Základní objekty, které jsou využívané modulem <strong>love.physics</strong></h2>

<p>Před použitím modulu <strong>love.physics</strong> ve vlastních aplikacích je nutné pochopit, s&nbsp;jakými objekty (ve smyslu objektově orientovaného programování, nikoli ve smyslu reálných objektů ve vykreslované scéně) engine tohoto modulu pracuje. Většina operací, tj.&nbsp;především vlastní simulace pohybu těles, pracuje s&nbsp;pěti typy objektů, my si však prozatím vystačíme se čtyřmi typy: <strong>World</strong>, <strong>Body</strong>, <strong>Shape</strong> a <strong>Fixture</strong>:</p>

<a href="http://fedora.cz/wp-content/uploads/2015/09/031.png"><img class="alignnone size-medium wp-image-5735" src="http://fedora.cz/wp-content/uploads/2015/09/031-450x450.png" alt="03" width="450" height="450" /></a>
<p><i>Obrázek 3: Vztah mezi čtyřmi základními typy objektů: World, Body(ies), Shape(s) a Fixture(s).</i></p>

<p>Popišme si tyto typy objektů podrobněji:</p>

<ol>

<li><strong>World</strong> &ndash; tento objekt představuje celý dvojrozměrný &bdquo;svět&ldquo;, ve kterém simulace pohybu a vzájemné interakce těles (kolize, odrazy) probíhá. Jedná se o obdélníkovou oblast, jenž představuje hranice, ve kterých by měly ležet vrcholy všech těles, přesněji řečeno všech tvarů, ze kterých se tělesa skládají. Nastavená hranice by měla být dostatečně velká, aby viditelná tělesa tuto hranici nemohla překročit, protože simulace probíhají pouze uvnitř simulovaného světa (sami si můžete ve starších verzích knihovny LÖVE vyzkoušet, co se stane, když bude hranice ležet v&nbsp;ploše obrazovky a těleso tuto hranici překročí &ndash; pohyb tělesa se zastaví a přestanou pracovat i detektory kolizí, nastavení hranice však už v&nbsp;novějších verzích knihovny LÖVE není nutné použít). Na druhou stranu příliš rozsáhlý simulovaný svět může zpomalovat výpočty vzájemných kolizí těles. Při vytváření simulovaného světa lze zvolit velikost tíhového zrychlení (tj.&nbsp;vlastně sílu gravitace a dokonce i její vektor).</li>

<li><strong>Body</strong> &ndash; tento objekt představuje nestlačitelnou hmotu umístěnou v&nbsp;simulovaném světě. Při vytváření tělesa lze nastavit jeho souřadnice v&nbsp;rámci simulovaného světa, úhel natočení, hustotu, těžiště (v&nbsp;kontextu této knihovny se jedná o bod, ve kterém je soustředěna hmotnost tělesa) i další fyzikální parametry. V&nbsp;případě, že je hmotnost tělesa nulová, nepůsobí na těleso gravitace. Existují i speciální typy těles nazývané střely (<i>bullets</i>), které se od &bdquo;běžných&ldquo; těles odlišují především použitím přesnějšího (a bohužel také pomalejšího) algoritmu použitého pro detekci kolizí. V&nbsp;případě, že by byl použit základní algoritmus detekce kolizí a v&nbsp;simulovaném světě by se velkou rychlostí pohybovala například střela proti tenké stěně, mohlo by se stát, že by střela touto stěnou prolétla, aniž by byla kolize správně vyhodnocena. Použitím střel se budeme zabývat v&nbsp;navazujících částech tohoto seriálu.</li>

<li><strong>Shape</strong> &ndash; geometrický tvar, který může být přiřazený k&nbsp;tělesu. Tvar představuje hranici tělesa, která je použita při detekci kolizí. V&nbsp;současné verzi knihovny <strong>love.physics</strong> je repertoár použitelných tvarů omezen pouze na konvexní uzavřené polygony a kruhy, protože výpočty kolizí s&nbsp;nekonvexními tvary jsou složitější než s&nbsp;tvary konvexními (ve skutečnosti se nejedná přímo o omezení knihovny <strong>love.physics</strong>, ale omezení dané C++ knihovnou <strong>Box2D</strong>, jejíž funkce a metody jsou interně volány). S&nbsp;využitím tvaru přiřazeného k&nbsp;tělesu je možné vypočítat i celkovou hmotnost tělesa a souřadnice jeho těžiště.</li>

<li><strong>Fixture</strong> &ndash; tento objekt zjednodušeně řečeno představuje vazbu mezi již dříve vytvořeným tvarem (<i>shape</i>) a tělesem (<i>body</i>). V&nbsp;nejjednodušším případě musí programátor pouze vytvořit těleso, následně specifikovat jeho tvar a spojit tyto dva objekty s&nbsp;využitím <i>fixture</i>. Existují i složitější případy, kdy je například nutné zadat odrazivost tělesa atd. Tyto případy si taktéž postupně vysvětlíme.</li>

<li><strong>Joint</strong> &ndash; tento pátý typ objektu (který nebyl na třetím obrázku zobrazen) představuje vazbu mezi tělesy, které se nachází v&nbsp;simulovaném světě. Existuje několik typů vazeb, například vazba, u níž je zadána vzdálenost dvou těles, přičemž simulační engine se snaží tato tělesa natočit a posunout tak, aby byla zvolená vazba splněna (samotný objekt představující vazbu je neviditelný, ovšem samozřejmě je možné například získat souřadnice koncových bodů vazby a ty vykreslit formou úseček). Je však možné použít i další typy vazeb, například vazbu představující kladku či páku apod. V&nbsp;dnešních demonstračních příkladech nejsou vazby použity, zabývat se jimi budeme až v&nbsp;navazujících článcích.</li>

</ol>

<a href="http://fedora.cz/wp-content/uploads/2015/09/041.png"><img class="alignnone size-medium wp-image-5736" src="http://fedora.cz/wp-content/uploads/2015/09/041-450x450.png" alt="04" width="450" height="450" /></a>
<p><i>Obrázek 4: Další snímek ze simulace využívající fyzikální engine z&nbsp;knihovny LÖVE.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Vytvoření simulovaného 2D světa</h2>

<p>Výše uvedený popis typů objektů, s&nbsp;nimiž je nutné v&nbsp;modulu <strong>love.physics</strong> pracovat, je sice obsáhlý a pravděpodobně i poněkud nesrozumitelný, ve skutečnosti je však vytvoření reálné fyzikální simulace poměrně přímočaré &ndash; ostatně náš první demonstrační příklad má pouhých 128 řádků zdrojového kódu, a to obsahuje relativně velké množství komentářů. Podívejme se tedy na to, jak lze vytvořit simulovaný fyzikální svět obsahující nepohyblivou &bdquo;podlahu&ldquo; a dva kvádry, které na tuto podlahu padají (označení &bdquo;kvádr&ldquo; sice není ve 2D světě přesné, ovšem o tělesech je vhodné uvažovat jako o reálných předmětech s&nbsp;hmotností a odrazivostí, nikoli o nehmotných 2D &bdquo;papírcích&ldquo;). Kostra demonstračního příkladu se prakticky ničím neliší od všech předchozích demonstračních příkladů &ndash; nachází se zde jen několik prozatím prázdných callback funkcí volaných při vzniku různých typů událostí:</p>

<pre>
<i>--</i>
<i>-- Knihovna LÖVE</i>
<i>--</i>
<i>-- Osmnáctý demonstrační příklad</i>
<i>--</i>
<i>-- Jednoduchý "svět", v němž se nachází dva kvádry.</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Funkce volaná při inicializaci aplikace.</i>
<i>--</i>
<strong>function</strong> love.load()
    ...
    ...
    ...
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Funkce volaná cca 30x za sekundu</i>
<i>--</i>
<strong>function</strong> love.update(dt)
    ...
    ...
    ...
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Tato funkce je volána automaticky při překreslení obsahu</i>
<i>-- okna či obrazovky.</i>
<i>--</i>
<strong>function</strong> love.draw()
    ...
    ...
    ...
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Callback funkce zavolaná při stisku klávesy.</i>
<i>--</i>
<strong>function</strong> love.keypressed(k)
    ...
    ...
    ...
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- finito</i>
<i>--</i>
</pre>

<p>Do zdrojového kódu přidáme volání funkcí, které vytvoří simulovaný svět. Nejprve je nutné nastavit měřítko pro přepočet mezi pixely a metry; v&nbsp;našem konkrétním případě odpovídá 64 pixelů jednomu metru v&nbsp;simulovaném světě. Proč je však nutné nastavovat měřítko? Mnohé parametry (tíhové zrychlení atd.) jsou specifikovány s&nbsp;využitím fyzikálních jednotek, zatímco při vykreslování či při čtení pozice kurzoru myši se používají bezrozměrné pixely. Následně se svět skutečně vytvoří zavoláním funkce <strong>love.physics.newWorld()</strong>, které se předá vektor představující tíhové zrychlení (způsobené pro zjednodušení pouze gravitační silou):</p>

<pre>
<i>-- tíhové zrychlení</i>
G = 9.81
&nbsp;
<i>-- počet pixelů odpovídající jednomu metru v simulovaném světě</i>
pixels_per_meter = 64
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Funkce volaná při inicializaci aplikace.</i>
<i>--</i>
<strong>function</strong> love.load()
    <i>-- nastavení rozměrů simulovaného světa</i>
    <i>-- (mapování fyzikálních jednotek na pixely)</i>
    love.physics.setMeter(pixels_per_meter)
&nbsp;
    <i>-- vytvoření simulovaného světa</i>
    world = love.physics.newWorld(0, G * pixels_per_meter, true)
&nbsp;
    ...
    ...
    ...
<strong>end</strong>
</pre>

<a href="http://fedora.cz/wp-content/uploads/2015/09/051.png"><img class="alignnone size-medium wp-image-5737" src="http://fedora.cz/wp-content/uploads/2015/09/051-450x450.png" alt="05" width="450" height="450" /></a>
<p><i>Obrázek 5: Další snímek ze simulace využívající fyzikální engine z&nbsp;knihovny LÖVE.</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Vytvoření &bdquo;podlahy&ldquo; v&nbsp;simulovaném světě</h2>

<p>Nové těleso se vytváří pomocí funkce <strong>love.physics.newBody()</strong>, jejímž prvním parametrem je objekt typu &bdquo;svět&ldquo;, dále se této funkci předá umístění tělesa (těžiště) v&nbsp;simulovaném světě (čtvrtý parametr je nepovinný, použijeme ho až v&nbsp;další kapitole). Další operací, kterou je nutné i u jednoduchých simulovaných světů provést, je volba a přiřazení tvaru (<i>shape</i>) ke každému tělesu. Jak jsme si již řekli v&nbsp;předchozích kapitolách, je možné pro tvar tělesa použít například konvexní polygon či kruh. V&nbsp;demonstračních příkladech se používá polygon ve tvaru obdélníku vytvářený funkcí (opět ne metodou!) nazvanou <strong>love.physics.newRectangleShape()</strong>. Parametry předané této funkci specifikují rozměry obdélníku (nikoli však umístění v&nbsp;simulovaném světě, to již známe). Následně se těleso musí spojit s&nbsp;tvarem pomocí objektu typu <strong>fixture</strong>. Poslední parametr při vytváření tohoto typu objektu je hustota tělesa (hmotnost se vypočte automaticky):</p>

<pre>
<i>--</i>
<i>-- Funkce volaná při inicializaci aplikace.</i>
<i>--</i>
<strong>function</strong> love.load()
    ...
    ...
    ...
    <i>-- těleso představující zemi</i>
    objects.ground = {}
    <i>-- počáteční umístění tělesa</i>
    objects.ground.body = love.physics.newBody(world, width/2, height-ground_height/2)
    <i>-- tvar a rozměry</i>
    objects.ground.shape = love.physics.newRectangleShape(width, ground_height)
    <i>-- propojení tvaru s tělesem</i>
    objects.ground.fixture = love.physics.newFixture(objects.ground.body, objects.ground.shape, 5)
    ...
    ...
    ...
<strong>end</strong>
</pre>

<a href="http://fedora.cz/wp-content/uploads/2015/09/061.png"><img class="alignnone size-medium wp-image-5738" src="http://fedora.cz/wp-content/uploads/2015/09/061-450x450.png" alt="06" width="450" height="450" /></a>
<p><i>Obrázek 6: Další snímek ze simulace využívající fyzikální engine z&nbsp;knihovny LÖVE.</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Přidání dvojice padajících kvádrů</h2>

<p>Prakticky stejným způsobem, jako se vytvořila &bdquo;podlaha&ldquo;, se do simulovaného světa přidá dvojice padajících kvádrů. Ty se od podlahy odlišují jen jediným detailem: mohou se pohybovat, což se fyzikální engine dozví ze čtvrtého nepovinného parametru funkce <strong>love.physics.newBody</strong>. Pokud je v&nbsp;tomto parametru uveden řetězec "dynamic", bude se dané těleso pohybovat a reagovat na na něj působící síly. Takže si zopakujme celý postup:</p>

<ol>
<li>Vytvoří se &bdquo;těleso&ldquo; funkcí <strong>love.physics.newBody</strong>, z&nbsp;něj se systém dozví jeho umístění a charakteristiky</li>
<li>Vytvoří se &bdquo;tvar&ldquo; funkcí <strong>love.physics.newRectangleShape</strong>, z&nbsp;něj se systém dozví fyzikální rozměry</li>
<li>&bdquo;Těleso&ldquo; a &bdquo;tvar&ldquo; se spojí pomocí <strong>love.physics.newFixture</strong>, z&nbsp;této funkce se systém navíc dozví hustotu tělesa (hmotnost si už vypočítá sám)</li>
</ol>

<pre>
<i>--</i>
<i>-- Funkce volaná při inicializaci aplikace.</i>
<i>--</i>
<strong>function</strong> love.load()
    ...
    ...
    ...
    <i>-- těleso představující první kvádr</i>
    objects.block1 = {}
    <i>-- počáteční umístění tělesa</i>
    objects.block1.body = love.physics.newBody(world, 200, 200, "dynamic")
    <i>-- tvar a rozměry</i>
    objects.block1.shape = love.physics.newRectangleShape(40, 150)
    <i>-- propojení tvaru s tělesem</i>
    objects.block1.fixture = love.physics.newFixture(objects.block1.body, objects.block1.shape, 5)
&nbsp;
    <i>-- těleso představující druhý kvádr</i>
    objects.block2 = {}
    <i>-- počáteční umístění tělesa</i>
    objects.block2.body = love.physics.newBody(world, 225, 50, "dynamic")
    <i>-- tvar a rozměry</i>
    objects.block2.shape = love.physics.newRectangleShape(100, 50)
    <i>-- propojení tvaru s tělesem</i>
    objects.block2.fixture = love.physics.newFixture(objects.block2.body, objects.block2.shape, 5)
    ...
    ...
    ...
<strong>end</strong>
</pre>

<a href="http://fedora.cz/wp-content/uploads/2015/09/071.png"><img class="alignnone size-medium wp-image-5739" src="http://fedora.cz/wp-content/uploads/2015/09/071-450x450.png" alt="07" width="450" height="450" /></a>
<p><i>Obrázek 7: První snímek z&nbsp;vylepšené simulace využívající fyzikální engine z&nbsp;knihovny LÖVE.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Automatická změna stavu simulovaného světa</h2>

<p>V&nbsp;demonstračním příkladu je simulovaný svět představován objektem uloženým do globální proměnné <strong>world</strong>. Změna stavu tohoto světa je z&nbsp;hlediska programátora triviální &ndash; stačí pravidelně volat metodu <strong>world:update()</strong> a předat jí počet &bdquo;tiků&ldquo; čítače času. Ve skutečnosti tedy stačí v&nbsp;demonstrační aplikaci provést následující jednoduchou změnu v&nbsp;callback funkci <strong>love.update</strong>:</p>

<pre>
<i>--</i>
<i>-- Funkce volaná cca 30x za sekundu</i>
<i>--</i>
<strong>function</strong> love.update(dt)
    <i>-- přepočítat parametry celého "světa"</i>
    world:update(dt)
&nbsp;
    local delay = 1/30
    <strong>if</strong> dt &lt; delay <strong>then</strong> 
        love.timer.sleep(delay - dt)
    <strong>end</strong>
<strong>end</strong>
</pre>

<a href="http://fedora.cz/wp-content/uploads/2015/09/081.png"><img class="alignnone size-medium wp-image-5740" src="http://fedora.cz/wp-content/uploads/2015/09/081-450x450.png" alt="08" width="450" height="450" /></a>
<p><i>Obrázek 8: Další snímek z&nbsp;vylepšené simulace využívající fyzikální engine z&nbsp;knihovny LÖVE.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Vykreslení objektů tvořících simulovaný svět</h2>

<p>Poněkud komplikovanější je vykreslení všech objektů tvořících náš simulovaný svět. Jedná se jak o &bdquo;podlahu&ldquo;, tak i o oba pohybující se kvádry. Veškeré vykreslování se samozřejmě provádí v&nbsp;callback funkci <strong>love.draw()</strong> a programátor musí explicitně určit, jaké tvary se mají vykreslit. Můžeme zde s&nbsp;výhodou použít metodu <strong>getPoints()</strong> objektů typu <strong>Shape</strong> a její výstup transformovat s&nbsp;využitím metody <strong>getWorldPoints()</strong> objektů typu <strong>Body</strong>. Souřadnice vrcholů mnohoúhelníku se pak předají funkci <strong>love.graphics.polygon()</strong>. Způsob vykreslení je ukázán níže:</p>

<pre>
<i>--</i>
<i>-- Tato funkce je volána automaticky při překreslení obsahu</i>
<i>-- okna či obrazovky.</i>
<i>--</i>
<strong>function</strong> love.draw()
    <i>-- vykreslení země</i>
    love.graphics.setColor(72, 160, 14)
    love.graphics.polygon("line", objects.ground.body:getWorldPoints(objects.ground.shape:getPoints()))
&nbsp;
    <i>-- vykreslení prvního tělesa</i>
    love.graphics.setColor(250, 150, 150)
    love.graphics.polygon("line", objects.block1.body:getWorldPoints(objects.block1.shape:getPoints()))
&nbsp;
    <i>-- vykreslení druhého tělesa</i>
    love.graphics.setColor(150, 150, 250)
    love.graphics.polygon("line", objects.block2.body:getWorldPoints(objects.block2.shape:getPoints()))
&nbsp;
    <i>-- výpis zprávy</i>
    love.graphics.setColor(250, 250, 250)
    love.graphics.print("Escape: to exit.", 20, 615)
<strong>end</strong>
</pre>

<a href="http://fedora.cz/wp-content/uploads/2015/09/091.png"><img class="alignnone size-medium wp-image-5741" src="http://fedora.cz/wp-content/uploads/2015/09/091-450x450.png" alt="09" width="450" height="450" /></a>
<p><i>Obrázek 9: Další snímek z&nbsp;vylepšené simulace využívající fyzikální engine z&nbsp;knihovny LÖVE.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Úplný zdrojový kód prvního demonstračního příkladu</h2>

<p>Podívejme se nyní na úplný zdrojový kód dnešního prvního demonstračního příkladu. Jak již bylo napsáno v&nbsp;úvodních kapitolách, má celý kód délku pouze 128 řádků, přičemž je použito relativně velké množství komentářů, takže programových řádků je ve skutečnosti mnohem méně:</p>

<pre>
<i>--</i>
<i>-- Knihovna LÖVE</i>
<i>--</i>
<i>-- Osmnáctý demonstrační příklad</i>
<i>--</i>
<i>-- Jednoduchý "svět", v němž se nachází dva kvádry.</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>-- rozměry okna, do něhož se bude provádět vykreslování</i>
width = 600
height = 600
ground_height = 50
&nbsp;
<i>-- tíhové zrychlení</i>
G = 9.81
&nbsp;
<i>-- počet pixelů odpovídající jednomu metru v simulovaném světě</i>
pixels_per_meter = 64
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Funkce volaná při inicializaci aplikace.</i>
<i>--</i>
<strong>function</strong> love.load()
    <i>-- načtení standardního fontu a nastavení grafického režimu</i>
    local font = love.graphics.newFont(love.default_font, 40)
&nbsp;
    <i>-- inicializace grafického režimu</i>
    love.graphics.setMode(width, height, false, false, 0)
&nbsp;
    <i>-- nastavení rozměrů simulovaného světa</i>
    <i>-- (mapování fyzikálních jednotek na pixely)</i>
    love.physics.setMeter(pixels_per_meter)
&nbsp;
    <i>-- vytvoření simulovaného světa</i>
    world = love.physics.newWorld(0, G * pixels_per_meter, true)
&nbsp;
    <i>-- tabulka s tělesy</i>
    objects = {}
&nbsp;
    <i>-- těleso představující zemi</i>
    objects.ground = {}
    <i>-- počáteční umístění tělesa</i>
    objects.ground.body = love.physics.newBody(world, width/2, height-ground_height/2)
    <i>-- tvar a rozměry</i>
    objects.ground.shape = love.physics.newRectangleShape(width, ground_height)
    <i>-- propojení tvaru s tělesem</i>
    objects.ground.fixture = love.physics.newFixture(objects.ground.body, objects.ground.shape, 5)
&nbsp;
    <i>-- těleso představující první kvádr</i>
    objects.block1 = {}
    <i>-- počáteční umístění tělesa</i>
    objects.block1.body = love.physics.newBody(world, 200, 200, "dynamic")
    <i>-- tvar a rozměry</i>
    objects.block1.shape = love.physics.newRectangleShape(40, 150)
    <i>-- propojení tvaru s tělesem</i>
    objects.block1.fixture = love.physics.newFixture(objects.block1.body, objects.block1.shape, 5)
&nbsp;
    <i>-- těleso představující druhý kvádr</i>
    objects.block2 = {}
    <i>-- počáteční umístění tělesa</i>
    objects.block2.body = love.physics.newBody(world, 225, 50, "dynamic")
    <i>-- tvar a rozměry</i>
    objects.block2.shape = love.physics.newRectangleShape(100, 50)
    <i>-- propojení tvaru s tělesem</i>
    objects.block2.fixture = love.physics.newFixture(objects.block2.body, objects.block2.shape, 5)
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Funkce volaná cca 30x za sekundu</i>
<i>--</i>
<strong>function</strong> love.update(dt)
    <i>-- přepočítat parametry celého "světa"</i>
    world:update(dt)
&nbsp;
    local delay = 1/30
    <strong>if</strong> dt &lt; delay <strong>then</strong> 
        love.timer.sleep(delay - dt)
    <strong>end</strong>
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Tato funkce je volána automaticky při překreslení obsahu</i>
<i>-- okna či obrazovky.</i>
<i>--</i>
<strong>function</strong> love.draw()
    <i>-- vykreslení země</i>
    love.graphics.setColor(72, 160, 14)
    love.graphics.polygon("line", objects.ground.body:getWorldPoints(objects.ground.shape:getPoints()))
&nbsp;
    <i>-- vykreslení prvního tělesa</i>
    love.graphics.setColor(250, 150, 150)
    love.graphics.polygon("line", objects.block1.body:getWorldPoints(objects.block1.shape:getPoints()))
&nbsp;
    <i>-- vykreslení druhého tělesa</i>
    love.graphics.setColor(150, 150, 250)
    love.graphics.polygon("line", objects.block2.body:getWorldPoints(objects.block2.shape:getPoints()))
&nbsp;
    <i>-- výpis zprávy</i>
    love.graphics.setColor(250, 250, 250)
    love.graphics.print("Escape: to exit.", 20, 615)
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Callback funkce zavolaná při stisku klávesy.</i>
<i>--</i>
<strong>function</strong> love.keypressed(k)
    <strong>if</strong> k == 'escape' <strong>then</strong> 
    <i>-- klávesou "Escape" se aplikace ukončí</i>
        love.event.quit()
    <strong>end</strong>
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- finito</i>
<i>--</i>
</pre>

<a href="http://fedora.cz/wp-content/uploads/2015/09/101.png"><img class="alignnone size-medium wp-image-5742" src="http://fedora.cz/wp-content/uploads/2015/09/101-450x450.png" alt="10" width="450" height="450" /></a>
<p><i>Obrázek 10: Další snímek z&nbsp;vylepšené simulace využívající fyzikální engine z&nbsp;knihovny LÖVE.</i></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Změna odrazivosti těles</h2>

<p>Simulace vypočítaná a zobrazená dnešním prvním demonstračním příkladem má jednu poněkud problematickou vlastnost: kvádry se při dopadu na podlahu (či na druhý kvádr) prakticky neodráží, což nepůsobí přirozeně. Tuto vlastnost můžeme v&nbsp;dalším příkladu velmi snadno změnit, a to zavoláním metody <strong>Fixture.setRestitution()</strong>, kde se předaným parametrem může odrazivost změnit (možná by se dalo použít i slovo &bdquo;pružnost&ldquo;, ve skutečnosti se však při dopadu a odrazu nemění/nedeformuje tvar tělesa). Typické hodnoty parametru odrazivosti leží v&nbsp;rozsahu 0,0 až 1,0, kde 0,0 představuje nulovou odrazivost a 1,0 maximální odrazivost (můžete si sami vyzkoušet, co se stane v&nbsp;případě, že je tento parametr vyšší, než hodnota 1,0). Podívejme se na příklad, v&nbsp;němž se změní odrazivost podlahy:</p>

<pre>
    <i>-- těleso představující zemi</i>
    objects.ground = {}
    <i>-- počáteční umístění tělesa</i>
    objects.ground.body = love.physics.newBody(world, width/2, height-ground_height/2)
    <i>-- tvar a rozměry</i>
    objects.ground.shape = love.physics.newRectangleShape(width, ground_height)
    <i>-- propojení tvaru s tělesem</i>
    objects.ground.fixture = love.physics.newFixture(objects.ground.body, objects.ground.shape, 5)
    objects.ground.fixture:setRestitution(0.7)
</pre>

<a href="http://fedora.cz/wp-content/uploads/2015/09/111.png"><img class="alignnone size-medium wp-image-5743" src="http://fedora.cz/wp-content/uploads/2015/09/111-450x450.png" alt="11" width="450" height="450" /></a>
<p><i>Obrázek 11: Další snímek z&nbsp;vylepšené simulace využívající fyzikální engine z&nbsp;knihovny LÖVE.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Naklonění kvádru v&nbsp;simulovaném světě</h2>

<p>Další změnou, kterou v&nbsp;simulovaném herním světě provedeme, bude přidání třetího pohybujícího se kvádru. Tento kvádr však bude nakloněný o úhel odpovídající přibližně 45&deg;. Vzhledem k&nbsp;tomu, že se v&nbsp;knihovně LÖVE všechny úhly specifikují v&nbsp;radiánech, odpovídá 45&deg; přibližně hodnotě &pi;/4 rad. Právě tuto hodnotu použijeme při vytváření tvaru (<i>shape</i>) s&nbsp;využitím funkce <strong>love.physics.newRectangleShape()</strong>. Tuto funkci jsme doposud volali s&nbsp;dvěma parametry představujícími délku stran kvádru, nyní však přidáme další tři parametry: relativní pozici středu [0,0] a právě úhel natočení 45&deg; &approx; &pi;/4 &approx; 3.1415/4:</p>

<pre>
    <i>-- těleso představující třetí kvádr</i>
    objects.block3 = {}
    <i>-- počáteční umístění tělesa</i>
    objects.block3.body = love.physics.newBody(world, 425, 50, "dynamic")
    <i>-- tvar a rozměry</i>
    objects.block3.shape = love.physics.newRectangleShape(0, 0, 100, 100, 3.1415/4)
    <i>-- propojení tvaru s tělesem</i>
    objects.block3.fixture = love.physics.newFixture(objects.block3.body, objects.block3.shape, 5)
    objects.block3.fixture:setRestitution(0.9)
</pre>

<a href="http://fedora.cz/wp-content/uploads/2015/09/121.png"><img class="alignnone size-medium wp-image-5744" src="http://fedora.cz/wp-content/uploads/2015/09/121-450x450.png" alt="12" width="450" height="450" /></a>
<p><i>Obrázek 12: Další snímek z&nbsp;vylepšené simulace využívající fyzikální engine z&nbsp;knihovny LÖVE.</i></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Úplný zdrojový kód druhého demonstračního příkladu</h2>

<p>Podívejme se nyní na úplný zdrojový kód dnešního druhého a současně i posledního demonstračního příkladu. Zde se již mění odrazivost všech těles a poslední kvádr, který byl přidaný do simulovaného světa, je nakloněný:</p>

<pre>
<i>--</i>
<i>-- Knihovna LÖVE</i>
<i>--</i>
<i>-- Devatenáctý demonstrační příklad</i>
<i>--</i>
<i>-- Jednoduchý "svět", v němž se nachází tři kvádry.</i>
<i>--</i>
&nbsp;
&nbsp;
&nbsp;
<i>-- rozměry okna, do něhož se bude provádět vykreslování</i>
width = 600
height = 600
ground_height = 50
&nbsp;
<i>-- tíhové zrychlení</i>
G = 9.81
&nbsp;
<i>-- počet pixelů odpovídající jednomu metru v simulovaném světě</i>
pixels_per_meter = 64
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Funkce volaná při inicializaci aplikace.</i>
<i>--</i>
<strong>function</strong> love.load()
    <i>-- načtení standardního fontu a nastavení grafického režimu</i>
    local font = love.graphics.newFont(love.default_font, 40)
&nbsp;
    <i>-- inicializace grafického režimu</i>
    love.graphics.setMode(width, height, false, false, 0)
&nbsp;
    <i>-- nastavení rozměrů simulovaného světa</i>
    <i>-- (mapování fyzikálních jednotek na pixely)</i>
    love.physics.setMeter(pixels_per_meter)
&nbsp;
    <i>-- vytvoření simulovaného světa</i>
    world = love.physics.newWorld(0, G * pixels_per_meter, true)
&nbsp;
    <i>-- tabulka s tělesy</i>
    objects = {}
&nbsp;
    <i>-- těleso představující zemi</i>
    objects.ground = {}
    <i>-- počáteční umístění tělesa</i>
    objects.ground.body = love.physics.newBody(world, width/2, height-ground_height/2)
    <i>-- tvar a rozměry</i>
    objects.ground.shape = love.physics.newRectangleShape(width, ground_height)
    <i>-- propojení tvaru s tělesem</i>
    objects.ground.fixture = love.physics.newFixture(objects.ground.body, objects.ground.shape, 5)
    objects.ground.fixture:setRestitution(0.7)
&nbsp;
    <i>-- těleso představující první kvádr</i>
    objects.block1 = {}
    <i>-- počáteční umístění tělesa</i>
    objects.block1.body = love.physics.newBody(world, 200, 200, "dynamic")
    <i>-- tvar a rozměry</i>
    objects.block1.shape = love.physics.newRectangleShape(40, 150)
    <i>-- propojení tvaru s tělesem</i>
    objects.block1.fixture = love.physics.newFixture(objects.block1.body, objects.block1.shape, 5)
    objects.block1.fixture:setRestitution(0.7)
&nbsp;
    <i>-- těleso představující druhý kvádr</i>
    objects.block2 = {}
    <i>-- počáteční umístění tělesa</i>
    objects.block2.body = love.physics.newBody(world, 225, 50, "dynamic")
    <i>-- tvar a rozměry</i>
    objects.block2.shape = love.physics.newRectangleShape(100, 50)
    <i>-- propojení tvaru s tělesem</i>
    objects.block2.fixture = love.physics.newFixture(objects.block2.body, objects.block2.shape, 5)
    objects.block2.fixture:setRestitution(0.7)
&nbsp;
    <i>-- těleso představující třetí kvádr</i>
    objects.block3 = {}
    <i>-- počáteční umístění tělesa</i>
    objects.block3.body = love.physics.newBody(world, 425, 50, "dynamic")
    <i>-- tvar a rozměry</i>
    objects.block3.shape = love.physics.newRectangleShape(0, 0, 100, 100, 3.1415/4)
    <i>-- propojení tvaru s tělesem</i>
    objects.block3.fixture = love.physics.newFixture(objects.block3.body, objects.block3.shape, 5)
    objects.block3.fixture:setRestitution(0.9)
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Funkce volaná cca 30x za sekundu</i>
<i>--</i>
<strong>function</strong> love.update(dt)
    <i>-- přepočítat parametry celého "světa"</i>
    world:update(dt)
&nbsp;
    local delay = 1/30
    <strong>if</strong> dt &lt; delay <strong>then</strong> 
        love.timer.sleep(delay - dt)
    <strong>end</strong>
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Tato funkce je volána automaticky při překreslení obsahu</i>
<i>-- okna či obrazovky.</i>
<i>--</i>
<strong>function</strong> love.draw()
    <i>-- vykreslení země</i>
    love.graphics.setColor(72, 160, 14)
    love.graphics.polygon("line", objects.ground.body:getWorldPoints(objects.ground.shape:getPoints()))
&nbsp;
    <i>-- vykreslení prvního tělesa</i>
    love.graphics.setColor(250, 150, 150)
    love.graphics.polygon("line", objects.block1.body:getWorldPoints(objects.block1.shape:getPoints()))
&nbsp;
    <i>-- vykreslení druhého tělesa</i>
    love.graphics.setColor(150, 150, 250)
    love.graphics.polygon("line", objects.block2.body:getWorldPoints(objects.block2.shape:getPoints()))
&nbsp;
    <i>-- vykreslení třetího tělesa</i>
    love.graphics.setColor(150, 250, 150)
    love.graphics.polygon("line", objects.block3.body:getWorldPoints(objects.block3.shape:getPoints()))
&nbsp;
    <i>-- výpis zprávy</i>
    love.graphics.setColor(250, 250, 250)
    love.graphics.print("Escape: to exit.", 20, 615)
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Callback funkce zavolaná při stisku klávesy.</i>
<i>--</i>
<strong>function</strong> love.keypressed(k)
    <strong>if</strong> k == 'escape' <strong>then</strong> 
    <i>-- klávesou "Escape" se aplikace ukončí</i>
        love.event.quit()
    <strong>end</strong>
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- finito</i>
<i>--</i>
</pre>

<a href="http://fedora.cz/wp-content/uploads/2015/09/131.png"><img class="alignnone size-medium wp-image-5745" src="http://fedora.cz/wp-content/uploads/2015/09/131-450x450.png" alt="13" width="450" height="450" /></a>
<p><i>Obrázek 13: Další snímek z&nbsp;vylepšené simulace využívající fyzikální engine z&nbsp;knihovny LÖVE: všechna zbývající tělesa jsou stabilizována.</i></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Repositář se zdrojovými kódy obou dnešních demonstračních příkladů</h2>

<p>Oba dva demonstrační příklady, s&nbsp;nimiž jsme se v&nbsp;dnešním článku seznámili, byly uloženy do Git repositáře umístěného na GitHubu (<a href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>).  Každý demonstrační příklad je tvořen pouze zdrojovým kódem uloženým v&nbsp;souboru <strong>main.lua</strong>:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Zdrojový kód</th></tr>
<tr><td>1</td><td>example18</td><td><a href="https://github.com/tisnik/presentations/tree/master/love/example18">https://github.com/tisnik/presentations/tree/master/love/example18</a></td></tr>
<tr><td>2</td><td>example19</td><td><a href="https://github.com/tisnik/presentations/tree/master/love/example19">https://github.com/tisnik/presentations/tree/master/love/example19</a></td></tr>
</table>

<p>Poznámka: demonstrační příklady jsou číslovány průběžně, protože tento článek (alespoň nepřímo) navazuje na seriál o programovacích jazycích vhodných pro výuku počítačové grafiky.</p>

<a href="http://fedora.cz/wp-content/uploads/2015/09/141.png"><img class="alignnone size-medium wp-image-5746" src="http://fedora.cz/wp-content/uploads/2015/09/141-450x450.png" alt="14" width="450" height="450" /></a>
<p><i>Obrázek 14: Snímek ze simulace, která bude popsána příště.</i></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Box2D (stránka projektu)<br />
<a href="http://box2d.org/">http://box2d.org/</a>
</li>

<li>Box2D FAQ<br />
<a href="https://github.com/erincatto/Box2D/wiki/FAQ">https://github.com/erincatto/Box2D/wiki/FAQ</a>
</li>

<li>Chipmunk2D (další fyzikální engine)<br />
<a href="http://chipmunk-physics.net/">http://chipmunk-physics.net/</a>
</li>

<li>Physics Engine (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Physics_engine">https://en.wikipedia.org/wiki/Physics_engine</a>
</li>

<li>Modul love.physics<br />
<a href="https://love2d.org/wiki/love.physics">https://love2d.org/wiki/love.physics</a>
</li>

<li>Objekt typu World<br />
<a href="https://love2d.org/wiki/World">https://love2d.org/wiki/World</a>
</li>

<li>Objekt typu Body<br />
<a href="https://love2d.org/wiki/Body">https://love2d.org/wiki/Body</a>
</li>

<li>Objekt typu Shape<br />
<a href="https://love2d.org/wiki/Shape">https://love2d.org/wiki/Shape</a>
</li>

<li>Objekt typu Joint<br />
<a href="https://love2d.org/wiki/Joint">https://love2d.org/wiki/Joint</a>
</li>

<li>Objekt typu Fixture<br />
<a href="https://love2d.org/wiki/Fixture">https://love2d.org/wiki/Fixture</a>
</li>

<li>Particle Systems From the Ground Up<br />
<a href="http://buildnewgames.com/particle-systems/">http://buildnewgames.com/particle-systems/</a>
</li>

<li>Particle Systems<br />
<a href="http://natureofcode.com/book/chapter-4-particle-systems/">http://natureofcode.com/book/chapter-4-particle-systems/</a>
</li>

<li>Domovská stránka systému LÖVE<br />
<a href="http://love2d.org/">http://love2d.org/</a>
</li>

<li>Dokumentace k&nbsp;systému LÖVE<br />
<a href="http://love2d.org/wiki/love">http://love2d.org/wiki/love</a>
</li>

<li>Domovská stránka programovacího jazyka Lua<br />
<a href="http://www.lua.org/ ">http://www.lua.org/ </a>
</li>

<li>Seriál o programovacím jazyku Lua (root.cz):<br />
<a href="http://www.root.cz/serialy/programovaci-jazyk-lua/">http://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>Domovská stránka systému LÖVE<br />
<a href="http://love2d.org/">http://love2d.org/</a>
</li>

<li>Domovská stránka programovacího jazyka Lua<br />
<a href="http://www.lua.org/ ">http://www.lua.org/ </a>
</li>

<li>Web o Lieru, Gusanos, GeneRally, Atari atd.<br />
<a href="http://karelik.wz.cz/">http://karelik.wz.cz/</a>
</li>

<li>Web o Lieru, Gusanos<br />
<a href="http://karelik.wz.cz/gusanos.php">http://karelik.wz.cz/gusanos.php</a>
</li>

<li>GUSANOS<br />
<a href="http://gusanos.sourceforge.net/">http://gusanos.sourceforge.net/</a>
</li>

<li>GUSANOS Download<br />
<a href="http://sourceforge.net/projects/gusanos/">http://sourceforge.net/projects/gusanos/</a>
</li>

<li>Lua<br />
<a href="http://www.linuxexpres.cz/praxe/lua">http://www.linuxexpres.cz/praxe/lua</a>
</li>

<li>Lua<br />
<a href="http://cs.wikipedia.org/wiki/Lua">http://cs.wikipedia.org/wiki/Lua</a>
</li>

<li>Lua (programming language)<br />
<a href="http://en.wikipedia.org/wiki/Lua_(programming_language)">http://en.wikipedia.org/wiki/Lua_(programming_language)</a>
</li>

<li>The Lua Programming Language<br />
<a href="http://www.tiobe.com/index.php/paperinfo/tpci/Lua.html">http://www.tiobe.com/index.php/paperinfo/tpci/Lua.html</a>
</li>

<li>Lua Programming Gems<br />
<a href="http://www.lua.org/gems/">http://www.lua.org/gems/</a>
</li>

<li>LuaForge<br />
<a href="http://luaforge.net/">http://luaforge.net/</a>
</li>

<li>Forge project tree<br />
<a href="http://luaforge.net/softwaremap/trove_list.php">http://luaforge.net/softwaremap/trove_list.php</a>
</li>

<li>SdlBasic home page<br />
<a href="http://www.sdlbasic.altervista.org/main/">http://www.sdlbasic.altervista.org/main/</a>
</li>

<li>SdlBasic examples<br />
<a href="http://nitrofurano.linuxkafe.com/sdlbasic/">http://nitrofurano.linuxkafe.com/sdlbasic/</a>
</li>

<li>SdlBasic na Wikipedii<br />
<a href="http://en.wikipedia.org/wiki/SdlBasic">http://en.wikipedia.org/wiki/SdlBasic</a>
</li>

<li>Simple DirectMedia Layer<br />
<a href="http://en.wikipedia.org/wiki/Simple_DirectMedia_Layer">http://en.wikipedia.org/wiki/Simple_DirectMedia_Layer</a>
</li>

<li>SDLBASIC &ndash; The high-level interpreter for all?<br />
<a href="http://openbytes.wordpress.com/2008/11/08/sdlbasic-the-high-level-interpreter-for-all/">http://openbytes.wordpress.com/2008/11/08/sdlbasic-the-high-level-interpreter-for-all/</a>
</li>

<li>FreeBasic home page<br />
<a href="http://www.freebasic.net/">http://www.freebasic.net/</a>
</li>

<li>FreeBASIC (Wikipedia EN)<br />
<a href="https://en.wikipedia.org/wiki/FreeBASIC">https://en.wikipedia.org/wiki/FreeBASIC</a>
</li>

<li>FreeBASIC Wiki<br />
<a href="http://www.freebasic.net/wiki/wikka.php?wakka=FBWiki">http://www.freebasic.net/wiki/wikka.php?wakka=FBWiki</a>
</li>

<li>FreeBASIC Manual<br />
<a href="http://www.freebasic.net/wiki/wikka.php?wakka=DocToc">http://www.freebasic.net/wiki/wikka.php?wakka=DocToc</a>
</li>

<li>FreeBASIC (Wikipedia CZ)<br />
<a href="http://cs.wikipedia.org/wiki/FreeBASIC">http://cs.wikipedia.org/wiki/FreeBASIC</a>
</li>

<li>The Griffon Legend<br />
<a href="http://syn9.thingie.net/?table=griffonlegend">http://syn9.thingie.net/?table=griffonlegend</a>
</li>

<li>Seriál Letní škola programovacího jazyka Logo<br />
<a href="http://www.root.cz/serialy/letni-skola-programovaciho-jazyka-logo/">http://www.root.cz/serialy/letni-skola-programovaciho-jazyka-logo/</a>
</li>

<li>Scratch: oficiální stránka projektu<br />
<a href="http://scratch.mit.edu/">http://scratch.mit.edu/</a>
</li>

<li>Scratch: galerie projektů vytvořených ve Scratchi<br />
<a href="http://scratch.mit.edu/galleries/browse/newest">http://scratch.mit.edu/galleries/browse/newest</a>
</li>

<li>Scratch: nápověda<br />
<a href="file:///usr/share/scratch/Help/en/index.html">file:///usr/share/scratch/Help/en/index.html</a>
</li>

<li>Scratch: obrazovky nápovědy<br />
<a href="file:///usr/share/scratch/Help/en/allscreens.html">file:///usr/share/scratch/Help/en/allscreens.html</a>
</li>

<li>Scratch (Wikipedie CZ)<br />
<a href="http://cs.wikipedia.org/wiki/Scratch">http://cs.wikipedia.org/wiki/Scratch</a>
</li>

<li>Scratch (programming language)<br />
<a href="http://en.wikipedia.org/wiki/Scratch_(programming_language)">http://en.wikipedia.org/wiki/Scratch_(programming_language)</a>
</li>

<li>Scratch Modification<br />
<a href="http://wiki.scratch.mit.edu/wiki/Scratch_Modification">http://wiki.scratch.mit.edu/wiki/Scratch_Modification</a>
</li>

<li>Scratch Lowers Resistance to Programming<br />
<a href="http://www.wired.com/gadgetlab/2009/03/scratch-lowers/">http://www.wired.com/gadgetlab/2009/03/scratch-lowers/</a>
</li>

<li>Snap!<br />
<a href="http://snap.berkeley.edu/">http://snap.berkeley.edu/</a>
</li>

<li>Prostředí Snap!<br />
<a href="http://snap.berkeley.edu/snapsource/snap.html">http://snap.berkeley.edu/snapsource/snap.html</a>
</li>

<li>Alternatives to Scratch<br />
<a href="http://wiki.scratch.mit.edu/wiki/Alternatives_to_Scratch">http://wiki.scratch.mit.edu/wiki/Alternatives_to_Scratch</a>
</li>

<li>Basic-256 home page<br />
<a href="http://www.basic256.org/index_en">http://www.basic256.org/index_en</a>
</li>

<li>Basic-256 Language Documentation<br />
<a href="http://doc.basic256.org/doku.php">http://doc.basic256.org/doku.php</a>
</li>

<li>Basic-256 Art Gallery<br />
<a href="http://www.basic256.org/artgallery">http://www.basic256.org/artgallery</a>
</li>

<li>Basic-256 Tutorial<br />
<a href="http://www.basic256.org/tutorials">http://www.basic256.org/tutorials</a>
</li>

<li>Why BASIC?<br />
<a href="http://www.basic256.org/whybasic">http://www.basic256.org/whybasic</a>
</li>

<li>A book to teach ANYBODY how to program a computer (using BASIC)<br />
<a href="http://www.basicbook.org/">http://www.basicbook.org/</a>
</li>

<li>BASIC Computer Games (published 1978) - Hammurabi<br />
<a href="http://atariarchives.org/basicgames/showpage.php?page=78">http://atariarchives.org/basicgames/showpage.php?page=78</a>
</li>

<li>Hamurabi - zdrojový kód v BASICu<br />
<a href="http://www.dunnington.u-net.com/public/basicgames/HMRABI">http://www.dunnington.u-net.com/public/basicgames/HMRABI</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2015</small></p>
</body>
</html>

