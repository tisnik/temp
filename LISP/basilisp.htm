<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Basilisp: interpret programovacího jazyka Clojure integrovaný s Pythonem</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Basilisp: interpret programovacího jazyka Clojure integrovaný s Pythonem</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Koncept jazyka LISP vznikl již před 65 roky. Od té doby bylo implementováno několik set, ale možná i několik tisíc implementací LISPu popř. od něj odvozených jazyků Scheme a Clojure. Dnes se seznámíme s Basilispem. Jde o interpret jazyka Clojure, jenž je integrovaný s platformou Pythonu, což je jeho největší předností.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Basilisp: interpret programovacího jazyka Clojure integrovaný s&nbsp;Pythonem</a></p>
<p><a href="#k02">2. Python VM ve funkci platformy pro další programovací jazyky</a></p>
<p><a href="#k03">3. Projekt <i>Basilisp</i></a></p>
<p><a href="#k04">4. Instalace projektu <i>Basilisp</i></a></p>
<p><a href="#k05">5. První kroky v&nbsp;interaktivní smyčce jazyka Basilisp</a></p>
<p><a href="#k06">6. Literály a jednoduché formy, s&nbsp;nimiž se v&nbsp;Basilispu pracuje</a></p>
<p><a href="#k07">7. Symboly a hesla</a></p>
<p><a href="#k08">8. Složené formy: strukturované datové typy</a></p>
<p><a href="#k09">9. Příklady konstrukce kolekcí v&nbsp;programovacím jazyku Basilisp</a></p>
<p><a href="#k10">10. Operace s&nbsp;kolekcemi a nekonečnými sekvencemi</a></p>
<p><a href="#k11">11. Predikáty, zjištění typových informací za běhu</a></p>
<p><a href="#k12">12. Řídicí struktury (speciální formy a makra)</a></p>
<p><a href="#k13">13. Ukázky využití vybraných řídicích struktur</a></p>
<p><a href="#k14">*** 14. Konstrukce <strong>cond</strong> a <strong>condp</strong></a></p>
<p><a href="#k15">*** 15. Balíčky dodávané se samotným jazykem Basilisp</a></p>
<p><a href="#k16">16. Interoperabilita s&nbsp;Pythonem</a></p>
<p><a href="#k17">17. Využití balíčků Pythonu přímo z&nbsp;Basilispu</a></p>
<p><a href="#k18">18. Předchozí části seriálu o LISPovských programovacích jazycích</a></p>
<p><a href="#k19">19. Literatura</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Basilisp: interpret programovacího jazyka Clojure integrovaný s&nbsp;Pythonem</h2>

<p>Svět programovacího jazyka LISP je velmi rozsáhlý a dá se říci, že i pestrý.
Jak již bylo napsáno v&nbsp;perexu dnešního článku, vznikl koncept tohoto
programovacího jazyka již před neuvěřitelnými 65 roky a od té doby bylo
vytvořeno několik set, ale s&nbsp;poměrně velkou pravděpodobností i několik
tisíc implementací LISPu popř.&nbsp;od něj odvozených jazyků Scheme a Clojure.
LISPy tak najdeme jak na osmibitových domácích mikropočítačích na jedné straně,
tak i na superpočítačích na straně druhé. V&nbsp;dnešním článku se seznámíme
s&nbsp;projektem nazvaným <i>Basilisp</i>. Jedná se o interpret programovacího
jazyka Clojure, který je integrovaný s&nbsp;platformou Pythonu (naproti tomu
klasický Clojure je integrovaný s&nbsp;JVM a ClojureScript
s&nbsp;JavaScriptem). Velkou předností Basilispu je téměř dokonalé navázání na
Python a jeho knihovny &ndash; dokonce je integrace lepší, než Clojure+Java,
protože Basilisp má s&nbsp;Pythonem podobný typový systém.</p>

<p>Spojení dialektu LISPu s&nbsp;virtuálním strojem Pythonu popř.&nbsp;přímo
s&nbsp;programovacím jazykem Python (tzv.&nbsp;<i>interop</i>) není zajímavé
jen z&nbsp;technologického hlediska, protože může mít i praktické využití.
Ostatně LISP byl jazykem používaným pro vývoj systémů umělé inteligence, a to
už v&nbsp;padesátých letech minulého století (z&nbsp;dnešního pohledu se ale
mnohdy jednalo spíš o hledání slepých uliček). A dnes má v&nbsp;oblasti AI a
strojového učení stejně výsadní postavení Python, takže se vlastně spojení
LISP+Python jeví jako poměrně pragmatická volba.</p>

<p><div class="rs-tip-major">Poznámka: z&nbsp;hlediska statistiky GitHubu se
již jedná o stabilnější typ projektu s&nbsp;deseti přispěvateli a relativně
dlouhou historií vylepšení (<a
href="https://github.com/basilisp-lang/basilisp">viz též příslušný
repositář</a>). Na druhou stranu však nemůže soupeřit například se statistikou
samotného <a href="https://github.com/clojure/clojure">Clojure</a> nebo dokonce
<a href="https://github.com/python/cpython">Pythonu</a>.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Python VM ve funkci platformy pro další programovací jazyky</h2>

<p>Fakt, že různé dialekty jazyků LISP a Scheme (popř.&nbsp;Clojure, který lze
považovat za moderní reinkarnaci LISPu) vznikají pro prakticky všechny moderní
virtuální stroje (typicky pro JVM, VM JavaScriptu, WASM nebo VM Pythonu)
vlastně není nic překvapivého. Musíme si totiž uvědomit, že praktická
použitelnost programovacího jazyka je do značné míry určena i celým
ekosystémem, který je programátorům, kteří chtějí tento jazyk začít používat,
k&nbsp;dispozici. A ekosystém Pythonu je dnes již velmi rozsáhlý a obsahuje
kvalitní a v&nbsp;celém světě používané knihovny i celé frameworky, takže se
může jednat o vhodný základ, na němž je možné postavit moderní varianty
LISPu.</p>

<p>Na podobné myšlence ostatně vznikl i výše zmíněný jazyk <i>Clojure</i>,
který vlastně vůbec nemá svůj vlastní virtuální stroj. Clojure vzniklo pro
virtuální stroj Javy (JVM &ndash; Java Virtual Machine), další varianty Clojure
byly implementovány pro CLR (ClojureCLR) a ClojureScript, který je kompilovaný
do JavaScriptu, takže může běžet buď v&nbsp;prohlížeči, v&nbsp;Node.js atd.
V&nbsp;každém případě však Clojure dokáže využít všechny dostupné knihovny pro
zvolenou platformu.</p>

<p>Pro virtuální stroj jazyka Python (Python VM) je v&nbsp;současnosti k
dispozici hned několik dialektů LISPu, Scheme či Clojure. Jedná se například o
méně známé projekty <i>Lizpop</i>, <i>Lispy</i> či <i>Lython</i>, dále o
<i>SchemePy</i>, <i>Clojure-py</i> a taktéž velmi zajímavým způsobem
implementovaný programovací jazyk nazvaný <i>Hy</i>. Do této kategorie částečně
spadá i programovací jazyk <i>Pixie</i>, se kterým jsme se již na stránkách
Roota seznámili. A dalším členem této již tak rozsáhlé rodiny je projekt <a
href="https://github.com/basilisp-lang/basilisp">Basilisp</a>, kterému se
budeme primárně věnovat v&nbsp;dnešním článku.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Projekt <i>Basilisp</i></h2>

<p>Projekt <i>Basilisp</i> je implementací programovacího jazyka Clojure
(resp.&nbsp;přesněji řečeno velké části tohoto jazyka) pro platformu klasického
CPythonu. Ovšem to, že Basilisp běží nad virtuálním strojem Pythonu není pouhý
implementační detail, ale důležitá vlastnost, protože Basilisp dokáže prakticky
bezproblémově volat funkce a metody samotného Pythonu, dokáže importovat
Pythonní balíčky atd. Rozhraní mezi Pythonem a Basilispem samozřejmě není zcela
bezproblémové, protože se zde střetává svět Pythonu s&nbsp;(obecně) měnitelnými
datovými strukturami na straně jedné a svět neměnitelných a persistentních
datových struktur na straně druhé. Ovšem, ostatně jak uvidíme
v&nbsp;navazujících kapitolách, je možné i tento problém řešit celkem
elegantním způsobem. Basilisp samotný obsahuje podporu pro interaktivní smyčku
REPL, která se navíc inicializuje rychleji, než je tomu v&nbsp;klasickém
Clojure postaveném nad virtuálním strojem Javy.</p>

<p><div class="rs-tip-major">Poznámka: zajímavé je, že se v&nbsp;projektu
<i>Basilisp</i> používají balíčky s&nbsp;implementací persistentních datových
struktur. Touto problematikou jsme se již na stránkách Roota zabývali ve
dvojici článků <a
href="https://www.root.cz/clanky/pyrsistent-persistentni-datove-struktury-v-pythonu/">Pyrsistent:
persistentní datové struktury v&nbsp;Pythonu</a> a <a
href="https://www.root.cz/clanky/pyrsistent-persistentni-datove-struktury-v-pythonu-dokonceni/">Pyrsistent:
persistentní datové struktury v&nbsp;Pythonu (dokončení)</a>.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Instalace projektu <i>Basilisp</i></h2>

<p><i>Basilisp</i> je dostupný ve formě běžného Pythonního balíčku, takže je
možné pro jeho instalaci použít například nástroj <strong>pip</strong>. Ovšem
pro první pokusy s&nbsp;tímto projektem bude lepší instalace do samostatného
adresáře, resp.&nbsp;přesněji řečeno do virtuálního prostředí Pythonu. Pro tuto
variantu instalaci použiji nástroj <strong>uv</strong>, i když naprosto stejným
způsobem lze využít <strong>pdm</strong> atd.</p>

<p>Nejprve si necháme vygenerovat adresář se základní kostrou Pythonního
projektu:</p>

<pre>
$ <strong>uv init basilisp-project</strong>
&nbsp;
Initialized project `basilisp-project` at `/tmp/ramdisk/basilisp-project`
</pre>

<p>Měl by vzniknout nový adresář s&nbsp;následujícím obsahem:</p>

<pre>
drwxr-xr-x. 3 ptisnovs ptisnovs 160 Nov  8 10:32 .
drwxr-xr-x. 3 ptisnovs ptisnovs  60 Nov  8 10:32 ..
drwxr-xr-x. 6 ptisnovs ptisnovs 180 Nov  8 10:32 .git
-rw-r--r--. 1 ptisnovs ptisnovs 109 Nov  8 10:32 .gitignore
-rw-r--r--. 1 ptisnovs ptisnovs  94 Nov  8 10:32 main.py
-rw-r--r--. 1 ptisnovs ptisnovs 162 Nov  8 10:32 pyproject.toml
-rw-r--r--. 1 ptisnovs ptisnovs   5 Nov  8 10:32 .python-version
-rw-r--r--. 1 ptisnovs ptisnovs   0 Nov  8 10:32 README.md
</pre>

<p>Přesuneme se do nově vytvořeného adresáře a nainstalujeme <i>Basilisp</i> do
virtuálního prostředí:</p>

<pre>
$ <strong>cd basilisp-project</strong>
&nbsp;
$ <strong>uv add basilisp</strong>
&nbsp;
Using CPython 3.12.10 interpreter at: /usr/bin/python3.12
Creating virtual environment at: .venv
Resolved 8 packages in 481ms
Prepared 3 packages in 236ms
Installed 7 packages in 12ms
 + attrs==25.4.0
 + basilisp==0.4.0
 + immutables==0.21
 + prompt-toolkit==3.0.52
 + pyrsistent==0.20.0
 + typing-extensions==4.15.0
 + wcwidth==0.2.14
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se
mj.&nbsp;nainstalovala i knihovna <strong>immutables</strong> a
<strong>pyrsistent</strong>.</div></p>

<p>Současně by měly být zaregistrovány nové příkazy/nástroje spustitelné přes
<strong>uv run</strong>:</p>

<pre>
$ <strong>uv run</strong>
&nbsp;
Provide a command or script to invoke with `uv run &lt;;command&gt;` or `uv run &lt;script&gt;.py`.
&nbsp;
The following commands are available in the environment:
&nbsp;
- basilisp
- basilisp-run
- python
- python3
- python3.12
</pre>

<p>My budeme v&nbsp;praktické části článku spouštět příkaz/nástroj
<strong>basilisp</strong>, který má sám další volby:</p>

<pre>
$ <strong>uv run basilisp</strong>
&nbsp;
usage: basilisp [-h] {bootstrap,nrepl-server,repl,run,test,version} ...
&nbsp;
Basilisp is a Lisp dialect inspired by Clojure targeting Python 3.
&nbsp;
positional arguments:
  {bootstrap,nrepl-server,repl,run,test,version}
                        sub-commands
    bootstrap           bootstrap the Python installation to allow importing Basilisp namespaces
    nrepl-server        start the nREPL server
    repl                start the Basilisp REPL
    run                 run a Basilisp script or code or namespace
    test                run tests in a Basilisp project
    version             print the version of Basilisp
&nbsp;
options:
  -h, --help            show this help message and exit
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. První kroky v&nbsp;interaktivní smyčce jazyka Basilisp</h2>

<p>Basilisp je vybaven plnohodnotnou interaktivní smyčkou REPL (<i>Read Eval
Print Loop</i>), která nabízí možnost editace příkazového řádku, práci
s&nbsp;historií příkazů, obsahuje jednoduchou nápovědu (postačuje napsat část
příkazu a nabídne se jeho doplnění), zvýraznění syntaxe a především pak
&bdquo;doskoky&ldquo; na párové závorky, což je pro LISPovský programovací
jazyk velmi důležité.</p>

<p>REPL se spustí následovně:</p>

<pre>
$ <strong>uv run basilisp repl</strong>
&nbsp;
basilisp.user=&gt;
</pre>

<p><div class="rs-tip-major">Poznámka: zobrazená výzva (<i>prompt</i>) před
šipkou =&gt; zobrazuje takzvaný jmenný prostor (<i>namespace</i>).</div></p>

<p>Zadané výrazy jsou ihned vyhodnocovány. Například forma * (makro nebo
funkce) pro součin hodnot se ihned po potvrzení klávesou Enter vyhodnotí a
výsledek se vypíše:</p>

<pre>
basilisp.user=&gt; <strong>(* 6 7)</strong>
&nbsp;
42
</pre>

<p>Ke každému načtenému symbolu je možné zobrazit nápovědu pomocí
<strong>doc</strong>:</p>

<pre>
basilisp.user=&gt; <strong>(doc +)</strong>
&nbsp;
------------------------
basilisp.core/+
([] [x] [x y] [x y &amp; args])
  Sum the arguments together. If no arguments given, returns 0.
nil
</pre>

<p>Nápověda k&nbsp;samotné funkci zobrazující nápovědu:</p>

<pre>
basilisp.user=&gt; <strong>(doc doc)</strong>
&nbsp;
------------------------
basilisp.repl/doc
([&amp;env &amp;form v])
  Print the docstring from an interned Var if found.

  ``v`` must be a symbol which resolves to a Var.
nil
</pre>

<p>Nápověda k&nbsp;velmi užitečné konstrukci <strong>range</strong>:</p>

<pre>
basilisp.user=&gt; <strong>(doc range)</strong>
&nbsp;
------------------------
basilisp.core/range
([] [end] [start end] [start end step])
  Return a range of integers from ``start``\. If ``end`` is specified, the sequence
  will terminate at ``end``\. If ``step`` is specified, that amount will be added
  for each iteration. ``step`` may be negative.
nil
</pre>

<p><div class="rs-tip-major">Poznámka: <strong>nil</strong> na konci všech
předchozích výrazů je výsledek volání <strong>doc</strong>.</div></p>

<p>Zajímavé a užitečné je, že vývojář má přímý přístup k&nbsp;základním funkcím
Pythonu. Ty se volají naprosto stejně, jakoby se jednalo o samotné funkce
Basilispu:</p>

<pre>
basilisp.user=&gt; <strong>(hex 42)</strong>
&nbsp;
"0x2a"
</pre>

<pre>
basilisp.user=&gt; <strong>(abs -42)</strong>
&nbsp;
42
</pre>

<p>Ovšem zavolat můžeme například i vestavěnou funkci <strong>help</strong> (ta
je interaktivní):</p>

<pre>
basilisp.user=&gt; <strong>(help)</strong>
&nbsp;
Welcome to Python 3.12's help utility! If this is your first time using
Python, you should definitely check out the tutorial at
https://docs.python.org/3.12/tutorial/.
&nbsp;
Enter the name of any module, keyword, or topic to get help on writing
Python programs and using Python modules.  To get a list of available
modules, keywords, symbols, or topics, enter "modules", "keywords",
"symbols", or "topics".
&nbsp;
Each module also comes with a one-line summary of what it does; to list
the modules whose name or summary contain a given string such as "spam",
enter "modules spam".
&nbsp;
To quit this help utility and return to the interpreter,
enter "q" or "quit".
&nbsp;
help&gt;
</pre>

<p>Příklad spuštění a vyhodnocení <strong>range</strong> (podrobnosti budou
uvedeny později):</p>

<pre>
basilisp.user=&gt; <strong>(range 10)</strong>
&nbsp;
(0 1 2 3 4 5 6 7 8 9)
</pre>

<p>Nápověda k&nbsp;další velmi užitečné funkci (vyššího řádu) nazvané
<strong>reduce</strong>:</p>

<pre>
basilisp.user=&gt; <strong>(doc reduce)</strong>
&nbsp;
------------------------
basilisp.core/reduce
([f coll] [f val coll])
  Reduce ``coll`` by ``f``\.
&nbsp;
  If ``val`` is not supplied and ``coll`` has no elements, ``f`` will be called with no
  arguments and the result will be returned.
&nbsp;
  If ``val`` is not supplied and ``coll`` has one element, the result of
  ``(f (first val))`` is returned.
&nbsp;
  If ``val`` is not supplied and ``coll`` has elements, repeatedly reduce ``coll`` by
  calling ``f`` on successive elements in ``coll``\.
&nbsp;
  If ``val`` is supplied and ``coll`` has no elements, return ``val` and ``f`` will not
  be called.
&nbsp;
  If ``val`` is supplied and ``coll`` has elements, repeatedly reduce ``coll`` by
  calling ``f`` on successive elements in ``coll``\, starting with ``val``\.
&nbsp;
  If ``f`` returns a ``reduced`` value at any point, reduction will terminate and the
  reduced value will be returned immediately.
</pre>

<p>Využití funkce <strong>reduce</strong> pro výpočet faktoriálu 1000 (podrobnosti opět budou uvedeny později):</p>

<pre>
basilisp.user=&gt; <strong>(reduce * (range 1 1000))</strong>
&nbsp;
40238726007709377354370243392300398571937486421071463254379991042993851239862902
05920442084869694048004799886101971960586316668729948085589013238296699445909974
24504087073759918823627727188732519779505950995276120874975462497043601418278094
64649629105639388743788648733711918104582578364784997701247663288983595573543251
31853239584630755574091142624174743493475534286465766116677973966688202912073791
43853719588249808126867838374559731746136085379534524221586593201928090878297308
43139284440328123155861103697680135730421616874760967587134831202547858932076716
91324484262361314125087802080002616831510273418279777047846358681701643650241536
91398281264810213092761244896359928705114964975419909342221566832572080821333186
11681155361583654698404670897560290095053761647584772842188967964624494516076535
34081989013854424879849599533191017233555566021394503997362807501378376153071277
61926849034352625200015888535147331611702103968175921510907788019393178114194545
25722386554146106289218796022383897147608850627686296714667469756291123408243920
81601537808898939645182632436716167621791689097799119037540312746222899880051954
44414282012187361745992642956581746628302955570299024324153181617210465832036786
90611726015878352075151628422554026517048330422614397428693306169089796848259012
54583271682264580665267699586526822728070757813918581788896522081643483448259932
66043367660176999612831860788386150279465955131156552036093988180612138558600301
43569452722420634463179746059468257310379008402443243846565724501440282188525247
09351906209290231364932734975655139587205596542287497740114133469627154228458623
77387538230483865688976461927383814900140767310446640259899490222221765904339901
88601856652648506179970235619389701786004081188972991831102117122984590164192106
88843871218556461249607987229085192968193723886426148396573822911231250241866493
53143970137428531926649875337218940694281434118520158014123344828015051399694290
15348307764456909907315243327828826986460278986432113908350621709500259738986355
42771967428222487575867657523442202075736305694988250879689281627538488633969099
59826280956121450994871701244516461260379029309120889086942028510640182154399457
15680594187274899809425474217358240106367740459574178516082923013535808184009699
63725242305608559037006242712434169090041536901059339838357779394109700277534720
00000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000
00000
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Literály a jednoduché formy, s&nbsp;nimiž se v&nbsp;Basilispu pracuje</h2>

<p>Nyní se již (konečně!) můžeme seznámit se základními stavebními prvky, na
kterých je programovací jazyk <i>Basilisp</i> postaven. Všechny příklady, které
zde budou ukázány, jsou spouštěny interaktivně ze smyčky <i>REPL</i>, což
znamená, že každý výraz je nejprve načten (<i>read</i>), vyhodnocen
(<i>evaluate</i>), posléze je jeho výsledek vypsán na standardní výstup
(<i>print</i>) a následně je očekáváno interaktivní zadání dalšího výrazu
(<i>loop</i>). Všechny dále uvedené výrazy jsou jednořádkové, takže na prvním
řádku je vypsán vlastní výraz (tak jak má být opsán do konzole) a na řádku
druhém výsledek tohoto výrazu.</p>

<p>V&nbsp;předchozích větách jsme sice pro jednoduchost používali slovo
&bdquo;výraz&ldquo; odpovídající spíše jazykům typu Céčka či Javy, ovšem
v&nbsp;případě <i>Basilispu</i> je, podobně jako v&nbsp;jiných variantách
<i>LISPu</i> či <i>Scheme</i>, základním uceleným prvkem programu takzvaná
<i>forma (form)</i>. Právě formy se postupně zpracovávají v&nbsp;interaktivní
smyčce <i>REPL</i> a <i>REPL</i> taktéž kontroluje, zda uživatel skutečně zadal
validní formu. V&nbsp;programovacím jazyku <i>Basilisp</i> (ale i
v&nbsp;<i>Clojure</i>) existují čtyři základní typy forem:</p>

<ol>
<li>literály</li>
<li>symboly a hesla (<i>keywords</i>)</li>
<li>složené formy (v&nbsp;podstatě se jedná o seznamy představující volání funkce)</li>
<li>speciální formy (podobají se složeným formám, ale interně se vyhodnocují odlišným způsobem, například se rekurzivně nevyhodnocují vnitřní podvýrazy atd.)</li>
</ol>

<p>Nejjednodušším typem formy jsou <i>literály</i>, protože ty se
v&nbsp;interaktivní smyčce <i>REPL</i> vyhodnocují samy na sebe. Na literály se
můžeme dívat jako na konstanty nějakého primitivního datového typu, mezi které
v&nbsp;programovacím jazyce <i>Basilisp</i> patří především čísla
(k&nbsp;dispozici jsou různé formy reprezentace), znaky, řetězce a pravdivostní
hodnoty. Nyní si ukážeme několik příkladů, které naznačí, jak s&nbsp;literály
pracuje <i>REPL</i> a tudíž i samotný programovací jazyk <i>Basilisp</i>.</p>

<p>Řetězec je prostě ... řetězec. Zapisuje se do dvojitých uvozovek (apostrofy
a zpětné apostrofy mají odlišný význam):</p>

<pre>
basilisp.user=&gt; <strong>"Hello"</strong>
Hello
</pre>

<p>Důležité je, že řetězce jsou &ndash; podobně jako v&nbsp;Pythonu nebo i
v&nbsp;Javě &ndash; konstantní a tudíž i neměnné (<i>immutable</i>), což sice
v&nbsp;některých případech může vést k&nbsp;tvorbě neefektivních operací,
kterým se však lze v&nbsp;<i>Basilispu</i> většinou zcela vyhnout. To, že jsou
řetězce neměnné však zjednodušuje tvorbu bezpečných vícevláknových aplikací,
řetězce lze využívat jako klíče do asociativních polí atd. atd., takže
přednosti většinou převažují nad zápory.</p>

<p>Pozor je nutné dát na to, že některé další typy Pythonovských řetězců nejsou
podporovány. Například nelze uvést prefix <strong>u</strong>:</p>

<pre>
basilisp.user=&gt; <strong>u"Hello"</strong>
&nbsp;
  exception: &lt;class 'basilisp.lang.compiler.exception.CompilerException'&gt;
      phase: :analyzing
    message: unable to resolve symbol 'u' in this context
       form: u
   location: &lt;REPL Input&gt;:1
</pre>

<p>Podporovány nejsou ani formátovací řetězce (a už vůbec ne řetězce
konvertované na šablonu, což je novinka Pythonu 3.14):</p>

<pre>
basilisp.user=&gt; <strong>f"Hello"</strong>
&nbsp;
  exception: &lt;class 'basilisp.lang.compiler.exception.CompilerException'&gt;
      phase: :analyzing
    message: unable to resolve symbol 'f' in this context
       form: f
   location: &lt;REPL Input&gt;:1
</pre>

<pre>
basilisp.user=&gt; <strong>"""Hello"""</strong>
&nbsp;
""
</pre>

<p>Použití literálů představujících pravdivostní hodnoty asi nikoho nepřekvapí:</p>

<pre>
basilisp.user=&gt; <strong>true</strong>
true
&nbsp;
basilisp.user=&gt; <strong>false</strong>
false
</pre>

<p><div class="rs-tip-major">Poznámka: pozor ovšem na to, že se
<strong>true</strong> a <strong>false</strong> musí zapisovat s&nbsp;malým
písmenem na začátku, na rozdíl od Pythonu:</div></p>

<pre>
basilisp.user=&gt; <strong>True</strong>
&nbsp;
  exception: &lt;class 'basilisp.lang.compiler.exception.CompilerException'&gt;
      phase: :analyzing
    message: unable to resolve symbol 'True' in this context
       form: True
   location: &lt;REPL Input&gt;:1
</pre>

<p>Číselné literály jsou již z&nbsp;pohledu programátora mnohem zajímavější,
protože numerické hodnoty lze reprezentovat různým způsobem, využívat různé
číselné soustavy, pracovat s&nbsp;racionálními čísly atd.</p>

<p>Základem je zápis literálu představujícího celé číslo (odpovídající
konvencím zápisu podle Céčka, C++ či Javy):</p>

<pre>
basilisp.user=&gt; <strong>42</strong>
&nbsp;
42
</pre>

<p>Před numerickou hodnotu lze zapsat i základ číselné soustavy (konkrétně před
<strong>r</strong> může být uvedeno číslo 2 až 36):</p>

<pre>
basilisp.user=&gt; <strong>2r101010</strong>
42
&nbsp;
basilisp.user=&gt; <strong>16r2a</strong>
42
&nbsp;
basilisp.user=&gt; <strong>36r16</strong>
42
</pre>

<p>Různé zápisy numerických hodnot s&nbsp;plovoucí řádovou čárkou, interně se
hodnoty ukládají podle normy IEEE 754 (vlastně stejně, jako je tomu i
v&nbsp;Pythonu):</p>

<pre>
basilisp.user=&gt; <strong>3.14</strong>
3.14
&nbsp;
basilisp.user=&gt; <strong>1e10</strong>
10000000000
&nbsp;
basilisp.user=&gt; <strong>1e-10</strong>
1e-10
</pre>

<p>Mnohé LISPovské programovací jazyky podporují práci se zlomky,
resp.&nbsp;přesněji řečeno s&nbsp;racionálními čísly. Stejně tak je tomu i
v&nbsp;jazyce Basilisp:</p>

<pre>
basilisp.user=&gt; <strong>100/3</strong>
100/3
</pre>

<p>Výpočet, jehož výsledkem je numerická hodnota (zjednodušený zlomek):</p>

<pre>
basilisp.user=&gt; <strong>(+ 7/6 3/4)</strong>
23/12
</pre>

<p>Od Clojure jsou odvozeny i numerické typy představující neomezené hodnoty a
typ s&nbsp;neomezenou přesností i rozsahem:</p>

<pre>
basilisp.user=&gt; <strong>1234M</strong>
1234
&nbsp;
basilisp.user=&gt; <strong>1234N</strong>
1234
</pre>

<p>A konečně se setkáme s&nbsp;hodnotou <strong>nil</strong>, která
v&nbsp;LISPovských jazycích nahrazuje None/NULL:</p>

<pre>
basilisp.user=&gt; <strong>nil</strong>
nil
</pre>

<p>Pozor ovšem na to, že hodnota <strong>None</strong> z&nbsp;Pythonu není
podporována &ndash; namísto ní se vždy použije <strong>nil</strong>:</p>

<pre>
basilisp.user=&gt; <strong>None</strong>
&nbsp;
  exception: &lt;class 'basilisp.lang.compiler.exception.CompilerException'&gt;
      phase: :analyzing
    message: unable to resolve symbol 'None' in this context
       form: None
   location: &lt;REPL Input&gt;:1
</pre>

<p><div class="rs-tip-major">Poznámka: V&nbsp;případě <strong>nil</strong> se
nejedná o žádnou novinku, protože <strong>nil</strong> najdeme i v&nbsp;dalších
programovacích jazycích. Poprvé se, i když v&nbsp;poněkud jiném významu,
objevil <a
href="https://www.root.cz/clanky/programovaci-jazyk-lisp-a-lisp-machines/">v&nbsp;původním
Lispu</a> a jazycích od něho odvozených (<a
href="https://www.root.cz/clanky/zaklady-programovani-v-jazyku-scheme/">Scheme</a>,
<a href="https://www.root.cz/vyhledavani/?qs=clojure">Clojure</a>); najdeme ho
i v&nbsp;<a
href="https://www.root.cz/serialy/programovaci-jazyk-lua/">programovacím jazyce
Lua</a> či v&nbsp;klasickém Pascalu. V&nbsp;některých dalších programovacích
jazycích se objevují jiná označení pro neznámou či nulovou hodnotu; typicky se
jedná o identifikátory <strong>NULL</strong>, <strong>null</strong> a taktéž
<strong>None</strong>. V&nbsp;následující tabulce se pro zajímavost můžete
podívat, jaký je vznik a význam všech těchto názvů:</div></p>

<table>
<tr><th>Slovo</th><th>Původ</th><th>Význam</th></tr>
<tr><td>null</td><td>latina</td><td>ne+ullus, žádný</td></tr>
<tr><td>nil</td><td>latina</td><td>nihil, nic (též zkratka &bdquo;Not In List&ldquo;)</td></tr>
<tr><td>none</td><td>stará angličtina</td><td>ne+an, ani jeden</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Symboly a hesla</h2>

<p>Nejjednodušší typ formy &ndash; <i>literály</i> &ndash; jsme si již popsali
<a href="#k06">v&nbsp;předchozí kapitole</a>, takže se pojďme věnovat dalším
třem typům forem. Druhým typem formy podporovaným programovacím jazykem
<i>Basilisp</i> jsou takzvané <i>symboly</i> známé už z&nbsp;klasického
<i>LISPu</i> (i Clojure), ke kterým se v&nbsp;<i>Basilisp</i> ještě přidávají
<i>keywords</i>. Začněme s&nbsp;popisem &bdquo;keywords&ldquo;. Překlad tohoto
slova je poněkud problematický kvůli jeho dvojímu významu (alespoň
v&nbsp;programování), takže se pokusím používat sousloví &bdquo;klíčová
hesla&ldquo;, protože termín &bdquo;keywords&ldquo; v&nbsp;<i>Basilisp</i>
<strong>ne</strong>znamená, že by se jednalo o rezervovaná klíčová slova
jazyka. Klíčová hesla jsou na použití jednodušší než symboly, protože se ve
smyčce <i>REPL</i> vyhodnocují samy na sebe a nemůže jim být přiřazena žádná
hodnota.</p>

<p>Zbývá odpovědět na otázku, k&nbsp;jakým účelům se tedy vlastně v&nbsp;praxi
tento typ formy hodí? Jedním z&nbsp;důvodů zavedení tohoto typu formy do
programovacího jazyka <i>Basilisp</i> byla podpora pro velmi užitečný datový
typ (kolekce) nazvaný <i>mapa</i>, ve které je možné uchovávat dvojice
klíč:hodnota. A jako klíč jsou s&nbsp;výhodou používána právě klíčová hesla,
protože jejich hodnotu nelze měnit a navíc se jejich hešovací hodnota může
vypočítat pouze jedenkrát. Smyčka <i>REPL</i> pozná, že uživatel používá
klíčové heslo z&nbsp;toho, že je těsně před ním napsána dvojtečka. Jak již bylo
řečeno výše, vyhodnotí se heslo na sebe samu (což je odlišné od řetězců, které
se v&nbsp;jiných ohledech s&nbsp;hesly v&nbsp;mnoha ohledech podobají):</p>

<pre>
basilisp.user=&gt; <strong>:x</strong>
:x
&nbsp;
basilisp.user=&gt; <strong>:heslo</strong>
:symbol
&nbsp;
basilisp.user=&gt; <strong>:dalsi-heslo</strong>
:dalsi-heslo
&nbsp;
basilisp.user=&gt; <strong>:dalsi.heslo</strong>
:dalsi.heslo
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti je dvojtečka uváděná před
klíčovým heslem jen syntaktickým cukrem, protože &bdquo;plný&ldquo; zápis
(v&nbsp;tomto případě speciální) formy představující klíčové heslo vypadá
takto:</div></p>

<pre>
basilisp.user=&gt; <strong>(keyword "heslo")</strong>
:heslo
</pre>

<pre>
basilisp.user=&gt; <strong>(doc keyword)</strong>
------------------------
basilisp.core/keyword
([name] [ns name])
  Create a new keyword with ``name`` and optional namespace ``ns``\. Keywords will
  have the colon prefix added automatically, so it should not be provided.
&nbsp;
  ``name`` may be keyword, symbol, or string. If ``name`` is a keyword or symbol with a
  namespace, the namespace will be included in the resulting value. If ``name`` is a
  string with at least one '/', the string will be split on the first '/' character
  with the first segment being used as ``ns`` and the second as ``name``.
&nbsp;
  If ``ns`` is not ``nil``, then both ``name`` and ``ns`` must be strings.
</pre>

<p>Podobným typem formy jsou <i>symboly</i>, před jejichž jménem se používá
ampersand. Symbolům může být přiřazena hodnota a z&nbsp;tohoto důvodu se
používají pro pojmenování funkcí, proměnných či jmenných prostorů. Se symboly
se ještě v&nbsp;tomto článku několikrát setkáme, nyní si tedy jen ukažme, jak
se symboly zapisují a jakým způsobem je interaktivní smyčka REPL vyhodnotí:</p>

<pre>
basilisp.user=&gt; <strong>'symbol</strong>
symbol
&nbsp;
basilisp.user=&gt; <strong>'dalsi-symbol</strong>
dalsi-symbol
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že po vyhodnocení
v&nbsp;REPL &bdquo;zmizí&ldquo; apostrof původně uvedený před jménem
symbolu.</div></p>

<p>Podobně jako dvojtečka byla pouze syntaktickým cukrem pro speciální formu
<strong>(keyword "xxx")</strong>, je i ampersand zkrácenou podobou speciální
formy <strong>(quote symbol)</strong>. Předchozí příklad by tedy šel zapsat i
následujícím způsobem:</p>

<pre>
basilisp.user=&gt; <strong>(quote symbol)</strong>
symbol
</pre>

<p>To, že se v&nbsp;obou případech jedná skutečně o stejný symbol, lze zjistit
s&nbsp;využitím funkce ekvivalence (zde již trošku předbíháme, takže se prosím
k příkladu vraťte po dočtení celého článku):</p>

<pre>
basilisp.user=&gt; <strong>(= 'symbol (quote symbol))</strong>
true
</pre>

<p>Zatím je to poměrně nuda, že? Ale už se pomalu dostáváme k&nbsp;další
dvojici forem &ndash; složeným formám a speciálním formám &ndash; jejichž
vyhodnocování představuje srdce programovacího jazyka Basilisp.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Složené formy: strukturované datové typy</h2>

<p>V&nbsp;této kapitole si popíšeme takzvané <i>složené formy</i>, protože
právě tyto formy představují, společně s&nbsp;formami speciálními, jeden
z&nbsp;nejdůležitějších prvků programovacího jazyka <i>Basilisp</i> (a do jisté
míry je to podobné i u původního LISPu)). V&nbsp;tradičním LISPu je složenou
formou především seznam (<i>list</i>), což je ovšem jen zjednodušeně zapsaný
řetězec takzvaných tečka-dvojic. Koncept tečka-dvojic byl v&nbsp;Clojure a tím
pádem i v&nbsp;Basilispu opuštěn (samotný znak tečky zde dostal jiný význam
&ndash; volání metod), ovšem k&nbsp;seznamům navíc přibyly i další způsoby
zápisu složených forem, které se používají (opět v&nbsp;podstatě jako
syntaktický cukr) pro zápis následujících datových struktur: vektoru
(<i>vector</i>), množiny (<i>set</i>) a mapy (<i>map</i>).</p>

<p>Všechny čtyři typy složených forem (budeme je dále nazývat kolekce), ať již
se jedná o seznam, vektor, množinu či mapu, jsou při svém zápisu do zdrojového
kódu z&nbsp;obou stran uvozeny závorkami, přičemž musí být zachována párovost
závorek (ke každé otevírací závorce přísluší jedna závorka uzavírací), která je
kontrolována před vyhodnocením složené formy ve smyčce REPL.</p>

<p>V&nbsp;předchozím textu bylo napsáno, že základním typem složené formy je
seznam (<i>list</i>), jehož prvky se již tradičně (více než padesát let!)
zapisují do kulatých závorek. Pro zápis vektorů (<i>vector</i>) se používají
hranaté závorky, mapy (<i>map</i>) využívají závorky složené a množiny
(<i>set</i>) taktéž závorky složené, ovšem před otevírací závorkou se musí
napsat křížek (<i>hash, #</i>). V&nbsp;následující tabulce jsou vypsány všechny
čtyři typy složených forem. Kromě seznamů lze ostatní tři složené formy
(vektory, mapy, množiny) vytvořit i pomocí vhodného konstruktoru (třetí
sloupec), ovšem přesný význam tohoto zápisu si uvedeme až v&nbsp;následujících
kapitolách:</p>

<table>
<tr><th>Typ kolekce</th><th>Zápis (syntaktický cukr)</th><th>Konstruktor</th></tr>
<tr><td>Seznam</td><td>(prvky)</td><td>(list prvky)</td></tr>
<tr><td>Vektor</td><td>[prvky]</td><td>(vector prvky)</td></tr>
<tr><td>Mapa</td><td>{dvojice klíč-hodnota}</td><td>(hash-map dvojice klíč-hodnota)</td></tr>
<tr><td>Množina</td><td>#{unikátní prvky}</td><td>(hash-set unikátní prvky)</td></tr>
</table>

<p>Konstruktory všech čtyř strukturovaných datových typů mají i svoji (velmi
stručnou) nápovědu:</p>

<pre>
basilisp.user=&gt; <strong>(doc list)</strong>
------------------------
basilisp.core/list
([&amp; args])
  Create a list from the arguments.
&nbsp;
basilisp.user=&gt; <strong>(doc vector)</strong>
------------------------
basilisp.core/vector
([&amp; elems])
  Create a vector from the input arguments.
nil
&nbsp;
basilisp.user=&gt; <strong>(doc hash-map)</strong>
------------------------
basilisp.core/hash-map
([&amp; kvs])
  Create a hash map from pairs of input arguments.
nil
&nbsp;
basilisp.user=&gt; <strong>(doc hash-set)</strong>
------------------------
basilisp.core/hash-set
([&amp; members])
  Create a set from the input arguments.
nil
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Příklady konstrukce kolekcí v&nbsp;programovacím jazyku Basilisp</h2>

<p>V&nbsp;tabulce zobrazené v&nbsp;předchozí kapitole byl obsah všech čtyř typů
kolekcí popsán jen velmi vágně slovem &bdquo;prvky&ldquo;. Z&nbsp;tohoto důvodu
bude čtenáře tohoto článku více zajímat, jaké prvky v&nbsp;nich mohou být
skutečně uloženy. Může se jednat jak o literály (popsané v&nbsp;předchozích
kapitolách), symboly, klíčová hesla, tak i &ndash; což je nejzajímavější
&ndash; o jiné kolekce. Není tedy vůbec neobvyklé pracovat například se seznamy
uloženými v&nbsp;jiných seznamech, s&nbsp;mapami (v&nbsp;podstatě se
strukturami či záznamy), v&nbsp;nichž jsou uloženy vektory atd. Vzhledem
k&nbsp;tomu, že Basilisp je dynamicky typovaným programovacím jazykem, lze
v&nbsp;jakémkoli okamžiku získat typ každého prvku uloženého v&nbsp;kolekci.
Jak se to ve skutečnosti provádí si vysvětlíme v části věnované predikátům.
Podívejme se nyní na několik demonstračních příkladů, kde u každého příkladu
bude vysvětleno, co se vlastně provádí a z&nbsp;jakého důvodu Basilisp některý
typ formy nedokáže zpracovat.</p>

<p>Před seznamy se musí zapsat znak <i>quote</i>, jinak by došlo k&nbsp;jejich
vyhodnocení, jakoby se jednalo o zápis volání funkce. Seznamy pochopitelně
mohou být vnořené:</p>

<pre>
basilisp.user=&gt; <strong>'(1 2 3)</strong>
(1 2 3)
&nbsp;
basilisp.user=&gt; <strong>'(1 2 '(3 '(5 6) 7 8) 9 10)</strong>
(1 2 (quote (3 (quote (5 6)) 7 8)) 9 10)
</pre>

<p>Další seznamy:</p>

<pre>
basilisp.user=&gt; <strong>'('toto 'je 'seznam 'symbolů)</strong>
((quote toto) (quote je) (quote seznam) (quote symbolů))
&nbsp;
basilisp.user=&gt; <strong>'("toto" "je" "seznam" "řetězců")</strong>
("toto" "je" "seznam" "\u0159et\u011bzc\u016f")
</pre>

<p>Vektory resp.&nbsp;prvky vektorů se zapisují do hranatých závorek. Zde se
naopak znak <i>quote</i> nikdy nepoužívá:</p>

<pre>
basilisp.user=&gt; <strong>[1 2 3]</strong>
[1 2 3]
&nbsp;
basilisp.user=&gt; <strong>'(1 2 '(3 4 '(5 6) 7 8) 9 10)</strong>
(1 2 (quote (3 4 (quote (5 6)) 7 8)) 9 10)
&nbsp;
basilisp.user=&gt; <strong>[1 2 [3 4 [5 6] 7 8] 9 10]</strong>
[1 2 [3 4 [5 6] 7 8] 9 10]
</pre>

<p>Prázdný seznam a prázdný vektor se zapisuje takto:</p>

<pre>
basilisp.user=&gt; <strong>'()</strong>
()
&nbsp;
basilisp.user=&gt; <strong>()</strong>
()
&nbsp;
basilisp.user=&gt; <strong>[]</strong>
[]
</pre>

<p>Zápis množiny:</p>

<pre>
basilisp.user=&gt; <strong>#{1 2 3 4}</strong>
#{1 2 3 4}
</pre>

<p>Nebo:</p>

<pre>
basilisp.user=&gt; <strong>#{:i :toto :je :množina}</strong>
#{:je :toto :i :množina}
</pre>

<p>Prázdná množina:</p>

<pre>
basilisp.user=&gt; <strong>{}</strong>
{}
</pre>

<p>Pozor ovšem na to, že prvky množiny musí být unikátní:</p>

<pre>
basilisp.user=&gt; <strong>#{1 2 1 3 2 3 3 4}</strong>
&nbsp;
  exception: &lt;class 'basilisp.lang.reader.SyntaxError'&gt;
    message: Duplicated values in set: 1, 2, 3
       line: 1:18
</pre>

<p>A konečně se podívejme na zápis slovníku neboli asociativního pole:</p>

<pre>
basilisp.user=&gt; <strong>{:prvni 1 :druhy 2}</strong>
{:prvni 1 :druhy 2}
&nbsp;
basilisp.user=&gt; <strong>{:seznam '(:toto :je :seznam), :vektor [:toto :je :vektor] }</strong>
{:seznam (:toto :je :seznam) :vektor [:toto :je :vektor]}
</pre>

<p>Prázdný slovník:</p>

<pre>
basilisp.user=&gt; <strong>#{}</strong>
#{}
</pre>

<p>Načtení obsahu souboru typu JSON do slovníku (zde nepatrně předbíháme):</p>

<pre>
basilisp.user=&gt; <strong>(import basilisp.json)</strong>
&nbsp;
basilisp.user=&gt; <strong>(basilisp.json/read (open "configuration.json" "r"))</strong>
{"llama_stack" {"url" "http://localhost:8321" "api_key" "**********" "use_as_library_client" false "library_client_config_path" nil} "service" {"port" 8080 "access_log" true "auth_enabled" false "tls_config" {"tls_key_password" nil "tls_certificate_path" nil "tls_key_path" nil} "color_log" true "host" "0.0.0.0" "workers" 1} "name" "Lightspeed Core Service (LCS)"}
</pre>

<p>Ještě nepatrně složitější příklad:</p>

<pre>
basilisp.user=&gt; <strong>(basilisp.pprint/pprint (basilisp.json/read (open "configuration.json" "r")))</strong>
&nbsp;
{"llama_stack"
 {"url" "http://localhost:8321" "api_key" "**********" "use_as_library_client"
                                                       false
  "library_client_config_path" nil}
 "service"
 {"port" 8080
  "access_log" true
  "auth_enabled" false
  "tls_config" {"tls_key_password" nil
                "tls_certificate_path" nil
                "tls_key_path" nil}
  "color_log" true
  "host" "0.0.0.0"
  "workers" 1}
 "name" "Lightspeed Core Service (LCS)"}
nil
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Operace s&nbsp;kolekcemi a nekonečnými sekvencemi</h2>

<p>Všechny čtyři typy kolekcí popsaných v&nbsp;předchozích dvou kapitolách,
mají několik společných vlastností, které umožňují, aby se v&nbsp;programovacím
jazyku Basilisp mohly poměrně snadno vytvářet vícevláknové programy. Základní
vlastností společnou všem čtyřem typům kolekcí je jejich neměnitelnost
(<i>immutability</i>). To znamená, že již ve chvíli, kdy je kolekce vytvořena,
je po celou další dobu její existence v&nbsp;běžícím programu určen její obsah,
tj.&nbsp;hodnoty všech prvků kolekce. Na první pohled to sice možná může
vypadat zvláštně, ale i s&nbsp;takto se chovajícími kolekcemi je možné
v&nbsp;reálným programech pracovat a to dokonce často velmi efektivním
způsobem. Ostatně i ve standardní knihovně programovacího jazyka Python
existují některé třídy, jejichž instance jsou neměnné. Typickým a všeobecně
známým příkladem jsou řetězce představované třídou <strong>string</strong>.</p>

<p>Kromě neměnitelnosti (<i>immutability</i>) je další společnou vlastností
všech čtyř typů kolekcí jejich <i>persistence</i>. Většina standardních funkcí
poskytovaná programovacím jazykem Basilisp se totiž snaží o to, aby jednou
vytvořené sekvence (dejme tomu seznam) byly znovupoužity i v&nbsp;případě, že
je vytvořen nový seznam, který v&nbsp;sobě obsahuje i seznam starší (ten stále
existuje a mohou na něj existovat reference používané například i v&nbsp;jiných
paralelně či souběžně běžících vláknech).</p>

<p>Vzhledem k&nbsp;tomu, že se obsah starého seznamu nemůže změnit (seznam je
neměnitelný), může například funkce <strong>cons</strong> známá již
z&nbsp;LISPu jednoduše k&nbsp;seznamu přidat nový první prvek (<i>head</i>)
s&nbsp;tím, že tento prvek ukazuje na původní seznam &ndash; jinými slovy není
nutné, alespoň v&nbsp;tomto případě, vytvářet kopii (ať již plytkou či
hlubokou) původního seznamu, což přispívá k&nbsp;tomu, že mnohé operace nad
kolekcemi jsou ve skutečnosti velmi rychlé, i když by se podle jejich popisu
mohlo zdát, že jejich implementace vyžaduje provedení časově složitých operací
(nebo přesunů bloků dat v&nbsp;paměti).</p>

<p>Podobně funkce <strong>pop</strong>, kterou skalní LISPaři pravděpodobně
znají pod názvem <strong>cdr</strong>, vrátí &bdquo;nový&ldquo; seznam
vytvořený z&nbsp;původního seznamu takovým způsobem, že se z&nbsp;něj
&bdquo;odstraní&ldquo; první prvek. Ve skutečnosti se však žádný nový seznam
nevytváří a již vůbec se nikde žádný prvek neodstraňuje, pouze se jednoduše
vrátí reference na druhý prvek původního seznamu, popř.&nbsp;prázdný seznam (),
pokud žádný druhý prvek v&nbsp;seznamu uložen není:</p>

<pre>
basilisp.user=&gt; <strong>(pop [1 2 3])</strong>
[1 2]
</pre>

<p>Podobnou operaci lze provést i s&nbsp;vektory:</p>

<pre>
basilisp.user=&gt; <strong>(pop '(1 2 3))</strong>
(2 3)
</pre>

<p>Další operace s&nbsp;kolekcemi:</p>

<pre>
basilisp.user=&gt; <strong>(peek '(1 2 3))</strong>
1
</pre>

<pre>
basilisp.user=&gt; <strong>(peek [1 2 3])</strong>
3
</pre>

<p>S&nbsp;kolekcemi lze pracovat i jako by se jednalo o sekvence:</p>

<pre>
basilisp.user=&gt; <strong>(first '(1 2 3))</strong>
1
</pre>

<pre>
basilisp.user=&gt; <strong>(first [1 2 3])</strong>
1
</pre>

<p>Třetí společnou vlastností všech čtyř typů kolekcí je to, že se
v&nbsp;každém případě vždy správně vyhodnotí jejich ekvivalence či
neekvivalence, nezávisle na tom, jakým způsobem kolekce vznikla. Programovací
jazyk Basilisp v&nbsp;tomto případě ovšem nemůže pouze jednoduše porovnat
rovnost referencí ukazujících na porovnávané kolekce (například dva seznamy),
ale mnohdy musí rekurzivně procházet jak samotnými porovnávanými kolekcemi, tak
i jejich prvky, jež taktéž mohou být kolekcemi. Naproti tomu například
v&nbsp;Javě to není vždy tak jednoduché, jak by se možná mohlo na první pohled
zdát, protože porovnání dvou objektů vyžaduje překrytí metody
<strong>Object</strong>.equals() a tím pádem i detailní znalost interních
struktur porovnávaných objektů.</p>

<p>Kolekce lze spojovat do nové kolekce. K&nbsp;tomuto účelu se používají
funkce <strong>cons</strong> (<i>konstruktor</i>) a <strong>conj</strong>. Ty
se od sebe liší podle použité kolekce i pořadím parametrů:</p>

<pre>
basilisp.user=&gt; <strong>(cons 1 [2 3 4])</strong>
(1 2 3 4)
</pre>

<pre>
basilisp.user=&gt; <strong>(conj [1 2 3] 4)</strong>
[1 2 3 4]
</pre>

<p>Ovšem u seznamů se výsledky <strong>conj</strong> liší!:</p>

<pre>
basilisp.user=&gt; <strong>(cons 1 '(2 3 4))</strong>
(1 2 3 4)
</pre>

<pre>
basilisp.user=&gt; <strong>(conj '(1 2 3) 4)</strong>
(4 1 2 3)
</pre>

<p>Seznam (kolekce) může vzniknout i jako výsledek dalších operací,
například:</p>

<p>Aplikace funkce na všechny prvky zdrojové kolekce:</p>

<pre>
basilisp.user=&gt; <strong>(map inc '(1 2 3 4 5 6 7 8))</strong>
(2 3 4 5 6 7 8 9)
</pre>

<p>Aplikace funkce postupně na všechny n-tice získané ze zdrojových
kolekcí:</p>

<pre>
basilisp.user=&gt; <strong>(map * [1 2 3 4] [5 6 7 8])</strong>
(5 12 21 32)
</pre>

<p>Dtto:</p>

<pre>
basilisp.user=&gt; <strong>(map / (range 10) (range 1 10))</strong>
(0 1/2 2/3 3/4 4/5 5/6 6/7 7/8 8/9)
</pre>

<p>Pracovat je možné i s&nbsp;nekonečnými sekvencemi, které se vyhodnocují
<i>líně</i>:</p>

<pre>
basilisp.user=&gt; <strong>(doc take)</strong>
------------------------
basilisp.core/take
([n] [n coll])
  Return the first ``n`` elements of ``coll``\.
</pre>

<p>Použití této funkce na nekonečné vstupní sekvence:</p>

<pre>
basilisp.user=&gt; <strong>(take 5 (repeat "x"))</strong>
("x" "x" "x" "x" "x")
</pre>

<p>I <strong>(range)</strong> je generátorem nekonečné sekvence hodnot:</p>

<pre>
basilisp.user=&gt; <strong>(take 10 (range))</strong>
(0 1 2 3 4 5 6 7 8 9)
</pre>

<p>Naproti tomu <strong>(range x y)</strong> vytváří konečnou sekvenci hodnot:</p>

<pre>
basilisp.user=&gt; <strong>(defn factorial</strong>
                <strong>[n]</strong>
                <strong>(reduce * (range 1 (inc n))))</strong>
#'basilisp.user/factorial
&nbsp;
basilisp.user=&gt; <strong>(factorial 3)</strong>
6
&nbsp;
basilisp.user=&gt; <strong>(factorial 100)</strong>
9332621544394415268169923885626670049071
5968264381621468592963895217599993229915
6089414639761565182862536979208272237582
51185210916864000000000000000000000000
</pre>

<p>Otestování funkce pro výpočet faktoriálu:</p>

<pre>
basilisp.user=&gt; <strong>(dotimes [n 10] (println n (factorial n)))</strong>
0 1
1 1
2 2
3 6
4 24
5 120
6 720
7 5040
8 40320
9 362880
nil
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Predikáty, zjištění typových informací za běhu</h2>

<p>Predikáty jsou funkce vracející pravdivostní hodnotu <strong>true</strong>
nebo <strong>false</strong>. V&nbsp;některých variantách programovacího jazyka
LISP bylo zvykem za jméno predikátu dávat znak &bdquo;p&ldquo;, takže například
funkce/predikát pro test na nulovou hodnotu (velmi často používaný predikát)
měl název <strong>zerop</strong>. V&nbsp;programovacím jazyku Basilisp se
namísto znaku &bdquo;p&ldquo; používá otazník, protože i otazník může být
součástí názvu identifikátoru. V&nbsp;následující tabulce jsou vypsány základní
predikáty:</p>

<table>
<tr><td># </td><td>Predikát </td><td>Význam</td></tr>
<tr><td>1 </td><td>nil? </td><td>test, zda je předaná hodnota rovna literálu nil</td></tr>
<tr><td>2 </td><td>true? </td><td>test, zda je předaná hodnota rovna literálu true</td></tr>
<tr><td>3 </td><td>false? </td><td>test, zda je předaná hodnota rovna literálu false</td></tr>
<tr><td>4 </td><td>number? </td><td>test na číslo (libovolného typu)</td></tr>
<tr><td>5 </td><td>integer? </td><td>test na celé číslo</td></tr>
<tr><td>6 </td><td>ratio? </td><td>test na zlomek (nikoli na obecné desetinné číslo)</td></tr>
<tr><td>7 </td><td>float? </td><td>test na desetinné číslo</td></tr>
<tr><td>8 </td><td>decimal? </td><td>test na hodnotu typu BigDecimal</td></tr>
<tr><td>9 </td><td>even? </td><td>test na sudou hodnotu</td></tr>
<tr><td>10 </td><td>odd? </td><td>test na lichou hodnotu</td></tr>
<tr><td>11 </td><td>pos? </td><td>test na kladnou hodnotu</td></tr>
<tr><td>12 </td><td>neg? </td><td>test na zápornou hodnotu</td></tr>
<tr><td>13 </td><td>zero? </td><td>test na nulu</td></tr>
<tr><td>14 </td><td>keyword? </td><td>test, zda je předaná hodnota typu klíčové heslo</td></tr>
<tr><td>15 </td><td>symbol? </td><td>test, zda je předaná hodnota typu symbol</td></tr>
<tr><td>16 </td><td>char? </td><td>test, zda je předaná hodnota typu char</td></tr>
<tr><td>17 </td><td>string? </td><td>test, zda je předaná hodnota typu řetězec</td></tr>
<tr><td>18 </td><td>seq? </td><td>test, zda je předaná hodnota typu sekvence</td></tr>
</table>

<p>Příklady volání predikátů:</p>

<pre>
basilisp.user=&gt; <strong>(nil? nil)</strong>
true
&nbsp;
basilisp.user=&gt; <strong>(nil? '())</strong>
false
&nbsp;
basilisp.user=&gt; <strong>(nil? ())</strong>
false
&nbsp;
basilisp.user=&gt; <strong>(neg? -42)</strong>
true
&nbsp;
basilisp.user=&gt; <strong>(neg? 42)</strong>
false
&nbsp;
basilisp.user=&gt; <strong>(ratio? 1/2)</strong>
true
&nbsp;
basilisp.user=&gt; <strong>(ratio? 1)</strong>
false
</pre>

<p>V&nbsp;některých případech je důležité zjistit typ hodnoty, a to za běhu
aplikace. K&nbsp;tomuto účelu lze použít funkci <strong>type</strong> známou
přímo z&nbsp;Pythonu. Příklady volání této funkce:</p>

<pre>
basilisp.user=&gt; <strong>(type nil)</strong>
&lt;class 'NoneType'&gt;
&nbsp;
basilisp.user=&gt; <strong>(type true)</strong>
&lt;class 'bool'&gt;
&nbsp;
basilisp.user=&gt; <strong>(type 'symbol)</strong>
&lt;class 'basilisp.lang.symbol.Symbol'&gt;
&nbsp;
basilisp.user=&gt; <strong>(type :heslo)</strong>
&lt;class 'basilisp.lang.keyword.Keyword'&gt;
&nbsp;
basilisp.user=&gt; <strong>(type '())</strong>
&lt;class 'basilisp.lang.list.PersistentList'&gt;
&nbsp;
basilisp.user=&gt; <strong>(type [])</strong>
&lt;class 'basilisp.lang.vector.PersistentVector'&gt;
&nbsp;
basilisp.user=&gt; <strong>(type #{})</strong>
&lt;class 'basilisp.lang.set.PersistentSet'&gt;
&nbsp;
basilisp.user=&gt; <strong>(type {})</strong>
&lt;class 'basilisp.lang.map.PersistentMap'&gt;
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že seznamy, vektory,
množiny i slovníky jsou <i>perzistentními</i> datovými strukturami.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Řídicí struktury (speciální formy a makra)</h2>

<p>Programovací jazyk <i>Basilisp</i> nabízí programátorům několik základních
řídicích struktur, které jsou představovány takzvanými <i>speciálními
formami</i> (ty se vyhodnocují jinak, než běžné funkce, proto jsou ostatně
nazývány &bdquo;speciální&ldquo;). Jedná se především o formy se jmény
<strong>if</strong>, <strong>loop</strong> a <strong>recur</strong>. Ovšem díky
makrosystému, tedy možnosti tvorby uživatelských maker, můžeme
v&nbsp;aplikacích psaných v&nbsp;Basilispu použít mnohem více řídicích
struktur, které jsou interně postaveny právě na výše zmíněné trojici (celý
Basilisp je, podobně jako jeho ideový předchůdce jazyk Clojure, stavebnicí
s&nbsp;malým množstvím základních prvků). V&nbsp;následující tabulce jsou
vypsány některé z&nbsp;nich (prozatím se soustředíme na rozhodování a
rozvětvení toku programu):</p>

<table>
<tr><th> #</th><th>Konstrukce</th><th>Typ</th><th>Stručný popis</th></tr>
<tr><td> 1</td><td>if</td><td>speciální forma</td><td>základní rozhodovací konstrukce, základ pro další makra</td></tr>
<tr><td> 2</td><td>if+do</td><td>dvě speciální formy</td><td>použito ve chvíli, kdy je nutné do jedné větve či obou větví zapsat více výrazů</td></tr>
<tr><td> 3</td><td>if-let</td><td>makro</td><td>kombinace speciálních forem <strong>if</strong> a <strong>let</strong></td></tr>
<tr><td> 4</td><td>if-some</td><td>makro</td><td>kombinace speciálních forem <strong>if</strong> (test na <strong>nil</strong>) a <strong>let</strong></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>and</td><td>makro</td><td>postupné vyhodnocování předaných výrazů až do chvíle, kdy se vrátí <strong>nil</strong> či <strong>false</strong> (jediné &bdquo;nepravdy&ldquo;)</td></tr>
<tr><td> 6</td><td>or</td><td>makro</td><td>postupné vyhodnocování předaných výrazů až do chvíle, kdy se vrátí <strong>true</strong></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>when</td><td>makro</td><td>vhodná náhrada za <strong>if</strong> s&nbsp;jedinou větví s&nbsp;více výrazy</td></tr>
<tr><td> 8</td><td>when-not</td><td>makro</td><td>vhodná náhrada za <strong>if-not</strong> s&nbsp;jedinou větví s&nbsp;více výrazy</td></tr>
<tr><td> 9</td><td>when-let</td><td>makro</td><td>kombinace speciálních forem <strong>when</strong> a <strong>let</strong></td></tr>
<tr><td>10</td><td>when-some</td><td>makro</td><td>kombinace speciálních forem <strong>when</strong> (test na <strong>nil</strong>) a <strong>let</strong></td></tr>
<tr><td>11</td><td>when-first</td><td>makro</td><td>použito při testu prvního prvku sekvence s&nbsp;následným zpracováním sekvence</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>12</td><td>cond</td><td>makro</td><td>postupné testování podmínek, pokud je podmínka splněna, vrátí se hodnota příslušného výrazu</td></tr>
<tr><td>13</td><td>cond + :else </td><td>makro</td><td>typické použití makra <strong>cond</strong> s&nbsp;větví <strong>:else</strong> nebo <strong>:default</strong></td></tr>
<tr><td>14</td><td>condp</td><td>makro</td><td>postupné dosazování testované hodnoty do zadaného výrazu, obdoba <strong>switch-case</strong></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>cond-&gt;</td><td>makro</td><td>odvozeno od <strong>cond</strong>, bude popsáno příště</td></tr>
<tr><td>16</td><td>cond-&gt;&gt;</td><td>makro</td><td>odvozeno od <strong>cond</strong>, bude popsáno příště</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>17</td><td>case</td><td>makro</td><td>další forma realizace rozvětvení</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: při studiu výše zmíněných forem se
vývojáři mohou přiučit i to, jak vlastně interně pracuje makrosystém
programovacího jazyka Basilisp. Tímto tématem jsme se částečně zabývali <a
href="https://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">zde</a>
v&nbsp;kontextu jazyka Clojure, ale prakticky totéž platí i pro
Basilisp.</div></p>

<p>Pro mnoho z&nbsp;výše uvedených forem je k&nbsp;dispozici i nápověda:</p>

<pre>
basilisp.user=&gt; <strong>(doc if-let)</strong>
------------------------
basilisp.core/if-let
([&amp;env &amp;form binding true-cond false-cond])
  Evaluate the binding as with ``let``, binding the given name for use in the ``true``
  expression iff the binding expression is truthy . Otherwise, return the ``false``
  expression without binding the name.
nil
</pre>

<pre>
basilisp.user=&gt; <strong>(doc case)</strong>
------------------------
basilisp.core/case
([&amp;env &amp;form expr &amp; clauses])
  Switch on ``expr`` to return a matching clause from the set of input clauses.
&nbsp;
  The input expression may be any valid Basilisp expression. A single default expression
  can follow the clauses, and its value will be returned if no clause matches.
&nbsp;
  The clauses are pairs of a matching value and a return value. The matching values are
  not evaluated and must be compile-time constants. Symbols will not be resolved. Lists
  may be passed to match multiple compile time values to a single return value. The
  dispatch is done in constant time.
nil
</pre>

<pre>
basilisp.user=&gt; <strong>(doc cond-&gt;&gt;)</strong>
------------------------
basilisp.core/cond-&gt;&gt;
([&amp;env &amp;form x &amp; clauses])
  Takes a test and form pair, threading ``x`` (as by :lpy:fn:`-&gt;&gt;`) through each form
  for which the corresponding test evaluates as ``true``\. ``cond-&gt;&gt;`` does not short
  circuit evaluation in any case.
nil
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Ukázky využití vybraných řídicích struktur</h2>

<p>Všechna makra popsaná v&nbsp;dalším textu jsou založena na využití speciální
formy <strong>if</strong>, jejíž různé varianty si popíšeme v&nbsp;této
kapitole.</p>

<p>Nejprve vytvoříme několik jmen navázaných na hodnoty (což je
v&nbsp;programovacím jazyku Basilisp obdoba konstant). Tyto hodnoty budou
použity v&nbsp;podmínkách uvedených později:</p>

<pre>
<strong>(def x 10)</strong>
<strong>(def y 20)</strong>
<strong>(def z 20)</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;naprosté většině skutečných
aplikací by se <strong>def</strong> tímto způsobem nepoužívalo, nebo alespoň ne
frekventovaně, protože to vede k&nbsp;vytvoření obdoby hodnot dostupných
&bdquo;globálně&ldquo; v&nbsp;rámci celého jmenného prostoru.</div></p>

<p>Základní rozhodovací konstrukce je tvořena speciální formou
<strong>if</strong>, která existuje ve dvou variantách &ndash; pouze
s&nbsp;větví <strong>then</strong> a s&nbsp;oběma větvemi <strong>then</strong>
i <strong>else</strong>. Tuto speciální formu lze tedy zapsat ve zkrácené
podobě:</p>

<pre>
<strong>(<u>if</u> test větev-then)</strong>
</pre>

<p>nebo v&nbsp;plné podobě:</p>

<pre>
<strong>(<u>if</u> test větev-then větev-else)</strong>
</pre>

<p>Speciální formu <strong>if</strong> je možné použít ve formě rozvětvení, což
je konstrukce známá například z&nbsp;programovacích jazyků C, <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">Go</a>, Pascalu, <a
href="https://www.root.cz/n/python/">Pythonu</a> atd. V&nbsp;tomto případě se
(nyní již v&nbsp;Basilisp) typicky setkáme s&nbsp;funkcemi nebo makry
s&nbsp;vedlejším efektem, které jsou ve větvi <strong>then</strong>
použity:</p>

<pre>
<strong>(<u>if</u> (&lt; x y)</strong>
  <strong>(println "x &lt; y"))</strong>
&nbsp;
x &lt; y
nil
</pre>

<p>V&nbsp;programovacím jazyku Basilisp a současně i ve všech LISPovských
programovacích se speciální forma <strong>if</strong> vyhodnocuje a následně se
vrátí výsledek tohoto vyhodnocení. Pokud je podmínka splněna, je vrácena
hodnota funkce/makra ve větvi <strong>then</strong>, v&nbsp;opačném případě je
vrácena hodnota funkce/makra ve větvi <strong>else</strong> nebo
<strong>nil</strong> tehdy, pokud větev <strong>else</strong> není vůbec
zapsána:</p>

<pre>
<strong>(<u>if</u> (&lt; x y)</strong>
  <strong>(+ x y))</strong>
&nbsp;
30
</pre>

<p>Nebo ještě jednodušeji:</p>

<pre>
<strong>(<u>if</u> (&lt; x y)</strong>
  <strong>:mensi)</strong>
&nbsp;
:mensi
</pre>

<p>Následující konstrukce vrátí hodnotu <strong>nil</strong>, protože podmínka
není splněna a současně není zapsána větev <strong>else</strong>:</p>

<pre>
<strong>(<u>if</u> (&lt; y x)</strong>
  <strong>(+ x y))</strong>
&nbsp;
nil
</pre>

<p>resp:</p>

<pre>
<strong>(<u>if</u> (&gt; x y)</strong>
  <strong>:vetsi)</strong>
&nbsp;
nil
</pre>

<p>Zápis s&nbsp;oběma větvemi:</p>

<pre>
<strong>(<u>if</u> (&lt; x y)</strong>
  <strong>(println "x &lt; y")</strong>
  <strong>(println "x &gt; y"))</strong>
&nbsp;
x &lt; y
nil
</pre>

<p>Konstrukce <strong>if</strong> je možné vnořovat:</p>

<pre>
<strong>(<u>if</u> (zero? x)</strong>
  <strong>:nulove</strong>
  <strong>(<u>if</u> (neg? x)</strong>
    <strong>:zaporne</strong>
    <strong>:kladne))</strong>
</pre>

<p>Praktičtější příklad &ndash; výpočet největšího společného dělitele:</p>

<pre>
<strong>(defn gcd</strong>
  <strong>[x y]</strong>
  <strong>(<u>if</u> (= x y)</strong>
    <strong>x</strong>
    <strong>(<u>if</u> (&gt; x y)</strong>
      <strong>(gcd (- x y) y)</strong>
      <strong>(gcd x (- y x)))))</strong>
&nbsp;
<strong>(println (gcd 64 24))</strong>
8
nil
</pre>

<p><div class="rs-tip-major">Poznámka: nyní se nám ve zdrojovém kódu
&bdquo;hromadí&ldquo; kulaté závorky :-)</div></p>

<p>V&nbsp;tomto případě je však lepší použít konstrukci <strong>cond</strong>
popsanou níže.</p>

<p>Mnohdy se setkáme s&nbsp;požadavkem, že se v&nbsp;jedné větvi speciální
formy <strong>if</strong> popř.&nbsp;v&nbsp;obou větvích má použít více funkcí
s&nbsp;vedlejším efektem (volání více funkcí bez vedlejšího efektu nemá význam,
i když není zakázáno). Tento požadavek, který je v&nbsp;Algolských
programovacích jazycích (C, Pascal, JavaScript, Go, ...) vyřešen
s&nbsp;využitím programových bloků (složené závorky), by bylo možné otrocky
přepsat do jazyka Basilisp pomocí speciální formy <strong>do</strong>:</p>

<pre>
<strong>(<u>if</u> (&lt; x y)</strong>
  <strong>(<u>do</u></strong>
    <strong>(println "x &lt; y")</strong>
    <strong>:mensi)</strong>
  <strong>(<u>do</u></strong>
    <strong>(println "x &gt; y")</strong>
    <strong>:vetsi))</strong>
</pre>

<p>Ve skutečnosti je však výše zmíněná kombinace <strong>if</strong> +
<strong>do</strong> velmi špatně čitelná, nehledě na to, že se kód začíná
ztrácet ve velkém množství kulatých závorek. Existuje však i (pro mnoho účelů)
lepší řešení. Pokud konstrukce <strong>if</strong> obsahuje pouze jedinou větev
(předpokládejme nyní pro určité zjednodušení, že se jedná o větev
<strong>then</strong>), lze namísto speciální formy <strong>if</strong> použít
makro nazvané příznačně <strong>when</strong>:</p>

<pre>
basilisp.user=&gt; <strong>(doc when)</strong>
------------------------
basilisp.core/when
([&amp;env &amp;form cond &amp; body])
  Evaluate ``cond`` and if it is truthy, execute body in an implicit ``do`` block.
nil
</pre>

<p>Následuje ukázka příkladu použití tohoto makra v&nbsp;situaci, kdy se má při
splnění podmínky vykonat více funkcí (s&nbsp;vedlejším efektem) a navíc se má
vrátit nějaká hodnota, typicky s&nbsp;využitím funkce <i>bez</i> vedlejšího
efektu:</p>

<pre>
<strong>(<u>when</u> (&lt; x y)</strong>
  <strong>(println "----------")</strong>
  <strong>(println "x &lt; y")</strong>
  <strong>(println "----------")</strong>
  <strong>:mensi)</strong>
&nbsp;
x &lt; y
:mensi
</pre>

<p>Následuje nepatrně složitější příklad vracející výsledek funkce
<strong>+</strong>:</p>

<pre>
<strong>(<u>when</u> (&lt; x y)</strong>
  <strong>(println "----------")</strong>
  <strong>(println "x &lt; y")</strong>
  <strong>(println "----------")</strong>
  <strong>(+ x y))</strong>
&nbsp;
x &lt; y
30
</pre>

<p>Blok vykonaný pro opačnou podmínku se zapisuje formou
<strong>when-not</strong>:</p>

<pre>
basilisp.user=&gt; <strong>(doc when-not)</strong>
------------------------
basilisp.core/when-not
([&amp;env &amp;form cond &amp; body])
  Evaluate ``cond`` and if it is falsey, execute body in an implicit ``do`` block.
nil
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Konstrukce <strong>cond</strong> a <strong>condp</strong></h2>

<p>Všechny rozhodovací konstrukce popsané v&nbsp;předchozí kapitole prováděly
rozvětvení toku programu na základě vyhodnocení jediné podmínky.  Ovšem
v&nbsp;praxi se velmi často setkáme s&nbsp;nutností rozhodovat se na základě
většího množství podmínek popř.&nbsp;na základě většího množství hodnot (a
obecně pak na základě <i>pattern matchingu</i>, což si ukážeme příště). Pokud
je nutné provést rozhodnutí na základě více podmínek, nabízí se využití makra
nazvaného <strong>cond</strong>, které se mj.&nbsp;objevilo (i když jinak
zapisované) už v&nbsp;prvních verzích LISPu:</p>

<pre>
basilisp.user=&gt; <strong>(doc cond)</strong>
------------------------
basilisp.core/cond
([&amp;env &amp;form &amp; clauses])
  Given groups of test/expression pairs, evaluate each test and, if ``true``\, return
  the expression. Otherwise, continue through until reaching the final expression.
nil
</pre>

<p>Tomuto makru se předávají dvojice test+výraz. Pokud je test splněn, je
vrácena hodnota příslušného výrazu. Poslední test bývá zapsán formou symbolu,
který se vždy vyhodnotí na pravdu &ndash; což je vlastně jakýkoli symbol
rozdílný od <strong>false</strong> nebo <strong>nil</strong>. Typicky se
používá symbol <strong>:else</strong>, ovšem někteří vývojáři dávají přednost
<strong>:default</strong> (takže se jedná o céčkaře nebo Javisty :-).</p>

<p>Funkci pro výpočet znaménka lze s&nbsp;využitím makra <strong>cond</strong>
přepsat následujícím způsobem:</p>

<pre>
<strong>(defn sgn-3</strong>
  <strong>[x]</strong>
  <strong>(<u>cond</u> (pos? x) 1</strong>
        <strong>(neg? x) -1</strong>
        <strong>true 0))</strong>
</pre>

<p>Otestování funkcionality takto upravené funkce je snadné:</p>

<pre>
<strong>(doseq [value [-100 -1 0 1 100]]</strong>
        <strong>(println (sgn-3 value)))</strong>
</pre>

<p>Se shodnými výsledky, jako tomu bylo v&nbsp;předchozích příkladech:</p>

<pre>
-1
-1
0
1
1
</pre>

<p>Poslední test se ovšem většinou zapisuje symbolem
<strong>:else</strong>:</p>

<pre>
<strong>(defn sgn-4</strong>
  <strong>[x]</strong>
  <strong>(<u>cond</u> (pos? x)  1</strong>
        <strong>(neg? x) -1</strong>
        <strong>:else     0))</strong>
</pre>

<p>nebo <strong>:default</strong>:</p>

<pre>
<strong>(defn sgn-5</strong>
  <strong>[x]</strong>
  <strong>(<u>cond</u> (pos? x)  1</strong>
        <strong>(neg? x) -1</strong>
        <strong>:default  0))</strong>
</pre>

<p>Přepis funkce pro výpočet největšího společného dělitele:</p>

<pre>
<strong>(defn gcd-2</strong>
  <strong>[x y]</strong>
  <strong>(<u>cond</u></strong>
    <strong>(= x y) x</strong>
    <strong>(&gt; x y) (gcd-2 (- x y) y)</strong>
    <strong>:else   (gcd-2 x (- y x))))</strong>
</pre>

<p>S&nbsp;otestováním:</p>

<pre>
<strong>(println (gcd-2 64 24))</strong>
8
nil
&nbsp;
<strong>(println (gcd-2 123456 6543216))</strong>
48
nil
</pre>

<p>Pokusme se nyní výraz s&nbsp;makrem <strong>cond</strong> expandovat,
abychom zjistili, jaký kód bude vlastně přeložen do bajtkódu:</p>

<pre>
<strong>(macroexpand</strong>
  <strong>'(cond (pos? x)  1</strong>
         <strong>(neg? x) -1</strong>
         <strong>:else     0))</strong>
</pre>

<p>Výsledkem expanze bude:</p>

<pre>
(if (pos? x) 1 (basilisp.core/cond (neg? x) -1 :else 0))
</pre>

<p>Plná expanze makra:</p>

<pre>
basilisp.user=&gt; <strong>(macroexpand-all</strong>
                  '(cond (pos? x)  1
                         (neg? x) -1
                         :else     0))
</pre>

<p>Výsledek už bude obsahovat jen vnořenou speciální formu
<strong>if</strong>:</p>

<pre>
(if (pos? x) 1 (if (neg? x) -1 (if :else 0 nil)))
</pre>

<p>Pro zajímavost si vyzkoušejme expanzi složitějšího výrazu, který převádí
bodové ohodnocení na známky:</p>

<pre>
<strong>(let [grade 85]</strong>
  <strong>(cond</strong>
    <strong>(&gt;= grade 90) "A"</strong>
    <strong>(&gt;= grade 80) "B"</strong>
    <strong>(&gt;= grade 70) "C"</strong>
    <strong>(&gt;= grade 55) "D"</strong>
    <strong>:else         "F"))</strong>
</pre>

<p>Expanze:</p>

<pre>
basilisp.user=&gt; <strong>(macroexpand</strong>
                  '(cond
                    (&gt;= grade 90) "A"
                    (&gt;= grade 80) "B"
                    (&gt;= grade 70) "C"
                    (&gt;= grade 55) "D"
                    :else "F"))
</pre>

<p>Výsledek:</p>

<pre>
(if (&gt;= grade 90) "A" (basilisp.core/cond (&gt;= grade 80) "B" (&gt;= grade 70) "C" (&gt;= grade 55) "D" :else "F"))
</pre>

<p>Plná expanze"</p>

<pre>
basilisp.user=&gt; <strong>(macroexpand-all</strong>
                  '(cond
                    (&gt;= grade 90) "A"
                    (&gt;= grade 80) "B"
                    (&gt;= grade 70) "C"
                    (&gt;= grade 55) "D"
                    :else "F"))
</pre>

<p>Výsledek bude opět obsahovat jen vnořenou speciální formu
<strong>if</strong>:</p>

<pre>
(if (&gt;= grade 90) "A" (if (&gt;= grade 80) "B" (if (&gt;= grade 70) "C" (if (&gt;= grade 55) "D" (if :else "F" nil)))))
</pre>

<p>Výše popsané makro <strong>cond</strong> je velmi univerzální, protože každý
test (kterých může být libovolné množství) je realizován plnohodnotným
predikátem, tj.&nbsp;funkcí, na základě jejíž (pravdivostní) návratové hodnoty
se rozhoduje, jestli se má provést příslušná větev či zda se má vyzkoušet další
test. Ve výsledku je toto makro expandováno na vnořené speciální formy
<strong>if</strong>. Ovšem mnohdy takovou univerzálnost nepotřebujeme a naopak
vyžadujeme, aby se výsledek nějakého výrazu porovnal se sekvencí známých
hodnot. Taková konstrukce, která je v&nbsp;C, C++ či Javě realizována přes
<strong>switch</strong>, se v&nbsp;programovacím jazyku Basilisp zapisuje
s&nbsp;využitím makra nazvaného <strong>condp</strong>:</p>

<pre>
basilisp.user=&gt; <strong>(doc condp)</strong>
------------------------
basilisp.core/condp
([&amp;env &amp;form pred expr &amp; clauses])
  Take a predicate and an expression and a series of clauses, call ``(pred test expr)``
  on the first expression for each clause. The result expression from first the set of
  clauses for which this expression returns a truthy value will be returned from the
  ``condp`` expression.

  Clauses can take two forms:

  - ``test-expr result-expr``
  - ``test-expr :&gt;&gt; result-fn`` where :&gt;&gt; is a keyword literal

  For the ternary expression clause, the unary ``result-fn`` will be called with the
  result of the predicate.

  A single final expression can be included at the end with no test expression which
  will be returned if no other clause matches the predicate. If no default is provided
  and no clause matches the predicate, a ``ValueError`` will be thrown.
nil
</pre>

<p>Z&nbsp;popisu je zřejmé, že je nutné uvést část výrazu, do kterého se
postupně doplňují hodnoty z&nbsp;testů v&nbsp;jednotlivých větvích &ndash;
skutečně se tedy jedná o obdobu <strong>case</strong> z&nbsp;C či Javy.
Poslední větev pochopitelně žádnou hodnotu pro otestování neobsahuje.</p>

<p>Podívejme se nyní na základní způsob použití tohoto makra. Na základě
předaného řetězce se rozhodneme, jaká hodnota se vrátí (jedná se o primitivní
transformaci, která by se v reálném programu realizovala přes mapu):</p>

<pre>
<strong>(let [value (read-line)]</strong>
  <strong>(<u>condp</u> = value</strong>
      <strong>"one"   1</strong>
      <strong>"two"   2</strong>
      <strong>"three" 3</strong>
      <strong>"four"  4</strong>
      <strong>"five"  5</strong>
              <strong>"unknown value"))</strong>
</pre>

<p>Samozřejmě namísto konstant ve větvích můžeme použít nějaký složitější
výraz, zde konkrétně volání funkcí +, - atd:</p>

<pre>
<strong>(let [value (read-line)]</strong>
  <strong>(<u>condp</u> = value</strong>
      <strong>"one"   (+ 0 1)</strong>
      <strong>"two"   (+ 1 1)</strong>
      <strong>"three" 3</strong>
      <strong>"four"  (* 2 2)</strong>
      <strong>"five"  5</strong>
              <strong>(str "unexpected value, \"" value \")))</strong>
</pre>

<p>Výrazy mohou být použity i v&nbsp;testovaných hodnotách (což představuje
rozdíl oproti některým výše zmíněným programovacím jazykům):</p>

<pre>
<strong>(let [value (read-line)]</strong>
  <strong>(<u>condp</u> = value</strong>
      <strong>"one"           (+ 0 1)</strong>
      <strong>(str "t" "wo")  (+ 1 1)</strong>
      <strong>(str "t" "ree") 3</strong>
      <strong>"four"          (* 2 2)</strong>
      <strong>"five"          5</strong>
                      <strong>(str "unexpected value, \"" value \")))</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: pro jednoduchost jsou všechny příklady
z&nbsp;této kapitoly dosti umělé; typicky &bdquo;školní&ldquo;.</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Balíčky dodávané se samotným jazykem Basilisp</h2>

<p></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Interoperabilita s&nbsp;Pythonem</h2>

<p>Nejdůležitějším rysem Basilispu je jeho schopnost relativně snadno volat kód
psaný v&nbsp;Pythonu. Bez této schopnosti by se jednalo &bdquo;jen&ldquo; o
další interpret LISPu, kterých vzniklo několik set. Ovšem fakt, že Basilisp
může volat jakoukoli funkci Pythonu (z&nbsp;libovolného balíčku) nebo metodu
jakékoli třídy, vlastně otevírá celý rozsáhlý ekosystém Pythonu světu
LISPu.</p>

<p>Ukažme si tuto schopnost na několika příkladech. Nejdříve načteme standardní
Pythonovský balíček <strong>datetime</strong> (způsobem importu se budeme
podrobněji zabývat v&nbsp;další kapitole):</p>

<pre>
basilisp.user=&gt; <strong>(import datetime)</strong>
nil
</pre>

<p>Zavolání funkce <strong>now</strong> vracející objekt. Do konzole se vypíše
tisknutelná podoba tohoto objektu:</p>

<pre>
basilisp.user=&gt; <strong>(datetime.datetime/now)</strong>
#inst "2025-11-11T16:18:25.492381"
</pre>

<p>Objekt (tedy instanci třídy) si můžeme uložit do nové proměnné nazvané
například <strong>now</strong>:</p>

<pre>
basilisp.user=&gt; <strong>(def now (datetime.datetime/now))</strong>
#'basilisp.user/now
</pre>

<p>Ověření, že pracujeme s&nbsp;typem &bdquo;objekt&ldquo;:</p>

<pre>
basilisp.user=&gt; <strong>(type now)</strong>
&lt;class 'datetime.datetime'&gt;
</pre>

<p>Můžeme získat i seznam atributů a metod, což není překvapivé, protože <strong>dir</strong> je původní funkce z&nbsp;Pythonu:</p>

<pre>
basilisp.user=&gt; <strong>(dir now)</strong>
#py ["__add__" "__class__" "__delattr__" "__dir__" "__doc__" "__eq__" "__format__"
"__ge__" "__getattribute__" "__getstate__" "__gt__" "__hash__" "__init__"
"__init_subclass__" "__le__" "__lt__" "__ne__" "__new__" "__radd__" "__reduce__"
"__reduce_ex__" "__repr__" "__rsub__" "__setattr__" "__sizeof__" "__str__" "__sub__"
"__subclasshook__" "astimezone" "combine" "ctime" "date" "day" "dst" "fold"
"fromisocalendar" "fromisoformat" "fromordinal" "fromtimestamp" "hour" "isocalendar"
"isoformat" "isoweekday" "max" "microsecond" "min" "minute" "month" "now" "replace"
"resolution" "second" "strftime" "strptime" "time" "timestamp" "timetuple" "timetz"
"today" "toordinal" "tzinfo" "tzname" "utcfromtimestamp" "utcnow" "utcof
</pre>

<p>Přístup k&nbsp;atributu objektu se provádí možná poněkud neobvykle
s&nbsp;využitím lomítka (převzato z&nbsp;Clojure):</p>

<pre>
basilisp.user=&gt; <strong>now/year</strong>
2025
</pre>

<p>Pro volání metody se používá speciální forma zapisovaná tečkou, což je opět
neobvyklé:</p>

<pre>
basilisp.user=&gt; <strong>(. now __str__)</strong>
"2025-11-11 16:19:00.366118"
</pre>

<p>Metodu je ovšem možné volat i jako běžnou (pseudo)funkci s&nbsp;tečkou na
začátku. Prvním parametrem je instance třídy:</p>

<pre>
basilisp.user=&gt; <strong>(.__str__ now)</strong>
"2025-11-11 16:19:00.366118"
</pre>

<p>Ukázka volání metody, která akceptuje další parametry:</p>

<pre>
basilisp.user=&gt; <strong>(. now strftime "%Y-%m-%d")</strong>
"2025-11-11"
</pre>

<p>Alternativní způsob zápisu:</p>

<pre>
basilisp.user=&gt; <strong>(.strftime now "%Y-%m-%d")</strong>
"2025-11-11"
</pre>

<p>Ještě si musíme ukázat, jak se volají standardní funkce Pythonu, které se
jmenují stejně, jako funkce v&nbsp;Basilispu. Příkladem je funkce
<strong>str</strong>:</p>

<pre>
basilisp.user=&gt; <strong>(str 42)</strong>
"42"
</pre>

<p>Původní Pythonovskou funkci <strong>str</strong> musíme uvést i se jmenným
prostorem:</p>

<pre>
basilisp.user=&gt; <strong>(python/str 42)</strong>
"42"
</pre>

<p>Složitější příklad, kde se kombinují standardní funkce Pythonu i standardní
funkce Basilispu:</p>

<pre>
basilisp.user=&gt; <strong>(python/str (abs (int "-42")))</strong>
"42"
</pre>

<p>Mimochodem: je zde možné s&nbsp;výhodou použít <i>threading macro</i> (možná
se jedná o jeden z&nbsp;nejlepších způsobů, jak se zbavovat závorek ve
zdrojových kódech :-):</p>

<pre>
basilisp.user=&gt; <strong>(-> "-42" int abs python/str)</strong>
"42"
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Využití balíčků Pythonu přímo z&nbsp;Basilispu</h2>

<p>Z&nbsp;Basilispu je možné volat i funkce z&nbsp;naimportovaných standardních
Pythonovských balíčků, popř.&nbsp;přistupovat k&nbsp;proměnným, které jsou
v&nbsp;těchto balíčcích definovány.</p>

<p>Balíček je nejdříve nutné naimportovat, a to například následujícím
způsobem:</p>

<pre>
basilisp.user=&gt; <strong>(import json)</strong>
nil
</pre>

<p>Poté je možné volat funkce, které jsou v&nbsp;tomto balíčku definovány, a to
s&nbsp;využitím konvence <strong>(jmenný_prostor/jméno_funkce)</strong>:</p>

<pre>
basilisp.user=&gt; <strong>(json/dumps (dict {"foo" 1 "bar" 2}))</strong>
"{\"foo\": 1, \"bar\": 2}"
</pre>

<p>Naimportujeme ještě jeden balíček, nyní <strong>math</strong>:</p>

<pre>
basilisp.user=&gt; <strong>(import math)</strong>
nil
</pre>

<p>Přečtení hodnoty proměnné definované v&nbsp;balíčku (bez závorek, protože
nechceme volat funkci):</p>

<pre>
basilisp.user=&gt; <strong>math/pi</strong>
3.141592653589793
</pre>

<p>Zavolání funkce z&nbsp;tohoto balíčku:</p>

<pre>
basilisp.user=&gt; <strong>(math/sqrt 2)</strong>
1.4142135623730951
</pre>

<p>Alternativně je možné definovat jmenný alias, podobně jako je tomu i
v&nbsp;samotném Pythonu:</p>

<pre>
basilisp.user=&gt; <strong>(import [math :as m])</strong>
nil
</pre>

<p>Přístup k&nbsp;funkci přes jmenný alias:</p>

<pre>
basilisp.user=&gt; <strong>(m/sqrt 2)</strong>
1.4142135623730951
</pre>

<p>Funkce a proměnné (resp.&nbsp;přesněji řečeno symboly) můžeme zařadit přímo
do aktuálního jmenného prostoru:</p>

<pre>
basilisp.user=&gt; <strong>(import [math :refer [pi sqrt]])</strong>
nil
</pre>

<p>Poté se již neuvádí jmenný prostor:</p>

<pre>
basilisp.user=&gt; <strong>pi</strong>
3.141592653589793
</pre>

<p>Nebo:</p>

<pre>
basilisp.user=&gt; <strong>(sqrt 2)</strong>
1.4142135623730951
</pre>

<p><div class="rs-tip-major">Poznámka: naprosto stejně se přistupuje
k&nbsp;importovaným třídám. Jejich instance se konstruují pomocí <strong>(new
název_třídy parametry_konstruktoru)</strong>.</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Předchozí části seriálu o LISPovských programovacích jazycích</h2>

<p>V&nbsp;této kapitole jsou uvedeny odkazy na všechny předchozí části seriálu
o světě programovacích jazyků LISP a Scheme (kromě samostatného seriálu, který
se věnoval programovacímu jazyku Clojure, odkazy na tento seriál jsou uvedeny
na konci kapitoly):</p>

<ol>

<li>Jemný úvod do rozsáhlého světa jazyků LISP a Scheme<br />
<a href="https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/">https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/</a>
</li>

<li>PicoLisp: minimalistický a přitom překvapivě výkonný interpret Lispu<br />
<a href="https://www.root.cz/clanky/picolisp-minimalisticky-a-pritom-prekvapive-vykonny-interpret-lispu/">https://www.root.cz/clanky/picolisp-minimalisticky-a-pritom-prekvapive-vykonny-interpret-lispu/</a>
</li>

<li>PicoLisp: užitečné funkce a speciální formy používané při tvorbě aplikací<br />
<a href="https://www.root.cz/clanky/picolisp-uzitecne-funkce-a-specialni-formy-pouzivane-pri-tvorbe-aplikaci/">https://www.root.cz/clanky/picolisp-uzitecne-funkce-a-specialni-formy-pouzivane-pri-tvorbe-aplikaci/</a>
</li>

<li>PicoLisp: dokončení popisu a několik praktických rad na závěr<br />
<a href="https://www.root.cz/clanky/picolisp-dokonceni-popisu-a-nekolik-praktickych-rad-na-zaver/">https://www.root.cz/clanky/picolisp-dokonceni-popisu-a-nekolik-praktickych-rad-na-zaver/</a>
</li>

<li>GNU Guile &ndash; interpret Scheme vestavitelný do nativních aplikací<br />
<a href="https://www.root.cz/clanky/gnu-guile-interpret-scheme-vestavitelny-do-nativnich-aplikaci/">https://www.root.cz/clanky/gnu-guile-interpret-scheme-vestavitelny-do-nativnich-aplikaci/</a>
</li>

<li>TinyScheme aneb další interpret jazyka Scheme vestavitelný do dalších aplikací<br />
<a href="https://www.root.cz/clanky/tinyscheme-aneb-dalsi-interpret-jazyka-scheme-vestavitelny-do-dalsich-aplikaci/">https://www.root.cz/clanky/tinyscheme-aneb-dalsi-interpret-jazyka-scheme-vestavitelny-do-dalsich-aplikaci/</a>
</li>

<li>Kawa: překvapivě silný a výkonný dialekt Scheme pro JVM<br />
<a href="https://www.root.cz/clanky/kawa-prekvapive-silny-a-vykonny-dialekt-scheme-pro-jvm/">https://www.root.cz/clanky/kawa-prekvapive-silny-a-vykonny-dialekt-scheme-pro-jvm/</a>
</li>

<li>Jazyk Kawa v&nbsp;ekosystému virtuálního stroje Javy<br />
<a href="https://www.root.cz/clanky/jazyk-kawa-v-ekosystemu-virtualniho-stroje-javy/">https://www.root.cz/clanky/jazyk-kawa-v-ekosystemu-virtualniho-stroje-javy/</a>
</li>

<li>Zpracování vektorů, matic a N-rozměrných polí v&nbsp;programovacím jazyku Kawa<br />
<a href="https://www.root.cz/clanky/zpracovani-vektoru-matic-a-n-rozmernych-poli-v-programovacim-jazyku-kawa/">https://www.root.cz/clanky/zpracovani-vektoru-matic-a-n-rozmernych-poli-v-programovacim-jazyku-kawa/</a>
</li>

<li>Racket: programovací jazyk a současně i platforma pro vývoj nových jazyků<br />
<a href="https://www.root.cz/clanky/racket-programovaci-jazyk-a-soucasne-i-platforma-pro-vyvoj-novych-jazyku/">https://www.root.cz/clanky/racket-programovaci-jazyk-a-soucasne-i-platforma-pro-vyvoj-novych-jazyku/</a>
</li>

<li>Makra v&nbsp;Racketu i v&nbsp;dalších lispovských jazycích<br />
<a href="https://www.root.cz/clanky/makra-v-racketu-i-v-dalsich-lispovskych-jazycich/">https://www.root.cz/clanky/makra-v-racketu-i-v-dalsich-lispovskych-jazycich/</a>
</li>

<li>Základní knihovna jazyka Racket<br />
<a href="https://www.root.cz/clanky/zakladni-knihovna-jazyka-racket/">https://www.root.cz/clanky/zakladni-knihovna-jazyka-racket/</a>
</li>

<li>Jazyk Joker: dialekt Clojure naprogramovaný v&nbsp;Go<br />
<a href="https://www.root.cz/clanky/jazyk-joker-dialekt-clojure-naprogramovany-v-go/">https://www.root.cz/clanky/jazyk-joker-dialekt-clojure-naprogramovany-v-go/</a>
</li>

<li>Chicken Scheme – další interpret a především překladač programovacího jazyka Scheme<br />
<a href="https://www.root.cz/clanky/chicken-scheme-dalsi-interpret-a-predevsim-prekladac-programovaciho-jazyka-scheme/">https://www.root.cz/clanky/chicken-scheme-dalsi-interpret-a-predevsim-prekladac-programovaciho-jazyka-scheme/</a>
</li>

<li>Projekt Gambit – další kvalitní interpret i překladač programovacího jazyka Scheme<br />
<a href="https://www.root.cz/clanky/projekt-gambit-dalsi-kvalitni-interpret-i-prekladac-programovaciho-jazyka-scheme/">https://www.root.cz/clanky/projekt-gambit-dalsi-kvalitni-interpret-i-prekladac-programovaciho-jazyka-scheme/</a>
</li>

<li>Interlisp aneb oživujeme dinosaura<br />
<a href="https://www.root.cz/clanky/interlisp-aneb-ozivujeme-dinosaura/">https://www.root.cz/clanky/interlisp-aneb-ozivujeme-dinosaura/</a>
</li>

<li>Propojení světa LISPu se světem JavaScriptu s&nbsp;využitím transpřekladače Wisp<br />
<a href="https://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp/">https://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp/</a>
</li>

<li>Propojení světa LISPu se světem JavaScriptu s&nbsp;využitím transpřekladače Wisp (2.část)<br />
<a href="https://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp-2-cast/">https://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp-2-cast/</a>
</li>

<li>Common Lisp: žralok mezi programovacími jazyky<br />
<a href="https://www.root.cz/clanky/common-lisp-zralok-mezi-programovacimi-jazyky/">https://www.root.cz/clanky/common-lisp-zralok-mezi-programovacimi-jazyky/</a>
</li>

<li>Common Lisp: žralok mezi programovacími jazyky (2.část)<br />
<a href="https://www.root.cz/clanky/common-lisp-zralok-mezi-programovacimi-jazyky-2-cast/">https://www.root.cz/clanky/common-lisp-zralok-mezi-programovacimi-jazyky-2-cast/</a>
</li>

<li>Jazyky Hy a Clojure-py: moderní dialekty LISPu určené pro Python VM<br />
<a href="https://www.root.cz/clanky/jazyky-hy-a-clojure-py-moderni-dialekty-lispu-urcene-pro-python-vm/">https://www.root.cz/clanky/jazyky-hy-a-clojure-py-moderni-dialekty-lispu-urcene-pro-python-vm/</a>
</li>

</ol>

<p>Články o Elispu:</p>

<ol>

<li>Úpravy Emacsu a tvorba nových modulů s&nbsp;využitím Emacs Lispu<br />
<a href="https://www.root.cz/clanky/upravy-emacsu-a-tvorba-novych-modulu-s-vyuzitim-emacs-lispu/">https://www.root.cz/clanky/upravy-emacsu-a-tvorba-novych-modulu-s-vyuzitim-emacs-lispu/</a>
</li>

<li>Úpravy Emacsu s&nbsp;Emacs Lisp: základní konstrukce jazyka<br />
<a href="https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-zakladni-konstrukce-jazyka/">https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-zakladni-konstrukce-jazyka/</a>
</li>

<li>Úpravy Emacsu s&nbsp;Emacs Lisp: všemocné makro cl-loop a knihovna dash<br />
<a href="https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-vsemocne-makro-cl-loop-a-knihovna-dash/">https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-vsemocne-makro-cl-loop-a-knihovna-dash/</a>
</li>

<li>Úpravy Emacsu s&nbsp;Emacs Lisp: možnosti nabízené knihovnou Dash<br />
<a href="https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-moznosti-nabizene-knihovnou-dash/">https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-moznosti-nabizene-knihovnou-dash/</a>
</li>

<li>Úpravy Emacsu s&nbsp;Emacs Lisp: dokončení popisu Emacs Lispu<br />
<a href="https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-dokonceni-popisu-emacs-lispu/">https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-dokonceni-popisu-emacs-lispu/</a>
</li>

<li>Úpravy Emacsu s&nbsp;Emacs Lisp: manipulace se základními datovými strukturami Emacsu<br />
<a href="https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-manipulace-se-zakladnimi-datovymi-strukturami-emacsu/">https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-manipulace-se-zakladnimi-datovymi-strukturami-emacsu/</a>
</li>

</ol>

<p><div class="rs-tip-major">Poznámka: povšimněte si, jak je svět LISPovských
jazyků pestrý.</div></p>

<p>Seriál o programovacím jazyku Clojure:</p>

<ol>

<li>Clojure  1: Úvod<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/</a>
</li>

<li>Clojure  2: Symboly, kolekce atd.<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/</a>
</li>

<li>Clojure  3: Funkcionální programování<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/</a>
</li>

<li>Clojure  4: Kolekce, sekvence a lazy sekvence<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/</a>
</li>

<li>Clojure  5: Sekvence, lazy sekvence a paralelní programy<br />
<a href="http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/</a>
</li>

<li>Clojure  6: Podpora pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/</a>
</li>

<li>Clojure  7: Další funkce pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/</a>
</li>

<li>Clojure  8: Identity, stavy, neměnné hodnoty a reference<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/">http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/</a>
</li>

<li>Clojure  9: Validátory, pozorovatelé a kooperace s Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/">http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/</a>
</li>

<li>Clojure 10: Kooperace mezi Clojure a Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/</a>
</li>

<li>Clojure 11: Generátorová notace seznamu/list comprehension<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/">http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/</a>
</li>

<li>Clojure 12: Překlad programů z Clojure do bajtkódu JVM I:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/">http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/</a>
</li>

<li>Clojure 13: Překlad programů z Clojure do bajtkódu JVM II:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/</a>
</li>

<li>Clojure 14: Základy práce se systémem maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/</a>
</li>

<li>Clojure 15: Tvorba uživatelských maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/</a>
</li>

<li>Programovací jazyk Clojure &ndash; triky při práci s řetězci<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/</a>
</li>

<li>Programovací jazyk Clojure &ndash; triky při práci s kolekcemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/</a>
</li>

<li>Programovací jazyk Clojure &ndash; práce s mapami a množinami<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/">http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/</a>
</li>

<li>Programovací jazyk Clojure &ndash; základy zpracování XML<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/">http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/</a>
</li>

<li>Programovací jazyk Clojure &ndash; testování s využitím knihovny Expectations<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/">http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/</a>
</li>

<li>Programovací jazyk Clojure &ndash; některé užitečné triky použitelné (nejenom) v&nbsp;testech<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/">http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/</a>
</li>

<li>Enlive &ndash; výkonný šablonovací systém pro jazyk Clojure<br/>
<a href="http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/">http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/</a>
</li>

<li>Nástroj Leiningen a programovací jazyk Clojure: tvorba vlastních knihoven pro veřejný repositář Clojars<br />
<a href="http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/">http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/</a>
</li>

<li>Novinky v Clojure verze 1.8.0<br />
<a href="http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/">http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async (pokračování)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/</a>
</li>

<li>Asynchronní programování v Clojure s využitím knihovny core.async (dokončení)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/</a>
</li>

<li>Vytváříme IRC bota v programovacím jazyce Clojure<br />
<a href="http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/">http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/</a>
</li>

<li>Gorilla REPL: interaktivní prostředí pro programovací jazyk Clojure<br />
<a href="https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/">https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/</a>
</li>

<li>Multimetody v Clojure aneb polymorfismus bez použití OOP<br />
<a href="https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/">https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/</a>
</li>

<li>Práce s externími Java archivy v programovacím jazyku Clojure<br />
<a href="https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/">https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/</a>
</li>

<li>Clojure 16: Složitější uživatelská makra<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/</a>
</li>

<li>Clojure 17: Využití standardních maker v praxi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/</a>
</li>

<li>Clojure 18: Základní techniky optimalizace aplikací<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Clojure 19: Vývojová prostředí pro Clojure<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/">http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/</a>
</li>

<li>Clojure 20: Vývojová prostředí pro Clojure (Vimu s REPL)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/">http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/</a>
</li>

<li>Clojure 21: ClojureScript aneb překlad Clojure do JS<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (2)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (3)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (4)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (5)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (6)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/</a>
</li>

<li>Programovací jazyk Clojure a databáze (1.část)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/</a>
</li>

<li>Pluginy pro Leiningen<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s&nbsp;vektory a maticemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s&nbsp;vektory a maticemi (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s&nbsp;využitím knihovny Clisk<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s&nbsp;využitím knihovny Clisk (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v&nbsp;jazyce Clojure<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v &nbsp;azyce Clojure (2)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v&nbsp;jazyce Clojure (3)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/</a>
</li>

<li>Programovací jazyk Clojure a práce s&nbsp;Gitem<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/</a>
</li>

<li>Programovací jazyk Clojure a práce s&nbsp;Gitem (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s&nbsp;využitím knihovny Clisk (dokončení)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/</a>
</li>

<li>Pixie: lehký skriptovací jazyk s&nbsp;„kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

<li>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/">https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/</a>
</li>

<li>Novinky v&nbsp;Clojure verze 1.9.0<br />
<a href="https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/">https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/</a>
</li>

<li>Validace dat s&nbsp;využitím knihovny spec v&nbsp;Clojure 1.9.0<br />
<a href="https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/">https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v&nbsp;Clojure<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v&nbsp;Clojure (2)<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/</a>
</li>

<li>Incanter: prostředí pro statistické výpočty s grafickým výstupem založené na Clojure<br />
<a href="https://www.root.cz/clanky/incanter-prostredi-pro-statisticke-vypocty-s-grafickym-vystupem-zalozene-na-clojure/">https://www.root.cz/clanky/incanter-prostredi-pro-statisticke-vypocty-s-grafickym-vystupem-zalozene-na-clojure/</a>
</li>

<li>Incanter: operace s&nbsp;maticemi<br />
<a href="https://www.root.cz/clanky/incanter-operace-s-maticemi/">https://www.root.cz/clanky/incanter-operace-s-maticemi/</a>
</li>

<li>Interpret programovacího jazyka Clojure integrovaný do Jupyter Notebooku<br />
<a href="https://www.root.cz/clanky/interpret-programovaciho-jazyka-clojure-integrovany-do-jupyter-notebooku/">https://www.root.cz/clanky/interpret-programovaciho-jazyka-clojure-integrovany-do-jupyter-notebooku/</a>
</li>

<li>Babashka: interpret Clojure určený pro rychlé spouštění utilit z&nbsp;příkazového řádku<br />
<a href="https://www.root.cz/clanky/babashka-interpret-clojure-urceny-pro-rychle-spousteni-utilit-z-prikazoveho-radku/">https://www.root.cz/clanky/babashka-interpret-clojure-urceny-pro-rychle-spousteni-utilit-z-prikazoveho-radku/</a>
</li>

<li>Pokročilý streaming založený na Apache Kafce, jazyku Clojure a knihovně Jackdaw<br />
<a href="https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw/">https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw/</a>
</li>

<li>Pokročilý streaming založený na Apache Kafce, jazyku Clojure a knihovně Jackdaw (2. část)<br />
<a href="https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw-2-cast/">https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw-2-cast/</a>
</li>

<li>Pokročilý streaming založený na projektu Apache Kafka, jazyku Clojure a knihovně Jackdaw (streamy a kolony)<br />
<a href="https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-projektu-apache-kafka-jazyku-clojure-a-knihovne-jackdaw-streamy-a-kolony/">https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-projektu-apache-kafka-jazyku-clojure-a-knihovne-jackdaw-streamy-a-kolony/</a>
</li>

<li>Řídicí struktury využitelné v&nbsp;programovacím jazyku Clojure<br />
<a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure/">https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure/</a>
</li>

</ol>



<p><a name="k19"></a></p>
<h2 id="k19">19. Literatura</h2>

<p>O Common Lispu, Scheme či Clojure, tedy o třech (s&nbsp;velkou
pravděpodobností) nejpoužívanějších dialektech LISPu, vyšlo poměrně velké
množství literatury. Pro Common Lisp je typická jeho velká stabilita, a to
minimálně od roku 1994, což mj.&nbsp;znamená, že i původní vydaní prvních dvou
dále zmíněných knih je zcela bez problémů použitelné i dnes (a obě knihy jsou
navíc dobře čitelné):</p>

<ol>

<li>Peter Seibel<br />
<i>&bdquo;Practical Common Lisp&ldquo;</i><br />
2009
</li>

<li>Paul Graham<br />
<i>&bdquo;ANSI Common Lisp&ldquo;</i><br />
1995
</li>

<li>Gerald Gazdar<br />
<i>&bdquo;Natural Language Processing in Lisp: An Introduction to Computational Linguistics&ldquo;</i><br />
1989
</li>

<li>Peter Norvig<br />
<i>&bdquo;Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp&ldquo;</i><br />
1991
</li>

<li>Alex Mileler et.al.<br />
<i>&bdquo;Clojure Applied: From Practice to Practitioner&ldquo;</i><br />
2015
</li>

<li>
<i>&bdquo;Living Clojure: An Introduction and Training Plan for Developers&ldquo;</i><br />
2015
</li>

<li>Dmitri Sotnikov<br />
<i>&bdquo;Web Development with Clojure: Build Bulletproof Web Apps with Less Code&ldquo;</i><br />
2016
</li>

<li>McCarthy<br />
<i>&bdquo;Recursive functions of symbolic expressions and their computation by machine, part I&ldquo;</i><br />
1960
</li>

<li>R. Kent Dybvig<br />
<i>&bdquo;The Scheme Programming Language&ldquo;</i><br />
2009
</li>

<li>Max Hailperin, Barbara Kaiser, Karl Knight<br />
<i>&bdquo;Concrete Abstractions&ldquo;</i><br />
1998
</li>

<li>Guy L. Steele<br />
<i>&bdquo;History of Scheme&ldquo;</i><br />
2006, Sun Microsystems Laboratories
</li>

<li>Kolář J., Muller K.:<br />
<i>&bdquo;Speciální programovací jazyky&ldquo;</i><br />
Praha 1981
</li>

<li>
<i>&bdquo;AutoLISP Release 9, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., October 1987
</li>

<li>
<i>&bdquo;AutoLISP Release 10, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., September 1988
</li>

<li>McCarthy, John; Abrahams, Paul W.; Edwards, Daniel J.; Hart, Timothy P.; Levin, Michael I.<br />
<i>&bdquo;LISP 1.5 Programmer's Manual&ldquo;</i><br />
MIT Press. ISBN 0 262 130 1 1 4
</li>

<li>Carl Hewitt; Peter Bishop and Richard Steiger<br />
<i>&bdquo;A Universal Modular Actor Formalism for Artificial Intelligence&ldquo;</i><br />
1973
</li>

<li>Feiman, J.<br />
<i>&bdquo;The Gartner Programming Language Survey (October 2001)&ldquo;</i><br />
Gartner Advisory
</li>

<li>Harold Abelson, Gerald Jay Sussman, Julie Sussman:<br />
<i>Structure and Interpretation of Computer Programs</i><br />
MIT Press. 1985, 1996 (a možná vyšel i další přetisk)
</li>

<li>Paul Graham<br />
<i>On Lisp</i><br />
Prentice Hall, 1993<br />
Dostupné online na adrese <a href="http://www.paulgraham.com/onlisptext.html">http://www.paulgraham.com/onlisptext.html</a>
</li>

<li>David S. Touretzky<br />
<i>Common LISP: A Gentle Introduction to Symbolic Computation (Dover Books on Engineering)</i><br />
</li>

<li>Peter Norvig<br />
<i>Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp</i>
</li>

<li>Patrick Winston, Berthold Horn<br />
<i>Lisp (3rd Edition)</i><br />
ISBN-13: 978-0201083194, ISBN-10: 0201083191
</li>

<li>Matthias Felleisen, David Van Horn, Dr. Conrad Barski<br>
<i>Realm of Racket: Learn to Program, One Game at a Time!</i><br />
ISBN-13: 978-1593274917, ISBN-10: 1593274912 
</li>

<li>Graham Hutton<br />
<i>A tutorial on the universality andexpressiveness of fold</i><br />
http://www.cs.nott.ac.uk/~pszgmh/fold.pdf
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Hy 1.0.0: dialekt Lispu integrovaný do Pythonu<br />
<a href="https://www.root.cz/zpravicky/hy-1-0-0-dialekt-lispu-integrovany-do-pythonu/">https://www.root.cz/zpravicky/hy-1-0-0-dialekt-lispu-integrovany-do-pythonu/</a>
</li>

<li>Janet Language<br />
<a href="https://janet-lang.org/">https://janet-lang.org/</a>
</li>

<li>Janet na GitHubu<br />
<a href="https://github.com/janet-lang/janet">https://github.com/janet-lang/janet</a>
</li>

<li>Janet for Mortals (a real book)<br />
<a href="https://janet.guide/">https://janet.guide/</a>
</li>

<li>Bauble studio<br />
<a href="https://bauble.studio/">https://bauble.studio/</a>
</li>

<li>Janet na Hacker News<br />
<a href="https://news.ycombinator.com/item?id=34843306">https://news.ycombinator.com/item?id=34843306</a>
</li>

<li>Common Lisp<br />
<a href="https://lisp-lang.org/">https://lisp-lang.org/</a>
</li>

<li>Why You Should Learn Lisp In 2022?<br />
<a href="https://www.youtube.com/watch?v=GWdf1flcLoM">https://www.youtube.com/watch?v=GWdf1flcLoM</a>
</li>

<li>LOOP Common Lisps Superior For<br />
<a href="https://www.youtube.com/watch?v=i4tmF_1nZng">https://www.youtube.com/watch?v=i4tmF_1nZng</a>
</li>

<li>Lisp VS C benchmarks<br />
<a href="https://programming-language-benchmarks.vercel.app/lisp-vs-c">https://programming-language-benchmarks.vercel.app/lisp-vs-c</a>
</li>

<li>Common Lisp: An elegant design pattern<br />
<a href="https://www.youtube.com/watch?v=9597LFlvMuE">https://www.youtube.com/watch?v=9597LFlvMuE</a>
</li>

<li>Common Lisp Macros By Example Tutorial<br />
<a href="https://lisp-journey.gitlab.io/blog/common-lisp-macros-by-example-tutorial/">https://lisp-journey.gitlab.io/blog/common-lisp-macros-by-example-tutorial/</a>
</li>

<li>The Common Lisp Cookbook<br />
<a href="https://lispcookbook.github.io/cl-cookbook/">https://lispcookbook.github.io/cl-cookbook/</a>
</li>

<li>The Evolution of Lisp<br />
<a href="https://www.csee.umbc.edu/courses/331/resources/papers/Evolution-of-Lisp.pdf">https://www.csee.umbc.edu/courses/331/resources/papers/Evolution-of-Lisp.pdf</a>
</li>

<li>Awesome CL<br />
<a href="https://github.com/CodyReichert/awesome-cl">https://github.com/CodyReichert/awesome-cl</a>
</li>

<li>LISP<br />
<a href="https://taoofmac.com/space/dev/lisp">https://taoofmac.com/space/dev/lisp</a>
</li>

<li>Repositář projektu femtolisp<br />
<a href="https://github.com/JeffBezanson/femtolisp">https://github.com/JeffBezanson/femtolisp</a>
</li>

<li>Femtolisp - lightweight, robust lisp interpreter built on reusable C libraries<br />
<a href="https://www.findbestopensource.com/product/femtolisp">https://www.findbestopensource.com/product/femtolisp</a>
</li>

<li>YCombinator: Femtolisp: A lightweight, robust, scheme-like Lisp implementation<br />
<a href="https://news.ycombinator.com/item?id=22094722">https://news.ycombinator.com/item?id=22094722</a>
</li>

<li>Learning Julia by Anshul Joshi, Rahul Lakhanpal: Femtolisp<br />
<a href="https://www.oreilly.com/library/view/learning-julia/9781785883279/2e85442f-d100-4b53-b8f7-7d20d62f0255.xhtml">https://www.oreilly.com/library/view/learning-julia/9781785883279/2e85442f-d100-4b53-b8f7-7d20d62f0255.xhtml</a>
</li>

<li>The role of femtolisp in Julia?<br />
<a href="https://discourse.julialang.org/t/the-role-of-femtolisp-in-julia/1902">https://discourse.julialang.org/t/the-role-of-femtolisp-in-julia/1902</a>
</li>

<li>LispSyntax.jl: A clojure-like lisp syntax for julia<br />
<a href="https://github.com/swadey/LispSyntax.jl">https://github.com/swadey/LispSyntax.jl</a>
</li>

<li>What exactly code lowering is an how to do “unlowering”?<br />
<a href="https://discourse.julialang.org/t/what-exactly-code-lowering-is-an-how-to-do-unlowering/1315">https://discourse.julialang.org/t/what-exactly-code-lowering-is-an-how-to-do-unlowering/1315</a>
</li>

<li>Interlisp.org: Dedicated to Restoring and Preserving the Interlisp experience<br />
<a href="https://github.com/Interlisp">https://github.com/Interlisp</a>
</li>

<li>Warren Teitelman<br />
<a href="https://en.wikipedia.org/wiki/Warren_Teitelman">https://en.wikipedia.org/wiki/Warren_Teitelman</a>
</li>

<li>InterLISP/65<br />
<a href="http://www.atarimania.com/utility-atari-400-800-xl-xe-interlisp-65_12477.html">http://www.atarimania.com/utility-atari-400-800-xl-xe-interlisp-65_12477.html</a>
</li>

<li>Lisp Editing in the 80s - Interlisp SEdit (Video)<br />
<a href="https://www.youtube.com/watch?v=2qsmF8HHskg">https://www.youtube.com/watch?v=2qsmF8HHskg</a>
</li>

<li>Inter-LISP<br />
<a href="http://www.atarimania.com/utility-atari-400-800-xl-xe-inter-lisp_29354.html">http://www.atarimania.com/utility-atari-400-800-xl-xe-inter-lisp_29354.html</a>
</li>

<li>InterLISP 65 Editing (video)<br />
<a href="https://www.youtube.com/watch?v=nY_hcazo86A">https://www.youtube.com/watch?v=nY_hcazo86A</a>
</li>

<li>Datasoft INTER-LISP/65 (Atari Age, chat)<br />
<a href="https://atariage.com/forums/topic/116093-datasoft-inter-lisp65/">https://atariage.com/forums/topic/116093-datasoft-inter-lisp65/</a>
</li>

<li>Marvin Minsky - The beauty of the Lisp language (44/151)<br />
<a href="https://www.youtube.com/watch?v=YaWVHyIBVeI">https://www.youtube.com/watch?v=YaWVHyIBVeI</a>
</li>

<li>History of LISP (Interlisp)<br />
<a href="http://www.softwarepreservation.org/projects/LISP/index.html#INTERLISP_">http://www.softwarepreservation.org/projects/LISP/index.html#INTERLISP_</a>
</li>

<li>Computer-Assisted Instruction (Bits and Bytes, Episode 7)<br />
<a href="https://www.youtube.com/watch?v=eURtTV_qKw8">https://www.youtube.com/watch?v=eURtTV_qKw8</a>
</li>

<li>Můžeme věřit překladačům? Projekty řešící schéma „důvěřivé důvěry“<br />
<a href="https://www.root.cz/clanky/muzeme-verit-prekladacum-projekty-resici-schema-duverive-duvery/">https://www.root.cz/clanky/muzeme-verit-prekladacum-projekty-resici-schema-duverive-duvery/</a>
</li>

<li>Gambit in the browser<br />
<a href="https://feeley.github.io/gambit-in-the-browser/">https://feeley.github.io/gambit-in-the-browser/</a>
</li>

<li>A Tour of Scheme in Gambit<br />
<a href="http://dynamo.iro.umontreal.ca/wiki/images/a/a7/A_Tour_of_Scheme_in_Gambit.pdf">http://dynamo.iro.umontreal.ca/wiki/images/a/a7/A_Tour_of_Scheme_in_Gambit.pdf</a>
</li>

<li>Gambit Scheme: Inside Out<br />
<a href="http://www.iro.umontreal.ca/~gambit/Gambit-inside-out.pdf">http://www.iro.umontreal.ca/~gambit/Gambit-inside-out.pdf</a>
</li>

<li>Gambit Internal Documentation<br />
<a href="http://dynamo.iro.umontreal.ca/wiki/index.php/Internal_Documentation">http://dynamo.iro.umontreal.ca/wiki/index.php/Internal_Documentation</a>
</li>

<li>clojure-scheme: Compiling to Native Code via Scheme <br />
<a href="http://www.iro.umontreal.ca/~gambit/Sorenson-Clojure-to-Native-via-Scheme.pdf">http://www.iro.umontreal.ca/~gambit/Sorenson-Clojure-to-Native-via-Scheme.pdf</a>
</li>

<li>Gauche &ndash; a Scheme implementation<br />
<a href="http://practical-scheme.net/gauche/">http://practical-scheme.net/gauche/</a>
</li>

<li>Scheme48<br />
<a href="https://s48.org/">https://s48.org/</a>
</li>

<li>SISC (Second Interpreter of Scheme)<br />
<a href="http://sisc-scheme.org/">http://sisc-scheme.org/</a>
</li>

<li>The SCM Implementation of Scheme<br />
<a href="https://people.csail.mit.edu/jaffer/SCM.html">https://people.csail.mit.edu/jaffer/SCM.html</a>
</li>

<li>Ypsilon - The ultimate script language system for the video pinball fourth generation<br />
<a href="http://www.littlewingpinball.com/doc/en/ypsilon/index.html">http://www.littlewingpinball.com/doc/en/ypsilon/index.html</a>
</li>

<li>Chicken Scheme<br />
<a href="https://call-cc.org/">https://call-cc.org/</a>
</li>

<li>Eggs Unlimited<br />
<a href="http://wiki.call-cc.org/chicken-projects/egg-index-5.html">http://wiki.call-cc.org/chicken-projects/egg-index-5.html</a>
</li>

<li>Chicken Scheme Wiki<br />
<a href="https://wiki.call-cc.org/">https://wiki.call-cc.org/</a>
</li>

<li>CHICKEN for Python programmers<br />
<a href="https://wiki.call-cc.org/chicken-for-python-programmers">https://wiki.call-cc.org/chicken-for-python-programmers</a>
</li>

<li>Programming for Performance<br />
<a href="http://wiki.call-cc.org/programming-for-performance">http://wiki.call-cc.org/programming-for-performance</a>
</li>

<li>Using the compiler<br />
<a href="https://wiki.call-cc.org/man/4/Using%20the%20compiler">https://wiki.call-cc.org/man/4/Using%20the%20compiler</a>
</li>

<li>CHICKEN Scheme tutorials<br />
<a href="https://wiki.call-cc.org/tutorials">https://wiki.call-cc.org/tutorials</a>
</li>

<li>Racket: programovací jazyk a současně i platforma pro vývoj nových jazyků<br />
<a href="https://www.root.cz/clanky/racket-programovaci-jazyk-a-soucasne-i-platforma-pro-vyvoj-novych-jazyku/">https://www.root.cz/clanky/racket-programovaci-jazyk-a-soucasne-i-platforma-pro-vyvoj-novych-jazyku/</a>
</li>

<li>Makra v Racketu i v dalších lispovských jazycích<br />
<a href="https://www.root.cz/clanky/makra-v-racketu-i-v-dalsich-lispovskych-jazycich/">https://www.root.cz/clanky/makra-v-racketu-i-v-dalsich-lispovskych-jazycich/</a>
</li>

<li>Základní knihovna jazyka Racket<br />
<a href="https://www.root.cz/clanky/zakladni-knihovna-jazyka-racket/">https://www.root.cz/clanky/zakladni-knihovna-jazyka-racket/</a>
</li>

<li>Grafický metaformát PostScript<br />
<a href="https://www.root.cz/clanky/graficky-metaformat-postscript/">https://www.root.cz/clanky/graficky-metaformat-postscript/</a>
</li>

<li>Vektorový grafický formát SVG<br />
<a href="https://www.root.cz/clanky/vektorovy-graficky-format-svg/">https://www.root.cz/clanky/vektorovy-graficky-format-svg/</a>
</li>

<li>The Racket Drawing Toolkit<br />
<a href="https://docs.racket-lang.org/draw/index.html">https://docs.racket-lang.org/draw/index.html</a>
</li>

<li>Traditional Turtles<br />
<a href="https://docs.racket-lang.org/turtles/Traditional_Turtles.html">https://docs.racket-lang.org/turtles/Traditional_Turtles.html</a>
</li>

<li>[racket] How best to repeat a function call n times?<br />
<a href="https://lists.racket-lang.org/users/archive/2014-September/064203.html">https://lists.racket-lang.org/users/archive/2014-September/064203.html</a>
</li>

<li>Racket: Macros<br />
<a href="https://www.it.uu.se/edu/course/homepage/avfunpro/ht13/lectures/Racket-3-Macros.pdf">https://www.it.uu.se/edu/course/homepage/avfunpro/ht13/lectures/Racket-3-Macros.pdf</a>
</li>

<li>Beautiful Racket / explainers: Macros<br />
<a href="https://beautifulracket.com/explainer/macros.html">https://beautifulracket.com/explainer/macros.html</a>
</li>

<li>Macros (dokumentace k Racketu)<br />
<a href="https://docs.racket-lang.org/guide/macros.html">https://docs.racket-lang.org/guide/macros.html</a>
</li>

<li>Model syntaxe jazyka Racket<br />
<a href="https://docs.racket-lang.org/reference/syntax-model.html">https://docs.racket-lang.org/reference/syntax-model.html</a>
</li>

<li>Syntax Objects<br />
<a href="https://docs.racket-lang.org/guide/stx-obj.html">https://docs.racket-lang.org/guide/stx-obj.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Beautiful Racket: an intro­duction to language-oriented programming using Racket<br />
<a href="https://beautifulracket.com/">https://beautifulracket.com/</a>
</li>

<li>Stránky projektu Racket<br />
<a href="https://racket-lang.org/">https://racket-lang.org/</a>
</li>

<li>Dokumentace k&nbsp;projektu Racket<br />
<a href="https://docs.racket-lang.org/index.html">https://docs.racket-lang.org/index.html</a>
</li>

<li>Seznam dostupných balíčků pro Racket<br />
<a href="https://pkgs.racket-lang.org/">https://pkgs.racket-lang.org/</a>
</li>

<li>Racket na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Racket_(programming_language)">https://en.wikipedia.org/wiki/Racket_(programming_language)</a>
</li>

<li>Vector Library (R7RS-compatible)<br />
<a href="https://srfi.schemers.org/srfi-133/srfi-133.html">https://srfi.schemers.org/srfi-133/srfi-133.html</a>
</li>

<li>Blogy o Racketu a navazujících technologiích<br />
<a href="https://blog.racket-lang.org/">https://blog.racket-lang.org/</a>
</li>

<li>Prográmky psané v&nbsp;Racketu na RosettaCode<br />
<a href="http://rosettacode.org/wiki/Category:Racket">http://rosettacode.org/wiki/Category:Racket</a>
</li>

<li>Fear of Macros<br />
<a href="https://www.greghendershott.com/fear-of-macros/">https://www.greghendershott.com/fear-of-macros/</a>
</li>

<li>Rackjure<br />
<a href="https://github.com/greghendershott/rackjure">https://github.com/greghendershott/rackjure</a>
</li>

<li>Matthew Flatt’s proposal to change Racket’s s-expressions based syntax to infix representation creates a stir in the community<br />
<a href="https://hub.packtpub.com/matthew-flatts-proposal-to-change-rackets-s-expressions-based-syntax-to-infix-representation-creates-a-stir-in-the-community/">https://hub.packtpub.com/matthew-flatts-proposal-to-change-rackets-s-expressions-based-syntax-to-infix-representation-creates-a-stir-in-the-community/</a>
</li>

<li>Racket News<br />
<a href="https://racket-news.com/">https://racket-news.com/</a>
</li>

<li>Racket: Lisp for learning<br />
<a href="https://lwn.net/Articles/795385/">https://lwn.net/Articles/795385/</a>
</li>

<li>Future of Racket<br />
<a href="https://www.greghendershott.com/2019/07/future-of-racket.html">https://www.greghendershott.com/2019/07/future-of-racket.html</a>
</li>

<li>Vectors (pro Gauche)<br />
<a href="https://practical-scheme.net/gauche/man/gauche-refe/Vectors.html">https://practical-scheme.net/gauche/man/gauche-refe/Vectors.html</a>
</li>

<li>Kawa: Compiling Scheme to Java<br />
<a href="https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html">https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html</a>
</li>

<li>Kawa in Languages shootout<br />
<a href="http://per.bothner.com/blog/2010/Kawa-in-shootout/">http://per.bothner.com/blog/2010/Kawa-in-shootout/</a>
</li>

<li>Kawa 2.0 Supports Scheme R7RS<br />
<a href="https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/">https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/</a>
</li>

<li>Kawa — fast scripting on the Java platform<br />
<a href="https://lwn.net/Articles/623349/">https://lwn.net/Articles/623349/</a>
</li>

<li>Tail call (a její optimalizace)<br />
<a href="https://en.wikipedia.org/wiki/Tail_call">https://en.wikipedia.org/wiki/Tail_call</a>
</li>

<li>SLIME (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/SLIME">http://en.wikipedia.org/wiki/SLIME</a>
</li>

<li>slime.vim<br />
<a href="http://s3.amazonaws.com/mps/slime.vim">http://s3.amazonaws.com/mps/slime.vim</a>
</li>

<li>What are the best scheme implementations?<br />
<a href="https://www.slant.co/topics/5282/~scheme-implementations">https://www.slant.co/topics/5282/~scheme-implementations</a>
</li>

<li>Bigloo homepage<br />
<a href="http://www-sop.inria.fr/mimosa/fp/Bigloo/">http://www-sop.inria.fr/mimosa/fp/Bigloo/</a>
</li>

<li>FTP s tarbally Bigloo<br />
<a href="ftp://ftp-sop.inria.fr/indes/fp/Bigloo">ftp://ftp-sop.inria.fr/indes/fp/Bigloo</a>
</li>

<li>GOTO 2018 • Functional Programming in 40 Minutes • Russ Olsen<br />
<a href="https://www.youtube.com/watch?v=0if71HOyVjY">https://www.youtube.com/watch?v=0if71HOyVjY</a>
</li>

<li>TinyScheme (stránka na Sourceforge)<br />
<a href="http://tinyscheme.sourceforge.net/home.html">http://tinyscheme.sourceforge.net/home.html</a>
</li>

<li>Embedding Tiny Scheme in a Game<br />
<a href="http://www.silicondelight.com/embedding-tiny-scheme-in-a-game/">http://www.silicondelight.com/embedding-tiny-scheme-in-a-game/</a>
</li>

<li>Embedding Scheme for a game mission scripting DSL<br />
<a href="http://carloscarrasco.com/embedding-scheme-for-a-game-mission-scripting-dsl.html">http://carloscarrasco.com/embedding-scheme-for-a-game-mission-scripting-dsl.html</a>
</li>

<li>Všechny verze TinyScheme na SourceForge<br />
<a href="https://sourceforge.net/projects/tinyscheme/files/tinyscheme/">https://sourceforge.net/projects/tinyscheme/files/tinyscheme/</a>
</li>

<li>Fork TinyScheme na GitHubu<br />
<a href="https://github.com/yawnt/tinyscheme">https://github.com/yawnt/tinyscheme</a>
</li>

<li>Ackermannova funkce<br />
<a href="https://cs.wikipedia.org/wiki/Ackermannova_funkce">https://cs.wikipedia.org/wiki/Ackermannova_funkce</a>
</li>

<li>Ackermann function na Rosetta Code<br />
<a href="https://rosettacode.org/wiki/Ackermann_function#Scheme">https://rosettacode.org/wiki/Ackermann_function#Scheme</a>
</li>

<li>Success Stories (lisp.org)<br />
<a href="https://lisp-lang.org/success/">https://lisp-lang.org/success/</a>
</li>

<li>Allegro Common Lisp Success Stories<br />
<a href="https://franz.com/success/">https://franz.com/success/</a>
</li>

<li>Clojure Success Stories<br />
<a href="https://clojure.org/community/success_stories">https://clojure.org/community/success_stories</a>
</li>

<li>Scheme Quick Reference<br />
<a href="https://www.st.cs.uni-saarland.de/edu/config-ss04/scheme-quickref.pdf">https://www.st.cs.uni-saarland.de/edu/config-ss04/scheme-quickref.pdf</a>
</li>

<li>Slajdy o Scheme (od slajdu číslo 15)<br />
<a href="https://docs.google.com/presentation/d/1abmDnKjrq1tcjGvvRNAKhOiSTSE2lyagtcEPal07Gbo/edit">https://docs.google.com/presentation/d/1abmDnKjrq1tcjGvvRNAKhOiSTSE2lyagtcEPal07Gbo/edit</a>
</li>

<li>Scheme Cheat Sheet<br />
<a href="https://github.com/smythp/scheme-cheat-sheet">https://github.com/smythp/scheme-cheat-sheet</a>
</li>

<li>Embedding Lua, embedding Guile <br />
<a href="http://puntoblogspot.blogspot.com/2013/04/embedding-lua-embedding-guile.html">http://puntoblogspot.blogspot.com/2013/04/embedding-lua-embedding-guile.html</a>
</li>

<li>Lambda Papers<br />
<a href="https://en.wikisource.org/wiki/Lambda_Papers">https://en.wikisource.org/wiki/Lambda_Papers</a>
</li>

<li>Revised<sup>7</sup>Report on the Algorithmic Language Scheme<br />
<a href="https://small.r7rs.org/attachment/r7rs.pdf">https://small.r7rs.org/attachment/r7rs.pdf</a>
</li>

<li>Video Lectures (MIT, SICP 2005)<br />
<a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/</a>
</li>

<li>Why is Scheme my first language in university?<br />
<a href="https://softwareengineering.stackexchange.com/questions/115252/why-is-scheme-my-first-language-in-university">https://softwareengineering.stackexchange.com/questions/115252/why-is-scheme-my-first-language-in-university</a>
</li>

<li>The Perils of JavaSchools<br />
<a href="https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/">https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/</a>
</li>

<li>How to Design Programs, Second Edition<br />
<a href="https://htdp.org/2019-02-24/index.html">https://htdp.org/2019-02-24/index.html</a>
</li>

<li>LilyPond<br />
<a href="http://lilypond.org/">http://lilypond.org/</a>
</li>

<li>LilyPond — Extending (přes Scheme)<br />
<a href="http://lilypond.org/doc/v2.18/Documentation/extending/scheme-tutorial">http://lilypond.org/doc/v2.18/Documentation/extending/scheme-tutorial</a>
</li>

<li>Scheme in LilyPond<br />
<a href="http://lilypond.org/doc/v2.18/Documentation/extending/scheme-in-lilypond">http://lilypond.org/doc/v2.18/Documentation/extending/scheme-in-lilypond</a>
</li>

<li>GnuCash<br />
<a href="http://www.gnucash.org/">http://www.gnucash.org/</a>
</li>

<li>Custom Reports (in GNU Cash)<br />
<a href="https://wiki.gnucash.org/wiki/Custom_Reports">https://wiki.gnucash.org/wiki/Custom_Reports</a>
</li>

<li>Program by Design<br />
<a href="https://programbydesign.org/">https://programbydesign.org/</a>
</li>

<li>SchemePy<br />
<a href="https://pypi.org/project/SchemePy/">https://pypi.org/project/SchemePy/</a>
</li>

<li>LISP FQA: Section - [1-5] What is the "minimal" set of primitives needed for a Lisp interpreter?<br />
<a href="http://www.faqs.org/faqs/lisp-faq/part1/section-6.html">http://www.faqs.org/faqs/lisp-faq/part1/section-6.html</a>
</li>

<li>femtolisp<br />
<a href="https://github.com/JeffBezanson/femtolisp">https://github.com/JeffBezanson/femtolisp</a>
</li>

<li>(How to Write a (Lisp) Interpreter (in Python))<br />
<a href="http://norvig.com/lispy.html">http://norvig.com/lispy.html</a>
</li>

<li>Repositář s&nbsp;Guile Emacsem<br />
<a href="http://git.hcoop.net/?p=bpt/guile.git">http://git.hcoop.net/?p=bpt/guile.git</a>
</li>

<li>Interacting with Guile Compound Data Types in C<br />
<a href="http://www.lonelycactus.com/guilebook/x1555.html">http://www.lonelycactus.com/guilebook/x1555.html</a>
</li>

<li>Calling Guile functions from C<br />
<a href="http://www.lonelycactus.com/guilebook/c1204.html#SECCALLGUILEFUNC">http://www.lonelycactus.com/guilebook/c1204.html#SECCALLGUILEFUNC</a>
</li>

<li>Arrays, and other compound data types<br />
<a href="http://www.lonelycactus.com/guilebook/charrays.html">http://www.lonelycactus.com/guilebook/charrays.html</a>
</li>

<li>Interacting with Guile Compound Data Types in C<br />
<a href="http://www.lonelycactus.com/guilebook/x1555.html">http://www.lonelycactus.com/guilebook/x1555.html</a>
</li>

<li>Guile Reference Manual<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/index.html">https://www.gnu.org/software/guile/manual/html_node/index.html</a>
</li>

<li>Scheme: Summary of Common Syntax<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/Syntax-Summary.html#Syntax-Summary">https://www.gnu.org/software/guile/manual/html_node/Syntax-Summary.html#Syntax-Summary</a>
</li>

<li>Scripting with Guile: Extension language enhances C and Scheme<br />
<a href="https://www.ibm.com/developerworks/library/l-guile/index.html">https://www.ibm.com/developerworks/library/l-guile/index.html</a>
</li>

<li>Having fun with Guile: a tutorial<br />
<a href="http://dustycloud.org/misc/guile-tutorial.html">http://dustycloud.org/misc/guile-tutorial.html</a>
</li>

<li>Guile: Loading Readline Support<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/Loading-Readline-Support.html#Loading-Readline-Support">https://www.gnu.org/software/guile/manual/html_node/Loading-Readline-Support.html#Loading-Readline-Support</a>
</li>

<li>lispy<br />
<a href="https://pypi.org/project/lispy/">https://pypi.org/project/lispy/</a>
</li>

<li>Lython<br />
<a href="https://pypi.org/project/Lython/">https://pypi.org/project/Lython/</a>
</li>

<li>Lizpop<br />
<a href="https://pypi.org/project/lizpop/">https://pypi.org/project/lizpop/</a>
</li>

<li>Budoucnost programovacích jazyků<br />
<a href="http://www.knesl.com/budoucnost-programovacich-jazyku">http://www.knesl.com/budoucnost-programovacich-jazyku</a>
</li>

<li>LISP Prolog and Evolution<br />
<a href="http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html">http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html</a>
</li>

<li>List of Lisp-family programming languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages">https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages</a>
</li>

<li>clojure_py na indexu PyPi<br />
<a href="https://pypi.python.org/pypi/clojure_py">https://pypi.python.org/pypi/clojure_py</a>
</li>

<li>PyClojure<br />
<a href="https://github.com/eigenhombre/PyClojure">https://github.com/eigenhombre/PyClojure</a>
</li>

<li>Hy na GitHubu<br />
<a href="https://github.com/hylang/hy">https://github.com/hylang/hy</a>
</li>

<li>Hy: The survival guide<br />
<a href="https://notes.pault.ag/hy-survival-guide/">https://notes.pault.ag/hy-survival-guide/</a>
</li>

<li>Hy běžící na monitoru terminálu společnosti Symbolics<br />
<a href="http://try-hy.appspot.com/">http://try-hy.appspot.com/</a>
</li>

<li>Welcome to Hy’s documentation!<br />
<a href="http://docs.hylang.org/en/stable/">http://docs.hylang.org/en/stable/</a>
</li>

<li>Hy na PyPi<br />
<a href="https://pypi.org/project/hy/#description">https://pypi.org/project/hy/#description</a>
</li>

<li>Getting Hy on Python<br />
<a href="https://lwn.net/Articles/596626/">https://lwn.net/Articles/596626/</a>
</li>

<li>Programming Can Be Fun with Hy<br />
<a href="https://opensourceforu.com/2014/02/programming-can-fun-hy/">https://opensourceforu.com/2014/02/programming-can-fun-hy/</a>
</li>

<li>Přednáška o projektu Hy (pětiminutový lighttalk)<br />
<a href="http://blog.pault.ag/day/2013/04/02">http://blog.pault.ag/day/2013/04/02</a>
</li>

<li>Hy (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Hy">https://en.wikipedia.org/wiki/Hy</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Point<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Point.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Point.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Narrowing<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Narrowing.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Narrowing.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Functions that Create Markers<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Markers.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Markers.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Motion<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Motion.html#Motion">https://www.gnu.org/software/emacs/manual/html_node/elisp/Motion.html#Motion</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Basic Char Syntax<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Char-Syntax.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Char-Syntax.html</a>
</li>

<li>Elisp: Sequence: List, Array<br />
<a href="http://ergoemacs.org/emacs/elisp_list_vs_vector.html">http://ergoemacs.org/emacs/elisp_list_vs_vector.html</a>
</li>

<li>Elisp: Property List<br />
<a href="http://ergoemacs.org/emacs/elisp_property_list.html">http://ergoemacs.org/emacs/elisp_property_list.html</a>
</li>

<li>Elisp: Hash Table<br />
<a href="http://ergoemacs.org/emacs/elisp_hash_table.html">http://ergoemacs.org/emacs/elisp_hash_table.html</a>
</li>

<li>Elisp: Association List<br />
<a href="http://ergoemacs.org/emacs/elisp_association_list.html">http://ergoemacs.org/emacs/elisp_association_list.html</a>
</li>

<li>The mapcar Function (An Introduction to Programming in Emacs Lisp)<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/mapcar.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/mapcar.html</a>
</li>

<li>Anaphoric macro<br />
<a href="https://en.wikipedia.org/wiki/Anaphoric_macro">https://en.wikipedia.org/wiki/Anaphoric_macro</a>
</li>

<li>Some Common Lisp Loop Macro Examples<br />
<a href="https://www.youtube.com/watch?v=3yl8o6r_omw">https://www.youtube.com/watch?v=3yl8o6r_omw</a>
</li>

<li>A Guided Tour of Emacs<br />
<a href="https://www.gnu.org/software/emacs/tour/">https://www.gnu.org/software/emacs/tour/</a>
</li>

<li>The Roots of Lisp<br />
<a href="http://www.paulgraham.com/rootsoflisp.html">http://www.paulgraham.com/rootsoflisp.html</a>
</li>

<li>Evil (Emacs Wiki)<br />
<a href="https://www.emacswiki.org/emacs/Evil">https://www.emacswiki.org/emacs/Evil</a>
</li>

<li>Evil (na GitHubu)<br />
<a href="https://github.com/emacs-evil/evil">https://github.com/emacs-evil/evil</a>
</li>

<li>Evil (na stránkách repositáře MELPA)<br />
<a href="https://melpa.org/#/evil">https://melpa.org/#/evil</a>
</li>

<li>Evil Mode: How I Switched From VIM to Emacs<br />
<a href="https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html">https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html</a>
</li>

<li>GNU Emacs (home page)<br />
<a href="https://www.gnu.org/software/emacs/">https://www.gnu.org/software/emacs/</a>
</li>

<li>GNU Emacs (texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs">http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs</a>
</li>

<li>An Introduction To Using GDB Under Emacs<br />
<a href="http://tedlab.mit.edu/~dr/gdbintro.html">http://tedlab.mit.edu/~dr/gdbintro.html</a>
</li>

<li>An Introduction to Programming in Emacs Lisp<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html</a>
</li>

<li>27.6 Running Debuggers Under Emacs<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html">https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html</a>
</li>

<li>GdbMode<br />
<a href="http://www.emacswiki.org/emacs/GdbMode">http://www.emacswiki.org/emacs/GdbMode</a>
</li>

<li>Emacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Emacs">https://en.wikipedia.org/wiki/Emacs</a>
</li>

<li>Emacs timeline<br />
<a href="http://www.jwz.org/doc/emacs-timeline.html">http://www.jwz.org/doc/emacs-timeline.html</a>
</li>

<li>Emacs Text Editors Family<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?EmacsFamily">http://texteditors.org/cgi-bin/wiki.pl?EmacsFamily</a>
</li>

<li>Vrapper aneb spojení možností Vimu a Eclipse<br />
<a href="https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse/">https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse/</a>
</li>

<li>Vrapper aneb spojení možností Vimu a Eclipse (část 2: vyhledávání a nahrazování textu)<br />
<a href="https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse-cast-2-vyhledavani-a-nahrazovani-textu/">https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse-cast-2-vyhledavani-a-nahrazovani-textu/</a>
</li>

<li>Emacs/Evil-mode - A basic reference to using evil mode in Emacs<br />
<a href="http://www.aakarshnair.com/posts/emacs-evil-mode-cheatsheet">http://www.aakarshnair.com/posts/emacs-evil-mode-cheatsheet</a>
</li>

<li>From Vim to Emacs+Evil chaotic migration guide<br />
<a href="https://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/">https://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/</a>
</li>

<li>Introduction to evil-mode {video)<br />
<a href="https://www.youtube.com/watch?v=PeVQwYUxYEg">https://www.youtube.com/watch?v=PeVQwYUxYEg</a>
</li>

<li>EINE (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/EINE">http://www.emacswiki.org/emacs/EINE</a>
</li>

<li>EINE (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?EINE">http://texteditors.org/cgi-bin/wiki.pl?EINE</a>
</li>

<li>ZWEI (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/ZWEI">http://www.emacswiki.org/emacs/ZWEI</a>
</li>

<li>ZWEI (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?ZWEI">http://texteditors.org/cgi-bin/wiki.pl?ZWEI</a>
</li>

<li>Zmacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Zmacs">https://en.wikipedia.org/wiki/Zmacs</a>
</li>

<li>Zmacs (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?Zmacs">http://texteditors.org/cgi-bin/wiki.pl?Zmacs</a>
</li>

<li>TecoEmacs (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/TecoEmacs">http://www.emacswiki.org/emacs/TecoEmacs</a>
</li>

<li>Micro Emacs<br />
<a href="http://www.emacswiki.org/emacs/MicroEmacs">http://www.emacswiki.org/emacs/MicroEmacs</a>
</li>

<li>Micro Emacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/MicroEMACS">https://en.wikipedia.org/wiki/MicroEMACS</a>
</li>

<li>EmacsHistory<br />
<a href="http://www.emacswiki.org/emacs/EmacsHistory">http://www.emacswiki.org/emacs/EmacsHistory</a>
</li>

<li>Seznam editorů s ovládáním podobným Emacsu či kompatibilních s příkazy Emacsu<br />
<a href="http://www.finseth.com/emacs.html">http://www.finseth.com/emacs.html</a>
</li>

<li>evil-numbers<br />
<a href="https://github.com/cofi/evil-numbers">https://github.com/cofi/evil-numbers</a>
</li>

<li>Debuggery a jejich nadstavby v&nbsp;Linuxu (1.část)<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/</a>
</li>

<li>Debuggery a jejich nadstavby v&nbsp;Linuxu (2.část)<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (3): Nemiver<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (4): KDbg<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (5): ladění aplikací v editorech Emacs a Vim<br />
<a href="https://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">https://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/</a>
</li>

<li>Org mode<br />
<a href="https://orgmode.org/">https://orgmode.org/</a>
</li>

<li>The Org Manual<br />
<a href="https://orgmode.org/manual/index.html">https://orgmode.org/manual/index.html</a>
</li>

<li>Kakoune (modální textový editor)<br />
<a href="http://kakoune.org/">http://kakoune.org/</a>
</li>

<li>Vim-style keybinding in Emacs/Evil-mode<br />
<a href="https://gist.github.com/troyp/6b4c9e1c8670200c04c16036805773d8">https://gist.github.com/troyp/6b4c9e1c8670200c04c16036805773d8</a>
</li>

<li>Emacs - jak začít<br />
<a href="http://www.abclinuxu.cz/clanky/navody/emacs-jak-zacit">http://www.abclinuxu.cz/clanky/navody/emacs-jak-zacit</a>
</li>

<li>Programovací jazyk LISP a LISP machines<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-lisp-a-lisp-machines/">https://www.root.cz/clanky/programovaci-jazyk-lisp-a-lisp-machines/</a>
</li>

<li>Evil-surround<br />
<a href="https://github.com/emacs-evil/evil-surround">https://github.com/emacs-evil/evil-surround</a>
</li>

<li>Spacemacs<br />
<a href="http://spacemacs.org/">http://spacemacs.org/</a>
</li>

<li>Lisp: Common Lisp, Racket, Clojure, Emacs Lisp<br />
<a href="http://hyperpolyglot.org/lisp">http://hyperpolyglot.org/lisp</a>
</li>

<li>Common Lisp, Scheme, Clojure, And Elisp Compared<br />
<a href="http://irreal.org/blog/?p=725">http://irreal.org/blog/?p=725</a>
</li>

<li>Does Elisp Suck?<br />
<a href="http://irreal.org/blog/?p=675">http://irreal.org/blog/?p=675</a>
</li>

<li>Emacs pro mírně pokročilé (9): Elisp<br />
<a href="https://www.root.cz/clanky/emacs-elisp/">https://www.root.cz/clanky/emacs-elisp/</a>
</li>

<li>If I want to learn lisp, are emacs and elisp a good choice?<br />
<a href="https://www.reddit.com/r/emacs/comments/2m141y/if_i_want_to_learn_lisp_are_emacs_and_elisp_a/">https://www.reddit.com/r/emacs/comments/2m141y/if_i_want_to_learn_lisp_are_emacs_and_elisp_a/</a>
</li>

<li>Clojure(Script) Interactive Development Environment that Rocks!<br />
<a href="https://github.com/clojure-emacs/cider">https://github.com/clojure-emacs/cider</a>
</li>

<li>An Introduction to Emacs Lisp<br />
<a href="https://harryrschwartz.com/2014/04/08/an-introduction-to-emacs-lisp.html">https://harryrschwartz.com/2014/04/08/an-introduction-to-emacs-lisp.html</a>
</li>

<li>Emergency Elisp<br />
<a href="http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html">http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html</a>
</li>

<li>Lambda calculus<br />
<a href="https://en.wikipedia.org/wiki/Lambda_calculus">https://en.wikipedia.org/wiki/Lambda_calculus</a>
</li>

<li>John McCarthy's original LISP paper from 1959<br />
<a href="https://www.reddit.com/r/programming/comments/17lpz4/john_mccarthys_original_lisp_paper_from_1959/">https://www.reddit.com/r/programming/comments/17lpz4/john_mccarthys_original_lisp_paper_from_1959/</a>
</li>

<li>Micro Manual LISP<br />
<a href="https://www.scribd.com/document/54050141/Micro-Manual-LISP">https://www.scribd.com/document/54050141/Micro-Manual-LISP</a>
</li>

<li>How Lisp Became God's Own Programming Language<br />
<a href="https://twobithistory.org/2018/10/14/lisp.html">https://twobithistory.org/2018/10/14/lisp.html</a>
</li>

<li>History of Lisp<br />
<a href="http://jmc.stanford.edu/articles/lisp/lisp.pdf">http://jmc.stanford.edu/articles/lisp/lisp.pdf</a>
</li>

<li>The Roots of Lisp<br />
<a href="http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf">http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf</a>
</li>

<li>Racket<br />
<a href="https://racket-lang.org/">https://racket-lang.org/</a>
</li>

<li>The Racket Manifesto<br />
<a href="http://felleisen.org/matthias/manifesto/">http://felleisen.org/matthias/manifesto/</a>
</li>

<li>MIT replaces Scheme with Python<br />
<a href="https://www.johndcook.com/blog/2009/03/26/mit-replaces-scheme-with-python/">https://www.johndcook.com/blog/2009/03/26/mit-replaces-scheme-with-python/</a>
</li>

<li>Adventures in Advanced Symbolic Programming<br />
<a href="http://groups.csail.mit.edu/mac/users/gjs/6.945/">http://groups.csail.mit.edu/mac/users/gjs/6.945/</a>
</li>

<li>Why MIT Switched from Scheme to Python (2009)<br />
<a href="https://news.ycombinator.com/item?id=14167453">https://news.ycombinator.com/item?id=14167453</a>
</li>

<li>Starodávná stránka XLispu<br />
<a href="http://www.xlisp.org/">http://www.xlisp.org/</a>
</li>

<li>AutoLISP<br />
<a href="https://en.wikipedia.org/wiki/AutoLISP">https://en.wikipedia.org/wiki/AutoLISP</a>
</li>

<li>Seriál PicoLisp: minimalistický a výkonný interpret Lispu<br />
<a href="https://www.root.cz/serialy/picolisp-minimalisticky-a-vykonny-interpret-lispu/">https://www.root.cz/serialy/picolisp-minimalisticky-a-vykonny-interpret-lispu/</a>
</li>

<li>Common Lisp<br />
<a href="https://common-lisp.net/">https://common-lisp.net/</a>
</li>

<li>Getting Going with Common Lisp<br />
<a href="https://cliki.net/Getting%20Started">https://cliki.net/Getting%20Started</a>
</li>

<li>Online Tutorial (Common Lisp)<br />
<a href="https://cliki.net/online%20tutorial">https://cliki.net/online%20tutorial</a>
</li>

<li>Guile Emacs<br />
<a href="https://www.emacswiki.org/emacs/GuileEmacs">https://www.emacswiki.org/emacs/GuileEmacs</a>
</li>

<li>Guile Emacs History<br />
<a href="https://www.emacswiki.org/emacs/GuileEmacsHistory">https://www.emacswiki.org/emacs/GuileEmacsHistory</a>
</li>

<li>Guile is a programming language<br />
<a href="https://www.gnu.org/software/guile/">https://www.gnu.org/software/guile/</a>
</li>

<li>MIT Scheme<br />
<a href="http://groups.csail.mit.edu/mac/projects/scheme/">http://groups.csail.mit.edu/mac/projects/scheme/</a>
</li>

<li>SIOD: Scheme in One Defun<br />
<a href="http://people.delphiforums.com/gjc//siod.html">http://people.delphiforums.com/gjc//siod.html</a>
</li>

<li>CommonLispForEmacs<br />
<a href="https://www.emacswiki.org/emacs/CommonLispForEmacs">https://www.emacswiki.org/emacs/CommonLispForEmacs</a>
</li>

<li>Elisp: print, princ, prin1, format, message<br />
<a href="http://ergoemacs.org/emacs/elisp_printing.html">http://ergoemacs.org/emacs/elisp_printing.html</a>
</li>

<li>Special Forms in Lisp<br />
<a href="http://www.nhplace.com/kent/Papers/Special-Forms.html">http://www.nhplace.com/kent/Papers/Special-Forms.html</a>
</li>

<li>Basic Building Blocks in LISP<br />
<a href="https://www.tutorialspoint.com/lisp/lisp_basic_syntax.htm">https://www.tutorialspoint.com/lisp/lisp_basic_syntax.htm</a>
</li>

<li>Introduction to LISP - University of Pittsburgh<br />
<a href="https://people.cs.pitt.edu/~milos/courses/cs2740/Lectures/LispTutorial.pdf">https://people.cs.pitt.edu/~milos/courses/cs2740/Lectures/LispTutorial.pdf</a>
</li>

<li>Why don't people use LISP<br />
<a href="https://forums.freebsd.org/threads/why-dont-people-use-lisp.24572/">https://forums.freebsd.org/threads/why-dont-people-use-lisp.24572/</a>
</li>

<li>Structured program theorem<br />
<a href="https://en.wikipedia.org/wiki/Structured_program_theorem">https://en.wikipedia.org/wiki/Structured_program_theorem</a>
</li>

<li>Clojure: API Documentation<br />
<a href="https://clojure.org/api/api">https://clojure.org/api/api</a>
</li>

<li>Tutorial for the Common Lisp Loop Macro<br />
<a href="http://www.ai.sri.com/pkarp/loop.html">http://www.ai.sri.com/pkarp/loop.html</a>
</li>

<li>Common Lisp's Loop Macro Examples for Beginners<br />
<a href="http://www.unixuser.org/~euske/doc/cl/loop.html">http://www.unixuser.org/~euske/doc/cl/loop.html</a>
</li>

<li>A modern list api for Emacs. No 'cl required.<br />
<a href="https://github.com/magnars/dash.el">https://github.com/magnars/dash.el</a>
</li>

<li>The LOOP Facility<br />
<a href="http://www.lispworks.com/documentation/HyperSpec/Body/06_a.htm">http://www.lispworks.com/documentation/HyperSpec/Body/06_a.htm</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>Transient Data Structures
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Jazyky Hy a Clojure-py: moderní dialekty LISPu určené pro Python VM<br />
<a href="https://www.root.cz/clanky/jazyky-hy-a-clojure-py-moderni-dialekty-lispu-urcene-pro-python-vm/">https://www.root.cz/clanky/jazyky-hy-a-clojure-py-moderni-dialekty-lispu-urcene-pro-python-vm/</a>
</li>

<li>Pixie: lehký skriptovací jazyk s „kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

<li>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/">https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/</a>
</li>

<li>The Nature of Lisp<br />
<a href="https://defmacro.org/ramblings/lisp.html">https://defmacro.org/ramblings/lisp.html</a>
</li>

<li>Stránka projektu Jython<br />
<a href="http://www.jython.org/">http://www.jython.org/</a>
</li>

<li>Jython (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Jython">https://en.wikipedia.org/wiki/Jython</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">https://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>JSR 223: Scripting for the Java<sup>TM</sup> Platform<br />
<a href="https://jcp.org/en/jsr/detail?id=223">https://jcp.org/en/jsr/detail?id=223</a>
</li>

<li>List of JVM languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_JVM_languages">https://en.wikipedia.org/wiki/List_of_JVM_languages</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>Economy Size Geek - Interview with Rich Hickey, Creator of Clojure<br />
<a href="https://www.linuxjournal.com/article/10708">https://www.linuxjournal.com/article/10708</a>
</li>

<li>Pyrsistent: persistentní datové struktury v&nbsp;Pythonu<br />
<a href="https://www.root.cz/clanky/pyrsistent-persistentni-datove-struktury-v-pythonu/">https://www.root.cz/clanky/pyrsistent-persistentni-datove-struktury-v-pythonu/</a>
</li>

<li>Pyrsistent: persistentní datové struktury v&nbsp;Pythonu (dokončení)<br />
<a href="https://www.root.cz/clanky/pyrsistent-persistentni-datove-struktury-v-pythonu-dokonceni/">https://www.root.cz/clanky/pyrsistent-persistentni-datove-struktury-v-pythonu-dokonceni/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

