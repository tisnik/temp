<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Femtolisp: varianta LISPu tvořící součást jazyka Julia</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Femtolisp: varianta LISPu tvořící součást jazyka Julia</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Na Rootu již vyšlo více než dvacet článků o různých dialektech programovacích jazyků LISP a Scheme. Další dialekt, s nímž se seznámíme dnes, se jmenuje Femtolisp. Jedná se o LISP v tradičním pojetí, na němž je zajímavé mj.&nbsp;i to, že je součástí překladače jazyka Julia.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Femtolisp: varianta LISPu tvořící součást jazyka Julia</a></p>
<p><a href="#k02">2. Různé implementace programovacího jazyka Scheme</a></p>
<p><a href="#k03">3. Dialekty LISPu</a></p>
<p><a href="#k04">4. Femtolisp jako součást programovacího jazyky Julia</a></p>
<p><a href="#k05">5. Překlad Femtolispu s&nbsp;bootstrapingem</a></p>
<p><a href="#k06">6. Skutečně minimalistická implementace?</a></p>
<p><a href="#k07">7. Vylepšení REPLu jazyka Femtolisp</a></p>
<p><a href="#k08">8. Základní vlastnosti jazyka Femtolisp</a></p>
<p><a href="#k09">9. Funkce a speciální formy</a></p>
<p><a href="#k10">10. Pojmenované funkce s&nbsp;proměnným počtem parametrů</a></p>
<p><a href="#k11">11. Povinné a nepovinné parametry pojmenovaných funkcí</a></p>
<p><a href="#k12">12. Koncová rekurze</a></p>
<p><a href="#k13">*** 13. Typový systém Femtolispu</a></p>
<p><a href="#k14">14. Lokální rozsah proměnných</a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">17. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k18">18. Předchozí části seriálu</a></p>
<p><a href="#k19">19. Literatura</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Femtolisp: varianta LISPu tvořící součást jazyka Julia</h2>

<p><i>&bdquo;Almost everybody has their own lisp implementation. Some
programmers' dogs and cats probably have their own lisp implementations as
well. This is great, but too often I see people omit some of the obscure but
critical features that make lisp uniquely wonderful. These include read macros
like #. and backreferences, gensyms, and properly escaped symbol names. If
you're going to waste everybody's time with yet another lisp, at least do it
right damnit.&ldquo;<br />
Jeff Bezanson, autor jazyka Femtolisp a spoluautor jazyka Julia</i></p>

<p>Na stránkách <a href="https://www.root.cz/">Roota</a> jsme si &ndash; jak
již ostatně bylo zmíněno v&nbsp;perexu dnešního článku &ndash; popsali
relativně velké množství různých dialektů a implementací programovacích jazyků
LISP a Scheme (viz též <a href="#k18">osmnáctou kapitolu s&nbsp;odkazy na
jednotlivé články o tomto tématu</a>). Jednotlivé implementace se od sebe
odlišují jak poskytovanými možnostmi (některé dialekty například nepodporují
tradiční LISPovské tečka-dvojice, další zase nemají plnohodnotné <a
href="https://en.wikipedia.org/wiki/Tail_call">TCO</a>), podporou či naopak
nepodporou nějakého standardu (<a
href="https://schemers.org/Documents/Standards/R5RS/">R5RS</a>, <a
href="http://www.r6rs.org/">R6RS</a>, <a
href="https://small.r7rs.org/">R7RS</a>, <a
href="http://www.paulgraham.com/acl.html">ANSI CommonLISP</a>), tak i použitými
technologiemi. V&nbsp;prozatím popsaných projektech tedy můžeme najít jak
klasické interpretry, tak i překladače, a to buď překladače do strojového kódu,
překladače do bajtkódu (JVM, WebAssembly), použití just-in-time překladače atd.
Jednotlivé implementace se od sebe odlišují taktéž použitým správcem paměti
(<i>garbage collector</i>) &ndash; což je technologie, která do značné míry
ovlivňuje úspěch či neúspěch implementace LISPu/Scheme v&nbsp;produkčním
prostředí.</p>

<a href="http://i.iinfo.cz/images/455/lisp01.png"><img src="http://i.iinfo.cz/images/455/lisp01-prev.png" alt="lisp01" height="270" width="257" /></a>
<p><i>Obrázek 1: Na tomto grafu evoluce programovacích jazyků můžeme vidět
některé historicky významné programovací jazyky, s&nbsp;nimiž jsme se již
setkali <a href="https://www.root.cz/serialy/unixove-vykopavky/">v&nbsp;seriálu
o historii počítačů</a>. Jedná se zejména o Fortran, Cobol, SNOBOL, Algol, APL,
BASIC (resp.&nbsp;přesněji řečeno celá rodina jazyků nesoucích toho jméno) a
samozřejmě taktéž o LISP a jeho varianty.</i></p>

<p><div class="rs-tip-major">Poznámka: některé implementace Scheme či LISPu
prošly dlouhým vývojem, během něhož došlo ke změně technologií, na nichž jsou
postaveny, a to většinou bez nutnosti měnit zdrojové kódy programů napsaných
v&nbsp;těchto jazycích. Typickým příkladem je <a
href="https://www.gnu.org/software/guile/">GNU Guile</a>, u něhož došlo ke
změně technologie ve verzi 2.0 (<a
href="https://www.hboehm.info/gc/">Boehm–Demers–Weiser GC</a>) a posléze taktéž
ve verzi 2.2 (nový optimalizující překladač a nový virtuální stroj). To vedlo
k&nbsp;urychlení reálných programů až o 30%.</div></p>

<img src="https://i.iinfo.cz/images/668/lisp1-1.jpg" class="image-365364" alt="&#160;" width="350" height="503" />
<p><i>Obrázek 2: Alonzo Church, autor slavného lambda kalkulu, na němž jsou
nepřímo postaveny všechny LISPovské jazyky.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Různé implementace programovacího jazyka Scheme</h2>

<p>V&nbsp;případě, že se zaměříme na projekty implementující nějaký standard
jazyka Scheme (a reálně použitelných a nasaditelných implementací Scheme dnes
existuje <a
href="http://community.schemewiki.org/?scheme-faq-standards#implementations">přibližně
padesát</a>!), můžeme tyto projekty rozdělit do několika skupin:</p>

<ol>

<li>V&nbsp;první skupině nalezneme klasické interpretry běžící nad nějakým
virtuálním strojem popř.&nbsp;překladače do bajtkódu těchto virtuálních strojů.
Do této kategorie patří například <a
href="http://practical-scheme.net/gauche/">Gauche</a>, již v&nbsp;úvodní
kapitole zmíněný <a
href="https://www.root.cz/clanky/gnu-guile-interpret-scheme-vestavitelny-do-nativnich-aplikaci/">GNU
Guile</a>, systém <a
href="https://www.root.cz/clanky/kawa-prekvapive-silny-a-vykonny-dialekt-scheme-pro-jvm/">Kawa</a>,
<a href="https://s48.org/">Scheme48</a>, <a href="http://sisc-scheme.org/">SISC
(Second Interpreter of Scheme)</a>, <a
href="https://people.csail.mit.edu/jaffer/SCM.html">SCM</a> či <a
href="http://www.littlewingpinball.com/doc/en/ypsilon/index.html">Ypsilon</a>
(ten se používá pro programování pravidel pinballů, resp.&nbsp;video verzí
těchto her). Některé ze zmíněných implementací Scheme používají vlastní
virtuální stroj (<i>Guile</i>), další pak nějakou již existující variantu
virtuálního stroje (<i>Kawa</i>, <i>SISC</i>). Z&nbsp;modernějších virtuálních
strojů (resp.&nbsp;bajtkódů pro ně) je nutné zmínit <i>WebAssembly</i>.
Existují minimálně dvě implementace Scheme pro WebAssembly &ndash; <a
href="https://github.com/schism-lang/schism">Schism</a> a <a
href="https://github.com/PollRobots/scheme">PollRobots scheme</a>.</li>

<li>Ve druhé skupině, která je relativně rozsáhlá, nalezneme překladače
programovacího jazyka Scheme do nativního (strojového) kódu. Do této kategorie
můžeme zařadit například <a href="https://scheme.com/">Chez Scheme</a> (ten
získal nejlepší hostname pro svoji domácí stránku), <a
href="http://ikarus-scheme.org/">Ikarus</a>, <a
href="http://larcenists.org/">Larceny</a>, <a
href="https://www.gnu.org/software/mit-scheme/">MIT Scheme</a>, <a
href="https://plt-scheme.org/software/mzscheme/">MzScheme</a> či již popsaný
rozsáhlý systém <a
href="https://www.root.cz/clanky/racket-programovaci-jazyk-a-soucasne-i-platforma-pro-vyvoj-novych-jazyku/">Racket</a>
založený na MzScheme, který je mj.&nbsp;používán i pro výuku (a to mj.&nbsp;i
proto, že obsahuje vlastní GUI, podporu pro tvorbu grafů, interpretry dalších
jazyků, mnohá rozšíření syntaxe založená na systému maker apod.).</li>

<li>A konečně existuje i skupina implementací programovacího jazyka Scheme
založená na <i>transpřekladači (transcompileru, transpileru)</i>, typicky
s&nbsp;výstupem do programovacího jazyka C. To znamená, že se vstupní kód
napsaný v&nbsp;jazyce Scheme analyzuje, transformuje a optimalizuje, ovšem
výstupem není přímo strojový kód, ale více či méně čitelný kód naprogramovaný
v&nbsp;jazyku C (a teoreticky samozřejmě i do jiného jazyka, podle mě by byl
v&nbsp;této roli ideální jazyk <a
href="https://www.root.cz/serialy/programovaci-jazyk-rust/">Rust</a>). Do této
skupiny řadíme především čtveřici <a
href="http://www-sop.inria.fr/indes/fp/Bigloo/">Bigloo</a>, <a
href="https://www.root.cz/clanky/chicken-scheme-dalsi-interpret-a-predevsim-prekladac-programovaciho-jazyka-scheme/">Chicken</a>,
<a href="http://www.gambitscheme.org/wiki/index.php/Main_Page">Gambit-C</a> a
<a href="https://engineering.purdue.edu/~qobi/software/">Stalin</a>. Do této
skupiny patří i projekt <a
href="https://www.root.cz/clanky/projekt-gambit-dalsi-kvalitni-interpret-i-prekladac-programovaciho-jazyka-scheme/">Gambit</a>
a <a href="https://scheme.fail/">Loko Scheme</a> (taktéž se zajímavou doménou).
Ovšem transpřekladačem může být vybavena i implementace <i>SISC</i> zmíněná
v&nbsp;první skupině (tento transpřekladač se jmenuje Hobbit).</li>

</ol>

<p><img src="http://i.iinfo.cz/images/315/hist26-3.jpg" alt="hist26" height="540" width="420" /></p>
<p><i>Obrázek 3: Jedna z&nbsp;mnoha knih o jazyce Scheme.</i></p>

<p><div class="rs-tip-major">Poznámka: existují i další možnosti, jak Scheme
implementovat. Například se může jednat o implementaci naprogramovanou
v&nbsp;JavaScriptu, která může běžet přímo ve webovém prohlížeči, podobně jako
již popsaný jazyk <a
href="https://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp/">WISP</a>,
o němž se ještě zmíníme v&nbsp;navazující kapitole. Příkladem této implementace
Scheme je <a
href="https://www.biwascheme.org/index.html">BiwaScheme</a>.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Dialekty LISPu</h2>

<p><i>&bdquo;The default language, embodied in a succession of popular
languages, has gradually evolved toward Lisp.&ldquo;<br />
Paul Graham</i></p>

<p>Ve světě programovacího jazyka LISP je situace chaotičtější a současně i
zajímavější, než je tomu v&nbsp;případě Scheme (jehož varianty typicky
podporují R5RS, R6RS a blíží se k&nbsp;R7RS). Jednotlivé implementace LISPu
totiž nemusí striktně odpovídat nějakému standardu (tedy obdobě RnRS). Nepsaným
standardem v&nbsp;této oblasti je sice Common Lisp (přesněji ANSI Common Lisp
<strong>je</strong> standard, ovšem zbytečně nabobtnalý), ovšem jen několik
dalších implementací LISPu se tomuto jazyku přibližuje. Neexistence všemi
akceptovaného standardu vedla k&nbsp;tomu, že vzniklo mnoho alternativních
dialektů LISPu popř.&nbsp;různých kombinací LISPu a Scheme (mimochodem: právě
do této kategorie lze zařadit i dnes popisovaný <i>Femtolisp</i>). Příkladem
odklonu od dosti rozsáhlého Common Lispu může být <i>PicoLisp</i>, což je
interpret LISPu pojatý striktně minimalisticky &ndash; a ve své základní
variantě odlišný od ostatních implementací LISPu. Zdrojové kódy PicoLispu
přitom existují ve dvou variantách. Pro všechny 32bitové procesory (a pro
architektury odlišné od x86_64, tedy i pro ARM atd.) se používá varianta
naprogramovaná v&nbsp;programovacím jazyce C, pro 64bitové procesory řady
x86_64 se pak používá varianta, v&nbsp;níž je část zdrojových kódů vytvořena
v&nbsp;assembleru a je vůči céčkové variantě optimalizována (jak s&nbsp;ohledem
na velikost, tak i rychlost interpretace).</p>

<a href="https://www.root.cz/obrazek/337666/"><img src="https://i.iinfo.cz/images/196/emacs2-1-prev.png" class="image-337666" alt="&#160;" width="370" height="196" /></a>
<p><i>Obrázek 4: Vývoj některých dialektů Lispu.<br />
Zdroj: <a href="https://en.wikipedia.org/wiki/Lisp_%28programming_language%29">Wikipedia</a>.</i></p>

<p>Samostatnou kapitolou je pak <i>Interlisp</i>, což původně byl dialekt
LISPu, který zavedl některé nové zajímavé technologie a díky své historii je
velmi zajímavý i v&nbsp;pohledu na vývoj celého IT. Interlisp (psaný původně
verzálkami, tedy INTERLISP či InterLisp) se lišil od většiny tehdejších
interpretrů. Původní Lispy totiž do značné míry vypadaly tak, jako například
dnešní <i>GNU Guile</i> nebo dnes popisovaný <i>Femtolisp</i> &ndash; všechny
formy musely být zapsány jako s-výrazy, přičemž se netolerovaly žádné chyby,
závorky musely být balancovány atd. Interlisp byl v&nbsp;tomto ohledu dosti
odlišný. Zejména byly rozšířeny možnosti nástrojů dodávaných společně
s&nbsp;tímto jazykem &ndash; přidán byl například v&nbsp;té době přelomový
korektor překlepů, přidány byly balíčky pro práci se soubory, balíček CLISP
umožňující zápis algebraických výrazů, programátorský editor pro strukturovaný
kód atd. Pro moderní platformy lze namísto původního <i>Interlispu</i> využít
projekt nazvaný přímočaře <i>LISPF4 - InterLisp Interpreter</i>, který je možné
nalézt na GitHubu, konkrétně na adrese <a
href="https://github.com/blakemcbride/LISPF4">https://github.com/blakemcbride/LISPF4</a>.
V&nbsp;rámci tohoto projektu došlo k&nbsp;přepsání těch částí Interlispu, které
byly původně vytvořeny v&nbsp;assembleru (a to v&nbsp;assembleru pro dobové
mainframy a minipočítače). Přepisem těchto obecně velmi těžko přenositelných
částí do programovacího jazyka C se zajistila mnohem snadnější přenositelnost,
takže dnes pro překlad stačí Linux se základními nástroji GNU toolchainu
(překladač jazyka C, linker).</p>

<img src="https://i.iinfo.cz/images/287/interlisp-4.png" class="image-444843" alt="&#160;" width="336" height="240" />
<p><i>Obrázek 5: Úvodní obrazovka Interlispu/65, což je varianta Intelispu pro
osmibitové mikroprocesory MOS 6502.</i></p>

<p>A nesmíme zapomenout ani na <i>transpilery</i>, mezi něž patří například
jazyk <i>Hy</i>, jemuž jsme se <a
href="https://www.root.cz/clanky/jazyky-hy-a-clojure-py-moderni-dialekty-lispu-urcene-pro-python-vm/">na
stránkách Roota taktéž věnovali</a>. Programovací jazyk <i>Hy</i> je určen pro
ekosystém jazyka Python. Programátorem zapsaný kód transformuje do Pythonu
s&nbsp;využitím AST a dokonce dokáže zdrojový LISPovský kód transformovat do
Pythonu a teprve poté ho spustit. To je výhodná vlastnost, protože umožňuje Hy
integrovat například s&nbsp;existujícími debuggery atd. Překlad přes AST nebo
Python podporuje jak Python 2.x, tak i Python 3.x. Další důležitou vlastností
Hy je možnost plné kooperace mezi kódem zapsaným přímo v&nbsp;tomto jazyku a
Pythoním kódem, což znamená, že je možné použít všechny Pythonovské knihovny a
frameworky (včetně Numpy, PyTorch, Flask atd.) a naopak &ndash; například mít
napsanou aplikaci v&nbsp;Pythonu a pro manipulaci se symboly použít Hy
(v&nbsp;tomto ohledu jsou homoikonické programovací jazyky s&nbsp;makry podle
mého názoru mnohem lepší než samotný Python, ostatně na tomto konceptu staví i
jazyk Julia).</p>

<a href="http://i.iinfo.cz/images/521/java32-01.png"><img src="http://i.iinfo.cz/images/521/java32-01-prev.png" width="370" height="231" alt="&#160;" /></a>
<p><i>Obrázek 6: Hra Abuse je z&nbsp;velké části napsána v&nbsp;LISPu &ndash;
nízkoúrovňové části používají nativní knihovny (na Linuxu například SDL), ovšem
veškerá herní logika je skutečně v&nbsp;LISPu a s&nbsp;troškou vůle a volného
času lze z&nbsp;Abuse vytvořit zcela odlišnou hru. Zdánlivá malá výkonnost
LISPu se zde neprojevuje, protože Abuse lze bez problémů hrát i na stařičkém
počítači s&nbsp;mikroprocesorem 80486DX2 (ostatně nízká výkonnost LISPu je pro
mnoho jeho implementací spíše legendou, než faktem).</i></p>

<p><div class="rs-tip-major">Poznámka: samostatnou kategorií je jazyk
<i>Clojure</i> a některé jeho dialekty, mezi které patří například poněkud
přehlížený <a
href="https://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp/">projekt
Wisp</a> (neboli Web Lisp). Clojure není ani klasickým LISPem ani Scheme, ale
jazykem postaveným nad myšlenkami původního LISPu a upraveným tak, aby
podporoval různé mechanismy řízení <i>stavu</i> programů (což je asi
nejdůležitějším přínosem tohoto jazyka).</div></p>

<img src="https://i.iinfo.cz/images/287/interlisp-6.png" class="image-444845" alt="&#160;" width="336" height="240" />
<p><i>Obrázek 7: Specifikem Interlispu/65 je existence funkcí
<strong>POKE</strong>, <strong>PEEK</strong>, <strong>STICK</strong> atd., tedy
funkcí známých z&nbsp;Atari BASICu a důležitých pro vývoj reálných aplikací.
Zde se s&nbsp;využitím funkce <strong>POKE</strong> změnil obsah barvového
registru s&nbsp;barvou pozadí obrazovky v&nbsp;textovém režimu.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Femtolisp se představuje</h2>

<p><i>&bdquo;You mean, how much you can develop during a PhD on scientific
computing with a known technical computing syntax and paradigm on top of a
modular compiler infrastructure with an enthusiastic community?&ldquo;</i></p>

<p>Dnes popisovaný dialekt jazyka LISP (resp.&nbsp;spíše Scheme, které je samo
o sobě dialekt LISPu) se jmenuje <i>Femtolisp</i>. Za vývojem tohoto
programovacího jazyka, jehož zdrojové kódy i (poněkud stručnou) dokumentaci
najdete na <a
href="https://github.com/JeffBezanson/femtolisp">https://github.com/JeffBezanson/femtolisp</a>,
stojí <i>Jeff Bezanson</i>, který je ovšem známější jako spoluautor
programovacího jazyka <a
href="https://www.root.cz/serialy/programovaci-jazyk-julia/">Julia</a>. Jeff se
kromě dalších věcí z&nbsp;oblasti <i>computer science</i> zabývá i typovými
systémy, viz též <a
href="https://github.com/JeffBezanson/phdthesis/blob/master/main.pdf">text jeho
doktorské práce</a> (ostatně i jemu můžeme vděčit za typový systém Julie).
Femtolisp je sice relativně minimalistickou implementací LISPu/Scheme, ovšem
obsahuje prakticky všechny důležité ikredience tohoto jazyka, a to včetně
podpory TCO a makrosystému. Jednou z&nbsp;chybějících věcí je podpora pro
&bdquo;dlouhá&ldquo; celá čísla a pro zlomky, což Femtolisp odlišuje například
od již popsaného projektu Guile.</p>

<p>Z&nbsp;praktického hlediska je důležité, že Femtolisp je dnes součástí již
zmíněného jazyka Julia, protože je použit pro parsing zdrojových kódů. Ostatně
právě poměrně pokročilý makrosystém jazyka Julia je umožněn tím, že je parsing
naprogramován pravě ve Femtolispu, tedy v&nbsp;jazyku, v&nbsp;němž je
manipulace se stromy (AST) snadná. V&nbsp;rámci zpracování zdrojových kódů se
totiž provádí několik operací, mezi jinými i transformace podobná této:</p>

<pre>
f(a, b) = sum(a' * b + a * b')
&nbsp;
Main.sum(Main.+(Main.Ac_mul_B(a,b),Main.A_mul_Bc(a,b)))
</pre>

<p>Příklady využití Femtolispu naleznete přímo <a
href="https://github.com/JuliaLang/Julia">v&nbsp;repositáři jazyka Julia</a>,
například v&nbsp;souborech <a
href="https://github.com/JuliaLang/julia/blob/master/src/ast.scm">ast.scm</a> a
<a
href="https://github.com/JuliaLang/julia/blob/master/src/jlfrontend.scm">jlfrontend.scm</a>.</p>

<p>O přítomnosti Femtolispu v&nbsp;jazyce Julia se můžeme snadno přesvědčit.
Standardní REPL tohoto jazyka se spouští takto:</p>

<pre>
$ <strong>julia</strong>
&nbsp;
   _       _ _(_)_     |  Documentation: https://docs.julialang.org
  (_)     | (_) (_)    |
   _ _   _| |_  __ _   |  Type "?" for help, "]?" for Pkg help.
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 1.5.3 (2020-11-09)
 _/ |\__'_|_|_|\__'_|  |  Fedora 33 build
|__/                   |
</pre>

<p>Ovšem po zadání přepínače <strong>--lisp</strong> se spustí REPL jiného
jazyka, konkrétně Femtolispu:</p>

<pre>
$ <strong>julia --lisp</strong>
&nbsp;
;  _
; |_ _ _ |_ _ |  . _ _
; | (-||||_(_)|__|_)|_)
;-------------------|----------------------------------------------------------
</pre>

<p><div class="rs-tip-major">Poznámka: mimochodem, aby se kruh uzavřel, je
možné díky modulu <a
href="https://github.com/swadey/LispSyntax.jl">LispSyntax.jl</a> psát programy
v&nbsp;LISPovské stylu i přímo v&nbsp;REPLu jazyka Julia.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Překlad Femtolispu s&nbsp;bootstrapingem</h2>

<p>Získání funkční verze Femtolispu je snadné. Postačuje pouze použít základní
vývojářské nástroje, konkrétně Git, Make a GNU C (popř.&nbsp;jiný překladač
programovacího jazyka C). Nejprve je pochopitelně nutné získat zdrojové
kódy:</p>

<pre>
$ <strong>git clone https://github.com/JeffBezanson/femtolisp.git</strong>
&nbsp;
Cloning into 'femtolisp'...
remote: Enumerating objects: 2412, done.
remote: Total 2412 (delta 0), reused 0 (delta 0), pack-reused 2412
Receiving objects: 100% (2412/2412), 1.60 MiB | 2.20 MiB/s, done.
Resolving deltas: 100% (1498/1498), done.
</pre>

<p>Vlastní překlad je prováděn v&nbsp;několika fázích, protože je podporován
takzvaný <i>bootstraping</i>. Nejdříve se přeloží jen ta nejzákladnější
varianta jazyka a teprve poté všechny potřebné symboly a funkce:</p>

<pre>
$ <strong>cd femtolisp</strong>
</pre>

<pre>
$ <strong>make</strong>
&nbsp;
gcc -O2 -DNDEBUG -falign-functions -Wall -Wno-strict-aliasing -Illt  -DUSE_COMPUTED_GOTO -c flisp.c -o flisp.o
gcc -O2 -DNDEBUG -falign-functions -Wall -Wno-strict-aliasing -Illt  -DUSE_COMPUTED_GOTO -c builtins.c -o builtins.o
gcc -O2 -DNDEBUG -falign-functions -Wall -Wno-strict-aliasing -Illt  -DUSE_COMPUTED_GOTO -c string.c -o string.o
string.c: In function ‘fl_string_width’:
string.c:56:21: warning: implicit declaration of function ‘wcwidth’ [-Wimplicit-function-declaration]
   56 |             int w = wcwidth(*(uint32_t*)cp_data(cp));
      |                     ^~~~~~~
gcc -O2 -DNDEBUG -falign-functions -Wall -Wno-strict-aliasing -Illt  -DUSE_COMPUTED_GOTO -c equalhash.c -o equalhash.o
gcc -O2 -DNDEBUG -falign-functions -Wall -Wno-strict-aliasing -Illt  -DUSE_COMPUTED_GOTO -c table.c -o table.o
...
...
...
gcc -O3 -DNDEBUG -Wall -Wno-strict-aliasing  -c lltinit.c -o lltinit.o
rm -rf libllt.a
ar rs libllt.a bitvector.o hashing.o socket.o timefuncs.o ptrhash.o utf8.o ios.o dirpath.o htable.o bitvector-ops.o int2str.o dump.o random.o lltinit.o
ar: creating libllt.a
make[1]: Leaving directory '/home/ptisnovs/temp/femtolisp/llt'
rm -rf libflisp.a
ar rs libflisp.a flisp.o builtins.o string.o equalhash.o table.o iostream.o
ar: creating libflisp.a
gcc -O2 -DNDEBUG -falign-functions -Wall -Wno-strict-aliasing -Illt  -DUSE_COMPUTED_GOTO -c flmain.c -o flmain.o
gcc -O2 -DNDEBUG -falign-functions -Wall -Wno-strict-aliasing -Illt  -DUSE_COMPUTED_GOTO flisp.o builtins.o string.o equalhash.o table.o iostream.o flmain.o -o flisp llt/libllt.a -lm libflisp.a
</pre>

<p>Samotná definice bootstrapingu vypadá přibližně následovně. Povšimněte si,
že se první minimalisticky pojatá verze Femtolispu použije pro vytvoření
základní knihovny tvořící prakticky nedílnou součást virtuálního stroje tohoto
jazyka:</p>

<pre>
#!/bin/sh
&nbsp;  
cp flisp.boot flisp.boot.bak
&nbsp;  
echo "Creating stage 0 boot file..."
#../../branches/interpreter/femtolisp/flisp mkboot0.lsp system.lsp compiler.lsp &gt; flisp.boot.new
./flisp mkboot0.lsp system.lsp compiler.lsp &gt; flisp.boot.new
mv flisp.boot.new flisp.boot
&nbsp;  
echo "Creating stage 1 boot file..."
./flisp mkboot1.lsp
&nbsp;  
echo "Testing..."
make test
</pre>

<p>Na konci se automaticky spustí testy, které ověří základní vlastnosti nově
přeloženého interpretru:</p>

<pre>
cd tests &amp;&amp; ../flisp unittest.lsp
all tests pass
</pre>

<p>Výsledkem překladu jsou dva soubory: spustitelný interpret
<strong>flisp</strong> a dále soubor <strong>flisp.boot</strong> se základními
funkcemi, ovšem přeloženými do &bdquo;bajtkódu&ldquo; (nejedná se ovšem o
skutečný bajtkód v&nbsp;původním významu tohoto slova). Pro další práci budete
skutečně potřebovat pouze tyto dva soubory.</p>

<p>Ověření výsledků překladu:</p>

<pre>
$ <strong>file flisp</strong>
flisp: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=685356fb92af78d4addae34f30047683e0299afc, for GNU/Linux 3.2.0, not stripped
</pre>

<p>Nyní si můžeme vyzkoušet spuštění interpretru:</p>

<pre>
$ <strong>./flisp</strong>
</pre>

<p>Zobrazit by se mělo logo Femtolispu následované výzvou (<i>prompt</i>):</p>

<pre>
;  _
; |_ _ _ |_ _ |  . _ _
; | (-||||_(_)|__|_)|_)
;-------------------|----------------------------------------------------------
&nbsp;
&gt;
</pre>

<p>Otestujeme, zda interpret reaguje na základní formu:</p>

<pre>
&gt; <strong>(+ 1 2)</strong>
3
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;naklonovaném repositáři je ještě
jedna varianta Lispu, která je menší. Naleznete ji v&nbsp;podadresáři
<strong>tiny</strong>:</div></p>

<pre>
$ <strong>cd tiny</strong>
&nbsp;
$ <strong>make</strong>
gcc -O3 -fomit-frame-pointer -Wall -Wextra lisp.c -o lisp 
&nbsp;
$ <strong>ls -l lisp</strong>
-rwxrwxr-x 1 ptisnovs ptisnovs 31560 Jan 15 17:09 lisp
&nbsp;
$ <strong>./lisp</strong>
Welcome to femtoLisp ----------------------------------------------------------
</pre>

<p>Touto variantou se však nebudeme v&nbsp;dalším textu zabývat. Snad jen stojí
za povšimnutí velikost výsledného binárního souboru &ndash; relativně malý
interpret o velikosti 31560 bajtů.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Skutečně minimalistická implementace?</h2>

<p>Původně byl <i>Femtolisp</i> pojat (alespoň podle slov svého autora) přísně
minimalisticky, a to jak s&nbsp;ohledem na velikost výsledného binárního kódu
s&nbsp;jazykem, tak i s&nbsp;ohledem na množství podporovaných knihoven.
Postupně se však jak vlastní jazyk, tak i množství podporovaných knihoven
rozrostlo, takže Femtolisp již &ndash; i přes své jméno &ndash; nepatří mezi
nejmenší prakticky použitelný dialekt LISPu či Scheme. Vzhledem k&nbsp;tomu, že
jsem v&nbsp;minulosti používal jazyky, jejichž velikost spustitelného souboru
byla 8kB (klasické verze BASICů), 4kB (základní verze jazyka BASIC) či pouze 1
kB (Forth), pochopitelně mě zajímalo, jak malý či naopak velký je Femtolisp po
svém překladu. Ostatně se můžeme podívat do následující tabulky, v&nbsp;níž
jsou vypsány velikosti některých malých (podle tvrzení autorů) implementací
LISPu a Scheme. Pro porovnání s&nbsp;mainstreamem jsem ještě přidal velikosti
interpretrů dalších programovacích jazyků. Všechny získané velikosti přitom
platí pro architekturu x86_64, případné balíčky pochází z&nbsp;Linux Mintu
(ovšem LISPy a Scheme jsem překládal přímo ze zdrojových kódů):</h4>

<table>
<tr><th>#</th><th>Interpret/VM</th><th>Velikost</th><th>Poznámka</th></tr>
<tr><td>1</td><td>Femtolisp</td><td>&nbsp;&nbsp;176&nbsp;296</td><td>po <strong>strip</strong></td></tr>
<tr><td>2</td><td>tiny Femtolisp</td><td>&nbsp;&nbsp;&nbsp;31&nbsp;560</td><td>alternativní implementace zmíněná výše</td></tr>
<tr><td>3</td><td>picolisp</td><td>&nbsp;&nbsp;195&nbsp;272</td><td>&nbsp;</td></tr>
<tr><td>4</td><td>tinyscheme</td><td>&nbsp;&nbsp;&nbsp;78&nbsp;152</td><td>po <strong>strip</strong></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>lua5.1</td><td>&nbsp;&nbsp;174&nbsp;976</td><td>standardní instalace z&nbsp;balíčku</td></tr>
<tr><td>6</td><td>lua5.2</td><td>&nbsp;&nbsp;195&nbsp;416</td><td>standardní instalace z&nbsp;balíčku</td></tr>
<tr><td>7</td><td>luajit</td><td>&nbsp;&nbsp;445&nbsp;080</td><td>standardní instalace z&nbsp;balíčku</td></tr>
<tr><td>8</td><td>python2.7</td><td>3&nbsp;674&nbsp;216</td><td>standardní instalace z&nbsp;balíčku</td></tr>
<tr><td>9</td><td>python3.8</td><td>5&nbsp;490&nbsp;488</td><td>standardní instalace z&nbsp;balíčku</td></tr>
</table>

<p>Binární kód Femtolispu byl zmenšen příkazem <strong>strip</strong>, a to
z&nbsp;této původní velikosti:</p>

<pre>
$ <strong>ls -l flisp</strong>
&nbsp;
-rwxrwxr-x 1 ptisnovs ptisnovs <u>205336</u> Dec 11 11:10 flisp
</pre>

<p>Na zobrazených přibližně 176 kB:</p>

<pre>
$ <strong>strip flisp</strong>
$ <strong>ls -l flisp</strong>
&nbsp;
-rwxrwxr-x 1 ptisnovs ptisnovs <u>176296</u> Dec 11 13:10 flisp
</pre>

<p><div class="rs-tip-major">Poznámka: do určité míry se jedná o porovnání
hrušek s&nbsp;jablky, protože nebereme do úvahy, jaké funkce jsou danou
implementací poskytovány ani případnou závislost na podpůrných knihovnách.
Ovšem všechny výše uvedené jazyky podporují REPL (<i>Read Eval Print Loop</i>),
jsou dynamicky typované, podporují do jisté míry funkcionální programování a
navíc mají automatického správce paměti: takže se opravdu může jednat o
porovnání hrušek s&nbsp;jablky a nikoli hrušek s&nbsp;tanky.</div></p>

<p><div class="rs-tip-major">Poznámka<sup>2</sup>: některé další možnosti,
například běh LISPu či Scheme na mikrořadičích, jsou zmíněny na stránce <a
href="https://dmitryfrank.com/articles/lisp_on_mcu">https://dmitryfrank.com/articles/lisp_on_mcu</a>.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vylepšení REPLu jazyka Femtolisp</h2>

<p>Femtolisp není přeložen s&nbsp;podporou knihovny <i>readline</i>, což je
patrné i z&nbsp;následujícího výpisu dynamických knihoven, na kterých Femtolisp
závisí:</p>

<pre>
$ <strong>ldd flisp </strong>
&nbsp;
        linux-vdso.so.1 (0x00007ffd68cb3000)
        libm.so.6 =&rarr; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f36b36d4000)
        libc.so.6 =&rarr; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f36b34e2000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f36b3869000)
</pre>

<p>Proč je to důležité? Nepodpora <i>readline</i>, mj.&nbsp;znamená, že
neexistuje historie příkazového řádku, není možné používat editační příkazy
typu <strong>Ctrl+A</strong>, <strong>Ctrl+E</strong>, vyhledávání v&nbsp;dříve
zadaných příkazech pomocí <strong>Ctrl+R</strong> atd. A navíc nefunguje
automatické doplňování jmen symbolů klávesou <strong>Tab</strong>. Tyto
vlastnosti, které dnes od REPLů prakticky automaticky očekáváme, je možné do
jisté míry doplnit externím nástrojem <strong>rlwrap</strong>. Tomu můžeme
předat soubor se symboly pro automatické doplňování. Spustíme tedy
<strong>flisp</strong> a zavoláme funkci <strong>environment</strong>:</p>

<pre>
&gt; <strong>(environment)</strong>
&nbsp;
(zero? write wchar void vector.map vector-&gt;list vector.alloc vector? values
       untrace vector ulong uint64 uint32 typeof uint16 uint8 traced? trace
       truncate top-level-exception-handler top-level-value to-proper
       time.string that table.values table.pairs table.keys table.invert
       table.foreach table.clone table.foldl table? table tan time.fromstring
       ...
       ...
       ...
</pre>

<p>Tento seznam symbolů je možné přesměrovat do souboru, který se může jmenovat
například <strong>environment.txt</strong>. Jeho ukázku nalezneme na adrese <a
href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/environment.txt">https://github.com/tisnik/lisp-families/blob/master/femtolisp/environment.txt</a>.
Následně <strong>flisp</strong> ukončíme a spustíme odlišným způsobem:</p>

<pre>
$ <strong>rlwrap -f environment.txt -m -M .scm ./flisp</strong>
</pre>

<p>Zdánlivě nedojde k&nbsp;žádné podstatné změně, ovšem nyní je možné využívat
historii příkazového řádku (šipky nahoru, dolů + vyhledávání), editovat obsah
příkazového řádku, zavolat externí editor pro delší texty a taktéž používat
klávesu <strong>Tab</strong> pro doplňování jmen symbolů &ndash; tedy
v&nbsp;naprosté většině případů funkcí, maker a speciálních forem
programovacího jazyka.</p>

<p><div class="rs-tip-major">Poznámka: soubor <strong>environment.txt</strong>
lze přepsat ve chvíli, kdy je do REPLu načten program funkcí <strong>(load
jméno_souboru)</strong>. V&nbsp;takovém případě se ve výsledném souboru objeví
i symboly definované v&nbsp;programu. Nejedná se sice o plnohodnotnou formu
technologie <i>code completion</i>, ovšem v&nbsp;každém případě bude situace
lepší, než nemít k&nbsp;dispozici žádnou podobnou pomůcku.</div></p>

<p>V&nbsp;dalším textu jsou vypsány vybrané klávesové zkratky, které jsou ve
výchozím nastavení použity knihovnou GNU Readline při přepnutí do režimu Emacs
(což je výchozí chování).</p>



<h4>Příkazy pro přesuny kurzoru</h4>

<p>Základní příkazy pro přesun kurzoru používají kombinaci Ctrl+znak, Alt+znak
popř.&nbsp;alternativně Esc, znak v&nbsp;případě, že zkratky Alt+znak kolidují
s&nbsp;emulátorem terminálu (například vyvolávají příkazy z&nbsp;menu &ndash;
což je z&nbsp;nějakého důvodu dnes moderní). Pokud je terminál správně
nakonfigurován, měly by fungovat i kurzorové šipky a navíc i klávesy Home a End
(se zřejmou funkcí):</p>

<table>
<tr><th>Klávesa</th><th>Význam</th></tr>
<tr><td>Ctrl+B</td><td>přesun na předchozí znak</td></tr>
<tr><td>Ctrl+F</td><td>přesun na další znak</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Alt+B</td><td>přesun na předchozí slovo</td></tr>
<tr><td>Alt+F</td><td>přesun na další slovo</td></tr>
<tr><td>Esc, B</td><td>shodné s&nbsp;Alt+B</td></tr>
<tr><td>Esc, F</td><td>shodné s&nbsp;Alt+F</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Ctrl+A</td><td>přesun na začátek řádku</td></tr>
<tr><td>Ctrl+E</td><td>přesun na konec řádku</td></tr>
</table>



<h4>Mazání textu, práce s&nbsp;kill ringem</h4>

<p>Pro přesun části textu v&nbsp;rámci editovaného řádku se používá takzvaný
<i>kill ring</i>, do něhož se smazaný text uloží. Pro vložení takto smazaného
textu do jiné oblasti se používá operace nazvaná <i>yank</i> (odpovídá
<i>paste</i>). Některé dále uvedené příkazy dokážou s&nbsp;kill ringem
pracovat:</p>

<table>
<tr><th>Klávesa</th><th>Význam</th></tr>
<tr><td>Ctrl+K</td><td>smaže text od kurzoru do konce řádku a uloží ho do kill ringu</td></tr>
<tr><td>Ctrl+U</td><td>smaže text od začátku řádku do pozice kurzoru a uloží ho do kill ringu</td></tr>
<tr><td>Ctrl+W</td><td>smaže předchozí slovo a uloží ho do kill ringu</td></tr>
<tr><td>Alt+D</td><td>smaže následující slovo a uloží ho do kill ringu</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Ctrl+Y</td><td>vloží text z&nbsp;kill ringu na místo, na němž se nachází kurzor (<i>yank</i>)</td></tr>
<tr><td>Alt+Y</td><td>po operaci Ctrl+Y dokáže <i>rotovat</i> historií kill ringu a obnovit tak (před)předchozí smazaný text</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Ctrl+D</td><td>smaže jeden znak (pokud je ovšem na řádku nějaký obsah, jinak typicky ukončí aplikaci)</td></tr>
</table>



<h4>Práce s&nbsp;historií dříve zadaných příkazů</h4>

<table>
<tr><th>Klávesa</th><th>Význam</th></tr>
<tr><td>Ctrl+P</td><td>průchod historií &ndash; předchozí text</td></tr>
<tr><td>Ctrl+N</td><td>průchod historií &ndash; následující text</td></tr>
<tr><td>Ctrl+R</td><td>zpětné (interaktivní) vyhledávání v&nbsp;historii</td></tr>
<tr><td>Ctrl+G</td><td>ukončení režimu vyhledávání</td></tr>
</table>



<h4>Některé další dostupné příkazy</h4>

<table>
<tr><th>Klávesa</th><th>Význam</th></tr>
<tr><td>Tab</td><td>implicitní klávesa pro zavolání <i>completeru</i></td></tr>
<tr><td>Ctrl+T</td><td>prohození dvou znaků (před kurzorem a na pozici kurzoru)</td></tr>
<tr><td>Ctrl+^</td><td>zavolání externího editoru</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Alt+U</td><td>text od pozice kurzoru do konce slova se změní NA VERZÁLKY</td></tr>
<tr><td>Alt+L</td><td>text od pozice kurzoru do konce slova se změní na mínusky</td></tr>
<tr><td>Alt+C</td><td>text od pozice kurzoru do konce slova se změní Tak, Že Slova Začínají Velkým Písmenem</td></tr>
</table>

<p>Důležitá i klávesová zkratka <strong>Ctrl+^</strong>, která zavolá textový
editor specifikovaný v&nbsp;proměnné prostředí <strong>EDITOR</strong> nebo
<strong>VISUAL</strong>. Do editoru lze vložit delší funkci či makro a uložit
výsledek, který se v&nbsp;REPLu ihned provede. Při volání
<strong>rlwrap</strong> jsme nastavili jména dočasných souborů tak, aby měly
příponu <strong>.scm</strong>, což zvolenému editoru umožní zvýraznění
syntaxe.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Základní vlastnosti jazyka Femtolisp</h2>

<p>Femtolisp sice ve svém názvu obsahuje <i>LISP</i>, ale samotná sémantika
implementovaného jazyka se spíše přibližuje vlastnostem popsaným v&nbsp;R4RS i
R5RS, takže jen v&nbsp;krátkosti (většinu příkladů jsme již viděli
v&nbsp;některém z&nbsp;předchozích článků). Všechny ukázky jsou zkopírovány
přímo z&nbsp;REPLu.</p>

<p>V&nbsp;dále uvedených příkladech budeme používat upravenou formu funkce
<strong>print</strong>, která provede automatické odřádkování:</p>

<pre>
(define (print item)
     (princ item)
     (newline))
</pre>

<p><div class="rs-tip-major">Poznámka: každá funkce vrací nějakou hodnotu, a to
včetně funkce <strong>newline</strong> vracející <strong>#t</strong>
(<strong>true</strong>). Pokud vám nevyhovuje neustálý výpis této hodnoty, lze
funkci <strong>print</strong> upravit na:</div></p>

<pre>
(define (print item)
     (princ item)
     (newline)
     "")
</pre>



<h4>Práce s&nbsp;tečka-dvojicemi</h4>

<p>Název LISP sice vznikl ze slov <i>LISt Processing</i>, ovšem ve skutečnosti
není základním složeným typem LISPů seznam (<i>list</i>), ale takzvaná
tečka-dvojice. Seznamy jsou jen jednou formou uspořádání tečka dvojic (další
formou mohou být stromy atd.).</p>

<pre>
<strong>(print '(1 . 2))</strong>
(1 . 2)
&nbsp;
<strong>(print '(1 . ((2 . 3) . 4)))</strong>
(1 (2 . 3) . 4)
&nbsp;
<strong>(print '((1 . 2) . (3 . 4)))</strong>
((1 . 2) 3 . 4)
&nbsp;
<i>; this is NOT proper list</i>
<strong>(print '(1 . (2 . (3 . nil))))</strong>
(1 2 3 . nil)
&nbsp;
<i>; this is proper list</i>
<strong>(print '(1 . (2 . (3 . ()))))</strong>
(1 2 3)
&nbsp;
<i>; this is NOT proper list</i>
<strong>(print '(1 . (2 . (3 . (4 ())))))</strong>
(1 2 3 4 ())
&nbsp;
<i>; this is proper list</i>
<strong>(print '(1 . (2 . (3 . (4 . ())))))</strong>
(1 2 3 4)
</pre>



<h4>Konstrukce tečka dvojic realizovaná formou <strong>cons</strong></h4>

<p>Tečka-dvojice lze z&nbsp;existujících hodnot a symbolů konstruovat
s&nbsp;využitím formy <strong>cons</strong>:</p>

<pre>
<i>; cons usage</i>
<strong>(cons 1 2)</strong>
(1 . 2)
&nbsp;
<i>; another cons usage</i>
<strong>(cons 1 (cons 2 3))</strong>
(1 2 . 3)
&nbsp;
<i>; this is proper list</i>
<strong>(cons 1 (cons 2 (cons 3 '())))</strong>
(1 2 3)
&nbsp;
<i>; this is proper list</i>
<strong>(cons 1 '(2 3 4))</strong>
(1 2 3 4)
&nbsp;
<i>; this is NOT proper list</i>
<strong>(cons 1 (cons 2 (cons 3 4)))</strong>
(1 2 3 . 4)
</pre>



<h4>Konstrukce seznamů</h4>

<p>Z&nbsp;tečka-dvojic lze sestrojit seznamy, což bylo ukázáno v&nbsp;posledním
příkladu:</p>

<pre>
<i>; this is proper list</i>
<strong>(print '(1 . (2 . (3 . (4 . ())))))</strong>
(1 2 3 4)
</pre>

<p>Vzhledem k&nbsp;tomu, že se seznamy používají velmi často (a to i pro
vytváření vyhodnocovaných forem), existuje i kratší způsob jejich zápisu:</p>

<pre>
<i>; empty list</i>
<strong>'()</strong>
()
&nbsp;
<i>; a list</i>
<strong>'(1 2 3 4)</strong>
(1 2 3 4)
&nbsp;
<i>; another list</i>
<strong>(list 1 2 3 4)</strong>
(1 2 3 4)
</pre>



<h4>Základní operace se seznamy &ndash; <strong>car</strong> a <strong>cdr</strong></h4>

<p>Ze seznamů lze získat první prvek formou <strong>car</strong> a zbylé prvky
formou <strong>cdr</strong>. Existují i další kombinace <strong>car</strong> a
<strong>cdr</strong> zapisované jako <strong>cadr</strong>,
<strong>cddr</strong> atd.:</p>

<pre>
<i>; create list and assign it to symbol</i>
<strong>(define a '(1 2 3 4))</strong>
(1 2 3 4)
&nbsp;
<i>; get the first item</i>
<strong>(car a)</strong>
1
&nbsp;
<i>; get the rest of a list</i>
<strong>(cdr a)</strong>
(2 3 4)
&nbsp;
<i>; combination of car+cdr</i>
<strong>(cadr a)</strong>
2
&nbsp;
<i>; combination of cdr+cdr</i>
<strong>(cddr a)</strong>
(3 4)
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Funkce a speciální formy</h2>

<p>Podobně jako u každého dialektu programovacího jazyka LISP
resp.&nbsp;Scheme, i v&nbsp;případě <i>Femtolispu</i> se program skládá
především z&nbsp;funkcí. Ty mohou být anonymní (nepojmenované) či naopak
pojmenované. Nejprve se zabývejme pojmenovanými funkcemi, protože ty se chovají
prakticky stejně, jako běžné funkce v&nbsp;jiných programovacích jazycích
&ndash; pouze způsob jejich zápisu je odlišný. Pojmenované funkce se definují
pomocí speciální formy <strong>define</strong>, za níž v&nbsp;závorkách
následuje jméno funkce. Každá funkce může mít libovolný počet parametrů,
jejichž jména se uvádí v&nbsp;seznamu ihned za pojmenováním funkce. Poslední
částí formy <strong>define</strong> je v&nbsp;tomto případě tělo funkce,
přičemž po zavolání funkce se vyhodnocená forma vrátí jako její výsledek (nikde
se tedy nezapisuje slovo &bdquo;return&ldquo; ani nic s&nbsp;podobným významem
&ndash; ostatně podobný způsob je použit i v&nbsp;Rustu):</p>

<pre>
<i>; one-liner function</i>
(define (<strong>add</strong> x y) (+ x y))
&nbsp;
<i>; function written on more lines</i>
(define (<strong>mul</strong> x y)
  (* x y))
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti je výše uvedená definice
pouze syntaktickým cukrem nahrazujícím definici proměnné, jejíž hodnotou je
anonymní funkce, která je zapisovaná pomocí speciální formy
<strong>lambda</strong>. Bez použití syntaktického cukru by definice nové
funkce vypadala takto:</div></p>

<pre>
<i>; function written on more lines using lambda</i>
(define <strong>div</strong> (lambda (x y)
  (* x y)))
</pre>

<p>Zavolání funkce je jednoduché &ndash; používá se stále ten samý formát
seznamu, na jehož prvním místě je jméno funkce a za ním následují
parametry:</p>

<pre>
(print (add 1 2))
(print (mul 6 7))
(print (div 10 3))
</pre>

<p>Kromě pojmenovaných funkcí, které jsme si již představili v&nbsp;předchozím
textu, je možné ve <i>Femtolispu</i> použít i funkce anonymní, tj.&nbsp;funkce,
které nejsou navázány na žádné jméno. Pro tento účel se používá přímo lambda
výraz (bez <strong>define</strong>), podobně jako v&nbsp;každém ortodoxním
Lispu (snad kromě <i>PicoLispu</i>):</p>

<pre>
<i>; anonymous function is a value</i>
(lambda (x y) (+ x y))
&nbsp;
<i>; call anonymous function</i>
(print (lambda (x y) (+ x y)))
</pre>

<p>Další důležitou vlastností jazyka implementovaného ve <i>Femtolispu</i>,
s&nbsp;níž se dnes (znovu) seznámíme, je použití takzvaných <i>speciálních
forem</i>. Ze syntaktického hlediska jsou speciální formy zapisovány naprosto
stejným způsobem jako běžné funkce, ovšem existuje zde jeden významný rozdíl
&ndash; zatímco u funkcí jsou všechny jejich parametry nejdříve vyhodnoceny, u
speciálních forem k&nbsp;tomuto vyhodnocení obecně nedochází, resp.&nbsp;jsou
vyhodnoceny pouze některé parametry (které konkrétně, to závisí na tom, o jakou
speciální formu se jedná). S&nbsp;některými speciálními formami jsme se již
setkali, především s&nbsp;formou <strong>define</strong> či
<strong>let</strong>, ovšem existují i formy další &ndash;
<strong>cond</strong>, <strong>if</strong>, <strong>and</strong>,
<strong>lambda</strong>, <strong>quote</strong>, <strong>do</strong> atd.</p>

<p>Speciální forma <strong>cond</strong>:</p>

<pre>
(define (sgn n)
  (<strong>cond</strong>
        ((&lt; n 0)      'negative)
        ((&gt; n 0)      'positive)
        ((zero? n)    'zero)))
</pre>

<p>Alternativní forma s&nbsp;větví <i>else</i>:</p>

<pre>
(define (sgn-2 n)
  (<strong>cond</strong>
        ((&lt; n 0)      'negative)
        ((&gt; n 0)      'positive)
        (#t           'zero)))
</pre>

<p>Speciální forma <strong>case</strong>:</p>

<pre>
(print
    (<strong>case</strong> (* 2 3)
      ((2 3 5 7) 'prime)
      ((1 4 6 8 9) 'composite)))
</pre>

<pre>
(print
    (<strong>case</strong> (car '(a y x))
    ((a e i o u) 'vowel)
    ((w y) 'semivowel)
    (else 'consonant)))
</pre>

<p>Speciální forma <strong>do</strong> pro realizaci smyček:</p>

<pre>
(define (compute-pi n)
  (let ((pi 4.0))
    (<strong>do</strong> ((i 3 (+ i 2)))
      ((&gt; i (+ n 2)))
      (set! pi (* pi (/ (- i 1) i) (/ (+ i 1) i))))
    pi))
&nbsp;
(<strong>do</strong> ((n 1 (* n 2)))
  ((&gt; n 10000000))
  (princ n)
  (princ " ")
  (princ (compute-pi n))
  (newline))
</pre>

<p>Pojmenované <strong>let</strong>, taktéž pro realizaci smyček:</p>

<pre>
(define (let-loop)
  (<strong>let</strong> loop ((i 0))
    (cond ((&gt; i 10))
          (else (print i)
                (loop (+ i 1))))))
</pre>

<p>Smyčka typu <strong>repeat n</strong>:</p>

<pre>
(define (call-n-times n proc)
  (<strong>let</strong> loop ((n n))
    (unless (zero? n)
      (proc)
      (loop (- n 1)))))
&nbsp;
(define (print-hello)
  (print "Hello"))
&nbsp;
(call-n-times 10 print-hello)
</pre>

<p>Ještě lepší řešení pro funkci s&nbsp;argumenty:</p>

<pre>
(define (call-n-times n proc argument)
  (<strong>let</strong> loop ((n n))
    (unless (zero? n)
      (proc argument)
      (loop (- n 1)))))
&nbsp;
(call-n-times 10 print "Hello")
</pre>

<p><div class="rs-tip-major">Poznámka: viz též diskuze na stránce <a
href="https://codereview.stackexchange.com/questions/110741/looping-in-scheme">https://codereview.stackexchange.com/questions/110741/looping-in-scheme</a>.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Pojmenované funkce s&nbsp;proměnným počtem parametrů</h2>

<p>Vzhledem k&nbsp;tomu, že speciální formu <strong>define</strong> (ve
variantě, kdy se definuje funkce) lze kdykoli zapsat s&nbsp;využitím speciální
formy <strong>lambda</strong>, je v&nbsp;programovacím jazyku <i>Femtolisp</i>
možné nadefinovat pojmenovanou funkci akceptující proměnný
(tj.&nbsp;v&nbsp;krajním případě i nulový) počet parametrů, z&nbsp;nichž je při
volání funkce automaticky vytvořen seznam, se kterým je možné v&nbsp;těle
funkce libovolným způsobem manipulovat. Syntakticky vypadá definice takové
funkce následovně:</p>

<pre>
(<strong>define (jméno funkce . parametr) [tělo funkce]</strong>)
</pre>

<p>Což je ekvivalentní zápisu, který již známe z&nbsp;předchozího textu:</p>

<pre>
(<strong>define jméno funkce (lambda parametr [tělo funkce])</strong>)
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;předchozím zápisu je důležité, že
<strong>parametr</strong> není uzavřen do kulatých závorek tak, jak by tomu
bylo v&nbsp;případě, kdyby se jednalo o klasický seznam parametrů.</div></p>

<p>Následuje příklad definice funkce s&nbsp;proměnným počtem parametrů:</p>

<pre>
<i>; funkce vracející počet skutečně předaných parametrů</i>
<strong>(define (foo . parametry) (length parametry))</strong>
</pre>

<p>Zavolání této funkce bez parametrů vrátí nulu:</p>

<pre>
<strong>(foo)</strong>
0
</pre>

<p>Předat můžeme jeden parametr:</p>

<pre>
<strong>(foo 42)</strong>
1
</pre>

<p>A samozřejmě i větší počet parametrů:</p>

<pre>
<strong>(foo 1 2)</strong>
2
&nbsp;
<strong>(foo "bar" "baz")</strong>
2
&nbsp;
<strong>(foo '(1 2 3 4))</strong>
1
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;posledním příkladu byl předán
jediný parametr (kterým je čistě náhodou seznam), proto se vrátila
jednička.</div></p>

<p>Ukažme si ještě alternativní formu zápisu využívající kombinace
<strong>define</strong> a <strong>lambda</strong>:</p>

<pre>
<i>; alternativní forma zápisu</i>
(define foo (lambda parametry (length parametry)))
&nbsp;
<i>; volání funkce bez parametrů</i>
(foo)
0
&nbsp;
<i>; volání funkce se třemi parametry (zde se jedná o trojici symbolů)</i>
(foo 'a 'b 'c)
3
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Povinné a nepovinné parametry pojmenovaných funkcí</h2>

<p>Při definici funkcí lze určit i nepovinné parametry. Hodnoty nepovinných
parametrů se uloží do seznamu, jehož jméno je uvedeno za tečkou v&nbsp;seznamu
parametrů. Jedná se tedy o kombinaci klasických funkcí s&nbsp;konstantním
počtem povinných parametrů a funkcí s&nbsp;proměnným počtem parametrů.</p>

<p>Podívejme se na jednoduchý příklad funkcí, které se liší jak počtem
parametrů, tak i tím, zda akceptují nepovinné parametry:</p>

<pre>
(define (f1)
  (print "no parameters"))
&nbsp;
(define (f2 a)
  (print "one parameter")
  (print a))
&nbsp;
(define (f3 a b)
  (print "two parameters")
  (print a)
  (print b))
&nbsp;
(define (f4 a . b)
  (print "at least one parameter")
  (print a)
  (print b))
&nbsp;
(define (f5 a b . c)
  (print "at least two parameters")
  (print a)
  (print b)
  (print c))
&nbsp;
(f1)
(f2 10)
(f3 1 2)
(f4 1)
(f4 1 2)
(f4 1 2 3)
(f5 1 2)
(f5 1 2 3)
(f5 1 2 3 4)
</pre>

<p>Výsledky získané po spuštění skriptu:</p>

<pre>
<strong>(f1)</strong>
no parameters
&nbsp;
<strong>(f2 10)</strong>
one parameter
10
&nbsp;
<strong>(f3 1 2)</strong>
two parameters
1
2
&nbsp;
<strong>(f4 1)</strong>
at least one parameter
1
()
&nbsp;
<strong>(f4 1 2)</strong>
at least one parameter
1
(2)
&nbsp;
<strong>(f4 1 2 3)</strong>
at least one parameter
1
(2 3)
&nbsp;
<strong>(f5 1 2)</strong>
at least two parameters
1
2
()
&nbsp;
<strong>(f5 1 2 3)</strong>
at least two parameters
1
2
(3)
&nbsp;
<strong>(f5 1 2 3 4)</strong>
at least two parameters
1
2
(3 4)
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Koncová rekurze</h2>

<p>V&nbsp;naprosté většině algoritmů se objevují bloky kódu, které se mají
iterativně opakovat. Při programování s&nbsp;využitím funkcionálního
paradigmatu se iterace vyjadřuje formou rekurze. Ta je samozřejmě ve
<i>Scheme</i> podporována (mezi jediné známější jazyky, které rekurzi
nepodporovaly, patřil původní <i>FORTRAN</i> a <i>Basic</i>), ovšem specifikace
jazyka <i>Scheme</i> jde ještě dále, protože určuje, ve kterých případech je
skutečná rekurze (při níž se parametry a návratové adresy musí ukládat na
zásobník) nahrazena takzvanou <i>koncovou rekurzí</i>, což zjednodušeně řečeno
znamená, že se namísto skutečného rekurzivního volání funkce interně provede
obyčejný skok (koncový skok či koncové volání) bez nutnosti alokace místa na
zásobníku pro parametry volané funkce a návratové adresy. Touto specifikací se
také do značné míry řídí <i>Femtolisp</i>.</p>

<p>Koncová rekurze představuje při správném použití velmi silnou programovací
techniku, protože umožňuje zapisovat mnoho algoritmů v&nbsp;mnohdy elegantní
rekurzivní formě, ovšem skutečné zpracování takto zapsaných algoritmů je stejně
efektivní jako provádění programové smyčky (každou koncovou rekurzi lze
nahradit smyčkou a naopak).</p>

<p>Následující funkce <strong>plus</strong> sice rekurzivně volá sebe sama,
ovšem z&nbsp;pohledu sémantiky se jedná o běžnou iteraci, protože volání
<strong>plus</strong> lze nahradit skokem &ndash; není zapotřebí si pamatovat
předchozí výsledky:</p>

<pre>
<i>; A classic example taken from MIT 6.001 course</i>
&nbsp;
(define (plus x y)
  (if (= x 0)
      y
      (plus (- x 1) (+ y 1))))
&nbsp;
(princ (plus 10000000 10000000))
(newline)
</pre>

<p>Při nepatrné úpravě ovšem získáme rekurzivní variantu, v&nbsp;níž je nutné
si pamatovat mezivýsledky získané při fázi navíjení:</p>

<pre>
<i>; A classic example taken from MIT 6.001 course</i>
&nbsp;
(define (plus x y)
  (if (= x 0)
      y
      (+ 1 (plus (- x 1) y))))
&nbsp;
(princ (plus 10000000 10000000))
(newline)
</pre>

<p>Dalším klasickým příkladem rozdílu mezi normální (plnou, skutečnou) rekurzí
a koncovou rekurzí je výpočet faktoriálu. Ten můžeme zapsat mnoha způsoby,
například (jak je to v&nbsp;matematice obvyklé), rekurzivně:</p>

<pre>
(define (factorial n)
    (if (= n 0) <i>; podmínka pro ukončení rekurzivního zanořování</i>
        1       <i>; faktoriál nuly je definitoricky roven jedné</i>
        (* n (factorial (- n 1)))))
</pre>

<p>Z&nbsp;teoretického hlediska není na výše uvedené funkci nic nekorektního,
ovšem při jejím praktickém používání brzy narazíme na limit způsobený omezenou
velikostí zásobníku.</p>

<p>Výše uvedený rekurzivní výpočet lze relativně malou úpravou převést na
výpočet který (alespoň v&nbsp;programovacím jazyce <i>Scheme</i>) vede na
koncové volání, což mj.&nbsp;znamená, že paměťové (prostorové) nároky tohoto
programu jsou konstantní:</p>

<pre>
<i>; výpočet faktoriálu využívající koncového volání</i>
(define (factorial n)
    (let fact-iter (          <i>; pomocná vnitřní funkce</i>
                  (n n)       <i>; počitadlo iterací</i>
                  (result 1)) <i>; průběžný výsledek</i>
        (if (= n 0)           <i>; po dosažení koncového stavu</i>
            result            <i>; se vrátí průběžný výsledek</i>
            (fact-iter (- n 1) (* n result)) <i>; koncové volání</i>
        )))
</pre>

<p><div class="rs-tip-major">Poznámka: i překlad do nativního kódu by měl být
v&nbsp;tomto případě lepší, než u běžné rekurzivní varianty.</div></p>

<p>Zásobník používaný v&nbsp;rekurzivních variantách není nijak omezený (na
rozdíl od mnoha dalších programovacích jazyků). Takže se může stát, že proces
začne používat swap. Prozatím ve <i>Femtolispu</i> neexistuje možnost omezení
velikosti zásobníku (na daný počet prvků) tak, jak to má například
<i>Guile</i>:</p>

<pre>
(define (plus x y)
  (if (= x 0)
      y
      (plus (- x 1) (+ y 1))))
&nbsp;
(define (test)
  (display (plus 10000000 10000000)))
&nbsp;
(define (handler)
  (display "Stack overflow\n"))
&nbsp;
<strong>(call-with-stack-overflow-handler 1000 test handler)</strong>
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Typový systém Femtolispu</h2>

<p>Femtolisp je sice odvozen od programovacího jazyka Scheme, ale ve
skutečnosti postrádá například plnou &bdquo;numerickou věž&ldquo;, což znamená,
že zde neexistuje úplná hierarchie numerických datových typů (celá čísla,
zlomky, reálná čísla, komplexní čísla). Většina aritmetických operací je
prováděna s&nbsp;hodnotami s&nbsp;plovoucí řádovou čárkou zpracovatelnými
matematickým koprocesorem popř.&nbsp;se operace provádí s&nbsp;čísly typu
<strong>int</strong>. To mj.&nbsp;znamená, že se Femtolisp bude chovat odlišně,
než například Guile. Příkladem může být jednoduchý výpočet podílu.</p>

<p>Femtolisp:</p>

<pre>
<strong>(/ 4 3)</strong>
1.3333333333333333
</pre>

<p>Guile:</p>

<pre>
<strong>(/ 4 3)</strong>
4/3
</pre>

<p>Test na přetečení celých čísel:</p>

<pre>
(define (print item)
     (princ item)
     (newline))
&nbsp;
(do ((n 1 (* n 2)))
  ((&gt; n 100000000000000000000))
  (print n))
</pre>

<p>Po spuštění ve Femtolispu je patrné, že se korektně detekovalo
přetečení:</p>

<pre>
1
2
4
8
16
32
...
...
...
72057594037927936
144115188075855872
288230376151711744
576460752303423488
&nbsp;
Press ENTER or type command to continue
parse-error: read: overflow in numeric constant 100000000000000000000
in file int_size.scm
</pre>

<p><div class="rs-tip-major">Poznámka: mnoho dalších implementací LISPu a
Scheme by přešlo na reprezentaci celých čísel s&nbsp;neomezeným
rozsahem.</div></p>

<p>Podívejme se nyní na další datové typy a jejich hodnoty. Snadno zjistíme, že
datový typ (a současně i hodnota) <strong>nil</strong> není přímo podporován
&ndash; i v&nbsp;tomto ohledu se tedy blížíme spíše ke Scheme než ke klasickým
LISPům:</p>

<pre>
<strong>nil</strong>
eval: variable nil has no value
#0 (lambda)
</pre>

<p>Pro reprezentaci pravdivostních hodnot se používají symboly
<strong>#t</strong> a <strong>#f</strong>, které se vyhodnocují samy na
sebe:</p>

<pre>
<strong>#t</strong>
#t
&nbsp;
<strong>#f</strong>
#f
</pre>

<p>Specifický význam má i prázdný seznam, jenž je zapisován takto:</p>

<pre>
<strong>'()</strong>
()
</pre>

<p>Nebo takto:</p>

<pre>
<strong>()</strong>
()
</pre>

<p><div class="rs-tip-major">Poznámka: vzhledem k&nbsp;tomu, že neexistuje
symbol <strong>nil</strong>, není nutné definovat podmínky jeho ekvivalence
s&nbsp;prázdným seznamem, což sice skalní LISPaře nepotěší, ale jedná se o
čistší návrh.</div></p>

<p>Podporovány jsou pochopitelně seznamy, ovšem vzhledem k&nbsp;tomu, že jak
seznamy, tak i formy se zapisují do hranatých závorek, je u seznamů nutné
zakázat jejich vyhodnocování:</p>

<pre>
<strong>(1 2 3)</strong>
type error: apply: expected function, got 1
#0 (lambda)
&nbsp;
<strong>'(1 2 3)</strong>
(1 2 3)
</pre>

<p>Femtolisp podporuje i zápis vektorů, resp.&nbsp;přesněji řečeno literálů
představujících vektory:</p>

<pre>
<strong>[1 2 3]</strong>
[1 2 3]
</pre>

<p>Řetězce se zapisují do uvozovek, jak je to běžné.</p>

<p>Ve Femtolispu je možné typ hodnoty (popř.&nbsp;skupinu typů) zjistit
s&nbsp;využitím několika predikátů, což jsou formy, jejichž jména končí
otazníkem:</p>

<table>
<tr><th>Predikát</th></tr>
<tr><td>atom?</td></tr>
<tr><td>list?</td></tr>
<tr><td>vector?</td></tr>
<tr><td>null?</td></tr>
<tr><td>number?</td></tr>
<tr><td>fixnum?</td></tr>
</table>

<p>Tyto predikáty si můžeme relativně snadno otestovat, a to pro hodnoty
libovolného typu:</p>

<pre>
(define (print item)
     (princ item)
     (newline))
&nbsp;
(define nil '())
&nbsp;
(print "atom?")
(print (atom? nil))
(print (atom? #t))
(print (atom? 42))
(print (atom? 3.14))
(print (atom? "string"))
(print (atom? '(1 2 3)))
(print (atom? [1 2 3]))
(newline)
&nbsp;
(print "list?")
(print (list? nil))
(print (list? #t))
(print (list? 42))
(print (list? 3.14))
(print (list? "string"))
(print (list? '(1 2 3)))
(print (list? [1 2 3]))
(newline)
&nbsp;
(print "vector?")
(print (vector? nil))
(print (vector? #t))
(print (vector? 42))
(print (vector? 3.14))
(print (vector? "string"))
(print (vector? '(1 2 3)))
(print (vector? [1 2 3]))
(newline)
&nbsp;
(print "null?")
(print (null? nil))
(print (null? #t))
(print (null? 42))
(print (null? 3.14))
(print (null? "string"))
(print (null? '(1 2 3)))
(print (null? [1 2 3]))
(newline)
&nbsp;
(print "number?")
(print (number? nil))
(print (number? #t))
(print (number? 42))
(print (number? 3.14))
(print (number? "string"))
(print (number? '(1 2 3)))
(print (number? [1 2 3]))
(newline)
&nbsp;
(print "fixnum?")
(print (fixnum? nil))
(print (fixnum? #t))
(print (fixnum? 42))
(print (fixnum? 3.14))
(print (fixnum? "string"))
(print (fixnum? '(1 2 3)))
(print (fixnum? [1 2 3]))
(newline)
&nbsp;
(print "zero?")
(print (zero? 0))
(print (zero? 42))
(newline)
</pre>

<p>Výsledky jsou vypsány na jednotlivé řádky, což ovšem není příliš
přehledné:</p>

<pre>
atom?
#t
#t
#t
#t
#t
#f
#t

list?
#t
#f
#f
#f
#f
#t
#f

vector?
#f
#f
#f
#f
#f
#f
#t

null?
#t
#f
#f
#f
#f
#f
#f

number?
#f
#f
#t
#t
#f
#f
#f

fixnum?
#f
#f
#t
#f
#f
#f
#f

zero?
#t
#f
</pre>

<table>
<tr><th></th><th></th></tr>
<tr><td></td><td></td></tr>
</table>


<p><a name="k14"></a></p>
<h2 id="k14">14. Lokální rozsah proměnných</h2>

<p>Jazyk Scheme (do kterého Femtolisp spadá, i přes své jméno) je, na rozdíl od
původních LISPů, založen na lokálním rozsahu proměnných (<i>local scope</i>).
Můžeme si to ostatně relativně snadno ukázat na následujícím demonstračním
příkladu, v&nbsp;němž je uvnitř funkce <strong>add</strong> použit lokální
rozsah, v&nbsp;rámci něhož je vyhodnocována proměnná <strong>x</strong>:</p>

<pre>
(define x 1)
(define y 2)
&nbsp;
(define (add x y)
    <i>; rozsah (scope) je lokální!</i>
    (set! x (+ x y))
    x)
&nbsp;
(print (add x y))
(print (add x y))
&nbsp;
(set! x 10)
(print (add x y))
(print (add x y))
</pre>

<p>Po spuštění tohoto příkladu se vypíše:</p>

<pre>
3
3
12
12
</pre>

<p><div class="rs-tip-major">Poznámka: ve funkci <strong>add</strong> se tedy
z&nbsp;pohledu z&nbsp;vnějšku neměnila globální proměnná
<strong>x</strong>.</div></p>

<p>Příklad s&nbsp;globálními a lokálními proměnnými:</p>

<p>Příklad s&nbsp;globálními a lokálními proměnnými:</p>

<pre>
(define x 1)
(define y 2)
&nbsp;
(define (add x y)
    (+ x y))
&nbsp;
(print (add x y))
&nbsp;
(print
    (let ((x 10)
          (y 20))
          (add x y)))
&nbsp;
&nbsp;
(set! x 10)
(print (add x y))
&nbsp;
(print
    (let ((x 10)
          (y 20))
          (add x y)))
&nbsp;
(print
    (let ((x 100))
          (add x y)))
</pre>

<p>Po spuštění tohoto demonstračníh příkladu se vypíše:</p>

<pre>
3
30
12
30
102
</pre>

<p><div class="rs-tip-major">Poznámka: <i>lexical scope</i> má ovšem
dalekosáhlejší důsledky, které mj.&nbsp;ovlivňují činnost správce paměti atd.
Jde o to, že pokud je nějaká proměnná (která je definovaná vně funkce) na
funkci <i>navázána</i> (prakticky: je ve funkci použita), nemůže tato proměnná
zaniknout ani při opuštění daného bloku, protože společně s&nbsp;funkcí tvoří
takzvaný <i>uzávěr (closure</i>). S&nbsp;uzávěry se v&nbsp;LISPovské rodině
jazyků setkáme velmi často a dnes je nalezneme i v&nbsp;některých dalších
programovacích jazycích (zdaleka ne ve všech):</div></p>

<pre>
(define (larger-than limit)
    (lambda (value) (&gt; value limit)))
&nbsp;
(print ((larger-than 5) 0))
(print ((larger-than 5) 10))
&nbsp;
(print (filter (larger-than 5) '(1 2 3 4 5 6 7 8 9 10)))
</pre>

<p>S&nbsp;těmito výsledky:</p>

<pre>
#f
#t
(6 7 8 9 10)
(6 7 8 9 10)
</pre>

<p>Další, nepatrně složitější implementace uzávěrů:</p>

<pre>
(define counter
    (let ((i -1))
         (lambda ()
             (set! i (+ i 1))
             i)))
&nbsp;
(print (counter))
(print (counter))
(print (counter))
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
0
1
2
</pre>

<p><div class="rs-tip-major">Poznámka: zde jsme vytvořili funkci
<strong>counter</strong>, kterou lze v&nbsp;určitém ohledu považovat za
<i>objekt</i>, protože má vlastní <i>stav</i> a <i>zapouzdřuje</i> hodnotu
čítače představovaného proměnnou <strong>i</strong>.</div></p>

<pre>
(define (get-counter)
    (let ((i -1))
         (lambda ()
             (set! i (+ i 1))
             i)))
&nbsp;
(define counter1 (get-counter))
(define counter2 (get-counter))
&nbsp;
(print (counter1))
(print (counter1))
(print (counter1))
&nbsp;
(print (counter2))
(print (counter2))
(print (counter2))
&nbsp;
(print (counter1))
(print (counter1))
(print (counter1))
</pre>

<p>Výsledky činnosti dvou čítačů:</p>

<pre>
0
1
2
&nbsp;
0
1
2
&nbsp;
3
4
5
</pre>

<p>Uzávěry ve skutečnosti nejsou &bdquo;obyčejnými&ldquo; funkcemi, protože je
lze současně považovat za úložiště dat. Viz například následující příklad, <a
href="https://mk12.github.io/sicp/text/2/1.html">který je uváděn</a> ve slavném
kurzu 6.001 na MIT (pravděpodobně nejlépe strukturovaném kurzu o informatice
vůbec). V&nbsp;tomto příkladu je <strong>cons-</strong> nositelem dat o
tečka-dvojici:</p>

<pre>
(define (cons- x y)
  (lambda (m)
    (if (= m 0) x y)))
&nbsp;
(define (car- z) (z 0))
(define (cdr- z) (z 1))
&nbsp;
(princ (cons- 1 2))
(newline)
&nbsp;
(princ (car- (cons- 1 2)))
(newline)
&nbsp;
(princ (cdr- (cons- 1 2)))
(newline)
</pre>

<p><div class="rs-tip-major">Poznámka: jazyky podporující uzávěry tedy
teoreticky vůbec nemusí podporovat další způsoby reprezentace dat (i když
z&nbsp;praktického pohledu je tomu jinak).</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

<p></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>

<p></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů určených pro
spuštění ve Femtolispu byly uloženy do Git repositáře, který je dostupný na
adrese <a
href="https://github.com/tisnik/lisp-families.git">https://github.com/tisnik/lisp-families.git</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, můžete
namísto toho použít odkazy na jednotlivé příklady, které naleznete
v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>boolean_ops.scm</td><td>pravdivostní operace</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/boolean_ops.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/boolean_ops.scm</a></td></tr>
<tr><td> 2</td><td>case1.scm</td><td>speciální forma <strong>case</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/case1.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/case1.scm</a></td></tr>
<tr><td> 3</td><td>case2.scm</td><td>speciální forma <strong>case</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/case2.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/case2.scm</a></td></tr>
<tr><td> 4</td><td>closure_1.scm</td><td>uzávěry, příklad číslo 1</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/closure_1.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/closure_1.scm</a></td></tr>
<tr><td> 5</td><td>closure_2.scm</td><td>uzávěry, příklad číslo 2</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/closure_2.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/closure_2.scm</a></td></tr>
<tr><td> 6</td><td>closure_3.scm</td><td>uzávěry, příklad číslo 3</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/closure_3.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/closure_3.scm</a></td></tr>
<tr><td> 7</td><td>closure_4.scm</td><td>uzávěry, příklad číslo 4</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/closure_4.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/closure_4.scm</a></td></tr>
<tr><td> 8</td><td>cond2.scm</td><td>speciální forma <strong>cond</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/cond2.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/cond2.scm</a></td></tr>
<tr><td> 9</td><td>cond.scm</td><td>speciální forma <strong>cond</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/cond.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/cond.scm</a></td></tr>
<tr><td>10</td><td>cons.scm</td><td>funkce <strong>cons</strong> použitá pro konstrukci seznamu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/cons.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/cons.scm</a></td></tr>
<tr><td>11</td><td>dot_pairs.scm</td><td>konstrukce tečka dvojic <i>(dot pairs</i>)</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/dot_pairs.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/dot_pairs.scm</a></td></tr>
<tr><td>12</td><td>factorial_1.scm</td><td>rekurzivní výpočet faktoriálu, první varianta</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/factorial_1.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/factorial_1.scm</a></td></tr>
<tr><td>13</td><td>factorial_2.scm</td><td>rekurzivní výpočet faktoriálu, druhá varianta</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/factorial_2.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/factorial_2.scm</a></td></tr>
<tr><td>14</td><td>factorial_3.scm</td><td>tail rekurze při výpočtu faktoriálu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/factorial_3.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/factorial_3.scm</a></td></tr>
<tr><td>15</td><td>factorial_4.scm</td><td>tabulka faktoriálů</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/factorial_4.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/factorial_4.scm</a></td></tr>
<tr><td>16</td><td>functions.scm</td><td>deklarace a volání funkcí</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/functions.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/functions.scm</a></td></tr>
<tr><td>17</td><td>int_size.scm</td><td>rozsah hodnot typu <strong>integer</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/int_size.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/int_size.scm</a></td></tr>
<tr><td>18</td><td>lexical_scope_1.scm</td><td>lexikální oblast platnosti proměnných, příklad číslo 1</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/lexical_scope_1.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/lexical_scope_1.scm</a></td></tr>
<tr><td>19</td><td>lexical_scope_2.scm</td><td>lexikální oblast platnosti proměnných, příklad číslo 2</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/lexical_scope_2.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/lexical_scope_2.scm</a></td></tr>
<tr><td>20</td><td>lexical_scope_3.scm</td><td>lexikální oblast platnosti proměnných, příklad číslo 3</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/lexical_scope_3.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/lexical_scope_3.scm</a></td></tr>
<tr><td>21</td><td>lexical_scope_4.scm</td><td>lexikální oblast platnosti proměnných, příklad číslo 4</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/lexical_scope_4.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/lexical_scope_4.scm</a></td></tr>
<tr><td>22</td><td>lists.scm</td><td>základní práce se seznamy</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/lists.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/lists.scm</a></td></tr>
<tr><td>23</td><td>pi_1.scm</td><td>výpočet π realizované ve Scheme, základní varianta</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/pi_1.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/pi_1.scm</a></td></tr>
<tr><td>24</td><td>predicates.scm</td><td>základní predikáty</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/predicates.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/predicates.scm</a></td></tr>
<tr><td>25</td><td>ackermann.scm</td><td>výpočet Ackermannovy funkce</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/ackermann.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/ackermann.scm</a></td></tr>
<tr><td>26</td><td>functions_varargs.scm</td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/functions_varargs.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/functions_varargs.scm</a></td></tr>
<tr><td>27</td><td>lambdas.scm</td><td>lambda výrazy</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/lambdas.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/lambdas.scm</a></td></tr>
<tr><td>28</td><td>let_loop_iterate1.scm</td><td>pojmenovaná forma <strong>let</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/let_loop_iterate1.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/let_loop_iterate1.scm</a></td></tr>
<tr><td>29</td><td>let_loop_iterate2.scm</td><td>pojmenovaná forma <strong>let</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/let_loop_iterate2.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/let_loop_iterate2.scm</a></td></tr>
<tr><td>30</td><td>let_loop.scm</td><td>pojmenovaná forma <strong>let</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/let_loop.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/let_loop.scm</a></td></tr>
<tr><td>31</td><td>MIT_6.001_plus_1.scm</td><td>funkce <strong>plus</strong>, iterativní výpočet</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/MIT_6.001_plus_1.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/MIT_6.001_plus_1.scm</a></td></tr>
<tr><td>32</td><td>MIT_6.001_plus_2.scm</td><td>funkce <strong>plus</strong>, rekurzivní výpočet</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/MIT_6.001_plus_2.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/MIT_6.001_plus_2.scm</a></td></tr>
<tr><td>33</td><td>MIT_6.001_sqrt.scm</td><td>funkce <strong>sqrt</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/femtolisp/MIT_6.001_sqrt.scm">https://github.com/tisnik/lisp-families/blob/master/femtolisp/MIT_6.001_sqrt.scm</a></td></tr>
</table>



<p><a name="k18"></a></p>
<h2 id="k18">18. Předchozí části seriálu</h2>

<p>V&nbsp;této kapitole jsou uvedeny odkazy na všechny předchozí části seriálu
o světě programovacích jazyků LISP a Scheme (kromě samostatného seriálu, který
se věnoval programovacímu jazyku Clojure):</p>

<ol>

<li>Jemný úvod do rozsáhlého světa jazyků LISP a Scheme<br />
<a href="https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/">https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/</a>
</li>

<li>PicoLisp: minimalistický a přitom překvapivě výkonný interpret Lispu<br />
<a href="https://www.root.cz/clanky/picolisp-minimalisticky-a-pritom-prekvapive-vykonny-interpret-lispu/">https://www.root.cz/clanky/picolisp-minimalisticky-a-pritom-prekvapive-vykonny-interpret-lispu/</a>
</li>

<li>PicoLisp: užitečné funkce a speciální formy používané při tvorbě aplikací<br />
<a href="https://www.root.cz/clanky/picolisp-uzitecne-funkce-a-specialni-formy-pouzivane-pri-tvorbe-aplikaci/">https://www.root.cz/clanky/picolisp-uzitecne-funkce-a-specialni-formy-pouzivane-pri-tvorbe-aplikaci/</a>
</li>

<li>PicoLisp: dokončení popisu a několik praktických rad na závěr<br />
<a href="https://www.root.cz/clanky/picolisp-dokonceni-popisu-a-nekolik-praktickych-rad-na-zaver/">https://www.root.cz/clanky/picolisp-dokonceni-popisu-a-nekolik-praktickych-rad-na-zaver/</a>
</li>

<li>GNU Guile – interpret Scheme vestavitelný do nativních aplikací<br />
<a href="https://www.root.cz/clanky/gnu-guile-interpret-scheme-vestavitelny-do-nativnich-aplikaci/">https://www.root.cz/clanky/gnu-guile-interpret-scheme-vestavitelny-do-nativnich-aplikaci/</a>
</li>

<li>TinyScheme aneb další interpret jazyka Scheme vestavitelný do dalších aplikací<br />
<a href="https://www.root.cz/clanky/tinyscheme-aneb-dalsi-interpret-jazyka-scheme-vestavitelny-do-dalsich-aplikaci/">https://www.root.cz/clanky/tinyscheme-aneb-dalsi-interpret-jazyka-scheme-vestavitelny-do-dalsich-aplikaci/</a>
</li>

<li>Kawa: překvapivě silný a výkonný dialekt Scheme pro JVM<br />
<a href="https://www.root.cz/clanky/kawa-prekvapive-silny-a-vykonny-dialekt-scheme-pro-jvm/">https://www.root.cz/clanky/kawa-prekvapive-silny-a-vykonny-dialekt-scheme-pro-jvm/</a>
</li>

<li>Jazyk Kawa v&nbsp;ekosystému virtuálního stroje Javy<br />
<a href="https://www.root.cz/clanky/jazyk-kawa-v-ekosystemu-virtualniho-stroje-javy/">https://www.root.cz/clanky/jazyk-kawa-v-ekosystemu-virtualniho-stroje-javy/</a>
</li>

<li>Zpracování vektorů, matic a N-rozměrných polí v&nbsp;programovacím jazyku Kawa<br />
<a href="https://www.root.cz/clanky/zpracovani-vektoru-matic-a-n-rozmernych-poli-v-programovacim-jazyku-kawa/">https://www.root.cz/clanky/zpracovani-vektoru-matic-a-n-rozmernych-poli-v-programovacim-jazyku-kawa/</a>
</li>

<li>Racket: programovací jazyk a současně i platforma pro vývoj nových jazyků<br />
<a href="https://www.root.cz/clanky/racket-programovaci-jazyk-a-soucasne-i-platforma-pro-vyvoj-novych-jazyku/">https://www.root.cz/clanky/racket-programovaci-jazyk-a-soucasne-i-platforma-pro-vyvoj-novych-jazyku/</a>
</li>

<li>Makra v&nbsp;Racketu i v&nbsp;dalších lispovských jazycích<br />
<a href="https://www.root.cz/clanky/makra-v-racketu-i-v-dalsich-lispovskych-jazycich/">https://www.root.cz/clanky/makra-v-racketu-i-v-dalsich-lispovskych-jazycich/</a>
</li>

<li>Základní knihovna jazyka Racket<br />
<a href="https://www.root.cz/clanky/zakladni-knihovna-jazyka-racket/">https://www.root.cz/clanky/zakladni-knihovna-jazyka-racket/</a>
</li>

<li>Jazyk Joker: dialekt Clojure naprogramovaný v&nbsp;Go<br />
<a href="https://www.root.cz/clanky/jazyk-joker-dialekt-clojure-naprogramovany-v-go/">https://www.root.cz/clanky/jazyk-joker-dialekt-clojure-naprogramovany-v-go/</a>
</li>

<li>Chicken Scheme – další interpret a především překladač programovacího jazyka Scheme<br />
<a href="https://www.root.cz/clanky/chicken-scheme-dalsi-interpret-a-predevsim-prekladac-programovaciho-jazyka-scheme/">https://www.root.cz/clanky/chicken-scheme-dalsi-interpret-a-predevsim-prekladac-programovaciho-jazyka-scheme/</a>
</li>

<li>Projekt Gambit – další kvalitní interpret i překladač programovacího jazyka Scheme<br />
<a href="https://www.root.cz/clanky/projekt-gambit-dalsi-kvalitni-interpret-i-prekladac-programovaciho-jazyka-scheme/">https://www.root.cz/clanky/projekt-gambit-dalsi-kvalitni-interpret-i-prekladac-programovaciho-jazyka-scheme/</a>
</li>

<li>Interlisp aneb oživujeme dinosaura<br />
<a href="https://www.root.cz/clanky/interlisp-aneb-ozivujeme-dinosaura/">https://www.root.cz/clanky/interlisp-aneb-ozivujeme-dinosaura/</a>
</li>

<li>Propojení světa LISPu se světem JavaScriptu s&nbsp;využitím transpřekladače Wisp<br />
<a href="https://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp/">https://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp/</a>
</li>

<li>Propojení světa LISPu se světem JavaScriptu s&nbsp;využitím transpřekladače Wisp (2.část)<br />
<a href="https://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp-2-cast/">https://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp-2-cast/</a>
</li>

</ol>

<p>Články o Elispu:</p>

<ol>

<li>Úpravy Emacsu a tvorba nových modulů s&nbsp;využitím Emacs Lispu<br />
<a href="https://www.root.cz/clanky/upravy-emacsu-a-tvorba-novych-modulu-s-vyuzitim-emacs-lispu/">https://www.root.cz/clanky/upravy-emacsu-a-tvorba-novych-modulu-s-vyuzitim-emacs-lispu/</a>
</li>

<li>Úpravy Emacsu s&nbsp;Emacs Lisp: základní konstrukce jazyka<br />
<a href="https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-zakladni-konstrukce-jazyka/">https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-zakladni-konstrukce-jazyka/</a>
</li>

<li>Úpravy Emacsu s&nbsp;Emacs Lisp: všemocné makro cl-loop a knihovna dash<br />
<a href="https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-vsemocne-makro-cl-loop-a-knihovna-dash/">https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-vsemocne-makro-cl-loop-a-knihovna-dash/</a>
</li>

<li>Úpravy Emacsu s&nbsp;Emacs Lisp: možnosti nabízené knihovnou Dash<br />
<a href="https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-moznosti-nabizene-knihovnou-dash/">https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-moznosti-nabizene-knihovnou-dash/</a>
</li>

<li>Úpravy Emacsu s&nbsp;Emacs Lisp: dokončení popisu Emacs Lispu<br />
<a href="https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-dokonceni-popisu-emacs-lispu/">https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-dokonceni-popisu-emacs-lispu/</a>
</li>

<li>Úpravy Emacsu s&nbsp;Emacs Lisp: manipulace se základními datovými strukturami Emacsu<br />
<a href="https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-manipulace-se-zakladnimi-datovymi-strukturami-emacsu/">https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-manipulace-se-zakladnimi-datovymi-strukturami-emacsu/</a>
</li>

</ol>



<p><a name="k19"></a></p>
<h2 id="k19">19. Literatura</h2>

<ol>

<li>Peter Seibel<br />
<i>&bdquo;Practical Common Lisp&ldquo;</i><br />
2009
</li>

<li>Paul Graham<br />
<i>&bdquo;ANSI Common Lisp&ldquo;</i><br />
1995
</li>

<li>Gerald Gazdar<br />
<i>&bdquo;Natural Language Processing in Lisp: An Introduction to Computational Linguistics&ldquo;</i><br />
1989
</li>

<li>Peter Norvig<br />
<i>&bdquo;Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp&ldquo;</i><br />
1991
</li>

<li>Alex Mileler et.al.<br />
<i>&bdquo;Clojure Applied: From Practice to Practitioner&ldquo;</i><br />
2015
</li>

<li>
<i>&bdquo;Living Clojure: An Introduction and Training Plan for Developers&ldquo;</i><br />
2015
</li>

<li>Dmitri Sotnikov<br />
<i>&bdquo;Web Development with Clojure: Build Bulletproof Web Apps with Less Code&ldquo;</i><br />
2016
</li>

<li>McCarthy<br />
<i>&bdquo;Recursive functions of symbolic expressions and their computation by machine, part I&ldquo;</i><br />
1960
</li>

<li>R. Kent Dybvig<br />
<i>&bdquo;The Scheme Programming Language&ldquo;</i><br />
2009
</li>

<li>Max Hailperin<br />
<i>&bdquo;Concrete Abstractions&ldquo;</i><br />
1998
</li>

<li>Guy L. Steele<br />
<i>&bdquo;History of Scheme&ldquo;</i><br />
2006, Sun Microsystems Laboratories
</li>

<li>Kolář J., Muller K.:<br />
<i>&bdquo;Speciální programovací jazyky&ldquo;</i><br />
Praha 1981
</li>

<li>
<i>&bdquo;AutoLISP Release 9, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., October 1987
</li>

<li>
<i>&bdquo;AutoLISP Release 10, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., September 1988
</li>

<li>McCarthy, John; Abrahams, Paul W.; Edwards, Daniel J.; Hart, Timothy P.; Levin, Michael I.<br />
<i>&bdquo;LISP 1.5 Programmer's Manual&ldquo;</i><br />
MIT Press. ISBN 0 262 130 1 1 4
</li>

<li>Carl Hewitt; Peter Bishop and Richard Steiger<br />
<i>&bdquo;A Universal Modular Actor Formalism for Artificial Intelligence&ldquo;</i><br />
1973
</li>

<li>Feiman, J.<br />
<i>&bdquo;The Gartner Programming Language Survey (October 2001)&ldquo;</i><br />
Gartner Advisory
</li>

<li>Harold Abelson, Gerald Jay Sussman, Julie Sussman:<br />
<i>Structure and Interpretation of Computer Programs</i><br />
MIT Press. 1985, 1996 (a možná vyšel i další přetisk)
</li>

<li>Paul Graham<br />
<i>On Lisp</i><br />
Prentice Hall, 1993<br />
Dostupné online na adrese <a href="http://www.paulgraham.com/onlisptext.html">http://www.paulgraham.com/onlisptext.html</a>
</li>

<li>David S. Touretzky<br />
<i>Common LISP: A Gentle Introduction to Symbolic Computation (Dover Books on Engineering)</i><br />
</li>

<li>Peter Norvig<br />
<i>Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp</i>
</li>

<li>Patrick Winston, Berthold Horn<br />
<i>Lisp (3rd Edition)</i><br />
ISBN-13: 978-0201083194, ISBN-10: 0201083191
</li>

<li>Matthias Felleisen, David Van Horn, Dr. Conrad Barski<br>
<i>Realm of Racket: Learn to Program, One Game at a Time!</i><br />
ISBN-13: 978-1593274917, ISBN-10: 1593274912 
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>The Evolution of Lisp<br />
<a href="https://www.csee.umbc.edu/courses/331/resources/papers/Evolution-of-Lisp.pdf">https://www.csee.umbc.edu/courses/331/resources/papers/Evolution-of-Lisp.pdf</a>
</li>

<li>LISP<br />
<a href="https://taoofmac.com/space/dev/lisp">https://taoofmac.com/space/dev/lisp</a>
</li>

<li>Repositář projektu femtolisp<br />
<a href="https://github.com/JeffBezanson/femtolisp">https://github.com/JeffBezanson/femtolisp</a>
</li>

<li>Femtolisp - lightweight, robust lisp interpreter built on reusable C libraries<br />
<a href="https://www.findbestopensource.com/product/femtolisp">https://www.findbestopensource.com/product/femtolisp</a>
</li>

<li>YCombinator: Femtolisp: A lightweight, robust, scheme-like Lisp implementation<br />
<a href="https://news.ycombinator.com/item?id=22094722">https://news.ycombinator.com/item?id=22094722</a>
</li>

<li>Learning Julia by Anshul Joshi, Rahul Lakhanpal: Femtolisp<br />
<a href="https://www.oreilly.com/library/view/learning-julia/9781785883279/2e85442f-d100-4b53-b8f7-7d20d62f0255.xhtml">https://www.oreilly.com/library/view/learning-julia/9781785883279/2e85442f-d100-4b53-b8f7-7d20d62f0255.xhtml</a>
</li>

<li>The role of femtolisp in Julia?<br />
<a href="https://discourse.julialang.org/t/the-role-of-femtolisp-in-julia/1902">https://discourse.julialang.org/t/the-role-of-femtolisp-in-julia/1902</a>
</li>

<li>LispSyntax.jl: A clojure-like lisp syntax for julia<br />
<a href="https://github.com/swadey/LispSyntax.jl">https://github.com/swadey/LispSyntax.jl</a>
</li>

<li>What exactly code lowering is an how to do “unlowering”?<br />
<a href="https://discourse.julialang.org/t/what-exactly-code-lowering-is-an-how-to-do-unlowering/1315">https://discourse.julialang.org/t/what-exactly-code-lowering-is-an-how-to-do-unlowering/1315</a>
</li>

<li>Interlisp.org: Dedicated to Restoring and Preserving the Interlisp experience<br />
<a href="https://github.com/Interlisp">https://github.com/Interlisp</a>
</li>

<li>Warren Teitelman<br />
<a href="https://en.wikipedia.org/wiki/Warren_Teitelman">https://en.wikipedia.org/wiki/Warren_Teitelman</a>
</li>

<li>InterLISP/65<br />
<a href="http://www.atarimania.com/utility-atari-400-800-xl-xe-interlisp-65_12477.html">http://www.atarimania.com/utility-atari-400-800-xl-xe-interlisp-65_12477.html</a>
</li>

<li>Lisp Editing in the 80s - Interlisp SEdit (Video)<br />
<a href="https://www.youtube.com/watch?v=2qsmF8HHskg">https://www.youtube.com/watch?v=2qsmF8HHskg</a>
</li>

<li>Inter-LISP<br />
<a href="http://www.atarimania.com/utility-atari-400-800-xl-xe-inter-lisp_29354.html">http://www.atarimania.com/utility-atari-400-800-xl-xe-inter-lisp_29354.html</a>
</li>

<li>InterLISP 65 Editing (video)<br />
<a href="https://www.youtube.com/watch?v=nY_hcazo86A">https://www.youtube.com/watch?v=nY_hcazo86A</a>
</li>

<li>Datasoft INTER-LISP/65 (Atari Age, chat)<br />
<a href="https://atariage.com/forums/topic/116093-datasoft-inter-lisp65/">https://atariage.com/forums/topic/116093-datasoft-inter-lisp65/</a>
</li>

<li>Marvin Minsky - The beauty of the Lisp language (44/151)<br />
<a href="https://www.youtube.com/watch?v=YaWVHyIBVeI">https://www.youtube.com/watch?v=YaWVHyIBVeI</a>
</li>

<li>History of LISP (Interlisp)<br />
<a href="http://www.softwarepreservation.org/projects/LISP/index.html#INTERLISP_">http://www.softwarepreservation.org/projects/LISP/index.html#INTERLISP_</a>
</li>

<li>Computer-Assisted Instruction (Bits and Bytes, Episode 7)<br />
<a href="https://www.youtube.com/watch?v=eURtTV_qKw8">https://www.youtube.com/watch?v=eURtTV_qKw8</a>
</li>

<li>Můžeme věřit překladačům? Projekty řešící schéma „důvěřivé důvěry“<br />
<a href="https://www.root.cz/clanky/muzeme-verit-prekladacum-projekty-resici-schema-duverive-duvery/">https://www.root.cz/clanky/muzeme-verit-prekladacum-projekty-resici-schema-duverive-duvery/</a>
</li>

<li>Gambit in the browser<br />
<a href="https://feeley.github.io/gambit-in-the-browser/">https://feeley.github.io/gambit-in-the-browser/</a>
</li>

<li>A Tour of Scheme in Gambit<br />
<a href="http://dynamo.iro.umontreal.ca/wiki/images/a/a7/A_Tour_of_Scheme_in_Gambit.pdf">http://dynamo.iro.umontreal.ca/wiki/images/a/a7/A_Tour_of_Scheme_in_Gambit.pdf</a>
</li>

<li>Gambit Scheme: Inside Out<br />
<a href="http://www.iro.umontreal.ca/~gambit/Gambit-inside-out.pdf">http://www.iro.umontreal.ca/~gambit/Gambit-inside-out.pdf</a>
</li>

<li>Gambit Internal Documentation<br />
<a href="http://dynamo.iro.umontreal.ca/wiki/index.php/Internal_Documentation">http://dynamo.iro.umontreal.ca/wiki/index.php/Internal_Documentation</a>
</li>

<li>clojure-scheme: Compiling to Native Code via Scheme <br />
<a href="http://www.iro.umontreal.ca/~gambit/Sorenson-Clojure-to-Native-via-Scheme.pdf">http://www.iro.umontreal.ca/~gambit/Sorenson-Clojure-to-Native-via-Scheme.pdf</a>
</li>

<li>Gauche &ndash; a Scheme implementation<br />
<a href="http://practical-scheme.net/gauche/">http://practical-scheme.net/gauche/</a>
</li>

<li>Scheme48<br />
<a href="https://s48.org/">https://s48.org/</a>
</li>

<li>SISC (Second Interpreter of Scheme)<br />
<a href="http://sisc-scheme.org/">http://sisc-scheme.org/</a>
</li>

<li>The SCM Implementation of Scheme<br />
<a href="https://people.csail.mit.edu/jaffer/SCM.html">https://people.csail.mit.edu/jaffer/SCM.html</a>
</li>

<li>Ypsilon - The ultimate script language system for the video pinball fourth generation<br />
<a href="http://www.littlewingpinball.com/doc/en/ypsilon/index.html">http://www.littlewingpinball.com/doc/en/ypsilon/index.html</a>
</li>

<li>Chicken Scheme<br />
<a href="https://call-cc.org/">https://call-cc.org/</a>
</li>

<li>Eggs Unlimited<br />
<a href="http://wiki.call-cc.org/chicken-projects/egg-index-5.html">http://wiki.call-cc.org/chicken-projects/egg-index-5.html</a>
</li>

<li>Chicken Scheme Wiki<br />
<a href="https://wiki.call-cc.org/">https://wiki.call-cc.org/</a>
</li>

<li>CHICKEN for Python programmers<br />
<a href="https://wiki.call-cc.org/chicken-for-python-programmers">https://wiki.call-cc.org/chicken-for-python-programmers</a>
</li>

<li>Programming for Performance<br />
<a href="http://wiki.call-cc.org/programming-for-performance">http://wiki.call-cc.org/programming-for-performance</a>
</li>

<li>Using the compiler<br />
<a href="https://wiki.call-cc.org/man/4/Using%20the%20compiler">https://wiki.call-cc.org/man/4/Using%20the%20compiler</a>
</li>

<li>CHICKEN Scheme tutorials<br />
<a href="https://wiki.call-cc.org/tutorials">https://wiki.call-cc.org/tutorials</a>
</li>

<li>Traditional Turtles<br />
<a href="https://docs.racket-lang.org/turtles/Traditional_Turtles.html">https://docs.racket-lang.org/turtles/Traditional_Turtles.html</a>
</li>

<li>[racket] How best to repeat a function call n times?<br />
<a href="https://lists.racket-lang.org/users/archive/2014-September/064203.html">https://lists.racket-lang.org/users/archive/2014-September/064203.html</a>
</li>

<li>Racket: Macros<br />
<a href="https://www.it.uu.se/edu/course/homepage/avfunpro/ht13/lectures/Racket-3-Macros.pdf">https://www.it.uu.se/edu/course/homepage/avfunpro/ht13/lectures/Racket-3-Macros.pdf</a>
</li>

<li>Beautiful Racket / explainers: Macros<br />
<a href="https://beautifulracket.com/explainer/macros.html">https://beautifulracket.com/explainer/macros.html</a>
</li>

<li>Macros (dokumentace k Racketu)<br />
<a href="https://docs.racket-lang.org/guide/macros.html">https://docs.racket-lang.org/guide/macros.html</a>
</li>

<li>Model syntaxe jazyka Racket<br />
<a href="https://docs.racket-lang.org/reference/syntax-model.html">https://docs.racket-lang.org/reference/syntax-model.html</a>
</li>

<li>Syntax Objects<br />
<a href="https://docs.racket-lang.org/guide/stx-obj.html">https://docs.racket-lang.org/guide/stx-obj.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Beautiful Racket: an intro­duction to language-oriented programming using Racket<br />
<a href="https://beautifulracket.com/">https://beautifulracket.com/</a>
</li>

<li>Stránky projektu Racket<br />
<a href="https://racket-lang.org/">https://racket-lang.org/</a>
</li>

<li>Dokumentace k&nbsp;projektu Racket<br />
<a href="https://docs.racket-lang.org/index.html">https://docs.racket-lang.org/index.html</a>
</li>

<li>Seznam dostupných balíčků pro Racket<br />
<a href="https://pkgs.racket-lang.org/">https://pkgs.racket-lang.org/</a>
</li>

<li>Racket na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Racket_(programming_language)">https://en.wikipedia.org/wiki/Racket_(programming_language)</a>
</li>

<li>Vector Library (R7RS-compatible)<br />
<a href="https://srfi.schemers.org/srfi-133/srfi-133.html">https://srfi.schemers.org/srfi-133/srfi-133.html</a>
</li>

<li>Blogy o Racketu a navazujících technologiích<br />
<a href="https://blog.racket-lang.org/">https://blog.racket-lang.org/</a>
</li>

<li>Prográmky psané v&nbsp;Racketu na RosettaCode<br />
<a href="http://rosettacode.org/wiki/Category:Racket">http://rosettacode.org/wiki/Category:Racket</a>
</li>

<li>Fear of Macros<br />
<a href="https://www.greghendershott.com/fear-of-macros/">https://www.greghendershott.com/fear-of-macros/</a>
</li>

<li>Rackjure<br />
<a href="https://github.com/greghendershott/rackjure">https://github.com/greghendershott/rackjure</a>
</li>

<li>Matthew Flatt’s proposal to change Racket’s s-expressions based syntax to infix representation creates a stir in the community<br />
<a href="https://hub.packtpub.com/matthew-flatts-proposal-to-change-rackets-s-expressions-based-syntax-to-infix-representation-creates-a-stir-in-the-community/">https://hub.packtpub.com/matthew-flatts-proposal-to-change-rackets-s-expressions-based-syntax-to-infix-representation-creates-a-stir-in-the-community/</a>
</li>

<li>Racket News<br />
<a href="https://racket-news.com/">https://racket-news.com/</a>
</li>

<li>Racket: Lisp for learning<br />
<a href="https://lwn.net/Articles/795385/">https://lwn.net/Articles/795385/</a>
</li>

<li>Future of Racket<br />
<a href="https://www.greghendershott.com/2019/07/future-of-racket.html">https://www.greghendershott.com/2019/07/future-of-racket.html</a>
</li>

<li>Vectors (pro Gauche)<br />
<a href="https://practical-scheme.net/gauche/man/gauche-refe/Vectors.html">https://practical-scheme.net/gauche/man/gauche-refe/Vectors.html</a>
</li>

<li>Kawa: Compiling Scheme to Java<br />
<a href="https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html">https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html</a>
</li>

<li>Kawa in Languages shootout<br />
<a href="http://per.bothner.com/blog/2010/Kawa-in-shootout/">http://per.bothner.com/blog/2010/Kawa-in-shootout/</a>
</li>

<li>Kawa 2.0 Supports Scheme R7RS<br />
<a href="https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/">https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/</a>
</li>

<li>Kawa — fast scripting on the Java platform<br />
<a href="https://lwn.net/Articles/623349/">https://lwn.net/Articles/623349/</a>
</li>

<li>Tail call (a její optimalizace)<br />
<a href="https://en.wikipedia.org/wiki/Tail_call">https://en.wikipedia.org/wiki/Tail_call</a>
</li>

<li>SLIME (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/SLIME">http://en.wikipedia.org/wiki/SLIME</a>
</li>

<li>slime.vim<br />
<a href="http://s3.amazonaws.com/mps/slime.vim">http://s3.amazonaws.com/mps/slime.vim</a>
</li>

<li>What are the best scheme implementations?<br />
<a href="https://www.slant.co/topics/5282/~scheme-implementations">https://www.slant.co/topics/5282/~scheme-implementations</a>
</li>

<li>Bigloo homepage<br />
<a href="http://www-sop.inria.fr/mimosa/fp/Bigloo/">http://www-sop.inria.fr/mimosa/fp/Bigloo/</a>
</li>

<li>FTP s tarbally Bigloo<br />
<a href="ftp://ftp-sop.inria.fr/indes/fp/Bigloo">ftp://ftp-sop.inria.fr/indes/fp/Bigloo</a>
</li>

<li>GOTO 2018 • Functional Programming in 40 Minutes • Russ Olsen<br />
<a href="https://www.youtube.com/watch?v=0if71HOyVjY">https://www.youtube.com/watch?v=0if71HOyVjY</a>
</li>

<li>TinyScheme (stránka na Sourceforge)<br />
<a href="http://tinyscheme.sourceforge.net/home.html">http://tinyscheme.sourceforge.net/home.html</a>
</li>

<li>Embedding Tiny Scheme in a Game<br />
<a href="http://www.silicondelight.com/embedding-tiny-scheme-in-a-game/">http://www.silicondelight.com/embedding-tiny-scheme-in-a-game/</a>
</li>

<li>Embedding Scheme for a game mission scripting DSL<br />
<a href="http://carloscarrasco.com/embedding-scheme-for-a-game-mission-scripting-dsl.html">http://carloscarrasco.com/embedding-scheme-for-a-game-mission-scripting-dsl.html</a>
</li>

<li>Všechny verze TinyScheme na SourceForge<br />
<a href="https://sourceforge.net/projects/tinyscheme/files/tinyscheme/">https://sourceforge.net/projects/tinyscheme/files/tinyscheme/</a>
</li>

<li>Fork TinyScheme na GitHubu<br />
<a href="https://github.com/yawnt/tinyscheme">https://github.com/yawnt/tinyscheme</a>
</li>

<li>Ackermannova funkce<br />
<a href="https://cs.wikipedia.org/wiki/Ackermannova_funkce">https://cs.wikipedia.org/wiki/Ackermannova_funkce</a>
</li>

<li>Ackermann function na Rosetta Code<br />
<a href="https://rosettacode.org/wiki/Ackermann_function#Scheme">https://rosettacode.org/wiki/Ackermann_function#Scheme</a>
</li>

<li>Success Stories (lisp.org)<br />
<a href="https://lisp-lang.org/success/">https://lisp-lang.org/success/</a>
</li>

<li>Allegro Common Lisp Success Stories<br />
<a href="https://franz.com/success/">https://franz.com/success/</a>
</li>

<li>Clojure Success Stories<br />
<a href="https://clojure.org/community/success_stories">https://clojure.org/community/success_stories</a>
</li>

<li>Scheme Quick Reference<br />
<a href="https://www.st.cs.uni-saarland.de/edu/config-ss04/scheme-quickref.pdf">https://www.st.cs.uni-saarland.de/edu/config-ss04/scheme-quickref.pdf</a>
</li>

<li>Slajdy o Scheme (od slajdu číslo 15)<br />
<a href="https://docs.google.com/presentation/d/1abmDnKjrq1tcjGvvRNAKhOiSTSE2lyagtcEPal07Gbo/edit">https://docs.google.com/presentation/d/1abmDnKjrq1tcjGvvRNAKhOiSTSE2lyagtcEPal07Gbo/edit</a>
</li>

<li>Scheme Cheat Sheet<br />
<a href="https://github.com/smythp/scheme-cheat-sheet">https://github.com/smythp/scheme-cheat-sheet</a>
</li>

<li>Embedding Lua, embedding Guile <br />
<a href="http://puntoblogspot.blogspot.com/2013/04/embedding-lua-embedding-guile.html">http://puntoblogspot.blogspot.com/2013/04/embedding-lua-embedding-guile.html</a>
</li>

<li>Lambda Papers<br />
<a href="https://en.wikisource.org/wiki/Lambda_Papers">https://en.wikisource.org/wiki/Lambda_Papers</a>
</li>

<li>Revised<sup>7</sup>Report on the Algorithmic Language Scheme<br />
<a href="https://small.r7rs.org/attachment/r7rs.pdf">https://small.r7rs.org/attachment/r7rs.pdf</a>
</li>

<li>Video Lectures (MIT, SICP 2005)<br />
<a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/</a>
</li>

<li>Why is Scheme my first language in university?<br />
<a href="https://softwareengineering.stackexchange.com/questions/115252/why-is-scheme-my-first-language-in-university">https://softwareengineering.stackexchange.com/questions/115252/why-is-scheme-my-first-language-in-university</a>
</li>

<li>The Perils of JavaSchools<br />
<a href="https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/">https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/</a>
</li>

<li>How to Design Programs, Second Edition<br />
<a href="https://htdp.org/2019-02-24/index.html">https://htdp.org/2019-02-24/index.html</a>
</li>

<li>LilyPond<br />
<a href="http://lilypond.org/">http://lilypond.org/</a>
</li>

<li>LilyPond — Extending (přes Scheme)<br />
<a href="http://lilypond.org/doc/v2.18/Documentation/extending/scheme-tutorial">http://lilypond.org/doc/v2.18/Documentation/extending/scheme-tutorial</a>
</li>

<li>Scheme in LilyPond<br />
<a href="http://lilypond.org/doc/v2.18/Documentation/extending/scheme-in-lilypond">http://lilypond.org/doc/v2.18/Documentation/extending/scheme-in-lilypond</a>
</li>

<li>GnuCash<br />
<a href="http://www.gnucash.org/">http://www.gnucash.org/</a>
</li>

<li>Custom Reports (in GNU Cash)<br />
<a href="https://wiki.gnucash.org/wiki/Custom_Reports">https://wiki.gnucash.org/wiki/Custom_Reports</a>
</li>

<li>Program by Design<br />
<a href="https://programbydesign.org/">https://programbydesign.org/</a>
</li>

<li>SchemePy<br />
<a href="https://pypi.org/project/SchemePy/">https://pypi.org/project/SchemePy/</a>
</li>

<li>LISP FQA: Section - [1-5] What is the "minimal" set of primitives needed for a Lisp interpreter?<br />
<a href="http://www.faqs.org/faqs/lisp-faq/part1/section-6.html">http://www.faqs.org/faqs/lisp-faq/part1/section-6.html</a>
</li>

<li>femtolisp<br />
<a href="https://github.com/JeffBezanson/femtolisp">https://github.com/JeffBezanson/femtolisp</a>
</li>

<li>(How to Write a (Lisp) Interpreter (in Python))<br />
<a href="http://norvig.com/lispy.html">http://norvig.com/lispy.html</a>
</li>

<li>Repositář s&nbsp;Guile Emacsem<br />
<a href="http://git.hcoop.net/?p=bpt/guile.git">http://git.hcoop.net/?p=bpt/guile.git</a>
</li>

<li>Interacting with Guile Compound Data Types in C<br />
<a href="http://www.lonelycactus.com/guilebook/x1555.html">http://www.lonelycactus.com/guilebook/x1555.html</a>
</li>

<li>Calling Guile functions from C<br />
<a href="http://www.lonelycactus.com/guilebook/c1204.html#SECCALLGUILEFUNC">http://www.lonelycactus.com/guilebook/c1204.html#SECCALLGUILEFUNC</a>
</li>

<li>Arrays, and other compound data types<br />
<a href="http://www.lonelycactus.com/guilebook/charrays.html">http://www.lonelycactus.com/guilebook/charrays.html</a>
</li>

<li>Interacting with Guile Compound Data Types in C<br />
<a href="http://www.lonelycactus.com/guilebook/x1555.html">http://www.lonelycactus.com/guilebook/x1555.html</a>
</li>

<li>Guile Reference Manual<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/index.html">https://www.gnu.org/software/guile/manual/html_node/index.html</a>
</li>

<li>Scheme: Summary of Common Syntax<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/Syntax-Summary.html#Syntax-Summary">https://www.gnu.org/software/guile/manual/html_node/Syntax-Summary.html#Syntax-Summary</a>
</li>

<li>Scripting with Guile: Extension language enhances C and Scheme<br />
<a href="https://www.ibm.com/developerworks/library/l-guile/index.html">https://www.ibm.com/developerworks/library/l-guile/index.html</a>
</li>

<li>Having fun with Guile: a tutorial<br />
<a href="http://dustycloud.org/misc/guile-tutorial.html">http://dustycloud.org/misc/guile-tutorial.html</a>
</li>

<li>Guile: Loading Readline Support<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/Loading-Readline-Support.html#Loading-Readline-Support">https://www.gnu.org/software/guile/manual/html_node/Loading-Readline-Support.html#Loading-Readline-Support</a>
</li>

<li>lispy<br />
<a href="https://pypi.org/project/lispy/">https://pypi.org/project/lispy/</a>
</li>

<li>Lython<br />
<a href="https://pypi.org/project/Lython/">https://pypi.org/project/Lython/</a>
</li>

<li>Lizpop<br />
<a href="https://pypi.org/project/lizpop/">https://pypi.org/project/lizpop/</a>
</li>

<li>Budoucnost programovacích jazyků<br />
<a href="http://www.knesl.com/budoucnost-programovacich-jazyku">http://www.knesl.com/budoucnost-programovacich-jazyku</a>
</li>

<li>LISP Prolog and Evolution<br />
<a href="http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html">http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html</a>
</li>

<li>List of Lisp-family programming languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages">https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages</a>
</li>

<li>clojure_py na indexu PyPi<br />
<a href="https://pypi.python.org/pypi/clojure_py">https://pypi.python.org/pypi/clojure_py</a>
</li>

<li>PyClojure<br />
<a href="https://github.com/eigenhombre/PyClojure">https://github.com/eigenhombre/PyClojure</a>
</li>

<li>Hy na GitHubu<br />
<a href="https://github.com/hylang/hy">https://github.com/hylang/hy</a>
</li>

<li>Hy: The survival guide<br />
<a href="https://notes.pault.ag/hy-survival-guide/">https://notes.pault.ag/hy-survival-guide/</a>
</li>

<li>Hy běžící na monitoru terminálu společnosti Symbolics<br />
<a href="http://try-hy.appspot.com/">http://try-hy.appspot.com/</a>
</li>

<li>Welcome to Hy’s documentation!<br />
<a href="http://docs.hylang.org/en/stable/">http://docs.hylang.org/en/stable/</a>
</li>

<li>Hy na PyPi<br />
<a href="https://pypi.org/project/hy/#description">https://pypi.org/project/hy/#description</a>
</li>

<li>Getting Hy on Python<br />
<a href="https://lwn.net/Articles/596626/">https://lwn.net/Articles/596626/</a>
</li>

<li>Programming Can Be Fun with Hy<br />
<a href="https://opensourceforu.com/2014/02/programming-can-fun-hy/">https://opensourceforu.com/2014/02/programming-can-fun-hy/</a>
</li>

<li>Přednáška o projektu Hy (pětiminutový lighttalk)<br />
<a href="http://blog.pault.ag/day/2013/04/02">http://blog.pault.ag/day/2013/04/02</a>
</li>

<li>Hy (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Hy">https://en.wikipedia.org/wiki/Hy</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Point<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Point.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Point.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Narrowing<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Narrowing.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Narrowing.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Functions that Create Markers<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Markers.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Markers.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Motion<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Motion.html#Motion">https://www.gnu.org/software/emacs/manual/html_node/elisp/Motion.html#Motion</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Basic Char Syntax<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Char-Syntax.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Char-Syntax.html</a>
</li>

<li>Elisp: Sequence: List, Array<br />
<a href="http://ergoemacs.org/emacs/elisp_list_vs_vector.html">http://ergoemacs.org/emacs/elisp_list_vs_vector.html</a>
</li>

<li>Elisp: Property List<br />
<a href="http://ergoemacs.org/emacs/elisp_property_list.html">http://ergoemacs.org/emacs/elisp_property_list.html</a>
</li>

<li>Elisp: Hash Table<br />
<a href="http://ergoemacs.org/emacs/elisp_hash_table.html">http://ergoemacs.org/emacs/elisp_hash_table.html</a>
</li>

<li>Elisp: Association List<br />
<a href="http://ergoemacs.org/emacs/elisp_association_list.html">http://ergoemacs.org/emacs/elisp_association_list.html</a>
</li>

<li>The mapcar Function (An Introduction to Programming in Emacs Lisp)<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/mapcar.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/mapcar.html</a>
</li>

<li>Anaphoric macro<br />
<a href="https://en.wikipedia.org/wiki/Anaphoric_macro">https://en.wikipedia.org/wiki/Anaphoric_macro</a>
</li>

<li>Some Common Lisp Loop Macro Examples<br />
<a href="https://www.youtube.com/watch?v=3yl8o6r_omw">https://www.youtube.com/watch?v=3yl8o6r_omw</a>
</li>

<li>A Guided Tour of Emacs<br />
<a href="https://www.gnu.org/software/emacs/tour/">https://www.gnu.org/software/emacs/tour/</a>
</li>

<li>The Roots of Lisp<br />
<a href="http://www.paulgraham.com/rootsoflisp.html">http://www.paulgraham.com/rootsoflisp.html</a>
</li>

<li>Evil (Emacs Wiki)<br />
<a href="https://www.emacswiki.org/emacs/Evil">https://www.emacswiki.org/emacs/Evil</a>
</li>

<li>Evil (na GitHubu)<br />
<a href="https://github.com/emacs-evil/evil">https://github.com/emacs-evil/evil</a>
</li>

<li>Evil (na stránkách repositáře MELPA)<br />
<a href="https://melpa.org/#/evil">https://melpa.org/#/evil</a>
</li>

<li>Evil Mode: How I Switched From VIM to Emacs<br />
<a href="https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html">https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html</a>
</li>

<li>GNU Emacs (home page)<br />
<a href="https://www.gnu.org/software/emacs/">https://www.gnu.org/software/emacs/</a>
</li>

<li>GNU Emacs (texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs">http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs</a>
</li>

<li>An Introduction To Using GDB Under Emacs<br />
<a href="http://tedlab.mit.edu/~dr/gdbintro.html">http://tedlab.mit.edu/~dr/gdbintro.html</a>
</li>

<li>An Introduction to Programming in Emacs Lisp<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html</a>
</li>

<li>27.6 Running Debuggers Under Emacs<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html">https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html</a>
</li>

<li>GdbMode<br />
<a href="http://www.emacswiki.org/emacs/GdbMode">http://www.emacswiki.org/emacs/GdbMode</a>
</li>

<li>Emacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Emacs">https://en.wikipedia.org/wiki/Emacs</a>
</li>

<li>Emacs timeline<br />
<a href="http://www.jwz.org/doc/emacs-timeline.html">http://www.jwz.org/doc/emacs-timeline.html</a>
</li>

<li>Emacs Text Editors Family<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?EmacsFamily">http://texteditors.org/cgi-bin/wiki.pl?EmacsFamily</a>
</li>

<li>Vrapper aneb spojení možností Vimu a Eclipse<br />
<a href="https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse/">https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse/</a>
</li>

<li>Vrapper aneb spojení možností Vimu a Eclipse (část 2: vyhledávání a nahrazování textu)<br />
<a href="https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse-cast-2-vyhledavani-a-nahrazovani-textu/">https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse-cast-2-vyhledavani-a-nahrazovani-textu/</a>
</li>

<li>Emacs/Evil-mode - A basic reference to using evil mode in Emacs<br />
<a href="http://www.aakarshnair.com/posts/emacs-evil-mode-cheatsheet">http://www.aakarshnair.com/posts/emacs-evil-mode-cheatsheet</a>
</li>

<li>From Vim to Emacs+Evil chaotic migration guide<br />
<a href="https://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/">https://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/</a>
</li>

<li>Introduction to evil-mode {video)<br />
<a href="https://www.youtube.com/watch?v=PeVQwYUxYEg">https://www.youtube.com/watch?v=PeVQwYUxYEg</a>
</li>

<li>EINE (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/EINE">http://www.emacswiki.org/emacs/EINE</a>
</li>

<li>EINE (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?EINE">http://texteditors.org/cgi-bin/wiki.pl?EINE</a>
</li>

<li>ZWEI (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/ZWEI">http://www.emacswiki.org/emacs/ZWEI</a>
</li>

<li>ZWEI (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?ZWEI">http://texteditors.org/cgi-bin/wiki.pl?ZWEI</a>
</li>

<li>Zmacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Zmacs">https://en.wikipedia.org/wiki/Zmacs</a>
</li>

<li>Zmacs (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?Zmacs">http://texteditors.org/cgi-bin/wiki.pl?Zmacs</a>
</li>

<li>TecoEmacs (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/TecoEmacs">http://www.emacswiki.org/emacs/TecoEmacs</a>
</li>

<li>Micro Emacs<br />
<a href="http://www.emacswiki.org/emacs/MicroEmacs">http://www.emacswiki.org/emacs/MicroEmacs</a>
</li>

<li>Micro Emacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/MicroEMACS">https://en.wikipedia.org/wiki/MicroEMACS</a>
</li>

<li>EmacsHistory<br />
<a href="http://www.emacswiki.org/emacs/EmacsHistory">http://www.emacswiki.org/emacs/EmacsHistory</a>
</li>

<li>Seznam editorů s ovládáním podobným Emacsu či kompatibilních s příkazy Emacsu<br />
<a href="http://www.finseth.com/emacs.html">http://www.finseth.com/emacs.html</a>
</li>

<li>evil-numbers<br />
<a href="https://github.com/cofi/evil-numbers">https://github.com/cofi/evil-numbers</a>
</li>

<li>Debuggery a jejich nadstavby v&nbsp;Linuxu (1.část)<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/</a>
</li>

<li>Debuggery a jejich nadstavby v&nbsp;Linuxu (2.část)<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (3): Nemiver<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (4): KDbg<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (5): ladění aplikací v editorech Emacs a Vim<br />
<a href="https://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">https://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/</a>
</li>

<li>Org mode<br />
<a href="https://orgmode.org/">https://orgmode.org/</a>
</li>

<li>The Org Manual<br />
<a href="https://orgmode.org/manual/index.html">https://orgmode.org/manual/index.html</a>
</li>

<li>Kakoune (modální textový editor)<br />
<a href="http://kakoune.org/">http://kakoune.org/</a>
</li>

<li>Vim-style keybinding in Emacs/Evil-mode<br />
<a href="https://gist.github.com/troyp/6b4c9e1c8670200c04c16036805773d8">https://gist.github.com/troyp/6b4c9e1c8670200c04c16036805773d8</a>
</li>

<li>Emacs - jak začít<br />
<a href="http://www.abclinuxu.cz/clanky/navody/emacs-jak-zacit">http://www.abclinuxu.cz/clanky/navody/emacs-jak-zacit</a>
</li>

<li>Programovací jazyk LISP a LISP machines<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-lisp-a-lisp-machines/">https://www.root.cz/clanky/programovaci-jazyk-lisp-a-lisp-machines/</a>
</li>

<li>Evil-surround<br />
<a href="https://github.com/emacs-evil/evil-surround">https://github.com/emacs-evil/evil-surround</a>
</li>

<li>Spacemacs<br />
<a href="http://spacemacs.org/">http://spacemacs.org/</a>
</li>

<li>Lisp: Common Lisp, Racket, Clojure, Emacs Lisp<br />
<a href="http://hyperpolyglot.org/lisp">http://hyperpolyglot.org/lisp</a>
</li>

<li>Common Lisp, Scheme, Clojure, And Elisp Compared<br />
<a href="http://irreal.org/blog/?p=725">http://irreal.org/blog/?p=725</a>
</li>

<li>Does Elisp Suck?<br />
<a href="http://irreal.org/blog/?p=675">http://irreal.org/blog/?p=675</a>
</li>

<li>Emacs pro mírně pokročilé (9): Elisp<br />
<a href="https://www.root.cz/clanky/emacs-elisp/">https://www.root.cz/clanky/emacs-elisp/</a>
</li>

<li>If I want to learn lisp, are emacs and elisp a good choice?<br />
<a href="https://www.reddit.com/r/emacs/comments/2m141y/if_i_want_to_learn_lisp_are_emacs_and_elisp_a/">https://www.reddit.com/r/emacs/comments/2m141y/if_i_want_to_learn_lisp_are_emacs_and_elisp_a/</a>
</li>

<li>Clojure(Script) Interactive Development Environment that Rocks!<br />
<a href="https://github.com/clojure-emacs/cider">https://github.com/clojure-emacs/cider</a>
</li>

<li>An Introduction to Emacs Lisp<br />
<a href="https://harryrschwartz.com/2014/04/08/an-introduction-to-emacs-lisp.html">https://harryrschwartz.com/2014/04/08/an-introduction-to-emacs-lisp.html</a>
</li>

<li>Emergency Elisp<br />
<a href="http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html">http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html</a>
</li>

<li>Lambda calculus<br />
<a href="https://en.wikipedia.org/wiki/Lambda_calculus">https://en.wikipedia.org/wiki/Lambda_calculus</a>
</li>

<li>John McCarthy's original LISP paper from 1959<br />
<a href="https://www.reddit.com/r/programming/comments/17lpz4/john_mccarthys_original_lisp_paper_from_1959/">https://www.reddit.com/r/programming/comments/17lpz4/john_mccarthys_original_lisp_paper_from_1959/</a>
</li>

<li>Micro Manual LISP<br />
<a href="https://www.scribd.com/document/54050141/Micro-Manual-LISP">https://www.scribd.com/document/54050141/Micro-Manual-LISP</a>
</li>

<li>How Lisp Became God's Own Programming Language<br />
<a href="https://twobithistory.org/2018/10/14/lisp.html">https://twobithistory.org/2018/10/14/lisp.html</a>
</li>

<li>History of Lisp<br />
<a href="http://jmc.stanford.edu/articles/lisp/lisp.pdf">http://jmc.stanford.edu/articles/lisp/lisp.pdf</a>
</li>

<li>The Roots of Lisp<br />
<a href="http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf">http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf</a>
</li>

<li>Racket<br />
<a href="https://racket-lang.org/">https://racket-lang.org/</a>
</li>

<li>The Racket Manifesto<br />
<a href="http://felleisen.org/matthias/manifesto/">http://felleisen.org/matthias/manifesto/</a>
</li>

<li>MIT replaces Scheme with Python<br />
<a href="https://www.johndcook.com/blog/2009/03/26/mit-replaces-scheme-with-python/">https://www.johndcook.com/blog/2009/03/26/mit-replaces-scheme-with-python/</a>
</li>

<li>Adventures in Advanced Symbolic Programming<br />
<a href="http://groups.csail.mit.edu/mac/users/gjs/6.945/">http://groups.csail.mit.edu/mac/users/gjs/6.945/</a>
</li>

<li>Why MIT Switched from Scheme to Python (2009)<br />
<a href="https://news.ycombinator.com/item?id=14167453">https://news.ycombinator.com/item?id=14167453</a>
</li>

<li>Starodávná stránka XLispu<br />
<a href="http://www.xlisp.org/">http://www.xlisp.org/</a>
</li>

<li>AutoLISP<br />
<a href="https://en.wikipedia.org/wiki/AutoLISP">https://en.wikipedia.org/wiki/AutoLISP</a>
</li>

<li>Seriál PicoLisp: minimalistický a výkonný interpret Lispu<br />
<a href="https://www.root.cz/serialy/picolisp-minimalisticky-a-vykonny-interpret-lispu/">https://www.root.cz/serialy/picolisp-minimalisticky-a-vykonny-interpret-lispu/</a>
</li>

<li>Common Lisp<br />
<a href="https://common-lisp.net/">https://common-lisp.net/</a>
</li>

<li>Getting Going with Common Lisp<br />
<a href="https://cliki.net/Getting%20Started">https://cliki.net/Getting%20Started</a>
</li>

<li>Online Tutorial (Common Lisp)<br />
<a href="https://cliki.net/online%20tutorial">https://cliki.net/online%20tutorial</a>
</li>

<li>Guile Emacs<br />
<a href="https://www.emacswiki.org/emacs/GuileEmacs">https://www.emacswiki.org/emacs/GuileEmacs</a>
</li>

<li>Guile Emacs History<br />
<a href="https://www.emacswiki.org/emacs/GuileEmacsHistory">https://www.emacswiki.org/emacs/GuileEmacsHistory</a>
</li>

<li>Guile is a programming language<br />
<a href="https://www.gnu.org/software/guile/">https://www.gnu.org/software/guile/</a>
</li>

<li>MIT Scheme<br />
<a href="http://groups.csail.mit.edu/mac/projects/scheme/">http://groups.csail.mit.edu/mac/projects/scheme/</a>
</li>

<li>SIOD: Scheme in One Defun<br />
<a href="http://people.delphiforums.com/gjc//siod.html">http://people.delphiforums.com/gjc//siod.html</a>
</li>

<li>CommonLispForEmacs<br />
<a href="https://www.emacswiki.org/emacs/CommonLispForEmacs">https://www.emacswiki.org/emacs/CommonLispForEmacs</a>
</li>

<li>Elisp: print, princ, prin1, format, message<br />
<a href="http://ergoemacs.org/emacs/elisp_printing.html">http://ergoemacs.org/emacs/elisp_printing.html</a>
</li>

<li>Special Forms in Lisp<br />
<a href="http://www.nhplace.com/kent/Papers/Special-Forms.html">http://www.nhplace.com/kent/Papers/Special-Forms.html</a>
</li>

<li>Basic Building Blocks in LISP<br />
<a href="https://www.tutorialspoint.com/lisp/lisp_basic_syntax.htm">https://www.tutorialspoint.com/lisp/lisp_basic_syntax.htm</a>
</li>

<li>Introduction to LISP - University of Pittsburgh<br />
<a href="https://people.cs.pitt.edu/~milos/courses/cs2740/Lectures/LispTutorial.pdf">https://people.cs.pitt.edu/~milos/courses/cs2740/Lectures/LispTutorial.pdf</a>
</li>

<li>Why don't people use LISP<br />
<a href="https://forums.freebsd.org/threads/why-dont-people-use-lisp.24572/">https://forums.freebsd.org/threads/why-dont-people-use-lisp.24572/</a>
</li>

<li>Structured program theorem<br />
<a href="https://en.wikipedia.org/wiki/Structured_program_theorem">https://en.wikipedia.org/wiki/Structured_program_theorem</a>
</li>

<li>Clojure: API Documentation<br />
<a href="https://clojure.org/api/api">https://clojure.org/api/api</a>
</li>

<li>Tutorial for the Common Lisp Loop Macro<br />
<a href="http://www.ai.sri.com/pkarp/loop.html">http://www.ai.sri.com/pkarp/loop.html</a>
</li>

<li>Common Lisp's Loop Macro Examples for Beginners<br />
<a href="http://www.unixuser.org/~euske/doc/cl/loop.html">http://www.unixuser.org/~euske/doc/cl/loop.html</a>
</li>

<li>A modern list api for Emacs. No 'cl required.<br />
<a href="https://github.com/magnars/dash.el">https://github.com/magnars/dash.el</a>
</li>

<li>The LOOP Facility<br />
<a href="http://www.lispworks.com/documentation/HyperSpec/Body/06_a.htm">http://www.lispworks.com/documentation/HyperSpec/Body/06_a.htm</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>Transient Data Structures
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Jazyky Hy a Clojure-py: moderní dialekty LISPu určené pro Python VM<br />
<a href="https://www.root.cz/clanky/jazyky-hy-a-clojure-py-moderni-dialekty-lispu-urcene-pro-python-vm/">https://www.root.cz/clanky/jazyky-hy-a-clojure-py-moderni-dialekty-lispu-urcene-pro-python-vm/</a>
</li>

<li>Pixie: lehký skriptovací jazyk s „kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

<li>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/">https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/</a>
</li>

<li>Stránka projektu Jython<br />
<a href="http://www.jython.org/">http://www.jython.org/</a>
</li>

<li>Jython (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Jython">https://en.wikipedia.org/wiki/Jython</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">https://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>JSR 223: Scripting for the Java<sup>TM</sup> Platform<br />
<a href="https://jcp.org/en/jsr/detail?id=223">https://jcp.org/en/jsr/detail?id=223</a>
</li>

<li>List of JVM languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_JVM_languages">https://en.wikipedia.org/wiki/List_of_JVM_languages</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>Economy Size Geek - Interview with Rich Hickey, Creator of Clojure<br />
<a href="https://www.linuxjournal.com/article/10708">https://www.linuxjournal.com/article/10708</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

