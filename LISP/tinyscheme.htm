<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>TinyScheme aneb další interpret jazyka Scheme vestavitelný do dalších aplikací</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>TinyScheme aneb další interpret jazyka Scheme vestavitelný do dalších aplikací</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. TinyScheme aneb další interpret jazyka Scheme vestavitelný do dalších aplikací</a></p>
<p><a href="#k02">2. Základní vlastnosti TinyScheme</a></p>
<p><a href="#k03">3. Získání zdrojových kódů a překlad TinyScheme</a></p>
<p><a href="#k04">4. Překlad bez podpory datového typu <i>double</i></a></p>
<p><a href="#k05">5. Soubor <strong>init.scm</strong></a></p>
<p><a href="#k06">6. Rekurze</a></p>
<p><a href="#k07">7. Programová smyčka typu <strong>do</strong></a></p>
<p><a href="#k08">8. Rozhraní mezi TinyScheme a nativními aplikacemi</a></p>
<p><a href="#k09">9. Inicializace interpretru Scheme a spuštění skriptu</a></p>
<p><a href="#k10">10. Úplný zdrojový kód prvního příkladu</a></p>
<p><a href="#k11">*** 11. Překlad prvního příkladu</a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">17. Jaký interpret použít pro implementaci DSL?</a></p>
<p><a href="#k18">*** 18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Literatura</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. TinyScheme aneb další interpret jazyka Scheme vestavitelný do dalších aplikací</h2>

<p><a
href="https://www.root.cz/clanky/gnu-guile-interpret-scheme-vestavitelny-do-nativnich-aplikaci/">Ve
druhé části</a> miniseriálu o různých interpretrech a překladačích
programovacích jazyků <a href="https://www.root.cz/n/lisp/">LISP</a> a Scheme
jsme si ukázali některé možnosti nabízené projektem GNU Guile. Připomeňme si ve
stručnosti, že se jedná o interpret kombinovaný s&nbsp;překladačem
programovacího jazyka Scheme, který lze využít jak samostatně (příkazem
<strong>guile</strong> se spustí interaktivní smyčka REPL) nebo je možné GNU
Guile vložit do dalších aplikací a použít tak Scheme jako skriptovací jazyk
rozšiřující možnosti vybrané aplikace a umožňující například tvorbu pluginů (ze
známých aplikací je tato idea asi nejvíce dotažena ve slavném <a
href="https://www.root.cz/n/emacs/">Emacsu</a>, který se rozšiřuje skripty
psanými v&nbsp;Emacs Lispu a i velká část samotného Emacsu je psána
v&nbsp;tomtéž programovacím jazyce).</p>

<p>Podobným způsobem je koncipován i projekt <i>TinyScheme</i>, s&nbsp;nímž se
seznámíme dnes. Název <i>TinyScheme</i> je poměrně přiléhavý, protože samotný
interpret (pochopitelně i s&nbsp;automatickým správcem paměti) je možné
přeložit do spustitelného souboru, který má po odstranění ladicích symbolů
velikost pouhých 66 kilobajtů, což je méně, než u programovacího jazyka Lua,
jehož interpret má na stejné architektuře velikost přes 150 kilobajtů (ovšem
toto porovnání není úplně férové, protože by bylo nutné porovnat i všechny
funkce ze základních knihoven). Navíc je možné <i>TinyScheme</i> vložit přímo
do vyvíjené aplikace, přičemž je umožněno podle požadavků vývojářů využít
statickou knihovnu (ta se slinkuje přímo do vyvíjené aplikace) či knihovnu
dynamickou (bude se načítat až po spuštění a inicializaci aplikace). Při
překladu <i>TinyScheme</i> lze navíc zvolit, které vlastnosti má výsledný
interpret mít; například lze zcela odstranit práci s&nbsp;hodnotami typu
<i>double</i> a zjednodušit tak nasazení na architekturách bez matematického
koprocesoru.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Základní vlastnosti TinyScheme</h2>

<p>O projektu <i>TinyScheme</i> jsme si <a href="#k01">v&nbsp;úvodní
kapitole</a> řekli, že se jedná  o jednu z&nbsp;mnoha implementací
programovacího jazyka Scheme. Ovšem co je tím myšleno v&nbsp;kontextu
LISPovského jazyka? Již víme, že LISP (a tím pádem i jeho derivát Scheme) je
dobré chápat spíše jako koncept, než jako konkrétní specifikaci, i když
například existuje ANSI norma LISPu (<a href="https://common-lisp.net/">Common
Lisp</a>). V&nbsp;případě některé implementace jazyka Scheme se tedy musíme
spíše dívat na to, které konkrétní vlastnosti specifikované (mnohdy ovšem
poměrně vágně) v&nbsp;RnRS jsou implementovány a které naopak nikoli;
samozřejmě s&nbsp;tím důležitým dodatkem, že mnohé vlastnosti lze relativně
snadno do již existujícího interpretru dodat dalšími funkcemi a makry (což je
konkrétně příklad speciální formy <strong>do</strong>, která je
v&nbsp;<i>TinyScheme</i> implementována jako makro v&nbsp;souboru
<strong>init.scm</strong>).</p>

<p>Mezi základní datové typy podporované interpretrem <i>TinyScheme</i> patří
především:</p>

<table>
<tr><th>#</th><th>Typ</th><th>Poznámka</th></tr>
<tr><td>1</td><td>Number</td><td>celá čísla jsou podporována vždy, podpora reálných čísel při USE_MATH=1</td></tr>
<tr><td>2</td><td>Symbol</td><td>podpora pro převod na řetězec i naopak</td></tr>
<tr><td>3</td><td>Pair</td><td>(tečka.dvojice)</td></tr>
<tr><td>4</td><td>String</td><td>může obsahovat i konec řádků (ukončení řetězce na dalším řádku)</td></tr>
<tr><td>5</td><td>Character</td><td>včetně řídicích znaků #\newline, #\tab atd.</td></tr>
<tr><td>6</td><td>Port</td><td>podle R5RS, bude podrobněji vysvětleno příště</td></tr>
<tr><td>7</td><td>Eof</td><td>podle R5RS, bude podrobněji vysvětleno příště</td></tr>
<tr><td>8</td><td>Environment</td><td></td></tr>
<tr><td>9</td><td>List</td><td>vytvářen běžným způsobem &ndash; rekurzivní sekvence tečka-dvojic</td></tr>
<tr><td>10</td><td>Vector</td><td>včetně všech základních podpůrných funkcí</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti nejsme omezeni pouze na
řetězce používající kódování ASCII. Pokud je korektně nastaven terminál, lze
využít i plnohodnotné UTF-8, protože interně <i>TinyScheme</i> s&nbsp;řetězci
zachází jako s&nbsp;céčkovými stringy a základní funkce tedy dokážou pracovat i
s&nbsp;UTF-8.</div></p>

<p>Při zápisu jednotlivých znaků je možné použít buď přímo ASCII hodnotu znaku
nebo symbol, který reprezentuje ty znaky z&nbsp;ASCII kódu, které nemají přímo
tisknutelnou podobu. Jedná se o prvních třicet jedna znaků a navíc taktéž o
znak DEL(ETE) s&nbsp;kódem 127:</p>

<table>
<tr><th>ASCII</th><th>Symbol</th><th>ASCII</th><th>Symbol</th></tr>
<tr><td>0 </td><td>#\nul</td><td>17</td><td>#\dc1</td></tr>
<tr><td>1 </td><td>#\soh</td><td>18</td><td>#\dc2</td></tr>
<tr><td>2 </td><td>#\stx</td><td>19</td><td>#\dc3</td></tr>
<tr><td>3 </td><td>#\etx</td><td>20</td><td>#\dc4</td></tr>
<tr><td>4 </td><td>#\eot</td><td>21</td><td>#\nak</td></tr>
<tr><td>5 </td><td>#\enq</td><td>22</td><td>#\syn</td></tr>
<tr><td>6 </td><td>#\ack</td><td>23</td><td>#\etv</td></tr>
<tr><td>7 </td><td>#\bel</td><td>24</td><td>#\can</td></tr>
<tr><td>8 </td><td>#\bs</td><td>25</td><td>#\em</td></tr>
<tr><td>9 </td><td>#\ht</td><td>26</td><td>#\sub</td></tr>
<tr><td>10</td><td>#\lf</td><td>27</td><td>#\esc</td></tr>
<tr><td>11</td><td>#\vt</td><td>28</td><td>#\fs</td></tr>
<tr><td>12</td><td>#\ff</td><td>29</td><td>#\gs</td></tr>
<tr><td>13</td><td>#\cr</td><td>30</td><td>#\rs</td></tr>
<tr><td>14</td><td>#\so</td><td>31</td><td>#\us</td></tr>
<tr><td>15</td><td>#\si</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>#\dle</td><td>127</td><td>#\del</td></tr>
</table>

<p><i>TinyScheme</i> se ovšem v&nbsp;některých ohledech odlišuje například od
GNU Guile nebo od MIT Scheme. Příkladem chybějící vlastnosti, na kterou lze
narazit i u relativně malých skriptů, je neexistující podpora pro komplexní
čísla a především pak pro zlomky. Ukažme si nyní příklad rozdílného chování
mezi GNU Guile, kterým jsme se <a
href="https://www.root.cz/clanky/gnu-guile-interpret-scheme-vestavitelny-do-nativnich-aplikaci/">zabývali
minule</a>, a TinyScheme při práci se zlomky.</p>

<p>Chování GNU Guile:</p>

<pre>
scheme@(guile-user)&gt; <strong>1/3</strong>
$1 = 1/3
scheme@(guile-user)&gt; <strong>(* 1/2 1/3)</strong>
$2 = 1/6
</pre>

<p>Chování TinyScheme:</p>

<pre>
ts&gt; <strong>1/3</strong>
Error: eval: unbound variable: 1/3 
&nbsp;
ts&gt; <strong>(* 1/2 1/3)</strong>
Error: eval: unbound variable: 1/2 
</pre>

<p>Při výpočtech je taktéž nutné si dát pozor na to, že rozsah celých čísel je
omezen nativním typem <strong>long</strong>, na rozdíl od klasického Scheme,
kde toto omezení neexistuje. Podívejme se na typický příklad &ndash; rekurzivní
výpočet faktoriálu:</p>

<pre>
(define (<strong>factorial</strong> n)
  (if (= n 0)     <i>; podmínka pro ukončení rekurzivního zanořování</i>
    1             <i>; faktoriál nuly je definitoricky roven jedné</i>
    (* n (factorial (- n 1)))
  )
)
&nbsp;
&nbsp;
(define n 0)
&nbsp;
(do ()
  ((&gt;= n 30))
  (display (factorial n))
  (newline)
  (set! n (+ n 1)))
</pre>

<p>Po spuštění zjistíme, že dochází k&nbsp;přetečení výsledků, což je
samozřejmě nekorektní:</p>

<pre>
1
1
2
6
24
120
720
5040
40320
362880
3628800
39916800
479001600
6227020800
87178291200
1307674368000
20922789888000
355687428096000
6402373705728000
121645100408832000
2432902008176640000
-4249290049419214848
-1250660718674968576
8128291617894825984
-7835185981329244160
7034535277573963776
-1569523520172457984
-5483646897237262336
-5968160532966932480
-7055958792655077376
</pre>

<p>V&nbsp;tomto případě nám pochopitelně nepomůže ani převod programu na
tail-call rekurzi:</p>

<pre>
(define (<strong>factorial</strong> n)
  (let fact-iter (                       <i>; pomocná vnitřní funkce</i>
                (n n)                    <i>; počitadlo iterací</i>
                (result 1))              <i>; průběžný výsledek</i>
      (if (= n 0)                        <i>; po dosažení koncového stavu</i>
        result                           <i>; se vrátí průběžný výsledek</i>
        (fact-iter (- n 1) (* n result)) <i>; koncové volání</i>
      )))
&nbsp;
&nbsp;
(define n 0)
&nbsp;
(do ()
  ((&gt;= n 30))
  (display (factorial n))
  (newline)
  (set! n (+ n 1)))
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
1
1
2
6
24
120
720
5040
40320
362880
3628800
39916800
479001600
6227020800
87178291200
1307674368000
20922789888000
355687428096000
6402373705728000
121645100408832000
2432902008176640000
-4249290049419214848
-1250660718674968576
8128291617894825984
-7835185981329244160
7034535277573963776
-1569523520172457984
-5483646897237262336
-5968160532966932480
-7055958792655077376
</pre>

<p>Naproti tomu GNU Guile s&nbsp;tímto příkladem žádné zásadní problémy
nemá:</p>

<pre>
1
1
2
6
24
120
720
5040
40320
362880
3628800
39916800
479001600
6227020800
87178291200
1307674368000
20922789888000
355687428096000
6402373705728000
121645100408832000
2432902008176640000
51090942171709440000
1124000727777607680000
25852016738884976640000
620448401733239439360000
15511210043330985984000000
403291461126605635584000000
10888869450418352160768000000
304888344611713860501504000000
8841761993739701954543616000000
</pre>

<p>Dále chybí podpora pro hygienická makra, což je docela škoda, protože se
&ndash; alespoň podle mého názoru &ndash; jedná o jednu z&nbsp;těch velmi
dobrých vlastností jazyka Scheme, kterou v&nbsp;naprosté většině
mainstreamových jazyků nenalezneme.</p>

<p>Poslední problém, se kterým se setkáme (ovšem na který narazíme u prakticky
všech interpretrů Scheme) je omezená práce paměti pro zásobník.
V&nbsp;následujícím příkladu je použita Ackermannova funkce, která je
rekurzivní, ovšem současně není primitivně rekurzivní. Navíc tato funkce i pro
malé vstupní hodnoty vyžaduje mnoho rekurzivních zanoření:</p>

<pre>
(define (<strong>A</strong> m n)
  (cond
    ((= m 0) (+ n 1))
    ((= n 0) (A (- m 1) 1))
    (else (A (- m 1) (A m (- n 1))))))
</pre>

<p>Tuto funkci si můžeme otestovat pro malé hodnoty <strong>m</strong> a
<strong>n</strong>:</p>

<pre>
(define m 0)
(define n 0)
&nbsp;
(do ()
  ((&gt;= m 4))
  (set! n 0)
  (do ()
    ((&gt;= n 5))
    (display (A m n))
    (display "\t")
    (set! n (+ n 1)))
  (newline)
  (set! m (+ m 1)))
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
1       2       3       4       5
2       3       4       5       6
3       5       7       9       11
5       13      29      61      125
</pre>

<p>Pro větší hodnoty, konkrétně pro <strong>m=5</strong> a <strong>n=0</strong>
se již ovšem Ackermannovu funkci nepodaří vyhodnotit:</p>

<pre>
(display (A 5 0))
</pre>

<p>V&nbsp;tomto případě interpret pouze lakonicky oznámí:</p>

<pre>
No memory!
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Získání zdrojových kódů a překlad TinyScheme</h2>

<p>TinyScheme pravděpodobně nebude k&nbsp;dispozici přímo ve formě balíčku pro
vaši Linuxovou distribuci, což však nemusí vadit, protože samotná kompilace
interpretru i knihoven TinyScheme je velmi snadná i rychlá a vyžaduje pouze
překladač jazyka C s&nbsp;jeho základními knihovnami a standardními nástroji
typu <strong>ld</strong>, <strong>ar</strong> atd. (v&nbsp;případě GNU Guile je
překlad nepatrně složitější, protože je vyžadováno větší množství knihoven,
které nebývají standardně nainstalovány).</p>

<p>Nejprve je samozřejmě nutné získat repositář se zdrojovými kódy TinyScheme.
Starší verze existuje ve formě forku přímo na GitHubu, konkrétně na adrese <a
href="https://github.com/yawnt/tinyscheme">https://github.com/yawnt/tinyscheme</a>,
pokud ovšem budete vyžadovat jinou verzi (ideálně poslední stabilní verzi
1.41), je nutné zdrojové kódy získat ze SourceForge, konkrétně z&nbsp;adresy <a
href="https://sourceforge.net/projects/tinyscheme/files/tinyscheme/">https://sourceforge.net/projects/tinyscheme/files/tinyscheme/</a>.
Poslední stabilní verze 1.41 je dostupná ve formě tarballu na adrese <a
href="https://sourceforge.net/projects/tinyscheme/files/tinyscheme/tinyscheme-1.41/tinyscheme-1.41.tar.gz/download">https://sourceforge.net/projects/tinyscheme/files/tinyscheme/tinyscheme-1.41/tinyscheme-1.41.tar.gz/download</a>
(stáhnout lze pochopitelně i ZIP archiv se stejným obsahem).</p>

<p>Samotná instalace se skládá jen ze dvou kroků.</p>

<p>Nejprve získaný tarball rozbalíme:</p>

<pre>
$ <strong>tar cvfz tinyscheme-1.41.tar.gz</strong>
</pre>

<p>Překlad a slinkování se provede klasicky nástrojem <strong>make</strong>.
V&nbsp;případě překladu na Linuxu není nutné soubor <strong>makefile</strong>
nijak upravovat, ovšem například při překladu pro operační systémy Microsoft
Windows, Solaris atd. se podívejte do <strong>makefile</strong> (v&nbsp;tomto
projektu je skutečně použit s&nbsp;malým písmenem na začátku názvu), které
části se musí zakomentovat a které naopak odkomentovat:</p>

<pre>
$ <strong>cd tinyscheme-1.41</strong>
&nbsp;
$ <strong>make</strong>
&nbsp;
gcc -fpic -pedantic -I. -c -g -Wno-char-subscripts -O -DSUN_DL=1 -DUSE_DL=1 -DUSE_MATH=1 -DUSE_ASCII_NAMES=0  scheme.c
gcc -fpic -pedantic -I. -c -g -Wno-char-subscripts -O -DSUN_DL=1 -DUSE_DL=1 -DUSE_MATH=1 -DUSE_ASCII_NAMES=0  dynload.c
dynload.c:24:0: warning: "SUN_DL" redefined [enabled by default]
 #define SUN_DL
 ^
&lt;command-line&gt;:0:0: note: this is the location of the previous definition
dynload.c: In function ‘dl_proc’:
dynload.c:77:14: warning: ISO C forbids conversion of object pointer to function pointer type [-Wpedantic]
   FARPROC fp=(FARPROC)dlsym(mo,proc);
              ^
gcc -shared -o libtinyscheme.so scheme.o dynload.o -ldl -lm
ar crs libtinyscheme.a scheme.o dynload.o
gcc -fpic -pedantic -o scheme -g -Wno-char-subscripts -O scheme.o dynload.o -ldl -lm
</pre>

<p><div class="rs-tip-major">Poznámka: výše zobrazená varování hlášená
překladačem jsou tak trošku ostuda (navíc se jedná o jednoduše opravitelné
problémy), ovšem snad ji autorovi odpustíme :-)</div></p>

<p>Po zadání předchozího příkladu by měly vzniknout zejména tyto tři
soubory:</p>

<table>
<tr><th>#</th><th>Soubor</th><th>Velikost (Linux, x86-64)</th><th>Velikost (Linux, i686)</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>scheme</td><td>208779</td><td>142735</td><td>interpret jazyka Scheme</td></tr>
<tr><td>2</td><td>libtinyscheme.so</td><td>225070</td><td>150038</td><td>knihovna pro dynamické linkování</td></tr>
<tr><td>3</td><td>libtinyscheme.a</td><td>332922</td><td>175540</td><td>knihovna pro statické linkování</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: zajímavé je, jak výrazně rozdílné jsou
velikosti výsledných souborů určených pro 32bitovou a pro 64bitovou
architekturu.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Překlad bez podpory datového typu <i>double</i></h2>

<p>Ve svém výchozím nastavení se <i>TinyScheme</i> překládá s&nbsp;volbou
<strong>USE_MATH=1</strong>. Při tomto nastavení se do vytvářeného interpretru
vloží podpora pro následující numerické funkce volatelné z&nbsp;libovolného
skriptu naprogramovaného ve Scheme:</p>

<table>
<tr><th>#</th><th>Funkce</th></tr>
<tr><td>1</td><td>exp</td></tr>
<tr><td>2</td><td>log</td></tr>
<tr><td>3</td><td>sin</td></tr>
<tr><td>4</td><td>cos</td></tr>
<tr><td>5</td><td>tan</td></tr>
<tr><td>6</td><td>asin</td></tr>
<tr><td>7</td><td>acos</td></tr>
<tr><td>8</td><td>atan</td></tr>
<tr><td>9</td><td>floor</td></tr>
<tr><td>10</td><td>ceiling</td></tr>
<tr><td>11</td><td>trunc</td></tr>
<tr><td>12</td><td>round</td></tr>
<tr><td>13</td><td>sqrt</td></tr>
<tr><td>14</td><td>expt</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: tyto funkce interně pracují
s&nbsp;hodnotami typu <i>double</i>, což na většině dnes podporovaných
mikroprocesorových architektur znamená <a
href="https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/#k03">numerické
hodnoty s&nbsp;dvojitou přesností</a> podle normy <a
href="https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/">IEEE
754</a>.</div></p>

<p>Pokud se ovšem volba <strong>USE_MATH=1</strong> nepoužije, znamená to, že
ani jedna z&nbsp;výše uvedených funkcí nebude k&nbsp;dispozici. Navíc se díky
tomu, že se nebude linkovat knihovna <strong>math</strong>, nepatrně zmenší
velikost výsledných binárních souborů s&nbsp;interpretrem i knihovnou
s&nbsp;implementací <i>TinyScheme</i>. Rozdíly ve velikosti pro architekturu
x86-64 můžeme vidět v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Soubor</th><th>Velikost při USE_MATH=1</th><th>Velikost při USE_MATH=0</th></tr>
<tr><td>1</td><td>scheme</td><td>208779</td><td>199569</td></tr>
<tr><td>2</td><td>libtinyscheme.so</td><td>225070</td><td>215860</td></tr>
<tr><td>3</td><td>libtinyscheme.a</td><td>332922</td><td>320666</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: překlad pro počítače, které mají
mikroprocesor s&nbsp;32bitovou architekturou i686, byl proveden na netbooku
Asus EEE 1000 s&nbsp;mikroprocesorem Atom.</div></p>

<p>Velikost vytvořených binárních souborů se sice zmenšila, ovšem dosti
nepatrně (alespoň v&nbsp;kontextu velikostí dnešních aplikací). Jaký má tedy
význam použití volby <strong>USE_MATH=0</strong> v&nbsp;praxi? Použijeme ji
například ve chvíli, kdy budeme potřebovat použít interpret programovacího
jazyka Scheme na těch architekturách, které neobsahují matematický koprocesor.
Kromě klasických osmibitových a šestnáctibitových mikrořadičů (TinyScheme by
mělo jíž provozovat například na <a
href="https://www.root.cz/clanky/sestnactibitove-mikroradice-ti-rady-msp430/">MSP430</a>)
se jedná o 32bitové mikrořadiče ARM. Zde bude úspora kódu mnohem větší, protože
pokud se vůbec nepoužije datový typ <strong>double</strong>, nebude se ani
linkovat knihovna se softwarovou implementací numerických operací.</p>

<p>Další matematické funkce jsou k&nbsp;dispozici vždy:</p>

<table>
<tr><th>#</th><th>Funkce</th></tr>
<tr><td>1</td><td>quotient</td></tr>
<tr><td>2</td><td>remainder</td></tr>
<tr><td>3</td><td>modulo</td></tr>
<tr><td>4</td><td>gcd</td></tr>
<tr><td>5</td><td>lcm</td></tr>
</table>

<p>Následující predikáty jsou dostupné jen z&nbsp;knihovny
<strong>init.scm</strong>:</p>

<table>
<tr><th>#</th><th>Funkce</th></tr>
<tr><td>1</td><td>exact?</td></tr>
<tr><td>2</td><td>inexact?</td></tr>
<tr><td>3</td><td>odd?</td></tr>
<tr><td>4</td><td>even?</td></tr>
<tr><td>5</td><td>zero?</td></tr>
<tr><td>6</td><td>positive?</td></tr>
<tr><td>7</td><td>negative?</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. Soubor <strong>init.scm</strong></h2>

<p>Kromě třech výše popsaných souborů vzniklých překladem (interpret, statická
knihovna, dynamická knihovna) je pro uživatele důležitý i soubor nazvaný
<strong>init.scm</strong>. Tento soubor obsahuje mnoho užitečných funkcí a
maker, které zjednodušují tvorbu nových programů a navíc do jisté míry zaručují
i kompatibilitu s&nbsp;R5RS a částečně i s&nbsp;R6RS. Tento soubor je
automaticky načítán interpretrem představovaným spustitelným souborem
<strong>scheme</strong>, ovšem v&nbsp;případě, že budeme provádět embedding
interpretru <i>TinyScheme</i> do vlastních aplikací, bude nutné načtení
<strong>init.scm</strong> provést ručně (to si ukážeme v&nbsp;navazujících
kapitolách).</p>

<p>Spuštění interpretru ve chvíli, kdy <strong>init.scm</strong> existuje, se
obejde bez chybových hlášení a všechny funkce a makra jsou automaticky
načtena:</p>

<pre>
$ <strong>./scheme</strong>
&nbsp;
TinyScheme 1.41
ts&gt; <strong>cadr</strong>
#&lt;CLOSURE&gt;
ts&gt;
ts&gt; <strong>(zero? 0)</strong>
#t
ts&gt; <strong>(negative? 0)</strong>
#f
</pre>

<p>Ve chvíli, kdy soubor <strong>init.scm</strong> není možné najít či načíst,
se chování změní:</p>

<pre>
$ <strong>./scheme</strong>
&nbsp;
Could not open file init.scm
TinyScheme 1.41
ts&gt; <strong>cadr</strong>
Error: eval: unbound variable: cadr 
&nbsp;
ts&gt;
ts&gt; <strong>(zero? 0)</strong>
Error: eval: unbound variable: zero? 
&nbsp;
ts&gt; <strong>(negative? 0)</strong>
Error: eval: unbound variable: negative? 
&nbsp;
</pre>

<p>Z&nbsp;rozšiřujících funkcí, které nalezneme v&nbsp;souboru
<strong>init.scm</strong> se jedná například o různé kombinace standardních
funkcí <strong>car</strong> a <strong>cdr</strong>:</p>

<pre>
ts&gt; <strong>(cadr '(1 2 3 4))</strong>
2
ts&gt; <strong>(caddr '(1 2 3 4))</strong>
3
ts&gt; <strong>(caar '('(1 2) '(3 4)))</strong>
quote
ts&gt; <strong>(caar '((1 2) (3 4)))</strong>
1
ts&gt; <strong>(cadr '((1 2) (3 4)))</strong>
(3 4)
</pre>

<p>Dále pak například makro s&nbsp;implementací programové smyčky
<strong>do</strong>, které se používá velmi snadno (viz též <a
href="#k07">sedmou kapitolu</a>):</p>

<pre>
<strong>(define i 0)</strong>
&nbsp;
<strong>(do ()</strong>
  <strong>((&gt;= i 10))</strong>
  <strong>(display i)</strong>
  <strong>(newline)</strong>
  <strong>(set! i (+ i 1)))</strong>
&nbsp;
0
1
2
3
4
5
6
7
8
9
</pre>

<p>O některých dalších funkcích, například numericky orientovaných predikátech,
jsme se již zmínili <a href="#k04">v&nbsp;předchozí kapitole</a>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Rekurze</h2>

<p><a
href="https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/">V&nbsp;úvodní
části</a> našeho povídání o programovacích jazycích <i>LISP</i> i <i>Scheme</i>
jsme si mj.&nbsp;řekli, že iteraci, tj.&nbsp;opakování vybrané části kódu
(většinou s&nbsp;různými parametry), lze vyjádřit buď pomocí rekurze nebo
s&nbsp;využitím explicitně či implicitně zapsaných programových smyček. Použití
rekurze je ve světě LISPu doporučovaná možnost, protože se nejvíce blíží
funkcionálnímu stylu programování a v&nbsp;mnoha případech taktéž vychází
rekurzivní zápis přímo z&nbsp;algoritmu, který se v&nbsp;jazyce <i>LISP</i>
nebo <i>Scheme</i> implementuje. Následuje příklad několika jednoduchých funkcí
zapsaných rekurzivně (jedná se o typické &bdquo;školní&ldquo; příklady).
Povšimněte si především toho, že se v&nbsp;těchto rekurzivních funkcích
nevyskytují žádné pomocné lokální proměnné, jejichž použití bychom se nemohli
vyhnout v&nbsp;případě zápisu obdobných výpočtů v&nbsp;nerekurzivní podobě.</p>

<p>Výpočet faktoriálu pro kladné parametry:</p>

<pre>
<i>; rekurzivní zápis výpočtu faktoriálu</i>
(define (<strong>factorial</strong> n)
    (if (&lt;= n 1)
        1
        (* n (factorial (- n 1)))))
</pre>

<p>Rekurzivně zapsaný výpočet n-tého prvku Fibonacciho posloupnosti:</p>

<pre>
<i>; rekurzivní výpočet Fibonacciho posloupnosti</i>
(define (<strong>fib</strong> n)
    (cond ((= n 0) 0)
          ((= n 1) 1)
          (else (+ (fib (- n 1)) (fib (- n 2))))))
</pre>

<p>Výpočet Ackermannovy funkce pro zadané vstupní parametru <strong>m</strong>
a <strong>n</strong>:</p>

<pre>
<i>; rekurzivní výpočet Ackermannovy funkce</i>
(define (<strong>A</strong> x y)
    (cond ((= y 0) 0)
          ((= x 0) (* 2 y))
          ((= y 1) 2)
          (else (A (- x 1) (A x (- y 1))))))
</pre>

<p>Výpočet největšího společného dělitele:</p>

<pre>
(define (<strong>gcd</strong> a b)
    (if (null? a)
        0
        (if (= b 0)
            a
            (gcd b (remainder a b)))))
</pre>

<p>Výpočet nejmenšího společného násobku:</p>

<pre>
(define (<strong>lcm</strong> a b)
    (if (null? a)
         1
         (if (or (= a 0) (= b 0))
             0
             (abs (* (quotient a (gcd a b)) b)))))
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Programová smyčka typu <strong>do</strong></h2>

<p>Ovšem v&nbsp;některých případech může být vhodnější nahradit rekurzivní
zápis algoritmu zápisem, v&nbsp;němž jsou použity programové smyčky. Pro tyto
účely obsahuje jazyk <i>Scheme</i> universální smyčku představovanou speciální
formou <strong>do</strong>. Tuto programovou smyčku lze použít například pro
tvorbu cyklu, v&nbsp;němž se postupně mění hodnota řídicí proměnné (či řídicích
proměnných), cyklu procházejícího přes prvky seznamu či cyklu, v&nbsp;němž se
postupně načítají a zpracovávají data uložená v&nbsp;externím souboru. Při
zápisu formy <strong>do</strong> je možné specifikovat seznam lokálních
proměnných platných v&nbsp;těle smyčky (tyto proměnné mohou být použity
například jako počitadla), výraz, pomocí kterého se hodnota těchto proměnných
změní na konci těla smyčky, podmínka pro ukončení smyčky a samozřejmě též tělo
smyčky, tj.&nbsp;příkazy prováděné v&nbsp;každé iteraci. Následuje jednoduchý
příklad použití speciální formy <strong>do</strong>, pomocí něhož je vytvořena
klasická počítaná smyčka:</p>

<pre>
(<strong>do</strong> ((i 1 (+ i 1)))  <i>; počáteční hodnota počitadla a iterační výraz provedený na konci smyčky</i>
    ((= i 10))       <i>; podmínka vyhodnocovaná pro ukončení smyčky</i>
        (display i)  <i>; tělo smyčky</i>
        (newline)
)
&nbsp;
1
2
3
4
5
6
7
8
9
</pre>

<p>Při zápisu speciální formy <strong>do</strong> lze vytvořit i větší množství
lokálních proměnných platných v&nbsp;rámci těla smyčky, viz následující příklad
s&nbsp;trojicí proměnných, z&nbsp;nichž každá se na konci smyčky (před začátkem
další iterace) modifikuje na základě vyhodnocení různých výrazů:</p>

<pre>
(<strong>do</strong> (
        (x 1 (* x 2))    <i>; počáteční hodnota proměnné a iterační výraz provedený na konci smyčky</i>
        (y 1000 (- y 1)) <i>; dtto</i>
        (z 0 (* x y))    <i>; dtto</i>
    )
    ((&lt; y x))         <i>; podmínka vyhodnocovaná pro ukončení smyčky</i>
        (display (list x y z)) <i>; tělo smyčky</i>
        (newline)
)
&nbsp;
(1 1000 0)
(2 999 1000)
(4 998 1998)
(8 997 3992)
(16 996 7976)
(32 995 15936)
(64 994 31840)
(128 993 63616)
(256 992 127104)
(512 991 253952)
</pre>

<p>V&nbsp;dalším příkladu je ukázáno postupné zpracování prvků uložených
v&nbsp;seznamu (ovšem tento příklad by ve skutečnosti bylo možné napsat mnohem
lépe a jednodušeji):</p>

<pre>
(do ((x '(1 2 3 4 5 6) (cdr x))) <i>; počáteční hodnota proměnné a iterační výraz provedený na konci smyčky</i>
    ((null? x))                  <i>; podmínka vyhodnocovaná pro ukončení smyčky</i>
        (display (car x))        <i>; vlastní tělo smyčky</i>
        (newline))
&nbsp;
1
2
3
4
5
6
</pre>

<p>Následuje poněkud složitější příklad, ve kterém je ukázáno použití vnořených
počítaných smyček při výpočtu podílu všech kombinací dvou celých čísel ležících
v&nbsp;rozsahu 1 až 10 (připomeňme, že výsledkem podílu dvou celých čísel je ve
standardním <i>Scheme</i> hodnota typu <i>rational</i> tj.&nbsp;racionální
číslo, ovšem v&nbsp;TinyScheme se jedná o reálné číslo). Na tomto příkladu je
patrné, že pro zápis složitějších programových struktur je vhodné používat
pomocné funkce, což je ostatně zásada, kterou je vhodné dodržovat i
v&nbsp;dalších programovacích jazycích:</p>

<pre>
(<strong>do</strong> ((y 1 (+ y 1)))    <i>; počáteční hodnota počitadla a iterační příkaz</i>
  ((&gt; y 10))           <i>; podmínka pro ukončení smyčky</i>
  (<strong>do</strong> ((x 1 (+ x 1)))  <i>; vnitřní smyčka</i>
    ((&gt; x 10))         <i>; podmínka pro ukončení vnitřní smyčky</i>
    (display (/ x y))  <i>; tisk výsledku</i>
    (display "\t")     <i>; přechod na další tabelační zarážku </i>
  )
  (newline)            <i>; přechod na další řádek</i>
)
</pre>

<p>Většinou se však používá poněkud odlišný zápis bez zavíracích závorek
umisťovaných na samostatné řádky:</p>

<pre>
(<strong>do</strong> ((y 1 (+ y 1)))    <i>; počáteční hodnota počitadla a iterační příkaz</i>
  ((&gt; y 10))           <i>; podmínka pro ukončení smyčky</i>
  (<strong>do</strong> ((x 1 (+ x 1)))  <i>; vnitřní smyčka</i>
    ((&gt; x 10))         <i>; podmínka pro ukončení vnitřní smyčky</i>
    (display (/ x y))  <i>; tisk výsledku</i>
    (display "\t"))    <i>; přechod na další tabelační zarážku </i>
  (newline))           <i>; přechod na další řádek</i>
</pre>

<p><div class="rs-tip-major">Poznámka: sice poněkud předbíháme, ale ukažme si,
jak je vlastně speciální forma <strong>do</strong> definována
v&nbsp;<i>TinyScheme</i>. Ve skutečnosti se jedná o makro, které se chová jako
speciální forma:</div></p>

<pre>
(macro <strong>do</strong>
  (lambda (do-macro)
    (apply (lambda (do vars endtest . body)
             (let ((do-loop (gensym)))
               `(letrec ((,do-loop
                           (lambda ,(map (lambda (x)
                                           (if (pair? x) (car x) x))
                                      `,vars)
                             (if ,(car endtest)
                               (begin ,@(cdr endtest))
                               (begin
                                 ,@body
                                 (,do-loop
                                   ,@(map (lambda (x)
                                            (cond
                                              ((not (pair? x)) x)
                                              ((&lt; (length x) 3) (car x))
                                              (else (car (cdr (cdr x))))))
                                       `,vars)))))))
                  (,do-loop
                    ,@(map (lambda (x)
                             (if (and (pair? x) (cdr x))
                               (car (cdr x))
                               '()))
                        `,vars)))))
      do-macro)))
</pre>

<p><div class="rs-tip-major">Poznámka: nejedná se vlastně o nijak dlouhý kód a
přitom sémantiku jazyka dosti výrazným způsobem rozšiřuje. Zde je možná patrná
elegance homoikonického jazyka.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Rozhraní mezi TinyScheme a nativními aplikacemi</h2>

<p>Ve druhé části dnešního článku si ukážeme, jakým způsobem je možné vložit
interpret programovacího jazyka Scheme do nativních aplikací vytvořených
v&nbsp;jazyku C. Samozřejmě lze použít i jiný kompilovaný jazyk (nejbližší je
C++), ovšem rozhraní mezi Scheme (resp.&nbsp;přesněji řečeno <i>TinyScheme</i>)
a C je nejjednodušeji použitelné. Pro překlad, slinkování a spuštění dále
popsaných příkladů budete potřebovat překladač C (gcc apod.) se základními
knihovnami i základními nástroji (<strong>ld</strong>, <strong>ar</strong>,
<strong>nm</strong>...). Soubory <strong>Makefile</strong> jsou zpracovávány
utilitou <strong>make</strong>. Žádné další nástroje ani knihovny již
v&nbsp;systému nejsou zapotřebí.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Inicializace interpretru Scheme a spuštění skriptu</h2>

<p>V&nbsp;prvním příkladu je ukázáno, jakým způsobem je možné spustit skript
naprogramovaný v&nbsp;jazyce Scheme přímo z&nbsp;céčka. Interpret Scheme lze
mít spuštěn ve více instancích, přičemž ke každé instanci se dostaneme přes
její <i>kontext</i>. Nejedná se přitom o globální proměnnou a jednotlivé
kontexty mezi sebou přímo nesdílí data. Co to znamená v&nbsp;praxi? Můžeme
vytvořit více na sobě nezávislých kontextů, použít tyto kontexty v&nbsp;různých
vláknech atd. &ndash; zde programátorovi nejsou kladeny žádné závažnější
překážky, což je jedna z&nbsp;výhod <i>TinyScheme</i>.</p>

<p>Nový kontext se vytvoří zavoláním funkce
<strong>scheme_init_new</strong>:</p>

<pre>
scheme *sc;
&nbsp;
sc = <strong>scheme_init_new</strong>();
</pre>

<p>Ve chvíli, kdy budeme chtít kontext zrušit (například při ukončení vlákna),
musíme zavolat opačnou funkci nazvanou <strong>scheme_deinit</strong>:</p>

<pre>
<strong>scheme_deinit</strong>(sc);
</pre>

<p>Dále můžeme vytvořit jednoduchý skript volající funkci
<strong>display</strong>. Tento skript uložíme do běžného céčkového
řetězce:</p>

<pre>
const char *<strong>script</strong>="(display \"Hello world!\")";
</pre>

<p>Načtení a vyhodnocení skriptu se provede funkcí
<strong>scheme_load_string</strong>:</p>

<pre>
<strong>scheme_load_string</strong>(sc, script);
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;předchozí větě jsem použil slovo
<i>vyhodnocení</i>. To znamená, že se každá forma zapsaná ve skriptu skutečně
zpracuje interpretrem, konkrétně funkcí <strong>eval</strong>. Pokud se jedná o
definici nového jména (proměnné, funkce, ...), bude jméno vytvořeno
v&nbsp;daném prostředí; ovšem pokud se jedná o volání funkce, bude funkce
<i>vyhodnocena</i>, tj.&nbsp;zavolána.</div></p>

<p>Aby se po spuštění příkladu něco skutečně stalo, budeme muset vytvořit i
céčkovskou variantu funkce <strong>display</strong>. Ta může vypadat
následovně:</p>

<pre>
pointer <strong>display</strong>(scheme *sc, pointer args) {
    if (args!=sc-&gt;NIL) {
        if (sc-&gt;vptr-&gt;is_string(sc-&gt;vptr-&gt;pair_car(args)))  {
            char *str = sc-&gt;vptr-&gt;string_value(sc-&gt;vptr-&gt;pair_car(args));
            printf("%s", str);
        }
    }
    return sc-&gt;NIL;
}
</pre>

<p>Tato funkce sice může na první pohled vypadat složitě, ale ve skutečnosti
celá její složitost spočívá v&nbsp;tom, že kontrolujeme, zda je jí předán
parametr a zda je tento parametr typu <strong>string</strong>. Pokud tomu tak
je, tak pomocí funkce <strong>string_value</strong> (přístupné přes ukazatel)
získáme céčkovský řetězec a ten posléze vytiskneme.</p>

<p>Novou funkci musíme zaregistrovat (pod vhodným jménem), aby ji interpret
jazyka Scheme mohl zavolat:</p>

<pre>
sc-&gt;vptr-&gt;<strong>scheme_define</strong>( 
    sc, 
    sc-&gt;global_env, 
    sc-&gt;vptr-&gt;mk_symbol(sc, "display"), 
    sc-&gt;vptr-&gt;mk_foreign_func(sc, display));
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, jakým způsobem se volají
funkce přes ukazatel získaný z&nbsp;tabulky <strong>vptr</strong>
z&nbsp;aktuálního kontextu. Globální prostor proměnných a funkcí tím vůbec není
ovlivněn.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Úplný zdrojový kód prvního příkladu</h2>

<p>Podívejme se nyní na úplný zdrojový kód prvního příkladu popsaného
v&nbsp;předchozí kapitole:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
#define USE_INTERFACE 1
&nbsp;
#include "scheme.h"
#include "scheme-private.h"
&nbsp;
pointer <strong>display</strong>(scheme *sc, pointer args) {
    if (args!=sc-&gt;NIL) {
        if (sc-&gt;vptr-&gt;is_string(sc-&gt;vptr-&gt;pair_car(args)))  {
            char *str = sc-&gt;vptr-&gt;string_value(sc-&gt;vptr-&gt;pair_car(args));
            printf("%s", str);
        }
    }
    return sc-&gt;NIL;
}
&nbsp;
int <strong>main</strong>(void)
{
    scheme *sc;
&nbsp;
    sc = scheme_init_new();
&nbsp;
    sc-&gt;vptr-&gt;scheme_define( 
        sc, 
        sc-&gt;global_env, 
        sc-&gt;vptr-&gt;mk_symbol(sc, "display"), 
        sc-&gt;vptr-&gt;mk_foreign_func(sc, display));
&nbsp;
    const char *script="(display \"Hello world!\")";
&nbsp;
    scheme_load_string(sc, script);
&nbsp;
    scheme_deinit(sc);
    return 0;
}
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si především řádku
<strong>#define USE_INTERFACE 1</strong>. Ten je nutné použít ještě před
načtením hlavičkových souborů <i>TinyScheme</i>. V&nbsp;opačném případě nebude
dostupná tabulka <strong>vptr</strong> s&nbsp;ukazateli funkcí.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Překlad prvního příkladu</h2>

<p></p>

<pre>
gcc -I . -L . embed1.c -o embed1 -l tinyscheme
</pre>

<p></p>

<pre>
CC=gcc
&nbsp;
CFLAGS=-Wall -std=c99 -pedantic -I.
&nbsp;
LIBS=-L . -l tinyscheme
&nbsp;
EXENAME=embed1
&nbsp;
all:    ${EXENAME}
&nbsp;
run:
        LD_LIBRARY_PATH=. ./${EXENAME}
&nbsp;
clean:
        rm -f embed1.o
        rm -f ${EXENAME}
&nbsp;
${EXENAME}:     embed1.o
        ${CC} $&lt; ${LIBS} -o $@
&nbsp;
embed1.o:       embed1.c
        ${CC} -c $&lt; ${CFLAGS}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>

<p></p>

<pre>
FILE *finit = fopen("init.scm", "r");
scheme_load_file(sc, finit);
fclose(finit);
</pre>

<pre>
(define (say-hello)
  (display "Hello world!")
  (newline))
&nbsp;
(say-hello)
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
#define USE_INTERFACE 1
&nbsp;
#include "scheme.h"
#include "scheme-private.h"
&nbsp;
pointer <strong>display</strong>(scheme *sc, pointer args) {
    if (args!=sc-&gt;NIL) {
        if (sc-&gt;vptr-&gt;is_string(sc-&gt;vptr-&gt;pair_car(args)))  {
            char *str = sc-&gt;vptr-&gt;string_value(sc-&gt;vptr-&gt;pair_car(args));
            printf("%s", str);
        }
    }
    return sc-&gt;NIL;
}
&nbsp;
int <strong>main</strong>(void)
{
    scheme *sc;
&nbsp;
    sc = scheme_init_new();
&nbsp;
    FILE *finit = fopen("init.scm", "r");
    scheme_load_file(sc, finit);
    fclose(finit);
&nbsp;
    sc-&gt;vptr-&gt;scheme_define( 
        sc, 
        sc-&gt;global_env, 
        sc-&gt;vptr-&gt;mk_symbol(sc, "display"), 
        sc-&gt;vptr-&gt;mk_foreign_func(sc, display));
&nbsp;
    FILE *f = fopen("script2.scm", "r");
    scheme_load_file(sc, f);
    fclose(f);
&nbsp;
    scheme_deinit(sc);
    return 0;
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. Jaký interpret použít pro implementaci DSL?</h2>

<p>Na tomto místě se možná někteří čtenáři mohou zeptat, jakou implementaci
LISPu či Scheme je vlastně nejvýhodnější použít v&nbsp;případě, že potřebujeme
přidat vlastní <i>DSL</i> (doménově specifický jazyk) do nějaké aplikace.
Z&nbsp;prozatím zmíněných řešení se nabízí:</p>

<ol>
<li><a href="https://www.root.cz/serialy/picolisp-minimalisticky-a-vykonny-interpret-lispu/">PicoLisp</a></li>
<li><a href="https://www.root.cz/clanky/gnu-guile-interpret-scheme-vestavitelny-do-nativnich-aplikaci/">GNU Guile</a></li>
<li>TinyScheme</li>
</ol>

<p>Předností <i>PicoLispu</i> jsou jeho nepatrné nároky na výpočetní výkon CPU
i na velikost dostupné operační paměti, takže je možné interpret tohoto
programovacího jazyka provozovat i na šestnáctibitových a pochopitelně i na
výkonnějších 32bitových mikrořadičích. Ovšem musíme se přitom smířit
s&nbsp;tím, že se jedná o v&nbsp;některých ohledech nestandardní implementaci
LISPu, s&nbsp;níž nebudou uživatelé dobře seznámeni.</p>

<p>Implementace <i>GNU Guile</i> naproti tomu odpovídá RnRS, což samozřejmě
zlepšuje pozici této implementace, neboť je k&nbsp;dispozici značné množství
dokumentace o Scheme, knihy, tutoriály, záznamy z&nbsp;přednášek atd. GNU Guile
taktéž podporuje překlad, multithreading, hygienická makra, práci
s&nbsp;komplexními čísly, se zlomky atd. atd. Ovšem za existenci všech těchto
vlastností zaplatíme většími nároky na systémové zdroje, což by mohlo
v&nbsp;některých implementacích vadit.</p>

<p>A konečně dnes popisovaná implementace <i>TinyScheme</i> leží zhruba na půli
cesty mezi minimalistickým, ovšem nestandardním <i>PicoLispem</i> na straně
jedné a <i>GNU Guile</i> na straně druhé. Mezi jeho přednosti patří relativně
dobrá podpora vlastností specifikovaných v&nbsp;R5RS (starší, ale stále platná
specifikace), malé nároky na systémové zdroje, možnost vytvoření několika na
sobě nezávislých <i>kontextů</i> apod. Nevýhodou ovšem je, že není podporována
úplná &bdquo;numerická věž&ldquo; Scheme; zejména může citelně chybět práce se
zlomky (což jsme již viděli na několika příkladech). Taktéž nejsou plně
podporována hygienická makra (chybí i makro <strong>while</strong>, to je však
možné doprogramovat).</p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;dalších částech tohoto
miniseriálu ovšem uvidíme, že existuje ještě větší množství implementací LISPu
a Scheme, jejichž interpretry či dokonce překladače je možné v&nbsp;případě
potřeby vložit do nativních aplikací a vytvořit tak pro ně vhodný DSL. Některé
z&nbsp;těchto implementací nabízí plnohodnotný překladač, další jsou zase
určeny pro minimalistická prostředí s&nbsp;omezenými výpočetními
prostředky.</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/lisp-families.git">https://github.com/tisnik/lisp-families.git</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, můžete
namísto toho použít odkazy na jednotlivé příklady, které naleznete
v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>ackermann.scm</td><td>Ackermannova funkce</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/examples/ackermann.scm">https://github.com/tisnik/lisp-families/blob/master/examples/ackermann.scm</a></td></tr>
<tr><td> 2</td><td>closure_1.scm</td><td>vytvoření a použití uzávěru, první příklad</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/examples/closure_1.scm">https://github.com/tisnik/lisp-families/blob/master/examples/closure_1.scm</a></td></tr>
<tr><td> 3</td><td>closure_2.scm</td><td>vytvoření a použití uzávěrů, druhý příklad</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/examples/closure_2.scm">https://github.com/tisnik/lisp-families/blob/master/examples/closure_2.scm</a></td></tr>
<tr><td> 4</td><td>do_loop_2.scm     </td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/examples/do_loop_2.scm">https://github.com/tisnik/lisp-families/blob/master/examples/do_loop_2.scm</a></td></tr>
<tr><td> 5</td><td>do_loop_3.scm     </td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/examples/do_loop_3.scm">https://github.com/tisnik/lisp-families/blob/master/examples/do_loop_3.scm</a></td></tr>
<tr><td> 6</td><td>do_loop.scm       </td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/examples/do_loop.scm">https://github.com/tisnik/lisp-families/blob/master/examples/do_loop.scm</a></td></tr>
<tr><td> 7</td><td>factorial_1.scm   </td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/examples/factorial_1.scm">https://github.com/tisnik/lisp-families/blob/master/examples/factorial_1.scm</a></td></tr>
<tr><td> 8</td><td>factorial_2.scm   </td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/examples/factorial_2.scm">https://github.com/tisnik/lisp-families/blob/master/examples/factorial_2.scm</a></td></tr>
<tr><td> 9</td><td>factorial_3.scm   </td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/examples/factorial_3.scm">https://github.com/tisnik/lisp-families/blob/master/examples/factorial_3.scm</a></td></tr>
<tr><td>10</td><td>fibonacci.scm     </td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/examples/fibonacci.scm">https://github.com/tisnik/lisp-families/blob/master/examples/fibonacci.scm</a></td></tr>
<tr><td>11</td><td>nested_loops_1.scm</td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/examples/nested_loops_1.scm">https://github.com/tisnik/lisp-families/blob/master/examples/nested_loops_1.scm</a></td></tr>
<tr><td>12</td><td>nested_loops_2.scm</td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/examples/nested_loops_2.scm">https://github.com/tisnik/lisp-families/blob/master/examples/nested_loops_2.scm</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Literatura</h2>

<ol>

<li>Peter Seibel<br />
<i>&bdquo;Practical Common Lisp&ldquo;</i><br />
2009
</li>

<li>Paul Graham<br />
<i>&bdquo;ANSI Common Lisp&ldquo;</i><br />
1995
</li>

<li>Gerald Gazdar<br />
<i>&bdquo;Natural Language Processing in Lisp: An Introduction to Computational Linguistics&ldquo;</i><br />
1989
</li>

<li>Peter Norvig<br />
<i>&bdquo;Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp&ldquo;</i><br />
1991
</li>

<li>Alex Mileler et.al.<br />
<i>&bdquo;Clojure Applied: From Practice to Practitioner&ldquo;</i><br />
2015
</li>

<li>
<i>&bdquo;Living Clojure: An Introduction and Training Plan for Developers&ldquo;</i><br />
2015
</li>

<li>Dmitri Sotnikov<br />
<i>&bdquo;Web Development with Clojure: Build Bulletproof Web Apps with Less Code&ldquo;</i><br />
2016
</li>

<li>McCarthy<br />
<i>&bdquo;Recursive functions of symbolic expressions and their computation by machine, part I&ldquo;</i><br />
1960
</li>

<li>R. Kent Dybvig<br />
<i>&bdquo;The Scheme Programming Language&ldquo;</i><br />
2009
</li>

<li>Max Hailperin<br />
<i>&bdquo;Concrete Abstractions&ldquo;</i><br />
1998
</li>

<li>Guy L. Steele<br />
<i>&bdquo;History of Scheme&ldquo;</i><br />
2006, Sun Microsystems Laboratories
</li>

<li>Kolář J., Muller K.:<br />
<i>&bdquo;Speciální programovací jazyky&ldquo;</i><br />
Praha 1981
</li>

<li>
<i>&bdquo;AutoLISP Release 9, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., October 1987
</li>

<li>
<i>&bdquo;AutoLISP Release 10, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., September 1988
</li>

<li>McCarthy, John; Abrahams, Paul W.; Edwards, Daniel J.; Hart, Timothy P.; Levin, Michael I.<br />
<i>&bdquo;LISP 1.5 Programmer's Manual&ldquo;</i><br />
MIT Press. ISBN 0 262 130 1 1 4
</li>

<li>Carl Hewitt; Peter Bishop and Richard Steiger<br />
<i>&bdquo;A Universal Modular Actor Formalism for Artificial Intelligence&ldquo;</i><br />
1973
</li>

<li>Feiman, J.<br />
<i>&bdquo;The Gartner Programming Language Survey (October 2001)&ldquo;</i><br />
Gartner Advisory
</li>

<li>Harold Abelson, Gerald Jay Sussman, Julie Sussman:<br />
<i>Structure and Interpretation of Computer Programs</i><br />
MIT Press. 1985, 1996 (a možná vyšel i další přetisk)
</li>

<li>Paul Graham<br />
<i>On Lisp</i><br />
Prentice Hall, 1993<br />
Dostupné online na stránce <a href="http://www.paulgraham.com/onlisptext.html">http://www.paulgraham.com/onlisptext.html</a>
</li>

<li>David S. Touretzky<br />
<i>Common LISP: A Gentle Introduction to Symbolic Computation (Dover Books on Engineering)</i><br />
</li>

<li>Peter Norvig<br />
<i>Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp</i>
</li>

<li>Patrick Winston, Berthold Horn<br />
<i>Lisp (3rd Edition)</i><br />
ISBN-13: 978-0201083194, ISBN-10: 0201083191
</li>

<li>Matthias Felleisen, David Van Horn, Dr. Conrad Barski<br>
<i>Realm of Racket: Learn to Program, One Game at a Time!</i><br />
ISBN-13: 978-1593274917, ISBN-10: 1593274912 
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>GOTO 2018 • Functional Programming in 40 Minutes • Russ Olsen<br />
<a href="https://www.youtube.com/watch?v=0if71HOyVjY">https://www.youtube.com/watch?v=0if71HOyVjY</a>
</li>

<li>TinyScheme (stránka na Sourceforge)<br />
<a href="http://tinyscheme.sourceforge.net/home.html">http://tinyscheme.sourceforge.net/home.html</a>
</li>

<li>Embedding Tiny Scheme in a Game<br />
<a href="http://www.silicondelight.com/embedding-tiny-scheme-in-a-game/">http://www.silicondelight.com/embedding-tiny-scheme-in-a-game/</a>
</li>

<li>Embedding Scheme for a game mission scripting DSL<br />
<a href="http://carloscarrasco.com/embedding-scheme-for-a-game-mission-scripting-dsl.html">http://carloscarrasco.com/embedding-scheme-for-a-game-mission-scripting-dsl.html</a>
</li>

<li>Všechny verze TinyScheme na SourceForge<br />
<a href="https://sourceforge.net/projects/tinyscheme/files/tinyscheme/">https://sourceforge.net/projects/tinyscheme/files/tinyscheme/</a>
</li>

<li>Fork TinyScheme na GitHubu<br />
<a href="https://github.com/yawnt/tinyscheme">https://github.com/yawnt/tinyscheme</a>
</li>

<li>Ackermannova funkce<br />
<a href="https://cs.wikipedia.org/wiki/Ackermannova_funkce">https://cs.wikipedia.org/wiki/Ackermannova_funkce</a>
</li>

<li>Ackermann function na Rosetta Code<br />
<a href="https://rosettacode.org/wiki/Ackermann_function#Scheme">https://rosettacode.org/wiki/Ackermann_function#Scheme</a>
</li>

<li>Scheme Quick Reference<br />
<a href="https://www.st.cs.uni-saarland.de/edu/config-ss04/scheme-quickref.pdf">https://www.st.cs.uni-saarland.de/edu/config-ss04/scheme-quickref.pdf</a>
</li>

<li>Slajdy o Scheme (od slajdu číslo 15)<br />
<a href="https://docs.google.com/presentation/d/1abmDnKjrq1tcjGvvRNAKhOiSTSE2lyagtcEPal07Gbo/edit">https://docs.google.com/presentation/d/1abmDnKjrq1tcjGvvRNAKhOiSTSE2lyagtcEPal07Gbo/edit</a>
</li>

<li>Scheme Cheat Sheet<br />
<a href="https://github.com/smythp/scheme-cheat-sheet">https://github.com/smythp/scheme-cheat-sheet</a>
</li>

<li>Embedding Lua, embedding Guile <br />
<a href="http://puntoblogspot.blogspot.com/2013/04/embedding-lua-embedding-guile.html">http://puntoblogspot.blogspot.com/2013/04/embedding-lua-embedding-guile.html</a>
</li>

<li>Lambda Papers<br />
<a href="https://en.wikisource.org/wiki/Lambda_Papers">https://en.wikisource.org/wiki/Lambda_Papers</a>
</li>

<li>Revised<sup>7</sup>Report on the Algorithmic Language Scheme<br />
<a href="https://small.r7rs.org/attachment/r7rs.pdf">https://small.r7rs.org/attachment/r7rs.pdf</a>
</li>

<li>Video Lectures (MIT, SICP 2005)<br />
<a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/</a>
</li>

<li>Why is Scheme my first language in university?<br />
<a href="https://softwareengineering.stackexchange.com/questions/115252/why-is-scheme-my-first-language-in-university">https://softwareengineering.stackexchange.com/questions/115252/why-is-scheme-my-first-language-in-university</a>
</li>

<li>The Perils of JavaSchools<br />
<a href="https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/">https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/</a>
</li>

<li>How to Design Programs, Second Edition<br />
<a href="https://htdp.org/2019-02-24/index.html">https://htdp.org/2019-02-24/index.html</a>
</li>

<li>LilyPond<br />
<a href="http://lilypond.org/">http://lilypond.org/</a>
</li>

<li>LilyPond — Extending (přes Scheme)<br />
<a href="http://lilypond.org/doc/v2.18/Documentation/extending/scheme-tutorial">http://lilypond.org/doc/v2.18/Documentation/extending/scheme-tutorial</a>
</li>

<li>Scheme in LilyPond<br />
<a href="http://lilypond.org/doc/v2.18/Documentation/extending/scheme-in-lilypond">http://lilypond.org/doc/v2.18/Documentation/extending/scheme-in-lilypond</a>
</li>

<li>GnuCash<br />
<a href="http://www.gnucash.org/">http://www.gnucash.org/</a>
</li>

<li>Custom Reports (in GNU Cash)<br />
<a href="https://wiki.gnucash.org/wiki/Custom_Reports">https://wiki.gnucash.org/wiki/Custom_Reports</a>
</li>

<li>Program by Design<br />
<a href="https://programbydesign.org/">https://programbydesign.org/</a>
</li>

<li>SchemePy<br />
<a href="https://pypi.org/project/SchemePy/">https://pypi.org/project/SchemePy/</a>
</li>

<li>LISP FQA: Section - [1-5] What is the "minimal" set of primitives needed for a Lisp interpreter?<br />
<a href="http://www.faqs.org/faqs/lisp-faq/part1/section-6.html">http://www.faqs.org/faqs/lisp-faq/part1/section-6.html</a>
</li>

<li>femtolisp<br />
<a href="https://github.com/JeffBezanson/femtolisp">https://github.com/JeffBezanson/femtolisp</a>
</li>

<li>(How to Write a (Lisp) Interpreter (in Python))<br />
<a href="http://norvig.com/lispy.html">http://norvig.com/lispy.html</a>
</li>

<li>Repositář s&nbsp;Guile Emacsem<br />
<a href="http://git.hcoop.net/?p=bpt/guile.git">http://git.hcoop.net/?p=bpt/guile.git</a>
</li>

<li>Interacting with Guile Compound Data Types in C<br />
<a href="http://www.lonelycactus.com/guilebook/x1555.html">http://www.lonelycactus.com/guilebook/x1555.html</a>
</li>

<li>Calling Guile functions from C<br />
<a href="http://www.lonelycactus.com/guilebook/c1204.html#SECCALLGUILEFUNC">http://www.lonelycactus.com/guilebook/c1204.html#SECCALLGUILEFUNC</a>
</li>

<li>Arrays, and other compound data types<br />
<a href="http://www.lonelycactus.com/guilebook/charrays.html">http://www.lonelycactus.com/guilebook/charrays.html</a>
</li>

<li>Interacting with Guile Compound Data Types in C<br />
<a href="http://www.lonelycactus.com/guilebook/x1555.html">http://www.lonelycactus.com/guilebook/x1555.html</a>
</li>

<li>Guile Reference Manual<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/index.html">https://www.gnu.org/software/guile/manual/html_node/index.html</a>
</li>

<li>Scheme: Summary of Common Syntax<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/Syntax-Summary.html#Syntax-Summary">https://www.gnu.org/software/guile/manual/html_node/Syntax-Summary.html#Syntax-Summary</a>
</li>

<li>Scripting with Guile: Extension language enhances C and Scheme<br />
<a href="https://www.ibm.com/developerworks/library/l-guile/index.html">https://www.ibm.com/developerworks/library/l-guile/index.html</a>
</li>

<li>Having fun with Guile: a tutorial<br />
<a href="http://dustycloud.org/misc/guile-tutorial.html">http://dustycloud.org/misc/guile-tutorial.html</a>
</li>

<li>Guile: Loading Readline Support<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/Loading-Readline-Support.html#Loading-Readline-Support">https://www.gnu.org/software/guile/manual/html_node/Loading-Readline-Support.html#Loading-Readline-Support</a>
</li>

<li>lispy<br />
<a href="https://pypi.org/project/lispy/">https://pypi.org/project/lispy/</a>
</li>

<li>Lython<br />
<a href="https://pypi.org/project/Lython/">https://pypi.org/project/Lython/</a>
</li>

<li>Lizpop<br />
<a href="https://pypi.org/project/lizpop/">https://pypi.org/project/lizpop/</a>
</li>

<li>Budoucnost programovacích jazyků<br />
<a href="http://www.knesl.com/budoucnost-programovacich-jazyku">http://www.knesl.com/budoucnost-programovacich-jazyku</a>
</li>

<li>LISP Prolog and Evolution<br />
<a href="http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html">http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html</a>
</li>

<li>List of Lisp-family programming languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages">https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages</a>
</li>

<li>clojure_py na indexu PyPi<br />
<a href="https://pypi.python.org/pypi/clojure_py">https://pypi.python.org/pypi/clojure_py</a>
</li>

<li>PyClojure<br />
<a href="https://github.com/eigenhombre/PyClojure">https://github.com/eigenhombre/PyClojure</a>
</li>

<li>Hy na GitHubu<br />
<a href="https://github.com/hylang/hy">https://github.com/hylang/hy</a>
</li>

<li>Hy: The survival guide<br />
<a href="https://notes.pault.ag/hy-survival-guide/">https://notes.pault.ag/hy-survival-guide/</a>
</li>

<li>Hy běžící na monitoru terminálu společnosti Symbolics<br />
<a href="http://try-hy.appspot.com/">http://try-hy.appspot.com/</a>
</li>

<li>Welcome to Hy’s documentation!<br />
<a href="http://docs.hylang.org/en/stable/">http://docs.hylang.org/en/stable/</a>
</li>

<li>Hy na PyPi<br />
<a href="https://pypi.org/project/hy/#description">https://pypi.org/project/hy/#description</a>
</li>

<li>Getting Hy on Python<br />
<a href="https://lwn.net/Articles/596626/">https://lwn.net/Articles/596626/</a>
</li>

<li>Programming Can Be Fun with Hy<br />
<a href="https://opensourceforu.com/2014/02/programming-can-fun-hy/">https://opensourceforu.com/2014/02/programming-can-fun-hy/</a>
</li>

<li>Přednáška o projektu Hy (pětiminutový lighttalk)<br />
<a href="http://blog.pault.ag/day/2013/04/02">http://blog.pault.ag/day/2013/04/02</a>
</li>

<li>Hy (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Hy">https://en.wikipedia.org/wiki/Hy</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Point<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Point.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Point.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Narrowing<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Narrowing.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Narrowing.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Functions that Create Markers<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Markers.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Markers.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Motion<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Motion.html#Motion">https://www.gnu.org/software/emacs/manual/html_node/elisp/Motion.html#Motion</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Basic Char Syntax<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Char-Syntax.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Char-Syntax.html</a>
</li>

<li>Elisp: Sequence: List, Array<br />
<a href="http://ergoemacs.org/emacs/elisp_list_vs_vector.html">http://ergoemacs.org/emacs/elisp_list_vs_vector.html</a>
</li>

<li>Elisp: Property List<br />
<a href="http://ergoemacs.org/emacs/elisp_property_list.html">http://ergoemacs.org/emacs/elisp_property_list.html</a>
</li>

<li>Elisp: Hash Table<br />
<a href="http://ergoemacs.org/emacs/elisp_hash_table.html">http://ergoemacs.org/emacs/elisp_hash_table.html</a>
</li>

<li>Elisp: Association List<br />
<a href="http://ergoemacs.org/emacs/elisp_association_list.html">http://ergoemacs.org/emacs/elisp_association_list.html</a>
</li>

<li>The mapcar Function (An Introduction to Programming in Emacs Lisp)<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/mapcar.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/mapcar.html</a>
</li>

<li>Anaphoric macro<br />
<a href="https://en.wikipedia.org/wiki/Anaphoric_macro">https://en.wikipedia.org/wiki/Anaphoric_macro</a>
</li>

<li>Some Common Lisp Loop Macro Examples<br />
<a href="https://www.youtube.com/watch?v=3yl8o6r_omw">https://www.youtube.com/watch?v=3yl8o6r_omw</a>
</li>

<li>A Guided Tour of Emacs<br />
<a href="https://www.gnu.org/software/emacs/tour/">https://www.gnu.org/software/emacs/tour/</a>
</li>

<li>The Roots of Lisp<br />
<a href="http://www.paulgraham.com/rootsoflisp.html">http://www.paulgraham.com/rootsoflisp.html</a>
</li>

<li>Evil (Emacs Wiki)<br />
<a href="https://www.emacswiki.org/emacs/Evil">https://www.emacswiki.org/emacs/Evil</a>
</li>

<li>Evil (na GitHubu)<br />
<a href="https://github.com/emacs-evil/evil">https://github.com/emacs-evil/evil</a>
</li>

<li>Evil (na stránkách repositáře MELPA)<br />
<a href="https://melpa.org/#/evil">https://melpa.org/#/evil</a>
</li>

<li>Evil Mode: How I Switched From VIM to Emacs<br />
<a href="https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html">https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html</a>
</li>

<li>GNU Emacs (home page)<br />
<a href="https://www.gnu.org/software/emacs/">https://www.gnu.org/software/emacs/</a>
</li>

<li>GNU Emacs (texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs">http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs</a>
</li>

<li>An Introduction To Using GDB Under Emacs<br />
<a href="http://tedlab.mit.edu/~dr/gdbintro.html">http://tedlab.mit.edu/~dr/gdbintro.html</a>
</li>

<li>An Introduction to Programming in Emacs Lisp<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html</a>
</li>

<li>27.6 Running Debuggers Under Emacs<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html">https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html</a>
</li>

<li>GdbMode<br />
<a href="http://www.emacswiki.org/emacs/GdbMode">http://www.emacswiki.org/emacs/GdbMode</a>
</li>

<li>Emacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Emacs">https://en.wikipedia.org/wiki/Emacs</a>
</li>

<li>Emacs timeline<br />
<a href="http://www.jwz.org/doc/emacs-timeline.html">http://www.jwz.org/doc/emacs-timeline.html</a>
</li>

<li>Emacs Text Editors Family<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?EmacsFamily">http://texteditors.org/cgi-bin/wiki.pl?EmacsFamily</a>
</li>

<li>Vrapper aneb spojení možností Vimu a Eclipse<br />
<a href="https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse/">https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse/</a>
</li>

<li>Vrapper aneb spojení možností Vimu a Eclipse (část 2: vyhledávání a nahrazování textu)<br />
<a href="https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse-cast-2-vyhledavani-a-nahrazovani-textu/">https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse-cast-2-vyhledavani-a-nahrazovani-textu/</a>
</li>

<li>Emacs/Evil-mode - A basic reference to using evil mode in Emacs<br />
<a href="http://www.aakarshnair.com/posts/emacs-evil-mode-cheatsheet">http://www.aakarshnair.com/posts/emacs-evil-mode-cheatsheet</a>
</li>

<li>From Vim to Emacs+Evil chaotic migration guide<br />
<a href="https://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/">https://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/</a>
</li>

<li>Introduction to evil-mode {video)<br />
<a href="https://www.youtube.com/watch?v=PeVQwYUxYEg">https://www.youtube.com/watch?v=PeVQwYUxYEg</a>
</li>

<li>EINE (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/EINE">http://www.emacswiki.org/emacs/EINE</a>
</li>

<li>EINE (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?EINE">http://texteditors.org/cgi-bin/wiki.pl?EINE</a>
</li>

<li>ZWEI (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/ZWEI">http://www.emacswiki.org/emacs/ZWEI</a>
</li>

<li>ZWEI (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?ZWEI">http://texteditors.org/cgi-bin/wiki.pl?ZWEI</a>
</li>

<li>Zmacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Zmacs">https://en.wikipedia.org/wiki/Zmacs</a>
</li>

<li>Zmacs (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?Zmacs">http://texteditors.org/cgi-bin/wiki.pl?Zmacs</a>
</li>

<li>TecoEmacs (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/TecoEmacs">http://www.emacswiki.org/emacs/TecoEmacs</a>
</li>

<li>Micro Emacs<br />
<a href="http://www.emacswiki.org/emacs/MicroEmacs">http://www.emacswiki.org/emacs/MicroEmacs</a>
</li>

<li>Micro Emacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/MicroEMACS">https://en.wikipedia.org/wiki/MicroEMACS</a>
</li>

<li>EmacsHistory<br />
<a href="http://www.emacswiki.org/emacs/EmacsHistory">http://www.emacswiki.org/emacs/EmacsHistory</a>
</li>

<li>Seznam editorů s ovládáním podobným Emacsu či kompatibilních s příkazy Emacsu<br />
<a href="http://www.finseth.com/emacs.html">http://www.finseth.com/emacs.html</a>
</li>

<li>evil-numbers<br />
<a href="https://github.com/cofi/evil-numbers">https://github.com/cofi/evil-numbers</a>
</li>

<li>Debuggery a jejich nadstavby v&nbsp;Linuxu (1.část)<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/</a>
</li>

<li>Debuggery a jejich nadstavby v&nbsp;Linuxu (2.část)<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (3): Nemiver<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (4): KDbg<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (5): ladění aplikací v editorech Emacs a Vim<br />
<a href="https://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">https://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/</a>
</li>

<li>Org mode<br />
<a href="https://orgmode.org/">https://orgmode.org/</a>
</li>

<li>The Org Manual<br />
<a href="https://orgmode.org/manual/index.html">https://orgmode.org/manual/index.html</a>
</li>

<li>Kakoune (modální textový editor)<br />
<a href="http://kakoune.org/">http://kakoune.org/</a>
</li>

<li>Vim-style keybinding in Emacs/Evil-mode<br />
<a href="https://gist.github.com/troyp/6b4c9e1c8670200c04c16036805773d8">https://gist.github.com/troyp/6b4c9e1c8670200c04c16036805773d8</a>
</li>

<li>Emacs - jak začít<br />
<a href="http://www.abclinuxu.cz/clanky/navody/emacs-jak-zacit">http://www.abclinuxu.cz/clanky/navody/emacs-jak-zacit</a>
</li>

<li>Programovací jazyk LISP a LISP machines<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-lisp-a-lisp-machines/">https://www.root.cz/clanky/programovaci-jazyk-lisp-a-lisp-machines/</a>
</li>

<li>Evil-surround<br />
<a href="https://github.com/emacs-evil/evil-surround">https://github.com/emacs-evil/evil-surround</a>
</li>

<li>Spacemacs<br />
<a href="http://spacemacs.org/">http://spacemacs.org/</a>
</li>

<li>Lisp: Common Lisp, Racket, Clojure, Emacs Lisp<br />
<a href="http://hyperpolyglot.org/lisp">http://hyperpolyglot.org/lisp</a>
</li>

<li>Common Lisp, Scheme, Clojure, And Elisp Compared<br />
<a href="http://irreal.org/blog/?p=725">http://irreal.org/blog/?p=725</a>
</li>

<li>Does Elisp Suck?<br />
<a href="http://irreal.org/blog/?p=675">http://irreal.org/blog/?p=675</a>
</li>

<li>Emacs pro mírně pokročilé (9): Elisp<br />
<a href="https://www.root.cz/clanky/emacs-elisp/">https://www.root.cz/clanky/emacs-elisp/</a>
</li>

<li>If I want to learn lisp, are emacs and elisp a good choice?<br />
<a href="https://www.reddit.com/r/emacs/comments/2m141y/if_i_want_to_learn_lisp_are_emacs_and_elisp_a/">https://www.reddit.com/r/emacs/comments/2m141y/if_i_want_to_learn_lisp_are_emacs_and_elisp_a/</a>
</li>

<li>Clojure(Script) Interactive Development Environment that Rocks!<br />
<a href="https://github.com/clojure-emacs/cider">https://github.com/clojure-emacs/cider</a>
</li>

<li>An Introduction to Emacs Lisp<br />
<a href="https://harryrschwartz.com/2014/04/08/an-introduction-to-emacs-lisp.html">https://harryrschwartz.com/2014/04/08/an-introduction-to-emacs-lisp.html</a>
</li>

<li>Emergency Elisp<br />
<a href="http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html">http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html</a>
</li>

<li>Lambda calculus<br />
<a href="https://en.wikipedia.org/wiki/Lambda_calculus">https://en.wikipedia.org/wiki/Lambda_calculus</a>
</li>

<li>John McCarthy's original LISP paper from 1959<br />
<a href="https://www.reddit.com/r/programming/comments/17lpz4/john_mccarthys_original_lisp_paper_from_1959/">https://www.reddit.com/r/programming/comments/17lpz4/john_mccarthys_original_lisp_paper_from_1959/</a>
</li>

<li>Micro Manual LISP<br />
<a href="https://www.scribd.com/document/54050141/Micro-Manual-LISP">https://www.scribd.com/document/54050141/Micro-Manual-LISP</a>
</li>

<li>How Lisp Became God's Own Programming Language<br />
<a href="https://twobithistory.org/2018/10/14/lisp.html">https://twobithistory.org/2018/10/14/lisp.html</a>
</li>

<li>History of Lisp<br />
<a href="http://jmc.stanford.edu/articles/lisp/lisp.pdf">http://jmc.stanford.edu/articles/lisp/lisp.pdf</a>
</li>

<li>The Roots of Lisp<br />
<a href="http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf">http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf</a>
</li>

<li>Racket<br />
<a href="https://racket-lang.org/">https://racket-lang.org/</a>
</li>

<li>The Racket Manifesto<br />
<a href="http://felleisen.org/matthias/manifesto/">http://felleisen.org/matthias/manifesto/</a>
</li>

<li>MIT replaces Scheme with Python<br />
<a href="https://www.johndcook.com/blog/2009/03/26/mit-replaces-scheme-with-python/">https://www.johndcook.com/blog/2009/03/26/mit-replaces-scheme-with-python/</a>
</li>

<li>Adventures in Advanced Symbolic Programming<br />
<a href="http://groups.csail.mit.edu/mac/users/gjs/6.945/">http://groups.csail.mit.edu/mac/users/gjs/6.945/</a>
</li>

<li>Why MIT Switched from Scheme to Python (2009)<br />
<a href="https://news.ycombinator.com/item?id=14167453">https://news.ycombinator.com/item?id=14167453</a>
</li>

<li>Starodávná stránka XLispu<br />
<a href="http://www.xlisp.org/">http://www.xlisp.org/</a>
</li>

<li>AutoLISP<br />
<a href="https://en.wikipedia.org/wiki/AutoLISP">https://en.wikipedia.org/wiki/AutoLISP</a>
</li>

<li>Seriál PicoLisp: minimalistický a výkonný interpret Lispu<br />
<a href="https://www.root.cz/serialy/picolisp-minimalisticky-a-vykonny-interpret-lispu/">https://www.root.cz/serialy/picolisp-minimalisticky-a-vykonny-interpret-lispu/</a>
</li>

<li>Common Lisp<br />
<a href="https://common-lisp.net/">https://common-lisp.net/</a>
</li>

<li>Getting Going with Common Lisp<br />
<a href="https://cliki.net/Getting%20Started">https://cliki.net/Getting%20Started</a>
</li>

<li>Online Tutorial (Common Lisp)<br />
<a href="https://cliki.net/online%20tutorial">https://cliki.net/online%20tutorial</a>
</li>

<li>Guile Emacs<br />
<a href="https://www.emacswiki.org/emacs/GuileEmacs">https://www.emacswiki.org/emacs/GuileEmacs</a>
</li>

<li>Guile Emacs History<br />
<a href="https://www.emacswiki.org/emacs/GuileEmacsHistory">https://www.emacswiki.org/emacs/GuileEmacsHistory</a>
</li>

<li>Guile is a programming language<br />
<a href="https://www.gnu.org/software/guile/">https://www.gnu.org/software/guile/</a>
</li>

<li>MIT Scheme<br />
<a href="http://groups.csail.mit.edu/mac/projects/scheme/">http://groups.csail.mit.edu/mac/projects/scheme/</a>
</li>

<li>SIOD: Scheme in One Defun<br />
<a href="http://people.delphiforums.com/gjc//siod.html">http://people.delphiforums.com/gjc//siod.html</a>
</li>

<li>CommonLispForEmacs<br />
<a href="https://www.emacswiki.org/emacs/CommonLispForEmacs">https://www.emacswiki.org/emacs/CommonLispForEmacs</a>
</li>

<li>Elisp: print, princ, prin1, format, message<br />
<a href="http://ergoemacs.org/emacs/elisp_printing.html">http://ergoemacs.org/emacs/elisp_printing.html</a>
</li>

<li>Special Forms in Lisp<br />
<a href="http://www.nhplace.com/kent/Papers/Special-Forms.html">http://www.nhplace.com/kent/Papers/Special-Forms.html</a>
</li>

<li>Basic Building Blocks in LISP<br />
<a href="https://www.tutorialspoint.com/lisp/lisp_basic_syntax.htm">https://www.tutorialspoint.com/lisp/lisp_basic_syntax.htm</a>
</li>

<li>Introduction to LISP - University of Pittsburgh<br />
<a href="https://people.cs.pitt.edu/~milos/courses/cs2740/Lectures/LispTutorial.pdf">https://people.cs.pitt.edu/~milos/courses/cs2740/Lectures/LispTutorial.pdf</a>
</li>

<li>Why don't people use LISP<br />
<a href="https://forums.freebsd.org/threads/why-dont-people-use-lisp.24572/">https://forums.freebsd.org/threads/why-dont-people-use-lisp.24572/</a>
</li>

<li>Structured program theorem<br />
<a href="https://en.wikipedia.org/wiki/Structured_program_theorem">https://en.wikipedia.org/wiki/Structured_program_theorem</a>
</li>

<li>Clojure: API Documentation<br />
<a href="https://clojure.org/api/api">https://clojure.org/api/api</a>
</li>

<li>Tutorial for the Common Lisp Loop Macro<br />
<a href="http://www.ai.sri.com/pkarp/loop.html">http://www.ai.sri.com/pkarp/loop.html</a>
</li>

<li>Common Lisp's Loop Macro Examples for Beginners<br />
<a href="http://www.unixuser.org/~euske/doc/cl/loop.html">http://www.unixuser.org/~euske/doc/cl/loop.html</a>
</li>

<li>A modern list api for Emacs. No 'cl required.<br />
<a href="https://github.com/magnars/dash.el">https://github.com/magnars/dash.el</a>
</li>

<li>The LOOP Facility<br />
<a href="http://www.lispworks.com/documentation/HyperSpec/Body/06_a.htm">http://www.lispworks.com/documentation/HyperSpec/Body/06_a.htm</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>Transient Data Structures
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Jazyky Hy a Clojure-py: moderní dialekty LISPu určené pro Python VM<br />
<a href="https://www.root.cz/clanky/jazyky-hy-a-clojure-py-moderni-dialekty-lispu-urcene-pro-python-vm/">https://www.root.cz/clanky/jazyky-hy-a-clojure-py-moderni-dialekty-lispu-urcene-pro-python-vm/</a>
</li>

<li>Pixie: lehký skriptovací jazyk s „kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

<li>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/">https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

