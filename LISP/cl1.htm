<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Common Lisp - žralok mezi programovacími jazyky</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Common Lisp - žralok mezi programovacími jazyky</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V seriálu o dialektech programovacího jazyka Lisp (kam lze zařadit i Scheme, Racket či Clojure) nesmí chybět článek o Common Lispu. Jedná se o multiparadigmatický programovací jazyk definovaný standardem (ANSI), pro nějž existuje několik vzájemně kompatibilních implementací.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Common Lisp &ndash; žralok mezi programovacími jazyky</a></p>
<p><a href="#k02">2. Stručná historie vývoje Common Lispu</a></p>
<p><a href="#k03">3. Interaktivní vývoj &ndash; skutečný REPL a koncept &bdquo;obrazu&ldquo; prostředí</a></p>
<p><a href="#k04">4. Instalace Common Lispu a nastavení prostředí</a></p>
<p><a href="#k05">5. Interní debugger Common Lispu</a></p>
<p><a href="#k06">6. První krůčky s&nbsp;Common Lispem</a></p>
<p><a href="#k07">7. Přerušení výpočtu a jeho obnovení</a></p>
<p><a href="#k08">8. Multiparadigmatický programovací jazyk</a></p>
<p><a href="#k09">9. Makrosystém Common Lispu</a></p>
<p><a href="#k10">10. LISP jako jazyk pro tvorbu (doménově specifických) jazyků</a></p>
<p><a href="#k11">11. DSL pro tvorbu programových smyček &ndash; makro <strong>loop</strong></a></p>
<p><a href="#k12">12. Použití klauzulí <strong>while</strong> a <strong>until</strong></a></p>
<p><a href="#k13">13. Různé varianty počítané smyčky typu <strong>for</strong></a></p>
<p><a href="#k14">14. Procházení prvky seznamu aneb smyčka typu <strong>for-each</strong></a></p>
<p><a href="#k15">15. Vybrané další možnosti poskytované makrem <strong>loop</strong></a></p>
<p><a href="#k16">16. Překlad LISPovského programu do nativního kódu</a></p>
<p><a href="#k17">17. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k18">18. Předchozí části seriálu</a></p>
<p><a href="#k19">19. Literatura</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Common Lisp &ndash; žralok mezi programovacími jazyky</h2>

<p><i>&bdquo;Most languages are used to solve problem. Lisp is one of the few
languages that allows you to write programs that write programs that solve
problems&ldquo;</i></p>

<p>Svět LISPovských jazyků je dnes velmi rozsáhlý a poměrně nepřehledný, ovšem
není se čemu divit, protože první koncept LISPu vznikl již před neuvěřitelnými
61 lety, konkrétně v&nbsp;roce 1958. Jedná se tedy o jeden z&nbsp;prvních
vyšších programovacích jazyků vyvinutých pro nasazení na mainframech. Některé
z&nbsp;těchto jazyků jsou (s&nbsp;modifikacemi a vylepšeními) používány dodnes,
a to nikoli pouze z&nbsp;důvodu konzervativnosti programátorů či nutnosti
údržby starého programového kódu stále používaného v&nbsp;produkčním prostředí.
V&nbsp;LISPu se totiž objevilo hned několik zajímavých a přelomových konceptů,
které samy o sobě dokázaly udržet tento programovací jazyk v&nbsp;hledáčku
programátorů. A nejenom to &ndash; mnoho myšlenek z&nbsp;LISPu se postupně
uplatňuje i v&nbsp;dalších programovacích jazycích, i když je nutné říci, že
některé koncepty (homoikonicita a s&nbsp;ní související makra a
metaprogramování) jsou do mnoha dalších jazyků přenositelná jen s&nbsp;obtížemi
(poměrně úspěšné jsou v&nbsp;tomto ohledu jazyky <a
href="https://www.root.cz/serialy/programovaci-jazyk-rust/">Rust</a> a <a
href="https://www.root.cz/serialy/programovaci-jazyk-julia/">Julia</a> se svými
systémy maker).</p>

<a href="https://www.root.cz/obrazek/572364/"><img src="https://i.iinfo.cz/images/556/cm1-1-prev.png" class="image-572364" alt="&#160;" title="Autor: third_party, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="220" height="270" /></a>
<p><i>Obrázek 1: O Common Lispu bylo vydáno i relativně velké množství
knih.</i></p>

<p>Dialektů LISPu vzniklo velké množství &ndash; určitě několik desítek,
pravděpodobně i několik set. Ovšem v&nbsp;současnosti se setkáme především
s&nbsp;Common Lispem, Elispem (v&nbsp;Emacsu), jazykem Racket a s&nbsp;Clojure.
Dnes se budeme zabývat prvně jmenovaným, tj.&nbsp;<i>Common Lispem</i>. Ten je
od roku 1994 definován v&nbsp;ANSI normě a existuje několik jeho implementací,
které jsou mezi sebou kompatibilní (zcela jistě na úrovni zdrojových kódů a
základních knihoven popsaných v&nbsp;ANSI):</p>

<ul>
<li>Steel Bank Common Lisp (SBCL)</li>
<li>Embeddable Common Lisp (ECL), je překládán do C</li>
<li>CLISP</li>
<li>ABCL, zajišťuje interoperabilitu s&nbsp;JVM</li>
<li>ClozureCL</li>
<li>CLASP, založena na iteroperabilitě s&nbsp;LLVM</li>
<li>AllegroCL (proprietary)</li>
<li>LispWorks (proprietary)</li>
<li>CMUCL, původně vznikl na Carnegie Mellon University</li>
<li>GNU Common Lisp</li>
</ul>

<p><div class="rs-tip-major">Poznámka: název Steel Bank Common Lisp vznikl jako
určitá slovní hříčka. Jedná se o referenci na CMUCL pocházející z&nbsp;Carnegie
Mellon University. Andrew Carnegie přitom podnikal v&nbsp;oblasti ocelářství
(<i>steel</i>), Andrew Mellon v&nbsp;oblasti bankovnictví
(<i>bank</i>).</div></p>

<p>Okolo Common Lispu vznikl poměrně rozsáhlý ekosystém, viz například stránku
<a
href="https://github.com/CodyReichert/awesome-cl">https://github.com/CodyReichert/awesome-cl</a>.</p>

<a href="https://www.root.cz/obrazek/572365/"><img src="https://i.iinfo.cz/images/556/cm1-2-prev.png" class="image-572365" alt="&#160;" title="Autor: third_party, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="179" height="270" /></a>
<p><i>Obrázek 2: Přebal další knihy o Common Lispu.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Stručná historie vývoje Common Lispu</h2>

<p><i>&bdquo;Common Lisp isn't going anywhere,<br />
and that's a great thing&ldquo;<br />
Alan Dipert</i></p>

<p>V&nbsp;této kapitole si alespoň ve stručnosti přiblížíme historii <i>Common
Lispu</i>. Ten původně vznikl z&nbsp;<i>Maclispu</i>, což je jeden
z&nbsp;dialektů programovacího jazyka LISP, kterému jsme se (i když taktéž jen
ve stručnosti) věnovali v&nbsp;článku <a
href="https://www.root.cz/clanky/interlisp-aneb-ozivujeme-dinosaura/">
Interlisp aneb oživujeme dinosaura</a>. Mezi cíle, které si tým, který vznikl
za účelem vývoje <i>Maclispu</i>, vytyčil, patřila především snaha o návrh
standardizované podoby programovacího jazyka Lisp; navíc se mělo jednat o
vylepšení předchozích dialektů LISPu. Tento cíl se ovšem do značné míry podobá
cílům dalších projektů, které vznikaly ve zhruba stejnou dobu: ZetaLisp, NIL,
Spice Lisp popř.&nbsp;S-1 Lisp. Common Lisp vznikl na základě myšlenek a
jazykových konstrukcí, které se v&nbsp;těchto dialektech Lispu objevily &ndash;
proto také Common Lisp není, minimálně co se týká standardní knihovny tohoto
jazyka, zcela konzistentní (což je více než patrné v&nbsp;porovnání se Scheme
či Clojure).</p>

<p><div class="rs-tip-major">Poznámka: taktéž nesmíme zapomenout na to, že za
vývojem Common Lispu stálo relativně velké množství autorů i pracovních skupin
(typicky realizovaných v&nbsp;rámci univerzitního prostředí napojeného na tehdy
významné IT firmy), na rozdíl od (například) Scheme či dokonce Clojure, což je
projekt, který vznikl jako &bdquo;one man show&ldquo; (a dodnes je do značné
míry ovlivněn především Richem Hickeym).</div></p>

<a href="http://i.iinfo.cz/images/455/lisp01.png"><img src="http://i.iinfo.cz/images/455/lisp01-prev.png" alt="lisp01" height="270" width="257" /></a>
<p><i>Obrázek 3: Na tomto grafu evoluce programovacích jazyků můžeme vidět
některé historicky významné programovací jazyky, s&nbsp;nimiž jsme se již
setkali v&nbsp;seriálu o historii počítačů. Jedná se zejména o Fortran, Cobol,
SNOBOL, Algol, APL, BASIC (resp.&nbsp;přesněji řečeno celá rodina jazyků
nesoucích toho jméno) a samozřejmě taktéž o LISP a jeho varianty.</i></p>

<p>Vraťme se však k&nbsp;historii Common Lispu. V&nbsp;roce 1981 se začala
tvořit kostra specifikace tohoto jazyka, přičemž za jejím vývojem stál
především Bob Engelmore, v&nbsp;té době pracující v&nbsp;ARPA. Bobovým cílem
bylo vytvoření standardu, který by však nebyl specifikován nějakou komisí, ale
spíše komunitou (ovšem komunitou v&nbsp;dobovém významu toho slova &ndash; tedy
nejvíce lidmi z&nbsp;univerzitního prostředí). A již o rok později, tedy
v&nbsp;roce 1982, byla tehdy první verze specifikace prezentována známým <a
href="https://en.wikipedia.org/wiki/Guy_L._Steele_Jr.">Guy Lewisem Steelem
Jr.</a> (mj.&nbsp;spoluautorem jazyka Scheme) na konferenci ACM (<i>ACM
symposium on functional programming and LISP</i>). Poté již práce na Common
Lispu pokračovala v&nbsp;poměrně rychlém tempu (s&nbsp;ohledem na to, že se
jednalo o jazyk, který se stal, slovy tvůrců &bdquo;součástí přírody&ldquo; a
již se pravděpodobně nebude a nemusí příliš měnit), takže v&nbsp;roce 1984
mohla vyjít první kniha o tomto jazyku &ndash; <i>Common Lisp the Language</i>
&ndash; která byla současně i jeho poloformální specifikací.</p>

<a href="https://www.root.cz/obrazek/337666/"><img src="https://i.iinfo.cz/images/196/emacs2-1-prev.png" class="image-337666" alt="&#160;" width="370" height="196" /></a>
<p><i>Obrázek 4: Vývoj některých dialektů Lispu.<br />
Zdroj: <a href="https://en.wikipedia.org/wiki/Lisp_%28programming_language%29">Wikipedia</a>.</i></p>

<p>Ovšem z&nbsp;pohledu standardizace je důležitý i rok 1994, kdy vznikl
standard <i>ANSI Common Lisp</i>. Po vydání této specifikace se vlastně
(minimálně oficiálně) Common Lisp dále neměnil, což ovšem neznamená, že
nedocházelo k&nbsp;postupnému rozšiřování, typicky formou knihoven maker a
funkcí. Takto například vznikla podpora pro Unicode, I/O operace založené na
CLOS či podpora pro souběžný běh výpočtů. V&nbsp;praxi to znamená mj.&nbsp;to,
že zdrojové kódy z&nbsp;roku 1994 budou s&nbsp;velkou pravděpodobností
použitelné i dnes (pochopitelně pokud nezávisí na nějakých zastaralých
knihovnách či operačních systémech). Ostatně je zajímavé (a pro ekosystém
jazyka Common Lisp možná i typické), že existuje relativně velké množství
knihoven, které nebyly například posledních pět či dokonce deset let změněny
(&bdquo;vylepšeny&ldquo;) a přece jsou bez problému použitelné. Tato stabilita
je v&nbsp;některých jiných ekosystémech prakticky nemyslitelná &ndash; ostatně
vývojáři by se pravděpodobně na pět let nemodifikovanou knihovnu pro
(například) Python či JavaScript dívali skrz prsty.</p>

<p><div class="rs-tip-major">Poznámka: dnes je Common Lisp společně se Scheme,
Racketem a Clojure nejpoužívanějším dialektem Lispu (zařadit sem můžeme ještě
ELisp z&nbsp;Emacsu). Pro programátory může být užitečná tato tabulka, která
některé výše uvedené dialekty porovnává: <a
href="http://hyperpolyglot.org/lisp">http://hyperpolyglot.org/lisp</a></div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Interaktivní vývoj &ndash; skutečný REPL a koncept &bdquo;obrazu&ldquo; prostředí</h2>

<p><i>&bdquo; Part of what makes Lisp distinctive is that it is designed to
evolve. As new abstractions become popular (object-oriented programming, for
example), it always turns out to be easy to implement them in Lisp. Like DNA,
such a language does not go out of style.&ldquo;<br />
Paul Graham</i></p>

<p>Základem vývoje v&nbsp;(Common) LISPu je interaktivní prostředí založené na
REPLu, tedy na okamžitém vyhodnocování zapsaných výrazů s&nbsp;výpisem jejich
výsledků. Ovšem v&nbsp;případě Common Lispu je REPL navíc doplněn o debugger <a
href="#k05">popsaný níže</a>. V&nbsp;krátkosti &ndash; při vzniku chyby se
neprovádí &bdquo;rozbalovací&ldquo; fáze založená na zpětném procházení
zásobníkových rámců. Tato operace je ponechána na uživateli, který tak může
skutečně zkoumat &bdquo;živý&ldquo; program.</p>

<p>Navíc Common Lisp dokáže pracovat s&nbsp;perzistentními objekty uloženými
v&nbsp;tzv.&nbsp;obrazu (<i>image</i>), což je podobný koncept, jaký nalezneme
například ve Smalltalku. Touto zajímavou technologií se budeme zabývat příště
(dnes je tato technologie díky perzistentním databázím méně důležitá, než
v&nbsp;osmdesátých letech, kdy byl tento koncept rozvinut).</p>

<img src="https://i.iinfo.cz/images/668/lisp1-3.png" class="image-365366" alt="&#160;" width="403" height="779" />
<p><i>Obrázek 5: Základem smyčky REPL je funkce <strong>EVAL</strong>. Zde je
uveden prakticky celý její zdrojový kód získaný z&nbsp;dvoustránkové publikace
o LISPu napsané McCarthym. Na první straně je popsán celý jazyk (jeho syntaxe i
sémantika), stranu druhou zabírá právě výpis funkce
<strong>EVAL</strong>.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Instalace Common Lispu a nastavení prostředí</h2>

<p>Jak již víme z&nbsp;předchozích kapitol, je nutné Common Lisp chápat jako
přesnou specifikaci jazyka a knihoven, nikoli jako konkrétní implementaci. Pro
Linux lze využít více implementací Common Lispu, přičemž pravděpodobně
nejpoužívanější je <i>CMU Common Lisp</i> zkracovaný na <i>CMUCL</i> a taktéž
<i>Steel Bank Common Lisp</i> neboli zkráceně <i>SBCL</i>. Existuje však
například i <i>GNU Common Lisp</i> atd. V&nbsp;této kapitole si ukážeme
instalaci <i>SBCL</i>, protože právě balíček s&nbsp;touto variantou Common
Lispu naleznete v&nbsp;repositářích mnoha distribucí Linuxu.</p>

<p>Instalace na systémy založené na balíčcích RPM (Fedora, RHEL):</p>

<pre>
# <strong>dnf install sbcl</strong>
&nbsp;
Last metadata expiration check: 0:25:24 ago on Fri 28 Jan 2022 07:36:45 AM EST.
Dependencies resolved.
================================================================================
 Package                Arch   Version           Repository                Size
================================================================================
Installing:
 sbcl                   x86_64 2.0.1-5.fc34      beaker-Fedora-Everything  15 M
Installing dependencies:
 cl-asdf                noarch 20101028-19.fc34  beaker-Fedora-Everything  87 k
 common-lisp-controller noarch 7.4-21.fc34       beaker-Fedora-Everything  24 k
&nbsp;
Transaction Summary
================================================================================
Install  3 Packages
&nbsp;
Total download size: 16 M
Installed size: 73 M
Is this ok [y/N]:
&nbsp;
Downloading Packages:
(1/3): common-lisp-controller-7.4-21.fc34.noarc 1.6 MB/s |  24 kB     00:00
(2/3): cl-asdf-20101028-19.fc34.noarch.rpm      838 kB/s |  87 kB     00:00
(3/3): sbcl-2.0.1-5.fc34.x86_64.rpm              24 MB/s |  15 MB     00:00
--------------------------------------------------------------------------------
Total                                            24 MB/s |  16 MB     00:00
Running transaction check
Transaction check succeeded.
Running transaction test
Transaction test succeeded.
Running transaction
  Preparing        :                                                        1/1
  Installing       : cl-asdf-20101028-19.fc34.noarch                        1/3
  Installing       : common-lisp-controller-7.4-21.fc34.noarch              2/3
  Installing       : sbcl-2.0.1-5.fc34.x86_64                               3/3
  Running scriptlet: sbcl-2.0.1-5.fc34.x86_64                               3/3
  Verifying        : cl-asdf-20101028-19.fc34.noarch                        1/3
  Verifying        : common-lisp-controller-7.4-21.fc34.noarch              2/3
  Verifying        : sbcl-2.0.1-5.fc34.x86_64                               3/3
&nbsp;
Installed:
  cl-asdf-20101028-19.fc34.noarch   common-lisp-controller-7.4-21.fc34.noarch
  sbcl-2.0.1-5.fc34.x86_64
&nbsp;
Complete!
</pre>

<p>Instalace na systémy založené na balíčcích Debianu:</p>

<pre>
# <strong>sudo apt-get install sbcl</strong>
&nbsp;
Reading package lists... Done
Building dependency tree       
Reading state information... Done
Suggested packages:
  sbcl-doc sbcl-source slime
The following NEW packages will be installed:
  sbcl
0 upgraded, 1 newly installed, 0 to remove and 2 not upgraded.
Need to get 0 B/8 439 kB of archives.
After this operation, 43,3 MB of additional disk space will be used.
Selecting previously unselected package sbcl.
(Reading database ... 291609 files and directories currently installed.)
Preparing to unpack .../sbcl_2%3a2.0.1-3_amd64.deb ...
Unpacking sbcl (2:2.0.1-3) ...
Setting up sbcl (2:2.0.1-3) ...
Processing triggers for man-db (2.9.1-1) ...
</pre>

<p>Prostředí SBCL se spustí následovně:</p>

<pre>
$ <strong>sbcl</strong>
&nbsp;
This is SBCL 2.0.1.debian, an implementation of ANSI Common Lisp.
More information about SBCL is available at &lt;http://www.sbcl.org/&gt;.
&nbsp;
SBCL is free software, provided as is, with absolutely no warranty.
It is mostly in the public domain; some portions are provided under
BSD-style licenses.  See the CREDITS and COPYING files in the
distribution for more information.
<strong>*</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: ona hvězdička na konci (přesněji řečeno
na samostatném řádku) je výzva (<i>prompt</i>), která se může v&nbsp;závislosti
na kontextu změnit.</div></p>

<p>SBCL není (alespoň většinou) slinkován s&nbsp;knihovnami typu
<i>readline</i>. Proč je to však tak důležité, že se o tom explicitně
zmiňujeme? Nepodpora <i>readline</i>, mj.&nbsp;znamená, že neexistuje historie
příkazového řádku, není možné používat editační příkazy typu
<strong>Ctrl+A</strong>, <strong>Ctrl+E</strong>, ani vyhledávání v&nbsp;dříve
zadaných příkazech pomocí <strong>Ctrl+R</strong> atd. A navíc nefunguje
automatické doplňování jmen symbolů klávesou <strong>Tab</strong>. Tyto
vlastnosti, které dnes od REPLů prakticky automaticky očekáváme, je možné do
jisté míry doplnit externím nástrojem <strong>rlwrap</strong>. Tomu můžeme
v&nbsp;případě potřeby předat soubor se symboly pro automatické doplňování.
Nástroj <strong>rlwrap</strong> se instaluje snadno:</p>

<pre>
$ <strong>dnf install rlwrap</strong>
&nbsp;
Last metadata expiration check: 0:33:16 ago on Sat 09 Apr 2022 06:45:42 AM EDT.
Dependencies resolved.
================================================================================
 Package              Arch        Version              Repository          Size
================================================================================
Installing:
 rlwrap               x86_64      0.45.2-1.fc34        updates            132 k
Installing dependencies:
 perl-File-Slurp      noarch      9999.32-3.fc34       beaker-Fedora       31 k
 perl-lib             x86_64      0.65-477.fc34        updates             25 k
&nbsp;
Transaction Summary
================================================================================
Install  3 Packages
&nbsp;
Total download size: 188 k
Installed size: 399 k
Is this ok [y/N]: y
Downloading Packages:
(1/3): perl-File-Slurp-9999.32-3.fc34.noarch.rp 3.6 MB/s |  31 kB     00:00    
(2/3): perl-lib-0.65-477.fc34.x86_64.rpm        197 kB/s |  25 kB     00:00    
(3/3): rlwrap-0.45.2-1.fc34.x86_64.rpm          649 kB/s | 132 kB     00:00    
--------------------------------------------------------------------------------
Total                                           142 kB/s | 188 kB     00:01     
</pre>

<p>S&nbsp;využitím <strong>rlwrap</strong> se bude prostředí <i>SBCL</i>
spouštět následujícím způsobem:</p>

<pre>
$ <strong>rlwrap sbcl</strong>
</pre>

<p>Se (zdánlivě) stejným výsledkem, ovšem v&nbsp;mnoha ohledech
s&nbsp;vylepšenou příkazovou řádkou:</p>

<pre>
This is SBCL 2.0.1-5.fc34, an implementation of ANSI Common Lisp.
More information about SBCL is available at &lt;http://www.sbcl.org/&gt;.
&nbsp;
SBCL is free software, provided as is, with absolutely no warranty.
It is mostly in the public domain; some portions are provided under
BSD-style licenses.  See the CREDITS and COPYING files in the
distribution for more information.
<strong>*</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti je však REPL Common Lispu
(resp.&nbsp;SBCL) většinou volán z&nbsp;integrovaného vývojového prostředí nebo
z&nbsp;programátorského textového editoru.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Interní debugger Common Lispu</h2>

<p>Důležitou součástí SBCL je i interní debugger, který umožňuje jak detekci
problémů, tak i interaktivní ladění a opravu kódu. Debugger je spuštěn buď při
vzniku chyby či výjimky, nebo například zavoláním funkce
<strong>cerror</strong>. Podívejme se na první možnost. Do prostředí SBCL
zapíšeme neznámý identifikátor (resp.&nbsp;symbol):</p>

<pre>
* <strong>foobar</strong>
</pre>

<p>Namísto pouhého konstatování, že došlo k&nbsp;chybě, se spustí debugger,
který uživateli nabídne několik možností:</p>

<pre>
debugger invoked on a UNBOUND-VARIABLE in thread
#&lt;THREAD "main thread" RUNNING {1000510083}&gt;:
  The variable FOOBAR is unbound.
&nbsp;
Type HELP for debugger help, or (SB-EXT:EXIT) to exit from SBCL.
&nbsp;
restarts (invokable by number or by possibly-abbreviated name):
  0: [CONTINUE   ] Retry using FOOBAR.
  1: [USE-VALUE  ] Use specified value.
  2: [STORE-VALUE] Set specified value and use it.
  3: [ABORT      ] Exit debugger, returning to top level.
&nbsp;
(SB-INT:SIMPLE-EVAL-IN-LEXENV FOOBAR #&lt;NULL-LEXENV&gt;)
0]
</pre>

<p>Odlišně se debugger zachová v&nbsp;případě, že se pokusíme zavolat neznámou
funkci:</p>

<pre>
* <strong>(foobar)</strong>
</pre>

<pre>
; in: FOOBAR
;     (FOOBAR)
;
; caught STYLE-WARNING:
;   undefined function: COMMON-LISP-USER::FOOBAR
;
; compilation unit finished
;   Undefined function:
;     FOOBAR
;   caught 1 STYLE-WARNING condition
&nbsp;
debugger invoked on a UNDEFINED-FUNCTION in thread
#&lt;THREAD "main thread" RUNNING {1000510083}&gt;:
  The function COMMON-LISP-USER::FOOBAR is undefined.
&nbsp;
Type HELP for debugger help, or (SB-EXT:EXIT) to exit from SBCL.
&nbsp;
restarts (invokable by number or by possibly-abbreviated name):
  0: [CONTINUE      ] Retry calling FOOBAR.
  1: [USE-VALUE     ] Call specified function.
  2: [RETURN-VALUE  ] Return specified values.
  3: [RETURN-NOTHING] Return zero values.
  4: [ABORT         ] Exit debugger, returning to top level.
&nbsp;
("undefined function")
</pre>

<p>Zajímavá je možnost <strong>RETURN-VALUE</strong>, která umožňuje pokračovat
ve (složitém) výpočtu nahrazením volání funkce za uživatelem zadanou hodnotu.
Například můžete spustit program, který má komunikovat se specifickou a
nedostupnou službou atd.</p>

<p>Příklad vyvolání debuggeru programově, tj.&nbsp;zavoláním funkce
<strong>cerror</strong>:</p>

<pre>
(defun factorial (n)
  (if (minusp n) (<strong>cerror "continue with negative value?" "negative value ~s" n</strong>))
  (* n (factorial (- n 1))))
</pre>

<p>Spustíme SBCL a načteme do něj zdrojový kód této funkce:</p>

<pre>
$ <strong>sbcl --load broken_factorial.lisp </strong>
&nbsp;
This is SBCL 2.0.1.debian, an implementation of ANSI Common Lisp.
More information about SBCL is available at &lt;http://www.sbcl.org/&gt;.
&nbsp;
SBCL is free software, provided as is, with absolutely no warranty.
It is mostly in the public domain; some portions are provided under
BSD-style licenses.  See the CREDITS and COPYING files in the
distribution for more information.
</pre>

<p>Po dosažení záporného <strong>n</strong> dojde k&nbsp;chybě a vyvolání
debuggeru:</p>

<pre>
* <strong>(factorial 10)</strong>
&nbsp;
debugger invoked on a SIMPLE-ERROR in thread
#&lt;THREAD "main thread" RUNNING {1000510083}&gt;:
  negative value -1
&nbsp;
Type HELP for debugger help, or (SB-EXT:EXIT) to exit from SBCL.
&nbsp;
restarts (invokable by number or by possibly-abbreviated name):
  0: [CONTINUE] continue with negative value?
  1: [ABORT   ] Exit debugger, returning to top level.
&nbsp;
(FACTORIAL -1)
   source: (CERROR "continue with negative value?" "negative value ~s" N)
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se vypíšou přesné
informace o chybě &ndash; ta je v&nbsp;Common Lispu typicky představována
textovou zprávou a nikoli objektem.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. První krůčky s&nbsp;Common Lispem</h2>

<p>V&nbsp;této kapitole se ve stručnosti seznámíme se základními vlastnostmi
LISPu, ovšem s&nbsp;ohledem na to, že již známe způsob programování ve Scheme a
Clojure (viz odkazy uvedené <a href="#k18">v&nbsp;osmácté kapitole</a>), takže
je možné se zaměřit na největší rozdíly. Ještě předtím se musíme alespoň ve
stručnosti seznámit s&nbsp;různými variantami funkce <strong>print</strong>,
protože tyto varianty budeme používat v&nbsp;demonstračních příkladech.
V&nbsp;následující tabulce je vypsána většina funkcí, které lze použít pro
zobrazení nějakých hodnot uživateli. Dnes využijeme funkce nazvané
<strong>princ</strong>, <strong>terpri</strong> a v&nbsp;některých příkladech i
funkci <strong>format</strong> (což je obdoba <strong>printf</strong>):</p>

<table>
<tr><th>Funkce</th><th>Stručný popis</th></tr>
<tr><td>print</td><td>tisk hodnoty takovým způsobem, aby ji bylo možné načíst zpět pomocí <strong>read</strong></td></tr>
<tr><td>prin1</td><td>dtto, ovšem bez konce řádku</td></tr>
<tr><td>princ</td><td>tisk hodnoty tak, aby byla dobře čitelná uživatelem (nekompatibilní s&nbsp;<strong>read</strong>)</td></tr>
<tr><td>terpri</td><td>odřádkování (<i>terminate print</i>)</td></tr>
<tr><td>format</td><td>naformátování zprávy podle zadané šablony a její tisk či vrácení ve formě řetězce</td></tr>
</table>

<p>V&nbsp;programovacím jazyce <i>LISP</i> je možné kromě základních
(interních, primitivních) funkcí definovat a následně i volat funkce
uživatelské, podobně jako v&nbsp;mnoha dalších programovacích jazycích. Ve
skutečnosti je velká část programů napsaných v&nbsp;LISPu tvořena právě
definicemi nových funkcí vystavěných na základě standardních funkcí a několika
speciálních forem. V&nbsp;<i>Common Lispu</i>, což je jedna
z&nbsp;nejrozšířenějších a také nejkomplexnějších implementací tohoto jazyka,
se funkce vytváří pomocí speciální formy nazvané <strong>defun</strong>
(<strong>de</strong>fine <strong>fun</strong>ction). Formát volání formy
<strong>defun</strong> při tvorbě nové funkce je velmi jednoduchý, programátor
si ovšem musí dát pozor na správné uzávorkování:</p>

<pre>
(defun název_funkce(parametry funkce) tělo funkce)
</pre>

<p>Návratovou hodnotou nově vytvořené funkce (po jejím zavolání a vykonání) je
hodnota výrazu tvořícího tělo funkce, což znamená, že není nutné používat
nějakou formu příkazu <strong>return</strong> tak, jak je tomu v&nbsp;mnoha
dalších programovacích jazycích. Ukažme si nyní způsob vytvoření dvou
jednoduchých funkcí a následného zavolání těchto funkcí:</p>

<pre>
<i>; funkce vracející druhou mocninu svého jediného parametru</i>
<strong>(defun sqr(x) (* x x))</strong>
&nbsp;
<i>; funkce, která sečte hodnoty svých dvou parametrů a vrátí výsledek součtu</i>
<strong>(defun plus(x y) (+ x y))</strong>
&nbsp;
<i>; zavoláme první funkci</i>
<strong>(sqr 42)</strong>
1764
&nbsp;
<i>; a nyní funkci druhou</i>
<strong>(plus 2 3)</strong>
5
&nbsp;
<i>; funkce lze samozřejmě libovolným způsobem kombinovat</i>
<strong>(plus (sqr 3) (sqr 4))</strong>
25
&nbsp;
<i>; podporovány jsou i zlomky</i>
<strong>(plus 1/2 2/3)</strong>
7/6
</pre>

<p><div class="rs-tip-major">Poznámka: existuje i možnost definice funkce
s&nbsp;nepovinnými parametry atd., což je téma navazujícího článku. Taktéž je
dobré upozornit na to, že ve Scheme se namísto <strong>defun</strong> používá
<strong>define</strong> s&nbsp;odlišným stylem zápisu a v&nbsp;Clojure
<strong>defn</strong>.</div></p>

<p>Common Lisp patří mezi ty dialekty Lispu, které pokládají rovnítko mezi
hodnotou <strong>nil</strong> a prázdným seznamem (což jsou zcela ekvivalentní
hodnoty):</p>

<pre>
<strong>nil</strong>
NIL
&nbsp;
<strong>'()</strong>
NIL
&nbsp;
<strong>()</strong>
NIL
</pre>

<p>Globální proměnné je vhodné před jejich použitím deklarovat:</p>

<pre>
(defvar x 1)
</pre>

<p>Teprve poté lze měnit jejich hodnotu, například přes <strong>setf</strong>
(zde se Common Lisp liší například od Elispu):</p>

<pre>
(setf x 2)
</pre>

<p>Pokus o nastavení nedefinované proměnné vede k&nbsp;zobrazení varování:</p>

<pre>
* <strong>(setf y 10)</strong>
&nbsp;
; in: SETF Y
;     (SETF Y 10)
; ==&gt;
;   (SETQ Y 10)
; 
; caught WARNING:
;   undefined variable: COMMON-LISP-USER::Y
; 
; compilation unit finished
;   Undefined variable:
;     Y
;   caught 1 WARNING condition
10
</pre>

<p>Definice konstanty:</p>

<pre>
(defconstant A 42)
</pre>

<p>Typová kontrola v&nbsp;době překladu (tomuto zajímavému tématu bude věnován
samostatný článek):</p>

<pre>
* <strong>(defun foo () (concatenate 'string "+" A))</strong>
&nbsp;
; in: DEFUN FOO
;     (CONCATENATE 'STRING "+" A)
; 
; caught WARNING:
;   Constant 42 conflicts with its asserted type SEQUENCE.
;   See also:
;     The SBCL Manual, Node "Handling of Types"
; 
; compilation unit finished
;   caught 1 WARNING condition
FOO
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Přerušení výpočtu a jeho obnovení</h2>

<p>Debugger, který je součástí většiny implementací Common Lispu, dokáže
zareagovat i na běhovou chybu. Ovšem nikoli tak, že by pouze vypsal obsah
zásobníkových rámců (což je například chování Pythonu i JVM &ndash; kde se tak
možnost ladění do jisté míry ztratí). Naopak &ndash;
k&nbsp;&bdquo;rozvinovací&ldquo; (<i>unwinding</i>) fázi nedojde,
resp.&nbsp;přesněji řečeno se Common Lisp zeptá programátora, jakou operaci má
konkrétně provést. Například je možné kód opravit a spustit znovu, a to přesně
z&nbsp;toho místa, kde byl běh přerušen (tedy s&nbsp;využitím původního obsahu
zásobníkových rámců).</p>

<p>Podívejme se na konkrétní, velmi jednoduchý příklad. Jedná se o klasický
rekurzivní výpočet faktoriálu, ovšem používá se zde neznámý symbol
<strong>default</strong>, který není nikde nastaven:</p>

<pre>
(defun factorial (n)
    (cond ((zerop n) <strong>default</strong>)
          (T (* n (factorial (- n 1))))))
</pre>

<p>Pokusme se nyní tento zdrojový kód načíst do SBCL:</p>

<pre>
$ <strong>sbcl --load broken_factorial2.lisp </strong>
</pre>

<p>V&nbsp;průběhu načítání se již dopředu vypíše varování a nedefinované
proměnné. Ovšem kód se načte, neboť Lisp předpokládá, že se proměnná může (na
globální úrovni) kdykoli později objevit, a to ještě před zavoláním funkce
<strong>factorial</strong> (bylo by ostatně zajímavé tento koncept přidat i do
dalších podobně koncipovaných jazyků):</p>

<pre>
This is SBCL 2.0.1.debian, an implementation of ANSI Common Lisp.
More information about SBCL is available at &lt;http://www.sbcl.org/&gt;.
&nbsp;
SBCL is free software, provided as is, with absolutely no warranty.
It is mostly in the public domain; some portions are provided under
BSD-style licenses.  See the CREDITS and COPYING files in the
distribution for more information.
&nbsp;
; file: /home/ptisnovs/src/lisp-families/common-lisp/broken_factorial2.lisp
; in: DEFUN FACTORIAL
;     (COND ((ZEROP N) DEFAULT) (T (* N (FACTORIAL (- N 1)))))
; ==&gt;
;   (IF (ZEROP N)
;       DEFAULT
;       (THE T (* N (FACTORIAL (- N 1)))))
; 
; caught WARNING:
;   undefined variable: COMMON-LISP-USER::DEFAULT
; 
; compilation unit finished
;   <strong>Undefined variable:</strong>
;     <strong>DEFAULT</strong>
;   caught 1 WARNING condition
</pre>

<p>Nyní se pokusme funkci <strong>factorial</strong> zavolat:</p>

<pre>
* <strong>(factorial 10)</strong>
</pre>

<p>Podle očekávání dojde k&nbsp;chybě, ovšem debugger nám umožňuje pokračovat
ve výpočtu zadáním specifikované hodnoty, která se za <strong>default</strong>
dosadí:</p>

<pre>
debugger invoked on a UNBOUND-VARIABLE in thread
#&lt;THREAD "main thread" RUNNING {1000560083}&gt;:
  The variable DEFAULT is unbound.
&nbsp;
Type HELP for debugger help, or (SB-EXT:EXIT) to exit from SBCL.
&nbsp;
restarts (invokable by number or by possibly-abbreviated name):
  0: [CONTINUE   ] Retry using DEFAULT.
  1: <strong>[USE-VALUE  ] Use specified value.</strong>
  2: [STORE-VALUE] Set specified value and use it.
  3: [ABORT      ] Exit debugger, returning to top level.
&nbsp;
(FACTORIAL 0)
   source: (COND ((ZEROP N) DEFAULT) (T (* N (FACTORIAL (- N 1)))))
</pre>

<p>Zkusme tedy vybrat možnost číslo 1 a dosadit hodnotu
<strong>default</strong>:</p>

<pre>
0] <strong>1</strong>
&nbsp;
Enter a form to be evaluated: <strong>1</strong>
3628800
</pre>

<p><div class="rs-tip-major">Poznámka: důležité je si uvědomit, že <i>až</i> po
zadání hodnoty došlo k&nbsp;fázi rozbalení při výpočtu faktoriálu,
tj.&nbsp;desetkrát se provedl výpočet <strong>n * factorial(n-1)</strong> a
nakonec jsme dostali očekávaný výsledek.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Multiparadigmatický programovací jazyk</h2>

<p>O Lispu (resp.&nbsp;někdy dokonce přímo o Common Lispu) se v&nbsp;některých
dokumentech tvrdí, že se jedná o funkcionální jazyk. Ve skutečnosti je Common
Lisp spíše multiparadigmatickým jazykem, který mj.&nbsp;umožňuje vytvářet
programy s&nbsp;využitím metodiky funkcionálního programování (funkce, funkce
vyššího řádu, uzávěry, neměnitelné hodnoty, striktně lokální proměnné). Ovšem
stejně dobře je možné použít klasický imperativní styl (měnitelné seznamy,
globální proměnné, ...), objektově orientovaný styl (typicky s&nbsp;využitím
<i>CLOS</i> &ndash; což je téma na samostatný článek) a především se Common
Lisp používá i jako metajazyk. Navíc je možné do LISPu přidávat další doménově
specifické jazyky nebo i například do něho &bdquo;vložit&ldquo; další
programovací jazyk (příkladem tohoto typu je projekt <a
href="https://github.com/phantomics/april">April</a>, což je vlastně APL
dostupné přímo z&nbsp;LISPu).</p>

<p>Ostatně podívejme se na následující zcela legální kód napsaný pro Common
Lisp, který se podobá starému (dobrému?) BASICu s&nbsp;čísly řádků a skoky
vytvořenými s&nbsp;využitím <strong>go</strong> (v&nbsp;BASICu pomocí
<strong>GOTO</strong>):</p>

<pre>
(tagbody
  10 (print "Hello!")
  20 (sleep 2)
  30 (go 10))
</pre>

<p><div class="rs-tip-major">Poznámka: toto není, i když by se to mohlo tak
jevit, zcela umělý příklad, protože <strong>tagbody</strong>
atd.&nbsp;nalezneme v&nbsp;expanzi mnoha maker, například i ve smyčce
<strong>loop</strong> popsané dále.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Makrosystém Common Lispu</h2>

<p>Jednou z&nbsp;nejzajímavějších vlastností <i>LISPu</i> (přesněji řečeno
některých jeho implementací, jejichž typickým zástupcem je i <i>Common
Lisp</i>) je možnost tvorby maker. Vzhledem k&nbsp;tomu, že LISPovské programy
jsou tvořeny, stejně jako data, pomocí rekurzivně vnořených seznamů, jsou
LISPovská makra založena na manipulaci se seznamy tvořícími program, což je
velký rozdíl například oproti makrům implementovaným v&nbsp;céčkovém
preprocesoru, kde se jedná o poměrně jednoduché (a z&nbsp;pohledu programátora
značně primitivní) textové záměny. Vzhledem k&nbsp;tomu, že LISPovská makra
dokážou manipulovat s&nbsp;vlastním programem, je možné pomocí nich vytvářet
například úplně nové jazykové konstrukce (různé smyčky, podmíněné příkazy,
částečně vyhodnocované formy atd.) s&nbsp;vlastní syntaxí, což je poměrně
unikátní vlastnost, kterou u většiny dalších programovacích jazyků nenajdeme.
Způsob definice maker se v&nbsp;některých ohledech podobá definici funkcí, ale
mezi funkcemi a makry existuje jeden zásadní rozdíl.</p>

<p>LISPovské funkce získávají jako svoje argumenty LISPovské hodnoty,
tj.&nbsp;většinou atomy, (anonymní) funkce nebo seznamy, a vrací taktéž nějakou
LISPovskou hodnotu &ndash; opět se může jednat o atom, (anonymní) funkci nebo
seznam. Funkce jsou vyhodnocovány (volány) až při spuštění programu. Makra jako
svůj vstup získávají LISPovský kód (zapsaný formou rekurzivně zanořeného
seznamu) a vrací taktéž LISPovský kód, což nepředstavuje oproti funkcím žádný
zásadnější rozdíl. Ovšem na rozdíl od funkcí jsou makra volána již při prvotním
zpracovávání programu, podobně jako jsou céčková makra zpracovávána céčkovým
preprocesorem (cpp) ještě před vlastní kompilací. Teprve výsledek volání makra
(nazývaný taktéž expanze makra) je považován za zápis výrazu, který může být
dále zpracován, tj.&nbsp;buď vyhodnocen (interpretační varianty LISPu) nebo
zkompilován (varianty LISPu vybavené překladačem). Poznamenejme ještě, že
v&nbsp;těle makra se může vyskytovat volání dalšího makra, což znamená, že LISP
musí při expanzi maker použít rekurzi.</p>

<p><div class="rs-tip-major">Poznámka: makry se budeme podrobněji zabývat
příště.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. LISP jako jazyk pro tvorbu (doménově specifických) jazyků</h2>

<p>Doménově specifické jazyky (anglicky <i>DSL</i> neboli <i>Domain-Specific
Language</i>) jsou velmi důležitou součástí informatiky a mnohé z&nbsp;nich
jsou velmi úspěšné a rozšířené do mnoha oblastí. Za připomenutí stojí například
<i>jazyk pro popis regulárních výrazů</i>, jenž je podporován jak mnoha
nástroji, tak i knihovnami, popř.&nbsp;je přímo součástí některých obecných
programovacích jazyků (Perl apod.). I v&nbsp;některých dalších případech je
tento přístup velmi užitečný a rozšířený, ostatně například SQL je
s&nbsp;velkou pravděpodobností <a
href="https://www.tiobe.com/tiobe-index/">nejpopulárnějším samostatně chápaným
doménově specifickým jazykem</a> neboli DSL vůbec, protože umožňuje snadné
optimalizace dotazů a vůbec pokládání dotazů čitelným, pochopitelným a
přenositelným způsobem. Dalším doménově specifickým jazykem, s&nbsp;nímž jsme
se již na stránkách Roota v&nbsp;rámci několika článků seznámili, je jazyk
<i>Gherkin</i> určený pro popis chování systémů a pro psaní BDD testů. Dalším
příkladem je <a
href="https://www.root.cz/clanky/graficky-metaformat-postscript/">PostScript</a>.</p>

<p>Mnohé z&nbsp;doménově specifických jazyků nejsou <a
href="https://cs.wikipedia.org/wiki/Turingovsk%C3%A1_%C3%BAplnost">Turingovsky
kompletní (úplný)</a>, což však není nedostatek, ale mnohdy naopak požadovaná
vlastnost. Příkladem mohou být DSL, v&nbsp;nichž není možné zapsat programové
smyčky ani rekurzi &ndash; tudíž je většinou výpočet resp.&nbsp;vyhodnocení
výrazu časově dosti přesně určené. Další DSL neumožňují explicitní alokaci
paměti, což může být v&nbsp;dané oblasti použití taktéž výhodné. Nasazení DSL
oproti plnohodnotnému jazyku tedy může být výhodné, protože cíleně omezené
možnosti takového jazyka můžeme chápat jako formu &bdquo;sémantického
sandboxingu&ldquo; (právě proto jsou regulární výrazy <i>regulární</i>).</p>

<p><div class="rs-tip-major">Poznámka: na tomto místě je zajímavé zmínit
PostScript, který je sice DSL, konkrétně specifickým jazykem pro popis
tiskových stran, ovšem oproti mnoha jiným DSL je Turingovsky kompletní. To
například umožňuje vykreslování procedurální grafiky (viz například <a
href="https://www.root.cz/clanky/fraktaly-v-signaturach-a-dalsi-hacky/#k03">tyto
příklady</a>), ovšem pokud tyto zcela korektní PostScriptové soubory spustíte
na podnikové tiskárně, můžete se dočkat nemilého překvapení
v&nbsp;několikahodinové odstávce, popř.&nbsp;nepříjemného e-mailu z&nbsp;IT
oddělení :-)</div></p>

<p>Právě LISP a tím pádem i Common Lisp, je velmi vhodným jazykem pro tvorbu
doménově specifických jazyků, a to z&nbsp;toho důvodu, že lze relativně snadno
manipulovat s&nbsp;abstraktním syntaktickým stromem (s&nbsp;využitím maker)
ještě před vlastním zpracováním kódu ve funkci <strong>eval</strong>. A
příkladů DSL vytvořených v&nbsp;LISPu existuje poměrně velké množství.
V&nbsp;navazujících kapitolách se seznámíme s&nbsp;makrem
<strong>loop</strong>, které do Common Lispu přidává DSL pro tvorbu různých
programových smyček, a to mnohdy i značně složitých:</p>

<pre>
(loop repeat 1000
      for x = (random 100)
      if (evenp x)
        collect x into evens
      else
        collect x into odds
      finally (return (values evens odds)))
</pre>

<p>Dále knihovna <a
href="https://github.com/ruricolist/spinneret">spinneret</a> umožňuje zápis
struktury HTML stránky přímo v&nbsp;LISPu, pochopitelně s&nbsp;možností použití
maker atd.:</p>

<pre>
(let ((*html-style* :human))
  (with-html
    (:div
      (:p "Text " (:a "link text") " more text"))))
</pre>

<p>Z&nbsp;dalších známějších DSL můžeme jmenovat i <a
href="https://github.com/fukamachi/sxql">SxQL</a> pro zápis dotazů do
databáze:</p>

<pre>
(select (:title :author :year)
  (from :books)
  (where (:and (:&gt;= :year 1995)
               (:&lt; :year 2010)))
  (order-by (:desc :year)))
</pre>

<p><div class="rs-tip-major">Poznámka: síla těchto DSL se projeví zejména ve
chvíli, kdy je zapotřebí dynamicky předávat parametry, proměnný počet parametrů
atd. (kdo by taky chtěl neustále <a
href="https://stackoverflow.com/questions/69217606/bulk-insert-rows-from-an-array-to-an-sql-server-with-golang/69217747#69217747">skládat
SQL příkazy ručně</a> že?)</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. DSL pro tvorbu programových smyček &ndash; makro <strong>loop</strong></h2>

<p>Smyčka <strong>loop</strong> ve formě, v&nbsp;jaké byla navržena
v&nbsp;Common Lispu (a poté částečně převzata do Elispu), programátorům nabízí
svůj vlastní doménově specifický jazyk (DSL). Z&nbsp;dalších demonstračních
příkladů bude patrné, že tento jazyk používá styl zápisu, který je kombinací
klasických strukturovaných jazyků (Algol, Pascal, C) a možností LISPu. Je tomu
tak z&nbsp;toho důvodu, aby bylo přímo ze zápisu smyčky, typicky již po
přečtení prvního řádku, patrné, jak bude smyčka prováděna. K&nbsp;tomuto účelu
se uvnitř smyčky <strong>loop</strong> používají symboly <strong>for</strong>,
<strong>repeat</strong>, <strong>in</strong>, <strong>finally</strong> atd.,
které mají svůj speciální význam, ale pouze uvnitř samotné formy
<strong>loop</strong>. Tím se <strong>loop</strong> do značné míry liší od
smyček v&nbsp;klasických jazycích, které programátory &bdquo;nutí&ldquo;
realizovat kód smyčky v&nbsp;jejím těle, což nemusí být vždy idiomatické.</p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;Common Lispu je možné tyto
symboly zapisovat i ve formě keywordů, tj.&nbsp;s&nbsp;dvojtečkami na začátku,
což může být čitelnější.</div></p>

<p>Podívejme se nyní na pravděpodobně nejjednodušší prakticky použitelný
příklad využívající smyčku <strong>loop</strong>, v&nbsp;níž bude použita
dvojice symbolů se speciálním významem, o nichž jsme se zmínili
v&nbsp;předchozím odstavci. Konkrétně budeme implementovat programovou smyčku,
jejíž tělo se bude n-krát opakovat. K&nbsp;zápisu této varianty smyčky nám
pomohou dva symboly se jmény <strong>repeat</strong> a <strong>do</strong>.
Povšimněte si, že zápis smyčky vypadá prakticky stejně, jako by tomu bylo
v&nbsp;některém z&nbsp;klasických strukturovaných jazyků (samozřejmě pokud si
odmyslíme kulaté závorky, do kterých toto makro vkládáme a které jsou
v&nbsp;Lispu v&nbsp;této formě povinné):</p>

<pre>
(<strong>loop</strong> <strong>repeat</strong> 10 <strong>do</strong>
      (princ "Hello world!")
      (terpri))
</pre>

<p>Makro <strong>loop</strong> zavolané tímto způsobem nevrací žádnou hodnotu,
takže se předpokládá, že smyčka vykoná svoji činnost jen díky tomu, že některá
funkce volaná při každé iteraci bude mít vedlejší efekt, například že vypíše
zprávu na obrazovku atd., což je ostatně přesně náš případ. Po spuštění výše
popsané smyčky se na výstupu skutečně zobrazí deset totožných zpráv:</p>

<pre>
Hello world!
Hello world!
Hello world!
Hello world!
Hello world!
Hello world!
Hello world!
Hello world!
Hello world!
Hello world!
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že při použití
<strong>loop-repeat-do</strong> vlastně nemáme k&nbsp;dispozici počitadlo
smyčky. V&nbsp;případě, že je nutné počitadlo využít, je výhodnější použít
další varianty smyčky, například <strong>loop-for</strong>, které budou popsány
dále.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Použití klauzulí <strong>while</strong> a <strong>until</strong></h2>

<p>Ve smyčce <strong>loop</strong> je možné v&nbsp;případě potřeby použít i
klauzule <strong>while</strong> a <strong>until</strong>, za nimiž se zapisuje
podmínka. Ta je od těla smyčky oddělena speciálním symbolem
<strong>do</strong>, takže zápisy vypadají následovně:</p>

<p>Vyhodnocení podmínky na začátku každé iterace, tělo smyčky se zavolá, pokud
je podmínka splněna:</p>

<pre>
(<strong>loop</strong> <strong>while</strong> podmínka <strong>do</strong> ...)
</pre>

<p>Vyhodnocení podmínky na začátku každé iterace, tělo smyčky se zavolá, pokud
podmínka splněna naopak <strong>není</strong> (po splnění podmínky se smyčka
opustí):</p>

<pre>
(<strong>loop</strong> <strong>until</strong> podmínka <strong>do</strong> ...)
</pre>

<p>Demonstrační příklad bude velmi jednoduchý, protože v&nbsp;něm použijeme
jedinou řídicí proměnnou <strong>i</strong>, kterou budeme nejprve zmenšovat o
jedničku a poté v&nbsp;druhé smyčce naopak zvyšovat až do chvíle, kdy překročí
hodnotu 10:</p>

<pre>
(defvar i 10)
&nbsp;
(<strong>loop</strong> <strong>while</strong> (&gt; i 0) <strong>do</strong>
      (format T "i = ~d~%" i)
      (setq i (- i 1)))
&nbsp;
(princ "rebound")
(terpri)
&nbsp;
(<strong>loop</strong> <strong>until</strong> (&gt; i 10) <strong>do</strong>
      (format T "i = ~d~%" i)
      (setq i (+ i 1)))
</pre>

<p>Výsledek bude vypadat takto:</p>

<pre>
i = 10
i = 9
i = 8
i = 7
i = 6
i = 5
i = 4
i = 3
i = 2
i = 1
rebound
i = 0
i = 1
i = 2
i = 3
i = 4
i = 5
i = 6
i = 7
i = 8
i = 9
i = 10
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Různé varianty počítané smyčky typu <strong>for</strong></h2>

<p>Makro <strong>loop</strong> samozřejmě podporuje i tvorbu klasických
programových smyček, v&nbsp;nichž se postupně mění hodnota počitadla. Základní
forma této smyčky vypadá následovně:</p>

<pre>
(<strong>loop</strong> <strong>for</strong> i <strong>to</strong> 10 <strong>do</strong>
      (format T "i = ~d~%" i))
</pre>

<p>Výsledek ukazuje, že se počítá od nuly a končí se až po dosažení koncové
hodnoty (pozor &ndash; ne o jedničku dříve):</p>

<pre>
i = 0
i = 1
i = 2
i = 3
i = 4
i = 5
i = 6
i = 7
i = 8
i = 9
i = 10
</pre>

<p>Alternativně můžeme v&nbsp;tomto případě namísto symbolu <strong>to</strong>
použít spíše <strong>upto</strong>:</p>

<pre>
(<strong>loop</strong> <strong>for</strong> i <strong>upto</strong> 10 <strong>do</strong>
      (format T "i = ~d~%" i))
</pre>

<p>A to se shodným výsledkem:</p>

<pre>
i = 0
i = 1
i = 2
i = 3
i = 4
i = 5
i = 6
i = 7
i = 8
i = 9
i = 10
</pre>

<p>Mnohdy potřebujeme, aby horní meze nebylo dosaženo a smyčka skončila těsně
předtím (což do určité míry odpovídá Pythonovskému <strong>for i in
range(x,y)</strong>). Namísto komplikovaných výpočtů použijte
<strong>below</strong> a nikoli <strong>to</strong> či
<strong>upto</strong>:</p>

<pre>
(<strong>loop</strong> <strong>for</strong> i <strong>below</strong> 10 <strong>do</strong>
      (format T "i = ~d~%" i))
</pre>

<p>V&nbsp;tomto případě se skutečně počítá jen do 9 a nikoli 10:</p>

<pre>
i = 0
i = 1
i = 2
i = 3
i = 4
i = 5
i = 6
i = 7
i = 8
i = 9
</pre>

<p>Užitečná je možnost přidání další (libovolné) podmínky, která pro počitadlo
musí platit. Jsou přeskočeny ty iterace, kdy podmínka není splněna (ovšem
smyčka není ukončena):</p>

<pre>
(<strong>loop</strong> <strong>for</strong> i <strong>below</strong> 10 <strong>when</strong> (evenp i) <strong>do</strong>
      (format T "i = ~d~%" i))
</pre>

<p>Výsledkem je v&nbsp;tomto případě sekvence sudých čísel:</p>

<pre>
i = 0
i = 2
i = 4
i = 6
i = 8
</pre>

<p>Popř.&nbsp;naopak:
</p>
<pre>
(<strong>loop</strong> <strong>for</strong> i <strong>below</strong> 10 <strong>when</strong> (oddp i) <strong>do</strong>
      (format T "i = ~d~%" i))
</pre>

<p>Výsledkem je nyní sekvence čísel lichých:</p>

<pre>
i = 1
i = 3
i = 5
i = 7
i = 9
</pre>

<p>Samozřejmě je možné v&nbsp;případě potřeby specifikovat i počáteční hodnotu
počitadla; tj.&nbsp;nemusí se vždy začínat na nule:</p>

<pre>
(<strong>loop</strong> <strong>for</strong> i <strong>from</strong> 1 <strong>to</strong> 10 <strong>do</strong>
      (format T "i = ~d~%" i))
</pre>

<p>Výsledek:</p>

<pre>
i = 1
i = 2
i = 3
i = 4
i = 5
i = 6
i = 7
i = 8
i = 9
i = 10
</pre>

<p>Totožná smyčka, ovšem s&nbsp;jiným symbolem (lépe čitelným):</p>

<pre>
(<strong>loop</strong> <strong>for</strong> i <strong>from</strong> 1 <strong>upto</strong> 10 <strong>do</strong>
      (format T "i = ~d~%" i))
</pre>

<p>Výsledek je stejný:</p>

<pre>
i = 1
i = 2
i = 3
i = 4
i = 5
i = 6
i = 7
i = 8
i = 9
i = 10
</pre>

<p>Kombinace <strong>from</strong> a <strong>below</strong>:</p>

<pre>
(<strong>loop</strong> <strong>for</strong> i <strong>from</strong> 1 <strong>below</strong> 10 <strong>do</strong>
      (format T "i = ~d~%" i))
</pre>

<p>Výsledek je kratší o poslední iteraci:</p>

<pre>
i = 1
i = 2
i = 3
i = 4
i = 5
i = 6
i = 7
i = 8
i = 9
</pre>

<p>Další kombinace již obsahují klauzuli <strong>when</strong>:</p>

<pre>
(<strong>loop</strong> <strong>for</strong> i <strong>from</strong> 1 <strong>to</strong> 10 <strong>when</strong> (evenp i) <strong>do</strong>
      (format T "i = ~d~%" i))
</pre>

<p>Výsledek:</p>

<pre>
i = 2
i = 4
i = 6
i = 8
i = 10
</pre>

<pre>
(<strong>loop</strong> <strong>for</strong> i <strong>from</strong> 1 <strong>upto</strong> 10 <strong>when</strong> (evenp i) <strong>do</strong>
      (format T "i = ~d~%" i))
</pre>

<p>Výsledek:</p>

<pre>
i = 2
i = 4
i = 6
i = 8
i = 10
</pre>

<pre>
(<strong>loop</strong> <strong>for</strong> i <strong>upfrom</strong> 1 <strong>upto</strong> 10 <strong>when</strong> (evenp i) <strong>do</strong>
         (princ (format "i = %d\n" i)))
</pre>

<p>Výsledek:</p>

<pre>
i = 2
i = 4
i = 6
i = 8
i = 10
</pre>

<pre>
(<strong>loop</strong> <strong>for</strong> i <strong>from</strong> 1 <strong>below</strong> 10 <strong>when</strong> (evenp i) <strong>do</strong>
         (princ (format "i = %d\n" i)))

</pre>

<p>Výsledek:</p>

<pre>
i = 2
i = 4
i = 6
i = 8
</pre>

<p>Další demonstrační příklad si již ukážeme v&nbsp;celku. Používá se
v&nbsp;něm symbol <strong>by</strong>, za nímž se udává krok, tj.&nbsp;o jakou
hodnotu se bude počitadlo měnit. Výchozí hodnotou je pochopitelně jednička:</p>

<pre>
(<strong>loop</strong> <strong>for</strong> i <strong>from</strong> 0 <strong>to</strong> 30 <strong>by</strong> 3 <strong>do</strong>
         (princ (format "i = %d\n" i)))
&nbsp;
(princ "---------------------------\n")
&nbsp;
(<strong>loop</strong> <strong>for</strong> i <strong>from</strong> 0 <strong>upto</strong> 30 <strong>by</strong> 3 <strong>do</strong>
         (princ (format "i = %d\n" i)))
&nbsp;
(princ "---------------------------\n")
&nbsp;
(<strong>loop</strong> <strong>for</strong> i <strong>upfrom</strong> 0 <strong>upto</strong> 30 <strong>by</strong> 3 <strong>do</strong>
         (princ (format "i = %d\n" i)))
&nbsp;
(princ "---------------------------\n")
&nbsp;
(<strong>loop</strong> <strong>for</strong> i <strong>upfrom</strong> 0 <strong>below</strong> 30 <strong>by</strong> 3 <strong>do</strong>
         (princ (format "i = %d\n" i)))
&nbsp;
(princ "===========================\n")
&nbsp;
(<strong>loop</strong> <strong>for</strong> i <strong>from</strong> 0 <strong>to</strong> 30 <strong>by</strong> 3 <strong>when</strong> (evenp i) <strong>do</strong>
         (princ (format "i = %d\n" i)))
&nbsp;
(princ "---------------------------\n")
&nbsp;
(<strong>loop</strong> <strong>for</strong> i <strong>from</strong> 0 <strong>upto</strong> 30 <strong>by</strong> 3 <strong>when</strong> (evenp i) <strong>do</strong>
         (princ (format "i = %d\n" i)))
&nbsp;
(princ "---------------------------\n")
</pre>

<p>Prozatím jsme v&nbsp;předchozích smyčkách počitadlo vždy zvyšovali, ať již o
jedničku nebo o jinou hodnotu. Počítat je však možné i opačným směrem.
V&nbsp;tomto případě však nestačí za <strong>by</strong> zadat záporné číslo!
Je nutné použít jiný zápis, a to s&nbsp;využitím symbolů
<strong>downto</strong> nebo <strong>above</strong>. Opět si ukažme některé
povolené kombinace (pozor na rozdílné chování <strong>downto</strong> a
<strong>above</strong>):</p>

<pre>
(<strong>loop</strong> <strong>for</strong> i <strong>from</strong> 10 <strong>downto</strong> 1 <strong>do</strong>
         (princ (format "i = %d\n" i)))
&nbsp;
(princ "---------------------------\n")
&nbsp;
(<strong>loop</strong> <strong>for</strong> i <strong>from</strong> 10 <strong>above</strong> 1 <strong>do</strong>
         (princ (format "i = %d\n" i)))
&nbsp;
(princ "---------------------------\n")
&nbsp;
(<strong>loop</strong> <strong>for</strong> i <strong>upfrom</strong> 10 <strong>above</strong> 1 <strong>do</strong>
         (princ (format "i = %d\n" i)))
&nbsp;
(princ "---------------------------\n")
&nbsp;
(<strong>loop</strong> <strong>for</strong> i <strong>from</strong> 10 <strong>downto</strong> 1 <strong>when</strong> (evenp i) <strong>do</strong>
         (princ (format "i = %d\n" i)))
&nbsp;
(princ "---------------------------\n")
&nbsp;
(<strong>loop</strong> <strong>for</strong> i <strong>from</strong> 10 <strong>above</strong> 1 <strong>when</strong> (evenp i) <strong>do</strong>
         (princ (format "i = %d\n" i)))
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Procházení prvky seznamu aneb smyčka typu <strong>for-each</strong></h2>

<p>V&nbsp;případě, že se má procházet všemi prvky seznamu (nebo vektoru), lze
použít klauzuli <strong>for</strong> <strong>in</strong>, která používá
následující styl zápisu:</p>

<pre>
(<strong>loop</strong> <strong>for</strong> prvek <strong>in</strong> seznam
  ...
  ...
  ...
  tělo smyčky
  ...
  ...
  ...)
</pre>

<p>Vidíme, že se tento zápis opět do značné míry podobá syntaxi, s&nbsp;níž se
setkáme v&nbsp;běžných programovacích jazycích. Typicky se tato smyčka používá
ve chvíli, kdy se v&nbsp;ní volá funkce s&nbsp;vedlejším efektem. Pokud tomu
tak není a je nutné ze smyčky vrátit výsledek aplikace nějaké funkce na prvky
seznamu, používá se klauzule <strong>collect</strong>, a to přibližně tímto
způsobem:</p>

<pre>
(<strong>loop</strong> <strong>for</strong> prvek <strong>in</strong> seznam
    collect prvek)
</pre>

<p>V&nbsp;následujícím příkladu je tato varianta smyčky použita, i když se ve
skutečnosti dá nahradit funkcí <strong>mapcar</strong>:</p>

<pre>
(defvar lst '(1 2 3 4 5 6 7 8 9 10))
&nbsp;
(print
    (<strong>loop</strong> <strong>for</strong> i <strong>in</strong> lst
          collect i))
&nbsp;
(print
    (<strong>loop</strong> <strong>for</strong> i <strong>in</strong> lst
          collect (* i i)))
&nbsp;
&nbsp;
(defun factorial (n)
    (cond ((zerop n) 1)
          (T (* n (factorial (- n 1))))))
&nbsp;
(print
    (<strong>loop</strong> <strong>for</strong> i <strong>in</strong> lst
          collect (factorial i)))
</pre>

<p>Výsledky:</p>

<pre>
(0 1 2 3 4 5 6 7 8 9 10)
&nbsp;
(0 1 4 9 16 25 36 49 64 81 100)
&nbsp;
(1 1 2 6 24 120 720 5040 40320 362880 3628800)
</pre>

<p>Existuje ještě jedna varianta smyčky <strong>for-each</strong>, ovšem tato
varianta používá zápis se symbolem <strong>on</strong> a nikoli
<strong>in</strong>:</p>

<pre>
(<strong>loop</strong> <strong>for</strong> prvek <strong>on</strong> seznam
    collect prvek)
</pre>

<p>Tato varianta prochází seznamem odlišně &ndash; v&nbsp;první iteraci se do
řídicí proměnné smyčky vloží celý seznam, ve druhé iteraci seznam bez prvního
prvku atd. atd.:</p>

<pre>
(defvar lst '(1 2 3 4 5 6 7 8 9 10))
&nbsp;
(defvar result
   (<strong>loop</strong> <strong>for</strong> i <strong>on</strong> lst
          collect i))
&nbsp;
(dolist (item result)
  (print item))
</pre>

<p>Výsledek nyní bude značně odlišný &ndash; bude se totiž jednat o seznam
seznamů:</p>

<pre>
(0 1 2 3 4 5 6 7 8 9 10)
&nbsp;
(1 2 3 4 5 6 7 8 9 10)
&nbsp;
(2 3 4 5 6 7 8 9 10)
&nbsp;
(3 4 5 6 7 8 9 10)
&nbsp;
(4 5 6 7 8 9 10)
&nbsp;
(5 6 7 8 9 10)
&nbsp;
(6 7 8 9 10)
&nbsp;
(7 8 9 10)
&nbsp;
(8 9 10)
&nbsp;
(9 10)
&nbsp;
(10)
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Vybrané další možnosti poskytované makrem <strong>loop</strong></h2>

<p>V&nbsp;předchozích demonstračních příkladech jsme pro získání výsledné
hodnoty smyčky používali klauzuli <strong>collect</strong>. Použít je však
možné i klauzuli <strong>append</strong>, která pracuje podobně, ale pokud této
klauzuli předáme seznam, budou všechny jeho prvky přidány do výsledného seznamu
(každý zvlášť). Můžeme tím tedy nahradit operaci <i>flatten</i>:</p>

<pre>
(defvar lst '(1 2 3 4 5 6 7 8 9 10))
&nbsp;
(defvar result
        (<strong>loop</strong> <strong>for</strong> i <strong>in</strong> lst
              collect i))
&nbsp;
(dolist (item result)
  (print item))
&nbsp;
(terpri)
(princ "-------------------------------------")
&nbsp;
(defvar kids '((alfa beta) () (gama delta) (omega) ()))
&nbsp;
(setq result
      (<strong>loop</strong> <strong>for</strong> i <strong>in</strong> kids
            append i))
&nbsp;
(dolist (item result)
  (print item))
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
-------------------------------------
ALFA 
BETA 
GAMA 
DELTA 
OMEGA 
</pre>

<p>Podívejme se ještě na některé složitější konstrukce, které dokážeme
s&nbsp;makrem <strong>loop</strong> vytvořit. Poměrně často se setkáme se
situací, kdy je nutné vypočítat sumu všech prvků nějakého seznamu nebo vektoru.
To lze provést několika způsoby (<strong>reduce</strong> atd.), ovšem při
použití smyčky <strong>loop</strong> lze k&nbsp;tomuto účelu využít klauzuli
<strong>sum</strong> pro akumulaci výsledků:</p>

<pre>
(defvar lst '(1 2 3 4 5 6 7 8 9 10))
&nbsp;
(defvar result
    (<strong>loop</strong> <strong>for</strong> i <strong>in</strong> lst
          <strong>sum</strong> i))
&nbsp;
(format T "Result: ~d~%" result)
</pre>

<p>Předchozí zápis vracel implicitně jedinou hodnotu ze smyčky, a to konkrétně
sumu prvků. Toto chování lze popsat i explicitně s&nbsp;využitím klauzule
<strong>finally</strong>, do níž zapíšeme příkaz, který se má vykonat při
ukončování smyčky. Povšimněte si, že zde používáme lokální proměnnou
<strong>total</strong> (lze ji pojmenovat různě):</p>

<pre>
(terpri)
(setq result
    (<strong>loop</strong> <strong>for</strong> i <strong>in</strong> lst
          <strong>sum</strong> i <strong>into</strong> total
          <strong>finally</strong> (return total)))
&nbsp;
(format T "Result: ~d~%" result)
</pre>

<p>Výsledkem bude v&nbsp;obou případech stejná zpráva:</p>

<pre>
Result: 55
</pre>

<p><div class="rs-tip-major">Poznámka: právě na těchto příkladech asi začíná
být viditelná síla doménově specifického jazyka makra
<strong>loop</strong>.</div></p>

<p>Předchozí demonstrační příklad je možné ještě více
&bdquo;vyšperkovat&ldquo;, například vypočítat počet všech prvků, jejich
součet, maximální hodnotu a minimální hodnotu. To vše v&nbsp;jediné smyčce a
bez použití podmínek. Povšimněte si způsobu, jak ze smyčky vrátit více
hodnot:</p>

<pre>
(defvar lst '(1 2 3 4 5 6 7 8 9 10))
&nbsp;
(setq result
    (<strong>loop</strong> <strong>for</strong> i <strong>in</strong> lst
             <strong>count</strong> i <strong>into</strong> counter
             <strong>sum</strong> i <strong>into</strong> total
             <strong>maximize</strong> i <strong>into</strong> max-value
             <strong>minimize</strong> i <strong>into</strong> min-value
             <strong>finally return</strong> (list min-value max-value total counter)))
&nbsp;
(format T "Min value ~d~%" (nth 0 result))
(format T "Max value ~d~%" (nth 1 result))
(format T "Sum value ~d~%" (nth 2 result))
(format T "Values ~d~%" (nth 3 result))
</pre>

<p>Výsledky vypočtené předchozím příkladem:</p>

<pre>
Min value 0
Max value 10
Sum value 55
Values 11
</pre>

<p><div class="rs-tip-major">Poznámka: namísto <strong>(list hodnoty)</strong>
lze použít i <strong>(values hodnoty)</strong>, což je specialita Common Lispu,
o níž se zmíníme příště.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Překlad LISPovského programu do nativního kódu</h2>

<p>Velmi důležitým konceptem, který v&nbsp;Common Lisp nalezneme, je překlad
celého prostředí Common Lispu, pochopitelně včetně uživatelem vytvořeného
projektu, do nativního kódu. Výsledkem překladu je skutečně celé lispovské
prostředí, a to včetně debuggeru atd. To má několik důsledků, například možnost
relativně snadno ladit službu běžící v&nbsp;(před)produkčním prostředí atd.,
výkonnost například webového serveru naprogramovaného v&nbsp;Lispu je obecně <a
href="https://github.com/fukamachi/woo/blob/master/images/benchmark.png">mnohonásobně
vyšší</a>, než v&nbsp;případě Ruby či Pythonu atd.</p>

<p>Podívejme se nyní na způsob vytvoření spustitelného (a v&nbsp;rámci dané
architektury a operačního systému i přenositelného) programu, po jehož spuštění
se vypočítá faktoriál. Nejprve spustíme prostředí SBCL:</p>

<pre>
$ <strong>sbcl</strong>
&nbsp;
This is SBCL 2.0.1.debian, an implementation of ANSI Common Lisp.
More information about SBCL is available at &lt;http://www.sbcl.org/&gt;.
&nbsp;
SBCL is free software, provided as is, with absolutely no warranty.
It is mostly in the public domain; some portions are provided under
BSD-style licenses.  See the CREDITS and COPYING files in the
distribution for more information.
</pre>

<p>Dále načteme zdrojový kód uložený v&nbsp;souboru
<strong>factorial2.lisp</strong>:</p>

<pre>
* <strong>(load "factorial2.lisp")</strong>
T
</pre>

<p>A provedeme překlad zavoláním funkce
<strong>sb-ext:save-lisp-and-die</strong>, které se předá jméno výsledného
spustitelného kódu, příznak, že se má skutečně vygenerovat spustitelný kód a
v&nbsp;neposlední řadě se uvede i jméno funkce, která se má spustit (na rozdíl
od Clojure tedy nemusíme tuto funkci pojmenovat <strong>main-</strong>):</p>

<pre>
* <strong>(sb-ext:save-lisp-and-die "factorial" :executable t :toplevel 'print-factorials)</strong>
</pre>

<p>Průběh překladu (je prakticky okamžitý):</p>

<pre>
[undoing binding stack and other enclosing state... done]
[performing final GC... done]
[defragmenting immobile space... (fin,inst,fdefn,code,sym)=348+687+14943+16321+24770... done]
[saving current Lisp image into factorial:
writing 0 bytes from the read-only space at 0x50000000
writing 384 bytes from the static space at 0x50100000
writing 22183936 bytes from the dynamic space at 0x1000000000
writing 1798144 bytes from the immobile space at 0x50300000
writing 10579968 bytes from the immobile space at 0x52100000
done]
</pre>

<p>Výsledkem překladu je dosti objemný soubor o velikosti 34MB!:</p>

<pre>
$ <strong>ls -lah factorial</strong>
-rwxr-xr-x. 1 tisnik tisnik 34M Apr 10 15:01 factorial
</pre>

<p>Který je ovšem plně funkční:</p>

<pre>
$ <strong>./factorial</strong>
&nbsp;
1 
2 
6 
24 
120 
720 
5040 
40320 
362880 
3628800 
39916800 
479001600 
6227020800 
87178291200 
1307674368000 
20922789888000 
355687428096000 
6402373705728000 
121645100408832000 
2432902008176640000 
</pre>

<p>Závislosti na dalších systémových knihovnách jsou v&nbsp;tomto případě
skutečně malé:</p>

<pre>
$ <strong>ldd factorial</strong>
&nbsp;
        linux-vdso.so.1 (0x00007fff3d663000)
        libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f78929bc000)
        libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f7892999000)
        libz.so.1 =&gt; /lib/x86_64-linux-gnu/libz.so.1 (0x00007f789297d000)
        libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f789282e000)
        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f789263c000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f78929d9000)
</pre>

<p><div class="rs-tip-major">Poznámka: existují způsoby, jak velikost tohoto
souboru zmenšit; některé z&nbsp;nich si ukážeme příště.</div></p>

<p>Na tomto místě je vhodné poznamenat, že například do určité míry
&bdquo;konkurenční&ldquo; Clojure je založeno na premise &bdquo;virtuální
stroje jsou budoucí operační systémy&ldquo; (což se dnes ukazuje být spíše
nepravdivé), takže se namísto přenositelného binárního souboru vytváří Java
archivy. Z&nbsp;tohoto pohledu je přístup Common Lispu až překvapivě
moderní.</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů určených pro
spuštění v&nbsp;prostředí Common Lispu byly uloženy do Git repositáře, který je
dostupný na adrese <a
href="https://github.com/tisnik/lisp-families.git">https://github.com/tisnik/lisp-families.git</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, můžete
namísto toho použít odkazy na jednotlivé příklady, které naleznete
v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>boolean_ops.lisp</td><td>pravdivostní operace</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/boolean_ops.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/boolean_ops.lisp</a></td></tr>
<tr><td> 2</td><td>cond.lisp</td><td>základní rozhodovací konstrukce</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/cond.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/cond.lisp</a></td></tr>
<tr><td> 3</td><td>cons.lisp</td><td>konstrukce seznamů</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/cons.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/cons.lisp</a></td></tr>
<tr><td> 4</td><td>dotimes1.lisp</td><td>použití makra <strong>dotimes</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/dotimes1.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/dotimes1.lisp</a></td></tr>
<tr><td> 5</td><td>dotimes2.lisp</td><td>použití makra <strong>dotimes</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/dotimes2.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/dotimes2.lisp</a></td></tr>
<tr><td> 6</td><td>dotimes3.lisp</td><td>použití makra <strong>dotimes</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/dotimes3.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/dotimes3.lisp</a></td></tr>
<tr><td> 7</td><td>dot_pairs.lisp</td><td>datový typ &bdquo;pár&ldquo;</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/dot_pairs.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/dot_pairs.lisp</a></td></tr>
<tr><td> 8</td><td>drop.lisp</td><td>funkce <strong>drop</strong> pro zpracování seznamů</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/drop.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/drop.lisp</a></td></tr>
<tr><td> 9</td><td>factorial1.lisp</td><td>výpočet faktoriálu, první varianta</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/factorial1.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/factorial1.lisp</a></td></tr>
<tr><td>10</td><td>factorial2.lisp</td><td>výpočet faktoriálu, druhá varianta</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/factorial2.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/factorial2.lisp</a></td></tr>
<tr><td>11</td><td>function1.lisp</td><td>funkce v&nbsp;Common Lispu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/function1.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/function1.lisp</a></td></tr>
<tr><td>12</td><td>function2.lisp</td><td>funkce v&nbsp;Common Lispu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/function2.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/function2.lisp</a></td></tr>
<tr><td>13</td><td>function3.lisp</td><td>funkce v&nbsp;Common Lispu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/function3.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/function3.lisp</a></td></tr>
<tr><td>14</td><td>function4.lisp</td><td>funkce v&nbsp;Common Lispu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/function4.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/function4.lisp</a></td></tr>
<tr><td>15</td><td>hello1.lisp</td><td>&bdquo;Hello world&ldquo; v&nbsp;Common Lispu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/hello1.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/hello1.lisp</a></td></tr>
<tr><td>16</td><td>hello2.lisp</td><td>&bdquo;Hello world&ldquo; v&nbsp;Common Lispu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/hello2.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/hello2.lisp</a></td></tr>
<tr><td>17</td><td>lists.lisp</td><td>operace se seznamy</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/lists.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/lists.lisp</a></td></tr>
<tr><td>18</td><td>predicates.lisp</td><td>vybrané predikáty</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/predicates.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/predicates.lisp</a></td></tr>
<tr><td>19</td><td>take.lisp</td><td>funkce <strong>take</strong> pro zpracování seznamů</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/take.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/take.lisp</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>20</td><td>loop_append.lisp</td><td>klauzule <strong>append</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_append.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_append.lisp</a></td></tr>
<tr><td>21</td><td>loop_for_from_dowto.lisp</td><td>smyčka s&nbsp;počitadlem</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_from_dowto.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_from_dowto.lisp</a></td></tr>
<tr><td>22</td><td>loop_for_from_to_by.lisp</td><td>smyčka s&nbsp;počitadlem</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_from_to_by.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_from_to_by.lisp</a></td></tr>
<tr><td>23</td><td>loop_for_from_to.lisp</td><td>smyčka s&nbsp;počitadlem</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_from_to.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_from_to.lisp</a></td></tr>
<tr><td>24</td><td>loop_for_in_by.lisp</td><td>procházení seznamu s&nbsp;klauzulí <strong>in</strong> a <strong>by</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_in_by.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_in_by.lisp</a></td></tr>
<tr><td>25</td><td>loop_for_in.lisp</td><td>procházení seznamu s&nbsp;klauzulí <strong>in</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_in.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_in.lisp</a></td></tr>
<tr><td>26</td><td>loop_for_on_by.lisp</td><td>procházení seznamem s&nbsp;klauzulí <strong>on</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_on_by.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_on_by.lisp</a></td></tr>
<tr><td>27</td><td>loop_for_on.lisp</td><td>procházení seznamem s&nbsp;klauzulí <strong>on</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_on.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_on.lisp</a></td></tr>
<tr><td>28</td><td>loop_for_to.lisp</td><td>smyčka s&nbsp;počitadlem</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_to.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_to.lisp</a></td></tr>
<tr><td>29</td><td>loop_maximize.lisp</td><td>vyhledání prvku s&nbsp;největším výsledkem výpočtu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_maximize.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_maximize.lisp</a></td></tr>
<tr><td>30</td><td>loop_max_min_count_sum.lisp</td><td>statistické informace o seznamu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_max_min_count_sum.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_max_min_count_sum.lisp</a></td></tr>
<tr><td>31</td><td>loop_repeat.lisp</td><td>klauzule <strong>repeat</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_repeat.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_repeat.lisp</a></td></tr>
<tr><td>32</td><td>loop_sum.lisp</td><td>výpočet sumy prvků</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_sum.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_sum.lisp</a></td></tr>
<tr><td>33</td><td>loop_while_until.lisp</td><td>klauzule <strong>while</strong> a <strong>until</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_while_until.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_while_until.lisp</a></td></tr>
<tr><td>34</td><td>broken_factorial.lisp</td><td>chyba při výpočtu faktoriálu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/broken_factorial.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/broken_factorial.lisp</a></td></tr>
<tr><td>35</td><td>broken_factorial2.lisp</td><td>chyba při výpočtu faktoriálu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/broken_factorial2.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/broken_factorial2.lisp</a></td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: všechny tyto demonstrační příklady je
možné spustit přímo z&nbsp;shellu: <strong>sbcl --load
&lt;jméno-souboru.lisp&gt;</strong></div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Předchozí části seriálu</h2>

<p>V&nbsp;této kapitole jsou uvedeny odkazy na všechny předchozí části seriálu
o světě programovacích jazyků LISP a Scheme (kromě samostatného seriálu, který
se věnoval programovacímu jazyku Clojure):</p>

<ol>

<li>Jemný úvod do rozsáhlého světa jazyků LISP a Scheme<br />
<a href="https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/">https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/</a>
</li>

<li>PicoLisp: minimalistický a přitom překvapivě výkonný interpret Lispu<br />
<a href="https://www.root.cz/clanky/picolisp-minimalisticky-a-pritom-prekvapive-vykonny-interpret-lispu/">https://www.root.cz/clanky/picolisp-minimalisticky-a-pritom-prekvapive-vykonny-interpret-lispu/</a>
</li>

<li>PicoLisp: užitečné funkce a speciální formy používané při tvorbě aplikací<br />
<a href="https://www.root.cz/clanky/picolisp-uzitecne-funkce-a-specialni-formy-pouzivane-pri-tvorbe-aplikaci/">https://www.root.cz/clanky/picolisp-uzitecne-funkce-a-specialni-formy-pouzivane-pri-tvorbe-aplikaci/</a>
</li>

<li>PicoLisp: dokončení popisu a několik praktických rad na závěr<br />
<a href="https://www.root.cz/clanky/picolisp-dokonceni-popisu-a-nekolik-praktickych-rad-na-zaver/">https://www.root.cz/clanky/picolisp-dokonceni-popisu-a-nekolik-praktickych-rad-na-zaver/</a>
</li>

<li>GNU Guile – interpret Scheme vestavitelný do nativních aplikací<br />
<a href="https://www.root.cz/clanky/gnu-guile-interpret-scheme-vestavitelny-do-nativnich-aplikaci/">https://www.root.cz/clanky/gnu-guile-interpret-scheme-vestavitelny-do-nativnich-aplikaci/</a>
</li>

<li>TinyScheme aneb další interpret jazyka Scheme vestavitelný do dalších aplikací<br />
<a href="https://www.root.cz/clanky/tinyscheme-aneb-dalsi-interpret-jazyka-scheme-vestavitelny-do-dalsich-aplikaci/">https://www.root.cz/clanky/tinyscheme-aneb-dalsi-interpret-jazyka-scheme-vestavitelny-do-dalsich-aplikaci/</a>
</li>

<li>Kawa: překvapivě silný a výkonný dialekt Scheme pro JVM<br />
<a href="https://www.root.cz/clanky/kawa-prekvapive-silny-a-vykonny-dialekt-scheme-pro-jvm/">https://www.root.cz/clanky/kawa-prekvapive-silny-a-vykonny-dialekt-scheme-pro-jvm/</a>
</li>

<li>Jazyk Kawa v&nbsp;ekosystému virtuálního stroje Javy<br />
<a href="https://www.root.cz/clanky/jazyk-kawa-v-ekosystemu-virtualniho-stroje-javy/">https://www.root.cz/clanky/jazyk-kawa-v-ekosystemu-virtualniho-stroje-javy/</a>
</li>

<li>Zpracování vektorů, matic a N-rozměrných polí v&nbsp;programovacím jazyku Kawa<br />
<a href="https://www.root.cz/clanky/zpracovani-vektoru-matic-a-n-rozmernych-poli-v-programovacim-jazyku-kawa/">https://www.root.cz/clanky/zpracovani-vektoru-matic-a-n-rozmernych-poli-v-programovacim-jazyku-kawa/</a>
</li>

<li>Racket: programovací jazyk a současně i platforma pro vývoj nových jazyků<br />
<a href="https://www.root.cz/clanky/racket-programovaci-jazyk-a-soucasne-i-platforma-pro-vyvoj-novych-jazyku/">https://www.root.cz/clanky/racket-programovaci-jazyk-a-soucasne-i-platforma-pro-vyvoj-novych-jazyku/</a>
</li>

<li>Makra v&nbsp;Racketu i v&nbsp;dalších lispovských jazycích<br />
<a href="https://www.root.cz/clanky/makra-v-racketu-i-v-dalsich-lispovskych-jazycich/">https://www.root.cz/clanky/makra-v-racketu-i-v-dalsich-lispovskych-jazycich/</a>
</li>

<li>Základní knihovna jazyka Racket<br />
<a href="https://www.root.cz/clanky/zakladni-knihovna-jazyka-racket/">https://www.root.cz/clanky/zakladni-knihovna-jazyka-racket/</a>
</li>

<li>Jazyk Joker: dialekt Clojure naprogramovaný v&nbsp;Go<br />
<a href="https://www.root.cz/clanky/jazyk-joker-dialekt-clojure-naprogramovany-v-go/">https://www.root.cz/clanky/jazyk-joker-dialekt-clojure-naprogramovany-v-go/</a>
</li>

<li>Chicken Scheme – další interpret a především překladač programovacího jazyka Scheme<br />
<a href="https://www.root.cz/clanky/chicken-scheme-dalsi-interpret-a-predevsim-prekladac-programovaciho-jazyka-scheme/">https://www.root.cz/clanky/chicken-scheme-dalsi-interpret-a-predevsim-prekladac-programovaciho-jazyka-scheme/</a>
</li>

<li>Projekt Gambit – další kvalitní interpret i překladač programovacího jazyka Scheme<br />
<a href="https://www.root.cz/clanky/projekt-gambit-dalsi-kvalitni-interpret-i-prekladac-programovaciho-jazyka-scheme/">https://www.root.cz/clanky/projekt-gambit-dalsi-kvalitni-interpret-i-prekladac-programovaciho-jazyka-scheme/</a>
</li>

<li>Interlisp aneb oživujeme dinosaura<br />
<a href="https://www.root.cz/clanky/interlisp-aneb-ozivujeme-dinosaura/">https://www.root.cz/clanky/interlisp-aneb-ozivujeme-dinosaura/</a>
</li>

<li>Propojení světa LISPu se světem JavaScriptu s&nbsp;využitím transpřekladače Wisp<br />
<a href="https://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp/">https://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp/</a>
</li>

<li>Propojení světa LISPu se světem JavaScriptu s&nbsp;využitím transpřekladače Wisp (2.část)<br />
<a href="https://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp-2-cast/">https://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp-2-cast/</a>
</li>

</ol>

<p>Články o Elispu:</p>

<ol>

<li>Úpravy Emacsu a tvorba nových modulů s&nbsp;využitím Emacs Lispu<br />
<a href="https://www.root.cz/clanky/upravy-emacsu-a-tvorba-novych-modulu-s-vyuzitim-emacs-lispu/">https://www.root.cz/clanky/upravy-emacsu-a-tvorba-novych-modulu-s-vyuzitim-emacs-lispu/</a>
</li>

<li>Úpravy Emacsu s&nbsp;Emacs Lisp: základní konstrukce jazyka<br />
<a href="https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-zakladni-konstrukce-jazyka/">https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-zakladni-konstrukce-jazyka/</a>
</li>

<li>Úpravy Emacsu s&nbsp;Emacs Lisp: všemocné makro cl-loop a knihovna dash<br />
<a href="https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-vsemocne-makro-cl-loop-a-knihovna-dash/">https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-vsemocne-makro-cl-loop-a-knihovna-dash/</a>
</li>

<li>Úpravy Emacsu s&nbsp;Emacs Lisp: možnosti nabízené knihovnou Dash<br />
<a href="https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-moznosti-nabizene-knihovnou-dash/">https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-moznosti-nabizene-knihovnou-dash/</a>
</li>

<li>Úpravy Emacsu s&nbsp;Emacs Lisp: dokončení popisu Emacs Lispu<br />
<a href="https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-dokonceni-popisu-emacs-lispu/">https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-dokonceni-popisu-emacs-lispu/</a>
</li>

<li>Úpravy Emacsu s&nbsp;Emacs Lisp: manipulace se základními datovými strukturami Emacsu<br />
<a href="https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-manipulace-se-zakladnimi-datovymi-strukturami-emacsu/">https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-manipulace-se-zakladnimi-datovymi-strukturami-emacsu/</a>
</li>

</ol>



<p><a name="k19"></a></p>
<h2 id="k19">19. Literatura</h2>

<p>O Common Lispu, Scheme či Clojure, tedy o třech (s&nbsp;velkou
pravděpodobností) nejpoužívanějších dialektech LISPu, vyšlo poměrně velké
množství literatury. Pro Common Lisp je typická jeho velká stabilita, a to
minimálně od roku 1994, což mj.&nbsp;znamená, že i původní vydaní prvních dvou
dále zmíněných knih je zcela bez problémů použitelné i dnes (a obě knihy jsou
navíc dobře čitelné):</p>

<ol>

<li>Peter Seibel<br />
<i>&bdquo;Practical Common Lisp&ldquo;</i><br />
2009
</li>

<li>Paul Graham<br />
<i>&bdquo;ANSI Common Lisp&ldquo;</i><br />
1995
</li>

<li>Gerald Gazdar<br />
<i>&bdquo;Natural Language Processing in Lisp: An Introduction to Computational Linguistics&ldquo;</i><br />
1989
</li>

<li>Peter Norvig<br />
<i>&bdquo;Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp&ldquo;</i><br />
1991
</li>

<li>Alex Mileler et.al.<br />
<i>&bdquo;Clojure Applied: From Practice to Practitioner&ldquo;</i><br />
2015
</li>

<li>
<i>&bdquo;Living Clojure: An Introduction and Training Plan for Developers&ldquo;</i><br />
2015
</li>

<li>Dmitri Sotnikov<br />
<i>&bdquo;Web Development with Clojure: Build Bulletproof Web Apps with Less Code&ldquo;</i><br />
2016
</li>

<li>McCarthy<br />
<i>&bdquo;Recursive functions of symbolic expressions and their computation by machine, part I&ldquo;</i><br />
1960
</li>

<li>R. Kent Dybvig<br />
<i>&bdquo;The Scheme Programming Language&ldquo;</i><br />
2009
</li>

<li>Max Hailperin<br />
<i>&bdquo;Concrete Abstractions&ldquo;</i><br />
1998
</li>

<li>Guy L. Steele<br />
<i>&bdquo;History of Scheme&ldquo;</i><br />
2006, Sun Microsystems Laboratories
</li>

<li>Kolář J., Muller K.:<br />
<i>&bdquo;Speciální programovací jazyky&ldquo;</i><br />
Praha 1981
</li>

<li>
<i>&bdquo;AutoLISP Release 9, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., October 1987
</li>

<li>
<i>&bdquo;AutoLISP Release 10, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., September 1988
</li>

<li>McCarthy, John; Abrahams, Paul W.; Edwards, Daniel J.; Hart, Timothy P.; Levin, Michael I.<br />
<i>&bdquo;LISP 1.5 Programmer's Manual&ldquo;</i><br />
MIT Press. ISBN 0 262 130 1 1 4
</li>

<li>Carl Hewitt; Peter Bishop and Richard Steiger<br />
<i>&bdquo;A Universal Modular Actor Formalism for Artificial Intelligence&ldquo;</i><br />
1973
</li>

<li>Feiman, J.<br />
<i>&bdquo;The Gartner Programming Language Survey (October 2001)&ldquo;</i><br />
Gartner Advisory
</li>

<li>Harold Abelson, Gerald Jay Sussman, Julie Sussman:<br />
<i>Structure and Interpretation of Computer Programs</i><br />
MIT Press. 1985, 1996 (a možná vyšel i další přetisk)
</li>

<li>Paul Graham<br />
<i>On Lisp</i><br />
Prentice Hall, 1993<br />
Dostupné online na adrese <a href="http://www.paulgraham.com/onlisptext.html">http://www.paulgraham.com/onlisptext.html</a>
</li>

<li>David S. Touretzky<br />
<i>Common LISP: A Gentle Introduction to Symbolic Computation (Dover Books on Engineering)</i><br />
</li>

<li>Peter Norvig<br />
<i>Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp</i>
</li>

<li>Patrick Winston, Berthold Horn<br />
<i>Lisp (3rd Edition)</i><br />
ISBN-13: 978-0201083194, ISBN-10: 0201083191
</li>

<li>Matthias Felleisen, David Van Horn, Dr. Conrad Barski<br>
<i>Realm of Racket: Learn to Program, One Game at a Time!</i><br />
ISBN-13: 978-1593274917, ISBN-10: 1593274912 
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Common Lisp<br />
<a href="https://lisp-lang.org/">https://lisp-lang.org/</a>
</li>

<li>Why You Should Learn Lisp In 2022?<br />
<a href="https://www.youtube.com/watch?v=GWdf1flcLoM">https://www.youtube.com/watch?v=GWdf1flcLoM</a>
</li>

<li>LOOP Common Lisps Superior For<br />
<a href="https://www.youtube.com/watch?v=i4tmF_1nZng">https://www.youtube.com/watch?v=i4tmF_1nZng</a>
</li>

<li>Lisp VS C benchmarks<br />
<a href="https://programming-language-benchmarks.vercel.app/lisp-vs-c">https://programming-language-benchmarks.vercel.app/lisp-vs-c</a>
</li>

<li>Common Lisp: An elegant design pattern<br />
<a href="https://www.youtube.com/watch?v=9597LFlvMuE">https://www.youtube.com/watch?v=9597LFlvMuE</a>
</li>

<li>Common Lisp Macros By Example Tutorial<br />
<a href="https://lisp-journey.gitlab.io/blog/common-lisp-macros-by-example-tutorial/">https://lisp-journey.gitlab.io/blog/common-lisp-macros-by-example-tutorial/</a>
</li>

<li>The Common Lisp Cookbook<br />
<a href="https://lispcookbook.github.io/cl-cookbook/">https://lispcookbook.github.io/cl-cookbook/</a>
</li>

<li>The Evolution of Lisp<br />
<a href="https://www.csee.umbc.edu/courses/331/resources/papers/Evolution-of-Lisp.pdf">https://www.csee.umbc.edu/courses/331/resources/papers/Evolution-of-Lisp.pdf</a>
</li>

<li>Awesome CL<br />
<a href="https://github.com/CodyReichert/awesome-cl">https://github.com/CodyReichert/awesome-cl</a>
</li>

<li>LISP<br />
<a href="https://taoofmac.com/space/dev/lisp">https://taoofmac.com/space/dev/lisp</a>
</li>

<li>Repositář projektu femtolisp<br />
<a href="https://github.com/JeffBezanson/femtolisp">https://github.com/JeffBezanson/femtolisp</a>
</li>

<li>Femtolisp - lightweight, robust lisp interpreter built on reusable C libraries<br />
<a href="https://www.findbestopensource.com/product/femtolisp">https://www.findbestopensource.com/product/femtolisp</a>
</li>

<li>YCombinator: Femtolisp: A lightweight, robust, scheme-like Lisp implementation<br />
<a href="https://news.ycombinator.com/item?id=22094722">https://news.ycombinator.com/item?id=22094722</a>
</li>

<li>Learning Julia by Anshul Joshi, Rahul Lakhanpal: Femtolisp<br />
<a href="https://www.oreilly.com/library/view/learning-julia/9781785883279/2e85442f-d100-4b53-b8f7-7d20d62f0255.xhtml">https://www.oreilly.com/library/view/learning-julia/9781785883279/2e85442f-d100-4b53-b8f7-7d20d62f0255.xhtml</a>
</li>

<li>The role of femtolisp in Julia?<br />
<a href="https://discourse.julialang.org/t/the-role-of-femtolisp-in-julia/1902">https://discourse.julialang.org/t/the-role-of-femtolisp-in-julia/1902</a>
</li>

<li>LispSyntax.jl: A clojure-like lisp syntax for julia<br />
<a href="https://github.com/swadey/LispSyntax.jl">https://github.com/swadey/LispSyntax.jl</a>
</li>

<li>What exactly code lowering is an how to do “unlowering”?<br />
<a href="https://discourse.julialang.org/t/what-exactly-code-lowering-is-an-how-to-do-unlowering/1315">https://discourse.julialang.org/t/what-exactly-code-lowering-is-an-how-to-do-unlowering/1315</a>
</li>

<li>Interlisp.org: Dedicated to Restoring and Preserving the Interlisp experience<br />
<a href="https://github.com/Interlisp">https://github.com/Interlisp</a>
</li>

<li>Warren Teitelman<br />
<a href="https://en.wikipedia.org/wiki/Warren_Teitelman">https://en.wikipedia.org/wiki/Warren_Teitelman</a>
</li>

<li>InterLISP/65<br />
<a href="http://www.atarimania.com/utility-atari-400-800-xl-xe-interlisp-65_12477.html">http://www.atarimania.com/utility-atari-400-800-xl-xe-interlisp-65_12477.html</a>
</li>

<li>Lisp Editing in the 80s - Interlisp SEdit (Video)<br />
<a href="https://www.youtube.com/watch?v=2qsmF8HHskg">https://www.youtube.com/watch?v=2qsmF8HHskg</a>
</li>

<li>Inter-LISP<br />
<a href="http://www.atarimania.com/utility-atari-400-800-xl-xe-inter-lisp_29354.html">http://www.atarimania.com/utility-atari-400-800-xl-xe-inter-lisp_29354.html</a>
</li>

<li>InterLISP 65 Editing (video)<br />
<a href="https://www.youtube.com/watch?v=nY_hcazo86A">https://www.youtube.com/watch?v=nY_hcazo86A</a>
</li>

<li>Datasoft INTER-LISP/65 (Atari Age, chat)<br />
<a href="https://atariage.com/forums/topic/116093-datasoft-inter-lisp65/">https://atariage.com/forums/topic/116093-datasoft-inter-lisp65/</a>
</li>

<li>Marvin Minsky - The beauty of the Lisp language (44/151)<br />
<a href="https://www.youtube.com/watch?v=YaWVHyIBVeI">https://www.youtube.com/watch?v=YaWVHyIBVeI</a>
</li>

<li>History of LISP (Interlisp)<br />
<a href="http://www.softwarepreservation.org/projects/LISP/index.html#INTERLISP_">http://www.softwarepreservation.org/projects/LISP/index.html#INTERLISP_</a>
</li>

<li>Computer-Assisted Instruction (Bits and Bytes, Episode 7)<br />
<a href="https://www.youtube.com/watch?v=eURtTV_qKw8">https://www.youtube.com/watch?v=eURtTV_qKw8</a>
</li>

<li>Můžeme věřit překladačům? Projekty řešící schéma „důvěřivé důvěry“<br />
<a href="https://www.root.cz/clanky/muzeme-verit-prekladacum-projekty-resici-schema-duverive-duvery/">https://www.root.cz/clanky/muzeme-verit-prekladacum-projekty-resici-schema-duverive-duvery/</a>
</li>

<li>Gambit in the browser<br />
<a href="https://feeley.github.io/gambit-in-the-browser/">https://feeley.github.io/gambit-in-the-browser/</a>
</li>

<li>A Tour of Scheme in Gambit<br />
<a href="http://dynamo.iro.umontreal.ca/wiki/images/a/a7/A_Tour_of_Scheme_in_Gambit.pdf">http://dynamo.iro.umontreal.ca/wiki/images/a/a7/A_Tour_of_Scheme_in_Gambit.pdf</a>
</li>

<li>Gambit Scheme: Inside Out<br />
<a href="http://www.iro.umontreal.ca/~gambit/Gambit-inside-out.pdf">http://www.iro.umontreal.ca/~gambit/Gambit-inside-out.pdf</a>
</li>

<li>Gambit Internal Documentation<br />
<a href="http://dynamo.iro.umontreal.ca/wiki/index.php/Internal_Documentation">http://dynamo.iro.umontreal.ca/wiki/index.php/Internal_Documentation</a>
</li>

<li>clojure-scheme: Compiling to Native Code via Scheme <br />
<a href="http://www.iro.umontreal.ca/~gambit/Sorenson-Clojure-to-Native-via-Scheme.pdf">http://www.iro.umontreal.ca/~gambit/Sorenson-Clojure-to-Native-via-Scheme.pdf</a>
</li>

<li>Gauche &ndash; a Scheme implementation<br />
<a href="http://practical-scheme.net/gauche/">http://practical-scheme.net/gauche/</a>
</li>

<li>Scheme48<br />
<a href="https://s48.org/">https://s48.org/</a>
</li>

<li>SISC (Second Interpreter of Scheme)<br />
<a href="http://sisc-scheme.org/">http://sisc-scheme.org/</a>
</li>

<li>The SCM Implementation of Scheme<br />
<a href="https://people.csail.mit.edu/jaffer/SCM.html">https://people.csail.mit.edu/jaffer/SCM.html</a>
</li>

<li>Ypsilon - The ultimate script language system for the video pinball fourth generation<br />
<a href="http://www.littlewingpinball.com/doc/en/ypsilon/index.html">http://www.littlewingpinball.com/doc/en/ypsilon/index.html</a>
</li>

<li>Chicken Scheme<br />
<a href="https://call-cc.org/">https://call-cc.org/</a>
</li>

<li>Eggs Unlimited<br />
<a href="http://wiki.call-cc.org/chicken-projects/egg-index-5.html">http://wiki.call-cc.org/chicken-projects/egg-index-5.html</a>
</li>

<li>Chicken Scheme Wiki<br />
<a href="https://wiki.call-cc.org/">https://wiki.call-cc.org/</a>
</li>

<li>CHICKEN for Python programmers<br />
<a href="https://wiki.call-cc.org/chicken-for-python-programmers">https://wiki.call-cc.org/chicken-for-python-programmers</a>
</li>

<li>Programming for Performance<br />
<a href="http://wiki.call-cc.org/programming-for-performance">http://wiki.call-cc.org/programming-for-performance</a>
</li>

<li>Using the compiler<br />
<a href="https://wiki.call-cc.org/man/4/Using%20the%20compiler">https://wiki.call-cc.org/man/4/Using%20the%20compiler</a>
</li>

<li>CHICKEN Scheme tutorials<br />
<a href="https://wiki.call-cc.org/tutorials">https://wiki.call-cc.org/tutorials</a>
</li>

<li>Traditional Turtles<br />
<a href="https://docs.racket-lang.org/turtles/Traditional_Turtles.html">https://docs.racket-lang.org/turtles/Traditional_Turtles.html</a>
</li>

<li>[racket] How best to repeat a function call n times?<br />
<a href="https://lists.racket-lang.org/users/archive/2014-September/064203.html">https://lists.racket-lang.org/users/archive/2014-September/064203.html</a>
</li>

<li>Racket: Macros<br />
<a href="https://www.it.uu.se/edu/course/homepage/avfunpro/ht13/lectures/Racket-3-Macros.pdf">https://www.it.uu.se/edu/course/homepage/avfunpro/ht13/lectures/Racket-3-Macros.pdf</a>
</li>

<li>Beautiful Racket / explainers: Macros<br />
<a href="https://beautifulracket.com/explainer/macros.html">https://beautifulracket.com/explainer/macros.html</a>
</li>

<li>Macros (dokumentace k Racketu)<br />
<a href="https://docs.racket-lang.org/guide/macros.html">https://docs.racket-lang.org/guide/macros.html</a>
</li>

<li>Model syntaxe jazyka Racket<br />
<a href="https://docs.racket-lang.org/reference/syntax-model.html">https://docs.racket-lang.org/reference/syntax-model.html</a>
</li>

<li>Syntax Objects<br />
<a href="https://docs.racket-lang.org/guide/stx-obj.html">https://docs.racket-lang.org/guide/stx-obj.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Beautiful Racket: an intro­duction to language-oriented programming using Racket<br />
<a href="https://beautifulracket.com/">https://beautifulracket.com/</a>
</li>

<li>Stránky projektu Racket<br />
<a href="https://racket-lang.org/">https://racket-lang.org/</a>
</li>

<li>Dokumentace k&nbsp;projektu Racket<br />
<a href="https://docs.racket-lang.org/index.html">https://docs.racket-lang.org/index.html</a>
</li>

<li>Seznam dostupných balíčků pro Racket<br />
<a href="https://pkgs.racket-lang.org/">https://pkgs.racket-lang.org/</a>
</li>

<li>Racket na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Racket_(programming_language)">https://en.wikipedia.org/wiki/Racket_(programming_language)</a>
</li>

<li>Vector Library (R7RS-compatible)<br />
<a href="https://srfi.schemers.org/srfi-133/srfi-133.html">https://srfi.schemers.org/srfi-133/srfi-133.html</a>
</li>

<li>Blogy o Racketu a navazujících technologiích<br />
<a href="https://blog.racket-lang.org/">https://blog.racket-lang.org/</a>
</li>

<li>Prográmky psané v&nbsp;Racketu na RosettaCode<br />
<a href="http://rosettacode.org/wiki/Category:Racket">http://rosettacode.org/wiki/Category:Racket</a>
</li>

<li>Fear of Macros<br />
<a href="https://www.greghendershott.com/fear-of-macros/">https://www.greghendershott.com/fear-of-macros/</a>
</li>

<li>Rackjure<br />
<a href="https://github.com/greghendershott/rackjure">https://github.com/greghendershott/rackjure</a>
</li>

<li>Matthew Flatt’s proposal to change Racket’s s-expressions based syntax to infix representation creates a stir in the community<br />
<a href="https://hub.packtpub.com/matthew-flatts-proposal-to-change-rackets-s-expressions-based-syntax-to-infix-representation-creates-a-stir-in-the-community/">https://hub.packtpub.com/matthew-flatts-proposal-to-change-rackets-s-expressions-based-syntax-to-infix-representation-creates-a-stir-in-the-community/</a>
</li>

<li>Racket News<br />
<a href="https://racket-news.com/">https://racket-news.com/</a>
</li>

<li>Racket: Lisp for learning<br />
<a href="https://lwn.net/Articles/795385/">https://lwn.net/Articles/795385/</a>
</li>

<li>Future of Racket<br />
<a href="https://www.greghendershott.com/2019/07/future-of-racket.html">https://www.greghendershott.com/2019/07/future-of-racket.html</a>
</li>

<li>Vectors (pro Gauche)<br />
<a href="https://practical-scheme.net/gauche/man/gauche-refe/Vectors.html">https://practical-scheme.net/gauche/man/gauche-refe/Vectors.html</a>
</li>

<li>Kawa: Compiling Scheme to Java<br />
<a href="https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html">https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html</a>
</li>

<li>Kawa in Languages shootout<br />
<a href="http://per.bothner.com/blog/2010/Kawa-in-shootout/">http://per.bothner.com/blog/2010/Kawa-in-shootout/</a>
</li>

<li>Kawa 2.0 Supports Scheme R7RS<br />
<a href="https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/">https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/</a>
</li>

<li>Kawa — fast scripting on the Java platform<br />
<a href="https://lwn.net/Articles/623349/">https://lwn.net/Articles/623349/</a>
</li>

<li>Tail call (a její optimalizace)<br />
<a href="https://en.wikipedia.org/wiki/Tail_call">https://en.wikipedia.org/wiki/Tail_call</a>
</li>

<li>SLIME (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/SLIME">http://en.wikipedia.org/wiki/SLIME</a>
</li>

<li>slime.vim<br />
<a href="http://s3.amazonaws.com/mps/slime.vim">http://s3.amazonaws.com/mps/slime.vim</a>
</li>

<li>What are the best scheme implementations?<br />
<a href="https://www.slant.co/topics/5282/~scheme-implementations">https://www.slant.co/topics/5282/~scheme-implementations</a>
</li>

<li>Bigloo homepage<br />
<a href="http://www-sop.inria.fr/mimosa/fp/Bigloo/">http://www-sop.inria.fr/mimosa/fp/Bigloo/</a>
</li>

<li>FTP s tarbally Bigloo<br />
<a href="ftp://ftp-sop.inria.fr/indes/fp/Bigloo">ftp://ftp-sop.inria.fr/indes/fp/Bigloo</a>
</li>

<li>GOTO 2018 • Functional Programming in 40 Minutes • Russ Olsen<br />
<a href="https://www.youtube.com/watch?v=0if71HOyVjY">https://www.youtube.com/watch?v=0if71HOyVjY</a>
</li>

<li>TinyScheme (stránka na Sourceforge)<br />
<a href="http://tinyscheme.sourceforge.net/home.html">http://tinyscheme.sourceforge.net/home.html</a>
</li>

<li>Embedding Tiny Scheme in a Game<br />
<a href="http://www.silicondelight.com/embedding-tiny-scheme-in-a-game/">http://www.silicondelight.com/embedding-tiny-scheme-in-a-game/</a>
</li>

<li>Embedding Scheme for a game mission scripting DSL<br />
<a href="http://carloscarrasco.com/embedding-scheme-for-a-game-mission-scripting-dsl.html">http://carloscarrasco.com/embedding-scheme-for-a-game-mission-scripting-dsl.html</a>
</li>

<li>Všechny verze TinyScheme na SourceForge<br />
<a href="https://sourceforge.net/projects/tinyscheme/files/tinyscheme/">https://sourceforge.net/projects/tinyscheme/files/tinyscheme/</a>
</li>

<li>Fork TinyScheme na GitHubu<br />
<a href="https://github.com/yawnt/tinyscheme">https://github.com/yawnt/tinyscheme</a>
</li>

<li>Ackermannova funkce<br />
<a href="https://cs.wikipedia.org/wiki/Ackermannova_funkce">https://cs.wikipedia.org/wiki/Ackermannova_funkce</a>
</li>

<li>Ackermann function na Rosetta Code<br />
<a href="https://rosettacode.org/wiki/Ackermann_function#Scheme">https://rosettacode.org/wiki/Ackermann_function#Scheme</a>
</li>

<li>Success Stories (lisp.org)<br />
<a href="https://lisp-lang.org/success/">https://lisp-lang.org/success/</a>
</li>

<li>Allegro Common Lisp Success Stories<br />
<a href="https://franz.com/success/">https://franz.com/success/</a>
</li>

<li>Clojure Success Stories<br />
<a href="https://clojure.org/community/success_stories">https://clojure.org/community/success_stories</a>
</li>

<li>Scheme Quick Reference<br />
<a href="https://www.st.cs.uni-saarland.de/edu/config-ss04/scheme-quickref.pdf">https://www.st.cs.uni-saarland.de/edu/config-ss04/scheme-quickref.pdf</a>
</li>

<li>Slajdy o Scheme (od slajdu číslo 15)<br />
<a href="https://docs.google.com/presentation/d/1abmDnKjrq1tcjGvvRNAKhOiSTSE2lyagtcEPal07Gbo/edit">https://docs.google.com/presentation/d/1abmDnKjrq1tcjGvvRNAKhOiSTSE2lyagtcEPal07Gbo/edit</a>
</li>

<li>Scheme Cheat Sheet<br />
<a href="https://github.com/smythp/scheme-cheat-sheet">https://github.com/smythp/scheme-cheat-sheet</a>
</li>

<li>Embedding Lua, embedding Guile <br />
<a href="http://puntoblogspot.blogspot.com/2013/04/embedding-lua-embedding-guile.html">http://puntoblogspot.blogspot.com/2013/04/embedding-lua-embedding-guile.html</a>
</li>

<li>Lambda Papers<br />
<a href="https://en.wikisource.org/wiki/Lambda_Papers">https://en.wikisource.org/wiki/Lambda_Papers</a>
</li>

<li>Revised<sup>7</sup>Report on the Algorithmic Language Scheme<br />
<a href="https://small.r7rs.org/attachment/r7rs.pdf">https://small.r7rs.org/attachment/r7rs.pdf</a>
</li>

<li>Video Lectures (MIT, SICP 2005)<br />
<a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/</a>
</li>

<li>Why is Scheme my first language in university?<br />
<a href="https://softwareengineering.stackexchange.com/questions/115252/why-is-scheme-my-first-language-in-university">https://softwareengineering.stackexchange.com/questions/115252/why-is-scheme-my-first-language-in-university</a>
</li>

<li>The Perils of JavaSchools<br />
<a href="https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/">https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/</a>
</li>

<li>How to Design Programs, Second Edition<br />
<a href="https://htdp.org/2019-02-24/index.html">https://htdp.org/2019-02-24/index.html</a>
</li>

<li>LilyPond<br />
<a href="http://lilypond.org/">http://lilypond.org/</a>
</li>

<li>LilyPond — Extending (přes Scheme)<br />
<a href="http://lilypond.org/doc/v2.18/Documentation/extending/scheme-tutorial">http://lilypond.org/doc/v2.18/Documentation/extending/scheme-tutorial</a>
</li>

<li>Scheme in LilyPond<br />
<a href="http://lilypond.org/doc/v2.18/Documentation/extending/scheme-in-lilypond">http://lilypond.org/doc/v2.18/Documentation/extending/scheme-in-lilypond</a>
</li>

<li>GnuCash<br />
<a href="http://www.gnucash.org/">http://www.gnucash.org/</a>
</li>

<li>Custom Reports (in GNU Cash)<br />
<a href="https://wiki.gnucash.org/wiki/Custom_Reports">https://wiki.gnucash.org/wiki/Custom_Reports</a>
</li>

<li>Program by Design<br />
<a href="https://programbydesign.org/">https://programbydesign.org/</a>
</li>

<li>SchemePy<br />
<a href="https://pypi.org/project/SchemePy/">https://pypi.org/project/SchemePy/</a>
</li>

<li>LISP FQA: Section - [1-5] What is the "minimal" set of primitives needed for a Lisp interpreter?<br />
<a href="http://www.faqs.org/faqs/lisp-faq/part1/section-6.html">http://www.faqs.org/faqs/lisp-faq/part1/section-6.html</a>
</li>

<li>femtolisp<br />
<a href="https://github.com/JeffBezanson/femtolisp">https://github.com/JeffBezanson/femtolisp</a>
</li>

<li>(How to Write a (Lisp) Interpreter (in Python))<br />
<a href="http://norvig.com/lispy.html">http://norvig.com/lispy.html</a>
</li>

<li>Repositář s&nbsp;Guile Emacsem<br />
<a href="http://git.hcoop.net/?p=bpt/guile.git">http://git.hcoop.net/?p=bpt/guile.git</a>
</li>

<li>Interacting with Guile Compound Data Types in C<br />
<a href="http://www.lonelycactus.com/guilebook/x1555.html">http://www.lonelycactus.com/guilebook/x1555.html</a>
</li>

<li>Calling Guile functions from C<br />
<a href="http://www.lonelycactus.com/guilebook/c1204.html#SECCALLGUILEFUNC">http://www.lonelycactus.com/guilebook/c1204.html#SECCALLGUILEFUNC</a>
</li>

<li>Arrays, and other compound data types<br />
<a href="http://www.lonelycactus.com/guilebook/charrays.html">http://www.lonelycactus.com/guilebook/charrays.html</a>
</li>

<li>Interacting with Guile Compound Data Types in C<br />
<a href="http://www.lonelycactus.com/guilebook/x1555.html">http://www.lonelycactus.com/guilebook/x1555.html</a>
</li>

<li>Guile Reference Manual<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/index.html">https://www.gnu.org/software/guile/manual/html_node/index.html</a>
</li>

<li>Scheme: Summary of Common Syntax<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/Syntax-Summary.html#Syntax-Summary">https://www.gnu.org/software/guile/manual/html_node/Syntax-Summary.html#Syntax-Summary</a>
</li>

<li>Scripting with Guile: Extension language enhances C and Scheme<br />
<a href="https://www.ibm.com/developerworks/library/l-guile/index.html">https://www.ibm.com/developerworks/library/l-guile/index.html</a>
</li>

<li>Having fun with Guile: a tutorial<br />
<a href="http://dustycloud.org/misc/guile-tutorial.html">http://dustycloud.org/misc/guile-tutorial.html</a>
</li>

<li>Guile: Loading Readline Support<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/Loading-Readline-Support.html#Loading-Readline-Support">https://www.gnu.org/software/guile/manual/html_node/Loading-Readline-Support.html#Loading-Readline-Support</a>
</li>

<li>lispy<br />
<a href="https://pypi.org/project/lispy/">https://pypi.org/project/lispy/</a>
</li>

<li>Lython<br />
<a href="https://pypi.org/project/Lython/">https://pypi.org/project/Lython/</a>
</li>

<li>Lizpop<br />
<a href="https://pypi.org/project/lizpop/">https://pypi.org/project/lizpop/</a>
</li>

<li>Budoucnost programovacích jazyků<br />
<a href="http://www.knesl.com/budoucnost-programovacich-jazyku">http://www.knesl.com/budoucnost-programovacich-jazyku</a>
</li>

<li>LISP Prolog and Evolution<br />
<a href="http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html">http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html</a>
</li>

<li>List of Lisp-family programming languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages">https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages</a>
</li>

<li>clojure_py na indexu PyPi<br />
<a href="https://pypi.python.org/pypi/clojure_py">https://pypi.python.org/pypi/clojure_py</a>
</li>

<li>PyClojure<br />
<a href="https://github.com/eigenhombre/PyClojure">https://github.com/eigenhombre/PyClojure</a>
</li>

<li>Hy na GitHubu<br />
<a href="https://github.com/hylang/hy">https://github.com/hylang/hy</a>
</li>

<li>Hy: The survival guide<br />
<a href="https://notes.pault.ag/hy-survival-guide/">https://notes.pault.ag/hy-survival-guide/</a>
</li>

<li>Hy běžící na monitoru terminálu společnosti Symbolics<br />
<a href="http://try-hy.appspot.com/">http://try-hy.appspot.com/</a>
</li>

<li>Welcome to Hy’s documentation!<br />
<a href="http://docs.hylang.org/en/stable/">http://docs.hylang.org/en/stable/</a>
</li>

<li>Hy na PyPi<br />
<a href="https://pypi.org/project/hy/#description">https://pypi.org/project/hy/#description</a>
</li>

<li>Getting Hy on Python<br />
<a href="https://lwn.net/Articles/596626/">https://lwn.net/Articles/596626/</a>
</li>

<li>Programming Can Be Fun with Hy<br />
<a href="https://opensourceforu.com/2014/02/programming-can-fun-hy/">https://opensourceforu.com/2014/02/programming-can-fun-hy/</a>
</li>

<li>Přednáška o projektu Hy (pětiminutový lighttalk)<br />
<a href="http://blog.pault.ag/day/2013/04/02">http://blog.pault.ag/day/2013/04/02</a>
</li>

<li>Hy (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Hy">https://en.wikipedia.org/wiki/Hy</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Point<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Point.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Point.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Narrowing<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Narrowing.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Narrowing.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Functions that Create Markers<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Markers.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Markers.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Motion<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Motion.html#Motion">https://www.gnu.org/software/emacs/manual/html_node/elisp/Motion.html#Motion</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Basic Char Syntax<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Char-Syntax.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Char-Syntax.html</a>
</li>

<li>Elisp: Sequence: List, Array<br />
<a href="http://ergoemacs.org/emacs/elisp_list_vs_vector.html">http://ergoemacs.org/emacs/elisp_list_vs_vector.html</a>
</li>

<li>Elisp: Property List<br />
<a href="http://ergoemacs.org/emacs/elisp_property_list.html">http://ergoemacs.org/emacs/elisp_property_list.html</a>
</li>

<li>Elisp: Hash Table<br />
<a href="http://ergoemacs.org/emacs/elisp_hash_table.html">http://ergoemacs.org/emacs/elisp_hash_table.html</a>
</li>

<li>Elisp: Association List<br />
<a href="http://ergoemacs.org/emacs/elisp_association_list.html">http://ergoemacs.org/emacs/elisp_association_list.html</a>
</li>

<li>The mapcar Function (An Introduction to Programming in Emacs Lisp)<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/mapcar.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/mapcar.html</a>
</li>

<li>Anaphoric macro<br />
<a href="https://en.wikipedia.org/wiki/Anaphoric_macro">https://en.wikipedia.org/wiki/Anaphoric_macro</a>
</li>

<li>Some Common Lisp Loop Macro Examples<br />
<a href="https://www.youtube.com/watch?v=3yl8o6r_omw">https://www.youtube.com/watch?v=3yl8o6r_omw</a>
</li>

<li>A Guided Tour of Emacs<br />
<a href="https://www.gnu.org/software/emacs/tour/">https://www.gnu.org/software/emacs/tour/</a>
</li>

<li>The Roots of Lisp<br />
<a href="http://www.paulgraham.com/rootsoflisp.html">http://www.paulgraham.com/rootsoflisp.html</a>
</li>

<li>Evil (Emacs Wiki)<br />
<a href="https://www.emacswiki.org/emacs/Evil">https://www.emacswiki.org/emacs/Evil</a>
</li>

<li>Evil (na GitHubu)<br />
<a href="https://github.com/emacs-evil/evil">https://github.com/emacs-evil/evil</a>
</li>

<li>Evil (na stránkách repositáře MELPA)<br />
<a href="https://melpa.org/#/evil">https://melpa.org/#/evil</a>
</li>

<li>Evil Mode: How I Switched From VIM to Emacs<br />
<a href="https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html">https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html</a>
</li>

<li>GNU Emacs (home page)<br />
<a href="https://www.gnu.org/software/emacs/">https://www.gnu.org/software/emacs/</a>
</li>

<li>GNU Emacs (texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs">http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs</a>
</li>

<li>An Introduction To Using GDB Under Emacs<br />
<a href="http://tedlab.mit.edu/~dr/gdbintro.html">http://tedlab.mit.edu/~dr/gdbintro.html</a>
</li>

<li>An Introduction to Programming in Emacs Lisp<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html</a>
</li>

<li>27.6 Running Debuggers Under Emacs<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html">https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html</a>
</li>

<li>GdbMode<br />
<a href="http://www.emacswiki.org/emacs/GdbMode">http://www.emacswiki.org/emacs/GdbMode</a>
</li>

<li>Emacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Emacs">https://en.wikipedia.org/wiki/Emacs</a>
</li>

<li>Emacs timeline<br />
<a href="http://www.jwz.org/doc/emacs-timeline.html">http://www.jwz.org/doc/emacs-timeline.html</a>
</li>

<li>Emacs Text Editors Family<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?EmacsFamily">http://texteditors.org/cgi-bin/wiki.pl?EmacsFamily</a>
</li>

<li>Vrapper aneb spojení možností Vimu a Eclipse<br />
<a href="https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse/">https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse/</a>
</li>

<li>Vrapper aneb spojení možností Vimu a Eclipse (část 2: vyhledávání a nahrazování textu)<br />
<a href="https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse-cast-2-vyhledavani-a-nahrazovani-textu/">https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse-cast-2-vyhledavani-a-nahrazovani-textu/</a>
</li>

<li>Emacs/Evil-mode - A basic reference to using evil mode in Emacs<br />
<a href="http://www.aakarshnair.com/posts/emacs-evil-mode-cheatsheet">http://www.aakarshnair.com/posts/emacs-evil-mode-cheatsheet</a>
</li>

<li>From Vim to Emacs+Evil chaotic migration guide<br />
<a href="https://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/">https://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/</a>
</li>

<li>Introduction to evil-mode {video)<br />
<a href="https://www.youtube.com/watch?v=PeVQwYUxYEg">https://www.youtube.com/watch?v=PeVQwYUxYEg</a>
</li>

<li>EINE (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/EINE">http://www.emacswiki.org/emacs/EINE</a>
</li>

<li>EINE (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?EINE">http://texteditors.org/cgi-bin/wiki.pl?EINE</a>
</li>

<li>ZWEI (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/ZWEI">http://www.emacswiki.org/emacs/ZWEI</a>
</li>

<li>ZWEI (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?ZWEI">http://texteditors.org/cgi-bin/wiki.pl?ZWEI</a>
</li>

<li>Zmacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Zmacs">https://en.wikipedia.org/wiki/Zmacs</a>
</li>

<li>Zmacs (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?Zmacs">http://texteditors.org/cgi-bin/wiki.pl?Zmacs</a>
</li>

<li>TecoEmacs (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/TecoEmacs">http://www.emacswiki.org/emacs/TecoEmacs</a>
</li>

<li>Micro Emacs<br />
<a href="http://www.emacswiki.org/emacs/MicroEmacs">http://www.emacswiki.org/emacs/MicroEmacs</a>
</li>

<li>Micro Emacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/MicroEMACS">https://en.wikipedia.org/wiki/MicroEMACS</a>
</li>

<li>EmacsHistory<br />
<a href="http://www.emacswiki.org/emacs/EmacsHistory">http://www.emacswiki.org/emacs/EmacsHistory</a>
</li>

<li>Seznam editorů s ovládáním podobným Emacsu či kompatibilních s příkazy Emacsu<br />
<a href="http://www.finseth.com/emacs.html">http://www.finseth.com/emacs.html</a>
</li>

<li>evil-numbers<br />
<a href="https://github.com/cofi/evil-numbers">https://github.com/cofi/evil-numbers</a>
</li>

<li>Debuggery a jejich nadstavby v&nbsp;Linuxu (1.část)<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/</a>
</li>

<li>Debuggery a jejich nadstavby v&nbsp;Linuxu (2.část)<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (3): Nemiver<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (4): KDbg<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (5): ladění aplikací v editorech Emacs a Vim<br />
<a href="https://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">https://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/</a>
</li>

<li>Org mode<br />
<a href="https://orgmode.org/">https://orgmode.org/</a>
</li>

<li>The Org Manual<br />
<a href="https://orgmode.org/manual/index.html">https://orgmode.org/manual/index.html</a>
</li>

<li>Kakoune (modální textový editor)<br />
<a href="http://kakoune.org/">http://kakoune.org/</a>
</li>

<li>Vim-style keybinding in Emacs/Evil-mode<br />
<a href="https://gist.github.com/troyp/6b4c9e1c8670200c04c16036805773d8">https://gist.github.com/troyp/6b4c9e1c8670200c04c16036805773d8</a>
</li>

<li>Emacs - jak začít<br />
<a href="http://www.abclinuxu.cz/clanky/navody/emacs-jak-zacit">http://www.abclinuxu.cz/clanky/navody/emacs-jak-zacit</a>
</li>

<li>Programovací jazyk LISP a LISP machines<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-lisp-a-lisp-machines/">https://www.root.cz/clanky/programovaci-jazyk-lisp-a-lisp-machines/</a>
</li>

<li>Evil-surround<br />
<a href="https://github.com/emacs-evil/evil-surround">https://github.com/emacs-evil/evil-surround</a>
</li>

<li>Spacemacs<br />
<a href="http://spacemacs.org/">http://spacemacs.org/</a>
</li>

<li>Lisp: Common Lisp, Racket, Clojure, Emacs Lisp<br />
<a href="http://hyperpolyglot.org/lisp">http://hyperpolyglot.org/lisp</a>
</li>

<li>Common Lisp, Scheme, Clojure, And Elisp Compared<br />
<a href="http://irreal.org/blog/?p=725">http://irreal.org/blog/?p=725</a>
</li>

<li>Does Elisp Suck?<br />
<a href="http://irreal.org/blog/?p=675">http://irreal.org/blog/?p=675</a>
</li>

<li>Emacs pro mírně pokročilé (9): Elisp<br />
<a href="https://www.root.cz/clanky/emacs-elisp/">https://www.root.cz/clanky/emacs-elisp/</a>
</li>

<li>If I want to learn lisp, are emacs and elisp a good choice?<br />
<a href="https://www.reddit.com/r/emacs/comments/2m141y/if_i_want_to_learn_lisp_are_emacs_and_elisp_a/">https://www.reddit.com/r/emacs/comments/2m141y/if_i_want_to_learn_lisp_are_emacs_and_elisp_a/</a>
</li>

<li>Clojure(Script) Interactive Development Environment that Rocks!<br />
<a href="https://github.com/clojure-emacs/cider">https://github.com/clojure-emacs/cider</a>
</li>

<li>An Introduction to Emacs Lisp<br />
<a href="https://harryrschwartz.com/2014/04/08/an-introduction-to-emacs-lisp.html">https://harryrschwartz.com/2014/04/08/an-introduction-to-emacs-lisp.html</a>
</li>

<li>Emergency Elisp<br />
<a href="http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html">http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html</a>
</li>

<li>Lambda calculus<br />
<a href="https://en.wikipedia.org/wiki/Lambda_calculus">https://en.wikipedia.org/wiki/Lambda_calculus</a>
</li>

<li>John McCarthy's original LISP paper from 1959<br />
<a href="https://www.reddit.com/r/programming/comments/17lpz4/john_mccarthys_original_lisp_paper_from_1959/">https://www.reddit.com/r/programming/comments/17lpz4/john_mccarthys_original_lisp_paper_from_1959/</a>
</li>

<li>Micro Manual LISP<br />
<a href="https://www.scribd.com/document/54050141/Micro-Manual-LISP">https://www.scribd.com/document/54050141/Micro-Manual-LISP</a>
</li>

<li>How Lisp Became God's Own Programming Language<br />
<a href="https://twobithistory.org/2018/10/14/lisp.html">https://twobithistory.org/2018/10/14/lisp.html</a>
</li>

<li>History of Lisp<br />
<a href="http://jmc.stanford.edu/articles/lisp/lisp.pdf">http://jmc.stanford.edu/articles/lisp/lisp.pdf</a>
</li>

<li>The Roots of Lisp<br />
<a href="http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf">http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf</a>
</li>

<li>Racket<br />
<a href="https://racket-lang.org/">https://racket-lang.org/</a>
</li>

<li>The Racket Manifesto<br />
<a href="http://felleisen.org/matthias/manifesto/">http://felleisen.org/matthias/manifesto/</a>
</li>

<li>MIT replaces Scheme with Python<br />
<a href="https://www.johndcook.com/blog/2009/03/26/mit-replaces-scheme-with-python/">https://www.johndcook.com/blog/2009/03/26/mit-replaces-scheme-with-python/</a>
</li>

<li>Adventures in Advanced Symbolic Programming<br />
<a href="http://groups.csail.mit.edu/mac/users/gjs/6.945/">http://groups.csail.mit.edu/mac/users/gjs/6.945/</a>
</li>

<li>Why MIT Switched from Scheme to Python (2009)<br />
<a href="https://news.ycombinator.com/item?id=14167453">https://news.ycombinator.com/item?id=14167453</a>
</li>

<li>Starodávná stránka XLispu<br />
<a href="http://www.xlisp.org/">http://www.xlisp.org/</a>
</li>

<li>AutoLISP<br />
<a href="https://en.wikipedia.org/wiki/AutoLISP">https://en.wikipedia.org/wiki/AutoLISP</a>
</li>

<li>Seriál PicoLisp: minimalistický a výkonný interpret Lispu<br />
<a href="https://www.root.cz/serialy/picolisp-minimalisticky-a-vykonny-interpret-lispu/">https://www.root.cz/serialy/picolisp-minimalisticky-a-vykonny-interpret-lispu/</a>
</li>

<li>Common Lisp<br />
<a href="https://common-lisp.net/">https://common-lisp.net/</a>
</li>

<li>Getting Going with Common Lisp<br />
<a href="https://cliki.net/Getting%20Started">https://cliki.net/Getting%20Started</a>
</li>

<li>Online Tutorial (Common Lisp)<br />
<a href="https://cliki.net/online%20tutorial">https://cliki.net/online%20tutorial</a>
</li>

<li>Guile Emacs<br />
<a href="https://www.emacswiki.org/emacs/GuileEmacs">https://www.emacswiki.org/emacs/GuileEmacs</a>
</li>

<li>Guile Emacs History<br />
<a href="https://www.emacswiki.org/emacs/GuileEmacsHistory">https://www.emacswiki.org/emacs/GuileEmacsHistory</a>
</li>

<li>Guile is a programming language<br />
<a href="https://www.gnu.org/software/guile/">https://www.gnu.org/software/guile/</a>
</li>

<li>MIT Scheme<br />
<a href="http://groups.csail.mit.edu/mac/projects/scheme/">http://groups.csail.mit.edu/mac/projects/scheme/</a>
</li>

<li>SIOD: Scheme in One Defun<br />
<a href="http://people.delphiforums.com/gjc//siod.html">http://people.delphiforums.com/gjc//siod.html</a>
</li>

<li>CommonLispForEmacs<br />
<a href="https://www.emacswiki.org/emacs/CommonLispForEmacs">https://www.emacswiki.org/emacs/CommonLispForEmacs</a>
</li>

<li>Elisp: print, princ, prin1, format, message<br />
<a href="http://ergoemacs.org/emacs/elisp_printing.html">http://ergoemacs.org/emacs/elisp_printing.html</a>
</li>

<li>Special Forms in Lisp<br />
<a href="http://www.nhplace.com/kent/Papers/Special-Forms.html">http://www.nhplace.com/kent/Papers/Special-Forms.html</a>
</li>

<li>Basic Building Blocks in LISP<br />
<a href="https://www.tutorialspoint.com/lisp/lisp_basic_syntax.htm">https://www.tutorialspoint.com/lisp/lisp_basic_syntax.htm</a>
</li>

<li>Introduction to LISP - University of Pittsburgh<br />
<a href="https://people.cs.pitt.edu/~milos/courses/cs2740/Lectures/LispTutorial.pdf">https://people.cs.pitt.edu/~milos/courses/cs2740/Lectures/LispTutorial.pdf</a>
</li>

<li>Why don't people use LISP<br />
<a href="https://forums.freebsd.org/threads/why-dont-people-use-lisp.24572/">https://forums.freebsd.org/threads/why-dont-people-use-lisp.24572/</a>
</li>

<li>Structured program theorem<br />
<a href="https://en.wikipedia.org/wiki/Structured_program_theorem">https://en.wikipedia.org/wiki/Structured_program_theorem</a>
</li>

<li>Clojure: API Documentation<br />
<a href="https://clojure.org/api/api">https://clojure.org/api/api</a>
</li>

<li>Tutorial for the Common Lisp Loop Macro<br />
<a href="http://www.ai.sri.com/pkarp/loop.html">http://www.ai.sri.com/pkarp/loop.html</a>
</li>

<li>Common Lisp's Loop Macro Examples for Beginners<br />
<a href="http://www.unixuser.org/~euske/doc/cl/loop.html">http://www.unixuser.org/~euske/doc/cl/loop.html</a>
</li>

<li>A modern list api for Emacs. No 'cl required.<br />
<a href="https://github.com/magnars/dash.el">https://github.com/magnars/dash.el</a>
</li>

<li>The LOOP Facility<br />
<a href="http://www.lispworks.com/documentation/HyperSpec/Body/06_a.htm">http://www.lispworks.com/documentation/HyperSpec/Body/06_a.htm</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>Transient Data Structures
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>LISP: Lex Fridman's favorite programming language<br />
<a href="https://www.youtube.com/watch?v=cMMiaCtOzV0">https://www.youtube.com/watch?v=cMMiaCtOzV0</a>
</li>

<li>What is the Curse of Lisp?<br />
<a href="https://www.youtube.com/watch?v=_J3x5yvQ8yc">https://www.youtube.com/watch?v=_J3x5yvQ8yc</a>
</li>

<li>Array Programming Re-Imagined in Lisp<br />
<a href="https://github.com/phantomics/april">https://github.com/phantomics/april</a>
</li>

<li>What is Nil Punning?<br />
<a href="https://www.youtube.com/watch?v=xiYKuDk6G-o">https://www.youtube.com/watch?v=xiYKuDk6G-o</a>
</li>

<li>Python VS Common Lisp, workflow and ecosystem<br />
<a href="https://lisp-journey.gitlab.io/pythonvslisp/">https://lisp-journey.gitlab.io/pythonvslisp/</a>
</li>

<li>A fast-moving Common Lisp software distribution<br />
<a href="https://ultralisp.org/">https://ultralisp.org/</a>
</li>

<li>Numcl<br />
<a href="https://github.com/numcl/numcl">https://github.com/numcl/numcl</a>
</li>

<li>Petalisp<br />
<a href="https://github.com/marcoheisig/Petalisp">https://github.com/marcoheisig/Petalisp</a>
</li>

<li>Common Lisp for the Curious Clojurian - Alan Dipert - Scicloj meeting 19<br />
<a href="https://www.youtube.com/watch?v=44Q9ew9JH_U">https://www.youtube.com/watch?v=44Q9ew9JH_U</a>
</li>

<li>Peter Norvig on Python<br />
<a href="https://serverhorror.wordpress.com/2010/10/19/peter-norvig-on-python/">https://serverhorror.wordpress.com/2010/10/19/peter-norvig-on-python/</a>
</li>

<li>A History of the Common Lisp<br />
<a href="https://www.cleverism.com/skills-and-tools/common-lisp/">https://www.cleverism.com/skills-and-tools/common-lisp/</a>
</li>

<li>Starting with Common Lisp in 2020<br />
<a href="http://dnaeon.github.io/starting-with-common-lisp-in-2020/">http://dnaeon.github.io/starting-with-common-lisp-in-2020/</a>
</li>

<li>JACL: JavaScript Assisted Common Lisp<br />
<a href="https://tailrecursion.com/JACL/">https://tailrecursion.com/JACL/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

