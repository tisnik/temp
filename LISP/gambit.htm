<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Projekt Gambit - další kvalitní interpret i překladač programovacího jazyka Scheme</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Projekt Gambit - další kvalitní interpret i překladač programovacího jazyka Scheme</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V současnosti existuje přibližně 50 reálně použitelných implementací programovacího jazyka Scheme, ovšem jen zhruba patnáct implementací je skutečně vhodných pro produkční nasazení. Mezi nejkvalitnější a nejrychlejší implementace Scheme patří projekt nazvaný Gambit, který si dnes představíme.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Projekt Gambit &ndash; další kvalitní interpret i překladač programovacího jazyka Scheme</a></p>
<p><a href="#k02">2. Transpřekladače; interaktivní smyčka REPL</a></p>
<p><a href="#k03">3. Gambit se představuje</a></p>
<p><a href="#k04">4. Instalace projektu Gambit</a></p>
<p><a href="#k05">5. Interpret a překladač &ndash; <strong>gsi</strong> a <strong>gsc</strong></a></p>
<p><a href="#k06">6. Použití interpretru dodávaného současně s&nbsp;Gambitem</a></p>
<p><a href="#k07">7. Debugger, který je součástí REPLu</a></p>
<p><a href="#k08">8. Základní vlastnosti jazyka Scheme</a></p>
<p><a href="#k09">9. Rozšíření zavedená (nejenom) systémem Gambit &ndash; nepovinné parametry funkcí</a></p>
<p><a href="#k10">10. Další možnosti volání funkcí</a></p>
<p><a href="#k11">11. Definice nových datových typů (struktur)</a></p>
<p><a href="#k12">12. Příprava jednoduchého benchmarku</a></p>
<p><a href="#k13">13. Porovnání rychlosti interpretrů Gambit, GNU Guile a Chicken Scheme</a></p>
<p><a href="#k14">14. Rychlost benchmarku přeloženého do nativního kódu</a></p>
<p><a href="#k15">15. Přepis algoritmu takovým způsobem, aby používal výpočty s&nbsp;hodnotami s&nbsp;plovoucí řádovou čárkou</a></p>
<p><a href="#k16">16. Použití vláken, paralelizace výpočtů</a></p>
<p><a href="#k17">17. Porovnání všech benchmarků</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Literatura</a></p>
<p><a href="#k20">20. Předchozí části seriálu</a></p>
<p><a href="#k21">21. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Projekt Gambit &ndash; další kvalitní interpret i překladač programovacího jazyka Scheme</h2>

<p><i>&bdquo;Scheme is simple, weird, and cool.&ldquo;</i></p>

<p><i>&bdquo;My God, It's full of 'car's&ldquo;</i></p>

<p>Jak jsme se již zmínili v&nbsp;perexu dnešního článku, existuje
v&nbsp;současnosti přibližně padesát reálně použitelných implementací
programovacího jazyka <i>Scheme</i>, ať již se jedná o interpretry či o
překladače. Pokud však budeme hledat skutečně kvalitní a stabilní implementaci
vhodnou pro produkční nasazení (a i když se to může zdát divné, Scheme skutečně
bývá takto nasazováno, i když se z&nbsp;různých důvodů jedná o málo známá
řešení), zmenšuje se počet vhodných systémů postavených nad jazykem Scheme na
zhruba patnáct, přičemž jednotlivé vhodné projekty můžeme podle použitých
technologií rozdělit do několika skupin:</p>

<ol>

<li>V&nbsp;první skupině nalezneme klasické interpretry běžící nad nějakým
virtuálním strojem popř.&nbsp;překladače do bajtkódu těchto virtuálních strojů.
Do této kategorie patří například <a
href="http://practical-scheme.net/gauche/">Gauche</a>, <a
href="https://www.root.cz/clanky/gnu-guile-interpret-scheme-vestavitelny-do-nativnich-aplikaci/">Guile</a>,
systém <a
href="https://www.root.cz/clanky/kawa-prekvapive-silny-a-vykonny-dialekt-scheme-pro-jvm/">Kawa</a>,
<a href="https://s48.org/">Scheme48</a>, <a href="http://sisc-scheme.org/">SISC
(Second Interpreter of Scheme)</a>, <a
href="https://people.csail.mit.edu/jaffer/SCM.html">SCM</a> či <a
href="http://www.littlewingpinball.com/doc/en/ypsilon/index.html">Ypsilon</a>
(ten se používá pro programování pravidel pinballů, resp.&nbsp;video verzí
těchto her). Některé ze zmíněných implementací Scheme používají vlastní
virtuální stroj (<i>Guile</i>), další pak nějakou již existující variantu
virtuálního stroje (<i>Kawa</i>, <i>SISC</i>).</li>

<li>Ve druhé skupině, která je relativně rozsáhlá, nalezneme překladače
programovacího jazyka Scheme do nativního (strojového) kódu. Do této kategorie
můžeme zařadit například <a href="https://scheme.com/">Chez Scheme</a> (ten
získal nejlepší hostname), <a href="http://ikarus-scheme.org/">Ikarus</a>, <a
href="http://larcenists.org/">Larceny</a>, <a
href="https://www.gnu.org/software/mit-scheme/">MIT Scheme</a>, <a
href="https://plt-scheme.org/software/mzscheme/">MzScheme</a> či již popsaný
rozsáhlý systém <a
href="https://www.root.cz/clanky/racket-programovaci-jazyk-a-soucasne-i-platforma-pro-vyvoj-novych-jazyku/">Racket</a>
založený na MzScheme, který je mj.&nbsp;používán i pro výuku (a to mj.&nbsp;i
proto, že obsahuje vlastní GUI, podporu pro tvorbu grafů, interpretry dalších
jazyků apod.).</li>

<li>A konečně existuje i skupina implementací programovacího jazyka Scheme
založená na <i>transpřekladači (transcompileru, transpileru)</i>, typicky
s&nbsp;výstupem do programovacího jazyka C. To znamená, že se vstupní kód
napsaný v&nbsp;jazyce Scheme analyzuje, transformuje a optimalizuje, ovšem
výstupem není přímo strojový kód, ale více či méně čitelný kód naprogramovaný
v&nbsp;jazyku C (a teoreticky samozřejmě i do jiného jazyka, podle mě by byl
v&nbsp;této roli ideální jazyk <a
href="https://www.root.cz/serialy/programovaci-jazyk-rust/">Rust</a>). Do této
skupiny řadíme především čtveřici <a
href="http://www-sop.inria.fr/indes/fp/Bigloo/">Bigloo</a>, <a
href="https://www.root.cz/clanky/chicken-scheme-dalsi-interpret-a-predevsim-prekladac-programovaciho-jazyka-scheme/">Chicken</a>,
<a href="http://www.gambitscheme.org/wiki/index.php/Main_Page">Gambit-C</a> a
<a href="https://engineering.purdue.edu/~qobi/software/">Stalin</a>. Ovšem
transpřekladačem může být vybavena i implementace <i>SISC</i> zmíněná
v&nbsp;první skupině (tento transpřekladač se jmenuje Hobbit).</li>

</ol>

<p>V&nbsp;dnešním článku se zaměříme na třetí zmíněnou skupinu, konkrétně na
projekt <i>Gambit-C</i> či zkráceně jen <i>Gambit</i>. Tento projekt obsahuje
jak již zmíněný <a
href="https://en.wikipedia.org/wiki/Source-to-source_compiler">transpřekladač</a>,
tak i interpret doplněný o <a
href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">interaktivní
programovou smyčku REPL</a> neboli <i>Read-Eval-Print-Loop</i> (REPL je podle
mého názoru jedním z&nbsp;nejdůležitějších vynálezů v&nbsp;oblasti IT &ndash;
zdaleka se totiž nemusí jednat o pouhou interaktivní příkazovou řádku, což
ostatně ukazuje popularita projektů založených na diářích, například <a
href="https://www.root.cz/clanky/jupyter-notebook-nastroj-pro-programatory-vyzkumniky-i-lektory/">Jupyter
Notebooku</a>).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Transpřekladače; interaktivní smyčka REPL</h2>

<p><div class="rs-tip-major">Poznámka: tato kapitola je krátkou odbočkou
s&nbsp;popisem dvou technologií, s&nbsp;nimiž se v&nbsp;souvislosti
s&nbsp;<i>Gambit</i> setkáme. Jedná se o technologii transpřekladačů a taktéž o
koncept interaktivní smyčky REPL.</div></p>

<p>V&nbsp;úvodní kapitole jsme se mj.&nbsp;zmínili i o problematice takzvaných
<i>transpřekladačů</i> (<i>transcompilers</i>, <i>source-to-source
compilers</i>). Připomeňme si, že transpřekladače jsou (dosti obecně řečeno)
nástroje sloužící pro překlad algoritmů zapsaných v&nbsp;nějakém zdrojovém
programovacím jazyce do zvoleného cílového jazyka (ovšem nikoli do nativního
kódu, mezikódu &ndash; intermetidate code &ndash; či bajtkódu, to je totiž role
běžných překladačů).</p>

<p>Transpřekladače se v&nbsp;informatice používají již po několik desetiletí;
například se stále můžeme setkat s&nbsp;nástroji, které převádí kód
z&nbsp;nějakého vyššího programovacího jazyka do Céčka, které je dnes
s&nbsp;trochou nadsázky chápáno jako &bdquo;univerzální assembler&ldquo;. Asi
nejznámějším příkladem staršího použití transpřekladačů je nástroj nazvaný
<strong>web2c</strong>, jenž slouží pro transformaci zdrojových kódů
<i>TeXu</i> do céčka. Transpřekladače se stávají velmi populární i pro
programátory webových aplikací, a to zejména z&nbsp;toho důvodu, že webové
prohlížeče nativně podporují většinou pouze JavaScript, který je tak přirozeně
cílovým jazykem transpřekladačů (proto se také JavaScriptu někdy říká
&bdquo;assembler pro web&ldquo;).</p>

<p>Z&nbsp;praxe můžeme uvést například následující projekty založené na
transpřekladači:</p>

<table>
<tr><th>#</th><th>Jazyk či transpřekladač</th><th>Poznámka</th></tr>
<tr><td>1</td><td>CoffeeScript</td><td>přidání syntaktického cukru do JavaScriptu</td></tr>
<tr><td>2</td><td><a href="https://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">ClojureScript</a></td><td>překlad aplikací psaných v&nbsp;Clojure do JavaScriptu</td></tr>
<tr><td>3</td><td>TypeScript</td><td>nadmnožina jazyka JavaScript, přidání datových typů</td></tr>
<tr><td>4</td><td>6to5</td><td>transpřeklad z&nbsp;ECMAScript 6 (nová varianta JavaScriptu) do starší varianty JavaScriptu</td></tr>
<tr><td>5</td><td>Kaffeine</td><td>rozšíření JavaScriptu o nové vlastnosti</td></tr>
<tr><td>6</td><td>RedScript</td><td>jazyk inspirovaný Ruby</td></tr>
<tr><td>7</td><td>GorillaScript</td><td>další rozšíření JavaScriptu</td></tr>
<tr><td>8</td><td>ghcjs</td><td>transpřekladač pro fanoušky programovacího jazyka Haskell</td></tr>
<tr><td>9</td><td>Haxe</td><td>transpřekladač, mezi jehož cílové jazyka patří i Java a JavaScript</td></tr>
<tr><td>10</td><td><a href="https://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp/">Wisp</a></td><td>transpřekladač jazyka podobného Clojure, opět do JavaScriptu</td></tr>
<tr><td>11</td><td>ScriptSharp</td><td>transpřekladač z&nbsp;C# do JavaScriptu</td></tr>
<tr><td>12</td><td>Dart</td><td>transpřekladač z&nbsp;jazyka Dart do JavaScriptu</td></tr>
<tr><td>13</td><td>COBOL &rarr; C</td><td>transpřekladač OpenCOBOL</td></tr>
<tr><td>14</td><td>COBOL &rarr; Java</td><td>transpřekladač P3COBOL</td></tr>
<tr><td>15</td><td><a href="https://www.root.cz/clanky/programovaci-jazyk-lua-v-roli-skriptovaciho-jazyka-pro-www-stranky/#k06">lua2js</a></td><td>transpřekladač jazyka Lua, opět do JavaScriptu</td></tr>
<tr><td>16</td><td><a href="https://www.root.cz/clanky/coconut-funkcionalni-jazyk-s-pattern-matchingem-kompatibilni-s-pythonem/">Coconut</a></td><td>transpřekladač jazyka Coconut do Pythonu</td></tr>
</table>

<p>I s&nbsp;principem a použitím interaktivní smyčky REPL jsme se již na
stránkách Rootu setkali, a to dokonce mnohokrát. Kromě článků, které se
věnovaly klasickým Unixovým shellům typu <a
href="https://www.root.cz/clanky/programovani-v-bash-shellu/">BASH</a>, <a
href="https://www.root.cz/clanky/prikazovy-radek-pritel-nejvernejsi-2/">tcsh</a>
či <a href="https://www.root.cz/clanky/zuzo-shell/">zsh</a> (a rozhraní shellů
není nic jiného, než interaktivní REPL), jsme smyčku REPL použili například při
popisu <a
href="https://www.root.cz/serialy/programovaci-jazyk-julia/">programovacího
jazyka Julia</a> či <a
href="https://www.root.cz/vyhledavani/?qs=clojure">jazyka Clojure</a>. Historií
vzniku REPL jsme se zabývali i <a
href="https://www.root.cz/clanky/programovaci-jazyky-pouzivane-nejen-v-nbsp-sssr-cast-3-ndash-lisp#k02">zde</a>.</p>

<p>Některé smyčky REPL jsou pojaty přísně minimalisticky, což je případ dnes
již spíše méně často používaného <a
href="https://www.root.cz/serialy/programovaci-jazyk-tcl/">jazyka TCL</a>. Tato
interaktivní REPL dokonce ani neobsahuje historii příkazů či podporu pro pohyb
kurzoru na příkazovém řádku:</p>

<pre>
% 
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se liší i znak výzvy
(<i>prompt</i>), protože se namísto obvyklého &gt; používá znak procenta; to je
ovšem pouze marginální změna.</div></p>

<p>Další interaktivní REPL alespoň uživatele informují, v&nbsp;jakém prostředí
se nachází. To je případ REPL (opět velmi jednoduše pojaté) programovacího
jazyka Lua:</p>

<pre>
Lua 5.2.3  Copyright (C) 1994-2013 Lua.org, PUC-Rio
&gt;
</pre>

<p>REPL projektu <a
href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua/">LuaJIT</a>
vypadá nepatrně odlišně:</p>

<pre>
LuaJIT 2.1.0-beta3 -- Copyright (C) 2005-2017 Mike Pall. http://luajit.org/
JIT: ON SSE2 SSE3 SSE4.1 BMI2 fold cse dce fwd dse narrow loop abc sink fuse
&gt;
</pre>

<p>Nově se plnohodnotný REPL objevil i v&nbsp;jazyku Clojure;
v&nbsp;předchozích verzích se používal dále zmíněný alternativní nREPL:</p>

<pre>
Clojure 1.9.0
user=&gt;
</pre>

<p>Podobně vypadá REPL <a
href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">programovacího
jazyka Pixie</a> (to vlastně není nijak překvapivé, protože se opět jedná o
jednu z&nbsp;v:</p>

<pre>
user =&gt;
</pre>

<p>Interaktivní rozhraní projektu <a
href="https://www.root.cz/clanky/gnu-guile-interpret-scheme-vestavitelny-do-nativnich-aplikaci/">GNU
Guile</a>, což je jedna z&nbsp;variant programovacího jazyka Scheme:</p>

<pre>
GNU Guile 2.0.14
Copyright (C) 1995-2016 Free Software Foundation, Inc.
&nbsp;
Guile comes with ABSOLUTELY NO WARRANTY; for details type `,show w'.
This program is free software, and you are welcome to redistribute it
under certain conditions; type `,show c' for details.
&nbsp;
Enter `,help' for help.
scheme@(guile-user)&gt; 
</pre>

<p>Plnohodnotnou smyčku REPL se všemi vymoženostmi nabízí zejména <a
href="https://www.root.cz/serialy/programovaci-jazyk-julia/">programovací jazyk
Julia</a>, což ostatně není překvapivé, protože se tento jazyk používá právě
pro postupnou inkrementální tvorbu aplikací v&nbsp;interaktivním prostředí:</p>

<pre>
               _
   _       _ _(_)_     |  Documentation: https://docs.julialang.org
  (_)     | (_) (_)    |
   _ _   _| |_  __ _   |  Type "?" for help, "]?" for Pkg help.
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 1.0.0 (2018-08-08)
 _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release
|__/                   |
&nbsp; 
julia&gt;
</pre>

<p>Podobně je tomu v&nbsp;případě programovacího jazyka Clojure doplněného o
<i>nREPL</i> (ten lze spustit například příkazem <strong>lein
repl</strong>):</p>

<pre>
nREPL server started on port 42733 on host 127.0.0.1 - nrepl://127.0.0.1:42733
REPL-y 0.3.7, nREPL 0.2.12
Clojure 1.8.0
OpenJDK 64-Bit Server VM 1.8.0_171-b10
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e
&nbsp;
user=&gt; 
</pre>

<p>Samozřejmě nesmíme zapomenout ani na REPL <a
href="https://www.root.cz/serialy/programovaci-jazyk-r/">doménově specifického
jazyka R</a>:</p>

<pre>
R version 3.5.3 (2019-03-11) -- "Great Truth"
Copyright (C) 2019 The R Foundation for Statistical Computing
Platform: x86_64-redhat-linux-gnu (64-bit)
&nbsp;
R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.
&nbsp;
  Natural language support but running in an English locale
&nbsp;
R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.
&nbsp;
Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.
&nbsp;
During startup - Warning messages:
1: Setting LC_TIME failed, using "C" 
2: Setting LC_MONETARY failed, using "C" 
3: Setting LC_PAPER failed, using "C" 
4: Setting LC_MEASUREMENT failed, using "C" 
gt;
</pre>

<a href="https://www.root.cz/obrazek/359743/"><img src="https://i.iinfo.cz/images/553/bpython-1-prev.png" class="image-359743" alt="&#160;" width="370" height="242" /></a>
<p><i>Obrázek 1: Jedna z&nbsp;alternativních REPL určených pro programovací
jazyk Python.</i></p>

<p>A v&nbsp;neposlední řadě nalezneme REPL i v&nbsp;systému <i>Gambit</i>,
jemuž se věnujeme v&nbsp;dnešním článku:</p>

<pre>
$ <strong>gsi</strong>
Gambit v4.8.8
&nbsp;
&gt;
</pre>

<img src="https://i.iinfo.cz/images/143/python-interpreters-1-5.png" class="image-359592" alt="&#160;" width="336" height="240" />
<p><i>Obrázek 2: Za zjednodušenou formu interaktivní smyčky REPL je možné
považovat i takzvaný přímý mód (direct mode) použitý například v&nbsp;klasickém
BASICu. Na tomto screenshotu je v&nbsp;přímém módu zapsán příkaz
<strong>LIST</strong>.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Gambit se představuje</h2>

<p>Projekt <i>Gambit</i> má za sebou poměrně velmi dlouhý vývoj, protože jeho
existenci můžeme vysledovat až do roku 1989, tedy 31 let do minulosti.
V&nbsp;té době vznikl první překladač (tedy nikoli ještě transpřekladač) jazyka
Scheme generující strojový kód pro slavný mikroprocesor <a
href="https://www.root.cz/clanky/ctyricet-let-existence-slavnych-mikroprocesoru-rady-motorola-68000/">Motorola
68000</a> (M68k). Tehdy obsahoval Gambit skutečně pouze překladač, nikoli
interpret. Dokonce, což je zvláštní, se v&nbsp;runtime zpočátku ani nenacházel
systém pro automatickou správu paměti (<i>garbage collector</i>), což je pro
LISPovský programovací jazyk spíše výjimka.</p>

<p><div class="rs-tip-major">Poznámka: samotný LISP, z&nbsp;něhož byl jazyk
Scheme odvozen, je ovšem ještě starší. Jeho koncept <a
href="https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/">vznikl
již v&nbsp;roce 1958</a>.</div></p>

<a href="http://i.iinfo.cz/images/455/lisp01.png"><img src="http://i.iinfo.cz/images/455/lisp01-prev.png" alt="lisp01" height="270" width="257" /></a>
<p><i>Obrázek 3: Na tomto grafu evoluce programovacích jazyků můžeme vidět
některé historicky významné programovací jazyky, s&nbsp;nimiž jsme se již
setkali <a href="https://www.root.cz/serialy/unixove-vykopavky/">v&nbsp;seriálu
o historii počítačů</a>. Jedná se zejména o Fortran, Cobol, SNOBOL, Algol, APL,
BASIC (resp.&nbsp;přesněji řečeno celá rodina jazyků nesoucích toho jméno) a
samozřejmě taktéž o LISP a jeho varianty.</i></p>

<p>Historie systému Gambit-C resp.&nbsp;později Gambit v&nbsp;kostce:</p>

<ul>
<li>1989: první překladač pro mikroprocesor M68K, prozatím bez interprertru a bez GC</li>
<li>1991: MacGambit pro platformu Apple Macintosh</li>
<li>1994: první backend pro C, použití Gambitu v&nbsp;komerční sféře</li>
<li>2004: Gambit v4, podpora vláken, podporuje LGPL i Apache Licenci</li>
</ul>

<p>Původním cílem Gambitu bylo zajistit kompatibilitu <a
href="https://schemers.org/Documents/Standards/R5RS/">s&nbsp;R5RS</a>. Dále
bylo naplánováno vytvořit systém přenositelný na různé platformy
s&nbsp;generátorem velmi rychlého a současně i malého výsledného binárního
kódu. Dnes se s&nbsp;tímto systémem setkáme ve výzkumu, při převodu
(transpilaci) Scheme do céčka (což si popíšeme dnes), JavaScriptu či do VHDL a
Gambit je dostupný i pro embedded systémy (obraz může být menší než 20kB a
stále kompatibilní alespoň <a
href="https://people.csail.mit.edu/jaffer/r4rs.pdf">s&nbsp;R4RS</a>). Již méně
často se Gambit používá jako skriptovací jazyk vkládaný do aplikací; to je dnes
doménou <a
href="https://www.root.cz/clanky/gnu-guile-interpret-scheme-vestavitelny-do-nativnich-aplikaci">GNU
Guile</a>.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Instalace projektu Gambit</h2>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti si můžeme základní
vlastnosti systému Gambit otestovat na adrese <a
href="https://feeley.github.io/gambit-in-the-browser/">https://feeley.github.io/gambit-in-the-browser/</a>,
v&nbsp;níž Gambit REPL běží v&nbsp;prohlížeči.</div></p>

<p>Gambit je dostupný ve formě balíčku pro různé varianty Linuxu, takže mnohdy
ani není nutné stahovat a překládat zdrojové kódy. Instalace na postarší (dnes
již vlastně historické) Fedoře 27:</p>

<pre>
$ <strong>sudo dnf install gambit-c</strong>
&nbsp;
Last metadata expiration check: 0:09:50 ago on Sat 04 Jul 2020 08:05:09 PM CEST.
Dependencies resolved.
================================================================================
 Package           Arch            Version                Repository       Size
================================================================================
Installing:
 gambit-c          x86_64          4.8.8-3.fc27           fedora          6.3 M
&nbsp;
Transaction Summary
================================================================================
Install  1 Package
&nbsp;
Total download size: 6.3 M
Installed size: 41 M
Is this ok [y/N]:
</pre>

<p>Průběh instalace:</p>

<pre>
Downloading Packages:
gambit-c-4.8.8-3.fc27.x86_64.rpm                1.9 MB/s | 6.3 MB     00:03    
--------------------------------------------------------------------------------
Total                                           1.3 MB/s | 6.3 MB     00:04     
Running transaction check
Transaction check succeeded.
Running transaction test
Transaction test succeeded.
Running transaction
  Preparing        :                                                        1/1 
  Installing       : gambit-c-4.8.8-3.fc27.x86_64                           1/1 
  Running scriptlet: gambit-c-4.8.8-3.fc27.x86_64                           1/1 
Running as unit: run-r04b3ce47d8fc449e97c9e1ae9a102764.service
  Verifying        : gambit-c-4.8.8-3.fc27.x86_64                           1/1 
&nbsp;
Installed:
  gambit-c.x86_64 4.8.8-3.fc27                                                  
&nbsp;
Complete!
</pre>

<p>Instalace na Fedoře 32 (včetně překladače C a linkeru):</p>

<pre>
$ <strong>sudo dnf install gambit-c</strong>
&nbsp;
Dependencies resolved.
================================================================================
 Package           Arch     Version            Repository                  Size
================================================================================
Installing:
 gambit-c          x86_64   4.9.3-3.fc32       beaker-Fedora-Everything   6.0 M
Installing dependencies:
 binutils          x86_64   2.34-6.fc32        updates                    5.4 M
 binutils-gold     x86_64   2.34-6.fc32        updates                    852 k
 cpp               x86_64   10.2.1-6.fc32      updates                    9.4 M
 gcc               x86_64   10.2.1-6.fc32      updates                     30 M
 glibc-devel       x86_64   2.31-4.fc32        updates                    1.0 M
 glibc-headers     x86_64   2.31-4.fc32        updates                    457 k
 isl               x86_64   0.16.1-10.fc32     beaker-Fedora-Everything   872 k
 kernel-headers    x86_64   5.9.13-100.fc32    updates                    1.2 M
 libmpc            x86_64   1.1.0-8.fc32       beaker-Fedora-Everything    59 k
 libxcrypt-devel   x86_64   4.4.17-1.fc32      updates                     32 k
&nbsp;
Transaction Summary
================================================================================
Install  11 Packages
&nbsp;
Total download size: 55 M
Installed size: 191 M
</pre>

<p>Instalace na Linux Mintu (pozor na odlišné jméno balíčku):</p>

<pre>
$ <strong>sudo apt-get install install gambc</strong>
&nbsp;
Reading package lists... Done
Building dependency tree       
Reading state information... Done
The following additional packages will be installed:
  gambc-doc libgambit4 libgambit4-dev
The following NEW packages will be installed:
  gambc gambc-doc libgambit4 libgambit4-dev
0 upgraded, 4 newly installed, 0 to remove and 399 not upgraded.
Need to get 593 kB/3 101 kB of archives.
After this operation, 21,7 MB of additional disk space will be used.
Do you want to continue? [Y/n] <strong>y</strong>
&nbsp;
ading package lists... Done
&nbsp;
Setting up gambc-doc (4.8.8-3.1) ...
Setting up libgambit4:amd64 (4.8.8-3.1) ...
Setting up libgambit4-dev:amd64 (4.8.8-3.1) ...
Setting up gambc (4.8.8-3.1) ...
update-alternatives: using /usr/bin/gsi to provide /usr/bin/scheme-r5rs (scheme-r5rs) in auto mode
Processing triggers for libc-bin (2.31-0ubuntu9) ...
Processing triggers for man-db (2.9.1-1) ...
Processing triggers for install-info (6.7.0.dfsg.2-5) ...
Processing triggers for doc-base (0.10.9) ...
Processing 1 added doc-base file...
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Interpret a překladač &ndash; <strong>gsi</strong> a <strong>gsc</strong></h2>

<p>Gambit může být použit jak v&nbsp;režimu interpretru, tak i překladače.
Interpret se spouští příkazem <strong>gsi</strong>. Z&nbsp;uživatelského
pohledu se jedná o klasickou interaktivní smyčku REPL. Na rozdíl od Guile ve
výchozím nastavení (pokud explicitně neinicializujete modul s&nbsp;readline) je
možné pracovat s&nbsp;historií příkazů, používat kurzorové šipky, všechny
základní editační příkazy známé z&nbsp;BASHe (záleží na
<strong>.inputrc</strong>) atd.:</p>

<a href="https://www.root.cz/obrazek/439830/"><img src="https://i.iinfo.cz/images/256/gambit-scheme-2-prev.png" class="image-439830" alt="&#160;" width="370" height="232" /></a>
<p><i>Obrázek 4: Interaktivní smyčka REPL spuštěná příkazem
<strong>gsi</strong>.</i></p>

<p>Informace o konfiguraci interpretru v&nbsp;době jeho překladu zjistíme
snadno:</p>

<pre>
$ <strong>gsi -v</strong>
&nbsp;
v4.8.8 20170202123920 x86_64-redhat-linux-gnu "./configure
'--build=x86_64-redhat-linux-gnu' '--host=x86_64-redhat-linux-gnu'
'--program-prefix=' '--disable-dependency-tracking' '--prefix=/usr'
'--exec-prefix=/usr' '--bindir=/usr/bin' '--sbindir=/usr/sbin'
'--sysconfdir=/etc' '--datadir=/usr/share' '--includedir=/usr/include'
'--libdir=/usr/lib64' '--libexecdir=/usr/libexec' '--localstatedir=/var'
'--sharedstatedir=/var/lib' '--mandir=/usr/share/man'
'--infodir=/usr/share/info' '--enable-single-host' '--enable-c-opt'
'--enable-gcc-opts' '--bindir=/usr/lib64/gambit-c/bin'
'--libdir=/usr/lib64/gambit-c' 'build_alias=x86_64-redhat-linux-gnu'
'host_alias=x86_64-redhat-linux-gnu' 'CFLAGS=-O2 -g -pipe -Wall
-Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -fexceptions
-fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches
-specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -m64 -mtune=generic'
'LDFLAGS=-Wl,-z,relro -specs=/usr/lib/rpm/redhat/redhat-hardened-ld'
'CXXFLAGS=-O2 -g -pipe -Wall -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2
-fexceptions -fstack-protector-strong --param=ssp-buffer-size=4
-grecord-gcc-switches -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -m64
-mtune=generic'"
</pre>

<p>Překladač Gambitu se spouští příkazem <strong>gsc</strong>:</p>

<pre>
$ <strong>gsc -exe factorial_3.scm </strong>
&nbsp;
$ <strong>./factorial_3</strong>
3628800
</pre>

<p><div class="rs-tip-major">Poznámka: překlad (což je ve skutečnosti
transpřeklad a následné zavolání gcc a linkeru) je velmi rychlý, což je jeden
z&nbsp;obrovských praktických rozdílů mezi Gambitem a Clojure
(s&nbsp;Leiningenem):</div></p>

<pre>
$ <strong>time gsc -exe factorial_3.scm</strong>
&nbsp;
real    0m0.427s
user    0m0.375s
sys     0m0.048s
</pre>

<p>Lze se podívat i na přesnější informace o tom, jaké operace se při překladu
provádí:</p>

<pre>
$ <strong>gsc -exe -verbose factorial_3.scm</strong>
&nbsp;
Parsing:
  print
  factorial
  "expr"
&nbsp;
Compiling:
  print
factorial
fact-iter
&nbsp;
Dumping:
  #&lt;primitive | factorial_3|&gt;
  #&lt;procedure print&gt;
  #&lt;procedure factorial&gt;
&nbsp;
Compilation finished.
gcc -O2 -g -pipe -Wall -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -m64 -mtune=generic   -Wno-unused -Wno-write-strings -O2 -fwrapv -fno-strict-aliasing -fno-trapping-math -fno-math-errno -fschedule-insns2 -fmodulo-sched -freschedule-modulo-scheduled-loops -fomit-frame-pointer -fPIC -fno-common -mieee-fp -mpc64   -D___SINGLE_HOST  -I"/usr/include" -c -o "factorial_3.o"  factorial_3.c
gcc -O2 -g -pipe -Wall -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -m64 -mtune=generic   -Wno-unused -Wno-write-strings -O2 -fwrapv -fno-strict-aliasing -fno-trapping-math -fno-math-errno -fschedule-insns2 -fmodulo-sched -freschedule-modulo-scheduled-loops -fomit-frame-pointer -fPIC -fno-common -mieee-fp -mpc64   -D___SINGLE_HOST  -I"/usr/include" -c -o "factorial_3_.o"  factorial_3_.c
gcc -Wl,-z,relro -specs=/usr/lib/rpm/redhat/redhat-hardened-ld -O2 -g -pipe -Wall -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -m64 -mtune=generic   -Wno-unused -Wno-write-strings -O2 -fwrapv -fno-strict-aliasing -fno-trapping-math -fno-math-errno -fschedule-insns2 -fmodulo-sched -freschedule-modulo-scheduled-loops -fomit-frame-pointer -fPIC -fno-common -mieee-fp -mpc64   -rdynamic  -D___SINGLE_HOST  -I"/usr/include"  -o "factorial_3"   factorial_3.o factorial_3_.o "/usr/lib64/gambit-c/libgambit.a" -lutil -ldl -lm  
</pre>

<p>Opět můžeme zjistit, jaké přepínače a konfigurační volby byly použity při
jeho vlastním překladu:</p>

<pre>
$ <strong>gsc -v</strong>
&nbsp;
v4.8.8 20170202123920 x86_64-redhat-linux-gnu "./configure
'--build=x86_64-redhat-linux-gnu' '--host=x86_64-redhat-linux-gnu'
'--program-prefix=' '--disable-dependency-tracking' '--prefix=/usr'
'--exec-prefix=/usr' '--bindir=/usr/bin' '--sbindir=/usr/sbin'
'--sysconfdir=/etc' '--datadir=/usr/share' '--includedir=/usr/include'
'--libdir=/usr/lib64' '--libexecdir=/usr/libexec' '--localstatedir=/var'
'--sharedstatedir=/var/lib' '--mandir=/usr/share/man'
'--infodir=/usr/share/info' '--enable-single-host' '--enable-c-opt'
'--enable-gcc-opts' '--bindir=/usr/lib64/gambit-c/bin'
'--libdir=/usr/lib64/gambit-c' 'build_alias=x86_64-redhat-linux-gnu'
'host_alias=x86_64-redhat-linux-gnu' 'CFLAGS=-O2 -g -pipe -Wall
-Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -fexceptions
-fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches
-specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -m64 -mtune=generic'
'LDFLAGS=-Wl,-z,relro -specs=/usr/lib/rpm/redhat/redhat-hardened-ld'
'CXXFLAGS=-O2 -g -pipe -Wall -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2
-fexceptions -fstack-protector-strong --param=ssp-buffer-size=4
-grecord-gcc-switches -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -m64
-mtune=generic'"
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Použití interpretru dodávaného současně s&nbsp;Gambitem</h2>

<p>Interpret spouštěný příkazem <strong>gsi</strong> se v&nbsp;mnoha ohledech
podobá interpretru GNU Guile. Zadávané příkazy (resp.&nbsp;přesněji řečeno se
jedná o formy a speciální příkazy) jsou vykonány ihned poté, co je forma
ukončena a je stisknuta klávesa Enter. To znamená, že lze zadávat i víceřádkové
formy, což jsme si ukázali <a href="#k05">v&nbsp;předchozí kapitole</a> na
příkladu faktoriálu. Při zápisu forem se navíc provádí &bdquo;doskoky&ldquo; na
právě uzavřené závorky, což je u LISPovského jazyka užitečné. Důležité jsou
ovšem i speciální příkazy, kterými se ovládá vlastní REPL popř.&nbsp;debugger,
který je součástí REPLu. Tyto příkazy začínají čárkou, což znamená, že
s&nbsp;objekty, jejichž název začíná taktéž čárkou (což Scheme umožňuje), se
bude pracovat obtížně (ovšem kdo by používal takové identifikátory?).</p>

<p>Seznam všech dostupných příkazů REPLu získáme pomocí příkazy
<strong>,?</strong> (což je odlišné od GNU Guile!):</p>

<pre>
&gt; <strong>,?</strong>
&nbsp;
,?              : Summary of comma commands
,h   | ,(h X)   : Help on procedure of last error or procedure/macro named X
,q              : Terminate the process
,qt             : Terminate the current thread
,t              : Jump to toplevel REPL
,d              : Jump to enclosing REPL
,c   | ,(c X)   : Continue the computation with stepping off
,s   | ,(s X)   : Continue the computation with stepping on (step)
,l   | ,(l X)   : Continue the computation with stepping on (leap)
,N              : Move to specific continuation frame (N&gt;=0)
,N+  | ,N-      : Move forward/backward by N continuation frames (N&gt;=0)
,+   | ,-       : Like ,1+ and ,1-
,++  | ,--      : Like ,N+ and ,N- with N = nb. of frames at head of backtrace
,y              : Display one-line summary of current frame
,i              : Display procedure attached to current frame
,b   | ,(b X)   : Display backtrace of current continuation or X (cont/thread)
,be  | ,(be X)  : Like ,b and ,(b X) but also display environment
,bed | ,(bed X) : Like ,be and ,(be X) but also display dynamic environment
,e   | ,(e X)   : Display environment of current frame or X (proc/cont/thread)
,ed  | ,(ed X)  : Like ,e and ,(e X) but also display dynamic environment
,st  | ,(st X)  : Display current thread group, or X (thread/thread group)
,(v X)          : Start a REPL visiting X (proc/cont/thread)
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Debugger, který je součástí REPLu</h2>

<p>Nejdůležitější je podpora pro zjišťování problémů, které nastaly při běhu
skriptů &ndash; jedná se tedy o základní debugging. Můžeme si to vyzkoušet na
příkladu, který obsahuje chybu ve výpočtu:</p>

<pre>
(define (print item)
  (display item)
  (newline))
&nbsp;
(define (factorial n)
  (if (= n 0) ; podmínka pro ukončení rekurzivního zanořování
      <u>(/ n 0)</u> <strong>; chyba ve výpočtu</strong>
      (* n (factorial (- n 1)))
      )
  )
</pre>

<p>Skript nejdříve načteme:</p>

<pre>
&gt; <strong>(load "factorial_error.scm")</strong>
&nbsp;
"/home/ptisnovs/src/lisp-families/gambit/factorial_error.scm"
</pre>

<p>Zkusíme spustit výpočet, při němž dojde k&nbsp;chybě:</p>

<pre>
&gt; <strong>(factorial 10)</strong>
*** ERROR IN factorial, "factorial_error.scm"@8.14 -- Divide by zero
(/ 0 0)
</pre>

<p>K&nbsp;chybě došlo až hluboko v&nbsp;rekurzivním výpočtu, takže se pokusíme
získat další informace příkazem <strong>,b</strong>:</p>

<pre>
1&gt; <strong>,b</strong>
&nbsp;
0  factorial                                         "factorial_error.scm"@8:14                        (factorial (- n 1))
1  factorial                                         "factorial_error.scm"@8:14                        (factorial (- n 1))
2  factorial                                         "factorial_error.scm"@8:14                        (factorial (- n 1))
3  factorial                                         "factorial_error.scm"@8:14                        (factorial (- n 1))
4  factorial                                         "factorial_error.scm"@8:14                        (factorial (- n 1))
5  factorial                                         "factorial_error.scm"@8:14                        (factorial (- n 1))
6  factorial                                         "factorial_error.scm"@8:14                        (factorial (- n 1))
7  factorial                                         "factorial_error.scm"@8:14                        (factorial (- n 1))
8  factorial                                         "factorial_error.scm"@8:14                        (factorial (- n 1))
9  factorial                                         "factorial_error.scm"@8:14                        (factorial (- n 1))
10 (interaction)                                     (console)@2:1                                     (factorial 10)
</pre>

<p>Podrobnější informace o tom, s&nbsp;jakými parametry byly funkce volány
v&nbsp;rekurzivním výpočtu:</p>

<pre>
2&gt; <strong>,be</strong>
&nbsp;
0  (interaction)                                     (console)@4:33                                    x
        n = 1
1  factorial                                         "factorial_error.scm"@8:14                        (factorial (- n 1))
        n = 1
2  factorial                                         "factorial_error.scm"@8:14                        (factorial (- n 1))
        n = 2
3  factorial                                         "factorial_error.scm"@8:14                        (factorial (- n 1))
        n = 3
4  factorial                                         "factorial_error.scm"@8:14                        (factorial (- n 1))
        n = 4
5  factorial                                         "factorial_error.scm"@8:14                        (factorial (- n 1))
        n = 5
6  factorial                                         "factorial_error.scm"@8:14                        (factorial (- n 1))
        n = 6
7  factorial                                         "factorial_error.scm"@8:14                        (factorial (- n 1))
        n = 7
8  factorial                                         "factorial_error.scm"@8:14                        (factorial (- n 1))
        n = 8
9  factorial                                         "factorial_error.scm"@8:14                        (factorial (- n 1))
        n = 9
10 factorial                                         "factorial_error.scm"@8:14                        (factorial (- n 1))
        n = 10
11 (interaction)                                     (console)@2:1                                     (factorial 10)
</pre>

<p>A konečně se můžeme v&nbsp;zásobníkových rámcích pohybovat a dostat se
přesně na tu oblast, kterou je zapotřebí více prozkoumat:</p>

<pre>
2&gt; <strong>,bed</strong>
&nbsp;
0  (interaction)                                     (console)@4:33                                    x
        n = 1
        (current-exception-handler) = primordial-exception-handler
        (current-input-port) = '#&lt;input-output-port #2 (console)&gt;
        (current-output-port) = '#&lt;input-output-port #2 (console)&gt;
        (current-directory) = "/home/ptisnovs/src/other/lisp-families/gambit/"
1  factorial                                         "factorial_error.scm"@8:14                        (factorial (- n 1))
        n = 1
        (current-exception-handler) = primordial-exception-handler
        (current-input-port) = '#&lt;input-output-port #2 (console)&gt;
        (current-output-port) = '#&lt;input-output-port #2 (console)&gt;
        (current-directory) = "/home/ptisnovs/src/other/lisp-families/gambit/"
2  factorial                                         "factorial_error.scm"@8:14                        (factorial (- n 1))
        n = 2
        (current-exception-handler) = primordial-exception-handler
        (current-input-port) = '#&lt;input-output-port #2 (console)&gt;
        (current-output-port) = '#&lt;input-output-port #2 (console)&gt;
        (current-directory) = "/home/ptisnovs/src/other/lisp-families/gambit/"
&nbsp;
2&gt; <strong>,2+</strong>
&nbsp;
2  factorial                                         "factorial_error.scm"@8.14                        (factorial (- n 1))
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Základní vlastnosti jazyka Scheme</h2>

<p>Gambit podporuje všechny vlastnosti popsané v&nbsp;R4RS i R5RS, takže jen
v&nbsp;krátkosti (většinu příkladů jsme již viděli s&nbsp;výjimkou
continuations a práci s&nbsp;výjimkami).</p>

<p>Práce s&nbsp;tečka-dvojicemi:</p>

<pre>
(print '(1 . 2))
&nbsp;
(print '(1 . ((2 . 3) . 4)))
&nbsp;
(print '((1 . 2) . (3 . 4)))
&nbsp;
<i>; this is proper list</i>
(print '(1 . (2 . (3 . nil))))
&nbsp;
<i>; this is proper list</i>
(print '(1 . (2 . (3 . ()))))
</pre>

<p>Konstrukce seznamů:</p>

<pre>
(print (cons 1 2))
&nbsp;
(print (cons 1 (cons 2 3)))
&nbsp;
(print '((1 . 2) . (3 . 4)))
&nbsp;
<i>; this is proper list</i>
(print (cons 1 (cons 2 (cons 3 '()))))
&nbsp;
(define nil '())
&nbsp;
<i>; this is proper list</i>
(print (cons 1 (cons 2 (cons 3 nil))))
</pre>

<p>Přístup k&nbsp;prvkům seznamů:</p>

<pre>
(print '(1 2 3 4))
&nbsp;
(print (list 1 2 3 4))
&nbsp;
<i>; create list and assign it to symbol</i>
<i>; (=variable)</i>
(define a '(1 2 3 4))
&nbsp;
<i>; get the first item</i>
(print (car a))
&nbsp;
<i>; get the rest of a list</i>
(print (cdr a))
&nbsp;
<i>; combination of car+cdr</i>
(print (cadr a))
&nbsp;
<i>; combination of cdr+cdr</i>
(print (cddr a))
</pre>

<p>Standardní predikáty:</p>

<pre>
(define nil '())
&nbsp;
(print "pair?")
(print (pair? nil))
(print (pair? #t))
(print (pair? 42))
(print (pair? "string"))
(print (pair? '(1 2 3)))
(newline)
&nbsp;
(print "list?")
(print (list? nil))
(print (list? #t))
(print (list? 42))
(print (list? "string"))
(print (list? '(1 2 3)))
(newline)
&nbsp;
(print "null?")
(print (null? nil))
(print (null? #t))
(print (null? 42))
(print (null? "string"))
(print (null? '(1 2 3)))
(newline)
&nbsp;
(print "zero?")
(print (zero? 0))
(print (zero? 42))
(newline)
</pre>

<p>Blok <strong>begin</strong> s&nbsp;formami, které se postupně vykonávají:</p>

<pre>
(begin
  (print "pair?")
  (print (pair? nil))
  (print (pair? #t))
  (print (pair? 42))
  (print (pair? "string"))
  (print (pair? '(1 2 3)))
  (newline))
&nbsp;
(begin
  (print "list?")
  (print (list? nil))
  (print (list? #t))
  (print (list? 42))
  (print (list? "string"))
  (print (list? '(1 2 3)))
  (newline))
&nbsp;
(begin
  (print "null?")
  (print (null? nil))
  (print (null? #t))
  (print (null? 42))
  (print (null? "string"))
  (print (null? '(1 2 3)))
  (newline))
&nbsp;
(begin
  (print "zero?")
  (print (zero? 0))
  (print (zero? 42))
  (newline))
</pre>

<p>Logické operace a použití speciálních forem <strong>and</strong> a
<strong>or</strong> namísto <strong>if</strong>:</p>

<pre>
(define nil '())
&nbsp;
(print (and #t #t))
(print (and #t nil))
(print (or #t #t))
(print (or #t nil))
(print (or nil nil #t nil))
(print (or nil nil nil nil))
(print (not nil))
(print (not #t))
&nbsp;
(define x 10)
(print (if (&gt; x 0) "kladne" "zaporne"))
&nbsp;
(define y 0)
(print (if (&gt; y 0) "kladne" "zaporne"))
&nbsp;
(define x 10)
(print (and (&gt; x 0) "kladne"))
&nbsp;
(define y 0)
(print (and (&gt; y 0) "kladne"))
</pre>

<p>Speciální forma <strong>cond</strong> zobecňující rozeskoky:</p>

<pre>
(define (<strong>sgn</strong> n)
  (cond
    ((&lt; n 0)      'negative)
    ((&gt; n 0)      'positive)
    ((zero? n)    'zero)))
&nbsp;
(print "sgn")
(print (sgn -10))
(print (sgn 0))
(print (sgn 10))
(newline)
&nbsp;
&nbsp;
(define (sgn-2 n)
  (cond
    ((&lt; n 0)      'negative)
    ((&gt; n 0)      'positive)
    (#t           'zero)))
&nbsp;
(print "sgn-2")
(print (sgn-2 -10))
(print (sgn-2 0))
(print (sgn-2 10))
(newline)
&nbsp;
(define (<strong>sgn</strong> n)
  (cond
    ((not (number? n)) 'not-a-number)
    ((&lt; n 0)      'negative)
    ((&gt; n 0)      'positive)
    ((zero? n)    'zero)))
&nbsp;
(print (sgn -10))
(print (sgn 0))
(print (sgn 10))
&nbsp;
(print (sgn '()))
</pre>

<p>Konstrukce vektorů, přístup k&nbsp;prvkům vektorů:</p>

<pre>
(define vector1 '#(1 2 3 4))
&nbsp;
(display vector1)
(newline)
&nbsp;
(display (vector-ref vector1 0))
(display (vector-ref vector1 10))
</pre>

<p>Mutace prvků vektorů:</p>

<pre>
(define vector2 (vector 1 2 3 4 5))
&nbsp;
(display vector2)
(newline)
&nbsp;
(display (vector-ref vector2 0))
(newline)
&nbsp;
(vector-set! vector2 2 -1)
&nbsp;
(display vector2)
(newline)
</pre>

<p>Anonymní funkce:</p>

<pre>
(lambda () (print "no parameters"))
&nbsp;
(lambda (a) (print "one parameter"))
&nbsp;
(lambda (a b) (print "two parameters"))
&nbsp;
(lambda (a . b) (print "at least one parameter"))
&nbsp;
(lambda (a b . c) (print "at least two parameters"))
&nbsp;
(lambda x (print "zero or more parameters"))
</pre>

<p>Pojmenované funkce:</p>

<pre>
<i>; one-liner function</i>
(define (<strong>add</strong> x y) (+ x y))
&nbsp;
<i>; function written on more lines</i>
(define (<strong>mul</strong> x y)
  (* x y))
&nbsp;
<i>; function written on more lines using lambda</i>
(define <strong>div</strong> (lambda (x y)
  (* x y)))
&nbsp;
<i>; test functions</i>
(print (add 1 2))
(print (mul 6 7))
(print (div 10 3))
</pre>

<p>Uzávěry:</p>

<pre>
(define <strong>counter</strong>
  (let ((i -1))
    (lambda ()
      (set! i (+ i 1))
      i)))
&nbsp;
(print (counter))
(print (counter))
(print (counter))
</pre>

<p>Více nezávislých čítačů:</p>

<pre>
(define (<strong>get-counter</strong>)
  (let ((i -1))
    (lambda ()
      (set! i (+ i 1))
      i)))
&nbsp;
(define <strong>counter1</strong> (get-counter))
(define <strong>counter2</strong> (get-counter))
&nbsp;
(print (counter1))
(print (counter1))
(print (counter1))
&nbsp;
(print (counter2))
(print (counter2))
(print (counter2))
&nbsp;
(print (counter1))
(print (counter1))
(print (counter1))
</pre>

<p>Použití <i>quote</i> a <i>quasiquote</i> (nejenom) při konstrukci seznamů:</p>

<pre>
(define b (list 1 2 3))
&nbsp;
(print "quote:")
(print '(a b c))
(print '(a ,b c))
(print '(a ,@b c))
(newline)
&nbsp;
(print "quasiquote:")
(print `(a b c))
(print `(a ,b c))
(print `(a ,@b c))
(newline)
</pre>

<p>Novinkou (resp.&nbsp;ne zcela běžnou věcí) je zachytávání výjimek, které je
ukázáno na příkladu s&nbsp;funkcí, která nevyhodí výjimku při dělení nulou.
Namísto toho vrátí <strong>#f</strong>, což je výsledek anonymní funkce
akceptující objekt s&nbsp;chybou:</p>

<pre>
(define (<strong>safe-div</strong> x y)
  (with-exception-catcher
    (lambda (error) #f)
    (lambda () (/ x y))))
&nbsp;
(print (safe-div 10 3))
(print (safe-div 10 0))
</pre>

<p>A poslední ne vždy implementovanou vlastností jsou takzvané
<i>continuations</i> (pokračování), což je obecně velmi užitečná programovací
technika, kterou si vysvětlíme v&nbsp;samostatném článku:</p>

<pre>
(define c1 #f)
&nbsp;
(define (<strong>test-cc</strong>)
  (let ((i 0))
    (call/cc (lambda (k) (set! c1 k)))
    (set! i (+ i 1))
    i))
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Rozšíření zavedená (nejenom) systémem Gambit &ndash; nepovinné parametry funkcí</h2>

<p>Gambit, podobně jako některé další varianty jazyka Scheme, umožňuje volání
funkcí s&nbsp;proměnným počtem parametrů popř.&nbsp;s&nbsp;nepovinnými
parametry. Funkce s&nbsp;nepovinnými parametry se používají následovně:</p>

<pre>
(define (<strong>f1</strong>)
  (print "no parameters"))
&nbsp;
(define (<strong>f2</strong> a)
  (print "one parameter")
  (print a))
&nbsp;
(define (<strong>f3</strong> a b)
  (print "two parameters")
  (print a)
  (print b))
&nbsp;
(define (<strong>f4</strong> a #!optional b)
  (print "at least one parameter")
  (print a)
  (print b))
&nbsp;
(define (<strong>f5</strong> a b #!optional c)
  (print "at least two parameters")
  (print a)
  (print b)
  (print c))
&nbsp;
(define (<strong>f6</strong> a #!optional (b -1))
  (print "at least one parameter")
  (print a)
  (print b))
&nbsp;
(define (<strong>f7</strong> a b #!optional (c -1))
  (print "at least two parameters")
  (print a)
  (print b)
  (print c))
&nbsp;
(f1)
(f2 10)
(f3 1 2)
(f4 1)
(f4 1 2)
(f5 1 2)
(f5 1 2 3)
(f6 1)
(f6 1 2)
(f7 1 2)
(f7 1 2 3)
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
no parameters
one parameter
10
two parameters
1
2
at least one parameter
1
#f
at least one parameter
1
2
at least two parameters
1
2
#f
at least two parameters
1
2
3
at least one parameter
1
-1
at least one parameter
1
2
at least two parameters
1
2
-1
at least two parameters
1
2
3
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že u nepovinných
parametrů je možné zadat jejich výchozí hodnotu (parametr i hodnota musí být
v&nbsp;samostatné závorce). Pokud výchozí hodnota není uvedena, použije se
namísto ní <strong>#f</strong>.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Další možnosti volání funkcí</h2>

<p>Použití proměnného počtu parametrů &ndash; zbylé parametry se uloží do
seznamu za tečkou:</p>

<pre>
(define (<strong>f1</strong>)
  (print "no parameters"))
&nbsp;
(define (<strong>f2</strong> a)
  (print "one parameter")
  (print a))
&nbsp;
(define (<strong>f3</strong> a b)
  (print "two parameters")
  (print a)
  (print b))
&nbsp;
(define (<strong>f4</strong> a . b)
  (print "at least one parameter")
  (print a)
  (print b))
&nbsp;
(define (<strong>f5</strong> a b . c)
  (print "at least two parameters")
  (print a)
  (print b)
  (print c))
&nbsp;
(f1)
(f2 10)
(f3 1 2)
(f4 1)
(f4 1 2)
(f4 1 2 3)
(f5 1 2)
(f5 1 2 3)
(f5 1 2 3 4)
</pre>

<p>Výsledky:</p>

<pre>

no parameters
one parameter
10
two parameters
1
2
at least one parameter
1
()
at least one parameter
1
(2)
at least one parameter
1
(2 3)
at least two parameters
1
2
()
at least two parameters
1
2
(3)
at least two parameters
1
2
(3 4)
</pre>

<p>Pojmenované parametry:</p>

<pre>
(define (<strong>f</strong> b #!key c (d 7) (e 8))
  (print b)
  (print c)
  (print e)
  (print e)
  (newline))
&nbsp;
(f 0)
(f 1 c: 2)
(f 1 e: 5)
(f 1 c: 2 d: 3 e: 4)
</pre>

<p>Výsledky:</p>

<pre>
0
#f
8
8
&nbsp;
1
2
8
8
&nbsp;
1
#f
5
5
&nbsp;
1
2
4
4
</pre>

<p>A konečně kombinace nepovinných parametrů a tzv.&bdquo;rest&ldquo;
(zbývajících) parametrů:</p>

<pre>
(define (<strong>f1</strong> #!optional (a 4) #!key (b 5) c)
  (print a)
  (print b)
  (print c)
  (newline))
&nbsp;
(define (<strong>f2</strong> #!key (i 5) #!rest j)
  (print i)
  (print j)
  (newline))
&nbsp;
(f1)
(f1 1)
(f1 2 b: 3)
(f1 4 b: 5 c: 6)
(f1 7 c: 8)
(f2 9)
(f2 10 i: 11)
(f2 i: 12 13)
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Definice nových datových typů (struktur)</h2>

<p>S&nbsp;využitím formy <strong>define-type</strong> je možné definovat tvar
nové datové struktury, pro kterou se navíc automaticky vytvoří konstruktor,
funkce pro přístup k&nbsp;prvkům struktury (gettery), funkce pro modifikaci
prvků struktury (settery, mutátory) i predikáty pro nový datový typ. Podívejme
se nyní na jednoduchý příklad s&nbsp;datovou strukturou pojmenovanou
<strong>user</strong> s&nbsp;prvky nazvanými <strong>name</strong> a
<strong>surname</strong>. Po zavolání <strong>define-type</strong> se vytvoří
konstruktor <strong>make-user</strong>, gettery <strong>user-name</strong> a
<strong>user-surname</strong> i mutátory <strong>user-name-set!</strong> a
<strong>user-surname-set!</strong>. Zapomenout nesmíme ani na predikát
<strong>user?</strong>:</p>

<pre>
(define (<strong>print</strong> item)
  (display item)
  (newline))
&nbsp;
(define-type <u>user</u> name surname)
&nbsp;
<i>; konstruktor</i>
(define <strong>john</strong> (make-user "John" "?"))
(print john)
&nbsp;
<i>; gettery</i>
(print (user-name john))
(print (user-surname john))
&nbsp;
<i>; mutatory (settery)</i>
(user-name-set! john "Real John")
(user-surname-set! john "Doe")
(print john)
(print (user-name john))
(print (user-surname john))
&nbsp;
<i>; predikaty</i>
(print (user? 42))
(print (user? john))
</pre>

<p>Příklad použití:</p>

<pre>
#&lt;user #2 name: "John" surname: "?"&gt;
John
?
#&lt;user #2 name: "Real John" surname: "Doe"&gt;
Real John
Doe
#f
#t
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Příprava jednoduchého benchmarku</h2>

<p>V&nbsp;úvodních kapitolách jsme si řekli, že projekt <i>Gambit</i> může být
pro vývojáře zajímavý mj.&nbsp;i proto, že je vybaven rychlým a plnohodnotným
překladačem. Zkusme tedy zjistit, jak kvalitní kód tento překladač dokáže
generovat; provedeme přitom porovnání s&nbsp;již dříve popsanými implementacemi
programovacího jazyka Scheme, tedy zejména s&nbsp;<i>GNU Guile</i> a <i>Chicken
Scheme</i>. Pro tento účel si připravíme jednoduchý benchmark, s&nbsp;nímž jsme
se vlastně již seznámili v&nbsp;předchozích článcích. Jedná se o program určený
pro iterativní výpočet konstanty &pi; s&nbsp;využitím (velmi pomalu
konvergujícího) <i>Wallisova součinu</i> (<i>Wallis product</i>, který je
popsán například na stránce <a
href="https://en.wikipedia.org/wiki/Wallis_product">https://en.wikipedia.org/wiki/Wallis_product</a>).
Jeden z&nbsp;možných přepisů tohoto algoritmu do Scheme může vypadat
následovně:</p>

<pre>
(define (<strong>compute-pi</strong> n)
  (let ((pi 4.0))
    (do ((i 3 (+ i 2)))
      ((&gt; i (+ n 2)))
      (set! pi (* pi (/ (- i 1) i) (/ (+ i 1) i))))
    pi))
&nbsp;
(do ((n 1 (* n 2)))
  ((&gt; n 10000000))
  (display n)
  (display " ")
  (display (compute-pi n))
  (newline))
</pre>

<p><div class="rs-tip-major">Poznámka: využíváme zde spíše imperativního
přístupu a nikoli přístupu funkcionálního. To je patrné zejména v&nbsp;použití
forem <strong>do</strong>, které jsou ovšem pro programy psané ve Scheme
většinou dosti netypické. Funkcionální tvar by mohl vypadat takto:</div></p>

<pre>
(define (<strong>compute-pi</strong> n)
  (let loop ((pi 4.0)
             (i 3))
    (if (&lt;= i (+ n 2))
        (loop (* pi (/ (- i 1) i) (/ (+ i 1) i))
              (+ i 2))
        pi)))
&nbsp; 
(let loop ((n 1))
  (display n)
  (display " ")
  (display (compute-pi n))
  (newline)
  (if (&lt;= n 10000000)
      (loop (* n 2))))
</pre>

<p>Výše uvedený benchmark použijeme v&nbsp;následujících kapitolách pro
otestování kvality či nekvality výsledného kódu generovaného Gambitem-C.</p>

<p>Pro porovnání přepíšeme benchmark i do jazyka Clojure:</p>

<pre>
(ns pi-1.core
  (:gen-class))
&nbsp;
(defn <strong>compute-pi</strong>
  [n]
  (loop [pi 4.0
         i  3]
         (if (&lt; i (+ n 2))
             (recur (* pi (/ (- i 1) i) (/ (+ i 1) i))
                    (+ i 2))
             pi)))
&nbsp;
(defn -main
  [&amp; args]
  (loop [n 1]
    (print n "\t")
    (println (compute-pi n))
    (if (&lt; n 5000000)
      (recur (* n 2)))))
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Porovnání rychlosti interpretrů Gambit, GNU Guile a Chicken Scheme</h2>

<p>S&nbsp;projektem nazvaným <i>GNU Guile</i> jsme se již <a
href="https://www.root.cz/clanky/gnu-guile-interpret-scheme-vestavitelny-do-nativnich-aplikaci/">v&nbsp;tomto
seriálu seznámili</a>. Jedná se o interpret jazyka Scheme doplněný o JIT
překladač, takže můžeme předpokládat, že by výpočetní výkon takto doplněného
interpretru mohl být vyšší, než je tomu v&nbsp;případě jednoduchého interpretru
dodávaného s&nbsp;projektem <i>Chicken Scheme</i>. Ostatně se o tomto
předpokladu můžeme snadno přesvědčit, protože <a href="#k12">výše popsaný</a>
výpočet konstanty &pi; je napsán takovým způsobem, že je kompatibilní jak
s&nbsp;GNU Guile, tak i s&nbsp;Gambitem a Chicken Scheme (ovšem pozor &ndash;
ne všechny konstrukce je možné mezi těmito implementacemi Scheme bez problémů
přenášet i přesto, že je zachována kompatibilita s&nbsp;RnRS).</p>

<p>Nejprve tedy výpočet spustíme v&nbsp;GNU Guile a budeme sledovat jak
strojový čas strávený výpočtem, tak i celkový čas viditelný vnějším
pozorovatelem (což je mnohdy důležitější ukazatel):</p>

<pre>
$ <strong>time guile pi1.scm</strong>
</pre>

<p>Výsledky, na jejichž konci jsou zobrazeny i časové údaje:</p>

<pre>
1 3.5555555555555554
2 3.5555555555555554
4 3.4133333333333336
8 3.302393550012597
16 3.230036466411716
32 3.1881271694471383
64 3.1654820600347926
128 3.1536988490957967
256 3.147686899556418
512 3.1446501625172
1024 3.143124017028185
2048 3.142358989121772
4096 3.141975985005608
8192 3.1417843602347433
16384 3.1416885171495856
32768 3.1416405879293077
65536 3.1416166213993866
131072 3.1416046376544267
262144 3.1415986456618494
524288 3.141595649635512
1048576 3.141594151614876
2097152 3.141593402602468
4194304 3.1415930280955355
8388608 3.1415928408418403
&nbsp;
real    0m4.858s
user    0m5.212s
sys     0m0.058s
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že čas strávený výpočtem
je z&nbsp;pohledu uživatele cca 4,8 sekundy (<strong>real</strong>=čas, který
je možné změřit stopkami vně počítače), zatímco z&nbsp;pohledu mikroprocesoru
je čas delší &ndash; celých 5,70 sekund
(<strong>user</strong>+<strong>sys</strong>). To znamená, že některé výpočty
musely být provedeny ve více vláknech, což je ostatně jen dobře.</div></p>

<p>Nyní si vyzkoušejme, jestli bude výpočet &pi; podle stejného skriptu
s&nbsp;využitím <i>interpretru</i> nástroje Chicken Scheme rychlejší nebo
pomalejší. Použijeme přepínače <strong>-b</strong> a <strong>-q</strong>, které
zajistí, že se interpret po dokončení výpočtů ihned ukončí a že se na začátku
nebudou zobrazovat úvodní informace o projektu Chicken Scheme (což sice nevede
k&nbsp;žádnému podstatnému urychlení, ale ke zpřesnění výsledných časů):</p>

<pre>
$ <strong>time csi -b -q pi1.scm</strong>
</pre>

<p>Samotné výsledky výpočtu by měly být přibližně podobné, minimálně na prvních
sedmi až osmi desetinných místech:</p>

<pre>
1 3.55555555555556
2 3.55555555555556
4 3.41333333333333
8 3.3023935500126
16 3.23003646641172
32 3.18812716944714
64 3.16548206003479
128 3.1536988490958
256 3.14768689955642
512 3.1446501625172
1024 3.14312401702818
2048 3.14235898912177
4096 3.14197598500561
8192 3.14178436023474
16384 3.14168851714959
32768 3.14164058792931
65536 3.14161662139939
131072 3.14160463765443
262144 3.14159864566185
524288 3.14159564963551
1048576 3.14159415161488
2097152 3.14159340260247
4194304 3.14159302809554
8388608 3.14159284084184
&nbsp;
real    0m8.137s
user    0m7.739s
sys     0m0.318s
</pre>

<p>Čas celého výpočtu je v&nbsp;tomto případě výrazně delší, než tomu je
v&nbsp;porovnání s&nbsp;projektem GNU Guile. Dále můžeme při porovnání všech
tří časů předpokládat, že výpočet běžel pouze v&nbsp;jediném vláknu (což je
ostatně pravda).</p>

<p>Nakonec vyzkoušíme stejný výpočet (a naprosto stejný zdrojový kód) spustit
<i>v&nbsp;intepretru</i> Gambitu:</p>

<pre>
$ <strong>time gsi pi_1.scm</strong>
</pre>

<p>Výsledky:</p>

<pre>
1 3.5555555555555554
2 3.5555555555555554
4 3.4133333333333336
8 3.302393550012597
16 3.230036466411716
32 3.1881271694471383
64 3.1654820600347926
128 3.1536988490957967
256 3.147686899556418
512 3.1446501625172
1024 3.143124017028185
2048 3.142358989121772
4096 3.141975985005608
8192 3.1417843602347433
16384 3.1416885171495856
32768 3.1416405879293077
65536 3.1416166213993866
131072 3.1416046376544267
262144 3.1415986456618494
524288 3.141595649635512
1048576 3.141594151614876
2097152 3.141593402602468
4194304 3.1415930280955355
8388608 3.1415928408418403
&nbsp;
real    0m46.689s
user    0m46.610s
sys     0m0.007s
</pre>

<p>Stručné porovnání výsledků:</p>

<table>
<tr><th>#</th><th>Interpret</th><th>real</th><th>user</th><th>sys</th></tr>
<tr><td>1</td><td>GNU Guile</td><td>4,858</td><td>5,212</td><td>0,058</td></tr>
<tr><td>2</td><td>Chicken Scheme</td><td>8,137</td><td>7,738</td><td>0,318</td></tr>
<tr><td>3</td><td>Gambit (gsi)</td><td>46,689</td><td>46,610</td><td>0,007</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: vidíme, že interpret Gambitu
v&nbsp;žádném případě není rychlejší, než je tomu v&nbsp;GNU Guile a Chicken
Scheme.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Rychlost benchmarku přeloženého do nativního kódu</h2>

<p>Nyní se pokusme náš testovací příklad přeložit a zjistit, jak a zda došlo
k&nbsp;urychlení výpočtů:</p>

<pre>
$ <strong>gsc -exe pi_1.scm </strong>
</pre>

<p>Pokud se překlad povedl, spustíme benchmark:</p>

<pre>
$ <strong>time ./pi_1</strong>
</pre>

<p>Výsledky:</p>

<pre>
real    0m37.454s
user    0m37.390s
sys     0m0.008s
</pre>

<p><div class="rs-tip-major">Poznámka: po překladu sice dosáhneme určitého
urychlení výpočtů, ovšem stále je výsledek <i>přeloženého programu</i>
pomalejší, než v&nbsp;případě <i>interpretrů</i> GNU Guile či Chicken
Scheme!</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Přepis algoritmu takovým způsobem, aby používal výpočty s&nbsp;hodnotami s&nbsp;plovoucí řádovou čárkou</h2>

<p>Algoritmus je možné v&nbsp;případě potřeby ještě vyššího výpočetního výkonu
přepsat takovým způsobem, aby se výpočty prováděly s&nbsp;hodnotami
s&nbsp;plovoucí řádovou čárkou. To se zajistí jak deklarací
<strong>mostly-flonum</strong> užitečné pro překladač, tak i použitím operátorů
fl*, fl/ a fl+ namísto operátorů *, / a +:</p>

<pre>
(declare
  (<strong>mostly-flonum</strong>)
  (block)
  (not safe))
&nbsp;
(define (compute-pi n)
  (let ((pi 4.0))
    (do ((i 3.0 (fl+ i 2.0)))
      ((<strong>fl&gt;</strong> i (<strong>fl+</strong> n 2.0)))
      (set! pi (<strong>fl*</strong> pi (<strong>fl/</strong> (<strong>fl-</strong> i 1.0) i) (<strong>fl/</strong> (<strong>fl+</strong> i 1.0) i))))
    pi))
 &nbsp;
(do ((n 1.0 (* n 2)))
  ((&gt; n 10000000))
  (display n)
  (display " ")
  (display (compute-pi n))
  (newline))
</pre>

<p>Výsledek běhu interpretru (<strong>gsi</strong>):</p>

<pre>
1. 3.5555555555555554
2. 3.5555555555555554
4. 3.4133333333333336
8. 3.302393550012597
16. 3.230036466411716
32. 3.1881271694471383
64. 3.1654820600347926
128. 3.1536988490957967
256. 3.147686899556418
512. 3.1446501625172
1024. 3.143124017028185
2048. 3.142358989121772
4096. 3.141975985005608
8192. 3.1417843602347433
16384. 3.1416885171495856
32768. 3.1416405879293077
65536. 3.1416166213993866
131072. 3.1416046376544267
262144. 3.1415986456618494
524288. 3.141595649635512
1048576. 3.141594151614876
2097152. 3.141593402602468
4194304. 3.1415930280955355
8388608. 3.1415928408418403
</pre>

<p>Čas dosažený při interpretaci:</p>

<pre>
real    0m8.188s
user    0m8.169s
sys     0m0.008s
</pre>

<p>Ještě si vyzkoušíme rychlost výpočtu po překladu, kde by se měly plně
projevit optimalizace při překladu:</p>

<pre>
$ <strong>gsc -exe pi_3_flonum.scm </strong>
</pre>

<p>Výsledky výpočtů:</p>

<pre>
$ <strong>time ./pi_3_flonum</strong>
&nbsp;
1. 3.5555555555555554
2. 3.5555555555555554
4. 3.4133333333333336
8. 3.302393550012597
16. 3.230036466411716
32. 3.1881271694471383
64. 3.1654820600347926
128. 3.1536988490957967
256. 3.147686899556418
512. 3.1446501625172
1024. 3.143124017028185
2048. 3.142358989121772
4096. 3.141975985005608
8192. 3.1417843602347433
16384. 3.1416885171495856
32768. 3.1416405879293077
65536. 3.1416166213993866
131072. 3.1416046376544267
262144. 3.1415986456618494
524288. 3.141595649635512
1048576. 3.141594151614876
2097152. 3.141593402602468
4194304. 3.1415930280955355
8388608. 3.1415928408418403
</pre>

<p>Dosažený čas:</p>

<pre>
real    0m0.153s
user    0m0.141s
sys     0m0.011s
</pre>

<p><div class="rs-tip-major">Poznámka: zde jsme již dosáhli znatelného
urychlení, což znamená, že Gambit může být při pečlivém naprogramování
užitečný. Ovšem pokračujme dále.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Použití vláken, paralelizace výpočtů</h2>

<p>Jednou z&nbsp;předností Gambitu je relativně jednoduchá paralelizace výpočtů
(i když ne tak jednoduchá, jako by tomu bylo v&nbsp;případě použití gorutin a
kanálů). V&nbsp;runtime lze výpočty upravit takovým způsobem, aby počet vláken
odpovídal počtu procesorových jader. Existuje přitom funkce nazvaná
<strong>##cpu-count</strong> vracející počet reálně dostupných jader a taktéž
funkce <strong>current-vm-processor-count</strong> vracející počet vláken OS,
které lze využít (s&nbsp;tím, že mapování vláken na CPU je ponecháno na
operačním systému).</p>

<p>Vytvoření vlákna zajistí forma <strong>make-thread</strong>, které se předá
kód, který se má spustit. Spuštění vlákna se provede s&nbsp;využitím
<strong>thread-start!</strong>, čekání na dokončení vlákna pak pomocí
<strong>thread-join!</strong>. Podívejme se nyní, jak lze předchozí kód
paralelizovat i s&nbsp;akumulací výsledků:</p>

<pre>
<i>; původní funkce pro výpočet se nemusí měnit</i>
(define (<strong>compute-pi</strong> n)
  (let ((pi 4.0))
    (do ((i 3 (+ i 2)))
      ((&gt; i (+ n 2)))
      (set! pi (* pi (/ (- i 1) i) (/ (+ i 1) i))))
    pi))
&nbsp; 
<i>; pomocná funkce pro výpočet a zobrazení výsledků</i>
(define (<strong>pi-for</strong> n)
  (let ((pi (compute-pi n)))
      (display n)
      (display "\t")
      (display pi)
      (newline)))
&nbsp;
<i>; vytvoření seznamu se vstupními hodnotami n</i>
(define (<strong>power-of-two</strong> n maximum)
  (if (&lt; n maximum)
     (cons n (power-of-two (* n 2) maximum))
     (list n)))
&nbsp;
<i>; vytvoření výpočetních vláken</i>
(define threads (map (lambda (n) (make-thread (lambda () (pi-for n))))
                     (power-of-two 1 5000000)))
&nbsp;
<i>; spuštění všech vláken</i>
(for-each thread-start! threads)
&nbsp;
<i>; čekání na dokončení výpočtů ve všech vláknech</i>
(for-each thread-join!  threads)
</pre>

<p>Čas výpočtů:</p>

<pre>
$ <strong>time ./pi_parallel</strong>
&nbsp;
1       3.5555555555555554
2       3.5555555555555554
4       3.4133333333333336
8       3.302393550012597
16      3.230036466411716
32      3.1881271694471383
64      3.1654820600347926
128     3.1536988490957967
256     3.147686899556418
512     3.1446501625172
1024    3.143124017028185
2048    3.142358989121772
4096    3.141975985005608
8192    3.1417843602347433
16384   3.1416885171495856
32768   3.1416405879293077
65536   3.1416166213993866
131072  3.1416046376544267
262144  3.1415986456618494
524288  3.141595649635512
1048576 3.141594151614876
2097152 3.141593402602468
4194304 3.1415930280955355
8388608 3.1415928408418403
&nbsp;
real    0m36.867s
user    0m36.800s
sys     0m0.013s
</pre>

<p><div class="rs-tip-major">Poznámka: tato úloha není plně
paralelizovatelná.</div></p>

<p>Paralelní verze s&nbsp;flonum:</p>

<pre>
(declare
  (mostly-flonum)
  (block)
  (not safe))
&nbsp;
(define (<strong>compute-pi</strong> n)
  (let ((pi 4.0))
    (do ((i 3.0 (fl+ i 2.0)))
      ((fl&gt; i (fl+ n 2.0)))
      (set! pi (fl* pi (fl/ (fl- i 1.0) i) (fl/ (fl+ i 1.0) i))))
    pi))
&nbsp;
(define (<strong>pi-for</strong> n)
  (let ((pi (compute-pi n)))
    (display n)
    (display "\t")
    (display pi)
    (newline)))
&nbsp;
(define (<strong>power-of-two</strong> n maximum)
  (if (&lt; n maximum)
      (cons n (power-of-two (* n 2) maximum))
      (list n)))
&nbsp;
(define <strong>threads</strong> (map (lambda (n) (make-thread (lambda () (pi-for n))))
                     (power-of-two 1.0 5000000)))
&nbsp;
(for-each thread-start! threads)
(for-each thread-join!  threads)
</pre>

<p>Výsledek výpočtu po překladu:</p>

<pre>
$ <strong>time ./pi_parallel_flonum</strong>
&nbsp;
1.        3.5555555555555554
2.        3.5555555555555554
4.        3.4133333333333336
8.        3.302393550012597
16.       3.230036466411716
32.       3.1881271694471383
64.       3.1654820600347926
128.      3.1536988490957967
256.      3.147686899556418
512.      3.1446501625172
1024.     3.143124017028185
2048.     3.142358989121772
4096.     3.141975985005608
8192.     3.1417843602347433
16384.    3.1416885171495856
32768.    3.1416405879293077
65536.    3.1416166213993866
131072.   3.1416046376544267
262144.   3.1415986456618494
524288.   3.141595649635512
2097152.  3.141593402602468
1048576.  3.141594151614876
4194304.  3.1415930280955355
8388608.  3.1415928408418403
&nbsp;
real    0m0.159s
user    0m0.150s
sys     0m0.009s
</pre>

<p>V&nbsp;Clojure bude paralelní výpočet vypadat takto:</p>

<pre>
(ns pi-2.core
  (:gen-class))
&nbsp;
(defn <strong>compute-pi</strong>
  [n]
  (loop [pi 4.0
         i  3]
         (if (&lt; i (+ n 2))
             (recur (* pi (/ (- i 1) i) (/ (+ i 1) i))
                    (+ i 2))
             pi)))
&nbsp;
(def <strong>power-of-2</strong>
  (iterate (partial *' 2) 2))
&nbsp;
(defn <strong>-main</strong>
  [&amp; args]
  (let [ns (take-while (partial &gt; 10000000) power-of-2)
        pi (pmap compute-pi ns)
        result (map vector ns pi)]
    (doseq [r result]
      (println (first r) "\t" (nth r 1))))
  (shutdown-agents))
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Porovnání všech benchmarků</h2>

<p>V&nbsp;této kapitole budou všechny benchmarky porovnány. V&nbsp;případě
jazyka Clojure byl benchmark spuštěn přímo příkazem <strong>lein run</strong>
(tedy vlastně v&nbsp;režimu interpretace &ndash; resp.&nbsp;přesněji řečeno
průběžného překladu do bajtkódu) a následně byl proveden překlad do bajtkódu
s&nbsp;uložením do JARu se spuštěním bajtkódu. Obě alternativy vypadají
následovně:</p>

<pre>
$ <strong>time lein run</strong>
</pre>

<pre>
$ <strong>lein uberjar</strong>
$ <strong>time java -jar pi_1-0.1.0-SNAPSHOT-standalone.jar </strong>
</pre>

<p>Následuje tabulka s&nbsp;výsledky benchmarků:</p>

<table>
<tr><th> #</th><th>Interpret/runtime</th><th>Varianta</th><th>real</th><th>user</th><th>sys</th></tr>
<tr><td> 1</td><td>GNU Guile</td><td>interpret</td><td>4,858</td><td>5,212</td><td>0,058</td></tr>
<tr><td> 2</td><td>Chicken Scheme</td><td>interpret</td><td>8,137</td><td>7,738</td><td>0,318</td></tr>
<tr><td> 3</td><td>Gambit (gsi)</td><td>interpret</td><td>46,689</td><td>46,610</td><td>0,007</td></tr>
<tr><td> 4</td><td>Gambit (gsi)</td><td>interpret (flonum)</td><td>8,188</td><td>8,169</td><td>0,008</td></tr>
<tr><td> 5</td><td>Gambit (gsc)</td><td>přeložený</td><td>37,454</td><td>37,390</td><td>0,008</td></tr>
<tr><td> 6</td><td>Gambit (gsc)</td><td>přeložený (flonum)</td><td>0,153</td><td>0,141</td><td>0,011</td></tr>
<tr><td> 7</td><td>Gambit (gsc)</td><td>přeložený (vlákna)</td><td>36,867</td><td>36,800</td><td>0,013</td></tr>
<tr><td> 8</td><td>Gambit (gsc)</td><td>přeložený (vlákna+flonum)</td><td>0,159</td><td>0,150</td><td>0,009</td></tr>
<tr><td> 9</td><td>Clojure</td><td>interpret</td><td>14,925</td><td>16,365</td><td>0,515</td></tr>
<tr><td>10</td><td>Clojure</td><td>bajtkód</td><td>6,107</td><td>7,177</td><td>0,394</td></tr>
<tr><td>11</td><td>Clojure</td><td>interpret, vlákna</td><td>10,684</td><td>18,007</td><td>0,634</td></tr>
<tr><td>12</td><td>Clojure</td><td>bajtkód, vlákna</td><td>3,691</td><td>8,765</td><td>0,491</td></tr>
</table>

<a href="https://www.root.cz/obrazek/439829/"><img src="https://i.iinfo.cz/images/256/gambit-scheme-1-prev.png" class="image-439829" alt="&#160;" width="360" height="270" /></a>
<p><i>Obrázek 5: Výsledky benchmarků.</i></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/lisp-families.git">https://github.com/tisnik/lisp-families.git</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, můžete
namísto toho použít odkazy na jednotlivé příklady, které naleznete
v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>begin.scm</td><td>použití programových bloků <strong>begin</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/begin.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/begin.scm</a></td></tr>
<tr><td> 2</td><td>boolean_ops.scm</td><td>základní Booleovské operace</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/boolean_ops.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/boolean_ops.scm</a></td></tr>
<tr><td> 3</td><td>closure_1.scm</td><td>uzávěry v&nbsp;jazyce Scheme &ndash; počitadlo</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/closure_1.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/closure_1.scm</a></td></tr>
<tr><td> 4</td><td>closure_2.scm</td><td>uzávěry v&nbsp;jazyce Scheme &ndash; počitadlo</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/closure_2.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/closure_2.scm</a></td></tr>
<tr><td> 5</td><td>cond.scm</td><td>rozhodovací konstrukce <strong>cond</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/cond.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/cond.scm</a></td></tr>
<tr><td> 6</td><td>cond2.scm</td><td>další příklad použití rozhodovací konstrukce <strong>cond</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/cond2.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/cond2.scm</a></td></tr>
<tr><td> 7</td><td>cons.scm</td><td>speciální forma <strong>cons</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/cons.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/cons.scm</a></td></tr>
<tr><td> 8</td><td>define_type.scm</td><td>definice nového datového typu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/define_type.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/define_type.scm</a></td></tr>
<tr><td> 9</td><td>dot_pairs.scm</td><td>konstrukce tečka dvojic</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/dot_pairs.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/dot_pairs.scm</a></td></tr>
<tr><td>10</td><td>factorial_1.scm</td><td>rekurzivní výpočet faktoriálu, první varianta</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/factorial_1.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/factorial_1.scm</a></td></tr>
<tr><td>11</td><td>factorial_2.scm</td><td>rekurzivní výpočet faktoriálu, druhá varianta</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/factorial_2.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/factorial_2.scm</a></td></tr>
<tr><td>12</td><td>factorial_3.scm</td><td>tail rekurze při výpočtu faktoriálu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/factorial_3.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/factorial_3.scm</a></td></tr>
<tr><td>13</td><td>factorial_error.scm</td><td>příklad s&nbsp;chybou použitý pro ukázku volání interního debuggeru</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/factorial_error.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/factorial_error.scm</a></td></tr>
<tr><td>14</td><td>functions_keyparam.scm</td><td>funkce s&nbsp;pojmenovanými parametry</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/functions_keyparam.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/functions_keyparam.scm</a></td></tr>
<tr><td>15</td><td>functions_optional_rest.scm</td><td>funkce s&nbsp;nepovinnými parametry</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/functions_optional_rest.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/functions_optional_rest.scm</a></td></tr>
<tr><td>16</td><td>functions_optional.scm</td><td>funkce s&nbsp;nepovinnými parametry</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/functions_optional.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/functions_optional.scm</a></td></tr>
<tr><td>17</td><td>functions.scm</td><td>deklarace a volání funkcí</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/functions.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/functions.scm</a></td></tr>
<tr><td>18</td><td>functions_varargs.scm</td><td>funkce s&nbsp;proměnným počtem parametrů</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/functions_varargs.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/functions_varargs.scm</a></td></tr>
<tr><td>19</td><td>lambdas.scm</td><td>anonymní funkce v&nbsp;jazyku Scheme</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/lambdas.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/lambdas.scm</a></td></tr>
<tr><td>20</td><td>lexical_scope_1.scm</td><td>lexikální oblast platnosti proměnných, příklad 1</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/lexical_scope_1.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/lexical_scope_1.scm</a></td></tr>
<tr><td>21</td><td>lexical_scope_2.scm</td><td>lexikální oblast platnosti proměnných, příklad 2</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/lexical_scope_2.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/lexical_scope_2.scm</a></td></tr>
<tr><td>22</td><td>lexical_scope_3.scm</td><td>lexikální oblast platnosti proměnných, příklad 3</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/lexical_scope_3.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/lexical_scope_3.scm</a></td></tr>
<tr><td>23</td><td>lexical_scope_4.scm</td><td>lexikální oblast platnosti proměnných, příklad 4</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/lexical_scope_4.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/lexical_scope_4.scm</a></td></tr>
<tr><td>24</td><td>lists.scm</td><td>operace se seznamy</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/lists.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/lists.scm</a></td></tr>
<tr><td>25</td><td>pi_1.scm</td><td>výpočet konstanty &pi; imperativním způsobem</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/pi_1.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/pi_1.scm</a></td></tr>
<tr><td>26</td><td>pi_1_B.scm</td><td>výpočet konstanty &pi; funkcionálně-imperativním způsobem</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/pi_1_B.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/pi_1_B.scm</a></td></tr>
<tr><td>27</td><td>pi_1_C.scm</td><td>výpočet konstanty &pi; funkcionálním způsobem</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/pi_1_C.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/pi_1_C.scm</a></td></tr>
<tr><td>28</td><td>pi_2.scm</td><td>optimalizace výpočtu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/pi_2.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/pi_2.scm</a></td></tr>
<tr><td>29</td><td>pi_3_flonum.scm</td><td>použití datového typu <i>flonum</i> při výpočtu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/pi_3_flonum.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/pi_3_flonum.scm</a></td></tr>
<tr><td>30</td><td>pi_for_parallel.scm</td><td>příprava pro paralelní výpočet konstanty &pi;</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/pi_for_parallel.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/pi_for_parallel.scm</a></td></tr>
<tr><td>31</td><td>pi_parallel.scm</td><td>paralelní výpočet konstanty &pi;</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/pi_parallel.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/pi_parallel.scm</a></td></tr>
<tr><td>32</td><td>pi_parallel_flonum.scm</td><td>paralelní výpočet konstanty &pi; s&nbsp;typem <i>float</i></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/pi_parallel_flonum.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/pi_parallel_flonum.scm</a></td></tr>
<tr><td>33</td><td>predicates.scm</td><td>predikáty Scheme</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/predicates.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/predicates.scm</a></td></tr>
<tr><td>34</td><td>vectors1.scm</td><td>zpracování vektorů</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/vectors1.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/vectors1.scm</a></td></tr>
<tr><td>35</td><td>vectors2.scm</td><td>zpracování vektorů</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/vectors2.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/vectors2.scm</a></td></tr>
<tr><td>36</td><td>quasiquote.scm</td><td>quote a quasiquote</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/quasiquote.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/quasiquote.scm</a></td></tr>
<tr><td>37</td><td>exceptions.scm</td><td>výjimky</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/gambit/exceptions.scm">https://github.com/tisnik/lisp-families/blob/master/gambit/exceptions.scm</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Literatura</h2>

<ol>

<li>Brian Harvey<br />
<i>&bdquo;Simply Scheme: Introducing Computer Science&ldquo;</i><br />
1999 MIT<br />
Dostupné online na adrese <a href="https://people.eecs.berkeley.edu/~bh/ss-toc2.html">https://people.eecs.berkeley.edu/~bh/ss-toc2.html</a>
</li>

<li>Paul R. Wilson<br />
<i>&bdquo;An Introduction to Scheme and its Implementation&ldquo;</i><br />
1997<br />
Dostupné online na adrese <a href="https://www.cs.utexas.edu/ftp/garbage/cs345/schintro-v14/schintro_toc.html">https://www.cs.utexas.edu/ftp/garbage/cs345/schintro-v14/schintro_toc.html</a>
</li>

<li>Dorai Sitaram<br />
<i>&bdquo;Teach Yourself Scheme in Fixnum Days&ldquo;</i><br />
1998–2015<br />
Dostupné online na adrese <a href="https://ds26gte.github.io/tyscheme/">https://ds26gte.github.io/tyscheme/</a>
</li>

<li>Peter Seibel<br />
<i>&bdquo;Practical Common Lisp&ldquo;</i><br />
2009
</li>

<li>Paul Graham<br />
<i>&bdquo;ANSI Common Lisp&ldquo;</i><br />
1995
</li>

<li>Gerald Gazdar<br />
<i>&bdquo;Natural Language Processing in Lisp: An Introduction to Computational Linguistics&ldquo;</i><br />
1989
</li>

<li>Peter Norvig<br />
<i>&bdquo;Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp&ldquo;</i><br />
1991
</li>

<li>Alex Mileler et.al.<br />
<i>&bdquo;Clojure Applied: From Practice to Practitioner&ldquo;</i><br />
2015
</li>

<li>
<i>&bdquo;Living Clojure: An Introduction and Training Plan for Developers&ldquo;</i><br />
2015
</li>

<li>Dmitri Sotnikov<br />
<i>&bdquo;Web Development with Clojure: Build Bulletproof Web Apps with Less Code&ldquo;</i><br />
2016
</li>

<li>McCarthy<br />
<i>&bdquo;Recursive functions of symbolic expressions and their computation by machine, part I&ldquo;</i><br />
1960
</li>

<li>R. Kent Dybvig<br />
<i>&bdquo;The Scheme Programming Language&ldquo;</i><br />
2009
</li>

<li>Max Hailperin, Barbara Kaiser, Karl Knight<br />
<i>&bdquo;Concrete Abstractions&ldquo;</i><br />
1998
</li>

<li>Guy L. Steele<br />
<i>&bdquo;History of Scheme&ldquo;</i><br />
2006, Sun Microsystems Laboratories
</li>

<li>Kolář J., Muller K.:<br />
<i>&bdquo;Speciální programovací jazyky&ldquo;</i><br />
Praha 1981
</li>

<li>
<i>&bdquo;AutoLISP Release 9, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., October 1987
</li>

<li>
<i>&bdquo;AutoLISP Release 10, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., September 1988
</li>

<li>McCarthy, John; Abrahams, Paul W.; Edwards, Daniel J.; Hart, Timothy P.; Levin, Michael I.<br />
<i>&bdquo;LISP 1.5 Programmer's Manual&ldquo;</i><br />
MIT Press. ISBN 0 262 130 1 1 4
</li>

<li>Carl Hewitt; Peter Bishop and Richard Steiger<br />
<i>&bdquo;A Universal Modular Actor Formalism for Artificial Intelligence&ldquo;</i><br />
1973
</li>

<li>Feiman, J.<br />
<i>&bdquo;The Gartner Programming Language Survey (October 2001)&ldquo;</i><br />
Gartner Advisory
</li>

<li>Harold Abelson, Gerald Jay Sussman, Julie Sussman:<br />
<i>Structure and Interpretation of Computer Programs</i><br />
MIT Press. 1985, 1996 (a možná vyšel i další přetisk)
</li>

<li>Paul Graham<br />
<i>On Lisp</i><br />
Prentice Hall, 1993<br />
Dostupné online na adrese <a href="http://www.paulgraham.com/onlisptext.html">http://www.paulgraham.com/onlisptext.html</a>
</li>

<li>David S. Touretzky<br />
<i>Common LISP: A Gentle Introduction to Symbolic Computation (Dover Books on Engineering)</i><br />
</li>

<li>Peter Norvig<br />
<i>Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp</i>
</li>

<li>Patrick Winston, Berthold Horn<br />
<i>Lisp (3rd Edition)</i><br />
ISBN-13: 978-0201083194, ISBN-10: 0201083191
</li>

<li>Matthias Felleisen, David Van Horn, Dr. Conrad Barski<br>
<i>Realm of Racket: Learn to Program, One Game at a Time!</i><br />
ISBN-13: 978-1593274917, ISBN-10: 1593274912 
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Předchozí části seriálu</h2>

<p>V&nbsp;této kapitole jsou uvedeny odkazy na všechny předchozí části seriálu
o světě programovacích jazyků LISP a Scheme:</p>

<ol>

<li>Jemný úvod do rozsáhlého světa jazyků LISP a Scheme<br />
<a href="https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/">https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/</a>
</li>

<li>PicoLisp: minimalistický a přitom překvapivě výkonný interpret Lispu<br />
<a href="https://www.root.cz/clanky/picolisp-minimalisticky-a-pritom-prekvapive-vykonny-interpret-lispu/">https://www.root.cz/clanky/picolisp-minimalisticky-a-pritom-prekvapive-vykonny-interpret-lispu/</a>
</li>

<li>PicoLisp: užitečné funkce a speciální formy používané při tvorbě aplikací<br />
<a href="https://www.root.cz/clanky/picolisp-uzitecne-funkce-a-specialni-formy-pouzivane-pri-tvorbe-aplikaci/">https://www.root.cz/clanky/picolisp-uzitecne-funkce-a-specialni-formy-pouzivane-pri-tvorbe-aplikaci/</a>
</li>

<li>PicoLisp: dokončení popisu a několik praktických rad na závěr<br />
<a href="https://www.root.cz/clanky/picolisp-dokonceni-popisu-a-nekolik-praktickych-rad-na-zaver/">https://www.root.cz/clanky/picolisp-dokonceni-popisu-a-nekolik-praktickych-rad-na-zaver/</a>
</li>

<li>GNU Guile – interpret Scheme vestavitelný do nativních aplikací<br />
<a href="https://www.root.cz/clanky/gnu-guile-interpret-scheme-vestavitelny-do-nativnich-aplikaci/">https://www.root.cz/clanky/gnu-guile-interpret-scheme-vestavitelny-do-nativnich-aplikaci/</a>
</li>

<li>TinyScheme aneb další interpret jazyka Scheme vestavitelný do dalších aplikací<br />
<a href="https://www.root.cz/clanky/tinyscheme-aneb-dalsi-interpret-jazyka-scheme-vestavitelny-do-dalsich-aplikaci/">https://www.root.cz/clanky/tinyscheme-aneb-dalsi-interpret-jazyka-scheme-vestavitelny-do-dalsich-aplikaci/</a>
</li>

<li>Kawa: překvapivě silný a výkonný dialekt Scheme pro JVM<br />
<a href="https://www.root.cz/clanky/kawa-prekvapive-silny-a-vykonny-dialekt-scheme-pro-jvm/">https://www.root.cz/clanky/kawa-prekvapive-silny-a-vykonny-dialekt-scheme-pro-jvm/</a>
</li>

<li>Jazyk Kawa v ekosystému virtuálního stroje Javy<br />
<a href="https://www.root.cz/clanky/jazyk-kawa-v-ekosystemu-virtualniho-stroje-javy/">https://www.root.cz/clanky/jazyk-kawa-v-ekosystemu-virtualniho-stroje-javy/</a>
</li>

<li>Zpracování vektorů, matic a N-rozměrných polí v programovacím jazyku Kawa<br />
<a href="https://www.root.cz/clanky/zpracovani-vektoru-matic-a-n-rozmernych-poli-v-programovacim-jazyku-kawa/">https://www.root.cz/clanky/zpracovani-vektoru-matic-a-n-rozmernych-poli-v-programovacim-jazyku-kawa/</a>
</li>

<li>Racket: programovací jazyk a současně i platforma pro vývoj nových jazyků<br />
<a href="https://www.root.cz/clanky/racket-programovaci-jazyk-a-soucasne-i-platforma-pro-vyvoj-novych-jazyku/">https://www.root.cz/clanky/racket-programovaci-jazyk-a-soucasne-i-platforma-pro-vyvoj-novych-jazyku/</a>
</li>

<li>Makra v Racketu i v dalších lispovských jazycích<br />
<a href="https://www.root.cz/clanky/makra-v-racketu-i-v-dalsich-lispovskych-jazycich/">https://www.root.cz/clanky/makra-v-racketu-i-v-dalsich-lispovskych-jazycich/</a>
</li>

<li>Základní knihovna jazyka Racket<br />
<a href="https://www.root.cz/clanky/zakladni-knihovna-jazyka-racket/">https://www.root.cz/clanky/zakladni-knihovna-jazyka-racket/</a>
</li>

<li>Jazyk Joker: dialekt Clojure naprogramovaný v Go<br />
<a href="https://www.root.cz/clanky/jazyk-joker-dialekt-clojure-naprogramovany-v-go/">https://www.root.cz/clanky/jazyk-joker-dialekt-clojure-naprogramovany-v-go/</a>
</li>

<li>Chicken Scheme – další interpret a především překladač programovacího jazyka Scheme<br />
<a href="https://www.root.cz/clanky/chicken-scheme-dalsi-interpret-a-predevsim-prekladac-programovaciho-jazyka-scheme/">https://www.root.cz/clanky/chicken-scheme-dalsi-interpret-a-predevsim-prekladac-programovaciho-jazyka-scheme/</a>
</li>

</ol>



<p><a name="k21"></a></p>
<h2 id="k21">21. Odkazy na Internetu</h2>

<ol>

<li>Gambit in the browser<br />
<a href="https://feeley.github.io/gambit-in-the-browser/">https://feeley.github.io/gambit-in-the-browser/</a>
</li>

<li>A Tour of Scheme in Gambit<br />
<a href="http://dynamo.iro.umontreal.ca/wiki/images/a/a7/A_Tour_of_Scheme_in_Gambit.pdf">http://dynamo.iro.umontreal.ca/wiki/images/a/a7/A_Tour_of_Scheme_in_Gambit.pdf</a>
</li>

<li>Gambit Scheme: Inside Out<br />
<a href="http://www.iro.umontreal.ca/~gambit/Gambit-inside-out.pdf">http://www.iro.umontreal.ca/~gambit/Gambit-inside-out.pdf</a>
</li>

<li>Gambit Internal Documentation<br />
<a href="http://dynamo.iro.umontreal.ca/wiki/index.php/Internal_Documentation">http://dynamo.iro.umontreal.ca/wiki/index.php/Internal_Documentation</a>
</li>

<li>clojure-scheme: Compiling to Native Code via Scheme <br />
<a href="http://www.iro.umontreal.ca/~gambit/Sorenson-Clojure-to-Native-via-Scheme.pdf">http://www.iro.umontreal.ca/~gambit/Sorenson-Clojure-to-Native-via-Scheme.pdf</a>
</li>

<li>Gauche &ndash; a Scheme implementation<br />
<a href="http://practical-scheme.net/gauche/">http://practical-scheme.net/gauche/</a>
</li>

<li>Scheme48<br />
<a href="https://s48.org/">https://s48.org/</a>
</li>

<li>SISC (Second Interpreter of Scheme)<br />
<a href="http://sisc-scheme.org/">http://sisc-scheme.org/</a>
</li>

<li>The SCM Implementation of Scheme<br />
<a href="https://people.csail.mit.edu/jaffer/SCM.html">https://people.csail.mit.edu/jaffer/SCM.html</a>
</li>

<li>Ypsilon - The ultimate script language system for the video pinball fourth generation<br />
<a href="http://www.littlewingpinball.com/doc/en/ypsilon/index.html">http://www.littlewingpinball.com/doc/en/ypsilon/index.html</a>
</li>

<li>Chicken Scheme<br />
<a href="https://call-cc.org/">https://call-cc.org/</a>
</li>

<li>Eggs Unlimited<br />
<a href="http://wiki.call-cc.org/chicken-projects/egg-index-5.html">http://wiki.call-cc.org/chicken-projects/egg-index-5.html</a>
</li>

<li>Chicken Scheme Wiki<br />
<a href="https://wiki.call-cc.org/">https://wiki.call-cc.org/</a>
</li>

<li>CHICKEN for Python programmers<br />
<a href="https://wiki.call-cc.org/chicken-for-python-programmers">https://wiki.call-cc.org/chicken-for-python-programmers</a>
</li>

<li>Programming for Performance<br />
<a href="http://wiki.call-cc.org/programming-for-performance">http://wiki.call-cc.org/programming-for-performance</a>
</li>

<li>Using the compiler<br />
<a href="https://wiki.call-cc.org/man/4/Using%20the%20compiler">https://wiki.call-cc.org/man/4/Using%20the%20compiler</a>
</li>

<li>CHICKEN Scheme tutorials<br />
<a href="https://wiki.call-cc.org/tutorials">https://wiki.call-cc.org/tutorials</a>
</li>

<li>Racket: programovací jazyk a současně i platforma pro vývoj nových jazyků<br />
<a href="https://www.root.cz/clanky/racket-programovaci-jazyk-a-soucasne-i-platforma-pro-vyvoj-novych-jazyku/">https://www.root.cz/clanky/racket-programovaci-jazyk-a-soucasne-i-platforma-pro-vyvoj-novych-jazyku/</a>
</li>

<li>Makra v Racketu i v dalších lispovských jazycích<br />
<a href="https://www.root.cz/clanky/makra-v-racketu-i-v-dalsich-lispovskych-jazycich/">https://www.root.cz/clanky/makra-v-racketu-i-v-dalsich-lispovskych-jazycich/</a>
</li>

<li>Základní knihovna jazyka Racket<br />
<a href="https://www.root.cz/clanky/zakladni-knihovna-jazyka-racket/">https://www.root.cz/clanky/zakladni-knihovna-jazyka-racket/</a>
</li>

<li>Grafický metaformát PostScript<br />
<a href="https://www.root.cz/clanky/graficky-metaformat-postscript/">https://www.root.cz/clanky/graficky-metaformat-postscript/</a>
</li>

<li>Vektorový grafický formát SVG<br />
<a href="https://www.root.cz/clanky/vektorovy-graficky-format-svg/">https://www.root.cz/clanky/vektorovy-graficky-format-svg/</a>
</li>

<li>The Racket Drawing Toolkit<br />
<a href="https://docs.racket-lang.org/draw/index.html">https://docs.racket-lang.org/draw/index.html</a>
</li>

<li>Traditional Turtles<br />
<a href="https://docs.racket-lang.org/turtles/Traditional_Turtles.html">https://docs.racket-lang.org/turtles/Traditional_Turtles.html</a>
</li>

<li>[racket] How best to repeat a function call n times?<br />
<a href="https://lists.racket-lang.org/users/archive/2014-September/064203.html">https://lists.racket-lang.org/users/archive/2014-September/064203.html</a>
</li>

<li>Racket: Macros<br />
<a href="https://www.it.uu.se/edu/course/homepage/avfunpro/ht13/lectures/Racket-3-Macros.pdf">https://www.it.uu.se/edu/course/homepage/avfunpro/ht13/lectures/Racket-3-Macros.pdf</a>
</li>

<li>Beautiful Racket / explainers: Macros<br />
<a href="https://beautifulracket.com/explainer/macros.html">https://beautifulracket.com/explainer/macros.html</a>
</li>

<li>Macros (dokumentace k Racketu)<br />
<a href="https://docs.racket-lang.org/guide/macros.html">https://docs.racket-lang.org/guide/macros.html</a>
</li>

<li>Model syntaxe jazyka Racket<br />
<a href="https://docs.racket-lang.org/reference/syntax-model.html">https://docs.racket-lang.org/reference/syntax-model.html</a>
</li>

<li>Syntax Objects<br />
<a href="https://docs.racket-lang.org/guide/stx-obj.html">https://docs.racket-lang.org/guide/stx-obj.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Beautiful Racket: an intro­duction to language-oriented programming using Racket<br />
<a href="https://beautifulracket.com/">https://beautifulracket.com/</a>
</li>

<li>Stránky projektu Racket<br />
<a href="https://racket-lang.org/">https://racket-lang.org/</a>
</li>

<li>Dokumentace k&nbsp;projektu Racket<br />
<a href="https://docs.racket-lang.org/index.html">https://docs.racket-lang.org/index.html</a>
</li>

<li>Seznam dostupných balíčků pro Racket<br />
<a href="https://pkgs.racket-lang.org/">https://pkgs.racket-lang.org/</a>
</li>

<li>Racket na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Racket_(programming_language)">https://en.wikipedia.org/wiki/Racket_(programming_language)</a>
</li>

<li>Vector Library (R7RS-compatible)<br />
<a href="https://srfi.schemers.org/srfi-133/srfi-133.html">https://srfi.schemers.org/srfi-133/srfi-133.html</a>
</li>

<li>Blogy o Racketu a navazujících technologiích<br />
<a href="https://blog.racket-lang.org/">https://blog.racket-lang.org/</a>
</li>

<li>Prográmky psané v&nbsp;Racketu na RosettaCode<br />
<a href="http://rosettacode.org/wiki/Category:Racket">http://rosettacode.org/wiki/Category:Racket</a>
</li>

<li>Fear of Macros<br />
<a href="https://www.greghendershott.com/fear-of-macros/">https://www.greghendershott.com/fear-of-macros/</a>
</li>

<li>Rackjure<br />
<a href="https://github.com/greghendershott/rackjure">https://github.com/greghendershott/rackjure</a>
</li>

<li>Matthew Flatt’s proposal to change Racket’s s-expressions based syntax to infix representation creates a stir in the community<br />
<a href="https://hub.packtpub.com/matthew-flatts-proposal-to-change-rackets-s-expressions-based-syntax-to-infix-representation-creates-a-stir-in-the-community/">https://hub.packtpub.com/matthew-flatts-proposal-to-change-rackets-s-expressions-based-syntax-to-infix-representation-creates-a-stir-in-the-community/</a>
</li>

<li>Racket News<br />
<a href="https://racket-news.com/">https://racket-news.com/</a>
</li>

<li>Racket: Lisp for learning<br />
<a href="https://lwn.net/Articles/795385/">https://lwn.net/Articles/795385/</a>
</li>

<li>Future of Racket<br />
<a href="https://www.greghendershott.com/2019/07/future-of-racket.html">https://www.greghendershott.com/2019/07/future-of-racket.html</a>
</li>

<li>Vectors (pro Gauche)<br />
<a href="https://practical-scheme.net/gauche/man/gauche-refe/Vectors.html">https://practical-scheme.net/gauche/man/gauche-refe/Vectors.html</a>
</li>

<li>Kawa: Compiling Scheme to Java<br />
<a href="https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html">https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html</a>
</li>

<li>Kawa in Languages shootout<br />
<a href="http://per.bothner.com/blog/2010/Kawa-in-shootout/">http://per.bothner.com/blog/2010/Kawa-in-shootout/</a>
</li>

<li>Kawa 2.0 Supports Scheme R7RS<br />
<a href="https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/">https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/</a>
</li>

<li>Kawa — fast scripting on the Java platform<br />
<a href="https://lwn.net/Articles/623349/">https://lwn.net/Articles/623349/</a>
</li>

<li>Tail call (a její optimalizace)<br />
<a href="https://en.wikipedia.org/wiki/Tail_call">https://en.wikipedia.org/wiki/Tail_call</a>
</li>

<li>SLIME (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/SLIME">http://en.wikipedia.org/wiki/SLIME</a>
</li>

<li>slime.vim<br />
<a href="http://s3.amazonaws.com/mps/slime.vim">http://s3.amazonaws.com/mps/slime.vim</a>
</li>

<li>What are the best scheme implementations?<br />
<a href="https://www.slant.co/topics/5282/~scheme-implementations">https://www.slant.co/topics/5282/~scheme-implementations</a>
</li>

<li>Bigloo homepage<br />
<a href="http://www-sop.inria.fr/mimosa/fp/Bigloo/">http://www-sop.inria.fr/mimosa/fp/Bigloo/</a>
</li>

<li>FTP s tarbally Bigloo<br />
<a href="ftp://ftp-sop.inria.fr/indes/fp/Bigloo">ftp://ftp-sop.inria.fr/indes/fp/Bigloo</a>
</li>

<li>GOTO 2018 • Functional Programming in 40 Minutes • Russ Olsen<br />
<a href="https://www.youtube.com/watch?v=0if71HOyVjY">https://www.youtube.com/watch?v=0if71HOyVjY</a>
</li>

<li>TinyScheme (stránka na Sourceforge)<br />
<a href="http://tinyscheme.sourceforge.net/home.html">http://tinyscheme.sourceforge.net/home.html</a>
</li>

<li>Embedding Tiny Scheme in a Game<br />
<a href="http://www.silicondelight.com/embedding-tiny-scheme-in-a-game/">http://www.silicondelight.com/embedding-tiny-scheme-in-a-game/</a>
</li>

<li>Embedding Scheme for a game mission scripting DSL<br />
<a href="http://carloscarrasco.com/embedding-scheme-for-a-game-mission-scripting-dsl.html">http://carloscarrasco.com/embedding-scheme-for-a-game-mission-scripting-dsl.html</a>
</li>

<li>Všechny verze TinyScheme na SourceForge<br />
<a href="https://sourceforge.net/projects/tinyscheme/files/tinyscheme/">https://sourceforge.net/projects/tinyscheme/files/tinyscheme/</a>
</li>

<li>Fork TinyScheme na GitHubu<br />
<a href="https://github.com/yawnt/tinyscheme">https://github.com/yawnt/tinyscheme</a>
</li>

<li>Ackermannova funkce<br />
<a href="https://cs.wikipedia.org/wiki/Ackermannova_funkce">https://cs.wikipedia.org/wiki/Ackermannova_funkce</a>
</li>

<li>Ackermann function na Rosetta Code<br />
<a href="https://rosettacode.org/wiki/Ackermann_function#Scheme">https://rosettacode.org/wiki/Ackermann_function#Scheme</a>
</li>

<li>Success Stories (lisp.org)<br />
<a href="https://lisp-lang.org/success/">https://lisp-lang.org/success/</a>
</li>

<li>Allegro Common Lisp Success Stories<br />
<a href="https://franz.com/success/">https://franz.com/success/</a>
</li>

<li>Clojure Success Stories<br />
<a href="https://clojure.org/community/success_stories">https://clojure.org/community/success_stories</a>
</li>

<li>Scheme Quick Reference<br />
<a href="https://www.st.cs.uni-saarland.de/edu/config-ss04/scheme-quickref.pdf">https://www.st.cs.uni-saarland.de/edu/config-ss04/scheme-quickref.pdf</a>
</li>

<li>Slajdy o Scheme (od slajdu číslo 15)<br />
<a href="https://docs.google.com/presentation/d/1abmDnKjrq1tcjGvvRNAKhOiSTSE2lyagtcEPal07Gbo/edit">https://docs.google.com/presentation/d/1abmDnKjrq1tcjGvvRNAKhOiSTSE2lyagtcEPal07Gbo/edit</a>
</li>

<li>Scheme Cheat Sheet<br />
<a href="https://github.com/smythp/scheme-cheat-sheet">https://github.com/smythp/scheme-cheat-sheet</a>
</li>

<li>Embedding Lua, embedding Guile <br />
<a href="http://puntoblogspot.blogspot.com/2013/04/embedding-lua-embedding-guile.html">http://puntoblogspot.blogspot.com/2013/04/embedding-lua-embedding-guile.html</a>
</li>

<li>Lambda Papers<br />
<a href="https://en.wikisource.org/wiki/Lambda_Papers">https://en.wikisource.org/wiki/Lambda_Papers</a>
</li>

<li>Revised<sup>7</sup>Report on the Algorithmic Language Scheme<br />
<a href="https://small.r7rs.org/attachment/r7rs.pdf">https://small.r7rs.org/attachment/r7rs.pdf</a>
</li>

<li>Video Lectures (MIT, SICP 2005)<br />
<a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/</a>
</li>

<li>Why is Scheme my first language in university?<br />
<a href="https://softwareengineering.stackexchange.com/questions/115252/why-is-scheme-my-first-language-in-university">https://softwareengineering.stackexchange.com/questions/115252/why-is-scheme-my-first-language-in-university</a>
</li>

<li>The Perils of JavaSchools<br />
<a href="https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/">https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/</a>
</li>

<li>How to Design Programs, Second Edition<br />
<a href="https://htdp.org/2019-02-24/index.html">https://htdp.org/2019-02-24/index.html</a>
</li>

<li>LilyPond<br />
<a href="http://lilypond.org/">http://lilypond.org/</a>
</li>

<li>LilyPond — Extending (přes Scheme)<br />
<a href="http://lilypond.org/doc/v2.18/Documentation/extending/scheme-tutorial">http://lilypond.org/doc/v2.18/Documentation/extending/scheme-tutorial</a>
</li>

<li>Scheme in LilyPond<br />
<a href="http://lilypond.org/doc/v2.18/Documentation/extending/scheme-in-lilypond">http://lilypond.org/doc/v2.18/Documentation/extending/scheme-in-lilypond</a>
</li>

<li>GnuCash<br />
<a href="http://www.gnucash.org/">http://www.gnucash.org/</a>
</li>

<li>Custom Reports (in GNU Cash)<br />
<a href="https://wiki.gnucash.org/wiki/Custom_Reports">https://wiki.gnucash.org/wiki/Custom_Reports</a>
</li>

<li>Program by Design<br />
<a href="https://programbydesign.org/">https://programbydesign.org/</a>
</li>

<li>SchemePy<br />
<a href="https://pypi.org/project/SchemePy/">https://pypi.org/project/SchemePy/</a>
</li>

<li>LISP FQA: Section - [1-5] What is the "minimal" set of primitives needed for a Lisp interpreter?<br />
<a href="http://www.faqs.org/faqs/lisp-faq/part1/section-6.html">http://www.faqs.org/faqs/lisp-faq/part1/section-6.html</a>
</li>

<li>femtolisp<br />
<a href="https://github.com/JeffBezanson/femtolisp">https://github.com/JeffBezanson/femtolisp</a>
</li>

<li>(How to Write a (Lisp) Interpreter (in Python))<br />
<a href="http://norvig.com/lispy.html">http://norvig.com/lispy.html</a>
</li>

<li>Repositář s&nbsp;Guile Emacsem<br />
<a href="http://git.hcoop.net/?p=bpt/guile.git">http://git.hcoop.net/?p=bpt/guile.git</a>
</li>

<li>Interacting with Guile Compound Data Types in C<br />
<a href="http://www.lonelycactus.com/guilebook/x1555.html">http://www.lonelycactus.com/guilebook/x1555.html</a>
</li>

<li>Calling Guile functions from C<br />
<a href="http://www.lonelycactus.com/guilebook/c1204.html#SECCALLGUILEFUNC">http://www.lonelycactus.com/guilebook/c1204.html#SECCALLGUILEFUNC</a>
</li>

<li>Arrays, and other compound data types<br />
<a href="http://www.lonelycactus.com/guilebook/charrays.html">http://www.lonelycactus.com/guilebook/charrays.html</a>
</li>

<li>Interacting with Guile Compound Data Types in C<br />
<a href="http://www.lonelycactus.com/guilebook/x1555.html">http://www.lonelycactus.com/guilebook/x1555.html</a>
</li>

<li>Guile Reference Manual<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/index.html">https://www.gnu.org/software/guile/manual/html_node/index.html</a>
</li>

<li>Scheme: Summary of Common Syntax<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/Syntax-Summary.html#Syntax-Summary">https://www.gnu.org/software/guile/manual/html_node/Syntax-Summary.html#Syntax-Summary</a>
</li>

<li>Scripting with Guile: Extension language enhances C and Scheme<br />
<a href="https://www.ibm.com/developerworks/library/l-guile/index.html">https://www.ibm.com/developerworks/library/l-guile/index.html</a>
</li>

<li>Having fun with Guile: a tutorial<br />
<a href="http://dustycloud.org/misc/guile-tutorial.html">http://dustycloud.org/misc/guile-tutorial.html</a>
</li>

<li>Guile: Loading Readline Support<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/Loading-Readline-Support.html#Loading-Readline-Support">https://www.gnu.org/software/guile/manual/html_node/Loading-Readline-Support.html#Loading-Readline-Support</a>
</li>

<li>lispy<br />
<a href="https://pypi.org/project/lispy/">https://pypi.org/project/lispy/</a>
</li>

<li>Lython<br />
<a href="https://pypi.org/project/Lython/">https://pypi.org/project/Lython/</a>
</li>

<li>Lizpop<br />
<a href="https://pypi.org/project/lizpop/">https://pypi.org/project/lizpop/</a>
</li>

<li>Budoucnost programovacích jazyků<br />
<a href="http://www.knesl.com/budoucnost-programovacich-jazyku">http://www.knesl.com/budoucnost-programovacich-jazyku</a>
</li>

<li>LISP Prolog and Evolution<br />
<a href="http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html">http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html</a>
</li>

<li>List of Lisp-family programming languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages">https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages</a>
</li>

<li>clojure_py na indexu PyPi<br />
<a href="https://pypi.python.org/pypi/clojure_py">https://pypi.python.org/pypi/clojure_py</a>
</li>

<li>PyClojure<br />
<a href="https://github.com/eigenhombre/PyClojure">https://github.com/eigenhombre/PyClojure</a>
</li>

<li>Hy na GitHubu<br />
<a href="https://github.com/hylang/hy">https://github.com/hylang/hy</a>
</li>

<li>Hy: The survival guide<br />
<a href="https://notes.pault.ag/hy-survival-guide/">https://notes.pault.ag/hy-survival-guide/</a>
</li>

<li>Hy běžící na monitoru terminálu společnosti Symbolics<br />
<a href="http://try-hy.appspot.com/">http://try-hy.appspot.com/</a>
</li>

<li>Welcome to Hy’s documentation!<br />
<a href="http://docs.hylang.org/en/stable/">http://docs.hylang.org/en/stable/</a>
</li>

<li>Hy na PyPi<br />
<a href="https://pypi.org/project/hy/#description">https://pypi.org/project/hy/#description</a>
</li>

<li>Getting Hy on Python<br />
<a href="https://lwn.net/Articles/596626/">https://lwn.net/Articles/596626/</a>
</li>

<li>Programming Can Be Fun with Hy<br />
<a href="https://opensourceforu.com/2014/02/programming-can-fun-hy/">https://opensourceforu.com/2014/02/programming-can-fun-hy/</a>
</li>

<li>Přednáška o projektu Hy (pětiminutový lighttalk)<br />
<a href="http://blog.pault.ag/day/2013/04/02">http://blog.pault.ag/day/2013/04/02</a>
</li>

<li>Hy (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Hy">https://en.wikipedia.org/wiki/Hy</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Point<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Point.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Point.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Narrowing<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Narrowing.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Narrowing.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Functions that Create Markers<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Markers.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Markers.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Motion<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Motion.html#Motion">https://www.gnu.org/software/emacs/manual/html_node/elisp/Motion.html#Motion</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Basic Char Syntax<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Char-Syntax.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Char-Syntax.html</a>
</li>

<li>Elisp: Sequence: List, Array<br />
<a href="http://ergoemacs.org/emacs/elisp_list_vs_vector.html">http://ergoemacs.org/emacs/elisp_list_vs_vector.html</a>
</li>

<li>Elisp: Property List<br />
<a href="http://ergoemacs.org/emacs/elisp_property_list.html">http://ergoemacs.org/emacs/elisp_property_list.html</a>
</li>

<li>Elisp: Hash Table<br />
<a href="http://ergoemacs.org/emacs/elisp_hash_table.html">http://ergoemacs.org/emacs/elisp_hash_table.html</a>
</li>

<li>Elisp: Association List<br />
<a href="http://ergoemacs.org/emacs/elisp_association_list.html">http://ergoemacs.org/emacs/elisp_association_list.html</a>
</li>

<li>The mapcar Function (An Introduction to Programming in Emacs Lisp)<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/mapcar.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/mapcar.html</a>
</li>

<li>Anaphoric macro<br />
<a href="https://en.wikipedia.org/wiki/Anaphoric_macro">https://en.wikipedia.org/wiki/Anaphoric_macro</a>
</li>

<li>Some Common Lisp Loop Macro Examples<br />
<a href="https://www.youtube.com/watch?v=3yl8o6r_omw">https://www.youtube.com/watch?v=3yl8o6r_omw</a>
</li>

<li>A Guided Tour of Emacs<br />
<a href="https://www.gnu.org/software/emacs/tour/">https://www.gnu.org/software/emacs/tour/</a>
</li>

<li>The Roots of Lisp<br />
<a href="http://www.paulgraham.com/rootsoflisp.html">http://www.paulgraham.com/rootsoflisp.html</a>
</li>

<li>Evil (Emacs Wiki)<br />
<a href="https://www.emacswiki.org/emacs/Evil">https://www.emacswiki.org/emacs/Evil</a>
</li>

<li>Evil (na GitHubu)<br />
<a href="https://github.com/emacs-evil/evil">https://github.com/emacs-evil/evil</a>
</li>

<li>Evil (na stránkách repositáře MELPA)<br />
<a href="https://melpa.org/#/evil">https://melpa.org/#/evil</a>
</li>

<li>Evil Mode: How I Switched From VIM to Emacs<br />
<a href="https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html">https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html</a>
</li>

<li>GNU Emacs (home page)<br />
<a href="https://www.gnu.org/software/emacs/">https://www.gnu.org/software/emacs/</a>
</li>

<li>GNU Emacs (texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs">http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs</a>
</li>

<li>An Introduction To Using GDB Under Emacs<br />
<a href="http://tedlab.mit.edu/~dr/gdbintro.html">http://tedlab.mit.edu/~dr/gdbintro.html</a>
</li>

<li>An Introduction to Programming in Emacs Lisp<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html</a>
</li>

<li>27.6 Running Debuggers Under Emacs<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html">https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html</a>
</li>

<li>GdbMode<br />
<a href="http://www.emacswiki.org/emacs/GdbMode">http://www.emacswiki.org/emacs/GdbMode</a>
</li>

<li>Emacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Emacs">https://en.wikipedia.org/wiki/Emacs</a>
</li>

<li>Emacs timeline<br />
<a href="http://www.jwz.org/doc/emacs-timeline.html">http://www.jwz.org/doc/emacs-timeline.html</a>
</li>

<li>Emacs Text Editors Family<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?EmacsFamily">http://texteditors.org/cgi-bin/wiki.pl?EmacsFamily</a>
</li>

<li>Vrapper aneb spojení možností Vimu a Eclipse<br />
<a href="https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse/">https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse/</a>
</li>

<li>Vrapper aneb spojení možností Vimu a Eclipse (část 2: vyhledávání a nahrazování textu)<br />
<a href="https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse-cast-2-vyhledavani-a-nahrazovani-textu/">https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse-cast-2-vyhledavani-a-nahrazovani-textu/</a>
</li>

<li>Emacs/Evil-mode - A basic reference to using evil mode in Emacs<br />
<a href="http://www.aakarshnair.com/posts/emacs-evil-mode-cheatsheet">http://www.aakarshnair.com/posts/emacs-evil-mode-cheatsheet</a>
</li>

<li>From Vim to Emacs+Evil chaotic migration guide<br />
<a href="https://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/">https://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/</a>
</li>

<li>Introduction to evil-mode {video)<br />
<a href="https://www.youtube.com/watch?v=PeVQwYUxYEg">https://www.youtube.com/watch?v=PeVQwYUxYEg</a>
</li>

<li>EINE (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/EINE">http://www.emacswiki.org/emacs/EINE</a>
</li>

<li>EINE (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?EINE">http://texteditors.org/cgi-bin/wiki.pl?EINE</a>
</li>

<li>ZWEI (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/ZWEI">http://www.emacswiki.org/emacs/ZWEI</a>
</li>

<li>ZWEI (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?ZWEI">http://texteditors.org/cgi-bin/wiki.pl?ZWEI</a>
</li>

<li>Zmacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Zmacs">https://en.wikipedia.org/wiki/Zmacs</a>
</li>

<li>Zmacs (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?Zmacs">http://texteditors.org/cgi-bin/wiki.pl?Zmacs</a>
</li>

<li>TecoEmacs (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/TecoEmacs">http://www.emacswiki.org/emacs/TecoEmacs</a>
</li>

<li>Micro Emacs<br />
<a href="http://www.emacswiki.org/emacs/MicroEmacs">http://www.emacswiki.org/emacs/MicroEmacs</a>
</li>

<li>Micro Emacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/MicroEMACS">https://en.wikipedia.org/wiki/MicroEMACS</a>
</li>

<li>EmacsHistory<br />
<a href="http://www.emacswiki.org/emacs/EmacsHistory">http://www.emacswiki.org/emacs/EmacsHistory</a>
</li>

<li>Seznam editorů s ovládáním podobným Emacsu či kompatibilních s příkazy Emacsu<br />
<a href="http://www.finseth.com/emacs.html">http://www.finseth.com/emacs.html</a>
</li>

<li>evil-numbers<br />
<a href="https://github.com/cofi/evil-numbers">https://github.com/cofi/evil-numbers</a>
</li>

<li>Debuggery a jejich nadstavby v&nbsp;Linuxu (1.část)<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/</a>
</li>

<li>Debuggery a jejich nadstavby v&nbsp;Linuxu (2.část)<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (3): Nemiver<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (4): KDbg<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (5): ladění aplikací v editorech Emacs a Vim<br />
<a href="https://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">https://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/</a>
</li>

<li>Org mode<br />
<a href="https://orgmode.org/">https://orgmode.org/</a>
</li>

<li>The Org Manual<br />
<a href="https://orgmode.org/manual/index.html">https://orgmode.org/manual/index.html</a>
</li>

<li>Kakoune (modální textový editor)<br />
<a href="http://kakoune.org/">http://kakoune.org/</a>
</li>

<li>Vim-style keybinding in Emacs/Evil-mode<br />
<a href="https://gist.github.com/troyp/6b4c9e1c8670200c04c16036805773d8">https://gist.github.com/troyp/6b4c9e1c8670200c04c16036805773d8</a>
</li>

<li>Emacs - jak začít<br />
<a href="http://www.abclinuxu.cz/clanky/navody/emacs-jak-zacit">http://www.abclinuxu.cz/clanky/navody/emacs-jak-zacit</a>
</li>

<li>Programovací jazyk LISP a LISP machines<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-lisp-a-lisp-machines/">https://www.root.cz/clanky/programovaci-jazyk-lisp-a-lisp-machines/</a>
</li>

<li>Evil-surround<br />
<a href="https://github.com/emacs-evil/evil-surround">https://github.com/emacs-evil/evil-surround</a>
</li>

<li>Spacemacs<br />
<a href="http://spacemacs.org/">http://spacemacs.org/</a>
</li>

<li>Lisp: Common Lisp, Racket, Clojure, Emacs Lisp<br />
<a href="http://hyperpolyglot.org/lisp">http://hyperpolyglot.org/lisp</a>
</li>

<li>Common Lisp, Scheme, Clojure, And Elisp Compared<br />
<a href="http://irreal.org/blog/?p=725">http://irreal.org/blog/?p=725</a>
</li>

<li>Does Elisp Suck?<br />
<a href="http://irreal.org/blog/?p=675">http://irreal.org/blog/?p=675</a>
</li>

<li>Emacs pro mírně pokročilé (9): Elisp<br />
<a href="https://www.root.cz/clanky/emacs-elisp/">https://www.root.cz/clanky/emacs-elisp/</a>
</li>

<li>If I want to learn lisp, are emacs and elisp a good choice?<br />
<a href="https://www.reddit.com/r/emacs/comments/2m141y/if_i_want_to_learn_lisp_are_emacs_and_elisp_a/">https://www.reddit.com/r/emacs/comments/2m141y/if_i_want_to_learn_lisp_are_emacs_and_elisp_a/</a>
</li>

<li>Clojure(Script) Interactive Development Environment that Rocks!<br />
<a href="https://github.com/clojure-emacs/cider">https://github.com/clojure-emacs/cider</a>
</li>

<li>An Introduction to Emacs Lisp<br />
<a href="https://harryrschwartz.com/2014/04/08/an-introduction-to-emacs-lisp.html">https://harryrschwartz.com/2014/04/08/an-introduction-to-emacs-lisp.html</a>
</li>

<li>Emergency Elisp<br />
<a href="http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html">http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html</a>
</li>

<li>Lambda calculus<br />
<a href="https://en.wikipedia.org/wiki/Lambda_calculus">https://en.wikipedia.org/wiki/Lambda_calculus</a>
</li>

<li>John McCarthy's original LISP paper from 1959<br />
<a href="https://www.reddit.com/r/programming/comments/17lpz4/john_mccarthys_original_lisp_paper_from_1959/">https://www.reddit.com/r/programming/comments/17lpz4/john_mccarthys_original_lisp_paper_from_1959/</a>
</li>

<li>Micro Manual LISP<br />
<a href="https://www.scribd.com/document/54050141/Micro-Manual-LISP">https://www.scribd.com/document/54050141/Micro-Manual-LISP</a>
</li>

<li>How Lisp Became God's Own Programming Language<br />
<a href="https://twobithistory.org/2018/10/14/lisp.html">https://twobithistory.org/2018/10/14/lisp.html</a>
</li>

<li>History of Lisp<br />
<a href="http://jmc.stanford.edu/articles/lisp/lisp.pdf">http://jmc.stanford.edu/articles/lisp/lisp.pdf</a>
</li>

<li>The Roots of Lisp<br />
<a href="http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf">http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf</a>
</li>

<li>Racket<br />
<a href="https://racket-lang.org/">https://racket-lang.org/</a>
</li>

<li>The Racket Manifesto<br />
<a href="http://felleisen.org/matthias/manifesto/">http://felleisen.org/matthias/manifesto/</a>
</li>

<li>MIT replaces Scheme with Python<br />
<a href="https://www.johndcook.com/blog/2009/03/26/mit-replaces-scheme-with-python/">https://www.johndcook.com/blog/2009/03/26/mit-replaces-scheme-with-python/</a>
</li>

<li>Adventures in Advanced Symbolic Programming<br />
<a href="http://groups.csail.mit.edu/mac/users/gjs/6.945/">http://groups.csail.mit.edu/mac/users/gjs/6.945/</a>
</li>

<li>Why MIT Switched from Scheme to Python (2009)<br />
<a href="https://news.ycombinator.com/item?id=14167453">https://news.ycombinator.com/item?id=14167453</a>
</li>

<li>Starodávná stránka XLispu<br />
<a href="http://www.xlisp.org/">http://www.xlisp.org/</a>
</li>

<li>AutoLISP<br />
<a href="https://en.wikipedia.org/wiki/AutoLISP">https://en.wikipedia.org/wiki/AutoLISP</a>
</li>

<li>Seriál PicoLisp: minimalistický a výkonný interpret Lispu<br />
<a href="https://www.root.cz/serialy/picolisp-minimalisticky-a-vykonny-interpret-lispu/">https://www.root.cz/serialy/picolisp-minimalisticky-a-vykonny-interpret-lispu/</a>
</li>

<li>Common Lisp<br />
<a href="https://common-lisp.net/">https://common-lisp.net/</a>
</li>

<li>Getting Going with Common Lisp<br />
<a href="https://cliki.net/Getting%20Started">https://cliki.net/Getting%20Started</a>
</li>

<li>Online Tutorial (Common Lisp)<br />
<a href="https://cliki.net/online%20tutorial">https://cliki.net/online%20tutorial</a>
</li>

<li>Guile Emacs<br />
<a href="https://www.emacswiki.org/emacs/GuileEmacs">https://www.emacswiki.org/emacs/GuileEmacs</a>
</li>

<li>Guile Emacs History<br />
<a href="https://www.emacswiki.org/emacs/GuileEmacsHistory">https://www.emacswiki.org/emacs/GuileEmacsHistory</a>
</li>

<li>Guile is a programming language<br />
<a href="https://www.gnu.org/software/guile/">https://www.gnu.org/software/guile/</a>
</li>

<li>MIT Scheme<br />
<a href="http://groups.csail.mit.edu/mac/projects/scheme/">http://groups.csail.mit.edu/mac/projects/scheme/</a>
</li>

<li>SIOD: Scheme in One Defun<br />
<a href="http://people.delphiforums.com/gjc//siod.html">http://people.delphiforums.com/gjc//siod.html</a>
</li>

<li>CommonLispForEmacs<br />
<a href="https://www.emacswiki.org/emacs/CommonLispForEmacs">https://www.emacswiki.org/emacs/CommonLispForEmacs</a>
</li>

<li>Elisp: print, princ, prin1, format, message<br />
<a href="http://ergoemacs.org/emacs/elisp_printing.html">http://ergoemacs.org/emacs/elisp_printing.html</a>
</li>

<li>Special Forms in Lisp<br />
<a href="http://www.nhplace.com/kent/Papers/Special-Forms.html">http://www.nhplace.com/kent/Papers/Special-Forms.html</a>
</li>

<li>Basic Building Blocks in LISP<br />
<a href="https://www.tutorialspoint.com/lisp/lisp_basic_syntax.htm">https://www.tutorialspoint.com/lisp/lisp_basic_syntax.htm</a>
</li>

<li>Introduction to LISP - University of Pittsburgh<br />
<a href="https://people.cs.pitt.edu/~milos/courses/cs2740/Lectures/LispTutorial.pdf">https://people.cs.pitt.edu/~milos/courses/cs2740/Lectures/LispTutorial.pdf</a>
</li>

<li>Why don't people use LISP<br />
<a href="https://forums.freebsd.org/threads/why-dont-people-use-lisp.24572/">https://forums.freebsd.org/threads/why-dont-people-use-lisp.24572/</a>
</li>

<li>Structured program theorem<br />
<a href="https://en.wikipedia.org/wiki/Structured_program_theorem">https://en.wikipedia.org/wiki/Structured_program_theorem</a>
</li>

<li>Clojure: API Documentation<br />
<a href="https://clojure.org/api/api">https://clojure.org/api/api</a>
</li>

<li>Tutorial for the Common Lisp Loop Macro<br />
<a href="http://www.ai.sri.com/pkarp/loop.html">http://www.ai.sri.com/pkarp/loop.html</a>
</li>

<li>Common Lisp's Loop Macro Examples for Beginners<br />
<a href="http://www.unixuser.org/~euske/doc/cl/loop.html">http://www.unixuser.org/~euske/doc/cl/loop.html</a>
</li>

<li>A modern list api for Emacs. No 'cl required.<br />
<a href="https://github.com/magnars/dash.el">https://github.com/magnars/dash.el</a>
</li>

<li>The LOOP Facility<br />
<a href="http://www.lispworks.com/documentation/HyperSpec/Body/06_a.htm">http://www.lispworks.com/documentation/HyperSpec/Body/06_a.htm</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>Transient Data Structures
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Jazyky Hy a Clojure-py: moderní dialekty LISPu určené pro Python VM<br />
<a href="https://www.root.cz/clanky/jazyky-hy-a-clojure-py-moderni-dialekty-lispu-urcene-pro-python-vm/">https://www.root.cz/clanky/jazyky-hy-a-clojure-py-moderni-dialekty-lispu-urcene-pro-python-vm/</a>
</li>

<li>Pixie: lehký skriptovací jazyk s „kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

<li>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/">https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/</a>
</li>

<li>Stránka projektu Jython<br />
<a href="http://www.jython.org/">http://www.jython.org/</a>
</li>

<li>Jython (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Jython">https://en.wikipedia.org/wiki/Jython</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">https://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>JSR 223: Scripting for the Java<sup>TM</sup> Platform<br />
<a href="https://jcp.org/en/jsr/detail?id=223">https://jcp.org/en/jsr/detail?id=223</a>
</li>

<li>List of JVM languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_JVM_languages">https://en.wikipedia.org/wiki/List_of_JVM_languages</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

<li>Economy Size Geek - Interview with Rich Hickey, Creator of Clojure<br />
<a href="https://www.linuxjournal.com/article/10708">https://www.linuxjournal.com/article/10708</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

