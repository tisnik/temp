<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Racket - programovací jazyk a současně i platforma pro vývoj nových jazyků</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Racket - programovací jazyk a současně i platforma pro vývoj nových jazyků</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešní části seriálu o světě lispovských jazyků si představíme pravděpodobně nejrozsáhlejší a nejúplnější implementaci programovacího jazyka Scheme. Jedná se o jazyk Racket, který je dodáván i s interaktivním vývojovým prostředím a množstvím přídavných modulů pokrývajících různá odvětví informatiky.</p>




<h2>Obsah</h2>

<p><a href="#k01">1. Racket &ndash; programovací jazyk a současně i platforma pro vývoj nových jazyků</a></p>
<p><a href="#k02">2. Instalace systému Racket</a></p>
<p><a href="#k03">3. Integrované vývojové prostředí a interaktivní smyčka REPL</a></p>
<p><a href="#k04">4. Základy programovacího jazyka Racket</a></p>
<p><a href="#k05">5. Numerická věž a příslušné základní predikáty</a></p>
<p><a href="#k06">6. Funkce jako základní stavební bloky programů</a></p>
<p><a href="#k07">7. Pojmenování uživatelských funkcí</a></p>
<p><a href="#k08">8. Anonymní funkce</a></p>
<p><a href="#k09">9. Anonymní funkce s&nbsp;proměnným počtem parametrů</a></p>
<p><a href="#k10">10. Pojmenované funkce s&nbsp;proměnným počtem parametrů</a></p>
<p><a href="#k11">11. Povinné a nepovinné parametry anonymních funkcí</a></p>
<p><a href="#k12">12. Povinné a nepovinné parametry pojmenovaných funkcí</a></p>
<p><a href="#k13">13. Parametry anonymních funkcí explicitně specifikované svým jménem</a></p>
<p><a href="#k14">14. Parametry pojmenovaných funkcí specifikované jménem</a></p>
<p><a href="#k15">15. Pojmenované a nepojmenované funkce s&nbsp;různou aritou</a></p>
<p><a href="#k16">16. Funkce jako hodnoty</a></p>
<p><a href="#k17">17. Obsah následující části seriálu</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Literatura</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Racket &ndash; programovací jazyk a současně i platforma pro vývoj nových jazyků</h2>

<p>V&nbsp;dnešní části <a
href="https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/">seriálu
o rozsáhlém a možná i poněkud chaotickém světě lispovských programovacích
jazyků</a> se seznámíme se základními vlastnostmi systému nazvaného
<i>Racket</i>. Naprostá většina programovacích jazyků (což většinou byly různé
varianty Scheme či LISPu), s&nbsp;nimiž jsme se až doposud seznámili, sestávala
z&nbsp;interpretru a/nebo překladače, který byl doplněn o interaktivní smyčku
REPL a taktéž o základní podpůrné knihovny. Systém <i>Racket</i> se ovšem
z&nbsp;tohoto ustáleného schématu poněkud vymyká, protože kromě již zmíněných
modulů &ndash; interpretru, překladače, REPL, základních knihoven &ndash;
obsahuje i integrované vývojové prostředí, opravdu rozsáhlé množství knihoven a
navíc systém pro snadnou instalaci dalších knihoven (či možná lépe řečeno
celých balíčků).</p>

<p><div class="rs-tip-major">Poznámka: původně se Racket jmenoval PLT Scheme,
takže asi nebude velkým překvapením, že většina základních vlastností Racketu
je ze Scheme odvozeno.</div></p>

<p>Ale to není zdaleka vše, protože samotný programovací jazyk Racketu je
poměrně snadno rozšiřitelný a modifikovatelný, takže vzniklo hned několik jeho
variant. Kromě klasického dynamicky typovaného jazyka Scheme je tak možné
použít jazyk s&nbsp;možností přesné deklarace datových typů, jazyk
s&nbsp;infixovu notací zápisu aritmetických výrazů, dokonce i implementaci
Algolu 60 atd. (samotný dialekt se vybírá pomocí řádku začínajícího na
<strong>#lang</strong>, což uvidíme v&nbsp;demonstračních příkladech).</p>

<p>Dnes se však seznámíme především s&nbsp;první zmíněnou variantou
programovacího jazyka Racket, přesněji řečeno s&nbsp;jedním dialektem
programovacího jazyka Scheme s&nbsp;dynamickým typovým systémem (typ je odvozen
od hodnoty, nemusí být specifikován u proměnné ani u parametru funkce).
Uvidíme, že i &bdquo;základní dialekt Scheme&ldquo; doznal několika užitečných
rozšíření. Teprve v&nbsp;navazujících článcích si ukážeme i další rozšíření
tohoto jazyka o další syntaxi a taktéž o novou sémantiku (což je důležitější,
než samotný způsob zápisu).</p>

<p><div class="rs-tip-major">Poznámka: možná to bude znít poněkud přízemně, ale
jedním z&nbsp;nejdůležitějších praktických rozšíření, které v&nbsp;systému
<i>Racket</i> nalezneme, souvisí se systémem modulů. Mnoho implementací LISPu a
Scheme (možná i většina implementací) systém modulů buď vůbec neobsahuje, nebo
ho má vyřešený dosti problematickým způsobem, například omezením na definici
jmenných prostorů atd. Tímto neduhem dokonce částečně trpí i programovací
Clojure; ostatně dotazy, jak vlastně přesně funguje systém jmenných prostorů
v&nbsp;Clojure, jsou velmi časté (ostatně neexistencí rozumného systému modulů
trpí i některé mainstreamové programovací jazyky).</div></p>

<img src="https://i.iinfo.cz/images/100/racket1-1.png" class="image-368024" alt="&#160;" width="322" height="371" />
<p><i>Obrázek 1: Logo systému Racket.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Instalace systému Racket</h2>

<p>Instalace celého systému Racket, včetně již výše zmíněného vývojového
prostředí, je poměrně jednoduchá, protože postačuje ze stránky <a
href="https://download.racket-lang.org/">https://download.racket-lang.org/</a>
stáhnout instalační soubor připravený pro vámi používaný operační systém, což
je v&nbsp;případě Linuxu BASH script, na jehož konci je celý systém Racket
zabalený. Tento soubor získáme například s&nbsp;využitím nástroje
<strong>wget</strong> (nebo libovolným webovým prohlížečem):</p>

<pre>
$ <strong>wget https://mirror.racket-lang.org/installers/7.4/racket-7.4-x86_64-linux.sh</strong>
</pre>

<p>Po stažení tohoto souboru je možné ho spustit, a to dokonce i
<strong>bez</strong> práv roota, ideálně pod novým uživatelem, který bude mít
přístup jen k&nbsp;Racketu:</p>

<pre>
$ <strong>bash racket-7.4-x86_64-linux.sh </strong>
</pre>

<p>Na začátku nám instalační skript položí několik otázek:</p>

<pre>
This program will extract and install Racket v7.4.
&nbsp;
Note: the required diskspace for this installation is 523M.
&nbsp;
Do you want a Unix-style distribution?
  In this distribution mode files go into different directories according
  to Unix conventions.  A "racket-uninstall" script will be generated
  to be used when you want to remove the installation.  If you say 'no',
  the whole Racket directory is kept in a single installation directory
  (movable and erasable), possibly with external links into it -- this is
  often more convenient, especially if you want to install multiple
  versions or keep it in your home directory.
Enter yes/no (default: no) &gt;
</pre>

<p>Povšimněte si, že instalační skript nám nabízí dvě možnosti instalace. První
takzvaná &bdquo;unixová&ldquo; varianta spočívá v&nbsp;tom, že se Racket
nainstaluje do běžné adresářové struktury, na kterou jsme zvyklí
z&nbsp;Unixových systémů: spustitelné soubory budou uloženy v&nbsp;adresáři
<strong>/usr/bin</strong>, manuálové stránky v&nbsp;adresáři
<strong>/usr/share/man</strong> atd. atd. Pro tento typ instalace pochopitelně
budete potřebovat práva roota a navíc koliduje se správcem balíčků dané
distribuce. Předností je, že lze snadno vytvářet spustitelné skripty
programované v&nbsp;Racketu. Tyto skripty musí mít nastaven příznak
<strong>+x</strong> a musí začínat řádkem s&nbsp;klasickým
&bdquo;she-bangem&ldquo;:</p>

<pre>
#!/usr/bin/env racket
</pre>

<p>Výhodnější ovšem může být, zejména ve chvíli, kdy Racket má používat jen
jediný uživatel, alternativní způsob instalace, který spočívá v&nbsp;tom, že se
Racket rozbalí do zvoleného adresáře. Tím může být například adresář
<strong>/opt</strong> nebo je pochopitelně možné instalaci provést přímo do
domovského adresáře toho uživatele, který instalaci provádí:</p>

<pre>
Enter yes/no (default: no) &gt; <strong>no</strong>
</pre>

<p>Po odpovědi &bdquo;no&ldquo; se instalační skript zeptá, do jakého adresáře
se má tedy instalace provést:</p>

<pre>
Where do you want to install the "racket" directory tree?
  1 - /usr/racket [default]
  2 - /usr/local/racket
  3 - ~/racket (/home/tester/racket)
  4 - ./racket (here)
  Or enter a different "racket" directory to install in.
&gt; <strong>4</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: instalaci můžete provést jako já do
adresáře <strong>/opt</strong>. Po takto nakonfigurované instalaci je potom
dobré přidat cestu <strong>/opt/racket/bin</strong> do proměnné
<strong>PATH</strong>, čímž se vám zjednoduší přístup ke spuštění interpretru,
REPLu i samotného vývojového prostředí.</div></p>

<p>Samotná instalace proběhne poměrně rychle, a to i přesto, že se na disku
obsadí relativně velké množství prostoru: více než 460 MB (což je skutečně
hodně, i když samotný instalační skript hlásí dokonce ještě větší číslo):</p>

<pre>
Checking the integrity of the binary archive... ok.
    Unpacking into "<strong>/opt/racket</strong>" (Ctrl+C to abort)...
Done.
&nbsp;
If you want to install new system links within the "bin", "man"
  and "share/applications" subdirectories of a common directory prefix
  (for example, "/usr/local") then enter the prefix of an existing
  directory that you want to use.  This might overwrite existing symlinks,
  but not files.
</pre>

<p>Adresářová struktura nainstalovaného systému Racket vypadá následovně:</p>

<pre>
.
├── bin
├── collects
│   ├── acks
│   ├── compiler
│   ├── data
│   ├── db
│   ├── dynext
│   ├── ffi
│   ├── file
│   ├── info
│   ├── info-domain
│   ├── json
│   ├── launcher
│   ├── net
│   ├── openssl
│   ├── pkg
│   ├── planet
│   ├── racket
│   ├── raco
│   ├── reader
│   ├── realm
│   ├── setup
│   ├── s-exp
│   ├── syntax
│   ├── version
│   └── xml
├── doc
│   ├── 2d
│   ├── acks
│   ├── algol60
│   ├── browser
│   ├── bug-report
│   ├── cards
│   ├── compatibility
│   ├── continue
│   ├── contract-profile
│   ├── cookies
│   ├── data
│   ├── datalog
│   ├── db
│   ├── deinprogramm
│   ├── demo-m1
│   ├── demo-m2
│   ├── demo-manual-m1
│   ├── demo-manual-m2
│   ├── demo-manual-s1
│   ├── demo-manual-s2
│   ├── demo-s1
│   ├── demo-s2
│   ├── distributed-places
│   ├── draw
│   ├── drracket
│   ├── drracket-tools
│   ├── ds-store
│   ├── dynext
│   ├── embedded-gui
│   ├── eopl
│   ├── errortrace
│   ├── file
│   ├── foreign
│   ├── framework
│   ├── frtime
│   ├── future-visualizer
│   ├── games
│   ├── getting-started
│   ├── gl-board-game
│   ├── graphics
│   ├── gui
│   ├── guide
│   ├── help
│   ├── htdp
│   ├── htdp-langs
│   ├── htdp-ptr
│   ├── html
│   ├── images
│   ├── inside
│   ├── json
│   ├── lazy
│   ├── license
│   ├── local-redirect
│   ├── macro-debugger
│   ├── make
│   ├── math
│   ├── more
│   ├── mrlib
│   ├── mysterx
│   ├── mzcom
│   ├── mzlib
│   ├── mzscheme
│   ├── net
│   ├── openssl
│   ├── optimization-coach
│   ├── option-contract
│   ├── osx-ssl
│   ├── parser-tools
│   ├── pict
│   ├── pict-snip
│   ├── picturing-programs
│   ├── pkg
│   ├── plai
│   ├── planet
│   ├── plot
│   ├── plt-installer
│   ├── preprocessor
│   ├── profile
│   ├── quick
│   ├── quickscript
│   ├── r5rs
│   ├── r6rs
│   ├── racket-cheat
│   ├── racklog
│   ├── rackunit
│   ├── raco
│   ├── readline
│   ├── redex
│   ├── reference
│   ├── release
│   ├── sasl
│   ├── scheme
│   ├── scribble
│   ├── scribble-pp
│   ├── scriblib
│   ├── search
│   ├── sgl
│   ├── slatex-wrap
│   ├── slideshow
│   ├── source-syntax
│   ├── srfi
│   ├── srfi-nf
│   ├── stepper
│   ├── string-constants
│   ├── style
│   ├── swindle
│   ├── syntax
│   ├── syntax-color
│   ├── teachpack
│   ├── test-engine
│   ├── tool
│   ├── tools
│   ├── trace
│   ├── ts-guide
│   ├── ts-reference
│   ├── turtles
│   ├── unix-socket
│   ├── version
│   ├── web-server
│   ├── web-server-internal
│   ├── win32-ssl
│   ├── xml
│   └── xrepl
├── etc
├── include
├── lib
├── man
│   └── man1
└── share
    ├── applications
    └── pkgs
</pre>

<p>Nastavení proměnné prostředí <strong>PATH</strong> takovým způsobem, aby
bylo možné jednoduše spustit interpret i REPL:</p>

<pre>
$ <strong>whereis racket</strong>
racket: /opt/racket/bin/racket
&nbsp;
$ <strong>export PATH=$PATH:/opt/racket/bin</strong>
&nbsp;
$ <strong>whereis racket</strong>
racket: /opt/racket/bin/racket
&nbsp;
$ <strong>racket --version</strong>
Welcome to Racket v7.4.
</pre>

<p><div class="rs-tip-major">Poznámka: toto nastavení můžete provést i
v&nbsp;konfiguračních skriptech <strong>.bashrc</strong>,
<strong>.profile</strong> nebo <strong>.bash_profile</strong>:</div></p>

<pre>
export PATH=$PATH:~/bin:~/.local/bin/:/opt/go/bin:~/go/bin:<strong>/opt/racket/bin</strong>
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Integrované vývojové prostředí a interaktivní smyčka REPL</h2>

<p>Po doufejme že úspěšné instalaci Racketu máme hned několik možností, jak
celý systém začít používat. Můžeme například spustit jeho integrované vývojové
prostředí:</p>

<pre>
/opt/racket/bin <strong>$ ./drracket</strong>
</pre>

<a href="https://www.root.cz/obrazek/368025/"><img src="https://i.iinfo.cz/images/100/racket1-2-prev.png" class="image-368025" alt="&#160;" width="341" height="270" /></a>
<p><i>Obrázek 2: Spuštění IDE systému Racket.</i></p>

<p>Prozatím si však vystačíme s&nbsp;interaktivní smyčkou REPL, kterou spustíme
příkazem <strong>racket</strong>:</p>

<pre>
/opt/racket/bin <strong>$ ./racket</strong>
&nbsp;
Welcome to Racket v7.4.
</pre>

<p><div class="rs-tip-major">Poznámka: pokud navíc zadáme příkazu
<strong>racket</strong> i jméno skriptu, ten bude spuštěn, takže kromě REPLu
pracuje tento nástroj i jako interpret.</div></p>

<img src="https://i.iinfo.cz/images/100/racket1-3.png" class="image-368026" alt="&#160;" width="402" height="783" />
<p><i>Obrázek 3: Výběr jazyka a dialektu.</i></p>

<p>Interaktivní smyčka je použitelná prakticky stejným způsobem, jako ostatní
REPL, s&nbsp;nimiž jsme se až doposud seznámili ve článcích o jazycích <a
href="https://www.root.cz/clanky/gnu-guile-interpret-scheme-vestavitelny-do-nativnich-aplikaci/">Guile</a>,
<a
href="https://www.root.cz/clanky/tinyscheme-aneb-dalsi-interpret-jazyka-scheme-vestavitelny-do-dalsich-aplikaci/">TinyScheme</a>,
<a
href="https://www.root.cz/serialy/picolisp-minimalisticky-a-vykonny-interpret-lispu/">PicoLispu</a>,
systému <a
href="https://www.root.cz/clanky/kawa-prekvapive-silny-a-vykonny-dialekt-scheme-pro-jvm/">Kawa</a>
atd. Jednotlivé formy jsou ihned po svém zápisu vyhodnocovány. Nejjednodušší je
pochopitelně situace ve chvíli, kdy je celá forma zapsána na jediném řádku:</p>

<pre>
&gt; <strong>(+ 1 1)</strong>
2
&nbsp;
&gt; <strong>(* 6 7)</strong>
42
</pre>

<p>Formy zapisované na více řádcích jsou vyhodnoceny až se zápisem poslední
pravé kulaté závorky:</p>

<pre>
&gt; <strong>(+</strong>
  <strong>1 2</strong>
  <strong>)</strong>
3
</pre>

<p>K&nbsp;dispozici je i nápověda, která se ovšem neotevře přímo
v&nbsp;terminálu, ale ve webovém prohlížeči:</p>

<pre>
&gt; <strong>(help random)</strong>
&nbsp;
Loading help index...
Sending to web browser...
  file: /opt/racket/doc/reference/generic-numbers.html
  anchor: (def._((lib._racket/private/base..rkt)._random))
</pre>

<a href="https://www.root.cz/obrazek/368027/"><img src="https://i.iinfo.cz/images/100/racket1-4-prev.png" class="image-368027" alt="&#160;" width="370" height="242" /></a>
<p><i>Obrázek 4: Nápověda zobrazená ve webovém prohlížeči.</i></p>

<p><div class="rs-tip-major">Poznámka: kromě výchozího prohlížeče, kterým je
<strong>Lynx</strong> je možné si nastavit i jiný prohlížeč, ovšem Lynx poměrně
pěkně zapadá do konceptu vývoje z&nbsp;terminálu.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Základy programovacího jazyka Racket</h2>

<p>Ve druhé části článku se seznámíme se základními vlastnostmi programovacího
jazyka Racket. Ten vychází z&nbsp;jazyka Scheme, takže většina dále popsaných
příkladů již může být čtenářům tohoto seriálu již dobře známa. Zaměříme se
především na tři sice základní, ale o to důležitější součásti programovacího
jazyka Racket:</p>

<ol>

<li>Práci s&nbsp;numerickými hodnotami a využitím celé takzvané
&bdquo;numerické věže&ldquo;</li>

<li>Definicí pojmenovaných i anonymních funkcí, včetně funkcí s&nbsp;proměnným
počtem parametrů, nepovinnými parametry, tzv.&nbsp;<i>keywords</i> parametry
atd. Funkce jsou základním stavebním prvkem funkcionálních jazyků, takže je
dobré znát všechny jejich možnosti (některé vlastnosti lze plně využít pouze
při přímém použití anonymních funkcí).</li>

<li>Některými základními speciálními formami určenými pro ovlivnění běhu
programu. Jedná se pochopitelně o podmínky a taktéž o programové smyčky.</li>

</ol>



<p><a name="k05"></a></p>
<h2 id="k05">5. Numerická věž a příslušné základní predikáty</h2>

<p>S&nbsp;takzvanou &bdquo;numerickou věží&ldquo; jsme se již v&nbsp;tomto
seriálu setkali při popisu možností dalších dialektů programovacího jazyka
Scheme. Připomeňme si ve stručnosti, že se jedná o hierarchii datových typů
reprezentujících různé typy čísel. Na vrcholu této hierarchie stojí obecný typ
<strong>number</strong>, pod ním leží komplexní čísla, dále čísla reálná, čísla
racionální (zlomky) a nakonec čísla celá:</p>

<table>
<tr><th>#</th><th>Typ</th><th>Význam</th></tr>
<tr><td>1</td><td>number</td><td>libovolná obecná čísla</td></tr>
<tr><td>2</td><td>complex</td><td>komplexní čísla</td></tr>
<tr><td>3</td><td>real</td><td>reálná čísla</td></tr>
<tr><td>4</td><td>rational</td><td>zlomky (racionální čísla)</td></tr>
<tr><td>5</td><td>integer</td><td>celá čísla</td></tr>
</table>

<p>Převody mezi numerickými typy jsou prováděny automaticky na základě
vyhodnocovaného výrazu. Například v&nbsp;následujícím výrazu bylo nutné
vyhodnotit výsledek jako komplexní číslo, protože jsme se snažili vypočítat
druhou odmocninu ze záporného čísla:</p>

<pre>
<strong>(sqrt (/ 3.14159 (- (expt 2 32))))</strong>
&nbsp;
0+2.704548801180264e-05i
</pre>

<p>V&nbsp;jazyce Racket dále existuje velké množství predikátů určených pro
zjištění, jakého typu je daná hodnota (a zda se vůbec jedná o číslo).
Povšimněte si, že některé predikáty slouží pro zjištění, zda se jedná o
&bdquo;přesná&ldquo; či naopak &bdquo;nepřesná&ldquo; čísla. Mezi &bdquo;přesná
čísla&ldquo; patří ty hodnoty, jejichž reálná i imaginární část je buď celé
číslo nebo zlomek (pozor na rozdíl mezi reálnou části komplexního čísla a
reálným číslem):</p>

<table>
<tr><th> #</th><th>Predikát</th><th>Stručný popis</th></tr>
<tr><td> 1</td><td>number?</td><td>test, zda se jedná o jakoukoli numerickou hodnotu</td></tr>
<tr><td> 2</td><td>complex?</td><td>test, zda se jedná o komplexní číslo</td></tr>
<tr><td> 3</td><td>real?</td><td>test, zda se jedná o reálné číslo</td></tr>
<tr><td> 4</td><td>rational?</td><td>test, zda se jedná o racionální číslo (zlomek)</td></tr>
<tr><td> 5</td><td>integer?</td><td>test, zda se jedná o celé číslo</td></tr>
<tr><td> 6</td><td>exact-integer?</td><td>test, zda se jedná o &bdquo;přesné&ldquo; celé číslo</td></tr>
<tr><td> 7</td><td>exact-nonnegative-integer?</td><td>test, zda se jedná o &bdquo;přesné&ldquo; celé nezáporné číslo</td></tr>
<tr><td> 8</td><td>exact-positive-integer?</td><td>test, zda se jedná o &bdquo;přesné&ldquo; celé kladné číslo</td></tr>
<tr><td> 9</td><td>inexact-real?</td><td>test, zda se jedná o &bdquo;nepřesné&ldquo; reálné číslo</td></tr>
<td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></td>
<tr><td>10</td><td>zero?</td><td>test na nulu</td></tr>
<tr><td>11</td><td>positive?</td><td>test na kladné číslo</td></tr>
<tr><td>12</td><td>negative?</td><td>test na záporné číslo</td></tr>
<tr><td>13</td><td>even?</td><td>test na sudé číslo</td></tr>
<tr><td>14</td><td>odd?</td><td>test na liché číslo</td></tr>
<tr><td>15</td><td>exact?</td><td>test na libovolné &bdquo;přesné&ldquo; číslo</td></tr>
<tr><td>16</td><td>inexact?</td><td>test na libovolné &bdquo;nepřesné&ldquo; číslo</td></tr>
</table>



<p><a name="k06"></a></p>
<h2 id="k06">6. Funkce jako základní stavební bloky programů</h2>

<p>Naprostým základem při tvorbě každé jen trošku rozsáhlejší aplikace je
dekompozice problému na menší části, které je možné realizovat snadněji,
protože se výchozí problém více konkretizuje (a přibližuje se tak jak možnostem
použitého programovacího jazyka, tak i schopnosti vývojáře problém
naprogramovat :-). V&nbsp;programovacím jazyku <i>Racket</i> se, podobně jako
v&nbsp;mnoha dalších imperativních a především funkcionálních programovacích
jazycích, pro rozklad problému na menší části používají uživatelsky definované
funkce, a to jak funkce pojmenované (navázané na nějaký symbol &ndash; jméno),
tak i funkce anonymní (tento typ funkcí je představován <i>lambda
výrazy</i>).</p>

<p><div class="rs-tip-major">Poznámka: může to být poněkud matoucí, ale funkce
se v&nbsp;jazyku Racket (i v&nbsp;jeho dokumentaci) někdy označují poněkud
obecnějším termínem <i>procedury</i>.</div></p>

<p>V&nbsp;této kapitole si popíšeme způsob tvorby pojmenovaných funkcí a <a
href="#k08">v&nbsp;kapitole osmé</a> se budeme zabývat problémem tvorby funkcí
anonymních, s&nbsp;čímž souvisí i problematika vytvoření a následného použití
lokálních proměnných. Možná by na tomto místě bylo vhodné připomenout, že
z&nbsp;čistě teoretického hlediska by se měly anonymní funkce popsat dříve než
funkce pojmenované, protože právě anonymní funkce tvoří základ pro vytváření
jak funkcí pojmenovaných, tak i lokálních proměnných (a mnoha dalších
užitečných jazykových konstrukcí). Vytvoření uživatelské pojmenované funkce je
v&nbsp;programovacím jazyku <i>Racket</i> velmi jednoduché &ndash; použije se
speciální forma <strong>define</strong>, za níž se do seznamu zapíše jméno nově
vytvářené funkce i jména jejích formálních parametrů. Za tímto seznamem
následuje tělo funkce, tj.&nbsp;výraz či sekvence výrazů, které se mají
vyhodnotit (v&nbsp;těchto výrazech je samozřejmě možné používat formální
parametry funkce).</p>

<p><div class="rs-tip-major">Poznámka: připomeňme si, že
<strong>define</strong> je <i>speciální formou</i> z&nbsp;toho důvodu, že se
jazyk Racket nesnaží i okamžité vyhodnocení jejích parametrů.</div></p>

<p>Hodnota posledního vyhodnoceného výrazu se stává i návratovou hodnotou celé
funkce, což mj.&nbsp;znamená, že všechny předchozí výrazy musí mít vedlejší
efekt, jinak je jejich volání (použití v&nbsp;těle funkce) vlastně
zbytečné.</p>

<p><div class="rs-tip-major">Poznámka: tento způsob &ndash; poslední výraz ve
funkci je současně (po vyhodnocení) její návratovou hodnotou &ndash; se používá
i v&nbsp;některých moderních programovacích jazycích, které tak mnohdy
nevyžadují explicitní použití klíčového slova
<strong>return</strong>.</div></p>

<p>Formálně vypadá vytvoření nové funkce následovně:</p>

<pre>
(define ([<strong>jméno funkce</strong>] [formální parametry]) [tělo funkce])
</pre>

<p>Definice konkrétní pojmenované funkce bez parametrů (vrací konstantu 0) a
její následné zavolání:</p>

<pre>
<strong>(define (nothing)</strong>
  <strong>0)</strong>
&nbsp;
<strong>(nothing)</strong>
0
</pre>

<p>Postup vytvoření uživatelské funkce s&nbsp;jedním parametrem a jejího
následného použití:</p>

<pre>
<strong>(define (square x) (* x x))</strong>
&nbsp;
<strong>(square 42)</strong>
1764
&nbsp;
<strong>(square (+ 1 2))</strong>
9
&nbsp;
<strong>(+ (square 3) (square 4))</strong>
25
</pre>

<p>Samozřejmě je možné vytvořit i funkci víceparametrickou, zde konkrétně
funkci pro výpočet hodnoty kvadratické funkce ve tvaru
<i>y=ax<sup>2</sup>+bx+c</i> pro zadanou hodnotu <i>x</i>:</p>

<pre>
<strong>(define (quadratic a b c x) (+ (* a x x) (* b x) c))</strong>
&nbsp;
<strong>(quadratic 1 0 0 1)</strong>
1
&nbsp;
<strong>(quadratic 2 2 2 4)</strong>
42
</pre>

<p>Ve funkci je možné vytvořit blok s&nbsp;lokálními proměnnými formou
<strong>let</strong>:</p>

<pre>
(define (square x)
  (let ((result (* x x)))
    result))                                                         
</pre>

<p>Ovšem <strong>let</strong> lze použít i mimo definici funkce pro vytvoření
lokálních proměnných (přesněji řečeno lokálního navázání symbolu/symbolů na
určité hodnoty):</p>

<pre>
(define (add x y)
    (+ x y))
&nbsp;
(print
    (let ((x 10)
          (y 20))
          (add x y)))
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Pojmenování uživatelských funkcí</h2>

<p>V&nbsp;programovacím jazyku <i>Racket</i> lze vytvářet i funkce,
v&nbsp;jejichž názvu se nachází různé nealfanumerické znaky. Je to ostatně
logické, protože se jedná o jeden z&nbsp;těch jazyků (a je jich překvapivě
velké množství), v&nbsp;nichž neexistují ani operátory (zapisované většinou
právě pomocí nealfanumerických znaků) ani většina dalších speciálních
syntaktických konstrukcí. V&nbsp;předchozích částech tohoto seriálu jsme si již
ukázali některé <i>predikáty</i>, u nichž je obvyklé, že jsou jejich jména
ukončena znakem otazník (<strong>?</strong>):</p>

<table>
<tr><th> #</th><th>Funkce (predikát)</th></tr>
<tr><td> 1</td><td>exact?</td></tr>
<tr><td> 2</td><td>inexact?</td></tr>
<tr><td> 3</td><td>odd?</td></tr>
<tr><td> 4</td><td>even?</td></tr>
<tr><td> 5</td><td>zero?</td></tr>
<tr><td> 6</td><td>positive?</td></tr>
<tr><td> 7</td><td>negative?</td></tr>
<tr><td> 8</td><td>eq?</td></tr>
<tr><td> 9</td><td>eqv?</td></tr>
<tr><td>10</td><td>equal?</td></tr>
<tr><td>11</td><td>null?</td></tr>
<tr><td>12</td><td>number?</td></tr>
</table>

<p>Také jsme se seznámili s&nbsp;konverzními funkcemi používajícími ve svém
názvu dvojici znaků <strong>-&gt;</strong>.  Mnohdy se také můžeme setkat
s&nbsp;tím, že se jméno uživatelské funkce skládá z&nbsp;více slov oddělených
pomlčkou (<strong>-</strong>), která je v&nbsp;jiných programovacích jazycích
většinou rezervována pro zápis operátoru rozdílu popř.&nbsp;změny znaménka.
V&nbsp;následujících příkladech je ukázáno, že jména uživatelských funkcí mohou
opravdu obsahovat téměř jakýkoli nealfanumerický znak (výjimek je pouze
několik, vypsány jsou pochopitelně v&nbsp;manuálu jazyka <i>Racket</i> a
většinou se jedná o různé formy závorek a taktéž o znak #):</p>

<pre>
(define (<strong>&gt;=</strong> x y)
    (or (&gt; x y) (= x y))
)
&nbsp;
<i>; druhá možná definice</i>
(define (<strong>&gt;=</strong> x y)
    (not (&lt; x y))
)
</pre>

<p>První přiblížení k&nbsp;tomu, jak by se mohl zapsat ternární výraz. Tento
příklad však má jeden poměrně závažný nedostatek vyplývající z&nbsp;vlastnosti
jazyka <i>Racket</i> (a obecně jakéhokoli lispovského jazyka). Dokážete přijít
na to, o jaký nedostatek se jedná?</p>

<pre>
(define (<strong>?:</strong> podminka prvni-vyraz druhy-vyraz)
    (if podminka prvni-vyraz druhy-vyraz)
)
&nbsp;
<i>; test</i>
(?: #t 1 2)
1
&nbsp;
<i>; další test</i>
(?: #f 1 2)
2
&nbsp;
<i>; Při tisku jednotlivých slov lze namísto</i>
<i>; řetězců použít i takzvané symboly uvozené apostrofem</i>
(?: (&lt; 1 2) 'mensi 'vetsi)
mensi

(?: (&lt; 2 1) 'mensi 'vetsi) 
vetsi
</pre>

<p>Programátoři znalí Basicu :-) pravděpodobně znají operátor &lt;&gt;
(nerovnost), který lze v&nbsp;jazyku <i>Racket</i> velmi jednoduše vytvořit
jako uživatelskou funkci:</p>

<pre>
(define (<strong>&lt;&gt;</strong> x y)
    (not (= x y)))
&nbsp;
(&lt;&gt; 1 2)
 #t
&nbsp;
(&lt;&gt; 1 1)
 #f
</pre>

<p>Ovšem výše uvedenou funkci můžeme též zobecnit na libovolný typ
parametrů:</p>

<pre>
(define (<strong>&lt;&gt;</strong> a b)
    (not (equal? a b)))
&nbsp;
(&lt;&gt; 'a 'b)
#t
&nbsp;
(&lt;&gt; "hello" "world")
#t
&nbsp;
(&lt;&gt; "hello" "hello")
#f
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Anonymní funkce</h2>

<p>Kromě pojmenovaných funkcí popsaných v&nbsp;předchozích dvou kapitolách je
možné v&nbsp;programovacím jazyce <i>Racket</i>, podobně jako
v&nbsp;<i>LISPu</i> a pochopitelně i v&nbsp;klasickém <i>Scheme</i>, ale i
mnoha dalších jazycích umožňujících funkcionální programování, vytvářet a
používat takzvané funkce anonymní. Tyto funkce, které je možné s&nbsp;výhodou
využít například při zápisu iterací nad prvky seznamů či při omezování oblasti
platnosti proměnných, se vytváří s&nbsp;využitím speciální formy
<strong>lambda</strong>, jejíž název je odvozen ze slavné Churchovy teorie
Lambda kalkulu, která má poměrně velký význam jak v&nbsp;teoretické
informatice, tak i v&nbsp;dalších odvětvích informatiky (viz též odkazy uvedené
<a href="#k20">v&nbsp;poslední kapitole</a>). Samotný zápis anonymní funkce se
příliš neliší od zápisu funkce pojmenované &ndash; jediný syntaktický rozdíl
spočívá v&nbsp;tom, že se při zápisu speciální formy <strong>lambda</strong>
nikde neuvádí jméno funkce, pouze seznam (jména) formálních parametrů, za nimiž
následuje tělo funkce:</p>

<pre>
(lambda ([formální parametry]) [tělo anonymní funkce])
</pre>

<pre>
<i>; pouze vytvoření anonymní funkce bez</i>
<i>; jejího dalšího použití (umělý příklad, který</i>
<i>; nemá větší význam, protože se anonymní funkce</i>
<i>; nikde nevolá)</i>
&gt; <strong>(lambda (x) (* x x))</strong>
#<procedure>
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti jsou možnosti specifikace
parametrů ještě dále rozšířeny, což si popíšeme v&nbsp;navazujících
kapitolách.</div></p>

<p>Ihned po vytvoření anonymní funkce je ji možné zavolat:</p>

<pre>
<i>; vytvoření anonymní funkce s jejím následným</i>
<i>; zavoláním s parametrem 42</i>
<strong>((lambda (x) (* x x)) 42)</strong>
1764
</pre>

<p>Příklad použití anonymní funkce s&nbsp;více parametry:</p>

<pre>
<i>; anonymní funkce s více parametry</i>
<strong>(lambda (a b c) (+ a b c))</strong>
#&lt;procedure #f (a b c)&gt;
&nbsp;
<strong>((lambda (a b c) (+ a b c)) 1 2 3)</strong>
6
</pre>

<p>Mezi funkcemi pojmenovanými a anonymními existuje velmi úzká vazba, kterou
si můžeme vysvětlit na jednoduchém příkladu. Mějme uživatelskou funkci nazvanou
<strong>plus</strong>, která sečte své dva parametry (pro jednoduchost
považujme tyto parametry vždy za čísla) a vrátí součet hodnot obou parametrů.
Definice takové funkce je velmi jednoduchá:</p>

<pre>
<strong>(define (plus x y) (+ x y))</strong>
&nbsp;
<i>; test</i>
<strong>(plus 1 2)</strong>
3
</pre>

<p>Výše uvedený zápis je ekvivalentní s&nbsp;následujícím zápisem, ve kterém se
vytváří proměnná nazvaná <strong>plus</strong>, která jako svoji hodnotu
obsahuje (anonymní) funkci. Již v&nbsp;úvodním článku o programovacím jazyku
<i>Scheme</i> jsme si řekli, že funkce lze používat na stejných místech jako
hodnoty jiných typů, takže je tento zápis korektní (a to i
v&nbsp;<i>Racketu</i>, který je, jak již víme, ze <i>Scheme</i> odvozen):</p>

<pre>
<strong>(define plus (lambda (x y) (+ x y)))</strong>
&nbsp;
<i>; zjistíme, jaká hodnota je na symbol plus navázána</i>
<strong>plus</strong>
#&lt;procedure:plus&gt;
<i>; test</i>
<strong>(plus 1 2)</strong>
3
</pre>

<p><div class="rs-tip-major">Poznámka: právě s&nbsp;posledním zápisem, který je
kombinací speciálních forem <strong>define</strong> a <strong>lambda</strong>,
se často setkáme v&nbsp;dalším textu i v&nbsp;navazujících částech tohoto
seriálu.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Anonymní funkce s&nbsp;proměnným počtem parametrů</h2>

<p>Kromě anonymních funkcí, v&nbsp;nichž jsou explicitně vyjmenovány všechny
jejich parametry, lze v&nbsp;programovacím jazyku <i>Racket</i> vytvářet a
následně i volat funkce s&nbsp;proměnným počtem parametrů, což může být
v&nbsp;některých případech velmi užitečné. V&nbsp;nejjednodušším případě, pokud
mají být všechny parametry proměnné (tj.&nbsp;ve skutečnosti se anonymní funkce
nemusí volat s&nbsp;parametrem žádným) se používá následující způsob vytvoření
anonymní funkce:</p>

<pre>
(<strong>lambda</strong> [jméno jediného formálního parametru] [tělo anonymní funkce])
</pre>

<p>To tedy znamená, že mezi následujícími dvěma výrazy je poměrně velký
rozdíl:</p>

<pre>
(lambda (x) ...)
(lambda y ...)
</pre>

<p><div class="rs-tip-major">Poznámka: první lambda výraz akceptuje jediný
parametr nazvaný <strong>x</strong>, druhý lambda výraz pak libovolný počet
parametrů, které se transformují do seznamu pojmenovaného pro změnu
<strong>y</strong>.</div></p>

<p>Při volání druhé výše uvedené anonymní funkce se do formálního parametru
<strong>y</strong> předá <i>seznam</i> obsahující všechny skutečně předávané
parametry. S&nbsp;tímto seznamem je možné pracovat jako s&nbsp;kterýmkoli jiným
seznamem, tj.&nbsp;například lze procházet přes jeho prvky atd:</p>

<pre>
<i>; jeden ze způsobů vytvoření seznamu</i>
<strong>((lambda x x) 1 2 3 4)</strong>
'(1 2 3 4)
&nbsp;
<i>; součet hodnot všech předaných parametrů</i>
<i>; (apply bude popsána dále)</i>
<strong>((lambda x (apply + x)) 1 2 3 4)</strong>
10
&nbsp;
<i>; na parametr (seznam) lze aplikovat různé funkce</i>
<strong>((lambda x (length x)) 'a 'b 'c 'd)</strong>
4
</pre>

<p>V&nbsp;programovacím jazyku <i>Racket</i> lze též použít kombinaci obou
předchozích způsobů, tj.&nbsp;vytvoření anonymní funkce vyžadující pevný počet
povinných parametrů s&nbsp;tím, že všechny ostatní hodnoty předané anonymní
funkci jsou nepovinné. Všechny nepovinné hodnoty jsou při volání anonymní
funkce uloženy do <i>seznamu</i> přiřazeného poslednímu parametru, přičemž
tento parametr musí být při definici anonymní funkce od ostatních parametrů
oddělen tečkou. Povšimněte si, že se v&nbsp;tomto případě nejedná o nějakou
speciální syntaxi, kterou bylo nutné do jazyka zavést, ale pouze o využití již
existujících možností <i>Racketu</i>, které podporuje, podobně jako
<i>LISP</i>, explicitní zápis tečka-dvojic:</p> 

<pre>
(<strong>lambda</strong> ([formální parametry].poslední parametr) [tělo anonymní funkce])
</pre>

<p>Následují příklady použití anonymní funkce s&nbsp;několika povinnými
(pojmenovanými) parametry a možností předání dalších hodnot v&nbsp;seznamu
předanému poslednímu parametru. Ve všech příkladech se v&nbsp;těle anonymní
funkce pouze vytiskne obsah posledního &bdquo;seznamového&ldquo; parametru:</p>

<pre>
<strong>((lambda (a . b) b) 1 2 3 4)</strong>
'(2 3 4)
&nbsp;
<strong>((lambda (a b . c) c) 1 2 3 4)</strong>
'(3 4)
&nbsp;
<strong>((lambda (a b c . d) d) 1 2 3 4)</strong>
'(4)
&nbsp;
<strong>((lambda (a b c d . e) e) 1 2 3 4)</strong>
'()
</pre>

<p><div class="rs-tip-major">Poznámka: programovací jazyk <i>Racket</i>,
přesněji řečeno jeho interaktivní smyčka REPL, se nepatrně odlišuje od
některých dalších implementací jazyka <i>Scheme</i> v&nbsp;tom ohledu, že
seznamy, které jsou výsledkem nějakých výpočtů, jsou zobrazeny
s&nbsp;apostrofem na začátku. Některé další interpretry Scheme namísto toho
zobrazí obsah seznamu bez apostrofu, což znamená, že například předchozí
příklad by při spuštění v&nbsp;REPLu vypadal následovně:</div></p>

<pre>
<strong>((lambda (a . b) b) 1 2 3 4)</strong>
(2 3 4)
&nbsp;
<strong>((lambda (a b . c) c) 1 2 3 4)</strong>
(3 4)
&nbsp;
<strong>((lambda (a b c . d) d) 1 2 3 4)</strong>
(4)
&nbsp;
<strong>((lambda (a b c d . e) e) 1 2 3 4)</strong>
()
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Pojmenované funkce s&nbsp;proměnným počtem parametrů</h2>

<p>Vzhledem k&nbsp;tomu, že speciální formu <strong>define</strong> (ve
variantě, kdy se definuje funkce) lze kdykoli zapsat s&nbsp;využitím speciální
formy <strong>lambda</strong>, je v&nbsp;programovacím jazyku <i>Racket</i>
možné nadefinovat pojmenovanou funkci akceptující proměnný
(tj.&nbsp;v&nbsp;krajním případě i nulový) počet parametrů, z&nbsp;nichž je při
volání funkce automaticky vytvořen seznam, se kterým je možné v&nbsp;těle
funkce libovolným způsobem manipulovat. Syntakticky vypadá definice takové
funkce následovně:</p>

<pre>
(<strong>define (jméno funkce . parametr) [tělo funkce]</strong>)
</pre>

<p>Což je ekvivalentní zápisu, který již známe z&nbsp;předchozího textu:</p>

<pre>
(<strong>define jméno funkce (lambda parametr [tělo funkce])</strong>)
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;předchozím zápisu je důležité, že
<strong>parametr</strong> není uzavřen do kulatých závorek tak, jak by tomu
bylo v&nbsp;případě, kdyby se jednalo o klasický seznam parametrů.</div></p>

<p>Následuje příklad definice funkce s&nbsp;proměnným počtem parametrů:</p>

<pre>
<i>; funkce vracející počet skutečně předaných parametrů</i>
<strong>(define (foo . parametry) (length parametry))</strong>
</pre>

<p>Zavolání této funkce bez parametrů vrátí nulu:</p>

<pre>
<strong>(foo)</strong>
0
</pre>

<p>Předat můžeme jeden parametr:</p>

<pre>
<strong>(foo 42)</strong>
1
</pre>

<p>A samozřejmě i větší počet parametrů:</p>

<pre>
<strong>(foo 1 2)</strong>
2
&nbsp;
<strong>(foo "bar" "baz")</strong>
2
&nbsp;
<strong>(foo '(1 2 3 4))</strong>
1
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;posledním příkladu byl předán
jediný parametr (kterým je čistě náhodou seznam), proto se vrátila
jednička.</div></p>

<p>Ukažme si ještě alternativní formu zápisu využívající kombinace
<strong>define</strong> a <strong>lambda</strong>:</p>

<pre>
<i>; alternativní forma zápisu</i>
(define foo (lambda parametry (length parametry)))
&nbsp;
<i>; volání funkce bez parametrů</i>
(foo)
0
&nbsp;
<i>; volání funkce se třemi parametry (zde se jedná o trojici symbolů)</i>
(foo 'a 'b 'c)
3
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Povinné a nepovinné parametry anonymních funkcí</h2>

<p>Při deklaraci anonymních funkcí můžeme použít i takzvané <i>nepovinné
parametry</i>. Pokud se při volání anonymní funkce neuvede hodnota takového
parametru, bude za ni dosazena výchozí hodnota. Nepovinné parametry se poznají
snadno &ndash; jsou zapsány formou vektoru o dvou prvcích. Prvním prvkem
vektoru je jméno parametru, druhým prvkem pak výchozí hodnota nepovinného
parametru.</p>

<p>Příklad anonymní funkce s&nbsp;jediným parametrem, který je nepovinný a
jehož výchozí hodnota je rovna dvěma:</p>

<pre>
(lambda <strong>([parametr 2])</strong> ...tělo anonymní funkce...)
</pre>

<p>Příklad anonymní funkce s&nbsp;jedním povinným parametrem a jedním
parametrem nepovinným:</p>

<pre>
(lambda <strong>(parametr-1 [parametr-2 2])</strong> ...tělo anonymní funkce...)
</pre>

<p>Příklad anonymní funkce se dvěma nepovinnými parametry:</p>

<pre>
(lambda <strong>([parametr-1 100] [parametr-2 200])</strong> ...tělo anonymní funkce...)
</pre>

<p><div class="rs-tip-major">Poznámka: z&nbsp;předchozích ukázek
mj.&nbsp;vyplývá (logický) důsledek &ndash; nejprve musí být uvedeny všechny
povinné parametry a teprve poté případné parametry nepovinné.</div></p>

<p>V&nbsp;další ukázce je deklarována funkce <strong>inc</strong> zvyšující
hodnotu svého (povinného) parametru buď o jedničku nebo o uvedenou nepovinnou
hodnotu <i>delta</i>:</p>

<pre>
#lang racket/base
&nbsp;
(define <strong>inc</strong>
  (lambda (x [delta 1])
    (+ x delta)))
&nbsp;
(display (inc 10))
(newline)
&nbsp;
(display (inc 10 20))
(newline)
&nbsp;
(display ((lambda (x [delta 1]) (+ x delta)) 10))
(newline)
&nbsp;
(display ((lambda (x [delta 1]) (+ x delta)) 10 20))
(newline)
</pre>

<p>Výsledky:</p>

<pre>
11
30
11
30
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že celý skript začíná
uvedením typu jazyka a jeho dialektu. Podobnými řádky budou začínat i všechny
demonstrační příklady, s&nbsp;nimiž se setkáme v&nbsp;navazujícím
textu.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Povinné a nepovinné parametry pojmenovaných funkcí</h2>

<p>Podobně, jako u lambda výrazů, je možné povinné a nepovinné parametry použít
i při deklaraci běžných pojmenovaných funkcí. Příklad <a
href="#k11">z&nbsp;předchozí kapitoly</a>, v&nbsp;němž jsme definovali funkci
<strong>inc</strong>, tedy můžeme velmi snadno přepsat takto:</p>

<pre>
#lang racket/base
&nbsp;
(define (<strong>inc</strong> x [delta 1])
    (+ x delta))
&nbsp;
(display (inc 10))
(newline)
&nbsp;
(display (inc 10 20))
(newline)
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
11
30
</pre>

<p>Následuje poněkud složitější (a možná i praktičtější) příklad, v&nbsp;němž
je deklarována funkce pro výpočet lineární transformace. Tato funkce akceptuje
jeden povinný parametr <strong>x</strong> a dále dvojici nepovinných parametrů,
které představují měřítko (hodnotu změny měřítka) a offset (posun). Výchozí
hodnota měřítka je 1 (identita) a výchozí hodnota posunu je 0 (bez posunu):</p>

<pre>
#lang racket/base
&nbsp;
(define (<strong>transform</strong> x [scale 1] [offset 0])
    (+ offset (* x scale)))
&nbsp;
(display (transform 10))
(newline)
&nbsp;
(display (transform 10 20))
(newline)
&nbsp;
(display (transform 10 20 -50))
(newline)
</pre>

<p>Opět si ukažme výsledky použití této funkce:</p>

<pre>
10
200
150
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Parametry anonymních funkcí explicitně specifikované svým jménem</h2>

<p>Kromě povinných a nepovinných parametrů popř.&nbsp;volitelného počtu
parametrů existují ještě další způsoby, jakými je možné funkcím předávat
hodnoty, které mají funkce zpracovávat. Jednou z&nbsp;dalších možností jsou
takzvané <i>keywords</i> parametry, což jsou parametry s&nbsp;explicitně
specifikovaným jménem.</p>

<p><div class="rs-tip-major">Poznámka: s&nbsp;podobným konceptem se můžeme
setkat například v&nbsp;programovacím jazyku Python, viz například <a
href="https://treyhunner.com/2018/04/keyword-arguments-in-python/">Keyword
(Named) Arguments in Python: How to Use Them</a>.</div></p>

<p>V&nbsp;dalším demonstračním příkladu se opět setkáme s&nbsp;funkcí určenou
pro výpočet lineární transformace. Tentokrát jsou ovšem parametry
s&nbsp;měřítkem a offsetem (posunem) deklarovány takovým způsobem, že je nutné
je specifikovat přímo svým jménem, které začíná křížkem a dvojtečkou:</p>

<pre>
#lang racket/base
&nbsp;
(define <strong>transform</strong>
  (lambda (x <strong>#:scale scale</strong> <strong>#:offset offset</strong>)
    (+ offset (* x scale))))
</pre>

<p>Příklad použití:</p>

<pre>
(display (transform 10 <strong>#:offset 0</strong> <strong>#:scale 1</strong>))
(newline)
&nbsp;
(display (transform 10 <strong>#:offset -100</strong> <strong>#:scale 1</strong>))
(newline)
&nbsp;
(display (transform 10 <strong>#:offset -100</strong> <strong>#:scale 100</strong>))
(newline)
</pre>

<p><div class="rs-tip-major">Poznámka: pojmenované parametry jsou vždy uváděny
až za běžnými parametry nepovinnými.</div></p>

<p>Mnohem praktičtější je však kombinace obou předchozích možností &ndash;
parametrů nepovinných a současně specifikovaných svým jménem. I to je
v&nbsp;jazyku <i>Racket</i> pochopitelně možné, a to následujícím způsobem:</p>

<pre>
(define transform
  (lambda (x <strong>#:scale [scale 1]</strong> <strong>#:offset [offset 0]</strong>)
    (+ offset (* x scale))))
</pre>

<p>Popř.&nbsp;pro větší názornost:</p>

<pre>
(define transform
  (lambda (x
           <strong>#:scale  [scale 1]</strong>
           <strong>#:offset [offset 0]</strong>)
    (+ offset (* x scale))))
</pre>

<p>Příklad použití:</p>

<pre>
(display (transform 10 <strong>#:offset 0</strong> <strong>#:scale 1</strong>))
(newline)
&nbsp;
(display (transform 10))
(newline)
&nbsp;
(display (transform 10 <strong>#:offset -10</strong>))
(newline)
&nbsp;
(display (transform 10 <strong>#:offset -100</strong> <strong>#:scale 1</strong>))
(newline)
&nbsp;
(display (transform 10 <strong>#:offset -100</strong> <strong>#:scale 100</strong>))
(newline)
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Parametry pojmenovaných funkcí specifikované jménem</h2>

<p>Tato kapitola bude velmi stručná, protože i u pojmenovaných funkcí je možné
specifikovat parametry, které se při volání funkce musí uvádět společně se svým
jménem. Následuje tedy ekvivalent prvního příkladu <a
href="#k13">z&nbsp;předchozí kapitoly</a>:</p>

<pre>
#lang racket/base
&nbsp;
(define (transform x <strong>#:scale scale</strong> <strong>#:offset offset</strong>)
    (+ offset (* x scale)))
&nbsp;
(display (transform 10 #:offset 0 #:scale 1))
(newline)
&nbsp;
(display (transform 10 #:offset -100 #:scale 1))
(newline)
&nbsp;
(display (transform 10 #:offset -100 #:scale 100))
(newline)
</pre>

<p>Taktéž můžeme vytvořit funkci akceptující nepovinné a současně i pojmenované
parametry:</p>

<pre>
#lang racket/base
&nbsp;
(define (transform x <strong>#:scale [scale 1]</strong> <strong>#:offset [offset 0]</strong>)
    (+ offset (* x scale)))
&nbsp;
(display (transform 10 #:offset 0 #:scale 1))
(newline)
&nbsp;
(display (transform 10))
(newline)
&nbsp;
(display (transform 10 #:offset -10))
(newline)
&nbsp;
(display (transform 10 #:offset -100 #:scale 1))
(newline)
&nbsp;
(display (transform 10 #:offset -100 #:scale 100))
(newline)
</pre>

<p>Výsledek předchozího skriptu:</p>

<pre>
10
10
0
-90
900
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Pojmenované a nepojmenované funkce s&nbsp;různou aritou</h2>

<p>Po přečtení předchozích sedmi kapitol by se mohlo zdát, že rozdíl mezi
pojmenovanými a anonymními funkcemi je pouze nepatrný a spočívá v&nbsp;tom, že
u pojmenovaných funkcí je nějakému symbolu funkce přiřazena a že tento symbol
tedy funkci reprezentuje při jejím volání. Ve skutečnosti jsou však možnosti
anonymních funkcí nepatrně větší a to z&nbsp;toho důvodu, že je možné vytvořit
anonymní funkci s&nbsp;různou aritou. Ve skutečnosti se jedná o větší počet
současně deklarovaných funkcí, které mají (mohou mít) různá těla podle toho,
kolik parametrů se při volání funkce použije.</p>

<p>Podívejme se na příklad funkce, která akceptuje různý počet parametrů
&ndash; od žádného parametru do dvou parametrů. Pro každou variantu je ve
skutečnosti použito jiné tělo (tedy z&nbsp;pohledu interpretru naprosto odlišný
kód):</p>

<pre>
#lang racket/base
&nbsp;
(define inc
  (<strong>case-lambda</strong>
    [() 0]
    [(x) (+ x 1)]
    [(x delta) (+ x delta)]))
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se v&nbsp;tomto
případě namísto speciální formy <strong>lambda</strong> použije forma
<strong>case-lambda</strong>.</div></p>

<p>Příklad použití této multifunkce:</p>

<pre>
(display (inc))
(newline)
&nbsp;
(display (inc 10))
(newline)
&nbsp;
(display (inc 10 -1))
(newline)
</pre>

<p><div class="rs-tip-major">Poznámka: s&nbsp;podobným konceptem jsme se
setkali i u programovacího jazyka Clojure, kde ovšem bylo možné vytvořit i
pojmenované funkce s&nbsp;různou aritou:</div></p>

<pre>
(defn <strong>multiply</strong>
    ([x]
     (* x x))
    ([x y]
     (* x y))
    ([x y z] (* x y z)))
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Funkce jako hodnoty</h2>

<p>V&nbsp;programovacím jazyku Racket jsou funkce plnohodnotnými objekty, takže
je například můžeme navázat na další symboly (&bdquo;uložit do proměnné&ldquo;)
atd. Ukažme si několik jednoduchých příkladů:</p>

<pre>
&gt; <strong>(define plus +)</strong>
&nbsp;
&gt; <strong>(define add plus)</strong>
&nbsp;
&gt; <strong>(+ 1 2)</strong>
3
&nbsp;
&gt; <strong>(add 1 2)</strong>
3
&nbsp;
&gt; <strong>(plus 1 2)</strong>
3
&nbsp;
&gt; <strong>(add 1 2 3 4)</strong>
10
</pre>

<p>Funkce lze použít jako parametr jiné funkce (funkce vyššího řádu):</p>

<pre>
&gt; <strong>(apply + '(1 2 3))</strong>
6
&nbsp;
&gt; <strong>(define plus +)</strong>
&nbsp;
&gt; <strong>(apply plus '(1 2 3))</strong>
6
</pre>

<p>Vytvoření nové funkce s&nbsp;využitím <strong>compose</strong> (podobné
threading makru z&nbsp;Clojure):</p>

<pre>
&gt; <strong>((compose1 - sqr) 10)</strong>
-100
&nbsp;
&gt; <strong>((compose1 sqr - sqr) 10)</strong>
10000
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Obsah následující části seriálu</h2>

<p>V&nbsp;navazující části seriálu o světě lispovských programovacích jazyků si
ukážeme některé pokročilejší možnosti tohoto jazyka a především pak knihovny,
které je možné ihned po instalaci Racketu použít. Jako ukázku si uvedeme
program pro výpočet a vykreslení Mandelbrotovy množiny. Tento příklad byl
získán ze stránky <a
href="https://rosettacode.org/wiki/Mandelbrot_set#Racket">projektu Rosetta
Code</a>. V&nbsp;tomto příkladu je ukázáno použití knihovny pro práci
s&nbsp;rastrovou grafikou, vytvoření rastrového obrázku ve formátu PNG, použití
formy <strong>for*</strong> pro vytvoření zanořených programových smyček
atd.:</p>

<pre>
#lang racket
&nbsp; 
(require racket/draw)
&nbsp; 
(define (<strong>iterations</strong> a z i)
  (define z′ (+ (* z z) a))
    (if (or (= i 255) (&gt; (magnitude z′) 2))
        i
        (iterations a z′ (add1 i))))
&nbsp; 
(define (<strong>iter-&gt;color</strong> i)
  (if (= i 255)
      (make-object color% "black")
      (make-object color% (* 5 (modulo i 15)) (* 32 (modulo i 7)) (* 8 (modulo i 31)))))
&nbsp; 
(define (<strong>mandelbrot</strong> width height)
  (define target (make-bitmap width height))
    (define dc (new bitmap-dc% [bitmap target]))
      (for* ([x width] [y height])
             (define real-x (- (* 3.0 (/ x width)) 2.25))
             (define real-y (- (* 2.5 (/ y height)) 1.25))
             (send dc set-pen (iter-&gt;color (iterations (make-rectangular real-x real-y) 0 0)) 1 'solid)
             (send dc draw-point x y))
      (send target save-file "mandelbrot.png" 'png))
&nbsp; 
(mandelbrot 300 200)
</pre>

<img src="https://i.iinfo.cz/images/100/racket1-5.png" class="image-368028" alt="&#160;" width="300" height="200" />
<p><i>Obrázek 5: Výsledek výpočtu provedeného předchozím skriptem.</i></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/lisp-families.git">https://github.com/tisnik/lisp-families.git</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, můžete
namísto toho použít odkazy na jednotlivé příklady, které naleznete
v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>ackermann.rkt</td><td>rekurzivní výpočet Ackermannovy funkce</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/ackermann.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/ackermann.rkt</a></td></tr>
<tr><td> 2</td><td>basic.rkt</td><td>základní použití interpretru jazyka Racket</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/basic.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/basic.rkt</a></td></tr>
<tr><td> 3</td><td>closure_1.rkt</td><td>použití uzávěrů, první příklad</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/closure_1.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/closure_1.rkt</a></td></tr>
<tr><td> 4</td><td>closure_2.rkt</td><td>použití uzávěrů, druhý příklad</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/closure_2.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/closure_2.rkt</a></td></tr>
<tr><td> 5</td><td>closure_3.rkt</td><td>použití uzávěrů, třetí příklad</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/closure_3.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/closure_3.rkt</a></td></tr>
<tr><td> 6</td><td>closure_4.rkt</td><td>použití uzávěrů, čtvrtý příklad</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/closure_4.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/closure_4.rkt</a></td></tr>
<tr><td> 7</td><td>factorial_1.rkt</td><td>rekurzivní výpočet faktoriálu s&nbsp;libovolným rozsahem výsledku</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/factorial_1.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/factorial_1.rkt</a></td></tr>
<tr><td> 8</td><td>factorial_2.rkt</td><td>úprava předchozího příkladu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/factorial_2.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/factorial_2.rkt</a></td></tr>
<tr><td> 9</td><td>factorial_3.rkt</td><td>použití tail-call optimalizace</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/factorial_3.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/factorial_3.rkt</a></td></tr>
<tr><td>10</td><td>functions1.rkt</td><td>definice a volání funkcí, první příklad</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/functions1.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/functions1.rkt</a></td></tr>
<tr><td>11</td><td>functions2.rkt</td><td>definice a volání funkcí, druhý příklad</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/functions2.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/functions2.rkt</a></td></tr>
<tr><td>12</td><td>functions3.rkt</td><td>definice a volání funkcí, třetí příklad</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/functions3.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/functions3.rkt</a></td></tr>
<tr><td>13</td><td>functions4.rkt</td><td>definice a volání funkcí, čtvrtý příklad</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/functions4.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/functions4.rkt</a></td></tr>
<tr><td>14</td><td>func_vararg.rkt</td><td>funkce s&nbsp;proměnným počtem parametrů</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/func_vararg.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/func_vararg.rkt</a></td></tr>
<tr><td>15</td><td>lambdas1.rkt</td><td>lambda výrazy, první příklad</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/lambdas1.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/lambdas1.rkt</a></td></tr>
<tr><td>16</td><td>lambdas2.rkt</td><td>lambda výrazy, druhý příklad</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/lambdas2.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/lambdas2.rkt</a></td></tr>
<tr><td>17</td><td>lambdas3.rkt</td><td>lambda výrazy, třetí příklad</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/lambdas3.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/lambdas3.rkt</a></td></tr>
<tr><td>18</td><td>lambdas_vararg.rkt</td><td>lambda výraz ss&nbsp;proměnným počtem parametrů</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/lambdas_vararg.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/lambdas_vararg.rkt</a></td></tr>
<tr><td>19</td><td>numeric.rkt</td><td>numerická věž jazyka Racket</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/numeric.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/numeric.rkt</a></td></tr>
<tr><td>20</td><td>pi_1.rkt</td><td>výpočet konstanty &pi; v oboru reálných čísel</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/pi_1.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/pi_1.rkt</a></td></tr>
<tr><td>21</td><td>pi_2.rkt</td><td>výpočet konstanty &pi; v oboru racionálních čísel</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/pi_2.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/pi_2.rkt</a></td></tr>
<tr><td>22</td><td>pi_3.rkt</td><td>dtto, ale převod výsledku na reálné číslo</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/pi_3.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/pi_3.rkt</a></td></tr>
<tr><td>23</td><td>functions_keyword_args.rkt</td><td>funkce s&nbsp;explicitně pojmenovanými argumenty</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/functions_keyword_args.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/functions_keyword_args.rkt</a></td></tr>
<tr><td>24</td><td>functions_keyword_optional_args.rkt</td><td>funkce s&nbsp;explicitně pojmenovanými a současně i volitelnými argumenty</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/functions_keyword_optional_args.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/functions_keyword_optional_args.rkt</a></td></tr>
<tr><td>25</td><td>functions_optional_args1.rkt</td><td>funkce s&nbsp;volitelnými argumenty, první příklad</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/functions_optional_args1.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/functions_optional_args1.rkt</a></td></tr>
<tr><td>26</td><td>functions_optional_args2.rkt</td><td>funkce s&nbsp;volitelnými argumenty, druhý příklad</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/functions_optional_args2.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/functions_optional_args2.rkt</a></td></tr>
<tr><td>27</td><td>lambda_arity.rkt</td><td>lambda výraz s&nbsp;proměnnou aritou</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/lambda_arity.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/lambda_arity.rkt</a></td></tr>
<tr><td>28</td><td>lambda_keyword_args.rkt</td><td>lambda výraz s&nbsp;explicitně pojmenovanými argumenty</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/lambda_keyword_args.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/lambda_keyword_args.rkt</a></td></tr>
<tr><td>29</td><td>lambda_keyword_optional_args.rkt</td><td>lambda výraz s&nbsp;explicitně pojmenovanými a současně i volitelnými argumenty</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/lambda_keyword_optional_args.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/lambda_keyword_optional_args.rkt</a></td></tr>
<tr><td>30</td><td>lambda_optional_args.rkt</td><td>lambda výraz s&nbsp;volitelnými argumenty</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/lambda_optional_args.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/lambda_optional_args.rkt</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Literatura</h2>

<ol>

<li>Peter Seibel<br />
<i>&bdquo;Practical Common Lisp&ldquo;</i><br />
2009
</li>

<li>Paul Graham<br />
<i>&bdquo;ANSI Common Lisp&ldquo;</i><br />
1995
</li>

<li>Gerald Gazdar<br />
<i>&bdquo;Natural Language Processing in Lisp: An Introduction to Computational Linguistics&ldquo;</i><br />
1989
</li>

<li>Peter Norvig<br />
<i>&bdquo;Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp&ldquo;</i><br />
1991
</li>

<li>Alex Mileler et.al.<br />
<i>&bdquo;Clojure Applied: From Practice to Practitioner&ldquo;</i><br />
2015
</li>

<li>
<i>&bdquo;Living Clojure: An Introduction and Training Plan for Developers&ldquo;</i><br />
2015
</li>

<li>Dmitri Sotnikov<br />
<i>&bdquo;Web Development with Clojure: Build Bulletproof Web Apps with Less Code&ldquo;</i><br />
2016
</li>

<li>McCarthy<br />
<i>&bdquo;Recursive functions of symbolic expressions and their computation by machine, part I&ldquo;</i><br />
1960
</li>

<li>R. Kent Dybvig<br />
<i>&bdquo;The Scheme Programming Language&ldquo;</i><br />
2009
</li>

<li>Max Hailperin<br />
<i>&bdquo;Concrete Abstractions&ldquo;</i><br />
1998
</li>

<li>Guy L. Steele<br />
<i>&bdquo;History of Scheme&ldquo;</i><br />
2006, Sun Microsystems Laboratories
</li>

<li>Kolář J., Muller K.:<br />
<i>&bdquo;Speciální programovací jazyky&ldquo;</i><br />
Praha 1981
</li>

<li>
<i>&bdquo;AutoLISP Release 9, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., October 1987
</li>

<li>
<i>&bdquo;AutoLISP Release 10, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., September 1988
</li>

<li>McCarthy, John; Abrahams, Paul W.; Edwards, Daniel J.; Hart, Timothy P.; Levin, Michael I.<br />
<i>&bdquo;LISP 1.5 Programmer's Manual&ldquo;</i><br />
MIT Press. ISBN 0 262 130 1 1 4
</li>

<li>Carl Hewitt; Peter Bishop and Richard Steiger<br />
<i>&bdquo;A Universal Modular Actor Formalism for Artificial Intelligence&ldquo;</i><br />
1973
</li>

<li>Feiman, J.<br />
<i>&bdquo;The Gartner Programming Language Survey (October 2001)&ldquo;</i><br />
Gartner Advisory
</li>

<li>Harold Abelson, Gerald Jay Sussman, Julie Sussman:<br />
<i>Structure and Interpretation of Computer Programs</i><br />
MIT Press. 1985, 1996 (a možná vyšel i další přetisk)
</li>

<li>Paul Graham<br />
<i>On Lisp</i><br />
Prentice Hall, 1993<br />
Dostupné online na stránce <a href="http://www.paulgraham.com/onlisptext.html">http://www.paulgraham.com/onlisptext.html</a>
</li>

<li>David S. Touretzky<br />
<i>Common LISP: A Gentle Introduction to Symbolic Computation (Dover Books on Engineering)</i><br />
</li>

<li>Peter Norvig<br />
<i>Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp</i>
</li>

<li>Patrick Winston, Berthold Horn<br />
<i>Lisp (3rd Edition)</i><br />
ISBN-13: 978-0201083194, ISBN-10: 0201083191
</li>

<li>Matthias Felleisen, David Van Horn, Dr. Conrad Barski<br>
<i>Realm of Racket: Learn to Program, One Game at a Time!</i><br />
ISBN-13: 978-1593274917, ISBN-10: 1593274912 
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Beautiful Racket: an intro­duction to language-oriented programming using Racket<br />
<a href="https://beautifulracket.com/">https://beautifulracket.com/</a>
</li>

<li>Stránky projektu Racket<br />
<a href="https://racket-lang.org/">https://racket-lang.org/</a>
</li>

<li>Dokumentace k&nbsp;projektu Racket<br />
<a href="https://docs.racket-lang.org/index.html">https://docs.racket-lang.org/index.html</a>
</li>

<li>Seznam dostupných balíčků pro Racket<br />
<a href="https://pkgs.racket-lang.org/">https://pkgs.racket-lang.org/</a>
</li>

<li>Racket na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Racket_(programming_language)">https://en.wikipedia.org/wiki/Racket_(programming_language)</a>
</li>

<li>Blogy o Racketu a navazujících technologiích<br />
<a href="https://blog.racket-lang.org/">https://blog.racket-lang.org/</a>
</li>

<li>Prográmky psané v&nbsp;Racketu na RosettaCode<br />
<a href="http://rosettacode.org/wiki/Category:Racket">http://rosettacode.org/wiki/Category:Racket</a>
</li>

<li>Kawa: Compiling Scheme to Java<br />
<a href="https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html">https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html</a>
</li>

<li>Kawa in Languages shootout<br />
<a href="http://per.bothner.com/blog/2010/Kawa-in-shootout/">http://per.bothner.com/blog/2010/Kawa-in-shootout/</a>
</li>

<li>Kawa 2.0 Supports Scheme R7RS<br />
<a href="https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/">https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/</a>
</li>

<li>Kawa — fast scripting on the Java platform<br />
<a href="https://lwn.net/Articles/623349/">https://lwn.net/Articles/623349/</a>
</li>

<li>Tail call (a její optimalizace)<br />
<a href="https://en.wikipedia.org/wiki/Tail_call">https://en.wikipedia.org/wiki/Tail_call</a>
</li>

<li>SLIME (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/SLIME">http://en.wikipedia.org/wiki/SLIME</a>
</li>

<li>slime.vim<br />
<a href="http://s3.amazonaws.com/mps/slime.vim">http://s3.amazonaws.com/mps/slime.vim</a>
</li>

<li>What are the best scheme implementations?<br />
<a href="https://www.slant.co/topics/5282/~scheme-implementations">https://www.slant.co/topics/5282/~scheme-implementations</a>
</li>

<li>Bigloo homepage<br />
<a href="http://www-sop.inria.fr/mimosa/fp/Bigloo/">http://www-sop.inria.fr/mimosa/fp/Bigloo/</a>
</li>

<li>FTP s tarbally Bigloo<br />
<a href="ftp://ftp-sop.inria.fr/indes/fp/Bigloo">ftp://ftp-sop.inria.fr/indes/fp/Bigloo</a>
</li>

<li>GOTO 2018 • Functional Programming in 40 Minutes • Russ Olsen<br />
<a href="https://www.youtube.com/watch?v=0if71HOyVjY">https://www.youtube.com/watch?v=0if71HOyVjY</a>
</li>

<li>TinyScheme (stránka na Sourceforge)<br />
<a href="http://tinyscheme.sourceforge.net/home.html">http://tinyscheme.sourceforge.net/home.html</a>
</li>

<li>Embedding Tiny Scheme in a Game<br />
<a href="http://www.silicondelight.com/embedding-tiny-scheme-in-a-game/">http://www.silicondelight.com/embedding-tiny-scheme-in-a-game/</a>
</li>

<li>Embedding Scheme for a game mission scripting DSL<br />
<a href="http://carloscarrasco.com/embedding-scheme-for-a-game-mission-scripting-dsl.html">http://carloscarrasco.com/embedding-scheme-for-a-game-mission-scripting-dsl.html</a>
</li>

<li>Všechny verze TinyScheme na SourceForge<br />
<a href="https://sourceforge.net/projects/tinyscheme/files/tinyscheme/">https://sourceforge.net/projects/tinyscheme/files/tinyscheme/</a>
</li>

<li>Fork TinyScheme na GitHubu<br />
<a href="https://github.com/yawnt/tinyscheme">https://github.com/yawnt/tinyscheme</a>
</li>

<li>Ackermannova funkce<br />
<a href="https://cs.wikipedia.org/wiki/Ackermannova_funkce">https://cs.wikipedia.org/wiki/Ackermannova_funkce</a>
</li>

<li>Ackermann function na Rosetta Code<br />
<a href="https://rosettacode.org/wiki/Ackermann_function#Scheme">https://rosettacode.org/wiki/Ackermann_function#Scheme</a>
</li>

<li>Success Stories (lisp.org)<br />
<a href="https://lisp-lang.org/success/">https://lisp-lang.org/success/</a>
</li>

<li>Allegro Common Lisp Success Stories<br />
<a href="https://franz.com/success/">https://franz.com/success/</a>
</li>

<li>Clojure Success Stories<br />
<a href="https://clojure.org/community/success_stories">https://clojure.org/community/success_stories</a>
</li>

<li>Scheme Quick Reference<br />
<a href="https://www.st.cs.uni-saarland.de/edu/config-ss04/scheme-quickref.pdf">https://www.st.cs.uni-saarland.de/edu/config-ss04/scheme-quickref.pdf</a>
</li>

<li>Slajdy o Scheme (od slajdu číslo 15)<br />
<a href="https://docs.google.com/presentation/d/1abmDnKjrq1tcjGvvRNAKhOiSTSE2lyagtcEPal07Gbo/edit">https://docs.google.com/presentation/d/1abmDnKjrq1tcjGvvRNAKhOiSTSE2lyagtcEPal07Gbo/edit</a>
</li>

<li>Scheme Cheat Sheet<br />
<a href="https://github.com/smythp/scheme-cheat-sheet">https://github.com/smythp/scheme-cheat-sheet</a>
</li>

<li>Embedding Lua, embedding Guile <br />
<a href="http://puntoblogspot.blogspot.com/2013/04/embedding-lua-embedding-guile.html">http://puntoblogspot.blogspot.com/2013/04/embedding-lua-embedding-guile.html</a>
</li>

<li>Lambda Papers<br />
<a href="https://en.wikisource.org/wiki/Lambda_Papers">https://en.wikisource.org/wiki/Lambda_Papers</a>
</li>

<li>Revised<sup>7</sup>Report on the Algorithmic Language Scheme<br />
<a href="https://small.r7rs.org/attachment/r7rs.pdf">https://small.r7rs.org/attachment/r7rs.pdf</a>
</li>

<li>Video Lectures (MIT, SICP 2005)<br />
<a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/</a>
</li>

<li>Why is Scheme my first language in university?<br />
<a href="https://softwareengineering.stackexchange.com/questions/115252/why-is-scheme-my-first-language-in-university">https://softwareengineering.stackexchange.com/questions/115252/why-is-scheme-my-first-language-in-university</a>
</li>

<li>The Perils of JavaSchools<br />
<a href="https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/">https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/</a>
</li>

<li>How to Design Programs, Second Edition<br />
<a href="https://htdp.org/2019-02-24/index.html">https://htdp.org/2019-02-24/index.html</a>
</li>

<li>LilyPond<br />
<a href="http://lilypond.org/">http://lilypond.org/</a>
</li>

<li>LilyPond — Extending (přes Scheme)<br />
<a href="http://lilypond.org/doc/v2.18/Documentation/extending/scheme-tutorial">http://lilypond.org/doc/v2.18/Documentation/extending/scheme-tutorial</a>
</li>

<li>Scheme in LilyPond<br />
<a href="http://lilypond.org/doc/v2.18/Documentation/extending/scheme-in-lilypond">http://lilypond.org/doc/v2.18/Documentation/extending/scheme-in-lilypond</a>
</li>

<li>GnuCash<br />
<a href="http://www.gnucash.org/">http://www.gnucash.org/</a>
</li>

<li>Custom Reports (in GNU Cash)<br />
<a href="https://wiki.gnucash.org/wiki/Custom_Reports">https://wiki.gnucash.org/wiki/Custom_Reports</a>
</li>

<li>Program by Design<br />
<a href="https://programbydesign.org/">https://programbydesign.org/</a>
</li>

<li>SchemePy<br />
<a href="https://pypi.org/project/SchemePy/">https://pypi.org/project/SchemePy/</a>
</li>

<li>LISP FQA: Section - [1-5] What is the "minimal" set of primitives needed for a Lisp interpreter?<br />
<a href="http://www.faqs.org/faqs/lisp-faq/part1/section-6.html">http://www.faqs.org/faqs/lisp-faq/part1/section-6.html</a>
</li>

<li>femtolisp<br />
<a href="https://github.com/JeffBezanson/femtolisp">https://github.com/JeffBezanson/femtolisp</a>
</li>

<li>(How to Write a (Lisp) Interpreter (in Python))<br />
<a href="http://norvig.com/lispy.html">http://norvig.com/lispy.html</a>
</li>

<li>Repositář s&nbsp;Guile Emacsem<br />
<a href="http://git.hcoop.net/?p=bpt/guile.git">http://git.hcoop.net/?p=bpt/guile.git</a>
</li>

<li>Interacting with Guile Compound Data Types in C<br />
<a href="http://www.lonelycactus.com/guilebook/x1555.html">http://www.lonelycactus.com/guilebook/x1555.html</a>
</li>

<li>Calling Guile functions from C<br />
<a href="http://www.lonelycactus.com/guilebook/c1204.html#SECCALLGUILEFUNC">http://www.lonelycactus.com/guilebook/c1204.html#SECCALLGUILEFUNC</a>
</li>

<li>Arrays, and other compound data types<br />
<a href="http://www.lonelycactus.com/guilebook/charrays.html">http://www.lonelycactus.com/guilebook/charrays.html</a>
</li>

<li>Interacting with Guile Compound Data Types in C<br />
<a href="http://www.lonelycactus.com/guilebook/x1555.html">http://www.lonelycactus.com/guilebook/x1555.html</a>
</li>

<li>Guile Reference Manual<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/index.html">https://www.gnu.org/software/guile/manual/html_node/index.html</a>
</li>

<li>Scheme: Summary of Common Syntax<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/Syntax-Summary.html#Syntax-Summary">https://www.gnu.org/software/guile/manual/html_node/Syntax-Summary.html#Syntax-Summary</a>
</li>

<li>Scripting with Guile: Extension language enhances C and Scheme<br />
<a href="https://www.ibm.com/developerworks/library/l-guile/index.html">https://www.ibm.com/developerworks/library/l-guile/index.html</a>
</li>

<li>Having fun with Guile: a tutorial<br />
<a href="http://dustycloud.org/misc/guile-tutorial.html">http://dustycloud.org/misc/guile-tutorial.html</a>
</li>

<li>Guile: Loading Readline Support<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/Loading-Readline-Support.html#Loading-Readline-Support">https://www.gnu.org/software/guile/manual/html_node/Loading-Readline-Support.html#Loading-Readline-Support</a>
</li>

<li>lispy<br />
<a href="https://pypi.org/project/lispy/">https://pypi.org/project/lispy/</a>
</li>

<li>Lython<br />
<a href="https://pypi.org/project/Lython/">https://pypi.org/project/Lython/</a>
</li>

<li>Lizpop<br />
<a href="https://pypi.org/project/lizpop/">https://pypi.org/project/lizpop/</a>
</li>

<li>Budoucnost programovacích jazyků<br />
<a href="http://www.knesl.com/budoucnost-programovacich-jazyku">http://www.knesl.com/budoucnost-programovacich-jazyku</a>
</li>

<li>LISP Prolog and Evolution<br />
<a href="http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html">http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html</a>
</li>

<li>List of Lisp-family programming languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages">https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages</a>
</li>

<li>clojure_py na indexu PyPi<br />
<a href="https://pypi.python.org/pypi/clojure_py">https://pypi.python.org/pypi/clojure_py</a>
</li>

<li>PyClojure<br />
<a href="https://github.com/eigenhombre/PyClojure">https://github.com/eigenhombre/PyClojure</a>
</li>

<li>Hy na GitHubu<br />
<a href="https://github.com/hylang/hy">https://github.com/hylang/hy</a>
</li>

<li>Hy: The survival guide<br />
<a href="https://notes.pault.ag/hy-survival-guide/">https://notes.pault.ag/hy-survival-guide/</a>
</li>

<li>Hy běžící na monitoru terminálu společnosti Symbolics<br />
<a href="http://try-hy.appspot.com/">http://try-hy.appspot.com/</a>
</li>

<li>Welcome to Hy’s documentation!<br />
<a href="http://docs.hylang.org/en/stable/">http://docs.hylang.org/en/stable/</a>
</li>

<li>Hy na PyPi<br />
<a href="https://pypi.org/project/hy/#description">https://pypi.org/project/hy/#description</a>
</li>

<li>Getting Hy on Python<br />
<a href="https://lwn.net/Articles/596626/">https://lwn.net/Articles/596626/</a>
</li>

<li>Programming Can Be Fun with Hy<br />
<a href="https://opensourceforu.com/2014/02/programming-can-fun-hy/">https://opensourceforu.com/2014/02/programming-can-fun-hy/</a>
</li>

<li>Přednáška o projektu Hy (pětiminutový lighttalk)<br />
<a href="http://blog.pault.ag/day/2013/04/02">http://blog.pault.ag/day/2013/04/02</a>
</li>

<li>Hy (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Hy">https://en.wikipedia.org/wiki/Hy</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Point<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Point.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Point.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Narrowing<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Narrowing.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Narrowing.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Functions that Create Markers<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Markers.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Markers.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Motion<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Motion.html#Motion">https://www.gnu.org/software/emacs/manual/html_node/elisp/Motion.html#Motion</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Basic Char Syntax<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Char-Syntax.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Char-Syntax.html</a>
</li>

<li>Elisp: Sequence: List, Array<br />
<a href="http://ergoemacs.org/emacs/elisp_list_vs_vector.html">http://ergoemacs.org/emacs/elisp_list_vs_vector.html</a>
</li>

<li>Elisp: Property List<br />
<a href="http://ergoemacs.org/emacs/elisp_property_list.html">http://ergoemacs.org/emacs/elisp_property_list.html</a>
</li>

<li>Elisp: Hash Table<br />
<a href="http://ergoemacs.org/emacs/elisp_hash_table.html">http://ergoemacs.org/emacs/elisp_hash_table.html</a>
</li>

<li>Elisp: Association List<br />
<a href="http://ergoemacs.org/emacs/elisp_association_list.html">http://ergoemacs.org/emacs/elisp_association_list.html</a>
</li>

<li>The mapcar Function (An Introduction to Programming in Emacs Lisp)<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/mapcar.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/mapcar.html</a>
</li>

<li>Anaphoric macro<br />
<a href="https://en.wikipedia.org/wiki/Anaphoric_macro">https://en.wikipedia.org/wiki/Anaphoric_macro</a>
</li>

<li>Some Common Lisp Loop Macro Examples<br />
<a href="https://www.youtube.com/watch?v=3yl8o6r_omw">https://www.youtube.com/watch?v=3yl8o6r_omw</a>
</li>

<li>A Guided Tour of Emacs<br />
<a href="https://www.gnu.org/software/emacs/tour/">https://www.gnu.org/software/emacs/tour/</a>
</li>

<li>The Roots of Lisp<br />
<a href="http://www.paulgraham.com/rootsoflisp.html">http://www.paulgraham.com/rootsoflisp.html</a>
</li>

<li>Evil (Emacs Wiki)<br />
<a href="https://www.emacswiki.org/emacs/Evil">https://www.emacswiki.org/emacs/Evil</a>
</li>

<li>Evil (na GitHubu)<br />
<a href="https://github.com/emacs-evil/evil">https://github.com/emacs-evil/evil</a>
</li>

<li>Evil (na stránkách repositáře MELPA)<br />
<a href="https://melpa.org/#/evil">https://melpa.org/#/evil</a>
</li>

<li>Evil Mode: How I Switched From VIM to Emacs<br />
<a href="https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html">https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html</a>
</li>

<li>GNU Emacs (home page)<br />
<a href="https://www.gnu.org/software/emacs/">https://www.gnu.org/software/emacs/</a>
</li>

<li>GNU Emacs (texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs">http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs</a>
</li>

<li>An Introduction To Using GDB Under Emacs<br />
<a href="http://tedlab.mit.edu/~dr/gdbintro.html">http://tedlab.mit.edu/~dr/gdbintro.html</a>
</li>

<li>An Introduction to Programming in Emacs Lisp<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html</a>
</li>

<li>27.6 Running Debuggers Under Emacs<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html">https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html</a>
</li>

<li>GdbMode<br />
<a href="http://www.emacswiki.org/emacs/GdbMode">http://www.emacswiki.org/emacs/GdbMode</a>
</li>

<li>Emacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Emacs">https://en.wikipedia.org/wiki/Emacs</a>
</li>

<li>Emacs timeline<br />
<a href="http://www.jwz.org/doc/emacs-timeline.html">http://www.jwz.org/doc/emacs-timeline.html</a>
</li>

<li>Emacs Text Editors Family<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?EmacsFamily">http://texteditors.org/cgi-bin/wiki.pl?EmacsFamily</a>
</li>

<li>Vrapper aneb spojení možností Vimu a Eclipse<br />
<a href="https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse/">https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse/</a>
</li>

<li>Vrapper aneb spojení možností Vimu a Eclipse (část 2: vyhledávání a nahrazování textu)<br />
<a href="https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse-cast-2-vyhledavani-a-nahrazovani-textu/">https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse-cast-2-vyhledavani-a-nahrazovani-textu/</a>
</li>

<li>Emacs/Evil-mode - A basic reference to using evil mode in Emacs<br />
<a href="http://www.aakarshnair.com/posts/emacs-evil-mode-cheatsheet">http://www.aakarshnair.com/posts/emacs-evil-mode-cheatsheet</a>
</li>

<li>From Vim to Emacs+Evil chaotic migration guide<br />
<a href="https://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/">https://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/</a>
</li>

<li>Introduction to evil-mode {video)<br />
<a href="https://www.youtube.com/watch?v=PeVQwYUxYEg">https://www.youtube.com/watch?v=PeVQwYUxYEg</a>
</li>

<li>EINE (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/EINE">http://www.emacswiki.org/emacs/EINE</a>
</li>

<li>EINE (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?EINE">http://texteditors.org/cgi-bin/wiki.pl?EINE</a>
</li>

<li>ZWEI (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/ZWEI">http://www.emacswiki.org/emacs/ZWEI</a>
</li>

<li>ZWEI (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?ZWEI">http://texteditors.org/cgi-bin/wiki.pl?ZWEI</a>
</li>

<li>Zmacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Zmacs">https://en.wikipedia.org/wiki/Zmacs</a>
</li>

<li>Zmacs (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?Zmacs">http://texteditors.org/cgi-bin/wiki.pl?Zmacs</a>
</li>

<li>TecoEmacs (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/TecoEmacs">http://www.emacswiki.org/emacs/TecoEmacs</a>
</li>

<li>Micro Emacs<br />
<a href="http://www.emacswiki.org/emacs/MicroEmacs">http://www.emacswiki.org/emacs/MicroEmacs</a>
</li>

<li>Micro Emacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/MicroEMACS">https://en.wikipedia.org/wiki/MicroEMACS</a>
</li>

<li>EmacsHistory<br />
<a href="http://www.emacswiki.org/emacs/EmacsHistory">http://www.emacswiki.org/emacs/EmacsHistory</a>
</li>

<li>Seznam editorů s ovládáním podobným Emacsu či kompatibilních s příkazy Emacsu<br />
<a href="http://www.finseth.com/emacs.html">http://www.finseth.com/emacs.html</a>
</li>

<li>evil-numbers<br />
<a href="https://github.com/cofi/evil-numbers">https://github.com/cofi/evil-numbers</a>
</li>

<li>Debuggery a jejich nadstavby v&nbsp;Linuxu (1.část)<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/</a>
</li>

<li>Debuggery a jejich nadstavby v&nbsp;Linuxu (2.část)<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (3): Nemiver<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (4): KDbg<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (5): ladění aplikací v editorech Emacs a Vim<br />
<a href="https://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">https://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/</a>
</li>

<li>Org mode<br />
<a href="https://orgmode.org/">https://orgmode.org/</a>
</li>

<li>The Org Manual<br />
<a href="https://orgmode.org/manual/index.html">https://orgmode.org/manual/index.html</a>
</li>

<li>Kakoune (modální textový editor)<br />
<a href="http://kakoune.org/">http://kakoune.org/</a>
</li>

<li>Vim-style keybinding in Emacs/Evil-mode<br />
<a href="https://gist.github.com/troyp/6b4c9e1c8670200c04c16036805773d8">https://gist.github.com/troyp/6b4c9e1c8670200c04c16036805773d8</a>
</li>

<li>Emacs - jak začít<br />
<a href="http://www.abclinuxu.cz/clanky/navody/emacs-jak-zacit">http://www.abclinuxu.cz/clanky/navody/emacs-jak-zacit</a>
</li>

<li>Programovací jazyk LISP a LISP machines<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-lisp-a-lisp-machines/">https://www.root.cz/clanky/programovaci-jazyk-lisp-a-lisp-machines/</a>
</li>

<li>Evil-surround<br />
<a href="https://github.com/emacs-evil/evil-surround">https://github.com/emacs-evil/evil-surround</a>
</li>

<li>Spacemacs<br />
<a href="http://spacemacs.org/">http://spacemacs.org/</a>
</li>

<li>Lisp: Common Lisp, Racket, Clojure, Emacs Lisp<br />
<a href="http://hyperpolyglot.org/lisp">http://hyperpolyglot.org/lisp</a>
</li>

<li>Common Lisp, Scheme, Clojure, And Elisp Compared<br />
<a href="http://irreal.org/blog/?p=725">http://irreal.org/blog/?p=725</a>
</li>

<li>Does Elisp Suck?<br />
<a href="http://irreal.org/blog/?p=675">http://irreal.org/blog/?p=675</a>
</li>

<li>Emacs pro mírně pokročilé (9): Elisp<br />
<a href="https://www.root.cz/clanky/emacs-elisp/">https://www.root.cz/clanky/emacs-elisp/</a>
</li>

<li>If I want to learn lisp, are emacs and elisp a good choice?<br />
<a href="https://www.reddit.com/r/emacs/comments/2m141y/if_i_want_to_learn_lisp_are_emacs_and_elisp_a/">https://www.reddit.com/r/emacs/comments/2m141y/if_i_want_to_learn_lisp_are_emacs_and_elisp_a/</a>
</li>

<li>Clojure(Script) Interactive Development Environment that Rocks!<br />
<a href="https://github.com/clojure-emacs/cider">https://github.com/clojure-emacs/cider</a>
</li>

<li>An Introduction to Emacs Lisp<br />
<a href="https://harryrschwartz.com/2014/04/08/an-introduction-to-emacs-lisp.html">https://harryrschwartz.com/2014/04/08/an-introduction-to-emacs-lisp.html</a>
</li>

<li>Emergency Elisp<br />
<a href="http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html">http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html</a>
</li>

<li>Lambda calculus<br />
<a href="https://en.wikipedia.org/wiki/Lambda_calculus">https://en.wikipedia.org/wiki/Lambda_calculus</a>
</li>

<li>John McCarthy's original LISP paper from 1959<br />
<a href="https://www.reddit.com/r/programming/comments/17lpz4/john_mccarthys_original_lisp_paper_from_1959/">https://www.reddit.com/r/programming/comments/17lpz4/john_mccarthys_original_lisp_paper_from_1959/</a>
</li>

<li>Micro Manual LISP<br />
<a href="https://www.scribd.com/document/54050141/Micro-Manual-LISP">https://www.scribd.com/document/54050141/Micro-Manual-LISP</a>
</li>

<li>How Lisp Became God's Own Programming Language<br />
<a href="https://twobithistory.org/2018/10/14/lisp.html">https://twobithistory.org/2018/10/14/lisp.html</a>
</li>

<li>History of Lisp<br />
<a href="http://jmc.stanford.edu/articles/lisp/lisp.pdf">http://jmc.stanford.edu/articles/lisp/lisp.pdf</a>
</li>

<li>The Roots of Lisp<br />
<a href="http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf">http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf</a>
</li>

<li>The Racket Manifesto<br />
<a href="http://felleisen.org/matthias/manifesto/">http://felleisen.org/matthias/manifesto/</a>
</li>

<li>MIT replaces Scheme with Python<br />
<a href="https://www.johndcook.com/blog/2009/03/26/mit-replaces-scheme-with-python/">https://www.johndcook.com/blog/2009/03/26/mit-replaces-scheme-with-python/</a>
</li>

<li>Adventures in Advanced Symbolic Programming<br />
<a href="http://groups.csail.mit.edu/mac/users/gjs/6.945/">http://groups.csail.mit.edu/mac/users/gjs/6.945/</a>
</li>

<li>Why MIT Switched from Scheme to Python (2009)<br />
<a href="https://news.ycombinator.com/item?id=14167453">https://news.ycombinator.com/item?id=14167453</a>
</li>

<li>Starodávná stránka XLispu<br />
<a href="http://www.xlisp.org/">http://www.xlisp.org/</a>
</li>

<li>AutoLISP<br />
<a href="https://en.wikipedia.org/wiki/AutoLISP">https://en.wikipedia.org/wiki/AutoLISP</a>
</li>

<li>Seriál PicoLisp: minimalistický a výkonný interpret Lispu<br />
<a href="https://www.root.cz/serialy/picolisp-minimalisticky-a-vykonny-interpret-lispu/">https://www.root.cz/serialy/picolisp-minimalisticky-a-vykonny-interpret-lispu/</a>
</li>

<li>Common Lisp<br />
<a href="https://common-lisp.net/">https://common-lisp.net/</a>
</li>

<li>Getting Going with Common Lisp<br />
<a href="https://cliki.net/Getting%20Started">https://cliki.net/Getting%20Started</a>
</li>

<li>Online Tutorial (Common Lisp)<br />
<a href="https://cliki.net/online%20tutorial">https://cliki.net/online%20tutorial</a>
</li>

<li>Guile Emacs<br />
<a href="https://www.emacswiki.org/emacs/GuileEmacs">https://www.emacswiki.org/emacs/GuileEmacs</a>
</li>

<li>Guile Emacs History<br />
<a href="https://www.emacswiki.org/emacs/GuileEmacsHistory">https://www.emacswiki.org/emacs/GuileEmacsHistory</a>
</li>

<li>Guile is a programming language<br />
<a href="https://www.gnu.org/software/guile/">https://www.gnu.org/software/guile/</a>
</li>

<li>MIT Scheme<br />
<a href="http://groups.csail.mit.edu/mac/projects/scheme/">http://groups.csail.mit.edu/mac/projects/scheme/</a>
</li>

<li>SIOD: Scheme in One Defun<br />
<a href="http://people.delphiforums.com/gjc//siod.html">http://people.delphiforums.com/gjc//siod.html</a>
</li>

<li>CommonLispForEmacs<br />
<a href="https://www.emacswiki.org/emacs/CommonLispForEmacs">https://www.emacswiki.org/emacs/CommonLispForEmacs</a>
</li>

<li>Elisp: print, princ, prin1, format, message<br />
<a href="http://ergoemacs.org/emacs/elisp_printing.html">http://ergoemacs.org/emacs/elisp_printing.html</a>
</li>

<li>Special Forms in Lisp<br />
<a href="http://www.nhplace.com/kent/Papers/Special-Forms.html">http://www.nhplace.com/kent/Papers/Special-Forms.html</a>
</li>

<li>Basic Building Blocks in LISP<br />
<a href="https://www.tutorialspoint.com/lisp/lisp_basic_syntax.htm">https://www.tutorialspoint.com/lisp/lisp_basic_syntax.htm</a>
</li>

<li>Introduction to LISP - University of Pittsburgh<br />
<a href="https://people.cs.pitt.edu/~milos/courses/cs2740/Lectures/LispTutorial.pdf">https://people.cs.pitt.edu/~milos/courses/cs2740/Lectures/LispTutorial.pdf</a>
</li>

<li>Why don't people use LISP<br />
<a href="https://forums.freebsd.org/threads/why-dont-people-use-lisp.24572/">https://forums.freebsd.org/threads/why-dont-people-use-lisp.24572/</a>
</li>

<li>Structured program theorem<br />
<a href="https://en.wikipedia.org/wiki/Structured_program_theorem">https://en.wikipedia.org/wiki/Structured_program_theorem</a>
</li>

<li>Clojure: API Documentation<br />
<a href="https://clojure.org/api/api">https://clojure.org/api/api</a>
</li>

<li>Tutorial for the Common Lisp Loop Macro<br />
<a href="http://www.ai.sri.com/pkarp/loop.html">http://www.ai.sri.com/pkarp/loop.html</a>
</li>

<li>Common Lisp's Loop Macro Examples for Beginners<br />
<a href="http://www.unixuser.org/~euske/doc/cl/loop.html">http://www.unixuser.org/~euske/doc/cl/loop.html</a>
</li>

<li>A modern list api for Emacs. No 'cl required.<br />
<a href="https://github.com/magnars/dash.el">https://github.com/magnars/dash.el</a>
</li>

<li>The LOOP Facility<br />
<a href="http://www.lispworks.com/documentation/HyperSpec/Body/06_a.htm">http://www.lispworks.com/documentation/HyperSpec/Body/06_a.htm</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>Transient Data Structures
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Jazyky Hy a Clojure-py: moderní dialekty LISPu určené pro Python VM<br />
<a href="https://www.root.cz/clanky/jazyky-hy-a-clojure-py-moderni-dialekty-lispu-urcene-pro-python-vm/">https://www.root.cz/clanky/jazyky-hy-a-clojure-py-moderni-dialekty-lispu-urcene-pro-python-vm/</a>
</li>

<li>Pixie: lehký skriptovací jazyk s „kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

<li>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/">https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/</a>
</li>

<li>Stránka projektu Jython<br />
<a href="http://www.jython.org/">http://www.jython.org/</a>
</li>

<li>Jython (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Jython">https://en.wikipedia.org/wiki/Jython</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">https://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>JSR 223: Scripting for the Java<sup>TM</sup> Platform<br />
<a href="https://jcp.org/en/jsr/detail?id=223">https://jcp.org/en/jsr/detail?id=223</a>
</li>

<li>List of JVM languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_JVM_languages">https://en.wikipedia.org/wiki/List_of_JVM_languages</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

