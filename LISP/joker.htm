<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Jazyk Joker: dialekt Clojure naprogramovaný v Go</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Jazyk Joker: dialekt Clojure naprogramovaný v Go</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešní části seriálu o LISPovských programovacích jazycích se seznámíme se základními vlastnostmi programovacího jazyka pojmenovaného Joker, který používá stejný zápis programů, jako populární Clojure. Na rozdíl od Clojure je však Joker naprogramován v Go a jeho interpret startuje prakticky okamžitě.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyk Joker: dialekt Clojure naprogramovaný v&nbsp;Go</a></p>
<p><a href="#k02">2. Porovnání Jokeru s&nbsp;programovacím jazykem Clojure</a></p>
<p><a href="#k03">3. Instalace interpretru programovacího jazyka Joker</a></p>
<p><a href="#k04">4. Spuštění interaktivní smyčky REPL</a></p>
<p><a href="#k05">5. Spuštění skriptu</a></p>
<p><a href="#k06">6. Režim linteru</a></p>
<p><a href="#k07">7. Základní jazykové konstrukce podporované Jokerem</a></p>
<p><a href="#k08">8. Jmenné prostory</a></p>
<p><a href="#k09">9. Práce se seznamy</a></p>
<p><a href="#k10">10. Vektory</a></p>
<p><a href="#k11">11. Mapy</a></p>
<p><a href="#k12">12. Množiny</a></p>
<p><a href="#k13">13. Vliv použitého datového typu na funkci pro výpočet faktoriálu</a></p>
<p><a href="#k14">14. Výpočet konstanty Pi Wallisovým součinem: použití reálných čísel a zlomků</a></p>
<p><a href="#k15">15. Makro <strong>dotimes</strong></a></p>
<p><a href="#k16">16. Přímá rekurze</a></p>
<p><a href="#k17">17. Tail rekurze</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Literatura</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk Joker: dialekt Clojure naprogramovaný v&nbsp;Go</h2>

<p>V&nbsp;dnešní části seriálu o LISPovských programovacích jazycích se
seznámíme se základními vlastnostmi programovacího jazyka pojmenovaného
<i>Joker</i> [<a href="https://joker-lang.org/">1</a>]. Jedná se o jeden
z&nbsp;jazyků, které se snaží používat syntaxi i sémantiku podobnou či
v&nbsp;ideálním případě zcela shodnou s&nbsp;programovacím jazykem <a
href="https://www.root.cz/vyhledavani/?qs=clojure">Clojure</a>, který je (vedle
některých dialektů Scheme a Common LISPu) dnes pravděpodobně nejpopulárnějším
LISPovským programovacím jazykem, jenž se dokonce umisťuje i relativně vysoko
<a
href="https://madnight.github.io/githut/#/pull_requests/2019/2">v&nbsp;různých
statistikách</a> (na druhou stranu ovšem vypadl z&nbsp;první padesátky <a
href="https://www.tiobe.com/tiobe-index/">Tiobe indexu</a>. Ovšem zatímco jazyk
Clojure existuje ve třech variantách &ndash; pro JVM (překlad do bajtkódu), pro
CLR (taktéž překlad do bajtkódu) a pro interpretry JavaScriptu (<a
href="https://clojurescript.org/">ClojureScript</a>), je tomu v&nbsp;případě
jazyka Joker jinak, protože Joker je vyvinut <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">v&nbsp;programovacím
jazyku Go</a> a &ndash; alespoň prozatím &ndash; je implementován jako prostý
interpret, který neprovádí překlad do bajtkódu ani do nativního kódu.</p>

<p>Tento přístup má své přednosti, ale pochopitelně i některé zápory. Mezi
přednosti patří především velmi rychlý start interpretru, a to jak
v&nbsp;porovnání se samotným Clojure (pro JVM), tak i například
v&nbsp;porovnání s&nbsp;jazykem Racket, jemuž jsme se věnovali
v&nbsp;předchozích částech tohoto seriálu ([<a
href="https://www.root.cz/clanky/racket-programovaci-jazyk-a-soucasne-i-platforma-pro-vyvoj-novych-jazyku/">2</a>],
[<a
href="https://www.root.cz/clanky/makra-v-racketu-i-v-dalsich-lispovskych-jazycich/">3</a>],
[<a href="https://www.root.cz/clanky/zakladni-knihovna-jazyka-racket/">4</a>] a
[<a
href="https://www.root.cz/clanky/zakladni-knihovny-pro-2d-grafiku-v-jazyku-racket/">5</a>])
a k&nbsp;jehož popisu se ještě později vrátíme. Ovšem &bdquo;pouhá&ldquo;
interpretace kódu bez jeho (mezi)překladu a případných optimalizací má
negativní vliv na celkový výkon aplikace. Projeví se to zejména u složitějších
výpočtů popř.&nbsp;u zpracování rozsáhlejších datových struktur, nicméně pro
mnoho reálných aplikací by se nemuselo jednat o zásadní problém.</p>

<p>Další vlastnost jazyka Joker však může být užitečná i pro ty programátory,
kteří používají originální jazyk Clojure. Joker totiž umožňuje spustit
<i>linter</i>, který dokáže zkontrolovat korektnost zapsaného zdrojového kódu.
A díky tomu, že se linter spouští velmi rychle (pod sekundu), lze tento nástroj
použít i pro rychlou kontrolu zdrojových kódů aplikace psaných přímo
v&nbsp;Clojure. Spuštění interpretru Clojure je totiž naproti tomu mnohem
pomalejší a náročnější na systémové zdroje. Navíc je možné linter použít i pro
rychlou kontrolu souborů uložených ve formátu <i>EDN</i> (<i>Extensible Data
Notation</i>), který je taktéž založen na syntaxi programovacího jazyka
Clojure. Bližší informace o tomto formátu, s&nbsp;nímž se ve světě Clojure
relativně často setkáme, lze najít na stránce <a
href="https://github.com/edn-format/edn">https://github.com/edn-format/edn</a>.</p>

<p><div class="rs-tip-major">Poznámka: Joker není prvním programovacím jazykem
se syntaxí i sémantikou odvozenou od Clojure. Na stránkách Roota jsme se již
seznámili s&nbsp;podobně koncipovanými jazyky <i>Hy</i> a <i>Clojure-py</i> [<a
href="https://www.root.cz/clanky/jazyky-hy-a-clojure-py-moderni-dialekty-lispu-urcene-pro-python-vm/">7</a>],
které jsou vytvořeny v&nbsp;Pythonu a dobře tak spolupracují s&nbsp;aplikacemi
napsanými právě v&nbsp;tomto populárním jazyku.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Porovnání Jokeru s&nbsp;programovacím jazykem Clojure</h2>

<p>Programovací jazyk Joker se v&nbsp;některých ohledech od jazyka Clojure
odlišuje, což je však většinou pochopitelné, protože ne všechny vlastnosti JVM
popř.&nbsp;CLR je možné &bdquo;emulovat&ldquo; v&nbsp;interpretru, který
k&nbsp;těmto nástrojům nemá přístup. Některé vlastnosti Jokeru, například
nabídka primitivních datových typů, je přímo ovlivněna vlastnostmi
programovacího jazyka Go. Ovšem nejdůležitějším rozdílem (alespoň
v&nbsp;současné verzi Jokeru) je neexistence podpory pro souběžný běh několika
vláken, což je vlastnost podporovaná přímo v&nbsp;základech jazyka Clojure
&ndash; viz například <a
href="https://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">transakční
paměť</a>, <a
href="https://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/#k07">agenti</a>,
<a
href="https://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">pmap</a>
a <a
href="https://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">pcalls</a>,
<a
href="https://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/#k01">futures
a promise</a> atd. atd. Je to zajímavé, protože Joker má k&nbsp;dispozici
všechny prostředky jazyka Go, především gorutiny a kanály, takže by alespoň
nějakou podporu pro souběžné spouštění funkcí bylo možné naprogramovat. Možná
se dočkáme až v&nbsp;některé vyšší verzi tohoto jazyka. S&nbsp;dalšími rozdíly
mezi původním Clojure a Jokerem se postupně seznámíme v&nbsp;navazujícím
textu.</p>

<p><div class="rs-tip-major">Poznámka: jak jsme se již zmínili <a
href="#k01">v&nbsp;úvodní kapitole</a>, je interpret programovacího jazyka
Joker naprogramován v&nbsp;jazyku Go. To mj.&nbsp;znamená, že Joker s&nbsp;Go
(resp.&nbsp;s&nbsp;jeho ekosystémem) sdílí některé společné vlastnosti,
například velmi snadnou instalaci na počítačích koncových uživatelů (interpret
je dodáván jako jediný spustitelný soubor pouze s&nbsp;minimálními závislostmi
na operačním systému) a rychlé spuštění, což je pro každý prakticky použitelný
interpret důležitá vlastnost. Ovšem porovnáním samotného jazyka Go
s&nbsp;Clojure se v&nbsp;tomto článku nebudeme zabývat. Pokud vás tato
problematika zajímá, můžete si přečíst několik názorů na dané téma, které
naleznete například na stránkách:</div></p>

<ol>

<li>Clojure vs Go - Clash of the Titans!<br />
<a href="https://our.status.im/clojure-vs-go/">https://our.status.im/clojure-vs-go/</a>
</li>

<li>How do you see future of Clojure compared to Golang?<br />
<a href="https://www.reddit.com/r/Clojure/comments/5uftns/how_do_you_see_future_of_clojure_compared_to/">https://www.reddit.com/r/Clojure/comments/5uftns/how_do_you_see_future_of_clojure_compared_to/</a>
</li>

<li>Choosing your future tech stack: Clojure vs Elixir vs Go<br />
<a href="https://smashingboxes.com/blog/choosing-your-future-tech-stack-clojure-vs-elixir-vs-go/">https://smashingboxes.com/blog/choosing-your-future-tech-stack-clojure-vs-elixir-vs-go/</a>
</li>

<li>Imagine you have to select a programming language in 2019<br />
<a href="https://medium.com/@yuliaoletskaya/imagine-you-have-to-select-a-programming-language-in-2019-162ddcbb6cf">https://medium.com/@yuliaoletskaya/imagine-you-have-to-select-a-programming-language-in-2019-162ddcbb6cf</a>
</li>

</ol>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti se oblasti nasazení obou
jazyků sice překrývají, ale v&nbsp;relativně malé oblasti, takže se většinou
nejedná o přímé konkurenty.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Instalace interpretru programovacího jazyka Joker</h2>

<p>Programovací jazyk Joker s&nbsp;poměrně velkou pravděpodobností nenaleznete
v&nbsp;oficiálních repositářích vaší distribuce, takže je nutné instalaci
provést odlišným způsobem. Archivy s&nbsp;binárním (spustitelným) souborem
obsahujícím interpret jazyka Joker i jeho základní knihovny (vše v&nbsp;jednom
binárním spustitelném souboru) jsou umístěny na adrese <a
href="https://github.com/candid82/joker/releases/tag/v0.12.7">https://github.com/candid82/joker/releases/tag/v0.12.7</a>
(tabulka s&nbsp;archivy je zobrazena na konci stránky). Stažení archivu
určeného pro 64bitovou platformu (x86-64) s&nbsp;Linuxem je tudíž velmi
snadné:</p>

<pre>
$ <strong>wget https://github.com/candid82/joker/releases/download/v0.12.7/joker-0.12.7-linux-amd64.zip</strong>
</pre>

<p>Po rozbalení staženého archivu postačuje interpret (představovaný souborem
<strong>joker</strong>) umístit do některého adresáře, na který ukazuje
proměnná prostředí <strong>PATH</strong> (může se jednat například o
<strong>/usr/local/bin</strong>, <strong>~/bin</strong> atd.&nbsp;podle
konkrétního uživatelského nastavení):</p>

<pre>
$ <strong>unzip joker-0.12.7-linux-amd64.zip</strong>
$ <strong>mv joker ~/bin</strong>
</pre>

<p>V&nbsp;případě, že preferujete vlastní překlad interpretru, musíte mít
nainstalovány standardní nástroje programovacího jazyka Go dostupné přímo
v&nbsp;repositáři vaší distribuce, popř.&nbsp;nabízené na stránce <a
href="https://golang.org/dl/">https://golang.org/dl/</a>. Po instalaci jazyka
Go je nutné provést nastavení proměnné prostředí <strong>GOPATH</strong>, což
je problematika, kterou jsme se podrobněji věnovali <a
href="https://www.root.cz/clanky/go-minimalisticky-a-prekvapive-vykonny-programovaci-jazyk/#k05">v&nbsp;úvodním
článku</a>, který zahájil <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">paralelně běžící
seriál o Go</a>. Samotný překlad se provede těmito pomocí kroků popsaných
v&nbsp;následujících odstavcích.</p>

<p><div class="rs-tip-major">Poznámka: pro úspěšný překlad projektu Joker je
nezbytně nutné mít nainstalován jazyk Go verze 1.12 nebo 1.13. V&nbsp;některých
Linuxových distribucích se stále nabízí Go 1.11 (možná dokonce i Go 1.10),
ovšem tato verze programovacího jazyka Go neobsahuje ve svých standardních
knihovnách všechny potřebné funkce a metody. Z&nbsp;tohoto důvodu nebude
překlad úspěšný.</div></p>

<p>Samotný proces překladu Jokeru není příliš složitý ani zdlouhavý:</p>

<p>Před vlastním překladem nejdříve získáme zdrojové kódy, a to s&nbsp;využitím
příkazu <strong>go get</strong>:</p>

<pre>
$ <strong>go get -d github.com/candid82/joker</strong>
</pre>

<p>Následně přejdeme do adresáře, který se předchozím příkazem vytvořil a
naplnil zdrojovými kódy:</p>

<pre>
$ <strong>cd $GOPATH/src/github.com/candid82/joker</strong>
</pre>

<p>Překlad spustíme přes skript <strong>run.sh</strong> a standardním příkazem
<strong>go install</strong>:</p>

<pre>
$ <strong>./run.sh --version &amp;&amp; go install</strong>
</pre>

<p>Výsledkem překladu by měl být spustitelný binární soubor o velikosti
přibližně 15 MB. Jedná se o poměrně značnou velikost, což je způsobeno tím, že
aplikace vytvořené v&nbsp;Go jsou překládány a linkovány se všemi knihovnami,
včetně knihovny pro automatickou správu paměti (GC) apod.:</p>

<pre>
$ <strong>ls -l joker </strong>
-rwxr-xr-x 1 tester tester 15248928 zář  3 06:53 joker
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Spuštění interaktivní smyčky REPL</h2>

<p>Po (doufejme že bezproblémovém a úspěšném) překladu a instalaci
programovacího jazyka Joker si můžeme vyzkoušet spustit interaktivní smyčku
REPL, kterou je tento jazyk &ndash; ostatně jako každý správný jazyk patřící do
LISPovské rodiny &ndash; vybaven. V&nbsp;případě, že binární soubor
s&nbsp;interpretrem leží v&nbsp;nějakém adresáři umístěném do proměnné
prostředí <strong>PATH</strong>, je spuštění REPLu snadné a navíc prakticky
okamžité:</p>

<pre>
$ <strong>./joker</strong>
Welcome to joker v0.12.7. Use EOF (Ctrl-D) or SIGINT (Ctrl-C) to exit.
</pre>

<p>Alternativně (pokud byl překlad proveden uživatelem ze zdrojových kódů):</p>

<pre>
$ <strong>$GOPATH/bin/joker</strong>
Welcome to joker v0.12.7. Use EOF (Ctrl-D) or SIGINT (Ctrl-C) to exit.
</pre>

<p>Pod uvítací zprávou se zobrazí výzva (<i>prompt</i>), která jako by
z&nbsp;oka vypadla výzvě známé z&nbsp;programovacího jazyka Clojure:</p>

<pre>
user=&gt;
</pre>

<p><div class="rs-tip-major">Poznámka: pokud máte na svém systému nainstalován
i programovací jazyk Clojure, popř.&nbsp;doplněný o nástroj <a
href="https://github.com/technomancy/leiningen">Leiningen</a>, můžete si sami
porovnat, jak rychlé je spuštění interaktivní smyčky REPL jazyka Joker a
podobně koncipované interaktivní smyčky REPL, tentokrát pro jazyk
Clojure:</div></p>

<pre>
$ <strong>lein repl</strong>
</pre>

<p>Ve druhém případě trvá spuštění REPLu cca pět sekund i na poměrně rychlém
stroji s&nbsp;mikroprocesorem i7 taktovaným na 2,9 GHz, ovšem na pomalejších
počítačích může spuštění interaktivní smyčky REPL trvat i více než deset
sekund, což je (například pro rychlé otestování nějaké myšlenky) poměrně
nepříjemné zdržení. Naproti tomu se interpret jazyka Joker spustí i na
pomalejších počítačích takřka okamžitě, takže se skutečně jedná o výborný
doplněk ke Clojure určený například k&nbsp;rychlému otestování nových nápadů
apod.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Spuštění skriptu</h2>

<p>Kromě přímého přechodu do interaktivní smyčky REPL je možné spustit nějaký
skript naprogramovaný v&nbsp;jazyce Joker. Spuštění skriptu je snadné a
přímočaré:</p>

<pre>
$ <strong>joker jméno_skriptu</strong>
</pre>

<p>Skripty vytvořené v&nbsp;jazyce Joker by měly mít koncovku
<strong>.joker</strong>, ovšem bez problémů lze použít i koncovku
<strong>.clj</strong>, která může být výhodnější; už jen z&nbsp;toho důvodu, že
tuto koncovku rozpoznávají mnohé programátorské textové editory.</p>

<p><div class="rs-tip-major">Poznámka: i z&nbsp;tohoto důvodu budou všechny
dnešní zdrojové kódy demonstračních příkladů uloženy do souborů
s&nbsp;koncovkou <strong>.clj</strong>. Tyto zdrojové soubory naleznete na
adrese <a
href="https://github.com/tisnik/lisp-families/tree/master/joker">https://github.com/tisnik/lisp-families/tree/master/joker</a>.</div></p>

<p>Příklad spuštění skriptu pro výpočet hodnoty Pi:</p>

<pre>
$ <strong>./joker pi_1.clj </strong>
&nbsp;
1       4.000000
2       3.555556
4       3.413333
8       3.302394
16      3.230036
32      3.188127
64      3.165482
128     3.153699
256     3.147687
512     3.144650
1024    3.143124
2048    3.142359
4096    3.141976
8192    3.141784
16384   3.141689
32768   3.141641
65536   3.141617
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Režim linteru</h2>

<p>Jak jsme si již řekli <a href="#k01">v&nbsp;úvodní kapitole</a>, je možné
interpret programovacího jazyka Joker přepnout do režimu <i>linteru</i>,
v&nbsp;němž se provádí kontrola zdrojového kódu (či dat), ovšem bez jeho
spuštění. Základní varianta příkazu vypadá takto:</p>

<pre>
$ <strong>joker --lint jméno_skriptu</strong>
</pre>

<p>Ve skutečnosti je ještě možné přesně specifikovat dialekt určující, jaký
zdrojový kód je očekáván na vstupu:</p>

<pre>
$ <strong>joker --lint --dialect dialekt jméno_skriptu</strong>
</pre>

<p>Mezi podporované dialekty patří:</p>

<table>
<tr><th>#</th><th>Volba <strong>--dialect</strong></th><th>Význam</th></tr>
<tr><td>1</td><td>clj</td><td>zdrojový soubor určený pro Clojure</td></tr>
<tr><td>2</td><td>cljs</td><td>zdrojový soubor určený pro ClojureScript</td></tr>
<tr><td>3</td><td>joker</td><td>zdrojový soubor určený pro Joker</td></tr>
<tr><td>4</td><td>edn</td><td>soubor ve formátu EDN (Extensible Data Notation)</td></tr>
</table>

<p>Příklad výstupu linteru:</p>

<pre>
raster_renderer.clj:177:21: Parse warning: Wrong number of args (7) passed to graph-generator.raster-renderer/draw-line
raster_renderer.clj:178:21: Parse warning: Wrong number of args (7) passed to graph-generator.raster-renderer/draw-circle
raster_renderer.clj:179:21: Parse warning: Wrong number of args (7) passed to graph-generator.raster-renderer/draw-arc
raster_renderer.clj:180:21: Parse warning: Wrong number of args (7) passed to graph-generator.raster-renderer/draw-text
raster_renderer.clj:174:13: Parse warning: unused binding: i
raster_renderer.clj:303:13: Parse warning: unused binding: i
raster_renderer.clj:432:19: Parse warning: unused binding: bounds
raster_renderer.clj:771:11: Parse warning: unused binding: room-id
raster_renderer.clj:29:12: Parse warning: unused namespace graph-generator.db-interface
</pre>

<p><div class="rs-tip-major">Poznámka: kupodivu se na tyto chyby dříve
nepřišlo, mj.&nbsp;i proto, že se jednalo o netestovanou a nenasazovanou část
zdrojového kódu. Interpret Clojure tyto kontroly bez dalších nástrojů
neprovádí.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Základní jazykové konstrukce podporované Jokerem</h2>

<p>V&nbsp;této kapitole se zmíníme o základních konceptech, na nichž je jazyk
Joker postaven. Samotný popis jednotlivých konstrukcí bude poměrně stručný, a
to z&nbsp;toho důvodu, že se Joker v&nbsp;mnoha ohledech podobá programovacímu
jazyku Clojure, kterému jsme se na stránkách Rootu <a
href="https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/#k19">zevrubně
věnovali</a>.</p>

<p>Nejprve se ve stručnosti zmíníme o primitivních datových typech. Ty jsou
v&nbsp;Jokeru podobné, jako je tomu v&nbsp;Go, ovšem konkrétní implementace (a
někdy i chování) se může nepatrně odlišovat:</p>

<pre>
<i>; hodnota nil použitelná i v logických výrazech</i>
user=&gt; <strong>nil</strong>
nil
&nbsp;
<i>; celočíselný typ int v Go</i>
user=&gt; <strong>42</strong>
42
&nbsp;
<i>; je možné použít i hexadecimální zápis celých hodnot</i>
user=&gt; <strong>0x2a</strong>
42
&nbsp;
<i>; Joker podporuje zlomky (typ ratio) s prakticky neomezeným rozsahem hodnot čitatele i jmenovatele</i>
user=&gt; <strong>1/3</strong>
1/3
&nbsp;
<i>; a samozřejmě i čísla s plovoucí řádovou čárkou (typ float64)</i>
user=&gt; <strong>3.1415</strong>
3.1415
&nbsp;
<i>; řetězce</i>
user=&gt; <strong>"foo bar baz"</strong>
"foo bar baz"
&nbsp;
<i>; funkce count pracuje korektně i s Unicode řetězci</i>
user&gt; <strong>(count "abcde")</strong>
5
user&gt; <strong>(count "ěščřž")</strong>
5
<i>; symboly</i>
user=&gt; <strong>:foo-bar-baz</strong>
:foo-bar-baz
</pre>

<p>Zapomenout nesmíme ani na celočíselný typ bez omezení rozsahu
reprezentovatelných hodnot. Interně je tento typ implementován pomocí balíčku
<strong>big.Int</strong>:</p>

<pre>
user=&gt; <strong>1N</strong>
1N
</pre>

<p>Nechybí ani numerický typ s&nbsp;plovoucí řádovou čárkou a prakticky
nekonečným rozsahem popř.&nbsp;přesností. Zde se používá postfixový znak
<strong>M</strong> a interně je tento typ implementován pomocí balíčku
<strong>big.Float</strong>:</p>

<pre>
user=&gt; <strong>1M</strong>
1M
&nbsp;
user=&gt; <strong>1.5e100M</strong>
1.5e+100M
</pre>

<p>Dále si v&nbsp;této kapitole ukažme základní volání funkce:</p>

<pre>
user=&gt; <strong>(println "Hello world")</strong>
Hello world
nil
</pre>

<p>Důležitá je i speciální forma nazvaná <strong>def</strong>. Ta se většinou
používá k&nbsp;navázání libovolné hodnoty (například čísla, pravdivostní
hodnoty, řetězce, seznamu a jak uvidíme dále, tak i funkce) na symbol. Méně
časté je použití této speciální formy k&nbsp;pouhému vytvoření symbolu.
V&nbsp;případě, že Joker vyhodnotí (&bdquo;spustí&ldquo;) tuto speciální formu,
dojde k&nbsp;vytvoření nové globální proměnné v&nbsp;aktuálně nastaveném
jmenném prostoru (nejde tedy o skutečnou globální proměnnou, ale o proměnnou
identifikovatelnou přes jmenný prostor &ndash; viz další text) a
k&nbsp;inicializaci této proměnné. Pokud již globální proměnná stejného jména
existuje, dojde k&nbsp;&bdquo;přepisu&ldquo; její hodnoty. Ve skutečnosti však
stará hodnota nemusí přestat existovat, protože může být navázána na další
proměnné:</p> 

<pre>
user=&gt; <strong>(def x (range 10))</strong>
#'user/x
</pre>

<p>Vyhodnocení hodnoty navázané na symbol:</p>

<pre>
user=&gt; <strong>x</strong>
(0 1 2 3 4 5 6 7 8 9)
</pre>

<p>Nepatrně složitější příklad:</p>

<pre>
user&gt; <strong>(def x 6)</strong>
#'user/x
&nbsp; 
user&gt; <strong>(def y 7)</strong>
#'user/y
 &nbsp; 
user&gt; <strong>(def answer (* x y))</strong>
#'user/answer
&nbsp; 
user&gt; <strong>answer</strong>
42
</pre>

<p>Ke globální proměnné lze přiřadit i takzvaný dokumentační řetězec a ten
následně získat makrem <strong>doc</strong>:</p>

<pre>
user&gt; <strong>(def answer "Odpoved na otazku o ... vesmiru, zivote a vubec" 42)</strong>
#'user/answer
&nbsp;
user&gt; <strong>(doc answer)</strong>
-------------------------
user/answer
  Odpoved na otazku o ... vesmiru, zivote a vubec
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Jmenné prostory</h2>

<p><a href="#k07">V&nbsp;předchozí kapitole</a> jsme se poprvé explicitně
zmínili o takzvaných <i>jmenných prostorech</i>. Jmenné prostory byly do
programovacího jazyka Joker (resp.&nbsp;do Clojure a potom do Jokeru) přidány
zejména z&nbsp;toho důvodu, že použití globálních symbolů je v&nbsp;reálných
programech velmi nebezpečné a to zejména proto, že jiná část programu, která
může být klidně vytvořena i jiným vývojářem, může nechtěně předeklarovat již
existující globální symbol. Co je ještě horší &ndash; tato předeklarace nemusí
nutně vést k&nbsp;okamžité chybě při práci s&nbsp;programem (ideálně při jeho
testování), ale může se projevit až při určité shodě okolností &ndash; podle
všeobecně platného zákona tedy ve chvíli, kdy se aplikace předvádí šéfovi či
zákazníkovi :-). Připomeňme si, že mezi globální symboly patří i symboly
představující jména funkcí, takže je asi představitelné, co by se stalo, kdyby
nějaká importovaná knihovna náhodou obsahovala funkci pojmenovanou stejně, jako
funkce vytvořená programátorem vyvíjené aplikace. Jmenné prostory proto
představují jeden z&nbsp;možných způsobů, jak tento problém poměrně elegantně
vyřešit (i když práce s&nbsp;nimi není vždy jednoduchá).</p>

<p>My jsme se již vlastně s&nbsp;jedním jmenným prostorem setkali
v&nbsp;textech vypisovaných smyčkou <i>REPL</i>, i když jsme si prozatím
nevysvětlili, že se skutečně jedná o jmenný symbol. Při používání smyčky REPL
je totiž jméno aktuálního jmenného prostoru vypisováno jako součást <i>výzvy
(prompt)</i>:</p>

<pre>
user=&gt;
</pre>

<p>V&nbsp;programovacím jazyku Joker je možné vytvořit takřka libovolný počet
jmenných prostorů a posléze se mezi těmito jmennými prostory přepínat,
tj.&nbsp;lze zvolit, který jmenný prostor bude jmenným prostorem aktuálním. Pro
tuto činnost se používá makro nazvané <strong>ns</strong>:</p>

<pre>
<strong>(ns název_jmenného_prostoru)</strong>
</pre>

<p>Podívejme se nyní na jednoduchý demonstrační příklad, v&nbsp;němž jsou
vytvořeny dvě globální proměnné nazvané <strong>answer</strong>. Každé proměnné
je přiřazena jiná hodnota a každá proměnná tudíž musí být uložena v&nbsp;jiném
jmenném prostoru. Povšimněte si taktéž toho, jak se změní výzva (prompt) při
přepnutí aktuálního jmenného prostoru:</p>

<pre>
<i>; vytvoření globální proměnné umístěné ve jmenném prostoru "user"</i>
user=&gt; <strong>(def answer 42)</strong>
#'user/answer
&nbsp;
<i>; jméno proměnné se vyhodnotí na hodnotu proměnné</i>
user=&gt; <strong>answer</strong>
42
&nbsp;
<i>; vytvoření nového jmenného prostoru nazvaného "novy"</i>
user=&gt; <strong>(ns novy)</strong>
nil
&nbsp;
<i>; lze v tomto jmenném prostoru vyhodnotit (=najít) proměnnou answer?</i>
novy=&gt; <strong>answer</strong>
CompilerException java.lang.RuntimeException: Unable to resolve symbol: answer
in this context, compiling:(NO_SOURCE_PATH:0)
&nbsp;
<i>; vytvoření nové globální proměnné ve jmenném prostoru "novy"</i>
novy=&gt; <strong>(def answer "?")</strong>
#'novy/answer
&nbsp;
<i>; její hodnotu nyní můžeme získat (vyhodnotit), aniž by došlo k chybě</i>
novy=&gt; <strong>answer</strong>
"?"
&nbsp;
<i>; přepnutí jmenného prostoru</i>
novy=&gt; <strong>(ns user)</strong>
nil
&nbsp;
<i>; nyní je opět viditelná první globální proměnná se jménem answer</i>
user=&gt; <strong>answer</strong>
42
</pre>

<p>Ve skutečnosti však nejsou jednotlivé jmenné prostory od sebe izolovány,
takže se můžeme odkazovat na symbol umístěný v&nbsp;jiném jmenném prostoru
pomocí zápisu <strong>jmenný_prostor/symbol</strong>. Ostatně i kvůli podpoře
tohoto způsobu zápisu není možné použít znak / ve jméně žádného symbolu (znaky
* či - je však možné použít, což se taktéž často děje, protože - se používá pro
oddělení jednotlivých slov v&nbsp;názvu symbolu a hvězdička je podle konvencí
používána pro konstanty). Podívejme se nyní na způsob využití zápisu
<strong>jmenný_prostor/symbol</strong>:</p>

<pre>
<i>; přepnutí jmenného prostoru</i>
user=&gt; <strong>(ns user)</strong>
nil
&nbsp;
<i>; proměnná z aktuálního jmenného prostoru</i>
user=&gt; <strong>answer</strong>
42
&nbsp;
<i>; proměnná z jiného jmenného prostoru</i>
user=&gt; <strong>novy/answer</strong>
"?"
&nbsp;
<i>; přepnutí jmenného prostoru</i>
user=&gt; <strong>(ns novy)</strong>
nil
&nbsp;
<i>; proměnná z aktuálního jmenného prostoru</i>
novy=&gt; <strong>answer</strong>
"?"
&nbsp;
<i>; proměnná z aktuálního jmenného prostoru</i>
novy=&gt; <strong>novy/answer</strong>
"?"
&nbsp;
<i>; proměnná z jiného jmenného prostoru</i>
novy=&gt; <strong>user/answer</strong>
42
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Práce se seznamy</h2>

<p>Programovací jazyk <i>Joker</i> podporuje všechny základní strukturované
datové typy, které známe z&nbsp;jazyka Clojure. Jedná se o seznamy, vektory,
mapy i množiny:</p>

<table>
<tr><th>#</th><th>Typ kolekce</th><th>Zápis konstruktoru</th></tr>
<tr><td>1</td><td>Seznam</td><td>'(prvky)</td></tr>
<tr><td>2</td><td>Vektor</td><td>[prvky]</td></tr>
<tr><td>3</td><td>Mapa</td><td>{dvojice klíč-hodnota}</td></tr>
<tr><td>4</td><td>Množina</td><td>#{unikátní prvky}</td></tr>
</table>

<p>Základním strukturovaným datovým typem každého LISPovského programovacího
jazyka jsou nepochybně seznamy (<i>list</i>). Jejich zpracování je
v&nbsp;jazyku Joker podobné jako v&nbsp;Clojure &ndash; prvky seznamů se
zapisují do kulatých závorek, což je ovšem stejná syntaxe, jako zápis volání
funkce. Aby se seznam nevyhodnocoval jako funkce (tedy aby první prvek seznamu
nebyl chápán jako jméno funkce), je nutné před jeho deklaraci zapsat znak '
(apostrof) nebo použít speciální formu <strong>quote</strong>.</p>

<p>Pochopitelně je podporován i koncept prázdného seznamu, který se zapisuje ve
formě prázdného páru kulatých závorek:</p>

<pre>
<i>; prázdný seznam</i>
user=&gt; <strong>'()</strong>
()
&nbsp;
<i>; prázdný seznam</i>
user=&gt; <strong>(quote ())</strong>
()
</pre>

<p>Seznam obsahující čtveřici numerických hodnot se vytvoří následujícím
způsobem:</p>

<pre>
<i>; seznam čísel</i>
user=&gt; <strong>'(1 2 3 4)</strong>
(1 2 3 4)
&nbsp;
<i>; seznam čísel</i>
user=&gt; <strong>(quote (1 2 3 4))</strong>
(1 2 3 4)
</pre>

<p>Seznam obsahující trojici řetězců vytvoříme naprosto stejným postupem:</p>

<pre>
<i>; seznam řetězců</i>
user=&gt; <strong>'("prvni" "druhy" "treti")</strong>
("prvni" "druhy" "treti")
</pre>

<p>Poměrně často se setkáme s&nbsp;použitím <i>keywords</i>, které jsou určeny
pro reprezentaci neměnných a současně i unikátních hodnot (unikátních
v&nbsp;rámci celého programu popř.&nbsp;jmenných prostorů):</p>

<pre>
<i>; seznam "keywords"</i>
user=&gt; <strong>'(:prvni :druhy :treti)</strong>
(:prvni :druhy :treti)
&nbsp;
user=&gt; <strong>(quote (:foo :bar :baz))</strong>
(:foo :bar :baz)
</pre>

<p>Dále je pochopitelně možné do seznamů ukládat proměnné, jejichž hodnota však
není vyhodnocována. To je ostatně logické, protože není vyhodnocen ani samotný
seznam a pravidla pro vyhodnocení jsou v&nbsp;LISPovských jazycích jednoduchá
(až na makra, která naopak takové vyhodnocení umožňují):</p>

<pre>
user=&gt; <strong>(def positionX 1)</strong>
#'user/positionX
&nbsp;
user=&gt; <strong>(def positionY 2)</strong>
#'user/positionY
&nbsp;
user=&gt; <strong>(def positionZ 3)</strong>
#'user/positionZ
</pre>

<p>Vytvoření seznamu, v&nbsp;němž jsou uloženy proměnné:</p>

<pre>
<i>; seznam s proměnnými</i>
user=&gt; <strong>'(positionX positionY positionZ)</strong>
(positionX positionY positionZ)
</pre>

<p>Ukažme si ještě několik příkladů vnořených seznamů:</p>

<pre>
<i>; vnořené seznamy</i>
user=&gt; <strong>'( '(:x :y) '(:z :w) )</strong>
((quote (:x :y)) (quote (:z :w)))
</pre>

<p>Díky tomu, že se nevyhodnocuje už vnější seznam, můžeme použít i následující
zápis (který však není ekvivalentní s&nbsp;předchozím zápisem &ndash; výsledkem
je odlišná datová struktura):</p>

<pre>
<i>; vnořené seznamy</i>
user=&gt; <strong>'( '(:x :y) '(:z :w) )</strong>
((:x :y) (:z :w))
</pre>

<p>Délka seznamu:</p>

<pre>
user&gt; <strong>(count '(1 2 3 4))</strong>
4
</pre>

<p>Zploštění seznamu je další relativně často používaná operace:</p>

<pre>
user&gt; <strong>(flatten '( (:x :y) (:z :w) ))</strong>
(:x :y :z :w)
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Vektory</h2>

<p>Další důležitou datovou strukturou, která je převzata z&nbsp;programovacího
jazyka Clojure, jsou vektory (<i>vectors</i>). Prvky vektorů se zapisují do
hranatých závorek a vzhledem k&nbsp;tomu, že se jedná o zápis odlišný od volání
funkce (na rozdíl od seznamů), není nutné před vektor psát ani apostrof ani
speciální formu <strong>quote</strong>. Prázdný vektor se zapíše takto:</p>

<pre>
<i>; prázdný vektor</i>
user=&gt; <strong>[]</strong>
[]
</pre>

<p>Vektor se čtveřicí celočíselných hodnot můžeme zapsat následovně:</p>

<pre>
<i>; vektor čísel</i>
user=&gt; <strong>[1 2 3 4]</strong>
[1 2 3 4]
</pre>

<p>Pochopitelně nám nic nebrání si vytvořit vektor z řetězců</p>

<pre>
<i>; vektor řetězců</i>
user=&gt; <strong>["prvni" "druhy" "treti"]</strong>
["prvni" "druhy" "treti"]
</pre>

<p>Vektor obsahující &bdquo;keywords&ldquo;:</p>

<pre>
<i>; vektor "keywords"</i>
user=&gt; <strong>[:prvni :druhy :treti]</strong>
[:prvni :druhy :treti]
</pre>

<p>A pochopitelně i vektor proměnných:</p>

<pre>
user=&gt; <strong>(def positionX 1)</strong>
#'user/positionX
&nbsp;
user=&gt; <strong>(def positionY 2)</strong>
#'user/positionY
&nbsp;
user=&gt; <strong>(def positionZ 3)</strong>
#'user/positionZ
&nbsp;
<i>; vektor proměnných</i>
user=&gt; <strong>[positionX positionY positionZ]</strong>
[1 2 3]
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se proměnné
vyhodnotily na svoje hodnoty.</div></p>

<p>Další často vyžadované operace se seznamy:</p>

<pre>
<i>; zploštění vektorů (výsledkem je seznam!)</i>
user&gt; <strong>(flatten [[:x :y] [:z :w]])</strong>
(:x :y :z :w)
&nbsp;
<i>; přístup k prvku vektoru</i>
user&gt; <strong>(nth [1 2 3 4] 2)</strong>
3
&nbsp;
<i>; neexistující prvek</i>
user&gt; <strong>(nth [1 2 3 4] 10)</strong>
&lt;joker.core&gt;:693:25: Eval error: Index 10 is out of bounds [0..3]
Stacktrace:
  global &lt;/gcrepl&gt;/gc:26:1
  core/nth &lt;/gcjoker.core&gt;/gc:693:25
&nbsp;
<i>; přístup k prvku vektoru bez rizika vzniku chyb</i>
user&gt; <strong>(get [1 2 3 4] 2)</strong>
3
&nbsp;
<i>; neexistující prvek</i>
user&gt; <strong>(get [1 2 3 4] 10)</strong>
nil
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Mapy</h2>

<p>Mapa, popř.&nbsp;též asociativní pole, se v&nbsp;reálných aplikacích používá
poměrně často a existuje pro ni i speciální konstrukce spočívající
v&nbsp;použití složených závorek, do nichž se zapíšou dvojice klíč-hodnota:</p>

<pre>
<i>; prázdná mapa</i>
user=&gt; <strong>{}</strong>
{}
</pre>

<p>Mapa s&nbsp;řetězci:</p>

<pre>
<i>; mapování typu string-string</i>
user=&gt; <strong>{"prvni" "first" "druhy" "second" "treti" "third"}</strong>
{"prvni" "first", "druhy" "second", "treti" "third"}
</pre>

<p>Lze použít i čárky, které zajistí větší čitelnost (je zřejmé, kde končí
která dvojice:)</p>

<pre>
<i>; mapování typu string-string</i>
user=&gt; <strong>{"prvni" "first", "druhy" "second", "treti" "third"}</strong>
{"prvni" "first", "druhy" "second", "treti" "third"}
</pre>

<p>Dále je vhodné si uvědomit, že prvky mapy jsou nejdříve vyhodnoceny:</p>

<pre>
<i>; mapa s vyhodnocením proměnných</i>
user=&gt; <strong>{"X" positionX "y" positionY "z" positionZ}</strong>
{"X" 1, "y" 2, "z" 3}
</pre>

<p>Převod vektorů/seznamů klíčů a vektorů/seznamů hodnot na mapu:</p>

<pre>
<i>; stejný počet klíčů i hodnot</i>
user&gt; <strong>(zipmap [1 2 3 4] [5 6 7 8])</strong>
{1 5, 2 6, 3 7, 4 8}
&nbsp;
<i>; větší počet hodnot</i>
user&gt; <strong>(zipmap [1 2 3 4] [5 6 7 8 9 0])</strong>
{1 5, 2 6, 3 7, 4 8}
</pre>

<p>Přístup k&nbsp;hodnotám uloženým v&nbsp;mapě:</p>

<pre>
user&gt; <strong>(def slova {"prvni" "first", "druhy" "second", "treti" "third"})</strong>
#'user/slova
&nbsp;
user&gt; <strong>(get slova "prvni")</strong>
"first"
&nbsp;
user&gt; <strong>(get slova "foobar")</strong>
nil
</pre>

<p>Test na existenci prvku (podle klíče):</p>

<pre>
user&gt; <strong>(def slova {"prvni" "first", "druhy" "second", "treti" "third"})</strong>
#'user/slova
&nbsp;
user&gt; <strong>(contains? slova "prvni")</strong>
true
&nbsp;
user&gt; <strong>(contains? slova "foobar")</strong>
false
</pre>

<p>Výběr většího množství prvků:</p>

<pre>
user&gt; <strong>(select-keys slova ["prvni" "treti"])</strong>
{"prvni" "first", "treti" "third"}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Množiny</h2>

<p>V&nbsp;jazyku Joker lze pochopitelně pracovat i s&nbsp;množinami. Ty se
vytváří konstruktorem #{}:</p>

<pre>
<i>; Množina</i>
user=&gt; <strong>#{"prvni" "druhy" "treti"}</strong>
#{"prvni" "druhy" "treti"}
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti nemusí být prvky
v&nbsp;množině vypsány ve stejném pořadí, jak do ní byly vloženy, interně se
totiž používá hešovací tabulka).</div></p>

<p>Prvky v&nbsp;množině nesmí být duplikátní!</p>

<p>Kontrolují se samozřejmě shodné hodnoty literálů:</p>

<pre>
user=&gt; <strong>#{1 1 3}</strong>
Read error: Duplicate set element 1
</pre>

<p>Řetězce jsou, jak již víme, taktéž literály (zde je duplikován řetězec
&bdquo;nesmi&ldquo;):</p>

<pre>
user=&gt; <strong>#{"nesmi" "mit" "dva" "stejne" "prvky" "skutecne" "nesmi"}</strong>
Read error: Duplicate set element nesmi
</pre>

<p><i>Joker</i> poctivě zkontroluje i ekvivalenci seznamů atd.:</p>

<pre>
user=&gt; <strong>#{ '(:stejny :seznam) '(:stejny :seznam) }</strong>
Read error: Duplicate set element (quote (:stejny :seznam))
</pre>

<p><div class="rs-tip-major">Poznámka: zde můžeme vidět odlišnost od jazyka
Clojure &ndash; chybové zprávy Jokeru jsou většinou kratší a současně i
specifičtější, než je tomu v&nbsp;Clojure:</div></p>

<pre>
user=&gt; <strong>#{1 1 3}</strong>
IllegalArgumentException Duplicate key: 1  clojure.lang.PersistentHashSet.create
WithCheck (PersistentHashSet.java:68)
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Vliv použitého datového typu na funkci pro výpočet faktoriálu</h2>

<p><a href="#k07">V&nbsp;sedmé kapitole</a> jsme se mj.&nbsp;zmínili o tom, že
v&nbsp;jazyku Joker existuje hned několik datových typů určených pro
reprezentaci numerických hodnot. Nyní si ukážeme, jaký vliv má zvolený datový
typ na některé výpočty. Připomeňme si deklaraci funkce pro výpočet faktoriálu.
Její zkrácená varianta zapsatelná na jediný řádek využívá funkci vyššího řádu
<strong>reduce</strong> a generátor sekvence <strong>range</strong>. Všechny
výpočty přitom probíhají s&nbsp;využitím datového typu &bdquo;celé
číslo&ldquo;, který má ovšem omezený rozsah hodnot, což se projeví na výpočtu,
přesněji řečeno na jeho výsledcích (interně se používá Go typ
<strong>int</strong>):</p>

<pre>
user=&gt; <strong>(defn factorial [n] (reduce * (range 1 (inc n))))</strong>
#'user/factorial
</pre>

<p>Výpočet faktoriálu si můžeme ověřit například tak, že se pokusíme vypočítat
výsledky pro hodnoty 0! až 29!. V&nbsp;oboru celých čísel ovšem výsledky
nevypadají příliš korektně:</p>

<pre>
user=&gt; <strong>(doseq [n (range 0 30)] (println n (factorial n)))</strong>
0 1
1 1
2 2
3 6
4 24
5 120
6 720
7 5040
8 40320
9 362880
10 3628800
11 39916800
12 479001600
13 6227020800
14 87178291200
15 1307674368000
16 20922789888000
17 355687428096000
18 6402373705728000
19 121645100408832000
20 2432902008176640000
21 -4249290049419214848
22 -1250660718674968576
23 8128291617894825984
24 -7835185981329244160
25 7034535277573963776
26 -1569523520172457984
27 -5483646897237262336
28 -5968160532966932480
29 -7055958792655077376
</pre>

<p>Lepšího výsledku dosáhneme při použití čísel s&nbsp;plovoucí řádovou čárkou
(interně typ <strong>float64</strong>):</p>

<pre>
user&gt; <strong>(defn factorial [n] (reduce * (range 1.0 (inc n))))</strong>
#'user/factorial
&nbsp;
user&gt; <strong>(doseq [n (range 0 30)] (println n (factorial n)))</strong>
0 1
1 1
2 2
3 6
4 24
5 120
6 720
7 5040
8 40320
9 362880
10 3.6288e+06
11 3.99168e+07
12 4.790016e+08
13 6.2270208e+09
14 8.71782912e+10
15 1.307674368e+12
16 2.0922789888e+13
17 3.55687428096e+14
18 6.402373705728e+15
19 1.21645100408832e+17
20 2.43290200817664e+18
21 5.109094217170944e+19
22 1.1240007277776077e+21
23 2.585201673888498e+22
24 6.204484017332394e+23
25 1.5511210043330986e+25
26 4.0329146112660565e+26
27 1.0888869450418352e+28
28 3.0488834461171384e+29
29 8.841761993739701e+30
</pre>

<p>Tyto výsledky vypadají lépe, ovšem například 1000! přesáhne rozsah typu
<strong>float64</strong>:</p>

<pre>
user&gt; <strong>(factorial 1000)</strong>
+Inf
</pre>

<p>Třetí varianta používá celá čísla s&nbsp;&bdquo;nekonečným&ldquo; rozsahem:</p>

<pre>
user&gt; <strong>(defn factorial [n] (reduce * (range 1N (inc n))))</strong>
</pre>

<p>Jedná se o nejlepší datový typ téměř přesně stvořený pro výpočet
faktoriálů:</p>

<pre>
user&gt; <strong>(doseq [n (range 0 30)] (println n (factorial n)))</strong>
0 1
1 1N
2 2N
3 6N
4 24N
5 120N
6 720N
7 5040N
8 40320N
9 362880N
10 3628800N
11 39916800N
12 479001600N
13 6227020800N
14 87178291200N
15 1307674368000N
16 20922789888000N
17 355687428096000N
18 6402373705728000N
19 121645100408832000N
20 2432902008176640000N
21 51090942171709440000N
22 1124000727777607680000N
23 25852016738884976640000N
24 620448401733239439360000N
25 15511210043330985984000000N
26 403291461126605635584000000N
27 10888869450418352160768000000N
28 304888344611713860501504000000N
29 8841761993739701954543616000000N
</pre>

<p>Problém nenastane ani při výpočtu 1000!:</p>

<pre>
#'user/factorial
user&gt; <strong>(factorial 1000)</strong>
4023872600770937735437024339230039857193748642107146325437999
1042993851239862902059204420848696940480047998861019719605863
1666872994808558901323829669944590997424504087073759918823627
...
...
...
2301353580818400969963725242305608559037006242712434169090041
5369010593398383577793941097002775347200000000000000000000000
0000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000N
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Výpočet konstanty Pi Wallisovým součinem: použití reálných čísel a zlomků</h2>

<p>Podívejme se nyní na použití různých datových typů na jednoduchém algoritmu
určeném pro výpočet hodnoty čísla Pi s&nbsp;využitím takzvaného <i>Wallisova
součinu</i> (<i>Wallis product</i>, viz též <a
href="https://en.wikipedia.org/wiki/Wallis_product">https://en.wikipedia.org/wiki/Wallis_product</a>).
Výpočet používající hodnoty s&nbsp;plovoucí řádovou čárkou může být
implementován například takto (používáme zde programovou smyčku, i když by bylo
možné algoritmus přepsat za pomoci rekurze &ndash; což je méně efektivní):</p>

<pre>
(defn compute-pi
    [n]
    (loop [pi 4.0
           i  3]
           (if (&lt; i (+ n 2))
               (recur (* pi (/ (- i 1) i) (/ (+ i 1) i))
                      (+ i 2))
               pi)))
&nbsp;
&nbsp;
(loop [n 1]
    (print n "\t")
    (println (compute-pi n))
    (if (&lt; n 500000)
        (recur (* n 2))))
</pre>

<p>Výsledky budou sice vypočteny rychle, ovšem přesnost se od určitého bodu již
nebude zvyšovat:</p>

<pre>
1       4.000000
2       3.555556
4       3.413333
8       3.302394
16      3.230036
32      3.188127
64      3.165482
128     3.153699
256     3.147687
512     3.144650
1024    3.143124
2048    3.142359
4096    3.141976
8192    3.141784
16384   3.141689
32768   3.141641
65536   3.141617
131072  3.141605
262144  3.141599
524288  3.141596
</pre>

<p>Druhá varianta používá čísla s&nbsp;teoreticky neomezenou přesností:</p>

<pre>
(defn compute-pi
    [n]
    (loop [pi 4M
           i  3]
           (if (&lt; i (+ n 2))
               (recur (* pi (/ (- i 1) i) (/ (+ i 1) i))
                      (+ i 2))
               pi)))
&nbsp;
&nbsp;
(loop [n 1]
    (print n "\t")
    (println (compute-pi n))
    (if (&lt; n 500000)
        (recur (* n 2))))
</pre>

<p>Výpočet je již znatelně pomalejší, ovšem Pi lze (s&nbsp;dostatkem času a
paměti) vypočítat s&nbsp;libovolnou přesností, i když používáme jeden
z&nbsp;nejpomaleji konvergujících algoritmů:</p>

<pre>
1       4M
2       3.5555555555555551608095912443887965835546460817611862740078511498087454612005M
4       3.41333333333333301753656188439991388456296898300406018291771319944995746157833M
8       3.30239355001259692280920194400154772374586363706317216774086896671698557673493M
16      3.23003646641171644532889395147155628591824505919549219334948928591485866419726M
32      3.1881271694471385210138122971756460360357166286716599658017344451317225348676M
64      3.16548206003479301000359223272779662079847690689602323017497171003960000199875M
128     3.15369884909579662233696379914525164935458647351778549138013266158467482689623M
256     3.14768689955642097012774122086854615055254871426894364462136545058514574740573M
512     3.1446501625172043342721016716151822642187838865539328374058640031469372655216M
1024    3.14312401702818716513564658579506676971691498322295763444751506627862492954596M
2048    3.14235898912177474909453737557243618376555954108506806271913844464157411813212M
4096    3.14197598500560203352568445241891251993592823431462623506515693992611545990133M
8192    3.14178436023473709091057936359290673473145653612318588673863895561787882156406M
16384   3.14168851714957705626885770501460708755455187703107092416262443647651781577763M
32768   3.1416405879293422812335507015910306209939040223297184216375211890918980802193M
65536   3.14161662139946575975135338281062749093860415881901622734854996519879152066546M
131072  3.1416046376545461304633895559846886819121577906409706156493279815083072754397M
262144  3.14159864566195543783459196307309124809158749182342203241630155983916009242113M
524288  3.14159564963570920196181065052181394692878789940139554703274845924206554511736M
</pre>

<p>Použít můžeme i zlomky, které jsou na konci převáděny na reálná čísla:</p>

<pre>
(defn compute-pi
    [n]
    (loop [pi 4/1
           i  3]
           (if (&lt; i (+ n 2))
               (recur (* pi (/ (- i 1) i) (/ (+ i 1) i))
                      (+ i 2))
               pi)))
&nbsp;
&nbsp;
(loop [n 1]
    (print n "\t")
    (println (double (compute-pi n)))
    (if (&lt; n 500000)
        (recur (* n 2))))
</pre>

<p>Výpočet je v&nbsp;tomto případě nejpomalejší:</p>

<pre>
1       4.000000
2       3.555556
4       3.413333
8       3.302394
16      3.230036
32      3.188127
64      3.165482
128     3.153699
256     3.147687
512     3.144650
1024    3.143124
2048    3.142359
4096    3.141976
8192    3.141784
16384   3.141689
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Makro <strong>dotimes</strong></h2>

<p>V&nbsp;některých programech může být poměrně užitečné makro nazvané
jednoduše a přitom příhodně <strong>dotimes</strong>, které dokáže nějaký výraz
(formu) opakovat <i>n</i> krát. Přitom toto makro může v&nbsp;každé iteraci
(opakování) nastavit zvolenou lokální proměnnou na aktuální hodnotu počitadla,
přičemž se hodnota počitadla v&nbsp;první iteraci vždy nastavuje na nulu a
v&nbsp;poslední iteraci dosahuje zadaného počtu opakování-1. Vzdáleně tedy
můžeme toto makro považovat za ekvivalent programové smyčky <strong>for i in
range(n):</strong> v&nbsp;programovacím jazyku <i>Python</i> či ekvivalent
k&nbsp;počítané smyčce <strong>for (int i = 0; i&lt;n; i++)</strong> známé
z&nbsp;céčka (zde bez možnosti mít lokální proměnnou jako počitadlo), C++, Javy
atd. Vzhledem k&nbsp;tomu, že se předpokládá, že forma &ndash; tělo smyčky
&ndash; předaná makru <strong>dotimes</strong> bude mít nějaký vedlejší efekt,
nejedná se sice o čistě funkcionální přístup, nicméně makro
<strong>dotimes</strong> může být skutečně velmi užitečné.</p>

<p>V&nbsp;jednoduchém demonstračním příkladu, který si ukážeme, se na
standardní výstup vypisuje převrácená hodnota celých čísel od 0 do 9. Vedlejším
efektem je v&nbsp;tomto případě samotný výpis na standardní výstup:</p>

<pre>
user=&gt; (dotimes [i 10] (println (/ 1.0 i)))
+Inf
1.000000
0.500000
0.333333
0.250000
0.200000
0.166667
0.142857
0.125000
0.111111
nil
</pre>

<div class="rs-box"><p>Poznámka: poslední vypsané <strong>nil</strong> je
návratovou hodnotou samotného makra <strong>dotimes</strong>, nikoli výsledek
poslední iterace)</p></div>

<p>Podívejme se nyní na poněkud složitější příklad, který by se
v&nbsp;imperativních programovacích jazycích většinou řešil s&nbsp;využitím
dvojice do sebe vnořených počítaných programových smyček. Mějme za úkol vypsat
tabulku malé násobilky, tj.&nbsp;všechny výsledky vzniklé vynásobením dvojic
celých čísel od 1 do 10. Tento algoritmus je možné velmi snadno realizovat
právě s&nbsp;využitím makra <strong>dotimes</strong>, například následujícím
one-linerem:</p>

<pre>
(dotimes [i 10] (dotimes [j 10] (print (* (+ i 1) (+ j 1)) "\t")) (println))
</pre>

<p>Pro větší přehlednost si můžeme výše uvedený one-liner přepsat na správně
odsazený program, z&nbsp;něhož je patrné, že se skutečně jedná o ekvivalent
dvou do sebe zanořených programových smyček:</p>

<pre>
(dotimes [i 10]
    (dotimes [j 10]
        (print (* (inc i) (inc j)) "\t"))
    (println))
</pre>

<p>A zde je již výsledek práce tohoto programu (poslední <strong>nil</strong>
je opět návratovou hodnotou makra <strong>dotimes</strong>):</p>

<pre>
1     2     3     4     5     6     7     8     9     10
2     4     6     8     10    12    14    16    18    20
3     6     9     12    15    18    21    24    27    30
4     8     12    16    20    24    28    32    36    40
5     10    15    20    25    30    35    40    45    50
6     12    18    24    30    36    42    48    54    60
7     14    21    28    35    42    49    56    63    70
8     16    24    32    40    48    56    64    72    80
9     18    27    36    45    54    63    72    81    90
10    20    30    40    50    60    70    80    90    100
nil
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Přímá rekurze</h2>

<p>Všechny funkcionální jazyky podporují přímou rekurzi, takže se podívejme na
její zápis. Typický školní příklad pro výpočet faktoriálu můžeme zapsat
následovně:</p>

<pre>
(defn fact
    [n]
    (if (&lt;= n 1)
        1
        (* n (fact (- n 1)))))
</pre>

<p>Vcelku snadno však může nastat situace, kdy se zcela zaplní paměť
s&nbsp;návratovými body i parametry rekurzivně volané funkce:</p>

<pre>
user&gt; <strong>(fact 1000000000)</strong>
runtime: goroutine stack exceeds 1000000000-byte limit
fatal error: stack overflow
</pre>

<p>V&nbsp;takovém případě celý interpret zhavaruje.</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Tail rekurze</h2>

<p>Důvod, proč předchozí volání funkce <strong>fact</strong> skončilo
s&nbsp;chybou, spočívá v&nbsp;tom, že došlo k&nbsp;přeplnění zásobníku při
rekurzivním volání. Na zásobník se totiž musí ukládat parametry předávané
volané funkci a taktéž body návratu (zjednodušeně řečeno návratové adresy). Aby
k&nbsp;přetečení zásobníku nedocházelo, můžeme naši funkci
<strong>fact</strong> upravit tak, aby se využívalo takzvané <i>tail
rekurze</i>. Velmi zjednodušeně řečeno je <i>tail rekurze</i> použita tehdy,
pokud je posledním příkazem nějaké funkce příkaz pro rekurzivní volání té samé
funkce. V&nbsp;tomto případě se nemusí na zásobník nic ukládat a namísto toho
se prostě provede skok. V&nbsp;Jokeru se však musí <i>tail rekurze</i> zapsat
explicitně, což má své přednosti i zápory (podle mě převažují přednosti,
protože již ze zápisu programu je zcela zřejmé, kdy k&nbsp;<i>tail rekurzi</i>
skutečně dojde).</p>

<p>Explicitní zápis rekurze spočívá ve využití speciální formy
<strong>recur</strong>, která se zapíše přesně do místa, kde má k&nbsp;tail
rekurzi (=skoku) dojít:</p>

<pre>
(defn fact
    ([n]
     (fact n 1))
    ([n acc]
     (if (&lt;= n 1)
         acc
         (recur (dec n) (* acc n)))))
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto příkladu používáme ještě
jednu důležitou vlastnost Jokeru &ndash; funkci s&nbsp;více aritami
resp.&nbsp;přesněji řečeno s&nbsp;větším množstvím variant, které se od sebe
odlišují počtem parametrů.</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/lisp-families.git">https://github.com/tisnik/lisp-families.git</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, můžete
namísto toho použít odkazy na jednotlivé příklady, které naleznete
v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>01_data_types.clj</td><td>základní datové typy</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/joker/01_data_types.clj">https://github.com/tisnik/lisp-families/blob/master/joker/01_data_types.clj</a></td></tr>
<tr><td> 2</td><td>02_collections.clj</td><td>kolekce a další strukturované datové typy</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/joker/02_collections.clj">https://github.com/tisnik/lisp-families/blob/master/joker/02_collections.clj</a></td></tr>
<tr><td> 3</td><td>03_arithmetic_functions.clj</td><td>test překladu aritmetických výrazů</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/joker/03_arithmetic_functions.clj">https://github.com/tisnik/lisp-families/blob/master/joker/03_arithmetic_functions.clj</a></td></tr>
<tr><td> 4</td><td>04_relop.clj</td><td>test překladu relačních výrazů</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/joker/04_relop.clj">https://github.com/tisnik/lisp-families/blob/master/joker/04_relop.clj</a></td></tr>
<tr><td> 5</td><td>05_boolean_op.clj</td><td>test překladu booleovských výrazů</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/joker/05_boolean_op.clj">https://github.com/tisnik/lisp-families/blob/master/joker/05_boolean_op.clj</a></td></tr>
<tr><td> 6</td><td>06_factorial_1.clj</td><td>výpočet faktoriálu v&nbsp;oboru int</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/joker/06_factorial_1.clj">https://github.com/tisnik/lisp-families/blob/master/joker/06_factorial_1.clj</a></td></tr>
<tr><td> 7</td><td>07_factorial_2.clj</td><td>výpočet faktoriálu v&nbsp;oboru float32</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/joker/07_factorial_2.clj">https://github.com/tisnik/lisp-families/blob/master/joker/07_factorial_2.clj</a></td></tr>
<tr><td> 8</td><td>08_factorial_3.clj</td><td>výpočet faktoriálu v&nbsp;oboru big.Int</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/joker/08_factorial_3.clj">https://github.com/tisnik/lisp-families/blob/master/joker/08_factorial_3.clj</a></td></tr>
<tr><td> 9</td><td>09_pi_1.clj</td><td>výpočet konstanty Pi, první varianta</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/joker/09_pi_1.clj">https://github.com/tisnik/lisp-families/blob/master/joker/09_pi_1.clj</a></td></tr>
<tr><td>10</td><td>10_pi_2.clj</td><td>výpočet konstanty Pi, druhá varianta</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/joker/10_pi_2.clj">https://github.com/tisnik/lisp-families/blob/master/joker/10_pi_2.clj</a></td></tr>
<tr><td>11</td><td>11_pi_3.clj</td><td>výpočet konstanty Pi, třetí varianta</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/joker/11_pi_3.clj">https://github.com/tisnik/lisp-families/blob/master/joker/11_pi_3.clj</a></td></tr>
<tr><td>12</td><td>12_dotimes.clj</td><td>makro <strong>dotimes</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/joker/12_dotimes.clj">https://github.com/tisnik/lisp-families/blob/master/joker/12_dotimes.clj</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Literatura</h2>

<ol>

<li>Peter Seibel<br />
<i>&bdquo;Practical Common Lisp&ldquo;</i><br />
2009
</li>

<li>Paul Graham<br />
<i>&bdquo;ANSI Common Lisp&ldquo;</i><br />
1995
</li>

<li>Gerald Gazdar<br />
<i>&bdquo;Natural Language Processing in Lisp: An Introduction to Computational Linguistics&ldquo;</i><br />
1989
</li>

<li>Peter Norvig<br />
<i>&bdquo;Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp&ldquo;</i><br />
1991
</li>

<li>Alex Mileler et.al.<br />
<i>&bdquo;Clojure Applied: From Practice to Practitioner&ldquo;</i><br />
2015
</li>

<li>
<i>&bdquo;Living Clojure: An Introduction and Training Plan for Developers&ldquo;</i><br />
2015
</li>

<li>Dmitri Sotnikov<br />
<i>&bdquo;Web Development with Clojure: Build Bulletproof Web Apps with Less Code&ldquo;</i><br />
2016
</li>

<li>McCarthy<br />
<i>&bdquo;Recursive functions of symbolic expressions and their computation by machine, part I&ldquo;</i><br />
1960
</li>

<li>R. Kent Dybvig<br />
<i>&bdquo;The Scheme Programming Language&ldquo;</i><br />
2009
</li>

<li>Max Hailperin<br />
<i>&bdquo;Concrete Abstractions&ldquo;</i><br />
1998
</li>

<li>Guy L. Steele<br />
<i>&bdquo;History of Scheme&ldquo;</i><br />
2006, Sun Microsystems Laboratories
</li>

<li>Kolář J., Muller K.:<br />
<i>&bdquo;Speciální programovací jazyky&ldquo;</i><br />
Praha 1981
</li>

<li>
<i>&bdquo;AutoLISP Release 9, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., October 1987
</li>

<li>
<i>&bdquo;AutoLISP Release 10, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., September 1988
</li>

<li>McCarthy, John; Abrahams, Paul W.; Edwards, Daniel J.; Hart, Timothy P.; Levin, Michael I.<br />
<i>&bdquo;LISP 1.5 Programmer's Manual&ldquo;</i><br />
MIT Press. ISBN 0 262 130 1 1 4
</li>

<li>Carl Hewitt; Peter Bishop and Richard Steiger<br />
<i>&bdquo;A Universal Modular Actor Formalism for Artificial Intelligence&ldquo;</i><br />
1973
</li>

<li>Feiman, J.<br />
<i>&bdquo;The Gartner Programming Language Survey (October 2001)&ldquo;</i><br />
Gartner Advisory
</li>

<li>Harold Abelson, Gerald Jay Sussman, Julie Sussman:<br />
<i>Structure and Interpretation of Computer Programs</i><br />
MIT Press. 1985, 1996 (a možná vyšel i další přetisk)
</li>

<li>Paul Graham<br />
<i>On Lisp</i><br />
Prentice Hall, 1993<br />
Dostupné online na stránce <a href="http://www.paulgraham.com/onlisptext.html">http://www.paulgraham.com/onlisptext.html</a>
</li>

<li>David S. Touretzky<br />
<i>Common LISP: A Gentle Introduction to Symbolic Computation (Dover Books on Engineering)</i><br />
</li>

<li>Peter Norvig<br />
<i>Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp</i>
</li>

<li>Patrick Winston, Berthold Horn<br />
<i>Lisp (3rd Edition)</i><br />
ISBN-13: 978-0201083194, ISBN-10: 0201083191
</li>

<li>Matthias Felleisen, David Van Horn, Dr. Conrad Barski<br>
<i>Realm of Racket: Learn to Program, One Game at a Time!</i><br />
ISBN-13: 978-1593274917, ISBN-10: 1593274912 
</li>

<li>Graham Hutton<br />
<i>A tutorial on the universality andexpressiveness of fold</i><br />
http://www.cs.nott.ac.uk/~pszgmh/fold.pdf
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Stránka projektu Joker<br />
<a href="https://joker-lang.org/">https://joker-lang.org/</a>
</li>

<li>Racket: programovací jazyk a současně i platforma pro vývoj nových jazyků<br />
<a href="https://www.root.cz/clanky/racket-programovaci-jazyk-a-soucasne-i-platforma-pro-vyvoj-novych-jazyku/">https://www.root.cz/clanky/racket-programovaci-jazyk-a-soucasne-i-platforma-pro-vyvoj-novych-jazyku/</a>
</li>

<li>Makra v Racketu i v dalších lispovských jazycích<br />
<a href="https://www.root.cz/clanky/makra-v-racketu-i-v-dalsich-lispovskych-jazycich/">https://www.root.cz/clanky/makra-v-racketu-i-v-dalsich-lispovskych-jazycich/</a>
</li>

<li>Základní knihovna jazyka Racket<br />
<a href="https://www.root.cz/clanky/zakladni-knihovna-jazyka-racket/">https://www.root.cz/clanky/zakladni-knihovna-jazyka-racket/</a>
</li>

<li>Základní knihovny pro 2D grafiku v jazyku Racket<br />
<a href="https://www.root.cz/clanky/zakladni-knihovny-pro-2d-grafiku-v-jazyku-racket/">https://www.root.cz/clanky/zakladni-knihovny-pro-2d-grafiku-v-jazyku-racket/</a>
</li>

<li>Popis formátu EDN<br />
<a href="https://github.com/edn-format/edn">https://github.com/edn-format/edn</a>
</li>

<li>Jazyky Hy a Clojure-py: moderní dialekty LISPu určené pro Python VM<br />
<a href="https://www.root.cz/clanky/jazyky-hy-a-clojure-py-moderni-dialekty-lispu-urcene-pro-python-vm/">https://www.root.cz/clanky/jazyky-hy-a-clojure-py-moderni-dialekty-lispu-urcene-pro-python-vm/</a>
</li>

<li>Grafický metaformát PostScript<br />
<a href="https://www.root.cz/clanky/graficky-metaformat-postscript/">https://www.root.cz/clanky/graficky-metaformat-postscript/</a>
</li>

<li>Vektorový grafický formát SVG<br />
<a href="https://www.root.cz/clanky/vektorovy-graficky-format-svg/">https://www.root.cz/clanky/vektorovy-graficky-format-svg/</a>
</li>

<li>The Racket Drawing Toolkit<br />
<a href="https://docs.racket-lang.org/draw/index.html">https://docs.racket-lang.org/draw/index.html</a>
</li>

<li>Traditional Turtles<br />
<a href="https://docs.racket-lang.org/turtles/Traditional_Turtles.html">https://docs.racket-lang.org/turtles/Traditional_Turtles.html</a>
</li>

<li>[racket] How best to repeat a function call n times?<br />
<a href="https://lists.racket-lang.org/users/archive/2014-September/064203.html">https://lists.racket-lang.org/users/archive/2014-September/064203.html</a>
</li>

<li>Racket: Macros<br />
<a href="https://www.it.uu.se/edu/course/homepage/avfunpro/ht13/lectures/Racket-3-Macros.pdf">https://www.it.uu.se/edu/course/homepage/avfunpro/ht13/lectures/Racket-3-Macros.pdf</a>
</li>

<li>Beautiful Racket / explainers: Macros<br />
<a href="https://beautifulracket.com/explainer/macros.html">https://beautifulracket.com/explainer/macros.html</a>
</li>

<li>Macros (dokumentace k Racketu)<br />
<a href="https://docs.racket-lang.org/guide/macros.html">https://docs.racket-lang.org/guide/macros.html</a>
</li>

<li>Model syntaxe jazyka Racket<br />
<a href="https://docs.racket-lang.org/reference/syntax-model.html">https://docs.racket-lang.org/reference/syntax-model.html</a>
</li>

<li>Syntax Objects<br />
<a href="https://docs.racket-lang.org/guide/stx-obj.html">https://docs.racket-lang.org/guide/stx-obj.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Beautiful Racket: an intro­duction to language-oriented programming using Racket<br />
<a href="https://beautifulracket.com/">https://beautifulracket.com/</a>
</li>

<li>Stránky projektu Racket<br />
<a href="https://racket-lang.org/">https://racket-lang.org/</a>
</li>

<li>Dokumentace k&nbsp;projektu Racket<br />
<a href="https://docs.racket-lang.org/index.html">https://docs.racket-lang.org/index.html</a>
</li>

<li>Seznam dostupných balíčků pro Racket<br />
<a href="https://pkgs.racket-lang.org/">https://pkgs.racket-lang.org/</a>
</li>

<li>Racket na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Racket_(programming_language)">https://en.wikipedia.org/wiki/Racket_(programming_language)</a>
</li>

<li>Blogy o Racketu a navazujících technologiích<br />
<a href="https://blog.racket-lang.org/">https://blog.racket-lang.org/</a>
</li>

<li>Prográmky psané v&nbsp;Racketu na RosettaCode<br />
<a href="http://rosettacode.org/wiki/Category:Racket">http://rosettacode.org/wiki/Category:Racket</a>
</li>

<li>Fear of Macros<br />
<a href="https://www.greghendershott.com/fear-of-macros/">https://www.greghendershott.com/fear-of-macros/</a>
</li>

<li>Rackjure<br />
<a href="https://github.com/greghendershott/rackjure">https://github.com/greghendershott/rackjure</a>
</li>

<li>Matthew Flatt’s proposal to change Racket’s s-expressions based syntax to infix representation creates a stir in the community<br />
<a href="https://hub.packtpub.com/matthew-flatts-proposal-to-change-rackets-s-expressions-based-syntax-to-infix-representation-creates-a-stir-in-the-community/">https://hub.packtpub.com/matthew-flatts-proposal-to-change-rackets-s-expressions-based-syntax-to-infix-representation-creates-a-stir-in-the-community/</a>
</li>

<li>Racket News<br />
<a href="https://racket-news.com/">https://racket-news.com/</a>
</li>

<li>Racket: Lisp for learning<br />
<a href="https://lwn.net/Articles/795385/">https://lwn.net/Articles/795385/</a>
</li>

<li>Future of Racket<br />
<a href="https://www.greghendershott.com/2019/07/future-of-racket.html">https://www.greghendershott.com/2019/07/future-of-racket.html</a>
</li>

<li>Kawa: Compiling Scheme to Java<br />
<a href="https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html">https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html</a>
</li>

<li>Kawa in Languages shootout<br />
<a href="http://per.bothner.com/blog/2010/Kawa-in-shootout/">http://per.bothner.com/blog/2010/Kawa-in-shootout/</a>
</li>

<li>Kawa 2.0 Supports Scheme R7RS<br />
<a href="https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/">https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/</a>
</li>

<li>Kawa — fast scripting on the Java platform<br />
<a href="https://lwn.net/Articles/623349/">https://lwn.net/Articles/623349/</a>
</li>

<li>Tail call (a její optimalizace)<br />
<a href="https://en.wikipedia.org/wiki/Tail_call">https://en.wikipedia.org/wiki/Tail_call</a>
</li>

<li>SLIME (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/SLIME">http://en.wikipedia.org/wiki/SLIME</a>
</li>

<li>slime.vim<br />
<a href="http://s3.amazonaws.com/mps/slime.vim">http://s3.amazonaws.com/mps/slime.vim</a>
</li>

<li>What are the best scheme implementations?<br />
<a href="https://www.slant.co/topics/5282/~scheme-implementations">https://www.slant.co/topics/5282/~scheme-implementations</a>
</li>

<li>Bigloo homepage<br />
<a href="http://www-sop.inria.fr/mimosa/fp/Bigloo/">http://www-sop.inria.fr/mimosa/fp/Bigloo/</a>
</li>

<li>FTP s tarbally Bigloo<br />
<a href="ftp://ftp-sop.inria.fr/indes/fp/Bigloo">ftp://ftp-sop.inria.fr/indes/fp/Bigloo</a>
</li>

<li>GOTO 2018 • Functional Programming in 40 Minutes • Russ Olsen<br />
<a href="https://www.youtube.com/watch?v=0if71HOyVjY">https://www.youtube.com/watch?v=0if71HOyVjY</a>
</li>

<li>TinyScheme (stránka na Sourceforge)<br />
<a href="http://tinyscheme.sourceforge.net/home.html">http://tinyscheme.sourceforge.net/home.html</a>
</li>

<li>Embedding Tiny Scheme in a Game<br />
<a href="http://www.silicondelight.com/embedding-tiny-scheme-in-a-game/">http://www.silicondelight.com/embedding-tiny-scheme-in-a-game/</a>
</li>

<li>Embedding Scheme for a game mission scripting DSL<br />
<a href="http://carloscarrasco.com/embedding-scheme-for-a-game-mission-scripting-dsl.html">http://carloscarrasco.com/embedding-scheme-for-a-game-mission-scripting-dsl.html</a>
</li>

<li>Všechny verze TinyScheme na SourceForge<br />
<a href="https://sourceforge.net/projects/tinyscheme/files/tinyscheme/">https://sourceforge.net/projects/tinyscheme/files/tinyscheme/</a>
</li>

<li>Fork TinyScheme na GitHubu<br />
<a href="https://github.com/yawnt/tinyscheme">https://github.com/yawnt/tinyscheme</a>
</li>

<li>Ackermannova funkce<br />
<a href="https://cs.wikipedia.org/wiki/Ackermannova_funkce">https://cs.wikipedia.org/wiki/Ackermannova_funkce</a>
</li>

<li>Ackermann function na Rosetta Code<br />
<a href="https://rosettacode.org/wiki/Ackermann_function#Scheme">https://rosettacode.org/wiki/Ackermann_function#Scheme</a>
</li>

<li>Success Stories (lisp.org)<br />
<a href="https://lisp-lang.org/success/">https://lisp-lang.org/success/</a>
</li>

<li>Allegro Common Lisp Success Stories<br />
<a href="https://franz.com/success/">https://franz.com/success/</a>
</li>

<li>Clojure Success Stories<br />
<a href="https://clojure.org/community/success_stories">https://clojure.org/community/success_stories</a>
</li>

<li>Scheme Quick Reference<br />
<a href="https://www.st.cs.uni-saarland.de/edu/config-ss04/scheme-quickref.pdf">https://www.st.cs.uni-saarland.de/edu/config-ss04/scheme-quickref.pdf</a>
</li>

<li>Slajdy o Scheme (od slajdu číslo 15)<br />
<a href="https://docs.google.com/presentation/d/1abmDnKjrq1tcjGvvRNAKhOiSTSE2lyagtcEPal07Gbo/edit">https://docs.google.com/presentation/d/1abmDnKjrq1tcjGvvRNAKhOiSTSE2lyagtcEPal07Gbo/edit</a>
</li>

<li>Scheme Cheat Sheet<br />
<a href="https://github.com/smythp/scheme-cheat-sheet">https://github.com/smythp/scheme-cheat-sheet</a>
</li>

<li>Embedding Lua, embedding Guile <br />
<a href="http://puntoblogspot.blogspot.com/2013/04/embedding-lua-embedding-guile.html">http://puntoblogspot.blogspot.com/2013/04/embedding-lua-embedding-guile.html</a>
</li>

<li>Lambda Papers<br />
<a href="https://en.wikisource.org/wiki/Lambda_Papers">https://en.wikisource.org/wiki/Lambda_Papers</a>
</li>

<li>Revised<sup>7</sup>Report on the Algorithmic Language Scheme<br />
<a href="https://small.r7rs.org/attachment/r7rs.pdf">https://small.r7rs.org/attachment/r7rs.pdf</a>
</li>

<li>Video Lectures (MIT, SICP 2005)<br />
<a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/</a>
</li>

<li>Why is Scheme my first language in university?<br />
<a href="https://softwareengineering.stackexchange.com/questions/115252/why-is-scheme-my-first-language-in-university">https://softwareengineering.stackexchange.com/questions/115252/why-is-scheme-my-first-language-in-university</a>
</li>

<li>The Perils of JavaSchools<br />
<a href="https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/">https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/</a>
</li>

<li>How to Design Programs, Second Edition<br />
<a href="https://htdp.org/2019-02-24/index.html">https://htdp.org/2019-02-24/index.html</a>
</li>

<li>LilyPond<br />
<a href="http://lilypond.org/">http://lilypond.org/</a>
</li>

<li>LilyPond — Extending (přes Scheme)<br />
<a href="http://lilypond.org/doc/v2.18/Documentation/extending/scheme-tutorial">http://lilypond.org/doc/v2.18/Documentation/extending/scheme-tutorial</a>
</li>

<li>Scheme in LilyPond<br />
<a href="http://lilypond.org/doc/v2.18/Documentation/extending/scheme-in-lilypond">http://lilypond.org/doc/v2.18/Documentation/extending/scheme-in-lilypond</a>
</li>

<li>GnuCash<br />
<a href="http://www.gnucash.org/">http://www.gnucash.org/</a>
</li>

<li>Custom Reports (in GNU Cash)<br />
<a href="https://wiki.gnucash.org/wiki/Custom_Reports">https://wiki.gnucash.org/wiki/Custom_Reports</a>
</li>

<li>Program by Design<br />
<a href="https://programbydesign.org/">https://programbydesign.org/</a>
</li>

<li>SchemePy<br />
<a href="https://pypi.org/project/SchemePy/">https://pypi.org/project/SchemePy/</a>
</li>

<li>LISP FQA: Section - [1-5] What is the "minimal" set of primitives needed for a Lisp interpreter?<br />
<a href="http://www.faqs.org/faqs/lisp-faq/part1/section-6.html">http://www.faqs.org/faqs/lisp-faq/part1/section-6.html</a>
</li>

<li>femtolisp<br />
<a href="https://github.com/JeffBezanson/femtolisp">https://github.com/JeffBezanson/femtolisp</a>
</li>

<li>(How to Write a (Lisp) Interpreter (in Python))<br />
<a href="http://norvig.com/lispy.html">http://norvig.com/lispy.html</a>
</li>

<li>Repositář s&nbsp;Guile Emacsem<br />
<a href="http://git.hcoop.net/?p=bpt/guile.git">http://git.hcoop.net/?p=bpt/guile.git</a>
</li>

<li>Interacting with Guile Compound Data Types in C<br />
<a href="http://www.lonelycactus.com/guilebook/x1555.html">http://www.lonelycactus.com/guilebook/x1555.html</a>
</li>

<li>Calling Guile functions from C<br />
<a href="http://www.lonelycactus.com/guilebook/c1204.html#SECCALLGUILEFUNC">http://www.lonelycactus.com/guilebook/c1204.html#SECCALLGUILEFUNC</a>
</li>

<li>Arrays, and other compound data types<br />
<a href="http://www.lonelycactus.com/guilebook/charrays.html">http://www.lonelycactus.com/guilebook/charrays.html</a>
</li>

<li>Interacting with Guile Compound Data Types in C<br />
<a href="http://www.lonelycactus.com/guilebook/x1555.html">http://www.lonelycactus.com/guilebook/x1555.html</a>
</li>

<li>Guile Reference Manual<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/index.html">https://www.gnu.org/software/guile/manual/html_node/index.html</a>
</li>

<li>Scheme: Summary of Common Syntax<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/Syntax-Summary.html#Syntax-Summary">https://www.gnu.org/software/guile/manual/html_node/Syntax-Summary.html#Syntax-Summary</a>
</li>

<li>Scripting with Guile: Extension language enhances C and Scheme<br />
<a href="https://www.ibm.com/developerworks/library/l-guile/index.html">https://www.ibm.com/developerworks/library/l-guile/index.html</a>
</li>

<li>Having fun with Guile: a tutorial<br />
<a href="http://dustycloud.org/misc/guile-tutorial.html">http://dustycloud.org/misc/guile-tutorial.html</a>
</li>

<li>Guile: Loading Readline Support<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/Loading-Readline-Support.html#Loading-Readline-Support">https://www.gnu.org/software/guile/manual/html_node/Loading-Readline-Support.html#Loading-Readline-Support</a>
</li>

<li>lispy<br />
<a href="https://pypi.org/project/lispy/">https://pypi.org/project/lispy/</a>
</li>

<li>Lython<br />
<a href="https://pypi.org/project/Lython/">https://pypi.org/project/Lython/</a>
</li>

<li>Lizpop<br />
<a href="https://pypi.org/project/lizpop/">https://pypi.org/project/lizpop/</a>
</li>

<li>Budoucnost programovacích jazyků<br />
<a href="http://www.knesl.com/budoucnost-programovacich-jazyku">http://www.knesl.com/budoucnost-programovacich-jazyku</a>
</li>

<li>LISP Prolog and Evolution<br />
<a href="http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html">http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html</a>
</li>

<li>List of Lisp-family programming languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages">https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages</a>
</li>

<li>clojure_py na indexu PyPi<br />
<a href="https://pypi.python.org/pypi/clojure_py">https://pypi.python.org/pypi/clojure_py</a>
</li>

<li>PyClojure<br />
<a href="https://github.com/eigenhombre/PyClojure">https://github.com/eigenhombre/PyClojure</a>
</li>

<li>Hy na GitHubu<br />
<a href="https://github.com/hylang/hy">https://github.com/hylang/hy</a>
</li>

<li>Hy: The survival guide<br />
<a href="https://notes.pault.ag/hy-survival-guide/">https://notes.pault.ag/hy-survival-guide/</a>
</li>

<li>Hy běžící na monitoru terminálu společnosti Symbolics<br />
<a href="http://try-hy.appspot.com/">http://try-hy.appspot.com/</a>
</li>

<li>Welcome to Hy’s documentation!<br />
<a href="http://docs.hylang.org/en/stable/">http://docs.hylang.org/en/stable/</a>
</li>

<li>Hy na PyPi<br />
<a href="https://pypi.org/project/hy/#description">https://pypi.org/project/hy/#description</a>
</li>

<li>Getting Hy on Python<br />
<a href="https://lwn.net/Articles/596626/">https://lwn.net/Articles/596626/</a>
</li>

<li>Programming Can Be Fun with Hy<br />
<a href="https://opensourceforu.com/2014/02/programming-can-fun-hy/">https://opensourceforu.com/2014/02/programming-can-fun-hy/</a>
</li>

<li>Přednáška o projektu Hy (pětiminutový lighttalk)<br />
<a href="http://blog.pault.ag/day/2013/04/02">http://blog.pault.ag/day/2013/04/02</a>
</li>

<li>Hy (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Hy">https://en.wikipedia.org/wiki/Hy</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Point<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Point.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Point.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Narrowing<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Narrowing.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Narrowing.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Functions that Create Markers<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Markers.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Markers.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Motion<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Motion.html#Motion">https://www.gnu.org/software/emacs/manual/html_node/elisp/Motion.html#Motion</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Basic Char Syntax<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Char-Syntax.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Char-Syntax.html</a>
</li>

<li>Elisp: Sequence: List, Array<br />
<a href="http://ergoemacs.org/emacs/elisp_list_vs_vector.html">http://ergoemacs.org/emacs/elisp_list_vs_vector.html</a>
</li>

<li>Elisp: Property List<br />
<a href="http://ergoemacs.org/emacs/elisp_property_list.html">http://ergoemacs.org/emacs/elisp_property_list.html</a>
</li>

<li>Elisp: Hash Table<br />
<a href="http://ergoemacs.org/emacs/elisp_hash_table.html">http://ergoemacs.org/emacs/elisp_hash_table.html</a>
</li>

<li>Elisp: Association List<br />
<a href="http://ergoemacs.org/emacs/elisp_association_list.html">http://ergoemacs.org/emacs/elisp_association_list.html</a>
</li>

<li>The mapcar Function (An Introduction to Programming in Emacs Lisp)<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/mapcar.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/mapcar.html</a>
</li>

<li>Anaphoric macro<br />
<a href="https://en.wikipedia.org/wiki/Anaphoric_macro">https://en.wikipedia.org/wiki/Anaphoric_macro</a>
</li>

<li>Some Common Lisp Loop Macro Examples<br />
<a href="https://www.youtube.com/watch?v=3yl8o6r_omw">https://www.youtube.com/watch?v=3yl8o6r_omw</a>
</li>

<li>A Guided Tour of Emacs<br />
<a href="https://www.gnu.org/software/emacs/tour/">https://www.gnu.org/software/emacs/tour/</a>
</li>

<li>The Roots of Lisp<br />
<a href="http://www.paulgraham.com/rootsoflisp.html">http://www.paulgraham.com/rootsoflisp.html</a>
</li>

<li>Evil (Emacs Wiki)<br />
<a href="https://www.emacswiki.org/emacs/Evil">https://www.emacswiki.org/emacs/Evil</a>
</li>

<li>Evil (na GitHubu)<br />
<a href="https://github.com/emacs-evil/evil">https://github.com/emacs-evil/evil</a>
</li>

<li>Evil (na stránkách repositáře MELPA)<br />
<a href="https://melpa.org/#/evil">https://melpa.org/#/evil</a>
</li>

<li>Evil Mode: How I Switched From VIM to Emacs<br />
<a href="https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html">https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html</a>
</li>

<li>GNU Emacs (home page)<br />
<a href="https://www.gnu.org/software/emacs/">https://www.gnu.org/software/emacs/</a>
</li>

<li>GNU Emacs (texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs">http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs</a>
</li>

<li>An Introduction To Using GDB Under Emacs<br />
<a href="http://tedlab.mit.edu/~dr/gdbintro.html">http://tedlab.mit.edu/~dr/gdbintro.html</a>
</li>

<li>An Introduction to Programming in Emacs Lisp<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html</a>
</li>

<li>27.6 Running Debuggers Under Emacs<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html">https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html</a>
</li>

<li>GdbMode<br />
<a href="http://www.emacswiki.org/emacs/GdbMode">http://www.emacswiki.org/emacs/GdbMode</a>
</li>

<li>Emacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Emacs">https://en.wikipedia.org/wiki/Emacs</a>
</li>

<li>Emacs timeline<br />
<a href="http://www.jwz.org/doc/emacs-timeline.html">http://www.jwz.org/doc/emacs-timeline.html</a>
</li>

<li>Emacs Text Editors Family<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?EmacsFamily">http://texteditors.org/cgi-bin/wiki.pl?EmacsFamily</a>
</li>

<li>Vrapper aneb spojení možností Vimu a Eclipse<br />
<a href="https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse/">https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse/</a>
</li>

<li>Vrapper aneb spojení možností Vimu a Eclipse (část 2: vyhledávání a nahrazování textu)<br />
<a href="https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse-cast-2-vyhledavani-a-nahrazovani-textu/">https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse-cast-2-vyhledavani-a-nahrazovani-textu/</a>
</li>

<li>Emacs/Evil-mode - A basic reference to using evil mode in Emacs<br />
<a href="http://www.aakarshnair.com/posts/emacs-evil-mode-cheatsheet">http://www.aakarshnair.com/posts/emacs-evil-mode-cheatsheet</a>
</li>

<li>From Vim to Emacs+Evil chaotic migration guide<br />
<a href="https://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/">https://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/</a>
</li>

<li>Introduction to evil-mode {video)<br />
<a href="https://www.youtube.com/watch?v=PeVQwYUxYEg">https://www.youtube.com/watch?v=PeVQwYUxYEg</a>
</li>

<li>EINE (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/EINE">http://www.emacswiki.org/emacs/EINE</a>
</li>

<li>EINE (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?EINE">http://texteditors.org/cgi-bin/wiki.pl?EINE</a>
</li>

<li>ZWEI (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/ZWEI">http://www.emacswiki.org/emacs/ZWEI</a>
</li>

<li>ZWEI (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?ZWEI">http://texteditors.org/cgi-bin/wiki.pl?ZWEI</a>
</li>

<li>Zmacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Zmacs">https://en.wikipedia.org/wiki/Zmacs</a>
</li>

<li>Zmacs (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?Zmacs">http://texteditors.org/cgi-bin/wiki.pl?Zmacs</a>
</li>

<li>TecoEmacs (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/TecoEmacs">http://www.emacswiki.org/emacs/TecoEmacs</a>
</li>

<li>Micro Emacs<br />
<a href="http://www.emacswiki.org/emacs/MicroEmacs">http://www.emacswiki.org/emacs/MicroEmacs</a>
</li>

<li>Micro Emacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/MicroEMACS">https://en.wikipedia.org/wiki/MicroEMACS</a>
</li>

<li>EmacsHistory<br />
<a href="http://www.emacswiki.org/emacs/EmacsHistory">http://www.emacswiki.org/emacs/EmacsHistory</a>
</li>

<li>Seznam editorů s ovládáním podobným Emacsu či kompatibilních s příkazy Emacsu<br />
<a href="http://www.finseth.com/emacs.html">http://www.finseth.com/emacs.html</a>
</li>

<li>evil-numbers<br />
<a href="https://github.com/cofi/evil-numbers">https://github.com/cofi/evil-numbers</a>
</li>

<li>Debuggery a jejich nadstavby v&nbsp;Linuxu (1.část)<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/</a>
</li>

<li>Debuggery a jejich nadstavby v&nbsp;Linuxu (2.část)<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (3): Nemiver<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (4): KDbg<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (5): ladění aplikací v editorech Emacs a Vim<br />
<a href="https://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">https://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/</a>
</li>

<li>Org mode<br />
<a href="https://orgmode.org/">https://orgmode.org/</a>
</li>

<li>The Org Manual<br />
<a href="https://orgmode.org/manual/index.html">https://orgmode.org/manual/index.html</a>
</li>

<li>Kakoune (modální textový editor)<br />
<a href="http://kakoune.org/">http://kakoune.org/</a>
</li>

<li>Vim-style keybinding in Emacs/Evil-mode<br />
<a href="https://gist.github.com/troyp/6b4c9e1c8670200c04c16036805773d8">https://gist.github.com/troyp/6b4c9e1c8670200c04c16036805773d8</a>
</li>

<li>Emacs - jak začít<br />
<a href="http://www.abclinuxu.cz/clanky/navody/emacs-jak-zacit">http://www.abclinuxu.cz/clanky/navody/emacs-jak-zacit</a>
</li>

<li>Programovací jazyk LISP a LISP machines<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-lisp-a-lisp-machines/">https://www.root.cz/clanky/programovaci-jazyk-lisp-a-lisp-machines/</a>
</li>

<li>Evil-surround<br />
<a href="https://github.com/emacs-evil/evil-surround">https://github.com/emacs-evil/evil-surround</a>
</li>

<li>Spacemacs<br />
<a href="http://spacemacs.org/">http://spacemacs.org/</a>
</li>

<li>Lisp: Common Lisp, Racket, Clojure, Emacs Lisp<br />
<a href="http://hyperpolyglot.org/lisp">http://hyperpolyglot.org/lisp</a>
</li>

<li>Common Lisp, Scheme, Clojure, And Elisp Compared<br />
<a href="http://irreal.org/blog/?p=725">http://irreal.org/blog/?p=725</a>
</li>

<li>Does Elisp Suck?<br />
<a href="http://irreal.org/blog/?p=675">http://irreal.org/blog/?p=675</a>
</li>

<li>Emacs pro mírně pokročilé (9): Elisp<br />
<a href="https://www.root.cz/clanky/emacs-elisp/">https://www.root.cz/clanky/emacs-elisp/</a>
</li>

<li>If I want to learn lisp, are emacs and elisp a good choice?<br />
<a href="https://www.reddit.com/r/emacs/comments/2m141y/if_i_want_to_learn_lisp_are_emacs_and_elisp_a/">https://www.reddit.com/r/emacs/comments/2m141y/if_i_want_to_learn_lisp_are_emacs_and_elisp_a/</a>
</li>

<li>Clojure(Script) Interactive Development Environment that Rocks!<br />
<a href="https://github.com/clojure-emacs/cider">https://github.com/clojure-emacs/cider</a>
</li>

<li>An Introduction to Emacs Lisp<br />
<a href="https://harryrschwartz.com/2014/04/08/an-introduction-to-emacs-lisp.html">https://harryrschwartz.com/2014/04/08/an-introduction-to-emacs-lisp.html</a>
</li>

<li>Emergency Elisp<br />
<a href="http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html">http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html</a>
</li>

<li>Lambda calculus<br />
<a href="https://en.wikipedia.org/wiki/Lambda_calculus">https://en.wikipedia.org/wiki/Lambda_calculus</a>
</li>

<li>John McCarthy's original LISP paper from 1959<br />
<a href="https://www.reddit.com/r/programming/comments/17lpz4/john_mccarthys_original_lisp_paper_from_1959/">https://www.reddit.com/r/programming/comments/17lpz4/john_mccarthys_original_lisp_paper_from_1959/</a>
</li>

<li>Micro Manual LISP<br />
<a href="https://www.scribd.com/document/54050141/Micro-Manual-LISP">https://www.scribd.com/document/54050141/Micro-Manual-LISP</a>
</li>

<li>How Lisp Became God's Own Programming Language<br />
<a href="https://twobithistory.org/2018/10/14/lisp.html">https://twobithistory.org/2018/10/14/lisp.html</a>
</li>

<li>History of Lisp<br />
<a href="http://jmc.stanford.edu/articles/lisp/lisp.pdf">http://jmc.stanford.edu/articles/lisp/lisp.pdf</a>
</li>

<li>The Roots of Lisp<br />
<a href="http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf">http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf</a>
</li>

<li>Racket<br />
<a href="https://racket-lang.org/">https://racket-lang.org/</a>
</li>

<li>The Racket Manifesto<br />
<a href="http://felleisen.org/matthias/manifesto/">http://felleisen.org/matthias/manifesto/</a>
</li>

<li>MIT replaces Scheme with Python<br />
<a href="https://www.johndcook.com/blog/2009/03/26/mit-replaces-scheme-with-python/">https://www.johndcook.com/blog/2009/03/26/mit-replaces-scheme-with-python/</a>
</li>

<li>Adventures in Advanced Symbolic Programming<br />
<a href="http://groups.csail.mit.edu/mac/users/gjs/6.945/">http://groups.csail.mit.edu/mac/users/gjs/6.945/</a>
</li>

<li>Why MIT Switched from Scheme to Python (2009)<br />
<a href="https://news.ycombinator.com/item?id=14167453">https://news.ycombinator.com/item?id=14167453</a>
</li>

<li>Starodávná stránka XLispu<br />
<a href="http://www.xlisp.org/">http://www.xlisp.org/</a>
</li>

<li>AutoLISP<br />
<a href="https://en.wikipedia.org/wiki/AutoLISP">https://en.wikipedia.org/wiki/AutoLISP</a>
</li>

<li>Seriál PicoLisp: minimalistický a výkonný interpret Lispu<br />
<a href="https://www.root.cz/serialy/picolisp-minimalisticky-a-vykonny-interpret-lispu/">https://www.root.cz/serialy/picolisp-minimalisticky-a-vykonny-interpret-lispu/</a>
</li>

<li>Common Lisp<br />
<a href="https://common-lisp.net/">https://common-lisp.net/</a>
</li>

<li>Getting Going with Common Lisp<br />
<a href="https://cliki.net/Getting%20Started">https://cliki.net/Getting%20Started</a>
</li>

<li>Online Tutorial (Common Lisp)<br />
<a href="https://cliki.net/online%20tutorial">https://cliki.net/online%20tutorial</a>
</li>

<li>Guile Emacs<br />
<a href="https://www.emacswiki.org/emacs/GuileEmacs">https://www.emacswiki.org/emacs/GuileEmacs</a>
</li>

<li>Guile Emacs History<br />
<a href="https://www.emacswiki.org/emacs/GuileEmacsHistory">https://www.emacswiki.org/emacs/GuileEmacsHistory</a>
</li>

<li>Guile is a programming language<br />
<a href="https://www.gnu.org/software/guile/">https://www.gnu.org/software/guile/</a>
</li>

<li>MIT Scheme<br />
<a href="http://groups.csail.mit.edu/mac/projects/scheme/">http://groups.csail.mit.edu/mac/projects/scheme/</a>
</li>

<li>SIOD: Scheme in One Defun<br />
<a href="http://people.delphiforums.com/gjc//siod.html">http://people.delphiforums.com/gjc//siod.html</a>
</li>

<li>CommonLispForEmacs<br />
<a href="https://www.emacswiki.org/emacs/CommonLispForEmacs">https://www.emacswiki.org/emacs/CommonLispForEmacs</a>
</li>

<li>Elisp: print, princ, prin1, format, message<br />
<a href="http://ergoemacs.org/emacs/elisp_printing.html">http://ergoemacs.org/emacs/elisp_printing.html</a>
</li>

<li>Special Forms in Lisp<br />
<a href="http://www.nhplace.com/kent/Papers/Special-Forms.html">http://www.nhplace.com/kent/Papers/Special-Forms.html</a>
</li>

<li>Basic Building Blocks in LISP<br />
<a href="https://www.tutorialspoint.com/lisp/lisp_basic_syntax.htm">https://www.tutorialspoint.com/lisp/lisp_basic_syntax.htm</a>
</li>

<li>Introduction to LISP - University of Pittsburgh<br />
<a href="https://people.cs.pitt.edu/~milos/courses/cs2740/Lectures/LispTutorial.pdf">https://people.cs.pitt.edu/~milos/courses/cs2740/Lectures/LispTutorial.pdf</a>
</li>

<li>Why don't people use LISP<br />
<a href="https://forums.freebsd.org/threads/why-dont-people-use-lisp.24572/">https://forums.freebsd.org/threads/why-dont-people-use-lisp.24572/</a>
</li>

<li>Structured program theorem<br />
<a href="https://en.wikipedia.org/wiki/Structured_program_theorem">https://en.wikipedia.org/wiki/Structured_program_theorem</a>
</li>

<li>Clojure: API Documentation<br />
<a href="https://clojure.org/api/api">https://clojure.org/api/api</a>
</li>

<li>Tutorial for the Common Lisp Loop Macro<br />
<a href="http://www.ai.sri.com/pkarp/loop.html">http://www.ai.sri.com/pkarp/loop.html</a>
</li>

<li>Common Lisp's Loop Macro Examples for Beginners<br />
<a href="http://www.unixuser.org/~euske/doc/cl/loop.html">http://www.unixuser.org/~euske/doc/cl/loop.html</a>
</li>

<li>A modern list api for Emacs. No 'cl required.<br />
<a href="https://github.com/magnars/dash.el">https://github.com/magnars/dash.el</a>
</li>

<li>The LOOP Facility<br />
<a href="http://www.lispworks.com/documentation/HyperSpec/Body/06_a.htm">http://www.lispworks.com/documentation/HyperSpec/Body/06_a.htm</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>Transient Data Structures
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Pixie: lehký skriptovací jazyk s „kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

<li>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/">https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/</a>
</li>

<li>Stránka projektu Jython<br />
<a href="http://www.jython.org/">http://www.jython.org/</a>
</li>

<li>Jython (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Jython">https://en.wikipedia.org/wiki/Jython</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">https://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>JSR 223: Scripting for the Java<sup>TM</sup> Platform<br />
<a href="https://jcp.org/en/jsr/detail?id=223">https://jcp.org/en/jsr/detail?id=223</a>
</li>

<li>List of JVM languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_JVM_languages">https://en.wikipedia.org/wiki/List_of_JVM_languages</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

