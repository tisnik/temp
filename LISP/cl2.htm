<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">2. Základní datové typy Lispu</a></p>
<p><a href="#k03">*** 3. Atomy</a></p>
<p><a href="#k04">4. Význam speciálních symbolů <strong>T</strong> a <strong>nil</strong></a></p>
<p><a href="#k05">*** 5. Uspořádané páry (<i>cons cell</i>)</a></p>
<p><a href="#k06">*** 6. CAR a CDR &ndash; operace pocházející z&nbsp;dob elektronkových sálových počítačů</a></p>
<p><a href="#k07">7. LISP = LISt Processor</a></p>
<p><a href="#k08">8. Vyhodnocování S-výrazů LISPem</a></p>
<p><a href="#k09">9. Prefixový zápis aritmetických a relačních výrazů</a></p>
<p><a href="#k10">10. Ale já chci používat &bdquo;lidský&ldquo; zápis aritmetických výrazů!</a></p>
<p><a href="#k11">11. Základní funkce pro práci se seznamy</a></p>
<p><a href="#k12">12. Funkce jako základní stavební kámen programů, pojmenování uživatelských funkcí</a></p>
<p><a href="#k13">13. Anonymní funkce</a></p>
<p><a href="#k14">14. Funkce s&nbsp;proměnným počtem parametrů</a></p>
<p><a href="#k15">15. Nepovinné parametry funkcí</a></p>
<p><a href="#k16">16. Parametry funkcí explicitně specifikované svým jménem</a></p>
<p><a href="#k17">17. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k18">18. Předchozí části seriálu</a></p>
<p><a href="#k19">19. Literatura</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>

<p><a href="http://imgs.xkcd.com/comics/lisp.jpg">Je Matrix napsaný v&nbsp;LISPu nebo v&nbsp;Perlu?</a></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Základní datové typy Lispu</h2>

<p>Základními datovými typy, se kterými se v&nbsp;<i>LISPu</i> (samozřejmě
včetně Common Lispu) pracuje, jsou <i>atomy</i> a <i>uspořádané páry</i>
(tečka-dvojice). Atomy jsou z&nbsp;hlediska tohoto programovacího jazyka
základními objekty, které není možné dále dělit (ostatně právě proto se také
označují jako <i>atomy</i>), ale je je možné ukládat do uspořádaných párů.
Atomy mohou být několika typů: jedná se především o <i>symboly</i> (například
<strong>ABC</strong>. A právě symboly jsou pro LISP typické a proto byl tento
jazyk použit v&nbsp;první generací &bdquo;AI aplikací&ldquo;). Dále patří mezi
atomy čísla (<strong>42</strong>, <strong>3.1415</strong> atd. &ndash; některé
interpretry jazyka LISP rozlišují celá čísla, čísla reálná, čísla komplexní a
někdy též zlomky, tj.&nbsp;čísla racionální), řetězce
(<strong>"pokus"</strong>, <strong>"velmi dlouhý řetězec"</strong>), vestavěné
funkce atd. Jak uvidíme dále, tak v&nbsp;reálných programech se atomy ukládají
do seznamů, přičemž pro označení začátku a konce seznamu se používají kulaté
závorky &ndash; levá závorka samozřejmě označuje začátek seznamu a pravá
závorka jeho konec (viz navazující kapitoly). Prvky/elementy seznamu jsou od
sebe odděleny alespoň jednou mezerou nebo koncem řádku, což mj.&nbsp;znamená,
že seznam může být rozepsán na více řádcích (to je velmi důležité ve chvíli,
kdy se pomocí seznamů reprezentují funkce).</p>

<p><div class="rs-tip-major">Poznámka: je dobré si uvědomit, že jak na atomy,
tak i na uspořádané páry je vhodné se dívat jako na <i>hodnoty</i>, které jsou
neměnné (<i>immutable</i>). Pokud se například v&nbsp;programu použije hodnota
42, nelze tuto hodnotu žádným způsobem změnit (ovšem lze z&nbsp;ní odvodit
jinou hodnotu <i>aplikací funkce</i>). To zajisté není nijak překvapivé, ovšem
totéž pravidlo platí (v&nbsp;klasických LISPech) i pro další typy atomů (včetně
řetězců) a taktéž pro uspořádané páry. A vzhledem k&nbsp;tomu, že seznamy jsou
tvořeny uspořádanými páry (jak uvidíme dále), je případná modifikace seznamu
možná jen výměnou nějakého páru za pár jiný.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Atomy</h2>

<p>Atomy se rozdělují do několika skupin</p>
numerické datové typy
cela cisla, fp, ratios

symboly
mohou obsahovat a takteze vetsinou obsahuji -

<p>Interní reprezentace atomů se může lišit od jejich tištěné (či zapisované)
reprezentace. Patrně nejvíce je to patrné na zlomcích (<i>rational</i>), které
jsou zjednodušeny:</p>

<pre>
* <strong>0/6</strong>
0
&nbsp;
* <strong>1/6</strong>
1/6
&nbsp;
* <strong>2/6</strong>
1/3
&nbsp;
* <strong>3/6</strong>
1/2
&nbsp;
* <strong>4/6</strong>
2/3
&nbsp;
* <strong>5/6</strong>
5/6
&nbsp;
* <strong>6/6</strong>
1
</pre>

<p>Pro zjištění (test), zda je argument atomem se používá predikát nazvaný
jednoduše <strong>atom</strong>. Pokud je argument předaný tomuto predikátu
skutečně atomem, vrátí se hodnota (symbol) <strong>T</strong>, v&nbsp;opačném
případě se vrátí <strong>nil</strong>:</p>

<pre>
* <strong>(atom nil)</strong>
T
&nbsp;
* <strong>(atom T)</strong>
T
&nbsp;
* <strong>(atom 42)</strong>
T
&nbsp;
* <strong>(atom 1/3)</strong>
T
&nbsp;
* <strong>(atom "foo")</strong>
T
&nbsp;
* <strong>(atom (list 1 2 3))</strong>
NIL
&nbsp;
* <strong>(atom '("uspořádaný" . "pár"))</strong>
NIL
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Význam speciálních symbolů <strong>T</strong> a <strong>nil</strong></h2>

<p>V&nbsp;<i>Common Lispu</i> (a taktéž i v&nbsp;mnoha dalších dialektech
LISPu, nikoli však v&nbsp;tomto významu ve Scheme) se setkáme se <i>speciálními
symboly</i> zapisovanými jako <strong>T</strong> a <strong>NIL</strong> (nebo
též malými písmeny, popř.&nbsp;T/nil). Tyto symboly jsou vždy definovány již
při inicializaci REPLu.</p>

<p>Jak se dozvíme v&nbsp;dalším textu, je zvláštním a v&nbsp;mnoha ohledech
důležitým typem seznamu <i>prázdný seznam</i>, který neobsahuje žádné prvky
(elementy) a proto je zapisován buď levou závorkou, za níž ihned následuje
závorka pravá (mezi závorkami se tedy nenachází žádný atom ani další seznam,
mohou se zde nacházet pouze mezery nebo konce řádků), nebo lze pro jeho zápis
alternativně použít symbol <strong>nil</strong>, který je ekvivalentní
prázdnému seznamu (současně se tímto symbolem označuje logická hodnota
nepravda, tj.&nbsp;prázdný seznam se v&nbsp;logických výrazech vyhodnocuje na
hodnotu <i>false</i>). Prázdný seznam a <strong>nil</strong> (či
<strong>NIL</strong>) jsou zcela ekvivalentní, takže je jedno, který ze zápisů
použijete. Současně je <strong>nil</strong> jediným objektem v&nbsp;LISPu,
který je současně symbolem i seznamem.</p>

<p>Konkrétně v&nbsp;SBCL se všechny následující vstupy (zapsané tučně)
vyhodnotí na NIL:</p>

<pre>
* <strong>'() </strong>
NIL
&nbsp;
* <strong>()</strong>
NIL
&nbsp;
* <strong>NIL</strong>
NIL
&nbsp;
* <strong>nil</strong>
NIL
</pre>

<p>Zatímco se <strong>nil</strong> v&nbsp;klasickém LISPu a tudíž i
v&nbsp;Common Lispu používá mj.&nbsp;i pro reprezentaci nepravdy, tedy hodnoty
<i>false</i>, je pro pravdivou hodnotu vyhrazen symbol <strong>T</strong> nebo
<strong>t</strong>. Prakticky vždy se však setkáme s&nbsp;tím, že
<strong>T</strong> je napsán verzálkou, zatímco zápis <strong>NIL/nil</strong>
je psán různě (jak verzálkami, tak i minuskami; já budu používat zápis
minuskami, který je kompatibilní i s&nbsp;dalšími programovacími jazyky, včetně
těch mainstreamových).</p>

<p><div class="rs-tip-major">Poznámka: jednou z&nbsp;poměrně zásadních
odlišností mezi <i>Scheme</i> a <i>LISPem</i> je rozdílná reprezentace
pravdivostních hodnot. Zatímco <i>LISP</i> považuje prázdný seznam
<strong>()</strong>, reprezentovaný též hodnotou <strong>nil</strong>, za
nepravdu a všechny ostatní hodnoty za pravdu (včetně vždy definovaného symbolu
<strong>T</strong>, jak již dobře víme), existuje ve <i>Scheme</i> jen jediná
globálně dostupná a v&nbsp;celém systému jedinečná nepravdivá hodnota
označovaná symbolem <strong>#f</strong>. Všechny ostatní objekty, včetně
prázdného seznamu, jsou považovány za hodnotu pravdivou, což může komplikovat
převody zdrojových kódů programů, protože v&nbsp;poměrně velkém množství
algoritmů se například zpracovávají seznamy takovým způsobem, že se z&nbsp;nich
postupně odebírají prvky a algoritmus skončí v&nbsp;případě odebrání posledního
prvku, neboť se prázdný seznam vyhodnotí na nepravdivou hodnotu. Odlišnosti
nalezneme i v&nbsp;Clojure, které rozlišuje mezi <strong>nil/false</strong> a
<strong>true</strong>, přičemž hodnoty <strong>true</strong> a
<strong>false</strong> odpovídají primitivním hodnotám jazyka Java (které jsou
již z&nbsp;principu jejich funkce jedináčci).</div></p>

<p>Další důležitou vlastností těchto symbolů je, že nejsou modifikovatelné a že
nelze vytvořit symbol se stejným jménem (který by teoreticky mohl přepsat
původní symbol a dokonce i změnit jeho význam). Ostatně si to můžeme velmi
snadno otestovat:</p>

<pre>
* <strong>(defvar T 42)</strong>
&nbsp;
debugger invoked on a SIMPLE-ERROR in thread
#&lt;THREAD "main thread" RUNNING {1000560083}&gt;:
  <u>Cannot proclaim a CONSTANT variable SPECIAL: T</u>
&nbsp;
Type HELP for debugger help, or (SB-EXT:EXIT) to exit from SBCL.
&nbsp;
restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.
&nbsp;
(SB-C::PROCESS-VARIABLE-DECLARATION T SPECIAL :SPECIAL)
0] 0
</pre>

<pre>
* <strong>(defvar NIL 42)</strong>
&nbsp;
debugger invoked on a SIMPLE-ERROR in thread
#&lt;THREAD "main thread" RUNNING {1000560083}&gt;:
  <u>Cannot proclaim a CONSTANT variable SPECIAL: NIL</u>
&nbsp;
Type HELP for debugger help, or (SB-EXT:EXIT) to exit from SBCL.
&nbsp;
restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.
&nbsp;
(SB-C::PROCESS-VARIABLE-DECLARATION NIL SPECIAL :SPECIAL)
0] 0  
</pre>

<pre>
* <strong>(setf T 42)</strong>
; in: SETF T
;     (SETF T 42)
; ==&gt;
;   (SETQ T 42)
; 
; caught ERROR:
;   <u>T is a constant and thus can't be set.</u>
; 
; compilation unit finished
;   caught 1 ERROR condition
&nbsp;
debugger invoked on a SB-INT:COMPILED-PROGRAM-ERROR in thread
#&lt;THREAD "main thread" RUNNING {1000560083}&gt;:
  Execution of a form compiled with errors.
Form:
  (SETQ T 42)
Compile-time error:
  <u>T is a constant and thus can't be set.</u>
&nbsp;
Type HELP for debugger help, or (SB-EXT:EXIT) to exit from SBCL.
&nbsp;
restarts (invokable by number or by possibly-abbreviated name):
  0: [ABORT] Exit debugger, returning to top level.
&nbsp;
((LAMBDA ()))
   source: (SETF T 42)
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Uspořádané páry (<i>cons cell</i>)</h2>

<p>V&nbsp;úvodním textu jsme si řekli, že programovací jazyk <i>LISP</i> je založen na zpracování seznamů, ostatně odtud pochází i jeho název. Jak jsou však seznamy uloženy v&nbsp;operační paměti počítače a jak s&nbsp;nimi interpretry tohoto jazyka pracují? Základní interní strukturou, která je však dostupná i programátorům aplikací v&nbsp;jazyce <i>LISP</i>, je takzvaný uspořádaný pár (<i>cons cell</i>), jenž se někdy označuje i jako <i>tečka-dvojice</i> (dotted-pair). Tuto strukturu si můžeme představit jako dvojici ukazatelů, přičemž každý z&nbsp;těchto ukazatelů může obsahovat adresu atomu, adresu další tečka-dvojice nebo speciální hodnotu <strong>nil</strong> odpovídající v&nbsp;céčku hodnotě <strong>NULL</strong> či v&nbsp;Javě hodnotě <strong>null</strong>, tj.&nbsp;jedná se o speciální hodnotu, která interpretru říká, že daný ukazatel neobsahuje žádný odkaz (a současně značí <i>false</i> a aby toho nebylo málo, tak navíc i prázdný seznam). Uspořádaný pár je možné v&nbsp;LISPovských programech zapisovat formou dvojice výrazů (takzvaných S-výrazů) oddělených tečkou, které jsou uzavřeny do kulatých závorek (i když je pravda, že se s&nbsp;tímto zápisem v&nbsp;reálných programech příliš často nesetkáme, především z&nbsp;důvodu nepřehledného zápisu s&nbsp;velkým množstvím závorek):</p>

<p>Základní způsob zápisu tečkového páru:</p>

<pre>
'(1 . 2)
(1 . 2)
</pre>

<p>Musí se skutečně jednat o pár, což je hlídáno:</p>

<pre>
'(1 . 2 . 3)
(1 . 2) -- Bad dotted pair
</pre>

<p>Složitější datová struktura tvořená rekurzivně zanořenými tečkovými
páry:</p>

<pre>
'(1 . ((2 . 3) . 4))
(1 (2 . 3) . 4)
</pre>

<p>Zde se opět pokoušíme o vytvoření trojice:</p>

<pre>
'(1 . (2 . 3) . 4)
(1 2 . 3) -- Bad dotted pair
</pre>

<p>V&nbsp;Common Lispu je vždy nutné interpretru zakázat pokus o vyhodnocení zadáním apostrofu:</p>

<pre>
'((1 . 2) . (3 . 4))
((1 . 2) 3 . 4)
</pre>

<p>A nyní přichází na řadu velmi zajímavá vlastnost: rekurzivní tečkové páry zakončené dvojicí (atom . NIL) vytvoří seznam, resp.&nbsp;přesněji řečeno seznam je pouze syntaktickým cukrem pro takto vytvořenou datovou strukturu:</p>

<pre>
'(1 . (2 . (3 . NIL)))
(1 2 3)
</pre>

<p>Dtto platí při použití prázdného seznamu jako ukončovacího prvku (prázdný
seznam je při zpracování a vyhodnocování totožný s&nbsp;NIL):</p>

<pre>
'(1 . (2 . (3 . ())))
(1 2 3)
</pre

<p><div class="rs-tip-major">Poznámka: levý prvek tohoto páru je tradičně označován zkratkou <strong>car</strong> a pravý prvek zkratkou <strong>cdr</strong>. Důvody budou uvedeny v&nbsp;následující kapitole.</div></p>

<pre>
; vytvoření následující paměťové struktury
;   .
;  / \
; A   B
;
(cons 'a 'b)
(A . B)

; vytvoření jednoprvkového seznamu ze symbolu (atomu)
; vytvoří se tato struktura:
;   .
;  / \
; A   nil
;
(cons 'a nil)
(A)

; složitější příklady
(cons '(a b) 'c)
((A B) . C)
; výsledkem je následující struktura
;       .
;      / \
;     .   C
;    / \
;   A   .
;      / \
;     B   nil

; tento příklad je zajímavý, protože první i druhá část
; vytvořené tečka dvojice je sama o sobě seznamem
(cons '(a b) '(c d))
((A B) C D)

; asi nejtypičtější použití funkce cons: přidání
; prvku na začátek seznamu
(cons 'a '(b c d))
(A B C D)
; výsledkem je následující struktura:
;     .
;    / \
;   A   .
;      / \
;     B   .
;        / \
;       C   .
;          / \
;         D   nil

; pokus o přidání jediného prvku na konec seznamu
; pomocí funkce cons se nepodaří
(cons '(a b c) 'd)
((A B C) . D)
; výsledkem je následující struktura
;       .
;      / \
;     .   D
;    / \
;   A   .
;      / \
;     B   .
;        / \
;       C   nil
; která se seznamu podobá jen velmi vzdáleně

; funkce append je v tomto případě výhodnější,
; jen si musíme dát pozor na to, že se spojují
; dva seznamy, nikoli seznam a atom
(append '(a b c) '(d))
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. CAR a CDR &ndash; operace pocházející z&nbsp;dob elektronkových sálových počítačů</h2>

<p>Pro přístup k&nbsp;informaci (atomu či další tečka dvojici), na kterou odkazuje první ukazatel tečka dvojice, se používá primitivní funkce s&nbsp;prapodivným jménem <strong>CAR</strong>, a pro přístup k&nbsp;informaci, na níž se odkazuje druhý ukazatel, lze použít funkci <strong>CDR</strong>. Common Lisp rozeznává i přece jen logičtější funkce <strong>FIRST</strong> a <strong>REST</strong> se stejným významem, jak mají <strong>CAR</strong> a <strong>CDR</strong>. Používat je možné oba způsoby pojmenování obou zmíněných operací, ovšem odkud se <strong>CAR</strong> a <strong>CDR</strong> vzaly?</p>

<p>První implementace programovacího jazyka <i>LISP</i> vznikla na sálovém počítači <i>IBM 704</i>, který byl založený na technologii elektronek a feritových pamětí. Tento počítač, přesněji řečeno jeho aritmeticko-logická jednotka, dokázal zpracovávat numerické či znakové hodnoty uložené ve slovech, jejichž šířka byla rovna 36 bitům (jednalo se buď o celá čísla se znaménkem, čísla uložená ve formátu plovoucí řádové čárky či šestici znaků, z&nbsp;nichž každý byl uložen v&nbsp;šesti bitech). Operační paměť počítače <i>IBM 704</i> byla z&nbsp;hlediska zpracování dat organizována po slovech o šířce 36 bitů (viz předchozí text), přičemž celkový počet těchto slov uložených v&nbsp;paměti mohl nabývat hodnot 4096, 8192 či 32768, což odpovídá postupně 18 kB, 36 kB a 144 kB (pro představu &ndash; v&nbsp;posledním případě musela feritová paměť obsahovat přes jeden milion feritových jadérek a několik desítek tisíc vodičů).  Právě 36bitová šířka zpracovávaných slov měla velký vliv na způsob uložení datových struktur <i>LISPu</i> v&nbsp;operační paměti, jak si ostatně řekneme v&nbsp;navazujícím odstavci.</p>

<a href="http://i.iinfo.cz/images/118/ibm07.jpg"><img src="http://i.iinfo.cz/images/118/ibm07-prev.jpg" alt="ibm07" height="270" width="331" /></a>
<p><i>Obrázek 2: Sálový počítač IBM-704.</i></p>

<p>Způsob interní konstrukce uspořádaných párů v&nbsp;původní podobě vychází přímo z&nbsp;architektury počítače IBM 704, který používal 15bitové adresy, čemuž odpovídá v&nbsp;předchozím odstavci zmíněný maximální počet 32768 adresovatelných slov. V&nbsp;každém 36bitovém slově bylo možné uložit dvě 15bitové adresy nazvané podle svého významu <i>address</i> a <i>decrement</i>.  Počítač IBM 704 obsahoval instrukce, pomocí nichž bylo možné jednu z&nbsp;částí <i>address</i> či <i>decrement</i> z&nbsp;36bitového slova získat a uložit ji do index registru, jenž se používal při adresování operandů strojových instrukcí. Tvůrci první implementace jazyka <i>LISP</i> tuto možnost využili &ndash; ukládali tečka-dvojice do 36bitového slova rozděleného na čtyři části: <i>prefix</i> (3 bity), <i>address</i> (15 bitů), <i>decrement</i> (15 bitů) a <i>tag</i> (3 bity). Původně v&nbsp;LISPu existovaly čtyři funkce, pomocí nichž bylo možné získat jednu ze čtyř částí 36bitového slova představujícího tečka dvojici:</p>

<table>
<tr><th>Primitivní funkce</th><th>Význam</th></tr>
<tr><td>CAR</td><td>Contents of the Address part of Register</td></tr>
<tr><td>CDR</td><td>Contents of the Decrement part of Register</td></tr>
<tr><td>CPR</td><td>Contents of the Prefix part of Register</td></tr>
<tr><td>CTR</td><td>Contents of the Tag part of Register</td></tr>
</table>

<p>Z&nbsp;těchto funkcí nakonec ve finální verzi <i>LISPu</i> zůstaly pouze funkce <strong>CAR</strong> a <strong>CDR</strong>, které můžeme nalézt v&nbsp;prakticky každém dialektu tohoto jazyka. Druhou oblastí, v&nbsp;níž se projevila architektura počítače IBM 704, byl způsob správy paměti. Původně chtěli tvůrci <i>LISPu</i> použít metodu počítání referencí na objekty (<i>reference counting</i>), ovšem to bylo poměrně problematické &ndash; v&nbsp;každém 36bitovém slově zbylo pouhých šest bitů (<i>prefix</i> a <i>tag</i>), navíc rozmístěných takovým způsobem, že jejich sloučení bylo poměrně obtížné. Použití čítačů referencí by tedy vedlo k&nbsp;nutnosti změny významu všech bitů v&nbsp;36bitovém slově, do čehož se autorům LISPu evidentně nechtělo :-) Proto namísto čítače referencí implementovali automatickou správu paměti pomocí plnohodnotného <i>garbage collectoru</i>, který dokázal pracovat korektně i v&nbsp;případech, kdy se vytvořila datová struktura obsahující cyklus (viz též následující části tohoto seriálu).</p>

<p><div class="rs-tip-major">Poznámka: s&nbsp;velkou pravděpodobností se jednalo o první využití garbage collectoru v&nbsp;široce používaném obecném programovacím jazyce.</p></div></p>

<p>Kromě funkcí <strong>CAR</strong> a <strong>CDR</strong> vznikly i další &bdquo;variace na dané téma&ldquo;, například funkce <strong>CAAR</strong> odpovídající volání <strong>(CAR (CAR ...))</strong>. V&nbsp;následující tabulce jsou často použité varianty funkcí <strong>CAR</strong> a <strong>CDR</strong> vypsány (totéž ovšem nelze udělat s&nbsp;funkcemi <strong>FIRST</strong> a <strong>REST</strong>; zde je patrné, jak důležité je v&nbsp;informatice správné pojmenování):</p>

<table>
<tr><th>Funkce</th><th>Výslovnost</th><th>Alternativní jméno</th></tr>
<tr><td>CAR</td><td>kar</td><td>FIRST</td></tr>
<tr><td>CDR</td><td>cou der</td><td>REST</td></tr>
<tr><td>CAAR</td><td>ka ar</td><td>&nbsp;</td></tr>
<tr><td>CADR</td><td>kae der</td><td>SECOND</td></tr>
<tr><td>CDAR</td><td>cou dar</td><td>&nbsp;</td></tr>
<tr><td>CDDR</td><td>cou dih-der</td><td>&nbsp;</td></tr>
<tr><td>CAAAR</td><td>ka a-ar</td><td>&nbsp;</td></tr>
<tr><td>CAADR</td><td>ka ae-der</td><td>&nbsp;</td></tr>
<tr><td>CADAR</td><td>ka dar</td><td>&nbsp;</td></tr>
<tr><td>CADDR</td><td>ka dih-der</td><td>THIRD</td></tr>
<tr><td>CDAAR</td><td>cou da-ar</td><td>&nbsp;</td></tr>
<tr><td>CDADR</td><td>cou dae-der</td><td>&nbsp;</td></tr>
<tr><td>CDDAR</td><td>cou dih-dar</td><td>&nbsp;</td></tr>
<tr><td>CDDDR</td><td>cou did-dih-der</td><td>&nbsp;</td></tr>
<tr><td>CADDDR</td><td>ka dih-dih-der</td><td>FOURTH</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: kdysi jsem četl pěkné porovnání uspořádaných dvojic s&nbsp;konceptem DNA. Tedy to, co je pro IT uspořádaná dvojice (zcela základní struktura, která umožňuje spojovat &bdquo;atomy&ldquo; do větších struktur), tím je DNA (a RNA) v&nbsp;biologii.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. LISP = LISt Processor</h2>

<p>S&nbsp;využitím uspořádaných párů zmíněných <a href="#k05">v&nbsp;páté
kapitole</a> je možné vytvořit klasický seznam následujícím způsobem:
<i>první</i> ukazatel každého n-tého uspořádaného páru odkazuje na n-tý prvek
seznamu (například na atom, řekněme na číslo 42 či symbol A), <i>druhý</i>
ukazatel se pak odkazuje na další (n plus první) uspořádaný pár. Speciálním
případem je poslední uspořádaný pár, jehož druhý ukazatel obsahuje výše
uvedenou speciální hodnotu <strong>nil</strong>. Z&nbsp;následujícího příkladu
(obsahujícího ekvivalentní datové struktury) je patrné, že použití syntaxe pro
zápis seznamů je pro uživatele přehlednější a současně i kratší, než explicitní
zápis uspořádaných párů; ovšem právě znalost vnitřní reprezentace seznamů
pomocí uspořádaných párů nám umožňuje pochopit, jak pracují některé základní
funkce, včetně již zmíněných funkcí <strong>CAR</strong> a
<strong>CDR</strong>:</p>

<pre>
<i>; seznam zapsaný s využitím uspořádaných párů</i>
<strong>'(1 . (2 . (3 . (4 . (5 . nil)))))</strong>
(1 2 3 4 5)
&nbsp;
<i>; běžný způsob zápisu seznamu</i>
<strong>'(1 2 3 4 5)</strong>
(1 2 3 4 5)
&nbsp;
</pre>

<p>Takto zapsané seznamy jsou z&nbsp;hlediska jazyka Common Lisp
ekvivalentní:</p>

<pre>
<strong>(equal '(1 . (2 . (3 . (4 . (5 . nil))))) '(1 2 3 4 5))</strong>
T
</pre>

<p>Interní struktura seznamu uloženého v&nbsp;paměti bude vypadat takto (bude
tedy přesně odpovídat prvnímu zápisu):</p>

<pre>
<i>;         .</i>
<i>;        / \</i>
<i>;       1   .</i>
<i>;          / \</i>
<i>;         2   .</i>
<i>;            / \</i>
<i>;           3   .</i>
<i>;              / \</i>
<i>;             4   .</i>
<i>;                / \</i>
<i>;               5   nil</i>
</pre>

<p>Na tomto místě poznamenejme, že další struktury vytvořené s&nbsp;využitím
rekurzivně zanořených uspořádaných párů není možné převést na běžné seznamy.
Například jednoduchý binární strom se třemi úrovněmi a čtyřmi listy lze
reprezentovat buď pomocí uspořádaných párů (v&nbsp;operační paměti se vytvoří
skutečná obdoba binárního stromu), popř.&nbsp;je možné tuto datovou strukturu
&bdquo;simulovat&ldquo; pomocí seznamů (ovšem v&nbsp;tomto případě bude
paměťová náročnost vyšší kvůli nutnosti ukončení všech podseznamů uspořádaným
párem obsahujícím ve svém druhém ukazateli hodnotu <strong>nil</strong>):</p>

<pre>
<i>; binární strom se třemi úrovněmi a čtyřmi listy vytvořený pomocí tečka dvojic</i>
<strong>'((A . B) . (C . D))</strong>
((A . B) C . D)
&nbsp;
<i>; interní podoba této struktury v operační paměti:</i>
<i>;        .</i>
<i>;       / \</i>
<i>;      .   .</i>
<i>;     / \ / \</i>
<i>;     A B C D</i>
&nbsp;
&nbsp;
<i>; binární strom vytvořený pomocí LISPovských seznamů</i>
<strong>'((A B) (C D))</strong>
((A B) (C D))
&nbsp;
<i>; interní podoba této struktury v operační paměti:</i>
<i>;          .</i>
<i>;         / \</i>
<i>;        /   \</i>
<i>;       /     \</i>
<i>;      /       \</i>
<i>;     .         .</i>
<i>;    / \       / \</i>
<i>;    A  .     .  nil</i>
<i>;      / \   / \</i>
<i>;      B nil C  .</i>
<i>;              / \</i>
<i>;              D nil</i>
</pre>

<p><div class="rs-tip-major">Poznámka: takto přímočaře nelze reprezentovat
jakýkoli graf. Například se jedná o graf s&nbsp;cyklem, řekněme cyklický
buffer. Pro tyto účely se používá dvojice kroků &ndash; vytvoření acyklické
struktury a přidání poslední vazby, která vytvoří cyklický graf:</div></p>

<pre>
<strong>(defvar c (list 1 2 3 4))</strong>
C
&nbsp;
<strong>c</strong>
(1 2 3 4)
&nbsp;
<i>; nutno použít pro zabránění nekonečnému výpisu</i>
<strong>(setq *print-circle* T)</strong>
T
&nbsp;
<i>; poslední vazba - vytvoření cyklu v grafu</i>
<strong>(setf (cdr (last c)) c)</strong>
#1=(1 2 3 4 . #1#)
&nbsp;
<strong>c</strong>
#1=(1 2 3 4 . #1#)
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Vyhodnocování S-výrazů LISPem</h2>

<p>Programy jsou v&nbsp;klasickém <i>LISPu</i> a tudíž i v&nbsp;Common Lispu
zapisovány &ndash; podobně jako data, se kterými tyto programy pracují &ndash;
taktéž pomocí seznamů, přičemž prvním prvkem takového seznamu je symbol nějaké
funkce. Interpretry <i>LISPu</i> jsou někdy (dodejme, že poněkud nepřesně)
označovány zkratkou <i>REPL</i>, která naznačuje, jakým způsobem jsou programy,
resp.&nbsp;jednotlivé výrazy, ze kterých se programy skládají, zpracovávány:
Read&ndash;Eval&ndash;Print&ndash;Loop. Ve skutečnosti však mnoho implementací
<i>LISPu</i> obsahuje i plnohodnotné překladače, které mnohdy produkují
optimalizovaný kód srovnatelný například s&nbsp;výsledky Céčkových překladačů
(což je případ <i>Common Lispu</i>).</p>

<p>Dnes si způsob zápisu programů popíšeme do větších podrobností. Základem
interpretace každého LISPovského programu je načtení a rozpoznání jednoho
výrazu (<i>read</i>), vyhodnocení tohoto výrazu (<i>eval</i>) a následný tisk
výsledné hodnoty výrazu na standardní výstup (<i>print</i>). Pravidla pro
vyhodnocení výrazů (někdy se též můžeme setkat s&nbsp;termínem
&bdquo;vyhodnocení forem&ldquo;) jsou v&nbsp;LISPu velmi jednoduchá a
přímočará, na rozdíl od mnoha jiných programovacích jazyků (vlastně na rozdíl
od všech mainstreamových jazyků). Tato pravidla lze ve zjednodušené podobě
sepsat do pouhých několika bodů:</p>

<ol>

<li>čísla a řetězce jsou literály, které jsou vyhodnoceny samy na sebe (což je
logické &ndash; jedná se o dále nedělitelné objekty, tedy o nám již známé
<i>atomy</i>)</li>

<li>hodnotou <i>symbolu</i> je objekt, který je na tento symbol navázán
(analogie z&nbsp;jiných programovacích jazyků &ndash; hodnotou proměnné zapsané
svým jménem je hodnota uložená do proměnné)</li>

<li><i>seznamy</i> jsou vyhodnocovány tak, že se první prvek seznamu chápe jako
jméno funkce (či jako jméno speciální formy), které je předán zbytek seznamu
jako parametry této funkce (nebo speciální formy)</li>

<li>v&nbsp;případě, že seznam obsahuje podseznamy, jsou tyto podseznamy
vyhodnoceny nejdříve, přičemž úroveň rekurzivního zanořování při vyhodnocování
podseznamů není teoreticky omezena (tj.&nbsp;podseznamy lze vnořovat do téměř
libovolné úrovně)</li>

</ol>

<p>Ukažme si nyní vyhodnocování výrazů na několika velmi jednoduchých
příkladech. První řádek uvedený pod poznámkou (uvozenou znakem
<strong>;</strong>) představuje text zapsaný uživatelem na klávesnici, řádek
druhý vypisuje samotný LISP (tedy například SBCL):</p>

<pre>
<i>; vyhodnocení číselné hodnoty (konstanty)</i>
<strong>42</strong>
42
&nbsp;
<i>; vyhodnocení číselné hodnoty (konstanty), ovšem ve tvaru zlomku</i>
<strong>1/3</strong>
1/3
&nbsp;
<i>; zlomky se automaticky zjednodušují</i>
<strong>10/2</strong>
5
&nbsp;
<i>; vyhodnocení speciálního symbolu <strong>nil</strong></i>
<strong>nil</strong>
NIL
&nbsp;
<i>; vyhodnocení speciálního symbolu <strong>T</strong></i>
<strong>T</strong>
T
&nbsp;
<i>; nil je současně zcela ekvivalentní prázdnému seznamu (což již víme)</i>
<strong>()</strong>
NIL
&nbsp;
<i>; vyhodnocení řetězce</i>
<strong>"www.root.cz"</strong>
"www.root.cz"
&nbsp;
<i>; vyhodnocení seznamu obsahujícího jako první prvek funkci</i>
<strong>(max 10 20)</strong>
20
&nbsp;
<i>; vyhodnocení seznamu obsahujícího další seznamy (každý podseznam v&nbsp;tomto případě znamená volání funkce)</i>
<strong>(max (min 10 20) (min 30 40))</strong>
30
&nbsp;
<i>; zákaz vyhodnocení seznamu speciální formou <strong>quote</strong></i>
<strong>(quote (max 10 20))</strong>
(MAX 10 20)
&nbsp;
<i>; zákaz vyhodnocení seznamu zkrácenou speciální formou <strong>quote</strong></i>
<strong>'(max 10 20)</strong>
(MAX 10 20)
&nbsp;
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Prefixový zápis aritmetických a relačních výrazů</h2>

<p>Zatímco v&nbsp;naprosté většině &bdquo;mainstreamových&ldquo; programovacích
jazyků, jakými jsou například klasické <i>Céčko</i>, <i>Java</i>,
<i>JavaScript</i>, <i>Go</i> či <i>Python</i>, se aritmetické a logické výrazy
zapisují v&nbsp;takzvané <i>infixové notaci</i>, při níž jsou binární operátory
zapisovány mezi dvojici operandů, tvůrci jazyka <i>LISP</i> se od tohoto
způsobu zápisu distancovali &ndash; namísto toho jsou v&nbsp;<i>LISPu</i> (a
tudíž i v&nbsp;Common Lispu) všechny základní aritmetické i logické (a
samozřejmě též relační) operace zapisovány jako volání funkcí (přesněji řečeno
se skutečně jedná o funkce, dokonce o funkce variadické), tj.&nbsp;vždy
v&nbsp;<i>prefixové podobě</i>. Důvodů, proč byla zvolena tato forma zápisu
výrazů, je více. Prvním důvodem je fakt, že syntaxe <i>LISPu</i> byl navrhována
s&nbsp;tím, že později dojde k&nbsp;jejím dalším modifikacím, tj.&nbsp;samotná
syntaxe nebyla pro tvůrce tohoto programovacího jazyka tak prioritní jako jeho
sémantika (paradoxní přitom je, že se nakonec syntaxe <i>LISPu</i> nezměnila,
takzvané M-výrazy se nedočkaly většího rozšíření, podobně jako další snahy o
úpravu syntaxe <i>LISPu</i> tak, aby se eliminovalo množství závorek či právě
prefixový zápis aritmetických výrazů).</p>

<p>Druhý důvod spočíval v&nbsp;tom, že zavedení infixových operátorů by do
programovacího jazyka zavádělo další komplikace: musely by se například řešit a
přesně specifikovat priority operací (a u některých operací i jejich
asociativita), se zapsanými výrazy by se složitěji prováděly různé symbolické
manipulace (integrace, derivace, zjednodušování výrazů), infixové operátory by
nebylo možné předávat jako parametry do jiných funkcí atd. Vzhledem
k&nbsp;tomu, že aritmetické operátory jsou v&nbsp;<i>LISPu</i> zapisovány jako
volání funkcí, musí se znak či jméno příslušného operátoru uvádět ve
vyhodnocovaném seznamu na prvním místě, podobně jako jméno jakékoli jiné
funkce. Všechny dílčí podvýrazy se samozřejmě vyhodnocují dříve než celý výraz,
což plně koresponduje s&nbsp;pravidly, která jsme si uvedli v&nbsp;předchozí
kapitole (podvýraz je zapsán formou volání nějaké funkce). Většina
aritmetických funkcí není omezena pouze na dva parametry, což znamená, že je
například možné zavoláním jedné funkce nazvané <strong>+</strong> sečíst i více
než dvě numerické hodnoty:</p>

<pre>
<i>; unární varianty</i>
<strong>(+ 1)</strong>
1
&nbsp;
<strong>(- 1)</strong>
-1
&nbsp;
<i>; převrácená hodnota</i>
<strong>(/ 2)</strong>
1/2
&nbsp;
<i>; identita</i>
<strong>(* 2)</strong>
2
&nbsp;
<i>; začneme pozvolna jako na základní škole :-)</i>
<strong>(+ 1 1)</strong>
2
&nbsp;
<i>; operace rozdílu - druhý argument funkce je odečten od prvního</i>
<strong>(- 1 2)</strong>
-1
&nbsp;
<i>; součet řady čísel</i>
<strong>(+ 1 2 3 4 5 6 7 8 9 10)</strong>
55
&nbsp;
<i>; níže uvedený výraz v infixové notaci odpovídá: 1-2-3-4-5....-10:</i>
<strong>(- 1 2 3 4 5 6 7 8 9 10)</strong>
-53
&nbsp;
<i>; POZOR - závorky v LISPu nemají mnoho společného</i>
<i>; s vyjádřením priority aritmetických operací</i>
<i>; (nelze je použít tak volně jako například v céčku)</i>
<strong>(* (+ 1 2) (+ 3 4))</strong>
21
&nbsp;
<strong>(+ (* 1 2) (* 3 4))</strong>
14
&nbsp;
<i>; Některé implementace LISPu, například i zde popisovaný Common Lisp,</i>
<i>; dokážou pracovat se zlomky, tj. snaží se racionální</i>
<i>; čísla vyjádřit formou zlomku (ideální jazyk do škol :-)</i>
<strong>(/ 1 2)</strong>
1/2
&nbsp;
<strong>(/ 1 2 3)</strong>
1/6
&nbsp;
<strong>(/ 3 2)</strong>
3/2
&nbsp;
<i>; zkusíme výpočet složitějšího zlomku</i>
<strong>(/ (+ 1 2) (+ 3 4))</strong>
3/7
&nbsp;
<i>; neracionální (reálná) čísla se vypisují tak, jak to</i>
<i>; známe z ostatních programovacích jazyků (samozřejmě</i>
<i>; v případě speciálních požadavků programátora lze použít</i>
<i>; různé formátovací funkce na úpravu výstupu)</i>
<strong>(* 0.3 (/ (+ 1 2) (+ 3 4)))</strong>
0.12857144
</pre>

<p>Programovací jazyk <i>LISP</i> obsahuje i úplnou sadu relačních operátorů,
které v&nbsp;závislosti na hodnotách předaných parametrů (operandů) vrací
hodnotu <strong>T</strong> (pravda) či <strong>nil</strong> (nepravda).
Povšimněte si, že konstanta <strong>nil</strong> má v&nbsp;LISPu poměrně velké
množství různých významů:</p>

<pre>
<i>; porovnání dvou číselných hodnot</i>
<i>; relace "menší než"</i>
<strong>(&lt; 1 2)</strong>
T
&nbsp;
<i>; relace "větší než"</i>
<strong>(&gt; 1 2)</strong>
NIL
&nbsp;
<i>; postupné porovnání hodnot (první-druhá atd.)</i>
<strong>(&lt; 1 2 3 4)</strong>
T
&nbsp;
<strong>(&lt; 3 1 2 4 5)</strong>
NIL
&nbsp;
<i>; relace "menší nebo rovno"</i>
<strong>(&lt;= 1 2)</strong>
T
&nbsp;
<i>; relace "větší nebo rovno"</i>
<strong>(&gt;= 1 2)</strong>
NIL
&nbsp;
<i>; porovnání dvou výrazů na ekvivalenci</i>
<strong>(equal 1 2)</strong>
NIL
&nbsp;
<strong>(equal 1 1)</strong>
T
&nbsp;
<i>; podvýrazy se nejprve vyhodnotí a posléze se porovnají</i>
<i>; vyhodnocené výsledky (v tomto případě dva atomy)</i>
<strong>(equal (+ 1 1) (/ 4 2))</strong>
T
&nbsp;
<i>; na ekvivalenci lze porovnávat i seznamy, nikoli pouze atomy</i>
<strong>(equal '(1 2) '(1 2))</strong>
T
&nbsp;
<strong>(equal '(1 2) '(2 1))</strong>
NIL
&nbsp;
<i>; nil se sice v některých pohledech podobá klíčovému slovu</i>
<i>; NULL z SQL ovšem způsob vyhodnocování této konstanty</i>
<i>; v LISPovských výrazech je poněkud odlišný</i>
<strong>(equal nil nil)</strong>
T
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Ale já chci používat &bdquo;lidský&ldquo; zápis aritmetických výrazů!</h2>

<p>V&nbsp;případě, že se má v&nbsp;nějaké <i>LISPovské</i> aplikaci použít
větší množství výpočtů, jež by mohly být při použití prefixové notace
nepřehledné, je možné použít hned několik knihoven, které slouží
k&nbsp;transformaci výrazů zapsaných infixově (tedy &bdquo;tak jak nás to učili
ve škole&ldquo;, včetně priorit) do prefixové podoby. Některé z&nbsp;těchto
knihoven dokonce dokážou výrazy různým způsobem zjednodušovat či kombinovat.
Například knihovna (spíše knihovnička, protože se skládá jen z&nbsp;několika
málo funkcí a maker) <a
href="https://github.com/quil-lang/cmu-infix">cmu-infix</a> určená pro Common
Lisp nabízí uživatelům funkci <strong>#I</strong> (ano, i takové názvy funkcí
je možné v&nbsp;LISPu použít, a to z&nbsp;toho důvodu, že znaky
<strong>-</strong>, <strong>#</strong> či <strong>&gt;</strong> nemají díky
absenci operátorů žádný speciální význam), kterou lze použít způsobem ukázaným
na následujícím jednoduchém příkladu. Povšimněte si, že mezi operandy a
operátory nemusí být zapsány mezery, protože knihovna provádí vlastní parsing
výrazů (jiné podobně zaměřené knihovny ovšem mezery vyžadují).</p>

<p>Výpočet délky vektoru popř.&nbsp;přepony pravoúhlého trojúhelníku:</p>

<pre>
#I( sqrt(a^^2 + b^^2) ))
</pre>

<p>Použít lze i relační a logické operátory:</p>

<pre>
#I( n != 0 and (n &amp; (n - 1)) == 0 ))
</pre>

<p>A konečně si ukažme třetí příklad získaný z&nbsp;oficiální dokumentace této
knihovny. Jedná se o definici funkce pro maticový součin:</p>

<pre>
(defun matmul (A B)
  "Compute C = A * B for matrices A and B."
  (let* ((m (array-dimension A 0))
         (n (array-dimension A 1))
         (q (array-dimension B 1))
         (C (make-array (list m q) :initial-element 0)))
    (loop :for i :below m :do
      (loop :for k :below q :do
        (loop :for j :below n :do
          #I( C[i, k] += A[i, j] * B[j, k] ))))
    C))
</pre>

<p><div class="rs-tip-major">Poznámka: matice a vektory budou popsány
příště.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Základní funkce pro práci se seznamy</h2>

<p>Z&nbsp;popisu programovacího jazyka <i>LISP</i> uvedeného v&nbsp;předchozích
kapitolách již víme, jakým způsobem se v&nbsp;tomto jazyku zapisují seznamy a
dokonce známe i dvě funkce sloužící pro získání prvního prvku seznamu
(<strong>car</strong> neboli <strong>first</strong>) a naopak zbytku seznamu
bez jeho prvního prvku (<strong>cdr</strong> neboli <strong>rest</strong>).
Vzhledem k&nbsp;tomu, že práce se seznamy tvoří poměrně podstatnou část
činnosti programátorů při psaní aplikací, obsahuje programovací jazyk
<i>LISP</i> ve své základní knihovně i mnohé další funkce, s&nbsp;jejichž
pomocí je možné se seznamy různým způsobem manipulovat. Některé
z&nbsp;nejčastěji používaných funkcí jsou vypsány v&nbsp;následující tabulce.
Jedná se o funkce dostupné v&nbsp;dialektu Common Lisp, proto se
v&nbsp;některých jiných dialektech můžete setkat s&nbsp;odlišným pojmenování
některých funkcí (například se namísto predikátu <strong>LISTP</strong> používá
<strong>LIST?</strong>):</p>

<table>
<tr><th>Jméno funkce</th><th>Význam</th></tr>
<tr><td>CONS</td><td>základní funkce &ndash; přidání dalšího elementu do seznamu popř. konstrukce uspořádaného páru (dvojice)</td></tr>
<tr><td>LAST</td><td>vrací poslední prvek seznamu</td></tr>
<tr><td>NTH</td><td>vrací n-tý prvek seznamu</td></tr>
<tr><td>LENGTH</td><td>zjištění délky seznamu</td></tr>
<tr><td>LIST</td><td>vytvoří nový seznam</td></tr>
<tr><td>APPEND</td><td>kombinace více seznamů</td></tr>
<tr><td>LISTP</td><td>predikát, který vrací <strong>T</strong> nebo <strong>nil</strong> v&nbsp;závislosti na tom, zda je parametrem seznam či jiný objekt</td></tr>
</table>

<p>Ukažme si nyní použití výše uvedených funkcí na jednoduchých demonstračních
příkladech. Použití apostrofu před čtyřprvkovým seznamem opět zabraňuje tomu,
aby se interpretr snažil seznam vyhodnotit, tj.&nbsp;volat (neexistující)
funkci <strong>a</strong> s&nbsp;parametry <strong>b, c, d</strong>.</p>

<pre>
<i>; funkci car již známe</i>
<strong>(car '(a b c d))</strong>
A
&nbsp;
<i>; stejně jako funkci cdr</i>
<strong>(cdr '(a b c d))</strong>
(B C D)
&nbsp;
<i>; cadr odpovídá výrazu (car (cdr seznam))</i>
<strong>(cadr '(a b c d))</strong>
B
&nbsp;
<strong>(car (cdr '(a b c d)))</strong>
B
&nbsp;
<strong>(cdar '(a b c d))</strong>
nelze vyhodnotit, protože se volá funkce CDR na atom A
&nbsp;
<i>; pozor - zde Common Lisp vrací jednoprvkový seznam</i>
<strong>(last '(a b c d))</strong>
(D)
&nbsp;
<i>; prvky seznamu jsou počítány od nuly</i>
<strong>(nth 0 '(a b c d))</strong>
A
&nbsp;
<strong>(nth 2 '(a b c d))</strong>
C
&nbsp;
<i>; pokus o přístup k neexistujícímu prvku seznamu</i>
<strong>(nth 4 '(a b c d))</strong>
NIL
</pre>

<p>Zjištění délky seznamu:</p>

<pre>
<strong>(length '(a b c d))</strong>
4
</pre>

<p>Konstrukce seznamů může být na první pohled poněkud složitější, zejména
v&nbsp;případě použití funkce <strong>cons</strong> (<i>constructor</i>). Když
si však uvědomíme, že tato funkce nedělá nic jiného než konstrukci uspořádaného
páru z&nbsp;obou předaných parametrů, je její chování zřejmé.</p>

<p>Následují příklady použití predikátu <strong>LISTP</strong>. Vzhledem
k&nbsp;tomu, že je <i>LISP</i> dynamicky typovaný jazyk, používají se predikáty
v&nbsp;něm napsaných aplikacích poměrně často:</p>

<pre>
<i>; test, zda je jednička (tj. atom) seznamem</i>
<strong>(listp 1)</strong>
NIL
&nbsp;
<i>; test, zda je výsledek součtu dvou čísel seznamem</i>
<strong>(listp (+ 1 2))</strong>
NIL
&nbsp;
<i>; test, zda je symbol A (atom) seznamem</i>
<strong>(listp 'A)</strong>
NIL
&nbsp;
<i>; (a b c d) je zcela jistě seznam</i>
<strong>(listp '(a b c d))</strong>
T
&nbsp;
<i>; i prázdný seznam je seznam :-)</i>
<strong>(listp '())</strong>
T
&nbsp;
<i>; prázdný seznam a nil jsou ekvivalentní</i>
<strong>(listp 'nil)</strong>
T
&nbsp;
<i>; nil se vyhodnocuje samo na sebe a navíc je</i>
<i>; ekvivalentní s prázdným seznamem - z toho</i>
<i>; vyplývá, že se před něj nemusí psát apostrof,</i>
<i>; protože se nemusíme "bát" vyhodnocení nil</i>
<i>; (trošku se nám to začíná komplikovat :-)</i>
<strong>(listp nil)</strong>
T
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Funkce jako základní stavební kámen programů, pojmenování uživatelských funkcí</h2>

<p>Naprostým základem při tvorbě každé jen trošku rozsáhlejší aplikace je
dekompozice problému na menší části, které je možné realizovat snadněji,
protože se výchozí problém více konkretizuje (a přibližuje se tak jak možnostem
použitého programovacího jazyka, tak i schopnosti vývojáře problém
naprogramovat :-). V&nbsp;programovacím jazyku <i>Common Lisp</i> se, podobně
jako v&nbsp;mnoha dalších imperativních a především funkcionálních
programovacích jazycích, pro rozklad problému na menší části používají
uživatelsky definované funkce, a to jak funkce pojmenované (navázané na nějaký
symbol &ndash; jméno), tak i funkce anonymní (tento typ funkcí je představován
<i>lambda výrazy</i>).</p>

<p><div class="rs-tip-major">Poznámka: může se to zdát podivné a možná i
zvrácené, ale například původní FORTRAN a mnohem novější standardní BASIC
funkce nepodporovaly. Do FORTRANu byly základní konstrukce strukturovaného
programování přidány až v&nbsp;rámci FORTRANu II v&nbsp;roce 1958.</div></p>

<p>V&nbsp;této kapitole si popíšeme způsob tvorby pojmenovaných funkcí a <a
href="#k13">v&nbsp;kapitole třinácté</a> se budeme zabývat problémem tvorby
funkcí anonymních, s&nbsp;čímž souvisí i problematika vytvoření a následného
použití lokálních proměnných. Možná by na tomto místě bylo vhodné připomenout,
že z&nbsp;čistě teoretického hlediska by se měly anonymní funkce popsat dříve
než funkce pojmenované, protože právě anonymní funkce tvoří základ pro
vytváření jak funkcí pojmenovaných, tak i lokálních proměnných (a mnoha dalších
užitečných jazykových konstrukcí). Vytvoření uživatelské pojmenované funkce je
v&nbsp;programovacím jazyku <i>Common Lisp</i> velmi jednoduché &ndash; použije
se makro <strong>defun</strong>, za nímž se zapíše jméno nově vytvářené funkce
i jména jejích formálních parametrů (ta jsou zapsána v&nbsp;seznamu). Za tímto
seznamem následuje tělo funkce, tj.&nbsp;výraz či sekvence výrazů, které se
mají vyhodnotit (v&nbsp;těchto výrazech je samozřejmě možné používat formální
parametry funkce).</p>

<p>Hodnota posledního vyhodnoceného výrazu se (většinou) stává i návratovou
hodnotou celé funkce, což mj.&nbsp;znamená, že všechny předchozí výrazy musí
mít vedlejší efekt, jinak je jejich volání (použití v&nbsp;těle funkce) vlastně
zbytečné.</p>

<p><div class="rs-tip-major">Poznámka: tento způsob &ndash; poslední výraz ve
funkci je současně (po vyhodnocení) její návratovou hodnotou &ndash; se používá
i v&nbsp;některých moderních programovacích jazycích, které tak mnohdy
nevyžadují explicitní použití klíčového slova
<strong>return</strong>.</div></p>

<p>Formálně vypadá vytvoření nové funkce následovně:</p>

<pre>
(defun [<strong>jméno funkce</strong>] ([formální parametry]) [tělo funkce])
</pre>

<p>Naproti tomu ve Scheme se používá &bdquo;jiné uzávorkování&ldquo; a namísto
makra <strong>defun</strong> se používá speciální forma
<strong>define</strong>:</p>

<pre>
(define ([<strong>jméno funkce</strong>] [formální parametry]) [tělo funkce])
</pre>

<p>Definice konkrétní pojmenované funkce bez parametrů (vrací konstantu 42) a
její následné zavolání:</p>

<pre>
(defun foo ()
  42)
&nbsp;
(print (foo))
</pre>

<p>Postup vytvoření uživatelské funkce s&nbsp;jedním parametrem a jejího
následného použití (zavolání):</p>

<pre>
(defun foo (message)
  (print message))
&nbsp;
&nbsp;
(foo "Hello")
</pre>

<p>Samozřejmě je možné vytvořit i funkci víceparametrickou:</p>

<pre>
(defun bar (message other)
  (print message))
&nbsp;
&nbsp;
(bar "Hello" "world")
</pre>

<p>Zápis na jednom resp.&nbsp;na více řádcích:</p>

<pre>
(defun add (x y) (+ x y))
&nbsp;  
(defun mul (x y)
  (* x y))
&nbsp;  
(print (add 1 2))
(print (mul 6 7))
</pre>

<p>Ve funkci je možné vytvořit blok s&nbsp;lokálními proměnnými formou
<strong>let</strong>:</p>

<pre>
(defun add+1 (x y)
  (let ((result (+ x y)))
        (+ 1 result)))
&nbsp;
(print (add+1 1 2))
</pre>

<p>V&nbsp;programovacím jazyku <i>Common Lisp</i> lze vytvářet i funkce,
v&nbsp;jejichž názvu se nachází různé nealfanumerické znaky. Je to ostatně
logické, protože se jedná o jeden z&nbsp;těch jazyků (a je jich překvapivě
velké množství), v&nbsp;nichž neexistují ani operátory (zapisované většinou
právě pomocí nealfanumerických znaků) ani většina dalších speciálních
syntaktických konstrukcí. V&nbsp;předchozích částech tohoto seriálu jsme si již
ukázali některé <i>predikáty</i>, u nichž je obvyklé, že jsou jejich jména
ukončena znakem otazník (<strong>?</strong>, minimálně ve Scheme).</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Anonymní funkce</h2>

<p>Kromě pojmenovaných funkcí ve stručnosti popsaných <a
href="#k12">v&nbsp;předchozí kapitole</a> je možné v&nbsp;programovacím jazyce
<i>Common Lispu</i>, podobně jako i v&nbsp;klasickém <i>Scheme</i>, ale i mnoha
dalších jazycích umožňujících funkcionální programování, vytvářet a používat
takzvané funkce anonymní. Tyto funkce, které je možné s&nbsp;výhodou využít
například při zápisu iterací nad prvky seznamů či při omezování oblasti
platnosti proměnných, se vytváří s&nbsp;využitím speciální formy
<strong>lambda</strong>, jejíž název je odvozen ze slavné Churchovy teorie
Lambda kalkulu, která má poměrně velký význam jak v&nbsp;teoretické
informatice, tak i v&nbsp;dalších odvětvích informatiky (viz též odkazy uvedené
<a href="#k20">v&nbsp;poslední kapitole</a>). Samotný zápis anonymní funkce se
příliš neliší od zápisu funkce pojmenované &ndash; jediný syntaktický rozdíl
spočívá v&nbsp;tom, že se při zápisu speciální formy <strong>lambda</strong>
nikde neuvádí jméno funkce, pouze seznam (jména) formálních parametrů, za nimiž
následuje tělo funkce:</p>

<pre>
(print ((lambda () "no parameters")))
&nbsp;
(print ((lambda (a) (list "one parameter" a)) 10))
&nbsp;
(print ((lambda (a b) (list "two parameters" a b)) 10 20))
</pre>

<p>Po vyhodnocení těchto tří příkazů bychom měli získat tyto výsledky:</p>

<pre>
"no parameters" 
("one parameter" 10) 
("two parameters" 10 20) 
</pre>

<p>Používat je možné i nepovinné parametry, anonymní funkce s&nbsp;proměnným
počtem parametrů atd. (viz též navazující kapitoly s&nbsp;podrobnějším
popisem). Podívejme se nyní jen na způsob zápisu:</p>

<pre>
(print ((lambda (a b &amp;optional c d) (list "two or more parameters" a b c d)) 10 20))
(print ((lambda (a b &amp;optional c d) (list "two or more parameters" a b c d)) 10 20 30))
(print ((lambda (a b &amp;optional c d) (list "two or more parameters" a b c d)) 10 20 30 40))
&nbsp;
(print ((lambda (a b &amp;rest values) (list "two or more parameters" a b values)) 10 20))
(print ((lambda (a b &amp;rest values) (list "two or more parameters" a b values)) 10 20 30))
(print ((lambda (a b &amp;rest values) (list "two or more parameters" a b values)) 10 20 30 40))
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Funkce s&nbsp;proměnným počtem parametrů</h2>

<p>V&nbsp;Common Lispu je možné s&nbsp;využitím formy <strong>defun</strong>
nadefinovat pojmenovanou funkci akceptující proměnný (tj.&nbsp;v&nbsp;krajním
případě i nulový) počet parametrů, z&nbsp;nichž je při volání funkce
automaticky vytvořen seznam, se kterým je možné v&nbsp;těle funkce libovolným
způsobem manipulovat. Syntakticky vypadá definice takové funkce následovně:</p>

<pre>
(defun jméno_funkce (&amp; rest values) [tělo funkce])
</pre>

<p>Nebo lze kombinovat povinné parametry a proměnný počet parametrů:</p>

<pre>
(defun jméno_funkce (povinné parametry &amp; rest values) [tělo funkce])
</pre>

<p>Podívejme se na jednoduchý příklad:</p>

<pre>
(defun show-values <strong>(a b &amp;rest values)</strong>
  (print values)
  (print (list a b values))
  (terpri))
&nbsp;
&nbsp;
(show-values 1 2)
(show-values 1 2 3)
(show-values 1 2 3 4)
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
NIL 
(1 2 NIL) 
&nbsp;
(3) 
(1 2 (3)) 
&nbsp;
(3 4) 
(1 2 (3 4)) 
</pre>

<p><div class="rs-tip-major">Poznámka: proměnné parametry se tedy vždy uloží do
seznamu, který může být i prázdný, neboli <strong>nil</strong>.</div></p>

<p>Odlišný způsob zpracování proměnných parametrů:</p>

<pre>
(defun show-values <strong>(a b &amp;rest values)</strong>
  (let ((l (append (list a b) values)))
  (print values)
  (print l)
  (terpri)))
&nbsp;
&nbsp;
(show-values 1 2)
(show-values 1 2 3)
(show-values 1 2 3 4)
</pre>

<p>Tentokrát s&nbsp;výsledky:</p>

<pre>
NIL 
(1 2) 
&nbsp;
(3) 
(1 2 3) 
&nbsp;
(3 4) 
(1 2 3 4) 
</pre>

<p>A konečně si uveďme příklad, v&nbsp;němž se všechny parametry postupně
vypíšou v&nbsp;<strong>dolist</strong> (což je vlastně smyčka typu
for-each):</p>

<pre>
(defun show-values <strong>(&amp;rest values)</strong>
  (dolist (value values)
    (print value))
  (terpri))
&nbsp;
&nbsp;
(show-values)
(show-values 1)
(show-values 1 2)
(show-values 1 2 3)
(show-values 1 2 3 4)
(show-values 1 2 3 4 5)
</pre>

<pre>
(nic)
&nbsp;
1 
&nbsp;
1 
2 
&nbsp;
1 
2 
3 
&nbsp;
1 
2 
3 
4 
&nbsp;
1 
2 
3 
4 
5 
</pre>

<p><div class="rs-tip-major">Poznámka: ve Scheme/Racketu se používá tento
zápis:</div></p>

<pre>
(<strong>define (jméno funkce . parametr) [tělo funkce]</strong>)
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Nepovinné parametry funkcí</h2>

<p>Při deklaraci funkcí můžeme použít i takzvané <i>nepovinné parametry</i>.
Pokud se při volání funkce neuvede hodnota takového parametru, bude za ni
dosazena výchozí hodnota. Nepovinné parametry se poznají snadno &ndash; jsou
zapsány za &amp;optional a to buď jen jménem nebo formou seznamu o dvou
prvcích. Prvním prvkem seznamu je jméno parametru, druhým prvkem pak výchozí
hodnota nepovinného parametru.</p>

<p>Použití nepovinných parametrů, jejichž výchozí hodnota bude
<strong>nil</strong>:</p>

<pre>
(defun show-values <strong>(a b &amp;optional c d)</strong>
  (print c)
  (print d)
  (print (list a b c d))
  (terpri))
&nbsp;
&nbsp;
(show-values 1 2)
(show-values 1 2 3)
(show-values 1 2 3 4)
</pre>

<p>Výsledky:</p>

<pre>
NIL 
NIL 
(1 2 NIL NIL) 
&nbsp;
3 
NIL 
(1 2 3 NIL) 
&nbsp;
3 
4 
(1 2 3 4) 
</pre>

<p>Použití nepovinných parametrů i s&nbsp;nastavenou výchozí hodnotou:</p>

<pre>
(defun show-values <strong>(a b &amp;optional (c -1) (d "nic"))</strong>
  (print c)
  (print d)
  (print (list a b c d))
  (terpri))
&nbsp;
&nbsp;
(show-values 1 2)
(show-values 1 2 3)
(show-values 1 2 3 4)
</pre>

<p>Výsledky získané po spuštění:</p>

<pre>
-1 
"nic" 
(1 2 -1 "nic") 
&nbsp;
3 
"nic" 
(1 2 3 "nic") 
&nbsp;
3 
4 
(1 2 3 4) 
</pre>

<p>Proměnný počet parametrů lze zkombinovat s&nbsp;funkcí s&nbsp;proměnným
počtem parametrů, ovšem přesně v&nbsp;tomto pořadí:</p>

<pre>
(defun show-values <strong>(a b &amp;optional c d &amp;rest values)</strong>
  (print c)
  (print d)
  (print values)
  (print (list a b c d values))
  (terpri))
&nbsp;
&nbsp;
(show-values 1 2)
(show-values 1 2 3)
(show-values 1 2 3 4)
(show-values 1 2 3 4 5)
(show-values 1 2 3 4 5 6)
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
NIL 
NIL 
NIL 
(1 2 NIL NIL NIL) 
&nbsp;
3 
NIL 
NIL 
(1 2 3 NIL NIL) 
&nbsp;
3 
4 
NIL 
(1 2 3 4 NIL) 
&nbsp;
3 
4 
(5) 
(1 2 3 4 (5)) 
&nbsp;
3 
4 
(5 6) 
(1 2 3 4 (5 6)) 
</pre>

<p>Další varianta, tentokrát se specifikací výchozí hodnoty nepovinných
parametrů:</p>

<pre>
(defun show-values <strong>(a b &amp;optional (c -1) (d "nic") &amp;rest values)</strong>
  (print c)
  (print d)
  (print values)
  (print (list a b c d values))
  (terpri))
&nbsp;
&nbsp;
(show-values 1 2)
(show-values 1 2 3)
(show-values 1 2 3 4)
(show-values 1 2 3 4 5)
(show-values 1 2 3 4 5 6)
</pre>

<p>Výsledky:</p>

<pre>
-1 
"nic" 
NIL 
(1 2 -1 "nic" NIL) 
&nbsp;
3 
"nic" 
NIL 
(1 2 3 "nic" NIL) 
&nbsp;
3 
4 
NIL 
(1 2 3 4 NIL) 
&nbsp;
3 
4 
(5) 
(1 2 3 4 (5)) 
&nbsp;
3 
4 
(5 6) 
(1 2 3 4 (5 6)) 
</pre>

<p>Ovšem tato kombinace již není dovolena (celkem logicky):</p>

<pre>
(defun show-values <strong>(a b &amp;rest values &amp;optional (c -1) (d "nic"))</strong>
  (print c)
  (print d)
  (print values)
  (print (list a b c d values))
  (terpri))
&nbsp;
&nbsp;
(show-values 1 2)
(show-values 1 2 3)
(show-values 1 2 3 4)
(show-values 1 2 3 4 5)
(show-values 1 2 3 4 5 6)
</pre>

<p>Při pokusu o vyhodnocení nastane chyba:</p>

<pre>
; file: /tmp/ramdisk/function_optional_rest_params_3.lisp
; in: DEFUN SHOW-VALUES
;     (DEFUN SHOW-VALUES (A B &amp;REST VALUES &amp;OPTIONAL (C -1) (D "nic"))
;       (PRINT C)
;       (PRINT D)
;       (PRINT VALUES)
;       (PRINT (LIST A B C D VALUES))
;       (TERPRI))
; 
; caught ERROR:
;   misplaced &amp;OPTIONAL in lambda list: (A B &amp;REST VALUES &amp;OPTIONAL (C -1)
;                                        (D "nic"))
Unhandled SB-INT:SIMPLE-PROGRAM-ERROR in thread #&lt;SB-THREAD:THREAD "main thread" RUNNING
                                                   {1000560083}&gt;:
  misplaced &amp;OPTIONAL in lambda list: (A B &amp;REST VALUES &amp;OPTIONAL (C -1)
                                       (D "nic"))
</pre>

<p><div class="rs-tip-major">Poznámka: ve Scheme/Racketu se používá tento
zápis:</div></p>

<pre>
#lang racket/base
&nbsp;
(define (<strong>inc</strong> x [delta 1])
    (+ x delta))
&nbsp;
(display (inc 10))
(newline)
&nbsp;
(display (inc 10 20))
(newline)
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Parametry funkcí explicitně specifikované svým jménem</h2>

<p>Kromě povinných a nepovinných parametrů popř.&nbsp;volitelného počtu
parametrů existují ještě další způsoby, jakými je možné funkcím předávat
hodnoty, které mají funkce zpracovávat. Jednou z&nbsp;dalších možností jsou
takzvané <i>keywords</i> parametry, což jsou parametry s&nbsp;explicitně
specifikovaným jménem. Jména těchto parametrů se zadávají za &amp;key a liší se
i způsob volání funkce.</p>

<p><div class="rs-tip-major">Poznámka: s&nbsp;podobným konceptem se můžeme
setkat například v&nbsp;programovacím jazyku Python, viz například <a
href="https://treyhunner.com/2018/04/keyword-arguments-in-python/">Keyword
(Named) Arguments in Python: How to Use Them</a>.</div></p>

<p>Příklad použití:</p>

<pre>
(defun show-values <strong>(&amp;key a b c d)</strong>
  (print (list a b c d)))
&nbsp;
&nbsp;
(show-values :a 1 :b 2 :c 3 :d 4)
(show-values :b 1 :a 2 :d 3 :c 4)
(show-values :d 1 :c 2 :b 3 :a 4)
</pre>

<p>Výsledek:</p>

<pre>
(1 2 3 4) 
(2 1 4 3) 
(4 3 2 1) 
</pre>

<p>Při volání funkce není pořadí pojmenovaných parametrů pevně dané a parametry
lze vynechat:</p>

<pre>
(defun show-values <strong>(&amp;key a b c d)</strong>
  (print (list a b c d)))
&nbsp;
&nbsp;
(show-values)
(show-values :a 1)
(show-values :b 2)
(show-values :a 1 :b 2)
(show-values :c 3 :d 4)
</pre>

<p>Výsledek:</p>

<pre>
(NIL NIL NIL NIL) 
(1 NIL NIL NIL) 
(NIL 2 NIL NIL) 
(1 2 NIL NIL) 
(NIL NIL 3 4)
</pre>

<p>Kombinace volitelných a pojmenovaných parametrů:</p>

<pre>
(defun show-values <strong>(a b &amp;optional c d &amp;key e f)</strong>
  (print (list a b c d e f)))
&nbsp;
&nbsp;
(show-values 1 2)
(show-values 1 2 3)
(show-values 1 2 3 4)
(show-values 1 2 :e 100)
(show-values 1 2 :e 100 :f 200)
(show-values 1 2 3 4 :e 100)
(show-values 1 2 3 4 :f 200)
(show-values 1 2 3 4 :e 100 :f 200)
</pre>

<p>Tentokrát s&nbsp;výsledkem:</p>

<pre>
(1 2 NIL NIL NIL NIL) 
(1 2 3 NIL NIL NIL) 
(1 2 3 4 NIL NIL) 
(1 2 :E 100 NIL NIL) 
(1 2 :E 100 NIL 200) 
(1 2 3 4 100 NIL) 
(1 2 3 4 NIL 200) 
(1 2 3 4 100 200)
</pre>

<p><div class="rs-tip-major">Poznámka: ve Scheme/Racketu se používá tento
zápis:</div></p>

<pre>
#lang racket/base
&nbsp;
(define (transform x <strong>#:scale scale</strong> <strong>#:offset offset</strong>)
    (+ offset (* x scale)))
&nbsp;
(display (transform 10 #:offset 0 #:scale 1))
(newline)
&nbsp;
(display (transform 10 #:offset -100 #:scale 1))
(newline)
&nbsp;
(display (transform 10 #:offset -100 #:scale 100))
(newline)
</pre>


<p><a name="k17"></a></p>
<h2 id="k17">17. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech <a
href="https://www.root.cz/clanky/common-lisp-zralok-mezi-programovacimi-jazyky/">minule</a>
i dnes použitých demonstračních příkladů určených pro spuštění v&nbsp;prostředí
Common Lispu byly uloženy do Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/lisp-families.git">https://github.com/tisnik/lisp-families.git</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, můžete
namísto toho použít odkazy na jednotlivé příklady, které naleznete
v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>boolean_ops.lisp</td><td>pravdivostní operace</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/boolean_ops.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/boolean_ops.lisp</a></td></tr>
<tr><td> 2</td><td>cond.lisp</td><td>základní rozhodovací konstrukce</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/cond.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/cond.lisp</a></td></tr>
<tr><td> 3</td><td>cons.lisp</td><td>konstrukce seznamů</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/cons.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/cons.lisp</a></td></tr>
<tr><td> 4</td><td>dotimes1.lisp</td><td>použití makra <strong>dotimes</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/dotimes1.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/dotimes1.lisp</a></td></tr>
<tr><td> 5</td><td>dotimes2.lisp</td><td>použití makra <strong>dotimes</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/dotimes2.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/dotimes2.lisp</a></td></tr>
<tr><td> 6</td><td>dotimes3.lisp</td><td>použití makra <strong>dotimes</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/dotimes3.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/dotimes3.lisp</a></td></tr>
<tr><td> 7</td><td>dot_pairs.lisp</td><td>datový typ &bdquo;pár&ldquo;</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/dot_pairs.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/dot_pairs.lisp</a></td></tr>
<tr><td> 8</td><td>drop.lisp</td><td>funkce <strong>drop</strong> pro zpracování seznamů</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/drop.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/drop.lisp</a></td></tr>
<tr><td> 9</td><td>factorial1.lisp</td><td>výpočet faktoriálu, první varianta</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/factorial1.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/factorial1.lisp</a></td></tr>
<tr><td>10</td><td>factorial2.lisp</td><td>výpočet faktoriálu, druhá varianta</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/factorial2.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/factorial2.lisp</a></td></tr>
<tr><td>11</td><td>function1.lisp</td><td>funkce v&nbsp;Common Lispu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/function1.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/function1.lisp</a></td></tr>
<tr><td>12</td><td>function2.lisp</td><td>funkce v&nbsp;Common Lispu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/function2.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/function2.lisp</a></td></tr>
<tr><td>13</td><td>function3.lisp</td><td>funkce v&nbsp;Common Lispu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/function3.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/function3.lisp</a></td></tr>
<tr><td>14</td><td>function4.lisp</td><td>funkce v&nbsp;Common Lispu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/function4.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/function4.lisp</a></td></tr>
<tr><td>15</td><td>hello1.lisp</td><td>&bdquo;Hello world&ldquo; v&nbsp;Common Lispu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/hello1.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/hello1.lisp</a></td></tr>
<tr><td>16</td><td>hello2.lisp</td><td>&bdquo;Hello world&ldquo; v&nbsp;Common Lispu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/hello2.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/hello2.lisp</a></td></tr>
<tr><td>17</td><td>lists.lisp</td><td>operace se seznamy</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/lists.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/lists.lisp</a></td></tr>
<tr><td>18</td><td>predicates.lisp</td><td>vybrané predikáty</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/predicates.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/predicates.lisp</a></td></tr>
<tr><td>19</td><td>take.lisp</td><td>funkce <strong>take</strong> pro zpracování seznamů</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/take.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/take.lisp</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>20</td><td>loop_append.lisp</td><td>klauzule <strong>append</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_append.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_append.lisp</a></td></tr>
<tr><td>21</td><td>loop_for_from_dowto.lisp</td><td>smyčka s&nbsp;počitadlem</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_from_dowto.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_from_dowto.lisp</a></td></tr>
<tr><td>22</td><td>loop_for_from_to_by.lisp</td><td>smyčka s&nbsp;počitadlem</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_from_to_by.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_from_to_by.lisp</a></td></tr>
<tr><td>23</td><td>loop_for_from_to.lisp</td><td>smyčka s&nbsp;počitadlem</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_from_to.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_from_to.lisp</a></td></tr>
<tr><td>24</td><td>loop_for_in_by.lisp</td><td>procházení seznamu s&nbsp;klauzulí <strong>in</strong> a <strong>by</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_in_by.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_in_by.lisp</a></td></tr>
<tr><td>25</td><td>loop_for_in.lisp</td><td>procházení seznamu s&nbsp;klauzulí <strong>in</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_in.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_in.lisp</a></td></tr>
<tr><td>26</td><td>loop_for_on_by.lisp</td><td>procházení seznamem s&nbsp;klauzulí <strong>on</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_on_by.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_on_by.lisp</a></td></tr>
<tr><td>27</td><td>loop_for_on.lisp</td><td>procházení seznamem s&nbsp;klauzulí <strong>on</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_on.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_on.lisp</a></td></tr>
<tr><td>28</td><td>loop_for_to.lisp</td><td>smyčka s&nbsp;počitadlem</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_to.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_for_to.lisp</a></td></tr>
<tr><td>29</td><td>loop_maximize.lisp</td><td>vyhledání prvku s&nbsp;největším výsledkem výpočtu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_maximize.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_maximize.lisp</a></td></tr>
<tr><td>30</td><td>loop_max_min_count_sum.lisp</td><td>statistické informace o seznamu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_max_min_count_sum.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_max_min_count_sum.lisp</a></td></tr>
<tr><td>31</td><td>loop_repeat.lisp</td><td>klauzule <strong>repeat</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_repeat.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_repeat.lisp</a></td></tr>
<tr><td>32</td><td>loop_sum.lisp</td><td>výpočet sumy prvků</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_sum.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_sum.lisp</a></td></tr>
<tr><td>33</td><td>loop_while_until.lisp</td><td>klauzule <strong>while</strong> a <strong>until</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_while_until.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/loop_while_until.lisp</a></td></tr>
<tr><td>34</td><td>broken_factorial.lisp</td><td>chyba při výpočtu faktoriálu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/broken_factorial.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/broken_factorial.lisp</a></td></tr>
<tr><td>35</td><td>broken_factorial2.lisp</td><td>chyba při výpočtu faktoriálu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/broken_factorial2.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/broken_factorial2.lisp</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>36</td><td>predicate_atom.lisp</td><td>predikát <strong>atom</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/predicate_atom.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/predicate_atom.lisp</a></td></tr>
<tr><td>37</td><td>function_optional_params_1.lisp</td><td>funkce s&nbsp;volitelnými parametry</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/function_optional_params_1.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/function_optional_params_1.lisp</a></td></tr>
<tr><td>38</td><td>function_optional_params_2.lisp</td><td>funkce s&nbsp;volitelnými parametry</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/function_optional_params_2.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/function_optional_params_2.lisp</a></td></tr>
<tr><td>39</td><td>function_optional_rest_params_1.lisp</td><td>funkce s&nbsp;volitelnými parametry i proměnným počtem parametrů</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/function_optional_rest_params_1.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/function_optional_rest_params_1.lisp</a></td></tr>
<tr><td>40</td><td>function_optional_rest_params_2.lisp</td><td>funkce s&nbsp;volitelnými parametry i proměnným počtem parametrů</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/function_optional_rest_params_2.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/function_optional_rest_params_2.lisp</a></td></tr>
<tr><td>41</td><td>function_optional_rest_params_3.lisp</td><td>nekorektní použití</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/function_optional_rest_params_2.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/function_optional_rest_params_2.lisp</a></td></tr>
<tr><td>42</td><td>function_rest_params_1.lisp</td><td>funkce s&nbsp;proměnným počtem parametrů</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/function_rest_params_1.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/function_rest_params_1.lisp</a></td></tr>
<tr><td>43</td><td>function_rest_params_2.lisp</td><td>funkce s&nbsp;proměnným počtem parametrů</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/function_rest_params_2.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/function_rest_params_2.lisp</a></td></tr>
<tr><td>44</td><td>function_rest_params_3.lisp</td><td>funkce s&nbsp;proměnným počtem parametrů</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/function_rest_params_3.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/function_rest_params_3.lisp</a></td></tr>
<tr><td>45</td><td>function_keyword_params_1.lisp</td><td>funkce s&nbsp;keyword parametry</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/function_keyword_params_1.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/function_keyword_params_1.lisp</a></td></tr>
<tr><td>46</td><td>function_keyword_params_2.lisp</td><td>funkce s&nbsp;keyword parametry</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/function_keyword_params_2.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/function_keyword_params_2.lisp</a></td></tr>
<tr><td>47</td><td>function_optional_keyword_params.lisp</td><td>funkce s&nbsp;keyword parametry i volitelnými parametry</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/function_optional_keyword_params.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/function_optional_keyword_params.lisp</a></td></tr>
<tr><td>48</td><td>function_return.lisp</td><td>předčasný výskok z&nbsp;funkce</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/function_return.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/function_return.lisp</a></td></tr>
<tr><td>49</td><td>lambdas1.lisp</td><td>lambda výrazy v&nbsp;LISPu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/lambdas1.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/lambdas1.lisp</a></td></tr>
<tr><td>50</td><td>lambdas2.lisp</td><td>lambda výrazy v&nbsp;LISPu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/common-lisp/lambdas2.lisp">https://github.com/tisnik/lisp-families/blob/master/common-lisp/lambdas2.lisp</a></td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: všechny tyto demonstrační příklady je
možné spustit přímo z&nbsp;shellu: <strong>sbcl --load
&lt;jméno-souboru.lisp&gt;</strong></div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Předchozí části seriálu</h2>

<p>V&nbsp;této kapitole jsou uvedeny odkazy na všechny předchozí části seriálu
o světě programovacích jazyků LISP a Scheme (kromě samostatného seriálu, který
se věnoval programovacímu jazyku Clojure):</p>

<ol>

<li>Jemný úvod do rozsáhlého světa jazyků LISP a Scheme<br />
<a href="https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/">https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/</a>
</li>

<li>PicoLisp: minimalistický a přitom překvapivě výkonný interpret Lispu<br />
<a href="https://www.root.cz/clanky/picolisp-minimalisticky-a-pritom-prekvapive-vykonny-interpret-lispu/">https://www.root.cz/clanky/picolisp-minimalisticky-a-pritom-prekvapive-vykonny-interpret-lispu/</a>
</li>

<li>PicoLisp: užitečné funkce a speciální formy používané při tvorbě aplikací<br />
<a href="https://www.root.cz/clanky/picolisp-uzitecne-funkce-a-specialni-formy-pouzivane-pri-tvorbe-aplikaci/">https://www.root.cz/clanky/picolisp-uzitecne-funkce-a-specialni-formy-pouzivane-pri-tvorbe-aplikaci/</a>
</li>

<li>PicoLisp: dokončení popisu a několik praktických rad na závěr<br />
<a href="https://www.root.cz/clanky/picolisp-dokonceni-popisu-a-nekolik-praktickych-rad-na-zaver/">https://www.root.cz/clanky/picolisp-dokonceni-popisu-a-nekolik-praktickych-rad-na-zaver/</a>
</li>

<li>GNU Guile – interpret Scheme vestavitelný do nativních aplikací<br />
<a href="https://www.root.cz/clanky/gnu-guile-interpret-scheme-vestavitelny-do-nativnich-aplikaci/">https://www.root.cz/clanky/gnu-guile-interpret-scheme-vestavitelny-do-nativnich-aplikaci/</a>
</li>

<li>TinyScheme aneb další interpret jazyka Scheme vestavitelný do dalších aplikací<br />
<a href="https://www.root.cz/clanky/tinyscheme-aneb-dalsi-interpret-jazyka-scheme-vestavitelny-do-dalsich-aplikaci/">https://www.root.cz/clanky/tinyscheme-aneb-dalsi-interpret-jazyka-scheme-vestavitelny-do-dalsich-aplikaci/</a>
</li>

<li>Kawa: překvapivě silný a výkonný dialekt Scheme pro JVM<br />
<a href="https://www.root.cz/clanky/kawa-prekvapive-silny-a-vykonny-dialekt-scheme-pro-jvm/">https://www.root.cz/clanky/kawa-prekvapive-silny-a-vykonny-dialekt-scheme-pro-jvm/</a>
</li>

<li>Jazyk Kawa v&nbsp;ekosystému virtuálního stroje Javy<br />
<a href="https://www.root.cz/clanky/jazyk-kawa-v-ekosystemu-virtualniho-stroje-javy/">https://www.root.cz/clanky/jazyk-kawa-v-ekosystemu-virtualniho-stroje-javy/</a>
</li>

<li>Zpracování vektorů, matic a N-rozměrných polí v&nbsp;programovacím jazyku Kawa<br />
<a href="https://www.root.cz/clanky/zpracovani-vektoru-matic-a-n-rozmernych-poli-v-programovacim-jazyku-kawa/">https://www.root.cz/clanky/zpracovani-vektoru-matic-a-n-rozmernych-poli-v-programovacim-jazyku-kawa/</a>
</li>

<li>Racket: programovací jazyk a současně i platforma pro vývoj nových jazyků<br />
<a href="https://www.root.cz/clanky/racket-programovaci-jazyk-a-soucasne-i-platforma-pro-vyvoj-novych-jazyku/">https://www.root.cz/clanky/racket-programovaci-jazyk-a-soucasne-i-platforma-pro-vyvoj-novych-jazyku/</a>
</li>

<li>Makra v&nbsp;Racketu i v&nbsp;dalších lispovských jazycích<br />
<a href="https://www.root.cz/clanky/makra-v-racketu-i-v-dalsich-lispovskych-jazycich/">https://www.root.cz/clanky/makra-v-racketu-i-v-dalsich-lispovskych-jazycich/</a>
</li>

<li>Základní knihovna jazyka Racket<br />
<a href="https://www.root.cz/clanky/zakladni-knihovna-jazyka-racket/">https://www.root.cz/clanky/zakladni-knihovna-jazyka-racket/</a>
</li>

<li>Jazyk Joker: dialekt Clojure naprogramovaný v&nbsp;Go<br />
<a href="https://www.root.cz/clanky/jazyk-joker-dialekt-clojure-naprogramovany-v-go/">https://www.root.cz/clanky/jazyk-joker-dialekt-clojure-naprogramovany-v-go/</a>
</li>

<li>Chicken Scheme – další interpret a především překladač programovacího jazyka Scheme<br />
<a href="https://www.root.cz/clanky/chicken-scheme-dalsi-interpret-a-predevsim-prekladac-programovaciho-jazyka-scheme/">https://www.root.cz/clanky/chicken-scheme-dalsi-interpret-a-predevsim-prekladac-programovaciho-jazyka-scheme/</a>
</li>

<li>Projekt Gambit – další kvalitní interpret i překladač programovacího jazyka Scheme<br />
<a href="https://www.root.cz/clanky/projekt-gambit-dalsi-kvalitni-interpret-i-prekladac-programovaciho-jazyka-scheme/">https://www.root.cz/clanky/projekt-gambit-dalsi-kvalitni-interpret-i-prekladac-programovaciho-jazyka-scheme/</a>
</li>

<li>Interlisp aneb oživujeme dinosaura<br />
<a href="https://www.root.cz/clanky/interlisp-aneb-ozivujeme-dinosaura/">https://www.root.cz/clanky/interlisp-aneb-ozivujeme-dinosaura/</a>
</li>

<li>Propojení světa LISPu se světem JavaScriptu s&nbsp;využitím transpřekladače Wisp<br />
<a href="https://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp/">https://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp/</a>
</li>

<li>Propojení světa LISPu se světem JavaScriptu s&nbsp;využitím transpřekladače Wisp (2.část)<br />
<a href="https://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp-2-cast/">https://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp-2-cast/</a>
</li>

<li>Common Lisp: žralok mezi programovacími jazyky<br />
<a href="https://www.root.cz/clanky/common-lisp-zralok-mezi-programovacimi-jazyky/">https://www.root.cz/clanky/common-lisp-zralok-mezi-programovacimi-jazyky/</a>
</li>

</ol>

<p>Články o Elispu:</p>

<ol>

<li>Úpravy Emacsu a tvorba nových modulů s&nbsp;využitím Emacs Lispu<br />
<a href="https://www.root.cz/clanky/upravy-emacsu-a-tvorba-novych-modulu-s-vyuzitim-emacs-lispu/">https://www.root.cz/clanky/upravy-emacsu-a-tvorba-novych-modulu-s-vyuzitim-emacs-lispu/</a>
</li>

<li>Úpravy Emacsu s&nbsp;Emacs Lisp: základní konstrukce jazyka<br />
<a href="https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-zakladni-konstrukce-jazyka/">https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-zakladni-konstrukce-jazyka/</a>
</li>

<li>Úpravy Emacsu s&nbsp;Emacs Lisp: všemocné makro cl-loop a knihovna dash<br />
<a href="https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-vsemocne-makro-cl-loop-a-knihovna-dash/">https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-vsemocne-makro-cl-loop-a-knihovna-dash/</a>
</li>

<li>Úpravy Emacsu s&nbsp;Emacs Lisp: možnosti nabízené knihovnou Dash<br />
<a href="https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-moznosti-nabizene-knihovnou-dash/">https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-moznosti-nabizene-knihovnou-dash/</a>
</li>

<li>Úpravy Emacsu s&nbsp;Emacs Lisp: dokončení popisu Emacs Lispu<br />
<a href="https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-dokonceni-popisu-emacs-lispu/">https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-dokonceni-popisu-emacs-lispu/</a>
</li>

<li>Úpravy Emacsu s&nbsp;Emacs Lisp: manipulace se základními datovými strukturami Emacsu<br />
<a href="https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-manipulace-se-zakladnimi-datovymi-strukturami-emacsu/">https://www.root.cz/clanky/upravy-emacsu-s-emacs-lisp-manipulace-se-zakladnimi-datovymi-strukturami-emacsu/</a>
</li>

</ol>



<p><a name="k19"></a></p>
<h2 id="k19">19. Literatura</h2>

<p>O Common Lispu, Scheme či Clojure, tedy o třech (s&nbsp;velkou
pravděpodobností) nejpoužívanějších dialektech LISPu, vyšlo poměrně velké
množství literatury. Pro Common Lisp je typická jeho velká stabilita, a to
minimálně od roku 1994, což mj.&nbsp;znamená, že i původní vydaní prvních dvou
dále zmíněných knih je zcela bez problémů použitelné i dnes (a obě knihy jsou
navíc dobře čitelné):</p>

<ol>

<li>Peter Seibel<br />
<i>&bdquo;Practical Common Lisp&ldquo;</i><br />
2009
</li>

<li>Paul Graham<br />
<i>&bdquo;ANSI Common Lisp&ldquo;</i><br />
1995
</li>

<li>Gerald Gazdar<br />
<i>&bdquo;Natural Language Processing in Lisp: An Introduction to Computational Linguistics&ldquo;</i><br />
1989
</li>

<li>Peter Norvig<br />
<i>&bdquo;Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp&ldquo;</i><br />
1991
</li>

<li>Alex Mileler et.al.<br />
<i>&bdquo;Clojure Applied: From Practice to Practitioner&ldquo;</i><br />
2015
</li>

<li>
<i>&bdquo;Living Clojure: An Introduction and Training Plan for Developers&ldquo;</i><br />
2015
</li>

<li>Dmitri Sotnikov<br />
<i>&bdquo;Web Development with Clojure: Build Bulletproof Web Apps with Less Code&ldquo;</i><br />
2016
</li>

<li>McCarthy<br />
<i>&bdquo;Recursive functions of symbolic expressions and their computation by machine, part I&ldquo;</i><br />
1960
</li>

<li>R. Kent Dybvig<br />
<i>&bdquo;The Scheme Programming Language&ldquo;</i><br />
2009
</li>

<li>Max Hailperin<br />
<i>&bdquo;Concrete Abstractions&ldquo;</i><br />
1998
</li>

<li>Guy L. Steele<br />
<i>&bdquo;History of Scheme&ldquo;</i><br />
2006, Sun Microsystems Laboratories
</li>

<li>Kolář J., Muller K.:<br />
<i>&bdquo;Speciální programovací jazyky&ldquo;</i><br />
Praha 1981
</li>

<li>
<i>&bdquo;AutoLISP Release 9, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., October 1987
</li>

<li>
<i>&bdquo;AutoLISP Release 10, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., September 1988
</li>

<li>McCarthy, John; Abrahams, Paul W.; Edwards, Daniel J.; Hart, Timothy P.; Levin, Michael I.<br />
<i>&bdquo;LISP 1.5 Programmer's Manual&ldquo;</i><br />
MIT Press. ISBN 0 262 130 1 1 4
</li>

<li>Carl Hewitt; Peter Bishop and Richard Steiger<br />
<i>&bdquo;A Universal Modular Actor Formalism for Artificial Intelligence&ldquo;</i><br />
1973
</li>

<li>Feiman, J.<br />
<i>&bdquo;The Gartner Programming Language Survey (October 2001)&ldquo;</i><br />
Gartner Advisory
</li>

<li>Harold Abelson, Gerald Jay Sussman, Julie Sussman:<br />
<i>Structure and Interpretation of Computer Programs</i><br />
MIT Press. 1985, 1996 (a možná vyšel i další přetisk)
</li>

<li>Paul Graham<br />
<i>On Lisp</i><br />
Prentice Hall, 1993<br />
Dostupné online na adrese <a href="http://www.paulgraham.com/onlisptext.html">http://www.paulgraham.com/onlisptext.html</a>
</li>

<li>David S. Touretzky<br />
<i>Common LISP: A Gentle Introduction to Symbolic Computation (Dover Books on Engineering)</i><br />
</li>

<li>Peter Norvig<br />
<i>Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp</i>
</li>

<li>Patrick Winston, Berthold Horn<br />
<i>Lisp (3rd Edition)</i><br />
ISBN-13: 978-0201083194, ISBN-10: 0201083191
</li>

<li>Matthias Felleisen, David Van Horn, Dr. Conrad Barski<br>
<i>Realm of Racket: Learn to Program, One Game at a Time!</i><br />
ISBN-13: 978-1593274917, ISBN-10: 1593274912 
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Common Lisp<br />
<a href="https://lisp-lang.org/">https://lisp-lang.org/</a>
</li>

<li>Why You Should Learn Lisp In 2022?<br />
<a href="https://www.youtube.com/watch?v=GWdf1flcLoM">https://www.youtube.com/watch?v=GWdf1flcLoM</a>
</li>

<li>LOOP Common Lisps Superior For<br />
<a href="https://www.youtube.com/watch?v=i4tmF_1nZng">https://www.youtube.com/watch?v=i4tmF_1nZng</a>
</li>

<li>Lisp VS C benchmarks<br />
<a href="https://programming-language-benchmarks.vercel.app/lisp-vs-c">https://programming-language-benchmarks.vercel.app/lisp-vs-c</a>
</li>

<li>Common Lisp: An elegant design pattern<br />
<a href="https://www.youtube.com/watch?v=9597LFlvMuE">https://www.youtube.com/watch?v=9597LFlvMuE</a>
</li>

<li>Common Lisp Macros By Example Tutorial<br />
<a href="https://lisp-journey.gitlab.io/blog/common-lisp-macros-by-example-tutorial/">https://lisp-journey.gitlab.io/blog/common-lisp-macros-by-example-tutorial/</a>
</li>

<li>The Common Lisp Cookbook<br />
<a href="https://lispcookbook.github.io/cl-cookbook/">https://lispcookbook.github.io/cl-cookbook/</a>
</li>

<li>The Evolution of Lisp<br />
<a href="https://www.csee.umbc.edu/courses/331/resources/papers/Evolution-of-Lisp.pdf">https://www.csee.umbc.edu/courses/331/resources/papers/Evolution-of-Lisp.pdf</a>
</li>

<li>Awesome CL<br />
<a href="https://github.com/CodyReichert/awesome-cl">https://github.com/CodyReichert/awesome-cl</a>
</li>

<li>LISP<br />
<a href="https://taoofmac.com/space/dev/lisp">https://taoofmac.com/space/dev/lisp</a>
</li>

<li>Repositář projektu femtolisp<br />
<a href="https://github.com/JeffBezanson/femtolisp">https://github.com/JeffBezanson/femtolisp</a>
</li>

<li>Femtolisp - lightweight, robust lisp interpreter built on reusable C libraries<br />
<a href="https://www.findbestopensource.com/product/femtolisp">https://www.findbestopensource.com/product/femtolisp</a>
</li>

<li>YCombinator: Femtolisp: A lightweight, robust, scheme-like Lisp implementation<br />
<a href="https://news.ycombinator.com/item?id=22094722">https://news.ycombinator.com/item?id=22094722</a>
</li>

<li>Learning Julia by Anshul Joshi, Rahul Lakhanpal: Femtolisp<br />
<a href="https://www.oreilly.com/library/view/learning-julia/9781785883279/2e85442f-d100-4b53-b8f7-7d20d62f0255.xhtml">https://www.oreilly.com/library/view/learning-julia/9781785883279/2e85442f-d100-4b53-b8f7-7d20d62f0255.xhtml</a>
</li>

<li>The role of femtolisp in Julia?<br />
<a href="https://discourse.julialang.org/t/the-role-of-femtolisp-in-julia/1902">https://discourse.julialang.org/t/the-role-of-femtolisp-in-julia/1902</a>
</li>

<li>LispSyntax.jl: A clojure-like lisp syntax for julia<br />
<a href="https://github.com/swadey/LispSyntax.jl">https://github.com/swadey/LispSyntax.jl</a>
</li>

<li>What exactly code lowering is an how to do “unlowering”?<br />
<a href="https://discourse.julialang.org/t/what-exactly-code-lowering-is-an-how-to-do-unlowering/1315">https://discourse.julialang.org/t/what-exactly-code-lowering-is-an-how-to-do-unlowering/1315</a>
</li>

<li>Interlisp.org: Dedicated to Restoring and Preserving the Interlisp experience<br />
<a href="https://github.com/Interlisp">https://github.com/Interlisp</a>
</li>

<li>Warren Teitelman<br />
<a href="https://en.wikipedia.org/wiki/Warren_Teitelman">https://en.wikipedia.org/wiki/Warren_Teitelman</a>
</li>

<li>InterLISP/65<br />
<a href="http://www.atarimania.com/utility-atari-400-800-xl-xe-interlisp-65_12477.html">http://www.atarimania.com/utility-atari-400-800-xl-xe-interlisp-65_12477.html</a>
</li>

<li>Lisp Editing in the 80s - Interlisp SEdit (Video)<br />
<a href="https://www.youtube.com/watch?v=2qsmF8HHskg">https://www.youtube.com/watch?v=2qsmF8HHskg</a>
</li>

<li>Inter-LISP<br />
<a href="http://www.atarimania.com/utility-atari-400-800-xl-xe-inter-lisp_29354.html">http://www.atarimania.com/utility-atari-400-800-xl-xe-inter-lisp_29354.html</a>
</li>

<li>InterLISP 65 Editing (video)<br />
<a href="https://www.youtube.com/watch?v=nY_hcazo86A">https://www.youtube.com/watch?v=nY_hcazo86A</a>
</li>

<li>Datasoft INTER-LISP/65 (Atari Age, chat)<br />
<a href="https://atariage.com/forums/topic/116093-datasoft-inter-lisp65/">https://atariage.com/forums/topic/116093-datasoft-inter-lisp65/</a>
</li>

<li>Marvin Minsky - The beauty of the Lisp language (44/151)<br />
<a href="https://www.youtube.com/watch?v=YaWVHyIBVeI">https://www.youtube.com/watch?v=YaWVHyIBVeI</a>
</li>

<li>History of LISP (Interlisp)<br />
<a href="http://www.softwarepreservation.org/projects/LISP/index.html#INTERLISP_">http://www.softwarepreservation.org/projects/LISP/index.html#INTERLISP_</a>
</li>

<li>Computer-Assisted Instruction (Bits and Bytes, Episode 7)<br />
<a href="https://www.youtube.com/watch?v=eURtTV_qKw8">https://www.youtube.com/watch?v=eURtTV_qKw8</a>
</li>

<li>Můžeme věřit překladačům? Projekty řešící schéma „důvěřivé důvěry“<br />
<a href="https://www.root.cz/clanky/muzeme-verit-prekladacum-projekty-resici-schema-duverive-duvery/">https://www.root.cz/clanky/muzeme-verit-prekladacum-projekty-resici-schema-duverive-duvery/</a>
</li>

<li>Gambit in the browser<br />
<a href="https://feeley.github.io/gambit-in-the-browser/">https://feeley.github.io/gambit-in-the-browser/</a>
</li>

<li>A Tour of Scheme in Gambit<br />
<a href="http://dynamo.iro.umontreal.ca/wiki/images/a/a7/A_Tour_of_Scheme_in_Gambit.pdf">http://dynamo.iro.umontreal.ca/wiki/images/a/a7/A_Tour_of_Scheme_in_Gambit.pdf</a>
</li>

<li>Gambit Scheme: Inside Out<br />
<a href="http://www.iro.umontreal.ca/~gambit/Gambit-inside-out.pdf">http://www.iro.umontreal.ca/~gambit/Gambit-inside-out.pdf</a>
</li>

<li>Gambit Internal Documentation<br />
<a href="http://dynamo.iro.umontreal.ca/wiki/index.php/Internal_Documentation">http://dynamo.iro.umontreal.ca/wiki/index.php/Internal_Documentation</a>
</li>

<li>clojure-scheme: Compiling to Native Code via Scheme <br />
<a href="http://www.iro.umontreal.ca/~gambit/Sorenson-Clojure-to-Native-via-Scheme.pdf">http://www.iro.umontreal.ca/~gambit/Sorenson-Clojure-to-Native-via-Scheme.pdf</a>
</li>

<li>Gauche &ndash; a Scheme implementation<br />
<a href="http://practical-scheme.net/gauche/">http://practical-scheme.net/gauche/</a>
</li>

<li>Scheme48<br />
<a href="https://s48.org/">https://s48.org/</a>
</li>

<li>SISC (Second Interpreter of Scheme)<br />
<a href="http://sisc-scheme.org/">http://sisc-scheme.org/</a>
</li>

<li>The SCM Implementation of Scheme<br />
<a href="https://people.csail.mit.edu/jaffer/SCM.html">https://people.csail.mit.edu/jaffer/SCM.html</a>
</li>

<li>Ypsilon - The ultimate script language system for the video pinball fourth generation<br />
<a href="http://www.littlewingpinball.com/doc/en/ypsilon/index.html">http://www.littlewingpinball.com/doc/en/ypsilon/index.html</a>
</li>

<li>Chicken Scheme<br />
<a href="https://call-cc.org/">https://call-cc.org/</a>
</li>

<li>Eggs Unlimited<br />
<a href="http://wiki.call-cc.org/chicken-projects/egg-index-5.html">http://wiki.call-cc.org/chicken-projects/egg-index-5.html</a>
</li>

<li>Chicken Scheme Wiki<br />
<a href="https://wiki.call-cc.org/">https://wiki.call-cc.org/</a>
</li>

<li>CHICKEN for Python programmers<br />
<a href="https://wiki.call-cc.org/chicken-for-python-programmers">https://wiki.call-cc.org/chicken-for-python-programmers</a>
</li>

<li>Programming for Performance<br />
<a href="http://wiki.call-cc.org/programming-for-performance">http://wiki.call-cc.org/programming-for-performance</a>
</li>

<li>Using the compiler<br />
<a href="https://wiki.call-cc.org/man/4/Using%20the%20compiler">https://wiki.call-cc.org/man/4/Using%20the%20compiler</a>
</li>

<li>CHICKEN Scheme tutorials<br />
<a href="https://wiki.call-cc.org/tutorials">https://wiki.call-cc.org/tutorials</a>
</li>

<li>Traditional Turtles<br />
<a href="https://docs.racket-lang.org/turtles/Traditional_Turtles.html">https://docs.racket-lang.org/turtles/Traditional_Turtles.html</a>
</li>

<li>[racket] How best to repeat a function call n times?<br />
<a href="https://lists.racket-lang.org/users/archive/2014-September/064203.html">https://lists.racket-lang.org/users/archive/2014-September/064203.html</a>
</li>

<li>Racket: Macros<br />
<a href="https://www.it.uu.se/edu/course/homepage/avfunpro/ht13/lectures/Racket-3-Macros.pdf">https://www.it.uu.se/edu/course/homepage/avfunpro/ht13/lectures/Racket-3-Macros.pdf</a>
</li>

<li>Beautiful Racket / explainers: Macros<br />
<a href="https://beautifulracket.com/explainer/macros.html">https://beautifulracket.com/explainer/macros.html</a>
</li>

<li>Macros (dokumentace k Racketu)<br />
<a href="https://docs.racket-lang.org/guide/macros.html">https://docs.racket-lang.org/guide/macros.html</a>
</li>

<li>Model syntaxe jazyka Racket<br />
<a href="https://docs.racket-lang.org/reference/syntax-model.html">https://docs.racket-lang.org/reference/syntax-model.html</a>
</li>

<li>Syntax Objects<br />
<a href="https://docs.racket-lang.org/guide/stx-obj.html">https://docs.racket-lang.org/guide/stx-obj.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Beautiful Racket: an intro­duction to language-oriented programming using Racket<br />
<a href="https://beautifulracket.com/">https://beautifulracket.com/</a>
</li>

<li>Stránky projektu Racket<br />
<a href="https://racket-lang.org/">https://racket-lang.org/</a>
</li>

<li>Dokumentace k&nbsp;projektu Racket<br />
<a href="https://docs.racket-lang.org/index.html">https://docs.racket-lang.org/index.html</a>
</li>

<li>Seznam dostupných balíčků pro Racket<br />
<a href="https://pkgs.racket-lang.org/">https://pkgs.racket-lang.org/</a>
</li>

<li>Racket na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Racket_(programming_language)">https://en.wikipedia.org/wiki/Racket_(programming_language)</a>
</li>

<li>Vector Library (R7RS-compatible)<br />
<a href="https://srfi.schemers.org/srfi-133/srfi-133.html">https://srfi.schemers.org/srfi-133/srfi-133.html</a>
</li>

<li>Blogy o Racketu a navazujících technologiích<br />
<a href="https://blog.racket-lang.org/">https://blog.racket-lang.org/</a>
</li>

<li>Prográmky psané v&nbsp;Racketu na RosettaCode<br />
<a href="http://rosettacode.org/wiki/Category:Racket">http://rosettacode.org/wiki/Category:Racket</a>
</li>

<li>Fear of Macros<br />
<a href="https://www.greghendershott.com/fear-of-macros/">https://www.greghendershott.com/fear-of-macros/</a>
</li>

<li>Rackjure<br />
<a href="https://github.com/greghendershott/rackjure">https://github.com/greghendershott/rackjure</a>
</li>

<li>Matthew Flatt’s proposal to change Racket’s s-expressions based syntax to infix representation creates a stir in the community<br />
<a href="https://hub.packtpub.com/matthew-flatts-proposal-to-change-rackets-s-expressions-based-syntax-to-infix-representation-creates-a-stir-in-the-community/">https://hub.packtpub.com/matthew-flatts-proposal-to-change-rackets-s-expressions-based-syntax-to-infix-representation-creates-a-stir-in-the-community/</a>
</li>

<li>Racket News<br />
<a href="https://racket-news.com/">https://racket-news.com/</a>
</li>

<li>Racket: Lisp for learning<br />
<a href="https://lwn.net/Articles/795385/">https://lwn.net/Articles/795385/</a>
</li>

<li>Future of Racket<br />
<a href="https://www.greghendershott.com/2019/07/future-of-racket.html">https://www.greghendershott.com/2019/07/future-of-racket.html</a>
</li>

<li>Vectors (pro Gauche)<br />
<a href="https://practical-scheme.net/gauche/man/gauche-refe/Vectors.html">https://practical-scheme.net/gauche/man/gauche-refe/Vectors.html</a>
</li>

<li>Kawa: Compiling Scheme to Java<br />
<a href="https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html">https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html</a>
</li>

<li>Kawa in Languages shootout<br />
<a href="http://per.bothner.com/blog/2010/Kawa-in-shootout/">http://per.bothner.com/blog/2010/Kawa-in-shootout/</a>
</li>

<li>Kawa 2.0 Supports Scheme R7RS<br />
<a href="https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/">https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/</a>
</li>

<li>Kawa — fast scripting on the Java platform<br />
<a href="https://lwn.net/Articles/623349/">https://lwn.net/Articles/623349/</a>
</li>

<li>Tail call (a její optimalizace)<br />
<a href="https://en.wikipedia.org/wiki/Tail_call">https://en.wikipedia.org/wiki/Tail_call</a>
</li>

<li>SLIME (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/SLIME">http://en.wikipedia.org/wiki/SLIME</a>
</li>

<li>slime.vim<br />
<a href="http://s3.amazonaws.com/mps/slime.vim">http://s3.amazonaws.com/mps/slime.vim</a>
</li>

<li>What are the best scheme implementations?<br />
<a href="https://www.slant.co/topics/5282/~scheme-implementations">https://www.slant.co/topics/5282/~scheme-implementations</a>
</li>

<li>Bigloo homepage<br />
<a href="http://www-sop.inria.fr/mimosa/fp/Bigloo/">http://www-sop.inria.fr/mimosa/fp/Bigloo/</a>
</li>

<li>FTP s tarbally Bigloo<br />
<a href="ftp://ftp-sop.inria.fr/indes/fp/Bigloo">ftp://ftp-sop.inria.fr/indes/fp/Bigloo</a>
</li>

<li>GOTO 2018 • Functional Programming in 40 Minutes • Russ Olsen<br />
<a href="https://www.youtube.com/watch?v=0if71HOyVjY">https://www.youtube.com/watch?v=0if71HOyVjY</a>
</li>

<li>TinyScheme (stránka na Sourceforge)<br />
<a href="http://tinyscheme.sourceforge.net/home.html">http://tinyscheme.sourceforge.net/home.html</a>
</li>

<li>Embedding Tiny Scheme in a Game<br />
<a href="http://www.silicondelight.com/embedding-tiny-scheme-in-a-game/">http://www.silicondelight.com/embedding-tiny-scheme-in-a-game/</a>
</li>

<li>Embedding Scheme for a game mission scripting DSL<br />
<a href="http://carloscarrasco.com/embedding-scheme-for-a-game-mission-scripting-dsl.html">http://carloscarrasco.com/embedding-scheme-for-a-game-mission-scripting-dsl.html</a>
</li>

<li>Všechny verze TinyScheme na SourceForge<br />
<a href="https://sourceforge.net/projects/tinyscheme/files/tinyscheme/">https://sourceforge.net/projects/tinyscheme/files/tinyscheme/</a>
</li>

<li>Fork TinyScheme na GitHubu<br />
<a href="https://github.com/yawnt/tinyscheme">https://github.com/yawnt/tinyscheme</a>
</li>

<li>Ackermannova funkce<br />
<a href="https://cs.wikipedia.org/wiki/Ackermannova_funkce">https://cs.wikipedia.org/wiki/Ackermannova_funkce</a>
</li>

<li>Ackermann function na Rosetta Code<br />
<a href="https://rosettacode.org/wiki/Ackermann_function#Scheme">https://rosettacode.org/wiki/Ackermann_function#Scheme</a>
</li>

<li>Success Stories (lisp.org)<br />
<a href="https://lisp-lang.org/success/">https://lisp-lang.org/success/</a>
</li>

<li>Allegro Common Lisp Success Stories<br />
<a href="https://franz.com/success/">https://franz.com/success/</a>
</li>

<li>Clojure Success Stories<br />
<a href="https://clojure.org/community/success_stories">https://clojure.org/community/success_stories</a>
</li>

<li>Scheme Quick Reference<br />
<a href="https://www.st.cs.uni-saarland.de/edu/config-ss04/scheme-quickref.pdf">https://www.st.cs.uni-saarland.de/edu/config-ss04/scheme-quickref.pdf</a>
</li>

<li>Slajdy o Scheme (od slajdu číslo 15)<br />
<a href="https://docs.google.com/presentation/d/1abmDnKjrq1tcjGvvRNAKhOiSTSE2lyagtcEPal07Gbo/edit">https://docs.google.com/presentation/d/1abmDnKjrq1tcjGvvRNAKhOiSTSE2lyagtcEPal07Gbo/edit</a>
</li>

<li>Scheme Cheat Sheet<br />
<a href="https://github.com/smythp/scheme-cheat-sheet">https://github.com/smythp/scheme-cheat-sheet</a>
</li>

<li>Embedding Lua, embedding Guile <br />
<a href="http://puntoblogspot.blogspot.com/2013/04/embedding-lua-embedding-guile.html">http://puntoblogspot.blogspot.com/2013/04/embedding-lua-embedding-guile.html</a>
</li>

<li>Lambda Papers<br />
<a href="https://en.wikisource.org/wiki/Lambda_Papers">https://en.wikisource.org/wiki/Lambda_Papers</a>
</li>

<li>Revised<sup>7</sup>Report on the Algorithmic Language Scheme<br />
<a href="https://small.r7rs.org/attachment/r7rs.pdf">https://small.r7rs.org/attachment/r7rs.pdf</a>
</li>

<li>Video Lectures (MIT, SICP 2005)<br />
<a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/</a>
</li>

<li>Why is Scheme my first language in university?<br />
<a href="https://softwareengineering.stackexchange.com/questions/115252/why-is-scheme-my-first-language-in-university">https://softwareengineering.stackexchange.com/questions/115252/why-is-scheme-my-first-language-in-university</a>
</li>

<li>The Perils of JavaSchools<br />
<a href="https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/">https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/</a>
</li>

<li>How to Design Programs, Second Edition<br />
<a href="https://htdp.org/2019-02-24/index.html">https://htdp.org/2019-02-24/index.html</a>
</li>

<li>LilyPond<br />
<a href="http://lilypond.org/">http://lilypond.org/</a>
</li>

<li>LilyPond — Extending (přes Scheme)<br />
<a href="http://lilypond.org/doc/v2.18/Documentation/extending/scheme-tutorial">http://lilypond.org/doc/v2.18/Documentation/extending/scheme-tutorial</a>
</li>

<li>Scheme in LilyPond<br />
<a href="http://lilypond.org/doc/v2.18/Documentation/extending/scheme-in-lilypond">http://lilypond.org/doc/v2.18/Documentation/extending/scheme-in-lilypond</a>
</li>

<li>GnuCash<br />
<a href="http://www.gnucash.org/">http://www.gnucash.org/</a>
</li>

<li>Custom Reports (in GNU Cash)<br />
<a href="https://wiki.gnucash.org/wiki/Custom_Reports">https://wiki.gnucash.org/wiki/Custom_Reports</a>
</li>

<li>Program by Design<br />
<a href="https://programbydesign.org/">https://programbydesign.org/</a>
</li>

<li>SchemePy<br />
<a href="https://pypi.org/project/SchemePy/">https://pypi.org/project/SchemePy/</a>
</li>

<li>LISP FQA: Section - [1-5] What is the "minimal" set of primitives needed for a Lisp interpreter?<br />
<a href="http://www.faqs.org/faqs/lisp-faq/part1/section-6.html">http://www.faqs.org/faqs/lisp-faq/part1/section-6.html</a>
</li>

<li>femtolisp<br />
<a href="https://github.com/JeffBezanson/femtolisp">https://github.com/JeffBezanson/femtolisp</a>
</li>

<li>(How to Write a (Lisp) Interpreter (in Python))<br />
<a href="http://norvig.com/lispy.html">http://norvig.com/lispy.html</a>
</li>

<li>Repositář s&nbsp;Guile Emacsem<br />
<a href="http://git.hcoop.net/?p=bpt/guile.git">http://git.hcoop.net/?p=bpt/guile.git</a>
</li>

<li>Interacting with Guile Compound Data Types in C<br />
<a href="http://www.lonelycactus.com/guilebook/x1555.html">http://www.lonelycactus.com/guilebook/x1555.html</a>
</li>

<li>Calling Guile functions from C<br />
<a href="http://www.lonelycactus.com/guilebook/c1204.html#SECCALLGUILEFUNC">http://www.lonelycactus.com/guilebook/c1204.html#SECCALLGUILEFUNC</a>
</li>

<li>Arrays, and other compound data types<br />
<a href="http://www.lonelycactus.com/guilebook/charrays.html">http://www.lonelycactus.com/guilebook/charrays.html</a>
</li>

<li>Interacting with Guile Compound Data Types in C<br />
<a href="http://www.lonelycactus.com/guilebook/x1555.html">http://www.lonelycactus.com/guilebook/x1555.html</a>
</li>

<li>Guile Reference Manual<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/index.html">https://www.gnu.org/software/guile/manual/html_node/index.html</a>
</li>

<li>Scheme: Summary of Common Syntax<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/Syntax-Summary.html#Syntax-Summary">https://www.gnu.org/software/guile/manual/html_node/Syntax-Summary.html#Syntax-Summary</a>
</li>

<li>Scripting with Guile: Extension language enhances C and Scheme<br />
<a href="https://www.ibm.com/developerworks/library/l-guile/index.html">https://www.ibm.com/developerworks/library/l-guile/index.html</a>
</li>

<li>Having fun with Guile: a tutorial<br />
<a href="http://dustycloud.org/misc/guile-tutorial.html">http://dustycloud.org/misc/guile-tutorial.html</a>
</li>

<li>Guile: Loading Readline Support<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/Loading-Readline-Support.html#Loading-Readline-Support">https://www.gnu.org/software/guile/manual/html_node/Loading-Readline-Support.html#Loading-Readline-Support</a>
</li>

<li>lispy<br />
<a href="https://pypi.org/project/lispy/">https://pypi.org/project/lispy/</a>
</li>

<li>Lython<br />
<a href="https://pypi.org/project/Lython/">https://pypi.org/project/Lython/</a>
</li>

<li>Lizpop<br />
<a href="https://pypi.org/project/lizpop/">https://pypi.org/project/lizpop/</a>
</li>

<li>Budoucnost programovacích jazyků<br />
<a href="http://www.knesl.com/budoucnost-programovacich-jazyku">http://www.knesl.com/budoucnost-programovacich-jazyku</a>
</li>

<li>LISP Prolog and Evolution<br />
<a href="http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html">http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html</a>
</li>

<li>List of Lisp-family programming languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages">https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages</a>
</li>

<li>clojure_py na indexu PyPi<br />
<a href="https://pypi.python.org/pypi/clojure_py">https://pypi.python.org/pypi/clojure_py</a>
</li>

<li>PyClojure<br />
<a href="https://github.com/eigenhombre/PyClojure">https://github.com/eigenhombre/PyClojure</a>
</li>

<li>Hy na GitHubu<br />
<a href="https://github.com/hylang/hy">https://github.com/hylang/hy</a>
</li>

<li>Hy: The survival guide<br />
<a href="https://notes.pault.ag/hy-survival-guide/">https://notes.pault.ag/hy-survival-guide/</a>
</li>

<li>Hy běžící na monitoru terminálu společnosti Symbolics<br />
<a href="http://try-hy.appspot.com/">http://try-hy.appspot.com/</a>
</li>

<li>Welcome to Hy’s documentation!<br />
<a href="http://docs.hylang.org/en/stable/">http://docs.hylang.org/en/stable/</a>
</li>

<li>Hy na PyPi<br />
<a href="https://pypi.org/project/hy/#description">https://pypi.org/project/hy/#description</a>
</li>

<li>Getting Hy on Python<br />
<a href="https://lwn.net/Articles/596626/">https://lwn.net/Articles/596626/</a>
</li>

<li>Programming Can Be Fun with Hy<br />
<a href="https://opensourceforu.com/2014/02/programming-can-fun-hy/">https://opensourceforu.com/2014/02/programming-can-fun-hy/</a>
</li>

<li>Přednáška o projektu Hy (pětiminutový lighttalk)<br />
<a href="http://blog.pault.ag/day/2013/04/02">http://blog.pault.ag/day/2013/04/02</a>
</li>

<li>Hy (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Hy">https://en.wikipedia.org/wiki/Hy</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Point<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Point.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Point.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Narrowing<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Narrowing.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Narrowing.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Functions that Create Markers<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Markers.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Markers.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Motion<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Motion.html#Motion">https://www.gnu.org/software/emacs/manual/html_node/elisp/Motion.html#Motion</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Basic Char Syntax<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Char-Syntax.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Char-Syntax.html</a>
</li>

<li>Elisp: Sequence: List, Array<br />
<a href="http://ergoemacs.org/emacs/elisp_list_vs_vector.html">http://ergoemacs.org/emacs/elisp_list_vs_vector.html</a>
</li>

<li>Elisp: Property List<br />
<a href="http://ergoemacs.org/emacs/elisp_property_list.html">http://ergoemacs.org/emacs/elisp_property_list.html</a>
</li>

<li>Elisp: Hash Table<br />
<a href="http://ergoemacs.org/emacs/elisp_hash_table.html">http://ergoemacs.org/emacs/elisp_hash_table.html</a>
</li>

<li>Elisp: Association List<br />
<a href="http://ergoemacs.org/emacs/elisp_association_list.html">http://ergoemacs.org/emacs/elisp_association_list.html</a>
</li>

<li>The mapcar Function (An Introduction to Programming in Emacs Lisp)<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/mapcar.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/mapcar.html</a>
</li>

<li>Anaphoric macro<br />
<a href="https://en.wikipedia.org/wiki/Anaphoric_macro">https://en.wikipedia.org/wiki/Anaphoric_macro</a>
</li>

<li>Some Common Lisp Loop Macro Examples<br />
<a href="https://www.youtube.com/watch?v=3yl8o6r_omw">https://www.youtube.com/watch?v=3yl8o6r_omw</a>
</li>

<li>A Guided Tour of Emacs<br />
<a href="https://www.gnu.org/software/emacs/tour/">https://www.gnu.org/software/emacs/tour/</a>
</li>

<li>The Roots of Lisp<br />
<a href="http://www.paulgraham.com/rootsoflisp.html">http://www.paulgraham.com/rootsoflisp.html</a>
</li>

<li>Evil (Emacs Wiki)<br />
<a href="https://www.emacswiki.org/emacs/Evil">https://www.emacswiki.org/emacs/Evil</a>
</li>

<li>Evil (na GitHubu)<br />
<a href="https://github.com/emacs-evil/evil">https://github.com/emacs-evil/evil</a>
</li>

<li>Evil (na stránkách repositáře MELPA)<br />
<a href="https://melpa.org/#/evil">https://melpa.org/#/evil</a>
</li>

<li>Evil Mode: How I Switched From VIM to Emacs<br />
<a href="https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html">https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html</a>
</li>

<li>GNU Emacs (home page)<br />
<a href="https://www.gnu.org/software/emacs/">https://www.gnu.org/software/emacs/</a>
</li>

<li>GNU Emacs (texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs">http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs</a>
</li>

<li>An Introduction To Using GDB Under Emacs<br />
<a href="http://tedlab.mit.edu/~dr/gdbintro.html">http://tedlab.mit.edu/~dr/gdbintro.html</a>
</li>

<li>An Introduction to Programming in Emacs Lisp<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html</a>
</li>

<li>27.6 Running Debuggers Under Emacs<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html">https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html</a>
</li>

<li>GdbMode<br />
<a href="http://www.emacswiki.org/emacs/GdbMode">http://www.emacswiki.org/emacs/GdbMode</a>
</li>

<li>Emacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Emacs">https://en.wikipedia.org/wiki/Emacs</a>
</li>

<li>Emacs timeline<br />
<a href="http://www.jwz.org/doc/emacs-timeline.html">http://www.jwz.org/doc/emacs-timeline.html</a>
</li>

<li>Emacs Text Editors Family<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?EmacsFamily">http://texteditors.org/cgi-bin/wiki.pl?EmacsFamily</a>
</li>

<li>Vrapper aneb spojení možností Vimu a Eclipse<br />
<a href="https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse/">https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse/</a>
</li>

<li>Vrapper aneb spojení možností Vimu a Eclipse (část 2: vyhledávání a nahrazování textu)<br />
<a href="https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse-cast-2-vyhledavani-a-nahrazovani-textu/">https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse-cast-2-vyhledavani-a-nahrazovani-textu/</a>
</li>

<li>Emacs/Evil-mode - A basic reference to using evil mode in Emacs<br />
<a href="http://www.aakarshnair.com/posts/emacs-evil-mode-cheatsheet">http://www.aakarshnair.com/posts/emacs-evil-mode-cheatsheet</a>
</li>

<li>From Vim to Emacs+Evil chaotic migration guide<br />
<a href="https://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/">https://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/</a>
</li>

<li>Introduction to evil-mode {video)<br />
<a href="https://www.youtube.com/watch?v=PeVQwYUxYEg">https://www.youtube.com/watch?v=PeVQwYUxYEg</a>
</li>

<li>EINE (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/EINE">http://www.emacswiki.org/emacs/EINE</a>
</li>

<li>EINE (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?EINE">http://texteditors.org/cgi-bin/wiki.pl?EINE</a>
</li>

<li>ZWEI (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/ZWEI">http://www.emacswiki.org/emacs/ZWEI</a>
</li>

<li>ZWEI (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?ZWEI">http://texteditors.org/cgi-bin/wiki.pl?ZWEI</a>
</li>

<li>Zmacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Zmacs">https://en.wikipedia.org/wiki/Zmacs</a>
</li>

<li>Zmacs (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?Zmacs">http://texteditors.org/cgi-bin/wiki.pl?Zmacs</a>
</li>

<li>TecoEmacs (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/TecoEmacs">http://www.emacswiki.org/emacs/TecoEmacs</a>
</li>

<li>Micro Emacs<br />
<a href="http://www.emacswiki.org/emacs/MicroEmacs">http://www.emacswiki.org/emacs/MicroEmacs</a>
</li>

<li>Micro Emacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/MicroEMACS">https://en.wikipedia.org/wiki/MicroEMACS</a>
</li>

<li>EmacsHistory<br />
<a href="http://www.emacswiki.org/emacs/EmacsHistory">http://www.emacswiki.org/emacs/EmacsHistory</a>
</li>

<li>Seznam editorů s ovládáním podobným Emacsu či kompatibilních s příkazy Emacsu<br />
<a href="http://www.finseth.com/emacs.html">http://www.finseth.com/emacs.html</a>
</li>

<li>evil-numbers<br />
<a href="https://github.com/cofi/evil-numbers">https://github.com/cofi/evil-numbers</a>
</li>

<li>Debuggery a jejich nadstavby v&nbsp;Linuxu (1.část)<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/</a>
</li>

<li>Debuggery a jejich nadstavby v&nbsp;Linuxu (2.část)<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (3): Nemiver<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (4): KDbg<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (5): ladění aplikací v editorech Emacs a Vim<br />
<a href="https://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">https://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/</a>
</li>

<li>Org mode<br />
<a href="https://orgmode.org/">https://orgmode.org/</a>
</li>

<li>The Org Manual<br />
<a href="https://orgmode.org/manual/index.html">https://orgmode.org/manual/index.html</a>
</li>

<li>Kakoune (modální textový editor)<br />
<a href="http://kakoune.org/">http://kakoune.org/</a>
</li>

<li>Vim-style keybinding in Emacs/Evil-mode<br />
<a href="https://gist.github.com/troyp/6b4c9e1c8670200c04c16036805773d8">https://gist.github.com/troyp/6b4c9e1c8670200c04c16036805773d8</a>
</li>

<li>Emacs - jak začít<br />
<a href="http://www.abclinuxu.cz/clanky/navody/emacs-jak-zacit">http://www.abclinuxu.cz/clanky/navody/emacs-jak-zacit</a>
</li>

<li>Programovací jazyk LISP a LISP machines<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-lisp-a-lisp-machines/">https://www.root.cz/clanky/programovaci-jazyk-lisp-a-lisp-machines/</a>
</li>

<li>Evil-surround<br />
<a href="https://github.com/emacs-evil/evil-surround">https://github.com/emacs-evil/evil-surround</a>
</li>

<li>Spacemacs<br />
<a href="http://spacemacs.org/">http://spacemacs.org/</a>
</li>

<li>Lisp: Common Lisp, Racket, Clojure, Emacs Lisp<br />
<a href="http://hyperpolyglot.org/lisp">http://hyperpolyglot.org/lisp</a>
</li>

<li>Common Lisp, Scheme, Clojure, And Elisp Compared<br />
<a href="http://irreal.org/blog/?p=725">http://irreal.org/blog/?p=725</a>
</li>

<li>Does Elisp Suck?<br />
<a href="http://irreal.org/blog/?p=675">http://irreal.org/blog/?p=675</a>
</li>

<li>Emacs pro mírně pokročilé (9): Elisp<br />
<a href="https://www.root.cz/clanky/emacs-elisp/">https://www.root.cz/clanky/emacs-elisp/</a>
</li>

<li>If I want to learn lisp, are emacs and elisp a good choice?<br />
<a href="https://www.reddit.com/r/emacs/comments/2m141y/if_i_want_to_learn_lisp_are_emacs_and_elisp_a/">https://www.reddit.com/r/emacs/comments/2m141y/if_i_want_to_learn_lisp_are_emacs_and_elisp_a/</a>
</li>

<li>Clojure(Script) Interactive Development Environment that Rocks!<br />
<a href="https://github.com/clojure-emacs/cider">https://github.com/clojure-emacs/cider</a>
</li>

<li>An Introduction to Emacs Lisp<br />
<a href="https://harryrschwartz.com/2014/04/08/an-introduction-to-emacs-lisp.html">https://harryrschwartz.com/2014/04/08/an-introduction-to-emacs-lisp.html</a>
</li>

<li>Emergency Elisp<br />
<a href="http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html">http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html</a>
</li>

<li>Lambda calculus<br />
<a href="https://en.wikipedia.org/wiki/Lambda_calculus">https://en.wikipedia.org/wiki/Lambda_calculus</a>
</li>

<li>John McCarthy's original LISP paper from 1959<br />
<a href="https://www.reddit.com/r/programming/comments/17lpz4/john_mccarthys_original_lisp_paper_from_1959/">https://www.reddit.com/r/programming/comments/17lpz4/john_mccarthys_original_lisp_paper_from_1959/</a>
</li>

<li>Micro Manual LISP<br />
<a href="https://www.scribd.com/document/54050141/Micro-Manual-LISP">https://www.scribd.com/document/54050141/Micro-Manual-LISP</a>
</li>

<li>How Lisp Became God's Own Programming Language<br />
<a href="https://twobithistory.org/2018/10/14/lisp.html">https://twobithistory.org/2018/10/14/lisp.html</a>
</li>

<li>History of Lisp<br />
<a href="http://jmc.stanford.edu/articles/lisp/lisp.pdf">http://jmc.stanford.edu/articles/lisp/lisp.pdf</a>
</li>

<li>The Roots of Lisp<br />
<a href="http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf">http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf</a>
</li>

<li>Racket<br />
<a href="https://racket-lang.org/">https://racket-lang.org/</a>
</li>

<li>The Racket Manifesto<br />
<a href="http://felleisen.org/matthias/manifesto/">http://felleisen.org/matthias/manifesto/</a>
</li>

<li>MIT replaces Scheme with Python<br />
<a href="https://www.johndcook.com/blog/2009/03/26/mit-replaces-scheme-with-python/">https://www.johndcook.com/blog/2009/03/26/mit-replaces-scheme-with-python/</a>
</li>

<li>Adventures in Advanced Symbolic Programming<br />
<a href="http://groups.csail.mit.edu/mac/users/gjs/6.945/">http://groups.csail.mit.edu/mac/users/gjs/6.945/</a>
</li>

<li>Why MIT Switched from Scheme to Python (2009)<br />
<a href="https://news.ycombinator.com/item?id=14167453">https://news.ycombinator.com/item?id=14167453</a>
</li>

<li>Starodávná stránka XLispu<br />
<a href="http://www.xlisp.org/">http://www.xlisp.org/</a>
</li>

<li>AutoLISP<br />
<a href="https://en.wikipedia.org/wiki/AutoLISP">https://en.wikipedia.org/wiki/AutoLISP</a>
</li>

<li>Seriál PicoLisp: minimalistický a výkonný interpret Lispu<br />
<a href="https://www.root.cz/serialy/picolisp-minimalisticky-a-vykonny-interpret-lispu/">https://www.root.cz/serialy/picolisp-minimalisticky-a-vykonny-interpret-lispu/</a>
</li>

<li>Common Lisp<br />
<a href="https://common-lisp.net/">https://common-lisp.net/</a>
</li>

<li>Getting Going with Common Lisp<br />
<a href="https://cliki.net/Getting%20Started">https://cliki.net/Getting%20Started</a>
</li>

<li>Online Tutorial (Common Lisp)<br />
<a href="https://cliki.net/online%20tutorial">https://cliki.net/online%20tutorial</a>
</li>

<li>Guile Emacs<br />
<a href="https://www.emacswiki.org/emacs/GuileEmacs">https://www.emacswiki.org/emacs/GuileEmacs</a>
</li>

<li>Guile Emacs History<br />
<a href="https://www.emacswiki.org/emacs/GuileEmacsHistory">https://www.emacswiki.org/emacs/GuileEmacsHistory</a>
</li>

<li>Guile is a programming language<br />
<a href="https://www.gnu.org/software/guile/">https://www.gnu.org/software/guile/</a>
</li>

<li>MIT Scheme<br />
<a href="http://groups.csail.mit.edu/mac/projects/scheme/">http://groups.csail.mit.edu/mac/projects/scheme/</a>
</li>

<li>SIOD: Scheme in One Defun<br />
<a href="http://people.delphiforums.com/gjc//siod.html">http://people.delphiforums.com/gjc//siod.html</a>
</li>

<li>CommonLispForEmacs<br />
<a href="https://www.emacswiki.org/emacs/CommonLispForEmacs">https://www.emacswiki.org/emacs/CommonLispForEmacs</a>
</li>

<li>Elisp: print, princ, prin1, format, message<br />
<a href="http://ergoemacs.org/emacs/elisp_printing.html">http://ergoemacs.org/emacs/elisp_printing.html</a>
</li>

<li>Special Forms in Lisp<br />
<a href="http://www.nhplace.com/kent/Papers/Special-Forms.html">http://www.nhplace.com/kent/Papers/Special-Forms.html</a>
</li>

<li>Basic Building Blocks in LISP<br />
<a href="https://www.tutorialspoint.com/lisp/lisp_basic_syntax.htm">https://www.tutorialspoint.com/lisp/lisp_basic_syntax.htm</a>
</li>

<li>Introduction to LISP - University of Pittsburgh<br />
<a href="https://people.cs.pitt.edu/~milos/courses/cs2740/Lectures/LispTutorial.pdf">https://people.cs.pitt.edu/~milos/courses/cs2740/Lectures/LispTutorial.pdf</a>
</li>

<li>Why don't people use LISP<br />
<a href="https://forums.freebsd.org/threads/why-dont-people-use-lisp.24572/">https://forums.freebsd.org/threads/why-dont-people-use-lisp.24572/</a>
</li>

<li>Structured program theorem<br />
<a href="https://en.wikipedia.org/wiki/Structured_program_theorem">https://en.wikipedia.org/wiki/Structured_program_theorem</a>
</li>

<li>Clojure: API Documentation<br />
<a href="https://clojure.org/api/api">https://clojure.org/api/api</a>
</li>

<li>Tutorial for the Common Lisp Loop Macro<br />
<a href="http://www.ai.sri.com/pkarp/loop.html">http://www.ai.sri.com/pkarp/loop.html</a>
</li>

<li>Common Lisp's Loop Macro Examples for Beginners<br />
<a href="http://www.unixuser.org/~euske/doc/cl/loop.html">http://www.unixuser.org/~euske/doc/cl/loop.html</a>
</li>

<li>A modern list api for Emacs. No 'cl required.<br />
<a href="https://github.com/magnars/dash.el">https://github.com/magnars/dash.el</a>
</li>

<li>The LOOP Facility<br />
<a href="http://www.lispworks.com/documentation/HyperSpec/Body/06_a.htm">http://www.lispworks.com/documentation/HyperSpec/Body/06_a.htm</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>Transient Data Structures
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>LISP: Lex Fridman's favorite programming language<br />
<a href="https://www.youtube.com/watch?v=cMMiaCtOzV0">https://www.youtube.com/watch?v=cMMiaCtOzV0</a>
</li>

<li>What is the Curse of Lisp?<br />
<a href="https://www.youtube.com/watch?v=_J3x5yvQ8yc">https://www.youtube.com/watch?v=_J3x5yvQ8yc</a>
</li>

<li>Array Programming Re-Imagined in Lisp<br />
<a href="https://github.com/phantomics/april">https://github.com/phantomics/april</a>
</li>

<li>What is Nil Punning?<br />
<a href="https://www.youtube.com/watch?v=xiYKuDk6G-o">https://www.youtube.com/watch?v=xiYKuDk6G-o</a>
</li>

<li>Python VS Common Lisp, workflow and ecosystem<br />
<a href="https://lisp-journey.gitlab.io/pythonvslisp/">https://lisp-journey.gitlab.io/pythonvslisp/</a>
</li>

<li>A fast-moving Common Lisp software distribution<br />
<a href="https://ultralisp.org/">https://ultralisp.org/</a>
</li>

<li>Numcl<br />
<a href="https://github.com/numcl/numcl">https://github.com/numcl/numcl</a>
</li>

<li>Petalisp<br />
<a href="https://github.com/marcoheisig/Petalisp">https://github.com/marcoheisig/Petalisp</a>
</li>

<li>Common Lisp for the Curious Clojurian - Alan Dipert - Scicloj meeting 19<br />
<a href="https://www.youtube.com/watch?v=44Q9ew9JH_U">https://www.youtube.com/watch?v=44Q9ew9JH_U</a>
</li>

<li>Peter Norvig on Python<br />
<a href="https://serverhorror.wordpress.com/2010/10/19/peter-norvig-on-python/">https://serverhorror.wordpress.com/2010/10/19/peter-norvig-on-python/</a>
</li>

<li>A History of the Common Lisp<br />
<a href="https://www.cleverism.com/skills-and-tools/common-lisp/">https://www.cleverism.com/skills-and-tools/common-lisp/</a>
</li>

<li>Starting with Common Lisp in 2020<br />
<a href="http://dnaeon.github.io/starting-with-common-lisp-in-2020/">http://dnaeon.github.io/starting-with-common-lisp-in-2020/</a>
</li>

<li>JACL: JavaScript Assisted Common Lisp<br />
<a href="https://tailrecursion.com/JACL/">https://tailrecursion.com/JACL/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

