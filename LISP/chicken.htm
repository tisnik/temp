<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Chicken Scheme - další interpret a především překladač programovacího jazyka Scheme</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Chicken Scheme - další interpret a především překladač programovacího jazyka Scheme</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Další zdařilá implementace programovacího jazyka Scheme je představována projektem nazvaným Chicken Scheme. Podobně jako u mnoha dalších moderních reinkarnací Scheme se nejedná o pouhý interpret, ale i o překladač. Největší devizou Chicken Scheme je však rozsáhlý ekosystém.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Chicken Scheme &ndash; další interpret a především překladač programovacího jazyka Scheme</a></p>
<p><a href="#k02">2. Překlad a instalace projektu Chicken Scheme</a></p>
<p><a href="#k03">3. Použití interpretru dodávaného současně s&nbsp;Chicken Scheme</a></p>
<p><a href="#k04">4. Překlad skriptu naprogramovaného ve Scheme do nativního kódu</a></p>
<p><a href="#k05">5. Možné problémy při překladu</a></p>
<p><a href="#k06">6. Příprava jednoduchého benchmarku</a></p>
<p><a href="#k07">7. Porovnání rychlosti interpretrů GNU Guile a Chicken Scheme</a></p>
<p><a href="#k08">8. Rychlost benchmarku přeloženého do nativního kódu</a></p>
<p><a href="#k09">9. Porovnání kvality překladače Chicken Scheme s&nbsp;alternativními implementacemi vytvořenými v&nbsp;C a Go</a></p>
<p><a href="#k10">10. Typové informace a jejich vliv na výsledek benchmarku</a></p>
<p><a href="#k11">11. Výsledky všech benchmarků v&nbsp;grafické podobě</a></p>
<p><a href="#k12">12. Další vlastnosti programovacího jazyka implementovaného v&nbsp;rámci Chicken Scheme</a></p>
<p><a href="#k13">13. Funkce a speciální formy</a></p>
<p><a href="#k14">14. Koncová rekurze</a></p>
<p><a href="#k15">15. Lokální rozsah proměnných</a></p>
<p><a href="#k16">16. FFI &ndash; rozhraní mezi Chicken Scheme a nativními jazyky (C apod.)</a></p>
<p><a href="#k17">17. Předchozí části seriálu</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Literatura</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Chicken Scheme &ndash; další interpret a především překladač programovacího jazyka Scheme</h2>

<p>V&nbsp;dnešní části <a
href="https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/">seriálu
o rozsáhlém a možná i poněkud chaotickém světě lispovských programovacích
jazyků</a> se seznámíme se základními vlastnostmi projektu nazvaného <i>Chicken
Scheme</i>, který naleznete na adrese <a
href="https://call-cc.org/">https://call-cc.org/</a>. Podle názvu tohoto
projektu je možné snadno uhodnout, že se jedná o další implementaci
programovacího jazyka Scheme (plně podle R5RS a částečně i R7RS), takže se nám
sbírka již popsaných implementací úspěšně rozrůstá (mimochodem: je zajímavé, že
se Scheme stále drží <a href="https://www.tiobe.com/tiobe-index/">v&nbsp;první
padesátce seznamu nejcitovanějších programovacích jazyků</a>, což je zvláštní,
když si uvědomíme, že například na slavné MIT byl předmět založený na SICP
nahrazen jinými předměty).</p>

<p>Jen pro připomenutí, s&nbsp;jakými variantami tohoto programovacího jazyka
jsme se již setkali: především se jednalo o projekt nazvaný <a
href="https://www.root.cz/clanky/gnu-guile-interpret-scheme-vestavitelny-do-nativnich-aplikaci/">GNU
Guile</a> a taktéž o nástroj <a
href="https://www.root.cz/clanky/tinyscheme-aneb-dalsi-interpret-jazyka-scheme-vestavitelny-do-dalsich-aplikaci/">TinyScheme</a>.
Oba zmíněné projekty nabízí programátorům jak klasickou interaktivní smyčku
REPL, tak i možnost vložit (<i>embed</i>) interpret či překladač jazyka Scheme
do dalších nativních aplikací a tím do značné míry rozšířit jejich možnosti
(skriptovatelné aplikace, aplikace s&nbsp;podporou pluginů získaných od třetích
stran atd.). Zatímco projekt GNU Guile obsahuje jak interpret, tak i překladač
(a to relativně dobrý), je TinyScheme v&nbsp;tomto ohledu mnohem jednodušší,
protože se jedná o &bdquo;pouhý&ldquo; interpret, ovšem pochopitelně doplněný o
automatickou správu paměti a další pro Scheme naprosto nezbytné vlastnosti.</p>

<img src="https://i.iinfo.cz/images/695/chicken-scheme-1.png" class="image-399601" alt="&#160;" width="220" height="118" />
<p><i>Obrázek 1: Logo projektu GNU Guile.</i></p>

<p>Z&nbsp;rozsáhlejších projektů jsme se zmínili o jazyku nazvaném <i>Kawa</i>,
který je zajímavý a potenciálně užitečný hned z&nbsp;několika důvodů. Jedná se
o implementaci jazyka Scheme naprogramovanou v&nbsp;Javě a běžící nad
virtuálním strojem Javy (JVM). Ovšem současně se v&nbsp;žádném případě nejedná
o pouhý primitivní interpret, ale o překladač jazyka Scheme do bajtkódu JVM. <a
href="http://per.bothner.com/blog/2010/Kawa-in-shootout/">Z&nbsp;benchmarků</a>
je patrné, že výsledný kód vůbec není pomalý ale naopak dokáže více než zdárně
konkurovat dalším programovacím jazykům, které v&nbsp;současnosti nad JVM
existují.</p>

<img src="https://i.iinfo.cz/images/695/chicken-scheme-2.png" class="image-399602" alt="&#160;" width="256" height="256" />
<p><i>Obrázek 2: Logo projektu Kawa.</i></p>

<p>A konečně jsme se ve třech článcích zabývali projektem nazvaným
<i>Racket</i>, jehož původní jméno bylo <i>PLT Scheme</i>. Samotný programovací
jazyk Racketu sice vychází z&nbsp;klasického Scheme, ale je poměrně snadno
rozšiřitelný a modifikovatelný, takže vzniklo hned několik jeho variant. Kromě
klasického dynamicky typovaného jazyka Scheme je tak možné použít jazyk
s&nbsp;možností přesné deklarace datových typů, jazyk s&nbsp;infixovu notací
zápisu aritmetických výrazů, dokonce i implementaci Algolu 60 atd.</p>

<a href="https://www.root.cz/obrazek/399603/"><img src="https://i.iinfo.cz/images/695/chicken-scheme-3-prev.png" class="image-399603" alt="&#160;" width="267" height="270" /></a>
<p><i>Obrázek 3: Logo projektu Racket.</i></p>

<p><div class="rs-tip-major">Poznámka zcela na okraj: Algol 60 oslaví příští
rok kulatiny, takže se seznámíme i s&nbsp;tímto jazykem. Oproti až absurdně
rozsáhlému Algolu 68 je totiž Algol 60 i na dnešní poměry velmi elegantním
jazykem, takže není divu, že od něj jsou odvozeny prakticky všechny dnešní
mainstreamové jazyky (s&nbsp;výjimkou LISPovské větve a funkcionálních
jazyků).</div></p>

<p>Přímými konkurenty <i>Chicken Scheme</i> jsou však odlišné implementace,
s&nbsp;nimiž se ještě v&nbsp;tomto seriálu později podrobněji seznámíme:</p>

<ol>
<li><i>Gambit-C</i> s&nbsp;pravděpodobně nejlepším překladačem do C</li>
<li><i>Bigloo</i> s&nbsp;překladačem do C, bajtkódu JVM a bajtkódu .NETu</li>
<li><i>Scheme48</i> s&nbsp;překladačem do bajtkódu</li>
</ol>

<img src="https://i.iinfo.cz/images/695/chicken-scheme-4.png" class="image-399604" alt="&#160;" width="256" height="306" />
<p><i>Obrázek 4: Logo projektu Chicken Scheme.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Překlad a instalace projektu Chicken Scheme</h2>

<p>Balíčky s&nbsp;projektem <i>Chicken Scheme</i> jsou sice většinou součástí
standardních repositářů většiny rozšířených linuxových distribucí, ovšem mnohdy
se setkáme se staršími verzemi tohoto jazyka. V&nbsp;době psaní tohoto článku
je aktuální verze 5.1, ovšem například ve Fedoře 30 (což není tak stará
distribuce) najdeme pouze Chicken Scheme ve verzi 4.12.0, o čemž se ostatně
můžeme velmi snadno přesvědčit:</p>

<pre>
[schemer ~]$ <strong>cat /etc/redhat-release</strong>
Fedora release 30 (Thirty)
&nbsp;
[schemer ~]$ <strong>chicken</strong>
&nbsp;
(c) 2008-2017, The CHICKEN Team
(c) 2000-2007, Felix L. Winkelmann
Version <strong>4.12.0</strong>
linux-unix-gnu-x86-64 [ 64bit manyargs dload ptables ]
compiled 2019-01-31 on buildvm-14.phx2.fedoraproject.org
&nbsp;
Enter `chicken -help' for information on how to use the compiler,
or try `csc' for a more convenient interface.
&nbsp;
Run `csi' to start the interactive interpreter.
</pre>

<p><div class="rs-tip-major">Poznámka: jak je z&nbsp;předchozího zápisu patrné,
bude se většina příkazů spouštět pod uživatelem se jménem
<strong>schemer</strong>, který byl vytvořen jen pro účely testování různých
implementací programovacího jazyka Scheme. Na vašem počítači samozřejmě můžete
použít libovolného uživatele (snad kromě roota).</div></p>

<p>Aby bylo možné použít nejnovější stabilní verzi interpretru a překladače, je
vhodnější provést překlad a instalaci Chicken Scheme přímo z&nbsp;dostupných
zdrojových kódů. Potřebovat budeme standardní vývojové nástroje, zejména
překladač programovacího jazyka C (výchozí je <i>GCC</i>, teoreticky je však
možné využít i další překladače) a <i>GNU Makefile</i>. Nejprve je nutné
stáhnout tarball se zdrojovými kódy stabilní verze Chicken Scheme. V&nbsp;tomto
konkrétním příkladu se bude stahovat verze 5.1.0, ale pochopitelně můžete
stáhnout i verzi starší či naopak novější:</p>

<pre>
[schemer ~]$ <strong>wget https://code.call-cc.org/releases/5.1.0/chicken-5.1.0.tar.gz</strong>
&nbsp;
--2019-11-14 19:20:27--  https://code.call-cc.org/releases/5.1.0/chicken-5.1.0.tar.gz
Resolving code.call-cc.org (code.call-cc.org)... 78.47.93.131
Connecting to code.call-cc.org (code.call-cc.org)|78.47.93.131|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 4071169 (3,9M) [application/x-gzip]
Saving to: ‘chicken-5.1.0.tar.gz’
&nbsp;
100%[=====================================================================================================================&gt;] 4 071 169   1,73MB/s   in 2,2s   
</pre>

<p>Následně je nutné stažený tarball rozbalit, a to běžným postupem:</p>

<pre>
[schemer ~]$ <strong>tar xvfz chicken-5.1.0.tar.gz</strong>
</pre>

<p>Dále přejít do adresáře vytvořeného při rozbalování tarballu se zdrojovými
kódu:</p>

<pre>
[schemer ~]$ <strong>cd chicken-5.1.0</strong>
</pre>

<p>A provést vlastní překlad, který většinou trvá několik desítek sekund:</p>

<pre>
[schemer chicken-5.1.0]$ <strong>make PLATFORM=linux</strong>
</pre>

<p>Po překladu by se měly v&nbsp;aktuálním adresáři objevit minimálně tyto tři
spustitelné soubory:</p>

<ol>
<li><strong>chicken</strong> (základní tooling včetně interpretru)</li>
<li><strong>csi</strong> (interpret)</li>
<li><strong>csc</strong> (překladač)</li>
</ol>

<p>Pro jistotu otestujeme, zda je možné spustit alespoň interpret (což by mělo
být v&nbsp;každém případě možné):</p>

<pre>
[schemer chicken-5.1.0]$ <strong>./csi</strong>
&nbsp;
CHICKEN
(c) 2008-2019, The CHICKEN Team
(c) 2000-2007, Felix L. Winkelmann
Version 5.1.0 (rev 8e62f718)
linux-unix-gnu-x86-64 [ 64bit dload ptables ]
</pre>

<p><div class="rs-tip-major">Poznámka: může následovat ještě další krok, a to
konkrétně instalace do adresářové struktury v&nbsp;<strong>/usr/local</strong>.
Pro tento krok budete potřebovat příslušná práva. Alternativně je možné
instalaci provést do adresáře <strong>/opt/chicken</strong>, ovšem posléze je
nutné správným způsobem nastavit cestu do podadresáře
<strong>/opt/chicken/bin</strong> a přidat ji do proměnné prostředí
<strong>PATH</strong>.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Použití interpretru dodávaného současně s&nbsp;Chicken Scheme</h2>

<p>Interpret dodávaný společně s&nbsp;projektem Chicken Scheme
(resp.&nbsp;přesněji řečeno interpret, který jsme přeložili podle postupu <a
href="#k02">z&nbsp;předchozí kapitoly</a>) je kompatibilní s&nbsp;dalšími
dialekty tohoto programovacího jazyka, a to minimálně na úrovni R5RS. Nejprve
si vyzkoušíme naprogramovat a následně spustit funkci určenou pro výpočet
faktoriálu, a to v&nbsp;její rekurzivní variantě (bez tail callů). Tato funkce
bývá v&nbsp;oblasti LISPovských jazyků obdobou programu typu &bdquo;Hello
world&ldquo;, který se používá v&nbsp;jazycích odvozených od Algolu (tato
tradice začala už u céčka):</p>

<pre>
(define (<strong>println</strong> item)
     (display item)
     (newline))
&nbsp;
(define (<strong>factorial</strong> n)
    (if (= n 0) <i>; podmínka pro ukončení rekurzivního zanořování</i>
        1       <i>; faktoriál nuly je definitoricky roven jedné</i>
        (* n (factorial (- n 1)))))
&nbsp;
(println (factorial 10))
</pre>

<p>Celý skript můžeme předat do interpretru, který je představován spustitelným
souborem <strong>csi </strong> (<i>Chicken Scheme Interpret</i>):</p>

<pre>
[schemer ~]$ <strong>./csi factorial.scm</strong>
</pre>

<p>Interpret by měl vypsat vypočtenou hodnotu faktoriálu a následně zůstat
v&nbsp;interaktivní smyčce REPL:</p>

<pre>
[schemer ~]$ <strong>csi factorial.scm</strong>
&nbsp;
CHICKEN
(c) 2008-2017, The CHICKEN Team
(c) 2000-2007, Felix L. Winkelmann
Version 4.12.0
linux-unix-gnu-x86-64 [ 64bit manyargs dload ptables ]
compiled 2019-01-31 on buildvm-14.phx2.fedoraproject.org
&nbsp;
; loading factorial.scm ...
3628800
</pre>

<p>Interpret musíme ukončit, a to například zavoláním funkce s&nbsp;názvem
<strong>quit</strong>:</p>

<pre>
#;1&gt; <strong>(quit)</strong>
</pre>

<p>Pokud je vyžadováno, aby se interpret ukončil ihned poté, co je dokončen běh
vybraného skriptu, je nutné použít přepínač <i>-q</i>:</p>

<pre>
[schemer ~]$ <strong>./csi -q factorial.scm</strong>
</pre>

<p>S&nbsp;tímto výsledkem:</p>

<pre>
[schemer ~]$ <strong>csi -q factorial.scm</strong>
&nbsp;
3628800
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Překlad skriptu naprogramovaného ve Scheme do nativního kódu</h2>

<p>Existují dva hlavní důvody, proč by se vývojář vůbec měl zabývat projektem
<i>Chicken Scheme</i>. Prvním důvodem je existence poměrně rozsáhlého
ekosystému, který je okolo tohoto jazyka postaven (takzvané <i>Eggs</i>). A
druhým důvodem je fakt, že je projekt <i>Chicken Scheme</i> vybaven
překladačem, který dokáže transformovat skripty zapsané ve Scheme do nativního
spustitelného kódu nebo do knihovny určené pro statické či dynamické slinkování
s&nbsp;dalšími bloky nativního kódu. Ve výsledném kódu je kromě běžných runtime
funkcí dostupný i plnohodnotný správce paměti (<i>garbage collector</i>), který
je pro LISPovské jazyky prakticky nutností.</p>

<p>Samotný překlad je přitom proveden v&nbsp;několika krocích:</p>

<ol>
<li>Transpilace zdrojového kódu ze Scheme do jazyka C</li>
<li>Překlad transpilovaného kódu překladačem jazyka C (například GCC)</li>
<li>Slinkování do spustitelné podoby a/nebo knihovny</li>
</ol>

<p>Důležité a potenciálně užitečné přitom je, že je umožněn takzvaný
<i>cross</i> překlad pro jiné architektury, než s&nbsp;jakou právě vývojář
pracuje. Je tak například možné na platformě x86-64 provést překlad aplikace
pro procesory ARM, AArch64 atd.</p>

<p>Dnes si ovšem ukážeme &bdquo;pouhý&ldquo; překlad do nativního kódu pro
stejnou platformu a systém, na které je provozován vlastní Chicken Scheme.
Samotný překlad je z&nbsp;pohledu uživatele-programátora až triviálně
jednoduchý, protože postačuje použít nástroj <strong>csc</strong> neboli
<i>Chicken Scheme Compiler</i>, kterému se v&nbsp;tom nejjednodušším případě
předá jediný argument &ndash; jméno překládaného skriptu:</p>

<pre>
[schemer ~]$ <strong>csc factorial.scm</strong>
</pre>

<p>Po několika sekundách by se měl vytvořit spustitelný soubor, jehož jméno je
odvozeno od jména původního skriptu (tedy v&nbsp;našem případě
<strong>factorial</strong>). Jedná se o běžnou aplikaci, kterou lze přímo
spustit:</p>

<pre>
[schemer ~]$ <strong>./factorial</strong>
3628800
</pre>

<p>Zajímavé bude zjistit, jak je vlastně výsledný soubor velký a jaké má
závislosti:</p>

<pre>
[schemer ~]$ <strong>ls -l factorial</strong>
&nbsp;
-rwxrwxr-x. 1 schemer schemer 51424 Dec  7 20:01 factorial
</pre>

<pre>
[schemer ~]$ <strong>ldd factorial</strong>
&nbsp;
        linux-vdso.so.1 (0x00007fff789ed000)
        libchicken.so.8 =&gt; /lib64/libchicken.so.8 (0x00007f5c75db6000)
        libm.so.6 =&gt; /lib64/libm.so.6 (0x00007f5c75c70000)
        libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f5c75c6a000)
        libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f5c75aa4000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f5c7623e000)
</pre>

<p><div class="rs-tip-major">Poznámka: důležitá je především závislost na
dynamické knihovně <strong>libchicken.so.8</strong>, kterou je nutné
v&nbsp;případě potřeby distribuovat současně s&nbsp;aplikací.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Možné problémy při překladu</h2>

<p>Pokud jste nainstalovali Chicken Scheme ze standardního repositáře vaší
linuxové distribuce, může se stát, že se překlad skriptu pro výpočet faktoriálu
nezdaří a namísto vytvoření výsledného spustitelného souboru se pouze zobrazí
chybové hlášení:</p>

<pre>
[schemer ~]$ <strong>csc factorial.scm</strong>
&nbsp;
sh: gcc: command not found
&nbsp;
Error: shell command terminated with non-zero exit status 32512: 'gcc'
'factorial.c' -o 'factorial.o' -c  -fno-strict-aliasing -fwrapv
-DHAVE_CHICKEN_CONFIG_H -DC_ENABLE_PTABLES -O2 -g -pipe -Werror=format-security
-Wp&ndash; D_FORTIFY_SOURCE=2 -Wp&ndash; D_GLIBCXX_ASSERTIONS -fexceptions
-fstack-protector-strong -grecord-gcc-switches
-specs=/usr/lib/rpm/redhat/redhat-hardened-cc1
-specs=/usr/lib/rpm/redhat/redhat-annobin-cc1 -m64 -mtune=generic
-fasynchronous-unwind-tables -fstack-clash-protection -fcf-protection -Wformat
-Os -fomit-frame-pointer -I/usr/include/chicken
</pre>

<p>Napravení tohoto problému je snadné &ndash; postačuje nainstalovat
<strong>gcc</strong> a vývojářskou verzi standardní céčkové knihovny.</p>

<p><div class="rs-tip-major">Poznámka: ve chvíli, kdy byl Chicken Scheme
přeložen ze zdrojových kódů podle postupu <a href="#k02">ze druhé kapitoly</a>,
bude překlad skriptu pro výpočet faktoriálu proveden v&nbsp;pořádku, protože
již máte k&nbsp;dispozici všechny potřebné nástroje.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Příprava jednoduchého benchmarku</h2>

<p>Vzhledem k&nbsp;tomu, že je projekt Chicken Scheme vybaven plnohodnotným
překladačem, bude užitečné zjistit, jak kvalitní kód tento překladač vlastně
generuje. Připravíme si tedy jednoduchý benchmark, s&nbsp;nímž jsme se vlastně
již seznámili v&nbsp;předchozích článcích. Jedná se o program určený pro
iterativní výpočet konstanty &pi; s&nbsp;využitím (velmi pomalu konvergujícího)
<i>Wallisova součinu</i> (<i>Wallis product</i>, který je popsán například na
stránce <a
href="https://en.wikipedia.org/wiki/Wallis_product">https://en.wikipedia.org/wiki/Wallis_product</a>).
Přepis tohoto algoritmu do Scheme může vypadat následovně:</p>

<pre>
(define (<strong>compute-pi</strong> n)
  (let ((pi 4.0))
    (do ((i 3 (+ i 2)))
      ((&gt; i (+ n 2)))
      (set! pi (* pi (/ (- i 1) i) (/ (+ i 1) i))))
    pi))
&nbsp;
(do ((n 1 (* n 2)))
  ((&gt; n 10000000))
  (display n)
  (display " ")
  (display (compute-pi n))
  (newline))
</pre>

<p><div class="rs-tip-major">Poznámka: využíváme zde spíše imperativního
přístupu a nikoli přístupu funkcionálního.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Porovnání rychlosti interpretrů GNU Guile a Chicken Scheme</h2>

<p>S&nbsp;projektem nazvaným <i>GNU Guile</i> jsme se již <a
href="https://www.root.cz/clanky/gnu-guile-interpret-scheme-vestavitelny-do-nativnich-aplikaci/">v&nbsp;tomto
seriálu seznámili</a>. Jedná se o interpret jazyka Scheme doplněný o JIT
překladač, takže můžeme předpokládat, že by výpočetní výkon takto doplněného
interpretru mohl být vyšší, než je tomu v&nbsp;případě jednoduchého interpretru
dodávaného s&nbsp;projektem <i>Chicken Scheme</i>. Ostatně se o tomto
předpokladu můžeme snadno přesvědčit, protože <a href="#k06">výše popsaný</a>
výpočet konstanty &pi; je napsán takovým způsobem, že je kompatibilní jak
s&nbsp;GNU Guile, tak i s&nbsp;Chicken Scheme.</p>

<p>Nejprve tedy výpočet spustíme v&nbsp;GNU Guile a budeme sledovat jak
strojový čas strávený výpočtem, tak i celkový čas viditelný vnějším
pozorovatelem (což je mnohdy důležitější ukazatel):</p>

<pre>
[schemer ~]$ <strong>time guile pi1.scm</strong>
</pre>

<p>Výsledky, na jejichž konci jsou zobrazeny i časové údaje:</p>

<pre>
1 3.5555555555555554
2 3.5555555555555554
4 3.4133333333333336
8 3.302393550012597
16 3.230036466411716
32 3.1881271694471383
64 3.1654820600347926
128 3.1536988490957967
256 3.147686899556418
512 3.1446501625172
1024 3.143124017028185
2048 3.142358989121772
4096 3.141975985005608
8192 3.1417843602347433
16384 3.1416885171495856
32768 3.1416405879293077
65536 3.1416166213993866
131072 3.1416046376544267
262144 3.1415986456618494
524288 3.141595649635512
1048576 3.141594151614876
2097152 3.141593402602468
4194304 3.1415930280955355
8388608 3.1415928408418403
&nbsp;
real    0m4.858s
user    0m5.212s
sys     0m0.058s
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že čas strávený výpočtem
je z&nbsp;pohledu uživatele cca 4,8 sekundy (<strong>real</strong>=čas, který
je možné změřit stopkami vně počítače), zatímco z&nbsp;pohledu mikroprocesoru
je čas delší &ndash; celých 5,70 sekund
(<strong>user</strong>+<strong>sys</strong>). To znamená, že některé výpočty
musely být provedeny ve více vláknech.</div></p>

<p>Nyní si vyzkoušejme, jestli bude výpočet &pi; podle stejného skriptu
s&nbsp;využitím <i>interpretru</i> nástroje Chicken Scheme rychlejší nebo
pomalejší. Použijeme přepínače <strong>-b</strong> a <strong>-q</strong>, které
zajistí, že se interpret po dokončení výpočtů ihned ukončí a že se na začátku
nebudou zobrazovat úvodní informace o projektu Chicken Scheme (což sice nevede
k&nbsp;žádnému podstatnému urychlení, ale ke zpřesnění výsledných časů):</p>

<pre>
[schemer ~]$ <strong>time csi -b -q pi1.scm</strong>
</pre>

<p>Samotné výsledky výpočtu by měly být přibližně podobné, minimálně na prvních
sedmi až osmi desetinných místech:</p>

<pre>
1 3.55555555555556
2 3.55555555555556
4 3.41333333333333
8 3.3023935500126
16 3.23003646641172
32 3.18812716944714
64 3.16548206003479
128 3.1536988490958
256 3.14768689955642
512 3.1446501625172
1024 3.14312401702818
2048 3.14235898912177
4096 3.14197598500561
8192 3.14178436023474
16384 3.14168851714959
32768 3.14164058792931
65536 3.14161662139939
131072 3.14160463765443
262144 3.14159864566185
524288 3.14159564963551
1048576 3.14159415161488
2097152 3.14159340260247
4194304 3.14159302809554
8388608 3.14159284084184
&nbsp;
real    0m8.137s
user    0m7.739s
sys     0m0.318s
</pre>

<p>Čas celého výpočtu je v&nbsp;tomto případě výrazně delší, než tomu je
v&nbsp;porovnání s&nbsp;projektem GNU Guile. Dále můžeme při porovnání všech
tří časů předpokládat, že výpočet běžel pouze v&nbsp;jediném vláknu (což je
ostatně pravda).</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Rychlost benchmarku přeloženého do nativního kódu</h2>

<p>Při porovnání předchozích časových údajů se může čtenář zajisté ptát, kde
tedy spočívají přednosti <i>Chicken Scheme</i> oproti <i>GNU Guile</i>, když
interpret je (alespoň v&nbsp;rámci jednoduchého a jednoúčelově zaměřeného
benchmarku) pomalejší. Odpověď je zřejmá &ndash; tou je překladač. Budeme tedy
muset benchmark nejdříve přeložit a otestovat, jak dlouho bude trvat výpočet
provedený (přeloženým) nativním kódem.</p>

<p>Samotný překlad je jednoduchý a prakticky okamžitý:</p>

<pre>
[schemer ~]$ <strong>csc pi1.scm</strong>
</pre>

<p>Dále již budeme používat spustitelný soubor nazvaný &bdquo;pi1&ldquo;:</p>

<pre>
[schemer ~]$ <strong>time ./pi1</strong>
</pre>

<p>Se stejnými výsledky výpočtu, ovšem zcela odlišnými časy:</p>

<pre>
1 3.55555555555556
2 3.55555555555556
4 3.41333333333333
8 3.3023935500126
16 3.23003646641172
32 3.18812716944714
64 3.16548206003479
128 3.1536988490958
256 3.14768689955642
512 3.1446501625172
1024 3.14312401702818
2048 3.14235898912177
4096 3.14197598500561
8192 3.14178436023474
16384 3.14168851714959
32768 3.14164058792931
65536 3.14161662139939
131072 3.14160463765443
262144 3.14159864566185
524288 3.14159564963551
1048576 3.14159415161488
2097152 3.14159340260247
4194304 3.14159302809554
8388608 3.14159284084184
&nbsp;
real    0m0.885s
user    0m0.869s
sys     0m0.011s
</pre>

<p>Nyní tedy celý výpočet trval pouze přibližně 0,89 sekundy, což je oproti
interpretaci (více než 8 sekund) prakticky řádový rozdíl!</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Porovnání kvality překladače Chicken Scheme s&nbsp;alternativními implementacemi vytvořenými v&nbsp;C a Go</h2>

<p>Překladač <i>Chicken Scheme</i> tedy skutečně dokáže odvést poměrně velmi
dobrou práci, minimálně v&nbsp;porovnání s&nbsp;klasickými interpretry
popř.&nbsp;interpretry dovybavenými JIT překladačem. Ovšem jak dobrý či naopak
špatný je tento překladač v&nbsp;porovnání s&nbsp;podobně naprogramovaným
algoritmem v&nbsp;čistém céčku? Na tomto místě můžeme předpokládat, že
<i>Chicken Scheme</i> bude produkovat horší kód (už jen kvůli neexistenci
explicitního typového systému, resp.&nbsp;prozatím jsme tento systém
nevyužili), ovšem musíme se o tomto předpokladu přesvědčit.</p>

<p>V&nbsp;céčku může obdobný výpočet konstanty &pi; vypadat následovně (jedná
se o prakticky doslovný přepis předchozího skriptu):</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
double <strong>compute_pi</strong>(int n) {
        double pi = 4.0;
        long i;
        for (i = 3; i &lt;= n + 2; i += 2) {
                pi = pi * (i-1)/i * (i+1)/i;
        }
        return pi;
}
&nbsp;
int <strong>main</strong>(void) {
        long n;
        for (n=1; n &lt;= 10000000; n *= 2) {
                printf("%ld %16.14f\n", n, compute_pi(n));
        }
        return 0;

}
</pre>

<p>Výsledky pro neoptimalizovaný kód:</p>

<pre>
[schemer ~]$ <strong>gcc -Wall -ansi pi.c</strong>
&nbsp;
[schemer ~]$ <strong>time ./a.out</strong>
&nbsp;
1 3.55555555555556
2 3.55555555555556
4 3.41333333333333
8 3.30239355001260
16 3.23003646641172
32 3.18812716944714
64 3.16548206003480
128 3.15369884909580
256 3.14768689955642
512 3.14465016251721
1024 3.14312401702820
2048 3.14235898912179
4096 3.14197598500563
8192 3.14178436023478
16384 3.14168851714965
32768 3.14164058792947
65536 3.14161662139959
131072 3.14160463765471
262144 3.14159864566229
524288 3.14159564963532
1048576 3.14159415161453
2097152 3.14159340260678
4194304 3.14159302810327
8388608 3.14159284083911
&nbsp;
real    0m0.157s
user    0m0.154s
sys     0m0.002s
</pre>

<p>Zde je urychlení cca 5,5násobné oproti výsledku překladače <i>Chicken
Scheme</i>!</p>

<p>Překlad se základními optimalizacemi:</p>

<pre>
[schemer ~]$ <strong>gcc -Wall -ansi -O3 pi1.c </strong>
&nbsp;
[schemer ~]$ <strong>time ./a.out </strong>
&nbsp;
1 3.55555555555556
2 3.55555555555556
4 3.41333333333333
8 3.30239355001260
16 3.23003646641172
32 3.18812716944714
64 3.16548206003480
128 3.15369884909580
256 3.14768689955642
512 3.14465016251721
1024 3.14312401702820
2048 3.14235898912179
4096 3.14197598500563
8192 3.14178436023478
16384 3.14168851714965
32768 3.14164058792947
65536 3.14161662139959
131072 3.14160463765471
262144 3.14159864566229
524288 3.14159564963532
1048576 3.14159415161453
2097152 3.14159340260678
4194304 3.14159302810327
8388608 3.14159284083911
&nbsp;
real    0m0.128s
user    0m0.126s
sys     0m0.001s
</pre>

<p>Je patrné, že jsme dosáhli ještě dalšího urychlení, i když již nikoli
několikanásobného, jako tomu bylo při přechodu na C.</p>

<p>Pro zajímavost si ještě vyzkoušejme podobný algoritmus napsaný <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">v&nbsp;programovacím
jazyku Go</a>. Nejdříve použijeme naivní přístup pracující v&nbsp;jednom vláknu
(tj.&nbsp;stejný přístup, jako ve Scheme a jazyku C):</p>

<pre>
package <strong>main</strong>
&nbsp; 
import "fmt"
&nbsp;
func <strong>computePi</strong>(n int) float64 {
        pi := 4.0
        var i int
        for i = 3; i &lt;= n+2; i += 2 {
                fi := float64(i)
                pi = pi * (fi - 1) / fi * (fi + 1) / fi
        }
        return pi
}
&nbsp;
func <strong>main</strong>() {
        var n int
        for n = 1; n &lt;= 10000000; n *= 2 {
                fmt.Printf("%d %16.14f\n", n, computePi(n))
        }
}
</pre>

<p>S&nbsp;výsledky benchmarku:</p>

<pre>
[schemer ~]$ <strong>go build pi1.go</strong>
&nbsp;
[schemer ~]$ <strong>time ./pi1</strong>
&nbsp;
1 3.55555555555556
2 3.55555555555556
4 3.41333333333333
8 3.30239355001260
16 3.23003646641172
32 3.18812716944714
64 3.16548206003480
128 3.15369884909580
256 3.14768689955642
512 3.14465016251721
1024 3.14312401702820
2048 3.14235898912179
4096 3.14197598500563
8192 3.14178436023478
16384 3.14168851714965
32768 3.14164058792947
65536 3.14161662139959
131072 3.14160463765471
262144 3.14159864566229
524288 3.14159564963532
1048576 3.14159415161453
2097152 3.14159340260678
4194304 3.14159302810327
8388608 3.14159284083911
&nbsp;
real    0m0.143s
user    0m0.136s
sys     0m0.005s
</pre>

<p>Výkonnější by mohl být algoritmus převedený do takové podoby, kdy se
konstanta &pi; získaná ze zadaného počtu prvků nějaké řady vypočítá
v&nbsp;samostatné <i>gorutině</i>:</p>

<pre>
package <strong>main</strong>
&nbsp;
import "fmt"
&nbsp;
func <strong>computePi</strong>(n int, results chan&lt;- float64) {
        pi := 4.0
        var i int
        for i = 3; i &lt;= n+2; i += 2 {
                fi := float64(i)
                pi = pi * (fi - 1) / fi * (fi + 1) / fi
        }
        results &lt;- pi
}
&nbsp;
func <strong>main</strong>() {
        var results [30]chan float64
        <i>// inicializace kanálů</i>
        for i := range results {
                results[i] = make(chan float64)
        }
&nbsp;
        <i>// výpočet v gorutinách</i>
        for i, n := 0, 1; n &lt;= 10000000; i, n = i+1, n*2 {
                go computePi(n, results[i])
        }
&nbsp;
        <i>// čekání na dokončení gorutin</i>
        for i, n := 0, 1; n &lt;= 10000000; i, n = i+1, n*2 {
                fmt.Printf("%d %16.14f\n", n, &lt;-results[i])
        }
}
</pre>

<p>Nyní budou výsledky odlišné:</p>

<pre>
[schemer ~]$ <strong>go build pi2.go</strong>
&nbsp;
[schemer ~]$ <strong>time ./pi2</strong>
&nbsp;
1 3.55555555555556
2 3.55555555555556
4 3.41333333333333
8 3.30239355001260
16 3.23003646641172
32 3.18812716944714
64 3.16548206003480
128 3.15369884909580
256 3.14768689955642
512 3.14465016251721
1024 3.14312401702820
2048 3.14235898912179
4096 3.14197598500563
8192 3.14178436023478
16384 3.14168851714965
32768 3.14164058792947
65536 3.14161662139959
131072 3.14160463765471
262144 3.14159864566229
524288 3.14159564963532
1048576 3.14159415161453
2097152 3.14159340260678
4194304 3.14159302810327
8388608 3.14159284083911
&nbsp;
real    0m0.078s
user    0m0.138s
sys     0m0.008s
</pre>

<p>Tento výpočet z&nbsp;hlediska mikroprocesoru sice trval prakticky stejně
dlouho, jako výpočet předchozí, ovšem z&nbsp;pohledu uživatele byl proveden
v&nbsp;prakticky polovičním čase. To přesně odpovídá použití gorutin, kdy je
celkový čas zdola omezen poslední gorutinou, která vlastně provádí více
výpočtů, než všechny ostatní gorutiny dohromady.</p>

<p><div class="rs-tip-major">Poznámka: podobných rozdílů lze dosáhnout i při
řádovém zvýšení počtu iterací a tím pádem i ve chvíli, kdy se časy výpočtu měří
spíše v&nbsp;jednotkách a desítkách sekund. Samotný čas spuštění interpretru
a/nebo runtime prostředí v&nbsp;případě Go je prakticky neměřitelný
(s&nbsp;využitím nástroje <strong>time</strong>).</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Typové informace a jejich vliv na výsledek benchmarku</h2>

<p>Dalšího vylepšení času výpočtu je možné dosáhnout přidáním typových
informací do zdrojového kódu vytvořeného v&nbsp;jazyku Scheme. Chicken Scheme
umožňuje specifikovat typ globálních symbolů tímto zápisem:</p>

<pre>
(: symbol typ)
</pre>

<p>V&nbsp;případě funkcí pak zápisem:</p>

<pre>
(: symbol (typy na vstupu -&gt; typ návratové hodnoty)
</pre>

<p>Dále je možné explicitně zadat typ hodnoty přiřazené k&nbsp;lokálnímu
symbolu, a to s&nbsp;využitím speciální formy <strong>the</strong>, které se
předá datový typ a hodnota či výraz. Například:</p>

<pre>
(let ((pi <strong>(the float 4.0)</strong>))
    ...
    ...
    ...)
</pre>

<p>Předchozí výpočet tedy můžeme poněkud nešikovně přepsat takto:</p>

<pre>
<strong>(: compute-pi (fixnum -&gt; float))</strong>
(define (compute-pi n)
  (let ((pi <strong>(the float 4.0)</strong>))
    (do ((i <strong>(the fixnum 3)</strong> (+ i 2)))
      ((&gt; i (+ n 2)))
      (set! pi (* pi (/ (- i 1) i) (/ (+ i 1) i))))
    pi))
&nbsp;
(do ((n 1 (* n 2)))
  ((&gt; n 10000000))
  (display n)
  (display " ")
  (display (compute-pi n))
  (newline))
</pre>

<p><div class="rs-tip-major">Poznámka: typ <strong>float</strong> odpovídá
numerické hodnotě s&nbsp;plovoucí řádovou čárkou, zatímco
<strong>fixnum</strong> celým číslům.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Výsledky všech benchmarků v&nbsp;grafické podobě</h2>

<p>Výsledky předchozích benchmarků si můžeme zobrazit i v&nbsp;grafické
podobě:</p>

<a href="https://www.root.cz/obrazek/399605/"><img src="https://i.iinfo.cz/images/695/chicken-scheme-5-prev.png" class="image-399605" alt="&#160;" width="370" height="221" /></a>
<p><i>Obrázek 5: Výsledky benchmarků v&nbsp;grafické podobě.</i></p>

<p><div class="rs-tip-major">Poznámka: na tomto místě je dobré si uvědomit, že
se jedná o mikrobenchmark, který pokrývá jen malou část možností jazyka Scheme.
Existují i další benchmarky, které porovnávají více implementací Scheme
vybavených překladači:</div></p>

<a href="https://www.root.cz/obrazek/399606/"><img src="https://i.iinfo.cz/images/695/chicken-scheme-6-prev.png" class="image-399606" alt="&#160;" width="139" height="270" /></a></p>
<p><i>Obrázek 6: Porovnání rychlostí výpočtu různých implementací jazyka
Scheme..</i></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Další vlastnosti programovacího jazyka implementovaného v&nbsp;rámci Chicken Scheme</h2>

<p>Většina základních vlastností programovacího jazyka implementovaného
v&nbsp;rámci <i>Chicken Scheme</i> je odvozena z&nbsp;R5RS a částečně i
z&nbsp;novějších vydání RnRS. Týká se to především samotné sémantiky
programovacího jazyka, ovšem s&nbsp;tím, že některé funkce, které jsou
v&nbsp;ostatních implementacích Scheme běžně dostupné, je v&nbsp;Chicken Scheme
zapotřebí explicitně importovat. Týká se to například i tak základních funkcí,
jakými jsou funkce vyššího řádu <strong>map</strong> či
<strong>filter</strong>. Ty jsou dostupné v&nbsp;balíčku nazvaném
<strong>srfi-1</strong> a před jejich použitím je nutné použít volání:</p>

<pre>
(use srfi-1)
</pre>

<p>popř.:</p>

<pre>
(import srfi-1)
</pre>

<p>Podobně jako je tomu i v&nbsp;dalších implementacích Scheme je i
v&nbsp;Chicken Scheme základním strukturovaným datovým typem seznam
(<i>list</i>) doplněný o základní funkce pro práci s&nbsp;ním. Z&nbsp;LISPu
byly převzaty funkce <strong>car</strong> a <strong>cdr</strong> i jejich další
varianty (<strong>cadr</strong>, <strong>cdar</strong> atd.):</p>

<pre>
<i>; helper function</i>
(define (println item)
     (display item)
     (newline))
&nbsp;
(println '(1 2 3 4))
&nbsp;
(println (list 1 2 3 4))
&nbsp;
<i>; create list and assign it to symbol</i>
<i>; (=variable)</i>
(define a '(1 2 3 4))
&nbsp;
<i>; get the first item</i>
(println (car a))
&nbsp;
<i>; get the rest of a list</i>
(println (cdr a))
&nbsp;
<i>; combination of car+cdr</i>
(println (cadr a))
&nbsp;
<i>; combination of cdr+cdr</i>
(println (cddr a))
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
(1 2 3 4)
(1 2 3 4)
1
(2 3 4)
2
(3 4)
</pre>

<p>Interně jsou seznamy reprezentovány prvky, přičemž každý prvek je tvořen
takzvanou tečka-dvojicí, kterou si můžeme představit jako strukturu obsahující
dvě hodnoty &ndash; buď ukazatel na další tečka-dvojici nebo hodnotu (včetně
prázdné hodnoty):</p>

<pre>
<i>; helper function</i>
(define (println item)
     (display item)
     (newline))
&nbsp;
<i>; simple dot-pair</i>
(println '(1 . 2))
&nbsp;
(println '(1 . ((2 . 3) . 4)))
&nbsp;
(println '((1 . 2) . (3 . 4)))
&nbsp;
<i>; this is proper list in LISP, but not in Scheme!</i>
(println '(1 . (2 . (3 . nil))))
&nbsp;
<i>; this is proper list</i>
(println '(1 . (2 . (3 . ()))))
</pre>

<p>Výsledky získané spuštěním tohoto skriptu:</p>

<pre>
(1 . 2)
(1 (2 . 3) . 4)
((1 . 2) 3 . 4)
(1 2 3 . nil)
(1 2 3)
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se chování Scheme (zde
konkrétně Chicken Scheme) v&nbsp;některých ohledech odlišuje od tradičních
implementací programovacího jazyka LISP.</div></p>

<p>Seznamy je možné konstruovat i s&nbsp;využitím funkce
<strong>cons</strong>:</p>

<pre>
(define (print item)
     (display item)
     (newline))
&nbsp;
(print (cons 1 2))
&nbsp;
(print (cons 1 (cons 2 3)))
&nbsp;
(print '((1 . 2) . (3 . 4)))
&nbsp;
<i>; this is proper list</i>
(print (cons 1 (cons 2 (cons 3 '()))))
&nbsp;
(define nil '())
&nbsp;
<i>; this is proper list</i>
(print (cons 1 (cons 2 (cons 3 nil))))
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
(1 . 2)
(1 2 . 3)
((1 . 2) 3 . 4)
(1 2 3)
(1 2 3)
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Funkce a speciální formy</h2>

<p>Podobně jako u každého dialektu programovacího jazyka LISP, i v&nbsp;případě
<i>Scheme</i> se program skládá především z&nbsp;funkcí. Ty mohou být anonymní
(nepojmenované) či naopak pojmenované. Nejprve se zabývejme pojmenovanými
funkcemi, protože ty se chovají prakticky stejně, jako běžné funkce
v&nbsp;jiných programovacích jazycích. Pojmenované funkce se definují pomocí
speciální formy <strong>define</strong>, za níž v&nbsp;závorkách následuje
jméno funkce. Každá funkce může mít libovolný počet parametrů, jejichž jména se
uvádí v&nbsp;seznamu ihned za pojmenováním funkce. Poslední částí formy
<strong>define</strong> je v&nbsp;tomto případě tělo funkce, přičemž po
zavolání funkce se vyhodnocená forma vrátí jako její výsledek (nikde se tedy
nezapisuje slovo &bdquo;return&ldquo; ani nic s&nbsp;podobným významem):</p>

<pre>
<i>; one-liner function</i>
(define (<strong>add</strong> x y) (+ x y))
&nbsp;
<i>; function written on more lines</i>
(define (<strong>mul</strong> x y)
  (* x y))
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti je výše uvedená definice
pouze syntaktickým cukrem nahrazujícím definici proměnné, jejíž hodnotou je
anonymní funkce, která je zapisovaná pomocí speciální formy
<strong>lambda</strong>. Bez použití syntaktického cukru by definice nové
funkce vypadala takto:</div></p>

<pre>
<i>; function written on more lines using lambda</i>
(define <strong>div</strong> (lambda (x y)
  (* x y)))
</pre>

<p>Zavolání funkce je jednoduché &ndash; používá se stále ten samý formát
seznamu, na jehož prvním místě je jméno funkce a za ním následují
parametry:</p>

<pre>
(print (add 1 2))
(print (mul 6 7))
(print (div 10 3))
</pre>

<p>Kromě pojmenovaných funkcí, které jsme si již představili v&nbsp;předchozím
textu, je možné ve <i>Scheme</i> použít i funkce anonymní, tj.&nbsp;funkce,
které nejsou navázány na žádné jméno. Pro tento účel se používá přímo lambda
výraz (bez <strong>define</strong>), podobně jako v&nbsp;každém ortodoxním
Lispu (snad kromě <i>PicoLispu</i>):</p>

<pre>
<i>; anonymous function is a value</i>
(lambda (x y) (+ x y))
&nbsp;
<i>; call anonymous function</i>
(print (lambda (x y) (+ x y)))
</pre>

<p>Další důležitou vlastností jazyka implementovaného v&nbsp;<i>Chicken
Scheme</i>, s&nbsp;níž se dnes (znovu) seznámíme, je použití takzvaných
<i>speciálních forem</i>. Ze syntaktického hlediska jsou speciální formy
zapisovány naprosto stejným způsobem jako běžné funkce, ovšem existuje zde
jeden významný rozdíl &ndash; zatímco u funkcí jsou všechny jejich parametry
nejdříve vyhodnoceny, u speciálních forem k&nbsp;tomuto vyhodnocení obecně
nedochází, resp.&nbsp;jsou vyhodnoceny pouze některé parametry (které
konkrétně, to závisí na tom, o jakou speciální formu se jedná).
S&nbsp;některými speciálními formami jsme se již setkali, především
s&nbsp;formou <strong>define</strong> či <strong>let</strong>, ovšem existují i
formy další &ndash; <strong>cond</strong>, <strong>if</strong>,
<strong>and</strong>, <strong>lambda</strong>, <strong>quote</strong>,
<strong>do</strong> atd.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Koncová rekurze</h2>

<p>V&nbsp;naprosté většině algoritmů se objevují bloky kódu, které se mají
iterativně opakovat. Při programování s&nbsp;využitím funkcionálního
paradigmatu se iterace vyjadřuje formou rekurze. Ta je samozřejmě ve
<i>Scheme</i> podporována (mezi jediné známější jazyky, které rekurzi
nepodporovaly, patřil původní <i>FORTRAN</i> a <i>Basic</i>), ovšem specifikace
jazyka <i>Scheme</i> jde ještě dále, protože určuje, ve kterých případech je
skutečná rekurze (při níž se parametry a návratové adresy musí ukládat na
zásobník) nahrazena takzvanou <i>koncovou rekurzí</i>, což zjednodušeně řečeno
znamená, že se namísto skutečného rekurzivního volání funkce interně provede
obyčejný skok (koncový skok či koncové volání) bez nutnosti alokace místa na
zásobníku pro parametry volané funkce a návratové adresy.</p>

<p>Koncová rekurze představuje při správném použití velmi silnou programovací
techniku, protože umožňuje zapisovat mnoho algoritmů v&nbsp;mnohdy elegantní
rekurzivní formě, ovšem skutečné zpracování takto zapsaných algoritmů je stejně
efektivní jako provádění programové smyčky (každou koncovou rekurzi lze
nahradit smyčkou a naopak).</p>

<p>Klasickým příkladem rozdílu mezi normální (plnou, skutečnou) rekurzí a
koncovou rekurzí je výpočet faktoriálu. Ten můžeme zapsat mnoha způsoby,
například (jak je to v&nbsp;matematice obvyklé), rekurzivně:</p>

<pre>
(define (factorial n)
    (if (= n 0) <i>; podmínka pro ukončení rekurzivního zanořování</i>
        1       <i>; faktoriál nuly je definitoricky roven jedné</i>
        (* n (factorial (- n 1)))))
</pre>

<p>Z&nbsp;teoretického hlediska není na výše uvedené funkci nic nekorektního,
ovšem při jejím praktickém používání brzy narazíme na limit způsobený omezenou
velikostí zásobníku.</p>

<p>Výše uvedený rekurzivní výpočet lze relativně malou úpravou převést na
výpočet který (alespoň v&nbsp;programovacím jazyce <i>Scheme</i>) vede na
koncové volání, což mj.&nbsp;znamená, že paměťové (prostorové) nároky tohoto
programu jsou konstantní:</p>

<pre>
<i>; výpočet faktoriálu využívající koncového volání</i>
(define (factorial n)
    (let fact-iter (          <i>; pomocná vnitřní funkce</i>
                  (n n)       <i>; počitadlo iterací</i>
                  (result 1)) <i>; průběžný výsledek</i>
        (if (= n 0)           <i>; po dosažení koncového stavu</i>
            result            <i>; se vrátí průběžný výsledek</i>
            (fact-iter (- n 1) (* n result)) <i>; koncové volání</i>
        )))
</pre>

<p><div class="rs-tip-major">Poznámka: i překlad do nativního kódu by měl být
v&nbsp;tomto případě lepší, než u běžné rekurzivní varianty.</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Lokální rozsah proměnných</h2>

<p>Jazyk Scheme je, na rozdíl od původních LISPů, založen na lokálním rozsahu
proměnných (<i>local scope</i>). Můžeme si to ukázat na následujícím
demonstračním příkladu, v&nbsp;němž je uvnitř funkce <strong>add</strong>
použit lokální rozsah, v&nbsp;rámci něhož je vyhodnocována proměnná
<strong>x</strong>:</p>

<pre>
(define x 1)
(define y 2)
&nbsp;
(define (add x y)
    ; rozsah (scope) je lokální!
    (set! x (+ x y))
    x)
&nbsp;
(print (add x y))
(print (add x y))
&nbsp;
(set! x 10)
(print (add x y))
(print (add x y))
</pre>

<p>Po spuštění tohoto příkladu se vypíše:</p>

<pre>
3
3
12
12
</pre>

<p><div class="rs-tip-major">Poznámka: ve funkci <strong>add</strong> se tedy
neměnila globální proměnná <strong>x</strong>.</div></p>

<p>Příklad s&nbsp;globálními a lokálními proměnnými:</p>

<pre>
(define x 1)
(define y 2)
&nbsp;
(define (add x y)
    (+ x y))
&nbsp;
(print (add x y))
&nbsp;
(print
    (let ((x 10)
          (y 20))
          (add x y)))
&nbsp;
&nbsp;
(set! x 10)
(print (add x y))
&nbsp;
(print
    (let ((x 10)
          (y 20))
          (add x y)))
&nbsp;
(print
    (let ((x 100))
          (add x y)))
</pre>

<p>Po spuštění tohoto příkladu se vypíše:</p>

<pre>
3
30
12
30
102
</pre>

<p><div class="rs-tip-major">Poznámka: <i>lexical scope</i> má ovšem
dalekosáhlejší důsledky, které mj.&nbsp;ovlivňují činnost správce paměti atd.
Jde o to, že pokud je nějaká proměnná (která je definovaná vně funkce) na
funkci <i>navázána</i> (prakticky: je ve funkci použita), nemůže tato proměnná
zaniknout ani při opuštění daného bloku, protože společně s&nbsp;funkcí tvoří
takzvaný <i>uzávěr (closure</i>). S&nbsp;uzávěry se v&nbsp;LISPovské rodině
jazyků setkáme velmi často a dnes je nalezneme i v&nbsp;některých dalších
programovacích jazycích (zdaleka ne ve všech):</div></p>

<pre>
(define (larger-than limit)
    (lambda (value) (&gt; value limit)))
&nbsp;
(print ((larger-than 5) 0))
(print ((larger-than 5) 10))
&nbsp;
(print (filter (larger-than 5) '(1 2 3 4 5 6 7 8 9 10)))
</pre>

<p>S&nbsp;těmito výsledky:</p>

<pre>
#f
#t
(6 7 8 9 10)
(6 7 8 9 10)
</pre>

<p>Další, nepatrně složitější implementace uzávěrů:</p>

<pre>
(use srfi-1)
&nbsp;
(define (print item)
     (display item)
     (newline))
&nbsp;
(define counter
    (let ((i -1))
         (lambda ()
             (set! i (+ i 1))
             i)))
&nbsp;
(print (counter))
(print (counter))
(print (counter))
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
0
1
2
</pre>

<p><div class="rs-tip-major">Poznámka: zde jsme vytvořili funkci
<strong>counter</strong>, kterou lze v&nbsp;určitém ohledu považovat za
<i>objekt</i>, protože má vlastní <i>stav</i> a <i>zapouzdřuje</i> hodnotu
čítače představovaného proměnnou <strong>i</strong>.</div></p>

<pre>
(use srfi-1)
&nbsp;
(define (print item)
     (display item)
     (newline))
&nbsp;
(define (get-counter)
    (let ((i -1))
         (lambda ()
             (set! i (+ i 1))
             i)))
&nbsp;
(define counter1 (get-counter))
(define counter2 (get-counter))
&nbsp;
(print (counter1))
(print (counter1))
(print (counter1))
&nbsp;
(print (counter2))
(print (counter2))
(print (counter2))
&nbsp;
(print (counter1))
(print (counter1))
(print (counter1))
</pre>

<p>Výsledky činnosti dvou čítačů:</p>

<pre>
0
1
2
&nbsp;
0
1
2
&nbsp;
3
4
5
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. FFI &ndash; rozhraní mezi Chicken Scheme a nativními jazyky (C apod.)</h2>

<p>V&nbsp;ekosystému jazyka Chicken Scheme nalezneme hned několik implementací
FFI neboli <a
href="https://en.wikipedia.org/wiki/Foreign_function_interface">Foreign
Function Interface</a>. Jedno z&nbsp;těchto rozšíření se jmenuje přiléhavě
&ndash; <i>The "Easy" Foreign Function Interface</i>. Použití FFI, tedy
zavolání nativní céčkové funkce, je s&nbsp;využitím tohoto rozšíření mnohdy
velmi triviální. Pokud například potřebujeme zavolat standardní funkci
<strong>getchar</strong>, jejíž deklaraci najdeme v&nbsp;hlavičkovém souboru
<strong>stdio.h</strong>, stačí napsat:</p>

<pre>
(foreign-declare "
#include &lt;stdio.h&gt;
")
&nbsp;
(foreign-parse "extern int getchar(void);")
</pre>

<p>Poté je možné tuto funkci zavolat, jakoby se jednalo o běžnou funkci či
speciální formu deklarovanou přímo ve Scheme:</p>

<pre>
(print (getchar))
</pre>

<p>Podobné je to v&nbsp;případě funkce akceptující parametr nějakého
(céčkového) typu:</p>

<pre>
(foreign-declare "
#include &lt;math.h&gt;
")
&nbsp;
(foreign-parse "extern double fabs(double);")
&nbsp;
(print (fabs -10))
</pre>

<p>V&nbsp;případě, že se použijí funkce, které nejsou dostupné ve standardní
knihovně, je nutné příslušnou externí knihovnu či objektový soubor správně
slinkovat:</p>

<pre>
$ <strong>csc -X easyffi ffi-test.scm soubor.o</strong>
</pre>

<p>Především při použití nestandardních knihoven je někdy nutné předat další
parametry překladači céčka a/nebo linkeru, typicky s&nbsp;cestou ke hlavičkovým
souborům a cestou ke knihovně, která se má slinkovat s&nbsp;vygenerovaným kódem
do výsledného spustitelného souboru:</p>

<pre>
$ <strong>csc -X easyffi ffi-test.scm soubor.o -C -Iinclude_directory -L "-llinovaná_knihovna"</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: FFI lze využít jak při překladu
(<strong>csc</strong>), což je implementačně jednodušší, tak i v&nbsp;režimu
interpretace skriptů psaných ve Scheme.</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Předchozí části seriálu</h2>

<p>V&nbsp;této kapitole jsou uvedeny odkazy na všechny předchozí části seriálu
o světě programovacích jazyků LISP a Scheme:</p>

<ol>

<li>Jemný úvod do rozsáhlého světa jazyků LISP a Scheme<br />
<a href="https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/">https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/</a>
</li>

<li>PicoLisp: minimalistický a přitom překvapivě výkonný interpret Lispu<br />
<a href="https://www.root.cz/clanky/picolisp-minimalisticky-a-pritom-prekvapive-vykonny-interpret-lispu/">https://www.root.cz/clanky/picolisp-minimalisticky-a-pritom-prekvapive-vykonny-interpret-lispu/</a>
</li>

<li>PicoLisp: užitečné funkce a speciální formy používané při tvorbě aplikací<br />
<a href="https://www.root.cz/clanky/picolisp-uzitecne-funkce-a-specialni-formy-pouzivane-pri-tvorbe-aplikaci/">https://www.root.cz/clanky/picolisp-uzitecne-funkce-a-specialni-formy-pouzivane-pri-tvorbe-aplikaci/</a>
</li>

<li>PicoLisp: dokončení popisu a několik praktických rad na závěr<br />
<a href="https://www.root.cz/clanky/picolisp-dokonceni-popisu-a-nekolik-praktickych-rad-na-zaver/">https://www.root.cz/clanky/picolisp-dokonceni-popisu-a-nekolik-praktickych-rad-na-zaver/</a>
</li>

<li>GNU Guile – interpret Scheme vestavitelný do nativních aplikací<br />
<a href="https://www.root.cz/clanky/gnu-guile-interpret-scheme-vestavitelny-do-nativnich-aplikaci/">https://www.root.cz/clanky/gnu-guile-interpret-scheme-vestavitelny-do-nativnich-aplikaci/</a>
</li>

<li>TinyScheme aneb další interpret jazyka Scheme vestavitelný do dalších aplikací<br />
<a href="https://www.root.cz/clanky/tinyscheme-aneb-dalsi-interpret-jazyka-scheme-vestavitelny-do-dalsich-aplikaci/">https://www.root.cz/clanky/tinyscheme-aneb-dalsi-interpret-jazyka-scheme-vestavitelny-do-dalsich-aplikaci/</a>
</li>

<li>Kawa: překvapivě silný a výkonný dialekt Scheme pro JVM<br />
<a href="https://www.root.cz/clanky/kawa-prekvapive-silny-a-vykonny-dialekt-scheme-pro-jvm/">https://www.root.cz/clanky/kawa-prekvapive-silny-a-vykonny-dialekt-scheme-pro-jvm/</a>
</li>

<li>Jazyk Kawa v ekosystému virtuálního stroje Javy<br />
<a href="https://www.root.cz/clanky/jazyk-kawa-v-ekosystemu-virtualniho-stroje-javy/">https://www.root.cz/clanky/jazyk-kawa-v-ekosystemu-virtualniho-stroje-javy/</a>
</li>

<li>Zpracování vektorů, matic a N-rozměrných polí v programovacím jazyku Kawa<br />
<a href="https://www.root.cz/clanky/zpracovani-vektoru-matic-a-n-rozmernych-poli-v-programovacim-jazyku-kawa/">https://www.root.cz/clanky/zpracovani-vektoru-matic-a-n-rozmernych-poli-v-programovacim-jazyku-kawa/</a>
</li>

<li>Racket: programovací jazyk a současně i platforma pro vývoj nových jazyků<br />
<a href="https://www.root.cz/clanky/racket-programovaci-jazyk-a-soucasne-i-platforma-pro-vyvoj-novych-jazyku/">https://www.root.cz/clanky/racket-programovaci-jazyk-a-soucasne-i-platforma-pro-vyvoj-novych-jazyku/</a>
</li>

<li>Makra v Racketu i v dalších lispovských jazycích<br />
<a href="https://www.root.cz/clanky/makra-v-racketu-i-v-dalsich-lispovskych-jazycich/">https://www.root.cz/clanky/makra-v-racketu-i-v-dalsich-lispovskych-jazycich/</a>
</li>

<li>Základní knihovna jazyka Racket<br />
<a href="https://www.root.cz/clanky/zakladni-knihovna-jazyka-racket/">https://www.root.cz/clanky/zakladni-knihovna-jazyka-racket/</a>
</li>

<li>Jazyk Joker: dialekt Clojure naprogramovaný v Go<br />
<a href="https://www.root.cz/clanky/jazyk-joker-dialekt-clojure-naprogramovany-v-go/">https://www.root.cz/clanky/jazyk-joker-dialekt-clojure-naprogramovany-v-go/</a>
</li>

</ol>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/lisp-families.git">https://github.com/tisnik/lisp-families.git</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, můžete
namísto toho použít odkazy na jednotlivé příklady, které naleznete
v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>dot_pairs.scm</td><td>konstrukce tečka dvojic (<i>dot pairs</i>)</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/chicken/dot_pairs.scm">https://github.com/tisnik/lisp-families/blob/master/chicken/dot_pairs.scm</a></td></tr>
<tr><td> 2</td><td>cons.scm</td><td>funkce <strong>cons</strong> použitá pro konstrukci seznamu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/chicken/cons.scm">https://github.com/tisnik/lisp-families/blob/master/chicken/cons.scm</a></td></tr>
<tr><td> 3</td><td>lists.scm</td><td>základní práce se seznamy</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/chicken/lists.scm">https://github.com/tisnik/lisp-families/blob/master/chicken/lists.scm</a></td></tr>
<tr><td> 4</td><td>functions.scm</td><td>deklarace a volání funkcí</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/chicken/functions.scm">https://github.com/tisnik/lisp-families/blob/master/chicken/functions.scm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>factorial_1.scm</td><td>rekurzivní výpočet faktoriálu, první varianta</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/chicken/factorial_1.scm">https://github.com/tisnik/lisp-families/blob/master/chicken/factorial_1.scm</a></td></tr>
<tr><td> 6</td><td>factorial_2.scm</td><td>rekurzivní výpočet faktoriálu, druhá varianta</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/chicken/factorial_2.scm">https://github.com/tisnik/lisp-families/blob/master/chicken/factorial_2.scm</a></td></tr>
<tr><td> 7</td><td>factorial_3.scm</td><td>tail rekurze při výpočtu faktoriálu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/chicken/factorial_3.scm">https://github.com/tisnik/lisp-families/blob/master/chicken/factorial_3.scm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>lexical_scope_1.scm</td><td>lexikální oblast platnosti proměnných, příklad číslo 1</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/chicken/lexical_scope_1.scm">https://github.com/tisnik/lisp-families/blob/master/chicken/lexical_scope_1.scm</a></td></tr>
<tr><td> 9</td><td>lexical_scope_2.scm</td><td>lexikální oblast platnosti proměnných, příklad číslo 2</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/chicken/lexical_scope_2.scm">https://github.com/tisnik/lisp-families/blob/master/chicken/lexical_scope_2.scm</a></td></tr>
<tr><td>10</td><td>lexical_scope_3.scm</td><td>lexikální oblast platnosti proměnných, příklad číslo 3</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/chicken/lexical_scope_3.scm">https://github.com/tisnik/lisp-families/blob/master/chicken/lexical_scope_3.scm</a></td></tr>
<tr><td>11</td><td>lexical_scope_4.scm</td><td>lexikální oblast platnosti proměnných, příklad číslo 4</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/chicken/lexical_scope_4.scm">https://github.com/tisnik/lisp-families/blob/master/chicken/lexical_scope_4.scm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>12</td><td>closure_1.scm</td><td>uzávěry, příklad číslo 1</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/chicken/closure_1.scm">https://github.com/tisnik/lisp-families/blob/master/chicken/closure_1.scm</a></td></tr>
<tr><td>13</td><td>closure_2.scm</td><td>uzávěry, příklad číslo 2</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/chicken/closure_2.scm">https://github.com/tisnik/lisp-families/blob/master/chicken/closure_2.scm</a></td></tr>
<tr><td>14</td><td>closure_3.scm</td><td>uzávěry, příklad číslo 3</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/chicken/closure_3.scm">https://github.com/tisnik/lisp-families/blob/master/chicken/closure_3.scm</a></td></tr>
<tr><td>15</td><td>closure_4.scm</td><td>uzávěry, příklad číslo 4</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/chicken/closure_4.scm">https://github.com/tisnik/lisp-families/blob/master/chicken/closure_4.scm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>pi1.scm</td><td>výpočet &pi; realizované ve Scheme, základní varianta</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/chicken/pi1.scm">https://github.com/tisnik/lisp-families/blob/master/chicken/pi1.scm</a></td></tr>
<tr><td>17</td><td>pi2.scm</td><td>výpočet &pi; realizované ve Scheme, přidání typových informací</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/chicken/pi2.scm">https://github.com/tisnik/lisp-families/blob/master/chicken/pi2.scm</a></td></tr>
<tr><td>18</td><td>pi1.c</td><td>výpočet &pi; realizovaný v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/chicken/pi1.c">https://github.com/tisnik/lisp-families/blob/master/chicken/pi1.c</a></td></tr>
<tr><td>19</td><td>pi1.go </td><td>výpočet &pi; realizovaný v&nbsp;jazyku Go, základní varianta</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/chicken/pi1.go ">https://github.com/tisnik/lisp-families/blob/master/chicken/pi1.go </a></td></tr>
<tr><td>20</td><td>pi2.go</td><td>výpočet &pi; realizovaný v&nbsp;jazyku Go, varianta založená na gorutinách</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/chicken/pi2.go">https://github.com/tisnik/lisp-families/blob/master/chicken/pi2.go</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Literatura</h2>

<p>Sbírka dnes již klasických knih o programovacích jazycích LISP a Scheme:</p>

<ol>

<li>Peter Seibel<br />
<i>&bdquo;Practical Common Lisp&ldquo;</i><br />
2009
</li>

<li>Paul Graham<br />
<i>&bdquo;ANSI Common Lisp&ldquo;</i><br />
1995
</li>

<li>Gerald Gazdar<br />
<i>&bdquo;Natural Language Processing in Lisp: An Introduction to Computational Linguistics&ldquo;</i><br />
1989
</li>

<li>Peter Norvig<br />
<i>&bdquo;Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp&ldquo;</i><br />
1991
</li>

<li>Alex Mileler et.al.<br />
<i>&bdquo;Clojure Applied: From Practice to Practitioner&ldquo;</i><br />
2015
</li>

<li>
<i>&bdquo;Living Clojure: An Introduction and Training Plan for Developers&ldquo;</i><br />
2015
</li>

<li>Dmitri Sotnikov<br />
<i>&bdquo;Web Development with Clojure: Build Bulletproof Web Apps with Less Code&ldquo;</i><br />
2016
</li>

<li>McCarthy<br />
<i>&bdquo;Recursive functions of symbolic expressions and their computation by machine, part I&ldquo;</i><br />
1960
</li>

<li>R. Kent Dybvig<br />
<i>&bdquo;The Scheme Programming Language&ldquo;</i><br />
2009
</li>

<li>Max Hailperin<br />
<i>&bdquo;Concrete Abstractions&ldquo;</i><br />
1998
</li>

<li>Guy L. Steele<br />
<i>&bdquo;History of Scheme&ldquo;</i><br />
2006, Sun Microsystems Laboratories
</li>

<li>Kolář J., Muller K.:<br />
<i>&bdquo;Speciální programovací jazyky&ldquo;</i><br />
Praha 1981
</li>

<li>
<i>&bdquo;AutoLISP Release 9, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., October 1987
</li>

<li>
<i>&bdquo;AutoLISP Release 10, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., September 1988
</li>

<li>McCarthy, John; Abrahams, Paul W.; Edwards, Daniel J.; Hart, Timothy P.; Levin, Michael I.<br />
<i>&bdquo;LISP 1.5 Programmer's Manual&ldquo;</i><br />
MIT Press. ISBN 0 262 130 1 1 4
</li>

<li>Carl Hewitt; Peter Bishop and Richard Steiger<br />
<i>&bdquo;A Universal Modular Actor Formalism for Artificial Intelligence&ldquo;</i><br />
1973
</li>

<li>Feiman, J.<br />
<i>&bdquo;The Gartner Programming Language Survey (October 2001)&ldquo;</i><br />
Gartner Advisory
</li>

<li>Harold Abelson, Gerald Jay Sussman, Julie Sussman:<br />
<i>Structure and Interpretation of Computer Programs</i><br />
MIT Press. 1985, 1996 (a možná vyšel i další přetisk)
</li>

<li>Paul Graham<br />
<i>On Lisp</i><br />
Prentice Hall, 1993<br />
Dostupné online na stránce <a href="http://www.paulgraham.com/onlisptext.html">http://www.paulgraham.com/onlisptext.html</a>
</li>

<li>David S. Touretzky<br />
<i>Common LISP: A Gentle Introduction to Symbolic Computation (Dover Books on Engineering)</i><br />
</li>

<li>Peter Norvig<br />
<i>Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp</i>
</li>

<li>Patrick Winston, Berthold Horn<br />
<i>Lisp (3rd Edition)</i><br />
ISBN-13: 978-0201083194, ISBN-10: 0201083191
</li>

<li>Matthias Felleisen, David Van Horn, Dr. Conrad Barski<br>
<i>Realm of Racket: Learn to Program, One Game at a Time!</i><br />
ISBN-13: 978-1593274917, ISBN-10: 1593274912 
</li>

<li>Graham Hutton<br />
<i>A tutorial on the universality andexpressiveness of fold</i><br />
http://www.cs.nott.ac.uk/~pszgmh/fold.pdf
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Chicken Scheme<br />
<a href="https://call-cc.org/">https://call-cc.org/</a>
</li>

<li>Eggs Unlimited<br />
<a href="http://wiki.call-cc.org/chicken-projects/egg-index-5.html">http://wiki.call-cc.org/chicken-projects/egg-index-5.html</a>
</li>

<li>Chicken Scheme Wiki<br />
<a href="https://wiki.call-cc.org/">https://wiki.call-cc.org/</a>
</li>

<li>CHICKEN for Python programmers<br />
<a href="https://wiki.call-cc.org/chicken-for-python-programmers">https://wiki.call-cc.org/chicken-for-python-programmers</a>
</li>

<li>Programming for Performance<br />
<a href="http://wiki.call-cc.org/programming-for-performance">http://wiki.call-cc.org/programming-for-performance</a>
</li>

<li>Using the compiler<br />
<a href="https://wiki.call-cc.org/man/4/Using%20the%20compiler">https://wiki.call-cc.org/man/4/Using%20the%20compiler</a>
</li>

<li>CHICKEN Scheme tutorials<br />
<a href="https://wiki.call-cc.org/tutorials">https://wiki.call-cc.org/tutorials</a>
</li>

<li>Racket: programovací jazyk a současně i platforma pro vývoj nových jazyků<br />
<a href="https://www.root.cz/clanky/racket-programovaci-jazyk-a-soucasne-i-platforma-pro-vyvoj-novych-jazyku/">https://www.root.cz/clanky/racket-programovaci-jazyk-a-soucasne-i-platforma-pro-vyvoj-novych-jazyku/</a>
</li>

<li>Makra v Racketu i v dalších lispovských jazycích<br />
<a href="https://www.root.cz/clanky/makra-v-racketu-i-v-dalsich-lispovskych-jazycich/">https://www.root.cz/clanky/makra-v-racketu-i-v-dalsich-lispovskych-jazycich/</a>
</li>

<li>Základní knihovna jazyka Racket<br />
<a href="https://www.root.cz/clanky/zakladni-knihovna-jazyka-racket/">https://www.root.cz/clanky/zakladni-knihovna-jazyka-racket/</a>
</li>

<li>Grafický metaformát PostScript<br />
<a href="https://www.root.cz/clanky/graficky-metaformat-postscript/">https://www.root.cz/clanky/graficky-metaformat-postscript/</a>
</li>

<li>Vektorový grafický formát SVG<br />
<a href="https://www.root.cz/clanky/vektorovy-graficky-format-svg/">https://www.root.cz/clanky/vektorovy-graficky-format-svg/</a>
</li>

<li>The Racket Drawing Toolkit<br />
<a href="https://docs.racket-lang.org/draw/index.html">https://docs.racket-lang.org/draw/index.html</a>
</li>

<li>Traditional Turtles<br />
<a href="https://docs.racket-lang.org/turtles/Traditional_Turtles.html">https://docs.racket-lang.org/turtles/Traditional_Turtles.html</a>
</li>

<li>[racket] How best to repeat a function call n times?<br />
<a href="https://lists.racket-lang.org/users/archive/2014-September/064203.html">https://lists.racket-lang.org/users/archive/2014-September/064203.html</a>
</li>

<li>Racket: Macros<br />
<a href="https://www.it.uu.se/edu/course/homepage/avfunpro/ht13/lectures/Racket-3-Macros.pdf">https://www.it.uu.se/edu/course/homepage/avfunpro/ht13/lectures/Racket-3-Macros.pdf</a>
</li>

<li>Beautiful Racket / explainers: Macros<br />
<a href="https://beautifulracket.com/explainer/macros.html">https://beautifulracket.com/explainer/macros.html</a>
</li>

<li>Macros (dokumentace k Racketu)<br />
<a href="https://docs.racket-lang.org/guide/macros.html">https://docs.racket-lang.org/guide/macros.html</a>
</li>

<li>Model syntaxe jazyka Racket<br />
<a href="https://docs.racket-lang.org/reference/syntax-model.html">https://docs.racket-lang.org/reference/syntax-model.html</a>
</li>

<li>Syntax Objects<br />
<a href="https://docs.racket-lang.org/guide/stx-obj.html">https://docs.racket-lang.org/guide/stx-obj.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Beautiful Racket: an intro­duction to language-oriented programming using Racket<br />
<a href="https://beautifulracket.com/">https://beautifulracket.com/</a>
</li>

<li>Stránky projektu Racket<br />
<a href="https://racket-lang.org/">https://racket-lang.org/</a>
</li>

<li>Dokumentace k&nbsp;projektu Racket<br />
<a href="https://docs.racket-lang.org/index.html">https://docs.racket-lang.org/index.html</a>
</li>

<li>Seznam dostupných balíčků pro Racket<br />
<a href="https://pkgs.racket-lang.org/">https://pkgs.racket-lang.org/</a>
</li>

<li>Racket na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Racket_(programming_language)">https://en.wikipedia.org/wiki/Racket_(programming_language)</a>
</li>

<li>Blogy o Racketu a navazujících technologiích<br />
<a href="https://blog.racket-lang.org/">https://blog.racket-lang.org/</a>
</li>

<li>Prográmky psané v&nbsp;Racketu na RosettaCode<br />
<a href="http://rosettacode.org/wiki/Category:Racket">http://rosettacode.org/wiki/Category:Racket</a>
</li>

<li>Fear of Macros<br />
<a href="https://www.greghendershott.com/fear-of-macros/">https://www.greghendershott.com/fear-of-macros/</a>
</li>

<li>Rackjure<br />
<a href="https://github.com/greghendershott/rackjure">https://github.com/greghendershott/rackjure</a>
</li>

<li>Matthew Flatt’s proposal to change Racket’s s-expressions based syntax to infix representation creates a stir in the community<br />
<a href="https://hub.packtpub.com/matthew-flatts-proposal-to-change-rackets-s-expressions-based-syntax-to-infix-representation-creates-a-stir-in-the-community/">https://hub.packtpub.com/matthew-flatts-proposal-to-change-rackets-s-expressions-based-syntax-to-infix-representation-creates-a-stir-in-the-community/</a>
</li>

<li>Racket News<br />
<a href="https://racket-news.com/">https://racket-news.com/</a>
</li>

<li>Racket: Lisp for learning<br />
<a href="https://lwn.net/Articles/795385/">https://lwn.net/Articles/795385/</a>
</li>

<li>Future of Racket<br />
<a href="https://www.greghendershott.com/2019/07/future-of-racket.html">https://www.greghendershott.com/2019/07/future-of-racket.html</a>
</li>

<li>Kawa: Compiling Scheme to Java<br />
<a href="https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html">https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html</a>
</li>

<li>Kawa in Languages shootout<br />
<a href="http://per.bothner.com/blog/2010/Kawa-in-shootout/">http://per.bothner.com/blog/2010/Kawa-in-shootout/</a>
</li>

<li>Kawa 2.0 Supports Scheme R7RS<br />
<a href="https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/">https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/</a>
</li>

<li>Kawa — fast scripting on the Java platform<br />
<a href="https://lwn.net/Articles/623349/">https://lwn.net/Articles/623349/</a>
</li>

<li>Tail call (a její optimalizace)<br />
<a href="https://en.wikipedia.org/wiki/Tail_call">https://en.wikipedia.org/wiki/Tail_call</a>
</li>

<li>SLIME (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/SLIME">http://en.wikipedia.org/wiki/SLIME</a>
</li>

<li>slime.vim<br />
<a href="http://s3.amazonaws.com/mps/slime.vim">http://s3.amazonaws.com/mps/slime.vim</a>
</li>

<li>What are the best scheme implementations?<br />
<a href="https://www.slant.co/topics/5282/~scheme-implementations">https://www.slant.co/topics/5282/~scheme-implementations</a>
</li>

<li>Bigloo homepage<br />
<a href="http://www-sop.inria.fr/mimosa/fp/Bigloo/">http://www-sop.inria.fr/mimosa/fp/Bigloo/</a>
</li>

<li>FTP s tarbally Bigloo<br />
<a href="ftp://ftp-sop.inria.fr/indes/fp/Bigloo">ftp://ftp-sop.inria.fr/indes/fp/Bigloo</a>
</li>

<li>GOTO 2018 • Functional Programming in 40 Minutes • Russ Olsen<br />
<a href="https://www.youtube.com/watch?v=0if71HOyVjY">https://www.youtube.com/watch?v=0if71HOyVjY</a>
</li>

<li>TinyScheme (stránka na Sourceforge)<br />
<a href="http://tinyscheme.sourceforge.net/home.html">http://tinyscheme.sourceforge.net/home.html</a>
</li>

<li>Embedding Tiny Scheme in a Game<br />
<a href="http://www.silicondelight.com/embedding-tiny-scheme-in-a-game/">http://www.silicondelight.com/embedding-tiny-scheme-in-a-game/</a>
</li>

<li>Embedding Scheme for a game mission scripting DSL<br />
<a href="http://carloscarrasco.com/embedding-scheme-for-a-game-mission-scripting-dsl.html">http://carloscarrasco.com/embedding-scheme-for-a-game-mission-scripting-dsl.html</a>
</li>

<li>Všechny verze TinyScheme na SourceForge<br />
<a href="https://sourceforge.net/projects/tinyscheme/files/tinyscheme/">https://sourceforge.net/projects/tinyscheme/files/tinyscheme/</a>
</li>

<li>Fork TinyScheme na GitHubu<br />
<a href="https://github.com/yawnt/tinyscheme">https://github.com/yawnt/tinyscheme</a>
</li>

<li>Ackermannova funkce<br />
<a href="https://cs.wikipedia.org/wiki/Ackermannova_funkce">https://cs.wikipedia.org/wiki/Ackermannova_funkce</a>
</li>

<li>Ackermann function na Rosetta Code<br />
<a href="https://rosettacode.org/wiki/Ackermann_function#Scheme">https://rosettacode.org/wiki/Ackermann_function#Scheme</a>
</li>

<li>Success Stories (lisp.org)<br />
<a href="https://lisp-lang.org/success/">https://lisp-lang.org/success/</a>
</li>

<li>Allegro Common Lisp Success Stories<br />
<a href="https://franz.com/success/">https://franz.com/success/</a>
</li>

<li>Clojure Success Stories<br />
<a href="https://clojure.org/community/success_stories">https://clojure.org/community/success_stories</a>
</li>

<li>Scheme Quick Reference<br />
<a href="https://www.st.cs.uni-saarland.de/edu/config-ss04/scheme-quickref.pdf">https://www.st.cs.uni-saarland.de/edu/config-ss04/scheme-quickref.pdf</a>
</li>

<li>Slajdy o Scheme (od slajdu číslo 15)<br />
<a href="https://docs.google.com/presentation/d/1abmDnKjrq1tcjGvvRNAKhOiSTSE2lyagtcEPal07Gbo/edit">https://docs.google.com/presentation/d/1abmDnKjrq1tcjGvvRNAKhOiSTSE2lyagtcEPal07Gbo/edit</a>
</li>

<li>Scheme Cheat Sheet<br />
<a href="https://github.com/smythp/scheme-cheat-sheet">https://github.com/smythp/scheme-cheat-sheet</a>
</li>

<li>Embedding Lua, embedding Guile <br />
<a href="http://puntoblogspot.blogspot.com/2013/04/embedding-lua-embedding-guile.html">http://puntoblogspot.blogspot.com/2013/04/embedding-lua-embedding-guile.html</a>
</li>

<li>Lambda Papers<br />
<a href="https://en.wikisource.org/wiki/Lambda_Papers">https://en.wikisource.org/wiki/Lambda_Papers</a>
</li>

<li>Revised<sup>7</sup>Report on the Algorithmic Language Scheme<br />
<a href="https://small.r7rs.org/attachment/r7rs.pdf">https://small.r7rs.org/attachment/r7rs.pdf</a>
</li>

<li>Video Lectures (MIT, SICP 2005)<br />
<a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/</a>
</li>

<li>Why is Scheme my first language in university?<br />
<a href="https://softwareengineering.stackexchange.com/questions/115252/why-is-scheme-my-first-language-in-university">https://softwareengineering.stackexchange.com/questions/115252/why-is-scheme-my-first-language-in-university</a>
</li>

<li>The Perils of JavaSchools<br />
<a href="https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/">https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/</a>
</li>

<li>How to Design Programs, Second Edition<br />
<a href="https://htdp.org/2019-02-24/index.html">https://htdp.org/2019-02-24/index.html</a>
</li>

<li>LilyPond<br />
<a href="http://lilypond.org/">http://lilypond.org/</a>
</li>

<li>LilyPond — Extending (přes Scheme)<br />
<a href="http://lilypond.org/doc/v2.18/Documentation/extending/scheme-tutorial">http://lilypond.org/doc/v2.18/Documentation/extending/scheme-tutorial</a>
</li>

<li>Scheme in LilyPond<br />
<a href="http://lilypond.org/doc/v2.18/Documentation/extending/scheme-in-lilypond">http://lilypond.org/doc/v2.18/Documentation/extending/scheme-in-lilypond</a>
</li>

<li>GnuCash<br />
<a href="http://www.gnucash.org/">http://www.gnucash.org/</a>
</li>

<li>Custom Reports (in GNU Cash)<br />
<a href="https://wiki.gnucash.org/wiki/Custom_Reports">https://wiki.gnucash.org/wiki/Custom_Reports</a>
</li>

<li>Program by Design<br />
<a href="https://programbydesign.org/">https://programbydesign.org/</a>
</li>

<li>SchemePy<br />
<a href="https://pypi.org/project/SchemePy/">https://pypi.org/project/SchemePy/</a>
</li>

<li>LISP FQA: Section - [1-5] What is the "minimal" set of primitives needed for a Lisp interpreter?<br />
<a href="http://www.faqs.org/faqs/lisp-faq/part1/section-6.html">http://www.faqs.org/faqs/lisp-faq/part1/section-6.html</a>
</li>

<li>femtolisp<br />
<a href="https://github.com/JeffBezanson/femtolisp">https://github.com/JeffBezanson/femtolisp</a>
</li>

<li>(How to Write a (Lisp) Interpreter (in Python))<br />
<a href="http://norvig.com/lispy.html">http://norvig.com/lispy.html</a>
</li>

<li>Repositář s&nbsp;Guile Emacsem<br />
<a href="http://git.hcoop.net/?p=bpt/guile.git">http://git.hcoop.net/?p=bpt/guile.git</a>
</li>

<li>Interacting with Guile Compound Data Types in C<br />
<a href="http://www.lonelycactus.com/guilebook/x1555.html">http://www.lonelycactus.com/guilebook/x1555.html</a>
</li>

<li>Calling Guile functions from C<br />
<a href="http://www.lonelycactus.com/guilebook/c1204.html#SECCALLGUILEFUNC">http://www.lonelycactus.com/guilebook/c1204.html#SECCALLGUILEFUNC</a>
</li>

<li>Arrays, and other compound data types<br />
<a href="http://www.lonelycactus.com/guilebook/charrays.html">http://www.lonelycactus.com/guilebook/charrays.html</a>
</li>

<li>Interacting with Guile Compound Data Types in C<br />
<a href="http://www.lonelycactus.com/guilebook/x1555.html">http://www.lonelycactus.com/guilebook/x1555.html</a>
</li>

<li>Guile Reference Manual<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/index.html">https://www.gnu.org/software/guile/manual/html_node/index.html</a>
</li>

<li>Scheme: Summary of Common Syntax<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/Syntax-Summary.html#Syntax-Summary">https://www.gnu.org/software/guile/manual/html_node/Syntax-Summary.html#Syntax-Summary</a>
</li>

<li>Scripting with Guile: Extension language enhances C and Scheme<br />
<a href="https://www.ibm.com/developerworks/library/l-guile/index.html">https://www.ibm.com/developerworks/library/l-guile/index.html</a>
</li>

<li>Having fun with Guile: a tutorial<br />
<a href="http://dustycloud.org/misc/guile-tutorial.html">http://dustycloud.org/misc/guile-tutorial.html</a>
</li>

<li>Guile: Loading Readline Support<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/Loading-Readline-Support.html#Loading-Readline-Support">https://www.gnu.org/software/guile/manual/html_node/Loading-Readline-Support.html#Loading-Readline-Support</a>
</li>

<li>lispy<br />
<a href="https://pypi.org/project/lispy/">https://pypi.org/project/lispy/</a>
</li>

<li>Lython<br />
<a href="https://pypi.org/project/Lython/">https://pypi.org/project/Lython/</a>
</li>

<li>Lizpop<br />
<a href="https://pypi.org/project/lizpop/">https://pypi.org/project/lizpop/</a>
</li>

<li>Budoucnost programovacích jazyků<br />
<a href="http://www.knesl.com/budoucnost-programovacich-jazyku">http://www.knesl.com/budoucnost-programovacich-jazyku</a>
</li>

<li>LISP Prolog and Evolution<br />
<a href="http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html">http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html</a>
</li>

<li>List of Lisp-family programming languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages">https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages</a>
</li>

<li>clojure_py na indexu PyPi<br />
<a href="https://pypi.python.org/pypi/clojure_py">https://pypi.python.org/pypi/clojure_py</a>
</li>

<li>PyClojure<br />
<a href="https://github.com/eigenhombre/PyClojure">https://github.com/eigenhombre/PyClojure</a>
</li>

<li>Hy na GitHubu<br />
<a href="https://github.com/hylang/hy">https://github.com/hylang/hy</a>
</li>

<li>Hy: The survival guide<br />
<a href="https://notes.pault.ag/hy-survival-guide/">https://notes.pault.ag/hy-survival-guide/</a>
</li>

<li>Hy běžící na monitoru terminálu společnosti Symbolics<br />
<a href="http://try-hy.appspot.com/">http://try-hy.appspot.com/</a>
</li>

<li>Welcome to Hy’s documentation!<br />
<a href="http://docs.hylang.org/en/stable/">http://docs.hylang.org/en/stable/</a>
</li>

<li>Hy na PyPi<br />
<a href="https://pypi.org/project/hy/#description">https://pypi.org/project/hy/#description</a>
</li>

<li>Getting Hy on Python<br />
<a href="https://lwn.net/Articles/596626/">https://lwn.net/Articles/596626/</a>
</li>

<li>Programming Can Be Fun with Hy<br />
<a href="https://opensourceforu.com/2014/02/programming-can-fun-hy/">https://opensourceforu.com/2014/02/programming-can-fun-hy/</a>
</li>

<li>Přednáška o projektu Hy (pětiminutový lighttalk)<br />
<a href="http://blog.pault.ag/day/2013/04/02">http://blog.pault.ag/day/2013/04/02</a>
</li>

<li>Hy (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Hy">https://en.wikipedia.org/wiki/Hy</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Point<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Point.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Point.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Narrowing<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Narrowing.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Narrowing.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Functions that Create Markers<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Markers.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Markers.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Motion<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Motion.html#Motion">https://www.gnu.org/software/emacs/manual/html_node/elisp/Motion.html#Motion</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Basic Char Syntax<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Char-Syntax.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Char-Syntax.html</a>
</li>

<li>Elisp: Sequence: List, Array<br />
<a href="http://ergoemacs.org/emacs/elisp_list_vs_vector.html">http://ergoemacs.org/emacs/elisp_list_vs_vector.html</a>
</li>

<li>Elisp: Property List<br />
<a href="http://ergoemacs.org/emacs/elisp_property_list.html">http://ergoemacs.org/emacs/elisp_property_list.html</a>
</li>

<li>Elisp: Hash Table<br />
<a href="http://ergoemacs.org/emacs/elisp_hash_table.html">http://ergoemacs.org/emacs/elisp_hash_table.html</a>
</li>

<li>Elisp: Association List<br />
<a href="http://ergoemacs.org/emacs/elisp_association_list.html">http://ergoemacs.org/emacs/elisp_association_list.html</a>
</li>

<li>The mapcar Function (An Introduction to Programming in Emacs Lisp)<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/mapcar.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/mapcar.html</a>
</li>

<li>Anaphoric macro<br />
<a href="https://en.wikipedia.org/wiki/Anaphoric_macro">https://en.wikipedia.org/wiki/Anaphoric_macro</a>
</li>

<li>Some Common Lisp Loop Macro Examples<br />
<a href="https://www.youtube.com/watch?v=3yl8o6r_omw">https://www.youtube.com/watch?v=3yl8o6r_omw</a>
</li>

<li>A Guided Tour of Emacs<br />
<a href="https://www.gnu.org/software/emacs/tour/">https://www.gnu.org/software/emacs/tour/</a>
</li>

<li>The Roots of Lisp<br />
<a href="http://www.paulgraham.com/rootsoflisp.html">http://www.paulgraham.com/rootsoflisp.html</a>
</li>

<li>Evil (Emacs Wiki)<br />
<a href="https://www.emacswiki.org/emacs/Evil">https://www.emacswiki.org/emacs/Evil</a>
</li>

<li>Evil (na GitHubu)<br />
<a href="https://github.com/emacs-evil/evil">https://github.com/emacs-evil/evil</a>
</li>

<li>Evil (na stránkách repositáře MELPA)<br />
<a href="https://melpa.org/#/evil">https://melpa.org/#/evil</a>
</li>

<li>Evil Mode: How I Switched From VIM to Emacs<br />
<a href="https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html">https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html</a>
</li>

<li>GNU Emacs (home page)<br />
<a href="https://www.gnu.org/software/emacs/">https://www.gnu.org/software/emacs/</a>
</li>

<li>GNU Emacs (texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs">http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs</a>
</li>

<li>An Introduction To Using GDB Under Emacs<br />
<a href="http://tedlab.mit.edu/~dr/gdbintro.html">http://tedlab.mit.edu/~dr/gdbintro.html</a>
</li>

<li>An Introduction to Programming in Emacs Lisp<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html</a>
</li>

<li>27.6 Running Debuggers Under Emacs<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html">https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html</a>
</li>

<li>GdbMode<br />
<a href="http://www.emacswiki.org/emacs/GdbMode">http://www.emacswiki.org/emacs/GdbMode</a>
</li>

<li>Emacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Emacs">https://en.wikipedia.org/wiki/Emacs</a>
</li>

<li>Emacs timeline<br />
<a href="http://www.jwz.org/doc/emacs-timeline.html">http://www.jwz.org/doc/emacs-timeline.html</a>
</li>

<li>Emacs Text Editors Family<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?EmacsFamily">http://texteditors.org/cgi-bin/wiki.pl?EmacsFamily</a>
</li>

<li>Vrapper aneb spojení možností Vimu a Eclipse<br />
<a href="https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse/">https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse/</a>
</li>

<li>Vrapper aneb spojení možností Vimu a Eclipse (část 2: vyhledávání a nahrazování textu)<br />
<a href="https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse-cast-2-vyhledavani-a-nahrazovani-textu/">https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse-cast-2-vyhledavani-a-nahrazovani-textu/</a>
</li>

<li>Emacs/Evil-mode - A basic reference to using evil mode in Emacs<br />
<a href="http://www.aakarshnair.com/posts/emacs-evil-mode-cheatsheet">http://www.aakarshnair.com/posts/emacs-evil-mode-cheatsheet</a>
</li>

<li>From Vim to Emacs+Evil chaotic migration guide<br />
<a href="https://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/">https://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/</a>
</li>

<li>Introduction to evil-mode {video)<br />
<a href="https://www.youtube.com/watch?v=PeVQwYUxYEg">https://www.youtube.com/watch?v=PeVQwYUxYEg</a>
</li>

<li>EINE (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/EINE">http://www.emacswiki.org/emacs/EINE</a>
</li>

<li>EINE (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?EINE">http://texteditors.org/cgi-bin/wiki.pl?EINE</a>
</li>

<li>ZWEI (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/ZWEI">http://www.emacswiki.org/emacs/ZWEI</a>
</li>

<li>ZWEI (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?ZWEI">http://texteditors.org/cgi-bin/wiki.pl?ZWEI</a>
</li>

<li>Zmacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Zmacs">https://en.wikipedia.org/wiki/Zmacs</a>
</li>

<li>Zmacs (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?Zmacs">http://texteditors.org/cgi-bin/wiki.pl?Zmacs</a>
</li>

<li>TecoEmacs (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/TecoEmacs">http://www.emacswiki.org/emacs/TecoEmacs</a>
</li>

<li>Micro Emacs<br />
<a href="http://www.emacswiki.org/emacs/MicroEmacs">http://www.emacswiki.org/emacs/MicroEmacs</a>
</li>

<li>Micro Emacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/MicroEMACS">https://en.wikipedia.org/wiki/MicroEMACS</a>
</li>

<li>EmacsHistory<br />
<a href="http://www.emacswiki.org/emacs/EmacsHistory">http://www.emacswiki.org/emacs/EmacsHistory</a>
</li>

<li>Seznam editorů s ovládáním podobným Emacsu či kompatibilních s příkazy Emacsu<br />
<a href="http://www.finseth.com/emacs.html">http://www.finseth.com/emacs.html</a>
</li>

<li>evil-numbers<br />
<a href="https://github.com/cofi/evil-numbers">https://github.com/cofi/evil-numbers</a>
</li>

<li>Debuggery a jejich nadstavby v&nbsp;Linuxu (1.část)<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/</a>
</li>

<li>Debuggery a jejich nadstavby v&nbsp;Linuxu (2.část)<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (3): Nemiver<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (4): KDbg<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (5): ladění aplikací v editorech Emacs a Vim<br />
<a href="https://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">https://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/</a>
</li>

<li>Org mode<br />
<a href="https://orgmode.org/">https://orgmode.org/</a>
</li>

<li>The Org Manual<br />
<a href="https://orgmode.org/manual/index.html">https://orgmode.org/manual/index.html</a>
</li>

<li>Kakoune (modální textový editor)<br />
<a href="http://kakoune.org/">http://kakoune.org/</a>
</li>

<li>Vim-style keybinding in Emacs/Evil-mode<br />
<a href="https://gist.github.com/troyp/6b4c9e1c8670200c04c16036805773d8">https://gist.github.com/troyp/6b4c9e1c8670200c04c16036805773d8</a>
</li>

<li>Emacs - jak začít<br />
<a href="http://www.abclinuxu.cz/clanky/navody/emacs-jak-zacit">http://www.abclinuxu.cz/clanky/navody/emacs-jak-zacit</a>
</li>

<li>Programovací jazyk LISP a LISP machines<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-lisp-a-lisp-machines/">https://www.root.cz/clanky/programovaci-jazyk-lisp-a-lisp-machines/</a>
</li>

<li>Evil-surround<br />
<a href="https://github.com/emacs-evil/evil-surround">https://github.com/emacs-evil/evil-surround</a>
</li>

<li>Spacemacs<br />
<a href="http://spacemacs.org/">http://spacemacs.org/</a>
</li>

<li>Lisp: Common Lisp, Racket, Clojure, Emacs Lisp<br />
<a href="http://hyperpolyglot.org/lisp">http://hyperpolyglot.org/lisp</a>
</li>

<li>Common Lisp, Scheme, Clojure, And Elisp Compared<br />
<a href="http://irreal.org/blog/?p=725">http://irreal.org/blog/?p=725</a>
</li>

<li>Does Elisp Suck?<br />
<a href="http://irreal.org/blog/?p=675">http://irreal.org/blog/?p=675</a>
</li>

<li>Emacs pro mírně pokročilé (9): Elisp<br />
<a href="https://www.root.cz/clanky/emacs-elisp/">https://www.root.cz/clanky/emacs-elisp/</a>
</li>

<li>If I want to learn lisp, are emacs and elisp a good choice?<br />
<a href="https://www.reddit.com/r/emacs/comments/2m141y/if_i_want_to_learn_lisp_are_emacs_and_elisp_a/">https://www.reddit.com/r/emacs/comments/2m141y/if_i_want_to_learn_lisp_are_emacs_and_elisp_a/</a>
</li>

<li>Clojure(Script) Interactive Development Environment that Rocks!<br />
<a href="https://github.com/clojure-emacs/cider">https://github.com/clojure-emacs/cider</a>
</li>

<li>An Introduction to Emacs Lisp<br />
<a href="https://harryrschwartz.com/2014/04/08/an-introduction-to-emacs-lisp.html">https://harryrschwartz.com/2014/04/08/an-introduction-to-emacs-lisp.html</a>
</li>

<li>Emergency Elisp<br />
<a href="http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html">http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html</a>
</li>

<li>Lambda calculus<br />
<a href="https://en.wikipedia.org/wiki/Lambda_calculus">https://en.wikipedia.org/wiki/Lambda_calculus</a>
</li>

<li>John McCarthy's original LISP paper from 1959<br />
<a href="https://www.reddit.com/r/programming/comments/17lpz4/john_mccarthys_original_lisp_paper_from_1959/">https://www.reddit.com/r/programming/comments/17lpz4/john_mccarthys_original_lisp_paper_from_1959/</a>
</li>

<li>Micro Manual LISP<br />
<a href="https://www.scribd.com/document/54050141/Micro-Manual-LISP">https://www.scribd.com/document/54050141/Micro-Manual-LISP</a>
</li>

<li>How Lisp Became God's Own Programming Language<br />
<a href="https://twobithistory.org/2018/10/14/lisp.html">https://twobithistory.org/2018/10/14/lisp.html</a>
</li>

<li>History of Lisp<br />
<a href="http://jmc.stanford.edu/articles/lisp/lisp.pdf">http://jmc.stanford.edu/articles/lisp/lisp.pdf</a>
</li>

<li>The Roots of Lisp<br />
<a href="http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf">http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf</a>
</li>

<li>Racket<br />
<a href="https://racket-lang.org/">https://racket-lang.org/</a>
</li>

<li>The Racket Manifesto<br />
<a href="http://felleisen.org/matthias/manifesto/">http://felleisen.org/matthias/manifesto/</a>
</li>

<li>MIT replaces Scheme with Python<br />
<a href="https://www.johndcook.com/blog/2009/03/26/mit-replaces-scheme-with-python/">https://www.johndcook.com/blog/2009/03/26/mit-replaces-scheme-with-python/</a>
</li>

<li>Adventures in Advanced Symbolic Programming<br />
<a href="http://groups.csail.mit.edu/mac/users/gjs/6.945/">http://groups.csail.mit.edu/mac/users/gjs/6.945/</a>
</li>

<li>Why MIT Switched from Scheme to Python (2009)<br />
<a href="https://news.ycombinator.com/item?id=14167453">https://news.ycombinator.com/item?id=14167453</a>
</li>

<li>Starodávná stránka XLispu<br />
<a href="http://www.xlisp.org/">http://www.xlisp.org/</a>
</li>

<li>AutoLISP<br />
<a href="https://en.wikipedia.org/wiki/AutoLISP">https://en.wikipedia.org/wiki/AutoLISP</a>
</li>

<li>Seriál PicoLisp: minimalistický a výkonný interpret Lispu<br />
<a href="https://www.root.cz/serialy/picolisp-minimalisticky-a-vykonny-interpret-lispu/">https://www.root.cz/serialy/picolisp-minimalisticky-a-vykonny-interpret-lispu/</a>
</li>

<li>Common Lisp<br />
<a href="https://common-lisp.net/">https://common-lisp.net/</a>
</li>

<li>Getting Going with Common Lisp<br />
<a href="https://cliki.net/Getting%20Started">https://cliki.net/Getting%20Started</a>
</li>

<li>Online Tutorial (Common Lisp)<br />
<a href="https://cliki.net/online%20tutorial">https://cliki.net/online%20tutorial</a>
</li>

<li>Guile Emacs<br />
<a href="https://www.emacswiki.org/emacs/GuileEmacs">https://www.emacswiki.org/emacs/GuileEmacs</a>
</li>

<li>Guile Emacs History<br />
<a href="https://www.emacswiki.org/emacs/GuileEmacsHistory">https://www.emacswiki.org/emacs/GuileEmacsHistory</a>
</li>

<li>Guile is a programming language<br />
<a href="https://www.gnu.org/software/guile/">https://www.gnu.org/software/guile/</a>
</li>

<li>MIT Scheme<br />
<a href="http://groups.csail.mit.edu/mac/projects/scheme/">http://groups.csail.mit.edu/mac/projects/scheme/</a>
</li>

<li>SIOD: Scheme in One Defun<br />
<a href="http://people.delphiforums.com/gjc//siod.html">http://people.delphiforums.com/gjc//siod.html</a>
</li>

<li>CommonLispForEmacs<br />
<a href="https://www.emacswiki.org/emacs/CommonLispForEmacs">https://www.emacswiki.org/emacs/CommonLispForEmacs</a>
</li>

<li>Elisp: print, princ, prin1, format, message<br />
<a href="http://ergoemacs.org/emacs/elisp_printing.html">http://ergoemacs.org/emacs/elisp_printing.html</a>
</li>

<li>Special Forms in Lisp<br />
<a href="http://www.nhplace.com/kent/Papers/Special-Forms.html">http://www.nhplace.com/kent/Papers/Special-Forms.html</a>
</li>

<li>Basic Building Blocks in LISP<br />
<a href="https://www.tutorialspoint.com/lisp/lisp_basic_syntax.htm">https://www.tutorialspoint.com/lisp/lisp_basic_syntax.htm</a>
</li>

<li>Introduction to LISP - University of Pittsburgh<br />
<a href="https://people.cs.pitt.edu/~milos/courses/cs2740/Lectures/LispTutorial.pdf">https://people.cs.pitt.edu/~milos/courses/cs2740/Lectures/LispTutorial.pdf</a>
</li>

<li>Why don't people use LISP<br />
<a href="https://forums.freebsd.org/threads/why-dont-people-use-lisp.24572/">https://forums.freebsd.org/threads/why-dont-people-use-lisp.24572/</a>
</li>

<li>Structured program theorem<br />
<a href="https://en.wikipedia.org/wiki/Structured_program_theorem">https://en.wikipedia.org/wiki/Structured_program_theorem</a>
</li>

<li>Clojure: API Documentation<br />
<a href="https://clojure.org/api/api">https://clojure.org/api/api</a>
</li>

<li>Tutorial for the Common Lisp Loop Macro<br />
<a href="http://www.ai.sri.com/pkarp/loop.html">http://www.ai.sri.com/pkarp/loop.html</a>
</li>

<li>Common Lisp's Loop Macro Examples for Beginners<br />
<a href="http://www.unixuser.org/~euske/doc/cl/loop.html">http://www.unixuser.org/~euske/doc/cl/loop.html</a>
</li>

<li>A modern list api for Emacs. No 'cl required.<br />
<a href="https://github.com/magnars/dash.el">https://github.com/magnars/dash.el</a>
</li>

<li>The LOOP Facility<br />
<a href="http://www.lispworks.com/documentation/HyperSpec/Body/06_a.htm">http://www.lispworks.com/documentation/HyperSpec/Body/06_a.htm</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>Transient Data Structures
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Jazyky Hy a Clojure-py: moderní dialekty LISPu určené pro Python VM<br />
<a href="https://www.root.cz/clanky/jazyky-hy-a-clojure-py-moderni-dialekty-lispu-urcene-pro-python-vm/">https://www.root.cz/clanky/jazyky-hy-a-clojure-py-moderni-dialekty-lispu-urcene-pro-python-vm/</a>
</li>

<li>Pixie: lehký skriptovací jazyk s „kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

<li>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/">https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/</a>
</li>

<li>Stránka projektu Jython<br />
<a href="http://www.jython.org/">http://www.jython.org/</a>
</li>

<li>Jython (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Jython">https://en.wikipedia.org/wiki/Jython</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">https://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>JSR 223: Scripting for the Java<sup>TM</sup> Platform<br />
<a href="https://jcp.org/en/jsr/detail?id=223">https://jcp.org/en/jsr/detail?id=223</a>
</li>

<li>List of JVM languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_JVM_languages">https://en.wikipedia.org/wiki/List_of_JVM_languages</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

