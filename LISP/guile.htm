<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>GNU Guile - interpret Scheme vestavitelný do nativních aplikací</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>GNU Guile - interpret Scheme vestavitelný do nativních aplikací</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhé části miniseriálu o různých interpretrech a překladačích programovacích jazyků LISP a Scheme si ukážeme některé možnosti nabízené projektem GNU Guile. Zaměříme se přitom nejenom na samotný programovací jazyk, ale především na možnost integrovat GNU Guile do vlastních aplikací (embedding).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. GNU Guile &ndash; interpret Scheme vestavitelný do nativních aplikací</a></p>
<p><a href="#k02">2. Lambda Papers</a></p>
<p><a href="#k03">3. Tajemná zkratka RnRS</a></p>
<p><a href="#k04">4. Základní vlastnosti programovacího jazyka Scheme</a></p>
<p><a href="#k05">5. Koncová rekurze (tail-recursion)</a></p>
<p><a href="#k06">6. Některé rozdíly mezi LISPem a Scheme</a></p>
<p><a href="#k07">7. Funkce</a></p>
<p><a href="#k08">8. Speciální formy</a></p>
<p><a href="#k09">9. Rozhraní mezi jazykem C a intepretrem Guile</a></p>
<p><a href="#k10">10. Načtení skriptu a zavolání funkce bez parametrů z&nbsp;jazyka C</a></p>
<p><a href="#k11">11. Překlad, slinkování a spuštění demonstračního příkladu</a></p>
<p><a href="#k12">12. Zavolání funkce se dvěma parametry a zpracování návratové hodnoty</a></p>
<p><a href="#k13">13. Předání řetězce do skriptu naprogramovaného v&nbsp;Guile</a></p>
<p><a href="#k14">14. Zavolání céčkovské (nativní) funkce z&nbsp;Guile</a></p>
<p><a href="#k15">15. Skript uložený přímo ve zdrojovém kódu ve formě řetězce</a></p>
<p><a href="#k16">16. Předání tečka dvojice do skriptu vytvořeného v&nbsp;Guile</a></p>
<p><a href="#k17">17. Konstrukce seznamu a vektoru v&nbsp;céčku s&nbsp;jeho předáním do Guile</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Literatura</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. GNU Guile &ndash; interpret Scheme vestavitelný do nativních aplikací</h2>

<p>V&nbsp;dnešním článku se seznámíme s&nbsp;projektem nazvaným <i>GNU
Guile</i>, což je implementace programovacího jazyka Scheme, kterou lze použít
jak ve funkci běžného interpretru či JIT překladače, tak i &ndash; což je
z&nbsp;praktického hlediska důležitější &ndash; je možné GNU Guile použít jako
vestavěný skriptovací jazyk do nativních aplikací. GNU Guile se měl díky této
vlastnosti stát primárním skriptovacím jazykem celého GNU projektu,
v&nbsp;praxi se s&nbsp;ním ovšem setkáme pouze v&nbsp;některých aplikacích. Za
zmínku stojí zejména projekty <a href="http://www.gnucash.org/">GnuCash</a> [<a
href="https://wiki.gnucash.org/wiki/Custom_Reports">1</a>] a <a
href="http://lilypond.org/">LilyPond</a> [<a
href="http://lilypond.org/doc/v2.18/Documentation/extending/scheme-tutorial">2</a>]
[<a
href="http://lilypond.org/doc/v2.18/Documentation/extending/scheme-in-lilypond">3</a>].
GNU Guile se dále používá (i když nikoli jako jediný skriptovací jazyk)
v&nbsp;GNOME a využit byl i v&nbsp;GIMPu, kde ho lze nahradit minimalistickým
<i>TinyScheme</i>, což je projekt, o němž se zmíníme příště (typické je, že jak
LilyPond, tak i GnuCash jsou interně dosti složité a uživatelsky skriptovatelné
aplikace, u nichž je použití tak expresivního jazyka, jakým Scheme je,
užitečné).</p>

<p>Pro zajímavost je vhodné se zmínit i projektu nazvaném <i>Guile Emacs</i>.
Název tohoto projektu může být poněkud matoucí, protože se ve skutečnosti
<i>nejedná</i> o snahu nahradit Emacs Lisp jazykem Scheme (resp.&nbsp;jeho
konkrétní implementací GNU Guile), ale o zajištění, aby byly zdrojové kódy
napsané v&nbsp;Elispu překládány stejným způsobem (podobným překladačem), jako
je tomu v&nbsp;případě Guile. Výsledkem by měl být rychlejší běh jak samotného
Emacsu, tak i jeho modulů, což může být zajímavé pro rozsáhlejší moduly typu
<i>org-mode</i>, webového prohlížeče atd. Navíc se díky použití překladače GNU
Guile otevírá možnost rozšíření možností samotného Elispu o vlastnosti
podporované v&nbsp;GNU Guile. Dále by mělo být možné psát moduly buď
v&nbsp;Elispu nebo přímo v&nbsp;Guile (které je sice taktéž založeno na
LISPovském dialektu, ale jedná se o matematicky čistější implementaci, což
některým programátorům může vyhovovat). Bližší informace o tomto projektu je
možné nalézt na <a
href="https://www.emacswiki.org/emacs/SiteMap">EmacsWiki</a>, konkrétně na
stránce <a
href="https://www.emacswiki.org/emacs/GuileEmacs">https://www.emacswiki.org/emacs/GuileEmacs</a>.</p>

<p><div class="rs-tip-major">Poznámka: GUILE by se měl psát velkými písmeny,
protože to je zkratka, která znamená &bdquo;GNU Ubiquitous Intelligent Language
for Extensions&ldquo;. Plné jméno &bdquo;GNU Guile&ldquo; tedy vlastně obsahuje
&bdquo;GNU&ldquo; hned dvakrát. Navíc je GNU rekurzivní zkratka znamenající
&bdquo;GNU's Not Unix!&ldquo;, takže je zde poněkud
&bdquo;přepakoňováno&ldquo;.</div></p>

<p>Dnešní článek je rozdělen na dvě části. V&nbsp;úvodní části se seznámíme
s&nbsp;některými základními vlastnostmi programovacího jazyka Scheme (ovšem jen
do té míry, do jaké budeme tento jazyk potřebovat v&nbsp;demonstračních
příkladech) a v&nbsp;části druhé (začínající <a href="#k09">devátou
kapitolou</a>) se budeme věnovat té nejužitečnější vlastnosti GNU Guile &ndash;
schopnosti vestavět tento programovací jazyk do nativních aplikací.
Demonstrační příklady ze druhé části při překladu a linkování používají GNU
Guile verze 2.0, protože právě tuto verzi nalezneme v&nbsp;některých
&bdquo;konzervativních&ldquo; distribucích Linuxu. Ovšem po nepatrné úpravě je
možné přejít i na novější (a rychlejší!) GNU Guile 2.2. Více informací o GNU
Guile verze 2.0 i verze 2.2 lze získat na stránkách <a
href="https://www.gnu.org/software/guile/download/#releases">https://www.gnu.org/software/guile/download/#releases</a>
a <a
href="https://www.gnu.org/software/guile/news/gnu-guile-220-released.html">https://www.gnu.org/software/guile/news/gnu-guile-220-released.html</a>.</p>

<p><div class="rs-tip-major">Poznámka: pokud vás zajímá, jak populární či
naopak méně používaný je programovací jazyk Scheme, můžete navštívit například
na stránku <a
href="https://madnight.github.io/githut/#/pushes/2018/2">https://madnight.github.io/githut/#/pushes/2018/2</a>,
která obsahuje statistiky získané z&nbsp;veřejných repositářů na GitHubu (což
ovšem na druhou stranu nemusí odpovídat tomu, jak se Scheme (ne)používá
v&nbsp;projektech, které na GitHubu ve veřejných repositářích
nejsou).</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Lambda Papers</h2>

<p>První článek o programovacím jazyku <i>Scheme</i>, který měl poměrně velký
vliv na další vývoj i chápání významu programovacích jazyků z&nbsp;teoretického
i praktického hlediska, se jmenoval &bdquo;Scheme: an Interpreter for Extended
Lambda Calculus&ldquo; a vyšel až v&nbsp;roce 1975 (to již LISP skoro dosahoval
plnoletosti). Po tomto článku následovala dvojice neméně důležitých publikací
s&nbsp;všeříkajícími názvy &bdquo;Lambda: The Ultimate Imperative&ldquo; a
&bdquo;Lambda: The Ultimate Declarative&ldquo; s&nbsp;popisem toho, jakým
způsobem je možné ve <i>Scheme</i> nahrazovat běžné programové konstrukce známé
například z&nbsp;tehdy používaných imperativních programovacích jazyků (céčka,
Fortranu, Algolu, posléze i Pascalu atd.). V&nbsp;následující tabulce jsou
vypsány všechny publikace Guye Steela a Geralda Sussmana vydávané v&nbsp;letech
1975 až 1980, které se dnes souhrnně nazývají <i>Lambda Papers</i> (<a
href="https://en.wikisource.org/wiki/Lambda_Papers">https://en.wikisource.org/wiki/Lambda_Papers</a>).
I přes svoje stáří jsou tyto publikace stále velmi důležitou součástí celého
oboru IT:</p>

<table>
<tr><th>Rok vydání</th><th>Název publikace</th></tr>
<tr><td>1975</td><td><a href="https://en.wikisource.org/wiki/Scheme:_An_Interpreter_for_Extended_Lambda_Calculus">Scheme: An Interpreter for Extended Lambda Calculus</a></td></tr>
<tr><td>1976</td><td><a href="https://en.wikisource.org/wiki/Lambda:_The_Ultimate_Imperative">Lambda: The Ultimate Imperative</a></td></tr>
<tr><td>1976</td><td><a href="https://en.wikisource.org/wiki/Lambda:_The_Ultimate_Declarative">Lambda: The Ultimate Declarative</a></td></tr>
<tr><td>1977</td><td><a href="https://en.wikisource.org/wiki/Lambda:_The_Ultimate_GOTO">Debunking the 'Expensive Procedure Call' Myth, or, Procedure Call Implementations Considered Harmful, or, Lambda: The Ultimate GOTO</a></td></tr>
<tr><td>1978</td><td><a href="https://en.wikisource.org/wiki/The_Art_of_the_Interpreter">The Art of the Interpreter or, the Modularity Complex (Parts Zero, One, and Two)</a></td></tr>
<tr><td>1978</td><td><a href="https://en.wikisource.org/wiki/Rabbit:_A_Compiler_for_Scheme">RABBIT: A Compiler for SCHEME</a></td></tr>
<tr><td>1979</td><td><a href="https://en.wikisource.org/wiki/Lambda:_The_Ultimate_Opcode">Design of LISP-based Processors, or SCHEME: A Dielectric LISP, or Finite Memories Considered Harmful, or LAMBDA: The Ultimate Opcode</a></td></tr>
<tr><td>1980</td><td>Compiler Optimization Based on Viewing LAMBDA as RENAME + GOTO</td></tr>
<tr><td>1980</td><td>Design of a Lisp-based Processor</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Tajemná zkratka RnRS</h2>

<p>Pro další vývoj programovacího jazyka <i>Scheme</i> byl důležitý rok 1978,
kdy došlo ke vzniku jeho prvního skutečného standardu, jenž byl popsán
v&nbsp;&bdquo;Revidované zprávě o algoritmickém jazyku Scheme&ldquo;
(<i>Revised Report on the Algorithmic Language Scheme</i>). Jazyk Scheme se i
tomto datu samozřejmě dále vyvíjel, takže v&nbsp;roce 1985 vznikl další popis
jeho standardu zveřejněný v&nbsp;dokumentu nazvaném &bdquo;Revize revidované
zprávy o Scheme, neboli neobvyklý LISP&ldquo;. Tradice ve vydávání revizí (a
revizí revizí) původní zprávy o programovacím jazyku <i>Scheme</i> zůstala
zachována až do dnešní doby. Postupně (resp.&nbsp;přesněji řečeno prozatím)
vzniklo celkem sedm revizí, což mj.&nbsp;znamená, že většina současných
implementací tohoto programovacího jazyka stále odpovídá buď páté revizi
(&bdquo;The Revised<sup>5</sup> Report on the Algorithmic Language
Scheme&ldquo;) z&nbsp;roku 1998, přizpůsobuje se revizi šesté (&bdquo;The
Revised<sup>6</sup> Report on the Algorithmic Language Scheme&ldquo;), která
byla schválena v&nbsp;roce 2007, popř.&nbsp;již adaptovala poněkud kontroverzní
R7RS (viz též <a
href="http://scheme-reports.org/">http://scheme-reports.org/</a> popř.&nbsp;<a
href="https://small.r7rs.org/wiki/R7RSSmallErrata/">R7RSSmall­Errata</a>).</p>

<p>Odkazy na jednotlivé (revidované (revidované)) reporty:</p>

<ol>
<li><a href="http://dspace.mit.edu/bitstream/handle/1721.1/5794/AIM-349.pdf">Report</a></li>
<li><a href="http://dspace.mit.edu/bitstream/handle/1721.1/6283/AIM-452.pdf">Revised Report</a></li>
<li><a href="http://dspace.mit.edu/bitstream/handle/1721.1/5600/AIM-848.pdf">Revised2 Report</a></li>
<li><a href="https://bitbucket.org/cowan/r7rs/raw/4c27517de187142ad2cf4bcd8cb9199ae1e48c09/rnrs/r3rs.pdf">Revised3 Report</a></li>
<li><a href="https://bitbucket.org/cowan/r7rs/raw/4c27517de187142ad2cf4bcd8cb9199ae1e48c09/rnrs/r4rs.pdf">Revised4 Report</a></li>
<li><a href="https://bitbucket.org/cowan/r7rs/raw/4c27517de187142ad2cf4bcd8cb9199ae1e48c09/rnrs/r5rs.pdf">Revised5 Report</a></li>
<li><a href="http://www.r6rs.org/">Revised6 Report</a></li>
<li><a href="https://bitbucket.org/cowan/r7rs/raw/4c27517de187142ad2cf4bcd8cb9199ae1e48c09/rnrs/r7rs-official.pdf">Revised7 Report, &bdquo;small&ldquo; language</a></li>
</ol>



<p><a name="k04"></a></p>
<h2 id="k04">4. Základní vlastnosti programovacího jazyka Scheme</h2>

<p><i>&bdquo;Learning Lisp is like climbing a hill in which the first part is
the steepest.&ldquo;</i></p>

<p><i>Scheme</i> je programovací jazyk, který podporuje různá paradigmata
programování, především paradigma funkcionální (i když se nejedná o čistě
funkcionální jazyk) a paradigma imperativní. Z&nbsp;funkcionálních jazyků se ve
<i>Scheme</i> objevuje především koncept lambda výrazů, funkcí jakožto
plnohodnotných datových typů, což mj.&nbsp;znamená, že funkce je možné předávat
jako parametry jiným funkcím, funkce mohou být návratovými hodnotami jiných
funkcí atd. Naopak z&nbsp;jazyků imperativních (mezi něž patří velká část
v&nbsp;současnosti používaných programovacích jazyků) se ve <i>Scheme</i>
objevuje bloková struktura kódu převzatá z&nbsp;<i>Algolu 60</i>, koncept
globálních a lokálních proměnných s&nbsp;takzvanou lexikální oblastí jejich
platnosti (<i>lexical scope</i>, na rozdíl od dynamického vyhodnocování
platnosti, které bylo použito v&nbsp;původním LISPu a teprve později se
v&nbsp;novějších LISPech přešlo k&nbsp;vyhodnocování lexikálnímu) a podpora
programových smyček, které se v&nbsp;čistě funkcionálních jazycích nahrazují
rekurzí či speciálními formami, mezi něž patří například
<strong>apply</strong>, <strong>map</strong>, <strong>for-each</strong>,
<strong>mapcar</strong> či <strong>reduce</strong>.</p>

<p>Základními datovými typy, se kterými se ve <i>Scheme</i> pracuje, jsou
<i>atomy</i> a <i>seznamy</i>. Atomy jsou z&nbsp;hlediska tohoto programovacího
jazyka základními objekty, které není možné dále dělit, ale je je možné ukládat
do seznamů. Atomy mohou být několika typů: jedná se především o <i>symboly</i>
(například <strong>ABC</strong>), čísla (<strong>42</strong>,
<strong>3.1415</strong> atd. &ndash; některé interpretry jazyka Scheme
rozlišují celá čísla, čísla reálná, čísla komplexní a někdy též zlomky,
tj.&nbsp;čísla racionální), řetězce, vestavěné funkce atd. V&nbsp;reálných
programech se atomy ukládají do seznamů, přičemž pro označení začátku a konce
seznamu se používají kulaté závorky &ndash; levá závorka samozřejmě označuje
začátek seznamu a pravá závorka jeho konec. Prvky/elementy seznamu jsou od sebe
odděleny alespoň jednou mezerou nebo koncem řádku, což mj.&nbsp;znamená, že
seznam může být rozepsán na více řádcích (to je velmi důležité ve chvíli, kdy
se pomocí seznamů reprezentují funkce).</p>

<p>Zvláštním a v&nbsp;mnoha ohledech důležitým typem seznamu je <i>prázdný
seznam</i>, jenž neobsahuje žádné prvky (elementy) a proto je zapisován levou
závorkou, za níž ihned následuje závorka pravá. Mezi závorkami se tedy
nenachází žádný atom ani další seznam, mohou se zde nacházet pouze mezery nebo
konce řádků (v&nbsp;LISPu je navíc prázdný seznam ekvivalentní symbolu
<strong>nil</strong>, který současně určuje pravdivostní hodnotu <i>false</i>).
Seznam může jako své prvky (elementy) obsahovat jak atomy, tak i další vnořené
seznamy, což znamená, že se jedná o rekurzivní datovou strukturu, pomocí níž je
možné popsat i mnohé další složitější datové struktury, například
n-dimenzionální pole, stromy, hierarchické mřížky atd. Pod tímto odstavcem je
uvedeno několik příkladů seznamů akceptovaných interpretrem jazyka Scheme.
Povšimněte si důsledného vyvážení pravých a levých závorek, především
v&nbsp;případě, že seznam obsahuje jako své prvky/elementy další
podseznamy:</p>

<pre>
(define (print item)
     (display item)
     (newline))
&nbsp;
(print '(1 2 3 4))
&nbsp;
(print (list 1 2 3 4))
&nbsp;
<i>; create list and assign it to symbol</i>
<i>; (=variable)</i>
(define a '(1 2 3 4))
&nbsp;
<i>; get the first item</i>
(print (car a))
&nbsp;
<i>; get the rest of a list</i>
(print (cdr a))
&nbsp;
<i>; combination of car+cdr</i>
(print (cadr a))
&nbsp;
<i>; combination of cdr+cdr</i>
(print (cddr a))
</pre>

<p>Interně jsou seznamy reprezentovány prvky, přičemž každý prvek je tvořen
takzvanou tečka-dvojicí, kterou si můžeme představit jako strukturu obsahující
dvě hodnoty &ndash; buď ukazatel na další tečka-dvojici nebo hodnotu (včetně
prázdné hodnoty):</p>

<pre>
(define (print item)
     (display item)
     (newline))
&nbsp;
(print '(1 . 2))
&nbsp;
(print '(1 . ((2 . 3) . 4)))
&nbsp;
(print '((1 . 2) . (3 . 4)))
&nbsp;
<i>; this is proper list in LISP, not in Scheme!</i>
(print '(1 . (2 . (3 . nil))))
&nbsp;
<i>; this is proper list</i>
(print '(1 . (2 . (3 . ()))))
</pre>

<p>Výsledky:</p>

<pre>

(1 . 2)
(1 (2 . 3) . 4)
((1 . 2) 3 . 4)
(1 2 3 . nil)
(1 2 3)
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Koncová rekurze (tail-recursion)</h2>

<p>V&nbsp;naprosté většině algoritmů se objevují bloky kódu, které se mají
iterativně opakovat. Při programování s&nbsp;využitím funkcionálního
paradigmatu se iterace vyjadřuje formou rekurze. Ta je samozřejmě ve
<i>Scheme</i> podporována (mezi jediné známější jazyky, které rekurzi
nepodporovaly, patřil původní <i>FORTRAN</i> a <i>Basic</i>), ovšem specifikace
jazyka <i>Scheme</i> jde ještě dále, protože určuje, ve kterých případech je
skutečná rekurze (při níž se parametry a návratové adresy musí ukládat na
zásobník) nahrazena takzvanou <i>koncovou rekurzí</i>, což zjednodušeně řečeno
znamená, že se namísto skutečného rekurzivního volání funkce interně provede
obyčejný skok (koncový skok či koncové volání) bez nutnosti alokace místa na
zásobníku pro parametry volané funkce a návratové adresy. Koncová rekurze
představuje při správném použití velmi silnou programovací techniku, protože
umožňuje zapisovat mnoho algoritmů v&nbsp;mnohdy elegantní rekurzivní formě,
ovšem skutečné zpracování takto zapsaných algoritmů je stejně efektivní jako
provádění programové smyčky (každou koncovou rekurzi lze nahradit smyčkou a
naopak).</p>

<p>Klasickým příkladem rozdílu mezi normální (plnou, skutečnou) rekurzí a
koncovou rekurzí je výpočet faktoriálu. Ten můžeme zapsat mnoha způsoby,
například (jak je to v&nbsp;matematice obvyklé), rekurzivně:</p>

<pre>
(define (factorial n)
    (if (= n 0) <i>; podmínka pro ukončení rekurzivního zanořování</i>
        1       <i>; faktoriál nuly je definitoricky roven jedné</i>
        (* n (factorial (- n 1)))
    )
)
</pre>

<p>Ve Scheme ovšem používáme nepatrně odlišný zápis, kde se uzavírací závorky
umisťují za poslední výraz:</p>

<pre>
(define (factorial n)
    (if (= n 0) <i>; podmínka pro ukončení rekurzivního zanořování</i>
        1       <i>; faktoriál nuly je definitoricky roven jedné</i>
        (* n (factorial (- n 1)))))
</pre>

<p>Z&nbsp;teoretického hlediska není na výše uvedené funkci nic nekorektního,
ovšem při jejím praktickém používání brzy narazíme na limit způsobený omezenou
velikostí zásobníku. Povšimněte si, že jazyk <i>Scheme</i> nemá velikost
datových typů omezen na <i>int</i> či <i>double</i> tak, jako tomu je u
některých dalších programovacích jazyků, překvapivě i u mnoha jazyků
vysokoúrovňových, kde by programátor teoreticky čekal vyšší úroveň
abstrakce:</p>

<pre>
<strong>(factorial 1)</strong>
1
&nbsp;
<strong>(factorial 10)</strong>
3628800
&nbsp;
<strong>(factorial 100)</strong>
9332621544394415268169923885626670049071
5968264381621468592963895217599993229915
6089414639761565182862536979208272237582
51185210916864000000000000000000000000 
<i>; výsledek je pro potřeby článku rozdělen na čtyři řádky</i>
&nbsp;
<i>; ovšem nyní výpočet zhavaruje (záleží na konkrétní verzi interpretru!)</i>
<strong>(factorial 1000)</strong>
ERROR: Stack overflow
ABORT: (stack-overflow)
</pre>

<p>Výše uvedený rekurzivní výpočet lze relativně malou úpravou převést na
výpočet který (alespoň v&nbsp;programovacím jazyce <i>Scheme</i>) vede na
koncové volání, což mj.&nbsp;znamená, že paměťové (prostorové) nároky tohoto
programu jsou konstantní:</p>

<pre>
; výpočet faktoriálu využívající koncového volání
(define (factorial n)
    (let fact-iter (          <i>; pomocná vnitřní funkce</i>
                  (n n)       <i>; počitadlo iterací</i>
                  (result 1)) <i>; průběžný výsledek</i>
        (if (= n 0)           <i>; po dosažení koncového stavu</i>
            result            <i>; se vrátí průběžný výsledek</i>
            (fact-iter (- n 1) (* n result)) <i>; koncové volání</i>
        )))
</pre>

<p>O tom, že upravený algoritmus výpočtu faktoriálu nevyužívá zásobník pro
ukládání mezivýsledků ani počitadla iterací, se můžeme jednoduše přesvědčit.
Popravdě řečeno i tento výpočet pro nějaké velké <i>n</i> zhavaruje, protože se
překročí limit paměti alokované pro uložení mezivýsledku &ndash; proměnné
<i>result</i>:</p>

<pre>
<strong>(factorial 1)</strong>
1
&nbsp;
<strong>(factorial 10)</strong>
3628800
&nbsp;
<strong>(factorial 100)</strong>
9332621544394415268169923885626670049071
5968264381621468592963895217599993229915
6089414639761565182862536979208272237582
51185210916864000000000000000000000000 
<i>; výsledek je pro potřeby článku rozdělen na čtyři řádky</i>
&nbsp;
<i>; zkusíme výpočet faktoriálu pro nějaké</i>
<i>; větší číslo</i>
<strong>(factorial 1000)</strong>
4023872600770937735437024339230039857193
7486421071463254379991042993851239862902
0592044208486969404800479988610197196058
6316668729948085589013238296699445909974
2450408707375991882362772718873251977950
5950995276120874975462497043601418278094
6464962910563938874378864873371191810458
2578364784997701247663288983595573543251
3185323958463075557409114262417474349347
5534286465766116677973966688202912073791
4385371958824980812686783837455973174613
6085379534524221586593201928090878297308
4313928444032812315586110369768013573042
1616874760967587134831202547858932076716
9132448426236131412508780208000261683151
0273418279777047846358681701643650241536
9139828126481021309276124489635992870511
4964975419909342221566832572080821333186
1168115536158365469840467089756029009505
3761647584772842188967964624494516076535
3408198901385442487984959953319101723355
5566021394503997362807501378376153071277
6192684903435262520001588853514733161170
2103968175921510907788019393178114194545
2572238655414610628921879602238389714760
8850627686296714667469756291123408243920
8160153780889893964518263243671616762179
1689097799119037540312746222899880051954
4441428201218736174599264295658174662830
2955570299024324153181617210465832036786
9061172601587835207515162842255402651704
8330422614397428693306169089796848259012
5458327168226458066526769958652682272807
0757813918581788896522081643483448259932
6604336766017699961283186078838615027946
5955131156552036093988180612138558600301
4356945272242063446317974605946825731037
9008402443243846565724501440282188525247
0935190620929023136493273497565513958720
5596542287497740114133469627154228458623
7738753823048386568897646192738381490014
0767310446640259899490222221765904339901
8860185665264850617997023561938970178600
4081188972991831102117122984590164192106
8884387121855646124960798722908519296819
3723886426148396573822911231250241866493
5314397013742853192664987533721894069428
1434118520158014123344828015051399694290
1534830776445690990731524332782882698646
0278986432113908350621709500259738986355
4277196742822248757586765752344220207573
6305694988250879689281627538488633969099
5982628095612145099487170124451646126037
9029309120889086942028510640182154399457
1568059418727489980942547421735824010636
7740459574178516082923013535808184009699
6372524230560855903700624271243416909004
1536901059339838357779394109700277534720
0000000000000000000000000000000000000000
0000000000000000000000000000000000000000
0000000000000000000000000000000000000000
0000000000000000000000000000000000000000
0000000000000000000000000000000000000000
0000000000000000000000000000000000000000
0000000
&nbsp;
; uff :-)
</pre>

<p><div class="rs-tip-major">Poznámka: GNU Guile používá dynamicky alokovaný
zásobník, takže bez problémů dokáže vypočítat i relativně vysoké faktoriály, a
to i bez použití tail rekurze.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Některé rozdíly mezi LISPem a Scheme</h2>

<p><div class="rs-tip-major">Poznámka: <a
href="https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/">připomeňme
si</a>, že LISP je nutné chápat spíše jako koncept, než jako konkrétní
programovací jazyk s&nbsp;přesně definovanými názvy literálů, funkcí a
speciálních forem. V&nbsp;některých diskusích se ovšem pod obecným pojmem LISP
myslí přímo <i>Common LISP</i>, což je velmi významný dialekt, kterému se
budeme podrobněji věnovat v&nbsp;navazujících článcích.</div></p>

<p>Zápis programů v&nbsp;jazyku <i>Scheme</i> se ze syntaktického a částečně i
ze sémantického hlediska podobá zápisu programů v&nbsp;<i>LISPu</i>, ovšem mezi
oběma jazyky existuje několik rozdílů, které poněkud komplikují převody
programů mezi <i>LISPem</i> a <i>Scheme</i> a samozřejmě i převody opačným
směrem. Nejzásadnějším rozdílem mezi <i>Scheme</i> a mnohými staršími
interpretry jazyka <i>LISP</i> (kromě <i>Common Lispu</i>) je to, že zatímco se
v&nbsp;LISPu oblast platnosti proměnných stanovuje dynamicky v&nbsp;čase běhu
programu (například ve chvíli, kdy je definována nová funkce se zjišťují
hodnoty všech proměnných použitých v&nbsp;této funkci), ve <i>Scheme</i> a
v&nbsp;některých novějších implementacích LISPu je oblast platnosti proměnné
určena na základě toho, v&nbsp;jakém bloku se proměnná nachází (tato vlastnost
jazyka se označuje <i>lexical scope</i>), což je podobné chování, jaké
nalezneme i u naprosté většiny dalších programovacích jazyků. <i>Lexical
scope</i> je v&nbsp;běžných programech přehlednější (programátor může určit
oblast platnosti pouze ze zdrojového kódu, nemusí přemýšlet nad tím, jak se
program chová při spuštění) a dokonce se i snáze implementuje.</p>

<p>Nejjednodušší příklad:</p>

<pre>
(define x 1)
(define y 2)
&nbsp;
(define (add x y)
    (+ x y))
&nbsp;
(print (+ x y))
(print (add x y))
&nbsp;
<i>; vypíše se:</i>
3
3
</pre>

<p>Změna hodnoty proměnné má vliv pouze na druhé volání funkce:</p>

<pre>
(define x 1)
(define y 2)
&nbsp;
(define (add x y)
    (+ x y))
&nbsp;
(print (add x y))
(set! x 10)
(print (add x y))
<i>; vypíše se:</i>
3
12
</pre>

<p>Zatím se neděje nic objevného, ovšem další příklad již ukazuje, jak Scheme
pracuje s&nbsp;lokálním rozsahem proměnné:</p>

<pre>
(define x 1)
(define y 2)
&nbsp;
(define (add x y)
    ; rozsah (scope) je lokální!
    (set! x (+ x y))
    x)
&nbsp;
(print (add x y))
(print (add x y))
&nbsp;
(set! x 10)
(print (add x y))
(print (add x y))
<i>; vypíše se:</i>
3
3
12
12
</pre>

<p>A konečně příklad s&nbsp;globálními a lokálními proměnnými:</p>

<pre>
(define x 1)
(define y 2)
&nbsp;
(define (add x y)
    (+ x y))
&nbsp;
(print (add x y))
&nbsp;
(print
    (let ((x 10)
          (y 20))
          (add x y)))
&nbsp;
&nbsp;
(set! x 10)
(print (add x y))
&nbsp;
(print
    (let ((x 10)
          (y 20))
          (add x y)))
&nbsp;
(print
    (let ((x 100))
          (add x y)))
<i>; vypíše se:</i>
3
30
12
30
102
</pre>

<p><div class="rs-tip-major">Poznámka: <i>lexical scope</i> má ovšem
dalekosáhlejší důsledky, které mj.&nbsp;ovlivňují činnost správce paměti atd.
Jde o to, že pokud je nějaká proměnná (která je definovaná vně funkce) na
funkci <i>navázána</i> (prakticky: je ve funkci použita), nemůže tato proměnná
zaniknout ani při opuštění daného bloku, protože společně s&nbsp;funkcí tvoří
takzvaný <i>uzávěr (closure</i>). S&nbsp;uzávěry se v&nbsp;LISPovské rodině
jazyků setkáme velmi často a dnes je nalezneme i v&nbsp;některých dalších
programovacích jazycích (zdaleka ne ve všech):</div></p>

<pre>
(define (larger-than limit)
    (lambda (value) (&gt; value limit)))
&nbsp;
(print ((larger-than 5) 0))
(print ((larger-than 5) 10))
&nbsp;
(print (filter (larger-than 5) '(1 2 3 4 5 6 7 8 9 10)))
<i>; s výsledky</i>
#f
#t
(6 7 8 9 10)
(6 7 8 9 10)
</pre>

<p><div class="rs-tip-major">Poznámka: podívejte se i na další demonstrační
příklady s&nbsp;uzávěry, které jsou uvedeny <a href="#k18">v&nbsp;osmnácté
kapitole</a>.</div></p>

<p>Druhou odlišností mezi <i>Scheme</i> a <i>LISPem</i> je rozdílná
reprezentace pravdivostních hodnot. Zatímco <i>LISP</i> považuje prázdný seznam
<strong>()</strong>, reprezentovaný též hodnotou <strong>nil</strong>, za
nepravdu a všechny ostatní hodnoty za pravdu, existuje ve <i>Scheme</i> jen
jediná globálně dostupná a v&nbsp;celém systému jedinečná nepravdivá hodnota
označovaná symbolem <strong>#f</strong>. Všechny ostatní objekty, včetně
prázdného seznamu, jsou považovány za hodnotu pravdivou, což může komplikovat
převody zdrojových kódů programů, protože v&nbsp;poměrně velkém množství
algoritmů se například zpracovávají seznamy takovým způsobem, že se z&nbsp;nich
postupně odebírají prvky a algoritmus skončí v&nbsp;případě odebrání posledního
prvku, neboť se prázdný seznam vyhodnotí na nepravdivou hodnotu.</p>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti i zde existují lokální
odlišnosti, například ve chvíli, kdy se GNU Guile snaží emulovat některé
vlastnosti Emacs Lispu.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Funkce</h2>

<p>Podobně jako u každého dialektu programovacího jazyka LISP, i v&nbsp;případě
<i>Schme</i> se program skládá především z&nbsp;funkcí. Ty mohou být anonymní
(nepojmenované) či naopak pojmenované. Nejprve se zabývejme pojmenovanými
funkcemi, protože ty se chovají prakticky stejně, jako běžné funkce
v&nbsp;jiných programovacích jazycích. Pojmenované funkce se definují pomocí
<strong>define</strong>, za nímž v&nbsp;závorkách následuje jméno funkce. Každá
funkce může mít libovolný počet parametrů, jejichž jména se uvádí
v&nbsp;seznamu ihned za pojmenováním funkce. Poslední částí formy
<strong>define</strong> je v&nbsp;tomto případě tělo funkce, přičemž po
zavolání funkce se vyhodnocená forma vrátí jako její výsledek (nikde se tedy
nezapisuje slovo &bdquo;return&ldquo; ani nic podobného):</p>

<pre>
<i>; one-liner function</i>
(define (<strong>add</strong> x y) (+ x y))
&nbsp;
<i>; function written on more lines</i>
(define (<strong>mul</strong> x y)
  (* x y))
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti je výše uvedená definice
pouze syntaktickým cukrem nahrazujícím definici proměnné, jejíž hodnotou je
anonymní funkce, která je zapisovaná pomocí speciální formy
<strong>lambda</strong>. Bez použití syntaktického cukru by definice nové
funkce vypadala takto:</div></p>

<pre>
<i>; function written on more lines using lambda</i>
(define <strong>div</strong> (lambda (x y)
  (* x y)))
</pre>

<p>Zavolání funkce je jednoduché &ndash; používá se stále ten samý formát
seznamu, na jehož prvním místě je jméno funkce a za ním následují
parametry:</p>

<pre>
(print (add 1 2))
(print (mul 6 7))
(print (div 10 3))
</pre>

<p>Kromě pojmenovaných funkcí, které jsme si již představili v&nbsp;předchozím
textu, je možné ve <i>Scheme</i> použít i funkce anonymní, tj.&nbsp;funkce,
které nejsou navázány na žádné jméno. Pro tento účel se používá přímo lambda
výraz (bez <strong>define</strong>), podobně jako v&nbsp;každém ortodoxním
Lispu (snad kromě <i>PicoLispu</i>):</p>

<pre>
<i>; anonymous function is a value</i>
(lambda (x y) (+ x y))
&nbsp;
<i>; call anonymous function</i>
(print (lambda (x y) (+ x y)))
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Speciální formy</h2>

<p>Poslední důležitou vlastností jazyka <i>Scheme</i>, s&nbsp;níž se dnes
seznámíme, je použití takzvaných <i>speciálních forem</i>. Ze syntaktického
hlediska jsou speciální formy zapisovány naprosto stejným způsobem jako běžné
funkce, ovšem existuje zde jeden významný rozdíl &ndash; zatímco u funkcí jsou
všechny jejich parametry nejdříve vyhodnoceny, u speciálních forem
k&nbsp;tomuto vyhodnocení obecně nedochází, resp.&nbsp;jsou vyhodnoceny pouze
některé parametry (které konkrétně, to závisí na tom, o jakou speciální formu
se jedná).</p>

<p>K&nbsp;čemu jsou speciální formy dobré? Typickým příkladem je zápis
podmíněných bloků kódu. V&nbsp;tomto případě potřebujeme, aby se nějaká část
programu vykonala pouze v&nbsp;případě, že je splněna (popř.&nbsp;nesplněna)
nějaká podmínka, v&nbsp;opačném případě nemá být tato část programu vůbec
vykonána. Pomocí běžných funkcí by nebylo možné tuto funkcionalitu splnit,
protože by kód (předaný jako parametr &ndash; jinou možnost ve Scheme ostatně
nemáme) vykonal ještě před zavoláním &bdquo;podmínkové&ldquo; funkce.
Z&nbsp;toho vyplývá, že samotná podmínka (i když se syntakticky podobá volání
funkce) je speciální formou.</p>

<p>Následuje seznam základních speciálních forem ve Scheme:</p>

<table>
<tr><th> #</th><th>Jméno</th><th>Stručný popis</th></tr>
<tr><td> 1</td><td>lambda</td><td>vytvoření anonymní funkce nebo uzávěru</td></tr>
<tr><td> 2</td><td>define</td><td>definice nové proměnné (může jít i o funkci)</td></tr>
<tr><td> 3</td><td>quote</td><td>zakazuje vyhodnocení podvýrazu (tedy seznamu)</td></tr>
<tr><td> 4</td><td>set!</td><td>změna hodnoty proměnné</td></tr>
<tr><td> 5</td><td>let</td><td>blok, na který je navázána nová lokální proměnná či proměnné</td></tr>
<tr><td> 6</td><td>let*</td><td>podobné <strong>let</strong>, ovšem umožňuje při inicializaci proměnných použít proměnné nalevo (nahoře) od právě deklarované proměnné</td></tr>
<tr><td> 7</td><td>letrec</td><td>podobné <strong>let</strong>, ovšem navíc je možné se při inicializaci proměnných rekurzivně odkazovat na další proměnné</td></tr>
<tr><td> 8</td><td>letrec*</td><td>kombinace <strong>let*</strong> a <strong>letrec</strong></td></tr>
<tr><td> 9</td><td>begin</td><td>umožňuje definovat blok s&nbsp;více výrazy, které se postupně vyhodnotí</td></tr>
<tr><td>10</td><td>if</td><td>podmíněné vyhodnocení prvního či druhého podvýrazu na základě vyhodnocené podmínky</td></tr>
<tr><td>11</td><td>cond</td><td>vícenásobné rozvětvení (vyhodnocení podvýrazů)</td></tr>
<tr><td>12</td><td>case</td><td>rozeskok na základě hodnoty vyhodnoceného podvýrazu</td></tr>
<tr><td>13</td><td>when</td><td>pokud je podmínka splněna, vyhodnotí všechny podvýrazy</td></tr>
<tr><td>14</td><td>unless</td><td>pokud podmínka není splněna, vyhodnotí všechny podvýrazy</td></tr>
<tr><td>15</td><td>and</td><td>zkrácené vyhodnocení logického součinu</td></tr>
<tr><td>16</td><td>or</td><td>zkrácené vyhodnocení logického součtu</td></tr>
<tr><td>17</td><td>do</td><td>zápis iterace s&nbsp;inicializací logických proměnných i s&nbsp;jejich změnou v&nbsp;každé iteraci</td></tr>
</table>

<p>Někdy (spíše však v&nbsp;teoreticky zaměřených článcích) se setkáme i
s&nbsp;pojmem <i>primitivní speciální formy</i>. Myslí se tím minimální sada
speciálních forem, která sama o sobě dostačuje, aby bylo možné vytvořit
plnohodnotný programovací jazyk. Existuje hned několik kombinací těchto
primitivních speciálních forem, například:</p>

<table>
<tr><th>#</th><th>Speciální forma</th></tr>
<tr><td>1</td><td>lambda</td></tr>
<tr><td>2</td><td>define</td></tr>
<tr><td>3</td><td>quote</td></tr>
<tr><td>4</td><td>if</td><tr></tr>
</table>

<p>Alternativní výběr:</p>

<table>
<tr><th>#</th><th>Speciální forma</th></tr>
<tr><td>1</td><td>lambda</td></tr>
<tr><td>2</td><td>define</td></tr>
<tr><td>3</td><td>quote</td></tr>
<tr><td>4</td><td>cond</td><tr></tr>
</table>

<p>Další alternativní výběr:</p>

<table>
<tr><th>#</th><th>Speciální forma</th></tr>
<tr><td>1</td><td>lambda</td></tr>
<tr><td>2</td><td>define</td></tr>
<tr><td>3</td><td>quote</td></tr>
<tr><td>4</td><td>and</td><tr></tr>
<tr><td>5</td><td>or</td><tr></tr>
</table>

<p><div class="rs-tip-major">Poznámka: v&nbsp;poslední tabulce zdánlivě
nenajdeme žádnou speciální formu, kterou by bylo možné použít pro realizaci
rozhodovací konstrukce typu <strong>if</strong> nebo <strong>cond</strong>. Ve
skutečnosti však speciální formy <strong>and</strong> a <strong>or</strong>
používají takzvané <i>zkrácené vyhodnocování výrazů</i> (ostatně proto je nelze
definovat jako běžné  funkce) &ndash; pokud je z&nbsp;již vyhodnocených výrazů
zřejmé, jaký bude výsledek logického součinu nebo součtu, další výrazy se již
nevyhodnocují, i když mohou mít vedlejší efekt.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Rozhraní mezi jazykem C a intepretrem Guile</h2>

<p>Použití samotného interpretru <i>GNU Guile</i> sice může být
v&nbsp;některých případech užitečné (a to nejenom pro účely výuky), ovšem
největší síla tohoto projektu spočívá v&nbsp;tom, že je možné (a to navíc
relativně snadným způsobem) integrovat interpret programovacího jazyka Scheme
do nativních aplikací naprogramovaných například v&nbsp;céčku či C++. Díky tomu
je umožněno vytvářet rozšiřitelné aplikace, což se (pochopitelně tam, kde to
dává smysl) z&nbsp;dlouhodobého hlediska může vyplatit jak samotným tvůrcům
aplikace, tak i jejím uživatelům (zjednodušeně řečeno: každý nový plugin, ať
již ho naprogramoval kdokoli, zajistí zvýšení prestiže aplikace a samozřejmě
pomůže i koncovým uživatelům). Příkladů rozšiřitelných aplikací, které se
mj.&nbsp;i díky této technologii staly úspěšné, je celá řada &ndash; různé CAD
systémy podporující uživatelské pluginy (klasickým příkladem je AutoCAD),
kancelářské balíky taktéž umožňující tvorbu mnohdy i velmi důmyslných pluginů,
rozšiřitelné webové prohlížeče, integrovaná &bdquo;pluginovatelná&ldquo;
vývojová prostředí typu VSCode, mnohé textové editory (<a
href="https://www.root.cz/serialy/textovy-editor-vim-jako-ide/">Vim</a>, <a
href="https://www.root.cz/clanky/atom-moderni-textovy-editor/">Atom</a>)
atd.</p>

<p>Existuje poměrně velké množství programovacích jazyků, které se vkládají
(<i>embed</i>) do aplikací, resp.&nbsp;přesněji řečeno, které jsou pro tento
účel vhodné. V&nbsp;oblasti her se například často setkáme s&nbsp;programovacím
jazykem Lua, kterému jsme se již <a
href="https://www.root.cz/serialy/programovaci-jazyk-lua/">na stránkách Rootu
věnovali</a>. Podobně se, především v&nbsp;novějších aplikacích, setkáme
s&nbsp;vloženým interpretrem <a
href="https://www.root.cz/n/python/">Pythonu</a>, popř.&nbsp;u aplikací
běžících nad JVM (virtuálním strojem Javy) se může jednat o programovací jazyk
<i>Groovy</i> (zde se příliš neujal <i>Jython</i>, který již není aktivně
vyvíjen).</p>

<p>Ve světě GNU se tímto &bdquo;embedded&ldquo; jazykem (<a
href="https://www.gnu.org/software/guile/">alespoň oficiálně</a>) mělo stát
právě Scheme realizované v&nbsp;dnes popisovaném projektu GNU Guile. A
s&nbsp;GNU Guile se skutečně v&nbsp;některých aplikacích setkáme, i když je
nutné říci, že snaha o jeho použití jakožto univerzálního skriptovacího
embedded jazyka nebyla a není stoprocentně úspěšná, a to dokonce ani v&nbsp;tak
klasických GNU projektech, jako je GNOME (Shell), kde by se podobně silný
programovací jazyk mohl dobře uplatnit. Důvodů pro tento stav můžeme najít hned
několik; osobně si ovšem myslím, že tím, jak se i do mainstreamových jazyků
postupně dostávají myšlenky převzaté ze světa LISPu (což je příklad Pythonu,
ale například i výše zmíněného Groovy), se poněkud ztrácí motivace k&nbsp;tomu
LISPovské jazyky používat ve větší míře.</p>

<p>Nicméně i přesto může být zajímavé se podívat na to, jak je vlastně rozhraní
mezí nativními aplikacemi a GNU Guile realizováno. V&nbsp;následujících
kapitolách si ukážeme několik demonstračních příkladů naprogramovaných
v&nbsp;céčku (konkrétně v&nbsp;C99, protože samotné Guile již ANSI C přímo
nepodporuje). Již na úvod si musíme říct, že rozhraní je oboustranné, což
mj.&nbsp;znamená, že céčková aplikace může volat funkci naprogramovanou
v&nbsp;Guile (pochopitelně s&nbsp;předáním parametrů a přebráním výsledné
návratové hodnoty) a naopak funkce naprogramovaná v&nbsp;Guile může volat
céčkovou funkci, opět s&nbsp;předáváním parametrů a návratové hodnoty. Vzhledem
k&nbsp;velkým rozdílům mezi oběma světy je nutné při předávání parametrů
zajistit veškeré potřebné konverze, čímž se v&nbsp;demonstračních příkladech
pochopitelně taktéž budeme zabývat.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Načtení skriptu a zavolání funkce bez parametrů z&nbsp;jazyka C</h2>

<p>První demonstrační příklad, který bude používat rozhraní mezi céčkem a
Guile, bude velmi jednoduchý a jeho činnost lze shrnout do několika bodů:</p>

<ol>

<li>Po spuštění (přeložené a slinkované) nativní aplikace se inicializuje
virtuální stroj GNU Guile.</li>

<li>Následně se načte skript nazvaný &bdquo;script1.scm&ldquo;. Tento skript
obsahuje jedinou funkci pojmenovanou <strong>say-hello</strong>.</li>

<li>V&nbsp;nativní aplikaci se vytvoří struktura obsahující (mimo dalších věcí)
i vstupní bod do výše zmíněné funkce <strong>say-hello</strong>.</li>

<li>Funkce naprogramovaná v&nbsp;GNU Guile se zavolá a jelikož nemá žádné
parametry, bude její zavolání realizováno nativní funkcí
<strong></strong>.</li>

<li>Po ukončení funkce <strong></strong> se řízení předá zpět nativní aplikaci.
Případná návratová hodnota je ignorována.</li>

</ol>

<p></p>

<p>Pro zavolání funkce definované v&nbsp;Guile z&nbsp;céčka je možné použít
následující nativní funkce, kterým se předá jak reference na volanou funkci,
tak i argumenty:</p>

<pre>
SCM <strong>scm_call_1</strong>(SCM proc, SCM arg1);
SCM <strong>scm_call_2</strong>(SCM proc, SCM arg1, SCM arg2);
SCM <strong>scm_call_3</strong>(SCM proc, SCM arg1, SCM arg2, SCM arg3);
SCM <strong>scm_call_4</strong>(SCM proc, SCM arg1, SCM arg2, SCM arg3, SCM arg4);
</pre>

<p>Část příkladu naprogramovaná v&nbsp;GNU Guile vypadá následovně:</p>

<pre>
(define (say-hello)
  (display "Hello world!"))
</pre>

<p>Samozřejmě si ukážeme i delší část vytvořenou v&nbsp;jazyku C:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;libguile.h&gt;
&nbsp;
int main( int argc, char **arg )
{
    SCM function;
&nbsp;
    scm_init_guile();
&nbsp;
    scm_c_primitive_load("script1.scm");
&nbsp;
    function = scm_variable_ref(scm_c_lookup("say-hello"));
&nbsp;
    scm_call_0(function);
&nbsp;
    return 0;
}
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si způsobu načtení skriptu i
nalezení reference na volanou funkci.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Překlad, slinkování a spuštění demonstračního příkladu</h2>

<p><div class="rs-tip-major">Poznámka: v&nbsp;příkladech budeme používat Guile
verze 2.0, ovšem úprava pro verzi 2.2 bude triviální.</div></p>

<p>Při překladu a linkování nativní části dnešního prvního demonstračního
příkladu budeme muset vyřešit jeden nepatrný problém &ndash; hlavičkový soubor
knihovny <strong>guile</strong> a někdy ani vlastní knihovna neleží v&nbsp;těch
adresářích, kde je očekává překladač céčka a linker. Příslušné cesty tedy
budeme muset nějakým způsobem zjistit a předat je překladači (volba
<strong>-I</strong>) a linkeru (volba <strong>-l</strong>). Pro tento účel je
možné použít užitečný nástroj <strong>pkg-config</strong>, který příslušné
cesty (a ovšem i další přepínače) dokáže zjistit a použít. Nástroj
<strong>pkg-config</strong> spustíme celkem dvakrát: jednou pro zjištění cesty
k&nbsp;hlavičkovým souborům a podruhé pro zjištění cesty ke knihovně,
s&nbsp;níž se má naše aplikace slinkovat:</p>

<table>
<tr><th>Příkaz</th><th>Význam</th></tr>
<tr><td>pkg-config --cflags-only-I guile-2.0</td><td>vrátí cestu k&nbsp;hlavičkovým souborům</td></tr>
<tr><td>pkg-config --libs guile-2.0</td><td>vrátí cestu ke knihovně včetně jména knihovny</td></tr>
</table>

<p>Celý překlad a slinkování by měl vypadat následovně:</p>

<pre>
gcc `pkg-config --cflags-only-I guile-2.0` `pkg-config --libs guile-2.0` test1.c -o test1
</pre>

<p>Namísto jednoúčelového skriptu určeného pouze pro překlad a slinkování
příkladu si samozřejmě můžeme vytvořit plnohodnotný soubor
<strong>Makefile</strong>, jehož předností je snadná rozšiřitelnost. Jedna
z&nbsp;možných forem takového souboru je zobrazena pod tímto odstavcem:</p>

<pre>
CC=gcc
&nbsp;
CFLAGS=-Wall -std=c99 -pedantic `pkg-config --cflags-only-I guile-2.0`
&nbsp;
LIBS=`pkg-config --libs guile-2.0`
&nbsp;
EXENAME=test1
&nbsp;
all:    ${EXENAME}
&nbsp;
clean:
        rm -f test1.o
        rm -f ${EXENAME}
&nbsp;
${EXENAME}:     test1.o
        ${CC} $&lt; ${LIBS} -o $@
&nbsp;
test1.o:        test1.c
        ${CC} -c $&lt; ${CFLAGS}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Zavolání funkce se dvěma parametry a zpracování návratové hodnoty</h2>

<p>Ve druhém příkladu si ukážeme způsob volání funkce se dvěma parametry:</p>

<pre>
(define (multiply x y)
  (* x y))
</pre>

<p>Tuto funkci budeme muset z&nbsp;céčka zavolat pomocí:</p>

<pre>
SCM <strong>scm_call_2</strong>(SCM proc, SCM arg1, SCM arg2);
</pre>

<p>Návratová hodnota ze <strong>scm_call_2</strong> ovšem není přímo výsledek
funkce v&nbsp;Guile, ale obalová struktura. Pro konverzi se použije konverzní
funkce <strong>scm_to_int</strong>:</p>

<pre>
return_value = scm_call_2(function, scm_from_int(6), scm_from_int(7));
integer_result = scm_to_int(return_value);
</pre>

<p>Úplný kód druhého demonstračního příkladu vypadá takto:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;libguile.h&gt;
&nbsp;
int main( int argc, char **arg )
{
    SCM function, return_value;
    int integer_result;
&nbsp;
    scm_init_guile();
&nbsp;
    scm_c_primitive_load("script2.scm");
&nbsp;
    function = scm_variable_ref(scm_c_lookup("multiply"));
&nbsp;
    return_value = scm_call_2(function, scm_from_int(6), scm_from_int(7));
&nbsp;
    integer_result = scm_to_int(return_value);
&nbsp;
    printf("result: %d\n", integer_result);
&nbsp;
    return 0;
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Předání řetězce do skriptu naprogramovaného v&nbsp;Guile</h2>

<p>Velmi často je taktéž nutné do Guile předávat řetězce, například do
následující funkce určené pro vytištění předaného řetězce na terminál:</p>

<pre>
(define (print-message message)
  (begin
      (display message)
      (newline)))
</pre>

<p>Jedno z&nbsp;možných řešení spočívá v&nbsp;použití konverzní funkce
<strong>scm_from_utf8_string</strong>:</p>

<pre>
scm_from_utf8_string("Hello world!")
</pre>

<p>Další část příkladu je prakticky stejná, jako u příkladu prvního:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;libguile.h&gt;
&nbsp;
int main( int argc, char **arg )
{
    SCM function;
&nbsp;
    scm_init_guile();
&nbsp;
    scm_c_primitive_load("script3.scm");
&nbsp;
    function = scm_variable_ref(scm_c_lookup("print-message"));
&nbsp;
    scm_call_1(function, scm_from_utf8_string("Hello world!"));
&nbsp;
    return 0;
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Zavolání céčkovské (nativní) funkce z&nbsp;Guile</h2>

<p>Prozatím jsme z&nbsp;céčka volali funkce naprogramované v&nbsp;Guile. Ovšem
možný je pochopitelně i opačný postup, kdy budeme potřebovat zavolat nativní
funkci z&nbsp;Guile:</p>

<pre>
(define (call-factorial number)
    (c-factorial number))
</pre>

<p>Zde by měla být <strong>c-factorial</strong> nativní funkce pro výpočet
faktoriálu (rekurzivně, v&nbsp;céčku bez tail rekurze):</p>

<pre>
long <strong>factorial</strong>(long n)
{
    if (n&lt;=1) {
        return 1;
    } else {
        return n * factorial(n-1);
    }
}
</pre>

<p>Ve skutečnosti ovšem provedeme mezikrok, kdy v&nbsp;nové nativní funkci
<strong>c_factorial</strong> zkonvertujeme parametry a následně i vypočtenou
návratovou hodnotu:</p>

<pre>
SCM <strong>c_factorial</strong>(SCM arg)
{
    long c_arg = scm_to_long(arg);
    long result = factorial(c_arg);
    printf("%ld! = %ld\n", c_arg, result);
    return scm_from_int(result);
}
</pre>

<p>Tuto funkci budeme muset zaregistrovat, aby ji interpret Guile našel:</p>

<pre>
scm_c_define_gsubr("c-factorial", 1, 0, 0, (void*)c_factorial);
</pre>

<p>Úplný zdrojový kód dnešního čtvrtého demonstračního příkladu vypadá
následovně:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;libguile.h&gt;
&nbsp;
long factorial(long n)
{
    if (n&lt;=1) {
        return 1;
    } else {
        return n * factorial(n-1);
    }
}
&nbsp;
SCM c_factorial(SCM arg)
{
    long c_arg = scm_to_long(arg);
    long result = factorial(c_arg);
    printf("%ld! = %ld\n", c_arg, result);
    return scm_from_int(result);
}
&nbsp;
int main( int argc, char **arg )
{
    SCM function;
    int n;
&nbsp;
    scm_init_guile();
&nbsp;
    scm_c_primitive_load("script4.scm");
    scm_c_define_gsubr("c-factorial", 1, 0, 0, (void*)c_factorial);
&nbsp;
    function = scm_variable_ref(scm_c_lookup("call-factorial"));
&nbsp;
    for (n=0; n&lt;=10; n++) {
        scm_call_1(function, scm_from_int(n));
    }
&nbsp;
    return 0;
}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Skript uložený přímo ve zdrojovém kódu ve formě řetězce</h2>

<p>V&nbsp;některých případech může být výhodné mít kratší skript naprogramovaný
v&nbsp;Guile reprezentovaný céčkovým řetězcem popř.&nbsp;si dokonce můžeme
skript &bdquo;složit&ldquo; z&nbsp;nějaké šablony, použít funkci
<strong>printf</strong> atd. atd. Jak se takový skript spustí je ukázáno
v&nbsp;dnešním pátém demonstračním příkladu:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;libguile.h&gt;
&nbsp;
const char *script = "(define (say-hello)\n"\
                     "  (display \"Hello world!\"))";
&nbsp;
int main( int argc, char **arg )
{
    SCM function;
&nbsp;
    scm_init_guile();
&nbsp;
    scm_c_eval_string(script);
&nbsp;
    function = scm_variable_ref(scm_c_lookup("say-hello"));
&nbsp;
    scm_call_0(function);
&nbsp;
    return 0;
}
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Předání tečka dvojice do skriptu vytvořeného v&nbsp;Guile</h2>

<p>Základními strukturovanými datovými typy jazyka Scheme jsou tečka-dvojice,
seznamy a taktéž vektory. Poměrně často je nutné tyto datové struktury vytvářet
v&nbsp;céčku a předávat je do Guile. Nejdříve si ukážeme způsob vytvoření
tečka-dvojice, kterou následně zpracujeme tímto skriptem:</p>

<pre>
(define (print-pair pair)
  (begin
      (display pair)
      (newline)
      (display (* (car pair) (cdr pair)))
      (newline)))
</pre>

<p>Před vytvořením tečka dvojice zkonstruujeme dvojici hodnot (používáme zde
historická jména <strong>car</strong> a <strong>cdr</strong>):</p>

<pre>
SCM s_car = scm_from_int(6);
SCM s_cdr = scm_from_int(7);
</pre>

<p>Následně funkcí <strong>scm_cons</strong> tečka dvojici zkonstruujeme:</p>

<pre>
SCM s_pair = scm_cons(s_car, s_cdr);
</pre>

<p>S&nbsp;takto obalenou hodnotou se již pracuje stejně, jako s&nbsp;jakoukoli
jinou hodnotou, kterou do Guile potřebujeme předat:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;libguile.h&gt;
&nbsp;
int main( int argc, char **arg )
{
    SCM function;
&nbsp;
    scm_init_guile();
&nbsp;
    SCM s_car = scm_from_int(6);
    SCM s_cdr = scm_from_int(7);
    SCM s_pair = scm_cons(s_car, s_cdr);
&nbsp;
    scm_c_primitive_load("script6.scm");
&nbsp;
    function = scm_variable_ref(scm_c_lookup("print-pair"));
&nbsp;
    scm_call_1(function, s_pair);
&nbsp;
    return 0;
}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Konstrukce seznamu a vektoru v&nbsp;céčku s&nbsp;jeho předáním do Guile</h2>

<p>Poněkud složitější bude konstrukce seznamu, jenž budeme chtít zpracovat
následujícím skriptem, který zobrazí délku seznamu i jeho obsah (v&nbsp;podobě
čitelné člověkem):</p>

<pre>
(define (print-list lst)
  (begin
      (display (length lst))
      (newline)
      (display lst)
      (newline)))
</pre>

<p>Nejprve vytvoříme prázdný seznam přestavovaný &bdquo;zarážkou&ldquo;
<strong>SCM_EOL</strong>:</p>

<pre>
SCM result_list = SCM_EOL;
</pre>

<p>Následně v&nbsp;programové smyčce vytvoříme jednotlivé elementy seznamu,
převedeme je na jednoprvkové seznamy a funkcí <strong>scm_append</strong> je
připojíme k&nbsp;postupně vznikajícímu výslednému seznamu:</p>

<pre>
for (i = 0; i &lt; 100; i++) {
    SCM element = scm_from_int(i);
    SCM one_element_list = scm_list_1(element);
    result_list = scm_append(scm_list_2(result_list, one_element_list));
}
</pre>

<p>Úplný zdrojový kód dnešního předposledního demonstračního příkladu vypadá
takto:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;libguile.h&gt;
&nbsp;
int main( int argc, char **arg )
{
    SCM function;
    SCM result_list = SCM_EOL;
    int i;
&nbsp;
    scm_init_guile();
&nbsp;
    for (i = 0; i &lt; 100; i++) {
        SCM element = scm_from_int(i);
        SCM one_element_list = scm_list_1(element);
        result_list = scm_append(scm_list_2(result_list, one_element_list));
    }
&nbsp;
    scm_c_primitive_load("script7.scm");
&nbsp;
    function = scm_variable_ref(scm_c_lookup("print-list"));
&nbsp;
    scm_call_1(function, result_list);
&nbsp;
    return 0;
}
</pre>

<p><div class="rs-tip-major">Poznámka: seznam i vektor lze v&nbsp;případě
potřeby vytvořit i z&nbsp;céčkovského pole.</div></p>

<p>Dnešní poslední demonstrační příklad pracuje s&nbsp;vektory, jejichž délka
je neměnitelná a musí být známá při jejich konstrukci (z&nbsp;tohoto pohledu
jsou tedy vektory podobné běžně chápaným polím):</p>

<pre>
(define (print-vector lst)
  (begin
      (display (vector-length lst))
      (newline)
      (display lst)
      (newline)))
</pre>

<p>Prázdný vektor se zkonstruuje funkcí <strong>scm_c_make_vector</strong>,
které se předá počet prvků:</p>

<pre>
SCM vector = scm_c_make_vector(100, scm_from_int(0));
</pre>

<p>Následně již můžeme naplnit hodnoty jednotlivých prvků (prvky se nevytváří,
na rozdíl od seznamů):</p>

<pre>
for (i = 0; i &lt; 100; i++) {
    SCM element = scm_from_int(i);
    scm_vector_set_x(vector, scm_from_int(i), element);
}
</pre>

<p>Celý zdrojový kód příkladu je vypsán pod tímto odstavcem:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;libguile.h&gt;
&nbsp;
int main( int argc, char **arg )
{
    SCM function;
    int i;
&nbsp;
    scm_init_guile();
&nbsp;
    SCM vector = scm_c_make_vector(100, scm_from_int(0));
&nbsp;
    for (i = 0; i &lt; 100; i++) {
        SCM element = scm_from_int(i);
        scm_vector_set_x(vector, scm_from_int(i), element);
    }
&nbsp;
    scm_c_primitive_load("script8.scm");
&nbsp;
    function = scm_variable_ref(scm_c_lookup("print-vector"));
&nbsp;
    scm_call_1(function, vector);
&nbsp;
    return 0;
}
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/lisp-families.git">https://github.com/tisnik/lisp-families.git</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, můžete
namísto toho použít odkazy na jednotlivé příklady, které naleznete
v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>dot_pairs.scm</td><td>konstrukce tečka dvojic</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/examples/dot_pairs.scm">https://github.com/tisnik/lisp-families/blob/master/examples/dot_pairs.scm</a></td></tr>
<tr><td> 2</td><td>cons.scm</td><td>funkce <strong>cons</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/examples/cons.scm">https://github.com/tisnik/lisp-families/blob/master/examples/cons.scm</a></td></tr>
<tr><td> 3</td><td>lists.scm</td><td>práce se seznamy</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/examples/lists.scm">https://github.com/tisnik/lisp-families/blob/master/examples/lists.scm</a></td></tr>
<tr><td> 4</td><td>functions.scm</td><td>deklarace a volání funkcí</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/examples/functions.scm">https://github.com/tisnik/lisp-families/blob/master/examples/functions.scm</a></td></tr>
<tr><td> 5</td><td>factorial_1.scm</td><td>rekurzivní výpočet faktoriálu, první varianta</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/examples/factorial_1.scm">https://github.com/tisnik/lisp-families/blob/master/examples/factorial_1.scm</a></td></tr>
<tr><td> 6</td><td>factorial_2.scm</td><td>rekurzivní výpočet faktoriálu, druhá varianta</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/examples/factorial_2.scm">https://github.com/tisnik/lisp-families/blob/master/examples/factorial_2.scm</a></td></tr>
<tr><td> 7</td><td>factorial_3.scm</td><td>tail rekurze při výpočtu faktoriálu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/examples/factorial_3.scm">https://github.com/tisnik/lisp-families/blob/master/examples/factorial_3.scm</a></td></tr>
<tr><td> 8</td><td>lexical_scope_1.scm</td><td>lexikální oblast platnosti proměnných, příklad 1</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/examples/lexical_scope_1.scm">https://github.com/tisnik/lisp-families/blob/master/examples/lexical_scope_1.scm</a></td></tr>
<tr><td> 9</td><td>lexical_scope_2.scm</td><td>lexikální oblast platnosti proměnných, příklad 2</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/examples/lexical_scope_2.scm">https://github.com/tisnik/lisp-families/blob/master/examples/lexical_scope_2.scm</a></td></tr>
<tr><td>10</td><td>lexical_scope_3.scm</td><td>lexikální oblast platnosti proměnných, příklad 3</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/examples/lexical_scope_3.scm">https://github.com/tisnik/lisp-families/blob/master/examples/lexical_scope_3.scm</a></td></tr>
<tr><td>11</td><td>lexical_scope_4.scm</td><td>lexikální oblast platnosti proměnných, příklad 4</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/examples/lexical_scope_4.scm">https://github.com/tisnik/lisp-families/blob/master/examples/lexical_scope_4.scm</a></td></tr>
<tr><td>12</td><td>closure_1.scm</td><td>uzávěry, příklad 1</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/examples/closure_1.scm">https://github.com/tisnik/lisp-families/blob/master/examples/closure_1.scm</a></td></tr>
<tr><td>13</td><td>closure_2.scm</td><td>uzávěry, příklad 2</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/examples/closure_2.scm">https://github.com/tisnik/lisp-families/blob/master/examples/closure_2.scm</a></td></tr>
<tr><td>14</td><td>closure_3.scm</td><td>uzávěry, příklad 3</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/examples/closure_3.scm">https://github.com/tisnik/lisp-families/blob/master/examples/closure_3.scm</a></td></tr>
<tr><td>15</td><td>closure_4.scm</td><td>uzávěry, příklad 4</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/examples/closure_4.scm">https://github.com/tisnik/lisp-families/blob/master/examples/closure_4.scm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>test1</td><td>C a Guile: načtení skriptu a zavolání funkce bez parametrů</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/c-interface/test1/">https://github.com/tisnik/lisp-families/blob/master/c-interface/test1/</a></td></tr>
<tr><td>17</td><td>test2</td><td>C a Guile: zavolání funkce se dvěma parametry a zpracování návratové hodnoty</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/c-interface/test2/">https://github.com/tisnik/lisp-families/blob/master/c-interface/test2/</a></td></tr>
<tr><td>18</td><td>test3</td><td>C a Guile: předání řetězce</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/c-interface/test3/">https://github.com/tisnik/lisp-families/blob/master/c-interface/test3/</a></td></tr>
<tr><td>19</td><td>test4</td><td>C a Guile: zavolání céčkovské (nativní) funkce z&nbsp;Guile</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/c-interface/test4/">https://github.com/tisnik/lisp-families/blob/master/c-interface/test4/</a></td></tr>
<tr><td>20</td><td>test5</td><td>C a Guile: skript uložený přímo ve zdrojovém kódu ve formě řetězce</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/c-interface/test5/">https://github.com/tisnik/lisp-families/blob/master/c-interface/test5/</a></td></tr>
<tr><td>21</td><td>test6</td><td>C a Guile: předání tečka dvojice do skriptu vytvořeného v&nbsp;Guile</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/c-interface/test6/">https://github.com/tisnik/lisp-families/blob/master/c-interface/test6/</a></td></tr>
<tr><td>22</td><td>test7</td><td>C a Guile: konstrukce seznamu s&nbsp;jeho předáním do Guile</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/c-interface/test7/">https://github.com/tisnik/lisp-families/blob/master/c-interface/test7/</a></td></tr>
<tr><td>23</td><td>test8</td><td>C a Guile: konstrukce vektoru v&nbsp;céčku s&nbsp;jeho předáním do Guile</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/c-interface/test8/">https://github.com/tisnik/lisp-families/blob/master/c-interface/test8/</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Literatura</h2>

<ol>

<li>Peter Seibel<br />
<i>&bdquo;Practical Common Lisp&ldquo;</i><br />
2009
</li>

<li>Paul Graham<br />
<i>&bdquo;ANSI Common Lisp&ldquo;</i><br />
1995
</li>

<li>Gerald Gazdar<br />
<i>&bdquo;Natural Language Processing in Lisp: An Introduction to Computational Linguistics&ldquo;</i><br />
1989
</li>

<li>Peter Norvig<br />
<i>&bdquo;Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp&ldquo;</i><br />
1991
</li>

<li>Alex Mileler et.al.<br />
<i>&bdquo;Clojure Applied: From Practice to Practitioner&ldquo;</i><br />
2015
</li>

<li>
<i>&bdquo;Living Clojure: An Introduction and Training Plan for Developers&ldquo;</i><br />
2015
</li>

<li>Dmitri Sotnikov<br />
<i>&bdquo;Web Development with Clojure: Build Bulletproof Web Apps with Less Code&ldquo;</i><br />
2016
</li>

<li>McCarthy<br />
<i>&bdquo;Recursive functions of symbolic expressions and their computation by machine, part I&ldquo;</i><br />
1960
</li>

<li>R. Kent Dybvig<br />
<i>&bdquo;The Scheme Programming Language&ldquo;</i><br />
2009
</li>

<li>Max Hailperin<br />
<i>&bdquo;Concrete Abstractions&ldquo;</i><br />
1998
</li>

<li>Guy L. Steele<br />
<i>&bdquo;History of Scheme&ldquo;</i><br />
2006, Sun Microsystems Laboratories
</li>

<li>Kolář J., Muller K.:<br />
<i>&bdquo;Speciální programovací jazyky&ldquo;</i><br />
Praha 1981
</li>

<li>
<i>&bdquo;AutoLISP Release 9, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., October 1987
</li>

<li>
<i>&bdquo;AutoLISP Release 10, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., September 1988
</li>

<li>McCarthy, John; Abrahams, Paul W.; Edwards, Daniel J.; Hart, Timothy P.; Levin, Michael I.<br />
<i>&bdquo;LISP 1.5 Programmer's Manual&ldquo;</i><br />
MIT Press. ISBN 0 262 130 1 1 4
</li>

<li>Carl Hewitt; Peter Bishop and Richard Steiger<br />
<i>&bdquo;A Universal Modular Actor Formalism for Artificial Intelligence&ldquo;</i><br />
1973
</li>

<li>Feiman, J.<br />
<i>&bdquo;The Gartner Programming Language Survey (October 2001)&ldquo;</i><br />
Gartner Advisory
</li>

<li>Harold Abelson, Gerald Jay Sussman, Julie Sussman:<br />
<i>Structure and Interpretation of Computer Programs</i><br />
MIT Press. 1985, 1996 (a možná vyšel i další přetisk)
</li>

<li>Paul Graham<br />
<i>On Lisp</i><br />
Prentice Hall, 1993<br />
Dostupné online na stránce <a href="http://www.paulgraham.com/onlisptext.html">http://www.paulgraham.com/onlisptext.html</a>
</li>

<li>David S. Touretzky<br />
<i>Common LISP: A Gentle Introduction to Symbolic Computation (Dover Books on Engineering)</i><br />
</li>

<li>Peter Norvig<br />
<i>Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp</i>
</li>

<li>Patrick Winston, Berthold Horn<br />
<i>Lisp (3rd Edition)</i><br />
ISBN-13: 978-0201083194, ISBN-10: 0201083191
</li>

<li>Matthias Felleisen, David Van Horn, Dr. Conrad Barski<br>
<i>Realm of Racket: Learn to Program, One Game at a Time!</i><br />
ISBN-13: 978-1593274917, ISBN-10: 1593274912 
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Scheme Quick Reference<br />
<a href="https://www.st.cs.uni-saarland.de/edu/config-ss04/scheme-quickref.pdf">https://www.st.cs.uni-saarland.de/edu/config-ss04/scheme-quickref.pdf</a>
</li>

<li>Slajdy o Scheme (od slajdu číslo 15)<br />
<a href="https://docs.google.com/presentation/d/1abmDnKjrq1tcjGvvRNAKhOiSTSE2lyagtcEPal07Gbo/edit">https://docs.google.com/presentation/d/1abmDnKjrq1tcjGvvRNAKhOiSTSE2lyagtcEPal07Gbo/edit</a>
</li>

<li>Scheme Cheat Sheet<br />
<a href="https://github.com/smythp/scheme-cheat-sheet">https://github.com/smythp/scheme-cheat-sheet</a>
</li>

<li>Embedding Lua, embedding Guile <br />
<a href="http://puntoblogspot.blogspot.com/2013/04/embedding-lua-embedding-guile.html">http://puntoblogspot.blogspot.com/2013/04/embedding-lua-embedding-guile.html</a>
</li>

<li>Lambda Papers<br />
<a href="https://en.wikisource.org/wiki/Lambda_Papers">https://en.wikisource.org/wiki/Lambda_Papers</a>
</li>

<li>Revised<sup>7</sup>Report on the Algorithmic Language Scheme<br />
<a href="https://small.r7rs.org/attachment/r7rs.pdf">https://small.r7rs.org/attachment/r7rs.pdf</a>
</li>

<li>Video Lectures (MIT, SICP 2005)<br />
<a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/</a>
</li>

<li>Why is Scheme my first language in university?<br />
<a href="https://softwareengineering.stackexchange.com/questions/115252/why-is-scheme-my-first-language-in-university">https://softwareengineering.stackexchange.com/questions/115252/why-is-scheme-my-first-language-in-university</a>
</li>

<li>The Perils of JavaSchools<br />
<a href="https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/">https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/</a>
</li>

<li>How to Design Programs, Second Edition<br />
<a href="https://htdp.org/2019-02-24/index.html">https://htdp.org/2019-02-24/index.html</a>
</li>

<li>LilyPond<br />
<a href="http://lilypond.org/">http://lilypond.org/</a>
</li>

<li>LilyPond — Extending (přes Scheme)<br />
<a href="http://lilypond.org/doc/v2.18/Documentation/extending/scheme-tutorial">http://lilypond.org/doc/v2.18/Documentation/extending/scheme-tutorial</a>
</li>

<li>Scheme in LilyPond<br />
<a href="http://lilypond.org/doc/v2.18/Documentation/extending/scheme-in-lilypond">http://lilypond.org/doc/v2.18/Documentation/extending/scheme-in-lilypond</a>
</li>

<li>GnuCash<br />
<a href="http://www.gnucash.org/">http://www.gnucash.org/</a>
</li>

<li>Custom Reports (in GNU Cash)<br />
<a href="https://wiki.gnucash.org/wiki/Custom_Reports">https://wiki.gnucash.org/wiki/Custom_Reports</a>
</li>

<li>Program by Design<br />
<a href="https://programbydesign.org/">https://programbydesign.org/</a>
</li>

<li>SchemePy<br />
<a href="https://pypi.org/project/SchemePy/">https://pypi.org/project/SchemePy/</a>
</li>

<li>LISP FQA: Section - [1-5] What is the "minimal" set of primitives needed for a Lisp interpreter?<br />
<a href="http://www.faqs.org/faqs/lisp-faq/part1/section-6.html">http://www.faqs.org/faqs/lisp-faq/part1/section-6.html</a>
</li>

<li>femtolisp<br />
<a href="https://github.com/JeffBezanson/femtolisp">https://github.com/JeffBezanson/femtolisp</a>
</li>

<li>(How to Write a (Lisp) Interpreter (in Python))<br />
<a href="http://norvig.com/lispy.html">http://norvig.com/lispy.html</a>
</li>

<li>Repositář s&nbsp;Guile Emacsem<br />
<a href="http://git.hcoop.net/?p=bpt/guile.git">http://git.hcoop.net/?p=bpt/guile.git</a>
</li>

<li>Interacting with Guile Compound Data Types in C<br />
<a href="http://www.lonelycactus.com/guilebook/x1555.html">http://www.lonelycactus.com/guilebook/x1555.html</a>
</li>

<li>Calling Guile functions from C<br />
<a href="http://www.lonelycactus.com/guilebook/c1204.html#SECCALLGUILEFUNC">http://www.lonelycactus.com/guilebook/c1204.html#SECCALLGUILEFUNC</a>
</li>

<li>Arrays, and other compound data types<br />
<a href="http://www.lonelycactus.com/guilebook/charrays.html">http://www.lonelycactus.com/guilebook/charrays.html</a>
</li>

<li>Interacting with Guile Compound Data Types in C<br />
<a href="http://www.lonelycactus.com/guilebook/x1555.html">http://www.lonelycactus.com/guilebook/x1555.html</a>
</li>

<li>Guile Reference Manual<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/index.html">https://www.gnu.org/software/guile/manual/html_node/index.html</a>
</li>

<li>Scheme: Summary of Common Syntax<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/Syntax-Summary.html#Syntax-Summary">https://www.gnu.org/software/guile/manual/html_node/Syntax-Summary.html#Syntax-Summary</a>
</li>

<li>Scripting with Guile: Extension language enhances C and Scheme<br />
<a href="https://www.ibm.com/developerworks/library/l-guile/index.html">https://www.ibm.com/developerworks/library/l-guile/index.html</a>
</li>

<li>Having fun with Guile: a tutorial<br />
<a href="http://dustycloud.org/misc/guile-tutorial.html">http://dustycloud.org/misc/guile-tutorial.html</a>
</li>

<li>Guile: Loading Readline Support<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/Loading-Readline-Support.html#Loading-Readline-Support">https://www.gnu.org/software/guile/manual/html_node/Loading-Readline-Support.html#Loading-Readline-Support</a>
</li>

<li>lispy<br />
<a href="https://pypi.org/project/lispy/">https://pypi.org/project/lispy/</a>
</li>

<li>Lython<br />
<a href="https://pypi.org/project/Lython/">https://pypi.org/project/Lython/</a>
</li>

<li>Lizpop<br />
<a href="https://pypi.org/project/lizpop/">https://pypi.org/project/lizpop/</a>
</li>

<li>Budoucnost programovacích jazyků<br />
<a href="http://www.knesl.com/budoucnost-programovacich-jazyku">http://www.knesl.com/budoucnost-programovacich-jazyku</a>
</li>

<li>LISP Prolog and Evolution<br />
<a href="http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html">http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html</a>
</li>

<li>List of Lisp-family programming languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages">https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages</a>
</li>

<li>clojure_py na indexu PyPi<br />
<a href="https://pypi.python.org/pypi/clojure_py">https://pypi.python.org/pypi/clojure_py</a>
</li>

<li>PyClojure<br />
<a href="https://github.com/eigenhombre/PyClojure">https://github.com/eigenhombre/PyClojure</a>
</li>

<li>Hy na GitHubu<br />
<a href="https://github.com/hylang/hy">https://github.com/hylang/hy</a>
</li>

<li>Hy: The survival guide<br />
<a href="https://notes.pault.ag/hy-survival-guide/">https://notes.pault.ag/hy-survival-guide/</a>
</li>

<li>Hy běžící na monitoru terminálu společnosti Symbolics<br />
<a href="http://try-hy.appspot.com/">http://try-hy.appspot.com/</a>
</li>

<li>Welcome to Hy’s documentation!<br />
<a href="http://docs.hylang.org/en/stable/">http://docs.hylang.org/en/stable/</a>
</li>

<li>Hy na PyPi<br />
<a href="https://pypi.org/project/hy/#description">https://pypi.org/project/hy/#description</a>
</li>

<li>Getting Hy on Python<br />
<a href="https://lwn.net/Articles/596626/">https://lwn.net/Articles/596626/</a>
</li>

<li>Programming Can Be Fun with Hy<br />
<a href="https://opensourceforu.com/2014/02/programming-can-fun-hy/">https://opensourceforu.com/2014/02/programming-can-fun-hy/</a>
</li>

<li>Přednáška o projektu Hy (pětiminutový lighttalk)<br />
<a href="http://blog.pault.ag/day/2013/04/02">http://blog.pault.ag/day/2013/04/02</a>
</li>

<li>Hy (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Hy">https://en.wikipedia.org/wiki/Hy</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Point<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Point.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Point.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Narrowing<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Narrowing.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Narrowing.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Functions that Create Markers<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Markers.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Markers.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Motion<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Motion.html#Motion">https://www.gnu.org/software/emacs/manual/html_node/elisp/Motion.html#Motion</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Basic Char Syntax<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Char-Syntax.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Char-Syntax.html</a>
</li>

<li>Elisp: Sequence: List, Array<br />
<a href="http://ergoemacs.org/emacs/elisp_list_vs_vector.html">http://ergoemacs.org/emacs/elisp_list_vs_vector.html</a>
</li>

<li>Elisp: Property List<br />
<a href="http://ergoemacs.org/emacs/elisp_property_list.html">http://ergoemacs.org/emacs/elisp_property_list.html</a>
</li>

<li>Elisp: Hash Table<br />
<a href="http://ergoemacs.org/emacs/elisp_hash_table.html">http://ergoemacs.org/emacs/elisp_hash_table.html</a>
</li>

<li>Elisp: Association List<br />
<a href="http://ergoemacs.org/emacs/elisp_association_list.html">http://ergoemacs.org/emacs/elisp_association_list.html</a>
</li>

<li>The mapcar Function (An Introduction to Programming in Emacs Lisp)<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/mapcar.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/mapcar.html</a>
</li>

<li>Anaphoric macro<br />
<a href="https://en.wikipedia.org/wiki/Anaphoric_macro">https://en.wikipedia.org/wiki/Anaphoric_macro</a>
</li>

<li>Some Common Lisp Loop Macro Examples<br />
<a href="https://www.youtube.com/watch?v=3yl8o6r_omw">https://www.youtube.com/watch?v=3yl8o6r_omw</a>
</li>

<li>A Guided Tour of Emacs<br />
<a href="https://www.gnu.org/software/emacs/tour/">https://www.gnu.org/software/emacs/tour/</a>
</li>

<li>The Roots of Lisp<br />
<a href="http://www.paulgraham.com/rootsoflisp.html">http://www.paulgraham.com/rootsoflisp.html</a>
</li>

<li>Evil (Emacs Wiki)<br />
<a href="https://www.emacswiki.org/emacs/Evil">https://www.emacswiki.org/emacs/Evil</a>
</li>

<li>Evil (na GitHubu)<br />
<a href="https://github.com/emacs-evil/evil">https://github.com/emacs-evil/evil</a>
</li>

<li>Evil (na stránkách repositáře MELPA)<br />
<a href="https://melpa.org/#/evil">https://melpa.org/#/evil</a>
</li>

<li>Evil Mode: How I Switched From VIM to Emacs<br />
<a href="https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html">https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html</a>
</li>

<li>GNU Emacs (home page)<br />
<a href="https://www.gnu.org/software/emacs/">https://www.gnu.org/software/emacs/</a>
</li>

<li>GNU Emacs (texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs">http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs</a>
</li>

<li>An Introduction To Using GDB Under Emacs<br />
<a href="http://tedlab.mit.edu/~dr/gdbintro.html">http://tedlab.mit.edu/~dr/gdbintro.html</a>
</li>

<li>An Introduction to Programming in Emacs Lisp<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html</a>
</li>

<li>27.6 Running Debuggers Under Emacs<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html">https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html</a>
</li>

<li>GdbMode<br />
<a href="http://www.emacswiki.org/emacs/GdbMode">http://www.emacswiki.org/emacs/GdbMode</a>
</li>

<li>Emacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Emacs">https://en.wikipedia.org/wiki/Emacs</a>
</li>

<li>Emacs timeline<br />
<a href="http://www.jwz.org/doc/emacs-timeline.html">http://www.jwz.org/doc/emacs-timeline.html</a>
</li>

<li>Emacs Text Editors Family<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?EmacsFamily">http://texteditors.org/cgi-bin/wiki.pl?EmacsFamily</a>
</li>

<li>Vrapper aneb spojení možností Vimu a Eclipse<br />
<a href="https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse/">https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse/</a>
</li>

<li>Vrapper aneb spojení možností Vimu a Eclipse (část 2: vyhledávání a nahrazování textu)<br />
<a href="https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse-cast-2-vyhledavani-a-nahrazovani-textu/">https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse-cast-2-vyhledavani-a-nahrazovani-textu/</a>
</li>

<li>Emacs/Evil-mode - A basic reference to using evil mode in Emacs<br />
<a href="http://www.aakarshnair.com/posts/emacs-evil-mode-cheatsheet">http://www.aakarshnair.com/posts/emacs-evil-mode-cheatsheet</a>
</li>

<li>From Vim to Emacs+Evil chaotic migration guide<br />
<a href="https://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/">https://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/</a>
</li>

<li>Introduction to evil-mode {video)<br />
<a href="https://www.youtube.com/watch?v=PeVQwYUxYEg">https://www.youtube.com/watch?v=PeVQwYUxYEg</a>
</li>

<li>EINE (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/EINE">http://www.emacswiki.org/emacs/EINE</a>
</li>

<li>EINE (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?EINE">http://texteditors.org/cgi-bin/wiki.pl?EINE</a>
</li>

<li>ZWEI (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/ZWEI">http://www.emacswiki.org/emacs/ZWEI</a>
</li>

<li>ZWEI (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?ZWEI">http://texteditors.org/cgi-bin/wiki.pl?ZWEI</a>
</li>

<li>Zmacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Zmacs">https://en.wikipedia.org/wiki/Zmacs</a>
</li>

<li>Zmacs (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?Zmacs">http://texteditors.org/cgi-bin/wiki.pl?Zmacs</a>
</li>

<li>TecoEmacs (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/TecoEmacs">http://www.emacswiki.org/emacs/TecoEmacs</a>
</li>

<li>Micro Emacs<br />
<a href="http://www.emacswiki.org/emacs/MicroEmacs">http://www.emacswiki.org/emacs/MicroEmacs</a>
</li>

<li>Micro Emacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/MicroEMACS">https://en.wikipedia.org/wiki/MicroEMACS</a>
</li>

<li>EmacsHistory<br />
<a href="http://www.emacswiki.org/emacs/EmacsHistory">http://www.emacswiki.org/emacs/EmacsHistory</a>
</li>

<li>Seznam editorů s ovládáním podobným Emacsu či kompatibilních s příkazy Emacsu<br />
<a href="http://www.finseth.com/emacs.html">http://www.finseth.com/emacs.html</a>
</li>

<li>evil-numbers<br />
<a href="https://github.com/cofi/evil-numbers">https://github.com/cofi/evil-numbers</a>
</li>

<li>Debuggery a jejich nadstavby v&nbsp;Linuxu (1.část)<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/</a>
</li>

<li>Debuggery a jejich nadstavby v&nbsp;Linuxu (2.část)<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (3): Nemiver<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (4): KDbg<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (5): ladění aplikací v editorech Emacs a Vim<br />
<a href="https://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">https://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/</a>
</li>

<li>Org mode<br />
<a href="https://orgmode.org/">https://orgmode.org/</a>
</li>

<li>The Org Manual<br />
<a href="https://orgmode.org/manual/index.html">https://orgmode.org/manual/index.html</a>
</li>

<li>Kakoune (modální textový editor)<br />
<a href="http://kakoune.org/">http://kakoune.org/</a>
</li>

<li>Vim-style keybinding in Emacs/Evil-mode<br />
<a href="https://gist.github.com/troyp/6b4c9e1c8670200c04c16036805773d8">https://gist.github.com/troyp/6b4c9e1c8670200c04c16036805773d8</a>
</li>

<li>Emacs - jak začít<br />
<a href="http://www.abclinuxu.cz/clanky/navody/emacs-jak-zacit">http://www.abclinuxu.cz/clanky/navody/emacs-jak-zacit</a>
</li>

<li>Programovací jazyk LISP a LISP machines<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-lisp-a-lisp-machines/">https://www.root.cz/clanky/programovaci-jazyk-lisp-a-lisp-machines/</a>
</li>

<li>Evil-surround<br />
<a href="https://github.com/emacs-evil/evil-surround">https://github.com/emacs-evil/evil-surround</a>
</li>

<li>Spacemacs<br />
<a href="http://spacemacs.org/">http://spacemacs.org/</a>
</li>

<li>Lisp: Common Lisp, Racket, Clojure, Emacs Lisp<br />
<a href="http://hyperpolyglot.org/lisp">http://hyperpolyglot.org/lisp</a>
</li>

<li>Common Lisp, Scheme, Clojure, And Elisp Compared<br />
<a href="http://irreal.org/blog/?p=725">http://irreal.org/blog/?p=725</a>
</li>

<li>Does Elisp Suck?<br />
<a href="http://irreal.org/blog/?p=675">http://irreal.org/blog/?p=675</a>
</li>

<li>Emacs pro mírně pokročilé (9): Elisp<br />
<a href="https://www.root.cz/clanky/emacs-elisp/">https://www.root.cz/clanky/emacs-elisp/</a>
</li>

<li>If I want to learn lisp, are emacs and elisp a good choice?<br />
<a href="https://www.reddit.com/r/emacs/comments/2m141y/if_i_want_to_learn_lisp_are_emacs_and_elisp_a/">https://www.reddit.com/r/emacs/comments/2m141y/if_i_want_to_learn_lisp_are_emacs_and_elisp_a/</a>
</li>

<li>Clojure(Script) Interactive Development Environment that Rocks!<br />
<a href="https://github.com/clojure-emacs/cider">https://github.com/clojure-emacs/cider</a>
</li>

<li>An Introduction to Emacs Lisp<br />
<a href="https://harryrschwartz.com/2014/04/08/an-introduction-to-emacs-lisp.html">https://harryrschwartz.com/2014/04/08/an-introduction-to-emacs-lisp.html</a>
</li>

<li>Emergency Elisp<br />
<a href="http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html">http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html</a>
</li>

<li>Lambda calculus<br />
<a href="https://en.wikipedia.org/wiki/Lambda_calculus">https://en.wikipedia.org/wiki/Lambda_calculus</a>
</li>

<li>John McCarthy's original LISP paper from 1959<br />
<a href="https://www.reddit.com/r/programming/comments/17lpz4/john_mccarthys_original_lisp_paper_from_1959/">https://www.reddit.com/r/programming/comments/17lpz4/john_mccarthys_original_lisp_paper_from_1959/</a>
</li>

<li>Micro Manual LISP<br />
<a href="https://www.scribd.com/document/54050141/Micro-Manual-LISP">https://www.scribd.com/document/54050141/Micro-Manual-LISP</a>
</li>

<li>How Lisp Became God's Own Programming Language<br />
<a href="https://twobithistory.org/2018/10/14/lisp.html">https://twobithistory.org/2018/10/14/lisp.html</a>
</li>

<li>History of Lisp<br />
<a href="http://jmc.stanford.edu/articles/lisp/lisp.pdf">http://jmc.stanford.edu/articles/lisp/lisp.pdf</a>
</li>

<li>The Roots of Lisp<br />
<a href="http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf">http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf</a>
</li>

<li>Racket<br />
<a href="https://racket-lang.org/">https://racket-lang.org/</a>
</li>

<li>The Racket Manifesto<br />
<a href="http://felleisen.org/matthias/manifesto/">http://felleisen.org/matthias/manifesto/</a>
</li>

<li>MIT replaces Scheme with Python<br />
<a href="https://www.johndcook.com/blog/2009/03/26/mit-replaces-scheme-with-python/">https://www.johndcook.com/blog/2009/03/26/mit-replaces-scheme-with-python/</a>
</li>

<li>Adventures in Advanced Symbolic Programming<br />
<a href="http://groups.csail.mit.edu/mac/users/gjs/6.945/">http://groups.csail.mit.edu/mac/users/gjs/6.945/</a>
</li>

<li>Why MIT Switched from Scheme to Python (2009)<br />
<a href="https://news.ycombinator.com/item?id=14167453">https://news.ycombinator.com/item?id=14167453</a>
</li>

<li>Starodávná stránka XLispu<br />
<a href="http://www.xlisp.org/">http://www.xlisp.org/</a>
</li>

<li>AutoLISP<br />
<a href="https://en.wikipedia.org/wiki/AutoLISP">https://en.wikipedia.org/wiki/AutoLISP</a>
</li>

<li>Seriál PicoLisp: minimalistický a výkonný interpret Lispu<br />
<a href="https://www.root.cz/serialy/picolisp-minimalisticky-a-vykonny-interpret-lispu/">https://www.root.cz/serialy/picolisp-minimalisticky-a-vykonny-interpret-lispu/</a>
</li>

<li>Common Lisp<br />
<a href="https://common-lisp.net/">https://common-lisp.net/</a>
</li>

<li>Getting Going with Common Lisp<br />
<a href="https://cliki.net/Getting%20Started">https://cliki.net/Getting%20Started</a>
</li>

<li>Online Tutorial (Common Lisp)<br />
<a href="https://cliki.net/online%20tutorial">https://cliki.net/online%20tutorial</a>
</li>

<li>Guile Emacs<br />
<a href="https://www.emacswiki.org/emacs/GuileEmacs">https://www.emacswiki.org/emacs/GuileEmacs</a>
</li>

<li>Guile Emacs History<br />
<a href="https://www.emacswiki.org/emacs/GuileEmacsHistory">https://www.emacswiki.org/emacs/GuileEmacsHistory</a>
</li>

<li>Guile is a programming language<br />
<a href="https://www.gnu.org/software/guile/">https://www.gnu.org/software/guile/</a>
</li>

<li>MIT Scheme<br />
<a href="http://groups.csail.mit.edu/mac/projects/scheme/">http://groups.csail.mit.edu/mac/projects/scheme/</a>
</li>

<li>SIOD: Scheme in One Defun<br />
<a href="http://people.delphiforums.com/gjc//siod.html">http://people.delphiforums.com/gjc//siod.html</a>
</li>

<li>CommonLispForEmacs<br />
<a href="https://www.emacswiki.org/emacs/CommonLispForEmacs">https://www.emacswiki.org/emacs/CommonLispForEmacs</a>
</li>

<li>Elisp: print, princ, prin1, format, message<br />
<a href="http://ergoemacs.org/emacs/elisp_printing.html">http://ergoemacs.org/emacs/elisp_printing.html</a>
</li>

<li>Special Forms in Lisp<br />
<a href="http://www.nhplace.com/kent/Papers/Special-Forms.html">http://www.nhplace.com/kent/Papers/Special-Forms.html</a>
</li>

<li>Basic Building Blocks in LISP<br />
<a href="https://www.tutorialspoint.com/lisp/lisp_basic_syntax.htm">https://www.tutorialspoint.com/lisp/lisp_basic_syntax.htm</a>
</li>

<li>Introduction to LISP - University of Pittsburgh<br />
<a href="https://people.cs.pitt.edu/~milos/courses/cs2740/Lectures/LispTutorial.pdf">https://people.cs.pitt.edu/~milos/courses/cs2740/Lectures/LispTutorial.pdf</a>
</li>

<li>Why don't people use LISP<br />
<a href="https://forums.freebsd.org/threads/why-dont-people-use-lisp.24572/">https://forums.freebsd.org/threads/why-dont-people-use-lisp.24572/</a>
</li>

<li>Structured program theorem<br />
<a href="https://en.wikipedia.org/wiki/Structured_program_theorem">https://en.wikipedia.org/wiki/Structured_program_theorem</a>
</li>

<li>Clojure: API Documentation<br />
<a href="https://clojure.org/api/api">https://clojure.org/api/api</a>
</li>

<li>Tutorial for the Common Lisp Loop Macro<br />
<a href="http://www.ai.sri.com/pkarp/loop.html">http://www.ai.sri.com/pkarp/loop.html</a>
</li>

<li>Common Lisp's Loop Macro Examples for Beginners<br />
<a href="http://www.unixuser.org/~euske/doc/cl/loop.html">http://www.unixuser.org/~euske/doc/cl/loop.html</a>
</li>

<li>A modern list api for Emacs. No 'cl required.<br />
<a href="https://github.com/magnars/dash.el">https://github.com/magnars/dash.el</a>
</li>

<li>The LOOP Facility<br />
<a href="http://www.lispworks.com/documentation/HyperSpec/Body/06_a.htm">http://www.lispworks.com/documentation/HyperSpec/Body/06_a.htm</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>Transient Data Structures
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Jazyky Hy a Clojure-py: moderní dialekty LISPu určené pro Python VM<br />
<a href="https://www.root.cz/clanky/jazyky-hy-a-clojure-py-moderni-dialekty-lispu-urcene-pro-python-vm/">https://www.root.cz/clanky/jazyky-hy-a-clojure-py-moderni-dialekty-lispu-urcene-pro-python-vm/</a>
</li>

<li>Pixie: lehký skriptovací jazyk s „kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

<li>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/">https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

