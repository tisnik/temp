<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Základní knihovna jazyka Racket</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Základní knihovna jazyka Racket</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve třetím článku o programovacím jazyce Racket si popíšeme některé důležité základní knihovny, které vývojářům poskytují mnoho užitečných funkcí &ndash; od zpracování seznamů přes práci s vektory a hešovacími mapami až po zpracování obecných proudů (streams).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Seznamy v&nbsp;roli základního strukturovaného datového typu všech LISPovských jazyků</a></p>
<p><a href="#k02">2. Základní funkce pro zpracování seznamů</a></p>
<p><a href="#k03">3. Průchod všemi prvky seznamu s&nbsp;využitím funkce <strong>for/list</strong></a></p>
<p><a href="#k04">4. Funkce vyššího řádu <strong>map</strong></a></p>
<p><a href="#k05">5. Další varianty funkce <strong>map</strong></a></p>
<p><a href="#k06">6. Funkce vyššího řádu <strong>filter</strong></a></p>
<p><a href="#k07">7. Funkce vyššího řádu <strong>foldl</strong> a <strong>foldr</strong></a></p>
<p><a href="#k08">8. Vektory</a></p>
<p><a href="#k09">9. Funkce a makra používaná pro zpracování vektorů</a></p>
<p><a href="#k10">10. Hešovací tabulky</a></p>
<p><a href="#k11">11. Funkce a makra používaná pro práci s&nbsp;hešovacími tabulkami</a></p>
<p><a href="#k12">12. Generátor číselné řady (typu <strong>range</strong>)</a></p>
<p><a href="#k13">13. Specializované datové typy</a></p>
<p><a href="#k14">*** 14. Celočíselné numerické hodnoty s&nbsp;pevným počtem bitů (<strong>fixnum</strong>)</a></p>
<p><a href="#k15">*** 15. Typ <strong>fxvector</strong></a></p>
<p><a href="#k16">*** 16. Typ <strong>flvector</strong></a></p>
<p><a href="#k17">*** 17. Typ <strong>stream</strong></a></p>
<p><a href="#k18">*** 18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Literatura</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Seznamy v&nbsp;roli základního strukturovaného datového typu všech LISPovských jazyků</h2>

<p>Nejdříve se zaměříme na funkce a makra používaná pro zpracování různých
datových struktur podporovaných programovacím jazykem <i>Racket</i>. Podobně,
jako je tomu v&nbsp;prakticky jakémkoli jiném lispovském programovacím jazyku,
je základním strukturovaným datovým typem seznam (<i>list</i>), na který se
taktéž můžeme dívat jako na vzájemně provázané tečka-dvojice (ostatně samotný
název LIST vznikl z&nbsp;dvousloví &bdquo;LISt Processor&ldquo;). Nejprve si
připomeňme, jakým způsobem je vlastně možné seznam vytvořit. V&nbsp;případě, že
máme k&nbsp;dispozici konkrétní prvky, které se mají do seznamu vložit,
použijeme konstruktor <strong>list</strong>, popř.&nbsp;můžeme seznam
reprezentovat přímo zápisem jeho prvků do závorek.</p>

<p><div class="rs-tip-major">Poznámka: ve všech demonstračních příkladech se
bude dodržovat následující konvence &ndash; <strong>tučným písmem</strong> je
označen text zapisovaný vývojářem, normálním písmem text vyhodnocovaný
interpretrem programovacího jazyka Racket a kurzívou případné poznámky
uvozované středníkem.</div></p>

<p>Prázdný seznam:</p>

<pre>
<strong>(list)</strong>
'()
&nbsp;
<strong>empty</strong>
'()
</pre>

<p>Seznam celých čísel:</p>

<pre>
<strong>(list 1 2 3 4)</strong>
'(1 2 3 4)
</pre>

<p>Seznam řetězců:</p>

<pre>
<strong>(list "www" "root" "cz")</strong>
'("www" "root" "cz")
</pre>

<p>Seznam symbolů:</p>

<pre>
<strong>(list '#:foo '#:bar '#:baz)</strong>
'(#:foo #:bar #:baz)
</pre>

<p>Vnořený seznam:</p>

<pre>
<strong>(list (list 1 2) (list 3 4) (list 5 (list 6)))</strong>
'((1 2) (3 4) (5 (6)))
</pre>

<p>Seznam lze napsat i přímo ve formě prvků umístěných do závorek, ovšem
nesmíme zapomenout na použití speciální formy <strong>quote</strong>, aby se
interpret nesnažil o vyhodnocení seznamu (jako funkce):</p>

<pre>
<strong>(quote (1 2 3 4))</strong>
(quote "www" "root" "cz")
</pre>

<p>Speciální forma <strong>quote</strong> se v&nbsp;praxi používá tak často, že
je umožněno ji zkrátit a zapisovat pomocí apostrofu:</p>

<pre>
<strong>'(1 2 3 4)</strong>
'(1 2 3 4)
&nbsp;
<strong>'("www" "root" "cz")</strong>
'("www" "root" "cz")
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;praxi se prakticky nikdy
nesetkáme s&nbsp;tím, že by vývojáři formu <strong>quote</strong> takto
rozepisovali; téměř vždy se používá apostrof. Ovšem například při výpisu
expandovaného makra (viz předchozí část tohoto seriálu) se
<strong>quote</strong> objevit může.</div></p>

<p>Jak se tedy liší použití konstruktoru <strong>list</strong> od přímého
zapsání seznamu s&nbsp;<strong>quote</strong>? V&nbsp;prvním případě mohou být
prvky seznamy vyhodnoceny (vypočítány), ve druhém případě nikoli:</p>

<pre>
<strong>(list (+ 1 2) (+ 3 4))</strong>
'(3 7)
&nbsp;
<strong>(quote ((+ 1 2) (+ 3 4)))</strong>
'((+ 1 2) (+ 3 4))
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Základní funkce pro zpracování seznamů</h2>

<p>V&nbsp;knihovnách programovacího jazyka <i>Racket</i> je k&nbsp;dispozici
poměrně velké množství funkcí určených pro práci se seznamy. Mnohé
z&nbsp;těchto funkcí bylo převzato ze starších dialektů jazyka LISP
popř.&nbsp;přímo z&nbsp;programovacího jazyka Scheme, další funkce pak
nalezneme v&nbsp;balíčku <strong>racket/list</strong>. Některé z&nbsp;těchto
funkcí si ukážeme na (velmi jednoduchých) demonstračních příkladech.</p>

<p>Zjištění délky seznamu, tj.&nbsp;počtu prvků v&nbsp;seznamu:</p>

<pre>
<strong>(define x '(1 2 3))</strong>
<strong>(length x)</strong>
3
&nbsp;
<strong>(define z '())</strong>
<strong>(length z)</strong>
0
</pre>

<p>Výběr n-tého prvku ze seznamu (i s&nbsp;případnou chybou, pokud index
nespadá do očekávaného rozsahu):</p>

<pre>
<strong>(list-ref x 2)</strong>
3
&nbsp;
<strong>(list-ref x 4)</strong>
; list-ref: index too large for list
;   index: 4
;   in: '(1 2 3)
; [,bt for context]
</pre>

<p>Výběr prvního prvku ze seznamu:</p>

<pre>
<strong>(first x)</strong>
1
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tradičním LISPu je tato funkce pojmenována <strong>car</strong>. Nic nám ovšem nebrání použít <strong>car</strong> i v&nbsp;Racketu:</div></p>

<pre>
<strong>(car x)</strong>
1
</pre>

<p>Vrácení zbytku seznamu bez prvního prvku:</p>

<pre>
<strong>(rest x)</strong>
'(2 3)
</pre>

<p><div class="rs-tip-major">Poznámka: opět se vraťme k&nbsp;tradičním LISPům,
kde se tato funkce jmenuje <strong>cdr</strong>. I tuto funkci v&nbsp;Racketu
nalezneme:</div></p>

<pre>
<strong>(cdr x)</strong>
'(2 3)
</pre>

<p>Test, zda seznam obsahuje daný prvek či nikoli:</p>

<pre>
<strong>(member 2 x)</strong>
'(2 3)
&nbsp;
<strong>(member 3 x)</strong>
'(3)
&nbsp;
<strong>(member 1 x)</strong>
'(1 2 3)
&nbsp;
<strong>(member 4 x)</strong>
#f
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto případě se vrací
pravdivostní hodnota <strong>#f</strong> nebo jiná hodnota vyhodnocovaná jako
pravda (tato hodnota je současně obsahem seznamu za nalezeným prvkem, což se
může hodit).</div></p>

<p>Otočení prvků v&nbsp;seznamu:</p>

<pre>
<strong>(reverse x)</strong>
'(3 2 1)
</pre>

<p>Vložení nového prvku do seznamu na jeho začátek (což je jediná operace, kterou lze provést v&nbsp;konstantním čase):</p>

<pre>
<strong>(cons 4 x)</strong>
'(4 1 2 3)
&nbsp;
<strong>(cons 4 z)</strong>
'(4)
</pre>

<p>Vytvoření seznamů z&nbsp;tečka dvojic:</p>

<pre>
<strong>(cons 1 empty)</strong>
'(1)
&nbsp;
<strong>(cons 1 (cons 2 empty))</strong>
'(1 2)
&nbsp;
<strong>(cons 1 (cons 2 (cons 3 empty)))</strong>
'(1 2 3)
</pre>

<p>Chování funkce <strong>cons</strong> se odlišuje podle toho, jakého typu
jsou parametry této funkci předané. Běžného chování známého z&nbsp;jiných
jazyků dosáhneme tehdy, pokud funkci předáme dva <i>atomy</i>. Výsledkem
v&nbsp;tomto případě bude tečka-dvojice:</p>

<pre>
<strong>(cons 1 2)</strong>
'(1 . 2)
&nbsp;
<strong>(cons 1 (cons 2 3))</strong>
'(1 2 . 3)
&nbsp;
<strong>(cons (cons 1 2) (cons 3 4))</strong>
'((1 . 2) 3 . 4)
</pre>

<p>Spojení dvou či více seznamů:</p>

<pre>
<strong>(append x x)</strong>
'(1 2 3 1 2 3)
&nbsp;
<strong>(append x x (list 9 9 9))</strong>
'(1 2 3 1 2 3 9 9 9)
&nbsp;
<strong>(append '(0 0 0) x x (list 9 9 9))</strong>
'(0 0 0 1 2 3 1 2 3 9 9 9)
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že v&nbsp;programovacím
jazyku Racket používáme identifikátor <strong>empty</strong> pro označení
prázdného seznamu. Alternativně lze použít i zápis <strong>'()</strong>, který
je používán v&nbsp;dalších dialektech LISPu či Scheme.</div></p>


<p>K&nbsp;dipozici je i predikát pro zjištění, zda je zkoumaná hodnota seznamem
či nikoli:</p>

<pre>
<strong>(define x '(1 2 3))</strong>
<strong>(list? x)</strong>
#t
&nbsp;
<strong>(define y 123)</strong>
<strong>(list? y)</strong>
#f
&nbsp;
<strong>(define z '())</strong>
<strong>(list? z)</strong>
#t
&nbsp;
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Průchod všemi prvky seznamu s&nbsp;využitím funkce <strong>for/list</strong></h2>

<p>Pro průchod všemi prvky seznamu můžeme použít funkci nazvanou příznačně
<strong>for/list</strong> (připomeňme si, že v&nbsp;Racketu nepatří lomítko
mezi specializované znaky a tudíž se může objevit i ve jméně funkce). Použití
je triviální:</p>

<pre>
<strong>(for/list ((item (list 1 2 3 4 5))) (+ item item))</strong>
'(2 4 6 8 10)
</pre>

<p>Rozepsání na více řádků a použití znaků [] namísto () pro větší
čitelnost:</p>

<pre>
<strong>(for/list ([item (list 1 2 3 4 5)])</strong>
          <strong>(+ item item))</strong>
'(2 4 6 8 10)
</pre>

<p>Průchod dvěma seznamy:</p>

<pre>
<strong>(for/list ([i1 (list 1 2 3 4)] [i2 (list 6 7 8 9)]) (+ i1 i2))</strong>
'(7 9 11 13)
</pre>

<p>Pokud je jeden ze seznamů kratší, zkrátí se i počet průchodů smyčkou:</p>

<pre>
<strong>(for/list ([i1 (list 1 2 3 4)] [i2 (list 6 7 8 9 10)]) (+ i1 i2))</strong>
'(7 9 11 13)
&nbsp;
<strong>(for/list ([i1 (list 1 2 3 4 5)] [i2 (list 6 7 8 9)]) (+ i1 i2))</strong>
'(7 9 11 13)
</pre>

<p><a href="#k04">V&nbsp;navazující kapitole</a> popsanou funkci
<strong>map</strong> je možné naprogramovat právě s&nbsp;využitím
<strong>for/list</strong>, a to například následujícím způsobem:</p>

<pre>
<strong>(define (map-function fce lst)</strong>
  <strong>(for/list ([item lst])</strong>
    <strong>(fce item)))</strong>
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Funkce vyššího řádu <strong>map</strong></h2>

<p>Zatímco v&nbsp;běžných imperativních programovacích jazycích se seznamy
zpracovávají prvek po prvku s&nbsp;využitím nějaké formy programové smyčky,
v&nbsp;jazyku <i>Racket</i> se setkáme spíše s&nbsp;použitím několika funkcí
vyššího řádu, které jako svůj vstup akceptují seznam a nějakou funkci, která je
postupně aplikována buď na prvky seznamu, nebo na prvek seznamu a akumulátor,
jehož hodnota se postupně při zpracovávání jednotlivých prvků seznamu mění.
Výsledkem bývá buď nový seznam, nebo výsledná hodnota akumulátoru. Tyto funkce
se většinou nazývají <strong>map</strong>, <strong>filter</strong> a
<strong>reduce</strong> či <strong>fold</strong> a v&nbsp;Racketu existuje hned
několik variant od každé této funkce.</p>

<p>První varianta funkce <strong>map</strong> se jmenuje ...
<strong>map</strong>. Tato funkce vyššího řádu akceptuje (v&nbsp;prvním
parametru) funkci s&nbsp;jedním vstupním parametrem, která bude aplikována na
prvky seznamu, který musí být do <strong>map</strong> předán jako druhý
parametr. Pochopitelně se podíváme na demonstrační příklady, protože se
s&nbsp;funkcí <strong>map</strong> v&nbsp;praxi setkáme velmi často.</p>

<p><div class="rs-tip-major">Poznámka: funkce <strong>map</strong>,
resp.&nbsp;přesněji řečeno koncept, na němž je postavena, se pravděpodobně
poprvé objevil právě v&nbsp;lispovských programovacích jazycích a odtud byl
později přenesen i do dalších funkcionálních jazyků a ještě později i do
běžných (řekněme mainstreamových) jazyků.</div></p>

<p>Aplikace existující funkce na seznam, výsledkem bude jiný seznam:</p>

<pre>
<strong>(map sqrt (list 1 4 9 16 25))</strong>
'(1 2 3 4 5)
</pre>

<p>Výsledný seznam může obsahovat i prvky odlišného typu:</p>

<pre>
<strong>(map even? (list 1 4 9 16 25))</strong>
'(#f #t #f #t #f)
&nbsp;
<strong>(map string-length (list "www" "." "root" "." "cz"))</strong>
'(3 1 4 1 2)
</pre>

<p>V&nbsp;případě, že budeme chtít na prvky seznamu aplikovat vlastní funkci
(s&nbsp;jedním vstupem), máme dvě možnosti:</p>

<ol>

<li>Vytvořit pojmenovanou funkci a tu následně do <strong>map</strong>
předat</li>

<li>Přímo ve funkci map deklarovat funkci anonymní, která bude omezena právě na
ono jediné volání funkce <strong>map</strong></li>

</ol>

<p>Opět si pochopitelně oba dva zmíněné případy ukážeme prakticky. Budeme
chtít, aby se hodnoty všech prvků seznamu zdvojnásobily. Pochopitelně je snadné
si vytvořit novou funkci pojmenovanou například <strong>double</strong> a tu
následně pro tento účel použít:</p>

<pre>
<strong>(define (double x) (+ x x))</strong>
<strong>(map double (list 1 2 3 4 5))</strong>
'(2 4 6 8 10)
</pre>

<p>Alternativně můžeme podobnou funkcionalitu implementovat jako funkci
anonymní na jediném řádku:</p>

<pre>
<strong>(map (lambda (x) (+ x x)) (list 1 2 3 4 5))</strong>
'(2 4 6 8 10)
</pre>

<p>Vzhledem k&nbsp;tomu, že výsledkem funkce <strong>map</strong> je opět
seznam, lze volání vnořit, i když to nemusí být příliš čitelné:</p>

<pre>
<strong>(map (lambda (x) (/ 1 x))</strong>
     <strong>(map (lambda (x) (+ x x))</strong>
          <strong>(list 1 2 3 4 5)))</strong>
'(1/2 1/4 1/6 1/8 1/10)
</pre>

<p>Nebo:</p>

<pre>
<strong>(define (inc x) (+ 1 x))</strong>
<strong>(inc 3)</strong>
4
&nbsp;
<strong>(map inc</strong>
     <strong>(map (lambda (x) (/ 1 x))</strong>
          <strong>(map (lambda (x) (+ x x))</strong>
               <strong>(list 1 2 3 4 5))))</strong>
'(3/2 5/4 7/6 9/8 11/10)
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Další varianty funkce <strong>map</strong></h2>

<p>Ve skutečnosti existují v&nbsp;programovacím jazyce Racket,
resp.&nbsp;přesněji řečeno v&nbsp;jeho základních knihovnách, i další varianty
funkce <strong>map</strong>. Poměrně často potřebujeme zjistit, zda prvky
seznamu odpovídají nějaké podmínce. Podmínku lze zapsat s&nbsp;využitím
klasického <i>predikátu</i>, tj.&nbsp;funkce s&nbsp;jedním vstupním parametrem,
která vrací pravdivostní hodnotu <strong>#t</strong> nebo <strong>#f</strong>.
Pokud použijeme funkci vyššího řádu <strong>map</strong> s&nbsp;takovým
predikátem, bude výsledkem nový seznam obsahující pouze pravdivostní
hodnoty.</p>

<p>Pokud například budeme chtít zjistit, které prvky jsou sudé, můžeme
postupovat takto:</p>

<pre>
<strong>(map even? (list 1 4 9 16 25))</strong>
'(#f #t #f #t #f)
</pre>

<p>Často však potřebujeme zjistit, jestli všechny prvky odpovídají zadané
podmínce (predikátu), zda žádný prvek predikátu neodpovídá, nebo dokonce zda
alespoň nějaký (tedy minimálně jeden) prvek predikátu odpovídá. Budeme tedy
chtít výsledný vektor nějakým způsobem konsolidovat do jediné pravdivostní
hodnoty <strong>#t</strong> nebo <strong>#f</strong>. A právě pro tento účel
slouží další varianty funkce <strong>map</strong> nazvané příznačně
<strong>andmap</strong> a <strong>ormap</strong>. Na následujících řádcích je
ukázáno, jak se tyto varianty chovají při zpracování vstupních seznamů.</p>

<p>Je alespoň jeden prvek sudý?</p>

<pre>
<strong>(ormap even? (list 1 4 9 16 25))</strong>
#t
&nbsp;
<strong>(ormap even? (list 1 3 5))</strong>
#f
</pre>

<p>Jsou všechny prvky seznamu sudé?</p>

<pre>
<strong>(andmap even? (list 1 4 9 16 25))</strong>
#f
&nbsp;
<strong>(andmap even? (list 2 4 6))</strong>
#t
</pre>

<p>Chování u prázdného seznamu může být poněkud překvapující, ovšem je
konzistentní se sémantikou prováděných operací:</p>

<pre>
<strong>(map even? empty)</strong>
'()
&nbsp;
<strong>(andmap even? empty)</strong>
#t
&nbsp;
<strong>(ormap even? empty)</strong>
#f
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti je chování funkcí
<strong>andmap</strong> a <strong>ormap</strong> do značné míry podobné dále
popsané funkci <strong>foldl</strong> v&nbsp;tom ohledu, že je seznam zpracován
a &bdquo;akumulován&ldquo; do jediné výsledné hodnoty.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Funkce vyššího řádu <strong>filter</strong></h2>

<p>Funkci <strong>map</strong> zmíněnou v&nbsp;předchozích kapitolách
pravděpodobně mnoho čtenářů již zná z&nbsp;dalších programovacích jazyků. Týká
se to i funkce nazvané <strong>filter</strong>, která dnes již patří
k&nbsp;základní nabídce funkcí i v&nbsp;mainstreamových programovacích jazycích
(kde bývá zobecněna pro zpracování libovolných <i>streamů</i> či
<i>sekvencí</i>). I tato funkce je funkcí vyššího řádu, a to z&nbsp;toho
důvodu, že jako svůj vstup akceptuje jinou funkci. Zde se konkrétně musí jednat
o predikát, tedy o funkci vracející pro každý svůj vstup pravdivostní hodnotu
<strong>#t</strong> nebo <strong>#f</strong>. Na základě výsledné hodnoty
predikátu se právě zpracovávaný prvek buď objeví ve výstupním seznamu či nikoli
&ndash; tato funkce tedy obecně vrací seznam, ale s&nbsp;odlišným počtem prvků,
než kolik jich má seznam vstupní (pokud není predikát splněn pro žádný prvek ze
vstupního seznamu, bude výsledkem prázdný seznam).</p>

<p>Opět se podívejme na několik demonstračních příkladů (s&nbsp;několika jsme
se již setkali v&nbsp;předchozích částech tohoto seriálu při popisu ostatních
dialektů programovacího jazyka Scheme):</p>

<pre>
<strong>(filter even? (list 1 2 3 4 5 6 7))</strong>
'(2 4 6)
&nbsp;
<strong>(filter odd? (list 1 2 3 4 5 6 7))</strong>
'(1 3 5 7)
&nbsp;
<strong>(filter positive? (list 1 2 3 4 5 6 7))</strong>
'(1 2 3 4 5 6 7)
&nbsp;
<strong>(filter negative? (list 1 2 3 4 5 6 7))</strong>
'()
</pre>

<p>Můžeme si samozřejmě vytvořit i vlastní predikát a ten následně použít:</p>

<pre>
<strong>(define (not-dot s) (not (eq? s ".")))</strong>
&nbsp;
<strong>(filter not-dot (list "www" "." "root" "." "cz"))</strong>
'("www" "root" "cz")
</pre>

<p>Použití anonymní funkce:</p>

<pre>
<strong>(filter (lambda (s) (not (eq? s "."))) (list "www" "." "root" "." "cz"))</strong>
'("www" "root" "cz")
</pre>

<p>Čitelnější varianta:</p>

<pre>
<strong>(filter (lambda (s) (not (eq? s ".")))</strong>
        <strong>(list "www" "." "root" "." "cz"))</strong>
'("www" "root" "cz")
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Funkce vyššího řádu <strong>foldl</strong> a <strong>foldr</strong></h2>

<p>Ve většině programovacích jazyků inspirovaných funkcionálním programováním
se kromě funkcí typu <strong>map</strong> a <strong>filter</strong> setkáme i
s&nbsp;funkcí vyššího řádu, která se nazývá buď <strong>reduce</strong> nebo
<strong>fold</strong>. Programovací jazyk <i>Racket</i> pochopitelně není
výjimkou, takže i v&nbsp;něm nalezneme tento typ funkce, a to dokonce
v&nbsp;několika variantách. Základní funkcí tohoto typu je funkce nazvaná
<strong>foldl</strong>, která postupně zpracovává všechny prvky seznamu zleva
doprava a aplikuje na každý prvek a akumulovanou hodnotu nějakou funkci.
Výsledkem je v&nbsp;každé iteraci nová hodnota akumulátoru a po projití celého
seznamu je výsledná hodnota uložená v&nbsp;akumulátoru současně i návratovou
hodnotou funkce <strong>foldl</strong>. Samotné volání této funkce je ovšem
nepatrně složitější, než tomu bylo u <strong>map</strong> a
<strong>filter</strong>. Je tomu tak z&nbsp;toho důvodu, že kromě
zpracovávající funkce (se dvěma parametry) a vstupního seznamu musíme funkci
<strong>foldl</strong> předat i počáteční hodnotu akumulátoru.</p>

<p>Opět si ukážeme několik demonstračních příkladů.</p>

<p>Součet hodnot v&nbsp;seznamu a součet s&nbsp;počáteční hodnotou akumulátoru
nastavenou na 100:</p>

<pre>
<strong>(foldl + 0 (list 1 2 3 4 5))</strong>
15
&nbsp;
<strong>(foldl + 100 (list 1 2 3 4 5))</strong>
115
</pre>

<p>Postupná konstrukce seznamu z&nbsp;tečka-dvojic:</p>

<pre>
<strong>(foldl cons empty (list 1 2 3 4 5))</strong>
'(5 4 3 2 1)
</pre>

<p>Použití funkce <strong>foldr</strong>, která seznam zpracovává od posledního
prvku:</p>

<pre>
<strong>(foldl cons empty (list 1 2 3 4 5))</strong>
'(1 2 3 4 5)
</pre>

<p>Při některých výpočtech je výsledek volání <strong>foldl</strong> a
<strong>foldr</strong> totožný, ovšem <strong>foldl</strong> je paměťově
efektivnější:</p>

<pre>
<strong>(foldr + 0 (list 1 2 3 4 5))</strong>
15
&nbsp;
<strong>(foldr + 100 (list 1 2 3 4 5))</strong>
115
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Vektory</h2>

<p>Výše popsané seznamy jsou v&nbsp;lispovských programovacích jazycích
základním strukturovaným datovým typem. Interně se jedná, jak již víme
z&nbsp;předchozích částí tohoto seriálu, o lineárně vázané prvky, přičemž každý
prvek je představován tečka dvojicí. V&nbsp;první části tečka-dvojice je
uložena hodnota prvku, v&nbsp;části druhé pak reference na další prvek. Toto
uspořádání je sice flexibilní a umožňuje snadnou tvorbu nového seznamu ze
seznamu původního (<strong>cons</strong>, <strong>append</strong>), ovšem
nevýhodou je pomalý přístup k&nbsp;jednotlivým prvkům, který je proveden
v&nbsp;lineárním čase; tj.&nbsp;časová složitost je <i>O(n)</i>.
V&nbsp;případě, že je zapotřebí zajistit konstantní přístup k&nbsp;jednotlivým
prvkům na základě jejich indexu, budeme s&nbsp;velkou pravděpodobností
preferovat strukturovaný datový typ, který se bude chovat podobně jako pole
v&nbsp;jiných programovacích jazycích. Takovým datovým typem je v&nbsp;jazyku
Racket typ nazvaný příznačně <i>vektor</i> (<i>vector</i>).</p>

<p>Literál vektoru se zapisuje:</p>

<pre>
<strong>#(jednotlivé prvky vektoru)</strong>
</pre>

<p>Příklad:</p>

<pre>
<strong>#(1 2 3 4)</strong>
'#(1 2 3 4)
&nbsp;
<strong>#()</strong>
'#()
</pre>

<p>Konstruktorem vektorů je funkce <strong>vektor</strong>:</p>

<pre>
<strong>(vector 1 2 3 4)</strong>
'#(1 2 3 4)
&nbsp;
<strong>(vector)</strong>
'#()
</pre>

<p>Vektor může obsahovat prvky libovolného typu:</p>

<pre>
<strong>(vector (list 1 2 3 4) (vector 1 2 3 4))</strong>
'#((1 2 3 4) #(1 2 3 4))
&nbsp;
<strong>(vector "foo" (list 1 2 3 4) "bar" (vector 1 2 3 4) "baz")</strong>
'#("foo" (1 2 3 4) "bar" #(1 2 3 4) "baz")
</pre>

<p>Takto vytvořený vektor je měnitelný (<i>mutable</i>).</p>

<p>Vytvořit můžeme i vektor o zadané kapacitě prvků:</p>

<pre>
<strong>(make-vector 10)</strong>
'#(0 0 0 0 0 0 0 0 0 0)
</pre>

<p>Takový vektor lze i inicializovat:</p>

<pre>
<strong>(make-vector 10 1/2)</strong>
'#(1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2)
</pre>

<p>K&nbsp;dispozici je i predikát testující, zda je hodnota typu vektor či
nikoli:</p>

<pre>
<strong>(vector? x)</strong>
#f
&nbsp;
<strong>(vector? y)</strong>
#t
&nbsp;
<strong>(vector? (vector))</strong>
#t
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si rozdílu oproti
programovacímu jazyku Clojure, v&nbsp;němž se prvky vektoru zapisují do
hranatých závorek. Interně jsou ovšem vektory v&nbsp;Clojure reprezentovány
odlišným a nepatrně složitějším způsobem jako &bdquo;široké&ldquo; stromy.
V&nbsp;případě programovacího jazyka Racket se ovšem jedná o skutečnou obdobu
polí. Navíc se v&nbsp;Racketu mohou hranaté závorky používat ve stejném významu
jako závorky kulaté, takže někteří autoři používají zápis, který do značné míry
připomíná jazyk Logo.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Funkce a makra používaná pro zpracování vektorů</h2>

<p>V&nbsp;základní knihovně programovacího jazyka Racket je k&nbsp;dispozici
několik desítek funkcí určených pro práci s&nbsp;vektory. Další funkce
nalezneme v&nbsp;rozšiřující knihovně nazvané <strong>racket/vector</strong>,
kterou je ovšem ve vytvářených skriptech potřeba explicitně načíst
příkazem:</p>

<pre>
<strong>(require racket/vector)</strong>
</pre>

<p>Použití těchto funkcí si opět ukážeme na příkladech.</p>

<p>Vektory, s&nbsp;nimiž budeme pracovat:</p>

<pre>
<strong>(define v1 (vector 1 2 3 4))</strong>
<strong>(define v3 (vector))</strong>
<strong>(vector-length v3)</strong>
</pre>

<p>Délka vektorů (počet prvků):</p>

<pre>
<strong>(vector-length v1)</strong>
4
&nbsp;
<strong>(vector-length v2)</strong>
4
&nbsp;
<strong>(vector-length v3)</strong>
0
</pre>

<p>Přístup k&nbsp;prvkům vektorů (čtení) s&nbsp;případným nahlášením chyb:</p>

<pre>
<strong>(vector-ref v1 0)</strong>
1
&nbsp;
<strong>(vector-ref v1 2)</strong>
3
&nbsp;
<strong>(vector-ref v1 10)</strong>
; vector-ref: index is out of range
;   index: 10
;   valid range: [0, 3]
;   vector: '#(1 2 3 4)
; [,bt for context]
</pre>

<p>Nastavení nové hodnoty měnitelného vektoru, opět s&nbsp;případným hlášením
chyby:</p>

<pre>
<strong>(vector-set! v1 2 -5)</strong>
&nbsp;
<strong>v1</strong>
'#(1 2 -5 4)
&nbsp;
<strong>(vector-set! v1 10 -5)</strong>
; vector-set!: index is out of range
;   index: 10
;   valid range: [0, 3]
;   vector: '#(1 2 -5 4)
; [,bt for context]
</pre>

<p>Vyplnění všech prvků vektoru stejnou hodnotou:</p>

<pre>
<strong>(vector-fill! v1 0)</strong>
&nbsp;
<strong>v1</strong>
'#(0 0 0 0)
</pre>

<p>Převod vektoru na seznam:</p>

<pre>
<strong>(vector-&gt;list v1)</strong>
'(0 0 0 0)
&nbsp;
<strong>(vector-&gt;list v2)</strong>
'(4 5 6 7)
&nbsp;
<strong>(vector-&gt;list v3)</strong>
'()
</pre>

<p>Převod seznamu na vektor:</p>

<pre>
<strong>(list-&gt;vector '())</strong>
'#()
&nbsp;
<strong>(list-&gt;vector '(1))</strong>
'#(1)
&nbsp;
<strong>(list-&gt;vector '(1 2 3))</strong>
'#(1 2 3)
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Hešovací tabulky</h2>

<p>Dalším velmi užitečným a často používaným strukturovaným datovým typem
v&nbsp;programovacím jazyku Racket jsou hešovací tabulky (<i>hash table</i>).
Podobně jako u seznamů a vektorů, je možné i u hešovacích tabulek zvolit, zda
se má jednat o neměnnou hodnotu či o hodnotu, kterou lze za běhu aplikace
modifikovat. Neměnná (<i>immutable</i>) hešovací tabulka se vytvoří pomocí
konstruktoru <strong>hash</strong>, kterému se předá libovolný počet dvojic
klíč-hodnota:</p>

<pre>
<strong>(hash "red" "#ff0000" "green" "#00ff00" "blue" "#0000ff")</strong>
'#hash(("blue" . "#0000ff") ("green" . "#00ff00") ("red" . "#ff0000"))
</pre>

<p>Při porovnávání klíčů prvků vkládaných do hešovací tabulky se používají
predikáty <strong>equal?</strong>, <strong>eq?</strong> nebo
<strong>eqv?</strong> (<strong>eq?</strong> provádí nejsilnější porovnání,
porovnání je současně nejrychlejší). Výše uvedený konstruktor
<strong>hash</strong> používá predikát <strong>equal?</strong>, ovšem
pochopitelně můžeme zvolit i další dva predikáty. Využívá se přitom odlišných
konstruktorů <strong>hasheq</strong> a <strong>hasheqv</strong>:</p>

<pre>
<strong>(hasheq "red" "#ff0000" "green" "#00ff00" "blue" "#0000ff")</strong>
'#hasheq(("blue" . "#0000ff") ("green" . "#00ff00") ("red" . "#ff0000"))
&nbsp;
<strong>(hasheqv "red" "#ff0000" "green" "#00ff00" "blue" "#0000ff")</strong>
'#hasheqv(("blue" . "#0000ff") ("green" . "#00ff00") ("red" . "#ff0000"))
</pre>

<p>Měnitelné hešovací tabulky, do nichž je možné v&nbsp;čase přidávat další
prvky, se vytváří s&nbsp;využitím konstruktoru <strong>make-hash</strong>,
popř.&nbsp;jeho alternativ <strong>make-hasheq</strong> a
<strong>make-hasheqv</strong>:</p>

<pre>
<strong>(define h1 (make-hash))</strong>
&nbsp;
<strong>(define h2 (make-hasheq))</strong>
&nbsp;
<strong>(define h3 (make-hasheqv))</strong>
&nbsp;
<strong>h1</strong>
'#hash()
&nbsp;
<strong>h2</strong>
'#hasheq()
&nbsp;
<strong>h3</strong>
'#hasheqv()
</pre>

<p>Prvky měnitelné hešovací tabulky lze inicializovat, a to předáním seznamu
obsahujícího dvojice klíč-hodnota (každá dvojice by měla být podseznamem):</p>

<pre>
<strong>(define h1 (make-hash '(["red" "#ff0000"] '["green" "#00ff00"] '["blue" "#0000ff"])))</strong>
&nbsp;
<strong>(define h2 (make-hasheq '(["red" "#ff0000"] '["green" "#00ff00"] '["blue" "#0000ff"])))</strong>
&nbsp;
<strong>(define h3 (make-hasheqv '(["red" "#ff0000"] '["green" "#00ff00"] '["blue" "#0000f</strong>
&nbsp;
<strong>h1</strong>
'#hash((quote . (("blue" "#0000ff"))) ("red" . ("#ff0000")))
&nbsp;
<strong>h2</strong>
'#hasheq((quote . (("blue" "#0000ff"))) ("red" . ("#ff0000")))
&nbsp;
<strong>h3</strong>
'#hasheqv((quote . (("blue" "#0000ff"))) ("red" . ("#ff0000")))
</pre>

<p><div class="rs-tip-major">Poznámka: opět platí, že hranaté závorky [] jsme
použili pouze pro větší čitelnost, ovšem stejně dobře lze použít ekvivalentní
zápis s&nbsp;kulatými závorkami () nebo s&nbsp;libovolným mixem závorek (ovšem
párové závorky musí být stejného typu).</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Funkce a makra používaná pro práci s&nbsp;hešovacími tabulkami</h2>

<p>Přečtení prvku uloženého pod známým klíčem:</p>

<pre>
<strong>(hash-ref h1 "blue")</strong>
"#0000ff"
</pre>

<p>Pokus o přečtení neexistujícího prvku:</p>

<pre>
<strong>(hash-ref h1 "foobar")</strong>
; hash-ref: no value found for key
;   key: "foobar"
; [,bt for context]
</pre>

<p>Specifikovat lze i hodnotu, která se vrací ve chvíli, kdy prvek nebyl nalezen:</p>

<pre>
<strong>(hash-ref h1 "blue" "nic")</strong>
"#0000ff"
&nbsp;
<strong>(hash-ref h1 "foobar" "nic")</strong>
"nic"
</pre>

<p>Do měnitelných hešovacích tabulek se nová dvojice klíč-hodnota ukládá funkcí
<strong>hash-set!</strong>:</p>

<pre>
<strong>(hash-set! h1 "red" "#ff0000")</strong>
&nbsp;
<strong>(hash-set! h1 "green" "#00ff00")</strong>
&nbsp;
<strong>(hash-set! h1 "blue" "#0000ff")</strong>
&nbsp;
<strong>h1</strong>
'#hash(("blue" . "#0000ff") ("green" . "#00ff00") ("red" . "#ff0000"))
</pre>

<p>Přepis hodnoty prvku (se stejným klíčem):</p>

<pre>
<strong>(hash-set! h1 "blue" "rgb(0,0,1)")</strong>
&nbsp;
<strong>h1</strong>
'#hash(("blue" . "rgb(0,0,1)") ("green" . "#00ff00") ("red" . "#ff0000"))
</pre>

<p>Odstranění prvku z&nbsp;hešovací tabulky:</p>

<pre>
<strong>(hash-remove! h1 "blue")</strong>
&nbsp;
<strong>(hash-remove! h1 "foobar")</strong>
&nbsp;
<strong>h1</strong>
'#hash(("green" . "#00ff00") ("red" . "#ff0000"))
</pre>

<p>U neměnitelných hešovacích tabulek se používají funkce
<strong>hash-set</strong> a <strong>hash-remove</strong> (bez vykřičníku na
konci), které ovšem pochopitelně nemodifikují původní tabulku, ale vrací
tabulku novou:</p>

<pre>
<strong>(define h1 (hash "red" "#ff0000" "green" "#00ff00" "blue" "#0000ff"))</strong>
&nbsp;
<strong>h1</strong>
'#hash(("blue" . "#0000ff") ("green" . "#00ff00") ("red" . "#ff0000"))
&nbsp;
<strong>(hash-set h1 "white" "#ffffff")</strong>
'#hash(("blue" . "#0000ff")
       ("green" . "#00ff00")
       ("red" . "#ff0000")
       ("white" . "#ffffff"))
&nbsp;
<strong>h1</strong>
'#hash(("blue" . "#0000ff") ("green" . "#00ff00") ("red" . "#ff0000"))
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Generátor číselné řady (typu <strong>range</strong>)</h2>

<p>V&nbsp;praxi se velmi často setkáme s&nbsp;požadavkem vytvoření sekvence
čísel. Tento požadavek je v&nbsp;mnoha programovacích jazycích realizován
nějakou základní funkcí; příkladem může být jazyk Python 2.x a jeho funkce
<strong>range</strong> (v&nbsp;Pythonu 3 se sémantika této funkce změnila).
V&nbsp;jazyku Racket se pro podobný účel používá funkce se jménem
<strong>in-range</strong>, což je jméno, které začne dávat smysl ve chvíli, kdy
ji použijeme společně se speciální formou <strong>for</strong> pro vytvoření
programové smyčky. Tato funkce vrací takzvaný <i>proud (stream)</i>:</p>

<pre>
<strong>(in-range 10)</strong>
#<stream>
</pre>

<p>Zkusme však tuto funkci zkombinovat s&nbsp;<strong>for/list</strong>.
Využijeme přitom jak základní variantu funkce, v&nbsp;níž se zadává pouze
koncová hodnota, tak i variantu s&nbsp;počáteční hodnotou a (nepovinným)
krokem:</p>

<pre>
<strong>(for/list ([i (in-range 10)]) i)</strong>
'(0 1 2 3 4 5 6 7 8 9)
&nbsp;
<strong>(for/list ([i (in-range 1 10)]) i)</strong>
'(1 2 3 4 5 6 7 8 9)
&nbsp;
<strong>(for/list ([i (in-range 1 10 2)]) i)</strong>
'(1 3 5 7 9)
&nbsp;
<strong>(for/list ([i (in-range 1 10 -2)]) i)</strong>
'()
&nbsp;
<strong>(for/list ([i (in-range 10 0 -2)]) i)</strong>
'(10 8 6 4 2)
</pre>

<p>Použití pro zlomky (typ <i>rational</i>):</p>

<pre>
<strong>(for/list ([i (in-range 1 10 1/2)]) i)</strong>
'(1 3/2 2 5/2 3 7/2 4 9/2 5 11/2 6 13/2 7 15/2 8 17/2 9 19/2)
</pre>

<p>Použití pro reálná čísla (se známým problémem, který způsobuje hodnota
0,1):</p>

<pre>
<strong>(for/list ([i (in-range 0.0 1 0.1)]) i)</strong>
'(0.0
  0.1
  0.2
  0.30000000000000004
  0.4
  0.5
  0.6
  0.7
  0.7999999999999999
  0.8999999999999999
  0.9999999999999999)
</pre>

<p>Existuje ještě podobná funkce nazvaná <strong>in-naturals</strong>, která
taktéž generuje číselnou řadu, ovšem v&nbsp;tomto případě nekonečnou (případná
programová smyčka tedy nikdy neskončí, pokud v&nbsp;ní nepoužijeme nějakou
jinou formu pro ukončení iteračního cyklu):</p>

<pre>
<strong>(for/list ([k (in-naturals)]</strong>
           <strong>[x (in-range 10)])</strong>
           <strong>(list k x))</strong>
'((0 0) (1 1) (2 2) (3 3) (4 4) (5 5) (6 6) (7 7) (8 8) (9 9))
</pre>

<p>popř.:</p>

<pre>
<strong>(for/list ([k (in-naturals)]</strong>
           <strong>[x (in-range 1 10)])</strong>
           <strong>(list k (/ 1 x)))</strong>
'((0 1) (1 1/2) (2 1/3) (3 1/4) (4 1/5) (5 1/6) (6 1/7) (7 1/8) (8 1/9))
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Specializované datové typy</h2>

<p>V&nbsp;navazujících kapitolách se ve stručnosti seznámíme s&nbsp;dalšími
specializovanými datovými typy, které lze v&nbsp;programovacím jazyku Racket
použít. V&nbsp;první řadě se jedná o numerický datový typ
<strong>fixnum</strong>, dále o typ <strong>flonum</strong>, vektory
s&nbsp;prvky <strong>fixnum</strong> a <strong>flonum</strong> a taktéž o
zobecnění sekvencí, které je představováno datovým typem
<strong>stream</strong>.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Celočíselné numerické hodnoty s&nbsp;pevným počtem bitů (<strong>fixnum</strong>)</h2>

<p>Běžné aritmetické funkce typu + atd. dokážou pracovat s&nbsp;libovolným
numerickým typem z&nbsp;<i>numerické věže</i> jazyka Racket. To je u
vysokoúrovňového programovacího jazyka očekávatelné chování, ovšem zaplatíme za
to delší dobou výpočtu a případně i větší spotřebou operační paměti. Pokud
potřebujeme provádět rychlé výpočty jen s&nbsp;celými čísly (navíc shora
omezenými), lze pro tento účel použít hodnoty typu <strong>fixnum</strong>, což
jsou celá čísla (<i>integer</i>) o šířce 31 bitů na 32bitových systémech a 63
bitů na systémech 64bitových (jeden bit je rezervován pro <i>tag</i>).</p>

<p>Aby byly dále popsané funkce volatelné, je nutné nahrát příslušnou
knihovnu:</p>

<pre>
<strong>(require racket/fixnum)</strong>
</pre>

<p>Poté lze namísto obecných funkcí +, -, &lt; atd. použít funkci
s&nbsp;prefixem &bdquo;fx&ldquo;:</p>

<pre>
<strong>(+ 1 2)</strong>
3
&nbsp;
<strong>(fx+ 1 2)</strong>
3
</pre>

<p>Rozdíl mezi <strong>+</strong> a <strong>fx+</strong> se projeví například
ve chvíli, kdy překročíme rozsah 31/63 bitů: </p>

<pre>
<strong>(+ 1 4611686018427387903)</strong>
4611686018427387904
&nbsp;
<strong>(fx+ 1 4611686018427387903)</strong>
; fx+: result is not a fixnum
;   result: 4611686018427387904
; [,bt for context]
</pre>

<p>Popř.&nbsp;se pokusíme o násobení velkých čísel, které může vést
k&nbsp;přetečení (mezi)výsledku (ovšem bez nahlášení chyby):</p>

<pre>
<strong>(* (* 99999 99999) (* 99999 99999))</strong>
99996000059999600001
&nbsp;
<strong>(fx* (fx* 99999 99999) (fx* 99999 99999))</strong>
-1461092345402933887
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Typ <strong>fxvector</strong></h2>

<p></p>

<pre>
(require racket/flonum)
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Typ <strong>flvector</strong></h2>

<p></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Typ <strong>stream</strong></h2>

<p></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/lisp-families.git">https://github.com/tisnik/lisp-families.git</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, můžete
namísto toho použít odkazy na jednotlivé příklady, které naleznete
v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Popis příkladu</th><th>Cesta</th></tr>
<tr><td>1</td><td>01-dot-pairs.rkt</td><td>zpracování tečka-dvojic</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/base-libraries/01-dot-pairs.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/base-libraries/01-dot-pairs.rkt</a></td></tr>
<tr><td>2</td><td>02-cons.rkt</td><td>konstrukce tečka dvojic a seznamů</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/base-libraries/02-cons.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/base-libraries/02-cons.rkt</a></td></tr>
<tr><td>3</td><td>03-lists_traditional.rkt</td><td>zpracování seznamů, tradiční funkce</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/base-libraries/03-lists_traditional.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/base-libraries/03-lists_traditional.rkt</a></td></tr>
<tr><td>4</td><td>04-lists_racket.rkt</td><td>zpracování seznamů, funkce Racketu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/base-libraries/04-lists_racket.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/base-libraries/04-lists_racket.rkt</a></td></tr>
<tr><td>5</td><td></td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/base-libraries/">https://github.com/tisnik/lisp-families/blob/master/racket/base-libraries/</a></td></tr>
<tr><td>6</td><td></td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/base-libraries/">https://github.com/tisnik/lisp-families/blob/master/racket/base-libraries/</a></td></tr>
<tr><td>7</td><td></td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/base-libraries/">https://github.com/tisnik/lisp-families/blob/master/racket/base-libraries/</a></td></tr>
<tr><td>8</td><td></td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/base-libraries/">https://github.com/tisnik/lisp-families/blob/master/racket/base-libraries/</a></td></tr>
<tr><td>9</td><td></td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/base-libraries/">https://github.com/tisnik/lisp-families/blob/master/racket/base-libraries/</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Literatura</h2>

<ol>

<li>Peter Seibel<br />
<i>&bdquo;Practical Common Lisp&ldquo;</i><br />
2009
</li>

<li>Paul Graham<br />
<i>&bdquo;ANSI Common Lisp&ldquo;</i><br />
1995
</li>

<li>Gerald Gazdar<br />
<i>&bdquo;Natural Language Processing in Lisp: An Introduction to Computational Linguistics&ldquo;</i><br />
1989
</li>

<li>Peter Norvig<br />
<i>&bdquo;Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp&ldquo;</i><br />
1991
</li>

<li>Alex Mileler et.al.<br />
<i>&bdquo;Clojure Applied: From Practice to Practitioner&ldquo;</i><br />
2015
</li>

<li>
<i>&bdquo;Living Clojure: An Introduction and Training Plan for Developers&ldquo;</i><br />
2015
</li>

<li>Dmitri Sotnikov<br />
<i>&bdquo;Web Development with Clojure: Build Bulletproof Web Apps with Less Code&ldquo;</i><br />
2016
</li>

<li>McCarthy<br />
<i>&bdquo;Recursive functions of symbolic expressions and their computation by machine, part I&ldquo;</i><br />
1960
</li>

<li>R. Kent Dybvig<br />
<i>&bdquo;The Scheme Programming Language&ldquo;</i><br />
2009
</li>

<li>Max Hailperin<br />
<i>&bdquo;Concrete Abstractions&ldquo;</i><br />
1998
</li>

<li>Guy L. Steele<br />
<i>&bdquo;History of Scheme&ldquo;</i><br />
2006, Sun Microsystems Laboratories
</li>

<li>Kolář J., Muller K.:<br />
<i>&bdquo;Speciální programovací jazyky&ldquo;</i><br />
Praha 1981
</li>

<li>
<i>&bdquo;AutoLISP Release 9, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., October 1987
</li>

<li>
<i>&bdquo;AutoLISP Release 10, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., September 1988
</li>

<li>McCarthy, John; Abrahams, Paul W.; Edwards, Daniel J.; Hart, Timothy P.; Levin, Michael I.<br />
<i>&bdquo;LISP 1.5 Programmer's Manual&ldquo;</i><br />
MIT Press. ISBN 0 262 130 1 1 4
</li>

<li>Carl Hewitt; Peter Bishop and Richard Steiger<br />
<i>&bdquo;A Universal Modular Actor Formalism for Artificial Intelligence&ldquo;</i><br />
1973
</li>

<li>Feiman, J.<br />
<i>&bdquo;The Gartner Programming Language Survey (October 2001)&ldquo;</i><br />
Gartner Advisory
</li>

<li>Harold Abelson, Gerald Jay Sussman, Julie Sussman:<br />
<i>Structure and Interpretation of Computer Programs</i><br />
MIT Press. 1985, 1996 (a možná vyšel i další přetisk)
</li>

<li>Paul Graham<br />
<i>On Lisp</i><br />
Prentice Hall, 1993<br />
Dostupné online na stránce <a href="http://www.paulgraham.com/onlisptext.html">http://www.paulgraham.com/onlisptext.html</a>
</li>

<li>David S. Touretzky<br />
<i>Common LISP: A Gentle Introduction to Symbolic Computation (Dover Books on Engineering)</i><br />
</li>

<li>Peter Norvig<br />
<i>Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp</i>
</li>

<li>Patrick Winston, Berthold Horn<br />
<i>Lisp (3rd Edition)</i><br />
ISBN-13: 978-0201083194, ISBN-10: 0201083191
</li>

<li>Matthias Felleisen, David Van Horn, Dr. Conrad Barski<br>
<i>Realm of Racket: Learn to Program, One Game at a Time!</i><br />
ISBN-13: 978-1593274917, ISBN-10: 1593274912 
</li>

<li>Graham Hutton<br />
<i>A tutorial on the universality andexpressiveness of fold</i><br />
http://www.cs.nott.ac.uk/~pszgmh/fold.pdf
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Racket: Macros<br />
<a href="https://www.it.uu.se/edu/course/homepage/avfunpro/ht13/lectures/Racket-3-Macros.pdf">https://www.it.uu.se/edu/course/homepage/avfunpro/ht13/lectures/Racket-3-Macros.pdf</a>
</li>

<li>Beautiful Racket / explainers: Macros<br />
<a href="https://beautifulracket.com/explainer/macros.html">https://beautifulracket.com/explainer/macros.html</a>
</li>

<li>Macros (dokumentace k Racketu)<br />
<a href="https://docs.racket-lang.org/guide/macros.html">https://docs.racket-lang.org/guide/macros.html</a>
</li>

<li>Model syntaxe jazyka Racket<br />
<a href="https://docs.racket-lang.org/reference/syntax-model.html">https://docs.racket-lang.org/reference/syntax-model.html</a>
</li>

<li>Syntax Objects<br />
<a href="https://docs.racket-lang.org/guide/stx-obj.html">https://docs.racket-lang.org/guide/stx-obj.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Beautiful Racket: an intro­duction to language-oriented programming using Racket<br />
<a href="https://beautifulracket.com/">https://beautifulracket.com/</a>
</li>

<li>Stránky projektu Racket<br />
<a href="https://racket-lang.org/">https://racket-lang.org/</a>
</li>

<li>Dokumentace k&nbsp;projektu Racket<br />
<a href="https://docs.racket-lang.org/index.html">https://docs.racket-lang.org/index.html</a>
</li>

<li>Seznam dostupných balíčků pro Racket<br />
<a href="https://pkgs.racket-lang.org/">https://pkgs.racket-lang.org/</a>
</li>

<li>Racket na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Racket_(programming_language)">https://en.wikipedia.org/wiki/Racket_(programming_language)</a>
</li>

<li>Blogy o Racketu a navazujících technologiích<br />
<a href="https://blog.racket-lang.org/">https://blog.racket-lang.org/</a>
</li>

<li>Prográmky psané v&nbsp;Racketu na RosettaCode<br />
<a href="http://rosettacode.org/wiki/Category:Racket">http://rosettacode.org/wiki/Category:Racket</a>
</li>

<li>Fear of Macros<br />
<a href="https://www.greghendershott.com/fear-of-macros/">https://www.greghendershott.com/fear-of-macros/</a>
</li>

<li>Rackjure<br />
<a href="https://github.com/greghendershott/rackjure">https://github.com/greghendershott/rackjure</a>
</li>

<li>Matthew Flatt’s proposal to change Racket’s s-expressions based syntax to infix representation creates a stir in the community<br />
<a href="https://hub.packtpub.com/matthew-flatts-proposal-to-change-rackets-s-expressions-based-syntax-to-infix-representation-creates-a-stir-in-the-community/">https://hub.packtpub.com/matthew-flatts-proposal-to-change-rackets-s-expressions-based-syntax-to-infix-representation-creates-a-stir-in-the-community/</a>
</li>

<li>Racket News<br />
<a href="https://racket-news.com/">https://racket-news.com/</a>
</li>

<li>Racket: Lisp for learning<br />
<a href="https://lwn.net/Articles/795385/">https://lwn.net/Articles/795385/</a>
</li>

<li>Future of Racket<br />
<a href="https://www.greghendershott.com/2019/07/future-of-racket.html">https://www.greghendershott.com/2019/07/future-of-racket.html</a>
</li>

<li>Kawa: Compiling Scheme to Java<br />
<a href="https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html">https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html</a>
</li>

<li>Kawa in Languages shootout<br />
<a href="http://per.bothner.com/blog/2010/Kawa-in-shootout/">http://per.bothner.com/blog/2010/Kawa-in-shootout/</a>
</li>

<li>Kawa 2.0 Supports Scheme R7RS<br />
<a href="https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/">https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/</a>
</li>

<li>Kawa — fast scripting on the Java platform<br />
<a href="https://lwn.net/Articles/623349/">https://lwn.net/Articles/623349/</a>
</li>

<li>Tail call (a její optimalizace)<br />
<a href="https://en.wikipedia.org/wiki/Tail_call">https://en.wikipedia.org/wiki/Tail_call</a>
</li>

<li>SLIME (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/SLIME">http://en.wikipedia.org/wiki/SLIME</a>
</li>

<li>slime.vim<br />
<a href="http://s3.amazonaws.com/mps/slime.vim">http://s3.amazonaws.com/mps/slime.vim</a>
</li>

<li>What are the best scheme implementations?<br />
<a href="https://www.slant.co/topics/5282/~scheme-implementations">https://www.slant.co/topics/5282/~scheme-implementations</a>
</li>

<li>Bigloo homepage<br />
<a href="http://www-sop.inria.fr/mimosa/fp/Bigloo/">http://www-sop.inria.fr/mimosa/fp/Bigloo/</a>
</li>

<li>FTP s tarbally Bigloo<br />
<a href="ftp://ftp-sop.inria.fr/indes/fp/Bigloo">ftp://ftp-sop.inria.fr/indes/fp/Bigloo</a>
</li>

<li>GOTO 2018 • Functional Programming in 40 Minutes • Russ Olsen<br />
<a href="https://www.youtube.com/watch?v=0if71HOyVjY">https://www.youtube.com/watch?v=0if71HOyVjY</a>
</li>

<li>TinyScheme (stránka na Sourceforge)<br />
<a href="http://tinyscheme.sourceforge.net/home.html">http://tinyscheme.sourceforge.net/home.html</a>
</li>

<li>Embedding Tiny Scheme in a Game<br />
<a href="http://www.silicondelight.com/embedding-tiny-scheme-in-a-game/">http://www.silicondelight.com/embedding-tiny-scheme-in-a-game/</a>
</li>

<li>Embedding Scheme for a game mission scripting DSL<br />
<a href="http://carloscarrasco.com/embedding-scheme-for-a-game-mission-scripting-dsl.html">http://carloscarrasco.com/embedding-scheme-for-a-game-mission-scripting-dsl.html</a>
</li>

<li>Všechny verze TinyScheme na SourceForge<br />
<a href="https://sourceforge.net/projects/tinyscheme/files/tinyscheme/">https://sourceforge.net/projects/tinyscheme/files/tinyscheme/</a>
</li>

<li>Fork TinyScheme na GitHubu<br />
<a href="https://github.com/yawnt/tinyscheme">https://github.com/yawnt/tinyscheme</a>
</li>

<li>Ackermannova funkce<br />
<a href="https://cs.wikipedia.org/wiki/Ackermannova_funkce">https://cs.wikipedia.org/wiki/Ackermannova_funkce</a>
</li>

<li>Ackermann function na Rosetta Code<br />
<a href="https://rosettacode.org/wiki/Ackermann_function#Scheme">https://rosettacode.org/wiki/Ackermann_function#Scheme</a>
</li>

<li>Success Stories (lisp.org)<br />
<a href="https://lisp-lang.org/success/">https://lisp-lang.org/success/</a>
</li>

<li>Allegro Common Lisp Success Stories<br />
<a href="https://franz.com/success/">https://franz.com/success/</a>
</li>

<li>Clojure Success Stories<br />
<a href="https://clojure.org/community/success_stories">https://clojure.org/community/success_stories</a>
</li>

<li>Scheme Quick Reference<br />
<a href="https://www.st.cs.uni-saarland.de/edu/config-ss04/scheme-quickref.pdf">https://www.st.cs.uni-saarland.de/edu/config-ss04/scheme-quickref.pdf</a>
</li>

<li>Slajdy o Scheme (od slajdu číslo 15)<br />
<a href="https://docs.google.com/presentation/d/1abmDnKjrq1tcjGvvRNAKhOiSTSE2lyagtcEPal07Gbo/edit">https://docs.google.com/presentation/d/1abmDnKjrq1tcjGvvRNAKhOiSTSE2lyagtcEPal07Gbo/edit</a>
</li>

<li>Scheme Cheat Sheet<br />
<a href="https://github.com/smythp/scheme-cheat-sheet">https://github.com/smythp/scheme-cheat-sheet</a>
</li>

<li>Embedding Lua, embedding Guile <br />
<a href="http://puntoblogspot.blogspot.com/2013/04/embedding-lua-embedding-guile.html">http://puntoblogspot.blogspot.com/2013/04/embedding-lua-embedding-guile.html</a>
</li>

<li>Lambda Papers<br />
<a href="https://en.wikisource.org/wiki/Lambda_Papers">https://en.wikisource.org/wiki/Lambda_Papers</a>
</li>

<li>Revised<sup>7</sup>Report on the Algorithmic Language Scheme<br />
<a href="https://small.r7rs.org/attachment/r7rs.pdf">https://small.r7rs.org/attachment/r7rs.pdf</a>
</li>

<li>Video Lectures (MIT, SICP 2005)<br />
<a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/</a>
</li>

<li>Why is Scheme my first language in university?<br />
<a href="https://softwareengineering.stackexchange.com/questions/115252/why-is-scheme-my-first-language-in-university">https://softwareengineering.stackexchange.com/questions/115252/why-is-scheme-my-first-language-in-university</a>
</li>

<li>The Perils of JavaSchools<br />
<a href="https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/">https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/</a>
</li>

<li>How to Design Programs, Second Edition<br />
<a href="https://htdp.org/2019-02-24/index.html">https://htdp.org/2019-02-24/index.html</a>
</li>

<li>LilyPond<br />
<a href="http://lilypond.org/">http://lilypond.org/</a>
</li>

<li>LilyPond — Extending (přes Scheme)<br />
<a href="http://lilypond.org/doc/v2.18/Documentation/extending/scheme-tutorial">http://lilypond.org/doc/v2.18/Documentation/extending/scheme-tutorial</a>
</li>

<li>Scheme in LilyPond<br />
<a href="http://lilypond.org/doc/v2.18/Documentation/extending/scheme-in-lilypond">http://lilypond.org/doc/v2.18/Documentation/extending/scheme-in-lilypond</a>
</li>

<li>GnuCash<br />
<a href="http://www.gnucash.org/">http://www.gnucash.org/</a>
</li>

<li>Custom Reports (in GNU Cash)<br />
<a href="https://wiki.gnucash.org/wiki/Custom_Reports">https://wiki.gnucash.org/wiki/Custom_Reports</a>
</li>

<li>Program by Design<br />
<a href="https://programbydesign.org/">https://programbydesign.org/</a>
</li>

<li>SchemePy<br />
<a href="https://pypi.org/project/SchemePy/">https://pypi.org/project/SchemePy/</a>
</li>

<li>LISP FQA: Section - [1-5] What is the "minimal" set of primitives needed for a Lisp interpreter?<br />
<a href="http://www.faqs.org/faqs/lisp-faq/part1/section-6.html">http://www.faqs.org/faqs/lisp-faq/part1/section-6.html</a>
</li>

<li>femtolisp<br />
<a href="https://github.com/JeffBezanson/femtolisp">https://github.com/JeffBezanson/femtolisp</a>
</li>

<li>(How to Write a (Lisp) Interpreter (in Python))<br />
<a href="http://norvig.com/lispy.html">http://norvig.com/lispy.html</a>
</li>

<li>Repositář s&nbsp;Guile Emacsem<br />
<a href="http://git.hcoop.net/?p=bpt/guile.git">http://git.hcoop.net/?p=bpt/guile.git</a>
</li>

<li>Interacting with Guile Compound Data Types in C<br />
<a href="http://www.lonelycactus.com/guilebook/x1555.html">http://www.lonelycactus.com/guilebook/x1555.html</a>
</li>

<li>Calling Guile functions from C<br />
<a href="http://www.lonelycactus.com/guilebook/c1204.html#SECCALLGUILEFUNC">http://www.lonelycactus.com/guilebook/c1204.html#SECCALLGUILEFUNC</a>
</li>

<li>Arrays, and other compound data types<br />
<a href="http://www.lonelycactus.com/guilebook/charrays.html">http://www.lonelycactus.com/guilebook/charrays.html</a>
</li>

<li>Interacting with Guile Compound Data Types in C<br />
<a href="http://www.lonelycactus.com/guilebook/x1555.html">http://www.lonelycactus.com/guilebook/x1555.html</a>
</li>

<li>Guile Reference Manual<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/index.html">https://www.gnu.org/software/guile/manual/html_node/index.html</a>
</li>

<li>Scheme: Summary of Common Syntax<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/Syntax-Summary.html#Syntax-Summary">https://www.gnu.org/software/guile/manual/html_node/Syntax-Summary.html#Syntax-Summary</a>
</li>

<li>Scripting with Guile: Extension language enhances C and Scheme<br />
<a href="https://www.ibm.com/developerworks/library/l-guile/index.html">https://www.ibm.com/developerworks/library/l-guile/index.html</a>
</li>

<li>Having fun with Guile: a tutorial<br />
<a href="http://dustycloud.org/misc/guile-tutorial.html">http://dustycloud.org/misc/guile-tutorial.html</a>
</li>

<li>Guile: Loading Readline Support<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/Loading-Readline-Support.html#Loading-Readline-Support">https://www.gnu.org/software/guile/manual/html_node/Loading-Readline-Support.html#Loading-Readline-Support</a>
</li>

<li>lispy<br />
<a href="https://pypi.org/project/lispy/">https://pypi.org/project/lispy/</a>
</li>

<li>Lython<br />
<a href="https://pypi.org/project/Lython/">https://pypi.org/project/Lython/</a>
</li>

<li>Lizpop<br />
<a href="https://pypi.org/project/lizpop/">https://pypi.org/project/lizpop/</a>
</li>

<li>Budoucnost programovacích jazyků<br />
<a href="http://www.knesl.com/budoucnost-programovacich-jazyku">http://www.knesl.com/budoucnost-programovacich-jazyku</a>
</li>

<li>LISP Prolog and Evolution<br />
<a href="http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html">http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html</a>
</li>

<li>List of Lisp-family programming languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages">https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages</a>
</li>

<li>clojure_py na indexu PyPi<br />
<a href="https://pypi.python.org/pypi/clojure_py">https://pypi.python.org/pypi/clojure_py</a>
</li>

<li>PyClojure<br />
<a href="https://github.com/eigenhombre/PyClojure">https://github.com/eigenhombre/PyClojure</a>
</li>

<li>Hy na GitHubu<br />
<a href="https://github.com/hylang/hy">https://github.com/hylang/hy</a>
</li>

<li>Hy: The survival guide<br />
<a href="https://notes.pault.ag/hy-survival-guide/">https://notes.pault.ag/hy-survival-guide/</a>
</li>

<li>Hy běžící na monitoru terminálu společnosti Symbolics<br />
<a href="http://try-hy.appspot.com/">http://try-hy.appspot.com/</a>
</li>

<li>Welcome to Hy’s documentation!<br />
<a href="http://docs.hylang.org/en/stable/">http://docs.hylang.org/en/stable/</a>
</li>

<li>Hy na PyPi<br />
<a href="https://pypi.org/project/hy/#description">https://pypi.org/project/hy/#description</a>
</li>

<li>Getting Hy on Python<br />
<a href="https://lwn.net/Articles/596626/">https://lwn.net/Articles/596626/</a>
</li>

<li>Programming Can Be Fun with Hy<br />
<a href="https://opensourceforu.com/2014/02/programming-can-fun-hy/">https://opensourceforu.com/2014/02/programming-can-fun-hy/</a>
</li>

<li>Přednáška o projektu Hy (pětiminutový lighttalk)<br />
<a href="http://blog.pault.ag/day/2013/04/02">http://blog.pault.ag/day/2013/04/02</a>
</li>

<li>Hy (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Hy">https://en.wikipedia.org/wiki/Hy</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Point<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Point.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Point.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Narrowing<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Narrowing.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Narrowing.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Functions that Create Markers<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Markers.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Markers.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Motion<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Motion.html#Motion">https://www.gnu.org/software/emacs/manual/html_node/elisp/Motion.html#Motion</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Basic Char Syntax<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Char-Syntax.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Char-Syntax.html</a>
</li>

<li>Elisp: Sequence: List, Array<br />
<a href="http://ergoemacs.org/emacs/elisp_list_vs_vector.html">http://ergoemacs.org/emacs/elisp_list_vs_vector.html</a>
</li>

<li>Elisp: Property List<br />
<a href="http://ergoemacs.org/emacs/elisp_property_list.html">http://ergoemacs.org/emacs/elisp_property_list.html</a>
</li>

<li>Elisp: Hash Table<br />
<a href="http://ergoemacs.org/emacs/elisp_hash_table.html">http://ergoemacs.org/emacs/elisp_hash_table.html</a>
</li>

<li>Elisp: Association List<br />
<a href="http://ergoemacs.org/emacs/elisp_association_list.html">http://ergoemacs.org/emacs/elisp_association_list.html</a>
</li>

<li>The mapcar Function (An Introduction to Programming in Emacs Lisp)<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/mapcar.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/mapcar.html</a>
</li>

<li>Anaphoric macro<br />
<a href="https://en.wikipedia.org/wiki/Anaphoric_macro">https://en.wikipedia.org/wiki/Anaphoric_macro</a>
</li>

<li>Some Common Lisp Loop Macro Examples<br />
<a href="https://www.youtube.com/watch?v=3yl8o6r_omw">https://www.youtube.com/watch?v=3yl8o6r_omw</a>
</li>

<li>A Guided Tour of Emacs<br />
<a href="https://www.gnu.org/software/emacs/tour/">https://www.gnu.org/software/emacs/tour/</a>
</li>

<li>The Roots of Lisp<br />
<a href="http://www.paulgraham.com/rootsoflisp.html">http://www.paulgraham.com/rootsoflisp.html</a>
</li>

<li>Evil (Emacs Wiki)<br />
<a href="https://www.emacswiki.org/emacs/Evil">https://www.emacswiki.org/emacs/Evil</a>
</li>

<li>Evil (na GitHubu)<br />
<a href="https://github.com/emacs-evil/evil">https://github.com/emacs-evil/evil</a>
</li>

<li>Evil (na stránkách repositáře MELPA)<br />
<a href="https://melpa.org/#/evil">https://melpa.org/#/evil</a>
</li>

<li>Evil Mode: How I Switched From VIM to Emacs<br />
<a href="https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html">https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html</a>
</li>

<li>GNU Emacs (home page)<br />
<a href="https://www.gnu.org/software/emacs/">https://www.gnu.org/software/emacs/</a>
</li>

<li>GNU Emacs (texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs">http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs</a>
</li>

<li>An Introduction To Using GDB Under Emacs<br />
<a href="http://tedlab.mit.edu/~dr/gdbintro.html">http://tedlab.mit.edu/~dr/gdbintro.html</a>
</li>

<li>An Introduction to Programming in Emacs Lisp<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html</a>
</li>

<li>27.6 Running Debuggers Under Emacs<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html">https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html</a>
</li>

<li>GdbMode<br />
<a href="http://www.emacswiki.org/emacs/GdbMode">http://www.emacswiki.org/emacs/GdbMode</a>
</li>

<li>Emacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Emacs">https://en.wikipedia.org/wiki/Emacs</a>
</li>

<li>Emacs timeline<br />
<a href="http://www.jwz.org/doc/emacs-timeline.html">http://www.jwz.org/doc/emacs-timeline.html</a>
</li>

<li>Emacs Text Editors Family<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?EmacsFamily">http://texteditors.org/cgi-bin/wiki.pl?EmacsFamily</a>
</li>

<li>Vrapper aneb spojení možností Vimu a Eclipse<br />
<a href="https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse/">https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse/</a>
</li>

<li>Vrapper aneb spojení možností Vimu a Eclipse (část 2: vyhledávání a nahrazování textu)<br />
<a href="https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse-cast-2-vyhledavani-a-nahrazovani-textu/">https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse-cast-2-vyhledavani-a-nahrazovani-textu/</a>
</li>

<li>Emacs/Evil-mode - A basic reference to using evil mode in Emacs<br />
<a href="http://www.aakarshnair.com/posts/emacs-evil-mode-cheatsheet">http://www.aakarshnair.com/posts/emacs-evil-mode-cheatsheet</a>
</li>

<li>From Vim to Emacs+Evil chaotic migration guide<br />
<a href="https://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/">https://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/</a>
</li>

<li>Introduction to evil-mode {video)<br />
<a href="https://www.youtube.com/watch?v=PeVQwYUxYEg">https://www.youtube.com/watch?v=PeVQwYUxYEg</a>
</li>

<li>EINE (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/EINE">http://www.emacswiki.org/emacs/EINE</a>
</li>

<li>EINE (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?EINE">http://texteditors.org/cgi-bin/wiki.pl?EINE</a>
</li>

<li>ZWEI (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/ZWEI">http://www.emacswiki.org/emacs/ZWEI</a>
</li>

<li>ZWEI (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?ZWEI">http://texteditors.org/cgi-bin/wiki.pl?ZWEI</a>
</li>

<li>Zmacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Zmacs">https://en.wikipedia.org/wiki/Zmacs</a>
</li>

<li>Zmacs (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?Zmacs">http://texteditors.org/cgi-bin/wiki.pl?Zmacs</a>
</li>

<li>TecoEmacs (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/TecoEmacs">http://www.emacswiki.org/emacs/TecoEmacs</a>
</li>

<li>Micro Emacs<br />
<a href="http://www.emacswiki.org/emacs/MicroEmacs">http://www.emacswiki.org/emacs/MicroEmacs</a>
</li>

<li>Micro Emacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/MicroEMACS">https://en.wikipedia.org/wiki/MicroEMACS</a>
</li>

<li>EmacsHistory<br />
<a href="http://www.emacswiki.org/emacs/EmacsHistory">http://www.emacswiki.org/emacs/EmacsHistory</a>
</li>

<li>Seznam editorů s ovládáním podobným Emacsu či kompatibilních s příkazy Emacsu<br />
<a href="http://www.finseth.com/emacs.html">http://www.finseth.com/emacs.html</a>
</li>

<li>evil-numbers<br />
<a href="https://github.com/cofi/evil-numbers">https://github.com/cofi/evil-numbers</a>
</li>

<li>Debuggery a jejich nadstavby v&nbsp;Linuxu (1.část)<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/</a>
</li>

<li>Debuggery a jejich nadstavby v&nbsp;Linuxu (2.část)<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (3): Nemiver<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (4): KDbg<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (5): ladění aplikací v editorech Emacs a Vim<br />
<a href="https://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">https://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/</a>
</li>

<li>Org mode<br />
<a href="https://orgmode.org/">https://orgmode.org/</a>
</li>

<li>The Org Manual<br />
<a href="https://orgmode.org/manual/index.html">https://orgmode.org/manual/index.html</a>
</li>

<li>Kakoune (modální textový editor)<br />
<a href="http://kakoune.org/">http://kakoune.org/</a>
</li>

<li>Vim-style keybinding in Emacs/Evil-mode<br />
<a href="https://gist.github.com/troyp/6b4c9e1c8670200c04c16036805773d8">https://gist.github.com/troyp/6b4c9e1c8670200c04c16036805773d8</a>
</li>

<li>Emacs - jak začít<br />
<a href="http://www.abclinuxu.cz/clanky/navody/emacs-jak-zacit">http://www.abclinuxu.cz/clanky/navody/emacs-jak-zacit</a>
</li>

<li>Programovací jazyk LISP a LISP machines<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-lisp-a-lisp-machines/">https://www.root.cz/clanky/programovaci-jazyk-lisp-a-lisp-machines/</a>
</li>

<li>Evil-surround<br />
<a href="https://github.com/emacs-evil/evil-surround">https://github.com/emacs-evil/evil-surround</a>
</li>

<li>Spacemacs<br />
<a href="http://spacemacs.org/">http://spacemacs.org/</a>
</li>

<li>Lisp: Common Lisp, Racket, Clojure, Emacs Lisp<br />
<a href="http://hyperpolyglot.org/lisp">http://hyperpolyglot.org/lisp</a>
</li>

<li>Common Lisp, Scheme, Clojure, And Elisp Compared<br />
<a href="http://irreal.org/blog/?p=725">http://irreal.org/blog/?p=725</a>
</li>

<li>Does Elisp Suck?<br />
<a href="http://irreal.org/blog/?p=675">http://irreal.org/blog/?p=675</a>
</li>

<li>Emacs pro mírně pokročilé (9): Elisp<br />
<a href="https://www.root.cz/clanky/emacs-elisp/">https://www.root.cz/clanky/emacs-elisp/</a>
</li>

<li>If I want to learn lisp, are emacs and elisp a good choice?<br />
<a href="https://www.reddit.com/r/emacs/comments/2m141y/if_i_want_to_learn_lisp_are_emacs_and_elisp_a/">https://www.reddit.com/r/emacs/comments/2m141y/if_i_want_to_learn_lisp_are_emacs_and_elisp_a/</a>
</li>

<li>Clojure(Script) Interactive Development Environment that Rocks!<br />
<a href="https://github.com/clojure-emacs/cider">https://github.com/clojure-emacs/cider</a>
</li>

<li>An Introduction to Emacs Lisp<br />
<a href="https://harryrschwartz.com/2014/04/08/an-introduction-to-emacs-lisp.html">https://harryrschwartz.com/2014/04/08/an-introduction-to-emacs-lisp.html</a>
</li>

<li>Emergency Elisp<br />
<a href="http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html">http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html</a>
</li>

<li>Lambda calculus<br />
<a href="https://en.wikipedia.org/wiki/Lambda_calculus">https://en.wikipedia.org/wiki/Lambda_calculus</a>
</li>

<li>John McCarthy's original LISP paper from 1959<br />
<a href="https://www.reddit.com/r/programming/comments/17lpz4/john_mccarthys_original_lisp_paper_from_1959/">https://www.reddit.com/r/programming/comments/17lpz4/john_mccarthys_original_lisp_paper_from_1959/</a>
</li>

<li>Micro Manual LISP<br />
<a href="https://www.scribd.com/document/54050141/Micro-Manual-LISP">https://www.scribd.com/document/54050141/Micro-Manual-LISP</a>
</li>

<li>How Lisp Became God's Own Programming Language<br />
<a href="https://twobithistory.org/2018/10/14/lisp.html">https://twobithistory.org/2018/10/14/lisp.html</a>
</li>

<li>History of Lisp<br />
<a href="http://jmc.stanford.edu/articles/lisp/lisp.pdf">http://jmc.stanford.edu/articles/lisp/lisp.pdf</a>
</li>

<li>The Roots of Lisp<br />
<a href="http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf">http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf</a>
</li>

<li>Racket<br />
<a href="https://racket-lang.org/">https://racket-lang.org/</a>
</li>

<li>The Racket Manifesto<br />
<a href="http://felleisen.org/matthias/manifesto/">http://felleisen.org/matthias/manifesto/</a>
</li>

<li>MIT replaces Scheme with Python<br />
<a href="https://www.johndcook.com/blog/2009/03/26/mit-replaces-scheme-with-python/">https://www.johndcook.com/blog/2009/03/26/mit-replaces-scheme-with-python/</a>
</li>

<li>Adventures in Advanced Symbolic Programming<br />
<a href="http://groups.csail.mit.edu/mac/users/gjs/6.945/">http://groups.csail.mit.edu/mac/users/gjs/6.945/</a>
</li>

<li>Why MIT Switched from Scheme to Python (2009)<br />
<a href="https://news.ycombinator.com/item?id=14167453">https://news.ycombinator.com/item?id=14167453</a>
</li>

<li>Starodávná stránka XLispu<br />
<a href="http://www.xlisp.org/">http://www.xlisp.org/</a>
</li>

<li>AutoLISP<br />
<a href="https://en.wikipedia.org/wiki/AutoLISP">https://en.wikipedia.org/wiki/AutoLISP</a>
</li>

<li>Seriál PicoLisp: minimalistický a výkonný interpret Lispu<br />
<a href="https://www.root.cz/serialy/picolisp-minimalisticky-a-vykonny-interpret-lispu/">https://www.root.cz/serialy/picolisp-minimalisticky-a-vykonny-interpret-lispu/</a>
</li>

<li>Common Lisp<br />
<a href="https://common-lisp.net/">https://common-lisp.net/</a>
</li>

<li>Getting Going with Common Lisp<br />
<a href="https://cliki.net/Getting%20Started">https://cliki.net/Getting%20Started</a>
</li>

<li>Online Tutorial (Common Lisp)<br />
<a href="https://cliki.net/online%20tutorial">https://cliki.net/online%20tutorial</a>
</li>

<li>Guile Emacs<br />
<a href="https://www.emacswiki.org/emacs/GuileEmacs">https://www.emacswiki.org/emacs/GuileEmacs</a>
</li>

<li>Guile Emacs History<br />
<a href="https://www.emacswiki.org/emacs/GuileEmacsHistory">https://www.emacswiki.org/emacs/GuileEmacsHistory</a>
</li>

<li>Guile is a programming language<br />
<a href="https://www.gnu.org/software/guile/">https://www.gnu.org/software/guile/</a>
</li>

<li>MIT Scheme<br />
<a href="http://groups.csail.mit.edu/mac/projects/scheme/">http://groups.csail.mit.edu/mac/projects/scheme/</a>
</li>

<li>SIOD: Scheme in One Defun<br />
<a href="http://people.delphiforums.com/gjc//siod.html">http://people.delphiforums.com/gjc//siod.html</a>
</li>

<li>CommonLispForEmacs<br />
<a href="https://www.emacswiki.org/emacs/CommonLispForEmacs">https://www.emacswiki.org/emacs/CommonLispForEmacs</a>
</li>

<li>Elisp: print, princ, prin1, format, message<br />
<a href="http://ergoemacs.org/emacs/elisp_printing.html">http://ergoemacs.org/emacs/elisp_printing.html</a>
</li>

<li>Special Forms in Lisp<br />
<a href="http://www.nhplace.com/kent/Papers/Special-Forms.html">http://www.nhplace.com/kent/Papers/Special-Forms.html</a>
</li>

<li>Basic Building Blocks in LISP<br />
<a href="https://www.tutorialspoint.com/lisp/lisp_basic_syntax.htm">https://www.tutorialspoint.com/lisp/lisp_basic_syntax.htm</a>
</li>

<li>Introduction to LISP - University of Pittsburgh<br />
<a href="https://people.cs.pitt.edu/~milos/courses/cs2740/Lectures/LispTutorial.pdf">https://people.cs.pitt.edu/~milos/courses/cs2740/Lectures/LispTutorial.pdf</a>
</li>

<li>Why don't people use LISP<br />
<a href="https://forums.freebsd.org/threads/why-dont-people-use-lisp.24572/">https://forums.freebsd.org/threads/why-dont-people-use-lisp.24572/</a>
</li>

<li>Structured program theorem<br />
<a href="https://en.wikipedia.org/wiki/Structured_program_theorem">https://en.wikipedia.org/wiki/Structured_program_theorem</a>
</li>

<li>Clojure: API Documentation<br />
<a href="https://clojure.org/api/api">https://clojure.org/api/api</a>
</li>

<li>Tutorial for the Common Lisp Loop Macro<br />
<a href="http://www.ai.sri.com/pkarp/loop.html">http://www.ai.sri.com/pkarp/loop.html</a>
</li>

<li>Common Lisp's Loop Macro Examples for Beginners<br />
<a href="http://www.unixuser.org/~euske/doc/cl/loop.html">http://www.unixuser.org/~euske/doc/cl/loop.html</a>
</li>

<li>A modern list api for Emacs. No 'cl required.<br />
<a href="https://github.com/magnars/dash.el">https://github.com/magnars/dash.el</a>
</li>

<li>The LOOP Facility<br />
<a href="http://www.lispworks.com/documentation/HyperSpec/Body/06_a.htm">http://www.lispworks.com/documentation/HyperSpec/Body/06_a.htm</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>Transient Data Structures
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Jazyky Hy a Clojure-py: moderní dialekty LISPu určené pro Python VM<br />
<a href="https://www.root.cz/clanky/jazyky-hy-a-clojure-py-moderni-dialekty-lispu-urcene-pro-python-vm/">https://www.root.cz/clanky/jazyky-hy-a-clojure-py-moderni-dialekty-lispu-urcene-pro-python-vm/</a>
</li>

<li>Pixie: lehký skriptovací jazyk s „kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

<li>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/">https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/</a>
</li>

<li>Stránka projektu Jython<br />
<a href="http://www.jython.org/">http://www.jython.org/</a>
</li>

<li>Jython (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Jython">https://en.wikipedia.org/wiki/Jython</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">https://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>JSR 223: Scripting for the Java<sup>TM</sup> Platform<br />
<a href="https://jcp.org/en/jsr/detail?id=223">https://jcp.org/en/jsr/detail?id=223</a>
</li>

<li>List of JVM languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_JVM_languages">https://en.wikipedia.org/wiki/List_of_JVM_languages</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

