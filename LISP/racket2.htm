<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Makra v Racketu i v dalších lispovských jazycích</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Makra v Racketu i v dalších lispovských jazycích</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Většina programovacích jazyků odvozených od Lispu nabízí programátorům systém pro tvorbu a používání maker. Jazyk Racket pochopitelně není výjimkou, ovšem jeho makrosystém je například oproti Common Lispu v&nbsp;mnoha směrech vylepšen, a to kvůli zajištění korektnosti a konzistence maker (takzvaná hygienická makra).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Role maker v&nbsp;lispovských programovacích jazycích</a></p>
<p><a href="#k02">2. Makra v&nbsp;Common Lispu</a></p>
<p><a href="#k03">3. Vytvoření makra v&nbsp;Common Lispu</a></p>
<p><a href="#k04">4. Výpis expandovaného makra, řešení dvojího vyhodnocení parametrů</a></p>
<p><a href="#k05">5. Typické Common Lispovské makro &bdquo;loop&ldquo;: operace nad seznamy</a></p>
<p><a href="#k06">6. Další příklady použití knihovního makra &bdquo;loop&ldquo;: počítané smyčky</a></p>
<p><a href="#k07">7. Základy práce se systémem maker v&nbsp;programovacím jazyku Clojure</a></p>
<p><a href="#k08">8. První písmeno ve zkratce REPL: objekt Reader a jeho makra</a></p>
<p><a href="#k09">9. Makra &bdquo;quote&ldquo; a &bdquo;syntax-quote&ldquo;</a></p>
<p><a href="#k10">10. Makra &bdquo;unquote&ldquo; a &bdquo;unquote-splicing&ldquo;</a></p>
<p><a href="#k11">11. Makra v&nbsp;programovacím jazyku Racket</a></p>
<p><a href="#k12">12. Vytvoření makra s&nbsp;využitím <strong>define-syntax-rule</strong></a></p>
<p><a href="#k13">13. Syntaktické objekty, použití <strong>syntax-&gt;datum</strong></a></p>
<p><a href="#k14">14. Makro pro prohození obsahu dvou proměnných</a></p>
<p><a href="#k15">15. Makro s&nbsp;volitelnou aritou</a></p>
<p><a href="#k16">16. Použití ... v&nbsp;makru</a></p>
<p><a href="#k17">17. Původní (nehygienická) makra v&nbsp;Racketu</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Literatura</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Role maker v&nbsp;lispovských programovacích jazycích</h2>

<p>Jednou z&nbsp;nejzajímavějších vlastností většiny klasických lispovských
jazyků je možnost tvorby maker. Vzhledem k&nbsp;tomu, že aplikace
naprogramované v&nbsp;LISPu (například v&nbsp;Common Lispu), Scheme či
v&nbsp;některém dalším lispovském jazyce (Clojure) jsou tvořeny, stejně jako
data, s&nbsp;využitím rekurzivně vnořených seznamů, jsou makra v&nbsp;LISPu
založena na manipulaci se seznamy tvořícími program, což je velký rozdíl
například oproti makrům implementovaným v&nbsp;céčkovém preprocesoru, kde se
jedná o poměrně jednoduché textové záměny (ostatně samotný preprocesor je
většinou zcela oddělený od překladače). Vzhledem k&nbsp;tomu, že lispovská
makra dokážou manipulovat s&nbsp;vlastním programem (resp.&nbsp;s&nbsp;jeho
uloženou podobou), je možné pomocí nich vytvářet například úplně nové jazykové
konstrukce (různé smyčky, podmíněné příkazy, částečně vyhodnocované formy atd.)
s&nbsp;vlastní syntaxí, což je poměrně unikátní vlastnost, kterou u většiny
dalších programovacích jazyků nenajdeme.</p>

<p><div class="rs-tip-major">Poznámka: existují samozřejmě i další jazyky
vybavené pokročilým makrosystémem. Na stránkách Rootu jsme se seznámili
například s&nbsp;následujícími jazyky a jejich koncepty maker:</div></p>

<ol>

<li>Práce s makry v&nbsp;programovacím jazyku Rust<br />
<a href="https://www.root.cz/clanky/prace-s-makry-v-programovacim-jazyku-rust/">https://www.root.cz/clanky/prace-s-makry-v-programovacim-jazyku-rust/</a>
</li>

<li>Programovací jazyk Julia: metaprogramování, makra a AST<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-julia-metaprogramovani-makra-a-ast/">https://www.root.cz/clanky/programovaci-jazyk-julia-metaprogramovani-makra-a-ast/</a>
</li>

</ol>

<p>Způsob definice maker se v&nbsp;některých ohledech podobá definici funkcí,
ale mezi funkcemi a makry existuje jeden zásadní rozdíl.</p>

<p>Funkce vytvořené v&nbsp;LISPu/Scheme/Clojure získávají jako svoje argumenty
<i>hodnoty</i>, tj.&nbsp;většinou atomy, (anonymní) funkce nebo seznamy, a
vrací taktéž nějakou hodnotu &ndash; opět se může jednat o atom, (anonymní)
funkci nebo seznam. Funkce jsou vyhodnocovány (volány) až při spuštění programu
a jejich argumenty jsou vyhodnocovány dříve, než se funkce zavolá. Makra ovšem
jako svůj vstup získávají lispovský kód (zapsaný formou rekurzivně zanořeného
seznamu) a vrací taktéž lispovský kód, což nepředstavuje oproti funkcím žádný
zásadnější rozdíl. Ovšem na rozdíl od funkcí jsou makra volána již při prvotním
zpracovávání programu, podobně jako jsou céčková makra zpracovávána céčkovým
preprocesorem (<strong>cpp</strong>) ještě před vlastní kompilací. Teprve
výsledek volání makra (nazývaný taktéž <i>expanze makra</i>) je považován za
zápis výrazu, který může být dále zpracován, tj.&nbsp;buď vyhodnocen
(interpretační varianty LISPu) nebo zkompilován (varianty LISPu vybavené
překladačem). Poznamenejme ještě, že v&nbsp;těle makra se může vyskytovat
volání dalšího makra, což znamená, že LISP musí při expanzi maker použít
rekurzi (tuto rekurzi lze v&nbsp;případě potřeby zakázat).</p>

<p><div class="rs-tip-major">Poznámka: různé varianty LISPu používají i různý
přístup ke tvorbě maker. V&nbsp;dnešním článku si nejprve (čistě pro porovnání
a pro zajištění kontextu) si nejprve ve stručnosti řekneme, jak je tato
problematika řešena <a href="#k01">v&nbsp;Common Lispu</a> a posléze i, jak
jsou makra implementována <a href="#k07">v&nbsp;programovacím jazyce
Clojure</a>. <a href="#k11">Druhá část článku</a> je pochopitelně věnována
jazyku <i>Racket</i>, jehož systém maker je poněkud odlišný.</div></p>

<p>Rozdíly mezi makry a funkcemi můžeme ve stručnosti shrnout takto:</p>

<table>
<tr><th>Funkce</th><th>Makro</th></tr>
<tr><td>volána v&nbsp;runtime</td><td>voláno (expandováno) v&nbsp;compile/eval time</td></tr>
<tr><td>na vstupu akceptuje libovolné hodnoty</td><td>akceptuje &bdquo;syntaktické objekty&ldquo;</td></tr>
<tr><td>na výstupu může vracet libovolnou hodnotu</td><td>výstupem je opět syntaktický objekt (expandované makro)</td></tr>
<tr><td>používá se pro implementaci knihoven i vlastních algoritmů</td><td>používá se pro rozšíření a úpravu sémantiky (DSL)</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Makra v&nbsp;Common Lispu</h2>

<p>Nejprve si ve stručnosti ukažme klasický makrosystém použitý
v&nbsp;<i>Common Lispu</i>. Při zápisu maker se poměrně často používají znaky
<strong>`</strong> (zpětný apostrof), <strong>,</strong> (čárka) a
<strong>@</strong> (zavináč). Zpětný apostrof se zapisuje před seznam, kde má
podobný význam jako běžný apostrof, který, jak již víme, zabraňuje tomu, aby
byl seznam vyhodnocen (jedná se o zkrácený zápis speciální formy
<strong>quote</strong>). V&nbsp;případě zpětného apostrofu je taktéž zabráněno
vyhodnocení seznamu, který se za apostrofem nachází, ovšem navíc lze uvnitř
takového seznamu použít symbol čárka, který označuje ty položky seznamu, které
se naopak vyhodnotit mají &ndash; díky tomu je možné přesně řídit, jak se má
seznam vyhodnotit, a to až na úroveň jeho jednotlivých prvků. Symbol zavináče
zapsaný (společně s&nbsp;čárkou) před nějakou položku seznamu taktéž vede
k&nbsp;vyhodnocení této položky, ale odlišným způsobem &ndash; položka (kterou
může být například další seznam) se přímo vloží do seznamu uvozeného zpětným
apostrofem.</p>

<p>Zní to celé složitě? Nejlepší bude, když si způsob použití všech tří symbolů
ukážeme na jednoduchých příkladech:</p>

<pre>
<i>; vytvoříme si dvě proměnné x a y obsahující hodnoty 1 a 2</i>
<strong>(setq x 1)</strong>
1
<strong>(setq y 2)</strong>
2
&nbsp;
<i>; pokus o vyhodnocení seznamu (x y) musí skončit chybou, protože</i>
<i>; x není jméno žádné funkce ale proměnné obsahující atom</i>
<strong>(x y)</strong>
*** - EVAL: undefined function X
&nbsp;
<i>; použití normálního apostrofu zabraňuje vyhodnocení seznamu</i>
<i>; (speciální forma quote)</i>
<strong>'(x y)</strong>
(X Y)
&nbsp;
<i>; použití zpětného apostrofu taktéž zabraňuje vyhodnocení seznamu</i>
<strong>`(x y)</strong>
(X Y)
&nbsp;
<i>; zabráníme vyhodnocení celého seznamu, ale naopak si vynutíme vyhodnocení y</i>
<strong>`(x ,y)</strong>
(X 2)
&nbsp;
<i>; zabráníme vyhodnocení celého seznamu, ale naopak si vynutíme vyhodnocení x</i>
<strong>`(,x y)</strong>
(1 Y)
&nbsp;
<i>; seznam jako celek vyhodnocen není (ty by vedlo k chybě - viz výše)</i>
<i>; ale jsou vyhodnoceny obě proměnné x a y</i>
<strong>`(,x ,y)</strong>
(1 2)
</pre>

<p>Vidíme tedy, že vyhodnocování seznamu a jeho položek můžeme velmi přesně
řídit a obejít tak standardní pravidla. Použití zavináče je ovšem již poněkud
komplikovanější:</p>

<pre>
; proměnná z obsahuje seznam se třemi symboly
(setq z '(www root cz))
(WWW ROOT CZ) 

; zabráníme vyhodnocení seznamu obsahujícího z (tedy další seznam)
`(1 2 3 z 4 5 6)
(1 2 3 Z 4 5 6)

; seznam jako celek není vyhodnocen, ale proměnná z ano
`(1 2 3 ,z 4 5 6)
(1 2 3 (WWW ROOT CZ) 4 5 6)

; podobné předchozímu, ovšem s tím rozdílem, že je seznam uložený
; v proměnné z "rozpuštěn" (zmizí závorky okolo trojice symbolů
; www root cz)
`(1 2 3 ,@z 4 5 6)
(1 2 3 WWW ROOT CZ 4 5 6)
</pre>

<p><div class="rs-tip-major">Poznámka: prozatím se může zdát, že symboly , ` a
@ mají jen minimální význam. Důležité ovšem je, že jejich zpracování se provádí
před spuštěním programu (nikoli v&nbsp;<i>runtime</i>), takže je lze použít pro
tvorbu a expanzi maker, což ostatně uvidíme hned <a
href="#k03">v&nbsp;navazující kapitole</a>.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Vytvoření makra v&nbsp;Common Lispu</h2>

<p>Nyní si konečně můžeme nějaké jednoduché makro ukázat. Namísto formy
<strong>defun</strong> se v&nbsp;Common Lispu při tvorbě maker používá
speciální forma pojmenovaná <strong>defmacro</strong>. Můžeme se tedy pokusit
vytvořit makro, které nahradí svůj parametr výrazem, jenž vypočítá druhou
mocninu tohoto parametru:</p>

<pre>
(defmacro <strong>Square</strong> (x) 
  `(* ,x ,x))
</pre>

<p>Toto makro funguje následujícím způsobem: při prvotním načítání LISPovských
výrazů (forem) se jakýkoli výskyt <strong>(Square cokoli)</strong> nahradí
formou <strong>(* cokoli cokoli)</strong> (zde je pěkně vidět, z&nbsp;jakého
důvodu existují symboly ` a ,). Teprve tato forma je předána interpretru nebo
překladači pro další zpracování, například přímému vyhodnocení. Když je
LISPovský program překládán, tak se přeloží až výsledek aplikace makra, což je
opět shodné se způsobem překladu céčkového programu.</p>

<p>Makro si můžeme ihned vyzkoušet:</p>

<pre>
<strong>(Square 42)</strong>
1764
&nbsp;
<strong>(Square (+ 1 2))</strong>
9
</pre>

<p><div class="rs-tip-major">Poznámka: toto makro je tak jednoduché, že
neukazuje celou sílu makrosystému Common Lispu. Ostatně podobného výsledku
dosáhneme i v&nbsp;C/C++, například takto:</div></p>

<pre>
#define Square(x) ((x)*(x))
</pre>

<p>Kvůli sémanticky omezenému makrosystému C je nutné symbol <strong>x</strong>
správně uzávorkovat.</p>

<p><div class="rs-tip-major">Poznámka: obě makra, tedy jak LISPovské, tak i
céčkovské, se ovšem budou chovat nekorektně, jak si to ukážeme <a
href="#k04">v&nbsp;další kapitole</a>.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Výpis expandovaného makra, řešení dvojího vyhodnocení parametrů</h2>

<p>Při tvorbě maker se může (a to velmi snadno a často :-) stát, že makro kvůli
nějaké chybě neprovádí přesně tu činnost, jakou programátor zamýšlel. Zatímco
funkce jsou volány až v&nbsp;době běhu programu, tj.&nbsp;je možné do jejich
těla vkládat různé ladicí příkazy (výpis hodnot, logování, aserce) či dokonce
běh programu trasovat, u maker to není možné, protože jsou expandována již při
překladu programu.</p>

<p>Ovšem v&nbsp;<i>Common Lispu</i> je možné si pomocí zabudované funkce
<strong>macroexpand</strong> nebo <strong>macroexpand-1</strong> zobrazit výpis
makra po expanzi, což může být velmi užitečné (podobně je možné si nechat
zobrazit výsledek činnosti preprocesoru programovacího jazyka C). Zatímco
funkce <strong>macroexpand</strong> zobrazí plně expandované makro
(tj.&nbsp;výsledný LISPovský kód po expanzi všech maker, a to i těch
vnořených), je po zavolání makra <strong>macroexpand-1</strong> zobrazeno makro
pouze po první expanzi, což znamená, že uvnitř expandovaného kódu se mohou
vyskytovat i volání dalších maker. V&nbsp;praxi se při ladění maker častěji
používá právě funkce <strong>macroexpand-1</strong>, jejíž použití je velmi
jednoduché, což si ostatně můžeme snadno ověřit:</p>

<pre>
<i>; nejprve znovu vytvoříme makro nazvané Square</i>
<strong>(defmacro Square (x)</strong>
  <strong>`(* ,x ,x))</strong>
&nbsp;
<i>; expanze makra při volání funkce Square s parametrem jenž je atomem</i>
<strong>(macroexpand-1 '(Square 42))</strong>
(* 42 42) ;
&nbsp;
<i>; expanze makra při volání funkce Square s parametrem jenž je formou</i>
<strong>(macroexpand-1 '(Square (+ 1 2)))</strong>
(* (+ 1 2) (+ 1 2)) ;
&nbsp;
<i>; makro se expanduje i v případě, že se použije neznámý symbol "plus"</i>
<strong>(macroexpand-1 '(Square (plus 1 2)))</strong>
(* (PLUS 1 2) (PLUS 1 2)) ;
</pre>

<p>Až při pohledu na expandované makro nás může napadnout, že vlastně nepracuje
dokonale, v&nbsp;některých případech dokonce pracuje chybně. Problém spočívá
v&nbsp;tom, že se předaný parametr po expanzi makra vyhodnocuje dvakrát, což
samozřejmě není větší problém v&nbsp;případě, že se předává/vyhodnocuje
atomická hodnota (číslo) nebo jednoduchý výraz, ovšem kdyby se jednalo
například o funkci načítající hodnotu z&nbsp;databáze nebo ze souboru
(popř.&nbsp;ze standardního vstupu), bylo by toto načítání prováděno dvakrát a
ne jedenkrát, jak by každý programátor při pohledu na program volající makro
očekával. Můžeme si to ostatně vyzkoušet (funkce <strong>read</strong> provádí
načtení výrazu ze standardního vstupu):</p>

<pre>
<strong>(Square (read))</strong>
2 <i>; zadáno uživatelem z klávesnice</i>
3 <i>; zadáno (druhá a jiná! hodnota) taktéž z klávesnice</i>
6 <i>; výsledek volání makra = 2*3</i>
</pre>

<p>Makro se můžeme pokusit &bdquo;opravit&ldquo; například tak, že se použije
pomocná lokální proměnná <i>temp</i>:</p>

<pre>
<strong>(defmacro Square2 (x)</strong>
    <strong>`(let ((temp ,x)) (* temp temp)))</strong>
&nbsp;
<i>; podíváme se na expanzi při jeho volání</i>
<i>; s parametrem (+ 1 2)</i>
<strong>(macroexpand-1 '(Square2 (+ 1 2)))</strong>
(LET ((TEMP (+ 1 2))) (* TEMP TEMP)) ;
<i>; vidíme, že se výraz (+ 1 2) vyhodnocuje pouze jedenkrát</i>
&nbsp;
<i>; otestujeme volání makra při předání funkce read</i>
<strong>(Square2 (read))</strong>
2 <i>; zadáno uživatelem z klávesnice</i>
4 <i>; správný výsledek a navíc program vyžadoval pouze jediný vstup z klávesnice</i>
</pre>

<p>Pomocí <strong>macroexpand-1</strong> je možné prozkoumat i makra dostupná
v&nbsp;základní knihovně jazyka:</p>

<pre>
<i>; makra or a and jsou implementovány tak, aby podporovaly</i>
<i>; zkrácené vyhodnocení logických výrazů</i>
<strong>(macroexpand-1 '(or foo bar))</strong>
(COND (FOO) (T BAR)) ;
&nbsp;
<strong>(macroexpand-1 '(and (foo t) (foo nil)))</strong>
(COND ((NOT (FOO T)) NIL) (T (FOO NIL))) ;
</pre>

<p><div class="rs-tip-major">Poznámka: mohlo by se zdát, že jsme všechny
problémy makra vyřešili. Ovšem u složitějších maker musíme zajistit ještě jednu
&bdquo;maličkost&ldquo; &ndash; interní lokální proměnné vytvořené při expanzi
makra by měly mít unikátní jméno, aby se náhodou nestalo, že makro bude voláno
s&nbsp;parametry, které se budou jmenovat stejně, jako lokální proměnné makra.
Tento problém je v&nbsp;Racketu (popsaného ve druhé částí článku) řešen
elegantněji.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Typické Common Lispovské makro &bdquo;loop&ldquo;: operace nad seznamy</h2>

<p>Jedním z&nbsp;nejužitečnějších maker, které se nachází ve standardní
knihovně <i>Common Lispu</i>, je makro nazvané prozaicky <strong>loop</strong>,
jenž je doplněné o několik dalších pomocných maker a symbolů (ty jsou použity
pro doplnění syntaxe o další &bdquo;klíčová slova&ldquo;).</p>

<p>S&nbsp;využitím makra <strong>loop</strong> lze v&nbsp;<i>LISPu</i>
(tj.&nbsp;jazyku založeném částečně na funkcionálním paradigmatu, který původně
vedl uživatele k&nbsp;používání rekurze namísto psaní programových smyček)
realizovat značné množství různých typů programových smyček, například smyčky
počítané (s&nbsp;možností změny kroku, o který se změní hodnota čítače či
čítačů smyček při každé iteraci), smyčky s&nbsp;podmínkou (odpovídá například
Pascalovským smyčkám typu <strong>while-do</strong> a
<strong>repeat-until</strong>) či iterační smyčky, která v&nbsp;každé iteraci
operuje nad prvky seznamů, polí či asociativních polí
(<strong>for-each</strong>). Na příkladu makra <strong>loop</strong> je pěkně a
názorně ukázána jedna z&nbsp;největších výhod <i>LISPovských</i> maker &ndash;
právě pomocí maker a některých dalších vlastností <i>LISPu</i> je možné
v&nbsp;případě potřeby vytvořit zcela nový jazyk s&nbsp;vlastní syntaxí
(doménově specifický jazyk).</p>

<p>Na následujících demonstračních příkladech si ukážeme některé možnosti,
které makro <strong>loop</strong> programátorům nabízí:</p>

<p>Smyčka, která postupně iteruje nad všemi elementy uloženými v&nbsp;seznamu
(tj.&nbsp;postupně všemi prvky prochází):</p>

<pre>
<strong>(loop for i in '(a b c d) do (print i))</strong>
&nbsp;
A
B
C
D
</pre>

<p><div class="rs-tip-major">Poznámka: samotné makro <strong>loop</strong>
vrací jako svoji návratovou hodnotu (většinou) atom <strong>NIL</strong>, který
ve výpisech pro větší přehlednost neuvádím. Pokud si příklady budete sami
spouštět v&nbsp;interpretru Common Lispu, bude po skončení smyčky na standardní
výstup navíc vypsán řádek obsahující právě <strong>NIL</strong>.</div></p>

<p>Pokud se ve zpracovávaném seznamu nachází další rekurzivně vnořené seznamy,
jsou při iterování seznamem chápány jako jeden prvek:</p>

<pre>
<strong>(loop for i in '(a (b c) d) do (print i))</strong>
&nbsp;
A 
(B C) 
D 
</pre>

<p>Programová smyčka, která postupně iteruje (prochází) přes CDR zvoleného
seznamu.  V&nbsp;první iteraci je do proměnné <i>i</i> přiřazen celý seznam
<i>s</i>, ve druhé iteraci <i>(cdr s)</i>, ve třetí iteraci <i>(cdr (cdr
s))</i> atd.:</p>

<pre>
<strong>(loop for i on '(a b c d) do (print i))</strong>
&nbsp;
(A B C D)
(A B C)
(B C)
(C)
</pre>

<p>Zpracování seznamu obsahujícího ve druhém prvku podseznam:</p>

<pre>
<strong>(loop for i on '(a (b c) d) do (print i))</strong>
&nbsp;
(A (B C) D) 
((B C) D) 
(D) 
</pre>

<p>Iterace nad dvojicí seznamů a postupná konstrukce seznamu obsahujícího
dvojice prvků ze seznamu prvního a druhého. Výsledek není v&nbsp;tomto případě
tisknut, ale je vrácen jako návratová hodnota smyčky, tj.&nbsp;lze ho například
přiřadit proměnné:</p>

<pre>
<strong>(loop for x in '(a b c d e)</strong>
      <strong>for y in '(1 2 3 4 5)</strong>
      <strong>collect (list x y))</strong>
&nbsp;
((A 1) (B 2) (C 3) (D 4) (E 5))
</pre>

<p>Přiřazení výsledného seznamu vytvořeného smyčkou do proměnné:</p>

<pre>
<strong>(setq a (loop for x in '(a b c d e)</strong>
              <strong>for y in '(1 2 3 4 5)</strong>
              <strong>collect (list x y)))</strong>
&nbsp;
((A 1) (B 2) (C 3) (D 4) (E 5))
&nbsp;
<i>; tisk hodnoty proměnné a</i>
<strong>a</strong>
((A 1) (B 2) (C 3) (D 4) (E 5))
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Další příklady použití knihovního makra &bdquo;loop&ldquo;: počítané smyčky</h2>

<p><a href="#k05">V&nbsp;předchozím textu</a> jsme si řekli, že makro
<strong>loop</strong> je možné použít mj.&nbsp;i pro tvorbu takzvaných
počítaných smyček, tj.&nbsp;takových smyček, které v&nbsp;každé iteraci zvyšují
nebo naopak snižují hodnotu čítače (lokální proměnné platné v&nbsp;rámci
smyčky). Syntaxe, kterou makro <strong>loop</strong> pro tento typ smyček
používá, je v&nbsp;mnoha ohledech podobná syntaxi Pascalu či některých verzí
starobylého Basicu, jak se ostatně můžete sami přesvědčit na následujících
demonstračních příkladech.</p>

<p>Nejprve je uveden základní tvar počítané smyčky se zadáním horní a dolní
meze čítače. Hodnota čítače se v&nbsp;tomto případě v&nbsp;každé iteraci
zvětšuje o jedničku, jak je to ostatně u počítaných smyček běžné:</p>

<pre>
<strong>(loop for i from 1 to 10 do (print i))</strong>
&nbsp;
1
2
3
4
5
6
7
8
9
10
</pre>

<p>Počítaná smyčka s&nbsp;čítačem, jehož hodnota se v&nbsp;každé iteraci
zmenšuje. Povšimněte si použití slova <strong>downto</strong>, které se
vyskytuje například i v&nbsp;Pascalu:</p>

<pre>
<strong>(loop for i from 10 downto 1 do (print i))</strong>
&nbsp;
10
9
8
7
6
5
4
3
2
1
</pre>

<p>U počítaných smyček lze měnit krok, tj.&nbsp;hodnotu, o kterou se čítač
smyčky v&nbsp;každé iteraci zvětší nebo naopak zmenší. Zde se použije slovo
<strong>by</strong>:</p>

<pre>
<strong>(loop for i from 1 to 10 by 1.5 do (print i))</strong>
&nbsp;
1
2.5
4.0
5.5
7.0
8.5
10.0
</pre>

<p>V&nbsp;mnoha implementacích programovacího jazyka <i>LISP</i> je podporován
i numerický datový typ &bdquo;zlomek&ldquo;, což je racionální číslo vyjádřené
čitatelem a jmenovatelem odděleným znakem / (lomítko). V&nbsp;počítaných
smyčkách lze samozřejmě zlomky využívat, jak je to patrné z&nbsp;následujících
dvou příkladů:</p>

<pre>
<strong>(loop for i from 0 to 10 by 3/2 do (print i))</strong>
&nbsp;
0
3/2
3
9/2
6
15/2
9
&nbsp;
<strong>(loop for i from 10 downto 0 by 4/3 do (print i))</strong>
&nbsp;
10
26/3
22/3
6
14/3
10/3
2
2/3
</pre>

<p>Hodnoty čítače je možné v&nbsp;případě potřeby omezit prakticky libovolnou
podmínkou. V&nbsp;následujícím příkladu je použit predikát
<strong>evenp</strong>, který vrací hodnotu T (pravda) v&nbsp;tom případě, kdy
je parametr tohoto predikátu sudé číslo:</p>

<pre>
<strong>(loop for i from 1 to 10 when (evenp i) do (print i))</strong>
&nbsp;
2
4
6
8
10
</pre>

<p>Hodnoty, kterých postupně nabývá čítač smyčky, lze mít uloženy
v&nbsp;seznamu (i když tento příklad je poněkud umělý, protože lze napsat
jednodušším způsobem):</p>

<pre>
<strong>(loop with a = '(1 42 3) for i in a do (print i))</strong>
&nbsp;
1
42
3
</pre>

<p>Na závěr si ukážeme způsob zápisu programové smyčky, která současně prochází
všemi prvky seznamu a navíc mění hodnotu čítače. Právě tento typ smyčky mnohdy
citelně chybí v&nbsp;ostatních programovacích jazycích, které nabízí buď
striktně počítanou smyčku nebo smyčku typu <i>for-each</i>:</p>

<pre>
<strong>(loop for x in '(a b c d e)</strong>
      <strong>for y from 1 do</strong>
      <strong>(format t "~s = ~s~%" y x))</strong>
&nbsp;
1 = A
2 = B
3 = C
4 = D
5 = E
</pre>

<p><div class="rs-tip-major">Poznámka: funkce <strong>format</strong> se
v&nbsp;mnoha ohledech podobá například céčkové funkci <strong>printf</strong>.
Prvním parametrem této funkce je výstupní proud, do kterého se má výsledek
tisknout (s&nbsp;tou výjimkou, že <strong>nil</strong> značí, že se výsledek
nikam netiskne, ale je navrácen ve formě řetězce, a <strong>T</strong> naopak
odpovídá standardnímu výstupu), druhým parametrem je formátovací řetězec a
další parametry jsou postupně tisknuty na výstup podle pravidel zadaných ve
formátovacím řetězci. Ve výše uvedeném příkladu jsou použita dvě formátovací
pravidla: <strong>~s</strong> = tisk hodnoty, <strong>~%</strong> =
odřádkování.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Základy práce se systémem maker v&nbsp;programovacím jazyku Clojure</h2>

<p>V&nbsp;této části článku si ukážeme základní koncepty práce s&nbsp;makry
v&nbsp;jazyku Clojure. Základní vlastnosti samotného interpretu jazyka
<i>Clojure</i> jsou přitom odvozeny od interpretrů používaných ve většině
variant programovacího jazyka <i>LISP</i>, což znamená, že autoři
<i>Clojure</i> (resp.&nbsp;přesněji řečeno především jeho původní a dodnes
pravděpodobně nejaktivnější autor <i>Rich Hickley</i>) vychází z&nbsp;ověřených
technologií, které byly poprvé implementovány již před více než padesáti roky
v&nbsp;rámci vývoje <i>LISPu</i> a na něj navazujících jazyků (<i>Scheme</i>).
Základem interpretru programovacího jazyka <i>Clojure</i> je, stejně jako
v&nbsp;<i>LISPu</i>, smyčka nazývaná <strong>REPL</strong>
(<i>Read-Evaluate-Print-Loop</i>), jejíž název vyplývá z&nbsp;toho, že mohla
být relativně jednoduše implementována způsobem ukázaným pod tímto odstavcem.
Ostatně z&nbsp;historického pohledu je zajímavé, že nějak podobně vlastně
<i>LISP</i> vznikl, když si jeho autor (<i>John McCarthy</i>) uvědomil, že na
základě implementace rekurzivní podoby funkce <strong>eval</strong> a několika
dalších pomocných funkcí dokáže vytvořit plnohodnotný programovací jazyk (viz
též úvodní článek tohoto seriálu):</p>

<pre>
<strong>(loop (print (eval (read))))</strong>
</pre>

<p>Není bez zajímavosti, že s&nbsp;<i>AST</i> se v&nbsp;<i>LISP/Clojure</i>
může manipulovat za použití stejných mechanismů (funkcí/forem/maker), které se
používají i při běžném programování &ndash; jinými slovy to znamená, že
<i>jazyk maker</i> je stále jazykem, v&nbsp;němž se zapisují programy (na
rozdíl od zmíněného céčka a C++, kde je jazyk maker zcela odlišný).</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. První písmeno ve zkratce REPL: objekt Reader a jeho makra</h2>

<p>Před popisem systému maker v&nbsp;programovacím jazyku <i>Clojure</i> si
ještě musíme říci, že ve skutečnosti existují dva typy maker &ndash; takzvaná
<i>reader macros</i>, neboli makra zabudovaná přímo do objektu/modulu, který
načítá formy ze standardního vstupu a potom běžná makra známá i z&nbsp;dalších
lispovských programovacích jazyků.</p>

<p>Nejprve se budeme zabývat makry používanými při načítání forem ze
standardního vstupu. Důvodů, proč je lepší začít s&nbsp;popisem této skupiny
maker je více, například fakt, že tato makra nelze vytvářet a existující makra
nelze modifikovat (na rozdíl od výše zmíněného <i>Common Lispu</i>, kde to
možné je) a taktéž to, že se tato makra používají v&nbsp;prakticky všech
zdrojových kódech, aniž by si vývojáři většinou uvědomovali, že ve svých
programech vůbec nějaká makra používají :-) Důvod existence <i>reader maker</i>
je jednoduchý &ndash; umožňují zkrácení zápisu programů, zajišťují možnost
zápisu komentářů (ty totiž nejsou považovány za běžné formy, protože nevrací
žádnou hodnotu, ani <strong>nil</strong>) a taktéž je možné s&nbsp;pomocí
tohoto typu maker přidávat k&nbsp;symbolům, seznamům, vektorům, mapám atd.
takzvaná metadata.</p>

<p>Zjednodušeně řečeno je možné říci, že <i>reader</i> makra pracují podobně
jako preprocesor v&nbsp;programovacích jazycích C a C++, protože text
zapisovaný či posílaný na standardní vstup je nejprve těmito makry zpracován a
posléze je &ndash; stále v&nbsp;textové podobě &ndash; poslán funkci
<i>read</i> pro parsing a vyhodnocení. Tato makra tedy slouží pro provádění
&bdquo;pouhých&ldquo; textových substitucí a nikoli k&nbsp;modifikaci AST, jak
je tomu u běžných maker. Která <i>reader</i> makra jsou v&nbsp;programovacím
jazyku <i>Clojure</i> podporována, nám prozradí následující tabulka, z&nbsp;níž
je patrné, že některá makra provádí skutečně značně jednoduchou činnost,
například pouhé odstranění komentářů:</p>

<table>
<tr><th>#</th><th>Makro</th><th>Název</th><th>Význam</th></tr>
<tr><td>1</td><td>;</td><td>comment</td><td>umožňuje obejít zápis <i>(comment nějaký text)</i> u komentářů</td></tr>
<tr><td>2</td><td>\</td><td>character</td><td>používané při zápisu znakových literálů</td></tr>
<tr><td>3</td><td>^</td><td>metadata</td><td>přidání metadat k&nbsp;symbolům, seznamům, vektorům, mapám a množinám</td></tr>
<tr><td>4</td><td>'</td><td>quote</td><td>nahrazuje zápis <i>(quote ...)</i></td></tr>
<tr><td>5</td><td>`</td><td>syntax-quote</td><td>provádí plnou kvalifikaci symbolů + zde lze použít makra ~ a ~@</td></tr>
<tr><td>6</td><td>~</td><td>unquote</td><td>zajistí, že se vyhodnotí pouze označená část formy (= provede substituci této části výsledkem)</td></tr>
<tr><td>7</td><td>~@</td><td>unquote-splicing</td><td>podobné předchozími makru, ovšem výsledná sekvence se vloží ve formě samostatných prvků do &bdquo;obalující&ldquo; sekvence</td></tr>
<tr><td>8</td><td>@</td><td>deref</td><td>nahrazuje zápis <i>(deref ...)</i></td></tr>
<tr><td>9</td><td>#</td><td>dispatch</td><td>má různé funkce: donutí reader, aby použil makro z&nbsp;jiné tabulky maker</td></tr>
</table>

<p>S&nbsp;popisem maker vestavěných do objektu <i>Reader</i> začneme jen
pozvolna, napřed si totiž popíšeme ta nejjednodušší makra. V&nbsp;jazyku
Clojure je nejjednodušším <i>reader makrem</i> s&nbsp;velkou pravděpodobností
makro nazvané &bdquo;comment&ldquo; zapisované pomocí znaku ; (středník).
Veškerý text, který je zapsaný mezi středníkem a koncem řádku je ignorován,
takže toto makro lze použít pro jednoduchý zápis jednořádkových komentářů.
Pokud by toto <i>reader</i> makro neexistovalo, muselo by se pro zápis
komentářů namísto toho používat normální makro <strong>comment</strong>, které
se však musí zapisovat stejně, jako jakákoli jiná forma, tj.&nbsp;i
s&nbsp;kulatými závorkami, což na čitelnosti komentářů určitě nepřidá. Nicméně
makro <strong>comment</strong> má svou nezastupitelnou úlohu, protože pomocí
něho můžeme do komentáře &bdquo;uzavřít&ldquo; i delší část kódu &ndash;
ostatně toto makro je použito i v&nbsp;samotných zdrojových kódech jazyka
<i>Clojure</i>.</p>

<p>Podívejme se nyní na několik jednoduchých demonstračních příkladů:</p>

<pre>
<i>; jednořádkové komentáře</i>
user=&gt; <strong>; toto je komentar</strong>
user=&gt; <strong>; ignorovany v REPL\</strong>
user=&gt;
&nbsp;
<i>; víceřádkový komentář</i>
user=&gt; <strong>(comment</strong>
<strong>komentar</strong>
<strong>muze</strong>
<strong>mit</strong>
<strong>nekolik</strong>
<strong>radku)</strong>
<i>; povšimněte si, že (comment) vrací hodnotu <strong>nil</strong></i>
nil
&nbsp;
user=&gt;
</pre>

<p><div class="rs-tip-major">Poznámka: zápis <strong>user=&gt;</strong>
představuje standardní výzvu (<i>prompt</i>) interpretru programovacího jazyka
Clojure.</div></p>

<p>Další velmi často používané <i>reader makro</i> se zapisuje s&nbsp;využitím
znaku \ (zpětné lomítko). Toto makro slouží pro zápis znakových konstant
(literálů) do zdrojového kódu. Tisknutelné znaky je možné zapsat buď přímo za
zpětné lomítko, nebo je možné použít kód libovolného znaku z&times;Unicode,
přičemž kód tohoto znaku musí být zapsán v&nbsp;hexadecimální soustavě za
dvojici znaků "\u":</p>

<pre>
<i>; běžný tisknutelný znak:</i>
user=&gt; <strong>\a</strong>
\a
&nbsp;
<i>; další běžný tisknutelný znak:</i>
user=&gt; <strong>\1</strong>
\1
&nbsp;
<i>; znak "u":</i>
user=&gt; <strong>\u</strong>
\u
<i>; znak s hexadecimální hodnotou 0x40, neboli 64:</i>
&nbsp;
user=&gt; <strong>\u0040</strong>
\@
&nbsp;
<i>; pokus o zápis neplatného znakového literálu:</i>
user=&gt; <strong>\aa</strong>
RuntimeException Unsupported character: \aa  clojure.lang.Util.runtimeException (Util.java:170)
&nbsp;
user=&gt;
</pre>

<p>Posledním &bdquo;jednoduchým&ldquo; <i>reader makrem</i> je makro zapisované
s&nbsp;využitím znaku ^. Toto makro slouží k&nbsp;přiřazení metadat
k&nbsp;symbolu, seznamu, vektoru, množině či mapě. Základní způsob využití
makra ^ je následující:</p>

<pre>
<i>; nastavení metadat k vektoru</i>
user=&gt; <strong>^{:atribut1 "Hodnota1" :atribut2 "Hodnota2"} [1 2 3]</strong>
[1 2 3]
&nbsp;
<i>; uložení vektoru a k němu přiřazeným metadatům</i>
<i>; do proměnné vektor</i>
user=&gt; <strong>(def vektor ^{:atribut1 "Hodnota1" :atribut2 "Hodnota2"} [1 2 3])</strong>
#'user/vektor
&nbsp;
<i>; přečtení stavu proměnné vektor</i>
user=&gt; <strong>vektor</strong>
[1 2 3]
&nbsp;
<i>; přečtení metadat přiřazených k proměnné vektor</i>
user=&gt; <strong>(meta vektor)</strong>
{:atribut2 "Hodnota2", :atribut1 "Hodnota1"}
&nbsp;
user=&gt;
</pre>

<p>Navíc existuje i alternativní způsob použití makra ^, který slouží pro
naplnění jediného atributu s&nbsp;názvem :tag:</p>

<pre>
<i>; uložení vektoru a k němu přiřazeným metadatům</i>
<i>; do proměnné vektor</i>
user=&gt; <strong>(def vektor ^"xyzzy" [1 2 3])</strong>
#'user/vektor
&nbsp;
<i>; přečtení stavu proměnné vektor</i>
user=&gt; <strong>vektor</strong>
[1 2 3]
&nbsp;
<i>; přečtení metadat přiřazených k proměnné vektor</i>
user=&gt; <strong>(meta vektor)</strong>
{:tag "xyzzy"}
&nbsp;
user=&gt;
</pre>

<p>Makro &bdquo;deref&ldquo; má již složitější chování. Může být použito pro
přečtení hodnoty, přesněji řečeno stavu reference a v&nbsp;programovacím jazyku
Clojure se používá u mnoha typů referencí (referenčních typů):</p>

<table>
<tr><th>#</th><th>Referenční typ</th></tr>
<tr><td>1</td><td>@ref</td></tr>
<tr><td>2</td><td>@agent</td></tr>
<tr><td>3</td><td>@var</td></tr>
<tr><td>4</td><td>@atom</td></tr>
<tr><td>5</td><td>@delay</td></tr>
<tr><td>6</td><td>@future</td></tr>
<tr><td>7</td><td>@promise</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: v&nbsp;jazyku Clojure se nepoužívají
proměnné v&nbsp;běžném smyslu tohoto slova. Namísto proměnných se používají
právě různé typy referencí.</div></p>

<p>Chování makra @ se však u různých typů referencí liší. Zatímco
<strong>@ref</strong>, <strong>@var</strong> či <strong>@atom</strong> pouze
vrátí aktuální stav reference, v&nbsp;případě použití <strong>@future</strong>,
<strong>@promise</strong> či <strong>@agent</strong> se ve skutečnosti musí
počkat na dokončení (asynchronního) výpočtu, který běží v&nbsp;jiném vláknu.
Pro jistotu si připomeňme tabulku s&nbsp;funkcemi a makry použitými při práci
s&nbsp;nejdůležitějšími referenčními typy:</p>

<table>
<tr><th>#</th><th>Typ</th><th>Var</th><th>Ref</th><th>Atom</th><th>Agent</th></tr>
<tr><td>1</td><td>Vytvoření</td><td>(def name value)</td><td>(ref value)</td><td>(atom value)</td><td>(agent value)</td></tr>
<tr><td>2</td><td>Nastavení hodnoty</td><td>(set! name value)</td><td>(ref-set ref value)</td><td>(reset! atom value)</td><td>&times;</td></tr>
<tr><td>3</td><td>Aplikace funkce</td><td>&times;</td><td>(alter ref funkce)</td><td>(swap! atom funkce)</td><td>(send agent funkce)</td></tr>
<tr><td>4</td><td>Čtení hodnoty</td><td>name</td><td>@ref</td><td>@atom</td><td>@agent</td></tr>
</table>

<p>Demonstrační příklad na použití referencí typu ref, tedy
&bdquo;normálních&ldquo; proměnných platných v&nbsp;rámci aktuálního jmenného
prostoru (ve skutečnosti je s&nbsp;referencemi typu ref možné provádět mnoho
operací, které by s&nbsp;běžnými proměnnými nebyly možné):</p>

<pre>
<i>; vytvoření refu</i>
user=&gt; <strong>(def my-ref (ref 42))</strong>
#'user/my-ref
&nbsp;
<i>; vytvoření refu</i>
user=&gt; <strong>(def string-ref (ref "Hello world"))</strong>
#'user/string-ref
&nbsp;
<i>; přečtení refu pomocí makra @</i>
user=&gt; <strong>@my-ref</strong>
42
&nbsp;
<i>; přečtení refu pomocí makra @</i>
user&gt; <strong>@string-ref</strong>
"Hello world"
&nbsp;
user=&gt;
</pre>

<p>Demonstrační příklad na použití atomů a samozřejmě i makra @:</p>

<pre>
<i>; vytvoření nového atomu</i>
user=&gt; <strong>(def x (atom 42))</strong>
#'user/x
&nbsp;
<i>; globální symbol x je navázán</i>
<i>; na atom a nikoli na stav identity</i>
<i>; (=hodnotu)</i>
user=&gt; <strong>x</strong>
#&lt;Atom@61a907: 42&gt;
&nbsp;
<i>; pro získání aktuálního stavu</i>
<i>; je nutné použít dereferenci</i>
user=&gt; <strong>(deref x)</strong>
42
&nbsp;
<i>; namísto (deref x) se používá</i>
<i>; makro preprocesoru @</i>
user=&gt; <strong>@x</strong>
42
&nbsp;
&nbsp;
<i>; atomická změna stavu identity</i>
user=&gt; <strong>(reset! x 10)</strong>
10
&nbsp;
user=&gt; <strong>(reset! x (+ 1 2 3))</strong>
6
&nbsp;
user=&gt; <strong>@x</strong>
7
&nbsp;
&nbsp;
<i>; další možnost atomické změny</i>
<i>; stavu identity - nyní přes funkci</i>
<i>; aplikovanou na atom a popř. i další</i>
<i>; parametry</i>
user=&gt; <strong>(swap! x + 1)</strong>
7
&nbsp;
user=&gt; <strong>@x</strong>
7
&nbsp;
user=&gt;
</pre>

<p>Příklad vytvoření agenta, poslání funkce agentovi a čekání na dokončení
výpočtu právě s&nbsp;použitím makra @:</p>

<pre>
<i>; vytvoření agenta</i>
user=&gt; <strong>(def my-agent (agent 0))</strong>
#'user/my-agent
&nbsp;
<i>; poslání funkce agentovi (6 je druhý parametr funkce)</i>
user=&gt; <strong>(send my-agent + 6)</strong>
#&lt;Agent@18622f3: 0&gt;
&nbsp;
<i>; poslání funkce agentovi (7 je druhý parametr funkce)</i>
user=&gt; <strong>(send my-agent * 7)</strong>
#&lt;Agent@18622f3: 6&gt;
&nbsp;
<i>; dereference - získání nového stavu - pomocí makra @</i>
user=&gt; <strong>@my-agent</strong>
42
&nbsp;
user=&gt;
</pre>

<p>Další příklad s&nbsp;makrem @, tentokrát použitým pro objekty
<i>future</i>:</p>

<pre>
<i>; vytvoření objektu typu future a spuštění paralelního vlákna</i>
user=&gt; <strong>(def future_fibonacci1 (future (fibonacci 35)))</strong>
#'user/future_fibonacci1
&nbsp;
<i>; vytvoření dalšího objektu typu future a spuštění paralelního vlákna</i>
user=&gt; <strong>(def future_fibonacci2 (future (fibonacci 35)))</strong>
#'user/future_fibonacci2
&nbsp;
<i>; čekání na dokončení prvního paralelně běžícího výpočtu</i>
<i>; - zde se využívá makro @</i>
user=&gt; <strong>@future_fibonacci1</strong>
9227465
&nbsp;
<i>; čekání na dokončení druhého paralelně běžícího výpočtu</i>
<i>; - zde se využívá makro @</i>
user=&gt; <strong>@future_fibonacci2</strong>
9227465
&nbsp;
user=&gt;
</pre>

<p>Poslední demonstrační příklad: makro @ a objekty typu <i>promise</i>:</p>

<pre>
<i>; vytvoření objektu typu promise</i>
<i>; a navázání na symbol promise-test</i>
user=&gt; <strong>(def promise-test (promise))</strong>
#'user/promise-test
&nbsp;
<i>; nastavení hodnoty</i>
user=&gt; <strong>(deliver promise-test 42)</strong>
#&lt;core$promise$reify__6153@1318b: 42&gt;
&nbsp;
<i>; získání nastavené hodnoty pomocí makra @</i>
user=&gt; <strong>@promise-test</strong>
42
&nbsp;
user=&gt;
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Makra &bdquo;quote&ldquo; a &bdquo;syntax-quote&ldquo;</h2>

<p>Konečně se dostáváme k&nbsp;zajímavějším a užitečnějším makrům, které
přibližují možnosti Clojure Common Lispu i dalším pokročilejším lispovským
jazykům, pochopitelně včetně Racketu. Jedno z&nbsp;nejdůležitějších a
nejčastěji používaných maker se jmenuje &bdquo;quote&ldquo; a zapisuje se
pomocí apostrofu. Toto makro zakazuje vyhodnocování seznamů, protože pokud by
objekt <i>reader</i> načetl formu ve tvaru <strong>(a b c)</strong>, předal by
ji do funkce <i>eval</i>, kde by se tato forma vyhodnotila jako volání funkce
<strong>a</strong> s&nbsp;parametry <strong>b</strong> a <strong>c</strong>.
Pokud však <i>reader</i> načte formu <strong>'(a b c)</strong>, ztransformuje
ji do tvaru <strong>(quote (a b c))</strong>, přičemž <strong>quote</strong> je
speciální forma zakazující vyhodnocení. Na většinu ostatních objektů kromě
seznamů nemá makro &bdquo;quote&ldquo; většinou žádný vliv:</p>

<pre>
<i>; zde nemá quote žádný vliv</i>
user=&gt; <strong>'42</strong>
42
&nbsp;
<i>; zákaz vyhodnocení seznamů jako funkce</i>
user=&gt; <strong>'(1 2 3)</strong>
(1 2 3)
&nbsp;
<i>; zde nemá quote žádný vliv</i>
user=&gt; <strong>'[1 2 3]</strong>
[1 2 3]
&nbsp;
<i>; stejné jako předchozí forma</i>
user=&gt; <strong>[1 2 3]</strong>
[1 2 3]
&nbsp;
<i>; zákaz vyhodnocení seznamů jako funkce</i>
user=&gt; <strong>'(* 6 7)</strong>
(* 6 7)
&nbsp;
<i>; zde se však seznam vyhodnotí jako funkce *</i>
user=&gt; <strong>(* 6 7)</strong>
42
&nbsp;
user=&gt;
</pre>

<p>Kromě makra &bdquo;quote&ldquo; ještě objekt <i>reader</i> rozeznává poněkud
komplikovanější makro nazývané &bdquo;syntax-quote&ldquo;, které se zapisuje
pomocí zpětného apostrofu: `. Chování tohoto makra se liší podle toho,
s&nbsp;jakým typem objektu je použito, ovšem ve všech případech se makro chová
tak, aby nedocházelo k&nbsp;vyhodnocení jeho argumentů, popř.&nbsp;ani
k&nbsp;vyhodnocení vnořených forem.</p>

<p><div class="rs-tip-major">Poznámka: podobnost s&nbsp;Common Lispem
pochopitelně není náhodná.</div></p>

<p>V&nbsp;následujících příkladech dochází k&nbsp;jednoduchému zákazu
vyhodnocení předané formy:</p>

<pre>
user=&gt; <strong>`42</strong>
42
&nbsp;
user=&gt; <strong>`(1 2 3)</strong>
(1 2 3)
&nbsp;
user=&gt; <strong>`[1 2 3]</strong>
[1 2 3]
&nbsp;
user=&gt;
</pre>

<p>Dále toho makro dokáže nahradit zjednodušené jméno symbolu jeho plně
kvalifikovaným jménem. Nejlépe si to opět ukážeme na několika příkladech:</p>

<pre>
user=&gt; <strong>`seq</strong>
clojure.core/seq
&nbsp;
user=&gt; <strong>`map</strong>
clojure.core/map
&nbsp;
user=&gt; <strong>`Integer/valueOf</strong>
java.lang.Integer/valueOf
&nbsp;
user=&gt;
</pre>

<p>Zákaz vyhodnocení a současně i náhrada zjednodušeného jména symbolu na plně
kvalifikované jméno se projeví tím, že se následující seznamy (a vektor na
konci) nevyhodnotí jako funkce, ale například funkce * se nahradí plným
jménem:</p>

<pre>
user=&gt; <strong>`(* 6 7)</strong>
(clojure.core/* 6 7)
&nbsp;
user=&gt; <strong>`(str "Hello" "world")</strong>
(clojure.core/str "Hello" "world")
&nbsp;
user=&gt; <strong>`[* seq str xyzzy neznamy]</strong>
[clojure.core/* clojure.core/seq clojure.core/str user/xyzzy user/neznamy]
&nbsp;
user=&gt;
</pre>

<p><div class="rs-tip-major">Poznámka: toto chování je důležité právě při
expanzi maker.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Makra &bdquo;unquote&ldquo; a &bdquo;unquote-splicing&ldquo;</h2>

<p>Makro nazvané &bdquo;unquote&ldquo;, které se zapisuje s&nbsp;využitím znaku
~ (tilda), dokáže vynutit vyhodnocení určité části výrazu, a to tehdy, pokud je
tento výraz umístěn v&nbsp;makru ` (syntax-quote), nikoli však ' (quote).</p>

<p><div class="rs-tip-major">Poznámka: povšimněte si podobnosti s&nbsp;čárkou
použitou v&nbsp;Common Lispu pro podobné účely.</div></p>

<p>Nejprve si ukažme způsob zápisu tohoto makra i to, jaký má toto makro vliv
na zapisované výrazy:</p>

<pre>
<i>; makro quote zakáže vyhodnocení celého seznamu</i>
user=&gt; <strong>'(1 2 (* 6 7) (/ 4 2))</strong>
(1 2 (* 6 7) (/ 4 2))
&nbsp;
<i>; makro syntax-quote zakáže vyhodnocení taktéž a</i>
<i>; současně provede náhradu jmen funkcí za jejich plný tvar</i>
user=&gt; <strong>`(1 2 (* 6 7) (/ 4 2))</strong>
(1 2 (clojure.core/* 6 7) (clojure.core// 4 2))
&nbsp;
<i>; pomocí ~ vynutíme vyhodnocení podvýrazu (* 6 7)</i>
user=&gt; <strong>`(1 2 ~(* 6 7) (/ 4 2))</strong>
(1 2 42 (clojure.core// 4 2))
&nbsp;
<i>; pomocí ~ vynutíme vyhodnocení podvýrazu (/ 4 2)</i>
user=&gt; <strong>`(1 2 (* 6 7) ~(/ 4 2))</strong>
(1 2 (clojure.core/* 6 7) 2)
&nbsp;
<i>; pomocí dvou ~ vynutíme vyhodnocení obou podvýrazů</i>
user=&gt; <strong>`(1 2 ~(* 6 7) ~(/ 4 2))</strong>
(1 2 42 2)
&nbsp;
user=&gt;
</pre>

<p>Podobným způsobem pracuje i makro zapisované pomocí dvou znaků ~@, ovšem to
navíc ještě provádí &bdquo;zplošťování seznamů&ldquo;. Prozatím si chování
tohoto makra ukážeme na velmi jednoduchém umělém příkladu:</p>

<pre>
<i>; uživatelsky definovaný seznam</i>
user=&gt; <strong>(def s '(1 2 3))</strong>
#'user/s
&nbsp;
<i>; makro quote zcela zakáže vyhodnocování</i>
user=&gt; <strong>'(1 2 3 (cons s s))</strong>
(1 2 3 (cons s s))
&nbsp;
<i>; makro syntax-quote taktéž, ovšem ještě nahradí</i>
<i>; všechny symboly jejich plnými jmény</i>
user=&gt; <strong>`(1 2 3 (cons s s))</strong>
(1 2 3 (clojure.core/cons user/s user/s))
&nbsp;
<i>; vynutíme si vyhodnocení podvýrazu (cons s s)</i>
<i>; který vrací ((1 2 3) 1 2 3)</i>
user=&gt; <strong>`(1 2 3 ~(cons s s))</strong>
(1 2 3 ((1 2 3) 1 2 3))
&nbsp;
<i>; dtto, ovšem seznam, jenž je výsledkem (cons s s)</i>
<i>; je zploštěn (jakoby je</i>
odstraněna jedna úroveň zanoření)
user=&gt; <strong>`(1 2 3 ~@(cons s s))</strong>
(1 2 3 (1 2 3) 1 2 3)
&nbsp;
user=&gt;
</pre>

<p>Podívejme se nyní na jednoduché uživatelské makro vytvořené s&nbsp;využitím
formy <strong>defmacro</strong>. V&nbsp;samotném makru použijeme výše zmíněná
makra ` (<i>syntax quote</i>) a ~ (<i>unquote</i>):</p>

<pre>
(defmacro <strong>trace1</strong>
    [vyraz]
    `(let [x ~vyraz] (println '~vyraz "=" x) x))
</pre>

<p>Aby makro fungovalo zcela správně, musíme umět vytvořit lokální symbol
s&nbsp;unikátním jménem. Pro tento účel se používá (tak jako v&nbsp;mnoha
dalších situacích) znak křížku zapisovaný <strong>ZA</strong> nějakým symbolem.
<i>Clojure</i> zápis <strong>symbol#</strong> expanduje na
<strong>symbol_generované_číslo</strong>, které bude unikátní, což je přesně
to, co potřebujeme. Ve třetí verzi našeho makra tedy nahradíme
<strong>x</strong> za <strong>x#</strong>:</p>

<pre>
(defmacro <strong>trace2</strong>
    [vyraz]
    `(let [x# ~vyraz] (println '~vyraz "=" x#) x#))
</pre>

<p>Nyní tedy již známe téměř všechny nástroje používané při tvorbě maker
v&nbsp;Clojure:</p>

<table>
<tr><th>Znak</th><th>Význam při tvorbě maker</th></tr>
<tr><td>`</td><td>většinou uzavírá celé tělo makra, tj. šablonu vytvářeného výrazu</td></tr>
<tr><td>~</td><td>ruší význam znaku `, ovšem pouze pro jediný symbol uvedený ihned za tímto znakem</td></tr>
<tr><td>#</td><td>symbol zapsaný před tímto znakem bude doplněn takovým způsobem, aby se jednalo o unikátní jméno</td></tr>
</table>



<p><a name="k11"></a></p>
<h2 id="k11">11. Makra v&nbsp;programovacím jazyku Racket</h2>

<p>Ve druhé části dnešního článku je ukázán základní způsob tvorby maker
v&nbsp;programovacím jazyku <i>Racket</i>. Bude se, alespoň z&nbsp;hlediska
teorie, jednat o stejný koncept, s&nbsp;nímž jsme se seznámili
v&nbsp;předchozích kapitolách (ostatně <i>Racket</i> je i přes svá mnohá
rozšíření stále lispovským jazykem), ovšem s&nbsp;tím rozdílem, že se
s&nbsp;makry v&nbsp;Racketu pracuje jednodušším a taktéž bezpečnějším způsobem
&ndash; samotný makrosystém nás totiž v&nbsp;případě potřeby dokáže odstínit od
některých problémů, na něž jsme narazili výše (lokální proměnné v&nbsp;expanzi
makra atd.). Dále je možné v&nbsp;Racketu vytvářet makra s&nbsp;proměnným
množstvím argumentů, což je sice možné i v&nbsp;Common Lispu či Clojure, ovšem
koncept použitý v&nbsp;Racketu je velmi snadno pochopitelný a následně i
použitelný (vlastně se syntakticky příliš neliší od funkcí s&nbsp;proměnným
počtem parametrů, které jsme si popsali v&nbsp;předchozí části tohoto
seriálu).</p>

<p><div class="rs-tip-major">Poznámka: někdy se můžeme setkat s&nbsp;termínem
&bdquo;hygienická makra&ldquo;. Makra v&nbsp;Racketu jsou hygienická v&nbsp;tom
smyslu, že například automaticky detekují konflikt ve jménech lokálních
proměnných a parametrů makra atd. Podobně koncipovaná makra nalezneme
v&nbsp;Rustu, jazyku Julia či v&nbsp;Dylanu. V&nbsp;Clojure nebo Common Lispu
se naproti tomu musíme o &bdquo;hygienu&ldquo; v&nbsp;některých případech
postarat sami.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Vytvoření makra s&nbsp;využitím <strong>define-syntax-rule</strong></h2>

<p>Nejprve se seznámíme se způsobem tvorby maker založených na formě
pojmenované <strong>define-syntax-rule</strong>. Tato makra se nazývají
<i>pattern-based macros</i>, což je název plynoucí z&nbsp;toho, že se expanze
makra řídí sadou vzorků/pravidel (minimálně jednoho vzorku). Základní použití
formy <strong>define-syntax-rule</strong> vypadá podobně, jako tomu bylo ve
výše zmíněné formě <strong>defmacro</strong>:</p>

<pre>
(define-syntax-rule (square x)
    (* x x))
</pre>

<p>Samotný zápis se do značné míry podobá zápisu běžné funkce (alespoň
z&nbsp;pohledu syntaxe), ovšem sémantika je odlišná:</p>

<ol>

<li>Za jménem formy <strong>define-syntax-rule</strong> se v&nbsp;závorce
nachází takzvaný vzorek (<i>pattern</i>). Každý vzorek začíná jménem makra
následovaného názvy parametrů. Podle počtu parametrů se určuje, jaká část makra
bude v&nbsp;daném kontextu expandována.</li>

<li>Za vzorkem/vzorky následuje šablona makra (<i>template</i>),
tj.&nbsp;(zjednodušeně a nepřesně řečeno) kód, na který je makro
expandováno.</li>

</ol>

<p>V&nbsp;našem jednoduchém případě bude volání makra:</p>

<pre>
<strong>(display (square 10))</strong>
100
</pre>

<p>expandováno na:</p>

<pre>
(* 10 10)
</pre>

<p>což asi není příliš překvapivé a v&nbsp;tomto případě ani užitečné.</p>

<p><div class="rs-tip-major">Poznámka: takováto jednoduchá makra se většinou
v&nbsp;reálných aplikacích nepíšou, protože v&nbsp;programovacím jazyku Racket
neslouží makra primárně k&nbsp;urychlení výpočtů (v&nbsp;tomto případě
k&nbsp;takzvanému <i>inliningu</i> kódu), ale spíše k&nbsp;vytváření nové
syntaxe a mnohdy i k&nbsp;tvorbě ucelených doménově specifických jazyků
(<i>DSL</i>).  Velmi dobrým příkladem DSL je <a href="#k06">výše popsané</a>
makro <strong>loop</strong> z&nbsp;Common Lispu.</div></p>

<p>Podívat se pochopitelně můžeme i na expanzi tohoto makra, a to buď celou
expanzi až na základní symboly jazyka nebo pouze na expanzi makra (bez dalšího
zpracování podforem):</p>

<pre>
(<strong>define-syntax-rule</strong> (square x)
    (* x x))
&nbsp;
(display (<strong>square 10</strong>))
&nbsp;
(newline)
&nbsp;
(display (<strong>expand-once '(square 10)</strong>))
(newline)
&nbsp;
(display (<strong>expand '(square 10)</strong>))
(newline)
</pre>

<p>Výsledkem bude výsledek výrazu, na který se makro expandovalo, expanze
samotného makra i celá expanze na primární prvky jazyka:</p>

<pre>
100
#&lt;syntax:/home/tester/test..rkt:2:4 (* 10 10)&gt;
#&lt;syntax:/home/tester/test..rkt:2:4 (#%app * (quote 10) (quote 10))&gt;
</pre>

<p>Použití proměnné namísto konstanty 10:</p>

<pre>
(<strong>define-syntax-rule</strong> (square x)
    (* x x))
&nbsp;
(define foobar 10)
&nbsp;
(display (<strong>square foobar</strong>))
&nbsp;
(newline)
&nbsp;
(display (<strong>expand-once '(square foobar)</strong>))
(newline)
&nbsp;
(display (<strong>expand '(square foobar)</strong>))
(newline)
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
100
#&lt;syntax:/home/tester/test.rkt:2:4 (* foobar foobar)&gt;
#&lt;syntax:/home/tester/test.rkt:2:4 (#%app * foobar foobar)&gt;
</pre>

<p>Pozor ovšem na to, že se parametr v&nbsp;expandovaném makru vyhodnocuje
dvakrát:</p>

<pre>
<strong>(display (expand-once '(square (+ 1 2))))</strong>
#&lt;syntax:readline-input:2:3 (* (+ 1 2) (+ 1 2))&gt;
</pre>

<p>Úprava tohoto problému může vypadat například takto:</p>

<pre>
(define-syntax-rule (square x)
    (let ([tmp x])
         (* tmp tmp)))
&nbsp;
(display (square 10))
(newline)
&nbsp;
(display (expand-once (square 10)))
(newline)
&nbsp;
(display (expand-once '(square 10)))
(newline)
&nbsp;
(display (expand-once '(square 10)))
(newline)
&nbsp;
(display (expand '(square 10)))
(newline)
&nbsp;
(display (expand-once '(square (+ 1 2))))
(newline)
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
100
#&lt;syntax (quote 100)&gt;
#&lt;syntax:readline-input:2:4 (let ((tmp 10)) (* tmp tmp))&gt;
#&lt;syntax:readline-input:2:4 (let ((tmp 10)) (* tmp tmp))&gt;
#&lt;syntax:readline-input:2:4 (let-values (((tmp) (quote 10))) (#%app * tmp tmp))&gt;
#&lt;syntax:readline-input:2:4 (let ((tmp (+ 1 2))) (* tmp tmp))&gt;
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Syntaktické objekty, použití <strong>syntax-&gt;datum</strong></h2>

<p>V&nbsp;předchozí kapitole jsme mohli vidět, že pokud si necháme vypsat
expandované makro, vrátí se hodnota začínající na
<strong>#&lt;syntax:</strong>:</p>

<pre>
<strong>(display (expand-once '(square (+ 1 2))))</strong>
#&lt;syntax:readline-input:2:4 (let ((tmp (+ 1 2))) (* tmp tmp))&gt;
</pre>

<p>Jedná se o takzvané syntaktické objekty, které je možné zapisovat i přímo
s&nbsp;pomocí znaku #. Ovšem nás bude nyní spíše zajímat, jak z&nbsp;takového
objektu získat čitelnou podobu expandovaného kódu. K&nbsp;tomuto účelu slouží
forma <strong>syntax-&gt;datum</strong>, kterou lze použít například takto:</p>

<pre>
(define-syntax-rule (square x)
    (* x x))
&nbsp;
(display (square 10))
(newline)
&nbsp;
(display (syntax-&gt;datum (expand-once (square 10))))
(newline)
&nbsp;
(display (syntax-&gt;datum (expand-once '(square 10))))
(newline)
&nbsp;
(display (syntax-&gt;datum (expand-once '(square 10))))
(newline)
&nbsp;
(display (syntax-&gt;datum (expand '(square 10))))
(newline)
&nbsp;
(display (syntax-&gt;datum (expand-once '(square (+ 1 2)))))
(newline)
</pre>

<p>S&nbsp;krásně čitelnými výsledky expanze makra:</p>

<pre>
100
(quote 100)
(* 10 10)
(* 10 10)
(#%app * (quote 10) (quote 10))
(* (+ 1 2) (+ 1 2))
</pre>

<p>Podobně si můžeme nechat vypsat expandovanou podobu vylepšené varianty makra
<strong>square</strong>:</p>

<pre>
(define-syntax-rule (square x)
    (let ([tmp x])
         (* tmp tmp)))
&nbsp;
(display (square 10))
(newline)
&nbsp;
(display (syntax-&gt;datum (expand-once (square 10))))
(newline)
&nbsp;
(display (syntax-&gt;datum (expand-once '(square 10))))
(newline)
&nbsp;
(display (syntax-&gt;datum (expand-once '(square 10))))
(newline)
&nbsp;
(display (syntax-&gt;datum (expand '(square 10))))
(newline)
&nbsp;
(display (syntax-&gt;datum (expand-once '(square (+ 1 2)))))
(newline)
</pre>

<p>Tentokrát pochopitelně s&nbsp;odlišnými výsledky, protože se
v&nbsp;expandovaném makru objeví forma <strong>let</strong>:</p>

<pre>
100
(quote 100)
(let ((tmp 10)) (* tmp tmp))
(let ((tmp 10)) (* tmp tmp))
(let-values (((tmp) (quote 10))) (#%app * tmp tmp))
(let ((tmp (+ 1 2))) (* tmp tmp))
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Makro pro prohození obsahu dvou proměnných</h2>

<p>Ukažme si tedy nepatrně složitější makro, které je mimochodem popsáno i
v&nbsp;dokumentaci programovacího jazyka Racket. Toto makro se jmenuje
<strong>swap</strong> a slouží k&nbsp;prohození obsahu dvou proměnných
s&nbsp;využitím lokální proměnné ve formě dočasného úložiště:</p>

<pre>
(define-syntax-rule (swap x y)
    (let ([tmp x])
         (set! x y)
         (set! y tmp)))
</pre>

<p>Příklad použití makra:</p>

<pre>
(swap foo bar)
</pre>

<p>Popř.&nbsp;v&nbsp;uceleném příkladu s&nbsp;dvojicí lokálních proměnných:</p>

<pre>
(let [(x 10)
      (y 20)]
     (swap x y)
     (display x)
     (newline)
     (display y)
     (newline))
&nbsp;
20
10
</pre>

<p>Toto volání makra je expandováno na:</p>

<pre>
(let ([tmp foo])
    (set! foo bar)
    (set! bar tmp))
</pre>

<p>Otestování s&nbsp;dvojicí globálních proměnných:</p>

<pre>
(define-syntax-rule (swap x y)
    (let ([tmp x])
         (set! x y)
         (set! y tmp)))
&nbsp;
(define foo 10)
(define bar 20)
&nbsp;
(swap foo bar)
(display foo)
(newline)
(display bar)
(newline)
&nbsp;
(display (expand-once '(swap foo bar)))
(newline)
</pre>

<p>Výsledky:</p>

<pre>
20
10
#&lt;syntax:/home/tester/test.rkt:2:4 (let ((tmp foo)) (set! foo bar) (set! bar tmp))&gt;
</pre>

<p>Co se však stane v&nbsp;případě, že budeme chtít prohodit obsah proměnných
<strong>tmp</strong> a <strong>baz</strong>? Mohlo by se zdát, že v&nbsp;tomto
případě dojde ke kolizi jména parametru makra a jména lokální proměnné
v&nbsp;expandovaném makru:</p>

<pre>
(let ([tmp tmp])
    (set! tmp baz)
    (set! baz tmp))
</pre>

<p>Ve skutečnosti ovšem makrosystém programovacího jazyka Racket tomuto
problému automaticky zabrání, protože dokáže lokální proměnné
v&nbsp;expandovaném makru přejmenovat takovým způsobem, aby byly unikátní:</p>

<pre>
(let ([tmp_1 tmp])
    (set! tmp baz)
    (set! baz tmp_1))
</pre>

<p>To však není zdaleka vše, protože se podobným způsobem zabrání tomu, aby se
použila pozměněná hodnota symbolu <strong>set!</strong>. Pokud totiž jednu
z&nbsp;proměnných nazveme právě <strong>set!</strong>, bude expandované makro
vypadat takto:</p>

<pre>
(let ([tmp_1 set1_1])
    (set! set1_1 baz)
    (set! baz tmp_1))
</pre>

<p>Pokud by k&nbsp;této záměně nedošlo, nebylo by možné funkci
<strong>set!</strong> zavolat.</p>

<p>Otestování:</p>

<pre>
(define-syntax-rule (swap x y)
    (let ([tmp x])
         (set! x y)
         (set! y tmp)))
&nbsp;
(let ([set! 10]
      [baz 20])
     (swap set! baz)
     (display set!)
     (newline)
     (display baz)
     (newline))
</pre>

<p>Výsledek je opět předvídatelný:</p>

<pre>
20
10
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Makro s&nbsp;volitelnou aritou</h2>

<p>V&nbsp;programovacím jazyku <i>Racket</i> je možné vytvářet makra
s&nbsp;volitelnou (proměnnou) aritou, podobně jako je možné vytvářet funkce
s&nbsp;proměnnou aritou. Asi nejtypičtějším příkladem mohou být makra nazvaná
<strong>and</strong> a <strong>or</strong>, které slouží k&nbsp;podmíněnému
vyhodnocení zapsaných výrazů. Vyhodnocení probíhá zleva doprava a ve chvíli,
kdy je již výsledek výrazu známý (mezivýsledek je <strong>#f</strong> u
<strong>and</strong> nebo <strong>#t</strong> u <strong>or</strong>),
vyhodnocení je ihned ukončeno a další parametry se nijak nevyhodnocují. Díky
tomu je možné tato makra použít pro řízení běhu programu a navíc nelze
<strong>and</strong> ani <strong>or</strong> realizovat běžnou funkcí (tam by
se naopak nejprve vyhodnotily všechny parametry, což nechceme).</p>

<p>Problém ovšem spočívá v&nbsp;tom, že <strong>and</strong> a
<strong>or</strong> nejsou binární operátory (tak jako je tomu v&nbsp;mnoha
mainstreamových jazycích), ale formy akceptující libovolný počet parametrů,
přičemž pro různé počty parametrů se může provádět odlišný výpočet.
K&nbsp;tomuto účelu slouží forma (taktéž makro) nazvaná
<strong>syntax-rules</strong>, které můžeme předat libovolný počet vzorků
volání makra i jeho expandované podoby. Například budeme požadovat, aby se
zavolání <strong>or</strong> bez parametrů expandovalo přímo na hodnotu
<strong>#f</strong>, zavolání <strong>or</strong> s&nbsp;jedním parametrem
přímo na hodnotu tohoto parametru a při zavolání se dvěma parametry bude
výsledek buď první hodnota (pokud je <strong>#t</strong>) nebo naopak hodnota
druhá:</p>

<pre>
(define-syntax or
  (syntax-rules ()
    [(or) #f]
    [(or x) x]
    [(or x y) (let ([z x])
                   (if z z y))]))
</pre>

<p><div class="rs-tip-major">Poznámka: víte proč se v&nbsp;posledním vzorku
používá lokální proměnná <strong>z</strong>, i když by se zdánlivě mohla
namísto formy <strong>let</strong> přímo zapsat podmínka?</div></p>

<p>Chování tohoto makra si můžeme velmi snadno ověřit, například na několika
variantách volání bez parametrů, s&nbsp;jedním parametrem a se dvěma
parametry:</p>

<pre>
(display (or))
(newline)
&nbsp;
(display (or #t))
(newline)
&nbsp;
(display (or #f))
(newline)
&nbsp;
(display (or #t #f))
(newline)
&nbsp;
(display (or #f #f))
(newline)
</pre>

<p>Navíc se taktéž můžeme podívat na způsob expanze tohoto makra:</p>

<pre>
(display (expand-once '(or)))
(newline)
&nbsp;
(display (expand-once '(or #f)))
(newline)
&nbsp;
(display (expand-once '(or #f #f)))
(newline)
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
#&lt;syntax:/home/tester/test.rkt:3:10 #f&gt;
#&lt;syntax #f&gt;
#&lt;syntax:/home/tester/test.rkt:5:14 (let ((z #f)) (if z z #f))&gt;
</pre>

<p>Čitelnější podobu expandovaného makra získáme opět přes
<strong>syntax-&gt;datum</strong>:</p>

<pre>
(display (syntax-&gt;datum (expand-once '(or))))
(display (syntax-&gt;datum (expand-once '(or #f))))
(display (syntax-&gt;datum (expand-once '(or #t))))
(display (syntax-&gt;datum (expand-once '(or #f #f))))
(display (syntax-&gt;datum (expand-once '(or #f #t))))
</pre>

<p>Nyní se vypíše:</p>

<pre>
#f
#f
#t
(let ((z #f)) (if z z #f))
(let ((z #f)) (if z z #t))
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Použití ... v&nbsp;makru</h2>

<p>V&nbsp;případě, že budeme chtít makro <strong>or</strong> modifikovat
takovým způsobem, aby pracovalo skutečně s&nbsp;libovolným množstvím argumentů,
můžeme pro tento účel použít ... (tři tečky). Nejprve si však ukažme, jak
Racket reaguje na situaci, kdy se makru předává špatný počet parametrů, který
neodpovídá žádnému pravidlu. Použijeme původní podobu makra:</p>

<pre>
(define-syntax or
  (syntax-rules ()
    [(or) #f]
    [(or x) x]
    [(or x y) (let ([z x])
                   (if z z y))]))
</pre>

<p>Makro budeme volat se třemi parametry (takové pravidlo neexistuje):</p>

<pre>
<strong>(display (or #f #f #t))</strong>
</pre>

<p>V&nbsp;tomto případě se vypíše chybové hlášení &bdquo;bad syntax&ldquo;
společně s&nbsp;výrazem, který je z&nbsp;pohledu interpretru programovacího
jazyka Racket chybný:</p>

<pre>
or: bad syntax
  in: (or #f #f #f)
</pre>

<p>V&nbsp;definici makra ovšem můžeme použít ... (trojici teček), a to jak
v&nbsp;samotném vzorku, tak i v&nbsp;šabloně popisující, jak se má makro
expandovat:</p>

<pre>
(define-syntax or
  (syntax-rules ()
    [(or) #f]
    [(or x) x]
    [(or x y) (let ([z x])
                   (if z z y))]
    [<strong>(or x y ...) (or x (or y ...))</strong>]))
</pre>

<p>V&nbsp;tomto případě se při expanzi makra nahradí trojice teček za ty
parametry, které nejsou explicitně pojmenovány. Jinými slovy to znamená, že se
zvýrazněný řádek uplatní u volání makra se třemi a více parametry. Volání se
nahradí expanzí makra, nyní ovšem bez prvního parametru a v&nbsp;případě
potřeby se expanze provádí rekurzivně &ndash; to vše ve chvíli, kdy je makro
načteno objektem typu <i>Reader</i>, nikoli v&nbsp;čase běhu.</p>

<p>Chování si můžeme odzkoušet:</p>

<pre>
<strong>(display (or #f #f #t))</strong>
</pre>

<pre>
#t
</pre>

<p>A samozřejmě si můžeme zobrazit i expandované makro:</p>

<pre>
<strong>(syntax-&gt;datum (expand-once '(or #t #f #t #f #t #f)))</strong>
'(or #t (or #f #t #f #t #f))
</pre>

<p>Plná expanze makra v&nbsp;čitelné podobě:</p>

<pre>
<strong>(syntax-&gt;datum (expand '(or #t #f #t #f #t #f)))</strong>
&nbsp;
'(let-values (((z) '#t))
   (if z
     z
     (let-values (((z) '#f))
       (if z
         z
         (let-values (((z) '#t))
           (if z
             z
             (let-values (((z) '#f))
               (if z z (let-values (((z) '#t)) (if z z '#f))))))))))
</pre>

<p><div class="rs-tip-major">Poznámka: podobným způsobem jsou implementována
makra pro realizaci programových smyček, kde se do ... schová celé tělo
smyčky.</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Původní (nehygienická) makra v&nbsp;Racketu</h2>

<p>V&nbsp;programovacím jazyku <i>Racket</i> se důrazně doporučuje používat
hygienická makra založená na vzorcích a šablonách, tedy makra popsaná
v&nbsp;předchozích kapitolách. Ovšem pro účely portace zdrojových kódů
z&nbsp;dalších dialektů Scheme nebo (Common) Lispu existuje balíček, který
programátorům nabízí i formy <strong>defmacro</strong>,
<strong>define-macro</strong> atd. Tento modul je popsaný na stránce <a
href="https://docs.racket-lang.org/compatibility/defmacro.html">https://docs.racket-lang.org/compatibility/defmacro.html</a>.
Jedná se o klasicky pojatá makra, která dokážou pracovat přímo se stromem
reprezentovaným S-výrazem. Kvůli tomu je nutné používat formy pro <i>quote</i>,
<i>quasiquote</i> a <i>unquote</i>, které jsme si představili při popisu Common
Lispovských maker.</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/lisp-families.git">https://github.com/tisnik/lisp-families.git</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, můžete
namísto toho použít odkazy na jednotlivé příklady, které naleznete
v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>square1.rkt</td><td>makro pro výpočet druhé mocniny</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/macros/square1.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/macros/square1.rkt</a></td></tr>
<tr><td> 2</td><td>square2.rkt</td><td>vylepšení předchozího makra (jedno vyhodnocení parametru)</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/macros/square2.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/macros/square2.rkt</a></td></tr>
<tr><td> 3</td><td>square1-printable.rkt</td><td>převod expandovaného makra <strong>square</strong> do čitelné podoby</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/macros/square1-printable.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/macros/square1-printable.rkt</a></td></tr>
<tr><td> 4</td><td>square2-printable.rkt</td><td>převod expandovaného makra <strong>square</strong> do čitelné podoby</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/macros/square2-printable.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/macros/square2-printable.rkt</a></td></tr>
<tr><td> 5</td><td>swap1.rkt</td><td>makro pro prohození obsahu dvou proměnných</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/macros/swap1.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/macros/swap1.rkt</a></td></tr>
<tr><td> 6</td><td>swap2.rkt</td><td>otestování na globálních proměnných</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/macros/swap2.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/macros/swap2.rkt</a></td></tr>
<tr><td> 7</td><td>swap3.rkt</td><td>otestování ošetření speciálních případů</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/macros/swap3.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/macros/swap3.rkt</a></td></tr>
<tr><td> 8</td><td>swap4.rkt</td><td>otestování ošetření speciálních případů</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/macros/swap4.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/macros/swap4.rkt</a></td></tr>
<tr><td> 9</td><td>or1.rkt</td><td>makro <strong>or</strong> s&nbsp;proměnnou aritou</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/macros/or1.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/macros/or1.rkt</a></td></tr>
<tr><td>10</td><td>or1-printable.rkt</td><td>převod expandovaného makra <strong>or</strong> do čitelné podoby</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/macros/or1-printable.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/macros/or1-printable.rkt</a></td></tr>
<tr><td>11</td><td>or2.rkt</td><td>makro <strong>or</strong> s&nbsp;libovolnou aritou</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/macros/or2.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/macros/or2.rkt</a></td></tr>
<tr><td>12</td><td>or2-printable.rkt</td><td>převod expandovaného makra <strong>or</strong> do čitelné podoby</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/racket/macros/or2-printable.rkt">https://github.com/tisnik/lisp-families/blob/master/racket/macros/or2-printable.rkt</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Literatura</h2>

<ol>

<li>Peter Seibel<br />
<i>&bdquo;Practical Common Lisp&ldquo;</i><br />
2009
</li>

<li>Paul Graham<br />
<i>&bdquo;ANSI Common Lisp&ldquo;</i><br />
1995
</li>

<li>Gerald Gazdar<br />
<i>&bdquo;Natural Language Processing in Lisp: An Introduction to Computational Linguistics&ldquo;</i><br />
1989
</li>

<li>Peter Norvig<br />
<i>&bdquo;Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp&ldquo;</i><br />
1991
</li>

<li>Alex Mileler et.al.<br />
<i>&bdquo;Clojure Applied: From Practice to Practitioner&ldquo;</i><br />
2015
</li>

<li>
<i>&bdquo;Living Clojure: An Introduction and Training Plan for Developers&ldquo;</i><br />
2015
</li>

<li>Dmitri Sotnikov<br />
<i>&bdquo;Web Development with Clojure: Build Bulletproof Web Apps with Less Code&ldquo;</i><br />
2016
</li>

<li>McCarthy<br />
<i>&bdquo;Recursive functions of symbolic expressions and their computation by machine, part I&ldquo;</i><br />
1960
</li>

<li>R. Kent Dybvig<br />
<i>&bdquo;The Scheme Programming Language&ldquo;</i><br />
2009
</li>

<li>Max Hailperin<br />
<i>&bdquo;Concrete Abstractions&ldquo;</i><br />
1998
</li>

<li>Guy L. Steele<br />
<i>&bdquo;History of Scheme&ldquo;</i><br />
2006, Sun Microsystems Laboratories
</li>

<li>Kolář J., Muller K.:<br />
<i>&bdquo;Speciální programovací jazyky&ldquo;</i><br />
Praha 1981
</li>

<li>
<i>&bdquo;AutoLISP Release 9, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., October 1987
</li>

<li>
<i>&bdquo;AutoLISP Release 10, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., September 1988
</li>

<li>McCarthy, John; Abrahams, Paul W.; Edwards, Daniel J.; Hart, Timothy P.; Levin, Michael I.<br />
<i>&bdquo;LISP 1.5 Programmer's Manual&ldquo;</i><br />
MIT Press. ISBN 0 262 130 1 1 4
</li>

<li>Carl Hewitt; Peter Bishop and Richard Steiger<br />
<i>&bdquo;A Universal Modular Actor Formalism for Artificial Intelligence&ldquo;</i><br />
1973
</li>

<li>Feiman, J.<br />
<i>&bdquo;The Gartner Programming Language Survey (October 2001)&ldquo;</i><br />
Gartner Advisory
</li>

<li>Harold Abelson, Gerald Jay Sussman, Julie Sussman:<br />
<i>Structure and Interpretation of Computer Programs</i><br />
MIT Press. 1985, 1996 (a možná vyšel i další přetisk)
</li>

<li>Paul Graham<br />
<i>On Lisp</i><br />
Prentice Hall, 1993<br />
Dostupné online na stránce <a href="http://www.paulgraham.com/onlisptext.html">http://www.paulgraham.com/onlisptext.html</a>
</li>

<li>David S. Touretzky<br />
<i>Common LISP: A Gentle Introduction to Symbolic Computation (Dover Books on Engineering)</i><br />
</li>

<li>Peter Norvig<br />
<i>Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp</i>
</li>

<li>Patrick Winston, Berthold Horn<br />
<i>Lisp (3rd Edition)</i><br />
ISBN-13: 978-0201083194, ISBN-10: 0201083191
</li>

<li>Matthias Felleisen, David Van Horn, Dr. Conrad Barski<br>
<i>Realm of Racket: Learn to Program, One Game at a Time!</i><br />
ISBN-13: 978-1593274917, ISBN-10: 1593274912 
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Racket: Macros<br />
<a href="https://www.it.uu.se/edu/course/homepage/avfunpro/ht13/lectures/Racket-3-Macros.pdf">https://www.it.uu.se/edu/course/homepage/avfunpro/ht13/lectures/Racket-3-Macros.pdf</a>
</li>

<li>Beautiful Racket / explainers: Macros<br />
<a href="https://beautifulracket.com/explainer/macros.html">https://beautifulracket.com/explainer/macros.html</a>
</li>

<li>Macros (dokumentace k Racketu)<br />
<a href="https://docs.racket-lang.org/guide/macros.html">https://docs.racket-lang.org/guide/macros.html</a>
</li>

<li>Model syntaxe jazyka Racket<br />
<a href="https://docs.racket-lang.org/reference/syntax-model.html">https://docs.racket-lang.org/reference/syntax-model.html</a>
</li>

<li>Syntax Objects<br />
<a href="https://docs.racket-lang.org/guide/stx-obj.html">https://docs.racket-lang.org/guide/stx-obj.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Beautiful Racket: an intro­duction to language-oriented programming using Racket<br />
<a href="https://beautifulracket.com/">https://beautifulracket.com/</a>
</li>

<li>Stránky projektu Racket<br />
<a href="https://racket-lang.org/">https://racket-lang.org/</a>
</li>

<li>Dokumentace k&nbsp;projektu Racket<br />
<a href="https://docs.racket-lang.org/index.html">https://docs.racket-lang.org/index.html</a>
</li>

<li>Seznam dostupných balíčků pro Racket<br />
<a href="https://pkgs.racket-lang.org/">https://pkgs.racket-lang.org/</a>
</li>

<li>Racket na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Racket_(programming_language)">https://en.wikipedia.org/wiki/Racket_(programming_language)</a>
</li>

<li>Blogy o Racketu a navazujících technologiích<br />
<a href="https://blog.racket-lang.org/">https://blog.racket-lang.org/</a>
</li>

<li>Prográmky psané v&nbsp;Racketu na RosettaCode<br />
<a href="http://rosettacode.org/wiki/Category:Racket">http://rosettacode.org/wiki/Category:Racket</a>
</li>

<li>Fear of Macros<br />
<a href="https://www.greghendershott.com/fear-of-macros/">https://www.greghendershott.com/fear-of-macros/</a>
</li>

<li>Rackjure<br />
<a href="https://github.com/greghendershott/rackjure">https://github.com/greghendershott/rackjure</a>
</li>

<li>Matthew Flatt’s proposal to change Racket’s s-expressions based syntax to infix representation creates a stir in the community<br />
<a href="https://hub.packtpub.com/matthew-flatts-proposal-to-change-rackets-s-expressions-based-syntax-to-infix-representation-creates-a-stir-in-the-community/">https://hub.packtpub.com/matthew-flatts-proposal-to-change-rackets-s-expressions-based-syntax-to-infix-representation-creates-a-stir-in-the-community/</a>
</li>

<li>Racket News<br />
<a href="https://racket-news.com/">https://racket-news.com/</a>
</li>

<li>Racket: Lisp for learning<br />
<a href="https://lwn.net/Articles/795385/">https://lwn.net/Articles/795385/</a>
</li>

<li>Future of Racket<br />
<a href="https://www.greghendershott.com/2019/07/future-of-racket.html">https://www.greghendershott.com/2019/07/future-of-racket.html</a>
</li>

<li>Kawa: Compiling Scheme to Java<br />
<a href="https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html">https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html</a>
</li>

<li>Kawa in Languages shootout<br />
<a href="http://per.bothner.com/blog/2010/Kawa-in-shootout/">http://per.bothner.com/blog/2010/Kawa-in-shootout/</a>
</li>

<li>Kawa 2.0 Supports Scheme R7RS<br />
<a href="https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/">https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/</a>
</li>

<li>Kawa — fast scripting on the Java platform<br />
<a href="https://lwn.net/Articles/623349/">https://lwn.net/Articles/623349/</a>
</li>

<li>Tail call (a její optimalizace)<br />
<a href="https://en.wikipedia.org/wiki/Tail_call">https://en.wikipedia.org/wiki/Tail_call</a>
</li>

<li>SLIME (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/SLIME">http://en.wikipedia.org/wiki/SLIME</a>
</li>

<li>slime.vim<br />
<a href="http://s3.amazonaws.com/mps/slime.vim">http://s3.amazonaws.com/mps/slime.vim</a>
</li>

<li>What are the best scheme implementations?<br />
<a href="https://www.slant.co/topics/5282/~scheme-implementations">https://www.slant.co/topics/5282/~scheme-implementations</a>
</li>

<li>Bigloo homepage<br />
<a href="http://www-sop.inria.fr/mimosa/fp/Bigloo/">http://www-sop.inria.fr/mimosa/fp/Bigloo/</a>
</li>

<li>FTP s tarbally Bigloo<br />
<a href="ftp://ftp-sop.inria.fr/indes/fp/Bigloo">ftp://ftp-sop.inria.fr/indes/fp/Bigloo</a>
</li>

<li>GOTO 2018 • Functional Programming in 40 Minutes • Russ Olsen<br />
<a href="https://www.youtube.com/watch?v=0if71HOyVjY">https://www.youtube.com/watch?v=0if71HOyVjY</a>
</li>

<li>TinyScheme (stránka na Sourceforge)<br />
<a href="http://tinyscheme.sourceforge.net/home.html">http://tinyscheme.sourceforge.net/home.html</a>
</li>

<li>Embedding Tiny Scheme in a Game<br />
<a href="http://www.silicondelight.com/embedding-tiny-scheme-in-a-game/">http://www.silicondelight.com/embedding-tiny-scheme-in-a-game/</a>
</li>

<li>Embedding Scheme for a game mission scripting DSL<br />
<a href="http://carloscarrasco.com/embedding-scheme-for-a-game-mission-scripting-dsl.html">http://carloscarrasco.com/embedding-scheme-for-a-game-mission-scripting-dsl.html</a>
</li>

<li>Všechny verze TinyScheme na SourceForge<br />
<a href="https://sourceforge.net/projects/tinyscheme/files/tinyscheme/">https://sourceforge.net/projects/tinyscheme/files/tinyscheme/</a>
</li>

<li>Fork TinyScheme na GitHubu<br />
<a href="https://github.com/yawnt/tinyscheme">https://github.com/yawnt/tinyscheme</a>
</li>

<li>Ackermannova funkce<br />
<a href="https://cs.wikipedia.org/wiki/Ackermannova_funkce">https://cs.wikipedia.org/wiki/Ackermannova_funkce</a>
</li>

<li>Ackermann function na Rosetta Code<br />
<a href="https://rosettacode.org/wiki/Ackermann_function#Scheme">https://rosettacode.org/wiki/Ackermann_function#Scheme</a>
</li>

<li>Success Stories (lisp.org)<br />
<a href="https://lisp-lang.org/success/">https://lisp-lang.org/success/</a>
</li>

<li>Allegro Common Lisp Success Stories<br />
<a href="https://franz.com/success/">https://franz.com/success/</a>
</li>

<li>Clojure Success Stories<br />
<a href="https://clojure.org/community/success_stories">https://clojure.org/community/success_stories</a>
</li>

<li>Scheme Quick Reference<br />
<a href="https://www.st.cs.uni-saarland.de/edu/config-ss04/scheme-quickref.pdf">https://www.st.cs.uni-saarland.de/edu/config-ss04/scheme-quickref.pdf</a>
</li>

<li>Slajdy o Scheme (od slajdu číslo 15)<br />
<a href="https://docs.google.com/presentation/d/1abmDnKjrq1tcjGvvRNAKhOiSTSE2lyagtcEPal07Gbo/edit">https://docs.google.com/presentation/d/1abmDnKjrq1tcjGvvRNAKhOiSTSE2lyagtcEPal07Gbo/edit</a>
</li>

<li>Scheme Cheat Sheet<br />
<a href="https://github.com/smythp/scheme-cheat-sheet">https://github.com/smythp/scheme-cheat-sheet</a>
</li>

<li>Embedding Lua, embedding Guile <br />
<a href="http://puntoblogspot.blogspot.com/2013/04/embedding-lua-embedding-guile.html">http://puntoblogspot.blogspot.com/2013/04/embedding-lua-embedding-guile.html</a>
</li>

<li>Lambda Papers<br />
<a href="https://en.wikisource.org/wiki/Lambda_Papers">https://en.wikisource.org/wiki/Lambda_Papers</a>
</li>

<li>Revised<sup>7</sup>Report on the Algorithmic Language Scheme<br />
<a href="https://small.r7rs.org/attachment/r7rs.pdf">https://small.r7rs.org/attachment/r7rs.pdf</a>
</li>

<li>Video Lectures (MIT, SICP 2005)<br />
<a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/</a>
</li>

<li>Why is Scheme my first language in university?<br />
<a href="https://softwareengineering.stackexchange.com/questions/115252/why-is-scheme-my-first-language-in-university">https://softwareengineering.stackexchange.com/questions/115252/why-is-scheme-my-first-language-in-university</a>
</li>

<li>The Perils of JavaSchools<br />
<a href="https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/">https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/</a>
</li>

<li>How to Design Programs, Second Edition<br />
<a href="https://htdp.org/2019-02-24/index.html">https://htdp.org/2019-02-24/index.html</a>
</li>

<li>LilyPond<br />
<a href="http://lilypond.org/">http://lilypond.org/</a>
</li>

<li>LilyPond — Extending (přes Scheme)<br />
<a href="http://lilypond.org/doc/v2.18/Documentation/extending/scheme-tutorial">http://lilypond.org/doc/v2.18/Documentation/extending/scheme-tutorial</a>
</li>

<li>Scheme in LilyPond<br />
<a href="http://lilypond.org/doc/v2.18/Documentation/extending/scheme-in-lilypond">http://lilypond.org/doc/v2.18/Documentation/extending/scheme-in-lilypond</a>
</li>

<li>GnuCash<br />
<a href="http://www.gnucash.org/">http://www.gnucash.org/</a>
</li>

<li>Custom Reports (in GNU Cash)<br />
<a href="https://wiki.gnucash.org/wiki/Custom_Reports">https://wiki.gnucash.org/wiki/Custom_Reports</a>
</li>

<li>Program by Design<br />
<a href="https://programbydesign.org/">https://programbydesign.org/</a>
</li>

<li>SchemePy<br />
<a href="https://pypi.org/project/SchemePy/">https://pypi.org/project/SchemePy/</a>
</li>

<li>LISP FQA: Section - [1-5] What is the "minimal" set of primitives needed for a Lisp interpreter?<br />
<a href="http://www.faqs.org/faqs/lisp-faq/part1/section-6.html">http://www.faqs.org/faqs/lisp-faq/part1/section-6.html</a>
</li>

<li>femtolisp<br />
<a href="https://github.com/JeffBezanson/femtolisp">https://github.com/JeffBezanson/femtolisp</a>
</li>

<li>(How to Write a (Lisp) Interpreter (in Python))<br />
<a href="http://norvig.com/lispy.html">http://norvig.com/lispy.html</a>
</li>

<li>Repositář s&nbsp;Guile Emacsem<br />
<a href="http://git.hcoop.net/?p=bpt/guile.git">http://git.hcoop.net/?p=bpt/guile.git</a>
</li>

<li>Interacting with Guile Compound Data Types in C<br />
<a href="http://www.lonelycactus.com/guilebook/x1555.html">http://www.lonelycactus.com/guilebook/x1555.html</a>
</li>

<li>Calling Guile functions from C<br />
<a href="http://www.lonelycactus.com/guilebook/c1204.html#SECCALLGUILEFUNC">http://www.lonelycactus.com/guilebook/c1204.html#SECCALLGUILEFUNC</a>
</li>

<li>Arrays, and other compound data types<br />
<a href="http://www.lonelycactus.com/guilebook/charrays.html">http://www.lonelycactus.com/guilebook/charrays.html</a>
</li>

<li>Interacting with Guile Compound Data Types in C<br />
<a href="http://www.lonelycactus.com/guilebook/x1555.html">http://www.lonelycactus.com/guilebook/x1555.html</a>
</li>

<li>Guile Reference Manual<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/index.html">https://www.gnu.org/software/guile/manual/html_node/index.html</a>
</li>

<li>Scheme: Summary of Common Syntax<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/Syntax-Summary.html#Syntax-Summary">https://www.gnu.org/software/guile/manual/html_node/Syntax-Summary.html#Syntax-Summary</a>
</li>

<li>Scripting with Guile: Extension language enhances C and Scheme<br />
<a href="https://www.ibm.com/developerworks/library/l-guile/index.html">https://www.ibm.com/developerworks/library/l-guile/index.html</a>
</li>

<li>Having fun with Guile: a tutorial<br />
<a href="http://dustycloud.org/misc/guile-tutorial.html">http://dustycloud.org/misc/guile-tutorial.html</a>
</li>

<li>Guile: Loading Readline Support<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/Loading-Readline-Support.html#Loading-Readline-Support">https://www.gnu.org/software/guile/manual/html_node/Loading-Readline-Support.html#Loading-Readline-Support</a>
</li>

<li>lispy<br />
<a href="https://pypi.org/project/lispy/">https://pypi.org/project/lispy/</a>
</li>

<li>Lython<br />
<a href="https://pypi.org/project/Lython/">https://pypi.org/project/Lython/</a>
</li>

<li>Lizpop<br />
<a href="https://pypi.org/project/lizpop/">https://pypi.org/project/lizpop/</a>
</li>

<li>Budoucnost programovacích jazyků<br />
<a href="http://www.knesl.com/budoucnost-programovacich-jazyku">http://www.knesl.com/budoucnost-programovacich-jazyku</a>
</li>

<li>LISP Prolog and Evolution<br />
<a href="http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html">http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html</a>
</li>

<li>List of Lisp-family programming languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages">https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages</a>
</li>

<li>clojure_py na indexu PyPi<br />
<a href="https://pypi.python.org/pypi/clojure_py">https://pypi.python.org/pypi/clojure_py</a>
</li>

<li>PyClojure<br />
<a href="https://github.com/eigenhombre/PyClojure">https://github.com/eigenhombre/PyClojure</a>
</li>

<li>Hy na GitHubu<br />
<a href="https://github.com/hylang/hy">https://github.com/hylang/hy</a>
</li>

<li>Hy: The survival guide<br />
<a href="https://notes.pault.ag/hy-survival-guide/">https://notes.pault.ag/hy-survival-guide/</a>
</li>

<li>Hy běžící na monitoru terminálu společnosti Symbolics<br />
<a href="http://try-hy.appspot.com/">http://try-hy.appspot.com/</a>
</li>

<li>Welcome to Hy’s documentation!<br />
<a href="http://docs.hylang.org/en/stable/">http://docs.hylang.org/en/stable/</a>
</li>

<li>Hy na PyPi<br />
<a href="https://pypi.org/project/hy/#description">https://pypi.org/project/hy/#description</a>
</li>

<li>Getting Hy on Python<br />
<a href="https://lwn.net/Articles/596626/">https://lwn.net/Articles/596626/</a>
</li>

<li>Programming Can Be Fun with Hy<br />
<a href="https://opensourceforu.com/2014/02/programming-can-fun-hy/">https://opensourceforu.com/2014/02/programming-can-fun-hy/</a>
</li>

<li>Přednáška o projektu Hy (pětiminutový lighttalk)<br />
<a href="http://blog.pault.ag/day/2013/04/02">http://blog.pault.ag/day/2013/04/02</a>
</li>

<li>Hy (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Hy">https://en.wikipedia.org/wiki/Hy</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Point<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Point.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Point.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Narrowing<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Narrowing.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Narrowing.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Functions that Create Markers<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Markers.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Markers.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Motion<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Motion.html#Motion">https://www.gnu.org/software/emacs/manual/html_node/elisp/Motion.html#Motion</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Basic Char Syntax<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Char-Syntax.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Char-Syntax.html</a>
</li>

<li>Elisp: Sequence: List, Array<br />
<a href="http://ergoemacs.org/emacs/elisp_list_vs_vector.html">http://ergoemacs.org/emacs/elisp_list_vs_vector.html</a>
</li>

<li>Elisp: Property List<br />
<a href="http://ergoemacs.org/emacs/elisp_property_list.html">http://ergoemacs.org/emacs/elisp_property_list.html</a>
</li>

<li>Elisp: Hash Table<br />
<a href="http://ergoemacs.org/emacs/elisp_hash_table.html">http://ergoemacs.org/emacs/elisp_hash_table.html</a>
</li>

<li>Elisp: Association List<br />
<a href="http://ergoemacs.org/emacs/elisp_association_list.html">http://ergoemacs.org/emacs/elisp_association_list.html</a>
</li>

<li>The mapcar Function (An Introduction to Programming in Emacs Lisp)<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/mapcar.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/mapcar.html</a>
</li>

<li>Anaphoric macro<br />
<a href="https://en.wikipedia.org/wiki/Anaphoric_macro">https://en.wikipedia.org/wiki/Anaphoric_macro</a>
</li>

<li>Some Common Lisp Loop Macro Examples<br />
<a href="https://www.youtube.com/watch?v=3yl8o6r_omw">https://www.youtube.com/watch?v=3yl8o6r_omw</a>
</li>

<li>A Guided Tour of Emacs<br />
<a href="https://www.gnu.org/software/emacs/tour/">https://www.gnu.org/software/emacs/tour/</a>
</li>

<li>The Roots of Lisp<br />
<a href="http://www.paulgraham.com/rootsoflisp.html">http://www.paulgraham.com/rootsoflisp.html</a>
</li>

<li>Evil (Emacs Wiki)<br />
<a href="https://www.emacswiki.org/emacs/Evil">https://www.emacswiki.org/emacs/Evil</a>
</li>

<li>Evil (na GitHubu)<br />
<a href="https://github.com/emacs-evil/evil">https://github.com/emacs-evil/evil</a>
</li>

<li>Evil (na stránkách repositáře MELPA)<br />
<a href="https://melpa.org/#/evil">https://melpa.org/#/evil</a>
</li>

<li>Evil Mode: How I Switched From VIM to Emacs<br />
<a href="https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html">https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html</a>
</li>

<li>GNU Emacs (home page)<br />
<a href="https://www.gnu.org/software/emacs/">https://www.gnu.org/software/emacs/</a>
</li>

<li>GNU Emacs (texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs">http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs</a>
</li>

<li>An Introduction To Using GDB Under Emacs<br />
<a href="http://tedlab.mit.edu/~dr/gdbintro.html">http://tedlab.mit.edu/~dr/gdbintro.html</a>
</li>

<li>An Introduction to Programming in Emacs Lisp<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html</a>
</li>

<li>27.6 Running Debuggers Under Emacs<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html">https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html</a>
</li>

<li>GdbMode<br />
<a href="http://www.emacswiki.org/emacs/GdbMode">http://www.emacswiki.org/emacs/GdbMode</a>
</li>

<li>Emacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Emacs">https://en.wikipedia.org/wiki/Emacs</a>
</li>

<li>Emacs timeline<br />
<a href="http://www.jwz.org/doc/emacs-timeline.html">http://www.jwz.org/doc/emacs-timeline.html</a>
</li>

<li>Emacs Text Editors Family<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?EmacsFamily">http://texteditors.org/cgi-bin/wiki.pl?EmacsFamily</a>
</li>

<li>Vrapper aneb spojení možností Vimu a Eclipse<br />
<a href="https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse/">https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse/</a>
</li>

<li>Vrapper aneb spojení možností Vimu a Eclipse (část 2: vyhledávání a nahrazování textu)<br />
<a href="https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse-cast-2-vyhledavani-a-nahrazovani-textu/">https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse-cast-2-vyhledavani-a-nahrazovani-textu/</a>
</li>

<li>Emacs/Evil-mode - A basic reference to using evil mode in Emacs<br />
<a href="http://www.aakarshnair.com/posts/emacs-evil-mode-cheatsheet">http://www.aakarshnair.com/posts/emacs-evil-mode-cheatsheet</a>
</li>

<li>From Vim to Emacs+Evil chaotic migration guide<br />
<a href="https://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/">https://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/</a>
</li>

<li>Introduction to evil-mode {video)<br />
<a href="https://www.youtube.com/watch?v=PeVQwYUxYEg">https://www.youtube.com/watch?v=PeVQwYUxYEg</a>
</li>

<li>EINE (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/EINE">http://www.emacswiki.org/emacs/EINE</a>
</li>

<li>EINE (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?EINE">http://texteditors.org/cgi-bin/wiki.pl?EINE</a>
</li>

<li>ZWEI (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/ZWEI">http://www.emacswiki.org/emacs/ZWEI</a>
</li>

<li>ZWEI (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?ZWEI">http://texteditors.org/cgi-bin/wiki.pl?ZWEI</a>
</li>

<li>Zmacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Zmacs">https://en.wikipedia.org/wiki/Zmacs</a>
</li>

<li>Zmacs (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?Zmacs">http://texteditors.org/cgi-bin/wiki.pl?Zmacs</a>
</li>

<li>TecoEmacs (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/TecoEmacs">http://www.emacswiki.org/emacs/TecoEmacs</a>
</li>

<li>Micro Emacs<br />
<a href="http://www.emacswiki.org/emacs/MicroEmacs">http://www.emacswiki.org/emacs/MicroEmacs</a>
</li>

<li>Micro Emacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/MicroEMACS">https://en.wikipedia.org/wiki/MicroEMACS</a>
</li>

<li>EmacsHistory<br />
<a href="http://www.emacswiki.org/emacs/EmacsHistory">http://www.emacswiki.org/emacs/EmacsHistory</a>
</li>

<li>Seznam editorů s ovládáním podobným Emacsu či kompatibilních s příkazy Emacsu<br />
<a href="http://www.finseth.com/emacs.html">http://www.finseth.com/emacs.html</a>
</li>

<li>evil-numbers<br />
<a href="https://github.com/cofi/evil-numbers">https://github.com/cofi/evil-numbers</a>
</li>

<li>Debuggery a jejich nadstavby v&nbsp;Linuxu (1.část)<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/</a>
</li>

<li>Debuggery a jejich nadstavby v&nbsp;Linuxu (2.část)<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (3): Nemiver<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (4): KDbg<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (5): ladění aplikací v editorech Emacs a Vim<br />
<a href="https://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">https://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/</a>
</li>

<li>Org mode<br />
<a href="https://orgmode.org/">https://orgmode.org/</a>
</li>

<li>The Org Manual<br />
<a href="https://orgmode.org/manual/index.html">https://orgmode.org/manual/index.html</a>
</li>

<li>Kakoune (modální textový editor)<br />
<a href="http://kakoune.org/">http://kakoune.org/</a>
</li>

<li>Vim-style keybinding in Emacs/Evil-mode<br />
<a href="https://gist.github.com/troyp/6b4c9e1c8670200c04c16036805773d8">https://gist.github.com/troyp/6b4c9e1c8670200c04c16036805773d8</a>
</li>

<li>Emacs - jak začít<br />
<a href="http://www.abclinuxu.cz/clanky/navody/emacs-jak-zacit">http://www.abclinuxu.cz/clanky/navody/emacs-jak-zacit</a>
</li>

<li>Programovací jazyk LISP a LISP machines<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-lisp-a-lisp-machines/">https://www.root.cz/clanky/programovaci-jazyk-lisp-a-lisp-machines/</a>
</li>

<li>Evil-surround<br />
<a href="https://github.com/emacs-evil/evil-surround">https://github.com/emacs-evil/evil-surround</a>
</li>

<li>Spacemacs<br />
<a href="http://spacemacs.org/">http://spacemacs.org/</a>
</li>

<li>Lisp: Common Lisp, Racket, Clojure, Emacs Lisp<br />
<a href="http://hyperpolyglot.org/lisp">http://hyperpolyglot.org/lisp</a>
</li>

<li>Common Lisp, Scheme, Clojure, And Elisp Compared<br />
<a href="http://irreal.org/blog/?p=725">http://irreal.org/blog/?p=725</a>
</li>

<li>Does Elisp Suck?<br />
<a href="http://irreal.org/blog/?p=675">http://irreal.org/blog/?p=675</a>
</li>

<li>Emacs pro mírně pokročilé (9): Elisp<br />
<a href="https://www.root.cz/clanky/emacs-elisp/">https://www.root.cz/clanky/emacs-elisp/</a>
</li>

<li>If I want to learn lisp, are emacs and elisp a good choice?<br />
<a href="https://www.reddit.com/r/emacs/comments/2m141y/if_i_want_to_learn_lisp_are_emacs_and_elisp_a/">https://www.reddit.com/r/emacs/comments/2m141y/if_i_want_to_learn_lisp_are_emacs_and_elisp_a/</a>
</li>

<li>Clojure(Script) Interactive Development Environment that Rocks!<br />
<a href="https://github.com/clojure-emacs/cider">https://github.com/clojure-emacs/cider</a>
</li>

<li>An Introduction to Emacs Lisp<br />
<a href="https://harryrschwartz.com/2014/04/08/an-introduction-to-emacs-lisp.html">https://harryrschwartz.com/2014/04/08/an-introduction-to-emacs-lisp.html</a>
</li>

<li>Emergency Elisp<br />
<a href="http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html">http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html</a>
</li>

<li>Lambda calculus<br />
<a href="https://en.wikipedia.org/wiki/Lambda_calculus">https://en.wikipedia.org/wiki/Lambda_calculus</a>
</li>

<li>John McCarthy's original LISP paper from 1959<br />
<a href="https://www.reddit.com/r/programming/comments/17lpz4/john_mccarthys_original_lisp_paper_from_1959/">https://www.reddit.com/r/programming/comments/17lpz4/john_mccarthys_original_lisp_paper_from_1959/</a>
</li>

<li>Micro Manual LISP<br />
<a href="https://www.scribd.com/document/54050141/Micro-Manual-LISP">https://www.scribd.com/document/54050141/Micro-Manual-LISP</a>
</li>

<li>How Lisp Became God's Own Programming Language<br />
<a href="https://twobithistory.org/2018/10/14/lisp.html">https://twobithistory.org/2018/10/14/lisp.html</a>
</li>

<li>History of Lisp<br />
<a href="http://jmc.stanford.edu/articles/lisp/lisp.pdf">http://jmc.stanford.edu/articles/lisp/lisp.pdf</a>
</li>

<li>The Roots of Lisp<br />
<a href="http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf">http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf</a>
</li>

<li>The Racket Manifesto<br />
<a href="http://felleisen.org/matthias/manifesto/">http://felleisen.org/matthias/manifesto/</a>
</li>

<li>MIT replaces Scheme with Python<br />
<a href="https://www.johndcook.com/blog/2009/03/26/mit-replaces-scheme-with-python/">https://www.johndcook.com/blog/2009/03/26/mit-replaces-scheme-with-python/</a>
</li>

<li>Adventures in Advanced Symbolic Programming<br />
<a href="http://groups.csail.mit.edu/mac/users/gjs/6.945/">http://groups.csail.mit.edu/mac/users/gjs/6.945/</a>
</li>

<li>Why MIT Switched from Scheme to Python (2009)<br />
<a href="https://news.ycombinator.com/item?id=14167453">https://news.ycombinator.com/item?id=14167453</a>
</li>

<li>Starodávná stránka XLispu<br />
<a href="http://www.xlisp.org/">http://www.xlisp.org/</a>
</li>

<li>AutoLISP<br />
<a href="https://en.wikipedia.org/wiki/AutoLISP">https://en.wikipedia.org/wiki/AutoLISP</a>
</li>

<li>Seriál PicoLisp: minimalistický a výkonný interpret Lispu<br />
<a href="https://www.root.cz/serialy/picolisp-minimalisticky-a-vykonny-interpret-lispu/">https://www.root.cz/serialy/picolisp-minimalisticky-a-vykonny-interpret-lispu/</a>
</li>

<li>Common Lisp<br />
<a href="https://common-lisp.net/">https://common-lisp.net/</a>
</li>

<li>Getting Going with Common Lisp<br />
<a href="https://cliki.net/Getting%20Started">https://cliki.net/Getting%20Started</a>
</li>

<li>Online Tutorial (Common Lisp)<br />
<a href="https://cliki.net/online%20tutorial">https://cliki.net/online%20tutorial</a>
</li>

<li>Guile Emacs<br />
<a href="https://www.emacswiki.org/emacs/GuileEmacs">https://www.emacswiki.org/emacs/GuileEmacs</a>
</li>

<li>Guile Emacs History<br />
<a href="https://www.emacswiki.org/emacs/GuileEmacsHistory">https://www.emacswiki.org/emacs/GuileEmacsHistory</a>
</li>

<li>Guile is a programming language<br />
<a href="https://www.gnu.org/software/guile/">https://www.gnu.org/software/guile/</a>
</li>

<li>MIT Scheme<br />
<a href="http://groups.csail.mit.edu/mac/projects/scheme/">http://groups.csail.mit.edu/mac/projects/scheme/</a>
</li>

<li>SIOD: Scheme in One Defun<br />
<a href="http://people.delphiforums.com/gjc//siod.html">http://people.delphiforums.com/gjc//siod.html</a>
</li>

<li>CommonLispForEmacs<br />
<a href="https://www.emacswiki.org/emacs/CommonLispForEmacs">https://www.emacswiki.org/emacs/CommonLispForEmacs</a>
</li>

<li>Elisp: print, princ, prin1, format, message<br />
<a href="http://ergoemacs.org/emacs/elisp_printing.html">http://ergoemacs.org/emacs/elisp_printing.html</a>
</li>

<li>Special Forms in Lisp<br />
<a href="http://www.nhplace.com/kent/Papers/Special-Forms.html">http://www.nhplace.com/kent/Papers/Special-Forms.html</a>
</li>

<li>Basic Building Blocks in LISP<br />
<a href="https://www.tutorialspoint.com/lisp/lisp_basic_syntax.htm">https://www.tutorialspoint.com/lisp/lisp_basic_syntax.htm</a>
</li>

<li>Introduction to LISP - University of Pittsburgh<br />
<a href="https://people.cs.pitt.edu/~milos/courses/cs2740/Lectures/LispTutorial.pdf">https://people.cs.pitt.edu/~milos/courses/cs2740/Lectures/LispTutorial.pdf</a>
</li>

<li>Why don't people use LISP<br />
<a href="https://forums.freebsd.org/threads/why-dont-people-use-lisp.24572/">https://forums.freebsd.org/threads/why-dont-people-use-lisp.24572/</a>
</li>

<li>Structured program theorem<br />
<a href="https://en.wikipedia.org/wiki/Structured_program_theorem">https://en.wikipedia.org/wiki/Structured_program_theorem</a>
</li>

<li>Clojure: API Documentation<br />
<a href="https://clojure.org/api/api">https://clojure.org/api/api</a>
</li>

<li>Tutorial for the Common Lisp Loop Macro<br />
<a href="http://www.ai.sri.com/pkarp/loop.html">http://www.ai.sri.com/pkarp/loop.html</a>
</li>

<li>Common Lisp's Loop Macro Examples for Beginners<br />
<a href="http://www.unixuser.org/~euske/doc/cl/loop.html">http://www.unixuser.org/~euske/doc/cl/loop.html</a>
</li>

<li>A modern list api for Emacs. No 'cl required.<br />
<a href="https://github.com/magnars/dash.el">https://github.com/magnars/dash.el</a>
</li>

<li>The LOOP Facility<br />
<a href="http://www.lispworks.com/documentation/HyperSpec/Body/06_a.htm">http://www.lispworks.com/documentation/HyperSpec/Body/06_a.htm</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>Transient Data Structures
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Jazyky Hy a Clojure-py: moderní dialekty LISPu určené pro Python VM<br />
<a href="https://www.root.cz/clanky/jazyky-hy-a-clojure-py-moderni-dialekty-lispu-urcene-pro-python-vm/">https://www.root.cz/clanky/jazyky-hy-a-clojure-py-moderni-dialekty-lispu-urcene-pro-python-vm/</a>
</li>

<li>Pixie: lehký skriptovací jazyk s „kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

<li>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/">https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/</a>
</li>

<li>Stránka projektu Jython<br />
<a href="http://www.jython.org/">http://www.jython.org/</a>
</li>

<li>Jython (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Jython">https://en.wikipedia.org/wiki/Jython</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">https://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>JSR 223: Scripting for the Java<sup>TM</sup> Platform<br />
<a href="https://jcp.org/en/jsr/detail?id=223">https://jcp.org/en/jsr/detail?id=223</a>
</li>

<li>List of JVM languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_JVM_languages">https://en.wikipedia.org/wiki/List_of_JVM_languages</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

