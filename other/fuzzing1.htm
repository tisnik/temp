<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Úvod do problematiky fuzzingu a fuzz testování</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Úvod do problematiky fuzzingu a fuzz testování</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Již několikrát jsme se na stránkách Rootu, především v každotýdenních postřezích z bezpečnosti, mohli setkat s termínem fuzzing nebo fuzz testování. V tomto článku se pokusíme o vysvětlení významu tohoto termínu. Popíšeme si i některé knihovny a nástroje používané pro fuzzing.</p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Úvod do problematiky fuzzingu a fuzz testování</a></p>
<p><a href="#k02">*** 2. Typy fuzzingu</a></p>
<p><a href="#k03">*** 3. Zrod termínu &bdquo;fuzzing&ldquo;</a></p>
<p><a href="#k04">*** 4. Vyhledávání operačních kódů neznámých instrukcí aneb slavná instrukce HCF</a></p>
<p><a href="#k05">*** 5. Pentium F00F bug</a></p>
<p><a href="#k06">*** 6. Nástroj <strong>crashme</strong></a></p>
<p><a href="#k07">*** 7. Fuzzy testování API a ABI</a></p>
<p><a href="#k08">*** 8. Slavný nástroj <strong>AFL</strong> &ndash; american fuzzy lop</a></p>
<p><a href="#k09">*** 9. Generování vstupních souborů</a></p>
<p><a href="#k10">*** 10. Fuzzy testování webových služeb a webových aplikací</a></p>
<p><a href="#k11">*** 11. Přehled vybraných knihoven pro fuzzy testování</a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. </a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Úvod do problematiky fuzzingu a fuzz testování</h2>

<p>V&nbsp;dnešním článku se seznámíme s&nbsp;problematikou takzvaného <i>fuzzingu</i> a <i>fuzz testování</i>. Jedná se o techniky určené pro testování stability, korektnosti a bezpečnosti aplikací či celých informačních systémů, které navíc mohou být &ndash; v&nbsp;porovnání s&nbsp;ručně vytvářenými testy &ndash; velmi efektivní. Principem fuzzingu je generování pseudonáhodných dat, posílání těchto dat do testovaného systému a zjišťování, jak se systém chová. Předchůdcem dnešních mnohdy velmi sofistikovaných systémů pro fuzzing jsou <i>random testy</i>, někdy nazývané <i>monkey testy</i>. Toto označení vzniklo z&nbsp;představy tlupy opic, které na klávesnici vytváří nesmyslné sekvence znaků, které jsou následně posílány do testované aplikace, popř.&nbsp;jiné tlupy opic zcela náhodně klikajících myší v&nbsp;grafickém uživatelském prostředí nějaké aplikace (mimochodem &ndash; tyto testy se někdy provádí i ručně, což je ovšem velmi drahé a navíc ani nelze zaručit například skutečnou náhodnost sekvence prováděných operací).</p>

<p><div class="rs-tip-major">Poznámka: pro počítače Macintosh dokonce vznikl systém pro testování GUI aplikací, který se jmenoval &bdquo;The Monkey&ldquo;.</div></p>

<p>Fuzzy testování je dnes považováno za poněkud odlišnou kategorii, než monkey testování, a to z&nbsp;toho důvodu, že mnohé moderní <i>fuzzery</i> (příkladem budiž slavný <i>AFL</i>) neprodukují čistě náhodné vstupy pro testovanou aplikaci, ale naopak se snaží produkovat vstup, který je do značné míry korektní, ovšem nějaká jeho část je modifikována. Navíc se většinou fuzzry snaží najít minimální množinu vstupních dat, která produkuje špatné výsledky popř.&nbsp;způsobí pád aplikace. Fuzzing se ovšem používá nejenom pro čisté testování stability, korektnosti a bezpečnosti aplikací. Lze ho taktéž použít pro řízené útoky na jednotlivé aplikace, služby operačního systému, samotná jádra operačního systému a dokonce i na samotný hardware. Fuzzing tak může být do jisté míry alternativou či spíše doplňkem penetračních testů.</p>

<p><div class="rs-tip-major">Poznámka: takové útoky je vhodné provést již při vývoji (samozřejmě v&nbsp;řízeném prostředí), protože lze předpokládat, že je dříve či později stejně provede někdo jiný :-)</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Typy fuzzingu</h2>

<p>Nástrojů pro fuzzy testování (budeme jim zkráceně říkat <i>fuzzery</i>) dnes existuje poměrně velké množství, ovšem ne všechny dostupné nástroje nabízí stejné vlastnosti a možnosti. Obecně je možné fuzzery rozdělit podle několika kritérií, zejména:</p>

<ol>

<li>Jakým způsobem jsou generovány vstupy použité v&nbsp;testech</li>

<li>Zda fuzzer zná a využívá informace o vnitřní struktuře testovaného systému či nikoli (black-box, white-box a gray-box testování)</li>

<li>A dále podle toho, zda a jak fuzzer rozumí struktuře vstupních dat či zda jen pseudonáhodně generuje vstupy bez dalších potřebných znalostí</li>

</ol>

<p><div class="rs-tip-major">Poznámka: obecně však neplatí, že je nejlepší použít takový fuzzer, který zná a využívá informace o vnitřní struktuře testovaného systému a navíc i &bdquo;chápe&ldquo; vstupní data. Mnoho chyb lze odhalit i naprosto jednoduchým fuzzerem, například dále zmíněným nástrojem <strong>crashme</strong> (čímž se přibližujeme k&nbsp;vlastnostem původních monkey testů).</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zrod termínu &bdquo;fuzzing&ldquo;</h2>

<p>Termín <i>fuzzing</i> se začal používat v&nbsp;roce 1988. Byl zaveden Bartonem Millerem, který si všiml, že náhodné vstupy (způsobené šumem na telefonní lince, kterou používal po připojení k&nbsp;univerzitnímu serveru s&nbsp;Unixem) přivedené do některých programů a utilit mohou vést k&nbsp;jejich pádu, tj.&nbsp;že zdaleka ne všechny vstupy jsou vždy řádně ošetřeny (testovaly se klasické programy a utility, včetně textového editoru Vi, awk, sort, sed, překladače cc atd.). Následně tento poznatek rozšířil a na kurzu, který vedl (Advanced Operating System) se tímto tématem začali věnovat i jeho studenti. A právě na tomto kurzu se začal používat termín &bdquo;fuzz&ldquo;. Zpočátku se sice fuzzing používal pro testování utility spouštěných z&nbsp;příkazové řádky, ale později byl celý koncept rozšířen i na aplikace s&nbsp;grafickým uživatelským rozhraním (tím se navázalo na nástroj &bdquo;The Monkey&ldquo; zmíněný <a href="#k01">v&nbsp;úvodní kapitole</a>).</p>

<p><div class="rs-tip-major">Poznámka: bližší informace je možné najít v&nbsp;knize <a href="https://books.google.at/books?id=tKN5DwAAQBAJ&pg=PR15&lpg=PR15&q=%22I+settled+on+the+term+fuzz%22&redir_esc=y&hl=de#v=onepage&q=%22I%20settled%20on%20the%20term%20fuzz%22&f=false">Fuzzing for Software Security Testing and Quality Assurance, Second Edition</a></div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Vyhledávání operačních kódů neznámých instrukcí aneb slavná instrukce HCF</h2>

<p>Techniky podobné fuzzingu se ovšem používaly i dříve. Oblíbenou disciplínou bylo vyhledávání nových operačních kódů nedokumentovaných instrukcí v&nbsp;instrukčních souborech starších procesorů a mikroprocesorů, u nichž se kvůli zjednodušení návrhu dekodéru (a většinou i mikroprogramového řadiče) neošetřovaly neznámé vstupy. Již v&nbsp;dobách počítačů řady IBM System/360 se polovážně mluvilo o instrukci <strong>HCF</strong> neboli plným jménem <i>Halt and Catch Fire</i>. Tato instrukce sice ve skutečnosti neexistovala, ale později se jméno <strong>HCF</strong> používalo pro nedokumentované instrukce, které nalezneme například u čipů <a href="https://www.liquisearch.com/halt_and_catch_fire/in_modern_cpus/motorola_6800">Motorola 6800</a> (zablokování mikroprocesoru), <a href="http://nparker.llx.com/a2/opcodes.html">MOS 6502</a> (kombinace několika jednodušších instrukcí), ale i čipů <a href="http://www.z80.info/z80undoc.htm">Z80</a> apod.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Pentium F00F bug</h2>

<p>Jednou z&nbsp;nejznámějších instrukcí spadajících do &bdquo;kategorie HCF&ldquo; (která byla pravděpodobně objevena právě zkoušením různých kombinací neznámých operačních kódů) je instrukce procesorů Intel Pentium, která by v&nbsp;assembleru vypadala následovně (nejedná se ovšem o validní instrukci, protože operandem by měla být adresa v&nbsp;paměti a nikoli pracovní registr):</p>

<pre>
lock cmpxchg8b eax
</pre>

<p>operační kód této instrukce v&nbsp;hexadecimálním kódu je:</p>

<pre>
F0 0F C7 C8
</pre>

<p>přičemž první dva znaky daly této chybě jméno. Problém &ndash; a to poměrně velký &ndash; spočíval v&nbsp;tom, že nevalidní instrukce by měly způsobit výjimku, kterou je možné dále zpracovat (aby například jádro systému mohlo vypsat informaci o tom, kde k&nbsp;takové výjimce došlo). Ovšem kombinace prefixu <strong>lock</strong> (zamčení sběrnice pro další procesory) s&nbsp;touto konkrétní instrukcí způsobila, že ani obsluha výjimky nebyla schopna přečíst data přes zamčenou sběrnici. Výsledkem bylo, že i běžný program spouštěný s&nbsp;právy běžného uživatele, dokázal celý procesor zastavit a musel být zresetován.</p>

<p><div class="rs-tip-major">Poznámka: zhruba ve stejné době byla objevena i chybná instrukce v&nbsp;mikroprocesorech Cyrix. Ta dostala název <i>Cyrix coma bug</i> a projevovala se podobně &ndash; po pokusu o vykonání této instrukce bylo zapotřebí mikroprocesor zresetovat.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Nástroj <strong>crashme</strong></h2>

<p><i>&bdquo;DO NOT USE THIS PROGRAM UNLESS YOU REALLY WANT TO CRASH YOUR COMPUTER.&ldquo;</i></p>

<p>Vraťme se ještě na chvíli k&nbsp;prehistorii nástrojů, které bychom dnes zařadili do kategorie <i>fuzzer</i>. Jedním z&nbsp;dnes již historických nástrojů, které je však možné stále nainstalovat i na moderní Linuxové distribuce, je nástroj nazvaný jednoduše a stručně <strong>crashme</strong>. Tento nástroj generuje náhodné sekvence bajtů, které se následně snaží spustit. Tímto způsobem se testuje stabilita a odolnost jádra operačního systému &ndash; předpokládá se totiž (a to zcela oprávněně), že ani zcela náhodná sekvence bajtů by neměla způsobit pád jádra operačního systému. Ovšem jak jsme mohli vidět <a href="#k05">v&nbsp;předchozí kapitole</a>, ne vždy musí být chyba v&nbsp;samotném jádře systému, protože moderní mikroprocesory jsou již velmi složité obvody, které prakticky <i>musí</i> obsahovat chyby.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Fuzzy testování API a ABI</h2>

<p>Velmi často se fuzzery používají pro testování API popř.&nbsp;i ABI. Typicky jsou fuzzery v&nbsp;tomto případě vhodným způsobem nakonfigurovány, aby mohly volat nativní funkce popř.&nbsp;metody a předávat jim generované parametry. Existují ovšem i sofistikovanější varianty fuzzerů, které je možné přilinkovat k&nbsp;testované knihovně. Díky tomu může fuzzer zjistit, který kód je pro jaké vstupy skutečně použit a příslušným způsobem vstupní data modifikovat. Příkladem takového fuzzeru je <a href="https://llvm.org/docs/LibFuzzer.html">libFuzzer</a>, který využívá <a href="http://clang.llvm.org/docs/SanitizerCoverage.html">SanitizerCoverage</a>.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Slavný nástroj <strong>AFL</strong> &ndash; american fuzzy lop</h2>

<p>Jedním z&nbsp;nejpoužívanějších a dalo by se říci, že i nejslavnějších fuzzy nástrojů je <i>AFL</i> neboli <i>american fuzzy lop</i>.</p>

<p><div class="rs-tip-major">Poznámka: možná se ptáte, z&nbsp;jakého důvodu by měl být nějaký obskurní fuzzy nástroj slavný. Je tomu tak z&nbsp;toho důvodu, že AFL byl použit pro odhalení některých poměrně závažných chyb, které (podle dnešní módy) dostaly i svá jména. Konkrétně se jednalo o Shellshock neboli Bashdoor, tedy o problém, který v&nbsp;důsledku postihl velké množství různých webových serverů i dalších služeb, které interně používají BASH.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Generování vstupních souborů</h2>

<p>Fuzzery se taktéž používají pro generování vstupních souborů, které jsou zpracovávány testovanými aplikacemi. V&nbsp;závislosti na typu aplikace může být takové testování přímočaré, ale mnohdy i velmi komplikované. Přímočaré testování lze použít u prakticky všech nástrojů, které čtou jeden vstupní soubor (či standardní vstup). Příkladem mohou být klasické unixové filtry (sort, uniq, sed, awk), ale i interně mnohem složitější nástroje typu překladač, interpret, linker, assembler apod., které již mnohdy vyžadují značně sofistikovaný fuzzer. Uveďme si ještě jeden příklad komplikovaného testování využívající fuzzer. Může se jednat o JVM či o webový browser, což jsou aplikace s&nbsp;mnoha (mnohdy poněkud skrytými vstupy). Například se jedná o soubory s&nbsp;fonty, což jsou interně velmi komplikované datové struktury, přičemž jakákoli chyba v&nbsp;knihovně, která tyto fonty zpracovává, může vést (v&nbsp;tom lepším případě) k&nbsp;pádu JVM/webového browseru, v&nbsp;horším případě pak k&nbsp;obejití &bdquo;sandboxu&ldquo;.</p>

<p><div class="rs-tip-major">Poznámka: tento příklad uvádím schválně, protože se již podobné chyby našly (libfreetype), nehledě na podobné knihovny pro práci s&nbsp;rastrovými obrázky atd.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Fuzzy testování webových služeb a webových aplikací</h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. Přehled vybraných knihoven pro fuzzy testování</h2>

<p>V&nbsp;navazujících kapitolách se ve stručnosti zmíníme o vybraných knihovnách, které je možné použít pro fuzzy testování. Vybrané knihovny jsou určeny pro různé programovací jazyky a mají i rozdílnou funkci &ndash; některé testují API a ABI, další jsou určeny spíše pro testování odolnosti celých aplikací, ostatní pak například pro testování webových služeb a aplikací založených na protokolu HTTP nebo HTTP/2.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. </h2>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Fuzzing (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Fuzzing">https://en.wikipedia.org/wiki/Fuzzing</a>
</li>

<li>american fuzzy lop<br />
<a href="http://lcamtuf.coredump.cx/afl/">http://lcamtuf.coredump.cx/afl/</a>
</li>

<li>AFL &ndash; QuickStartGuide.txt<br />
<a href="https://github.com/google/AFL/blob/master/docs/QuickStartGuide.txt">https://github.com/google/AFL/blob/master/docs/QuickStartGuide.txt</a>
</li>

<li>Introduction to Fuzzing in Python with AFL<br />
<a href="https://alexgaynor.net/2015/apr/13/introduction-to-fuzzing-in-python-with-afl/">https://alexgaynor.net/2015/apr/13/introduction-to-fuzzing-in-python-with-afl/</a>
</li>

<li>Writing a Simple Fuzzer in Python<br />
<a href="https://jmcph4.github.io/2018/01/19/writing-a-simple-fuzzer-in-python/">https://jmcph4.github.io/2018/01/19/writing-a-simple-fuzzer-in-python/</a>
</li>

<li>Golang Fuzzing: A go-fuzz Tutorial and Example<br />
<a href="http://networkbit.ch/golang-fuzzing/">http://networkbit.ch/golang-fuzzing/</a>
</li>

<li>Fuzzing Python Modules<br />
<a href="https://stackoverflow.com/questions/20749026/fuzzing-python-modules">https://stackoverflow.com/questions/20749026/fuzzing-python-modules</a>
</li>

<li>0x3 Python Tutorial: Fuzzer<br />
<a href="http://www.primalsecurity.net/0x3-python-tutorial-fuzzer/">http://www.primalsecurity.net/0x3-python-tutorial-fuzzer/</a>
</li>

<li>fuzzing na PyPi<br />
<a href="https://pypi.org/project/fuzzing/">https://pypi.org/project/fuzzing/</a>
</li>

<li>Fuzzing 0.3.2 documentation<br />
<a href="https://fuzzing.readthedocs.io/en/latest/">https://fuzzing.readthedocs.io/en/latest/</a>
</li>

<li>Randomized testing for Go<br />
<a href="https://github.com/dvyukov/go-fuzz">https://github.com/dvyukov/go-fuzz</a>
</li>

<li>HTTP/2 fuzzer written in Golang<br />
<a href="https://github.com/c0nrad/http2fuzz">https://github.com/c0nrad/http2fuzz</a>
</li>

<li>Ffuf (Fuzz Faster U Fool) – An Open Source Fast Web Fuzzing Tool<br />
<a href="https://hacknews.co/hacking-tools/20191208/ffuf-fuzz-faster-u-fool-an-open-source-fast-web-fuzzing-tool.html">https://hacknews.co/hacking-tools/20191208/ffuf-fuzz-faster-u-fool-an-open-source-fast-web-fuzzing-tool.html</a>
</li>

<li>Continuous Fuzzing Made Simple<br />
<a href="https://fuzzit.dev/">https://fuzzit.dev/</a>
</li>

<li>Halt and Catch Fire<br />
<a href="https://en.wikipedia.org/wiki/Halt_and_Catch_Fire#Intel_x86">https://en.wikipedia.org/wiki/Halt_and_Catch_Fire#Intel_x86</a>
</li>

<li>Pentium F00F bug<br />
<a href="https://en.wikipedia.org/wiki/Pentium_F00F_bug">https://en.wikipedia.org/wiki/Pentium_F00F_bug</a>
</li>

<li>Random testing<br />
<a href="https://en.wikipedia.org/wiki/Random_testing">https://en.wikipedia.org/wiki/Random_testing</a>
</li>

<li>Monkey testing<br />
<a href="https://en.wikipedia.org/wiki/Monkey_testing">https://en.wikipedia.org/wiki/Monkey_testing</a>
</li>

<li>Fuzzing for Software Security Testing and Quality Assurance, Second Edition<br />
<a href="https://books.google.at/books?id=tKN5DwAAQBAJ&pg=PR15&lpg=PR15&q=%22I+settled+on+the+term+fuzz%22&redir_esc=y&hl=de#v=onepage&q=%22I%20settled%20on%20the%20term%20fuzz%22&f=false">https://books.google.at/books?id=tKN5DwAAQBAJ&pg=PR15&lpg=PR15&q=%22I+settled+on+the+term+fuzz%22&redir_esc=y&hl=de#v=onepage&q=%22I%20settled%20on%20the%20term%20fuzz%22&f=false</a>
</li>

<li>Z80 Undocumented Instructions<br />
<a href="http://www.z80.info/z80undoc.htm">http://www.z80.info/z80undoc.htm</a>
</li>

<li>The 6502/65C02/65C816 Instruction Set Decoded<br />
<a href="http://nparker.llx.com/a2/opcodes.html">http://nparker.llx.com/a2/opcodes.html</a>
</li>

<li>libFuzzer – a library for coverage-guided fuzz testing<br />
<a href="https://llvm.org/docs/LibFuzzer.html">https://llvm.org/docs/LibFuzzer.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2020</small></p>
</body>
</html>

