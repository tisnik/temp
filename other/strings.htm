<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Interní reprezentace řetězců v různých programovacích jazycích: od počítačového pravěku po současnost</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Interní reprezentace řetězců v různých programovacích jazycích: od počítačového pravěku po současnost</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Textové řetězce &ndash; mohlo by se zdát, že práce s nimi vlastně není žádná věda, jedná se přece (zdánlivě) o pouhopouhou posloupnost znaků. Ve skutečnosti je však tato problematika poměrně rozsáhlá a může být řešena různými způsoby a technikami.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Interní reprezentace řetězců v&nbsp;různých jazycích: od počítačového pravěku po současnost</a></p>
<p><a href="#k02">2. Assemblery</a></p>
<p><a href="#k03">3. Řetězec bez ukončujícího znaku se známou délkou</a></p>
<p><a href="#k04">4. Řetězec s&nbsp;předem známým ukončujícím znakem</a></p>
<p><a href="#k05">5. Řetězce v&nbsp;původním Pascalu</a></p>
<p><a href="#k06">6. Řetězce v&nbsp;programovacím jazyku C</a></p>
<p><a href="#k07">7. Vylepšení práce s&nbsp;řetězci v&nbsp;UCSD Pascalu a Turbo Pascalu</a></p>
<p><a href="#k08">8. Interpretry a překladače BASICu</a></p>
<p><a href="#k09">9. Řetězce a pole řetězců v&nbsp;Sinclair BASICu</a></p>
<p><a href="#k10">10. Řetězce v&nbsp;Atari BASICu</a></p>
<p><a href="#k11">11. Příchod moderních programovacích jazyků &ndash; automatická správa paměti, problematika &bdquo;širokých&ldquo; znaků</a></p>
<p><a href="#k12">12. Řetězce podporující Unicode</a></p>
<p><a href="#k13">13. Formát řetězců v&nbsp;Javě</a></p>
<p><a href="#k14">14. Způsob ukládání řetězců na haldě v&nbsp;JVM</a></p>
<p><a href="#k15">15. Nové trendy při práci s&nbsp;řetězci</a></p>
<p><a href="#k16">16. Python 3.3 s&nbsp;flexibilní reprezentací řetězců</a></p>
<p><a href="#k17">17. Otestování velikosti objektů typu řetězec v&nbsp;Pythonu 3.4.3</a></p>
<p><a href="#k18">18. Interní reprezentace řetězce v&nbsp;Pythonu 3.4.3</a></p>
<p><a href="#k19">19. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Interní reprezentace řetězců v&nbsp;různých jazycích: od počítačového pravěku po současnost</h2>

<p>Problematika ukládání řetězců nám sice může na první pohled připadat
triviální, ovšem ve skutečnosti se jedná o dosti rozsáhlé téma, které je
poměrně aktuální, protože mnoho aplikací zpracovává enormní množství řetězců
(webové služby, postrelační databáze, ostatně i všechny moderní balíky
&bdquo;office&ldquo; interně pracují s&nbsp;relativně velkými dokumenty
v&nbsp;XML), s&nbsp;řetězci (konkrétně s&nbsp;céčkovými řetězci) se pojí
některé bezpečnostní problémy atd. Způsob interního ukládání řetězců ovlivňuje
i operace, které je s&nbsp;nimi možné provádět, takže si při studiu
jednotlivých technologií můžeme položit třeba následující otázky:</p>

<ol>

<li>Jsou řetězce neměnitelné (<i>immutable</i>) či měnitelné (<i>mutable</i>)?
Obojí přístup má svoje výhody a samozřejmě i nevýhody. Mimochodem &ndash;
většina dalších otázek se týká především měnitelných řetězců.</li>

<li>Pokud jsou řetězce měnitelné, lze modifikovat i jejich délku či nikoli?
V&nbsp;případě, že je délka měnitelná, znamená to, že runtime jazyka musí
umožňovat realokaci paměti.</li>

<li>Má jazyk rozpoznávat konstantní (statické) řetězce od měnitelných řetězců a
zpracovávat je odlišným způsobem? Asi nejdále byla tato idea rozvinuta
v&nbsp;jazyku Rust.</li>

<li>Pokud je délka řetězce specifikována při jeho deklaraci a nelze ji dále
změnit, co se stane ve chvíli, kdy se do řetězce přidají další znaky či se
naopak znaky odeberou?  Možností je opět více, například uživatelé Sinclair
BASICu asi znají termín Prokrústéúv řetězec používaný u polí řetězců (více viz
další kapitoly).</li>

<li>Jakým způsobem a kde se uloží délka řetězce? K&nbsp;dispozici je několik
možností &ndash; délku může znát jen překladač (původní Pascal, Fortran a
kupodivu i některé moderní jazyky se statickými řetězci), délka může být
uložena ve struktuře obalující řetězec, nebo se může použít vybraný znak
reprezentující konec řetězce.</li>

<li>Má řetězec obsahovat i další metainformace, například o použité kódové
stránce? To je příklad typu AnsiString v&nbsp;Delphi 2009.</li>

<li>Jak budou kódovány znaky v&nbsp;řetězci? Historicky se používal zejména
EBCDIC a ASCII, později se rozšířily i takzvané &bdquo;široké znaky&ldquo; a
dnes je k&nbsp;výběru hned několik možností, jak reprezentovat všechny znaky
z&nbsp;Unicode či jejich podmnožinu.</li>

<li>V&nbsp;případě blokového přenosu (resp.&nbsp;častěji kopie) řetězců je
taktéž nutné odpovědět na otázku, jak přesně se bude pracovat s&nbsp;koncem
řetězce ve chvíli, kdy jeho délka nebude rovna celočíselnému násobku velikosti
přenášené informace (typicky 2, 4 či osm bajtů). Jinými slovy &ndash; může se
rutina pro práci s&nbsp;řetězci dovolit přistupovat ZA konec řetězce či
nikoli?</li>

</ol>



<p><a name="k02"></a></p>
<h2 id="k02">2. Assemblery</h2>

<p>Na stránkách <a href="http://www.root.cz">Rootu</a> jsme se již několikrát
mohli setkat s&nbsp;takzvaným <i>assemblerem</i> neboli jazykem symbolických
instrukcí (<i>JSI</i>), alternativně též nazývaným jazykem symbolických adres
(<i>JSA</i>). Připomeňme si, že se jedná o nižší programovací jazyk,
v&nbsp;němž je možné psát programy na úrovni jednotlivých strojových instrukcí
konkrétního (vybraného) mikroprocesoru. To mimochodem znamená, že vzniklo
prakticky nepřeberné množství assemblerů, mnohdy dokonce více assemblerů pro
jediný typ mikroprocesoru (a naopak, některé assemblery podporují více
architektur CPU). Assemblery vznikly proto, že programování na úrovni
strojového kódu je velmi pracné, zejména ve chvíli, kdy je nutné existující
program modifikovat a tím pádem měnit cílové adresy skoků, adresy globálních
proměnných atd.</p>

<a href="http://www.root.cz/obrazek/210813/"><img src="http://i.iinfo.cz/images/462/dev-8bit-9-prev.png" class="image-210813" width="370" height="264" alt="&#160;" /></a>
<p><i>Obrázek 1: Úryvek programu napsaný v&nbsp;assembleru mikroprocesoru MOS
6502.</i></p>

<p>Assemblery tedy představovaly (a stále představují) mnohem civilizovanější
způsob programování, než přímý zápis strojového kódu. Některé assemblery šly
ještě dále, protože byly vybaveny více či méně dokonalým systémem maker
(s&nbsp;parametry i bez parametrů, popř.s&nbsp;volitelným typem jejich
expanze). Ostatně i z&nbsp;této vlastnosti vychází jejich běžné označení
&ndash; <i>macroassembler</i>.</p>

<a href="http://www.root.cz/obrazek/211571/"><img src="http://i.iinfo.cz/images/322/a2-prev.png" class="image-211571" alt="&#160;" height="264" width="370" /></a>
<p><i>Obrázek 2: Vývojové prostředí Atari Macro Assembleru.</i></p>

<p>Na tomto místě si můžeme položit obvyklou otázku &ndash; jak se vlastně
s&nbsp;řetězci pracuje v&nbsp;assemblerech a jak jsou řetězce reprezentovány?
Vzhledem k&nbsp;tomu, že assembler je v&nbsp;hierarchii programovacích jazyků
umístěn těsně nad strojovým kódem, je asi zřejmé, že reprezentace řetězců bude
odpovídat zvyklostem architektury konkrétního mikroprocesoru a taktéž
požadavkům operačního systému či knihoven, které se z&nbsp;assembleru
volají.</p>

<a href="http://www.root.cz/obrazek/210819/"><img src="http://i.iinfo.cz/images/462/dev-8bit-15-prev.png" class="image-210819" width="360" height="270" alt="&#160;" /></a>
<p><i>Obrázek 3: Vývojové prostředí Zeus Assembleru.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Řetězec bez ukončujícího znaku se známou délkou</h2>

<p>V&nbsp;tomto článku si ukážeme tři různé příklady, které se vždy týkají
řetězců používajících kódování ASCII. První příklad je naprogramován pro
mikroprocesory s&nbsp;architekturou x86-64 a je určen pro operační systém
Linux. Po překladu a spuštění by se měla na standardní výstup vypsat klasická
zpráva &bdquo;Hello world!&ldquo;, a to s&nbsp;využitím služby jádra operačního
systému <strong>sys_write</strong>, které se předá file deskriptor standardního
výstupu, adresa řetězce a jeho délka:</p>

<pre>
# asmsyntax=as
&nbsp;
&nbsp;
# Linux kernel system call table
sys_exit=1
sys_write=4
&nbsp;
&nbsp;
&nbsp;
#-----------------------------------------------------------------------------
.section .data
&nbsp;
hello_lbl:
        <strong>.string "Hello World!\n"</strong>
&nbsp;
#-----------------------------------------------------------------------------
.section .text
        .global _start          # tento symbol ma byt dostupny i linkeru
&nbsp;
_start:
        mov   $sys_write, %eax  # cislo syscallu pro funkci "write"
        mov   $1,%ebx           # standardni vystup
        mov   <strong>$hello_lbl</strong>,%ecx   # adresa retezce, ktery se ma vytisknout
        mov   <strong>$13</strong>,%edx          # pocet znaku, ktere se maji vytisknout
        int   $0x80             # volani Linuxoveho kernelu
&nbsp;
        movl  $sys_exit,%eax    # cislo sycallu pro funkci "exit"
        movl  $0,%ebx           # exit code = 0
        int   $0x80             # volani Linuxoveho kernelu
</pre>

<p>Povšimněte si, že řetězec je v&nbsp;tomto případě reprezentován jako sled
znaků, ovšem to samozřejmě <strong>nestačí</strong> &ndash; funkci jádra musíme
dodat i informaci o adrese začátku řetězce a navíc i jeho délku (počet znaků).
Díky tomu, že se délka řetězce předává v&nbsp;samostatném parametru, nemusí být
řetězec ukončen speciálním znakem (tak, jak je tomu v&nbsp;dalších
příkladech):</p>

<p>Pro architekturu AArch64 bude kód nepatrně odlišný (už jen proto, že se
změnily čísla syscallů), ovšem s&nbsp;řetězci se bude pracovat shodně:</p>

<pre>
# Linux kernel system call table
sys_exit=93
sys_write=64
&nbsp;
# List of syscalls for AArch64:
# https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h
&nbsp;
&nbsp;
&nbsp;
#-----------------------------------------------------------------------------
.section .data
&nbsp;
hello_lbl:
        <strong>.string "Hello World!\n"</strong>
&nbsp;
#-----------------------------------------------------------------------------
.section .text
        .global _start          // tento symbol ma byt dostupny i linkeru
&nbsp;
_start:
        mov  x8, #sys_write     // cislo sycallu pro funkci "write"
        mov  x0, #1             // standardni vystup
        ldr  x1, <strong>=hello_lbl</strong>     // adresa retezce, ktery se ma vytisknout
        mov  x2, <strong>#13</strong>            // pocet znaku, ktere se maji vytisknout
        svc  0                  // volani Linuxoveho kernelu
&nbsp;
        mov  x8, #sys_exit      // cislo sycallu pro funkci "exit"
        mov  x0, #0             // exit code = 0
        svc  0                  // volani Linuxoveho kernelu
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Řetězec s&nbsp;předem známým ukončujícím znakem</h2>

<p>Zatímco první příklad byl určen pro moderní operační systém (Linux) i pro
moderní mikroprocesory (x86-64 a AArch64), pochází druhý assemblerovský příklad
z&nbsp;poměrně dávné počítačové historie, konkrétně z&nbsp;dob kralování
různých variant DOSu. Tento příklad, který poběží na všech mikroprocesorech
řady Intel 8086, po svém překladu a spuštění taktéž vypíše zprávu na standardní
výstup <a
href="https://en.wikipedia.org/wiki/MS-DOS_API#DOS_INT_21h_services">službou
číslo 9</a>, dále počká na stisk klávesy a následně se program ukončí
(v&nbsp;případě COM programů stačí pro ukončení instrukce
<strong>RET</strong>).</p>

<p>Opět se zaměřme na to, jak jsou reprezentovány řetězce. Nyní není
reprezentace určena instrukční sadou ani snahou o kompatibilitu s&nbsp;vyššími
programovacími jazyky, ale konvencemi použitého operačního systému, které
v&nbsp;některých případech byly mimochodem &bdquo;vypůjčeny&ldquo; ze staršího
systému CP/M. Tyto konvence říkají, že při volání některých služeb jádra jsou
řetězce ukončeny znakem $, takže jsme v&nbsp;assembleru museli tento znak
<i>explicitně</i> zapsat (assembler to za nás v&nbsp;tomto případě neudělá
automaticky). Vzhledem k&nbsp;tomu, že systém přesně ví, kde je řetězec
ukončen, nemusí se službě jádra předávat jeho délka:</p>

<pre>
ideal
model   tiny                    ;pametovy model CS=DS=SS mensi nez 64kB
p286                            ;povoleny instrukce procesoru 286+
&nbsp;
;-----------------------------------------------------------------------------
dataseg                         ;zacatek data-segmentu
&nbsp;
message   db      <strong>"Hello world!$"</strong>
&nbsp;
;-----------------------------------------------------------------------------
codeseg                         ;zacatek code-segmentu
org     0100h                   ;zacatek kodu pro programy typu COM
&nbsp;
start:
&nbsp;
;------ Tisk retezce na obrazovku
        mov     dx, <strong>offset message</strong>
        mov     ah, 9
        int     21h
&nbsp;
;------ Vyprazdnit buffer klavesnice a cekat na klavesu
        xor     ax, ax
        int     16h
&nbsp;
;------ Ukonceni procesu
        retn
end start
</pre>

<p>Vzhledem ke značné flexibilitě assembleru v&nbsp;něm můžeme řetězce
reprezentovat takovými způsoby, které budou vyhovovat vyšším programovacím
jazykům a jejich knihovnám. V&nbsp;dalším příkladu se snažíme z&nbsp;assembleru
volat známou funkci <strong>putc()</strong> ze standardní knihovny jazyka C.
V&nbsp;céčku jsou řetězce uloženy jako sekvence znaků s&nbsp;ukončujícím znakem
s&nbsp;kódem 0 (dnes jde většinou o znak NUL z&nbsp;ASCII), takže před voláním
céčkovské funkce budeme muset připravit řetězce v&nbsp;tomto vyžadovaném
formátu. To není prakticky žádný problém, protože pouze za vlastní sekvenci
znaků přidáme nulu popř.&nbsp;můžeme v&nbsp;některých assemblerech použít makro
či direktivu pojmenovanou například <strong>.asciz</strong> (GNU Assembler) či
<strong>ASCIIZ</strong> (původní assembler pro PDP-10), která nulu doplní
automaticky a samozřejmě pro ni zarezervuje bajt v&nbsp;operační paměti:</p>

<pre>
# asmsyntax=as
&nbsp;
# Program pro otestovani volani funkci ze standardni knihovny jazyka C
# - volani funkce 'puts'
&nbsp;
.intel_syntax noprefix
&nbsp;
&nbsp;
&nbsp;
#-----------------------------------------------------------------------------
.section .data
hello_world_message:
        <strong>.asciz "Hello world!\n"</strong>    # zprava, ktera se ma vytisknout na standardni vystup
&nbsp;
&nbsp;
&nbsp;
#-----------------------------------------------------------------------------
.section .text
        .global main               # tento symbol ma byt dostupny i linkeru
&nbsp;
main:
        sub  rsp, 8                # zajistit zarovnani RSP na adresu delitelnou 16
&nbsp;
                                   # jedinym parametrem je adresa zpravy
        mov  rdi, <strong>offset hello_world_message</strong>
        call puts                  # volani funkce 'puts' ze standardni knihovny
&nbsp;
        add  rsp, 8                # obnoveni puvodni hodnoty RSP
&nbsp;
        xor  eax, eax              # navratova hodnota (exit status)
        ret                        # ukonceni aplikace
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Řetězce v&nbsp;původním Pascalu</h2>

<p>Původní Pascal práci s&nbsp;řetězci prakticky žádným způsobem nepodporoval,
pokud tedy nepočítáme možnost výpisu řetězcového literálu na terminál. Jediná
datová struktura, která se řetězci podobala, bylo pole znaků, u něhož překladač
znal jeho délku (délka je totiž součástí informace o typu, protože &bdquo;open
arrays&ldquo; začal Pascal podporovat až mnohem později). Takové pole se však
inicializovalo poněkud těžkopádně; znak po znaku. Navíc nebylo přesně
specifikováno chování v&nbsp;případě, že některé prvky pole nebyly
inicializovány a řetězec se měl vypsat:</p>

<pre>
type
    THistoricalString = array[0..10] of char;
var
    aString: THistoricalString; 
begin
    aString[0] := 'H';
    aString[1] := 'e';
    aString[2] := 'l';
    aString[3] := 'l';
    aString[4] := 'o';
    ...
    ...
    ...
end;
</pre>

<img src="https://i.iinfo.cz/images/644/retezce-1.png" class="image-303817" alt="&#160;" width="640" height="400" />
<p><i>Obrázek 4: Takto přibližně vypadá &bdquo;řetězec&ldquo; v&nbsp;původním
Pascalu.</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Řetězce v&nbsp;programovacím jazyku C</h2>

<p><i>&bdquo;To a lot of people, C is a dead language, and ${lang} is the
language of the future, for ever-changing transient values of ${lang}. The
reality of the situation is that all other languages today directly or
indirectly sit on top of the Posix API and the NUL-terminated string of
C.&ldquo;</i></p>

<p>V&nbsp;tomto článku se samozřejmě nemůžeme nezmínit o jazyku C, protože
způsob interní reprezentace řetězců v&nbsp;céčku ovlivnil celý další vývoj IT,
což se týká například i instrukčních sad mikroprocesorů. Ostatně i například
UTF-8 je navržen s&nbsp;ohledem na to, aby byl tento formát kompatibilní
s&nbsp;céčkovými řetězci (význam nulového znaku). Zkráceně &ndash; v&nbsp;céčku
jsou řetězce reprezentovány sekvencí znaků, přičemž tato sekvence je ukončena
znakem s&nbsp;kódem nula (<strong>NUL</strong> v&nbsp;ASCII, ovšem céčko nemusí
používat jen ASCII). To mimochodem znamená, že pro zjištění délky řetězce je
nutné ho celý projít a najít, na kterém místě se ona nula nachází.</p>

<p>Proč byl vlastně zvolen tento formát uložení, když už před vznikem céčka
existovaly odlišné formáty (například s&nbsp;délkou řetězce v&nbsp;prvním bajtu
či slovu, adresou začátku i konce řetězce apod.)? Céčko je částečně odvozeno od
programovacího jazyka B a když B vznikal, byly používány dosti rozmanité
počítačové architektury, v&nbsp;nichž se bitová šířka znaků pohybovala od
pouhých pěti bitů, přes běžnějších 7 a 8 bitů až po znaky o šířce 22 bitů.
Stanovit tedy, že první znak bude obsahovat délku řetězce bylo poněkud
ošemetné, zejména na strojích s&nbsp;pětibitovými znaky. Navíc by byla
maximální délka řetězců závislá na použité platformě, což by nepřispělo
k&nbsp;přenositelnosti programů.</p>

<p>Volba, kterou autoři céčka udělali, je proto pochopitelná; ostatně céčko
bylo bez problémů portováno snad na všechny procesorové architektury, včetně <a
href="https://www.root.cz/clanky/digitalni-signalove-procesory-rady-tms320/">DSP,
které zpracovávají jen slova o šířce 32 bitů</a>, počítačů používajících EBCDIC
namísto ASCII atd.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vylepšení práce s&nbsp;řetězci v&nbsp;UCSD Pascalu a Turbo Pascalu</h2>

<p>Pro vývoj Pascalu se stal přelomovým projektem UCSD Pascal, který přinesl
novinku &ndash; překlad do takzvaného P-kódu, jenž byl zpracováván virtuálním
strojem, což je stejná technologie, jaká se používá doposud (Java, Python, Lua
atd.). Navíc ještě UCSD Pascal přinesl podporu pro práci s&nbsp;řetězci, které
již byly reprezentovány &bdquo;klasickým Pascalovským&ldquo; stylem, tedy polem
bajtů, jehož první prvek nesl informaci o délce řetězce. Tuto novinku později
převzal i slavný Turbo Pascal, takže i v&nbsp;tomto jazyku lze poměrně
flexibilně pracovat s&nbsp;řetězci o maximální délce 255 znaků.</p>

<p>Navíc zůstala zachována podpora i polí znaků (většinou se používá zápis
<strong>packed array</strong>, i když <strong>packed</strong> Turbo Pascal
ignoruje), přičemž konstantní pole znaků bylo možné inicializovat tak, jak je
to patrné z&nbsp;dalšího obrázku (dost se to podobá céčkovému způsobu
inicializace). Aby toho nebylo málo, podporuje Turbo Pascal typ
<strong>PChar</strong>, jenž odpovídá céčkovskému <strong>char *</strong> se
stejným významem. Tento typ se používá mj.&nbsp;i pro nulou ukončené
řetězce.</p>

<img src="https://i.iinfo.cz/images/644/retezce-2.png" class="image-303818" alt="&#160;" width="640" height="400" />
<p><i>Obrázek 5: Některé operace, které lze s&nbsp;řetězci provádět
v&nbsp;Turbo Pascalu.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Interpretry a překladače BASICu</h2>

<p>Při popisu vývoje různých způsobů reprezentace řetězců samozřejmě nesmíme
zapomenout ani programovací jazyk, jehož více či méně kvalitní dialekty
existovaly prakticky pro všechny typy domácích (ale i profesionálních)
osmibitových počítačů. Jedná se samozřejmě o jazyk <i>BASIC</i> (<i>Beginner's
All-purpose Symbolic Instruction Code</i>), jehož syntaxe a především sémantika
pozitivně ale i negativně ovlivnily celou jednu generaci programátorů (včetně
autora tohoto článku :-). Ovšem tento programovací jazyk je z&nbsp;historického
hlediska zajímavý i proto, že se v&nbsp;souvislosti s&nbsp;jeho vývojem poprvé
objevují jména Bill Gates a Paul Allen spolu s&nbsp;jejich společností původně
nazývanou <i>Micro-Soft</i>.</p> 

<a href="http://www.root.cz/obrazek/210821/"><img src="http://i.iinfo.cz/images/462/dev-8bit-17-prev.png" class="image-210821" width="215" height="270" alt="&#160;" /></a>
<p><i>Obrázek 6: Manuál k&nbsp;původnímu BASICu.</i></p>

<p>Programovací jazyk <i>BASIC</i> byl vyvinut v&nbsp;roce 1964 J. G. Kemenym a
T. E. Kurtzem na universitě v&nbsp;Dartmouthu. Kemeny a Kurtz tento jazyk
navrhli s&nbsp;ohledem na to, aby umožnili rychlé osvojení ovládání počítačů i
jejich programování pracovníkům a studentům, kteří nejsou (a ani nechtějí být)
specialisty na programování, ale potřebují problémy řešené v&nbsp;jejich praxi
vhodným způsobem algoritmizovat a následně vhodným způsobem zapsat tak, aby
počítač mohl zapsané algoritmy skutečně provést. Důraz na co největší
jednoduchost jazyka se projevil například omezením počtu proměnných na 26,
automatickou deklarací a inicializací proměnných (což je u větších programů
velmi záludná vlastnost), existencí (původně) pouze jednoho datového typu
atd.</p>

<a href="http://www.root.cz/obrazek/210823/"><img src="http://i.iinfo.cz/images/462/dev-8bit-19-prev.jpg" class="image-210823" width="364" height="270" alt="&#160;" /></a>
<p><i>Obrázek 7: BASIC pro mikropočítače Apple-II.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Řetězce a pole řetězců v&nbsp;Sinclair BASICu</h2>

<p>Zajímavé je, že první verze BASICu práci s&nbsp;řetězci vlastně vůbec
nepodporovala; tato velmi důležitá funkcionalita byla do jazyka přidána až o
rok později, tedy v&nbsp;roce 1965. Od té doby se však jednalo o nezbytnou
součást BASICu, i když funkce a operace pro práci s&nbsp;řetězci byly
v&nbsp;různých dialektech dosti odlišné. Pro představení dvou způsobů uložení
řetězců se podívejme na Sinclair Basic a Atari Basic, což jsou dva interpretry,
které se od sebe v&nbsp;mnoha ohledech velmi liší.</p>

<a href="http://www.root.cz/obrazek/210827/"><img src="http://i.iinfo.cz/images/462/dev-8bit-23-prev.png" class="image-210827" width="357" height="270" alt="&#160;" /></a>
<p><i>Obrázek 8: BASIC na slavném mikropočítači ZX-81.</i></p>

<p>Sinclair Basic podporuje práci s&nbsp;běžnými řetězci, které mohou mít
flexibilní délku, není nutné dopředu udávat jejich velikost a lze s&nbsp;nimi
provádět řadu zajímavých operací díky podpoře takzvaného &bdquo;slicingu&ldquo;
(specifikaci podřetězce zadáním indexu prvního a posledního znaku):</p>

<pre>
10 LET a$="abcdef"
20 FOR n=1 TO 6
30 PRINT a$(n TO 6)
40 NEXT n
50 STOP
</pre>

<img src="http://i.iinfo.cz/images/122/pc6703.png" width="304" height="232" alt="pc6703" />
<p><i>Obrázek 9: Znaková sada mikropočítače ZX80 a taktéž i mikropočítače ZX81,
která byla uložena v&nbsp;paměti ROM, jejíž celková kapacita dosahovala 4kB
resp.&nbsp;8kB (nejvíce místa zabral interpret jazyka Basic). S&nbsp;využitím
znaků z&nbsp;této sady bylo možné vykreslit i poměrně věrohodné obrázky a
složité herní scény. Povšimněte si, že tato znaková sada neodpovídá ASCII a
navíc obsahuje pouze 64 znaků; dalších 64 znaků jsou jen inverzní
varianty.</i></p>

<p>Kromě běžných řetězců lze v&nbsp;Sinclair Basicu pracovat i s&nbsp;poli
řetězců, ovšem v&nbsp;tomto případě mají řetězce uložené v&nbsp;poli konstantní
velikost specifikovanou při vytváření pole příkazem <strong>DIM</strong>.
Všechny operace s&nbsp;řetězci uloženými v&nbsp;poli zajistí, že se nezmění
délka řetězce &ndash; kratší řetězce jsou doplněny na plnou délku, potenciálně
delší řetězce jsou uříznuty, opět tak, aby se řetězec nezvětšil nebo nedošlo
k&nbsp;přepisu paměti, která mu nepatří. Toto chování se někdy nazývá
Prokrústéovo přiřazení podle postavy <a
href="https://cs.wikipedia.org/wiki/Prokr%C3%BAst%C3%A9s">Prokrústéa</a>
z&nbsp;řecké mytologie (ten ovšem nepracoval s&nbsp;řetězci, ale s&nbsp;lidmi
:-).</p>

<a href="http://www.root.cz/obrazek/210833/"><img src="http://i.iinfo.cz/images/462/dev-8bit-29.png" class="image-210833" width="256" height="192" alt="&#160;" /></a>
<p><i>Obrázek 10: Editace programu na ZX Spectru v&nbsp;řádkovém
editoru.</i></p>

<p>Interně jsou řetězce uloženy ve formátu naznačeném na osmém obrázku.
Povšimněte si, že pro jméno řetězce zbylo jen pět bitů, takže jméno může být
jen jednopísmenné. Délka řetězce je &ndash; z&nbsp;pohledu kapacity operační
paměti ZX Spectra &ndash; neomezená, což je velký rozdíl oproti klasickým
&bdquo;Pascalovským řetězcům&ldquo; omezeným na 255 znaků.</p>

<img src="https://i.iinfo.cz/images/644/retezce-3.png" class="image-303819" alt="&#160;" width="506" height="126" />
<p><i>Obrázek 11: Formát uložení řetězců.</i></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Řetězce v&nbsp;Atari BASICu</h2>

<p>Poněkud odlišným způsobem je uložení řetězců realizováno v&nbsp;Atari
BASICu. V&nbsp;tomto dialektu BASICu je totiž nutné velikost řetězce předem
určit příkazem DIM, který současně i provede alokaci paměti pro řetězec.
V&nbsp;paměti jsou přitom uloženy dvě struktury, které řetězec plně popisují
&ndash; jedná se především o sekvenci znaků v&nbsp;kódování ATASCII (odvozeno
od ASCII doplněním spodních 32 znaků a změnou několika běžných znaků) a taktéž
o strukturu o délce osmi bajtů, která obsahuje typ proměnné (první bajt), index
jména proměnné s&nbsp;řetězcem (druhý bajt), adresu začátku řetězce (přesněji
řečeno offset), alokovanou délku řetězce (maximálně 32767 znaků) a aktuální
délku řetězce (opět maximálně 32767 znaků). To znamená, že i když je například
provedena alokace pro řetězec o délce 1000 znaků, může v&nbsp;něm být reálně
uloženo jen deset znaků.</p>

<img src="https://i.iinfo.cz/images/644/retezce-4.png" class="image-303820" alt="&#160;" width="640" height="384" />
<p><i>Obrázek 12: Po inicializaci interpretru Atari Basicu je k&nbsp;dispozici
37902 volných bajtů. Po alokaci řetězce o délce deseti znaků přijdeme celkem o
20 bajtů &ndash; dva bajty zabere název proměnné, osm bajtů struktura popsaná
výše (typ+index proměnné, adresa řetězce, jeho maximální délka a aktuální
délka) a zbylých 10 bajtů je vyhrazeno pro vlastní řetězec.</i></p>

<p>Veškeré operace s&nbsp;řetězci jsou zcela bezpečné, protože nikdy nedojde
k&nbsp;překročení jeho délky (přepisu jiné paměti); při spojování řetězců dojde
k&nbsp;ukončení na předem stanoveném limitu.  Mimochodem: poměrně častým trikem
bylo uložení strojových instrukcí do řetězce, zjištění adresy řetězce funkcí
<strong>ADR</strong> a &bdquo;spuštění řetězce&ldquo; další funkcí
<strong>USR</strong>.</p>

<img src="https://i.iinfo.cz/images/644/retezce-5.png" class="image-303821" alt="&#160;" width="640" height="384" />
<p><i>Obrázek 13: Pokud alokujeme další řetězec o maximální kapacitě 100 znaků,
přijdeme o 110 bajtů. Opět platí, že &bdquo;chybějících&ldquo; deset bajtů bylo
použito pro jméno proměnné, její typ, adresu+délku+maximální délku
řetězce.</i></p>

<p>Vzhledem k&nbsp;tomu, že Atari BASIC neumožňuje ukládat řetězce do polí,
bylo možné operátor indexování () &bdquo;přetížit&ldquo; takovým způsobem, že
je možné přistupovat jak k&nbsp;jednotlivým znakům řetězce, tak i
k&nbsp;podřetězci (jedná se tedy o slicing). Tento operátor je možné použít i
na levé straně přiřazovacího příkazu pro změnu vybrané části řetězce:</p>

<pre>
10 DIM S$(15),T$(15),Q$(15)      vypíše se
20 S$="ATASIC":PRINT S$          ATASIC
30 Q$=S$(3,5):PRINT Q$           ASI
40 T$="RI_BA":PRINT T$           RI_BA
50 S$(7,13)="T$:PRINT S$         ATASICRI_BA
60 S$=S$(1,6):PRINT S$           ATASIC
70 T$(6,9)=S$(4,6):PRINT T$      RI_BASIC
80 S$(4)=T$:PRINT S$             ATARI_BASIC
90 Q$=S$(1):PRINT Q$             ATARI_BASIC
100 Q$=S$(1,1):PRINT Q$          A
</pre>

<img src="https://i.iinfo.cz/images/644/retezce-6.png" class="image-303822" alt="&#160;" width="640" height="384" />
<p><i>Obrázek 14: Z&nbsp;výpisu adres řetězců je zřejmé, že jsou v&nbsp;paměti
uloženy těsně za sebou (první řetězec má délku 10 znaků) a že se nepočítá
s&nbsp;žádným ukončovacím znakem.</i></p>

<img src="https://i.iinfo.cz/images/644/retezce-7.png" class="image-303823" alt="&#160;" width="640" height="384" />
<p><i>Obrázek 15: Do řetězce A$ o kapacitě deseti znaků můžeme uložit kratší
text a zjistit jeho délku. Při snaze o uložení delšího textu nedojde
k&nbsp;žádné chybě a už vůbec ne k&nbsp;přepisu cizí paměti &ndash; řetězec se
pouze na příslušném místě odřízne.</i></p>

<img src="https://i.iinfo.cz/images/644/retezce-8.png" class="image-303824" alt="&#160;" width="640" height="384" />
<p><i>Obrázek 16: Pokus o alokaci řetězce, který se již nevejde do volné
operační paměti samozřejmě skončí s&nbsp;chybou a proměnná nebude
vytvořena.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Příchod moderních programovacích jazyků &ndash; automatická správa paměti, problematika &bdquo;širokých&ldquo; znaků</h2>

<p><i>&bdquo;I always thought it was a rite of passage for all C++ programmers
to write their own string library&ldquo;</i></p>

<p>Jazyk C i Pascal (například Turbo Pascal před rozšířením o OOP) je možné
považovat za klasické překládané jazyky, které se v&nbsp;devadesátých letech
používaly pro tvorbu většiny aplikací. Postupně se však začaly rozšiřovat
moderní (a &bdquo;moderní&ldquo;) programovací jazyky, ať již kompilované (C++)
nebo skriptovací (zpočátku TCL a Perl, později Python a Ruby, ať dodržíme
pořadí jejich vzniku). Většina těchto jazyků více či méně úspěšně řešila
problematiku automatické správy paměti při práci s&nbsp;řetězci. Příkladem
jednoho řešení může být Delphi 2 používající alokaci řetězců na haldě (heapu)
s&nbsp;počítáním referencí (což je řešení, které například u klasického C nelze
použít).</p>

<p>Navíc se s&nbsp;příchodem desktopových aplikací a rozsáhlých databází
používaných mezinárodními firmami začala ukazovat potřeba rozumného a
unifikovaného kódování znaků různých abeced, protože řešení spočívající
v&nbsp;použití kódových stránek (u nás CP852 neboli PC Latin 2, ISO-8859-2
neboli ISO Latin 2, KOI-8 CS2 definovaná CSN 36 9103, neoficiální ale o to
povedenější stránka bratrů Kamenických, Windows-1250, MacOS CE atd.) vede u
mezinárodně používaných aplikací k&nbsp;mnoha problémům (ostatně i dnes ještě
narazíme například na webové stránky, jejichž kódování neodpovídá hlavičce
posílané serverem a podobné špeky).</p>

<a href="http://i.iinfo.cz/images/38/ibm-5-4.jpg"><img src="http://i.iinfo.cz/images/38/ibm-5-4-prev.jpg" alt="ibm-5" height="270" width="191" /></a>
<p><i>Obrázek 17: Spolu s&nbsp;rozšiřováním Fortranu z&nbsp;mainframů firmy IBM
na další architektury se zvyšovala potřeba standardizace tohoto jazyka.
Postupně vzniklo několik norem, například ANSI norma FORTRAN 66, FORTRAN 77, či
ANSI/ISO standard Fortran 90 (názvy standardů jsou uvedeny správně &ndash;
jméno jazyka se skutečně postupem času změnilo z &bdquo;FORTRAN&ldquo; na
&bdquo;Fortran&ldquo;).</i></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Řetězce podporující Unicode</h2>

<p>Do mnoha jazyků se začala z&nbsp;výše uvedených důvodů postupně přidávat
podpora pro takzvané &bdquo;široké znaky&ldquo;. Jazyk C byl v&nbsp;rámci
standardu C90 rozšířen o typ <strong>wchar_t</strong> (ten ovšem nemá pevně
specifikovanou šířku), a v&nbsp;roce 2011 o typy <strong>char16_t</strong> a
<strong>char32_t</strong> s&nbsp;explicitní šířkou, ovšem bez specifikace
kódování (většinou <strong>char16_t</strong> používá UCS-2 a
<strong>char32_t</strong> UCS-4). Podobně bylo rozšířeno i zmíněné Delphi,
nejdříve o typ AnsiString v&nbsp;Delphi 2 a později o Unicodestring
v&nbsp;Delphi 2009. Přechod na &bdquo;široké znaky&ldquo; se samozřejmě
nevyhnul ani skriptovacím jazykům, takže například Python používal buď UCS-2
(typicky ve verzi pro Windows) nebo UCS-4 při překladu na Linuxu (ovšem jedná
se o volitelné nastavení, které lze změnit při překladu). Další příklady,
včetně novinek přidaných do Pythonu 3.3, jsou uvedeny v&nbsp;navazujících
kapitolách.</p>

<p>V&nbsp;současnosti se můžeme nejčastěji setkat se čtyřmi interními
reprezentacemi řetězců:</p>

<ul>
<li>8bitové kódování (ASCII, kódové stránky, některé aplikace &bdquo;zkousnou&ldquo; i UTF-8)</li>
<li>16bitové kódování, typicky UCS-2 (ovšem nevyhovuje například z&nbsp;toho důvodu, že budou <a href="https://en.wikipedia.org/wiki/GB_18030">problémy na čínském trhu</a>), existuje i ve variantě UTF-16, což je to nehorší z&nbsp;obou světů :-)</li>
<li>32bitové kódování, typicky UCS-4</li>
<li>variabilní délka znaků, UTF-8 (používáno například v&nbsp;Rustu)</li>
</ul>



<p><a name="k13"></a></p>
<h2 id="k13">13. Formát řetězců v&nbsp;Javě</h2>

<p>V&nbsp;Javě se na řetězce můžeme dívat dvěma pohledy. Na jednu stranu se
jedná o pouhou třídu, jejíž instance lze vytvářet s&nbsp;využitím operátoru
<strong>new</strong>, na stranu druhou však pro práci s&nbsp;řetězci existuje
podpora v&nbsp;samotné syntaxi a sémantice tohoto programovacího jazyka,
protože do programů je možné zapisovat řetězcové literály (konstantní řetězce)
a navíc pro řetězce existují přetížené verze operátorů + a += (nikoli však již
operátoru ==, což stále vede ke vzniku mnohdy těžko objevitelných sémantických
chyb). To však není vše, protože řetězcové literály jsou ukládány
v&nbsp;<i>constant poolu</i> (<a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-2-cast-podrobnejsi-analyza-obsahu-constant-poolu">http://www.root.cz/clanky/pohled-pod-kapotu-jvm-2-cast-podrobnejsi-analyza-obsahu-constant-poolu</a>),
takže řetězce jsou skutečně na platformě Java zpracovávány jiným způsobem, než
další třídy a jejich instance (navíc s&nbsp;JDK7 existuje pro řetězce speciální
forma rozeskoku <strong>switch</strong> &ndash; viz též <a
href="http://www.root.cz/clanky/novinky-v-nbsp-jdk-7-aneb-mirny-pokrok-v-nbsp-mezich-zakona-1/">http://www.root.cz/clanky/novinky-v-nbsp-jdk-7-aneb-mirny-pokrok-v-nbsp-mezich-zakona-1/</a>).</p>

<p>Z&nbsp;hlediska vývojáře je důležitý taktéž fakt, že řetězce jsou
neměnitelné (<i>immutable</i>), což s&nbsp;sebou přináší jak některé výhody,
tak i komplikace, především ve chvíli, kdy se mají s&nbsp;řetězci provádět
složitější operace. Interně řetězce vypadají poměrně jednoduše, alespoň při
prvním pohledu, protože jsou tvořeny polem <strong>char[]</strong>, což
znamená, že každý prvek tohoto pole má velikost šestnáct bitů. Pro většinu
abeced platí, že každý znak uložený v&nbsp;tomto poli skutečně odpovídá jednomu
znaku dané abecedy (latinky, azbuky, alfabety ...), ovšem ve skutečnosti není
možné v&nbsp;rozsahu 0..2<sup>16</sup> reprezentovat libovolný znak definovaný
v&nbsp;normě Unicode. To platí pouze pro znaky s&nbsp;kódem 0x0000 až 0xFFFF,
které se někdy označují názvem <i>Basic Multilingual Plane (BMP)</i>, které
jsou v&nbsp;řetězci uloženy stylem jeden_znak_abecedy == 1 char. Pro znaky
s&nbsp;vyšším kódem (až 0x10FFFF) je nutné v&nbsp;řetězci vyhradit pár hodnot
typu <strong>char</strong>, tento pár se jmenuje <i>surrogate pair</i>.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Způsob ukládání řetězců na haldě v&nbsp;JVM</h2>

<p>Na haldě (kde se alokují všechny objekty, tj.&nbsp;referenční datové typy),
je každý řetězec představován dvěma objekty &ndash; instancí třídy
<strong>String</strong> a instancí pole <strong>char[]</strong> &ndash; toto
pole je sice atributem třídy <strong>String</strong>, ovšem pole jsou, chápána
jako objekty, tudíž se namísto pole ukládá pouze jeho reference.  To
s&nbsp;sebou nese určitou (osobně bych řekl, že velmi velkou) režii, která vede
k&nbsp;tomu, že řetězce používané v&nbsp;typických Javovských aplikacích
spotřebují daleko větší množství operační paměti, než je na první pohled
patrné.</p>

<p>Nejprve se podívejme na to, jak je uložena každá instance třídy
<strong>String</strong>:</p>

<table>
<tr><th>#</th><th>Velikost (B)</th><th>Struktura</th><th>Popis</th></tr>
<tr><td>1</td><td>8</td><td>HEADER</td><td>hlavička objektu (přiřazena každému objektu na haldě)</td></tr>
<tr><td>2</td><td>4</td><td>int offset</td><td>atribut <strong>offset</strong> instance třídy String</td></tr>
<tr><td>3</td><td>4</td><td>int count </td><td>atribut <strong>count</strong> instance třídy String</td></tr>
<tr><td>4</td><td>4</td><td>int hash  </td><td>atribut <strong>hash</strong> instance třídy String</td></tr>
<tr><td>5</td><td>4</td><td>char[]    </td><td>reference na pole znaků</td></tr>
</table>

<p>Celková velikost paměti pro uložení instance třídy <strong>String</strong>
je tedy minimálně 24 bajtů, a to pouze v&nbsp;případě, že reference na objekty
má šířku 32 bitů a nikoli 64 bitů (i to je možné v&nbsp;případě větších kapacit
hald). Oněch 24 bajtů se označuje <i>shallow size</i> (&bdquo;mělká
velikost&ldquo; značící, že nebereme v&nbsp;úvahu velikosti objektových
atributů) a je stejná pro všechny instance třídy String.</p>

<p>To však samozřejmě není vše, protože instance třídy <strong>String</strong>
se pouze odkazuje na pole <strong>char[]</strong>, které je na haldě uloženo
následovně:</p>

<table>
<tr><th>#</th><th>Velikost (B)</th><th>Struktura</th><th>Popis</th></tr>
<tr><td>1</td><td>8</td><td>HEADER</td><td>hlavička objektu (přiřazena každému objektu na haldě)</td></tr>
<tr><td>2</td><td>4</td><td>int length</td><td>délka pole = délka řetězce ve znacích</td></tr>
<tr><td>3</td><td>x</td><td>length*2</td><td>vlastní obsah řetězce</td></tr>
<tr><td>4</td><td>0 nebo 2</td><td>PADDING</td><td>výplň, aby celková délka objektu byla dělitelná čtyřmi (někdy osmi)</td></tr>
</table>

<p>I pro pole <strong>char[]</strong>, které bude obsahovat pouze jeden znak,
tedy bude na haldě alokována paměť o velikosti šestnácti bajtů!</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Nové trendy při práci s&nbsp;řetězci</h2>

<p>Konečně se dostáváme k&nbsp;programovacím jazyků, jejichž autoři se nebáli
s&nbsp;řetězci pracovat poněkud neortodoxním způsobem. Jedná se především o
jazyk Rust a kupodivu taktéž o Python, přesněji řečeno Python od verze 3.3,
v&nbsp;níž došlo sice k&nbsp;méně známé, ale o to důležitější změně.
Problematice práce s&nbsp;řetězci v&nbsp;Rustu jsme se již <a
href="https://www.root.cz/clanky/prace-s-retezci-v-programovacim-jazyku-rust/">relativně
podrobně věnovali</a> (ovšem chystám ještě doplnění tohoto článku na základě
dotazů), takže se podívejme, jak s&nbsp;řetězci pracuje Python, konkrétně
Python 3.3 a vyšší. Předchozí verze Pythonu totiž mohly být zkompilovány buď
s&nbsp;podporou UCS-2 nebo UCS-4 [<a
href="https://mail.python.org/pipermail/python-dev/2008-July/080886.html">1</a>].</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Python 3.3 s&nbsp;flexibilní reprezentací řetězců</h2>

<p>V&nbsp;programovacím jazyku Python verze 3.3 došlo k&nbsp;poměrně významné
změně, která se týká způsobu interního uložení řetězců. Autoři Pythonu si totiž
uvědomili, že na jednu stranu je sice důležité podporovat Unicode (a to celé
Unicode, žádný subset typu <a
href="https://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane">BMP</a>,
vzhledem k&nbsp;normě <a href="https://en.wikipedia.org/wiki/GB_18030">GB
18030</a>) ovšem v&nbsp;mnoha případech to vede k&nbsp;tomu, že se do operační
paměti ukládá až čtyřikrát větší množství dat, než je skutečně nutné, protože
mnoho řetězců používaných v&nbsp;každodenní praxi obsahuje pouze ASCII znaky.
Navíc větší množství dat uložených v&nbsp;paměti znamená, že se při manipulaci
s&nbsp;nimi bude hůře využívat procesorová cache. Proto došlo v&nbsp;rámci <a
href="https://www.python.org/dev/peps/pep-0393/">PEP 393</a> k&nbsp;takové
úpravě, která zajistí možnost uložení řetězců ve třech formátech, což je
naznačeno v&nbsp;tabulce:</p>

<table>
<tr><th>Šířka znaku</th><th>Kódování</th><th>Prefix při zápisu kódu</th></tr>
<tr><td>1 bajt</td><td>Latin-1</td><td>\x</td></tr>
<tr><td>2 bajty</td><td>UCS-2</td><td>\u</td></tr>
<tr><td>4 bajty</td><td>UCS-4</td><td>\U</td></tr>
</table>

<p>Tyto změny by měly být pro programátory i uživatele zcela transparentní,
takže by se nemělo stát, že by například do řetězce původně uloženého
s&nbsp;kódováním Latin-1 (nadmnožina ASCII) nešel uložit například znak
v&nbsp;azbuce &ndash; ostatně řetězce jsou v&nbsp;Pythonu neměnitelné, takže se
konverze provede v&nbsp;rámci prováděné operace automaticky.</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Otestování velikosti objektů typu řetězec v&nbsp;Pythonu 3.4.3</h2>

<p>Podívejme se nyní, jak je výběr formátu pro uložení řetězce prováděn při
interpretaci řetězcového literálu. Nejprve importujeme modul
<strong>sys</strong>, který nabízí funkci <strong>getsizeof()</strong>:</p

<pre>
Python <strong>3.4.3</strong> (default, Nov 17 2016, 01:08:31) 
[GCC 4.8.4] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import sys
</pre>

<p>Zjistíme velikost objektu reprezentujícího prázdný řetězec. Tato velikost se
může lišit podle verze Pythonu a použité architektury, nás však budou zajímat
rozdíly oproti této hodnotě:</p>

<pre>
&gt;&gt;&gt; sys.getsizeof("")
49
</pre>

<p>Zjistíme velikost objektu řetězce s&nbsp;jedním ASCII znakem (měla by být o
jedničku vyšší, než hodnota předchozí) a taktéž velikost objektu řetězce
s&nbsp;jedenácti znaky (bude se lišit o deset bajtů oproti hodnotě předchozí).
Výsledek je zřejmý &ndash; každý znak je v&nbsp;tomto případě reprezentován
jediným bajtem:</p>

<pre>
&gt;&gt;&gt; sys.getsizeof("e")
50
&gt;&gt;&gt; sys.getsizeof("e 123456789")
60
</pre>

<p>Nyní vytvoříme řetězec s&nbsp;ne-ASCII znakem. Velikost příslušného objektu
se zvětší (opět nás však bude zajímat rozdíl oproti této velikosti, ne její
absolutní hodnota):</p>

<pre>
&gt;&gt;&gt; sys.getsizeof("ě")
76
</pre>

<p>Dále vypočteme velikost řetězce s&nbsp;ne-ASCII znakem, po němž následuje
deset ASCII znaků. Vidíme, že každý znak je uložen ve dvou bajtech &ndash;
prvním znakem byl určen interní formát řetězce:</p>

<pre>
&gt;&gt;&gt; sys.getsizeof("ě 123456789")
96
</pre>

<p>Zkusme si nyní vytvořit řetězec s&nbsp;jediným znakem, který nepatří do BPM,
tedy ho nelze reprezentovat v&nbsp;UCS-2. Posléze k&nbsp;tomuto znaku přidáme
dalších deset znaků a snadno zjistíme, že v&nbsp;tomto případě je každý znak
reprezentován čtyřmi bajty ((120-80)/10):</p>

<pre>
&gt;&gt;&gt; sys.getsizeof("\U0001ffff")
80
&gt;&gt;&gt; sys.getsizeof("\U0001ffff 123456789")
120
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Interní reprezentace řetězce v&nbsp;Pythonu 3.4.3</h2>

<p>Jen pro zajímavost se můžeme podívat, jak celý objekt s&nbsp;řetězcem
vypadá. U ASCII řetězců:</p>

<pre>
&gt;&gt;&gt; bytearray((ctypes.c_byte*sys.getsizeof("Hello world!")).from_address(id("Hello world!")))
bytearray(b'\x02\x00\x00\x00\x00\x00\x00\x00\x00\x89\x96\x00
\x00\x00\x00\x00\x0c\x00\x00\x00\x00\x00\x00\x00\x17L\xc6c\x01
\xc0\x08a\xe4\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00Hello world!\x00')
</pre>

<p>U řetězců reprezentovaných v&nbsp;UCS-2:</p>

<pre>
&gt;&gt;&gt; bytearray((ctypes.c_byte*sys.getsizeof("ěščřžýáíéúů")).from_address(id("ěščřžýáíéúů")))
bytearray(b'\x02\x00\x00\x00\x00\x00\x00\x00\x00\x89\x96\x00
\x00\x00\x00\x00\x0b\x00\x00\x00\x00\x00\x00\x00\x98\xd8J\xd9
\xd5\xb7\xd0\x9d\xa8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x1b
\x01a\x01\r\x01Y\x01~\x01\xfd\x00\xe1\x00\xed\x00\xe9\x00\xfa
\x00o\x01\x00\x00')
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na Internetu</h2>

<ol>

<li>The Most Expensive One-byte Mistake: Did Ken, Dennis, and Brian choose wrong with NUL-terminated text strings?<br />
<a href="http://queue.acm.org/detail.cfm?id=2010365">http://queue.acm.org/detail.cfm?id=2010365</a>
</li>

<li>UCSD Pascal<br />
<a href="https://en.wikipedia.org/wiki/UCSD_Pascal">https://en.wikipedia.org/wiki/UCSD_Pascal</a>
</li>

<li>D Language: Strings<br />
<a href="https://dlang.org/spec/arrays.html#strings">https://dlang.org/spec/arrays.html#strings</a>
</li>

<li>The History Behind the Definition of a 'String'<br />
<a href="https://stackoverflow.com/questions/880195/the-history-behind-the-definition-of-a-string">https://stackoverflow.com/questions/880195/the-history-behind-the-definition-of-a-string</a>
</li>

<li>Libc: Representation of Strings<br />
<a href="https://www.gnu.org/software/libc/manual/html_node/Representation-of-Strings.html">https://www.gnu.org/software/libc/manual/html_node/Representation-of-Strings.html</a>
</li>

<li>ATARI BASIC<br />
<a href="http://www.atariarchives.org/dere/chapt10.php">http://www.atariarchives.org/dere/chapt10.php</a>
</li>

<li>BASIC (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/BASIC">http://en.wikipedia.org/wiki/BASIC</a>
</li>

<li>BASIC (Wikipedia CZ)<br />
<a href="http://cs.wikipedia.org/wiki/BASIC">http://cs.wikipedia.org/wiki/BASIC</a>
</li>

<li>Turbo BASIC (Wikipedia CZ)<br />
<a href="http://cs.wikipedia.org/wiki/Turbo_BASIC">http://cs.wikipedia.org/wiki/Turbo_BASIC</a>
</li>

<li>Sinclair BASIC (Wikipedia CZ)<br />
<a href="http://cs.wikipedia.org/wiki/Sinclair_BASIC">http://cs.wikipedia.org/wiki/Sinclair_BASIC</a>
</li>

<li>More BASIC Computer Games<br />
<a href="http://www.atariarchives.org/morebasicgames/">http://www.atariarchives.org/morebasicgames/</a>
</li>

<li>Dartmouth College Computation Center: 1964 &ndash; The original Dartmouth BASIC manual<br />
<a href="http://www.bitsavers.org/pdf/dartmouth/BASIC_Oct64.pdf">http://www.bitsavers.org/pdf/dartmouth/BASIC_Oct64.pdf</a>
</li>

<li>The Original BASIC<br />
<a href="http://www.truebasic.com/">http://www.truebasic.com/</a>
</li>

<li>BASIC - Beginners All-purpose Symbolic Instruction Code<br />
<a href="http://hopl.murdoch.edu.au/showlanguage.prx?exp=176">http://hopl.murdoch.edu.au/showlanguage.prx?exp=176</a>
</li>

<li>Universal Coded Character Set<br />
<a href="https://en.wikipedia.org/wiki/Universal_Coded_Character_Set">https://en.wikipedia.org/wiki/Universal_Coded_Character_Set</a>
</li>

<li>UTF-16<br />
<a href="https://en.wikipedia.org/wiki/UTF-16">https://en.wikipedia.org/wiki/UTF-16</a>
</li>

<li>PEP 393 -- Flexible String Representation<br />
<a href="https://www.python.org/dev/peps/pep-0393/">https://www.python.org/dev/peps/pep-0393/</a>
</li>

<li>In-memory size of a Python structure<br />
<a href="https://stackoverflow.com/questions/1331471/in-memory-size-of-a-python-structure">https://stackoverflow.com/questions/1331471/in-memory-size-of-a-python-structure</a>
</li>

<li>What is internal representation of string in Python 3.x<br />
<a href="https://stackoverflow.com/questions/1838170/what-is-internal-representation-of-string-in-python-3-x#9079985">https://stackoverflow.com/questions/1838170/what-is-internal-representation-of-string-in-python-3-x#9079985</a>
</li>

<li>How to profile memory usage in Python<br />
<a href="https://www.pluralsight.com/blog/tutorials/how-to-profile-memory-usage-in-python">https://www.pluralsight.com/blog/tutorials/how-to-profile-memory-usage-in-python</a>
</li>

<li>What's the rationale for null terminated strings?<br />
<a href="https://stackoverflow.com/questions/4418708/whats-the-rationale-for-null-terminated-strings">https://stackoverflow.com/questions/4418708/whats-the-rationale-for-null-terminated-strings</a>
</li>

<li>Unicode<br />
<a href="https://en.wikipedia.org/wiki/Unicode">https://en.wikipedia.org/wiki/Unicode</a>
</li>

<li>The Development of the C Language<br />
<a href="https://www.bell-labs.com/usr/dmr/www/chist.html">https://www.bell-labs.com/usr/dmr/www/chist.html</a>
</li>

<li>Borland Pascal Wiki: String operations<br />
<a href="http://borlandpascal.wikia.com/wiki/String_operations">http://borlandpascal.wikia.com/wiki/String_operations</a>
</li>

<li>Pascal Strings<br />
<a href="https://www.tutorialspoint.com/pascal/pascal_strings.htm">https://www.tutorialspoint.com/pascal/pascal_strings.htm</a>
</li>

<li>PChar - Null terminated strings<br />
<a href="https://www.freepascal.org/docs-html/ref/refsu12.html">https://www.freepascal.org/docs-html/ref/refsu12.html</a>
</li>

<li>Comparison of Pascal and C<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_Pascal_and_C">https://en.wikipedia.org/wiki/Comparison_of_Pascal_and_C</a>
</li>

<li>FORTRAN 66<br />
<a href="http://fortranwiki.org/fortran/show/FORTRAN+66">http://fortranwiki.org/fortran/show/FORTRAN+66</a>
</li>

<li>Fortran: strings<br />
<a href="https://en.wikibooks.org/wiki/Fortran/strings">https://en.wikibooks.org/wiki/Fortran/strings</a>
</li>

<li>Strings in Atari BASIC<br />
<a href="http://www.cyberroach.com/analog/an11/strings.htm">http://www.cyberroach.com/analog/an11/strings.htm</a>
</li>

<li>String Arrays in Atari BASIC<br />
<a href="http://www.atarimagazines.com/compute/issue11/52_1_STRING_ARRAYS_IN_ATARI_BASIC.php">http://www.atarimagazines.com/compute/issue11/52_1_STRING_ARRAYS_IN_ATARI_BASIC.php</a>
</li>

<li>An Atari BASIC Tutorial<br />
<a href="http://www.cyberroach.com/analog/an25/basictutorial.htm">http://www.cyberroach.com/analog/an25/basictutorial.htm</a>
</li>

<li>Basic Multilingual Plane<br />
<a href="https://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane">https://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

