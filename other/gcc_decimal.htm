<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Kouzlo datových typů Decimal32 a Decimal64</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Kouzlo datových typů Decimal32 a Decimal64</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Kouzlo datových typů Decimal32 a Decimal64</a></p>
<p><a href="#k02">2. Obecná reprezentace hodnot s&nbsp;plovoucí řádovou čárkou</a></p>
<p><a href="#k03">3. Poněkud nepřehledný svět formátů čísel s&nbsp;plovoucí řádovou čárkou</a></p>
<p><a href="#k04">4. Varianta IEEE 754 <strong>single</strong> &ndash; hodnoty s&nbsp;jednoduchou přesností</a></p>
<p><a href="#k05">5. Varianta IEEE 754 <strong>double</strong> &ndash; hodnoty s&nbsp;dvojnásobnou přesností</a></p>
<p><a href="#k06">*** 6. Denormalizovaná čísla, hodnoty typu NaN a nekonečna</a></p>
<p><a href="#k07">*** 7. Omezení typů <strong>single</strong> i <strong>double</strong></a></p>
<p><a href="#k08">*** 8. Klasický problém: konečná či nekonečná smyčka?</a></p>
<p><a href="#k09">*** 9. Tisk numerických hodnot <i>single</i> a <i>double</i> v&nbsp;hexadecimálním formátu</a></p>
<p><a href="#k10">*** 10. Interní struktura hodnot typu <strong>single</strong> a <strong>double</strong></a></p>
<p><a href="#k11">*** 11. Dekódování numerických hodnot uložených ve formátu <i>single</i> a <i>double</i></a></p>
<p><a href="#k12">*** 12. Formáty <strong>Decimal32</strong>, <strong>Decimal64</strong> a <strong>Decimal128</strong></a></p>
<p><a href="#k13">*** 13. Problém hodnoty 0,1 mizí</a></p>
<p><a href="#k14">*** 14. Počítaná smyčka s&nbsp;krokem 0,1 a koncovou hodnotou 1,0 realizovaná s&nbsp;využitím typů Decimal</a></p>
<p><a href="#k15">*** 15. Interní struktura formátu <strong>Decimal32</strong></a></p>
<p><a href="#k16">*** 16. Dekódování hodnoty typu <strong>Decimal32</strong></a></p>
<p><a href="#k17">*** 17. Test přesnosti</a></p>
<p><a href="#k18">*** 18. Rychlost výpočtů: porovnání <strong>Decimal</strong> se <strong>single</strong> a <strong>double</strong></a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Kouzlo datových typů Decimal32 a Decimal64</h2>

<p>Reprezentace numerických hodnot v&nbsp;paměti počítače s&nbsp;využitím
plovoucí řádové čárky se používá již 70 let, protože prvním počítačem
podporujících výpočty s&nbsp;těmito hodnotami na úrovni hardware byl mainframe
IBM 704 pocházející z&nbsp;roku 1954. Od té do doby vzniklo minimálně několik
desítek, ale mnohem pravděpodobněji spíše stovek různých variant uložení čísel.
Většinou však mají společný základ: číselná hodnota je uložena jako trojice
(znaménko, mantisa, exponent), přičemž se liší jak bitové šířky mantisy a
exponentu, tak i základ (báze) pro exponent, forma reprezentace nekonečen a
různých &bdquo;nečísel&ldquo; NaN, to, jak jsou číslice uloženy (binárně, BCD,
...) apod.</p>

<p>Původní norma IEEE 754 z&nbsp;roku 1985, která definovala mj.&nbsp;i formáty
nazvané <i>single (precision)</i> a <i>double (precision)</i>, byla brzy
implementována v&nbsp;hardware (jednalo se například o matematický koprocesor
8087 atd.) a postupně se stala skutečně celosvětově dodržovaným standardem.
Ovšem formáty single a double se nehodí pro bankovní a další finanční aplikace
a z&nbsp;tohoto důvodu se v&nbsp;pozdější variantě normy IEEE 754 objevily i
datové typy <i>Decimal</i> (32bitový, 64bitový a 128bitový). A právě těmito
datovými typy se budeme dnes zabývat, mj.&nbsp;i proto, že byly oficiálně
přijaty i do tak konzervativního programovacího jazyka, jakým je C (a podporuje
je například GCC).</p>

<a href="http://i.iinfo.cz/images/118/ibm07.jpg"><img src="http://i.iinfo.cz/images/118/ibm07-prev.jpg" alt="ibm07" height="270" width="331" /></a>
<p><i>Obrázek 1: Sálový počítač IBM-704, který na úrovni hardware podporoval
výpočty s&nbsp;hodnotami s&nbsp;plovoucí řádovou čárkou (tečkou).</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Obecná reprezentace hodnot s&nbsp;plovoucí řádovou čárkou</h2>

<p>Všechny dále popsané formáty (reprezentace) numerických hodno používají
systém takzvané plovoucí řádové čárky (anglicky <i>floating point</i>, protože
se v&nbsp;angličtině namísto čárky používá tečka). Systém plovoucí řádové čárky
je založen na tom, že vybraná konečná <strong>podmnožina reálných
čísel</strong> může být vyjádřena vztahem:</p>

<p><strong>X<sub>FP</sub> = (-1)<sup>s</sup>&nbsp;&times;&nbsp;b<sup>exp-bias</sup>&nbsp;&times;&nbsp;m</strong></p>

<p>přičemž význam jednotlivých symbolů ve vztahu je následující:</p>

<ul>

<li><strong>X<sub>FP</sub></strong> značí reprezentovanou numerickou hodnotu
z&nbsp;podmnožiny racionálních čísel (ta je zase podmnožinou čísel reálných).
Díky vyhrazeným (speciálním) hodnotám je většinou možné rozlišit kladnou a
zápornou nulu i kladné a záporné nekonečno, což je jeden z&nbsp;důležitých
rozdílů oproti způsobu reprezentace celých čísel. Také se většinou může nějakým
vhodným způsobem uložit nečíselná hodnota: <i>NaN &ndash; (Not a Number)</i>,
která je výsledkem některých matematicky nedefinovaných operací, například 0/0
nebo 0<sup>0</sup>.</li>

<li><strong>b</strong> je <i>báze</i>, někdy také nazývaná <i>radix</i>, u
normy <i>IEEE 754</i> to byla původně dvojka (formáty single, double i
extended), protože výpočty s&nbsp;bází dvě jsou pro číslicové obvody
nejjednodušší. V&nbsp;minulosti se však používaly i jiné báze, například 8, 16
nebo i 10. S&nbsp;bází 16 se dnes již prakticky nesetkáme, o to relevantnější
je však v&nbsp;dnešním článku báze nastavená na desítku.</li>

<li><strong>exp</strong> je vždy kladná hodnota exponentu posunutého o hodnotu
<strong>bias</strong></li>

<li><strong>bias</strong> je hodnota, díky které je uložený exponent vždy
kladný. Tato hodnota se většinou volí dle vztahu:<br />
<i>bias=2<sup>eb-1</sup>-1</i>, kde <i>eb</i> je počet bitů vyhrazených pro
exponent. Pro specifické účely je však možné zvolit i jinou hodnotu.</li>

<li><strong>m</strong> je mantisa, která je u formátů dle normy <i>IEEE 754</i>
vždy kladná (protože znaménko je uloženo zvlášť).</li>

<li><strong>s</strong> je znaménkový bit nabývající hodnoty 0 nebo 1. Pokud je
tento bit nulový, je reprezentovaná hodnota <strong>X<sub>FP</sub></strong>
kladná, v&nbsp;opačném případě se jedná o zápornou hodnotu. Vzhledem
k&nbsp;tomu, že je jeden bit vyhrazen na uložení znaménka, je možné rozlišit
kladnou a zápornou nulu, kladné i záporné nekonečno atd. (některé systémy bit
znaménka používají v&nbsp;negované podobě, to však na principu nic nemění).</li

<a href="https://www.root.cz/obrazek/305587/"><img src="https://i.iinfo.cz/images/346/fp-number-chaos-2-1-prev.jpg" class="image-305587" alt="&#160;" width="370" height="134" /></a>
<p><i>Obrázek 2: První čip, který používal formát definovaný v&nbsp;IEEE 754
&ndash; Intel 8087.<br />
Zdroj: Wikipedia, Autor: Dirk Oppelt</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Poněkud nepřehledný svět formátů čísel s&nbsp;plovoucí řádovou čárkou</h2>

<p>V&nbsp;následující tabulce jsou pro zajímavost vypsány některé nejčastěji
používané či nějakým způsobem (z&nbsp;hlediska historie atd.) zajímavé formáty
hodnot s&nbsp;plovoucí řádovou čárkou. Povšimněte si především toho, že báze je
většinou dvojková, pouze v&nbsp;některých případech desítková či šestnáctková.
Dnes nás budou nejvíce zajímat formáty definované v&nbsp;normě IEEE 754 ve
variantě z&nbsp;roku 2008, tedy formáty s&nbsp;bází 2 a 10:</p>

<table>
<tr><th>Počítač/norma/systém</th><th>Šířka (b)</th><th>Báze</th><th>Exponent (b)</th><th>Mantisa (b)</th></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008-dokonceni/#k11">&bdquo;microfloat&ldquo;</a></td><td>8</td><td>2</td><td>4</td><td>3+1</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008-dokonceni/#k10">IEEE 754 half</a></td><td>16</td><td>2</td><td>5</td><td>10+1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008-dokonceni/#k04">IEEE 754 single</a></td><td>32</td><td>2</td><td>8</td><td>23+1</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008-dokonceni/#k05">IEEE 754 double</a></td><td>64</td><td>2</td><td>11</td><td>52+1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008-dokonceni/#k07">IEEE 754 double extended</a></td><td>80</td><td>2</td><td>15</td><td>64</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008-dokonceni/#k08">IEEE 754 quadruple</a></td><td>128</td><td>2</td><td>15</td><td>112+1</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008-dokonceni/#k09">IEEE 754 octuple</a></td><td>256</td><td>2</td><td>19</td><td>236+1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008-dokonceni/#k18">IEEE 754 decimal32</a></td><td>32</td><td>10</td><td>variabilní</td><td>20 (variabilní)</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008-dokonceni/#k18">IEEE 754 decimal64</a></td><td>64</td><td>10</td><td>variabilní</td><td>50 (variabilní)</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008-dokonceni/#k18">IEEE 754 decimal128</a></td><td>128</td><td>10</td><td>variabilní</td><td>110 (variabilní)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008/#k06">IBM řady 7xx</a></td><td>36</td><td>2</td><td>8</td><td>27</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008/#k10">IBM 360 single</a></td><td>32</td><td>16</td><td>7</td><td>24</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008/#k10">IBM 360 double</a></td><td>64</td><td>16</td><td>7</td><td>56</td></tr>
<tr><td>HP 3000 single</td><td>32</td><td>2</td><td>9</td><td>22</td></tr>
<tr><td>HP 3000 double</td><td>64</td><td>2</td><td>9</td><td>54</td></tr>
<tr><td>CDC 6000, 6600</td><td>60</td><td>2</td><td>11</td><td>48+1</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008/#k11">Cray-1</a></td><td>64</td><td>2</td><td>15</td><td>48</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008/#k09">Strela</a></td><td>43</td><td>2</td><td>7</td><td>35</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008/#k13">Apple II</a></td><td>40</td><td>2</td><td>8</td><td>31+1</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008/#k14">ZX Spectrum</a></td><td>40</td><td>2</td><td>8</td><td>31+1</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008/#k15">Atari (FP rutiny)</a></td><td>48</td><td>10</td><td>7</td><td>40</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008/#k16">Turbo Pascal real</a></td><td>48</td><td>2</td><td>8</td><td>39</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: v&nbsp;případě, že je ve sloupci
<i>Mantisa</i> napsána hodnota <i>n+1</i>, znamená to, že hodnoty jsou
normalizovány takovým způsobem, aby první bit mantisy byl vždy jedničkový.
V&nbsp;takovém případě tento bit nemusíme nikam zapisovat (víme, že je
jednička) a tudíž se mantisa automaticky o tento jeden bit rozšiřuje. To
samozřejmě neplatí pro denormalizované hodnoty, tedy pro hodnoty blízké nule. A
pro typy Decimal32 a Decimal64 je situace ještě složitější :-)</div></p>

<p>Druhá verze normy IEEE 754-2008 již obsahuje specifikaci většího množství
formátů; navíc došlo k&nbsp;přejmenování typů <i>single</i> a <i>double</i> na
<i>binary32</i> a <i>binary64</i> (což nikdo nepoužívá :-):</p>

<table>
<tr><th>Oficiální jméno</th><th>Základní</th><th>Známo též jako</th><th>Znaménko</th><th>Exponent</th><th>Mantisa</th><th>Celkem</th><th>Decimálních číslic</th></tr>
<tr><td>binary16</td><td>&times;</td><td>half precision</td><td>1b</td><td> 5b</td><td>10b</td><td>16b</td><td>cca 3,3</td></tr>
<tr><td>binary32</td><td>&#x2713;</td><td>single precision/float</td><td>1b</td><td> 8b</td><td>23b</td><td>32b</td><td>cca 7,2</td></tr>
<tr><td>binary64</td><td>&#x2713;</td><td>double precision</td><td>1b</td><td>11b</td><td>52b</td><td>64b</td><td>cca 15,9</td></tr>
<tr><td>binary128</td><td>&#x2713;</td><td>quadruple precision</td><td>1b</td><td>15b</td><td>112b</td><td>128b</td><td>cca 34,0</td></tr>
<tr><td>binary256</td><td>&times;</td><td>octuple precision</td><td>1b</td><td>19b</td><td>236b</td><td>256b</td><td>cca 71,3</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Varianta IEEE 754 <strong>single</strong> &ndash; hodnoty s&nbsp;jednoduchou přesností</h2>

<p>V&nbsp;dalším textu budeme porovnávat základní vlastnosti typů
<i>Decimal</i> s&nbsp;původními formáty <i>float/single</i> a <i>double</i>,
takže ještě na chvíli u těchto formátů zůstaneme.</p>

<p>Formát numerických hodnot, který je v&nbsp;programovacích jazycích označován
buď jako <i>single</i> či <i>float</i>, je charakteristický tím, že se pro
uložení numerické hodnoty používá třiceti dvou bitů (4 byty), což pro mnoho
aplikací představuje velmi dobrý poměr mezi rozsahem hodnot, přesností a nároky
na úložný prostor, nehledě na to, že mnoho architektur stále používá 32bitové
sběrnice (klasické ARMy, ...). Oněch 32 bitů je rozděleno do třech částí.
V&nbsp;první části (představované nejvyšším bitem) je uloženo znaménko,
následuje osm bitů pro uložení posunutého exponentu a za nimi je zbývajících 23
bitů, které slouží pro uložení mantisy. Celé třiceti dvoubitové slovo s&nbsp;FP
hodnotou tedy vypadá následovně:</p>

<table>
<tr><th>bit</th><td>31</td><td>30 &nbsp; 29 ... 24 &nbsp; 23</td><td>22 &nbsp; 21 ... 3 &nbsp; 2 &nbsp; 1 &nbsp; 0</td></tr>
<tr><th>význam</th><td>s</td><td>exponent (8 bitů)</td><td>mantisa (23 bitů)</td></tr>
</table>

<p>Exponent je přitom posunutý o hodnotu <strong>bias</strong>, která je
nastavena na 127, protože je použit výše uvedený vztah:</p>

<p><i>bias=2<sup>eb-1</sup>-1</i></p>

<p>a po dosazení <i>eb=8 (bitů)</i> dostaneme:</p>

<p><i>bias=2<sup>8-1</sup>-1=2<sup>7</sup>-1=128-1=</i><strong>127</strong></p>

<p>Vzorec pro vyjádření reálné hodnoty vypadá následovně:</p>

<p><i>X<sub>single</sub>=(-1)<sup>s</sup>&nbsp;&times;&nbsp;2<sup>exp-127</sup>&nbsp;&times;&nbsp;m</i></p>

<p>Uložení znaménka číselné hodnoty je jednoduché: pokud je znaménkový bit
nastavený na jedničku, jedná se o zápornou hodnotu, v&nbsp;opačném případě jde
o hodnotu kladnou. Exponent je uložený v&nbsp;takzvané <strong>posunuté
formě</strong>, tj.&nbsp;jako binárně zakódované celé číslo v&nbsp;rozsahu
0..255. Po vyjádření neposunutého exponentu dostáváme rozsah -127..128, obě
krajní hodnoty jsou však použity pro speciální účely, proto dostáváme rozsah
exponentů pouze -126..127 pro normalizovaná čísla (krajními hodnotami jsou
takové exponenty, které mají všechny bity buď jedničkové nebo naopak
nulové).</p>

<a href="https://www.root.cz/obrazek/305588/"><img src="https://i.iinfo.cz/images/346/fp-number-chaos-2-2-prev.jpg" class="image-305588" alt="&#160;" width="270" height="270" /></a>
<p><i>Obrázek 3: Matematický koprocesor vyráběný firmou Weitek. Tento konkrétní
čip je určen pro procesory řady 486 (není kompatibilní s&nbsp;80487), ovšem
Weitek vyráběl koprocesory pro celou řadu dalších architektur, od 8087 přes
Motoroly řady 68k až po (micro)SPARC.</i></p>

<p>Ještě si však musíme říci, jakým způsobem je uložena mantisa. Ta je totiž
většinou (až na velmi malá čísla) <strong>normalizovaná</strong>, což znamená,
že se do mantisy ukládají pouze hodnoty v&nbsp;rozsahu
&lt;1,0;2,0-&epsilon;&gt;. Vzhledem k&nbsp;tomu, že první bit umístěný před
binární tečkou je u tohoto rozsahu vždy nastavený na jedničku, není ho
zapotřebí ukládat, což znamená, že ušetříme jeden bit z&nbsp;třiceti
dvoubitového slova (viz úvodní kapitolu). Pro normalizované hodnoty platí
následující vztah:</p>

<p><i>X<sub>single</sub>=(-1)<sup>s</sup>&nbsp;&times;&nbsp;2<sup>exp-127</sup>(1.M)<sub>2</sub></i></p>

<p>kde <strong>M</strong> je hodnota bitového vektoru mantisy, tj.:</p>

<p><i>M=m<sub>22</sub><sup>-1</sup>+m<sub>21</sub><sup>-2</sup>+m<sub>20</sub><sup>-3</sup>+...+m<sub>1</sub><sup>-22</sup>+m<sub>0</sub><sup>-23</sup></i></p>

<p>Rozsah hodnot, které je možné reprezentovat ve formátu jednoduché přesnosti
v&nbsp;normalizovaném tvaru je -3,4&times;10<sup>38</sup> až
3,4&times;10<sup>38</sup>. Nejnižší reprezentovatelná (normalizovaná) hodnota
je rovna 1,17549&times;10<sup>-38</sup>, denormalizovaná pak
1,40129&times;10<sup>-45</sup>. Jak jsme k&nbsp;těmto hodnotám došli? Zkuste se
podívat na následující vztahy:</p>

<table>
<tr><th>hexadecimální hodnota</th><th>výpočet FP</th><th>dekadický výsledek</th><th>normalizováno</th></tr>
<tr><td>0x00000001</td><td>2<sup>-126</sup>&times;2<sup>-23</sup></td><td>1,40129&times;10<sup>-45</sup></td><td>ne</td></tr>
<tr><td>0x00800000</td><td>2<sup>-126</sup></td><td>1,17549&times;10<sup>-38</sup></td><td>ano</td></tr>
<tr><td>0x7F7FFFFF</td><td>(2-2<sup>-23</sup>)&times;2<sup>127</sup></td><td>3,4&times;10<sup>38</sup></td><td>ano</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. Varianta IEEE 754 <strong>double</strong> &ndash; hodnoty s&nbsp;dvojnásobnou přesností</h2>

<p>Formát s&nbsp;dvojitou přesností (<strong>double</strong>), který je
definovaný taktéž původní normou IEEE 754, se v&nbsp;mnoha ohledech podobá
formátu s&nbsp;jednoduchou přesností (<strong>single</strong>), pouze se
zdvojnásobil celkový počet bitů, ve kterých je hodnota uložena, tj.&nbsp;místo
32 bitů se používá 64 bitů. Právě to je hlavní příčinou toho, proč se tento
formát nazývá <i>double</i>, ve skutečnosti je totiž přesnost více než
dvojnásobná. 64 bitů alokovaných pro FP hodnotu je v&nbsp;tomto případě
rozděleno následujícím způsobem:</p>

<ol>
<li>1 bit pro znaménko</li>
<li>11 bitů pro exponent</li>
<li>52 bitů pro mantisu</li>
</ol>

<p>Bitově vypadá rozdělení následovně:</p>

<table>
<tr><th>bit</th><td>63</td><td>62 ... 52</td><td>51 ... 0</td></tr>
<tr><th>význam</th><td>s</td><td>exponent (11 bitů)</td><td>mantisa (52 bitů)</td></tr>
</table>

<p>Exponent je v&nbsp;tomto případě posunutý o hodnotu
<strong>bias=2047</strong> a vzorec pro výpočet reálné hodnoty vypadá
takto:</p>

<p><i>X<sub>double</sub>=(-1)<sup>s</sup>&nbsp;&times;&nbsp;2<sup>exp-2047</sup>&nbsp;&times;&nbsp;m</i></p>

<p>Přičemž hodnotu mantisy je možné pro normalizované hodnoty získat pomocí
vztahu:</p>

<p><i>m=1+m<sub>51</sub><sup>-1</sup>+m<sub>50</sub><sup>-2</sup>+m<sub>49</sub><sup>-3</sup>+...+m<sub>0</sub><sup>-52</sup></i></p>

<p>(<i>m<sub>x</sub></i> představuje <i>x</i>-tý bit mantisy)</p>

<p>Rozsah hodnot ukládaných ve dvojité přesnosti je
-1,7&times;10<sup>308</sup>..1,7&times;10<sup>308</sup>, nejmenší možná
nenulová hodnota je rovna 2,2&times;10<sup>-308</sup>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Denormalizovaná čísla, hodnoty typu NaN a nekonečna</h2>

<p>Ještě si musíme vysvětlit význam těch exponentů, které mají minimální a
maximální hodnotu, tj.&nbsp;jsou buď nulové, nebo mají v&nbsp;případě formátu
<i>single</i> hodnotu 255 (obě samozřejmě před posunem). Vše je přehledně
uvedeno v&nbsp;následující tabulce:</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Omezení typů <strong>single</strong> i <strong>double</strong></h2>

<pre>
#include &lt;stdio.h&gt;

int main(void) {
    float x = 0.1;
    float y = 0.2;
    float z = 0.3;

    puts(x + y == z ? "rovnost" : "nerovnost");
    return 0;
}
</pre>

<pre>
#include &lt;stdio.h&gt;

int main(void) {
    double x = 0.1;
    double y = 0.2;
    double z = 0.3;

    puts(x + y == z ? "rovnost" : "nerovnost");
    return 0;
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Klasický problém: konečná či nekonečná smyčka?</h2>

<pre>
#include &lt;stdio.h&gt;

int main(void) {
    float x;

    for (x=0.0; x!=1.0; x+=0.2) {
        printf("%f\n", x);
    }
    return 0;
}
</pre>

<pre>
#include &lt;stdio.h&gt;

int main(void) {
    float x;

    for (x=0.0; x!=1.0; x+=0.1) {
        printf("%f\n", x);
    }
    return 0;
}
</pre>

<pre>
#include &lt;stdio.h&gt;

int main(void) {
    double x;

    for (x=0.0; x!=1.0; x+=0.2) {
        printf("%f\n", x);
    }
    return 0;
}
</pre>

<pre>
#include &lt;stdio.h&gt;

int main(void) {
    double x;

    for (x=0.0; x!=1.0; x+=0.1) {
        printf("%f\n", x);
    }
    return 0;
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Tisk numerických hodnot <i>single</i> a <i>double</i> v&nbsp;hexadecimálním formátu</h2>

<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    float values[] = {0.0, 0.1, 0.2, 1.0, 2.0, 10.0, 100.0, 1000.0, 1000.1, 1.0/0.0, -0.0, -0.1, -0.2, -1.0, -1000.0, -1.0/0.0, 0.0/0.0};
    int i;

    for (i=0; i<sizeof(values)/sizeof(float); i++) {
        printf("%9.4f   %a\n", values[i], values[i]);
    }

    return 0;
}
</pre>

<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    double values[] = {0.0, 0.1, 0.2, 1.0, 2.0, 10.0, 100.0, 1000.0, 1000.1, 1.0/0.0, -0.0, -0.1, -0.2, -1.0, -1000.0, -1.0/0.0, 0.0/0.0};
    int i;

    for (i=0; i<sizeof(values)/sizeof(double); i++) {
        printf("%9.4f   %a\n", values[i], values[i]);
    }

    return 0;
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Interní struktura hodnot typu <strong>single</strong> a <strong>double</strong></h2>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

void print_float_as_hex(float value) {
    union {
        float f;
        uint32_t u;
    } f2u = { .f = value };

    printf("%f -&gt; %08x\n", value, f2u.u);
}

int main(void) {
    float x = 0.1;
    float y = 0.2;
    float z = 0.3;

    print_float_as_hex(x);
    print_float_as_hex(y);
    print_float_as_hex(z);
    return 0;
}
</pre>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

void print_double_as_hex(double value) {
    union {
        double f;
        uint64_t u;
    } f2u = { .f = value };

    printf("%f -&gt; %016lx\n", value, f2u.u);
}

int main(void) {
    double x = 0.1;
    double y = 0.2;
    double z = 0.3;

    print_double_as_hex(x);
    print_double_as_hex(y);
    print_double_as_hex(z);
    return 0;
}
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Dekódování numerických hodnot uložených ve formátu <i>single</i> a <i>double</i></h2>

<pre>
#include &lt;stdio.h&gt;

void decode_float(float value)
{
    const int exponent_bias = 127;
    const int mantissa_base = 1 &lt;&lt; 23;
    const int max_exponent = 255;
    const int mantissa_mask = 0x07fffff;

    const int mantissa_bits = 23;
    const int exponent_bits = 8;

    typedef union {
        float value;
        __uint32_t x;
    } IEEE_754_float;

    IEEE_754_float f;
    f.value = value;
    __uint32_t x = f.x;

    unsigned int sign = 0x01 &amp; (x &gt;&gt; (mantissa_bits + exponent_bits));
    unsigned int exponent = max_exponent &amp; (x &gt;&gt; mantissa_bits);
    unsigned int mantissa = mantissa_mask &amp; x;

    printf("%+10.4f       ", value);

    if (exponent == max_exponent) {
        if (mantissa == 0) {
            printf("%c infinity\n", sign ? '-' : '+');
        } else {
            puts("NaN");
        }
    } else {
        printf("%c %10.8f x 2^%-2d\n", sign ? '-' : '+',
               1.0 + (float) mantissa / mantissa_base, exponent - exponent_bias);
    }
}


int main(void)
{
    float values[] = {0.0, 0.1, 0.2, 1.0, 2.0, 10.0, 100.0, 1000.0, 1000.1, 1.0/0.0, -0.0, -0.1, -0.2, -1.0, -1000.0, -1.0/0.0, 0.0/0.0};
    int i;

    for (i=0; i<sizeof(values)/sizeof(float); i++) {
        decode_float(values[i]);
    }

    return 0;
}
</pre>

<pre>
#include &lt;stdio.h&gt;

void decode_double(double value)
{
    const int exponent_bias = 1023;
    const __uint64_t mantissa_base = 1L &lt;&lt; 52;
    const int max_exponent = 2047;
    const __uint64_t mantissa_mask = 0x0fffffffffffff;

    const int mantissa_bits = 52;
    const int exponent_bits = 11;

    typedef union {
        double value;
        __uint64_t x;
    } IEEE_754_double;

    IEEE_754_double d;
    d.value = value;
    __uint64_t x = d.x;

    unsigned int sign = 0x01 &amp; (x &gt;&gt; (mantissa_bits + exponent_bits));
    unsigned int exponent = max_exponent &amp; (x &gt;&gt; mantissa_bits);
    __uint64_t mantissa = mantissa_mask &amp; x;

    printf("%+10.4f       ", value);

    if (exponent == max_exponent) {
        if (mantissa == 0) {
            printf("%c infinity\n", sign ? '-' : '+');
        } else {
            puts("NaN");
        }
    } else {
        printf("%c %10.8f x 2^%-2d\n", sign ? '-' : '+',
               1.0 + (double) mantissa / mantissa_base, exponent - exponent_bias);
    }
}


int main(void)
{
    double values[] = {0.0, 0.1, 0.2, 1.0, 2.0, 10.0, 100.0, 1000.0, 1000.1, 1.0/0.0, -0.0, -0.1, -0.2, -1.0, -1000.0, -1.0/0.0, 0.0/0.0};
    int i;

    for (i=0; i<sizeof(values)/sizeof(double); i++) {
        decode_double(values[i]);
    }

    return 0;
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Formáty <strong>Decimal32</strong>, <strong>Decimal64</strong> a <strong>Decimal128</strong></h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. Problém hodnoty 0,1 mizí</h2>

<pre>
#include &lt;stdio.h&gt;

int main(void) {
    _Decimal32 x = 0.1df;
    _Decimal32 y = 0.2df;
    _Decimal32 z = 0.3df;

    puts(x + y == z ? "rovnost" : "nerovnost");
    return 0;
}
</pre>

<pre>
#include &lt;stdio.h&gt;

int main(void) {
    _Decimal64 x = 0.1dd;
    _Decimal64 y = 0.2dd;
    _Decimal64 z = 0.3dd;

    puts(x + y == z ? "rovnost" : "nerovnost");
    return 0;
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Počítaná smyčka s&nbsp;krokem 0,1 a koncovou hodnotou 1,0 realizovaná s&nbsp;využitím typů Decimal</h2>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

int main(void) {
    _Decimal32 x;

    for (x=0.0df; x!=1.0df; x+=0.1df) {
        printf("%f\n", (float)x);
    }
    return 0;
}
</pre>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

int main(void) {
    _Decimal64 x;

    for (x=0.0df; x!=1.0df; x+=0.1df) {
        printf("%f\n", (float)x);
    }
    return 0;
}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Interní struktura formátu <strong>Decimal32</strong></h2>

<p></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Dekódování hodnoty typu <strong>Decimal32</strong></h2>

<pre>
#include &lt;stdio.h&gt;

void decode_double(_Decimal32 value)
{
    const int combination_bits = 11;
    const int trailing_bits = 20;

    const int combination_mask = 0x7ff;
    const int trailing_mask = 0x0fffff;

    const int exponent_bias = 101;


    typedef union {
        _Decimal32 value;
        __uint32_t x;
    } IEEE_754_decimal32;

    IEEE_754_decimal32 d;
    d.value = value;
    __uint32_t x = d.x;

    unsigned int sign = 0x01 &amp; (x &gt;&gt; (combination_bits + trailing_bits));
    unsigned int combination = combination_mask &amp; (x &gt;&gt; trailing_bits);
    unsigned int trailing =  trailing_mask &amp; x;
    unsigned int g10 = 0x01 &amp; (combination &gt;&gt; 10);
    unsigned int g9 = 0x01 &amp; (combination &gt;&gt; 9);

    // hodnota po konverzi
    printf("%+10.4f       ", (float)value);

    // ziskana bitova pole
    printf("%d  %d  %d  %03x  %05x      ", sign, g10, g9, combination, trailing);

    // znamenko
    printf("%c  ", sign ? '-' : '+');

    if ((combination &amp; 0x7c0) == 0x780) {
        printf("infinity\n");
    } else if ((combination &amp; 0x7c0) == 0x7c0) {
        printf("NaN\n");
    } else if ((g10 == 1) &amp;&amp; (g9 == 1)) {
        printf("special case\n");
    } else {
        unsigned int exponent = (combination &gt;&gt; 3) - exponent_bias;
        unsigned int mantissa = trailing + ((combination &amp; 0x07) &lt;&lt; 20);
        printf("%d x 10^%d\n", mantissa, exponent);
    }
}


int main(void)
{
    double values[] = {0.0, 0.1, 0.2, 1.0, 2.0, 10.0, 100.0, 1000.0, 1000.1, 1.0/0.0, -0.0, -0.1, -0.2, -1.0, -1000.0, -1.0/0.0, 0.0/0.0};
    int i;

    printf("    value        S G10 G9 comb.trailing   decoded\n");
    for (i=0; i<sizeof(values)/sizeof(double); i++) {
        decode_double(values[i]);
    }

    return 0;
}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Test přesnosti</h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. Rychlost výpočtů: porovnání <strong>Decimal</strong> se <strong>single</strong> a <strong>double</strong></h2>

<pre>
void calc_mandelbrot(unsigned int width, unsigned int height, unsigned int maxiter, unsigned char palette[][3])
{
    const number_type zero = 0.0;
    const number_type two = 2.0;
    const number_type three = 3.0;
    const number_type bailout = 4.0;

    puts("P3");
    printf("%d %d\n", width, height);
    puts("255");

    number_type cy = -1.5;
    int y;
    for (y=0; y<height; y++) {
        number_type cx = -2.0;
        int x;
        for (x=0; x<width; x++) {
            number_type zx = zero;
            number_type zy = zero;
            unsigned int i = 0;
            while (i &lt; maxiter) {
                number_type zx2 = zx * zx;
                number_type zy2 = zy * zy;
                if (zx2 + zy2 &gt; bailout) {
                    break;
                }
                zy = two * zx * zy + cy;
                zx = zx2 - zy2 + cx;
                i++;
            }
            unsigned char *color = palette[i % 256];
            unsigned char r = *color++;
            unsigned char g = *color++;
            unsigned char b = *color;
            printf("%d %d %d\n", r, g, b);
            cx += three/width;
        }
        cy += three/height;
    }
}
</pre>

<pre>
#include <stdlib.h>
#include &lt;stdio.h&gt;

#include "palette_mandmap.h"

typedef _Decimal32 number_type;

#include "mandelbrot.h"

int main(int argc, char **argv)
{
    if (argc &lt; 4) {
        puts("usage: ./mandelbrot width height maxiter");
        return 1;
    }
    int width = atoi(argv[1]);
    int height = atoi(argv[2]);
    int maxiter = atoi(argv[3]);
    calc_mandelbrot(width, height, maxiter, palette);
    return 0;
}
</pre>

<pre>
for i in $(seq 0 100 1000)
do
    echo $i &gt;&gt; results.txt
    /usr/bin/time -f "%U" -o results.txt -a ./mandelbrot_float     1000 1000 $i &gt; /dev/null
    /usr/bin/time -f "%U" -o results.txt -a ./mandelbrot_double    1000 1000 $i &gt; /dev/null
    /usr/bin/time -f "%U" -o results.txt -a ./mandelbrot_decimal32 1000 1000 $i &gt; /dev/null
    /usr/bin/time -f "%U" -o results.txt -a ./mandelbrot_decimal64 1000 1000 $i &gt; /dev/null
done
</pre>

<pre>
from toolz.itertoolz import partition

with open("results.txt") as f:
    lines = f.read().split("\n")

results = partition(5, lines)

for result in results:
    print(",".join(result))
</pre>

<pre>
Iter,float,double,Decimal32,Decimal64
0,0.12,0.11,0.17,0.15
100,0.16,0.17,5.36,4.09
200,0.23,0.23,9.80,7.12
300,0.29,0.29,14.56,10.43
400,0.37,0.37,19.34,14.06
500,0.43,0.50,23.13,16.70
600,0.46,0.48,25.71,19.66
700,0.50,0.54,29.61,21.44
800,0.58,0.58,35.01,25.15
900,0.61,0.64,37.23,28.01
1000,0.66,0.77,41.00,31.03
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady popsané v&nbsp;dnešním článku byly uloženy do
veřejného <a href="https://github.com/tisnik/presentations.git">Git
repositáře</a>, z&nbsp;něhož si je můžete snadno stáhnout a otestovat. Všechny
příklady byly otestovány s&nbsp;GCC verze 9.4.0 (to je už trošku vykopávka) a
13.2.1:</p>

<table>
<tr><th> #</th><th>Soubor</th><th>Stručný popis</th><th>Odkaz</th></tr>
<tr><td> 1</td><td>float_0_1.c</td><td>součet konstant 0,1 a 0,2, porovnání s&nbsp;konstantou 0,3; realizace typem <i>float/single</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/float_0_1.c">https://github.com/tisnik/presentations/blob/master/decimal/float_0_1.c</a></td></tr>
<tr><td> 2</td><td>float_loop_1.c</td><td>programová smyčka s&nbsp;krokem 0,2; realizace typem <i>float/single</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/float_loop_1.c">https://github.com/tisnik/presentations/blob/master/decimal/float_loop_1.c</a></td></tr>
<tr><td> 3</td><td>float_loop_2.c</td><td>programová smyčka s&nbsp;krokem 0,1; realizace typem <i>float/single</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/float_loop_2.c">https://github.com/tisnik/presentations/blob/master/decimal/float_loop_2.c</a></td></tr>
<tr><td> 4</td><td>float_values.c</td><td>převod hodnot typu <i>float/single</i> na 32bitovou hexadecimální hodnotou</td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/float_values.c">https://github.com/tisnik/presentations/blob/master/decimal/float_values.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>double_0_1.c</td><td>součet konstant 0,1 a 0,2, porovnání s&nbsp;konstantou 0,3; realizace typem <i>double</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/double_0_1.c">https://github.com/tisnik/presentations/blob/master/decimal/double_0_1.c</a></td></tr>
<tr><td> 6</td><td>double_loop_1.c</td><td>programová smyčka s&nbsp;krokem 0,2; realizace typem <i>double</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/double_loop_1.c">https://github.com/tisnik/presentations/blob/master/decimal/double_loop_1.c</a></td></tr>
<tr><td> 7</td><td>double_loop_2.c</td><td>programová smyčka s&nbsp;krokem 0,1; realizace typem <i>double</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/double_loop_2.c">https://github.com/tisnik/presentations/blob/master/decimal/double_loop_2.c</a></td></tr>
<tr><td> 8</td><td>double_values.c</td><td>převod hodnot typu <i>float/single</i> na 64bitovou hexadecimální hodnotou</td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/double_values.c">https://github.com/tisnik/presentations/blob/master/decimal/double_values.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>hexa_float.c</td><td>výpis hodnot typu <i>float/single</i> v&nbsp;hexadecimálním formátu</td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/hexa_float.c">https://github.com/tisnik/presentations/blob/master/decimal/hexa_float.c</a></td></tr>
<tr><td>10</td><td>hexa_double.c</td><td>výpis hodnot typu <i>double</i> v&nbsp;hexadecimálním formátu</td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/hexa_double.c">https://github.com/tisnik/presentations/blob/master/decimal/hexa_double.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>decode_float.c </td><td>dekódování numerických hodnot typu <i>float/single</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/decode_float.c">https://github.com/tisnik/presentations/blob/master/decimal/decode_float.c</a></td></tr>
<tr><td>12</td><td>decode_double.c</td><td>dekódování numerických hodnot typu <i>double</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/decode_double.c">https://github.com/tisnik/presentations/blob/master/decimal/decode_double.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>decimal32_0_1.c</td><td>součet konstant 0,1 a 0,2, porovnání s&nbsp;konstantou 0,3; realizace typem <i>Decimal32</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/decimal32_0_1.c">https://github.com/tisnik/presentations/blob/master/decimal/decimal32_0_1.c</a></td></tr>
<tr><td>14</td><td>decimal64_0_1.c</td><td>součet konstant 0,1 a 0,2, porovnání s&nbsp;konstantou 0,3; realizace typem <i>Decimal64</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/decimal64_0_1.c">https://github.com/tisnik/presentations/blob/master/decimal/decimal64_0_1.c</a></td></tr>
<tr><td>15</td><td>decimal32_loop.c</td><td>programová smyčka s&nbsp;krokem 0,1; realizace typem <i>Decimal32</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/decimal32_loop.c">https://github.com/tisnik/presentations/blob/master/decimal/decimal32_loop.c</a></td></tr>
<tr><td>16</td><td>decimal64_loop.c</td><td>programová smyčka s&nbsp;krokem 0,1; realizace typem <i>Decimal64</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/decimal64_loop.c">https://github.com/tisnik/presentations/blob/master/decimal/decimal64_loop.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>17</td><td>decode_decimal32.c</td><td>dekódování numerických hodnot typu <i>Decimal32</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/decode_decimal32.c">https://github.com/tisnik/presentations/blob/master/decimal/decode_decimal32.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>mandelbrot_float.c</td><td>benchmark s&nbsp;výpočtem Mandelbrotovy množiny, varianta pro typ <i>float/single</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/mandelbrot_float.c">https://github.com/tisnik/presentations/blob/master/decimal/mandelbrot_float.c</a></td></tr>
<tr><td>19</td><td>mandelbrot_double.c</td><td>benchmark s&nbsp;výpočtem Mandelbrotovy množiny, varianta pro typ <i>double</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/mandelbrot_double.c">https://github.com/tisnik/presentations/blob/master/decimal/mandelbrot_double.c</a></td></tr>
<tr><td>20</td><td>mandelbrot_decimal32.c</td><td>benchmark s&nbsp;výpočtem Mandelbrotovy množiny, varianta pro typ <i>Decimal32</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/mandelbrot_decimal32.c">https://github.com/tisnik/presentations/blob/master/decimal/mandelbrot_decimal32.c</a></td></tr>
<tr><td>21</td><td>mandelbrot_decimal64.c</td><td>benchmark s&nbsp;výpočtem Mandelbrotovy množiny, varianta pro typ <i>Decimal64</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/mandelbrot_decimal64.c">https://github.com/tisnik/presentations/blob/master/decimal/mandelbrot_decimal64.c</a></td></tr>
<tr><td>22</td><td>mandelbrot.h</td><td>realizace výpočtu Mandelbrotovy množiny nezávislá na použitém datovém typu</td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/mandelbrot.h">https://github.com/tisnik/presentations/blob/master/decimal/mandelbrot.h</a></td></tr>
<tr><td>23</td><td>palette_mandmap.h</td><td>barvová paleta použitá v&nbsp;benchmarku</td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/palette_mandmap.h">https://github.com/tisnik/presentations/blob/master/decimal/palette_mandmap.h</a></td></tr>
<tr><td>24</td><td>bench.sh</td><td>spuštění benchmarků</td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/bench.sh">https://github.com/tisnik/presentations/blob/master/decimal/bench.sh</a></td></tr>
<tr><td>25</td><td>results2csv.py</td><td>převod výsledků benchmarků na formát CSV</td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/results2csv.py">https://github.com/tisnik/presentations/blob/master/decimal/results2csv.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>GCC: 6.14 Decimal Floating Types<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Decimal-Float.html">https://gcc.gnu.org/onlinedocs/gcc/Decimal-Float.html</a>
</li>

<li>Routines for decimal floating point emulation<br />
<a href="https://gcc.gnu.org/onlinedocs/gccint/Decimal-float-library-routines.html">https://gcc.gnu.org/onlinedocs/gccint/Decimal-float-library-routines.html</a>
</li>

<li>Representation of hexadecimal floating point<br />
<a href="https://www.ibm.com/docs/en/hla-and-tf/1.6?topic=lq-representation-hexadecimal-floating-point">https://www.ibm.com/docs/en/hla-and-tf/1.6?topic=lq-representation-hexadecimal-floating-point</a>
</li>

<li>Decimal floating point<br />
<a href="https://en.wikipedia.org/wiki/Decimal_floating_point">https://en.wikipedia.org/wiki/Decimal_floating_point</a>
</li>

<li>Hexadecimal Floating-Point Constants<br />
<a href="https://www.exploringbinary.com/hexadecimal-floating-point-constants/">https://www.exploringbinary.com/hexadecimal-floating-point-constants/</a>
</li>

<li>Norma IEEE 754 a příbuzní: formáty plovoucí řádové tečky<br />
<a href="https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/">https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/</a>
</li>

<li>decimal32 floating-point format<br />
<a href="https://en.wikipedia.org/wiki/Decimal32_floating-point_format">https://en.wikipedia.org/wiki/Decimal32_floating-point_format</a>
</li>

<li>decimal64 floating-point format<br />
<a href="https://en.wikipedia.org/wiki/Decimal64_floating-point_format">https://en.wikipedia.org/wiki/Decimal64_floating-point_format</a>
</li>

<li>decimal128 floating-point format<br />
<a href="https://en.wikipedia.org/wiki/Decimal128_floating-point_format">https://en.wikipedia.org/wiki/Decimal128_floating-point_format</a>
</li>

<li>IEEE-754 Floating-Point Conversion<br />
<a href="http://babbage.cs.qc.cuny.edu/IEEE-754.old/32bit.html">http://babbage.cs.qc.cuny.edu/IEEE-754.old/32bit.html</a>
</li>

<li>Small Float Formats<br />
<a href="https://www.khronos.org/opengl/wiki/Small_Float_Formats">https://www.khronos.org/opengl/wiki/Small_Float_Formats</a>
</li>

<li>Binary-coded decimal<br />
<a href="https://en.wikipedia.org/wiki/Binary-coded_decimal">https://en.wikipedia.org/wiki/Binary-coded_decimal</a>
</li>

<li>Chen–Ho encoding<br />
<a href="https://en.wikipedia.org/wiki/Chen%E2%80%93Ho_encoding">https://en.wikipedia.org/wiki/Chen%E2%80%93Ho_encoding</a>
</li>

<li>Densely packed decimal<br />
<a href="https://en.wikipedia.org/wiki/Densely_packed_decimal">https://en.wikipedia.org/wiki/Densely_packed_decimal</a>
</li>

<li>A Summary of Chen-Ho Decimal Data encoding<br />
<a href="http://speleotrove.com/decimal/chen-ho.html">http://speleotrove.com/decimal/chen-ho.html</a>
</li>

<li>Art of Assembly language programming: The 80x87 Floating Point Coprocessors<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html</a>
</li>

<li>Art of Assembly language programming: The FPU Instruction Set<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html</a>
</li>

<li>INTEL 80387 PROGRAMMER'S REFERENCE MANUAL<br />
<a href="http://www.ragestorm.net/downloads/387intel.txt">http://www.ragestorm.net/downloads/387intel.txt</a>
</li>

<li>Floating-Point Formats<br />
<a href="http://www.quadibloc.com/comp/cp0201.htm">http://www.quadibloc.com/comp/cp0201.htm</a>
</li>

<li>IBM Floating Point Architecture<br />
<a href="http://en.wikipedia.org/wiki/IBM_Floating_Point_Architecture">http://en.wikipedia.org/wiki/IBM_Floating_Point_Architecture</a>
</li>

<li>Extended Binary Coded Decimal Interchange Code<br />
<a href="http://en.wikipedia.org/wiki/EBCDIC">http://en.wikipedia.org/wiki/EBCDIC</a>
</li>

<li>ASCII/EBCDIC Conversion Table<br />
<a href="http://docs.hp.com/en/32212-90008/apcs01.html">http://docs.hp.com/en/32212-90008/apcs01.html</a>
</li>

<li>EBCDIC<br />
<a href="http://www.hansenb.pdx.edu/DMKB/dict/tutorials/ebcdic.php">http://www.hansenb.pdx.edu/DMKB/dict/tutorials/ebcdic.php</a>
</li>

<li>EBCDIC tables<br />
<a href="http://home.mnet-online.de/wzwz.de/temp/ebcdic/cc_en.htm">http://home.mnet-online.de/wzwz.de/temp/ebcdic/cc_en.htm</a>
</li>

<li>36-bit<br />
<a href="http://en.wikipedia.org/wiki/36-bit_word_length">http://en.wikipedia.org/wiki/36-bit_word_length</a>
</li>

<li>36bit.org<br />
<a href="http://www.36bit.org/">http://www.36bit.org/</a>
</li>

<li>How did the Apple II do floating point?<br />
<a href="https://groups.google.com/forum/#!topic/comp.emulators.apple2/qSBiG2TAlRg">https://groups.google.com/forum/#!topic/comp.emulators.apple2/qSBiG2TAlRg</a>
</li>

<li>IBM Floating Point Architecture<br />
<a href="https://en.wikipedia.org/wiki/IBM_Floating_Point_Architecture">https://en.wikipedia.org/wiki/IBM_Floating_Point_Architecture</a>
</li>

<li>The Arithmetic Subroutines<br />
<a href="http://www.users.waitrose.com/~thunor/mmcoyzx81/chapter17.html">http://www.users.waitrose.com/~thunor/mmcoyzx81/chapter17.html</a>
</li>

<li>ZX Floating point to Decimal code in BASIC<br />
<a href="http://www.sinclairzxworld.com/viewtopic.php?t=1422">http://www.sinclairzxworld.com/viewtopic.php?t=1422</a>
</li>

<li>Floating Point Arithmetic Package<br />
<a href="http://www.retrocomputing.net/parts/atari/800/docs/atari_os/atari_os_user_manual_08.htm">http://www.retrocomputing.net/parts/atari/800/docs/atari_os/atari_os_user_manual_08.htm</a>
</li>

<li>Turbo Pascal Real<br />
<a href="http://www.shikadi.net/moddingwiki/Turbo_Pascal_Real">http://www.shikadi.net/moddingwiki/Turbo_Pascal_Real</a>
</li>

<li>THE FLOATING POINT ARITHMETIC PACKAGE<br />
<a href="http://www.atarimax.com/freenet/freenet_material/5.8-BitComputersSupportArea/7.TechnicalResourceCenter/showarticle.php?14">http://www.atarimax.com/freenet/freenet_material/5.8-BitComputersSupportArea/7.TechnicalResourceCenter/showarticle.php?14</a>
</li>

<li>The Most Expensive One-byte Mistake: Did Ken, Dennis, and Brian choose wrong with NUL-terminated text strings?<br />
<a href="http://queue.acm.org/detail.cfm?id=2010365">http://queue.acm.org/detail.cfm?id=2010365</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

