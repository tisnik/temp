<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Kouzlo datových typů Decimal32, Decimal64 a Decimal128</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Kouzlo datových typů Decimal32, Decimal64 a Decimal128</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V normě IEEE 754-2008 nalezneme kromě klasických numerických formátů i popis typů (formátů) s desítkovým základem exponentu. Jedná se o typy Decimal32, Decimal64 a Decimal128. Tyto typy jsou taktéž podporovány některými překladači jazyka C, takže si můžeme i prakticky otestovat jejich základní vlastnosti, přednosti a zápory.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Kouzlo datových typů Decimal32, Decimal64 a Decimal128</a></p>
<p><a href="#k02">2. Obecná reprezentace hodnot s&nbsp;plovoucí řádovou čárkou</a></p>
<p><a href="#k03">3. Poněkud nepřehledný svět formátů čísel s&nbsp;plovoucí řádovou čárkou</a></p>
<p><a href="#k04">4. Varianta IEEE 754 <strong>single</strong> &ndash; hodnoty s&nbsp;jednoduchou přesností</a></p>
<p><a href="#k05">5. Varianta IEEE 754 <strong>double</strong> &ndash; hodnoty s&nbsp;dvojnásobnou přesností</a></p>
<p><a href="#k06">6. Denormalizovaná čísla, hodnoty typu NaN a nekonečna</a></p>
<p><a href="#k07">7. Omezení typů <strong>single</strong> i <strong>double</strong></a></p>
<p><a href="#k08">8. Klasický problém: konečná či nekonečná smyčka?</a></p>
<p><a href="#k09">9. Tisk numerických hodnot <i>single</i> a <i>double</i> v&nbsp;hexadecimálním formátu</a></p>
<p><a href="#k10">10. Interní struktura hodnot typu <strong>single</strong> a <strong>double</strong></a></p>
<p><a href="#k11">11. Dekódování numerických hodnot uložených ve formátu <i>single</i> a <i>double</i></a></p>
<p><a href="#k12">12. Formáty <strong>Decimal32</strong>, <strong>Decimal64</strong> a <strong>Decimal128</strong></a></p>
<p><a href="#k13">13. Problém hodnoty 0,1 mizí</a></p>
<p><a href="#k14">14. Počítaná smyčka s&nbsp;krokem 0,1 a koncovou hodnotou 1,0 realizovaná s&nbsp;využitím typů Decimal</a></p>
<p><a href="#k15">15. Interní struktura formátu <strong>Decimal32</strong></a></p>
<p><a href="#k16">16. Dekódování hodnoty typu <strong>Decimal32</strong></a></p>
<p><a href="#k17">17. Rychlost výpočtů: porovnání <strong>Decimal</strong> se <strong>single</strong> a <strong>double</strong></a></p>
<p><a href="#k18">18. Výsledky benchmarků</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Kouzlo datových typů Decimal32, Decimal64 a Decimal128</h2>

<p>Reprezentace numerických hodnot v&nbsp;paměti počítače s&nbsp;využitím
plovoucí řádové čárky se používá již 70 let, protože prvním počítačem
podporujících výpočty s&nbsp;těmito hodnotami na úrovni hardware byl mainframe
IBM 704 pocházející z&nbsp;roku 1954. Od té do doby vzniklo minimálně několik
desítek, ale mnohem pravděpodobněji spíše stovek různých variant uložení čísel.
Většinou však mají společný základ: číselná hodnota je uložena jako trojice
(znaménko, mantisa, exponent), přičemž se liší jak bitové šířky mantisy a
exponentu, tak i základ (báze) pro exponent, forma reprezentace nekonečen a
různých &bdquo;nečísel&ldquo; NaN, to, jak jsou číslice uloženy (binárně, BCD,
...) apod.</p>

<p>Původní norma IEEE 754 z&nbsp;roku 1985, která definovala mj.&nbsp;i formáty
nazvané <i>single (precision)</i> a <i>double (precision)</i>, byla brzy
implementována v&nbsp;hardware (jednalo se například o matematický koprocesor
8087 atd.) a postupně se stala skutečně celosvětově dodržovaným standardem.
Ovšem formáty single a double se nehodí pro bankovní a další finanční aplikace
a z&nbsp;tohoto důvodu se v&nbsp;pozdější variantě normy IEEE 754 objevily i
datové typy <i>Decimal</i> (32bitový, 64bitový a 128bitový). A právě těmito
datovými typy se budeme dnes zabývat, mj.&nbsp;i proto, že byly oficiálně
přijaty i do tak konzervativního programovacího jazyka, jakým je C (a podporuje
je například GCC).</p>

<a href="http://i.iinfo.cz/images/118/ibm07.jpg"><img src="http://i.iinfo.cz/images/118/ibm07-prev.jpg" alt="ibm07" height="270" width="331" /></a>
<p><i>Obrázek 1: Sálový počítač IBM-704, který na úrovni hardware podporoval
výpočty s&nbsp;hodnotami s&nbsp;plovoucí řádovou čárkou (tečkou).</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Obecná reprezentace hodnot s&nbsp;plovoucí řádovou čárkou</h2>

<p>Všechny dále popsané formáty (reprezentace) numerických hodno používají
systém takzvané plovoucí řádové čárky (anglicky <i>floating point</i>, protože
se v&nbsp;angličtině namísto čárky používá tečka). Systém plovoucí řádové čárky
je založen na tom, že vybraná konečná <strong>podmnožina reálných
čísel</strong> může být vyjádřena vztahem:</p>

<p><strong>X<sub>FP</sub> = (-1)<sup>s</sup>&nbsp;&times;&nbsp;b<sup>exp-bias</sup>&nbsp;&times;&nbsp;m</strong></p>

<p>přičemž význam jednotlivých symbolů ve vztahu je následující:</p>

<ul>

<li><strong>X<sub>FP</sub></strong> značí reprezentovanou numerickou hodnotu
z&nbsp;podmnožiny racionálních čísel (ta je zase podmnožinou čísel reálných).
Díky vyhrazeným (speciálním) hodnotám je většinou možné rozlišit kladnou a
zápornou nulu i kladné a záporné nekonečno, což je jeden z&nbsp;důležitých
rozdílů oproti způsobu reprezentace celých čísel. Také se většinou může nějakým
vhodným způsobem uložit nečíselná hodnota: <i>NaN &ndash; (Not a Number)</i>,
která je výsledkem některých matematicky nedefinovaných operací, například 0/0
nebo 0<sup>0</sup>.</li>

<li><strong>b</strong> je <i>báze</i>, někdy také nazývaná <i>radix</i>, u
normy <i>IEEE 754</i> to byla původně dvojka (formáty single, double i
extended), protože výpočty s&nbsp;bází dvě jsou pro číslicové obvody
nejjednodušší. V&nbsp;minulosti se však používaly i jiné báze, například 8, 16
nebo i 10. S&nbsp;bází 16 se dnes již prakticky nesetkáme, o to relevantnější
je však v&nbsp;dnešním článku báze nastavená na desítku.</li>

<li><strong>exp</strong> je vždy kladná hodnota exponentu posunutého o hodnotu
<strong>bias</strong></li>

<li><strong>bias</strong> je hodnota, díky které je uložený exponent vždy
kladný. Tato hodnota se většinou volí dle vztahu:<br />
<i>bias=2<sup>eb-1</sup>-1</i>, kde <i>eb</i> je počet bitů vyhrazených pro
exponent. Pro specifické účely je však možné zvolit i jinou hodnotu.</li>

<li><strong>m</strong> je mantisa, která je u formátů dle normy <i>IEEE 754</i>
vždy kladná (protože znaménko je uloženo zvlášť).</li>

<li><strong>s</strong> je znaménkový bit nabývající hodnoty 0 nebo 1. Pokud je
tento bit nulový, je reprezentovaná hodnota <strong>X<sub>FP</sub></strong>
kladná, v&nbsp;opačném případě se jedná o zápornou hodnotu. Vzhledem
k&nbsp;tomu, že je jeden bit vyhrazen na uložení znaménka, je možné rozlišit
kladnou a zápornou nulu, kladné i záporné nekonečno atd. (některé systémy bit
znaménka používají v&nbsp;negované podobě, to však na principu nic nemění).</li>

</ul>

<a href="https://www.root.cz/obrazek/305587/"><img src="https://i.iinfo.cz/images/346/fp-number-chaos-2-1-prev.jpg" class="image-305587" alt="&#160;" width="370" height="134" /></a>
<p><i>Obrázek 2: První čip, který používal formát definovaný v&nbsp;IEEE 754
&ndash; Intel 8087.<br />
Zdroj: Wikipedia, Autor: Dirk Oppelt</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Poněkud nepřehledný svět formátů čísel s&nbsp;plovoucí řádovou čárkou</h2>

<p>V&nbsp;následující tabulce jsou pro zajímavost vypsány některé nejčastěji
používané či nějakým způsobem (z&nbsp;hlediska historie atd.) zajímavé formáty
hodnot s&nbsp;plovoucí řádovou čárkou. Povšimněte si především toho, že báze je
většinou dvojková, pouze v&nbsp;některých případech desítková či šestnáctková.
Dnes nás budou nejvíce zajímat formáty definované v&nbsp;normě IEEE 754 ve
variantě z&nbsp;roku 2008, tedy formáty s&nbsp;bází 2 a 10:</p>

<table>
<tr><th>Počítač/norma/systém</th><th>Šířka (b)</th><th>Báze</th><th>Exponent (b)</th><th>Mantisa (b)</th></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008-dokonceni/#k11">&bdquo;microfloat&ldquo;</a></td><td>8</td><td>2</td><td>4</td><td>3+1</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008-dokonceni/#k10">IEEE 754 half</a></td><td>16</td><td>2</td><td>5</td><td>10+1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008-dokonceni/#k04">IEEE 754 single</a></td><td>32</td><td>2</td><td>8</td><td>23+1</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008-dokonceni/#k05">IEEE 754 double</a></td><td>64</td><td>2</td><td>11</td><td>52+1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008-dokonceni/#k07">IEEE 754 double extended</a></td><td>80</td><td>2</td><td>15</td><td>64</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008-dokonceni/#k08">IEEE 754 quadruple</a></td><td>128</td><td>2</td><td>15</td><td>112+1</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008-dokonceni/#k09">IEEE 754 octuple</a></td><td>256</td><td>2</td><td>19</td><td>236+1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008-dokonceni/#k18">IEEE 754 decimal32</a></td><td>32</td><td>10</td><td>variabilní</td><td>20 (variabilní)</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008-dokonceni/#k18">IEEE 754 decimal64</a></td><td>64</td><td>10</td><td>variabilní</td><td>50 (variabilní)</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008-dokonceni/#k18">IEEE 754 decimal128</a></td><td>128</td><td>10</td><td>variabilní</td><td>110 (variabilní)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008/#k06">IBM řady 7xx</a></td><td>36</td><td>2</td><td>8</td><td>27</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008/#k10">IBM 360 single</a></td><td>32</td><td>16</td><td>7</td><td>24</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008/#k10">IBM 360 double</a></td><td>64</td><td>16</td><td>7</td><td>56</td></tr>
<tr><td>HP 3000 single</td><td>32</td><td>2</td><td>9</td><td>22</td></tr>
<tr><td>HP 3000 double</td><td>64</td><td>2</td><td>9</td><td>54</td></tr>
<tr><td>CDC 6000, 6600</td><td>60</td><td>2</td><td>11</td><td>48+1</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008/#k11">Cray-1</a></td><td>64</td><td>2</td><td>15</td><td>48</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008/#k09">Strela</a></td><td>43</td><td>2</td><td>7</td><td>35</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008/#k13">Apple II</a></td><td>40</td><td>2</td><td>8</td><td>31+1</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008/#k14">ZX Spectrum</a></td><td>40</td><td>2</td><td>8</td><td>31+1</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008/#k15">Atari (FP rutiny)</a></td><td>48</td><td>10</td><td>7</td><td>40</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008/#k16">Turbo Pascal real</a></td><td>48</td><td>2</td><td>8</td><td>39</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: v&nbsp;případě, že je ve sloupci
<i>Mantisa</i> napsána hodnota <i>n+1</i>, znamená to, že hodnoty jsou
normalizovány takovým způsobem, aby první bit mantisy byl vždy jedničkový.
V&nbsp;takovém případě tento bit nemusíme nikam zapisovat (víme, že je
jednička) a tudíž se mantisa automaticky o tento jeden bit rozšiřuje. To
samozřejmě neplatí pro denormalizované hodnoty, tedy pro hodnoty blízké nule. A
pro typy Decimal32 a Decimal64 je situace ještě složitější :-)</div></p>

<p>Druhá verze normy IEEE 754-2008 již obsahuje specifikaci většího množství
formátů; navíc došlo k&nbsp;přejmenování typů <i>single</i> a <i>double</i> na
<i>binary32</i> a <i>binary64</i> (což nikdo nepoužívá :-):</p>

<table>
<tr><th>Oficiální jméno</th><th>Základní</th><th>Známo též jako</th><th>Znaménko</th><th>Exponent</th><th>Mantisa</th><th>Celkem</th><th>Decimálních číslic</th></tr>
<tr><td>binary16</td><td>&times;</td><td>half precision</td><td>1b</td><td> 5b</td><td>10b</td><td>16b</td><td>cca 3,3</td></tr>
<tr><td>binary32</td><td>&#x2713;</td><td>single precision/float</td><td>1b</td><td> 8b</td><td>23b</td><td>32b</td><td>cca 7,2</td></tr>
<tr><td>binary64</td><td>&#x2713;</td><td>double precision</td><td>1b</td><td>11b</td><td>52b</td><td>64b</td><td>cca 15,9</td></tr>
<tr><td>binary128</td><td>&#x2713;</td><td>quadruple precision</td><td>1b</td><td>15b</td><td>112b</td><td>128b</td><td>cca 34,0</td></tr>
<tr><td>binary256</td><td>&times;</td><td>octuple precision</td><td>1b</td><td>19b</td><td>236b</td><td>256b</td><td>cca 71,3</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Varianta IEEE 754 <strong>single</strong> &ndash; hodnoty s&nbsp;jednoduchou přesností</h2>

<p>V&nbsp;dalším textu budeme porovnávat základní vlastnosti typů
<i>Decimal</i> s&nbsp;původními formáty <i>float/single</i> a <i>double</i>,
takže ještě na chvíli u těchto formátů zůstaneme.</p>

<p>Formát numerických hodnot, který je v&nbsp;programovacích jazycích označován
buď jako <i>single</i> či <i>float</i>, je charakteristický tím, že se pro
uložení numerické hodnoty používá třiceti dvou bitů (4 byty), což pro mnoho
aplikací představuje velmi dobrý poměr mezi rozsahem hodnot, přesností a nároky
na úložný prostor, nehledě na to, že mnoho architektur stále používá 32bitové
sběrnice (klasické ARMy, ...). Oněch 32 bitů je rozděleno do třech částí.
V&nbsp;první části (představované nejvyšším bitem) je uloženo znaménko,
následuje osm bitů pro uložení posunutého exponentu a za nimi je zbývajících 23
bitů, které slouží pro uložení mantisy. Celé třiceti dvoubitové slovo s&nbsp;FP
hodnotou tedy vypadá následovně:</p>

<table>
<tr><th>bit</th><td>31</td><td>30 &nbsp; 29 ... 24 &nbsp; 23</td><td>22 &nbsp; 21 ... 3 &nbsp; 2 &nbsp; 1 &nbsp; 0</td></tr>
<tr><th>význam</th><td>s</td><td>exponent (8 bitů)</td><td>mantisa (23 bitů)</td></tr>
</table>

<p>Exponent je přitom posunutý o hodnotu <strong>bias</strong>, která je
nastavena na 127, protože je použit výše uvedený vztah:</p>

<p><i>bias=2<sup>eb-1</sup>-1</i></p>

<p>a po dosazení <i>eb=8 (bitů)</i> dostaneme:</p>

<p><i>bias=2<sup>8-1</sup>-1=2<sup>7</sup>-1=128-1=</i><strong>127</strong></p>

<p>Vzorec pro vyjádření reálné hodnoty vypadá následovně:</p>

<p><i>X<sub>single</sub>=(-1)<sup>s</sup>&nbsp;&times;&nbsp;2<sup>exp-127</sup>&nbsp;&times;&nbsp;m</i></p>

<p>Uložení znaménka číselné hodnoty je jednoduché: pokud je znaménkový bit
nastavený na jedničku, jedná se o zápornou hodnotu, v&nbsp;opačném případě jde
o hodnotu kladnou. Exponent je uložený v&nbsp;takzvané <strong>posunuté
formě</strong>, tj.&nbsp;jako binárně zakódované celé číslo v&nbsp;rozsahu
0..255. Po vyjádření neposunutého exponentu dostáváme rozsah -127..128, obě
krajní hodnoty jsou však použity pro speciální účely, proto dostáváme rozsah
exponentů pouze -126..127 pro normalizovaná čísla (krajními hodnotami jsou
takové exponenty, které mají všechny bity buď jedničkové nebo naopak
nulové).</p>

<a href="https://www.root.cz/obrazek/305588/"><img src="https://i.iinfo.cz/images/346/fp-number-chaos-2-2-prev.jpg" class="image-305588" alt="&#160;" width="270" height="270" /></a>
<p><i>Obrázek 3: Matematický koprocesor vyráběný firmou Weitek. Tento konkrétní
čip je určen pro procesory řady 486 (není kompatibilní s&nbsp;80487), ovšem
Weitek vyráběl koprocesory pro celou řadu dalších architektur, od 8087 přes
Motoroly řady 68k až po (micro)SPARC.</i></p>

<p>Ještě si však musíme říci, jakým způsobem je uložena mantisa. Ta je totiž
většinou (až na velmi malá čísla) <strong>normalizovaná</strong>, což znamená,
že se do mantisy ukládají pouze hodnoty v&nbsp;rozsahu
&lt;1,0;2,0-&epsilon;&gt;. Vzhledem k&nbsp;tomu, že první bit umístěný před
binární tečkou je u tohoto rozsahu vždy nastavený na jedničku, není ho
zapotřebí ukládat, což znamená, že ušetříme jeden bit z&nbsp;třiceti
dvoubitového slova (viz úvodní kapitolu). Pro normalizované hodnoty platí
následující vztah:</p>

<p><i>X<sub>single</sub>=(-1)<sup>s</sup>&nbsp;&times;&nbsp;2<sup>exp-127</sup>(1.M)<sub>2</sub></i></p>

<p>kde <strong>M</strong> je hodnota bitového vektoru mantisy, tj.:</p>

<p><i>M=m<sub>22</sub><sup>-1</sup>+m<sub>21</sub><sup>-2</sup>+m<sub>20</sub><sup>-3</sup>+...+m<sub>1</sub><sup>-22</sup>+m<sub>0</sub><sup>-23</sup></i></p>

<p>Rozsah hodnot, které je možné reprezentovat ve formátu jednoduché přesnosti
v&nbsp;normalizovaném tvaru je -3,4&times;10<sup>38</sup> až
3,4&times;10<sup>38</sup>. Nejnižší reprezentovatelná (normalizovaná) hodnota
je rovna 1,17549&times;10<sup>-38</sup>, denormalizovaná pak
1,40129&times;10<sup>-45</sup>. Jak jsme k&nbsp;těmto hodnotám došli? Zkuste se
podívat na následující vztahy:</p>

<table>
<tr><th>hexadecimální hodnota</th><th>výpočet FP</th><th>dekadický výsledek</th><th>normalizováno</th></tr>
<tr><td>0x00000001</td><td>2<sup>-126</sup>&times;2<sup>-23</sup></td><td>1,40129&times;10<sup>-45</sup></td><td>ne</td></tr>
<tr><td>0x00800000</td><td>2<sup>-126</sup></td><td>1,17549&times;10<sup>-38</sup></td><td>ano</td></tr>
<tr><td>0x7F7FFFFF</td><td>(2-2<sup>-23</sup>)&times;2<sup>127</sup></td><td>3,4&times;10<sup>38</sup></td><td>ano</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. Varianta IEEE 754 <strong>double</strong> &ndash; hodnoty s&nbsp;dvojnásobnou přesností</h2>

<p>Formát s&nbsp;dvojitou přesností (<strong>double</strong>), který je
definovaný taktéž původní normou IEEE 754, se v&nbsp;mnoha ohledech podobá
formátu s&nbsp;jednoduchou přesností (<strong>single</strong>), pouze se
zdvojnásobil celkový počet bitů, ve kterých je hodnota uložena, tj.&nbsp;místo
32 bitů se používá 64 bitů. Právě to je hlavní příčinou toho, proč se tento
formát nazývá <i>double</i>, ve skutečnosti je totiž přesnost více než
dvojnásobná. 64 bitů alokovaných pro FP hodnotu je v&nbsp;tomto případě
rozděleno následujícím způsobem:</p>

<ol>
<li>1 bit pro znaménko</li>
<li>11 bitů pro exponent</li>
<li>52 bitů pro mantisu</li>
</ol>

<p>Bitově vypadá rozdělení následovně:</p>

<table>
<tr><th>bit</th><td>63</td><td>62 ... 52</td><td>51 ... 0</td></tr>
<tr><th>význam</th><td>s</td><td>exponent (11 bitů)</td><td>mantisa (52 bitů)</td></tr>
</table>

<p>Exponent je v&nbsp;tomto případě posunutý o hodnotu
<strong>bias=2047</strong> a vzorec pro výpočet reálné hodnoty vypadá
takto:</p>

<p><i>X<sub>double</sub>=(-1)<sup>s</sup>&nbsp;&times;&nbsp;2<sup>exp-2047</sup>&nbsp;&times;&nbsp;m</i></p>

<p>Přičemž hodnotu mantisy je možné pro normalizované hodnoty získat pomocí
vztahu:</p>

<p><i>m=1+m<sub>51</sub><sup>-1</sup>+m<sub>50</sub><sup>-2</sup>+m<sub>49</sub><sup>-3</sup>+...+m<sub>0</sub><sup>-52</sup></i></p>

<p>(<i>m<sub>x</sub></i> představuje <i>x</i>-tý bit mantisy)</p>

<p>Rozsah hodnot ukládaných ve dvojité přesnosti je
-1,7&times;10<sup>308</sup>..1,7&times;10<sup>308</sup>, nejmenší možná
nenulová hodnota je rovna 2,2&times;10<sup>-308</sup>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Denormalizovaná čísla, hodnoty typu NaN a nekonečna</h2>

<p>Ještě si musíme vysvětlit význam těch exponentů, které mají minimální a
maximální hodnotu, tj.&nbsp;jsou buď nulové, nebo mají v&nbsp;případě formátu
<i>single</i> hodnotu 255 (obě samozřejmě před posunem). Vše je přehledně
uvedeno v&nbsp;následující tabulce:</p>

<table>
<tr><th>s-bit</th><th>exponent</th><th>mantisa</th><th>význam</th><th>šestnáctkově</th></tr>
<tr><td>0</td><td>0&lt;e&lt;255</td><td>&gt;0</td><td>normalizované kladné číslo</td><td>&nbsp;</td></tr>
<tr><td>1</td><td>0&lt;e&lt;255</td><td>&gt;0</td><td>normalizované záporné číslo</td><td>&nbsp;</td></tr>
<tr><td>0</td><td>0</td><td>&gt;0</td><td>denormalizované kladné číslo</td><td>&nbsp;</td></tr>
<tr><td>1</td><td>0</td><td>&gt;0</td><td>denormalizované záporné číslo</td><td>&nbsp;</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>kladná nula</td><td>0x00000000</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>záporná nula</td><td>0x80000000</td></tr>
<tr><td>0</td><td>255</td><td>0</td><td>kladné nekonečno</td><td>0x7F800000</td></tr>
<tr><td>1</td><td>255</td><td>0</td><td>záporné nekonečno</td><td>0xFF800000</td></tr>
<tr><td>0</td><td>255</td><td>&gt;0</td><td>NaN &ndash; not a number</td><td>&nbsp;</td></tr>
<tr><td>1</td><td>255</td><td>&gt;0</td><td>NaN &ndash; not a number</td><td>&nbsp;</td></tr>
</table>

<p>Pojmem <strong>denormalizovaná čísla</strong> označujeme takové hodnoty, u
kterých není první (explicitně nevyjádřený) bit mantisy roven jedničce, ale
naopak nule. Výpočty s&nbsp;těmito velmi malými hodnotami nejsou přesné,
zejména při násobení a dělení (a samozřejmě i všech odvozených operacích). Při
ukládání denormalizovaných čísel je exponent vždy nastaven na nejnižší hodnotu,
tj.&nbsp;na -126 a nejvyšší (explicitně neukládaný) bit mantisy je vždy nulový,
nikoli jedničkový, jak je tomu u normalizovaných hodnot.</p>

<p>Hodnota typu <strong>NaN</strong> vznikne v&nbsp;případě, že je použita
operace s&nbsp;nejasným výsledkem, například 0/0 nebo, a to v&nbsp;praxi snad
nejčastěji, při odmocňování záporných čísel. Nekonečná hodnota vzniká typicky
při dělení nulou (zde je možné zjistit znaménko), nebo při vyjádření funkcí
typu <i>log(0)</i> atd.</p>

<p>Minimální a maximální hodnota exponentu má speciální význam i u formátu
double:</p>

<table>
<tr><th>s-bit</th><th>exponent</th><th>mantisa</th><th>význam</th></tr>
<tr><td>0</td><td>0&lt;e&lt;2047</td><td>&gt;0</td><td>normalizované kladné číslo</td></tr>
<tr><td>1</td><td>0&lt;e&lt;2047</td><td>&gt;0</td><td>normalizované záporné číslo</td></tr>
<tr><td>0</td><td>0</td><td>&gt;0</td><td>denormalizované kladné číslo</td></tr>
<tr><td>1</td><td>0</td><td>&gt;0</td><td>denormalizované záporné číslo</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>kladná nula</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>záporná nula</td></tr>
<tr><td>0</td><td>2047</td><td>0</td><td>kladné nekonečno</td></tr>
<tr><td>1</td><td>2047</td><td>0</td><td>záporné nekonečno</td></tr>
<tr><td>0</td><td>2047</td><td>&gt;0</td><td>NaN &ndash; not a number</td></tr>
<tr><td>1</td><td>2047</td><td>&gt;0</td><td>NaN &ndash; not a number</td></tr>
</table>

<p>Kromě obou základních formátů (tj.&nbsp;jednoduché i dvojité přesnosti) je
v&nbsp;normě IEEE 754 povoleno používat i rozšířené formáty. Na platformě x86
je při výpočtech prováděných v&nbsp;matematickém koprocesoru používán rozšířený
formát nazývaný <strong>extended</strong> či <strong>temporary</strong>. Tento
formát je zajímavý tím, že pro uložení FP hodnot používá 80 bitů a je do něho
možné beze ztráty přesnosti uložit 64bitové hodnoty typu integer (což je
v&nbsp;mnoha oblastech velmi důležité, protože například převod 64bitový
integer &rarr; double je vždy doprovázen ztrátou nejnižších číslic!).
Osmdesátibitový vektor je rozdělený do třech částí následujícím způsobem:</p>

<ul>
<li>1 bit pro znaménko</li>
<li>15 bitů pro exponent (<i>BIAS</i> je roven 16383)</li>
<li>64 bitů pro mantisu (maximální hodnota přesahuje 10<sup>4932</sup>)</li>
</ul>

<p>U&nbsp;tohoto formátu je zajímavá funkce bitu s&nbsp;indexem 63. Podle
hodnoty tohoto bitu se rozlišují čísla normalizovaná a nenormalizovaná (tento
bit ve skutečnosti nahrazuje implicitně nastavovaný nejvyšší bit mantisy, jak
ho známe z&nbsp;předchozích formátů). Všechny možnosti, které mohou při
ukládání extended FP formátu nastat, jsou přehledně vypsány v&nbsp;následující
tabulce:</p>

<table>
<tr><th>s-bit</th><th>exponent</th><th>mantisa</th><th>m<sub>63</sub><th>význam</th></tr>
<tr><td>0</td><td>0&lt;e&lt;32767</td><td>&gt;0</td><td>1</td><td>normalizované kladné číslo</td></tr>
<tr><td>1</td><td>0&lt;e&lt;32767</td><td>&gt;0</td><td>1</td><td>normalizované záporné číslo</td></tr>
<tr><td>0</td><td>0&lt;e&lt;32767</td><td>&gt;0</td><td>0</td><td><strong>ne</strong>normalizované kladné číslo</td></tr>
<tr><td>1</td><td>0&lt;e&lt;32767</td><td>&gt;0</td><td>0</td><td><strong>ne</strong>normalizované záporné číslo</td></tr>
<tr><td>0</td><td>0</td><td>&gt;0</td><td>0</td><td><strong>de</strong>normalizované kladné číslo</td></tr>
<tr><td>1</td><td>0</td><td>&gt;0</td><td>0</td><td><strong>de</strong>normalizované záporné číslo</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>x</td><td>kladná nula</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>x</td><td>záporná nula</td></tr>
<tr><td>0</td><td>32767</td><td>0</td><td>x</td><td>kladné nekonečno</td></tr>
<tr><td>1</td><td>32767</td><td>0</td><td>x</td><td>záporné nekonečno</td></tr>
<tr><td>0</td><td>32767</td><td>&gt;0</td><td>x</td><td>NaN &ndash; not a number</td></tr>
<tr><td>1</td><td>32767</td><td>&gt;0</td><td>x</td><td>NaN &ndash; not a number</td></tr>
</table>

<p>Pro normalizované i nenormalizované hodnoty je možné uloženou hodnotu
vyjádřit pomocí vzorce (všimněte si, že bit 63 je umístěn před binární
tečkou):</p>

<p><i>X<sub>extended</sub>=(-1)<sup>s</sup>&nbsp;&times;&nbsp;2<sup>exp-16383</sup>&nbsp;&times;&nbsp;m</i></p>
<p><i>m=m<sub>63</sub><sup>0</sup>+m<sub>62</sub><sup>-1</sup>+m<sub>61</sub><sup>-2</sup>+...+m<sub>0</sub><sup>-63</sup></i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Omezení typů <strong>single</strong> i <strong>double</strong></h2>

<p>Největší nevýhodou formátů <i>single</i> a <i>double</i>, s&nbsp;nimiž jsme
se seznámili v&nbsp;předchozích kapitolách, je fakt, že zvolený základ
exponentu (báze) je sice výhodný z&nbsp;pohledu realizace výpočtů (ať již
v&nbsp;SW či HW), ovšem na druhou stranu to způsobuje problémy při práci
s&nbsp;hodnotami, s&nbsp;nimiž se běžně setkáváme při výpočtech s&nbsp;měnou
(úroky, daně, účetnictví). Zdaleka nejznámější je v&nbsp;tomto ohledu
konstanta, kterou můžeme v&nbsp;desítkové soustavě zapsat jako 0,1 (či 0.1).
Zatímco v&nbsp;desítkové soustavě je tato konstanta reprezentovatelná konečným
počtem cifer (zde konkrétně se jedná o dvě cifry + desetinnou tečku), ve
formátech <i>single</i> a <i>double</i> to tak snadné není, protože pro
<i>přesnou</i> reprezentaci desítkové hodnoty 0,1 by bylo nutné použít
nekonečný rozvoj dvojkových cifer:</p>

<pre>
0.00011001100110011... (opakující se sekvence 0011)
</pre>

<p>V&nbsp;případě, že použijeme konečný počet cifer (a to u typů <i>single</i>
i <i>double</i> pochopitelně musíme), tak ve skutečnosti uložíme pouze
přibližnou hodnotu 0,1, konkrétně hodnotu 0.100000001490116119384765625
s&nbsp;chybou 0.000000001490116119384765625 (v&nbsp;případě typu <i>float</i>).
Sice se může stát, že se jedná o malou chybu, ovšem u operací s&nbsp;měnou
v&nbsp;takovém případě to může vést k&nbsp;reálným problémům (typickým
příkladem může být složený úrok).</p>

<p>Podívejme se na jednoduchý příklad, který navíc ukazuje další vlastnost
formátů <i>single</i> a <i>double</i> &ndash; zaokrouhlování při výpočtech i
zaokrouhlování při výpisu hodnot na obrazovku. Budeme sčítat dvojici
desítkových hodnot 0,1 a 0,2 a porovnávat výsledek s&nbsp;konstantou 0,3. Ani
jednu z&nbsp;hodnot přitom není možné reprezentovat přesně:</p>

<table>
<tr><th>Původní hodnota</th><th>Ve skutečnosti uloženo</th><th>Chyba</th></tr>
<tr><td>0.1</td><td>0.100000001490116119384765625</td><td>0.000000001490116119384765625</td></tr>
<tr><td>0.2</td><td>0.20000000298023223876953125</td><td>0.00000000298023223876953125</td></tr>
<tr><td>0.3</td><td>0.300000011920928955078125</td><td>0.000000011920928955078125</td></tr>
</table>

<p>Přesto &bdquo;díky&ldquo; nepřesnostem, které jsou zkombinovány se
zaokrouhlením atd. dostaneme odlišné výsledky pro <i>single (float)</i> a
<i>double</i>:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
int main(void) {
    float x = 0.1;
    float y = 0.2;
    float z = 0.3;
&nbsp;
    puts(x + y == z ? "rovnost" : "nerovnost");
    return 0;
}
</pre>

<p>Tento program vypíše:</p>

<pre>
rovnost
</pre>

<p>Zatímco pro typ <i>double</i>:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
int main(void) {
    double x = 0.1;
    double y = 0.2;
    double z = 0.3;
&nbsp;
    puts(x + y == z ? "rovnost" : "nerovnost");
    return 0;
}
</pre>

<p>Dostaneme opačný výsledek:</p>

<pre>
nerovnost
</pre>

<p><div class="rs-tip-major">Poznámka: z&nbsp;toho mj.&nbsp;vyplývá, že je
vhodnější zjišťovat, zda se nějaká hodnota liší od očekávané hodnoty o nějaké
zvolené &epsilon;.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Klasický problém: konečná či nekonečná smyčka?</h2>

<p>Ještě zákeřnější je chování formátů s&nbsp;plovoucí řádovou čárkou
v&nbsp;případech, že s&nbsp;jejich využitím realizujeme počítané programové
smyčky, speciálně ve chvíli, kdy testujeme, zda se <i>přesně</i> dosáhne
koncové hodnoty počitadla. Problém pochopitelně spočívá především
v&nbsp;chápání onoho slova &bdquo;přesně&ldquo;, protože přesné obecně nejsou
ani výpočty s&nbsp;plovoucí čárkou ani uložené hodnoty.</p>

<p>Opět si toto chování ukažme na známých příkladech. Například si zkusme
přeložit a spustit program s&nbsp;touto smyčkou:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
int main(void) {
    float x;
&nbsp;
    for (x=0.0; x!=1.0; x+=0.2) {
        printf("%f\n", x);
    }
    return 0;
}
</pre>

<p>Z&nbsp;výsledků plyne, že se tento program chová podle očekávání:</p>

<pre>
0.000000
0.200000
0.400000
0.600000
0.800000
</pre>

<p>Mohlo by se tedy zdát, že i když nahradíme krok 0,2 za 0,1, nic podstatného
se nezmění, pouze se nevypíše pět hodnot, ale hodnot deset:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
int main(void) {
    float x;
&nbsp;
    for (x=0.0; x!=1.0; x+=0.1) {
        printf("%f\n", x);
    }
    return 0;
}
</pre>

<p>Jak je tomu však v&nbsp;praxi? Program nejprve vypíše prvních deset hodnot
podle očekávání:</p>

<pre>
0.000000
0.100000
0.200000
0.300000
0.400000
0.500000
0.600000
0.700000
0.800000
0.900000
</pre>

<p>Poté však pokračuje dále (mezní hodnotu smyčky tedy přeskočí, což je
matoucí, ovšem jedná se o zaokrouhlení při výpisu hodnoty):</p>

<pre>
1.100000
1.200000
1.300000
1.400000
1.500000
1.600000
...
...
...
</pre>

<p>A po určité chvíli již bude chyba tak velká, že se ve výpisu objeví
&bdquo;divná&ldquo; čísla:</p>

<pre>
...
...
...
7.799995
7.899995
7.999995
...
...
...
</pre>

<p>A chyba bude narůstat:</p>

<pre>
...
...
...
107436.304688
107436.406250
107436.507812
107436.609375
107436.710938
...
...
...
</pre>

<p>Mohlo by se tedy zdát, že přechodem ze <i>single (float)</i> na
<i>double</i> se problému zbavíme, protože vše by mělo být
&bdquo;přesnější&ldquo;. Opět si to nejprve otestujme se smyčkou s&nbsp;krokem
0,2:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
int main(void) {
    double x;
&nbsp;
    for (x=0.0; x!=1.0; x+=0.2) {
        printf("%f\n", x);
    }
    return 0;
}
</pre>

<p>Vše vypadá v&nbsp;pořádku:</p>

<pre>
0.000000
0.200000
0.400000
0.600000
0.800000
</pre>

<p>Přejděme tedy na smyčku s&nbsp;krokem 0,1:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
int main(void) {
    double x;
&nbsp;
    for (x=0.0; x!=1.0; x+=0.1) {
        printf("%f\n", x);
    }
    return 0;
}
</pre>

<p>Nyní opět dojde k&nbsp;problému s&nbsp;&bdquo;přeskokem&ldquo; mezní
hodnoty:</p>

<pre>
0.000000
0.100000
0.200000
0.300000
0.400000
0.500000
0.600000
0.700000
0.800000
0.900000
1.000000 !!!!!!!!
1.100000
1.200000
1.300000
1.400000
1.500000
1.600000
1.700000
1.800000
1.900000
...
...
...
495457.199956
495457.299956
495457.399956
495457.499956
495457.599956
495457.699956
495457.799956
495457.899956
495457.999956
495458.099956
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Tisk numerických hodnot <i>single</i> a <i>double</i> v&nbsp;hexadecimálním formátu</h2>

<p>Zajímavé bude zjistit, jak vlastně vypadá interní formát numerických hodnot
uložených ve formátech <i>single</i> a <i>double</i>. Můžeme se pokusit vypsat
si ony 32bitové či 64bitové hodnoty v&nbsp;hexadecimálním formátu (tedy
zakódovaná sekvence 32 či 64 bitů) popř.&nbsp;využít &bdquo;hexadecimální FP
formát&ldquo;, jenž je v&nbsp;céčkové knihovně podporován.</p>

<p>Nejprve si ukažme použití &bdquo;hexadecimálního FP formátu&ldquo;, který je
zajištěn díky formátovacímu znaku <strong>%a</strong>:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
int main(void)
{
    float values[] = {0.0, 0.1, 0.2, 1.0, 2.0, 10.0, 100.0, 1000.0, 1000.1, 1.0/0.0, -0.0, -0.1, -0.2, -1.0, -1000.0, -1.0/0.0, 0.0/0.0};
    int i;
&nbsp;
    for (i=0; i&lt;sizeof(values)/sizeof(float); i++) {
        printf("%9.4f   %a\n", values[i], values[i]);
    }
&nbsp;
    return 0;
}
</pre>

<p>Výsledky zde odhalují, že hodnoty 0,1 atd. nelze reprezentovat zcela přesně:</p>

<pre>
   0.0000   0x0p+0
   0.1000   0x1.99999ap-4
   0.2000   0x1.99999ap-3
   1.0000   0x1p+0
   2.0000   0x1p+1
  10.0000   0x1.4p+3
 100.0000   0x1.9p+6
1000.0000   0x1.f4p+9
1000.1000   0x1.f40cccp+9
      inf   inf
  -0.0000   -0x0p+0
  -0.1000   -0x1.99999ap-4
  -0.2000   -0x1.99999ap-3
  -1.0000   -0x1p+0
-1000.0000   -0x1.f4p+9
     -inf   -inf
     -nan   -nan
</pre>

<p>Totéž lze pochopitelně provést i pro datový typ <i>double</i>:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
int main(void)
{
    double values[] = {0.0, 0.1, 0.2, 1.0, 2.0, 10.0, 100.0, 1000.0, 1000.1, 1.0/0.0, -0.0, -0.1, -0.2, -1.0, -1000.0, -1.0/0.0, 0.0/0.0};
    int i;
&nbsp;
    for (i=0; i&lt;sizeof(values)/sizeof(double); i++) {
        printf("%9.4f   %a\n", values[i], values[i]);
    }
&nbsp;
    return 0;
}
</pre>

<p>Výsledky odhalují stále stejný problém:</p>

<pre>
   0.0000   0x0p+0
   0.1000   0x1.999999999999ap-4
   0.2000   0x1.999999999999ap-3
   1.0000   0x1p+0
   2.0000   0x1p+1
  10.0000   0x1.4p+3
 100.0000   0x1.9p+6
1000.0000   0x1.f4p+9
1000.1000   0x1.f40cccccccccdp+9
      inf   inf
  -0.0000   -0x0p+0
  -0.1000   -0x1.999999999999ap-4
  -0.2000   -0x1.999999999999ap-3
  -1.0000   -0x1p+0
-1000.0000   -0x1.f4p+9
     -inf   -inf
     -nan   -nan
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Interní struktura hodnot typu <strong>single</strong> a <strong>double</strong></h2>

<p>&bdquo;Hexadecimální výstup&ldquo; ve formě, v&nbsp;jaké byl ukázán
v&nbsp;předchozí kapitole, však nenapovídá, jak přesně jsou hodnoty typu
<i>single</i> a <i>double</i> reprezentovány (resp.&nbsp;uloženy). První náhled
na způsob uložení nám dá pouhý převod těchto hodnot na sekvenci osmi či
šestnácti hexadecimálních cifer. Toho můžeme dosáhnout v&nbsp;programovacím
jazyku C snadno, viz též následující dva příklady.</p>

<p>První příklad převede hodnoty typu <i>float</i> na 32bitové hexadecimální
číslo:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
&nbsp;
void print_float_as_hex(float value) {
    union {
        float f;
        uint32_t u;
    } f2u = { .f = value };
&nbsp;
    printf("%f -&gt; %08x\n", value, f2u.u);
}
&nbsp;
int main(void) {
    float x = 0.1;
    float y = 0.2;
    float z = 0.3;
&nbsp;
    print_float_as_hex(x);
    print_float_as_hex(y);
    print_float_as_hex(z);
    return 0;
}
</pre>

<p>Z&nbsp;výsledků je patrné, že všechny tři &bdquo;problémové&ldquo; numerické
hodnoty, s&nbsp;nimiž jsme se již setkali, by pravděpodobně vyžadovaly
nekonečný rozvoj. I bez znalosti přesného způsobu uložení je navíc patrné, že
se provedlo zaokrouhlení (z&nbsp;C na D resp.&nbsp;z 9 na A):</p>

<pre>
0.100000 -&gt; 3dcccccd
0.200000 -&gt; 3e4ccccd
0.300000 -&gt; 3e99999a
</pre>

<p>Tutéž operaci můžeme provést i pro hodnoty typu <i>double</i>, které
převedeme na 64bitové hexadecimální číslo:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
&nbsp;
void print_double_as_hex(double value) {
    union {
        double f;
        uint64_t u;
    } f2u = { .f = value };
&nbsp;
    printf("%f -&gt; %016lx\n", value, f2u.u);
}
&nbsp;
int main(void) {
    double x = 0.1;
    double y = 0.2;
    double z = 0.3;
&nbsp;
    print_double_as_hex(x);
    print_double_as_hex(y);
    print_double_as_hex(z);
    return 0;
}
</pre>

<p>I zde je jasně patrné zaokrouhlení:</p>

<pre>
0.100000 -&gt; 3fb999999999999a
0.200000 -&gt; 3fc999999999999a
0.300000 -&gt; 3fd3333333333333
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Dekódování numerických hodnot uložených ve formátu <i>single</i> a <i>double</i></h2>

<p>Mnohem více informací o uložení <i>single</i> a <i>double</i> však získáme
až ve chvíli, kdy se pokusíme o dekódování oněch 32bitových či 64bitových
hodnot. Opět se nejdříve podívejme na typ <i>single</i>, který rozděluje
32bitovou hodnotu na jednobitové znaménko, osmibitový exponent s&nbsp;biasem
127 a 23 bitovou mantisou, kde se u normalizovaných hodnot předpokládá, že
nejvyšší bit mantisy je jedničkový a proto nemusí být uložen. Navíc víme, že
pokud má exponent maximální možnou hodnotu, je uloženo buď nekonečno či
&bdquo;nečíslo&ldquo; NaN (rozlišujeme zde podle hodnoty mantisy). Znaménko
nekonečna je určeno znaménkovým bitem. Zbytek je již zajištěn bitovými posuny,
maskováním bitů a trikem s&nbsp;přičtením jedničky (ten je ovšem
<i>nekorektní</i> pro nenormalizované hodnoty):</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
void decode_float(float value)
{
    const int exponent_bias = 127;
    const int mantissa_base = 1 &lt;&lt; 23;
    const int max_exponent = 255;
    const int mantissa_mask = 0x07fffff;
&nbsp;
    const int mantissa_bits = 23;
    const int exponent_bits = 8;
&nbsp;
    typedef union {
        float value;
        __uint32_t x;
    } IEEE_754_float;
&nbsp;
    IEEE_754_float f;
    f.value = value;
    __uint32_t x = f.x;
&nbsp;
    unsigned int sign = 0x01 &amp; (x &gt;&gt; (mantissa_bits + exponent_bits));
    unsigned int exponent = max_exponent &amp; (x &gt;&gt; mantissa_bits);
    unsigned int mantissa = mantissa_mask &amp; x;
&nbsp;
    printf("%+10.4f       ", value);
&nbsp;
    if (exponent == max_exponent) {
        if (mantissa == 0) {
            printf("%c infinity\n", sign ? '-' : '+');
        } else {
            puts("NaN");
        }
    } else {
        printf("%c %10.8f x 2^%-2d\n", sign ? '-' : '+',
               1.0 + (float) mantissa / mantissa_base, exponent - exponent_bias);
    }
}
&nbsp;
&nbsp;
int main(void)
{
    float values[] = {0.0, 0.1, 0.2, 1.0, 2.0, 10.0, 100.0, 1000.0, 1000.1, 1.0/0.0, -0.0, -0.1, -0.2, -1.0, -1000.0, -1.0/0.0, 0.0/0.0};
    int i;
&nbsp;
    for (i=0; i&lt;sizeof(values)/sizeof(float); i++) {
        decode_float(values[i]);
    }
&nbsp;
    return 0;
}
</pre>

<p>Nyní se podívejme, jaké výsledky (interní struktura) se vypíšou pro některé
zajímavé hodnoty, které jsou součástí zdrojového kódu:</p>

<pre>
   +0.0000       + 1.00000000 x 2^-127
   +0.1000       + 1.60000002 x 2^-4
   +0.2000       + 1.60000002 x 2^-3
   +1.0000       + 1.00000000 x 2^0 
   +2.0000       + 1.00000000 x 2^1 
  +10.0000       + 1.25000000 x 2^3 
 +100.0000       + 1.56250000 x 2^6 
+1000.0000       + 1.95312500 x 2^9 
+1000.1000       + 1.95332026 x 2^9 
      +inf       + infinity
   -0.0000       - 1.00000000 x 2^-127
   -0.1000       - 1.60000002 x 2^-4
   -0.2000       - 1.60000002 x 2^-3
   -1.0000       - 1.00000000 x 2^0 
-1000.0000       - 1.95312500 x 2^9 
      -inf       - infinity
      -nan       NaN
</pre>

<p>U hodnoty +0.0 a -0.0 by se ve skutečnosti mělo postupovat sofistikovaněji,
protože u nejmenší hodnoty exponentu se jedná o nenormalizovaná čísla.</p>

<p><div class="rs-tip-major">Poznámka: příkladem budiž hodnota +10.0, která je
uložena jako mantisa 1.25 a exponent 3, tj.&nbsp;výsledkem je
1.25&times;2<sup>3</sup>=10. Naopak u hodnot 0.1 a 0.2 je zřejmé, že
vynásobením mantisy 1.600000002 hodnotou 1/16 nebo 1/8 nedostaneme přesný
výsledek.</div></p>

<p>Naprosto stejným způsobem lze dekódovat hodnoty typu <i>double</i>; pouze se
použije větší počet bitů pro exponent (a tím pádem i větší bias) i větší počet
bitů pro mantisu:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
void decode_double(double value)
{
    const int exponent_bias = 1023;
    const __uint64_t mantissa_base = 1L &lt;&lt; 52;
    const int max_exponent = 2047;
    const __uint64_t mantissa_mask = 0x0fffffffffffff;
&nbsp;
    const int mantissa_bits = 52;
    const int exponent_bits = 11;
&nbsp;
    typedef union {
        double value;
        __uint64_t x;
    } IEEE_754_double;
&nbsp;
    IEEE_754_double d;
    d.value = value;
    __uint64_t x = d.x;
&nbsp;
    unsigned int sign = 0x01 &amp; (x &gt;&gt; (mantissa_bits + exponent_bits));
    unsigned int exponent = max_exponent &amp; (x &gt;&gt; mantissa_bits);
    __uint64_t mantissa = mantissa_mask &amp; x;
&nbsp;
    printf("%+10.4f       ", value);
&nbsp;
    if (exponent == max_exponent) {
        if (mantissa == 0) {
            printf("%c infinity\n", sign ? '-' : '+');
        } else {
            puts("NaN");
        }
    } else {
        printf("%c %10.8f x 2^%-2d\n", sign ? '-' : '+',
               1.0 + (double) mantissa / mantissa_base, exponent - exponent_bias);
    }
}
&nbsp;
&nbsp;
int main(void)
{
    double values[] = {0.0, 0.1, 0.2, 1.0, 2.0, 10.0, 100.0, 1000.0, 1000.1, 1.0/0.0, -0.0, -0.1, -0.2, -1.0, -1000.0, -1.0/0.0, 0.0/0.0};
    int i;
&nbsp;
    for (i=0; i&lt;sizeof(values)/sizeof(double); i++) {
        decode_double(values[i]);
    }
&nbsp;
    return 0;
}
</pre>

<p>Výsledky až na větší počet cifer odpovídají předchozímu příkladu:</p>

<pre>
   +0.0000       + 1.00000000 x 2^-1023
   +0.1000       + 1.60000000 x 2^-4
   +0.2000       + 1.60000000 x 2^-3
   +1.0000       + 1.00000000 x 2^0 
   +2.0000       + 1.00000000 x 2^1 
  +10.0000       + 1.25000000 x 2^3 
 +100.0000       + 1.56250000 x 2^6 
+1000.0000       + 1.95312500 x 2^9 
+1000.1000       + 1.95332031 x 2^9 
      +inf       + infinity
   -0.0000       - 1.00000000 x 2^-1023
   -0.1000       - 1.60000000 x 2^-4
   -0.2000       - 1.60000000 x 2^-3
   -1.0000       - 1.00000000 x 2^0 
-1000.0000       - 1.95312500 x 2^9 
      -inf       - infinity
      -nan       NaN
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Formáty <strong>Decimal32</strong>, <strong>Decimal64</strong> a <strong>Decimal128</strong></h2>

<p>Víme již, že formáty <i>single</i> i <i>double</i> jsou sice výhodné
z&nbsp;hlediska jejich implementace (a proto je najdeme v&nbsp;HW), ovšem
způsobují problémy při práci s&nbsp;často používanými desetinnými čísly, a to i
při použití malého množství desetinných míst. Jaké je tedy řešení tohoto
reálného problému? Zajisté nebude postačovat pouze zvýšit přesnost uložení,
tj.&nbsp;přejít z&nbsp;typu <i>double</i> na 96bitová či 128bitová čísla
s&nbsp;plovoucí řádovou čárkou a bází=2. Problému desítkové hodnoty 0.1,
tedy:</p>

<pre>
0.1<sub>10</sub> == 0.00011001100110011<sub>2</sub>... (opakující se sekvence 0011)
</pre>

<p>se totiž ani s&nbsp;vyšším počtem bitů mantisy či exponentu jen tak jednoduše
nezbavíme (tedy nikoli při použití konečného počtu cifer), pouze ho odsuneme do
pozdější doby.</p>

<p>Skutečné řešení spočívá v&nbsp;tom, že se použijí formáty FP hodnot, u nichž
nebude báze exponentu nastavena na konstantu 2, ale na desítku. Realizace
výpočtů v&nbsp;počítači (ať již SW či HW) se sice zkomplikuje, ovšem
&bdquo;lidské&ldquo; numerické hodnoty, tedy hodnoty, které zapisujeme
v&nbsp;desítkové soustavě, bude možné uložit naprosto přesně. A právě
z&nbsp;tohoto důvodu vznikly různé &bdquo;dekadické formáty s&nbsp;plovoucí
řádovou tečkou/čárkou&ldquo;. Tři z&nbsp;těchto formátů byly standardizovány
v&nbsp;normě IEEE 754-2008 (druhé číslo je rok vydání upravené normy) a tyto
formáty nazvané <i>Decimal32</i>, <i>Decimal64</i> a <i>Decimal128</i> můžeme
používat i v&nbsp;jazyku C, i když s&nbsp;omezeními (k&nbsp;dispozici jsou
prakticky jen výpočty a pomocné specializované funkce, ale již ne realizace
v&nbsp;knihovnách <strong>math</strong> či <strong>stdio</strong>).</p>

<pre>
#include &lt;stdint.h&gt;
&nbsp;
int main(void) {
    _Decimal32 x;
    _Decimal64 y;
    _Decimal128 z;
    return 0;
}
</pre>

<p>Společné znaky a rozdíly mezi všemi třemi &bdquo;dekadickými&ldquo;
formáty:</p>

<table>
<tr><th>Formát</th><th>Šířka</th><th>Znaménko</th><th>Bitové pole s&nbsp;ciframi</th><th>Exponent</th><th>Bitové pole <i>combination</i></th></tr>
<tr><td>Decimal32 </td><td> 32 bitů</td><td>1 bit</td><td>20 bitů</td><td>6 bitů</td><td>5 bitů</td></tr>
<tr><td>Decimal64 </td><td> 64 bitů</td><td>1 bit</td><td>50 bitů</td><td>8 bitů</td><td>5 bitů</td></tr>
<tr><td>Decimal128</td><td>128 bitů</td><td>1 bit</td><td>110 bitů</td><td>12 bitů</td><td>5 bitů</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti je interní struktura
zejména formátu <i>Decimal32</i> složitější, než naznačuje předchozí tabulka.
K&nbsp;této problematice se ještě vrátíme.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Problém hodnoty 0,1 mizí</h2>

<p>Hodnoty 0,1, 0,2 i 0,3 je možné s&nbsp;využitím libovolného typu
<i>Decimal</i> uložit zcela přesně a proto všechny tři následující příklady
vypíšou (podle očekávání) zprávu &bdquo;rovnost&ldquo;:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
int main(void) {
    _Decimal32 x = 0.1df;
    _Decimal32 y = 0.2df;
    _Decimal32 z = 0.3df;
&nbsp;
    puts(x + y == z ? "rovnost" : "nerovnost");
    return 0;
}
</pre>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
int main(void) {
    _Decimal64 x = 0.1dd;
    _Decimal64 y = 0.2dd;
    _Decimal64 z = 0.3dd;
&nbsp;
    puts(x + y == z ? "rovnost" : "nerovnost");
    return 0;
}
</pre>

<p>a:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
int main(void) {
    _Decimal128 x = 0.1dl;
    _Decimal128 y = 0.2dl;
    _Decimal128 z = 0.3dl;
&nbsp;
    puts(x + y == z ? "rovnost" : "nerovnost");
    return 0;
}
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, jakým způsobem (postfixy)
se specifikuje, že daná konstanta je typu Decimal32, Decimal64 či Decimal128.
Tyto postfixy lze zapsat jak malými, tak i velkými znaky.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Počítaná smyčka s&nbsp;krokem 0,1 a koncovou hodnotou 1,0 realizovaná s&nbsp;využitím typů Decimal</h2>

<p>Při využití datových typů <i>Decimal</i> taktéž zcela odpadá problém
s&nbsp;realizací počítané programové smyčky s&nbsp;krokem nastaveným na 0.1 a
koncovou hodnotou 1.0 &ndash; tyto smyčky vždy korektně skončí. Opět si to pro
úplnost ukažme ve všech třech variantách, i když se nyní budeme muset spokojit
s&nbsp;výpisem numerických hodnot převedených na <i>float</i> či <i>double</i>,
protože libc nemusí podporovat přímý výpis dekadických hodnot s&nbsp;plovoucí
řádovou čárkou.</p>

<p>Varianta pro <i>Decimal32</i>:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
&nbsp;
int main(void) {
    _Decimal32 x;
&nbsp;
    for (x=0.0df; x!=1.0df; x+=0.1df) {
        printf("%f\n", (float)x);
    }
    return 0;
}
</pre>

<p>Výsledky:</p>

<pre>
0.000000
0.100000
0.200000
0.300000
0.400000
0.500000
0.600000
0.700000
0.800000
0.900000
</pre>

<p>Varianta pro <i>Decimal64</i>:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
&nbsp;
int main(void) {
    _Decimal64 x;
&nbsp;
    for (x=0.0dd; x!=1.0dd; x+=0.1dd) {
        printf("%f\n", (float)x);
    }
    return 0;
}
</pre>

<p>Výsledky:</p>

<pre>
0.000000
0.100000
0.200000
0.300000
0.400000
0.500000
0.600000
0.700000
0.800000
0.900000
</pre>

<p>Varianta pro <i>Decimal128</i>:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
&nbsp;
int main(void) {
    _Decimal128 x;

    for (x=0.0dl; x!=1.0dl; x+=0.1dl) {
        printf("%f\n", (float)x);
    }
    return 0;
}
</pre>

<p>Výsledky:</p>

<pre>
0.000000
0.100000
0.200000
0.300000
0.400000
0.500000
0.600000
0.700000
0.800000
0.900000
</pre>

<p><div class="rs-tip-major">Poznámka: velikost výsledného binárního souboru
zda narůstá až k&nbsp;2MB, což je zvláštní (a bude to vyžadovat větší pochopení
toho, jaký kód a proč se slinkoval).</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Interní struktura formátu <strong>Decimal32</strong></h2>

<p>Interně vypadají formáty <i>Decimal</i> dosti odlišně od formátů
<i>single</i> a <i>double</i>, i když základní myšlenka &ndash; rozdělení na
znaménko, mantisu a exponent &ndash; vlastně zůstává zachována. Nejsložitější
je, i když to může znít poněkud paradoxně, formát <i>Decimal32</i> a proto se
zaměřme na jeho popis. 32bitové slovo je zde rozděleno na tři oblasti:</p>

<ul>
<li>1 bitové znaménko</li>
<li>11 bitů pro tzv. <i>combination field</i></li>
<li>20 bitů pro tzv. <i>trailing significand field</i></li>
</ul>

<p>Oněch 11 bitů <i>combination fieldu</i> se označuje symboly G10, G9, až G0.
V&nbsp;případě, že alespoň jeden z&nbsp;bitů G10 a G9 je nastavený na nulu, je
hodnota uložena takto:</p>

<ul>
<li>Následujících šest bitů obsahuje desítkový exponent s&nbsp;biasem 101</li>
<li>Nejnižší tři bity se spojí s&nbsp;posledními 20 bity a vytvoří tak mantisu
(ta může být uložena dvěma způsoby, ale typicky se setkáme s&nbsp;binární
reprezentací</li>
</ul>

<p>To tedy znamená, že většina běžných numerických hodnot je v&nbsp;32bitových
slovech uložena takto:</p>

<pre>
s 00eeeeee mmmmmmmmmmmmmmmmmmmmmmm
s 01eeeeee mmmmmmmmmmmmmmmmmmmmmmm
s 10eeeeee mmmmmmmmmmmmmmmmmmmmmmm
</pre>

<p>kde <i>s</i> je znaménko, <i>e</i> jsou bity exponentu (před nimi jsou i ony
konstantní bity) a <i>m</i> jsou bity mantisy.</p>

<p>V&nbsp;případě, že jak bity G10, tak i G9 jsou nastaveny na jedničku, je
kódování odlišné. Nejprve se rozeznávají speciální hodnoty podle bitů G10 až
G6:</p>

<pre>
s 11110xxx xxxxxxxxxxxxxxxxxxxxxxx - kladné nebo záporné nekonečno
s 11111xxx xxxxxxxxxxxxxxxxxxxxxxx - not a number (NaN)
</pre>

<p>Ostatní kombinace bitů (de facto kombinace nezačínající čtyřmi jedničkami)
vypadají takto:</p>

<pre>
s 11EEeeeeee 100mmmmmmmmmmmmmmmmmmmm
s 11EEeeeeee 100mmmmmmmmmmmmmmmmmmmm
s 10EEeeeeee 100mmmmmmmmmmmmmmmmmmmm
</pre>

<p>přičemž platí, že kombinace bitů EE nesmí být 11 (ale jen 00, 01 či 10);
v&nbsp;opačném případě se jedná o speciální hodnoty.</p>

<p><div class="rs-tip-major">Poznámka: to ovšem znamená, že speciální hodnoty
zabírají poměrně mnoho bitových kombinací &ndash; je vlastně využito jen pěti
bitů a zbývajících 27 bitů (tedy celkem 2<sup>28</sup> hodnot) je
nevyužito.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Dekódování hodnoty typu <strong>Decimal32</strong></h2>

<p>Zkusme si tyto případy (kromě posledního) zanést do prográmku s&nbsp;funkcí,
které se předá hodnota typu <i>Decimal32</i>, která je dekódována a následně
jsou vypsána jednotlivá bitová pole i (symbolicky) hodnota, která je uložena.
Opět připomínám, že prográmek neobsahuje jednu větev, která odpovídá G10=1 a
G9=1, přičemž se <i>nebude</i> jednat o speciální hodnotu typu nekonečno či NaN
(doplnění je relativně snadné a můžeme ho ponechat jako domácí úkol váženého
čtenáře :-). Zdrojový kód popsaného programu bude vypadat následovně:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
void decode_decimal32(_Decimal32 value)
{
    const int combination_bits = 11;
    const int trailing_bits = 20;
&nbsp;
    const int combination_mask = 0x7ff;
    const int trailing_mask = 0x0fffff;
&nbsp;
    const int exponent_bias = 101;
&nbsp;
&nbsp;
    typedef union {
        _Decimal32 value;
        __uint32_t x;
    } IEEE_754_decimal32;
&nbsp;
    IEEE_754_decimal32 d;
    d.value = value;
    __uint32_t x = d.x;
&nbsp;
    unsigned int sign = 0x01 &amp; (x &gt;&gt; (combination_bits + trailing_bits));
    unsigned int combination = combination_mask &amp; (x &gt;&gt; trailing_bits);
    unsigned int trailing =  trailing_mask &amp; x;
    unsigned int g10 = 0x01 &amp; (combination &gt;&gt; 10);
    unsigned int g9 = 0x01 &amp; (combination &gt;&gt; 9);
&nbsp;
    // hodnota po konverzi
    printf("%+10.4f       ", (float)value);
&nbsp;
    // ziskana bitova pole
    printf("%d  %d  %d  %03x  %05x      ", sign, g10, g9, combination, trailing);
&nbsp;
    // znamenko
    printf("%c  ", sign ? '-' : '+');
&nbsp;
    if ((combination &amp; 0x7c0) == 0x780) {
        printf("infinity\n");
    } else if ((combination &amp; 0x7c0) == 0x7c0) {
        printf("NaN\n");
    } else if ((g10 == 1) &amp;&amp; (g9 == 1)) {
        printf("special case\n");
    } else {
        unsigned int exponent = (combination &gt;&gt; 3) - exponent_bias;
        unsigned int mantissa = trailing + ((combination &amp; 0x07) &lt;&lt; 20);
        printf("%d x 10^%d\n", mantissa, exponent);
    }
}
&nbsp;
&nbsp;
int main(void)
{
    _Decimal32 one = 1.0dd;
    _Decimal32 three = 3.0dd;
    _Decimal32 values[] = {0.0dd, 0.1dd, 0.2dd, 1.0dd, 2.0dd,
                           10.0dd, 100.0dd, 1000.0dd, 1000.1dd,
                           one/three, 1.0dd/0.0dd,
                           -0.0dd, -0.1dd, -0.2dd, -1.0dd,
                           -1000.0dd, -1.0dd/0.0dd, 0.0dd/0.0dd};
    int i;
&nbsp;
    printf("    value        S G10 G9 comb.trailing   decoded\n");
    for (i=0; i&lt;sizeof(values)/sizeof(_Decimal32); i++) {
        decode_decimal32(values[i]);
    }
&nbsp;
    return 0;
}
</pre>

<p>Výsledky, které tento prográmek vypíše, vypadají následovně:</p>

<pre>
    value        S G10 G9 comb.trailing   decoded
   +0.0000       0  0  1  320  00000      +  0 x 10^-1
   +0.1000       0  0  1  320  00001      +  1 x 10^-1
   +0.2000       0  0  1  320  00002      +  2 x 10^-1
   +1.0000       0  0  1  320  0000a      +  10 x 10^-1
   +2.0000       0  0  1  320  00014      +  20 x 10^-1
  +10.0000       0  0  1  320  00064      +  100 x 10^-1
 +100.0000       0  0  1  320  003e8      +  1000 x 10^-1
+1000.0000       0  0  1  320  02710      +  10000 x 10^-1
+1000.1000       0  0  1  320  02711      +  10001 x 10^-1
   +0.3333       0  0  1  2f3  2dcd5      +  3333333 x 10^-7
      +inf       0  1  1  780  00000      +  infinity
   -0.0000       1  0  1  320  00000      -  0 x 10^-1
   -0.1000       1  0  1  320  00001      -  1 x 10^-1
   -0.2000       1  0  1  320  00002      -  2 x 10^-1
   -1.0000       1  0  1  320  0000a      -  10 x 10^-1
-1000.0000       1  0  1  320  02710      -  10000 x 10^-1
      -inf       1  1  1  780  00000      -  infinity
      +nan       0  1  1  7c0  00000      +  NaN
</pre>

<p>Tyto hodnoty si postupně popišme.</p>

<p>Z&nbsp;výše uvedeného výpisu je patrné, že formát Decimal32 dokáže bez
problémů ukládat hodnoty typu 0,1 atd., a to jak hodnoty kladné, tak i záporné
(znaménko je opět uloženo ve zvláštním bitu a tedy nemusíme složitě přemýšlet
na dvojkovým doplňkem atd.):</p>

<pre>
    value        S G10 G9 comb.trailing   decoded
   +0.1000       0  0  1  320  00001      +  1 x 10^-1
   +0.2000       0  0  1  320  00002      +  2 x 10^-1
   -0.1000       1  0  1  320  00001      -  1 x 10^-1
   -0.2000       1  0  1  320  00002      -  2 x 10^-1
</pre>

<p>Zcela přirozeně (alespoň z&nbsp;pohledu člověka, ne počítače) jsou uloženy i
násobky deseti, včetně hodnoty 1 (tedy deset na nultou):</p>

<pre>
   +1.0000       0  0  1  320  0000a      +  10 x 10^-1
  +10.0000       0  0  1  320  00064      +  100 x 10^-1
 +100.0000       0  0  1  320  003e8      +  1000 x 10^-1
+1000.0000       0  0  1  320  02710      +  10000 x 10^-1
   -1.0000       1  0  1  320  0000a      -  10 x 10^-1
-1000.0000       1  0  1  320  02710      -  10000 x 10^-1
</pre>

<p><div class="rs-tip-major">Poznámka: hodnoty nejsou normalizovány, což je
jeden z&nbsp;rozdílů oproti formátům <i>single</i> a <i>double</i>. Při
normalizaci by mantisa byla nastavena na jedničku a pouze by se posouval
desítkový exponent.</div></p>

<p>Nula nepatří mezi speciální hodnoty, ale je uložena jako hodnota
s&nbsp;mantisou rovnou nule (a teoreticky libovolným exponentem). A jak je
dobrým zvykem, rozlišuje se kladná a záporná nula:</p>

<pre>
    value        S G10 G9 comb.trailing   decoded
   +0.0000       0  0  1  320  00000      +  0 x 10^-1
   -0.0000       1  0  1  320  00000      -  0 x 10^-1
</pre>

<p>Speciální hodnoty mají nastaveny bity G10 a G9, na rozdíl od běžných hodnot.
A samozřejmě odlišíme kladné a záporné nekonečno:</p>

<pre>
    value        S G10 G9 comb.trailing   decoded
      +inf       0  1  1  780  00000      +  infinity
      -inf       1  1  1  780  00000      -  infinity
      +nan       0  1  1  7c0  00000      +  NaN
</pre>

<p>Zbývají nám dvě hodnoty 1000,1 a 1/3. První z&nbsp;těchto hodnot je uložena
přesně, tedy jako 10001&times;0,1. Ovšem druhou hodnotu přesně nelze
reprezentovat a opět zde dojde k&nbsp;chybě. Povšimněte si navíc, jak málo
cifer máme ve formátu <i>Decimal32</i> k&nbsp;dispozici (zde jen sedm
desítkových cifer):</p>

<pre>
    value        S G10 G9 comb.trailing   decoded
+1000.1000       0  0  1  320  02711      +  10001 x 10^-1
   +0.3333       0  0  1  2f3  2dcd5      +  3333333 x 10^-7
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Rychlost výpočtů: porovnání <strong>Decimal</strong> se <strong>single</strong> a <strong>double</strong></h2>

<p>V&nbsp;předchozím textu jsme si popsali ty nejdůležitější vlastnosti
datových typů <i>Decimal32</i> a <i>Decimal64</i>. Prozatím jsme se ovšem
nezmínili o tom, jak pomalé či naopak rychlé budou výpočty s&nbsp;numerickými
hodnotami uloženými v&nbsp;těchto formátech (a již dopředu prozradím, že
výsledky budou překvapivé). Pro porovnání rychlostí výpočtů s&nbsp;typy
<i>single (float)</i>, <i>double</i>, <i>Decimal32</i> a <i>Decimal64</i>
použijeme výpočet Mandelbrotový množiny, což je benchmark, který jsem
v&nbsp;článcích použil již nejméně desetkrát (v&nbsp;různých podobách a
v&nbsp;různých programovacích jazycích).</p>

<p>Výpočet Mandelbrotovy množiny bude naprogramován takovým způsobem, aby
jediný zápis algoritmu bylo možné použít pro výpočty s&nbsp;numerickými
hodnotami různých typů (přesněji řečeno typů s&nbsp;plovoucí řádovou čárkou, i
když teoreticky lze použít i typy s&nbsp;pevnou řádovou čárkou, které však
většinou nejsou na mainstreamových platformách přímo podporovány &ndash;
nalezneme je jen u některých digitálních signálových procesorů). Povšimněte si,
že se ve výpočtu (kromě celočíselných počitadel atd.) používá obecný a dopředu
neznámý datový typ <strong>number</strong>, který budeme muset dodefinovat:</p>

<pre>
void calc_mandelbrot(unsigned int width, unsigned int height, unsigned int maxiter, unsigned char palette[][3])
{
    const number_type zero = 0.0;
    const number_type two = 2.0;
    const number_type three = 3.0;
    const number_type bailout = 4.0;
&nbsp;
    puts("P3");
    printf("%d %d\n", width, height);
    puts("255");
&nbsp;
    number_type cy = -1.5;
    int y;
    for (y=0; y&lt;height; y++) {
        number_type cx = -2.0;
        int x;
        for (x=0; x&lt;width; x++) {
            number_type zx = zero;
            number_type zy = zero;
            unsigned int i = 0;
            while (i &lt; maxiter) {
                number_type zx2 = zx * zx;
                number_type zy2 = zy * zy;
                if (zx2 + zy2 &gt; bailout) {
                    break;
                }
                zy = two * zx * zy + cy;
                zx = zx2 - zy2 + cx;
                i++;
            }
            unsigned char *color = palette[i % 256];
            unsigned char r = *color++;
            unsigned char g = *color++;
            unsigned char b = *color;
            printf("%d %d %d\n", r, g, b);
            cx += three/width;
        }
        cy += three/height;
    }
}
</pre>

<p>Výše uvedený výpočet Mandelbrotovy množiny je pro jednoduchost uložen
v&nbsp;hlavičkovém souboru, který budeme vkládat do jednotlivých benchmarků.
V&nbsp;každém benchmarku ovšem nejprve nadefinujeme datový typ
<strong>number</strong>. Příklad pro benchmark využívající hodnoty typu
<i>single (float)</i>:</p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
&nbsp;
#include "palette_mandmap.h"
&nbsp;
typedef float number_type;
&nbsp;
#include "mandelbrot.h"
&nbsp;
int main(int argc, char **argv)
{
    if (argc &lt; 4) {
        puts("usage: ./mandelbrot width height maxiter");
        return 1;
    }
    int width = atoi(argv[1]);
    int height = atoi(argv[2]);
    int maxiter = atoi(argv[3]);
    calc_mandelbrot(width, height, maxiter, palette);
    return 0;
}
</pre>

<p>Dtto pro benchmark pro typ <i>double</i>:</p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
&nbsp;
#include "palette_mandmap.h"
&nbsp;
typedef double number_type;
&nbsp;
#include "mandelbrot.h"
&nbsp;
int main(int argc, char **argv)
{
    if (argc &lt; 4) {
        puts("usage: ./mandelbrot width height maxiter");
        return 1;
    }
    int width = atoi(argv[1]);
    int height = atoi(argv[2]);
    int maxiter = atoi(argv[3]);
    calc_mandelbrot(width, height, maxiter, palette);
    return 0;
}
</pre>

<p>A pro úplnost si uveďme i tři zbývající benchmarky pro typy <i>Decimal32</i>
a <i>Decimal64</i>:</p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
&nbsp;
#include "palette_mandmap.h"
&nbsp;
typedef _Decimal32 number_type;
&nbsp;
#include "mandelbrot.h"
&nbsp;
int main(int argc, char **argv)
{
    if (argc &lt; 4) {
        puts("usage: ./mandelbrot width height maxiter");
        return 1;
    }
    int width = atoi(argv[1]);
    int height = atoi(argv[2]);
    int maxiter = atoi(argv[3]);
    calc_mandelbrot(width, height, maxiter, palette);
    return 0;
}
</pre>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
&nbsp;
#include "palette_mandmap.h"
&nbsp;
typedef _Decimal64 number_type;
&nbsp;
#include "mandelbrot.h"
&nbsp;
int main(int argc, char **argv)
{
    if (argc &lt; 4) {
        puts("usage: ./mandelbrot width height maxiter");
        return 1;
    }
    int width = atoi(argv[1]);
    int height = atoi(argv[2]);
    int maxiter = atoi(argv[3]);
    calc_mandelbrot(width, height, maxiter, palette);
    return 0;
}
</pre>

<p>a konečně:</p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
&nbsp;
#include "palette_mandmap.h"
&nbsp;
typedef _Decimal128 number_type;
&nbsp;
#include "mandelbrot.h"
&nbsp;
int main(int argc, char **argv)
{
    if (argc &lt; 4) {
        puts("usage: ./mandelbrot width height maxiter");
        return 1;
    }
    int width = atoi(argv[1]);
    int height = atoi(argv[2]);
    int maxiter = atoi(argv[3]);
    calc_mandelbrot(width, height, maxiter, palette);
    return 0;
}
</pre>

<p>Po překladu všech výše uvedených benchmarků (s&nbsp;přepínačem
<strong>-O3</strong>; žádné další přepínače nepoužijeme, ale klidně si
vyzkoušejte přidat přepínače pro optimalizace IEEE 754 operací) je spustíme
s&nbsp;vhodně zvolenými konstantami <strong>width</strong>,
<strong>height</strong> a <strong>maxiter</strong>. Pro jednoduchost budeme
postupně měnit pouze hodnotu <strong>maxiter</strong> od nuly do 1000
s&nbsp;krokem 100.</p>

<pre>
for i in $(seq 0 100 1000)
do
    echo $i &gt;&gt; results.txt
    /usr/bin/time -f "%U" -o results.txt -a ./mandelbrot_float     1000 1000 $i &gt; /dev/null
    /usr/bin/time -f "%U" -o results.txt -a ./mandelbrot_double    1000 1000 $i &gt; /dev/null
    /usr/bin/time -f "%U" -o results.txt -a ./mandelbrot_decimal32 1000 1000 $i &gt; /dev/null
    /usr/bin/time -f "%U" -o results.txt -a ./mandelbrot_decimal64 1000 1000 $i &gt; /dev/null
done
</pre>

<p><div class="rs-tip-major">Poznámka: důvod, proč výpočet provádíme i pro
vstupní hodnotu <strong>maxiter==0</strong>, je jednoduchý &ndash; budeme si
chtít ověřit, že vykreslení samotné Mandelbrotovy množiny s&nbsp;jejím uložením
na výstup je časově tak krátká operace, že ji budeme moci ignorovat.</div></p>

<p>Výsledky benchmarků vypsané do textového souboru si převedeme do formátu CSV
a ten dále použijeme pro zobrazení grafu:</p>

<pre>
from toolz.itertoolz import partition
&nbsp;
with open("results.txt") as f:
    lines = f.read().split("\n")
&nbsp;
results = partition(5, lines)
&nbsp;
for result in results:
    print(",".join(result))
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Výsledky benchmarků</h2>

<p>První výsledky jsou získané pro počítač s&nbsp;mikroprocesorem Intel(R)
Core(TM) i7-8665U CPU @ 1.90GHz (počet jader nebude hrát žádnou roli):</p>

<pre>
Iter    float   double  Decimal32  Decimal64
--------------------------------------------
0       0.12    0.11     0.17       0.15
100     0.16    0.17     5.36       4.09
200     0.23    0.23     9.80       7.12
300     0.29    0.29    14.56      10.43
400     0.37    0.37    19.34      14.06
500     0.43    0.50    23.13      16.70
600     0.46    0.48    25.71      19.66
700     0.50    0.54    29.61      21.44
800     0.58    0.58    35.01      25.15
900     0.61    0.64    37.23      28.01
1000    0.66    0.77    41.00      31.03
</pre>

<p>V&nbsp;grafické podobě vypadají výsledky takto:</p>

<img src="https://i.iinfo.cz/images/577/gcc-decimal-1.webp" class="image-1120576" width="794" height="488" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 4: Rychlost výpočtů pro všech pět formátů numerických hodnot.</i></p>

<p>Rychlosti v&nbsp;případě <i>single/float</i> a <i>double</i> jsou tak velké,
že příslušné sloupce na grafu nejsou patrné. Proto si porovnejme pouze tyto dvě
série hodnot:</p>

<img src="https://i.iinfo.cz/images/577/gcc-decimal-2.webp" class="image-1120577" width="786" height="483" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 5: Rozdíly mezi rychlostí výpočtů s&nbsp;formáty single/float a double.</i></p>

<p>Druhé výsledky jsou získané pro počítač s&nbsp;mikroprocesorem 12th Gen
Intel(R) Core(TM) i7-1270P (počet jader opět nebude hrát žádnou roli):</p>

<pre>
Iter    float   double  Decimal32   Decimal64
---------------------------------------------
0       0.07    0.07     0.08    0.07    0.15
100     0.10    0.10     3.08    2.47    7.85
200     0.15    0.14     5.34    4.26   13.58
300     0.17    0.17     7.26    5.94   19.87
400     0.21    0.22     9.07    6.95   25.48
500     0.24    0.25    11.23    9.07   31.06
600     0.28    0.28    13.20   10.64   36.39
700     0.32    0.32    15.17   12.52   41.93
800     0.35    0.35    17.33   13.76   47.07
900     0.38    0.38    19.09   15.54   52.84
1000    0.42    0.41    20.65   16.25   57.95
</pre>

<p>Opět se podívejme i na grafickou podobu výsledků:</p>

<img src="https://i.iinfo.cz/images/577/gcc-decimal-3.webp" class="image-1120578" width="776" height="477" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 6: Rychlost výpočtů pro všech pět formátů numerických hodnot</i></p>

<img src="https://i.iinfo.cz/images/577/gcc-decimal-4.webp" class="image-1120579" width="783" height="475" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 7: Rozdíly mezi rychlostí výpočtů s&nbsp;formáty single/float a double.</i></p>

<p>Výsledky benchmarků jsou (možná) poněkud překvapivé. Začněme porovnáním
rychlostí operací s&nbsp;numerickými hodnotami ve formátech <i>single
(float)</i> a <i>double</i>. Zajímavé je, že výpočty s&nbsp;hodnotami
s&nbsp;dvojitou přesností jsou prakticky stejně rychlé (někdy i rychlejší), než
výpočty s&nbsp;jednoduchou přesností. To do určité míry dává smysl, protože
výpočty jsou prováděny stejnou výpočetní jednotkou a navíc překladač GCC
neprovedl zásadní &bdquo;vektorizaci&ldquo; kódu, kde by se dalo využít větší
délky vektorů s&nbsp;hodnotami <i>single</i> oproti vektorům s&nbsp;hodnotami
<i>double</i>. Z&nbsp;tohoto pohledu má typ <i>single</i> výhodu v&nbsp;menší
paměťové náročnosti, což se však využije například při zpracování delších
signálů, velkých polí atd.</p>

<p>Zajímavější je však fakt, že výpočty s&nbsp;typem <i>Decimal32</i> jsou
<strong>pomalejší</strong>, než výpočty s&nbsp;typem <i>Decimal64</i>. Zde se
již jedná o způsob reprezentace hodnot (<i>Decimal32</i> je složitější a
pravděpodobně vyžaduje více rozeskoků) a možná i o optimalizace určené pro
64bitovou platformu. Nicméně opět platí &ndash; pokud není zapotřebí šetřit
pamětí RAM (velká pole, tiskové sestavy, účetnictví s&nbsp;miliony položek),
pravděpodobně se vyplatí přímo použít <i>Decimal64</i>, i když se jeho dalších
předností (rozsah, přesnost) nevyužije.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady popsané v&nbsp;dnešním článku byly uloženy do
veřejného <a href="https://github.com/tisnik/presentations.git">Git
repositáře</a>, z&nbsp;něhož si je můžete snadno stáhnout a otestovat. Všechny
příklady byly otestovány s&nbsp;GCC verze 9.4.0 (to je už trošku vykopávka) a
13.2.1:</p>

<table>
<tr><th> #</th><th>Soubor</th><th>Stručný popis</th><th>Odkaz</th></tr>
<tr><td> 1</td><td>float_0_1.c</td><td>součet konstant 0,1 a 0,2, porovnání s&nbsp;konstantou 0,3; realizace typem <i>float/single</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/float_0_1.c">https://github.com/tisnik/presentations/blob/master/decimal/float_0_1.c</a></td></tr>
<tr><td> 2</td><td>float_loop_1.c</td><td>programová smyčka s&nbsp;krokem 0,2; realizace typem <i>float/single</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/float_loop_1.c">https://github.com/tisnik/presentations/blob/master/decimal/float_loop_1.c</a></td></tr>
<tr><td> 3</td><td>float_loop_2.c</td><td>programová smyčka s&nbsp;krokem 0,1; realizace typem <i>float/single</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/float_loop_2.c">https://github.com/tisnik/presentations/blob/master/decimal/float_loop_2.c</a></td></tr>
<tr><td> 4</td><td>float_values.c</td><td>převod hodnot typu <i>float/single</i> na 32bitovou hexadecimální hodnotou</td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/float_values.c">https://github.com/tisnik/presentations/blob/master/decimal/float_values.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>double_0_1.c</td><td>součet konstant 0,1 a 0,2, porovnání s&nbsp;konstantou 0,3; realizace typem <i>double</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/double_0_1.c">https://github.com/tisnik/presentations/blob/master/decimal/double_0_1.c</a></td></tr>
<tr><td> 6</td><td>double_loop_1.c</td><td>programová smyčka s&nbsp;krokem 0,2; realizace typem <i>double</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/double_loop_1.c">https://github.com/tisnik/presentations/blob/master/decimal/double_loop_1.c</a></td></tr>
<tr><td> 7</td><td>double_loop_2.c</td><td>programová smyčka s&nbsp;krokem 0,1; realizace typem <i>double</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/double_loop_2.c">https://github.com/tisnik/presentations/blob/master/decimal/double_loop_2.c</a></td></tr>
<tr><td> 8</td><td>double_values.c</td><td>převod hodnot typu <i>float/single</i> na 64bitovou hexadecimální hodnotou</td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/double_values.c">https://github.com/tisnik/presentations/blob/master/decimal/double_values.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>hexa_float.c</td><td>výpis hodnot typu <i>float/single</i> v&nbsp;hexadecimálním formátu</td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/hexa_float.c">https://github.com/tisnik/presentations/blob/master/decimal/hexa_float.c</a></td></tr>
<tr><td>10</td><td>hexa_double.c</td><td>výpis hodnot typu <i>double</i> v&nbsp;hexadecimálním formátu</td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/hexa_double.c">https://github.com/tisnik/presentations/blob/master/decimal/hexa_double.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>decode_float.c </td><td>dekódování numerických hodnot typu <i>float/single</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/decode_float.c">https://github.com/tisnik/presentations/blob/master/decimal/decode_float.c</a></td></tr>
<tr><td>12</td><td>decode_double.c</td><td>dekódování numerických hodnot typu <i>double</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/decode_double.c">https://github.com/tisnik/presentations/blob/master/decimal/decode_double.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>decimal32_0_1.c</td><td>součet konstant 0,1 a 0,2, porovnání s&nbsp;konstantou 0,3; realizace typem <i>Decimal32</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/decimal32_0_1.c">https://github.com/tisnik/presentations/blob/master/decimal/decimal32_0_1.c</a></td></tr>
<tr><td>14</td><td>decimal64_0_1.c</td><td>součet konstant 0,1 a 0,2, porovnání s&nbsp;konstantou 0,3; realizace typem <i>Decimal64</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/decimal64_0_1.c">https://github.com/tisnik/presentations/blob/master/decimal/decimal64_0_1.c</a></td></tr>
<tr><td>15</td><td>decimal128_0_1.c</td><td>součet konstant 0,1 a 0,2, porovnání s&nbsp;konstantou 0,3; realizace typem <i>Decimal128</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/decimal128_0_1.c">https://github.com/tisnik/presentations/blob/master/decimal/decimal128_0_1.c</a></td></tr>
<tr><td>16</td><td>decimal32_loop.c</td><td>programová smyčka s&nbsp;krokem 0,1; realizace typem <i>Decimal32</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/decimal32_loop.c">https://github.com/tisnik/presentations/blob/master/decimal/decimal32_loop.c</a></td></tr>
<tr><td>17</td><td>decimal64_loop.c</td><td>programová smyčka s&nbsp;krokem 0,1; realizace typem <i>Decimal64</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/decimal64_loop.c">https://github.com/tisnik/presentations/blob/master/decimal/decimal64_loop.c</a></td></tr>
<tr><td>18</td><td>decimal128_loop.c</td><td>programová smyčka s&nbsp;krokem 0,1; realizace typem <i>Decimal128</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/decimal128_loop.c">https://github.com/tisnik/presentations/blob/master/decimal/decimal128_loop.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>19</td><td>decode_decimal32.c</td><td>dekódování numerických hodnot typu <i>Decimal32</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/decode_decimal32.c">https://github.com/tisnik/presentations/blob/master/decimal/decode_decimal32.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>20</td><td>mandelbrot_float.c</td><td>benchmark s&nbsp;výpočtem Mandelbrotovy množiny, varianta pro typ <i>float/single</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/mandelbrot_float.c">https://github.com/tisnik/presentations/blob/master/decimal/mandelbrot_float.c</a></td></tr>
<tr><td>21</td><td>mandelbrot_double.c</td><td>benchmark s&nbsp;výpočtem Mandelbrotovy množiny, varianta pro typ <i>double</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/mandelbrot_double.c">https://github.com/tisnik/presentations/blob/master/decimal/mandelbrot_double.c</a></td></tr>
<tr><td>22</td><td>mandelbrot_decimal32.c</td><td>benchmark s&nbsp;výpočtem Mandelbrotovy množiny, varianta pro typ <i>Decimal32</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/mandelbrot_decimal32.c">https://github.com/tisnik/presentations/blob/master/decimal/mandelbrot_decimal32.c</a></td></tr>
<tr><td>23</td><td>mandelbrot_decimal64.c</td><td>benchmark s&nbsp;výpočtem Mandelbrotovy množiny, varianta pro typ <i>Decimal64</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/mandelbrot_decimal64.c">https://github.com/tisnik/presentations/blob/master/decimal/mandelbrot_decimal64.c</a></td></tr>
<tr><td>24</td><td>mandelbrot_decimal128.c</td><td>benchmark s&nbsp;výpočtem Mandelbrotovy množiny, varianta pro typ <i>Decimal128</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/mandelbrot_decimal128.c">https://github.com/tisnik/presentations/blob/master/decimal/mandelbrot_decimal128.c</a></td></tr>
<tr><td>25</td><td>mandelbrot.h</td><td>realizace výpočtu Mandelbrotovy množiny nezávislá na použitém datovém typu</td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/mandelbrot.h">https://github.com/tisnik/presentations/blob/master/decimal/mandelbrot.h</a></td></tr>
<tr><td>26</td><td>palette_mandmap.h</td><td>barvová paleta použitá v&nbsp;benchmarku</td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/palette_mandmap.h">https://github.com/tisnik/presentations/blob/master/decimal/palette_mandmap.h</a></td></tr>
<tr><td>27</td><td>bench.sh</td><td>spuštění benchmarků</td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/bench.sh">https://github.com/tisnik/presentations/blob/master/decimal/bench.sh</a></td></tr>
<tr><td>28</td><td>results2csv.py</td><td>převod výsledků benchmarků na formát CSV</td><td><a href="https://github.com/tisnik/presentations/blob/master/decimal/results2csv.py">https://github.com/tisnik/presentations/blob/master/decimal/results2csv.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>GCC: 6.14 Decimal Floating Types<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Decimal-Float.html">https://gcc.gnu.org/onlinedocs/gcc/Decimal-Float.html</a>
</li>

<li>Routines for decimal floating point emulation<br />
<a href="https://gcc.gnu.org/onlinedocs/gccint/Decimal-float-library-routines.html">https://gcc.gnu.org/onlinedocs/gccint/Decimal-float-library-routines.html</a>
</li>

<li>Representation of hexadecimal floating point<br />
<a href="https://www.ibm.com/docs/en/hla-and-tf/1.6?topic=lq-representation-hexadecimal-floating-point">https://www.ibm.com/docs/en/hla-and-tf/1.6?topic=lq-representation-hexadecimal-floating-point</a>
</li>

<li>Decimal floating point<br />
<a href="https://en.wikipedia.org/wiki/Decimal_floating_point">https://en.wikipedia.org/wiki/Decimal_floating_point</a>
</li>

<li>Hexadecimal Floating-Point Constants<br />
<a href="https://www.exploringbinary.com/hexadecimal-floating-point-constants/">https://www.exploringbinary.com/hexadecimal-floating-point-constants/</a>
</li>

<li>Norma IEEE 754 a příbuzní: formáty plovoucí řádové tečky<br />
<a href="https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/">https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/</a>
</li>

<li>decimal32 floating-point format<br />
<a href="https://en.wikipedia.org/wiki/Decimal32_floating-point_format">https://en.wikipedia.org/wiki/Decimal32_floating-point_format</a>
</li>

<li>decimal64 floating-point format<br />
<a href="https://en.wikipedia.org/wiki/Decimal64_floating-point_format">https://en.wikipedia.org/wiki/Decimal64_floating-point_format</a>
</li>

<li>decimal128 floating-point format<br />
<a href="https://en.wikipedia.org/wiki/Decimal128_floating-point_format">https://en.wikipedia.org/wiki/Decimal128_floating-point_format</a>
</li>

<li>IEEE-754 Floating-Point Conversion<br />
<a href="http://babbage.cs.qc.cuny.edu/IEEE-754.old/32bit.html">http://babbage.cs.qc.cuny.edu/IEEE-754.old/32bit.html</a>
</li>

<li>Small Float Formats<br />
<a href="https://www.khronos.org/opengl/wiki/Small_Float_Formats">https://www.khronos.org/opengl/wiki/Small_Float_Formats</a>
</li>

<li>Binary-coded decimal<br />
<a href="https://en.wikipedia.org/wiki/Binary-coded_decimal">https://en.wikipedia.org/wiki/Binary-coded_decimal</a>
</li>

<li>Chen–Ho encoding<br />
<a href="https://en.wikipedia.org/wiki/Chen%E2%80%93Ho_encoding">https://en.wikipedia.org/wiki/Chen%E2%80%93Ho_encoding</a>
</li>

<li>Densely packed decimal<br />
<a href="https://en.wikipedia.org/wiki/Densely_packed_decimal">https://en.wikipedia.org/wiki/Densely_packed_decimal</a>
</li>

<li>A Summary of Chen-Ho Decimal Data encoding<br />
<a href="http://speleotrove.com/decimal/chen-ho.html">http://speleotrove.com/decimal/chen-ho.html</a>
</li>

<li>Art of Assembly language programming: The 80x87 Floating Point Coprocessors<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html</a>
</li>

<li>Art of Assembly language programming: The FPU Instruction Set<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html</a>
</li>

<li>INTEL 80387 PROGRAMMER'S REFERENCE MANUAL<br />
<a href="http://www.ragestorm.net/downloads/387intel.txt">http://www.ragestorm.net/downloads/387intel.txt</a>
</li>

<li>Floating-Point Formats<br />
<a href="http://www.quadibloc.com/comp/cp0201.htm">http://www.quadibloc.com/comp/cp0201.htm</a>
</li>

<li>IBM Floating Point Architecture<br />
<a href="http://en.wikipedia.org/wiki/IBM_Floating_Point_Architecture">http://en.wikipedia.org/wiki/IBM_Floating_Point_Architecture</a>
</li>

<li>Extended Binary Coded Decimal Interchange Code<br />
<a href="http://en.wikipedia.org/wiki/EBCDIC">http://en.wikipedia.org/wiki/EBCDIC</a>
</li>

<li>ASCII/EBCDIC Conversion Table<br />
<a href="http://docs.hp.com/en/32212-90008/apcs01.html">http://docs.hp.com/en/32212-90008/apcs01.html</a>
</li>

<li>EBCDIC<br />
<a href="http://www.hansenb.pdx.edu/DMKB/dict/tutorials/ebcdic.php">http://www.hansenb.pdx.edu/DMKB/dict/tutorials/ebcdic.php</a>
</li>

<li>EBCDIC tables<br />
<a href="http://home.mnet-online.de/wzwz.de/temp/ebcdic/cc_en.htm">http://home.mnet-online.de/wzwz.de/temp/ebcdic/cc_en.htm</a>
</li>

<li>36-bit<br />
<a href="http://en.wikipedia.org/wiki/36-bit_word_length">http://en.wikipedia.org/wiki/36-bit_word_length</a>
</li>

<li>36bit.org<br />
<a href="http://www.36bit.org/">http://www.36bit.org/</a>
</li>

<li>How did the Apple II do floating point?<br />
<a href="https://groups.google.com/forum/#!topic/comp.emulators.apple2/qSBiG2TAlRg">https://groups.google.com/forum/#!topic/comp.emulators.apple2/qSBiG2TAlRg</a>
</li>

<li>IBM Floating Point Architecture<br />
<a href="https://en.wikipedia.org/wiki/IBM_Floating_Point_Architecture">https://en.wikipedia.org/wiki/IBM_Floating_Point_Architecture</a>
</li>

<li>The Arithmetic Subroutines<br />
<a href="http://www.users.waitrose.com/~thunor/mmcoyzx81/chapter17.html">http://www.users.waitrose.com/~thunor/mmcoyzx81/chapter17.html</a>
</li>

<li>ZX Floating point to Decimal code in BASIC<br />
<a href="http://www.sinclairzxworld.com/viewtopic.php?t=1422">http://www.sinclairzxworld.com/viewtopic.php?t=1422</a>
</li>

<li>Floating Point Arithmetic Package<br />
<a href="http://www.retrocomputing.net/parts/atari/800/docs/atari_os/atari_os_user_manual_08.htm">http://www.retrocomputing.net/parts/atari/800/docs/atari_os/atari_os_user_manual_08.htm</a>
</li>

<li>Turbo Pascal Real<br />
<a href="http://www.shikadi.net/moddingwiki/Turbo_Pascal_Real">http://www.shikadi.net/moddingwiki/Turbo_Pascal_Real</a>
</li>

<li>THE FLOATING POINT ARITHMETIC PACKAGE<br />
<a href="http://www.atarimax.com/freenet/freenet_material/5.8-BitComputersSupportArea/7.TechnicalResourceCenter/showarticle.php?14">http://www.atarimax.com/freenet/freenet_material/5.8-BitComputersSupportArea/7.TechnicalResourceCenter/showarticle.php?14</a>
</li>

<li>The Most Expensive One-byte Mistake: Did Ken, Dennis, and Brian choose wrong with NUL-terminated text strings?<br />
<a href="http://queue.acm.org/detail.cfm?id=2010365">http://queue.acm.org/detail.cfm?id=2010365</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

