<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Brain Floating Point &ndash; nový formát uložení čísel pro strojové učení i chytrá čidla</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Brain Floating Point &ndash; nový formát uložení čísel pro strojové učení a chytrá čidla</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Přibližně před dvěma roky se do povědomí programátorů, kteří se zabývají strojovým učením popř. práci s takzvanými chytrými čidly, dostal nový formát reprezentace numerických hodnot s plovoucí řádovou čárkou. Ten se jmenuje Brain Floating Point resp. zkráceně bfloat16. Dnes si tento formát popíšeme v kontextu dalších FP formátů.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Brain Floating Point &ndash; nový formát uložení čísel pro strojové učení i chytrá čidla</a></p>
<p><a href="#k02">2. Časté způsoby reprezentace numerických hodnot ve formátu pevné a plovoucí řádové (binární) tečky</a></p>
<p><a href="#k03">3. Uložení numerických hodnot ve formátu pevné řádové binární tečky</a></p>
<p><a href="#k04">4. Uložení čísel ve formátu plovoucí řádové (binární) tečky</a></p>
<p><a href="#k05">*** 5. Formát plovoucí řádové binární tečky a norma IEEE 754</a></p>
<p><a href="#k06">*** 6. Přednosti a zápory formátu plovoucí řádové tečky</a></p>
<p><a href="#k07">*** 7. Podpora v&nbsp;hardware</a></p>
<p><a href="#k08">*** 8. Klasické matematické koprocesory</a></p>
<p><a href="#k09">*** 9. Digitální signálové procesory</a></p>
<p><a href="#k10">*** 10. Grafické akcelerátory a GPU</a></p>
<p><a href="#k11">*** 11. Moderní GPU</a></p>
<p><a href="#k12">*** 12. Na scénu přichází formát <strong>bfloat16</strong></a></p>
<p><a href="#k13">*** 13. Vztah mezi formáty <strong>single</strong>, <strong>half</strong> a <strong>bfloat16</strong></a></p>
<p><a href="#k14">*** 14. Přednosti a zápory formátu <strong>bfloat16</strong></a></p>
<p><a href="#k15">*** 15. Podpora formátu <strong>bfloat16</strong></a></p>
<p><a href="#k16">*** 16. Programovací jazyk Julia</a></p>
<p><a href="#k17">*** 17. Python a knihovna NumPy</a></p>
<p><a href="#k18">*** 18. Rozšíření do dalších programovacích jazyků</a></p>
<p><a href="#k19">*** 19. Kombinace různých formátů</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Brain Floating Point &ndash; nový formát uložení čísel pro strojové učení i chytrá čidla</h2>

<p>Přibližně od první poloviny roku 2018 se můžeme jak v&nbsp;různých článcích
zabývajících se tématem strojového učení, tak i v&nbsp;některých knihovnách a
frameworcích pro ML (<i>Machine Learning</i>) i AI (<i>Artifical
Intelligence</i>) setkat s&nbsp;numerickým formátem označeným
<strong>bfloat16</strong> neboli plným jménem <i>Brain Floating Point</i>.
Jedná se o jednu z&nbsp;několika používaných variant &bdquo;zkrácených&ldquo;
numerických formátů s&nbsp;plovoucí řádovou čárkou (někdy se setkáme se
souhrnným označením <i>half float</i>, což ovšem není zcela přesné). Numerická
hodnota uložená ve formátu <strong>bfloat16</strong> zabere v&nbsp;operační
paměti či v&nbsp;registru CPU nebo GPU pouhé dva bajty, což může znít minimálně
zvláštně v&nbsp;dnešní době, kdy se používají nejenom již poměrně dlouho
zavedené typy <i>single</i> (32 bitů) a <i>double</i> (64 bitů), ale navíc i (i
když nutno říci, že méně často) formáty <i>quadruple</i> (128 bitů) a dokonce i
<i>octuple</i> (256 bitů). Důvodů, proč se prosazuje právě formát
<strong>bfloat16</strong> je více. Zejména za to může fakt, že se
v&nbsp;oblasti strojového učení používají GPU, jejichž výpočetní výkon spojené
s&nbsp; masivní paralelizací výpočtů (a hluboké pipeliny) v&nbsp;důsledku vedou
k&nbsp;tomu, že se úzkým hrdlem opět stává rychlost resp.&nbsp;spíše pomalost
operační paměti. A poloviční bitová šířka numerických hodnot používaných
například při tréninku neuronových sítí mnohdy může vést k&nbsp;mnohonásobnému
urychlení celého procesu.</p>

<p>Nejdříve se ovšem zmiňme o tom, že přestože dnes v&nbsp;mnoha aplikačních
oblastech převažuje uložení numerických hodnot v&nbsp;nějakém formátu plovoucí
řádové čárky (či tečky &ndash; podle konkrétních místních pravidel zápisu),
můžeme se setkat i s&nbsp;formátem, v&nbsp;němž je řádová čárka/tečka pevně
umístěna na určité binární pozici, což mj.&nbsp;znamená, že se její konkrétní
pozice (významem odpovídající exponentu) nemusí explicitně ukládat.
S&nbsp;takovými formáty se setkáme v&nbsp;oblasti mikrořadičů, digitálních
signálových procesorů (DSP) i programovatelných obvodů FPGA. Výhodou je
mj.&nbsp;fakt, že si programátor sám určí požadovaný rozsah hodnot i přesnost,
a to na základě analýzy řešeného problému. Aritmetické operace jsou posléze
prováděny klasickou aritmeticko-logickou jednotkou (ALU), přičemž součet,
rozdíl i porovnání jsou shodné s&nbsp;celými čísly a u součinu a podílu je
nutné provádět bitové posuny (což mnohé DSP mohou provádět automaticky
v&nbsp;rámci jediné strojové instrukce).</p>

<p><div class="rs-tip-major">Poznámka: extrémním případem jsou celá čísla
(<i>integer</i>), u nichž je řádová čárka umístěna přesně za poslední cifru
s&nbsp;nejnižší váhou. V&nbsp;tomto případě se posuny po násobení a dělení
pochopitelně neprovádí, protože se jedná o posuny o nula bitů.</div></p>

<p>V&nbsp;anglické literatuře se zmíněná forma reprezentace číselných hodnot
označuje zkratkou <strong>FX</strong> nebo (i když asi méně často)
<strong>FXP</strong> (<i><strong>f</strong>i<strong>x</strong>ed
<strong>p</strong>oint</i>), zatímco dnes častěji používaná reprezentace
v&nbsp;systému plovoucí řádové tečky se všeobecně označuje zkratkou
<strong>FP</strong> (<i>floating point</i>). V&nbsp;jednom článku jsem dokonce
místo zkratky <strong>FX</strong> viděl i zkratku <strong>XP</strong>
(<i>fi<strong>x</strong>ed <strong>p</strong>oint</i>), ale to bylo před mnoha
lety, v&nbsp;době dnes již muzeálních Windows 95 :-). Nejprve si vysvětlíme
princip obou metod použitých pro ukládání podmnožiny racionálních čísel a
posléze si také řekneme, jaké výhody a nevýhody jednotlivé principy přináší
v&nbsp;každodenní programátorské praxi a ve kterých situacích je vhodnější
použít pevnou řádovou čárku. V&nbsp;dalším textu budeme formát pevné binární
řádové tečky zkracovat na <strong>FX formát</strong> a formát používající
plovoucí řádovou tečku budeme zapisovat jako <strong>FP formát</strong>.</p>

<p><div class="rs-tip-major">Poznámka pro úplnost: některé programovací jazyky,
typicky jazyky z&nbsp;LISPovské větve, podporují i typ <i>rational</i>,
v&nbsp;němž je hodnota reprezentována zlomkem dvou celých čísel. Na současném
HW se výpočty s&nbsp;tímto datovým typem provádí softwarově &ndash; jinými
slovy nejsou přímo podporovány ani v&nbsp;ALU ani ve FPU.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Časté způsoby reprezentace numerických hodnot ve formátu pevné a plovoucí řádové (binární) tečky</h2>

<p>Při ukládání číselných hodnot do operační paměti počítače poměrně záhy
narazíme na některé problémy, z&nbsp;nichž některé souvisí s&nbsp;konečným
počtem bitů, které pro uložení dané hodnoty &bdquo;obětujeme&ldquo; a další
vycházejí ze způsobu zpracování numerických hodnot mikroprocesorem či
matematickým koprocesorem. V&nbsp;konečném počtu bitů je totiž možné uložit
pouze <strong>konečné</strong> množství různých hodnot (pro <i>n</i> bitů
maximálně <i>2<sup>n</sup></i> hodnot, i když u mnohých formátů je to méně) a
je plně v&nbsp;rukou programátora a návrháře HW, jak efektivně daný počet bitů
využije či naopak promrhá ukládáním nepodstatných informací. Poměrně často se
totiž stává, že i program využívající dvojitou či dokonce rozšířenou přesnost
čísel při <strong>FP</strong> operacích (tj.&nbsp;datové typy <i>double</i> a
<i>extended/temporary</i>) dává nesprávné výsledky dané nepochopením principu
práce <strong>FP</strong> aritmetiky a přitom je možné se přesnějších výsledků
dobrat i při použití pouhých 32 bitů či dokonce šestnácti bitů, ale
s&nbsp;pečlivě vyváženými aritmetickými a bitovými operacemi.</p>

<p>Na druhou stranu nejsou dnes používané mikroprocesory tak univerzálními
zařízeními, jak by se na první pohled mohlo zdát. Mikroprocesory jsou totiž
(většinou) navrženy tak, aby účinně, například v&nbsp;rámci jedné operace či
instrukce, zpracovávaly pouze konstantní počet bitů. Příkladem mohou být dnes
velmi rozšířené procesory řady x86 a x86-64, které jsou velmi dobré při práci
s&nbsp;32bitovými resp.&nbsp;64bitovými hodnotami, ale při požadavku na
aritmetické výpočty probíhající na (řekněme) 21 bitech se veškerá jejich
efektivita ztrácí a procesor se širokými vnitřními sběrnicemi, matematickým
koprocesorem atd. se potýká s&nbsp;prohazováním jednotlivých bitů. Podobně
mnohé DSP dokážou velmi efektivně provádět výpočty s&nbsp;operandy o šířce 24
bitů, ovšem operace s&nbsp;jinými typy operandů nejsou prakticky podporovány
vůbec. Mnohem lepší situace nastane v&nbsp;případě, že se nějaká operace
implementuje na programovatelném poli FPGA &ndash; zde je možné vytvořit obvody
provádějící matematické a logické operace s&nbsp;libovolným počtem bitů, čímž
se oproti univerzálním řešením (např.&nbsp;konstantní bitová šířka sběrnice
a/nebo registrů) ušetří mnoho plochy těchto velmi zajímavých obvodů (FPGA mohou
mimochodem znamenat i velkou šanci pro hnutí open source &ndash; pomocí nich by
mohlo vznikat, a někde už vzniká <strong>open hardware</strong>, které by mohlo
odstranit závislost na &bdquo;uzavřených&ldquo; síťových a grafických kartách
apod.).</p>

<p>Vraťme se však ke způsobům reprezentace číselných hodnot v&nbsp;operační
paměti. Nejprve předpokládejme, že pro reprezentaci vlastností určitého objektu
či stavu z&nbsp;reálného světa použijeme <i>N</i> binárních číslic (bitů),
tj.&nbsp;základních jednotek informace, která může nabývat pouze jedné ze dvou
povolených hodnot (ty se značí například symboly <i>yes/no</i> nebo
<i>true</i>/<i>false</i>, ale my se budeme spíše držet označení <i>0</i> a
<i>1</i>). Pomocí této uspořádané <i>N</i>-tice je možné popsat celkem:</p>

<p><i>2<sub>0</sub>&times;2<sub>1</sub>&times;2<sub>2</sub> ... 2<sub>N-1</sub>=2<sup>N</sup></i></p>

<p>jednoznačných, tj.&nbsp;navzájem odlišných, stavů. Množina těchto stavů může
reprezentovat prakticky jakýkoliv abstraktní či reálný objekt. Přitom si musíme
uvědomit, že u této množiny není implicitně řečeno ani myšleno, že se jedná
například o celá kladná čísla, to je pouze jedna z&nbsp;mnoha možných
interpretací zvolené <i>N</i>-tice (my programátoři máme tendenci považovat
celá kladná čísla za přirozenou interpretaci bitové <i>N</i>-tice, to však
vychází pouze z&nbsp;našeho pohledu na svět a z&nbsp;našich zkušeností).
Reprezentaci momentálního stavu abstraktního či reálného objektu si můžeme
představit jako zobrazení z&nbsp;množiny binárních stavů na elementy vzorové (a
obecně neuspořádané) množiny. Nejčastěji používanými zobrazeními jsou zobrazení
množiny binárních stavů na interval celých kladných čísel (<i>Unsigned
Integers</i>), popřípadě na interval celých čísel (<i>Signed Integers</i>).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Uložení numerických hodnot ve formátu pevné řádové binární tečky</h2>

<p>Numerické hodnoty zapsané ve&nbsp;formátu <i>pevné řádové binární tečky</i>
se chápou jako podmnožina racionálních čísel, což jsou taková čísla, jejichž
hodnoty lze vyjádřit vztahem:</p>

<p><i>x<sub>FX</sub>=a/b &nbsp;&nbsp; a,b leží v Z, b &ne; 0</i></p>

<p>Číselné hodnoty z&nbsp;uvažované podmnožiny jsou navíc omezeny
podmínkou:</p>

<p><i>b=2<sup>k</sup> &nbsp;&nbsp; b leží v Z, k leží v Z<sup>+</sup></i></p>

<p>Protože <i>b</i> je celočíselnou mocninou dvojky (a ne desítky či jiného
základu), určuje jeho hodnota <i>n</i> polohu <i>binární tečky</i>
v&nbsp;uloženém čísle. Další podmínkou, která má však spíše implementační
charakter, je zachování stejného počtu binárních cifer v&nbsp;každém
reprezentovaném čísle, což mimo jiné znamená, že všechna čísla mají řádovou
binární tečku umístěnou na stejném místě &ndash; z&nbsp;této podmínky ostatně
plyne i název popisovaného způsobu reprezentace vybrané podmnožiny racionálních
čísel. Tak jako i v&nbsp;jiných reprezentacích čísel, jsou nulové číslice před
první nenulovou cifrou a za poslední nenulovou cifrou nevýznamné, proto je není
zapotřebí uvádět.</p>

<p>Prakticky může být číselná hodnota v&nbsp;systému pevné řádové tečky uložena
na osmi bitech například následujícím způsobem (uvažujeme pouze kladné
hodnoty):</p>

<table>
<tr><td>Pozice bitu</td><td>8&nbsp;&nbsp;&nbsp;&nbsp;</td><td>7&nbsp;&nbsp;&nbsp;&nbsp;</td><td>6&nbsp;&nbsp;&nbsp;&nbsp;</td><td>5&nbsp;&nbsp;&nbsp;&nbsp;</td><td>4&nbsp;&nbsp;&nbsp;&nbsp;</td><td>3&nbsp;&nbsp;&nbsp;&nbsp;</td><td>2&nbsp;&nbsp;&nbsp;&nbsp;</td><td>1&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td>Váha bitu</td><td>2<sup>4</sup></td><td>2<sup>3</sup></td><td>2<sup>2</sup></td><td>2<sup>1</sup></td><td>2<sup>0</sup></td><td>2<sup>-1</sup></td><td>2<sup>-2</sup></td><td>2<sup>-3</sup></td></tr>
<tr><td>Desítková váha bitu</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td><td>0,5</td><td>0,25</td><td>0,125</td></tr>
</table>

<p>Ve výše uvedeném příkladu je binární řádová tečka umístěna vždy mezi třetím
a čtvrtým bitem. Vzhledem k&nbsp;tomu, že je tato skutečnost dopředu známá
algoritmu, který provádí zpracování čísel (základní aritmetické operace), není
zapotřebí spolu s&nbsp;číslem uchovávat i pozici binární tečky, což výrazně
snižuje počet bitů, které je zapotřebí rezervovat pro čísla ze zadaného
rozsahu. To je tedy první přednost systému pevné řádové tečky &ndash; pokud
programátor dopředu zná rozsah všech zpracovávaných hodnot a požadovanou
přesnost, může být výhodné tento systém použít. Programátor také díky
explicitním určení polohy řádové tečky může určit, ve kterém místě programu se
musí přesnost či rozsah zvýšit a kdy naopak snížit. Lépe se tak využije počet
bitů, které můžeme pro uložení jednoho čísla obětovat (typicky je tento počet
bitů roven délce slova mikroprocesoru, popř.&nbsp;jeho celočíselnému násobku či
naopak podílu).</p>

<p>Dále je možné základní matematické operace (sčítání, odčítání, násobení a
dělení) poměrně jednoduše implementovat i při použití formátu pevné řádové
tečky. V&nbsp;případě, že není k&nbsp;dispozici specializovaný (a současně
velmi komplikovaný) matematický koprocesor, je mnohdy mnohem jednodušší a
rychlejší implementovat matematické operace v&nbsp;FX formátu. To je případ
mnoha jednočipových mikroprocesorů (mikrořadičů), signálových procesorů, ale i
specializovaných zařízení obsahujících programovatelné obvody CPLD či FPGA.
Dnes sice mají komplikovanější (a dražší) FPGA implementovanou i jednotku FPU,
ale mnohdy je výhodnější použít FPGA bez této jednotky a potřebné operace si do
tohoto obvodu &bdquo;vypálit&ldquo; po svém.</p>

<p><div class="rs-tip-major">Poznámka: typickým příkladem DSP navrženým pro FX
aritmetiku je revoluční čip <i>TMS32010</i>, jenž jsme si popsali
v&nbsp;článcích <a
href="https://www.root.cz/clanky/digitalni-signalove-procesory-rady-tms320/">Digitální
signálové procesory řady TMS320</a> a <a
href="https://www.root.cz/clanky/instrukcni-sada-digitalnich-signalovych-procesoru-rady-tms320/">Instrukční
sada digitálních signálových procesorů řady TMS320</a>.</div></p>

<img src="https://i.iinfo.cz/images/257/tms320-1.png" class="image-275138" alt="" width="550" height="806">
<p><i>Obrázek 1: Interní bloky DSP TMS32010, z&nbsp;nichž je patrné, že se
násobení a posun dají provádět velmi efektivně (ostatně tento DSP vlastně není
nic jiného, než podpůrné obvody postavené okolo rychlé násobičky).</i></p>

<p>Třetí výhodou je fakt, že u FX formátu může programátor navrhnout a posléze
také dodržet požadovanou přesnost všech prováděných výpočtů. To je velký rozdíl
oproti FP formátu (resp.&nbsp;jeho podmnožinám, které se nejčastěji používají).
Není vzácností narazit na programy, které používají datové typy <i>float</i> či
<i>double</i> a přitom jsou výpočty prováděné v&nbsp;těchto programech zatíženy
velkou chybou, protože si programátoři plně neuvědomují některé limity FP
formátu (příklady si ukážeme níže). Zcela kritické jsou například výpočty
s&nbsp;peněžními hodnotami, ale i pouhé sčítání čísel, jež se od sebe o mnoho
řádů liší, vede k&nbsp;velkým chybám, které dokonce mohou zapříčinit vznik
nekonečných smyček, populární dělení nulou atd.</p>

<p>FX formát má však i mnohé nevýhody. První nevýhoda spočívá v&nbsp;tom, že
tento formát není příliš podporován, a to ani po programové stránce (podpora
v&nbsp;programovacích jazycích), ani výrobci mikroprocesorů pro počítače PC.
Situace je však odlišná v&nbsp;oblasti jednočipových mikropočítačů, signálových
procesorů (DSP), řídicích systémů, nebo například u IBM RS 6000, který kromě
jednotky FPU obsahuje i FXU &ndash; jednotku pro provádění výpočtů v&nbsp;pevné
řádové binární čárce. Na platformě x86 je možné pro FX formát použít instrukce
<strong>MMX</strong> a <strong>SSE-2</strong> (na rozdíl od původního SSE či
AVX orientovaných na typy <i>single</i> a <i>double</i>).</p>

<p>Dále může být použití FX formátu nevýhodné v&nbsp;případě, že se mají
zpracovávat numerické hodnoty, které mají velký dynamický rozsah,
tj.&nbsp;poměr mezi nejvyšší a nejnižší absolutní hodnotou. V&nbsp;takovém
případě by se mohlo stát, že by se při použití FX formátu muselo pro každé
číslo alokovat velké množství bitů, které by mohlo dokonce překročit počet bitů
nutných pro FP formát. Také v&nbsp;případě, kdy dopředu nevíme, jaké hodnoty se
budou zpracovávat, může být výhodnější použití FP formátu. Zde se však nabízí
otázka, ve kterých případech nevíme, jaké hodnoty můžeme na vstupu získat:
většinou je již z&nbsp;podstaty úlohy dopředu známé, s&nbsp;čím je možné
počítat a které hodnoty jsou naprosto nesmyslné. Je však pravdou, že takovou
analýzu málokdo dělá a když při výpočtech ve <i>floatech</i> dochází
k&nbsp;chybám, tak se bez přemýšlení program přepíše na <i>doubly</i> a problém
se tak buď odstraní, nebo alespoň odsune na pozdější dobu, například do chvíle,
kdy jsou programu předložena reálná data a ne &bdquo;pouze&ldquo; data
testovací.</p>

<p><div class="rs-tip-major">Poznámka: a právě v&nbsp;tomto ohledu FX formáty
mnohdy narazily na své limity, například v&nbsp;oblasti renderingu (paměť
hloubky potřebuje velký dynamický rozsah) a právě v&nbsp;oblasti strojového
učení.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Uložení čísel ve formátu plovoucí řádové (binární) tečky</h2>

<p>Uložení racionálních čísel ve formátu plovoucí řádové tečky (FP formát) se
od FX formátu odlišuje především v&nbsp;tom, že si každá numerická hodnota sama
v&nbsp;sobě nese aktuální polohu řádové tečky. Z&nbsp;tohoto důvodu je kromě
bitů, které musí být rezervovány pro uložení významných číslic numerické
hodnoty, nutné pro každou numerickou hodnotu rezervovat i další bity,
v&nbsp;nichž je určena mocnina o nějakém základu (typicky 2, 8, 10 či 16),
kterou musí být významné číslice vynásobeny resp.&nbsp;vyděleny. První část
čísla uloženého v&nbsp;FP formátu se nazývá <strong>mantisa</strong>, druhá
část <strong>exponent</strong>. Obecný formát uložení a způsob získání
původního čísla je následující:</p>

<p><i>x<sub>FP</sub>=b<sup>e</sup>&times;m</i></p>

<p>kde:</p>

<ol>
<li><i>x<sub>FX</sub></i> značí reprezentovanou numerickou hodnotu z&nbsp;podmnožiny reálných čísel</li>
<li><i>b</i> je báze, někdy také nazývaná <i>radix</i></li>
<li><i>e</i> je hodnota exponentu (může být i záporná)</li>
<li><i>m</i> je mantisa, která může být i záporná</li>
</ol>

<p><div class="rs-tip-major">Poznámka: většinou požadujeme i práci se zápornými
hodnotami, proto se zavádí další bit <i>s</i> pro uložení znaménka. To
mj.&nbsp;znamená, že lze reprezentovat kladnou i zápornou nulu, což lze
považovat za výhodu.</div></p>

<p>Konkrétní formát numerických hodnot reprezentovaných v&nbsp;systému plovoucí
řádové tečky závisí především na volbě báze (<strong>radixu</strong>) a také na
počtu bitů rezervovaných pro uložení mantisy a exponentu. V&nbsp;minulosti
existovalo značné množství různých formátů plovoucí řádové tečky (vzpomíná si
někdo například na <strong>Turbo Pascal</strong> s&nbsp;jeho šestibajtovým
datovým typem <i>real</i>?), v&nbsp;relativně nedávné minulosti se však
ustálilo použití formátů specifikovaných v&nbsp;normě IEEE 754. Ovšem, jak
uvidíme dále, se ukazuje, že původní formáty definované v&nbsp;IEEE 754
nedostačují všem požadavkům, a to na obou stranách spektra (někdo požaduje
vyšší přesnost/rozsah, jiný zase rychlost výpočtů a malé paměťové nároky).
Proto došlo k&nbsp;rozšíření této normy o nové formáty a nezávisle na tom i na
vývoji formátu <strong>bfloat16</strong>.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Formát plovoucí řádové binární tečky a norma IEEE 754</h2>

<p>V&nbsp;oblasti FP formátů se dnes nejčastěji setkáme s&nbsp;výše zmíněnou
normou IEEE 754 popř.&nbsp;jejími rozšířenými variantami. Norma IEEE 754
specifikuje nejenom vlastní formát uložení numerických hodnot v&nbsp;systému
plovoucí řádové tečky, ale (a to je celkem neznámá skutečnost) i pravidla
implementace operací s&nbsp;těmito hodnotami, včetně konverzí. Konkrétně je
v&nbsp;této normě popsáno:</p>

<ol>
<li>Základní (<i>basic</i>) a rozšířený (<i>extended</i>) formát uložení numerických hodnot.</li>
<li>Způsob provádění základních matematických operací:
    <ul>
    <li>součet</li>
    <li>rozdíl</li>
    <li>součin</li>
    <li>podíl</li>
    <li>zbytek po dělení</li>
    <li>druhá odmocnina</li>
    <li>porovnání</li>
    </ul></li>
<li>Režimy zaokrouhlování.</li>
<li>Způsob práce s&nbsp;denormalizovanými hodnotami.</li>
<li>Pravidla konverze mezi celočíselnými formáty (<i>integer</i> bez a se znaménkem) a formáty s&nbsp;plovoucí řádovou čárkou.</li>
<li>Způsob konverze mezi různými formáty s&nbsp;plovoucí řádovou čárkou (<i>single</i> &rarr; <i>double</i> atd.).</li>
<li>Způsob konverze základního formátu s&nbsp;plovoucí řádovou čárkou na řetězec číslic (včetně nekonečen a nečíselných hodnot).</li>
<li>Práce s&nbsp;hodnotami NaN (<i>not a number</i>) a výjimkami, které mohou při výpočtech za určitých předpokladů vzniknout.</li>
</ol>

<a href="https://www.root.cz/obrazek/305587/"><img src="https://i.iinfo.cz/images/346/fp-number-chaos-2-1-prev.jpg" class="image-305587" alt="&#160;" width="370" height="134" /></a>
<p><i>Obrázek 2: První čip, který používal formát definovaný v&nbsp;IEEE 754
&ndash; Intel 8087.<br />
Zdroj: Wikipedia, Autor: Dirk Oppelt</i></p>

<p>V&nbsp;normě (přesněji řečeno v&nbsp;její rozšířené variantě IEEE 754-2008
resp.&nbsp;její poslední úpravě IEEE 754-2019) nalezneme mj.&nbsp;i tyto FP
formáty:</p>

<table>
<tr><th>Označení</th><th>Šířka (b)</th><th>Báze</th><th>Exponent (b)</th><th>Mantisa (b)</th></tr>
<tr><td>IEEE 754 half</td><td>16</td><td>2</td><td>5</td><td>10+1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>IEEE 754 single</td><td>32</td><td>2</td><td>8</td><td>23+1</td></tr>
<tr><td>IEEE 754 double</td><td>64</td><td>2</td><td>11</td><td>52+1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>IEEE 754 double extended</td><td>80</td><td>2</td><td>15</td><td>64</td></tr>
<tr><td>IEEE 754 quadruple</td><td>128</td><td>2</td><td>15</td><td>112+1</td></tr>
<tr><td>IEEE 754 octuple</td><td>256</td><td>2</td><td>19</td><td>236+1</td></tr>
</table>

<img src="http://i.iinfo.cz/images/21/pc157-1.jpg" alt=" " width="450" height="448" />
<p><i>Obrázek 3: Mikroprocesory Pentium i všechny další čipy řady 80x86 již
implicitně obsahují plnohodnotný FPU. Zlé jazyky tvrdí, že u první řady Pentií
byl FPU tak rychlý jen proto, že <a
href="https://en.wikipedia.org/wiki/Pentium_FDIV_bug">výsledky pouze
odhadoval</a> :-)</i></p>

<p>Typ <i>single</i> (nebo <i>float</i> popř.&nbsp;<i>float32</i>) vypadá
takto:</p>

<table>
<tr><th>bit</th><td>31</td><td>30 &nbsp; 29 ... 24 &nbsp; 23</td><td>22 &nbsp; 21 ... 3 &nbsp; 2 &nbsp; 1 &nbsp; 0</td></tr>
<tr><th>význam</th><td>s</td><td>exponent (8 bitů)</td><td>mantisa (23 bitů)</td></tr>
</table>

<p>Exponent je přitom posunutý o hodnotu <strong>bias</strong>, která je
nastavena na 127, protože je použit výše uvedený vztah:</p>

<p><i>bias=2<sup>eb-1</sup>-1</i></p>

<p>a po dosazení <i>eb=8 (bitů)</i> dostaneme:</p>

<p><i>bias=2<sup>8-1</sup>-1=2<sup>7</sup>-1=128-1=</i><strong>127</strong></p>

<p>Vzorec pro vyjádření reálné hodnoty vypadá následovně:</p>

<p><i>X<sub>single</sub>=(-1)<sup>s</sup>&nbsp;&times;&nbsp;2<sup>exp-127</sup>&nbsp;&times;&nbsp;m</i></p>

<p>Rozsah hodnot, které je možné reprezentovat ve formátu jednoduché přesnosti
v&nbsp;normalizovaném tvaru je -3,4&times;10<sup>38</sup> až
3,4&times;10<sup>38</sup>. Nejnižší reprezentovatelná (normalizovaná) hodnota
je rovna 1,17549&times;10<sup>-38</sup>, denormalizovaná pak
1,40129&times;10<sup>-45</sup>. Jak jsme k&nbsp;těmto hodnotám došli? Zkuste se
podívat na následující vztahy:</p>

<table>
<tr><th>hexadecimální hodnota</th><th>výpočet FP</th><th>dekadický výsledek</th><th>normalizováno</th></tr>
<tr><td>0x00000001</td><td>2<sup>-126</sup>&times;2<sup>-23</sup></td><td>1,40129&times;10<sup>-45</sup></td><td>ne</td></tr>
<tr><td>0x00800000</td><td>2<sup>-126</sup></td><td>1,17549&times;10<sup>-38</sup></td><td>ano</td></tr>
<tr><td>0x7F7FFFFF</td><td>(2-2<sup>-23</sup>)&times;2<sup>127</sup></td><td>3,4&times;10<sup>38</sup></td><td>ano</td></tr>
</table>

<p>Formát s&nbsp;dvojitou přesností (<strong>double</strong>), který je
definovaný taktéž normou IEEE 754, se v&nbsp;mnoha ohledech podobá formátu
s&nbsp;jednoduchou přesností (<strong>single</strong>), pouze se zdvojnásobil
celkový počet bitů, ve kterých je hodnota uložena, tj.&nbsp;místo 32 bitů se
používá 64 bitů:</p>

<table>
<tr><th>bit</th><td>63</td><td>62 ... 52</td><td>51 ... 0</td></tr>
<tr><th>význam</th><td>s</td><td>exponent (11 bitů)</td><td>mantisa (52 bitů)</td></tr>
</table>

<p>Exponent je v&nbsp;tomto případě posunutý o hodnotu
<strong>bias=2047</strong> a vzorec pro výpočet reálné hodnoty vypadá
takto:</p>

<p><i>X<sub>double</sub>=(-1)<sup>s</sup>&nbsp;&times;&nbsp;2<sup>exp-2047</sup>&nbsp;&times;&nbsp;m</i></p>

<p>Přičemž hodnotu mantisy je možné pro normalizované hodnoty získat pomocí
vztahu:</p>

<p><i>m=1+m<sub>51</sub><sup>-1</sup>+m<sub>50</sub><sup>-2</sup>+m<sub>49</sub><sup>-3</sup>+...+m<sub>0</sub><sup>-52</sup></i></p>

<p>(<i>m<sub>x</sub></i> představuje <i>x</i>-tý bit mantisy)</p>

<p>Rozsah hodnot ukládaných ve dvojité přesnosti je
-1,7&times;10<sup>308</sup>..1,7&times;10<sup>308</sup>, nejmenší možná
nenulová hodnota je rovna 2,2&times;10<sup>-308</sup>.</p>

<p>V&nbsp;novější normě IEEE 754-2008 je specifikován nepovinný formát nazvaný
<i>binary128</i>, který se ovšem běžně označuje <i>quadruple precision</i> či
jen <i>quad precision</i>. Tento formát je založen na slovech širokých 128 bitů
(16 bajtů), která jsou rozdělena takto:</p>

<table>
<tr><th>bit</th><td>127</td><td>126 ... 112</td><td>111 ... 0</td></tr>
<tr><th>význam</th><td>s</td><td>exponent (15 bitů)</td><td>mantisa (112 bitů)</td></tr>
</table>

<p>Exponent je v&nbsp;tomto případě posunutý o hodnotu
<strong>bias=16383</strong>. Dekadická přesnost u tohoto formátu dosahuje 34
cifer!</p>

<p>Jen krátce se zmiňme o poslední variantě FP formátu, který se nazývá
<i>binary256</i> či méně formálně <i>octuple precision</i>. Tento formát
využívá slova o šířce plných 256 bitů (32 bajtů) s&nbsp;následujícím
rozdělením:</p>

<table>
<tr><th>bit</th><td>255</td><td>254 ... 236</td><td>235 ... 0</td></tr>
<tr><th>význam</th><td>s</td><td>exponent (19 bitů)</td><td>mantisa (235 bitů)</td></tr>
</table>




<p><a name="k06"></a></p>
<h2 id="k06">6. Přednosti a zápory formátu plovoucí řádové tečky</h2>

<p>Vzhledem k&nbsp;tomu, že je FP formát v&nbsp;současnosti velmi rozšířený a používaný, musí nutně přinášet některé výhody, jinak by jeho rozšíření nebylo zdaleka tak velké. První předností je podpora FP operací díky hardwarovým FPU jednotkám, které jsou dostupné jak ve formě samostatného matematického koprocesoru (Intel 8087, Intel i80287, Intel i80387, Intel i80487, Motorola M68881, Motorola M68882), tak i jako přímá součást moderních mikroprocesorů (řada x86 od "plnohodnotných" mikroprocesorů i486, Motorola M68040, Power PC, některé typy mikrořadičů a signálových procesorů atd.). Další předností je existence normy IEEE 754, ve které je mimo jiné řečeno i to, že každá FPU jednotka by měla podporovat ideálně dva formáty, například <i>basic single</i> a <i>basic double</i>. To je velmi důležité, zejména pro přenos numerických údajů mezi různými zařízeními. Pro mnoho programátorů je také výhodné to, že jeden základní datový typ (například <i>float</i>) je možné použít pro reprezentaci mnoha objektů či vlastností (jak si však ukážeme v&nbsp;další části tohoto seriálu, ne vždy je tento předpoklad pravdivý). Všechny tyto skutečnosti vedly k&nbsp;tomu, že FP formát (či formáty) jsou v&nbsp;prakticky všech programovacích jazycích implementovány jako základní datové typy, což představuje velký náskok před FX formátem, který je podporován pouze několika málo jazyky a programovými knihovnami.</p>

<p>FP formát však má i některé zápory, které nás mohou v&nbsp;některých případech "donutit" k&nbsp;použití formátu FX. První nevýhoda vychází z&nbsp;velké komplexnosti vlastního formátu, tj.&nbsp;způsobu rozdělení údajů na mantisu a exponent. I taková základní matematická operace, jako je součet, je díky FP formátu poměrně složitá a výsledek nemusí vždy odpovídat intuitivnímu cítění programátora, který má tendenci FP formát pokládat za ekvivalent reálných čísel ("<strong>datový typ double je přesný...</strong>").  Mnoho programátorů se například chybně spoléhá na to, že i pouhý převod mezi typem <i>int</i> na <i>single/float</i> a zpět na <i>int</i> je bezeztrátový &ndash; pravý opak je pravdou a to vzhledem k&nbsp;tomu, že se ztratí hodnoty minimálně osmi nejnižších bitů, které musely být vyhrazeny pro uložení exponentu. FP formát, resp.&nbsp;formát specifikovaný normou IEEE 754, se nehodí pro práci s&nbsp;peněžními hodnotami; z&nbsp;tohoto důvodu se v&nbsp;některých vyšších programovacích jazycích zavádí speciální datový typ <i>decimal</i> resp.&nbsp;<i>currency</i>, určený speciálně pro peněžní hodnoty.</p>

<p>Další nedostatek FP formátu souvisí s&nbsp;jeho značnou komplexností.  Hardwarové jednotky FPU jsou velmi komplikované, což limituje použití FP operací v&nbsp;některých vestavných &ndash; <i>embedded</i> &ndash; zařízeních (těch je dnes řádově více než osobních počítačů), ale i v&nbsp;dnes oblíbených smartphonech atd. Tím neříkám, že některé mikroprocesory použité ve smartphonech FPU nemají, bylo by ale zajímavé zjistit, zda by ty statisíce logických hradel použitých na implementaci FPU nešly využít jiným způsobem. Dále se komplikuje a především zpomaluje převod mezi FP formáty a celočíselnými formáty dat (integer, long). Z&nbsp;tohoto důvodu jsou například mnohé signálové procesory zkonstruovány tak, aby podporovaly pouze FX aritmetiku, protože jak na vstupu signálového procesoru, tak i na jeho výstupu jsou prakticky vždy celočíselné hodnoty a pouze převody mezi vstupem, interní reprezentací a výstupem by byly mnohdy komplikovanější než implementace veškerých výpočtů v&nbsp;FX reprezentaci.</p>


int x = ...;
float f = ...;
double d = ...;

žádná není rovna NaN

<table>
<tr><th>Tvrzení</th><th>Je pravdivé?</th></tr>
<tr><td></td><td></td></tr>
</table>

x == (int)(float) x
x == (int)(double) x
f == (float)(double) f
d == (float) d
f == -(-f);
2/3 == 2/3.0
d < 0.0 ⇒ ((d*2) < 0.0)
d > f ⇒ -f > -d
d * d >= 0.0
(d+f)-d == f


primitive type Float16 <: AbstractFloat 16 end
primitive type Float32 <: AbstractFloat 32 end
primitive type Float64 <: AbstractFloat 64 end

primitive type Bool <: Integer 8 end
primitive type Char <: AbstractChar 32 end

primitive type Int8    <: Signed   8 end
primitive type UInt8   <: Unsigned 8 end
primitive type Int16   <: Signed   16 end
primitive type UInt16  <: Unsigned 16 end
primitive type Int32   <: Signed   32 end
primitive type UInt32  <: Unsigned 32 end
primitive type Int64   <: Signed   64 end
primitive type UInt64  <: Unsigned 64 end
primitive type Int128  <: Signed   128 end
primitive type UInt128 <: Unsigned 128 end


Format 	Significand 	Exponent
bfloat16 	8 bits 	8 bits
fp16 	11 bits 	5 bits
fp32 	24 bits 	8 bits

 	u 	xmins 	xmin 	xmax
bfloat16 	3.91e-03 	(*) 	1.18e-38 	3.39e+38
fp16 	4.88e-04 	5.96e-08 	6.10e-05 	6.55e+04
fp32 	5.96e-08 	1.40e-45 	1.18e-38 	3.40e+38


tiny FP


0..2 frac
3..6 exp
7 signum

Exp exp E 2 E
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
0000
0001
0010
0011
0100
0101
0110
0111
1000
1001
1010
1011
1100
1101
1110
1111
-6
-6
-5
-4
-3
-2
-1
0
+1
+2
+3
+4
+5
+6
+7
n/a 1/64
1/64
1/32
1/16
1/8
1/4
1/2
1
2
4
8
16
32
64
128
(denorms) - první řádka
(inf, NaN) - poslední řádka

<p><a name="k07"></a></p>
<h2 id="k07">7. Numpy</h2>

<table>
<tr><th>Formát</th><th>Popis</th><th>Rozsah</th></tr>
<tr><td>bool</td><td>uloženo po bajtech</td><td> True/False</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>int8</td><td>celočíselný se znaménkem</td><td>-128..127</td></tr>
<tr><td>int16</td><td>celočíselný se znaménkem</td><td>-32768..32767</td></tr>
<tr><td>int32</td><td>celočíselný se znaménkem</td><td>-2147483648..2147483647</td></tr>
<tr><td>int64</td><td>celočíselný se znaménkem</td><td>-9223372036854775808..9223372036854775807</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>uint8</td><td>celočíselný bez znaménka</td><td> 0..255</td></tr>
<tr><td>uint16</td><td>celočíselný bez znaménka</td><td> 0..65535</td></tr>
<tr><td>uint32</td><td>celočíselný bez znaménka</td><td> 0..4294967295</td></tr>
<tr><td>uint64</td><td>celočíselný bez znaménka</td><td> 0..18446744073709551615</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>float16</td><td>plovoucí řádová čárka</td><td> poloviční přesnost (half)</td></tr>
<tr><td>float32</td><td>plovoucí řádová čárka</td><td> jednoduchá přesnost (single)</td></tr>
<tr><td>float64</td><td>plovoucí řádová čárka</td><td> dvojitá přesnost (double)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>complex64 </td><td>komplexní číslo (dvojice)</td><td> 2×float32</td></tr>
<tr><td>complex128</td><td>komplexní číslo (dvojice)</td><td> 2×float64</td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Klasické matematické koprocesory</h2>

<table>
<tr><th>Dekadicky</th><th>Double (hexa)</th><th>Single (hexa)</th><th>Half (hexa)</th><th>Bfloat16 (hexa)</th></tr>
<tr><td></td><td></td><td></td><td></td><td></td></tr>
</table>
1000
0x408f400000000000
0x447a0000
0x63d0
0x447a

0.1
0x3fb999999999999a
0x3dcccccd
0x2e66
0x3dcd


<p><a name="k09"></a></p>
<h2 id="k09">9. Digitální signálové procesory</h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. Grafické akcelerátory a GPU</h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. Na scénu přichází formát <strong>bfloat16</strong></h2>

The world’s fastest supercomputer, SUMMIT at Oak Ridge National Lab, can perform 3.3 X 1018 operations in one seconds when half precision is used. However when a linear system of equations are solved on the same computer using the High Performance LINPACK benchmark it performs 122.3 X 1015 operations in one second, and note that here double precision floating point format is used. 



<p><a name="k12"></a></p>
<h2 id="k12">12. Vztah mezi formáty <strong>single</strong>, <strong>half</strong> a <strong>bfloat16</strong></h2>

memory!!!



<p><a name="k13"></a></p>
<h2 id="k13">13. Přednosti a zápory formátu <strong>bfloat16</strong></h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. Podpora formátu <strong>bfloat16</strong></h2>

<p>Samotný formát <strong>bfloat16</strong> je poměrně nový, takže si teprve postupně hledá cestu pro začlenění jak do samotného hardware (mikroprocesorů a GPU), tak i do širší množiny programovacích jazyků, knihoven a frameworků. Nejprve se zmiňme o hardwarové podpoře. Formát <strong>bfloat</strong> je již začleněn do nových &bdquo;AI procesorů&ldquo; společnosti Intel. Mezi ně patří například Nervana NNP-L1000 atd. Dále se s&nbsp;tímto typem setkáme u výkonných procesorů Xeon, protože do rozšíření instrukční sady AVX-512 byly přidány tři instrukce označované souhrnně <strong>AVX-512_BF16</strong>. Jedná se konkrétně o instrukce s&nbsp;nezapamatovatelnými názvy VCVTNE2PS2BF16, VCVTNEPS2BF16 a VDPBF16PS. Důležitější je pravděpodobně podpora v&nbsp;TPU (<i>tensor processing unit</i>) a tím pádem i v&nbsp;knihovně <i>TensorFlow</i>. To ovšem není vše, protože se <strong>bfloat</strong> objevuje/objeví i v&nbsp;čipech s&nbsp;architekturou ARMv8.6-A atd. </p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Programovací jazyk Julia</h2>




<p><a name="k16"></a></p>
<h2 id="k16">16. Python a knihovna NumPy</h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. Rozšíření do dalších programovacích jazyků</h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. </h2>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>bfloat16 - Hardware Numerics Definition<br />
<a href="https://software.intel.com/en-us/download/bfloat16-hardware-numerics-definition">https://software.intel.com/en-us/download/bfloat16-hardware-numerics-definition</a>
</li>

<li>Intel Prepares To Graft Google’s Bfloat16 Onto Processors<br />
<a href="https://www.nextplatform.com/2019/07/15/intel-prepares-to-graft-googles-bfloat16-onto-processors/">https://www.nextplatform.com/2019/07/15/intel-prepares-to-graft-googles-bfloat16-onto-processors/</a>
</li>

<li>A Study of BFLOAT16 for Deep Learning Training<br />
<a href="https://arxiv.org/pdf/1905.12322.pdf">https://arxiv.org/pdf/1905.12322.pdf</a>
</li>

<li>BFloat16s.jl<br />
<a href="https://github.com/JuliaComputing/BFloat16s.jl">https://github.com/JuliaComputing/BFloat16s.jl</a>
</li>

<li>Half Precision Arithmetic: fp16 Versus bfloat16<br />
<a href="https://nhigham.com/2018/12/03/half-precision-arithmetic-fp16-versus-bfloat16/">https://nhigham.com/2018/12/03/half-precision-arithmetic-fp16-versus-bfloat16/</a>
</li>

<li>bfloat16 floating-point format (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Bfloat16_floating-point_format">https://en.wikipedia.org/wiki/Bfloat16_floating-point_format</a>
</li>

<li>Unum (number format)<br />
<a href="https://en.wikipedia.org/wiki/Unum_(number_format)#Posit">https://en.wikipedia.org/wiki/Unum_(number_format)#Posit</a>
</li>

<li>Performance Benefits of Half Precision Floats<br />
<a href="https://software.intel.com/en-us/articles/performance-benefits-of-half-precision-floats">https://software.intel.com/en-us/articles/performance-benefits-of-half-precision-floats</a>
</li>

<li>Norma IEEE 754 a příbuzní: formáty plovoucí řádové tečky<br />
<a href="https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/">https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/</a>
</li>

<li>IEEE-754 Floating-Point Conversion<br />
<a href="http://babbage.cs.qc.cuny.edu/IEEE-754.old/32bit.html">http://babbage.cs.qc.cuny.edu/IEEE-754.old/32bit.html</a>
</li>

<li>Small Float Formats<br />
<a href="https://www.khronos.org/opengl/wiki/Small_Float_Formats">https://www.khronos.org/opengl/wiki/Small_Float_Formats</a>
</li>

<li>Binary-coded decimal<br />
<a href="https://en.wikipedia.org/wiki/Binary-coded_decimal">https://en.wikipedia.org/wiki/Binary-coded_decimal</a>
</li>

<li>Chen–Ho encoding<br />
<a href="https://en.wikipedia.org/wiki/Chen%E2%80%93Ho_encoding">https://en.wikipedia.org/wiki/Chen%E2%80%93Ho_encoding</a>
</li>

<li>Densely packed decimal<br />
<a href="https://en.wikipedia.org/wiki/Densely_packed_decimal">https://en.wikipedia.org/wiki/Densely_packed_decimal</a>
</li>

<li>A Summary of Chen-Ho Decimal Data encoding<br />
<a href="http://speleotrove.com/decimal/chen-ho.html">http://speleotrove.com/decimal/chen-ho.html</a>
</li>

<li>Art of Assembly language programming: The 80x87 Floating Point Coprocessors<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html</a>
</li>

<li>Art of Assembly language programming: The FPU Instruction Set<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html</a>
</li>

<li>INTEL 80387 PROGRAMMER'S REFERENCE MANUAL<br />
<a href="http://www.ragestorm.net/downloads/387intel.txt">http://www.ragestorm.net/downloads/387intel.txt</a>
</li>

<li>Floating-Point Formats<br />
<a href="http://www.quadibloc.com/comp/cp0201.htm">http://www.quadibloc.com/comp/cp0201.htm</a>
</li>

<li>Data types (SciPy)<br />
<a href="https://docs.scipy.org/doc/numpy-1.13.0/user/basics.types.html">https://docs.scipy.org/doc/numpy-1.13.0/user/basics.types.html</a>
</li>

<li>New 16-bit floating point type &ndash; NumPy 1.6.0 Release Notes<br />
<a href="https://github.com/numpy/numpy/blob/7cfec2403486456b52b525eccf7541e1562d9ab3/doc/release/1.6.0-notes.rst#new-16-bit-floating-point-type">https://github.com/numpy/numpy/blob/7cfec2403486456b52b525eccf7541e1562d9ab3/doc/release/1.6.0-notes.rst#new-16-bit-floating-point-type</a>
</li>

<li>RFC pro Rust<br />
<a href="https://github.com/joshtriplett/rfcs/blob/f16b/text/0000-f16b.md">https://github.com/joshtriplett/rfcs/blob/f16b/text/0000-f16b.md</a>
</li>

<li>IEEE-754 Floating Point Converter<br />
<a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">https://www.h-schmidt.net/FloatConverter/IEEE754.html</a>
</li>

<li>Mediump float calculator<br />
<a href="https://oletus.github.io/float16-simulator.js/">https://oletus.github.io/float16-simulator.js/</a>
</li>

<li>IEEE 754 Calculator<br />
<a href="http://weitz.de/ieee/">http://weitz.de/ieee/</a>
</li>

<li>BFloat16 (Swift for TensorFlow)<br />
<a href="https://www.tensorflow.org/swift/api_docs/Structs/BFloat16">https://www.tensorflow.org/swift/api_docs/Structs/BFloat16</a>
</li>

<li>Using bfloat16 with TensorFlow models<br />
<a href="https://cloud.google.com/tpu/docs/bfloat16">https://cloud.google.com/tpu/docs/bfloat16</a>
</li>

<li>What is tf.bfloat16 “truncated 16-bit floating point”?<br />
<a href="https://stackoverflow.com/questions/44873802/what-is-tf-bfloat16-truncated-16-bit-floating-point">https://stackoverflow.com/questions/44873802/what-is-tf-bfloat16-truncated-16-bit-floating-point</a>
</li>

<li>BFloat16 processing for Neural Networks on Armv8-A<br />
<a href="https://community.arm.com/developer/ip-products/processors/b/ml-ip-blog/posts/bfloat16-processing-for-neural-networks-on-armv8_2d00_a">https://community.arm.com/developer/ip-products/processors/b/ml-ip-blog/posts/bfloat16-processing-for-neural-networks-on-armv8_2d00_a</a>
</li>

<li>Mixed precision training<br />
<a href="https://arxiv.org/pdf/1710.03740.pdf">https://arxiv.org/pdf/1710.03740.pdf</a>
</li>

<li>[R] Mixed Precision Training<br />
<a href="https://www.reddit.com/r/MachineLearning/comments/75phd2/r_mixed_precision_training/">https://www.reddit.com/r/MachineLearning/comments/75phd2/r_mixed_precision_training/</a>
</li>

<li>Floating Point Numbers<br />
<a href="https://floating-point-gui.de/formats/fp/">https://floating-point-gui.de/formats/fp/</a>
</li>

<li>Float exposed<br />
<a href="https://float.exposed/0x40490000">https://float.exposed/0x40490000</a>
</li>

<li>Float Toy<br />
<a href="http://evanw.github.io/float-toy/">http://evanw.github.io/float-toy/</a>
</li>

<li>IEEE-754 visualization<br />
<a href="https://bartaz.github.io/ieee754-visualization/">https://bartaz.github.io/ieee754-visualization/</a>
</li>

<li>Advantages Of BFloat16 For AI Inference<br />
<a href="https://semiengineering.com/advantages-of-bfloat16-for-ai-inference/">https://semiengineering.com/advantages-of-bfloat16-for-ai-inference/</a>
</li>

<li>ARMv8-A bude podporovat nový formát čísel BFloat16<br />
<a href="https://www.root.cz/zpravicky/armv8-a-bude-podporovat-novy-format-cisle-bfloat16/">https://www.root.cz/zpravicky/armv8-a-bude-podporovat-novy-format-cisle-bfloat16/</a>
</li>

<li>Intel oznámil nový formát BFloat16 pro budoucí procesory<br />
<a href="https://www.root.cz/zpravicky/intel-oznamil-novy-format-bfloat16-pro-budouci-procesory/">https://www.root.cz/zpravicky/intel-oznamil-novy-format-bfloat16-pro-budouci-procesory/</a>
</li>

<li>Nový formát čísel Intelu BFloat16 bude v GCC 10 a Clang 9 <br />
<a href="https://www.root.cz/zpravicky/novy-format-cisel-intelu-bfloat16-bude-v-gcc-10-a-clang-9/">https://www.root.cz/zpravicky/novy-format-cisel-intelu-bfloat16-bude-v-gcc-10-a-clang-9/</a>
</li>

<li>Mixed precision<br />
<a href="https://www.tensorflow.org/guide/keras/mixed_precision">https://www.tensorflow.org/guide/keras/mixed_precision</a>
</li>

<li>Training Performance: A user’s guide to converge faster (TensorFlow Dev Summit 2018)<br />
<a href="https://www.youtube.com/watch?v=SxOsJPaxHME">https://www.youtube.com/watch?v=SxOsJPaxHME</a>
</li>

<li>Programování GPU na Raspberry Pi: použití Quad Processor Unit(s) <br />
<a href="https://www.root.cz/clanky/programovani-gpu-na-raspberry-pi-pouziti-quad-processor-unit-s/">https://www.root.cz/clanky/programovani-gpu-na-raspberry-pi-pouziti-quad-processor-unit-s/</a>
</li>

<li>“Half Precision” 16-bit Floating Point Arithmetic<br />
<a href="https://blogs.mathworks.com/cleve/2017/05/08/half-precision-16-bit-floating-point-arithmetic/">https://blogs.mathworks.com/cleve/2017/05/08/half-precision-16-bit-floating-point-arithmetic/</a>
</li>

<li>Half Precision Arithmetic in Numerical Linear Algebra<br />
<a href="https://nla-group.org/2018/10/03/half-precision-arithmetic-in-numerical-linear-algebra/">https://nla-group.org/2018/10/03/half-precision-arithmetic-in-numerical-linear-algebra/</a>
</li>

<li>Enable BF16 support<br />
<a href="https://gcc.gnu.org/ml/gcc-patches/2019-04/msg00477.html">https://gcc.gnu.org/ml/gcc-patches/2019-04/msg00477.html</a>
</li>

<li>Survey of Floating-Point Formats<br />
<a href="https://mrob.com/pub/math/floatformats.html">https://mrob.com/pub/math/floatformats.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2020</small></p>
</body>
</html>

