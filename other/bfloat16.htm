<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Brain Floating Point &ndash; nový formát uložení čísel pro strojové učení i chytrá čidla</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Brain Floating Point &ndash; nový formát uložení čísel pro strojové učení a chytrá čidla</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Přibližně před dvěma roky se do povědomí programátorů, kteří se zabývají strojovým učením popř. práci s takzvanými chytrými čidly, dostal nový formát reprezentace numerických hodnot s plovoucí řádovou čárkou. Ten se jmenuje Brain Floating Point resp. zkráceně bfloat16. Dnes si tento formát popíšeme v kontextu dalších FP formátů.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Brain Floating Point &ndash; nový formát uložení čísel pro strojové učení i chytrá čidla</a></p>
<p><a href="#k02">2. Časté způsoby reprezentace numerických hodnot ve formátu pevné a plovoucí řádové (binární) tečky</a></p>
<p><a href="#k03">3. Uložení numerických hodnot ve formátu pevné řádové binární tečky</a></p>
<p><a href="#k04">4. Uložení čísel ve formátu plovoucí řádové (binární) tečky</a></p>
<p><a href="#k05">5. Formát plovoucí řádové binární tečky a norma IEEE 754</a></p>
<p><a href="#k06">6. Přednosti a zápory formátu plovoucí řádové tečky</a></p>
<p><a href="#k07">7. Datový formát half (half float, half-precision floating-point) a další FP formáty s&nbsp;nižším počtem bitů</a></p>
<p><a href="#k08">8. Podpora datového typu half</a></p>
<p><a href="#k09">9. Knihovna NumPy</a></p>
<p><a href="#k10">10. Programovací jazyk Julia</a></p>
<p><a href="#k11">11. Proč používat typ half float?</a></p>
<p><a href="#k12">*** 12. Vlastnosti typu half float</a></p>
<p><a href="#k13">*** 13. Na scénu přichází formát <strong>bfloat16</strong></a></p>
<p><a href="#k14">*** 14. Vztah mezi formáty <strong>single</strong>, <strong>half</strong> a <strong>bfloat16</strong></a></p>
<p><a href="#k15">*** 15. Přednosti a zápory formátu <strong>bfloat16</strong></a></p>
<p><a href="#k16">*** 16. Podpora formátu <strong>bfloat16</strong></a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. </a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Brain Floating Point &ndash; nový formát uložení čísel pro strojové učení i chytrá čidla</h2>

<p>Přibližně od první poloviny roku 2018 se můžeme jak v&nbsp;různých článcích
zabývajících se tématem strojového učení, tak i v&nbsp;některých knihovnách a
frameworcích pro ML (<i>Machine Learning</i>) i AI (<i>Artifical
Intelligence</i>) setkat s&nbsp;numerickým formátem označeným
<strong>bfloat16</strong> neboli plným jménem <i>Brain Floating Point</i>.
Jedná se o jednu z&nbsp;několika používaných variant &bdquo;zkrácených&ldquo;
numerických formátů s&nbsp;plovoucí řádovou čárkou (někdy se setkáme se
souhrnným označením <i>half float</i>, což ovšem není zcela přesné). Numerická
hodnota uložená ve formátu <strong>bfloat16</strong> zabere v&nbsp;operační
paměti či v&nbsp;registru CPU nebo GPU pouhé dva bajty, což může znít minimálně
zvláštně v&nbsp;dnešní době, kdy se používají nejenom již poměrně dlouho
zavedené typy <i>single</i> (32 bitů) a <i>double</i> (64 bitů), ale navíc i (i
když nutno říci, že méně často) formáty <i>quadruple</i> (128 bitů) a dokonce i
<i>octuple</i> (256 bitů). Důvodů, proč se prosazuje právě formát
<strong>bfloat16</strong> je více. Zejména za to může fakt, že se
v&nbsp;oblasti strojového učení používají GPU, jejichž výpočetní výkon spojené
s&nbsp; masivní paralelizací výpočtů (a hluboké pipeliny) v&nbsp;důsledku vedou
k&nbsp;tomu, že se úzkým hrdlem opět stává rychlost resp.&nbsp;spíše pomalost
operační paměti. A poloviční bitová šířka numerických hodnot používaných
například při tréninku neuronových sítí mnohdy může vést k&nbsp;mnohonásobnému
urychlení celého procesu.</p>

<p>Nejdříve se ovšem zmiňme o tom, že přestože dnes v&nbsp;mnoha aplikačních
oblastech převažuje uložení numerických hodnot v&nbsp;nějakém formátu plovoucí
řádové čárky (či tečky &ndash; podle konkrétních místních pravidel zápisu),
můžeme se setkat i s&nbsp;formátem, v&nbsp;němž je řádová čárka/tečka pevně
umístěna na určité binární pozici, což mj.&nbsp;znamená, že se její konkrétní
pozice (významem odpovídající exponentu) nemusí explicitně ukládat.
S&nbsp;takovými formáty se setkáme v&nbsp;oblasti mikrořadičů, digitálních
signálových procesorů (DSP) i programovatelných obvodů FPGA. Výhodou je
mj.&nbsp;fakt, že si programátor sám určí požadovaný rozsah hodnot i přesnost,
a to na základě analýzy řešeného problému. Aritmetické operace jsou posléze
prováděny klasickou aritmeticko-logickou jednotkou (ALU), přičemž součet,
rozdíl i porovnání jsou shodné s&nbsp;celými čísly a u součinu a podílu je
nutné provádět bitové posuny (což mnohé DSP mohou provádět automaticky
v&nbsp;rámci jediné strojové instrukce).</p>

<p><div class="rs-tip-major">Poznámka: extrémním případem jsou celá čísla
(<i>integer</i>), u nichž je řádová čárka umístěna přesně za poslední cifru
s&nbsp;nejnižší váhou. V&nbsp;tomto případě se posuny po násobení a dělení
pochopitelně neprovádí, protože se jedná o posuny o nula bitů.</div></p>

<p>V&nbsp;anglické literatuře se zmíněná forma reprezentace číselných hodnot
označuje zkratkou <strong>FX</strong> nebo (i když asi méně často)
<strong>FXP</strong> (<i><strong>f</strong>i<strong>x</strong>ed
<strong>p</strong>oint</i>), zatímco dnes častěji používaná reprezentace
v&nbsp;systému plovoucí řádové tečky se všeobecně označuje zkratkou
<strong>FP</strong> (<i>floating point</i>). V&nbsp;jednom článku jsem dokonce
místo zkratky <strong>FX</strong> viděl i zkratku <strong>XP</strong>
(<i>fi<strong>x</strong>ed <strong>p</strong>oint</i>), ale to bylo před mnoha
lety, v&nbsp;době dnes již muzeálních Windows 95 :-). Nejprve si vysvětlíme
princip obou metod použitých pro ukládání podmnožiny racionálních čísel a
posléze si také řekneme, jaké výhody a nevýhody jednotlivé principy přináší
v&nbsp;každodenní programátorské praxi a ve kterých situacích je vhodnější
použít pevnou řádovou čárku. V&nbsp;dalším textu budeme formát pevné binární
řádové tečky zkracovat na <strong>FX formát</strong> a formát používající
plovoucí řádovou tečku budeme zapisovat jako <strong>FP formát</strong>.</p>

<p><div class="rs-tip-major">Poznámka pro úplnost: některé programovací jazyky,
typicky jazyky z&nbsp;LISPovské větve, podporují i typ <i>rational</i>,
v&nbsp;němž je hodnota reprezentována zlomkem dvou celých čísel. Na současném
HW se výpočty s&nbsp;tímto datovým typem provádí softwarově &ndash; jinými
slovy nejsou přímo podporovány ani v&nbsp;ALU ani ve FPU.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Časté způsoby reprezentace numerických hodnot ve formátu pevné a plovoucí řádové (binární) tečky</h2>

<p>Při ukládání číselných hodnot do operační paměti počítače poměrně záhy
narazíme na některé problémy, z&nbsp;nichž některé souvisí s&nbsp;konečným
počtem bitů, které pro uložení dané hodnoty &bdquo;obětujeme&ldquo; a další
vycházejí ze způsobu zpracování numerických hodnot mikroprocesorem či
matematickým koprocesorem. V&nbsp;konečném počtu bitů je totiž možné uložit
pouze <strong>konečné</strong> množství různých hodnot (pro <i>n</i> bitů
maximálně <i>2<sup>n</sup></i> hodnot, i když u mnohých formátů je to méně) a
je plně v&nbsp;rukou programátora a návrháře HW, jak efektivně daný počet bitů
využije či naopak promrhá ukládáním nepodstatných informací. Poměrně často se
totiž stává, že i program využívající dvojitou či dokonce rozšířenou přesnost
čísel při <strong>FP</strong> operacích (tj.&nbsp;datové typy <i>double</i> a
<i>extended/temporary</i>) dává nesprávné výsledky dané nepochopením principu
práce <strong>FP</strong> aritmetiky a přitom je možné se přesnějších výsledků
dobrat i při použití pouhých 32 bitů či dokonce šestnácti bitů, ale
s&nbsp;pečlivě vyváženými aritmetickými a bitovými operacemi.</p>

<p>Na druhou stranu nejsou dnes používané mikroprocesory tak univerzálními
zařízeními, jak by se na první pohled mohlo zdát. Mikroprocesory jsou totiž
(většinou) navrženy tak, aby účinně, například v&nbsp;rámci jedné operace či
instrukce, zpracovávaly pouze konstantní počet bitů. Příkladem mohou být dnes
velmi rozšířené procesory řady x86 a x86-64, které jsou velmi dobré při práci
s&nbsp;32bitovými resp.&nbsp;64bitovými hodnotami, ale při požadavku na
aritmetické výpočty probíhající na (řekněme) 21 bitech se veškerá jejich
efektivita ztrácí a procesor se širokými vnitřními sběrnicemi, matematickým
koprocesorem atd. se potýká s&nbsp;prohazováním jednotlivých bitů. Podobně
mnohé DSP dokážou velmi efektivně provádět výpočty s&nbsp;operandy o šířce 24
bitů, ovšem operace s&nbsp;jinými typy operandů nejsou prakticky podporovány
vůbec. Mnohem lepší situace nastane v&nbsp;případě, že se nějaká operace
implementuje na programovatelném poli FPGA &ndash; zde je možné vytvořit obvody
provádějící matematické a logické operace s&nbsp;libovolným počtem bitů, čímž
se oproti univerzálním řešením (např.&nbsp;konstantní bitová šířka sběrnice
a/nebo registrů) ušetří mnoho plochy těchto velmi zajímavých obvodů (FPGA mohou
mimochodem znamenat i velkou šanci pro hnutí open source &ndash; pomocí nich by
mohlo vznikat, a někde už vzniká <strong>open hardware</strong>, které by mohlo
odstranit závislost na &bdquo;uzavřených&ldquo; síťových a grafických kartách
apod.).</p>

<p>Vraťme se však ke způsobům reprezentace číselných hodnot v&nbsp;operační
paměti. Nejprve předpokládejme, že pro reprezentaci vlastností určitého objektu
či stavu z&nbsp;reálného světa použijeme <i>N</i> binárních číslic (bitů),
tj.&nbsp;základních jednotek informace, která může nabývat pouze jedné ze dvou
povolených hodnot (ty se značí například symboly <i>yes/no</i> nebo
<i>true</i>/<i>false</i>, ale my se budeme spíše držet označení <i>0</i> a
<i>1</i>). Pomocí této uspořádané <i>N</i>-tice je možné popsat celkem:</p>

<p><i>2<sub>0</sub>&times;2<sub>1</sub>&times;2<sub>2</sub> ... 2<sub>N-1</sub>=2<sup>N</sup></i></p>

<p>jednoznačných, tj.&nbsp;navzájem odlišných, stavů. Množina těchto stavů může
reprezentovat prakticky jakýkoliv abstraktní či reálný objekt. Přitom si musíme
uvědomit, že u této množiny není implicitně řečeno ani myšleno, že se jedná
například o celá kladná čísla, to je pouze jedna z&nbsp;mnoha možných
interpretací zvolené <i>N</i>-tice (my programátoři máme tendenci považovat
celá kladná čísla za přirozenou interpretaci bitové <i>N</i>-tice, to však
vychází pouze z&nbsp;našeho pohledu na svět a z&nbsp;našich zkušeností).
Reprezentaci momentálního stavu abstraktního či reálného objektu si můžeme
představit jako zobrazení z&nbsp;množiny binárních stavů na elementy vzorové (a
obecně neuspořádané) množiny. Nejčastěji používanými zobrazeními jsou zobrazení
množiny binárních stavů na interval celých kladných čísel (<i>Unsigned
Integers</i>), popřípadě na interval celých čísel (<i>Signed Integers</i>).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Uložení numerických hodnot ve formátu pevné řádové binární tečky</h2>

<p>Numerické hodnoty zapsané ve&nbsp;formátu <i>pevné řádové binární tečky</i>
se chápou jako podmnožina racionálních čísel, což jsou taková čísla, jejichž
hodnoty lze vyjádřit vztahem:</p>

<p><i>x<sub>FX</sub>=a/b &nbsp;&nbsp; a,b leží v Z, b &ne; 0</i></p>

<p>Číselné hodnoty z&nbsp;uvažované podmnožiny jsou navíc omezeny
podmínkou:</p>

<p><i>b=2<sup>k</sup> &nbsp;&nbsp; b leží v Z, k leží v Z<sup>+</sup></i></p>

<p>Protože <i>b</i> je celočíselnou mocninou dvojky (a ne desítky či jiného
základu), určuje jeho hodnota <i>n</i> polohu <i>binární tečky</i>
v&nbsp;uloženém čísle. Další podmínkou, která má však spíše implementační
charakter, je zachování stejného počtu binárních cifer v&nbsp;každém
reprezentovaném čísle, což mimo jiné znamená, že všechna čísla mají řádovou
binární tečku umístěnou na stejném místě &ndash; z&nbsp;této podmínky ostatně
plyne i název popisovaného způsobu reprezentace vybrané podmnožiny racionálních
čísel. Tak jako i v&nbsp;jiných reprezentacích čísel, jsou nulové číslice před
první nenulovou cifrou a za poslední nenulovou cifrou nevýznamné, proto je není
zapotřebí uvádět.</p>

<p>Prakticky může být číselná hodnota v&nbsp;systému pevné řádové tečky uložena
na osmi bitech například následujícím způsobem (uvažujeme pouze kladné
hodnoty):</p>

<table>
<tr><td>Pozice bitu</td><td>8&nbsp;&nbsp;&nbsp;&nbsp;</td><td>7&nbsp;&nbsp;&nbsp;&nbsp;</td><td>6&nbsp;&nbsp;&nbsp;&nbsp;</td><td>5&nbsp;&nbsp;&nbsp;&nbsp;</td><td>4&nbsp;&nbsp;&nbsp;&nbsp;</td><td>3&nbsp;&nbsp;&nbsp;&nbsp;</td><td>2&nbsp;&nbsp;&nbsp;&nbsp;</td><td>1&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td>Váha bitu</td><td>2<sup>4</sup></td><td>2<sup>3</sup></td><td>2<sup>2</sup></td><td>2<sup>1</sup></td><td>2<sup>0</sup></td><td>2<sup>-1</sup></td><td>2<sup>-2</sup></td><td>2<sup>-3</sup></td></tr>
<tr><td>Desítková váha bitu</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td><td>0,5</td><td>0,25</td><td>0,125</td></tr>
</table>

<p>Ve výše uvedeném příkladu je binární řádová tečka umístěna vždy mezi třetím
a čtvrtým bitem. Vzhledem k&nbsp;tomu, že je tato skutečnost dopředu známá
algoritmu, který provádí zpracování čísel (základní aritmetické operace), není
zapotřebí spolu s&nbsp;číslem uchovávat i pozici binární tečky, což výrazně
snižuje počet bitů, které je zapotřebí rezervovat pro čísla ze zadaného
rozsahu. To je tedy první přednost systému pevné řádové tečky &ndash; pokud
programátor dopředu zná rozsah všech zpracovávaných hodnot a požadovanou
přesnost, může být výhodné tento systém použít. Programátor také díky
explicitním určení polohy řádové tečky může určit, ve kterém místě programu se
musí přesnost či rozsah zvýšit a kdy naopak snížit. Lépe se tak využije počet
bitů, které můžeme pro uložení jednoho čísla obětovat (typicky je tento počet
bitů roven délce slova mikroprocesoru, popř.&nbsp;jeho celočíselnému násobku či
naopak podílu).</p>

<p>Dále je možné základní matematické operace (sčítání, odčítání, násobení a
dělení) poměrně jednoduše implementovat i při použití formátu pevné řádové
tečky. V&nbsp;případě, že není k&nbsp;dispozici specializovaný (a současně
velmi komplikovaný) matematický koprocesor, je mnohdy mnohem jednodušší a
rychlejší implementovat matematické operace v&nbsp;FX formátu. To je případ
mnoha jednočipových mikroprocesorů (mikrořadičů), signálových procesorů, ale i
specializovaných zařízení obsahujících programovatelné obvody CPLD či FPGA.
Dnes sice mají komplikovanější (a dražší) FPGA implementovanou i jednotku FPU,
ale mnohdy je výhodnější použít FPGA bez této jednotky a potřebné operace si do
tohoto obvodu &bdquo;vypálit&ldquo; po svém.</p>

<p><div class="rs-tip-major">Poznámka: typickým příkladem DSP navrženým pro FX
aritmetiku je revoluční čip <i>TMS32010</i>, jenž jsme si popsali
v&nbsp;článcích <a
href="https://www.root.cz/clanky/digitalni-signalove-procesory-rady-tms320/">Digitální
signálové procesory řady TMS320</a> a <a
href="https://www.root.cz/clanky/instrukcni-sada-digitalnich-signalovych-procesoru-rady-tms320/">Instrukční
sada digitálních signálových procesorů řady TMS320</a>.</div></p>

<img src="https://i.iinfo.cz/images/257/tms320-1.png" class="image-275138" alt="" width="550" height="806">
<p><i>Obrázek 1: Interní bloky DSP TMS32010, z&nbsp;nichž je patrné, že se
násobení a posun dají provádět velmi efektivně (ostatně tento DSP vlastně není
nic jiného, než podpůrné obvody postavené okolo rychlé násobičky).</i></p>

<p>Třetí výhodou je fakt, že u FX formátu může programátor navrhnout a posléze
také dodržet požadovanou přesnost všech prováděných výpočtů. To je velký rozdíl
oproti FP formátu (resp.&nbsp;jeho podmnožinám, které se nejčastěji používají).
Není vzácností narazit na programy, které používají datové typy <i>float</i> či
<i>double</i> a přitom jsou výpočty prováděné v&nbsp;těchto programech zatíženy
velkou chybou, protože si programátoři plně neuvědomují některé limity FP
formátu (příklady si ukážeme níže). Zcela kritické jsou například výpočty
s&nbsp;peněžními hodnotami, ale i pouhé sčítání čísel, jež se od sebe o mnoho
řádů liší, vede k&nbsp;velkým chybám, které dokonce mohou zapříčinit vznik
nekonečných smyček, populární dělení nulou atd.</p>

<p>FX formát má však i mnohé nevýhody. První nevýhoda spočívá v&nbsp;tom, že
tento formát není příliš podporován, a to ani po programové stránce (podpora
v&nbsp;programovacích jazycích), ani výrobci mikroprocesorů pro počítače PC.
Situace je však odlišná v&nbsp;oblasti jednočipových mikropočítačů, signálových
procesorů (DSP), řídicích systémů, nebo například u IBM RS 6000, který kromě
jednotky FPU obsahuje i FXU &ndash; jednotku pro provádění výpočtů v&nbsp;pevné
řádové binární čárce. Na platformě x86 je možné pro FX formát použít instrukce
<strong>MMX</strong> a <strong>SSE-2</strong> (na rozdíl od původního SSE či
AVX orientovaných na typy <i>single</i> a <i>double</i>).</p>

<p>Dále může být použití FX formátu nevýhodné v&nbsp;případě, že se mají
zpracovávat numerické hodnoty, které mají velký dynamický rozsah,
tj.&nbsp;poměr mezi nejvyšší a nejnižší absolutní hodnotou. V&nbsp;takovém
případě by se mohlo stát, že by se při použití FX formátu muselo pro každé
číslo alokovat velké množství bitů, které by mohlo dokonce překročit počet bitů
nutných pro FP formát. Také v&nbsp;případě, kdy dopředu nevíme, jaké hodnoty se
budou zpracovávat, může být výhodnější použití FP formátu. Zde se však nabízí
otázka, ve kterých případech nevíme, jaké hodnoty můžeme na vstupu získat:
většinou je již z&nbsp;podstaty úlohy dopředu známé, s&nbsp;čím je možné
počítat a které hodnoty jsou naprosto nesmyslné. Je však pravdou, že takovou
analýzu málokdo dělá a když při výpočtech ve <i>floatech</i> dochází
k&nbsp;chybám, tak se bez přemýšlení program přepíše na <i>doubly</i> a problém
se tak buď odstraní, nebo alespoň odsune na pozdější dobu, například do chvíle,
kdy jsou programu předložena reálná data a ne &bdquo;pouze&ldquo; data
testovací.</p>

<p><div class="rs-tip-major">Poznámka: a právě v&nbsp;tomto ohledu FX formáty
mnohdy narazily na své limity, například v&nbsp;oblasti renderingu (paměť
hloubky potřebuje velký dynamický rozsah) a právě v&nbsp;oblasti strojového
učení.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Uložení čísel ve formátu plovoucí řádové (binární) tečky</h2>

<p>Uložení racionálních čísel ve formátu plovoucí řádové tečky (FP formát) se
od FX formátu odlišuje především v&nbsp;tom, že si každá numerická hodnota sama
v&nbsp;sobě nese aktuální polohu řádové tečky. Z&nbsp;tohoto důvodu je kromě
bitů, které musí být rezervovány pro uložení významných číslic numerické
hodnoty, nutné pro každou numerickou hodnotu rezervovat i další bity,
v&nbsp;nichž je určena mocnina o nějakém základu (typicky 2, 8, 10 či 16),
kterou musí být významné číslice vynásobeny resp.&nbsp;vyděleny. První část
čísla uloženého v&nbsp;FP formátu se nazývá <strong>mantisa</strong>, druhá
část <strong>exponent</strong>. Obecný formát uložení a způsob získání
původního čísla je následující:</p>

<p><i>x<sub>FP</sub>=b<sup>e</sup>&times;m</i></p>

<p>kde:</p>

<ol>
<li><i>x<sub>FX</sub></i> značí reprezentovanou numerickou hodnotu z&nbsp;podmnožiny reálných čísel</li>
<li><i>b</i> je báze, někdy také nazývaná <i>radix</i></li>
<li><i>e</i> je hodnota exponentu (může být i záporná)</li>
<li><i>m</i> je mantisa, která může být i záporná</li>
</ol>

<p><div class="rs-tip-major">Poznámka: většinou požadujeme i práci se zápornými
hodnotami, proto se zavádí další bit <i>s</i> pro uložení znaménka. To
mj.&nbsp;znamená, že lze reprezentovat kladnou i zápornou nulu, což lze
považovat za výhodu.</div></p>

<p>Konkrétní formát numerických hodnot reprezentovaných v&nbsp;systému plovoucí
řádové tečky závisí především na volbě báze (<strong>radixu</strong>) a také na
počtu bitů rezervovaných pro uložení mantisy a exponentu. V&nbsp;minulosti
existovalo značné množství různých formátů plovoucí řádové tečky (vzpomíná si
někdo například na <strong>Turbo Pascal</strong> s&nbsp;jeho šestibajtovým
datovým typem <i>real</i>?), v&nbsp;relativně nedávné minulosti se však
ustálilo použití formátů specifikovaných v&nbsp;normě IEEE 754. Ovšem, jak
uvidíme dále, se ukazuje, že původní formáty definované v&nbsp;IEEE 754
nedostačují všem požadavkům, a to na obou stranách spektra (někdo požaduje
vyšší přesnost/rozsah, jiný zase rychlost výpočtů a malé paměťové nároky).
Proto došlo k&nbsp;rozšíření této normy o nové formáty a nezávisle na tom i na
vývoji formátu <strong>bfloat16</strong>.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Formát plovoucí řádové binární tečky a norma IEEE 754</h2>

<p>V&nbsp;oblasti FP formátů se dnes nejčastěji setkáme s&nbsp;výše zmíněnou
normou IEEE 754 popř.&nbsp;jejími rozšířenými variantami. Norma IEEE 754
specifikuje nejenom vlastní formát uložení numerických hodnot v&nbsp;systému
plovoucí řádové tečky, ale (a to je celkem neznámá skutečnost) i pravidla
implementace operací s&nbsp;těmito hodnotami, včetně konverzí. Konkrétně je
v&nbsp;této normě popsáno:</p>

<ol>
<li>Základní (<i>basic</i>) a rozšířený (<i>extended</i>) formát uložení numerických hodnot.</li>
<li>Způsob provádění základních matematických operací:
    <ul>
    <li>součet</li>
    <li>rozdíl</li>
    <li>součin</li>
    <li>podíl</li>
    <li>zbytek po dělení</li>
    <li>druhá odmocnina</li>
    <li>porovnání</li>
    </ul></li>
<li>Režimy zaokrouhlování.</li>
<li>Způsob práce s&nbsp;denormalizovanými hodnotami.</li>
<li>Pravidla konverze mezi celočíselnými formáty (<i>integer</i> bez a se znaménkem) a formáty s&nbsp;plovoucí řádovou čárkou.</li>
<li>Způsob konverze mezi různými formáty s&nbsp;plovoucí řádovou čárkou (<i>single</i> &rarr; <i>double</i> atd.).</li>
<li>Způsob konverze základního formátu s&nbsp;plovoucí řádovou čárkou na řetězec číslic (včetně nekonečen a nečíselných hodnot).</li>
<li>Práce s&nbsp;hodnotami NaN (<i>not a number</i>) a výjimkami, které mohou při výpočtech za určitých předpokladů vzniknout.</li>
</ol>

<a href="https://www.root.cz/obrazek/305587/"><img src="https://i.iinfo.cz/images/346/fp-number-chaos-2-1-prev.jpg" class="image-305587" alt="&#160;" width="370" height="134" /></a>
<p><i>Obrázek 2: První čip, který používal formát definovaný v&nbsp;IEEE 754
&ndash; Intel 8087.<br />
Zdroj: Wikipedia, Autor: Dirk Oppelt</i></p>

<p>V&nbsp;normě (přesněji řečeno v&nbsp;její rozšířené variantě IEEE 754-2008
resp.&nbsp;její poslední úpravě IEEE 754-2019) nalezneme mj.&nbsp;i tyto FP
formáty:</p>

<table>
<tr><th>Označení</th><th>Šířka (b)</th><th>Báze</th><th>Exponent (b)</th><th>Mantisa (b)</th></tr>
<tr><td>IEEE 754 half</td><td>16</td><td>2</td><td>5</td><td>10+1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>IEEE 754 single</td><td>32</td><td>2</td><td>8</td><td>23+1</td></tr>
<tr><td>IEEE 754 double</td><td>64</td><td>2</td><td>11</td><td>52+1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>IEEE 754 double extended</td><td>80</td><td>2</td><td>15</td><td>64</td></tr>
<tr><td>IEEE 754 quadruple</td><td>128</td><td>2</td><td>15</td><td>112+1</td></tr>
<tr><td>IEEE 754 octuple</td><td>256</td><td>2</td><td>19</td><td>236+1</td></tr>
</table>

<img src="http://i.iinfo.cz/images/21/pc157-1.jpg" alt=" " width="450" height="448" />
<p><i>Obrázek 3: Mikroprocesory Pentium i všechny další čipy řady 80x86 již
implicitně obsahují plnohodnotný FPU. Zlé jazyky tvrdí, že u první řady Pentií
byl FPU tak rychlý jen proto, že <a
href="https://en.wikipedia.org/wiki/Pentium_FDIV_bug">výsledky pouze
odhadoval</a> :-)</i></p>

<p>Typ <i>single</i> (nebo <i>float</i> popř.&nbsp;<i>float32</i>) vypadá
takto:</p>

<table>
<tr><th>bit</th><td>31</td><td>30 &nbsp; 29 ... 24 &nbsp; 23</td><td>22 &nbsp; 21 ... 3 &nbsp; 2 &nbsp; 1 &nbsp; 0</td></tr>
<tr><th>význam</th><td>s</td><td>exponent (8 bitů)</td><td>mantisa (23 bitů)</td></tr>
</table>

<p>Exponent je přitom posunutý o hodnotu <strong>bias</strong>, která je
nastavena na 127, protože je použit výše uvedený vztah:</p>

<p><i>bias=2<sup>eb-1</sup>-1</i></p>

<p>a po dosazení <i>eb=8 (bitů)</i> dostaneme:</p>

<p><i>bias=2<sup>8-1</sup>-1=2<sup>7</sup>-1=128-1=</i><strong>127</strong></p>

<p>Vzorec pro vyjádření reálné hodnoty vypadá následovně:</p>

<p><i>X<sub>single</sub>=(-1)<sup>s</sup>&nbsp;&times;&nbsp;2<sup>exp-127</sup>&nbsp;&times;&nbsp;m</i></p>

<p>Rozsah hodnot, které je možné reprezentovat ve formátu jednoduché přesnosti
v&nbsp;normalizovaném tvaru je -3,4&times;10<sup>38</sup> až
3,4&times;10<sup>38</sup>. Nejnižší reprezentovatelná (normalizovaná) hodnota
je rovna 1,17549&times;10<sup>-38</sup>, denormalizovaná pak
1,40129&times;10<sup>-45</sup>. Jak jsme k&nbsp;těmto hodnotám došli? Zkuste se
podívat na následující vztahy:</p>

<table>
<tr><th>hexadecimální hodnota</th><th>výpočet FP</th><th>dekadický výsledek</th><th>normalizováno</th></tr>
<tr><td>0x00000001</td><td>2<sup>-126</sup>&times;2<sup>-23</sup></td><td>1,40129&times;10<sup>-45</sup></td><td>ne</td></tr>
<tr><td>0x00800000</td><td>2<sup>-126</sup></td><td>1,17549&times;10<sup>-38</sup></td><td>ano</td></tr>
<tr><td>0x7F7FFFFF</td><td>(2-2<sup>-23</sup>)&times;2<sup>127</sup></td><td>3,4&times;10<sup>38</sup></td><td>ano</td></tr>
</table>

<p>Formát s&nbsp;dvojitou přesností (<strong>double</strong>), který je
definovaný taktéž normou IEEE 754, se v&nbsp;mnoha ohledech podobá formátu
s&nbsp;jednoduchou přesností (<strong>single</strong>), pouze se zdvojnásobil
celkový počet bitů, ve kterých je hodnota uložena, tj.&nbsp;místo 32 bitů se
používá 64 bitů:</p>

<table>
<tr><th>bit</th><td>63</td><td>62 ... 52</td><td>51 ... 0</td></tr>
<tr><th>význam</th><td>s</td><td>exponent (11 bitů)</td><td>mantisa (52 bitů)</td></tr>
</table>

<p>Exponent je v&nbsp;tomto případě posunutý o hodnotu
<strong>bias=2047</strong> a vzorec pro výpočet reálné hodnoty vypadá
takto:</p>

<p><i>X<sub>double</sub>=(-1)<sup>s</sup>&nbsp;&times;&nbsp;2<sup>exp-2047</sup>&nbsp;&times;&nbsp;m</i></p>

<p>Přičemž hodnotu mantisy je možné pro normalizované hodnoty získat pomocí
vztahu:</p>

<p><i>m=1+m<sub>51</sub><sup>-1</sup>+m<sub>50</sub><sup>-2</sup>+m<sub>49</sub><sup>-3</sup>+...+m<sub>0</sub><sup>-52</sup></i></p>

<p>(<i>m<sub>x</sub></i> představuje <i>x</i>-tý bit mantisy)</p>

<p>Rozsah hodnot ukládaných ve dvojité přesnosti je
-1,7&times;10<sup>308</sup>..1,7&times;10<sup>308</sup>, nejmenší možná
nenulová hodnota je rovna 2,2&times;10<sup>-308</sup>.</p>

<p>V&nbsp;novější normě IEEE 754-2008 je specifikován nepovinný formát nazvaný
<i>binary128</i>, který se ovšem běžně označuje <i>quadruple precision</i> či
jen <i>quad precision</i>. Tento formát je založen na slovech širokých 128 bitů
(16 bajtů), která jsou rozdělena takto:</p>

<table>
<tr><th>bit</th><td>127</td><td>126 ... 112</td><td>111 ... 0</td></tr>
<tr><th>význam</th><td>s</td><td>exponent (15 bitů)</td><td>mantisa (112 bitů)</td></tr>
</table>

<p>Exponent je v&nbsp;tomto případě posunutý o hodnotu
<strong>bias=16383</strong>. Dekadická přesnost u tohoto formátu dosahuje 34
cifer!</p>

<p>Jen krátce se zmiňme o poslední variantě FP formátu, který se nazývá
<i>binary256</i> či méně formálně <i>octuple precision</i>. Tento formát
využívá slova o šířce plných 256 bitů (32 bajtů) s&nbsp;následujícím
rozdělením:</p>

<table>
<tr><th>bit</th><td>255</td><td>254 ... 236</td><td>235 ... 0</td></tr>
<tr><th>význam</th><td>s</td><td>exponent (19 bitů)</td><td>mantisa (235 bitů)</td></tr>
</table>

<p>Exponent je v&nbsp;tomto případě posunutý o hodnotu
<strong>bias=262143</strong>. Dekadická přesnost u tohoto formátu dosahuje 71
cifer, nejmenší (nenormalizovaná) reprezentovatelná hodnota rozdílná od nuly je
přibližně 10<sup>−78984</sup>, maximální hodnota pak 1.611
&times;10<sup>78913</sup> (těžko říct, zda je takový rozsah vůbec reálně
využitelný).</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Přednosti a zápory formátu plovoucí řádové tečky</h2>

<p>Vzhledem k&nbsp;tomu, že je FP formát v&nbsp;současnosti velmi rozšířený a
používaný, musí nutně přinášet některé výhody, jinak by jeho rozšíření nebylo
zdaleka tak velké. První předností je podpora FP operací díky hardwarovým FPU
jednotkám, které jsou dostupné jak ve formě samostatného matematického
koprocesoru (původně Intel 8087, Intel i80287, Intel i80387, Intel i80487,
Motorola M68881, Motorola M68882), tak i jako přímá součást moderních
mikroprocesorů (řada x86 od &bdquo;plnohodnotných&ldquo; mikroprocesorů i486,
Motorola M68040, Power PC, některé typy mikrořadičů a signálových procesorů
atd.). Zapomenout nesmíme ani na další rozšíření instrukčních sad, které FP
podporují: SSE-x (x86), VFP (ARM), NEON (ARM), rozšíření pro RISC-V (F, D, Q).
Další předností je existence normy IEEE 754, ve které je mimo jiné řečeno i to,
že každá FPU jednotka by měla podporovat ideálně dva formáty, například
<i>basic single</i> a <i>basic double</i>. To je velmi důležité, zejména pro
přenos numerických údajů mezi různými zařízeními. Pro mnoho programátorů je
také výhodné to, že jeden základní datový typ (například <i>float</i>) je možné
použít pro reprezentaci mnoha objektů či vlastností. Všechny tyto skutečnosti
vedly k&nbsp;tomu, že FP formát (či možná lépe řečeno formáty) jsou
v&nbsp;prakticky všech programovacích jazycích implementovány jako základní
datové typy, což představuje velký náskok před FX formátem, který je podporován
pouze několika málo jazyky a programovými knihovnami.</p>

<p>FP formát však má i některé zápory, které nás mohou v&nbsp;některých
případech &bdquo;donutit&ldquo; k&nbsp;použití nějakého alternativního formátu
(FX, rational). První nevýhoda vychází z&nbsp;velké komplexnosti vlastního
formátu, tj.&nbsp;způsobu rozdělení údajů na mantisu a exponent. I taková
základní matematická operace, jako je součet, je kvůli FP formátu poměrně
složitá a výsledek nemusí vždy odpovídat intuitivnímu cítění programátora,
který má tendenci FP formát pokládat za ekvivalent reálných čísel
(&bdquo;<strong>datový typ double je přesný...</strong>&ldquo;). Mnoho
programátorů se například chybně spoléhá na to, že i pouhý převod mezi typem
<i>int</i> na <i>single/float</i> a zpět na <i>int</i> je bezeztrátový &ndash;
pravý opak je pravdou a to vzhledem k&nbsp;tomu, že se ztratí hodnoty minimálně
osmi nejnižších bitů, které musely být vyhrazeny pro uložení exponentu. FP
formát, resp.&nbsp;formát specifikovaný normou IEEE 754, se vůbec nehodí pro
práci s&nbsp;peněžními hodnotami; z&nbsp;tohoto důvodu se v&nbsp;některých
vyšších programovacích jazycích zavádí speciální datový typ <i>decimal</i>
resp.&nbsp;<i>currency</i>, určený speciálně pro peněžní hodnoty.</p>

<p>Další nedostatek FP formátu souvisí s&nbsp;jeho značnou komplexností.
Hardwarové jednotky FPU jsou relativně komplikované, což limituje použití FP
operací v&nbsp;některých vestavných &ndash; <i>embedded</i> &ndash; zařízeních
(těch je dnes řádově více než osobních počítačů). Dále se komplikuje a
především zpomaluje převod mezi FP formáty a celočíselnými formáty dat
(integer, long). Z&nbsp;tohoto důvodu jsou například mnohé signálové procesory
zkonstruovány tak, aby podporovaly pouze FX aritmetiku, protože jak na vstupu
signálového procesoru, tak i na jeho výstupu jsou prakticky vždy celočíselné
hodnoty a pouze převody mezi vstupem, interní reprezentací a výstupem by byly
mnohdy komplikovanější než implementace veškerých výpočtů v&nbsp;FX
reprezentaci.</p>

<p><div class="rs-tip-major">Poznámka: paradoxně největší problémy při práci
s&nbsp;FP spočívají v&nbsp;tom, že formáty podle normy IEEE 754 jsou vlastně
navrženy velmi šikovně a pro mnoho situací dávají dobré výsledky. To vede
k&nbsp;tomu, že se někdy zapomene na limity těchto formátů.</div></p>

<p>Jen pro zajímavost si zkuste vyplnit následující tabulku pro tři proměnné
různých typů, jejichž hodnota není rovna NaN:</p>

<pre>
int x = ...;
float f = ...;
double d = ...;
</pre>

<p>Které tvrzení (výraz) je pravdivý a který nepravdivý a proč?:</p>

<table>
<tr><th>Tvrzení</th><th>Je pravdivé?</th></tr>
<tr><td>x == (int)(float) x</td><td>ano/ne</td></tr>
<tr><td>x == (int)(double) x</td><td>ano/ne</td></tr>
<tr><td>f == (float)(double) f</td><td>ano/ne</td></tr>
<tr><td>d == (float) d</td><td>ano/ne</td></tr>
<tr><td>f == -(-f);</td><td>ano/ne</td></tr>
<tr><td>2/3 == 2/3.0</td><td>ano/ne</td></tr>
<tr><td>d &lt; 0.0 ⇒ ((d*2) &lt; 0.0)</td><td>ano/ne</td></tr>
<tr><td>d &gt; f ⇒ -f &gt; -d</td><td>ano/ne</td></tr>
<tr><td>d * d &gt;= 0.0</td><td>ano/ne</td></tr>
<tr><td>(d+f)-d == f</td><td>ano/ne</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Datový formát half (half float, half-precision floating-point) a další FP formáty s&nbsp;nižším počtem bitů</h2>

<p>Zatímco výše zmíněné formáty <i>single</i> a <i>double</i> jsou určeny pro
běžné aritmetické výpočty a při správném použití mohou být využity v&nbsp;mnoha
numerických algoritmech, začal být společně s&nbsp;rozšiřováním grafických
akcelerátorů vyvíjen tlak na standardizaci formátů s&nbsp;menší bitovou
hloubkou. Je tomu tak z&nbsp;toho důvodu, že některé operace (již jsme se
zmínili o paměti hloubky, ovšem i operace s&nbsp;barvami pixelů atd.) někdy
vyžadují vyšší dynamický rozsah, ovšem přesnost nemusí být vysoká a více nám
záleží na rychlosti provádění operací.</p>

<p>Dobrým příkladem je dnes již pochopitelně dávno překonaný, ovšem
z&nbsp;hlediska vývoje IT velmi důležitý grafický akcelerátor Voodoo I,
resp.&nbsp;přesněji řečeno způsob implementace jeho paměti hloubky. Do paměti
hloubky (Z-bufferu) je možné ukládat vzdálenosti fragmentů od pozorovatele
(kamery) ve dvou formátech, v&nbsp;obou případech je však každý údaj vždy
uložen na šestnácti bitech. Při použití prvního způsobu se do Z-bufferu
skutečně ukládají vzdálenosti fragmentů, přesněji řečeno celočíselná část
vzdálenosti (výpočty vzdálenosti se provádí přesněji, ale výsledek je při
ukládání zaokrouhlen). Tento formát není příliš výhodný, protože po projekci 3D
scény ze světových souřadnic do prostoru obrazovky není krok mezi jednotlivými
vzdálenostmi konstantní, což vede k&nbsp;vizuálním chybám při vykreslování
(rozlišení pouze 2<sup>16</sup> vzdáleností je v&nbsp;tomto případě
nedostatečné). Z&nbsp;tohoto důvodu se preferuje druhý způsob (nazývaný také
<i>w-buffer</i>), při němž se do Z-bufferu ukládají převrácené hodnoty
vzdálenosti, a to ve speciálním formátu čísel s&nbsp;pohyblivou řádovou tečkou
(čárkou), který má následující strukturu připomínající formát definovaný
v&nbsp;IEEE 754 (viz předchozí kapitoly):</p>

<p>
1.mantissa &times; 2<sup>exponent</sup>
</p>

<p>V&nbsp;tomto formátu je pro mantisu vyhrazeno dvanáct bitů a pro exponent
čtyři bity. Povšimněte si implicitní jedničky před desetinnou tečkou i toho, že
žádný bit není vyhrazen pro uložení znaménka &ndash; vzdálenosti (a samozřejmě
i jejich převrácené hodnoty) jsou vždy kladné. Minimální hodnota, kterou lze
tímto způsobem uložit, je rovna jedničce (0x0000 ~
1.000000000000<sub>2</sub>&times;2<sup>0</sup>), maximální hodnota 65528.0
(0xffff ~ 1.111111111111<sub>2</sub>&times;2<sup>15</sup>).  Podobné
&bdquo;krátké&ldquo; formáty čísel s&nbsp;plovoucí řádovou tečkou jsou
v&nbsp;oblasti grafických akcelerátorů velmi oblíbené. NVidia a firma Microsoft
zavedla typ <i>half</i> do jazyka Cg (v&nbsp;roce 2002), ILM podporuje tento
formát pro operace vyžadující velkou dynamiku (rozsah) hodnot atd.</p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;některých grafických
akcelerátorech narazíme na formát <i>fp24</i>, který stojí na půl cesty mezi
typem <i>half</i> a <i>single</i>.</div></p>

<p>Tento formát používá pro ukládání FP hodnot pouhých šestnáct bitů,
tj.&nbsp;dva byty. Maximální hodnota je rovna 65504
(FFE0<sub>16</sub>=1111111111100000<sub>2</sub>), minimální hodnota (větší než
nula) přibližně 5,9&times;10<sup>-8</sup>. Předností tohoto formátu je malá
bitová šířka (umožňuje paralelní přenos po interních sběrnicích GPU) a také
větší rychlost zpracování základních operací, protože pro tak malou bitovou
šířku mantisy je možné některé operace &bdquo;zadrátovat&ldquo; a nepočítat
pomocí ALU.  Také některé iterativní výpočty (sin, cos, sqrt) mohou být
provedeny rychleji, než v&nbsp;případě plnohodnotných typů
<strong>float</strong> a <strong>single</strong>.</p>

<table>
<tr><td>Celkový počet bitů (bytů):</td><td>16 (2)</td></tr>
<tr><td>Bitů pro znaménko:</td><td>1</td></tr>
<tr><td>Bitů pro exponent:</td><td>5</td></tr>
<tr><td>Bitů pro mantisu:</td><td>10</td></tr>
<tr><td>BIAS (offset exponentu):</td><td>15</td></tr>
<tr><td>Přesnost:</td><td>5-6 číslic</td></tr>
<tr><td>Maximální hodnota:</td><td>65504</td></tr>
<tr><td>Minimální hodnota:</td><td>-65504</td></tr>
<tr><td>Nejmenší kladná nenulová hodnota:</td><td>5,96&times;10<sup>-8</sup></td></tr>
<tr><td>Nejmenší kladná normalizovaná hodnota:</td><td>6,104&times;10<sup>-5</sup></td></tr>
<tr><td>Podpora +&infin;:</td><td>ano</td></tr>
<tr><td>Podpora -&infin;:</td><td>ano</td></tr>
<tr><td>Podpora NaN:</td><td>ano</td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Podpora datového typu half</h2>

<p>Datový typ s&nbsp;poloviční přesností nalezneme v&nbsp;mnoha GPU. Příkladem
mohou být čipy s&nbsp;jádrem <i>VideoCore</i>, které nalezneme
v&nbsp;populárních jednodeskových mikropočítačích Raspberry Pi:</p>

<img src="https://i.iinfo.cz/images/211/rpi-gpu1-1.png" class="image-263918" alt="&#160;" height="972" width="768" />
<p><i>Obrázek 4: Schéma GPU VideoCore.</i></p>

<p>Na předchozím obrázku můžeme vidět koncepci VideoCore. Na jednu stranu se
nejedná ani o univerzálně programovatelný čip s&nbsp;maticí nezávisle
pracujících CPU, na stranu druhou to ale není pevně nakonfigurovaný 3D
akcelerátor. Některé moduly, které VideoCore obsahuje, jsou určeny čistě pro
provádění 2D a 3D grafických operací a je možné je pouze překonfigurovat,
nikoli přeprogramovat (Front-End Pipe, Interpolator, celý koncept Z-bufferu
atd.). Některé moduly pracují s&nbsp;vertexy (vrcholy) zpracovávaných
grafických primitiv, další moduly naopak zpracovávají fragmenty, tj.&nbsp;data
popisující jeden pixel, který se má zapsat do framebufferu. Zajímavostí je
použití TLB (Tile Bufferu), který zde z&nbsp;důvodů lepší škálovatelnosti
nahrazuje přímý přístup do klasického framebufferu. Ovšem z&nbsp;hlediska
programování obecných algoritmů nejsou tyto bloky většinou podstatné;
důležitější jsou programovatelné QPU neboli <i>Quad Processor Unit(s)</i> a
k&nbsp;nim přidružené pomocné moduly (QPU je název používaný společností
Broadcom, obecný název pro tento typ programovatelných modulů je <i>shader</i>).</p>

<p>Všechny QPU mají stejnou interní strukturu a skládají se z&nbsp;několika
bloků:</p>

<ol>
<li>Banky A s&nbsp;32 pracovními registry. Každý registr má šířku 32 bitů.</li>
<li>Banky B, taktéž s&nbsp;32 pracovními registry. Každý registr má šířku 32 bitů.</li>
<li>Sady šesti akumulátorů (na schématu chybí šestý akumulátor <strong>r5</strong>, ten je z&nbsp;pohledu QPU určen jen pro čtení, z&nbsp;pohledu programátora naopak představuje možnost, jak do QPU přenést data)</li>
<li>První ALU orientovanou na operaci násobení (+ na operace hledání minima, maxima atd.).</li>
<li>První ALU orientovanou na operaci sčítání (+ na bitové posuny, logické operace, součty a rozdíly se saturací).</li>
<li>Několik multiplexorů, které vybírají ty vstupní registry, jenž se mají použít jako operandy v&nbsp;ALU.</li>
<li>Moduly označené <i>packer</i> a <i>unpacker</i> zajišťují základní konverze dat (32bitový registr totiž může obsahovat skalární hodnotu či vektor).</li>
</ol>

<img src="https://i.iinfo.cz/images/325/rpi-gpu-6.png" class="image-263924" alt="&#160;" height="557" width="734" /></p>
<p><i>Obrázek 5: Interní struktura každého QPU (zjednodušená, nejsou zde naznačeny řezy pipeline atd.).</i></p>

<p>Z&nbsp;obrázku číslo 5 je patrné, že každý QPU obsahuje dvě samostatně
pracující aritmeticko-logické jednotky, přičemž první jednotka provádí operace
součtu a druhá jednotka především operaci součinu. ALU tedy nejsou zcela
symetrické.  Kromě operace součtu dvou vektorů (32bitová FP operace) může první
ALU provádět bitové posuny, logické operace a v&nbsp;neposlední řadě taktéž
vektorové součty a rozdíly se saturací (myšleny jsou zde součty a rozdíly
prováděné prvek po prvku, výpočty se saturací jsou obzvlášť výhodné při
zpracování signálů). Druhá aritmeticko-logická jednotka dokáže kromě násobení
dvou 32bitových FP hodnot provést součet prvků dvou vektorů, rozdíl prvků,
výpočet minima (prvek po prvku), výpočet maxima a taktéž násobení vektorů prvek
po prvku.</p>

<p>Co je ovšem v&nbsp;kontextu tohoto článku důležité: QPU mohou zpracovávat
data v&nbsp;několika různých formátech. Vždy však platí, že do první i druhé
aritmeticko-logické jednotky vstupují hodnoty přečtené z&nbsp;32 bitových
registrů či z&nbsp;akumulátorů (tyto hodnoty se označují termínem
<i>vektor</i>, i když se ve skutečnosti může jednat o skalární hodnotu). Každou
32bitovou hodnotu je možné interpretovat jako:</p>

<ul>
<li>32bitová hodnota typu celé číslo (integer)</li>
<li>32bitová FP hodnota (single/float)</li>
<li>16bitová celočíselná hodnota se znaménkem</li>
<li>16bitová FP hodnota (má poněkud omezený repertoár operací)</li>
<li>8bitová celočíselná hodnota bez znaménka (čtyři hodnoty/prvky mohou tvořit vektor)</li>
<li>8bitová hodnota reprezentující barvovou složku v&nbsp;rozsahu 0,0 až 1,0 (čtyři složky tvoří barvu)</li>
</ul>

<p>Práce s&nbsp;16bitovými FP hodnotami je obecně rychlejší, než u 32bitových
hodnot typu single, takže lze překonat i udávanou výkonnost čipů
v&nbsp;GFLOPS.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Knihovna NumPy</h2>

<p>Formát <i>half</i> je podporován i v&nbsp;knihovně NumPy, kde se s&nbsp;ním
setkáme pod jménem <i>float16</i>. V&nbsp;následující tabulce jsou vypsány
základní datové formáty podporované touto knihovnou:</p>

<table>
<tr><th>Formát</th><th>Popis</th><th>Rozsah</th></tr>
<tr><td>bool</td><td>uloženo po bajtech</td><td> True/False</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>int8</td><td>celočíselný se znaménkem</td><td>-128..127</td></tr>
<tr><td>int16</td><td>celočíselný se znaménkem</td><td>-32768..32767</td></tr>
<tr><td>int32</td><td>celočíselný se znaménkem</td><td>-2147483648..2147483647</td></tr>
<tr><td>int64</td><td>celočíselný se znaménkem</td><td>-9223372036854775808..9223372036854775807</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>uint8</td><td>celočíselný bez znaménka</td><td>0..255</td></tr>
<tr><td>uint16</td><td>celočíselný bez znaménka</td><td>0..65535</td></tr>
<tr><td>uint32</td><td>celočíselný bez znaménka</td><td>0..4294967295</td></tr>
<tr><td>uint64</td><td>celočíselný bez znaménka</td><td>0..18446744073709551615</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>float16</td><td>plovoucí řádová čárka</td><td>poloviční přesnost (half)</td></tr>
<tr><td>float32</td><td>plovoucí řádová čárka</td><td>jednoduchá přesnost (single)</td></tr>
<tr><td>float64</td><td>plovoucí řádová čárka</td><td>dvojitá přesnost (double)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>complex64 </td><td>komplexní číslo (dvojice)</td><td> 2×float32</td></tr>
<tr><td>complex128</td><td>komplexní číslo (dvojice)</td><td> 2×float64</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto kontextu je zajímavé, že
není podporován formát <i>complex32</i>, tj.&nbsp;komplexní číslo, jehož reálná
i imaginární složka jsou reprezentovány formátem <i>float16</i></div>.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Programovací jazyk Julia</h2>

<p>Formát plovoucí řádové čárky s&nbsp;poloviční přesností se používá i
v&nbsp;některých programovacích jazycích. Příkladem je programovací jazyk
Julia, mezi jehož <a
href="https://www.root.cz/clanky/programovaci-jazyk-julia-typovy-system-funkce-a-metody/#k03">základními
datovými typy</a> nalezneme i typ nazvaný <strong>float16</strong>. Všechny
primitivní datové typy tohoto jazyka jsou vypsány v&nbsp;následující tabulce,
typ s&nbsp;poloviční přesností na prvním řádku:</p>

<pre>
primitive type <strong>Float16</strong> &lt;: AbstractFloat 16 end
primitive type Float32 &lt;: AbstractFloat 32 end
primitive type Float64 &lt;: AbstractFloat 64 end
&nbsp;
primitive type Bool &lt;: Integer 8 end
primitive type Char &lt;: AbstractChar 32 end
&nbsp;
primitive type Int8    &lt;: Signed   8 end
primitive type UInt8   &lt;: Unsigned 8 end
primitive type Int16   &lt;: Signed   16 end
primitive type UInt16  &lt;: Unsigned 16 end
primitive type Int32   &lt;: Signed   32 end
primitive type UInt32  &lt;: Unsigned 32 end
primitive type Int64   &lt;: Signed   64 end
primitive type UInt64  &lt;: Unsigned 64 end
primitive type Int128  &lt;: Signed   128 end
primitive type UInt128 &lt;: Unsigned 128 end
</pre>

<img src="https://i.iinfo.cz/images/662/julia-1.png" alt="julia" />
<p><i>Obrázek 6: Logo programovacího jazyka Julia.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Proč používat typ half float?</h2>

<p>V&nbsp;předchozím textu jsme se dozvěděli, že se formát s&nbsp;poloviční
přesností používá na některých GPU a nalezneme ho v&nbsp;programovacím jazyku
Julia i v&nbsp;knihovně NumPy. Všechny tyto tři technologie mají jednu věc
společnou &ndash; používají se (či mohou používat) pro numerické výpočty, a to
mnohdy vysoce výpočetně náročné výpočty, u nichž je nutné zajistit co nejvyšší
výpočetní výkon. A právě na GPU popř.&nbsp;na specializovaném hardware
(superpočítače) se datový typ <i>half float</i> poměrně dobře prosadil,
pochopitelně u některých typů výpočtů popř.&nbsp;jen v&nbsp;některé části celé
&bdquo;pipeline&ldquo;.</p>

<p>Výkon se nezvyšuje pouze tím, že operace mohou být provedeny rychleji, ale
taktéž vyšším využitím cache, omezením přístupu k&nbsp;pomalé operační paměti
či dokonce k&nbsp;ještě pomalejším diskům.</p>

<p>Příkladem může být jeden z&nbsp;nejvýkonnějších superpočítačů na světě
&ndash; stroj <a
href="https://www.olcf.ornl.gov/olcf-resources/compute-systems/summit/">SUMMIT</a>.
Při použití standardního benchmarku založeného na LINPACKu a tedy i formátu
<i>double</i>, dosahuje výpočetní výkon přibližně 148 petaFLOPS, tedy číselně
148&times;10<sup>15</sup> FLOPS. Ovšem pokud se provádí výpočty s&nbsp;typem
<i>half float</i>, je výpočetní výkon o několik řádů vyšší, konkrétně
3,3&times;10<sup>18</sup> FLOPS, tedy v&nbsp;řádu exaFLOPS!</p>

<p><div class="rs-tip-major">Poznámka: hodnoty xFLOPS se u SUMMITu
v&nbsp;některých článcích liší podle použitého benchmarku a aktuální
konfiguraci tohoto stroje se spotřebou 13MW.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Vlastnosti typu half float</h2>

<p>Při návrhu formátu <i>half float</i> se jeho tvůrci snažili o vyvážení dvou
protichůdných požadavků &ndash; zajistit relativně slušnou přesnost výpočtů a
současně i umožnit velký dynamický rozsah hodnot. V&nbsp;případě formátů
<i>double</i> či <i>quadruple</i> je zajištění obou požadavků poměrně snadné,
protože je k&nbsp;dispozici velký počet bitů, které lze rozdělit mezi mantisu a
exponent, ovšem u formátu <i>half float</i> s&nbsp;pouhými šestnácti dostupnými
bity (jeden z&nbsp;nich je navíc rezervován pro uložení znaménka) nutně muselo
dojít ke kompromisům. Tvůrci formátu <i>half float</i> v&nbsp;tomto případě
upřednostnili spíše přesnost výpočtů resp.&nbsp;přesnost ukládaných hodnot, a
proto bylo pro mantisu rezervováno celých deset bitů a pro exponent pouze bitů
pět. Vyzkoušejme si nyní základní vlastnosti tohoto formátu na jednoduchém
testu &ndash; výpočtu součtu harmonické řady. Ta je divergentní, což bylo
ostatně dokázáno již ve čtrnáctém století. Ovšem při naivním výpočtu této řady
se ukazují některé nepříjemné vlastnosti hodnot s&nbsp;plovoucí řádovou čárkou.
Ostatně to bude patrné na výpočtu této řady, kterou lze realizovat jak
s&nbsp;hodnotami typu <i>double</i>, tak i s&nbsp;hodnotami typu <i>float</i> a
pochopitelně i <i>half float</i>.</p>

<p>Realizace výpočtu s&nbsp;hodnotami typu <i>double</i>, což je typ, který
v&nbsp;implementačním jazyce (Go) má odlišné jméno <i>float64</i>. Ve výpočtu
zjišťujeme, kdy je již další přičítaný člen z&nbsp;důvodu velkého dynamického
rozsahu (mezisoučet versus hodnota n-tého prvku) považován za nulovou hodnotu a
v&nbsp;této chvíli je výpočet ukončen:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func main() {
        var n uint64 = 1
        var h1 float64 = 0.0
        var h2 float64 = 0.0
&nbsp;
        for true {
                h2 = h1 + 1.0/float64(n)
                if n%10000000 == 0 {
                        fmt.Printf("%f %f %20.18f %d\n", h1, h2, h2-h1, n)
                }
                if h1 == h2 {
                        break
                }
                h1 = h2
                n++
        }
        fmt.Printf("Done:\n%f %f %d\n", h1, h2, n)
}
</pre>

<p>Tento program po několika dnech skončí s&nbsp;těmito (pochopitelně
nesprávnými) hodnotami:</p>

<pre>
34.122 34.122 cca 281000000000000
</pre>

<p>Při použití typu <i>single</i> (v&nbsp;Go <i>float32</i>) je výpočet ukončen
po pár sekundách, pochopitelně opět s&nbsp;nesprávným výsledkem:</p>

<pre>
package main
&nbsp;
import "fmt"

func main() {
        var n uint64 = 1
        var h1 float32 = 0.0
        var h2 float32 = 0.0
&nbsp;
        for true {
                h2 = h1 + 1.0/float32(n)
                if n%1000 == 0 {
                        fmt.Printf("%f %f %10.8f %d\n", h1, h2, h2-h1, n)
                }
                if h1 == h2 {
                        break
                }
                h1 = h2
                n++
        }
        fmt.Printf("Done:\n%f %f %d\n", h1, h2, n)
}
</pre>

<p>Z&nbsp;výsledků je patrné, že se iterační výpočet ukončí již po přibližně
dvou milionech iterací, protože přesnost i rozsah typu <i>single</i> je menší,
než u typu <i>double</i>:</p>

<pre>
7.484478 7.485478 0.00099993 1000
8.177869 8.178369 0.00049973 2000
8.583423 8.583756 0.00033379 3000
...
...
...
15.401630 15.401631 0.00000095 2095000
15.402584 15.402585 0.00000095 2096000
15.403538 15.403539 0.00000095 2097000
Done:
15.403683 15.403683 2097152
</pre>

<p>A konečně se dostáváme k&nbsp;typu <i>half float</i>. Sice se nejedná o
základní datový typ programovacího jazyka Go, ale převody na typ <i>half
float</i> (v&nbsp;Go označované <i>float16</i>) zajišťuje knihovna <a
href="https://github.com/x448/float16">github.com/x448/float16</a>:</p>

<pre>
package main
&nbsp;
import (
        "fmt"
        "github.com/x448/float16"
)
&nbsp;
func main() {
        var n uint64 = 1
        h1 := float16.Fromfloat32(0.0)
        h2 := float16.Fromfloat32(0.0)
&nbsp;
        for true {
                h2 = float16.Fromfloat32(h1.Float32() + 1.0/float32(n))
                fmt.Printf("%-11s %-11s %10.8f %d\n", h1.String(), h2.String(), h2.Float32()-h1.Float32(), n)
                if h1 == h2 {
                        break
                }
                h1 = h2
                n++
        }
        fmt.Printf("Done:\n%s %s %d\n", h1.String(), h2.String(), n)
}
</pre>

<p>Výsledky běhu tohoto demonstračního příkladu ukazují, že malá přesnost i
rozsah se projeví velmi negativně na celém výpočtu. Ten je ukončen již po
pouhých 513 iteracích, což znamená, že v&nbsp;kontextu výpočtu je již 1/512
považováno za nulovou hodnotu:</p>

<pre>
0           1           1.00000000 1
1           1.5         0.50000000 2
1.5         1.8330078   0.33300781 3
1.8330078   2.0820312   0.24902344 4
2.0820312   2.28125     0.19921875 5
2.28125     2.4472656   0.16601562 6
2.4472656   2.5898438   0.14257812 7
2.5898438   2.7148438   0.12500000 8
2.7148438   2.8261719   0.11132812 9
2.8261719   2.9257812   0.09960938 10
...
...
...
7.0585938   7.0625      0.00390625 506
7.0625      7.0664062   0.00390625 507
7.0664062   7.0703125   0.00390625 508
7.0703125   7.0742188   0.00390625 509
7.0742188   7.078125    0.00390625 510
7.078125    7.0820312   0.00390625 511
7.0820312   7.0859375   0.00390625 512
7.0859375   7.0859375   0.00000000 513
Done:
7.0859375 7.0859375 513
</pre>

<p><div class="rs-tip-major">Poznámka: pokud preferujete použití Pythonu, budou
příklady vypadat následovně:</div></p>

<pre>
</pre>

<pre>
</pre>

<pre>
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Na scénu přichází formát <strong>bfloat16</strong></h2>

<table>
<tr><th>Dekadicky</th><th>Double (hexa)</th><th>Single (hexa)</th><th>Half (hexa)</th><th>Bfloat16 (hexa)</th></tr>
<tr><td></td><td></td><td></td><td></td><td></td></tr>
</table>
1000
0x408f400000000000
0x447a0000
0x63d0
0x447a

0.1
0x3fb999999999999a
0x3dcccccd
0x2e66
0x3dcd











Format  Significand     Exponent
bfloat16        8 bits  8 bits
fp16    11 bits         5 bits
fp32    24 bits         8 bits

        u       xmins   xmin    xmax
bfloat16        3.91e-03        (*)     1.18e-38        3.39e+38
fp16    4.88e-04        5.96e-08        6.10e-05        6.55e+04
fp32    5.96e-08        1.40e-45        1.18e-38        3.40e+38


tiny FP


0..2 frac
3..6 exp
7 signum

Exp exp E 2 E
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
0000
0001
0010
0011
0100
0101
0110
0111
1000
1001
1010
1011
1100
1101
1110
1111
-6
-6
-5
-4
-3
-2
-1
0
+1
+2
+3
+4
+5
+6
+7
n/a 1/64
1/64
1/32
1/16
1/8
1/4
1/2
1
2
4
8
16
32
64
128
(denorms) - první řádka
(inf, NaN) - poslední řádka








<p><a name="k15"></a></p>
<h2 id="k15">15. Podpora formátu <strong>bfloat16</strong></h2>

<p>Samotný formát <strong>bfloat16</strong> je poměrně nový, takže si teprve postupně hledá cestu pro začlenění jak do samotného hardware (mikroprocesorů a GPU), tak i do širší množiny programovacích jazyků, knihoven a frameworků. Nejprve se zmiňme o hardwarové podpoře. Formát <strong>bfloat</strong> je již začleněn do nových &bdquo;AI procesorů&ldquo; společnosti Intel. Mezi ně patří například Nervana NNP-L1000 atd. Dále se s&nbsp;tímto typem setkáme u výkonných procesorů Xeon, protože do rozšíření instrukční sady AVX-512 byly přidány tři instrukce označované souhrnně <strong>AVX-512_BF16</strong>. Jedná se konkrétně o instrukce s&nbsp;nezapamatovatelnými názvy VCVTNE2PS2BF16, VCVTNEPS2BF16 a VDPBF16PS. Důležitější je pravděpodobně podpora v&nbsp;TPU (<i>tensor processing unit</i>) a tím pádem i v&nbsp;knihovně <i>TensorFlow</i>. To ovšem není vše, protože se <strong>bfloat</strong> objevuje/objeví i v&nbsp;čipech s&nbsp;architekturou ARMv8.6-A atd. </p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Programovací jazyk Julia</h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. Python a knihovna NumPy</h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. Rozšíření do dalších programovacích jazyků</h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Kombinace různých formátů</h2>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>half-rs (pro Rust)<br />
<a href="https://github.com/starkat99/half-rs">https://github.com/starkat99/half-rs</a>
</li>

<li>float16 (pro Go)<br />
<a href="https://github.com/x448/float16">https://github.com/x448/float16</a>
</li>

<li>bfloat16 - Hardware Numerics Definition<br />
<a href="https://software.intel.com/en-us/download/bfloat16-hardware-numerics-definition">https://software.intel.com/en-us/download/bfloat16-hardware-numerics-definition</a>
</li>

<li>Intel Prepares To Graft Google’s Bfloat16 Onto Processors<br />
<a href="https://www.nextplatform.com/2019/07/15/intel-prepares-to-graft-googles-bfloat16-onto-processors/">https://www.nextplatform.com/2019/07/15/intel-prepares-to-graft-googles-bfloat16-onto-processors/</a>
</li>

<li>A Study of BFLOAT16 for Deep Learning Training<br />
<a href="https://arxiv.org/pdf/1905.12322.pdf">https://arxiv.org/pdf/1905.12322.pdf</a>
</li>

<li>BFloat16s.jl<br />
<a href="https://github.com/JuliaComputing/BFloat16s.jl">https://github.com/JuliaComputing/BFloat16s.jl</a>
</li>

<li>Half Precision Arithmetic: fp16 Versus bfloat16<br />
<a href="https://nhigham.com/2018/12/03/half-precision-arithmetic-fp16-versus-bfloat16/">https://nhigham.com/2018/12/03/half-precision-arithmetic-fp16-versus-bfloat16/</a>
</li>

<li>bfloat16 floating-point format (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Bfloat16_floating-point_format">https://en.wikipedia.org/wiki/Bfloat16_floating-point_format</a>
</li>

<li>Unum (number format)<br />
<a href="https://en.wikipedia.org/wiki/Unum_(number_format)#Posit">https://en.wikipedia.org/wiki/Unum_(number_format)#Posit</a>
</li>

<li>Performance Benefits of Half Precision Floats<br />
<a href="https://software.intel.com/en-us/articles/performance-benefits-of-half-precision-floats">https://software.intel.com/en-us/articles/performance-benefits-of-half-precision-floats</a>
</li>

<li>Norma IEEE 754 a příbuzní: formáty plovoucí řádové tečky<br />
<a href="https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/">https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/</a>
</li>

<li>IEEE-754 Floating-Point Conversion<br />
<a href="http://babbage.cs.qc.cuny.edu/IEEE-754.old/32bit.html">http://babbage.cs.qc.cuny.edu/IEEE-754.old/32bit.html</a>
</li>

<li>Small Float Formats<br />
<a href="https://www.khronos.org/opengl/wiki/Small_Float_Formats">https://www.khronos.org/opengl/wiki/Small_Float_Formats</a>
</li>

<li>Binary-coded decimal<br />
<a href="https://en.wikipedia.org/wiki/Binary-coded_decimal">https://en.wikipedia.org/wiki/Binary-coded_decimal</a>
</li>

<li>Chen–Ho encoding<br />
<a href="https://en.wikipedia.org/wiki/Chen%E2%80%93Ho_encoding">https://en.wikipedia.org/wiki/Chen%E2%80%93Ho_encoding</a>
</li>

<li>Densely packed decimal<br />
<a href="https://en.wikipedia.org/wiki/Densely_packed_decimal">https://en.wikipedia.org/wiki/Densely_packed_decimal</a>
</li>

<li>A Summary of Chen-Ho Decimal Data encoding<br />
<a href="http://speleotrove.com/decimal/chen-ho.html">http://speleotrove.com/decimal/chen-ho.html</a>
</li>

<li>Art of Assembly language programming: The 80x87 Floating Point Coprocessors<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html</a>
</li>

<li>Art of Assembly language programming: The FPU Instruction Set<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html</a>
</li>

<li>INTEL 80387 PROGRAMMER'S REFERENCE MANUAL<br />
<a href="http://www.ragestorm.net/downloads/387intel.txt">http://www.ragestorm.net/downloads/387intel.txt</a>
</li>

<li>Floating-Point Formats<br />
<a href="http://www.quadibloc.com/comp/cp0201.htm">http://www.quadibloc.com/comp/cp0201.htm</a>
</li>

<li>Data types (SciPy)<br />
<a href="https://docs.scipy.org/doc/numpy-1.13.0/user/basics.types.html">https://docs.scipy.org/doc/numpy-1.13.0/user/basics.types.html</a>
</li>

<li>New 16-bit floating point type &ndash; NumPy 1.6.0 Release Notes<br />
<a href="https://github.com/numpy/numpy/blob/7cfec2403486456b52b525eccf7541e1562d9ab3/doc/release/1.6.0-notes.rst#new-16-bit-floating-point-type">https://github.com/numpy/numpy/blob/7cfec2403486456b52b525eccf7541e1562d9ab3/doc/release/1.6.0-notes.rst#new-16-bit-floating-point-type</a>
</li>

<li>RFC pro Rust<br />
<a href="https://github.com/joshtriplett/rfcs/blob/f16b/text/0000-f16b.md">https://github.com/joshtriplett/rfcs/blob/f16b/text/0000-f16b.md</a>
</li>

<li>IEEE-754 Floating Point Converter<br />
<a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">https://www.h-schmidt.net/FloatConverter/IEEE754.html</a>
</li>

<li>Mediump float calculator<br />
<a href="https://oletus.github.io/float16-simulator.js/">https://oletus.github.io/float16-simulator.js/</a>
</li>

<li>IEEE 754 Calculator<br />
<a href="http://weitz.de/ieee/">http://weitz.de/ieee/</a>
</li>

<li>BFloat16 (Swift for TensorFlow)<br />
<a href="https://www.tensorflow.org/swift/api_docs/Structs/BFloat16">https://www.tensorflow.org/swift/api_docs/Structs/BFloat16</a>
</li>

<li>Using bfloat16 with TensorFlow models<br />
<a href="https://cloud.google.com/tpu/docs/bfloat16">https://cloud.google.com/tpu/docs/bfloat16</a>
</li>

<li>What is tf.bfloat16 “truncated 16-bit floating point”?<br />
<a href="https://stackoverflow.com/questions/44873802/what-is-tf-bfloat16-truncated-16-bit-floating-point">https://stackoverflow.com/questions/44873802/what-is-tf-bfloat16-truncated-16-bit-floating-point</a>
</li>

<li>BFloat16 processing for Neural Networks on Armv8-A<br />
<a href="https://community.arm.com/developer/ip-products/processors/b/ml-ip-blog/posts/bfloat16-processing-for-neural-networks-on-armv8_2d00_a">https://community.arm.com/developer/ip-products/processors/b/ml-ip-blog/posts/bfloat16-processing-for-neural-networks-on-armv8_2d00_a</a>
</li>

<li>Mixed precision training<br />
<a href="https://arxiv.org/pdf/1710.03740.pdf">https://arxiv.org/pdf/1710.03740.pdf</a>
</li>

<li>[R] Mixed Precision Training<br />
<a href="https://www.reddit.com/r/MachineLearning/comments/75phd2/r_mixed_precision_training/">https://www.reddit.com/r/MachineLearning/comments/75phd2/r_mixed_precision_training/</a>
</li>

<li>Floating Point Numbers<br />
<a href="https://floating-point-gui.de/formats/fp/">https://floating-point-gui.de/formats/fp/</a>
</li>

<li>Float exposed<br />
<a href="https://float.exposed/0x40490000">https://float.exposed/0x40490000</a>
</li>

<li>Float Toy<br />
<a href="http://evanw.github.io/float-toy/">http://evanw.github.io/float-toy/</a>
</li>

<li>IEEE-754 visualization<br />
<a href="https://bartaz.github.io/ieee754-visualization/">https://bartaz.github.io/ieee754-visualization/</a>
</li>

<li>Advantages Of BFloat16 For AI Inference<br />
<a href="https://semiengineering.com/advantages-of-bfloat16-for-ai-inference/">https://semiengineering.com/advantages-of-bfloat16-for-ai-inference/</a>
</li>

<li>ARMv8-A bude podporovat nový formát čísel BFloat16<br />
<a href="https://www.root.cz/zpravicky/armv8-a-bude-podporovat-novy-format-cisle-bfloat16/">https://www.root.cz/zpravicky/armv8-a-bude-podporovat-novy-format-cisle-bfloat16/</a>
</li>

<li>Intel oznámil nový formát BFloat16 pro budoucí procesory<br />
<a href="https://www.root.cz/zpravicky/intel-oznamil-novy-format-bfloat16-pro-budouci-procesory/">https://www.root.cz/zpravicky/intel-oznamil-novy-format-bfloat16-pro-budouci-procesory/</a>
</li>

<li>Nový formát čísel Intelu BFloat16 bude v GCC 10 a Clang 9 <br />
<a href="https://www.root.cz/zpravicky/novy-format-cisel-intelu-bfloat16-bude-v-gcc-10-a-clang-9/">https://www.root.cz/zpravicky/novy-format-cisel-intelu-bfloat16-bude-v-gcc-10-a-clang-9/</a>
</li>

<li>Mixed precision<br />
<a href="https://www.tensorflow.org/guide/keras/mixed_precision">https://www.tensorflow.org/guide/keras/mixed_precision</a>
</li>

<li>Training Performance: A user’s guide to converge faster (TensorFlow Dev Summit 2018)<br />
<a href="https://www.youtube.com/watch?v=SxOsJPaxHME">https://www.youtube.com/watch?v=SxOsJPaxHME</a>
</li>

<li>Programování GPU na Raspberry Pi: použití Quad Processor Unit(s) <br />
<a href="https://www.root.cz/clanky/programovani-gpu-na-raspberry-pi-pouziti-quad-processor-unit-s/">https://www.root.cz/clanky/programovani-gpu-na-raspberry-pi-pouziti-quad-processor-unit-s/</a>
</li>

<li>“Half Precision” 16-bit Floating Point Arithmetic<br />
<a href="https://blogs.mathworks.com/cleve/2017/05/08/half-precision-16-bit-floating-point-arithmetic/">https://blogs.mathworks.com/cleve/2017/05/08/half-precision-16-bit-floating-point-arithmetic/</a>
</li>

<li>Half Precision Arithmetic in Numerical Linear Algebra<br />
<a href="https://nla-group.org/2018/10/03/half-precision-arithmetic-in-numerical-linear-algebra/">https://nla-group.org/2018/10/03/half-precision-arithmetic-in-numerical-linear-algebra/</a>
</li>

<li>Enable BF16 support<br />
<a href="https://gcc.gnu.org/ml/gcc-patches/2019-04/msg00477.html">https://gcc.gnu.org/ml/gcc-patches/2019-04/msg00477.html</a>
</li>

<li>Survey of Floating-Point Formats<br />
<a href="https://mrob.com/pub/math/floatformats.html">https://mrob.com/pub/math/floatformats.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2020</small></p>
</body>
</html>

