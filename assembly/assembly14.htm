<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Použití assembleru v Linuxu: práce s matematickým koprocesorem</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Použití assembleru v Linuxu: práce s matematickým koprocesorem</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Nedílnou součástí prakticky všech moderních mikroprocesorů i některých mikrořadičů je modul určený pro provádění operací s&nbsp;hodnotami s&nbsp;plovoucí řádovou čárkou. S&nbsp;některými možnostmi nabízenými tímto modulem, který se v&nbsp;minulosti označoval termínem &bdquo;matematický koprocesor&ldquo;, se ve stručnosti seznámíme v&nbsp;dnešním článku.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Použití assembleru v&nbsp;Linuxu: práce s&nbsp;matematickým koprocesorem</a></p>
<p><a href="#k02">2. Rozdíl mezi celočíselnými operacemi a operacemi s&nbsp;hodnotami s&nbsp;plovoucí řádovou čárkou</a></p>
<p><a href="#k03">3. Norma IEEE 754 a její varianty</a></p>
<p><a href="#k04">4. Způsob interní reprezentace hodnot s&nbsp;plovoucí řádovou čárkou</a></p>
<p><a href="#k05">5. Formát <strong>single</strong> &ndash; hodnoty s&nbsp;jednoduchou přesností</a></p>
<p><a href="#k06">6. Uložení znaménka, mantisy a exponentu ve formátu single</a></p>
<p><a href="#k07">7. Speciální hodnoty s&nbsp;exponenty 0 a 255</a></p>
<p><a href="#k08">8. Denormalizovaná čísla, hodnoty typu NaN a nekonečna</a></p>
<p><a href="#k09">9. Formát <strong>double</strong> &ndash; hodnoty s&nbsp;dvojnásobnou přesností</a></p>
<p><a href="#k10">10. Rozšířený formát <strong>extended</strong>/<strong>temporary</strong></a></p>
<p><a href="#k11">11. Pracovní registry matematického koprocesoru</a></p>
<p><a href="#k12">12. Řídicí registr</a></p>
<p><a href="#k13">13. Stavový registr</a></p>
<p><a href="#k14">14. Základní instrukce &ndash; načítání dat do registrů</a></p>
<p><a href="#k15">15. Aritmetické operace</a></p>
<p><a href="#k16">16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Použití assembleru v&nbsp;Linuxu: práce s&nbsp;matematickým koprocesorem</h2>

<p>Na všech mikroprocesorech s&nbsp;architekturou i386 i x86-64 a taktéž u většiny mikroprocesorů s&nbsp;architekturou ARM (s&nbsp;výjimkou některých menších mikrořadičů řady Cortex-M či starších čipů předchozí generace) nalezneme modul, který je určený pro provádění operací s&nbsp;hodnotami reprezentovanými v&nbsp;takzvaném systému plovoucí řádové čárky. V&nbsp;angličtině se používá označení <i>floating point</i>, protože při zápisu desetinných čísel se zde používá tečka a nikoli čárka. Tento modul se z&nbsp;historických důvodů nazývá &bdquo;matematický koprocesor&ldquo;, a to proto, že v&nbsp;minulosti se skutečně jednalo o samostatný čip, který bylo možné na základní desku počítače nainstalovat až ve chvíli, kdy to bylo vzhledem k&nbsp;provozovaným úlohám nezbytné (typicky se jednalo o osobní mikropočítače, na nichž se provozoval CAD popř.&nbsp;se na něm v&nbsp;tabulkovém procesoru zpracovávaly rozsáhlejší tabulky s&nbsp;mnoha výpočty). Později se matematický koprocesor stal nedílnou součástí mikroprocesoru, což znamená, že dnes již není nutné testovat jeho přítomnost, provádění všech operací s&nbsp;plovoucí řádovou čárkou je rychlejší (sdílí se společná interní sběrnice) a taktéž není nutné explicitně čekat na dokončení výpočtů.</p>

<p>V&nbsp;dnešním článku se seznámíme především s&nbsp;instrukcemi i s&nbsp;principem práce s&nbsp;hodnotami s&nbsp;plovoucí řádovou čárkou, který je použit na mikroprocesorech s&nbsp;architekturou i386 a x86-64. Až příště si řekneme, jakým způsobem lze podobné výpočty provádět na čipech s&nbsp;architekturou ARM (tam je totiž situace poněkud složitější vzhledem k&nbsp;mnoha různým variantám, s&nbsp;nimiž se můžeme setkat).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Rozdíl mezi celočíselnými operacemi a operacemi s&nbsp;hodnotami s&nbsp;plovoucí řádovou čárkou</h2>

<p>Již v&nbsp;úvodu je nutné upozornit na fakt, že zpracování hodnot s&nbsp;plovoucí řádovou čárkou se <strong>v&nbsp;mnoha ohledech</strong> odlišuje od zpracování celočíselných hodnot. Je tomu tak hned z&nbsp;několika důvodů. U celočíselných hodnot je u všech současných mikroprocesorových architektur totiž předem zřejmé, jaké hodnoty lze uložit do zvoleného n-bitového slova. Například u osmibitových slov je při použití čísel bez znaménka možné reprezentovat hodnoty od 0 do 255 (včetně), zatímco u čísel se znaménkem (konkrétně s&nbsp;dvojkovým doplňkem) jsou to hodnoty od -128 do 127. Navíc je při provádění základních aritmetických operací nutné sledovat pouze několik výjimečných stavů:</p>

<ol>
<li>Přenos u čísel bez znaménka (<i>carry</i>)</li>
<li>Přetečení u čísel se znaménkem (<i>overflow</i>)</li>
<li>Dělení nulou</li>
</ol>

<p>Povšimněte si, že není nutné řešit například práci s&nbsp;nekonečnými hodnotami (kladné a záporné nekonečno), protože takové hodnoty stejně nelze nijak reprezentovat, čímž se detekce potenciálně neplatných výpočtů zjednodušuje. Není například nutné řešit, co se stane v&nbsp;případě pokusu o výpočet &infin;-&infin; nebo 0&times;&infin;, vlastně jedinou potenciálně problematickou operací je výpočet x/0 a speciálně též 0/0 (setkáme se dokonce s&nbsp;ALU, kde je výsledek tohoto výpočtu jednička).</p>

<p>Naproti tomu u hodnot reprezentovaných v&nbsp;systému plovoucí řádové čárky může výjimečných stavů nastat mnohem více, a to i ve chvíli, kdy uvažujeme pouze čtyři základní aritmetické operace a ne speciality typu druhá odmocnina ze záporného čísla atd.:</p>

<ol>
<li>Přetečení</li>
<li>Podtečení</li>
<li>Práce s&nbsp;tzv. denormalizovanými čísly</li>
<li>Operace s&nbsp;nekonečny (kladné, záporné)</li>
<li>Neplatné operace typu 0/0, &infin;-&infin; nebo 0&times;&infin;</li>
<li>Operace s&nbsp;hodnotami, které nejsou skutečná čísla (<i>NaN</i>)</li>
</ol>

<p>Navíc se zde objevuje další problém, který u celých čísel nebylo nutné řešit &ndash; jakým způsobem se má provádět zaokrouhlení výsledků tak, aby je bylo možné uložit zpět do pracovních registrů.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Norma IEEE 754 a její varianty</h2>

<p>Před popisem jednotlivých instrukcí určených pro provádění operací s&nbsp;hodnotami s&nbsp;plovoucí řádovou čárkou je nutné se seznámit s&nbsp;tím, jak jsou vlastně taková čísla interně reprezentována (tj.&nbsp;uložena v&nbsp;pracovních registrech či v&nbsp;operační paměti), protože způsob jejich reprezentace do značné míry určuje i přesnost, rozsah podporovaných hodnot, některá specifika (způsob porovnávání) apod. U naprosté většiny polovodičových čipů vyrobených v&nbsp;posledním čtvrtstoletí se pro reprezentaci numerických hodnot s&nbsp;plovoucí řádovou čárkou dodržují vybrané formáty (někdy i všechny formáty!) specifikované v&nbsp;normě <i>IEEE 754</i>, která sama je postupně rozšiřována a upřesňována. V&nbsp;normě <i>IEEE 754</i>, jejíž první verze je mimochodem v&nbsp;platnosti již od roku 1985, jsou specifikovány nejenom vlastní formáty uložení numerických hodnot v&nbsp;systému pohyblivé řádové čárky (FP formátu), ale i pravidla implementace základních aritmetických operací s&nbsp;těmito hodnotami, aplikace zaokrouhlovacích režimů, způsoby některých konverzí apod. Konkrétně je v&nbsp;této normě popsáno:</p>

<ol>
<li>Základní (<i>basic</i>) a rozšířený (<i>extended</i>) formát uložení numerických hodnot.</li>
<li>Způsob provádění základních matematických operací:
    <ul>
    <li>součet</li>
    <li>rozdíl</li>
    <li>součin</li>
    <li>podíl</li>
    <li>zbytek po dělení</li>
    <li>druhá odmocnina</li>
    <li>porovnání</li>
    </ul></li>
<li>Režimy zaokrouhlování.</li>
<li>Způsob práce s&nbsp;denormalizovanými hodnotami.</li>
<li>Pravidla konverze mezi celočíselnými formáty (<i>integer</i> bez a se znaménkem) a formáty s&nbsp;plovoucí řádovou čárkou.</li>
<li>Způsob konverze mezi různými formáty s&nbsp;plovoucí řádovou čárkou (<i>single</i> &rarr; <i>double</i> atd.).</li>
<li>Způsob konverze základního formátu s&nbsp;plovoucí řádovou čárkou na řetězec číslic (včetně nekonečen a nečíselných hodnot).</li>
<li>Práce s&nbsp;hodnotami NaN (<i>not a number</i>) a výjimkami, které mohou při výpočtech za určitých předpokladů vzniknout.</li>
</ol>



<p><a name="k04"></a></p>
<h2 id="k04">4. Způsob interní reprezentace hodnot s&nbsp;plovoucí řádovou čárkou</h2>

<p>Vybraná podmnožina racionálních čísel může být vyjádřena vztahem:</p>

<p><strong>X<sub>FP</sub>=(-1)<sup>s</sup>&nbsp;&times;&nbsp;2<sup>exp-bias</sup>&nbsp;&times;&nbsp;m</strong></p>

<p>přičemž význam jednotlivých symbolů ve vztahu je následující:</p>

<ul>

<li><strong>X<sub>FP</sub></strong> značí reprezentovanou numerickou hodnotu z&nbsp;podmnožiny racionálních čísel (ta je zase podmnožinou čísel reálných). Díky vyhrazeným (speciálním) hodnotám je možné rozlišit kladnou a zápornou nulu i kladné a záporné nekonečno, což je jeden z&nbsp;důležitých rozdílů oproti způsobu reprezentace celých čísel. Také se může uložit nečíselná hodnota: <i>NaN &ndash; (Not a Number)</i>, která je výsledkem některých matematicky nedefinovaných operací, například 0/0 nebo 0<sup>0</sup>.</li>

<li><strong>2</strong> je <i>báze</i>, někdy také nazývaná <i>radix</i>, u normy <i>IEEE 754</i> je to vždy dvojka, protože výpočty s&nbsp;bází dvě jsou pro číslicové obvody nejjednodušší. V&nbsp;minulosti se používaly i jiné báze, například 8, 16 nebo i 10, s&nbsp;nimi se však již dnes prakticky nesetkáme.</li>

<li><strong>exp</strong> je vždy kladná hodnota exponentu posunutého o hodnotu <strong>bias</strong></li>

<li><strong>bias</strong> je hodnota, díky které je uložený exponent vždy kladný. Tato hodnota se většinou volí dle vztahu: <i>bias=2<sup>eb-1</sup>-1</i>, kde <i>eb</i> je počet bitů vyhrazených pro exponent. Pro specifické účely je však možné zvolit i jinou hodnotu.</li>

<li><strong>m</strong> je mantisa, která je u formátů dle normy <i>IEEE 754</i> vždy kladná</li>

<li><strong>s</strong> je znaménkový bit nabývající hodnoty 0 nebo 1. Pokud je tento bit nulový, je reprezentovaná hodnota <strong>X<sub>FP</sub></strong> kladná, v&nbsp;opačném případě se jedná o zápornou hodnotu. Vzhledem k&nbsp;tomu, že je jeden bit vyhrazen na uložení znaménka, je možné rozlišit kladnou a zápornou nulu.</li>

</ul>



<p><a name="k05"></a></p>
<h2 id="k05">5. Formát <strong>single</strong> &ndash; hodnoty s&nbsp;jednoduchou přesností</h2>

<p>Podle bitové šířky čísel <strong>exp</strong>, <strong>bias</strong> a <strong>m</strong> se rozlišují základní (<i>basic</i>) a rozšířené (<i>extended</i>) formáty FP čísel; norma <i>IEEE 754</i> přitom explicitně zmiňuje dva základní formáty: jednoduchá přesnost (<i>single</i>) a dvojitá přesnost (<i>double</i>).</p>

<p>Tento formát, který je v&nbsp;programovacích jazycích označován buď jako <i>single</i> či <i>float</i>, je charakteristický tím, že se pro uložení numerické hodnoty používá třiceti dvou bitů (4 byty), což pro mnoho aplikací představuje velmi dobrý poměr mezi rozsahem hodnot, přesností a nároky na úložný prostor, nehledě na to, že mnoho architektur stále používá 32 bitové sběrnice. Oněch 32 bitů je rozděleno do třech částí. V&nbsp;první části (představované nejvyšším bitem) je uloženo znaménko, následuje osm bitů pro uložení posunutého exponentu a za nimi je zbývajících 23 bitů, které slouží pro uložení mantisy. Celé třiceti dvoubitové slovo s&nbsp;FP hodnotou tedy vypadá následovně:</p>

<table>
<tr><th>bit</th><td>31</td><td>30 &nbsp; 29 ... 24 &nbsp; 23</td><td>22 &nbsp; 21 ... 3 &nbsp; 2 &nbsp; 1 &nbsp; 0</td></tr>
<tr><th>význam</th><td>s</td><td>exponent (8 bitů)</td><td>mantisa (23 bitů)</td></tr>
</table>

<p>Exponent je přitom posunutý o hodnotu <strong>bias</strong>, která je nastavena na 127, protože je použit výše uvedený vztah:</p>

<p><i>bias=2<sup>eb-1</sup>-1</i></p>

<p>a po dosazení <i>eb=8 (bitů)</i> dostaneme:</p>

<p><i>bias=2<sup>8-1</sup>-1=2<sup>7</sup>-1=128-1=</i><strong>127</strong></p>

<p>Vzorec pro vyjádření reálné hodnoty vypadá následovně:</p>

<p><i>X<sub>single</sub>=(-1)<sup>s</sup>&nbsp;&times;&nbsp;2<sup>exp-127</sup>&nbsp;&times;&nbsp;m</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Uložení znaménka, mantisy a exponentu ve formátu single</h2>

<p>Uložení znaménka číselné hodnoty je jednoduché: pokud je znaménkový bit nastavený na jedničku, jedná se o zápornou hodnotu, v&nbsp;opačném případě jde o hodnotu kladnou. Exponent je uložený v&nbsp;takzvané <strong>posunuté formě</strong>, tj.&nbsp;jako binárně zakódované celé číslo v&nbsp;rozsahu 0..255. Po vyjádření neposunutého exponentu dostáváme rozsah -127..128, obě krajní hodnoty jsou však použity pro speciální účely, proto dostáváme rozsah exponentů -126..127 pro normalizovaná čísla (krajními hodnotami jsou takové exponenty, které mají všechny bity buď jedničkové nebo naopak nulové). Ještě si však musíme říci, jakým způsobem je uložena mantisa. Ta je totiž většinou (až na velmi malá čísla) <strong>normalizovaná</strong>, což znamená, že se do mantisy ukládají pouze hodnoty v&nbsp;rozsahu &lt;1,0;2,0-&epsilon;&gt;. Vzhledem k&nbsp;tomu, že první bit umístěný před binární tečkou je u tohoto rozsahu vždy nastavený na jedničku, není ho zapotřebí ukládat, což znamená, že ušetříme jeden bit z&nbsp;třiceti dvoubitového slova. Pro normalizované hodnoty platí následující vztah:</p>

<p><i>X<sub>single</sub>=(-1)<sup>s</sup>&nbsp;&times;&nbsp;2<sup>exp-127</sup>(1.M)<sub>2</sub></i></p>

<p>kde <strong>M</strong> je hodnota bitového vektoru mantisy, tj.:</p>

<p><i>M=m<sub>22</sub><sup>-1</sup>+m<sub>21</sub><sup>-2</sup>+m<sub>20</sub><sup>-3</sup>+...+m<sub>1</sub><sup>-22</sup>+m<sub>0</sub><sup>-23</sup></i></p>

<p>Rozsah hodnot, jež je možné reprezentovat pomocí jednoduché přesnosti v&nbsp;normalizovaném tvaru je -3,4&times;10<sup>38</sup> až 3,4&times;10<sup>38</sup>. Nejnižší reprezentovatelná (normalizovaná) hodnota je rovna 1,17549&times;10<sup>-38</sup>, denormalizovaná pak 1,40129&times;10<sup>-45</sup>. Jak jsme k&nbsp;těmto hodnotám došli? Zkuste se podívat na následující vztahy:</p>

<table>
<tr><th>hexadecimální hodnota</th><th>výpočet FP</th><th>dekadický výsledek</th><th>normalizováno</th></tr>
<tr><td>0x00000001 </td><td>2<sup>-126</sup>&times;2<sup>-23</sup></td><td>1,40129&times;10<sup>-45</sup></td><td>ne</td></tr>
<tr><td>0x00800000 </td><td>2<sup>-126</sup></td><td>1,17549&times;10<sup>-38</sup></td><td>ano</td></tr>
<tr><td>0x7F7FFFFF </td><td>(2-2<sup>-23</sup>)&times;2<sup>127</sup></td><td>3,4&times;10<sup>38</sup></td><td>ano</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Speciální hodnoty s&nbsp;exponenty 0 a 255</h2>

<p>Ještě si musíme vysvětlit význam těch exponentů, které mají minimální a maximální hodnotu, tj.&nbsp;jsou buď nulové, nebo mají hodnotu 255 (obě samozřejmě před posunem). Vše je přehledně uvedeno v&nbsp;následující tabulce:</p>

<table>
<tr><th>s-bit</th><th>exponent</th><th>mantisa</th><th>význam</th><th>šestnáctkově</th></tr>
<tr><td>0</td><td>0&lt;e&lt;255</td><td>&gt;0</td><td>normalizované kladné číslo</td><td>&nbsp;</td></tr>
<tr><td>1</td><td>0&lt;e&lt;255</td><td>&gt;0</td><td>normalizované záporné číslo</td><td>&nbsp;</td></tr>
<tr><td>0</td><td>0</td><td>&gt;0</td><td>denormalizované kladné číslo</td><td>&nbsp;</td></tr>
<tr><td>1</td><td>0</td><td>&gt;0</td><td>denormalizované záporné číslo</td><td>&nbsp;</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>kladná nula</td><td>0x00000000</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>záporná nula</td><td>0x80000000</td></tr>
<tr><td>0</td><td>255</td><td>0</td><td>kladné nekonečno</td><td>0x7F800000</td></tr>
<tr><td>1</td><td>255</td><td>0</td><td>záporné nekonečno</td><td>0xFF800000</td></tr>
<tr><td>0</td><td>255</td><td>&gt;0</td><td>NaN &ndash; not a number</td><td>&nbsp;</td></tr>
<tr><td>1</td><td>255</td><td>&gt;0</td><td>NaN &ndash; not a number</td><td>&nbsp;</td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Denormalizovaná čísla, hodnoty typu NaN a nekonečna</h2>

<p>Pojmem <strong>denormalizovaná čísla</strong> označujeme takové hodnoty, u kterých není první (explicitně nevyjádřený) bit mantisy roven jedničce, ale naopak nule. Výpočty s&nbsp;těmito velmi malými hodnotami nejsou přesné, zejména při násobení a dělení (a samozřejmě i všech odvozených operacích). Při ukládání denormalizovaných čísel je exponent vždy nastaven na nejnižší hodnotu, tj.&nbsp;na -126 a nejvyšší (explicitně neukládaný) bit mantisy je vždy nulový, nikoli jedničkový, jak je tomu u normalizovaných hodnot. Hodnota typu <strong>NaN</strong> vznikne v&nbsp;případě, že je použita operace s&nbsp;nejasným výsledkem, například 0/0, 0<sup>0</sup> nebo, a to v&nbsp;praxi snad nejčastěji, při odmocňování záporných čísel. Nekonečná hodnota vzniká typicky při dělení nulou (zde je možné zjistit znaménko), nebo při vyjádření funkcí typu <i>log(0)</i> atd.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Formát <strong>double</strong> &ndash; hodnoty s&nbsp;dvojnásobnou přesností</h2>

<p>Formát s&nbsp;dvojitou přesností (<strong>double</strong>), který je definovaný taktéž normou IEEE 754, se v&nbsp;mnoha ohledech podobá formátu s&nbsp;jednoduchou přesností (<strong>single</strong>), pouze se zdvojnásobil celkový počet bitů, ve kterých je hodnota uložena, tj.&nbsp;místo 32 bitů se používá 64 bitů. Právě to je hlavní příčinou toho, proč se tento formát nazývá double, ve skutečnosti je totiž přesnost více než dvojnásobná. 64 bitů alokovaných pro FP hodnotu je v&nbsp;tomto případě rozděleno následujícím způsobem:</p>

<ol>
<li>1 bit pro znaménko</li>
<li>11 bitů pro exponent</li>
<li>52 bitů pro mantisu</li>
</ol>

<p>Bitově vypadá rozdělení následovně:</p>

<table>
<tr><th>bit</th><td>63</td><td>62 ... 52</td><td>51 ... 0</td></tr>
<tr><th>význam</th><td>s</td><td>exponent (11 bitů)</td><td>mantisa 52( bitů)</td></tr>
</table>

<p>Exponent je v&nbsp;tomto případě posunutý o hodnotu <strong>bias=2047</strong> a vzorec pro výpočet reálné hodnoty vypadá takto:</p>

<p><i>X<sub>double</sub>=(-1)<sup>s</sup>&nbsp;&times;&nbsp;2<sup>exp-2047</sup>&nbsp;&times;&nbsp;m</i></p>

<p>Přičemž hodnotu mantisy je možné pro normalizované hodnoty získat pomocí vztahu:</p>

<p><i>m=1+m<sub>51</sub><sup>-1</sup>+m<sub>50</sub><sup>-2</sup>+m<sub>49</sub><sup>-3</sup>+...+m<sub>0</sub><sup>-52</sup></i></p>

<p>(<i>m<sub>x</sub></i> představuje <i>x</i>-tý bit mantisy)</p>

<p>Rozsah hodnot ukládaných ve dvojité přesnosti je -1,7&times;10<sup>308</sup>..1,7&times;10<sup>308</sup>, nejmenší možná nenulová hodnota je rovna 2,2&times;10<sup>-308</sup>. Minimální a maximální hodnota exponentu má opět speciální význam, který je vysvětlen (spolu s&nbsp;normalizovanými čísly) v&nbsp;následující tabulce:</p>

<table>
<tr><th>s-bit</th><th>exponent</th><th>mantisa</th><th>význam</th></tr>
<tr><td>0</td><td>0&lt;e&lt;2047</td><td>&gt;0</td><td>normalizované kladné číslo</td></tr>
<tr><td>1</td><td>0&lt;e&lt;2047</td><td>&gt;0</td><td>normalizované záporné číslo</td></tr>
<tr><td>0</td><td>0</td><td>&gt;0</td><td>denormalizované kladné číslo</td></tr>
<tr><td>1</td><td>0</td><td>&gt;0</td><td>denormalizované záporné číslo</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>kladná nula</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>záporná nula</td></tr>
<tr><td>0</td><td>2047</td><td>0</td><td>kladné nekonečno</td></tr>
<tr><td>1</td><td>2047</td><td>0</td><td>záporné nekonečno</td></tr>
<tr><td>0</td><td>2047</td><td>&gt;0</td><td>NaN &ndash; not a number</td></tr>
<tr><td>1</td><td>2047</td><td>&gt;0</td><td>NaN &ndash; not a number</td></tr>
</table>



<p><a name="k10"></a></p>
<h2 id="k10">10. Rozšířený formát <strong>extended</strong>/<strong>temporary</strong></h2>

<p>Kromě obou základních formátů (tj.&nbsp;jednoduché i dvojité přesnosti) je v&nbsp;normě IEEE 754 povoleno používat i rozšířené formáty. Na platformě x86 je při výpočtech prováděných v&nbsp;matematickém koprocesoru používán rozšířený formát nazývaný <strong>extended</strong> či <strong>temporary</strong>. Tento formát je zajímavý tím, že pro uložení FP hodnot používá 80 bitů a je do něho možné beze ztráty přesnosti uložit 64bitové hodnoty typu integer (což je v&nbsp;mnoha oblastech velmi důležité). Osmdesátibitový vektor je rozdělený do třech částí následujícím způsobem:</p>

<ul>
<li>1 bit pro znaménko</li>
<li>15 bitů pro exponent (<i>BIAS</i> je roven 16383)</li>
<li>64 bitů pro mantisu (maximální hodnota přesahuje 10<sup>4932</sup>)</li>
</ul>

<p>U&nbsp;tohoto formátu je zajímavá funkce bitu s&nbsp;indexem 63. Podle hodnoty tohoto bitu se rozlišují čísla normalizovaná a nenormalizovaná (tento bit ve skutečnosti nahrazuje implicitně nastavovaný nejvyšší bit mantisy, jak ho známe z&nbsp;předchozích formátů). Matematické koprocesory řady 80x87 sice dokážou pracovat s&nbsp;čísly nenormalizovanými, výsledkem jeho aritmetických operací jsou však vždy hodnoty normalizované. Všechny možnosti, které mohou při ukládání extended FP formátu nastat, jsou přehledně vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th>s-bit</th><th>exponent</th><th>mantisa</th><th>m<sub>63</sub><th>význam</th></tr>
<tr><td>0</td><td>0&lt;e&lt;32767</td><td>&gt;0</td><td>1</td><td>normalizované kladné číslo</td></tr>
<tr><td>1</td><td>0&lt;e&lt;32767</td><td>&gt;0</td><td>1</td><td>normalizované záporné číslo</td></tr>
<tr><td>0</td><td>0&lt;e&lt;32767</td><td>&gt;0</td><td>0</td><td><strong>ne</strong>normalizované kladné číslo</td></tr>
<tr><td>1</td><td>0&lt;e&lt;32767</td><td>&gt;0</td><td>0</td><td><strong>ne</strong>normalizované záporné číslo</td></tr>
<tr><td>0</td><td>0</td><td>&gt;0</td><td>0</td><td><strong>de</strong>normalizované kladné číslo</td></tr>
<tr><td>1</td><td>0</td><td>&gt;0</td><td>0</td><td><strong>de</strong>normalizované záporné číslo</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>x</td><td>kladná nula</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>x</td><td>záporná nula</td></tr>
<tr><td>0</td><td>32767</td><td>0</td><td>x</td><td>kladné nekonečno</td></tr>
<tr><td>1</td><td>32767</td><td>0</td><td>x</td><td>záporné nekonečno</td></tr>
<tr><td>0</td><td>32767</td><td>&gt;0</td><td>x</td><td>NaN &ndash; not a number</td></tr>
<tr><td>1</td><td>32767</td><td>&gt;0</td><td>x</td><td>NaN &ndash; not a number</td></tr>
</table>

<p>Pro normalizované i nenormalizované hodnoty je možné uloženou hodnotu vyjádřit pomocí vzorce (všimněte si, že bit 63 je umístěn před binární tečkou):</p>

<p><i>X<sub>extended</sub>=(-1)<sup>s</sup>&nbsp;&times;&nbsp;2<sup>exp-16383</sup>&nbsp;&times;&nbsp;m</i></p>
<p><i>m=m<sub>63</sub><sup>0</sup>+m<sub>62</sub><sup>-1</sup>+m<sub>61</sub><sup>-2</sup>+...+m<sub>0</sub><sup>-63</sup></i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Pracovní registry matematického koprocesoru</h2>

<p>Matematický koprocesor má k&nbsp;dispozici celkem osm pracovních registrů, přičemž každý registr má šířku osmdesáti bitů. To znamená, že je možné provádět operace s&nbsp;hodnotami s&nbsp;rozšířenou (<i>extended</i>) přesností a samozřejmě taktéž s&nbsp;přesností jednoduchou (<i>single</i>) a dvojitou (<i>double</i>). Zajímavé a dnes již poněkud neobvyklé je, že zmíněných osm registrů tvoří zásobník, takže instrukce pro načítání hodnot ve skutečnosti provádí uložení na vrchol zásobníku, aritmetické operace pracují se dvěma registry na vrcholu zásobníku atd. U mnoha instrukcí je však možné toto pravidlo porušit a zvolit si registry explicitně, popř.&nbsp;zakázat odstranění původních operandů ze zásobníku. Zápis jmen registrů vypadá takto: <strong>ST(0)</strong>, <strong>ST(1)</strong> atd. (pořadí registru v&nbsp;zásobníku se průběžně mění). Moderní FPU již tento zásobníkový koncept, který byl výhodný pro starší a méně dobré překladače, zcela odstranily.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Řídicí registr</h2>

<p>Kromě pracovních registrů obsahuje matematický koprocesor i řídicí registr (<i>control register</i>). Ten má šířku pouze šestnáct bitů a obsahuje masky výjimek, které mohou nastat při provádění různých operací, dále pak dva bity pro volbu zaokrouhlovacího režimu a taktéž dva bity pro volbu přesnosti jednotlivých výpočtů:</p>

<table>
<tr><th> #</th><th>Označení</th><th>Význam</th></tr>
<tr><td> 0</td><td>IM</td><td>maska výjimky Invalid Operation</td></tr>
<tr><td> 1</td><td>DM</td><td>maska výjimky Denormalized Operand</td></tr>
<tr><td> 2</td><td>ZM</td><td>maska výjimky Zero Divide</td></tr>
<tr><td> 3</td><td>OM</td><td>maska výjimky Overflow</td></tr>
<tr><td> 4</td><td>UM</td><td>maska výjimky Underflow</td></tr>
<tr><td> 5</td><td>PM</td><td>maska výjimky Precision</td></tr>
<tr><td> 6</td><td>&times;</td><td></td></tr>
<tr><td> 7</td><td>IE</td><td>povolení přerušení (dnes nevyužito)</td></tr>
<tr><td> 8</td><td>PC1</td><td>volba přesnosti výpočtů (viz tabulku níže)</td></tr>
<tr><td> 9</td><td>PC2</td><td>-//-</td></tr>
<tr><td>10</td><td>RC1</td><td>volba zaokrouhlovacího režimu (viz tabulku níže)</td></tr>
<tr><td>11</td><td>RC2</td><td>-//-</td></tr>
<tr><td>12</td><td>IC</td><td>dnes nepoužito, pro kompatibilitu s 80287</td></tr>
<tr><td>13</td><td>&times;</td><td></td></tr>
<tr><td>14</td><td>&times;</td><td></td></tr>
<tr><td>15</td><td>&times;</td><td></td></tr>
</table>

<p>Bity <strong>RC2</strong> a <strong>RC1</strong> se používají pro volbu zaokrouhlení:</p>

<table>
<tr><th>RC2</th><th>RC1</th><th></th></tr>
<tr><td>0</td><td>0</td><td>zaokrouhlení na nejbližší sudé číslo (mantisa)</td></tr>
<tr><td>0</td><td>1</td><td>zaokrouhlení směrem k -&infin;</td></tr>
<tr><td>1</td><td>0</td><td>zaokrouhlení směrem k +&infin;</td></tr>
<tr><td>1</td><td>1</td><td>zaokrouhlení směrem k nule</td></tr>
</table>

<p>Bity <strong>PC2</strong> a <strong>PC1</strong> určují, zda se mají výpočty provádět s&nbsp;jednoduchou přesností, dvojitou přesností či s&nbsp;rozšířenou přesností:</p>

<table>
<tr><th>PC2</th><th>PC1</th><th></th></tr>
<tr><td>0</td><td>0</td><td>32 bitů</td></tr>
<tr><td>0</td><td>1</td><td>&nbsp;</td></tr>
<tr><td>1</td><td>0</td><td>64 bitů</td></tr>
<tr><td>1</td><td>1</td><td>80 bitů (výchozí)</td></tr>
</table>

<p>Většinou není nutné obsah tohoto registru v&nbsp;průběhu výpočtů měnit.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Stavový registr</h2>

<p>Jednotlivé matematické operace prováděné matematickým koprocesorem nastavují bity v&nbsp;takzvaném stavovém registru (<i>status register</i>). Tento registru má taktéž šířku šestnácti bitů a jeho struktura vypadá následovně:</p>

<table>
<tr><th> #</th><th>Označení</th><th>Význam</th></tr>
<tr><td> 0</td><td>IE</td><td>výjimka Invalid Operation</td></tr>
<tr><td> 1</td><td>DE</td><td>výjimka Denormalized Operand</td></tr>
<tr><td> 2</td><td>ZO</td><td>výjimka Zero Divide</td></tr>
<tr><td> 3</td><td>OE</td><td>výjimka Overflow</td></tr>
<tr><td> 4</td><td>UE</td><td>výjimka Underflow</td></tr>
<tr><td> 5</td><td>PE</td><td>výjimka Precision</td></tr>
<tr><td> 6</td><td>SF</td><td>špatná manipulace se zásobníkem operandů</td></tr>
<tr><td> 7</td><td>ES</td><td>Error summary</td></tr>
<tr><td> 8</td><td>C0</td><td>výsledek porovnání (příznakový bit)</td></tr>
<tr><td> 9</td><td>C1</td><td>výsledek porovnání (příznakový bit)</td></tr>
<tr><td>10</td><td>C2</td><td>výsledek porovnání (příznakový bit)</td></tr>
<tr><td>11</td><td>ST0</td><td>ukazatel vrcholu zásobníku</td></tr>
<tr><td>12</td><td>ST1</td><td>ukazatel vrcholu zásobníku</td></tr>
<tr><td>13</td><td>ST2</td><td>ukazatel vrcholu zásobníku</td></tr>
<tr><td>14</td><td>C3</td><td>výsledek porovnání (příznakový bit)</td></tr>
<tr><td>15</td><td>B</td><td>busy bit (provádí se operace)</td></tr>
</table>

<p>Nejzajímavější jsou bity <strong>C0</strong>, <strong>C1</strong>, <strong>C2</strong> a <strong>C3</strong>, protože do těchto bitů se ukládá například výsledek porovnání dvou hodnot atd. Tyto bity jsou ve stavovém registru umístěny tak, aby přesně odpovídaly umístění standardních příznaků v&nbsp;registru <strong>EFLAGS</strong>:</p>

<table>
<tr><th>FPU</th><th>EFLAGS</th></tr>
<tr><td>C0</td><td>carry flag </td></tr>
<tr><td>C1</td><td>undefined  </td></tr>
<tr><td>C2</td><td>parity flag</td></tr>
<tr><td>C3</td><td>zero flag  </td></tr>
</table>

<p>Způsob použití si ukážeme příště.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Základní instrukce &ndash; načítání dat do registrů</h2>

<p>V&nbsp;této kapitole si prozatím bez demonstračního příkladu vypíšeme základní instrukce určené pro načtení dat do registrů FPU. Jedná se o následujících osm instrukcí:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>FLD   </td><td>načtení hodnoty typu single, double či extended z paměti či jiného registru</td></tr>
<tr><td>2</td><td>FLD1  </td><td>načtení konstanty +1,0</td></tr>
<tr><td>3</td><td>FLDL2T</td><td>načtení konstanty log<sub>2</sub>10</td></tr>
<tr><td>4</td><td>FLDL2E</td><td>načtení konstanty log<sub>2</sub>e</td></tr>
<tr><td>5</td><td>FLDPI </td><td>načtení konstanty &pi;</td></tr>
<tr><td>6</td><td>FLDLG2</td><td>načtení konstanty log<sub>10</sub>2</td></tr>
<tr><td>7</td><td>FLDLN2</td><td>načtení konstanty log<sub>e</sub>2</td></tr>
<tr><td>8</td><td>FLDZ  </td><td>načtení konstanty +0,0 (kladná nula)</td></tr>
</table>

<p>Hodnoty logaritmů se využijí v&nbsp;mnoha instrukcích, které si popíšeme příště.</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Aritmetické operace</h2>

<p>Mezi základní aritmetické operace patří především:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>FADD</td><td>součet</td></tr>
<tr><td>2</td><td>FSUB</td><td>rozdíl</td></tr>
<tr><td>3</td><td>FSUBR</td><td>rozdíl, ale operandy jsou prohozeny</td></tr>
<tr><td>4</td><td>FMUL</td><td>součin</td></tr>
<tr><td>5</td><td>FDIV</td><td>podíl</td></tr>
<tr><td>6</td><td>FDIVR</td><td>podíl, ale operandy jsou prohozeny</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>FCHS</td><td>změna znaménka</td></tr>
<tr><td>8</td><td>FABS</td><td>výpočet absolutní hodnoty</td></tr>
<tr><td>9</td><td>FSQRT</td><td>výpočet druhé odmocniny</td></tr>
</table>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>Art of Assembly language programming: The 80x87 Floating Point Coprocessors<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html</a>
</li>

<li>Art of Assembly language programming: The FPU Instruction Set<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html</a>
</li>

<li>INTEL 80387 PROGRAMMER'S REFERENCE MANUAL<br />
<a href="http://www.ragestorm.net/downloads/387intel.txt">http://www.ragestorm.net/downloads/387intel.txt</a>
</li>

<li>x86 Instruction Set Reference: FLD<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_100.html">http://x86.renejeschke.de/html/file_module_x86_id_100.html</a>
</li>

<li>x86 Instruction Set Reference: FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_101.html">http://x86.renejeschke.de/html/file_module_x86_id_101.html</a>
</li>

<li>x86 Instruction Set Reference: BT<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_22.html">http://x86.renejeschke.de/html/file_module_x86_id_22.html</a>
</li>

<li>x86 Instruction Set Reference: BTC<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_23.html">http://x86.renejeschke.de/html/file_module_x86_id_23.html</a>
</li>

<li>x86 Instruction Set Reference: BTR<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_24.html">http://x86.renejeschke.de/html/file_module_x86_id_24.html</a>
</li>

<li>x86 Instruction Set Reference: BTS<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_25.html">http://x86.renejeschke.de/html/file_module_x86_id_25.html</a>
</li>

<li>x86 Instruction Set Reference: BSF<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_19.html">http://x86.renejeschke.de/html/file_module_x86_id_19.html</a>
</li>

<li>x86 Instruction Set Reference: BSR<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_20.html">http://x86.renejeschke.de/html/file_module_x86_id_20.html</a>
</li>

<li>x86 Instruction Set Reference: BSWAP<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_21.html">http://x86.renejeschke.de/html/file_module_x86_id_21.html</a>
</li>

<li>x86 Instruction Set Reference: XCHG<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_328.html">http://x86.renejeschke.de/html/file_module_x86_id_328.html</a>
</li>

<li>x86 Instruction Set Reference: SETcc<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_288.html">http://x86.renejeschke.de/html/file_module_x86_id_288.html</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>The GNU Assembler Tutorial<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html">http://tigcc.ticalc.org/doc/gnuasm.html</a>
</li>

<li>The GNU Assembler - macros<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html#SEC109">http://tigcc.ticalc.org/doc/gnuasm.html#SEC109</a>
</li>

<li>ARM subroutines &amp; program stack<br />
<a href="http://www.toves.org/books/armsub/">http://www.toves.org/books/armsub/</a>
</li>

<li>Generating Mixed Source and Assembly List using GCC<br />
<a href="http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/">http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/</a>
</li>

<li>Calling subroutines<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm</a>
</li>

<li>ARM Assembly Language Programming<br />
<a href="http://peter-cockerell.net/aalp/html/frames.html">http://peter-cockerell.net/aalp/html/frames.html</a>
</li>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Intel x86 JUMP quick reference<br />
<a href="http://unixwiz.net/techtips/x86-jumps.html">http://unixwiz.net/techtips/x86-jumps.html</a>
</li>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Assembler pod Linuxem<br />
<a href="http://phoenix.inf.upol.cz/linux/prog/asm.html">http://phoenix.inf.upol.cz/linux/prog/asm.html</a>
</li>

<li>AT&amp;T Syntax versus Intel Syntax<br />
<a href="https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html">https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html</a>
</li>

<li>Linux Assembly website<br />
<a href="http://asm.sourceforge.net/">http://asm.sourceforge.net/</a>
</li>

<li>Using Assembly Language in Linux<br />
<a href="http://asm.sourceforge.net/articles/linasm.html">http://asm.sourceforge.net/articles/linasm.html</a>
</li>

<li>vasm<br />
<a href="http://sun.hasenbraten.de/vasm/">http://sun.hasenbraten.de/vasm/</a>
</li>

<li>vasm &ndash; dokumentace<br />
<a href="http://sun.hasenbraten.de/vasm/release/vasm.html">http://sun.hasenbraten.de/vasm/release/vasm.html</a>
</li>

<li>The Yasm Modular Assembler Project<br />
<a href="http://yasm.tortall.net/">http://yasm.tortall.net/</a>
</li>

<li>680x0:AsmOne<br />
<a href="http://www.amigacoding.com/index.php/680x0:AsmOne">http://www.amigacoding.com/index.php/680x0:AsmOne</a>
</li>

<li>ASM-One Macro Assembler<br />
<a href="http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler">http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler</a>
</li>

<li>ASM-One pages<br />
<a href="http://www.theflamearrows.info/documents/asmone.html">http://www.theflamearrows.info/documents/asmone.html</a>
</li>

<li>Základní informace o ASM-One<br />
<a href="http://www.theflamearrows.info/documents/asminfo.html">http://www.theflamearrows.info/documents/asminfo.html</a>
</li>

<li>Linux Syscall Reference<br />
<a href="http://syscalls.kernelgrok.com/">http://syscalls.kernelgrok.com/</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>IBM System 360/370 Compiler and Historical Documentation<br />
<a href="http://www.edelweb.fr/Simula/">http://www.edelweb.fr/Simula/</a>
</li>

<li>IBM 700/7000 series<br />
<a href="http://en.wikipedia.org/wiki/IBM_700/7000_series">http://en.wikipedia.org/wiki/IBM_700/7000_series</a>
</li>

<li>IBM System/360<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/360">http://en.wikipedia.org/wiki/IBM_System/360</a>
</li>

<li>IBM System/370<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/370">http://en.wikipedia.org/wiki/IBM_System/370</a>
</li>

<li>Mainframe family tree and chronology<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html</a>
</li>

<li>704 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html</a>
</li>

<li>705 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html</a>
</li>

<li>The IBM 704<br />
<a href="http://www.columbia.edu/acis/history/704.html">http://www.columbia.edu/acis/history/704.html</a>
</li>

<li>IBM Mainframe album<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html</a>
</li>

<li>Osmibitové muzeum<br />
<a href="http://osmi.tarbik.com/">http://osmi.tarbik.com/</a>
</li>

<li>Tesla PMI-80<br />
<a href="http://osmi.tarbik.com/cssr/pmi80.html">http://osmi.tarbik.com/cssr/pmi80.html</a>
</li>

<li>PMI-80<br />
<a href="http://en.wikipedia.org/wiki/PMI-80">http://en.wikipedia.org/wiki/PMI-80</a>
</li>

<li>PMI-80<br />
<a href="http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016">http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016</a>
</li>

<li>The 6502 overflow flag explained mathematically <br />
<a href="http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html">http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html</a>
</li>

<li>X86 Opcode and Instruction Reference<br />
<a href="http://ref.x86asm.net/coder32.html">http://ref.x86asm.net/coder32.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

