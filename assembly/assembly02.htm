<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Použití assembleru v Linuxu: volání služeb nabízených jádrem</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Použití assembleru v Linuxu: volání služeb nabízených jádrem</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhé části článku o použití assembleru v&nbsp;Linuxu se seznámíme s&nbsp;dalšími jednoduchými příklady, v&nbsp;nichž se budou využívat pouze služby jádra operačního systému, což znamená, že k&nbsp;vytvářeným programům nebude nutné připojovat (linkovat) žádné další knihovny. Všechny příklady budou připraveny jak pro GNU Assembler (GAS), tak i (až na jednu výjimku) pro Netwide Assembler (NASM).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Doplnění k&nbsp;předchozímu článku &ndash; příklady upravené Danem Horákem pro &bdquo;big iron&ldquo;</a></p>
<p><a href="#k02">2. Použití assembleru v&nbsp;Linuxu: volání služeb nabízených jádrem</a></p>
<p><a href="#k03">3. Strojové instrukce, které dnes budeme používat</a></p>
<p><a href="#k04">4. Dvě syntaxe zápisu programů podporované GNU Assemblerem</a></p>
<p><a href="#k05">5. Služba <strong>sys_write</strong>: zápis sekvence bajtů do souboru specifikovaného deskriptorem</a></p>
<p><a href="#k06">6. Program typu &bdquo;Hello world!&ldquo; napsaný v&nbsp;GNU Assembleru pro i386</a></p>
<p><a href="#k07">7. Použití &bdquo;Intel&ldquo; syntaxe pro program typu &bdquo;Hello world&ldquo;</a></p>
<p><a href="#k08">8. Vizuální rozdíl: AT&amp;T syntaxe versus Intel syntaxe</a></p>
<p><a href="#k09">9. Přepis programu typu &bdquo;Hello world!&ldquo; do syntaxe Netwide Assembleru (NASM)</a></p>
<p><a href="#k10">10. Vizuální rozdíl: Intel syntaxe v&nbsp;GNU Assembleru versus NASM</a></p>
<p><a href="#k11">11. Vylepšená verze výpočtu délky řetězce</a></p>
<p><a href="#k12">12. Přepis programu pro architekturu S/390 a S/390x</a></p>
<p><a href="#k13">13. Repositář se zdrojovými kódy demonstračních příkladů</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Doplnění k&nbsp;předchozímu článku &ndash; příklady upravené Danem Horákem pro &bdquo;big iron&ldquo;</h2>

<p>Ještě předtím, než se začneme zabývat tématem dnešního článku, se na chvíli vraťme k&nbsp;prvnímu dílu, v&nbsp;němž jsme si ukázali jednoduché &bdquo;šablony&ldquo; s&nbsp;programy psanými v&nbsp;assembleru procesorů řady i386/x86-64 i 32bitových ARMů s&nbsp;instrukční sadou Thumb. Dan Horák, jemuž tímto posílám velké poděkování, tyto šablony upravil pro použití v&nbsp;Linuxu běžícího na &bdquo;big ironu&ldquo;, konkrétně na systémech (ať již reálných či emulovaných) S/390 (architektura s&nbsp;31bitovým adresováním) a S/390x (již 64bitová architektura). Tyto příklady naleznete v&nbsp;GIT repositáři v&nbsp;adresáři <a href="https://github.com/tisnik/presentations/tree/master/assembler/01_gas_template">01_gas_template</a> a <a href="https://github.com/tisnik/presentations/tree/master/assembler/03_gas_hello_world">03_gas_hello_world</a> (bude <a href="#k12">popsán níže</a>), samozřejmě včetně skriptů pro překlad a slinkování. Pro zajímavost se na upravenou šablonu podívejme, neboť je na ní vidět rozdíl oproti ostatním dvěma architekturám:</p>

<h3>Program, který se po svém spuštění ukončí zavoláním služby jádra sys_exit</h3>

<pre>
# asmsyntax=as

# Sablona pro zdrojovy kod Linuxoveho programu naprogramovaneho
# v assembleru GNU AS.
#
# Autor: Pavel Tisnovsky
#        Dan Horak



# Linux kernel system call table
sys_exit=1



#-----------------------------------------------------------------------------
.section .data



#-----------------------------------------------------------------------------
.section .bss



#-----------------------------------------------------------------------------
.section .text
        .global _start          # tento symbol ma byt dostupny i linkeru

_start:
        la    1,sys_exit        # cislo sycallu pro funkci "exit"
        la    2,0               # exit code = 0
        svc   0                 # volani Linuxoveho kernelu

        # pro syscally &lt; 256 funguje i nasledujici
#       la      2,0
#       svc     sys_exit
</pre>

<p>Povšimněte si především způsobu zápisu jmen (či spíše indexů) pracovních registrů. Samotná služba jádra se volá instrukcí <strong>SVC</strong> neboli &bdquo;Supervisor Call&ldquo;.</p>

<p>Překlad a slinkování pro S/390:</p>

<pre>
as -m31 s390.s -o s390.o
ld -melf_s390 -s s390.o
</pre>

<p>Překlad a slinkování pro S/390x:</p>

<pre>
as s390.s -o s390x.o
ld -s s390x.o
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Použití assembleru v&nbsp;Linuxu: volání služeb nabízených jádrem</h2>

<p>V&nbsp;dnešním článku se budeme primárně zabývat základními službami nabízenými jádrem Linuxu. Již <a href="http://mojefedora.cz/pouziti-assembleru-v-linuxu/">z&nbsp;úvodní části</a> víme, že tyto služby lze snadno volat i z&nbsp;assembleru. Většinou pouze postačuje naplnit pracovní registry požadovanými parametry popř.&nbsp;adresami složitějších datových struktur uložených v&nbsp;operační paměti, nastavit číslo služby a následně provést přepnutí procesoru do režimu jádra. Na architektuře i386 se přepnutí provede instrukcí <strong>INT</strong>, která způsobí přerušení, jenž je obsluhované jádrem. Při programování je dobré mít na paměti, že takto realizovaná obsluha systémových volání je relativně pomalá, takže se například při vypisování řetězců na standardní výstup či do souboru vyplatí si ukládat výstupní data do bufferu a volat jádro až ve chvíli, kdy je to skutečně nutné (nikoli tedy po jednotlivých znacích). Samozřejmě lze použít i služby knihovny <strong>libc</strong>, což se pro složitější aplikace stává praktickou nezbytností.</p>

<p>Programy, které si ukážeme a odladíme dnes i v&nbsp;příští (třetí) části, budou používat následující tři systémová volání (<i>syscally</i>):</p>

<table>
<tr><th>Syscall</th><th>Číslo</th><th>Význam</th></tr>
<tr><td>sys_exit </td><td>1</td><td>ukončení procesu</td></tr>
<tr><td>sys_read </td><td>3</td><td>čtení přes deskriptor souboru (například standardního vstupu)</td></tr>
<tr><td>sys_write</td><td>4</td><td>zápis přes deskriptor souboru (například do standardního výstupu)</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Strojové instrukce, které dnes budeme používat</h2>

<p>Pro jednoduchost se prozatím budeme soustředit především na procesory s&nbsp;architekturou i386 a x86-64 (jedinou výjimkou bude <a href="#k12">dvanáctá kapitola</a> a programy vytvořené Danem Horákem pro S/390 a S/390x). Zajímavé je, že si prozatím vystačíme s&nbsp;pouhými několika strojovými instrukcemi resp.&nbsp;jejich variantami, které se od sebe odlišují použitými operandy. V&nbsp;následující tabulce je použita Intel syntaxe, která je podle mého názoru mnohem čitelnější, než syntaxe AT&amp;T:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>mov eax, 1</td><td>uložení konstanty do registru <strong>eax</strong></td></tr>
<tr><td>2</td><td>mov ecx, offset návěští</td><td>uložení adresy do registru <strong>ecx</strong></td></tr>
<tr><td>3</td><td>mov [entered], eax</td><td>uložení registru na adresu zadanou návěštím</td></tr>
<tr><td>4</td><td>mod edx, [entered]</td><td>načtení 32bitového slova z&nbsp;adresy zadané návěštím</td></tr>
<tr><td>5</td><td>int 80h</td><td>volání jádra funkce (syscall)</td></tr>
</table>

<p>V&nbsp;režimu i386 lze používat 32bitové pracovní registry nazvané:</p>

<table>
<tr><th>Registr</th><th>Poznámka</th></tr>
<tr><td>EAX</td><td>univerzální registr</td></tr>
<tr><td>EBX</td><td>univerzální registr</td></tr>
<tr><td>ECX</td><td>univerzální registr</td></tr>
<tr><td>EDX</td><td>univerzální registr</td></tr>
<tr><td>ESI</td><td>index registr</td></tr>
<tr><td>EDI</td><td>index registr</td></tr>
<tr><td>EBP</td><td>index registr, někdy použit pro uložení báze zásobníkového rámce</td></tr>
<tr><td>ESP</td><td>použit pro adresování v&nbsp;rámci zásobníkového rámce</td></tr>
</table>

<p>V&nbsp;režimu x86-64 se bitová šířka pracovních registrů (používaných kromě běžných aritmetických a logických operací mj.&nbsp;i pro adresování) zvyšuje na plných šedesát čtyři bitů a navíc se namísto původní osmice pracovních 32bitových registrů EAX, EBX, ECX, EDX, EBP, ESP, ESI, EDI (viz předchozí tabulka) používá dvojnásobný počet pracovních registrů RAX, RBX, RCX, RDX, RBP, RSP, RSI, RDI, R8, R9, R10, R11, R12, R13, R14, R15.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Dvě syntaxe zápisu programů podporované GNU Assemblerem</h2>

<p>Při použití <i>GNU Assembleru</i> na mikroprocesorech s&nbsp;architekturou i386 či x86-64 je možné použít dvě různé syntaxe zápisu programů. Proč vlastně k&nbsp;tomuto stavu došlo? Původní verze <i>GNU Assembleru</i> z&nbsp;historických důvodů používala zápis používaný v&nbsp;AT&amp;T (resp.&nbsp;přesněji řečeno v&nbsp;Bell Labs při vývoji Unixu). Tento zápis je sice (samozřejmě jen do určité míry) konzistentní mezi různými platformami, ovšem pro mnoho programátorů pracujících na platformách s&nbsp;procesory s&nbsp;architekturou i386 je AT&amp;T syntaxe velmi nezvyklá a taktéž nekompatibilní s&nbsp;dalšími typy assemblerů (<i>Turbo Assembler &ndash; TASM</i>, <i>Microsoft Macro Assembler &ndash; MASM</i> atd.). Proto mj.&nbsp;vznikl i projekt <i>Netwide Assembler (NASM)</i>, který i na Linux (resp.&nbsp;přesněji řečeno do jeho toolchainu) přidal podporu pro zápis programů v&nbsp;assembleru podle zvyklostí z&nbsp;jiných systémů. Změny později nastaly i v&nbsp;<i>GNU Assembleru</i>, což mj.&nbsp;znamená, že od verze 2.10 je možné se jedinou direktivou přepnout do režimu částečně kompatibilního s&nbsp;TASM/MASM. Rozdíly mezi oběma způsoby zápisu si ukážeme na praktických příkladech v&nbsp;dalších kapitolách.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Služba <strong>sys_write</strong>: zápis sekvence bajtů do souboru specifikovaného deskriptorem</h2>

<p>Prvním programem, s&nbsp;nímž se dnes seznámíme, je program typu &bdquo;Hello world!&ldquo;. Ten je možné v&nbsp;assembleru procesorů řady i386/x86-64 realizovat poměrně snadno, a to z&nbsp;toho důvodu, že samotné jádro operačního systému obsahuje systémové volání (<i>syscall</i>) pro zápis sekvence bajtů do souboru specifikovaného svým deskriptorem. My sice prozatím neumíme pracovat se soubory, to však vůbec nevadí, protože pro každý nový proces jsou automaticky vytvořeny tři deskriptory: standardní vstup, standardní výstup a chybový výstup. A právě standardní výstup použijeme pro výpis řetězce &bdquo;Hello world!&ldquo;. Na 32bitovém systému vypadá příslušný <i>syscall</i> takto:</p>

<table>
<tr><th>Registr</th><th>Význam</th><th>Obsah</th></tr>
<tr><td>eax</td><td>číslo syscallu</td><td>sys_write=4</td></tr>
<tr><td>ebx</td><td>číslo deskriptoru</td><td>stdout=1</td></tr>
<tr><td>ecx</td><td>adresa řetězce/bajtů</td><td>nastaví se do .data segmentu</td></tr>
<tr><td>edx</td><td>počet bajtů pro zápis</td><td>strlen("Hello world!\n")=13</td></tr>
</table>



<p><a name="k06"></a></p>
<h2 id="k06">6. Program typu &bdquo;Hello world!&ldquo; napsaný v&nbsp;GNU Assembleru pro i386</h2>

<p>Podívejme se, jak bude vypadat <a href="https://github.com/tisnik/presentations/blob/master/assembler/03_gas_hello_world/hello_world.s">zápis programu</a> typu &bdquo;Hello world!&ldquo; napsaný v&nbsp;GNU Assembleru pro i386. Celý program vlastně volá jen dvě služby jádra: <strong>sys_write</strong> a <strong>sys_exit</strong>. U <strong>sys_write</strong> se nastaví registry způsobem popsaným ve výše uvedené tabulce. Zajímavý je obsah registru <strong>ecx</strong>, protože ten musí obsahovat adresu řetězce (resp.&nbsp;bloku bajtů). V&nbsp;AT&amp;T syntaxi to vypadá následovně:</p>

<pre>
mov   $hello_lbl,%ecx
</pre>

<p>Přičemž <strong>hello_lbl</strong> je návěští (<i>label</i>) neboli pojmenovaná adresa. Samotný řetězec leží v&nbsp;sekci <strong>.data</strong>, která je automaticky vkládána do výsledného binárního souboru. Povšimněte si, že řetězec není ukončen znakem s&nbsp;ASCII kódem 0. To není nutné, protože systémová služba přesně zná délku řetězce (bloku bajtů):</p>

<pre>
# asmsyntax=as

# Jednoducha aplikace typu "Hello world!" naprogramovana
# v assembleru GNU as.
#
# Autor: Pavel Tisnovsky



# Linux kernel system call table
sys_exit=1
sys_write=4



#-----------------------------------------------------------------------------
.section .data

hello_lbl:
        .string "Hello World!\n"

#-----------------------------------------------------------------------------
.section .bss



#-----------------------------------------------------------------------------
.section .text
        .global _start          # tento symbol ma byt dostupny i linkeru

_start:
        mov   $sys_write, %eax  # cislo syscallu pro funkci "write"
        mov   $1,%ebx           # standardni vystup
        mov   $hello_lbl,%ecx   # adresa retezce, ktery se ma vytisknout
        mov   $13,%edx          # pocet znaku, ktere se maji vytisknout
        int   $0x80             # volani Linuxoveho kernelu

        movl  $sys_exit,%eax    # cislo sycallu pro funkci "exit"
        movl  $0,%ebx           # exit code = 0
        int   $0x80             # volani Linuxoveho kernelu
</pre>

<p>Program přeložíme a slinkujeme následujícím způsobem:</p>

<pre>
as hello_world.s -o hello_world.o
ld -s hello_world.o
</pre>

<p>Pokud vás zajímá, jak vypadá interní struktura vytvořeného spustitelného souboru a jaké (ladicí i jiné) symboly tento soubor obsahuje, můžete použít následující příkaz, který všechny potřebné informace dokáže získat a zobrazit v&nbsp;čitelné podobě. Nejzajímavější je v&nbsp;tomto okamžiku struktura nazvaná <i>SYMBOL TABLE</i> i zpětný překlad (<i>disassembly</i>):</p>

<pre>
objdump -f -d -t -h a.out
</pre>

<pre>
a.out:     file format elf64-x86-64
architecture: i386:x86-64, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x00000000004000b0

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000022  00000000004000b0  00000000004000b0  000000b0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000e  00000000006000d2  00000000006000d2  000000d2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
SYMBOL TABLE:
no symbols



Disassembly of section .text:

00000000004000b0 &lt;.text&gt;:
  4000b0:       b8 04 00 00 00          mov    $0x4,%eax
  4000b5:       bb 01 00 00 00          mov    $0x1,%ebx
  4000ba:       b9 d2 00 60 00          mov    $0x6000d2,%ecx
  4000bf:       ba 0d 00 00 00          mov    $0xd,%edx
  4000c4:       cd 80                   int    $0x80
  4000c6:       b8 01 00 00 00          mov    $0x1,%eax
  4000cb:       bb 00 00 00 00          mov    $0x0,%ebx
  4000d0:       cd 80                   int    $0x80
</pre>

<p>O tom, že se ve spustitelném souboru vyskytuje i řetězec &bdquo;Hello world!&ldquo; se přesvědčíme příkazem <strong>strings</strong>:</p>

<pre>
$ <strong>strings a.out</strong>
&nbsp;
Hello World!
.shstrtab
.text
.data
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Použití &bdquo;Intel&ldquo; syntaxe pro program typu &bdquo;Hello world&ldquo;</h2>

<p>Podívejme se nyní, jak lze zapsat tu stejnou aplikaci, ovšem s&nbsp;použitím Intel syntaxe. První změnou je použití přepínače:</p>

<pre>
.intel_syntax noprefix
</pre>

<p>Dále se prohodily operandy všech instrukcí, takže u instrukce <strong>mov</strong> je na prvním místě cílový registr (či adresa) a na místě druhém zdrojový registr, adresa či konstanta. U jmen registrů se nemusí uvádět znak dolaru a poslední významnou změnou je odlišný zápis při načítání adresy do registru:</p>

<pre>
mov   $hello_lbl,%ecx        # adresa retezce, ktery se ma vytisknout

versus

mov   ecx, offset hello_lbl  # adresa retezce, ktery se ma vytisknout
</pre>

<p><a href="https://github.com/tisnik/presentations/blob/master/assembler/06_gas_intel_hello_world/hello_world.s">Úplný program</a> vypadá následovně:</p>

<pre>
# asmsyntax=as

# Jednoducha aplikace typu "Hello world!" naprogramovana
# v assembleru GNU as - pouzita je "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix


# Linux kernel system call table
sys_exit=1
sys_write=4



#-----------------------------------------------------------------------------
.section .data

hello_lbl:
        .string "Hello World!\n"     # string, ktery JE ukoncen nulou

#-----------------------------------------------------------------------------
.section .bss



#-----------------------------------------------------------------------------
.section .text
        .global _start               # tento symbol ma byt dostupny i linkeru

_start:
        mov   eax, sys_write         # cislo syscallu pro funkci "write"
        mov   ebx, 1                 # standardni vystup
        mov   ecx, offset hello_lbl  # adresa retezce, ktery se ma vytisknout
        mov   edx, 13                # pocet znaku, ktere se maji vytisknout
        int   0x80                   # volani Linuxoveho kernelu

        mov   eax, sys_exit          # cislo sycallu pro funkci "exit"
        mov   ebx, 0                 # exit code = 0
        int   0x80                   # volani Linuxoveho kernelu
</pre>

<p>Program přeložíme a slinkujeme stejným způsobem, jako předchozí verzi:</p>

<pre>
as hello_world.s -o hello_world.o
ld -s hello_world.o
</pre>

<p>Při zkoumání výsledného spustitelného binárního souboru máme dvě možnosti. Buď použít nám již známé volání, které používá disassembler kompatibilní se syntaxí AT&amp;T:</p>

<pre>
objdump -f -d -t -h a.out
</pre>

<p>Alternativně je však možné se přepnout i na syntaxi kompatibilní s&nbsp;překladači typu NASM či TASM:</p>

<pre>
objdump -M intel-mnemonic -f -d -t -h a.out
</pre>

<p>Ve druhém případě bude výsledek do značné míry podobný původnímu zdrojovému kódu:</p>

<pre>
a.out:     file format elf64-x86-64
architecture: i386:x86-64, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x00000000004000b0

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000022  00000000004000b0  00000000004000b0  000000b0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000e  00000000006000d2  00000000006000d2  000000d2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
SYMBOL TABLE:
no symbols



Disassembly of section .text:

00000000004000b0 &lt;.text&gt;:
  4000b0:       b8 04 00 00 00          mov    eax,0x4
  4000b5:       bb 01 00 00 00          mov    ebx,0x1
  4000ba:       b9 d2 00 60 00          mov    ecx,0x6000d2
  4000bf:       ba 0d 00 00 00          mov    edx,0xd
  4000c4:       cd 80                   int    0x80
  4000c6:       b8 01 00 00 00          mov    eax,0x1
  4000cb:       bb 00 00 00 00          mov    ebx,0x0
  4000d0:       cd 80                   int    0x80
</pre>




<p><a name="k08"></a></p>
<h2 id="k08">8. Vizuální rozdíl: AT&amp;T syntaxe versus Intel syntaxe</h2>

<p>Rozdíly mezi oběma způsoby zápisu jsou dobře patrné ve chvíli, kdy si oba zdrojové soubory zobrazíme vedle sebe, což je provedeno na následujícím screenshotu:</p>

<a href="http://mojefedora.cz/wp-content/uploads/2016/06/01_att_vs_intel.png"><img src="http://mojefedora.cz/wp-content/uploads/2016/06/01_att_vs_intel-488x254.png" alt="01_att_vs_intel" width="488" height="254" class="alignnone size-thumbnail wp-image-7246" /></a>

<p>Obrázek ve vyšším rozlišení naleznete na adrese <a href="https://raw.githubusercontent.com/tisnik/presentations/master/assembler/att_vs_intel.png">https://raw.githubusercontent.com/tisnik/presentations/master/assembler/att_vs_intel.png</a>.</p>

<p>Poznámka: oba výsledné soubory jsou po překladu do nativního kódu samozřejmě zcela identické!</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Přepis programu typu &bdquo;Hello world!&ldquo; do syntaxe Netwide Assembleru (NASM)</h2>

<p>Pokusme se nyní přepsat program z&nbsp;GNU Assembleru do Netwide Assembleru (NASM). Uvidíme, že samotný zápis je sice v&nbsp;mnoha ohledech odlišný (jiný formát komentářů či zápisů konstant, zjednodušení při práci s&nbsp;adresami), ovšem základní koncepty zůstávají zachovány. Nejdříve se podívejme na <a href="https://github.com/tisnik/presentations/blob/master/assembler/04_nasm_hello_world_A/hello_world.asm">zdrojový kód</a> programu. Samotný popis rozdílů bude uveden posléze:</p>

<pre>
; asmsyntax=nasm

; Jednoducha aplikace typu "Hello world!" naprogramovana
; v assembleru NASM.
;
; Autor: Pavel Tisnovsky



; Linux kernel system call table
sys_exit  equ 1
sys_write equ 4



;-----------------------------------------------------------------------------
section .data
        hello:        db 'Hello world!',10



;-----------------------------------------------------------------------------
section .bss



;-----------------------------------------------------------------------------
section .text
        global _start           ; tento symbol ma byt dostupny i linkeru

_start:
        mov   eax,sys_write     ; cislo syscallu pro funkci "write"
        mov   ebx,1             ; standardni vystup
        mov   ecx,hello         ; adresa retezce, ktery se ma vytisknout
        mov   edx,13            ; pocet znaku, ktere se maji vytisknout
        int   80h               ; volani Linuxoveho kernelu

        mov   eax,sys_exit      ; cislo sycallu pro funkci "exit"
        mov   ebx,0             ; exit code = 0
        int   80h               ; volani Linuxoveho kernelu
</pre>

<p>Vidíme, že se liší zápis komentářů, které zde začínají znakem středníku. U GNU Assembleru je práce s&nbsp;komentáři poněkud problematická, protože na různých architekturách se používají odlišné znaky (zavináč atd.). Středníky mají výhodu ve snadném zápisu (bez shiftu) i v&nbsp;dlouhé tradici použití tohoto znaku i v&nbsp;jiných assemblerech (opět viz TASM a MASM). Odlišný je taktéž způsob deklarace konstant, protože pro celočíselné konstanty je nutné použít zápis <strong>jméno equ hodnota</strong> (opět se jedná o určitou tradici, i když s&nbsp;poněkud horší čitelností oproti zápisu <strong>jméno=hodnota</strong>). Rozdíl je i v&nbsp;deklaraci řetězce, kdy se používá zápis:</p>

<pre>
hello:        db 'Hello world!',10
</pre>

<p>U tohoto zápisu je zajímavé, že se skutečně předepisuje vytvoření bloku bajtů zakončeného hodnotou 10 (konec řádku), zatímco v&nbsp;případě GNU Assembleru se navíc za řetězec vložila nula, která je zde zhola zbytečná (nejedná se o céčkový řetězec ani s&nbsp;ním tak nepracujeme). Mimochodem, <strong>db</strong> znamená &bdquo;define byte&ldquo;, samozřejmě se tedy můžeme setkat i s&nbsp;deklaracemi <strong>dw</strong> (&bdquo;define word&ldquo;), <strong>dd</strong> (&bdquo;define double word&ldquo;) či <strong>dq</strong> (&bdquo;define quad word&ldquo;). Poslední viditelnou změnou je určité zjednodušení načtení adresy, kdy se (v&nbsp;některých případech) nemusí používat pomocné slovo <strong>offset</strong> ani <strong>byte ptr</strong> apod. Pokud by se namísto adresy mělo pracovat přímo s&nbsp;hodnotou uloženou na této adrese, je nutné použít složené závory (což si ukážeme příště).</p>

<p>Překlad na 32bitové architektuře zajistí příkazy:</p>

<pre>
nasm -felf32 hello_world.asm
ld -s hello_world.o
</pre>

<p>Na 64bitové architektuře použijeme mírně odlišný zápis:</p>

<pre>
nasm -felf64 hello_world.asm
ld -s hello_world.o
</pre>

<p>Jen pro zajímavost se můžeme přesvědčit, že se překlad provedl (až na chybějící nulu na konci řetězce) stejně, jako v&nbsp;předchozím příkladu (liší se délka sekce <strong>.data</strong> o jedničku):</p>

<pre>
$ ./disassemble

a.out:     file format elf64-x86-64
architecture: i386:x86-64, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x00000000004000b0

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000022  00000000004000b0  00000000004000b0  000000b0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000d  00000000006000d4  00000000006000d4  000000d4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
SYMBOL TABLE:
no symbols



Disassembly of section .text:

00000000004000b0 &lt;.text&gt;:
  4000b0:       b8 04 00 00 00          mov    $0x4,%eax
  4000b5:       bb 01 00 00 00          mov    $0x1,%ebx
  4000ba:       b9 d4 00 60 00          mov    $0x6000d4,%ecx
  4000bf:       ba 0d 00 00 00          mov    $0xd,%edx
  4000c4:       cd 80                   int    $0x80
  4000c6:       b8 01 00 00 00          mov    $0x1,%eax
  4000cb:       bb 00 00 00 00          mov    $0x0,%ebx
  4000d0:       cd 80                   int    $0x80
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Vizuální rozdíl: Intel syntaxe v&nbsp;GNU Assembleru versus NASM</h2>

<p>Opět se podívejme na rozdíly mezi oběma způsoby zápisu. Budeme porovnávat zápis programu v&nbsp;GNU Assembleru při použití syntaxe Intel a zápis programu v&nbsp;Netwide Assembleru (porovnání syntaxe AT&amp;T s&nbsp;NASM by totiž nebylo příliš přínosné, rozdílů je zde příliš mnoho):</p>

<a href="http://mojefedora.cz/wp-content/uploads/2016/06/02_gas_vs_nasm.png"><img src="http://mojefedora.cz/wp-content/uploads/2016/06/02_gas_vs_nasm-489x254.png" alt="02_gas_vs_nasm" width="489" height="254" class="alignnone size-thumbnail wp-image-7247" /></a>

<p>Obrázek ve vyšším rozlišení naleznete na adrese <a href="https://raw.githubusercontent.com/tisnik/presentations/master/assembler/gas_vs_nasm.png">https://raw.githubusercontent.com/tisnik/presentations/master/assembler/gas_vs_nasm.png</a>.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Vylepšená verze výpočtu délky řetězce</h2>

<p>Programy, které jsme si až doposud ukazovali, měly jednu nepříjemnou vlastnost &ndash; při volání systémové funkce <strong>sys_write</strong> jsme museli zadávat délku řetězce formou konstanty (13), kterou jsme vypočetli ručně. Pokud by se řetězec změnil, bylo by nutné tuto konstantu ve zdrojovém kódu najít a opravit. Ve skutečnosti však můžeme program vylepšit, a to relativně jednoduchým trikem. Nejdříve se podívejme, jak se tento trik zapisuje:</p>

<pre>
hello:        db 'Hello world!',10
; $ obsahuje aktualni adresu v dobe prekladu
helloLength   equ $-hello
</pre>

<p>Nejdříve je deklarován blok bajtů obsahující řetězec ukončený znakem pro odřádkování, což pro nás není nic nového. Následně je ovšem použit zápis <strong>$-hello</strong>. Znak $ má v&nbsp;Netwide assembleru (ale nejenom zde) speciální význam, protože je nahrazen za aktuální adresu spočtenou v&nbsp;době překladu pro daný programový řádek (resp.&nbsp;pro jeho začátek). Tato adresa odpovídá adrese návěští <strong>hello</strong> zvýšené přesně o délku řetězce, což znamená, že výpočet probíhá při překladu takto <strong>$-hello=(hello+délka_řetězce)-hello=délka_řetězce</strong>. A tato hodnota přesně odpovídá hodnotě, kterou musíme předat systémovému volání:</p>

<pre>
; asmsyntax=nasm

; Jednoducha aplikace typu "Hello world!" naprogramovana
; v assembleru NASM.
;
; Autor: Pavel Tisnovsky



; Linux kernel system call table
sys_exit  equ 1
sys_write equ 4



;-----------------------------------------------------------------------------
section .data
        hello:        db 'Hello world!',10
        ; $ obsahuje aktualni adresu v dobe prekladu
        helloLength   equ $-hello



;-----------------------------------------------------------------------------
section .bss



;-----------------------------------------------------------------------------
section .text
        global _start           ; tento symbol ma byt dostupny i linkeru

_start:
        mov   eax,sys_write     ; cislo syscallu pro funkci "write"
        mov   ebx,1             ; standardni vystup
        mov   ecx,hello         ; adresa retezce, ktery se ma vytisknout
        mov   edx,helloLength   ; helloLength je konstanta, nikoli adresa!
        int   80h               ; volani Linuxoveho kernelu

        mov   eax,sys_exit      ; cislo sycallu pro funkci "exit"
        mov   ebx,0             ; exit code = 0
        int   80h               ; volani Linuxoveho kernelu
</pre>

<p>Překlad a slinkování se provede naprosto stejným způsobem, jako tomu bylo v&nbsp;předchozím příkladu.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Přepis programu pro architekturu S/390 a S/390x</h2>

<p>Pro zajímavost se podívejme, jak se &bdquo;Hello world!&ldquo; napíše pro mainframy S/390 a S/390x. Tuto úpravu provedl Dan Horák, kterému opět děkuji:</p>

<h3>Program &bdquo;Hello world&ldquo; pro S/390</h3>

<pre>
# asmsyntax=as

# Jednoducha aplikace typu "Hello world!" naprogramovana
# v assembleru GNU as.
#
# Autor: Pavel Tisnovsky
#        Dan Horak



# Linux kernel system call table
sys_exit=1
sys_write=4



#-----------------------------------------------------------------------------
.section .data

hello_lbl:
        .string "Hello World!\n"

#-----------------------------------------------------------------------------
.section .bss



#-----------------------------------------------------------------------------
.section .text
        .global _start          # tento symbol ma byt dostupny i linkeru

_start:
        basr  13,0              # nastaveni literal poolu
.L0:    ahi   13,.LT0-.L0
        la    1,sys_write       # cislo syscallu pro funkci "write"
        la    2,1               # standardni vystup
        l     3,.LC1-.LT0(13)   # adresa retezce, ktery se ma vytisknout
        la    4,13              # pocet znaku, ktere se maji vytisknout
        svc   0                 # volani Linuxoveho kernelu

        la    1,sys_exit        # cislo sycallu pro funkci "exit"
        la    2,0               # exit code = 0
        svc   0                 # volani Linuxoveho kernelu

# literal pool
.LT0:
.LC1:   .long   hello_lbl
</pre>



<h3>Program &bdquo;Hello world&ldquo; pro S/390x</h3>

<p>Verze pro 64bitovou architekturu je jednodušší a do značné míry odpovídá variantě aplikace určené pro procesory s&nbsp;architekturou i386. Odlišují se jen jména registrů (zde pouze indexy) a mnemotechnické zkratky instrukcí (<strong>SVC</strong>=Supervisor Call atd.):</p>

<pre>
# asmsyntax=as

# Jednoducha aplikace typu "Hello world!" naprogramovana
# v assembleru GNU as.
#
# Autor: Pavel Tisnovsky
#        Dan Horak



# Linux kernel system call table
sys_exit=1
sys_write=4



#-----------------------------------------------------------------------------
.section .data

hello_lbl:
        .string "Hello World!\n"

#-----------------------------------------------------------------------------
.section .bss



#-----------------------------------------------------------------------------
.section .text
        .global _start          # tento symbol ma byt dostupny i linkeru

_start:
        la    1,sys_write       # cislo syscallu pro funkci "write"
        la    2,1               # standardni vystup
        larl  3,hello_lbl       # adresa retezce, ktery se ma vytisknout
        la    4,13              # pocet znaku, ktere se maji vytisknout
        svc   0                 # volani Linuxoveho kernelu

        la    1,sys_exit        # cislo sycallu pro funkci "exit"
        la    2,0               # exit code = 0
        svc   0                 # volani Linuxoveho kernelu
</pre>

<p>Poznámka: trik s&nbsp;výpočtem délky řetězce s&nbsp;využitím $ je samozřejmě možné provést i v&nbsp;tomto příkladu.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Repositář se zdrojovými kódy demonstračních příkladů</h2>

<p>Všechny dnes popisované demonstrační příklady byly společně s&nbsp;podpůrnými skripty uloženy do GIT repositáře dostupného na adrese <a href="https://github.com/tisnik/presentations/">https://github.com/tisnik/presentations/</a>. Následuje tabulka s&nbsp;odkazy na zdrojové kódy příkladů i na již zmíněné podpůrné skripty:</p>

<h3>Hello world v&nbsp;GNU Assembleru</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>hello_world.s      </td><td>program pro i386/x86-64     </td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/03_gas_hello_world/hello_world.s">https://github.com/tisnik/presentations/blob/master/assembler/03_gas_hello_world/hello_world.s</a></td></tr>
<tr><td>2</td><td>hello_world-s390.s </td><td>program pro s/390           </td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/03_gas_hello_world/hello_world-s390.s">https://github.com/tisnik/presentations/blob/master/assembler/03_gas_hello_world/hello_world-s390.s</a></td></tr>
<tr><td>3</td><td>hello_world-s390x.s</td><td>program pro s/390x          </td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/03_gas_hello_world/hello_world-s390x.s">https://github.com/tisnik/presentations/blob/master/assembler/03_gas_hello_world/hello_world-s390x.s</a></td></tr>
<tr><td>4</td><td>as_ibm_s390        </td><td>skript pro překlad na s/390 </td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/03_gas_hello_world/as_ibm_s390">https://github.com/tisnik/presentations/blob/master/assembler/03_gas_hello_world/as_ibm_s390</a></td></tr>
<tr><td>5</td><td>as_ibm_s390x       </td><td>skript pro překlad na s/390x</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/03_gas_hello_world/as_ibm_s390x">https://github.com/tisnik/presentations/blob/master/assembler/03_gas_hello_world/as_ibm_s390x</a></td></tr>
<tr><td>6</td><td>assemble           </td><td>skript pro překlad na i386  </td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/03_gas_hello_world/assemble">https://github.com/tisnik/presentations/blob/master/assembler/03_gas_hello_world/assemble</a></td></tr>
<tr><td>7</td><td>disassemble        </td><td>skript pro disassembling    </td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/03_gas_hello_world/disassemble">https://github.com/tisnik/presentations/blob/master/assembler/03_gas_hello_world/disassemble</a></td></tr>
</table>

<img src="http://mojefedora.cz/wp-content/uploads/2016/06/03.png" alt="03" width="660" height="642" class="alignnone size-full wp-image-7248" />



<h3>Hello world v&nbsp;GNU Assembleru, Intel syntaxe</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>hello_world.s      </td><td>program pro i386/x86-64     </td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/06_gas_intel_hello_world/hello_world.s">https://github.com/tisnik/presentations/blob/master/assembler/06_gas_intel_hello_world/hello_world.s</a></td></tr>
<tr><td>2</td><td>assemble           </td><td>skript pro překlad na i386  </td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/06_gas_intel_hello_world/assemble">https://github.com/tisnik/presentations/blob/master/assembler/06_gas_intel_hello_world/assemble</a></td></tr>
<tr><td>3</td><td>disassemble        </td><td>skript pro disassembling    </td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/06_gas_intel_hello_world/disassemble">https://github.com/tisnik/presentations/blob/master/assembler/06_gas_intel_hello_world/disassemble</a></td></tr>
</table>

<img src="http://mojefedora.cz/wp-content/uploads/2016/06/04.png" alt="04" width="660" height="658" class="alignnone size-full wp-image-7249" />



<h3>Hello world v&nbsp;Netwide Assembleru</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>hello_world.asm    </td><td>program pro NASM            </td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/04_nasm_hello_world_A/hello_world.asm">https://github.com/tisnik/presentations/blob/master/assembler/04_nasm_hello_world_A/hello_world.asm</a></td></tr>
<tr><td>2</td><td>assemble_i386      </td><td>skript pro překlad na i386  </td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/04_nasm_hello_world_A/assemble_i386">https://github.com/tisnik/presentations/blob/master/assembler/04_nasm_hello_world_A/assemble_i386</a></td></tr>
<tr><td>3</td><td>assemble_x86_64    </td><td>skript pro překlad na x86/64</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/04_nasm_hello_world_A/assemble_x86_64">https://github.com/tisnik/presentations/blob/master/assembler/04_nasm_hello_world_A/assemble_x86_64</a></td></tr>
<tr><td>4</td><td>disassemble        </td><td>skript pro disassembling    </td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/04_nasm_hello_world_A/disassemble">https://github.com/tisnik/presentations/blob/master/assembler/04_nasm_hello_world_A/disassemble</a></td></tr>
</table>

<img src="http://mojefedora.cz/wp-content/uploads/2016/06/05.png" alt="05" width="660" height="642" class="alignnone size-full wp-image-7250" />



<h3>Hello world v&nbsp;Netwide Assembleru, vylepšený výpočet délky řetězce</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>hello_world.asm    </td><td>program pro NASM            </td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/05_nasm_hello_world_B/hello_world.asm">https://github.com/tisnik/presentations/blob/master/assembler/05_nasm_hello_world_B/hello_world.asm</a></td></tr>
<tr><td>2</td><td>assemble_i386      </td><td>skript pro překlad na i386  </td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/05_nasm_hello_world_B/assemble_i386">https://github.com/tisnik/presentations/blob/master/assembler/05_nasm_hello_world_B/assemble_i386</a></td></tr>
<tr><td>3</td><td>assemble_x86_64    </td><td>skript pro překlad na x86/64</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/05_nasm_hello_world_B/assemble_x86_64">https://github.com/tisnik/presentations/blob/master/assembler/05_nasm_hello_world_B/assemble_x86_64</a></td></tr>
<tr><td>4</td><td>disassemble        </td><td>skript pro disassembling    </td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/05_nasm_hello_world_B/disassemble">https://github.com/tisnik/presentations/blob/master/assembler/05_nasm_hello_world_B/disassemble</a></td></tr>
</table>

<img src="http://mojefedora.cz/wp-content/uploads/2016/06/06.png" alt="06" width="660" height="674" class="alignnone size-full wp-image-7251" />



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Assembler pod Linuxem<br />
<a href="http://phoenix.inf.upol.cz/linux/prog/asm.html">http://phoenix.inf.upol.cz/linux/prog/asm.html</a>
</li>

<li>AT&amp;T Syntax versus Intel Syntax<br />
<a href="https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html">https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html</a>
</li>

<li>Linux Assembly website<br />
<a href="http://asm.sourceforge.net/">http://asm.sourceforge.net/</a>
</li>

<li>Using Assembly Language in Linux<br />
<a href="http://asm.sourceforge.net/articles/linasm.html">http://asm.sourceforge.net/articles/linasm.html</a>
</li>

<li>vasm<br />
<a href="http://sun.hasenbraten.de/vasm/">http://sun.hasenbraten.de/vasm/</a>
</li>

<li>vasm &ndash; dokumentace<br />
<a href="http://sun.hasenbraten.de/vasm/release/vasm.html">http://sun.hasenbraten.de/vasm/release/vasm.html</a>
</li>

<li>The Yasm Modular Assembler Project<br />
<a href="http://yasm.tortall.net/">http://yasm.tortall.net/</a>
</li>

<li>680x0:AsmOne<br />
<a href="http://www.amigacoding.com/index.php/680x0:AsmOne">http://www.amigacoding.com/index.php/680x0:AsmOne</a>
</li>

<li>ASM-One Macro Assembler<br />
<a href="http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler">http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler</a>
</li>

<li>ASM-One pages<br />
<a href="http://www.theflamearrows.info/documents/asmone.html">http://www.theflamearrows.info/documents/asmone.html</a>
</li>

<li>Základní informace o ASM-One<br />
<a href="http://www.theflamearrows.info/documents/asminfo.html">http://www.theflamearrows.info/documents/asminfo.html</a>
</li>

<li>Linux Syscall Reference<br />
<a href="http://syscalls.kernelgrok.com/">http://syscalls.kernelgrok.com/</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>IBM System 360/370 Compiler and Historical Documentation<br />
<a href="http://www.edelweb.fr/Simula/">http://www.edelweb.fr/Simula/</a>
</li>

<li>IBM 700/7000 series<br />
<a href="http://en.wikipedia.org/wiki/IBM_700/7000_series">http://en.wikipedia.org/wiki/IBM_700/7000_series</a>
</li>

<li>IBM System/360<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/360">http://en.wikipedia.org/wiki/IBM_System/360</a>
</li>

<li>IBM System/370<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/370">http://en.wikipedia.org/wiki/IBM_System/370</a>
</li>

<li>Mainframe family tree and chronology<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html</a>
</li>

<li>704 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html</a>
</li>

<li>705 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html</a>
</li>

<li>The IBM 704<br />
<a href="http://www.columbia.edu/acis/history/704.html">http://www.columbia.edu/acis/history/704.html</a>
</li>

<li>IBM Mainframe album<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html</a>
</li>

<li>Osmibitové muzeum<br />
<a href="http://osmi.tarbik.com/">http://osmi.tarbik.com/</a>
</li>

<li>Tesla PMI-80<br />
<a href="http://osmi.tarbik.com/cssr/pmi80.html">http://osmi.tarbik.com/cssr/pmi80.html</a>
</li>

<li>PMI-80<br />
<a href="http://en.wikipedia.org/wiki/PMI-80">http://en.wikipedia.org/wiki/PMI-80</a>
</li>

<li>PMI-80<br />
<a href="http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016">http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

