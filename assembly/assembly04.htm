<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Použití assembleru v Linuxu: podmínky, rozvětvení a programové smyčky</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Použití assembleru v Linuxu: podmínky, rozvětvení a programové smyčky</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve čtvrté části článku o použití assembleru (nejenom) v&nbsp;Linuxu se budeme zabývat technikami využívanými pro tvorbu podmínek a taktéž různých typů programových smyček v&nbsp;assembleru, což je problematika, která na většině v&nbsp;současnosti používaných mikroprocesorových architektur vyžaduje práci s&nbsp;takzvanými příznaky (či příznakovými bity).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Podmíněné a nepodmíněné skoky jako základ pro realizaci rozvětvení a programových smyček</a></p>
<p><a href="#k02">2. Strojové instrukce určené pro provedení skoku na architekturách i386 a x86_64</a></p>
<p><a href="#k03">3. Základní příznakové bity na architekturách i386 a x86_64</a></p>
<p><a href="#k04">4. Vybrané instrukce pro podmíněné skoky založené na testování příznakových bitů</a></p>
<p><a href="#k05">5. Použití instrukcí <strong>DEC</strong> a <strong>JZN</strong> pro implementaci počítané programové smyčky</a></p>
<p><a href="#k06">6. Odlišná realizace počítané smyčky s&nbsp;instrukcemi <strong>DEC</strong>, <strong>JZ</strong> a <strong>JMP</strong></a></p>
<p><a href="#k07">7. Praktický příklad &ndash; jednoduchá počítaná programová smyčka</a></p>
<p><a href="#k08">8. Další praktický příklad &ndash; počítaná programová smyčka s&nbsp;testem na začátku</a></p>
<p><a href="#k09">9. Použití instrukce <strong>CMP</strong> v&nbsp;součinnosti s&nbsp;podmíněným skokem</a></p>
<p><a href="#k10">10. Praktický příklad &ndash; počítaná smyčka s&nbsp;volitelným začátkem a koncem</a></p>
<p><a href="#k11">11. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Podmíněné a nepodmíněné skoky jako základ pro realizaci rozvětvení a programových smyček</h2>

<p>Velmi důležitým typem strojových instrukcí, které v&nbsp;různé podobě najdeme prakticky u všech modelů mikroprocesorů (resp.&nbsp;přesněji řečeno u mikroprocesorů všech dnes rozšířených mikroprocesorových architektur), jsou instrukce provádějící skoky na nějakou adresu v&nbsp;operační paměti. Implementace skoku není, alespoň na první pohled a u jednodušších architektur bez instrukční pipeline, vlastně nijak složitá, protože se v&nbsp;případě použití <i>absolutní adresy</i> dosadí hodnota z&nbsp;operačního kódu instrukce do registru <i>PC</i> a v&nbsp;případě použití <i>relativní adresy</i> se tato hodnota (nazývaná někdy poněkud nepřesně <i>offset</i>) přičte k&nbsp;aktuální hodnotě registru <i>PC</i>. Relativní adresa je v&nbsp;tomto případě v&nbsp;kódu instrukce uložena se znaménkem, proto se skok může provést dozadu i dopředu (ostatně právě použití relativní adresy uvidíme v&nbsp;dále popisovaných demonstračních příkladech).</p>

<p>Skoky většinou dělíme podle jednoho kritéria (formy zápisu adresy) na <i>absolutní</i> a <i>relativní</i> a podle kritéria druhého (za jakým okolností se skok provede) na skoky <i>podmíněné</i> a <i>nepodmíněné</i>. V&nbsp;závislosti na použité instrukční sadě jsou možné různé kombinace, typicky však u většiny mikroprocesorů nalezneme kombinace nepodmíněný absolutní skok, nepodmíněný relativní skok a podmíněný relativní skok. Skoky nepodmíněné jsou jednodušší a svou podstatou odpovídají příkazu <strong>goto</strong> známého z&nbsp;některých programovacích jazyků a také z&nbsp;mnoha článků, ve kterých autoři mnohdy bez hlubšího zamyšlení se nad původní myšlenkou opakují, že by se <strong>goto</strong> nemělo při strukturovaném programování používat :-). V&nbsp;assembleru se však skoky vesele používají, neboť právě pomocí nich se vytváří základní konstrukce strukturovaného programování &ndash; podmínky a programové smyčky.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Strojové instrukce určené pro provedení skoku na architekturách i386 a x86_64</h2>

<p>U architektury mikroprocesorů 32bitové řady i386 a taktéž 64bitové řady x86-64 je základní strojovou instrukcí určenou pro provedení <i>nepodmíněného skoku</i> instrukce nazvaná jednoduše a přímočaře <strong>JMP</strong> (což je, jak jste zajisté zjistili, mnemotechnická zkratka slova <i>jump</i>). V&nbsp;assembleru většinou za mnemotechnickou zkratkou jména instrukce následuje návěští (<i>label</i>), z&nbsp;něhož assembler odvodí reálnou adresu. Ukažme si typický špagetový kód vznikající nadbytečným použitím této instrukce:</p>

<pre>
# asmsyntax=as
 
# Ukazka spagetoveho kodu s instrukci typu JMP
# - pouzita je "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky
 
.intel_syntax noprefix
 
 
 
# Linux kernel system call table
sys_exit=1
 
 
 
#-----------------------------------------------------------------------------
.section .data
 
 
 
#-----------------------------------------------------------------------------
.section .bss
 
 
 
#-----------------------------------------------------------------------------
.section .text
        .global _start               # tento symbol ma byt dostupny i linkeru
 
_start:
        jmp   l1
l4:     
        mov   eax, sys_exit          # cislo sycallu pro funkci "exit"
        mov   ebx, 0                 # exit code = 0
        int   0x80                   # volani Linuxoveho kernelu

l2:     jmp   l3

l1:     jmp   l2

l3:     jmp   l4
</pre>

<p>Překlad vypadá takto (skoky jsou zde relativní a tudíž velmi krátké &ndash; celá instrukce má délku pouhé dva bajty):</p>

<pre>
0000000000400078 &lt;.text&gt;
  400078:       eb 0e                   jmp    0x400088 ; relativní skok vpřed
  40007a:       b8 01 00 00 00          mov    eax,0x1
  40007f:       bb 00 00 00 00          mov    ebx,0x0
  400084:       cd 80                   int    0x80
  400086:       eb 02                   jmp    0x40008a ; relativní skok o 3 adresy dál
  400088:       eb fc                   jmp    0x400086 ; relativní skok zpět (druhá hodnota je se znaménkem)
  40008a:       eb ee                   jmp    0x40007a ; relativní skok zpět (druhá hodnota je se znaménkem)
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Základní příznakové bity na architekturách i386 a x86_64</h2>

<p>Alternativně je možné použít i další způsoby adresování, čímž se například implementuje tabulka skoků (jedna z&nbsp;možných realizací stavového automatu) atd., ovšem tyto techniky pro účely dnešního článku prozatím nepotřebujeme znát. Mnohem zajímavější jsou <i>podmíněné skoky</i>, které se při programování v&nbsp;assembleru či ve strojovém kódu používají pro implementaci programových smyček <strong>while</strong>, <strong>do-while</strong>, <strong>for</strong> a taktéž konstrukcí typu <strong>if-then-else</strong> atd. Podmíněný skok je proveden či naopak neproveden na základě nějaké podmínky. Vzhledem k&nbsp;tomu, že pracujeme na té nejnižší programové úrovni, tj.&nbsp;na úrovni strojových instrukcí, není samozřejmě možné podmínku definovat nějakým složitým a sofistikovaným způsobem &ndash; musí se jednat o operaci, kterou mikroprocesor dokáže jednoduše a především dostatečně rychle zpracovat (i přesto představují skoky úzké místo v&nbsp;programech).</p>

<p>Z&nbsp;tohoto prostého důvodu &ndash; podmínky musí být realizovány dostatečně jednoduchým způsobem pro snadnou implementaci na čipu &ndash; jsou na mikroprocesorových architekturách i386 a x86-64 podmínky založeny na testování jednoho z&nbsp;takzvaných příznakových bitů, negací těchto bitů či dokonce jejich kombinací. Pokud z&nbsp;důvodu zjednodušení výkladu celé relativně rozsáhlé problematiky budeme ignorovat některé speciálnější příznaky a především pak rozdíly mezi hodnotami bez znaménka (unsigned) a se znaménkem (signed), můžeme zpočátku použít především příznaky nazvané <strong>Carry flag</strong>, <strong>Sign flag</strong> a <strong>Zero flag</strong>, tj.&nbsp;<i>příznak přenosu</i>, <i>příznak záporného výsledku</i> a <i>příznak nulovosti</i>. Význam těchto příznakových bitů se shrnut v&nbsp;následující tabulce:</p>

<table>
<tr><th>Příznak</th><th>Význam zkratky</th><th>Poznámka</th></tr>
<tr><td>ZF</td><td>zero flag</td><td>výsledek předchozí operace je nulový</td></tr>
<tr><td>CF</td><td>carry flag</td><td>přenos (bezznaménková aritmetika)</td></tr>
<tr><td>SF</td><td>sign flag</td><td>výsledek je záporný (nastaven nejvyšší bit bajtu či slova)</td></tr>
</table>

<p>V&nbsp;případě, že alespoň prozatím nebudeme brát v&nbsp;úvahu další příznakové bity, existuje šest základních variant podmíněného skoku, které jsou vypsány v&nbsp;tabulce <a href="#k04">v&nbsp;navazující kapitole</a>. Ve chvíli, kdy podmínka není splněna (tj.&nbsp;testovaný příznakový bit má opačnou hodnotu než očekávanou), není skok proveden, tj.&nbsp;mikroprocesor instrukci skoku v&nbsp;podstatě ignoruje a pokračuje v&nbsp;načtení instrukce uvedené ihned za skokem (to, že mikroprocesor instrukci skoku ignoruje samozřejmě platí jen z&nbsp;pohledu logiky vytvářeného programu; samotné provedení instrukce muselo proběhnout a tudíž se program o několik strojových taktů pozdržel &ndash; i neprovedení podmíněného kroku si tedy vyžádalo svou cenu).</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Vybrané instrukce pro podmíněné skoky založené na testování příznakových bitů</h2>

<p>Strojové instrukce určené pro provedení podmíněných skoků jsou ve své základní variantě (existují pro ně totiž i jmenné aliasy) pojmenovány jednoduše a přímočaře &ndash; začínají písmenem <strong>J</strong> (jump), za nímž následuje volitelné písmeno <strong>N</strong> (negace) a jednoznaková zkratka příznaku. Instrukce <strong>JNC</strong> tedy znamená &bdquo;proveď skok, pokud příznak Carry není nastaven&ldquo;, zatímco instrukce <strong>JZ</strong> znamená &bdquo;proveď skok pouze při nastavení příznaku Zero&ldquo;:</p>

<table>
<tr><th>Mnemotechnická zkratka instrukce</th><th>Význam instrukce podmíněného skoku</th></tr>
<tr><td>JC </td><td>podmíněný skok za předpokladu, že je nastaven příznak přenosu (<strong>Carry flag</strong>)</td></tr>
<tr><td>JNC</td><td>podmíněný skok za předpokladu, že je vynulován příznak přenosu (<strong>Carry flag</strong>)</td></tr>
<tr><td>JZ </td><td>podmíněný skok za předpokladu, že je nastaven příznak nulovosti (<strong>Zero flag</strong>)</td></tr>
<tr><td>JNZ</td><td>podmíněný skok za předpokladu, že je vynulován příznak nulovosti (<strong>Zero flag</strong>)</td></tr>
<tr><td>JS </td><td>podmíněný skok za předpokladu, že je nastaven příznak záporného výsledku (<strong>Sign flag</strong>)</td></tr>
<tr><td>JNS</td><td>podmíněný skok za předpokladu, že je vynulován příznak záporného výsledku (<strong>Sign flag</strong>)</td></tr>
</table>

<p>Jmenné aliasy:</p>

<table>
<tr><th>Instrukce</th><th>Alias</th></tr>
<tr><td>JZ </td><td>JE </td></tr>
<tr><td>JNZ</td><td>JNE</td></tr>
<tr><td>JC </td><td>JB, JNAE</td></tr>
<tr><td>JNC</td><td>JNB, JAE</td></tr>
<tr><td>JS </td><td>nemá alias</td></tr>
<tr><td>JNS</td><td>nemá alias</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. Použití instrukcí <strong>DEC</strong> a <strong>JZN</strong> pro implementaci počítané programové smyčky</h2>

<p><a href="#k04">V&nbsp;předchozí kapitole</a> jsme si řekli, že podmíněné relativní skoky jsou použity pro implementaci programových smyček a podmínek. K&nbsp;tomuto účelu se podmíněné skoky prakticky vždy vhodně kombinují s&nbsp;některou instrukcí, která modifikuje jeden příznakový bit či dokonce větší množství příznakových bitů. Například jednoduchou počítanou programovou smyčku by bylo možné implementovat s&nbsp;využitím kombinace strojových instrukcí <strong>DEC</strong> a <strong>JNZ</strong>. Instrukce nazvaná <strong>DEC</strong> snižuje obsah specifikovaného pracovního registru o jedničku a současně nastavuje příznak nuly, tj.&nbsp;<strong>Zero flag (ZF)</strong>, samozřejmě ovšem pouze za předpokladu, že ten pracovní registr, jehož hodnota se snižuje, skutečně dosáhl nulové hodnoty. Instrukce <strong>JNZ</strong> znamená podmíněný skok, který je proveden pouze tehdy, pokud příznak nuly <i>není</i> nastaven (&bdquo;jump if not zero&ldquo;, viz též předchozí kapitolu).</p>

<p>Před samotným začátkem programové smyčky je samozřejmě nutné do pracovního registru nastavit potřebný počet opakování, který by měl být ideálně odlišný od nuly. Ostatně zkuste si sami odpovědět na otázku, co by se stalo v&nbsp;případě, kdy by pracovní registr použitý jako počitadlo, byl před vstupem do smyčky vynulovaný. Podívejme se nyní na způsob použití 32bitového registru EAX ve funkci počitadla. Vzhledem k&nbsp;tomu, že se testuje pouze nulovost registru po snížení jeho hodnoty o jedničku, může tato smyčka být provedena 0&times; až 2<sup>32</sup>-1&times; (ignoruje se znaménko):</p>

<pre>
        MOV EAX, počet_opakování ; počet opakování smyčky
SMYCKA: příkaz 1                 ; libovolné instrukce, jejichž celková
        příkaz 2                 ; celková délka bloku musí být menší než cca 120 bytů
        ...                      ; (kvůli omezení relativního skoku, pokud se délka překročí, použije se delší instrukce)
        ...
        ...
        příkaz X
        DEC EAX                  ; snížení čítače smyčky o jedničku
        JNZ SMYCKA               ; přeloží se jako relativní skok
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Odlišná realizace počítané smyčky s&nbsp;instrukcemi <strong>DEC</strong>, <strong>JZ</strong> a <strong>JMP</strong></h2>

<p>Podmínku ovšem můžeme naopak přesunout i na samotný začátek smyčky. Nyní se ovšem namísto instrukce pro podmíněný skok <strong>JNZ</strong> použije instrukce <strong>JZ</strong> v&nbsp;kombinaci s&nbsp;instrukcí nepodmíněného skoku <strong>JMP</strong>:</p>

<pre>
        MOV EAX, počet_opakování ; počet opakování smyčky
SMYCKA: DEC EAX                  ; snížení čítače smyčky o jedničku
        JZ  KONEC                ; přeloží se jako relativní skok
        příkaz 1                 ; libovolné instrukce, jejichž celková
        příkaz 2                 ; celková délka bloku musí být menší než cca 120 bytů
        ...                      ; (kvůli omezení relativního skoku, pokud se délka překročí, použije se delší instrukce)
        ...
        ...
        příkaz X
        JMP SMYCKA               ; nepodmíněný skok na začátek smyčky
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Praktický příklad &ndash; jednoduchá počítaná programová smyčka</h2>

<p>Podívejme se nyní na způsob realizace velmi jednoduché počítané programové smyčky naprogramované v&nbsp;assembleru mikroprocesorů s&nbsp;architekturou i386 a x86_64 (používají se však pouze 32bitové registry). V&nbsp;tomto příkladu je dynamicky vytvořen buffer pro čtyřicet ASCII znaků. Do tohoto bufferu se v&nbsp;programové smyčce následně vypíše čtyřicet hvězdiček. Počitadlo smyčky je uloženo v&nbsp;32bitovém pracovním registru EBX, adresa začátku bufferu v&nbsp;registru ECX a zapisovaný znak v&nbsp;osmibitovém pracovním registru AL (součást registru EAX). Řetězec čtyřiceti znaků je následně vypsán na standardní výstup nám již důvěrně známou funkcí <strong>sys_write</strong>:</p>
 
<pre>
# asmsyntax=as
 
# Testovaci program naprogramovany v assembleru GNU as
# - pocitana programova smycka
# - pouzita je "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky
 
.intel_syntax noprefix
 
 
# Linux kernel system call table
sys_exit=1
sys_write=4
 
# pocet opakovani znaku
rep_count=40
 
 
 
#-----------------------------------------------------------------------------
.section .data
 
 
 
#-----------------------------------------------------------------------------
.section .bss
        .lcomm buffer, rep_count     # rezervace bufferu pro vystup
 
 
 
#-----------------------------------------------------------------------------
.section .text
        .global _start               # tento symbol ma byt dostupny i linkeru
 
_start:
        mov   ecx, offset buffer     # zapis se bude provadet do tohoto bufferu
        mov   ebx, rep_count         # pocet opakovani znaku
        mov   al,  '*'               # zapisovany znak
loop:
        mov   [ecx], al              # zapis znaku do bufferu
        inc   ecx                    # uprava ukazatele do bufferu
        dec   ebx                    # zmenseni pocitadla
        jnz   loop                   # pokud jsme se nedostali k nule, skok na zacatek smycky
 
        mov   eax, sys_write         # cislo syscallu pro funkci "write"
        mov   ebx, 1                 # standardni vystup
        mov   ecx, offset buffer     # adresa retezce, ktery se ma vytisknout
        mov   edx, rep_count         # pocet znaku, ktere se maji vytisknout
        int   0x80                   # volani Linuxoveho kernelu
 
        mov   eax, sys_exit          # cislo sycallu pro funkci "exit"
        mov   ebx, 0                 # exit code = 0
        int   0x80                   # volani Linuxoveho kernelu
</pre>

<p>Překlad se provede takto:</p>

<pre>
as loop1.s -o loop1.o
ld -s loop1.o
</pre>

<p>Zajímavé bude se podívat na způsob překladu aplikace a na realizaci podmíněného skoku:</p>

<pre>
objdump -M intel-mnemonic -f -d -t -h a.out
</pre>

<pre>
a.out:     file format elf64-x86-64
architecture: i386:x86-64, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x00000000004000b0

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000037  00000000004000b0  00000000004000b0  000000b0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000030  00000000006000e8  00000000006000e8  000000e8  2**3
                  ALLOC
SYMBOL TABLE:
no symbols



Disassembly of section .text:

00000000004000b0 &lt;.text&gt;:
  4000b0:       b9 e8 00 60 00          mov    ecx,0x6000e8
  4000b5:       bb 28 00 00 00          mov    ebx,0x28
  4000ba:       b0 2a                   mov    al,0x2a
  4000bc:       67 88 01                mov    BYTE PTR [ecx],al
  4000bf:       ff c1                   inc    ecx
  4000c1:       ff cb                   dec    ebx
  4000c3:       75 f7                   jne    0x4000bc
  4000c5:       b8 04 00 00 00          mov    eax,0x4
  4000ca:       bb 01 00 00 00          mov    ebx,0x1
  4000cf:       b9 e8 00 60 00          mov    ecx,0x6000e8
  4000d4:       ba 28 00 00 00          mov    edx,0x28
  4000d9:       cd 80                   int    0x80
  4000db:       b8 01 00 00 00          mov    eax,0x1
  4000e0:       bb 00 00 00 00          mov    ebx,0x0
  4000e5:       cd 80                   int    0x80
</pre>

<p>Poznámky:</p>

<ol>

<li>Podmíněný skok ve zdrojovém kódu realizujeme instrukcí <strong>JNZ</strong>, která se ve výpisu zobrazuje jako <strong>JNE</strong>, což je ovšem jen jmenný alias.</li>

<li>Strojová instrukce pro podmíněný skok má délku pouhé dva bajty: 75 f7. První bajt je operační kód, druhý bajt pak číslo se znaménkem, které je větší než 0x7f, což naznačuje skok <i>zpět</i>.</li>

<li>Pokud by tělo smyčky překročilo přibližně 120 bajtů, byla by instrukce pro skok delší (některé assemblery ovšem vypíšou varování či dokonce chybu a vyžadují explicitní použití &bdquo;dlouhého&ldquo; skoku).</li>

</ol>



<p><a name="k08"></a></p>
<h2 id="k08">8. Další praktický příklad &ndash; počítaná programová smyčka s&nbsp;testem na začátku</h2>

<p>V&nbsp;dalším demonstračním příkladu je ukázána počítaná programová smyčka, v&nbsp;níž se test na ukončení provádí na jejím začátku po odečtení jedničky od počitadla. Tento příklad je vlastně v&nbsp;mnoha ohledech totožný s&nbsp;příkladem předchozím, ovšem vzhledem k&nbsp;tomu, že změna stavu počitadla (snížení jeho hodnoty o jedničku) a následný test je proveden na začátku smyčky, je nutné při inicializaci počitadla do něj vložit hodnotu 41 a nikoli 40, jinak by se vytisklo pouze 39 hvězdiček následovaných ASCII znakem s&nbsp;kódem nula:</p>

<pre>
# asmsyntax=as
 
# Testovaci program naprogramovany v assembleru GNU as
# - pocitana programova smycka s testem na zacatku
# - pouzita je "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky
 
.intel_syntax noprefix
 
 
# Linux kernel system call table
sys_exit=1
sys_write=4
 
# pocet opakovani znaku
rep_count=40
 
 
 
#-----------------------------------------------------------------------------
.section .data
 
 
 
#-----------------------------------------------------------------------------
.section .bss
        .lcomm buffer, rep_count     # rezervace bufferu pro vystup
 
 
 
#-----------------------------------------------------------------------------
.section .text
        .global _start               # tento symbol ma byt dostupny i linkeru
 
_start:
        mov   ecx, offset buffer     # zapis se bude provadet do tohoto bufferu
        mov   ebx, rep_count+1       # pocet opakovani znaku+1 (protoze se dec+test provadi na zacatku)
        mov   al,  '*'               # zapisovany znak
loop:
        dec   ebx                    # zmenseni pocitadla
        jz    konec                  # pokud jsme se dostali k nule, konec smycky
        mov   [ecx], al              # zapis znaku do bufferu
        inc   ecx                    # uprava ukazatele do bufferu
        jmp   loop                   # nepodmineny skok na zacatek smycky
konec:

        mov   eax, sys_write         # cislo syscallu pro funkci "write"
        mov   ebx, 1                 # standardni vystup
        mov   ecx, offset buffer     # adresa retezce, ktery se ma vytisknout
        mov   edx, rep_count         # pocet znaku, ktere se maji vytisknout
        int   0x80                   # volani Linuxoveho kernelu
 
        mov   eax, sys_exit          # cislo sycallu pro funkci "exit"
        mov   ebx, 0                 # exit code = 0
        int   0x80                   # volani Linuxoveho kernelu
</pre>

<p>Překlad se provede takto:</p>

<pre>
as loop2.s -o loop2.o
ld -s loop2.o
</pre>

<p>Opět se podívejme na zpětný překlad (disassembling), aby bylo patrné, jakým způsobem se přeloží podmíněný i nepodmíněný skok:</p>

<pre>
objdump -M intel-mnemonic -f -d -t -h a.out
</pre>

<pre>
a.out:     file format elf64-x86-64
architecture: i386:x86-64, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x00000000004000b0

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000039  00000000004000b0  00000000004000b0  000000b0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000030  00000000006000f0  00000000006000f0  000000f0  2**3
                  ALLOC
SYMBOL TABLE:
no symbols



Disassembly of section .text:

00000000004000b0 &lt;.text&gt;:
  4000b0:       b9 f0 00 60 00          mov    ecx,0x6000f0
  4000b5:       bb 29 00 00 00          mov    ebx,0x29
  4000ba:       b0 2a                   mov    al,0x2a
  4000bc:       ff cb                   dec    ebx
  4000be:       74 07                   je     0x4000c7
  4000c0:       67 88 01                mov    BYTE PTR [ecx],al
  4000c3:       ff c1                   inc    ecx
  4000c5:       eb f5                   jmp    0x4000bc
  4000c7:       b8 04 00 00 00          mov    eax,0x4
  4000cc:       bb 01 00 00 00          mov    ebx,0x1
  4000d1:       b9 f0 00 60 00          mov    ecx,0x6000f0
  4000d6:       ba 28 00 00 00          mov    edx,0x28
  4000db:       cd 80                   int    0x80
  4000dd:       b8 01 00 00 00          mov    eax,0x1
  4000e2:       bb 00 00 00 00          mov    ebx,0x0
  4000e7:       cd 80                   int    0x80
</pre>

<p>Poznámky:</p>

<ol>

<li>Podmíněný skok ve zdrojovém kódu realizujeme instrukcí <strong>JZ</strong>, která se ve výpisu zobrazuje jako <strong>JE</strong>, což je opět pouze jmenný alias.</li>

<li>Strojová instrukce pro podmíněný skok má znovu délku pouhé dva bajty a z&nbsp;druhého bajtu (0x07) vidíme, že je proveden skok <i>vpřed</i> (o osm bajtů počítáno od začátku skoku).</li>

<li>Pokud by tělo smyčky překročilo přibližně 120 bajtů, byla by instrukce pro skok delší (některé assemblery ovšem vypíšou varování či dokonce chybu a vyžadují explicitní použití &bdquo;dlouhého&ldquo; skoku).</li>

<li>Nepodmíněný skok je taktéž realizován s&nbsp;použitím relativní adresy, takže délka této instrukce je pouhé dva bajty. Druhý bajt instrukce je větší než 0x7f, takže se jedná o skok <i>zpět</i>.</li>

</ol>



<p><a name="k09"></a></p>
<h2 id="k09">9. Použití instrukce <strong>CMP</strong> v&nbsp;součinnosti s&nbsp;podmíněným skokem</h2>

<p>Společně s&nbsp;podmíněnými skoky se velmi často používá doposud nepopsaná instrukce nazvaná <strong>CMP</strong> (mnemotechnická zkratka od slova <i>compare</i>). V&nbsp;podstatě se jedná o běžné celočíselné odečítání, tj.&nbsp;o instrukci nazvanou <strong>SUB</strong>, ovšem s&nbsp;tím důležitým rozdílem, že výsledek, tj.&nbsp;samotný rozdíl, není nikam zapsán, což znamená, že se obsah běžných pracovních registrů provedením této instrukce nezmění. Na první pohled může vypadat tato instrukce nesmyslně &ndash; proč se vůbec mají odečítat dvě hodnoty, když se výsledek hned zapomene? Ovšem samotný výsledek není ve skutečnosti vše, protože při odečítání si mikroprocesor v&nbsp;příznakových registrech zapamatuje i to, zda byla odečítaná čísla shodná (tehdy se nastaví <strong>Zero flag</strong> na jedničku) či zda byla druhá hodnota větší než hodnota první (příznak <strong>Carry flag</strong> bude v&nbsp;tomto případě roven jedné).</p>

<p>Instrukce <strong>CMP</strong> akceptuje různé typy operandů; může se jednat o běžné pracovní registry, ovšem použít lze i konstanty či obsah získaný ze zvolené adresy operační paměti. V&nbsp;následující tabulce si ukážeme, jaké příznaky se nastaví při provedení různých variant funkce <strong>CMP</strong>:</p>

<table>
<tr><th>První operand</th><th>Druhý operand</th><th>Zero flag</th><th>Carry flag</th><th>Význam</th></tr>
<tr><td>00</td><td>00</td><td>1</td><td>0</td><td>obě hodnoty jsou shodné</td></tr>
<tr><td>42</td><td>42</td><td>1</td><td>0</td><td>obě hodnoty jsou shodné</td></tr>
<tr><td>20</td><td>10</td><td>0</td><td>0</td><td>první hodnota je větší (nedošlo k&nbsp;přenosu)</td></tr>
<tr><td>10</td><td>20</td><td>0</td><td>1</td><td>druhá hodnota je větší (došlo k&nbsp;přenosu)</td></tr>
</table>

<p>Poznámka: ve skutečnosti by v&nbsp;tomto případě (odečítání a porovnávání) bylo korektnější mluvit o takzvané <i>výpůjčce (borrow)</i> a nikoli o <i>přenosu (carry)</i>.</p>

<p>Z&nbsp;těchto příkladů současně nepřímo vyplývá i to, jak můžeme příznakové bity použít. Jestliže je zapotřebí testovat dvě hodnoty na rovnost, postačí zjistit, zda je <strong>Zero flag</strong> nastavený na jedničku (ostatně i z&nbsp;tohoto důvodu má podmíněný skok <strong>JZ</strong> alias <strong>JE</strong> &ndash; jump if equal). Pokud potřebujeme otestovat, jestli je první hodnota menší než druhá, lze zjistit hodnotu příznaku <strong>Carry flag</strong> atd. Test na nulovou hodnotu lze provést odečtením nuly &ndash; výsledek bude uložen v&nbsp;<strong>Zero flagu</strong> (ve skutečnosti se ovšem tento test většinou neprovádí, protože i některé další instrukce dokážou nastavit tento příznak automaticky a vlastně &bdquo;mimochodem&ldquo;). Podobně je tomu u testování, zda je hodnota kladná či záporná. Podívejme se na několik možností použití:</p>

<pre>
; test na rovnost dvou hodnot
MOV EAX, hodnota 1
MOV EBX, hodnota 2
CMP EAX, EBX
JZ  JE_ROVNO    ; skok na kód provedený v případě rovnosti
JNZ NENI_ROVNO  ; skok na kód provedený v případě nerovnosti
</pre>

<pre>
; zjištění relace dvou čísel
MOV EAX, hodnota 1
MOV EBX, hodnota 2
CMP EAX, EBX
JNC EAX_JE_VETSI_NEBO_ROVNO_EBX
JC  EAX_JE_MENSI_NEZ_EBX
</pre>

<pre>
; test na nulovost
MOV EAX, hodnota
SUB EBX,EBX       ; vynulování registru EBX (lze i XOR EBX,EBX)
CMP EAX,EBX
JZ  EAX_JE_NULOVE
</pre>

<pre>
; test na nulovost
MOV EAX, hodnota
CMP EAX,0
JZ  EAX_JE_NULOVE
</pre>

<pre>
; test na kladnou či zápornou hodnou
MOV EAX, hodnota
CMP EAX,0
JS  EAX_JE_ZAPORNE
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Praktický příklad &ndash; počítaná smyčka s&nbsp;volitelným začátkem a koncem</h2>

<p>Dnešní poslední demonstrační příklad opět ukazuje realizaci počítané programové smyčky, tentokrát se ovšem ve smyčce vytváří řetězec obsahující znaky od 'a' do 'z'. Pro test na ukončení smyčky se používá kombinace instrukcí <strong>CMP+JNZ</strong> pro porovnání, zda aktuálně zapisovaný znak nepřekročil hodnotu 'z' (v&nbsp;předchozích příkladech se prováděl test na nulu). Povšimněte si, že se ve zdrojovém kódu mohou zapisovat i složitější konstantní výrazy typu 'z'+1 či dokonce 'z'-'a'+1:</p>

<pre>
# asmsyntax=as
 
# Testovaci program naprogramovany v assembleru GNU as
# - smycka vyuzivajici instrukci CMP
# - pouzita je "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky
 
.intel_syntax noprefix
 
 
# Linux kernel system call table
sys_exit=1
sys_write=4
 
# pocet opakovani znaku
rep_count='z'-'a'+1
 
 
 
#-----------------------------------------------------------------------------
.section .data
 
 
 
#-----------------------------------------------------------------------------
.section .bss
        .lcomm buffer, rep_count     # rezervace bufferu pro vystup
 
 
 
#-----------------------------------------------------------------------------
.section .text
        .global _start               # tento symbol ma byt dostupny i linkeru
 
_start:
        mov   ecx, offset buffer     # zapis se bude provadet do tohoto bufferu
        mov   al, 'a'                # kod prvniho zapisovaneho znaku
loop:
        mov   [ecx], al              # zapis znaku do bufferu
        inc   al                     # ASCII kod dalsiho znaku
        inc   ecx                    # uprava ukazatele do bufferu
        cmp   al, 'z'+1              # ma se smycka ukoncit?
        jnz   loop                   # pokud jsme neprekrocili kod 'z', opakovat smycku
 
        mov   eax, sys_write         # cislo syscallu pro funkci "write"
        mov   ebx, 1                 # standardni vystup
        mov   ecx, offset buffer     # adresa retezce, ktery se ma vytisknout
        mov   edx, rep_count         # pocet znaku, ktere se maji vytisknout
        int   0x80                   # volani Linuxoveho kernelu
 
        mov   eax, sys_exit          # cislo sycallu pro funkci "exit"
        mov   ebx, 0                 # exit code = 0
        int   0x80                   # volani Linuxoveho kernelu
</pre>

<p>Překlad se provede následovně:</p>

<pre>
as loop3.s -o loop3.o
ld -s loop3.o
</pre>

<p>Zpětný překlad (disassembling) prozradí způsob překladu:</p>

<pre>
objdump -M intel-mnemonic -f -d -t -h a.out
</pre>

<pre>
a.out:     file format elf64-x86-64
architecture: i386:x86-64, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x00000000004000b0

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000034  00000000004000b0  00000000004000b0  000000b0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000020  00000000006000e8  00000000006000e8  000000e8  2**3
                  ALLOC
SYMBOL TABLE:
no symbols



Disassembly of section .text:

00000000004000b0 &lt;.text&gt;:
  4000b0:       b9 e8 00 60 00          mov    ecx,0x6000e8
  4000b5:       b0 61                   mov    al,0x61
  4000b7:       67 88 01                mov    BYTE PTR [ecx],al
  4000ba:       fe c0                   inc    al
  4000bc:       ff c1                   inc    ecx
  4000be:       3c 7b                   cmp    al,0x7b
  4000c0:       75 f5                   jne    0x4000b7
  4000c2:       b8 04 00 00 00          mov    eax,0x4
  4000c7:       bb 01 00 00 00          mov    ebx,0x1
  4000cc:       b9 e8 00 60 00          mov    ecx,0x6000e8
  4000d1:       ba 1a 00 00 00          mov    edx,0x1a
  4000d6:       cd 80                   int    0x80
  4000d8:       b8 01 00 00 00          mov    eax,0x1
  4000dd:       bb 00 00 00 00          mov    ebx,0x0
  4000e2:       cd 80                   int    0x80
</pre>

<p>Díky tomu, že zapisovaný znak je uložený v&nbsp;osmibitovém registru AL, je zvýšení tohoto registru o jedničku a test na mezní hodnotu realizován velmi krátkými strojovými instrukcemi <strong>inc al</strong> a <strong>cmp al, 0x7b</strong>.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny čtyři dnes popisované demonstrační příklady byly společně s&nbsp;podpůrnými skripty určenými pro překlad či naopak pro disassembling uloženy do GIT repositáře dostupného na adrese <a href="https://github.com/tisnik/presentations/">https://github.com/tisnik/presentations/</a>. Všechny dnešní příklady jsou, na rozdíl od některých příkladů vysvětlených minule a předminule, určené pro GNU Assembler a používají &bdquo;Intel&ldquo; syntaxi. Následuje tabulka s&nbsp;odkazy na zdrojové kódy příkladů i na již zmíněné podpůrné skripty:</p>



<h3>Špagetový kód realizovaný instrukcí nepodmíněného skoku JMP</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>jumps.s    </td><td>program pro GNU Assembler        </td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/14_spaghetti_code/jumps.s">https://github.com/tisnik/presentations/blob/master/assembler/14_spaghetti_code/jumps.s</a></td></tr>
<tr><td>2</td><td>assemble   </td><td>skript pro překlad na i386/x86_64</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/14_spaghetti_code/assemble">https://github.com/tisnik/presentations/blob/master/assembler/14_spaghetti_code/assemble</a></td></tr>
<tr><td>3</td><td>disassemble</td><td>skript pro disassembling         </td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/14_spaghetti_code/disassemble">https://github.com/tisnik/presentations/blob/master/assembler/14_spaghetti_code/disassemble</a></td></tr>
</table>



<h3>Počítaná programová smyčka s&nbsp;testem prováděným na začátku</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>loop1.s    </td><td>program pro GNU Assembler        </td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/11_gas_loop/loop1.s">https://github.com/tisnik/presentations/blob/master/assembler/11_gas_loop/loop1.s</a></td></tr>
<tr><td>2</td><td>assemble   </td><td>skript pro překlad na i386/x86_64</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/11_gas_loop/assemble">https://github.com/tisnik/presentations/blob/master/assembler/11_gas_loop/assemble</a></td></tr>
<tr><td>3</td><td>disassemble</td><td>skript pro disassembling         </td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/11_gas_loop/disassemble">https://github.com/tisnik/presentations/blob/master/assembler/11_gas_loop/disassemble</a></td></tr>
</table>



<h3>Počítaná programová smyčka s&nbsp;testem prováděným na konci</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>loop2.s    </td><td>program pro GNU Assembler        </td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/12_gas_loop/loop2.s">https://github.com/tisnik/presentations/blob/master/assembler/12_gas_loop/loop2.s</a></td></tr>
<tr><td>2</td><td>assemble   </td><td>skript pro překlad na i386/x86_64</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/12_gas_loop/assemble">https://github.com/tisnik/presentations/blob/master/assembler/12_gas_loop/assemble</a></td></tr>
<tr><td>3</td><td>disassemble</td><td>skript pro disassembling         </td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/12_gas_loop/disassemble">https://github.com/tisnik/presentations/blob/master/assembler/12_gas_loop/disassemble</a></td></tr>
</table>



<h3>Počítaná smyčka s&nbsp;volitelným začátkem a koncem</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>loop3.s    </td><td>program pro GNU Assembler        </td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/13_gas_loop/loop3.s">https://github.com/tisnik/presentations/blob/master/assembler/13_gas_loop/loop3.s</a></td></tr>
<tr><td>2</td><td>assemble   </td><td>skript pro překlad na i386/x86_64</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/13_gas_loop/assemble">https://github.com/tisnik/presentations/blob/master/assembler/13_gas_loop/assemble</a></td></tr>
<tr><td>3</td><td>disassemble</td><td>skript pro disassembling         </td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/13_gas_loop/disassemble">https://github.com/tisnik/presentations/blob/master/assembler/13_gas_loop/disassemble</a></td></tr>
</table>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>Intel x86 JUMP quick reference<br />
<a href="http://unixwiz.net/techtips/x86-jumps.html">http://unixwiz.net/techtips/x86-jumps.html</a>
</li>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Assembler pod Linuxem<br />
<a href="http://phoenix.inf.upol.cz/linux/prog/asm.html">http://phoenix.inf.upol.cz/linux/prog/asm.html</a>
</li>

<li>AT&amp;T Syntax versus Intel Syntax<br />
<a href="https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html">https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html</a>
</li>

<li>Linux Assembly website<br />
<a href="http://asm.sourceforge.net/">http://asm.sourceforge.net/</a>
</li>

<li>Using Assembly Language in Linux<br />
<a href="http://asm.sourceforge.net/articles/linasm.html">http://asm.sourceforge.net/articles/linasm.html</a>
</li>

<li>vasm<br />
<a href="http://sun.hasenbraten.de/vasm/">http://sun.hasenbraten.de/vasm/</a>
</li>

<li>vasm &ndash; dokumentace<br />
<a href="http://sun.hasenbraten.de/vasm/release/vasm.html">http://sun.hasenbraten.de/vasm/release/vasm.html</a>
</li>

<li>The Yasm Modular Assembler Project<br />
<a href="http://yasm.tortall.net/">http://yasm.tortall.net/</a>
</li>

<li>680x0:AsmOne<br />
<a href="http://www.amigacoding.com/index.php/680x0:AsmOne">http://www.amigacoding.com/index.php/680x0:AsmOne</a>
</li>

<li>ASM-One Macro Assembler<br />
<a href="http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler">http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler</a>
</li>

<li>ASM-One pages<br />
<a href="http://www.theflamearrows.info/documents/asmone.html">http://www.theflamearrows.info/documents/asmone.html</a>
</li>

<li>Základní informace o ASM-One<br />
<a href="http://www.theflamearrows.info/documents/asminfo.html">http://www.theflamearrows.info/documents/asminfo.html</a>
</li>

<li>Linux Syscall Reference<br />
<a href="http://syscalls.kernelgrok.com/">http://syscalls.kernelgrok.com/</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>IBM System 360/370 Compiler and Historical Documentation<br />
<a href="http://www.edelweb.fr/Simula/">http://www.edelweb.fr/Simula/</a>
</li>

<li>IBM 700/7000 series<br />
<a href="http://en.wikipedia.org/wiki/IBM_700/7000_series">http://en.wikipedia.org/wiki/IBM_700/7000_series</a>
</li>

<li>IBM System/360<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/360">http://en.wikipedia.org/wiki/IBM_System/360</a>
</li>

<li>IBM System/370<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/370">http://en.wikipedia.org/wiki/IBM_System/370</a>
</li>

<li>Mainframe family tree and chronology<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html</a>
</li>

<li>704 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html</a>
</li>

<li>705 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html</a>
</li>

<li>The IBM 704<br />
<a href="http://www.columbia.edu/acis/history/704.html">http://www.columbia.edu/acis/history/704.html</a>
</li>

<li>IBM Mainframe album<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html</a>
</li>

<li>Osmibitové muzeum<br />
<a href="http://osmi.tarbik.com/">http://osmi.tarbik.com/</a>
</li>

<li>Tesla PMI-80<br />
<a href="http://osmi.tarbik.com/cssr/pmi80.html">http://osmi.tarbik.com/cssr/pmi80.html</a>
</li>

<li>PMI-80<br />
<a href="http://en.wikipedia.org/wiki/PMI-80">http://en.wikipedia.org/wiki/PMI-80</a>
</li>

<li>PMI-80<br />
<a href="http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016">http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

