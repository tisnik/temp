<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Použití assembleru v Linuxu: konvence při volání knihovních funkcí na mikroprocesorech ARM</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Použití assembleru v Linuxu: konvence při volání knihovních funkcí na mikroprocesorech ARM</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Předchozí článek, v&nbsp;němž jsme si ve stručnosti popsali konvence používané při volání knihovních funkcí na mikroprocesorech s&nbsp;64bitovou architekturou x86-64, dnes doplníme, protože si řekneme, jakým způsobem se volají knihovní funkce na 32bitových mikroprocesorech s&nbsp;architekturou ARM. Dnešní díl tedy bude zaměřen více prakticky, neboť assembler se na ARMech s&nbsp;velkou pravděpodobností používá častěji, než je tomu na obecně výkonnějších 64bitových čipech x86-64, které jsou navíc určeny pro odlišný segment trhu.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Použití assembleru v&nbsp;Linuxu: konvence při volání knihovních funkcí na mikroprocesorech ARM</a></p>
<p><a href="#k02">2. Kostra programu napsaného v&nbsp;assembleru se subrutinou <strong>main</strong></a></p>
<p><a href="#k03">3. První demonstrační příklad &ndash; návrat ze subrutiny <strong>main</strong> s&nbsp;předáním návratového kódu</a></p>
<p><a href="#k04">4. Alternativní způsob ukončení subrutiny <strong>main</strong> instrukcí <strong>bx</strong></a></p>
<p><a href="#k05">5. Druhý demonstrační příklad &ndash; použití instrukce <strong>bx</strong></a></p>
<p><a href="#k06">6. Uložení návratové adresy na zásobník</a></p>
<p><a href="#k07">7. Třetí demonstrační příklad &ndash; uložení návratové adresy na zásobník</a></p>
<p><a href="#k08">8. Uložení návratové adresy i registrů, které se používají v&nbsp;subrutině</a></p>
<p><a href="#k09">9. Čtvrtý demonstrační příklad &ndash; uložení a obnova obsahu pracovních registrů</a></p>
<p><a href="#k10">10. Volání knihovní funkce <strong>puts()</strong> z&nbsp;assembleru</a></p>
<p><a href="#k11">11. Pátý demonstrační příklad &ndash; zavolání funkce <strong>puts()</strong></a></p>
<p><a href="#k12">12. Spuštění příkladu v&nbsp;debuggeru</a></p>
<p><a href="#k13">13. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Použití assembleru v&nbsp;Linuxu: konvence při volání knihovních funkcí na mikroprocesorech ARM</h2>

<p>Na <a href="https://mojefedora.cz/pouziti-assembleru-v-linuxu-volani-funkci-ze-standardni-knihovny-jazyka-c/">předchozí díl</a> seriálu o použití assembleru v&nbsp;Linuxu, v&nbsp;němž jsme si popsali způsob volání funkcí standardní céčkové knihovny na 64bitových mikroprocesorech s&nbsp;architekturou x86-64, dnes navážeme, protože si řekneme a na několika demonstračních příkladech ukážeme, jakým způsobem je možné provést stejnou činnost, nyní ovšem na 32bitových RISCových mikroprocesorech s&nbsp;architekturou ARM. Jen pro úplnost si připomeňme některé instrukce, které na těchto mikroprocesorech existují a s&nbsp;nimiž se setkáme v&nbsp;navazujících kapitolách. Mnemotechnické zkratky těchto instrukcí i jejich chování se (podle očekávání) odlišují od procesorů Intel:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>MOV</td><td>přenos dat mezi registry, načtení konstanty do registru atd.</td></tr>
<tr><td>2</td><td>B</td><td>nepodmíněný skok popř.&nbsp;skok při splnění určené podmínky</td></tr>
<tr><td>3</td><td>BL</td><td>skok do podprogramu (<i>branch and link</i>)</td></tr>
<tr><td>4</td><td>BX</td><td>skok + přepnutí mikroprocesoru do režimu Thumb či zpět</td></tr>
<tr><td>5</td><td>STM</td><td>uložení vybrané skupiny registrů do operační paměti</td></tr>
<tr><td>6</td><td>LDM</td><td>načtení vybrané skupiny registrů z&nbsp;operační paměti</td></tr>
</table>

<p>Základní instrukcí skoku je instrukce pojmenovaná jednoduše <strong>B</strong>, což je zkratka odvozená od slova <i>branch</i>. 32bitové slovo této instrukce je rozděleno na tři části. V&nbsp;nejvyšších čtyřech bitech se nachází kód podmínky, což v&nbsp;důsledku znamená, že jediná instrukce <strong>B</strong> může nahradit všechny formy podmíněných skoků (přesněji řečeno čtrnáct typů podmíněných skoků a jeden skok nepodmíněný). Za těmito čtyřmi bity následuje taktéž čtyřbitový operační kód <strong>1010</strong> a ve zbylých 24 bitech instrukčního slova je pak uložena konstanta, z&nbsp;níž se vypočítá offset skoku. Skok je vždy proveden na adresu dělitelnou čtyřmi, tudíž je při výpočtu offsetu 24bitová konstanta posunuta o dva bity doleva.</p>

<p>Další důležitou instrukcí mikroprocesorů ARM je instrukce sloužící pro skok do podprogramu. Zatímco na mnoha jiných architekturách mikroprocesorů se ukládá návratová adresa do zásobníku, na mikroprocesorech ARM je pro uložení návratové hodnoty použit pracovní registr <i>R14</i> nazývaný z&nbsp;tohoto důvodu taktéž <i>link register</i>. Pro skok do podprogramu se používá instrukce <strong>BL</strong>, neboli <i>branch and link</i>. Při provádění této instrukce provede mikroprocesor ve skutečnosti dvě operace: vypočítá adresu skoku stejným způsobem, jako tomu bylo u instrukce <strong>B</strong> (<i>branch</i>) a uloží tuto adresu do registru <i>R15/PC</i> (tato adresa se použije pro načtení následující instrukce). Současně však taktéž vloží adresu <i>aktuální PC-4</i> do registru <i>R14/LR</i>, protože právě hodnota <i>aktuální PC-4</i> je adresou instrukce ležící těsně ZA instrukcí skoku (nesmíme zapomenout na to, že se při provedení skoku ve skutečnosti již obsah registru <i>PC</i> stačil dvakrát zvýšit o hodnotu 4).</p>

<p>V&nbsp;dalších příkladech budeme často používat instrukci určenou pro výskok (resp.&nbsp;přesněji řečeno návrat) z&nbsp;podprogramu. Zajímavé je, že ve skutečnosti žádná speciální instrukce typu <strong>RET</strong> nebo <strong>RETURN</strong> na mikroprocesorech ARM neexistuje. Vše, co musí programátor udělat, je obnovit obsah registru <i>R15/PC</i> z&nbsp;registru <i>R14</i>, a to prostým přesunem dat:</p>

<pre>
mov PC, LR
</pre>

<p>U mikroprocesorů ARM podporujících instrukční sadu Thumb, popřípadě i technologii Jazelle (bajtkód JVM) existují i další typy skokových instrukcí. Pro přehlednost jsou všechny skokové instrukce vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>B  </td><td>prostý skok</td></tr>
<tr><td>2</td><td>BL </td><td>skok + uložení návratové hodnoty do link registru</td></tr>
<tr><td>3</td><td>BX </td><td>skok + přepnutí do režimu Thumb či zpět</td></tr>
<tr><td>4</td><td>BLX</td><td>kombinace instrukcí BL+BX</td></tr>
<tr><td>5</td><td>BXJ</td><td>skok + přepnutí do režimu Jazelle</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Kostra programu napsaného v&nbsp;assembleru se subrutinou <strong>main</strong></h2>

<p>Připomeňme si nejdříve, jak vlastně vypadala kostra toho nejjednoduššího programu napsaného v&nbsp;assembleru 32bitových mikroprocesorů ARM. Celý program se skládal pouze ze tří instrukcí, které nejprve naplnily pracovní registry <strong>r0</strong> (návratový kód, který lze načíst v&nbsp;shellu) a <strong>r7</strong> (číslo syscallu, tedy číslo funkce jádra, která se má zavolat) a následně se instrukcí <strong>SVC</strong> zavolalo jádro operačního systému. Tato sekvence instrukcí začínala na návěští se jménem <strong>_start</strong>. Toto jméno je velmi důležité, neboť právě podle něho linker pozná, kam má umístit vstupní bod do programu. Pro jistou si celou kostru aplikace ještě jednou ukažme (povšimněte si, že komentáře je nutné zapisovat znakem @, neboť znak # je vyhrazen pro zápis konstanty; určitou výjimkou jsou komentáře umístěné na samostatném řádku):</p>

<pre>
# asmsyntax=as

# Sablona pro zdrojovy kod Linuxoveho programu naprogramovaneho
# v assembleru GNU AS.
#
# Autor: Pavel Tisnovsky



# Linux kernel system call table
sys_exit=1



#-----------------------------------------------------------------------------
.section .data



#-----------------------------------------------------------------------------
.section .bss



#-----------------------------------------------------------------------------
.section .text
        <strong>.global _start</strong>      @ tento symbol ma byt dostupny i z linkeru

<strong>_start</strong>:
        mov   r7,$sys_exit  @ cislo sycallu pro funkci "exit"
        mov   r0,#0         @ exit code = 0
        svc   0             @ volani Linuxoveho kernelu
</pre>

<p>Podobně jako je tomu na architektuře x86-64, i na ARMech platí, že pokud se pro překlad assemblerovského programu použije nástroj <strong>gcc</strong>, bude kostra aplikace vypadat poněkud odlišně v&nbsp;porovnání s&nbsp;programy, s&nbsp;nimiž jsme se až doposud setkávali. Je tomu tak z&nbsp;toho prostého důvodu, že <strong>gcc</strong> implicitně vytvoří vstupní bod (<i>entry point</i>) do programu, který je označen návěštím <strong>_start</strong> a obsahuje nativní kód získaný z&nbsp;objektového souboru <strong>crt0.o</strong>. Tento kód volá funkci/subrutinu <strong>main</strong>, z&nbsp;níž se musí řízení programu na konci nějakým způsobem vrátit. Ukončení aplikace vypadá poměrně jednoduše: do registru <strong>r0</strong> se uloží návratový kód a následně se řízení programu vrátí ze subrutiny <strong>main</strong> do volajícího kódu. Instrukce <strong>ret</strong> sice na ARMech neexistuje, to ovšem nevadí, jak již ostatně víme <a href="#k01">z&nbsp;předchozí kapitoly</a>, protože ji můžeme jednoduše nahradit instrukcí <strong>mov PC, LR</strong>:</p>

<pre>
.section .text
        <strong>.global main</strong>   @ tento symbol ma byt dostupny i linkeru

<strong>main:</strong>

        mov  r0, #0    @ navratova hodnota (exit status)
        mov  pc, lr    @ ukonceni aplikace (rizeni se vrati na adresu ulozenou v LR)
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. První demonstrační příklad &ndash; návrat ze subrutiny <strong>main</strong> s&nbsp;předáním návratového kódu</h2>

<p>Pro úplnost si ukažme, jak tedy vypadá celá kostra demonstračního příkladu naprogramovaného pro 32bitové RISCové procesory ARM. Tento příklad je určen pro překlad s&nbsp;využitím nástroje <strong>gcc</strong>, nikoli kombinací utilit <strong>as</strong>+<strong>ld</strong>, proto je v&nbsp;něm deklarováno návěští <strong>main</strong> namísto <strong>_start</strong>:</p>

<pre>
# asmsyntax=as

# Program pro otestovani volani funkci ze standardni knihovny jazyka C
# - varianta urcena pro klasickou 32bitovou architekturu ARM
#
# Autor: Pavel Tisnovsky



#-----------------------------------------------------------------------------
.section .data



#-----------------------------------------------------------------------------
.section .text
        .global main   @ tento symbol ma byt dostupny i linkeru

main:

        mov  r0, #0    @ navratova hodnota (exit status)
        mov  pc, lr    @ ukonceni aplikace (rizeni se vrati na adresu ulozenou v LR)
</pre>

<p>Porovnejme si, jak se tento program odlišuje od varianty určené pro procesory s&nbsp;architekturou x86-64 (nebo i i386, zde je to jedno):</p>

<a href="https://mojefedora.cz/wp-content/uploads/2016/11/43_stdc_stub.png"><img class="alignnone size-thumbnail wp-image-7889" src="https://mojefedora.cz/wp-content/uploads/2016/11/43_stdc_stub-600x167.png" alt="43_stdc_stub" width="600" height="167" /></a>

<p>Pro překlad a slinkování použijte jediný příkaz:</p>

<pre>
gcc test.s
</pre>

<p>Výsledkem by měl být spustitelný soubor, jehož velikost dosahuje na mém systému 5268 bajtů (ovšem s&nbsp;jinou verzí <strong>gcc</strong> či <strong>libc</strong> může být velikost nepatrně odlišná). Některé symboly je možné ze spustitelného souboru odstranit takto:</p>

<pre>
strip a.out
</pre>

<p>Na mém operačním systému (<i>Raspbian</i>) se velikost spustitelného souboru po tomto zásahu zmenší na 2824 bajtů. Jen pro připomenutí &ndash; překladem původní aplikace volající přímo jádro operačního systému vznikl spustitelný soubor o velikosti pouhých 312 bajtů.</p>

<p>Pro zajímavost se podívejme, jak vypadá přeložená funkce/subrutina <strong>main</strong>. Jedná se o pouhé dvě instrukce (to již ostatně víme), přičemž každá instrukce má konstantní šířku 32 bitů:</p>

<pre>
00008390 &lt;main&gt;:
    8390:       e3a00000        mov     r0, #0
    8394:       e1a0f00e        mov     pc, lr
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Alternativní způsob ukončení subrutiny <strong>main</strong> instrukcí <strong>bx</strong></h2>

<p>Pokud se podíváte na strojový kód, který vznikne překladem céčkovských zdrojových textů do assembleru, zjistíte, že se návrat z&nbsp;funkce/subrutiny <strong>main</strong> provádí poněkud odlišným způsobem, protože se namísto instrukce <strong>mov PC, LR</strong> používá instrukce <strong>bx LR</strong> (<i>branch and exchange</i>), tj.&nbsp;skok na adresu, která je uložena v&nbsp;pracovním registru <strong>LR</strong> (<i>link register</i>). Teoreticky by sice bylo možné použít i instrukci <strong>b</strong> (<i>branch</i>), ovšem tato instrukce neumožňuje, aby se namísto offsetu (24bitové konstanty) použil pracovní registr. Překladač programovacího jazyka C většinou vygeneruje tento strojový kód:</p>

<pre>
main:
        mov  r0, #0    @ navratova hodnota (exit status)
        bx   lr        @ ukonceni aplikace (rizeni se vrati na adresu ulozenou v LR)
</pre>

<p>Poznámka: v&nbsp;některých případech může instrukce <strong>BX</strong> přepnout režim procesoru na základě nejnižších bitů adresy.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Druhý demonstrační příklad &ndash; použití instrukce <strong>bx</strong></h2>

<p>Ukažme si, jak by mohl vypadat zdrojový kód nejjednoduššího programu napsaného v&nbsp;assembleru, který je překládán pomocí nástroje <i>gcc</i> a tudíž obsahuje pouze funkci/subrutinu <strong>main</strong>. Program je tvořen pouhými dvěma instrukcemi, přičemž první instrukce nastavuje návratový kód a druhá instrukce ukončí provádění subrutiny <strong>main</strong>:</p>

<pre>
# asmsyntax=as

# Program pro otestovani volani funkci ze standardni knihovny jazyka C
# - varianta urcena pro klasickou 32bitovou architekturu ARM
#
# Autor: Pavel Tisnovsky



#-----------------------------------------------------------------------------
.section .data



#-----------------------------------------------------------------------------
.section .text
        .global main   @ tento symbol ma byt dostupny i linkeru

main:
        mov  r0, #0    @ navratova hodnota (exit status)
        bx   lr        @ ukonceni aplikace (rizeni se vrati na adresu ulozenou v LR)
</pre>

<p>V&nbsp;objektovém kódu nalezneme tyto dvě instrukce. Další části jsou automaticky přidané při linkování a nemusí nás nyní zajímat:</p>

<pre>
00008390 &lt;main&gt;:
    8390:       e3a00000        mov     r0, #0
    8394:       e12fff1e        bx      lr
</pre>

<p>Povšimněte si, že díky tomu, že všechny instrukce mají na původní RISCové architektuře ARM shodnou šířku 32bitů, má subrutina <strong>main</strong> po překladu stejnou velikost, jako u předchozího příkladu:</p>

<pre>
00008390 &lt;main&gt;:
    8390:       e3a00000        mov     r0, #0
    8394:       e1a0f00e        mov     pc, lr
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Uložení návratové adresy na zásobník</h2>

<p>Pokud se v&nbsp;subrutině <strong>main</strong> budou volat další subrutiny a knihovní funkce, došlo by ke změně registru <strong>LR</strong> a tudíž by nebylo možné se jednoduše ze subrutiny <strong>main</strong> vrátit zpět do volajícího kódu. Z&nbsp;tohoto důvodu je vhodné, aby se obsah registru <strong>LR</strong> uložil na zásobník a těsně před návratem ze subrutiny <strong>main</strong> by se obsah tohoto registru opět obnovil. Pro tento účel je možné použít instrukce <strong>STM</strong> (<i>store multiple</i>) a <strong>LDM</strong> (<i>load multiple</i>). Jedná se o všestranně použitelné instrukce, u nichž lze specifikovat jak adresu, na kterou se budou ukládat operandy, tak i způsob případného zvýšení či snížení této adresy (právě automatická inkrementace a dekrementace simuluje práci zásobníku). Navíc tyto instrukce nemusí ukládat či načítat jen jeden operand, ale libovolný počet pracovních registrů (ten je zvolen pomocí bitového pole uvnitř instrukčního kódu):</p>

<table>
<tr><th>Instrukce</th><th>Význam</th></tr>
<tr><td>STM R10, {R1}</td><td>uložení registru R1 na adresu specifikovanou v R10</td></tr>
<tr><td>STM R10, {R1, R2}</td><td>uložení registrů R1 a R2 na adresu specifikovanou v R10 a na adresu následující</td></tr>
<tr><td>STMFD R10!, {R1}</td><td>R10 obsahuje adresu vrcholu zásobníku, na nějž je uložen registr R1</td></tr>
<tr><td>STMFD R10!, {R1,R2,R3}</td><td>R10 obsahuje adresu vrcholu zásobníku, na nějž jsou uloženy registry R1, R2 a R3</td></tr>
<tr><td>STMED R10!, {R1}</td><td>R10 obsahuje adresu vrcholu zásobníku, na nějž je uložen registr R1</td></tr>
<tr><td>STMED R10!, {R1,R2,R3}</td><td>R10 obsahuje adresu vrcholu zásobníku, na nějž jsou uloženy registry R1, R2 a R3</td></tr>
<tr><td>STMFA R10!, {R1}</td><td>jako STMFD, ovšem zásobník roste směrem k&nbsp;vyšším adresám</td></tr>
<tr><td>STMFA R10!, {R1,R2,R3}</td><td>jako STMFD, ovšem zásobník roste směrem k&nbsp;vyšším adresám</td></tr>
</table>

<p>Rozdíl mezi STM<strong>F</strong>D a STM<strong>E</strong>D spočívá v&nbsp;chování ukazatele na vrchol zásobníku. U varianty <strong>F</strong> vrchol ukazuje na poslední zapsaný (zaplněný) prvek, zatímco u varianty <strong>E</strong> ukazuje na první volný prvek.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Třetí demonstrační příklad &ndash; uložení návratové adresy na zásobník</h2>

<p>Ve třetím demonstračním příkladu se ihned po vstupu do subrutiny <strong>main</strong> uloží <i>link register</i> na zásobník, následně se nastaví návratová hodnota do pracovního registru <strong>r0</strong> a v&nbsp;posledním kroku se malým trikem obnoví hodnota uložená na zásobník (byl to obsah <i>link registru</i>), ovšem tentokrát se tato hodnota zapíše přímo do instrukčního čítače (<i>program counter</i>). Tím se vlastně de facto provede již dříve zmíněná instrukce <strong>mov PC, LR</strong>, resp.&nbsp;přesněji řečeno pseudoinstrukce <strong>mov PC, původní_hodnota_LR</strong>:</p>

<pre>
# asmsyntax=as

# Program pro otestovani volani funkci ze standardni knihovny jazyka C
# - varianta urcena pro klasickou 32bitovou architekturu ARM
#
# Autor: Pavel Tisnovsky



#-----------------------------------------------------------------------------
.section .data



#-----------------------------------------------------------------------------
.section .text
        .global main       @ tento symbol ma byt dostupny i linkeru

main:
        stmfd sp!, {lr}    @ ulozeni registru LR na zasobnik
        mov   r0, #42      @ navratova hodnota (exit status)
        ldmfd sp!, {pc}    @ ukonceni aplikace (rizeni se vrati na adresu ulozenou v LR)
</pre>

<p>I přesto, že jsou instrukce typu <strong>LDM</strong> a <strong>STM</strong> velmi univerzální a mohou provádět potenciálně složité operace (například uložení všech pracovních registrů atd.), jsou stále překládány do jediného 32bitového instrukčního slova, což je ostatně vidět z&nbsp;následujícího výpisu získaného disassemblerem:</p>

<pre>
00008390 &lt;main&gt;:
    8390:       e92d4000        stmfd   sp!, {lr}
    8394:       e3a0002a        mov     r0, #42 ; 0x2a
    8398:       e8bd8000        ldmfd   sp!, {pc}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Uložení návratové adresy i registrů, které se používají v&nbsp;subrutině</h2>

<p>Vzhledem k&nbsp;tomu, že instrukce typu <strong>LDM</strong> a <strong>STM</strong> dokážou načíst či naopak uložit větší množství pracovních registrů, je možné na začátku subrutiny zajistit, aby se na zásobník uložily například registry R4, R5, R6 a LR. Pokud nedodržíte pořadí registrů, vypíše assembler varování, protože kvůli způsobu kódování musí být registry ukládány v&nbsp;pevně daném pořadí:</p>

<pre>
stmfd sp!, {r4, r5, r6, <strong>lr</strong>}  @ ulozeni zvolenych registru na zasobnik
</pre>

<p>Návrat ze subrutiny je poté proveden následovně &ndash; celý trik spočívá v&nbsp;tom, že poslední registr, který se obnovuje, již není LR ale PC:</p>

<pre>
ldmfd sp!, {r4, r5, r6, <strong>pc</strong>}  @ obnova registru, ukonceni aplikace (rizeni se vrati na adresu ulozenou v LR)
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Čtvrtý demonstrační příklad &ndash; uložení a obnova obsahu pracovních registrů</h2>

<p>Postup, který jsme si popsali <a href="#k08">v&nbsp;předchozí kapitole</a> nyní použijeme ve čtvrtém demonstračním příkladu, jehož kostra vypadá následovně:</p>

<pre>
# asmsyntax=as

# Program pro otestovani volani funkci ze standardni knihovny jazyka C
# - varianta urcena pro klasickou 32bitovou architekturu ARM
#
# Autor: Pavel Tisnovsky



#-----------------------------------------------------------------------------
.section .data



#-----------------------------------------------------------------------------
.section .text
        .global main                 @ tento symbol ma byt dostupny i linkeru

main:
        stmfd sp!, {r4, r5, r6, lr}  @ ulozeni zvolenych registru na zasobnik
        mov   r0, #42                @ navratova hodnota (exit status)
        ldmfd sp!, {r4, r5, r6, pc}  @ obnova registru, ukonceni aplikace (rizeni se vrati na adresu ulozenou v LR)
</pre>

<p>Po překladu se můžeme podívat na způsob zakódování instrukcí, tentokrát pro přehlednost s&nbsp;použitím mnemotechnických zkratek používaných firmou Intel:</p>

<pre>
00008390 &lt;main&gt;:
    8390:       e92d4070        push    {r4, r5, r6, lr}
    8394:       e3a0002a        mov     r0, #42 ; 0x2a
    8398:       e8bd8070        pop     {r4, r5, r6, pc}
</pre>

<p>Význam programu se samozřejmě nezměnil, disassembler pouze použil názvy <strong>push</strong> a <strong>pop</strong>, které přesně odpovídají tomu, co se v&nbsp;programu děje.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Volání knihovní funkce <strong>puts()</strong> z&nbsp;assembleru</h2>

<p>Funkce, které jsou dostupné ve standardní céčkové knihovně, se volají velmi jednoduše instrukcí <strong>bl</strong> (<i>branch and link</i>), které se předá adresa funkce. Adresa se samozřejmě zjišťuje až při překladu; ve zdrojovém kódu se použije jméno (návěští funkce). Pokud by funkce neměla žádné parametry, vypadalo by volání následovně:</p>

<pre>
bl    puts                      @ zavolani knihovni funkce puts()
</pre>

<p>Ve skutečnosti funkce <strong>puts</strong> očekává jeden parametr, kterým je adresa řetězce, který se má vytisknout. Tento řetězec může být umístěn v&nbsp;datovém segmentu a deklarován pomocí <strong>.asciiz</strong> (tím se za konec řetězce přidá ukončující nula):</p>

<pre>
.section .data
hello_world_message:
        .asciz "Hello world!\n"         @ zprava, ktera se ma vytisknout na standardni vystup
</pre>

<p>Parametry se předávají přes pracovní registry. V&nbsp;tomto konkrétním případě je nutné v&nbsp;registru <strong>r0</strong> předat adresu řetězce (resp.&nbsp;adresu jeho prvního znaku). Nejprve tuto adresu načteme, a to pseudoinstrukcí <strong>ldr</strong>. Tato instrukce se většinou přeloží takovým způsobem, že konstantu (adresu) umístí před či za subrutinu a načtení je provedeno relativně k&nbsp;obsahu registru PC:</p>

<pre>
ldr   r0, =hello_world_message  @ adresa zpravy, ktera se ma vytisknout
</pre>

<p>Parametr máme inicializovaný a jiné parametry již funkce <strong>puts</strong> nepotřebuje, takže ji nyní skutečně můžeme zavolat:</p>

<pre>
bl    puts                      @ zavolani knihovni funkce puts()
</pre>

<p>Povšimněte si, že zavoláním se přepíše obsah registru LR, což je jeden z&nbsp;důvodů, proč jsme si jeho obsah uschovali na zásobníku.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Pátý demonstrační příklad &ndash; zavolání funkce <strong>puts()</strong></h2>

<p>Celá sekvence volání knihovní funkce <strong>puts</strong> je použita v&nbsp;dnešním posledním demonstračním příkladu, jehož zdrojový kód je umístěn pod tento odstavec:</p>

<pre>
# asmsyntax=as

# Program pro otestovani volani funkci ze standardni knihovny jazyka C
# - volani funkce 'puts'
# - varianta urcena pro klasickou 32bitovou architekturu ARM
#
# Autor: Pavel Tisnovsky



#-----------------------------------------------------------------------------
.section .data
hello_world_message:
        .asciz "Hello world!\n"         @ zprava, ktera se ma vytisknout na standardni vystup



#-----------------------------------------------------------------------------
.section .text
        .global main                    @ tento symbol ma byt dostupny i linkeru

main:
        stmfd sp!, {lr}                 @ ulozeni zvolenych registru na zasobnik
        ldr   r0, =hello_world_message  @ adresa zpravy, ktera se ma vytisknout
        bl    puts                      @ zavolani knihovni funkce puts()
        mov   r0, #42                   @ navratova hodnota (exit status)
        ldmfd sp!, {pc}                 @ obnova registru, ukonceni aplikace (rizeni se vrati na adresu ulozenou v LR)
</pre>

<p>Opět se podívejme na porovnání tohoto programového kódu s&nbsp;jeho ekvivalentem, ovšem naprogramovaným pro mikroprocesory s&nbsp;architekturou x86-64. Manipulace se zásobníkem je na procesorech ARM kratší, a to z&nbsp;toho důvodu, že není nutné zajišťovat zarovnání vrcholu zásobníku na adresu dělitelnou šestnácti:</p>

<a href="https://mojefedora.cz/wp-content/uploads/2016/11/44_stdc_puts.png"><img class="alignnone size-thumbnail wp-image-7890" src="https://mojefedora.cz/wp-content/uploads/2016/11/44_stdc_puts-559x254.png" alt="44_stdc_puts" width="559" height="254" /></a>



<p><a name="k12"></a></p>
<h2 id="k12">12. Spuštění příkladu v&nbsp;debuggeru</h2>

<p>Na závěr si zkusme odkrokovat chování posledního programu v&nbsp;GNU debuggeru. Překlad proveďte s&nbsp;volbou <strong>-g</strong> a posléze spusťte debugger:</p>

<pre>
pi@raspberrypi $ <strong>gdb a.out</strong>
GNU gdb (GDB) 7.4.1-debian
Copyright (C) 2012 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "arm-linux-gnueabihf".
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;...
Reading symbols from /mnt/home/pi/temp/44_stdc_puts/a.out...done.
</pre>

<p>Nastavíme breakpoint na vstup subrutiny <strong>main</strong>:</p>

<pre>
(gdb) <strong>break main</strong>
Breakpoint 1 at 0x83cc: file main_arm.s, line 24.
</pre>

<p>Nyní aplikaci spustíme. Měla by se zastavit na nastaveném breakpointu:</p>

<pre>
(gdb) <strong>run</strong>
Starting program: /mnt/home/pi/temp/44_stdc_puts/a.out 

Breakpoint 1, main () at main_arm.s:24
24              ldr   r0, =hello_world_message  @ adresa zpravy, ktera se ma vytisknout
</pre>

<p>Můžeme se podívat na aktuální hodnotu všech pracovních registrů. Zajímat nás bude zejména registru <strong>r0</strong> a <strong>pc</strong>:</p>

<pre>
(gdb) <strong>info registers</strong>
r0             <strong>0x1</strong>      1
r1             0xbefff724       3204445988
r2             0xbefff72c       3204445996
r3             0x83c8   33736
r4             0x0      0
r5             0x0      0
r6             0x831c   33564
r7             0x0      0
r8             0x0      0
r9             0x0      0
r10            0xb6fff000       3070226432
r11            0x0      0
r12            0xb6fbf000       3069964288
sp             0xbefff5d4       0xbefff5d4
lr             0xb6eaa82c       -1226135508
pc             <strong>0x83cc</strong>   0x83cc &lt;main+4&gt;
cpsr           0x60000010       1610612752
</pre>

<p>Taktéž si můžeme zobrazit, na jakém místě kódu se právě nacházíme:</p>

<pre>
(gdb) <strong>disassemble</strong>
Dump of assembler code for function main:
   0x000083c8 &lt;+0&gt;:     push    {lr}
=&gt; 0x000083cc &lt;+4&gt;:     ldr     r0, [pc, #8]    ; 0x83dc &lt;main+20&gt;
   0x000083d0 &lt;+8&gt;:     bl      0x82ec
   0x000083d4 &lt;+12&gt;:    mov     r0, #42 ; 0x2a
   0x000083d8 &lt;+16&gt;:    pop     {pc}
   0x000083dc &lt;+20&gt;:    andeq   r0, r1, r0, lsl #11
End of assembler dump.
</pre>

<p>Nyní řekneme debuggeru, aby vykonal další instrukci a ihned poté se opět zastavil:</p>

<pre>
(gdb) <strong>step</strong>
25              bl    puts                      @ zavolani knihovni funkce puts()
</pre>

<p>Pohledem na disassemblovaný kód se ujistíme, že se řízení skutečně přesunulo pouze na další instrukci:</p>

<pre>
(gdb) <strong>disassemble </strong>
Dump of assembler code for function main:
   0x000083c8 &lt;+0&gt;:     push    {lr}
   0x000083cc &lt;+4&gt;:     ldr     r0, [pc, #8]    ; 0x83dc &lt;main+20&gt;
=&gt; 0x000083d0 &lt;+8&gt;:     bl      0x82ec
   0x000083d4 &lt;+12&gt;:    mov     r0, #42 ; 0x2a
   0x000083d8 &lt;+16&gt;:    pop     {pc}
   0x000083dc &lt;+20&gt;:    andeq   r0, r1, r0, lsl #11
End of assembler dump.
</pre>

<p>Současně se změnil obsah pracovního registru <strong>r0</strong> (obsahuje adresu řetězce) a samozřejmě i obsah registru <strong>pc</strong> (obsahuje adresu další instrukce):</p>

<pre>
(gdb) info registers 
r0             <strong>0x10580</strong>  66944
r1             0xbefff724       3204445988
r2             0xbefff72c       3204445996
r3             0x83c8   33736
r4             0x0      0
r5             0x0      0
r6             0x831c   33564
r7             0x0      0
r8             0x0      0
r9             0x0      0
r10            0xb6fff000       3070226432
r11            0x0      0
r12            0xb6fbf000       3069964288
sp             0xbefff5d4       0xbefff5d4
lr             0xb6eaa82c       -1226135508
pc             0x83d0   0x83d0 &lt;main+8&gt;
cpsr           0x60000010       1610612752
</pre>

<p>Po dalším kroku se na standardní výstup vytiskne zpráva, protože tímto krokem se volala funkce <strong>puts</strong>:</p>

<pre>
(gdb) <strong>step</strong>
Hello world!

26              mov   r0, #42                   @ navratova hodnota (exit status)
</pre>

<p>Program můžeme dokončit příkazem &bdquo;continue&ldquo;:</p>

<pre>
(gdb) <strong>cont</strong>
Continuing.
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popisované demonstrační příklady byly, podobně jako ve všech předchozích částech tohoto seriálu, společně s&nbsp;podpůrnými skripty určenými pro jejich překlad či naopak pro disassembling, uloženy do GIT repositáře dostupného na adrese <a href="https://github.com/tisnik/presentations/">https://github.com/tisnik/presentations/</a>. Všechny příklady jsou určeny pro GNU Assembler. Následují tabulky obsahující odkazy na zdrojové kódy příkladů i na již zmíněné podpůrné skripty:</p>

<h3>První demonstrační příklad: šablona pro překlad nástrojem <strong>gcc</strong></h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>main.s</td><td>hlavní program pro procesory x86-64</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/43_stdc_stub/main.s">https://github.com/tisnik/presentations/blob/master/assembler/43_stdc_stub/main.s</a></td></tr>
<tr><td>2</td><td>main_arm_v1.s</td><td>hlavní program pro procesory ARM (verze 1)</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/43_stdc_stub/main_arm_v1.s">https://github.com/tisnik/presentations/blob/master/assembler/43_stdc_stub/main_arm_v1.s</a></td></tr>
<tr><td>3</td><td>main_arm_v2.s</td><td>hlavní program pro procesory ARM (verze 2)</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/43_stdc_stub/main_arm_v2.s">https://github.com/tisnik/presentations/blob/master/assembler/43_stdc_stub/main_arm_v2.s</a></td></tr>
<tr><td>4</td><td>main_arm_v3.s</td><td>hlavní program pro procesory ARM (verze 3)</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/43_stdc_stub/main_arm_v3.s">https://github.com/tisnik/presentations/blob/master/assembler/43_stdc_stub/main_arm_v3.s</a></td></tr>
<tr><td>5</td><td>main_arm_v4.s</td><td>hlavní program pro procesory ARM (verze 4)</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/43_stdc_stub/main_arm_v4.s">https://github.com/tisnik/presentations/blob/master/assembler/43_stdc_stub/main_arm_v4.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>6</td><td>assemble</td><td>skript pro překlad s&nbsp;využitím gcc (verze pro x86-64)</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/43_stdc_stub/assemble">https://github.com/tisnik/presentations/blob/master/assembler/43_stdc_stub/assemble</a></td></tr>
<tr><td>7</td><td>assemble_arm_v1</td><td>skript pro překlad s&nbsp;využitím gcc (ARM verze 1)</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/43_stdc_stub/assemble_arm_v1">https://github.com/tisnik/presentations/blob/master/assembler/43_stdc_stub/assemble_arm_v1</a></td></tr>
<tr><td>8</td><td>assemble_arm_v2</td><td>skript pro překlad s&nbsp;využitím gcc (ARM verze 2)</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/43_stdc_stub/assemble_arm_v2">https://github.com/tisnik/presentations/blob/master/assembler/43_stdc_stub/assemble_arm_v2</a></td></tr>
<tr><td>9</td><td>assemble_arm_v3</td><td>skript pro překlad s&nbsp;využitím gcc (ARM verze 3)</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/43_stdc_stub/assemble_arm_v3">https://github.com/tisnik/presentations/blob/master/assembler/43_stdc_stub/assemble_arm_v3</a></td></tr>
<tr><td>10</td><td>assemble_arm_v4</td><td>skript pro překlad s&nbsp;využitím gcc (ARM verze 4)</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/43_stdc_stub/assemble_arm_v4">https://github.com/tisnik/presentations/blob/master/assembler/43_stdc_stub/assemble_arm_v4</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>disassemble</td><td>skript pro disassembling</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/43_stdc_stub/disassemble">https://github.com/tisnik/presentations/blob/master/assembler/43_stdc_stub/disassemble</a></td></tr>
</table>

<p>Poznámka: skript pro disassembling je shodný pro obě architektury mikroprocesorů.</p>



<h3>Druhý demonstrační příklad: volání knihovní funkce <strong>puts()</strong></h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>main_64bit.s</td><td>hlavní program pro procesory x86-64</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/44_stdc_puts/main_64bit.s">https://github.com/tisnik/presentations/blob/master/assembler/44_stdc_puts/main_64bit.s</a></td></tr>
<tr><td>2</td><td>main_arm.s</td><td>hlavní program pro procesory ARM</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/44_stdc_puts/main_arm.s">https://github.com/tisnik/presentations/blob/master/assembler/44_stdc_puts/main_arm.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>assemble_64bit</td><td>skript pro překlad s&nbsp;využitím gcc (verze pro x86-64)</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/44_stdc_puts/assemble_64bit">https://github.com/tisnik/presentations/blob/master/assembler/44_stdc_puts/assemble_64bit</a></td></tr>
<tr><td>4</td><td>assemble_arm</td><td>skript pro překlad s&nbsp;využitím gcc (verze pro ARM)</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/44_stdc_puts/assemble_arm">https://github.com/tisnik/presentations/blob/master/assembler/44_stdc_puts/assemble_arm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>disassemble</td><td>skript pro disassembling</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/44_stdc_puts/disassemble">https://github.com/tisnik/presentations/blob/master/assembler/44_stdc_puts/disassemble</a></td></tr>
</table>

<p>Poznámka: opět zde platí, že skript pro disassembling je shodný pro obě architektury mikroprocesorů.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>ARM Documentation: B, BL, BX, BLX, and BXJ<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0204j/Cihfddaf.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0204j/Cihfddaf.html</a>
</li>

<li>Branch and Call Sequences Explained<br />
<a href="https://community.arm.com/groups/processors/blog/2013/09/25/branch-and-call-sequences-explained">https://community.arm.com/groups/processors/blog/2013/09/25/branch-and-call-sequences-explained</a>
</li>

<li>Improving ARM Code Density and Performance<br />
<a href="New Thumb Extensions to the ARM Architecture Richard Phelan">New Thumb Extensions to the ARM Architecture Richard Phelan</a>
</li>

<li>The ARM Processor Architecture<br />
<a href="http://www.arm.com/products/processors/technologies/instruction-set-architectures.php">http://www.arm.com/products/processors/technologies/instruction-set-architectures.php</a>
</li>

<li>Thumb-2 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html</a>
</li>

<li>Introduction to ARM thumb<br />
<a href="http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb">http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb</a>
</li>

<li>ARM, Thumb, and ThumbEE instruction sets<br />
<a href="http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm">http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm</a>
</li>

<li>An Introduction to ARM Assembly Language<br />
<a href="http://dev.emcelettronica.com/introduction-to-arm-assembly-language">http://dev.emcelettronica.com/introduction-to-arm-assembly-language</a>
</li>

<li>Processors - ARM<br />
<a href="http://www.arm.com/products/processors/index.php">http://www.arm.com/products/processors/index.php</a>
</li>

<li>The ARM Instruction Set<br />
<a href="http://simplemachines.it/doc/arm_inst.pdf">http://simplemachines.it/doc/arm_inst.pdf</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ARM_architecture">http://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>C Functions Without Arguments<br />
<a href="https://eklitzke.org/c-functions-without-arguments">https://eklitzke.org/c-functions-without-arguments</a>
</li>

<li>GNU Assembler Examples<br />
<a href="http://cs.lmu.edu/~ray/notes/gasexamples/">http://cs.lmu.edu/~ray/notes/gasexamples/</a>
</li>

<li>Simply FPU<br />
<a href="http://www.website.masmforum.com/tutorials/fptute/">http://www.website.masmforum.com/tutorials/fptute/</a>
</li>

<li>Art of Assembly language programming: The 80x87 Floating Point Coprocessors<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html</a>
</li>

<li>Art of Assembly language programming: The FPU Instruction Set<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html</a>
</li>

<li>INTEL 80387 PROGRAMMER'S REFERENCE MANUAL<br />
<a href="http://www.ragestorm.net/downloads/387intel.txt">http://www.ragestorm.net/downloads/387intel.txt</a>
</li>

<li>x86 Instruction Set Reference: FLD<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_100.html">http://x86.renejeschke.de/html/file_module_x86_id_100.html</a>
</li>

<li>x86 Instruction Set Reference: FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_101.html">http://x86.renejeschke.de/html/file_module_x86_id_101.html</a>
</li>

<li>x86 Instruction Set Reference: FLD<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_100.html">http://x86.renejeschke.de/html/file_module_x86_id_100.html</a>
</li>

<li>x86 Instruction Set Reference: FST/FSTP<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_117.html">http://x86.renejeschke.de/html/file_module_x86_id_117.html</a>
</li>

<li>x86 Instruction Set Reference: BTC<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_23.html">http://x86.renejeschke.de/html/file_module_x86_id_23.html</a>
</li>

<li>x86 Instruction Set Reference: BTR<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_24.html">http://x86.renejeschke.de/html/file_module_x86_id_24.html</a>
</li>

<li>x86 Instruction Set Reference: BTS<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_25.html">http://x86.renejeschke.de/html/file_module_x86_id_25.html</a>
</li>

<li>x86 Instruction Set Reference: BSF<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_19.html">http://x86.renejeschke.de/html/file_module_x86_id_19.html</a>
</li>

<li>x86 Instruction Set Reference: BSR<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_20.html">http://x86.renejeschke.de/html/file_module_x86_id_20.html</a>
</li>

<li>x86 Instruction Set Reference: BSWAP<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_21.html">http://x86.renejeschke.de/html/file_module_x86_id_21.html</a>
</li>

<li>x86 Instruction Set Reference: XCHG<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_328.html">http://x86.renejeschke.de/html/file_module_x86_id_328.html</a>
</li>

<li>x86 Instruction Set Reference: SETcc<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_288.html">http://x86.renejeschke.de/html/file_module_x86_id_288.html</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>The GNU Assembler Tutorial<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html">http://tigcc.ticalc.org/doc/gnuasm.html</a>
</li>

<li>The GNU Assembler - macros<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html#SEC109">http://tigcc.ticalc.org/doc/gnuasm.html#SEC109</a>
</li>

<li>ARM subroutines &amp; program stack<br />
<a href="http://www.toves.org/books/armsub/">http://www.toves.org/books/armsub/</a>
</li>

<li>Generating Mixed Source and Assembly List using GCC<br />
<a href="http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/">http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/</a>
</li>

<li>Calling subroutines<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm</a>
</li>

<li>ARM Assembly Language Programming<br />
<a href="http://peter-cockerell.net/aalp/html/frames.html">http://peter-cockerell.net/aalp/html/frames.html</a>
</li>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Intel x86 JUMP quick reference<br />
<a href="http://unixwiz.net/techtips/x86-jumps.html">http://unixwiz.net/techtips/x86-jumps.html</a>
</li>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Assembler pod Linuxem<br />
<a href="http://phoenix.inf.upol.cz/linux/prog/asm.html">http://phoenix.inf.upol.cz/linux/prog/asm.html</a>
</li>

<li>AT&amp;T Syntax versus Intel Syntax<br />
<a href="https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html">https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html</a>
</li>

<li>Linux Assembly website<br />
<a href="http://asm.sourceforge.net/">http://asm.sourceforge.net/</a>
</li>

<li>Using Assembly Language in Linux<br />
<a href="http://asm.sourceforge.net/articles/linasm.html">http://asm.sourceforge.net/articles/linasm.html</a>
</li>

<li>vasm<br />
<a href="http://sun.hasenbraten.de/vasm/">http://sun.hasenbraten.de/vasm/</a>
</li>

<li>vasm &ndash; dokumentace<br />
<a href="http://sun.hasenbraten.de/vasm/release/vasm.html">http://sun.hasenbraten.de/vasm/release/vasm.html</a>
</li>

<li>The Yasm Modular Assembler Project<br />
<a href="http://yasm.tortall.net/">http://yasm.tortall.net/</a>
</li>

<li>680x0:AsmOne<br />
<a href="http://www.amigacoding.com/index.php/680x0:AsmOne">http://www.amigacoding.com/index.php/680x0:AsmOne</a>
</li>

<li>ASM-One Macro Assembler<br />
<a href="http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler">http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler</a>
</li>

<li>ASM-One pages<br />
<a href="http://www.theflamearrows.info/documents/asmone.html">http://www.theflamearrows.info/documents/asmone.html</a>
</li>

<li>Základní informace o ASM-One<br />
<a href="http://www.theflamearrows.info/documents/asminfo.html">http://www.theflamearrows.info/documents/asminfo.html</a>
</li>

<li>Linux Syscall Reference<br />
<a href="http://syscalls.kernelgrok.com/">http://syscalls.kernelgrok.com/</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>IBM System 360/370 Compiler and Historical Documentation<br />
<a href="http://www.edelweb.fr/Simula/">http://www.edelweb.fr/Simula/</a>
</li>

<li>IBM 700/7000 series<br />
<a href="http://en.wikipedia.org/wiki/IBM_700/7000_series">http://en.wikipedia.org/wiki/IBM_700/7000_series</a>
</li>

<li>IBM System/360<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/360">http://en.wikipedia.org/wiki/IBM_System/360</a>
</li>

<li>IBM System/370<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/370">http://en.wikipedia.org/wiki/IBM_System/370</a>
</li>

<li>Mainframe family tree and chronology<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html</a>
</li>

<li>704 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html</a>
</li>

<li>705 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html</a>
</li>

<li>The IBM 704<br />
<a href="http://www.columbia.edu/acis/history/704.html">http://www.columbia.edu/acis/history/704.html</a>
</li>

<li>IBM Mainframe album<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html</a>
</li>

<li>Osmibitové muzeum<br />
<a href="http://osmi.tarbik.com/">http://osmi.tarbik.com/</a>
</li>

<li>Tesla PMI-80<br />
<a href="http://osmi.tarbik.com/cssr/pmi80.html">http://osmi.tarbik.com/cssr/pmi80.html</a>
</li>

<li>PMI-80<br />
<a href="http://en.wikipedia.org/wiki/PMI-80">http://en.wikipedia.org/wiki/PMI-80</a>
</li>

<li>PMI-80<br />
<a href="http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016">http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016</a>
</li>

<li>The 6502 overflow flag explained mathematically <br />
<a href="http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html">http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html</a>
</li>

<li>X86 Opcode and Instruction Reference<br />
<a href="http://ref.x86asm.net/coder32.html">http://ref.x86asm.net/coder32.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

