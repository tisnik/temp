<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Použití assembleru v Linuxu: RISCová architektura AArch64</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Použití assembleru v Linuxu: RISCová architektura AArch64</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve všech předchozích částech tohoto seriálu jsme se zabývali především psaním programového kódu pro mikroprocesory s&nbsp;architekturami x86, x86-64 a 32bitovou architekturou ARM. Ovšem stále častěji se můžeme setkat se zařízeními, v&nbsp;nichž je použit nějaký mikroprocesor s&nbsp;architekturou AArch64, tedy se 64bitovým ARMem. Právě této architektuře, která je samozřejmě podporována i Fedorou, se budeme poněkud podrobněji věnovat v&nbsp;dnešním článku.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Použití assembleru v&nbsp;Linuxu: RISCová architektura AArch64</a></p>
<p><a href="#k02">2. Důvody pro vznik architektury AArch64</a></p>
<p><a href="#k03">3. Rodina ARMv8-A</a></p>
<p><a href="#k04">4. Architektura AArch64 z&nbsp;pohledu programátora</a></p>
<p><a href="#k05">5. Pracovní registry</a></p>
<p><a href="#k06">6. Význam třicátého druhého registru</a></p>
<p><a href="#k07">7. Operace s&nbsp;32bitovými a 64bitovými operandy</a></p>
<p><a href="#k08">8. Možnosti adresování</a></p>
<p><a href="#k09">9. Zjednodušení instrukční sady</a></p>
<p><a href="#k10">10. První demonstrační příklad &ndash; šablona pro AArch64</a></p>
<p><a href="#k11">11. Disassemblovaný objektový kód prvního příkladu</a></p>
<p><a href="#k12">12. Druhý demonstrační příklad &ndash; tisk řetězce na standardní výstup</a></p>
<p><a href="#k13">13. Disassemblovaný objektový kód druhého příkladu</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Použití assembleru v&nbsp;Linuxu: RISCová architektura AArch64</h2>

<p>V&nbsp;poměrně velkém množství moderních elektronických zařízení se můžeme setkat s&nbsp;mikroprocesory založenými na 64bitové architektuře <i>AArch64</i>. Tato architektura je sice do jisté míry odvozena od původní &bdquo;klasické&ldquo; 32bitové RISCové architektury ARM (dnes pro odlišení nazývané ARM32), ovšem při přechodu na 64bitový systém došlo k&nbsp;mnoha podstatným změnám, které se týkají jak počtu a funkce pracovních registrů, tak i instrukční sady, která se v&nbsp;některých ohledech od původní RISCové sady odlišuje. Vzhledem k&nbsp;tomu, že architektura AArch64 je dnes podporována mj.&nbsp;i Fedorou (vlastně se jedná o druhý primární systém, ihned po čipech x86-64), zaslouží si podrobnější popis. Nejprve si řekneme, s&nbsp;jakými rozdíly je nutné počítat při práci v&nbsp;assembleru a následně si postupně převedeme jednotlivé demonstrační příklady, s&nbsp;nimiž jsme se již setkali, do 64bitové podoby.</p>

<p>Mikroprocesory a mikrořadiče ARM za sebou mají dlouhou dobu vývoje, takže není divu, že postupně vznikaly různé generace těchto čipů, které se od sebe odlišovaly jak svým výpočetním výkonem, tak i různými změnami v&nbsp;instrukční sadě, uspořádáním cache, počtem řezů (pipeline), použitými submoduly (hardwarová násobička, dělička, jednotka pro SIMD operace, matematický koprocesor) atd. Čipy ARM je možné rozlišit podle architektury, přičemž základní dělení je naznačeno v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Architektura</th><th>Adresová/datová sběrnice</th><th>Jádro</th><th>Poznámka/profil (u Cortex)</th></tr>
<tr><td>1</td><td>ARMv1   </td><td>26/32 bitů</td><td>ARM1</td><td>první implementace, technologické demo</td></tr>
<tr><td>2</td><td>ARMv2   </td><td>26/32 bitů</td><td>ARM2, ARM3</td><td>přidána HW násobička a MMU</td></tr>
<tr><td>3</td><td>ARMv3   </td><td>26/32 bitů</td><td>ARM6, ARM7</td><td></td></tr>
<tr><td>4</td><td>ARMv4   </td><td>26/32 bitů</td><td>ARM8</td><td>patří sem mj.&nbsp;i řada čipů StrongARM</td></tr>
<tr><td>5</td><td>ARMv5   </td><td>32 bitů   </td><td>ARM7EJ, ARM9E, ARM10E</td><td>lze najít ve starších zařízeních</td></tr>
<tr><td>6</td><td>ARMv6   </td><td>32 bitů   </td><td>ARM11</td><td>dodnes používaná jádra</td></tr>
<tr><td>7</td><td>ARMv6-M </td><td>32 bitů   </td><td>Cortex-M0, Cortex-M0+, Cortex-M1</td><td>mikrořadiče (M v&nbsp;názvu)</td></tr>
<tr><td>8</td><td>ARMv7-M </td><td>32 bitů   </td><td>Cortex-M3</td><td>mikrořadiče (poznáme podle M v&nbsp;názvu)</td></tr>
<tr><td>9</td><td>ARMv7E-M</td><td>32 bitů   </td><td>Cortex-M4, Cortex-M7</td><td>mikrořadiče (M v&nbsp;názvu)</td></tr>
<tr><td>10</td><td>ARMv7-R </td><td>32 bitů   </td><td>Cortex-R4, Cortex-R5, Cortex-R7</td><td>realtime aplikace (R v&nbsp;názvu)</td></tr>
<tr><td>11</td><td>ARMv7-A </td><td>32 bitů   </td><td>Cortex-A5, Cortex-A7, Cortex-A8, Cortex-A9, Cortex-A12, Cortex-A15, Cortex-A17</td><td>smartphony atd.</td></tr>
<tr><td>12</td><td>ARMv8-A </td><td>32/64 bitů</td><td>Cortex-A35, Cortex-A53, A57, A72 a A73</td><td>smartphony atd.</td></tr>
</table>

<p>V&nbsp;dalším textu nás budou zajímat především čipy s&nbsp;architekturou <strong>ARMv8-A</strong>, která je vypsána na posledním řádku tabulky.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Důvody pro vznik architektury AArch64</h2>

<p>Existuje hned několik důvodů, proč se společnost ARM Holdings rozhodla k&nbsp;poměrně rizikovému a velmi pravděpodobně i finančně náročnému kroku, tj.&nbsp;k&nbsp;vývoji zcela nové a zpětně nekompatibilní architektury. Mikroprocesory ARM se totiž začaly používat v&nbsp;nových oblastech, například pro některé servery, kde již možnosti 32bitových adres nemusely být dostačující. Navíc původní 32bitová architektura začala vykazovat určité známky zastaralosti, což pravděpodobně není až tak překvapivé, zvláště když si uvědomíme, že první RISCové ARMy začaly být testovány již v&nbsp;roce 1985, tj.&nbsp;před 31 roky. Bylo tedy jen logické, že se vylepšení původní architektury a současně přechod na 64bitovou aritmeticko-logickou jednotku a adresování, provede v&nbsp;jednom kroku a současně se zachová původní portfolia mikroprocesorů a mikrořadičů. Nová architektura i s&nbsp;ní spojená instrukční sada byly navrženy s&nbsp;ohledem na moderní překladače a virtuální stroje. Společnost ARM se v&nbsp;tomto ohledu mohla opřít o mnohaleté studium chování existujících aplikací (ostatně právě na základě tohoto studia byly v&nbsp;minulosti vytvořeny instrukční sady Thumb a Thumb-2).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Rodina ARMv8-A</h2>

<p>V&nbsp;současnosti používané 64bitové čipy ARM patří do rodiny ARMv8-A. Nalezneme zde jádra <a href="https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php">Cortex-A35</a>, <a href="https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php">Cortex-A53</a>, <a href="https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php">Cortex-A57</a>, <a href="https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php">Cortex-A72</a> a <a href="https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php">Cortex-A73</a>, které se od sebe odlišují především výpočetním výkonem. Čipy s&nbsp;těmito jádry lze nalézt ve výkonných tabletech, ale i serverech. Vzhledem k&nbsp;tomu, že u ARMv8-A je zaručena zpětná kompatibilita s&nbsp;existující 32bitovou architekturou ARMv7-A, znamená to, že mikroprocesory je možné přepnout mezi 32bitovým kompatibilním režimem a plnohodnotným 64bitovým režimem (ve skutečnosti se v&nbsp;32bitovém režimu je možné provést přepnutí mezi A32 a T32, tj.&nbsp;mezi původními RISCovými instrukcemi a instrukcemi Thumb/Thumb2).</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Architektura AArch64 z&nbsp;pohledu programátora</h2>

<p>Z&nbsp;pohledu programátora pracujícího v&nbsp;assembleru je architektura AArch64 v&nbsp;několika ohledech odlišná od původní 32bitové architektury. Především se zvýšil počet pracovních registrů z&nbsp;patnácti na 31. Všechny registry se navíc rozšířily z&nbsp;třiceti dvou bitů na 64 bitů. Ovšem mnohé operace stále podporují i 32bitové operandy &ndash; v&nbsp;tomto případě se použije ta samá skupina registrů, z&nbsp;nichž se ovšem využije jen spodních 32 bitů (nedochází zde tedy k&nbsp;rozdvojení každého 64bitového registru na dva registry 32bitové, jak to známe z&nbsp;jiných typů procesorů). Podporován je i matematický koprocesor, jehož struktura se v&nbsp;mnoha ohledech blíží VPS. Nesmíme zapomenout ani na změny v&nbsp;instrukční sadě, které budou popsány níže. Poslední důležitým vylepšením je &bdquo;zadrátování&ldquo; podpory pro AES, SHA-1 a SHA-256, což je využitelné jak na tabletech či smartphonech, tak i na serverech (o podrobnostech se zmíníme v&nbsp;dalších částech tohoto seriálu).</p>

<p>Zajímavé je, že se designéři AArch64 vrátili k&nbsp;původní myšlence RISC a i z&nbsp;tohoto důvodu mají všechny instrukce konstantní šířku třiceti dvou bitů (na rozdíl od Thumb a Thumb-2).</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Pracovní registry</h2>

<p>Původních patnáct pracovních registrů pojmenovaných <strong>R0</strong> až <strong>R14</strong> bylo rozšířeno na 31 registrů, z&nbsp;nichž každý má šířku 64 bitů. Z&nbsp;tohoto důvodu muselo dojít k&nbsp;úpravě pojmenování registrů způsobem, který je naznačený v&nbsp;následující tabulce:</p>

<table>
<tr><th>Jméno</th><th>Význam</th></tr>
<tr><td>r0..r30</td><td>použito například v&nbsp;dokumentaci, popisu ABI atd.</td></tr>
<tr><td>x0..x30</td><td>celý 64bitový registr použitý jako zdroj či cíl</td></tr>
<tr><td>w0..w30</td><td>spodních 32 bitů registru (horních 32 bitů výsledku je buď vynulováno nebo znaménkově rozšířeno)</td></tr>
</table>

<p>Všechny tyto registry mají v&nbsp;instrukční sadě stejné postavení, na rozdíl od instrukční sady Thumb, v&nbsp;níž se pro některé instrukce může použít jen spodních osm registrů.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Význam třicátého druhého registru</h2>

<p>Třicátý druhý registr, tj.&nbsp;registr se jménem <strong>x31</strong> či <strong>w31</strong>, není ve skutečnosti běžným pracovním registrem, protože má dva speciální významy. V&nbsp;případě použití tohoto registru v&nbsp;aritmetických či logických instrukcích se při použití ve funkci vstupního operandu tento registr chová jako konstantní nula a při použití ve funkci operandu výstupního jako /dev/null (výsledek se zahodí a neovlivní skutečnou hodnotu uloženou do registru). Proto se v&nbsp;assembleru může pro pojmenování tohoto registru použít jméno <strong>xzr</strong> či <strong>wzr</strong>. U instrukcí pracujících se zásobníkem se tento registr chová jako ukazatel na vrchol zásobníku a proto se pro něj v&nbsp;assembleru používá jméno <strong>rsp</strong> či jen <strong>SP</strong> (na velikosti písmen u jmen registrů samozřejmě nezáleží).</p>

<p>Poznámky:</p>

<ol>
<li>Registr <strong>x30</strong> se používá ve funkci <strong>LR</strong> (<i>Link Register</i>).</li>
<li>Registr <strong>PC</strong> není přímo dostupný.</li>
</ol>



<p><a name="k07"></a></p>
<h2 id="k07">7. Operace s&nbsp;32bitovými a 64bitovými operandy</h2>

<p>U aritmetických instrukcí je možné zvolit, zda se mají operace provádět s&nbsp;32bitovými či 64bitovými operandy. U 64bitových operandů je vlastní provedení instrukce jednoduché, ovšem u 32bitových operandů je nutné zajistit, aby měl výsledek operace smysl i ve chvíli, kdy se převede na 64 bitů. Z&nbsp;tohoto důvodu je při použití 32bitového <i>zdrojového</i> operandu horních 32 bitů původně 64bitového registru ignorováno a při použití 32bitového <i>cílového</i> operandu se horních 32 bitů buď vynuluje (většina instrukcí) či znaménkově rozšíří. U 32bitových operací se navíc příznaky (zero, carry, negative...) nastavují pouze na základě 32bitového výsledku. Některé výjimky, které se týkají například bitových posunů a rotací, si popíšeme u jednotlivých demonstračních příkladů, kde se tyto instrukce použijí.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Možnosti adresování</h2>

<p>Díky použití pracovních registrů se šířkou 64 bitů se samozřejmě dosti podstatným způsobem rozšířil adresní prostor, který by jinak byl omezen na &bdquo;pouhých&ldquo; 32 bitů. Teoretický adresový rozsah 64 bitů je u architektury AArch64 ve skutečnosti snížen na 49 bitů virtuální adresy, což je však podle všeho dostačující, a to i pro relativně vzdálenou budoucnost. Navíc se horních osm bitů adresy ignoruje, což znamená, že do této oblasti registru použitého pro adresování je možné uložit &bdquo;tag&ldquo;. Tato technika se v&nbsp;některých programovacích jazycích používá pro rozlišení datového typu (příkladem mohou být jazyky odvozené od LISPu).</p>

<p>Některé další omezení je způsobeno tím, že všechny instrukce mají konstantní šířku 32 bitů:</p>

<ul>
<li>Pro podmíněné skoky může cíl skoku ležet v&nbsp;rozsahu &pm;1 MB</li>
<li>Pro relativní skoky může cíl opět ležet v&nbsp;rozsahu &pm;1 MB</li>
<li>U nepodmíněných skoků je rozsah větší, celých &pm;128 MB (což by mělo dostačovat pro prakticky všechny účely)</li>
<li>Generování adresy (ukládané do registru) lze implementovat dvojicí instrukcí pro rozsah 4GB</li>
</ul>



<p><a name="k09"></a></p>
<h2 id="k09">9. Zjednodušení instrukční sady</h2>

<p>Instrukční sada AArch64 se oproti původní 32bitové RISCové sadě v&nbsp;několika ohledech liší, především pak v&nbsp;následujících oblastech:</p>

<ol>
<li>Byly odstraněny instrukce <strong>LDM</strong>, <strong>STM</strong>, <strong>PUSH</strong> a <strong>POP</strong> ve variantě s bitovým polem registru</li>
<li>Naproti tomu lze použít instrukce <strong>LDP</strong> a <strong>STP</strong> pracující s&nbsp;libovolnými dvěma registry (zajímavá myšlenka na využití 32bitového slova)</li>
<li>Byly odstraněny prefixy pro podmínku, nyní jsou podmínky použity jen u skoků a několika dalších vybraných instrukcí</li>
<li>Byl odstraněn prefix <strong>IT</strong> známý z&nbsp;Thumb-2</li>
</ol>

<p>Tyto změny jsou založeny na výsledcích benchmarků, protože současné prediktory skoků jsou již velmi kvalitní. Navíc odstranění podmínkových bitů umožnilo použití více bitů v&nbsp;instrukčním slově pro jiné účely.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. První demonstrační příklad &ndash; šablona pro AArch64</h2>

<p>Podívejme se nyní na velmi jednoduchý demonstrační příklad. Jedná se o šablonu, kterou jsme si již ukázali pro jiné architektury (x86, PowerPC, s390, 32bitový ARM):</p>

<pre>
# asmsyntax=as

# Sablona pro zdrojovy kod Linuxoveho programu naprogramovaneho
# v assembleru GNU AS pro architekturu AArch64.
#
# Autor: Pavel Tisnovsky



# Linux kernel system call table
sys_exit=93



#-----------------------------------------------------------------------------
.section .data



#-----------------------------------------------------------------------------
.section .bss



#-----------------------------------------------------------------------------
.section .text
        .global _start          // tento symbol ma byt dostupny i z linkeru

_start:
        mov  x8, #sys_exit      // cislo sycallu pro funkci "exit"
        mov  x0, #0             // exit code = 0
        svc  0                  // volani Linuxoveho kernelu
</pre>

<p>Pro porovnání si ukažme stejný příklad, ovšem pro ARM 32:</p>

<pre>
# asmsyntax=as

# Sablona pro zdrojovy kod Linuxoveho programu naprogramovaneho
# v assembleru GNU AS.
#
# Autor: Pavel Tisnovsky



# Linux kernel system call table
sys_exit=1



#-----------------------------------------------------------------------------
.section .data



#-----------------------------------------------------------------------------
.section .bss



#-----------------------------------------------------------------------------
.section .text
        .global _start          @ tento symbol ma byt dostupny i z linkeru

_start:
        mov   r7,$sys_exit      @ cislo sycallu pro funkci "exit"
        mov   r0,#0             @ exit code = 0
        svc   0                 @ volani Linuxoveho kernelu
</pre>

<p>Změny, které musely být provedeny, jsou následující:</p>

<ol>
<li>U AArch64 se poznámky zapisují &bdquo;logicky&ldquo; pomocí znaků //</li>
<li>Namísto 32bitových registrů <strong>r0</strong> až <strong>r14</strong> se používají registry <strong>x0</strong> až <strong>x30</strong></li>
<li>Číslo syscallu se ukládá do registru <strong>x8</strong>, nikoli do <strong>r7</strong> (pomůcka: ARMv8 - x8, ARMv7 - r7)</li>
<li>Čísla syscallů jsou na AArch64 <a href="https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h">zcela odlišná</a>!</li>
</ol>



<p><a name="k11"></a></p>
<h2 id="k11">11. Disassemblovaný objektový kód prvního příkladu</h2>

<p>Náš demonstrační příklad přeložíme a slinkujeme následujícím způsobem:</p>

<pre>
as aarch64.s -o aarch64.o
ld -s aarch64.o
</pre>

<p>Pro zajímavost se podívejme na obsah vytvořeného spustitelného binárního souboru <strong>a.out</strong>. Tento obsah získáme příkazem:</p>

<pre>
objdump -f -d -t -h a.out
</pre>

<pre>
a.out:     file format elf64-littleaarch64
architecture: aarch64, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x0000000000400078

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         0000000c  0000000000400078  0000000000400078  00000078  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
SYMBOL TABLE:
no symbols



Disassembly of section .text:

0000000000400078 &lt;.text&gt;:
  400078:       d2800ba8        mov     x8, #0x5d                       // #93
  40007c:       d2800000        mov     x0, #0x0                        // #0
  400080:       d4000001        svc     #0x0
</pre>

<p>Povšimněte si, že všechny instrukce mají skutečně konstantní šířku 32 bitů. Navíc je zajímavé, že obě instrukce <strong>mov</strong> pracují se skutečnými konstantami uloženými přímo v&nbsp;instrukčním slově.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Druhý demonstrační příklad &ndash; tisk řetězce na standardní výstup</h2>

<p>Druhý demonstrační příklad je nepatrně složitější, protože se jedná o aplikaci typu Hello world, v&nbsp;níž musíme volat dvě funkce jádra &ndash; <strong>sys_write</strong> pro zápis na standardní výstup a <strong>sys_exit</strong> pro ukončení aplikace. Opět si povšimněte, že se čísla syscallů zcela odlišují od hodnot, s&nbsp;nimiž jsme se až doposud setkali:</p>

<pre>
# asmsyntax=as

# Jednoducha aplikace typu "Hello world!" naprogramovana
# v assembleru GNU as.
#
# Autor: Pavel Tisnovsky



# Linux kernel system call table
sys_exit=93
sys_write=64



#-----------------------------------------------------------------------------
.section .data

hello_lbl:
        .string "Hello World!\n"

#-----------------------------------------------------------------------------
.section .bss



#-----------------------------------------------------------------------------
.section .text
        .global _start          // tento symbol ma byt dostupny i linkeru

_start:
        mov  x8, #sys_write     // cislo sycallu pro funkci "write"
        mov  x0, #1             // standardni vystup
        ldr  x1, =hello_lbl     // adresa retezce, ktery se ma vytisknout
        mov  x2, #13            // pocet znaku, ktere se maji vytisknout
        svc  0                  // volani Linuxoveho kernelu

        mov  x8, #sys_exit      // cislo sycallu pro funkci "exit"
        mov  x0, #0             // exit code = 0
        svc  0                  // volani Linuxoveho kernelu
</pre>

<p>Za povšimnutí stojí použití pseudoinstrukce <strong>ldr</strong> pro načtení <i>adresy</i> počátečního znaku v&nbsp;řetězci.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Disassemblovaný objektový kód druhého příkladu</h2>

<p>Opět se podívejme na způsob překladu druhého demonstračního příkladu do strojového kódu. Poznámky budou uvedeny pod výpisem zdrojového kódu:</p>

<pre>
a.out:     file format elf64-littleaarch64
architecture: aarch64, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x00000000004000b0

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000028  00000000004000b0  00000000004000b0  000000b0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000e  00000000004100d8  00000000004100d8  000000d8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
SYMBOL TABLE:
no symbols



Disassembly of section .text:

00000000004000b0 &lt;.text&gt;:
  4000b0:       d2800808        mov     x8, #0x40                       // #64
  4000b4:       d2800020        mov     x0, #0x1                        // #1
  4000b8:       580000c1        ldr     x1, 0x4000d0
  4000bc:       d28001a2        mov     x2, #0xd                        // #13
  4000c0:       d4000001        svc     #0x0
  4000c4:       d2800ba8        mov     x8, #0x5d                       // #93
  4000c8:       d2800000        mov     x0, #0x0                        // #0
  4000cc:       d4000001        svc     #0x0
  4000d0:       004100d8        .inst   0x004100d8 ; undefined
  4000d4:       00000000        .inst   0x00000000 ; undefined
</pre>

<p>Jediná instrukce, která se přeložila složitějším způsobem, je instrukce <strong>ldr</strong>. Ta načítá konstantu uloženou od adresy <strong>4000d0</strong>. Tato adresa je 64 bitová, proto je rozepsána na dva řádky:</p>

<pre>
  4000d0:       004100d8        .inst   0x004100d8 ; undefined
  4000d4:       00000000        .inst   0x00000000 ; undefined
</pre>

<p>Po složení obou 32bitových slov získáme adresu 0x0000_0000_0041_00d8 ukazující přesně na začátek datové sekce, v&nbsp;níž je uložen řetězec &bdquo;Hello world!\n&ldquo;:</p>

<pre>
  1 .data         0000000e  00000000004100d8  00000000004100d8  000000d8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Cortex-A35<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php</a>
</li>

<li>Cortex-A53<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php</a>
</li>

<li>Cortex-A57<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php</a>
</li>

<li>Cortex-A72<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php</a>
</li>

<li>Cortex-A73<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php</a>
</li>

<li>System cally pro AArch64 na Linuxu<br />
<a href="https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h">https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</a>
</li>

<li>Architectures/AArch64 (FedoraProject.org)<br />
<a href="https://fedoraproject.org/wiki/Architectures/AArch64">https://fedoraproject.org/wiki/Architectures/AArch64</a>
</li>

<li>SIG pro AArch64 (CentOS)<br />
<a href="https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64">https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64</a>
</li>

<li>The ARMv8 instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>A64 Instruction Set<br />
<a href="https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set">https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set</a>
</li>

<li>Switching between the instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>The A64 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>Introduction to ARMv8 64-bit Architecture<br />
<a href="https://quequero.org/2014/04/introduction-to-arm-architecture/">https://quequero.org/2014/04/introduction-to-arm-architecture/</a>
</li>

<li>MCU market turns to 32-bits and ARM<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1280803">http://www.eetimes.com/document.asp?doc_id=1280803</a>
</li>

<li>Cortex-M0 Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0.php">http://www.arm.com/products/processors/cortex-m/cortex-m0.php</a>
</li>

<li>Cortex-M0+ Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php">http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php</a>
</li>

<li>ARM Processors in a Mixed Signal World<br />
<a href="http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world">http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_architecture">https://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>ARM Documentation: B, BL, BX, BLX, and BXJ<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0204j/Cihfddaf.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0204j/Cihfddaf.html</a>
</li>

<li>Branch and Call Sequences Explained<br />
<a href="https://community.arm.com/groups/processors/blog/2013/09/25/branch-and-call-sequences-explained">https://community.arm.com/groups/processors/blog/2013/09/25/branch-and-call-sequences-explained</a>
</li>

<li>Improving ARM Code Density and Performance<br />
<a href="New Thumb Extensions to the ARM Architecture Richard Phelan">New Thumb Extensions to the ARM Architecture Richard Phelan</a>
</li>

<li>Aarch64 Register and Instruction Quick Start<br />
<a href="https://wiki.cdot.senecacollege.ca/wiki/Aarch64_Register_and_Instruction_Quick_Start">https://wiki.cdot.senecacollege.ca/wiki/Aarch64_Register_and_Instruction_Quick_Start</a>
</li>

<li>Exploring AArch64 assembler – Chapter 1<br />
<a href="http://thinkingeek.com/2016/10/08/exploring-aarch64-assembler-chapter1/">http://thinkingeek.com/2016/10/08/exploring-aarch64-assembler-chapter1/</a>
</li>

<li>Exploring AArch64 assembler – Chapter 2<br />
<a href="http://thinkingeek.com/2016/10/08/exploring-aarch64-assembler-chapter-2/">http://thinkingeek.com/2016/10/08/exploring-aarch64-assembler-chapter-2/</a>
</li>

<li>The ARM Processor Architecture<br />
<a href="http://www.arm.com/products/processors/technologies/instruction-set-architectures.php">http://www.arm.com/products/processors/technologies/instruction-set-architectures.php</a>
</li>

<li>Thumb-2 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html</a>
</li>

<li>Introduction to ARM thumb<br />
<a href="http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb">http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb</a>
</li>

<li>ARM, Thumb, and ThumbEE instruction sets<br />
<a href="http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm">http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm</a>
</li>

<li>An Introduction to ARM Assembly Language<br />
<a href="http://dev.emcelettronica.com/introduction-to-arm-assembly-language">http://dev.emcelettronica.com/introduction-to-arm-assembly-language</a>
</li>

<li>Processors - ARM<br />
<a href="http://www.arm.com/products/processors/index.php">http://www.arm.com/products/processors/index.php</a>
</li>

<li>The ARM Instruction Set<br />
<a href="http://simplemachines.it/doc/arm_inst.pdf">http://simplemachines.it/doc/arm_inst.pdf</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ARM_architecture">http://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>C Functions Without Arguments<br />
<a href="https://eklitzke.org/c-functions-without-arguments">https://eklitzke.org/c-functions-without-arguments</a>
</li>

<li>GNU Assembler Examples<br />
<a href="http://cs.lmu.edu/~ray/notes/gasexamples/">http://cs.lmu.edu/~ray/notes/gasexamples/</a>
</li>

<li>Simply FPU<br />
<a href="http://www.website.masmforum.com/tutorials/fptute/">http://www.website.masmforum.com/tutorials/fptute/</a>
</li>

<li>Art of Assembly language programming: The 80x87 Floating Point Coprocessors<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html</a>
</li>

<li>Art of Assembly language programming: The FPU Instruction Set<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html</a>
</li>

<li>INTEL 80387 PROGRAMMER'S REFERENCE MANUAL<br />
<a href="http://www.ragestorm.net/downloads/387intel.txt">http://www.ragestorm.net/downloads/387intel.txt</a>
</li>

<li>x86 Instruction Set Reference: FLD<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_100.html">http://x86.renejeschke.de/html/file_module_x86_id_100.html</a>
</li>

<li>x86 Instruction Set Reference: FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_101.html">http://x86.renejeschke.de/html/file_module_x86_id_101.html</a>
</li>

<li>x86 Instruction Set Reference: FLD<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_100.html">http://x86.renejeschke.de/html/file_module_x86_id_100.html</a>
</li>

<li>x86 Instruction Set Reference: FST/FSTP<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_117.html">http://x86.renejeschke.de/html/file_module_x86_id_117.html</a>
</li>

<li>x86 Instruction Set Reference: BTC<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_23.html">http://x86.renejeschke.de/html/file_module_x86_id_23.html</a>
</li>

<li>x86 Instruction Set Reference: BTR<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_24.html">http://x86.renejeschke.de/html/file_module_x86_id_24.html</a>
</li>

<li>x86 Instruction Set Reference: BTS<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_25.html">http://x86.renejeschke.de/html/file_module_x86_id_25.html</a>
</li>

<li>x86 Instruction Set Reference: BSF<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_19.html">http://x86.renejeschke.de/html/file_module_x86_id_19.html</a>
</li>

<li>x86 Instruction Set Reference: BSR<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_20.html">http://x86.renejeschke.de/html/file_module_x86_id_20.html</a>
</li>

<li>x86 Instruction Set Reference: BSWAP<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_21.html">http://x86.renejeschke.de/html/file_module_x86_id_21.html</a>
</li>

<li>x86 Instruction Set Reference: XCHG<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_328.html">http://x86.renejeschke.de/html/file_module_x86_id_328.html</a>
</li>

<li>x86 Instruction Set Reference: SETcc<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_288.html">http://x86.renejeschke.de/html/file_module_x86_id_288.html</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>The GNU Assembler Tutorial<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html">http://tigcc.ticalc.org/doc/gnuasm.html</a>
</li>

<li>The GNU Assembler - macros<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html#SEC109">http://tigcc.ticalc.org/doc/gnuasm.html#SEC109</a>
</li>

<li>ARM subroutines &amp; program stack<br />
<a href="http://www.toves.org/books/armsub/">http://www.toves.org/books/armsub/</a>
</li>

<li>Generating Mixed Source and Assembly List using GCC<br />
<a href="http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/">http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/</a>
</li>

<li>Calling subroutines<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm</a>
</li>

<li>ARM Assembly Language Programming<br />
<a href="http://peter-cockerell.net/aalp/html/frames.html">http://peter-cockerell.net/aalp/html/frames.html</a>
</li>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Intel x86 JUMP quick reference<br />
<a href="http://unixwiz.net/techtips/x86-jumps.html">http://unixwiz.net/techtips/x86-jumps.html</a>
</li>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Assembler pod Linuxem<br />
<a href="http://phoenix.inf.upol.cz/linux/prog/asm.html">http://phoenix.inf.upol.cz/linux/prog/asm.html</a>
</li>

<li>AT&amp;T Syntax versus Intel Syntax<br />
<a href="https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html">https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html</a>
</li>

<li>Linux Assembly website<br />
<a href="http://asm.sourceforge.net/">http://asm.sourceforge.net/</a>
</li>

<li>Using Assembly Language in Linux<br />
<a href="http://asm.sourceforge.net/articles/linasm.html">http://asm.sourceforge.net/articles/linasm.html</a>
</li>

<li>vasm<br />
<a href="http://sun.hasenbraten.de/vasm/">http://sun.hasenbraten.de/vasm/</a>
</li>

<li>vasm &ndash; dokumentace<br />
<a href="http://sun.hasenbraten.de/vasm/release/vasm.html">http://sun.hasenbraten.de/vasm/release/vasm.html</a>
</li>

<li>The Yasm Modular Assembler Project<br />
<a href="http://yasm.tortall.net/">http://yasm.tortall.net/</a>
</li>

<li>680x0:AsmOne<br />
<a href="http://www.amigacoding.com/index.php/680x0:AsmOne">http://www.amigacoding.com/index.php/680x0:AsmOne</a>
</li>

<li>ASM-One Macro Assembler<br />
<a href="http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler">http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler</a>
</li>

<li>ASM-One pages<br />
<a href="http://www.theflamearrows.info/documents/asmone.html">http://www.theflamearrows.info/documents/asmone.html</a>
</li>

<li>Základní informace o ASM-One<br />
<a href="http://www.theflamearrows.info/documents/asminfo.html">http://www.theflamearrows.info/documents/asminfo.html</a>
</li>

<li>Linux Syscall Reference<br />
<a href="http://syscalls.kernelgrok.com/">http://syscalls.kernelgrok.com/</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>IBM System 360/370 Compiler and Historical Documentation<br />
<a href="http://www.edelweb.fr/Simula/">http://www.edelweb.fr/Simula/</a>
</li>

<li>IBM 700/7000 series<br />
<a href="http://en.wikipedia.org/wiki/IBM_700/7000_series">http://en.wikipedia.org/wiki/IBM_700/7000_series</a>
</li>

<li>IBM System/360<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/360">http://en.wikipedia.org/wiki/IBM_System/360</a>
</li>

<li>IBM System/370<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/370">http://en.wikipedia.org/wiki/IBM_System/370</a>
</li>

<li>Mainframe family tree and chronology<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html</a>
</li>

<li>704 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html</a>
</li>

<li>705 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html</a>
</li>

<li>The IBM 704<br />
<a href="http://www.columbia.edu/acis/history/704.html">http://www.columbia.edu/acis/history/704.html</a>
</li>

<li>IBM Mainframe album<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html</a>
</li>

<li>Osmibitové muzeum<br />
<a href="http://osmi.tarbik.com/">http://osmi.tarbik.com/</a>
</li>

<li>Tesla PMI-80<br />
<a href="http://osmi.tarbik.com/cssr/pmi80.html">http://osmi.tarbik.com/cssr/pmi80.html</a>
</li>

<li>PMI-80<br />
<a href="http://en.wikipedia.org/wiki/PMI-80">http://en.wikipedia.org/wiki/PMI-80</a>
</li>

<li>PMI-80<br />
<a href="http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016">http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016</a>
</li>

<li>The 6502 overflow flag explained mathematically <br />
<a href="http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html">http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html</a>
</li>

<li>X86 Opcode and Instruction Reference<br />
<a href="http://ref.x86asm.net/coder32.html">http://ref.x86asm.net/coder32.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

