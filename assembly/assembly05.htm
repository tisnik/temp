<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Použití assembleru v Linuxu: podmínky, rozvětvení a programové smyčky na procesorech ARM</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Použití assembleru v Linuxu: podmínky, rozvětvení a programové smyčky na procesorech ARM</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Příznakové bity a podmíněné skoky, se kterými jsme se setkali už ve čtvrté části tohoto seriálu, se samozřejmě nepoužívají pouze na platformách i386 a x86_64. Podobný systém můžeme nalézt i u mikroprocesorů s&nbsp;architekturou ARM, v&nbsp;nichž je dokonce možné použít podmínky u prakticky všech instrukcí. Právě s&nbsp;tímto zajímavým konceptem se dnes podrobněji seznámíme.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Použití assembleru v&nbsp;Linuxu: podmínky, rozvětvení a programové smyčky na procesorech ARM</a></p>
<p><a href="#k02">2. Malé zopakování z&nbsp;minula &ndash; příznakové bity a instrukce podmíněného skoku na i386 a x86_64</a></p>
<p><a href="#k03">3. Stavové registry na mikroprocesorech s&nbsp;architekturou ARM</a></p>
<p><a href="#k04">4. Příznakové a stavové bity na mikroprocesorech s&nbsp;architekturou ARM</a></p>
<p><a href="#k05">5. Podmínky specifikované u instrukcí (<i>condition codes</i>)</a></p>
<p><a href="#k06">6. Instrukce podmíněného i nepodmíněného skoku v&nbsp;režimu ARM</a></p>
<p><a href="#k07">7. Nastavení příznakových bitů u aritmetických instrukcí</a></p>
<p><a href="#k08">8. První praktický příklad &ndash; jednoduchá počítaná programová smyčka</a></p>
<p><a href="#k09">9. Druhý praktický příklad &ndash; nastavení příznakových bitů při odečítání jedničky instrukcí <strong>sub</strong></a></p>
<p><a href="#k10">10. Třetí praktický příklad &ndash; počítaná programová smyčka s&nbsp;testem provedeným na začátku</a></p>
<p><a href="#k11">11. Čtvrtý praktický příklad &ndash; optimalizace předchozího příkladu instrukcí <strong>subs</strong></a></p>
<p><a href="#k12">12. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k13">13. Optimalizace kódu (počtu instrukcí) při výpočtu největšího společného dělitele</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Použití assembleru v&nbsp;Linuxu: podmínky, rozvětvení a programové smyčky na procesorech ARM</h2>

<p><a href="http://mojefedora.cz/pouziti-assembleru-v-linuxu-podminky-rozvetveni-a-programove-smycky/">V&nbsp;předchozí části</a> seriálu o použití assembleru v&nbsp;operačním systému Linux jsme se seznámili s&nbsp;takzvanými <i>příznakovými bity</i>, které se v&nbsp;assembleru používají společně s&nbsp;instrukcemi určenými pro podmíněné skoky k&nbsp;implementaci rozvětvení a taktéž pro implementaci různých typů programových smyček. Ukázali jsme si, jak je tento koncept využitý u mikroprocesorů s&nbsp;32bitovou architekturou i386 i se 64bitovou architekturou x86_64. Příznakové bity se ovšem používají i u dalších mikroprocesorových architektur, včetně populárních čipů typu ARM (určitou výjimku z&nbsp;tohoto trendu představují čipy s&nbsp;architekturami MIPS, RISC-V, DEC Alpha a taktéž některé VLIW architektury). Právě architekturou ARM a konceptem příznakových bitů kombinovaných s&nbsp;takzvanými podmínkovými kódy se budeme zabývat v&nbsp;dnešním článku. Navíc si přepíšeme dva demonstrační příklady ukázané minule do formy vhodné právě pro mikroprocesory s&nbsp;architekturou ARM. Prozatím se pro jednoduchost budeme zabývat &bdquo;klasickou&ldquo; 32bitovou RISCovou instrukční sadou těchto mikroprocesorů, nikoli sadou Thumb či Thumb-2.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Malé zopakování z&nbsp;minula &ndash; příznakové bity a instrukce podmíněného skoku na i386 a x86_64</h2>

<p>Pro úplnost a i pro vzájemné porovnání různých přístupů k&nbsp;dané problematice si jen velmi stručně připomeňme, jakým způsobem je koncept příznakových bitů a podmíněných skoků realizován na mikroprocesorech s&nbsp;architekturou i386 a x86_64. Všechny příznakové bity jsou uloženy v&nbsp;registru <strong>EFLAGS</strong> (32bitové prostředí) popř.&nbsp;<strong>RFLAGS</strong> (64bitové prostředí), přičemž mezi základní příznaky používané v&nbsp;praxi velmi často patří především příznaky nazvané <strong>Carry flag</strong>, <strong>Sign flag</strong>, <strong>Zero flag</strong> a <strong>Overflow flag</strong>, tj.&nbsp;<i>příznak přenosu</i>, <i>příznak záporného výsledku</i>, <i>příznak nulovosti</i> a <i>příznak přetečení</i>. Význam těchto příznakových bitů se shrnut v&nbsp;následující tabulce:</p>

<table>
<tr><th>Příznak</th><th>Význam zkratky</th><th>Poznámka</th></tr>
<tr><td>ZF</td><td>zero flag</td><td>výsledek předchozí operace je nulový</td></tr>
<tr><td>CF</td><td>carry flag</td><td>přenos (bezznaménková aritmetika, unsigned)</td></tr>
<tr><td>SF</td><td>sign flag</td><td>výsledek je záporný (nastaven nejvyšší bit bajtu či slova)</td></tr>
<tr><td>OF</td><td>overflow flag</td><td>přenos/přetečení ve znaménkové aritmetice (signed)</td></tr>
</table>

<p>Tyto příznakové bity jsou nastavovány aritmetickými instrukcemi i instrukcemi určenými pro porovnání operandů. Dále mohou být otestovány a použity v&nbsp;instrukcích podmíněných skoků. Pro jednoduchost na chvíli zapomeňme na práci s&nbsp;čísly se znaménkem (těm bude věnován samostatný článek, protože se jedná o relativně rozsáhlou problematiku), takže se počet podmíněných skoků prozatím redukuje na pouhých šest instrukcí:</p>

<table>
<tr><th>Mnemotechnická zkratka instrukce</th><th>Význam instrukce podmíněného skoku</th></tr>
<tr><td>JC </td><td>podmíněný skok provedený za předpokladu, že je nastaven příznak přenosu (<strong>Carry flag</strong>)</td></tr>
<tr><td>JNC</td><td>podmíněný skok provedený za předpokladu, že je vynulován příznak přenosu (<strong>Carry flag</strong>)</td></tr>
<tr><td>JZ </td><td>podmíněný skok provedený za předpokladu, že je nastaven příznak nulovosti (<strong>Zero flag</strong>)</td></tr>
<tr><td>JNZ</td><td>podmíněný skok provedený za předpokladu, že je vynulován příznak nulovosti (<strong>Zero flag</strong>)</td></tr>
<tr><td>JS </td><td>podmíněný skok provedený za předpokladu, že je nastaven příznak záporného výsledku (<strong>Sign flag</strong>)</td></tr>
<tr><td>JNS</td><td>podmíněný skok provedený za předpokladu, že je vynulován příznak záporného výsledku (<strong>Sign flag</strong>)</td></tr>
</table>

<p>Pro některé z&nbsp;výše uvedených instrukcí určených pro provedení podmíněných skoků existují i takzvané jmenné aliasy, což jsou ve skutečnosti zcela totožné instrukce, které ovšem mají jiné jméno. S&nbsp;těmito aliasy je dobré se seznámit, protože je nalezneme například při výpisu disassembleru či při práci s&nbsp;některými debuggery (používá je například i GNU Debugger a nástroj <strong>objdump</strong>, což jsme si ověřili <a href="http://mojefedora.cz/pouziti-assembleru-v-linuxu-podminky-rozvetveni-a-programove-smycky/#k07">minule</a>):</p>

<table>
<tr><th>Instrukce</th><th>Alias</th></tr>
<tr><td>JZ </td><td>JE </td></tr>
<tr><td>JNZ</td><td>JNE</td></tr>
<tr><td>JC </td><td>JB, JNAE</td></tr>
<tr><td>JNC</td><td>JNB, JAE</td></tr>
<tr><td>JS </td><td>nemá alias</td></tr>
<tr><td>JNS</td><td>nemá alias</td></tr>
</table>

<p>Poznámka: povšimněte si, že každá instrukce skoku testuje pouze jediný příznakový bit (jeho nulovost či naopak nenulovost). Ve skutečnosti však existují i takové skokové instrukce, v&nbsp;nichž se testuje kombinace několika příznakových bitů či jejich negací. S&nbsp;těmito instrukcemi a především s&nbsp;jejich významem pro praxi se seznámíme příště.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Stavové registry na mikroprocesorech s&nbsp;architekturou ARM</h2>

<p>Nyní se již konečně můžeme zabývat populární architekturou ARM. Kromě patnácti 32bitových pracovních registrů a programového čítače obsahují mikroprocesory s&nbsp;touto architekturou i registry, v&nbsp;nichž se uchovávají různé příznaky. V&nbsp;uživatelském režimu se pracuje s&nbsp;příznaky uloženými v&nbsp;registru nazvaném <strong>CPSR</strong> (<i>Current Program Status Register</i>) a pro každý další režim existuje navíc zvláštní registr nazvaný <strong>SPSR</strong> (<i>Saved Program Status Register</i>), v&nbsp;němž jsou uchovány původní příznaky ze <strong>CPSR</strong>. Podobně jako všechny pracovní registry, mají i registry <strong>CPSR</strong> a <strong>SPSR</strong> shodnou šířku 32 bitů, což má svoje výhody. Mimo jiné i to, že šířka 32 bitů ponechala konstruktérům procesorů ARM mnoho prostoru pro uložení různých důležitých informací do registrů <strong>CPSR/SPSR</strong>, takže se nemuseli uchylovat k&nbsp;nepříliš promyšleným technikám známým například z&nbsp;platformy x86, kde se původně šestnáctibitový registr <strong>FLAGS</strong> (<i>8086</i>) postupně změnil na 32bitový registr <strong>EFLAGS</strong> (<i>80386</i>), vedle něho vznikl registr <strong>MSW</strong> (<i>80286</i>) rozšířený na <strong>CR0</strong> atd.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Příznakové a stavové bity na mikroprocesorech s&nbsp;architekturou ARM</h2>

<p>Ve výše zmíněných stavových registrech <strong>CPSR/SPSR</strong> mikroprocesorů ARM jsou uloženy především příznakové bity nastavované aritmeticko-logickou jednotkou při provádění základních aritmetických instrukcí či bitových operací, dále pak bity určující, jakou instrukční sadu mikroprocesor v&nbsp;daný okamžik zpracovává (<i>ARM</i>, <i>Thumb</i>, <i>Jazelle</i>), příznak pořadí zpracovávání bajtů (little/big endian) a taktéž příznaky používané u SIMD operací. Zdaleka ne všechny mikroprocesory ARM však skutečně pracují se všemi bity, což je logické, protože například příznak <strong>Q</strong> je používán jen u mikroprocesorů podporujících aritmetiku se saturací, příznak <strong>J</strong> u čipů s&nbsp;podporou technologie <i>Jazelle</i> atd. Pojďme si tedy jednotlivé příznakové i stavové bity vypsat. Povšimněte si, že především první čtyři bity mají prakticky shodný název i stejný význam, jako je tomu u již popsané architektury i386 a x86_64 (rozdíl je jen v&nbsp;pojmenování příznaku <i>sign flag</i> a <i>negative flag</i>, význam je však shodný):</p>

<table>
<tr><th>Příznak</th><th>Význam zkratky</th><th>Poznámka</th></tr>
<tr><td>N</td><td>negative</td><td>výsledek ALU operace je záporný</td></tr>
<tr><td>V</td><td>overflow</td><td>přetečení (znaménková aritmetika, signed)</td></tr>
<tr><td>Z</td><td>zero</td><td>výsledek je nulový</td></tr>
<tr><td>C</td><td>carry</td><td>přenos (bezznaménková aritmetika, unsigned)</td></tr>
<tr><td>Q</td><td>sticky overflow</td><td>aritmetika se saturací, od ARMv5e výše</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>I</td><td>interrupt</td><td>zákaz IRQ (přerušení)</td></tr>
<tr><td>F</td><td>fast interrupt</td><td>zákaz FIRQ (rychlého přerušení)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>T</td><td>thumb</td><td>příznak zpracování instrukční sady Thumb (jen u procesorů se znakem "T" v&nbsp;názvu)</td></tr>
<tr><td>J</td><td>jazelle</td><td>příznak zpracování instrukční sady Jazelle (jen u procesorů se znakem "J" v&nbsp;názvu)</td></tr>
<tr><td>E</td><td>endianness</td><td>pořadí bajtů při práci s RAM (big/little endian)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>GE</td><td>4 bity</td><td>použito u SIMD operací (pouze některé čipy)</td></tr>
<tr><td>IF</td><td>5 bitů</td><td>použito u instrukcí Thumb2 (pouze některé čipy)</td></tr>
<tr><td>M</td><td>5 bitů</td><td>režim práce mikroprocesoru (user, IRQ, FIRQ, ...)</td></tr>
</table>

<p>Poznámka: v&nbsp;tabulce zobrazené výše nejsou jednotlivé bity uvedeny v&nbsp;takovém pořadí, v&nbsp;jakém se nachází ve stavovém registru; sdruženy jsou podle své funkce.</p>

<p>V&nbsp;dalším textu nás budou zajímat opět pouze tři příznakové bity: <strong>Z</strong>, <strong>C</strong> a <strong>N</strong>, podobně jako tomu bylo ve čtvrté části tohoto seriálu.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Podmínky specifikované u instrukcí (<i>condition codes</i>)</h2>

<p>U klasické RISCové instrukční sady ARM se v&nbsp;nejvyšších čtyřech bitech každé instrukce nachází takzvaný kód podmínky. Konstruktéři těchto mikroprocesorů totiž (alespoň částečně) vyřešili problematiku podmíněných skoků tím, že umožnili vykonat každou instrukci pouze v&nbsp;tom případě, že je splněna podmínka, jejích kód je zapsán právě v&nbsp;oněch čtyřech nejvyšších bitech instrukce. A o jakou problematiku podmíněných skoků se vlastně jedná? Podmíněné skoky představují pro klasickou RISCovou pipeline obtížný úkol: důvodem existence instrukční pipeline je to, aby se v&nbsp;každém taktu v&nbsp;ideálním případě dokončila jedna instrukce. U skoků, zvláště těch podmíněných, se však již <strong>před</strong> rozhodnutím, zda se skok provede či nikoli, začnou zpracovávat další instrukce umístěné za skokem, což však znamená, že se v&nbsp;případě provedení skoku tyto instrukce ve skutečnosti nemají vykonat. Konstruktéři RISCových a posléze i CISCových mikroprocesorů tedy hledali různé způsoby řešení této problematiky, ať se již jedná o spekulativní provádění instrukcí (příliš mnoho tranzistorů) či o prediktory skoků (ne vždy jsou úspěšné).</p>

<p>Díky tomu, že u mikroprocesorů <i>ARM</i> lze podmínku vykonání zadat u každé instrukce, je možné, aby se celkový počet podmíněných skoků v&nbsp;programu minimalizoval. Zejména se to týká skoků používaných pro implementaci programové konstrukce <strong>if-then-else</strong>, kde se v&nbsp;jednotlivých větvích nachází jen malé množství instrukcí. Aby však mělo použití podmínkových kódů smysl, musela se změnit ještě jedna vlastnost procesorů <i>ARM</i>: jejich aritmeticko-logická jednotka totiž změní stavové bity <i>carry</i>, <i>zero</i>, <i>overflow</i> a <i>negative</i> pouze v&nbsp;tom případě, že je to explicitně v&nbsp;instrukčním kódu zapsáno (výjimku tvoří porovnávací instrukce). Touto vlastností se budeme zabývat až v&nbsp;následujícím textu.</p>

<p>První sada podmínkových kódů se používá pro provedení či naopak neprovedení instrukce na základě hodnoty jednoho z&nbsp;příznakových bitů <i>zero</i>, <i>overflow</i> či <i>negative</i>. Poslední podmínkový kód z&nbsp;této skupiny má název <i>AL (Any/Always)</i> a značí, že se instrukce provede v&nbsp;každém případě. Tento podmínkový kód se tudíž většinou v&nbsp;assembleru nezapisuje, protože je (celkem pochopitelně) považován za implicitní:</p>

<table>
<tr><th>Kód</td></th><th>Přípona</th><th>Význam</th><th>Testovaná podmínka</th></tr>
<tr><td>0000</td><td>EQ</td><td>Z set     </td><td>rovnost (či nulový výsledek)</td></tr>
<tr><td>0001</td><td>NE</td><td>Z clear   </td><td>nerovnost (či nenulový výsledek)</td></tr>
<tr><td>0100</td><td>MI</td><td>N set     </td><td>výsledek je záporný</td></tr>
<tr><td>0101</td><td>PL</td><td>N clear   </td><td>výsledek je kladný či 0</td></tr>
<tr><td>0110</td><td>VS</td><td>V set     </td><td>nastalo přetečení</td></tr>
<tr><td>0111</td><td>VC</td><td>V clear   </td><td>nenastalo přetečení</td></tr>
<tr><td>1110</td><td>AL</td><td>Any/Always</td><td>většinou se nezapisuje, implicitní podmínka</td></tr>
</table>

<p>Další čtyři podmínkové kódy se většinou používají při porovnávání dvou hodnot bez znaménka (unsigned). V&nbsp;těchto případech se testují stavy příznakových bitů <i>carry</i> a <i>zero</i>, přesněji řečeno kombinací těchto bitů:</p>

<table>
<tr><th>Kód</td><th>Přípona</th><th>Význam</th><th>Testovaná podmínka</th></tr>
<tr><td>0010</td><td>CS/HS</td><td>C set            </td><td>&gt;=</td></tr>
<tr><td>0011</td><td>CC/LO</td><td>C clear          </td><td>&lt;</td></tr>
<tr><td>1000</td><td>HI   </td><td>C set and Z clear</td><td>&gt;</td></tr>
<tr><td>1001</td><td>LS   </td><td>C clear or Z set </td><td>&lt;=</td></tr>
</table>

<p>Poslední čtyři podmínkové kódy se používají pro porovnávání hodnot se znaménkem (signed). V&nbsp;těchto případech se namísto příznakových bitů <i>carry</i> a <i>zero</i> testují kombinace bitů <i>negative</i>, <i>overflow</i> a <i>zero</i>:</p>

<table>
<tr><th>Kód</td><th>Přípona</th><th>Význam</th><th>Testovaná podmínka</th></tr>
<tr><td>1010</td><td>GE</td><td>N and V the same</td><td>&gt;=</td></tr>
<tr><td>1011</td><td>LT</td><td>N and V differ  </td><td>&lt;</td></tr>
<tr><td>1100</td><td>GT</td><td>Z clear, N == V </td><td>&gt;</td></tr>
<tr><td>1101</td><td>LE</td><td>Z set, N != V   </td><td>&lt;=</td></tr>
</table>



<p><a name="k06"></a></p>
<h2 id="k06">6. Instrukce podmíněného i nepodmíněného skoku v&nbsp;režimu ARM</h2>

<p>Podobně, jako je tomu i u dalších instrukčních sad (<i>ISA</i>), najdeme i v&nbsp;instrukčním souboru mikroprocesorů <i>ARM</i> několik instrukcí určených pro provedení skoku. Tyto instrukce lze (poněkud zjednodušeně řečeno) považovat za instrukce, které do registru <i>PC/R15</i> vloží novou konstantu, popř.&nbsp;navíc uloží původní obsah registru <i>PC/14</i> do registru <i>LR/R14</i> (v&nbsp;tomto případě je však situace komplikovanější, protože obsah registru PC se již kvůli posunu instrukce v&nbsp;pipeline zvýšil o hodnotu 8; podrobnosti si řekneme v&nbsp;dalším textu).</p>

<p>Základní instrukcí skoku je instrukce pojmenovaná jednoduše <strong>B</strong>, což je zkratka od slova <i>branch</i>. 32bitové slovo této instrukce je rozděleno na tři části. V&nbsp;nejvyšších čtyřech bitech se nachází kód podmínky, což v&nbsp;důsledku znamená, že jediná instrukce <strong>B</strong> může nahradit všechny formy podmíněných skoků (přesněji řečeno čtrnáct typů podmíněných skoků a jeden skok nepodmíněný). Za těmito čtyřmi bity následuje taktéž čtyřbitový operační kód <strong>1010</strong> a ve zbylých 24 bitech je pak uložena konstanta, z&nbsp;níž se vypočítá offset skoku:</p>

<pre>
31     27     23                         0
+------+------+--------------------------+
| cond | 1010 |       offset skoku       |
+------+------+--------------------------+
</pre>

<p>Vzhledem k&nbsp;tomu, že všechny instrukce jsou v&nbsp;operační paměti zarovnány na adresu dělitelnou čtyřmi, je před provedením skoku 24bitová konstanta obsažená v&nbsp;instrukci posunuta o dva bity doleva. Výsledkem je 26bitová konstanta (mající dva nejnižší bity nulové), která je při provádění skoku přičtena k&nbsp;aktuální hodnotě registru <i>PC</i>. Jednoduše lze spočítat, že díky použití 26bitové konstanty lze provést podmíněný či nepodmíněný skok v&nbsp;rozsahu +-32 MB. Důležité je, že se při překladu programu z&nbsp;assembleru musí při výpočtu offsetu odečíst od aktuální hodnoty registru <i>PC</i> hodnota osm, a to z&nbsp;toho důvodu, že se skok provádí až ve fázi <i>execute</i>, tj.&nbsp;ve chvíli, kdy se již v&nbsp;instrukční pipeline nachází další dvě instrukce: jedna ve fázi <i>decode</i> (ta byla přečtena z&nbsp;adresy <i>původní PC+4</i>) a druhá teprve ve fázi <i>fetch</i> a registr <i>PC</i> již obsahuje adresu této nejpozději načtené instrukce (<i>původní PC+8</i>). Pozdější varianty mikroprocesorů ARM sice již mají pipeline s&nbsp;jiným počtem řezů, ovšem toto chování zůstalo kvůli zpětné kompatibilitě zachováno.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Nastavení příznakových bitů u aritmetických instrukcí</h2>

<p>Mezi základní aritmetické instrukce patří samozřejmě instrukce součtu a rozdílu. U instrukcí rozdílu je zajímavé, že existují ve dvou variantách podle toho, zda se odečítá první operand od druhého nebo naopak. Motivace je zřejmá &ndash; pro oba operandy existují odlišná pravidla:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>ADD</td><td>operand1+operand2</td></tr>
<tr><td>2</td><td>ADC</td><td>operand1+operand2+carry</td></tr>
<tr><td>3</td><td>SUB</td><td>operand1-operand2</td></tr>
<tr><td>4</td><td>SBC</td><td>operand1-operand2+carry-1</td></tr>
<tr><td>5</td><td>RSB</td><td>operand2-operand1</td></tr>
<tr><td>6</td><td>RSC</td><td>operand2-operand1+carry-1</td></tr>
</table>

<p>Tyto instrukce navíc ještě ve svém slově obsahují takzvaný <i>S-bit</i> určující, zda má instrukce nastavit příznaky ALU (N, V, Z, C) na základě výsledku operace. Jediné instrukce, u nichž je tento bit nastaven stále, jsou instrukce provádějící porovnání bez uložení výsledku operace (popsané ihned v&nbsp;následujícím odstavci):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>ADDS</td><td>operand1+operand2 a současně nastavení příznakových bitů</td></tr>
<tr><td>2</td><td>ADCS</td><td>operand1+operand2+carry a současně nastavení příznakových bitů</td></tr>
<tr><td>3</td><td>SUBS</td><td>operand1-operand2 a současně nastavení příznakových bitů</td></tr>
<tr><td>4</td><td>SBCS</td><td>operand1-operand2+carry-1 a současně nastavení příznakových bitů</td></tr>
<tr><td>5</td><td>RSBS</td><td>operand2-operand1 a současně nastavení příznakových bitů</td></tr>
<tr><td>6</td><td>RSCS</td><td>operand2-operand1+carry-1 a současně nastavení příznakových bitů</td></tr>
</table>

<p>Další skupinou instrukcí jsou instrukce provádějící nějakou aritmetickou či logickou operaci. Ovšem výsledek této operace se nikam neuloží, pouze se nastaví příznakové bity (navíc se tyto bity nastaví vždy, není zde možnost volby bitu <i>S</i>):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>CMP</td><td>operand1-operand2</td></tr>
<tr><td>2</td><td>CMN</td><td>operand1+operand2 (compare negative)</td></tr>
<tr><td>3</td><td>TST</td><td>operand1 and operand2</td></tr>
<tr><td>4</td><td>TEQ</td><td>operand1 xor operand2</td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. První praktický příklad &ndash; jednoduchá počítaná programová smyčka</h2>

<p>Konečně se dostáváme k&nbsp;demonstračním příkladům. V&nbsp;prvním demonstračním příkladu je ukázána implementace programové smyčky, v&nbsp;níž se nejprve naplní řetězec čtyřiceti znaky hvězdičky a následně se tento řetězec vytiskne na standardní výstup. Popišme si nyní podrobněji některé zajímavé instrukce. Pro načtení adresy bufferu do registru R1 se použije zápis:</p>

<pre>
ldr   r1, =buffer            @ zapis se bude provadet do tohoto bufferu
</pre>

<p>Samotný zápis do bufferu (tedy do paměti) zajišťuje instrukce <strong>strb</strong>, tedy &bdquo;store byte&ldquo;. Adresa je uložena v&nbsp;registru R1, dolních osm bitů registru R3 obsahuje kód znaku:</p>

<pre>
strb  r3, [r1]               @ zapis znaku do bufferu
</pre>

<p>Samotná programová smyčka s&nbsp;počitadlem reprezentovaným registrem R2 vypadá takto:</p>

<pre>
loop:
        strb  r3, [r1]               @ zapis znaku do bufferu
        add   r1, r1, #1             @ uprava ukazatele do bufferu
        sub   r2, r2, #1             @ zmenseni pocitadla
        cmp   r2, #0                 @ otestovani, zda jsme jiz nedosahli nuly
        bne   loop                   @ pokud jsme se nedostali k nule, skok na zacatek smycky
</pre>

<p>Povšimněte si použití instrukce <strong>sub</strong> pro snížení hodnoty počitadla, po níž následuje test <strong>cmp</strong> na kontrolu, zda počitadlo dosáhlo nulové hodnoty.</p>

<p>Následuje výpis celého zdrojového kódu tohoto demonstračního příkladu:</p>

<pre>
# asmsyntax=as
 
# Testovaci program naprogramovany v assembleru GNU as
# - pocitana programova smycka
# - uprava pro mikroprocesory s architekturou ARM
#
# Autor: Pavel Tisnovsky
 
 
 
# Linux kernel system call table
sys_exit   = 1
sys_write  = 4
 
# Dalsi konstanty pouzite v programu - standardni streamy
std_input  = 0
std_output = 1

# pocet opakovani znaku
rep_count  = 40
 
 
 
#-----------------------------------------------------------------------------
.section .data
 
 
 
#-----------------------------------------------------------------------------
.section .bss
        .lcomm buffer, rep_count     @ rezervace bufferu pro vystup
 
 
 
#-----------------------------------------------------------------------------
.section .text
        .global _start               @ tento symbol ma byt dostupny i linkeru
 
_start:
        ldr   r1, =buffer            @ zapis se bude provadet do tohoto bufferu
        mov   r2, $rep_count         @ pocet opakovani znaku
        mov   r3, #'*'               @ zapisovany znak
loop:
        strb  r3, [r1]               @ zapis znaku do bufferu
        add   r1, r1, #1             @ uprava ukazatele do bufferu
        sub   r2, r2, #1             @ zmenseni pocitadla
        cmp   r2, #0                 @ otestovani, zda jsme jiz nedosahli nuly
        bne   loop                   @ pokud jsme se nedostali k nule, skok na zacatek smycky
 
        mov   r7, $sys_write         @ cislo syscallu pro funkci "write"
        mov   r0, $std_output        @ standardni vystup
        ldr   r1, =buffer            @ adresa retezce, ktery se ma vytisknout
        mov   r2, $rep_count         @ pocet znaku, ktere se maji vytisknout
        svc   0                      @ volani Linuxoveho kernelu
 
        mov   r7, $sys_exit          @ cislo sycallu pro funkci "exit"
        mov   r0, #0                 @ exit code = 0
        svc   0                      @ volani Linuxoveho kernelu
</pre>

<p>Překlad a slinkování se provede příkazy:</p>

<pre>
as loop1-arm-v1.s -o loop1-arm-v1.o
ld -s loop1-arm-v1.o
</pre>

<p>Výpis obsahu vytvořeného spustitelného souboru:</p>

<pre>
a.out:     file format elf32-littlearm
architecture: armv4, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x00008074

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000044  00008074  00008074  00000074  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000028  000100b8  000100b8  000000b8  2**3
                  ALLOC
  2 .ARM.attributes 00000014  00000000  00000000  000000b8  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
no symbols



Disassembly of section .text:

00008074 &lt;.text&gt;:
    8074:	e59f1038 	ldr	r1, [pc, #56]	; 0x80b4
    8078:	e3a02028 	mov	r2, #40	; 0x28
    807c:	e3a0302a 	mov	r3, #42	; 0x2a
    8080:	e5c13000 	strb	r3, [r1]
    8084:	e2811001 	add	r1, r1, #1
    8088:	e2422001 	sub	r2, r2, #1
    808c:	e3520000 	cmp	r2, #0
    8090:	1afffffa 	bne	0x8080
    8094:	e3a07004 	mov	r7, #4
    8098:	e3a00001 	mov	r0, #1
    809c:	e59f1010 	ldr	r1, [pc, #16]	; 0x80b4
    80a0:	e3a02028 	mov	r2, #40	; 0x28
    80a4:	ef000000 	svc	0x00000000
    80a8:	e3a07001 	mov	r7, #1
    80ac:	e3a00000 	mov	r0, #0
    80b0:	ef000000 	svc	0x00000000
    80b4:	000100b8 	strheq	r0, [r1], -r8
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Druhý praktický příklad &ndash; nastavení příznakových bitů při odečítání jedničky instrukcí <strong>sub</strong></h2>

<p>Programová smyčka implementovaná v&nbsp;předchozím příkladu není příliš dokonalá, protože se zbytečně provádí dvě instrukce pro snížení počitadla a test na nulu namísto použití instrukce jediné:</p>

<pre>
loop:
        strb  r3, [r1]               @ zapis znaku do bufferu
        add   r1, r1, #1             @ uprava ukazatele do bufferu
        sub   r2, r2, #1             @ zmenseni pocitadla
        cmp   r2, #0                 @ otestovani, zda jsme jiz nedosahli nuly
        bne   loop                   @ pokud jsme se nedostali k nule, skok na zacatek smycky
</pre>

<p>Z&nbsp;předchozího textu již víme, že když se namísto instrukce <strong>sub</strong> použije instrukce <strong>subs</strong>, nastaví se při snížení hodnoty počitadla i příznakové bity, zejména dnes důležitý příznak nulovosti. Smyčku lze tedy přepsat takto:</p>

<pre>
loop:
        strb  r3, [r1]               @ zapis znaku do bufferu
        add   r1, r1, #1             @ uprava ukazatele do bufferu
        subs  r2, r2, #1             @ zmenseni pocitadla a soucasne nastaveni priznaku
        bne   loop                   @ pokud jsme se nedostali k nule, skok na zacatek smycky
</pre>

<p>Nejenom že ušetříme čtyři bajty v&nbsp;objektovém kódu, ale každá iterace bude minimálně o jeden takt rychlejší. Následuje výpis celého zdrojového kódu druhého demonstračního příkladu, který se vlastně příliš neliší od příkladu předchozího (až na odlišnou implementaci testu na ukončení smyčky):</p>

<pre>
# asmsyntax=as
 
# Testovaci program naprogramovany v assembleru GNU as
# - pocitana programova smycka
# - uprava pro mikroprocesory s architekturou ARM
#
# Autor: Pavel Tisnovsky
 
 
 
# Linux kernel system call table
sys_exit   = 1
sys_write  = 4
 
# Dalsi konstanty pouzite v programu - standardni streamy
std_input  = 0
std_output = 1

# pocet opakovani znaku
rep_count  = 40
 
 
 
#-----------------------------------------------------------------------------
.section .data
 
 
 
#-----------------------------------------------------------------------------
.section .bss
        .lcomm buffer, rep_count     @ rezervace bufferu pro vystup
 
 
 
#-----------------------------------------------------------------------------
.section .text
        .global _start               @ tento symbol ma byt dostupny i linkeru
 
_start:
        ldr   r1, =buffer            @ zapis se bude provadet do tohoto bufferu
        mov   r2, $rep_count         @ pocet opakovani znaku
        mov   r3, #'*'               @ zapisovany znak
loop:
        strb  r3, [r1]               @ zapis znaku do bufferu
        add   r1, r1, #1             @ uprava ukazatele do bufferu
        subs  r2, r2, #1             @ zmenseni pocitadla a soucasne nastaveni priznaku
        bne   loop                   @ pokud jsme se nedostali k nule, skok na zacatek smycky
 
        mov   r7, $sys_write         @ cislo syscallu pro funkci "write"
        mov   r0, $std_output        @ standardni vystup
        ldr   r1, =buffer            @ adresa retezce, ktery se ma vytisknout
        mov   r2, $rep_count         @ pocet znaku, ktere se maji vytisknout
        svc   0                      @ volani Linuxoveho kernelu
 
        mov   r7, $sys_exit          @ cislo sycallu pro funkci "exit"
        mov   r0, #0                 @ exit code = 0
        svc   0                      @ volani Linuxoveho kernelu
</pre>

<p>Z&nbsp;disassemblovaného výstupu je patrné, že se skutečně podařilo program zkrátit o čtyři bajty (to samozřejmě není mnoho, ale u větších aplikací se toto zmenšení už pěkně nasčítá):</p>

<pre>
a.out:     file format elf32-littlearm
architecture: armv4, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x00008074

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000040  00008074  00008074  00000074  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000028  000100b8  000100b8  000000b8  2**3
                  ALLOC
  2 .ARM.attributes 00000014  00000000  00000000  000000b4  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
no symbols



Disassembly of section .text:

00008074 &lt;.text&gt;:
    8074:	e59f1034 	ldr	r1, [pc, #52]	; 0x80b0
    8078:	e3a02028 	mov	r2, #40	; 0x28
    807c:	e3a0302a 	mov	r3, #42	; 0x2a
    8080:	e5c13000 	strb	r3, [r1]
    8084:	e2811001 	add	r1, r1, #1
    8088:	e2522001 	subs	r2, r2, #1
    808c:	1afffffb 	bne	0x8080
    8090:	e3a07004 	mov	r7, #4
    8094:	e3a00001 	mov	r0, #1
    8098:	e59f1010 	ldr	r1, [pc, #16]	; 0x80b0
    809c:	e3a02028 	mov	r2, #40	; 0x28
    80a0:	ef000000 	svc	0x00000000
    80a4:	e3a07001 	mov	r7, #1
    80a8:	e3a00000 	mov	r0, #0
    80ac:	ef000000 	svc	0x00000000
    80b0:	000100b8 	strheq	r0, [r1], -r8
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Třetí praktický příklad &ndash; počítaná programová smyčka s&nbsp;testem provedeným na začátku</h2>

<p>Ve třetím demonstračním příkladu je ukázána počítaná programová smyčka, v&nbsp;níž se test na ukončení provádí na jejím začátku ihned po odečtení jedničky od počitadla. Tento příklad je vlastně v&nbsp;mnoha ohledech totožný s&nbsp;příkladem předchozím, ovšem vzhledem k&nbsp;tomu, že změna stavu počitadla (snížení jeho hodnoty o jedničku) a následný test je proveden na začátku smyčky, je nutné při inicializaci počitadla do něj vložit hodnotu 41 a nikoli 40, jinak by se vytisklo pouze 39 hvězdiček následovaných ASCII znakem s&nbsp;kódem nula:</p>

<pre>
        mov   r2, $rep_count+1       @ pocet opakovani znaku
</pre>

<p>Samotná programová smyčka je implementována takto (instrukce <strong>b</strong> na konci představuje nepodmíněný skok na začátek smyčky):</p>

<pre>
loop:
        sub   r2, r2, #1             @ zmenseni pocitadla
        cmp   r2, #0                 @ otestovani, zda jsme jiz nedosahli nuly
        beq   konec                  @ pokud jsme se dostali k nule, konec smycky
        strb  r3, [r1]               @ zapis znaku do bufferu
        add   r1, r1, #1             @ uprava ukazatele do bufferu
        b     loop                   @ nepodmineny skok na zacatek smycky
konec:
</pre>

<p>Podívejme se na úplný zdrojový kód příkladu:</p>

<pre>
# asmsyntax=as
 
# Testovaci program naprogramovany v assembleru GNU as
# - pocitana programova smycka s testem na zacatku
# - uprava pro mikroprocesory s architekturou ARM
#
# Autor: Pavel Tisnovsky
 
 
 
# Linux kernel system call table
sys_exit   = 1
sys_write  = 4
 
# Dalsi konstanty pouzite v programu - standardni streamy
std_input  = 0
std_output = 1

# pocet opakovani znaku
rep_count  = 40
 
 
 
#-----------------------------------------------------------------------------
.section .data
 
 
 
#-----------------------------------------------------------------------------
.section .bss
        .lcomm buffer, rep_count     @ rezervace bufferu pro vystup
 
 
 
#-----------------------------------------------------------------------------
.section .text
        .global _start               @ tento symbol ma byt dostupny i linkeru
 
_start:
        ldr   r1, =buffer            @ zapis se bude provadet do tohoto bufferu
        mov   r2, $rep_count+1       @ pocet opakovani znaku
        mov   r3, #'*'               @ zapisovany znak
loop:
        sub   r2, r2, #1             @ zmenseni pocitadla
        cmp   r2, #0                 @ otestovani, zda jsme jiz nedosahli nuly
        beq   konec                  @ pokud jsme se dostali k nule, konec smycky
        strb  r3, [r1]               @ zapis znaku do bufferu
        add   r1, r1, #1             @ uprava ukazatele do bufferu
        b     loop                   @ nepodmineny skok na zacatek smycky
konec:
 
        mov   r7, $sys_write         @ cislo syscallu pro funkci "write"
        mov   r0, $std_output        @ standardni vystup
        ldr   r1, =buffer            @ adresa retezce, ktery se ma vytisknout
        mov   r2, $rep_count         @ pocet znaku, ktere se maji vytisknout
        svc   0                      @ volani Linuxoveho kernelu
 
        mov   r7, $sys_exit          @ cislo sycallu pro funkci "exit"
        mov   r0, #0                 @ exit code = 0
        svc   0                      @ volani Linuxoveho kernelu
</pre>

<p>Zpětný překlad objektového kódu vypadá následovně:</p>

<pre>
a.out:     file format elf32-littlearm
architecture: armv4, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x00008074

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000048  00008074  00008074  00000074  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000028  000100c0  000100c0  000000c0  2**3
                  ALLOC
  2 .ARM.attributes 00000014  00000000  00000000  000000bc  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
no symbols



Disassembly of section .text:

00008074 &lt;.text&gt;:
    8074:	e59f103c 	ldr	r1, [pc, #60]	; 0x80b8
    8078:	e3a02029 	mov	r2, #41	; 0x29
    807c:	e3a0302a 	mov	r3, #42	; 0x2a
    8080:	e2422001 	sub	r2, r2, #1
    8084:	e3520000 	cmp	r2, #0
    8088:	0a000002 	beq	0x8098
    808c:	e5c13000 	strb	r3, [r1]
    8090:	e2811001 	add	r1, r1, #1
    8094:	eafffff9 	b	0x8080
    8098:	e3a07004 	mov	r7, #4
    809c:	e3a00001 	mov	r0, #1
    80a0:	e59f1010 	ldr	r1, [pc, #16]	; 0x80b8
    80a4:	e3a02028 	mov	r2, #40	; 0x28
    80a8:	ef000000 	svc	0x00000000
    80ac:	e3a07001 	mov	r7, #1
    80b0:	e3a00000 	mov	r0, #0
    80b4:	ef000000 	svc	0x00000000
    80b8:	000100c0 	andeq	r0, r1, r0, asr #1
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Čtvrtý praktický příklad &ndash; optimalizace předchozího příkladu instrukcí <strong>subs</strong></h2>

<p>Čtvrtý příklad vznikl zjednodušením příkladu třetího. Opět se to týká programové smyčky a využití instrukce <strong>subs</strong> namísto instrukce <strong>sub</strong>. Původní verze smyčky vypadala následovně:</p>

<pre>
loop:
        sub   r2, r2, #1             @ zmenseni pocitadla
        cmp   r2, #0                 @ otestovani, zda jsme jiz nedosahli nuly
        beq   konec                  @ pokud jsme se dostali k nule, konec smycky
        strb  r3, [r1]               @ zapis znaku do bufferu
        add   r1, r1, #1             @ uprava ukazatele do bufferu
        b     loop                   @ nepodmineny skok na zacatek smycky
</pre>

<p>Dvojici instrukcí <strong>sub</strong>+<strong>cmp</strong> lze nahradit instrukcí <strong>subs</strong> nastavující příznaky:</p>

<pre>
loop:
        subs  r2, r2, #1             @ zmenseni pocitadla a nastaveni priznaku
        beq   konec                  @ pokud jsme se dostali k nule, konec smycky
        strb  r3, [r1]               @ zapis znaku do bufferu
        add   r1, r1, #1             @ uprava ukazatele do bufferu
        b     loop                   @ nepodmineny skok na zacatek smycky
konec:
</pre>

<p>Opět se podívejme na úplný zdrojový kód příkladu:</p>

<pre>
# asmsyntax=as
 
# Testovaci program naprogramovany v assembleru GNU as
# - pocitana programova smycka s testem na zacatku
# - uprava pro mikroprocesory s architekturou ARM
#
# Autor: Pavel Tisnovsky
 
 
 
# Linux kernel system call table
sys_exit   = 1
sys_write  = 4
 
# Dalsi konstanty pouzite v programu - standardni streamy
std_input  = 0
std_output = 1

# pocet opakovani znaku
rep_count  = 40
 
 
 
#-----------------------------------------------------------------------------
.section .data
 
 
 
#-----------------------------------------------------------------------------
.section .bss
        .lcomm buffer, rep_count     @ rezervace bufferu pro vystup
 
 
 
#-----------------------------------------------------------------------------
.section .text
        .global _start               @ tento symbol ma byt dostupny i linkeru
 
_start:
        ldr   r1, =buffer            @ zapis se bude provadet do tohoto bufferu
        mov   r2, $rep_count+1       @ pocet opakovani znaku
        mov   r3, #'*'               @ zapisovany znak
loop:
        subs  r2, r2, #1             @ zmenseni pocitadla a nastaveni priznaku
        beq   konec                  @ pokud jsme se dostali k nule, konec smycky
        strb  r3, [r1]               @ zapis znaku do bufferu
        add   r1, r1, #1             @ uprava ukazatele do bufferu
        b     loop                   @ nepodmineny skok na zacatek smycky
konec:
 
        mov   r7, $sys_write         @ cislo syscallu pro funkci "write"
        mov   r0, $std_output        @ standardni vystup
        ldr   r1, =buffer            @ adresa retezce, ktery se ma vytisknout
        mov   r2, $rep_count         @ pocet znaku, ktere se maji vytisknout
        svc   0                      @ volani Linuxoveho kernelu
 
        mov   r7, $sys_exit          @ cislo sycallu pro funkci "exit"
        mov   r0, #0                 @ exit code = 0
        svc   0                      @ volani Linuxoveho kernelu
</pre>

<p>Zpětný překlad objektového kódu vypadá následovně:</p>

<pre>
a.out:     file format elf32-littlearm
architecture: armv4, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x00008074

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000044  00008074  00008074  00000074  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000028  000100b8  000100b8  000000b8  2**3
                  ALLOC
  2 .ARM.attributes 00000014  00000000  00000000  000000b8  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
no symbols



Disassembly of section .text:

00008074 &lt;.text&gt;:
    8074:	e59f1038 	ldr	r1, [pc, #56]	; 0x80b4
    8078:	e3a02029 	mov	r2, #41	; 0x29
    807c:	e3a0302a 	mov	r3, #42	; 0x2a
    8080:	e2522001 	subs	r2, r2, #1
    8084:	0a000002 	beq	0x8094
    8088:	e5c13000 	strb	r3, [r1]
    808c:	e2811001 	add	r1, r1, #1
    8090:	eafffffa 	b	0x8080
    8094:	e3a07004 	mov	r7, #4
    8098:	e3a00001 	mov	r0, #1
    809c:	e59f1010 	ldr	r1, [pc, #16]	; 0x80b4
    80a0:	e3a02028 	mov	r2, #40	; 0x28
    80a4:	ef000000 	svc	0x00000000
    80a8:	e3a07001 	mov	r7, #1
    80ac:	e3a00000 	mov	r0, #0
    80b0:	ef000000 	svc	0x00000000
    80b4:	000100b8 	strheq	r0, [r1], -r8
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny čtyři dnes popisované demonstrační příklady byly společně s&nbsp;podpůrnými skripty určenými pro překlad či naopak pro disassembling uloženy do GIT repositáře dostupného na adrese <a href="https://github.com/tisnik/presentations/">https://github.com/tisnik/presentations/</a>. Všechny dnešní příklady jsou určené pro GNU Assembler. Následuje tabulka s&nbsp;odkazy na zdrojové kódy příkladů i na již zmíněné podpůrné skripty:</p>



<h3>První demonstrační příklad</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>loop1-arm-v1.s </td><td>program pro GNU Assembler            </td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/11_gas_loop/loop1-arm-v1.s">https://github.com/tisnik/presentations/blob/master/assembler/11_gas_loop/loop1-arm-v1.s</a></td></tr>
<tr><td>2</td><td>assemble_arm-v1</td><td>skript pro překlad na procesorech ARM</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/11_gas_loop/assemble_arm-v1">https://github.com/tisnik/presentations/blob/master/assembler/11_gas_loop/assemble_arm-v1</a></td></tr>
<tr><td>3</td><td>disassemble-arm</td><td>skript pro disassembling             </td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/11_gas_loop/disassemble-arm">https://github.com/tisnik/presentations/blob/master/assembler/11_gas_loop/disassemble-arm</a></td></tr>
</table>



<h3>Druhý demonstrační příklad</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>loop1-arm-v2.s </td><td>program pro GNU Assembler            </td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/11_gas_loop/loop1-arm-v2.s">https://github.com/tisnik/presentations/blob/master/assembler/11_gas_loop/loop1-arm-v2.s</a></td></tr>
<tr><td>2</td><td>assemble_arm-v2</td><td>skript pro překlad na procesorech ARM</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/11_gas_loop/assemble_arm-v2">https://github.com/tisnik/presentations/blob/master/assembler/11_gas_loop/assemble_arm-v2</a></td></tr>
<tr><td>3</td><td>disassemble-arm</td><td>skript pro disassembling             </td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/11_gas_loop/disassemble-arm">https://github.com/tisnik/presentations/blob/master/assembler/11_gas_loop/disassemble-arm</a></td></tr>
</table>



<h3>Třetí demonstrační příklad</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>loop2-arm-v1.s </td><td>program pro GNU Assembler            </td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/12_gas_loop/loop2-arm-v1.s">https://github.com/tisnik/presentations/blob/master/assembler/12_gas_loop/loop2-arm-v1.s</a></td></tr>
<tr><td>2</td><td>assemble_arm-v1</td><td>skript pro překlad na procesorech ARM</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/12_gas_loop/assemble_arm-v1">https://github.com/tisnik/presentations/blob/master/assembler/12_gas_loop/assemble_arm-v1</a></td></tr>
<tr><td>3</td><td>disassemble-arm</td><td>skript pro disassembling             </td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/12_gas_loop/disassemble-arm">https://github.com/tisnik/presentations/blob/master/assembler/12_gas_loop/disassemble-arm</a></td></tr>
</table>



<h3>Čtvrtý demonstrační příklad</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>loop2-arm-v2.s </td><td>program pro GNU Assembler            </td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/12_gas_loop/loop2-arm-v2.s">https://github.com/tisnik/presentations/blob/master/assembler/12_gas_loop/loop2-arm-v2.s</a></td></tr>
<tr><td>2</td><td>assemble_arm-v2</td><td>skript pro překlad na procesorech ARM</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/12_gas_loop/assemble_arm-v2">https://github.com/tisnik/presentations/blob/master/assembler/12_gas_loop/assemble_arm-v2</a></td></tr>
<tr><td>3</td><td>disassemble-arm</td><td>skript pro disassembling             </td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/12_gas_loop/disassemble-arm">https://github.com/tisnik/presentations/blob/master/assembler/12_gas_loop/disassemble-arm</a></td></tr>
</table>



<p><a name="k13"></a></p>
<h2 id="k13">13. Optimalizace kódu (počtu instrukcí) při výpočtu největšího společného dělitele</h2>

<p>Pojďme si nyní ukázat, jak je možné použít podmínkové kódy v&nbsp;praxi. Následující demonstrační příklad byl získán přímo z&nbsp;materiálů dodávaných k&nbsp;mikroprocesorům <i>ARM</i>, takže je jisté, že byl vybrán s&nbsp;ohledem na to, aby dobře ilustroval použití podmínkových kódů a markantní rozdíl v&nbsp;délce programu i délce jeho trvání (v&nbsp;praxi jsou tyto rozdíly poněkud menší). Příklad představuje céčkovskou funkci určenou pro výpočet největšího společného dělitele dvou 32bitových hodnot. Algoritmus pro výpočet největšího společného dělitele je možné v&nbsp;céčku zapsat následovně:</p>

<pre>
int gcd(int a, int b)
{
    while (a != b) do
    {
        if (a &gt; b)
        {
            a = a - b;
        }
        else
        {
            b = b - a;
        }
    }
    return a;
}
</pre>

<p>Pokud by tento algoritmus byl přeložen do assembleru s&nbsp;využitím klasicky pojatých podmíněných skoků, mohl by výsledek vypadat následovně: instrukce <strong>CMP</strong> porovná dva pracovní registry obsahující obě hodnoty, pro něž se počítá největší společný dělitel. Na základě tohoto porovnání se vykoná buď &bdquo;větev if&ldquo; nebo &bdquo;větev else&ldquo;, což ovšem znamená, že se v&nbsp;každé iteraci musí vykonat dvě instrukce podmíněných skoků (<strong>BEQ, BLT</strong>) a jedna instrukce skoku nepodmíněného (<strong>B</strong>):</p>

<pre>
gcd     CMP      r0, r1      ; porovnání registrů r0 a r1
        BEQ      end         ; pokud r0 == r1, konec smyčky
        BLT      less        ; skok když r0 je menší než r1
        SUB      r0, r0, r1  ; tělo "if"
        B        gcd         ; další iterace
less
        SUB      r1, r1, r0  ; tělo "else"
        B        gcd         ; další iterace
end
</pre>

<p>Naproti tomu optimalizující překladač může výše uvedený program přeložit pouze do čtyř instrukcí, přičemž obě prostřední instrukce jsou vykonány pouze při splnění zadané podmínky (viz suffix uvedený u jména instrukce):</p>

<pre>
gcd
        CMP      r0, r1      ; porovnání registrů r0 a r1
        SUBGT    r0, r0, r1  ; rozdíl jen v případě, že r0 byl větší než r1
        SUBLT    r1, r1, r0  ; rozdíl jen v případě, že r1 byl větší než r0
        BNE      gcd         ; pokud r0 != r1, skok na začátek smyčky
</pre>

<p>Vzhledem k&nbsp;tomu, že všechny instrukce mají konstantní šířku 32 bitů, odpovídá zkrácení programu v&nbsp;assembleru (počet ušetřených řádků) přímo úměrně i zkrácení výsledného strojového programu a současně i jeho rychlejšímu běhu, protože provedení podmíněného skoku vede k&nbsp;pozastavení instrukční pipeline na tři takty:</p>

<table>
<tr><th>Program</th><th>Instrukcí</th><th>Bajtů</th></tr>
<tr><td>A</td><td>7</td><td>28</td></tr>
<tr><td>B</td><td>4</td><td>16</td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Intel x86 JUMP quick reference<br />
<a href="http://unixwiz.net/techtips/x86-jumps.html">http://unixwiz.net/techtips/x86-jumps.html</a>
</li>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Assembler pod Linuxem<br />
<a href="http://phoenix.inf.upol.cz/linux/prog/asm.html">http://phoenix.inf.upol.cz/linux/prog/asm.html</a>
</li>

<li>AT&amp;T Syntax versus Intel Syntax<br />
<a href="https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html">https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html</a>
</li>

<li>Linux Assembly website<br />
<a href="http://asm.sourceforge.net/">http://asm.sourceforge.net/</a>
</li>

<li>Using Assembly Language in Linux<br />
<a href="http://asm.sourceforge.net/articles/linasm.html">http://asm.sourceforge.net/articles/linasm.html</a>
</li>

<li>vasm<br />
<a href="http://sun.hasenbraten.de/vasm/">http://sun.hasenbraten.de/vasm/</a>
</li>

<li>vasm &ndash; dokumentace<br />
<a href="http://sun.hasenbraten.de/vasm/release/vasm.html">http://sun.hasenbraten.de/vasm/release/vasm.html</a>
</li>

<li>The Yasm Modular Assembler Project<br />
<a href="http://yasm.tortall.net/">http://yasm.tortall.net/</a>
</li>

<li>680x0:AsmOne<br />
<a href="http://www.amigacoding.com/index.php/680x0:AsmOne">http://www.amigacoding.com/index.php/680x0:AsmOne</a>
</li>

<li>ASM-One Macro Assembler<br />
<a href="http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler">http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler</a>
</li>

<li>ASM-One pages<br />
<a href="http://www.theflamearrows.info/documents/asmone.html">http://www.theflamearrows.info/documents/asmone.html</a>
</li>

<li>Základní informace o ASM-One<br />
<a href="http://www.theflamearrows.info/documents/asminfo.html">http://www.theflamearrows.info/documents/asminfo.html</a>
</li>

<li>Linux Syscall Reference<br />
<a href="http://syscalls.kernelgrok.com/">http://syscalls.kernelgrok.com/</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>IBM System 360/370 Compiler and Historical Documentation<br />
<a href="http://www.edelweb.fr/Simula/">http://www.edelweb.fr/Simula/</a>
</li>

<li>IBM 700/7000 series<br />
<a href="http://en.wikipedia.org/wiki/IBM_700/7000_series">http://en.wikipedia.org/wiki/IBM_700/7000_series</a>
</li>

<li>IBM System/360<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/360">http://en.wikipedia.org/wiki/IBM_System/360</a>
</li>

<li>IBM System/370<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/370">http://en.wikipedia.org/wiki/IBM_System/370</a>
</li>

<li>Mainframe family tree and chronology<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html</a>
</li>

<li>704 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html</a>
</li>

<li>705 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html</a>
</li>

<li>The IBM 704<br />
<a href="http://www.columbia.edu/acis/history/704.html">http://www.columbia.edu/acis/history/704.html</a>
</li>

<li>IBM Mainframe album<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html</a>
</li>

<li>Osmibitové muzeum<br />
<a href="http://osmi.tarbik.com/">http://osmi.tarbik.com/</a>
</li>

<li>Tesla PMI-80<br />
<a href="http://osmi.tarbik.com/cssr/pmi80.html">http://osmi.tarbik.com/cssr/pmi80.html</a>
</li>

<li>PMI-80<br />
<a href="http://en.wikipedia.org/wiki/PMI-80">http://en.wikipedia.org/wiki/PMI-80</a>
</li>

<li>PMI-80<br />
<a href="http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016">http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016</a>
</li>

<li>The 6502 overflow flag explained mathematically <br />
<a href="http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html">http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

