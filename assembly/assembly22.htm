<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Použití assembleru v Linuxu: assembler a jazyk C</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Použití assembleru v Linuxu: assembler a jazyk C</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Assembler v&nbsp;Linuxu se v&nbsp;současnosti používá převážně v&nbsp;těch situacích, kdy je zapotřebí efektivně provést pouze určité specifické paměťově či výpočetně náročné operace. Zbytek aplikace se přitom vytváří v&nbsp;některém vyšším programovacím jazyku, například v&nbsp;C či C++. Z&nbsp;tohoto důvodu je užitečné vědět, jak je možné assembler (resp.&nbsp;kód psaný v&nbsp;assembleru) kombinovat se zdrojovým kódem psaným v&nbsp;C či C++. Právě této problematice je věnován dnešní článek.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Použití assembleru v&nbsp;Linuxu: assembler a jazyk C</a></p>
<p><a href="#k02">2. Příkazy <strong>asm</strong> a <strong>__asm__</strong></a></p>
<p><a href="#k03">3. Jak se příkazy <strong>asm</strong> a <strong>__asm__</strong> zpracovávají?</a></p>
<p><a href="#k04">4. Blok vytvořený v&nbsp;assembleru bez vstupních a výstupních operandů</a></p>
<p><a href="#k05">5. Specifikace výstupních operandů</a></p>
<p><a href="#k06">6. Přesné určení registrů pro výstupní operandy</a></p>
<p><a href="#k07">7. Specifikace vstupních operandů</a></p>
<p><a href="#k08">8. Explicitní určení registru pro výstupní operand</a></p>
<p><a href="#k09">9. Explicitní určení registrů pro vstupní operandy i výstupní operand</a></p>
<p><a href="#k10">10. Stejný registr použitý pro vstupní i výstupní operand</a></p>
<p><a href="#k11">11. Vliv optimalizací na generovaný kód</a></p>
<p><a href="#k12">12. Použití syntaxe používané firmou Intel</a></p>
<p><a href="#k13">13. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Použití assembleru v&nbsp;Linuxu: assembler a jazyk C</h2>

<p>Pokud je nutné v&nbsp;nějaké nativní aplikaci, tj.&nbsp;v&nbsp;aplikaci překládané do strojového kódu, určitou kritickou část naprogramovat v&nbsp;assembleru, mají vývojáři k&nbsp;dispozici hned několik možností:</p>

<ul>

<li>Ta část, která je psaná v&nbsp;assembleru, může být přeložena ze samostatných zdrojových kódů libovolným assemblerem (GNU Assembler, NASM atd.) a následně staticky slinkována se zbytkem aplikace, což jsme si již v&nbsp;tomto seriálu ukázali. Připomeňme si, že kód v&nbsp;assembleru lze v&nbsp;případě potřeby přímo překládat zavoláním <strong>gcc</strong>, nikoli <strong>as</strong>, což nám mj.&nbsp;umožní implicitně volat linker (pokud je to zapotřebí). V&nbsp;assembleru jsme v&nbsp;tomto případě omezeni na tvorbu subrutin, které se volají z&nbsp;céčkového kódu, tj.&nbsp;nelze například naprogramovat jen vnitřní smyčku v&nbsp;assembleru.</li>

<li>Část psanou v&nbsp;assembleru lze přeložit běžným způsobem (opět s&nbsp;využitím GNU Assembleru, NASMu atd.) a následně objektový kód uložit do dynamické knihovny (<i>so</i>). Tato knihovna se bude k&nbsp;aplikaci linkovat až po spuštění programu. Platí pro nás prakticky stejná omezení, jaká byla zmíněna v&nbsp;předchozím bodu.</li>

<li>V&nbsp;jediném zdrojovém kódu lze kombinovat céčko (či C++) a assembler. Tato možnost přináší některé výhody, například zápis instrukcí v&nbsp;assembleru přímo do funkce (optimalizace vnitřních smyček), ovšem i některé nevýhody, protože zdrojový kód se stane nepřenositelným na další platformy (s&nbsp;využitím podmíněného překladu je však možné pro další platformy připravit alternativní kód). I přesto si tento způsob dnes vysvětlíme; taktéž si ukážeme, jak se do části psané v&nbsp;assembleru předávají parametry.</li>

</ul>

<p>Poznámka: všechny demonstrační příklady byly vyzkoušeny s&nbsp;překladačem <strong>GCC</strong> a nemusí být plně přenositelné na další typy překladačů:</p>

<pre>
<strong>gcc --version</strong>
gcc (GCC) 6.3.1 20161221 (Red Hat 6.3.1-1)
Copyright (C) 2016 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Příkazy <strong>asm</strong> a <strong>__asm__</strong></h2>

<p>V&nbsp;mnoha překladačích programovacího jazyka C popř.&nbsp;jazyka C++ nalezneme příkaz <strong>asm</strong>, za kterým následuje buď programový blok umístěný ve složených závorkách (tento způsob se používal například u kdysi populárních překladačů společnosti Borland) nebo blok umístěný v&nbsp;závorkách kulatých. V&nbsp;případě překladače GNU C se používá druhý způsob. Ovšem vzhledem k&nbsp;tomu, že <strong>asm</strong> není rezervované klíčové slovo specifikované ve standardech C, nebude tento blok správně rozeznán při překladu s&nbsp;volbami <strong>-ansi</strong> a/nebo <strong>-std</strong>. Z&nbsp;tohoto důvodu se doporučuje namísto <strong>asm</strong> používat <strong>__asm__</strong> a pro překlad zdrojového kódu na jiných překladačích navíc do pro jistotu hlavičky či na úvod doplnit:</p>

<pre>
#ifndef __GNUC__
#define __asm__ asm
#endif
</pre>

<p>Bližší informace o této problematice je možné v&nbsp;případě potřeby najít například na stránce <a href="https://gcc.gnu.org/onlinedocs/gcc/Alternate-Keywords.html#Alternate-Keywords">Alternate Keywords</a>.</p>

<p>Poznámka: v&nbsp;demonstračních příkladech navíc používám i deklaraci <strong>__volatile__</strong> zabezpečující, že se blok v&nbsp;assembleru nebude žádným způsobem optimalizovat (a tím pádem ani odstraňovat). To je důležité, protože se vyhnete nemilým překvapením při překladu s&nbsp;volbami -Ox apod.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Jak se příkazy <strong>asm</strong> a <strong>__asm__</strong> zpracovávají?</h2>

<p>Instrukce zapsané v&nbsp;blocích <strong>asm</strong> či <strong>__asm__</strong> se překladačem céčka zpracovávají způsobem, který může vzdáleně připomínat expanzi maker. V&nbsp;podstatě se provádí pouze náhrady čísel parametrů za jména registrů a takto upravený kód se předá do assembleru, a to dokonce včetně znaků pro konce řádků, mezer na začátcích řádků atd. Z&nbsp;tohoto důvodu se již tradičně celý program zapisuje formou řetězce, kde se na každém řádku explicitně uvádí znak pro odřádkování <strong>\n</strong> a znak tabulátoru <strong>\t</strong> ve chvíli, kdy se nezapisuje řádek s&nbsp;návěštím (<i>label</i>); zde by naopak tabulátor překážel. Za tímto řetězcem se zapisuje nepovinný seznam výstupních registrů, seznam vstupních registrů a konečně seznam registrů používaných uvnitř kódu (tuto problematiku si blíže vysvětlíme v&nbsp;dalším textu, takže se následujícího kódu moc nelekněte). Jednotlivé seznamy se od sebe oddělují dvojtečkou. Celý zápis může vypadat následovně:</p>

<pre>
#include &lt;stdio.h&gt;

int main()
{
    __asm__ __volatile__(
        "nop   \n\t"
        " nop   \n\t"
        "  nop   \n\t"
        "    nop   \n\t"
        "    nop  # komentar \n\t"
        : /* zadne vystupni registry */
        : /* zadne vstupni operandy */
        : /* zadne registry pouzivane uvnitr kodu */
    );

    return 0;
}
</pre>

<p>Podívejme se, jakým způsobem se tento blok zpracuje překladačem céčka. Překladač musíme zavolat s&nbsp;volbou <strong>-S</strong>, aby se ze zdrojového kódu vygeneroval mezivýsledek předávaný interně do GNU assembleru <strong>as</strong>. Tento mezivýsledek obsahuje přeložený céčkový kód, případné ladicí informace a taktéž expandované bloky <strong>asm</strong>:</p>

<pre>
gcc -S asm_in_c_0.c
</pre>

<p>Mezivýsledek vypadá zhruba následovně. Povšimněte si zvýrazněných řádků, z&nbsp;nichž je patrné, že se náš &bdquo;program&ldquo; skutečně pouze vložil na správné místo, a to včetně všech mezer a komentářů:</p>

<pre>
        .file   "asm_in_c_0.c"
        .text
        .globl  main
        .type   main, @function
main:
.LFB0:
        .cfi_startproc
        pushq   %rbp
        .cfi_def_cfa_offset 16
        .cfi_offset 6, -16
        movq    %rsp, %rbp
        .cfi_def_cfa_register 6
#APP
# 5 "asm_in_c_0.c" 1
<strong>        nop</strong>
<strong>         nop</strong>
<strong>          nop</strong>
<strong>            nop</strong>
<strong>            nop  # komentar </strong>

# 0 "" 2
#NO_APP
        movl    $0, %eax
        popq    %rbp
        .cfi_def_cfa 7, 8
        ret
        .cfi_endproc
.LFE0:
        .size   main, .-main
        .ident  "GCC: (GNU) 6.3.1 20161221 (Red Hat 6.3.1-1)"
        .section        .note.GNU-stack,"",@progbits
</pre>

<p>Poznámka: pozor na to, že komentáře jsou na jiných platformách zapisovány odlišnými znaky!</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Blok vytvořený v&nbsp;assembleru bez vstupních a výstupních operandů</h2>

<p>V&nbsp;případě, že je v&nbsp;assemblerovském bloku potřeba vykonat nějaké instrukce, a to nezávisle na okolním céčkovém kódu, není nutné specifikovat žádné vstupní registry ani výstupní operandy. Jestliže se navíc v&nbsp;takovém bloku nemění obsah jiných registrů (samozřejmě kromě <strong>PC</strong> neboli čítače instrukcí), je i poslední seznam registrů prázdný. Celý blok lze zapsat dvěma způsoby. Rozsáhlejším s&nbsp;explicitním uvedením prázdných seznamů (k&nbsp;vidění je méně často):</p>

<pre>
#include &lt;stdio.h&gt;

int main()
{
    __asm__ __volatile__(
        "nop   \n\t"
        : /* zadne vystupni registry */
        : /* zadne vstupni operandy */
        : /* zadne registry pouzivane uvnitr kodu */
    );

    return 0;
}
</pre>

<p>Nebo jednodušším a taktéž mnohem kratším způsobem, kde zcela chybí tři seznamy oddělené dvojtečkami. Celý assemblerovský blok je tedy tvořen jediným (obecně víceřádkovým) řetězcem:</p>

<pre>
#include &lt;stdio.h&gt;

int main()
{
    __asm__ __volatile__(
        "nop   \n\t"
    );

    return 0;
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Specifikace výstupních operandů</h2>

<p>Nyní se podívejme na poněkud složitější příklad, v&nbsp;němž bude vytvořen blok v&nbsp;assembleru, jehož úkolem bude zapsat konstantu 42 do globální proměnné nazvané <strong>result</strong>. Postup je jednoduchý:</p>

<ol>
<li>Načteme konstantu 42 do pracovního registru <strong>RBX</strong> (připomeňme si, že se nacházíme na platformě x86-64).</li>
<li>Uložíme obsah registru <strong>RBX</strong> do proměnné <strong>result</strong>.</li>
</ol>

<p>Při zápisu tohoto bloku musíme vyřešit dva problémy. První problém spočívá ve specifikaci proměnné <strong>result</strong>, což lze řešit zápisem "=" (result) v&nbsp;seznamu výstupních operandů. Tento zápis znamená: ulož obsah automaticky vybraného pracovního registru (například <strong>RAX</strong>) do proměnné <strong>result</strong>. Interně je první výstupní operand v&nbsp;assembleru reprezentován znaky %0, případný druhý operand znaky %1 atd. Druhý problém spočívá v&nbsp;tom, že přepisujeme obsah registru <strong>RBX</strong>, což překladač céčka neví. Musíme ho o tom informovat, aby překladač věděl, že nesmí počítat s&nbsp;tím, že bude obsah tohoto registru nezměněn. To se provede jednoduše &ndash; v&nbsp;posledním (třetím) seznamu se uvede jméno tohoto registru popř.&nbsp;většího množství registrů:</p>

<pre>
#include &lt;stdio.h&gt;

unsigned long long result;

int main()
{
    __asm__ __volatile__(
        "mov    $42, %%rbx;   \n\t"
        "mov    %%rbx, %0;    \n\t"
        : "=r" (result)  /* vystupni operand */
        :                /* zadne vstupni operandy */
        : "%rbx"         /* registry pouzivane uvnitr kodu */
    );

    printf("%Ld\n", result);

    return 0;
}
</pre>

<p>Ve skutečnosti se náš assemblerovský blok transformuje do třech strojových instrukcí, protože je nutné uložit obsah automaticky vybraného pracovního registru do proměnné <strong>result</strong>. Konkrétně může vypadat výsledek transformace takto (poslední instrukce ukládá obsah registru <strong>RAX</strong> do globální proměnné):</p>

<pre>
#APP
# 7 "asm_in_c_3.c" 1
        mov    $42, %rbx;   
        mov    %rbx, %rax;    

# 0 "" 2
#NO_APP
        movq    %rax, result(%rip)
</pre>

<p>Poznámka: pokud vám nevyhovuje používání %0 pro výstupní operand, lze provést jeho pojmenování následujícím způsobem:</p>

<pre>
    __asm__ (
            "mov $42, %%rbx  \n\t"
            "mov %%rbx, <strong>%[result_ident]</strong>  \n\t"
            : <strong>[result_ident]</strong> "=r" (result)
            :
            : "%rbx");
    printf("%Ld\n", result);
    return 0;
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Přesné určení registrů pro výstupní operandy</h2>

<p>V&nbsp;předchozím příkladu jsme nechali na céčkovém překladači, ať si sám zvolí registr používaný pro výstupní operand. Samozřejmě je však možné registr zvolit explicitně, a to náhradou znaku "r" v&nbsp;řetězci "=r" za jiný znak podle následující tabulky. Povšimněte si, že (alespoň prozatím) není možné explicitně použít vyšších osm pracovních registrů, tj.&nbsp;registry pojmenované <strong>R8</strong> až <strong>R15</strong>. V&nbsp;samotném assemblerovském kódu však tyto registry lze využít:</p>

<table>
<tr><th>Náhrada "r"</th><th>Význam</th></tr>
<tr><td>a</td><td>%rax, %eax, %ax, %al</td></tr>
<tr><td>b</td><td>%rbx, %ebx, %bx, %bl</td></tr>
<tr><td>c</td><td>%rcx, %ecx, %cx, %cl</td></tr>
<tr><td>d</td><td>%rdx, %edx, %dx, %dl</td></tr>
<tr><td>S</td><td>%rsi, %esi, %si</td></tr>
<tr><td>D</td><td>%rdi, %edi, %di</td></tr>
</table>

<p>Podívejme se nyní na to, co se stane, když pro výstupní operand explicitně zvolíme registr <strong>RCX</strong>:</p>

<pre>
#include &lt;stdio.h&gt;

unsigned long long result;

int main()
{
    __asm__ __volatile__(
        "mov    $42, %%rbx;   \n\t"
        "mov    %%rbx, %0;    \n\t"
        : "=c" (result)  /* vystupni operand */
        :                /* zadne vstupni operandy */
        : "%rbx"         /* registry pouzivane uvnitr kodu */
    );

    printf("%Ld\n", result);

    return 0;
}
</pre>

<p>Tento kód se přeloží následujícím způsobem:</p>

<pre>
#APP
# 7 "test.c" 1
        mov    $42, %rbx;   
        mov    %rbx, %rcx;    
        
# 0 "" 2
#NO_APP
        movq    %rcx, %rax
        movq    %rax, result(%rip)
</pre>

<p>Nenechte se zmást použitím <strong>RAX</strong>, po optimalizaci (-O) tento mezikrok zmizí.</p>

<p>Alternativně můžeme zcela vynechat meziuložení výsledku do registru <strong>RBX</strong> a prohlásit tento registr za registr obsahující výstupní operand:</p>

<pre>
#include &lt;stdio.h&gt;

unsigned long long result;

int main()
{
    __asm__ __volatile__(
        "mov    $42, %%rbx;   \n\t"
        : "=b" (result)  /* vystupni operand */
        :                /* zadne vstupni operandy */
        :                /* registry pouzivane uvnitr kodu */
    );

    printf("%Ld\n", result);

    return 0;
}
</pre>

<p>Překlad bude vypadat takto:</p>

<pre>
#APP
# 7 "test.c" 1
        mov    $42, %rbx;   
        
# 0 "" 2
#NO_APP
        movq    %rbx, %rax
        movq    %rax, result(%rip)
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Specifikace vstupních operandů</h2>

<p>Zkusme si nyní vytvořit složitější příklad, v&nbsp;němž (samozřejmě v&nbsp;assembleru) sečteme obsah dvou celočíselných proměnných a uložíme výsledek do proměnné třetí. Pro jednoduchost se budou vstupní proměnné jmenovat <strong>x</strong> a <strong>y</strong>, proměnná výstupní se bude jmenovat <strong>result</strong>. Blok napsaný v&nbsp;assembleru se vlastně nebude příliš odlišovat od předchozího příkladu, ovšem kromě výstupního operandu musíme specifikovat i operandy vstupní. Používá se podobný způsob zápisu, ovšem bez znaku "=". Vstupní operandy vytváří se vstupními operandy jednu ucelenou řadu, takže v&nbsp;tomto konkrétním příkladu bude mít výstupní operand označení %0, první vstupní operand označení %1 a druhý operand pochopitelně označení %2:</p>

<pre>
#include &lt;stdio.h&gt;

unsigned long long x = 10;
unsigned long long y = 20;
unsigned long long result;

int main()
{
    __asm__ __volatile__(
        "mov    %1, %%rbx;   \n\t"
        "add    %2, %%rbx;   \n\t"
        "mov    %%rbx, %%rcx \n\t"
        : "=c" (result)    /* vystupni operand */
        : "r" (x), "r" (y) /* dva vstupni operandy */
        : "%rbx"           /* registry pouzivane uvnitr kodu */
    );

    printf("%Ld\n", result);

    return 0;
}
</pre>

<p>Výsledek transformace provedené překladačem céčka vypadá takto:</p>

<pre>
        movq    x(%rip), %rax
        movq    y(%rip), %rdx
#APP
# 9 "test.c" 1
        mov    %rax, %rbx;   
        add    %rdx, %rbx;   
        mov    %rbx, %rcx 
        
# 0 "" 2
#NO_APP
        movq    %rcx, %rax
        movq    %rax, result(%rip)
</pre>

<p>Na začátku vidíme automaticky vygenerované instrukce pro umístění vstupních operandů do vybraných registrů (vybral si je sám překladač), dále pak vlastní výpočet a konečně uložení výsledku do proměnné <strong>result</strong>.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Explicitní určení registru pro výstupní operand</h2>

<p>Opět můžeme trošku experimentovat a explicitně určit, že výstupní operand je uložen v&nbsp;registru <strong>RAX</strong>. Tím si ušetříme jednu instrukci <strong>MOV</strong>:</p>

<pre>
#include &lt;stdio.h&gt;

unsigned long long x = 10;
unsigned long long y = 20;
unsigned long long result;

int main()
{
    __asm__ __volatile__(
        "mov    %1, %%rax;   \n\t"
        "add    %2, %%rax;   \n\t"
        : "=a" (result)    /* vystupni operand */
        : "r" (x), "r" (y) /* dva vstupni operandy */
        :                  /* registry pouzivane uvnitr kodu */
    );

    printf("%Ld\n", result);

    return 0;
}
</pre>

<p>Výsledek transformace provedené překladačem céčka (bez zapnutých optimalizací) vypadá následovně:</p>

<pre>
        movq    x(%rip), %rax
        movq    y(%rip), %rdx
#APP
# 9 "test.c" 1
        mov    %rax, %rbx;   
        add    %rdx, %rbx;   
        mov    %rbx, %rcx 
        
# 0 "" 2
#NO_APP
        movq    %rax, result(%rip)
        movq    result(%rip), %rax
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Explicitní určení registrů pro vstupní operandy i výstupní operand</h2>

<p>Pokračujme v&nbsp;našich úpravách dále. Nyní budeme požadovat, aby výstupní operand (součet) byl umístěn v&nbsp;registru <strong>RAX</strong>, první vstupní operand v&nbsp;registru <strong>RBX</strong> a druhý vstupní operand v&nbsp;registru <strong>RCX</strong>. Zápis bude vypadat následovně (připomeňme si tabulku <a href="#k06">ze šesté kapitoly</a>):</p>

<pre>
#include &lt;stdio.h&gt;

unsigned long long x = 10;
unsigned long long y = 20;
unsigned long long result;

int main()
{
    __asm__ __volatile__(
        "mov    %%rbx, %%rax;   \n\t"
        "add    %%rcx, %%rax;   \n\t"
        : "=a" (result)    /* vystupni operand */
        : "b" (x), "c" (y) /* dva vstupni operandy v registrech rbx a rcx */
        :                  /* registry pouzivane uvnitr kodu */
    );

    printf("%Ld\n", result);

    return 0;
}
</pre>

<p>Výsledek transformace provedené překladačem céčka (bez zapnutých optimalizací) vypadá následovně:</p>

<pre>
        movq    x(%rip), %rax
        movq    y(%rip), %rdx
        movq    %rax, %rbx
        movq    %rdx, %rcx
#APP
# 9 "test.c" 1
        mov    %rbx, %rbx;   
        add    %rcx, %rbx;   
        mov    %rbx, %rcx 
        
# 0 "" 2
#NO_APP
        movq    %rax, result(%rip)
        movq    result(%rip), %rax
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Stejný registr použitý pro vstupní i výstupní operand</h2>

<p>Samozřejmě je možné &ndash; a často se s&nbsp;tím setkáme &ndash; použít jediný registr jak pro vstupní, tak i pro výstupní operand. Celý blok psaný v&nbsp;assembleru se nám v&nbsp;takovém případě zjednoduší na jedinou instrukci a navíc nebudeme muset specifikovat žádný pracovní registr:</p>

<pre>
#include &lt;stdio.h&gt;

unsigned long long x = 10;
unsigned long long y = 20;
unsigned long long result;

int main()
{
    __asm__ __volatile__(
        "add    %%rbx, %%rax;   \n\t"
        : "=a" (result)    /* vystupni operand */
        : "a" (x), "b" (y) /* dva vstupni operandy v registrech rbx a rcx */
        :                  /* registry pouzivane uvnitr kodu */
    );

    printf("%Ld\n", result);

    return 0;
}
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Vliv optimalizací na generovaný kód</h2>

<p>Velký vliv na výslednou podobu kódu mají optimalizace prováděné céčkovým překladačem. Ten sice nezasahuje do našeho kódu psaného v&nbsp;assembleru (což je samozřejmě dobře), ovšem přípravu operandů a uložení výsledků již může být optimalizováno. Předchozí příklad přeložený bez optimalizací vypadá takto:</p>

<pre>
        movq    x(%rip), %rax
        movq    y(%rip), %rdx
        movq    %rdx, %rbx
#APP
# 9 "asm_in_c_9.c" 1
        add    %rbx, %rax;   

# 0 "" 2
#NO_APP
        movq    %rax, result(%rip)
        movq    result(%rip), %rax
</pre>

<p>Výsledek překladu s&nbsp;volbou -O:</p>

<pre>
        movq    x(%rip), %rax
        movq    y(%rip), %rbx
#APP
# 9 "asm_in_c_9.c" 1
        add    %rbx, %rax;   

# 0 "" 2
#NO_APP
        movq    %rax, result(%rip)
</pre>

<p>Tento kód je již přímočarý a přesně odpovídá tomu, co jsme požadovali: vstupní operandy ulož do registrů <strong>RAX</strong> a <strong>RBX</strong>, proveď součet těchto registrů a následně ulož <strong>RAX</strong> do proměnné <strong>result</strong>.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Použití syntaxe používané firmou Intel</h2>

<p>Poslední zajímavostí, o které se dnes zmíníme, je použití syntaxe firmy Intel. Tato syntaxe je podle mého názoru čitelnější, protože zmizí nepěkná procenta atd., navíc se prohodí operandy všech instrukcí. Tuto syntaxi můžeme použít:</p>

<pre>
#include &lt;stdio.h&gt;

unsigned long long x = 10;
unsigned long long y = 20;
unsigned long long result;

int main()
{
    __asm__ __volatile__(
        "add    rax, rbx;   \n\t"
        : "=a" (result)    /* vystupni operand */
        : "a" (x), "b" (y) /* dva vstupni operandy v registrech rbx a rcx */
        :                  /* registry pouzivane uvnitr kodu */
    );

    printf("%Ld\n", result);

    return 0;
}
</pre>

<p>Nesmíme však zapomenout při překladu použít volbu <strong>-masm=intel</strong>. Podoba výsledného transformovaného kódu se v&nbsp;tomto případě radikálně pozmění:</p>

<pre>
        mov     rax, QWORD PTR x[rip]
        mov     rdx, QWORD PTR y[rip]
        mov     rbx, rdx
#APP
# 9 "test.c" 1
        add    rax, rbx;   
        
# 0 "" 2
#NO_APP
        mov     QWORD PTR result[rip], rax
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny demonstrační příklady byly, podobně jako v&nbsp;předchozích částech tohoto seriálu, společně s&nbsp;podpůrným skriptem připraveným pro jejich překlad, uloženy do GIT repositáře dostupného na adrese <a href="https://github.com/tisnik/presentations/">https://github.com/tisnik/presentations/</a>. Všechny zmíněné příklady jsou určeny pro překladač GNU C:</p>

<table>
<tr><th> #</th><th>Soubor</th><th>Odkaz do repositáře</th></tr>
<tr><td> 1</td><td>asm_in_c_0.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c/asm_in_c_0.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c/asm_in_c_0.c</a></td></tr>
<tr><td> 2</td><td>asm_in_c_1.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c/asm_in_c_1.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c/asm_in_c_1.c</a></td></tr>
<tr><td> 3</td><td>asm_in_c_2.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c/asm_in_c_2.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c/asm_in_c_2.c</a></td></tr>
<tr><td> 4</td><td>asm_in_c_3.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c/asm_in_c_3.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c/asm_in_c_3.c</a></td></tr>
<tr><td> 5</td><td>asm_in_c_4.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c/asm_in_c_4.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c/asm_in_c_4.c</a></td></tr>
<tr><td> 6</td><td>asm_in_c_5.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c/asm_in_c_5.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c/asm_in_c_5.c</a></td></tr>
<tr><td> 7</td><td>asm_in_c_6.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c/asm_in_c_6.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c/asm_in_c_6.c</a></td></tr>
<tr><td> 8</td><td>asm_in_c_7.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c/asm_in_c_7.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c/asm_in_c_7.c</a></td></tr>
<tr><td> 9</td><td>asm_in_c_8.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c/asm_in_c_8.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c/asm_in_c_8.c</a></td></tr>
<tr><td>10</td><td>asm_in_c_9.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c/asm_in_c_9.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c/asm_in_c_9.c</a></td></tr>
<tr><td>11</td><td>asm_in_c_10.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c/asm_in_c_10.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c/asm_in_c_10.c</a></td></tr>
<tr><td>12</td><td>Makefile</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c/Makefile">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c/Makefile</a></td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>How to Use Inline Assembly Language in C Code<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C">https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C</a>
</li>

<li>GCC-Inline-Assembly-HOWTO<br />
<a href="http://ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">http://ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html</a>
</li>

<li>A Brief Tutorial on GCC inline asm (x86 biased)<br />
<a href="http://www.osdever.net/tutorials/view/a-brief-tutorial-on-gcc-inline-asm">http://www.osdever.net/tutorials/view/a-brief-tutorial-on-gcc-inline-asm</a>
</li>

<li>GCC Inline ASM<br />
<a href="http://locklessinc.com/articles/gcc_asm/">http://locklessinc.com/articles/gcc_asm/</a>
</li>

<li>Cortex-A35<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php</a>
</li>

<li>Cortex-A53<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php</a>
</li>

<li>Cortex-A57<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php</a>
</li>

<li>Cortex-A72<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php</a>
</li>

<li>Cortex-A73<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php</a>
</li>

<li>System cally pro AArch64 na Linuxu<br />
<a href="https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h">https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</a>
</li>

<li>Architectures/AArch64 (FedoraProject.org)<br />
<a href="https://fedoraproject.org/wiki/Architectures/AArch64">https://fedoraproject.org/wiki/Architectures/AArch64</a>
</li>

<li>SIG pro AArch64 (CentOS)<br />
<a href="https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64">https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64</a>
</li>

<li>The ARMv8 instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>A64 Instruction Set<br />
<a href="https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set">https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set</a>
</li>

<li>Switching between the instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>The A64 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>Introduction to ARMv8 64-bit Architecture<br />
<a href="https://quequero.org/2014/04/introduction-to-arm-architecture/">https://quequero.org/2014/04/introduction-to-arm-architecture/</a>
</li>

<li>MCU market turns to 32-bits and ARM<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1280803">http://www.eetimes.com/document.asp?doc_id=1280803</a>
</li>

<li>Cortex-M0 Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0.php">http://www.arm.com/products/processors/cortex-m/cortex-m0.php</a>
</li>

<li>Cortex-M0+ Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php">http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php</a>
</li>

<li>ARM Processors in a Mixed Signal World<br />
<a href="http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world">http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_architecture">https://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>ARM Documentation: B, BL, BX, BLX, and BXJ<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0204j/Cihfddaf.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0204j/Cihfddaf.html</a>
</li>

<li>Branch and Call Sequences Explained<br />
<a href="https://community.arm.com/groups/processors/blog/2013/09/25/branch-and-call-sequences-explained">https://community.arm.com/groups/processors/blog/2013/09/25/branch-and-call-sequences-explained</a>
</li>

<li>Improving ARM Code Density and Performance<br />
<a href="New Thumb Extensions to the ARM Architecture Richard Phelan">New Thumb Extensions to the ARM Architecture Richard Phelan</a>
</li>

<li>Aarch64 Register and Instruction Quick Start<br />
<a href="https://wiki.cdot.senecacollege.ca/wiki/Aarch64_Register_and_Instruction_Quick_Start">https://wiki.cdot.senecacollege.ca/wiki/Aarch64_Register_and_Instruction_Quick_Start</a>
</li>

<li>Exploring AArch64 assembler – Chapter 1<br />
<a href="http://thinkingeek.com/2016/10/08/exploring-aarch64-assembler-chapter1/">http://thinkingeek.com/2016/10/08/exploring-aarch64-assembler-chapter1/</a>
</li>

<li>Exploring AArch64 assembler – Chapter 2<br />
<a href="http://thinkingeek.com/2016/10/08/exploring-aarch64-assembler-chapter-2/">http://thinkingeek.com/2016/10/08/exploring-aarch64-assembler-chapter-2/</a>
</li>

<li>The ARM Processor Architecture<br />
<a href="http://www.arm.com/products/processors/technologies/instruction-set-architectures.php">http://www.arm.com/products/processors/technologies/instruction-set-architectures.php</a>
</li>

<li>Thumb-2 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html</a>
</li>

<li>Introduction to ARM thumb<br />
<a href="http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb">http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb</a>
</li>

<li>ARM, Thumb, and ThumbEE instruction sets<br />
<a href="http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm">http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm</a>
</li>

<li>An Introduction to ARM Assembly Language<br />
<a href="http://dev.emcelettronica.com/introduction-to-arm-assembly-language">http://dev.emcelettronica.com/introduction-to-arm-assembly-language</a>
</li>

<li>Processors - ARM<br />
<a href="http://www.arm.com/products/processors/index.php">http://www.arm.com/products/processors/index.php</a>
</li>

<li>The ARM Instruction Set<br />
<a href="http://simplemachines.it/doc/arm_inst.pdf">http://simplemachines.it/doc/arm_inst.pdf</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ARM_architecture">http://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>C Functions Without Arguments<br />
<a href="https://eklitzke.org/c-functions-without-arguments">https://eklitzke.org/c-functions-without-arguments</a>
</li>

<li>GNU Assembler Examples<br />
<a href="http://cs.lmu.edu/~ray/notes/gasexamples/">http://cs.lmu.edu/~ray/notes/gasexamples/</a>
</li>

<li>Simply FPU<br />
<a href="http://www.website.masmforum.com/tutorials/fptute/">http://www.website.masmforum.com/tutorials/fptute/</a>
</li>

<li>Art of Assembly language programming: The 80x87 Floating Point Coprocessors<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html</a>
</li>

<li>Art of Assembly language programming: The FPU Instruction Set<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html</a>
</li>

<li>INTEL 80387 PROGRAMMER'S REFERENCE MANUAL<br />
<a href="http://www.ragestorm.net/downloads/387intel.txt">http://www.ragestorm.net/downloads/387intel.txt</a>
</li>

<li>x86 Instruction Set Reference: FLD<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_100.html">http://x86.renejeschke.de/html/file_module_x86_id_100.html</a>
</li>

<li>x86 Instruction Set Reference: FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_101.html">http://x86.renejeschke.de/html/file_module_x86_id_101.html</a>
</li>

<li>x86 Instruction Set Reference: FLD<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_100.html">http://x86.renejeschke.de/html/file_module_x86_id_100.html</a>
</li>

<li>x86 Instruction Set Reference: FST/FSTP<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_117.html">http://x86.renejeschke.de/html/file_module_x86_id_117.html</a>
</li>

<li>x86 Instruction Set Reference: BTC<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_23.html">http://x86.renejeschke.de/html/file_module_x86_id_23.html</a>
</li>

<li>x86 Instruction Set Reference: BTR<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_24.html">http://x86.renejeschke.de/html/file_module_x86_id_24.html</a>
</li>

<li>x86 Instruction Set Reference: BTS<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_25.html">http://x86.renejeschke.de/html/file_module_x86_id_25.html</a>
</li>

<li>x86 Instruction Set Reference: BSF<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_19.html">http://x86.renejeschke.de/html/file_module_x86_id_19.html</a>
</li>

<li>x86 Instruction Set Reference: BSR<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_20.html">http://x86.renejeschke.de/html/file_module_x86_id_20.html</a>
</li>

<li>x86 Instruction Set Reference: BSWAP<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_21.html">http://x86.renejeschke.de/html/file_module_x86_id_21.html</a>
</li>

<li>x86 Instruction Set Reference: XCHG<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_328.html">http://x86.renejeschke.de/html/file_module_x86_id_328.html</a>
</li>

<li>x86 Instruction Set Reference: SETcc<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_288.html">http://x86.renejeschke.de/html/file_module_x86_id_288.html</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>The GNU Assembler Tutorial<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html">http://tigcc.ticalc.org/doc/gnuasm.html</a>
</li>

<li>The GNU Assembler - macros<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html#SEC109">http://tigcc.ticalc.org/doc/gnuasm.html#SEC109</a>
</li>

<li>ARM subroutines &amp; program stack<br />
<a href="http://www.toves.org/books/armsub/">http://www.toves.org/books/armsub/</a>
</li>

<li>Generating Mixed Source and Assembly List using GCC<br />
<a href="http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/">http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/</a>
</li>

<li>Calling subroutines<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm</a>
</li>

<li>ARM Assembly Language Programming<br />
<a href="http://peter-cockerell.net/aalp/html/frames.html">http://peter-cockerell.net/aalp/html/frames.html</a>
</li>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Intel x86 JUMP quick reference<br />
<a href="http://unixwiz.net/techtips/x86-jumps.html">http://unixwiz.net/techtips/x86-jumps.html</a>
</li>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Assembler pod Linuxem<br />
<a href="http://phoenix.inf.upol.cz/linux/prog/asm.html">http://phoenix.inf.upol.cz/linux/prog/asm.html</a>
</li>

<li>AT&amp;T Syntax versus Intel Syntax<br />
<a href="https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html">https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html</a>
</li>

<li>Linux Assembly website<br />
<a href="http://asm.sourceforge.net/">http://asm.sourceforge.net/</a>
</li>

<li>Using Assembly Language in Linux<br />
<a href="http://asm.sourceforge.net/articles/linasm.html">http://asm.sourceforge.net/articles/linasm.html</a>
</li>

<li>vasm<br />
<a href="http://sun.hasenbraten.de/vasm/">http://sun.hasenbraten.de/vasm/</a>
</li>

<li>vasm &ndash; dokumentace<br />
<a href="http://sun.hasenbraten.de/vasm/release/vasm.html">http://sun.hasenbraten.de/vasm/release/vasm.html</a>
</li>

<li>The Yasm Modular Assembler Project<br />
<a href="http://yasm.tortall.net/">http://yasm.tortall.net/</a>
</li>

<li>680x0:AsmOne<br />
<a href="http://www.amigacoding.com/index.php/680x0:AsmOne">http://www.amigacoding.com/index.php/680x0:AsmOne</a>
</li>

<li>ASM-One Macro Assembler<br />
<a href="http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler">http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler</a>
</li>

<li>ASM-One pages<br />
<a href="http://www.theflamearrows.info/documents/asmone.html">http://www.theflamearrows.info/documents/asmone.html</a>
</li>

<li>Základní informace o ASM-One<br />
<a href="http://www.theflamearrows.info/documents/asminfo.html">http://www.theflamearrows.info/documents/asminfo.html</a>
</li>

<li>Linux Syscall Reference<br />
<a href="http://syscalls.kernelgrok.com/">http://syscalls.kernelgrok.com/</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>IBM System 360/370 Compiler and Historical Documentation<br />
<a href="http://www.edelweb.fr/Simula/">http://www.edelweb.fr/Simula/</a>
</li>

<li>IBM 700/7000 series<br />
<a href="http://en.wikipedia.org/wiki/IBM_700/7000_series">http://en.wikipedia.org/wiki/IBM_700/7000_series</a>
</li>

<li>IBM System/360<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/360">http://en.wikipedia.org/wiki/IBM_System/360</a>
</li>

<li>IBM System/370<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/370">http://en.wikipedia.org/wiki/IBM_System/370</a>
</li>

<li>Mainframe family tree and chronology<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html</a>
</li>

<li>704 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html</a>
</li>

<li>705 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html</a>
</li>

<li>The IBM 704<br />
<a href="http://www.columbia.edu/acis/history/704.html">http://www.columbia.edu/acis/history/704.html</a>
</li>

<li>IBM Mainframe album<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html</a>
</li>

<li>Osmibitové muzeum<br />
<a href="http://osmi.tarbik.com/">http://osmi.tarbik.com/</a>
</li>

<li>Tesla PMI-80<br />
<a href="http://osmi.tarbik.com/cssr/pmi80.html">http://osmi.tarbik.com/cssr/pmi80.html</a>
</li>

<li>PMI-80<br />
<a href="http://en.wikipedia.org/wiki/PMI-80">http://en.wikipedia.org/wiki/PMI-80</a>
</li>

<li>PMI-80<br />
<a href="http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016">http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016</a>
</li>

<li>The 6502 overflow flag explained mathematically <br />
<a href="http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html">http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html</a>
</li>

<li>X86 Opcode and Instruction Reference<br />
<a href="http://ref.x86asm.net/coder32.html">http://ref.x86asm.net/coder32.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

