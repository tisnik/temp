<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Použití assembleru v Linuxu: aritmetické a logické instrukce i bitové posuny v praxi</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Použití assembleru v Linuxu: aritmetické a logické instrukce i bitové posuny v praxi</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve dvanácté části seriálu o použití assembleru v&nbsp;Linuxu použijeme znalosti a aritmetických a logických instrukcích i o bitových posunech, které jsme získali v&nbsp;předchozích článcích. Vytvoříme si totiž několik maker a k&nbsp;nim přidružených subrutin určených pro výpis hexadecimálních i desítkových hodnot na standardní výstup. Uvidíme, že i tyto na první pohled jednoduché funkce vyžadují poměrně podrobnou znalost assembleru, způsobu adresování buněk operační paměti apod.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Použití assembleru v&nbsp;Linuxu: aritmetické a logické instrukce i bitové posuny v&nbsp;praxi</a></p>
<p><a href="#k02">2. Makro pro vytištění hexadecimální hodnoty na standardní výstup</a></p>
<p><a href="#k03">3. Subrutina pro převod celého 32bitového čísla na osmici hexadecimálních cifer</a></p>
<p><a href="#k04">4. První demonstrační příklad: použití bitové rotace, maskování a součtu</a></p>
<p><a href="#k05">5. Výsledky vygenerované prvním demonstračním příkladem</a></p>
<p><a href="#k06">6. Disassemblovaný strojový kód subrutiny <strong>hex2string</strong></a></p>
<p><a href="#k07">7. Druhý demonstrační příklad: optimalizace spočívající v&nbsp;eliminaci nepodmíněného skoku</a></p>
<p><a href="#k08">8. Výsledky vygenerované druhým demonstračním příkladem</a></p>
<p><a href="#k09">9. Disassemblovaný strojový kód upravené subrutiny <strong>hex2string</strong></a></p>
<p><a href="#k10">10. Vytištění desítkové hodnoty na standardní výstup</a></p>
<p><a href="#k11">11. Třetí demonstrační příklad: použití instrukce <strong>DIV</strong> a adresování typu registr+registr+offset</a></p>
<p><a href="#k12">12. Výsledky vygenerované třetím demonstračním příkladem</a></p>
<p><a href="#k13">13. Disassemblovaný strojový kód subrutiny <strong>decimal2string</strong></a></p>
<p><a href="#k14">14. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k15">15. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Použití assembleru v&nbsp;Linuxu: aritmetické a logické instrukce i bitové posuny v&nbsp;praxi</h2>

<p>V&nbsp;úvodních jedenácti částech seriálu o využití assembleru v&nbsp;Linuxu (na různých platformách) jsme si popsali většinu nejdůležitějších strojových instrukcí, které můžeme nalézt jak na mikroprocesorových architekturách i386 a x86-64, tak i na 32bitových mikroprocesorech ARM. Jedná se o instrukce pro relativní či absolutní podmíněné a nepodmíněné skoky, skoky do podprogramů (subrutin) a návrat z&nbsp;podprogramů, aritmetické instrukce, logické instrukce, instrukce pro provedení bitových posunů a rotací, instrukce pro aritmetické posuny a samozřejmě též o instrukce určené pro přenos dat mezi pracovními registry mikroprocesoru popř.&nbsp;pro přenos dat mezi vybraným pracovním registrem a operační pamětí. Taktéž jsme si popsali význam čtyř stavových bitů nazvaných <i>Carry flag</i>, <i>Overflow flag</i>, <i>Sign/Negative flag</i> a <i>Zero flag</i> a jejich použití při operacích s&nbsp;celými čísly bez znaménka i se znaménkem.</p>

<p>Ovšem samotná znalost těchto instrukcí popř.&nbsp;znalost, jak jednotlivé operace ovlivní příznakové bity, je sama o sobě nedůležitá, pokud nejsme schopni tyto instrukce použít v&nbsp;reálných programech popř.&nbsp;v&nbsp;jednotlivých podprogramech (subrutinách). Z&nbsp;tohoto důvodu si dnes ukážeme trojici demonstračních příkladů, v&nbsp;nichž budou implementována makra nazvaná <strong>hex2string</strong> a <strong>decimal2string</strong>. Tato makra slouží, jak jejich název napovídá, k&nbsp;převodu celého čísla na řetězec obsahující buď hexadecimální reprezentaci tohoto čísla nebo reprezentaci v&nbsp;desítkové soustavě. Při implementaci těchto maker si procvičíme použití aritmetických instrukcí (součet, celočíselné dělení), bitových rotací, maskování pomocí instrukce <strong>AND</strong>, adresování buněk v&nbsp;operační paměti, a samozřejmě též použití nepodmíněných a podmíněných skoků (konkrétně <strong>JGE</strong>, <strong>JNE</strong> a <strong>JNZ</strong>).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Makro pro vytištění hexadecimální hodnoty na standardní výstup</h2>

<p>Prvním makrem, kterým se dnes budeme zabývat, je makro určené pro vytištění hexadecimální hodnoty na standardní výstup. Makro by mělo akceptovat jediný parametr &ndash; celočíselnou hodnotu, která má být pro převedení do hexadecimální podoby vytištěna. Při implementaci samozřejmě můžeme použít již existující makro určené pro tisk zprávy nazvané <strong>writeMessage</strong>. Připomeňme si, že makro <strong>writeMessage</strong> očekává počáteční adresu řetězce a počet znaků v&nbsp;řetězci:</p>

<pre>
# Deklarace makra pro vytisteni zpravy na standardni vystup
.macro writeMessage message,messageLength
        mov   ecx, offset \message   # adresa retezce, ktery se ma vytisknout
        mov   edx, \messageLength    # pocet znaku, ktere se maji vytisknout
        call  write_message          # vytisknout zpravu "Zero flag not set"
.endm
</pre>

<p>Před vytvořením makra určeného pro tisk hexadecimální hodnoty si v&nbsp;datovém segmentu připravíme &bdquo;šablonu&ldquo; použitou jako základ pro zprávu, která se zobrazí na standardním výstupu. Povšimněte si, že řetězec, který šablonu tvoří, je rozdělen na dvě části, protože potřebujeme znát adresu otazníků, které budou následně přepsány hexadecimální hodnotou (namísto otazníků je samozřejmě možné použít libovolný jiný znak). Celá šablona tedy vypadá takto: "Hex value: 0x????????\n", přičemž návěští (<i>label</i>) <strong>hexValueTemplate</strong> obsahuje adresu prvního otazníku:</p>

<pre>
.section .data
hexValueMessage:
        .string "Hex value: 0x"             # prvni cast zpravy
hexValueTemplate:                           # druha cast zpravy ma vlastni navesti
        .string "????????\n"                # otazniky budou prepsany
hexValueMessageLen = $ - hexValueMessage    # delka zpravy
</pre>

<p>Samotné makro <strong>printHexNumber</strong> je vlastně velmi jednoduché, protože na jeho začátku pouze naplníme 32bitový pracovní registr <strong>EDX</strong> hodnotou, která se má vytisknout, do dalšího pracovního registru <strong>EBX</strong> vložíme adresu prvního otazníku v&nbsp;šabloně, posléze zavoláme subrutinu <strong>hex2string</strong> popsanou dále a konečně zavoláme makro <strong>writeMessage</strong>, které upravenou zprávu vytiskne na standardní výstup:</p>

<pre>
# Makro pro vypis 32bitove hexadecimalni hodnoty na standardni vystup
# Jedinym parametrem makra je hodnota (konstanta)
.macro printHexNumber value
        mov  edx, \value                   # hodnotu pro tisk ulozit do registru EDX
        mov  ebx, offset hexValueTemplate  # adresu pro retezec ulozit do registru EBX
        call hex2string                    # zavolani prislusne subrutiny pro prevod na string
        writeMessage hexValueMessage, hexValueMessageLen # retezec je naplnen, tak ho muzeme vytisknout
.endm
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Subrutina pro převod celého 32bitového čísla na osmici hexadecimálních cifer</h2>

<p>Makro, které má vytisknout hexadecimální hodnotu 32bitového celého čísla na standardní výstup, již máme vytvořené, takže nám &bdquo;pouze&ldquo; zbývá implementace subrutiny <strong>hex2string</strong>. Tato subrutina očekává v&nbsp;registru <strong>EDX</strong> 32bitovou hodnotu a v&nbsp;registru <strong>EBX</strong> adresu prvního otazníku v&nbsp;šabloně zprávy. Pro převod 32bitové hodnoty na osmici hexadecimálních cifer můžeme použít následující algoritmus (existují však i další možnosti):</p>

<ol>

<li>Do osmibitového registru <strong>CL</strong>, který bude fungovat jako počitadlo, uložíme konstantu 8, protože 32bitová hodnota je převedena na osmici hexadecimálních cifer.</li>

<li>Hodnota v&nbsp;registru <strong>EDX</strong> se zrotuje doleva o čtyři bity. Touto operací se původní nejvyšší čtyři bity přesunou do spodních čtyř bitů (musíme tedy skutečně použít rotaci a nikoli aritmetický posun).</li>

<li>Spodních osm bitů registru <strong>EDX</strong> se přesune do osmibitového registru <strong>AL</strong>. Ten tedy bude obsahovat čtyři bity s&nbsp;nezajímavým obsahem a spodní čtyři bity s&nbsp;cifrou.</li>

<li>Horní čtyři bity registru <strong>AL</strong> maskujeme operací <strong>AND AL, 0x0f</strong>, takže registr <strong>AL</strong> bude obsahovat číslo od 0 do 15.</li>

<li>Pokud je v&nbsp;registru <strong>AL</strong> uložena hodnota menší než 10, přičteme k&nbsp;této hodnotě '0', tedy ASCII kód znaku nula. Touto operací tedy jednoduše provedeme převod na ASCII znak.</li>

<li>Pokud je naopak hodnota v&nbsp;registru <strong>AL</strong> větší nebo rovna deseti, provedeme přičtení konstanty takovým způsobem, aby byl výsledkem znak 'A' až 'F'.</li>

<li>Přepíšeme první otazník hodnotou uloženou v&nbsp;registru <strong>AL</strong> (jedná se o nejvyšší cifru výsledku).</li>

<li>Zvýšíme adresu v&nbsp;registru <strong>EBX</strong>, aby se v&nbsp;dalším kroku přepsal druhý otazník atd.</li>

<li>Snížíme počitadlo v&nbsp;registru <strong>CL</strong> o jedničku a pokud je nenulové, bude se celá smyčka opakovat.</li>

</ol>

<p>Konkrétní implementace algoritmu popsaného výše může vypadat následovně. Povšimněte si použití podmíněného skoku <strong>JGE</strong> při rozlišení cifry 0..9 od cifry A..F a taktéž nám již známého typického ukončení počítané programové smyčky dvojicí instrukcí <strong>DEC+JNZ</strong>:</p>

<pre>
# Subrutina urcena pro prevod 32bitove hexadecimalni hodnoty na retezec
# Vstup: EDX - hodnota, ktera se ma prevest na retezec
#        EBX - adresa jiz drive alokovaneho retezce (resp. osmice bajtu)
hex2string:
                  mov cl,  8                # pocet opakovani smycky

print_one_digit:  rol edx, 4                # rotace doleva znamena, ze se do spodnich 4 bitu nasune dalsi cifra
                  mov al, dl                # nechceme porusit obsah vstupni hodnoty v EDX, proto pouzijeme AL
                  and al, 0x0f              # maskovani, potrebujeme pracovat jen s jednou cifrou
                  cmp al, 10                # je cifra vetsi nebo rovna 10?
                  jge alpha_digit           # ano je, prevest na znak 'A'..'F'

numeric_digit:    add al, '0'               # neni, prevest na znak '0'..'9' (postacuje pricist ASCII hodnotu '0')
                  jmp store_digit

alpha_digit:      add al, 'A'-10            # prevod hodnoty 10..15 na znaky 'A'..'F'

store_digit:      mov byte ptr [ebx], al    # ulozeni cifry do retezce
                  inc ebx                   # dalsi ulozeni v retezci o znak dale
                  dec cl                    # snizeni pocitadla smycky
                  jnz print_one_digit       # a opakovani smycky, dokud se nedosahlo nuly

                  ret                       # navrat ze subrutiny
</pre>

<p>Poznámka: při ukládání znaku (jedné hexadecimální cifry) do řetězce je nutné použít <strong>mov byte ptr [ebx], al</strong>, protože jinak by GNU Assembler nevěděl, zda se má zapisovat bajt, 16bitové slovo, 32bitové slovo či 64bitové slovo.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. První demonstrační příklad: použití bitové rotace, maskování a součtu</h2>

<p>Pro větší přehlednost je první demonstrační příklad rozdělen do čtyř samostatných souborů, z&nbsp;nichž tři soubory obsahují makra a k&nbsp;nim pomocné subrutiny:</p>

<table>
<tr><th>Soubor</th><th>Význam</th></tr>
<tr><td>main.s</td><td>hlavní část aplikace, tento soubor je předán GNU Assembleru pro překlad, ostatní soubory jsou do něho vkládány direktivou <strong>.include</strong></td></tr>
<tr><td>exit.s</td><td>obsahuje pouze makro <strong>exit</strong> pro ukončení procesu</td></tr>
<tr><td>writeMessage.s</td><td>obsahuje makro <strong>writeMessage</strong> a taktéž příslušnou subrutinu <strong>write_message</strong>, taktéž zde nalezneme makro <strong>println</strong></td></tr>
<tr><td>printHexNumber.s</td><td>obsahuje makro <strong>printHexNumber</strong>, subrutinu <strong>hex2string</strong> a taktéž šablonu zprávy <strong>hexValueMessage</strong></td></tr>
</table>

<h3>Obsah souboru main.s</h3>

<p>V&nbsp;tomto souboru se přes direktivy <strong>.include</strong> vkládají další soubory a volají se makra <strong>printHexNumber</strong>, <strong>println</strong> a <strong>exit</strong>:</p>

<pre>
# asmsyntax=as

# Program pro otestovani makra urceneho pro vytisteni hexadecimalni hodnoty.
# - pro zapis je pouzita "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix



# Nacteni definice makra pro ukonceni aplikace
.include "exit.s"

# Nacteni maker pro (opakovany) tisk zpravy i prislusne subrutiny
.include "writeMessage.s"

# Nacteni makra pro vytisteni hexadecimalni 32bitove hodnoty
# spolecne s makrem je nactena i prislusna subrutina
.include "printHexNumber.s"



#-----------------------------------------------------------------------------
.section .data



#-----------------------------------------------------------------------------
.section .bss



#-----------------------------------------------------------------------------
.section .text
        .global _start               # tento symbol ma byt dostupny i linkeru

_start:
        printHexNumber 0             # otestujme zakladni hodnoty
        printHexNumber 1
        printHexNumber 2

        println

        printHexNumber 9             # dulezity je i prechod '9'-&gt;'A'
        printHexNumber 10

        println

        printHexNumber 15            # dalsi dulezity prechod pro otestovani 'F'-&gt;'10'
        printHexNumber 16

        println

        printHexNumber 127           # dalsi zajimave hodnoty pro otestovani
        printHexNumber 128
        printHexNumber 255
        printHexNumber 256

        println

        printHexNumber -1            # aritmetika se znamenkem - dvojkovym doplnkem
        printHexNumber -2
        printHexNumber -256

        exit                         # ukonceni aplikace
</pre>



<h3>Obsah souboru exit.s</h3>

<p>Zde nedochází k&nbsp;žádným podstatnějším změnám oproti předchozím demonstračním příkladům, v&nbsp;nichž jsme tento soubor taktéž využívali:</p>

<pre>
# asmsyntax=as

# Makro pro ukonceni procesu v Linuxu.
# - pro zapis je pouzita "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

sys_exit   = 1                       # cislo syscallu pro ukonceni procesu

# Deklarace makra pro ukonceni aplikace
.macro exit
        mov   eax, sys_exit          # cislo sycallu pro funkci "exit"
        mov   ebx, 0                 # exit code = 0
        int   0x80                   # volani Linuxoveho kernelu
.endm
</pre>



<h3>Obsah souboru writeMessage.s</h3>

<p>Nalezneme zde definici maker <strong>writeMessage</strong> a <strong>println</strong> společně se subrutinou <strong>write_message</strong>:</p>

<pre>
# asmsyntax=as

# Makro pro tisk zpravy na standardni vystup.
# - pro zapis je pouzita "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

# Linux kernel system call table
sys_write  = 4
std_output = 1



# Deklarace makra pro vytisteni zpravy na standardni vystup
.macro writeMessage message,messageLength
        mov   ecx, offset \message   # adresa retezce, ktery se ma vytisknout
        mov   edx, \messageLength    # pocet znaku, ktere se maji vytisknout
        call  write_message          # vytisknout zpravu "Zero flag not set"
.endm



# Podprogram pro vytisteni zpravy na standardni vystup
# Ocekava se, ze v ecx bude adresa zpravy a v edx jeji delka
write_message:
        mov   eax, sys_write         # cislo syscallu pro funkci "write"
        mov   ebx, std_output        # standardni vystup
        int   0x80
        ret



# Deklarace makra pro vytisteni znaku konce radku (provede se tedy odradkovani)
.macro println
        writeMessage printlnMessage,printlnLength
.endm



#-----------------------------------------------------------------------------
.section .data
# Miniretezec pouzivany makrem println
printlnMessage:
        .string "\n"
printlnLength = $ - printlnMessage
</pre>



<h3>Obsah souboru printHexNumber.s</h3>

<p>Nejdůležitější část celého programu s&nbsp;deklarací makra <strong>printHexNumber</strong> a subrutinou <strong>hex2string</strong>:</p>

<pre>
# asmsyntax=as

# Makro pro pripravu a tisk hexadecimalni hodnoty na standardni vystup.
# - pro zapis je pouzita "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix



# Makro pro vypis 32bitove hexadecimalni hodnoty na standardni vystup
# Jedinym parametrem makra je hodnota (konstanta)
.macro printHexNumber value
        mov  edx, \value                   # hodnotu pro tisk ulozit do registru EDX
        mov  ebx, offset hexValueTemplate  # adresu pro retezec ulozit do registru EBX
        call hex2string                    # zavolani prislusne subrutiny pro prevod na string
        writeMessage hexValueMessage, hexValueMessageLen # retezec je naplnen, tak ho muzeme vytisknout
.endm



#-----------------------------------------------------------------------------
.section .data
hexValueMessage:
        .string "Hex value: 0x"             # prvni cast zpravy
hexValueTemplate:                           # druha cast zpravy ma vlastni navesti
        .string "????????\n"                # otazniky budou prepsany
hexValueMessageLen = $ - hexValueMessage    # delka zpravy



#-----------------------------------------------------------------------------
.section .text

# Subrutina urcena pro prevod 32bitove hexadecimalni hodnoty na retezec
# Vstup: EDX - hodnota, ktera se ma prevest na retezec
#        EBX - adresa jiz drive alokovaneho retezce (resp. osmice bajtu)
hex2string:
                  mov cl,  8                # pocet opakovani smycky

print_one_digit:  rol edx, 4                # rotace doleva znamena, ze se do spodnich 4 bitu nasune dalsi cifra
                  mov al, dl                # nechceme porusit obsah vstupni hodnoty v EDX, proto pouzijeme AL
                  and al, 0x0f              # maskovani, potrebujeme pracovat jen s jednou cifrou
                  cmp al, 10                # je cifra vetsi nebo rovna 10?
                  jge alpha_digit           # ano je, prevest na znak 'A'..'F'

numeric_digit:    add al, '0'               # neni, prevest na znak '0'..'9' (postacuje pricist ASCII hodnotu '0')
                  jmp store_digit

alpha_digit:      add al, 'A'-10            # prevod hodnoty 10..15 na znaky 'A'..'F'

store_digit:      mov byte ptr [ebx], al    # ulozeni cifry do retezce
                  inc ebx                   # dalsi ulozeni v retezci o znak dale
                  dec cl                    # snizeni pocitadla smycky
                  jnz print_one_digit       # a opakovani smycky, dokud se nedosahlo nuly

                  ret                       # navrat ze subrutiny
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Výsledky vygenerované prvním demonstračním příkladem</h2>

<p>Pro jistotu se podívejme, jaké výsledky jsou naším prvním demonstračním příkladem vytištěny:</p>

<pre>
<strong>./a.out</strong>

Hex value: 0x00000000
Hex value: 0x00000001
Hex value: 0x00000002

Hex value: 0x00000009
Hex value: 0x0000000A

Hex value: 0x0000000F
Hex value: 0x00000010

Hex value: 0x0000007F
Hex value: 0x00000080
Hex value: 0x000000FF
Hex value: 0x00000100

Hex value: 0xFFFFFFFF
Hex value: 0xFFFFFFFE
Hex value: 0xFFFFFF00
</pre>

<p>Vše se zdá být v&nbsp;pořádku, a to i v&nbsp;případě záporných čísel, protože záporná čísla jsou, jak již víme z&nbsp;předchozích částí tohoto seriálu, reprezentovaná v&nbsp;dvojkovém doplňku.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Disassemblovaný strojový kód subrutiny <strong>hex2string</strong></h2>

<p>Pro zajímavost si v&nbsp;této kapitole ukažme, jak vypadá přeložený strojový kód subrutiny <strong>hex2string</strong>, kterou jsme si popsali v&nbsp;předchozích kapitolách. Celá subrutina byla přeložena do dvaceti sedmi bajtů a pro výpis každé cifry dojde k&nbsp;minimálně dvěma skokům (<strong>JGE+JNE</strong> popř.&nbsp;<strong>JMP+JNE</strong>). Povšimněte si, že všechny instrukce skoků mají délku pouhé dva bajty, a to z&nbsp;toho důvodu, že GNU Assembler zvolil použití relativních skoků v&nbsp;rozsahu -126..128 bajtů. Taktéž si povšimněte toho, že všechny instrukce s&nbsp;osmibitovými registry a konstantami (<strong>MOV CL, 0x08</strong>, <strong>AND AL, 0x0F</strong>, <strong>CMP AL, 0x0A</strong> či <strong>ADD AL, 0x30</strong>) mají taktéž velikost pouhé dva bajty. Pokud by všude byly použity 32bitové registry, byla by subrutina o několik bajtů delší:</p>

<pre>
0000000d &lt;hex2string&gt;:
   d:   b1 08                   mov    cl,0x8

0000000f &lt;print_one_digit&gt;:
   f:   c1 c2 04                rol    edx,0x4
  12:   88 d0                   mov    al,dl
  14:   24 0f                   and    al,0xf
  16:   3c 0a                   cmp    al,0xa
  18:   7d 04                   jge    1e &lt;alpha_digit&gt;

0000001a &lt;numeric_digit&gt;:
  1a:   04 30                   add    al,0x30
  1c:   eb 02                   jmp    20 &lt;store_digit&gt;

0000001e &lt;alpha_digit&gt;:
  1e:   04 37                   add    al,0x37

00000020 &lt;store_digit&gt;:
  20:   88 03                   mov    BYTE PTR [ebx],al
  22:   43                      inc    ebx
  23:   fe c9                   dec    cl
  25:   75 e8                   jne    f &lt;print_one_digit&gt;
  27:   c3                      ret
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Druhý demonstrační příklad: optimalizace spočívající v&nbsp;eliminaci nepodmíněného skoku</h2>

<p>První verze subrutiny <strong>hex2string</strong> není napsána optimálně; zejména se to týká zbytečně velkého množství programových skoků. V&nbsp;celém algoritmu nalezneme jednu podmínku (cifra menší než 10 či naopak větší nebo rovna deseti) a jednu smyčku (opakování výpočtu pro osm cifer). My jsme v&nbsp;první verzi použili následující implementaci podmínky:</p>

<pre>
                  cmp al, 10                # je cifra vetsi nebo rovna 10?
                  jge alpha_digit           # ano je, prevest na znak 'A'..'F'

numeric_digit:    add al, '0'               # neni, prevest na znak '0'..'9' (postacuje pricist ASCII hodnotu '0')
                  jmp store_digit

alpha_digit:      add al, 'A'-10            # prevod hodnoty 10..15 na znaky 'A'..'F'
</pre>

<p>Tutéž podmínku lze ovšem přepsat takovým způsobem, aby bylo možné vynechat druhý (nepodmíněný) skok. Podmínku otočíme, takže namísto skoku <strong>JGE</strong> (<i>jump if greater than or equal</i>) se použije skok <strong>JL</strong> (<i>jump if less</i>). U cifer A až F ovšem dojde k&nbsp;dvěma součtům:</p>

<pre>
                  cmp al, 10                # je cifra vetsi nebo rovna 10?
                  jl  store_digit           # neni, pouze prevest 0..9 na ASCII hodnotu '0'..'9'

alpha_digit:      add al, 'A'-10-'0'        # prevod hodnoty 10..15 na znaky 'A'..'F'

store_digit:      add al, '0'
</pre>

<p>Nová podoba souboru <strong>printHexNumber.s</strong> vypadá následovně:</p>

<pre>
# asmsyntax=as

# Makro pro pripravu a tisk hexadecimalni hodnoty na standardni vystup.
# - pro zapis je pouzita "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix



# Makro pro vypis 32bitove hexadecimalni hodnoty na standardni vystup
# Jedinym parametrem makra je hodnota (konstanta)
.macro printHexNumber value
        mov  edx, \value                   # hodnotu pro tisk ulozit do registru EDX
        mov  ebx, offset hexValueTemplate  # adresu pro retezec ulozit do registru EBX
        call hex2string                    # zavolani prislusne subrutiny pro prevod na string
        writeMessage hexValueMessage, hexValueMessageLen # retezec je naplnen, tak ho muzeme vytisknout
.endm



#-----------------------------------------------------------------------------
.section .data
hexValueMessage:
        .string "Hex value: 0x"             # prvni cast zpravy
hexValueTemplate:                           # druha cast zpravy ma vlastni navesti
        .string "????????\n"                # otazniky budou prepsany
hexValueMessageLen = $ - hexValueMessage    # delka zpravy



#-----------------------------------------------------------------------------
.section .text

# Subrutina urcena pro prevod 32bitove hexadecimalni hodnoty na retezec
# Vstup: EDX - hodnota, ktera se ma prevest na retezec
#        EBX - adresa jiz drive alokovaneho retezce (resp. osmice bajtu)
hex2string:
                  mov cl,  8                # pocet opakovani smycky

print_one_digit:  rol edx, 4                # rotace doleva znamena, ze se do spodnich 4 bitu nasune dalsi cifra
                  mov al, dl                # nechceme porusit obsah vstupni hodnoty v EDX, proto pouzijeme AL
                  and al, 0x0f              # maskovani, potrebujeme pracovat jen s jednou cifrou
                  cmp al, 10                # je cifra vetsi nebo rovna 10?
                  jl  store_digit           # neni, pouze prevest 0..9 na ASCII hodnotu '0'..'9'

alpha_digit:      add al, 'A'-10-'0'        # prevod hodnoty 10..15 na znaky 'A'..'F'

store_digit:      add al, '0'
                  mov byte ptr [ebx], al    # ulozeni cifry do retezce
                  inc ebx                   # dalsi ulozeni v retezci o znak dale
                  dec cl                    # snizeni pocitadla smycky
                  jnz print_one_digit       # a opakovani smycky, dokud se nedosahlo nuly

                  ret                       # navrat ze subrutiny
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Výsledky vygenerované druhým demonstračním příkladem</h2>

<p>Po úpravě subrutiny <strong>hex2string</strong> samozřejmě znovu program přeložíme a spustíme, aby se funkčnost subrutiny otestovala. Výsledky jsou (podle očekávání) shodné s&nbsp;originální verzí:</p>

<pre>
<strong>./a.out</strong>

Hex value: 0x00000000
Hex value: 0x00000001
Hex value: 0x00000002

Hex value: 0x00000009
Hex value: 0x0000000A

Hex value: 0x0000000F
Hex value: 0x00000010

Hex value: 0x0000007F
Hex value: 0x00000080
Hex value: 0x000000FF
Hex value: 0x00000100

Hex value: 0xFFFFFFFF
Hex value: 0xFFFFFFFE
Hex value: 0xFFFFFF00
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Disassemblovaný strojový kód upravené subrutiny <strong>hex2string</strong></h2>

<p>Vzhledem k&nbsp;tomu, že jsme ze subrutiny <strong>hex2string</strong> odstranili jeden nepodmíněný relativní skok, který byl původně přeložen do dvou bajtů, měla by být i podoba subrutiny po překladu do strojového kódu kratší přesně o tyto dva bajty. Můžeme se o tom ostatně velmi snadno přesvědčit po zadání příkazu:</p>

<pre>
objdump -M intel-mnemonic -f -d -t -h main.o
</pre>

<p>Ve výsledku nalezneme mj.&nbsp;i strojový kód a zpětný překlad subrutiny <strong>hex2string</strong>, z&nbsp;něhož skutečně vyplývá délka 25 bajtů v&nbsp;porovnání s&nbsp;27 bajty předchozí verze:</p>

<pre>
0000000d &lt;hex2string&gt;:
   d:   b1 08                   mov    cl,0x8

0000000f &lt;print_one_digit&gt;:
   f:   c1 c2 04                rol    edx,0x4
  12:   88 d0                   mov    al,dl
  14:   24 0f                   and    al,0xf
  16:   3c 0a                   cmp    al,0xa
  18:   7c 02                   jl     1c &lt;store_digit&gt;

0000001a &lt;alpha_digit&gt;:
  1a:   04 07                   add    al,0x7

0000001c &lt;store_digit&gt;:
  1c:   04 30                   add    al,0x30
  1e:   88 03                   mov    BYTE PTR [ebx],al
  20:   43                      inc    ebx
  21:   fe c9                   dec    cl
  23:   75 ea                   jne    f &lt;print_one_digit&gt;
  25:   c3                      ret
</pre>

<p>Poznámka: teoreticky jsou možné i další úpravy, například změna adresování při zápisu a použití instrukce <strong>STOSB</strong> namísto <strong>MOV</strong>, ovšem na moderních procesorech je použitá subrutina dostatečně rychlá a současně i krátká (což je neméně důležité zejména s&nbsp;ohledem na využití cache v&nbsp;procesoru).</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Vytištění desítkové hodnoty na standardní výstup</h2>

<p>Převod celočíselné 32bitové hodnoty na řetězec představující hexadecimální zápis tohoto čísla již tedy pro nás není problematický. Zkusme si nyní možná poněkud složitější příklad &ndash; převod celočíselné 32bitové hodnoty na decimální podobu. V&nbsp;tomto případě už nelze použít postup popsaný výše, tedy postupné získávání jednotlivých hexadecimálních cifer, přičemž každá cifra je uložena ve čtyřech bitech. Budeme muset postupovat jinak &ndash; postupně budeme dělit vstupní hodnotu deseti a zbytek po dělení budou jednotlivé cifry, které převedeme na ASCII. Řetězec s&nbsp;textovou reprezentací čísla se tedy bude skládat odzadu (od posledního znaku):</p>

<ol>

<li>Do 32bitového registru <strong>ECX</strong>, který bude fungovat jako počitadlo, uložíme konstantu 10, protože 32bitová hodnota je převedena na deset desítkových cifer (2<sup>32</sup>=4294967296). Můžeme zde vidět rozdíl oproti předchozímu příkladu, kde se pro počitadlo používal osmibitový registr, ale je to nutné, neboť nyní <strong>ECX</strong> použijeme i při adresování.</li>

<li>Do jednoho z&nbsp;volných 32bitových registrů se vloží konstanta 10, která bude použita v&nbsp;instrukci <strong>DIV</strong>. Opět je to nutné, protože instrukce <strong>DIV</strong>, jako jedna z&nbsp;mála aritmetických instrukcí, vyžaduje použití registru a nikoli konstanty (jinak by bylo možné zapsat <strong>DIV 10</strong>).</li>

<li>Vynulujeme registr <strong>EDX</strong>, protože instrukce <strong>DIV</strong> provede dělení 64bitové hodnoty uložené v&nbsp;registrovém párů <strong>EDX:EAX</strong>. My samozřejmě dělíme pouze 32bitové číslo, takže horních 32bitů bude vždy nulových.</li>

<li>Instrukcí <strong>DIV EDI</strong> vydělíme hodnotu v&nbsp;<strong>(EDX):EAX</strong> deseti, přičemž výsledek se uloží zpět do <strong>EAX</strong> (což se nám hodí pro další iteraci) a zbytek po dělení se ocitne v&nbsp;registru <strong>EDX</strong>.</li>

<li>Víme, že po dělení deseti může být zbytek maximálně roven devíti, takže budeme pracovat jen s&nbsp;osmi nejnižšími bity registru <strong>EDX</strong>, pro něž existuje jmenný alias <strong>DL</strong>. Přičteme ke zbytku ASCII hodnotu znaku '0' a získáme tak nejnižší cifru výsledku.</li>

<li>Nyní máme v&nbsp;registru <strong>DL</strong> uloženou nejnižší cifru výsledku (ASCII kód znaku '0' až '9'), v&nbsp;registru <strong>ECX</strong> je hodnota počitadla (na začátku nastavena na 10) a v&nbsp;registru <strong>EBX</strong> adresa začátku řetězce s&nbsp;otazníky (kam se mají postupně vypsat jednotlivé cifry). My nyní potřebujeme zapisovat cifry od konce (od nejnižšího řádu), tedy od adresy <strong>EBX+ECX-1</strong>. Takový adresovací režim je skutečně na architektuře i386/x86-64 podporován, takže stačí provést zápis: <strong>mov byte ptr [ebx+ecx-1], dl </strong>.</li>

<li>Snížíme počitadlo v&nbsp;registru <strong>ECX</strong> o jedničku a pokud je nenulové, bude se celá smyčka opakovat.</li>

</ol>

<pre>
# Subrutina urcena pro prevod 32bitove desitkove hodnoty na retezec
# Vstup: EAX - hodnota, ktera se ma prevest na retezec
#        EBX - adresa jiz drive alokovaneho retezce (resp. minimalne deseti bajtu)
decimal2string:
                  mov ecx, 10              # celkovy pocet zapisovanych cifer/znaku
                  mov edi, ecx             # instrukce DIV vyzaduje deleni registrem, pouzijme tedy EDI

next_digit:
                  xor edx, edx             # delenec je dvojice EDX:EAX, vynulujeme tedy horni registr EDX
                  div edi                  # deleni hodnoty ulozene v EDX:EAX deseti (delitelem je EDI)
                                           # vysledek se ulozi do EAX, zbytek do EDX
                                           # pri deleni deseti je jistota, ze zbytek je jen cislo 0..9

                  add dl, '0'              # prevod hodnoty 0..9 na znak '0'-'9'

                  mov byte ptr [ebx+ecx-1], dl # zapis retezce (od posledniho znaku)

                  dec ecx                  # presun na predchozi znak v retezci a soucasne snizeni hodnoty pocitadla
                  jnz next_digit           # uz jsme dosli k poslednimu cislu?

                  ret                      # navrat ze subrutiny
</pre>

<p>Celá subrutina má pouhých devět instrukcí, což není špatné.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Třetí demonstrační příklad: použití instrukce <strong>DIV</strong> a adresování typu registr+registr+offset</h2>

<p>Celý třetí demonstrační příklad si zde nebudeme vypisovat, a to z&nbsp;toho prostého důvodu, že soubory <strong>exit.s</strong> a <strong>writeMessage.s</strong> jsou naprosto shodné se soubory použitými v&nbsp;prvních dvou příkladech. Ukážeme si tedy obsah souborů <strong>main.s</strong> a samozřejmě taktéž <strong>printDecimalNumber.s</strong>.</p>



<h3>Soubor main.s</h3>

<p>V&nbsp;tomto souboru se přes direktivy <strong>.include</strong> vkládají další soubory a volají se makra <strong>printDecimalNumber</strong>, <strong>println</strong> a <strong>exit</strong>. Vzhledem k&nbsp;charakteru převodu již netestujeme hodnoty typu 0xf (15) a 255, které jsou zajímavé z&nbsp;hlediska hexadecimálního kódu, ale hodnoty typu 99, 100, 999, 1000 atd. Vyzkoušíme i zadání záporných čísel, i když je nutné dopředu říci, že ta nebudou vypsána korektně:</p>

<pre>
# asmsyntax=as

# Program pro otestovani makra urceneho pro vytisteni desitkove hodnoty.
# - pro zapis je pouzita "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix



# Nacteni definice makra pro ukonceni aplikace
.include "exit.s"

# Nacteni maker pro (opakovany) tisk zpravy i prislusne subrutiny
.include "writeMessage.s"

# Nacteni makra pro vytisteni desitkove 32bitove hodnoty
# spolecne s makrem je nactena i prislusna subrutina
.include "printDecimalNumber.s"



#-----------------------------------------------------------------------------
.section .data



#-----------------------------------------------------------------------------
.section .bss



#-----------------------------------------------------------------------------
.section .text
        .global _start               # tento symbol ma byt dostupny i linkeru

_start:
        printDecimalNumber 0         # otestujme zakladni hodnoty
        printDecimalNumber 1
        printDecimalNumber 2

        println

        printDecimalNumber 9         # dulezity je i prechod
        printDecimalNumber 10

        println

        printDecimalNumber 99        # dalsi dulezity prechod pro otestovani
        printDecimalNumber 100

        println

        printDecimalNumber 999       # a dalsi...
        printDecimalNumber 1000

        println

        printDecimalNumber -1        # aritmetika se znamenkem - dvojkovym doplnkem
        printDecimalNumber -2
        printDecimalNumber -9
        printDecimalNumber -10

        exit                         # ukonceni aplikace
</pre>



<h3>Soubor printDecimalNumber.s</h3>

<p>Nejdůležitější částí tohoto demonstračního příkladu je již popsané makro <strong>printDecimalNumber</strong> a k&nbsp;němu příslušející subrutina <strong>decimal2string</strong>. Ty nalezneme právě v&nbsp;souboru nazvaném <strong>printDecimalNumber.s</strong>:</p>

<pre>
# asmsyntax=as

# Makro pro pripravu a tisk desitkove hodnoty na standardni vystup.
# - pro zapis je pouzita "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix



# Makro pro vypis 32bitove desitkove hodnoty na standardni vystup
# Jedinym parametrem makra je hodnota (konstanta)
.macro printDecimalNumber value
        mov  eax, \value                       # hodnotu pro tisk ulozit do registru EAX
        mov  ebx, offset decimalValueTemplate  # adresu pro retezec ulozit do registru EBX
        call decimal2string                    # zavolani prislusne subrutiny pro prevod na string
        writeMessage decimalValueMessage, decimalValueMessageLen # retezec je naplnen, tak ho muzeme vytisknout
.endm



#-----------------------------------------------------------------------------
.section .data
decimalValueMessage:
        .string "Decimal value: "              # prvni cast zpravy
decimalValueTemplate:                          # druha cast zpravy ma vlastni navesti
        .string "??????????\n"                 # otazniky budou prepsany (musi jich byt presne deset!)
decimalValueMessageLen = $ - decimalValueMessage    # delka zpravy



#-----------------------------------------------------------------------------
.section .text

# Subrutina urcena pro prevod 32bitove desitkove hodnoty na retezec
# Vstup: EDX - hodnota, ktera se ma prevest na retezec
#        EBX - adresa jiz drive alokovaneho retezce (resp. minimalne deseti bajtu)
decimal2string:
                  mov ecx, 10              # celkovy pocet zapisovanych cifer/znaku
                  mov edi, ecx             # instrukce DIV vyzaduje deleni registrem, pouzijme tedy EDI

next_digit:
                  xor edx, edx             # delenec je dvojice EDX:EAX, vynulujeme tedy horni registr EDX
                  div edi                  # deleni hodnoty ulozene v EDX:EAX deseti (delitelem je EDI)
                                           # vysledek se ulozi do EAX, zbytek do EDX
                                           # pri deleni deseti je jistota, ze zbytek je jen cislo 0..9

                  add dl, '0'              # prevod hodnoty 0..9 na znak '0'-'9'

                  mov byte ptr [ebx+ecx-1], dl # zapis retezce (od posledniho znaku)

                  dec ecx                  # presun na predchozi znak v retezci a soucasne snizeni hodnoty pocitadla
                  jnz next_digit           # uz jsme dosli k poslednimu cislu?

                  ret                      # navrat ze subrutiny
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Výsledky vygenerované třetím demonstračním příkladem</h2>

<p>Po spuštění tohoto demonstračního příkladu by se na standardním výstupu měly objevit následující řádky:</p>

<pre>
<strong>./a.out</strong>

Decimal value: 0000000000
Decimal value: 0000000001
Decimal value: 0000000002

Decimal value: 0000000009
Decimal value: 0000000010

Decimal value: 0000000099
Decimal value: 0000000100

Decimal value: 0000000999
Decimal value: 0000001000

Decimal value: 4294967295
Decimal value: 4294967294
Decimal value: 4294967287
Decimal value: 4294967286
</pre>

<p>Povšimněte si především nesprávné funkce subrutiny pro záporná čísla, tedy pro poslední čtyři řádky na výstupu. Pokud by bylo nutné záporná čísla skutečně zpracovávat a vypisovat, celý program by byl poněkud složitější, neboť by se musel testovat nejvyšší bit původní hodnoty (<strong>CMP+JP</strong>) a namísto instrukce <strong>DIV</strong> by se použila instrukce <strong>IDIV</strong> popř.&nbsp;by se před výpočtem číslo převedlo na svou absolutní hodnotu instrukcí <strong>NEG</strong>.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Disassemblovaný strojový kód subrutiny <strong>decimal2string</strong></h2>

<p>Pro zajímavost se opět podívejme, jak se program přeložil do strojového kódu:</p>

<pre>
0000000d &lt;decimal2string&gt;:
   d:   b9 0a 00 00 00          mov    ecx,0xa
  12:   89 cf                   mov    edi,ecx

00000014 &lt;next_digit&gt;:
  14:   31 d2                   xor    edx,edx
  16:   f7 f7                   div    edi
  18:   80 c2 30                add    dl,0x30
  1b:   88 54 0b ff             mov    BYTE PTR [ebx+ecx*1-0x1],dl
  1f:   49                      dec    ecx
  20:   75 f2                   jne    14 &lt;next_digit&gt;
  22:   c3                      ret
</pre>

<p>Velmi neefektivní je především první instrukce, která nastavuje počitadlo. Pokud by nám záleželo na délce subrutiny a nikoli na rychlosti zpracování, lze použít známého triku s&nbsp;vymazáním celého registru a nastavením pouze jeho spodních osmi bitů:</p>

<pre>
   d:   31 c9                   xor    ecx,ecx
   f:   b1 0a                   mov    cl,0xa
</pre>

<p>Naopak je možná překvapivé, jak se přeložila relativně složitá instrukce <strong>mov BYTE PTR [ebx+ecx*1-0x1],dl</strong>, v&nbsp;níž se, jak vidíme, navíc násobí hodnota počitadla <strong>ECX</strong> celočíselnou konstantou 1 (zde tuto možnost nevyužijeme, ale při přístupu do polí či záznamů to může být velmi výhodné:</p>

<pre>
  1b:   88 54 0b ff             mov    BYTE PTR [ebx+ecx*1-0x1],dl
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny tři dnes popisované demonstrační příklady byly, podobně jako ve všech předchozích částech tohoto seriálu, společně s&nbsp;podpůrnými skripty určenými pro jejich překlad či naopak pro disassembling, uloženy do GIT repositáře dostupného na adrese <a href="https://github.com/tisnik/presentations/">https://github.com/tisnik/presentations/</a>. Všechny příklady jsou určeny pro GNU Assembler a používají Intel syntaxi, která je pro mnoho programátorů čitelnější, než původní AT&amp;T syntaxe. Následují tabulky s&nbsp;odkazy na zdrojové kódy příkladů i na již zmíněné podpůrné skripty:</p>

<h3>První demonstrační příklad &ndash; vytištění hexadecimální 32bitové hodnoty</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>main.s</td><td>hlavní program pro GNU Assembler</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/32_print_hex_number/main.s">https://github.com/tisnik/presentations/blob/master/assembler/32_print_hex_number/main.s</a></td></tr>
<tr><td>2</td><td>exit.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/32_print_hex_number/exit.s">https://github.com/tisnik/presentations/blob/master/assembler/32_print_hex_number/exit.s</a></td></tr>
<tr><td>3</td><td>writeMessage.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/32_print_hex_number/writeMessage.s">https://github.com/tisnik/presentations/blob/master/assembler/32_print_hex_number/writeMessage.s</a></td></tr>
<tr><td>4</td><td>printHexNumber.s</td><td>implementace makra a subrutiny pro převod hex2string</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/32_print_hex_number/printHexNumber.s">https://github.com/tisnik/presentations/blob/master/assembler/32_print_hex_number/printHexNumber.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>assemble</td><td>skript pro překlad na procesorech i386</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/32_print_hex_number/assemble">https://github.com/tisnik/presentations/blob/master/assembler/32_print_hex_number/assemble</a></td></tr>
<tr><td>6</td><td>disassemble</td><td>skript pro disassembling</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/32_print_hex_number/disassemble">https://github.com/tisnik/presentations/blob/master/assembler/32_print_hex_number/disassemble</a></td></tr>
</table>



<h3>Druhý demonstrační příklad &ndash; vylepšená verze subrutiny pro vytištění hexadecimální 32bitové hodnoty</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>main.s</td><td>hlavní program pro GNU Assembler</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/33_print_hex_number_2/main.s">https://github.com/tisnik/presentations/blob/master/assembler/33_print_hex_number_2/main.s</a></td></tr>
<tr><td>2</td><td>exit.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/33_print_hex_number_2/exit.s">https://github.com/tisnik/presentations/blob/master/assembler/33_print_hex_number_2/exit.s</a></td></tr>
<tr><td>3</td><td>writeMessage.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/33_print_hex_number_2/writeMessage.s">https://github.com/tisnik/presentations/blob/master/assembler/33_print_hex_number_2/writeMessage.s</a></td></tr>
<tr><td>4</td><td>printHexNumber2.s</td><td>vylepšená implementace makra a subrutiny pro převod hex2string</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/33_print_hex_number_2/printHexNumber2.s">https://github.com/tisnik/presentations/blob/master/assembler/33_print_hex_number_2/printHexNumber2.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>assemble</td><td>skript pro překlad na procesorech i386</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/33_print_hex_number_2/assemble">https://github.com/tisnik/presentations/blob/master/assembler/33_print_hex_number_2/assemble</a></td></tr>
<tr><td>6</td><td>disassemble</td><td>skript pro disassembling</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/33_print_hex_number_2/disassemble">https://github.com/tisnik/presentations/blob/master/assembler/33_print_hex_number_2/disassemble</a></td></tr>
</table>



<h3>Třetí demonstrační příklad &ndash; vytištění desítkové 32bitové hodnoty</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>main.s</td><td>hlavní program pro GNU Assembler</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/34_print_decimal_number/main.s">https://github.com/tisnik/presentations/blob/master/assembler/34_print_decimal_number/main.s</a></td></tr>
<tr><td>2</td><td>exit.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/34_print_decimal_number/exit.s">https://github.com/tisnik/presentations/blob/master/assembler/34_print_decimal_number/exit.s</a></td></tr>
<tr><td>3</td><td>writeMessage.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/34_print_decimal_number/writeMessage.s">https://github.com/tisnik/presentations/blob/master/assembler/34_print_decimal_number/writeMessage.s</a></td></tr>
<tr><td>4</td><td>printDecimalNumber.s</td><td>implementace makra a subrutiny pro převod decimal2string</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/34_print_decimal_number/printDecimalNumber.s">https://github.com/tisnik/presentations/blob/master/assembler/34_print_decimal_number/printDecimalNumber.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>assemble</td><td>skript pro překlad na procesorech i386</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/34_print_decimal_number/assemble">https://github.com/tisnik/presentations/blob/master/assembler/34_print_decimal_number/assemble</a></td></tr>
<tr><td>6</td><td>disassemble</td><td>skript pro disassembling</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/34_print_decimal_number/disassemble">https://github.com/tisnik/presentations/blob/master/assembler/34_print_decimal_number/disassemble</a></td></tr>
</table>



<p><a name="k15"></a></p>
<h2 id="k15">15. Odkazy na Internetu</h2>

<ol>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>The GNU Assembler Tutorial<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html">http://tigcc.ticalc.org/doc/gnuasm.html</a>
</li>

<li>The GNU Assembler - macros<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html#SEC109">http://tigcc.ticalc.org/doc/gnuasm.html#SEC109</a>
</li>

<li>ARM subroutines &amp; program stack<br />
<a href="http://www.toves.org/books/armsub/">http://www.toves.org/books/armsub/</a>
</li>

<li>Generating Mixed Source and Assembly List using GCC<br />
<a href="http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/">http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/</a>
</li>

<li>Calling subroutines<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm</a>
</li>

<li>ARM Assembly Language Programming<br />
<a href="http://peter-cockerell.net/aalp/html/frames.html">http://peter-cockerell.net/aalp/html/frames.html</a>
</li>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Intel x86 JUMP quick reference<br />
<a href="http://unixwiz.net/techtips/x86-jumps.html">http://unixwiz.net/techtips/x86-jumps.html</a>
</li>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Assembler pod Linuxem<br />
<a href="http://phoenix.inf.upol.cz/linux/prog/asm.html">http://phoenix.inf.upol.cz/linux/prog/asm.html</a>
</li>

<li>AT&amp;T Syntax versus Intel Syntax<br />
<a href="https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html">https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html</a>
</li>

<li>Linux Assembly website<br />
<a href="http://asm.sourceforge.net/">http://asm.sourceforge.net/</a>
</li>

<li>Using Assembly Language in Linux<br />
<a href="http://asm.sourceforge.net/articles/linasm.html">http://asm.sourceforge.net/articles/linasm.html</a>
</li>

<li>vasm<br />
<a href="http://sun.hasenbraten.de/vasm/">http://sun.hasenbraten.de/vasm/</a>
</li>

<li>vasm &ndash; dokumentace<br />
<a href="http://sun.hasenbraten.de/vasm/release/vasm.html">http://sun.hasenbraten.de/vasm/release/vasm.html</a>
</li>

<li>The Yasm Modular Assembler Project<br />
<a href="http://yasm.tortall.net/">http://yasm.tortall.net/</a>
</li>

<li>680x0:AsmOne<br />
<a href="http://www.amigacoding.com/index.php/680x0:AsmOne">http://www.amigacoding.com/index.php/680x0:AsmOne</a>
</li>

<li>ASM-One Macro Assembler<br />
<a href="http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler">http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler</a>
</li>

<li>ASM-One pages<br />
<a href="http://www.theflamearrows.info/documents/asmone.html">http://www.theflamearrows.info/documents/asmone.html</a>
</li>

<li>Základní informace o ASM-One<br />
<a href="http://www.theflamearrows.info/documents/asminfo.html">http://www.theflamearrows.info/documents/asminfo.html</a>
</li>

<li>Linux Syscall Reference<br />
<a href="http://syscalls.kernelgrok.com/">http://syscalls.kernelgrok.com/</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>IBM System 360/370 Compiler and Historical Documentation<br />
<a href="http://www.edelweb.fr/Simula/">http://www.edelweb.fr/Simula/</a>
</li>

<li>IBM 700/7000 series<br />
<a href="http://en.wikipedia.org/wiki/IBM_700/7000_series">http://en.wikipedia.org/wiki/IBM_700/7000_series</a>
</li>

<li>IBM System/360<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/360">http://en.wikipedia.org/wiki/IBM_System/360</a>
</li>

<li>IBM System/370<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/370">http://en.wikipedia.org/wiki/IBM_System/370</a>
</li>

<li>Mainframe family tree and chronology<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html</a>
</li>

<li>704 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html</a>
</li>

<li>705 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html</a>
</li>

<li>The IBM 704<br />
<a href="http://www.columbia.edu/acis/history/704.html">http://www.columbia.edu/acis/history/704.html</a>
</li>

<li>IBM Mainframe album<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html</a>
</li>

<li>Osmibitové muzeum<br />
<a href="http://osmi.tarbik.com/">http://osmi.tarbik.com/</a>
</li>

<li>Tesla PMI-80<br />
<a href="http://osmi.tarbik.com/cssr/pmi80.html">http://osmi.tarbik.com/cssr/pmi80.html</a>
</li>

<li>PMI-80<br />
<a href="http://en.wikipedia.org/wiki/PMI-80">http://en.wikipedia.org/wiki/PMI-80</a>
</li>

<li>PMI-80<br />
<a href="http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016">http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016</a>
</li>

<li>The 6502 overflow flag explained mathematically <br />
<a href="http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html">http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html</a>
</li>

<li>X86 Opcode and Instruction Reference<br />
<a href="http://ref.x86asm.net/coder32.html">http://ref.x86asm.net/coder32.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

