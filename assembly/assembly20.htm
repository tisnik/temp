<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Použití assembleru v Linuxu: RISCová architektura AArch64 (programové smyčky)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Použití assembleru v Linuxu: RISCová architektura AArch64 (pokračování)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;dnešní části seriálu o použití assembleru v&nbsp;Linuxu si na několika demonstračních příkladech ukážeme, jakým způsobem je možné využívat nepodmíněné i podmíněné skoky na procesorech s&nbsp;architekturou AArch64 při implementaci programových smyček s&nbsp;podmínkou testovanou na začátku či na konci každé iterace. Uvidíme, že se instrukční sady ARM32 a AArch64 v&nbsp;tomto ohledu od sebe poněkud odlišují.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Použití assembleru v&nbsp;Linuxu: RISCová architektura AArch64 (pokračování)</a></p>
<p><a href="#k02">2. Od podmínkových bitů k&nbsp;podmíněným skokům</a></p>
<p><a href="#k03">3. Základní podmíněné skoky na architektuře AArch64</a></p>
<p><a href="#k04">4. Počítaná programová smyčka &ndash; první varianta</a></p>
<p><a href="#k05">5. Porovnání verze pro ARM32 s&nbsp;verzí pro AArch64</a></p>
<p><a href="#k06">6. Počítaná programová smyčka &ndash; druhá varianta</a></p>
<p><a href="#k07">7. Porovnání verze pro ARM32 s&nbsp;verzí pro AArch64</a></p>
<p><a href="#k08">8. Test na ukončení smyčky na začátku každé iterace</a></p>
<p><a href="#k09">9. První varianta smyčky s&nbsp;testem na začátku</a></p>
<p><a href="#k10">10. Porovnání s&nbsp;ARM32</a></p>
<p><a href="#k11">11. Druhá varianta smyčky s&nbsp;testem na začátku</a></p>
<p><a href="#k12">12. Porovnání s&nbsp;ARM32</a></p>
<p><a href="#k13">13. Instrukce <strong>CBZ</strong> a <strong>CBNZ</strong></a></p>
<p><a href="#k14">14. Úprava prvního demonstračního příkladu použitím instrukce <strong>CBNZ</strong></a></p>
<p><a href="#k15">15. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Použití assembleru v&nbsp;Linuxu: RISCová architektura AArch64 (pokračování)</h2>

<p>Jedním z&nbsp;důležitých rozdílů mezi 32bitovou RISCovou architekturou ARM a 64bitovou architekturou AArch64 je absence podmínkových bitů u AArch64. To mj.&nbsp;znamená, že se v&nbsp;programovém kódu bude nacházet větší množství skoků, protože není možné využít vynechání či přeskočení (<i>skip</i>) nějaké instrukce či sekvence instrukcí v&nbsp;závislosti na aktuálním nastavení bitových příznaků (<i>zero</i>, <i>carry</i>, <i>overflow</i>, <i>negative</i>). Na druhou stranu však v&nbsp;instrukční sadě AArch64 nalezneme některé nové užitečné a poměrně často používané instrukce, například podmíněné skoky <strong>CBZ</strong> a <strong>CBNZ</strong>, které byly již dříve přidány do instrukční sady Thumb-2 (ovšem v&nbsp;původní RISCové instrukční sadě je nenajdeme). V&nbsp;dnešním článku si nejprve ukážeme, jakým způsobem se musí přepsat programy používající počítané programové smyčky s&nbsp;testem na začátku či na konci a jak lze v&nbsp;těchto smyčkách využít zmíněné instrukce <strong>CBZ</strong> a <strong>CBNZ</strong>. Zmíníme se i o některých dalších omezeních, s&nbsp;nimiž je nutné na AArch64 počítat; například s&nbsp;nutností použití 32bitového registru <strong>Wx</strong> při zápisu jednotlivých bajtů (znaků) do operační paměti.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Od podmínkových bitů k&nbsp;podmíněným skokům</h2>

<p>Již v&nbsp;předchozím článku jsme si řekli, že instrukční sada AArch64 se od původní 32bitové RISCové instrukční sady ARM32 (či zkráceně pouze A32) odlišuje mj.&nbsp;i v&nbsp;tom, že se zredukoval počet instrukcí, u nichž je možné použít podmínkové bity. Jen ve stručnosti si připomeňme, že v&nbsp;instrukční sadě ARM32 jsou v&nbsp;prakticky každém instrukčním slovu (každé má konstantní šířku třiceti dvou bitů) rezervovány čtyři nejvyšší bity, v&nbsp;nichž je zapsán kód podmínky, při jejímž splnění se instrukce provede. Díky této vlastnosti bylo možné v&nbsp;mnoha algoritmech zredukovat počet podmíněných skoků, což je v&nbsp;případě RISCových procesorů poměrně důležité.</p>

<p>Všechny podmínky jsou vyhodnoceny na základě hodnoty jednoho či (častěji) většího množství příznaků. První sada podmínkových kódů se používá pro provedení či naopak neprovedení instrukce na základě hodnoty jednoho z&nbsp;příznakových bitů <strong>Z (zero)</strong>, <strong>V (overflow)</strong> či <strong>N (negative)</strong>. Poslední podmínkový kód z&nbsp;této skupiny má název <strong>AL</strong> (Any/Always) a značí, že se instrukce provede v&nbsp;každém případě. Tento podmínkový kód se tudíž většinou v&nbsp;assembleru ani nezapisuje, protože je považován za implicitní:</p>

<table>
<tr><th>Kód</th><th>Přípona</th><th>Význam</th><th>Testovaná podmínka</th></tr>
<tr><td>0000</td><td>EQ</td><td>Z = 1</td><td>rovnost (či nulový výsledek)</td></tr>
<tr><td>0001</td><td>NE</td><td>Z = 0</td><td>nerovnost (či nenulový výsledek)</td></tr>
<tr><td>0100</td><td>MI</td><td>N = 1</td><td>výsledek je záporný</td></tr>
<tr><td>0101</td><td>PL</td><td>N = 0</td><td>výsledek je kladný či 0</td></tr>
<tr><td>0110</td><td>VS</td><td>V = 1</td><td>nastalo přetečení</td></tr>
<tr><td>0111</td><td>VC</td><td>V = 0</td><td>nenastalo přetečení</td></tr>
<tr><td>1110</td><td>AL</td><td>Any/Always</td><td>většinou se nezapisuje, implicitní podmínka</td></tr>
</table>

<p>Další čtyři podmínkové kódy se většinou používají při porovnávání dvou hodnot bez znaménka (unsigned). V&nbsp;těchto případech se testují stavy příznakových bitů <strong>C (carry)</strong> a <strong>Z (zero)</strong>, přesněji řečeno kombinace těchto bitů:</p>

<table>
<tr><th>Kód </th><th>Přípona</th><th>Význam</th><th>Testovaná podmínka</th></tr>
<tr><td>0010</td><td>CS/HS</td><td>C = 1</td><td>&ge;</td></tr>
<tr><td>0011</td><td>CC/LO</td><td>C = 0</td><td>&lt;</td></tr>
<tr><td>1000</td><td>HI</td><td>C = 1 &amp; Z = 0</td><td>&gt;</td></tr>
<tr><td>1001</td><td>LS</td><td>C = 0 | Z = 1 </td><td>&le;</td></tr>
</table>

<p>Poslední čtyři podmínkové kódy se používají pro porovnávání hodnot se znaménkem (signed). V&nbsp;těchto případech se namísto příznakových bitů <strong>(C) carry</strong> a <strong>(Z) zero</strong> testují kombinace bitů <strong>(N) negative</strong>, <strong>(V) overflow</strong> a <strong>(Z) zero</strong>:</p>

<table>
<tr><th>Kód </th><th>Přípona</th><th>Význam</th><th>Testovaná podmínka</th></tr>
<tr><td>1010</td><td>GE</td><td>N == V</td><td>&ge;</td></tr>
<tr><td>1011</td><td>LT</td><td>N &ne; V </td><td>&lt;</td></tr>
<tr><td>1100</td><td>GT</td><td>Z = 0, N = V </td><td>&gt;</td></tr>
<tr><td>1101</td><td>LE</td><td>Z = 1, N &ne; V</td><td>&le;</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Základní podmíněné skoky na architektuře AArch64</h2>

<p>Procesory s&nbsp;architekturou AArch64 sice používají shodné podmínkové bity, ty jsou ovšem použity jen v&nbsp;několika instrukcích. Příznak přetečení je, podobně jako u mnoha dalších typů procesorů, používán při aritmetických operacích a testy podmínkových bitů lze provádět především u podmíněných skoků, tj.&nbsp;u instrukcí, jejichž mnemotechnická zkratka začíná znakem &bdquo;B&ldquo; od slova &bdquo;Branch&ldquo;. Rozeznáváme následující typy nepodmíněných podmíněných skoků:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Alternativní zápis</th></tr>
<tr><td>1</td><td>B</td><td>BAL</td></tr>
<tr><td>2</td><td>B.EQ</td><td>BEQ</td></tr>
<tr><td>3</td><td>B.NE</td><td>BNE</td></tr>
<tr><td>4</td><td>B.MI</td><td>BMI</td></tr>
<tr><td>5</td><td>B.PL</td><td>BPL</td></tr>
<tr><td>6</td><td>B.VS</td><td>BVS</td></tr>
<tr><td>7</td><td>B.VC</td><td>BVC</td></tr>
<tr><td>8</td><td>B.CS</td><td>BCS</td></tr>
<tr><td>9</td><td>B.CC</td><td>BCC</td></tr>
<tr><td>10</td><td>B.HI</td><td>BHI</td></tr>
<tr><td>11</td><td>B.LS</td><td>BLS</td></tr>
<tr><td>12</td><td>B.GE</td><td>BGE</td></tr>
<tr><td>13</td><td>B.LT</td><td>BLT</td></tr>
<tr><td>14</td><td>B.GT</td><td>BGT</td></tr>
<tr><td>15</td><td>B.LE</td><td>BLE</td></tr>
</table>

<p>Poznámka: alternativní zápis je podporován například GNU Assemblerem, který budeme používat v&nbsp;demonstračních příkladech.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Počítaná programová smyčka &ndash; první varianta</h2>

<p>Nastavení příznakových bitů a podmíněné skoky si otestujeme na demonstračním příkladu, s&nbsp;nímž jsme se již seznámili na jiných architekturách. V&nbsp;tomto příkladu je implementována počítaná programová smyčka, v&nbsp;níž se naplňuje řetězec (resp.&nbsp;přesněji řečeno předem zvolená oblast paměti) znakem &bdquo;*&ldquo;. První varianta tohoto příkladu vypadá na architektuře AArch64 prakticky stejně, jako tomu bylo u dalších popisovaných typů mikroprocesorů, tj.&nbsp;x86, x86-64 i ARM32 &ndash; používá se sekvence tří instrukcí určených pro snížení hodnoty počitadla smyčky o jedničku, testu, zda již počitadlo dosáhlo nuly a podmíněného skoku provedeného za předpokladu, že se nuly nedosáhlo:</p>

<pre>
loop:
        strb  w3, [x1]               // zapis znaku do bufferu
        add   x1, x1, #1             // uprava ukazatele do bufferu
        sub   x2, x2, #1             // zmenseni pocitadla
        cmp   x2, #0                 // otestovani, zda jsme jiz nedosahli nuly
        bne   loop                   // pokud jsme se nedostali k nule, skok na zacatek smycky
</pre>

<p>Povšimněte si, že při zápisu bajtu (znaku) do operační paměti instrukcí <strong>strb</strong> (<i>store byte</i>) je nutné použít 32bitový registr <strong>w3</strong> a nikoli 64bitový registr<strong>x3</strong>. Do paměti se zapisuje samozřejmě pouze spodních osm bitů.</p>

<p>Úplný zdrojový kód tohoto příkladu vypadá následovně:</p>

<pre>
# asmsyntax=as
 
# Testovaci program naprogramovany v assembleru GNU as
# - pocitana programova smycka
# - uprava pro mikroprocesory s architekturou AArch64
#
# Autor: Pavel Tisnovsky
 
 
 
# Linux kernel system call table
sys_exit   = 93
sys_write  = 64

# List of syscalls for AArch64:
# https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h
 
# Dalsi konstanty pouzite v programu - standardni streamy
std_input  = 0
std_output = 1

# pocet opakovani znaku
rep_count  = 40
 
 
 
#-----------------------------------------------------------------------------
.section .data
 
 
 
#-----------------------------------------------------------------------------
.section .bss
        .lcomm buffer, rep_count     // rezervace bufferu pro vystup
 
 
 
#-----------------------------------------------------------------------------
.section .text
        .global _start               // tento symbol ma byt dostupny i linkeru
 
_start:
        ldr   x1, =buffer            // zapis se bude provadet do tohoto bufferu
        mov   x2, #rep_count         // pocet opakovani znaku
        mov   w3, #'*'               // zapisovany znak
loop:
        strb  w3, [x1]               // zapis znaku do bufferu
        add   x1, x1, #1             // uprava ukazatele do bufferu
        sub   x2, x2, #1             // zmenseni pocitadla
        cmp   x2, #0                 // otestovani, zda jsme jiz nedosahli nuly
        bne   loop                   // pokud jsme se nedostali k nule, skok na zacatek smycky
 
        mov   x8, #sys_write         // cislo syscallu pro funkci "write"
        mov   x0, #std_output        // standardni vystup
        ldr   x1, =buffer            // adresa retezce, ktery se ma vytisknout
        mov   x2, #rep_count         // pocet znaku, ktere se maji vytisknout
        svc   0                      // volani Linuxoveho kernelu
 
        mov   x8, #sys_exit          // cislo sycallu pro funkci "exit"
        mov   x0, #0                 // exit code = 0
        svc   0                      // volani Linuxoveho kernelu
</pre>

<p>Překlad provedeme nám již známým způsobem (zde se jednotlivé architektury od sebe prakticky neodlišují):</p>

<pre>
as loop1-aarch64-v1.s -o loop1-aarch64-v1.o
ld -s loop1-aarch64-v1.o
</pre>

<p>Zpětný překlad lze získat klasickým &bdquo;disassemblingem&ldquo;:</p>

<pre>
objdump -f -d -t -h a.out
</pre>

<p>Výstup z&nbsp;disassembleru bude vypadat následovně:</p>

<pre>
a.out:     file format elf64-littleaarch64
architecture: aarch64, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x00000000004000b0

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000048  00000000004000b0  00000000004000b0  000000b0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000028  00000000004100f8  00000000004100f8  000000f8  2**3
                  ALLOC
SYMBOL TABLE:
no symbols



Disassembly of section .text:

00000000004000b0 &lt;.text&gt;:
  4000b0:       58000201        ldr     x1, 0x4000f0
  4000b4:       d2800502        mov     x2, #0x28                       // #40
  4000b8:       52800543        mov     w3, #0x2a                       // #42
  4000bc:       39000023        strb    w3, [x1]
  4000c0:       91000421        add     x1, x1, #0x1
  4000c4:       d1000442        sub     x2, x2, #0x1
  4000c8:       f100005f        cmp     x2, #0x0
  4000cc:       54ffff81        b.ne    0x4000bc
  4000d0:       d2800808        mov     x8, #0x40                       // #64
  4000d4:       d2800020        mov     x0, #0x1                        // #1
  4000d8:       580000c1        ldr     x1, 0x4000f0
  4000dc:       d2800502        mov     x2, #0x28                       // #40
  4000e0:       d4000001        svc     #0x0
  4000e4:       d2800ba8        mov     x8, #0x5d                       // #93
  4000e8:       d2800000        mov     x0, #0x0                        // #0
  4000ec:       d4000001        svc     #0x0
  4000f0:       004100f8        .inst   0x004100f8 ; undefined
  4000f4:       00000000        .inst   0x00000000 ; undefined
</pre>

<p>Povšimněte si, že se ve zpětném překladu používá &bdquo;ARMovský&ldquo; zápis instrukce podmíněného skoku: <strong>B.NE</strong> namísto alternativního zápisu <strong>BNE</strong>, který jsme použili ve zdrojovém kódu.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Porovnání verze pro ARM32 s&nbsp;verzí pro AArch64</h2>

<p>Při porovnání dvou variant tohoto příkladu (ARM32 versus AArch64) vidíme, že zdrojové kódy jsou prakticky totožné a liší se od sebe pouze použitou syntaxí (odlišný zápis poznámek), jmény registrů (ve druhé verzi jsou použity 64bitové registry), a explicitním použitím 32bitového registru pro uložení bajtu (kódu znaku) do paměti:</p>

<a href="https://mojefedora.cz/wp-content/uploads/2016/12/11_arm32_aarch64_v1.png"><img class="alignnone size-thumbnail wp-image-8108" src="https://mojefedora.cz/wp-content/uploads/2016/12/11_arm32_aarch64_v1-411x254.png" alt="" width="411" height="254" /></a>

<p>Poznámka: povšimněte si rozdílných čísel syscallů, což je téma, kterému jsme se věnovali minule.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Počítaná programová smyčka &ndash; druhá varianta</h2>

<p>Alternativní způsob zápisu smyčky spočívá v&nbsp;odstranění explicitního testování nulové hodnoty počitadla instrukcí <strong>CMP</strong>. Můžeme totiž využít toho, že se příznak <strong>Z (zero)</strong> může nastavit automaticky již při dekrementaci hodnoty počitadla. Na procesorech ARM je v&nbsp;tomto případě nutné namísto instrukce <strong>SUB</strong> použít instrukci <strong>SUBS</strong>, kde poslední znak &bdquo;S&ldquo; znamená &bdquo;set (flags)&ldquo;. Celá programová smyčka se nám zkrátí o jednu instrukci, což může znamenat poměrně znatelné urychlení (samozřejmě nikoli v&nbsp;našem jednoduchém příkladu, ale například při výpočtech nad velkými poli se tato optimalizace již může projevit):</p>

<pre>
loop:
        strb  w3, [x1]               // zapis znaku do bufferu
        add   x1, x1, #1             // uprava ukazatele do bufferu
        subs  x2, x2, #1             // zmenseni pocitadla a soucasne nastaveni priznaku
        bne   loop                   // pokud jsme se nedostali k nule, skok na zacatek smycky
</pre>

<p>Následuje úplný zdrojový kód druhého demonstračního příkladu:</p>

<pre>
# asmsyntax=as
 
# Testovaci program naprogramovany v assembleru GNU as
# - pocitana programova smycka
# - uprava pro mikroprocesory s architekturou AArch64
#
# Autor: Pavel Tisnovsky
 
 
 
# Linux kernel system call table
sys_exit   = 93
sys_write  = 64

# List of syscalls for AArch64:
# https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h
 
# Dalsi konstanty pouzite v programu - standardni streamy
std_input  = 0
std_output = 1

# pocet opakovani znaku
rep_count  = 40
 
 
 
#-----------------------------------------------------------------------------
.section .data
 
 
 
#-----------------------------------------------------------------------------
.section .bss
        .lcomm buffer, rep_count     // rezervace bufferu pro vystup
 
 
 
#-----------------------------------------------------------------------------
.section .text
        .global _start               // tento symbol ma byt dostupny i linkeru
 
_start:
        ldr   x1, =buffer            // zapis se bude provadet do tohoto bufferu
        mov   x2, #rep_count         // pocet opakovani znaku
        mov   w3, #'*'               // zapisovany znak
loop:
        strb  w3, [x1]               // zapis znaku do bufferu
        add   x1, x1, #1             // uprava ukazatele do bufferu
        subs  x2, x2, #1             // zmenseni pocitadla a soucasne nastaveni priznaku
        bne   loop                   // pokud jsme se nedostali k nule, skok na zacatek smycky
 
        mov   x8, #sys_write         // cislo syscallu pro funkci "write"
        mov   x0, #std_output        // standardni vystup
        ldr   x1, =buffer            // adresa retezce, ktery se ma vytisknout
        mov   x2, #rep_count         // pocet znaku, ktere se maji vytisknout
        svc   0                      // volani Linuxoveho kernelu
 
        mov   x8, #sys_exit          // cislo sycallu pro funkci "exit"
        mov   x0, #0                 // exit code = 0
        svc   0                      // volani Linuxoveho kernelu
</pre>

<p>Výsledek zpětného překladu (disassemblingu) je následující:</p>

<pre>

a.out:     file format elf64-littleaarch64
architecture: aarch64, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x00000000004000b0

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000048  00000000004000b0  00000000004000b0  000000b0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000028  00000000004100f8  00000000004100f8  000000f8  2**3
                  ALLOC
SYMBOL TABLE:
no symbols



Disassembly of section .text:

00000000004000b0 &lt;.text&gt;:
  4000b0:       58000201        ldr     x1, 0x4000f0
  4000b4:       d2800502        mov     x2, #0x28                       // #40
  4000b8:       52800543        mov     w3, #0x2a                       // #42
  4000bc:       39000023        strb    w3, [x1]
  4000c0:       91000421        add     x1, x1, #0x1
  4000c4:       f1000442        subs    x2, x2, #0x1
  4000c8:       54ffffa1        b.ne    0x4000bc
  4000cc:       d2800808        mov     x8, #0x40                       // #64
  4000d0:       d2800020        mov     x0, #0x1                        // #1
  4000d4:       580000e1        ldr     x1, 0x4000f0
  4000d8:       d2800502        mov     x2, #0x28                       // #40
  4000dc:       d4000001        svc     #0x0
  4000e0:       d2800ba8        mov     x8, #0x5d                       // #93
  4000e4:       d2800000        mov     x0, #0x0                        // #0
  4000e8:       d4000001        svc     #0x0
  4000ec:       00000000        .inst   0x00000000 ; undefined
  4000f0:       004100f8        .inst   0x004100f8 ; undefined
  4000f4:       00000000        .inst   0x00000000 ; undefined
</pre>

<p>Vidíme, že programová smyčka je skutečně a jednu instrukci kratší.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Porovnání verze pro ARM32 s&nbsp;verzí pro AArch64</h2>

<p>Opět si ukažme, do jaké míry se odlišuje zápis programu určený pro 32bitovou architekturu ARM32 se zápisem toho samého programu určeného pro AArch64:</p>

<a href="https://mojefedora.cz/wp-content/uploads/2016/12/11_arm32_aarch64_v2.png"><img class="alignnone size-thumbnail wp-image-8109" src="https://mojefedora.cz/wp-content/uploads/2016/12/11_arm32_aarch64_v2-410x254.png" alt="" width="410" height="254" /></a>



<p><a name="k08"></a></p>
<h2 id="k08">8. Test na ukončení smyčky na začátku každé iterace</h2>

<p>Další úprava programové smyčky spočívá v&nbsp;testu ukončení iterací na jejím začátku. To je opět téma, kterému jsme se již věnovali, takže si pouze ukažme, jakým způsobem je možné tuto programovou smyčku implementovat na architektuře AArch64. Samotná smyčka končí nepodmíněným skokem na její začátek; instrukce nepodmíněného skoku se jmenuje <strong>B</strong> (&bdquo;branch&ldquo;):</p>

<pre>
loop:
        sub   x2, x2, #1             // zmenseni pocitadla
        cmp   x2, #0                 // otestovani, zda jsme jiz nedosahli nuly
        beq   konec                  // pokud jsme se dostali k nule, konec smycky
        strb  w3, [x1]               // zapis znaku do bufferu
        add   x1, x1, #1             // uprava ukazatele do bufferu
        b     loop                   // nepodmineny skok na zacatek smycky
konec:
</pre>

<p>Samozřejmě je opět možné vynechat instrukci <strong>CMP</strong> a nastavit příznak <strong>zero</strong> přímo při dekrementaci počitadla:</p>

<pre>
loop:
        subs  x2, x2, #1             // zmenseni pocitadla a nastaveni priznaku
        beq   konec                  // pokud jsme se dostali k nule, konec smycky
        strb  w3, [x1]               // zapis znaku do bufferu
        add   x1, x1, #1             // uprava ukazatele do bufferu
        b     loop                   // nepodmineny skok na zacatek smycky
konec:
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. První varianta smyčky s&nbsp;testem na začátku</h2>

<p>Pro úplnost si ukažme celý zdrojový kód s&nbsp;první variantou počítané programové smyčky s&nbsp;testem provedeným na začátku každé iterace:</p>

<pre>
# asmsyntax=as
 
# Testovaci program naprogramovany v assembleru GNU as
# - pocitana programova smycka s testem na zacatku
# - uprava pro mikroprocesory s architekturou AArch64
#
# Autor: Pavel Tisnovsky
 
 
 
# Linux kernel system call table
sys_exit   = 93
sys_write  = 64

# List of syscalls for AArch64:
# https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h
 
# Dalsi konstanty pouzite v programu - standardni streamy
std_input  = 0
std_output = 1

# pocet opakovani znaku
rep_count  = 40
 
 
 
#-----------------------------------------------------------------------------
.section .data
 
 
 
#-----------------------------------------------------------------------------
.section .bss
        .lcomm buffer, rep_count     // rezervace bufferu pro vystup
 
 
 
#-----------------------------------------------------------------------------
.section .text
        .global _start               // tento symbol ma byt dostupny i linkeru
 
_start:
        ldr   x1, =buffer            // zapis se bude provadet do tohoto bufferu
        mov   x2, #rep_count+1       // pocet opakovani znaku
        mov   w3, #'*'               // zapisovany znak
loop:
        sub   x2, x2, #1             // zmenseni pocitadla
        cmp   x2, #0                 // otestovani, zda jsme jiz nedosahli nuly
        beq   konec                  // pokud jsme se dostali k nule, konec smycky
        strb  w3, [x1]               // zapis znaku do bufferu
        add   x1, x1, #1             // uprava ukazatele do bufferu
        b     loop                   // nepodmineny skok na zacatek smycky
konec:
 
        mov   x8, #sys_write         // cislo syscallu pro funkci "write"
        mov   x0, #std_output        // standardni vystup
        ldr   x1, =buffer            // adresa retezce, ktery se ma vytisknout
        mov   x2, #rep_count         // pocet znaku, ktere se maji vytisknout
        svc   0                      // volani Linuxoveho kernelu
 
        mov   x8, #sys_exit          // cislo sycallu pro funkci "exit"
        mov   x0, #0                 // exit code = 0
        svc   0                      // volani Linuxoveho kernelu
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Porovnání s&nbsp;ARM32</h2>

<p>Podobně, jako tomu bylo v&nbsp;předchozích demonstračních příkladech, i u počítané smyčky s&nbsp;testem na začátku si ukážeme porovnání se zdrojovým kódem určeným pro 32bitové mikroprocesory s&nbsp;původní RISCovou instrukční sadou ARM32. Vidíme, že rozdíly jsou nepatrné, pouze se použijí 64bitové registry (kromě registru obsahujícího kód zapisovaného znaku, což je dáno nutností použití instrukce <strong>strb</strong>) a syntaxe je čitelnější (odlišné znaky pro poznámky, prefixy konstant atd.):</p>

<a href="https://mojefedora.cz/wp-content/uploads/2016/12/12_arm32_aarch64_v1.png"><img class="alignnone size-thumbnail wp-image-8110" src="https://mojefedora.cz/wp-content/uploads/2016/12/12_arm32_aarch64_v1-436x254.png" alt="" width="436" height="254" /></a>



<p><a name="k11"></a></p>
<h2 id="k11">11. Druhá varianta smyčky s&nbsp;testem na začátku</h2>

<p>Druhá varianta počítané programové smyčky s&nbsp;testem na začátku vypadá po přepisu do assembleru pro architekturu AArch64 následovně. Povšimněte si, že programová smyčka začíná dvojicí instrukcí <strong>subs+beq</strong>:</p>

<pre>
# asmsyntax=as
 
# Testovaci program naprogramovany v assembleru GNU as
# - pocitana programova smycka s testem na zacatku
# - uprava pro mikroprocesory s architekturou AArch64
#
# Autor: Pavel Tisnovsky
 
 
 
# Linux kernel system call table
sys_exit   = 93
sys_write  = 64

# List of syscalls for AArch64:
# https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h
 
# Dalsi konstanty pouzite v programu - standardni streamy
std_input  = 0
std_output = 1

# pocet opakovani znaku
rep_count  = 40
 
 
 
#-----------------------------------------------------------------------------
.section .data
 
 
 
#-----------------------------------------------------------------------------
.section .bss
        .lcomm buffer, rep_count     // rezervace bufferu pro vystup
 
 
 
#-----------------------------------------------------------------------------
.section .text
        .global _start               // tento symbol ma byt dostupny i linkeru
 
_start:
        ldr   x1, =buffer            // zapis se bude provadet do tohoto bufferu
        mov   x2, #rep_count+1       // pocet opakovani znaku
        mov   w3, #'*'               // zapisovany znak
loop:
        subs  x2, x2, #1             // zmenseni pocitadla a nastaveni priznaku
        beq   konec                  // pokud jsme se dostali k nule, konec smycky
        strb  w3, [x1]               // zapis znaku do bufferu
        add   x1, x1, #1             // uprava ukazatele do bufferu
        b     loop                   // nepodmineny skok na zacatek smycky
konec:
 
        mov   x8, #sys_write         // cislo syscallu pro funkci "write"
        mov   x0, #std_output        // standardni vystup
        ldr   x1, =buffer            // adresa retezce, ktery se ma vytisknout
        mov   x2, #rep_count         // pocet znaku, ktere se maji vytisknout
        svc   0                      // volani Linuxoveho kernelu
 
        mov   x8, #sys_exit          // cislo sycallu pro funkci "exit"
        mov   x0, #0                 // exit code = 0
        svc   0                      // volani Linuxoveho kernelu
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Porovnání s&nbsp;ARM32</h2>

<p>Opět si, dnes již naposledy, porovnejme variantu téhož programu, poprvé vytvořeného pro 32bitové procesory s&nbsp;instrukční sadou ARM32, podruhé pro 64bitové procesory AArch64:</p>

<a href="https://mojefedora.cz/wp-content/uploads/2016/12/12_arm32_aarch64_v2.png"><img class="alignnone size-thumbnail wp-image-8111" src="https://mojefedora.cz/wp-content/uploads/2016/12/12_arm32_aarch64_v2-416x254.png" alt="" width="416" height="254" /></a>



<p><a name="k13"></a></p>
<h2 id="k13">13. Instrukce <strong>CBZ</strong> a <strong>CBNZ</strong></h2>

<p>Instrukční sada AArch64 obsahuje i některé instrukce, které byly úspěšně otestovány v&nbsp;instrukčních sadách Thumb a Thumb-2. Do této oblasti spadají i nové typy podmíněných skoků. Ty se totiž v&nbsp;mnoha případech ukazují být kritickou částí kódu, protože zejména podmíněné skoky mohou přerušit jinak plynulý tok zpracovávaných instrukcí, takže se z&nbsp;ideálního stavu, kdy RISCové jádro díky existenci pipeline dokončí v&nbsp;každém cyklu jednu instrukci (v&nbsp;případě superskalárních čipů Cortex-A i více instrukcí) můžeme dostat do stavu, kdy podmíněný skok způsobí nutnost přerušit již zpracovávané instrukce a začít znovu (samozřejmě s&nbsp;latencí).</p>

<p>Při analýze reálných aplikací si tvůrci instrukční sady Thumb-2 všimli si, že se v&nbsp;programech velmi často vyskytuje sekvence instrukcí, které nejdřív porovnají obsah vybraného pracovního registru s&nbsp;nulou a posléze provedou podmíněný skok na základě toho, zda je onen pracovní registr skutečně nulový nebo naopak nenulový. Poměrně velké frekvenci této sekvence instrukcí se nelze ani divit, protože podobným způsobem mohou být implementovány například testy na hodnotu NULL, počítané smyčky, smyčky typu do-while v&nbsp;nichž je pravdivostní hodnota vyjádřena celým číslem, práce s&nbsp;ASCIIZ řetězci atd. Aby bylo možné zmenšit velikost binárního kódu programu a současně ho i urychlit, byly do instrukční sady Thumb-2 přidány dvě nové instrukce, které nejprve provedou porovnání pracovního registru s&nbsp;nulou a poté provedou skok, pokud je registr nulový či naopak není nulový. Součástí instrukčního slova je přitom i krátký offset umožňující provést skok do vzdálenosti PC+4 až PC+130.</p>

<p>První z&nbsp;těchto instrukcí provede skok, pokud je vybraný pracovní registr nulový:</p>

<pre>
CBZ Rn, offset   ; compare and branch if zero
</pre>

<p>Tato instrukce je ekvivalentní delší sekvenci:</p>

<pre>
CMP Rn, #0
BEQ label
</pre>

<p>Druhá instrukce provádí skok v přesně opačném případě, tj.&nbsp;tehdy, když má registr nenulovou hodnotu:</p>

<pre>
CBNZ Rn, offset   ; compare and branch if non zero
</pre>

<p>Ekvivalentní zápis:</p>

<pre>
CMP Rn, #0
BNE label
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Úprava prvního demonstračního příkladu použitím instrukce <strong>CBNZ</strong></h2>

<p>Vzhledem k&nbsp;tomu, že se instrukce <strong>CBZ</strong> a <strong>CBNZ</strong> mohou použít i u 64bitové architektury AArch64, upravíme si první demonstrační příklad takovým způsobem, aby se v&nbsp;něm tyto instrukce využily. To znamená, že se namísto sekvence instrukcí:</p>

<pre>
        mov   x2, #rep_count         // pocet opakovani programove smycky
loop:
        ...
        ...
        ...
        sub   x2, x2, #1             // zmenseni pocitadla
        cmp   x2, #0                 // otestovani, zda jsme jiz nedosahli nuly
        bne   loop                   // pokud jsme se nedostali k nule, skok na zacatek smycky
</pre>

<p>Použije nová sekvence:</p>

<pre>
        mov   x2, #rep_count         // pocet opakovani programove smycky
loop:
        ...
        ...
        ...
        sub   x2, x2, #1             // zmenseni pocitadla a soucasne nastaveni priznaku
        cbnz  x2, loop               // pokud jsme se nedostali k nule, skok na zacatek smycky
</pre>

<p>Vidíme, že se nám podařilo smyčku zkrátit o jednu instrukci, takže jsme se vlastně dostali do stejné situace, jako při použití dvojice <strong>subs</strong> + podmíněný skok (jinými slovy &ndash; zde nám instrukce <strong>CBNZ</strong> vlastně příliš nepomohla):</p>

<pre>
        mov   x2, #rep_count         // pocet opakovani programove smycky
loop:
        ...
        ...
        ...
        subs  x2, x2, #1             // zmenseni pocitadla a soucasne nastaveni priznaku
        bne   loop                   // pokud jsme se nedostali k nule, skok na zacatek smycky
</pre>

<p>Podívejme se nyní na způsob zařazení instrukce <strong>CBNZ</strong> do celého programu, který po svém spuštění vygeneruje řetězec se čtyřiceti hvězdičkami, který následně vytiskne na standardní výstup:</p>

<pre>
# asmsyntax=as
 
# Testovaci program naprogramovany v assembleru GNU as
# - pocitana programova smycka realizovana instrukci CBNZ
# - uprava pro mikroprocesory s architekturou AArch64
#
# Autor: Pavel Tisnovsky
 
 
 
# Linux kernel system call table
sys_exit   = 93
sys_write  = 64

# List of syscalls for AArch64:
# https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h
 
# Dalsi konstanty pouzite v programu - standardni streamy
std_input  = 0
std_output = 1

# pocet opakovani znaku
rep_count  = 40
 
 
 
#-----------------------------------------------------------------------------
.section .data
 
 
 
#-----------------------------------------------------------------------------
.section .bss
        .lcomm buffer, rep_count     // rezervace bufferu pro vystup
 
 
 
#-----------------------------------------------------------------------------
.section .text
        .global _start               // tento symbol ma byt dostupny i linkeru
 
_start:
        ldr   x1, =buffer            // zapis se bude provadet do tohoto bufferu
        mov   x2, #rep_count         // pocet opakovani znaku
        mov   w3, #'*'               // zapisovany znak
loop:
        strb  w3, [x1]               // zapis znaku do bufferu
        add   x1, x1, #1             // uprava ukazatele do bufferu
        sub   x2, x2, #1             // zmenseni pocitadla a soucasne nastaveni priznaku
        cbnz  x2, loop               // pokud jsme se nedostali k nule, skok na zacatek smycky
 
        mov   x8, #sys_write         // cislo syscallu pro funkci "write"
        mov   x0, #std_output        // standardni vystup
        ldr   x1, =buffer            // adresa retezce, ktery se ma vytisknout
        mov   x2, #rep_count         // pocet znaku, ktere se maji vytisknout
        svc   0                      // volani Linuxoveho kernelu
 
        mov   x8, #sys_exit          // cislo sycallu pro funkci "exit"
        mov   x0, #0                 // exit code = 0
        svc   0                      // volani Linuxoveho kernelu
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Odkazy na Internetu</h2>

<ol>

<li>Cortex-A35<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php</a>
</li>

<li>Cortex-A53<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php</a>
</li>

<li>Cortex-A57<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php</a>
</li>

<li>Cortex-A72<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php</a>
</li>

<li>Cortex-A73<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php</a>
</li>

<li>System cally pro AArch64 na Linuxu<br />
<a href="https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h">https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</a>
</li>

<li>Architectures/AArch64 (FedoraProject.org)<br />
<a href="https://fedoraproject.org/wiki/Architectures/AArch64">https://fedoraproject.org/wiki/Architectures/AArch64</a>
</li>

<li>SIG pro AArch64 (CentOS)<br />
<a href="https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64">https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64</a>
</li>

<li>The ARMv8 instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>A64 Instruction Set<br />
<a href="https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set">https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set</a>
</li>

<li>Switching between the instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>The A64 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>Introduction to ARMv8 64-bit Architecture<br />
<a href="https://quequero.org/2014/04/introduction-to-arm-architecture/">https://quequero.org/2014/04/introduction-to-arm-architecture/</a>
</li>

<li>MCU market turns to 32-bits and ARM<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1280803">http://www.eetimes.com/document.asp?doc_id=1280803</a>
</li>

<li>Cortex-M0 Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0.php">http://www.arm.com/products/processors/cortex-m/cortex-m0.php</a>
</li>

<li>Cortex-M0+ Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php">http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php</a>
</li>

<li>ARM Processors in a Mixed Signal World<br />
<a href="http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world">http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_architecture">https://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>ARM Documentation: B, BL, BX, BLX, and BXJ<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0204j/Cihfddaf.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0204j/Cihfddaf.html</a>
</li>

<li>Branch and Call Sequences Explained<br />
<a href="https://community.arm.com/groups/processors/blog/2013/09/25/branch-and-call-sequences-explained">https://community.arm.com/groups/processors/blog/2013/09/25/branch-and-call-sequences-explained</a>
</li>

<li>Improving ARM Code Density and Performance<br />
<a href="New Thumb Extensions to the ARM Architecture Richard Phelan">New Thumb Extensions to the ARM Architecture Richard Phelan</a>
</li>

<li>Aarch64 Register and Instruction Quick Start<br />
<a href="https://wiki.cdot.senecacollege.ca/wiki/Aarch64_Register_and_Instruction_Quick_Start">https://wiki.cdot.senecacollege.ca/wiki/Aarch64_Register_and_Instruction_Quick_Start</a>
</li>

<li>Exploring AArch64 assembler – Chapter 1<br />
<a href="http://thinkingeek.com/2016/10/08/exploring-aarch64-assembler-chapter1/">http://thinkingeek.com/2016/10/08/exploring-aarch64-assembler-chapter1/</a>
</li>

<li>Exploring AArch64 assembler – Chapter 2<br />
<a href="http://thinkingeek.com/2016/10/08/exploring-aarch64-assembler-chapter-2/">http://thinkingeek.com/2016/10/08/exploring-aarch64-assembler-chapter-2/</a>
</li>

<li>The ARM Processor Architecture<br />
<a href="http://www.arm.com/products/processors/technologies/instruction-set-architectures.php">http://www.arm.com/products/processors/technologies/instruction-set-architectures.php</a>
</li>

<li>Thumb-2 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html</a>
</li>

<li>Introduction to ARM thumb<br />
<a href="http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb">http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb</a>
</li>

<li>ARM, Thumb, and ThumbEE instruction sets<br />
<a href="http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm">http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm</a>
</li>

<li>An Introduction to ARM Assembly Language<br />
<a href="http://dev.emcelettronica.com/introduction-to-arm-assembly-language">http://dev.emcelettronica.com/introduction-to-arm-assembly-language</a>
</li>

<li>Processors - ARM<br />
<a href="http://www.arm.com/products/processors/index.php">http://www.arm.com/products/processors/index.php</a>
</li>

<li>The ARM Instruction Set<br />
<a href="http://simplemachines.it/doc/arm_inst.pdf">http://simplemachines.it/doc/arm_inst.pdf</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ARM_architecture">http://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>C Functions Without Arguments<br />
<a href="https://eklitzke.org/c-functions-without-arguments">https://eklitzke.org/c-functions-without-arguments</a>
</li>

<li>GNU Assembler Examples<br />
<a href="http://cs.lmu.edu/~ray/notes/gasexamples/">http://cs.lmu.edu/~ray/notes/gasexamples/</a>
</li>

<li>Simply FPU<br />
<a href="http://www.website.masmforum.com/tutorials/fptute/">http://www.website.masmforum.com/tutorials/fptute/</a>
</li>

<li>Art of Assembly language programming: The 80x87 Floating Point Coprocessors<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html</a>
</li>

<li>Art of Assembly language programming: The FPU Instruction Set<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html</a>
</li>

<li>INTEL 80387 PROGRAMMER'S REFERENCE MANUAL<br />
<a href="http://www.ragestorm.net/downloads/387intel.txt">http://www.ragestorm.net/downloads/387intel.txt</a>
</li>

<li>x86 Instruction Set Reference: FLD<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_100.html">http://x86.renejeschke.de/html/file_module_x86_id_100.html</a>
</li>

<li>x86 Instruction Set Reference: FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_101.html">http://x86.renejeschke.de/html/file_module_x86_id_101.html</a>
</li>

<li>x86 Instruction Set Reference: FLD<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_100.html">http://x86.renejeschke.de/html/file_module_x86_id_100.html</a>
</li>

<li>x86 Instruction Set Reference: FST/FSTP<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_117.html">http://x86.renejeschke.de/html/file_module_x86_id_117.html</a>
</li>

<li>x86 Instruction Set Reference: BTC<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_23.html">http://x86.renejeschke.de/html/file_module_x86_id_23.html</a>
</li>

<li>x86 Instruction Set Reference: BTR<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_24.html">http://x86.renejeschke.de/html/file_module_x86_id_24.html</a>
</li>

<li>x86 Instruction Set Reference: BTS<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_25.html">http://x86.renejeschke.de/html/file_module_x86_id_25.html</a>
</li>

<li>x86 Instruction Set Reference: BSF<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_19.html">http://x86.renejeschke.de/html/file_module_x86_id_19.html</a>
</li>

<li>x86 Instruction Set Reference: BSR<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_20.html">http://x86.renejeschke.de/html/file_module_x86_id_20.html</a>
</li>

<li>x86 Instruction Set Reference: BSWAP<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_21.html">http://x86.renejeschke.de/html/file_module_x86_id_21.html</a>
</li>

<li>x86 Instruction Set Reference: XCHG<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_328.html">http://x86.renejeschke.de/html/file_module_x86_id_328.html</a>
</li>

<li>x86 Instruction Set Reference: SETcc<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_288.html">http://x86.renejeschke.de/html/file_module_x86_id_288.html</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>The GNU Assembler Tutorial<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html">http://tigcc.ticalc.org/doc/gnuasm.html</a>
</li>

<li>The GNU Assembler - macros<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html#SEC109">http://tigcc.ticalc.org/doc/gnuasm.html#SEC109</a>
</li>

<li>ARM subroutines &amp; program stack<br />
<a href="http://www.toves.org/books/armsub/">http://www.toves.org/books/armsub/</a>
</li>

<li>Generating Mixed Source and Assembly List using GCC<br />
<a href="http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/">http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/</a>
</li>

<li>Calling subroutines<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm</a>
</li>

<li>ARM Assembly Language Programming<br />
<a href="http://peter-cockerell.net/aalp/html/frames.html">http://peter-cockerell.net/aalp/html/frames.html</a>
</li>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Intel x86 JUMP quick reference<br />
<a href="http://unixwiz.net/techtips/x86-jumps.html">http://unixwiz.net/techtips/x86-jumps.html</a>
</li>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Assembler pod Linuxem<br />
<a href="http://phoenix.inf.upol.cz/linux/prog/asm.html">http://phoenix.inf.upol.cz/linux/prog/asm.html</a>
</li>

<li>AT&amp;T Syntax versus Intel Syntax<br />
<a href="https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html">https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html</a>
</li>

<li>Linux Assembly website<br />
<a href="http://asm.sourceforge.net/">http://asm.sourceforge.net/</a>
</li>

<li>Using Assembly Language in Linux<br />
<a href="http://asm.sourceforge.net/articles/linasm.html">http://asm.sourceforge.net/articles/linasm.html</a>
</li>

<li>vasm<br />
<a href="http://sun.hasenbraten.de/vasm/">http://sun.hasenbraten.de/vasm/</a>
</li>

<li>vasm &ndash; dokumentace<br />
<a href="http://sun.hasenbraten.de/vasm/release/vasm.html">http://sun.hasenbraten.de/vasm/release/vasm.html</a>
</li>

<li>The Yasm Modular Assembler Project<br />
<a href="http://yasm.tortall.net/">http://yasm.tortall.net/</a>
</li>

<li>680x0:AsmOne<br />
<a href="http://www.amigacoding.com/index.php/680x0:AsmOne">http://www.amigacoding.com/index.php/680x0:AsmOne</a>
</li>

<li>ASM-One Macro Assembler<br />
<a href="http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler">http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler</a>
</li>

<li>ASM-One pages<br />
<a href="http://www.theflamearrows.info/documents/asmone.html">http://www.theflamearrows.info/documents/asmone.html</a>
</li>

<li>Základní informace o ASM-One<br />
<a href="http://www.theflamearrows.info/documents/asminfo.html">http://www.theflamearrows.info/documents/asminfo.html</a>
</li>

<li>Linux Syscall Reference<br />
<a href="http://syscalls.kernelgrok.com/">http://syscalls.kernelgrok.com/</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>IBM System 360/370 Compiler and Historical Documentation<br />
<a href="http://www.edelweb.fr/Simula/">http://www.edelweb.fr/Simula/</a>
</li>

<li>IBM 700/7000 series<br />
<a href="http://en.wikipedia.org/wiki/IBM_700/7000_series">http://en.wikipedia.org/wiki/IBM_700/7000_series</a>
</li>

<li>IBM System/360<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/360">http://en.wikipedia.org/wiki/IBM_System/360</a>
</li>

<li>IBM System/370<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/370">http://en.wikipedia.org/wiki/IBM_System/370</a>
</li>

<li>Mainframe family tree and chronology<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html</a>
</li>

<li>704 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html</a>
</li>

<li>705 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html</a>
</li>

<li>The IBM 704<br />
<a href="http://www.columbia.edu/acis/history/704.html">http://www.columbia.edu/acis/history/704.html</a>
</li>

<li>IBM Mainframe album<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html</a>
</li>

<li>Osmibitové muzeum<br />
<a href="http://osmi.tarbik.com/">http://osmi.tarbik.com/</a>
</li>

<li>Tesla PMI-80<br />
<a href="http://osmi.tarbik.com/cssr/pmi80.html">http://osmi.tarbik.com/cssr/pmi80.html</a>
</li>

<li>PMI-80<br />
<a href="http://en.wikipedia.org/wiki/PMI-80">http://en.wikipedia.org/wiki/PMI-80</a>
</li>

<li>PMI-80<br />
<a href="http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016">http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016</a>
</li>

<li>The 6502 overflow flag explained mathematically <br />
<a href="http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html">http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html</a>
</li>

<li>X86 Opcode and Instruction Reference<br />
<a href="http://ref.x86asm.net/coder32.html">http://ref.x86asm.net/coder32.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

