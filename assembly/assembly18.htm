<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Použití assembleru v Linuxu: volání knihovní funkce printf s proměnným počtem parametrů</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Použití assembleru v Linuxu: volání knihovní funkce printf s proměnným počtem parametrů</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Téma volání knihovních funkcí z&nbsp;assembleru dnes dokončíme. Ukážeme si totiž, jakým způsobem se volá funkce <strong>printf</strong> s&nbsp;proměnným počtem parametrů, což je zejména na architektuře x86-64 řešeno poněkud zvláštním způsobem. Všechny dnes popsané příklady budou implementovány jak pro již zmíněnou architekturu x86-64, tak i pro 32bitové procesory ARM. Právě porovnáním stejných příkladů implementovaných pro různé architektury lze získat povědomí o tom, jak se jednotlivé procesorové architektury od sebe odlišují.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Použití assembleru v&nbsp;Linuxu: volání knihovní funkce <strong>printf</strong> s&nbsp;proměnným počtem parametrů</a></p>
<p><a href="#k02">2. Volání funkcí a předávání parametrů na architektuře x86-64</a></p>
<p><a href="#k03">3. Volání funkcí a předávání parametrů na architektuře ARM32</a></p>
<p><a href="#k04">4. Rekapitulace šestnácté části &ndash; výpis řetězce funkcí <strong>printf</strong></a></p>
<p><a href="#k05">5. Formátovací řetězec a předání dalších parametrů funkci <strong>printf</strong></a></p>
<p><a href="#k06">6. První demonstrační příklad &ndash; tisk znaku a dekadické hodnoty funkcí <strong>printf</strong></a></p>
<p><a href="#k07">7. Tisk ASCII tabulky: předání čtyř parametrů funkci <strong>printf</strong></a></p>
<p><a href="#k08">8. Druhý demonstrační příklad &ndash; kódy znaků z&nbsp;ASCII tabulky</a></p>
<p><a href="#k09">9. Volání funkce <strong>printf</strong> pro výpis hodnoty typu <i>double</i></a></p>
<p><a href="#k10">10. Třetí demonstrační příklad &ndash; výpis hodnoty typu <i>double</i></a></p>
<p><a href="#k11">11. Volání funkce <strong>printf</strong> na architektuře ARM</a></p>
<p><a href="#k12">12. Tisk znaku a dekadické hodnoty funkcí <strong>printf</strong> na architektuře ARM</a></p>
<p><a href="#k13">13. Tisk ASCII znaků na architektuře ARM</a></p>
<p><a href="#k14">14. Výpis hodnoty typu <i>double</i> na architektuře ARM</a></p>
<p><a href="#k15">15. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k16">16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Použití assembleru v&nbsp;Linuxu: volání knihovní funkce <strong>printf</strong> s&nbsp;proměnným počtem parametrů</h2>

<p>V&nbsp;předchozích dvou částech [<a href="https://mojefedora.cz/pouziti-assembleru-v-linuxu-volani-funkci-ze-standardni-knihovny-jazyka-c/">1</a>] [<a href="https://mojefedora.cz/pouziti-assembleru-v-linuxu-konvence-pri-volani-knihovnich-funkci-na-mikroprocesorech-arm/">2</a>] seriálu o použití assembleru v&nbsp;Linuxu jsme se seznámili se způsobem volání funkcí umístěných v&nbsp;externích knihovnách, zejména pak ve standardní céčkové knihovně. Připomeňme si, že se způsob volání funkcí a samozřejmě i způsob předávání parametrů těmto funkcím odlišuje podle toho, jaká procesorová architektura je použita. U některých operačních systémů je navíc použit odlišný způsob volání, nás samozřejmě bude zajímat především Linux. Situaci na architekturách x86-64 a ARM 32 shrnují navazující dvě kapitoly.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Volání funkcí a předávání parametrů na architektuře x86-64</h2>

<p>Na platformě x86-64 se pro předání prvních šesti celočíselných parametrů nebo adres používají registry, a to v&nbsp;tomto pořadí: <strong>RDI</strong>, <strong>RSI</strong>, <strong>RDX</strong>, <strong>RCX</strong>, <strong>R8</strong> a <strong>R9</strong>. Pokud je zapotřebí předat hodnotu s&nbsp;plovoucí řádovou čárkou, použijí se registry <strong>XMM0</strong>, <strong>XMM1</strong>, <strong>XMM2</strong>, <strong>XMM3</strong>, <strong>XMM4</strong>, <strong>XMM5</strong>, <strong>XMM6</strong> a <strong>XMM7</strong>. Pokud má funkce větší množství parametrů, je nutné je předat na zásobníku, ovšem v&nbsp;praxi se většinou s&nbsp;touto potřebou často nesetkáme. Důležité je také vědět, že po návratu z&nbsp;funkce jsou zachovány obsahy jen několika registrů, konkrétně <strong>R12</strong> až <strong>R15</strong> a taktéž <strong>RBX</strong>, <strong>RSP</strong> a <strong>RBP</strong>. Zajímavá je funkce registrů <strong>R10</strong> a <strong>R11</strong>, které sice nejsou použity pro předání parametrů, ovšem jejich obsah současně není zachován (resp.&nbsp;není zaručeno, že je obsah zachován). Proto jsou tyto registry používány pro uložení mezivýsledků s&nbsp;krátkou dobou života.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Volání funkcí a předávání parametrů na architektuře ARM32</h2>

<p>Na platformě 32bitových mikroprocesorů ARM se parametry taktéž předávají přes pracovní registry, samozřejmě za předpokladu, že jich není příliš mnoho (v&nbsp;opačném případě se další parametry předávají přes zásobník). První čtyři parametry se předávají v&nbsp;registrech <strong>R0</strong> až <strong>R3</strong>. Další čtyři registry <strong>R4</strong> až <strong>R8</strong> jsou použity například pro uložení hodnot lokálních proměnných atd. Registry <strong>R12</strong> až <strong>R15</strong> mají různé speciální použití (programový čítač, link registr, ukazatel na vrchol zásobníku...) a význam zbývajících tří registrů <strong>R9</strong> až <strong>R11</strong> se liší na základě použité instrukční sady (ARM32 versus Thumb). Volaná funkce/subrutina musí zachovat obsah těchto registrů: <strong>R4</strong>-<strong>R8</strong>, <strong>R10</strong>, <strong>R11</strong> a <strong>SP</strong>. Norma dále předepisuje, že 64bitové hodnoty se předávají ve dvojici registrů a hodnota 128bitová ve čtyřech registrech (může se jednat o jediný takto předaný parametr).</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Rekapitulace šestnácté části &ndash; výpis řetězce funkcí <strong>printf</strong></h2>

<p><a href="https://mojefedora.cz/pouziti-assembleru-v-linuxu-volani-funkci-ze-standardni-knihovny-jazyka-c/">V&nbsp;šestnácté části</a> tohoto seriálu jsme si ukázali základní způsob volání knihovní funkce <strong>printf</strong>. Tato funkce (ale samozřejmě nejenom ona) je zvláštní tím, že podporuje proměnný počet parametrů, které navíc mohou být různého typu. O vyzvednutí a interpretaci parametrů se funkce <strong>printf</strong> stará sama na základě obsahu formátovacího řetězce (historické překladače navíc vůbec nekontrolovaly, jestli počet a typ parametrů s&nbsp;formátovacím řetězcem souhlasí, nedělají to logicky ani assemblery), ovšem i volající kód musí dodržovat jistá pravidla. O způsobem předávání parametrů jsme se zmínili ve druhé kapitole, ovšem tuto informaci musíme doplnit o vysvětlení významu registru <strong>RAX</strong>:</p>

<ol>
<li>Celočíselné parametry a adresy se postupně předávají v&nbsp;registrech: <strong>RDI</strong>, <strong>RSI</strong>, <strong>RDX</strong>, <strong>RCX</strong>, <strong>R8</strong> a <strong>R9</strong> (dále pak na zásobníku)</li>
<li>Hodnoty single(float) a double se postupně předávají v&nbsp;registrech: <strong>XMM0</strong>, <strong>XMM1</strong>, <strong>XMM2</strong>, <strong>XMM3</strong>, <strong>XMM4</strong>, <strong>XMM5</strong>, <strong>XMM6</strong> a <strong>XMM7</strong> (dále pak opět na zásobníku)</li>
<li>V&nbsp;registru <strong>RAX</strong> (ve skutečnosti však jen v&nbsp;<strong>AL</strong>, tj.&nbsp;ve spodních osmi bitech) je nutné předat počet hodnot typu float či double.</li>
</ol>

<p>Volání funkce <strong>printf</strong>, které se předá pouze formátovací řetězec, bude implementováno takto. Povšimněte si především vynulování registru <strong>AL</strong> před vlastním voláním (sami si můžete vyzkoušet, že aplikace zhavaruje, pokud tuto instrukci zakomentujete):</p>

<pre>
# asmsyntax=as

# Program pro otestovani volani funkci ze standardni knihovny jazyka C
# - volani funkce 'printf'
# - pro zapis je pouzita "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix



#-----------------------------------------------------------------------------
.section .data
hello_world_message:
        .asciz "Hello world!\n"    # zprava, ktera se ma vytisknout na standardni vystup



#-----------------------------------------------------------------------------
.section .text
        .global main               # tento symbol ma byt dostupny i linkeru

main:
        sub  rsp, 8                # zajistit zarovnani RSP na adresu delitelnou 16

                                   # jedinym parametrem je adresa zpravy
        mov  rdi, offset hello_world_message
        xor  al, al                # pocet parametru predanych ve vektorovych registrech
        call printf                # volani funkce 'printf' ze standardni knihovny

        add  rsp, 8                # obnoveni puvodni hodnoty RSP

        xor  eax, eax              # navratova hodnota (exit status)

        ret                        # ukonceni aplikace
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Formátovací řetězec a předání dalších parametrů funkci <strong>printf</strong></h2>

<p>Zkusme si nyní vytvořit složitější příklad, který bude zhruba odpovídat tomuto céčkovému kódu:</p>

<pre>
printf("char=%c code=%d\n", '*', 42);
</pre>

<p>Formátovací řetězec uložený do sekce <strong>data</strong> se samozřejmě změní, aby odpovídal výše zobrazenému céčkovému kódu:</p>

<pre>
.section .data
hello_world_message:
        .asciz "char=%c code=%d\n" # zprava, ktera se ma vytisknout na standardni vystup
</pre>

<p>Změní se i volání funkce <strong>printf</strong>, neboť nyní ji musíme předat tři parametry &ndash; adresu formátovacího řetězce, ASCII kód znaku hvězdička a numerický kód stejného znaku (ve skutečnosti se v&nbsp;obou případech jedná o stejné konstanty). <a href="#k05">Z&nbsp;rekapitulace</a> je zřejmé, že tři parametry se budou postupně předávat v&nbsp;registrech <strong>RDI</strong>, <strong>RSI</strong> a <strong>RDX</strong>. Žádný parametr typu <i>float</i> či <i>double</i> nepředáváme, takže registr <strong>AL</strong> musí být nulový:</p>

<pre>
mov  rdi, offset hello_world_message
mov  rsi, '*'              # druhym parametrem je kod znaku
mov  rdx, 42               # tretim parametrem je cele cislo
xor  al, al                # pocet parametru predanych ve vektorovych registrech
call printf                # volani funkce 'printf' ze standardni knihovny
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. První demonstrační příklad &ndash; tisk znaku a dekadické hodnoty funkcí <strong>printf</strong></h2>

<p>Úplný zdrojový kód demonstračního příkladu, v&nbsp;němž se volá funkce <strong>printf</strong> se třemi parametry, vypadá následovně:</p>

<pre>
# asmsyntax=as

# Program pro otestovani volani funkci ze standardni knihovny jazyka C
# - volani funkce 'printf' s vetsim poctem parametru
# - pro zapis je pouzita "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix



#-----------------------------------------------------------------------------
.section .data
hello_world_message:
        .asciz "char=%c code=%d\n" # zprava, ktera se ma vytisknout na standardni vystup



#-----------------------------------------------------------------------------
.section .text
        .global main               # tento symbol ma byt dostupny i linkeru

main:
        sub  rsp, 8                # zajistit zarovnani RSP na adresu delitelnou 16

                                   # prvnim parametrem je adresa zpravy
        mov  rdi, offset hello_world_message
        mov  rsi, '*'              # druhym parametrem je kod znaku
        mov  rdx, 42               # tretim parametrem je cele cislo
        xor  al, al                # pocet parametru predanych ve vektorovych registrech
        call printf                # volani funkce 'printf' ze standardni knihovny

        add  rsp, 8                # obnoveni puvodni hodnoty RSP

        xor  eax, eax              # navratova hodnota (exit status)

        ret                        # ukonceni aplikace
</pre>

<p>Překlad a slinkování na platformě x86-64 je jednoduché, protože opět použijeme překladač <i>gcc</i>:</p>

<pre>
gcc -g main_64bit.s
</pre>

<p>Po spuštění příkladu by se na standardní výstup měla vytisknout hvězdička i její ASCII kód:</p>

<pre>
<strong>./a.out</strong>
char=* code=42
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Tisk ASCII tabulky: předání čtyř parametrů funkci <strong>printf</strong></h2>

<p>Předchozí příklad můžeme ještě upravit takovým způsobem, aby došlo k&nbsp;vytištění všech tisknutelných ASCII znaků, tj.&nbsp;znaků s&nbsp;kódy od 32 (mezera) až po 126 (tilda). Provedeme dvě úpravy:</p>

<ol>
<li>Kromě dekadické hodnoty znaku se vytiskne i hodnota hexadecimální.</li>
<li>Volání funkce i naplnění jejich parametrů bude provedeno v&nbsp;programové smyčce.</li>
</ol>

<p>První úprava si vyžádá změnu formátovacího řetězce:</p>

<pre>
.section .data
hello_world_message:
        .asciz "char=%c code=%d hex=%02x\n" # zprava, ktera se ma vytisknout na standardni vystup
</pre>

<p>Funkce <strong>printf</strong> se zavolá s&nbsp;kódem znaku uloženým v&nbsp;registru <strong>R12</strong>. Je to totiž jeden z&nbsp;registrů, jejichž obsah nebude volanou funkcí poškozen:</p>

<pre>
mov  rdi, offset hello_world_message
mov  rsi, r12              # druhym parametrem je kod znaku
mov  rdx, r12              # tretim parametrem je cele cislo
mov  rcx, r12              # tretim parametrem je taktez cele cislo
xor  al, al                # pocet parametru predanych ve vektorovych registrech
call printf                # volani funkce 'printf' ze standardni knihovny
</pre>

<p>Nyní nám již zbývá použít registr <strong>R12</strong> jako počitadlo smyčky, což je téma, které již známe z&nbsp;úvodních částí tohoto seriálu:</p>

<pre>
        mov  r12, 32               # pocitadlo je v prvnim registru, jehoz obsah je zachovan
                                   # i po zavolani funkce printf()
loop:
        ...
        ...
        ...

        inc  r12                   # zvyseni hodnoty pocitadla
        cmp  r12, 127              # konec smycky?
        jne  loop                  # ne? takze dalsi iterace
</pre>

<p>Smyčku a volání funkce <strong>printf</strong> sestavíme dohromady a získáme fragment celého programu:</p>

<pre>
        mov  r12, 32               # pocitadlo je v prvnim registru, jehoz obsah je zachovan
                                   # i po zavolani funkce printf()
loop:
                                   # prvnim parametrem je adresa zpravy
        mov  rdi, offset hello_world_message
        mov  rsi, r12              # druhym parametrem je kod znaku
        mov  rdx, r12              # tretim parametrem je cele cislo
        mov  rcx, r12              # tretim parametrem je taktez cele cislo
        xor  al, al                # pocet parametru predanych ve vektorovych registrech
        call printf                # volani funkce 'printf' ze standardni knihovny

        inc  r12                   # zvyseni hodnoty pocitadla
        cmp  r12, 127              # konec smycky?
        jne  loop                  # ne, dalsi iterace
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Druhý demonstrační příklad &ndash; kódy znaků z&nbsp;ASCII tabulky</h2>

<p>Úplný zdrojový kód dnešního druhého demonstračního příkladu upraveného pro architekturu x86-64 vypadá následovně:</p>

<pre>
# asmsyntax=as

# Program pro otestovani volani funkci ze standardni knihovny jazyka C
# - volani funkce 'printf' s vetsim poctem parametru
# - pro zapis je pouzita "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix



#-----------------------------------------------------------------------------
.section .data
hello_world_message:
        .asciz "char=%c code=%d hex=%02x\n" # zprava, ktera se ma vytisknout na standardni vystup



#-----------------------------------------------------------------------------
.section .text
        .global main               # tento symbol ma byt dostupny i linkeru

main:
        sub  rsp, 8                # zajistit zarovnani RSP na adresu delitelnou 16

        mov  r12, 32               # pocitadlo je v prvnim registru, jehoz obsah je zachovan
                                   # i po zavolani funkce printf()
loop:
                                   # prvnim parametrem je adresa zpravy
        mov  rdi, offset hello_world_message
        mov  rsi, r12              # druhym parametrem je kod znaku
        mov  rdx, r12              # tretim parametrem je cele cislo
        mov  rcx, r12              # tretim parametrem je taktez cele cislo
        xor  al, al                # pocet parametru predanych ve vektorovych registrech
        call printf                # volani funkce 'printf' ze standardni knihovny

        inc  r12                   # zvyseni hodnoty pocitadla
        cmp  r12, 127              # konec smycky?
        jne  loop                  # ne, dalsi iterace

        add  rsp, 8                # obnoveni puvodni hodnoty RSP

        xor  eax, eax              # navratova hodnota (exit status)

        ret                        # ukonceni aplikace
</pre>

<p>Po překladu a spuštění tohoto příkladu získáme tento výstup:</p>

<pre>
char=  code=32 hex=20
char=! code=33 hex=21
char=" code=34 hex=22
char=# code=35 hex=23
char=$ code=36 hex=24
char=% code=37 hex=25
char=&amp; code=38 hex=26
char=' code=39 hex=27
char=( code=40 hex=28
char=) code=41 hex=29
char=* code=42 hex=2a
char=+ code=43 hex=2b
char=, code=44 hex=2c
char=- code=45 hex=2d
char=. code=46 hex=2e
char=/ code=47 hex=2f
char=0 code=48 hex=30
char=1 code=49 hex=31
char=2 code=50 hex=32
char=3 code=51 hex=33
char=4 code=52 hex=34
char=5 code=53 hex=35
char=6 code=54 hex=36
char=7 code=55 hex=37
char=8 code=56 hex=38
char=9 code=57 hex=39
char=: code=58 hex=3a
char=; code=59 hex=3b
char=&lt; code=60 hex=3c
char== code=61 hex=3d
char=&gt; code=62 hex=3e
char=? code=63 hex=3f
char=@ code=64 hex=40
char=A code=65 hex=41
char=B code=66 hex=42
char=C code=67 hex=43
char=D code=68 hex=44
char=E code=69 hex=45
char=F code=70 hex=46
char=G code=71 hex=47
char=H code=72 hex=48
char=I code=73 hex=49
char=J code=74 hex=4a
char=K code=75 hex=4b
char=L code=76 hex=4c
char=M code=77 hex=4d
char=N code=78 hex=4e
char=O code=79 hex=4f
char=P code=80 hex=50
char=Q code=81 hex=51
char=R code=82 hex=52
char=S code=83 hex=53
char=T code=84 hex=54
char=U code=85 hex=55
char=V code=86 hex=56
char=W code=87 hex=57
char=X code=88 hex=58
char=Y code=89 hex=59
char=Z code=90 hex=5a
char=[ code=91 hex=5b
char=\ code=92 hex=5c
char=] code=93 hex=5d
char=^ code=94 hex=5e
char=_ code=95 hex=5f
char=` code=96 hex=60
char=a code=97 hex=61
char=b code=98 hex=62
char=c code=99 hex=63
char=d code=100 hex=64
char=e code=101 hex=65
char=f code=102 hex=66
char=g code=103 hex=67
char=h code=104 hex=68
char=i code=105 hex=69
char=j code=106 hex=6a
char=k code=107 hex=6b
char=l code=108 hex=6c
char=m code=109 hex=6d
char=n code=110 hex=6e
char=o code=111 hex=6f
char=p code=112 hex=70
char=q code=113 hex=71
char=r code=114 hex=72
char=s code=115 hex=73
char=t code=116 hex=74
char=u code=117 hex=75
char=v code=118 hex=76
char=w code=119 hex=77
char=x code=120 hex=78
char=y code=121 hex=79
char=z code=122 hex=7a
char={ code=123 hex=7b
char=| code=124 hex=7c
char=} code=125 hex=7d
char=~ code=126 hex=7e
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Volání funkce <strong>printf</strong> pro výpis hodnoty typu <i>double</i></h2>

<p>Další úkol, který dnes vyřešíme, spočívá ve vytištění hodnoty typu <i>double</i>, tj.&nbsp;hodnoty reprezentované v&nbsp;systému plovoucí řádové čárky. Konkrétně se bude jednat o číslo &pi;, které již dokážeme získat, a to konkrétně instrukcí <strong>fldpi</strong> matematického koprocesoru (&pi; se uloží na zásobník matematického koprocesoru). Nejdříve si zarezervujeme místo v&nbsp;paměti, kam se tato konstanta uloží. Tato paměťová oblast představovaná sekcí .bss je vytvořena až po spuštění aplikace (tedy v&nbsp;runtime). Rezervovat je nutné osm bajtů:</p>

<pre>
.section .bss


.lcomm number, 8                     # na toto misto se bude ukladat konstanta typu double
</pre>

<p>Do této oblasti se uloží binární reprezentace konstanty &pi;:</p>

<pre>
fldpi
fstp  qword ptr number
</pre>

<p>Následně připravíme parametry pro funkci <strong>printf</strong>. Prvním parametrem je stále formátovací řetězec, takže se pro jeho předání použije celočíselný registr <strong>RDI</strong>. Ovšem druhý parametr je typu <i>double</i> a musí se tedy předat v&nbsp;&bdquo;multimediálním&ldquo; registru <strong>XMM0</strong>! Příprava obou parametrů vypadá takto:</p>

<pre>
mov   rdi, offset hello_world_message
movsd xmm0, qword ptr number
</pre>

<p>Právě nyní nastal okamžik pro přípravu registru <strong>AL</strong> (či celého registru <strong>EAX</strong>), který musí obsahovat počet parametrů předaných v&nbsp;registrech <strong>XMM?</strong>:</p>

<pre>
mov  eax, 1                # pocet parametru predanych ve vektorovych registrech
</pre>

<p>Nyní je již možné funkci <strong>printf</strong> bez problémů zavolat:</p>

<pre>
call printf                # volani funkce 'printf' ze standardni knihovny
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Třetí demonstrační příklad &ndash; výpis hodnoty typu <i>double</i></h2>

<p>Úplný zdrojový kód dnešního třetího demonstračního příkladu upraveného pro architekturu x86-64 vypadá následovně:</p>

<pre>
# asmsyntax=as

# Program pro otestovani volani funkci ze standardni knihovny jazyka C
# - volani funkce 'printf' pro vypis hodnoty typu double
# - pro zapis je pouzita "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix



#-----------------------------------------------------------------------------
.section .data
hello_world_message:
        .asciz "float = %f\n"      # zprava, ktera se ma vytisknout na standardni vystup



#-----------------------------------------------------------------------------
.section .bss

.lcomm number, 8                     # na toto misto se bude ukladat konstanta typu double




#-----------------------------------------------------------------------------
.section .text
        .global main               # tento symbol ma byt dostupny i linkeru

main:
        sub  rsp, 8                # zajistit zarovnani RSP na adresu delitelnou 16

                                   # prvnim parametrem je adresa zpravy
        mov  rdi, offset hello_world_message

        fldpi                      # druhym parametrem je double konstanta Pi
        fstp  qword ptr number
        movsd xmm0, qword ptr number

        mov  eax, 1                # pocet parametru predanych ve vektorovych registrech
        call printf                # volani funkce 'printf' ze standardni knihovny

        add  rsp, 8                # obnoveni puvodni hodnoty RSP

        xor  eax, eax              # navratova hodnota (exit status)

        ret                        # ukonceni aplikace
</pre>

<p>Po překladu a spuštění získáme na standardním výstupu následující zprávu:</p>

<pre>
float = 3.141593
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Volání funkce <strong>printf</strong> na architektuře ARM</h2>

<p>Všechny předchozí demonstrační příklady si nyní ukážeme v&nbsp;úpravě určené pro 32bitové mikroprocesory s&nbsp;architekturou ARM. V&nbsp;prvním příkladu se volá funkce <strong>printf</strong> a předává se jí jediný parametr &ndash; ukazatel na řetězec, který se má vytisknout. Základní kostru aplikace známe z&nbsp;předchozího dílu:</p>

<pre>
main:
        stmfd sp!, {lr}                 @ ulozeni zvolenych registru na zasobnik

        ...
        ...
        ...

        mov   r0, #42                   @ navratova hodnota (exit status)
        ldmfd sp!, {pc}                 @ obnova registru, ukonceni aplikace
                                        @ (rizeni se vrati na adresu ulozenou v LR)
</pre>

<p>Volání funkce <strong>printf</strong> je jednoduché, protože parametry se předávají postupně v&nbsp;registrech <strong>R0</strong>, <strong>R1</strong>, <strong>R2</strong> a <strong>R3</strong>. V&nbsp;tomto příkladu se předává jediný parametr v&nbsp;registru <strong>R0</strong> (povšimněte si použití znaku =, který zde nahrazuje slova <i>dword ptr</i>):</p>

<pre>
        ldr   r0, =hello_world_message  @ adresa zpravy, ktera se ma vytisknout
                                        @ (jde o jediny parametr predany funkci printf())
</pre>

<p>Volání knihovních funkcí zajišťuje instrukce <strong>BL</strong> neboli <i>branch and link</i>:</p>

<pre>
        bl    printf                    @ zavolani knihovni funkce printf()
</pre>

<p>Úplný zdrojový kód vypadá následovně:</p>

<pre>
# asmsyntax=as

# Program pro otestovani volani funkci ze standardni knihovny jazyka C
# - volani funkce 'printf'
# - varianta urcena pro klasickou 32bitovou architekturu ARM
#
# Autor: Pavel Tisnovsky



#-----------------------------------------------------------------------------
.section .data
hello_world_message:
        .asciz "Hello world!\n"         @ zprava, ktera se ma vytisknout na standardni vystup



#-----------------------------------------------------------------------------
.section .text
        .global main                    @ tento symbol ma byt dostupny i linkeru

main:
        stmfd sp!, {lr}                 @ ulozeni zvolenych registru na zasobnik

        ldr   r0, =hello_world_message  @ adresa zpravy, ktera se ma vytisknout
                                        @ (jde o jediny parametr predany funkci printf())

        bl    printf                    @ zavolani knihovni funkce printf()

        mov   r0, #42                   @ navratova hodnota (exit status)
        ldmfd sp!, {pc}                 @ obnova registru, ukonceni aplikace
                                        @ (rizeni se vrati na adresu ulozenou v LR)
</pre>

<p>Překlad se provede takto (předpokládám, že se nejedná o cross kompilaci):</p>

<pre>
gcc main_arm.s
</pre>

<p>Funkce main je přeložena do strojového kódu následujícím způsobem (povšimněte si umístění konstanty ihned za kód funkce):</p>

<pre>
000083cc &lt;main&gt;:
    83cc:       e92d4000        stmfd   sp!, {lr}
    83d0:       e59f0008        ldr     r0, [pc, #8]    ; 83e0 &lt;main+0x14&gt;
    83d4:       ebffffc5        bl      82f0 &lt;printf@plt&gt;
    83d8:       e3a0002a        mov     r0, #42 ; 0x2a
    83dc:       e8bd8000        ldmfd   sp!, {pc}
    83e0:       00010584        .word   0x00010584
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Tisk znaku a dekadické hodnoty funkcí <strong>printf</strong> na architektuře ARM</h2>

<p>Příprava pro tisk znaku a dekadické hodnoty vypadá v&nbsp;assembleru procesorů ARM prakticky stejně, jako tomu bylo na architektuře x86-64, pouze nesmíme zapomenout na to, že konstanty je nutné uvozovat znakem #:</p>

<pre>
        ldr   r0, =hello_world_message  @ adresa zpravy, ktera se ma vytisknout
        mov   r1, #'*'                  @ druhym parametrem je kod znaku
        mov   r2, #42                   @ tretim parametrem je cele cislo

        bl    printf                    @ zavolani knihovni funkce printf()
</pre>

<p>Úplný zdrojový kód tohoto demonstračního příkladu vypadá následovně:</p>

<pre>
# asmsyntax=as

# Program pro otestovani volani funkci ze standardni knihovny jazyka C
# - volani funkce 'printf' s vetsim poctem parametru
# - varianta urcena pro klasickou 32bitovou architekturu ARM
#
# Autor: Pavel Tisnovsky



#-----------------------------------------------------------------------------
.section .data
hello_world_message:
        .asciz "char=%c code=%d\n" @ zprava, ktera se ma vytisknout na standardni vystup



#-----------------------------------------------------------------------------
.section .text
        .global main                    @ tento symbol ma byt dostupny i linkeru

main:
        stmfd sp!, {lr}                 @ ulozeni zvolenych registru na zasobnik

        ldr   r0, =hello_world_message  @ adresa zpravy, ktera se ma vytisknout
        mov   r1, #'*'                  @ druhym parametrem je kod znaku
        mov   r2, #42                   @ tretim parametrem je cele cislo

        bl    printf                    @ zavolani knihovni funkce printf()

        mov   r0, #42                   @ navratova hodnota (exit status)
        ldmfd sp!, {pc}                 @ obnova registru, ukonceni aplikace
                                        @ (rizeni se vrati na adresu ulozenou v LR)
</pre>

<p>Funkce main je přeložena do strojového kódu následujícím způsobem:</p>

<pre>
000083cc &lt;main&gt;:
    83cc:       e92d4000        stmfd   sp!, {lr}
    83d0:       e59f0010        ldr     r0, [pc, #16]   ; 83e8 &lt;main+0x1c&gt;
    83d4:       e3a0102a        mov     r1, #42 ; 0x2a
    83d8:       e3a0202a        mov     r2, #42 ; 0x2a
    83dc:       ebffffc3        bl      82f0 &lt;printf@plt&gt;
    83e0:       e3a0002a        mov     r0, #42 ; 0x2a
    83e4:       e8bd8000        ldmfd   sp!, {pc}
    83e8:       0001058c        .word   0x0001058c
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Tisk ASCII znaků na architektuře ARM</h2>

<p>Programová smyčka určená pro tisk ASCII znaků je založena na kódu, který opět známe z&nbsp;předchozích částí tohoto seriálu. Registr <strong>R4</strong> byl zvolen z&nbsp;toho důvodu, že jeho obsah <a href="#k03">není při volání funkce pozměněn</a>:</p>

<pre>
        mov   r4, #32                   @ inicializace pocitadla

loop:
        ...
        ...
        ...

        add   r4, r4, #1                @ zvyseni hodnoty pocitadla
        cmp   r4, #127                  @ porovnani s koncovou hodnotou smycky
        bne   loop                      @ dosahli jsme konce? pokud ne, skok na zacatek smycky
</pre>

<p>Do této smyčky pouze vložíme volání funkce <strong>printf</strong> s&nbsp;tím, že její parametry jsou naplněny právě na základě aktuálního obsahu registru <strong>R4</strong> (počitadla smyčky):</p>

<pre>
        mov   r4, #32                   @ inicializace pocitadla

loop:
        ldr   r0, =ASCII_char_message   @ adresa zpravy, ktera se ma vytisknout
        mov   r1, r4                    @ druhym parametrem je kod znaku
        mov   r2, r4                    @ tretim parametrem je totez cele cislo
        mov   r3, r4                    @ ctvrtym parametrem je totez cele cislo

        bl    printf                    @ zavolani knihovni funkce printf()

        add   r4, r4, #1                @ zvyseni hodnoty pocitadla
        cmp   r4, #127                  @ porovnani s koncovou hodnotou smycky
        bne   loop                      @ dosahli jsme konce? pokud ne, skok na zacatek smycky
</pre>

<p>Úplný zdrojový kód tohoto demonstračního příkladu vypadá následovně:</p>

<pre>
# asmsyntax=as

# Program pro otestovani volani funkci ze standardni knihovny jazyka C
# - volani funkce 'printf' pro zobrazeni casti ASCII tabulky
# - varianta urcena pro klasickou 32bitovou architekturu ARM
#
# Autor: Pavel Tisnovsky



#-----------------------------------------------------------------------------
.section .data
ASCII_char_message:
        .asciz "char=%c code=%d hex=%02x\n" @ zprava, ktera se ma vytisknout na standardni vystup



#-----------------------------------------------------------------------------
.section .text
        .global main                    @ tento symbol ma byt dostupny i linkeru

main:
        stmfd sp!, {lr}                 @ ulozeni zvolenych registru na zasobnik
        mov   r4, #32                   @ inicializace pocitadla

loop:
        ldr   r0, =ASCII_char_message   @ adresa zpravy, ktera se ma vytisknout
        mov   r1, r4                    @ druhym parametrem je kod znaku
        mov   r2, r4                    @ tretim parametrem je totez cele cislo
        mov   r3, r4                    @ ctvrtym parametrem je totez cele cislo

        bl    printf                    @ zavolani knihovni funkce printf()

        add   r4, r4, #1                @ zvyseni hodnoty pocitadla
        cmp   r4, #127                  @ porovnani s koncovou hodnotou smycky
        bne   loop                      @ dosahli jsme konce? pokud ne, skok na zacatek smycky

        mov   r0, #42                   @ navratova hodnota (exit status)
        ldmfd sp!, {pc}                 @ obnova registru, ukonceni aplikace
                                        @ (rizeni se vrati na adresu ulozenou v LR)

</pre>

<p>Funkce main je přeložena do strojového kódu následujícím způsobem:</p>

<pre>
000083d4 &lt;loop&gt;:
    83d4:       e59f0020        ldr     r0, [pc, #32]   ; 83fc &lt;loop+0x28&gt;
    83d8:       e1a01004        mov     r1, r4
    83dc:       e1a02004        mov     r2, r4
    83e0:       e1a03004        mov     r3, r4
    83e4:       ebffffc1        bl      82f0 &lt;printf@plt&gt;
    83e8:       e2844001        add     r4, r4, #1
    83ec:       e354007f        cmp     r4, #127        ; 0x7f
    83f0:       1afffff7        bne     83d4 &lt;loop&gt;
    83f4:       e3a0002a        mov     r0, #42 ; 0x2a
    83f8:       e8bd8000        ldmfd   sp!, {pc}
    83fc:       000105a0        .word   0x000105a0
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Výpis hodnoty typu <i>double</i> na architektuře ARM</h2>

<p>Poslední příklad používá ABI, v&nbsp;němž se i čísla typu <i>float</i> či <i>double</i> předávají v&nbsp;celočíselných registrech. Tento příklad vlastně ani nevyžaduje přítomnost matematického koprocesoru, na druhou stranu je však nutné konstantu typu <i>double</i> zakódovat ručně, popř.&nbsp;lze využít utilitku <a href="https://github.com/tisnik/presentations/blob/master/assembler/fp2hex/fp2hex.c">fp2hex</a>:</p>

<pre>
number:
        .word   0xbff00000              @ prvnich 32 bitu cisla
        .word   0x10010000              @ druhych 32 bitu cisla
</pre>

<p>Naplnění parametrů funkce <strong>printf</strong> s&nbsp;jejím následným zavoláním (povšimněte si, v&nbsp;jakém pořadí se naplňuje 64bitový parametr):</p>

<pre>
ldr   r0, =hello_world_message  @ adresa zpravy, ktera se ma vytisknout
ldr   r1, number+4
ldr   r2, number

bl    printf                    @ zavolani knihovni funkce printf()
</pre>

<p>Opět se podívejme na úplný zdrojový kód tohoto demonstračního příkladu:</p>

<pre>
# asmsyntax=as

# Program pro otestovani volani funkci ze standardni knihovny jazyka C
# - volani funkce 'printf' pro vypis hodnoty typu double
# - varianta urcena pro klasickou 32bitovou architekturu ARM
#
# Autor: Pavel Tisnovsky



#-----------------------------------------------------------------------------
.section .data
hello_world_message:
        .asciz "double = %f\n"          @ zprava, ktera se ma vytisknout na standardni vystup



#-----------------------------------------------------------------------------
.section .text
        .global main                    @ tento symbol ma byt dostupny i linkeru

main:
        stmfd sp!, {lr}                 @ ulozeni zvolenych registru na zasobnik

        ldr   r0, =hello_world_message  @ adresa zpravy, ktera se ma vytisknout
        ldr   r1, number+4
        ldr   r2, number

        bl    printf                    @ zavolani knihovni funkce printf()

        mov   r0, #42                   @ navratova hodnota (exit status)
        ldmfd sp!, {pc}                 @ obnova registru, ukonceni aplikace
                                        @ (rizeni se vrati na adresu ulozenou v LR)
number:
        .word   0xbff00000              @ prvnich 32 bitu cisla
        .word   0x10010000              @ druhych 32 bitu cisla
</pre>

<p>Funkce main je přeložena do strojového kódu následujícím způsobem:</p>

<pre>
000083cc &lt;main&gt;:
    83cc:	e92d4000 	stmfd	sp!, {lr}
    83d0:	e59f0018 	ldr	r0, [pc, #24]	; 83f0 &lt;number+0x8&gt;
    83d4:	e59f1010 	ldr	r1, [pc, #16]	; 83ec &lt;number+0x4&gt;
    83d8:	e59f2008 	ldr	r2, [pc, #8]	; 83e8 &lt;number&gt;
    83dc:	ebffffc3 	bl	82f0 &lt;printf@plt&gt;
    83e0:	e3a0002a 	mov	r0, #42	; 0x2a
    83e4:	e8bd8000 	ldmfd	sp!, {pc}
</pre>

<p>Ihned za kódem funkce main je umístěna trojice 32bitových konstant. První dvě konstanty představují binární obraz čísla -1.0, třetí konstanta pak adresu formátovacího řetězce funkce <strong>printf</strong>:</p>

<pre>
000083e8 &lt;number&gt;:
    83e8:	bff00000 	.word	0xbff00000
    83ec:	10010000 	.word	0x10010000
    83f0:	00010594 	.word	0x00010594
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popisované demonstrační příklady byly, podobně jako ve všech předchozích částech tohoto seriálu, společně s&nbsp;podpůrnými skripty určenými pro jejich překlad či naopak pro disassembling, uloženy do GIT repositáře dostupného na adrese <a href="https://github.com/tisnik/presentations/">https://github.com/tisnik/presentations/</a>. Všechny příklady jsou určeny pro GNU Assembler. Následují tabulky obsahující odkazy na zdrojové kódy příkladů i na již zmíněné podpůrné skripty:</p>

<h3>První demonstrační příklad: tisk znaku a dekadické hodnoty funkcí <strong>printf</strong></h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>main_64bit.s</td><td>hlavní program pro procesory x86-64</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/46_stdc_printf_vararg/main_64bit.s">https://github.com/tisnik/presentations/blob/master/assembler/46_stdc_printf_vararg/main_64bit.s</a></td></tr>
<tr><td>2</td><td>main_arm.s</td><td>hlavní program pro 32bitové procesory ARM</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/46_stdc_printf_vararg/main_arm.s">https://github.com/tisnik/presentations/blob/master/assembler/46_stdc_printf_vararg/main_arm.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>assemble_64bit</td><td>skript pro překlad s&nbsp;využitím gcc (verze pro x86-64)</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/46_stdc_printf_vararg/assemble_64bit">https://github.com/tisnik/presentations/blob/master/assembler/46_stdc_printf_vararg/assemble_64bit</a></td></tr>
<tr><td>4</td><td>assemble_arm</td><td>skript pro překlad s&nbsp;využitím gcc (verze pro ARM)</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/46_stdc_printf_vararg/assemble_arm">https://github.com/tisnik/presentations/blob/master/assembler/46_stdc_printf_vararg/assemble_arm</a></td></tr>
<tr><td>5</td><td>disassemble</td><td>skript pro disassembling</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/46_stdc_printf_vararg/disassemble">https://github.com/tisnik/presentations/blob/master/assembler/46_stdc_printf_vararg/disassemble</a></td></tr>
</table>



<h3>Druhý demonstrační příklad: kódy znaků z&nbsp;ASCII tabulky</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>main_64bit.s</td><td>hlavní program pro procesory x86-64</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/47_stdc_printf_float/main_64bit.s">https://github.com/tisnik/presentations/blob/master/assembler/47_stdc_printf_float/main_64bit.s</a></td></tr>
<tr><td>2</td><td>main_arm.s</td><td>hlavní program pro 32bitové procesory ARM</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/47_stdc_printf_float/main_arm.s">https://github.com/tisnik/presentations/blob/master/assembler/47_stdc_printf_float/main_arm.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>assemble_64bit</td><td>skript pro překlad s&nbsp;využitím gcc (verze pro x86-64)</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/47_stdc_printf_float/assemble_64bit">https://github.com/tisnik/presentations/blob/master/assembler/47_stdc_printf_float/assemble_64bit</a></td></tr>
<tr><td>4</td><td>assemble_arm</td><td>skript pro překlad s&nbsp;využitím gcc (verze pro ARM)</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/47_stdc_printf_float/assemble_arm">https://github.com/tisnik/presentations/blob/master/assembler/47_stdc_printf_float/assemble_arm</a></td></tr>
<tr><td>5</td><td>disassemble</td><td>skript pro disassembling</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/47_stdc_printf_float/disassemble">https://github.com/tisnik/presentations/blob/master/assembler/47_stdc_printf_float/disassemble</a></td></tr>
</table>



<h3>Třetí demonstrační příklad: výpis hodnoty typu <i>double</i> na standardní výstup</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>main_64bit.s</td><td>hlavní program pro procesory x86-64</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/48_ascii_chars/main_64bit.s">https://github.com/tisnik/presentations/blob/master/assembler/48_ascii_chars/main_64bit.s</a></td></tr>
<tr><td>2</td><td>main_arm.s</td><td>hlavní program pro 32bitové procesory ARM</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/48_ascii_chars/main_arm.s">https://github.com/tisnik/presentations/blob/master/assembler/48_ascii_chars/main_arm.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>assemble_64bit</td><td>skript pro překlad s&nbsp;využitím gcc (verze pro x86-64)</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/48_ascii_chars/assemble_64bit">https://github.com/tisnik/presentations/blob/master/assembler/48_ascii_chars/assemble_64bit</a></td></tr>
<tr><td>4</td><td>assemble_arm</td><td>skript pro překlad s&nbsp;využitím gcc (verze pro ARM)</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/48_ascii_chars/assemble_arm">https://github.com/tisnik/presentations/blob/master/assembler/48_ascii_chars/assemble_arm</a></td></tr>
<tr><td>5</td><td>disassemble</td><td>skript pro disassembling</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/48_ascii_chars/disassemble">https://github.com/tisnik/presentations/blob/master/assembler/48_ascii_chars/disassemble</a></td></tr>
</table>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>ARM Documentation: B, BL, BX, BLX, and BXJ<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0204j/Cihfddaf.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0204j/Cihfddaf.html</a>
</li>

<li>Branch and Call Sequences Explained<br />
<a href="https://community.arm.com/groups/processors/blog/2013/09/25/branch-and-call-sequences-explained">https://community.arm.com/groups/processors/blog/2013/09/25/branch-and-call-sequences-explained</a>
</li>

<li>Improving ARM Code Density and Performance<br />
<a href="New Thumb Extensions to the ARM Architecture Richard Phelan">New Thumb Extensions to the ARM Architecture Richard Phelan</a>
</li>

<li>The ARM Processor Architecture<br />
<a href="http://www.arm.com/products/processors/technologies/instruction-set-architectures.php">http://www.arm.com/products/processors/technologies/instruction-set-architectures.php</a>
</li>

<li>Thumb-2 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html</a>
</li>

<li>Introduction to ARM thumb<br />
<a href="http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb">http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb</a>
</li>

<li>ARM, Thumb, and ThumbEE instruction sets<br />
<a href="http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm">http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm</a>
</li>

<li>An Introduction to ARM Assembly Language<br />
<a href="http://dev.emcelettronica.com/introduction-to-arm-assembly-language">http://dev.emcelettronica.com/introduction-to-arm-assembly-language</a>
</li>

<li>Processors - ARM<br />
<a href="http://www.arm.com/products/processors/index.php">http://www.arm.com/products/processors/index.php</a>
</li>

<li>The ARM Instruction Set<br />
<a href="http://simplemachines.it/doc/arm_inst.pdf">http://simplemachines.it/doc/arm_inst.pdf</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ARM_architecture">http://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>C Functions Without Arguments<br />
<a href="https://eklitzke.org/c-functions-without-arguments">https://eklitzke.org/c-functions-without-arguments</a>
</li>

<li>GNU Assembler Examples<br />
<a href="http://cs.lmu.edu/~ray/notes/gasexamples/">http://cs.lmu.edu/~ray/notes/gasexamples/</a>
</li>

<li>Simply FPU<br />
<a href="http://www.website.masmforum.com/tutorials/fptute/">http://www.website.masmforum.com/tutorials/fptute/</a>
</li>

<li>Art of Assembly language programming: The 80x87 Floating Point Coprocessors<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html</a>
</li>

<li>Art of Assembly language programming: The FPU Instruction Set<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html</a>
</li>

<li>INTEL 80387 PROGRAMMER'S REFERENCE MANUAL<br />
<a href="http://www.ragestorm.net/downloads/387intel.txt">http://www.ragestorm.net/downloads/387intel.txt</a>
</li>

<li>x86 Instruction Set Reference: FLD<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_100.html">http://x86.renejeschke.de/html/file_module_x86_id_100.html</a>
</li>

<li>x86 Instruction Set Reference: FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_101.html">http://x86.renejeschke.de/html/file_module_x86_id_101.html</a>
</li>

<li>x86 Instruction Set Reference: FLD<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_100.html">http://x86.renejeschke.de/html/file_module_x86_id_100.html</a>
</li>

<li>x86 Instruction Set Reference: FST/FSTP<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_117.html">http://x86.renejeschke.de/html/file_module_x86_id_117.html</a>
</li>

<li>x86 Instruction Set Reference: BTC<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_23.html">http://x86.renejeschke.de/html/file_module_x86_id_23.html</a>
</li>

<li>x86 Instruction Set Reference: BTR<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_24.html">http://x86.renejeschke.de/html/file_module_x86_id_24.html</a>
</li>

<li>x86 Instruction Set Reference: BTS<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_25.html">http://x86.renejeschke.de/html/file_module_x86_id_25.html</a>
</li>

<li>x86 Instruction Set Reference: BSF<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_19.html">http://x86.renejeschke.de/html/file_module_x86_id_19.html</a>
</li>

<li>x86 Instruction Set Reference: BSR<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_20.html">http://x86.renejeschke.de/html/file_module_x86_id_20.html</a>
</li>

<li>x86 Instruction Set Reference: BSWAP<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_21.html">http://x86.renejeschke.de/html/file_module_x86_id_21.html</a>
</li>

<li>x86 Instruction Set Reference: XCHG<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_328.html">http://x86.renejeschke.de/html/file_module_x86_id_328.html</a>
</li>

<li>x86 Instruction Set Reference: SETcc<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_288.html">http://x86.renejeschke.de/html/file_module_x86_id_288.html</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>The GNU Assembler Tutorial<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html">http://tigcc.ticalc.org/doc/gnuasm.html</a>
</li>

<li>The GNU Assembler - macros<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html#SEC109">http://tigcc.ticalc.org/doc/gnuasm.html#SEC109</a>
</li>

<li>ARM subroutines &amp; program stack<br />
<a href="http://www.toves.org/books/armsub/">http://www.toves.org/books/armsub/</a>
</li>

<li>Generating Mixed Source and Assembly List using GCC<br />
<a href="http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/">http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/</a>
</li>

<li>Calling subroutines<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm</a>
</li>

<li>ARM Assembly Language Programming<br />
<a href="http://peter-cockerell.net/aalp/html/frames.html">http://peter-cockerell.net/aalp/html/frames.html</a>
</li>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Intel x86 JUMP quick reference<br />
<a href="http://unixwiz.net/techtips/x86-jumps.html">http://unixwiz.net/techtips/x86-jumps.html</a>
</li>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Assembler pod Linuxem<br />
<a href="http://phoenix.inf.upol.cz/linux/prog/asm.html">http://phoenix.inf.upol.cz/linux/prog/asm.html</a>
</li>

<li>AT&amp;T Syntax versus Intel Syntax<br />
<a href="https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html">https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html</a>
</li>

<li>Linux Assembly website<br />
<a href="http://asm.sourceforge.net/">http://asm.sourceforge.net/</a>
</li>

<li>Using Assembly Language in Linux<br />
<a href="http://asm.sourceforge.net/articles/linasm.html">http://asm.sourceforge.net/articles/linasm.html</a>
</li>

<li>vasm<br />
<a href="http://sun.hasenbraten.de/vasm/">http://sun.hasenbraten.de/vasm/</a>
</li>

<li>vasm &ndash; dokumentace<br />
<a href="http://sun.hasenbraten.de/vasm/release/vasm.html">http://sun.hasenbraten.de/vasm/release/vasm.html</a>
</li>

<li>The Yasm Modular Assembler Project<br />
<a href="http://yasm.tortall.net/">http://yasm.tortall.net/</a>
</li>

<li>680x0:AsmOne<br />
<a href="http://www.amigacoding.com/index.php/680x0:AsmOne">http://www.amigacoding.com/index.php/680x0:AsmOne</a>
</li>

<li>ASM-One Macro Assembler<br />
<a href="http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler">http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler</a>
</li>

<li>ASM-One pages<br />
<a href="http://www.theflamearrows.info/documents/asmone.html">http://www.theflamearrows.info/documents/asmone.html</a>
</li>

<li>Základní informace o ASM-One<br />
<a href="http://www.theflamearrows.info/documents/asminfo.html">http://www.theflamearrows.info/documents/asminfo.html</a>
</li>

<li>Linux Syscall Reference<br />
<a href="http://syscalls.kernelgrok.com/">http://syscalls.kernelgrok.com/</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>IBM System 360/370 Compiler and Historical Documentation<br />
<a href="http://www.edelweb.fr/Simula/">http://www.edelweb.fr/Simula/</a>
</li>

<li>IBM 700/7000 series<br />
<a href="http://en.wikipedia.org/wiki/IBM_700/7000_series">http://en.wikipedia.org/wiki/IBM_700/7000_series</a>
</li>

<li>IBM System/360<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/360">http://en.wikipedia.org/wiki/IBM_System/360</a>
</li>

<li>IBM System/370<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/370">http://en.wikipedia.org/wiki/IBM_System/370</a>
</li>

<li>Mainframe family tree and chronology<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html</a>
</li>

<li>704 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html</a>
</li>

<li>705 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html</a>
</li>

<li>The IBM 704<br />
<a href="http://www.columbia.edu/acis/history/704.html">http://www.columbia.edu/acis/history/704.html</a>
</li>

<li>IBM Mainframe album<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html</a>
</li>

<li>Osmibitové muzeum<br />
<a href="http://osmi.tarbik.com/">http://osmi.tarbik.com/</a>
</li>

<li>Tesla PMI-80<br />
<a href="http://osmi.tarbik.com/cssr/pmi80.html">http://osmi.tarbik.com/cssr/pmi80.html</a>
</li>

<li>PMI-80<br />
<a href="http://en.wikipedia.org/wiki/PMI-80">http://en.wikipedia.org/wiki/PMI-80</a>
</li>

<li>PMI-80<br />
<a href="http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016">http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016</a>
</li>

<li>The 6502 overflow flag explained mathematically <br />
<a href="http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html">http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html</a>
</li>

<li>X86 Opcode and Instruction Reference<br />
<a href="http://ref.x86asm.net/coder32.html">http://ref.x86asm.net/coder32.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

