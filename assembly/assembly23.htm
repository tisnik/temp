<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Kombinace assembleru a programovacího jazyka C na procesorech ARM</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Kombinace assembleru a programovacího jazyka C na procesorech ARM</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;předchozím článku jsme si ukázali, jakým způsobem je možné zkombinovat zdrojový kód napsaný v&nbsp;programovacím jazyku C s&nbsp;kódem psaným v&nbsp;assembleru. Přitom jsme se zaměřili na 32bitovou architekturu x86 (i386 až i686) a 64bitovou architekturu x86-64. Dnes si ukážeme kombinaci jazyka C a assembleru na mikroprocesorech s&nbsp;architekturou ARM.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Kombinace assembleru a programovacího jazyka C na procesorech ARM</a></p>
<p><a href="#k02">2. Seznam obecných jmen registrů použitých pro specifikaci vstupních a výstupních operandů</a></p>
<p><a href="#k03">3. Zápis komentářů, zpracování bloku <strong>asm</strong> překladačem céčka</a></p>
<p><a href="#k04">4. Pořadí zápisu operandů, specifikace konstant a jmen registrů</a></p>
<p><a href="#k05">5. Vrácení hodnoty z&nbsp;bloku napsaného v&nbsp;assembleru</a></p>
<p><a href="#k06">6. Větší množství výstupních operandů</a></p>
<p><a href="#k07">7. Vstupní a výstupní operandy</a></p>
<p><a href="#k08">8. Použití symbolických jmen v&nbsp;assemblerovském bloku: cesta k&nbsp;čitelnému zdrojovému kódu</a></p>
<p><a href="#k09">9. Makefile určený pro překlad dnešních demonstračních příkladů</a></p>
<p><a href="#k10">10. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k11">11. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Kombinace assembleru a programovacího jazyka C na procesorech ARM</h2>

<p>Již <a href="https://mojefedora.cz/pouziti-assembleru-v-linuxu-assembler-a-jazyk-c/">z&nbsp;předchozího článku</a> víme, že překladač GNU C (ale nejenom on) podporuje zápis bloků s&nbsp;instrukcemi assembleru přímo do zdrojových kódů psaných v&nbsp;céčku či C++. To může být velmi výhodné, protože nám to umožňuje nejenom psaní celých subrutin (podprogramů) v&nbsp;assembleru, ale i kombinaci C a assembleru v&nbsp;rámci jedné funkce, tj.&nbsp;bez nutnosti explicitního volání subrutiny, předání parametrů a návratu ze subrutiny apod. Minule jsme si taktéž ukázali způsob specifikace vstupních a výstupních operandů uvnitř bloku <strong>asm</strong> či <strong>__asm__</strong>. Dnes budeme v&nbsp;popisu této problematiky pokračovat, ovšem zaměříme se především na 32bitovou architekturu ARM, která se od architektury x86/x86-64 v&nbsp;mnoha ohledech odlišuje. Týká se to samozřejmě i způsobu zápisu assemblerovských bloků, specifikací operandů atd.</p>

<p>Všechny demonstrační příklady, s&nbsp;nimiž se dnes seznámíme, byly odzkoušeny na dnes již postarším GCC překladači verze 4.6.3, kterou naleznete v&nbsp;původních instalacích Raspbianu (testování probíhalo na Raspberry Pi):</p>

<pre>
<strong>gcc --version</strong>
gcc (Debian 4.6.3-14+rpi1) 4.6.3
Copyright (C) 2011 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
</pre>

<p>Verze GNU assembleru použitá pro otestování demonstračních příkladů:</p>

<pre>
<strong>as -version</strong>
GNU assembler (GNU Binutils for Debian) 2.24.51.20140425
Copyright (C) 2014 Free Software Foundation, Inc.
This program is free software; you may redistribute it under the terms of
the GNU General Public License version 3 or later.
This program has absolutely no warranty.
This assembler was configured for a target of `arm-linux-gnueabihf'.
</pre>

<p>Poznámka: demonstrační příklady budou samozřejmě funkční i na novějším překladači a/nebo novější verzi GNU Assembleru. Budou taktéž funkční na novějších procesorech ARM s&nbsp;výjimkou řady Cortex-M, která neobsahuje podporu pro původní ARMovskou instrukční sadu.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Seznam obecných jmen registrů použitých pro specifikaci vstupních a výstupních operandů</h2>

<p>Minule jsme si řekli, že při specifikaci vstupních a výstupních operandů celého assemblerovského bloku je nutné specifikovat, do jakých registrů se tyto operandy budou ukládat. Všechny příklady používaly obecné označení &bdquo;r&ldquo; značící libovolný pracovní registr. Na platformě x86/x86-64 je možné registr zvolit explicitně, a to náhradou znaku &bdquo;r&ldquo; v&nbsp;řetězci "=r" za jiný znak podle následující tabulky. Povšimněte si, že (alespoň prozatím) není možné explicitně použít vyšších osm pracovních registrů, tj.&nbsp;registry pojmenované <strong>R8</strong> až <strong>R15</strong>. V&nbsp;samotném assemblerovském kódu však tyto registry samozřejmě lze využít:</p>

<table>
<tr><th>Náhrada "r"</th><th>Význam</th></tr>
<tr><td>a</td><td>%rax, %eax, %ax, %al</td></tr>
<tr><td>b</td><td>%rbx, %ebx, %bx, %bl</td></tr>
<tr><td>c</td><td>%rcx, %ecx, %cx, %cl</td></tr>
<tr><td>d</td><td>%rdx, %edx, %dx, %dl</td></tr>
<tr><td>S</td><td>%rsi, %esi, %si</td></tr>
<tr><td>D</td><td>%rdi, %edi, %di</td></tr>
</table>

<p>U 32bitových mikroprocesorů a mikrořadičů ARM se kromě běžných pracovních registrů spadajících do kategorie &bdquo;r&ldquo; mohou používat i následující skupiny registrů. Povšimněte si, že některé skupiny jsou platné pouze v&nbsp;režimu ARM (původní RISCová instrukční sada), jiné naopak pouze v&nbsp;režimu Thumb. Některé skupiny dále vyžadují matematický koprocesor (VFP...) či rozšíření NEON:</p>

<table>
<tr><th>Skupina registrů</th><th>Omezení</th><th>Význam</th></tr>
<tr><td>r</td><td>&times;</td><td>libovolný pracovní registr</td></tr>
<tr><td>l</td><td>&times;</td><td>pracovní registr r0-r7 v&nbsp;režimu Thumb</td></tr>
<tr><td>h</td><td>&times;</td><td>pracovní registr r8-r15 v&nbsp;režimu Thumb</td></tr>
<tr><td>b</td><td>Thumb</td><td>pracovní registr r0-r7 popř.&nbsp;ukazatel na vrchol zásobníku</td></tr>
<tr><td>f</td><td>FPA</td><td>registr f0-f7</td></tr>
<tr><td>t</td><td>VFP</td><td>registr s0-s31 (single)</td></tr>
<tr><td>x</td><td>VFP</td><td>registr d0-d7 (double)</td></tr>
<tr><td>w</td><td>VFP</td><td>registr d0-d15 (double)</td></tr>
<tr><td>w</td><td>VFPv3</td><td>registr d0-d31 (double)</td></tr>
</table>

<p>Poznámka: přesnou specifikaci registru (například &bdquo;r0&ldquo;) prozatím nelze provést.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zápis komentářů, zpracování bloku <strong>asm</strong> překladačem céčka</h2>

<p>Praktickou část začneme velmi jednoduchým příkladem, na němž si ukážeme jeden z&nbsp;rozdílů mezi assemblerovským blokem psaným pro architektury x86 a x86-64 na jedné straně a tímtéž blokem psaným pro ARMovskou 32bitovou architekturu na straně druhé. Nejprve se podívejme, jak se zapisují komentáře při použití procesorů Intel či AMD. Každý komentář v&nbsp;assemblerovském bloku začíná znakem # a platí až do konce aktuálního řádku:</p>

<pre>
#include &lt;stdio.h&gt;

int main()
{
    __asm__ __volatile__(
        "nop   \n\t"
        " nop   \n\t"
        "  nop   \n\t"
        "    nop   \n\t"
        "    nop  # komentar \n\t"
        : /* zadne vystupni registry */
        : /* zadne vstupni operandy */
        : /* zadne registry pouzivane uvnitr kodu */
    );

    return 0;
}
</pre>

<p>Naprosto stejný příklad, ovšem psaný pro 32bitovou architekturu ARM, používá odlišné komentáře. Ty začínají znakem @ a taktéž platí až do konce aktuálního řádku:</p>

<pre>
#include &lt;stdio.h&gt;

int main()
{
    __asm__ __volatile__(
        "nop   \n\t"
        " nop   \n\t"
        "  nop   \n\t"
        "    nop   \n\t"
        "    nop  @ komentar \n\t"
        : /* zadne vystupni registry */
        : /* zadne vstupni operandy */
        : /* zadne registry pouzivane uvnitr kodu */
    );

    return 0;
}
</pre>

<p>Pokud se chcete podívat na způsob zpracování takového bloku překladačem céčka, lze použít příkaz:</p>

<pre>
gcc -S -c test.c -o test.s
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Pořadí zápisu operandů, specifikace konstant a jmen registrů</h2>

<p>Jména běžných pracovních registrů odpovídají konvencím používaným společností ARM, tj.&nbsp;registry mají přiřazena jména <strong>r0</strong> až <strong>r15</strong>. U některých registrů, konkrétně u posledních třech registrů, je možné použít i jmenný alias, což se týká především <strong>pc</strong> (programový čítač), <strong>lr</strong> (link register) a <strong>sp</strong> (ukazatel na vrchol zásobníku).</p>

<p>Vstupní operandy se zapisují způsobem "r" (proměnná_či_konstanta). Operandy se od sebe oddělují čárkou a od výstupních operandů jsou odděleny dvojtečkou:</p>

<pre>
: "r"  (ix),  "r" (iy)  /* vstupni operandy */
</pre>

<p>Výstupní operandy se zapisují způsobem "=r" (proměnná) a pokud je jich větší množství, opět se pro jejich oddělení používá čárka:</p>

<pre>
: "=r" (ox), "=r" (oy)  /* vystupni operandy */
</pre>

<p>Na konci celého bloku se uvádí nepovinný seznam registrů, které jsou modifikovány (&bdquo;zničeny&ldquo;) uvnitř assemblerovského bloku. Překladač programovacího jazyka C tuto informaci potřebuje, aby do těchto registrů před zavoláním assemblerovského bloku neuložil důležité údaje (připomeňme si, že samotný překladač se nijak nesnaží o hlubší analýzu assemblerovského bloku):</p>

<pre>
: "r0", "r1"            /* registry pouzivane uvnitr kodu */
</pre>

<p>Následující assemblerovský blok má:</p>

<ol>
<li>Dva vstupní operandy, které jsou naplněny z&nbsp;proměnných <strong>ix</strong> a <strong>iy</strong>.</li>
<li>Dva výstupní operandy, které jsou naplněny z&nbsp;proměnných <strong>ox</strong> a <strong>oy</strong>.</li>
<li>Specifikaci pracovních registrů <strong>r0</strong> a <strong>r1</strong> &bdquo;zničených&ldquo; uvnitř bloku.</li>
</ol>

<pre>
    __asm__ __volatile__(
        ""                      /* řetězec, který se po expanzi předá do assembleru */
        : "=r" (ox), "=r" (oy)  /* vystupni operandy */
        : "r"  (ix),  "r" (iy)  /* vstupni operandy */
        : "r0", "r1"            /* registry pouzivane uvnitr kodu */
    );
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Vrácení hodnoty z&nbsp;bloku napsaného v&nbsp;assembleru</h2>

<p>Zkusme si nyní vytvořit assemblerovský blok, který nemá žádné vstupní operandy, ovšem má jeden operand výstupní. V&nbsp;tomto bloku se nejdříve do pracovního registru <strong>r0</strong> vloží konstanta 42 a ta se ve druhé instrukci přenese do výstupního operandu, který je v&nbsp;bloku reprezentován svým pořadovým číslem <strong>%0</strong>. Výsledek je uložen do globální proměnné <strong>result</strong>, která je následně vypsána na standardní výstup běžnou céčkovskou funkcí <strong>printf()</strong>:</p>

<pre>
#include &lt;stdio.h&gt;

unsigned long result;

int main()
{
    __asm__ __volatile__(
        "mov    r0, #42    \n\t"
        "mov    %0, r0     \n\t"
        : "=r" (result)  /* vystupni operand */
        :                /* zadne vstupni operandy */
        : "r0"           /* registry pouzivane uvnitr kodu */
    );

    printf("%ld\n", result);

    return 0;
}
</pre>

<p>Pokud výše uvedený zdrojový kód přeložíme s&nbsp;volbou <strong>-s</strong>, můžeme ve vygenerovaném souboru najít i náš blok, v&nbsp;němž je jasně patrné, jak došlo k&nbsp;náhradě operandu specifikovaného svým pořadovým číslem <strong>%0</strong> za registr <strong>r2</strong>:</p>

<pre>
#APP
@ 7 "asm_in_c_4.c" 1
        mov    r0, #42    
        mov    r2, r0     
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Větší množství výstupních operandů</h2>

<p>Na rozdíl od běžných funkcí mohou assemblerovské bloky vytvořit větší množství výstupních hodnot, které jsou reprezentovány výstupními operandy. V&nbsp;předchozím příkladu jsme použili jen jeden výstupní operand, nyní si ukážeme použití dvou operandů, jejichž hodnoty mají být na konci assemblerovského bloku uloženy do globálních proměnných nazvaných <strong>x</strong> a <strong>y</strong>. Pro zajímavost je v&nbsp;assemblerovském bloku použita instrukce <strong>mov</strong>, která hodnotu vstupního operandu (registr <strong>r0</strong>) posune doleva o jeden bit (jedná se o logický posun), což je v&nbsp;instrukční sadě 32bitových mikroprocesorů ARM plně podporováno:</p>

<pre>
#include &lt;stdio.h&gt;

unsigned long x = 10;
unsigned long y = 20;

int main()
{
    printf("%ld\t%ld\n", x, y);

    __asm__ __volatile__(
        "mov    r0, #42          \n\t"
        "mov    r1, r0, lsl #1   \n\t"
        "mov    %0, r0           \n\t"
        "mov    %1, r1           \n\t"
        : "=r" (x), "=r" (y)  /* vystupni operandy */
        :                     /* zadne vstupni operandy */
        : "r0", "r1"          /* registry pouzivane uvnitr kodu */
    );

    printf("%ld\t%ld\n", x, y);

    return 0;
}
</pre>

<p>Po překladu a spuštění tohoto příkladu by se na standardní výstup měly vypsat původní hodnoty proměnných <strong>x</strong> a <strong>y</strong> (ty budou následně přepsány) a na druhém řádku jejich nové hodnoty (42 a 42&times;2):</p>

<pre>
10      20
42      84
</pre>

<p>Pro zajímavost se podívejme, jak se náš assemblerovský blok přeložil do výsledného souboru. Vidíme, že překladač vybral pracovní registry <strong>r12</strong> a <strong>r2</strong> (pro registr <strong>r12</strong> je použil alias <strong>ip</strong>):</p>

<pre>
#APP
@ 10 "asm_in_c_4.c" 1
        mov    r0, #42          
        mov    r1, r0, lsl #1   
        mov    ip, r0           
        mov    r2, r1           
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vstupní a výstupní operandy</h2>

<p>V&nbsp;dalším příkladu je ukázána kombinace vstupních a výstupních operandů. Povšimněte si především toho, že výstupní operandy jsou uvedeny na prvním místě a proto jsou jim přiřazena pořadová čísla %0 a %1. Až potom následují vstupní operandy s&nbsp;pořadovými čísly %2 a %3 (toto číslování může být zpočátku matoucí). I v&nbsp;tomto příkladu používáme instrukci <strong>mov</strong> kombinovanou s&nbsp;operací logického posunu doprava o dva bity (jen pro ukázku možností ARMovských procesorů):</p>

<pre>
#include &lt;stdio.h&gt;

unsigned long ix = 100;
unsigned long iy = 200;
unsigned long ox;
unsigned long oy;

int main()
{
    printf("%ld\t%ld\n", ix, iy);

    __asm__ __volatile__(
        "mov    r0, %2          \n\t"
        "mov    r1, %3          \n\t"
        "mov    %0, r0, lsr #2  \n\t"
        "mov    %1, r1, lsr #2  \n\t"
        : "=r" (ox), "=r" (oy)  /* vystupni operandy */
        : "r" (ix),  "r" (iy)   /* vstupni operandy */
        : "r0", "r1"            /* registry pouzivane uvnitr kodu */
    );

    printf("%ld\t%ld\n", ox, oy);

    return 0;
}
</pre>

<p>Po překladu a spuštění tohoto příkladu by se na standardní výstup měly vypsat hodnoty vstupních proměnných <strong>ix</strong> a <strong>iy</strong> a na druhém řádku hodnoty proměnných výstupních <strong>ox</strong> a <strong>oy</strong>:</p>

<pre>
100      200
25       50
</pre>

<p>Opět se podívejme na způsob překladu. První čtyři instrukce naplní obsahy pracovních registrů vstupními proměnnými, následuje vlastní assemblerovský blok a následně uložení výsledků do výstupních proměnných:</p>

<pre>
        ldr     r3, .L2+4
        ldr     r3, [r3, #0]
        ldr     r2, .L2+8
        ldr     r2, [r2, #0]
#APP
@ 12 "asm_in_c_5.c" 1
        mov    r0, r3          
        mov    r1, r2          
        mov    ip, r0, lsr #2  
        mov    r2, r1, lsr #2  
        
@ 0 "" 2
        ldr     r3, .L2+12
        str     ip, [r3, #0]
        ldr     r3, .L2+16
        str     r2, [r3, #0]
</pre>

<p>Pro pochopení způsobu adresování (.L2+12 atd.) je nutné se podívat na datovou sekci vygenerovaného souboru. Každé slovo má šířku čtyři bajty:</p>

<pre>
.L2:
        .word   .LC0
        .word   ix
        .word   iy
        .word   ox
        .word   oy
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Použití symbolických jmen v&nbsp;assemblerovském bloku: cesta k&nbsp;čitelnému zdrojovému kódu</h2>

<p>Již minule jsme se zmínili o možnosti použití symbolických jmen vstupních a výstupních operandů v&nbsp;assemblerovském bloku. Tyto operandy je nejdříve zapotřebí pojmenovat, přičemž jména se uvádí v&nbsp;hranatých závorkách:</p>

<pre>
: [output1] "=r" (ox),  /* vystupni operandy */
  [output2] "=r" (oy)
: [input1]  "r" (ix),   /* vstupni operandy */
  [input2]  "r" (iy)
</pre>

<p>Následně lze tato jména použít v&nbsp;assemblerovském bloku, nesmíme však zapomenout na uvedení znaku procenta před symbolické jméno:</p>

<pre>
"mov    r0, %[input1]           \n\t"
"mov    r1, %[input2]           \n\t"
"mov    %[output1], r0, lsr #2  \n\t"
"mov    %[output2], r1, lsr #2  \n\t"
</pre>

<p>Demonstrační příklad popsaný <a href="#k07">v&nbsp;předchozí kapitole</a> můžeme velmi snadno přepsat do čitelnější podoby:</p>

<pre>
#include &lt;stdio.h&gt;

unsigned long ix = 100;
unsigned long iy = 200;
unsigned long ox;
unsigned long oy;

int main()
{
    printf("%ld\t%ld\n", ix, iy);

    __asm__ __volatile__(
        "mov    r0, %[input1]           \n\t"
        "mov    r1, %[input2]           \n\t"
        "mov    %[output1], r0, lsr #2  \n\t"
        "mov    %[output2], r1, lsr #2  \n\t"
        : [output1] "=r" (ox),  /* vystupni operandy */
          [output2] "=r" (oy)
        : [input1]  "r" (ix),   /* vstupni operandy */
          [input2]  "r" (iy)
        : "r0", "r1"            /* registry pouzivane uvnitr kodu */
    );

    printf("%ld\t%ld\n", ox, oy);

    return 0;
}
</pre>

<p>Překlad proběhne prakticky totožným způsobem:</p>

<pre>
        ldr     r3, .L2+4
        ldr     r3, [r3, #0]
        ldr     r2, .L2+8
        ldr     r2, [r2, #0]
#APP
@ 12 "asm_in_c_6.c" 1
        mov    r0, r3           
        mov    r1, r2           
        mov    ip, r0, lsr #2  
        mov    r2, r1, lsr #2  
        
@ 0 "" 2
        ldr     r3, .L2+12
        str     ip, [r3, #0]
        ldr     r3, .L2+16
        str     r2, [r3, #0]
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Makefile určený pro překlad dnešních demonstračních příkladů</h2>

<p>Všechny demonstrační příklady, které jsme si v&nbsp;dnešním článku ukázali, lze přeložit příkazem <strong>make</strong> s&nbsp;využitím následujícího souboru Makefile. Tento soubor si raději stáhněte <a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/Makefile">přímo z&nbsp;repositáře</a>, neboť jen tak budete mít jistotu, že se nenahradí znaky pro Tab za mezery:</p>

<pre>
# Parametry prekladace.
CFLAGS=-Wall -O9

# Vychozi pravidlo pro vytvoreni vysledne spustitelne aplikace.
all:    asm_in_c_0.s asm_in_c_0 \
        asm_in_c_1.s asm_in_c_1 \
        asm_in_c_2.s asm_in_c_2 \
        asm_in_c_3.s asm_in_c_3 \
        asm_in_c_4.s asm_in_c_4 \
        asm_in_c_5.s asm_in_c_5 \
        asm_in_c_6.s asm_in_c_6 \
        asm_in_c_7.s asm_in_c_7 \
        asm_in_c_8.s asm_in_c_8 \
        asm_in_c_9.s asm_in_c_9 \
        asm_in_c_10.s asm_in_c_10 \
        asm_in_c_11.s asm_in_c_11

clean:
        rm -f *.o
        rm -f *.s
        rm -f asm_in_c_[0-9]+

# Pravidlo pro slinkovani vsech objektovych souboru a vytvoreni
# vysledne spustitelne aplikace.
$(PROGNAME):    $(PROGNAME).o
        $(CC) -o $@ $(LDFLAGS) $&lt;

# Pravidlo pro preklad kazdeho zdrojoveho souboru do prislusneho
# objektoveho souboru.
%.o:    %.c
        $(CC) $(CFLAGS) -c $&lt; -o $@

# Pravidlo pro preklad kazdeho zdrojoveho souboru do prislusneho
# assemblerovskeho vysledku.
%.s:    %.c
        $(CC) $(CFLAGS) -S -c $&lt; -o $@
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny demonstrační příklady byly, podobně jako v&nbsp;prakticky všech předchozích částech tohoto seriálu, společně s&nbsp;podpůrným skriptem připraveným pro jejich překlad, uloženy do GIT repositáře dostupného na adrese <a href="https://github.com/tisnik/presentations/">https://github.com/tisnik/presentations/</a>. Všechny zmíněné příklady jsou určeny pro překladač GNU C (podrobnosti o konkrétních verzích jsou uvedeny v&nbsp;úvodní kapitole):</p>

<table>
<tr><th> #</th><th>Soubor</th><th>Odkaz do repositáře</th></tr>
<tr><td> 1</td><td>asm_in_c_0.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_0.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_0.c</a></td></tr>
<tr><td> 2</td><td>asm_in_c_1.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_1.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_1.c</a></td></tr>
<tr><td> 3</td><td>asm_in_c_2.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_2.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_2.c</a></td></tr>
<tr><td> 4</td><td>asm_in_c_3.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_3.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_3.c</a></td></tr>
<tr><td> 5</td><td>asm_in_c_4.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_4.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_4.c</a></td></tr>
<tr><td> 6</td><td>asm_in_c_5.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_5.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_5.c</a></td></tr>
<tr><td> 7</td><td>asm_in_c_6.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_6.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_6.c</a></td></tr>
<tr><td> 8</td><td>asm_in_c_7.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_7.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_7.c</a></td></tr>
<tr><td> 9</td><td>asm_in_c_8.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_8.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_8.c</a></td></tr>
<tr><td>10</td><td>asm_in_c_9.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_9.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_9.c</a></td></tr>
<tr><td>11</td><td>asm_in_c_10.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_10.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_10.c</a></td></tr>
<tr><td>12</td><td>asm_in_c_11.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_11.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_11.c</a></td></tr>
</table>

<p>Poznámka: poslední příklady budou podrobněji popsány příště.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Odkazy na Internetu</h2>

<ol>

<li>ARM GCC Inline Assembler Cookbook<br />
<a href="http://www.ethernut.de/en/documents/arm-inline-asm.html">http://www.ethernut.de/en/documents/arm-inline-asm.html</a>
</li>

<li>Extended Asm - Assembler Instructions with C Expression Operands<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html</a>
</li>

<li>ARM inline asm secrets<br />
<a href="http://hardwarebug.org/2010/07/06/arm-inline-asm-secrets/">http://hardwarebug.org/2010/07/06/arm-inline-asm-secrets/</a>
</li>

<li>How to Use Inline Assembly Language in C Code<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C">https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C</a>
</li>

<li>GCC-Inline-Assembly-HOWTO<br />
<a href="http://ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">http://ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html</a>
</li>

<li>A Brief Tutorial on GCC inline asm (x86 biased)<br />
<a href="http://www.osdever.net/tutorials/view/a-brief-tutorial-on-gcc-inline-asm">http://www.osdever.net/tutorials/view/a-brief-tutorial-on-gcc-inline-asm</a>
</li>

<li>GCC Inline ASM<br />
<a href="http://locklessinc.com/articles/gcc_asm/">http://locklessinc.com/articles/gcc_asm/</a>
</li>

<li>Cortex-A35<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php</a>
</li>

<li>Cortex-A53<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php</a>
</li>

<li>Cortex-A57<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php</a>
</li>

<li>Cortex-A72<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php</a>
</li>

<li>Cortex-A73<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php</a>
</li>

<li>System cally pro AArch64 na Linuxu<br />
<a href="https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h">https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</a>
</li>

<li>Architectures/AArch64 (FedoraProject.org)<br />
<a href="https://fedoraproject.org/wiki/Architectures/AArch64">https://fedoraproject.org/wiki/Architectures/AArch64</a>
</li>

<li>SIG pro AArch64 (CentOS)<br />
<a href="https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64">https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64</a>
</li>

<li>The ARMv8 instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>A64 Instruction Set<br />
<a href="https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set">https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set</a>
</li>

<li>Switching between the instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>The A64 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>Introduction to ARMv8 64-bit Architecture<br />
<a href="https://quequero.org/2014/04/introduction-to-arm-architecture/">https://quequero.org/2014/04/introduction-to-arm-architecture/</a>
</li>

<li>MCU market turns to 32-bits and ARM<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1280803">http://www.eetimes.com/document.asp?doc_id=1280803</a>
</li>

<li>Cortex-M0 Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0.php">http://www.arm.com/products/processors/cortex-m/cortex-m0.php</a>
</li>

<li>Cortex-M0+ Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php">http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php</a>
</li>

<li>ARM Processors in a Mixed Signal World<br />
<a href="http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world">http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_architecture">https://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>ARM Documentation: B, BL, BX, BLX, and BXJ<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0204j/Cihfddaf.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0204j/Cihfddaf.html</a>
</li>

<li>Branch and Call Sequences Explained<br />
<a href="https://community.arm.com/groups/processors/blog/2013/09/25/branch-and-call-sequences-explained">https://community.arm.com/groups/processors/blog/2013/09/25/branch-and-call-sequences-explained</a>
</li>

<li>Improving ARM Code Density and Performance<br />
<a href="New Thumb Extensions to the ARM Architecture Richard Phelan">New Thumb Extensions to the ARM Architecture Richard Phelan</a>
</li>

<li>Aarch64 Register and Instruction Quick Start<br />
<a href="https://wiki.cdot.senecacollege.ca/wiki/Aarch64_Register_and_Instruction_Quick_Start">https://wiki.cdot.senecacollege.ca/wiki/Aarch64_Register_and_Instruction_Quick_Start</a>
</li>

<li>Exploring AArch64 assembler – Chapter 1<br />
<a href="http://thinkingeek.com/2016/10/08/exploring-aarch64-assembler-chapter1/">http://thinkingeek.com/2016/10/08/exploring-aarch64-assembler-chapter1/</a>
</li>

<li>Exploring AArch64 assembler – Chapter 2<br />
<a href="http://thinkingeek.com/2016/10/08/exploring-aarch64-assembler-chapter-2/">http://thinkingeek.com/2016/10/08/exploring-aarch64-assembler-chapter-2/</a>
</li>

<li>The ARM Processor Architecture<br />
<a href="http://www.arm.com/products/processors/technologies/instruction-set-architectures.php">http://www.arm.com/products/processors/technologies/instruction-set-architectures.php</a>
</li>

<li>Thumb-2 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html</a>
</li>

<li>Introduction to ARM thumb<br />
<a href="http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb">http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb</a>
</li>

<li>ARM, Thumb, and ThumbEE instruction sets<br />
<a href="http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm">http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm</a>
</li>

<li>An Introduction to ARM Assembly Language<br />
<a href="http://dev.emcelettronica.com/introduction-to-arm-assembly-language">http://dev.emcelettronica.com/introduction-to-arm-assembly-language</a>
</li>

<li>Processors - ARM<br />
<a href="http://www.arm.com/products/processors/index.php">http://www.arm.com/products/processors/index.php</a>
</li>

<li>The ARM Instruction Set<br />
<a href="http://simplemachines.it/doc/arm_inst.pdf">http://simplemachines.it/doc/arm_inst.pdf</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ARM_architecture">http://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>C Functions Without Arguments<br />
<a href="https://eklitzke.org/c-functions-without-arguments">https://eklitzke.org/c-functions-without-arguments</a>
</li>

<li>GNU Assembler Examples<br />
<a href="http://cs.lmu.edu/~ray/notes/gasexamples/">http://cs.lmu.edu/~ray/notes/gasexamples/</a>
</li>

<li>Simply FPU<br />
<a href="http://www.website.masmforum.com/tutorials/fptute/">http://www.website.masmforum.com/tutorials/fptute/</a>
</li>

<li>Art of Assembly language programming: The 80x87 Floating Point Coprocessors<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html</a>
</li>

<li>Art of Assembly language programming: The FPU Instruction Set<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html</a>
</li>

<li>INTEL 80387 PROGRAMMER'S REFERENCE MANUAL<br />
<a href="http://www.ragestorm.net/downloads/387intel.txt">http://www.ragestorm.net/downloads/387intel.txt</a>
</li>

<li>x86 Instruction Set Reference: FLD<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_100.html">http://x86.renejeschke.de/html/file_module_x86_id_100.html</a>
</li>

<li>x86 Instruction Set Reference: FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_101.html">http://x86.renejeschke.de/html/file_module_x86_id_101.html</a>
</li>

<li>x86 Instruction Set Reference: FLD<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_100.html">http://x86.renejeschke.de/html/file_module_x86_id_100.html</a>
</li>

<li>x86 Instruction Set Reference: FST/FSTP<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_117.html">http://x86.renejeschke.de/html/file_module_x86_id_117.html</a>
</li>

<li>x86 Instruction Set Reference: BTC<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_23.html">http://x86.renejeschke.de/html/file_module_x86_id_23.html</a>
</li>

<li>x86 Instruction Set Reference: BTR<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_24.html">http://x86.renejeschke.de/html/file_module_x86_id_24.html</a>
</li>

<li>x86 Instruction Set Reference: BTS<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_25.html">http://x86.renejeschke.de/html/file_module_x86_id_25.html</a>
</li>

<li>x86 Instruction Set Reference: BSF<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_19.html">http://x86.renejeschke.de/html/file_module_x86_id_19.html</a>
</li>

<li>x86 Instruction Set Reference: BSR<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_20.html">http://x86.renejeschke.de/html/file_module_x86_id_20.html</a>
</li>

<li>x86 Instruction Set Reference: BSWAP<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_21.html">http://x86.renejeschke.de/html/file_module_x86_id_21.html</a>
</li>

<li>x86 Instruction Set Reference: XCHG<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_328.html">http://x86.renejeschke.de/html/file_module_x86_id_328.html</a>
</li>

<li>x86 Instruction Set Reference: SETcc<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_288.html">http://x86.renejeschke.de/html/file_module_x86_id_288.html</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>The GNU Assembler Tutorial<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html">http://tigcc.ticalc.org/doc/gnuasm.html</a>
</li>

<li>The GNU Assembler - macros<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html#SEC109">http://tigcc.ticalc.org/doc/gnuasm.html#SEC109</a>
</li>

<li>ARM subroutines &amp; program stack<br />
<a href="http://www.toves.org/books/armsub/">http://www.toves.org/books/armsub/</a>
</li>

<li>Generating Mixed Source and Assembly List using GCC<br />
<a href="http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/">http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/</a>
</li>

<li>Calling subroutines<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm</a>
</li>

<li>ARM Assembly Language Programming<br />
<a href="http://peter-cockerell.net/aalp/html/frames.html">http://peter-cockerell.net/aalp/html/frames.html</a>
</li>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Intel x86 JUMP quick reference<br />
<a href="http://unixwiz.net/techtips/x86-jumps.html">http://unixwiz.net/techtips/x86-jumps.html</a>
</li>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Assembler pod Linuxem<br />
<a href="http://phoenix.inf.upol.cz/linux/prog/asm.html">http://phoenix.inf.upol.cz/linux/prog/asm.html</a>
</li>

<li>AT&amp;T Syntax versus Intel Syntax<br />
<a href="https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html">https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html</a>
</li>

<li>Linux Assembly website<br />
<a href="http://asm.sourceforge.net/">http://asm.sourceforge.net/</a>
</li>

<li>Using Assembly Language in Linux<br />
<a href="http://asm.sourceforge.net/articles/linasm.html">http://asm.sourceforge.net/articles/linasm.html</a>
</li>

<li>vasm<br />
<a href="http://sun.hasenbraten.de/vasm/">http://sun.hasenbraten.de/vasm/</a>
</li>

<li>vasm &ndash; dokumentace<br />
<a href="http://sun.hasenbraten.de/vasm/release/vasm.html">http://sun.hasenbraten.de/vasm/release/vasm.html</a>
</li>

<li>The Yasm Modular Assembler Project<br />
<a href="http://yasm.tortall.net/">http://yasm.tortall.net/</a>
</li>

<li>680x0:AsmOne<br />
<a href="http://www.amigacoding.com/index.php/680x0:AsmOne">http://www.amigacoding.com/index.php/680x0:AsmOne</a>
</li>

<li>ASM-One Macro Assembler<br />
<a href="http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler">http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler</a>
</li>

<li>ASM-One pages<br />
<a href="http://www.theflamearrows.info/documents/asmone.html">http://www.theflamearrows.info/documents/asmone.html</a>
</li>

<li>Základní informace o ASM-One<br />
<a href="http://www.theflamearrows.info/documents/asminfo.html">http://www.theflamearrows.info/documents/asminfo.html</a>
</li>

<li>Linux Syscall Reference<br />
<a href="http://syscalls.kernelgrok.com/">http://syscalls.kernelgrok.com/</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>IBM System 360/370 Compiler and Historical Documentation<br />
<a href="http://www.edelweb.fr/Simula/">http://www.edelweb.fr/Simula/</a>
</li>

<li>IBM 700/7000 series<br />
<a href="http://en.wikipedia.org/wiki/IBM_700/7000_series">http://en.wikipedia.org/wiki/IBM_700/7000_series</a>
</li>

<li>IBM System/360<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/360">http://en.wikipedia.org/wiki/IBM_System/360</a>
</li>

<li>IBM System/370<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/370">http://en.wikipedia.org/wiki/IBM_System/370</a>
</li>

<li>Mainframe family tree and chronology<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html</a>
</li>

<li>704 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html</a>
</li>

<li>705 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html</a>
</li>

<li>The IBM 704<br />
<a href="http://www.columbia.edu/acis/history/704.html">http://www.columbia.edu/acis/history/704.html</a>
</li>

<li>IBM Mainframe album<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html</a>
</li>

<li>Osmibitové muzeum<br />
<a href="http://osmi.tarbik.com/">http://osmi.tarbik.com/</a>
</li>

<li>Tesla PMI-80<br />
<a href="http://osmi.tarbik.com/cssr/pmi80.html">http://osmi.tarbik.com/cssr/pmi80.html</a>
</li>

<li>PMI-80<br />
<a href="http://en.wikipedia.org/wiki/PMI-80">http://en.wikipedia.org/wiki/PMI-80</a>
</li>

<li>PMI-80<br />
<a href="http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016">http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016</a>
</li>

<li>The 6502 overflow flag explained mathematically <br />
<a href="http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html">http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html</a>
</li>

<li>X86 Opcode and Instruction Reference<br />
<a href="http://ref.x86asm.net/coder32.html">http://ref.x86asm.net/coder32.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

