<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Použití assembleru v Linuxu: práce s matematickým koprocesorem (pokračování)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Použití assembleru v Linuxu: práce s matematickým koprocesorem (pokračování)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;předchozím článku věnovaném použití assembleru v&nbsp;Linuxu jsme se seznámili se základními vlastnosti matematického koprocesoru využívaného na platformách i386 a x86-64. Dnes si vyzkoušíme aplikaci některých vybraných instrukcí v&nbsp;trojici demonstračních příkladů. Ukážeme si i některé mezní případy a výjimky, které mohou při výpočtech nastat &ndash; dělení nulou atd.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Použití assembleru v Linuxu: práce s&nbsp;matematickým koprocesorem (pokračování)</a></p>
<p><a href="#k02">2. Načtení FP konstanty do registru mikroprocesoru s&nbsp;následným uložením konstanty do paměti</a></p>
<p><a href="#k03">3. První demonstrační příklad: vytištění hodnot 0.0, 1.0 a Pi v&nbsp;hexadecimálním tvaru</a></p>
<p><a href="#k04">4. Jak přečíst a dekódovat vytištěné výsledky?</a></p>
<p><a href="#k05">5. Pomocný program pro převod FPU hodnot do jejich hexadecimální podoby</a></p>
<p><a href="#k06">6. Základní aritmetické operace v&nbsp;praxi</a></p>
<p><a href="#k07">7. Složitější výrazy a práce se zásobníkem operandů</a></p>
<p><a href="#k08">8. Druhý demonstrační příklad: základní aritmetické operace</a></p>
<p><a href="#k09">9. Dělení kladnou a zápornou nulou</a></p>
<p><a href="#k10">10. Dělení nuly nulou aneb práce s&nbsp;NaN</a></p>
<p><a href="#k11">11. Třetí demonstrační příklad: dělení nulou</a></p>
<p><a href="#k12">12. Pomocné zdrojové soubory</a></p>
<p><a href="#k13">13. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Použití assembleru v Linuxu: práce s&nbsp;matematickým koprocesorem (pokračování)</h2>

<p><a href="https://mojefedora.cz/pouziti-assembleru-v-linuxu-prace-s-matematickym-koprocesorem/">V&nbsp;předchozí části</a> seriálu o použití assembleru v&nbsp;Linuxu jsme se seznámili se základními koncepty, na nichž je postaven matematický koprocesor používaný na architekturách i386 a x86-64. Připomeňme si, že matematický koprocesor obsahuje osm pracovních registrů, každý o šířce osmdesáti bitů. Tyto registry jsou doplněny o řídicí registr a stavový registr. Dnes si ve třech demonstračních příkladech ukážeme, jakým způsobem je možné matematický koprocesor použít pro základní výpočty, zejména pro aritmetické operace. Taktéž si ukážeme, co se stane při dělení nenulového čísla nulou (což je zcela legální operace) i při pokusu o dělení nuly nulou. Demonstrační příklady jsou primárně odladěny pro 32bitovou platformu i386 (běží ovšem samozřejmě i v&nbsp;64bitovém systému), ovšem po nepatrné úpravě je lze použít i v&nbsp;čistém 64bitovém režimu.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Načtení FP konstanty do registru mikroprocesoru s&nbsp;následným uložením konstanty do paměti</h2>

<p>Matematický koprocesor obsahuje několik instrukcí, které je možné použít pro uložení konstanty do pracovního registru procesoru. Mezi základní konstanty patří kladná nula +0,0, kladná jednička +1,0, konstanta &pi; a taktéž na první pohled možná poněkud zbytečné, ale v&nbsp;praxi používané konstanty log<sub>2</sub>10, log<sub>2</sub>e, log<sub>10</sub>2 a log<sub>e</sub>2 (u některých výpočtů totiž může být výhodné nejprve operandy zlogaritmovat a posléze je namísto násobení pouze sečíst atd.). Všechny instrukce, které do pracovního registru matematického koprocesoru, konkrétně do registru, jenž aktuálně leží na vrcholu zásobníku, uloží příslušnou konstantu, jsou vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>FLDZ  </td><td>načtení konstanty +0,0 (kladná nula)</td></tr>
<tr><td>2</td><td>FLD1  </td><td>načtení konstanty +1,0</td></tr>
<tr><td>3</td><td>FLDPI </td><td>načtení konstanty &pi;</td></tr>
<tr><td>4</td><td>FLDL2T</td><td>načtení konstanty log<sub>2</sub>10</td></tr>
<tr><td>5</td><td>FLDL2E</td><td>načtení konstanty log<sub>2</sub>e</td></tr>
<tr><td>6</td><td>FLDLG2</td><td>načtení konstanty log<sub>10</sub>2</td></tr>
<tr><td>7</td><td>FLDLN2</td><td>načtení konstanty log<sub>e</sub>2</td></tr>
</table>

<p>Jakým způsobem se však přesvědčíme o tom, že skutečně došlo k&nbsp;uložení zvolené konstanty do vybraného pracovního registru matematického koprocesoru? Kupodivu není k&nbsp;dispozici žádná instrukce, která by data přímo převedla z&nbsp;matematického koprocesoru do hlavního procesoru, ovšem můžeme využít toho, že obsah libovolného pracovního registru matematického koprocesoru je možné převést do podporovaného formátu (<i>single</i>, <i>double</i>, <i>extended</i>) a uložit zkonvertovanou hodnotu na zvolenou adresu operační paměti. Z&nbsp;této adresy se pak může hodnota načíst do pracovního registru hlavního procesoru a následně se tato hodnota může vypsat například v&nbsp;hexadecimálním tvaru, což již umíme, neboť jsme se touto problematikou již zabývali v&nbsp;předchozích článcích.</p>

<p>Nejdříve je nutné pojmenovat adresu, na kterou se budou hodnoty ukládat. Pro jednoduchost se bude jednat o čtyři bajty alokované v&nbsp;sekci BSS (tato sekce není součástí přeloženého binárního souboru). Čtyři bajty jsou zvoleny proto, že se původně 80bitová hodnota převede do formátu <i>single</i> (číslo s&nbsp;plovoucí řádovou čárkou s&nbsp;jednoduchou přesností). Pro pojmenování (label) zvolíme jméno <strong>number</strong>:</p>

<pre>
.section .bss

.lcomm number, 4                     # na toto misto se bude ukladat konstanta typu float
</pre>

<p>Samotná sekvence instrukcí určených pro vložení konstanty do pracovního registru matematického koprocesoru, následné uložení této hodnoty do operační paměti, načtení uložené hodnoty do pracovního registru hlavního procesoru a vypsání hodnoty v&nbsp;hexadecimální tvaru vypadá následovně:</p>

<pre>
fldz                         # nacteni FP konstanty 0.0
fstp dword ptr number        # ulozeni do pameti (4 bajty)
mov  eax, dword ptr number   # nacteni hodnoty, tentokrat to celociselneho registru
printHexNumber eax           # vytiskneme celociselnou hodnotu v hexa tvaru
</pre>

<p>Povšimněte si, že při ukládání do operační paměti musíme přes <strong>dword ptr</strong> přesně určit způsob konverze (zde na čtyři bajty = <i>single</i>). Totéž platí při zpětném načítání hodnoty do 32bitového pracovního registru <strong>EAX</strong>. Následně voláme makro <strong>printHexNumber</strong>, jehož zdrojový kód naleznete <a href="#k12">ve dvanácté kapitole</a>.</p>

<p>Poznámka: instrukce <strong>FSTP</strong> provádí kombinaci operací <strong>FST</strong>+<strong>POP</strong>, tedy konverzi a uložení obsahu pracovního registru následovanou odstraněním hodnoty ze zásobníku (což se provádí pouhým posunem indexu vrcholu zásobníku o jedničku).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. První demonstrační příklad: vytištění hodnot 0.0, 1.0 a Pi v&nbsp;hexadecimálním tvaru</h2>

<p>Dnešní první demonstrační příklad je založen na sekvenci tří instrukcí <strong>FLDX</strong>, <strong>FSTP adresa</strong> a <strong>MOV eax, adresa</strong> následovaných voláním makra <strong>printHexNumber</strong>. Tímto způsobem jsou postupně vypsány hodnoty +0,0, +1,0 a &pi;, a to v&nbsp;hexadecimálním tvaru. Nejprve se podívejme na zdrojový kód, který tvoří hlavní část programu, zbylé tři moduly jsou opět popsány ve dvanácté kapitole:</p>

<pre>
# asmsyntax=as

# Program pro otestovani zakladnich FP operaci
# - pro zapis je pouzita "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix



# Nacteni definice makra pro ukonceni aplikace
.include "exit.s"

# Nacteni maker pro (opakovany) tisk zpravy i prislusne subrutiny
.include "writeMessage.s"

# Nacteni makra pro vytisteni hexadecimalni 32bitove hodnoty
# spolecne s makrem je nactena i prislusna subrutina
.include "printHexNumber.s"



#-----------------------------------------------------------------------------
.section .data
fpuValueZeroMessage:
        .string "0.0: "                             # zprava
fpuValueZeroMessageLength = $ - fpuValueZeroMessage # delka zpravy

fpuValueOneMessage:
        .string "1.0: "                             # zprava
fpuValueOneMessageLength = $ - fpuValueOneMessage   # delka zpravy

fpuValuePiMessage:
        .string "Pi:  "                             # zprava
fpuValuePiMessageLength = $ - fpuValuePiMessage     # delka zpravy



#-----------------------------------------------------------------------------
.section .bss

.lcomm number, 4                     # na toto misto se bude ukladat konstanta typu float



#-----------------------------------------------------------------------------
.section .text
        .global _start               # tento symbol ma byt dostupny i linkeru

_start:
        writeMessage fpuValueZeroMessage, fpuValueZeroMessageLength

        fldz                         # nacteni FP konstanty 0.0
        fstp dword ptr number        # ulozeni do pameti (4 bajty)
        mov  eax, dword ptr number   # nacteni hodnoty, tentokrat to celociselneho registru
        printHexNumber eax           # vytiskneme celociselnou hodnotu v hexa tvaru



        writeMessage fpuValueOneMessage, fpuValueOneMessageLength

        fld1                         # nacteni FP konstanty 1.0
        fstp dword ptr number        # ulozeni do pameti (4 bajty)
        mov  eax, dword ptr number   # nacteni hodnoty, tentokrat to celociselneho registru
        printHexNumber eax           # vytiskneme celociselnou hodnotu v hexa tvaru



        writeMessage fpuValuePiMessage, fpuValuePiMessageLength

        fldpi                        # nacteni FP konstanty Pi
        fstp dword ptr number        # ulozeni do pameti (4 bajty)
        mov  eax, dword ptr number   # nacteni hodnoty, tentokrat to celociselneho registru
        printHexNumber eax           # vytiskneme celociselnou hodnotu v hexa tvaru



        println                      # odradkovani

        exit                         # ukonceni aplikace
</pre>

<p>Překlad a slinkování se provede následujícím způsobem:</p>

<pre>
as -g --32 main.s -o main.o
ld -m elf_i386 -s main.o
</pre>

<p>Výsledkem je binární soubor spustitelný jak na 32bitovém, tak i na 64bitovém systému.</p>

<p>Pro překlad upraveného kódu určeného pouze pro 64bitový systém použijte příkazy:</p>

<pre>
as -g  main_x86_64.s -o main.o
ld -s main.o
</pre>

<p>Pro zajímavost se podívejme na to, jakým způsobem se FPU instrukce přeložily do nativního kódu:</p>

<p>32bitový systém i386:</p>

<pre>
00000026 &lt;_start&gt;:
  26:   b9 1a 00 00 00          mov    ecx,0x1a
  2b:   ba 06 00 00 00          mov    edx,0x6
  30:   e8 cb ff ff ff          call   0 &lt;write_message&gt;
<strong>  35:   d9 ee                   fldz   </strong>
<strong>  37:   d9 1d 00 00 00 00       fstp   DWORD PTR ds:0x0</strong>
  3d:   a1 00 00 00 00          mov    eax,ds:0x0
  42:   60                      pusha  
  43:   89 c2                   mov    edx,eax
  45:   bb 10 00 00 00          mov    ebx,0x10
  4a:   e8 be ff ff ff          call   d &lt;hex2string&gt;
  4f:   b9 02 00 00 00          mov    ecx,0x2
  54:   ba 18 00 00 00          mov    edx,0x18
  59:   e8 a2 ff ff ff          call   0 &lt;write_message&gt;
  5e:   61                      popa   
  5f:   b9 20 00 00 00          mov    ecx,0x20
  64:   ba 06 00 00 00          mov    edx,0x6
  69:   e8 92 ff ff ff          call   0 &lt;write_message&gt;
<strong>  6e:   d9 e8                   fld1   </strong>
<strong>  70:   d9 1d 00 00 00 00       fstp   DWORD PTR ds:0x0</strong>
  76:   a1 00 00 00 00          mov    eax,ds:0x0
  7b:   60                      pusha  
  7c:   89 c2                   mov    edx,eax
  7e:   bb 10 00 00 00          mov    ebx,0x10
  83:   e8 85 ff ff ff          call   d &lt;hex2string&gt;
  88:   b9 02 00 00 00          mov    ecx,0x2
  8d:   ba 18 00 00 00          mov    edx,0x18
  92:   e8 69 ff ff ff          call   0 &lt;write_message&gt;
  97:   61                      popa   
  98:   b9 26 00 00 00          mov    ecx,0x26
  9d:   ba 06 00 00 00          mov    edx,0x6
  a2:   e8 59 ff ff ff          call   0 &lt;write_message&gt;
<strong>  a7:   d9 eb                   fldpi  </strong>
<strong>  a9:   d9 1d 00 00 00 00       fstp   DWORD PTR ds:0x0</strong>
  af:   a1 00 00 00 00          mov    eax,ds:0x0
  b4:   60                      pusha  
  b5:   89 c2                   mov    edx,eax
  b7:   bb 10 00 00 00          mov    ebx,0x10
  bc:   e8 4c ff ff ff          call   d &lt;hex2string&gt;
  c1:   b9 02 00 00 00          mov    ecx,0x2
  c6:   ba 18 00 00 00          mov    edx,0x18
  cb:   e8 30 ff ff ff          call   0 &lt;write_message&gt;
  d0:   61                      popa   
  d1:   b9 00 00 00 00          mov    ecx,0x0
  d6:   ba 02 00 00 00          mov    edx,0x2
  db:   e8 20 ff ff ff          call   0 &lt;write_message&gt;
  e0:   b8 01 00 00 00          mov    eax,0x1
  e5:   bb 00 00 00 00          mov    ebx,0x0
  ea:   cd 80                   int    0x80
</pre>

<p>64bitový systém x86-64:</p>

<pre>
0000000000000028 &lt;_start&gt;:
  28:	b9 00 00 00 00       	mov    ecx,0x0
  2d:	ba 06 00 00 00       	mov    edx,0x6
  32:	e8 c9 ff ff ff       	call   0 &lt;write_message&gt;
<strong>  37:	d9 ee                	fldz   </strong>
<strong>  39:	d9 1c 25 00 00 00 00 	fstp   DWORD PTR ds:0x0</strong>
  40:	8b 04 25 00 00 00 00 	mov    eax,DWORD PTR ds:0x0
  47:	50                   	push   rax
  48:	53                   	push   rbx
  49:	51                   	push   rcx
  4a:	52                   	push   rdx
  4b:	89 c2                	mov    edx,eax
  4d:	bb 00 00 00 00       	mov    ebx,0x0
  52:	e8 b6 ff ff ff       	call   d &lt;hex2string&gt;
  57:	b9 00 00 00 00       	mov    ecx,0x0
  5c:	ba 18 00 00 00       	mov    edx,0x18
  61:	e8 9a ff ff ff       	call   0 &lt;write_message&gt;
  66:	5a                   	pop    rdx
  67:	59                   	pop    rcx
  68:	5b                   	pop    rbx
  69:	58                   	pop    rax
  6a:	b9 00 00 00 00       	mov    ecx,0x0
  6f:	ba 06 00 00 00       	mov    edx,0x6
  74:	e8 87 ff ff ff       	call   0 &lt;write_message&gt;
<strong>  79:	d9 e8                	fld1   </strong>
<strong>  7b:	d9 1c 25 00 00 00 00 	fstp   DWORD PTR ds:0x0</strong>
  82:	8b 04 25 00 00 00 00 	mov    eax,DWORD PTR ds:0x0
  89:	50                   	push   rax
  8a:	53                   	push   rbx
  8b:	51                   	push   rcx
  8c:	52                   	push   rdx
  8d:	89 c2                	mov    edx,eax
  8f:	bb 00 00 00 00       	mov    ebx,0x0
  94:	e8 74 ff ff ff       	call   d &lt;hex2string&gt;
  99:	b9 00 00 00 00       	mov    ecx,0x0
  9e:	ba 18 00 00 00       	mov    edx,0x18
  a3:	e8 58 ff ff ff       	call   0 &lt;write_message&gt;
  a8:	5a                   	pop    rdx
  a9:	59                   	pop    rcx
  aa:	5b                   	pop    rbx
  ab:	58                   	pop    rax
  ac:	b9 00 00 00 00       	mov    ecx,0x0
  b1:	ba 06 00 00 00       	mov    edx,0x6
  b6:	e8 45 ff ff ff       	call   0 &lt;write_message&gt;
<strong>  bb:	d9 eb                	fldpi  </strong>
<strong>  bd:	d9 1c 25 00 00 00 00 	fstp   DWORD PTR ds:0x0</strong>
  c4:	8b 04 25 00 00 00 00 	mov    eax,DWORD PTR ds:0x0
  cb:	50                   	push   rax
  cc:	53                   	push   rbx
  cd:	51                   	push   rcx
  ce:	52                   	push   rdx
  cf:	89 c2                	mov    edx,eax
  d1:	bb 00 00 00 00       	mov    ebx,0x0
  d6:	e8 32 ff ff ff       	call   d &lt;hex2string&gt;
  db:	b9 00 00 00 00       	mov    ecx,0x0
  e0:	ba 18 00 00 00       	mov    edx,0x18
  e5:	e8 16 ff ff ff       	call   0 &lt;write_message&gt;
  ea:	5a                   	pop    rdx
  eb:	59                   	pop    rcx
  ec:	5b                   	pop    rbx
  ed:	58                   	pop    rax
  ee:	b9 00 00 00 00       	mov    ecx,0x0
  f3:	ba 02 00 00 00       	mov    edx,0x2
  f8:	e8 03 ff ff ff       	call   0 &lt;write_message&gt;
  fd:	b8 01 00 00 00       	mov    eax,0x1
 102:	bb 00 00 00 00       	mov    ebx,0x0
 107:	cd 80                	int    0x80
</pre>

<p>V&nbsp;obou případech si povšimněte, že všechny FPU operace začínají
prefixovým bajtem s&nbsp;hodnotou <strong>D9</strong>, za nímž u jednodušších
instrukcí následuje jediný bajt s&nbsp;operačním kódem a u instrukcí
<strong>FLD</strong> a <strong>FST</strong> navíc ještě adresa ze které se mají
přečíst data popř.&nbsp;na kterou se mají data naopak uložit.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Jak přečíst a dekódovat vytištěné výsledky?</h2>

<p>Pokud přeložený program spustíme, měly by se na standardní výstup vypsat následující tři řádky:</p>

<pre>
0.0: Hex value: 0x00000000
1.0: Hex value: 0x3F800000
Pi:  Hex value: 0x40490FDB
</pre>

<p>Vidíme, že jsme pro každou hodnotu reprezentovanou v&nbsp;systému plovoucí řádové čárky dostali hexadeciální 32bitové číslo, které reprezentuje binární &bdquo;otisk&ldquo; 32bitové hodnoty typu <i>single</i>. S&nbsp;formátem <i>single</i> jsme se seznámili <a href="https://mojefedora.cz/pouziti-assembleru-v-linuxu-prace-s-matematickym-koprocesorem/">v&nbsp;předchozím článku</a>, takže jen stručně:</p>

<table>
<tr><th>bit</th><td>31</td><td>30 &nbsp; 29 ... 24 &nbsp; 23</td><td>22 &nbsp; 21 ... 3 &nbsp; 2 &nbsp; 1 &nbsp; 0</td></tr>
<tr><th>význam</th><td>s</td><td>exponent (8 bitů)</td><td>mantisa (23 bitů)</td></tr>
</table>

<p>Exponent je posunutý o <i>bias</i> nastavený na hodnotu 127. Mantisa u normalizovaných čísel obsahuje jen čísla za (binární) řádovou čárkou, tudíž je k&nbsp;hodnotě mantisy nutné přičíst jedničku. Získané hodnoty tedy můžeme dekódovat:</p>

<table>
<tr><th>Hexa</th><th>Binárně</th><th>s</th><th>Exponent</th><th>Mantisa</th></tr>
<tr><td>0x00000000</td><td>00000000000000000000000000000000</td><td>+</td><td>0 (spec)</td><td>0</td></tr>
<tr><td>0x3F800000</td><td>00111111100000000000000000000000</td><td>+</td><td>127-127=0</td><td>1,0 + 0,0</td></tr>
<tr><td>0x40490FDB</td><td>01000000010010010000111111011011</td><td>+</td><td>128-127=1</td><td>1,0 + 0,57079637050628662109375</td></tr>
</table>

<p>První hodnota je zcela jednoznačně kladná nula, druhá hodnota je rovna 1,0&times;2<sup>0</sup>=1, třetí hodnota je pak rovna 1,57079637050628662109375&times;2<sup>1</sup>=&pi; (zde konkrétně přibližná hodnota 3.14159274101257324218750). Vidíme, že jak způsob uložení hodnot, tak i jejich zpětné ruční dekódování pracuje spolehlivě.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Pomocný program pro převod FPU hodnot do jejich hexadecimální podoby</h2>

<p>Hodnoty samozřejmě není nutné převádět ručně. Pro zpětný převod FP hodnot, tedy hodnot reprezentovaných v&nbsp;systému plovoucí řádové čárky do hexadecimální 32bitové reprezentace je možné použít i následující jednoduchý program napsaný v&nbsp;céčku. Pokud při spuštění programu specifikujete na příkazové řádce FP hodnotu, například 0.5, vypíše se ihned její obraz v&nbsp;paměti, tj.&nbsp;to, jak je číslo interně reprezentováno (logiku programu lze v&nbsp;případě potřeby jednoduše i obrátit tak, aby převádět hexadecimální reprezentaci na FP hodnotu):</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

union {
    float flt;
    int   hex;
} float_hex;

int main(int argc, char **argv)
{
    if (argc == 2) {
        float_hex.flt = atof(argv[1]);
        printf("%08x\n", float_hex.hex);
    }
    return 0;
}
</pre>

<p>Funkci programu si můžeme jednoduše odzkoušet:</p>

<pre>
<strong>gcc -o fp2hex fp2hex.c </strong>
&nbsp;
<strong>./fp2hex 0</strong>
00000000
&nbsp;
<strong>./fp2hex 1</strong>
3f800000
&nbsp;
<strong>./fp2hex -1</strong>
bf800000
&nbsp;
<strong>./fp2hex 3.14</strong>
40490fdb
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Základní aritmetické operace v&nbsp;praxi</h2>

<p>Minule jsme se taktéž seznámili s&nbsp;instrukcemi pro základní aritmetické operace. Jedná se o tyto instrukce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>FADD</td><td>součet</td></tr>
<tr><td>2</td><td>FSUB</td><td>rozdíl</td></tr>
<tr><td>3</td><td>FSUBR</td><td>rozdíl, ale operandy jsou prohozeny</td></tr>
<tr><td>4</td><td>FMUL</td><td>součin</td></tr>
<tr><td>5</td><td>FDIV</td><td>podíl</td></tr>
<tr><td>6</td><td>FDIVR</td><td>podíl, ale operandy jsou prohozeny</td></tr>
</table>

<p>U všech těchto instrukcí lze navíc specifikovat příponu <strong>P</strong>, podobně jako u <strong>FST/FSTP</strong>. Pokud je tato přípona uvedena, budou ze zásobníku tvořeném pracovními registry odstraněny oba vstupní operandy, a teprve až poté se na zásobník uloží výsledek aritmetické operace. To mj.&nbsp;znamená, že součet dvou hodnot (zde konkrétně součet dvou jedniček) je možné implementovat následujícím způsobem:</p>

<pre>
fld1                         # nacteni FP konstanty 1.0
fld1                         # nacteni FP konstanty 1.0
faddp                        # soucet obou hodnot (1.0+1.0)
fstp dword ptr number        # ulozeni do pameti (4 bajty)
&nbsp;
mov  eax, dword ptr number   # nacteni hodnoty, tentokrat to celociselneho registru
printHexNumber eax           # vytiskneme celociselnou hodnotu v hexa tvaru
</pre>

<p>Ukázka použití základních aritmetických operací tvoří základ pro dnešní druhý demonstrační příklad, jehož zdrojový kód bude uveden <a href="#k08">v&nbsp;osmé kapitole</a>.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Složitější výrazy a práce se zásobníkem operandů</h2>

<p>Způsob načtení konstant do pracovních registrů (a tím pádem i do zásobníku) matematického koprocesoru již známe, takže si nyní již můžeme ukázat, jak se provádí základní aritmetické operace. Začneme podobně jako žáčci v&nbsp;první třídě &ndash; součtem dvou jedniček. To se v&nbsp;assembleru provede velmi jednoduše: nejdříve se na vrchol zásobníku, tj.&nbsp;do pracovního registru st(0), uloží první konstanta 1.0, a ve druhém kroku se na posunutý vrchol zásobníku (tj.&nbsp;do sousedního pracovního registru) uloží druhá konstanta 1.0. V&nbsp;kroku třetím se provede instrukce <strong>FADDP</strong>, která nejenže obě hodnoty uložené na vrcholu zásobníku a těsně pod ním sečte, ale navíc je ještě ze zásobníku odstraní (odstranění druhého operandu je zajištěno použitím <strong>FADDP</strong> namísto <strong>FADD</strong>). Celý výpočet tedy může vypadat takto:</p>

<pre>
fld1                         # nacteni FP konstanty 1.0
fld1                         # nacteni FP konstanty 1.0
faddp                        # soucet obou hodnot (1.0+1.0)
</pre>

<p>Podívejme se nyní na součet tří hodnot. Zde můžeme postupovat několika způsoby, z&nbsp;nichž nejjednodušší způsob spočívá v&nbsp;uložení všech tří hodnot na zásobník s&nbsp;následným použitím dvojice instrukcí <strong>FADDP</strong>. První instrukce sečte poslední dvě hodnoty uložené na zásobníku, takže jeho nový obsah bude [1.0, 2.0], druhá instrukce pak sečte 1.0+2.0 s&nbsp;uložením celkového výsledku zpět:</p>

<pre>
fld1                         # nacteni FP konstanty 1.0
fld1                         # nacteni FP konstanty 1.0
fld1                         # nacteni FP konstanty 1.0
faddp
faddp                        # soucet vsech tri hodnot (1.0+(1.0+1.0))
</pre>

<p>Pokud budeme chtít vynásobit hodnoty 2.0 a 3.0, můžeme oba výpočty spojit dohromady a díky tomu, že zásobník má kapacitu pro osm hodnot, vyhneme se jakýmkoli přesunům dat mezi pracovními registry</p>

<pre>
fld1                         # nacteni FP konstanty 1.0
fld1                         # nacteni FP konstanty 1.0
faddp                        # soucet obou hodnot (1.0+1.0)
                             # nyni je na zasobniku ulozena hodnota 2

fld1                         # nacteni FP konstanty 1.0
fld1                         # nacteni FP konstanty 1.0
fld1                         # nacteni FP konstanty 1.0
faddp
faddp                        # soucet vsech tri hodnot (1.0+(1.0+1.0))
                             # vysledek 3.0 je ulozen zpet na zasobnik

fmulp                        # nyni jsou na zasobniku ulozeny hodnoty 2 a 3 ktere vynasobime

fstp dword ptr number        # ulozeni do pameti (4 bajty)
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Druhý demonstrační příklad: základní aritmetické operace</h2>

<p>Ve druhém demonstračním příkladu je ukázán způsob práce se zásobníkem tvořeným osmi pracovními registry matematického koprocesoru. Nejprve je vytištěna hodnota 1.0 způsobem, který již známe z&nbsp;předchozího příkladu. Následně je proveden součet dvou hodnot 1.0 s&nbsp;vytištěním výsledku této operace. Poslední část příkladu provádí výpočet popsaný <a href="#k07">v&nbsp;předchozí kapitole</a>, tj.&nbsp;2.0*3.0, ve skutečnosti se však počítá (1.0+1.0)*(1.0+(1.0+1.0)). Po překladu a spuštění by se měly na standardním výstupu objevit následující řádky:</p>

<pre>
1.0:      Hex value: 0x3F800000
1.0+1.0:  Hex value: 0x40000000
2.0*3.0:  Hex value: 0x40C00000
</pre>

<p>Zdrojový kód druhého demonstračního příkladu vypadá takto:</p>

<pre>
# asmsyntax=as

# Program pro otestovani zakladnich FPU operaci
# - pro zapis je pouzita "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix



# Nacteni definice makra pro ukonceni aplikace
.include "exit.s"

# Nacteni maker pro (opakovany) tisk zpravy i prislusne subrutiny
.include "writeMessage.s"

# Nacteni makra pro vytisteni hexadecimalni 32bitove hodnoty
# spolecne s makrem je nactena i prislusna subrutina
.include "printHexNumber.s"



#-----------------------------------------------------------------------------
.section .data
fpuValueOneMessage:
        .string "1.0:      "                        # zprava
fpuValueOneMessageLength = $ - fpuValueOneMessage   # delka zpravy

fpuAddResultMessage:
        .string "1.0+1.0:  "                        # zprava
fpuAddResultMessageLength = $ - fpuAddResultMessage # delka zpravy

fpuMulResultMessage:
        .string "2.0*3.0:  "                        # zprava
fpuMulResultMessageLength = $ - fpuMulResultMessage # delka zpravy



#-----------------------------------------------------------------------------
.section .bss

.lcomm number, 4                     # na toto misto se bude ukladat konstanta typu float



#-----------------------------------------------------------------------------
.section .text
        .global _start               # tento symbol ma byt dostupny i linkeru

_start:
        writeMessage fpuValueOneMessage, fpuValueOneMessageLength

        fld1                         # nacteni FP konstanty 1.0
        fstp dword ptr number        # ulozeni do pameti (4 bajty)
        mov  eax, dword ptr number   # nacteni hodnoty, tentokrat to celociselneho registru
        printHexNumber eax           # vytiskneme celociselnou hodnotu v hexa tvaru



        writeMessage fpuAddResultMessage, fpuAddResultMessageLength

        fld1                         # nacteni FP konstanty 1.0
        fld1                         # nacteni FP konstanty 1.0
        faddp                        # soucet obou hodnot (1.0+1.0)
        fstp dword ptr number        # ulozeni do pameti (4 bajty)
        mov  eax, dword ptr number   # nacteni hodnoty, tentokrat to celociselneho registru
        printHexNumber eax           # vytiskneme celociselnou hodnotu v hexa tvaru



        writeMessage fpuMulResultMessage, fpuMulResultMessageLength

        fld1                         # nacteni FP konstanty 1.0
        fld1                         # nacteni FP konstanty 1.0
        faddp                        # soucet obou hodnot (1.0+1.0)

        fld1                         # nacteni FP konstanty 1.0
        fld1                         # nacteni FP konstanty 1.0
        fld1                         # nacteni FP konstanty 1.0
        faddp
        faddp                        # soucet vsech tri hodnot (1.0+(1.0+1.0))

        fmulp                        # nyni jsou na zasobniku ulozeny hodnoty 2 a 3 ktere vynasobime

        fstp dword ptr number        # ulozeni do pameti (4 bajty)
        mov  eax, dword ptr number   # nacteni hodnoty, tentokrat to celociselneho registru
        printHexNumber eax           # vytiskneme celociselnou hodnotu v hexa tvaru



        println                      # odradkovani

        exit                         # ukonceni aplikace
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Dělení kladnou a zápornou nulou</h2>

<p>V&nbsp;předchozím demonstračním příkladu jsme si mj.&nbsp;ukázali instrukci <strong>FMULP</strong> sloužící k&nbsp;vynásobení obou vstupních operandů. Dá se tedy předpokládat, že bude existovat i opačná instrukce určená pro dělení operandů. Taková instrukce skutečně existuje a její varianty se jmenují <strong>FDIV</strong> a <strong>FDIVP</strong>. Samotné dělení je prováděno obvyklým způsobem, ovšem zaměřme se nyní na to, co se stane, pokud se provádí dělení nulou. Ve formátech single i double je znaménko reprezentováno samostatným bitem, což mj.&nbsp;znamená, že existuje kladná a záporná nula.</p>

<p>Dělení kladnou nulou je jednoduché a lze ho realizovat například takto:</p>

<pre>
fld1                         # nacteni FP konstanty 1.0
fldz                         # nacteni FP konstanty 0.0
fdivp                        # deleni nulou
</pre>

<p>Dělení zápornou nulou vyžaduje použití instrukce <strong>FCHS</strong>, která otočí znaménko svého operandu (zde konkrétně oné nuly):</p>

<pre>
fld1                         # nacteni FP konstanty 1.0
fldz                         # nacteni FP konstanty 0.0
fchs                         # zmena znamenka nuly
fdivp                        # deleni zapornou nulou
</pre>

<p>Jak budou vypadat výsledky dělení?</p>

<pre>
1/0:   Hex value: 0x7F800000
-1/0:  Hex value: 0xFF800000
</pre>

<p>Po převodu na binární tvar a rozdělení bitových polí:</p>

<table>
<tr><th>Hexa</th><th>Binárně</th><th>s</th><th>Exponent</th><th>Mantisa</th></tr>
<tr><td>0x7F800000</td><td>01111111100000000000000000000000</td><td>+</td><td>255 (spec)</td><td>0</td></tr>
<tr><td>0xFF800000</td><td>11111111100000000000000000000000</td><td>-</td><td>255 (spec)</td><td>0</td></tr>
</table>

<p>Oba výsledky se od sebe liší jen nejvyšším bitem, což je znaménko. Dále následuje osm bitů exponentu. Tyto bity jsou v&nbsp;obou případech nastaveny na samé jedničky, samotný exponent je pak nulový. To odpovídá tabulce speciálních hodnot, s&nbsp;níž jsme se seznámili minule:</p>

<table>
<tr><th>s-bit</th><th>exponent</th><th>mantisa</th><th>význam</th><th>šestnáctkově</th></tr>
<tr><td>0</td><td>255</td><td>0</td><td>kladné nekonečno</td><td>0x7F800000</td></tr>
<tr><td>1</td><td>255</td><td>0</td><td>záporné nekonečno</td><td>0xFF800000</td></tr>
</table>



<p><a name="k10"></a></p>
<h2 id="k10">10. Dělení nuly nulou aneb práce s&nbsp;NaN</h2>

<p>Ještě jsme si však nevyzkoušeli další speciální případ &ndash; dělení 0/0. I to lze realizovat velmi snadno následujícími třemi instrukcemi:</p>

<pre>
fldz                         # nacteni FP konstanty 0.0
fldz                         # nacteni FP konstanty 0.0
fdivp                        # vypocet 0.0/0.0
</pre>

<p>Výsledkem bude hodnota:</p>

<pre>
0/0:   Hex value: 0xFFC00000
</pre>

<p>Po převodu na binární tvar a rozdělení bitových polí:</p>

<table>
<tr><th>Hexa</th><th>Binárně</th><th>s</th><th>Exponent</th><th>Mantisa</th></tr>
<tr><td>0xFFC00000</td><td>11111111110000000000000000000000</td><td>+</td><td>255 (spec)</td><td>dva nejvyšší bity jednička</td></tr>
</table>

<p>Opět nahlédněme do tabulky zveřejněné minule, abychom zjistili, co tato hodnota znamená:</p>

<table>
<tr><th>s-bit</th><th>exponent</th><th>mantisa</th><th>význam</th></tr>
<tr><td>0</td><td>255</td><td>&gt;0</td><td>NaN &ndash; not a number</td></tr>
<tr><td>1</td><td>255</td><td>&gt;0</td><td>NaN &ndash; not a number</td></tr>
</table>

<p>Vidíme, že vydělením nuly nulou (ať již kladnou či zápornou) získáme speciální hodnotu NaN. Většina dalších instrukcí sice NaN může akceptovat, ale výsledkem operace bude opět NaN, na což je zapotřebí dávat při programování (nejenom v&nbsp;assembleru) pozor.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Třetí demonstrační příklad: dělení nulou</h2>

<p>Dělení nenulové hodnoty kladnou i zápornou nulou jakož i dělení nuly nulou je ukázáno v&nbsp;dnešním třetím a současně i posledním demonstračním příkladu, jehož zdrojový kód je zobrazen pod tímto odstavcem. Ve všech třech případech se pro dělení používá instrukce <strong>FDIVP</strong>:</p>

<pre>
# asmsyntax=as

# Program pro otestovani deleni nulou
# - pro zapis je pouzita "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix



# Nacteni definice makra pro ukonceni aplikace
.include "exit.s"

# Nacteni maker pro (opakovany) tisk zpravy i prislusne subrutiny
.include "writeMessage.s"

# Nacteni makra pro vytisteni hexadecimalni 32bitove hodnoty
# spolecne s makrem je nactena i prislusna subrutina
.include "printHexNumber.s"



#-----------------------------------------------------------------------------
.section .data
fpuDivideByZeroMessage:
        .string "1/0:   "                        # zprava
fpuDivideByZeroMessageLength = $ - fpuDivideByZeroMessage   # delka zpravy

fpuDivideByNegativeZeroMessage:
        .string "-1/0:  "                        # zprava
fpuDivideByNegativeZeroMessageLength = $ - fpuDivideByNegativeZeroMessage   # delka zpravy

fpuDivideZeroByZeroMessage:
        .string "0/0:   "                        # zprava
fpuDivideZeroByZeroMessageLength = $ - fpuDivideZeroByZeroMessage   # delka zpravy



#-----------------------------------------------------------------------------
.section .bss

.lcomm number, 4                     # na toto misto se bude ukladat konstanta typu float



#-----------------------------------------------------------------------------
.section .text
        .global _start               # tento symbol ma byt dostupny i linkeru

_start:
        writeMessage fpuDivideByZeroMessage, fpuDivideByZeroMessageLength

        fld1                         # nacteni FP konstanty 1.0
        fldz                         # nacteni FP konstanty 0.0
        fdivp                        # deleni nulou
        fstp dword ptr number        # ulozeni do pameti (4 bajty)
        mov  eax, dword ptr number   # nacteni hodnoty, tentokrat to celociselneho registru
        printHexNumber eax           # vytiskneme celociselnou hodnotu v hexa tvaru



        writeMessage fpuDivideByNegativeZeroMessage, fpuDivideByNegativeZeroMessageLength

        fld1                         # nacteni FP konstanty 1.0
        fldz                         # nacteni FP konstanty 0.0
        fchs                         # zmena znamenka nuly
        fdivp                        # deleni zapornou nulou
        fstp dword ptr number        # ulozeni do pameti (4 bajty)
        mov  eax, dword ptr number   # nacteni hodnoty, tentokrat to celociselneho registru
        printHexNumber eax           # vytiskneme celociselnou hodnotu v hexa tvaru



        writeMessage fpuDivideZeroByZeroMessage, fpuDivideZeroByZeroMessageLength

        fldz                         # nacteni FP konstanty 0.0
        fldz                         # nacteni FP konstanty 0.0
        fdivp                        # vypocet 0.0/0.0
        fstp dword ptr number        # ulozeni do pameti (4 bajty)
        mov  eax, dword ptr number   # nacteni hodnoty, tentokrat to celociselneho registru
        printHexNumber eax           # vytiskneme celociselnou hodnotu v hexa tvaru



        println                      # odradkovani

        exit                         # ukonceni aplikace

</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Pomocné zdrojové soubory</h2>

<p>Demonstrační příklady popsané v&nbsp;předchozích kapitolách používají makra a subrutiny (procedury), s&nbsp;nimiž jsme se již seznámili minule a předminule. Tyto makra a subrutiny jsou uloženy v&nbsp;samostatných souborech přidávaných do hlavního programu s&nbsp;využitím direktivy <strong>.include</strong>.</p>

<h3>exit.s</h3>

<pre>
# asmsyntax=as

# Makro pro ukonceni procesu v Linuxu.
# - pro zapis je pouzita "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

sys_exit   = 1                       # cislo syscallu pro ukonceni procesu

# Deklarace makra pro ukonceni aplikace
.macro exit
        mov   eax, sys_exit          # cislo sycallu pro funkci "exit"
        mov   ebx, 0                 # exit code = 0
        int   0x80                   # volani Linuxoveho kernelu
.endm
</pre>

<h3>writeMessage.s</h3>

<pre>
# asmsyntax=as

# Makro pro tisk zpravy na standardni vystup.
# - pro zapis je pouzita "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

# Linux kernel system call table
sys_write  = 4
std_output = 1



# Deklarace makra pro vytisteni zpravy na standardni vystup
.macro writeMessage message,messageLength
        mov   ecx, offset \message   # adresa retezce, ktery se ma vytisknout
        mov   edx, \messageLength    # pocet znaku, ktere se maji vytisknout
        call  write_message          # vytisknout zpravu "Zero flag not set"
.endm



# Podprogram pro vytisteni zpravy na standardni vystup
# Ocekava se, ze v ecx bude adresa zpravy a v edx jeji delka
write_message:
        mov   eax, sys_write         # cislo syscallu pro funkci "write"
        mov   ebx, std_output        # standardni vystup
        int   0x80
        ret



# Deklarace makra pro vytisteni znaku konce radku (provede se tedy odradkovani)
.macro println
        writeMessage printlnMessage,printlnLength
.endm



#-----------------------------------------------------------------------------
.section .data
# Miniretezec pouzivany makrem println
printlnMessage:
        .string "\n"
printlnLength = $ - printlnMessage
</pre>

<h3>printHexNumber.s (32bitová varianta)</h3>

<pre>
# asmsyntax=as

# Makro pro pripravu a tisk hexadecimalni hodnoty na standardni vystup.
# - pro zapis je pouzita "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix



# Makro pro vypis 32bitove hexadecimalni hodnoty na standardni vystup
# Jedinym parametrem makra je hodnota (konstanta)
.macro printHexNumber value
        pusha                              # uschovat vsechny registry na zasobnik
        mov  edx, \value                   # hodnotu pro tisk ulozit do registru EDX
        mov  ebx, offset hexValueTemplate  # adresu pro retezec ulozit do registru EBX
        call hex2string                    # zavolani prislusne subrutiny pro prevod na string
        writeMessage hexValueMessage, hexValueMessageLen # retezec je naplnen, tak ho muzeme vytisknout
        popa                               # obnovit obsah vsech registru
.endm



#-----------------------------------------------------------------------------
.section .data
hexValueMessage:
        .string "Hex value: 0x"             # prvni cast zpravy
hexValueTemplate:                           # druha cast zpravy ma vlastni navesti
        .string "????????\n"                # otazniky budou prepsany
hexValueMessageLen = $ - hexValueMessage    # delka zpravy



#-----------------------------------------------------------------------------
.section .text

# Subrutina urcena pro prevod 32bitove hexadecimalni hodnoty na retezec
# Vstup: EDX - hodnota, ktera se ma prevest na retezec
#        EBX - adresa jiz drive alokovaneho retezce (resp. osmice bajtu)
hex2string:
                  mov cl,  8                # pocet opakovani smycky

print_one_digit:  rol edx, 4                # rotace doleva znamena, ze se do spodnich 4 bitu nasune dalsi cifra
                  mov al, dl                # nechceme porusit obsah vstupni hodnoty v EDX, proto pouzijeme AL
                  and al, 0x0f              # maskovani, potrebujeme pracovat jen s jednou cifrou
                  cmp al, 10                # je cifra vetsi nebo rovna 10?
                  jl  store_digit           # neni, pouze prevest 0..9 na ASCII hodnotu '0'..'9'

alpha_digit:      add al, 'A'-10-'0'        # prevod hodnoty 10..15 na znaky 'A'..'F'

store_digit:      add al, '0'
                  mov byte ptr [ebx], al    # ulozeni cifry do retezce
                  inc ebx                   # dalsi ulozeni v retezci o znak dale
                  dec cl                    # snizeni pocitadla smycky
                  jnz print_one_digit       # a opakovani smycky, dokud se nedosahlo nuly

                  ret                       # navrat ze subrutiny
</pre>

<h3>printHexNumber_64.s (64bitová varianta)</h3>

<pre>
# asmsyntax=as

# Makro pro pripravu a tisk hexadecimalni hodnoty na standardni vystup.
# - pro zapis je pouzita "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix



# Makro pro vypis 32bitove hexadecimalni hodnoty na standardni vystup
# Jedinym parametrem makra je hodnota (konstanta)
.macro printHexNumber value
        push rax
        push rbx
        push rcx
        push rdx                           # uschovat vsechny registry na zasobnik
        mov  edx, \value                   # hodnotu pro tisk ulozit do registru EDX
        mov  ebx, offset hexValueTemplate  # adresu pro retezec ulozit do registru EBX
        call hex2string                    # zavolani prislusne subrutiny pro prevod na string
        writeMessage hexValueMessage, hexValueMessageLen # retezec je naplnen, tak ho muzeme vytisknout
        pop rdx
        pop rcx
        pop rbx
        pop rax                            # obnovit obsah vsech registru
.endm



#-----------------------------------------------------------------------------
.section .data
hexValueMessage:
        .string "Hex value: 0x"             # prvni cast zpravy
hexValueTemplate:                           # druha cast zpravy ma vlastni navesti
        .string "????????\n"                # otazniky budou prepsany
hexValueMessageLen = $ - hexValueMessage    # delka zpravy



#-----------------------------------------------------------------------------
.section .text

# Subrutina urcena pro prevod 32bitove hexadecimalni hodnoty na retezec
# Vstup: EDX - hodnota, ktera se ma prevest na retezec
#        EBX - adresa jiz drive alokovaneho retezce (resp. osmice bajtu)
hex2string:
                  mov cl,  8                # pocet opakovani smycky

print_one_digit:  rol edx, 4                # rotace doleva znamena, ze se do spodnich 4 bitu nasune dalsi cifra
                  mov al, dl                # nechceme porusit obsah vstupni hodnoty v EDX, proto pouzijeme AL
                  and al, 0x0f              # maskovani, potrebujeme pracovat jen s jednou cifrou
                  cmp al, 10                # je cifra vetsi nebo rovna 10?
                  jl  store_digit           # neni, pouze prevest 0..9 na ASCII hodnotu '0'..'9'

alpha_digit:      add al, 'A'-10-'0'        # prevod hodnoty 10..15 na znaky 'A'..'F'

store_digit:      add al, '0'
                  mov byte ptr [ebx], al    # ulozeni cifry do retezce
                  inc ebx                   # dalsi ulozeni v retezci o znak dale
                  dec cl                    # snizeni pocitadla smycky
                  jnz print_one_digit       # a opakovani smycky, dokud se nedosahlo nuly

                  ret                       # navrat ze subrutiny
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny tři dnes popisované demonstrační příklady byly, podobně jako ve všech předchozích částech tohoto seriálu, společně s&nbsp;podpůrnými skripty určenými pro jejich překlad či naopak pro disassembling, uloženy do GIT repositáře dostupného na adrese <a href="https://github.com/tisnik/presentations/">https://github.com/tisnik/presentations/</a>. Všechny příklady jsou určeny pro GNU Assembler a používají Intel syntaxi, která je pro mnoho programátorů čitelnější, než původní AT&amp;T syntaxe. Následují tabulky obsahující odkazy na zdrojové kódy příkladů i na již zmíněné podpůrné skripty:</p>

<h3>První demonstrační příklad: vytištění hodnot 0.0, 1.0 a Pi v&nbsp;hexadecimálním tvaru</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>main.s</td><td>hlavní program pro GNU Assembler, varianta pro i386</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/40_fpu_constants/main.s">https://github.com/tisnik/presentations/tree/master/assembler/40_fpu_constants/main.s</a></td></tr>
<tr><td>2</td><td>main_64bit.s</td><td>hlavní program pro GNU Assembler, varianta pro x86-64</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/40_fpu_constants/main_64bit.s">https://github.com/tisnik/presentations/tree/master/assembler/40_fpu_constants/main_64bit.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>exit.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/40_fpu_constants/exit.s">https://github.com/tisnik/presentations/tree/master/assembler/40_fpu_constants/exit.s</a></td></tr>
<tr><td>4</td><td>writeMessage.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/40_fpu_constants/writeMessage.s">https://github.com/tisnik/presentations/tree/master/assembler/40_fpu_constants/writeMessage.s</a></td></tr>
<tr><td>5</td><td>printHexNumber.s</td><td>32bitová implementace makra a subrutiny pro převod hex2string</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/40_fpu_constants/printHexNumber.s">https://github.com/tisnik/presentations/tree/master/assembler/40_fpu_constants/printHexNumber.s</a></td></tr>
<tr><td>6</td><td>printHexNumber_64bit.s</td><td>64bitová implementace makra a subrutiny pro převod hex2string</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/40_fpu_constants/printHexNumber_64bit.s">https://github.com/tisnik/presentations/tree/master/assembler/40_fpu_constants/printHexNumber_64bit.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>assemble</td><td>skript pro překlad na procesorech i386</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/40_fpu_constants/assemble">https://github.com/tisnik/presentations/tree/master/assembler/40_fpu_constants/assemble</a></td></tr>
<tr><td>8</td><td>assemble_64bit</td><td>skript pro překlad na procesorech x86-64</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/40_fpu_constants/assemble_64bit">https://github.com/tisnik/presentations/tree/master/assembler/40_fpu_constants/assemble_64bit</a></td></tr>
<tr><td>9</td><td>disassemble</td><td>skript pro disassembling</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/40_fpu_constants/disassemble">https://github.com/tisnik/presentations/tree/master/assembler/40_fpu_constants/disassemble</a></td></tr>
</table>



<h3>Druhý demonstrační příklad: základní aritmetické operace</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>main.s</td><td>hlavní program pro GNU Assembler, varianta pro i386</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/41_fpu_arithmetic/main.s">https://github.com/tisnik/presentations/tree/master/assembler/41_fpu_arithmetic/main.s</a></td></tr>
<tr><td>2</td><td>main_64bit.s</td><td>hlavní program pro GNU Assembler, varianta pro x86-64</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/41_fpu_arithmetic/main_64bit.s">https://github.com/tisnik/presentations/tree/master/assembler/41_fpu_arithmetic/main_64bit.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>exit.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/41_fpu_arithmetic/exit.s">https://github.com/tisnik/presentations/tree/master/assembler/41_fpu_arithmetic/exit.s</a></td></tr>
<tr><td>4</td><td>writeMessage.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/41_fpu_arithmetic/writeMessage.s">https://github.com/tisnik/presentations/tree/master/assembler/41_fpu_arithmetic/writeMessage.s</a></td></tr>
<tr><td>5</td><td>printHexNumber.s</td><td>32bitová implementace makra a subrutiny pro převod hex2string</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/41_fpu_arithmetic/printHexNumber.s">https://github.com/tisnik/presentations/tree/master/assembler/41_fpu_arithmetic/printHexNumber.s</a></td></tr>
<tr><td>6</td><td>printHexNumber_64bit.s</td><td>64bitová implementace makra a subrutiny pro převod hex2string</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/41_fpu_arithmetic/printHexNumber_64bit.s">https://github.com/tisnik/presentations/tree/master/assembler/41_fpu_arithmetic/printHexNumber_64bit.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>assemble</td><td>skript pro překlad na procesorech i386</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/41_fpu_arithmetic/assemble">https://github.com/tisnik/presentations/tree/master/assembler/41_fpu_arithmetic/assemble</a></td></tr>
<tr><td>8</td><td>assemble_64bit</td><td>skript pro překlad na procesorech x86-64</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/41_fpu_arithmetic/assemble_64bit">https://github.com/tisnik/presentations/tree/master/assembler/41_fpu_arithmetic/assemble_64bit</a></td></tr>
<tr><td>9</td><td>disassemble</td><td>skript pro disassembling</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/41_fpu_arithmetic/disassemble">https://github.com/tisnik/presentations/tree/master/assembler/41_fpu_arithmetic/disassemble</a></td></tr>
</table>



<h3>Třetí demonstrační příklad: dělení nulou</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>main.s</td><td>hlavní program pro GNU Assembler, varianta pro i386</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/42_fpu_div_by_0/main.s">https://github.com/tisnik/presentations/tree/master/assembler/42_fpu_div_by_0/main.s</a></td></tr>
<tr><td>2</td><td>main_64bit.s</td><td>hlavní program pro GNU Assembler, varianta pro x86-64</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/42_fpu_div_by_0/main_64bit.s">https://github.com/tisnik/presentations/tree/master/assembler/42_fpu_div_by_0/main_64bit.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>exit.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/42_fpu_div_by_0/exit.s">https://github.com/tisnik/presentations/tree/master/assembler/42_fpu_div_by_0/exit.s</a></td></tr>
<tr><td>4</td><td>writeMessage.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/42_fpu_div_by_0/writeMessage.s">https://github.com/tisnik/presentations/tree/master/assembler/42_fpu_div_by_0/writeMessage.s</a></td></tr>
<tr><td>5</td><td>printHexNumber.s</td><td>32bitová implementace makra a subrutiny pro převod hex2string</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/42_fpu_div_by_0/printHexNumber.s">https://github.com/tisnik/presentations/tree/master/assembler/42_fpu_div_by_0/printHexNumber.s</a></td></tr>
<tr><td>6</td><td>printHexNumber_64bit.s</td><td>64bitová implementace makra a subrutiny pro převod hex2string</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/42_fpu_div_by_0/printHexNumber_64bit.s">https://github.com/tisnik/presentations/tree/master/assembler/42_fpu_div_by_0/printHexNumber_64bit.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>assemble</td><td>skript pro překlad na procesorech i386</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/42_fpu_div_by_0/assemble">https://github.com/tisnik/presentations/tree/master/assembler/42_fpu_div_by_0/assemble</a></td></tr>
<tr><td>8</td><td>assemble_64bit</td><td>skript pro překlad na procesorech x86-64</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/42_fpu_div_by_0/assemble_64bit">https://github.com/tisnik/presentations/tree/master/assembler/42_fpu_div_by_0/assemble_64bit</a></td></tr>
<tr><td>9</td><td>disassemble</td><td>skript pro disassembling</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/42_fpu_div_by_0/disassemble">https://github.com/tisnik/presentations/tree/master/assembler/42_fpu_div_by_0/disassemble</a></td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Simply FPU<br />
<a href="http://www.website.masmforum.com/tutorials/fptute/">http://www.website.masmforum.com/tutorials/fptute/</a>
</li>

<li>Art of Assembly language programming: The 80x87 Floating Point Coprocessors<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html</a>
</li>

<li>Art of Assembly language programming: The FPU Instruction Set<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html</a>
</li>

<li>INTEL 80387 PROGRAMMER'S REFERENCE MANUAL<br />
<a href="http://www.ragestorm.net/downloads/387intel.txt">http://www.ragestorm.net/downloads/387intel.txt</a>
</li>

<li>x86 Instruction Set Reference: FLD<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_100.html">http://x86.renejeschke.de/html/file_module_x86_id_100.html</a>
</li>

<li>x86 Instruction Set Reference: FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_101.html">http://x86.renejeschke.de/html/file_module_x86_id_101.html</a>
</li>

<li>x86 Instruction Set Reference: FLD<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_100.html">http://x86.renejeschke.de/html/file_module_x86_id_100.html</a>
</li>

<li>x86 Instruction Set Reference: FST/FSTP<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_117.html">http://x86.renejeschke.de/html/file_module_x86_id_117.html</a>
</li>

<li>x86 Instruction Set Reference: FADD/FADDP/FIADD<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_81.html">http://x86.renejeschke.de/html/file_module_x86_id_81.html</a>
</li>

<li>x86 Instruction Set Reference: FSUB/FSUBP/FISUB<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_121.html">http://x86.renejeschke.de/html/file_module_x86_id_121.html</a>
</li>

<li>x86 Instruction Set Reference: FDIV/FDIVP/FIDIV<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_91.html">http://x86.renejeschke.de/html/file_module_x86_id_91.html</a>
</li>

<li>x86 Instruction Set Reference: BT<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_22.html">http://x86.renejeschke.de/html/file_module_x86_id_22.html</a>
</li>

<li>x86 Instruction Set Reference: BTC<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_23.html">http://x86.renejeschke.de/html/file_module_x86_id_23.html</a>
</li>

<li>x86 Instruction Set Reference: BTR<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_24.html">http://x86.renejeschke.de/html/file_module_x86_id_24.html</a>
</li>

<li>x86 Instruction Set Reference: BTS<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_25.html">http://x86.renejeschke.de/html/file_module_x86_id_25.html</a>
</li>

<li>x86 Instruction Set Reference: BSF<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_19.html">http://x86.renejeschke.de/html/file_module_x86_id_19.html</a>
</li>

<li>x86 Instruction Set Reference: BSR<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_20.html">http://x86.renejeschke.de/html/file_module_x86_id_20.html</a>
</li>

<li>x86 Instruction Set Reference: BSWAP<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_21.html">http://x86.renejeschke.de/html/file_module_x86_id_21.html</a>
</li>

<li>x86 Instruction Set Reference: XCHG<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_328.html">http://x86.renejeschke.de/html/file_module_x86_id_328.html</a>
</li>

<li>x86 Instruction Set Reference: SETcc<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_288.html">http://x86.renejeschke.de/html/file_module_x86_id_288.html</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>The GNU Assembler Tutorial<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html">http://tigcc.ticalc.org/doc/gnuasm.html</a>
</li>

<li>The GNU Assembler - macros<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html#SEC109">http://tigcc.ticalc.org/doc/gnuasm.html#SEC109</a>
</li>

<li>ARM subroutines &amp; program stack<br />
<a href="http://www.toves.org/books/armsub/">http://www.toves.org/books/armsub/</a>
</li>

<li>Generating Mixed Source and Assembly List using GCC<br />
<a href="http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/">http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/</a>
</li>

<li>Calling subroutines<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm</a>
</li>

<li>ARM Assembly Language Programming<br />
<a href="http://peter-cockerell.net/aalp/html/frames.html">http://peter-cockerell.net/aalp/html/frames.html</a>
</li>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Intel x86 JUMP quick reference<br />
<a href="http://unixwiz.net/techtips/x86-jumps.html">http://unixwiz.net/techtips/x86-jumps.html</a>
</li>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Assembler pod Linuxem<br />
<a href="http://phoenix.inf.upol.cz/linux/prog/asm.html">http://phoenix.inf.upol.cz/linux/prog/asm.html</a>
</li>

<li>AT&amp;T Syntax versus Intel Syntax<br />
<a href="https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html">https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html</a>
</li>

<li>Linux Assembly website<br />
<a href="http://asm.sourceforge.net/">http://asm.sourceforge.net/</a>
</li>

<li>Using Assembly Language in Linux<br />
<a href="http://asm.sourceforge.net/articles/linasm.html">http://asm.sourceforge.net/articles/linasm.html</a>
</li>

<li>vasm<br />
<a href="http://sun.hasenbraten.de/vasm/">http://sun.hasenbraten.de/vasm/</a>
</li>

<li>vasm &ndash; dokumentace<br />
<a href="http://sun.hasenbraten.de/vasm/release/vasm.html">http://sun.hasenbraten.de/vasm/release/vasm.html</a>
</li>

<li>The Yasm Modular Assembler Project<br />
<a href="http://yasm.tortall.net/">http://yasm.tortall.net/</a>
</li>

<li>680x0:AsmOne<br />
<a href="http://www.amigacoding.com/index.php/680x0:AsmOne">http://www.amigacoding.com/index.php/680x0:AsmOne</a>
</li>

<li>ASM-One Macro Assembler<br />
<a href="http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler">http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler</a>
</li>

<li>ASM-One pages<br />
<a href="http://www.theflamearrows.info/documents/asmone.html">http://www.theflamearrows.info/documents/asmone.html</a>
</li>

<li>Základní informace o ASM-One<br />
<a href="http://www.theflamearrows.info/documents/asminfo.html">http://www.theflamearrows.info/documents/asminfo.html</a>
</li>

<li>Linux Syscall Reference<br />
<a href="http://syscalls.kernelgrok.com/">http://syscalls.kernelgrok.com/</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>IBM System 360/370 Compiler and Historical Documentation<br />
<a href="http://www.edelweb.fr/Simula/">http://www.edelweb.fr/Simula/</a>
</li>

<li>IBM 700/7000 series<br />
<a href="http://en.wikipedia.org/wiki/IBM_700/7000_series">http://en.wikipedia.org/wiki/IBM_700/7000_series</a>
</li>

<li>IBM System/360<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/360">http://en.wikipedia.org/wiki/IBM_System/360</a>
</li>

<li>IBM System/370<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/370">http://en.wikipedia.org/wiki/IBM_System/370</a>
</li>

<li>Mainframe family tree and chronology<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html</a>
</li>

<li>704 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html</a>
</li>

<li>705 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html</a>
</li>

<li>The IBM 704<br />
<a href="http://www.columbia.edu/acis/history/704.html">http://www.columbia.edu/acis/history/704.html</a>
</li>

<li>IBM Mainframe album<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html</a>
</li>

<li>Osmibitové muzeum<br />
<a href="http://osmi.tarbik.com/">http://osmi.tarbik.com/</a>
</li>

<li>Tesla PMI-80<br />
<a href="http://osmi.tarbik.com/cssr/pmi80.html">http://osmi.tarbik.com/cssr/pmi80.html</a>
</li>

<li>PMI-80<br />
<a href="http://en.wikipedia.org/wiki/PMI-80">http://en.wikipedia.org/wiki/PMI-80</a>
</li>

<li>PMI-80<br />
<a href="http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016">http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016</a>
</li>

<li>The 6502 overflow flag explained mathematically <br />
<a href="http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html">http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html</a>
</li>

<li>X86 Opcode and Instruction Reference<br />
<a href="http://ref.x86asm.net/coder32.html">http://ref.x86asm.net/coder32.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

