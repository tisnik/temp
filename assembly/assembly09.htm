<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Použití assembleru v Linuxu: makra v GNU Assembleru (dokončení)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Použití assembleru v Linuxu: makra v GNU Assembleru (dokončení)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;pořadí již devátém článku o použití assembleru v&nbsp;operačním systému Linux dokončíme popis makrosystému GNU Assembleru. Minule jsme se seznámili se způsobem vytvoření jednoduchých maker s&nbsp;případnými parametry, ovšem ve skutečnosti GNU Assembler nabízí programátorům i další možnosti, například zápis podmínek, výrazů, vkládání souborů (include) atd.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Použití assembleru v Linuxu: makra v GNU Assembleru (dokončení)</a></p>
<p><a href="#k02">2. Využití direktivy <strong>.print</strong> při ladění maker</a></p>
<p><a href="#k03">3. První demonstrační příklad &ndash; použití direktivy <strong>.print</strong></a></p>
<p><a href="#k04">4. Volání makra z&nbsp;jiného makra</a></p>
<p><a href="#k05">5. Druhý demonstrační příklad &ndash; ukázka volání makra z&nbsp;jiného makra</a></p>
<p><a href="#k06">6. Výrazy v&nbsp;direktivách</a></p>
<p><a href="#k07">7. Třetí demonstrační příklad &ndash; vytvoření vysokoúrovňových rozhodovacích konstrukcí pomocí maker</a></p>
<p><a href="#k08">8. Použití direktivy pro zápis podmínek &ndash; <strong>.if</strong> a <strong>.endif</strong></a></p>
<p><a href="#k09">9. Porovnání číselných hodnot a řetězců</a></p>
<p><a href="#k10">10. Čtvrtý demonstrační příklad &ndash; porovnání řetězců</a></p>
<p><a href="#k11">11. Direktiva <strong>.include</strong></a></p>
<p><a href="#k12">12. Pátý demonstrační příklad &ndash; použití direktivy <strong>.include</strong></a></p>
<p><a href="#k13">13. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Použití assembleru v Linuxu: makra v GNU Assembleru (dokončení)</h2>

<p>V&nbsp;předchozím článku jsme se seznámili se způsobem tvorby jednoduchých maker v&nbsp;GNU Assembleru. Připomeňme si, že makra je možné použít například ve chvíli, kdy se v&nbsp;kódu opakuje nějaká sekvence instrukcí; typicky se jedná o volání knihovní či systémové funkce s&nbsp;přípravou parametrů. Díky uživatelsky definovaným makrům lze volání knihovních i systémových funkcí zapisovat způsobem, který se podobá zápisu používaném ve vyšších programovacích jazycích. Velmi jednoduchým příkladem může být makro pojmenované <strong>exit</strong>, které slouží k&nbsp;ukončení aktuálního procesu. Zápis makra vypadá následovně:</p>

<pre>
# Deklarace makra pro ukonceni aplikace
.macro exit
        mov   eax, sys_exit          # cislo sycallu pro funkci "exit"
        mov   ebx, 0                 # exit code = 0
        int   0x80                   # volani Linuxoveho kernelu
.endm
</pre>

<p>Použití tohoto makra (bez parametrů) je ještě jednodušší:</p>

<pre>
_start:
        ...
        ... vlastni kod programu
        ...
        exit                         # ukonceni aplikace
</pre>

<p>Ještě si připomeňme způsob vytvoření nepatrně složitějšího makra s&nbsp;parametry:</p>

<pre>
# Deklarace makra pro vytisteni zpravy na standardni vystup
.macro writeMessage message,messageLength
        mov   ecx, offset \message   # adresa retezce, ktery se ma vytisknout
        mov   edx, \messageLength    # pocet znaku, ktere se maji vytisknout
        call  write_message          # vytisknout zpravu "Zero flag not set"
.endm
</pre>

<p>Použití tohoto makra je následující:</p>

<pre>
writeMessage message1,message1len
</pre>

<p>Povšimněte si, že jsme se skutečně nepatrně přiblížili k&nbsp;zápisu podobnému vyšším programovacím jazykům.</p>

<p>Makrosystém GNU Assembleru je ovšem ve skutečnosti mnohem sofistikovanější a nabízí programátorům i další možnosti, nejenom &bdquo;pouhou&ldquo; expanzi maker provedenou před samotným překladem. S&nbsp;některými dalšími možnostmi se seznámíme v&nbsp;dnešním článku. Jedná se například o použití výrazů, podmínkových konstrukcí typu <strong>if-then-else</strong> či direktivy pojmenované <strong>.print</strong>, která může být užitečná například při ladění maker (výhodnější je však sledování expandovaného kódu). Taktéž si ukážeme, co se stane ve chvíli, kdy se v&nbsp;jednom makru volá jiné makro &ndash; tuto funkcionalitu GNU Assembler samozřejmě taktéž podporuje. Poslední potenciálně velmi užitečnou direktivou je direktiva nazvaná <strong>.include</strong>, která umožňuje vložení jednoho zdrojového kódu do kódu jiného, podobně jako céčkovská direktiva <strong>#include</strong>. S&nbsp;využitím této direktivy je možné si vytvořit sadu maker snadno použitelných v&nbsp;celém projektu (jen tak je možné si udržet pořádek v&nbsp;rozsáhlejších projektech).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Využití direktivy <strong>.print</strong> při ladění maker</h2>

<p>Při ladění maker je v&nbsp;mnoha případech důležité se přesvědčit o tom, že skutečně došlo k&nbsp;expanzi makra popř.&nbsp;že assembler při zpracování zdrojového kódu překládaného programu došel na určitý řádek. Jedno z&nbsp;možných a velmi jednoduše použitelných řešení spočívá v&nbsp;použití direktivy <strong>.print</strong>. Této direktivě se předá řetězec, který se při zpracování direktivy jednoduše vytiskne na standardní výstup:</p>

<pre>
.print "Hello world!"
</pre>

<p>Užitečnost této direktivy se ještě zvyšuje díky tomu, že uvnitř makra (ale nikde jinde!) lze do řetězce přidat i symbol \@, s&nbsp;nímž jsme se seznámili minule. Připomeňme si, že tento symbol se používá jako počitadlo volání maker a je možné ho použít mj.&nbsp;i pro vytváření unikátních názvů návěští. I tento zápis je tedy legální:</p>

<pre>
.print "Aktuální hodnota počitadla maker: \@"
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. První demonstrační příklad &ndash; použití direktivy <strong>.print</strong></h2>

<p>Podívejme se nyní na způsob použití výše popsané direktivy <strong>.print</strong>, a to v&nbsp;demonstračním příkladu, s&nbsp;nímž jsme se již seznámili minule. V&nbsp;tomto příkladu je deklarováno makro <strong>writeMessageRepeatedly</strong>, ve kterém jsme vytvářeli unikátní názvy návěští pomocí počitadla \@. Bylo by tedy vhodné se přesvědčit o tom, jak přesně tato návěští vypadají, což je přesný úkol právě pro direktivu <strong>.print</strong>. Upravené makro vypadá následovně:</p>

<pre>
# Deklarace makra pro vytisteni zpravy na standardni vystup
.macro writeMessageRepeatedly message,messageLength,count
        mov   ebp, \count            # nastaveni pocitadla
        <strong>.print "Declaring label loop\@"</strong>
loop\@:                              # lokalni navesti (unikatni)
        mov   ecx, offset \message   # adresa retezce, ktery se ma vytisknout
        mov   edx, \messageLength    # pocet znaku, ktere se maji vytisknout
        call  write_message          # vytisknout zpravu "Zero flag not set"
        dec   ebp                    # snizeni hodnoty pocitadla
        jnz   loop\@                 # opakovani smycky
.endm
</pre>

<p>Upravené makro zařadíme do zdrojového kódu demonstračního příkladu:</p>

<pre>
# asmsyntax=as

# Ukazka pouziti maker v GNU Assembleru - pouziti direktivy .print pro vypis pocitadla
# - pouzita je "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix


# Linux kernel system call table
sys_exit   = 1
sys_write  = 4

# Dalsi konstanty pouzite v programu - standardni streamy
std_input  = 0
std_output = 1



#-----------------------------------------------------------------------------

# Deklarace makra pro ukonceni aplikace
.macro exit
        mov   eax, sys_exit          # cislo sycallu pro funkci "exit"
        mov   ebx, 0                 # exit code = 0
        int   0x80                   # volani Linuxoveho kernelu
.endm



# Deklarace makra pro vytisteni zpravy na standardni vystup
.macro writeMessage message,messageLength
        mov   ecx, offset \message   # adresa retezce, ktery se ma vytisknout
        mov   edx, \messageLength    # pocet znaku, ktere se maji vytisknout
        call  write_message          # vytisknout zpravu "Zero flag not set"
.endm



# Deklarace makra pro vytisteni zpravy na standardni vystup
.macro writeMessageRepeatedly message,messageLength,count
        mov   ebp, \count            # nastaveni pocitadla
        .print "Declaring label loop\@"
loop\@:                              # lokalni navesti (unikatni)
        mov   ecx, offset \message   # adresa retezce, ktery se ma vytisknout
        mov   edx, \messageLength    # pocet znaku, ktere se maji vytisknout
        call  write_message          # vytisknout zpravu "Zero flag not set"
        dec   ebp                    # snizeni hodnoty pocitadla
        jnz   loop\@                 # opakovani smycky
.endm



#-----------------------------------------------------------------------------
.section .data
message1:
        .string "Hello world\n"
message1len = $ - message1         # delka prvni zpravy

message2:
        .string "Vitejte na mojefedora.cz\n"
message2len = $ - message2         # delka druhe zpravy

message3:
        .string "Assembler je fajn\n"
message3len = $ - message3         # delka druhe zpravy



#-----------------------------------------------------------------------------
.section .bss



#-----------------------------------------------------------------------------
.section .text
        .global _start               # tento symbol ma byt dostupny i linkeru

_start:
        writeMessageRepeatedly message1,message1len,10
        writeMessageRepeatedly message2,message2len,2
        writeMessageRepeatedly message3,message3len,7
        exit                         # ukonceni aplikace



# Podprogram pro vytisteni zpravy na standardni vystup
# Ocekava se, ze v ecx bude adresa zpravy a v edx jeji delka
write_message:
        mov   eax, sys_write         # cislo syscallu pro funkci "write"
        mov   ebx, std_output        # standardni vystup
        int   0x80
        ret
</pre>

<p>Nejzajímavější bude sledovat, co se bude dít při překladu:</p>

<pre>
<strong>as -g --32 print_directive.s -o print_directive.o</strong>
&nbsp;
Declaring label loop0
Declaring label loop1
Declaring label loop2
</pre>

<p>Vidíme, že jak počitadlo volání maker \@, tak i direktiva <strong>.print</strong> skutečně pracují korektně.</p>

<p>Výpis expandovaných maker se získá jednoduše přepínačem <strong>-alm</strong> kombinovaném s&nbsp;přepínačem <strong>-g</strong> (viz též předchozí část tohoto seriálu):</p>

<pre>
as -alm -g --32 print_directive.s -o print_directive.o
</pre>

<p>Výsledek expanze:</p>

<pre>
GAS LISTING print_directive.s                   page 1


   1                    # asmsyntax=as
   2                    
   3                    # Ukazka pouziti maker v GNU Assembleru - pouziti direktivy .print pro vypis pocitadla
   4                    # - pouzita je "Intel" syntaxe.
   5                    #
   6                    # Autor: Pavel Tisnovsky
   7                    
   8                    .intel_syntax noprefix
   9                    
  10                    
  11                    # Linux kernel system call table
  12                    sys_exit   = 1
  13                    sys_write  = 4
  14                    
  15                    # Dalsi konstanty pouzite v programu - standardni streamy
  16                    std_input  = 0
  17                    std_output = 1
  18                    
  19                    
  20                    
  21                    #-----------------------------------------------------------------------------
  22                    
  23                    # Deklarace makra pro ukonceni aplikace
  24                    .macro exit
  25                            mov   eax, sys_exit          # cislo sycallu pro funkci "exit"
  26                            mov   ebx, 0                 # exit code = 0
  27                            int   0x80                   # volani Linuxoveho kernelu
  28                    .endm
  29                    
  30                    
  31                    
  32                    # Deklarace makra pro vytisteni zpravy na standardni vystup
  33                    .macro writeMessage message,messageLength
  34                            mov   ecx, offset \message   # adresa retezce, ktery se ma vytisknout
  35                            mov   edx, \messageLength    # pocet znaku, ktere se maji vytisknout
  36                            call  write_message          # vytisknout zpravu "Zero flag not set"
  37                    .endm
  38                    
  39                    
  40                    
  41                    # Deklarace makra pro vytisteni zpravy na standardni vystup
  42                    .macro writeMessageRepeatedly message,messageLength,count
  43                            mov   ebp, \count            # nastaveni pocitadla
  44                            .print "Declaring label loop\@"
  45                    loop\@:                              # lokalni navesti (unikatni)
  46                            mov   ecx, offset \message   # adresa retezce, ktery se ma vytisknout
  47                            mov   edx, \messageLength    # pocet znaku, ktere se maji vytisknout
  48                            call  write_message          # vytisknout zpravu "Zero flag not set"
  49                            dec   ebp                    # snizeni hodnoty pocitadla
  50                            jnz   loop\@                 # opakovani smycky
  51                    .endm
  52                    
  53                    
  54                    
  55                    #-----------------------------------------------------------------------------
  56                    .section .data
  57                    message1:


GAS LISTING print_directive.s                   page 2


  58 0000 48656C6C              .string "Hello world\n"
  58      6F20776F 
  58      726C640A 
  58      00
  59                    message1len = $ - message1         # delka prvni zpravy
  60                    
  61                    message2:
  62 000d 56697465              .string "Vitejte na mojefedora.cz\n"
  62      6A746520 
  62      6E61206D 
  62      6F6A6566 
  62      65646F72 
  63                    message2len = $ - message2         # delka druhe zpravy
  64                    
  65                    message3:
  66 0027 41737365              .string "Assembler je fajn\n"
  66      6D626C65 
  66      72206A65 
  66      2066616A 
  66      6E0A00
  67                    message3len = $ - message3         # delka druhe zpravy
  68                    
  69                    
  70                    
  71                    #-----------------------------------------------------------------------------
  72                    .section .bss
  73                    
  74                    
  75                    
  76                    #-----------------------------------------------------------------------------
  77                    .section .text
  78                            .global _start               # tento symbol ma byt dostupny i linkeru
  79                    
  80                    _start:
  81                            writeMessageRepeatedly message1,message1len,10
  81 0000 BD0A0000      &gt;  mov ebp,10
  81      00
  81                    &gt;  .print "Declaring label loop0"
  81                    &gt; loop0:
  81 0005 B9000000      &gt;  mov ecx,offset message1
  81      00
  81 000a BA0D0000      &gt;  mov edx,message1len
  81      00
  81 000f E83D0000      &gt;  call write_message
  81      00
  81 0014 4D            &gt;  dec ebp
  81 0015 75EE          &gt;  jnz loop0
  82                            writeMessageRepeatedly message2,message2len,2
  82 0017 BD020000      &gt;  mov ebp,2
  82      00
  82                    &gt;  .print "Declaring label loop1"
  82                    &gt; loop1:
  82 001c B90D0000      &gt;  mov ecx,offset message2
  82      00
  82 0021 BA1A0000      &gt;  mov edx,message2len
  82      00
  82 0026 E8260000      &gt;  call write_message


GAS LISTING print_directive.s                   page 3


  82      00
  82 002b 4D            &gt;  dec ebp
  82 002c 75EE          &gt;  jnz loop1
  83                            writeMessageRepeatedly message3,message3len,7
  83 002e BD070000      &gt;  mov ebp,7
  83      00
  83                    &gt;  .print "Declaring label loop2"
  83                    &gt; loop2:
  83 0033 B9270000      &gt;  mov ecx,offset message3
  83      00
  83 0038 BA130000      &gt;  mov edx,message3len
  83      00
  83 003d E80F0000      &gt;  call write_message
  83      00
  83 0042 4D            &gt;  dec ebp
  83 0043 75EE          &gt;  jnz loop2
  84                            exit                         # ukonceni aplikace
  84 0045 B8010000      &gt;  mov eax,sys_exit
  84      00
  84 004a BB000000      &gt;  mov ebx,0
  84      00
  84 004f CD80          &gt;  int 0x80
  85                    
  86                    
  87                    
  88                    # Podprogram pro vytisteni zpravy na standardni vystup
  89                    # Ocekava se, ze v ecx bude adresa zpravy a v edx jeji delka
  90                    write_message:
  91 0051 B8040000              mov   eax, sys_write         # cislo syscallu pro funkci "write"
  91      00
  92 0056 BB010000              mov   ebx, std_output        # standardni vystup
  92      00
  93 005b CD80                  int   0x80
  94 005d C3                    ret
  95                    
</pre>

<p>Povšimněte si především toho, že expandované makro se pozná jednoduše podle znaku &gt; na příslušném řádku.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Volání makra z&nbsp;jiného makra</h2>

<p>Při používání maker se velmi často dostaneme do situace, kdy je zapotřebí z&nbsp;jednoho makra volat jiné makro. To samozřejmě GNU Assembler podporuje, protože &bdquo;volání makra&ldquo; není nic jiného, než textová expanze jeho těla. Pro příklad nemusíme chodit daleko, stačí se podívat na předchozí demonstrační příklad, v&nbsp;němž jsou deklarována dvě makra, která používají shodnou sekvenci instrukcí:</p>

<pre>
# Deklarace makra pro vytisteni zpravy na standardni vystup
.macro writeMessage message,messageLength
        mov   ecx, offset \message   # adresa retezce, ktery se ma vytisknout
        mov   edx, \messageLength    # pocet znaku, ktere se maji vytisknout
        call  write_message          # vytisknout zpravu "Zero flag not set"
.endm



# Deklarace makra pro vytisteni zpravy na standardni vystup
.macro writeMessageRepeatedly message,messageLength,count
        mov   ebp, \count            # nastaveni pocitadla
        .print "Declaring label loop\@"
loop\@:                              # lokalni navesti (unikatni)
        mov   ecx, offset \message   # adresa retezce, ktery se ma vytisknout
        mov   edx, \messageLength    # pocet znaku, ktere se maji vytisknout
        call  write_message          # vytisknout zpravu "Zero flag not set"
        dec   ebp                    # snizeni hodnoty pocitadla
        jnz   loop\@                 # opakovani smycky
.endm
</pre>

<p>Povšimněte si, že v&nbsp;makru <strong>writeMessageRepeatedly</strong> vlastně můžeme volat makro <strong>writeMessage</strong>, takže úprava bude jednoduchá a výsledné makro <strong>writeMessageRepeatedly</strong> bude kratší a přehlednější:</p>

<pre>
# Deklarace makra pro vytisteni zpravy na standardni vystup
.macro writeMessageRepeatedly message,messageLength,count
        mov   ebp, \count            # nastaveni pocitadla
        .print "Declaring label loop\@"
loop\@:                              # lokalni navesti (unikatni)
        writeMessage \message, \messageLength
        dec   ebp                    # snizeni hodnoty pocitadla
        jnz   loop\@                 # opakovani smycky
.endm
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Druhý demonstrační příklad &ndash; ukázka volání makra z&nbsp;jiného makra</h2>

<p>V&nbsp;dnešním druhém demonstračním příkladu je použito upravené makro <strong>writeMessageRepeatedly</strong>. Zajímavý není ani tak zápis zdrojového kódu uvedený pod tímto odstavcem, ale způsob, jakým je zpracováno počitadlo \@ a co se bude dít při expanzi:</p>

<pre>
# asmsyntax=as

# Ukazka pouziti maker v GNU Assembleru - volani makra z jineho makra
# - pouzita je "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix


# Linux kernel system call table
sys_exit   = 1
sys_write  = 4

# Dalsi konstanty pouzite v programu - standardni streamy
std_input  = 0
std_output = 1



#-----------------------------------------------------------------------------

# Deklarace makra pro ukonceni aplikace
.macro exit
        mov   eax, sys_exit          # cislo sycallu pro funkci "exit"
        mov   ebx, 0                 # exit code = 0
        int   0x80                   # volani Linuxoveho kernelu
.endm



# Deklarace makra pro vytisteni zpravy na standardni vystup
.macro writeMessage message,messageLength
        mov   ecx, offset \message   # adresa retezce, ktery se ma vytisknout
        mov   edx, \messageLength    # pocet znaku, ktere se maji vytisknout
        call  write_message          # vytisknout zpravu "Zero flag not set"
.endm



# Deklarace makra pro vytisteni zpravy na standardni vystup
.macro writeMessageRepeatedly message,messageLength,count
        mov   ebp, \count            # nastaveni pocitadla
        .print "Declaring label loop\@"
loop\@:                              # lokalni navesti (unikatni)
        writeMessage \message, \messageLength
        dec   ebp                    # snizeni hodnoty pocitadla
        jnz   loop\@                 # opakovani smycky
.endm



#-----------------------------------------------------------------------------
.section .data
message1:
        .string "Hello world\n"
message1len = $ - message1         # delka prvni zpravy

message2:
        .string "Vitejte na mojefedora.cz\n"
message2len = $ - message2         # delka druhe zpravy

message3:
        .string "Assembler je fajn\n"
message3len = $ - message3         # delka druhe zpravy



#-----------------------------------------------------------------------------
.section .bss



#-----------------------------------------------------------------------------
.section .text
        .global _start               # tento symbol ma byt dostupny i linkeru

_start:
        writeMessageRepeatedly message1,message1len,10
        writeMessageRepeatedly message2,message2len,2
        writeMessageRepeatedly message3,message3len,7
        exit                         # ukonceni aplikace



# Podprogram pro vytisteni zpravy na standardni vystup
# Ocekava se, ze v ecx bude adresa zpravy a v edx jeji delka
write_message:
        mov   eax, sys_write         # cislo syscallu pro funkci "write"
        mov   ebx, std_output        # standardni vystup
        int   0x80
        ret
</pre>

<p>Při překladu se stane zajímavá věc &ndash; direktiva <strong>.print</strong> vypíše názvy vytvořených unikátních návěští, jejichž hodnoty se liší o dvojku a nikoli o jedničku. Je tomu tak z&nbsp;toho důvodu, že \@ počítá jakoukoli expanzi makra, tedy i makra zanořeného do jiného makra:</p>

<pre>
Declaring label loop0
Declaring label loop2
Declaring label loop4
</pre>

<p>Opět se podívejme na výsledek expanze maker:</p>

<pre>
GAS LISTING nested_macros.s                     page 1


   1                    # asmsyntax=as
   2                    
   3                    # Ukazka pouziti maker v GNU Assembleru - volani makra z jineho makra
   4                    # - pouzita je "Intel" syntaxe.
   5                    #
   6                    # Autor: Pavel Tisnovsky
   7                    
   8                    .intel_syntax noprefix
   9                    
  10                    
  11                    # Linux kernel system call table
  12                    sys_exit   = 1
  13                    sys_write  = 4
  14                    
  15                    # Dalsi konstanty pouzite v programu - standardni streamy
  16                    std_input  = 0
  17                    std_output = 1
  18                    
  19                    
  20                    
  21                    #-----------------------------------------------------------------------------
  22                    
  23                    # Deklarace makra pro ukonceni aplikace
  24                    .macro exit
  25                            mov   eax, sys_exit          # cislo sycallu pro funkci "exit"
  26                            mov   ebx, 0                 # exit code = 0
  27                            int   0x80                   # volani Linuxoveho kernelu
  28                    .endm
  29                    
  30                    
  31                    
  32                    # Deklarace makra pro vytisteni zpravy na standardni vystup
  33                    .macro writeMessage message,messageLength
  34                            mov   ecx, offset \message   # adresa retezce, ktery se ma vytisknout
  35                            mov   edx, \messageLength    # pocet znaku, ktere se maji vytisknout
  36                            call  write_message          # vytisknout zpravu "Zero flag not set"
  37                    .endm
  38                    
  39                    
  40                    
  41                    # Deklarace makra pro vytisteni zpravy na standardni vystup
  42                    .macro writeMessageRepeatedly message,messageLength,count
  43                            mov   ebp, \count            # nastaveni pocitadla
  44                            .print "Declaring label loop\@"
  45                    loop\@:                              # lokalni navesti (unikatni)
  46                            writeMessage \message, \messageLength
  47                            dec   ebp                    # snizeni hodnoty pocitadla
  48                            jnz   loop\@                 # opakovani smycky
  49                    .endm
  50                    
  51                    
  52                    
  53                    #-----------------------------------------------------------------------------
  54                    .section .data
  55                    message1:
  56 0000 48656C6C              .string "Hello world\n"
  56      6F20776F 


GAS LISTING nested_macros.s                   page 2


  56      726C640A 
  56      00
  57                    message1len = $ - message1         # delka prvni zpravy
  58                    
  59                    message2:
  60 000d 56697465              .string "Vitejte na mojefedora.cz\n"
  60      6A746520 
  60      6E61206D 
  60      6F6A6566 
  60      65646F72 
  61                    message2len = $ - message2         # delka druhe zpravy
  62                    
  63                    message3:
  64 0027 41737365              .string "Assembler je fajn\n"
  64      6D626C65 
  64      72206A65 
  64      2066616A 
  64      6E0A00
  65                    message3len = $ - message3         # delka druhe zpravy
  66                    
  67                    
  68                    
  69                    #-----------------------------------------------------------------------------
  70                    .section .bss
  71                    
  72                    
  73                    
  74                    #-----------------------------------------------------------------------------
  75                    .section .text
  76                            .global _start               # tento symbol ma byt dostupny i linkeru
  77                    
  78                    _start:
  79                            writeMessageRepeatedly message1,message1len,10
  79 0000 BD0A0000      &gt;  mov ebp,10
  79      00
  79                    &gt;  .print "Declaring label loop0"
  79                    &gt; loop0:
  79                    &gt;  writeMessage message1,message1len
  79 0005 B9000000      &gt;&gt;  mov ecx,offset message1
  79      00
  79 000a BA0D0000      &gt;&gt;  mov edx,message1len
  79      00
  79 000f E83D0000      &gt;&gt;  call write_message
  79      00
  79 0014 4D            &gt;  dec ebp
  79 0015 75EE          &gt;  jnz loop0
  80                            writeMessageRepeatedly message2,message2len,2
  80 0017 BD020000      &gt;  mov ebp,2
  80      00
  80                    &gt;  .print "Declaring label loop2"
  80                    &gt; loop2:
  80                    &gt;  writeMessage message2,message2len
  80 001c B90D0000      &gt;&gt;  mov ecx,offset message2
  80      00
  80 0021 BA1A0000      &gt;&gt;  mov edx,message2len
  80      00
  80 0026 E8260000      &gt;&gt;  call write_message


GAS LISTING nested_macros.s                   page 3


  80      00
  80 002b 4D            &gt;  dec ebp
  80 002c 75EE          &gt;  jnz loop2
  81                            writeMessageRepeatedly message3,message3len,7
  81 002e BD070000      &gt;  mov ebp,7
  81      00
  81                    &gt;  .print "Declaring label loop4"
  81                    &gt; loop4:
  81                    &gt;  writeMessage message3,message3len
  81 0033 B9270000      &gt;&gt;  mov ecx,offset message3
  81      00
  81 0038 BA130000      &gt;&gt;  mov edx,message3len
  81      00
  81 003d E80F0000      &gt;&gt;  call write_message
  81      00
  81 0042 4D            &gt;  dec ebp
  81 0043 75EE          &gt;  jnz loop4
  82                            exit                         # ukonceni aplikace
  82 0045 B8010000      &gt;  mov eax,sys_exit
  82      00
  82 004a BB000000      &gt;  mov ebx,0
  82      00
  82 004f CD80          &gt;  int 0x80
  83                    
  84                    
  85                    
  86                    # Podprogram pro vytisteni zpravy na standardni vystup
  87                    # Ocekava se, ze v ecx bude adresa zpravy a v edx jeji delka
  88                    write_message:
  89 0051 B8040000              mov   eax, sys_write         # cislo syscallu pro funkci "write"
  89      00
  90 0056 BB010000              mov   ebx, std_output        # standardni vystup
  90      00
  91 005b CD80                  int   0x80
  92 005d C3                    ret
  93                    
</pre>

<p>Zajímavé jsou například následující řádky, z&nbsp;nichž je patrné, že makro volané z&nbsp;jiného makra poznáme snadno podle většího počtu znaků &gt;:</p>

<pre>
  81                    &gt; loop4:
  81                    &gt;  writeMessage message3,message3len
  81 0033 B9270000      &gt;&gt;  mov ecx,offset message3
  81      00
  81 0038 BA130000      &gt;&gt;  mov edx,message3len
  81      00
  81 003d E80F0000      &gt;&gt;  call write_message
  81      00
  81 0042 4D            &gt;  dec ebp
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Výrazy v&nbsp;direktivách</h2>

<p>Při vytváření konstant či maker lze v&nbsp;GNU Assembleru používat výrazy, v&nbsp;nichž se vyskytují numerické konstanty. Tyto výrazy lze použít například při výpočtu adresy (při překladu), což je až překvapivě častá operace. Zápis výrazů do značné míry odpovídá zvyklostem známým z&nbsp;céčka (až na dvě výjimky), liší se však priority operátorů, což je naznačeno v&nbsp;následující tabulce:</p>

<table>
<tr><th>Priorita</th><th>Operátory</th></tr>
<tr><td>nejvyšší</td><td>* / % &lt;&lt; &gt;&gt;</td></tr>
<tr><td>střední </td><td>| &amp; ^ (XOR) ! (OR NOT &ndash; rozdílné od céčka!)</td></tr>
<tr><td>nižší   </td><td>+ - == &lt;&gt; (nerovnost, rozdílné od céčka!) &lt; &lt;= &gt; &gt;= </td></tr>
<tr><td>nejnižší</td><td>&amp;&amp; ||</td></tr>
</table>

<p>Navíc ještě existují dva unární operátory, tj.&nbsp;operátory, u nichž se jediný operand zapisuje za operátor:</p>

<table>
<tr><th>Operátor</th><th>Význam</th></tr>
<tr><td>-</td><td>dvojkový doplněk</td></tr>
<tr><td>~</td><td>bitová negace</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Třetí demonstrační příklad &ndash; vytvoření vysokoúrovňových rozhodovacích konstrukcí pomocí maker</h2>

<p>V&nbsp;GNU Assembleru je možné napsat i relativně sofistikovaná makra, která programátorům nabízí obdobu rozhodovacích konstrukcí typu <strong>if-then-else</strong>. Tato makra typicky převedou konstrukci s&nbsp;podmínkou na sekvenci instrukcí <strong>cmp</strong>, <strong>jump(podmínka)</strong>, <strong>jump(negace-podmínky)</strong>, což může vést ke zjednodušení zápisu celého programu (vlastně se tak nepatrně přiblížíme k&nbsp;vysokoúrovňovým programovacím jazykům). V&nbsp;takovém případě je však nutné generovat vhodné názvy návěští, což lze řešit s&nbsp;využitím výrazů v&nbsp;direktivách, například takto:</p>

<pre>
.set _if_label_counter, 0

.macro make_label counter
 xxx\counter:
.endm

.macro jump_to_label counter
        jz xxx\counter
.endm

# Makro pro oznaceni zacatku podminky
.macro _if_equal
        .set _if_label_counter, _if_label_counter+1
        jump_to_label _if_label_counter
.endm

.macro _endif
        make_label _if_label_counter
.endm
</pre>

<p>Povšimněte si, že zde není možné použít počitadlo \@, a to z&nbsp;toho prostého důvodu, že by počitadlo bylo zvyšováno při <i>každém</i> volání makra, tedy ihned po <strong>_if_equal</strong> by již makro <strong>_endif</strong> použilo jinou hodnotu. Navíc se jedná o globální počitadlo, nad nímž nemáme žádnou kontrolu.</p>

<p>Použití nově nadefinovaných &bdquo;rozhodovacích konstrukcí&ldquo;:</p>

<pre>
_start:
        writeMessage message1,message1len

        cmp eax, eax
        _if_equal
            writeMessage message2,message2len
        _endif

        cmp eax, eax
        _if_equal
            writeMessage message2,message2len
        _endif

        writeMessage message3,message3len
        exit
</pre>

<p>Tato makra i jejich volání jsou součástí dalšího demonstračního příkladu, jehož úplný zdrojový kód vypadá následovně:</p>

<pre>
# asmsyntax=as

# Ukazka pouziti maker v GNU Assembleru - if-then atd.
# - pouzita je "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix

# Linux kernel system call table
sys_exit   = 1
sys_write  = 4

# Dalsi konstanty pouzite v programu - standardni streamy
std_input  = 0
std_output = 1



#-----------------------------------------------------------------------------

# Deklarace makra pro ukonceni aplikace
.macro exit
        mov   eax, sys_exit          # cislo sycallu pro funkci "exit"
        mov   ebx, 0                 # exit code = 0
        int   0x80                   # volani Linuxoveho kernelu
.endm



# Deklarace makra pro vytisteni zpravy na standardni vystup
.macro writeMessage message,messageLength
        mov   ecx, offset \message   # adresa retezce, ktery se ma vytisknout
        mov   edx, \messageLength    # pocet znaku, ktere se maji vytisknout
        call  write_message          # vytisknout zpravu "Zero flag not set"
.endm


.set _if_label_counter, 0

.macro make_label counter
 xxx\counter:
.endm

.macro jump_to_label counter
        jz xxx\counter
.endm

# Makro pro oznaceni zacatku podminky
.macro _if_equal
        .set _if_label_counter, _if_label_counter+1
        jump_to_label _if_label_counter
.endm

.macro _endif
        make_label _if_label_counter
.endm



#-----------------------------------------------------------------------------
.section .data
message1:
        .string "Hello world\n"
message1len = $ - message1         # delka prvni zpravy

message2:
        .string "Vitejte na mojefedora.cz\n"
message2len = $ - message2         # delka druhe zpravy

message3:
        .string "Assembler je fajn\n"
message3len = $ - message3         # delka druhe zpravy



#-----------------------------------------------------------------------------
.section .bss



#-----------------------------------------------------------------------------
.section .text
        .global _start               # tento symbol ma byt dostupny i linkeru

_start:
        writeMessage message1,message1len
        cmp eax, eax
        _if_equal
        writeMessage message2,message2len
        _endif

        cmp eax, eax
        _if_equal
        writeMessage message2,message2len
        _endif

        writeMessage message3,message3len
        exit                         # ukonceni aplikace



# Podprogram pro vytisteni zpravy na standardni vystup
# Ocekava se, ze v ecx bude adresa zpravy a v edx jeji delka
write_message:
        mov   eax, sys_write         # cislo syscallu pro funkci "write"
        mov   ebx, std_output        # standardni vystup
        int   0x80
        ret
</pre>

<p>Poznámka: zkuste upravit nějakou podmínku například následovně:</p>

<pre>
mov ebx, eax
inc ebx
cmp eax, ebx
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Použití direktivy pro zápis podmínek &ndash; <strong>.if</strong> a <strong>.endif</strong></h2>

<p>V&nbsp;souvislosti s&nbsp;výrazy a konstantami (ať již numerickými či textovými) je vhodné se zmínit o podpoře pro podmíněný překlad. Makrosystém GNU Assembleru totiž podporuje tvorbu podmínek typu <strong>if-then-else</strong>, přičemž v&nbsp;podmínce je možné testovat buď hodnotu nějakého řetězce či provést porovnání dvou numerických výrazů. Při zápisu podmínek je nutné si uvědomit, že celý makrosystém slouží k&nbsp;&bdquo;úpravám&ldquo; zdrojového kódu před jeho překladem. Všechny podmínky se tedy vyhodnotí již při překladu (resp.&nbsp;těsně před ním), což znamená, že se v&nbsp;žádném případě nejedná o podmínky vyhodnocované v&nbsp;době běhu programu.</p>

<p>Základní podmínky se zapisují direktivami <strong>.if</strong>, <strong>.else</strong> a <strong>.endif</strong>, což je patrné i z&nbsp;následujícího velmi jednoduchého příkladu. Samozřejmě je nutné, aby se všechny výrazy použité v&nbsp;podmínce vyhodnotily již při překladu (viz též předchozí kapitolu):</p>

<pre>
# asmsyntax=as

x=42
y=10

.if x &gt; y
    .print "vetsi"
.else
    .print "mensi"
.endif

.if x % 2 == 0
    .print "suda"
.else
    .print "licha"
.endif
</pre>

<p>Po spuštění GNU Assembleru získáme na standardním výstupu dvě zprávy:</p>

<pre>
<strong>as test.s</strong>
&nbsp;
vetsi
suda
</pre>

<p>Podobným způsobem lze zařídit podmíněný překlad některých částí kódu:</p>

<pre>
# asmsyntax=as

# Ukazka pouziti maker v GNU Assembleru - direktivy .if a .endif
# - pouzita je "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix

printFirstMessage  = 1
printSecondMessage = 0
printThirdMessage  = 1


# Linux kernel system call table
sys_exit   = 1
sys_write  = 4

# Dalsi konstanty pouzite v programu - standardni streamy
std_input  = 0
std_output = 1



#-----------------------------------------------------------------------------

# Deklarace makra pro ukonceni aplikace
.macro exit
        mov   eax, sys_exit          # cislo sycallu pro funkci "exit"
        mov   ebx, 0                 # exit code = 0
        int   0x80                   # volani Linuxoveho kernelu
.endm



# Deklarace makra pro vytisteni zpravy na standardni vystup
.macro writeMessage message,messageLength
        mov   ecx, offset \message   # adresa retezce, ktery se ma vytisknout
        mov   edx, \messageLength    # pocet znaku, ktere se maji vytisknout
        call  write_message          # vytisknout zpravu "Zero flag not set"
.endm



# Deklarace makra pro vytisteni zpravy na standardni vystup
.macro writeMessageRepeatedly message,messageLength,count
        mov   ebp, \count            # nastaveni pocitadla
        .print "Declaring label loop\@"
loop\@:                              # lokalni navesti (unikatni)
        writeMessage \message, \messageLength
        dec   ebp                    # snizeni hodnoty pocitadla
        jnz   loop\@                 # opakovani smycky
.endm



#-----------------------------------------------------------------------------
.section .data
message1:
        .string "Hello world\n"
message1len = $ - message1         # delka prvni zpravy

message2:
        .string "Vitejte na mojefedora.cz\n"
message2len = $ - message2         # delka druhe zpravy

message3:
        .string "Assembler je fajn\n"
message3len = $ - message3         # delka druhe zpravy



#-----------------------------------------------------------------------------
.section .bss



#-----------------------------------------------------------------------------
.section .text
        .global _start               # tento symbol ma byt dostupny i linkeru

_start:
        .if printFirstMessage
        writeMessageRepeatedly message1,message1len,10
        .endif

        .if printSecondMessage
        writeMessageRepeatedly message2,message2len,2
        .endif

        .if printThirdMessage
        writeMessageRepeatedly message3,message3len,7
        .endif

        exit                         # ukonceni aplikace



# Podprogram pro vytisteni zpravy na standardni vystup
# Ocekava se, ze v ecx bude adresa zpravy a v edx jeji delka
write_message:
        mov   eax, sys_write         # cislo syscallu pro funkci "write"
        mov   ebx, std_output        # standardni vystup
        int   0x80
        ret
</pre>

<p>Po spuštění získáme následující výstup:</p>

<pre>
Hello world
Hello world
Hello world
Hello world
Hello world
Hello world
Hello world
Hello world
Hello world
Hello world
Assembler je fajn
Assembler je fajn
Assembler je fajn
Assembler je fajn
Assembler je fajn
Assembler je fajn
Assembler je fajn
</pre>

<p>Expanze maker:</p>

<pre>
GAS LISTING if_endif.s                   page 1


   1                    # asmsyntax=as
   2                    
   3                    # Ukazka pouziti maker v GNU Assembleru - volani makra z jineho makra
   4                    # - pouzita je "Intel" syntaxe.
   5                    #
   6                    # Autor: Pavel Tisnovsky
   7                    
   8                    .intel_syntax noprefix
   9                    
  10                    printFirstMessage  = 1
  11                    printSecondMessage = 0
  12                    printThirdMessage  = 1
  13                    
  14                    
  15                    # Linux kernel system call table
  16                    sys_exit   = 1
  17                    sys_write  = 4
  18                    
  19                    # Dalsi konstanty pouzite v programu - standardni streamy
  20                    std_input  = 0
  21                    std_output = 1
  22                    
  23                    
  24                    
  25                    #-----------------------------------------------------------------------------
  26                    
  27                    # Deklarace makra pro ukonceni aplikace
  28                    .macro exit
  29                            mov   eax, sys_exit          # cislo sycallu pro funkci "exit"
  30                            mov   ebx, 0                 # exit code = 0
  31                            int   0x80                   # volani Linuxoveho kernelu
  32                    .endm
  33                    
  34                    
  35                    
  36                    # Deklarace makra pro vytisteni zpravy na standardni vystup
  37                    .macro writeMessage message,messageLength
  38                            mov   ecx, offset \message   # adresa retezce, ktery se ma vytisknout
  39                            mov   edx, \messageLength    # pocet znaku, ktere se maji vytisknout
  40                            call  write_message          # vytisknout zpravu "Zero flag not set"
  41                    .endm
  42                    
  43                    
  44                    
  45                    # Deklarace makra pro vytisteni zpravy na standardni vystup
  46                    .macro writeMessageRepeatedly message,messageLength,count
  47                            mov   ebp, \count            # nastaveni pocitadla
  48                            .print "Declaring label loop\@"
  49                    loop\@:                              # lokalni navesti (unikatni)
  50                            writeMessage \message, \messageLength
  51                            dec   ebp                    # snizeni hodnoty pocitadla
  52                            jnz   loop\@                 # opakovani smycky
  53                    .endm
  54                    
  55                    
  56                    
  57                    #-----------------------------------------------------------------------------


GAS LISTING if_endif.s                         page 2


  58                    .section .data
  59                    message1:
  60 0000 48656C6C              .string "Hello world\n"
  60      6F20776F 
  60      726C640A 
  60      00
  61                    message1len = $ - message1         # delka prvni zpravy
  62                    
  63                    message2:
  64 000d 56697465              .string "Vitejte na mojefedora.cz\n"
  64      6A746520 
  64      6E61206D 
  64      6F6A6566 
  64      65646F72 
  65                    message2len = $ - message2         # delka druhe zpravy
  66                    
  67                    message3:
  68 0027 41737365              .string "Assembler je fajn\n"
  68      6D626C65 
  68      72206A65 
  68      2066616A 
  68      6E0A00
  69                    message3len = $ - message3         # delka druhe zpravy
  70                    
  71                    
  72                    
  73                    #-----------------------------------------------------------------------------
  74                    .section .bss
  75                    
  76                    
  77                    
  78                    #-----------------------------------------------------------------------------
  79                    .section .text
  80                            .global _start               # tento symbol ma byt dostupny i linkeru
  81                    
  82                    _start:
  83                            .if printFirstMessage
  84                            writeMessageRepeatedly message1,message1len,10
  84 0000 BD0A0000      &gt;  mov ebp,10
  84      00
  84                    &gt;  .print "Declaring label loop0"
  84                    &gt; loop0:
  84                    &gt;  writeMessage message1,message1len
  84 0005 B9000000      &gt;&gt;  mov ecx,offset message1
  84      00
  84 000a BA0D0000      &gt;&gt;  mov edx,message1len
  84      00
  84 000f E8260000      &gt;&gt;  call write_message
  84      00
  84 0014 4D            &gt;  dec ebp
  84 0015 75EE          &gt;  jnz loop0
  85                            .endif
  86                    
  87                            .if printSecondMessage
  88                            writeMessageRepeatedly message2,message2len,2
  89                            .endif
  90                    


GAS LISTING if_endif.s                         page 3


  91                            .if printThirdMessage
  92                            writeMessageRepeatedly message3,message3len,7
  92 0017 BD070000      &gt;  mov ebp,7
  92      00
  92                    &gt;  .print "Declaring label loop2"
  92                    &gt; loop2:
  92                    &gt;  writeMessage message3,message3len
  92 001c B9270000      &gt;&gt;  mov ecx,offset message3
  92      00
  92 0021 BA130000      &gt;&gt;  mov edx,message3len
  92      00
  92 0026 E80F0000      &gt;&gt;  call write_message
  92      00
  92 002b 4D            &gt;  dec ebp
  92 002c 75EE          &gt;  jnz loop2
  93                            .endif
  94                    
  95                            exit                         # ukonceni aplikace
  95 002e B8010000      &gt;  mov eax,sys_exit
  95      00
  95 0033 BB000000      &gt;  mov ebx,0
  95      00
  95 0038 CD80          &gt;  int 0x80
  96                    
  97                    
  98                    
  99                    # Podprogram pro vytisteni zpravy na standardni vystup
 100                    # Ocekava se, ze v ecx bude adresa zpravy a v edx jeji delka
 101                    write_message:
 102 003a B8040000              mov   eax, sys_write         # cislo syscallu pro funkci "write"
 102      00
 103 003f BB010000              mov   ebx, std_output        # standardni vystup
 103      00
 104 0044 CD80                  int   0x80
 105 0046 C3                    ret
 106                    
</pre>


<p><a name="k09"></a></p>
<h2 id="k09">9. Porovnání číselných hodnot a řetězců</h2>

<p>Ve skutečnosti existuje hned několik dalších variant direktivy typu <strong>.if</strong>, které se od sebe odlišují podle toho, jaký typ podmínky se testuje &ndash; zda se například testuje hodnota řetězce či zda se porovnávají dvě numerické konstanty. Podívejme se na následující tabulku, kde jsou jednotlivé direktivy pro přehlednost vypsány:</p>

<table>
<tr><th>#</th><th>Direktiva</th><th>Význam direktivy</th></tr>
<tr><td>1</td><td>.if</td><td>test na výsledek výrazu</td></tr>
<tr><td>2</td><td>.ifne</td><td>alias pro předchozí direktivu</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>.ifdef</td><td>test, zda symbol existuje</td></tr>
<tr><td>4</td><td>.ifndef</td><td>test, zda symbol neexistuje</td></tr>
<tr><td>5</td><td>.ifnotdef</td><td>alias pro předchozí direktivu</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>6</td><td>.ifc</td><td>porovnání dvou řetězců na rovnost</td></tr>
<tr><td>7</td><td>.ifeqs</td><td>alias pro předchozí direktivu (<i>EQual Strings</i>)</td></tr>
<tr><td>8</td><td>.ifnc</td><td>porovnání dvou řetězců na nerovnost</td></tr>
<tr><td>9</td><td>.ifnes</td><td>alias pro předchozí direktivu (<i>Not Equal Strings)</i>)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>.ifeq</td><td>test výrazu na nulu</td></tr>
<tr><td>11</td><td>.ifge</td><td>test výrazu na kladné číslo či nulu</td></tr>
<tr><td>12</td><td>.ifgt</td><td>test výrazu na kladné číslo</td></tr>
<tr><td>13</td><td>.ifle</td><td>test výrazu na záporné číslo či nulu</td></tr>
<tr><td>14</td><td>.iflt</td><td>test výrazu na záporné číslo</td></tr>
</table>

<p>Vidíme, že z&nbsp;názvů direktiv lze snadno poznat, jaká podmínka (či její negace) se makrosystémem GNU Debuggeru testuje.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Čtvrtý demonstrační příklad &ndash; porovnání řetězců</h2>

<p>Použití direktiv pro porovnání řetězců si ukažme na velmi jednoduchém (umělém) příkladu:</p>

<pre>
# asmsyntax=as

# Ukazka pouziti maker v GNU Assembleru - direktivy pro porovnani retezcu
# - pouzita je "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix



.print ".ifc"

.ifc "Hello", "World"
    .print "Hello == World"
.else
    .print "Hello != World"
.endif

.ifc "Hello", "Hello"
    .print "Hello == Hello"
.else
    .print "Hello != Hello"
.endif

.ifc "", ""
    .print "empty strings are equal"
.else
    .print "empty strings are not equal"
.endif



.print "\n.ifeqs"

.ifeqs "Hello", "World"
    .print "Hello == World"
.else
    .print "Hello != World"
.endif

.ifeqs "Hello", "Hello"
    .print "Hello == Hello"
.else
    .print "Hello != Hello"
.endif

.ifeqs "", ""
    .print "empty strings are equal"
.else
    .print "empty strings are not equal"
.endif



.print "\n.ifnes"

.ifnes "Hello", "World"
    .print "Hello != World"
.else
    .print "Hello == World"
.endif

.ifnes "Hello", "Hello"
    .print "Hello != Hello"
.else
    .print "Hello == Hello"
.endif

.ifnes "", ""
    .print "empty strings are not equal"
.else
    .print "empty strings are equal"
.endif
</pre>

<p>Při překladu se na standardní výstup vypíšou následující zprávy:</p>

<pre>
.ifc
Hello != World
Hello == Hello
empty strings are equal

.ifeqs
Hello != World
Hello == Hello
empty strings are equal

.ifnes
Hello != World
Hello == Hello
empty strings are equal
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Direktiva <strong>.include</strong></h2>

<p>Při psaní rozsáhlejších projektů se velmi často programátor dostane do situace, kdy je nutné projekt rozdělit do většího množství souborů, které se samostatně překládají a následně linkují. Ovšem mnoho maker by bylo vhodné využít v&nbsp;dalších souborech a sdílet je tak v&nbsp;rámci celého projektu. Vzhledem k&nbsp;tomu, že linkování je až posledním krokem při překladu a sestavování programu, je nutné pro sdílení maker použít odlišnou techniku. Ta spočívá v&nbsp;použití direktivy <strong>.include</strong>, která má stejný význam jako direktiva <strong>#include</strong> v&nbsp;programovacích jazycích C a C++: do souboru, v&nbsp;němž se <strong>.include</strong> použije se při překladu vloží jiný specifikovaný soubor a až teprve poté dojde k&nbsp;případné expanzi maker a následně k&nbsp;překladu (ve skutečnosti lze všechny tři fáze provádět v&nbsp;&bdquo;pipeline&ldquo;, čímž se překlad urychlí a navíc se ušetří značná část kapacity operační paměti).</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Pátý demonstrační příklad &ndash; použití direktivy <strong>.include</strong></h2>

<p>Podívejme se na praktické použití direktivy <strong>.include</strong>. Předchozí příklady rozdělíme do tří souborů. V&nbsp;prvním z&nbsp;nich bude pouze makro <strong>exit</strong>:</p>

<pre>
# asmsyntax=as

# Makro pro ukonceni procesu v Linuxu.
#
# Autor: Pavel Tisnovsky

sys_exit   = 1

# Deklarace makra pro ukonceni aplikace
.macro exit
        mov   eax, sys_exit          # cislo sycallu pro funkci "exit"
        mov   ebx, 0                 # exit code = 0
        int   0x80                   # volani Linuxoveho kernelu
.endm
</pre>

<p>Ve druhém souboru jsou deklarována makra pro tisk zprávy a pro opakovaný tisk zprávy:</p>

<pre>
# asmsyntax=as

# Makro pro tisk zpravy na standardni vystup.
#
# Autor: Pavel Tisnovsky

# Linux kernel system call table
sys_write  = 4
std_output = 1


# Deklarace makra pro vytisteni zpravy na standardni vystup
.macro writeMessage message,messageLength
        mov   ecx, offset \message   # adresa retezce, ktery se ma vytisknout
        mov   edx, \messageLength    # pocet znaku, ktere se maji vytisknout
        call  write_message          # vytisknout zpravu "Zero flag not set"
.endm



# Deklarace makra pro vytisteni zpravy na standardni vystup
.macro writeMessageRepeatedly message,messageLength,count
        mov   ebp, \count            # nastaveni pocitadla
        .print "Declaring label loop\@"
loop\@:                              # lokalni navesti (unikatni)
        writeMessage \message, \messageLength
        dec   ebp                    # snizeni hodnoty pocitadla
        jnz   loop\@                 # opakovani smycky
.endm



# Podprogram pro vytisteni zpravy na standardni vystup
# Ocekava se, ze v ecx bude adresa zpravy a v edx jeji delka
write_message:
        mov   eax, sys_write         # cislo syscallu pro funkci "write"
        mov   ebx, std_output        # standardni vystup
        int   0x80
        ret
</pre>

<p>Třetí soubor použije první dva soubory, protože jsou do něj vloženy direktivou <strong>.include</strong>:</p>

<pre>
# asmsyntax=as

# Ukazka pouziti maker v GNU Assembleru - direktiva .include
# - pouzita je "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix

# Nacteni definice makra pro ukonceni aplikace
.include "exit.s"

# Nacteni maker pro (opakovany) tisk zpravy i prislusne subrutiny
.include "writeMessage.s"



#-----------------------------------------------------------------------------
.section .data
message1:
        .string "Hello world\n"
message1len = $ - message1         # delka prvni zpravy

message2:
        .string "Vitejte na mojefedora.cz\n"
message2len = $ - message2         # delka druhe zpravy

message3:
        .string "Assembler je fajn\n"
message3len = $ - message3         # delka druhe zpravy



#-----------------------------------------------------------------------------
.section .bss



#-----------------------------------------------------------------------------
.section .text
        .global _start               # tento symbol ma byt dostupny i linkeru

_start:
        writeMessageRepeatedly message1,message1len,10
        writeMessageRepeatedly message2,message2len,2
        writeMessageRepeatedly message3,message3len,7
        exit                         # ukonceni aplikace
</pre>

<p>O tom, že je vložení souborů a expanze maker provedena korektně, se přesvědčíme na formátovaném listingu:</p>

<pre>
GAS LISTING include.s                   page 1


   1                    # asmsyntax=as
   2                    
   3                    # Ukazka pouziti maker v GNU Assembleru - direktiva .include
   4                    # - pouzita je "Intel" syntaxe.
   5                    #
   6                    # Autor: Pavel Tisnovsky
   7                    
   8                    .intel_syntax noprefix
   9                    
  10                    # Nacteni definice makra pro ukonceni aplikace
  11                    .include "exit.s"
   1                    # asmsyntax=as
   2                    
   3                    # Makro pro ukonceni procesu v Linuxu.
   4                    #
   5                    # Autor: Pavel Tisnovsky
   6                    
   7                    sys_exit   = 1
   8                    
   9                    # Deklarace makra pro ukonceni aplikace
  10                    .macro exit
  11                            mov   eax, sys_exit          # cislo sycallu pro funkci "exit"
  12                            mov   ebx, 0                 # exit code = 0
  13                            int   0x80                   # volani Linuxoveho kernelu
  14                    .endm
  15                    
  12                    
  13                    # Nacteni maker pro (opakovany) tisk zpravy i prislusne subrutiny
  14                    .include "writeMessage.s"
   1                    # asmsyntax=as
   2                    
   3                    # Makro pro tisk zpravy na standardni vystup.
   4                    #
   5                    # Autor: Pavel Tisnovsky
   6                    
   7                    # Linux kernel system call table
   8                    sys_write  = 4
   9                    std_output = 1
  10                    
  11                    
  12                    # Deklarace makra pro vytisteni zpravy na standardni vystup
  13                    .macro writeMessage message,messageLength
  14                            mov   ecx, offset \message   # adresa retezce, ktery se ma vytisknout
  15                            mov   edx, \messageLength    # pocet znaku, ktere se maji vytisknout
  16                            call  write_message          # vytisknout zpravu "Zero flag not set"
  17                    .endm
  18                    
  19                    
  20                    
  21                    # Deklarace makra pro vytisteni zpravy na standardni vystup
  22                    .macro writeMessageRepeatedly message,messageLength,count
  23                            mov   ebp, \count            # nastaveni pocitadla
  24                            .print "Declaring label loop\@"
  25                    loop\@:                              # lokalni navesti (unikatni)
  26                            writeMessage \message, \messageLength
  27                            dec   ebp                    # snizeni hodnoty pocitadla
  28                            jnz   loop\@                 # opakovani smycky


GAS LISTING include.s                         page 2


  29                    .endm
  30                    
  31                    
  32                    
  33                    # Podprogram pro vytisteni zpravy na standardni vystup
  34                    # Ocekava se, ze v ecx bude adresa zpravy a v edx jeji delka
  35                    write_message:
  36 0000 B8040000              mov   eax, sys_write         # cislo syscallu pro funkci "write"
  36      00
  37 0005 BB010000              mov   ebx, std_output        # standardni vystup
  37      00
  38 000a CD80                  int   0x80
  39 000c C3                    ret
  40                    
  15                    
  16                    
  17                    
  18                    #-----------------------------------------------------------------------------
  19                    .section .data
  20                    message1:
  21 0000 48656C6C              .string "Hello world\n"
  21      6F20776F 
  21      726C640A 
  21      00
  22                    message1len = $ - message1         # delka prvni zpravy
  23                    
  24                    message2:
  25 000d 56697465              .string "Vitejte na mojefedora.cz\n"
  25      6A746520 
  25      6E61206D 
  25      6F6A6566 
  25      65646F72 
  26                    message2len = $ - message2         # delka druhe zpravy
  27                    
  28                    message3:
  29 0027 41737365              .string "Assembler je fajn\n"
  29      6D626C65 
  29      72206A65 
  29      2066616A 
  29      6E0A00
  30                    message3len = $ - message3         # delka druhe zpravy
  31                    
  32                    
  33                    
  34                    #-----------------------------------------------------------------------------
  35                    .section .bss
  36                    
  37                    
  38                    
  39                    #-----------------------------------------------------------------------------
  40                    .section .text
  41                            .global _start               # tento symbol ma byt dostupny i linkeru
  42                    
  43                    _start:
  44                            writeMessageRepeatedly message1,message1len,10
  44 000d BD0A0000      &gt;  mov ebp,10
  44      00


GAS LISTING include.s                         page 3


  44                    &gt;  .print "Declaring label loop0"
  44                    &gt; loop0:
  44                    &gt;  writeMessage message1,message1len
  44 0012 B9000000      &gt;&gt;  mov ecx,offset message1
  44      00
  44 0017 BA0D0000      &gt;&gt;  mov edx,message1len
  44      00
  44 001c E8DFFFFF      &gt;&gt;  call write_message
  44      FF
  44 0021 4D            &gt;  dec ebp
  44 0022 75EE          &gt;  jnz loop0
  45                            writeMessageRepeatedly message2,message2len,2
  45 0024 BD020000      &gt;  mov ebp,2
  45      00
  45                    &gt;  .print "Declaring label loop2"
  45                    &gt; loop2:
  45                    &gt;  writeMessage message2,message2len
  45 0029 B90D0000      &gt;&gt;  mov ecx,offset message2
  45      00
  45 002e BA1A0000      &gt;&gt;  mov edx,message2len
  45      00
  45 0033 E8C8FFFF      &gt;&gt;  call write_message
  45      FF
  45 0038 4D            &gt;  dec ebp
  45 0039 75EE          &gt;  jnz loop2
  46                            writeMessageRepeatedly message3,message3len,7
  46 003b BD070000      &gt;  mov ebp,7
  46      00
  46                    &gt;  .print "Declaring label loop4"
  46                    &gt; loop4:
  46                    &gt;  writeMessage message3,message3len
  46 0040 B9270000      &gt;&gt;  mov ecx,offset message3
  46      00
  46 0045 BA130000      &gt;&gt;  mov edx,message3len
  46      00
  46 004a E8B1FFFF      &gt;&gt;  call write_message
  46      FF
  46 004f 4D            &gt;  dec ebp
  46 0050 75EE          &gt;  jnz loop4
  47                            exit                         # ukonceni aplikace
  47 0052 B8010000      &gt;  mov eax,sys_exit
  47      00
  47 0057 BB000000      &gt;  mov ebx,0
  47      00
  47 005c CD80          &gt;  int 0x80
  48                    
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popisované demonstrační příklady byly, podobně jako v&nbsp;předchozích částech tohoto seriálu, společně s&nbsp;podpůrnými skripty určenými pro jejich překlad či naopak pro disassembling, uloženy do GIT repositáře dostupného na adrese <a href="https://github.com/tisnik/presentations/">https://github.com/tisnik/presentations/</a>. Všechny příklady jsou určeny pro GNU Assembler a používají Intel syntaxi. Následuje tabulka s&nbsp;odkazy na zdrojové kódy příkladů i na již zmíněné podpůrné skripty:</p>

<h3>První demonstrační příklad &ndash; použití direktivy <strong>.print</strong></h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>print_directive.s</td><td>program pro GNU Assembler</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/23_print_directive/print_directive.s">https://github.com/tisnik/presentations/blob/master/assembler/23_print_directive/print_directive.s</a></td></tr>
<tr><td>2</td><td>assemble</td><td>skript pro překlad na procesorech i386</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/23_print_directive/assemble">https://github.com/tisnik/presentations/blob/master/assembler/23_print_directive/assemble</a></td></tr>
<tr><td>3</td><td>assemble_list</td><td>skript pro překlad a vygenerování listingu</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/23_print_directive/assemble_list">https://github.com/tisnik/presentations/blob/master/assembler/23_print_directive/assemble_list</a></td></tr>
<tr><td>4</td><td>disassemble</td><td>skript pro disassembling</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/23_print_directive/disassemble">https://github.com/tisnik/presentations/blob/master/assembler/23_print_directive/disassemble</a></td></tr>
<tr><td>5</td><td>print_directive.list</td><td>výsledek skriptu assemble.list</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/23_print_directive/print_directive.list">https://github.com/tisnik/presentations/blob/master/assembler/23_print_directive/print_directive.list</a></td></tr>
</table>

<h3>Druhý demonstrační příklad &ndash; ukázka volání makra z&nbsp;jiného makra</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>nested_macros.s</td><td>program pro GNU Assembler</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/24_nested_macros/nested_macros.s">https://github.com/tisnik/presentations/blob/master/assembler/24_nested_macros/nested_macros.s</a></td></tr>
<tr><td>2</td><td>assemble</td><td>skript pro překlad na procesorech i386</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/24_nested_macros/assemble">https://github.com/tisnik/presentations/blob/master/assembler/24_nested_macros/assemble</a></td></tr>
<tr><td>3</td><td>assemble_list</td><td>skript pro překlad a vygenerování listingu</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/24_nested_macros/assemble_list">https://github.com/tisnik/presentations/blob/master/assembler/24_nested_macros/assemble_list</a></td></tr>
<tr><td>4</td><td>disassemble</td><td>skript pro disassembling</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/24_nested_macros/disassemble">https://github.com/tisnik/presentations/blob/master/assembler/24_nested_macros/disassemble</a></td></tr>
<tr><td>5</td><td>nested_macros.list</td><td>výsledek skriptu assemble.list</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/24_nested_macros/nested_macros.list">https://github.com/tisnik/presentations/blob/master/assembler/24_nested_macros/nested_macros.list</a></td></tr>
</table>

<h3>Třetí demonstrační příklad &ndash; direktivy použité pro zápis podmínek</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>if_endif.s</td><td>program pro GNU Assembler</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/25_if_endif/if_endif.s">https://github.com/tisnik/presentations/blob/master/assembler/25_if_endif/if_endif.s</a></td></tr>
<tr><td>2</td><td>assemble</td><td>skript pro překlad na procesorech i386</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/25_if_endif/assemble">https://github.com/tisnik/presentations/blob/master/assembler/25_if_endif/assemble</a></td></tr>
<tr><td>3</td><td>assemble_list</td><td>skript pro překlad a vygenerování listingu</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/25_if_endif/assemble_list">https://github.com/tisnik/presentations/blob/master/assembler/25_if_endif/assemble_list</a></td></tr>
<tr><td>4</td><td>disassemble</td><td>skript pro disassembling</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/25_if_endif/disassemble">https://github.com/tisnik/presentations/blob/master/assembler/25_if_endif/disassemble</a></td></tr>
<tr><td>5</td><td>if_endif.list</td><td>výsledek skriptu assemble.list</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/25_if_endif/if_endif.list">https://github.com/tisnik/presentations/blob/master/assembler/25_if_endif/if_endif.list</a></td></tr>
</table>

<h3>Čtvrtý demonstrační příklad &ndash; porovnání řetězců</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>string_comparisons.s</td><td>program pro GNU Assembler</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/26_string_comparisons/string_comparisons.s">https://github.com/tisnik/presentations/blob/master/assembler/26_string_comparisons/string_comparisons.s</a></td></tr>
<tr><td>2</td><td>assemble</td><td>skript pro překlad na procesorech i386</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/26_string_comparisons/assemble">https://github.com/tisnik/presentations/blob/master/assembler/26_string_comparisons/assemble</a></td></tr>
<tr><td>3</td><td>assemble_list</td><td>skript pro překlad a vygenerování listingu</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/26_string_comparisons/assemble_list">https://github.com/tisnik/presentations/blob/master/assembler/26_string_comparisons/assemble_list</a></td></tr>
<tr><td>4</td><td>disassemble</td><td>skript pro disassembling</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/26_string_comparisons/disassemble">https://github.com/tisnik/presentations/blob/master/assembler/26_string_comparisons/disassemble</a></td></tr>
<tr><td>5</td><td>string_comparisons.list</td><td>výsledek skriptu assemble.list</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/26_string_comparisons/string_comparisons.list">https://github.com/tisnik/presentations/blob/master/assembler/26_string_comparisons/string_comparisons.list</a></td></tr>
</table>

<h3>Pátý demonstrační příklad &ndash; použití direktivy <strong>.include</strong></h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>include.s</td><td>program pro GNU Assembler</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/27_include/include.s">https://github.com/tisnik/presentations/blob/master/assembler/27_include/include.s</a></td></tr>
<tr><td>2</td><td>exit.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/27_include/exit.s">https://github.com/tisnik/presentations/blob/master/assembler/27_include/exit.s</a></td></tr>
<tr><td>3</td><td>writeMessage.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/27_include/writeMessage.s">https://github.com/tisnik/presentations/blob/master/assembler/27_include/writeMessage.s</a></td></tr>
<tr><td>4</td><td>assemble</td><td>skript pro překlad na procesorech i386</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/27_include/assemble">https://github.com/tisnik/presentations/blob/master/assembler/27_include/assemble</a></td></tr>
<tr><td>4</td><td>assemble_list</td><td>skript pro překlad a vygenerování listingu</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/27_include/assemble_list">https://github.com/tisnik/presentations/blob/master/assembler/27_include/assemble_list</a></td></tr>
<tr><td>5</td><td>disassemble</td><td>skript pro disassembling</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/27_include/disassemble">https://github.com/tisnik/presentations/blob/master/assembler/27_include/disassemble</a></td></tr>
<tr><td>6</td><td>include.list</td><td>výsledek skriptu assemble.list</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/27_include/include.list">https://github.com/tisnik/presentations/blob/master/assembler/27_include/include.list</a></td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>The GNU Assembler Tutorial<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html">http://tigcc.ticalc.org/doc/gnuasm.html</a>
</li>

<li>The GNU Assembler - macros<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html#SEC109">http://tigcc.ticalc.org/doc/gnuasm.html#SEC109</a>
</li>

<li>ARM subroutines &amp; program stack<br />
<a href="http://www.toves.org/books/armsub/">http://www.toves.org/books/armsub/</a>
</li>

<li>Generating Mixed Source and Assembly List using GCC<br />
<a href="http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/">http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/</a>
</li>

<li>Calling subroutines<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm</a>
</li>

<li>ARM Assembly Language Programming<br />
<a href="http://peter-cockerell.net/aalp/html/frames.html">http://peter-cockerell.net/aalp/html/frames.html</a>
</li>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Intel x86 JUMP quick reference<br />
<a href="http://unixwiz.net/techtips/x86-jumps.html">http://unixwiz.net/techtips/x86-jumps.html</a>
</li>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Assembler pod Linuxem<br />
<a href="http://phoenix.inf.upol.cz/linux/prog/asm.html">http://phoenix.inf.upol.cz/linux/prog/asm.html</a>
</li>

<li>AT&amp;T Syntax versus Intel Syntax<br />
<a href="https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html">https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html</a>
</li>

<li>Linux Assembly website<br />
<a href="http://asm.sourceforge.net/">http://asm.sourceforge.net/</a>
</li>

<li>Using Assembly Language in Linux<br />
<a href="http://asm.sourceforge.net/articles/linasm.html">http://asm.sourceforge.net/articles/linasm.html</a>
</li>

<li>vasm<br />
<a href="http://sun.hasenbraten.de/vasm/">http://sun.hasenbraten.de/vasm/</a>
</li>

<li>vasm &ndash; dokumentace<br />
<a href="http://sun.hasenbraten.de/vasm/release/vasm.html">http://sun.hasenbraten.de/vasm/release/vasm.html</a>
</li>

<li>The Yasm Modular Assembler Project<br />
<a href="http://yasm.tortall.net/">http://yasm.tortall.net/</a>
</li>

<li>680x0:AsmOne<br />
<a href="http://www.amigacoding.com/index.php/680x0:AsmOne">http://www.amigacoding.com/index.php/680x0:AsmOne</a>
</li>

<li>ASM-One Macro Assembler<br />
<a href="http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler">http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler</a>
</li>

<li>ASM-One pages<br />
<a href="http://www.theflamearrows.info/documents/asmone.html">http://www.theflamearrows.info/documents/asmone.html</a>
</li>

<li>Základní informace o ASM-One<br />
<a href="http://www.theflamearrows.info/documents/asminfo.html">http://www.theflamearrows.info/documents/asminfo.html</a>
</li>

<li>Linux Syscall Reference<br />
<a href="http://syscalls.kernelgrok.com/">http://syscalls.kernelgrok.com/</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>IBM System 360/370 Compiler and Historical Documentation<br />
<a href="http://www.edelweb.fr/Simula/">http://www.edelweb.fr/Simula/</a>
</li>

<li>IBM 700/7000 series<br />
<a href="http://en.wikipedia.org/wiki/IBM_700/7000_series">http://en.wikipedia.org/wiki/IBM_700/7000_series</a>
</li>

<li>IBM System/360<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/360">http://en.wikipedia.org/wiki/IBM_System/360</a>
</li>

<li>IBM System/370<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/370">http://en.wikipedia.org/wiki/IBM_System/370</a>
</li>

<li>Mainframe family tree and chronology<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html</a>
</li>

<li>704 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html</a>
</li>

<li>705 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html</a>
</li>

<li>The IBM 704<br />
<a href="http://www.columbia.edu/acis/history/704.html">http://www.columbia.edu/acis/history/704.html</a>
</li>

<li>IBM Mainframe album<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html</a>
</li>

<li>Osmibitové muzeum<br />
<a href="http://osmi.tarbik.com/">http://osmi.tarbik.com/</a>
</li>

<li>Tesla PMI-80<br />
<a href="http://osmi.tarbik.com/cssr/pmi80.html">http://osmi.tarbik.com/cssr/pmi80.html</a>
</li>

<li>PMI-80<br />
<a href="http://en.wikipedia.org/wiki/PMI-80">http://en.wikipedia.org/wiki/PMI-80</a>
</li>

<li>PMI-80<br />
<a href="http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016">http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016</a>
</li>

<li>The 6502 overflow flag explained mathematically <br />
<a href="http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html">http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html</a>
</li>

<li>X86 Opcode and Instruction Reference<br />
<a href="http://ref.x86asm.net/coder32.html">http://ref.x86asm.net/coder32.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

