<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Logické a bitové operace na mikroprocesorech řady x86</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Logické a bitové operace na mikroprocesorech řady x86</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Nedílnou součástí většiny programů psaných v&nbsp;assembleru jsou i instrukce provádějící logické a bitové operace. Do této skupiny patří zejména instrukce <strong>NOT</strong>, <strong>AND</strong>, <strong>OR</strong> a <strong>XOR</strong> doplněné o instrukci nazvanou jednoduše <strong>TEST</strong>. Nesmíme ovšem zapomenout ani na bitové rotace, bitové posuny a aritmetický posun doprava, tedy na instrukce s&nbsp;mnemotechnickými zkratkami <strong>ROL</strong>, <strong>ROR</strong>, <strong>RCL</strong>, <strong>RCR</strong>, <strong>SHL</strong>, <strong>SHR</strong> a konečně <strong>SAR</strong>.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Logické a bitové operace na mikroprocesorech řady x86</a></p>
<p><a href="#k02">2. Strojová instrukce <strong>NOT</strong>: negace bit po bitu</a></p>
<p><a href="#k03">3. Strojová instrukce <strong>TEST</strong> a příklady jejího využití</a></p>
<p><a href="#k04">4. Strojová instrukce <strong>AND</strong></a></p>
<p><a href="#k05">5. Strojová instrukce <strong>OR</strong></a></p>
<p><a href="#k06">6. Strojová instrukce <strong>XOR</strong></a></p>
<p><a href="#k07">7. Bitová rotace doprava a doleva</a></p>
<p><a href="#k08">8. Bitové rotace prováděné přes příznak přenosu</a></p>
<p><a href="#k09">9. Bitové posuny doprava a doleva</a></p>
<p><a href="#k10">10. Aritmetický posun doprava</a></p>
<p><a href="#k11">11. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Logické a bitové operace na mikroprocesorech řady x86</h2>

<p>Naprostá většina aritmeticko-logických jednotek použitých v&nbsp;mikroprocesorech podporuje provádění nejméně čtyř základních logických operací (aplikovaných bit po bitu), ke kterým se v&nbsp;některých případech mohou přidat i operace další. Jedná se o operaci logického bitového součinu (<strong>AND</strong>) nad všemi korespondujícími bity pracovních registrů či jednoho pracovního registru a buňky operační paměti či konstanty, dále pak o operaci logického součtu (<strong>OR</strong>), nonekvivalenci (<strong>XOR</strong> či <strong>EOR</strong>) a konečně o operaci bitové negace (<strong>COM</strong> popř.&nbsp;,<strong>NOT</strong>) všech bitů jednoho z&nbsp;pracovních registrů. První tři zmíněné operace, tj.&nbsp;logický součin, logický součet a nonekvivalence, jsou operacemi binárními, což znamená, že vyžadují dva operandy (většinou dva pracovní registry, registr a konstantu či registr a buňku v&nbsp;operační paměti), poslední operace &ndash; negace &ndash;, je operací unární, tj.&nbsp;na vstupu vyžaduje pouze obsah pracovního registru či buňku v&nbsp;operační paměti.</p>

<p>V&nbsp;dnešním článku se zaměříme na způsob implementace těchto operací na mikroprocesorech s&nbsp;32bitovou architekturou x86 i s&nbsp;64bitovou architekturou x86-64. U těchto procesorů nalezneme i instrukci <strong>TEST</strong>, která vlastně provádí prakticky stejnou operaci jako instrukce <strong>AND</strong>, ovšem bez uložení výsledku zpět do pracovního registru (jedná se tedy o obdobu dvojice instrukcí <strong>SUB</strong> a <strong>CMP</strong>). Posléze si popíšeme i další důležité a relativně často používané operace, konkrétně bitové posuny a rotace.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Strojová instrukce <strong>NOT</strong>: negace bit po bitu</h2>

<p>Nejjednodušší strojovou instrukcí manipulující s&nbsp;jednotlivými bity zvoleného pracovního registru či buňky operační paměti je instrukce nazvaná <strong>NOT</strong>. Tato instrukce zneguje každý bit svého jediného operandu, přitom se však, na rozdíl od všech dalších dále popsaných instrukcí, nijak neovlivní hodnoty příznakových bitů. Ohledně mnemotechnické zkratky této instrukce panuje poměrně velký zmatek, protože někteří výrobci mikroprocesorů (kteří většinou současně zkratky instrukcí pro svoje výrobky definují) používají zkratku <strong>NEG</strong> či <strong>COM</strong>, a jiní naopak zkratku <strong>NEG</strong> vyhradili pro instrukci určenou pro vytvoření dvojkového doplňku, tj.&nbsp;změny znaménka čísla (což je i případ mikroprocesorů Intel řady x86). Podívejme se, jak tato instrukce pracuje při použití šestnáctibitového registru:</p>

<table>
<tr><th>&nbsp;</th><th>dec bez znaménka</th><th>dec se znaménkem</th><th>hex</th><th>binárně</th></tr>
<tr><td>původní hodnota registru         </td><td>    0</td><td>     0</td><td>0000</td><td>0000000000000000</td></tr>
<tr><td>po provedení <strong>NOT</strong></td><td>65535</td><td>    -1</td><td>FFFF</td><td>1111111111111111</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>původní hodnota                  </td><td>   42</td><td>    42</td><td>002A</td><td>0000000000101010</td></tr>
<tr><td>po provedení <strong>NOT</strong></td><td>65493</td><td>   -43</td><td>FFD5</td><td>1111111111010101</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>původní hodnota                  </td><td>12345</td><td> 12345</td><td>3039</td><td>0011000000111001</td></tr>
<tr><td>po provedení <strong>NOT</strong></td><td>53190</td><td>-12346</td><td>CFC6</td><td>1100111111000110</td></tr>
</table>

<p>Poznámka: instrukce <strong>NEG</strong> skutečně pouze neguje všechny bity, pokud potřebujete získat číslo s&nbsp;opačným znaménkem, použijte instrukci <strong>NEG</strong>.</p>

<p>Nastavení bitových příznaků uložených v&nbsp;registru <strong>EFLAGS</strong>:</p>

<table>
<tr><th>Příznak</th><th>Nastavení</th></tr>
<tr><td>Zero flag    </td><td>nezměněn</td></tr>
<tr><td>Sign flag    </td><td>nezměněn</td></tr>
<tr><td>Carry flag   </td><td>nezměněn</td></tr>
<tr><td>Overflow flag</td><td>nezměněn</td></tr>
</table>

<p>Podporované adresovací režimy:</p>

<table>
<tr><th>Operand</th></tr>
<tr><td>osmibitový registr</td></tr>
<tr><td>16bitový registr</td></tr>
<tr><td>32bitový registr</td></tr>
<tr><td>64bitový registr</td></tr>
<tr><td>osmibitová hodnota v&nbsp;RAM</td></tr>
<tr><td>16bitová hodnota v&nbsp;RAM</td></tr>
<tr><td>32bitová hodnota v&nbsp;RAM</td></tr>
<tr><td>64bitová hodnota v&nbsp;RAM</td></tr>
</table>

<p>Vidíme, že adresování operandu je u této instrukce velmi jednoduché, protože je použit jediný operand.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Strojová instrukce <strong>TEST</strong> a příklady jejího využití</h2>

<p>Strojová instrukce <strong>TEST</strong> slouží k&nbsp;provedení logické operace konjunkce (and) bit po bitu s&nbsp;požadovanou dvojicí pracovních registrů, popř.&nbsp;s&nbsp;jedním pracovním registrem a obsahem buňky načtené z&nbsp;operační paměti (zpracovat lze jednotlivé bajty, 16bitová slova, 32bitová slova a nově i 64bitová slova). Jinými slovy se jedná o stejnou funkci, jakou provádí dále popsaná instrukce <strong>AND</strong>. Jediný, zato však podstatný rozdíl spočívá v&nbsp;tom, že zatímco instrukce <strong>AND</strong> uložila výsledek operace do pracovního registru, který byl jejím prvním operandem, tak instrukce <strong>TEST</strong> výsledek operace ihned &bdquo;zapomene&ldquo;, tj.&nbsp;obsah žádného pracovního registru se nezmění. K&nbsp;čemu je však vlastně tato instrukce užitečná, když se výsledek operace <strong>AND</strong> ihned zapomene? Asi jste již správně uhodli, že výsledkem spuštění této instrukce budou pozměněné příznakové bity, podobně jako tomu bylo u minule popsané strojové instrukce <strong>CMP</strong>.</p>

<p>Instrukce <strong>TEST</strong> nastaví čtveřici příznakových bitů. Jedná se o <i>Carry Flag (CF)</i>, <i>Zero Flag (ZF)</i>, <i>Sign Flag (SF)</i> i <i>Overflow Flag (OF)</i>. <i>Carry Flag</i> a <i>Overflow Flag</i> jsou touto instrukcí vynulovány, čehož je možné využít k&nbsp;některým optimalizacím. Příznakový bit <i>Zero flag</i> se nastaví v&nbsp;závislosti na tom, zda je výsledek konjunkce nulový či nenulový. A konečně <i>Sign Flag</i> je nastaven podle nejvyššího bitu výsledku konjunkce. Tato instrukce se používá především při implementaci různých podmínek či programových smyček, podobně jako minule popsaná instrukce <strong>CMP</strong>. K&nbsp;čemu lze tuto znalost využít? Například pro otestování znaménka hodnoty uložené v&nbsp;nějakém registru:</p> 

<pre>
TEST EAX, EAX
JS je_zaporne
</pre>

<p>Na rozdíl od instrukce <strong>CMP EAX, 0</strong> je <strong>TEST EAX, EAX</strong> kratší (nenačítá se konstanta) a ve většině případů i o několik strojových cyklů rychlejší.</p>

<p>Nastavení příznaku <i>Zero flag</i> po provedení operace <strong>TEST</strong> nad dvojicí šestnáctibitových registrů:</p>

<table>
<tr><th>&nbsp;</th><th>hex</th><th>binárně</th><th>Zero flag</th></tr>
<tr><td>operand 1</td><td>0000</td><td>0000000000000000</td><td></td></tr>
<tr><td>operand 2</td><td>0000</td><td>0000000000000000</td><td></td></tr>
<tr><td>výsledek </td><td>0000</td><td>0000000000000000</td><td>1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>operand 1</td><td>2A2A</td><td>0010101000101010</td><td></td></tr>
<tr><td>operand 2</td><td>00FF</td><td>0000000011111111</td><td></td></tr>
<tr><td>výsledek </td><td>002A</td><td>0000000000101010</td><td>0</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>operand 1</td><td>0FF0</td><td>0000111111110000</td><td></td></tr>
<tr><td>operand 2</td><td>FF00</td><td>1111111100000000</td><td></td></tr>
<tr><td>výsledek </td><td>0F00</td><td>0000111100000000</td><td>0</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>operand 1</td><td>00FF</td><td>0000000011111111</td><td></td></tr>
<tr><td>operand 2</td><td>FF00</td><td>1111111100000000</td><td></td></tr>
<tr><td>výsledek </td><td>0000</td><td>0000000000000000</td><td>1</td></tr>
</table>

<p>Nastavení bitových příznaků uložených v&nbsp;registru <strong>EFLAGS</strong>:</p>

<table>
<tr><th>Příznak</th><th>Nastavení</th></tr>
<tr><td>Zero flag    </td><td>nastaven, pokud je výsledek operace <strong>AND</strong> provedené bit po bitu nulový</td></tr>
<tr><td>Sign flag    </td><td>nastaven na základě nejvyššího bitu operace <strong>AND</strong> provedené bit po bitu</td></tr>
<tr><td>Carry flag   </td><td>vynulován</td></tr>
<tr><td>Overflow flag</td><td>vynulován</td></tr>
</table>

<p>Podporované adresovací režimy:</p>

<table>
<tr><th>Operand 1</th><th>Operand 2</th></tr>
<tr><td>osmibitový registr</td><td>osmibitový registr</td></tr>
<tr><td>osmibitový registr</td><td>osmibitová hodnota v&nbsp;RAM</td></tr>
<tr><td>osmibitový registr</td><td>osmibitová konstanta</td></tr>
<tr><td>osmibitová hodnota v&nbsp;RAM</td><td>osmibitová konstanta</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16bitový registr</td><td>16bitový registr</td></tr>
<tr><td>16bitový registr</td><td>16bitová hodnota v&nbsp;RAM</td></tr>
<tr><td>16bitový registr</td><td>16bitová konstanta</td></tr>
<tr><td>16bitová hodnota v&nbsp;RAM</td><td>16bitová konstanta</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>32bitový registr</td><td>32bitový registr</td></tr>
<tr><td>32bitový registr</td><td>32bitová hodnota v&nbsp;RAM</td></tr>
<tr><td>32bitový registr</td><td>32bitová konstanta</td></tr>
<tr><td>32bitová hodnota v&nbsp;RAM</td><td>32bitová konstanta</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>64bitový registr</td><td>64bitový registr</td></tr>
<tr><td>64bitový registr</td><td>64bitová hodnota v&nbsp;RAM</td></tr>
<tr><td>64bitový registr</td><td>64bitová konstanta</td></tr>
<tr><td>64bitová hodnota v&nbsp;RAM</td><td>64bitová konstanta</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Strojová instrukce <strong>AND</strong></h2>

<p>V&nbsp;programech či jejich částech psaných ve strojovém kódu nebo jazyku symbolických instrukcí se velmi často používá logická operace <strong>AND</strong>, která provádí logický součin obsahu vybraného pracovního registru s&nbsp;obsahem jiného pracovního registru či s&nbsp;obsahem vybrané buňky (buněk) načtených z&nbsp;operační paměti (popř.&nbsp;lze použít i konstantu). Logický součin je při použití této instrukce prováděn bit po bitu. Výsledek je uložen do jednoho z&nbsp;pracovních registrů v&nbsp;závislosti na adresní části instrukce.</p>

<p>Podle výsledku operace je nastaven příznak <i>Zero flag</i> (výsledek je nulový či nenulový) a <i>Sign Flag</i> (podle nejvyššího bitu výsledku), naopak příznaky <i>Carry Flag</i> a <i>Overflow Flag</i> jsou vynulovány. Tato operace slouží jak k&nbsp;implementaci logického součinu s&nbsp;pravdivostními hodnotami (pracovní registry v&nbsp;tomto případě typicky obsahují hodnoty 0x00000000 nebo 0xFFFFFFFF), tak i k&nbsp;maskování vybraných bitů jednoho z&nbsp;pracovních registrů. Obsah druhého pracovního registru slouží jako takzvaná <i>maska</i>: pokud je nějaký bit masky roven nule, je vynulován i příslušný bit prvního pracovního registru. Následují příklady použití této instrukce:</p>

<table>
<tr><th>&nbsp;</th><th>hex</th><th>binárně</th><th>Zero flag</th></tr>
<tr><td>operand 1</td><td>0000</td><td>0000000000000000</td><td></td></tr>
<tr><td>operand 2</td><td>0000</td><td>0000000000000000</td><td></td></tr>
<tr><td>výsledek </td><td>0000</td><td>0000000000000000</td><td>1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>operand 1</td><td>2A2A</td><td>0010101000101010</td><td></td></tr>
<tr><td>operand 2</td><td>00FF</td><td>0000000011111111</td><td></td></tr>
<tr><td>výsledek </td><td>002A</td><td>0000000000101010</td><td>0</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>operand 1</td><td>0FF0</td><td>0000111111110000</td><td></td></tr>
<tr><td>operand 2</td><td>FF00</td><td>1111111100000000</td><td></td></tr>
<tr><td>výsledek </td><td>0F00</td><td>0000111100000000</td><td>0</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>operand 1</td><td>00FF</td><td>0000000011111111</td><td></td></tr>
<tr><td>operand 2</td><td>FF00</td><td>1111111100000000</td><td></td></tr>
<tr><td>výsledek </td><td>0000</td><td>0000000000000000</td><td>1</td></tr>
</table>

<p>Nastavení bitových příznaků uložených v&nbsp;registru <strong>EFLAGS</strong>:</p>

<table>
<tr><th>Příznak</th><th>Nastavení</th></tr>
<tr><td>Zero flag    </td><td>nastaven, pokud je výsledek operace <strong>AND</strong> provedené bit po bitu nulový</td></tr>
<tr><td>Sign flag    </td><td>nastaven na základě nejvyššího bitu operace <strong>AND</strong> provedené bit po bitu</td></tr>
<tr><td>Carry flag   </td><td>vynulován</td></tr>
<tr><td>Overflow flag</td><td>vynulován</td></tr>
</table>

<p>Podporované adresovací režimy:</p>

<table>
<tr><th>Operand 1</th><th>Operand 2</th></tr>
<tr><td>osmibitový registr</td><td>osmibitový registr</td></tr>
<tr><td>osmibitový registr</td><td>osmibitová hodnota v&nbsp;RAM</td></tr>
<tr><td>osmibitový registr</td><td>osmibitová konstanta</td></tr>
<tr><td>osmibitová hodnota v&nbsp;RAM</td><td>osmibitová konstanta</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16bitový registr</td><td>16bitový registr</td></tr>
<tr><td>16bitový registr</td><td>16bitová hodnota v&nbsp;RAM</td></tr>
<tr><td>16bitový registr</td><td>16bitová konstanta</td></tr>
<tr><td>16bitová hodnota v&nbsp;RAM</td><td>16bitová konstanta</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>32bitový registr</td><td>32bitový registr</td></tr>
<tr><td>32bitový registr</td><td>32bitová hodnota v&nbsp;RAM</td></tr>
<tr><td>32bitový registr</td><td>32bitová konstanta</td></tr>
<tr><td>32bitová hodnota v&nbsp;RAM</td><td>32bitová konstanta</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>64bitový registr</td><td>64bitový registr</td></tr>
<tr><td>64bitový registr</td><td>64bitová hodnota v&nbsp;RAM</td></tr>
<tr><td>64bitový registr</td><td>64bitová konstanta</td></tr>
<tr><td>64bitová hodnota v&nbsp;RAM</td><td>64bitová konstanta</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. Strojová instrukce <strong>OR</strong></h2>

<p>Strojová instrukce <strong>OR</strong> je určena k&nbsp;provedení logického součtu (opět bit po bitu) s&nbsp;obsahy dvou pracovních registrů, popř.&nbsp;registru a obsahu vybrané buňky operační paměti. Výsledek je uložen do registru, který tvoří první parametr instrukce, tj.&nbsp;je uveden na prvním místě při zápisu instrukce v&nbsp;assembleru. Tato operace se používá například pro nastavení určených bitů pracovního registru na jedničku (jedná se ve skutečnosti opět o maskování, i když opačného významu, než tomu bylo u instrukce <strong>AND</strong>) nebo pro implementaci booleovských (pravdivostních) výrazů. Podle výsledku aplikace operace <strong>OR</strong> se nastaví příznaky <i>Zero flag</i> a <i>Sign flag</i>, zatímco obsahy příznaků <i>Carry flag</i> a <i>Overflow flag</i> jsou vynulovány:</p>

<table>
<tr><th>&nbsp;</th><th>hex</th><th>binárně</th><th>Zero flag</th></tr>
<tr><td>operand 1</td><td>0000</td><td>0000000000000000</td><td></td></tr>
<tr><td>operand 2</td><td>0000</td><td>0000000000000000</td><td></td></tr>
<tr><td>výsledek </td><td>0000</td><td>0000000000000000</td><td>1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>operand 1</td><td>2A2A</td><td>0010101000101010</td><td></td></tr>
<tr><td>operand 2</td><td>00FF</td><td>0000000011111111</td><td></td></tr>
<tr><td>výsledek </td><td>2AFF</td><td>0010101011111111</td><td>0</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>operand 1</td><td>0FF0</td><td>0000111111110000</td><td></td></tr>
<tr><td>operand 2</td><td>FF00</td><td>1111111100000000</td><td></td></tr>
<tr><td>výsledek </td><td>FFF0</td><td>1111111111110000</td><td>0</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>operand 1</td><td>00FF</td><td>0000000011111111</td><td></td></tr>
<tr><td>operand 2</td><td>FF00</td><td>1111111100000000</td><td></td></tr>
<tr><td>výsledek </td><td>FFFF</td><td>1111111111111111</td><td>0</td></tr>
</table>

<p>Nastavení bitových příznaků uložených v&nbsp;registru <strong>EFLAGS</strong>:</p>

<table>
<tr><th>Příznak</th><th>Nastavení</th></tr>
<tr><td>Zero flag    </td><td>nastaven, pokud je výsledek operace <strong>OR</strong> provedené bit po bitu nulový</td></tr>
<tr><td>Sign flag    </td><td>nastaven na základě nejvyššího bitu operace <strong>OR</strong> provedené bit po bitu</td></tr>
<tr><td>Carry flag   </td><td>vynulován</td></tr>
<tr><td>Overflow flag</td><td>vynulován</td></tr>
</table>

<p>Podporované adresovací režimy:</p>

<table>
<tr><th>Operand 1</th><th>Operand 2</th></tr>
<tr><td>osmibitový registr</td><td>osmibitový registr</td></tr>
<tr><td>osmibitový registr</td><td>osmibitová hodnota v&nbsp;RAM</td></tr>
<tr><td>osmibitový registr</td><td>osmibitová konstanta</td></tr>
<tr><td>osmibitová hodnota v&nbsp;RAM</td><td>osmibitová konstanta</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16bitový registr</td><td>16bitový registr</td></tr>
<tr><td>16bitový registr</td><td>16bitová hodnota v&nbsp;RAM</td></tr>
<tr><td>16bitový registr</td><td>16bitová konstanta</td></tr>
<tr><td>16bitová hodnota v&nbsp;RAM</td><td>16bitová konstanta</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>32bitový registr</td><td>32bitový registr</td></tr>
<tr><td>32bitový registr</td><td>32bitová hodnota v&nbsp;RAM</td></tr>
<tr><td>32bitový registr</td><td>32bitová konstanta</td></tr>
<tr><td>32bitová hodnota v&nbsp;RAM</td><td>32bitová konstanta</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>64bitový registr</td><td>64bitový registr</td></tr>
<tr><td>64bitový registr</td><td>64bitová hodnota v&nbsp;RAM</td></tr>
<tr><td>64bitový registr</td><td>64bitová konstanta</td></tr>
<tr><td>64bitová hodnota v&nbsp;RAM</td><td>64bitová konstanta</td></tr>
</table>



<p><a name="k06"></a></p>
<h2 id="k06">6. Strojová instrukce <strong>XOR</strong></h2>

<p>S&nbsp;využitím strojové instrukce <strong>XOR</strong>, která bývá v&nbsp;některých assemblerech označována mnemotechnickou zkratkou <strong>EOR</strong>, se provádí operace nonekvivalence, tj.&nbsp;exkluzivní (výlučný) logický součet obou zadaných operandů a to opět, stejně jako u předchozích dvou instrukcí, bit po bitu. Podle výsledku této instrukce jsou nastaveny příznaky <i>Zero flag</i> a <i>Sign flag</i>, podobně jako u výše uvedených operací <strong>AND</strong> a <strong>OR</strong>.</p>

<p>Zatímco logický součet i součin se mj.&nbsp;používá pro implementaci logických výrazů známých z&nbsp;vyšších programovacích jazyků, je operace nonekvivalence používána k&nbsp;selektivní negaci vybraných bitů, protože ve chvíli, kdy jsou oba korespondující bity nastaveny na logickou jedničku, je výsledkem logická nula. Tuto instrukci lze využít v&nbsp;mnoha oblastech, například v&nbsp;počítačové grafice, šifrování, generátorech pseudonáhodných posloupností čísel (RND), konstrukci kontrolních součtů či cyklických kódů (CRC) atd. Je přitom využito faktu, že dvojí použití operace <strong>XOR</strong> se stejným druhým operandem vede k&nbsp;tomu, že výsledkem je původní hodnota, předaná operaci v&nbsp;prvním kroku. Následují příklady použití, ve kterých stojí za povšimnutí &bdquo;negující&ldquo; vlastnost této instrukce (poslední příklad) i to, že aplikace nonekvivalence na tu samou hodnotu dává nulový výsledek (třetí příklad).</p>

<table>
<tr><th>&nbsp;</th><th>hex</th><th>binárně</th><th>Zero flag</th></tr>
<tr><td>operand 1</td><td>0000</td><td>0000000000000000</td><td></td></tr>
<tr><td>operand 2</td><td>0000</td><td>0000000000000000</td><td></td></tr>
<tr><td>výsledek </td><td>0000</td><td>0000000000000000</td><td>1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>operand 1</td><td>2A2A</td><td>0010101000101010</td><td></td></tr>
<tr><td>operand 2</td><td>00FF</td><td>0000000011111111</td><td></td></tr>
<tr><td>výsledek </td><td>2AD5</td><td>0010101011010101</td><td>0</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>operand 1</td><td>2A2A</td><td>0010101000101010</td><td></td></tr>
<tr><td>operand 2</td><td>2A2A</td><td>0010101000101010</td><td></td></tr>
<tr><td>výsledek </td><td>0000</td><td>0000000000000000</td><td>1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>operand 1</td><td>0FF0</td><td>0000111111110000</td><td></td></tr>
<tr><td>operand 2</td><td>FF00</td><td>1111111100000000</td><td></td></tr>
<tr><td>výsledek </td><td>F0F0</td><td>1111000011110000</td><td>0</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>operand 1</td><td>00FF</td><td>0000000011111111</td><td></td></tr>
<tr><td>operand 2</td><td>FF00</td><td>1111111100000000</td><td></td></tr>
<tr><td>výsledek </td><td>FFFF</td><td>1111111111111111</td><td>0</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>operand 1</td><td>002A</td><td>0000000000101010</td><td></td></tr>
<tr><td>operand 2</td><td>FFFF</td><td>1111111111111111</td><td></td></tr>
<tr><td>výsledek </td><td>FFD5</td><td>1111111111010101</td><td>0</td></tr>
</table>

<p>Nastavení bitových příznaků uložených v&nbsp;registru <strong>EFLAGS</strong>:</p>

<table>
<tr><th>Příznak</th><th>Nastavení</th></tr>
<tr><td>Zero flag    </td><td>nastaven, pokud je výsledek operace <strong>XOR</strong> provedené bit po bitu nulový</td></tr>
<tr><td>Sign flag    </td><td>nastaven na základě nejvyššího bitu operace <strong>XOR</strong> provedené bit po bitu</td></tr>
<tr><td>Carry flag   </td><td>vynulován</td></tr>
<tr><td>Overflow flag</td><td>vynulován</td></tr>
</table>

<p>Podporované adresovací režimy:</p>

<table>
<tr><th>Operand 1</th><th>Operand 2</th></tr>
<tr><td>osmibitový registr</td><td>osmibitový registr</td></tr>
<tr><td>osmibitový registr</td><td>osmibitová hodnota v&nbsp;RAM</td></tr>
<tr><td>osmibitový registr</td><td>osmibitová konstanta</td></tr>
<tr><td>osmibitová hodnota v&nbsp;RAM</td><td>osmibitová konstanta</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16bitový registr</td><td>16bitový registr</td></tr>
<tr><td>16bitový registr</td><td>16bitová hodnota v&nbsp;RAM</td></tr>
<tr><td>16bitový registr</td><td>16bitová konstanta</td></tr>
<tr><td>16bitová hodnota v&nbsp;RAM</td><td>16bitová konstanta</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>32bitový registr</td><td>32bitový registr</td></tr>
<tr><td>32bitový registr</td><td>32bitová hodnota v&nbsp;RAM</td></tr>
<tr><td>32bitový registr</td><td>32bitová konstanta</td></tr>
<tr><td>32bitová hodnota v&nbsp;RAM</td><td>32bitová konstanta</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>64bitový registr</td><td>64bitový registr</td></tr>
<tr><td>64bitový registr</td><td>64bitová hodnota v&nbsp;RAM</td></tr>
<tr><td>64bitový registr</td><td>64bitová konstanta</td></tr>
<tr><td>64bitová hodnota v&nbsp;RAM</td><td>64bitová konstanta</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Bitová rotace doprava a doleva</h2>

<p>V&nbsp;assembleru se poměrně často používají instrukce provádějící takzvané <i>bitové rotace</i>. O co se vlastně jedná? Jde o posun všech bitů v&nbsp;některém z&nbsp;pracovních registrů, ovšem takovým způsobem, že se jedná o uzavřenou smyčku, tj.&nbsp;obsah bitu, který by se provedením posunu ztratil (byl by vysunut), je naopak zkopírován na vstup. Kromě toho se tento bit zkopíruje do příznakového bitu <i>Carry flag</i>, což není samoúčelné, protože se této skutečnosti dá využít pro provedení skoku v&nbsp;závislosti na hodnotě jednoho konkrétního bitu, implementaci generátoru pseudonáhodných čísel nebo při programování aritmetických operací násobení a dělení (to však již na moderních mikroprocesorech postrádá význam). Pro takto chápanou bitovou rotaci existují dvě instrukce, první pro rotaci obsahu pracovního registru doleva a druhá pro rotaci doprava. Každá instrukce způsobí rotaci buď pouze o jeden bit, popř.&nbsp;o zadaný počet bitů (mikroprocesory však kvůli optimalizacím maskují čítač rotace, takže se maximálně provede 32 či 64 rotací). Nákres rotace doleva i doprava, je naznačen na obrázku:</p>

<a href="https://mojefedora.cz/wp-content/uploads/2016/09/01.png"><img class="alignnone size-full wp-image-7493" src="https://mojefedora.cz/wp-content/uploads/2016/09/01.png" alt="01" width="450" height="180" /></a>
<p><i>Obrázek 1: Bitová rotace doleva a doprava (zde ukázána se 16bitovým operandem).</i></p>

<p>Instrukce pro rotaci doleva se jmenuje <strong>ROL</strong>, instrukce pro rotaci doprava logicky <strong>ROR</strong>. Kromě příznaku <i>Carry flag</i> může být nastaven i příznak <i>Overflow flag</i>, ovšem pouze za toho předpokladu, že se rotuje o jediný bit (v&nbsp;jiném případě chybí správná sémantika pro tento příznak):</p>

<table>
<tr><th>Příznak</th><th>Nastavení</th></tr>
<tr><td>Zero flag    </td><td>nezměněn</td></tr>
<tr><td>Sign flag    </td><td>nezměněn</td></tr>
<tr><td>Carry flag   </td><td>bit, který byl rotací přesunut na začátek/konec registru</td></tr>
<tr><td>Overflow flag</td><td>nastaven pouze při rotaci o jediný bit, má význam jako při sčítání a odčítání</td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Bitové rotace prováděné přes příznak přenosu</h2>

<p>Kromě běžných bitových rotací popsaných v&nbsp;předchozí kapitole se setkáme i s&nbsp;rotacemi prováděnými přes příznak přenosu (<i>Carry flag</i>). V&nbsp;podstatě se jedná o rozšíření bitové šířky rotovaného registru o jeden bit, který je představovaný právě příznakem přenosu, tj.&nbsp;neprovádí se rotace 8, 16, 32 či 64 bitů, ale bitů devíti, 17, 33 či 65. Použití těchto typů rotací spočívá například v&nbsp;implementaci víceslovní aritmetiky (rotuje se přes větší množství slov), popř.&nbsp;při požadavku na vložení hodnoty příznaku přenosu do určeného bitu pracovního registru (booleovské operace). Nákres rotace doleva i doprava přes příznak přenosu, je naznačen na obrázku:</p>

<a href="https://mojefedora.cz/wp-content/uploads/2016/09/02.png"><img class="alignnone size-thumbnail wp-image-7494" src="https://mojefedora.cz/wp-content/uploads/2016/09/02.png" alt="02" width="450" height="180" /></a>
<p><i>Obrázek 2: Bitová rotace doleva a doprava přes příznak přenosu (zde ukázána se 16bitovým operandem).</i></p>

<p>Instrukce pro rotaci doleva přes příznak přenosu se jmenuje <strong>RCL</strong>, instrukce pro rotaci doprava přes příznak přenosu pak <strong>RCR</strong>. Kromě příznaku <i>Carry flag</i> může být, podobně jako tomu bylo u instrukcí <strong>ROL</strong> a <strong>ROR</strong> nastaven i příznak <i>Overflow flag</i>, ovšem pouze za toho předpokladu, že se rotuje o jediný bit (v&nbsp;jiném případě chybí správná sémantika pro tento příznak):</p>

<table>
<tr><th>Příznak</th><th>Nastavení</th></tr>
<tr><td>Zero flag    </td><td>nezměněn</td></tr>
<tr><td>Sign flag    </td><td>nezměněn</td></tr>
<tr><td>Carry flag   </td><td>bit, který byl rotací přesunut na začátek/konec registru</td></tr>
<tr><td>Overflow flag</td><td>nastaven pouze při rotaci o jediný bit, má význam jako při sčítání a odčítání</td></tr>
</table>

<p>Poznámka: u jiných typů mikroprocesorů se setkáme s&nbsp;odlišnými mnemotechnickými zkratkami těchto instrukcí, například namísto <strong>RCL</strong> se používá <strong>RLC</strong> či jen <strong>RL</strong>.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Bitové posuny doprava a doleva</h2>

<p>Další dvě strojové instrukce, s&nbsp;nimiž se dnes alespoň ve stručnosti seznámíme, mají mnemotechnické zkratky <strong>SHL</strong> a <strong>SHR</strong>. Tyto zkratky znamenají <i>Shift Left</i> a <i>Shift Right</i>, tedy bitový posun doleva a doprava. Od rotací se bitové posuny odliší především tím, že se při posunu doleva do nejnižšího bitu vždy vloží nula a při posunu doprava se do nejvyššího bitu taktéž uloží nula (při rotacích se naproti tomu namísto nuly použil příznak přenosu). K&nbsp;čemu je možné tyto instrukce využít? Typickým příkladem je optimalizace násobení mocninou dvou (instrukce <strong>SHL</strong>) či naopak dělení mocninou dvou (instrukce <strong>SHR</strong>). Musíme však mít na paměti důležitý fakt, že <strong>SHR</strong> lze použít pouze pro hodnoty bez znaménka (<i>unsigned</i>). Pro hodnoty se znaménkem je nutné použít instrukci <strong>SAR</strong> popsanou <a href="#k10">v&nbsp;navazující kapitole</a>.</p>

<p>Nastavení bitových příznaků uložených v&nbsp;registru <strong>EFLAGS</strong>:</p>

<table>
<tr><th>Příznak</th><th>Nastavení</th></tr>
<tr><td>Zero flag    </td><td>nastaven při nulovém výsledku</td></tr>
<tr><td>Sign flag    </td><td>nastaven podle nejvyššího bitu výsledku</td></tr>
<tr><td>Carry flag   </td><td>bit, který byl rotací přesunut na začátek/konec registru</td></tr>
<tr><td>Overflow flag</td><td>nastaven pouze při rotaci o jediný bit, má význam jako při sčítání a odčítání</td></tr>
</table>

<p>Poznámka: příznaky nejsou nastaveny ve chvíli, kdy je posun proveden o 0 bitů, i když by se teoreticky <i>Zero flag</i> a <i>Sign flag</i> nastavit mohl.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Aritmetický posun doprava</h2>

<p>K&nbsp;výše popsané šestici bitových rotací a posunů nalezneme v&nbsp;instrukční sadě mikroprocesorů řady x86 a x86-64 i takzvaný <i>aritmetický posun doprava</i> (<strong>SAR</strong> &ndash; <i>Shift Arithmetic Right</i>). Jedná se vlastně o obdobu bitového posunu doprava (<strong>SHR</strong>), ovšem s&nbsp;tím rozdílem, že obsah nejvyššího bitu zůstává za všech okolností zachován (a samozřejmě je ještě zkopírován do druhého nejvyššího bitu). Pokud si uvědomíme, jakým způsobem jsou reprezentovány hodnoty v&nbsp;systému dvojkového doplňku (viz předchozí části tohoto seriálu), je zřejmé, že tato instrukce ve většině případů (99,99% u šestnáctibitových čísel) provádí dělení dvěma, a to i pro záporné hodnoty. Pro aritmetický posun doleva žádná specializovaná instrukce není dostupná, protože ji lze nahradit běžným posunem (platí i pro záporná čísla reprezentovaná v&nbsp;systému dvojkového doplňku). Mnoho assemblerů sice nabízí instrukci <strong>SAL</strong>, ta je však kódována stejným způsobem jako instrukce <strong>SHL</strong>.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2016/09/03.png"><img class="alignnone size-thumbnail wp-image-7495" src="https://mojefedora.cz/wp-content/uploads/2016/09/03.png" alt="03" width="450" height="110" /></a>
<p><i>Obrázek 3: Aritmetický posun doprava (zde ukázán se 16bitovým operandem).</i></p>

<p>Nastavení bitových příznaků uložených v&nbsp;registru <strong>EFLAGS</strong>:</p>

<table>
<tr><th>Příznak</th><th>Nastavení</th></tr>
<tr><td>Zero flag    </td><td>nastaven při nulovém výsledku</td></tr>
<tr><td>Sign flag    </td><td>nastaven podle nejvyššího bitu výsledku</td></tr>
<tr><td>Carry flag   </td><td>bit, který byl rotací přesunut na začátek/konec registru</td></tr>
<tr><td>Overflow flag</td><td>nastaven pouze při rotaci o jediný bit, má význam jako při sčítání a odčítání</td></tr>
</table>

<p>Poznámka: příznaky nejsou nastaveny ve chvíli, kdy je posun proveden o 0 bitů, i když by se teoreticky <i>Zero flag</i> a <i>Sign flag</i> nastavit mohl.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Odkazy na Internetu</h2>

<ol>

<li>x86 Instruction Set Reference<br />
<a href="http://x86.renejeschke.de/">http://x86.renejeschke.de/</a>
</li>

<li>x86 Instruction Set Reference: Logical AND<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_12.html">http://x86.renejeschke.de/html/file_module_x86_id_12.html</a>
</li>

<li>x86 Instruction Set Reference: Logical Inclusive OR<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_219.html">http://x86.renejeschke.de/html/file_module_x86_id_219.html</a>
</li>

<li>x86 Instruction Set Reference: Logical Exclusive OR<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_330.html">http://x86.renejeschke.de/html/file_module_x86_id_330.html</a>
</li>

<li>x86 Instruction Set Reference: One's Complement Negation<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_218.html">http://x86.renejeschke.de/html/file_module_x86_id_218.html</a>
</li>

<li>x86 Instruction Set Reference: RCL/RCR/ROL/ROR<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_273.html">http://x86.renejeschke.de/html/file_module_x86_id_273.html</a>
</li>

<li>x86 Instruction Set Reference: SAL/SAR/SHL/SHR<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_285.html">http://x86.renejeschke.de/html/file_module_x86_id_285.html</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>The GNU Assembler Tutorial<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html">http://tigcc.ticalc.org/doc/gnuasm.html</a>
</li>

<li>The GNU Assembler - macros<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html#SEC109">http://tigcc.ticalc.org/doc/gnuasm.html#SEC109</a>
</li>

<li>ARM subroutines &amp; program stack<br />
<a href="http://www.toves.org/books/armsub/">http://www.toves.org/books/armsub/</a>
</li>

<li>Generating Mixed Source and Assembly List using GCC<br />
<a href="http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/">http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/</a>
</li>

<li>Calling subroutines<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm</a>
</li>

<li>ARM Assembly Language Programming<br />
<a href="http://peter-cockerell.net/aalp/html/frames.html">http://peter-cockerell.net/aalp/html/frames.html</a>
</li>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Intel x86 JUMP quick reference<br />
<a href="http://unixwiz.net/techtips/x86-jumps.html">http://unixwiz.net/techtips/x86-jumps.html</a>
</li>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Assembler pod Linuxem<br />
<a href="http://phoenix.inf.upol.cz/linux/prog/asm.html">http://phoenix.inf.upol.cz/linux/prog/asm.html</a>
</li>

<li>AT&amp;T Syntax versus Intel Syntax<br />
<a href="https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html">https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html</a>
</li>

<li>Linux Assembly website<br />
<a href="http://asm.sourceforge.net/">http://asm.sourceforge.net/</a>
</li>

<li>Using Assembly Language in Linux<br />
<a href="http://asm.sourceforge.net/articles/linasm.html">http://asm.sourceforge.net/articles/linasm.html</a>
</li>

<li>vasm<br />
<a href="http://sun.hasenbraten.de/vasm/">http://sun.hasenbraten.de/vasm/</a>
</li>

<li>vasm &ndash; dokumentace<br />
<a href="http://sun.hasenbraten.de/vasm/release/vasm.html">http://sun.hasenbraten.de/vasm/release/vasm.html</a>
</li>

<li>The Yasm Modular Assembler Project<br />
<a href="http://yasm.tortall.net/">http://yasm.tortall.net/</a>
</li>

<li>680x0:AsmOne<br />
<a href="http://www.amigacoding.com/index.php/680x0:AsmOne">http://www.amigacoding.com/index.php/680x0:AsmOne</a>
</li>

<li>ASM-One Macro Assembler<br />
<a href="http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler">http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler</a>
</li>

<li>ASM-One pages<br />
<a href="http://www.theflamearrows.info/documents/asmone.html">http://www.theflamearrows.info/documents/asmone.html</a>
</li>

<li>Základní informace o ASM-One<br />
<a href="http://www.theflamearrows.info/documents/asminfo.html">http://www.theflamearrows.info/documents/asminfo.html</a>
</li>

<li>Linux Syscall Reference<br />
<a href="http://syscalls.kernelgrok.com/">http://syscalls.kernelgrok.com/</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>IBM System 360/370 Compiler and Historical Documentation<br />
<a href="http://www.edelweb.fr/Simula/">http://www.edelweb.fr/Simula/</a>
</li>

<li>IBM 700/7000 series<br />
<a href="http://en.wikipedia.org/wiki/IBM_700/7000_series">http://en.wikipedia.org/wiki/IBM_700/7000_series</a>
</li>

<li>IBM System/360<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/360">http://en.wikipedia.org/wiki/IBM_System/360</a>
</li>

<li>IBM System/370<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/370">http://en.wikipedia.org/wiki/IBM_System/370</a>
</li>

<li>Mainframe family tree and chronology<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html</a>
</li>

<li>704 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html</a>
</li>

<li>705 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html</a>
</li>

<li>The IBM 704<br />
<a href="http://www.columbia.edu/acis/history/704.html">http://www.columbia.edu/acis/history/704.html</a>
</li>

<li>IBM Mainframe album<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html</a>
</li>

<li>Osmibitové muzeum<br />
<a href="http://osmi.tarbik.com/">http://osmi.tarbik.com/</a>
</li>

<li>Tesla PMI-80<br />
<a href="http://osmi.tarbik.com/cssr/pmi80.html">http://osmi.tarbik.com/cssr/pmi80.html</a>
</li>

<li>PMI-80<br />
<a href="http://en.wikipedia.org/wiki/PMI-80">http://en.wikipedia.org/wiki/PMI-80</a>
</li>

<li>PMI-80<br />
<a href="http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016">http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016</a>
</li>

<li>The 6502 overflow flag explained mathematically <br />
<a href="http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html">http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html</a>
</li>

<li>X86 Opcode and Instruction Reference<br />
<a href="http://ref.x86asm.net/coder32.html">http://ref.x86asm.net/coder32.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

