<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Použití assembleru v Linuxu: zpracování celých čísel se znaménkem</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Použití assembleru v Linuxu: zpracování celých čísel se znaménkem</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve většině aplikací, jejichž části jsou psané v&nbsp;assembleru, se setkáme s&nbsp;nutností zpracovávat celočíselné hodnoty se znaménkem, což například v&nbsp;programovacím jazyce C odpovídá datovému typu <i>signed int</i>. Naprostá většina moderních mikroprocesorů práci s&nbsp;tímto datovým typem nativně podporuje, ovšem práce s&nbsp;celými čísly se znaménkem od programátora vyžaduje poněkud hlubší znalosti. Zejména je nutné porozumět tomu, jakým způsobem se pracuje se všemi čtyřmi příznakovými bity a zejména pak s&nbsp;jejich kombinacemi. Právě tímto důležitým tématem se budeme zabývat dnes.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Použití assembleru v&nbsp;Linuxu: zpracování celých čísel se znaménkem</a></p>
<p><a href="#k02">2. Základní aritmetické operace s&nbsp;celými čísly se znaménkem</a></p>
<p><a href="#k03">3. Nastavení příznakových bitů Zero, Sign, Carry a Overflow při porovnání dvou operandů</a></p>
<p><a href="#k04">4. První demonstrační příklad &ndash; nastavení a test příznaku Zero</a></p>
<p><a href="#k05">5. Výsledky běhu prvního demonstračního příkladu</a></p>
<p><a href="#k06">6. Druhý demonstrační příklad &ndash; nastavení a test příznaku Sign</a></p>
<p><a href="#k07">7. Výsledky běhu druhého demonstračního příkladu</a></p>
<p><a href="#k08">8. Třetí demonstrační příklad &ndash; nastavení a test příznaku Carry</a></p>
<p><a href="#k09">9. Výsledky běhu třetího demonstračního příkladu</a></p>
<p><a href="#k10">10. Čtvrtý demonstrační příklad &ndash; nastavení a test příznaku Overflow</a></p>
<p><a href="#k11">11. Výsledky běhu čtvrtého demonstračního příkladu</a></p>
<p><a href="#k12">12. Podmíněné skoky při práci s&nbsp;celými čísly se znaménkem</a></p>
<p><a href="#k13">13. První skupina podmíněných skoků &ndash; test jediného příznaku</a></p>
<p><a href="#k14">14. Druhá skupina podmíněných skoků &ndash; test kombinace příznaků</a></p>
<p><a href="#k15">15. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k16">16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Použití assembleru v&nbsp;Linuxu: zpracování celých čísel se znaménkem</h2>

<p>Všechny moderní typy mikroprocesorů obsahují ve svých instrukčních sadách mj.&nbsp;i instrukce určené pro zpracování celých čísel se znaménkem. V&nbsp;první řadě se pochopitelně jedná o instrukce, které lze použít pro provedení základních aritmetických operací (součet, rozdíl, součin, podíl popř.&nbsp;i výpočet zbytku po dělení), ovšem nesmíme zapomenout ani na operace aritmetického posunu doprava a doleva (neboli násobení a dělení mocninou dvou) a taktéž na podmíněné skoky. Právě kvůli podpoře podmíněných skoků je nutné, aby mikroprocesory kromě dvou již popsaných bitových příznaků <strong>Zero Flag</strong> a <strong>Carry Flag</strong> správně pracovaly i s&nbsp;příznaky <strong>Sign Flag</strong> a především pak <strong>Overflow Flag</strong> (poznámka: některé architektury, například MIPS, se zcela obejdou bez použití bitových příznaků, ovšem jak architektuře i386 a x86-64, tak i na klasické architektuře ARM, které jsou minimálně v&nbsp;tomto ohledu prakticky totožné, se s&nbsp;příznaky pracuje).</p>

<p>V&nbsp;dnešním článku se v&nbsp;úvodu seznámíme s&nbsp;významem všech čtyř zmíněných příznaků. Dále si řekneme, které základní aritmetické operace je možné použít na mikroprocesorové architektuře i386 a x86-64 a jak přesně se nastavují všechny čtyři již zmíněné příznaky. Následovat bude čtveřice poměrně jednoduchých demonstračních příkladů, na nichž je ukázán konkrétní způsob nastavení příznaků při provádění operace <strong>ADD</strong> a <strong>CMP</strong> s&nbsp;různými hodnotami. <a href="#k12">Ve dvanácté kapitole</a> a v&nbsp;dalších dvou navazujících kapitolách si pak řekneme, jaké typy podmíněných skoků se používají při práci s&nbsp;celými čísly se znaménkem. Uvidíme, že se tyto skoky jsou již mnohem složitější, než tomu bylo u podmíněných skoků používaných při práci s&nbsp;čísly bez znaménka (je tomu tak proto, že u některých podmínek je nutné testovat kombinaci většího množství příznaků).</p>

<p>Poznámka: pod pojmem &bdquo;čísla se znaménkem&ldquo; (signed integer) je myšlena reprezentace celých čísel <a href="https://cs.wikipedia.org/wiki/Dvojkov%C3%BD_dopln%C4%9Bk">v&nbsp;doplňkovém kódu</a> (dvojkový doplněk).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Základní aritmetické operace s&nbsp;celými čísly se znaménkem</h2>

<p>Pro začátek se budeme zabývat instrukční sadou mikroprocesorů s&nbsp;architekturou i386 a x86-64, a to z&nbsp;toho důvodu, aby bylo možné si všechny příklady ihned otestovat na běžném desktopu či notebooku. U těchto typů mikroprocesorů nalezneme několik aritmetických instrukcí podporujících zpracování celých čísel se znaménkem. Tyto instrukce jsou vypsány v&nbsp;následujících tabulkách. Většina zmíněných instrukcí dokáže zpracovat osmibitové, šestnáctibitové, 32bitové i 64bitové hodnoty, přičemž jeden operand může ležet v&nbsp;operační paměti a nikoli v&nbsp;pracovním registru:</p>

<h3>Operace se dvěma vstupními operandy</h3>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th><th>Poznámka</th></tr>
<tr><td>1</td><td>ADD dest, src</td><td>součet</td><td>použitelné i pro čísla bez znaménka</td></tr>
<tr><td>2</td><td>ADC dest, src</td><td>součet s&nbsp;přičtením CF</td><td>použitelné i pro čísla bez znaménka</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>SUB dest, src</td><td>rozdíl</td><td>použitelné i pro čísla bez znaménka</td></tr>
<tr><td>4</td><td>SBB dest, src</td><td>rozdíl</td><td>k&nbsp;menšiteli je nejprve přičten CF</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>IMUL dest, src</td><td>součin</td><td>nastavuje jen CF a OF</td></tr>
<tr><td>6</td><td>IMUL dest, src1, src2</td><td>součin dest=src1*src2</td><td>nastavuje jen CF a OF</td></tr>
<tr><td>7</td><td>IDIV dest</td><td>podíl + výpočet zbytku po dělení</td><td>příznaky nedefinované</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>8</td><td>CMP src1, src2</td><td>porovnání registrů</td><td>jako SUB, ovšem bez uložení výsledku</td></tr>
</table>

<p>Poznámka<sup>1</sup>: u instrukce <strong>IDIV</strong> je první vstupní operand typicky uložen v&nbsp;registrovém páru AX, DX:AX či EDX:EAX. Výsledkem této instrukce je dvojice hodnot &ndash; podíl a zbytek po dělení.</p>

<p>Poznámka<sup>2</sup>: při striktním pohledu by se mohlo zdát, že instrukce <strong>CMP</strong> do seznamu aritmetických instrukcí nepatří, ovšem jedná se vlastně o běžnou instrukci <strong>SUB</strong> (rozdíl), s&nbsp;tím, že se nikam neukládá výsledek, pouze se nastaví všechny čtyři bitové příznaky. Tato instrukce je velmi užitečná a často používaná (i překladači).</p>



<h3>Operace s&nbsp;jedním vstupním operandem</h3>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th><th>Poznámka</th></tr>
<tr><td>1</td><td>INC</td><td>zvýšení registru či buňky v&nbsp;paměti o 1</td><td>nenastavuje CF</td></tr>
<tr><td>2</td><td>DEC</td><td>snížení registru či buňky v&nbsp;paměti o 1</td><td>nenastavuje CF</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>NEG</td><td>vynásobení hodnotou -1</td><td>CF == 0 pro vstup==0, jinak CF==1</td></tr>
</table>

<p>Poznámka<sup>1</sup>: zajímavé je, že instrukce <strong>INC</strong> a <strong>DEC</strong> nenastavují příznak CF, a to i když dojde k&nbsp;přetečení (hodnota CF je zachována, čehož lze v&nbsp;některých algoritmech využít). Lze tedy testovat pouze příznak ZF, který však má prakticky stejný význam: u <strong>ADD operand,1</strong> se CF nastaví ve stejné chvíli jako ZF atd. (sami si to vyzkoušejte, ovšem u <strong>SUB operand,1</strong> je to o krok posunuté).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Nastavení příznakových bitů Zero, Sign, Carry a Overflow při porovnání dvou operandů</h2>

<p><a href="#k02">V&nbsp;předchozí kapitole</a> jsme se explicitně zmínili o velkém praktickém významu instrukce <strong>CMP</strong> použité při porovnání dvou operandů. Tato instrukce nastaví všechny čtyři bitové příznaky (navíc ještě příznak parity atd., ale to není tak důležité). Zajímavé je, že instrukce pracuje korektně jak pro čísla bez znaménka, tak i pro čísla se znaménkem, ovšem u čísel bez znaménka má smysl kontrolovat pouze příznaky ZF a CF, zatímco u čísel se znaménkem kombinaci tří příznaků ZF, SF a OF:</p>

<table>
<tr><th>Příznak</th><th colspan="2">Bez znaménka</th><th colspan="2">Se znaménkem</th></tr>
<tr><th>Hodnota</th><th>0</th><th>1</th><th>0</th><th>1</th></tr>
<tr><td>ZF</td><td>nerovnost</td><td>rovnost</td><td>nerovnost</td><td>rovnost</td></tr>
<tr><td>CF</td><td>větší nebo rovno</td><td>menší než</td><td>&times;</td><td>&times;</td></tr>
<tr><td>SF</td><td>&times;</td><td>&times;</td><td colspan="2">viz další text</td></tr>
<tr><td>OF</td><td>&times;</td><td>&times;</td><td colspan="2">viz další text</td></tr>
</table>

<p>Pro čísla se znaménkem je tedy skutečně nutné sledovat hodnoty příznaků ZF, SF a OF. Význam příznaku ZF je zřejmý &ndash; otestuje se jím rovnost obou porovnávaných operandů, protože bit ZF nabude hodnoty 1 pouze za předpokladu, že operand1==operand2 a tedy operand1-operand2==0. U příznaků SF a OF je to již poněkud komplikovanější, o čemž se můžeme přesvědčit při pohledu na následující tabulku:</p>

<table>
<tr><th>SF</th><th>OF</th><th>Význam</th></tr>
<tr><td>0</td><td>1</td><td>menší než</td></tr>
<tr><td>1</td><td>0</td><td>menší než</td></tr>
<tr><td>0</td><td>0</td><td>větší nebo rovno</td></tr>
<tr><td>1</td><td>1</td><td>větší nebo rovno</td></tr>
</table>

<p>Jinými slovy &ndash; podmínka operand1&lt;operand2 je splněna ve chvíli, kdy platí SF&oplus;OF==1, kde &oplus; je bitový operátor XOR. Pokud naopak platí SF==OF, byla splněna podmínka operand1&ge;operand2. O rozhodnutí o zbylých dvou podmínkách operand1&le;operand2 a operand1&gt;operand2 se postará přečtení bitového příznaku ZF. Opět pro přehlednost:</p>

<table>
<tr><th>ZF</th><th>SF</th><th>OF</th><th>Význam</th></tr>
<tr><td>0</td><td>0</td><td>1</td><td>menší než</td></tr>
<tr><td>0</td><td>1</td><td>0</td><td>menší než</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>větší než</td></tr>
<tr><td>0</td><td>1</td><td>1</td><td>větší než</td></tr>
<tr><td>1</td><td>0</td><td>1</td><td>rovnost</td></tr>
<tr><td>1</td><td>1</td><td>0</td><td>rovnost</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>rovnost</td></tr>
<tr><td>1</td><td>1</td><td>1</td><td>rovnost</td></tr>
</table>

<p>Poznámka: ve skutečnosti všechny tyto možnosti nemohou nastat, což se týká posledních čtyř řádků tabulky (otázka pro čtenáře &ndash; proč tomu tak je?).</p>

<p>Pokud vás zajímá, jak přesně jsou použity výše zmíněné bitové příznaky v&nbsp;podmíněných skocích, pokračujte ve čtení <a href="#k12">dvanácté kapitoly</a>. V&nbsp;následujících osmi kapitolách se totiž na relativně jednoduchých demonstračních příkladech přesvědčíme, za jakých okolností jsou příznaky nastavovány, což je sice užitečné pro pochopení interního chování mikroprocesoru a jeho ALU (aritmeticko-logické jednotky), ovšem u většiny programů je důležité pouze vědět, jaká instrukce skoku se má použít v&nbsp;návaznosti na instrukci <strong>CMP</strong>.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. První demonstrační příklad &ndash; nastavení a test příznaku Zero</h2>

<p>S&nbsp;příznakem ZF (Zero Flag) jsme se již poměrně podrobně seznámili v&nbsp;předchozích částech tohoto seriálu, takže si nyní pouze vytvořme demonstrační příklad, který ukáže, za jakých okolností se tento příznak nastaví instrukcemi <strong>ADD</strong> a <strong>CMP</strong>. V&nbsp;příkladu použijeme znalosti, které jsme získali <a href="https://mojefedora.cz/pouziti-assembleru-v-linuxu-makra-v-gnu-assembleru-dokonceni/">minule</a> a <a href="https://mojefedora.cz/pouziti-assembleru-v-linuxu-makra-v-gnu-assembleru/">předminule</a>, což konkrétně znamená, že příklad je rozdělen do tří souborů <strong>exit.s</strong>, <strong>writeMessage.s</strong> a <strong>zero_flag.s</strong> a používá ve velké míře makra. V&nbsp;prvním souboru nalezneme makro použité pro ukončení procesu:</p>

<pre>
# asmsyntax=as

# Makro pro ukonceni procesu v Linuxu.
#
# Autor: Pavel Tisnovsky

sys_exit   = 1

# Deklarace makra pro ukonceni aplikace
.macro exit
        mov   eax, sys_exit          # cislo sycallu pro funkci "exit"
        mov   ebx, 0                 # exit code = 0
        int   0x80                   # volani Linuxoveho kernelu
.endm
</pre>

<p>Ve druhém souboru najdeme makro a subrutinu (volanou makrem) pro zobrazení řetězce na standardním výstupu:</p>

<pre>
# asmsyntax=as

# Makro pro tisk zpravy na standardni vystup.
#
# Autor: Pavel Tisnovsky

# Linux kernel system call table
sys_write  = 4
std_output = 1


# Deklarace makra pro vytisteni zpravy na standardni vystup
.macro writeMessage message,messageLength
        mov   ecx, offset \message   # adresa retezce, ktery se ma vytisknout
        mov   edx, \messageLength    # pocet znaku, ktere se maji vytisknout
        call  write_message          # vytisknout zpravu "Zero flag not set"
.endm



# Podprogram pro vytisteni zpravy na standardni vystup
# Ocekava se, ze v ecx bude adresa zpravy a v edx jeji delka
write_message:
        mov   eax, sys_write         # cislo syscallu pro funkci "write"
        mov   ebx, std_output        # standardni vystup
        int   0x80
        ret
</pre>

<p>Třetí příklad obsahuje především dvojici maker nazvaných <strong>compareAndShowZeroFlag</strong> a <strong>addAndShowZeroFlag</strong>. Těmto makrům se předají dvě celočíselné 32bitové hodnoty se znaménkem, následně se provede vybraná operace (<strong>ADD</strong> nebo <strong>CMP</strong>) a vytiskne se hodnota příznaku ZF (Zero Flag) nastavená těmito operacemi. Tato makra jsou následně volána s&nbsp;různými hodnotami, viz též <a href="#k05">navazující kapitolu</a>:</p>

<pre>
# asmsyntax=as

# Program pro otestovani chovani priznaku ZF (priznak nulovosti)
# - pouzita je "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix



# Nacteni definice makra pro ukonceni aplikace
.include "exit.s"

# Nacteni maker pro tisk zpravy i prislusne subrutiny
.include "writeMessage.s"

#-----------------------------------------------------------------------------

# Deklarace makra pro porovnani dvou hodnot a vytisteni stavu priznaku ZF
.macro compareAndShowZeroFlag const1, const2
        mov   eax, \const1
        mov   ebx, \const2
        cmp   eax, ebx               # porovnani registru a nastaveni priznaku
        jz    zero_set\@             # test na priznak ZF
        writeMessage messageZeroNotSet, messageZeroNotSetLen
        jmp   end_compare\@
zero_set\@:
        writeMessage messageZeroSet, messageZeroSetLen
end_compare\@:
.endm

# Deklarace makra pro soucet dvou hodnot a vytisteni stavu priznaku ZF
.macro addAndShowZeroFlag const1, const2
        mov   eax, \const1
        mov   ebx, \const2
        add   eax, ebx               # soucet registru a nastaveni priznaku
        jz    zero_set\@             # test na priznak ZF
        writeMessage messageZeroNotSet, messageZeroNotSetLen
        jmp   end_add\@
zero_set\@:
        writeMessage messageZeroSet, messageZeroSetLen
end_add\@:
.endm



#-----------------------------------------------------------------------------
.section .data
messageZeroSet:
        .string "Zero flag set\n"
messageZeroSetLen = $ - messageZeroSet  # delka prvni zpravy

messageZeroNotSet:
        .string "Zero flag not set\n"
messageZeroNotSetLen = $ - messageZeroNotSet  # delka druhe zpravy

messageCmp:
        .string "\nInstruction: CMP\n"
messageCmpLen = $ - messageCmp     # delka treti zpravy

messageAdd:
        .string "\nInstruction: ADD\n"
messageAddLen = $ - messageAdd     # delka ctvrte zpravy

messagePositiveValues:
        .string "\nPositive values\n"
messagePositiveValuesLen = $ - messagePositiveValues

messageNegativeValues:
        .string "\nNegative values\n"
messageNegativeValuesLen = $ - messageNegativeValues

message0x7fffffffand0x80000000:
        .string "\n0x7fffffff and 0x80000000\n"
message0x7fffffffand0x80000000Len = $ - message0x7fffffffand0x80000000



#-----------------------------------------------------------------------------
.section .bss



#-----------------------------------------------------------------------------
.section .text
        .global _start               # tento symbol ma byt dostupny i linkeru

_start:
        writeMessage messageCmp, messageCmpLen

        writeMessage messagePositiveValues, messagePositiveValuesLen
        compareAndShowZeroFlag    0,   0
        compareAndShowZeroFlag  100,   0
        compareAndShowZeroFlag    0, 100
        compareAndShowZeroFlag  100, 100

        writeMessage messageNegativeValues, messageNegativeValuesLen
        compareAndShowZeroFlag -100,    0
        compareAndShowZeroFlag    0, -100
        compareAndShowZeroFlag -100, -100

        writeMessage messageAdd, messageAddLen

        writeMessage messagePositiveValues, messagePositiveValuesLen
        addAndShowZeroFlag   0,   0
        addAndShowZeroFlag 100,   0
        addAndShowZeroFlag   0, 100
        addAndShowZeroFlag 100, 100

        writeMessage messageNegativeValues, messageNegativeValuesLen
        addAndShowZeroFlag -100,    0
        addAndShowZeroFlag  100, -100
        addAndShowZeroFlag -100,  100
        addAndShowZeroFlag -100, -100

        writeMessage message0x7fffffffand0x80000000, message0x7fffffffand0x80000000Len
        addAndShowZeroFlag 0x7fffffff, 0x7fffffff
        addAndShowZeroFlag 0x7fffffff, 0x80000000
        addAndShowZeroFlag 0x80000000, 0x80000000
        addAndShowZeroFlag 0x80000000, 0x80000001

        exit                              # ukonceni aplikace
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Výsledky běhu prvního demonstračního příkladu</h2>

<p>Podívejme se nyní na výsledky vypsané na standardní výstup dnešním prvním demonstračním příkladem:</p>

<pre>
Instruction: CMP

Positive values
Zero flag set
Zero flag not set
Zero flag not set
Zero flag set

Negative values
Zero flag not set
Zero flag not set
Zero flag set

Instruction: ADD

Positive values
Zero flag set
Zero flag not set
Zero flag not set
Zero flag not set

Negative values
Zero flag not set
Zero flag set
Zero flag set
Zero flag not set

0x7fffffff and 0x80000000
Zero flag not set
Zero flag not set
Zero flag set
Zero flag not set
</pre>

<p>Výsledky lze shrnout následovně. U operace <strong>CMP</strong> je to nejjednodušší &ndash; pokud jsou oba porovnávané operandy totožné, nastaví se ZF na jedničku, v&nbsp;opačném případě na nulu. Nezáleží ani na nulovosti operandů, ani na jejich znaménku:</p>

<table>
<tr><th>Operand 1</th><th>Operand 2</th><th>ZF po CMP</th><th>Poznámka</th></tr>
<tr><td>   0</td><td>   0</td><td>1</td><td>shodné operandy</td></tr>
<tr><td> 100</td><td>   0</td><td>0</td><td>rozdílné operandy</td></tr>
<tr><td>   0</td><td> 100</td><td>0</td><td>rozdílné operandy</td></tr>
<tr><td> 100</td><td> 100</td><td>1</td><td>shodné operandy</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>-100</td><td>   0</td><td>0</td><td>rozdílné operandy</td></tr>
<tr><td>   0</td><td>-100</td><td>0</td><td>rozdílné operandy</td></tr>
<tr><td>-100</td><td>-100</td><td>1</td><td>shodné operandy</td></tr>
</table>

<p>U operace <strong>ADD</strong> nezáleží na původní hodnotě operandů, ale pouze na výsledku součtu. Pokud je součet nulový, je nastaven ZF na jedničku, v&nbsp;opačném případě na nulu. Pozor však na speciální případ, kdy dojde k&nbsp;přetečení výsledku &ndash; výsledek bude mít hodnotu přesně 0x100000000, což je o jedničku více, než maximální hodnota 0xffffffff reprezentovaná 32 bity. Ovšem vzhledem k&nbsp;tomu, že hodnota 0x100000000 má všech spodních 32bitů nulových, je i v&nbsp;tomto případě ZF nastaven:</p>

<table>
<tr><th>Operand 1</th><th>Operand 2</th><th>ZF po ADD</th><th>Poznámka</th></tr>
<tr><td>   0</td><td>   0</td><td>1</td><td>0+0 = 0</td></tr>
<tr><td> 100</td><td>   0</td><td>0</td><td>100+0 &ne; 0</td></tr>
<tr><td>   0</td><td> 100</td><td>0</td><td>0+100 &ne; 0</td></tr>
<tr><td> 100</td><td> 100</td><td>0</td><td>100+100 &ne; 0</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>-100</td><td>   0</td><td>0</td><td>-100+0 &ne; 0</td></tr>
<tr><td> 100</td><td>-100</td><td>1</td><td>100+(-100) = 0</td></tr>
<tr><td>-100</td><td> 100</td><td>1</td><td>-100+100 = 0</td></tr>
<tr><td>-100</td><td>-100</td><td>0</td><td>-100+(-100) &ne; 0</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x7fffffff</td><td>0x7fffffff</td><td>0</td><td>přetečení, spodních 32bitů &ne; 0</td></tr>
<tr><td>0x7fffffff</td><td>0x80000000</td><td>0</td><td>přetečení, spodních 32bitů &ne; 0</td></tr>
<tr><td>0x80000000</td><td>0x80000000</td><td>1</td><td>přetečení, spodních 32bitů = 0</td></tr>
<tr><td>0x80000000</td><td>0x80000001</td><td>0</td><td>přetečení, spodních 32bitů &ne; 0</td></tr>
</table>



<p><a name="k06"></a></p>
<h2 id="k06">6. Druhý demonstrační příklad &ndash; nastavení a test příznaku Sign</h2>

<p>Druhý demonstrační příklad se prakticky ve všech ohledech podobá příkladu prvnímu, ovšem namísto testování příznaku ZF se zde testuje příznak SF, tedy znaménko výsledku prováděné operace (u instrukce <strong>CMP</strong> se tedy jedná o výsledek rozdílu obou operandů). Nejprve se podívejme na zdrojový kód tohoto příkladu, důležitější však bude pohled na výsledek uvedený <a href="#k07">v&nbsp;navazující kapitole</a>:</p>

<pre>
# asmsyntax=as

# Program pro otestovani chovani priznaku SF (priznak znamenka)
# - pouzita je "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix



# Nacteni definice makra pro ukonceni aplikace
.include "exit.s"

# Nacteni maker pro (opakovany) tisk zpravy i prislusne subrutiny
.include "writeMessage.s"

#-----------------------------------------------------------------------------

# Deklarace makra pro porovnani dvou hodnot a vytisteni stavu priznaku ZF
.macro compareAndShowSignFlag const1, const2
        mov   eax, \const1
        mov   ebx, \const2
        cmp   eax, ebx               # porovnani registru a nastaveni priznaku
        js    sign_set\@             # test na priznak SF
        writeMessage messageSignNotSet, messageSignNotSetLen
        jmp   end_compare\@
sign_set\@:
        writeMessage messageSignSet, messageSignSetLen
end_compare\@:
.endm

# Deklarace makra pro soucet dvou hodnot a vytisteni stavu priznaku ZF
.macro addAndShowSignFlag const1, const2
        mov   eax, \const1
        mov   ebx, \const2
        add   eax, ebx               # soucet registru a nastaveni priznaku
        js    sign_set\@             # test na priznak SF
        writeMessage messageSignNotSet, messageSignNotSetLen
        jmp   end_add\@
sign_set\@:
        writeMessage messageSignSet, messageSignSetLen
end_add\@:
.endm



#-----------------------------------------------------------------------------
.section .data
messageSignSet:
        .string "Sign flag set\n"
messageSignSetLen = $ - messageSignSet  # delka prvni zpravy

messageSignNotSet:
        .string "Sign flag not set\n"
messageSignNotSetLen = $ - messageSignNotSet  # delka druhe zpravy

messageCmp:
        .string "\nInstruction: CMP\n"
messageCmpLen = $ - messageCmp     # delka treti zpravy

messageAdd:
        .string "\nInstruction: ADD\n"
messageAddLen = $ - messageAdd     # delka ctvrte zpravy

messagePositiveValues:
        .string "\nPositive values\n"
messagePositiveValuesLen = $ - messagePositiveValues

messageNegativeValues:
        .string "\nNegative values\n"
messageNegativeValuesLen = $ - messageNegativeValues

message0x7fffffffand0x80000000:
        .string "\n0x7fffffff and 0x80000000\n"
message0x7fffffffand0x80000000Len = $ - message0x7fffffffand0x80000000



#-----------------------------------------------------------------------------
.section .bss



#-----------------------------------------------------------------------------
.section .text
        .global _start               # tento symbol ma byt dostupny i linkeru

_start:
        writeMessage messageCmp, messageCmpLen

        writeMessage messagePositiveValues, messagePositiveValuesLen
        compareAndShowSignFlag    0,   0
        compareAndShowSignFlag  100,   0
        compareAndShowSignFlag    0, 100
        compareAndShowSignFlag  100, 100

        writeMessage messageNegativeValues, messageNegativeValuesLen
        compareAndShowSignFlag -100,    0
        compareAndShowSignFlag    0, -100
        compareAndShowSignFlag -100, -100

        writeMessage messageAdd, messageAddLen

        writeMessage messagePositiveValues, messagePositiveValuesLen
        addAndShowSignFlag   0,   0
        addAndShowSignFlag 100,   0
        addAndShowSignFlag   0, 100
        addAndShowSignFlag 100, 100

        writeMessage messageNegativeValues, messageNegativeValuesLen
        addAndShowSignFlag -100,    0
        addAndShowSignFlag  100, -100
        addAndShowSignFlag -100,  100
        addAndShowSignFlag -100, -100

        writeMessage message0x7fffffffand0x80000000, message0x7fffffffand0x80000000Len
        addAndShowSignFlag 0x7fffffff, 0x7fffffff
        addAndShowSignFlag 0x7fffffff, 0x80000000
        addAndShowSignFlag 0x80000000, 0x80000000
        addAndShowSignFlag 0x80000000, 0x80000001

        exit                              # ukonceni aplikace
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Výsledky běhu druhého demonstračního příkladu</h2>

<p>Podobně jako u příkladu prvního, i zde si nejprve uvedeme zprávy vypsané demonstračním příkladem a posléze výsledky shrneme v&nbsp;přehlednějších tabulkách:</p>

<pre>
Instruction: CMP

Positive values
Sign flag not set
Sign flag not set
Sign flag set
Sign flag not set

Negative values
Sign flag set
Sign flag not set
Sign flag not set

Instruction: ADD

Positive values
Sign flag not set
Sign flag not set
Sign flag not set
Sign flag not set

Negative values
Sign flag set
Sign flag not set
Sign flag not set
Sign flag set

0x7fffffff and 0x80000000
Sign flag set
Sign flag set
Sign flag not set
Sign flag not set
</pre>

<p>Podívejme se nyní na shrnutí všech výsledků vypsaných tímto demonstračním příkladem. Začneme operací <strong>CMP</strong>, která odečte oba operandy a do příznaku SF dosadí znaménko výsledku (rozdílu). Pokud je výsledek záporný, je SF nastaven na jedničku, v&nbsp;opačném případě je nastaven na nulu:</p>

<table>
<tr><th>Operand 1</th><th>Operand 2</th><th>SF po CMP</th><th>Poznámka</th></tr>
<tr><td>   0</td><td>   0</td><td>0</td><td>0 - 0 &ge; 0</td></tr>
<tr><td> 100</td><td>   0</td><td>0</td><td>100 - 0 &ge; 0</td></tr>
<tr><td>   0</td><td> 100</td><td>1</td><td>0 - 100 &lt; 0</td></tr>
<tr><td> 100</td><td> 100</td><td>0</td><td>100 - 0 &ge; 0</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>-100</td><td>   0</td><td>1</td><td>-100 - 0 &lt; 0</td></tr>
<tr><td>   0</td><td>-100</td><td>0</td><td>0 - (-100) &ge; 0</td></tr>
<tr><td>-100</td><td>-100</td><td>0</td><td>-100 - (-100) &ge; 0</td></tr>
</table>

<p>Z&nbsp;této tabulky vyplývá i sémantika operace <strong>CMP</strong> a příznaku SF &ndash; testuje se platnost podmínek x - y &ge; 0 a x - y &lt; 0.</p>

<p>Výsledky pro operaci <strong>ADD</strong>:</p>

<table>
<tr><th>Operand 1</th><th>Operand 2</th><th>SF po ADD</th><th>Poznámka</th></tr>
<tr><td>   0</td><td>   0</td><td>0</td><td>0+0 &ge; 0</td></tr>
<tr><td> 100</td><td>   0</td><td>0</td><td>100+0 &ge; 0</td></tr>
<tr><td>   0</td><td> 100</td><td>0</td><td>0+100 &ge; 0</td></tr>
<tr><td> 100</td><td> 100</td><td>0</td><td>100+100 &ge; 0</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>-100</td><td>   0</td><td>1</td><td>-100+0 &lt; 0</td></tr>
<tr><td> 100</td><td>-100</td><td>0</td><td>100+(-100) &ge; 0</td></tr>
<tr><td>-100</td><td> 100</td><td>0</td><td>-100+100 &ge; 0</td></tr>
<tr><td>-100</td><td>-100</td><td>1</td><td>-100+(-100) &lt; 0</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x7fffffff</td><td>0x7fffffff</td><td>1</td><td>nejvyšší bit výsledku má hodnotu 1</td></tr>
<tr><td>0x7fffffff</td><td>0x80000000</td><td>1</td><td>nejvyšší bit výsledku má hodnotu 1</td></tr>
<tr><td>0x80000000</td><td>0x80000000</td><td>0</td><td>nejvyšší bit výsledku má hodnotu 0</td></tr>
<tr><td>0x80000000</td><td>0x80000001</td><td>0</td><td>nejvyšší bit výsledku má hodnotu 0</td></tr>
</table>

<p>Opět si povšimněte, že v&nbsp;mezních případech &ndash; při přetečení &ndash; je sice příznak SF &bdquo;nějak&ldquo; nastaven, ale bez dalších testů nejsme schopni říci, k&nbsp;jaké situaci přesně došlo.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Třetí demonstrační příklad &ndash; nastavení a test příznaku Carry</h2>

<p>Třetí demonstrační příklad již bude poněkud zajímavější, než předchozí dva příklady, protože v&nbsp;něm budeme sledovat nastavení příznaku přenosu (<i>carry</i>), a to jak v&nbsp;případě výpočtu rozdílu operandů (instrukce <strong>CMP</strong>), tak i při jejich součtu (instrukce <strong>ADD</strong>). Zdrojový kód tohoto příkladu je prakticky totožný s&nbsp;příklady předchozími, samozřejmě ovšem s&nbsp;tím rozdílem, že namísto podmíněného skoku <strong>jz</strong> (<i>jump if ZF set</i>) či <strong>js</strong> (<i>jump if SF set</i>) je použit podmíněný skok <strong>jc</strong> (<i>jump if CF set</i>):</p>

<pre>
# asmsyntax=as

# Program pro otestovani chovani priznaku CF (priznak prenosu)
# - pouzita je "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix



# Nacteni definice makra pro ukonceni aplikace
.include "exit.s"

# Nacteni maker pro (opakovany) tisk zpravy i prislusne subrutiny
.include "writeMessage.s"

#-----------------------------------------------------------------------------

# Deklarace makra pro porovnani dvou hodnot a vytisteni stavu priznaku ZF
.macro compareAndShowCarryFlag const1, const2
        mov   eax, \const1
        mov   ebx, \const2
        cmp   eax, ebx               # porovnani registru a nastaveni priznaku
        jc    carry_set\@             # test na priznak CF
        writeMessage messageCarryNotSet, messageCarryNotSetLen
        jmp   end_compare\@
carry_set\@:
        writeMessage messageCarrySet, messageCarrySetLen
end_compare\@:
.endm

# Deklarace makra pro soucet dvou hodnot a vytisteni stavu priznaku ZF
.macro addAndShowCarryFlag const1, const2
        mov   eax, \const1
        mov   ebx, \const2
        add   eax, ebx               # soucet registru a nastaveni priznaku
        jc    carry_set\@             # test na priznak CF
        writeMessage messageCarryNotSet, messageCarryNotSetLen
        jmp   end_add\@
carry_set\@:
        writeMessage messageCarrySet, messageCarrySetLen
end_add\@:
.endm



#-----------------------------------------------------------------------------
.section .data
messageCarrySet:
        .string "Carry flag set\n"
messageCarrySetLen = $ - messageCarrySet  # delka prvni zpravy

messageCarryNotSet:
        .string "Carry flag not set\n"
messageCarryNotSetLen = $ - messageCarryNotSet  # delka druhe zpravy

messageCmp:
        .string "\nInstruction: CMP\n"
messageCmpLen = $ - messageCmp     # delka treti zpravy

messageAdd:
        .string "\nInstruction: ADD\n"
messageAddLen = $ - messageAdd     # delka ctvrte zpravy

messagePositiveValues:
        .string "\nPositive values\n"
messagePositiveValuesLen = $ - messagePositiveValues

messageNegativeValues:
        .string "\nNegative values\n"
messageNegativeValuesLen = $ - messageNegativeValues

message0x7fffffffand0x80000000:
        .string "\n0x7fffffff and 0x80000000\n"
message0x7fffffffand0x80000000Len = $ - message0x7fffffffand0x80000000



#-----------------------------------------------------------------------------
.section .bss



#-----------------------------------------------------------------------------
.section .text
        .global _start               # tento symbol ma byt dostupny i linkeru

_start:
        writeMessage messageCmp, messageCmpLen

        writeMessage messagePositiveValues, messagePositiveValuesLen
        compareAndShowCarryFlag    0,   0
        compareAndShowCarryFlag  100,   0
        compareAndShowCarryFlag    0, 100
        compareAndShowCarryFlag  100, 100

        writeMessage messageNegativeValues, messageNegativeValuesLen
        compareAndShowCarryFlag -100,    0
        compareAndShowCarryFlag    0, -100
        compareAndShowCarryFlag -100, -100

        writeMessage messageAdd, messageAddLen

        writeMessage messagePositiveValues, messagePositiveValuesLen
        addAndShowCarryFlag   0,   0
        addAndShowCarryFlag 100,   0
        addAndShowCarryFlag   0, 100
        addAndShowCarryFlag 100, 100

        writeMessage messageNegativeValues, messageNegativeValuesLen
        addAndShowCarryFlag -100,    0
        addAndShowCarryFlag  100, -100
        addAndShowCarryFlag -100,  100
        addAndShowCarryFlag -100, -100

        writeMessage message0x7fffffffand0x80000000, message0x7fffffffand0x80000000Len
        addAndShowCarryFlag 0x7fffffff, 0
        addAndShowCarryFlag 0x7fffffff, 1
        addAndShowCarryFlag 0x7fffffff, 2
        addAndShowCarryFlag 0x7fffffff, 0x7fffffff
        addAndShowCarryFlag 0x7fffffff, 0x80000000
        addAndShowCarryFlag 0x80000000, 0x80000000
        addAndShowCarryFlag 0x80000000, 0x80000001

        exit                              # ukonceni aplikace

</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Výsledky běhu třetího demonstračního příkladu</h2>

<p>Po překladu a spuštění tohoto příkladu získáme na standardním výstupu následující zprávy:</p>

<pre>
Instruction: CMP

Positive values
Carry flag not set
Carry flag not set
Carry flag set
Carry flag not set

Negative values
Carry flag not set
Carry flag set
Carry flag not set

Instruction: ADD

Positive values
Carry flag not set
Carry flag not set
Carry flag not set
Carry flag not set

Negative values
Carry flag not set
Carry flag set
Carry flag set
Carry flag set

0x7fffffff and 0x80000000
Carry flag not set
Carry flag not set
Carry flag not set
Carry flag not set
Carry flag not set
Carry flag set
Carry flag set
</pre>

<p>Shrnutí výsledků bude podobné, jako u předchozích dvou příkladů.</p>

<p>Operace <strong>CMP</strong>:</p>

<table>
<tr><th>Operand 1</th><th>Operand 2</th><th>CF po CMP</th><th>Poznámka</th></tr>
<tr><td>   0</td><td>   0</td><td>0</td><td>nedošlo k&nbsp;přenosu</td></tr>
<tr><td> 100</td><td>   0</td><td>0</td><td>nedošlo k&nbsp;přenosu</td></tr>
<tr><td>   0</td><td> 100</td><td>1</td><td>při operaci 0-100 je potřeba výpůjčka (<i>borrow</i>)</td></tr>
<tr><td> 100</td><td> 100</td><td>0</td><td>nedošlo k&nbsp;přenosu</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>-100</td><td>   0</td><td>0</td><td>nedošlo k&nbsp;přenosu (-100 v&nbsp;dvojkovém doplňku)</td></tr>
<tr><td>   0</td><td>-100</td><td>1</td><td>při operaci 0-(-100) je potřeba výpůjčka (<i>borrow</i>)</td></tr>
<tr><td>-100</td><td>-100</td><td>0</td><td>rozdíl dvou stejných čísel &ndash; nedojde k&nbsp;přenosu</td></tr>
</table>

<p>Povšimněte si, že příznak <i>carry</i> (přenos) je nastavován i v&nbsp;případě, že byla použita výpůjčka (<i>borrow</i>). U některých typů mikroprocesorů je tomu přesně naopak! (ze stále používaných čipů se jedná o řadu PIC).</p>

<p>Operace <strong>ADD</strong>:</p>

<table>
<tr><th>Operand 1</th><th>Operand 2</th><th>CF po ADD</th><th>Poznámka</th></tr>
<tr><td>   0</td><td>   0</td><td>0</td><td>bez přenosu</td></tr>
<tr><td> 100</td><td>   0</td><td>0</td><td>bez přenosu</td></tr>
<tr><td>   0</td><td> 100</td><td>0</td><td>bez přenosu</td></tr>
<tr><td> 100</td><td> 100</td><td>0</td><td>bez přenosu</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>-100</td><td>   0</td><td>0</td><td>bez přenosu</td></tr>
<tr><td> 100</td><td>-100</td><td>1</td><td>s&nbsp;přenosem! (-100 v&nbsp;dvojkovém doplňku)</td></tr>
<tr><td>-100</td><td> 100</td><td>1</td><td>s&nbsp;přenosem! (-100 v&nbsp;dvojkovém doplňku)</td></tr>
<tr><td>-100</td><td>-100</td><td>1</td><td>s&nbsp;přenosem! (-100 v&nbsp;dvojkovém doplňku)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x7fffffff</td><td>0</td><td>0</td><td>bez přenosu</td></tr>
<tr><td>0x7fffffff</td><td>1</td><td>0</td><td>bez přenosu</td></tr>
<tr><td>0x7fffffff</td><td>2</td><td>0</td><td>bez přenosu</td></tr>
<tr><td>0x7fffffff</td><td>0x7fffffff</td><td>0</td><td>bez přenosu</td></tr>
<tr><td>0x7fffffff</td><td>0x80000000</td><td>0</td><td>bez přenosu (na hranici)</td></tr>
<tr><td>0x80000000</td><td>0x80000000</td><td>1</td><td>přenos a výsledkem je 0</td></tr>
<tr><td>0x80000000</td><td>0x80000001</td><td>1</td><td>přenos a výsledkem je 1</td></tr>
</table>

<p>Zde můžeme vidět dvě zajímavosti:</p>

<ol>

<li>U operací typu -100+100 je sice výsledkem nula, ale ve skutečnosti dojde k&nbsp;přenosu, protože hodnota -100 je reprezentována v&nbsp;dvojkovém doplňku.</li>

<li>U čísel bez znaménka nedává (u porovnávání operací <strong>CMP</strong>) moc smysl testovat právě CF, protože je výsledek nekonzistentní.</li>

</ol>



<p><a name="k10"></a></p>
<h2 id="k10">10. Čtvrtý demonstrační příklad &ndash; nastavení a test příznaku Overflow</h2>

<p>Čtvrtý a současně i dnešní poslední demonstrační příklad je v&nbsp;kontextu tohoto článku nejdůležitější, protože ukazuje, jakým způsobem je nastavován příznak přetečení (<i>overflow</i>) u operací <strong>ADD</strong> a <strong>CMP</strong>. Podívejme se nejprve na zdrojový kód tohoto příkladu:</p>

<pre>
# asmsyntax=as

# Program pro otestovani chovani priznaku OF (priznak preteceni)
# - pouzita je "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix



# Nacteni definice makra pro ukonceni aplikace
.include "exit.s"

# Nacteni maker pro (opakovany) tisk zpravy i prislusne subrutiny
.include "writeMessage.s"

#-----------------------------------------------------------------------------

# Deklarace makra pro porovnani dvou hodnot a vytisteni stavu priznaku ZF
.macro compareAndShowOverflowFlag const1, const2
        mov   eax, \const1
        mov   ebx, \const2
        cmp   eax, ebx               # porovnani registru a nastaveni priznaku
        jo    overflow_set\@             # test na priznak OF
        writeMessage messageOverflowNotSet, messageOverflowNotSetLen
        jmp   end_compare\@
overflow_set\@:
        writeMessage messageOverflowSet, messageOverflowSetLen
end_compare\@:
.endm

# Deklarace makra pro soucet dvou hodnot a vytisteni stavu priznaku ZF
.macro addAndShowOverflowFlag const1, const2
        mov   eax, \const1
        mov   ebx, \const2
        add   eax, ebx               # soucet registru a nastaveni priznaku
        jo    overflow_set\@             # test na priznak OF
        writeMessage messageOverflowNotSet, messageOverflowNotSetLen
        jmp   end_add\@
overflow_set\@:
        writeMessage messageOverflowSet, messageOverflowSetLen
end_add\@:
.endm



#-----------------------------------------------------------------------------
.section .data
messageOverflowSet:
        .string "Overflow flag set\n"
messageOverflowSetLen = $ - messageOverflowSet  # delka prvni zpravy

messageOverflowNotSet:
        .string "Overflow flag not set\n"
messageOverflowNotSetLen = $ - messageOverflowNotSet  # delka druhe zpravy

messageCmp:
        .string "\nInstruction: CMP\n"
messageCmpLen = $ - messageCmp     # delka treti zpravy

messageAdd:
        .string "\nInstruction: ADD\n"
messageAddLen = $ - messageAdd     # delka ctvrte zpravy

messagePositiveValues:
        .string "\nPositive values\n"
messagePositiveValuesLen = $ - messagePositiveValues

messageNegativeValues:
        .string "\nNegative values\n"
messageNegativeValuesLen = $ - messageNegativeValues

message0x7fffffffand0x80000000:
        .string "\n0x7fffffff and 0x80000000\n"
message0x7fffffffand0x80000000Len = $ - message0x7fffffffand0x80000000



#-----------------------------------------------------------------------------
.section .bss



#-----------------------------------------------------------------------------
.section .text
        .global _start               # tento symbol ma byt dostupny i linkeru

_start:
        writeMessage messageCmp, messageCmpLen

        writeMessage messagePositiveValues, messagePositiveValuesLen
        compareAndShowOverflowFlag    0,   0
        compareAndShowOverflowFlag  100,   0
        compareAndShowOverflowFlag    0, 100
        compareAndShowOverflowFlag  100, 100

        writeMessage messageNegativeValues, messageNegativeValuesLen
        compareAndShowOverflowFlag -100,    0
        compareAndShowOverflowFlag    0, -100
        compareAndShowOverflowFlag -100, -100

        writeMessage messageAdd, messageAddLen

        writeMessage messagePositiveValues, messagePositiveValuesLen
        addAndShowOverflowFlag   0,   0
        addAndShowOverflowFlag 100,   0
        addAndShowOverflowFlag   0, 100
        addAndShowOverflowFlag 100, 100

        writeMessage messageNegativeValues, messageNegativeValuesLen
        addAndShowOverflowFlag -100,    0
        addAndShowOverflowFlag  100, -100
        addAndShowOverflowFlag -100,  100
        addAndShowOverflowFlag -100, -100

        writeMessage message0x7fffffffand0x80000000, message0x7fffffffand0x80000000Len
        addAndShowOverflowFlag 0x7fffffff, 0
        addAndShowOverflowFlag 0x7fffffff, 1
        addAndShowOverflowFlag 0x7fffffff, 2
        addAndShowOverflowFlag 0x7fffffff, 0x7fffffff
        addAndShowOverflowFlag 0x7fffffff, 0x80000000
        addAndShowOverflowFlag 0x80000000, 0x80000000
        addAndShowOverflowFlag 0x80000000, 0x80000001

        exit                              # ukonceni aplikace
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Výsledky běhu čtvrtého demonstračního příkladu</h2>

<p>Výsledky čtvrtého příkladu jsou nejzajímavější a poněkud méně předvídatelné, takže je vhodné je sledovat pečlivěji. Nejprve se podívejme, jaké zprávy se vypíšou na standardní výstup:</p>

<pre>
Instruction: CMP

Positive values
Overflow flag not set
Overflow flag not set
Overflow flag not set
Overflow flag not set

Negative values
Overflow flag not set
Overflow flag not set
Overflow flag not set

Instruction: ADD

Positive values
Overflow flag not set
Overflow flag not set
Overflow flag not set
Overflow flag not set

Negative values
Overflow flag not set
Overflow flag not set
Overflow flag not set
Overflow flag not set

0x7fffffff and 0x80000000
Overflow flag not set
Overflow flag set
Overflow flag set
Overflow flag set
Overflow flag not set
Overflow flag set
Overflow flag set
</pre>

<p>Operace <strong>CMP</strong>:</p>

<table>
<tr><th>Operand 1</th><th>Operand 2</th><th>OF po CMP</th><th>Poznámka</th></tr>
<tr><td>   0</td><td>   0</td><td>0</td><td>nedošlo k&nbsp;přetečení</td></tr>
<tr><td> 100</td><td>   0</td><td>0</td><td>nedošlo k&nbsp;přetečení</td></tr>
<tr><td>   0</td><td> 100</td><td>1</td><td>nedošlo k&nbsp;přetečení</td></tr>
<tr><td> 100</td><td> 100</td><td>0</td><td>nedošlo k&nbsp;přetečení</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>-100</td><td>   0</td><td>0</td><td>nedošlo k&nbsp;přetečení</td></tr>
<tr><td>   0</td><td>-100</td><td>1</td><td>nedošlo k&nbsp;přetečení</td></tr>
<tr><td>-100</td><td>-100</td><td>0</td><td>nedošlo k&nbsp;přetečení</td></tr>
</table>

<p>Na rozdíl od příznaku CF, který v&nbsp;případě záporných čísel dával nekonzistentní výsledky, je příznak OF konzistentní &ndash; všechny porovnávané hodnoty jsou tak malé, že u jejich rozdílu k&nbsp;přetečení nedojde.</p>

<p>Operace <strong>ADD</strong>:</p>

<table>
<tr><th>Operand 1</th><th>Operand 2</th><th>CF po ADD</th><th>Poznámka</th></tr>
<tr><td>   0</td><td>   0</td><td>0</td><td>bez přetečení</td></tr>
<tr><td> 100</td><td>   0</td><td>0</td><td>bez přetečení</td></tr>
<tr><td>   0</td><td> 100</td><td>0</td><td>bez přetečení</td></tr>
<tr><td> 100</td><td> 100</td><td>0</td><td>bez přetečení</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>-100</td><td>   0</td><td>0</td><td>bez přetečení</td></tr>
<tr><td> 100</td><td>-100</td><td>0</td><td>bez přetečení</td></tr>
<tr><td>-100</td><td> 100</td><td>0</td><td>bez přetečení</td></tr>
<tr><td>-100</td><td>-100</td><td>0</td><td>bez přetečení</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>0x7fffffff</td><td>0</td><td>0</td><td>bez přetečení (mezní případ)</td></tr>
<tr><td>0x7fffffff</td><td>1</td><td>1</td><td>došlo ke změně znaménka výsledku &ndash; přetečení</td></tr>
<tr><td>0x7fffffff</td><td>2</td><td>1</td><td>došlo ke změně znaménka výsledku &ndash; přetečení</td></tr>
<tr><td>0x7fffffff</td><td>0x7fffffff</td><td>1</td><td>došlo ke změně znaménka</td></tr>
<tr><td>0x7fffffff</td><td>0x80000000</td><td>0</td><td>výsledkem je -1, ovšem druhý vstupní operand je záporný</td></tr>
<tr><td>0x80000000</td><td>0x80000000</td><td>1</td><td>změna znaménka a současně i přenos (<i>carry</i>)</td></tr>
<tr><td>0x80000000</td><td>0x80000001</td><td>1</td><td>změna znaménka a současně i přenos (<i>carry</i>)</td></tr>
</table>

<p>Z&nbsp;tabulky je patrné, že při nastavování příznaku OF se testují jak znaménka vstupních operandů, tak i operandů výstupního. Vzorec pro výpočet vypadá takto:</p>

<p>OF = not (((A<sub>31</sub> nor B<sub>31</sub>) and C<sub>30</sub>) nor ((A<sub>31</sub> nand B<sub>31</sub>) nor C<sub>30</sub>))</p>

<p>C<sub>30</sub> je přenos z&nbsp;třicátého do třicátého prvního bitu, A a B jsou vstupní operandy.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Podmíněné skoky při práci s&nbsp;celými čísly se znaménkem</h2>

<p>Nyní již máme k&nbsp;dispozici všechny informace potřebné pro to, abychom se seznámili s&nbsp;podmíněnými skoky používanými při práci s&nbsp;celými čísly. Připomeňme si, že podmíněné skoky jsou v&nbsp;assembleru základním prvkem pro řízení běhu programu, tedy pro tvorbu programových smyček i rozhodovacích konstrukcí typu <i>if-then-else</i>. V&nbsp;případě celých čísel bez znaménka jsme si (většinou) vystačili s&nbsp;pouhým porovnáním a otestováním příznaku ZF a/nebo CF. Příkladem může být již dříve popsaná programová smyčka určená pro vytištění sekvence hvězdiček:</p>

<pre>
        mov   ecx, offset buffer     # zapis se bude provadet do tohoto bufferu
        mov   ebx, rep_count         # pocet opakovani znaku
        mov   al,  '*'               # zapisovany znak
loop:
        mov   [ecx], al              # zapis znaku do bufferu
        inc   ecx                    # uprava ukazatele do bufferu
        dec   ebx                    # zmenseni pocitadla
        jnz   loop                   # pokud jsme se nedostali k nule, skok na zacatek smycky
</pre>

<p>U čísel se znaménkem je to složitější, neboť je nutné testovat kombinaci tří příznaků: ZF, SF a OF, což je naznačeno v&nbsp;poslední tabulce uvedené <a href="#k03">ve třetí kapitole</a>. Sémantika skoků je platná pro operaci <strong>CMP</strong> a samozřejmě též <strong>SUB</strong>.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. První skupina podmíněných skoků &ndash; test jediného příznaku</h2>

<p>Některé podmíněné skoky si po porovnání dvou operandů se znaménkem vystačí s&nbsp;testováním jediného příznaku. Jedná se o následující skoky:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Alias</th><th>Test</th><th>Podmínka</th></tr>
<tr><td>1</td><td>JZ </td><td>JE </td><td>ZF == 1</td><td>op1 == op2</td></tr>
<tr><td>2</td><td>JNZ</td><td>JNE</td><td>ZF == 0</td><td>op1 &ne; op2</td></tr>
</table>

<p>Mnemotechnické pomůcky:</p>

<ol>
<li>JE - Jump if equal</li>
<li>JNE - Jump if not equal</li>
</ol>



<p><a name="k14"></a></p>
<h2 id="k14">14. Druhá skupina podmíněných skoků &ndash; test kombinace příznaků</h2>

<p>Ostatní podmíněné skoky po porovnání dvou operandů se znaménkem musí testovat kombinaci většího množství příznaků. Jedná se o následující skoky:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Alias</th><th>Test</th><th>Podmínka</th></tr>
<tr><td>1</td><td>JL </td><td>JNGE</td><td>SF &lt;&gt; OF</td><td>op1 &lt; op2</td></tr>
<tr><td>2</td><td>JGE</td><td>JNL </td><td>SF == OF</td><td>op1 &ge; op2</td></tr>
<tr><td>3</td><td>JLE</td><td>JNG </td><td>ZF = 1 or SF &lt;&gt; OF</td><td>op1 &le; op2</td></tr>
<tr><td>4</td><td>JG </td><td>JNLE</td><td>ZF = 0 and SF == OF</td><td>op1 &gt; op2</td></tr>
</table>

<p>Poznámka: interně se podmínka SF &lt;&gt; OF realizuje pomocí bitové operace SF &oplus; OF.</p>


<p>Mnemotechnické pomůcky:</p>

<ol>
<li>JL &ndash; Jump if less</li>
<li>JNGE &ndash; Jump if not greater or equal</li>
<li>JGE &ndash; Jump if greater or equal</li>
<li>JNL &ndash; Jump if not less</li>
<li>JLE &ndash;Jump if less or equal</li>
<li>JNG &ndash; Jump if not greater</li>
<li>JG &ndash; Jump if greater</li>
<li>JNLE &ndash; Jump if not less or equal</li>
</ol>



<p><a name="k15"></a></p>
<h2 id="k15">15. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popisované demonstrační příklady byly, podobně jako ve všech předchozích částech tohoto seriálu, společně s&nbsp;podpůrnými skripty určenými pro jejich překlad či naopak pro disassembling, uloženy do GIT repositáře dostupného na adrese <a href="https://github.com/tisnik/presentations/">https://github.com/tisnik/presentations/</a>. Všechny příklady jsou určeny pro GNU Assembler a používají Intel syntaxi, která je čitelnější, než původní AT&amp;T syntaxe. Následuje tabulka s&nbsp;odkazy na zdrojové kódy příkladů i na již zmíněné podpůrné skripty:</p>

<h3>První demonstrační příklad &ndash; nastavení a test příznaku Zero</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>zero_flag.s</td><td>hlavní program pro GNU Assembler</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/28_zero_flag/zero_flag.s">https://github.com/tisnik/presentations/blob/master/assembler/28_zero_flag/zero_flag.s</a></td></tr>
<tr><td>2</td><td>exit.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/28_zero_flag/exit.s">https://github.com/tisnik/presentations/blob/master/assembler/28_zero_flag/exit.s</a></td></tr>
<tr><td>3</td><td>writeMessage.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/28_zero_flag/writeMessage.s">https://github.com/tisnik/presentations/blob/master/assembler/28_zero_flag/writeMessage.s</a></td></tr>
<tr><td>4</td><td>assemble</td><td>skript pro překlad na procesorech i386</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/28_zero_flag/assemble">https://github.com/tisnik/presentations/blob/master/assembler/28_zero_flag/assemble</a></td></tr>
<tr><td>5</td><td>disassemble</td><td>skript pro disassembling</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/28_zero_flag/disassemble">https://github.com/tisnik/presentations/blob/master/assembler/28_zero_flag/disassemble</a></td></tr>
</table>



<h3>Druhý demonstrační příklad &ndash; nastavení a test příznaku Sign</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>sign_flag.s</td><td>hlavní program pro GNU Assembler</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/29_sign_flag/sign_flag.s">https://github.com/tisnik/presentations/blob/master/assembler/29_sign_flag/sign_flag.s</a></td></tr>
<tr><td>2</td><td>exit.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/29_sign_flag/exit.s">https://github.com/tisnik/presentations/blob/master/assembler/29_sign_flag/exit.s</a></td></tr>
<tr><td>3</td><td>writeMessage.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/29_sign_flag/writeMessage.s">https://github.com/tisnik/presentations/blob/master/assembler/29_sign_flag/writeMessage.s</a></td></tr>
<tr><td>4</td><td>assemble</td><td>skript pro překlad na procesorech i386</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/29_sign_flag/assemble">https://github.com/tisnik/presentations/blob/master/assembler/29_sign_flag/assemble</a></td></tr>
<tr><td>5</td><td>disassemble</td><td>skript pro disassembling</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/29_sign_flag/disassemble">https://github.com/tisnik/presentations/blob/master/assembler/29_sign_flag/disassemble</a></td></tr>
</table>



<h3>Třetí demonstrační příklad &ndash; nastavení a test příznaku Carry</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>carry_flag.s</td><td>hlavní program pro GNU Assembler</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/30_carry_flag/carry_flag.s">https://github.com/tisnik/presentations/blob/master/assembler/30_carry_flag/carry_flag.s</a></td></tr>
<tr><td>2</td><td>exit.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/30_carry_flag/exit.s">https://github.com/tisnik/presentations/blob/master/assembler/30_carry_flag/exit.s</a></td></tr>
<tr><td>3</td><td>writeMessage.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/30_carry_flag/writeMessage.s">https://github.com/tisnik/presentations/blob/master/assembler/30_carry_flag/writeMessage.s</a></td></tr>
<tr><td>4</td><td>assemble</td><td>skript pro překlad na procesorech i386</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/30_carry_flag/assemble">https://github.com/tisnik/presentations/blob/master/assembler/30_carry_flag/assemble</a></td></tr>
<tr><td>5</td><td>disassemble</td><td>skript pro disassembling</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/30_carry_flag/disassemble">https://github.com/tisnik/presentations/blob/master/assembler/30_carry_flag/disassemble</a></td></tr>
</table>



<h3>Čtvrtý demonstrační příklad &ndash; nastavení a test příznaku Overflow</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>overflow_flag.s</td><td>hlavní program pro GNU Assembler</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/31_overflow_flag/overflow_flag.s">https://github.com/tisnik/presentations/blob/master/assembler/31_overflow_flag/overflow_flag.s</a></td></tr>
<tr><td>2</td><td>exit.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/31_overflow_flag/exit.s">https://github.com/tisnik/presentations/blob/master/assembler/31_overflow_flag/exit.s</a></td></tr>
<tr><td>3</td><td>writeMessage.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/31_overflow_flag/writeMessage.s">https://github.com/tisnik/presentations/blob/master/assembler/31_overflow_flag/writeMessage.s</a></td></tr>
<tr><td>4</td><td>assemble</td><td>skript pro překlad na procesorech i386</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/31_overflow_flag/assemble">https://github.com/tisnik/presentations/blob/master/assembler/31_overflow_flag/assemble</a></td></tr>
<tr><td>5</td><td>disassemble</td><td>skript pro disassembling</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/31_overflow_flag/disassemble">https://github.com/tisnik/presentations/blob/master/assembler/31_overflow_flag/disassemble</a></td></tr>
</table>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>The GNU Assembler Tutorial<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html">http://tigcc.ticalc.org/doc/gnuasm.html</a>
</li>

<li>The GNU Assembler - macros<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html#SEC109">http://tigcc.ticalc.org/doc/gnuasm.html#SEC109</a>
</li>

<li>ARM subroutines &amp; program stack<br />
<a href="http://www.toves.org/books/armsub/">http://www.toves.org/books/armsub/</a>
</li>

<li>Generating Mixed Source and Assembly List using GCC<br />
<a href="http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/">http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/</a>
</li>

<li>Calling subroutines<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm</a>
</li>

<li>ARM Assembly Language Programming<br />
<a href="http://peter-cockerell.net/aalp/html/frames.html">http://peter-cockerell.net/aalp/html/frames.html</a>
</li>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Intel x86 JUMP quick reference<br />
<a href="http://unixwiz.net/techtips/x86-jumps.html">http://unixwiz.net/techtips/x86-jumps.html</a>
</li>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Assembler pod Linuxem<br />
<a href="http://phoenix.inf.upol.cz/linux/prog/asm.html">http://phoenix.inf.upol.cz/linux/prog/asm.html</a>
</li>

<li>AT&amp;T Syntax versus Intel Syntax<br />
<a href="https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html">https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html</a>
</li>

<li>Linux Assembly website<br />
<a href="http://asm.sourceforge.net/">http://asm.sourceforge.net/</a>
</li>

<li>Using Assembly Language in Linux<br />
<a href="http://asm.sourceforge.net/articles/linasm.html">http://asm.sourceforge.net/articles/linasm.html</a>
</li>

<li>vasm<br />
<a href="http://sun.hasenbraten.de/vasm/">http://sun.hasenbraten.de/vasm/</a>
</li>

<li>vasm &ndash; dokumentace<br />
<a href="http://sun.hasenbraten.de/vasm/release/vasm.html">http://sun.hasenbraten.de/vasm/release/vasm.html</a>
</li>

<li>The Yasm Modular Assembler Project<br />
<a href="http://yasm.tortall.net/">http://yasm.tortall.net/</a>
</li>

<li>680x0:AsmOne<br />
<a href="http://www.amigacoding.com/index.php/680x0:AsmOne">http://www.amigacoding.com/index.php/680x0:AsmOne</a>
</li>

<li>ASM-One Macro Assembler<br />
<a href="http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler">http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler</a>
</li>

<li>ASM-One pages<br />
<a href="http://www.theflamearrows.info/documents/asmone.html">http://www.theflamearrows.info/documents/asmone.html</a>
</li>

<li>Základní informace o ASM-One<br />
<a href="http://www.theflamearrows.info/documents/asminfo.html">http://www.theflamearrows.info/documents/asminfo.html</a>
</li>

<li>Linux Syscall Reference<br />
<a href="http://syscalls.kernelgrok.com/">http://syscalls.kernelgrok.com/</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>IBM System 360/370 Compiler and Historical Documentation<br />
<a href="http://www.edelweb.fr/Simula/">http://www.edelweb.fr/Simula/</a>
</li>

<li>IBM 700/7000 series<br />
<a href="http://en.wikipedia.org/wiki/IBM_700/7000_series">http://en.wikipedia.org/wiki/IBM_700/7000_series</a>
</li>

<li>IBM System/360<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/360">http://en.wikipedia.org/wiki/IBM_System/360</a>
</li>

<li>IBM System/370<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/370">http://en.wikipedia.org/wiki/IBM_System/370</a>
</li>

<li>Mainframe family tree and chronology<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html</a>
</li>

<li>704 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html</a>
</li>

<li>705 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html</a>
</li>

<li>The IBM 704<br />
<a href="http://www.columbia.edu/acis/history/704.html">http://www.columbia.edu/acis/history/704.html</a>
</li>

<li>IBM Mainframe album<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html</a>
</li>

<li>Osmibitové muzeum<br />
<a href="http://osmi.tarbik.com/">http://osmi.tarbik.com/</a>
</li>

<li>Tesla PMI-80<br />
<a href="http://osmi.tarbik.com/cssr/pmi80.html">http://osmi.tarbik.com/cssr/pmi80.html</a>
</li>

<li>PMI-80<br />
<a href="http://en.wikipedia.org/wiki/PMI-80">http://en.wikipedia.org/wiki/PMI-80</a>
</li>

<li>PMI-80<br />
<a href="http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016">http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016</a>
</li>

<li>The 6502 overflow flag explained mathematically <br />
<a href="http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html">http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html</a>
</li>

<li>X86 Opcode and Instruction Reference<br />
<a href="http://ref.x86asm.net/coder32.html">http://ref.x86asm.net/coder32.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

