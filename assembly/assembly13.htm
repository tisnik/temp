<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Použití assembleru v Linuxu: operace s jednotlivými bity, koncept Booleovského procesoru</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Použití assembleru v Linuxu: operace s jednotlivými bity, koncept Booleovského procesoru</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;relativně velkém množství algoritmů se nepracuje pouze s&nbsp;bajty či ještě širšími slovy (16bitů, 32bitů, 64bitů), ale &bdquo;pouze&ldquo; s&nbsp;jednotlivými bity. Z&nbsp;tohoto důvodu nalezneme u některých typů mikroprocesorových architektur speciální instrukce určené pro manipulaci s&nbsp;bity, konkrétně pro jejich testování, změnu hodnoty, vyhledávání jedničkového bitu v&nbsp;delším bitovém řetězci, prohození vybraných bitů v&nbsp;registru atd. Právě s&nbsp;tímto typem instrukcí dostupných na procesorech s&nbsp;architekturou i386 a x86-64 se seznámíme v&nbsp;dnešním článku.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Použití assembleru v Linuxu: operace s jednotlivými bity, koncept Booleovského procesoru</a></p>
<p><a href="#k02">2. Koncept plnohodnotného Booleovského procesoru versus bitové operace</a></p>
<p><a href="#k03">3. Instrukce BT: test hodnoty vybraného bitu</a></p>
<p><a href="#k04">4. První demonstrační příklad: test hodnoty vybraného bitu</a></p>
<p><a href="#k05">5. Instrukce BTS, BTR a BTC: test hodnoty vybraného bitu s&nbsp;jeho nastavením či negací</a></p>
<p><a href="#k06">6. Druhý demonstrační příklad: změna vybraných bitů bez použití masky</a></p>
<p><a href="#k07">7. Instrukce BSF a BSR: hledání nenulového bitu v&nbsp;bitovém řetězci</a></p>
<p><a href="#k08">8. Třetí demonstrační příklad: nalezení prvního nenulového bitu</a></p>
<p><a href="#k09">9. Čtvrtý demonstrační příklad: nalezení posledního nenulového bitu</a></p>
<p><a href="#k10">10. Instrukce XCHG a BSWAP: prohození bajtů ve slovech různé šířky</a></p>
<p><a href="#k11">11. Pátý demonstrační příklad: použití instrukce BSWAP</a></p>
<p><a href="#k12">12. Instrukce typu SETcc aneb podpora pro céčkové výrazy s&nbsp;logickými hodnotami</a></p>
<p><a href="#k13">13. Pomocná makra a procedury použité v&nbsp;demonstračních příkladech</a></p>
<p><a href="#k14">14. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k15">15. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Použití assembleru v Linuxu: operace s jednotlivými bity, koncept Booleovského procesoru</h2>

<p>V&nbsp;dnešním článku si popíšeme některé specifické instrukce, které je možné použít u všech soudobých mikroprocesorů s&nbsp;architekturou i386 i x86-64. Tyto instrukce jsou určeny pro manipulaci s&nbsp;jednotlivými bity, ať již se jedná o bity uložené v&nbsp;nějakém pracovním registru či o bity uložené přímo v&nbsp;operační paměti. V&nbsp;první skupině se nachází jediná instrukce určená pro test hodnoty vybraného bitu, ve skupině druhé nalezneme tři instrukce, které kromě testu ještě změní hodnotu bitu, ve třetí skupině můžeme najít instrukce, které dokážou vyhledat index prvního či naopak posledního nenulového bitu (předpokládá se, že registr neobsahuje samé nuly), následují instrukce určené pro prohození skupiny bitů v&nbsp;registru (<i>little endian/big endian</i> atd.) a konečně si v&nbsp;závěru článku popíšeme instrukce, které dokážou nastavit hodnotu ve vybraném registru na nulu či naopak na jedničku, a to na základě splnění či nesplnění nějaké podmínky. Chování některých dále popsaných instrukcí si otestujeme v&nbsp;pěti demonstračních příkladech, v&nbsp;nichž mj.&nbsp;využijeme i makra a subrutiny, které jsme si popsali <a href="https://mojefedora.cz/pouziti-assembleru-v-linuxu-aritmeticke-a-logicke-instrukce-i-bitove-posuny-v-praxi/">v&nbsp;předchozím článku</a> (výpis dekadické i hexadecimální hodnoty atd.).</p>

<p>Jen pro zajímavost a doplnění pro pamětníky: prakticky všechny instrukce, které budou popsány v&nbsp;následujících kapitolách (až na instrukce <strong>XCHG</strong> a <strong>BSWAP</strong>) byly do instrukčního souboru přidány &bdquo;až&ldquo; v&nbsp;32bitových procesorech Intel 80386, zatímco v&nbsp;řadě 8088, 8086, 80186 a 80286 je nenalezneme. Týká se to instrukcí <strong>BT</strong>, <strong>BTC</strong>, <strong>BTS</strong>, <strong>BTR</strong>, <strong>BSF</strong>, <strong>BSR</strong> i celé skupiny <strong>SETcc</strong>. Jedinou instrukcí přidanou později (konkrétně společně s&nbsp;procesory 80486) je instrukce <strong>BSWAP</strong>.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Koncept plnohodnotného Booleovského procesoru versus bitové operace</h2>

<p>S&nbsp;konceptem takzvaných <i>Booleovských procesorů</i> má společnost Intel dlouhodobou zkušenost, protože ho využila například u známých a dodnes používaných osmibitových mikrořadičů řady <i>Intel 8051 (MCS-51)</i>. Tímto termínem se označuje sada instrukcí, které dokážou pracovat na úrovni jednotlivých bitů a nikoli celých slov, a to (většinou) dokonce takovým způsobem, že i přístup do operační paměti či do speciálních řídicích registrů (SFR) periferních zařízení je prováděn po jednom bitu (například negace jediného bitu je rozdílná operace od přečtení bajtu/slova do akumulátoru, negace vybraného bitu a zápis celého bajtu/slova zpět). Jen pro zajímavost: na již zmíněném mikrořadiči <i>MCS-51</i> je implementován úplný Booleovský procesor s&nbsp;jednobitovým akumulátorem (tím je příznak <strong>C</strong>/<i>carry</i>), sedmnácti instrukcemi, 128 bitovou oblastí RAM a 128 bitovou oblastí speciálních řídicích registrů (SFR).</p>

<p>U mikroprocesorů i386 a x86-64 je Booleovský procesor, resp.&nbsp;přesněji řečeno instrukce pro práci s&nbsp;jednotlivými bity, sice taktéž použit, ale nemá tak velký význam, a to z&nbsp;toho prostého důvodu, že architektura i386/x86-64 není (alespoň v&nbsp;naprosté většině případů) použita pro implementaci mikrořadiče s&nbsp;množstvím speciálních řídicích registrů, u nichž má význam číst či zapisovat jednotlivé bity. Taktéž datová sběrnice je zcela odlišná, takže instrukce <strong>BT</strong>, <strong>BTC</strong> atd. ve skutečnosti vždy přenáší celá 32bitová či 64bitová slova.</p>

<p>Poznámka: uvádí se, že na mikrořadiči Intel 8051 mohlo použití instrukcí Booleovského procesoru zkrátit programy až o 30%.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Instrukce BT: test hodnoty vybraného bitu</h2>

<p>První strojovou instrukcí, s&nbsp;níž se v&nbsp;dnešním článku seznámíme, je instrukce nazvaná <i>Bit Test</i>. Zkratka této instrukce používaná v&nbsp;assemblerech, disassemblerech a debuggerech je <strong>BT</strong>, což je v&nbsp;rámci instrukční sady mikroprocesorů s&nbsp;architekturou i386 i x86-64 jedna z&nbsp;mála výjimek, protože většina instrukcí má třípísmennou či ještě delší zkratku (druhou výjimkou je instrukce nazvaná <strong>IN</strong>). Instrukce <strong>BT</strong> slouží k&nbsp;provedení testu vybraného bitu registru popř.&nbsp;bitu uloženého na specifikované adrese operační paměti. Na základě hodnoty tohoto bitu (0 či 1) je nastaven příznak <strong>CF</strong> (<i>Carry Flag</i>), který je následně možné použít v&nbsp;dalších instrukcích, například pro provedení podmíněného skoku atd. Existují celkem čtyři kombinace operandů vstupujících do instrukce <strong>BT</strong>:</p>

<table>
<tr><th>První operand</th><th>Druhý operand (číslo bitu)</th></tr>
<tr><td>registr</td><td>registr</td></tr>
<tr><td>registr</td><td>konstanta</td></tr>
<tr><td>adresa</td><td>registr</td></tr>
<tr><td>adresa</td><td>konstanta</td></tr>
</table>

<p>Poznámka: při adresování buňky paměti, v&nbsp;níž se nachází testovaný bit, je možné použít většinu adresovacích režimů s&nbsp;nimiž jsme se již setkali v&nbsp;předchozích částech tohoto seriálu (registr, registr+offset, registr1+registr2&times;konstanta+offset apod.).</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. První demonstrační příklad: test hodnoty vybraného bitu</h2>

<p>V&nbsp;prvním demonstračním příkladu si ukážeme (poměrně umělé) použití instrukce <strong>BT</strong>. Pro zadané 32bitové hodnoty se vždy otestuje hodnota bitu s&nbsp;nejnižší váhou, hodnota bitu s&nbsp;indexem 1 a posléze hodnota bitu s&nbsp;váhou nejvyšší. Hodnoty těchto bitů jsou následně vypsány na standardní výstup, a to s&nbsp;použitím jednoduchého triku: vzhledem k&nbsp;tomu, že je výsledek testu zapsán do příznakového bitu <i>Carry Flag</i>, můžeme tento bit snadno přičíst k&nbsp;registru obsahujícího ASCII kód znaku "0" instrukcí <strong>ADC registr, 0</strong> (<i>ADC=Add With Carry Flag</i>). Co se v&nbsp;tomto případě stane? Mohou nastat pouze dvě možnosti:</p>

<ul>
<li>Carry Flag není nastaven &ndash; v&nbsp;registru bude stále uložen ASCII kód znaku "0".</li>
<li>Carry Flag je nastaven &ndash; v&nbsp;registru bude ASCII kód znaku "1" (v&nbsp;ASCII leží "1" ihned za "0").</li>
</ul>

<p>Celý algoritmus určený pro test hodnoty vybraného bitu pracovního registru s&nbsp;jeho následným výpisem může vypadat následovně:</p>

<pre>
        mov ebx, 32_bitová_konstanta
        mov al, '0'                    # ASCII kód znaku, který se má "vepsat" do šablony
        bt  ebx, index_bitu            # pokud je testovaný bit nastavený na jedničku - nastaví se i Carry Flag
        adc al, 0                      # přičtení Carry Flagu ke znaku "0"
        mov [bitValueTemplate], al     # zápis do šablony
        writeMessage bitValueMessage, bitValueMessageLen  # vytištění zprávy
</pre>

<p>Použitá šablona:</p>

<pre>
bitValueMessage:
        .string "Bit value: "              # prvni cast zpravy
bitValueTemplate:                          # druha cast zpravy ma vlastni navesti
        .string "?\n"                      # otaznik bude prepsan
bitValueMessageLen = $ - bitValueMessage   # delka zpravy
</pre>

<p>Následuje výpis celého zdrojového kódu dnešního prvního demonstračního příkladu:</p>

<pre>
# asmsyntax=as

# Program pro otestovani instrukce BT
# - pro zapis je pouzita "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix



# Nacteni definice makra pro ukonceni aplikace
.include "exit.s"

# Nacteni maker pro (opakovany) tisk zpravy i prislusne subrutiny
.include "writeMessage.s"

# Nacteni makra pro vytisteni hexadecimalni 32bitove hodnoty
# spolecne s makrem je nactena i prislusna subrutina
.include "printHexNumber.s"



.macro testAndPrintBitValue word,bitIndex
        mov ebx, \word
        mov al, '0'
        bt  ebx, \bitIndex
        adc al, 0
        mov [bitValueTemplate], al
        writeMessage bitValueMessage, bitValueMessageLen
.endm

#-----------------------------------------------------------------------------
.section .data
bitValueMessage:
        .string "Bit value: "              # prvni cast zpravy
bitValueTemplate:                          # druha cast zpravy ma vlastni navesti
        .string "?\n"                      # otaznik bude prepsan
bitValueMessageLen = $ - bitValueMessage   # delka zpravy



#-----------------------------------------------------------------------------
.section .bss



#-----------------------------------------------------------------------------
.section .text
        .global _start               # tento symbol ma byt dostupny i linkeru

_start:
        printHexNumber 0x00000001
        testAndPrintBitValue 0x00000001, 0
        testAndPrintBitValue 0x00000001, 1
        testAndPrintBitValue 0x00000001, 31
        println

        printHexNumber 0x80000000
        testAndPrintBitValue 0x80000000, 0
        testAndPrintBitValue 0x80000000, 1
        testAndPrintBitValue 0x80000000, 31
        println

        printHexNumber 0xffffffff
        testAndPrintBitValue 0xffffffff, 0
        testAndPrintBitValue 0xffffffff, 1
        testAndPrintBitValue 0xffffffff, 31
        println

        exit                         # ukonceni aplikace
</pre>

<p>Podívejme se na vypsané zprávy a tím pádem i výsledky testu bitů:</p>

<pre>
Hex value: 0x00000001
Bit value: 1              ; bit s nejnižší váhou
Bit value: 0              ; bit s indexem 1
Bit value: 0              ; bit s nejvyšší váhou

Hex value: 0x80000000
Bit value: 0              ; bit s nejnižší váhou
Bit value: 0              ; bit s indexem 1
Bit value: 1              ; bit s nejvyšší váhou

Hex value: 0xFFFFFFFF
Bit value: 1              ; bit s nejnižší váhou
Bit value: 1              ; bit s indexem 1
Bit value: 1              ; bit s nejvyšší váhou
</pre>

<p>Vidíme, že instrukce <strong>BT</strong> skutečně pracuje podle předpokladů.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Instrukce BTS, BTR a BTC: test hodnoty vybraného bitu s&nbsp;jeho nastavením či negací</h2>

<p>K&nbsp;instrukci <strong>BT</strong>, kterou jsme si popsali v&nbsp;předchozím textu, existují ještě tři další varianty zapisované zkratkami <strong>BTS</strong>, <strong>BTC</strong> a <strong>BTR</strong>. Tyto instrukce provádí dvě operace. Nejdříve provedou test zvoleného bitu s&nbsp;uložením výsledku do příznakového bitu <i>Carry Flag</i> (<strong>CF</strong>), tj.&nbsp;stejnou činnost jako instrukce <strong>BT</strong>. Druhá operace spočívá ve změně testovaného bitu na základě zvolené instrukce; viz též následující tabulku:</p>

<table>
<tr><th>#</th><th>Zkratka instrukce</th><th>Význam zkratky</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>BTC</td><td>Bit Test (and) Clear</td><td>testovaný bit je vynulován</td></tr>
<tr><td>2</td><td>BTS</td><td>Bit Test (and) Set</td><td>testovaný bit je nastaven na jedničku</td></tr>
<tr><td>3</td><td>BTR</td><td>Bit Test (and) Reverse</td><td>testovaný bit je znegován</td></tr>
</table>

<p>Poznámka<sup>1</sup>: povšimněte si, že společně s&nbsp;již popsanou instrukcí <strong>BT</strong> jsou pokryty všechny základní operace, které lze s&nbsp;vybraným bitem provést: ponechat jeho původní hodnotu, nastavit bit na nulu, nastavit bit na jedničku či jeho hodnotu znegovat.</p>

<p>Poznámka<sup>2</sup>: nejedná se o atomické operace, což znamená, že přímé použití těchto instrukcí k&nbsp;implementaci zámků či semaforů nemusí být u systému s&nbsp;větším množstvím procesorů korektní. Namísto toho lze použít specializované instrukce, například <strong>CMPXCHG</strong> atd.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Druhý demonstrační příklad: změna vybraných bitů bez použití masky</h2>

<p>V&nbsp;dnešním druhém demonstračním příkladu je ukázáno použití instrukce <strong>BTC</strong>. Tato instrukce je volána v&nbsp;makru nazvaném <strong>testAndPrintBitValue</strong>, které provádí následující operace:</p>

<ol>
<li>Nejprve se vytiskne původní 32bitová hodnota předaná makru.</li>
<li>Následně je otestován a posléze znegován bit se zvoleným indexem.</li>
<li>Původní hodnota bitu je vypsána díky použití triku s&nbsp;instrukcí <strong>ADC</strong>, o níž jsme se zmínili výše.</li>
<li>Nová 32bitová hodnota se znegovaným bitem je taktéž vypsána.</li>
<li>V&nbsp;posledním kroku je provedeno odřádkování.</li>
</ol>

<p>Celé makro vypadá následovně (instrukce <strong>PUSH</strong> a <strong>POP</strong> musíme použít pro úschovu hodnoty pracovního registru <strong>EBX</strong>):</p>

<pre>
.macro testAndPrintBitValue word,bitIndex
        mov ebx, \word
        printHexNumber ebx                 # vytisteni puvodni hodnoty
        mov al, '0'                        # ASCII kod znaku, ktery se ma vepsat do sablony
        btc  ebx, \bitIndex                # test bitu a posleze jeho negace
        push ebx                           # nechceme prijit o hodnotu predanou do makra
        adc al, 0                          # pricteni Carry Flagu ke znaku "0"
        mov [bitValueTemplate], al         # zapis do sablony
        writeMessage bitValueMessage, bitValueMessageLen  # vypis celeho retezce na standardni vystup
        pop ebx                            # obnoveni hodnoty ulozene na zasobnik instrukci push ebx
        printHexNumber ebx                 # vytisteni nove hodnoty (po negaci vybraneho bitu)
        println
.endm
</pre>

<p>Podívejme se nyní na výpis celého demonstračního příkladu:</p>

<pre>
# asmsyntax=as

# Program pro otestovani instrukce BTC
# - pro zapis je pouzita "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix



# Nacteni definice makra pro ukonceni aplikace
.include "exit.s"

# Nacteni maker pro (opakovany) tisk zpravy i prislusne subrutiny
.include "writeMessage.s"

# Nacteni makra pro vytisteni hexadecimalni 32bitove hodnoty
# spolecne s makrem je nactena i prislusna subrutina
.include "printHexNumber.s"



.macro testAndPrintBitValue word,bitIndex
        mov ebx, \word
        printHexNumber ebx
        mov al, '0'
        btc  ebx, \bitIndex
        push ebx
        adc al, 0
        mov [bitValueTemplate], al
        writeMessage bitValueMessage, bitValueMessageLen
        pop ebx
        printHexNumber ebx
        println
.endm

#-----------------------------------------------------------------------------
.section .data
bitValueMessage:
        .string "Bit value: "              # prvni cast zpravy
bitValueTemplate:                          # druha cast zpravy ma vlastni navesti
        .string "?\n"                      # otaznik bude prepsan
bitValueMessageLen = $ - bitValueMessage   # delka zpravy



#-----------------------------------------------------------------------------
.section .bss



#-----------------------------------------------------------------------------
.section .text
        .global _start               # tento symbol ma byt dostupny i linkeru

_start:
        testAndPrintBitValue 0x00000001, 0
        testAndPrintBitValue 0x00000001, 1
        testAndPrintBitValue 0x00000001, 31

        testAndPrintBitValue 0x80000000, 0
        testAndPrintBitValue 0x80000000, 1
        testAndPrintBitValue 0x80000000, 31

        testAndPrintBitValue 0xffffffff, 0
        testAndPrintBitValue 0xffffffff, 1
        testAndPrintBitValue 0xffffffff, 31

        exit                         # ukonceni aplikace
</pre>

<p>Po spuštění příkladu se otestují hodnoty <strong>0x00000001</strong>, <strong>0x80000000</strong> a <strong>0xffffffff</strong>, přesněji řečeno bity s&nbsp;nejnižší váhou, bity s&nbsp;indexem 1 a bity s&nbsp;nejvyšší váhou:</p>

<pre>
Hex value: 0x00000001
Bit value: 1
Hex value: 0x00000000

Hex value: 0x00000001
Bit value: 0
Hex value: 0x00000003

Hex value: 0x00000001
Bit value: 0
Hex value: 0x80000001

Hex value: 0x80000000
Bit value: 0
Hex value: 0x80000001

Hex value: 0x80000000
Bit value: 0
Hex value: 0x80000002

Hex value: 0x80000000
Bit value: 1
Hex value: 0x00000000

Hex value: 0xFFFFFFFF
Bit value: 1
Hex value: 0xFFFFFFFE

Hex value: 0xFFFFFFFF
Bit value: 1
Hex value: 0xFFFFFFFD

Hex value: 0xFFFFFFFF
Bit value: 1
Hex value: 0x7FFFFFFF
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Instrukce BSF a BSR: hledání nenulového bitu v&nbsp;bitovém řetězci</h2>

<p>Vzhledem k&nbsp;tomu, že mikroprocesory s&nbsp;architekturou i386 a x86-64 patří mezi procesory typu <i>CISC (Complex Instruction Set Computer)</i>, pravděpodobně nás nepřekvapí, že v&nbsp;jejich instrukční sadě nalezneme i poměrně exotické instrukce. Mezi tyto relativně málo používané instrukce patří i dvojice <strong>BSF</strong> a <strong>BSR</strong>. Zkratky těchto instrukcí vznikly ze sousloví <i>Bit Scan Forward</i> a <i>Bit Scan Reverse</i>, co to však znamená? Instrukce <strong>BSF</strong> (<i>Bit Scan Forward</i>) postupně prochází všemi bity vybraného registru (či buňky paměti) a hledá první nenulový bit. Do cílového registru posléze zapíše index tohoto bitu, přičemž bit s&nbsp;nejnižší váhou má index roven nule a nejvyšší bit má index buď 31 (32bitový operand) či 63 (64bitový operand). Zajímavé je, že pokud jsou všechny bity nulové, není výsledek této instrukce přesně definován a můžeme získat jakoukoli hodnotu. Je tedy nutné současně provést i test na nulovost testovaného registru či buňky paměti. Instrukce <strong>BSR</strong> (<i>Bit Scan Reverse</i>) pracuje podobným způsobem, ale vyhledávání začne od nejvyššího bitu směrem k&nbsp;bitu s&nbsp;nulovým indexem.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Třetí demonstrační příklad: nalezení prvního nenulového bitu</h2>

<p>Ve třetím demonstračním příkladu využijeme <a href="https://mojefedora.cz/pouziti-assembleru-v-linuxu-aritmeticke-a-logicke-instrukce-i-bitove-posuny-v-praxi/">minule popsaná</a> makra určená pro tisk dekadické hodnoty i hexadecimální hodnoty, protože se nejdříve na standardní výstup hexadecimálně vytiskne vstupní 32bitová hodnota (uložená v&nbsp;pracovním registru <strong>EBX</strong>) a posléze se již dekadicky vytiskne index prvního nenulového bitu hledaný od bitu s&nbsp;indexem 0. Hlavní soubor s&nbsp;programem vypadá následovně:</p>

<pre>
# asmsyntax=as

# Program pro otestovani instrukce BSF
# - pro zapis je pouzita "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix



# Nacteni definice makra pro ukonceni aplikace
.include "exit.s"

# Nacteni maker pro (opakovany) tisk zpravy i prislusne subrutiny
.include "writeMessage.s"

# Nacteni makra pro vytisteni hexadecimalni 32bitove hodnoty
# spolecne s makrem je nactena i prislusna subrutina
.include "printHexNumber.s"

# Nacteni makra pro vytisteni decimalni 32bitove hodnoty
# spolecne s makrem je nactena i prislusna subrutina
.include "printDecimalNumber.s"



#-----------------------------------------------------------------------------
.section .data



#-----------------------------------------------------------------------------
.section .bss



#-----------------------------------------------------------------------------
.section .text
        .global _start               # tento symbol ma byt dostupny i linkeru

_start:
        mov ebx, 0x00000001
        printHexNumber ebx
        bsf eax, ebx
        printDecimalNumber eax
        println

        mov ebx, 0x00000002
        printHexNumber ebx
        bsf eax, ebx
        printDecimalNumber eax
        println

        mov ebx, 0x0000f000          # sada ctyr jednicek za sebou
        printHexNumber ebx
        bsf eax, ebx
        printDecimalNumber eax
        println

        mov ebx, 0x00010000
        printHexNumber ebx
        bsf eax, ebx
        printDecimalNumber eax
        println

        mov ebx, 0x80000000
        printHexNumber ebx
        bsf eax, ebx
        printDecimalNumber eax
        println

        mov ebx, 0x80000001          # jednickovy je pouze nejnizsi a nejvyssi bit
        printHexNumber ebx
        bsf eax, ebx
        printDecimalNumber eax
        println

        mov ebx, 0x00000000
        printHexNumber ebx
        bsf eax, ebx                 # nahodna hodnota
        printDecimalNumber eax
        println

        exit                         # ukonceni aplikace
</pre>

<p>Podívejme se nyní na výsledek běhu tohoto programu. Zajímavá je především poslední vypsaná hodnota 2, která je sice podle specifikace náhodná, ale na mém CPU zcela konzistentní (na to se ovšem pochopitelně nedá spolehnout):</p>

<pre>
Hex value: 0x00000001
Decimal value: 0000000000

Hex value: 0x00000002
Decimal value: 0000000001

Hex value: 0x0000F000
Decimal value: 0000000012

Hex value: 0x00010000
Decimal value: 0000000016

Hex value: 0x80000000
Decimal value: 0000000031

Hex value: 0x80000001
Decimal value: 0000000000

Hex value: 0x00000000
Decimal value: 0000000002
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Čtvrtý demonstrační příklad: nalezení posledního nenulového bitu</h2>

<p>Čtvrtý demonstrační příklad je prakticky zcela totožný s&nbsp;příkladem předchozím, ovšem namísto instrukce <strong>BSF</strong> se pro hledání prvního nenulového bitu používá instrukce <strong>BSR</strong>. V&nbsp;některých případech budou výsledky shodné (32bitová hodnota s&nbsp;jediným nenulovým bitem), v&nbsp;dalších případech se výsledky budou podle očekávání odlišovat:</p>

<pre>
# asmsyntax=as

# Program pro otestovani instrukce BSR
# - pro zapis je pouzita "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix



# Nacteni definice makra pro ukonceni aplikace
.include "exit.s"

# Nacteni maker pro (opakovany) tisk zpravy i prislusne subrutiny
.include "writeMessage.s"

# Nacteni makra pro vytisteni hexadecimalni 32bitove hodnoty
# spolecne s makrem je nactena i prislusna subrutina
.include "printHexNumber.s"

# Nacteni makra pro vytisteni decimalni 32bitove hodnoty
# spolecne s makrem je nactena i prislusna subrutina
.include "printDecimalNumber.s"



#-----------------------------------------------------------------------------
.section .data



#-----------------------------------------------------------------------------
.section .bss



#-----------------------------------------------------------------------------
.section .text
        .global _start               # tento symbol ma byt dostupny i linkeru

_start:
        mov ebx, 0x00000001
        printHexNumber ebx
        bsr eax, ebx
        printDecimalNumber eax
        println

        mov ebx, 0x00000002
        printHexNumber ebx
        bsr eax, ebx
        printDecimalNumber eax
        println

        mov ebx, 0x0000f000          # sada ctyr jednicek za sebou
        printHexNumber ebx
        bsr eax, ebx
        printDecimalNumber eax
        println

        mov ebx, 0x00010000
        printHexNumber ebx
        bsr eax, ebx
        printDecimalNumber eax
        println

        mov ebx, 0x80000000
        printHexNumber ebx
        bsr eax, ebx
        printDecimalNumber eax
        println

        mov ebx, 0x80000001          # jednickovy je pouze nejnizsi a nejvyssi bit
        printHexNumber ebx
        bsr eax, ebx
        printDecimalNumber eax
        println

        mov ebx, 0x00000000
        printHexNumber ebx
        bsr eax, ebx                 # nahodna hodnota
        printDecimalNumber eax
        println

        exit                         # ukonceni aplikace
</pre>

<p>Opět se podívejme na to, jaké hodnoty (indexy bitů) nalezne tento demonstrační příklad:</p>

<pre>
Hex value: 0x00000001
Decimal value: 0000000000

Hex value: 0x00000002
Decimal value: 0000000001

Hex value: 0x0000F000
Decimal value: 0000000015

Hex value: 0x00010000
Decimal value: 0000000016

Hex value: 0x80000000
Decimal value: 0000000031

Hex value: 0x80000001
Decimal value: 0000000031

Hex value: 0x00000000
Decimal value: 0000000002
</pre>


<p><a name="k10"></a></p>
<h2 id="k10">10. Instrukce XCHG a BSWAP: prohození bajtů ve slovech různé šířky</h2>

<p>Do čtvrté skupiny instrukcí, které si dnes alespoň ve stručnosti popíšeme, spadají instrukce, které dokážou ve zvoleném slovu prohodit obsah některých bitů. Do této skupiny patří instrukce <strong>XCHG</strong> (<i>exchange</i>) a <strong>BSWAP</strong> (<i>byte swap</i>). Instrukce <strong>XCHG</strong> je vlastně variantou instrukce <strong>MOV</strong>, protože taktéž přenáší data; zatímco však instrukce <strong>MOV</strong> provádí přenos jedním směrem zdroj&rarr;cíl, instrukce <strong>XCHG</strong> prohodí obsah zdroje a cíle. Speciální případ nastane, pokud jsou zdrojem a cílem dvě části jediného registru, například <strong>AH</strong> a <strong>AL</strong>. Instrukce <strong>XCHG AH, AL</strong> tedy vlastně prohodí nejnižších osm bitů registru <strong>AX</strong> (<strong>EAX, RAX</strong>) s&nbsp;bity s&nbsp;indexy 8 až 15. Instrukce <strong>BSWAP</strong> sice není tak univerzální, ovšem může být v&nbsp;některých případech velmi užitečná &ndash; prohazuje totiž všechny bajty ve zvoleném registru a to takovým způsobem, že převádí hodnotu z&nbsp;reprezentace <i>little endian</i> na <i>big endian</i> či zpět. Pokud instrukci <strong>BSWAP</strong> použijeme dvakrát za sebou se stejným registrem, hodnota tohoto registru se ve výsledku nezmění, protože se jednotlivé bajty opět vrátí na původní místo (to si ostatně ukážeme v&nbsp;demonstračním příkladu).</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Pátý demonstrační příklad: použití instrukce BSWAP</h2>

<p>Pátý a současně i dnešní poslední demonstrační příklad je vlastně velmi jednoduchý, protože se v&nbsp;něm použije instrukce <strong>BSWAP</strong> určená pro prohození bajtů v&nbsp;32bitových slovech s&nbsp;hodnotami 0x12345678 a 0x000000ff. Vlastní prohození a následný návrat k&nbsp;původní hodnotě 32bitového slova může vypadat následovně:</p>

<pre>
        mov eax, 0x12345678
        printHexNumber eax           # vytiskneme puvodni­ hodnotu
        bswap eax
        printHexNumber eax           # vytiskneme slovo s prohozenymi bajty
        bswap eax
        printHexNumber eax           # vytiskneme puvodni­ hodnotu
        println

        mov eax, 0x000000ff
        printHexNumber eax           # vytiskneme puvodni­ hodnotu
        bswap eax
        printHexNumber eax           # vytiskneme slovo s prohozenymi bajty
        bswap eax
        printHexNumber eax           # vytiskneme puvodni­ hodnotu
        println
</pre>

<p>Příklad by měl po svém spuštění vypsat na standardní výstup následujících osm řádků:</p>

<pre>
Hex value: 0x12345678
Hex value: 0x78563412
Hex value: 0x12345678

Hex value: 0x000000FF
Hex value: 0xFF000000
Hex value: 0x000000FF
</pre>

<p>Podívejme se nyní na úplný výpis zdrojového kódu pátého příkladu:</p>

<pre>
# asmsyntax=as

# Program pro otestovani instrukce BSWAP
# - pro zapis je pouzita "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix



# Nacteni definice makra pro ukonceni aplikace
.include "exit.s"

# Nacteni maker pro (opakovany) tisk zpravy i prislusne subrutiny
.include "writeMessage.s"

# Nacteni makra pro vytisteni hexadecimalni 32bitove hodnoty
# spolecne s makrem je nactena i prislusna subrutina
.include "printHexNumber.s"



#-----------------------------------------------------------------------------
.section .data



#-----------------------------------------------------------------------------
.section .bss



#-----------------------------------------------------------------------------
.section .text
        .global _start               # tento symbol ma byt dostupny i linkeru

_start:
        mov eax, 0x12345678
        printHexNumber eax           # vytiskneme puvodni hodnotu
        bswap eax
        printHexNumber eax           # vytiskneme slovo s prohozenymi bajty
        bswap eax
        printHexNumber eax           # vytiskneme puvodni hodnotu
        println

        mov eax, 0x000000ff
        printHexNumber eax           # vytiskneme puvodni hodnotu
        bswap eax
        printHexNumber eax           # vytiskneme slovo s prohozenymi bajty
        bswap eax
        printHexNumber eax           # vytiskneme puvodni hodnotu
        println

        exit                         # ukonceni aplikace
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Instrukce typu SETcc aneb podpora pro céčkové výrazy s&nbsp;logickými hodnotami</h2>

<p>Poslední skupina instrukcí, s&nbsp;nimiž se dnes seznámíme, je poměrně rozsáhlá. Jedná se o instrukce nazývané <strong>SETcc</strong> (znaky <strong>cc</strong> se mění podle konkrétního typu instrukce), které dokážou nastavit hodnotu vybraného pracovního registru na nulu či jedničku podle toho, zda je nebo naopak není splněna nějaká podmínka. O jakou podmínku se může jednat? U těchto instrukcí se používají ty stejné podmínky, jaké nalezneme u podmíněných skoků, tedy testy příznakových bitů a jejich kombinací. Ostatně se podívejme na následující tabulku, v&nbsp;níž jsou instrukce patřící do této skupiny vypsány:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Testovaná podmínka</th></tr>
<tr><td> 1</td><td>SETA  </td><td>CF=0 &amp; ZF=0</td></tr>
<tr><td> 2</td><td>SETAE </td><td>CF=0</td></tr>
<tr><td> 3</td><td>SETB  </td><td>CF=1</td></tr>
<tr><td> 4</td><td>SETBE </td><td>CF=1 | ZF=1</td></tr>
<tr><td> 5</td><td>SETC  </td><td>CF=1</td></tr>
<tr><td> 6</td><td>SETE  </td><td>ZF=1</td></tr>
<tr><td> 7</td><td>SETG  </td><td>ZF=0 &amp; SF=OF</td></tr>
<tr><td> 8</td><td>SETGE </td><td>SF=OF</td></tr>
<tr><td> 9</td><td>SETL  </td><td>SF&ne;OF</td></tr>
<tr><td>10</td><td>SETLE </td><td>ZF=1 | SF&ne;OF</td></tr>
<tr><td>11</td><td>SETNA </td><td>CF=1 | ZF=1</td></tr>
<tr><td>12</td><td>SETNAE</td><td>CF=1</td></tr>
<tr><td>13</td><td>SETNB </td><td>CF=0</td></tr>
<tr><td>14</td><td>SETNBE</td><td>CF=0 &amp; ZF=0</td></tr>
<tr><td>15</td><td>SETNC </td><td>CF=0</td></tr>
<tr><td>16</td><td>SETNE </td><td>ZF=0</td></tr>
<tr><td>17</td><td>SETNG </td><td>ZF=1 | SF&ne;OF</td></tr>
<tr><td>18</td><td>SETNGE</td><td>SF&ne;OF</td></tr>
<tr><td>19</td><td>SETNL </td><td>SF=OF</td></tr>
<tr><td>20</td><td>SETNLE</td><td>ZF=0 &amp; SF=OF</td></tr>
<tr><td>21</td><td>SETNO </td><td>OF=0</td></tr>
<tr><td>22</td><td>SETNP </td><td>PF=0</td></tr>
<tr><td>23</td><td>SETNS </td><td>SF=0</td></tr>
<tr><td>24</td><td>SETNZ </td><td>ZF=0</td></tr>
<tr><td>25</td><td>SETO  </td><td>OF=1</td></tr>
<tr><td>26</td><td>SETP  </td><td>PF=1</td></tr>
<tr><td>27</td><td>SETPE </td><td>PF=1</td></tr>
<tr><td>28</td><td>SETPO </td><td>PF=0</td></tr>
<tr><td>29</td><td>SETS  </td><td>SF=1</td></tr>
<tr><td>30</td><td>SETZ  </td><td>ZF=1</td></tr>
</table>



<p><a name="k13"></a></p>
<h2 id="k13">13. Pomocná makra a procedury použité v&nbsp;demonstračních příkladech</h2>

<p>Demonstrační příklady popsané v&nbsp;předchozích kapitolách používají makra a subrutiny (procedury), s&nbsp;nimiž jsme se již seznámili minule. Tyto makra a subrutiny jsou uloženy v&nbsp;samostatných souborech přidávaných do hlavního programu s&nbsp;využitím direktivy <strong>.include</strong>.</p>

<h3>exit.s</h3>

<pre>
# asmsyntax=as

# Makro pro ukonceni procesu v Linuxu.
# - pro zapis je pouzita "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

sys_exit   = 1                       # cislo syscallu pro ukonceni procesu

# Deklarace makra pro ukonceni aplikace
.macro exit
        mov   eax, sys_exit          # cislo sycallu pro funkci "exit"
        mov   ebx, 0                 # exit code = 0
        int   0x80                   # volani Linuxoveho kernelu
.endm
</pre>

<h3>writeMessage.s</h3>

<pre>
# asmsyntax=as

# Makro pro tisk zpravy na standardni vystup.
# - pro zapis je pouzita "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

# Linux kernel system call table
sys_write  = 4
std_output = 1



# Deklarace makra pro vytisteni zpravy na standardni vystup
.macro writeMessage message,messageLength
        mov   ecx, offset \message   # adresa retezce, ktery se ma vytisknout
        mov   edx, \messageLength    # pocet znaku, ktere se maji vytisknout
        call  write_message          # vytisknout zpravu "Zero flag not set"
.endm



# Podprogram pro vytisteni zpravy na standardni vystup
# Ocekava se, ze v ecx bude adresa zpravy a v edx jeji delka
write_message:
        mov   eax, sys_write         # cislo syscallu pro funkci "write"
        mov   ebx, std_output        # standardni vystup
        int   0x80
        ret



# Deklarace makra pro vytisteni znaku konce radku (provede se tedy odradkovani)
.macro println
        writeMessage printlnMessage,printlnLength
.endm



#-----------------------------------------------------------------------------
.section .data
# Miniretezec pouzivany makrem println
printlnMessage:
        .string "\n"
printlnLength = $ - printlnMessage
</pre>

<h3>printHexNumber.s</h3>

<pre>
# asmsyntax=as

# Makro pro pripravu a tisk hexadecimalni hodnoty na standardni vystup.
# - pro zapis je pouzita "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix



# Makro pro vypis 32bitove hexadecimalni hodnoty na standardni vystup
# Jedinym parametrem makra je hodnota (konstanta)
.macro printHexNumber value
        pusha                              # uschovat vsechny registry na zasobnik
        mov  edx, \value                   # hodnotu pro tisk ulozit do registru EDX
        mov  ebx, offset hexValueTemplate  # adresu pro retezec ulozit do registru EBX
        call hex2string                    # zavolani prislusne subrutiny pro prevod na string
        writeMessage hexValueMessage, hexValueMessageLen # retezec je naplnen, tak ho muzeme vytisknout
        popa                               # obnovit obsah vsech registru
.endm



#-----------------------------------------------------------------------------
.section .data
hexValueMessage:
        .string "Hex value: 0x"             # prvni cast zpravy
hexValueTemplate:                           # druha cast zpravy ma vlastni navesti
        .string "????????\n"                # otazniky budou prepsany
hexValueMessageLen = $ - hexValueMessage    # delka zpravy



#-----------------------------------------------------------------------------
.section .text

# Subrutina urcena pro prevod 32bitove hexadecimalni hodnoty na retezec
# Vstup: EDX - hodnota, ktera se ma prevest na retezec
#        EBX - adresa jiz drive alokovaneho retezce (resp. osmice bajtu)
hex2string:
                  mov cl,  8                # pocet opakovani smycky

print_one_digit:  rol edx, 4                # rotace doleva znamena, ze se do spodnich 4 bitu nasune dalsi cifra
                  mov al, dl                # nechceme porusit obsah vstupni hodnoty v EDX, proto pouzijeme AL
                  and al, 0x0f              # maskovani, potrebujeme pracovat jen s jednou cifrou
                  cmp al, 10                # je cifra vetsi nebo rovna 10?
                  jl  store_digit           # neni, pouze prevest 0..9 na ASCII hodnotu '0'..'9'

alpha_digit:      add al, 'A'-10-'0'        # prevod hodnoty 10..15 na znaky 'A'..'F'

store_digit:      add al, '0'
                  mov byte ptr [ebx], al    # ulozeni cifry do retezce
                  inc ebx                   # dalsi ulozeni v retezci o znak dale
                  dec cl                    # snizeni pocitadla smycky
                  jnz print_one_digit       # a opakovani smycky, dokud se nedosahlo nuly

                  ret                       # navrat ze subrutiny
</pre>

<h3>printDecimalNumber.s</h3>

<pre>
# asmsyntax=as

# Makro pro pripravu a tisk desitkove hodnoty na standardni vystup.
# - pro zapis je pouzita "Intel" syntaxe.
#
# Autor: Pavel Tisnovsky

.intel_syntax noprefix



# Makro pro vypis 32bitove desitkove hodnoty na standardni vystup
# Jedinym parametrem makra je hodnota (konstanta)
.macro printDecimalNumber value
        pusha                                  # uschovat vsechny registry na zasobnik
        mov  eax, \value                       # hodnotu pro tisk ulozit do registru EAX
        mov  ebx, offset decimalValueTemplate  # adresu pro retezec ulozit do registru EBX
        call decimal2string                    # zavolani prislusne subrutiny pro prevod na string
        writeMessage decimalValueMessage, decimalValueMessageLen # retezec je naplnen, tak ho muzeme vytisknout
        popa                                   # obnovit obsah vsech registru
.endm



#-----------------------------------------------------------------------------
.section .data
decimalValueMessage:
        .string "Decimal value: "              # prvni cast zpravy
decimalValueTemplate:                          # druha cast zpravy ma vlastni navesti
        .string "??????????\n"                 # otazniky budou prepsany (musi jich byt presne deset!)
decimalValueMessageLen = $ - decimalValueMessage    # delka zpravy



#-----------------------------------------------------------------------------
.section .text

# Subrutina urcena pro prevod 32bitove desitkove hodnoty na retezec
# Vstup: EDX - hodnota, ktera se ma prevest na retezec
#        EBX - adresa jiz drive alokovaneho retezce (resp. minimalne deseti bajtu)
decimal2string:
                  mov ecx, 10              # celkovy pocet zapisovanych cifer/znaku
                  mov edi, ecx             # instrukce DIV vyzaduje deleni registrem, pouzijme tedy EDI

next_digit:
                  xor edx, edx             # delenec je dvojice EDX:EAX, vynulujeme tedy horni registr EDX
                  div edi                  # deleni hodnoty ulozene v EDX:EAX deseti (delitelem je EDI)
                                           # vysledek se ulozi do EAX, zbytek do EDX
                                           # pri deleni deseti je jistota, ze zbytek je jen cislo 0..9

                  add dl, '0'              # prevod hodnoty 0..9 na znak '0'-'9'

                  mov byte ptr [ebx+ecx-1], dl # zapis retezce (od posledniho znaku)

                  dec ecx                  # presun na predchozi znak v retezci a soucasne snizeni hodnoty pocitadla
                  jnz next_digit           # uz jsme dosli k poslednimu cislu?

                  ret                      # navrat ze subrutiny
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všech pět dnes popisovaných demonstračních příkladů bylo, podobně jako ve všech předchozích částech tohoto seriálu, společně s&nbsp;podpůrnými skripty určenými pro jejich překlad či naopak pro disassembling, uloženo do GIT repositáře dostupného na adrese <a href="https://github.com/tisnik/presentations/">https://github.com/tisnik/presentations/</a>. Všechny příklady jsou určeny pro GNU Assembler a používají Intel syntaxi, která je pro mnoho programátorů čitelnější, než původní AT&amp;T syntaxe. Následují tabulky obsahující odkazy na zdrojové kódy příkladů i na již zmíněné podpůrné skripty:</p>

<h3>První demonstrační příklad: test hodnoty vybraného bitu</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>main.s</td><td>hlavní program pro GNU Assembler</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/35_bit_test/main.s">https://github.com/tisnik/presentations/blob/master/assembler/35_bit_test/main.s</a></td></tr>
<tr><td>2</td><td>exit.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/35_bit_test/exit.s">https://github.com/tisnik/presentations/blob/master/assembler/35_bit_test/exit.s</a></td></tr>
<tr><td>3</td><td>writeMessage.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/35_bit_test/writeMessage.s">https://github.com/tisnik/presentations/blob/master/assembler/35_bit_test/writeMessage.s</a></td></tr>
<tr><td>4</td><td>printHexNumber.s</td><td>implementace makra a subrutiny pro převod hex2string</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/35_bit_test/printHexNumber.s">https://github.com/tisnik/presentations/blob/master/assembler/35_bit_test/printHexNumber.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>assemble</td><td>skript pro překlad na procesorech i386</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/35_bit_test/assemble">https://github.com/tisnik/presentations/blob/master/assembler/35_bit_test/assemble</a></td></tr>
<tr><td>6</td><td>disassemble</td><td>skript pro disassembling</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/35_bit_test/disassemble">https://github.com/tisnik/presentations/blob/master/assembler/35_bit_test/disassemble</a></td></tr>
</table>

<h3>Druhý demonstrační příklad: změna vybraných bitů bez použití masky</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>main.s</td><td>hlavní program pro GNU Assembler</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/36_btc/main.s">https://github.com/tisnik/presentations/blob/master/assembler/36_btc/main.s</a></td></tr>
<tr><td>2</td><td>exit.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/36_btc/exit.s">https://github.com/tisnik/presentations/blob/master/assembler/36_btc/exit.s</a></td></tr>
<tr><td>3</td><td>writeMessage.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/36_btc/writeMessage.s">https://github.com/tisnik/presentations/blob/master/assembler/36_btc/writeMessage.s</a></td></tr>
<tr><td>4</td><td>printHexNumber.s</td><td>implementace makra a subrutiny pro převod hex2string</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/36_btc/printHexNumber.s">https://github.com/tisnik/presentations/blob/master/assembler/36_btc/printHexNumber.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>assemble</td><td>skript pro překlad na procesorech i386</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/36_btc/assemble">https://github.com/tisnik/presentations/blob/master/assembler/36_btc/assemble</a></td></tr>
<tr><td>6</td><td>disassemble</td><td>skript pro disassembling</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/36_btc/disassemble">https://github.com/tisnik/presentations/blob/master/assembler/36_btc/disassemble</a></td></tr>
</table>

<h3>Třetí demonstrační příklad: nalezení prvního nenulového bitu</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>main.s</td><td>hlavní program pro GNU Assembler</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/37_bsf/main.s">https://github.com/tisnik/presentations/blob/master/assembler/37_bsf/main.s</a></td></tr>
<tr><td>2</td><td>exit.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/37_bsf/exit.s">https://github.com/tisnik/presentations/blob/master/assembler/37_bsf/exit.s</a></td></tr>
<tr><td>3</td><td>writeMessage.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/37_bsf/writeMessage.s">https://github.com/tisnik/presentations/blob/master/assembler/37_bsf/writeMessage.s</a></td></tr>
<tr><td>4</td><td>printHexNumber.s</td><td>implementace makra a subrutiny pro převod hex2string</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/37_bsf/printHexNumber.s">https://github.com/tisnik/presentations/blob/master/assembler/37_bsf/printHexNumber.s</a></td></tr>
<tr><td>5</td><td>printDecimalNumber.s</td><td>implementace makra a subrutiny pro převod decimal2string</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/37_bsf/printDecimalNumber.s">https://github.com/tisnik/presentations/blob/master/assembler/37_bsf/printDecimalNumber.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>6</td><td>assemble</td><td>skript pro překlad na procesorech i386</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/37_bsf/assemble">https://github.com/tisnik/presentations/blob/master/assembler/37_bsf/assemble</a></td></tr>
<tr><td>7</td><td>disassemble</td><td>skript pro disassembling</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/37_bsf/disassemble">https://github.com/tisnik/presentations/blob/master/assembler/37_bsf/disassemble</a></td></tr>
</table>

<h3>Čtvrtý demonstrační příklad: nalezení posledního nenulového bitu</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>main.s</td><td>hlavní program pro GNU Assembler</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/38_bsr/main.s">https://github.com/tisnik/presentations/blob/master/assembler/38_bsr/main.s</a></td></tr>
<tr><td>2</td><td>exit.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/38_bsr/exit.s">https://github.com/tisnik/presentations/blob/master/assembler/38_bsr/exit.s</a></td></tr>
<tr><td>3</td><td>writeMessage.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/38_bsr/writeMessage.s">https://github.com/tisnik/presentations/blob/master/assembler/38_bsr/writeMessage.s</a></td></tr>
<tr><td>4</td><td>printHexNumber.s</td><td>implementace makra a subrutiny pro převod hex2string</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/38_bsr/printHexNumber.s">https://github.com/tisnik/presentations/blob/master/assembler/38_bsr/printHexNumber.s</a></td></tr>
<tr><td>5</td><td>printDecimalNumber.s</td><td>implementace makra a subrutiny pro převod decimal2string</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/38_bsr/printDecimalNumber.s">https://github.com/tisnik/presentations/blob/master/assembler/38_bsr/printDecimalNumber.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>6</td><td>assemble</td><td>skript pro překlad na procesorech i386</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/38_bsr/assemble">https://github.com/tisnik/presentations/blob/master/assembler/38_bsr/assemble</a></td></tr>
<tr><td>7</td><td>disassemble</td><td>skript pro disassembling</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/38_bsr/disassemble">https://github.com/tisnik/presentations/blob/master/assembler/38_bsr/disassemble</a></td></tr>
</table>

<h3>Pátý demonstrační příklad: použití instrukce BSWAP</h3>

<table>
<tr><th>#</th><th>Soubor</th><th>Popis</th><th>Odkaz do repositáře</th></tr>
<tr><td>1</td><td>main.s</td><td>hlavní program pro GNU Assembler</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/39_bswap/main.s">https://github.com/tisnik/presentations/blob/master/assembler/39_bswap/main.s</a></td></tr>
<tr><td>2</td><td>exit.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/39_bswap/exit.s">https://github.com/tisnik/presentations/blob/master/assembler/39_bswap/exit.s</a></td></tr>
<tr><td>3</td><td>writeMessage.s</td><td>program pro GNU Assembler, který se vkládá do prvního souboru</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/39_bswap/writeMessage.s">https://github.com/tisnik/presentations/blob/master/assembler/39_bswap/writeMessage.s</a></td></tr>
<tr><td>4</td><td>printHexNumber.s</td><td>implementace makra a subrutiny pro převod hex2string</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/39_bswap/printHexNumber.s">https://github.com/tisnik/presentations/blob/master/assembler/39_bswap/printHexNumber.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>assemble</td><td>skript pro překlad na procesorech i386</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/39_bswap/assemble">https://github.com/tisnik/presentations/blob/master/assembler/39_bswap/assemble</a></td></tr>
<tr><td>6</td><td>disassemble</td><td>skript pro disassembling</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/39_bswap/disassemble">https://github.com/tisnik/presentations/blob/master/assembler/39_bswap/disassemble</a></td></tr>
</table>



<p><a name="k15"></a></p>
<h2 id="k15">15. Odkazy na Internetu</h2>

<ol>

<li>x86 Instruction Set Reference: BT<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_22.html">http://x86.renejeschke.de/html/file_module_x86_id_22.html</a>
</li>

<li>x86 Instruction Set Reference: BTC<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_23.html">http://x86.renejeschke.de/html/file_module_x86_id_23.html</a>
</li>

<li>x86 Instruction Set Reference: BTR<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_24.html">http://x86.renejeschke.de/html/file_module_x86_id_24.html</a>
</li>

<li>x86 Instruction Set Reference: BTS<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_25.html">http://x86.renejeschke.de/html/file_module_x86_id_25.html</a>
</li>

<li>x86 Instruction Set Reference: BSF<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_19.html">http://x86.renejeschke.de/html/file_module_x86_id_19.html</a>
</li>

<li>x86 Instruction Set Reference: BSR<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_20.html">http://x86.renejeschke.de/html/file_module_x86_id_20.html</a>
</li>

<li>x86 Instruction Set Reference: BSWAP<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_21.html">http://x86.renejeschke.de/html/file_module_x86_id_21.html</a>
</li>

<li>x86 Instruction Set Reference: XCHG<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_328.html">http://x86.renejeschke.de/html/file_module_x86_id_328.html</a>
</li>

<li>x86 Instruction Set Reference: SETcc<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_288.html">http://x86.renejeschke.de/html/file_module_x86_id_288.html</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>The GNU Assembler Tutorial<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html">http://tigcc.ticalc.org/doc/gnuasm.html</a>
</li>

<li>The GNU Assembler - macros<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html#SEC109">http://tigcc.ticalc.org/doc/gnuasm.html#SEC109</a>
</li>

<li>ARM subroutines &amp; program stack<br />
<a href="http://www.toves.org/books/armsub/">http://www.toves.org/books/armsub/</a>
</li>

<li>Generating Mixed Source and Assembly List using GCC<br />
<a href="http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/">http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/</a>
</li>

<li>Calling subroutines<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm</a>
</li>

<li>ARM Assembly Language Programming<br />
<a href="http://peter-cockerell.net/aalp/html/frames.html">http://peter-cockerell.net/aalp/html/frames.html</a>
</li>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Intel x86 JUMP quick reference<br />
<a href="http://unixwiz.net/techtips/x86-jumps.html">http://unixwiz.net/techtips/x86-jumps.html</a>
</li>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Assembler pod Linuxem<br />
<a href="http://phoenix.inf.upol.cz/linux/prog/asm.html">http://phoenix.inf.upol.cz/linux/prog/asm.html</a>
</li>

<li>AT&amp;T Syntax versus Intel Syntax<br />
<a href="https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html">https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html</a>
</li>

<li>Linux Assembly website<br />
<a href="http://asm.sourceforge.net/">http://asm.sourceforge.net/</a>
</li>

<li>Using Assembly Language in Linux<br />
<a href="http://asm.sourceforge.net/articles/linasm.html">http://asm.sourceforge.net/articles/linasm.html</a>
</li>

<li>vasm<br />
<a href="http://sun.hasenbraten.de/vasm/">http://sun.hasenbraten.de/vasm/</a>
</li>

<li>vasm &ndash; dokumentace<br />
<a href="http://sun.hasenbraten.de/vasm/release/vasm.html">http://sun.hasenbraten.de/vasm/release/vasm.html</a>
</li>

<li>The Yasm Modular Assembler Project<br />
<a href="http://yasm.tortall.net/">http://yasm.tortall.net/</a>
</li>

<li>680x0:AsmOne<br />
<a href="http://www.amigacoding.com/index.php/680x0:AsmOne">http://www.amigacoding.com/index.php/680x0:AsmOne</a>
</li>

<li>ASM-One Macro Assembler<br />
<a href="http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler">http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler</a>
</li>

<li>ASM-One pages<br />
<a href="http://www.theflamearrows.info/documents/asmone.html">http://www.theflamearrows.info/documents/asmone.html</a>
</li>

<li>Základní informace o ASM-One<br />
<a href="http://www.theflamearrows.info/documents/asminfo.html">http://www.theflamearrows.info/documents/asminfo.html</a>
</li>

<li>Linux Syscall Reference<br />
<a href="http://syscalls.kernelgrok.com/">http://syscalls.kernelgrok.com/</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>IBM System 360/370 Compiler and Historical Documentation<br />
<a href="http://www.edelweb.fr/Simula/">http://www.edelweb.fr/Simula/</a>
</li>

<li>IBM 700/7000 series<br />
<a href="http://en.wikipedia.org/wiki/IBM_700/7000_series">http://en.wikipedia.org/wiki/IBM_700/7000_series</a>
</li>

<li>IBM System/360<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/360">http://en.wikipedia.org/wiki/IBM_System/360</a>
</li>

<li>IBM System/370<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/370">http://en.wikipedia.org/wiki/IBM_System/370</a>
</li>

<li>Mainframe family tree and chronology<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html</a>
</li>

<li>704 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html</a>
</li>

<li>705 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html</a>
</li>

<li>The IBM 704<br />
<a href="http://www.columbia.edu/acis/history/704.html">http://www.columbia.edu/acis/history/704.html</a>
</li>

<li>IBM Mainframe album<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html</a>
</li>

<li>Osmibitové muzeum<br />
<a href="http://osmi.tarbik.com/">http://osmi.tarbik.com/</a>
</li>

<li>Tesla PMI-80<br />
<a href="http://osmi.tarbik.com/cssr/pmi80.html">http://osmi.tarbik.com/cssr/pmi80.html</a>
</li>

<li>PMI-80<br />
<a href="http://en.wikipedia.org/wiki/PMI-80">http://en.wikipedia.org/wiki/PMI-80</a>
</li>

<li>PMI-80<br />
<a href="http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016">http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016</a>
</li>

<li>The 6502 overflow flag explained mathematically <br />
<a href="http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html">http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html</a>
</li>

<li>X86 Opcode and Instruction Reference<br />
<a href="http://ref.x86asm.net/coder32.html">http://ref.x86asm.net/coder32.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

