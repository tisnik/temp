<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Kombinace assembleru a programovacího jazyka C na procesorech ARM (dokončení)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Kombinace assembleru a programovacího jazyka C na procesorech ARM (dokončení)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Téma kombinace assembleru a programovacího jazyka C na mikroprocesorech s&nbsp;32bitovou architekturou ARM dnes dokončíme. Ukážeme si způsob přístupu na haldu (heap), volání služeb jádra, použití programových smyček v&nbsp;assembleru a nezapomeneme ani na poměrně rozsáhlou problematiku práce s&nbsp;hodnotami s&nbsp;plovoucí řádovou čárkou s&nbsp;využitím technologie VFP (Vector Floating Point).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Kombinace assembleru a programovacího jazyka C na procesorech ARM (dokončení)</a></p>
<p><a href="#k02">2. Přístup z&nbsp;assembleru na haldu</a></p>
<p><a href="#k03">3. Volání služeb jádra z&nbsp;assembleru</a></p>
<p><a href="#k04">4. Použití počítaných smyček v&nbsp;assemblerovském bloku</a></p>
<p><a href="#k05">5. Vylepšení zápisu u assemblerovských bloků s&nbsp;návěštími</a></p>
<p><a href="#k06">6. Základ práce s&nbsp;hodnotami s&nbsp;plovoucí řádovou čárkou</a></p>
<p><a href="#k07">7. Přenos druhého FP operandu do operandu výstupního</a></p>
<p><a href="#k08">8. Použití symbolických jmen vstupních a výstupních operandů</a></p>
<p><a href="#k09">9. Využití pracovních registrů VFP (Vector Floating Point)</a></p>
<p><a href="#k10">10. Základní instrukce VFP</a></p>
<p><a href="#k11">11. Součet dvou FP hodnot instrukcí <strong>vadd.f32</strong></a></p>
<p><a href="#k12">12. Podíl dvou FP hodnot instrukcí <strong>vdiv.f32</strong></a></p>
<p><a href="#k13">13. Makefile určený pro překlad dnešních demonstračních příkladů</a></p>
<p><a href="#k14">14. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k15">15. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Kombinace assembleru a programovacího jazyka C na procesorech ARM (dokončení)</h2>

<p>Téma, jemuž jsme se věnovali v&nbsp;předchozích dvou částech seriálu o assembleru v&nbsp;Linuxu, dnes dokončíme. Ukážeme si totiž některé nepatrně složitější příklady bloků napsaných v&nbsp;assembleru 32bitových mikroprocesorů s&nbsp;architekturou ARM. Nejdříve si řekneme, jakým způsobem je možné přistupovat k&nbsp;datům umístěným na haldě (<i>heapu</i>), způsob zápisu programových smyček ve vkládaném assembleru a na konec se zaměříme na stručný popis technologie <i>VFP (Vector Floating Point)</i> a její využití při provádění základních aritmetických operací s&nbsp;hodnotami s&nbsp;plovoucí řádovou čárkou.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Přístup z&nbsp;assembleru na haldu</h2>

<p>Ve vkládaných assemblerovských blocích je samozřejmě možné přistupovat i k&nbsp;těm datům, které jsou umístěny na haldě. My si konkrétně ukážeme způsob změny některých znaků v&nbsp;řetězci. Při vytváření řetězce je nutné zaručit, aby byl skutečně předán přes ukazatel, takže se pro vstupní operand použije modifikátor &bdquo;m&ldquo;. Adresa prvního znaku v&nbsp;řetězci se načte do pracovního registru instrukcí <strong>ldr</strong> (<i>load register</i>), o zápis jednoho znaku se postará instrukce <strong>strb</strong> (<i>store byte</i>). Povšimněte si, že je možné k&nbsp;počátečnímu znaku řetězce (k&nbsp;jeho adrese) přičíst offset (4 pro pátý a 7 pro osmý znak):</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

char *message = NULL;

int main()
{
    message = (char*) malloc(20);
    strcpy(message, "Hello world!");

    puts(message);
    __asm__ __volatile__(
        "ldr   r1, %0         @ adresa retezce  \n\t"
        "mov   r2, #'*'       @ zapisovany znak \n\t"
        "strb  r2, [r1,#4]    @ prepis jednoho 'o' \n\t"
        "strb  r2, [r1,#7]    @ prepis druheho 'o' \n\t"
        :                         /* zadne vystupni operandy */
        : "m" (message)           /* vstupni operandy */
        : "r1", "r2"              /* registry pouzivane uvnitr kodu */
    );

    puts(message);

    return 0;
}
</pre>

<p>Po překladu a spuštění příkladu by se na standardním výstupu měl objevit původní řetězec a řetězec upravený &ndash; s&nbsp;přepsanými dvěma znaky:</p>

<pre>
Hello world!
Hell* w*rld!
</pre>

<p>Podívejme se ještě na to, jak se tento příklad přeložil do assembleru, tj.&nbsp;jakým způsobem se naplnil vstupní operand:</p>

<pre>
        ldr     r3, .L2
#APP
@ 13 "asm_in_c_7.c" 1
        ldr   r1, [r3, #0]         @ adresa retezce  
        mov   r2, #'*'       @ zapisovany znak 
        strb  r2, [r1,#4]    @ prepis jednoho 'o' 
        strb  r2, [r1,#7]    @ prepis druheho 'o' 
        
@ 0 "" 2
        ldr     r3, .L2
        ldr     r3, [r3, #0]
        mov     r0, r3
        bl      puts
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Volání služeb jádra z&nbsp;assembleru</h2>

<p>Ve druhém demonstračním příkladu zavoláme funkci jádra sloužící pro výpis sekvence bajtů do zvoleného zařízení či do souboru. Pokud použijeme číslo souboru #1, bude se jednat o standardní výstup, což již známe z&nbsp;&bdquo;čistě assemblerovských&ldquo; příkladů. Data, která se budou na standardní výstup zapisovat, jsou přečtena z&nbsp;běžného céčkovského řetězce, který je v&nbsp;tomto případě umístěn v&nbsp;sekci konstant. Povšimněte si, že nula ukončující céčkovský řetězec není žádným způsobem jádrem zpracována; naopak musíme explicitně předat délku řetězce (počet zapisovaných bajtů):</p>

<pre>
#include &lt;stdio.h&gt;

const char *message = "Hello world!";

int main()
{
    __asm__ __volatile__(
        "mov   r7, #4         @ cislo syscallu pro funkci write  \n\t"
        "mov   r0, #1         @ standardni vystup  \n\t"
        "ldr   r1, %0         @ adresa retezce, ktery se ma vytisknout  \n\t"
        "mov   r2, #12        @ pocet znaku, ktere se maji vytisknout  \n\t"
        "svc   0              @ volani Linuxoveho kernelu  \n\t"
        :                        /* zadne vystupni operandy */
        : "m" (message)          /* zadne vstupni operandy */
        : "r0", "r1", "r2", "r7" /* registry pouzivane uvnitr kodu */
    );

    return 0;
}
</pre>

<p>Překlad provedený GCC vyprodukuje následující sekvenci instrukcí:</p>

<pre>
        ldr     r3, .L2
#APP
@ 7 "asm_in_c_8.c" 1
        mov   r7, #4         @ cislo syscallu pro funkci write  
        mov   r0, #1         @ standardni vystup  
        ldr   r1, [r3, #0]   @ adresa retezce, ktery se ma vytisknout  
        mov   r2, #12        @ pocet znaku, ktere se maji vytisknout  
        svc   0              @ volani Linuxoveho kernelu  
</pre>


<p><a name="k04"></a></p>
<h2 id="k04">4. Použití počítaných smyček v&nbsp;assemblerovském bloku</h2>

<p>Ve třetím příkladu si vytvoříme jednoduchou programovou smyčku, která postupně změní několik znaků v&nbsp;řetězci umístěného na haldu. Všechny instrukce již známe, povšimněte si však toho, že návěští smyčky (label <strong>loop</strong>) musí být zapsáno na začátku řádku, takže se před něj nezapisuje znak tabulátoru. Výsledek není příliš čitelný, to však opravíme v&nbsp;další kapitole:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

char *message = NULL;

int main()
{
    message = (char*) malloc(20);
    strcpy(message, "Hello world!");

    puts(message);

    __asm__ __volatile__(
        "ldr   r1, %0         @ adresa retezce  \n\t"
        "mov   r2, #'*'       @ zapisovany znak \n\t"
        "mov   r3, #2         @ pocitadlo smycky \n\t"
        "\n"
        "loop:\n\t"
        "strb  r2, [r1,r3]    @ prepis jednoho znaku \n\t"
        "add   r3, r3, #2     @ zvyseni hodnoty pocitadla \n\t"
        "cmp   r3, #12        @ porovnani s ocekavanou koncovou hodnotou \n\t"
        "bne  loop            @ podmineny skok na zacatek smycky \n\t"
        :                         /* zadne vystupni operandy */
        : "m" (message)           /* vstupni operandy */
        : "r1", "r2", "r3"        /* registry pouzivane uvnitr kodu */
    );

    puts(message);

    return 0;
}
</pre>

<p>Po překladu a spuštění získáme na standardním výstupu tyto dva řádky:</p>

<pre>
Hello world!
He*l* *o*k*!
</pre>

<p>Překlad provedený GCC vyprodukuje následující sekvenci instrukcí:</p>

<pre>
#APP
@ 14 "asm_in_c_9.c" 1
        ldr   r1, [r0, #0]         @ adresa retezce  
        mov   r2, #'*'       @ zapisovany znak 
        mov   r3, #2         @ pocitadlo smycky 
        
loop:
        strb  r2, [r1,r3]    @ prepis jednoho znaku 
        add   r3, r3, #2     @ zvyseni hodnoty pocitadla 
        cmp   r3, #12        @ porovnani s ocekavanou koncovou hodnotou 
        bne  loop            @ podmineny skok na zacatek smycky 
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Vylepšení zápisu u assemblerovských bloků s&nbsp;návěštími</h2>

<p>Předchozí příklad je možné přepsat do mnohem čitelnější podoby takovým způsobem, že <i>ne</i>použijeme znaky tabulátoru na začátku řádku, ale namísto toho se spokojíme se starými dobrými mezerami. Takový vkládaný assemblerovský blok je již mnohem čitelnější &ndash; ostatně posuďte sami:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

char *message = NULL;

int main()
{
    message = (char*) malloc(20);
    strcpy(message, "Hello world!");

    puts(message);

    __asm__ __volatile__(
        "        ldr   r1, %0         @ adresa retezce   \n"
        "        mov   r2, #'*'       @ zapisovany znak  \n"
        "        mov   r3, #2         @ pocitadlo smycky \n"
        "loop:                                           \n"
        "        strb  r2, [r1,r3]    @ prepis jednoho znaku \n"
        "        add   r3, r3, #2     @ zvyseni hodnoty pocitadla \n"
        "        cmp   r3, #12        @ porovnani s ocekavanou koncovou hodnotou \n"
        "        bne  loop            @ podmineny skok na zacatek smycky \n"
        :                         /* zadne vystupni operandy */
        : "m" (message)           /* vstupni operandy */
        : "r1", "r2", "r3"        /* registry pouzivane uvnitr kodu */
    );

    puts(message);

    return 0;
}
</pre>

<p>Takto vypadá kód vygenerovaný překladačem GCC:</p>

<pre>
#APP
@ 14 "asm_in_c_10.c" 1
                ldr   r1, [r0, #0]         @ adresa retezce   
        mov   r2, #'*'       @ zapisovany znak  
        mov   r3, #2         @ pocitadlo smycky 
loop:                                           
        strb  r2, [r1,r3]    @ prepis jednoho znaku 
        add   r3, r3, #2     @ zvyseni hodnoty pocitadla 
        cmp   r3, #12        @ porovnani s ocekavanou koncovou hodnotou 
        bne  loop            @ podmineny skok na zacatek smycky 
</pre>

<p>Poslední úprava se týká prvního řádku s&nbsp;instrukcí <strong>ldr</strong>, který je posunutý doprava. Nad tento řádek umístíme jediný znak pro odřádkování:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

char *message = NULL;

int main()
{
    message = (char*) malloc(20);
    strcpy(message, "Hello world!");

    puts(message);

    __asm__ __volatile__(
        "\n"
        "        ldr   r1, %0         @ adresa retezce   \n"
        "        mov   r2, #'*'       @ zapisovany znak  \n"
        "        mov   r3, #2         @ pocitadlo smycky \n"
        "loop:                                           \n"
        "        strb  r2, [r1,r3]    @ prepis jednoho znaku \n"
        "        add   r3, r3, #2     @ zvyseni hodnoty pocitadla \n"
        "        cmp   r3, #12        @ porovnani s ocekavanou koncovou hodnotou \n"
        "        bne  loop            @ podmineny skok na zacatek smycky \n"
        :                         /* zadne vystupni operandy */
        : "m" (message)           /* vstupni operandy */
        : "r1", "r2", "r3"        /* registry pouzivane uvnitr kodu */
    );

    puts(message);

    return 0;
}

</pre>

<p>Výsledek:</p>

<pre>
#APP
@ 14 "asm_in_c_11.c" 1
        
        ldr   r1, [r0, #0]         @ adresa retezce   
        mov   r2, #'*'       @ zapisovany znak  
        mov   r3, #2         @ pocitadlo smycky 
loop:                                           
        strb  r2, [r1,r3]    @ prepis jednoho znaku 
        add   r3, r3, #2     @ zvyseni hodnoty pocitadla 
        cmp   r3, #12        @ porovnani s ocekavanou koncovou hodnotou 
        bne  loop            @ podmineny skok na zacatek smycky 
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Základ práce s&nbsp;hodnotami s&nbsp;plovoucí řádovou čárkou</h2>

<p>Ve druhé části dnešního článku o použití assembleru společně s&nbsp;jazykem C se zaměříme na popis způsobu zpracování hodnot s&nbsp;plovoucí řádovou čárkou (<i>FP = Floating Point</i>). Pokud programujeme v&nbsp;assembleru, máme při zpracování FP hodnot dvě možnosti &ndash; můžeme použít běžné celočíselné 32bitové pracovní registry se jmény <strong>r0</strong> až <strong>r15</strong>, mezi nimiž lze FP hodnoty jen přenášet a popř.&nbsp;i v&nbsp;omezené míře porovnávat, či můžeme použít skutečný matematický koprocesor, který u dnešních 32bitových čipů ARM většinou implementuje instrukční sadu <i>VFPx</i> (<i>vector floating point</i>). Nejprve se seznámíme s&nbsp;první možností, kdy s&nbsp;FP hodnotami pracujeme naprosto stejným způsobem, jakoby se jednalo o hodnoty celočíselné. V&nbsp;prvním příkladu tohoto typu je implementován assemblerovský blok se dvěma vstupními operandy (proměnnými typu <i>float</i>) a jediným operandem výstupním (jenž je taktéž typu <i>float</i>). Uvnitř bloku pouze přesuneme první vstupní operand do operandu výstupního, žádná další operace se zde neprovádí:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

float x = 0.5f;
float y = 1.0f;
float z = 1000.0f;

int main()
{
    printf("%f\n", z);

    __asm__ __volatile__(
        "    mov %0, %1\n"    /* presunuti prvniho vstupniho operandu na vystup */
        : "=r" (z)            /* vystupni operand */
        : "r" (x), "r" (y)    /* vstupni operandy */
        :                     /* registry pouzivane uvnitr kodu */
    );

    printf("%f\n", z);

    return 0;
}
</pre>

<p>V&nbsp;přeloženém kódu vyprodukovaném překladačem GCC vypadá náš assemblerovský blok poněkud komplikovaně, což je způsobeno načítáním vstupních operandů nepřímo přes adresy a uložením výstupního operandu taktéž přes adresu:</p>

<pre>
        ldr     r3, .L2+8
        ldr     r3, [r3, #0]    @ float
        ldr     r2, .L2+12
        ldr     r2, [r2, #0]    @ float
#APP
@ 13 "asm_in_c_12.c" 1
        <strong>mov r2, r3</strong>

@ 0 "" 2
        ldr     r3, .L2+4
        str     r2, [r3, #0]    @ float
</pre>

<p>První dvě instrukce načtou první vstupní operand (registr <strong>r3</strong> zde slouží jak pro adresování, tak i jako místo pro první operand). Druhé dvě instrukce provedou totéž, ale pro druhý vstupní operand. Následuje přenos (<strong>mov</strong>) a opětovné uložení výsledku z&nbsp;registru <strong>r2</strong> na adresu dočasně umístěnou v&nbsp;registru <strong>r3</strong>.</p>




<p><a name="k07"></a></p>
<h2 id="k07">7. Přenos druhého FP operandu do operandu výstupního</h2>

<p>Ve výpisu přeloženého kódu uvedeného <a href="#k06">v&nbsp;předchozí kapitole</a> jste si pravděpodobně povšimli toho, že jeden pracovní registr byl použit jak pro uložení vstupního operandu, tak i pro uložení operandu výstupního. Totéž bude platit ve chvíli, kdy v&nbsp;našem assemblerovském bloku přeneseme do výstupního operandu druhý vstupní operand, tj.&nbsp;hodnotu uloženou v&nbsp;proměnné <strong>y</strong>. Příklad se změní pouze minimálně:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

float x = 0.5f;
float y = 1.0f;
float z = 1000.0f;

int main()
{
    printf("%f\n", z);

    __asm__ __volatile__(
        "    mov %0, %2\n"    /* presunuti prvniho vstupniho operandu na vystup */
        : "=r" (z)            /* vystupni operand */
        : "r" (x), "r" (y)    /* vstupni operandy */
        :                     /* registry pouzivane uvnitr kodu */
    );

    printf("%f\n", z);

    return 0;
}
</pre>

<p>V&nbsp;přeloženém kódu nalezneme i část odpovídající našemu assemblerovskému bloku, provedená instrukce je vlastně zbytečná, protože převádí data do stejného registru:</p>

<pre>
        ldr     r3, .L2+8
        ldr     r3, [r3, #0]    @ float
        ldr     r2, .L2+12
        ldr     r2, [r2, #0]    @ float
#APP
@ 13 "asm_in_c_13.c" 1
        <strong>mov r2, r2</strong>

@ 0 "" 2
        ldr     r3, .L2+4
        str     r2, [r3, #0]    @ float
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Použití symbolických jmen vstupních a výstupních operandů</h2>

<p>Ještě stojí za připomenutí možnost použít symbolická jména vstupních i výstupních operandů v&nbsp;assemblerovském bloku. To je ukázáno v&nbsp;dalším demonstračním příkladu, který se ve všech ohledech podobá oběma předchozím příkladům, až na to, že namísto indexů operandů se použijí jejich symbolická jména:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

float x = 0.5f;
float y = 1.0f;
float z = 1000.0f;

int main()
{
    printf("%f\n", z);

    __asm__ __volatile__(
        "    mov %[var_z], %[var_x]\n"    /* presunuti prvniho vstupniho operandu na vystup */
        : [var_z]"=r" (z)                 /* vystupni operand */
        : [var_x]"r" (x),
          [var_y]"r" (y)                  /* vstupni operandy */
        :                                 /* registry pouzivane uvnitr kodu */
    );

    printf("%f\n", z);

    return 0;
}
</pre>

<p>Přeložená část programu s&nbsp;assemblerovským blokem a jeho inicializační fází vypadá takto (k&nbsp;žádné podstatné změně nedošlo):</p>

<pre>
        ldr     r3, .L2+8
        ldr     r3, [r3, #0]    @ float
        ldr     r2, .L2+12
        ldr     r2, [r2, #0]    @ float
#APP
@ 13 "asm_in_c_14.c" 1
            mov r2, r3

@ 0 "" 2
        ldr     r3, .L2+4
        str     r2, [r3, #0]    @ float
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Využití pracovních registrů VFP (Vector Floating Point)</h2>

<p>Mnohem častěji se s&nbsp;FP hodnotami pracuje s&nbsp;využitím <i>VFP</i>. Matematické koprocesory <i>VFP</i> obecně obsahují šestnáct pracovních registrů, každý o šířce 64 bitů. Tyto registry lze použít buď pro práci s&nbsp;hodnotami s&nbsp;dvojitou přesností (<i>double</i>) &ndash; potom se tyto registry v&nbsp;assembleru označují jmény <strong>d0</strong> až <strong>d15</strong>. Ovšem taktéž je možné libovolný registr rozdělit na dva registry o šířce 32 bitů, z&nbsp;nichž každý dokáže pojmout číselnou hodnotu s&nbsp;jednoduchou přesností (<i>single/float</i>). Díky tomuto rozdělení se počet registrů pro formát <i>single</i> zvětšil na dvojnásobek &ndash; tyto registry jsou v&nbsp;assembleru pojmenovány <strong>s0</strong> až <strong>s31</strong>. Podle konvence dodržované jak překladači, tak i v&nbsp;programových knihovnách se při volání subrutin používají registry <strong>d0</strong> až <strong>d7</strong> pro předávání parametrů subrutině, popř.&nbsp;pro získání návratových hodnot ze subrutiny. Samozřejmě se tyto registry taktéž používají při výpočtech v&nbsp;subrutině. Ostatní registry lze taktéž použít, ovšem jejich hodnota by měla být při návratu ze subrutiny obnovena.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Základní instrukce VFP</h2>

<p>Nyní se již konečně dostáváme k&nbsp;popisu jednotlivých instrukcí, které lze nalézt v&nbsp;instrukční sadě <i>VFP</i>. Zajímavý je především fakt, že každá instrukce obsahuje příznak, zda se má provádět operace s&nbsp;hodnotami/registry typu <i>single</i> či <i>double</i> (postfix <strong>.f32</strong> resp. <strong>.f64</strong>). Instrukce taktéž obsahují příznakové bity určující, za jakých podmínek se instrukce má provést. Význam těchto příznakových bitů je poněkud odlišný od bitů použitých v&nbsp;instrukční sadě <i>ARM</i>, a to především z&nbsp;toho důvodu, že příznak <strong>V</strong> má jiný význam (přetečení hodnoty celého čísla do znaménkového bitu versus dvě FP hodnoty nelze porovnat). To, zda se bude vybraná operace provádět nad dvojicí skalárních hodnot nebo nad dvojicí registrů, je určeno hodnotami <strong>LEN</strong> a <strong>STRIDE</strong>) v&nbsp;řídicím registru <strong>FPSCR</strong>. Ve výchozím nastavení je <strong>LEN</strong> rovno jedné a operace se neprovádí s&nbsp;vektory, ale se skaláry.</p>

<p>Při změně hodnoty pouze některých bitů registru <strong>FPSCR</strong> se používá následující sekvence instrukcí:</p>

<pre>
VMRS   r3,FPSCR           ; přesun hodnoty FPSCR do registru R3
BIC    r3,r3,#0x00370000  ; vynulování bitových polí STRIDE a LEN
ORR    r3,r3,#0x00030000  ; nastavení STRIDE = 1 a LEN = 4
VMSR   FPSCR,r3           ; zpětný přesun hodnoty z R3 do registru FPSCR
</pre>

<p>V&nbsp;následující tabulce jsou vypsány základní aritmetické operace:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th><th>Prováděný výpočet</th></tr>
<tr><td> 1</td><td>VADD  Fd, Fn, Fm</td><td>součet</td><td>Fd := Fn + Fm</td></tr>
<tr><td> 2</td><td>VSUB  Fd, Fn, Fm</td><td>rozdíl</td><td>Fd := Fn - Fm</td></tr>
<tr><td> 3</td><td>VNEG  Fd, Fm</td><td>změna znaménka</td><td>Fd := - Fm</td></tr>
<tr><td> 4</td><td>VABS  Fd, Fm</td><td>absolutní hodnota</td><td>Fd := abs(Fm)</td></tr>
<tr><td> 5</td><td>VSQRT Fd, Fm</td><td>druhá odmocnina</td><td>Fd := sqrt(Fm)</td></tr>
<tr><td> 6</td><td>VDIV  Fd, Fn, Fm</td><td>dělení</td><td>Fd := Fn / Fm</td></tr>
<tr><td> 7</td><td>VMUL  Fd, Fn, Fm</td><td>násobení</td><td>Fd := Fn * Fm</td></tr>
<tr><td> 8</td><td>VMLA  Fd, Fn, Fm</td><td>násobení + akumulace</td><td>Fd := Fd + (Fn * Fm)</td></tr>
<tr><td> 9</td><td>VMLS  Fd, Fn, Fm</td><td>odečtení součinu</td><td>Fd := Fd - (Fn * Fm)</td></tr>
<tr><td>10</td><td>VNMUL Fd, Fn, Fm</td><td>násobení + změna znaménka</td><td>Fn := - (Fn * Fm)</td></tr>
<tr><td>11</td><td>VNMLA Fd, Fn, Fm</td><td>kombinace VNMUL a VMLA</td><td>Fd := - Fd - (Fn * Fm)</td></tr>
<tr><td>12</td><td>VNMLS Fd, Fn, Fm</td><td>kombinace VNMUL a VMLS</td><td>Fd := - Fd + (Fn * Fm)</td></tr>
</table>

<p><ins>Poznámka: povšimněte si především šesti různých variant násobení. To je zapříčiněno tím, že se <i>VFP</i> používá například i pro filtraci obrazu, FFT atd., kde lze tyto operace s&nbsp;výhodou použít.</ins></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Součet dvou FP hodnot instrukcí <strong>vadd.f32</strong></h2>

<p>Zkusme si nyní vytvořit nepatrně složitější assemblerovský blok, v&nbsp;němž se sečte obsah dvou globálních FP proměnných <strong>x</strong>, <strong>y</strong> a výsledek se uloží do třetí proměnné <strong>z</strong>. Pro součet se využije instrukce <strong>vadd.f32</strong>, kde suffix .f32 určuje, že se bude pracovat s&nbsp;registry typu <i>single</i> (jednoduchá přesnost):</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

float x = 0.5f;
float y = 1.0f;
float z = 1000.0f;

int main()
{
    printf("%f\n", z);

    __asm__ __volatile__(
        "    vadd.f32 %[var_z], %[var_x], %[var_y]\n"  /* soucet obou vstupnich operandu */
        : [var_z]"=w" (z)                 /* vystupni operand */
        : [var_x]"w" (x),
          [var_y]"w" (y)                  /* vstupni operandy */
        :                                 /* registry pouzivane uvnitr kodu */
    );

    printf("%f\n", z);

    return 0;
}

</pre>

<p>Opět se podívejme na výsledný kód, který vznikl překladem původního zdrojového kódu demonstračního příkladu. Můžeme zde vidět, že se obsah FP registru načítá dvojicí instrukcí <strong>ldr+flds</strong> a ukládá dvojicí <strong>ldr+fsts</strong>. Překladač si zvolil použití registrů <strong>s14</strong> a <strong>s15</strong>:</p>

<pre>
        ldr     r3, .L2+8
        flds    s15, [r3, #0]
        ldr     r3, .L2+12
        flds    s14, [r3, #0]
#APP
@ 13 "asm_in_c_15.c" 1
        <strong>vadd.f32 s15, s15, s14</strong>

@ 0 "" 2
        ldr     r3, .L2+4
        fsts    s15, [r3, #0]
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Podíl dvou FP hodnot instrukcí <strong>vdiv.f32</strong></h2>

<p>Poslední příklad používá instrukci <strong>vdiv</strong> pro vydělení dvou hodnot 100,0 a -0,1; výsledkem bude -1000,0:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

float x = 100.0f;
float y = -0.1f;
float z = 0.0f;

int main()
{
    printf("%f\n", z);

    __asm__ __volatile__(
        "    vdiv.f32 %[var_z], %[var_x], %[var_y]\n"  /* soucet obou vstupnich operandu */
        : [var_z]"=w" (z)                 /* vystupni operand */
        : [var_x]"w" (x),
          [var_y]"w" (y)                  /* vstupni operandy */
        :                                 /* registry pouzivane uvnitr kodu */
    );

    printf("%f\n", z);

    return 0;
}
</pre>

<p>Vygenerovaný kód je prakticky totožný s&nbsp;předchozím příkladem, samozřejmě s&nbsp;tím rozdílem, že se namísto instrukce <strong>vadd</strong> použije instrukce <strong>vdiv</strong>:</p>

<pre>
        ldr     r3, .L2+8
        flds    s15, [r3, #0]
        ldr     r3, .L2+12
        flds    s14, [r3, #0]
#APP
@ 13 "asm_in_c_16.c" 1
        <strong>vdiv.f32 s15, s15, s14</strong>

@ 0 "" 2
        ldr     r3, .L2+4
        fsts    s15, [r3, #0]
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Makefile určený pro překlad dnešních demonstračních příkladů</h2>

<p>Všechny demonstrační příklady, které jsme si v&nbsp;dnešním i předchozím článku ukázali, lze přeložit příkazem <strong>make</strong> s&nbsp;využitím následujícího souboru Makefile. Tento soubor si raději stáhněte <a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/Makefile">přímo z&nbsp;repositáře</a>, neboť jen tak budete mít jistotu, že se nenahradí znaky pro Tab za mezery:</p>

<pre>
# Parametry prekladace.
CFLAGS=-Wall -O9 -g

# Vychozi pravidlo pro vytvoreni vysledne spustitelne aplikace.
all:    asm_in_c_0.s asm_in_c_0 \
        asm_in_c_1.s asm_in_c_1 \
        asm_in_c_2.s asm_in_c_2 \
        asm_in_c_3.s asm_in_c_3 \
        asm_in_c_4.s asm_in_c_4 \
        asm_in_c_5.s asm_in_c_5 \
        asm_in_c_6.s asm_in_c_6 \
        asm_in_c_7.s asm_in_c_7 \
        asm_in_c_8.s asm_in_c_8 \
        asm_in_c_9.s asm_in_c_9 \
        asm_in_c_10.s asm_in_c_10 \
        asm_in_c_11.s asm_in_c_11 \
        asm_in_c_12.s asm_in_c_12 \
        asm_in_c_13.s asm_in_c_13 \
        asm_in_c_14.s asm_in_c_14 \
        asm_in_c_15.s asm_in_c_15 \
        asm_in_c_16.s asm_in_c_16

clean:
        rm -f *.o
        rm -f *.s
        rm -f asm_in_c_[0-9]+

# Pravidlo pro slinkovani vsech objektovych souboru a vytvoreni
# vysledne spustitelne aplikace.
$(PROGNAME):    $(PROGNAME).o
        $(CC) -o $@ $(LDFLAGS) $&lt;

# Pravidlo pro preklad kazdeho zdrojoveho souboru do prislusneho
# objektoveho souboru.
%.o:    %.c
        $(CC) $(CFLAGS) -c $&lt; -o $@

# Pravidlo pro preklad kazdeho zdrojoveho souboru do prislusneho
# assemblerovskeho vysledku.
%.s:    %.c
        $(CC) $(CFLAGS) -S -c $&lt; -o $@
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny demonstrační příklady byly, podobně jako v&nbsp;prakticky všech předchozích částech tohoto seriálu, společně s&nbsp;podpůrným skriptem připraveným pro jejich překlad, uloženy do GIT repositáře dostupného na adrese <a href="https://github.com/tisnik/presentations/">https://github.com/tisnik/presentations/</a>. Všechny zmíněné příklady jsou určeny pro překladač GNU C (podrobnosti o konkrétních verzích jsou uvedeny v&nbsp;úvodní kapitole):</p>

<table>
<tr><th> #</th><th>Soubor</th><th>Odkaz do repositáře</th></tr>
<tr><td> 1</td><td>asm_in_c_0.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_0.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_0.c</a></td></tr>
<tr><td> 2</td><td>asm_in_c_1.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_1.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_1.c</a></td></tr>
<tr><td> 3</td><td>asm_in_c_2.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_2.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_2.c</a></td></tr>
<tr><td> 4</td><td>asm_in_c_3.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_3.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_3.c</a></td></tr>
<tr><td> 5</td><td>asm_in_c_4.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_4.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_4.c</a></td></tr>
<tr><td> 6</td><td>asm_in_c_5.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_5.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_5.c</a></td></tr>
<tr><td> 7</td><td>asm_in_c_6.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_6.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_6.c</a></td></tr>
<tr><td> 8</td><td>asm_in_c_7.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_7.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_7.c</a></td></tr>
<tr><td> 9</td><td>asm_in_c_8.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_8.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_8.c</a></td></tr>
<tr><td>10</td><td>asm_in_c_9.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_9.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_9.c</a></td></tr>
<tr><td>11</td><td>asm_in_c_10.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_10.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_10.c</a></td></tr>
<tr><td>12</td><td>asm_in_c_11.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_11.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_11.c</a></td></tr>
<tr><td>13</td><td>asm_in_c_12.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_12.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_12.c</a></td></tr>
<tr><td>14</td><td>asm_in_c_13.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_13.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_13.c</a></td></tr>
<tr><td>15</td><td>asm_in_c_14.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_14.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_14.c</a></td></tr>
<tr><td>16</td><td>asm_in_c_15.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_15.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_15.c</a></td></tr>
<tr><td>17</td><td>asm_in_c_16.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_16.c">https://github.com/tisnik/presentations/blob/master/assembler/asm_in_c_arm/asm_in_c_16.c</a></td></tr>
</table>



<p><a name="k15"></a></p>
<h2 id="k15">15. Odkazy na Internetu</h2>

<ol>

<li>ARM GCC Inline Assembler Cookbook<br />
<a href="http://www.ethernut.de/en/documents/arm-inline-asm.html">http://www.ethernut.de/en/documents/arm-inline-asm.html</a>
</li>

<li>Extended Asm - Assembler Instructions with C Expression Operands<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html</a>
</li>

<li>ARM inline asm secrets<br />
<a href="http://hardwarebug.org/2010/07/06/arm-inline-asm-secrets/">http://hardwarebug.org/2010/07/06/arm-inline-asm-secrets/</a>
</li>

<li>How to Use Inline Assembly Language in C Code<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C">https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C</a>
</li>

<li>GCC-Inline-Assembly-HOWTO<br />
<a href="http://ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">http://ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html</a>
</li>

<li>A Brief Tutorial on GCC inline asm (x86 biased)<br />
<a href="http://www.osdever.net/tutorials/view/a-brief-tutorial-on-gcc-inline-asm">http://www.osdever.net/tutorials/view/a-brief-tutorial-on-gcc-inline-asm</a>
</li>

<li>GCC Inline ASM<br />
<a href="http://locklessinc.com/articles/gcc_asm/">http://locklessinc.com/articles/gcc_asm/</a>
</li>

<li>Cortex-A35<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php</a>
</li>

<li>Cortex-A53<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php</a>
</li>

<li>Cortex-A57<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php</a>
</li>

<li>Cortex-A72<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php</a>
</li>

<li>Cortex-A73<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php</a>
</li>

<li>System cally pro AArch64 na Linuxu<br />
<a href="https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h">https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</a>
</li>

<li>Architectures/AArch64 (FedoraProject.org)<br />
<a href="https://fedoraproject.org/wiki/Architectures/AArch64">https://fedoraproject.org/wiki/Architectures/AArch64</a>
</li>

<li>SIG pro AArch64 (CentOS)<br />
<a href="https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64">https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64</a>
</li>

<li>The ARMv8 instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>A64 Instruction Set<br />
<a href="https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set">https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set</a>
</li>

<li>Switching between the instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>The A64 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>Introduction to ARMv8 64-bit Architecture<br />
<a href="https://quequero.org/2014/04/introduction-to-arm-architecture/">https://quequero.org/2014/04/introduction-to-arm-architecture/</a>
</li>

<li>MCU market turns to 32-bits and ARM<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1280803">http://www.eetimes.com/document.asp?doc_id=1280803</a>
</li>

<li>Cortex-M0 Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0.php">http://www.arm.com/products/processors/cortex-m/cortex-m0.php</a>
</li>

<li>Cortex-M0+ Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php">http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php</a>
</li>

<li>ARM Processors in a Mixed Signal World<br />
<a href="http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world">http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_architecture">https://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>ARM Documentation: B, BL, BX, BLX, and BXJ<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0204j/Cihfddaf.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0204j/Cihfddaf.html</a>
</li>

<li>Branch and Call Sequences Explained<br />
<a href="https://community.arm.com/groups/processors/blog/2013/09/25/branch-and-call-sequences-explained">https://community.arm.com/groups/processors/blog/2013/09/25/branch-and-call-sequences-explained</a>
</li>

<li>Improving ARM Code Density and Performance<br />
<a href="New Thumb Extensions to the ARM Architecture Richard Phelan">New Thumb Extensions to the ARM Architecture Richard Phelan</a>
</li>

<li>Aarch64 Register and Instruction Quick Start<br />
<a href="https://wiki.cdot.senecacollege.ca/wiki/Aarch64_Register_and_Instruction_Quick_Start">https://wiki.cdot.senecacollege.ca/wiki/Aarch64_Register_and_Instruction_Quick_Start</a>
</li>

<li>Exploring AArch64 assembler – Chapter 1<br />
<a href="http://thinkingeek.com/2016/10/08/exploring-aarch64-assembler-chapter1/">http://thinkingeek.com/2016/10/08/exploring-aarch64-assembler-chapter1/</a>
</li>

<li>Exploring AArch64 assembler – Chapter 2<br />
<a href="http://thinkingeek.com/2016/10/08/exploring-aarch64-assembler-chapter-2/">http://thinkingeek.com/2016/10/08/exploring-aarch64-assembler-chapter-2/</a>
</li>

<li>The ARM Processor Architecture<br />
<a href="http://www.arm.com/products/processors/technologies/instruction-set-architectures.php">http://www.arm.com/products/processors/technologies/instruction-set-architectures.php</a>
</li>

<li>Thumb-2 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html</a>
</li>

<li>Introduction to ARM thumb<br />
<a href="http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb">http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb</a>
</li>

<li>ARM, Thumb, and ThumbEE instruction sets<br />
<a href="http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm">http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm</a>
</li>

<li>An Introduction to ARM Assembly Language<br />
<a href="http://dev.emcelettronica.com/introduction-to-arm-assembly-language">http://dev.emcelettronica.com/introduction-to-arm-assembly-language</a>
</li>

<li>Processors - ARM<br />
<a href="http://www.arm.com/products/processors/index.php">http://www.arm.com/products/processors/index.php</a>
</li>

<li>The ARM Instruction Set<br />
<a href="http://simplemachines.it/doc/arm_inst.pdf">http://simplemachines.it/doc/arm_inst.pdf</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/ARM_architecture">http://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>C Functions Without Arguments<br />
<a href="https://eklitzke.org/c-functions-without-arguments">https://eklitzke.org/c-functions-without-arguments</a>
</li>

<li>GNU Assembler Examples<br />
<a href="http://cs.lmu.edu/~ray/notes/gasexamples/">http://cs.lmu.edu/~ray/notes/gasexamples/</a>
</li>

<li>Simply FPU<br />
<a href="http://www.website.masmforum.com/tutorials/fptute/">http://www.website.masmforum.com/tutorials/fptute/</a>
</li>

<li>Art of Assembly language programming: The 80x87 Floating Point Coprocessors<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html</a>
</li>

<li>Art of Assembly language programming: The FPU Instruction Set<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html</a>
</li>

<li>INTEL 80387 PROGRAMMER'S REFERENCE MANUAL<br />
<a href="http://www.ragestorm.net/downloads/387intel.txt">http://www.ragestorm.net/downloads/387intel.txt</a>
</li>

<li>x86 Instruction Set Reference: FLD<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_100.html">http://x86.renejeschke.de/html/file_module_x86_id_100.html</a>
</li>

<li>x86 Instruction Set Reference: FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_101.html">http://x86.renejeschke.de/html/file_module_x86_id_101.html</a>
</li>

<li>x86 Instruction Set Reference: FLD<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_100.html">http://x86.renejeschke.de/html/file_module_x86_id_100.html</a>
</li>

<li>x86 Instruction Set Reference: FST/FSTP<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_117.html">http://x86.renejeschke.de/html/file_module_x86_id_117.html</a>
</li>

<li>x86 Instruction Set Reference: BTC<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_23.html">http://x86.renejeschke.de/html/file_module_x86_id_23.html</a>
</li>

<li>x86 Instruction Set Reference: BTR<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_24.html">http://x86.renejeschke.de/html/file_module_x86_id_24.html</a>
</li>

<li>x86 Instruction Set Reference: BTS<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_25.html">http://x86.renejeschke.de/html/file_module_x86_id_25.html</a>
</li>

<li>x86 Instruction Set Reference: BSF<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_19.html">http://x86.renejeschke.de/html/file_module_x86_id_19.html</a>
</li>

<li>x86 Instruction Set Reference: BSR<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_20.html">http://x86.renejeschke.de/html/file_module_x86_id_20.html</a>
</li>

<li>x86 Instruction Set Reference: BSWAP<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_21.html">http://x86.renejeschke.de/html/file_module_x86_id_21.html</a>
</li>

<li>x86 Instruction Set Reference: XCHG<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_328.html">http://x86.renejeschke.de/html/file_module_x86_id_328.html</a>
</li>

<li>x86 Instruction Set Reference: SETcc<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_288.html">http://x86.renejeschke.de/html/file_module_x86_id_288.html</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>The GNU Assembler Tutorial<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html">http://tigcc.ticalc.org/doc/gnuasm.html</a>
</li>

<li>The GNU Assembler - macros<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html#SEC109">http://tigcc.ticalc.org/doc/gnuasm.html#SEC109</a>
</li>

<li>ARM subroutines &amp; program stack<br />
<a href="http://www.toves.org/books/armsub/">http://www.toves.org/books/armsub/</a>
</li>

<li>Generating Mixed Source and Assembly List using GCC<br />
<a href="http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/">http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/</a>
</li>

<li>Calling subroutines<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm</a>
</li>

<li>ARM Assembly Language Programming<br />
<a href="http://peter-cockerell.net/aalp/html/frames.html">http://peter-cockerell.net/aalp/html/frames.html</a>
</li>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Intel x86 JUMP quick reference<br />
<a href="http://unixwiz.net/techtips/x86-jumps.html">http://unixwiz.net/techtips/x86-jumps.html</a>
</li>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Assembler pod Linuxem<br />
<a href="http://phoenix.inf.upol.cz/linux/prog/asm.html">http://phoenix.inf.upol.cz/linux/prog/asm.html</a>
</li>

<li>AT&amp;T Syntax versus Intel Syntax<br />
<a href="https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html">https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html</a>
</li>

<li>Linux Assembly website<br />
<a href="http://asm.sourceforge.net/">http://asm.sourceforge.net/</a>
</li>

<li>Using Assembly Language in Linux<br />
<a href="http://asm.sourceforge.net/articles/linasm.html">http://asm.sourceforge.net/articles/linasm.html</a>
</li>

<li>vasm<br />
<a href="http://sun.hasenbraten.de/vasm/">http://sun.hasenbraten.de/vasm/</a>
</li>

<li>vasm &ndash; dokumentace<br />
<a href="http://sun.hasenbraten.de/vasm/release/vasm.html">http://sun.hasenbraten.de/vasm/release/vasm.html</a>
</li>

<li>The Yasm Modular Assembler Project<br />
<a href="http://yasm.tortall.net/">http://yasm.tortall.net/</a>
</li>

<li>680x0:AsmOne<br />
<a href="http://www.amigacoding.com/index.php/680x0:AsmOne">http://www.amigacoding.com/index.php/680x0:AsmOne</a>
</li>

<li>ASM-One Macro Assembler<br />
<a href="http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler">http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler</a>
</li>

<li>ASM-One pages<br />
<a href="http://www.theflamearrows.info/documents/asmone.html">http://www.theflamearrows.info/documents/asmone.html</a>
</li>

<li>Základní informace o ASM-One<br />
<a href="http://www.theflamearrows.info/documents/asminfo.html">http://www.theflamearrows.info/documents/asminfo.html</a>
</li>

<li>Linux Syscall Reference<br />
<a href="http://syscalls.kernelgrok.com/">http://syscalls.kernelgrok.com/</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>IBM System 360/370 Compiler and Historical Documentation<br />
<a href="http://www.edelweb.fr/Simula/">http://www.edelweb.fr/Simula/</a>
</li>

<li>IBM 700/7000 series<br />
<a href="http://en.wikipedia.org/wiki/IBM_700/7000_series">http://en.wikipedia.org/wiki/IBM_700/7000_series</a>
</li>

<li>IBM System/360<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/360">http://en.wikipedia.org/wiki/IBM_System/360</a>
</li>

<li>IBM System/370<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/370">http://en.wikipedia.org/wiki/IBM_System/370</a>
</li>

<li>Mainframe family tree and chronology<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html</a>
</li>

<li>704 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html</a>
</li>

<li>705 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html</a>
</li>

<li>The IBM 704<br />
<a href="http://www.columbia.edu/acis/history/704.html">http://www.columbia.edu/acis/history/704.html</a>
</li>

<li>IBM Mainframe album<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html</a>
</li>

<li>Osmibitové muzeum<br />
<a href="http://osmi.tarbik.com/">http://osmi.tarbik.com/</a>
</li>

<li>Tesla PMI-80<br />
<a href="http://osmi.tarbik.com/cssr/pmi80.html">http://osmi.tarbik.com/cssr/pmi80.html</a>
</li>

<li>PMI-80<br />
<a href="http://en.wikipedia.org/wiki/PMI-80">http://en.wikipedia.org/wiki/PMI-80</a>
</li>

<li>PMI-80<br />
<a href="http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016">http://www.old-computers.com/museum/computer.asp?st=1&amp;c=1016</a>
</li>

<li>The 6502 overflow flag explained mathematically <br />
<a href="http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html">http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html</a>
</li>

<li>X86 Opcode and Instruction Reference<br />
<a href="http://ref.x86asm.net/coder32.html">http://ref.x86asm.net/coder32.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

