<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Calysto Hy: integrace programovacího jazyka Hy s Jupyter Notebookem</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Calysto Hy: integrace programovacího jazyka Hy s Jupyter Notebookem</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku si ukážeme způsob integrace programovacího jazyka Hy, což je homoikonický jazyk odvozený od Lispu/Clojure a běžící ve virtuálním stroji Pythonu, s Jupyter Notebookem. Integraci zajišťuje kernel Calysto Hy.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Calysto Hy: integrace programovacího jazyka Hy s&nbsp;Jupyter Notebookem</a></p>
<p><a href="#k02">2. Programovací jazyk <strong>Hy</strong></a></p>
<p><a href="#k03">3. Instalace Jupyter Notebooku</a></p>
<p><a href="#k04">4. Instalace projektu Calysto Hy</a></p>
<p><a href="#k05">5. Registrace nového kernelu do Jupyter Notebooku a spuštění Jupyter Notebooku</a></p>
<p><a href="#k06">6. Základní datové typy jazyka Hy</a></p>
<p><a href="#k07">7. Zpracování kolekcí &ndash; vektorů a slovníků &ndash; v&nbsp;jazyku Hy</a></p>
<p><a href="#k08">8. Funkce a makra určená pro práci se slovníky</a></p>
<p><a href="#k09">9. Volání funkcí a metod definovaných v&nbsp;Pythonu</a></p>
<p><a href="#k10">10. Jazyk Hy a knihovna Numpy</a></p>
<p><a href="#k11">11. Volání funkcí definovaných v&nbsp;jazyku Hy z&nbsp;Pythonu</a></p>
<p><a href="#k12">12. Makrosystém programovacího jazyka Hy</a></p>
<p><a href="#k13">13. Využití <strong>eval</strong>, homoikonicita jazyků</a></p>
<p><a href="#k14">14. Makra &bdquo;quote&ldquo; a &bdquo;syntax-quote&ldquo;</a></p>
<p><a href="#k15">15. Praktické použití &ndash; jednoduchá makra vytvořená v&nbsp;jazyku Hy</a></p>
<p><a href="#k16">16. Spuštění samotného interpretru jazyka <strong>Hy</strong> a práce s&nbsp;interaktivní smyčkou REPL</a></p>
<p><a href="#k17">17. Dodatek: Dostupné kernely pro Jupyter Notebook</a></p>
<p><a href="#k18">18. Předchozí články o Jupyter Notebooku</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Calysto Hy: integrace programovacího jazyka Hy s&nbsp;Jupyter Notebookem</h2>

<p>V&nbsp;dnešním článku si ukážeme, jakým způsobem je možné zajistit integraci
programovacího jazyka Hy (což je <a
href="https://cs.wikipedia.org/wiki/Homoikonicita">homoikonický jazyk</a>
odvozený od Lispu a běžící ve virtuálním stroji Pythonu) s&nbsp;Jupyter
Notebookem. Jedná se tedy o pokračování článků, v&nbsp;nichž jsme si
představili propojení Jupyter Notebooku <a
href="https://www.root.cz/clanky/programovaci-jazyk-r-jupyter-notebook-a-jupytext/">s&nbsp;programovacím
jazykem R</a>, <a
href="https://www.root.cz/clanky/gophernotes-kombinace-interaktivniho-prostredi-jupyteru-s-jazykem-go/">Go</a>
a v&nbsp;neposlední řadě taktéž <a
href="https://www.root.cz/clanky/interpret-programovaciho-jazyka-clojure-integrovany-do-jupyter-notebooku/">s&nbsp;jazykem
Clojure</a>.</p>

<img src="https://i.iinfo.cz/images/198/calysto-hy-1.png" class="image-445236" alt="&#160;" width="300" height="300" />
<p><i>Obrázek 1: Logo programovacího jazyka Hy.</i></p>

<p>Čtenář si zajisté může položit otázku, proč by vlastně měl jazyk <i>Hy</i>
vyzkoušet a jaké nové či lepší vlastnosti mu přinese. Pravděpodobně největším
přínosem je &ndash; podobně jako v&nbsp;dalších lispovských jazycích &ndash;
homoikonocita umožňující <i>metaprogramování</i>. Dalším přínosem je snadnější
manipulace se symboly. Nesmíme ale zapomenout ani na další vlastnosti jazyka
<i>Hy</i>, například na možnost práce se zlomky (<i>fraction</i>) namísto
výpočtů s&nbsp;numerickými hodnotami reprezentovanými podle IEEE 754
(v&nbsp;Pythonu konkrétně s&nbsp;<i>double</i>, <a
href="https://www.root.cz/clanky/brain-floating-point-ndash-novy-format-ulozeni-cisel-pro-strojove-uceni-a-chytra-cidla/#k09">v&nbsp;knihovně
NumPy pak i s&nbsp;dalšími typy</a>, a to včetně typu <i>half</i>). Výpočty se
zlomky jsou sice pomalejší, neboť pro normalizaci výsledků se používá
softwarové řešení a nikoli možnosti poskytované matematickým koprocesorem,
ovšem mnoho nepříjemných vlastností typů s&nbsp;plovoucí řádovou čárkou se zde
neobjevuje (například je možné přesně pracovat s&nbsp;desetinnými hodnotami
atd.). Určitou nevýhodu představuje fakt, že nelze reprezentovat například 1/0
(tedy nekonečno) nebo 0/0.</p>

<img src="https://i.iinfo.cz/images/198/calysto-hy-2.png" class="image-445237" alt="&#160;" width="300" height="347" />
<p><i>Obrázek 2: Logo projektu Jupyter Notebook.</i></p>

<p><div class="rs-tip-major">Poznámka: pro Jupyter Notebook existují ještě
minimálně dva další reálně použitelné projekty, které uživatelům-programátorům
umožňují pracovat s&nbsp;LISPovským programovacím jazykem. Jeden z&nbsp;těchto
projektů se jmenuje <i>Calysto Scheme</i> a lze ho najít na adrese <a
href="https://github.com/Calysto/calysto_scheme">https://github.com/Calysto/calysto_scheme</a>
(podobnost s&nbsp;Calysto Hy není náhodná). Druhý z&nbsp;těchto projektů
integruje s&nbsp;Jupyter Notebookem programovací jazyk <a
href="https://clojure.org/">Clojure</a> a setkali jsme se s&nbsp;ním
v&nbsp;článku s&nbsp;titulkem <a
href="https://www.root.cz/clanky/interpret-programovaciho-jazyka-clojure-integrovany-do-jupyter-notebooku/">Interpret
programovacího jazyka Clojure integrovaný do Jupyter Notebooku</a>. Mezi těmito
projekty existují značné rozdíly. <i>Calysto Scheme</i> je klasickou
implementací programovacího jazyka Scheme, takže jsou podporovány například
<i>continuations</i>. V&nbsp;případě <i>Clojupyteru</i> se jedná o plnohodnotný
jazyk Clojure, se všemi výhodami i zápory, které to přináší (start JVM atd.). a
<i>Calysto Hy</i> je z&nbsp;tohoto pohledu &bdquo;lehkotonážní&ldquo; jazyk
postavený nad možnostmi virtuálního stroje Pythonu.</div></p>

<img src="https://i.iinfo.cz/images/198/calysto-hy-3.png" class="image-445238" alt="&#160;" width="300" height="111" />
<p><i>Obrázek 3: Logo známé knihovny NumPy.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Programovací jazyk <strong>Hy</strong></h2>

<p>Programovací jazyk <i>Hy</i> je ve velké míře inspirován (poměrně
populárním) jazykem <i>Clojure</i>, s&nbsp;nímž jsme se na stránkách Roota již
mnohokrát setkali <a href="https://www.root.cz/n/clojure/">v&nbsp;samostatném
seriálu</a>. Ovšem zatímco interpret programovacího jazyka Clojure překládá
všechny zapsané výrazy (resp.&nbsp;přesněji řečeno <i>formy</i>) do bajtkódu
JVM a teprve poté je spouští, pracuje jazyk <i>Hy</i> odlišně, protože kód
generuje s&nbsp;využitím <a
href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">AST</a> a dokonce
dokáže zdrojový LISPovský kód transformovat do Pythonu a teprve poté ho spustit
(takže se vlastně jedná o <i>transpiler</i>). To je výhodná vlastnost, protože
umožňuje <i>Hy</i> poměrně snadno integrovat například s&nbsp;debuggery atd.
Překlad přes AST nebo Python podporuje jak Python 2.x, tak i Python 3.x. Další
důležitou vlastností <i>Hy</i> je možnost plné kooperace mezi kódem zapsaným
přímo v&nbsp;tomto jazyku a Pythoním kódem, což znamená, že je možné použít
všechny pythonovské knihovny a frameworky (včetně <i>Numpy</i>, <i>PyTorch</i>,
<i>Flask</i> atd.) a naopak &ndash; například mít napsanou aplikaci
v&nbsp;Pythonu a pro manipulaci se symboly použít <i>Hy</i> (v&nbsp;tomto
ohledu jsou homoikonické programovací jazyky s&nbsp;podporou maker a ideálně i
neměnitelných datových struktur podle mého názoru mnohem lepší, než samotný
Python).</p>

<p>A právě možnost použít jazyk <i>Hy</i> společně s&nbsp;naprostou většinou
balíčků programovacího jazyka Python umožnila integraci jazyka <i>Hy</i> do
projektu Jupyter Notebook.</p>

<p>Fakt, že různé dialekty jazyků LISP a Scheme vznikají pro prakticky všechny
moderní virtuální stroje (typicky pro JVM, VM JavaScriptu nebo VM Pythonu)
vlastně není nic překvapivého. Musíme si totiž uvědomit, že praktická
použitelnost programovacího jazyka je do značné míry určena i celým
ekosystémem, který je programátorům k&nbsp;dispozici. A ekosystém Pythonu je
dnes již velmi rozsáhlý a obsahuje kvalitní a v&nbsp;celém světě používané
knihovny i celé frameworky, takže se může jednat o vhodný základ, na němž je
možné postavit moderní varianty LISPu či Scheme. Podobným způsobem ostatně
vznikl i programovací jazyk <i>Clojure</i> (což je taktéž dialekt LISPu, i když
v mnoha ohledech vylepšený a navíc od běžných Lispů odlišný), který vlastně
vůbec nemá svůj vlastní virtuální stroj &ndash; původně Clojure vzniklo pro
virtuální stroj Javy (JVM), další varianty posléze byly implementovány pro CLR
(ClojureCLR) a ClojureScript, který je kompilovaný do JavaScriptu, takže může
běžet buď v&nbsp;prohlížeči, v&nbsp;Node.js atd.</p>

<p>Pro virtuální stroj Pythonu je v&nbsp;současnosti k&nbsp;dispozici hned
několik dialektů LISPu, Scheme či Clojure. Jedná se například o méně známé
projekty <a href="https://pypi.org/project/Lizpop">Lizpop</a>, <a
href="https://pypi.org/project/lispy/">Lispy</a> či <a
href="https://pypi.org/project/Lython/">Lython</a>, dále o <a
href="https://pypi.org/project/SchemePy/">SchemePy</a> (ten mimochodem tvoří
základ pro integraci Scheme s&nbsp;Jupyter Notebookem &ndash; o tom však až
jindy), <a href="https://pypi.org/project/clojure_py/">Clojure-py</a> o němž se
zmíníme v&nbsp;dalším textu a především velmi zajímavým způsobem implementovaný
programovací jazyk <i>Hy</i>, kterému je věnována větší část dnešního článku.
Do této kategorie částečně spadá i jazyk Pixie, s&nbsp;nímž jsme se již na
stránkách Roota <a
href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">ve
stručnosti seznámili</a>.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Instalace Jupyter Notebooku</h2>

<p>S&nbsp;programovacím jazykem <i>Hy</i> se pochopitelně seznámíme prakticky a
využijeme přitom interaktivní prostředí Jupyter Notebooku. To je možné
nainstalovat hned několika způsoby, podle toho, zda se využijí balíčky dostupné
přímo v&nbsp;repositáři dané linuxové distribuce nebo se použijí jiní správci
balíčků (typicky <strong>conda</strong> nebo <strong>pip</strong>). Prakticky
všechny oficiálně podporované postupy instalace jsou zmíněny v&nbsp;diagramu
umístěném na stránce <a
href="https://jupyter.readthedocs.io/en/latest/projects/content-projects.html">https://jupyter.readthedocs.io/en/latest/projects/content-projects.html</a>.</p>

<p>Ve Fedoře (27 a výše) lze instalaci provést příkazem:</p>

<pre>
$ <strong>sudo dnf install python3-notebook</strong>
</pre>

<p>Instalace na Linux Mintu a dalších distribucích odvozených od Ubuntu nebo
Debianu:</p>

<pre>
$ <strong>sudo apt-get install python3-notebook</strong>
</pre>

<p>Samozřejmě se nainstaluje i velká řada podpůrných balíčků:</p>

<pre>
Reading package lists... Done
Building dependency tree       
Reading state information... Done
The following additional packages will be installed:
  fonts-font-awesome fonts-glyphicons-halflings javascript-common jupyter-core jupyter-nbextension-jupyter-js-widgets jupyter-notebook libjs-backbone libjs-bootstrap
  libjs-bootstrap-tour libjs-codemirror libjs-es6-promise libjs-jed libjs-jquery libjs-jquery-typeahead libjs-jquery-ui libjs-marked libjs-moment libjs-requirejs
  libjs-requirejs-text libjs-text-encoding libjs-underscore libjs-xterm pandoc pandoc-data python3-attr python3-bleach python3-dateutil python3-defusedxml
  python3-html5lib python3-importlib-metadata python3-ipykernel python3-ipywidgets python3-jinja2 python3-jsonschema python3-jupyter-client python3-jupyter-core
  python3-mistune python3-more-itertools python3-nbconvert python3-nbformat python3-pandocfilters python3-prometheus-client python3-pyrsistent python3-send2trash
  python3-terminado python3-testpath python3-tornado python3-webencodings python3-widgetsnbextension python3-zipp python3-zmq
Suggested packages:
  apache2 | lighttpd | httpd libjs-jquery-lazyload libjs-json libjs-jquery-ui-docs texlive-latex-recommended texlive-xetex texlive-luatex pandoc-citeproc
  texlive-latex-extra context wkhtmltopdf librsvg2-bin groff ghc nodejs php python ruby r-base-core node-katex python-attr-doc python-bleach-doc python3-genshi
  python3-lxml python-ipywidgets-doc python-jinja2-doc python-jsonschema-doc python-nbconvert-doc python-notebook-doc python-tornado-doc python3-twisted
The following NEW packages will be installed:
  fonts-font-awesome fonts-glyphicons-halflings javascript-common jupyter-core jupyter-nbextension-jupyter-js-widgets jupyter-notebook libjs-backbone libjs-bootstrap
  libjs-bootstrap-tour libjs-codemirror libjs-es6-promise libjs-jed libjs-jquery libjs-jquery-typeahead libjs-jquery-ui libjs-marked libjs-moment libjs-requirejs
  libjs-requirejs-text libjs-text-encoding libjs-underscore libjs-xterm pandoc pandoc-data python3-attr python3-bleach python3-dateutil python3-defusedxml
  python3-html5lib python3-importlib-metadata python3-ipykernel python3-ipywidgets python3-jinja2 python3-jsonschema python3-jupyter-client python3-jupyter-core
  python3-mistune python3-more-itertools python3-nbconvert python3-nbformat python3-notebook python3-pandocfilters python3-prometheus-client python3-pyrsistent
  python3-send2trash python3-terminado python3-testpath python3-tornado python3-webencodings python3-widgetsnbextension python3-zipp python3-zmq
0 upgraded, 52 newly installed, 0 to remove and 424 not upgraded.
Need to get 21,1 MB of archives.
After this operation, 165 MB of additional disk space will be used.
Do you want to continue? [Y/n] 
</pre>

<p>Využít je možné i výše zmíněného správce balíčků <a
href="https://docs.conda.io/en/latest/">Conda</a>. V&nbsp;případě, že tento
nástroj používáte, bude instalace vypadat následovně:</p>

<pre>
$ <strong>conda install -c conda-forge notebook</strong>
</pre>

<p>A konečně lze použít i klasický <strong>pip</strong> nebo
<strong>pip3</strong> (v&nbsp;závislosti na tom, jaký je stav Pythonu 3 na
daném operačním systému):</p>

<pre>
$ <strong>pip install notebook</strong>
</pre>

<p>V&nbsp;případě, že <strong>pip</strong> instaluje balíčky pro Python 2 a
nikoli pro Python 3, použijeme:</p>

<pre>
$ <strong>pip3 install notebook</strong>
</pre>

<p>Použít je možné i spuštění v&nbsp;kontejneru. Konkrétně pro Docker je
k&nbsp;dispozici hned několik obrazů Jupyter Notebooku, každý s&nbsp;rozdílnými
kernely a dalšími moduly. Viz <a
href="https://hub.docker.com/u/jupyter/#!">https://hub.docker.com/u/jupyter/#!</a>.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Instalace projektu Calysto Hy</h2>

<p>Po instalaci Jupyter Notebooku provedeného v&nbsp;rámci <a
href="#k03">předchozí kapitoly</a> nainstalujeme projekt <i>Calysto Hy</i>,
který zajišťuje integraci jazyka Hy právě s&nbsp;Jupyter Notebookem. Pro
zajímavost provedeme instalaci v&nbsp;rámci virtuálního prostředí Pythonu
zajištěného známým nástrojem <a
href="https://virtualenv.pypa.io/en/latest/">Virtualenv</a>. Pochopitelně lze
provést i instalaci pro celý operační systém popř.&nbsp;pro aktuálně
přihlášeného uživatele, ale pro testování a rozšiřování Jupyter Notebooku může
být použití virtuálního prostředí bezpečnější (jednoduchým přepínáním mezi
virtuálními prostředími lze omezit či změnit počet dostupných <i>kernelů</i>
atd.).</p>

<p>Nejprve vytvoříme adresář, který bude obsahovat nástroje a balíčky
nainstalované v&nbsp;rámci virtuálního prostředí:</p>

<pre>
$ <strong>python3 -m venv calysto_hy</strong>
</pre>

<p>Dále virtuální prostředí aktivujeme:</p>

<pre>
$ <strong>source calysto_hy/bin/activate</strong>
</pre>

<p>To by se mělo projevit úpravou výzvy (<i>prompt</i>):</p>

<pre>
(calysto_hy) bash-4.4$ 
</pre>

<p>Dalším krokem je instalace balíčku <a
href="https://github.com/ekaschalk/jedhy">Jedhy</a>, jenž zajišťuje automatické
doplňování kódu, prohlížení dokumentace atd. pro jazyk Hy:</p>

<pre>
(calysto_hy) bash-4.4$ <strong>pip3 install git+https://github.com/ekaschalk/jedhy.git</strong>
&nbsp;
Collecting git+https://github.com/ekaschalk/jedhy.git
  Cloning https://github.com/ekaschalk/jedhy.git to /tmp/ramdisk/pip-27q_yyiv-build
Collecting toolz (from jedhy==1)
  Downloading https://files.pythonhosted.org/packages/12/f5/537e55f8ba664ff2a26f26913010fb0fcb98b6bbadc6158af888184fd0b7/toolz-0.11.1-py3-none-any.whl (55kB)
Installing collected packages: toolz, jedhy
  Running setup.py install for jedhy: started
    Running setup.py install for jedhy: finished with status 'done'
Successfully installed jedhy-1 toolz-0.11.1
You are using pip version 9.0.3, however version 21.0.1 is available.
You should consider upgrading via the 'pip install --upgrade pip' command.
</pre>

<p>Podobně nainstalujeme samotný balíček <i>Calysto Hy</i>:</p>

<pre>
(calysto_hy) bash-4.4$ <strong>pip3 install git+https://github.com/Calysto/calysto_hy.git</strong>
&nbsp;
Collecting git+https://github.com/Calysto/calysto_hy.git
  Cloning https://github.com/Calysto/calysto_hy.git to /tmp/ramdisk/pip-rvdrr46p-build
Collecting metakernel (from calysto-hy==0.1.1)
  Downloading https://files.pythonhosted.org/packages/a4/3f/b4db994950bb1443228f097be3c0827f106641a18f0243f37bc1bd747a0a/metakernel-0.27.5-py2.py3-none-any.whl (208kB)
Collecting hy (from calysto-hy==0.1.1)
  Downloading https://files.pythonhosted.org/packages/42/5b/2a6930c12112b1e773e1c97d9c6cad9bf4b448d31daab53654b7ff2481cc/hy-0.20.0-py2.py3-none-any.whl (83kB)
Requirement already satisfied: toolz in ./calysto_hy/lib/python3.6/site-packages (from calysto-hy==0.1.1)
Collecting ipykernel (from metakernel-&gt;calysto-hy==0.1.1)
  Downloading https://files.pythonhosted.org/packages/56/95/3a670c8b2c2370bd8631c313f42e60983b3113ffec4035940592252bd6d5/ipykernel-5.5.0-py3-none-any.whl (120kB)
Collecting pexpect&gt;=4.2 (from metakernel-&gt;calysto-hy==0.1.1)
  Downloading https://files.pythonhosted.org/packages/39/7b/88dbb785881c28a102619d46423cb853b46dbccc70d3ac362d99773a78ce/pexpect-4.8.0-py2.py3-none-any.whl (59kB)
Collecting astor&gt;=0.8 (from hy-&gt;calysto-hy==0.1.1)
  Downloading https://files.pythonhosted.org/packages/c3/88/97eef84f48fa04fbd6750e62dcceafba6c63c81b7ac1420856c8dcc0a3f9/astor-0.8.1-py2.py3-none-any.whl
Collecting rply&gt;=0.7.7 (from hy-&gt;calysto-hy==0.1.1)
  Downloading https://files.pythonhosted.org/packages/c0/7c/f66be9e75485ae6901ae77d8bdbc3c0e99ca748ab927b3e18205759bde09/rply-0.7.8-py2.py3-none-any.whl
Collecting funcparserlib&gt;=0.3.6 (from hy-&gt;calysto-hy==0.1.1)
  Downloading https://files.pythonhosted.org/packages/cb/f7/b4a59c3ccf67c0082546eaeb454da1a6610e924d2e7a2a21f337ecae7b40/funcparserlib-0.3.6.tar.gz
Collecting colorama (from hy-&gt;calysto-hy==0.1.1)
  Downloading https://files.pythonhosted.org/packages/44/98/5b86278fbbf250d239ae0ecb724f8572af1c91f4a11edf4d36a206189440/colorama-0.4.4-py2.py3-none-any.whl
Collecting ipython&gt;=5.0.0 (from ipykernel-&gt;metakernel-&gt;calysto-hy==0.1.1)
  Downloading https://files.pythonhosted.org/packages/23/6a/210816c943c9aeeb29e4e18a298f14bf0e118fe222a23e13bfcc2d41b0a4/ipython-7.16.1-py3-none-any.whl (785kB)
Collecting traitlets&gt;=4.1.0 (from ipykernel-&gt;metakernel-&gt;calysto-hy==0.1.1)
  Downloading https://files.pythonhosted.org/packages/ca/ab/872a23e29cec3cf2594af7e857f18b687ad21039c1f9b922fac5b9b142d5/traitlets-4.3.3-py2.py3-none-any.whl (75kB)
Collecting jupyter-client (from ipykernel-&gt;metakernel-&gt;calysto-hy==0.1.1)
  Downloading https://files.pythonhosted.org/packages/77/e8/c3cf72a32a697256608d5fa96360c431adec6e1c6709ba7f13f99ff5ee04/jupyter_client-6.1.12-py3-none-any.whl (112kB)
Collecting tornado&gt;=4.2 (from ipykernel-&gt;metakernel-&gt;calysto-hy==0.1.1)
  Downloading https://files.pythonhosted.org/packages/01/d1/8750ad20cbcefb499bb8b405e243f83c2c89f78d139e6f8c8d800640f554/tornado-6.1-cp36-cp36m-manylinux1_x86_64.whl (427kB)
Collecting ptyprocess&gt;=0.5 (from pexpect&gt;=4.2-&gt;metakernel-&gt;calysto-hy==0.1.1)
  Downloading https://files.pythonhosted.org/packages/22/a6/858897256d0deac81a172289110f31629fc4cee19b6f01283303e18c8db3/ptyprocess-0.7.0-py2.py3-none-any.whl
Collecting appdirs (from rply&gt;=0.7.7-&gt;hy-&gt;calysto-hy==0.1.1)
  Downloading https://files.pythonhosted.org/packages/3b/00/2344469e2084fb287c2e0b57b72910309874c3245463acd6cf5e3db69324/appdirs-1.4.4-py2.py3-none-any.whl
Collecting backcall (from ipython&gt;=5.0.0-&gt;ipykernel-&gt;metakernel-&gt;calysto-hy==0.1.1)
  Downloading https://files.pythonhosted.org/packages/4c/1c/ff6546b6c12603d8dd1070aa3c3d273ad4c07f5771689a7b69a550e8c951/backcall-0.2.0-py2.py3-none-any.whl
Collecting prompt-toolkit!=3.0.0,!=3.0.1,&lt;3.1.0,&gt;=2.0.0 (from ipython&gt;=5.0.0-&gt;ipykernel-&gt;metakernel-&gt;calysto-hy==0.1.1)
  Downloading https://files.pythonhosted.org/packages/ce/ee/08ceeb759c570bf96b4c636582ebf18c14c3c844a601b2e77b17f462aa6b/prompt_toolkit-3.0.17-py3-none-any.whl (367kB)
Requirement already satisfied: setuptools&gt;=18.5 in ./calysto_hy/lib/python3.6/site-packages (from ipython&gt;=5.0.0-&gt;ipykernel-&gt;metakernel-&gt;calysto-hy==0.1.1)
Collecting decorator (from ipython&gt;=5.0.0-&gt;ipykernel-&gt;metakernel-&gt;calysto-hy==0.1.1)
  Downloading https://files.pythonhosted.org/packages/ed/1b/72a1821152d07cf1d8b6fce298aeb06a7eb90f4d6d41acec9861e7cc6df0/decorator-4.4.2-py2.py3-none-any.whl
Collecting pygments (from ipython&gt;=5.0.0-&gt;ipykernel-&gt;metakernel-&gt;calysto-hy==0.1.1)
  Downloading https://files.pythonhosted.org/packages/3a/80/a52c0a7c5939737c6dca75a831e89658ecb6f590fb7752ac777d221937b9/Pygments-2.8.1-py3-none-any.whl (983kB)
Collecting pickleshare (from ipython&gt;=5.0.0-&gt;ipykernel-&gt;metakernel-&gt;calysto-hy==0.1.1)
  Downloading https://files.pythonhosted.org/packages/9a/41/220f49aaea88bc6fa6cba8d05ecf24676326156c23b991e80b3f2fc24c77/pickleshare-0.7.5-py2.py3-none-any.whl
Collecting jedi&gt;=0.10 (from ipython&gt;=5.0.0-&gt;ipykernel-&gt;metakernel-&gt;calysto-hy==0.1.1)
  Downloading https://files.pythonhosted.org/packages/f9/36/7aa67ae2663025b49e8426ead0bad983fee1b73f472536e9790655da0277/jedi-0.18.0-py2.py3-none-any.whl (1.4MB)
Collecting six (from traitlets&gt;=4.1.0-&gt;ipykernel-&gt;metakernel-&gt;calysto-hy==0.1.1)
  Downloading https://files.pythonhosted.org/packages/ee/ff/48bde5c0f013094d729fe4b0316ba2a24774b3ff1c52d924a8a4cb04078a/six-1.15.0-py2.py3-none-any.whl
Collecting ipython-genutils (from traitlets&gt;=4.1.0-&gt;ipykernel-&gt;metakernel-&gt;calysto-hy==0.1.1)
  Downloading https://files.pythonhosted.org/packages/fa/bc/9bd3b5c2b4774d5f33b2d544f1460be9df7df2fe42f352135381c347c69a/ipython_genutils-0.2.0-py2.py3-none-any.whl
Collecting jupyter-core&gt;=4.6.0 (from jupyter-client-&gt;ipykernel-&gt;metakernel-&gt;calysto-hy==0.1.1)
  Downloading https://files.pythonhosted.org/packages/53/40/5af36bffa0af3ac71d3a6fc6709de10e4f6ff7c01745b8bc4715372189c9/jupyter_core-4.7.1-py3-none-any.whl (82kB)
Collecting pyzmq&gt;=13 (from jupyter-client-&gt;ipykernel-&gt;metakernel-&gt;calysto-hy==0.1.1)
  Downloading https://files.pythonhosted.org/packages/7c/8f/e83fc0060a7626d3555b971a70a37a0d57f727ec7ec860e9aadf96fdd724/pyzmq-22.0.3-cp36-cp36m-manylinux1_x86_64.whl (1.1MB)
Collecting python-dateutil&gt;=2.1 (from jupyter-client-&gt;ipykernel-&gt;metakernel-&gt;calysto-hy==0.1.1)
  Downloading https://files.pythonhosted.org/packages/d4/70/d60450c3dd48ef87586924207ae8907090de0b306af2bce5d134d78615cb/python_dateutil-2.8.1-py2.py3-none-any.whl (227kB)
Collecting wcwidth (from prompt-toolkit!=3.0.0,!=3.0.1,&lt;3.1.0,&gt;=2.0.0-&gt;ipython&gt;=5.0.0-&gt;ipykernel-&gt;metakernel-&gt;calysto-hy==0.1.1)
  Downloading https://files.pythonhosted.org/packages/59/7c/e39aca596badaf1b78e8f547c807b04dae603a433d3e7a7e04d67f2ef3e5/wcwidth-0.2.5-py2.py3-none-any.whl
Collecting parso&lt;0.9.0,&gt;=0.8.0 (from jedi&gt;=0.10-&gt;ipython&gt;=5.0.0-&gt;ipykernel-&gt;metakernel-&gt;calysto-hy==0.1.1)
  Downloading https://files.pythonhosted.org/packages/ad/f0/ef6bdb1eba2dbfda60c985cd8d7b47b6ed8c6a1f5d212f39ff50b64f172c/parso-0.8.1-py2.py3-none-any.whl (93kB)
Installing collected packages: backcall, six, decorator, ipython-genutils, traitlets, wcwidth, prompt-toolkit, ptyprocess, pexpect, pygments, pickleshare, parso, jedi, ipython, jupyter-core, pyzmq, python-dateutil, tornado, jupyter-client, ipykernel, metakernel, astor, appdirs, rply, funcparserlib, colorama, hy, calysto-hy
  Running setup.py install for funcparserlib: started
    Running setup.py install for funcparserlib: finished with status 'done'
  Running setup.py install for calysto-hy: started
    Running setup.py install for calysto-hy: finished with status 'done'
Successfully installed appdirs-1.4.4 astor-0.8.1 backcall-0.2.0 calysto-hy-0.1.1 colorama-0.4.4 decorator-4.4.2 funcparserlib-0.3.6 hy-0.20.0 ipykernel-5.5.0 ipython-7.16.1 ipython-genutils-0.2.0 jedi-0.18.0 jupyter-client-6.1.12 jupyter-core-4.7.1 metakernel-0.27.5 parso-0.8.1 pexpect-4.8.0 pickleshare-0.7.5 prompt-toolkit-3.0.17 ptyprocess-0.7.0 pygments-2.8.1 python-dateutil-2.8.1 pyzmq-22.0.3 rply-0.7.8 six-1.15.0 tornado-6.1 traitlets-4.3.3 wcwidth-0.2.5
You are using pip version 9.0.3, however version 21.0.1 is available.
You should consider upgrading via the 'pip install --upgrade pip' command.
</pre>

<p>A konečně v&nbsp;posledním kroku instalace spustíme příkaz pro instalaci
Calysto Hy do Notebooku:</p>

<pre>
<strong>python3 -m calysto_hy install --sys-prefix</strong>
&nbsp;
[InstallKernelSpec] Installed kernelspec calysto_hy in /home/ptisnovs/calysto_hy/share/jupyter/kernels/calysto_hy
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Registrace nového kernelu do Jupyter Notebooku a spuštění Jupyter Notebooku</h2>

<p>Pro jistotu se ještě přesvědčíme, že se nový kernel Calysto Hy skutečně
zaregistroval do Jupyter Notebooku. Soubor s&nbsp;konfigurací kernelu je uložen
v&nbsp;podadresáři <strong>calysto_hy/share/jupyter/kernels/calysto_hy</strong>
a měl by vypadat následovně:</p>

<pre>
{"argv": ["/home/ptisnovs/calysto_hy/bin/python3", "-m", "calysto_hy", "-f", "{connection_file}"], "codemirror_mode": "hy", "display_name": "Calysto Hy", "language": "hy", "name": "calysto_hy"}
</pre>

<p>Po přeformátování:</p>

<pre>
{
  "argv": [
    "/home/ptisnovs/calysto_hy/bin/python3",
    "-m",
    "calysto_hy",
    "-f",
    "{connection_file}"
  ],
  "codemirror_mode": "hy",
  "display_name": "Calysto Hy",
  "language": "hy",
  "name": "calysto_hy"
}
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;případě, že nový kernel nebude po
spuštění Jupyter Notebooku dostupný (viz též další kapitolu), vytvořte
symbolický link z&nbsp;adresáře
<strong>/home/ptisnovs/.local/share/jupyter/kernels</strong> na výše uvedený
adresář <strong>calysto_hy/share/jupyter/kernels/calysto_hy</strong>.</div></p>

<p>Ještě před prvním spuštěním Jupyter Notebooku je vhodné si nastavit heslo,
které se bude zadávat pro přístup do jeho grafického uživatelského
rozhraní:</p>

<pre>
$ <strong>jupyter notebook password</strong>
&nbsp;  
Enter password:
Verify password:
[NotebookPasswordApp] Wrote hashed password to /home/ptisnovs/.jupyter/jupyter_notebook_config.json
</pre>

<p>Nyní konečně nastal čas spustit Jupyter Notebook:</p>

<pre>
$ <strong>jupyter notebook</strong>
&nbsp;
[I 11:26:39.019 NotebookApp] Writing notebook server cookie secret to /run/user/1000/jupyter/notebook_cookie_secret
[W 11:26:39.615 NotebookApp] <i>WARNING: The notebook server is listening on all IP addresses and not using encryption. This is not recommended.</i>
[I 11:26:39.629 NotebookApp] Serving notebooks from local directory: /home/ptisnovs
[I 11:26:39.629 NotebookApp] 0 active kernels
[I 11:26:39.629 NotebookApp] The Jupyter Notebook is running at:
[I 11:26:39.629 NotebookApp] <i>http://[all ip addresses on your system]:8888/</i>
[I 11:26:39.629 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).
[I 11:26:39.983 NotebookApp] 302 GET /tree (::1) 1.91ms
</pre>

<p>Pokud se zobrazí i řádky zvýrazněné kurzivou, znamená to, že server Jupyter
Notebooku bude přístupný z&nbsp;ostatních počítačů v&nbsp;síti. Toto chování
(někdy ho vyžadujeme) lze zakázat editací souboru
<strong>~/.jupyter/jupyter_notebook_config.json</strong>, konkrétně úpravou
řádku s&nbsp;klíčem &bdquo;ip&ldquo;:</p>

<pre>
{
  "NotebookApp": {
    "password": "sha1:neco-tay-je",
    "ip": <strong>"localhost"</strong>
  }
}
</pre>

<p>Nové spuštění Jupyter Notebooku by již mělo být bezproblémové:</p>

<pre>
$ <strong>jupyter notebook</strong>
&nbsp;
[I 12:28:08.540 NotebookApp] Serving notebooks from local directory: /home/ptisnovs
[I 12:28:08.540 NotebookApp] 0 active kernels
[I 12:28:08.540 NotebookApp] The Jupyter Notebook is running at:
[I 12:28:08.540 NotebookApp] <strong>http://localhost:8888/</strong>
[I 12:28:08.540 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).
</pre>

<a href="https://www.root.cz/obrazek/445239/"><img src="https://i.iinfo.cz/images/198/calysto-hy-4-prev.png" class="image-445239" alt="&#160;" width="370" height="134" /></a>
<p><i>Obrázek 4: První spuštění Jupyter Notebooku.</i></p>

<img src="https://i.iinfo.cz/images/198/calysto-hy-5.png" class="image-445240" alt="&#160;" width="211" height="244" />
<p><i>Obrázek 5: Nabídka vytvoření nového diáře používajícího kernel Calysto
Hy.</i></p>

<a href="https://www.root.cz/obrazek/445241/"><img src="https://i.iinfo.cz/images/198/calysto-hy-6-prev.png" class="image-445241" alt="&#160;" width="370" height="83" /></a>
<p><i>Obrázek 6: Nový diář založený na kernelu Calysto Hy.</i></p>

<img src="https://i.iinfo.cz/images/198/calysto-hy-7.png" class="image-445242" alt="&#160;" width="352" height="280" />
<p><i>Obrázek 7: Kernel je možné prakticky kdykoli přepnout (i když to zde
nedává význam).</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Základní datové typy jazyka Hy</h2>

<p>V&nbsp;této kapitole si popíšeme základní jednoduché datové typy
programovacího jazyka Hy. Především se jedná o pravdivostní hodnoty. A právě
v&nbsp;tomto ohledu se <i>Hy</i> odlišuje od většiny dalších dialektů LISPu,
protože pro pravdivostní hodnoty používá <strong>True</strong> a
<strong>False</strong> převzaté přímo z&nbsp;Pythonu. I prázdná hodnota se
zapisuje jinak, než v&nbsp;mnoha dalších interpretrech LISPu, protože se
používá Pythonovské <strong>None</strong>. Rozdíly mezi různými dialekty LISPu
shrnuje následující tabulka:</p>

<table>
<tr><th>Dialekt</th><th>Pravda</th><th>Nepravda</th><th>Prázdná hodnota</th></tr>
<tr><td>Common Lisp</td><td>t</td><td>nil</td><td>nil</td></tr>
<tr><td>Scheme</td><td>#t</td><td>#f</td><td>'()</td></tr>
<tr><td>Clojure</td><td>true</td><td>false</td><td>nil</td></tr>
<tr><td>Hy</td><td>True</td><td>False</td><td>None</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: další zajímavé porovnání různých
dialektů LISPu naleznete na stránce <a
href="http://hyperpolyglot.org/lisp">http://hyperpolyglot.org/lisp</a>.</div></p>

<p>Můžeme si to vyzkoušet:</p>

<a href="https://www.root.cz/obrazek/445243/"><img src="https://i.iinfo.cz/images/198/calysto-hy-8-prev.png" class="image-445243" alt="&#160;" width="370" height="264" /></a>
<p><i>Obrázek 8: Základní datové typy programovacího jazyka Hy.</i></p>

<p>Programovací jazyk <i>Hy</i> rozlišuje mezi celými čísly, čísly
s&nbsp;plovoucí řádovou čárkou, komplexními čísly a konečně zlomky. První tři
numerické typy jsou převzaty z&nbsp;Pythonu a jsou s&nbsp;ním plně
kompatibilní; zlomky jsou typické pro prakticky všechny LISPovské jazyky a jsou
interně implementovány objektem. U numerických hodnot je možné používat prefixy
0x, 0o a 0b:</p>

<a href="https://www.root.cz/obrazek/445244/"><img src="https://i.iinfo.cz/images/198/calysto-hy-9-prev.png" class="image-445244" alt="&#160;" width="370" height="259" /></a>
<p><i>Obrázek 9: Práce s&nbsp;numerickými hodnotami.</i></p>

<p>Řetězce se zapisují prakticky stejně jako v&nbsp;Pythonu, ovšem musí se
použít uvozovky a nikoli apostrofy (ty mají odlišný význam). Podporovány jsou i
prefixy pro Unicode řetězce (výchozí) a tzv.&nbsp;&bdquo;raw&ldquo; řetězce
(typicky používané při zápisu regulárních výrazů):</p>

<a href="https://www.root.cz/obrazek/445245/"><img src="https://i.iinfo.cz/images/198/calysto-hy-10-prev.png" class="image-445245" alt="&#160;" width="370" height="169" /></a>
<p><i>Obrázek 10: Práce s&nbsp;řetězci.</i></p>

<p>Specialitou jsou tzv.&bdquo;here dokumenty&ldquo;, tj.&nbsp;víceřádkové
řetězce s&nbsp;prakticky libovolným obsahem, jejichž zápis byl inspirován <a
href="https://www.root.cz/serialy/programovaci-jazyk-lua/">programovacím
jazykem Lua</a>. Tyto řetězce začínají znaky #[XXX[ a končí znaky ]XXX],
přičemž za XXX je možné doplnit libovolně dlouhou (i prázdnou) sekvenci znaků,
která se v&nbsp;řetězci v&nbsp;ideálním případě nebude vyskytovat:</p>

<a href="https://www.root.cz/obrazek/445246/"><img src="https://i.iinfo.cz/images/198/calysto-hy-11-prev.png" class="image-445246" alt="&#160;" width="370" height="232" /></a>
<p><i>Obrázek 11: &bdquo;Here dokumenty&ldquo; v&nbsp;jazyku Hy.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Zpracování kolekcí &ndash; vektorů a slovníků &ndash; v&nbsp;jazyku Hy</h2>

<p>Ve druhé části dnešního článku se zaměříme na problematiku práce
s&nbsp;kolekcemi (tj.&nbsp;zejména s&nbsp;vektory a se slovníky), protože to je
jedna z&nbsp;oblastí, v&nbsp;níž se programovací jazyk <i>Hy</i> odlišuje od
<i>Clojure</i> (s&nbsp;nímž má jinak velmi mnoho společných vlastností). Důvody
pro všechny dále zmíněné rozdíly jsou ve skutečnosti velmi pragmatické &ndash;
vzhledem k&nbsp;tomu, že v&nbsp;<i>Hy</i> jsou vektory představované
Pythonovskými seznamy, není například možné zachovat neměnnost
(<i>immutability</i>), což je jeden z&nbsp;hlavních konceptů, na nichž je
postaven programovací jazyk <i>Clojure</i>. Většina základních funkcí navíc
vrací přímo vektor a nikoli tzv.&nbsp;línou sekvenci (<i>lazy sequence</i>)
tak, jak je tomu v&nbsp;Clojure.</p>

<p>Na začátek si uveďme důležitý fakt, že <i>Hy</i> rozlišuje mezi seznamem
(<i>list</i>), což je datová struktura podobná klasickému LISPovskému seznamu
tvořenému tečka-dvojicemi a mezi vektorem (<i>vector</i>), který odpovídá
Pythonovskému seznamu, jehož obsah i tvar (shape) je měnitelný. Vektor se
vytvoří následovně:</p>

<pre>
=&gt; <i>; vektory nejsou neměnné (immutable) tak jako v Clojure!</i>
=&gt; <strong>(setv vektor [1 2 3 4])</strong>
</pre>

<p>Takto vytvořený vektor je možné modifikovat &ndash; měnit hodnotu jeho
prvků, měnit jeho tvar (<i>shape</i>), tj.&nbsp;počet prvků atd.</p>

<p>V&nbsp;dalších demonstračním příkladech si ukážeme základní funkce určené
pro práci s&nbsp;vektory. Jedná se v&nbsp;první řadě o funkci
<strong>get</strong> určenou pro přečtení jednoho prvku ze seznamu na zadaném
indexu (indexuje se od nuly) a taktéž o funkce nazvané příznačně
<strong>first</strong> a <strong>last</strong> pro přístup k&nbsp;prvnímu
resp.&nbsp;k&nbsp;poslednímu prvku. Povšimněte si, že funkce
<strong>get</strong> akceptuje i záporné indexy pro přístup k&nbsp;prvkům od
konce vektoru, což vlastně není překvapivé, protože se tato funkce překládá na
Pythonovské <strong>vektor[index]</strong>:</p>

<pre>
=&gt; <i>; výraz pro přečtení prvku vektoru</i>
=&gt; <strong>(get vektor 1)</strong>
2
=&gt; <strong>(get vektor -1)</strong>
4
=&gt; <strong>(get vektor -2)</strong>
3
&nbsp;
=&gt; <i>; speciální funkce pro významné prvky vektoru</i>
=&gt; <strong>(first vektor)</strong>
1
=&gt; <strong>(last vektor)</strong>
4
</pre>

<p>Další funkce určená pro práci s&nbsp;vektory se jmenuje
<strong>rest</strong> a její chování již více odpovídá chování jazyka Clojure,
protože tato funkce nevrací seznam ani vektor, ale <i>iterátor</i>, což je
možné považovat za obdobu líné sekvence. Pro převod iterátoru na vektor se
používá funkce <strong>list</strong>, což je sice matoucí, ale musíme si
uvědomit, že snahou je zachování co největší úrovně kompatibility
s&nbsp;Pythonem:</p>

<pre>
=&gt; <i>; převod na sekvenci bez prvního prvku</i>
=&gt; <strong>(rest vektor)</strong>
&lt;itertools.islice object at 0x7f1237a16f98&gt;
&nbsp;
=&gt; <i>; zpětný převod sekvence na vektor</i>
=&gt; <strong>(list (rest vektor))</strong>
[2, 3, 4]
&nbsp;
=&gt; <i>; vylepšený způsob zápisu předchozího výrazu</i>
=&gt; <strong>(-> vektor rest list)</strong>
[2, 3, 4]
</pre>

<p>Následuje ukázka použití vektoru vektorů neboli matic, ať již pravidelných
nebo nepravidelných:</p>

<pre>
=&gt; <i>; dvourozměrný vektor (matice)</i>
=&gt; <strong>(setv matice [[1 2 3] [4 5 6] [7 8 9]])</strong>
&nbsp;
=&gt; <strong>matice</strong>
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
&nbsp;
=&gt; <i>; nepravidelná matice</i>
=&gt; <strong>(setv matice2 [[1] [2 3] [4 5 6] [7 8 9 10]])</strong>
&nbsp;
=&gt; <strong>matice2</strong>
[[1], [2, 3], [4, 5, 6], [7, 8, 9, 10]]
</pre>

<p>Při snaze o vytvoření &bdquo;plochého&ldquo; vektoru použijeme funkci
pojmenovanou <strong>flatten</strong>:</p>

<pre>
=&gt; <strong>(flatten matice)</strong>
[1, 2, 3, 4, 5, 6, 7, 8, 9]
</pre>

<p>Další užitečná funkce <strong>cut</strong> slouží pro vytvoření dalšího
vektoru z&nbsp;vybraných prvků vektoru prvního. Překlad této funkce odpovídá
Pythonovskému <strong>vektor[od:do]</strong>, a to včetně možnosti použití
záporných indexů:</p>

<pre>
=&gt; <i>; získání subvektoru</i>
=&gt; <strong>(cut vektor 1 5)</strong>
[2, 3, 4]
=&gt; <strong>(cut vektor 1)</strong>
[2, 3, 4]
=&gt; <strong>(cut vektor -5 -2)</strong>
[1, 2]
=&gt; <strong>(cut vektor -3 -2)</strong>
[2]
</pre>

<p>Třetím nepovinným parametrem je možné určit krok, ať již kladný či
záporný:</p>

<pre>
=&gt; <strong>(setv vektor2 (list (range 20)))</strong>
&nbsp;
=&gt; <i>; sudé prvky</i>
=&gt; <strong>(cut vektor2 2 -1 2)</strong>
[2, 4, 6, 8, 10, 12, 14, 16, 18]
=&nbsp;
=&gt; <i>; otočení vektoru</i>
=&gt; <strong>(cut vektor2 -1 0 -1)</strong>
[19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
=&nbsp;
=&gt; <i>; otočení se získáním jen lichých prvků</i>
=&gt; <strong>(cut vektor2 -1 0 -2)</strong>
[19, 17, 15, 13, 11, 9, 7, 5, 3, 1]
</pre>

<p>Pro změnu hodnoty prvku ve vektoru se používá makro <strong>assoc</strong>,
ovšem musíme si dát pozor na to, aby prvek s&nbsp;daným indexem již ve vektoru
existoval:</p>

<pre>
=&gt; <i>; změna prvku ve vektoru je možná</i>
=&gt; <strong>(assoc vektor 2 42)</strong>
=&nbsp;
=&gt; <i>; POZOR: vyhodí výjimku!</i>
=&gt; <strong>(assoc vektor 10 -1)</strong>
Traceback (most recent call last):
  File "/home/tester/.local/lib/python3.6/site-packages/hy/importer.py", line 198, in hy_eval
    eval(ast_compile(_ast, &lt;eval_body&gt;", "exec"), namespace)
  File "&lt;eval_body&gt;", line 1, in &lt;module&gt;
IndexError: list assignment index out of range
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že makro
<strong>asocc</strong> nevrací žádnou hodnotu, resp.&nbsp;přesněji řečeno vrací
<strong>None</strong> (odpovídá <strong>nil</strong> v&nbsp;LISPu). Je tomu tak
z&nbsp;toho důvodu, že dochází k&nbsp;modifikaci původního vektoru.</div></p>

<p>Při mazání prvků z&nbsp;vektoru použijeme funkci <strong>del</strong>,
typicky společně s&nbsp;funkcí <strong>cut</strong>:</p>

<pre>
=&gt; <strong>(setv vektor2 ["A" "B" "C" "D" "E" "F"])</strong>
&nbsp;
=&gt; <strong>vektor2</strong>
['A', 'B', 'C', 'D', 'E', 'F']
&nbsp;
=&gt; <strong>(cut vektor2 2 4)</strong>
['C', 'D']
&nbsp;
=&gt; <strong>(del (cut vektor2 2 4))</strong>
&nbsp;
=&gt; <strong>vektor2</strong>
&nbsp;
['A', 'B', 'E', 'F']
&nbsp;
=&gt; <strong>(-&gt; (cut vektor2 2 4) del)</strong>
&nbsp;
=&gt; <strong>vektor2</strong>
['A', 'B']
</pre>

<p>A konečně pro přidání nového prvku do vektoru můžete použít metodu
<strong>.append</strong>, která se zapisuje dvěma způsoby &ndash; funkcionálně
nebo objektově:</p>

<pre>
=&gt; <i>; přidání prvku do vektoru (na jeho konec)</i>
=&gt; <strong>(.append vektor 5)</strong>
&nbsp;
=&gt; <i>; přidání prvku do vektoru (na jeho konec)</i>
=&gt; <strong>(vektor.append 5)</strong>
</pre>

*** image ***
<p><i>Obrázek 12: Práce s&nbsp;vektory.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Funkce a makra určená pro práci se slovníky</h2>

<p>Další funkce a makra, která si v&nbsp;dnešním článku popíšeme, se týkají
práce se slovníky (<i>dictionary</i>). I v&nbsp;této oblasti vidíme inspiraci
programovacím jazykem <i>Clojure</i> (konstruktory slovníků), ovšem současně je
patrná poměrně úzká návaznost i na samotný programovací jazyk Python. Nejprve
si zopakujme, jak vypadá konstruktor slovníku. Ten je jednoduchý &ndash;
všechny dvojice klíč+hodnota se uvedou do složených závorek:</p>

<pre>
=&gt; <strong>{"prvni" "first" "druhy" "second" "treti" "third"}</strong>
{'prvni': 'first', 'druhy': 'second', 'treti': 'third'}
</pre>

<p>Pro získání hodnoty uložené pod nějakým klíčem se opět používá funkce
<strong>get</strong>, které se ovšem pochopitelně namísto indexu prvku předává
klíč (obecně neceločíselný). V&nbsp;případě, že prvek s&nbsp;daným klíčem není
nalezen, dojde k&nbsp;běhové výjimce:</p>

<pre>
=&gt; <strong>(setv d1 {:id 1 :name "Eda" :surname "Wasserfall"})</strong>
&nbsp;
=&gt; <strong>(get d1 :name)</strong>
'Eda'
=&gt; <strong>(get d1 :xyname)</strong>
Traceback (most recent call last):
  File "/home/tester/.local/lib/python3.6/site-packages/hy/importer.py", line 201, in hy_eval
    return eval(ast_compile(expr, "&lt;eval&gt;", "eval"), namespace)
  File "&lt;eval&gt;", line 1, in &lt;module&gt;
KeyError: '\ufdd0:xyname'
</pre>

<p>V&nbsp;případě, že se ve funkci <strong>get</strong> použije větší množství
selektorů (indexů popř.&nbsp;klíčů), je možné vybírat hodnoty z&nbsp;vnořených
datových struktur. Opět si to ukažme na velmi jednoduchém demonstračním
příkladu, konkrétně na slovníku, který v&nbsp;jednom prvku obsahuje seznam:</p>

<pre>
=&gt; <strong>(setv d2 {:id 1 :name "Eda" :surname "Wasserfall" :actors ["Genadij Rumlena" "Pavel Vondruška"]})</strong>
&nbsp;
=&gt; <strong>(get d2 :actors 1)</strong>
'Pavel Vondruška'
&nbsp;
=&gt; <strong>(get d2 :actors 0)</strong>
'Genadij Rumlena'
</pre>

<p>I u slovníků lze použít funkci <strong>assoc</strong> pro přidání další
dvojice klíč+hodnota. Slovník je tedy možné vytvořit postupně:</p>

<pre>
=&gt; <strong>(setv d3 {})</strong>
&nbsp;
=&gt; <strong>(assoc d3 :id 10)</strong>
&nbsp;
=&gt; <strong>(assoc d3 :name "Eda")</strong>
&nbsp;
=&gt; <strong>(assoc d3 :surname "Wasserfall")</strong>
&nbsp;
</pre>

<p><div class="rs-tip-major">Poznámka: funkce <strong>assoc</strong> mění
původní slovník, na rozdíl od stejně pojmenované funkce v&nbsp;jazyku Clojure,
která vytváří slovník nový.</div></p>

<p>Funkce <strong>assoc</strong> dokáže přepsat hodnotu prvku, a to ve chvíli,
kdy použijeme stejný klíč, který je již ve slovníku obsažen:</p>

<pre>
=&gt; <strong>(assoc d3 :id 10)</strong>
</pre>

<p>Vymazání dvojice klíč+hodnota zajišťuje funkce <strong>del</strong>:</p>

<pre>
=&gt; <strong>(del (get d3 :surname))</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;jazyce Clojure pro tento účel
slouží funkce <strong>dissoc</strong>, ovšem v&nbsp;případě jazyka Hy se
používá funkce s&nbsp;podobným názvem, jaký má klíčové slovo
<strong>del</strong> v&nbsp;Pythonu.</div></p>

<p>Další možností, jak vytvořit slovník, je použití funkce pojmenované
<strong>zip</strong> (ta zazipuje dvě sekvence), ovšem výsledek je nutné na
slovník převést:</p>

<pre>
=&gt; <strong>(dict (zip [:id :name :surname] [1 "Eda" "Wasserfall"]))</strong>
</pre>

<p>Nepatrně složitější příklady založené na funkci <strong>zip</strong>:</p>

<pre>
=&gt; <strong>(repeat "A" 10)</strong>
repeat('A', 10)
&nbsp;
=&gt; <strong>(dict (zip (range 10) (repeat "A" 10)))</strong>
{0: 'A', 1: 'A', 2: 'A', 3: 'A', 4: 'A', 5: 'A', 6: 'A', 7: 'A', 8: 'A', 9: 'A'}
&nbsp;
=&gt; <strong>(-&gt; (zip (range 10) (range 10 1 -1)) dict)</strong>
{0: 10, 1: 9, 2: 8, 3: 7, 4: 6, 5: 5, 6: 4, 7: 3, 8: 2}
</pre>

<p>Počet hodnot může přesahovat počet klíčů, ovšem hodnoty, které nelze na
klíče namapovat, se budou jednoduše ignorovat:</p>

<pre>
=&gt; <strong>(-> (zip (range 10) (range 50 1 -1)) dict)</strong>
{0: 50, 1: 49, 2: 48, 3: 47, 4: 46, 5: 45, 6: 44, 7: 43, 8: 42, 9: 41}
</pre>

*** image ***
<p><i>Obrázek 13: Práce se slovníky v&nbsp;Hy spuštěném v&nbsp;Jupyter
Notebooku.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Volání funkcí a metod definovaných v&nbsp;Pythonu</h2>

<p>V&nbsp;této kapitole si ukážeme, jakým způsobem můžeme v&nbsp;jazyku
<i>Hy</i> použít funkce a metody definované v&nbsp;Pythonu. Pro tento účel si
připravíme malý testovací modul nazvaný <strong>test_module.py</strong>, který
obsahuje jak několik funkcí, tak i třídu s&nbsp;konstruktorem a jednou metodou.
Navíc je deklarována jedna konstanta:</p>

<pre>
THE_ANSWER = 42
&nbsp;
&nbsp;
def <strong>multiply_two_numbers</strong>(x, y):
    return x * y
&nbsp;
&nbsp;
class <strong>uber_class</strong>:
    def <strong>__init__</strong>(self, x):
        self._x = x
&nbsp;
    def <strong>compute_square</strong>(self):
        return self._x * self._x
</pre>

<p>Použití tříd a metod z&nbsp;modulu <strong>datetime</strong> je snadné.
Povšimněte si, že metody lze volat jak stylem <strong>(.metoda objekt
parametry)</strong>, tak i stylem <strong>(objekt.metoda
parametry)</strong>:</p>

<pre>
(import [datetime [date :as d]])
&nbsp;
(setv date (d 2018 02 28))
(print date)
(print date.year)
(print date.month)
(print date.day)
&nbsp;
(setv now1 (.today d))
(print now1)
(setv now2 (d.today))
(print now2)
</pre>

<p>Příklad použití konstanty a funkce z&nbsp;našeho testovacího modulu ukazuje,
že lze použít jak původní jména (vytvořená podle konvencí Pythonu), tak i jména
odpovídající konvencím programovacího jazyka Hy:</p>

<pre>
(import [test_module [*]])
&nbsp;
(print THE_ANSWER)
(print *the-answer*)
(print (multiply_two_numbers 6 7))
(print (multiply-two-numbers 6 7))
</pre>

<p>Alternativní způsob importu do vlastního jmenného prostoru
<strong>t</strong>:</p>

<pre>
(import [test_module :as t])
&nbsp;
(print t.THE_ANSWER)
(print t.*the-answer*)
(print (t.multiply_two_numbers 6 7))
(print (t.multiply-two-numbers 6 7))
</pre>

<p>Konstrukce objektu a volání jeho metody (opět oběma podporovanými
způsoby):</p>

<pre>
(setv u (uber_class 42))
(print u)
(print (u.compute_square))
(print (.compute_square u))
</pre>

*** image ***
<p><i>Obrázek 14: Volání funkcí Pythonu v&nbsp;Hy spuštěném v&nbsp;Jupyter
Notebooku.</i></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Jazyk Hy a knihovna Numpy</h2>

<p>Jupyter Notebook se velmi často používá společně s&nbsp;knihovnou Numpy a
Matplotlib, popř.&nbsp;s&nbsp;knihovnou Pandas. Všechny tři zmíněné knihovny
jsou určeny pro programovací jazyk Python, takže je zřejmé (viz <a
href="#k09">předchozí kapitolu</a>), že tyto knihovny budou bez problémů
volatelné i z&nbsp;programovacího jazyka Hy. Samozřejmě je nejprve nutné
provést import těchto knihoven:</p>

<pre>
=&gt; <strong>(import numpy)</strong>
</pre>

<p>popř.:</p>

<pre>
=&gt; <strong>(import [numpy :as np])</strong>
</pre>

<p>Ihned poté je možné si zobrazit nápovědu k&nbsp;naimportované knihovně nebo
jen jediné funkci:</p>

<pre>
=&gt; <strong>(help np)</strong>
&nbsp;
Help on package numpy:
&nbsp;
NAME
    numpy
&nbsp;
DESCRIPTION
    NumPy
    =====
&nbsp;
    Provides
      1. An array object of arbitrary homogeneous items
      2. Fast mathematical operations over arrays
      3. Linear Algebra, Fourier Transforms, Random Number Generation
</pre>

<p>Naimportovanou knihovnu můžeme ihned začít používat:</p>

<pre>
=&gt; <strong>(np.arange 1 10)</strong>
array([1, 2, 3, 4, 5, 6, 7, 8, 9])
&nbsp;
=&gt; <strong>(np.linspace 1 10)</strong>
array([ 1.        ,  1.18367347,  1.36734694,  1.55102041,  1.73469388,
        1.91836735,  2.10204082,  2.28571429,  2.46938776,  2.65306122,
        2.83673469,  3.02040816,  3.20408163,  3.3877551 ,  3.57142857,
        3.75510204,  3.93877551,  4.12244898,  4.30612245,  4.48979592,
        4.67346939,  4.85714286,  5.04081633,  5.2244898 ,  5.40816327,
        5.59183673,  5.7755102 ,  5.95918367,  6.14285714,  6.32653061,
        6.51020408,  6.69387755,  6.87755102,  7.06122449,  7.24489796,
        7.42857143,  7.6122449 ,  7.79591837,  7.97959184,  8.16326531,
        8.34693878,  8.53061224,  8.71428571,  8.89795918,  9.08163265,
        9.26530612,  9.44897959,  9.63265306,  9.81632653, 10.        ])
</pre>

<p>atd.</p>

<p><div class="rs-tip-major">Poznámka: samozřejmě se stále používá typový
systém Pythonu:</div></p>

<pre>
=&gt; <strong>(np.array [1 2 3])</strong>
array([1, 2, 3])
&nbsp;
=&gt; <strong>(type (np.arange 1 10))</strong>
&nbsp;
&lt;class 'numpy.ndarray'&gt;
</pre>

<img src="https://i.iinfo.cz/images/198/calysto-hy-15.png" class="image-445250" alt="&#160;" width="659" height="774" />
<p><i>Obrázek 15: Volání funkcí z&nbsp;knihovny Numpy v&nbsp;Hy spuštěném
v&nbsp;Jupyter Notebooku.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Volání funkcí definovaných v&nbsp;jazyku Hy z&nbsp;Pythonu</h2>

<p>Nyní si ukážeme opačný směr spolupráce mezi programovacím jazykem <i>Hy</i>
a <i>Pythonem</i>, než tomu bylo <a href="#k09">v&nbsp;deváté</a> a <a
href="#k10">desáté kapitole</a>. Nejdříve nadefinujeme několik funkcí
v&nbsp;jazyku Hy a posléze tyto funkce (resp.&nbsp;jen ty funkce, které mají
korektní jméno) zavoláme z&nbsp;Pythonu. Nutné přitom je, aby se použilo
následující pojmenování souboru s&nbsp;modulem naprogramovaným v&nbsp;Hy:</p>

<pre>
jméno_modulu.hy
</pre>

<p><div class="rs-tip-major">Poznámka: demonstrační příklady z&nbsp;této
kapitole nejsou ukázány v&nbsp;Jupyter Notebooku, neboť vyžadují použití dvou
kernelů. To je samozřejmě možné, ale již poněkud komplikované.</div></p>

<p>Vytvoříme tedy soubor nazvaný <strong>interop2.hy</strong>, který bude mít
následující obsah:</p>

<pre>
<i>; Běžná funkce zapisovaná ve stylu LISPu</i>
(defn <strong>calculate-multiplication</strong>
    [x y]
    (* x y))
&nbsp;
&nbsp;
<i>; Predikáty</i>
(defn <strong>zero?</strong>
    [x]
    (= x 0))
&nbsp;
(defn <strong>even?</strong>
    [x]
    (zero? (% x 2)))
&nbsp;
(defn <strong>odd?</strong>
    [x]
    (not (even? x)))
&nbsp;
&nbsp;
<i>; Konverzní funkce</i>
(defn <strong>string-&gt;bool</strong>
    [s]
    (= s "true"))
&nbsp;
(defn <strong>deg-&gt;rad</strong>
    [angle]
    (* angle (/ 3.1415 180)))
&nbsp;
&nbsp;
<i>; Privátní funkce</i>
(defn <strong>-hidden</strong>
    [x]
    (+ x 1))
&nbsp;
<i>; Funkce psaná velkými písmeny</i>
(defn <strong>*major*</strong>
    [x]
    (+ x 1))
</pre>

<p>Všechny funkce, u nichž se podařilo vytvoření korektního pythonovského
jména, lze zavolat přímo z&nbsp;Pythonu, a to stejným způsobem, jako jakékoli
jiné funkce. Nesmíme zapomenout na import modulu <strong>hy</strong> a
samozřejmě i testovaného modulu (ten se nijak nepřekládá!):</p>

<pre>
import hy
from interop2 import *
&nbsp;
print(calculate_multiplication(6, 7))
&nbsp;
print(is_zero(0))
print(is_zero(1))
print(is_zero(2))
&nbsp;
print(is_even(0))
print(is_even(1))
print(is_even(2))
&nbsp;
print(is_odd(0))
print(is_odd(1))
print(is_odd(2))
&nbsp;
print(MAJOR(1))
&nbsp;
import interop2
print(interop2._hidden(1))
</pre>

<p><div class="rs-tip-major">Můžeme vidět, že interoperabilita mezi jazyky Hy
&rarr; Python i Python &rarr; Hy je na velmi dobré úrovni a oba programátor
může vcelku bez problémů využívat možností obou jazyků v&nbsp;jediném projektu
(s&nbsp;tím dodatkem, že situace v&nbsp;Jupyter Notebooku je nepatrně
komplikovanější).</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Makrosystém programovacího jazyka Hy</h2>

<p>V&nbsp;navazujících kapitolách se ve stručnosti seznámíme s&nbsp;možnostmi
makrosystému nabízeného programovacím jazykem Hy. Před zápisem uživatelských
maker si však ukažme takzvaná <i>reader makra</i>, která jsou aplikována již ve
chvíli načítání jednotlivých výrazů do interpretru. Samotná reader makra jsou
velmi jednoduchá, protože nemají přístup k&nbsp;AST (jsou aplikována příliš
brzy):</p>

<table>
<tr><th>#</th><th>Makro</th><th>Název</th><th>Význam</th></tr>
<tr><td>1</td><td>;</td><td>comment</td><td>umožňuje obejít zápis (comment nějaký text) u komentářů</td></tr>
<tr><td>2</td><td>'</td><td>quote</td><td>nahrazuje zápis (quote …)</td></tr>
<tr><td>3</td><td>`</td><td>syntax-quote</td><td>provádí plnou kvalifikaci symbolů + zde lze použít makra ~ a ~@</td></tr>
<tr><td>4</td><td>~</td><td>unquote</td><td>zajistí, že se vyhodnotí pouze označená část formy (= provede substituci této části výsledkem)</td></tr>
<tr><td>5</td><td>~@</td><td>unquote-splicing</td><td>podobné předchozími makru, ovšem výsledná sekvence se vloží ve formě samostatných prvků do „obalující“ sekvence</td></tr>
<tr><td>6</td><td>#</td><td>dispatch</td><td>má různé funkce: donutí reader, aby použil makro z jiné tabulky maker</td></tr>
</table>

<p>Makro <i>dispatch</i> (poslední v&nbsp;předchozí tabulce) má ve skutečnosti
několik významů v&nbsp;závislosti na tom, jaký znak je uveden ihned po křížku
(#):</p>

<table>
<tr><th>#</th><th>Dvojice znaků</th><th>Způsob použití</th><th>Význam</th></tr>
<tr><td>1</td><td>#{</td><td>#{prvky}   </td><td>zápis množiny</td></tr>
<tr><td>2</td><td>#_</td><td>#_text     </td><td>text je ignorován – alternativní způsob komentáře</td></tr>
</table>

<p>V&nbsp;uživatelských makrech (těch plnohodnotných) se velmi často používají
reader makra <i>syntax-quote</i> a <i>unquote</i>, s&nbsp;nimiž se blíže
seznámíme v&nbsp;dalším textu.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Využití funkce <strong>eval</strong>, homoikonicita jazyků</h2>

<p>Jednoduchý interpret LISPu mohl být teoreticky implementován pouze
s&nbsp;využitím trojice funkcí <strong>read</strong> (načtení výrazu/formy ze
standardního vstupu), <strong>print</strong> (tisk výsledku vyhodnocení
výrazu/formy na standardní výstup), <strong>eval</strong> (většinou rekurzivně
implementovaná funkce určená pro vyhodnocení načtené formy), které byly
doplněny speciální formou či makrem <strong>loop</strong> (nekonečná smyčka
&ndash; při striktním pohledu se v&nbsp;tomto případě nemůže jednat o funkci).
Ve skutečnosti je však samozřejmě nutné, aby byl prakticky použitelný
programovací jazyk doplněn o alespoň minimální množství základních funkcí a
speciálních forem. V&nbsp;případě původního LISPu se jednalo o sedm funkcí a
dvě speciální formy: <strong>atom</strong>, <strong>car</strong>,
<strong>cdr</strong>, <strong>cond</strong>, <strong>cons</strong>,
<strong>eq</strong>, <strong>quote</strong>, <strong>lambda</strong> a konečně
<strong>label</strong>.</p>

<p><div class="rs-tip-major">Poznámka: tyto funkce a formy jsou skutečně
postačující pro plnohodnotný LISP, přičemž samotná implementace LISPu může
vypadat takto:</div></p>

<img src="https://i.iinfo.cz/images/198/calysto-hy-16.png" class="image-445251" alt="&#160;" width="463" height="996" />
<p><i>Obrázek 16: Implementace interpretru LISPu<br />
Autor: Paul Graham.</i></p>

<p>Původně relativně velmi jednoduše a přitom elegantně implementovaný
interpret programovacího jazyka LISP se postupně začal vyvíjet a jednou
z&nbsp;nových a přitom mocných technik, které do něj byly přidány, jsou
takzvaná makra, která se však v&nbsp;mnoha ohledech liší od maker používaných
například v&nbsp;programovacích jazycích C a C++. Zatímco v&nbsp;céčku a C++
jsou makra zpracovávána poměrně &bdquo;hloupým&ldquo; preprocesorem, který
dokáže provádět textové substituce, načítat vkládané soubory a vyhodnocovat
jednoduché podmínky, mohou makra implementovaná v&nbsp;programovacím jazyce
LISP pracovat přímo se zadávanými formami, které makra mohou různým způsobem
modifikovat &ndash; přitom se zde využívá faktu, že v&nbsp;LISPu a tudíž i
v&nbsp;programovacím jazyku <i>Hy</i> jsou programy reprezentovány ve formě
(obvykle rekurzivně vnořených) seznamů, a změnou obsahu těchto seznamů lze
vlastně přímo manipulovat s&nbsp;takzvaným abstraktním syntaktickým stromem
(<i>AST – Abstract Syntax Tree</i>).</p>

<p><div class="rs-tip-major">Poznámka: odlišný makrosystém, než nabízí C a C++,
má například jazyk <a
href="https://www.root.cz/clanky/programovaci-jazyk-julia-metaprogramovani-makra-a-ast/">Julia</a>
a taktéž programovací jazyk <a
href="https://www.root.cz/clanky/prace-s-makry-v-programovacim-jazyku-rust/">Rust</a>.</div></p>

<p>Není bez zajímavosti, že s&nbsp;AST se v&nbsp;LISPu nebo Hy může manipulovat
za použití stejných mechanismů (funkcí/forem/maker), které se používají i při
běžném programování &ndash; jinými slovy to znamená, že jazyk maker je stále
jazykem, v&nbsp;němž se zapisují programy (na rozdíl od zmíněného céčka a C++,
kde je jazyk maker zcela odlišný). Jinými slovy to znamená, že se při tvorbě
maker musíme seznámit pouze se způsobem zápisu maker, ale v&nbsp;samotných
makrech se mohou používat funkce, které jsme si již v&nbsp;tomto článku popsali
&ndash; většinou se bude jednat o funkce pro práci se seznamy, což je vzhledem
ke způsobu reprezentace programů (jako do sebe vnořených seznamů)
pochopitelné.</p>

<p><div class="rs-tip-major">Poznámka: tato vlastnost se nazývá
<i>homoikonicita</i> a v&nbsp;důsledku znamená, že dialekty LISPu vlastně stojí
na vrcholu hierarchie programovacích jazyků. Jakoukoli novou sémantickou
konstrukci, která se objeví v&nbsp;jiném programovacím jazyku, je totiž možné
díky homoikonicitě implementovat i v&nbsp;LISPech (za předpokladu že LISP je
Turingovsky úplný, což bezpochyby je).</div></p>

<p>Do funkce <strong>eval</strong> je tedy možné předat pouze korektně zapsanou
formu. V&nbsp;některých případech je však určitý výraz nebo i větší část
programů dostupná pouze ve formě řetězce &ndash; ten může být přečten například
ze souboru, zadán uživatelem v&nbsp;nějakém GUI dialogu atd. Problém nastane
v&nbsp;případě, kdy se pokusíme tento řetězec předat funkci
<strong>eval</strong> v&nbsp;domnění, že se předávaný řetězec
&bdquo;automagicky&ldquo; bude transformovat na korektní formu a ta se následně
vyhodnotí.</p>

<p>Předpoklad, že <strong>eval</strong> bude jako svůj parametr akceptovat
řetězec, může vycházet ze zkušeností vývojáře s&nbsp;jinými programovacími
jazyky (nemusíme ostatně chodit daleko &ndash; takto se totiž chová přímo
Python), kde tomu tak skutečně může být, ovšem v&nbsp;Hy a ani v&nbsp;dalších
dialektech LISPu to neplatí a pro toto chování jsou i dobré důvody &ndash; mimo
jiné i bezpečnost (a taktéž to, že parsování řetězce skutečně není prací pro
<strong>eval</strong>). Podívejme se nyní, co se stane, pokud se pokusíme
nechat vyhodnotit řetězec obsahující zápis korektní formy, ovšem pouze
v&nbsp;textové podobě:</p>

<pre>
<i>; vytvoření nové globální proměnné</i>
<i>; a přiřazení SEZNAMU do této proměnné</i>
=&gt; <strong>(setv hello-code '(print "Hello world!"))</strong>
&nbsp;
<i>; hodnotu proměnné (tedy obsah seznamu)</i>
<i>; lze samozřejmě kdykoli získat</i>
=&gt; <strong>hello-code</strong>
HyExpression([
  HySymbol('print'),
  HyString('Hello world!')])
&nbsp;
<i>; i když proměnná obsahuje seznam s korektním</i>
<i>; voláním funkce, není možné použít následující</i>
<i>; formu pro zavolání této funkce</i>
=&gt; <strong>(hello-code)</strong>
Traceback (most recent call last):
  File "/home/tester/.local/lib/python3.4/site-packages/hy/importer.py", line 201, in hy_eval
    return eval(ast_compile(expr, "&lt;eval&gt;", "eval"), namespace)
  File "&lt;eval&gt;", line 1, in &lt;module&gt;
TypeError: 'HyExpression' object is not callable
&nbsp;
<i>; namísto toho se musí použít funkce eval</i>
=&gt; <strong>(eval hello-code)</strong>
Hello world!
</pre>

<a href="https://www.root.cz/obrazek/445252/"><img src="https://i.iinfo.cz/images/198/calysto-hy-17-prev.png" class="image-445252" alt="&#160;" width="370" height="213" /></a>
<p><i>Obrázek 17: Použití <strong>eval</strong> v&nbsp;jazyku Hy.</i></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Makra &bdquo;quote&ldquo; a &bdquo;syntax-quote&ldquo;</h2>

<p>Konečně se dostáváme k&nbsp;zajímavým a užitečným reader makrům. Jedno
z&nbsp;nejdůležitějších a nejčastěji používaných maker se jmenuje <i>quote</i>
a zapisuje se pomocí apostrofu. Toto makro zakazuje vyhodnocování seznamů,
protože pokud by objekt reader načetl formu ve tvaru <strong>(a b c)</strong>,
předal by ji do funkce <strong>eval</strong>, kde by se tato forma vyhodnotila
jako volání funkce <strong>a</strong> s&nbsp;parametry <strong>b</strong> a
<strong>c</strong>. Pokud však reader načte formu <strong>'(a b c)</strong>,
ztransformuje ji do tvaru <strong>(quote (a b c))</strong>, přičemž
<strong>quote</strong> je speciální forma zakazující vyhodnocení. Na většinu
ostatních objektů kromě seznamů nemá makro <i>quote</i> většinou žádný
vliv:</p>

<pre>
=&gt; <strong>'42</strong>
HyInteger(42)
=&gt; <strong>'(1 2 3)</strong>
HyExpression([
  HyInteger(1),
  HyInteger(2),
  HyInteger(3)])
=&gt; <strong>'[1 2 3]</strong>
HyList([
  HyInteger(1),
  HyInteger(2),
  HyInteger(3)])
=&gt; <strong>[1 2 3]</strong>
[1, 2, 3]
=&gt; <strong>'(* 6 7)</strong>
HyExpression([
  HySymbol('*'),
  HyInteger(6),
  HyInteger(7)])
=&gt; <strong>(* 6 7)</strong>
42
</pre>

<p>Kromě makra <i>quote</i> ještě objekt reader rozeznává poněkud
komplikovanější makro nazývané <i>syntax-quote</i>, které se zapisuje pomocí
zpětného apostrofu: `. Chování tohoto makra se liší podle toho, s&nbsp;jakým
typem objektu je použito, ovšem ve všech případech se makro chová tak, aby
nedocházelo k&nbsp;vyhodnocení jeho argumentů, popř.&nbsp;ani
k&nbsp;vyhodnocení vnořených forem. V&nbsp;následujících příkladech dochází
k&nbsp;jednoduchému zákazu vyhodnocení předané formy:</p>

<pre>
=&gt; <strong>`42</strong>
HyInteger(42)
=&gt; <strong>`(1 2 3)</strong>
HyExpression([
  HyInteger(1),
  HyInteger(2),
  HyInteger(3)])
=&gt; <strong>`[1 2 3]</strong>
HyList([
  HyInteger(1),
  HyInteger(2),
  HyInteger(3)])
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Praktické použití &ndash; jednoduchá makra vytvořená v&nbsp;jazyku Hy</h2>

<p>Uživatelská makra se vytváří s&nbsp;využitím <strong>defmacro</strong>.
Podívejme se nyní na velmi jednoduché makro, které po svém zavolání
(v&nbsp;době zpracování vstupního textu!) provede expanzi na <strong>(print
'výraz)</strong>, tj.&nbsp;vypíše se původní (nevyhodnocený!) výraz, což se
může hodit například při ladění programů:</p>

<pre>
(defmacro <strong>print-expression-1</strong>
    [expression]
    `(print '~expression))
</pre>

<p>Makro můžeme upravit i takovým způsobem, aby se nejprve vypsal nevyhodnocený
výraz a posléze i jeho výsledek. Použijeme zde speciální formu
<strong>do</strong> pro spojení většího množství funkcí do jediného bloku.
Povšimněte si, že celý blok je uvozen zpětným apostrofem a uvnitř bloku tedy
můžeme využít ~:</p>

<pre>
(defmacro <strong>print-expression-2</strong>
    [expression]
    `(do (print '~expression)
         (print ~expression)))
</pre>

<p>Příklady použití právě nadefinovaného makra
<strong>print-expression-2</strong>:</p>

<pre>
<strong>(print-expression-1 (* 6 7))</strong>
&nbsp;
HyExpression([
  HySymbol('*'),
  HyInteger(6),
  HyInteger(7)])
&nbsp;
&nbsp;
(print-expression-2 (* 6 7))
&nbsp;
HyExpression([
  HySymbol('*'),
  HyInteger(6),
  HyInteger(7)])
42
</pre>

<p>Další makro nalezneme v&nbsp;doplňkové knihovně jazyka Hy. Umožňuje pro
každý prvek seznamu zavolat nějakou funkci, která může mít vedlejší efekt.
Uvnitř této funkce je příslušný prvek seznamu představován symbolem
<strong>it</strong>. Makro nazvané <strong>ap-each</strong> vypadá následovně a
jeho chování při expanzi je zřejmý, protože známe význam ` ~ i ~@:</p>

<pre>
(defmacro ap-each [lst &amp;rest body]
  `(for [it ~lst] ~@body))
</pre>

<p>Příklad použití:</p>

<pre>
=&gt; <strong>(ap-each [1 2 3] (print it))</strong>
1
2
3
&nbsp;
=&gt; <strong>(ap-each [1 2 3] (print (* it it)))</strong>
1
4
9
</pre>

<a href="https://www.root.cz/obrazek/445254/"><img src="https://i.iinfo.cz/images/198/calysto-hy-19-prev.png" class="image-445254" alt="&#160;" width="370" height="203" /></a></p>
<p><i>Obrázek 19: Dvě užitečná makra spuštěná přímo v&nbsp;prostředí Jupyter
Notebooku.</i></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Spuštění samotného interpretru jazyka <strong>Hy</strong> a práce s&nbsp;interaktivní smyčkou REPL</h2>

<p>Interpret programovacího jazyka <i>Hy</i> není dostupný pouze z&nbsp;Jupyter
Notebooku. Můžeme ho spustit i samostatně, a to velmi jednoduše: příkazem
<strong>hy</strong>. Tento příkaz podporuje několik přepínačů, z&nbsp;nichž
nejzajímavější je <strong>--spy</strong>, o němž se zmíníme v&nbsp;dalším
textu:</p>

<pre>
$ <strong>hy --help</strong>
&nbsp;
usage: hy [-h | -v | -i CMD | -c CMD | -m MODULE | FILE | -] [ARG]...
&nbsp;
optional arguments:
-h, --help
    show this help message and exit
-c=COMMAND
    program passed in as a string (terminates option list)
-m=MOD
    module to run, passed in as a string (terminates option list)
-E
    ignore PYTHON* environment variables
-B
    don't write .py[co] files on import; also PYTHONDONTWRITEBYTECODE=x
-i=ICOMMAND
    program passed in as a string, then stay in REPL (terminates option list)
--spy
    print equivalent Python code before executing
--repl-output-fn=REPL_OUTPUT_FN
    function for printing REPL output (e.g., hy.contrib.hy-repr.hy-repr)
-v, --version
    show program's version number and exit
&nbsp;
FILE
  program read from script
-
  program read from stdin
[ARG]...
  arguments passed to program in sys.argv[1:]
</pre>

<p>Zkusme si nyní interpret spustit a získat tak přístup k&nbsp;interaktivní
smyčce <a
href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a>.
Interpret se spustí prakticky okamžitě (na rozdíl od klasického Clojure
založeného na JVM, kde je prodleva již patrnější &ndash; sekundy a
v&nbsp;některých případech i desítky sekund). Výzva interpretru (<i>prompt</i>)
se skládá ze znaků =&gt; (opět na rozdíl od Clojure bez uvedení výchozího
jmenného prostoru):</p>

<pre>
$ <strong>hy</strong>
&nbsp;
hy 0.20.0 using CPython(default) 3.6.6 on Linux
=&gt;
</pre>

<p>V&nbsp;interaktivní smyčce je každý výraz po svém načtení (<i>Read</i>) ze
standardního vstupu ihned vyhodnocen (<i>Eval</i>) a výsledná hodnota je
následně vypsána do terminálu (<i>Print</i>) a interpret bude očekávat načtení
dalšího výrazu (<i>Loop</i>). Některé výrazy jsou jednoduché, protože se
vyhodnotí samy na sebe. Příkladem mohou být numerické hodnoty, pravdivostní
hodnoty, řetězce atd:</p>

<pre>
=&gt; <strong>42</strong>
42
&nbsp;
=&gt; <strong>3.1415</strong>
3.1415
&nbsp;
=&gt; <strong>1+2j</strong>
(1+2j)
&nbsp;
=&gt; <strong>6j</strong>
6j
&nbsp;
=&gt; <strong>4/7</strong>
Fraction(4, 7)
&nbsp;
=&gt; <strong>True</strong>
True
&nbsp;
=&gt; <strong>False</strong>
False
&nbsp;
=&gt; <strong>None</strong>
&nbsp;
</pre>

<p>Volba <strong>--spy</strong> umožňuje zjisit, jakým způsobem je kód
z&nbsp;Hy transformován do Pythonu před vypsáním výsledku výrazu:</p>

<pre>
=&gt; <strong>(+ 10 20)</strong>
10 + 20
30
&nbsp;
&nbsp;
=&gt; <strong>(setv x 10)</strong>
x = 10
None
&nbsp;
&nbsp;
=&gt; <strong>(setv y 20)</strong>
y = 20
None
&nbsp;
&nbsp;
=&gt; <strong>(+ x y)</strong>
x + y
30
&nbsp;
&nbsp;
=&gt; <strong>(setv z [1 2 3])</strong>
z = [1, 2, 3]
None
&nbsp;
&nbsp;
=&gt; <strong>(assoc z 4 4)</strong>
z[4] = 4
None
</pre>

<p>Dále je možné s&nbsp;využitím nástrojů nazvaných <strong>hy2py</strong> a
<strong>hy2py3</strong> lze provést překlad zdrojových kódů naprogramovaných
v&nbsp;jazyce Hy do Pythonu 2 či do Pythonu 3. Možnosti těchto nástrojů si
ukážeme na třech variantách výpočtu faktoriálu. Povšimněte si, že výsledkem
jsou většinou velmi pěkně čitelné zdrojové kódy, což při transpřekladu není
vždy zvykem:</p>

<pre>
<i>; nerekurzivní výpočet faktoriálu</i>
&nbsp;
(defn <strong>factorial</strong>
    [n]
    (if (neg? n)
        (raise (ValueError "natural number expected"))
        (reduce * (range 1 (inc n)))))
&nbsp;
(print (factorial 10))
&nbsp;
(for [n (range 1 11)]
     (print n (factorial n)))
&nbsp;
(print (factorial -10))
</pre>

<p>Výsledek přeložený nástrojem <strong>hy2py3</strong> &ndash; příkaz od
příkazu obdoba předchozího skriptu:</p>

<pre>
from hy.core.language import inc, is_neg, reduce
from hy.core.shadow import *
&nbsp;
&nbsp;
def <strong>factorial</strong>(n):
    if is_neg(n):
        raise ValueError('natural number expected')
        _hy_anon_var_1 = None
    else:
        _hy_anon_var_1 = reduce(*, range(1, inc(n)))
    return _hy_anon_var_1
&nbsp;
&nbsp;
print(factorial(10))
for n in range(1, 11):
    print(n, factorial(n))
print(factorial(-10))
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Dodatek: dostupné kernely pro Jupyter Notebook</h2>

<p>V&nbsp;tomto dodatku jsou vypsány kernely, které jsou dostupné pro projekt
Jupyter Notebook a které uživatelům nabízí vazbu na různé programovací jazyky.
V&nbsp;kontextu dnešního článku zajímavé kernely jsou zvýrazněny:</p>

<table>
<tr><th>Kernel</th><th>Jazyk</th></tr>
<tr><td>Dyalog Jupyter Kernel</td><td>APL (Dyalog)</td></tr>
<tr><td>Coarray-Fortran</td><td>Fortran 2008/2015</td></tr>
<tr><td>IJulia</td><td>Julia</td></tr>
<tr><td>IHaskell</td><td>ghc &gt;= 7.6</td></tr>
<tr><td>IRuby</td><td>ruby &gt;= 2.3</td></tr>
<tr><td>tslab</td><td>Typescript 3.7.2, JavaScript ESNext</td></tr>
<tr><td>IJavascript</td><td>nodejs &gt;= 0.10</td></tr>
<tr><td>ITypeScript</td><td>Typescript &gt;= 2.0</td></tr>
<tr><td>jpCoffeescript</td><td>coffeescript &gt;= 1.7</td></tr>
<tr><td>jp-LiveScript</td><td>livescript &gt;= 1.5</td></tr>
<tr><td>ICSharp</td><td>C# 4.0+</td></tr>
<tr><td>IFSharp</td><td>F#</td></tr>
<tr><td>lgo</td><td>Go &gt;= 1.8</td></tr>
<tr><td>iGalileo</td><td>Galileo &gt;= 0.1.3</td></tr>
<tr><td>gopherlab</td><td>Go &gt;= 1.6</td></tr>
<tr><td>Gophernotes</td><td>Go &gt;= 1.9</td></tr>
<tr><td>IScala</td><td>Scala</td></tr>
<tr><td>IErlang</td><td>Erlang</td></tr>
<tr><td>ITorch</td><td>Torch 7 (LuaJIT)</td></tr>
<tr><td>IElixir</td><td>Elixir &gt;= 1.5</td></tr>
<tr><td>ierl</td><td>Erlang &gt;= 19, Elixir &gt;= 1.4, LFE 1.2</td></tr>
<tr><td>OCaml-Jupyter</td><td>OCaml &gt;= 4.02</td></tr>
<tr><td>IForth</td><td>Forth</td></tr>
<tr><td>peforth</td><td>Forth</td></tr>
<tr><td>IPerl</td><td>Perl 5</td></tr>
<tr><td>Perl6</td><td>Perl 6.c</td></tr>
<tr><td>IPerl6</td><td>Perl 6</td></tr>
<tr><td>Jupyter-Perl6</td><td>Perl 6.C</td></tr>
<tr><td>IPHP</td><td>PHP &gt;= 5.4</td></tr>
<tr><td>Jupyter-PHP</td><td>PHP &gt;= 7.0.0</td></tr>
<tr><td>IOctave</td><td>Octave</td></tr>
<tr><td>IScilab</td><td>Scilab</td></tr>
<tr><td>MATLAB Kernel</td><td>Matlab</td></tr>
<tr><td>Bash</td><td>bash</td></tr>
<tr><td>Z shell</td><td>zsh &gt;= 5.3</td></tr>
<tr><td>PowerShell</td><td>PowerShell</td></tr>
<tr><td><strong>CloJupyter</strong></td><td>Clojure &gt;= 1.7</td></tr>
<tr><td><strong>jupyter-kernel-jsr223</strong></td><td>Clojure 1.8</td></tr>
<tr><td><strong>Hy Kernel</strong></td><td><strong>Hy</strong></td></tr>
<tr><td><strong>Calysto Hy</strong></td><td><strong>Hy</strong></td></tr>
<tr><td>jp-babel</td><td>Babel</td></tr>
<tr><td>Lua Kernel</td><td>Lua</td></tr>
<tr><td>IPurescript</td><td>Purescript</td></tr>
<tr><td>IPyLua</td><td>Lua</td></tr>
<tr><td>ILua</td><td>Lua</td></tr>
<tr><td>Calysto Scheme</td><td>Scheme</td></tr>
<tr><td>Calysto Processing</td><td>Processing.js &gt;= 2</td></tr>
<tr><td>idl_kernel</td><td>IDL</td></tr>
<tr><td>Mochi Kernel</td><td>Mochi</td></tr>
<tr><td>Lua (used in Splash)</td><td>Lua</td></tr>
<tr><td>Calysto Bash</td><td>bash</td></tr>
<tr><td>IBrainfuck</td><td>Brainfuck</td></tr>
<tr><td>cling</td><td>C++</td></tr>
<tr><td>xeus-cling</td><td>C++</td></tr>
<tr><td>Prolog</td><td>Prolog</td></tr>
<tr><td>SWI-Prolog</td><td>SWI-Prolog</td></tr>
<tr><td>cl-jupyter</td><td>Common Lisp</td></tr>
<tr><td>common-lisp-jupyter</td><td>Common Lisp</td></tr>
<tr><td>IJython</td><td>Jython 2.7</td></tr>
<tr><td>ROOT</td><td>C++/python</td></tr>
<tr><td>Tcl</td><td>Tcl 8.5</td></tr>
<tr><td>J</td><td>J 805-807 (J901beta)</td></tr>
<tr><td>Jython</td><td>Jython&gt;=2.7.0</td></tr>
<tr><td>C</td><td>C</td></tr>
<tr><td>Coconut</td><td>Coconut</td></tr>
<tr><td>Pike</td><td>Pike &gt;= 7.8</td></tr>
<tr><td>jupyter-kotlin</td><td>Kotlin 1.1-M04 EAP</td></tr>
<tr><td>mit-scheme-kernel</td><td>MIT Scheme 9.2</td></tr>
<tr><td>elm-kernel</td><td>elm</td></tr>
<tr><td>SciJava Jupyter Kernel</td><td>Java + 9 scripting languages</td></tr>
<tr><td><strong>BeakerX</strong></td><td>Groovy, Java, Scala, Clojure, Kotlin, SQL</td></tr>
<tr><td>IJava</td><td>Java 9</td></tr>
<tr><td>Guile</td><td>Guile 2.0.12</td></tr>
<tr><td>IRacket</td><td>Racket &gt;= 6.10</td></tr>
<tr><td>EvCxR Jupyter Kernel</td><td>Rust &gt;= 1.29.2</td></tr>
<tr><td>SSH Kernel</td><td>Bash</td></tr>
<tr><td>Emu86 Kernel</td><td>Intel Assembly Language</td></tr>
</table>



<p><a name="k18"></a></p>
<h2 id="k18">18. Předchozí články o Jupyter Notebooku</h2>

<p>Se samotným nástrojem Jupyter Notebook jsme se již na stránkách Rootu
několikrát setkali (až již přímo či nepřímo), a to konkrétně
v&nbsp;následujících článcích:</p>

<ol>

<li>Gophernotes: kombinace interaktivního prostředí Jupyteru s jazykem Go<br />
<a href="https://www.root.cz/clanky/gophernotes-kombinace-interaktivniho-prostredi-jupyteru-s-jazykem-go/">https://www.root.cz/clanky/gophernotes-kombinace-interaktivniho-prostredi-jupyteru-s-jazykem-go/</a>
</li>

<li>Jupyter Notebook &ndash; nástroj pro programátory, výzkumníky i lektory<br />
<a href="https://www.root.cz/clanky/jupyter-notebook-nastroj-pro-programatory-vyzkumniky-i-lektory/">https://www.root.cz/clanky/jupyter-notebook-nastroj-pro-programatory-vyzkumniky-i-lektory/</a>
</li>

<li>Tvorba grafů v&nbsp;Jupyter Notebooku s&nbsp;využitím knihovny Matplotlib<br />
<a href="https://www.root.cz/clanky/tvorba-grafu-v-jupyter-notebooku-s-vyuzitim-knihovny-matplotlib/">https://www.root.cz/clanky/tvorba-grafu-v-jupyter-notebooku-s-vyuzitim-knihovny-matplotlib/</a>
</li>

<li>Tvorba grafů v&nbsp;Jupyter Notebooku s&nbsp;využitím knihovny Matplotlib (dokončení)<br />
<a href="https://www.root.cz/clanky/tvorba-grafu-v-jupyter-notebooku-s-vyuzitim-knihovny-matplotlib-dokonceni/">https://www.root.cz/clanky/tvorba-grafu-v-jupyter-notebooku-s-vyuzitim-knihovny-matplotlib-dokonceni/</a>
</li>

<li>Jupyter Notebook &ndash; operace s&nbsp;rastrovými obrázky a UML diagramy, literate programming<br />
<a href="https://www.root.cz/clanky/jupyter-notebook-operace-s-rastrovymi-obrazky-a-uml-diagramy-literate-programming/">https://www.root.cz/clanky/jupyter-notebook-operace-s-rastrovymi-obrazky-a-uml-diagramy-literate-programming/</a>
</li>

<li>Interpret programovacího jazyka Clojure integrovaný do Jupyter Notebooku<br />
<a href="https://www.root.cz/clanky/interpret-programovaciho-jazyka-clojure-integrovany-do-jupyter-notebooku/">https://www.root.cz/clanky/interpret-programovaciho-jazyka-clojure-integrovany-do-jupyter-notebooku/</a>
</li>

<li>Programovací jazyk R, Jupyter notebook a Jupytext<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-r-jupyter-notebook-a-jupytext/">https://www.root.cz/clanky/programovaci-jazyk-r-jupyter-notebook-a-jupytext/</a>
</li>

</ol>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny demonstrační příklady, resp.&nbsp;přesněji řečeno diáře pro Jupyter
Notebook a kernel jazyka Hy, byly uloženy do repositáře, který naleznete na
adrese <a
href="https://github.com/tisnik/jupyter-notebook-examples">https://github.com/tisnik/jupyter-notebook-examples</a>:</p>

<table>
<tr><th> #</th><th>Notebook/skript</th><th>Popis</th><th>Odkaz</th></tr>
<tr><td> 1</td><td>Calysto Hy #1 - základní datové typy.ipynb</td><td>základní datové typy jazyka Hy</td><td><a href="https://github.com/tisnik/jupyter-notebook-examples/tree/master/calysto_hy/Calysto Hy %231 - základní datové typy.ipynb">https://github.com/tisnik/jupyter-notebook-examples/tree/master/calysto_hy/Calysto Hy #1 - základní datové typy.ipynb</a></td></tr>
<tr><td> 2</td><td>Calysto Hy #2 - numerické hodnoty.ipynb</td><td>práce s&nbsp;numerickými hodnotami v&nbsp;Hy</td><td><a href="https://github.com/tisnik/jupyter-notebook-examples/tree/master/calysto_hy/Calysto Hy %232 - numerické hodnoty.ipynb">https://github.com/tisnik/jupyter-notebook-examples/tree/master/calysto_hy/Calysto Hy #2 - numerické hodnoty.ipynb</a></td></tr>
<tr><td> 3</td><td>Calysto Hy #3 - řetězce.ipynb</td><td>jazyk Hy a řetězce</td><td><a href="https://github.com/tisnik/jupyter-notebook-examples/tree/master/calysto_hy/Calysto Hy %233 - řetězce.ipynb">https://github.com/tisnik/jupyter-notebook-examples/tree/master/calysto_hy/Calysto Hy #3 - řetězce.ipynb</a></td></tr>
<tr><td> 4</td><td>Calysto Hy #4 - here dokumenty.ipynb</td><td>here dokumenty v&nbsp;jazyku Hy</td><td><a href="https://github.com/tisnik/jupyter-notebook-examples/tree/master/calysto_hy/Calysto Hy %234 - here dokumenty.ipynb">https://github.com/tisnik/jupyter-notebook-examples/tree/master/calysto_hy/Calysto Hy #4 - here dokumenty.ipynb</a></td></tr>
<tr><td> 5</td><td>Calysto Hy #5 - zpracování vektorů.ipynb</td><td>zpracování vektorů</td><td><a href="https://github.com/tisnik/jupyter-notebook-examples/tree/master/calysto_hy/Calysto Hy %235 - zpracování vektorů.ipynb">https://github.com/tisnik/jupyter-notebook-examples/tree/master/calysto_hy/Calysto Hy #5 - zpracování vektorů.ipynb</a></td></tr>
<tr><td> 6</td><td>Calysto Hy #6 - práce se slovníky.ipynb</td><td>práce se slovníky</td><td><a href="https://github.com/tisnik/jupyter-notebook-examples/tree/master/calysto_hy/Calysto Hy %236 - práce se slovníky.ipynb">https://github.com/tisnik/jupyter-notebook-examples/tree/master/calysto_hy/Calysto Hy #6 - práce se slovníky.ipynb</a></td></tr>
<tr><td> 7</td><td>Calysto Hy #7 - Python interop.ipynb</td><td>volání funkcí a metod Pythonu</td><td><a href="https://github.com/tisnik/jupyter-notebook-examples/tree/master/calysto_hy/Calysto Hy %237 - Python interop.ipynb">https://github.com/tisnik/jupyter-notebook-examples/tree/master/calysto_hy/Calysto Hy #7 - Python interop.ipynb</a></td></tr>
<tr><td> 8</td><td>Calysto Hy #8 - Numpy.ipynb</td><td>práce s&nbsp;knihovnou Numpy</td><td><a href="https://github.com/tisnik/jupyter-notebook-examples/tree/master/calysto_hy/Calysto Hy %238 - Numpy.ipynb">https://github.com/tisnik/jupyter-notebook-examples/tree/master/calysto_hy/Calysto Hy #8 - Numpy.ipynb</a></td></tr>
<tr><td> 9</td><td>Calysto Hy #9 - makra.ipynb</td><td>makra v&nbsp;jazyku Hy</td><td><a href="https://github.com/tisnik/jupyter-notebook-examples/tree/master/calysto_hy/Calysto Hy %239 - makra.ipynb">https://github.com/tisnik/jupyter-notebook-examples/tree/master/calysto_hy/Calysto Hy #9 - makra.ipynb</a></td></tr>
<tr><td>10</td><td>Calysto Hy #10 - makra.ipynb</td><td>makra v&nbsp;jazyku Hy</td><td><a href="https://github.com/tisnik/jupyter-notebook-examples/tree/master/calysto_hy/Calysto Hy %2310 - makra.ipynb">https://github.com/tisnik/jupyter-notebook-examples/tree/master/calysto_hy/Calysto Hy #10 - makra.ipynb</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Calysto Hy<br />
<a href="https://github.com/Calysto/calysto_hy">https://github.com/Calysto/calysto_hy</a>
</li>

<li>Calysto Scheme<br />
<a href="https://github.com/Calysto/calysto_scheme">https://github.com/Calysto/calysto_scheme</a>
</li>

<li>Calysto Metakernel<br />
<a href="https://github.com/Calysto/metakernel">https://github.com/Calysto/metakernel</a>
</li>

<li>Calysto Hy Notebooks: Tutorial.ipynb<br />
<a href="https://github.com/Calysto/calysto_hy/blob/master/notebooks/Tutorial.ipynb">https://github.com/Calysto/calysto_hy/blob/master/notebooks/Tutorial.ipynb</a>
</li>

<li>Python becomes a platform<br />
<a href="https://khinsen.wordpress.com/2012/03/15/python-becomes-a-platform/">https://khinsen.wordpress.com/2012/03/15/python-becomes-a-platform/</a>
</li>

<li>Python becomes a platform. Thoughts on the release of clojure-py<br />
<a href="https://news.ycombinator.com/item?id=3708974">https://news.ycombinator.com/item?id=3708974</a>
</li>

<li>SchemePy<br />
<a href="https://pypi.org/project/SchemePy/">https://pypi.org/project/SchemePy/</a>
</li>

<li>lispy<br />
<a href="https://pypi.org/project/lispy/">https://pypi.org/project/lispy/</a>
</li>

<li>Lython<br />
<a href="https://pypi.org/project/Lython/">https://pypi.org/project/Lython/</a>
</li>

<li>Lizpop<br />
<a href="https://pypi.org/project/lizpop/">https://pypi.org/project/lizpop/</a>
</li>

<li>Budoucnost programovacích jazyků<br />
<a href="http://www.knesl.com/budoucnost-programovacich-jazyku">http://www.knesl.com/budoucnost-programovacich-jazyku</a>
</li>

<li>LISP Prolog and Evolution<br />
<a href="http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html">http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html</a>
</li>

<li>List of Lisp-family programming languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages">https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages</a>
</li>

<li>clojure_py na indexu PyPi<br />
<a href="https://pypi.python.org/pypi/clojure_py">https://pypi.python.org/pypi/clojure_py</a>
</li>

<li>PyClojure<br />
<a href="https://github.com/eigenhombre/PyClojure">https://github.com/eigenhombre/PyClojure</a>
</li>

<li>Hy na GitHubu<br />
<a href="https://github.com/hylang/hy">https://github.com/hylang/hy</a>
</li>

<li>Hy: The survival guide<br />
<a href="https://notes.pault.ag/hy-survival-guide/">https://notes.pault.ag/hy-survival-guide/</a>
</li>

<li>Hy běžící na monitoru terminálu společnosti Symbolics<br />
<a href="http://try-hy.appspot.com/">http://try-hy.appspot.com/</a>
</li>

<li>Welcome to Hy’s documentation!<br />
<a href="http://docs.hylang.org/en/stable/">http://docs.hylang.org/en/stable/</a>
</li>

<li>Hy na PyPi<br />
<a href="https://pypi.org/project/hy/#description">https://pypi.org/project/hy/#description</a>
</li>

<li>Getting Hy on Python<br />
<a href="https://lwn.net/Articles/596626/">https://lwn.net/Articles/596626/</a>
</li>

<li>Programming Can Be Fun with Hy<br />
<a href="https://opensourceforu.com/2014/02/programming-can-fun-hy/">https://opensourceforu.com/2014/02/programming-can-fun-hy/</a>
</li>

<li>Přednáška o projektu Hy (pětiminutový lighttalk)<br />
<a href="http://blog.pault.ag/day/2013/04/02">http://blog.pault.ag/day/2013/04/02</a>
</li>

<li>Hy (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Hy">https://en.wikipedia.org/wiki/Hy</a>
</li>

<li>Clojure home page<br />
<a href="http://clojure.org/">http://clojure.org/</a>
</li>

<li>Clojure Sequences<br />
<a href="http://clojure.org/sequences">http://clojure.org/sequences</a>
</li>

<li>Clojure Data Structures<br />
<a href="http://clojure.org/data_structures">http://clojure.org/data_structures</a>
</li>

<li>Clojure<br />
<a href="https://en.wikipedia.org/wiki/Clojure">https://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>How to create Clojure notebooks in Jupyter<br />
<a href="https://s01blog.wordpress­.com/2017/12/10/how-to-create-clojure-notebooks-in-jupyter/">https://s01blog.wordpress­.com/2017/12/10/how-to-create-clojure-notebooks-in-jupyter/</a>
</li>

<li>Dokumentace k&nbsp;nástroji Conda<br />
<a href="https://docs.conda.io/en/latest/">https://docs.conda.io/en/latest/</a>
</li>

<li>Notebook interface<br />
<a href="https://en.wikipedia.org/wi­ki/Notebook_interface">https://en.wikipedia.org/wi­ki/Notebook_interface</a>
</li>

<li>Matplotlib Home Page<br />
<a href="http://matplotlib.org/">http://matplotlib.org/</a>
</li>

<li>Matplotlib (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Matplotlib">https://en.wikipedia.org/wiki/Matplotlib</a>
</li>

<li>Popis barvových map modulu matplotlib.cm<br />
<a href="https://gist.github.com/endolith/2719900#id7">https://gist.github.com/endolith/2719900#id7</a>
</li>

<li>Ukázky (palety) barvových map modulu matplotlib.cm<br />
<a href="http://matplotlib.org/examples/color/colormaps_reference.html">http://matplotlib.org/examples/color/colormaps_reference.html</a>
</li>

<li>Galerie grafů vytvořených v&nbsp;Matplotlibu<br />
<a href="https://matplotlib.org/3.2.1/gallery/">https://matplotlib.org/3.2.1/gallery/</a>
</li>

<li>showcase example code: xkcd.py<br />
<a href="https://matplotlib.org/xkcd/examples/showcase/xkcd.html">https://matplotlib.org/xkcd/examples/showcase/xkcd.html</a>
</li>

<li>Customising contour plots in matplotlib<br />
<a href="https://philbull.wordpress.com/2012/12/27/customising-contour-plots-in-matplotlib/">https://philbull.wordpress.com/2012/12/27/customising-contour-plots-in-matplotlib/</a>
</li>

<li>Graphics with Matplotlib<br />
<a href="http://kestrel.nmt.edu/~raymond/software/python_notes/paper004.html">http://kestrel.nmt.edu/~raymond/software/python_notes/paper004.html</a>
</li>

<li>The IPython Notebook<br />
<a href="http://ipython.org/notebook.html">http://ipython.org/notebook.html</a>
</li>

<li>nbviewer: a simple way to share Jupyter Notebooks<br />
<a href="https://nbviewer.jupyter.org/">https://nbviewer.jupyter.org/</a>
</li>

<li>Back to the Future: Lisp as a Base for a Statistical Computing System<br />
<a href="https://www.stat.auckland.ac.nz/~ihaka/downloads/Compstat-2008.pdf">https://www.stat.auckland.ac.nz/~ihaka/downloads/Compstat-2008.pdf</a>
</li>

<li>gg4clj: a simple wrapper for using R's ggplot2 in Clojure and Gorilla REPL<br />
<a href="https://github.com/JonyEpsilon/gg4clj">https://github.com/JonyEpsilon/gg4clj</a>
</li>

<li>Analemma: a Clojure-based SVG DSL and charting library<br />
<a href="http://liebke.github.io/analemma/">http://liebke.github.io/analemma/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2021</small></p>
</body>
</html>

