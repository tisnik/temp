<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Datové kolekce v programovacím jazyku Rust: množiny</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Datové kolekce v programovacím jazyku Rust: množiny</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Třetí skupinou datových kolekcí, které lze nalézt ve standardní knihovně programovacího jazyka Rust, jsou podle očekávání množiny (set). Podobně, jako tomu bylo u map, jsou i množiny implementované dvěma způsoby &ndash; s&nbsp;použitím hešovacích tabulek a B-stromů.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Datové kolekce v&nbsp;programovacím jazyku Rust: množiny</a></p>
<p><a href="#k02">2. Základní operace, které lze provádět s&nbsp;množinami</a></p>
<p><a href="#k03">3. Vytvoření množiny implementované hešovací tabulkou</a></p>
<p><a href="#k04">4. Vytvoření množiny implementované B-stromem</a></p>
<p><a href="#k05">5. Operace <strong>insert()</strong> a <strong>remove()</strong></a></p>
<p><a href="#k06">6. Množinové operace sjednocení, průniku, rozdílu a symetrické diference</a></p>
<p><a href="#k07">7. Implementace pomocí hešovací tabulky</a></p>
<p><a href="#k08">8. Implementace pomocí B-stromu</a></p>
<p><a href="#k09">9. Vytvoření množiny z&nbsp;pole</a></p>
<p><a href="#k10">10. Vytvoření množiny z&nbsp;vektoru</a></p>
<p><a href="#k11">11. Funkce pro vytvoření množiny z&nbsp;vektoru</a></p>
<p><a href="#k12">12. Použití generické formy funkce <strong>vec2set</strong></a></p>
<p><a href="#k13">13. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Datové kolekce v&nbsp;programovacím jazyku Rust: množiny</h2>

<p>Třetí důležitou datovou strukturou patřící mezi standardní kolekce, se
kterou se dříve či později musí seznámit prakticky jakýkoli vývojář používající
programovací jazyk Rust, jsou množiny (<i>sets</i>). Ty jsou charakteristické
tím, že každý prvek obsahují maximálně jednou (na rozdíl od <a
href="https://www.root.cz/clanky/datove-kolekce-v-programovacim-jazyku-rust/?ic=serial-box&icc=text-title#k07">seznamů</a>,
<a
href="https://www.root.cz/clanky/datove-kolekce-v-programovacim-jazyku-rust/?ic=serial-box&icc=text-title#k04">vektorů</a>
či hodnot uložených do <a
href="https://www.root.cz/clanky/datove-kolekce-v-programovacim-jazyku-rust-mapy/">map</a>).
Podobně jako mapy, i množiny existují ve dvou podobách: s&nbsp;nesetříděnými
prvky (založeno na hešovacích tabulkách) a se setříděnými prvky (založeno na
B-stromech). Pro vytvoření prvního typu množiny je nutno použít typ
<strong>std::collections::HashSet</strong>. Pro vytvoření druhého typu množiny
se používá datový typ <strong>std::collections::BTreeSet</strong>. V&nbsp;obou
případech je samozřejmě nutné na začátku modulu použít příkaz
<strong>use</strong>, tedy například:</p>

<pre>
use std::collections::HashSet;
</pre>

<p>či:</p>

<pre>
use std::collections::BTreeSet;
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Základní operace, které lze provádět s&nbsp;množinami</h2>

<p>Nejdůležitějšími množinovými operacemi je sjednocení, průnik, rozdíl (viz
též navazující kapitoly) a test, zda je jedna množina podmnožinou (subset) či
nadmnožinou jiné množiny. V&nbsp;programovacím jazyku Rust je ovšem množiny
možné využít podobně jako další typy sekvencí, tj.&nbsp;získat iterátor atd.
Proto se také v&nbsp;případě potřeby práce se setříděnou sekvencí většinou
používají právě množiny a nikoli ručně tříděné vektory či pole.</p>

<p>Základní operace s&nbsp;prvky množin:</p>

<table>
<tr><th>Operace</th><th>Metoda</th></tr>
<tr><td>Vložení prvku</td><td>insert()</td></tr>
<tr><td>Odstranění prvku</td><td>remove()</td></tr>
<tr><td>Přečtení prvku</td><td>get()</td></tr>
<tr><td>Kombinace odstranění a vložení</td><td>replace()</td></tr>
</table>

<p>Základní operace s&nbsp;celými množinami:</p>

<table>
<tr><th>Operace</th><th>Funkce či metoda</th><th>Operátor</th></tr>
<tr><td>Vytvoření množiny</td><td>HashSet::new(), BTreeSet::new()</td><td>&nbsp;</td></tr>
<tr><td>Získání iterátoru</td><td>iter()</td><td>&amp;množina</td></tr>
<tr><td>Sjednocení množin</td><td>union()</td><td>|</td></tr>
<tr><td>Průnik množin</td><td>intesection()</td><td>&amp;</td></tr>
<tr><td>Rozdíl množin</td><td>difference()</td><td>-</td></tr>
<tr><td>Symetrická diference</td><td>symmetric_difference()</td><td>^</td></tr>
</table>

<p>Povšimněte si, že pro základní operace s&nbsp;celými množinami byly
přetíženy i operátory &amp;, |, - a ^. Podrobnosti si řekneme později.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Vytvoření množiny implementované hešovací tabulkou</h2>

<p>V&nbsp;prvním demonstračním příkladu si ukážeme vytvoření množiny, která je
interně implementována formou hešovací tabulky. Do množiny je vloženo sedm
prvků, ovšem dva vkládané prvky mají stejnou hodnotu. Při vkládání prvků se pro
otestování unikátnosti prvků v&nbsp;množině používá trait <a
href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">Eq</a>, což mimochodem
znamená, že tento trait musí být implementován i datovým typem prvků ukládaných
do množiny. Vzhledem k&nbsp;tomu, že trait <i>Eq</i> je pro typ &amp;str
korektně implementován, bude ve skutečnosti do množiny vloženo jen šest
prvků:</p>

<pre>
use std::collections::HashSet;
&nbsp;
fn print_hashset(set: &amp;HashSet&lt;&amp;str&gt;) {
    for item in set {
        println!("{}", item);
    }
}
&nbsp;
fn main() {
    let <strong>mut</strong> set = <strong>HashSet::new()</strong>;
&nbsp;
    <strong>set.insert</strong>("podporucik");
    <strong>set.insert</strong>("inspektor");
    <strong>set.insert</strong>("praktikant");
    <strong>set.insert</strong>("tovarnik");
    <strong>set.insert</strong>("tovarnik");
    <strong>set.insert</strong>("stevard");
    <strong>set.insert</strong>("podkoni");
&nbsp;
    print_hashset(&amp;set);
}
</pre>

<p>Povšimněte si že:</p>

<ol>
<li>Typ prvků množiny je odvozen překladačem automaticky.</li>
<li>Proměnná <strong>set</strong> musí být měnitelná.</li>
<li>Při výpisu všech prvků se iterátor získává unárním operátorem &amp;</li>
<li>Pokud budete chtít specifikovat typ množiny, stačí za jméno proměnné zapsat :HashSet&lt;&amp;str&gt;</li>
</ol>

<p>Po překladu a spuštění se na standardním výstupu objeví je šestice
řádků:</p>

<pre>
stevard
inspektor
podkoni
praktikant
podporucik
tovarnik
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Vytvoření množiny implementované B-stromem</h2>

<p>Druhý příklad se prakticky neliší od příkladu prvního, pouze se použije
odlišná implementace množiny. Ve chvíli, kdy je množina interně implementována
B-stromem, budou prvky automaticky při vkládání do množiny zatříděny takovým
způsobem, že standardní iterátor vrátí prvky setříděné. Při zatřiďování prvků
se používá trait <a
href="https://doc.rust-lang.org/std/cmp/trait.Ord.html">Ord</a>, což opět
znamená, že tento trait musí být implementován datovým typem prvků množiny (to
je pochopitelně kontrolováno překladačem):</p>

<pre>
use std::collections::BTreeSet;
&nbsp;
fn print_hashset(set: &amp;BTreeSet&lt;&amp;str&gt;) {
    for item in set {
        println!("{}", item);
    }
}
&nbsp;
fn main() {
    let <strong>mut</strong> set = <strong>BTreeSet::new()</strong>;
&nbsp;
    <strong>set.insert</strong>("podporucik");
    <strong>set.insert</strong>("inspektor");
    <strong>set.insert</strong>("praktikant");
    <strong>set.insert</strong>("tovarnik");
    <strong>set.insert</strong>("tovarnik");
    <strong>set.insert</strong>("stevard");
    <strong>set.insert</strong>("podkoni");
&nbsp;
    print_hashset(&amp;set);
}
</pre>

<p>Po překladu a spuštění se na standardním výstupu objeví je šestice
řádků:</p>

<pre>
inspektor
podkoni
podporucik
praktikant
stevard
tovarnik
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Operace <strong>insert()</strong> a <strong>remove()</strong></h2>

<p>Opakem operace <strong>insert</strong>, která vkládá nové prvky do množiny,
je samozřejmě operace <strong>remove</strong>. Současně tato funkce vrací
pravdivostní hodnotu <strong>true</strong>, pokud odstraňovaný prvek skutečně
v&nbsp;množině existoval. Pokud neexistoval, vrátí se hodnota
<strong>false</strong>, ale z&nbsp;pohledu operací prováděných nad množinami se
nejedná o chybu:</p>

<pre>
use std::collections::HashSet;
&nbsp;
fn print_hashset(set: &amp;HashSet&lt;&amp;str&gt;) {
    for item in set {
        println!("{}", item);
    }
}
&nbsp;
fn main() {
    let mut set = HashSet::new();
&nbsp;
    set.insert("podporucik");
    set.insert("inspektor");
    set.insert("praktikant");
    set.insert("tovarnik");
    set.insert("tovarnik");
    set.insert("stevard");
    set.insert("podkoni");
&nbsp;
    print_hashset(&amp;set);
&nbsp;
    println!("-------------------------------");
&nbsp;
    <strong>set.remove</strong>("tovarnik");
    <strong>set.remove</strong>("neco jineho");
&nbsp;
    print_hashset(&amp;set);
}
</pre>

<p>Příklad výstupu. Před oddělovačem je zobrazen původní obsah množiny, pod
oddělovačem pak nový obsah po odstranění jednoho jejího prvku (druhé volání
<strong>remove</strong> pouze vrátilo <strong>false</strong>):</p>

<pre>
stevard
tovarnik
praktikant
podkoni
inspektor
podporucik
-------------------------------
stevard
praktikant
podkoni
inspektor
podporucik
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Množinové operace sjednocení, průniku, rozdílu a symetrické diference</h2>

<p>Již ve <a href="#k02">druhé kapitole</a> jsme si řekli, že množiny ze
standardní knihovny programovacího jazyka Rust podporují čtyři <a
href="https://cs.wikipedia.org/wiki/Mno%C5%BEina#Z.C3.A1kladn.C3.AD_mno.C5.BEinov.C3.A9_operace">základní
množinové operace</a> s&nbsp;výjimkou doplňku (ten není podporován, protože by
v&nbsp;naprosté většině případů musel vygenerovat nekonečnou množinu). Podle
očekávání jsou všechny operace reprezentovány metodami, jejichž parametrem je
reference na druhou množinu a výsledkem iterátor pro prvky množiny nové. Kromě
toho je ovšem možné použít i přetížené operátory, jejichž operandy jsou vždy
reference na obě množiny. Použití přetížených operátorů je podle mého názoru
v&nbsp;tomto případě mnohem čitelnější:</p>

<table>
<tr><th>Operace</th><th>Funkce či metoda</th><th>Operátor</th></tr>
<tr><td>Sjednocení množin</td><td>union()</td><td>|</td></tr>
<tr><td>Průnik množin</td><td>intesection()</td><td>&amp;</td></tr>
<tr><td>Rozdíl množin</td><td>difference()</td><td>-</td></tr>
<tr><td>Symetrická diference</td><td>symmetric_difference()</td><td>^</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Implementace pomocí hešovací tabulky</h2>

<p>V&nbsp;dalším příkladu jsou všechny čtyři podporované množinové operace
volány formou metod:</p>

<pre>
use std::collections::HashSet;
&nbsp;
fn print_hashset(set: &amp;HashSet&lt;&amp;str&gt;) {
    for item in set {
        println!("{}", item);
    }
}
&nbsp;
fn main() {
    let mut set1 = HashSet::new();
    let mut set2 = HashSet::new();
&nbsp;
    set1.insert("podporucik");
    set1.insert("inspektor");
    set1.insert("praktikant");
    set1.insert("tovarnik");
&nbsp;
    set2.insert("tovarnik");
    set2.insert("stevard");
    set2.insert("podkoni");
    set2.insert("inspektor");
&nbsp;
    println!("Set1");
    print_hashset(&amp;set1);
&nbsp;
    println!("\nSet2");
    print_hashset(&amp;set2);
&nbsp;
    println!("\nUnion");
    for item in <strong>set1.union(&amp;set2)</strong> {
        println!("{}", item);
    }
&nbsp;
    println!("\nIntersetion");
    for item in <strong>set1.intersection(&amp;set2)</strong> {
        println!("{}", item);
    }
&nbsp;
    println!("\nDifference set1-set2");
    for item in <strong>set1.difference(&amp;set2)</strong> {
        println!("{}", item);
    }
&nbsp;
    println!("\nDifference set2-set1");
    for item in <strong>set2.difference(&amp;set1)</strong> {
        println!("{}", item);
    }
&nbsp;
    println!("\nSymmetric difference");
    for item in <strong>set1.symmetric_difference(&amp;set2)</strong> {
        println!("{}", item);
    }
}
</pre>

<p>Příklad výstupu:</p>

<pre>
Set1
inspektor
tovarnik
podporucik
praktikant
&nbsp;
Set2
inspektor
podkoni
tovarnik
stevard
&nbsp;
Union
inspektor
tovarnik
podporucik
praktikant
podkoni
stevard
&nbsp;
Intersetion
inspektor
tovarnik
&nbsp;
Difference set1-set2
podporucik
praktikant
&nbsp;
Difference set2-set1
podkoni
stevard
&nbsp;
Symmetric difference
podporucik
praktikant
podkoni
stevard
</pre>

<p>Přepišme si nyní příklad tak, aby se namísto metod použily přetížené operátory:</p>

<pre>
use std::collections::HashSet;
&nbsp;
fn print_hashset(set: &amp;HashSet&lt;&amp;str&gt;) {
    for item in set {
        println!("{}", item);
    }
}
&nbsp;
fn main() {
    let set1 = ["podporucik", "inspektor", "praktikant", "tovarnik"].iter().cloned().collect();
    let set2 = ["tovarnik", "stevard", "podkoni", "inspektor"].iter().cloned().collect();
&nbsp;
    println!("Set1");
    print_hashset(&amp;set1);
&nbsp;
    println!("\nSet2");
    print_hashset(&amp;set2);
&nbsp;
    println!("\nUnion");
    for item in <strong>&amp;set1 | &amp;set2</strong> {
        println!("{}", item);
    }
&nbsp;
    println!("\nIntersetion");
    for item in <strong>&amp;set1 &amp; &amp;set2</strong> {
        println!("{}", item);
    }
&nbsp;
    println!("\nDifference set1-set2");
    for item in <strong>&amp;set1 - &amp;set2</strong> {
        println!("{}", item);
    }
&nbsp;
    println!("\nDifference set2-set1");
    for item in <strong>&amp;set2 - &amp;set1</strong> {
        println!("{}", item);
    }
&nbsp;
    println!("\nSymmetric difference");
    for item in <strong>&amp;set1 ^ &amp;set2</strong> {
        println!("{}", item);
    }
}
</pre>

<p>Příklad výstupu:</p>

<pre>
Set1
inspektor
praktikant
tovarnik
podporucik
&nbsp;
Set2
stevard
inspektor
podkoni
tovarnik
&nbsp;
Union
inspektor
stevard
podkoni
praktikant
tovarnik
podporucik
&nbsp;
Intersetion
inspektor
tovarnik
&nbsp;
Difference set1-set2
praktikant
podporucik
&nbsp;
Difference set2-set1
stevard
podkoni
&nbsp;
Symmetric difference
stevard
podkoni
praktikant
podporucik
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Implementace pomocí B-stromu</h2>

<p>Pokud kód z&nbsp;předchozího příkladu použijeme, ovšem pro množiny založené
na B-stromech, měly by iterátory vrácené metodami <strong>union()</strong>,
<strong>intersection()</strong>, <strong>difference()</strong> a
<strong>symmetric_difference()</strong> vracet prvky v&nbsp;setříděném
pořadí:</p>

<pre>
use std::collections::BTreeSet;
&nbsp;
fn print_btree_set(set: &amp;BTreeSet&lt;&amp;str&gt;) {
    for item in set {
        println!("{}", item);
    }
}
&nbsp;
fn main() {
    let mut set1 = BTreeSet::new();
    let mut set2 = BTreeSet::new();
&nbsp;
    set1.insert("podporucik");
    set1.insert("inspektor");
    set1.insert("praktikant");
    set1.insert("tovarnik");
&nbsp;
    set2.insert("tovarnik");
    set2.insert("stevard");
    set2.insert("podkoni");
    set2.insert("inspektor");
&nbsp;
    println!("Set1");
    print_btree_set(&amp;set1);
&nbsp;
    println!("\nSet2");
    print_btree_set(&amp;set2);
&nbsp;
    println!("\nUnion");
    for item in set1.union(&amp;set2) {
        println!("{}", item);
    }
&nbsp;
    println!("\nIntersetion");
    for item in set1.intersection(&amp;set2) {
        println!("{}", item);
    }
&nbsp;
    println!("\nDifference set1-set2");
    for item in set1.difference(&amp;set2) {
        println!("{}", item);
    }
&nbsp;
    println!("\nDifference set2-set1");
    for item in set2.difference(&amp;set1) {
        println!("{}", item);
    }
&nbsp;
    println!("\nSymmetric difference");
    for item in set1.symmetric_difference(&amp;set2) {
        println!("{}", item);
    }
}
</pre>

<p>Z&nbsp;výstupu je patrné, že skutečně došlo ke správnému zatřídění prvků:</p>

<pre>
Set1
inspektor
podporucik
praktikant
tovarnik
&nbsp;
Set2
inspektor
podkoni
stevard
tovarnik
&nbsp;
Union
inspektor
podkoni
podporucik
praktikant
stevard
tovarnik
&nbsp;
Intersetion
inspektor
tovarnik
&nbsp;
Difference set1-set2
podporucik
praktikant
&nbsp;
Difference set2-set1
podkoni
stevard
&nbsp;
Symmetric difference
podkoni
podporucik
praktikant
stevard
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Vytvoření množiny z&nbsp;pole</h2>

<p>Poměrně často se setkáme s&nbsp;potřebou vytvořit neměnitelnou množinu.
Vzhledem k&nbsp;tomu, že pro množiny neexistuje vhodná syntaxe konstruktoru,
musíme si vypomoci jiným způsobem, například využitím iterátoru vytvořeného pro
všechny prvky pole. Následující kód získá iterátor pro dané pole, postupně
vytvoří klony jeho prvků a následně z&nbsp;iterátoru vytvoří kolekci.
Povšimněte si toho, že samotná proměnná držící množinu již nemusí být
měnitelná:</p>

<pre>
let množina = [].iter().cloned().collect();
</pre>

<p>Vytvoření množiny z&nbsp;pole lze do zdrojového kódu zařadit velmi
snadno:</p>

<pre>
use std::collections::HashSet;
&nbsp;
fn print_hashset(set: &amp;HashSet&lt;&amp;str&gt;) {
    for item in set {
        println!("{}", item);
    }
}
&nbsp;
fn main() {
    let set1 = <strong>["podporucik", "inspektor", "praktikant", "tovarnik"].iter().cloned().collect()</strong>;
    let set2 = <strong>["tovarnik", "stevard", "podkoni", "inspektor"].iter().cloned().collect()</strong>;
&nbsp;
    println!("Set1");
    print_hashset(&amp;set1);
&nbsp;
    println!("\nSet2");
    print_hashset(&amp;set2);
&nbsp;
    println!("\nUnion");
    for item in set1.union(&amp;set2) {
        println!("{}", item);
    }
&nbsp;
    println!("\nIntersetion");
    for item in set1.intersection(&amp;set2) {
        println!("{}", item);
    }
&nbsp;
    println!("\nDifference set1-set2");
    for item in set1.difference(&amp;set2) {
        println!("{}", item);
    }
&nbsp;
    println!("\nDifference set2-set1");
    for item in set2.difference(&amp;set1) {
        println!("{}", item);
    }
&nbsp;
    println!("\nSymmetric difference");
    for item in set1.symmetric_difference(&amp;set2) {
        println!("{}", item);
    }
}
</pre>

<p>Poznámka: vyzkoušejte si, co se stane, když bude pole obsahovat shodné
prvky.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Vytvoření množiny z&nbsp;vektoru</h2>

<p>Prakticky stejným způsobem se množina vytváří z&nbsp;vektoru, v&nbsp;tomto
případě ale bude překladač vyžadovat přesné určení typu množiny:</p>

<pre>
use std::collections::HashSet;
&nbsp;
fn print_hashset(set: &amp;HashSet&lt;&amp;str&gt;) {
    for item in set {
        println!("{}", item);
    }
}
&nbsp;
fn main() {
    <strong>let set1: HashSet&lt;&amp;str&gt; = vec!["podporucik", "inspektor", "praktikant", "tovarnik"].iter().cloned().collect();</strong>
    <strong>let set2: HashSet&lt;&amp;str&gt; = vec!["tovarnik", "stevard", "podkoni", "inspektor"].iter().cloned().collect();</strong>
&nbsp;
    println!("Set1");
    print_hashset(&amp;set1);
&nbsp;
    println!("\nSet2");
    print_hashset(&amp;set2);
&nbsp;
    println!("\nUnion");
    for item in set1.union(&amp;set2) {
        println!("{}", item);
    }
&nbsp;
    println!("\nIntersetion");
    for item in set1.intersection(&amp;set2) {
        println!("{}", item);
    }
&nbsp;
    println!("\nDifference set1-set2");
    for item in set1.difference(&amp;set2) {
        println!("{}", item);
    }
&nbsp;
    println!("\nDifference set2-set1");
    for item in set2.difference(&amp;set1) {
        println!("{}", item);
    }
&nbsp;
    println!("\nSymmetric difference");
    for item in set1.symmetric_difference(&amp;set2) {
        println!("{}", item);
    }
}
</pre>

<p>Poznámka: opět si vyzkoušejte, co se stane, když bude vektor obsahovat
shodné prvky.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Funkce pro vytvoření množiny z&nbsp;vektoru</h2>

<p>V&nbsp;rámci tréningu si můžeme vyzkoušet vytvořit funkci, která převede
prvky vektoru na množinu. Tato funkce bude obsahovat jediný <i>výraz</i>, jehož
výsledek se bude vracet, takže existují dvě formy zápisu, přičemž je doporučeno
použít druhý způsob (ten neobsahuje středník za výrazem):</p>

<pre>
fn vec2set(v: Vec&lt;&amp;str&gt;) -&gt; HashSet&lt;&amp;str&gt; {
    return v.iter().cloned().collect();
}
</pre>
<pre>
fn vec2set(v: Vec&lt;&amp;str&gt;) -&gt; HashSet&lt;&amp;str&gt; {
    v.iter().cloned().collect()
}
</pre>

<p>Zařazení této funkce do zdrojového kódu programu je snadné:</p>

<pre>
use std::collections::HashSet;
&nbsp;
fn print_hashset(set: &amp;HashSet&lt;&amp;str&gt;) {
    for item in set {
        println!("{}", item);
    }
}
&nbsp;
fn vec2set(v: Vec&lt;&amp;str&gt;) -&gt; HashSet&lt;&amp;str&gt; {
    v.iter().cloned().collect()
}
&nbsp;
fn main() {
    let set1 = vec2set(vec!["podporucik", "inspektor", "praktikant", "tovarnik"]);
    let set2 = vec2set(vec!["tovarnik", "stevard", "podkoni", "inspektor"]);
&nbsp;
    println!("Set1");
    print_hashset(&amp;set1);
&nbsp;
    println!("\nSet2");
    print_hashset(&amp;set2);
&nbsp;
    println!("\nUnion");
    for item in set1.union(&amp;set2) {
        println!("{}", item);
    }
&nbsp;
    println!("\nIntersetion");
    for item in set1.intersection(&amp;set2) {
        println!("{}", item);
    }
&nbsp;
    println!("\nDifference set1-set2");
    for item in set1.difference(&amp;set2) {
        println!("{}", item);
    }
&nbsp;
    println!("\nDifference set2-set1");
    for item in set2.difference(&amp;set1) {
        println!("{}", item);
    }
&nbsp;
    println!("\nSymmetric difference");
    for item in set1.symmetric_difference(&amp;set2) {
        println!("{}", item);
    }
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Použití generické formy funkce <strong>vec2set</strong></h2>

<p>Ve skutečnosti není funkce <strong>vec2set</strong> popsaná v&nbsp;předchozí
kapitole univerzální, protože bude pracovat pouze pro vektory obsahující
řetězce. V&nbsp;případě, že budeme chtít vytvořit univerzální funkci, je nutné
(asi podle očekávání) použít generické typy, v&nbsp;nichž překladači Rustu
zaručíme, že se tato funkce bude volat pouze pro vektory, jejichž prvky
implementují traity <strong>Copy</strong>, <strong>Eq</strong> a
<strong>Hash</strong>. První z&nbsp;těchto traitů je nutný pro volání
<strong>cloned()</strong>, další dva pro přidání prvků do množiny. Traity se
v&nbsp;tomto případě oddělují znakem +:</p>

<pre>
fn vec2set&lt;T: Copy + Eq + Hash&gt;(v: Vec&lt;T&gt;) -&gt; HashSet&lt;T&gt; {
    v.iter().cloned().collect()
}
</pre>

<p>Úplný zdrojový kód může vypadat následovně:</p>

<pre>
use std::collections::HashSet;
use std::hash::Hash;
&nbsp;
fn print_hashset(set: &amp;HashSet&lt;&amp;str&gt;) {
    for item in set {
        println!("{}", item);
    }
}
&nbsp;
fn vec2set&lt;T: Copy + Eq + Hash&gt;(v: Vec&lt;T&gt;) -&gt; HashSet&lt;T&gt; {
    v.iter().cloned().collect()
}
&nbsp;
fn main() {
    let set1 = vec2set(vec!["podporucik", "inspektor", "praktikant", "tovarnik"]);
    let set2 = vec2set(vec!["tovarnik", "stevard", "podkoni", "inspektor"]);
&nbsp;
    println!("Set1");
    print_hashset(&amp;set1);
&nbsp;
    println!("\nSet2");
    print_hashset(&amp;set2);
&nbsp;
    println!("\nUnion");
    for item in set1.union(&amp;set2) {
        println!("{}", item);
    }
&nbsp;
    println!("\nIntersetion");
    for item in set1.intersection(&amp;set2) {
        println!("{}", item);
    }
&nbsp;
    println!("\nDifference set1-set2");
    for item in set1.difference(&amp;set2) {
        println!("{}", item);
    }
&nbsp;
    println!("\nDifference set2-set1");
    for item in set2.difference(&amp;set1) {
        println!("{}", item);
    }
&nbsp;
    println!("\nSymmetric difference");
    for item in set1.symmetric_difference(&amp;set2) {
        println!("{}", item);
    }
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popisované demonstrační příklady byly, podobně jako ve všech
předchozích částech tohoto seriálu, uloženy do Git repositáře dostupného na
adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě bez nutnosti
klonovat celý repositář:</p>

<table>
<tr><th>Příklad</th><th>Odkaz</th></tr>
<tr><td>266_sequences27.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/266_sequences27.rs">https://github.com/tisnik/presentations/blob/master/rust/266_sequences27.rs</a></td></tr>
<tr><td>267_sequences28.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/267_sequences28.rs">https://github.com/tisnik/presentations/blob/master/rust/267_sequences28.rs</a></td></tr>
<tr><td>268_sequences29.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/268_sequences29.rs">https://github.com/tisnik/presentations/blob/master/rust/268_sequences29.rs</a></td></tr>
<tr><td>269_sequences30.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/269_sequences30.rs">https://github.com/tisnik/presentations/blob/master/rust/269_sequences30.rs</a></td></tr>
<tr><td>270_sequences31.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/270_sequences31.rs">https://github.com/tisnik/presentations/blob/master/rust/270_sequences31.rs</a></td></tr>
<tr><td>271_sequences32.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/271_sequences32.rs">https://github.com/tisnik/presentations/blob/master/rust/271_sequences32.rs</a></td></tr>
<tr><td>272_sequences33.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/272_sequences33.rs">https://github.com/tisnik/presentations/blob/master/rust/272_sequences33.rs</a></td></tr>
<tr><td>273_sequences34.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/273_sequences34.rs">https://github.com/tisnik/presentations/blob/master/rust/273_sequences34.rs</a></td></tr>
<tr><td>274_sequences35.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/274_sequences35.rs">https://github.com/tisnik/presentations/blob/master/rust/274_sequences35.rs</a></td></tr>
<tr><td>275_sequences36.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/275_sequences36.rs">https://github.com/tisnik/presentations/blob/master/rust/275_sequences36.rs</a></td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Struct std::collections::HashSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html">https://doc.rust-lang.org/std/collections/struct.HashSet.html</a>
</li>

<li>Struct std::collections::BTreeSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html">https://doc.rust-lang.org/std/collections/struct.BTreeSet.html</a>
</li>

<li>Set (abstract data type)<br />
<a href="https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support">https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support</a>
</li>

<li>Associative array<br />
<a href="https://en.wikipedia.org/wiki/Associative_array">https://en.wikipedia.org/wiki/Associative_array</a>
</li>

<li>Hash Table<br />
<a href="https://en.wikipedia.org/wiki/Hash_table">https://en.wikipedia.org/wiki/Hash_table</a>
</li>

<li>B-tree<br />
<a href="https://en.wikipedia.org/wiki/B-tree">https://en.wikipedia.org/wiki/B-tree</a>
</li>

<li>Pedro Celis: Robin Hood Hashing (naskenované PDF!)<br />
<a href="https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf">https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf</a>
</li>

<li>Robin Hood hashing<br />
<a href="http://codecapsule.com/2013/11/11/robin-hood-hashing/">http://codecapsule.com/2013/11/11/robin-hood-hashing/</a>
</li>

<li>Robin Hood hashing: backward shift deletion<br />
<a href="http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/">http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/</a>
</li>

<li>Module std::collections<br />
<a href="https://doc.rust-lang.org/std/collections/">https://doc.rust-lang.org/std/collections/</a>
</li>

<li>Module std::vec<br />
<a href="https://doc.rust-lang.org/nightly/std/vec/index.html">https://doc.rust-lang.org/nightly/std/vec/index.html</a>
</li>

<li>Struct std::collections::VecDeque<br />
<a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html">https://doc.rust-lang.org/std/collections/struct.VecDeque.html</a>
</li>

<li>Struct std::collections::LinkedList<br />
<a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html">https://doc.rust-lang.org/std/collections/struct.LinkedList.html</a>
</li>

<li>Module std::fmt<br />
<a href="https://doc.rust-lang.org/std/fmt/">https://doc.rust-lang.org/std/fmt/</a>
</li>

<li>Macro std::println<br />
<a href="https://doc.rust-lang.org/std/macro.println.html">https://doc.rust-lang.org/std/macro.println.html</a>
</li>

<li>Enum std::result::Result<br />
<a href="https://doc.rust-lang.org/std/result/enum.Result.html">https://doc.rust-lang.org/std/result/enum.Result.html</a>
</li>

<li>Module std::result<br />
<a href="https://doc.rust-lang.org/std/result/">https://doc.rust-lang.org/std/result/</a>
</li>

<li>Result<br />
<a href="http://rustbyexample.com/std/result.html">http://rustbyexample.com/std/result.html</a>
</li>

<li>Rust stdlib: Option<br />
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">https://doc.rust-lang.org/std/option/enum.Option.html</a>
</li>

<li>Module std::option<br />
<a href="https://doc.rust-lang.org/std/option/index.html">https://doc.rust-lang.org/std/option/index.html</a>
</li>

<li>Rust by example: option<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>Rust by example: if-let<br />
<a href="http://rustbyexample.com/flow_control/if_let.html">http://rustbyexample.com/flow_control/if_let.html</a>
</li>

<li>Rust by example: while let<br />
<a href="http://rustbyexample.com/flow_control/while_let.html">http://rustbyexample.com/flow_control/while_let.html</a>
</li>

<li>Rust by example: Option&lt;i32&gt;<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>An Overview of Macros in Rust<br />
<a href="http://words.steveklabnik.com/an-overview-of-macros-in-rust">http://words.steveklabnik.com/an-overview-of-macros-in-rust</a>
</li>

<li>A Practical Intro to Macros in Rust 1.0<br />
<a href="https://danielkeep.github.io/practical-intro-to-macros.html">https://danielkeep.github.io/practical-intro-to-macros.html</a>
</li>

<li>The Rust Programming Language: macros<br />
<a href="https://doc.rust-lang.org/beta/book/macros.html">https://doc.rust-lang.org/beta/book/macros.html</a>
</li>

<li>Rust by example: 15 macro_rules!<br />
<a href="http://rustbyexample.com/macros.html">http://rustbyexample.com/macros.html</a>
</li>

<li>Primitive Type isize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.isize.html">https://doc.rust-lang.org/nightly/std/primitive.isize.html</a>
</li>

<li>Primitive Type usize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">https://doc.rust-lang.org/nightly/std/primitive.usize.html</a>
</li>

<li>Primitive Type array<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.array.html">https://doc.rust-lang.org/nightly/std/primitive.array.html</a>
</li>

<li>Module std::slice<br />
<a href="https://doc.rust-lang.org/nightly/std/slice/">https://doc.rust-lang.org/nightly/std/slice/</a>
</li>

<li>Rust by Example: 2.3 Arrays and Slices<br />
<a href="http://rustbyexample.com/primitives/array.html">http://rustbyexample.com/primitives/array.html</a>
</li>

<li>What is the difference between Slice and Array (stackoverflow)<br />
<a href="http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array">http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array</a>
</li>

<li>Learning Rust With Entirely Too Many Linked Lists<br />
<a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/">http://cglab.ca/~abeinges/blah/too-many-lists/book/</a>
</li>

<li>Testcase: linked list<br />
<a href="http://rustbyexample.com/custom_types/enum/testcase_linked_list.html">http://rustbyexample.com/custom_types/enum/testcase_linked_list.html</a>
</li>

<li>Operators and Overloading<br />
<a href="https://doc.rust-lang.org/book/operators-and-overloading.html">https://doc.rust-lang.org/book/operators-and-overloading.html</a>
</li>

<li>Module std::ops<br />
<a href="https://doc.rust-lang.org/std/ops/index.html">https://doc.rust-lang.org/std/ops/index.html</a>
</li>

<li>Module std::cmp<br />
<a href="https://doc.rust-lang.org/std/cmp/index.html">https://doc.rust-lang.org/std/cmp/index.html</a>
</li>

<li>Trait std::ops::Add<br />
<a href="https://doc.rust-lang.org/stable/std/ops/trait.Add.html">https://doc.rust-lang.org/stable/std/ops/trait.Add.html</a>
</li>

<li>Trait std::ops::AddAssign<br />
<a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html">https://doc.rust-lang.org/std/ops/trait.AddAssign.html</a>
</li>

<li>Trait std::ops::Drop<br />
<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">https://doc.rust-lang.org/std/ops/trait.Drop.html</a>
</li>

<li>Trait std::cmp::Eq<br />
<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">https://doc.rust-lang.org/std/cmp/trait.Eq.html</a>
</li>

<li>Struct std::boxed::Box<br />
<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">https://doc.rust-lang.org/std/boxed/struct.Box.html</a>
</li>

<li>Explore the ownership system in Rust<br />
<a href="https://nercury.github.io/rust/guide/2015/01/19/ownership.html">https://nercury.github.io/rust/guide/2015/01/19/ownership.html</a>
</li>

<li>Rust's ownership and move semantic<br/>
<a href="http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics">http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics</a>
</li>

<li>Trait std::marker::Copy<br/>
<a href="https://doc.rust-lang.org/stable/std/marker/trait.Copy.html">https://doc.rust-lang.org/stable/std/marker/trait.Copy.html</a>
</li>

<li>Trait std::clone::Clone<br />
<a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html">https://doc.rust-lang.org/stable/std/clone/trait.Clone.html</a>
</li>

<li>The Stack and the Heap<br />
<a href="https://doc.rust-lang.org/book/the-stack-and-the-heap.html">https://doc.rust-lang.org/book/the-stack-and-the-heap.html</a>
</li>

<li>Rust Compare: Pointers &amp; References<br />
<a href="http://www.rust-compare.com/site/pointers.html">http://www.rust-compare.com/site/pointers.html</a>
</li>

<li>Rust Compare: Parameters<br />
<a href="http://www.rust-compare.com/site/params.html">http://www.rust-compare.com/site/params.html</a>
</li>

<li>Why does this compile? Automatic dereferencing?<br />
<a href="https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183">https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183</a>
</li>

<li>Understanding Pointers, Ownership, and Lifetimes in Rust<br />
<a href="http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html">http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html</a>
</li>

<li>Rust lang series episode #25 — pointers (#rust-series)<br />
<a href="https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series">https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series</a>
</li>

<li>Rust - home page<br />
<a href="https://www.rust-lang.org/en-US/">https://www.rust-lang.org/en-US/</a>
</li>

<li>Rust - Frequently Asked Questions<br />
<a href="https://www.rust-lang.org/en-US/faq.html">https://www.rust-lang.org/en-US/faq.html</a>
</li>

<li>Destructuring and Pattern Matching<br />
<a href="https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/">https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/</a>
</li>

<li>The Rust Programming Language<br />
<a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>
</li>

<li>Rust (programming language)<br />
<a href="https://en.wikipedia.org/wiki/Rust_%28programming_language%29">https://en.wikipedia.org/wiki/Rust_%28programming_language%29</a>
</li>

<li>Go - home page<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>Stack Overflow - Most Loved, Dreaded, and Wanted language<br />
<a href="https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted">https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted</a>
</li>

<li>Rust vs Go (dva roky staré hodnocení, od té doby došlo k posunům v obou jazycích)<br />
<a href="http://jaredforsyth.com/2014/03/22/rust-vs-go/">http://jaredforsyth.com/2014/03/22/rust-vs-go/</a>
</li>

<li>Rust vs Go: My experience<br />
<a href="https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/">https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/</a>
</li>

<li>Friends of Rust (Organizations running Rust in production)<br />
<a href="https://www.rust-lang.org/en-US/friends.html">https://www.rust-lang.org/en-US/friends.html</a>
</li>

<li>Rust programs versus C++ g++<br />
<a href="https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp">https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp</a>
</li>

<li>Další benchmarky (nejedná se o reálné příklady &bdquo;ze života&ldquo;)<br />
<a href="https://github.com/kostya/benchmarks">https://github.com/kostya/benchmarks</a>
</li>

<li>Go na Redditu<br />
<a href="https://www.reddit.com/r/golang/">https://www.reddit.com/r/golang/</a>
</li>

<li>Rust vs. Go<br />
<a href="http://vschart.com/compare/rust/vs/go-language">http://vschart.com/compare/rust/vs/go-language</a>
</li>

<li>Abstraction without overhead: traits in Rust<br />
<a href="https://blog.rust-lang.org/2015/05/11/traits.html">https://blog.rust-lang.org/2015/05/11/traits.html</a>
</li>

<li>Method Syntax<br />
<a href="https://doc.rust-lang.org/book/method-syntax.html">https://doc.rust-lang.org/book/method-syntax.html</a>
</li>

<li>Traits in Rust<br />
<a href="https://doc.rust-lang.org/book/traits.html">https://doc.rust-lang.org/book/traits.html</a>
</li>

<li>Functional Programming in Rust - Part 1 : Function Abstraction<br />
<a href="http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/">http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/</a>
</li>

<li>Of the emerging systems languages Rust, D, Go and Nim, which is the strongest language and why?<br />
<a href="https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why">https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why</a>
</li>

<li>Chytré ukazatele (moderní verze jazyka C++) [MSDN]<br />
<a href="https://msdn.microsoft.com/cs-cz/library/hh279674.aspx">https://msdn.microsoft.com/cs-cz/library/hh279674.aspx</a>
</li>

<li>UTF-8 Everywhere<br />
<a href="http://utf8everywhere.org/">http://utf8everywhere.org/</a>
</li>

<li>Rust by Example<br />
<a href="http://rustbyexample.com/">http://rustbyexample.com/</a>
</li>

<li>Rust oficiálně ve Fedoře<br />
<a href="https://mojefedora.cz/rust-oficialne-ve-fedore/">https://mojefedora.cz/rust-oficialne-ve-fedore/</a>
</li>

<li>Resource acquisition is initialization<br />
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization</a>
</li>

<li>TIOBE index (October 2016)<br />
<a href="http://www.tiobe.com/tiobe-index/">http://www.tiobe.com/tiobe-index/</a>
</li>

<li>Porovnání Go, D a Rustu na OpenHubu:<br />
<a href="https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits">https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits</a>
</li>

<li>String Types in Rust<br />
<a href="http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/">http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/</a>
</li>

<li>Trait (computer programming)<br />
<a href="https://en.wikipedia.org/wiki/Trait_%28computer_programming%29">https://en.wikipedia.org/wiki/Trait_%28computer_programming%29</a>
</li>

<li>Type inference<br />
<a href="https://en.wikipedia.org/wiki/Type_inference">https://en.wikipedia.org/wiki/Type_inference</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

