<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Ukazatele v Rustu aneb temná strana Síly 2</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Ukazatele v Rustu aneb temná strana Síly 2</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>I ve dvacáté sedmé části seriálu o programovacím jazyce Rust budeme pokračovat v&nbsp;popisu vlastností ukazatelů (pointerů), které sice v&nbsp;Rustu existují, ale jsou používány s&nbsp;mnohem menší frekvencí, než například v&nbsp;jazyku C.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Přístup ke složkám datové struktury přes ukazatel</a></p>
<p><a href="#k02">2. Změna složek datové struktury ve chvíli, kdy již byla odstraněna z&nbsp;paměti</a></p>
<p><a href="#k03">3. Použití metody <strong>as_ptr()</strong></a></p>
<p><a href="#k04">4. Ukazatelová aritmetika: metoda <strong>offset()</strong></a></p>
<p><a href="#k05">5. Přístup mimo prvky pole přes ukazatel</a></p>
<p><a href="#k06">6. Zápis do paměti přes ukazatel</a></p>
<p><a href="#k07">7. Ukazatel NULL</a></p>
<p><a href="#k08">8. Pokus o přístup do paměti přes ukazatel NULL</a></p>
<p><a href="#k09">9. Operace <strong>std::ptr::write()</strong></a></p>
<p><a href="#k10">10. Chování aplikace při přímém přiřazení nové hodnoty do proměnné</a></p>
<p><a href="#k11">11. Chování aplikace při použití operace <strong>std::ptr::write()</strong></a></p>
<p><a href="#k12">12. Kdy nepoužít ukazatele?</a></p>
<p><a href="#k13">13. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Přístup ke složkám datové struktury přes ukazatel</h2>

<div class="rs-box">
<p>Důležité upozornění: tento článek se, podobně jako článek <a
href="https://www.root.cz/clanky/ukazatele-v-rustu-aneb-temna-strana-sily/">předchozí</a>,
zabývá relativně okrajovou částí programovacího jazyka Rust. V&nbsp;praxi byste
se s&nbsp;použitím ukazatelů v&nbsp;Rustu neměli <a href="#k12">setkat příliš
často</a>, a to především z&nbsp;toho důvodu, že mnohé vlastnosti ukazatelů
jsou nahrazeny jinými prostředky &ndash; <a
href="https://www.root.cz/clanky/rust-predavani-parametru-referenci-elegantni-zpusob-prace-se-sekvencemi/#k02">referencemi</a>,
&bdquo;řezy&ldquo; (slice), <a
href="https://www.root.cz/clanky/pretezovani-operatoru-a-sprava-pameti-v-programovacim-jazyku-rust/#k09">typem
&bdquo;Box&ldquo;</a>, <a
href="https://www.root.cz/clanky/sprava-pameti-v-programovacim-jazyku-rust-s-pocitanim-referenci/#k03">typem
&bdquo;Rc&ldquo;</a> atd. Na druhou stranu je ovšem dobré znát i temné a
nebezpečné zákoutí programovacího jazyka.</p></div>

<p>Vraťme se k&nbsp;demonstračnímu příkladu, který jsme si ukázali na konci <a
href="https://www.root.cz/clanky/ukazatele-v-rustu-aneb-temna-strana-sily/">předchozího
článku</a>. V&nbsp;tomto příkladu je deklarován datový typ (struktura)
<strong>Complex</strong>, k&nbsp;níž existuje i destruktor. Následně vytvoříme
hodnotu tohoto typu a adresu, na níž je hodnota uložena, předáme do ukazatele.
V&nbsp;příkladu je dále ukázáno, že k&nbsp;prvkům datové struktury je možné
přistupovat i přes ukazatel: <strong>(*pointer).real</strong>. Přitom je nutné
mít na paměti, že v&nbsp;Rustu neexistuje obdoba operátoru -&gt; známého
z&nbsp;C a C++:</p>

<pre>
#[derive(Debug)]
struct Complex {
    real: f32,
    imag: f32,
}
&nbsp;
impl Complex {
    fn new(real: f32, imag: f32) -&gt; Complex {
        println!("Constructing complex number: {:}+{:}i", real, imag);
        Complex{real:real, imag:imag}
    }
}
&nbsp;
impl Drop for Complex {
    fn drop(&amp;mut self) {
        println!("Dropping complex number: {:}+{:}i", self.real, self.imag);
    }
}
&nbsp;
fn main() {
    let mut value: Complex = Complex::new(1.0, 2.0);
    let pointer: *mut Complex;
&nbsp;
    pointer = &amp;mut value;
&nbsp;
    println!("{:?}", value);
    unsafe {
        println!("{:?}", *pointer);
    }
&nbsp;
    value.real = 10.0;
    value.imag = 20.0;
&nbsp;
    println!("{:?}", value);
    unsafe {
        println!("{:?}", *pointer);
    }
&nbsp;
    unsafe {
        (*pointer).real = 20.0;
        (*pointer).imag = 40.0;
    }
&nbsp;
    println!("{:?}", value);
&nbsp;
    unsafe {
        println!("{:?}", *pointer);
    }
}
</pre>

<p>Podívejme se, jaké zprávy se vypíšou při spuštění tohoto příkladu:</p>

<pre>
Constructing complex number: 1+2i
Complex { real: 1, imag: 2 }
Complex { real: 1, imag: 2 }
Complex { real: 10, imag: 20 }
Complex { real: 10, imag: 20 }
Complex { real: 20, imag: 40 }
Complex { real: 20, imag: 40 }
Dropping complex number: 20+40i
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Změna složek datové struktury ve chvíli, kdy již byla odstraněna z&nbsp;paměti</h2>

<p>Při použití ukazatelů překladač programovacího jazyka Rust předpokládá, že
programátor přesně ví, co dělá, takže se neprovádí prakticky žádné kontroly
životnosti/viditelnost proměnných. V&nbsp;následujícím příkladu má proměnná
<strong>value</strong> omezenou živostnost na &bdquo;svůj&ldquo; blok {},
zatímco ukazatel nazvaný <strong>pointer</strong> k&nbsp;proměnné přistupuje i
ve chvíli, kdy již byla opuštěna oblast její platnosti (to bude patrné po
spuštění aplikace):</p>

<pre>
#[derive(Debug)]
struct Complex {
    real: f32,
    imag: f32,
}
&nbsp;
impl Complex {
    fn new(real: f32, imag: f32) -&gt; Complex {
        println!("Constructing complex number: {:}+{:}i", real, imag);
        Complex{real:real, imag:imag}
    }
}
&nbsp;
impl Drop for Complex {
    fn drop(&amp;mut self) {
        println!("Dropping complex number: {:}+{:}i", self.real, self.imag);
    }
}
&nbsp;
fn main() {
    let pointer: *mut Complex;
&nbsp;
    {
        let mut value: Complex = Complex::new(1.0, 2.0);
        pointer = &amp;mut value;
&nbsp;
        println!("{:?}", value);
        unsafe {
            println!("{:?}", *pointer);
        }
&nbsp;
        value.real = 10.0;
        value.imag = 20.0;
&nbsp;
        println!("{:?}", value);
        unsafe {
            println!("{:?}", *pointer);
        }
&nbsp;
        unsafe {
            (*pointer).real = 20.0;
            (*pointer).imag = 40.0;
        }
        println!("{:?}", value);
        unsafe {
            println!("{:?}", *pointer);
        }
    }
&nbsp;
<strong>    // !!!</strong>
<strong>    unsafe {</strong>
<strong>        (*pointer).real = -1.1;</strong>
<strong>        (*pointer).imag = -2.2;</strong>
<strong>        println!("{:?}", *pointer);</strong>
<strong>    }</strong>
}
</pre>

<p>Velmi zajímavé věci nastanou při spuštění aplikace. Povšimněte si především
toho, že skutečně vypršela oblast viditelnosti proměnné typu Complex a dokonce
byl zavolán její destruktor. Teprve poté jsme přes ukazatel zapsali do paměti,
která ovšem již proměnné nepatří! V&nbsp;tomto konkrétním případě sice nedošlo
k&nbsp;pádu aplikace (což souvisí se způsobem alokace zásobníkových rámců), ale
samozřejmě se jedná o sémanticky špatně napsaný program:</p>

<pre>
Constructing complex number: 1+2i
Complex { real: 1, imag: 2 }
Complex { real: 1, imag: 2 }
Complex { real: 10, imag: 20 }
Complex { real: 10, imag: 20 }
Complex { real: 20, imag: 40 }
Complex { real: 20, imag: 40 }
<strong>Dropping complex number: 20+40i</strong>
Complex { real: -1.1, imag: -2.2 }
</pre>

<p>Představte si navíc tento (sémanticky taktéž chybný) příklad, který opět
půjde přeložit:</p>

<pre>
fn get_ptr_to_complex() -&gt; *mut Complex {
    let mut value: Complex = Complex::new(1.0, 2.0);
    println!("{:?}", value);
    return &amp;mut value;
}
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Použití metody <strong>as_ptr()</strong></h2>

<p>U některých typů je možné získat ukazatel na hodnotu daného typu pomocí
metody <strong>as_ptr()</strong>. Z&nbsp;datových typů, s&nbsp;nimiž se často
setkáte, se jedná především o řetězce (<strong>str</strong>) a řezy poli
(<strong>slice</strong>). Vzhledem k&nbsp;tomu, že v&nbsp;naprosté většině
případů dokáže překadač Rustu automaticky volat metody pro
<strong>slice</strong> přímo nad zdrojovými poli (pro které je řez vytvořen),
je možné metodu <strong>as_ptr()</strong> volat i pro celé pole:</p>

<pre>
    let array: [i32; 5] = [1, 2, 3, 4, 5];
&nbsp;
    let pointer: *const i32 = array.<strong>as_ptr()</strong>;
&nbsp;
    println!("{:?}", array);
</pre>

<p>Poznámka: ve skutečnosti je řez/slice interně reprezentován právě ukazatelem
+ počtem prvků.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Ukazatelová aritmetika: metoda <strong>offset()</strong></h2>

<p>Oproti programovacímu jazyku C nejsou v&nbsp;Rustu některé operace
s&nbsp;ukazateli prováděny přes &bdquo;klasickou&ldquo; ukazatelovou aritmetiku
(přičtení offsetu k&nbsp;ukazateli přetíženým operátorem + atd.), ovšem namísto
toho je možné použít metodu <strong>offset()</strong>, která vypočte offset na
základě datového typu ukazatele &ndash; jinými slovy pokud se jedná o ukazatel
na hodnotu typu i8 nebo pole i8, bude offet použit přímo, u typu i32 bude
offset vynásoben čtyřmi, protože jeden prvek i32 zabírá v&nbsp;paměti čtyři
bajty. Podívejme se na jednoduchý příklad, v&nbsp;němž se vytvoří pole
s&nbsp;pěti prvky typu i32 a následně se přistoupí k&nbsp;prvnímu prvku přímo
přes ukazatel, dále ke stejnému prvku přes offset (nulový) a poté ke druhému
prvku pole:</p>

<pre>
fn main() {
    let array: [i32; 5] = [1, 2, 3, 4, 5];
&nbsp;
    let pointer: *const i32 = array.<strong>as_ptr()</strong>;
&nbsp;
    println!("{:?}", array);
    unsafe {
        println!("{}", <strong>*pointer</strong>);
        println!("{}", <strong>*pointer.offset(0)</strong>);
        println!("{}", <strong>*pointer.offset(1)</strong>);
    }
}
</pre>

<p>Po překladu a spuštění by se mělo vypsat:</p>

<pre>
[1, 2, 3, 4, 5]
1
1
2
</pre>

<p>Typ ukazatele se odvodí automaticky, takže ho nemusíme explicitně
zapisovat:</p>

<pre>
fn main() {
    let array: [i32; 5] = [1, 2, 3, 4, 5];
&nbsp;
    let pointer = array.<strong>as_ptr()</strong>;
&nbsp;
    println!("{:?}", array);
    unsafe {
        println!("{}", <strong>*pointer</strong>);
        println!("{}", <strong>*pointer.offset(0)</strong>);
        println!("{}", <strong>*pointer.offset(1)</strong>);
    }
}
</pre>

<p>Ukazatel ovšem můžeme získat například i pro druhý prvek pole, čímž se
situace změní, protože offsety budou počítány relativně k&nbsp;tomuto prvku.
Zde můžeme použít záporného offsetu k&nbsp;přístupu do předchozího prvku:</p>

<pre>
fn main() {
    let array: [i32; 5] = [1, 2, 3, 4, 5];
&nbsp;
    let pointer: *const i32 = <strong>&amp;array[1] as *const i32</strong>;
&nbsp;
    println!("{:?}", array);
    unsafe {
        println!("{}", <strong>*pointer</strong>);
        println!("{}", <strong>*pointer.offset(-1)</strong>);
        println!("{}", <strong>*pointer.offset(1)</strong>);
    }
}
</pre>

<p>Po překladu a spuštění by se mělo vypsat:</p>

<pre>
[1, 2, 3, 4, 5]
2
1
3
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Přístup mimo prvky pole přes ukazatel</h2>

<p>Pravděpodobně jste si povšimli, že metodu <strong>offset()</strong> voláme
v&nbsp;bloku <strong>unsafe</strong>. To je vyžadováno překladačem z&nbsp;toho
prostého důvodu, že není (a obecně ani nemůže být) prováděna žádná kontrola,
jestli přes offset stále přistupujeme k&nbsp;platným adresám či zda je offset
zadán špatně. V&nbsp;následujícím programu hned na třech místech přistupujeme
do paměti, která nám vlastně nepatří:</p>

<pre>
fn main() {
    let array: [i32; 5] = [1, 2, 3, 4, 5];
&nbsp;
    let pointer: *const i32 = &amp;array[0] as *const i32;
&nbsp;
    println!("{:?}", array);
    unsafe {
        println!("{}", *pointer);
        println!("{}", *pointer.offset(1));
&nbsp;
        // !!!
        println!("{}", <strong>*pointer.offset(10)</strong>);
&nbsp;
        // !!!
        println!("{}", <strong>*pointer.offset(-1)</strong>);
&nbsp;
        // !!!
        println!("{}", <strong>*pointer.offset(-10)</strong>);
    }
}
</pre>

<p>V&nbsp;mém případě se program podařilo spustit bez segfaultu (což však není
zaručeno), ovšem samozřejmě přečteme pseudonáhodné hodnoty:</p>

<pre>
[1, 2, 3, 4, 5]
1
2
32678
1808587265
0
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Zápis do paměti přes ukazatel</h2>

<p>Přes metodu <strong>offset()</strong> získáme vlastně jen jiný ukazatel,
takže můžeme provádět i nepřímý zápis. V&nbsp;následujícím příkladu se nejdříve
vypíšou původní hodnoty pětiprvkového pole, následně se dva prvky změní, a to
nepřímo přes ukazatel a posléze se vypíše nový obsah pole. Samozřejmě i zápis
přes ukazatel a výpočet offsetu musí být umístěn v&nbsp;bloku
<strong>unsafe</strong>:</p>

<pre>
fn main() {
    let mut array: [i32; 5] = [1, 2, 3, 4, 5];
&nbsp;
    let pointer: *mut i32 = array.as_mut_ptr();
&nbsp;
    println!("{:?}", array);
    unsafe {
        *pointer = 100;
        *pointer.offset(2) = 200;
    }
    println!("{:?}", array);
}
</pre>

<p>Příklad výstupu:</p>

<pre>
[1, 2, 3, 4, 5]
[100, 2, 200, 4, 5]
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Ukazatel NULL</h2>

<p>V&nbsp;programovacím jazyku Rust je možné pracovat i s&nbsp;ukazatelem
obsahujícím speciální hodnotu NULL. Ta se vytváří jednoduše &ndash; funkcí
<strong>ptr::null()</strong> pro ukazatele na konstantní hodnoty
popř.&nbsp;funkcí <strong>ptr::null_mut()</strong> pro ukazatele na hodnoty
měnitelné. Použití těchto funkcí je snadné:</p>

<pre>
use std::ptr;
&nbsp;
fn main() {
    let pointer: *const i32 = ptr::null();
&nbsp;
    println!("{:p}", pointer);
}
</pre>

<p>Příklad výpisu asi skalní céčkaře nepřekvapí:</p>

<pre>
0x0
</pre>

<p>Inicializace ukazatele na měnitelnou hodnotu:</p>

<pre>
use std::ptr;
&nbsp;
fn main() {
    let pointer: *mut i32 = ptr::null_mut();
&nbsp;
    println!("{:p}", pointer);
}
</pre>

<p>Příklad výpisu (skutečně se zde jedná o stejnou adresu), ovšem její typ je
odlišný:</p>

<pre>
0x0
</pre>

<p>Pokud budeme chtít ukazatel sice inicializovat na hodnotu NULL, ale později
adresu změnit, musíme deklarovat měnitelnou (mutable) proměnnou:</p>

<pre>
use std::ptr;
&nbsp;
fn main() {
    let mut pointer: *const i32 = ptr::null();
&nbsp;
    println!("{:p}", pointer);
&nbsp;
    let value: i32 = 42;
    pointer = &value;
&nbsp;
    println!("{:p}", pointer);
}
</pre>

<p>Příklad výpisu:</p>

<pre>
0x0
0x7fff2aab8c1c
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Pokus o přístup do paměti přes ukazatel NULL</h2>

<p>Přístup do paměti přes ukazatel nastavený na NULL je sice možný &ndash;
překladač takovou konstrukci nebude detekovat ani ji nebude hlásit jako chybu
&ndash; ale na všech moderních 32bitových a 64bitových architekturách vždy
dojde k&nbsp;pádu aplikace v&nbsp;runtime (což je asi jediné rozumné chování).
Otestování je snadné.</p>

<p>Čtení:</p>

<pre>
use std::ptr;
&nbsp;
fn main() {
    let pointer: *const i32 = <strong>ptr::null()</strong>;
&nbsp;
    println!("{:p}", pointer);
&nbsp;
    unsafe {
        println!("{}", <strong>*pointer</strong>);
    }
}
</pre>

<p>Jedna z&nbsp;mála možností, jak v&nbsp;Rustu dosáhnout segfaultu:</p>

<pre>
$ <strong>./test</strong>
0x0
Segmentation fault
$ <strong>echo $?</strong>
139
</pre>

<p>Zápis:</p>

<pre>
use std::ptr;
&nbsp;
fn main() {
    let pointer: *mut i32 = <strong>ptr::null_mut()</strong>;
&nbsp;
    println!("{:p}", pointer);
&nbsp;
    unsafe {
        <strong>*pointer = 42</strong>;
    }
}
</pre>

<p>Nahlásí se stejná chyba:</p>

<pre>
$ <strong>./test</strong>
0x0
Segmentation fault
$ <strong>echo $?</strong>
139
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Operace <strong>std::ptr::write()</strong></h2>

<p>Další vyloženě nebezpečnou operací je operace představována funkcí
<strong>std::ptr::write()</strong>. Tato funkce provádí zdánlivě banální
operaci &ndash; zápis nové hodnoty na zadanou adresu:</p>

<pre>
use std::ptr;
&nbsp;
fn main() {
    let mut x = 0;
    let pointer: *mut i32 = &amp;mut x;
    let y = 42;
&nbsp;
    println!("{:p}", pointer);
    println!("{}", x);
&nbsp;
    unsafe {
        ptr::write(pointer, y);
    }
    println!("{}", x);
}
</pre>

<p>Ve skutečnosti se však provede <strong>jen</strong> přepis staré hodnoty
hodnotou novou, ale již se neprovede korektní zrušení staré hodnoty: nezavolá
se destruktor atd. Proto je nutné tuto operaci použít skutečně jen ve chvíli,
kdy víme co děláme.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Chování aplikace při přímém přiřazení nové hodnoty do proměnné</h2>

<p>Podívejme se nyní, jak se aplikace chová ve chvíli, kdy do proměnné
přiřadíme jinou hodnotu (k&nbsp;tomu se vůbec nepoužívají ukazatele):</p>

<pre>
use std::ptr;
&nbsp;
#[derive(Debug)]
struct Complex {
    real: f32,
    imag: f32,
}
&nbsp;
impl Complex {
    fn new(real: f32, imag: f32) -&gt; Complex {
        println!("Constructing complex number: {:}+{:}i", real, imag);
        Complex{real:real, imag:imag}
    }
}
&nbsp;
impl Drop for Complex {
    fn drop(&amp;mut self) {
        println!("Dropping complex number: {:}+{:}i", self.real, self.imag);
    }
}
&nbsp;
fn main() {
    let mut value: Complex = Complex::new(1.0, 2.0);
    let value2: Complex = Complex::new(100.0, 200.0);
    let pointer: *mut Complex = &amp;mut value;
&nbsp;
    println!("{:p}", pointer);
    println!("{:?}", value);
&nbsp;
    value = value2;
    println!("{:p}", pointer);
    println!("{:?}", value);
}
</pre>

<p>Podle očekávání získáme následující výsledek &ndash; jsou zkonstruována dvě
komplexní čísla a tudíž se taktéž zavolají dva destruktory ve chvíli, kdy končí
životnost hodnot:</p>

<pre>
Constructing complex number: 1+2i
Constructing complex number: 100+200i
0x7fffe54b4658
Complex { real: 1, imag: 2 }
Dropping complex number: 1+2i
0x7fffe54b4658
Complex { real: 100, imag: 200 }
Dropping complex number: 100+200i
</pre>

<p>Podobně tomu bude ve chvíli, kdy upravíme funkci <strong>main()</strong>
tak, aby se přiřazení provedlo přes ukazatel:</p>

<pre>
fn main() {
    let mut value: Complex = Complex::new(1.0, 2.0);
    let value2: Complex = Complex::new(100.0, 200.0);
    let pointer: *mut Complex = &amp;mut value;
&nbsp;
    println!("{:p}", pointer);
    println!("{:?}", value);
&nbsp;
    unsafe {
        *pointer = value2;
    }
&nbsp;
    println!("{:p}", pointer);
    println!("{:?}", value);
}
</pre>

<p>Překladač Rustu je v&nbsp;tomto případě dost chytrý na to, aby poznal, že
přiřazením v&nbsp;bloku <strong>unsafe</strong> končí životnost prvního
komplexního čísla.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Chování aplikace při použití operace <strong>std::ptr::write()</strong></h2>

<p>Třetí modifikace příkladu spočívá v&nbsp;použití
<strong>std::ptr::write()</strong> namísto přiřazení:</p>

<pre>
use std::ptr;
&nbsp;
#[derive(Debug)]
struct Complex {
    real: f32,
    imag: f32,
}
&nbsp;
impl Complex {
    fn new(real: f32, imag: f32) -&gt; Complex {
        println!("Constructing complex number: {:}+{:}i", real, imag);
        Complex{real:real, imag:imag}
    }
}
&nbsp;
impl Drop for Complex {
    fn drop(&amp;mut self) {
        println!("Dropping complex number: {:}+{:}i", self.real, self.imag);
    }
}
&nbsp;
fn main() {
    let mut value: Complex = Complex::new(1.0, 2.0);
    let value2: Complex = Complex::new(100.0, 200.0);
    let pointer: *mut Complex = &amp;mut value;
&nbsp;
    println!("{:p}", pointer);
    println!("{:?}", value);
&nbsp;
    unsafe {
        <strong>ptr::write(pointer, value2)</strong>;
    }
&nbsp;
    println!("{:p}", pointer);
    println!("{:?}", value);
}
</pre>

<p>Zde je již chování diametrálně odlišné, neboť se <strong>nezavolá</strong>
destruktor pro první komplexní číslo!</p>

<pre>
Constructing complex number: 1+2i
Constructing complex number: 100+200i
0x7fff05ac3478
Complex { real: 1, imag: 2 }
0x7fff05ac3478
Complex { real: 100, imag: 200 }
Dropping complex number: 100+200i
</pre>

<p>Tuto operaci má tedy smysl použít jen v&nbsp;několika ojedinělých případech,
kdy přesně víme, že nechceme volat destruktory staré hodnoty.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Kdy nepoužít ukazatele?</h2>

<p>Jak již bylo naznačeno v&nbsp;úvodní kapitole, používají se ukazatele
v&nbsp;Rustu jen v&nbsp;relativně malém množství případů, typicky při nutnosti
volání nativních funkcí přes FFI či při implementaci efektivních datových
struktur (viz zdrojové kódy pro Vec). Důležitější je pro céčkaře vědět, kdy
naopak ukazatele nepoužít, protože Rust nabízí lepší (typicky bezpečnější)
řešení:</p>

<ul>

<li>Pokud potřebujete předat parametr do funkce odkazem a ne hodnotou, použijte
<a
href="https://www.root.cz/clanky/rust-predavani-parametru-referenci-elegantni-zpusob-prace-se-sekvencemi/#k02">referenci</a>.</li>

<li>Pokud potřebujete alokovat strukturu na haldě, použijte <a
href="https://www.root.cz/clanky/pretezovani-operatoru-a-sprava-pameti-v-programovacim-jazyku-rust/#k09">typ
Box</a>. Rust si sám ohlídá viditelnost/životnost struktury.</li>

<li>Pokud navíc potřebujete automatickou správu paměti s&nbsp;počítáním
referencí, je k&nbsp;dispozici <a
href="https://www.root.cz/clanky/sprava-pameti-v-programovacim-jazyku-rust-s-pocitanim-referenci/#k03">typ
Rc a Arc</a>.</li>

<li>Někdy se v&nbsp;C používají ukazatele proto, aby se mohla vrátit
&bdquo;žádná hodnota&ldquo; (tedy NULL) nebo &bdquo;chyba&ldquo; (většinou
taktéž NULL). V&nbsp;takovém případe je mnohem lepší použít typ <a
href="https://www.root.cz/clanky/datovy-typ-option-v-programovacim-jazyku-rust/">Option</a>
nebo <a
href="https://www.root.cz/clanky/reakce-na-chyby-v-programovacim-jazyku-rust/#k03">Result</a>
(liší se především sémantikou)</li>

</ul>



<p><a name="k13"></a></p>
<h2 id="k13">13. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popisované demonstrační příklady byly, ostatně podobně jako ve
všech předchozích částech <a
href="https://www.root.cz/serialy/programovaci-jazyk-rust/">tohoto seriálu</a>,
uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě
bez nutnosti klonovat celý repositář:</p>

<table>
<tr><th>Příklad</th><th>Adresa</th></tr>
<tr><td>pointers05.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers05.rs">https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers05.rs</a></td></tr>
<tr><td>pointers06.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers06.rs">https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers06.rs</a></td></tr>
<tr><td>pointers07.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers07.rs">https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers07.rs</a></td></tr>
<tr><td>pointers08.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers08.rs">https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers08.rs</a></td></tr>
<tr><td>pointers09.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers09.rs">https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers09.rs</a></td></tr>
<tr><td>pointers10.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers10.rs">https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers10.rs</a></td></tr>
<tr><td>pointers11.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers11.rs">https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers11.rs</a></td></tr>
<tr><td>pointers12.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers12.rs">https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers12.rs</a></td></tr>
<tr><td>pointers13.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers13.rs">https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers13.rs</a></td></tr>
<tr><td>pointers14.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers14.rs">https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers14.rs</a></td></tr>
<tr><td>pointers15.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers15.rs">https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers15.rs</a></td></tr>
<tr><td>pointers16.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers16.rs">https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers16.rs</a></td></tr>
<tr><td>pointers17.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers17.rs">https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers17.rs</a></td></tr>
<tr><td>pointers18.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers18.rs">https://github.com/tisnik/presentations/blob/master/rust/pointers/pointers18.rs</a></td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>The Rustonomicon: The Dark Arts of Advanced and Unsafe Rust Programming<br />
<a href="https://doc.rust-lang.org/nomicon/">https://doc.rust-lang.org/nomicon/</a>
</li>

<li>Primitive Type pointer<br />
<a href="https://doc.rust-lang.org/std/primitive.pointer.html">https://doc.rust-lang.org/std/primitive.pointer.html</a>
</li>

<li>Cargo: správce projektů a balíčků pro programovací jazyk Rust<br />
<a href="https://mojefedora.cz/cargo-spravce-projektu-a-balicku-pro-programovaci-jazyk-rust/">https://mojefedora.cz/cargo-spravce-projektu-a-balicku-pro-programovaci-jazyk-rust/</a>
</li>

<li>Network Communication and Serialization in Rust<br />
<a href="https://www.safaribooksonline.com/blog/2014/01/28/network-communication-serialization-rust/">https://www.safaribooksonline.com/blog/2014/01/28/network-communication-serialization-rust/</a>
</li>

<li>Crate bincode<br />
<a href="http://tyoverby.com/bincode/bincode/index.html">http://tyoverby.com/bincode/bincode/index.html</a>
</li>

<li>Struct std::fs::File<br />
<a href="https://doc.rust-lang.org/std/fs/struct.File.html">https://doc.rust-lang.org/std/fs/struct.File.html</a>
</li>

<li>Trait std::io::Seek<br />
<a href="https://doc.rust-lang.org/std/io/trait.Seek.html">https://doc.rust-lang.org/std/io/trait.Seek.html</a>
</li>

<li>Trait std::io::Read<br />
<a href="https://doc.rust-lang.org/std/io/trait.Read.html">https://doc.rust-lang.org/std/io/trait.Read.html</a>
</li>

<li>Trait std::io::Write<br />
<a href="https://doc.rust-lang.org/std/io/trait.Write.html">https://doc.rust-lang.org/std/io/trait.Write.html</a>
</li>

<li>Trait std::io::BufRead<br />
<a href="https://doc.rust-lang.org/std/io/trait.BufRead.html">https://doc.rust-lang.org/std/io/trait.BufRead.html</a>
</li>

<li>Module std::io::prelude<br />
<a href="https://doc.rust-lang.org/std/io/prelude/index.html">https://doc.rust-lang.org/std/io/prelude/index.html</a>
</li>

<li>std::net::IpAddr<br />
<a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">https://doc.rust-lang.org/std/net/enum.IpAddr.html</a>
</li>

<li>std::net::Ipv4Addr<br />
<a href="https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html">https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html</a>
</li>

<li>std::net::Ipv6Addr<br />
<a href="https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html">https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html</a>
</li>

<li>TcpListener<br />
<a href="https://doc.rust-lang.org/std/net/struct.TcpListener.html">https://doc.rust-lang.org/std/net/struct.TcpListener.html</a>
</li>

<li>TcpStream<br />
<a href="https://doc.rust-lang.org/std/net/struct.TcpStream.html">https://doc.rust-lang.org/std/net/struct.TcpStream.html</a>
</li>

<li>Binary heap (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Binary_heap">https://en.wikipedia.org/wiki/Binary_heap</a>
</li>

<li>Binární halda (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_halda">https://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_halda</a>
</li>

<li>Halda (datová struktura)<br />
<a href="https://cs.wikipedia.org/wiki/Halda_%28datov%C3%A1_struktura%29">https://cs.wikipedia.org/wiki/Halda_%28datov%C3%A1_struktura%29</a>
</li>

<li>Struct std::collections::HashSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html">https://doc.rust-lang.org/std/collections/struct.HashSet.html</a>
</li>

<li>Struct std::collections::BTreeSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html">https://doc.rust-lang.org/std/collections/struct.BTreeSet.html</a>
</li>

<li>Struct std::collections::BinaryHeap<br />
<a href="https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html">https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html</a>
</li>

<li>Set (abstract data type)<br />
<a href="https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support">https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support</a>
</li>

<li>Associative array<br />
<a href="https://en.wikipedia.org/wiki/Associative_array">https://en.wikipedia.org/wiki/Associative_array</a>
</li>

<li>Hash Table<br />
<a href="https://en.wikipedia.org/wiki/Hash_table">https://en.wikipedia.org/wiki/Hash_table</a>
</li>

<li>B-tree<br />
<a href="https://en.wikipedia.org/wiki/B-tree">https://en.wikipedia.org/wiki/B-tree</a>
</li>

<li>Pedro Celis: Robin Hood Hashing (naskenované PDF!)<br />
<a href="https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf">https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf</a>
</li>

<li>Robin Hood hashing<br />
<a href="http://codecapsule.com/2013/11/11/robin-hood-hashing/">http://codecapsule.com/2013/11/11/robin-hood-hashing/</a>
</li>

<li>Robin Hood hashing: backward shift deletion<br />
<a href="http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/">http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/</a>
</li>

<li>Module std::collections<br />
<a href="https://doc.rust-lang.org/std/collections/">https://doc.rust-lang.org/std/collections/</a>
</li>

<li>Module std::vec<br />
<a href="https://doc.rust-lang.org/nightly/std/vec/index.html">https://doc.rust-lang.org/nightly/std/vec/index.html</a>
</li>

<li>Struct std::collections::VecDeque<br />
<a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html">https://doc.rust-lang.org/std/collections/struct.VecDeque.html</a>
</li>

<li>Struct std::collections::LinkedList<br />
<a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html">https://doc.rust-lang.org/std/collections/struct.LinkedList.html</a>
</li>

<li>Module std::fmt<br />
<a href="https://doc.rust-lang.org/std/fmt/">https://doc.rust-lang.org/std/fmt/</a>
</li>

<li>Macro std::println<br />
<a href="https://doc.rust-lang.org/std/macro.println.html">https://doc.rust-lang.org/std/macro.println.html</a>
</li>

<li>Enum std::result::Result<br />
<a href="https://doc.rust-lang.org/std/result/enum.Result.html">https://doc.rust-lang.org/std/result/enum.Result.html</a>
</li>

<li>Module std::result<br />
<a href="https://doc.rust-lang.org/std/result/">https://doc.rust-lang.org/std/result/</a>
</li>

<li>Result<br />
<a href="http://rustbyexample.com/std/result.html">http://rustbyexample.com/std/result.html</a>
</li>

<li>Rust stdlib: Option<br />
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">https://doc.rust-lang.org/std/option/enum.Option.html</a>
</li>

<li>Module std::option<br />
<a href="https://doc.rust-lang.org/std/option/index.html">https://doc.rust-lang.org/std/option/index.html</a>
</li>

<li>Rust by example: option<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>Rust by example: if-let<br />
<a href="http://rustbyexample.com/flow_control/if_let.html">http://rustbyexample.com/flow_control/if_let.html</a>
</li>

<li>Rust by example: while let<br />
<a href="http://rustbyexample.com/flow_control/while_let.html">http://rustbyexample.com/flow_control/while_let.html</a>
</li>

<li>Rust by example: Option&lt;i32&gt;<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>An Overview of Macros in Rust<br />
<a href="http://words.steveklabnik.com/an-overview-of-macros-in-rust">http://words.steveklabnik.com/an-overview-of-macros-in-rust</a>
</li>

<li>A Practical Intro to Macros in Rust 1.0<br />
<a href="https://danielkeep.github.io/practical-intro-to-macros.html">https://danielkeep.github.io/practical-intro-to-macros.html</a>
</li>

<li>The Rust Programming Language: macros<br />
<a href="https://doc.rust-lang.org/beta/book/macros.html">https://doc.rust-lang.org/beta/book/macros.html</a>
</li>

<li>Rust by example: 15 macro_rules!<br />
<a href="http://rustbyexample.com/macros.html">http://rustbyexample.com/macros.html</a>
</li>

<li>Primitive Type isize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.isize.html">https://doc.rust-lang.org/nightly/std/primitive.isize.html</a>
</li>

<li>Primitive Type usize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">https://doc.rust-lang.org/nightly/std/primitive.usize.html</a>
</li>

<li>Primitive Type array<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.array.html">https://doc.rust-lang.org/nightly/std/primitive.array.html</a>
</li>

<li>Module std::slice<br />
<a href="https://doc.rust-lang.org/nightly/std/slice/">https://doc.rust-lang.org/nightly/std/slice/</a>
</li>

<li>Rust by Example: 2.3 Arrays and Slices<br />
<a href="http://rustbyexample.com/primitives/array.html">http://rustbyexample.com/primitives/array.html</a>
</li>

<li>What is the difference between Slice and Array (stackoverflow)<br />
<a href="http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array">http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array</a>
</li>

<li>Learning Rust With Entirely Too Many Linked Lists<br />
<a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/">http://cglab.ca/~abeinges/blah/too-many-lists/book/</a>
</li>

<li>Testcase: linked list<br />
<a href="http://rustbyexample.com/custom_types/enum/testcase_linked_list.html">http://rustbyexample.com/custom_types/enum/testcase_linked_list.html</a>
</li>

<li>Operators and Overloading<br />
<a href="https://doc.rust-lang.org/book/operators-and-overloading.html">https://doc.rust-lang.org/book/operators-and-overloading.html</a>
</li>

<li>Module std::ops<br />
<a href="https://doc.rust-lang.org/std/ops/index.html">https://doc.rust-lang.org/std/ops/index.html</a>
</li>

<li>Module std::cmp<br />
<a href="https://doc.rust-lang.org/std/cmp/index.html">https://doc.rust-lang.org/std/cmp/index.html</a>
</li>

<li>Trait std::ops::Add<br />
<a href="https://doc.rust-lang.org/stable/std/ops/trait.Add.html">https://doc.rust-lang.org/stable/std/ops/trait.Add.html</a>
</li>

<li>Trait std::ops::AddAssign<br />
<a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html">https://doc.rust-lang.org/std/ops/trait.AddAssign.html</a>
</li>

<li>Trait std::ops::Drop<br />
<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">https://doc.rust-lang.org/std/ops/trait.Drop.html</a>
</li>

<li>Trait std::cmp::Eq<br />
<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">https://doc.rust-lang.org/std/cmp/trait.Eq.html</a>
</li>

<li>Struct std::boxed::Box<br />
<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">https://doc.rust-lang.org/std/boxed/struct.Box.html</a>
</li>

<li>Explore the ownership system in Rust<br />
<a href="https://nercury.github.io/rust/guide/2015/01/19/ownership.html">https://nercury.github.io/rust/guide/2015/01/19/ownership.html</a>
</li>

<li>Rust's ownership and move semantic<br/>
<a href="http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics">http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics</a>
</li>

<li>Trait std::marker::Copy<br/>
<a href="https://doc.rust-lang.org/stable/std/marker/trait.Copy.html">https://doc.rust-lang.org/stable/std/marker/trait.Copy.html</a>
</li>

<li>Trait std::clone::Clone<br />
<a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html">https://doc.rust-lang.org/stable/std/clone/trait.Clone.html</a>
</li>

<li>The Stack and the Heap<br />
<a href="https://doc.rust-lang.org/book/the-stack-and-the-heap.html">https://doc.rust-lang.org/book/the-stack-and-the-heap.html</a>
</li>

<li>Rust Compare: Pointers &amp; References<br />
<a href="http://www.rust-compare.com/site/pointers.html">http://www.rust-compare.com/site/pointers.html</a>
</li>

<li>Rust Compare: Parameters<br />
<a href="http://www.rust-compare.com/site/params.html">http://www.rust-compare.com/site/params.html</a>
</li>

<li>Why does this compile? Automatic dereferencing?<br />
<a href="https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183">https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183</a>
</li>

<li>Understanding Pointers, Ownership, and Lifetimes in Rust<br />
<a href="http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html">http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html</a>
</li>

<li>Rust lang series episode #25 — pointers (#rust-series)<br />
<a href="https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series">https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series</a>
</li>

<li>Rust - home page<br />
<a href="https://www.rust-lang.org/en-US/">https://www.rust-lang.org/en-US/</a>
</li>

<li>Rust - Frequently Asked Questions<br />
<a href="https://www.rust-lang.org/en-US/faq.html">https://www.rust-lang.org/en-US/faq.html</a>
</li>

<li>Destructuring and Pattern Matching<br />
<a href="https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/">https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/</a>
</li>

<li>The Rust Programming Language<br />
<a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>
</li>

<li>Rust (programming language)<br />
<a href="https://en.wikipedia.org/wiki/Rust_%28programming_language%29">https://en.wikipedia.org/wiki/Rust_%28programming_language%29</a>
</li>

<li>Go - home page<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>Stack Overflow - Most Loved, Dreaded, and Wanted language<br />
<a href="https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted">https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted</a>
</li>

<li>Rust vs Go (dva roky staré hodnocení, od té doby došlo k posunům v obou jazycích)<br />
<a href="http://jaredforsyth.com/2014/03/22/rust-vs-go/">http://jaredforsyth.com/2014/03/22/rust-vs-go/</a>
</li>

<li>Rust vs Go: My experience<br />
<a href="https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/">https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/</a>
</li>

<li>Friends of Rust (Organizations running Rust in production)<br />
<a href="https://www.rust-lang.org/en-US/friends.html">https://www.rust-lang.org/en-US/friends.html</a>
</li>

<li>Rust programs versus C++ g++<br />
<a href="https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp">https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp</a>
</li>

<li>Další benchmarky (nejedná se o reálné příklady &bdquo;ze života&ldquo;)<br />
<a href="https://github.com/kostya/benchmarks">https://github.com/kostya/benchmarks</a>
</li>

<li>Go na Redditu<br />
<a href="https://www.reddit.com/r/golang/">https://www.reddit.com/r/golang/</a>
</li>

<li>Rust vs. Go<br />
<a href="http://vschart.com/compare/rust/vs/go-language">http://vschart.com/compare/rust/vs/go-language</a>
</li>

<li>Abstraction without overhead: traits in Rust<br />
<a href="https://blog.rust-lang.org/2015/05/11/traits.html">https://blog.rust-lang.org/2015/05/11/traits.html</a>
</li>

<li>Method Syntax<br />
<a href="https://doc.rust-lang.org/book/method-syntax.html">https://doc.rust-lang.org/book/method-syntax.html</a>
</li>

<li>Traits in Rust<br />
<a href="https://doc.rust-lang.org/book/traits.html">https://doc.rust-lang.org/book/traits.html</a>
</li>

<li>Functional Programming in Rust - Part 1 : Function Abstraction<br />
<a href="http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/">http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/</a>
</li>

<li>Of the emerging systems languages Rust, D, Go and Nim, which is the strongest language and why?<br />
<a href="https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why">https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why</a>
</li>

<li>Chytré ukazatele (moderní verze jazyka C++) [MSDN]<br />
<a href="https://msdn.microsoft.com/cs-cz/library/hh279674.aspx">https://msdn.microsoft.com/cs-cz/library/hh279674.aspx</a>
</li>

<li>UTF-8 Everywhere<br />
<a href="http://utf8everywhere.org/">http://utf8everywhere.org/</a>
</li>

<li>Rust by Example<br />
<a href="http://rustbyexample.com/">http://rustbyexample.com/</a>
</li>

<li>Rust oficiálně ve Fedoře<br />
<a href="https://mojefedora.cz/rust-oficialne-ve-fedore/">https://mojefedora.cz/rust-oficialne-ve-fedore/</a>
</li>

<li>Resource acquisition is initialization<br />
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization</a>
</li>

<li>TIOBE index (October 2016)<br />
<a href="http://www.tiobe.com/tiobe-index/">http://www.tiobe.com/tiobe-index/</a>
</li>

<li>Porovnání Go, D a Rustu na OpenHubu:<br />
<a href="https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits">https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits</a>
</li>

<li>String Types in Rust<br />
<a href="http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/">http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/</a>
</li>

<li>Trait (computer programming)<br />
<a href="https://en.wikipedia.org/wiki/Trait_%28computer_programming%29">https://en.wikipedia.org/wiki/Trait_%28computer_programming%29</a>
</li>

<li>Type inference<br />
<a href="https://en.wikipedia.org/wiki/Type_inference">https://en.wikipedia.org/wiki/Type_inference</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

