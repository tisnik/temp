<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Rust - funkce, lambda výrazy a rozhodovací konstrukce match</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Rust - funkce, lambda výrazy a rozhodovací konstrukce match</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhé části seriálu o programovacím jazyku Rust se budeme věnovat třem důležitým jazykovým konstrukcím. Jedná se o funkce, lambda výrazy tvořící základ pro uzávěry a o rozhodovací konstrukci match, která v Rustu nahrazuje nešikovnou konstrukci switch-case.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyk Rust &ndash; funkce, lambda výrazy a rozhodovací konstrukce match</a></p>
<p><a href="#k02">2. Deklarace funkce bez parametrů i bez návratové hodnoty</a></p>
<p><a href="#k03">3. Deklarace funkce s&nbsp;parametry, ale bez návratové hodnoty</a></p>
<p><a href="#k04">4. Návratové hodnoty funkce</a></p>
<p><a href="#k05">5. Funkce bez návratového bodu</a></p>
<p><a href="#k06">6. Funkce jako plnohodnotný datový typ</a></p>
<p><a href="#k07">7. Funkce vyššího řádu</a></p>
<p><a href="#k08">8. Lambda výrazy</a></p>
<p><a href="#k09">9. Typy parametrů v&nbsp;lambda výrazech</a></p>
<p><a href="#k10">10. Lambda výrazy přiřazené do proměnné</a></p>
<p><a href="#k11">11. Rozhodovací konstrukce <strong>match</strong></a></p>
<p><a href="#k12">12. Konstrukce <strong>match</strong> ve funkci výrazu (ne příkazu)</a></p>
<p><a href="#k13">13. Jednoduché vzory v&nbsp;konstrukci <strong>match</strong></a></p>
<p><a href="#k14">14. Specifikace rozsahu</a></p>
<p><a href="#k15">15. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k16">16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk Rust &ndash; funkce, lambda výrazy a rozhodovací konstrukce match</h2>

<p><i>&bdquo;I call it my billion-dollar mistake. It was the invention of the
null reference in 1965. At that time, I was designing the first comprehensive
type system for references in an object oriented language (ALGOL W). My goal
was to ensure that all use of references should be absolutely safe, with
checking performed automatically by the compiler. But I couldn’t resist the
temptation to put in a null reference, simply because it was so easy to
implement. This has led to innumerable errors, vulnerabilities, and system
crashes, which have probably caused a billion dollars of pain and damage in the
last forty years.&ldquo;<br />
C.A.R. Hoare, InfoQ Null References: The Billion Dollar Mistake</i></p>

<p><a
href="https://www.root.cz/clanky/programovaci-jazyk-rust-nahrada-c-nebo-slepa-cesta/">V&nbsp;úvodní
části</a> <a
href="https://www.root.cz/serialy/programovaci-jazyk-rust/">seriálu o
programovacím jazyku Rust</a> jsme si, prozatím ovšem bez větších podrobností,
řekli, z&nbsp;jakého důvodu tento relativně mladý jazyk vlastně vznikl a pro
které typy aplikací může být výhodné ho použít. Připomeňme si jen krátce, že se
jedná o jazyk určený pro překlad do (nativního) strojového kódu s&nbsp;využitím
LLVM backendu, přičemž cílem je vytvořit takový výsledný strojový kód, který by
byl jak z&nbsp;hlediska spotřeby paměti, tak i z&nbsp;hlediska výkonu
srovnatelný s&nbsp;výsledkem produkovaným překladači jazyků C či C++.
Programovací jazyk Rust je však zároveň navržen s&nbsp;ohledem na tvorbu
bezpečnějších aplikací i s&nbsp;důrazem na použití paralelismu. Dnes se poněkud
podrobněji seznámíme se třemi rysy tohoto programovacího jazyka &ndash;
s&nbsp;funkcemi tvořícími základ modulárních aplikací, s&nbsp;lambda výrazy
(v&nbsp;tento okamžik ovšem bez vysvětlení uzávěrů) a taktéž s&nbsp;rozhodovací
konstrukcí <strong>match</strong>, která v&nbsp;Rustu nahradila primitivnější a
mnohdy nevyhovující konstrukci <strong>switch-case</strong>.</p>

<p>Poznámka: všechny následující příklady je možné přeložit překladačem
nazvaným <strong>rustc</strong>, který se spouští klasicky z&nbsp;příkazové
řádky. Žádné další podpůrné nástroje (<strong>cargo</strong> apod.) prozatím
nebudete potřebovat. Chybová hlášení, s&nbsp;nimiž se taktéž setkáme, se mohou
nepatrně lišit v&nbsp;závislosti na aktuálně nainstalované verzi Rustu.</p>

<p>Poznámka<sup>2</sup>: v&nbsp;této části se některým konstrukcím věnuje
poměrně velké množství prostoru, včetně ukázky typických chyb, s&nbsp;nimiž se
může programátor přecházející na Rust setkat. Prosím čtenáře o vyjádření
v&nbsp;diskuzi, jestli je lepší se v&nbsp;jednom článku věnovat více
vlastnostem (méně podrobně) či zda tato forma vyhovuje.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Deklarace funkce bez parametrů i bez návratové hodnoty</h2>

<p>Začněme skutečně velmi jednoduchými příklady. V&nbsp;následujícím úryvku
kódu můžeme vidět deklaraci dvou funkcí nazvaných <strong>foo</strong> a
<strong>main</strong>. Deklarace funkce začíná klíčovým slovem
<strong>fn</strong> (takže se neupíšete tak, jako například
v&nbsp;JavaScriptu). Za tímto klíčovým slovem následuje jméno funkce, případná
specifikace typu u generických funkcí (zapsáno v&nbsp;úhlových závorkách),
seznam a typy parametrů umístěných v&nbsp;kulatých závorkách, případná
specifikace návratového typu a konečně blok, v&nbsp;němž je zapsáno tělo
funkce. Jak je patrné z&nbsp;úryvku kódu, ani jedna z&nbsp;deklarovaných funkcí
neakceptuje žádné parametry a dokonce ani nemá žádnou návratovou hodnotu.
Z&nbsp;tohoto důvodu je deklarace zjednodušena a v&nbsp;kulatých závorkách se
žádná jména a typy parametrů neuvádí, dokonce se neuvádí ani návratový typ
funkce:</p>

<pre>
fn foo() {
    println!("foo");
}
&nbsp;
fn main() {
    foo();
}
</pre>

<p>Kulaté závorky nelze vynechat, což hlídá překladač:</p>

<pre>
fn foo {
    println!("foo");
}
&nbsp;
fn main() {
    foo();
}
</pre>

<pre>
error: expected one of `(` or `&lt;`, found `{`
 --&gt; 15_void_function.rs:1:8
  |
1 | fn foo {
  |        ^
&nbsp;
error: aborting due to previous error
</pre>

<p>Taktéž je striktně hlídáno, aby se funkci bez parametrů skutečně nic
nepředávalo:</p>

<pre>
fn foo() {
    println!("foo");
}
&nbsp;
fn main() {
    foo(42);
}
</pre>

<pre>
error[E0061]: this function takes 0 parameters but 1 parameter was supplied
 --&gt; 15_void_function.rs:6:5
  |
6 |     foo(42);
  |     ^^^^^^^ expected 0 parameters

error: aborting due to previous error
</pre>

<p>Poznámka: pozor na to, že v&nbsp;céčku znamená zápis () něco jiného,
konkrétně funkci s&nbsp;nespecifikovaným počtem parametrů (zde je Rust blíže
k&nbsp;C++):</p>

<pre>
void foo() {
}
&nbsp;
int main(void) {
    foo(42);
    return 0;
}
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Deklarace funkce s&nbsp;parametry, ale bez návratové hodnoty</h2>

<p>Nyní se podívejme na nepatrně složitější příklad, v&nbsp;němž jsou
deklarovány čtyři funkce. První funkce neakceptuje žádné parametry (opět je to
hlídáno překladačem), druhá funkce akceptuje parametr typu celé 32bitové číslo
se znaménkem a třetí funkce akceptuje dva parametry stejného typu, tedy opět
celé 32bitové číslo se znaménkem. Povšimněte si způsobu zápisu, který se sice
liší od specifikace typů v&nbsp;céčku či Javě, na stranu druhou je tento zápis
konzistentní s&nbsp;deklarací proměnných apod..</p>

<pre>
fn foo() {
    println!("foo");
}
&nbsp;
fn bar(argument:i32) {
    println!("{}", argument);
}
&nbsp;
fn baz(argument1:i32, argument2:i32) {
    println!("{} {}", argument1, argument2);
}
&nbsp;
fn main() {
    foo();
    bar(42);
    baz(1, 2);
}
</pre>

<p>Již v&nbsp;době překladu je hlídáno, zda jsou funkce volány s&nbsp;parametry
správných typů. Pokud příklad pozměníme takovým způsobem, že funkce
<strong>bar</strong> a <strong>baz</strong> budou akceptovat celá čísla bez
znaménka a předáme těmto funkcím záporné hodnoty, nebude překlad úspěšný:</p>

<pre>
fn foo() {
    println!("foo");
}
&nbsp;
fn bar(argument:<strong>u32</strong>) {
    println!("{}", argument);
}
&nbsp;
fn baz(argument1:<strong>u32</strong>, argument2:<strong>u32</strong>) {
    println!("{} {}", argument1, argument2);
}
&nbsp;
fn main() {
    foo();
    bar(<strong>-42</strong>);
    baz(<strong>-1</strong>, 2);
}
</pre>

<p>Při pokusu o překlad takto upraveného příkladu nebude překladač
<strong>rustc</strong> příliš spokojen s&nbsp;předloženým zdrojovým kódem, což
dá najevo barevným chybovým hlášením, z&nbsp;kterého je zřejmé, kde chyba
nastala (v&nbsp;článku nejsou barvy vidět, v&nbsp;praxi však zvyšují čitelnost
a přehlednost):</p>

<pre>
error[E0080]: constant evaluation error
  --&gt; 16_typed_arguments.rs:15:9
   |
15 |     bar(-42);
   |         ^^^ unary negation of unsigned integer
&nbsp;
error[E0080]: constant evaluation error
  --&gt; 16_typed_arguments.rs:16:9
   |
16 |     baz(-1, 2);
   |         ^^ unary negation of unsigned integer

error: aborting due to 2 previous errors
</pre>

<p>Překladač se nenechá zmást ani tehdy, pokud je funkci předávána
proměnná nesprávného typu:</p>

<pre>
fn foo() {
    println!("foo");
}
&nbsp;
fn bar(argument:<strong>u32</strong>) {
    println!("{}", argument);
}
&nbsp;
fn baz(argument1:i32, argument2:i32) {
    println!("{} {}", argument1, argument2);
}
&nbsp;
fn main() {
    foo();
    <strong>let x:i32 = -42;</strong>
    bar(<strong>x</strong>);
    baz(1, 2);
}
</pre>

<pre>
error[E0308]: mismatched types
  --&gt; 16_typed_arguments.rs:16:9
   |
16 |     bar(x);
   |         ^ expected u32, found i32
&nbsp;
error: aborting due to previous error
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Návratové hodnoty funkce</h2>

<p>Jak se deklarují funkce s&nbsp;parametry již víme, takže se ještě musíme
seznámit se způsobem deklarace funkce, která vrací nějakou hodnotu. Typ
návratové hodnoty se specifikuje za šipkou -&gt; zapsanou po seznamu parametrů,
ale ještě před blokem obsahujícím tělo funkce:</p>

<pre>
fn foo() -&gt; i32 {
    42
}
&nbsp;
fn bar(argument:i32) -&gt; i32 {
    return argument * 2;
}
&nbsp;
fn baz(argument:i32) -&gt; i32 {
    argument * 2
}
&nbsp;
fn main() {
    println!("{}", foo());
    println!("{}", bar(21));
    println!("{}", baz(21));
}
</pre>

<p>Povšimněte si dvou zajímavostí. Funkce, která vrací hodnotu, může být
zapsána dvěma způsoby:</p>

<ol>

<li>Blok tvořící tělo kódu obsahuje jeden příkaz <strong>return výraz</strong>
či více příkazů <strong>return výraz</strong>, které mohou být umístěny
v&nbsp;podmínce atd. Vzhledem k&nbsp;tomu, že se jedná o příkaz, <i>je za ním
uveden středník</i>.</li>

<li>Blok může končit výrazem, <i>za kterým se nepíše středník</i>. Celý blok je
totiž v&nbsp;jazyce Rust považován za plnohodnotný výraz vracející hodnotu (to
je podobné LISPovským jazykům). Tento zápis by měl být preferovaný, konkrétně
funkce <strong>bar</strong> není zapsána idiomaticky.</li>

</ol>

<p>Opět si otestujme, co se stane v&nbsp;případě, že uděláme chybu při
specifikaci typů parametrů a návratového typu funkce. Následující příklad byl
nepatrně upraven tak, že funkce <strong>bar</strong> a <strong>baz</strong>
očekávají 32bitová celá čísla se znaménkem (<i>signed</i>), ovšem typ
návratových hodnot je odlišný &ndash; taktéž 32bitová celá čísla, ovšem bez
znaménka (<i>unsigned</i>):</p>

<pre>
fn foo() -&gt; i32 {
    42
}
&nbsp;
fn bar(argument:i32) -&gt; u32 {
    return argument * 2;
}
&nbsp;
fn baz(argument:i32) -&gt; u32 {
    argument * 2
}
&nbsp;
fn main() {
    println!("{}", foo());
    println!("{}", bar(21));
    println!("{}", baz(21));
}
</pre>

<p>V&nbsp;některých jiných jazycích by tato deklarace byla zcela korektní (což
zde znamená, že by se chyba projevila až v&nbsp;čase běhu), zatímco překladač
Rustu vypíše již v&nbsp;čase překladu chybová hlášení:</p>

<pre>
error[E0308]: mismatched types
 --&gt; 17_return_value.rs:6:12
  |
6 |     return argument * 2;
  |            ^^^^^^^^^^^^ expected u32, found i32
&nbsp;
error[E0308]: mismatched types
  --&gt; 17_return_value.rs:10:5
   |
10 |     argument * 2
   |     ^^^^^^^^^^^^ expected u32, found i32

error: aborting due to 2 previous errors
</pre>

<p>Druhá chyba je méně nápadná a ukazuje, co se stane ve chvíli, kdy
zapomeneme, že pokud blok těla funkce končí výrazem, nesmí za ním být
středník:</p>

<pre>
fn foo() -&gt; i32 {
    42<strong>;</strong>
}
&nbsp;
fn bar(argument:i32) -&gt; i32 {
    return argument * 2;
}
&nbsp;
fn baz(argument:i32) -&gt; i32 {
    argument * 2<strong>;</strong>
}
&nbsp;
fn main() {
    println!("{}", foo());
    println!("{}", bar(21));
    println!("{}", baz(21));
}
</pre>

<p>I v&nbsp;tomto případě nás překladač pohlídá:</p>

<pre>
error[E0269]: not all control paths return a value
 --&gt; 17_return_value.rs:1:1
  |
1 | fn foo() -&gt; i32 {
  | ^
  |
help: consider removing this semicolon:
 --&gt; 17_return_value.rs:2:7
  |
2 |     42;
  |       ^
&nbsp;
error[E0269]: not all control paths return a value
  --&gt; 17_return_value.rs:9:1
   |
9  | fn baz(argument:i32) -&gt; i32 {
   | ^
   |
help: consider removing this semicolon:
  --&gt; 17_return_value.rs:10:17
   |
10 |     argument * 2;
   |                 ^
&nbsp;
error: aborting due to 2 previous errors
</pre>

<p>Zkusme ještě jeden nefunkční příklad, tentokrát kombinující oba způsoby (což
de facto znamená, že se poslední výraz nikdy nevyhodnotí):</p>

<pre>
fn baz(argument:i32) -&gt; i32 {
    return 0;
    argument * 2
}
</pre>

<p>Nyní nastanou při překladu dvě chyby, přičemž druhá chyba současně způsobila
i chybu první:</p>

<pre>
warning: unused variable: `argument`, #[warn(unused_variables)] on by default
 --&gt; 17_return_value.rs:9:8
  |
9 | fn baz(argument:i32) -&gt; i32 {
  |        ^^^^^^^^
&nbsp;
warning: unreachable expression, #[warn(unreachable_code)] on by default
  --&gt; 17_return_value.rs:11:5
   |
11 |     argument * 2
   |     ^^^^^^^^^^^^
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Funkce bez návratového bodu</h2>

<p>Určitou specialitou jsou funkce, z&nbsp;nichž se řízení programu již nikdy
nevrátí (takže se striktně vzato vlastně o skutečné funkce nejedná). U těchto
funkcí, které se v&nbsp;Rustu nazývají <i>diverging functions</i>, se namísto
specifikace návratového typu používá zápis -&gt; !. Příkladem může být funkce
<strong>foo</strong>, která volá knihovní makro <strong>panic!</strong>, jenž
ukončí právě aktivní vlákno a zde tedy i celou aplikaci:</p>

<pre>
fn foo() -&gt; ! {
    panic!("This function never returns!");
}
&nbsp;
fn main() {
    foo();
}
</pre>

<p>Překlad proběhne v&nbsp;pořádku a při spuštění získáme následující chybové
hlášení:</p>

<pre>
thread 'main' panicked at 'This function never returns!', 18_diverging_function.rs:2
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</pre>

<p>Pokud budete postupovat podle výše vypsané nápovědy, získáme celý (zde dosti
nečitelný) backtrace:</p>

<pre>
~/ $ <strong>export RUST_BACKTRACE=1;./18_diverging_function </strong>
thread 'main' panicked at 'This function never returns!', 18_diverging_function.rs:2
stack backtrace:
   1:     0x7fa0a71100d9 - std::sys::backtrace::tracing::imp::write::hd4b54a4a2078cb15
   2:     0x7fa0a7112c1c - std::panicking::default_hook::_{{closure}}::h51a5ee7ba6a9fcef
   3:     0x7fa0a7112109 - std::panicking::default_hook::hf823fce261e27590
   4:     0x7fa0a7112748 - std::panicking::rust_panic_with_hook::h8d486474663979b9
   5:     0x7fa0a710b616 - std::panicking::begin_panic::h94e6fb50d7864116
   6:     0x7fa0a710b76f - _18_diverging_function::foo::haed231fc6b9e676c
   7:     0x7fa0a710b777 - _18_diverging_function::main::h3672be7d52a51206
   8:     0x7fa0a711a706 - __rust_maybe_catch_panic
   9:     0x7fa0a7111882 - std::rt::lang_start::hca48e539ce72a288
  10:     0x7fa0a710b7a9 - main
  11:     0x7fa0a6505f44 - __libc_start_main
  12:     0x7fa0a710b478 - &lt;unknown&gt;
  13:                0x0 - &lt;unknown&gt;
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Funkce jako plnohodnotný datový typ</h2>

<p>Funkce jsou v&nbsp;programovacím jazyku Rust považovány za plnohodnotný
datový typ, podobně jako v&nbsp;mnoha funkcionálních jazycích. Díky tomu je
možné funkce předávat jako parametry jiným funkcím, vracet funkce, ukládat
funkce do proměnných (resp.&nbsp;přesněji řečeno vytvořit vazbu mezi funkcí a
jménem proměnné) atd. Podívejme se prozatím na velmi jednoduchý příklad,
v&nbsp;němž opět máme deklarovány nám již známé funkce <strong>foo</strong>,
<strong>bar</strong> a <strong>baz</strong>. Tyto funkce jsou uloženy do
proměnných <strong>f1</strong>, <strong>f2</strong> a <strong>f3</strong> a lze
je přes tyto proměnné i zavolat:</p>

<pre>
fn foo() -&gt; i32 {
    42
}
&nbsp;
fn bar(argument:i32) -&gt; i32 {
    return argument * 2;
}
&nbsp;
fn baz(argument:i32) -&gt; i32 {
    argument * 2
}
&nbsp;
fn main() {
    let f1 = foo;
    let f2 = bar;
    let f3 = baz;
    println!("{}", f1());
    println!("{}", f2(21));
    println!("{}", f3(21));
}
</pre>

<p>Překlad a spuštění by měly proběhnout bez problémů:</p>

<pre>
42
42
42
</pre>

<p>Poznámka: podobné chování sice lze napodobit i v&nbsp;céčku použitím
ukazatelů na funkce, ovšem hned v&nbsp;další části tohoto seriálu si ukážeme,
že vlastnosti funkcí v&nbsp;Rustu jsou poněkud odlišné, a to mj.&nbsp;i díky
možnosti deklarace generických funkcí.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Funkce vyššího řádu</h2>
 
<p>Programovací jazyk <i>Rust</i> sice není, na rozdíl od Haskellu a částečně i
Clojure, čistě funkcionálním jazykem, nicméně i zde mohou hrát při vývoji
aplikací velkou roli takzvané funkce vyššího řádu, tj.&nbsp;funkce, které jako
své parametry akceptují jiné funkce popř.&nbsp;dokonce vrací (nové) funkce jako
svoji návratovou hodnotu (o tom jsme se zmiňovali již <a
href="#k06">v&nbsp;předchozí kapitole</a>). Mezi dvě základní funkce vyššího
řádu, které nalezneme prakticky ve všech jazycích, jež tento koncept nějakým
způsobem podporují, patří funkce nazvané <strong>map</strong> a taktéž
<strong>filter</strong>. Funkce <strong>map</strong> postupně aplikuje jí
předanou funkci na jednotlivé prvky nějaké sekvence a vytváří tak sekvenci
novou (modifikovanou).</p>

<p>Pro jednoduchost si ukažme, jak lze použít funkci <strong>map</strong>
společně s&nbsp;objektem typu <i>range</i>, s&nbsp;nímž jsme se již seznámili
minule. Nejprve vytvoříme sekvenci celých čísel od 0 do 9 a posléze na každý
prvek této sekvence zavoláme funkci <strong>square</strong>. Výsledkem je nová
sekvence, jejíž prvky jsou vypsány v&nbsp;programové smyčce typu
<i>for</i>:</p>

<pre>
fn square(x:u32) -&gt; u32 {
    x*x
}
&nbsp;
fn main() {
    let sequence = 0..10;
    let squares = sequence.map(square);
    for n in squares {
        println!("{}", n);
    }
}
</pre>

<p>Po překladu a spuštění by se na standardní výstup měly vypsat prvky nově
vypočtené sekvence:</p>

<pre>
0
1
4
9
16
25
36
49
64
81
</pre>

<p>Poznámka: sekvencemi se budeme podrobněji zabývat příště, protože se jedná o
poměrně vhodný způsob, jak &bdquo;funkcionálně&ldquo; pracovat
s&nbsp;homogenními datovými strukturami. Navíc se díky tomu, že funkce
<strong>map</strong> či <strong>filter</strong> (a několik dalších funkcí)
vrací novou sekvenci (či přesněji řečeno iterátor), mohou tyto funkce vyššího
řádu řetězit.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Lambda výrazy</h2>

<p>Kromě pojmenovaných funkcí, které jsme si již představili v&nbsp;předchozích
kapitolách, je možné v&nbsp;programovacím jazyku <i>Rust</i> použít i funkce
anonymní, tj.&nbsp;funkce, které nejsou navázány na žádné jméno. Anonymní
funkce jsou taktéž nazývány lambda výrazy (<i>lambda expression</i>), což má
svůj původ v&nbsp;lambda kalkulu (to je však již téma přesahující možnosti
dnešního článku :-). Označení &bdquo;anonymní funkce&ldquo; poměrně přesně
charakterizuje, o co se jedná &ndash; tyto funkce jednoduše nemají jméno.
Předností je, že anonymní funkce lze předat ve formě parametru nějaké funkci
vyššího řádu. To se hodí zejména ve chvíli, kdy se daná funkce používá jen na
jednom místě v&nbsp;programu. Příkladem může být v&nbsp;předchozí kapitole
uvedená funkce <strong>square</strong>, která se použije pouze jedenkrát a
současně je její tělo tvořeno jednoduchým výrazem. Tuto funkci můžeme přepsat
na funkci anonymní takto:</p>

<pre>
|x| x*x
</pre>

<p>V&nbsp;této formě zápisu se mezi znaky || vkládají jména parametrů a
popř.&nbsp;jejich typy a za druhým znakem | následuje výraz tvořící tělo
anonymní funkce.</p>

<p>Příklad použití odvozený od delšího příkladu z&nbsp;předchozí kapitoly:</p>

<pre>
fn main() {
    let sequence = 0..10;
    let squares = sequence.map(|x| x*x);
    for n in squares {
        println!("{}", n);
    }
}
</pre>

<p>Po překladu a spuštění by se na standardní výstup měly vypsat prvky nově
vypočtené sekvence:</p>

<pre>
0
1
4
9
16
25
36
49
64
81
</pre>

<p>Ve skutečnosti nemusí být tělo anonymní funkce tvořeno jediným výrazem,
protože můžeme využít faktu, že blok {} je v&nbsp;jazyku Rust považován za
plnohodnotný výraz s&nbsp;nějakou výslednou hodnotou. Můžeme tedy napsat i:</p>

<pre>
fn main() {
    let sequence = 0..10;
    let squares = sequence.map(|x| {let result=x*x; result});
    for n in squares {
        println!("{}", n);
    }
}
</pre>

<p>Někdy se delší anonymní funkce rozepisují na více řádků:</p>

<pre>
fn main() {
    let sequence = 0..10;
    let squares = sequence.map(|x| {let result=x*x;
                                    result
                                   });
    for n in squares {
        println!("{}", n);
    }
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Typy parametrů v&nbsp;lambda výrazech</h2>

<p>Pozorného čtenáře asi napadlo, jak je vlastně možné, že anonymní funkce měla
uvedeno pouze jméno argumentu a nikoli jeho typ. Totéž platí i o typu návratové
hodnoty, ten nebyl dokonce pro jistotu specifikován vůbec. Ve skutečnosti je to
(někdy) povoleno, protože se anonymní funkce použila v&nbsp;takovém kontextu,
že překladač mohl odvodit, jakého typu parametr i návratová hodnota jsou. Ovšem
v&nbsp;případě potřeby (ta ovšem nebude moc častá) lze typ parametru předepsat,
a to následujícím způsobem:</p>

<pre>
fn main() {
    let sequence = -10..10;
    let squares = sequence.map(|x<strong>:i32</strong>| x*x);
    for n in squares {
        println!("{}", n);
    }
}
</pre>

<p>Překlad a spuštění proběhnou v&nbsp;pořádku:</p>

<pre>
81
64
49
36
25
16
9
4
1
0
1
4
9
16
25
36
49
64
81
</pre>

<p>Explicitně zadaný typ parametru/parametrů, pokud je tedy uveden, je
samozřejmě hlídán, o čemž se můžeme snadno přesvědčit, když se anonymní funkci
očekávající jen přirozená čísla pokusíme předat hodnotu zápornou:</p>

<pre>
fn main() {
    let sequence = -10..10;
    let squares = sequence.map(|x:u32| x*x);
    for n in squares {
        println!("{}", n);
    }
}
</pre>

<p>Kontrola je opět provedena již při překladu:</p>

<pre>
error[E0080]: constant evaluation error
 --&gt; 22_typed_lambda_expression.rs:2:20
  |
2 |     let sequence = -10..10;
  |                    ^^^ unary negation of unsigned integer

error: aborting due to previous error
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Lambda výrazy přiřazené do proměnné</h2>

<p>Následující demonstrační příklad kombinuje některé koncepty, s&nbsp;nimiž
jsme se seznámili v&nbsp;předchozích kapitolách. Jedná se o deklaraci anonymní
funkce s&nbsp;uvedením typu parametru a o uložení funkce do proměnné
(resp.&nbsp;o navázání funkce na jméno proměnné):</p>

<pre>
fn main() {
    let is_odd  = |x: i32| x &amp; 1 == 1;
    //let is_even = |x: i32| !is_odd(x);
    let square  = |x: i32| x*x;
    for x in 0..10 {
        println!("{}*{}={}, {} is {} number", x, x, square(x), x, if is_odd(x) {"odd"} else {"even"})
    }
}
</pre>

<p>Tento příklad by měl po svém překladu a spuštění vypsat na standardní výstup
následujících deset řádků:</p>

<pre>
0*0=0, 0 is even number
1*1=1, 1 is odd number
2*2=4, 2 is even number
3*3=9, 3 is odd number
4*4=16, 4 is even number
5*5=25, 5 is odd number
6*6=36, 6 is even number
7*7=49, 7 is odd number
8*8=64, 8 is even number
9*9=81, 9 is odd number
</pre>

<p>Poznámka: sice by se mohlo zdát, že není žádný rozdíl mezi deklarací
pojmenované funkce a anonymní funkcí přiřazenou do proměnné (tím se vlastně
funkce &bdquo;pojmenuje&ldquo;), ve skutečnosti je však možné svázat anonymní
funkci se symbolem vytvořeným vně této funkce &ndash; jinými slovy je
v&nbsp;Rustu možné tvořit <i>uzávěry (closures)</i>.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Rozhodovací konstrukce <strong>match</strong></h2>

<p>Programovací jazyk Rust sice nepodporuje céčkovskou rozhodovací konstrukci
typu <strong>switch-case</strong> (kterou převzala a jen mírně rozšířila Java
atd.), což však ve skutečnosti není žádná škoda, protože namísto toho nabízí
mnohem robustnější konstrukci <strong>match</strong>, kterou lze taktéž použít
pro volbu některé větve kódu, jenž se má provést. Nejprve se bez dlouhých
popisů podívejme na způsob zápisu této konstrukce v&nbsp;její nejjednodušší
podobě, tedy při klasickém rozvětvení:</p>

<pre>
fn main() {
    let x:i32 = 1;

    match x {
        0 =&gt; println!("zero"),
        1 =&gt; println!("one"),
        2 =&gt; println!("two"),
        3 =&gt; println!("three"),
        _ =&gt; println!("something else"),
    }
}
</pre>

<p>Vidíme, že v&nbsp;konstrukci <strong>match</strong> je několik větví,
přičemž každá větev začíná porovnávanou hodnotou a výraz či příkaz je uveden za
šipkou tvořenou znaky =&gt;. Poslední řádek obsahuje symbol _, který vlastně
nahrazuje větev <strong>default</strong>. Ve skutečnosti je však sémantika
tohoto symbolu poněkud odlišná, protože před šipkou =&gt; je uveden takzvaný
vzorek (<i>pattern</i>) a nikoli pouhopouhá konstanta.</p>

<p>Ve skutečnosti překladač kontroluje, zda je _ použit, protože je vyžadováno,
aby větve v&nbsp;konstrukci <strong>match</strong> pokryly všechny možné
hodnoty testovaného výrazu (mám pocit, že současný překladač obsahuje chybu,
protože pouze vyžaduje použití _ vždy, i když to s&nbsp;ohledem na předchozí
větve není nutné). Zkusme přeložit následující příklad:</p>

<pre>
fn main() {
    let x:i32 = 1;

    match x {
        0 =&gt; println!("zero"),
        1 =&gt; println!("one"),
        2 =&gt; println!("two"),
        3 =&gt; println!("three"),
    }
}
</pre>

<p>Podle očekávání skončí pokus o překlad tohoto zdrojového kódu
s&nbsp;chybou:</p>

<pre>
error[E0004]: non-exhaustive patterns: `_` not covered
 --&gt; 24_match.rs:4:11
  |
4 |     match x {
  |           ^ pattern `_` not covered

error: aborting due to previous error
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Konstrukce <strong>match</strong> ve funkci výrazu (ne příkazu)</h2>

<p>Podobně jako tomu bylo o konstrukce <strong>if-else</strong> či u
programového bloku <strong>{}</strong>, je i konstrukce <strong>match</strong>
považována za <i>výraz</i>, nikoli za <i>příkaz</i>. To znamená, že
<strong>match</strong> je možné použít v&nbsp;nějakém výpočtu, uvnitř jiného
výrazu atd. V&nbsp;dalším příkladu je deklarována funkce nazvaná
<strong>classify</strong>, které se předá celočíselná hodnota a funkce vrátí
konstantní řetězec, který tuto hodnotu popisuje (podezřelému zápisu
&amp;'static str prosím prozatím věřte, popíšeme si ho později, protože řetězce
jsou poměrně komplikované téma). Tato funkce obsahuje ve svém bloku jediný
výraz a tím je <strong>match</strong> (proto ostatně za složenou závorkou není
středník):</p>

<pre>
fn classify(x:i32) -&gt; &amp;'static str {
    match x {
        0 =&gt; "zero",
        1 =&gt; "one",
        2 =&gt; "two",
        3 =&gt; "three",
        _ =&gt; "something else",
    }
}
&nbsp;
fn main() {
    for x in 0..10 {
        println!("{}:{}", x, classify(x))
    }
}
</pre>

<p>Po překladu a spuštění dostaneme na standardním výstupu tyto zprávy:</p>

<pre>
0:zero
1:one
2:two
3:three
4:something else
5:something else
6:something else
7:something else
8:something else
9:something else
</pre>

<p>Poznámka: někdy se setkáme s&nbsp;tím, že se <strong>match</strong> použije
namísto konstrukce <strong>if-else</strong>. Skutečně se může jednat o
čitelnější zápis, který vzdáleně připomíná funkci <strong>cond</strong>
z&nbsp;LISPu:</p>

<pre>
fn factorial(n: u64) -&gt; u64 {
    match n {
        0 =&gt; 1,
        _ =&gt; n * factorial(n-1)
    }
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Jednoduché vzory v&nbsp;konstrukci <strong>match</strong></h2>

<p>Již jsme si naznačili, že před šipkou =&gt; se nemusí uvádět pouhé
konstanty, s&nbsp;nimiž je porovnáván výraz předaný konstrukci
<strong>match</strong>, ale mohou být použity nějaké obecně složitější vzory
(<i>pattern</i>). Asi nejjednodušší vzor se tvoří pomocí znaku |, kterým je
možné specifikovat několik hodnot, s&nbsp;nimiž je výsledek výrazu porovnáván.
Příklad použití tohoto vzoru osvětlí:</p>

<pre>
fn classify(x:i32) -&gt; &amp;'static str {
    match x {
        0         =&gt; "zero",
        1 | 2     =&gt; "one or two",
        3 | 4 | 5 =&gt; "from three to five",
        _         =&gt; "something else",
    }
}
&nbsp;
fn main() {
    for x in 0..10 {
        println!("{}:{}", x, classify(x))
    }
}
</pre>

<p>Po spuštění by se měl vypsat tento text:</p>

<pre>
0:zero
1:one or two
2:one or two
3:from three to five
4:from three to five
5:from three to five
6:something else
7:something else
8:something else
9:something else
</pre>

<p>Vidíme, že tímto zápisem můžeme nahradit céčkovskou konstrukci:</p>

<pre>
switch (x) {
    case 0: return "zero";
    case 1:
    case 2: return "one or two";
    ...
    ...
    ...
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Specifikace rozsahu</h2>

<p>V&nbsp;programové konstrukci <strong>match</strong> je možné použít i
specifikaci rozsahu, tj.&nbsp;testu, zda kontrolovaná hodnota leží
v&nbsp;zadaných mezích. Tyto meze se zapisují s&nbsp;využitím trojice teček,
což je odlišné od zápisu dvou teček používaných při konstrukci objektu typu
<i>range</i>. Dalším podstatným rozdílem mezi zápisem mezí a objektem typu
<i>range</i> je fakt, že meze jsou vždy kontrolovány včetně obou krajních
hodnot. To konkrétně znamená, že v&nbsp;dalším příkladu se text &bdquo;from
three to five&ldquo; vypíše pro vstupní hodnoty 3, 4 a 5:</p>

<pre>
fn classify(x:i32) -&gt; &amp;'static str {
    match x {
        0         =&gt; "zero",
        1 | 2     =&gt; "one or two",
        3 ... 5   =&gt; "from three to five",
        10 ... 20 =&gt; "from ten to twenty",
        _         =&gt; "something else",
    }
}
&nbsp;
fn main() {
    for x in 0..20 {
        println!("{}:{}", x, classify(x))
    }
}
</pre>

<p>Příklad si po překladu samozřejmě můžeme jednoduše otestovat:</p>

<pre>
0:zero
1:one or two
2:one or two
3:from three to five
4:from three to five
5:from three to five
6:something else
7:something else
8:something else
9:something else
10:from ten to twenty
11:from ten to twenty
12:from ten to twenty
13:from ten to twenty
14:from ten to twenty
15:from ten to twenty
16:from ten to twenty
17:from ten to twenty
18:from ten to twenty
19:from ten to twenty
</pre>

<p>Překladač programovacího jazyka Rust kontroluje, zda se omylem namísto
trojice teček ... (meze) nezapsal konstruktor objektu <i>range</i> dvojicí
teček. Následující příklad se tedy nepřeloží korektně kvůli zvýrazněnému
řádku:</p>

<pre>
fn classify(x:i32) -&gt; &amp;'static str {
    match x {
        0         =&gt; "zero",
        1 | 2     =&gt; "one or two",
        3 ... 5   =&gt; "from three to five",
        <strong>10 .. 20 =&gt; "from ten to twenty",</strong>
        _         =&gt; "something else",
    }
}
&nbsp;
fn main() {
    for x in 0..20 {
        println!("{}:{}", x, classify(x))
    }
}
</pre>

<p>Při pokusu o překlad se vypíše následující chybové hlášení:</p>

<pre>
error: expected one of `...`, `=&gt;`, `if`, or `|`, found `..`
 --&gt; 27_match_range.rs:6:12
  |
6 |         10 .. 20 =&gt; "from ten to twenty",
  |            ^^
&nbsp;
error: aborting due to previous error
</pre>

<p>Poznámka: podobná konstrukce sice není dostupná ve standardním céčku, ale
lze ji nalézt například <a
href="https://gcc.gnu.org/onlinedocs/gcc/Case-Ranges.html">v&nbsp;rozšíření
překladače GCC</a> (a možná i dalších překladačů). Daní ovšem bude
nekompatibilita zdrojového kódu se standardem.</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes ukázané demonstrační příklady, resp.&nbsp;přesněji řečeno
jejich bezchybné varianty, byly uloženy do Git repositáře dostupného na adrese
<a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě bez nutnosti
klonovat celý (dnes již objemný) repositář:</p>

<table>
<tr><th>Příklad</th><th>Odkaz</th></tr>
<tr><td>15_void_function.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/15_void_function.rs">https://github.com/tisnik/presentations/blob/master/rust/15_void_function.rs</a></td></tr>
<tr><td>16_typed_arguments.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/16_typed_arguments.rs">https://github.com/tisnik/presentations/blob/master/rust/16_typed_arguments.rs</a></td></tr>
<tr><td>17_return_value.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/17_return_value.rs">https://github.com/tisnik/presentations/blob/master/rust/17_return_value.rs</a></td></tr>
<tr><td>18_diverging_function.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/18_diverging_function.rs">https://github.com/tisnik/presentations/blob/master/rust/18_diverging_function.rs</a></td></tr>
<tr><td>19_function_variable.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/19_function_variable.rs">https://github.com/tisnik/presentations/blob/master/rust/19_function_variable.rs</a></td></tr>
<tr><td>20_higher_order_functions.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/20_higher_order_functions.rs">https://github.com/tisnik/presentations/blob/master/rust/20_higher_order_functions.rs</a></td></tr>
<tr><td>21_lambda_expression.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/21_lambda_expression.rs">https://github.com/tisnik/presentations/blob/master/rust/21_lambda_expression.rs</a></td></tr>
<tr><td>22_typed_lambda_expression.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/22_typed_lambda_expression.rs">https://github.com/tisnik/presentations/blob/master/rust/22_typed_lambda_expression.rs</a></td></tr>
<tr><td>23_lambda_as_value.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/23_lambda_as_value.rs">https://github.com/tisnik/presentations/blob/master/rust/23_lambda_as_value.rs</a></td></tr>
<tr><td>24_match.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/24_match.rs">https://github.com/tisnik/presentations/blob/master/rust/24_match.rs</a></td></tr>
<tr><td>25_match_as_expression.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/25_match_as_expression.rs">https://github.com/tisnik/presentations/blob/master/rust/25_match_as_expression.rs</a></td></tr>
<tr><td>26_match_or.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/26_match_or.rs">https://github.com/tisnik/presentations/blob/master/rust/26_match_or.rs</a></td></tr>
<tr><td>27_match_range.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/27_match_range.rs">https://github.com/tisnik/presentations/blob/master/rust/27_match_range.rs</a></td></tr>
<tr><td>28_factorial.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/28_factorial.rs">https://github.com/tisnik/presentations/blob/master/rust/28_factorial.rs</a></td></tr>
</table>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>Rust - home page<br />
<a href="https://www.rust-lang.org/en-US/">https://www.rust-lang.org/en-US/</a>
</li>

<li>Rust - Frequently Asked Questions<br />
<a href="https://www.rust-lang.org/en-US/faq.html">https://www.rust-lang.org/en-US/faq.html</a>
</li>

<li>The Rust Programming Language<br />
<a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>
</li>

<li>Rust (programming language)<br />
<a href="https://en.wikipedia.org/wiki/Rust_%28programming_language%29">https://en.wikipedia.org/wiki/Rust_%28programming_language%29</a>
</li>

<li>Go - home page<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>Stack Overflow - Most Loved, Dreaded, and Wanted language<br />
<a href="https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted">https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted</a>
</li>

<li>Rust vs Go (dva roky staré hodnocení, od té doby došlo k posunům v obou jazycích)<br />
<a href="http://jaredforsyth.com/2014/03/22/rust-vs-go/">http://jaredforsyth.com/2014/03/22/rust-vs-go/</a>
</li>

<li>Rust vs Go: My experience<br />
<a href="https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/">https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/</a>
</li>

<li>Friends of Rust (Organizations running Rust in production)<br />
<a href="https://www.rust-lang.org/en-US/friends.html">https://www.rust-lang.org/en-US/friends.html</a>
</li>

<li>Rust programs versus C++ g++<br />
<a href="https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp">https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp</a>
</li>

<li>Další benchmarky (nejedná se o reálné příklady &bdquo;ze života&ldquo;)<br />
<a href="https://github.com/kostya/benchmarks">https://github.com/kostya/benchmarks</a>
</li>

<li>Go na Redditu<br />
<a href="https://www.reddit.com/r/golang/">https://www.reddit.com/r/golang/</a>
</li>

<li>Rust vs. Go<br />
<a href="http://vschart.com/compare/rust/vs/go-language">http://vschart.com/compare/rust/vs/go-language</a>
</li>

<li>Abstraction without overhead: traits in Rust<br />
<a href="https://blog.rust-lang.org/2015/05/11/traits.html">https://blog.rust-lang.org/2015/05/11/traits.html</a>
</li>

<li>Functional Programming in Rust - Part 1 : Function Abstraction<br />
<a href="http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/">http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/</a>
</li>

<li>Of the emerging systems languages Rust, D, Go and Nim, which is the strongest language and why?<br />
<a href="https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why">https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why</a>
</li>

<li>Chytré ukazatele (moderní verze jazyka C++) [MSDN]<br />
<a href="https://msdn.microsoft.com/cs-cz/library/hh279674.aspx">https://msdn.microsoft.com/cs-cz/library/hh279674.aspx</a>
</li>

<li>UTF-8 Everywhere<br />
<a href="http://utf8everywhere.org/">http://utf8everywhere.org/</a>
</li>

<li>Rust by Example<br />
<a href="http://rustbyexample.com/">http://rustbyexample.com/</a>
</li>

<li>Rust oficiálně ve Fedoře<br />
<a href="https://mojefedora.cz/rust-oficialne-ve-fedore/">https://mojefedora.cz/rust-oficialne-ve-fedore/</a>
</li>

<li>Resource acquisition is initialization<br />
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization</a>
</li>

<li>TIOBE index (October 2016)<br />
<a href="http://www.tiobe.com/tiobe-index/">http://www.tiobe.com/tiobe-index/</a>
</li>

<li>Porovnání Go, D a Rustu na OpenHubu:<br />
<a href="https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits">https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits</a>
</li>

<li>String Types in Rust<br />
<a href="http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/">http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/</a>
</li>

<li>Trait (computer programming)<br />
<a href="https://en.wikipedia.org/wiki/Trait_%28computer_programming%29">https://en.wikipedia.org/wiki/Trait_%28computer_programming%29</a>
</li>

<li>Type inference<br />
<a href="https://en.wikipedia.org/wiki/Type_inference">https://en.wikipedia.org/wiki/Type_inference</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

