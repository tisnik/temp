<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Piston - knihovna pro práci s 2D i 3D grafikou v Rustu</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Piston - knihovna pro práci s 2D i 3D grafikou v Rustu</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V již třicáté deváté části seriálu o programovacím jazyku Rust se seznámíme se základními koncepty, na nichž je postavena knihovna Piston. Tato knihovna umožňuje práci s 2D i 3D grafikou s využitím různých &bdquo;backendů&ldquo;, mezi něž samozřejmě patří i moderní OpenGL.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Piston &ndash; knihovna pro práci s 2D i 3D grafikou v Rustu</a></p>
<p><a href="#k02">2. Koncepty, na nichž je knihovna Piston postavena</a></p>
<p><a href="#k03">3. Vykreslovací backendy</a></p>
<p><a href="#k04">4. Vytvoření nového projektu používajícího moduly Pistonu</a></p>
<p><a href="#k05">5. Stažení a překlad potřebných knihoven a modulů</a></p>
<p><a href="#k06">6. Práce s&nbsp;okny</a></p>
<p><a href="#k07">7. Vytvoření nového okna s&nbsp;jeho navázáním na OpenGL backend</a></p>
<p><a href="#k08">8. Smyčka událostí</a></p>
<p><a href="#k09">9. Překreslení 2D scény</a></p>
<p><a href="#k10">10. Hlavní funkce programu, překlad a spuštění aplikace</a></p>
<p><a href="#k11">11. Nepatrná vylepšení: specifikace velikosti okna, uzavření okna klávesou Esc, odstranění varování při překlad</a></p>
<p><a href="#k12">12. Filtrování událostí</a></p>
<p><a href="#k13">13. Grafický kontext</a></p>
<p><a href="#k14">14. Vykreslení čtverce</a></p>
<p><a href="#k15">15. Vykreslení úsečky</a></p>
<p><a href="#k16">16. Úplný zdrojový kód třetího demonstračního příkladu</a></p>
<p><a href="#k17">17. Dnes popsané struktury a traity</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Piston &ndash; knihovna pro práci s 2D i 3D grafikou v Rustu</h2>

<p>Po popisu skriptovacího jazyka <i>Dyon</i> [<a
href="https://www.root.cz/clanky/dyon-spojeni-prednosti-rustu-a-dynamicky-typovanych-programovacich-jazyku/">1</a>]
[<a
href="https://www.root.cz/clanky/dyon-spojeni-prednosti-rustu-a-dynamicky-typovanych-programovacich-jazyku-2-cast/">2</a>],
který je určený primárně pro použití v&nbsp;rustovském ekosystému, se zaměříme
na popis základních konceptů knihovny nazvané <i>Piston</i>. Knihovna Piston je
určena pro tvorbu aplikací s&nbsp;grafickým výstupem, ať se již jedná o
&bdquo;pouhou&ldquo; 2D grafiku či o plnohodnotnou trojrozměrnou grafiku
vykreslovanou s&nbsp;využitím grafického akcelerátoru. Může se jednat například
o multimediální aplikace, <a href="http://playformdev.blogspot.cz/">grafická
dema</a>, <a href="http://hematite.piston.rs/">hry</a> atd. Ve skutečnosti
knihovna Piston poměrně úzce souvisí s&nbsp;již popsaným Dyonem, protože Dyon
byl vytvořen mj.&nbsp;i proto, aby se práce s&nbsp;grafikou do jisté míry
zjednodušila (například se to týká podpory pro zpracování 2D, 3D i 4D vektorů,
zaměření na práci s&nbsp;poli atd.) a aby bylo možné obejít některé těžkosti
vyplývající z&nbsp;typového systému Rustu. Nicméně dnes se budeme zabývat
použitím knihovny Piston přímo z&nbsp;Rustu; způsob propojení Dyonu a Pistonu
bude popsán později.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Koncepty, na nichž je knihovna Piston postavena</h2>

<p>Termín &bdquo;knihovna Piston&ldquo; může být poněkud matoucí, protože si
pod ním můžeme představit monolitickou knihovnu či ucelený (ale taktéž
monolitický) framework. Ve skutečnosti je však na Piston implementován
v&nbsp;mnoha modulech a záleží jen na programátorovi, které moduly ve svém
projektu potřebuje a použije. Samotný překlad i slinkování se většinou provádí
přes nástroj <i>Cargo</i>, který již známe, takže správa projektu a modulů, na
nichž projekt závisí, je poměrně jednoduchá. Každý modul samozřejmě má svůj
repositář, který je možné (pro naprostou většinu standardních modulů) nalézt na
adrese <a
href="https://github.com/PistonDevelopers">https://github.com/PistonDevelopers</a>.
Povšimněte si, že zde nalezneme i repositář s&nbsp;dříve popsaným jazykem Dyon
či knihovnu <i>conrod</i>, která si zaslouží vlastní článek; některé další
repositáře obsahují různé utility apod.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Vykreslovací backendy</h2>

<p>Navíc Piston pro vykreslování používá poměrně striktní oddělení
<i>frontendu</i> od <i>backendu</i>, přičemž frontendem jsou v&nbsp;tomto
kontextu myšleny především moduly <strong>piston</strong> a
<strong>graphics</strong>, s&nbsp;jejichž využitím programátor řídí
vykreslování a roli backendu přebírají moduly, které se starají o vytvoření
okna, správu vstupních zařízení (klávesnice, myš, ...) a nakonec i o vlastní
rendering. Díky tomuto oddělení je například možné pro správu oken (vytvoření
okna a nastavení grafického kontextu) použít knihovnu Glutin (naprogramovanou
v&nbsp;Rustu), SDL2 (nativní C/C++), GLFW (nativní C/C++) atd., 2D a 3D grafiku
vykreslovat buď přes OpenGL, DirectX či softwarově (na obrazovku či do
rastrového obrázku) atd.</p>

<p>Poznámka: volba modulů pro <i>backend</i> může proběhnout jen na jediném
místě &ndash; v&nbsp;projektovém souboru. To ostatně uvidíme i ve všech třech
demonstračních příkladech, které si postupně popíšeme.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Vytvoření nového projektu používajícího moduly Pistonu</h2>

<p>Ukažme si nyní, jakým způsobem je možné vytvořit projekt používající moduly
knihovny Piston a jak se tento projekt následně přeloží a slinkuje. Není na tom
nic složitého, protože tvorbu nového projektu (s&nbsp;využitím nástroje Cargo)
již dobře známe:</p>

<pre>
<strong>cargo new --bin piston-demo1</strong>
</pre>

<p>Dále upravíme projektový soubor <strong>cargo.toml</strong>. Potřebujeme do
něj doplnit sekci <strong>[dependencies]</strong> a přidat do ní pět
modulů:</p>

<pre>
[package]
name = "piston-demo1"
version = "0.1.0"
authors = ["Pavel Tisnovsky &lt;ptisnovs@redhat.com&gt;"]
&nbsp;
[dependencies]
piston = "0.33.0"
piston2d-graphics = "0.21.1"
pistoncore-glutin_window = "0.39.0"
piston2d-opengl_graphics = "0.46.0"
piston_window = "0.70.0"
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Stažení a překlad potřebných knihoven a modulů</h2>

<p>Dále se pro jistotu přesvědčte, že používáte správnou verzi Rustu.
V&nbsp;tomto případě lze použít i nightly verzi (na testovacím stroji mám
starší verzi ze 7.8.2017):</p>

<pre>
<strong>rustup show</strong>
&nbsp;
Default host: x86_64-unknown-linux-gnu
&nbsp;
installed toolchains
--------------------
&nbsp;
stable-x86_64-unknown-linux-gnu
nightly-x86_64-unknown-linux-gnu (default)
&nbsp;
active toolchain
----------------
&nbsp;
nightly-x86_64-unknown-linux-gnu (default)
rustc 1.21.0-nightly (cbbe17aa7 2017-08-07)
</pre>

<p>Následuje časově nejdelší krok, v&nbsp;němž se poprvé stáhnou všechny moduly
ze sekce <strong>[dependencies]</strong> společně s&nbsp;(rekurzivně) závislými
moduly a knihovnami. Připravte se na stažení přibližně 100 MB! Ihned po stažení
se všechny moduly přeloží, což bude opět časově náročnější činnost
(v&nbsp;závislosti na výkonnosti počítače až několik minut):</p>

<pre>
<strong>cargo build</strong>
</pre>

<pre>
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading piston v0.33.0
 Downloading pistoncore-glutin_window v0.39.0
 Downloading piston2d-graphics v0.21.1
 Downloading piston2d-opengl_graphics v0.46.0
 Downloading pistoncore-input v0.19.0
 Downloading pistoncore-window v0.28.0
 Downloading pistoncore-event_loop v0.33.0
 Downloading piston-viewport v0.3.0
 Downloading piston-float v0.3.0
 Downloading shader_version v0.2.2
 Downloading glutin v0.9.2
 Downloading gl v0.6.3
 Downloading winit v0.7.6
 Downloading libc v0.2.30
 Downloading shared_library v0.1.7
 Downloading gl_generator v0.5.5
 Downloading xml-rs v0.6.1
 Downloading khronos_api v1.0.1
 Downloading interpolation v0.1.0
 Downloading vecmath v0.3.0
 Downloading piston-texture v0.5.0
 Downloading fnv v1.0.5
 Downloading rusttype v0.2.1
 Downloading piston-shaders_graphics2d v0.3.1
 Downloading image v0.15.0
 Downloading stb_truetype v0.2.1
 Downloading linked-hash-map v0.0.10
 Downloading arrayvec v0.3.23
 Downloading byteorder v0.4.2
 Downloading nodrop v0.1.9
 Downloading odds v0.2.25
 Downloading jpeg-decoder v0.1.13
 Downloading num-rational v0.1.39
 Downloading scoped_threadpool v0.1.7
 Downloading num-iter v0.1.34
 Downloading gif v0.9.2
 Downloading png v0.9.0
 Downloading enum_primitive v0.1.1
 Downloading byteorder v1.1.0
 Downloading rayon v0.8.2
 Downloading rayon-core v1.2.1
 Downloading futures v0.1.15
 Downloading coco v0.1.1
 Downloading scopeguard v0.3.2
 Downloading num-integer v0.1.35
 Downloading color_quant v1.0.0
 Downloading lzw v0.10.0
 Downloading deflate v0.7.16
 Downloading inflate v0.2.0
 Downloading adler32 v1.0.2
 Downloading x11-dl v2.15.0
 Downloading wayland-client v0.9.9
 Downloading osmesa-sys v0.1.2
 Downloading pkg-config v0.3.9
 Downloading tempfile v2.1.6
 Downloading wayland-kbd v0.9.1
 Downloading wayland-window v0.7.0
 Downloading wayland-protocols v0.9.9
 Downloading bitflags v0.7.0
 Downloading memmap v0.4.0
 Downloading dlib v0.3.1
 Downloading wayland-sys v0.9.9
 Downloading libloading v0.3.4
 Downloading target_build_utils v0.3.1
 Downloading phf v0.7.21
 Downloading serde_json v0.9.10
 Downloading phf_shared v0.7.21
 Downloading siphasher v0.2.2
 Downloading serde v0.9.15
 Downloading dtoa v0.4.2
 Downloading itoa v0.3.2
 Downloading phf_codegen v0.7.21
 Downloading phf_generator v0.7.21
 Downloading wayland-scanner v0.9.9
 Downloading xml-rs v0.3.6
 Downloading fs2 v0.2.5
 Downloading kernel32-sys v0.2.2
 Downloading winapi v0.2.8
 Downloading winapi-build v0.1.1
   Compiling adler32 v1.0.2
   Compiling siphasher v0.2.2
   Compiling serde v1.0.11
   Compiling linked-hash-map v0.0.10
   Compiling log v0.3.8
   Compiling rayon-core v1.2.1
   Compiling piston-float v0.3.0
   Compiling serde v0.9.15
   Compiling winapi-build v0.1.1
   Compiling unicode-xid v0.0.4
   Compiling interpolation v0.1.0
   Compiling fnv v1.0.5
   Compiling scopeguard v0.3.2
   Compiling piston-texture v0.5.0
   Compiling num-traits v0.1.40
   Compiling either v1.1.0
   Compiling quote v0.3.15
   Compiling odds v0.2.25
   Compiling scoped_threadpool v0.1.7
   Compiling read_color v0.1.0
   Compiling shader_version v0.2.2
   Compiling pkg-config v0.3.9
   Compiling color_quant v1.0.0
   Compiling futures v0.1.15
   Compiling byteorder v0.4.2
   Compiling byteorder v1.1.0
   Compiling piston-shaders_graphics2d v0.3.1
   Compiling lzw v0.10.0
   Compiling bitflags v0.9.1
   Compiling bitflags v0.7.0
   Compiling inflate v0.2.0
   Compiling itoa v0.3.2
   Compiling dtoa v0.4.2
   Compiling lazy_static v0.2.8
   Compiling libc v0.2.30
   Compiling winapi v0.2.8
   Compiling khronos_api v1.0.1
   Compiling phf_shared v0.7.21
   Compiling piston-viewport v0.3.0
   Compiling vecmath v0.3.0
   Compiling synom v0.11.3
   Compiling kernel32-sys v0.2.2
   Compiling coco v0.1.1
   Compiling enum_primitive v0.1.1
   Compiling num-integer v0.1.35
   Compiling nodrop v0.1.9
   Compiling x11-dl v2.15.0
   Compiling stb_truetype v0.2.1
   Compiling deflate v0.7.16
   Compiling xml-rs v0.6.1
   Compiling xml-rs v0.3.6
   Compiling gif v0.9.2
   Compiling serde_json v0.9.10
   Compiling num_cpus v1.6.2
   Compiling shared_library v0.1.7
   Compiling rand v0.3.16
   Compiling phf v0.7.21
   Compiling piston2d-graphics v0.21.1
   Compiling syn v0.11.11
   Compiling num-rational v0.1.39
   Compiling num-iter v0.1.34
   Compiling arrayvec v0.3.23
   Compiling wayland-scanner v0.9.9
   Compiling gl_generator v0.5.5
   Compiling osmesa-sys v0.1.2
   Compiling tempfile v2.1.6
   Compiling phf_generator v0.7.21
   Compiling png v0.9.0
   Compiling rusttype v0.2.1
   Compiling wayland-client v0.9.9
   Compiling wayland-protocols v0.9.9
   Compiling phf_codegen v0.7.21
   Compiling fs2 v0.2.5
   Compiling glutin v0.9.2
   Compiling gl v0.6.3
   Compiling serde_derive_internals v0.15.1
   Compiling rayon v0.8.2
   Compiling target_build_utils v0.3.1
   Compiling memmap v0.4.0
   Compiling serde_derive v1.0.11
   Compiling jpeg-decoder v0.1.13
   Compiling image v0.15.0
   Compiling pistoncore-input v0.19.0
   Compiling libloading v0.3.4
   Compiling pistoncore-window v0.28.0
   Compiling pistoncore-event_loop v0.33.0
   Compiling piston v0.33.0
   Compiling dlib v0.3.1
   Compiling wayland-sys v0.9.9
   Compiling wayland-kbd v0.9.1
   Compiling wayland-window v0.7.0
   Compiling winit v0.7.6
   Compiling piston2d-opengl_graphics v0.46.0
   Compiling pistoncore-glutin_window v0.39.0
   Compiling piston-demo1 v0.1.0 (file:///home/tester/rust/projects/piston-demo1)
    Finished dev [unoptimized + debuginfo] target(s) in 139.55 secs
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Práce s&nbsp;okny</h2>

<p>Jedním ze základních úkolů každé aplikace, která používá knihovnu Piston, je
vytvoření nového okna (to může být v&nbsp;případě potřeby zobrazeno přes celou
obrazovku), zajištění takzvaného grafického kontextu pro toto okno a spuštění
programové smyčky, v&nbsp;níž se zpracovávají události (<i>event loop</i>). Pro
usnadnění vytváření okna a jeho konfigurace je určen balíček (<i>crate</i>)
nazvaný jednoduše <strong>piston_window</strong>. Nové okno se vytvoří a
nakonfiguruje v&nbsp;nejjednodušším případě takto:</p>

<pre>
let mut window: PistonWindow =
    WindowSettings::new("titulek okna", [horizontální_rozměr, vertikální_rozměr])
        .build()
        .unwrap();
</pre>

<p>Povšimněte si poměrně typického &bdquo;zřetězení&ldquo; volání metod/funkcí.
Metoda <strong>build()</strong> vytvoří okno a vrátí hodnotu typu
<strong>Result</strong> obsahující buď nové okno nebo chybovou zprávu. Metodou
<strong>unwrap()</strong> pak ze struktury <strong>Result</strong> získáme
objekt představující okno. V&nbsp;případě potřeby je možné na tomto místě
použít pattern matching a vypsat případné chybové hlášení.</p>

<p>Ve výchozím nastavení se používá <a
href="https://github.com/gfx-rs/gfx">Gfx</a> a backend Glutin. Pokud budeme
potřebovat použít jiný backend, například knihovnu SDL2, postačuje nepatrná
změna typu:</p>

<pre>
let window: PistonWindow<strong>&lt;Sdl2Window&gt;</strong> =
    WindowSettings::new("titulek okna", [horizontální_rozměr, vertikální_rozměr])
        .build()
        .unwrap();
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vytvoření nového okna s&nbsp;jeho navázáním na OpenGL backend</h2>

<p>Metodou <strong>WindowSettings:opengl()</strong> lze nastavit verzi OpenGL,
která se použije pro vykreslování:</p>

<pre>
fn opengl(self, value: OpenGL) -&gt; Self
</pre>

<p>Tato metoda vrací stejnou (i když samozřejmě modifikovanou) instanci
struktury typu <strong>WindowSettings</strong>. To mj.&nbsp;znamená, že je
možné volání této metody zřetězit s&nbsp;ostatními metodami, zejména
s&nbsp;metodou <strong>WindowSettings:build</strong> (to jsme již viděli
v&nbsp;předchozí kapitole):</p>

<pre>
fn create_window() -&gt; PistonWindow {
    let opengl = OpenGL::V2_1;
&nbsp;
    WindowSettings::new("piston-demo1", (400, 300))
        .<strong>opengl(opengl)</strong>
        .build()
        .unwrap()
}
</pre>

<p>Podporované verze OpenGL:</p>

<table>
<tr><td>OpenGL::V2_0</td></tr>
<tr><td>OpenGL::V2_1</td></tr>
<tr><td>OpenGL::V3_0</td></tr>
<tr><td>OpenGL::V3_1</td></tr>
<tr><td>OpenGL::V3_2</td></tr>
<tr><td>OpenGL::V3_3</td></tr>
<tr><td>OpenGL::V4_0</td></tr>
<tr><td>OpenGL::V4_1</td></tr>
<tr><td>OpenGL::V4_2</td></tr>
<tr><td>OpenGL::V4_3</td></tr>
<tr><td>OpenGL::V4_4</td></tr>
<tr><td>OpenGL::V4_5</td></tr>
</table>

<p>Samozřejmě je nutné použít takovou verzi OpenGL, která je podporována GPU a
jejím ovladačem!</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Smyčka událostí</h2>

<p>Velmi důležitým konceptem, s&nbsp;nímž se v&nbsp;knihovně Piston (a
samozřejmě nejenom zde) setkáme, je systém událostí (<i>events</i>). Při běhu
aplikace totiž dochází ke vzniku různých událostí, které jsou vyvolány jak
samotným systémem (časovač...), tak i uživatelem (stisk klávesy, posun kurzoru
myši, ...). Na tyto události může aplikace nějakým způsobem reagovat, typicky
s&nbsp;použitím takzvaných <i>callback funkcí</i>.  Nejdůležitější událostí, na
níž musíme reagovat v&nbsp;každém případě, je požadavek překreslení okna
aplikace. Programová smyčka, v&nbsp;níž se postupně načítají události
z&nbsp;fronty událostí (<i>events queue</i>) může ve své nejjednodušší podobě
vypadat následovně:</p>

<pre>
fn event_loop(mut window: PistonWindow) -&gt; () {
    while let Some(event) = window.next() {
        on_event(&amp;mut window, event)
    }
}
</pre>

<p>Parametr typu <strong>PistonWindow</strong> musí být označen modifikátorem
<strong>mut</strong>!</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Překreslení 2D scény</h2>

<p>Samotná reakce na žádost o překreslení scény je v&nbsp;idiomatickém kódu
realizována uzávěrem, kterému se předají dva parametry &ndash; grafický kontext
a struktura typu <a
href="http://docs.piston.rs/piston_window/gfx_graphics/struct.GfxGraphics.html">gfx_graphics::GfxGraphics</a>,
která slouží pro zadávání příkazů pro kreslení (tuto strukturu si můžeme
představit jako jakýsi buffer příkazů, které jsou transformovány do volání
funkcí OpenGL, SDL2 atd.). Nejjednodušší reakce na žádost o překreslení okna
může vypadat takto:</p>

<pre>
fn on_event(window: &amp;mut PistonWindow, event: Event) -&gt; () {
    window.draw_2d(&amp;event,
                   |context, g2d| { clear([0.8, 1.0, 0.8, 1.0], g2d); });
}
</pre>

<p>Vidíme, že v&nbsp;uzávěru voláme jen funkci <a
href="http://docs.piston.rs/piston_window/graphics/fn.clear.html">clear</a>,
která smaže celé okno barvou R=80%, G=100%, B=80%. Poslední hodnotou je
průhlednost.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Hlavní funkce programu, překlad a spuštění aplikace</h2>

<p>Zbývá nám pouze doplnit hlavní funkci programu, v&nbsp;níž se vytvoří nové
okno a zavolá se obsluha smyčky událostí:</p>

<pre>
fn main() {
    let window: PistonWindow = create_window();
    event_loop(window);
}
</pre>

<p>Celý zdrojový kód dnešního prvního demonstračního příkladu vypadá
následovně:</p>

<pre>
extern crate piston_window;
use piston_window::*;
&nbsp;
&nbsp;
fn create_window() -&gt; PistonWindow {
    let opengl = OpenGL::V2_1;
&nbsp;
    WindowSettings::new("piston-demo1", (400, 300))
        .opengl(opengl)
        .build()
        .unwrap()
}
&nbsp;
&nbsp;
fn on_event(window: &amp;mut PistonWindow, event: Event) -&gt; () {
    window.draw_2d(&amp;event,
                   |context, g2d| { clear([0.8, 1.0, 0.8, 1.0], g2d); });
}
&nbsp;
&nbsp;
fn event_loop(mut window: PistonWindow) -&gt; () {
    while let Some(event) = window.next() {
        on_event(&amp;mut window, event)
    }
}
&nbsp;
&nbsp;
fn main() {
    let window: PistonWindow = create_window();
    event_loop(window);
}
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Nepatrná vylepšení: specifikace velikosti okna, uzavření okna klávesou Esc, odstranění varování při překladu</h2>

<p>Předchozí program můžeme vylepšit, a to hned několika způsoby. Nejprve se
podívejme na to, jakým způsobem je vlastně specifikována velikost okna. Při
pohledu na předchozí demonstrační příklad by se mohlo zdát, že se jedná o
jednoduchou n-tici (konkrétně dvojici) celočíselných hodnot představujících
šířku a výšku okna (zde konkrétně 400&times;300 pixelů):</p>

<pre>
WindowSettings::new("piston-demo1", <strong>(400, 300)</strong>)
    .opengl(opengl)
    .build()
    .unwrap()
</pre>

<p>Ve skutečnosti je velikost okna představována datovou strukturou nazvanou <a
href="http://docs.piston.rs/piston_window/window/struct.Size.html">Size</a>:</p>

<pre>
pub struct Size {
    pub width: u32,
    pub height: u32,
}
</pre>

<p>Důvod, proč bylo možné použít zápis <strong>(400, 300)</strong> je
jednoduchý &ndash; tato struktura mj.&nbsp;implementuje i dva traity
<strong>From&lt;[u32; 2]&gt;</strong> a <strong>From&lt;(u32, u32)&gt;</strong>
s&nbsp;předepsanými konverzními funkcemi:</p>

<pre>
fn from(value: [u32; 2]) -&gt; Size
fn from(value: (u32, u32)) -&gt; Size
</pre>

<p>Velikost okna však můžeme specifikovat i explicitně konstruktorem struktury
<strong>Size</strong>:</p>

<pre>
let window_size: Size = Size {
    width: width,
    height: height,
};
</pre>

<p>Další úprava spočívá v&nbsp;konfiguraci okna takovým způsobem, aby bylo
možné okno zavřít klávesou Esc. K&nbsp;tomu není nutné psát event handler, ale
postačí použít metodu <strong>exit_on_esc()</strong> pro datovou strukturu
<strong>window::WindowSettings</strong>:</p>

<pre>
fn exit_on_esc(self, value: bool) -&gt; Self
</pre>

<p>Povšimněte si, že tato metoda vrací modifikovaný strukturu
s&nbsp;konfigurací okna, takže ji lze použít v&nbsp;řetězci nastavení:</p>

<pre>
fn create_window(width: u32, height: u32) -&gt; PistonWindow {
    let opengl = OpenGL::V2_1;
&nbsp;
    let window_size: Size = Size {
        width: width,
        height: height,
    };
&nbsp;
    WindowSettings::new("piston-demo2", <strong>window_size</strong>)
        .<strong>exit_on_esc(true)</strong>
        .opengl(opengl)
        .build()
        .unwrap()
}
</pre>

<p>Poslední úprava zamezí zobrazení varování překladače o tom, že
v&nbsp;anonymní funkci zavolané při požadavku na překreslení okna (prozatím)
nevyužíváme první parametr. Pokud tento parametr přejmenujeme na _
(podtržítko), nebude varování vypisováno, protože podtržítko je považováno za
zástupné jméno (<i>placeholder</i>), s&nbsp;čímž jsme se již ostatně několikrát
setkali:</p>

<pre>
fn on_event(window: &amp;mut PistonWindow, event: Event) -&gt; () {
    window.draw_2d(&amp;event,
                   |_, g2d| { clear([0.8, 1.0, 0.8, 1.0], g2d); });
}
</pre>

<p>Úplný zdrojový kód dnešního druhého demonstračního příkladu, v&nbsp;němž
byly provedeny všechny výše popsané změny, vypadá takto:</p>

<pre>
extern crate piston_window;
use piston_window::*;
&nbsp;
&nbsp;
fn create_window(width: u32, height: u32) -&gt; PistonWindow {
    let opengl = OpenGL::V2_1;
&nbsp;
    let window_size: Size = Size {
        width: width,
        height: height,
    };
&nbsp;
    WindowSettings::new("piston-demo2", window_size)
        .exit_on_esc(true)
        .opengl(opengl)
        .build()
        .unwrap()
}
&nbsp;
&nbsp;
fn on_event(window: &amp;mut PistonWindow, event: Event) -&gt; () {
    window.draw_2d(&amp;event,
                   |_, g2d| { clear([0.8, 1.0, 0.8, 1.0], g2d); });
}
&nbsp;
&nbsp;
fn event_loop(mut window: PistonWindow) -&gt; () {
    while let Some(event) = window.next() {
        on_event(&amp;mut window, event)
    }
}
&nbsp;
&nbsp;
fn main() {
    let window: PistonWindow = create_window(400, 300);
    event_loop(window);
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Filtrování událostí</h2>

<p>Metoda <strong>PistonWindow.next()</strong> vrací hodnotu (datovou
strukturu) typu <strong>Option&lt;Event&gt;</strong>. Jedná se tedy o
potenciálně prázdnou &bdquo;obálku&ldquo; obsahující objekt typu
<strong>Event</strong>, což je ve skutečnosti výčet, který může reprezentovat
události spadající do tří skupin:</p>

<ol>
<li><strong>Input</strong> &ndash; veškeré události vznikající činností uživatele</li>
<li><strong>Loop</strong> &ndash; periodicky se opakující události (idle, překreslení okna...)</li>
<li>Další specifické, konfigurovatelné události (nebudeme je používat)</li>
</ol>

<p>Do první skupiny řadíme události:</p>

<ol>
<li>Button</li>
<li>Move</li>
<li>Text</li>
<li>Resize</li>
<li>Focus</li>
<li>Cursor</li>
<li>Close</li>
</ol>

<p>Do druhé skupiny pak události:</p>

<ol>
<li>Render</li>
<li>AfterRender</li>
<li>Update</li>
<li>Idle</li>
</ol>

<p>Jak lze však zjisti, zda událost, která je uložena v&nbsp;konkrétní instanci
<strong>Option&lt;Event&gt;</strong>, odpovídá žádosti o překreslení okna?
Můžeme využít toho, že je pro tuto událost traitem
<strong>input::RenderEvent</strong> (<a
href="http://docs.piston.rs/piston_window/src/input/render.rs.html#43-56">http://docs.piston.rs/piston_window/src/input/render.rs.html#43-56</a>)
předepsána metoda <a
href="http://docs.piston.rs/piston_window/src/input/render.rs.html#38-40">render_args</a>:</p>

<pre>
fn render_args(&amp;self) -&gt; Option&lt;RenderArgs&gt;
</pre>

<p>Pokud se skutečně jedná o žádost o překreslení okna, vrátí tato metoda
hodnotu <strong>Some(RenderArgs)</strong>, v&nbsp;opačném případě vrátí
<strong>None</strong>. To znamená, že původní funkci:</p>

<pre>
fn event_loop(mut window: PistonWindow) -&gt; () {
    while let Some(event) = window.next() {
        on_event(&amp;mut window, event)
    }
}
</pre>

<p>můžeme přepsat tak, aby se v&nbsp;ní testovalo, zda právě zpracovávaná
událost vyžaduje překreslení okna aplikace, a to testem na
<strong>Some</strong>:</p>

<pre>
fn event_loop(mut window: PistonWindow) -&gt; () {
    while let Some(event) = window.next() {
        if let Some(_) = event.render_args() {
            on_event(&amp;mut window, event)
        }
    }
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Grafický kontext</h2>

<p>Grafický kontext je struktura nesoucí informaci o pohledové a transformační
matici, o takzvaném viewportu (přes něj se zjednodušeně řečeno provádí mapování
2D souřadnic získaných po ortogonální či perspektivní projekci na adresy pixelů
na obrazovce) i o aktuálně nastavených vykreslovacích režimech. Tato struktura
vypadá následovně:</p>

<pre>
pub struct Context {
    pub viewport: Option&lt;Viewport&gt;,
    pub view: Matrix2d,
    pub transform: Matrix2d,
    pub draw_state: DrawState,
}
</pre>

<p>S&nbsp;touto strukturou se prozatím setkáme při kreslení 2D objektů, protože
u nich je zapotřebí přečíst transformační matici
(<strong>Context.transform</strong>).</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Vykreslení čtverce</h2>

<p>Podívejme se nyní na to, jak je možné vykreslit nějaký jednoduchý 2D
obrazec. Zcela nejjednodušší 2D entitou není v&nbsp;Pistonu kupodivu ani bod
ani úsečka, ale obdélník nebo čtverec :-) Při vykreslování čtverce musíme
především specifikovat jeho barvu, což je pole čtyř hodnot typu
<strong>f32</strong>:</p>

<pre>
const RED:   [f32; 4] = [1.0, 0.0, 0.0, 1.0];
</pre>

<p>Dále je nutné vytvořit strukturu obsahující pozici a rozměry čtverce.
Povšimněte si, že souřadnice i rozměry jsou typu <strong>f64</strong> a nikoli
<strong>i32</strong> či dokonce jen <strong>i16</strong>. Musíme totiž počítat
s&nbsp;transformacemi:</p>

<pre>
const SQUARE_SIZE: f64 = 50.0;
&nbsp;
let size = window.window.size();
let width = size.width as f64;
let height = size.height as f64;
&nbsp;
let x = (width - SQUARE_SIZE)/2.0;
let y = (height - SQUARE_SIZE)/2.0;
let square = rectangle::square(x, y, SQUARE_SIZE);
</pre>

<p>Vlastní vykreslení obdélníka či čtverce vyžaduje znalost transformační
matice (získáme z&nbsp;grafického kontextu) a instanci G2d (tu získáme jako
parametr vstupující do volaného uzávěru):</p>

<pre>
window.draw_2d(&amp;event,
               |context, g2d| { clear([0.8, 1.0, 0.8, 1.0], g2d);
                                g2d.clear_stencil(0);
                                rectangle(RED, square, context.transform, g2d); });
</pre>

<p>Celá obsluha žádosti o překreslení okna může vypadat takto:</p>

<pre>
fn on_event(window: &amp;mut PistonWindow, event: Event) -&gt; () {
    const RED:   [f32; 4] = [1.0, 0.0, 0.0, 1.0];
    const SQUARE_SIZE: f64 = 50.0;
&nbsp;
    let size = window.window.size();
    let width = size.width as f64;
    let height = size.height as f64;
&nbsp;
    let x = (width - SQUARE_SIZE)/2.0;
    let y = (height - SQUARE_SIZE)/2.0;
    let square = rectangle::square(x, y, SQUARE_SIZE);
&nbsp;
    window.draw_2d(&amp;event,
                   |context, g2d| { clear([0.8, 1.0, 0.8, 1.0], g2d);
                                    g2d.clear_stencil(0);
                                    rectangle(RED, square, context.transform, g2d); });
}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Vykreslení úsečky</h2>

<p>Při vykreslování úseček postupujeme podobně jako při vykreslování obdélníku
či čtverce, ovšem musíme navíc specifikovat šířku úsečky. Struktura
reprezentující geometrii úsečky je triviální &ndash; jedná se o pole čtyř
hodnot typu <strong>f64</strong> s&nbsp;obvyklým významem [x1, y2, x2, y1].
Vykreslení dvou úseček představujících úhlopříčky okna tedy bude vypadat
takto:</p>

<pre>
fn on_event(window: &amp;mut PistonWindow, event: Event) -&gt; () {
    const BLUE:  [f32; 4] = [0.0, 0.0, 1.0, 1.0];
    const LINE_BORDER: f64 = 10.0;
&nbsp;
    let size = window.window.size();
    let width = size.width as f64;
    let height = size.height as f64;
&nbsp;
    let x1 = LINE_BORDER;
    let y1 = LINE_BORDER;
&nbsp;
    let x2 = width - LINE_BORDER;
    let y2 = height - LINE_BORDER;
&nbsp;
    let line1:[f64;4] = [x1, y1, x2, y2];
    let line2:[f64;4] = [x1, y2, x2, y1];
&nbsp;
    window.draw_2d(&amp;event,
                   |context, g2d| { clear([0.8, 1.0, 0.8, 1.0], g2d);
                                    g2d.clear_stencil(0);
                                    line(BLUE, 1., line1, context.transform, g2d);
                                    line(BLUE, 0.5, line2, context.transform, g2d); });
}
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Úplný zdrojový kód třetího demonstračního příkladu</h2>

<p>V&nbsp;předchozích dvou kapitolách jsme si ukazovali části kódu třetího
příkladu, který vypadá následovně:</p>

<pre>
extern crate piston_window;
use piston_window::*;
&nbsp;
&nbsp;
fn create_window(width: u32, height: u32) -&gt; PistonWindow {
    let opengl = OpenGL::V2_1;
&nbsp;
    let window_size: Size = Size {
        width: width,
        height: height,
    };
&nbsp;
    WindowSettings::new("piston-demo3", window_size)
        .exit_on_esc(true)
        .opengl(opengl)
        .build()
        .unwrap()
}
&nbsp;
&nbsp;
fn on_event(window: &amp;mut PistonWindow, event: Event) -&gt; () {
    const RED:   [f32; 4] = [1.0, 0.0, 0.0, 1.0];
    const BLUE:  [f32; 4] = [0.0, 0.0, 1.0, 1.0];
    const SQUARE_SIZE: f64 = 50.0;
    const LINE_BORDER: f64 = 10.0;
&nbsp;
    let size = window.window.size();
    let width = size.width as f64;
    let height = size.height as f64;
&nbsp;
    let x = (width - SQUARE_SIZE)/2.0;
    let y = (height - SQUARE_SIZE)/2.0;
    let square = rectangle::square(x, y, SQUARE_SIZE);
&nbsp;
    let x1 = LINE_BORDER;
    let y1 = LINE_BORDER;
&nbsp;
    let x2 = width - LINE_BORDER;
    let y2 = height - LINE_BORDER;
&nbsp;
    let line1:[f64;4] = [x1, y1, x2, y2];
    let line2:[f64;4] = [x1, y2, x2, y1];
&nbsp;
    window.draw_2d(&amp;event,
                   |context, g2d| { clear([0.8, 1.0, 0.8, 1.0], g2d);
                                    g2d.clear_stencil(0);
                                    line(BLUE, 1., line1, context.transform, g2d);
                                    line(BLUE, 0.5, line2, context.transform, g2d);
                                    rectangle(RED, square, context.transform, g2d); });
}
&nbsp;
&nbsp;
fn event_loop(mut window: PistonWindow) -&gt; () {
    while let Some(event) = window.next() {
        if let Some(_) = event.render_args() {
            on_event(&amp;mut window, event)
        }
    }
}
&nbsp;
&nbsp;
fn main() {
    let window: PistonWindow = create_window(400, 300);
    event_loop(window);
}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Dnes popsané struktury a traity</h2>

<p>V&nbsp;této kapitole jsou uvedeny odkazy na dokumentaci ke všem dnes
popsaným strukturám a traitům, které patří do knihovny Piston:</p>

<table>
<tr><th>Struktura/Trait</th><th>Dokumentace</th></tr>
<tr><td>Struct window::WindowSettings</td><td><a href="http://docs.piston.rs/piston_window/window/struct.WindowSettings.html">http://docs.piston.rs/piston_window/window/struct.WindowSettings.html</a></td></tr>
<tr><td>Struct window::Size</td><td><a href="http://docs.piston.rs/piston_window/window/struct.Size.html">http://docs.piston.rs/piston_window/window/struct.Size.html</a></td></tr>
<tr><td>Struct piston_window::PistonWindow</td><td><a href="http://docs.piston.rs/piston_window/piston_window/struct.PistonWindow.html">http://docs.piston.rs/piston_window/piston_window/struct.PistonWindow.html</a></td></tr>
<tr><td>Trait window::OpenGLWindow</td><td><a href="http://docs.piston.rs/piston_window/window/trait.OpenGLWindow.html">http://docs.piston.rs/piston_window/window/trait.OpenGLWindow.html</a></td></tr>
<tr><td>Trait window::BuildFromWindowSettings</td><td><a href="http://docs.piston.rs/piston_window/window/trait.BuildFromWindowSettings.html">http://docs.piston.rs/piston_window/window/trait.BuildFromWindowSettings.html</a></td></tr>
<tr><td>Trait graphics::Graphics</td><td><a href="http://docs.piston.rs/piston_window/graphics/trait.Graphics.html">http://docs.piston.rs/piston_window/graphics/trait.Graphics.html</a></td></tr>
<tr><td>Trait input::RenderEvent</td><td><a href="http://docs.piston.rs/piston_window/input/trait.RenderEvent.html">http://docs.piston.rs/piston_window/input/trait.RenderEvent.html</a></td></tr>
<tr><td>Enum shader_version::opengl::OpenGL</td><td><a href="http://docs.piston.rs/piston_window/shader_version/opengl/enum.OpenGL.html">http://docs.piston.rs/piston_window/shader_version/opengl/enum.OpenGL.html</a></td></tr>
</table>
 


<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popisované demonstrační příklady (Rustovské projekty) byly,
ostatně podobně jako ve všech předchozích částech <a
href="https://www.root.cz/serialy/programovaci-jazyk-rust/">tohoto seriálu</a>,
uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě
bez nutnosti klonovat celý repositář (ovšem u projektů je lepší mít celý
repositář, abyste nemuseli pracně stahovat všechny potřebné soubory):</p>

<table>
<tr><th>Příklad</th><th>Adresa</th></tr>
<tr><td>První projekt</td><td>piston-demo1</td></tr>
<tr><td>Cargo.toml</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/piston-demo1/Cargo.toml">https://github.com/tisnik/presentations/blob/master/rust/projects/piston-demo1/Cargo.toml</a></td></tr>
<tr><td>main.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/piston-demo1/src/main.rs">https://github.com/tisnik/presentations/blob/master/rust/projects/piston-demo1/src/main.rs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Druhý projekt</td><td>piston-demo2</td></tr>
<tr><td>Cargo.toml</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/piston-demo2/Cargo.toml">https://github.com/tisnik/presentations/blob/master/rust/projects/piston-demo2/Cargo.toml</a></td></tr>
<tr><td>main.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/piston-demo2/src/main.rs">https://github.com/tisnik/presentations/blob/master/rust/projects/piston-demo2/src/main.rs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Třetí projekt</td><td>piston-demo3</td></tr>
<tr><td>Cargo.toml</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/piston-demo3/Cargo.toml">https://github.com/tisnik/presentations/blob/master/rust/projects/piston-demo3/Cargo.toml</a></td></tr>
<tr><td>main.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/piston-demo3/src/main.rs">https://github.com/tisnik/presentations/blob/master/rust/projects/piston-demo3/src/main.rs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na Internetu</h2>

<ol>

<li>Secrets design - optional information in `bool` and `f64`<br />
<a href="https://github.com/PistonDevelopers/dyon/issues/266">https://github.com/PistonDevelopers/dyon/issues/266</a>
</li>

<li>Option value design<br />
<a href="https://github.com/PistonDevelopers/dyon/issues/172">https://github.com/PistonDevelopers/dyon/issues/172</a>
</li>

<li>Result value design (`err(x)/ok(x)`)<br />
<a href="https://github.com/PistonDevelopers/dyon/issues/82">https://github.com/PistonDevelopers/dyon/issues/82</a>
</li>

<li>∑/sum, ∏/prod, min, max, sift, ∃/any, ∀/all loops<br />
<a href="https://github.com/PistonDevelopers/dyon/issues/119">https://github.com/PistonDevelopers/dyon/issues/119</a>
</li>

<li>Dyon: tutoriál<br />
<a href="http://www.piston.rs/dyon-tutorial/">http://www.piston.rs/dyon-tutorial/</a>
</li>

<li>Repositář s&nbsp;programovacím jazykem Dyon<br />
<a href="https://github.com/PistonDevelopers/dyon">https://github.com/PistonDevelopers/dyon</a>
</li>

<li>Dyon: A rusty dynamically typed scripting language<br />
<a href="https://rust.libhunt.com/project/dyon">https://rust.libhunt.com/project/dyon</a>
</li>

<li>Dyon snippets<br />
<a href="https://github.com/PistonDevelopers/dyon_snippets">https://github.com/PistonDevelopers/dyon_snippets</a>
</li>

<li>Scripting without garbage collector<br />
<a href="http://blog.piston.rs/2016/02/21/scripting-without-garbage-collector/">http://blog.piston.rs/2016/02/21/scripting-without-garbage-collector/</a>
</li>

<li>Podpora pro &bdquo;matematické&ldquo; smyčky<br />
<a href="https://github.com/PistonDevelopers/dyon/issues/119">https://github.com/PistonDevelopers/dyon/issues/119</a>
</li>

<li>Rust-clippy Wiki<br />
<a href="https://github.com/rust-lang-nursery/rust-clippy/wiki">https://github.com/rust-lang-nursery/rust-clippy/wiki</a>
</li>

<li>Rust-clippy<br />
<a href="https://rust.libhunt.com/project/rust-clippy">https://rust.libhunt.com/project/rust-clippy</a>
</li>

<li>ndarray - dokumentace k&nbsp;modulu<br />
<a href="https://bluss.github.io/rust-ndarray/master/ndarray/index.html">https://bluss.github.io/rust-ndarray/master/ndarray/index.html</a>
</li>

<li>ndarray - Crate<br />
<a href="https://crates.io/crates/ndarray">https://crates.io/crates/ndarray</a>
</li>

<li>rustup<br />
<a href="https://www.rustup.rs/">https://www.rustup.rs/</a>
</li>

<li>rustup: the Rust toolchain installer (Git repositář + dokumentace)<br />
<a href="https://github.com/rust-lang-nursery/rustup.rs">https://github.com/rust-lang-nursery/rustup.rs</a>
</li>

<li>The Rust FFI Omnibus<br />
<a href="http://jakegoulding.com/rust-ffi-omnibus/">http://jakegoulding.com/rust-ffi-omnibus/</a>
</li>

<li>Build Script Support<br />
<a href="http://doc.crates.io/build-script.html">http://doc.crates.io/build-script.html</a>
</li>

<li>Calling Rust From Python<br />
<a href="https://bheisler.github.io/post/calling-rust-in-python/">https://bheisler.github.io/post/calling-rust-in-python/</a>
</li>

<li>Calling Rust in Python (komentáře k předchozímu článku)<br />
<a href="https://www.reddit.com/r/rust/comments/63iy5a/calling_rust_in_python/">https://www.reddit.com/r/rust/comments/63iy5a/calling_rust_in_python/</a>
</li>

<li>CFFI Documentation<br />
<a href="https://cffi.readthedocs.io/en/latest/">https://cffi.readthedocs.io/en/latest/</a>
</li>

<li>Build Script Support<br />
<a href="http://doc.crates.io/build-script.html">http://doc.crates.io/build-script.html</a>
</li>

<li>Creating a shared and static library with the gnu compiler [gcc]<br />
<a href="http://www.adp-gmbh.ch/cpp/gcc/create_lib.html">http://www.adp-gmbh.ch/cpp/gcc/create_lib.html</a>
</li>

<li>ctypes — A foreign function library for Python<br />
<a href="https://docs.python.org/2/library/ctypes.html">https://docs.python.org/2/library/ctypes.html</a>
</li>

<li>FFI: Foreign Function Interface<br />
<a href="https://doc.rust-lang.org/book/ffi.html">https://doc.rust-lang.org/book/ffi.html</a>
</li>

<li>Primitive Type pointer<br />
<a href="https://doc.rust-lang.org/std/primitive.pointer.html">https://doc.rust-lang.org/std/primitive.pointer.html</a>
</li>

<li>Cargo: správce projektů a balíčků pro programovací jazyk Rust<br />
<a href="https://mojefedora.cz/cargo-spravce-projektu-a-balicku-pro-programovaci-jazyk-rust/">https://mojefedora.cz/cargo-spravce-projektu-a-balicku-pro-programovaci-jazyk-rust/</a>
</li>

<li>Network Communication and Serialization in Rust<br />
<a href="https://www.safaribooksonline.com/blog/2014/01/28/network-communication-serialization-rust/">https://www.safaribooksonline.com/blog/2014/01/28/network-communication-serialization-rust/</a>
</li>

<li>Crate bincode<br />
<a href="http://tyoverby.com/bincode/bincode/index.html">http://tyoverby.com/bincode/bincode/index.html</a>
</li>

<li>Struct std::fs::File<br />
<a href="https://doc.rust-lang.org/std/fs/struct.File.html">https://doc.rust-lang.org/std/fs/struct.File.html</a>
</li>

<li>Trait std::io::Seek<br />
<a href="https://doc.rust-lang.org/std/io/trait.Seek.html">https://doc.rust-lang.org/std/io/trait.Seek.html</a>
</li>

<li>Trait std::io::Read<br />
<a href="https://doc.rust-lang.org/std/io/trait.Read.html">https://doc.rust-lang.org/std/io/trait.Read.html</a>
</li>

<li>Trait std::io::Write<br />
<a href="https://doc.rust-lang.org/std/io/trait.Write.html">https://doc.rust-lang.org/std/io/trait.Write.html</a>
</li>

<li>Trait std::io::BufRead<br />
<a href="https://doc.rust-lang.org/std/io/trait.BufRead.html">https://doc.rust-lang.org/std/io/trait.BufRead.html</a>
</li>

<li>Module std::io::prelude<br />
<a href="https://doc.rust-lang.org/std/io/prelude/index.html">https://doc.rust-lang.org/std/io/prelude/index.html</a>
</li>

<li>std::net::IpAddr<br />
<a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">https://doc.rust-lang.org/std/net/enum.IpAddr.html</a>
</li>

<li>std::net::Ipv4Addr<br />
<a href="https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html">https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html</a>
</li>

<li>std::net::Ipv6Addr<br />
<a href="https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html">https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html</a>
</li>

<li>TcpListener<br />
<a href="https://doc.rust-lang.org/std/net/struct.TcpListener.html">https://doc.rust-lang.org/std/net/struct.TcpListener.html</a>
</li>

<li>TcpStream<br />
<a href="https://doc.rust-lang.org/std/net/struct.TcpStream.html">https://doc.rust-lang.org/std/net/struct.TcpStream.html</a>
</li>

<li>Binary heap (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Binary_heap">https://en.wikipedia.org/wiki/Binary_heap</a>
</li>

<li>Binární halda (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_halda">https://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_halda</a>
</li>

<li>Halda (datová struktura)<br />
<a href="https://cs.wikipedia.org/wiki/Halda_%28datov%C3%A1_struktura%29">https://cs.wikipedia.org/wiki/Halda_%28datov%C3%A1_struktura%29</a>
</li>

<li>Struct std::collections::HashSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html">https://doc.rust-lang.org/std/collections/struct.HashSet.html</a>
</li>

<li>Struct std::collections::BTreeSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html">https://doc.rust-lang.org/std/collections/struct.BTreeSet.html</a>
</li>

<li>Struct std::collections::BinaryHeap<br />
<a href="https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html">https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html</a>
</li>

<li>Set (abstract data type)<br />
<a href="https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support">https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support</a>
</li>

<li>Associative array<br />
<a href="https://en.wikipedia.org/wiki/Associative_array">https://en.wikipedia.org/wiki/Associative_array</a>
</li>

<li>Hash Table<br />
<a href="https://en.wikipedia.org/wiki/Hash_table">https://en.wikipedia.org/wiki/Hash_table</a>
</li>

<li>B-tree<br />
<a href="https://en.wikipedia.org/wiki/B-tree">https://en.wikipedia.org/wiki/B-tree</a>
</li>

<li>Pedro Celis: Robin Hood Hashing (naskenované PDF!)<br />
<a href="https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf">https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf</a>
</li>

<li>Robin Hood hashing<br />
<a href="http://codecapsule.com/2013/11/11/robin-hood-hashing/">http://codecapsule.com/2013/11/11/robin-hood-hashing/</a>
</li>

<li>Robin Hood hashing: backward shift deletion<br />
<a href="http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/">http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/</a>
</li>

<li>Module std::collections<br />
<a href="https://doc.rust-lang.org/std/collections/">https://doc.rust-lang.org/std/collections/</a>
</li>

<li>Module std::vec<br />
<a href="https://doc.rust-lang.org/nightly/std/vec/index.html">https://doc.rust-lang.org/nightly/std/vec/index.html</a>
</li>

<li>Struct std::collections::VecDeque<br />
<a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html">https://doc.rust-lang.org/std/collections/struct.VecDeque.html</a>
</li>

<li>Struct std::collections::LinkedList<br />
<a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html">https://doc.rust-lang.org/std/collections/struct.LinkedList.html</a>
</li>

<li>Module std::fmt<br />
<a href="https://doc.rust-lang.org/std/fmt/">https://doc.rust-lang.org/std/fmt/</a>
</li>

<li>Macro std::println<br />
<a href="https://doc.rust-lang.org/std/macro.println.html">https://doc.rust-lang.org/std/macro.println.html</a>
</li>

<li>Enum std::result::Result<br />
<a href="https://doc.rust-lang.org/std/result/enum.Result.html">https://doc.rust-lang.org/std/result/enum.Result.html</a>
</li>

<li>Module std::result<br />
<a href="https://doc.rust-lang.org/std/result/">https://doc.rust-lang.org/std/result/</a>
</li>

<li>Result<br />
<a href="http://rustbyexample.com/std/result.html">http://rustbyexample.com/std/result.html</a>
</li>

<li>Rust stdlib: Option<br />
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">https://doc.rust-lang.org/std/option/enum.Option.html</a>
</li>

<li>Module std::option<br />
<a href="https://doc.rust-lang.org/std/option/index.html">https://doc.rust-lang.org/std/option/index.html</a>
</li>

<li>Rust by example: option<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>Rust by example: if-let<br />
<a href="http://rustbyexample.com/flow_control/if_let.html">http://rustbyexample.com/flow_control/if_let.html</a>
</li>

<li>Rust by example: while let<br />
<a href="http://rustbyexample.com/flow_control/while_let.html">http://rustbyexample.com/flow_control/while_let.html</a>
</li>

<li>Rust by example: Option&lt;i32&gt;<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>An Overview of Macros in Rust<br />
<a href="http://words.steveklabnik.com/an-overview-of-macros-in-rust">http://words.steveklabnik.com/an-overview-of-macros-in-rust</a>
</li>

<li>A Practical Intro to Macros in Rust 1.0<br />
<a href="https://danielkeep.github.io/practical-intro-to-macros.html">https://danielkeep.github.io/practical-intro-to-macros.html</a>
</li>

<li>The Rust Programming Language: macros<br />
<a href="https://doc.rust-lang.org/beta/book/macros.html">https://doc.rust-lang.org/beta/book/macros.html</a>
</li>

<li>Rust by example: 15 macro_rules!<br />
<a href="http://rustbyexample.com/macros.html">http://rustbyexample.com/macros.html</a>
</li>

<li>Primitive Type isize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.isize.html">https://doc.rust-lang.org/nightly/std/primitive.isize.html</a>
</li>

<li>Primitive Type usize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">https://doc.rust-lang.org/nightly/std/primitive.usize.html</a>
</li>

<li>Primitive Type array<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.array.html">https://doc.rust-lang.org/nightly/std/primitive.array.html</a>
</li>

<li>Module std::slice<br />
<a href="https://doc.rust-lang.org/nightly/std/slice/">https://doc.rust-lang.org/nightly/std/slice/</a>
</li>

<li>Rust by Example: 2.3 Arrays and Slices<br />
<a href="http://rustbyexample.com/primitives/array.html">http://rustbyexample.com/primitives/array.html</a>
</li>

<li>What is the difference between Slice and Array (stackoverflow)<br />
<a href="http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array">http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array</a>
</li>

<li>Learning Rust With Entirely Too Many Linked Lists<br />
<a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/">http://cglab.ca/~abeinges/blah/too-many-lists/book/</a>
</li>

<li>Testcase: linked list<br />
<a href="http://rustbyexample.com/custom_types/enum/testcase_linked_list.html">http://rustbyexample.com/custom_types/enum/testcase_linked_list.html</a>
</li>

<li>Operators and Overloading<br />
<a href="https://doc.rust-lang.org/book/operators-and-overloading.html">https://doc.rust-lang.org/book/operators-and-overloading.html</a>
</li>

<li>Module std::ops<br />
<a href="https://doc.rust-lang.org/std/ops/index.html">https://doc.rust-lang.org/std/ops/index.html</a>
</li>

<li>Module std::cmp<br />
<a href="https://doc.rust-lang.org/std/cmp/index.html">https://doc.rust-lang.org/std/cmp/index.html</a>
</li>

<li>Trait std::ops::Add<br />
<a href="https://doc.rust-lang.org/stable/std/ops/trait.Add.html">https://doc.rust-lang.org/stable/std/ops/trait.Add.html</a>
</li>

<li>Trait std::ops::AddAssign<br />
<a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html">https://doc.rust-lang.org/std/ops/trait.AddAssign.html</a>
</li>

<li>Trait std::ops::Drop<br />
<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">https://doc.rust-lang.org/std/ops/trait.Drop.html</a>
</li>

<li>Trait std::cmp::Eq<br />
<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">https://doc.rust-lang.org/std/cmp/trait.Eq.html</a>
</li>

<li>Struct std::boxed::Box<br />
<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">https://doc.rust-lang.org/std/boxed/struct.Box.html</a>
</li>

<li>Explore the ownership system in Rust<br />
<a href="https://nercury.github.io/rust/guide/2015/01/19/ownership.html">https://nercury.github.io/rust/guide/2015/01/19/ownership.html</a>
</li>

<li>Rust's ownership and move semantic<br/>
<a href="http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics">http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics</a>
</li>

<li>Trait std::marker::Copy<br/>
<a href="https://doc.rust-lang.org/stable/std/marker/trait.Copy.html">https://doc.rust-lang.org/stable/std/marker/trait.Copy.html</a>
</li>

<li>Trait std::clone::Clone<br />
<a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html">https://doc.rust-lang.org/stable/std/clone/trait.Clone.html</a>
</li>

<li>The Stack and the Heap<br />
<a href="https://doc.rust-lang.org/book/the-stack-and-the-heap.html">https://doc.rust-lang.org/book/the-stack-and-the-heap.html</a>
</li>

<li>Rust Compare: Pointers &amp; References<br />
<a href="http://www.rust-compare.com/site/pointers.html">http://www.rust-compare.com/site/pointers.html</a>
</li>

<li>Rust Compare: Parameters<br />
<a href="http://www.rust-compare.com/site/params.html">http://www.rust-compare.com/site/params.html</a>
</li>

<li>Why does this compile? Automatic dereferencing?<br />
<a href="https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183">https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183</a>
</li>

<li>Understanding Pointers, Ownership, and Lifetimes in Rust<br />
<a href="http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html">http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html</a>
</li>

<li>Rust lang series episode #25 — pointers (#rust-series)<br />
<a href="https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series">https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series</a>
</li>

<li>Rust - home page<br />
<a href="https://www.rust-lang.org/en-US/">https://www.rust-lang.org/en-US/</a>
</li>

<li>Rust - Frequently Asked Questions<br />
<a href="https://www.rust-lang.org/en-US/faq.html">https://www.rust-lang.org/en-US/faq.html</a>
</li>

<li>Destructuring and Pattern Matching<br />
<a href="https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/">https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/</a>
</li>

<li>The Rust Programming Language<br />
<a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>
</li>

<li>Rust (programming language)<br />
<a href="https://en.wikipedia.org/wiki/Rust_%28programming_language%29">https://en.wikipedia.org/wiki/Rust_%28programming_language%29</a>
</li>

<li>Go - home page<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>Stack Overflow - Most Loved, Dreaded, and Wanted language<br />
<a href="https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted">https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted</a>
</li>

<li>Rust vs Go (dva roky staré hodnocení, od té doby došlo k posunům v obou jazycích)<br />
<a href="http://jaredforsyth.com/2014/03/22/rust-vs-go/">http://jaredforsyth.com/2014/03/22/rust-vs-go/</a>
</li>

<li>Rust vs Go: My experience<br />
<a href="https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/">https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/</a>
</li>

<li>Friends of Rust (Organizations running Rust in production)<br />
<a href="https://www.rust-lang.org/en-US/friends.html">https://www.rust-lang.org/en-US/friends.html</a>
</li>

<li>Rust programs versus C++ g++<br />
<a href="https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp">https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp</a>
</li>

<li>Další benchmarky (nejedná se o reálné příklady &bdquo;ze života&ldquo;)<br />
<a href="https://github.com/kostya/benchmarks">https://github.com/kostya/benchmarks</a>
</li>

<li>Go na Redditu<br />
<a href="https://www.reddit.com/r/golang/">https://www.reddit.com/r/golang/</a>
</li>

<li>Rust vs. Go<br />
<a href="http://vschart.com/compare/rust/vs/go-language">http://vschart.com/compare/rust/vs/go-language</a>
</li>

<li>Abstraction without overhead: traits in Rust<br />
<a href="https://blog.rust-lang.org/2015/05/11/traits.html">https://blog.rust-lang.org/2015/05/11/traits.html</a>
</li>

<li>Method Syntax<br />
<a href="https://doc.rust-lang.org/book/method-syntax.html">https://doc.rust-lang.org/book/method-syntax.html</a>
</li>

<li>Traits in Rust<br />
<a href="https://doc.rust-lang.org/book/traits.html">https://doc.rust-lang.org/book/traits.html</a>
</li>

<li>Functional Programming in Rust - Part 1 : Function Abstraction<br />
<a href="http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/">http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/</a>
</li>

<li>Of the emerging systems languages Rust, D, Go and Nim, which is the strongest language and why?<br />
<a href="https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why">https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why</a>
</li>

<li>Chytré ukazatele (moderní verze jazyka C++) [MSDN]<br />
<a href="https://msdn.microsoft.com/cs-cz/library/hh279674.aspx">https://msdn.microsoft.com/cs-cz/library/hh279674.aspx</a>
</li>

<li>UTF-8 Everywhere<br />
<a href="http://utf8everywhere.org/">http://utf8everywhere.org/</a>
</li>

<li>Rust by Example<br />
<a href="http://rustbyexample.com/">http://rustbyexample.com/</a>
</li>

<li>Rust oficiálně ve Fedoře<br />
<a href="https://mojefedora.cz/rust-oficialne-ve-fedore/">https://mojefedora.cz/rust-oficialne-ve-fedore/</a>
</li>

<li>Resource acquisition is initialization<br />
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization</a>
</li>

<li>TIOBE index (October 2016)<br />
<a href="http://www.tiobe.com/tiobe-index/">http://www.tiobe.com/tiobe-index/</a>
</li>

<li>Porovnání Go, D a Rustu na OpenHubu:<br />
<a href="https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits">https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits</a>
</li>

<li>String Types in Rust<br />
<a href="http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/">http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/</a>
</li>

<li>Trait (computer programming)<br />
<a href="https://en.wikipedia.org/wiki/Trait_%28computer_programming%29">https://en.wikipedia.org/wiki/Trait_%28computer_programming%29</a>
</li>

<li>Type inference<br />
<a href="https://en.wikipedia.org/wiki/Type_inference">https://en.wikipedia.org/wiki/Type_inference</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

