<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Generické typy v programovacím jazyku Rust</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Generické typy v programovacím jazyku Rust</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V šesté části seriálu o programovacím jazyku Rust se budeme věnovat problematice generických datových typů, protože ty mají v Rustu nezastupitelné místo a je na nich mj. postavena i celá základní knihovna tohoto jazyka. Ukážeme si i přetížení operátorů.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Generické typy v&nbsp;programovacím jazyku Rust</a></p>
<p><a href="#k02">2. Komplexní čísla s&nbsp;volitelným typem reálné a imaginární složky</a></p>
<p><a href="#k03">3. Motivace pro implementaci generických funkcí</a></p>
<p><a href="#k04">4. Vytvoření generické funkce</a></p>
<p><a href="#k05">5. Silná typová kontrola</a></p>
<p><a href="#k06">6. Tisk hodnoty komplexního čísla s&nbsp;volitelným typem reálné a imaginární složky</a></p>
<p><a href="#k07">7. Trait &bdquo;Debug&ldquo;</a></p>
<p><a href="#k08">8. Přetížení operátoru + pro komplexní čísla</a></p>
<p><a href="#k09">9. Změna operátoru + podle typu druhého operandu</a></p>
<p><a href="#k10">10. Porovnání dvou komplexních čísel</a></p>
<p><a href="#k11">11. Trait specifikující chování operátoru == (porovnání)</a></p>
<p><a href="#k12">12. Obsah další části seriálu</a></p>
<p><a href="#k13">13. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Generické typy v&nbsp;programovacím jazyku Rust</h2>

<p>Programovací jazyk Rust podporuje deklaraci a následné použití generických
datových typů, které mohou při správném použití zjednodušit tvorbu
znovupoužitelného programového kódu a současně zajistit silnou typovou kontrolu
při překladu. Podívejme se nejprve na motivační příklad, v&nbsp;němž prozatím
<strong>nejsou</strong> použity generické datové typy. Jedná se opět o
implementaci datového typu představujícího komplexní čísla. Naše první verze
vypadala zhruba takto &ndash; Complex je zde pouhá datová struktura:</p>

<pre>
struct Complex {
    real: f32,
    imag: f32,
}
&nbsp;
fn main() {
    let c1 = Complex{real:10.0, imag:20.0};
    let c2 = Complex{real:10.1, imag:20.1};
    let c3 = Complex{real:10.2, imag:20.2};
    let c4 = Complex{real:1., imag:2.};
&nbsp;
    println!("{}+{}i", c1.real, c1.imag);
    println!("{}+{}i", c2.real, c2.imag);
    println!("{}+{}i", c3.real, c3.imag);
    println!("{}+{}i", c4.real, c4.imag);
}
</pre>

<p>V&nbsp;tomto zdrojovém kódu je deklarováno, že reálná a imaginární složka je
představována datovým typem <i>float/single</i>, což je překladačem striktně
hlídáno (a to mnohem silněji, než například v&nbsp;céčku). Pokud se například
pokusíme do reálné či imaginární složky vložit celé číslo, dojde k&nbsp;chybě
při překladu:</p>

<pre>
struct Complex {
    real: f32,
    imag: f32,
}
&nbsp;
fn main() {
    let c1 = Complex{real:10, imag:20};
    let c2 = Complex{real:10.1, imag:20.1};
    let c3 = Complex{real:10.2, imag:20.2};
    let c4 = Complex{real:1, imag:2};
&nbsp;
    println!("{}+{}i", c1.real, c1.imag);
    println!("{}+{}i", c2.real, c2.imag);
    println!("{}+{}i", c3.real, c3.imag);
    println!("{}+{}i", c4.real, c4.imag);
}
</pre>

<p>Při pokusu o překlad tohoto příkladu by se mělo vypsat následující chybové
hlášení, a to pro všechny výskyty hodnoty odlišného datového typu:</p>

<pre>
error[E0308]: mismatched types
 --&gt; test.rs:7:27
  |
7 |     let c1 = Complex{real:10, imag:20};
  |                           ^^ expected f32, found integral variable
  |
  = note: expected type `f32`
  = note:    found type `{integer}`
&nbsp;
error[E0308]: mismatched types
 --&gt; test.rs:7:36
  |
7 |     let c1 = Complex{real:10, imag:20};
  |                                    ^^ expected f32, found integral variable
  |
  = note: expected type `f32`
  = note:    found type `{integer}`
&nbsp;
error[E0308]: mismatched types
  --&gt; test.rs:10:27
   |
10 |     let c4 = Complex{real:1, imag:2};
   |                           ^ expected f32, found integral variable
   |
   = note: expected type `f32`
   = note:    found type `{integer}`
&nbsp;
error[E0308]: mismatched types
  --&gt; test.rs:10:35
   |
10 |     let c4 = Complex{real:1, imag:2};
   |                                   ^ expected f32, found integral variable
   |
   = note: expected type `f32`
   = note:    found type `{integer}`
&nbsp;
error: aborting due to 4 previous errors
</pre>

<p>Podle očekávání nebude překlad dokončen ani ve chvíli, kdy se namísto typu
<i>float/single</i> použijí konstanty datového typu <i>double</i>:</p>

<pre>
fn main() {
    let c1 = Complex{real:10f64, imag:20f64};
&nbsp;
    println!("{}+{}i", c1.real, c1.imag);
}
</pre>

<p>V&nbsp;průběhu překladu by se měla vypsat tato dvě chybová hlášení:</p>

<pre>
error[E0308]: mismatched types
 --&gt; test.rs:7:27
  |
7 |     let c1 = Complex{real:10f64, imag:20f64};
  |                           ^^^^^ expected f32, found f64
&nbsp;
error[E0308]: mismatched types
 --&gt; test.rs:7:39
  |
7 |     let c1 = Complex{real:10f64, imag:20f64};
  |                                       ^^^^^ expected f32, found f64
&nbsp;
error: aborting due to 2 previous errors
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Komplexní čísla s&nbsp;volitelným typem reálné a imaginární složky</h2>

<p>Předchozí příklad sice fungoval korektně a podle předpokladů, ovšem jen ve
chvíli, kdy nám postačovalo použití komplexních čísel, jejichž složky byly
reprezentovány typem <i>float/single</i>. Ovšem je jen otázkou času, kdy nějaký
vývojář bude chtít použít podobný kód, ovšem například pro datový typ
<i>double</i>, pro typ &bdquo;zlomek&ldquo; atd. V&nbsp;takovém případě může
být nejvýhodnější deklaraci datové struktury upravit takovým způsobem, aby se
konkrétní typ složek komplexního čísla rozpoznal až v&nbsp;době překladu na
základě typů konkrétních hodnot či výrazů použitých pro konstrukci datové
struktury. Programovací jazyk Rust tento přístup podporuje, protože umožňuje
následující styl deklarace (znak <strong>T</strong> není klíčovým slovem, ovšem
je v&nbsp;kontextu generických datových typů často používán, takže tento úzus
taktéž dodržíme):</p>

<pre>
struct Complex&lt;T&gt; {
    real: T,
    imag: T,
}
</pre>

<p>Tento zápis znamená, že se za <strong>T</strong> při překladu doplní
konkrétní rozpoznaný datový typ, což si můžeme snadno vyzkoušet:</p>

<pre>
fn main() {
    let c1 = Complex{real:10, imag:20};
    let c2 = Complex{real:10.1, imag:20.1};
    let c3 = Complex{real:10.2f64, imag:20.2f64};
    let c4 = Complex{real:true, imag:false};
&nbsp;
    println!("{}+{}i", c1.real, c1.imag);
    println!("{}+{}i", c2.real, c2.imag);
    println!("{}+{}i", c3.real, c3.imag);
    println!("{}+{}i", c4.real, c4.imag);
}
</pre>

<p>Ve chvíli, kdy se pokusíme o kombinaci různých typů, budeme na to upozorněni
překladačem, protože typ reálné i imaginární složky musí být totožný:</p>

<pre>
fn main() {
    let c1 = Complex{real:10, imag:true};

    println!("{}+{}i", c1.real, c1.imag);
}
</pre>

<pre>
error[E0308]: mismatched types
 --&gt; test.rs:7:36
  |
7 |     let c1 = Complex{real:10, imag:true};
  |                                    ^^^^ expected integral variable, found bool
  |
  = note: expected type `{integer}`
  = note:    found type `bool`

error: aborting due to previous error
</pre>

<p>Jinými slovy &ndash; typ datové struktury <strong>Complex</strong> je
parametrizovatelný, ovšem současně je stále zajištěna typová kontrola (nejedná
se tedy o nic ve smyslu Complex(Object, Object) :-).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Motivace pro implementaci generických funkcí</h2>

<p>V&nbsp;programovacím jazyku Rust je možné kromě deklarace generických
datových typů vytvářet i generické funkce, tj.&nbsp;funkce, u nichž lze
specifikovat parametrizovatelné typy argumentů i návratový typ. Podívejme se na
sice poněkud umělý, ale o to kratší demonstrační příklad. V&nbsp;tomto příkladu
nejprve deklarujeme výčtový typ a následně funkci, která akceptuje dva
parametry typu <strong>i32</strong> (celé číslo se znaménkem) a třetí parametr,
na základě jehož hodnoty funkce vrátí buď první či druhý parametr. Nejprve si
povšimněte, jak se používá výčtový typ (má vlastní jmenný prostor, proto se
zapisuje <strong>Item::First</strong> a nikoli pouze <strong>First</strong>).
Použití konstrukce <strong>match</strong> je v&nbsp;tomto případě idiomatické a
mnohem lepší, než pokus o použití <strong>if</strong>, a to z&nbsp;toho důvodu,
že překladač sám zkontroluje, zda v&nbsp;konstrukci <strong>match</strong>
reagujeme na všechny možné vstupy (což samozřejmě děláme :-):</p>

<pre>
enum Item {
    First,
    Second,
}
&nbsp;
fn select_item(first_item:i32, second_item:i32, item:Item) -&gt; i32 {
    match item {
        Item::First  =&gt; first_item,
        Item::Second =&gt; second_item,
    }
}
&nbsp;
fn main() {
    let x = 10;
    let y = 20;
    println!("1st item = {}", select_item(x, y, Item::First));
    println!("2nd item = {}", select_item(x, y, Item::Second));
    
}
</pre>

<p>Po překladu a spuštění by se na standardní výstup měly vypsat následující
dva řádky znamenající, že poprvé funkce <strong>select_item</strong> vybrala a
vrátila první argument (resp.&nbsp;zde jeho kopii!) a podruhé druhý
argument:</p>

<pre>
1st item = 10
2nd item = 20
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Vytvoření generické funkce</h2>

<p>Přiznejme si, že funkce <strong>select_item</strong> v&nbsp;podobě,
v&nbsp;jaké jsme si ji ukázali <a href="#k03">v&nbsp;předchozí kapitole</a>,
není příliš použitelná, protože ji lze volat pouze s&nbsp;parametry typu
<strong>i32</strong>. Pokusme se tedy vytvořit podobnou funkci, ovšem
generickou. V&nbsp;tomto případě to znamená, že typy prvních dvou parametrů
musí být shodné a musí odpovídat návratovému typu funkce &ndash; ta totiž nemá
provádět žádné konverze, pouze vybírat mezi prvním a druhým argumentem. Takto
navržená generická funkce může vypadat následovně (povšimněte si především
zápisu &lt;T&gt; za jménem funkce):</p>

<pre>
fn select_item&lt;T&gt;(first_item:T, second_item:T, item:Item) -&gt; T {
    match item {
        Item::First  =&gt; first_item,
        Item::Second =&gt; second_item,
    }
}
</pre>

<p>Nově deklarovanou funkci je možné použít pro různé typy argumentů,
samozřejmě za předpokladu, že oba dva argumenty budou stejného typu:</p>

<pre>
enum Item {
    First,
    Second,
}
&nbsp;
fn select_item&lt;T&gt;(first_item:T, second_item:T, item:Item) -&gt; T {
    match item {
        Item::First  =&gt; first_item,
        Item::Second =&gt; second_item,
    }
}
&nbsp;
fn main() {
    let x = 10.1;
    let y = 20.2;
    println!("1st item = {}", select_item(x, y, Item::First));
    println!("2nd item = {}", select_item(x, y, Item::Second));
&nbsp;
    let z:i32 = 10;
    let w:i32 = 20;
    println!("1st item = {}", select_item(z, w, Item::First));
    println!("2nd item = {}", select_item(z, w, Item::Second));
&nbsp;
    let a = true;
    let b = false;
    println!("1st item = {}", select_item(a, b, Item::First));
    println!("2nd item = {}", select_item(a, b, Item::Second));
}
</pre>

<p>Po spuštění získáme následující řádky vypsané na standardní výstup:</p>

<pre>
1st item = 10.1
2nd item = 20.2
1st item = 10
2nd item = 20
1st item = true
2nd item = false
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Silná typová kontrola</h2>

<p><a href="#k04">V&nbsp;předchozí kapitole</a> jsme si řekli, že překladač pro
novou podobu funkce <strong>select_item</strong> kontroluje, zda jsou typy
prvních dvou argumentů shodné. Pojďme si toto tvrzení ověřit: </p>

<pre>
enum Item {
    First,
    Second,
}
&nbsp;
fn select_item&lt;T&gt;(first_item:T, second_item:T, item:Item) -&gt; T {
    match item {
        Item::First  =&gt; first_item,
        Item::Second =&gt; second_item,
    }
}
&nbsp;
fn main() {
    let x = 10.1;
    let y = 20;
    println!("1st item = {}", select_item(x, y, Item::First));
    println!("2nd item = {}", select_item(x, y, Item::Second));
&nbsp;
    let z:f32 = 10;
    let w:i32 = 20;
    println!("1st item = {}", select_item(z, w, Item::First));
    println!("2nd item = {}", select_item(z, w, Item::Second));
&nbsp;
    let a = 10;
    let b = false;
    println!("1st item = {}", select_item(a, b, Item::First));
    println!("2nd item = {}", select_item(a, b, Item::Second));
}
</pre>

<p>Spusťme nyní překladač na tento zdrojový kód, aby bylo patrné, jak pracuje
statická typová kontrola (navíc je ukázána i kontrola typů proměnných a hodnot
přiřazovaných do proměnných, což je téma, kterému jsme se již věnovali):</p>

<pre>
error[E0308]: mismatched types
  --&gt; test.rs:16:46
   |
16 |     println!("1st item = {}", select_item(x, y, Item::First));
   |                                              ^ expected floating-point variable, found integral variable
&lt;std macros&gt;:2:27: 2:58 note: in this expansion of format_args!
&lt;std macros&gt;:3:1: 3:54 note: in this expansion of print! (defined in &lt;std macros&gt;)
test.rs:16:5: 16:63 note: in this expansion of println! (defined in &lt;std macros&gt;)
   |
   = note: expected type `{float}`
   = note:    found type `{integer}`
&nbsp;
error[E0308]: mismatched types
  --&gt; test.rs:17:46
   |
17 |     println!("2nd item = {}", select_item(x, y, Item::Second));
   |                                              ^ expected floating-point variable, found integral variable
&lt;std macros&gt;:2:27: 2:58 note: in this expansion of format_args!
&lt;std macros&gt;:3:1: 3:54 note: in this expansion of print! (defined in &lt;std macros&gt;)
test.rs:17:5: 17:64 note: in this expansion of println! (defined in &lt;std macros&gt;)
   |
   = note: expected type `{float}`
   = note:    found type `{integer}`
&nbsp;
error[E0308]: mismatched types
  --&gt; test.rs:19:17
   |
19 |     let z:f32 = 10;
   |                 ^^ expected f32, found integral variable
   |
   = note: expected type `f32`
   = note:    found type `{integer}`
&nbsp;
error[E0308]: mismatched types
  --&gt; test.rs:21:46
   |
21 |     println!("1st item = {}", select_item(z, w, Item::First));
   |                                              ^ expected f32, found i32
&lt;std macros&gt;:2:27: 2:58 note: in this expansion of format_args!
&lt;std macros&gt;:3:1: 3:54 note: in this expansion of print! (defined in &lt;std macros&gt;)
test.rs:21:5: 21:63 note: in this expansion of println! (defined in &lt;std macros&gt;)
&nbsp;
error[E0308]: mismatched types
  --&gt; test.rs:22:46
   |
22 |     println!("2nd item = {}", select_item(z, w, Item::Second));
   |                                              ^ expected f32, found i32
&lt;std macros&gt;:2:27: 2:58 note: in this expansion of format_args!
&lt;std macros&gt;:3:1: 3:54 note: in this expansion of print! (defined in &lt;std macros&gt;)
test.rs:22:5: 22:64 note: in this expansion of println! (defined in &lt;std macros&gt;)
&nbsp;
error[E0308]: mismatched types
  --&gt; test.rs:26:46
   |
26 |     println!("1st item = {}", select_item(a, b, Item::First));
   |                                              ^ expected integral variable, found bool
&lt;std macros&gt;:2:27: 2:58 note: in this expansion of format_args!
&lt;std macros&gt;:3:1: 3:54 note: in this expansion of print! (defined in &lt;std macros&gt;)
test.rs:26:5: 26:63 note: in this expansion of println! (defined in &lt;std macros&gt;)
   |
   = note: expected type `{integer}`
   = note:    found type `bool`
&nbsp;
error[E0308]: mismatched types
  --&gt; test.rs:27:46
   |
27 |     println!("2nd item = {}", select_item(a, b, Item::Second));
   |                                              ^ expected integral variable, found bool
&lt;std macros&gt;:2:27: 2:58 note: in this expansion of format_args!
&lt;std macros&gt;:3:1: 3:54 note: in this expansion of print! (defined in &lt;std macros&gt;)
test.rs:27:5: 27:64 note: in this expansion of println! (defined in &lt;std macros&gt;)
   |
   = note: expected type `{integer}`
   = note:    found type `bool`
&nbsp;
error: aborting due to 7 previous errors
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Tisk hodnoty komplexního čísla s&nbsp;volitelným typem reálné a imaginární složky</h2>

<p>Pokud budeme chtít vytisknout hodnotu komplexního čísla, jehož typy složek
jsou parametrizovatelné, narazíme brzy na malý problém související
s&nbsp;expanzí makra <strong>println!</strong> (toto makro potřebuje znát typy
tisknutých hodnot). Řešením je implementace traitu nazvaného
<strong>Debug</strong> a implementace funkce <strong>print</strong>, která
v&nbsp;případě komplexních čísel může vypadat následovně. Důležitý je zde
formátovací řetězec {:?}, který odpovídá právě traitu <strong>Debug</strong>,
pokud se uvede pouze {}, odpovídá to traitu <strong>Display</strong>:</p>

<pre>
fn print(&amp;self) {
    println!("complex number: {:?}+{:?}i", self.real, self.imag);
}
</pre>

<p>Trait <strong>Debug</strong> nalezneme v&nbsp;modulu
<strong>std::fmt</strong>, takže první řádek našeho programu bude vypadat
takto:</p>

<pre>
use std::fmt::Debug;
</pre>

<p>Trait <strong>Debug</strong> může být pro komplexní čísla implementován
stylem:</p>

<pre>
impl&lt;T: Debug&gt; Complex&lt;T&gt; {
&nbsp;
    fn new(real: T, imag: T) -&gt; Complex&lt;T&gt; {
        Complex{real:real, imag:imag}
    }
&nbsp;
    fn print(&amp;self) {
        println!("complex number: {:?}+{:?}i", self.real, self.imag);
    }
&nbsp;
}
</pre>

<p>Zápis typu <strong>&lt;T: Debug&gt; Complex&lt;T&gt;</strong> použijeme i
v&nbsp;dalších demonstračních příkladech.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Trait &bdquo;Debug&ldquo;</h2>

<p>Úplný zdrojový kód, v&nbsp;němž je použit trait <strong>Debug</strong> je
vypsán pod tímto odstavcem:</p>

<pre>
use std::fmt::Debug;
&nbsp;
struct Complex&lt;T: Debug&gt; {
    real: T,
    imag: T,
}
&nbsp;
impl&lt;T: Debug&gt; Complex&lt;T&gt; {
&nbsp;
    fn new(real: T, imag: T) -&gt; Complex&lt;T&gt; {
        Complex{real:real, imag:imag}
    }
&nbsp;
    fn print(&amp;self) {
        println!("complex number: {:?}+{:?}i", self.real, self.imag);
    }
&nbsp;
}
&nbsp;
fn main() {
    let c1 = Complex::new(3, 4);
    let c2 = Complex::new(3.3f32, 4.4f32);
    let c3 = Complex::new(5.0f64, 6.0f64);
    c1.print();
    c2.print();
    c3.print();
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Přetížení operátoru + pro komplexní čísla</h2>

<p>Ve druhé části článku se budeme zabývat problematikou přetěžování operátorů,
protože uvidíme, že i v&nbsp;této oblasti se využijí generické datové typy.
Začneme operátorem +, který si přetížíme pro komplexní čísla. Přetížení
operátoru v&nbsp;kontextu programovacího jazyka Rust znamená, že implementujeme
trait <strong>Add</strong> z&nbsp;modulu <strong>std::ops</strong>.
V&nbsp;tomto traitu je předepsána funkce <strong>add</strong> s&nbsp;poněkud
zvláštní hlavičkou, z&nbsp;níž nepřímo plyne, že typ druhého operandu + (RHS =
right-hand side) je volitelný (a potenciálně odlišný od typu operandu prvního)
a dokonce že i návratový typ může být odlišný (u součtu to může vypadat
podivně, ale řekněme, že u přetížíme operátor * pro skalární součin dvou
vektorů):</p>

<pre>
fn add(self, rhs: RHS) -&gt; Self::Output;
</pre>

<p>Zápis Self::Output odkazuje na atribut traitu nazvaný
<strong>Output</strong>, který musíme taktéž nastavit. V&nbsp;našem konkrétním
případě jsou oba operandy operátoru + stejného typu a navíc odpovídají výsledku
výrazu s +. Implementace může vypadat následovně:</p>

<pre>
impl Add for Complex {
&nbsp;
    type Output = Complex;
&nbsp;
    fn add(self, right: Complex) -&gt; Self::Output {
        Complex{real: self.real + right.real,
                imag: self.imag + right.imag}
    }
&nbsp;
}
</pre>

<p>Povšimněte si, že skutečně deklarujeme výstupní typ jako
<strong>Complex</strong> a stejný je i typ pravého operandu +. Navíc stojí za
připomenutí fakt, že sémantika operátoru + je taková, že vrací <i>novou</i>
hodnotu, což přesně odpovídá kódu funkce. Nesnažíme se tedy modifikovat
stávající komplexní číslo, to ostatně ani není u neměnného typu možné:</p>

<p>Úplný demonstrační příklad vypadá takto:</p>

<pre>
use std::ops::Add;
&nbsp;
struct Complex {
    real: f32,
    imag: f32,
}
&nbsp;
impl Complex {
&nbsp;
    fn new(real: f32, imag: f32) -&gt; Complex {
        Complex{real:real, imag:imag}
    }
&nbsp;
    fn print(&amp;self) {
        println!("complex number: {:}+{:}i", self.real, self.imag);
    }
&nbsp;
}
&nbsp;
impl Add for Complex {
&nbsp;
    type Output = Complex;
&nbsp;
    fn add(self, right: Complex) -&gt; Self::Output {
        Complex{real: self.real + right.real,
                imag: self.imag + right.imag}
    }
&nbsp;
}
&nbsp;
fn main() {
    let c1 = Complex::new(1.0, 1.0);
    let c2 = Complex::new(3.0, 4.0);
    c1.print();
    c2.print();
    let c3 = c1 + c2;
    c3.print();
}
</pre>

<p>Alternativně samozřejmě můžeme ve funkci <strong>add</strong> využít konstruktor:</p>

<pre>
use std::ops::Add;
&nbsp;
struct Complex {
    real: f32,
    imag: f32,
}
&nbsp;
impl Complex {
&nbsp;
    fn new(real: f32, imag: f32) -&gt; Complex {
        Complex{real:real, imag:imag}
    }
&nbsp;
    fn print(&amp;self) {
        println!("complex number: {:}+{:}i", self.real, self.imag);
    }
&nbsp;
}
&nbsp;
impl Add for Complex {
&nbsp;
    type Output = Complex;
&nbsp;
    fn add(self, right: Complex) -&gt; Self::Output {
        Complex::new(self.real + right.real,
                     self.imag + right.imag)
    }
}
&nbsp;
fn main() {
    let c1 = Complex::new(1.0, 1.0);
    let c2 = Complex::new(3.0, 4.0);
    c1.print();
    c2.print();
    let c3 = c1 + c2;
    c3.print();
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Změna operátoru + podle typu druhého operandu</h2>

<p>Ve skutečnosti může být chování operátoru +, nebo samozřejmě jakéhokoli
jiného přetíženého operátoru, odlišné podle toho, jaký je typ druhého operandu
(první operand má typ stejný &ndash; odpovídá typu, pro nějž implementujeme
trait <strong>Add</strong>). Zkusme nyní změnit náš příklad takovým způsobem,
aby bylo možné sečíst dvě komplexní čísla nebo ke komplexnímu číslu přičíst
reálnou konstantu (výsledkem bude nové komplexní číslo). Zde se již musí použít
generický zápis, nikoli však pro datový typ či funkci, ale pro celý trait.
První implementaci traitu již známe, musíme ovšem přidat specifikaci typu
(druhého operandu):</p>

<pre>
impl Add&lt;Complex&gt; for Complex {
&nbsp;
    type Output = Complex;
&nbsp;
    fn add(self, right: Complex) -&gt; Self::Output {
        Complex::new(self.real + right.real,
                     self.imag + right.imag)
    }
}
</pre>

<p>Druhý trait se uplatní při součtu komplexní číslo+reálné číslo:</p>

<pre>
impl Add&lt;f32&gt; for Complex {
&nbsp;
    type Output = Complex;
&nbsp;
    fn add(self, right: f32) -&gt; Self::Output {
        Complex::new(self.real + right,
                     self.imag)
    }
}
</pre>

<p>Úplný demonstrační příklad vypadá následovně (ve funkci main se sčítají dvě
komplexní čísla i komplexní číslo s&nbsp;číslem reálným):</p>

<pre>
use std::ops::Add;
&nbsp;
struct Complex {
    real: f32,
    imag: f32,
}
&nbsp;
impl Complex {
&nbsp;
    fn new(real: f32, imag: f32) -&gt; Complex {
        Complex{real:real, imag:imag}
    }
&nbsp;
    fn print(&amp;self) {
        println!("complex number: {:}+{:}i", self.real, self.imag);
    }
&nbsp;
}
&nbsp;
impl Add&lt;Complex&gt; for Complex {
&nbsp;
    type Output = Complex;
&nbsp;
    fn add(self, right: Complex) -&gt; Self::Output {
        Complex::new(self.real + right.real,
                     self.imag + right.imag)
    }
}
&nbsp;
impl Add&lt;f32&gt; for Complex {
&nbsp;
    type Output = Complex;
&nbsp;
    fn add(self, right: f32) -&gt; Self::Output {
        Complex::new(self.real + right,
                     self.imag)
    }
}
&nbsp;
fn main() {
    let c1 = Complex::new(1.0, 1.0);
    let c2 = Complex::new(3.0, 4.0);
    c1.print();
    c2.print();
    let c3 = c1 + c2;
    c3.print();
    let c4 = c3 + 1000.;
    c4.print();
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Porovnání dvou komplexních čísel</h2>

<p>Další operátor, který se poměrně často přetěžuje, je operátor pro porovnání
dvou hodnot. Tento operátor není pro uživatelem definované datové struktury
předepsán, o čemž se ostatně lze velmi snadno přesvědčit při pokusu o překlad
zdrojového kódu, v&nbsp;němž se budou porovnávat komplexní čísla:</p>

<pre>
use std::ops::Add;
&nbsp;
struct Complex {
    real: f32,
    imag: f32,
}
&nbsp;
impl Complex {
&nbsp;
    fn new(real: f32, imag: f32) -&gt; Complex {
        Complex{real:real, imag:imag}
    }
&nbsp;
    fn print(&amp;self) {
        println!("complex number: {:}+{:}i", self.real, self.imag);
    }
&nbsp;
}
&nbsp;
impl Add&lt;Complex&gt; for Complex {
&nbsp;
    type Output = Complex;
&nbsp;
    fn add(self, right: Complex) -&gt; Self::Output {
        Complex::new(self.real + right.real,
                     self.imag + right.imag)
    }
}
&nbsp;
impl Add&lt;f32&gt; for Complex {
&nbsp;
    type Output = Complex;
&nbsp;
    fn add(self, right: f32) -&gt; Self::Output {
        Complex::new(self.real + right,
                     self.imag)
    }
}
&nbsp;
fn main() {
    let c1 = Complex::new(1.0, 1.0);
    let c2 = Complex::new(3.0, 4.0);
    c1.print();
    c2.print();
    let c3 = c1 + c2;
    let c4 = Complex::new(4.0, 5.0);
    c3.print();
    c4.print();
    println!("c3 == c4? {}", (if c3==c4 { "yes"} else {"no"}));
}
</pre>

<p>Překladač při pokusu o kompilaci pouze vypíše následující chybovou
zprávu:</p>

<pre>
error[E0369]: binary operation `==` cannot be applied to type `Complex`
  --&gt; test.rs:49:34
   |
49 |     println!("c3 == c4? {}", (if c3==c4 { "yes"} else {"no"}));
   |                                  ^^
&lt;std macros&gt;:2:27: 2:58 note: in this expansion of format_args!
&lt;std macros&gt;:3:1: 3:54 note: in this expansion of print! (defined in &lt;std macros&gt;)
test.rs:49:5: 49:64 note: in this expansion of println! (defined in &lt;std macros&gt;)
   |
note: an implementation of `std::cmp::PartialEq` might be missing for `Complex`
  --&gt; test.rs:49:34
   |
49 |     println!("c3 == c4? {}", (if c3==c4 { "yes"} else {"no"}));
   |                                  ^^
&lt;std macros&gt;:2:27: 2:58 note: in this expansion of format_args!
&lt;std macros&gt;:3:1: 3:54 note: in this expansion of print! (defined in &lt;std macros&gt;)
test.rs:49:5: 49:64 note: in this expansion of println! (defined in &lt;std macros&gt;)
&nbsp;
error: aborting due to previous error
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Trait specifikující chování operátoru == (porovnání)</h2>

<p>Chybové hlášení překladače, které jsme viděli v&nbsp;předchozí kapitole,
poměrně přesně naznačovalo, co je zapotřebí udělat proto, aby bylo možné dvě
komplexní čísla porovnat. Je nutné implementovat buď trait <strong>Eq</strong>
nebo <strong>PartialEq</strong>. Tyto dva traity se od sebe odlišují svou
sémantikou, protože u traitu <strong>Eq</strong> je nutné zajistit test
skutečné (relace) ekvivalence (ta je reflexivní, symetrická a tranzitivní),
kdežto u traitu <strong>PartialEq</strong> se zajišťuje jen symetričnost a
tranzitivita. Co to znamená v&nbsp;praxi? Typickým příkladem jsou hodnoty
s&nbsp;plovoucí řádovou čárkou, které (pokud jsou implementovány podle normy
IEEE 754), nezajišťují reflexivitu pro NaN, protože platí NaN != NaN.</p>

<p>Implementace traitu <strong>PartialEq</strong> pro komplexní čísla není
příliš složitá, postačuje jen implementovat funkci <strong>eq</strong>
vracející pro dvě komplexní čísla pravdivostní hodnotu (ve skutečnosti nemusí
být pravým operandem komplexní číslo, což se podobá výše zmíněnému příkladu
s&nbsp;operandem +):</p>

<pre>
impl PartialEq for Complex {
&nbsp;
    fn eq(&amp;self, right: &amp;Complex) -&gt; bool {
        self.real == right.real &amp;&amp; self.imag == right.imag
    }
}
</pre>

<p>Implementovaný trait lze snadno otestovat:</p>

<pre>
use std::ops::Add;
use std::cmp::PartialEq;
&nbsp;
struct Complex {
    real: f32,
    imag: f32,
}
&nbsp;
impl Complex {
&nbsp;
    fn new(real: f32, imag: f32) -&gt; Complex {
        Complex{real:real, imag:imag}
    }
&nbsp;
    fn print(&amp;self) {
        println!("complex number: {:}+{:}i", self.real, self.imag);
    }
&nbsp;
}
&nbsp;
impl Add&lt;Complex&gt; for Complex {
&nbsp;
    type Output = Complex;
&nbsp;
    fn add(self, right: Complex) -&gt; Self::Output {
        Complex::new(self.real + right.real,
                     self.imag + right.imag)
    }
}
&nbsp;
impl Add&lt;f32&gt; for Complex {
&nbsp;
    type Output = Complex;
&nbsp;
    fn add(self, right: f32) -&gt; Self::Output {
        Complex::new(self.real + right,
                     self.imag)
    }
}
&nbsp;
impl PartialEq for Complex {
&nbsp;
    fn eq(&amp;self, right: &amp;Complex) -&gt; bool {
        self.real == right.real &amp;&amp; self.imag == right.imag
    }
}
&nbsp;
fn main() {
    let c1 = Complex::new(1.0, 1.0);
    let c2 = Complex::new(3.0, 4.0);
    c1.print();
    c2.print();
    let c3 = c1 + c2;
    let c4 = Complex::new(4.0, 5.0);
    c3.print();
    c4.print();
    println!("c3 == c4? {}", (if c3==c4 { "yes"} else {"no"}));
}
</pre>

<p>Povšimněte si, že konstrukci <strong>if-else</strong> lze použít i ve
výrazu, pouze se musí uzavřít do kulatých závorek.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Obsah další části seriálu</h2>

<p>V&nbsp;další části seriálu si nejprve popíšeme způsob přetížení dalších typů
operátorů. Zajímavé budou především operátory typu +=, -= atd., protože u
těchto operátorů se předpokládá, že dojde ke změně (modifikaci) levého
operandu. To v&nbsp;Rustu znamená, že operand musí být měnitelný (mutable), což
se samozřejmě bude týkat i naší implementace komplexních čísel. Ve druhé části
článku se budeme zabývat způsobem alokace objektů na haldě (<i>heap</i>) a tím,
jak lze zajistit automatickou správu paměti bez toho, aby bylo nutné používat
komplikované garbage collectory.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popisované demonstrační příklady byly, podobně jako
v&nbsp;předchozích částech tohoto seriálu, uloženy do Git repositáře dostupného
na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě bez nutnosti
klonovat celý (dnes již poněkud objemný) repositář:</p>

<table>
<tr><th>Příklad</th><th>Odkaz</th></tr>
<tr><td>79_trait_return_type.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/79_trait_return_type.rs">https://github.com/tisnik/presentations/blob/master/rust/79_trait_return_type.rs</a></td></tr>
<tr><td>80_generic_struct.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/80_generic_struct.rs">https://github.com/tisnik/presentations/blob/master/rust/80_generic_struct.rs</a></td></tr>
<tr><td>81_enum_and_match.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/81_enum_and_match.rs">https://github.com/tisnik/presentations/blob/master/rust/81_enum_and_match.rs</a></td></tr>
<tr><td>82_generic_function.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/82_generic_function.rs">https://github.com/tisnik/presentations/blob/master/rust/82_generic_function.rs</a></td></tr>
<tr><td>83_generic_function_type_error.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/83_generic_function_type_error.rs">https://github.com/tisnik/presentations/blob/master/rust/83_generic_function_type_error.rs</a></td></tr>
<tr><td>84_debug_trait.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/84_debug_trait.rs">https://github.com/tisnik/presentations/blob/master/rust/84_debug_trait.rs</a></td></tr>
<tr><td>85_add_trait.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/85_add_trait.rs">https://github.com/tisnik/presentations/blob/master/rust/85_add_trait.rs</a></td></tr>
<tr><td>86_add_trait_2.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/86_add_trait_2.rs">https://github.com/tisnik/presentations/blob/master/rust/86_add_trait_2.rs</a></td></tr>
<tr><td>87_add_trait_3.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/87_add_trait_3.rs">https://github.com/tisnik/presentations/blob/master/rust/87_add_trait_3.rs</a></td></tr>
<tr><td>88_missing_eq_trait.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/88_missing_eq_trait.rs">https://github.com/tisnik/presentations/blob/master/rust/88_missing_eq_trait.rs</a></td></tr>
<tr><td>89_partial_eq_trait.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/89_partial_eq_trait.rs">https://github.com/tisnik/presentations/blob/master/rust/89_partial_eq_trait.rs</a></td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Operators and Overloading<br />
<a href="https://doc.rust-lang.org/book/operators-and-overloading.html">https://doc.rust-lang.org/book/operators-and-overloading.html</a>
</li>

<li>Module std::ops<br />
<a href="https://doc.rust-lang.org/std/ops/index.html">https://doc.rust-lang.org/std/ops/index.html</a>
</li>

<li>Module std::cmp<br />
<a href="https://doc.rust-lang.org/std/cmp/index.html">https://doc.rust-lang.org/std/cmp/index.html</a>
</li>

<li>Trait std::ops::Add<br />
<a href="https://doc.rust-lang.org/stable/std/ops/trait.Add.html">https://doc.rust-lang.org/stable/std/ops/trait.Add.html</a>
</li>

<li>Trait std::ops::AddAssign<br />
<a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html">https://doc.rust-lang.org/std/ops/trait.AddAssign.html</a>
</li>

<li>Trait std::ops::Drop<br />
<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">https://doc.rust-lang.org/std/ops/trait.Drop.html</a>
</li>

<li>Trait std::cmp::Eq<br />
<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">https://doc.rust-lang.org/std/cmp/trait.Eq.html</a>
</li>

<li>Struct std::boxed::Box<br />
<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">https://doc.rust-lang.org/std/boxed/struct.Box.html</a>
</li>

<li>Explore the ownership system in Rust<br />
<a href="https://nercury.github.io/rust/guide/2015/01/19/ownership.html">https://nercury.github.io/rust/guide/2015/01/19/ownership.html</a>
</li>

<li>Rust's ownership and move semantic<br/>
<a href="http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics">http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics</a>
</li>

<li>Trait std::marker::Copy<br/>
<a href="https://doc.rust-lang.org/stable/std/marker/trait.Copy.html">https://doc.rust-lang.org/stable/std/marker/trait.Copy.html</a>
</li>

<li>Trait std::clone::Clone<br />
<a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html">https://doc.rust-lang.org/stable/std/clone/trait.Clone.html</a>
</li>

<li>The Stack and the Heap<br />
<a href="https://doc.rust-lang.org/book/the-stack-and-the-heap.html">https://doc.rust-lang.org/book/the-stack-and-the-heap.html</a>
</li>

<li>Rust Compare: Pointers &amp; References<br />
<a href="http://www.rust-compare.com/site/pointers.html">http://www.rust-compare.com/site/pointers.html</a>
</li>

<li>Rust Compare: Parameters<br />
<a href="http://www.rust-compare.com/site/params.html">http://www.rust-compare.com/site/params.html</a>
</li>

<li>Why does this compile? Automatic dereferencing?<br />
<a href="https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183">https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183</a>
</li>

<li>Understanding Pointers, Ownership, and Lifetimes in Rust<br />
<a href="http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html">http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html</a>
</li>

<li>Rust lang series episode #25 — pointers (#rust-series)<br />
<a href="https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series">https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series</a>
</li>

<li>Rust - home page<br />
<a href="https://www.rust-lang.org/en-US/">https://www.rust-lang.org/en-US/</a>
</li>

<li>Rust - Frequently Asked Questions<br />
<a href="https://www.rust-lang.org/en-US/faq.html">https://www.rust-lang.org/en-US/faq.html</a>
</li>

<li>Destructuring and Pattern Matching<br />
<a href="https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/">https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/</a>
</li>

<li>The Rust Programming Language<br />
<a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>
</li>

<li>Rust (programming language)<br />
<a href="https://en.wikipedia.org/wiki/Rust_%28programming_language%29">https://en.wikipedia.org/wiki/Rust_%28programming_language%29</a>
</li>

<li>Go - home page<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>Stack Overflow - Most Loved, Dreaded, and Wanted language<br />
<a href="https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted">https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted</a>
</li>

<li>Rust vs Go (dva roky staré hodnocení, od té doby došlo k posunům v obou jazycích)<br />
<a href="http://jaredforsyth.com/2014/03/22/rust-vs-go/">http://jaredforsyth.com/2014/03/22/rust-vs-go/</a>
</li>

<li>Rust vs Go: My experience<br />
<a href="https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/">https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/</a>
</li>

<li>Friends of Rust (Organizations running Rust in production)<br />
<a href="https://www.rust-lang.org/en-US/friends.html">https://www.rust-lang.org/en-US/friends.html</a>
</li>

<li>Rust programs versus C++ g++<br />
<a href="https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp">https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp</a>
</li>

<li>Další benchmarky (nejedná se o reálné příklady &bdquo;ze života&ldquo;)<br />
<a href="https://github.com/kostya/benchmarks">https://github.com/kostya/benchmarks</a>
</li>

<li>Go na Redditu<br />
<a href="https://www.reddit.com/r/golang/">https://www.reddit.com/r/golang/</a>
</li>

<li>Rust vs. Go<br />
<a href="http://vschart.com/compare/rust/vs/go-language">http://vschart.com/compare/rust/vs/go-language</a>
</li>

<li>Abstraction without overhead: traits in Rust<br />
<a href="https://blog.rust-lang.org/2015/05/11/traits.html">https://blog.rust-lang.org/2015/05/11/traits.html</a>
</li>

<li>Method Syntax<br />
<a href="https://doc.rust-lang.org/book/method-syntax.html">https://doc.rust-lang.org/book/method-syntax.html</a>
</li>

<li>Traits in Rust<br />
<a href="https://doc.rust-lang.org/book/traits.html">https://doc.rust-lang.org/book/traits.html</a>
</li>

<li>Functional Programming in Rust - Part 1 : Function Abstraction<br />
<a href="http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/">http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/</a>
</li>

<li>Of the emerging systems languages Rust, D, Go and Nim, which is the strongest language and why?<br />
<a href="https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why">https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why</a>
</li>

<li>Chytré ukazatele (moderní verze jazyka C++) [MSDN]<br />
<a href="https://msdn.microsoft.com/cs-cz/library/hh279674.aspx">https://msdn.microsoft.com/cs-cz/library/hh279674.aspx</a>
</li>

<li>UTF-8 Everywhere<br />
<a href="http://utf8everywhere.org/">http://utf8everywhere.org/</a>
</li>

<li>Rust by Example<br />
<a href="http://rustbyexample.com/">http://rustbyexample.com/</a>
</li>

<li>Rust oficiálně ve Fedoře<br />
<a href="https://mojefedora.cz/rust-oficialne-ve-fedore/">https://mojefedora.cz/rust-oficialne-ve-fedore/</a>
</li>

<li>Resource acquisition is initialization<br />
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization</a>
</li>

<li>TIOBE index (October 2016)<br />
<a href="http://www.tiobe.com/tiobe-index/">http://www.tiobe.com/tiobe-index/</a>
</li>

<li>Porovnání Go, D a Rustu na OpenHubu:<br />
<a href="https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits">https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits</a>
</li>

<li>String Types in Rust<br />
<a href="http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/">http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/</a>
</li>

<li>Trait (computer programming)<br />
<a href="https://en.wikipedia.org/wiki/Trait_%28computer_programming%29">https://en.wikipedia.org/wiki/Trait_%28computer_programming%29</a>
</li>

<li>Type inference<br />
<a href="https://en.wikipedia.org/wiki/Type_inference">https://en.wikipedia.org/wiki/Type_inference</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

