<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Rust: práce s binárními soubory, serializace a deserializace</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Rust: práce s binárními soubory, serializace a deserializace</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve dvacáté čtvrté části seriálu o programovacím jazyku Rust se seznámíme se základními a prozatím velmi jednoduchými koncepty práce s&nbsp;binárními soubory a taktéž s&nbsp;problematikou serializace a deserializace dat s&nbsp;využitím projektu bincode.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Práce s&nbsp;binárními soubory</a></p>
<p><a href="#k02">2. Čtení jednotlivých bajtů z&nbsp;binárního souboru</a></p>
<p><a href="#k03">3. Přesun &bdquo;kurzoru&ldquo; v&nbsp;rámci aktuálně otevřeného souboru</a></p>
<p><a href="#k04">4. Serializace a deserializace dat</a></p>
<p><a href="#k05">5. Použití modulu <strong>bincode</strong></a></p>
<p><a href="#k06">6. Příprava projektu řízeného nástrojem Cargo</a></p>
<p><a href="#k07">7. První projekt: serializace a deserializace hodnoty typu <strong>i32</strong></a></p>
<p><a href="#k08">8. Druhý projekt: korektní reakce na chyby, které by mohly při serializaci či deserializaci nastat</a></p>
<p><a href="#k09">9. Přímá serializace do souboru</a></p>
<p><a href="#k10">10. Třetí projekt: přímá serializace do souboru</a></p>
<p><a href="#k11">11. Přímá deserializace ze souboru</a></p>
<p><a href="#k12">12. Čtvrtý projekt: přímá deserializace ze souboru</a></p>
<p><a href="#k13">13. Repositář s&nbsp;demonstračními příklady a projekty</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Práce s&nbsp;binárními soubory</h2>

<p><a
href="https://www.root.cz/clanky/programovaci-jazyk-rust-prace-se-soubory-a-se-standardnimi-proudy/">V&nbsp;předchozím</a>
dílu seriálu o programovacím jazyku Rust jsme se seznámili se základními traity
a strukturami používanými při práci s&nbsp;datovými streamy, tj.&nbsp;například
se soubory či se standardními streamy (stdin, stdout, stderr). Připomeňme si,
že základními traity pro vstupně-výstupní operace jsou traity <a
href="https://doc.rust-lang.org/std/io/trait.Read.html">std::io::Read</a> a <a
href="https://doc.rust-lang.org/std/io/trait.Write.html">std::io::Write</a>.
Tyto traity jsou mj.&nbsp;implementovány i strukturami <a
href="https://doc.rust-lang.org/std/fs/struct.File.html">std::fs::File</a>
(zápis i čtení ze souborů), <a
href="https://doc.rust-lang.org/std/io/struct.Stdin.html">std::io::Stdin</a>
(jen čtení), <a
href="https://doc.rust-lang.org/std/io/struct.Stdout.html">std::io::Stdout</a>
(jen zápis) a samozřejmě také <a
href="https://doc.rust-lang.org/std/io/struct.Stderr.html">std::io::Stderr</a>
(opět jen zápis).</p>

<p>Pro bufferovaný vstup se používá struktura <a
href="https://doc.rust-lang.org/std/io/struct.BufReader.html">std::io::BufReader</a>
(ta mj.&nbsp;umožňuje pracovat se souborem jako s&nbsp;iterátorem vracejícím
jednotlivé řádky) a pro bufferovaný výstup se používá struktura <a
href="https://doc.rust-lang.org/std/io/struct.BufWriter.html">std::io::BufWriter</a>.
Tyto struktury se v&nbsp;praxi používají velmi často, protože je práce
s&nbsp;nimi většinou efektivnější, než nízkoúrovňový přístup přes traity Read a
Write.</p>

<p>V&nbsp;dalším textu se budeme zabývat jak prací s&nbsp;binárními soubory,
tak i problematikou serializace a deserializace. Ta ovšem není řešena
standardní knihovnou, ale dalšími přídavnými moduly.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Čtení jednotlivých bajtů z&nbsp;binárního souboru</h2>

<p>Traity Read a Write pracují na úrovni jednotlivých bajtů popř.&nbsp;řezů
polí a vektorů obsahujících bajty. Pouze v&nbsp;případě čtení je možné načíst
celý řetězec v&nbsp;kódování UTF-8 (pokud vstupní soubor obsahuje neplatné
kombinace bajtů, vrátí se chyba). Konkrétně se jedná o následující funkce:</p>

<table>
<tr><th>Trait</th><th>Funkce</th><th>Použitý typ</th><th>Návratová hodnota</th></tr>
<tr><td>Write</td><td>write</td><td>&amp;[u8]</td><td>void</td></tr>
<tr><td>Read</td><td>read</td><td>&amp;[u8]</td><td>void</td></tr>
<tr><td>Read</td><td>read_to_end</td><td>Vec&lt;u8&gt;</td><td>Result&lt;usize&gt;</td></tr>
<tr><td>Read</td><td>read_to_string</td><td>String</td><td>Result&lt;usize&gt;</td></tr>
</table>

<p>Pokud budete potřebovat postupně načítat jednotlivé bajty (což je
neefektivní), je možné použít například následující funkci s&nbsp;jednobajtovým
bufferem:</p>

<pre>
fn read_one_byte(mut fin: &amp;File) -&gt; bool {
    let mut buffer = [0; 1];
&nbsp;
    match <strong>fin.read(&amp;mut buffer)</strong> {
        Ok(size) =&gt; {
            if size &gt; 0 {
                println!("Read: '{}' = {}", buffer[0] as char, buffer[0]);
            }
            size &gt; 0
        }
        Err(error) =&gt; {
            println!("file read error: {}", error);
            false
        }
    }
}
</pre>

<p>Zajímavé je, že přesný typ bufferu, tedy že se jedná o buffer s&nbsp;jedinou
položkou typu <strong>u8</strong>, si překladač zjistí až z&nbsp;řádku, kde se
provádí volání <strong>fin.read()</strong>. Zajímavý je i řádek
s&nbsp;přetypováním bajtu na znak <strong>buffer[0] as char</strong>, což je
zde nutné, aby makro <strong>println!</strong> skutečně do apostrofů vypsalo
jednotlivé znaky a nikoli jejich kódy. Funkce samozřejmě bude korektně pracovat
pouze pro (rozšířené) ASCII soubory.</p>

<p>Poznámka: povšimněte si, že díky použití typu Result a pattern matchingu
není nutné, aby funkce <strong>read</strong> vracela &bdquo;speciální&ldquo;
hodnoty typu EOF atd., podobně jako to známe například z&nbsp;céčkovské
<strong>getc</strong> apod.</p>

<p>Následující příklad nejdříve vytvoří textový soubor &bdquo;test.txt&ldquo; a
následně z&nbsp;tohoto souboru postupně načte jednotlivé bajty:</p>

<pre>
use std::io::Read;
use std::io::Write;
use std::fs::File;
&nbsp;
fn write_message_to_file(mut fout: &amp;File) {
    match fout.write(b"Hello, world!\n") {
        Ok(written) =&gt; {
            println!("{} bytes written", written);
        }
        Err(error) =&gt; {
            println!("write error: {}", error);
        }
    }
}
&nbsp;
fn create_hello_world_file(file_name: &amp;str) {
    match File::create(file_name) {
        Ok(fout) =&gt; {
            write_message_to_file(&amp;fout);
        }
        Err(error) =&gt; {
            println!("file create error: {}", error);
        }
    }
}
&nbsp;
fn read_one_byte(mut fin: &amp;File) -&gt; bool {
    let mut buffer = [0; 1];
&nbsp;
    match fin.read(&amp;mut buffer) {
        Ok(size) =&gt; {
            if size &gt; 0 {
                println!("Read: '{}' = {}", buffer[0] as char, buffer[0]);
            }
            size &gt; 0
        }
        Err(error) =&gt; {
            println!("file read error: {}", error);
            false
        }
    }
}
&nbsp;
fn main() {
    create_hello_world_file("test.txt");
&nbsp;
    let fin = File::open("test.txt").unwrap();
&nbsp;
    while read_one_byte(&amp;fin)
    {}
}
</pre>

<p>Tento program by měl po svém spuštění na standardní výstup vypsat
následující řádky (poslední přečtený znak je znakem pro konec řádku, proto je
výstup &bdquo;rozházený&ldquo;):</p>

<pre>
14 bytes written
Read: 'H' = 72
Read: 'e' = 101
Read: 'l' = 108
Read: 'l' = 108
Read: 'o' = 111
Read: ',' = 44
Read: ' ' = 32
Read: 'w' = 119
Read: 'o' = 111
Read: 'r' = 114
Read: 'l' = 108
Read: 'd' = 100
Read: '!' = 33
Read: '
' = 10
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Přesun &bdquo;kurzoru&ldquo; v&nbsp;rámci aktuálně otevřeného souboru</h2>

<p>Při práci se soubory, tj.&nbsp;se strukturou <a
href="https://doc.rust-lang.org/std/fs/struct.File.html">std::fs::File</a>, je
možné se díky implementaci traitu <a
href="https://doc.rust-lang.org/std/io/trait.Seek.html">std::io::Seek</a>
posouvat v&nbsp;otevřeném souboru na libovolnou pozici. Pokud například
otevřeme testovací textový soubor &bdquo;test.txt&ldquo; pro čtení:</p>

<pre>
let mut fin = File::open("test.txt").unwrap();
</pre>

<p>je možné se posouvat relativně vůči začátku souboru, konci souboru (zde je
nutné použít záporný offset!) či vůči aktuální pozici imaginárního
&bdquo;kurzoru&ldquo; v&nbsp;souboru. Zápis je jednoduchý:</p>

<pre>
// posun vůči začátku souboru (sedmý bajt)
// lze se posunout ZA konec souboru, ovšem chování je systémově závislé
let position = fin.seek(SeekFrom::Start(7));
&nbsp;
// posun vůči konci souboru (druhý bajt od konce)
// lze se posunout ZA konec souboru, nikoli PŘED jeho začátek
let position = fin.seek(SeekFrom::End(-2));
&nbsp;
// posun relativně vůči aktuální pozici
// lze se posunout ZA konec souboru, nikoli PŘED jeho začátek
let position = fin.seek(SeekFrom::Current(-2));
</pre>

<p>Metoda <strong>seek</strong> vrátí aktuální (novou) pozici v&nbsp;souboru.
Podívejme se nyní na jednoduchý demonstrační příklad:</p>

<pre>
use std::io::Read;
use std::io::Write;
use std::io::Seek;
use std::io::SeekFrom;
use std::fs::File;
use std::io::Error;
&nbsp;
fn write_message_to_file(mut fout: &amp;File) {
    match fout.write(b"Hello, world!\n") {
        Ok(written) =&gt; {
            println!("{} bytes written", written);
        }
        Err(error) =&gt; {
            println!("write error: {}", error);
        }
    }
}
&nbsp;
fn create_hello_world_file(file_name: &amp;str) {
    match File::create(file_name) {
        Ok(fout) =&gt; {
            write_message_to_file(&amp;fout);
        }
        Err(error) =&gt; {
            println!("file create error: {}", error);
        }
    }
}
&nbsp;
fn read_one_byte(mut fin: &amp;File) -&gt; bool {
    let mut buffer = [0; 1];
&nbsp;
    match fin.read(&amp;mut buffer) {
        Ok(size) =&gt; {
            if size &gt; 0 {
                println!("Read: '{}' = {}", buffer[0] as char, buffer[0]);
            }
            size &gt; 0
        }
        Err(error) =&gt; {
            println!("file read error: {}", error);
            false
        }
    }
}
&nbsp;
fn print_position(pos: Result&lt;u64, Error&gt;) {
    println!("position in file: {}", pos.unwrap());
}
&nbsp;
fn main() {
    create_hello_world_file("test.txt");
&nbsp;
    let mut fin = File::open("test.txt").unwrap();
&nbsp;
    read_one_byte(&amp;fin);
&nbsp;
    let position = fin.seek(SeekFrom::Start(7));
    read_one_byte(&amp;fin);
    print_position(position);
&nbsp;
    let position = fin.seek(SeekFrom::End(-2));
    read_one_byte(&amp;fin);
    print_position(position);
&nbsp;
    let position = fin.seek(SeekFrom::Current(-2));
    read_one_byte(&amp;fin);
    print_position(position);
}
</pre>

<p>Tento program by měl po svém spuštění na standardní výstup vypsat
následující řádky s&nbsp;přečtenými bajty a taktéž s&nbsp;aktuálně nastavenou
pozicí v&nbsp;souboru:</p>

<pre>
14 bytes written
Read: 'H' = 72
Read: 'w' = 119
position in file: 7
Read: '!' = 33
position in file: 12
Read: 'd' = 100
position in file: 11
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Serializace a deserializace dat</h2>

<p>Ve druhé části dnešního článku se budeme zabývat problematikou serializace a
deserializace dat. Tato činnost není ve standardní knihovně přímo podporovaná,
takže je nutné použít nějakou další knihovnu popř.&nbsp;si napsat vlastní
řešení (to bude ovšem pravděpodobně ošklivé a obecně nebezpečné, protože se
možná nevyhnete nutnosti použití takzvaných <a
href="https://doc.rust-lang.org/nomicon/transmutes.html">transmutací</a>). Pro
začátek si řekneme základní informace o serializaci do binárních souborů,
k&nbsp;čemuž se dnes pravděpodobně nejčastěji používá knihovna <a
href="http://tyoverby.com/bincode/bincode/">bincode</a>. V&nbsp;případě potřeby
je možné tuto knihovnu doplnit o knihovny <a
href="http://tyoverby.com/bincode/byteorder/index.html">Byteorder</a> (převody
hodnot mezi little a bit endian a naopak) a <a
href="http://tyoverby.com/bincode/serde/index.html">Serde</a> (serializing and
deserializing), jejíž možnosti si popíšeme příště.</p>

<p>Poznámka: v&nbsp;minulosti se používala i knihovna <a
href="https://github.com/rust-lang-deprecated/rustc-serialize">rustc-serialize</a>,
ta již ovšem není podporovaná, protože přednost dostala knihovna <i>Serde</i>,
která je dnes v&nbsp;této oblasti de facto standardem.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Použití modulu <strong>bincode</strong></h2>

<p>V&nbsp;knihovně <strong>bincode</strong> nalezneme několik pomocných
struktur, výčtových typů a především pak následující čtveřici funkcí:</p>

<table>
<tr><th>Funkce</th><th>Význam</th></tr>
<tr><td>serialize</td><td>serializace objektu do vektoru bajtů</td></tr>
<tr><td>deserialize</td><td>deserializace řezu polem bajtů do zvoleného typu objektu</td></tr>
<tr><td>serialize_into</td><td>serializace přímo do writeru (typicky do souboru)</td></tr>
<tr><td>deserialize_from</td><td>deserializace z&nbsp;readeru (typicky ze souboru)</td></tr>
</table>

<p>Teoreticky je možné si vystačit s&nbsp;těmito čtyřmi funkcemi, v&nbsp;praxi
však bude nutné pro uživatelské struktury implementovat traity <i>Serialize</i>
a <i>Deserialize</i>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Příprava projektu řízeného nástrojem Cargo</h2>

<p>Pro použití modulu <strong>bincode</strong> si vytvoříme nový projekt, a to
s&nbsp;využitím velmi užitečného nástroje <i>Cargo</i>. Tento nástroj již byl
stručně popsán <a
href="https://mojefedora.cz/cargo-spravce-projektu-a-balicku-pro-programovaci-jazyk-rust/">na
konkurenčním :-) serveru</a>, takže si dnes jen ve stručnosti řekneme, jak se
projekt vytvoří a jak se následně zkonfiguruje.</p>

<p>Pro vytvoření nového projektu postačuje použít příkaz <strong>cargo
new</strong>, kterému se předá jméno projektu (to je povinné). Pokud se ovšem
má vytvořit projekt, jehož výsledkem bude spustitelná aplikace (což je i náš
případ), je nutné navíc použít přepínač <strong>–-bin</strong>. V&nbsp;opačném
případě by se totiž vytvořil projekt s&nbsp;kostrou knihovny. Vytvořme si nyní
jednoduchý projekt nazvaný &bdquo;serialization1&ldquo;, po jehož překladu
získáme spustitelnou aplikaci (a nikoli knihovnu):</p>

<pre>
cargo new --bin serialiation
     Created binary (application) `serialiation` project
</pre>

<p>Struktura projektu by měla vypadat následovně &ndash; jedná se o jeden
projektový soubor nazvaný <strong>Cargo.toml</strong> a o jeden zdrojový soubor
umístěný v&nbsp;podadresáři <strong>src</strong>:</p>

<pre>
.
├── Cargo.toml
└── src
    └── main.rs
&nbsp;
1 directory, 2 files
</pre>

<p>Z&nbsp;hlediska nástroje Cargo je nejdůležitější projektový soubor
pojmenovaný jednoduše <strong>Cargo.toml</strong>. Již víme, že tento soubor je
vytvořen automaticky při inicializaci projektu, ovšem předpokládá se, že ho
bude programátor měnit v&nbsp;závislosti na potřebách konkrétního projektu. My
si tento soubor upravíme tak, že do závislostí přidáme modul (<i>crate</i>)
nazvaný <strong>bincode</strong>:</p>

<pre>
[package]
name = "serialization1"
version = "0.1.0"
authors = ["Pavel Tisnovsky &lt;ptisnovs@redhat.com&gt;"]
&nbsp;
[dependencies]
<strong>bincode = "0.7.0"</strong>
</pre>

<p>Příkazem <strong>cargo build</strong> můžeme spustit proces, který stáhne
všechny potřebné knihovny a následně projekt přeloží.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. První projekt: serializace a deserializace hodnoty typu <strong>i32</strong></h2>

<p>Použití funkcí <strong>serialize()</strong> a <strong>deserialize()</strong>
si ukážeme na velmi jednoduchém příkladu, v&nbsp;němž nejdříve serializujeme
celé číslo typu <strong>i32</strong> (integer) do vektoru čtyř bajtů a následně
provedeme deserializaci. Návratovými hodnotami obou zmíněných funkcí je
Result&lt;typ&gt;, takže pro jednoduchost použijeme metodu
<strong>unwrap()</strong> na získání vrácené hodnoty. Budeme tedy předpokládat,
že při serializaci a deserializaci nedojde k&nbsp;žádné chybě (což je poněkud
optimistické):</p>

<pre>
#[macro_use]
extern crate bincode;
&nbsp;
use bincode::{serialize, deserialize, Infinite};
&nbsp;
fn main() {
    let x:i32 = 0x12345678;
&nbsp;
    let serialized: Vec&lt;u8&gt; = <strong>serialize(&amp;x, Infinite)</strong>.unwrap();
&nbsp;
    for i in &amp;serialized {
        println!("{:x}", i);
    }
&nbsp;
    let deserialized: <strong>i32</strong> = <strong>deserialize(&amp;serialized[..])</strong>.unwrap();
&nbsp;
    println!("deserialized value: 0x{:x}", deserialized);
}
</pre>

<p>Hodnota <strong>Infinite</strong> slouží pro určení maximální povolené
velikosti výsledného vektoru bajtů (zde samozřejmě bez omezení).</p>

<p>Povšimněte si, že při volání funkce <strong>deserialize()</strong> musíme
překladači pomoci se zjištěním typu deserializovaného objektu. To je ostatně
logické, protože překladač nemá žádnou jinou možnost, jak ze sekvence bajtů
zjistit, o jaký objekt se jednalo.</p>

<p>Při prvním spuštění se stáhnou všechny potřebné knihovny:</p>

<pre>
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading bincode v0.7.0
 Downloading num-traits v0.1.37
 Downloading byteorder v1.0.0
 Downloading serde v0.9.15
   Compiling num-traits v0.1.37
   Compiling byteorder v1.0.0
   Compiling serde v0.9.15
   Compiling bincode v0.7.0
   Compiling serialization1 v0.1.0 (file:///home/tester/temp/presentations/rust/new/serialization1)
    Finished debug [unoptimized + debuginfo] target(s) in 41.77 secs
     Running `target/debug/serialization1`
</pre>

<pre>
Finished debug [unoptimized + debuginfo] target(s) in 0.0 secs
Running `target/debug/serialization1`
78
56
34
12
deserialized value: 0x12345678
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Druhý projekt: korektní reakce na chyby, které by mohly při serializaci či deserializaci nastat</h2>

<p>Druhý projekt, který je opět vytvořený přes nástroj Cargo, pouze vylepšuje
projekt předchozí, protože zde již reagujeme na všechny problémy, s&nbsp;nimiž
se můžeme při serializaci a deserializaci setkat. Podobně jako u mnoha
předchozích příkladů se i zde snažíme používat pattern matching namísto
otrockého psaní podmínek if-else s&nbsp;explicitním přístupem do struktury
Result. Opět si povšimněte, že jsme ve větvi <strong>Ok(deserialed)</strong>
nuceni překladači &bdquo;pomoci&ldquo; uvedením typu deserializovaného objektu
s&nbsp;použitím pomocné proměnné:</p>

<pre>
#[macro_use]
extern crate bincode;
&nbsp;
use bincode::{serialize, deserialize, Infinite};
&nbsp;
fn main() {
    let x:i32 = 0x12345678;
&nbsp;
    match <strong>serialize(&amp;x, Infinite)</strong> {
        Ok(encoded) =&gt; {
            for i in &amp;encoded {
                println!("{:x}", i);
            }
            match <strong>deserialize(&amp;encoded)</strong> {
                Ok(deserialized) =&gt; {
                    let val:i32 = deserialized;
                    println!("deserialized value: 0x{:x}", val);
                }
                Err(error) =&gt; {
                    println!("deserialization error: {}", error);
                }
            }
        }
        Err(error) =&gt; {
            println!("serialization error: {}", error);
        }
    }
}
</pre>

<p>Překlad a spuštění tohoto projektu bude vypadat následovně:</p>

<pre>
Compiling serialization2 v0.1.0 (file:///home/tester/temp/presentations/rust/new/serialization2)
Finished debug [unoptimized + debuginfo] target(s) in 0.80 secs
Running `target/debug/serialization2`
78
56
34
12
deserialized value: 0x12345678
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Přímá serializace do souboru</h2>

<p>S&nbsp;využitím funkce <strong>serialize_into()</strong> je možné
serializovaný objekt přímo uložit do souboru. To může být velmi výhodné, neboť
knihovna <strong>bincode</strong> může serializaci provádět postupně, dokonce
ani nemusí v&nbsp;operační paměti vytvářet serializovaný obraz objektu, což se
projeví především u obrovských objektů (představme si například dvourozměrné
pole s&nbsp;texturou či rastrovým obrázkem atd.). Serializaci přímo do souboru
provedeme takto:</p>

<pre>
fn serialize_value(mut fout: &amp;File, value: i32) {
    match serialize_into(&amp;mut fout, &amp;value, Infinite) {
        Ok(_) =&gt; {
            println!("successfully serialized into file");
        }
        Err(error) =&gt; {
            println!("serialization error: {}", error);
        }
    }
}
</pre>

<p>Poznámka: soubor musí být samozřejmě otevřen v&nbsp;režimu zápisu. Hodnota
<strong>Infinite</strong> opět instruuje knihovnu <strong>bincode</strong>, aby
nijak neomezovala velikost výsledného proudu bajtů.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Třetí projekt: přímá serializace do souboru</h2>

<p>Výše uvedenou funkci <strong>serialize_value()</strong> použijeme ve třetím
projektu, který po svém spuštění vytvoří soubor nazvaný &bdquo;test.bin&ldquo;.
Tento soubor by měl mít velikost přesně čtyři bajty a měl by obsahovat binární
podobu celého čísla 0x12345678, decimálně tedy 305419896:</p>

<pre>
#[macro_use]
extern crate bincode;
&nbsp;
use std::fs::File;
&nbsp;
use bincode::{serialize_into, Infinite};
&nbsp;
fn serialize_value(mut fout: &amp;File, value: i32) {
    match serialize_into(&amp;mut fout, &amp;value, Infinite) {
        Ok(_) =&gt; {
            println!("successfully serialized into file");
        }
        Err(error) =&gt; {
            println!("serialization error: {}", error);
        }
    }
}
&nbsp;
fn main() {
    let x:i32 = 0x12345678;
&nbsp;
    match File::create("test.bin") {
        Ok(fout) =&gt; {
            serialize_value(&amp;fout, x);
        }
        Err(error) =&gt; {
            println!("file create error: {}", error);
        }
    }
}
</pre>

<p>Po zadání příkazu <strong>cargo run</strong> by se měla vypsat zpráva o
úspěšném překladu a vytvoření binárního souboru (cesta k&nbsp;vytvořenému
spustitelnému souboru bude samozřejmě odlišná do cesty získané na testovacím
stroji):</p>

<pre>
Finished debug [unoptimized + debuginfo] target(s) in 0.0 secs
Running `/home/tester/temp/presentations/rust/new/serialization3/target/debug/serialization3`
successfully serialized into file
</pre>

<p>Vytvořený binární soubor si můžeme velmi snadno prohlédnout nástrojem
<strong>od</strong> nebo <strong>hexdump</strong>:</p>

<pre>
hexdump -C test.bin 
00000000  78 56 34 12                                       |xV4.|
00000004
</pre>

<p>Poznámka: v&nbsp;tomto případě by bylo vhodnější použít modul
<strong>byteorder</strong> a explicitně specifikovat, v&nbsp;jakém pořadí se
mají bajty reprezentující 32bitové celé číslo uložit. Podrobnosti si ukážeme
příště (tento modul je navíc velmi jednoduše použitelný).</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Přímá deserializace ze souboru</h2>

<p>Opakem přímé serializace dat do souboru je samozřejmě přímá deserializace.
To opět znamená, že není zapotřebí, aby se obsah souboru nejdříve explicitně
načetl do pole či vektoru bajtů a následně se provedla deserializace. Obě
činnosti provede funkce nazvaná <strong>deserialize_from()</strong>, která
vynechá mezikrok s&nbsp;načtením celého souboru (což by v&nbsp;některých
případech ani nebylo možné a už vůbec ne praktické). Podívejme se nyní na velmi
jednoduchou funkci provádějící deserializaci čtyř bajtů tvořících jedno celé
číslo typu <strong>i32</strong>. Překladač zná návratovou hodnotu funkce a
z&nbsp;ní si odvodí typ, který se má deserializovat. Jak však můžete vidět,
není odvození triviální, neboť vlastně říkáme: potřebujeme hodnotu typu
<strong>i32</strong> obalenou typem Option, která se získá z&nbsp;typu
Result&lt;i32&gt; a přesně tento typ vyžaduj jak návratovou hodnotu generické
funkce <strong>deserialize_from()</strong>:</p>

<pre>
fn deserialize_value(mut fout: &amp;File) -&gt; Option&lt;i32&gt; {
    match deserialize_from(&amp;mut fout, Infinite) {
        Ok(value) =&gt; {
            println!("successfully deserialized from file");
            Some(value)
        }
        Err(error) =&gt; {
            println!("serialization error: {}", error);
            None
        }
    }
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Čtvrtý projekt: přímá deserializace ze souboru</h2>

<p>Výše popsanou funkci přidáme do dnešního posledního projektu, do jehož
adresáře si však nejdříve překopírujte soubor &bdquo;test.bin&ldquo; vytvořený
předchozím projektem (pokud to neuděláte, aspoň si můžete otestovat, do jaké
míry se v&nbsp;programu pracuje s&nbsp;chybovými stavy):</p>

<pre>
#[macro_use]
extern crate bincode;
&nbsp;
use std::fs::File;
&nbsp;
use bincode::{deserialize_from, Infinite};
&nbsp;
fn deserialize_value(mut fout: &amp;File) -&gt; Option&lt;i32&gt; {
    match deserialize_from(&amp;mut fout, Infinite) {
        Ok(value) =&gt; {
            println!("successfully deserialized from file");
            Some(value)
        }
        Err(error) =&gt; {
            println!("serialization error: {}", error);
            None
        }
    }
}
&nbsp;
fn main() {
    match File::open("test.bin") {
        Ok(fout) =&gt; {
            match deserialize_value(&amp;fout) {
                Some(value) =&gt; {
                    println!("deserialized value: 0x{:x}", value);
                }
                None =&gt; {
                }
            }
        }
        Err(error) =&gt; {
            println!("file create error: {}", error);
        }
    }
}
</pre>

<p>Pokud byl soubor &bdquo;test.bin&ldquo; nalezen a pokud skutečně obsahuje
čtyři bajty 0x78, 0x56, 0x34 a 0x12, měl by tento příklad vypsat na standardní
výstup následující text:</p>

<pre>
successfully deserialized from file
deserialized value: 0x12345678
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Repositář s&nbsp;demonstračními příklady a projekty</h2>

<p>Všechny dnes popisované demonstrační příklady a projekty byly, ostatně
podobně jako ve všech předchozích částech <a
href="https://www.root.cz/serialy/programovaci-jazyk-rust/">tohoto seriálu</a>,
uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Příklady a projekty si můžete v&nbsp;případě potřeby stáhnout i jednotlivě bez
nutnosti klonovat celý repositář:</p>

<table>
<tr><th>Příklad</th><th>Adresa</th></tr>
<tr><td>306_read_bytes.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/306_read_bytes.rs">https://github.com/tisnik/presentations/blob/master/rust/306_read_bytes.rs</a></td></tr>
<tr><td>307_seek</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/307_seek.rs">https://github.com/tisnik/presentations/blob/master/rust/307_seek.rs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>serialization1</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/serialization1">https://github.com/tisnik/presentations/blob/master/rust/projects/serialization1</a></td></tr>
<tr><td>serialization2</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/serialization2">https://github.com/tisnik/presentations/blob/master/rust/projects/serialization2</a></td></tr>
<tr><td>serialization3</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/serialization3">https://github.com/tisnik/presentations/blob/master/rust/projects/serialization3</a></td></tr>
<tr><td>deserialization1</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/projects/deserialization1">https://github.com/tisnik/presentations/blob/master/rust/projects/deserialization1</a></td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Cargo: správce projektů a balíčků pro programovací jazyk Rust<br />
<a href="https://mojefedora.cz/cargo-spravce-projektu-a-balicku-pro-programovaci-jazyk-rust/">https://mojefedora.cz/cargo-spravce-projektu-a-balicku-pro-programovaci-jazyk-rust/</a>
</li>

<li>Network Communication and Serialization in Rust<br />
<a href="https://www.safaribooksonline.com/blog/2014/01/28/network-communication-serialization-rust/">https://www.safaribooksonline.com/blog/2014/01/28/network-communication-serialization-rust/</a>
</li>

<li>Crate bincode<br />
<a href="http://tyoverby.com/bincode/bincode/index.html">http://tyoverby.com/bincode/bincode/index.html</a>
</li>

<li>Struct std::fs::File<br />
<a href="https://doc.rust-lang.org/std/fs/struct.File.html">https://doc.rust-lang.org/std/fs/struct.File.html</a>
</li>

<li>Trait std::io::Seek<br />
<a href="https://doc.rust-lang.org/std/io/trait.Seek.html">https://doc.rust-lang.org/std/io/trait.Seek.html</a>
</li>

<li>Trait std::io::Read<br />
<a href="https://doc.rust-lang.org/std/io/trait.Read.html">https://doc.rust-lang.org/std/io/trait.Read.html</a>
</li>

<li>Trait std::io::Write<br />
<a href="https://doc.rust-lang.org/std/io/trait.Write.html">https://doc.rust-lang.org/std/io/trait.Write.html</a>
</li>

<li>Trait std::io::BufRead<br />
<a href="https://doc.rust-lang.org/std/io/trait.BufRead.html">https://doc.rust-lang.org/std/io/trait.BufRead.html</a>
</li>

<li>Module std::io::prelude<br />
<a href="https://doc.rust-lang.org/std/io/prelude/index.html">https://doc.rust-lang.org/std/io/prelude/index.html</a>
</li>

<li>std::net::IpAddr<br />
<a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">https://doc.rust-lang.org/std/net/enum.IpAddr.html</a>
</li>

<li>std::net::Ipv4Addr<br />
<a href="https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html">https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html</a>
</li>

<li>std::net::Ipv6Addr<br />
<a href="https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html">https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html</a>
</li>

<li>TcpListener<br />
<a href="https://doc.rust-lang.org/std/net/struct.TcpListener.html">https://doc.rust-lang.org/std/net/struct.TcpListener.html</a>
</li>

<li>TcpStream<br />
<a href="https://doc.rust-lang.org/std/net/struct.TcpStream.html">https://doc.rust-lang.org/std/net/struct.TcpStream.html</a>
</li>

<li>Binary heap (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Binary_heap">https://en.wikipedia.org/wiki/Binary_heap</a>
</li>

<li>Binární halda (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_halda">https://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_halda</a>
</li>

<li>Halda (datová struktura)<br />
<a href="https://cs.wikipedia.org/wiki/Halda_%28datov%C3%A1_struktura%29">https://cs.wikipedia.org/wiki/Halda_%28datov%C3%A1_struktura%29</a>
</li>

<li>Struct std::collections::HashSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html">https://doc.rust-lang.org/std/collections/struct.HashSet.html</a>
</li>

<li>Struct std::collections::BTreeSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html">https://doc.rust-lang.org/std/collections/struct.BTreeSet.html</a>
</li>

<li>Struct std::collections::BinaryHeap<br />
<a href="https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html">https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html</a>
</li>

<li>Set (abstract data type)<br />
<a href="https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support">https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support</a>
</li>

<li>Associative array<br />
<a href="https://en.wikipedia.org/wiki/Associative_array">https://en.wikipedia.org/wiki/Associative_array</a>
</li>

<li>Hash Table<br />
<a href="https://en.wikipedia.org/wiki/Hash_table">https://en.wikipedia.org/wiki/Hash_table</a>
</li>

<li>B-tree<br />
<a href="https://en.wikipedia.org/wiki/B-tree">https://en.wikipedia.org/wiki/B-tree</a>
</li>

<li>Pedro Celis: Robin Hood Hashing (naskenované PDF!)<br />
<a href="https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf">https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf</a>
</li>

<li>Robin Hood hashing<br />
<a href="http://codecapsule.com/2013/11/11/robin-hood-hashing/">http://codecapsule.com/2013/11/11/robin-hood-hashing/</a>
</li>

<li>Robin Hood hashing: backward shift deletion<br />
<a href="http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/">http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/</a>
</li>

<li>Module std::collections<br />
<a href="https://doc.rust-lang.org/std/collections/">https://doc.rust-lang.org/std/collections/</a>
</li>

<li>Module std::vec<br />
<a href="https://doc.rust-lang.org/nightly/std/vec/index.html">https://doc.rust-lang.org/nightly/std/vec/index.html</a>
</li>

<li>Struct std::collections::VecDeque<br />
<a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html">https://doc.rust-lang.org/std/collections/struct.VecDeque.html</a>
</li>

<li>Struct std::collections::LinkedList<br />
<a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html">https://doc.rust-lang.org/std/collections/struct.LinkedList.html</a>
</li>

<li>Module std::fmt<br />
<a href="https://doc.rust-lang.org/std/fmt/">https://doc.rust-lang.org/std/fmt/</a>
</li>

<li>Macro std::println<br />
<a href="https://doc.rust-lang.org/std/macro.println.html">https://doc.rust-lang.org/std/macro.println.html</a>
</li>

<li>Enum std::result::Result<br />
<a href="https://doc.rust-lang.org/std/result/enum.Result.html">https://doc.rust-lang.org/std/result/enum.Result.html</a>
</li>

<li>Module std::result<br />
<a href="https://doc.rust-lang.org/std/result/">https://doc.rust-lang.org/std/result/</a>
</li>

<li>Result<br />
<a href="http://rustbyexample.com/std/result.html">http://rustbyexample.com/std/result.html</a>
</li>

<li>Rust stdlib: Option<br />
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">https://doc.rust-lang.org/std/option/enum.Option.html</a>
</li>

<li>Module std::option<br />
<a href="https://doc.rust-lang.org/std/option/index.html">https://doc.rust-lang.org/std/option/index.html</a>
</li>

<li>Rust by example: option<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>Rust by example: if-let<br />
<a href="http://rustbyexample.com/flow_control/if_let.html">http://rustbyexample.com/flow_control/if_let.html</a>
</li>

<li>Rust by example: while let<br />
<a href="http://rustbyexample.com/flow_control/while_let.html">http://rustbyexample.com/flow_control/while_let.html</a>
</li>

<li>Rust by example: Option&lt;i32&gt;<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>An Overview of Macros in Rust<br />
<a href="http://words.steveklabnik.com/an-overview-of-macros-in-rust">http://words.steveklabnik.com/an-overview-of-macros-in-rust</a>
</li>

<li>A Practical Intro to Macros in Rust 1.0<br />
<a href="https://danielkeep.github.io/practical-intro-to-macros.html">https://danielkeep.github.io/practical-intro-to-macros.html</a>
</li>

<li>The Rust Programming Language: macros<br />
<a href="https://doc.rust-lang.org/beta/book/macros.html">https://doc.rust-lang.org/beta/book/macros.html</a>
</li>

<li>Rust by example: 15 macro_rules!<br />
<a href="http://rustbyexample.com/macros.html">http://rustbyexample.com/macros.html</a>
</li>

<li>Primitive Type isize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.isize.html">https://doc.rust-lang.org/nightly/std/primitive.isize.html</a>
</li>

<li>Primitive Type usize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">https://doc.rust-lang.org/nightly/std/primitive.usize.html</a>
</li>

<li>Primitive Type array<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.array.html">https://doc.rust-lang.org/nightly/std/primitive.array.html</a>
</li>

<li>Module std::slice<br />
<a href="https://doc.rust-lang.org/nightly/std/slice/">https://doc.rust-lang.org/nightly/std/slice/</a>
</li>

<li>Rust by Example: 2.3 Arrays and Slices<br />
<a href="http://rustbyexample.com/primitives/array.html">http://rustbyexample.com/primitives/array.html</a>
</li>

<li>What is the difference between Slice and Array (stackoverflow)<br />
<a href="http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array">http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array</a>
</li>

<li>Learning Rust With Entirely Too Many Linked Lists<br />
<a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/">http://cglab.ca/~abeinges/blah/too-many-lists/book/</a>
</li>

<li>Testcase: linked list<br />
<a href="http://rustbyexample.com/custom_types/enum/testcase_linked_list.html">http://rustbyexample.com/custom_types/enum/testcase_linked_list.html</a>
</li>

<li>Operators and Overloading<br />
<a href="https://doc.rust-lang.org/book/operators-and-overloading.html">https://doc.rust-lang.org/book/operators-and-overloading.html</a>
</li>

<li>Module std::ops<br />
<a href="https://doc.rust-lang.org/std/ops/index.html">https://doc.rust-lang.org/std/ops/index.html</a>
</li>

<li>Module std::cmp<br />
<a href="https://doc.rust-lang.org/std/cmp/index.html">https://doc.rust-lang.org/std/cmp/index.html</a>
</li>

<li>Trait std::ops::Add<br />
<a href="https://doc.rust-lang.org/stable/std/ops/trait.Add.html">https://doc.rust-lang.org/stable/std/ops/trait.Add.html</a>
</li>

<li>Trait std::ops::AddAssign<br />
<a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html">https://doc.rust-lang.org/std/ops/trait.AddAssign.html</a>
</li>

<li>Trait std::ops::Drop<br />
<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">https://doc.rust-lang.org/std/ops/trait.Drop.html</a>
</li>

<li>Trait std::cmp::Eq<br />
<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">https://doc.rust-lang.org/std/cmp/trait.Eq.html</a>
</li>

<li>Struct std::boxed::Box<br />
<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">https://doc.rust-lang.org/std/boxed/struct.Box.html</a>
</li>

<li>Explore the ownership system in Rust<br />
<a href="https://nercury.github.io/rust/guide/2015/01/19/ownership.html">https://nercury.github.io/rust/guide/2015/01/19/ownership.html</a>
</li>

<li>Rust's ownership and move semantic<br/>
<a href="http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics">http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics</a>
</li>

<li>Trait std::marker::Copy<br/>
<a href="https://doc.rust-lang.org/stable/std/marker/trait.Copy.html">https://doc.rust-lang.org/stable/std/marker/trait.Copy.html</a>
</li>

<li>Trait std::clone::Clone<br />
<a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html">https://doc.rust-lang.org/stable/std/clone/trait.Clone.html</a>
</li>

<li>The Stack and the Heap<br />
<a href="https://doc.rust-lang.org/book/the-stack-and-the-heap.html">https://doc.rust-lang.org/book/the-stack-and-the-heap.html</a>
</li>

<li>Rust Compare: Pointers &amp; References<br />
<a href="http://www.rust-compare.com/site/pointers.html">http://www.rust-compare.com/site/pointers.html</a>
</li>

<li>Rust Compare: Parameters<br />
<a href="http://www.rust-compare.com/site/params.html">http://www.rust-compare.com/site/params.html</a>
</li>

<li>Why does this compile? Automatic dereferencing?<br />
<a href="https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183">https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183</a>
</li>

<li>Understanding Pointers, Ownership, and Lifetimes in Rust<br />
<a href="http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html">http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html</a>
</li>

<li>Rust lang series episode #25 — pointers (#rust-series)<br />
<a href="https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series">https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series</a>
</li>

<li>Rust - home page<br />
<a href="https://www.rust-lang.org/en-US/">https://www.rust-lang.org/en-US/</a>
</li>

<li>Rust - Frequently Asked Questions<br />
<a href="https://www.rust-lang.org/en-US/faq.html">https://www.rust-lang.org/en-US/faq.html</a>
</li>

<li>Destructuring and Pattern Matching<br />
<a href="https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/">https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/</a>
</li>

<li>The Rust Programming Language<br />
<a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>
</li>

<li>Rust (programming language)<br />
<a href="https://en.wikipedia.org/wiki/Rust_%28programming_language%29">https://en.wikipedia.org/wiki/Rust_%28programming_language%29</a>
</li>

<li>Go - home page<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>Stack Overflow - Most Loved, Dreaded, and Wanted language<br />
<a href="https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted">https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted</a>
</li>

<li>Rust vs Go (dva roky staré hodnocení, od té doby došlo k posunům v obou jazycích)<br />
<a href="http://jaredforsyth.com/2014/03/22/rust-vs-go/">http://jaredforsyth.com/2014/03/22/rust-vs-go/</a>
</li>

<li>Rust vs Go: My experience<br />
<a href="https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/">https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/</a>
</li>

<li>Friends of Rust (Organizations running Rust in production)<br />
<a href="https://www.rust-lang.org/en-US/friends.html">https://www.rust-lang.org/en-US/friends.html</a>
</li>

<li>Rust programs versus C++ g++<br />
<a href="https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp">https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp</a>
</li>

<li>Další benchmarky (nejedná se o reálné příklady &bdquo;ze života&ldquo;)<br />
<a href="https://github.com/kostya/benchmarks">https://github.com/kostya/benchmarks</a>
</li>

<li>Go na Redditu<br />
<a href="https://www.reddit.com/r/golang/">https://www.reddit.com/r/golang/</a>
</li>

<li>Rust vs. Go<br />
<a href="http://vschart.com/compare/rust/vs/go-language">http://vschart.com/compare/rust/vs/go-language</a>
</li>

<li>Abstraction without overhead: traits in Rust<br />
<a href="https://blog.rust-lang.org/2015/05/11/traits.html">https://blog.rust-lang.org/2015/05/11/traits.html</a>
</li>

<li>Method Syntax<br />
<a href="https://doc.rust-lang.org/book/method-syntax.html">https://doc.rust-lang.org/book/method-syntax.html</a>
</li>

<li>Traits in Rust<br />
<a href="https://doc.rust-lang.org/book/traits.html">https://doc.rust-lang.org/book/traits.html</a>
</li>

<li>Functional Programming in Rust - Part 1 : Function Abstraction<br />
<a href="http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/">http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/</a>
</li>

<li>Of the emerging systems languages Rust, D, Go and Nim, which is the strongest language and why?<br />
<a href="https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why">https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why</a>
</li>

<li>Chytré ukazatele (moderní verze jazyka C++) [MSDN]<br />
<a href="https://msdn.microsoft.com/cs-cz/library/hh279674.aspx">https://msdn.microsoft.com/cs-cz/library/hh279674.aspx</a>
</li>

<li>UTF-8 Everywhere<br />
<a href="http://utf8everywhere.org/">http://utf8everywhere.org/</a>
</li>

<li>Rust by Example<br />
<a href="http://rustbyexample.com/">http://rustbyexample.com/</a>
</li>

<li>Rust oficiálně ve Fedoře<br />
<a href="https://mojefedora.cz/rust-oficialne-ve-fedore/">https://mojefedora.cz/rust-oficialne-ve-fedore/</a>
</li>

<li>Resource acquisition is initialization<br />
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization</a>
</li>

<li>TIOBE index (October 2016)<br />
<a href="http://www.tiobe.com/tiobe-index/">http://www.tiobe.com/tiobe-index/</a>
</li>

<li>Porovnání Go, D a Rustu na OpenHubu:<br />
<a href="https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits">https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits</a>
</li>

<li>String Types in Rust<br />
<a href="http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/">http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/</a>
</li>

<li>Trait (computer programming)<br />
<a href="https://en.wikipedia.org/wiki/Trait_%28computer_programming%29">https://en.wikipedia.org/wiki/Trait_%28computer_programming%29</a>
</li>

<li>Type inference<br />
<a href="https://en.wikipedia.org/wiki/Type_inference">https://en.wikipedia.org/wiki/Type_inference</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

