<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Rust - předávání parametrů referencí, elegantní způsob práce se sekvencemi</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Rust - předávání parametrů referencí, elegantní způsob práce se sekvencemi</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Třetí část seriálu o programovacím jazyku Rust je věnována dvěma tématům. Nejdříve si řekneme, jak je možné předávat parametry do funkcí přes reference a následně si ukážeme &bdquo;funkcionální&ldquo; způsob práce se sekvencemi.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Předání parametrů do funkcí hodnotou</a></p>
<p><a href="#k02">2. Předání parametrů referencí</a></p>
<p><a href="#k03">3. Změna hodnoty proměnné předané referencí</a></p>
<p><a href="#k04">4. Měnitelný parametr předaný hodnotou</a></p>
<p><a href="#k05">5. Iterátory &ndash; malé zopakování z&nbsp;předchozích dílů</a></p>
<p><a href="#k06">6. Délka sekvence</a></p>
<p><a href="#k07">7. Průchod sekvencí se získáním indexu každého prvku</a></p>
<p><a href="#k08">8. Otočení sekvence</a></p>
<p><a href="#k09">9. Funkcionální přístup při zpracování sekvencí &ndash; funkce vyššího řádu</a></p>
<p><a href="#k10">10. Metoda <strong>map</strong>: aplikace vybrané funkce na každý prvek sekvence</a></p>
<p><a href="#k11">11. Metoda <strong>filter</strong>: výběr pouze některých prvků s&nbsp;použitím filtru</a></p>
<p><a href="#k12">12. Metody <strong>take</strong> a <strong>take_while</strong>: získání pouze zvoleného počtu prvků ze sekvence</a></p>
<p><a href="#k13">13. Nekonečné sekvence a práce s&nbsp;nimi</a></p>
<p><a href="#k14">14. Metoda <strong>fold</strong>: postupné zpracování prvků sekvence</a></p>
<p><a href="#k15">15. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k16">16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Předání parametrů do funkcí hodnotou</h2>

<p>První problematikou, kterou se dnes budeme zabývat, je způsob předávání
parametrů funkcím přes takzvané <i>reference</i>. Již na tomto místě je vhodné
upozornit na to, že pod názvem <i>reference</i> se v&nbsp;programovacím jazyku
Rust skrývá koncept, který je v&nbsp;některých ohledech odlišný od referencí
známých z&nbsp;Javy či z&nbsp;C++. Nejprve si však připomeňme, jak vypadá
funkce, do které se předávají parametry hodnotou (value). Taková funkce může
vypadat následovně:</p>

<pre>
fn print_values(arg1:<strong>i32</strong>, arg2:<strong>i32</strong>) {
    println!("function print_values()");
    println!("Variable1: {}", arg1);
    println!("Variable2: {}", arg2);
}
</pre>

<p>Při volání této funkce jí můžeme předat jak proměnné, tak i hodnoty. U
proměnných nezávisí na tom, zda jsou měnitelné či neměnitelné, ovšem musí mít
správný typ, což je striktně hlídáno:</p>

<pre>
fn main() {
    let variable1 = 1;
    let mut variable2 = 1;
&nbsp;
    print_values(variable1, variable2);
    print_values(100, 200);
}
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Předání parametrů referencí</h2>

<p>V&nbsp;některých případech však není nutné, aby se parametr funkci musel
předávat hodnotou, protože předání hodnotou vlastně znamená, že se vytvoří
kopie parametru, což je mnohdy zbytečné (můžeme například chtít předat
rozsáhlou strukturu). V&nbsp;takovém případě lze předat pouze <i>referenci</i>
na hodnotu. Datový typ &bdquo;reference na hodnotu typu TYP_X&ldquo; se
zapisuje <strong>&amp;TYP_X</strong>. Funkce akceptující referenci má
z&nbsp;tohoto důvodu nepatrně odlišnou deklaraci datových typů parametrů.
Uvnitř funkce je nutné reference takzvaně dereferencovat, na což se používá
unární operátor * zapisovaný před argument či proměnnou typu reference:</p>

<pre>
fn pass_by_reference(arg1:<strong>&amp;i32</strong>, arg2:<strong>&amp;i32</strong>) {
    println!("function pass_by_reference()");
    println!("Variable1: {}", *arg1);
    println!("Variable2: {}", *arg2);
}
</pre>

<p>Funkce se bude volat následovně (povšimněte si použití &amp; pro získání
reference na proměnné):</p>

<pre>
fn main() {
    let variable1 = 1;
    let mut variable2 = 2;
&nbsp;
    print_variables(variable1, variable2);
    pass_by_reference(<strong>&amp;variable1</strong>, <strong>&amp;variable2</strong>);
}
</pre>

<p>Již zde můžeme vidět odlišnost od referencí používaných v&nbsp;Javě i C++.
Javu si dovolím z&nbsp;dalšího popisu vynechat, protože v&nbsp;ní se striktně
rozlišuje mezi primitivními datovými typy (předávané vždy hodnotou) a
referenčními (objektovými) typy (předávané naopak vždy referencí); což
mj.&nbsp;vede ke zjednodušení syntaxe a k&nbsp;některým sémantickým problémům.
V&nbsp;C++ je možné použít skutečné reference, ovšem s&nbsp;nimi se uvnitř
funkce pracuje odlišně &ndash; nemusí se například provádět explicitní
dereferencování. Reference jsou v&nbsp;obou jazycích vždy inicializované.
Naopak v&nbsp;C++ není možné použít následující zápis, který je naopak
v&nbsp;Rustu zcela legální:</p>

<pre>
pass_by_reference(<strong>&amp;100</strong>, <strong>&amp;200</strong>);
</pre>

<p>Celý zdrojový kód příkladu, v&nbsp;němž je deklarována funkce akceptující
parametry předávané hodnotou a funkce akceptující reference, vypadá
následovně:</p>

<pre>
fn print_variables(arg1:i32, arg2:i32) {
    println!("function print_variables()");
    println!("Variable1: {}", arg1);
    println!("Variable2: {}", arg2);
}
&nbsp;
fn pass_by_reference(arg1:<strong>&amp;i32</strong>, arg2:<strong>&amp;i32</strong>) {
    println!("function pass_by_reference()");
    println!("Variable1: {}", *arg1);
    println!("Variable2: {}", *arg2);
}
&nbsp;
fn main() {
    let variable1 = 1;
    let mut variable2 = 2;
&nbsp;
    print_variables(variable1, variable2);
    pass_by_reference(<strong>&amp;variable1</strong>, <strong>&amp;variable2</strong>);
}
</pre>

<p>Po spuštění by se měly dvakrát po sobě vypsat shodné hodnoty:</p>

<pre>
function print_variables()
Variable1: 1
Variable2: 2
function pass_by_reference()
Variable1: 1
Variable2: 2
</pre>

<p>Ve skutečnosti není nutné dereferenci zapisovat ve chvíli, kdy si překladač
dokáže odvodit, že přistupujeme k referencované hodnotě. Stručně řečeno – pokud
z funkce pass_by_reference odstraníte hvězdičky (operátor dereference),
proběhne překlad v pořádku. Totéž platí i při volání funkce, kdy je možné
zapsat znak &amp; kolikrát chcete. Je to zvláštní a užitečný důsledek silné
typové kontroly a typové inference.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Změna hodnoty proměnné předané referencí</h2>

<p>Proměnné, které jsou do nějaké funkce předané referencí, lze uvnitř této
funkce změnit, ovšem je nutné dodržet několik podmínek. Nejprve se podívejme na
demonstrační příklad, který vychází z&nbsp;částečně mylné domněnky, že se
s&nbsp;referencemi v&nbsp;Rustu zachází stejně jako s&nbsp;ukazateli (zápis
dereference se skutečně práci s&nbsp;ukazateli podobá, ale jen syntakticky,
nikoli sémanticky). V&nbsp;příkladu je deklarována funkce nazvaná
<strong>mutate_variable</strong>, v&nbsp;níž se přes referenci mění proměnná
předaná v&nbsp;argumentu <strong>arg2</strong>:</p>

<pre>
fn mutate_variable(arg1:i32, arg2:<strong>&amp;i32</strong>) {
    println!("mutation ...");
    let x = arg1 * 2;
    <strong>*arg2 = x</strong>;
}
&nbsp;
fn print_variables(arg1:i32, arg2:i32) {
    println!("function print_variables()");
    println!("Variable1: {}", arg1);
    println!("Variable2: {}", arg2);
}
&nbsp;
fn pass_by_reference(arg1:&amp;i32, arg2:&amp;i32) {
    println!("function pass_by_reference()");
    println!("Variable1: {}", *arg1);
    println!("Variable2: {}", *arg2);
}
&nbsp;
fn main() {
    let variable1 = 1;
    let mut variable2 = 1;
&nbsp;
    print_variables(variable1, variable2);
    pass_by_reference(&amp;variable1, &amp;variable2);
&nbsp;
    mutate_variable(variable1, <strong>&amp;variable2</strong>);
&nbsp;
    print_variables(variable1, variable2);
    pass_by_reference(&amp;variable1, &amp;variable2);
}
</pre>

<p>Tento příklad se ovšem nepodaří přeložit, a to z&nbsp;toho důvodu, že volané
funkci sice skutečně předáváme měnitelnou proměnnou, ovšem typ &amp;i32
označuje neměnitelnou referenci:</p>

<pre>
error: cannot assign to immutable borrowed content `*arg2`
 --&gt; 29_func_params.rs:4:5
  |
4 |     *arg2 = x;
  |     ^^^^^^^^^
&nbsp;
error: aborting due to previous error
</pre>

<p>Pokud skutečně potřebujeme změnit hodnotu proměnné předané referencí, je
nutné pozměnit typ druhého parametru funkce na <strong>&amp;mul i32</strong>,
což je typ znamenající &bdquo;referenci, přes níž je možné změnit hodnotu
referencovaného objektu&ldquo;:</p>

<pre>
fn mutate_variable(arg1:i32, arg2:<strong>&amp;mut i32</strong>) {
    println!("mutation ...");
    let x = arg1 * 2;
    <strong>*arg2 = x</strong>;
}
&nbsp;
fn print_variables(arg1:i32, arg2:i32) {
    println!("function print_variables()");
    println!("Variable1: {}", arg1);
    println!("Variable2: {}", arg2);
}
&nbsp;
fn pass_by_reference(arg1:&amp;i32, arg2:&amp;i32) {
    println!("function pass_by_reference()");
    println!("Variable1: {}", *arg1);
    println!("Variable2: {}", *arg2);
}
&nbsp;
fn main() {
    let variable1 = 1;
    let mut variable2 = 1;
&nbsp;
    print_variables(variable1, variable2);
    pass_by_reference(&amp;variable1, &amp;variable2);
&nbsp;
    mutate_variable(variable1, <strong>&amp;mut variable2</strong>);
&nbsp;
    print_variables(variable1, variable2);
    pass_by_reference(&amp;variable1, &amp;variable2);
}
</pre>

<p>Po této nepatrné změně se program přeloží a bude pracovat podle požadavků
&ndash; funkce <strong>mutate_variable</strong> skutečně změní hodnotu druhé
proměnné:</p>

<pre>
function print_variables()
Variable1: 1
Variable2: 1
function pass_by_reference()
Variable1: 1
Variable2: 1
mutation ...
function print_variables()
Variable1: 1
Variable2: 2
function pass_by_reference()
Variable1: 1
Variable2: 2
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Měnitelný parametr předaný hodnotou</h2>

<p>To, že je reference měnitelná, však ještě neznamená, že budeme moci změnit
hodnotu neměnitelné (immutable) proměnné. Překladač jazyka Rust si tuto
skutečnost ohlídá. Pokud například změníme deklaraci druhé proměnné tak, že se
bude jednat o proměnnou neměnitelnou:</p>

<pre>
    let variable1 = 1;
    let variable2 = 1;
</pre>

<p>Dojde při překladu k&nbsp;chybě:</p>

<pre>
error: cannot borrow immutable local variable `variable2` as mutable
  --&gt; 29_func_params.rs:26:37
   |
21 |     let variable2 = 1;
   |         --------- use `mut variable2` here to make mutable
...
26 |     mutate_variable(variable1, &amp;mut variable2);
   |                                     ^^^^^^^^^ cannot borrow mutably
&nbsp;
error: aborting due to previous error
</pre>

<p>Nepomůže nám ani pokus o obelstění překladače tím, že při volání funkce
vynecháme klíčové slovo <strong>mut</strong>:</p>

<pre>
    let variable1 = 1;
    let variable2 = 1;
    mutate_variable(variable1, &amp;variable2);
</pre>

<pre>
error[E0308]: mismatched types
  --&gt; 29_func_params.rs:26:32
   |
26 |     mutate_variable(variable1, &amp;variable2);
   |                                ^^^^^^^^^^ values differ in mutability
   |
   = note: expected type `&amp;mut i32`
   = note:    found type `&amp;i32`
&nbsp;
error: aborting due to previous error
</pre>

<p>Podívejme se ještě na jedno úskalí jazyka Rust. Pokud se pokusíme změnit
hodnotu argumentu uvnitř funkce:</p>

<pre>
fn mutate_variable(arg1:i32, arg2:&amp;mut i32) {
    println!("mutation ...");
    let x = arg1 * 2;
    arg1  = x;
    *arg2 = arg1;
}
</pre>

<p>Dojde opět k&nbsp;detekci chyby, protože argument je neměnitelný:</p>

<pre>
error[E0384]: re-assignment of immutable variable `arg1`
 --&gt; 30_func_params.rs:4:5
  |
1 | fn mutate_variable(arg1:i32, arg2:&amp;mut i32) {
  |                    ---- first assignment to `arg1`
...
4 |     arg1  = x;
  |     ^^^^^^^^^ re-assignment of immutable variable
&nbsp;
error: aborting due to previous error
</pre>

<p>Tuto chybu můžeme napravit použitím klíčového slova <strong>mut</strong>
před jméno argumentu. Tím ovšem jen povolujeme změnu hodnoty, která vznikla při
volání funkce, nikoli změnu původní proměnné (první parametr je předáván
hodnotou):</p>

<pre>
fn mutate_variable(<strong>mut</strong> arg1:i32, arg2:&amp;mut i32) {
    println!("mutation ...");
    let x = arg1 * 2;
    arg1  = x;
    *arg2 = arg1;
}
&nbsp;
fn print_variables(arg1:i32, arg2:i32) {
    println!("function print_variables()");
    println!("Variable1: {}", arg1);
    println!("Variable2: {}", arg2);
}
&nbsp;
fn pass_by_reference(arg1:&amp;i32, arg2:&amp;i32) {
    println!("function pass_by_reference()");
    println!("Variable1: {}", *arg1);
    println!("Variable2: {}", *arg2);
}
&nbsp;
fn main() {
    let variable1 = 1;
    let mut variable2 = 1;
&nbsp;
    print_variables(variable1, variable2);
    pass_by_reference(&amp;variable1, &amp;variable2);
&nbsp;
    mutate_variable(variable1, &amp;mut variable2);
&nbsp;
    print_variables(variable1, variable2);
    pass_by_reference(&amp;variable1, &amp;variable2);
}
</pre>

<p>Po spuštění je patrné, že se změna prvního argumentu nijak neprojevila vně
funkce:</p>

<pre>
function print_variables()
Variable1: 1
Variable2: 1
function pass_by_reference()
Variable1: 1
Variable2: 1
mutation ...
function print_variables()
Variable1: 1
Variable2: 2
function pass_by_reference()
Variable1: 1
Variable2: 2
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Iterátory &ndash; malé zopakování z&nbsp;předchozích dílů</h2>

<p>Minule jsme se seznámili s&nbsp;objektem typu <i>range</i>, který dokáže
generovat určitou sekvenci hodnot. Tento typ objektů je specifickým typem
takzvaných <i>iterátorů</i>. Iterátory jsou známé a často používané i
v&nbsp;dalších programovacích jazycích; v&nbsp;Rustu je jejich užitečnost ještě
zvýšena tím, že iterátory lze použít pro vytváření a zpracování takzvaných
&bdquo;líných sekvencí&ldquo;, které mohou být v&nbsp;některých případech i
nekonečné. Zpracování (potenciálně) nekonečných sekvencí v&nbsp;konečném čase
je umožněno právě díky tomu, že se prvky sekvence vyhodnocují
&bdquo;líně&ldquo;, tj.&nbsp;až v&nbsp;tom okamžiku, kdy jsou skutečně
zapotřebí.</p>

<p>V&nbsp;dalších příkladech budeme pro jednoduchost často používat objekty
typu <i>range</i>, takže si jen připomeňme, jak se s&nbsp;nimi pracuje:</p>

<pre>
fn main() {
    // projiti sekvence hodnot od 1 do 10 (vcetne)
    for i in <strong>1..11</strong> {
        println!("{}", i);
    }
}
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Délka sekvence</h2>

<p>Délku sekvence můžeme zjistit několika způsoby. Nejprimitivnější je průchod
všemi prvky sekvence v&nbsp;programové smyčce typu <strong>for
each</strong>:</p>

<pre>
fn main() {
    // promenna pouzita pro vypocet delky sekvence (naivni implementace)
    let mut cnt :u32 = 0;
&nbsp;
    // projiti sekvence hodnot od 1 do 10 (vcetne)
    for i in 1..11 {
        cnt += 1;
    }
    println!("{}", cnt);
}
</pre>

<p>Tuto možnost si zde ukazujeme jen z&nbsp;toho důvodu, že namísto jména
řídicí proměnné smyčky můžeme použít univerzální vzorek _, což je idiomatický
způsob použitý ve chvíli, kdy programátor potřebuje naznačit, že ho hodnota
přiřazovaná do řídicí proměnné nezajímá:</p>

<pre>
fn main() {
    // promenna pouzita pro vypocet delky sekvence (naivni implementace)
    let mut cnt :u32 = 0;
&nbsp;
    // projiti sekvence hodnot od 1 do 10 (vcetne)
    // ridici promenna se nikdy nepouzije
    for _ in 1..11 {
        cnt += 1;
    }
    println!("{}", cnt);
}
</pre>

<p>Iterátor je samostatným objektem, což již víme z&nbsp;minula, takže ho lze
přiřadit do proměnné:</p>

<pre>
fn main() {
    // iterator (povsimnete si, ze je nemenny)
    let iter = 1..11;
&nbsp;
    // promenna pouzita pro vypocet delky sekvence (naivni implementace)
    let mut cnt :u32 = 0;
&nbsp;
    // projiti sekvence hodnot od 1 do 10 (vcetne)
    // ridici promenna se nikdy nepouzije
    for _ in iter {
        cnt += 1;
    }
    println!("{}", cnt);
}
</pre>

<p>Mnohem jednodušší a samozřejmě i rychlejší je však zavolat metodu
<strong>count</strong> vracející počet prvků (pokud se tedy nejedná o
nekonečnou sekvenci, tam je ovšem volání této metody ohlídáno):</p>

<pre>
fn main() {
    // iterator (povsimnete si, ze je nemenny)
    let iter = 1..11;
&nbsp;
    // promenna pouzita pro vypocet delky sekvence (typ musi byt nastaven na usize)
    let cnt :usize;
&nbsp;
    cnt = iter.count();
&nbsp;
    println!("count = {}", cnt);
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Průchod sekvencí se získáním indexu každého prvku</h2>

<p>V&nbsp;mnoha případech může být užitečné získat při průchodu sekvence indexy
jednotlivých prvků. První řešení spočívá v&nbsp;použití počítané programové
smyčky, to je však poměrně nešikovné (viz Java a její rozhraní
<strong>ListIterator</strong>). Lepší je následující způsob založený na metodě
<strong>enumerate</strong>, která vrací nový iterátor. Tento iterátor generuje
dvojici index+prvek a jeho použití je velmi jednoduché:</p>

<pre>
fn main() {
    // iterator (povsimnete si, ze je nemenny)
    let iter = 1..11;
&nbsp;
    // pruchod sekvenci se ziskanim indexu a hodnoty kazdeho prvku
    for <strong>(index,item)</strong> in <strong>iter.enumerate()</strong> {
	println!("item[{}] = {}", index, item);
    }
}
</pre>

<p>Můžeme zde vidět i novou sémantiku <strong>(index,item</strong>) použitelnou
i v&nbsp;jiných částech jazyka.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Otočení sekvence</h2>

<p>V&nbsp;některých případech je zapotřebí sekvenci otočit. K&nbsp;tomuto účelu
lze využít metodu nazvanou <strong>rev</strong> (od slova
&bdquo;reverse&ldquo;). Její použití je jednoduché, jak je ostatně patrné
z&nbsp;následujícího demonstračního příkladu:</p>

<pre>
fn main() {
    // iterator (povsimnete si, ze je nemenny)
    let iter1 = 1..11;
    let iter2 = iter1.rev();
&nbsp;
    // pruchod sekvenci se ziskanim indexu a hodnoty kazdeho prvku
    for (index,item) in iter2.enumerate() {
	println!("item[{}] = {}", index, item);
    }
}
</pre>

<p>Výsledek by nás v&nbsp;tomto případě neměl překvapit:</p>

<pre>
item[0] = 10
item[1] = 9
item[2] = 8
item[3] = 7
item[4] = 6
item[5] = 5
item[6] = 4
item[7] = 3
item[8] = 2
item[9] = 1
</pre>

<p>O některých důsledcích plynoucích z&nbsp;použití této metody si více řekneme
v&nbsp;části o nekonečných sekvencích.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Funkcionální přístup při zpracování sekvencí &ndash; funkce vyššího řádu</h2>

<p>V&nbsp;programovacím jazyce Rust nalezneme několik metod použitelných při
zpracování sekvencí vytvářených pomocí iterátorů. Tyto metody mají jména i
sémantiku převzatou z&nbsp;funkcionálních jazyků (poprvé se objevily
v&nbsp;LISPu, který sice není čistě funkcionální, ale nalezneme v&nbsp;něm
mnoho prvků, které se do FP jazyků posléze dostaly). Mezi zmíněné metody
&ndash; které by byly ve funkcionálních jazycích implementovány funkcemi
vyššího řádu &ndash; patří zejména <strong>map</strong>,
<strong>filter</strong>, <strong>take</strong>, <strong>take_while</strong> a
<strong>fold</strong> (někde se nazývá <strong>reduce</strong>).</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Metoda <strong>map</strong>: aplikace vybrané funkce na každý prvek sekvence</h2>

<p>S&nbsp;funkcí či možná přesněji řečeno s&nbsp;metodou vyššího řádu nazvanou
<strong>map</strong> jsme se již setkali minule, takže si jen krátce
připomeňme, že <strong>map</strong> postupně aplikuje jí předanou funkci na
jednotlivé prvky nějaké sekvence a vytváří tak sekvenci novou (modifikovanou).
V&nbsp;prvním příkladu se funkce <strong>map</strong> bude postupně volat
neanonymní funkci <strong>square</strong>:</p>

<pre>
fn square(x :i32) -&gt; i32 {
    x * x
}
&nbsp;
fn main() {
    // iterator (povsimnete si, ze je nemenny)
    let iter1 = 1..11;
    let iter2 = iter1.<strong>map(square)</strong>;
&nbsp;
    // pruchod sekvenci se ziskanim indexu a hodnoty kazdeho prvku
    for (index,item) in iter2.enumerate() {
	println!("item[{}] = {}", index, item);
    }
}
</pre>

<p>Po překladu získáme na standardním výstupu tyto zprávy:</p>

<pre>
item[0] = 1
item[1] = 4
item[2] = 9
item[3] = 16
item[4] = 25
item[5] = 36
item[6] = 49
item[7] = 64
item[8] = 81
item[9] = 100
</pre>

<p>Můžeme samozřejmě použít i anonymní funkci, což je více idiomatické:</p>

<pre>
fn main() {
    // iterator (povsimnete si, ze je nemenny)
    let iter1 = 1..11;
    let iter2 = iter1.<strong>map(|x| x*x)</strong>;

    // pruchod sekvenci se ziskanim indexu a hodnoty kazdeho prvku
    for (index,item) in iter2.enumerate() {
        println!("item[{}] = {}", index, item);
    }
}
</pre>

<p>Jen si připomeňme, že do anonymní funkce lze bez problémů zapisovat bloky,
protože poslední výraz v&nbsp;bloku určuje i hodnotu celého bloku (blok je
<i>výraz</i>, ne <i>příkaz</i>). To stejné platí i pro rozhodovací konstrukce
<strong>if-then</strong> či <strong>match</strong>, takže následující zápis je
zcela korektní a funkční:</p>

<pre>
fn main() {
    // iterator (povsimnete si, ze je nemenny)
    let iter1 = 1..11;
    let iter2 = iter1.<strong>map(|x| {if x&lt;5 {x*x} else {10/x}}</strong>);

    // pruchod sekvenci se ziskanim indexu a hodnoty kazdeho prvku
    for (index,item) in iter2.enumerate() {
        println!("item[{}] = {}", index, item);
    }
}
</pre>

<p>Po spuštění takto upraveného příkladu získáme na standardním výstupu těchto
deset řádků:</p>

<pre>
item[0] = 1
item[1] = 4
item[2] = 9
item[3] = 16
item[4] = 2
item[5] = 1
item[6] = 1
item[7] = 1
item[8] = 1
item[9] = 1
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Metoda <strong>filter</strong>: výběr pouze některých prvků s&nbsp;použitím filtru</h2>

<p>Užitečná je v&nbsp;mnoha případech i metoda nazvaná <strong>filter</strong>,
která ze sekvence vybere pouze ty prvky, které odpovídají zadanému
<i>predikátu</i>. Predikátem je libovolná funkce vracející pravdivostní hodnotu
<strong>true</strong> či <strong>false</strong>. Zkusme vytvořit a použít
predikát, kterým bude funkce testující, zda je parametr sudé číslo. Povšimněte
si však jedné maličkosti &ndash; anonymní funkci uvedené v&nbsp;metodě
<strong>filter</strong> se postupně předává <i>reference</i> na zpracovávaný
prvek, tudíž je nutné před voláním našeho predikátu <strong>even</strong>
použít dereferenci <strong>*x</strong>:</p>

<pre>
fn even(x :u32) -&gt; bool {
    x % 2 == 0
}
&nbsp;
fn main() {
    // iterator (povsimnete si, ze je nemenny)
    let iter1 = 1..11;
    let iter2 = iter1.<strong>filter(|x| even(*x))</strong>;
&nbsp;
    // pruchod sekvenci se ziskanim indexu a hodnoty kazdeho prvku
    for (index,item) in iter2.enumerate() {
	println!("item[{}] = {}", index, item);
    }
}
</pre>

<p>Výsledek je předvídatelný:</p>

<pre>
item[0] = 2
item[1] = 4
item[2] = 6
item[3] = 8
item[4] = 10
</pre>

<p>Zajímavé je, že anonymní funkci volající náš predikát lze zapsat i jinak
&ndash; již parametr anonymní funkce je označen jako reference, takže kód je
čitelnější (dereferenci si překladač doplní automaticky):</p>

<pre>
fn even(x :u32) -&gt; bool {
    x % 2 == 0
}
&nbsp;
fn main() {
    // iterator (povsimnete si, ze je nemenny)
    let iter1 = 1..11;
    let iter2 = iter1.<strong>filter(|&amp;x| even(x))</strong>;
&nbsp;
    // pruchod sekvenci se ziskanim indexu a hodnoty kazdeho prvku
    for (index,item) in iter2.enumerate() {
	println!("item[{}] = {}", index, item);
    }
}
</pre>

<p>Výsledek překladu bude (bitově) naprosto shodný, stejně jako bude stejný
obsah standardního výstupu:</p>

<pre>
item[0] = 2
item[1] = 4
item[2] = 6
item[3] = 8
item[4] = 10
</pre>

<p>Nejlepší je samozřejmě vložit predikát přímo do anonymní funkce předané
metodě <strong>filter</strong>. S&nbsp;následujícím kódem se pravděpodobně
setkáte nejčastěji:</p>

<pre>
fn main() {
    // iterator (povsimnete si, ze je nemenny)
    let iter1 = 1..11;
    let iter2 = iter1.<strong>filter(|x| x % 2 == 0)</strong>;
&nbsp;
    // pruchod sekvenci se ziskanim indexu a hodnoty kazdeho prvku
    for (index,item) in iter2.enumerate() {
	println!("item[{}] = {}", index, item);
    }
}
</pre>

<p>Výsledek je podle očekávání stále stejný:</p>

<pre>
item[0] = 2
item[1] = 4
item[2] = 6
item[3] = 8
item[4] = 10
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Metody <strong>take</strong> a <strong>take_while</strong>: získání pouze zvoleného počtu prvků ze sekvence</h2>

<p>Ve chvíli, kdy je nutné z&nbsp;nějaké sekvence získat pouze určitý počet
prvků, je možné zavolat metodu nazvanou <strong>take</strong>. Tato metoda
vrátí pouze prvních <i>n</i> prvků ze sekvence, nezávisle na tom, zda se jedná
o sekvenci konečnou či nekonečnou. V&nbsp;následujícím programu se nejprve
vytvoří objekt typu <i>range</i> se sto prvky, následně se s&nbsp;využitím
filtru vyberou pouze sudé prvky a v&nbsp;posledním kroku se
z&nbsp;vyfiltrovaných prvků (je jich celkem padesát) vytvoří sekvence o pouhých
deseti prvcích:</p>

<pre>
fn main() {
    // iterator (povsimnete si, ze je nemenny)
    let iter1 = 1..101;
    let iter2 = iter1.filter(|x| x % 2 == 0);
    let iter3 = <strong>iter2.take(10)</strong>;
&nbsp;
    // pruchod sekvenci se ziskanim indexu a hodnoty kazdeho prvku
    for (index,item) in iter3.enumerate() {
	println!("item[{}] = {}", index, item);
    }
}
</pre>

<p>Po překladu a spouštění se na standardní výstup vypíšou následující
zprávy:</p>

<pre>
item[0] = 2
item[1] = 4
item[2] = 6
item[3] = 8
item[4] = 10
item[5] = 12
item[6] = 14
item[7] = 16
item[8] = 18
item[9] = 20
</pre>

<p>Funkce/metoda <strong>take</strong> bude pracovat správně i ve chvíli, kdy
požadujeme větší počet prvků, než máme k&nbsp;dispozici. K&nbsp;žádnému
překročení mezí nedojde:</p>

<pre>
fn main() {
    // iterator (povsimnete si, ze je nemenny)
    let iter1 = 1..101;
    let iter2 = iter1.filter(|x| x % 2 == 0);
    let iter3 = <strong>iter2.take(1000)</strong>;

    // pruchod sekvenci se ziskanim indexu a hodnoty kazdeho prvku
    for (index,item) in iter3.enumerate() {
        println!("item[{}] = {}", index, item);
    }
}
</pre>

<pre>
item[0] = 2
item[1] = 4
item[2] = 6
item[3] = 8
item[4] = 10
item[5] = 12
item[6] = 14
...
...
...
item[41] = 84
item[42] = 86
item[43] = 88
item[44] = 90
item[45] = 92
item[46] = 94
item[47] = 96
item[48] = 98
item[49] = 100
</pre>

<p>Další zajímavou a užitečnou funkcí (metodou?) vyššího řádu, kterou lze
použít pro zpracování sekvencí, je funkce <strong>take-while</strong>. Tato
funkce se částečně podobá funkci <strong>take</strong>, která z&nbsp;předané
sekvence získá prvních <i>n</i> prvků, ovšem funkce <strong>take-while</strong>
namísto hodnoty <i>n</i> očekává predikát. Dokud predikát vrací hodnotu
<strong>true</strong>, budou se prvky ze vstupní sekvence předávat do sekvence
výstupní, při první hodnotě <strong>false</strong> je funkce ukončena.
Podívejme se na jednoduchý příklad:</p>

<pre>
fn main() {
    let iter1 = 1..999;
    let iter2 = iter1.filter(|x| x % 2 == 0);
    let iter3 = iter2.<strong>take_while(|x| x*x &lt; 200)</strong>;
&nbsp;
    // pruchod sekvenci se ziskanim indexu a hodnoty kazdeho prvku
    for (index,item) in iter3.enumerate() {
        println!("item[{}] = {}", index, item);
    }
}
</pre>

<pre>
item[0] = 2
item[1] = 4
item[2] = 6
item[3] = 8
item[4] = 10
item[5] = 12
item[6] = 14
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Nekonečné sekvence a práce s&nbsp;nimi</h2>

<p>V&nbsp;některých funkcionálních jazycích se setkáme s&nbsp;termíny
<i>nekonečná sekvence</i> popř.&nbsp;<i>&bdquo;líná&ldquo; sekvence (lazy
sekvence)</i>. Tyto termíny spolu úzce souvisí. Připomeňme si, že sekvencí je
v&nbsp;programovacím jazyku Rust myšlen objekt typu &bdquo;iterátor&ldquo;,
v&nbsp;němž je implementována metoda <strong>next</strong>, po jejímž zavolání
se buď vrátí další prvek nebo se, pokud další prvek neexistuje, vrátí hodnota
None (ve skutečnosti metoda <strong>next</strong> vrací hodnotu typu
Option&lt;?&gt;, což však bude téma probírané příště. Pokud iterátor postupně
vrací prvky z&nbsp;nějaké sekvence, znamená to, že po vrácení posledního prvku
je sekvence ukončena. Ovšem může také existovat iterátor &ndash; a je to
poměrně časté &ndash; který neustále vrací další a další hodnoty. Jeden takový
iterátor můžeme získat snadno, protože i objekt typu <i>range</i> nemusí mít
uvedenou horní mez. Zápis je sice poněkud zvláštní, ale plně funkční:</p>

<pre>
fn main() {
    let iter1 = <strong>1..</strong>;
&nbsp;
    // pruchod sekvenci se ziskanim indexu a hodnoty kazdeho prvku
    for (index,item) in iter1.enumerate() {
	println!("item[{}] = {}", index, item);
    }
}
</pre>

<p>Sami si vyzkoušejte příklad přeložit a spustit. Program se ukončí pomocí
Ctrl+C nebo oblíbeným příkazem <strong>kill</strong>.</p>

<p>Nekonečné sekvence již tedy dokážeme vytvořit, ale co se s&nbsp;nimi dá
dělat, když při pokusu o jejich zpracování dostaneme nekonečný počet hodnot? Ve
skutečnosti tak tomu být nemusí, protože metody, které se sekvencemi pracují
(<strong>map</strong>, <strong>filter</strong> atd.), ve skutečnosti nemusí
volat jim předané (anonymní) funkce ihned, ale až ve chvíli, kdy je skutečně
nutné vyčíslit hodnoty prvků. Lze tedy zpracovávat i nekonečné sekvence, ovšem
za předpokladu, že se v&nbsp;řetězci zpracování, například na jeho konci, počet
prvků nějakým způsobem omezí. Podívejme se na příklad:</p>

<pre>
fn main() {
    let iter1 = <strong>1..</strong>;
    let iter2 = iter1.filter(|x| x % 2 == 0);
    let iter3 = iter2.take(10);
&nbsp;
    // pruchod sekvenci se ziskanim indexu a hodnoty kazdeho prvku
    for (index,item) in iter3.enumerate() {
	println!("item[{}] = {}", index, item);
    }
}
</pre>

<p>V&nbsp;tomto příkladu vytvoříme nekonečnou a současně i &bdquo;línou&ldquo;
sekvenci představovanou objektem typu <i>range</i>. Všechny (!) prvky této
sekvence jsou následně profiltrovány a z&nbsp;výsledné nekonečné
&bdquo;líné&ldquo; sekvence je vybráno prvních deset prvků. Na první pohled by
se mělo jednat o nekonečný program, protože anonymní funkci pro vyfiltrování
sudých hodnot zdánlivě aplikujeme na nekonečný počet prvků, ovšem vzhledem
k&nbsp;tomu, že je vyhodnocení &bdquo;líné&ldquo;, je ve skutečnosti zmíněná
anonymní funkce zavolána jen dvacetkrát (zastavení zajišťuje funkce/metoda
<strong>take</strong>):</p>

<pre>
item[0] = 2
item[1] = 4
item[2] = 6
item[3] = 8
item[4] = 10
item[5] = 12
item[6] = 14
item[7] = 16
item[8] = 18
item[9] = 20
</pre>

<p>Samozřejmě lze použít i metodu <strong>take_while</strong>:</p>

<pre>
fn main() {
    let iter1 = 1..;
    let iter2 = iter1.filter(|x| x % 2 == 0);
    let iter3 = iter2.take_while(|x| x*x &lt; 256);
&nbsp;
    // pruchod sekvenci se ziskanim indexu a hodnoty kazdeho prvku
    for (index,item) in iter3.enumerate() {
	println!("item[{}] = {}", index, item);
    }
}
</pre>

<p>S&nbsp;následujícím výstupem:</p>

<pre>
item[0] = 2
item[1] = 4
item[2] = 6
item[3] = 8
item[4] = 10
item[5] = 12
item[6] = 14
</pre>

<p>Možné jsou i další kombinace, které ukazují, že i při zpracování nekonečných
sekvencí nepotřebujeme ani nekonečnou paměť ani nekonečný čas:</p>

<pre>
    let iter1 = 1..;
    let iter2 = iter1.filter(|x| x % 2 == 0);
    let iter3 = iter2.map(|x| x * x );
    let iter4 = iter3.take(20);

    // pruchod sekvenci se ziskanim indexu a hodnoty kazdeho prvku
    for (index,item) in iter4.enumerate() {
        println!("item[{}] = {}", index, item);
    }
}
</pre>

<p>Výsledkem je řada čtverců sudých hodnot:</p>

<pre>
item[0] = 4
item[1] = 16
item[2] = 36
item[3] = 64
item[4] = 100
item[5] = 144
item[6] = 196
item[7] = 256
item[8] = 324
item[9] = 400
item[10] = 484
item[11] = 576
item[12] = 676
item[13] = 784
item[14] = 900
item[15] = 1024
item[16] = 1156
item[17] = 1296
item[18] = 1444
item[19] = 1600
</pre>

<p>Ne všechny metody je však možné na nekonečné sekvence aplikovat. Například
dříve popsaná metoda <strong>rev</strong> je aplikovatelná pouze na sekvence
konečné, což je hlídáno při překladu:</p>

<pre>
fn main() {
    let iter1 = 1..;
    let iter2 = iter1.filter(|x| x % 2 == 0);
    let iter3 = iter2<strong>.rev()</strong>;
    let iter4 = iter3.take_while(|x| x*x &lt; 256);
&nbsp;
    // pruchod sekvenci se ziskanim indexu a hodnoty kazdeho prvku
    for (index,item) in iter3.enumerate() {
        println!("item[{}] = {}", index, item);
    }
}
</pre>

<p>Překlad se v&nbsp;tomto případe nepodaří, a to z&nbsp;toho důvodu, že
sekvencí není možné iterovat pozpátku:</p>

<pre>
error[E0277]: the trait bound `std::ops::RangeFrom&lt;{integer}&gt;: std::iter::DoubleEndedIterator` is not satisfied
 --&gt; 46_iter16.rs:4:23
  |
4 |     let iter3 = iter2.rev();
  |                       ^^^
  |
  = note: required because of the requirements on the impl of `std::iter::DoubleEndedIterator` for `std::iter::Filter&lt;std::ops::RangeFrom&lt;{integer}&gt;, [closure@46_iter16.rs:3:30: 3:44]&gt;`
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Funkce <strong>fold</strong>: postupné zpracování prvků sekvence</h2>

<p>Poslední funkcí vyššího řádu, která nesmí chybět v&nbsp;repertoáru žádné
funkcionálně zaměřené knihovny (a tím pádem ani v&nbsp;repertoáru metod
iterátorů), je funkce pojmenovaná <strong>reduce</strong>
popř.&nbsp;<strong>fold</strong>. Názvy těchto funkcí naznačují jejich účel
&ndash; dochází k&nbsp;postupné redukci prvků uložených v&nbsp;sekvenci, a to
(postupnou) aplikací zvolené uživatelské funkce na jednotlivé prvky a po
krocích počítaný mezivýsledek. V&nbsp;programovacím jazyku Rust se příslušná
metoda, která toto chování zajišťuje, jmenuje <strong>fold</strong> a akceptuje
dva parametry &ndash; počáteční hodnotu &bdquo;akumulátoru&ldquo;
(mezivýsledku) a uzávěr, což je zjednodušeně řečeno funkce (typicky anonymní),
která na sebe má navázánu alespoň jednu volnou proměnnou. Tento uzávěr je
postupně volán se dvěma argumenty &ndash; aktuální hodnotou akumulátoru
(mezivýsledku) a prvkem získaným ze vstupní sekvence. Akumulátor je po každém
volání modifikován tak, že obsahuje hodnotou vrácenou uzávěrem.</p>

<p>Podívejme se na příklad, v&nbsp;němž sečteme všechny prvky zvolené sekvence.
Tato sekvence obsahuje prvky s&nbsp;hodnotou 2, 4, 6 .. 20. Při postupně
prováděném součtu je mezivýsledek nejprve nastaven na nulu, takže poprvé je
anonymní funkce/uzávěr <strong>|sum, x| sum + x</strong> volána
s&nbsp;parametry sum=0 a x=2, podruhé s&nbsp;parametry sum=2, x=4 atd.:</p>

<pre>
fn main() {
    let iter1 = 1..;
    let iter2 = iter1.filter(|x| x % 2 == 0);
    let iter3 = iter2.take(10);
    let suma  = iter3.<strong>fold(0, |sum, x| sum + x)</strong>;
&nbsp;
    println!("sum = {}", suma);
}
</pre>

<p>Po spuštění tohoto příkladu by se na standardním výstupu měla objevit jediná
hodnota 110:</p>

<pre>
sum = 110
</pre>

<p>Nepatrně složitější příklad slouží pro výpočet tabulky faktoriálů. Zde si
povšimněte, že počáteční hodnota mezivýsledku (akumulátoru) je nastavena na
jedničku. Taktéž stojí za povšimnutí, že při konstrukci objektu typu
<i>range</i> můžeme použít proměnné, nikoli nutně konstanty:</p>

<pre>
fn main() {
    for n in 1..10 {
	let fact = <strong>(1..n+1).fold(1, |prod, x| prod * x)</strong>;
	println!("{}! = {}", n, fact);
    }
}
</pre>

<p>Výsledkem tohoto programu bude tabulka s&nbsp;faktoriály prvních devíti
přirozených čísel:</p>

<pre>
1! = 1
2! = 2
3! = 6
4! = 24
5! = 120
6! = 720
7! = 5040
8! = 40320
9! = 362880
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes ukázané demonstrační příklady, resp.&nbsp;přesněji řečeno
jejich bezchybné varianty, byly uloženy do Git repositáře dostupného na adrese
<a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě bez nutnosti
klonovat celý (dnes již objemný) repositář:</p>

<table>
<tr><th>Příklad</th><th>Odkaz</th></tr>
<tr><td>29_func_params.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/29_func_params.rs">https://github.com/tisnik/presentations/blob/master/rust/29_func_params.rs</a></td></tr>
<tr><td>30_func_params.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/30_func_params.rs">https://github.com/tisnik/presentations/blob/master/rust/30_func_params.rs</a></td></tr>
<tr><td>31_iter1.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/31_iter1.rs">https://github.com/tisnik/presentations/blob/master/rust/31_iter1.rs</a></td></tr>
<tr><td>32_iter2.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/32_iter2.rs">https://github.com/tisnik/presentations/blob/master/rust/32_iter2.rs</a></td></tr>
<tr><td>33_iter3.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/33_iter3.rs">https://github.com/tisnik/presentations/blob/master/rust/33_iter3.rs</a></td></tr>
<tr><td>34_iter4.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/34_iter4.rs">https://github.com/tisnik/presentations/blob/master/rust/34_iter4.rs</a></td></tr>
<tr><td>35_iter5.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/35_iter5.rs">https://github.com/tisnik/presentations/blob/master/rust/35_iter5.rs</a></td></tr>
<tr><td>36_iter6.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/36_iter6.rs">https://github.com/tisnik/presentations/blob/master/rust/36_iter6.rs</a></td></tr>
<tr><td>37_iter7.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/37_iter7.rs">https://github.com/tisnik/presentations/blob/master/rust/37_iter7.rs</a></td></tr>
<tr><td>38_iter8.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/38_iter8.rs">https://github.com/tisnik/presentations/blob/master/rust/38_iter8.rs</a></td></tr>
<tr><td>39_iter9.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/39_iter9.rs">https://github.com/tisnik/presentations/blob/master/rust/39_iter9.rs</a></td></tr>
<tr><td>40_iter10.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/40_iter10.rs">https://github.com/tisnik/presentations/blob/master/rust/40_iter10.rs</a></td></tr>
<tr><td>41_iter11.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/41_iter11.rs">https://github.com/tisnik/presentations/blob/master/rust/41_iter11.rs</a></td></tr>
<tr><td>42_iter12.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/42_iter12.rs">https://github.com/tisnik/presentations/blob/master/rust/42_iter12.rs</a></td></tr>
<tr><td>43_iter13.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/43_iter13.rs">https://github.com/tisnik/presentations/blob/master/rust/43_iter13.rs</a></td></tr>
<tr><td>44_iter14.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/44_iter14.rs">https://github.com/tisnik/presentations/blob/master/rust/44_iter14.rs</a></td></tr>
<tr><td>45_iter15.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/45_iter15.rs">https://github.com/tisnik/presentations/blob/master/rust/45_iter15.rs</a></td></tr>
<tr><td>46_iter16.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/46_iter16.rs">https://github.com/tisnik/presentations/blob/master/rust/46_iter16.rs</a></td></tr>
<tr><td>47_iter17.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/47_iter17.rs">https://github.com/tisnik/presentations/blob/master/rust/47_iter17.rs</a></td></tr>
<tr><td>48_iter18.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/48_iter18.rs">https://github.com/tisnik/presentations/blob/master/rust/48_iter18.rs</a></td></tr>
</table>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>Rust Compare: Pointers &amp; References<br />
<a href="http://www.rust-compare.com/site/pointers.html">http://www.rust-compare.com/site/pointers.html</a>
</li>

<li>Rust Compare: Parameters<br />
<a href="http://www.rust-compare.com/site/params.html">http://www.rust-compare.com/site/params.html</a>
</li>

<li>Why does this compile? Automatic dereferencing?<br />
<a href="https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183">https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183</a>
</li>

<li>Understanding Pointers, Ownership, and Lifetimes in Rust<br />
<a href="http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html">http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html</a>
</li>

<li>Rust lang series episode #25 — pointers (#rust-series)<br />
<a href="https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series">https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series</a>
</li>

<li>Rust - home page<br />
<a href="https://www.rust-lang.org/en-US/">https://www.rust-lang.org/en-US/</a>
</li>

<li>Rust - Frequently Asked Questions<br />
<a href="https://www.rust-lang.org/en-US/faq.html">https://www.rust-lang.org/en-US/faq.html</a>
</li>

<li>The Rust Programming Language<br />
<a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>
</li>

<li>Rust (programming language)<br />
<a href="https://en.wikipedia.org/wiki/Rust_%28programming_language%29">https://en.wikipedia.org/wiki/Rust_%28programming_language%29</a>
</li>

<li>Go - home page<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>Stack Overflow - Most Loved, Dreaded, and Wanted language<br />
<a href="https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted">https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted</a>
</li>

<li>Rust vs Go (dva roky staré hodnocení, od té doby došlo k posunům v obou jazycích)<br />
<a href="http://jaredforsyth.com/2014/03/22/rust-vs-go/">http://jaredforsyth.com/2014/03/22/rust-vs-go/</a>
</li>

<li>Rust vs Go: My experience<br />
<a href="https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/">https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/</a>
</li>

<li>Friends of Rust (Organizations running Rust in production)<br />
<a href="https://www.rust-lang.org/en-US/friends.html">https://www.rust-lang.org/en-US/friends.html</a>
</li>

<li>Rust programs versus C++ g++<br />
<a href="https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp">https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp</a>
</li>

<li>Další benchmarky (nejedná se o reálné příklady &bdquo;ze života&ldquo;)<br />
<a href="https://github.com/kostya/benchmarks">https://github.com/kostya/benchmarks</a>
</li>

<li>Go na Redditu<br />
<a href="https://www.reddit.com/r/golang/">https://www.reddit.com/r/golang/</a>
</li>

<li>Rust vs. Go<br />
<a href="http://vschart.com/compare/rust/vs/go-language">http://vschart.com/compare/rust/vs/go-language</a>
</li>

<li>Abstraction without overhead: traits in Rust<br />
<a href="https://blog.rust-lang.org/2015/05/11/traits.html">https://blog.rust-lang.org/2015/05/11/traits.html</a>
</li>

<li>Functional Programming in Rust - Part 1 : Function Abstraction<br />
<a href="http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/">http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/</a>
</li>

<li>Of the emerging systems languages Rust, D, Go and Nim, which is the strongest language and why?<br />
<a href="https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why">https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why</a>
</li>

<li>Chytré ukazatele (moderní verze jazyka C++) [MSDN]<br />
<a href="https://msdn.microsoft.com/cs-cz/library/hh279674.aspx">https://msdn.microsoft.com/cs-cz/library/hh279674.aspx</a>
</li>

<li>UTF-8 Everywhere<br />
<a href="http://utf8everywhere.org/">http://utf8everywhere.org/</a>
</li>

<li>Rust by Example<br />
<a href="http://rustbyexample.com/">http://rustbyexample.com/</a>
</li>

<li>Rust oficiálně ve Fedoře<br />
<a href="https://mojefedora.cz/rust-oficialne-ve-fedore/">https://mojefedora.cz/rust-oficialne-ve-fedore/</a>
</li>

<li>Resource acquisition is initialization<br />
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization</a>
</li>

<li>TIOBE index (October 2016)<br />
<a href="http://www.tiobe.com/tiobe-index/">http://www.tiobe.com/tiobe-index/</a>
</li>

<li>Porovnání Go, D a Rustu na OpenHubu:<br />
<a href="https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits">https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits</a>
</li>

<li>String Types in Rust<br />
<a href="http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/">http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/</a>
</li>

<li>Trait (computer programming)<br />
<a href="https://en.wikipedia.org/wiki/Trait_%28computer_programming%29">https://en.wikipedia.org/wiki/Trait_%28computer_programming%29</a>
</li>

<li>Type inference<br />
<a href="https://en.wikipedia.org/wiki/Type_inference">https://en.wikipedia.org/wiki/Type_inference</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>


