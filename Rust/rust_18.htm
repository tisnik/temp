<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Datové kolekce v programovacím jazyku Rust: mapy</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Datové kolekce v programovacím jazyku Rust: mapy</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Druhou skupinou datových kolekcí, které můžeme nalézt ve standardní knihovně programovacího jazyka Rust, jsou mapy (asociativní pole). Existují dvě odlišně se chovající implementace map. První implementace je založena na hešovacích tabulkách, druhá implementace na B-stromech.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Mapy (asociativní pole)</a></p>
<p><a href="#k02">2. Implementace mapy hešovací tabulkou &ndash; HashMap</a></p>
<p><a href="#k03">3. Operace <strong>get</strong> a datový typ <strong>Option</strong></a></p>
<p><a href="#k04">4. Hodnota obalená v&nbsp;typu <strong>Option</strong></a></p>
<p><a href="#k05">5. Iterátor pro dvojice klíč:hodnota</a></p>
<p><a href="#k06">6. Operace <strong>insert</strong></a></p>
<p><a href="#k07">7. Operace <strong>remove</strong> a <strong>clear</strong></a></p>
<p><a href="#k08">8. Typ <strong>Entry</strong> a operace <strong>or_insert</strong></a></p>
<p><a href="#k09">9. Iterace přes všechny klíče a hodnoty</a></p>
<p><a href="#k10">10. Iterátor umožňující modifikovat hodnoty v&nbsp;mapě</a></p>
<p><a href="#k11">11. Mapa implementovaná B-stromem</a></p>
<p><a href="#k12">12. Příklad ukazující principiální rozdíl mezi HashMap a BTreeMap</a></p>
<p><a href="#k13">13. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Mapy (asociativní pole)</h2>

<p>V&nbsp;mnoha aplikacích se setkáme s&nbsp;potřebou práce s&nbsp;mapami
(asociativními poli). Tyto datové struktury se od běžných polí (či v&nbsp;Rustu
vektorů) odlišují především tím, že se pro selektory prvků nepoužívají
<i>indexy</i> ale <i>klíče</i>. Zatímco indexy jsou v&nbsp;případě polí/vektorů
představovány posloupností celých čísel typicky začínajících od 0 či 1, pro
klíče lze použít hodnoty prakticky libovolného typu. Velmi často se jedná o
řetězce, ale nemusíme se samozřejmě omezit jen na ně. Ve standardní knihovně
programovacího jazyka Rust nalezneme dvě implementace map. První implementace
je založena na hešovacích tabulkách a druhá implementace na B-stromech. Tyto
implementace se sice interně odlišují a mají i různé vlastnosti, ovšem základní
rozhraní (sada metod) zůstává zachována. Při výběru vhodné implementace se
můžete řídit následující tabulkou, v&nbsp;níž jsou vypsány časové složitosti
základních operací. U map založených na hešovacích tabulkách je u operace
<strong>insert()</strong> vypsána amortizovaná složitost, složitost dalších
operací pak silně závisí na vlastnostech klíčů a použité hešovací funkce (tu
lze vybrat):</p>

<table>
<tr><th>Implementace</th><th>get()</th><th>insert()</th><th>remove()</th></tr>
<tr><td>HashMap</td><td>&ge;O(1)</td><td>&ge;O(1) (amort.)</td><td>&ge;O(1)</td></tr>
<tr><td>BTreeMap</td><td>O(log n)</td><td>O(log n)</td><td>O(log n)</td></tr>
</table>

<p>Poznámka: většinou se v&nbsp;aplikacích (minimálně těch s&nbsp;otevřeným
zdrojovým kódem) setkáme s&nbsp;HashMapou, ovšem v&nbsp;některých případech
budete potřebovat speciální vlastnosti BTreeMapy (průchod mapou ve stanoveném
pořadí prvků atd.).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Implementace mapy hešovací tabulkou &ndash; HashMap</h2>

<p>Jak jsme si řekli <a href="#k01">v&nbsp;předchozí kapitole</a>, je první typ
mapy implementován hešovací tabulkou. To mj.&nbsp;znamená, že datový typ
použitý pro reprezentaci klíčů musí implementovat dva traity: <i>Eq</i> a
<i>Hash</i>. Tyto traity jsou implementovány všemi primitivními datovými typy,
samozřejmě včetně řetězců a polí (zde ovšem jen v&nbsp;případě, že i prvky polí
tyto traity implementují), takže se například velmi často setkáme
s&nbsp;použitím řetězců ve funkci klíčů. Pro mapy (prozatím) neexistuje žádná
speciální syntaxe pro jejich vytvoření, takže se musíme spokojit
s&nbsp;použitím metody <strong>insert()</strong>. Podívejme se na jednoduchý
příklad, v&nbsp;němž se do mapy typu &amp;str, &amp;str&gt; vloží pět prvků a
následně se metodou <strong>get()</strong> přečte hodnota uložená pod klíčem
"Trachta" a "Novak" (tato hodnota ve skutečnosti neexistuje):</p>

<pre>
use std::collections::HashMap;
&nbsp;
fn main() {
    let <strong>mut</strong> map = <strong>HashMap::new()</strong>;
&nbsp;
    <strong>map.insert</strong>("Trachta",      "inspektor");
    <strong>map.insert</strong>("Hlavacek",     "praktikant");
    <strong>map.insert</strong>("Bierhanzel",   "tovarnik");
    <strong>map.insert</strong>("Meyer",        "tovarnik");
    <strong>map.insert</strong>("Vaclav Kotek", "stevard");
&nbsp;
    println!("Trachta: {:?}", <strong>map.get</strong>("Trachta"));
    println!("Novak:   {:?}", <strong>map.get</strong>("Novak"));
}
</pre>

<p>Poznámka: modifikátor <strong>mut</strong> je nutné kvůli neexistující
syntaxi pro konstruktor s&nbsp;inicializací mapy uvést.</p>

<p>Po spuštění tohoto programu by se měly vypsat následující dva řádky:</p>

<pre>
Trachta: Some("inspektor")
Novak:   None
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Operace <strong>get</strong> a datový typ <strong>Option</strong></h2>

<p>Výsledek spuštění předchozího demonstračního příkladu ukazuje, že metoda
<strong>get()</strong> nevrací přímo hodnotu uloženou do mapy, ale typ
<strong>Option</strong>, který buď obaluje skutečnou hodnotu, nebo je roven
None (situace je ještě složitější, neboť se nevrací přímo uložená hodnota, ale
reference, viz též navazující kapitolu). Navíc jsme díky typové inferenci
nemuseli explicitně specifikovat typ mapy (tj.&nbsp;typ klíčů a typ hodnot),
neboť si tyto informace překladač sám odvodil z&nbsp;prvního příkazu
<strong>map.insert()</strong>. Ovšem ve chvíli, kdy mapu předáváme &ndash; ať
již přímo či přes referenci &ndash; do jiné funkce, je nutné typ uvést.
V&nbsp;dnešním druhém příkladu je ve funkci <strong>print_role()</strong>
hodnota vrácená metodou <strong>get()</strong> analyzována způsobem, který již
známe <a
href="https://www.root.cz/clanky/datovy-typ-option-v-programovacim-jazyku-rust/">z&nbsp;části
věnované typu Option</a> (mapu musíme předat referencí, protože by se jinak
změnil ownership):</p>

<pre>
use std::collections::HashMap;
&nbsp;
fn print_role(map: <strong>&amp;HashMap&lt;&amp;str, &amp;str&gt;</strong>, name: &amp;str) -&gt; () {
    let role = map.get(name);
    if <strong>role.is_none</strong>() {
        println!("{}: neobsazeno", name);
    } else {
        println!("{}: {}", name, role.unwrap());
    }
}
&nbsp;
fn main() {
    let mut map = HashMap::new();
&nbsp;
    map.insert("Trachta",      "inspektor");
    map.insert("Hlavacek",     "praktikant");
    map.insert("Bierhanzel",   "tovarnik");
    map.insert("Meyer",        "tovarnik");
    map.insert("Vaclav Kotek", "stevard");
&nbsp;
    print_role(&amp;map, "Trachta");
    print_role(&amp;map, "Novak");
}
</pre>

<p>Po spuštění tohoto programu by se měly vypsat následující dva řádky:</p>

<pre>
Trachta: inspektor
Novak: neobsazeno
</pre>

<p>Z&nbsp;předchozích částí tohoto seriálu také víme, že rozhodovací konstrukci
<strong>if X.is_none()</strong> je výhodnější nahradit pattern matchingem:</p>

<pre>
use std::collections::HashMap;
&nbsp;
fn print_role(map: &amp;HashMap&lt;&amp;str, &amp;str&gt;, name: &amp;str) -&gt; () {
    let role = map.get(name);
    <strong>match role</strong> {
        <strong>None            =&gt;</strong> println!("{}: neobsazeno", name),
        <strong>Some(role_name) =&gt;</strong> println!("{}: {}", name, role_name)
    }
}
&nbsp;
fn main() {
    let mut map = HashMap::new();
&nbsp;
    map.insert("Trachta",      "inspektor");
    map.insert("Hlavacek",     "praktikant");
    map.insert("Bierhanzel",   "tovarnik");
    map.insert("Meyer",        "tovarnik");
    map.insert("Vaclav Kotek", "stevard");
&nbsp;
    print_role(&amp;map, "Trachta");
    print_role(&amp;map, "Novak");
}
</pre>

<p>Výsledek běhu tohoto programu musí být shodný s&nbsp;programem
předchozím:</p>

<pre>
Trachta: inspektor
Novak: neobsazeno
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Hodnota obalená v&nbsp;typu <strong>Option</strong></h2>

<p>I když to z&nbsp;předchozích příkladů nebylo zřejmé, není v&nbsp;datové
struktuře typu <strong>Option</strong> uložena přímo hodnota získaná
z&nbsp;mapy, ale pouze její reference. To plyne z&nbsp;modelu vlastnictví,
který tvoří velmi důležitý základ programovacího jazyka Rust. Z&nbsp;tohoto
důvodu, pokud budeme například refaktorovat funkci pro získání role (ve formě
typu String), musí být do této funkce předána hodnota typu
<strong>Option&lt;&amp;&amp;str&gt;</strong> a nikoli
<strong>Option&lt;&amp;str&gt;</strong> (kvůli většímu zmatení je zde použita
druhá reference <strong>&amp;str</strong>, ta však již souvisí
s&nbsp;primitivním typem <strong>str</strong>, s&nbsp;nímž se vždy setkáme jen
ve formě reference):</p>

<pre>
use std::collections::HashMap;
&nbsp;
fn get_role_name(role: <strong>Option&lt;&amp;&amp;str&gt;</strong>) -&gt; String {
    match role {
        <strong>None            =&gt;</strong> "neobsazeno".to_string(),
        <strong>Some(role_name) =&gt;</strong> role_name.to_string()
    }
}
&nbsp;
fn print_role(map: &amp;HashMap&lt;&amp;str, &amp;str&gt;, name: &amp;str) -&gt; () {
    let role = map.get(name);
    println!("{}: {}", name, get_role_name(role));
}
&nbsp;
fn main() {
    let mut map = HashMap::new();
&nbsp;
    map.insert("Trachta",      "inspektor");
    map.insert("Hlavacek",     "praktikant");
    map.insert("Bierhanzel",   "tovarnik");
    map.insert("Meyer",        "tovarnik");
    map.insert("Vaclav Kotek", "stevard");
&nbsp;
    print_role(&amp;map, "Trachta");
    print_role(&amp;map, "Novak");
}
</pre>

<p>Výsledek běhu tohoto programu musí být shodný s&nbsp;programem
předchozím:</p>

<pre>
Trachta: inspektor
Novak: neobsazeno
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Iterátor pro dvojice klíč:hodnota</h2>

<p>Pokud je zapotřebí projít všemi prvky (či lépe řečeno všemi dvojicemi
klíč:hodnota), je možné použít metodu <strong>iter()</strong>, která tento
průchod zajistí. Nesmíme však zapomenout na to, že pořadí uložení prvků
v&nbsp;hashmapě je obecně odlišné od pořadí vkládání prvků. Záleží totiž na
použité hešovací funkci, počtu případných kolizí atd. Povšimněte si, jakým
způsobem se zapisuje smyčka typu foreach ve chvíli, kdy v&nbsp;každé iteraci
získáme dvojici hodnot. S&nbsp;tímto zápisem jsme se již setkali
v&nbsp;předchozích částech tohoto seriálu:</p>

<pre>
use std::collections::HashMap;
&nbsp;
fn print_map(map: &amp;HashMap&lt;&amp;str, &amp;str&gt;) {
    for <strong>(name, role)</strong> in <strong>map.iter()</strong> {
        println!("{:15} \"{}\"", name, role);
    }
    println!("");
}
&nbsp;
fn main() {
    let mut map = HashMap::new();
&nbsp;
    print_map(&amp;map);
&nbsp;
    map.insert("Trachta",      "inspektor");
    map.insert("Hlavacek",     "praktikant");
    map.insert("Bierhanzel",   "tovarnik");
    map.insert("Meyer",        "tovarnik");
    map.insert("Vaclav Kotek", "stevard");
&nbsp;
    print_map(&amp;map);
}
</pre>

<p>Výsledek běhu tohoto příkladu může (ale u vás nutně nemusí) vypadat
následovně:</p>

<pre>
Bierhanzel      "tovarnik"
Trachta         "inspektor"
Vaclav Kotek    "stevard"
Hlavacek        "praktikant"
Meyer           "tovarnik"
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Operace <strong>insert</strong></h2>

<p>Operace <strong>insert</strong> představovaná stejnojmennou metodou pracuje
následovně:</p>

<ul>
    <li>Pokud prvek pod daným klíčem neexistoval:
        <ol>
            <li>Vloží novou dvojici klíč:hodnota do mapy.</li>
            <li>Vrátí se hodnota <strong>None</strong> (může se ignorovat).</li>
        </ol>
    </li>
    <li>Pokud prvek pod daným klíčem již existoval:
        <ol>
            <li>Hodnota je přepsána.</li>
            <li>Vrátí se původní hodnota obalená v&nbsp;<strong>Option</strong> (může se ignorovat).</li>
        </ol>
    </li>
</ul>

<p>Poznámka: skutečně se vrací původní hodnota, tj.&nbsp;nikoli reference na
ni. Důvod je stále stejný: ownership model programovacího jazyka Rust.</p>

<p>V&nbsp;následujícím demonstračním příkladu přepíšeme původní role jinými
hodnotami:</p>

<pre>
use std::collections::HashMap;
&nbsp;
fn print_map(map: &amp;HashMap&lt;&amp;str, &amp;str&gt;) {
    if map.is_empty() {
        println!("empty collection");
    } else {
        for (name, role) in map.iter() {
            println!("{:15} \"{}\"", name, role);
        }
    }
    println!("");
}
&nbsp;
fn main() {
    let mut map = HashMap::new();
&nbsp;
    print_map(&amp;map);
&nbsp;
    map.insert("Trachta",      "inspektor");
    map.insert("Hlavacek",     "praktikant");
    map.insert("Bierhanzel",   "tovarnik");
    map.insert("Meyer",        "tovarnik");
    map.insert("Vaclav Kotek", "stevard");
&nbsp;
    print_map(&amp;map);
&nbsp;
    map.insert("Bierhanzel",   "neobsazen");
    map.insert("Meyer",        "neobsazen");
&nbsp;
    print_map(&amp;map);
}
</pre>

<p>Výsledek běhu tohoto příkladu může (ale u vás nutně nemusí) vypadat
následovně. Důležité je, aby se ve druhé části pod dvěma klíči "Bierhanzel" a
"Meyer" objevila hodnota "neobsazen":</p>

<pre>
empty collection
&nbsp;
Bierhanzel      "tovarnik"
Vaclav Kotek    "stevard"
Trachta         "inspektor"
Meyer           "tovarnik"
Hlavacek        "praktikant"
&nbsp;
Bierhanzel      "neobsazen"
Vaclav Kotek    "stevard"
Trachta         "inspektor"
Meyer           "neobsazen"
Hlavacek        "praktikant"
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Operace <strong>remove</strong> a <strong>clear</strong></h2>

<p>Operace <strong>remove</strong> představovaná stejně pojmenovanou metodou
odstraní hodnotu uloženou pod daným klíčem z&nbsp;mapy a navíc tuto hodnotu
vrátí obalenou typem <strong>Option</strong> (ovšem skutečně se vrátí hodnota,
nikoli reference na ni). Přitom je legální se pokusit o odstranění neexistující
hodnoty &ndash; nedojde k&nbsp;žádné běhové chybě a metoda
<strong>remove()</strong> vrátí <strong>None</strong>. Pokud potřebujete
odstranit všechny prvky z&nbsp;mapy, použijte metodu <strong>clear()</strong>
popř.&nbsp;<strong>drain()</strong>. Druhá z&nbsp;těchto metod navíc vrátí
iterátor, který odstraňované hodnoty &bdquo;zachrání&ldquo;:</p>

<pre>
use std::collections::HashMap;
&nbsp;
fn print_map(map: &amp;HashMap&lt;&amp;str, &amp;str&gt;) {
    if map.is_empty() {
        println!("empty collection");
    } else {
        for (name, role) in map.iter() {
            println!("{:15} \"{}\"", name, role);
        }
    }
    println!("");
}
&nbsp;
fn main() {
    let mut map = HashMap::new();
&nbsp;
    print_map(&amp;map);
&nbsp;
    map.insert("Trachta",      "inspektor");
    map.insert("Hlavacek",     "praktikant");
    map.insert("Bierhanzel",   "tovarnik");
    map.insert("Meyer",        "tovarnik");
    map.insert("Vaclav Kotek", "stevard");
&nbsp;
    print_map(&amp;map);
&nbsp;
    map.insert("Bierhanzel",   "neobsazen");
    map.insert("Meyer",        "neobsazen");
&nbsp;
    print_map(&amp;map);
&nbsp;
    <strong>map.remove("Bierhanzel")</strong>;
    <strong>map.remove("Meyer")</strong>;
&nbsp;
    print_map(&amp;map);
&nbsp;
    <strong>map.clear()</strong>;
&nbsp;
    print_map(&amp;map);
}
</pre>

<p>Výstup demonstračního příkladu:</p>

<pre>
empty collection
&nbsp;
Hlavacek        "praktikant"
Trachta         "inspektor"
Vaclav Kotek    "stevard"
Bierhanzel      "tovarnik"
Meyer           "tovarnik"
&nbsp;
Hlavacek        "praktikant"
Trachta         "inspektor"
Vaclav Kotek    "stevard"
Bierhanzel      "neobsazen"
Meyer           "neobsazen"
&nbsp;
Hlavacek        "praktikant"
Trachta         "inspektor"
Vaclav Kotek    "stevard"
&nbsp;
empty collection
</pre>

<p>Poznámka: sami si zkuste do zdrojového kódu přidat příkaz pro odstranění
hodnoty s&nbsp;neexistujícím klíčem.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Typ <strong>Entry</strong> a operace <strong>or_insert</strong></h2>

<p>Pro libovolné místo v&nbsp;mapě (i neobsazené místo) lze získat objekt typu
<strong>Entry</strong>. Jeho funkce do jisté míry odpovídá <i>kurzoru</i>
v&nbsp;databázích. Ve chvíli, kdy již objekt typu <strong>Entry</strong> máme
k&nbsp;dispozici, lze použít jeho metody, z&nbsp;nichž nejužitečnější je
<strong>or_insert()</strong>. Tato metoda zapíše novou hodnotu do daného místa,
ovšem jen ve chvíli, kdy hodnota prozatím neexistuje. Navíc vrátí referenci na
tuto hodnotu (existující či novou). Tímto způsobem můžeme v&nbsp;programu
ušetřit některé rozhodovací konstrukce pro test, zda je nutné hodnotu zapsat či
nikoli. Ostatně se podívejme na příklad, kdy je sice třikrát po sobě volána
metoda <strong>or_insert()</strong>, ovšem pouze v&nbsp;posledním případě se do
mapy skutečně zapíše další prvek:</p>

<pre>
use std::collections::HashMap;
&nbsp;
fn print_map(map: &amp;HashMap&lt;&amp;str, &amp;str&gt;) {
    if map.is_empty() {
        println!("empty collection");
    } else {
        for (name, role) in map.iter() {
            println!("{:15} \"{}\"", name, role);
        }
    }
    println!("");
}
&nbsp;
fn main() {
    let mut map = HashMap::new();
&nbsp;
    print_map(&amp;map);
&nbsp;
    map.insert("Trachta",      "inspektor");
    map.insert("Hlavacek",     "praktikant");
    map.insert("Bierhanzel",   "tovarnik");
    map.insert("Meyer",        "tovarnik");
    map.insert("Vaclav Kotek", "stevard");
&nbsp;
    print_map(&amp;map);
&nbsp;
    map.<strong>entry("Bierhanzel").or_insert("neobsazen")</strong>;
    map.<strong>entry("Meyer").or_insert("neobsazen")</strong>;
    map.<strong>entry("Novak").or_insert("namornik")</strong>;
&nbsp;
    print_map(&amp;map);
}
</pre>

<p>Výsledek běhu tohoto příkladu:</p>

<pre>
empty collection
&nbsp;
Trachta         "inspektor"
Bierhanzel      "tovarnik"
Hlavacek        "praktikant"
Meyer           "tovarnik"
Vaclav Kotek    "stevard"
&nbsp;
Trachta         "inspektor"
Bierhanzel      "tovarnik"
Novak           "namornik"
Hlavacek        "praktikant"
Meyer           "tovarnik"
Vaclav Kotek    "stevard"
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Iterace přes všechny klíče a hodnoty</h2>

<p>V&nbsp;některých případech potřebujeme získat pouze sekvenci klíčů nebo
hodnot, nikoli sekvenci dvojic klíč:hodnota. Řešení je jednoduché. Při
požadavku na získání sekvence klíčů se použije metoda <strong>keys()</strong>
vracející iterátor:</p>

<pre>
use std::collections::HashMap;
&nbsp;
fn print_map_keys(map: &amp;HashMap&lt;&amp;str, &amp;str&gt;) {
    for key in <strong>map.keys()</strong> {
        println!("{}", key);
    }
}
&nbsp;
fn main() {
    let mut map = HashMap::new();
&nbsp;
    print_map_keys(&amp;map);
&nbsp;
    map.insert("Trachta",      "inspektor");
    map.insert("Hlavacek",     "praktikant");
    map.insert("Bierhanzel",   "tovarnik");
    map.insert("Meyer",        "tovarnik");
    map.insert("Vaclav Kotek", "stevard");
&nbsp;
    print_map_keys(&amp;map);
}
</pre>

<p>Výstup programu:</p>

<pre>
Vaclav Kotek
Bierhanzel
Meyer
Trachta
Hlavacek
</pre>

<p>Sekvence hodnot se získá metodou <strong>values()</strong>, i tato metoda
vrací iterátor:</p>

<pre>
use std::collections::HashMap;
&nbsp;
fn print_map_values(map: &amp;HashMap&lt;&amp;str, &amp;str&gt;) {
    for key in <strong>map.values()</strong> {
        println!("{}", key);
    }
}
&nbsp;
fn main() {
    let mut map = HashMap::new();
&nbsp;
    print_map_values(&amp;map);
&nbsp;
    map.insert("Trachta",      "inspektor");
    map.insert("Hlavacek",     "praktikant");
    map.insert("Bierhanzel",   "tovarnik");
    map.insert("Meyer",        "tovarnik");
    map.insert("Vaclav Kotek", "stevard");
&nbsp;
    print_map_values(&amp;map);
}
</pre>

<p>Výstup programu:</p>

<pre>
stevard
tovarnik
praktikant
tovarnik
inspektor
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Iterátor umožňující modifikovat hodnoty v&nbsp;mapě</h2>

<p>Vzhledem k&nbsp;tomu, že iterátor vrací reference na hodnoty, mohlo by se
zdát, že je velmi snadné tyto hodnoty změnit, například takto:</p>

<pre>
for (_, role) in <strong>map.iter()</strong> {
    *role = "?"
}
</pre>

<p>Ve skutečnosti tomu tak není, protože <strong>reference</strong> postupně
vracené iterátorem jsou neměnitelné (<i>immutable</i>). Ostatně se o tom můžeme
sami přesvědčit pokusem o překlad následujícího příkladu:</p>

<pre>
use std::collections::HashMap;
&nbsp;
fn print_map(map: &amp;HashMap&lt;&amp;str, &amp;str&gt;) {
    if map.is_empty() {
        println!("empty collection");
    } else {
        for (name, role) in map.iter() {
            println!("{:15} \"{}\"", name, role);
        }
    }
    println!("");
}
&nbsp;
fn main() {
    let mut map = HashMap::new();
&nbsp;
    print_map(&amp;map);
&nbsp;
    map.insert("Trachta",      "inspektor");
    map.insert("Hlavacek",     "praktikant");
    map.insert("Bierhanzel",   "tovarnik");
    map.insert("Meyer",        "tovarnik");
    map.insert("Vaclav Kotek", "stevard");
&nbsp;
    print_map(&amp;map);
&nbsp;
    for (_, role) in <strong>map.iter()</strong> {
        *role = "?"
    }
&nbsp;
    print_map(&amp;map);
}
</pre>

<p>Při překladu vypíše překladač programovacího jazyka Rust následující chybové
hlášení:</p>

<pre>
error: cannot assign to immutable borrowed content `*role`
  --&gt; 261_sequences22.rs:28:9
   |
28 |         *role = "?"
   |         ^^^^^^^^^^^
&nbsp;
error: aborting due to previous error
</pre>

<p>Řešení tohoto problému je snadné &ndash; postačuje použít jiný typ iterátoru
vracejícího měnitelné (<i>mutable</i>) reference:</p>

<pre>
for (_, role) in <strong>map.iter_mut()</strong> {
    *role = "?"
}
</pre>

<p>Poznámka: to, že je reference měnitelná či neměnitelná, nemusí nijak
souviset s&nbsp;tím, zda je měnitelná či naopak neměnitelná samotná
hodnota.</p>

<p>Následující příklad již půjde přeložit:</p>

<pre>
use std::collections::HashMap;
&nbsp;
fn print_map(map: &amp;HashMap&lt;&amp;str, &amp;str&gt;) {
    if map.is_empty() {
        println!("empty collection");
    } else {
        for (name, role) in map.iter() {
            println!("{:15} \"{}\"", name, role);
        }
    }
    println!("");
}
&nbsp;
fn main() {
    let mut map = HashMap::new();
&nbsp;
    print_map(&amp;map);
&nbsp;
    map.insert("Trachta",      "inspektor");
    map.insert("Hlavacek",     "praktikant");
    map.insert("Bierhanzel",   "tovarnik");
    map.insert("Meyer",        "tovarnik");
    map.insert("Vaclav Kotek", "stevard");
&nbsp;
    print_map(&amp;map);
&nbsp;
    for (_, role) in <strong>map.iter_mut()</strong> {
        *role = "?"
    }
&nbsp;
    print_map(&amp;map);
}
</pre>

<p>Z&nbsp;výsledku je patrné, že se nám skutečně při iteraci podařilo změnit
původní mapu:</p>

<pre>
empty collection
&nbsp;
Meyer           "tovarnik"
Trachta         "inspektor"
Hlavacek        "praktikant"
Vaclav Kotek    "stevard"
Bierhanzel      "tovarnik"
&nbsp;
Meyer           "?"
Trachta         "?"
Hlavacek        "?"
Vaclav Kotek    "?"
Bierhanzel      "?"
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Mapa implementovaná B-stromem</h2>

<p>Mapa interně implementovaná B-stromem se na první pohled nijak neliší od
mapy implementované hešovací tabulkou. Stačí použít jiný konstruktor. První
demonstrační příklad můžeme přepsat následovně:</p>

<pre>
use <strong>std::collections::BTreeMap</strong>;
&nbsp;
fn main() {
    let mut map = <strong>BTreeMap::new()</strong>;
&nbsp;
    map.insert("Trachta",      "inspektor");
    map.insert("Hlavacek",     "praktikant");
    map.insert("Bierhanzel",   "tovarnik");
    map.insert("Meyer",        "tovarnik");
    map.insert("Vaclav Kotek", "stevard");
&nbsp;
    println!("Trachta: {:?}", map.get("Trachta"));
    println!("Novak:   {:?}", map.get("Novak"));
}
</pre>

<p>Výsledek běhu tohoto příkladu:</p>

<pre>
Trachta: Some("inspektor")
Novak:   None
</pre>

<p>Stejně lze přepsat i nějaký složitější příklad používající metody
<strong>insert()</strong>, <strong>remove()</strong>, <strong>clear()</strong>
a <strong>iter()</strong>. Jediný rozdíl představuje deklarace typu mapy:</p>

<pre>
use std::collections::BTreeMap;
&nbsp;
fn print_map(map: &amp;BTreeMap&lt;&amp;str, &amp;str&gt;) {
    if map.is_empty() {
        println!("empty collection");
    } else {
        for (name, role) in map.iter() {
            println!("{:15} \"{}\"", name, role);
        }
    }
    println!("");
}
&nbsp;
fn main() {
    let mut map = BTreeMap::new();
&nbsp;
    print_map(&amp;map);
&nbsp;
    map.insert("Trachta",      "inspektor");
    map.insert("Hlavacek",     "praktikant");
    map.insert("Bierhanzel",   "tovarnik");
    map.insert("Meyer",        "tovarnik");
    map.insert("Vaclav Kotek", "stevard");
&nbsp;
    print_map(&amp;map);
&nbsp;
    map.insert("Bierhanzel",   "neobsazen");
    map.insert("Meyer",        "neobsazen");
&nbsp;
    print_map(&amp;map);
&nbsp;
    map.remove("Bierhanzel");
    map.remove("Meyer");
&nbsp;
    print_map(&amp;map);
&nbsp;
    map.clear();
&nbsp;
    print_map(&amp;map);
}
</pre>

<p>Výsledek běhu demonstračního příkladu:</p>

<pre>
empty collection
&nbsp;
Bierhanzel      "tovarnik"
Hlavacek        "praktikant"
Meyer           "tovarnik"
Trachta         "inspektor"
Vaclav Kotek    "stevard"
&nbsp;
Bierhanzel      "neobsazen"
Hlavacek        "praktikant"
Meyer           "neobsazen"
Trachta         "inspektor"
Vaclav Kotek    "stevard"
&nbsp;
Hlavacek        "praktikant"
Trachta         "inspektor"
Vaclav Kotek    "stevard"
&nbsp;
empty collection
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Příklad ukazující principiální rozdíl mezi HashMap a BTreeMap</h2>

<p>Z&nbsp;pohledu uživatele je nejdůležitějším rozdílem mezi implementací mapy
hešovací tabulkou a B-stromem fakt, že v&nbsp;prvním případě nám iterátor vrátí
prvky v&nbsp;&bdquo;náhodném&ldquo; pořadí, kdežto v&nbsp;případě B-stromu je
pořadí pevně specifikováno &ndash; klíče prvků jsou setříděny vzestupně, což
souvisí s&nbsp;interní strukturou B-stromu a způsobem reorganizace uzlů při
vkládání a mazání prvků. V&nbsp;následujícím příkladu je ukázáno, jak se bude
lišit výstup z&nbsp;obou implementací map pro stejné vstupy, tj.&nbsp;pro
shodné dvojice klíč:hodnota:</p>

<pre>
use std::collections::HashMap;
use std::collections::BTreeMap;
&nbsp;
fn print_hashmap_keys(map: &amp;HashMap&lt;&amp;str, &amp;str&gt;) {
    for key in map.keys() {
        println!("{}", key);
    }
}
&nbsp;
fn print_btreemap_keys(map: &amp;BTreeMap&lt;&amp;str, &amp;str&gt;) {
    for key in map.keys() {
        println!("{}", key);
    }
}
&nbsp;
fn main() {
    let mut map1 = HashMap::new();
    let mut map2 = BTreeMap::new();
&nbsp;
    map1.insert("Zdenek",       "podporucik");
    map1.insert("Trachta",      "inspektor");
    map1.insert("Hlavacek",     "praktikant");
    map1.insert("Bierhanzel",   "tovarnik");
    map1.insert("Meyer",        "tovarnik");
    map1.insert("Vaclav Kotek", "stevard");
    map1.insert("Ales",         "podkoni");
&nbsp;
    print_hashmap_keys(&amp;map1);
&nbsp;
    println!("-------------------------------");
&nbsp;
    map2.insert("Zdenek",       "podporucik");
    map2.insert("Trachta",      "inspektor");
    map2.insert("Hlavacek",     "praktikant");
    map2.insert("Bierhanzel",   "tovarnik");
    map2.insert("Meyer",        "tovarnik");
    map2.insert("Vaclav Kotek", "stevard");
    map2.insert("Ales",         "podkoni");
&nbsp;
    print_btreemap_keys(&amp;map2);
}
</pre>

<p>Povšimněte si, že první polovina výstupu je nesetříděná a druhá je abecedně
setříděná:</p>

<pre>
Meyer
Vaclav Kotek
Ales
Zdenek
Bierhanzel
Trachta
Hlavacek
-------------------------------
Ales
Bierhanzel
Hlavacek
Meyer
Trachta
Vaclav Kotek
Zdenek
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popisované demonstrační příklady byly, podobně jako ve všech
předchozích částech tohoto seriálu, uloženy do Git repositáře dostupného na
adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě bez nutnosti
klonovat celý repositář:</p>

<table>
<tr><th>Příklad</th><th>Odkaz</th></tr>
<tr><td>251_sequences12.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/251_sequences12.rs">https://github.com/tisnik/presentations/blob/master/rust/251_sequences12.rs</a></td></tr>
<tr><td>252_sequences13.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/252_sequences13.rs">https://github.com/tisnik/presentations/blob/master/rust/252_sequences13.rs</a></td></tr>
<tr><td>253_sequences14.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/253_sequences14.rs">https://github.com/tisnik/presentations/blob/master/rust/253_sequences14.rs</a></td></tr>
<tr><td>254_sequences15.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/254_sequences15.rs">https://github.com/tisnik/presentations/blob/master/rust/254_sequences15.rs</a></td></tr>
<tr><td>255_sequences16.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/255_sequences16.rs">https://github.com/tisnik/presentations/blob/master/rust/255_sequences16.rs</a></td></tr>
<tr><td>256_sequences17.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/256_sequences17.rs">https://github.com/tisnik/presentations/blob/master/rust/256_sequences17.rs</a></td></tr>
<tr><td>257_sequences18.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/257_sequences18.rs">https://github.com/tisnik/presentations/blob/master/rust/257_sequences18.rs</a></td></tr>
<tr><td>258_sequences19.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/258_sequences19.rs">https://github.com/tisnik/presentations/blob/master/rust/258_sequences19.rs</a></td></tr>
<tr><td>259_sequences20.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/259_sequences20.rs">https://github.com/tisnik/presentations/blob/master/rust/259_sequences20.rs</a></td></tr>
<tr><td>260_sequences21.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/260_sequences21.rs">https://github.com/tisnik/presentations/blob/master/rust/260_sequences21.rs</a></td></tr>
<tr><td>261_sequences22.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/261_sequences22.rs">https://github.com/tisnik/presentations/blob/master/rust/261_sequences22.rs</a></td></tr>
<tr><td>262_sequences23.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/262_sequences23.rs">https://github.com/tisnik/presentations/blob/master/rust/262_sequences23.rs</a></td></tr>
<tr><td>263_sequences24.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/263_sequences24.rs">https://github.com/tisnik/presentations/blob/master/rust/263_sequences24.rs</a></td></tr>
<tr><td>264_sequences25.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/264_sequences25.rs">https://github.com/tisnik/presentations/blob/master/rust/264_sequences25.rs</a></td></tr>
<tr><td>265_sequences26.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/265_sequences26.rs">https://github.com/tisnik/presentations/blob/master/rust/265_sequences26.rs</a></td></tr>
</table>



<p><a name="k12"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Associative array<br />
<a href="https://en.wikipedia.org/wiki/Associative_array">https://en.wikipedia.org/wiki/Associative_array</a>
</li>

<li>Hash Table<br />
<a href="https://en.wikipedia.org/wiki/Hash_table">https://en.wikipedia.org/wiki/Hash_table</a>
</li>

<li>B-tree<br />
<a href="https://en.wikipedia.org/wiki/B-tree">https://en.wikipedia.org/wiki/B-tree</a>
</li>

<li>Pedro Celis: Robin Hood Hashing (naskenované PDF!)<br />
<a href="https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf">https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf</a>
</li>

<li>Robin Hood hashing<br />
<a href="http://codecapsule.com/2013/11/11/robin-hood-hashing/">http://codecapsule.com/2013/11/11/robin-hood-hashing/</a>
</li>

<li>Robin Hood hashing: backward shift deletion<br />
<a href="http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/">http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/</a>
</li>

<li>Module std::collections<br />
<a href="https://doc.rust-lang.org/std/collections/">https://doc.rust-lang.org/std/collections/</a>
</li>

<li>Module std::vec<br />
<a href="https://doc.rust-lang.org/nightly/std/vec/index.html">https://doc.rust-lang.org/nightly/std/vec/index.html</a>
</li>

<li>Struct std::collections::VecDeque<br />
<a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html">https://doc.rust-lang.org/std/collections/struct.VecDeque.html</a>
</li>

<li>Struct std::collections::LinkedList<br />
<a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html">https://doc.rust-lang.org/std/collections/struct.LinkedList.html</a>
</li>

<li>Module std::fmt<br />
<a href="https://doc.rust-lang.org/std/fmt/">https://doc.rust-lang.org/std/fmt/</a>
</li>

<li>Macro std::println<br />
<a href="https://doc.rust-lang.org/std/macro.println.html">https://doc.rust-lang.org/std/macro.println.html</a>
</li>

<li>Enum std::result::Result<br />
<a href="https://doc.rust-lang.org/std/result/enum.Result.html">https://doc.rust-lang.org/std/result/enum.Result.html</a>
</li>

<li>Module std::result<br />
<a href="https://doc.rust-lang.org/std/result/">https://doc.rust-lang.org/std/result/</a>
</li>

<li>Result<br />
<a href="http://rustbyexample.com/std/result.html">http://rustbyexample.com/std/result.html</a>
</li>

<li>Rust stdlib: Option<br />
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">https://doc.rust-lang.org/std/option/enum.Option.html</a>
</li>

<li>Module std::option<br />
<a href="https://doc.rust-lang.org/std/option/index.html">https://doc.rust-lang.org/std/option/index.html</a>
</li>

<li>Rust by example: option<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>Rust by example: if-let<br />
<a href="http://rustbyexample.com/flow_control/if_let.html">http://rustbyexample.com/flow_control/if_let.html</a>
</li>

<li>Rust by example: while let<br />
<a href="http://rustbyexample.com/flow_control/while_let.html">http://rustbyexample.com/flow_control/while_let.html</a>
</li>

<li>Rust by example: Option&lt;i32&gt;<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>An Overview of Macros in Rust<br />
<a href="http://words.steveklabnik.com/an-overview-of-macros-in-rust">http://words.steveklabnik.com/an-overview-of-macros-in-rust</a>
</li>

<li>A Practical Intro to Macros in Rust 1.0<br />
<a href="https://danielkeep.github.io/practical-intro-to-macros.html">https://danielkeep.github.io/practical-intro-to-macros.html</a>
</li>

<li>The Rust Programming Language: macros<br />
<a href="https://doc.rust-lang.org/beta/book/macros.html">https://doc.rust-lang.org/beta/book/macros.html</a>
</li>

<li>Rust by example: 15 macro_rules!<br />
<a href="http://rustbyexample.com/macros.html">http://rustbyexample.com/macros.html</a>
</li>

<li>Primitive Type isize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.isize.html">https://doc.rust-lang.org/nightly/std/primitive.isize.html</a>
</li>

<li>Primitive Type usize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">https://doc.rust-lang.org/nightly/std/primitive.usize.html</a>
</li>

<li>Primitive Type array<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.array.html">https://doc.rust-lang.org/nightly/std/primitive.array.html</a>
</li>

<li>Module std::slice<br />
<a href="https://doc.rust-lang.org/nightly/std/slice/">https://doc.rust-lang.org/nightly/std/slice/</a>
</li>

<li>Rust by Example: 2.3 Arrays and Slices<br />
<a href="http://rustbyexample.com/primitives/array.html">http://rustbyexample.com/primitives/array.html</a>
</li>

<li>What is the difference between Slice and Array (stackoverflow)<br />
<a href="http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array">http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array</a>
</li>

<li>Learning Rust With Entirely Too Many Linked Lists<br />
<a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/">http://cglab.ca/~abeinges/blah/too-many-lists/book/</a>
</li>

<li>Testcase: linked list<br />
<a href="http://rustbyexample.com/custom_types/enum/testcase_linked_list.html">http://rustbyexample.com/custom_types/enum/testcase_linked_list.html</a>
</li>

<li>Operators and Overloading<br />
<a href="https://doc.rust-lang.org/book/operators-and-overloading.html">https://doc.rust-lang.org/book/operators-and-overloading.html</a>
</li>

<li>Module std::ops<br />
<a href="https://doc.rust-lang.org/std/ops/index.html">https://doc.rust-lang.org/std/ops/index.html</a>
</li>

<li>Module std::cmp<br />
<a href="https://doc.rust-lang.org/std/cmp/index.html">https://doc.rust-lang.org/std/cmp/index.html</a>
</li>

<li>Trait std::ops::Add<br />
<a href="https://doc.rust-lang.org/stable/std/ops/trait.Add.html">https://doc.rust-lang.org/stable/std/ops/trait.Add.html</a>
</li>

<li>Trait std::ops::AddAssign<br />
<a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html">https://doc.rust-lang.org/std/ops/trait.AddAssign.html</a>
</li>

<li>Trait std::ops::Drop<br />
<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">https://doc.rust-lang.org/std/ops/trait.Drop.html</a>
</li>

<li>Trait std::cmp::Eq<br />
<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">https://doc.rust-lang.org/std/cmp/trait.Eq.html</a>
</li>

<li>Struct std::boxed::Box<br />
<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">https://doc.rust-lang.org/std/boxed/struct.Box.html</a>
</li>

<li>Explore the ownership system in Rust<br />
<a href="https://nercury.github.io/rust/guide/2015/01/19/ownership.html">https://nercury.github.io/rust/guide/2015/01/19/ownership.html</a>
</li>

<li>Rust's ownership and move semantic<br/>
<a href="http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics">http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics</a>
</li>

<li>Trait std::marker::Copy<br/>
<a href="https://doc.rust-lang.org/stable/std/marker/trait.Copy.html">https://doc.rust-lang.org/stable/std/marker/trait.Copy.html</a>
</li>

<li>Trait std::clone::Clone<br />
<a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html">https://doc.rust-lang.org/stable/std/clone/trait.Clone.html</a>
</li>

<li>The Stack and the Heap<br />
<a href="https://doc.rust-lang.org/book/the-stack-and-the-heap.html">https://doc.rust-lang.org/book/the-stack-and-the-heap.html</a>
</li>

<li>Rust Compare: Pointers &amp; References<br />
<a href="http://www.rust-compare.com/site/pointers.html">http://www.rust-compare.com/site/pointers.html</a>
</li>

<li>Rust Compare: Parameters<br />
<a href="http://www.rust-compare.com/site/params.html">http://www.rust-compare.com/site/params.html</a>
</li>

<li>Why does this compile? Automatic dereferencing?<br />
<a href="https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183">https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183</a>
</li>

<li>Understanding Pointers, Ownership, and Lifetimes in Rust<br />
<a href="http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html">http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html</a>
</li>

<li>Rust lang series episode #25 — pointers (#rust-series)<br />
<a href="https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series">https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series</a>
</li>

<li>Rust - home page<br />
<a href="https://www.rust-lang.org/en-US/">https://www.rust-lang.org/en-US/</a>
</li>

<li>Rust - Frequently Asked Questions<br />
<a href="https://www.rust-lang.org/en-US/faq.html">https://www.rust-lang.org/en-US/faq.html</a>
</li>

<li>Destructuring and Pattern Matching<br />
<a href="https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/">https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/</a>
</li>

<li>The Rust Programming Language<br />
<a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>
</li>

<li>Rust (programming language)<br />
<a href="https://en.wikipedia.org/wiki/Rust_%28programming_language%29">https://en.wikipedia.org/wiki/Rust_%28programming_language%29</a>
</li>

<li>Go - home page<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>Stack Overflow - Most Loved, Dreaded, and Wanted language<br />
<a href="https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted">https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted</a>
</li>

<li>Rust vs Go (dva roky staré hodnocení, od té doby došlo k posunům v obou jazycích)<br />
<a href="http://jaredforsyth.com/2014/03/22/rust-vs-go/">http://jaredforsyth.com/2014/03/22/rust-vs-go/</a>
</li>

<li>Rust vs Go: My experience<br />
<a href="https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/">https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/</a>
</li>

<li>Friends of Rust (Organizations running Rust in production)<br />
<a href="https://www.rust-lang.org/en-US/friends.html">https://www.rust-lang.org/en-US/friends.html</a>
</li>

<li>Rust programs versus C++ g++<br />
<a href="https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp">https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp</a>
</li>

<li>Další benchmarky (nejedná se o reálné příklady &bdquo;ze života&ldquo;)<br />
<a href="https://github.com/kostya/benchmarks">https://github.com/kostya/benchmarks</a>
</li>

<li>Go na Redditu<br />
<a href="https://www.reddit.com/r/golang/">https://www.reddit.com/r/golang/</a>
</li>

<li>Rust vs. Go<br />
<a href="http://vschart.com/compare/rust/vs/go-language">http://vschart.com/compare/rust/vs/go-language</a>
</li>

<li>Abstraction without overhead: traits in Rust<br />
<a href="https://blog.rust-lang.org/2015/05/11/traits.html">https://blog.rust-lang.org/2015/05/11/traits.html</a>
</li>

<li>Method Syntax<br />
<a href="https://doc.rust-lang.org/book/method-syntax.html">https://doc.rust-lang.org/book/method-syntax.html</a>
</li>

<li>Traits in Rust<br />
<a href="https://doc.rust-lang.org/book/traits.html">https://doc.rust-lang.org/book/traits.html</a>
</li>

<li>Functional Programming in Rust - Part 1 : Function Abstraction<br />
<a href="http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/">http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/</a>
</li>

<li>Of the emerging systems languages Rust, D, Go and Nim, which is the strongest language and why?<br />
<a href="https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why">https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why</a>
</li>

<li>Chytré ukazatele (moderní verze jazyka C++) [MSDN]<br />
<a href="https://msdn.microsoft.com/cs-cz/library/hh279674.aspx">https://msdn.microsoft.com/cs-cz/library/hh279674.aspx</a>
</li>

<li>UTF-8 Everywhere<br />
<a href="http://utf8everywhere.org/">http://utf8everywhere.org/</a>
</li>

<li>Rust by Example<br />
<a href="http://rustbyexample.com/">http://rustbyexample.com/</a>
</li>

<li>Rust oficiálně ve Fedoře<br />
<a href="https://mojefedora.cz/rust-oficialne-ve-fedore/">https://mojefedora.cz/rust-oficialne-ve-fedore/</a>
</li>

<li>Resource acquisition is initialization<br />
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization</a>
</li>

<li>TIOBE index (October 2016)<br />
<a href="http://www.tiobe.com/tiobe-index/">http://www.tiobe.com/tiobe-index/</a>
</li>

<li>Porovnání Go, D a Rustu na OpenHubu:<br />
<a href="https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits">https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits</a>
</li>

<li>String Types in Rust<br />
<a href="http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/">http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/</a>
</li>

<li>Trait (computer programming)<br />
<a href="https://en.wikipedia.org/wiki/Trait_%28computer_programming%29">https://en.wikipedia.org/wiki/Trait_%28computer_programming%29</a>
</li>

<li>Type inference<br />
<a href="https://en.wikipedia.org/wiki/Type_inference">https://en.wikipedia.org/wiki/Type_inference</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

