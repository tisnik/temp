<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Datové kolekce v programovacím jazyku Rust</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Datové kolekce v programovacím jazyku Rust</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Při popisu standardní knihovny programovacího jazyka Rust samozřejmě nemůžeme vynechat datové kolekce a moduly určené pro práci s&nbsp;nimi. Mezi datové kolekce se řadí sekvenční typy, množiny a mapy. Programátor si přitom může podle svých požadavků vybrat vždy z&nbsp;několika implementací požadované kolekce.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Datové kolekce v&nbsp;programovacím jazyku Rust</a></p>
<p><a href="#k02">2. Sekvenční typy: Vec, VecDeque a LinkedList</a></p>
<p><a href="#k03">3. Časová složitost základních operací se sekvencemi</a></p>
<p><a href="#k04">4. Sekvenční typ <strong>Vec</strong></a></p>
<p><a href="#k05">5. Operace <strong>push()</strong>, <strong>pop()</strong> a indexování prvků</a></p>
<p><a href="#k06">6. Operace <strong>insert()</strong> a <strong>remove()</strong></a></p>
<p><a href="#k07">7. Sekvenční typ <strong>LinkedList</strong></a></p>
<p><a href="#k08">8. Operace <strong>push_front()</strong>, <strong>push_back()</strong>, <strong>pop_front()</strong> a <strong>pop_back()</strong></a></p>
<p><a href="#k09">9. Operace <strong>split_off()</strong></a></p>
<p><a href="#k10">10. Operace <strong>append()</strong></a></p>
<p><a href="#k11">11. Vyhledání prvku v&nbsp;seznamu &ndash; operace <strong>contains()</strong></a></p>
<p><a href="#k12">12. Sekvenční typ <strong>VecDeque</strong></a></p>
<p><a href="#k13">13. Běžná fronta: operace <strong>push_back()</strong>, a <strong>pop_front()</strong></a></p>
<p><a href="#k14">14. Příklady použití oboustranné fronty</a></p>
<p><a href="#k15">15. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k16">16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Datové kolekce v&nbsp;programovacím jazyku Rust</h2>

<p>Při popisu základních vlastností programovacího jazyka Rust jsme se
zmiňovali i o primitivních datových typech. Většinou se jedná o skalární typy,
konkrétně o booleovský typ, celá čísla, čísla s&nbsp;plovoucí řádovou čárkou a
znaky. Výjimkou jsou konstantní řetězce, n-tice (<i>tuple</i>) a pole
(<i>array</i>). V&nbsp;mnoha aplikacích &ndash; s&nbsp;velkou pravděpodobností
se dokonce bude jednat o většinu aplikací &ndash; si však s&nbsp;použitím n-tic
a polí nevystačíme. Z&nbsp;tohoto důvodu je v&nbsp;základní knihovně
programovacího jazyka Rust implementováno hned několik typů datových kolekcí,
které dělíme na sekvenční (homogenní) typy, množiny a mapy. Ostatně podobné
dělení nalezneme například i v&nbsp;<i>JCF (Java Collection Framework)</i>.
V&nbsp;následující tabulce jsou všechny tři typy i jejich konkrétní
implementace vypsány. Navíc je do této tabulky doplněna i nezařazená kolekce
<strong>BinaryHeap</strong>:</p>

<table>
<tr><th>Typ</th><th>Konkrétní implementace</th></tr>
<tr><td>Sekvence</td><td>Vec, VecDeque, LinkedList</td></tr>
<tr><td>Množiny</td><td>HashSet, BTreeSet</td></tr>
<tr><td>Mapy</td><td>HashMap, BTreeMap</td></tr>
<tr><td>Ostatní</td><td>BinaryHeap</td></tr>
</table>

<p>Autoři programovacího jazyka Rust doporučují použít standardní typy kolekcí
všude tam, kde je to alespoň trošku možné. Důvod je jednoduchý &ndash; použitím
standardní kolekce se zjednoduší programové rozhraní knihoven, již z&nbsp;názvu
kolekce budou ostatní programátoři informováni jak o základních vlastnostech,
tak i o konkrétní implementaci atd. Taktéž je důležité, že standardní knihovna
je napsána optimálně a je velmi dobře testována (už jen proto, že ji používá
obrovské množství programátorů).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Sekvenční typy: Vec, VecDeque a LinkedList</h2>

<p>První tři typy kolekcí se jmenují <strong>Vec</strong>,
<strong>VecDeque</strong> a <strong>LinkedList</strong>. Jedná se o sekvenční a
současně i homogenní datové typy. Označení <i>sekvenční</i> znamená to, že je
zachováno pořadí prvků a navíc lze získat iterátor procházející všemi prvky
v&nbsp;tomto pořadí. Označením <i>homogenní</i> odkazujeme na fakt, že se při
konstrukci sekvence přesně definuje datový typ jejích prvků, který je následně
kontrolován překladačem.</p>

<p>Všechny tři sekvenční typy nabízí metodu <strong>iter()</strong> vracející
iterátor, konkrétně objekt typu <strong>Iter&lt;T&gt;</strong>, kde
<strong>T</strong> je typ prvků vkládaných do kolekcí. Přes iterátor má
programátor přístup jak k&nbsp;sekvenci všech prvků v&nbsp;kolekci, tak i
k&nbsp;mnoha dalším užitečným metodám, například:</p>

<table>
<tr><th>Metoda pro Iter&lt;T&gt;</th><th>Význam</th></tr>
<tr><td>next()</td><td>vrátí další prvek</td></tr>
<tr><td>last()</td><td>vrátí poslední prvek</td></tr>
<tr><td>nth(n)</td><th>vrátí n-tý prvek</th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>take(n)</td><td>vrátí prvních n prvků</td></tr>
<tr><td>skip(n)</td><td>opak předchozího, vrátí prvky od n-tého</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>count()</td><td>počet prvků do konce sekvence</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>map()</td><td>iterátor pro novou sekvenci, která vznikne aplikací vybrané funkce</td></tr>
<tr><td>filter()</td><td>iterátor pro novou sekvenci po aplikaci filtru</td></tr>
<tr><td>filter_map()</td><td>kombinace obou předchozích možností</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>zip()</td><td>ze dvou iterátorů vznikne nový pro sekvence dvojic</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Časová složitost základních operací se sekvencemi</h2>

<p>Při výběru vhodné datové kolekce sekvenčního typu je nutné brát v&nbsp;úvahu
především paměťovou náročnost a taktéž časovou složitost základních operací se
sekvencemi. Mezi základní operace řadíme výběr i-tého prvku <i>get(i)</i>,
vložení nového prvku na i-tou pozici <i>insert(i)</i>, vyjmutí prvku
z&nbsp;i-té pozice <i>remove(i)</i>, připojení druhé kolekce <i>append</i> a
taktéž rozdělení kolekce na dvě libovolně velké části začínající i-tou pozicí
<i>split_off(i)</i>. Povšimněte si, že u dvoucestného lineárního seznamu je
složitost výběru prvku &bdquo;jen&ldquo; O(min(i, n-i)) a nikoli O(n), protože
vyhledání lze provádět i od posledního prvku. Totéž samozřejmě platí i pro
operace <i>insert(i)</i> a <i>remove(i)</i>, protože sice vložení a vyjmutí
prvku má u seznamu složitost O(1), ovšem nejprve je nutné vyhledat místo, kam
se má prvek vložit nebo z&nbsp;něhož se má odstranit. U operace <i>append</i>
(připojení druhé kolekce) značí <i>m</i> velikost připojované kolekce:</p>

<table>
<tr><th>Sekvence</th><th>get(i)</th><th>insert(i)</th><th>remove(i)</th><th>append</th><th>split_off(i)</th></tr>
<tr><td>Vec</td><td>O(1)</td><td>O(n-i)</td><td>O(n-i)</td><td>O(m)</td><td>O(n-i)</td></tr>
<tr><td>VecDeque</td><td>O(1)</td><td>O(min(i, n-i))</td><td>O(min(i, n-i))</td><td>O(m)</td><td>O(min(i, n-i))</td></tr>
<tr><td>LinkedList</td><td>O(min(i, n-i))</td><td>O(min(i, n-i))</td><td>O(min(i, n-i))</td><td>O(1)</td><td>O(min(i, n-i))</td></tr>
</table>

<p>Poznámka: operace <i>insert(i)</i> a <i>append()</i> u typů
<strong>Vec</strong> a <strong>VecDeque</strong> budou mít horší časovou
složitost O(n) ve chvíli, kdy bude zapotřebí zvětšit kapacitu příslušné
kolekce. U operace <i>remove(i)</i>, která je teoreticky inverzní
k&nbsp;operaci <i>insert(i)</i> to však neplatí, protože kolekce se nikdy
automaticky nezmenšují &ndash; jedná se totiž o explicitní operaci vyvolanou
v&nbsp;uživatelském programu.</p>

<p>Poznámka<sup>2</sup>: existují i operace, které mají lepší časovou
složitost. Příkladem je operace <i>push()</i> u vektorů v&nbsp;případě, že má
vektor dostatečnou kapacitu. V&nbsp;takovém případě je složitost O(1).</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Sekvenční typ <strong>Vec</strong></h2>

<p>S&nbsp;vektory, které jsou v&nbsp;programovacím jazyku Rust představovány
typem <strong>Vec</strong>, jsme se již <a
href="https://www.root.cz/clanky/prace-s-vektory-v-programovacim-jazyku-rust/">v&nbsp;tomto
seriálu setkali</a>. Připomeňme si ve stručnosti, že interně je
<strong>Vec</strong> reprezentován strukturou, která obsahuje několik atributů,
především kapacitu vektoru, počet prvků vektoru (počet prvků může být a bývá
menší než kapacita) a taktéž ukazatel na vlastní prvky, které jsou však
umístěny na haldě (dokonce musí být na haldě, protože překladač nezná délku
vektoru, což je v&nbsp;Rustu jeden z&nbsp;požadavků na umístění hodnoty na
zásobník). Interně jsou prvky uloženy v&nbsp;poli, což znamená komplikace při
zvětšování a/nebo zmenšování jeho kapacity (je nutné provést kopii. Vektory lze
vytvořit konstruktorem <strong>Vec::new()</strong>, ovšem mnohem častěji
uvidíme použití makra <strong>vec!</strong>:</p>

<pre>
fn main() {
    let vector = vec![1, 2, 3, 4, 5];
}
</pre>

<p>Poměrně často se setkáme i s&nbsp;nutností specifikovat počáteční kapacitu
vektoru:</p>

<pre>
fn main() {
    let mut vector = Vec::with_capacity(10);
}
</pre>

<p>Pokud má vektor dostatečnou kapacitu specifikovanou programátorem
(implicitní výchozí kapacita při použití konstruktoru
<strong>Vec::new()</strong> je nula prvků!), je možné provádět všechny základní
operace &ndash; získání i-tého prvku, vložení prvku na konec vektoru a
odstranění prvku z&nbsp;konce vektoru s&nbsp;konstantní složitostí. Vektor je
tedy možné použít i ve funkci zásobníku. Kromě toho je však možné použít i
další operace, které budou postupně podrobněji popsány v&nbsp;navazujících
kapitolách.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Operace <strong>push()</strong>, <strong>pop()</strong> a indexování prvků</h2>

<p>Mezi dvě základní operace s&nbsp;vektory patří <strong>push()</strong> a
<strong>pop()</strong>. Tyto operace, které mají v&nbsp;ideálním případě
konstantní složitost O(1) (pokud je kapacita dostatečná), jsou prováděny na
konci vektoru &ndash; <strong>push()</strong> připojí nový prvek (a
popř.&nbsp;realokuje vektor) a <strong>pop()</strong> prvek odstraní a současně
vrátí jeho hodnotu. Ovšem vzhledem k&nbsp;tomu, že nemusí být zřejmé, zda
vektor vůbec nějaký prvek obsahuje, vrací operace <strong>pop()</strong> nikoli
přímo hodnotu typu <strong>T</strong>, ale nám již dobře známou strukturu
<strong>Option&lt;T&gt;</strong> (tedy i <strong>None</strong> v&nbsp;případě
prázdného vektoru). Vyzkoušejme si použití těchto operací na jednoduchém
příkladu:</p>

<pre>
fn print_vector(vector: &amp;Vec&lt;i32&gt;) {
    if vector.is_empty() {
        println!("vector is empty");
    } else {
        println!("vector has {} items", vector.len());
    }
&nbsp;
    for item in vector.iter() {
        println!("{}", item);
    }
&nbsp;
    println!("-------------------------");
}
&nbsp;
fn main() {
    let mut vector = vec![];
&nbsp;
    println!("new vector");
    print_vector(&amp;vector);
&nbsp;
    for i in 0..10 {
        vector.push(2*i);
    }
&nbsp;
    println!("after 10x push");
    print_vector(&amp;vector);
&nbsp;
    for _ in 0..5 {
        vector.pop();
    }
&nbsp;
    println!("after 5x pop");
    print_vector(&amp;vector);
&nbsp;
    println!("indexing vector items");
    for i in 0..vector.len() {
        println!("{}", vector[i]);
    }
&nbsp;
}
</pre>

<p>Výsledek:</p>

<pre>
new vector
vector is empty
-------------------------
after 10x push
vector has 10 items
0
2
4
6
8
10
12
14
16
18
-------------------------
after 5x pop
vector has 5 items
0
2
4
6
8
-------------------------
indexing vector items
0
2
4
6
8
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Operace <strong>insert()</strong> a <strong>remove()</strong></h2>

<p>Do vektorů lze přidávat prvky na zvolené místo (index) operací
<strong>insert()</strong>, které se předá index a hodnota vkládaného prvku.
Opakem je operace <strong>remove()</strong>, která navíc vrátí hodnotu
odstraňovaného prvku. Vzhledem ke způsobu interní reprezentace vektoru (pole
prvků) mají tyto operace složitost O(n-i), kde n je počet prvků vektoru. Pokud
je ovšem nutné provést realokaci (vektor nemá dostatečnou kapacitu), je
složitost horší: O(n). Opět se podívejme na demonstrační příklad:</p>

<pre>
fn print_vector(vector: &amp;Vec&lt;i32&gt;) {
    if vector.is_empty() {
        println!("vector is empty");
    } else {
        println!("vector has {} items", vector.len());
    }
&nbsp;
    for item in vector.iter() {
        println!("{}", item);
    }
&nbsp;
    println!("-------------------------");
}
&nbsp;
fn main() {
    let mut vector = vec![];
&nbsp;
    println!("new vector");
    print_vector(&amp;vector);
&nbsp;
    for i in 0..10 {
        vector.push(2*i);
    }
&nbsp;
    println!("after 10x push");
    print_vector(&amp;vector);
&nbsp;
    for _ in 0..5 {
        vector.pop();
    }
&nbsp;
    println!("after 5x pop");
    print_vector(&amp;vector);
&nbsp;
    vector.resize(10, -1);
&nbsp;
    println!("after resize to 10 items");
    print_vector(&amp;vector);
&nbsp;
    vector.insert(2, 999);
    vector.insert(10, 1000);
&nbsp;
    println!("after 2x insert");
    print_vector(&amp;vector);
&nbsp;
    vector.remove(0);
    vector.remove(10);
&nbsp;
    println!("after 2x remove");
    print_vector(&amp;vector);
&nbsp;
}
</pre>

<p>Výsledek:</p>

<pre>
new vector
vector is empty
-------------------------
after 10x push
vector has 10 items
0
2
4
6
8
10
12
14
16
18
-------------------------
after 5x pop
vector has 5 items
0
2
4
6
8
-------------------------
after resize to 10 items
vector has 10 items
0
2
4
6
8
-1
-1
-1
-1
-1
-------------------------
after 2x insert
vector has 12 items
0
2
999
4
6
8
-1
-1
-1
-1
1000
-1
-------------------------
after 2x remove
vector has 10 items
2
999
4
6
8
-1
-1
-1
-1
1000
-------------------------
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Sekvenční typ <strong>LinkedList</strong></h2>

<p>Druhým sekvenčním a současně i homogenním datovým typem je
<i>LinkedList</i>. Interně se jedná o dvousměrný spojový seznam, takže každý
prvek obsahuje referenci na prvek předchozí i prvek následující. Struktura
navíc obsahuje i referenci na první a poslední prvek, takže přidávání či
ubírání prvků z&nbsp;obou stran seznamu (začátek, konec) je operace se
složitostí O(1) a získání i-tého prvku má složitost O(min(i, n-1)), protože se
může procházet jak od začátku, tak i od konce, přičemž se samozřejmě zvolí
kratší cesta. Podobnou složitost mají i operace <i>insert()</i> a
<i>remove()</i>, takže v&nbsp;případě, kdy je nutné často vkládat či naopak
odstraňovat prvky uvnitř sekvenční struktury, je dvousměrný spojový seznam
vhodná volba. Nesmíme však zapomenout na to, že každý prvek kromě své hodnoty
obsahuje i dvojici referencí, takže paměťová náročnost je (někdy i násobně)
větší, než u běžných polí či vektorů.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Operace <strong>push_front()</strong>, <strong>push_back()</strong>, <strong>pop_front()</strong> a <strong>pop_back()</strong></h2>

<p>V&nbsp;předchozí kapitole jsme si řekli, že u dvoucestného spojového seznamu
je možné nové prvky přidávat na oba konce a z&nbsp;obou konců je taktéž
odstraňovat. K&nbsp;tomu slouží operace <strong>push_front()</strong>,
<strong>push_back()</strong>, <strong>pop_front()</strong> a
<strong>pop_back()</strong>. V&nbsp;dalším příkladu je ukázáno přidání prvků na
začátek i na konec seznamu. Navíc si povšimněte, že i tento typ kolekce
podporuje operace <strong>is_empty()</strong>, <strong>len()</strong> a
<strong>iter()</strong>:</p>

<pre>
use std::collections::LinkedList;
&nbsp;
fn print_list(list: &amp;LinkedList&lt;i32&gt;) {
&nbsp;
    if list.is_empty() {
        println!("list is empty");
    } else {
        println!("list has {} items", list.len());
    }
&nbsp;
    for item in list.iter() {
        println!("{}", item);
    }
&nbsp;
    println!("-------------------------");
}
&nbsp;
fn main() {
    let mut list: LinkedList&lt;i32&gt; = LinkedList::new();
&nbsp;
    println!("new list");
    print_list(&amp;list);
&nbsp;
    for i in 0..10 {
        list.push_back(i);
    }
&nbsp;
    println!("after 10x push_back");
    print_list(&amp;list);
&nbsp;
    for i in 0..10 {
        list.push_front(i);
    }
&nbsp;
    println!("after 10x push_front");
    print_list(&amp;list);
&nbsp;
}
</pre>

<p>Výsledek:</p>

<pre>
new list
list is empty
-------------------------
after 10x push_back
list has 10 items
0
1
2
3
4
5
6
7
8
9
-------------------------
after 10x push_front
list has 20 items
9
8
7
6
5
4
3
2
1
0
0
1
2
3
4
5
6
7
8
9
-------------------------
</pre>

<p>Další příklad používá operace <strong>push_front()</strong> a
<strong>push_back()</strong> následované operacemi <strong>pop_front()</strong>
a <strong>pop_back()</strong>:</p>

<pre>
use std::collections::LinkedList;
&nbsp;
fn print_list(list: &amp;LinkedList&lt;i32&gt;) {
&nbsp;
    if list.is_empty() {
        println!("list is empty");
    } else {
        println!("list has {} items", list.len());
    }
&nbsp;
    for item in list.iter() {
        println!("{}", item);
    }
&nbsp;
    println!("-------------------------");
}
&nbsp;
fn main() {
    let mut list: LinkedList&lt;i32&gt; = LinkedList::new();
&nbsp;
    println!("new list");
    print_list(&amp;list);
&nbsp;
    for i in 0..10 {
        list.push_back(i);
    }
&nbsp;
    println!("after 10x push_back");
    print_list(&amp;list);
&nbsp;
    for i in 0..10 {
        list.push_front(i);
    }
&nbsp;
    println!("after 10x push_front");
    print_list(&amp;list);
&nbsp;
    for _ in 0..4 {
        list.pop_front();
    }
&nbsp;
    println!("after 5x pop_front");
    print_list(&amp;list);
&nbsp;
    for _ in 0..4 {
        list.pop_back();
    }
&nbsp;
    println!("after 5x pop_back");
    print_list(&amp;list);
&nbsp;
}
</pre>

<pre>
new list
list is empty
-------------------------
after 10x push_back
list has 10 items
0
1
2
3
4
5
6
7
8
9
-------------------------
after 10x push_front
list has 20 items
9
8
7
6
5
4
3
2
1
0
0
1
2
3
4
5
6
7
8
9
-------------------------
after 5x pop_front
list has 16 items
5
4
3
2
1
0
0
1
2
3
4
5
6
7
8
9
-------------------------
after 5x pop_back
list has 12 items
5
4
3
2
1
0
0
1
2
3
4
5
-------------------------
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Operace <strong>split_off()</strong></h2>

<p>Seznam (ale i vektor) je možné v&nbsp;případě potřeby rozdělit na dva kratší
seznamy operací <i>split_off()</i>. Této operaci se předá index prvku seznamu,
kde má dojít k&nbsp;jeho rozdělení. Starý seznam je zkrácen takovým způsobem,
že obsahuje prvky s&nbsp;indexy 0 až i-1, nový seznam pak obsahuje prvky, které
měly původně indexy i až n-1. Opět se podívejme na příklad použití této
operace:</p>

<pre>
use std::collections::LinkedList;
&nbsp;
fn print_list(list: &amp;LinkedList&lt;i32&gt;) {
&nbsp;
    if list.is_empty() {
        println!("list is empty");
    } else {
        println!("list has {} items", list.len());
    }
&nbsp;
    for item in list.iter() {
        println!("{}", item);
    }
&nbsp;
    println!("-------------------------");
}
&nbsp;
fn main() {
    let mut list1: LinkedList&lt;i32&gt; = LinkedList::new();
&nbsp;
    println!("new list");
    print_list(&amp;list1);
&nbsp;
    for i in 0..10 {
        list1.push_back(i);
    }
&nbsp;
    println!("after 10x push_back");
    print_list(&amp;list1);
&nbsp;
    let list2 = list1.split_off(5);
&nbsp;
    println!("1st list");
    print_list(&amp;list1);
&nbsp;
    println!("2nd list");
    print_list(&amp;list2);
&nbsp;
}
</pre>

<p>Výsledek:</p>

<pre>
new list
list is empty
-------------------------
after 10x push_back
list has 10 items
0
1
2
3
4
5
6
7
8
9
-------------------------
1st list
list has 5 items
0
1
2
3
4
-------------------------
2nd list
list has 5 items
5
6
7
8
9
-------------------------
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Operace <strong>append()</strong></h2>

<p>Opakem výše popsané operace <i>split_off()</i> je operace <i>append()</i>,
která dokáže k&nbsp;jednomu lineárnímu seznamu přidat druhý seznam (ten je
naopak vyprázdněn, tj.&nbsp;nebude obsahovat žádné prvky &ndash; to je důsledek
ownership modelu Rustu). Překladač přitom kontroluje, zda jsou oba seznamy
kompatibilní, tj.&nbsp;jestli obsahují prvky stejného typu. U seznamů je
operace <i>append()</i> provedena v&nbsp;konstantním čase, protože se pouze
změní hodnoty dvou referencí u posledního prvku prvního seznamu a počátečního
prvku seznamu druhého:</p>

<pre>
use std::collections::LinkedList;
&nbsp;
fn print_list(list: &amp;LinkedList&lt;i32&gt;) {
&nbsp;
    if list.is_empty() {
        println!("list is empty");
    } else {
        println!("list has {} items", list.len());
    }
&nbsp;
    for item in list.iter() {
        println!("{}", item);
    }
&nbsp;
    println!("-------------------------");
}
&nbsp;
fn main() {
    let mut list1: LinkedList&lt;i32&gt; = LinkedList::new();
    let mut list2: LinkedList&lt;i32&gt; = LinkedList::new();
&nbsp;
    for _ in 0..10 {
        list1.push_back(1);
    }
&nbsp;
    for _ in 0..10 {
        list2.push_front(2);
    }
&nbsp;
    println!("1st list");
    print_list(&amp;list1);
&nbsp;
    println!("2nd list");
    print_list(&amp;list2);
&nbsp;
    list1.append(&amp;mut list2);
&nbsp;
    println!("after append");
&nbsp;
    println!("1st list");
    print_list(&amp;list1);
&nbsp;
    println!("2nd list");
    print_list(&amp;list2);
&nbsp;
}
</pre>

<p>Výsledek běhu tohoto programu:</p>

<pre>
1st list
list has 10 items
1
1
1
1
1
1
1
1
1
1
-------------------------
2nd list
list has 10 items
2
2
2
2
2
2
2
2
2
2
-------------------------
after append
1st list
list has 20 items
1
1
1
1
1
1
1
1
1
1
2
2
2
2
2
2
2
2
2
2
-------------------------
2nd list
list is empty
-------------------------
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Vyhledání prvku v&nbsp;seznamu &ndash; operace <strong>contains()</strong></h2>

<p>Poslední užitečnou operací nad seznamem, kterou si dnes popíšeme, je test na
existenci prvku s&nbsp;daným obsahem. Tuto operaci se složitostí O(n) zajišťuje
metoda <strong>contains()</strong> vracející pravdivostní hodnotu
<strong>true</strong> či <strong>false</strong>. Povšimněte si, že hodnotu
testovaného prvku je zapotřebí předat přes referenci, což platí například i pro
celočíselné hodnoty:</p>

<pre>
use std::collections::LinkedList;
&nbsp;
fn main() {
    let mut list: LinkedList&lt;i32&gt; = LinkedList::new();
&nbsp;
    for i in 5..10 {
        list.push_back(i);
    }
&nbsp;
    for i in 0..15 {
        println!("{}: {}", i, list.contains(&amp;i));
    }
}
</pre>

<p>Výsledek běhu tohoto příkladu:</p>

<pre>
0: false
1: false
2: false
3: false
4: false
5: true
6: true
7: true
8: true
9: true
10: false
11: false
12: false
13: false
14: false
</pre>

<p>Poznámka: pokud by tato operace měla při práci s&nbsp;kolekcí převažovat, je
výhodnější použít <strong>HashSet</strong> či <strong>BTreeSet</strong>.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Sekvenční typ <strong>VecDeque</strong></h2>

<p>Posledním sekvenčním i homogenním datovým typem, který nalezneme ve
standardní knihovně programovacího jazyka Rust, je <strong>VecDeque</strong>
neboli obousměrná fronta (<i>double-ended queue, deque</i>). Interně se jedná o
cyklickou frontu (<i>ring buffer</i>) s&nbsp;měnitelnou velikostí &ndash;
fronta může v&nbsp;případě potřeby na obou stranách narůstat. Tímto typem lze
snadno implementovat abstraktní datové typy zásobník i fronta, popř.&nbsp;obě
možnosti zkombinovat. Pokud se má <strong>VecDeque</strong> použít jako běžná
fronta, používají se pro vkládání a odstraňování prvků operace
<strong>push_back()</strong> a <strong>pop_front()</strong>. Metoda
<strong>iter()</strong> vrací prvky ve frontě v&nbsp;pořadí od začátku do
konce, což uvidíme na dalších demonstračních příkladech.</p>

<p>Poznámka: pokud jsou operace <strong>push_back()</strong> a
<strong>pop_front()</strong> vyvážené, není nutné zvyšovat kapacitu cyklické
fronty ani přemisťovat její prvky, což je v&nbsp;kontrastu s&nbsp;dvojicí
<strong>insert(0)</strong> a <strong>pop()</strong> u vektorů.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Běžná fronta: operace <strong>push_back()</strong>, a <strong>pop_front()</strong></h2>

<p>Na dalším demonstračním příkladu si povšimněte především toho, že se prvky
získané iterátorem skutečně vypisují v&nbsp;pořadí od začátku (<i>front</i>) do
konce (<i>back</i>) i toho, jak se prvky frontou postupně přemisťují
(&bdquo;probublávají&ldquo;). Navíc je operace <strong>pop_front()</strong>
validní i ve chvíli, kdy je fronta prázdná &ndash; opět se totiž vrací typ
<strong>Option&lt;T&gt;</strong> s&nbsp;případnou hodnotou
<strong>None</strong> v&nbsp;případě prázdné fronty:</p>

<pre>
use std::collections::VecDeque;
&nbsp;
fn print_deque(deque: &amp;VecDeque&lt;i32&gt;) {
&nbsp;
    if deque.is_empty() {
        print!("deque is empty");
    } else {
        print!("deque has {} items: ", deque.len());
    }
&nbsp;
    for item in deque.iter() {
        print!("{:2} ", item);
    }
&nbsp;
    println!("");
}
&nbsp;
fn main() {
    let mut deque: VecDeque&lt;i32&gt; = VecDeque::new();
&nbsp;
    for i in 0..5 {
        deque.push_back(i);
        print_deque(&amp;deque);
    }
&nbsp;
    for i in 10..20 {
        deque.pop_front();
        deque.push_back(i);
        print_deque(&amp;deque);
    }
&nbsp;
    for _ in 0..6 {
        deque.pop_front();
        print_deque(&amp;deque);
    }
&nbsp;
}
</pre>

<pre>
deque has 1 items:  0 
deque has 2 items:  0  1 
deque has 3 items:  0  1  2 
deque has 4 items:  0  1  2  3 
deque has 5 items:  0  1  2  3  4 
deque has 5 items:  1  2  3  4 10 
deque has 5 items:  2  3  4 10 11 
deque has 5 items:  3  4 10 11 12 
deque has 5 items:  4 10 11 12 13 
deque has 5 items: 10 11 12 13 14 
deque has 5 items: 11 12 13 14 15 
deque has 5 items: 12 13 14 15 16 
deque has 5 items: 13 14 15 16 17 
deque has 5 items: 14 15 16 17 18 
deque has 5 items: 15 16 17 18 19 
deque has 4 items: 16 17 18 19 
deque has 3 items: 17 18 19 
deque has 2 items: 18 19 
deque has 1 items: 19 
deque is empty
deque is empty
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Příklady použití oboustranné fronty</h2>

<p>V&nbsp;dalším příkladu se fronta používá obráceným způsobem &ndash; prvky
jsou přidávány na začátek a odstraňovány z&nbsp;konce:</p>

<pre>
use std::collections::VecDeque;
&nbsp;
fn print_deque(deque: &amp;VecDeque&lt;i32&gt;) {
&nbsp;
    if deque.is_empty() {
        print!("deque is empty");
    } else {
        print!("deque has {} items: ", deque.len());
    }
&nbsp;
    for item in deque.iter() {
        print!("{:2} ", item);
    }
&nbsp;
    println!("");
}
&nbsp;
fn main() {
    let mut deque: VecDeque&lt;i32&gt; = VecDeque::new();
&nbsp;
    for i in 0..5 {
        deque.push_front(i);
        print_deque(&amp;deque);
    }
&nbsp;
    for i in 10..20 {
        deque.pop_back();
        deque.push_front(i);
        print_deque(&amp;deque);
    }
&nbsp;
    for _ in 0..6 {
        deque.pop_back();
        print_deque(&amp;deque);
    }
&nbsp;
}
</pre>

<p>Výsledek běhu:</p>

<pre>
deque has 1 items:  0 
deque has 2 items:  1  0 
deque has 3 items:  2  1  0 
deque has 4 items:  3  2  1  0 
deque has 5 items:  4  3  2  1  0 
deque has 5 items: 10  4  3  2  1 
deque has 5 items: 11 10  4  3  2 
deque has 5 items: 12 11 10  4  3 
deque has 5 items: 13 12 11 10  4 
deque has 5 items: 14 13 12 11 10 
deque has 5 items: 15 14 13 12 11 
deque has 5 items: 16 15 14 13 12 
deque has 5 items: 17 16 15 14 13 
deque has 5 items: 18 17 16 15 14 
deque has 5 items: 19 18 17 16 15 
deque has 4 items: 19 18 17 16 
deque has 3 items: 19 18 17 
deque has 2 items: 19 18 
deque has 1 items: 19 
deque is empty
deque is empty
</pre>

<p>Použití <i>deque</i> ve funkci zásobníku:</p>

<pre>
use std::collections::VecDeque;
&nbsp;
fn print_deque(deque: &amp;VecDeque&lt;i32&gt;) {
&nbsp;
    if deque.is_empty() {
        print!("deque is empty");
    } else {
        print!("deque has {} items: ", deque.len());
    }
&nbsp;
    for item in deque.iter() {
        print!("{:2} ", item);
    }
&nbsp;
    println!("");
}
&nbsp;
fn main() {
    let mut deque: VecDeque&lt;i32&gt; = VecDeque::new();
&nbsp;
    for i in 0..5 {
        deque.push_front(i);
        print_deque(&amp;deque);
    }
&nbsp;
    for i in 10..20 {
        deque.pop_front();
        deque.push_front(i);
        print_deque(&amp;deque);
    }
&nbsp;
    for _ in 0..6 {
        deque.pop_front();
        print_deque(&amp;deque);
    }
&nbsp;
}
</pre>

<pre>
deque has 1 items:  0 
deque has 2 items:  1  0 
deque has 3 items:  2  1  0 
deque has 4 items:  3  2  1  0 
deque has 5 items:  4  3  2  1  0 
deque has 5 items: 10  3  2  1  0 
deque has 5 items: 11  3  2  1  0 
deque has 5 items: 12  3  2  1  0 
deque has 5 items: 13  3  2  1  0 
deque has 5 items: 14  3  2  1  0 
deque has 5 items: 15  3  2  1  0 
deque has 5 items: 16  3  2  1  0 
deque has 5 items: 17  3  2  1  0 
deque has 5 items: 18  3  2  1  0 
deque has 5 items: 19  3  2  1  0 
deque has 4 items:  3  2  1  0 
deque has 3 items:  2  1  0 
deque has 2 items:  1  0 
deque has 1 items:  0 
deque is empty
deque is empty
</pre>

<p>Taktéž použití <i>deque</i> jako zásobníku, prvky se však vkládají na konec,
nikoli na začátek:</p>

<pre>
use std::collections::VecDeque;
&nbsp;
fn print_deque(deque: &amp;VecDeque&lt;i32&gt;) {
&nbsp;
    if deque.is_empty() {
        print!("deque is empty");
    } else {
        print!("deque has {} items: ", deque.len());
    }
&nbsp;
    for item in deque.iter() {
        print!("{:2} ", item);
    }
&nbsp;
    println!("");
}
&nbsp;
fn main() {
    let mut deque: VecDeque&lt;i32&gt; = VecDeque::new();
&nbsp;
    for i in 0..5 {
        deque.push_back(i);
        print_deque(&amp;deque);
    }
&nbsp;
    for i in 10..20 {
        deque.pop_back();
        deque.push_back(i);
        print_deque(&amp;deque);
    }
&nbsp;
    for _ in 0..6 {
        deque.pop_back();
        print_deque(&amp;deque);
    }
&nbsp;
}
</pre>

<pre>
deque has 1 items:  0 
deque has 2 items:  0  1 
deque has 3 items:  0  1  2 
deque has 4 items:  0  1  2  3 
deque has 5 items:  0  1  2  3  4 
deque has 5 items:  0  1  2  3 10 
deque has 5 items:  0  1  2  3 11 
deque has 5 items:  0  1  2  3 12 
deque has 5 items:  0  1  2  3 13 
deque has 5 items:  0  1  2  3 14 
deque has 5 items:  0  1  2  3 15 
deque has 5 items:  0  1  2  3 16 
deque has 5 items:  0  1  2  3 17 
deque has 5 items:  0  1  2  3 18 
deque has 5 items:  0  1  2  3 19 
deque has 4 items:  0  1  2  3 
deque has 3 items:  0  1  2 
deque has 2 items:  0  1 
deque has 1 items:  0 
deque is empty
deque is empty
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popisované demonstrační příklady byly, podobně jako ve všech
předchozích částech tohoto seriálu, uloženy do Git repositáře dostupného na
adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě bez nutnosti
klonovat celý repositář:</p>

<table>
<tr><th>Příklad</th><th>Odkaz</th></tr>
<tr><td>240_sequences1.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/240_sequences1.rs">https://github.com/tisnik/presentations/blob/master/rust/240_sequences1.rs</a></td></tr>
<tr><td>241_sequences2.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/241_sequences2.rs">https://github.com/tisnik/presentations/blob/master/rust/241_sequences2.rs</a></td></tr>
<tr><td>242_sequences3.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/242_sequences3.rs">https://github.com/tisnik/presentations/blob/master/rust/242_sequences3.rs</a></td></tr>
<tr><td>243_sequences4.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/243_sequences4.rs">https://github.com/tisnik/presentations/blob/master/rust/243_sequences4.rs</a></td></tr>
<tr><td>244_sequences5.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/244_sequences5.rs">https://github.com/tisnik/presentations/blob/master/rust/244_sequences5.rs</a></td></tr>
<tr><td>245_sequences6.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/245_sequences6.rs">https://github.com/tisnik/presentations/blob/master/rust/245_sequences6.rs</a></td></tr>
<tr><td>246_sequences7.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/246_sequences7.rs">https://github.com/tisnik/presentations/blob/master/rust/246_sequences7.rs</a></td></tr>
<tr><td>247_sequences8.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/247_sequences8.rs">https://github.com/tisnik/presentations/blob/master/rust/247_sequences8.rs</a></td></tr>
<tr><td>248_sequences9.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/248_sequences9.rs">https://github.com/tisnik/presentations/blob/master/rust/248_sequences9.rs</a></td></tr>
<tr><td>249_sequences10.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/249_sequences10.rs">https://github.com/tisnik/presentations/blob/master/rust/249_sequences10.rs</a></td></tr>
<tr><td>250_sequences11.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/250_sequences11.rs">https://github.com/tisnik/presentations/blob/master/rust/250_sequences11.rs</a></td></tr>
</table>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>Module std::collections<br />
<a href="https://doc.rust-lang.org/std/collections/">https://doc.rust-lang.org/std/collections/</a>
</li>

<li>Module std::vec<br />
<a href="https://doc.rust-lang.org/nightly/std/vec/index.html">https://doc.rust-lang.org/nightly/std/vec/index.html</a>
</li>

<li>Struct std::collections::VecDeque<br />
<a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html">https://doc.rust-lang.org/std/collections/struct.VecDeque.html</a>
</li>

<li>Struct std::collections::LinkedList<br />
<a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html">https://doc.rust-lang.org/std/collections/struct.LinkedList.html</a>
</li>

<li>Module std::fmt<br />
<a href="https://doc.rust-lang.org/std/fmt/">https://doc.rust-lang.org/std/fmt/</a>
</li>

<li>Macro std::println<br />
<a href="https://doc.rust-lang.org/std/macro.println.html">https://doc.rust-lang.org/std/macro.println.html</a>
</li>

<li>Enum std::result::Result<br />
<a href="https://doc.rust-lang.org/std/result/enum.Result.html">https://doc.rust-lang.org/std/result/enum.Result.html</a>
</li>

<li>Module std::result<br />
<a href="https://doc.rust-lang.org/std/result/">https://doc.rust-lang.org/std/result/</a>
</li>

<li>Result<br />
<a href="http://rustbyexample.com/std/result.html">http://rustbyexample.com/std/result.html</a>
</li>

<li>Rust stdlib: Option<br />
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">https://doc.rust-lang.org/std/option/enum.Option.html</a>
</li>

<li>Module std::option<br />
<a href="https://doc.rust-lang.org/std/option/index.html">https://doc.rust-lang.org/std/option/index.html</a>
</li>

<li>Rust by example: option<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>Rust by example: if-let<br />
<a href="http://rustbyexample.com/flow_control/if_let.html">http://rustbyexample.com/flow_control/if_let.html</a>
</li>

<li>Rust by example: while let<br />
<a href="http://rustbyexample.com/flow_control/while_let.html">http://rustbyexample.com/flow_control/while_let.html</a>
</li>

<li>Rust by example: Option&lt;i32&gt;<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>An Overview of Macros in Rust<br />
<a href="http://words.steveklabnik.com/an-overview-of-macros-in-rust">http://words.steveklabnik.com/an-overview-of-macros-in-rust</a>
</li>

<li>A Practical Intro to Macros in Rust 1.0<br />
<a href="https://danielkeep.github.io/practical-intro-to-macros.html">https://danielkeep.github.io/practical-intro-to-macros.html</a>
</li>

<li>The Rust Programming Language: macros<br />
<a href="https://doc.rust-lang.org/beta/book/macros.html">https://doc.rust-lang.org/beta/book/macros.html</a>
</li>

<li>Rust by example: 15 macro_rules!<br />
<a href="http://rustbyexample.com/macros.html">http://rustbyexample.com/macros.html</a>
</li>

<li>Primitive Type isize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.isize.html">https://doc.rust-lang.org/nightly/std/primitive.isize.html</a>
</li>

<li>Primitive Type usize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">https://doc.rust-lang.org/nightly/std/primitive.usize.html</a>
</li>

<li>Primitive Type array<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.array.html">https://doc.rust-lang.org/nightly/std/primitive.array.html</a>
</li>

<li>Module std::slice<br />
<a href="https://doc.rust-lang.org/nightly/std/slice/">https://doc.rust-lang.org/nightly/std/slice/</a>
</li>

<li>Rust by Example: 2.3 Arrays and Slices<br />
<a href="http://rustbyexample.com/primitives/array.html">http://rustbyexample.com/primitives/array.html</a>
</li>

<li>What is the difference between Slice and Array (stackoverflow)<br />
<a href="http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array">http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array</a>
</li>

<li>Learning Rust With Entirely Too Many Linked Lists<br />
<a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/">http://cglab.ca/~abeinges/blah/too-many-lists/book/</a>
</li>

<li>Testcase: linked list<br />
<a href="http://rustbyexample.com/custom_types/enum/testcase_linked_list.html">http://rustbyexample.com/custom_types/enum/testcase_linked_list.html</a>
</li>

<li>Operators and Overloading<br />
<a href="https://doc.rust-lang.org/book/operators-and-overloading.html">https://doc.rust-lang.org/book/operators-and-overloading.html</a>
</li>

<li>Module std::ops<br />
<a href="https://doc.rust-lang.org/std/ops/index.html">https://doc.rust-lang.org/std/ops/index.html</a>
</li>

<li>Module std::cmp<br />
<a href="https://doc.rust-lang.org/std/cmp/index.html">https://doc.rust-lang.org/std/cmp/index.html</a>
</li>

<li>Trait std::ops::Add<br />
<a href="https://doc.rust-lang.org/stable/std/ops/trait.Add.html">https://doc.rust-lang.org/stable/std/ops/trait.Add.html</a>
</li>

<li>Trait std::ops::AddAssign<br />
<a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html">https://doc.rust-lang.org/std/ops/trait.AddAssign.html</a>
</li>

<li>Trait std::ops::Drop<br />
<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">https://doc.rust-lang.org/std/ops/trait.Drop.html</a>
</li>

<li>Trait std::cmp::Eq<br />
<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">https://doc.rust-lang.org/std/cmp/trait.Eq.html</a>
</li>

<li>Struct std::boxed::Box<br />
<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">https://doc.rust-lang.org/std/boxed/struct.Box.html</a>
</li>

<li>Explore the ownership system in Rust<br />
<a href="https://nercury.github.io/rust/guide/2015/01/19/ownership.html">https://nercury.github.io/rust/guide/2015/01/19/ownership.html</a>
</li>

<li>Rust's ownership and move semantic<br/>
<a href="http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics">http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics</a>
</li>

<li>Trait std::marker::Copy<br/>
<a href="https://doc.rust-lang.org/stable/std/marker/trait.Copy.html">https://doc.rust-lang.org/stable/std/marker/trait.Copy.html</a>
</li>

<li>Trait std::clone::Clone<br />
<a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html">https://doc.rust-lang.org/stable/std/clone/trait.Clone.html</a>
</li>

<li>The Stack and the Heap<br />
<a href="https://doc.rust-lang.org/book/the-stack-and-the-heap.html">https://doc.rust-lang.org/book/the-stack-and-the-heap.html</a>
</li>

<li>Rust Compare: Pointers &amp; References<br />
<a href="http://www.rust-compare.com/site/pointers.html">http://www.rust-compare.com/site/pointers.html</a>
</li>

<li>Rust Compare: Parameters<br />
<a href="http://www.rust-compare.com/site/params.html">http://www.rust-compare.com/site/params.html</a>
</li>

<li>Why does this compile? Automatic dereferencing?<br />
<a href="https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183">https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183</a>
</li>

<li>Understanding Pointers, Ownership, and Lifetimes in Rust<br />
<a href="http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html">http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html</a>
</li>

<li>Rust lang series episode #25 — pointers (#rust-series)<br />
<a href="https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series">https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series</a>
</li>

<li>Rust - home page<br />
<a href="https://www.rust-lang.org/en-US/">https://www.rust-lang.org/en-US/</a>
</li>

<li>Rust - Frequently Asked Questions<br />
<a href="https://www.rust-lang.org/en-US/faq.html">https://www.rust-lang.org/en-US/faq.html</a>
</li>

<li>Destructuring and Pattern Matching<br />
<a href="https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/">https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/</a>
</li>

<li>The Rust Programming Language<br />
<a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>
</li>

<li>Rust (programming language)<br />
<a href="https://en.wikipedia.org/wiki/Rust_%28programming_language%29">https://en.wikipedia.org/wiki/Rust_%28programming_language%29</a>
</li>

<li>Go - home page<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>Stack Overflow - Most Loved, Dreaded, and Wanted language<br />
<a href="https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted">https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted</a>
</li>

<li>Rust vs Go (dva roky staré hodnocení, od té doby došlo k posunům v obou jazycích)<br />
<a href="http://jaredforsyth.com/2014/03/22/rust-vs-go/">http://jaredforsyth.com/2014/03/22/rust-vs-go/</a>
</li>

<li>Rust vs Go: My experience<br />
<a href="https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/">https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/</a>
</li>

<li>Friends of Rust (Organizations running Rust in production)<br />
<a href="https://www.rust-lang.org/en-US/friends.html">https://www.rust-lang.org/en-US/friends.html</a>
</li>

<li>Rust programs versus C++ g++<br />
<a href="https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp">https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp</a>
</li>

<li>Další benchmarky (nejedná se o reálné příklady &bdquo;ze života&ldquo;)<br />
<a href="https://github.com/kostya/benchmarks">https://github.com/kostya/benchmarks</a>
</li>

<li>Go na Redditu<br />
<a href="https://www.reddit.com/r/golang/">https://www.reddit.com/r/golang/</a>
</li>

<li>Rust vs. Go<br />
<a href="http://vschart.com/compare/rust/vs/go-language">http://vschart.com/compare/rust/vs/go-language</a>
</li>

<li>Abstraction without overhead: traits in Rust<br />
<a href="https://blog.rust-lang.org/2015/05/11/traits.html">https://blog.rust-lang.org/2015/05/11/traits.html</a>
</li>

<li>Method Syntax<br />
<a href="https://doc.rust-lang.org/book/method-syntax.html">https://doc.rust-lang.org/book/method-syntax.html</a>
</li>

<li>Traits in Rust<br />
<a href="https://doc.rust-lang.org/book/traits.html">https://doc.rust-lang.org/book/traits.html</a>
</li>

<li>Functional Programming in Rust - Part 1 : Function Abstraction<br />
<a href="http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/">http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/</a>
</li>

<li>Of the emerging systems languages Rust, D, Go and Nim, which is the strongest language and why?<br />
<a href="https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why">https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why</a>
</li>

<li>Chytré ukazatele (moderní verze jazyka C++) [MSDN]<br />
<a href="https://msdn.microsoft.com/cs-cz/library/hh279674.aspx">https://msdn.microsoft.com/cs-cz/library/hh279674.aspx</a>
</li>

<li>UTF-8 Everywhere<br />
<a href="http://utf8everywhere.org/">http://utf8everywhere.org/</a>
</li>

<li>Rust by Example<br />
<a href="http://rustbyexample.com/">http://rustbyexample.com/</a>
</li>

<li>Rust oficiálně ve Fedoře<br />
<a href="https://mojefedora.cz/rust-oficialne-ve-fedore/">https://mojefedora.cz/rust-oficialne-ve-fedore/</a>
</li>

<li>Resource acquisition is initialization<br />
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization</a>
</li>

<li>TIOBE index (October 2016)<br />
<a href="http://www.tiobe.com/tiobe-index/">http://www.tiobe.com/tiobe-index/</a>
</li>

<li>Porovnání Go, D a Rustu na OpenHubu:<br />
<a href="https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits">https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits</a>
</li>

<li>String Types in Rust<br />
<a href="http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/">http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/</a>
</li>

<li>Trait (computer programming)<br />
<a href="https://en.wikipedia.org/wiki/Trait_%28computer_programming%29">https://en.wikipedia.org/wiki/Trait_%28computer_programming%29</a>
</li>

<li>Type inference<br />
<a href="https://en.wikipedia.org/wiki/Type_inference">https://en.wikipedia.org/wiki/Type_inference</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

