<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Užitečné funkce a makra ze standardní knihovny Rustu</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Užitečné funkce a makra ze standardní knihovny Rustu</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Dnešní část seriálu o programovacím jazyku Rust bude oddechová, protože se v&nbsp;ní budeme zabývat některými užitečnými funkcemi a makry dostupnými ze standardní knihovny Rustu. Popíšeme si formátování vypisovaných zpráv, práci s&nbsp;proměnnými prostředí a taktéž se způsobem zpracování argumentů předaných na příkazovém řádku.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Základní a alternativní formátování celočíselných hodnot</a></p>
<p><a href="#k02">2. Šířka vypisovaných hodnot</a></p>
<p><a href="#k03">3. Zarovnání hodnot: doleva, doprava, vycentrování</a></p>
<p><a href="#k04">4. Výplň místa specifikovaným znakem</a></p>
<p><a href="#k05">5. Vytištění znaménka a tisk počátečních nul</a></p>
<p><a href="#k06">6. Nastavení přesnosti výpisu hodnot s&nbsp;plovoucí řádovou čárkou</a></p>
<p><a href="#k07">7. Řízení šířky a přesnosti s&nbsp;využitím nepovinných argumentů</a></p>
<p><a href="#k08">8. Celočíselné primitivní datové typy &ndash; základní funkce a metody</a></p>
<p><a href="#k09">9. Prohození bajtů ve slovech, konverze mezi little a big endian</a></p>
<p><a href="#k10">10. Bitové rotace a posuny celočíselných hodnot</a></p>
<p><a href="#k11">11. Zjištění atributů hodnot s&nbsp;plovoucí řádovou čárkou</a></p>
<p><a href="#k12">12. Proměnné prostředí vyhodnocované v&nbsp;době překladu</a></p>
<p><a href="#k13">13. Proměnné prostředí vyhodnocované při běhu aplikace</a></p>
<p><a href="#k14">14. Přečtení argumentů předaných na příkazové řádce</a></p>
<p><a href="#k15">15. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k16">16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Základní formátování celočíselných hodnot</h2>

<p>V&nbsp;programovacím jazyku Rust mají vývojáři k&nbsp;dispozici velmi
užitečné makro nazvané <strong>format!</strong>, které je možné použít pro
převod prakticky libovolných hodnot na řetězec s&nbsp;možností specifikace
způsobu formátování. Toto makro lze použít buď přímo nebo nepřímo v&nbsp;dalším
makru pojmenovaném <strong>println!</strong>, které již důvěrně známe
z&nbsp;předchozích částí tohoto seriálu. Toto makro používá stejný způsob
zápisu formátovacího řetězce, pouze se po výpisu výsledného textu na standardní
výstup navíc provede přidání znaku pro konec řádku (provede se
odřádkování).</p>

<p>Formátovací řetězec se zapisuje způsobem, který se poněkud odlišuje od
céčkovské funkce <strong>printf</strong>. Nejprve si ukažme, jakým způsobem je
možné zvolit základ číselné soustavy při převodu celého čísla (se znaménkem či
bez znaménka) na řetězec. Ve výchozím nastavení se použije desítková soustava,
lze však zvolit i soustavu osmičkovou, hexadecimální (s&nbsp;malými či velkými
písmeny pro cifry A až F) a nově taktéž soustavu binární. Každému číslu, které
se má objevit ve výstupním řetězci/formátované zprávě, odpovídá obsah jedné
dvojice složených závorek <strong>{}</strong> (pokud jsou závorky prázdné,
odpovídá to výchozímu formátování a použití desítkové soustavy):</p>

<pre>
fn main() {
    let value = 42;
&nbsp;
    println!("<strong>{}</strong>", value);
    println!("0<strong>{:o}</strong>", value);
    println!("0x<strong>{:x}</strong>", value);
    println!("0x<strong>{:X}</strong>", value);
    println!("0b<strong>{:b}</strong>", value);
}
</pre>

<p>Zpráva vypsaná po překladu a spuštění příkladu:</p>

<pre>
42
052
0x2a
0x2A
0b101010
</pre>

<p>Existuje i alternativní forma výpisu, v&nbsp;níž se do výsledného řetězce
automaticky přidají i prefixy číselné soustavy (0o, 0x, 0b). Alternativní forma
vyžaduje použití znaku # před specifikací číselné soustavy:</p>

<pre>
fn main() {
    let value = 42;
&nbsp;
    println!("<strong>{}</strong>", value);
    println!("<strong>{:#o}</strong>", value);
    println!("<strong>{:#x}</strong>", value);
    println!("<strong>{:#X}</strong>", value);
    println!("<strong>{:#b}</strong>", value);
}
</pre>

<p>Zpráva vypsaná po překladu a spuštění příkladu:</p>

<pre>
42
0o52
0x2a
0x2A
0b101010
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Šířka vypisovaných hodnot</h2>

<p>Specifikovat je samozřejmě možné i šířku vypisovaných hodnot, ovšem
s&nbsp;tím, že pokud je nutné hodnotu reprezentovat větším počtem znaků, než je
zadaná šířka, bude se šířka ignorovat; viz druhý řádek (znak roury je zde
použit jen pro vizuální zvýraznění šířky řetězce a nemá zde žádný specifický
význam):</p>

<pre>
fn main() {
    let value = 42;
&nbsp;
    println!("<strong>|{}|</strong>", value);
    println!("<strong>|{:1}|</strong>", value);
    println!("<strong>|{:10}|</strong>", value);
    println!("<strong>|{:20}|</strong>", value);
}
</pre>

<p>Zpráva vypsaná po překladu a spuštění příkladu:</p>

<pre>
|42|
|42|
|        42|
|                  42|
</pre>

<p>Šířku lze samozřejmě kombinovat se specifikací základu číselné soustavy, a
to takto:</p>

<pre>
fn main() {
    let value = 42;
&nbsp;
    println!("|{}|", value);
    println!("|{:1b}|", value);
    println!("|{:10b}|", value);
    println!("|{:20b}|", value);
}
</pre>

<p>Zpráva vypsaná po překladu a spuštění příkladu:</p>

<pre>
|42|
|101010|
|    101010|
|              101010|
</pre>

<p>Makrem <strong>println!</strong> je samozřejmě možné naformátovat a vypsat
více hodnot:</p>

<pre>
fn main() {
    let value1 = 42;
    let value2 = 8080;
    println!("|{:10}|{:10}|", value1, value2);
}
</pre>

<p>Zpráva vypsaná po překladu a spuštění příkladu:</p>

<pre>
|        42|      8080|
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zarovnání hodnot: doleva, doprava, vycentrování</h2>

<p>V&nbsp;případě, že je hodnota naformátována na menší počet znaků, než by
odpovídalo specifikaci šířky, lze zvolit způsob zarovnání. Podporováno je
zarovnání doprava (znak &gt;), doleva (znak &lt;) a na střed (znak ^),
samozřejmě s&nbsp;tím, že zarovnání na střed nemusí být přesné (lichý počet
znaků versus sudá hodnota zarovnání a naopak):</p>

<pre>
fn main() {
    let value = 42;
&nbsp;
    println!("|<strong>{}</strong>|", value);
    println!("|<strong>{:20}</strong>|", value);
    println!("|<strong>{:&gt;20}</strong>|", value);
    println!("|<strong>{:&lt;20}</strong>|", value);
    println!("|<strong>{:^20}</strong>|", value);
}
</pre>

<p>Zpráva vypsaná po překladu a spuštění příkladu:</p>

<pre>
|42|
|<strong>                  42</strong>|
|                  42|
|42                  |
|         42         |
</pre>

<p>Povšimněte si, že výchozí zarovnání numerických hodnot je doprava (druhý
zvýrazněný řádek výpisu). Zkusme si však příklad upravit tak, že se namísto
celočíselné hodnoty bude formátovat řetězec:</p>

<pre>
fn main() {
    let str = "hello";
&nbsp;
    println!("|<strong>{}</strong>|", str);
    println!("|<strong>{:20}</strong>|", str);
    println!("|<strong>{:&gt;20}</strong>|", str);
    println!("|<strong>{:&lt;20}</strong>|", str);
    println!("|<strong>{:^20}</strong>|", str);
}
</pre>

<p>Na druhém řádku je patrné, že implicitní zarovnání řetězců je na levý okraj:</p>

<pre>
|hello|
|<strong>hello               </strong>|
|               hello|
|hello               |
|       hello        |
</pre>

<p>Explicitní určení zarovnání samozřejmě funguje stejně v&nbsp;obou
případech, viz poslední tři řádky výpisu.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Výplň místa specifikovaným znakem</h2>

<p>V&nbsp;některých případech může být užitečné použít při formátování výstupu
namísto mezer odlišné znaky. I tato možnost je v&nbsp;programovacím jazyku Rust
podporována, což je patrné z&nbsp;následujícího příkladu, v&nbsp;němž u
numerických hodnot používáme pro výplň tečky a u řetězců podtržítka:</p>

<pre>
fn main() {
    let value = 42;
    println!("|{}|", value);
    println!("|{:10}|", value);
    println!("|{:.&gt;10}|", value);
    println!("|{:.&lt;10}|", value);
    println!("|{:.^10}|", value);
&nbsp;
    println!("")
&nbsp;
    let str = "hello";
    println!("|{}|", str);
    println!("|{:20}|", str);
    println!("|{:_&gt;20}|", str);
    println!("|{:_&lt;20}|", str);
    println!("|{:_^20}|", str);
}
</pre>

<p>Zpráva vypsaná po překladu a spuštění příkladu:</p>

<pre>
|42|
|        42|
|........42|
|42........|
|....42....|
&nbsp;
|hello|
|hello               |
|_______________hello|
|hello_______________|
|_______hello________|
</pre>

<p>Další způsob použití:</p>

<pre>
fn main() {
    for i in 0..16 {
        println!("|{:.&gt;10}|", 1 &lt;&lt; i);
    }
}
</pre>

<p>Zpráva vypsaná po překladu a spuštění příkladu:</p>

<pre>
|.........1|
|.........2|
|.........4|
|.........8|
|........16|
|........32|
|........64|
|.......128|
|.......256|
|.......512|
|......1024|
|......2048|
|......4096|
|......8192|
|.....16384|
|.....32768|
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Vytištění znaménka a tisk počátečních nul</h2>

<p>Makra <strong>format!</strong> a <strong>println!</strong> rozeznávají ve
formátovacím řetězci i znak +, kterým se vyžaduje explicitní výpis znaménka
celočíselné hodnoty, a to i ve chvíli, kdy je hodnota kladná. Znak - je taktéž
možné použít, ale prozatím se ignoruje, tj.&nbsp;nemá žádný speciální význam
(na rozdíl od <strong>printf</strong> v&nbsp;céčku). Použití znaků + a - je
jednoduché:</p>

<pre>
fn main() {
    let value1 =  42;
    let value2 = -42;
&nbsp;
    println!("|<strong>{}</strong>|", value1);
    println!("|<strong>{:-10}</strong>|", value1);
    println!("|<strong>{:+10}</strong>|", value1);
    println!("|<strong>{}</strong>|", value2);
    println!("|<strong>{:-10}</strong>|", value2);
    println!("|<strong>{:+10}</strong>|", value2);
}
</pre>

<p>Zpráva vypsaná po překladu a spuštění příkladu:</p>

<pre>
|42|
|        42|
|       +42|
|-42|
|       -42|
|       -42|
</pre>

<p>Pokud je nutné do výpisu naformátovaných celočíselných hodnot doplnit nuly
(ty nemění význam vypsané hodnoty), není nic jednoduššího než použít znak 0
před uvedením požadované šířky výpisu:</p>

<pre>
fn main() {
    let value1 =  42;
    let value2 = -42;
&nbsp;
    println!("|<strong>{:-010}</strong>|", value1);
    println!("|<strong>{:+010}</strong>|", value1);
    println!("|<strong>{:-010}</strong>|", value2);
    println!("|<strong>{:+010}</strong>|", value2);
}
</pre>

<p>Zpráva vypsaná po překladu a spuštění příkladu:</p>

<pre>
|0000000042|
|+000000042|
|-000000042|
|-000000042|
</pre>

<p>Totéž platí i pro další základy číselných soustav:</p>

<pre>
fn main() {
    for i in 0..16 {
        println!("<strong>{:08b}</strong>", i);
    }
}
</pre>

<p>Zpráva vypsaná po překladu a spuštění příkladu:</p>

<pre>
00000000
00000001
00000010
00000011
00000100
00000101
00000110
00000111
00001000
00001001
00001010
00001011
00001100
00001101
00001110
00001111
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Nastavení přesnosti výpisu hodnot s&nbsp;plovoucí řádovou čárkou</h2>

<p>U hodnot s&nbsp;plovoucí řádovou čárkou je možné explicitně zvolit počet
číslic za čárkou/tečkou, a to způsobem, který se používal již v&nbsp;céčku,
tj.&nbsp;uvede se celková šířka čísla ve znacích a za tečkou pak počet
desetinných míst. Opět je možná kombinace se specifikací zarovnání:</p>

<pre>
fn main() {
    let value = 42.5;
&nbsp;
    println!("<strong>{}</strong>",        value);
    println!("<strong>{:10}</strong>",     value);
    println!("<strong>{:10.4}</strong>",   value);
    println!("<strong>{:+10}</strong>",    value);
    println!("<strong>{:+10.4}</strong>",  value);
    println!("<strong>{:^+10}</strong>",   value);
    println!("<strong>{:^+10.4}</strong>", value);
}
</pre>

<p>Zpráva vypsaná po překladu a spuštění příkladu:</p>

<pre>
42.5
      42.5
   42.5000
     +42.5
  +42.5000
  +42.5   
 +42.5000 
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Řízení šířky a přesnosti s&nbsp;využitím nepovinných argumentů</h2>

<p>Požadovaná šířka ve formátovacím řetězci se alternativně zadává i
specifikací jména nepovinného parametru makra <strong>format!</strong> a
<strong>println!</strong>. V&nbsp;následujícím příkladu je za znakem : namísto
číselné hodnoty šířky specifikováno jméno <strong>width</strong> (ukončené
dolarem), které musí odpovídat pojmenovanému parametru. Pokud je nutné použít
zarovnání, zapíše se znak pro zarovnání před jméno parametru:</p>

<pre>
fn main() {
    let value = 42.5;
&nbsp;
    for i in 1..20 {
        println!("|<strong>{:width$}</strong>|", value, <strong>width</strong>=i);
    }
&nbsp;
    for i in 1..20 {
        println!("|<strong>{:^width$}</strong>|", value, <strong>width</strong>=i);
    }
}
</pre>

<p>Zpráva vypsaná po překladu a spuštění příkladu:</p>

<pre>
|42.5|
|42.5|
|42.5|
|42.5|
| 42.5|
|  42.5|
|   42.5|
|    42.5|
|     42.5|
|      42.5|
|       42.5|
|        42.5|
|         42.5|
|          42.5|
|           42.5|
|            42.5|
|             42.5|
|              42.5|
|               42.5|
|42.5|
|42.5|
|42.5|
|42.5|
|42.5 |
| 42.5 |
| 42.5  |
|  42.5  |
|  42.5   |
|   42.5   |
|   42.5    |
|    42.5    |
|    42.5     |
|     42.5     |
|     42.5      |
|      42.5      |
|      42.5       |
|       42.5       |
|       42.5        |
</pre>

<p>Zkusme si vytvořit složitější příklad, v&nbsp;němž se mění jak šířka
výsledného čísla v&nbsp;řetězci, tak i počet desetinných míst. Povšimněte si,
že ve formátovacím řetězci se jména nepovinných parametrů vždy ukončují znakem
dolaru:</p>

<pre>
fn main() {
    let value = 0.5;
&nbsp;
    for w in 1 .. 11 {
        println!("width={}", w);
        for p in 1 .. (w-1) {
            println!("|{:<strong>width</strong>$.<strong>precision</strong>$}|", value, <strong>width</strong>=w, <strong>precision</strong>=p);
        }
        println!("");
    }
}
</pre>

<p>Zpráva vypsaná po překladu a spuštění příkladu:</p>

<pre>
width=1
&nbsp;
width=2
&nbsp;
width=3
|0.5|
&nbsp;
width=4
| 0.5|
|0.50|
&nbsp;
width=5
|  0.5|
| 0.50|
|0.500|
&nbsp;
width=6
|   0.5|
|  0.50|
| 0.500|
|0.5000|
&nbsp;
width=7
|    0.5|
|   0.50|
|  0.500|
| 0.5000|
|0.50000|
&nbsp;
width=8
|     0.5|
|    0.50|
|   0.500|
|  0.5000|
| 0.50000|
|0.500000|
&nbsp;
width=9
|      0.5|
|     0.50|
|    0.500|
|   0.5000|
|  0.50000|
| 0.500000|
|0.5000000|
&nbsp;
width=10
|       0.5|
|      0.50|
|     0.500|
|    0.5000|
|   0.50000|
|  0.500000|
| 0.5000000|
|0.50000000|
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Celočíselné primitivní datové typy &ndash; základní funkce a metody</h2>

<p>Další oblastí, kterou se dnes budeme zabývat, jsou metody dostupné pro
vybrané primitivní datové typy. Začneme celočíselnými hodnotami, pro něž
existují metody nazvané <strong>min_value()</strong> a
<strong>max_value()</strong> vracející minimální a maximální hodnotu
reprezentovatelnou daným celočíselným datovým typem. V&nbsp;následujícím
příkladu se minimální a maximální hodnoty vypíšou pro všech osm celočíselných
typů:</p>

<pre>
fn main() {
    println!("Type:      {:&gt;22} {:&gt;22} {:&gt;22} {:&gt;22} {:&gt;22} {:&gt;22} {:&gt;22} {:&gt;22}",
             "i8",
             "i16",
             "i32",
             "i64",
             "u8",
             "u16",
             "u32",
             "u64");
    println!("min_value: {:&gt;22} {:&gt;22} {:&gt;22} {:&gt;22} {:&gt;22} {:&gt;22} {:&gt;22} {:&gt;22}",
             i8::min_value(),
             i16::min_value(),
             i32::min_value(),
             i64::min_value(),
             u8::min_value(),
             u16::min_value(),
             u32::min_value(),
             u64::min_value());
    println!("max_value: {:&gt;22} {:&gt;22} {:&gt;22} {:&gt;22} {:&gt;22} {:&gt;22} {:&gt;22} {:&gt;22}",
             i8::max_value(),
             i16::max_value(),
             i32::max_value(),
             i64::max_value(),
             u8::max_value(),
             u16::max_value(),
             u32::max_value(),
             u64::max_value());
}
</pre>

<p>Vypsaná tabulka odpovídá předpokládanému výsledku:</p>

<pre>
Type:                i8          i16          i32                    i64           u8          u16          u32                    u64
min_value:         -128       -32768  -2147483648   -9223372036854775808            0            0            0                      0
max_value:          127        32767   2147483647    9223372036854775807          255        65535   4294967295   18446744073709551615
</pre>

<p>(některé sloupce jsou pro přehlednost zmenšeny)</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Prohození bajtů ve slovech, konverze mezi little a big endian</h2>

<p>Mezi další užitečné metody u primitivních datových typů patří metoda
<strong>swap_bytes()</strong> sloužící pro prohození všech bajtů ve slově
(kromě u8 a i8) a dále metody <strong>from_le()</strong>,
<strong>from_be()</strong>, <strong>to_le()</strong> a
<strong>to_be()</strong>, které lze použít pro konverzi mezi nativní
reprezentací čísla a formátem <i>little endian</i> a <i>big endiann</i>. Podle
použité platformy mohou dvě z&nbsp;těchto funkcí vracet původní hodnotu.
Příkladem může být platforma i386, u níž funkce <strong>from_le()</strong>
vrátí původní číslo. Ostatně můžeme si to vyzkoušet:</p>

<pre>
fn main() {
    let value:u32 = 0xcafebabe;

    println!("{:x}", value);
    println!("{:x}", value.swap_bytes());
    println!("{:x}", u32::from_le(value));
    println!("{:x}", u32::from_be(value));
}
</pre>

<p>Na platformě i386 či x86-64 by se mělo vypsat:</p>

<pre>
cafebabe
bebafeca
cafebabe
bebafeca
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Bitové rotace a posuny celočíselných hodnot</h2>

<p>Zatímco bitové posuny jsou podporovány samotným jazykem díky operátorům
&lt;&lt; a &gt;&gt;, bitové rotace je nutné provést metodami nazvanými
<strong>rotate_left()</strong> a <strong>rotate_right()</strong>. Pro lepší
ilustraci budeme původní hodnotu, posunutou hodnotu i zrotovanou hodnotu
vypisovat s&nbsp;formátováním 032b, tedy 32 bitů zarovnaných zleva nulami:</p>

<pre>
fn main() {
    let value:u32 = 3;
&nbsp;
    println!("{:032b}", value);
&nbsp;
    println!("");
    for rot in 0..10 {
        println!("{:032b}", value.rotate_left(rot));
    }
&nbsp;
    println!("");
    for rot in 0..10 {
        println!("{:032b}", value.rotate_right(rot));
    }
&nbsp;
    println!("");
    for rot in 0..10 {
        println!("{:032b}", value &lt;&lt; rot);
    }
&nbsp;
    println!("");
    for rot in 0..10 {
        println!("{:032b}", value &gt;&gt; rot);
    }
}
</pre>

<p>Zpráva vypsaná po překladu a spuštění příkladu:</p>

<pre>
00000000000000000000000000000011
&nbsp;
00000000000000000000000000000011
00000000000000000000000000000110
00000000000000000000000000001100
00000000000000000000000000011000
00000000000000000000000000110000
00000000000000000000000001100000
00000000000000000000000011000000
00000000000000000000000110000000
00000000000000000000001100000000
00000000000000000000011000000000
&nbsp;
00000000000000000000000000000011
10000000000000000000000000000001
11000000000000000000000000000000
01100000000000000000000000000000
00110000000000000000000000000000
00011000000000000000000000000000
00001100000000000000000000000000
00000110000000000000000000000000
00000011000000000000000000000000
00000001100000000000000000000000
&nbsp;
00000000000000000000000000000011
00000000000000000000000000000110
00000000000000000000000000001100
00000000000000000000000000011000
00000000000000000000000000110000
00000000000000000000000001100000
00000000000000000000000011000000
00000000000000000000000110000000
00000000000000000000001100000000
00000000000000000000011000000000
&nbsp;
00000000000000000000000000000011
00000000000000000000000000000001
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Zjištění atributů hodnot s&nbsp;plovoucí řádovou čárkou</h2>

<p>Mnoho potenciálně důležitých informací je možné získat i pro primitivní
datové typy s&nbsp;plovoucí řádovou čárkou, konkrétně pro typy
&bdquo;f32&ldquo; a &bdquo;f64&ldquo;. Především jsou dostupné informace o
maximální hodnotě (která ještě není považována za nekonečno), o minimální
hodnotě, o nejmenší kladné nenulové hodnotě a taktéž o způsobu reprezentace
čísla (počet číslic, počet bitů pro uložení mantisy, největší a nejmenší
exponent při dvojkovém i desítkovém vyjádření, radix atd.). Nesmíme zapomenout
ani na speciální hodnoty: kladné a záporné nekonečno a NaN:</p>

<pre>
use std::f32;
&nbsp;
fn main() {
    println!("Max          {}",    f32::MAX);
    println!("Min          {}",    f32::MIN);
    println!("Min pos      {}",    f32::MIN_POSITIVE);
    println!("");
    println!("+Infinity    {}",    f32::INFINITY);
    println!("-Infinity    {}",    f32::NEG_INFINITY);
    println!("NaN          {}",    f32::NAN);
    println!("");
    println!("Digits       {}",    f32::DIGITS);
    println!("Max exponent 10^{}", f32::MAX_10_EXP);
    println!("Min exponent 10^{}", f32::MIN_10_EXP);
    println!("Epsilon      {}",    f32::EPSILON);
    println!("");
    println!("Radix        {}",    f32::RADIX);
    println!("Digits       {}",    f32::MANTISSA_DIGITS);
    println!("Max exponent 2^{}",  f32::MAX_EXP);
    println!("Min exponent 2^{}",  f32::MIN_EXP);
}
</pre>

<p>Zpráva vypsaná po překladu a spuštění příkladu:</p>

<pre>
Max          340282350000000000000000000000000000000
Min          -340282350000000000000000000000000000000
Min pos      0.000000000000000000000000000000000000011754944
&nbsp;
+Infinity    inf
-Infinity    -inf
NaN          NaN
&nbsp;
Digits       6
Max exponent 10^38
Min exponent 10^-37
Epsilon      0.00000011920929
&nbsp;
Radix        2
Digits       24
Max exponent 2^128
Min exponent 2^-125
</pre>

<p>Stejný příklad lze upravit pro typ &bdquo;f64&ldquo;:</p>

<pre>
use std::f64;
&nbsp;
fn main() {
    println!("Max          {}",    f64::MAX);
    println!("Min          {}",    f64::MIN);
    println!("Min pos      {}",    f64::MIN_POSITIVE);
    println!("");
    println!("+Infinity    {}",    f64::INFINITY);
    println!("-Infinity    {}",    f64::NEG_INFINITY);
    println!("NaN          {}",    f64::NAN);
    println!("");
    println!("Digits       {}",    f64::DIGITS);
    println!("Max exponent 10^{}", f64::MAX_10_EXP);
    println!("Min exponent 10^{}", f64::MIN_10_EXP);
    println!("Epsilon      {}",    f64::EPSILON);
    println!("");
    println!("Radix        {}",    f64::RADIX);
    println!("Digits       {}",    f64::MANTISSA_DIGITS);
    println!("Max exponent 2^{}",  f64::MAX_EXP);
    println!("Min exponent 2^{}",  f64::MIN_EXP);
}
</pre>

<p>Zpráva vypsaná po překladu a spuštění příkladu:</p>

<pre>
Max          179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
Min          -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
Min pos      0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000022250738585072014
&nbsp;
+Infinity    inf
-Infinity    -inf
NaN          NaN
&nbsp;
Digits       15
Max exponent 10^308
Min exponent 10^-307
Epsilon      0.0000000000000002220446049250313
&nbsp;
Radix        2
Digits       53
Max exponent 2^1024
Min exponent 2^-1021
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Proměnné prostředí vyhodnocované v&nbsp;době překladu</h2>

<p><i>V&nbsp;době překladu</i> lze přistupovat k&nbsp;proměnným prostředí
použitím makra <strong>env!</strong>. Překladač si v&nbsp;tomto případě hlídá,
zda proměnná prostředí existuje a pokud tomu tak není, vypíše chybové hlášení.
Hodnota proměnné je přečtena a zapsána do výsledného souboru, tj.&nbsp;namísto
volání makra <strong>env!</strong> se bude ve výsledném kódu nacházet
konstantní řetězec:</p>

<pre>
fn main() {
    println!("PATH:    {}", env!("PATH"));
    println!("HOME:    {}", env!("HOME"));
    println!("DISPLAY: {}", env!("DISPLAY"));
}
</pre>

<p>Zpráva vypsaná po překladu a spuštění příkladu:</p>

<pre>
PATH:    /home/tester/.npm/bin:/home/tester/.npm/bin:/home/tester/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/home/tester/bin:/home/tester/bin
HOME:    /home/tester
DISPLAY: :0.0
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Proměnné prostředí vyhodnocované při běhu aplikace</h2>

<p>Při běhu programu (<i>runtime</i>) je samozřejmě taktéž možné přistupovat
k&nbsp;proměnným prostředí, dokonce je to ještě užitečnější, než
v&nbsp;příkladu předchozím. Ovšem v&nbsp;tomto případě se nepoužívá makro, ale
funkce <strong>env::var()</strong>. Tato funkce vrací typ
<strong>Result</strong> popsaný minule, takže lze snadno zjistit, zda proměnná
existuje či nikoli:</p>

<pre>
use std::env;
&nbsp;
fn print_env_var(name:&amp;str) {
    match env::var(name) {
        Ok(val) =&gt; println!("{}: {:?}", name, val),
        Err(e)  =&gt; println!("couldn't interpret {}: {}", name, e),
    }
}
&nbsp;
fn main() {
    print_env_var("PATH");
    print_env_var("HOME");
    print_env_var("DISPLAY");
    print_env_var("SPECIAL");
}
</pre>

<p>Zpráva vypsaná po překladu a spuštění příkladu:</p>

<pre>
PATH: "/home/tester/.npm/bin:/home/tester/.npm/bin:/home/tester/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/home/tester/bin:/home/tester/bin"
HOME: "/home/tester"
DISPLAY: ":0.0"
couldn't interpret SPECIAL: environment variable not found
</pre>

<p>Snadno lze získat i iterátor se všemi proměnnými prostředí. Iterace nad
jmény i hodnotami proměnných probíhá takto:</p>

<pre>
use std::env;
&nbsp;
fn main() {
    for (key, value) in env::vars() {
        println!("{}: {}", key, value);
    }
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Přečtení argumentů předaných na příkazové řádce</h2>

<p>Do funkce <strong>main</strong> se v&nbsp;programovacím jazyku Rust
nepředávají žádné parametry, takže pokud je zapotřebí přistupovat
k&nbsp;argumentům příkazové řádky, je nutné použít odlišný přístup. Ten spočívá
v&nbsp;použití iterátoru vráceného po zavolání <strong>env::args()</strong>.
Tento iterátor obsahuje všechny předané parametry a na prvním místě i jméno
souboru, který byl spuštěn:</p>

<pre>
use std::env;
&nbsp;
fn main() {
    for arg in <strong>env::args()</strong> {
        println!("{}", arg);
    }
}
</pre>

<p>Předchozí příklad po svém spuštění (se zadáním tří parametrů) vypíše:</p>

<pre>
<strong>./239_env_all_args foo bar baz</strong>
&nbsp;
./239_env_all_args
foo
bar
baz
</pre>

<p>V&nbsp;operačním systému Linux obsahuje první prvek iterátoru cestu ke
spouštěnému souboru. Tu získáme velmi snadno, jen nesmíme zapomenout na to, že
prvky vrácené iterátorem jsou typu <strong>Option</strong>, takže je nutné
použít metodu <strong>.unwrap()</strong>:</p>

<pre>
use std::env;
&nbsp;
fn main() {
    let exename = env::args().nth(0);
    let arguments = env::args().count();
&nbsp;
    println!("exename:   {}", exename.unwrap());
    println!("arguments: {}", arguments);
}
</pre>

<p>Předchozí příklad po svém spuštění (se zadáním tří parametrů) vypíše:</p>

<pre>
./240_env_exe_name foo bar baz
&nbsp;
exename:   ./240_env_exe_name
arguments: 4
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popisované demonstrační příklady byly, podobně jako ve všech
předchozích částech tohoto seriálu, uloženy do Git repositáře dostupného na
adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě bez nutnosti
klonovat celý repositář:</p>

<table>
<tr><th>Příklad</th><th>Odkaz</th></tr>
<tr><td>221_format_basic.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/221_format_basic.rs">https://github.com/tisnik/presentations/blob/master/rust/221_format_basic.rs</a></td></tr>
<tr><td>222_format_alternate_forms.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/222_format_alternate_forms.rs">https://github.com/tisnik/presentations/blob/master/rust/222_format_alternate_forms.rs</a></td></tr>
<tr><td>223_format_width_align1.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/223_format_width_align1.rs">https://github.com/tisnik/presentations/blob/master/rust/223_format_width_align1.rs</a></td></tr>
<tr><td>224_format_width_align2.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/224_format_width_align2.rs">https://github.com/tisnik/presentations/blob/master/rust/224_format_width_align2.rs</a></td></tr>
<tr><td>225_format_fill.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/225_format_fill.rs">https://github.com/tisnik/presentations/blob/master/rust/225_format_fill.rs</a></td></tr>
<tr><td>226_format_sign.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/226_format_sign.rs">https://github.com/tisnik/presentations/blob/master/rust/226_format_sign.rs</a></td></tr>
<tr><td>227_format_padding.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/227_format_padding.rs">https://github.com/tisnik/presentations/blob/master/rust/227_format_padding.rs</a></td></tr>
<tr><td>228_format_precision.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/228_format_precision.rs">https://github.com/tisnik/presentations/blob/master/rust/228_format_precision.rs</a></td></tr>
<tr><td>229_format_width_param.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/229_format_width_param.rs">https://github.com/tisnik/presentations/blob/master/rust/229_format_width_param.rs</a></td></tr>
<tr><td>230_format_width_precision_params.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/230_format_width_precision_params.rs">https://github.com/tisnik/presentations/blob/master/rust/230_format_width_precision_params.rs</a></td></tr>
<tr><td>231_integers.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/231_integers.rs">https://github.com/tisnik/presentations/blob/master/rust/231_integers.rs</a></td></tr>
<tr><td>232_integer_swaps.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/232_integer_swaps.rs">https://github.com/tisnik/presentations/blob/master/rust/232_integer_swaps.rs</a></td></tr>
<tr><td>233_integer_rot_shift.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/233_integer_rot_shift.rs">https://github.com/tisnik/presentations/blob/master/rust/233_integer_rot_shift.rs</a></td></tr>
<tr><td>234_floats.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/234_floats.rs">https://github.com/tisnik/presentations/blob/master/rust/234_floats.rs</a></td></tr>
<tr><td>235_doubles.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/235_doubles.rs">https://github.com/tisnik/presentations/blob/master/rust/235_doubles.rs</a></td></tr>
<tr><td>236_env_macro.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/236_env_macro.rs">https://github.com/tisnik/presentations/blob/master/rust/236_env_macro.rs</a></td></tr>
<tr><td>237_env_runtime.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/237_env_runtime.rs">https://github.com/tisnik/presentations/blob/master/rust/237_env_runtime.rs</a></td></tr>
<tr><td>238_env_all_vars.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/238_env_all_vars.rs">https://github.com/tisnik/presentations/blob/master/rust/238_env_all_vars.rs</a></td></tr>
<tr><td>239_env_all_args.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/239_env_all_args.rs">https://github.com/tisnik/presentations/blob/master/rust/239_env_all_args.rs</a></td></tr>
<tr><td>240_env_exe_name.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/240_env_exe_name.rs">https://github.com/tisnik/presentations/blob/master/rust/240_env_exe_name.rs</a></td></tr>
</table>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>Module std::fmt<br />
<a href="https://doc.rust-lang.org/std/fmt/">https://doc.rust-lang.org/std/fmt/</a>
</li>

<li>Macro std::println<br />
<a href="https://doc.rust-lang.org/std/macro.println.html">https://doc.rust-lang.org/std/macro.println.html</a>
</li>

<li>Enum std::result::Result<br />
<a href="https://doc.rust-lang.org/std/result/enum.Result.html">https://doc.rust-lang.org/std/result/enum.Result.html</a>
</li>

<li>Module std::result<br />
<a href="https://doc.rust-lang.org/std/result/">https://doc.rust-lang.org/std/result/</a>
</li>

<li>Result<br />
<a href="http://rustbyexample.com/std/result.html">http://rustbyexample.com/std/result.html</a>
</li>

<li>Rust stdlib: Option<br />
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">https://doc.rust-lang.org/std/option/enum.Option.html</a>
</li>

<li>Module std::option<br />
<a href="https://doc.rust-lang.org/std/option/index.html">https://doc.rust-lang.org/std/option/index.html</a>
</li>

<li>Rust by example: option<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>Rust by example: if-let<br />
<a href="http://rustbyexample.com/flow_control/if_let.html">http://rustbyexample.com/flow_control/if_let.html</a>
</li>

<li>Rust by example: while let<br />
<a href="http://rustbyexample.com/flow_control/while_let.html">http://rustbyexample.com/flow_control/while_let.html</a>
</li>

<li>Rust by example: Option&lt;i32&gt;<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>An Overview of Macros in Rust<br />
<a href="http://words.steveklabnik.com/an-overview-of-macros-in-rust">http://words.steveklabnik.com/an-overview-of-macros-in-rust</a>
</li>

<li>A Practical Intro to Macros in Rust 1.0<br />
<a href="https://danielkeep.github.io/practical-intro-to-macros.html">https://danielkeep.github.io/practical-intro-to-macros.html</a>
</li>

<li>The Rust Programming Language: macros<br />
<a href="https://doc.rust-lang.org/beta/book/macros.html">https://doc.rust-lang.org/beta/book/macros.html</a>
</li>

<li>Rust by example: 15 macro_rules!<br />
<a href="http://rustbyexample.com/macros.html">http://rustbyexample.com/macros.html</a>
</li>

<li>Module std::vec<br />
<a href="https://doc.rust-lang.org/nightly/std/vec/index.html">https://doc.rust-lang.org/nightly/std/vec/index.html</a>
</li>

<li>Primitive Type isize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.isize.html">https://doc.rust-lang.org/nightly/std/primitive.isize.html</a>
</li>

<li>Primitive Type usize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">https://doc.rust-lang.org/nightly/std/primitive.usize.html</a>
</li>

<li>Primitive Type array<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.array.html">https://doc.rust-lang.org/nightly/std/primitive.array.html</a>
</li>

<li>Module std::slice<br />
<a href="https://doc.rust-lang.org/nightly/std/slice/">https://doc.rust-lang.org/nightly/std/slice/</a>
</li>

<li>Rust by Example: 2.3 Arrays and Slices<br />
<a href="http://rustbyexample.com/primitives/array.html">http://rustbyexample.com/primitives/array.html</a>
</li>

<li>What is the difference between Slice and Array (stackoverflow)<br />
<a href="http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array">http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array</a>
</li>

<li>Learning Rust With Entirely Too Many Linked Lists<br />
<a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/">http://cglab.ca/~abeinges/blah/too-many-lists/book/</a>
</li>

<li>Testcase: linked list<br />
<a href="http://rustbyexample.com/custom_types/enum/testcase_linked_list.html">http://rustbyexample.com/custom_types/enum/testcase_linked_list.html</a>
</li>

<li>Operators and Overloading<br />
<a href="https://doc.rust-lang.org/book/operators-and-overloading.html">https://doc.rust-lang.org/book/operators-and-overloading.html</a>
</li>

<li>Module std::ops<br />
<a href="https://doc.rust-lang.org/std/ops/index.html">https://doc.rust-lang.org/std/ops/index.html</a>
</li>

<li>Module std::cmp<br />
<a href="https://doc.rust-lang.org/std/cmp/index.html">https://doc.rust-lang.org/std/cmp/index.html</a>
</li>

<li>Trait std::ops::Add<br />
<a href="https://doc.rust-lang.org/stable/std/ops/trait.Add.html">https://doc.rust-lang.org/stable/std/ops/trait.Add.html</a>
</li>

<li>Trait std::ops::AddAssign<br />
<a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html">https://doc.rust-lang.org/std/ops/trait.AddAssign.html</a>
</li>

<li>Trait std::ops::Drop<br />
<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">https://doc.rust-lang.org/std/ops/trait.Drop.html</a>
</li>

<li>Trait std::cmp::Eq<br />
<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">https://doc.rust-lang.org/std/cmp/trait.Eq.html</a>
</li>

<li>Struct std::boxed::Box<br />
<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">https://doc.rust-lang.org/std/boxed/struct.Box.html</a>
</li>

<li>Explore the ownership system in Rust<br />
<a href="https://nercury.github.io/rust/guide/2015/01/19/ownership.html">https://nercury.github.io/rust/guide/2015/01/19/ownership.html</a>
</li>

<li>Rust's ownership and move semantic<br/>
<a href="http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics">http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics</a>
</li>

<li>Trait std::marker::Copy<br/>
<a href="https://doc.rust-lang.org/stable/std/marker/trait.Copy.html">https://doc.rust-lang.org/stable/std/marker/trait.Copy.html</a>
</li>

<li>Trait std::clone::Clone<br />
<a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html">https://doc.rust-lang.org/stable/std/clone/trait.Clone.html</a>
</li>

<li>The Stack and the Heap<br />
<a href="https://doc.rust-lang.org/book/the-stack-and-the-heap.html">https://doc.rust-lang.org/book/the-stack-and-the-heap.html</a>
</li>

<li>Rust Compare: Pointers &amp; References<br />
<a href="http://www.rust-compare.com/site/pointers.html">http://www.rust-compare.com/site/pointers.html</a>
</li>

<li>Rust Compare: Parameters<br />
<a href="http://www.rust-compare.com/site/params.html">http://www.rust-compare.com/site/params.html</a>
</li>

<li>Why does this compile? Automatic dereferencing?<br />
<a href="https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183">https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183</a>
</li>

<li>Understanding Pointers, Ownership, and Lifetimes in Rust<br />
<a href="http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html">http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html</a>
</li>

<li>Rust lang series episode #25 — pointers (#rust-series)<br />
<a href="https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series">https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series</a>
</li>

<li>Rust - home page<br />
<a href="https://www.rust-lang.org/en-US/">https://www.rust-lang.org/en-US/</a>
</li>

<li>Rust - Frequently Asked Questions<br />
<a href="https://www.rust-lang.org/en-US/faq.html">https://www.rust-lang.org/en-US/faq.html</a>
</li>

<li>Destructuring and Pattern Matching<br />
<a href="https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/">https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/</a>
</li>

<li>The Rust Programming Language<br />
<a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>
</li>

<li>Rust (programming language)<br />
<a href="https://en.wikipedia.org/wiki/Rust_%28programming_language%29">https://en.wikipedia.org/wiki/Rust_%28programming_language%29</a>
</li>

<li>Go - home page<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>Stack Overflow - Most Loved, Dreaded, and Wanted language<br />
<a href="https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted">https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted</a>
</li>

<li>Rust vs Go (dva roky staré hodnocení, od té doby došlo k posunům v obou jazycích)<br />
<a href="http://jaredforsyth.com/2014/03/22/rust-vs-go/">http://jaredforsyth.com/2014/03/22/rust-vs-go/</a>
</li>

<li>Rust vs Go: My experience<br />
<a href="https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/">https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/</a>
</li>

<li>Friends of Rust (Organizations running Rust in production)<br />
<a href="https://www.rust-lang.org/en-US/friends.html">https://www.rust-lang.org/en-US/friends.html</a>
</li>

<li>Rust programs versus C++ g++<br />
<a href="https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp">https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp</a>
</li>

<li>Další benchmarky (nejedná se o reálné příklady &bdquo;ze života&ldquo;)<br />
<a href="https://github.com/kostya/benchmarks">https://github.com/kostya/benchmarks</a>
</li>

<li>Go na Redditu<br />
<a href="https://www.reddit.com/r/golang/">https://www.reddit.com/r/golang/</a>
</li>

<li>Rust vs. Go<br />
<a href="http://vschart.com/compare/rust/vs/go-language">http://vschart.com/compare/rust/vs/go-language</a>
</li>

<li>Abstraction without overhead: traits in Rust<br />
<a href="https://blog.rust-lang.org/2015/05/11/traits.html">https://blog.rust-lang.org/2015/05/11/traits.html</a>
</li>

<li>Method Syntax<br />
<a href="https://doc.rust-lang.org/book/method-syntax.html">https://doc.rust-lang.org/book/method-syntax.html</a>
</li>

<li>Traits in Rust<br />
<a href="https://doc.rust-lang.org/book/traits.html">https://doc.rust-lang.org/book/traits.html</a>
</li>

<li>Functional Programming in Rust - Part 1 : Function Abstraction<br />
<a href="http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/">http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/</a>
</li>

<li>Of the emerging systems languages Rust, D, Go and Nim, which is the strongest language and why?<br />
<a href="https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why">https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why</a>
</li>

<li>Chytré ukazatele (moderní verze jazyka C++) [MSDN]<br />
<a href="https://msdn.microsoft.com/cs-cz/library/hh279674.aspx">https://msdn.microsoft.com/cs-cz/library/hh279674.aspx</a>
</li>

<li>UTF-8 Everywhere<br />
<a href="http://utf8everywhere.org/">http://utf8everywhere.org/</a>
</li>

<li>Rust by Example<br />
<a href="http://rustbyexample.com/">http://rustbyexample.com/</a>
</li>

<li>Rust oficiálně ve Fedoře<br />
<a href="https://mojefedora.cz/rust-oficialne-ve-fedore/">https://mojefedora.cz/rust-oficialne-ve-fedore/</a>
</li>

<li>Resource acquisition is initialization<br />
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization</a>
</li>

<li>TIOBE index (October 2016)<br />
<a href="http://www.tiobe.com/tiobe-index/">http://www.tiobe.com/tiobe-index/</a>
</li>

<li>Porovnání Go, D a Rustu na OpenHubu:<br />
<a href="https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits">https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits</a>
</li>

<li>String Types in Rust<br />
<a href="http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/">http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/</a>
</li>

<li>Trait (computer programming)<br />
<a href="https://en.wikipedia.org/wiki/Trait_%28computer_programming%29">https://en.wikipedia.org/wiki/Trait_%28computer_programming%29</a>
</li>

<li>Type inference<br />
<a href="https://en.wikipedia.org/wiki/Type_inference">https://en.wikipedia.org/wiki/Type_inference</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

