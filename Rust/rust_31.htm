<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Rust: rozhraní mezi Rustem a Pythonem</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Rust: rozhraní mezi Rustem a Pythonem</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku o programovacím jazyku Rust si ukážeme, lze zdrojový kód Rustu přeložit do dynamické knihovny a jak se budou funkce Rustu volat z Pythonu. Při komunikaci mezi Rustem a Pythonem je samozřejmě nutné vyřešit několik problémů, o nichž se zmíníme.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyk Rust: rozhraní mezi Rustem a Pythonem</a></p>
<p><a href="#k02">2. Překlad zdrojového kódu Rustu do dynamické knihovny</a></p>
<p><a href="#k03">3. Vytvoření projektu pro překlad zdrojového kódu do dynamické knihovny</a></p>
<p><a href="#k04">4. Zdrojový kód funkce, která se přeloží do dynamické knihovny</a></p>
<p><a href="#k05">5. Zdrojový kód Pythonovského skriptu, který má dynamickou knihovnu využít</a></p>
<p><a href="#k06">6. Překlad projektu a pokus zavolání funkce z&nbsp;dynamické knihovny</a></p>
<p><a href="#k07">7. Name mangling a jeho důsledky</a></p>
<p><a href="#k08">8. Zákaz name manglingu při překladu</a></p>
<p><a href="#k09">9. Načtení dynamické knihovny bez uvedení cesty ve zdrojovém kódu</a></p>
<p><a href="#k10">10. Předávání struktur mezi Rustem a Pythonem</a></p>
<p><a href="#k11">11. Rustovská část aplikace</a></p>
<p><a href="#k12">12. Skript psaný v&nbsp;Pythonu, který volá funkce z&nbsp;dynamické knihovny</a></p>
<p><a href="#k13">13. Spuštění skriptu, který zavolá funkci pro součet komplexních čísel</a></p>
<p><a href="#k14">14. Předávání struktur odkazem</a></p>
<p><a href="#k15">15. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k16">16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk Rust: rozhraní mezi Rustem a Pythonem</h2>

<p>V&nbsp;předchozích třech částech [<a
href="https://www.root.cz/clanky/programovaci-jazyk-rust-pouziti-ffi-pro-volani-funkci-z-nativnich-knihoven/">1</a>]
[<a
href="https://www.root.cz/clanky/programovaci-jazyk-rust-pouziti-ffi-pro-volani-funkci-z-nativnich-knihoven-2-cast/">2</a>]
[<a
href="https://www.root.cz/clanky/programovaci-jazyk-rust-pouziti-ffi-pri-predavani-struktur/">3</a>]
<a href="https://www.root.cz/serialy/programovaci-jazyk-rust/">seriálu o
programovacím jazyku Rust</a> jsme se zabývali problematikou volání nativních
funkcí (psaných většinou v&nbsp;jazyku C, i když to samozřejmě není nutná
podmínka) z&nbsp;Rustu, a to konkrétně s&nbsp;využitím technologie <a
href="https://doc.rust-lang.org/book/first-edition/ffi.html">FFI</a>
(<i>Foreign Function Interface</i>). Dnes bude programovací jazyk Rust
vystupovat v&nbsp;opačné roli &ndash; programy psané v&nbsp;Rustu již nebudou
&bdquo;konzumenty&ldquo; cizích nativních knihoven ale naopak bude Rust sloužit
pro vytvoření dynamických knihoven, jejichž funkce budeme volat z&nbsp;dalšího
programovacího jazyka, konkrétně z&nbsp;Pythonu. Propojíme tak Rust
s&nbsp;dnes pravděpodobně nejpopulárnějším vysokoúrovňovým programovacím
jazykem současnosti.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Překlad zdrojového kódu Rustu do dynamické knihovny</h2>

<p>Vzhledem k&nbsp;tomu, že překladač programovacího jazyka Rust kompiluje
zdrojové kódy do běžného nativního objektového kódu zpracovávaného linkerem, je
zřejmé, že i v&nbsp;Rustu je možné vytvářet běžné statické i dynamické
knihovny. Musíme ovšem zajistit, aby překladač žádným způsobem nemodifikoval
jména funkcí, protože rustovský překladač implicitně provádí takzvané <a
href="https://en.wikipedia.org/wiki/Name_mangling#Rust">name mangling</a>,
s&nbsp;čímž se většina programátorů pravděpodobně setkala spíše
v&nbsp;souvislosti s&nbsp;programovacím jazykem C++. Pokud tedy v&nbsp;Rustu
<i>name mangling</i> zakážeme a nastavíme správce projektů Cargo takovým
způsobem, aby po překladu vytvořil běžnou dynamickou knihovnu, bude možné tuto
knihovnu bez větších problémů použít v&nbsp;Pythonu (a samozřejmě i
v&nbsp;jakémkoli jiném programovacím jazyku). Na straně Pythonu lze pro volání
nativních funkcí použít například standardní modul <a
href="https://docs.python.org/3.3/library/ctypes.html">ctypes</a> nebo sice
méně známý, ale o to povedenější modul <a
href="https://cffi.readthedocs.io/en/latest/">CFFI</a>. Dnes použité příklady
budou pro jednoduchost používat modul <i>ctypes</i>, který ve svém systému již
pravděpodobně máte nainstalovaný.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Vytvoření projektu pro překlad zdrojového kódu do dynamické knihovny</h2>

<p>Nejprve si ukážeme, jak se s&nbsp;využitím nástroje Cargo vytvoří a následně
nakonfiguruje projekt, který bude sloužit pro vytvoření dynamické knihovny
s&nbsp;přeloženými funkcemi Rustu. Nový projekt vytvoříme nám již známým
příkazem <strong>cargo new</strong>, kterému nyní ovšem <i>ne</i>předáme
přepínač <strong>--bin</strong>, protože výsledkem našeho projektu nemá být
spustitelný program:</p>

<pre>
cargo new test1
</pre>

<p>Tento příkaz by měl vytvořit nový adresář pojmenovaný
<strong>test1</strong>, v&nbsp;němž bude tato struktura souborů a
podadresářů:</p>

<pre>
.
├── Cargo.toml
└── src
    └── lib.rs
</pre>

<p>Nyní je zapotřebí upravit projektový soubor <strong>Cargo.toml</strong>,
konkrétně do něj přidat dva řádky, které jsou na dalším výpisu zvýrazněny.
Těmito řádky se specifikuje &ndash; zjednodušeně řečeno &ndash; typ výsledku
překladu:</p>

<pre>
[package]
name = "test1"
version = "0.1.0"
authors = ["Pavel Tisnovsky &lt;ptisnovs@redhat.com&gt;"]
&nbsp;
<strong>[lib]</strong>
<strong>crate-type = ["dylib"]</strong>
&nbsp;
[dependencies]
</pre>

<p>Specifikujeme, že výsledkem překladu bude dynamická knihovna
<strong>libtest1.so</strong> nebo <strong>test1.dll</strong>.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Zdrojový kód funkce, která se přeloží do dynamické knihovny</h2>

<p>Původní obsah souboru <strong>src/lib.rc</strong> vymažeme a přepíšeme
následujícím obsahem:</p>

<pre>
pub extern fn add_integers(x: i32, y: i32) -&gt; i32 {
    x + y
}
</pre>

<p>Jedná se o nekomplikovanou funkci s&nbsp;jediným výrazem, jehož výsledná
hodnota je současně návratovou hodnotou celé funkce (povšimněte si chybějícího
středníku na konci výrazu).</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Zdrojový kód Pythonovského skriptu, který má dynamickou knihovnu využít</h2>

<p>Nyní je nutné vytvořit druhou část projektu naprogramovanou v&nbsp;Pythonu.
Tato část bude jednoduchá, protože sestává z&nbsp;jediného souboru
<strong>test.py</strong> uloženého v&nbsp;adresáři s&nbsp;projektem (opět pro
jednoduchost, v&nbsp;reálném světě je situace poněkud odlišná):</p>

<pre>
#!/usr/bin/env python3
import ctypes
&nbsp;
testlib1 = ctypes.CDLL("target/debug/libtest1.so")
&nbsp;
result = testlib1.add_integers(1, 2)
print("1 + 2 = {}".format(result))
&nbsp;
result = testlib1.add_integers(1.5, 2)
print("1.5 + 2 = {}".format(result))
</pre>

<p>Povšimněte si, že nejdříve otevřeme dynamickou knihovnu, k&nbsp;níž je
uvedena plná cesta. To není obvyklý způsob, neboť v&nbsp;praxi je lepší se
spolehnout na proměnnou <strong>LD_LIBRARY_PATH</strong>, což si ukážeme
v&nbsp;dalších demonstračních projektech.</p>

<p>Výsledná struktura celého projektu by nyní měla vypadat následovně:</p>

<pre>
.
├── Cargo.toml
├── src
│   └── lib.rs
└── test.py
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Překlad projektu a pokus zavolání funkce z&nbsp;dynamické knihovny</h2>

<p>Překlad rustovské části projektu by měl proběhnout bez větších problémů:</p>

<pre>
<strong>cargo build</strong>
   Compiling test1 v0.1.0 (file:///home/tester/libs/test1)
    Finished debug [unoptimized + debuginfo] target(s) in 0.40 secs
</pre>

<p>Dynamická knihovna by se měla objevit v&nbsp;podadresáři
<strong>target/debug</strong> a měla by mít název <strong>libtest1.so</strong>
(na Windows pravděpodobně <strong>test1.dll</strong>, ale nemám to kde
odzkoušet :-)</p>

<p>Můžete si vytvořit i finální verzi knihovny:</p>

<pre>
$ <strong>cargo build --release</strong>
   Compiling test1 v0.1.0 (file:///home/tester/libs/test1)
    Finished release [optimized] target(s) in 0.44 secs
</pre>

<p>V&nbsp;tomto případě bude dynamická knihovna vytvořena v&nbsp;podadresáři
<strong>target/release</strong>.</p>

<p>Poznámka: po otestování (viz navazující kapitoly) je možné adresář
s&nbsp;projektem vyčistit příkazem:</p>

<pre>
<strong>cargo clean</strong>
</pre>

<p>Pokud si ale zkusíte spustit skript <strong>test.py</strong>, dočkáte se
nemilého překvapení v&nbsp;podobě pádu skriptu (a výpisu stacktrace):</p>

<pre>
Traceback (most recent call last):
  File "./test.py", line 6, in &lt;module&gt;
    result = testlib1.add_integers(1, 2)
  File "/usr/lib/python3.4/ctypes/__init__.py", line 364, in __getattr__
    func = self.__getitem__(name)
  File "/usr/lib/python3.4/ctypes/__init__.py", line 369, in __getitem__
    func = self._FuncPtr((name_or_ordinal, self))
AttributeError: target/debug/libtest1.so: undefined symbol: add_integers
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Name mangling a jeho důsledky</h2>

<p>Proč vlastně došlo k&nbsp;této chybě? Už v&nbsp;úvodním textu jsme si řekli,
že při překladu zdrojového kódu Rustu do nativního kódu je nutné zamezit
takzvanému name manglingu. Pokud se totiž podíváme na obsah vytvořené dynamické
knihovny, tak zjistíme, že naše funkce nazvaná původně
<strong>add_integers</strong> byla během překladu přejmenována:</p>

<pre>
<strong>objdump -t target/debug/libtest1.so |grep add_integers</strong>
00000000000c0be0 g     F .text  0000000000000040              _ZN5test112add_integers17hb1df977e169afd6aE
</pre>

<p>Skript psaný v&nbsp;Pythonu se snaží zavolat nativní funkci pojmenovanou
<strong>_add_integers</strong>, ovšem tu nenajde, našel by teoreticky jen
<strong>_ZN5test112add_integers17hb1df977e169afd6aE</strong>.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Zákaz name manglingu při překladu</h2>

<p>Ve skutečnosti je možné name mangling velmi jednoduše zakázat, minimálně pro
naši funkci, která akceptuje dva celočíselné (tedy primitivní) parametry a
vrací taktéž celočíselný parametr. Postačuje nepatrná úprava zdrojového
kódu:</p>

<pre>
<strong>#[no_mangle]</strong>
pub extern fn add_integers(x: i32, y: i32) -&gt; i32 {
    x + y
}
</pre>

<p>Po překladu si zkontrolujeme, zda byla funkce zařazena do dynamické knihovny
a jaké je její skutečné jméno:</p>

<pre>
$ <strong>objdump -t target/debug/libtest2.so |grep add_integers</strong>
00000000000c0bc0 g     F .text  0000000000000040              add_integers
</pre>

<p>Vidíme, že nyní již jméno neobsahuje žádné &bdquo;magické&ldquo; znaky,
takže tato část aplikace je v&nbsp;pořádku.</p>

<p>Po spuštění Pythonovské části:</p>

<pre>
python test.py
</pre>

<p>Dostaneme následující výstup, který je zcela v&nbsp;pořádku (resp.&nbsp;je
očekávaný):</p>

<pre>
1 + 2 = 3
Traceback (most recent call last):
  File "./test.py", line 9, in &lt;module&gt;
    result = testlib2.add_integers(1.5, 2)
ctypes.ArgumentError: argument 1: &lt;class 'TypeError'&gt;: Don't know how to convert parameter 1
</pre>

<p>První volání funkce <strong>add_integers()</strong> proběhlo v&nbsp;pořádku,
avšak volání druhé skončilo s&nbsp;chybou, protože se nativní funkci snažíme
předat neceločíselný parametr (což je samozřejmě nekorektní, takže pád skriptu
je očekávaný a jedná se o mnohem lepší chování, než kdyby se Python snažil
parametry nějakým způsobem implicitně převádět).</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Načtení dynamické knihovny bez uvedení cesty ve zdrojovém kódu</h2>

<p>Většinou se budeme v&nbsp;praxi snažit, aby se cesta k&nbsp;dynamické
knihovně nemusela do zdrojového kódu nikam zadávat, takže se namísto
skriptu:</p>

<pre>
#!/usr/bin/env python3
import ctypes
&nbsp;
testlib1 = <strong>ctypes.CDLL("target/debug/libtest1.so")</strong>
&nbsp;
...
...
...
</pre>

<p>Použije spíše skript:</p>

<pre>
#!/usr/bin/env python3
import ctypes
&nbsp;
testlib2 = <strong>ctypes.CDLL("libtest2.so")</strong>
&nbsp;
result = testlib2.add_integers(1, 2)
print("1 + 2 = {}".format(result))
&nbsp;
result = testlib2.add_integers(1.5, 2)
print("1.5 + 2 = {}".format(result))
</pre>

<p>V&nbsp;případě, že se pokusíme tento skript spustit, dojde k&nbsp;chybě,
protože knihovna, kterou jsme přeložili, byla uložena do podadresáře, o němž
skript nic neví:</p>

<pre>
Traceback (most recent call last):
  File "./test2.py", line 4, in &lt;module&gt;
    testlib2 = ctypes.CDLL("libtest2.so")
  File "/usr/lib/python3.4/ctypes/__init__.py", line 351, in __init__
    self._handle = _dlopen(self._name, mode)
OSError: <strong>libtest2.so</strong>: cannot open shared object file: No such file or directory
</pre>

<p>Pokud však před spuštěním skriptu nastavíme proměnnou prostředí
<strong>LD_LIBRARY_PATH</strong>, knihovna se bez problému nalezne a skript se
spustí bez chyby:</p>

<pre>
LD_LIBRARY_PATH=target/debug ./test2.py
</pre>

<p>Poznámka: mnohem korektnější by samozřejmě bylo pouze přidat nový adresář do
existujícího obsahu proměnné <strong>LD_LIBRARY_PATH</strong>, tj.&nbsp;provést
tento příkaz:</p>

<pre>
LD_LIBRARY_PATH=$LD_LIBRARY_PATH:target/debug ./test2.py
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Předávání struktur mezi Rustem a Pythonem</h2>

<p>Ve druhé části dnešního článku si ukážeme způsob předávání struktur mezi
Rustem a Pythonem. Připomeňme si, že v&nbsp;Rustu představují struktury
základní (a do značné míry jedinou) technologii pro tvorbu uživatelsky
definovaných heterogenních datových struktur (naproti tomu pole a vektory jsou
struktury homogenní). Oproti primitivním datovým typům je předávání struktur
poněkud složitější, a to zejména na straně Pythonu, protože je nutné explicitně
specifikovat typy prvků a samozřejmě i jejich pořadí. Další problém, který je
někdy nutné řešit, představuje předávání struktur odkazem,
tj.&nbsp;s&nbsp;využitím ukazatelů. I s&nbsp;touto problematikou se postupně
seznámíme.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Rustovská část aplikace</h2>

<p>Ukažme si nyní velmi jednoduchou aplikaci, v&nbsp;níž bude používána datová
struktura reprezentující komplexní číslo a v&nbsp;Rustu bude navíc
implementována funkce pro součet dvou komplexních čísel.</p>

<p>Část aplikace psaná v&nbsp;programovacím jazyku Rust bude nejprve obsahovat
deklaraci struktury nazvané <strong>Complex</strong>. Tuto strukturu již známe
a jedinou změnou je přidání anotace zajišťující překlad podle zvyků
programovacího jazyka C (protože knihovna <i>ctypes</i> počítá s&nbsp;céčkovými
konvencemi):</p>

<pre>
<strong>#[repr(C)]</strong>
pub struct Complex {
    real: f32,
    imag: f32,
}
</pre>

<p>Ve stejném zdrojovém kódu je taktéž uvedena funkce určená pro součet dvou
komplexních čísel. Jedná se o skutečnou funkci, která nijak nemění své
parametry, ale vytváří nové komplexní číslo (to ovšem nemusí být příliš
efektivní, například při práci s&nbsp;vektory či maticemi komplexních
čísel):</p>

<pre>
<strong>#[no_mangle]</strong>
pub extern fn add_complex(c1: Complex, c2: Complex) -&gt; Complex {
    Complex {real: c1.real + c2.real, imag: c1.imag + c2.imag}
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Skript psaný v&nbsp;Pythonu, který volá funkce z&nbsp;dynamické knihovny</h2>

<p>Skript naprogramovaný v&nbsp;Pythonu, který bude volat rustovskou funkci pro
součet komplexních čísel, je již poměrně složitý. Nejdříve si uveďme je úplnou
podobu a potom se zaměříme na popis jednotlivých částí:</p>

<pre>
#!/usr/bin/env python3
import ctypes
&nbsp;
libtest3 = ctypes.CDLL("target/debug/libtest3.so")
&nbsp;
&nbsp;
class Complex(ctypes.Structure):
    _fields_ = [("real", ctypes.c_float), ("imag", ctypes.c_float)]
&nbsp;
    def __str__(self):
        return "Complex: %f + i%f" % (self.real, self.imag)
&nbsp;
&nbsp;
libtest3.add_complex.argtypes = (Complex, Complex)
libtest3.add_complex.restype = Complex
&nbsp;
c1 = Complex(1.0, 2.0)
c2 = Complex(3.0, 4.0)
&nbsp;
c3 = libtest3.add_complex(c1, c2)
&nbsp;
print(c1)
print(c2)
print(c3)
</pre>

<p>Na začátku pouze naimportujeme funkce a typy z&nbsp;modulu
<i>ctypes</i>:</p>

<pre>
#!/usr/bin/env python3
import ctypes
</pre>

<p>Následně se pokusíme načíst novou dynamickou knihovnu s&nbsp;deklarací
struktury <strong>Complex</strong> i s&nbsp;funkcí
<strong>add_complex()</strong>. Samozřejmě zde můžete odstranit cestu ke
knihovně a použít přístup s&nbsp;proměnnou prostředí
<strong>LD_LIBRARY_PATH</strong>:</p>

<pre>
libtest3 = ctypes.CDLL("target/debug/libtest3.so")
</pre>

<p>Následuje poměrně složitá část skriptu, v&nbsp;níž (znovu) deklarujeme
datovou strukturu <strong>Complex</strong>, tentokrát ovšem takovým způsobem,
aby pořadí a typy atributů (<i>fields</i>) přesně odpovídaly rustovské
deklaraci. Všimněte si, jak se atributy popisují &ndash; uvádí se jejich jméno
a datový typ (což je důležité, aby interpret Pythonu mohl strukturu vytvořit
tak, aby byla binárním obrazem céčkovské či rustovské struktury). Navíc si
&ndash; zcela nezávisle na původní struktuře &ndash; můžeme přidat metody,
například metodu <strong>__str__</strong>, která nám umožní nechat si vypsat
obsah komplexního číslo (tedy reálné a imaginární složky).</p>

<pre>
class Complex(ctypes.Structure):
    _fields_ = [("real", ctypes.c_float), ("imag", ctypes.c_float)]
&nbsp;
    def __str__(self):
        return "Complex: %f + i%f" % (self.real, self.imag)
</pre>

<p>Od této chvíle je možné se k&nbsp;třídě <strong>Complex</strong> chovat
prakticky stejně, jako k&nbsp;jakékoli jiné třídě.</p>

<p>Následuje ještě jedná poměrně záludná, ale důležitá část, a to konkrétní
určení typů parametrů funkce <strong>add_complex()</strong> a taktéž přesného
návratového typu této funkce. Připomeňme si, že <strong>libtest3</strong> je
objekt vrácený voláním
<strong>ctypes.CDLL("target/debug/libtest3.so")</strong>:</p>

<pre>
libtest3.add_complex.argtypes = (Complex, Complex)
libtest3.add_complex.restype = Complex
</pre>

<p>Nyní se již můžeme začít chovat ke třídě <strong>Complex</strong> i
k&nbsp;funkci <strong>add_complex()</strong> běžným způsobem &ndash;
následující kód již neobsahuje žádné speciality a při pohledu na něj ani nelze
říct, že by třída <strong>Complex</strong> či funkce
<strong>add_complex()</strong> byla něčím výjimečná:</p>

<pre>
c1 = Complex(1.0, 2.0)
c2 = Complex(3.0, 4.0)
&nbsp;
c3 = libtest3.add_complex(c1, c2)
&nbsp;
print(c1)
print(c2)
print(c3)
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Spuštění skriptu, který zavolá funkci pro součet komplexních čísel</h2>

<p>Po spuštění skriptu by se měly na standardním výstupu objevit hodnoty
uložené do datových struktur <strong>c1</strong> a <strong>c2</strong> i
hodnoty ve vypočtené struktuře <strong>c3</strong>:</p>

<pre>
Complex: 1.000000 + i2.000000
Complex: 3.000000 + i4.000000
Complex: 4.000000 + i6.000000
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Předávání struktur odkazem</h2>

<p>Velmi často se setkáme s&nbsp;nutností předat strukturu do volané funkce
odkazem. Opět se nejdříve podívejme na rustovskou část aplikace, v&nbsp;níž je
deklarována nová funkce, které se předává první komplexní číslo odkazem, což
nám umožňuje měnit jeho atributy (navíc se při volání nemusí struktura
kopírovat):</p>

<pre>
#[repr(C)]
pub struct Complex {
    real: f32,
    imag: f32,
}
&nbsp;
#[no_mangle]
pub extern fn add_complex(c1: Complex, c2: Complex) -&gt; Complex {
    Complex {real: c1.real + c2.real, imag: c1.imag + c2.imag}
}
&nbsp;
#[no_mangle]
pub extern fn add_complex_mut(c1: &amp;mut Complex, c2: Complex) -&gt; () {
    c1.real += c2.real;
    c1.imag += c2.imag;
}
</pre>

<p>Skript napsaný v&nbsp;Pythonu je nepatrně složitější, minimálně v&nbsp;té
části, kde se specifikují typy parametrů funkce
<strong>add_complex_mut()</strong> (viz zvýrazněnou část):</p>

<pre>
#!/usr/bin/env python3
import ctypes
&nbsp;
libtest4 = ctypes.CDLL("target/debug/libtest4.so")
&nbsp;
&nbsp;
class Complex(ctypes.Structure):
    _fields_ = [("real", ctypes.c_float), ("imag", ctypes.c_float)]
&nbsp;
    def __str__(self):
        return "Complex: %f + i%f" % (self.real, self.imag)
&nbsp;
&nbsp;
libtest4.add_complex.argtypes = (Complex, Complex)
libtest4.add_complex.restype = Complex
&nbsp;
<strong>libtest4.add_complex_mut.argtypes = (ctypes.POINTER(Complex), Complex)</strong>
<strong>libtest4.add_complex_mut.restype = None</strong>
&nbsp;
c1 = Complex(1.0, 2.0)
c2 = Complex(3.0, 4.0)
&nbsp;
c3 = libtest4.add_complex(c1, c2)
&nbsp;
print(c1)
print(c2)
print(c3)
&nbsp;
libtest4.add_complex_mut(<strong>ctypes.byref(c1)</strong>, c2)
print(c1)
libtest4.add_complex_mut(<strong>ctypes.byref(c1)</strong>, c2)
print(c1)
</pre>

<p>V&nbsp;závěrečné části skriptu se musí objekt (instance třídy Complex)
převést na referenci (resp.&nbsp;se musí předat reference).</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny čtyři dnes popisované demonstrační příklady (projekty) byly, ostatně
podobně jako ve všech předchozích částech <a
href="https://www.root.cz/serialy/programovaci-jazyk-rust/">tohoto seriálu</a>,
uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě
bez nutnosti klonovat celý repositář (ovšem u projektů je lepší mít celý
repositář, abyste nemuseli pracně stahovat všechny potřebné soubory):</p>

<table>
<tr><th>Příklad</th><th>Adresa</th></tr>
<tr><td>Knihovna číslo 1</td><td>&nbsp;</td></tr>
<tr><td>Cargo.toml</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/libs/test1/Cargo.toml">https://github.com/tisnik/presentations/blob/master/rust/ffi/test1/Cargo.toml</a></td></tr>
<tr><td>lib.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/libs/test1/src/lib.rs">https://github.com/tisnik/presentations/blob/master/rust/libs/test1/src/lib.rs</a></td></tr>
<tr><td>test.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/libs/test1/test.py">https://github.com/tisnik/presentations/blob/master/rust/libs/test1/test.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Knihovna číslo 2</td><td>&nbsp;</td></tr>
<tr><td>Cargo.toml</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/libs/test2/Cargo.toml">https://github.com/tisnik/presentations/blob/master/rust/ffi/test2/Cargo.toml</a></td></tr>
<tr><td>lib.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/libs/test2/src/lib.rs">https://github.com/tisnik/presentations/blob/master/rust/libs/test2/src/lib.rs</a></td></tr>
<tr><td>test.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/libs/test2/test.py">https://github.com/tisnik/presentations/blob/master/rust/libs/test2/test.py</a></td></tr>
<tr><td>test2.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/libs/test2/test2.py">https://github.com/tisnik/presentations/blob/master/rust/libs/test2/test2.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Knihovna číslo 3</td><td>&nbsp;</td></tr>
<tr><td>Cargo.toml</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/libs/test3/Cargo.toml">https://github.com/tisnik/presentations/blob/master/rust/ffi/test3/Cargo.toml</a></td></tr>
<tr><td>lib.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/libs/test3/src/lib.rs">https://github.com/tisnik/presentations/blob/master/rust/libs/test3/src/lib.rs</a></td></tr>
<tr><td>test.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/libs/test3/test.py">https://github.com/tisnik/presentations/blob/master/rust/libs/test3/test.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Knihovna číslo 4</td><td>&nbsp;</td></tr>
<tr><td>Cargo.toml</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/libs/test4/Cargo.toml">https://github.com/tisnik/presentations/blob/master/rust/ffi/test4/Cargo.toml</a></td></tr>
<tr><td>lib.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/libs/test4/src/lib.rs">https://github.com/tisnik/presentations/blob/master/rust/libs/test4/src/lib.rs</a></td></tr>
<tr><td>test.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/libs/test4/test.py">https://github.com/tisnik/presentations/blob/master/rust/libs/test4/test.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
</table>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>Calling Rust From Python<br />
<a href="https://bheisler.github.io/post/calling-rust-in-python/">https://bheisler.github.io/post/calling-rust-in-python/</a>
</li>

<li>Calling Rust in Python (komentáře k předchozímu článku)<br />
<a href="https://www.reddit.com/r/rust/comments/63iy5a/calling_rust_in_python/">https://www.reddit.com/r/rust/comments/63iy5a/calling_rust_in_python/</a>
</li>

<li>CFFI Documentation<br />
<a href="https://cffi.readthedocs.io/en/latest/">https://cffi.readthedocs.io/en/latest/</a>
</li>

<li>Build Script Support<br />
<a href="http://doc.crates.io/build-script.html">http://doc.crates.io/build-script.html</a>
</li>

<li>Creating a shared and static library with the gnu compiler [gcc]<br />
<a href="http://www.adp-gmbh.ch/cpp/gcc/create_lib.html">http://www.adp-gmbh.ch/cpp/gcc/create_lib.html</a>
</li>

<li>ctypes — A foreign function library for Python<br />
<a href="https://docs.python.org/2/library/ctypes.html">https://docs.python.org/2/library/ctypes.html</a>
</li>

<li>FFI: Foreign Function Interface<br />
<a href="https://doc.rust-lang.org/book/ffi.html">https://doc.rust-lang.org/book/ffi.html</a>
</li>

<li>Primitive Type pointer<br />
<a href="https://doc.rust-lang.org/std/primitive.pointer.html">https://doc.rust-lang.org/std/primitive.pointer.html</a>
</li>

<li>Cargo: správce projektů a balíčků pro programovací jazyk Rust<br />
<a href="https://mojefedora.cz/cargo-spravce-projektu-a-balicku-pro-programovaci-jazyk-rust/">https://mojefedora.cz/cargo-spravce-projektu-a-balicku-pro-programovaci-jazyk-rust/</a>
</li>

<li>Network Communication and Serialization in Rust<br />
<a href="https://www.safaribooksonline.com/blog/2014/01/28/network-communication-serialization-rust/">https://www.safaribooksonline.com/blog/2014/01/28/network-communication-serialization-rust/</a>
</li>

<li>Crate bincode<br />
<a href="http://tyoverby.com/bincode/bincode/index.html">http://tyoverby.com/bincode/bincode/index.html</a>
</li>

<li>Struct std::fs::File<br />
<a href="https://doc.rust-lang.org/std/fs/struct.File.html">https://doc.rust-lang.org/std/fs/struct.File.html</a>
</li>

<li>Trait std::io::Seek<br />
<a href="https://doc.rust-lang.org/std/io/trait.Seek.html">https://doc.rust-lang.org/std/io/trait.Seek.html</a>
</li>

<li>Trait std::io::Read<br />
<a href="https://doc.rust-lang.org/std/io/trait.Read.html">https://doc.rust-lang.org/std/io/trait.Read.html</a>
</li>

<li>Trait std::io::Write<br />
<a href="https://doc.rust-lang.org/std/io/trait.Write.html">https://doc.rust-lang.org/std/io/trait.Write.html</a>
</li>

<li>Trait std::io::BufRead<br />
<a href="https://doc.rust-lang.org/std/io/trait.BufRead.html">https://doc.rust-lang.org/std/io/trait.BufRead.html</a>
</li>

<li>Module std::io::prelude<br />
<a href="https://doc.rust-lang.org/std/io/prelude/index.html">https://doc.rust-lang.org/std/io/prelude/index.html</a>
</li>

<li>std::net::IpAddr<br />
<a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">https://doc.rust-lang.org/std/net/enum.IpAddr.html</a>
</li>

<li>std::net::Ipv4Addr<br />
<a href="https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html">https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html</a>
</li>

<li>std::net::Ipv6Addr<br />
<a href="https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html">https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html</a>
</li>

<li>TcpListener<br />
<a href="https://doc.rust-lang.org/std/net/struct.TcpListener.html">https://doc.rust-lang.org/std/net/struct.TcpListener.html</a>
</li>

<li>TcpStream<br />
<a href="https://doc.rust-lang.org/std/net/struct.TcpStream.html">https://doc.rust-lang.org/std/net/struct.TcpStream.html</a>
</li>

<li>Binary heap (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Binary_heap">https://en.wikipedia.org/wiki/Binary_heap</a>
</li>

<li>Binární halda (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_halda">https://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_halda</a>
</li>

<li>Halda (datová struktura)<br />
<a href="https://cs.wikipedia.org/wiki/Halda_%28datov%C3%A1_struktura%29">https://cs.wikipedia.org/wiki/Halda_%28datov%C3%A1_struktura%29</a>
</li>

<li>Struct std::collections::HashSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html">https://doc.rust-lang.org/std/collections/struct.HashSet.html</a>
</li>

<li>Struct std::collections::BTreeSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html">https://doc.rust-lang.org/std/collections/struct.BTreeSet.html</a>
</li>

<li>Struct std::collections::BinaryHeap<br />
<a href="https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html">https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html</a>
</li>

<li>Set (abstract data type)<br />
<a href="https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support">https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support</a>
</li>

<li>Associative array<br />
<a href="https://en.wikipedia.org/wiki/Associative_array">https://en.wikipedia.org/wiki/Associative_array</a>
</li>

<li>Hash Table<br />
<a href="https://en.wikipedia.org/wiki/Hash_table">https://en.wikipedia.org/wiki/Hash_table</a>
</li>

<li>B-tree<br />
<a href="https://en.wikipedia.org/wiki/B-tree">https://en.wikipedia.org/wiki/B-tree</a>
</li>

<li>Pedro Celis: Robin Hood Hashing (naskenované PDF!)<br />
<a href="https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf">https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf</a>
</li>

<li>Robin Hood hashing<br />
<a href="http://codecapsule.com/2013/11/11/robin-hood-hashing/">http://codecapsule.com/2013/11/11/robin-hood-hashing/</a>
</li>

<li>Robin Hood hashing: backward shift deletion<br />
<a href="http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/">http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/</a>
</li>

<li>Module std::collections<br />
<a href="https://doc.rust-lang.org/std/collections/">https://doc.rust-lang.org/std/collections/</a>
</li>

<li>Module std::vec<br />
<a href="https://doc.rust-lang.org/nightly/std/vec/index.html">https://doc.rust-lang.org/nightly/std/vec/index.html</a>
</li>

<li>Struct std::collections::VecDeque<br />
<a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html">https://doc.rust-lang.org/std/collections/struct.VecDeque.html</a>
</li>

<li>Struct std::collections::LinkedList<br />
<a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html">https://doc.rust-lang.org/std/collections/struct.LinkedList.html</a>
</li>

<li>Module std::fmt<br />
<a href="https://doc.rust-lang.org/std/fmt/">https://doc.rust-lang.org/std/fmt/</a>
</li>

<li>Macro std::println<br />
<a href="https://doc.rust-lang.org/std/macro.println.html">https://doc.rust-lang.org/std/macro.println.html</a>
</li>

<li>Enum std::result::Result<br />
<a href="https://doc.rust-lang.org/std/result/enum.Result.html">https://doc.rust-lang.org/std/result/enum.Result.html</a>
</li>

<li>Module std::result<br />
<a href="https://doc.rust-lang.org/std/result/">https://doc.rust-lang.org/std/result/</a>
</li>

<li>Result<br />
<a href="http://rustbyexample.com/std/result.html">http://rustbyexample.com/std/result.html</a>
</li>

<li>Rust stdlib: Option<br />
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">https://doc.rust-lang.org/std/option/enum.Option.html</a>
</li>

<li>Module std::option<br />
<a href="https://doc.rust-lang.org/std/option/index.html">https://doc.rust-lang.org/std/option/index.html</a>
</li>

<li>Rust by example: option<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>Rust by example: if-let<br />
<a href="http://rustbyexample.com/flow_control/if_let.html">http://rustbyexample.com/flow_control/if_let.html</a>
</li>

<li>Rust by example: while let<br />
<a href="http://rustbyexample.com/flow_control/while_let.html">http://rustbyexample.com/flow_control/while_let.html</a>
</li>

<li>Rust by example: Option&lt;i32&gt;<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>An Overview of Macros in Rust<br />
<a href="http://words.steveklabnik.com/an-overview-of-macros-in-rust">http://words.steveklabnik.com/an-overview-of-macros-in-rust</a>
</li>

<li>A Practical Intro to Macros in Rust 1.0<br />
<a href="https://danielkeep.github.io/practical-intro-to-macros.html">https://danielkeep.github.io/practical-intro-to-macros.html</a>
</li>

<li>The Rust Programming Language: macros<br />
<a href="https://doc.rust-lang.org/beta/book/macros.html">https://doc.rust-lang.org/beta/book/macros.html</a>
</li>

<li>Rust by example: 15 macro_rules!<br />
<a href="http://rustbyexample.com/macros.html">http://rustbyexample.com/macros.html</a>
</li>

<li>Primitive Type isize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.isize.html">https://doc.rust-lang.org/nightly/std/primitive.isize.html</a>
</li>

<li>Primitive Type usize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">https://doc.rust-lang.org/nightly/std/primitive.usize.html</a>
</li>

<li>Primitive Type array<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.array.html">https://doc.rust-lang.org/nightly/std/primitive.array.html</a>
</li>

<li>Module std::slice<br />
<a href="https://doc.rust-lang.org/nightly/std/slice/">https://doc.rust-lang.org/nightly/std/slice/</a>
</li>

<li>Rust by Example: 2.3 Arrays and Slices<br />
<a href="http://rustbyexample.com/primitives/array.html">http://rustbyexample.com/primitives/array.html</a>
</li>

<li>What is the difference between Slice and Array (stackoverflow)<br />
<a href="http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array">http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array</a>
</li>

<li>Learning Rust With Entirely Too Many Linked Lists<br />
<a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/">http://cglab.ca/~abeinges/blah/too-many-lists/book/</a>
</li>

<li>Testcase: linked list<br />
<a href="http://rustbyexample.com/custom_types/enum/testcase_linked_list.html">http://rustbyexample.com/custom_types/enum/testcase_linked_list.html</a>
</li>

<li>Operators and Overloading<br />
<a href="https://doc.rust-lang.org/book/operators-and-overloading.html">https://doc.rust-lang.org/book/operators-and-overloading.html</a>
</li>

<li>Module std::ops<br />
<a href="https://doc.rust-lang.org/std/ops/index.html">https://doc.rust-lang.org/std/ops/index.html</a>
</li>

<li>Module std::cmp<br />
<a href="https://doc.rust-lang.org/std/cmp/index.html">https://doc.rust-lang.org/std/cmp/index.html</a>
</li>

<li>Trait std::ops::Add<br />
<a href="https://doc.rust-lang.org/stable/std/ops/trait.Add.html">https://doc.rust-lang.org/stable/std/ops/trait.Add.html</a>
</li>

<li>Trait std::ops::AddAssign<br />
<a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html">https://doc.rust-lang.org/std/ops/trait.AddAssign.html</a>
</li>

<li>Trait std::ops::Drop<br />
<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">https://doc.rust-lang.org/std/ops/trait.Drop.html</a>
</li>

<li>Trait std::cmp::Eq<br />
<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">https://doc.rust-lang.org/std/cmp/trait.Eq.html</a>
</li>

<li>Struct std::boxed::Box<br />
<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">https://doc.rust-lang.org/std/boxed/struct.Box.html</a>
</li>

<li>Explore the ownership system in Rust<br />
<a href="https://nercury.github.io/rust/guide/2015/01/19/ownership.html">https://nercury.github.io/rust/guide/2015/01/19/ownership.html</a>
</li>

<li>Rust's ownership and move semantic<br/>
<a href="http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics">http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics</a>
</li>

<li>Trait std::marker::Copy<br/>
<a href="https://doc.rust-lang.org/stable/std/marker/trait.Copy.html">https://doc.rust-lang.org/stable/std/marker/trait.Copy.html</a>
</li>

<li>Trait std::clone::Clone<br />
<a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html">https://doc.rust-lang.org/stable/std/clone/trait.Clone.html</a>
</li>

<li>The Stack and the Heap<br />
<a href="https://doc.rust-lang.org/book/the-stack-and-the-heap.html">https://doc.rust-lang.org/book/the-stack-and-the-heap.html</a>
</li>

<li>Rust Compare: Pointers &amp; References<br />
<a href="http://www.rust-compare.com/site/pointers.html">http://www.rust-compare.com/site/pointers.html</a>
</li>

<li>Rust Compare: Parameters<br />
<a href="http://www.rust-compare.com/site/params.html">http://www.rust-compare.com/site/params.html</a>
</li>

<li>Why does this compile? Automatic dereferencing?<br />
<a href="https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183">https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183</a>
</li>

<li>Understanding Pointers, Ownership, and Lifetimes in Rust<br />
<a href="http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html">http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html</a>
</li>

<li>Rust lang series episode #25 — pointers (#rust-series)<br />
<a href="https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series">https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series</a>
</li>

<li>Rust - home page<br />
<a href="https://www.rust-lang.org/en-US/">https://www.rust-lang.org/en-US/</a>
</li>

<li>Rust - Frequently Asked Questions<br />
<a href="https://www.rust-lang.org/en-US/faq.html">https://www.rust-lang.org/en-US/faq.html</a>
</li>

<li>Destructuring and Pattern Matching<br />
<a href="https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/">https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/</a>
</li>

<li>The Rust Programming Language<br />
<a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>
</li>

<li>Rust (programming language)<br />
<a href="https://en.wikipedia.org/wiki/Rust_%28programming_language%29">https://en.wikipedia.org/wiki/Rust_%28programming_language%29</a>
</li>

<li>Go - home page<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>Stack Overflow - Most Loved, Dreaded, and Wanted language<br />
<a href="https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted">https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted</a>
</li>

<li>Rust vs Go (dva roky staré hodnocení, od té doby došlo k posunům v obou jazycích)<br />
<a href="http://jaredforsyth.com/2014/03/22/rust-vs-go/">http://jaredforsyth.com/2014/03/22/rust-vs-go/</a>
</li>

<li>Rust vs Go: My experience<br />
<a href="https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/">https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/</a>
</li>

<li>Friends of Rust (Organizations running Rust in production)<br />
<a href="https://www.rust-lang.org/en-US/friends.html">https://www.rust-lang.org/en-US/friends.html</a>
</li>

<li>Rust programs versus C++ g++<br />
<a href="https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp">https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp</a>
</li>

<li>Další benchmarky (nejedná se o reálné příklady &bdquo;ze života&ldquo;)<br />
<a href="https://github.com/kostya/benchmarks">https://github.com/kostya/benchmarks</a>
</li>

<li>Go na Redditu<br />
<a href="https://www.reddit.com/r/golang/">https://www.reddit.com/r/golang/</a>
</li>

<li>Rust vs. Go<br />
<a href="http://vschart.com/compare/rust/vs/go-language">http://vschart.com/compare/rust/vs/go-language</a>
</li>

<li>Abstraction without overhead: traits in Rust<br />
<a href="https://blog.rust-lang.org/2015/05/11/traits.html">https://blog.rust-lang.org/2015/05/11/traits.html</a>
</li>

<li>Method Syntax<br />
<a href="https://doc.rust-lang.org/book/method-syntax.html">https://doc.rust-lang.org/book/method-syntax.html</a>
</li>

<li>Traits in Rust<br />
<a href="https://doc.rust-lang.org/book/traits.html">https://doc.rust-lang.org/book/traits.html</a>
</li>

<li>Functional Programming in Rust - Part 1 : Function Abstraction<br />
<a href="http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/">http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/</a>
</li>

<li>Of the emerging systems languages Rust, D, Go and Nim, which is the strongest language and why?<br />
<a href="https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why">https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why</a>
</li>

<li>Chytré ukazatele (moderní verze jazyka C++) [MSDN]<br />
<a href="https://msdn.microsoft.com/cs-cz/library/hh279674.aspx">https://msdn.microsoft.com/cs-cz/library/hh279674.aspx</a>
</li>

<li>UTF-8 Everywhere<br />
<a href="http://utf8everywhere.org/">http://utf8everywhere.org/</a>
</li>

<li>Rust by Example<br />
<a href="http://rustbyexample.com/">http://rustbyexample.com/</a>
</li>

<li>Rust oficiálně ve Fedoře<br />
<a href="https://mojefedora.cz/rust-oficialne-ve-fedore/">https://mojefedora.cz/rust-oficialne-ve-fedore/</a>
</li>

<li>Resource acquisition is initialization<br />
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization</a>
</li>

<li>TIOBE index (October 2016)<br />
<a href="http://www.tiobe.com/tiobe-index/">http://www.tiobe.com/tiobe-index/</a>
</li>

<li>Porovnání Go, D a Rustu na OpenHubu:<br />
<a href="https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits">https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits</a>
</li>

<li>String Types in Rust<br />
<a href="http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/">http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/</a>
</li>

<li>Trait (computer programming)<br />
<a href="https://en.wikipedia.org/wiki/Trait_%28computer_programming%29">https://en.wikipedia.org/wiki/Trait_%28computer_programming%29</a>
</li>

<li>Type inference<br />
<a href="https://en.wikipedia.org/wiki/Type_inference">https://en.wikipedia.org/wiki/Type_inference</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

